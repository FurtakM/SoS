// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 80357 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 44367 0 9
// PrepareGensher ;
 189: CALL 3160 0 0
// PreparePopov ;
 193: CALL 6371 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 9059 0 0
// MC_Start ( ) ;
 205: CALL 52043 0 0
// Action ;
 209: CALL 9466 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 4294 0 0
// InitMC_Powell ( ) ;
 284: CALL 1515 0 0
// InitMC_Popov ( ) ;
 288: CALL 7529 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
 599: PPUSH
// powell_side := 4 ;
 600: LD_ADDR_EXP 11
 604: PUSH
 605: LD_INT 4
 607: ST_TO_ADDR
// uc_side := powell_side ;
 608: LD_ADDR_OWVAR 20
 612: PUSH
 613: LD_EXP 11
 617: ST_TO_ADDR
// uc_nation := 1 ;
 618: LD_ADDR_OWVAR 21
 622: PUSH
 623: LD_INT 1
 625: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 626: LD_ADDR_EXP 10
 630: PUSH
 631: LD_STRING Powell
 633: PPUSH
 634: CALL_OW 25
 638: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 639: LD_EXP 10
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 7
 649: PPUSH
 650: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 654: LD_EXP 10
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 5
 664: PPUSH
 665: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 669: LD_EXP 10
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: LD_INT 6
 679: PPUSH
 680: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 684: LD_EXP 10
 688: PPUSH
 689: LD_INT 4
 691: PPUSH
 692: LD_INT 4
 694: PPUSH
 695: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 699: LD_EXP 10
 703: PPUSH
 704: LD_INT 4
 706: PPUSH
 707: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 711: LD_ADDR_VAR 0 3
 715: PUSH
 716: LD_INT 5
 718: PUSH
 719: LD_INT 178
 721: PUSH
 722: LD_INT 117
 724: PUSH
 725: LD_INT 2
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 29
 736: PUSH
 737: LD_INT 167
 739: PUSH
 740: LD_INT 102
 742: PUSH
 743: LD_INT 0
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 6
 754: PUSH
 755: LD_INT 200
 757: PUSH
 758: LD_INT 111
 760: PUSH
 761: LD_INT 4
 763: PUSH
 764: LD_INT 10
 766: PUSH
 767: LD_INT 11
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 201
 783: PUSH
 784: LD_INT 140
 786: PUSH
 787: LD_INT 4
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 27
 798: PUSH
 799: LD_INT 206
 801: PUSH
 802: LD_INT 124
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 27
 816: PUSH
 817: LD_INT 209
 819: PUSH
 820: LD_INT 128
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_INT 27
 834: PUSH
 835: LD_INT 211
 837: PUSH
 838: LD_INT 132
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 173
 855: PUSH
 856: LD_INT 83
 858: PUSH
 859: LD_INT 3
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 6
 870: PUSH
 871: LD_INT 186
 873: PUSH
 874: LD_INT 103
 876: PUSH
 877: LD_INT 2
 879: PUSH
 880: LD_INT 12
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: PUSH
 894: LD_INT 33
 896: PUSH
 897: LD_INT 173
 899: PUSH
 900: LD_INT 99
 902: PUSH
 903: LD_INT 2
 905: PUSH
 906: LD_INT 6
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 32
 918: PUSH
 919: LD_INT 174
 921: PUSH
 922: LD_INT 102
 924: PUSH
 925: LD_INT 2
 927: PUSH
 928: LD_INT 6
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PUSH
 938: LD_INT 32
 940: PUSH
 941: LD_INT 178
 943: PUSH
 944: LD_INT 100
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 6
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 33
 962: PUSH
 963: LD_INT 174
 965: PUSH
 966: LD_INT 108
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: LD_INT 7
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 33
 984: PUSH
 985: LD_INT 182
 987: PUSH
 988: LD_INT 122
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 7
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 36
1006: PUSH
1007: LD_INT 194
1009: PUSH
1010: LD_INT 124
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: LD_INT 184
1027: PUSH
1028: LD_INT 141
1030: PUSH
1031: LD_INT 1
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: PUSH
1044: LD_INT 33
1046: PUSH
1047: LD_INT 183
1049: PUSH
1050: LD_INT 131
1052: PUSH
1053: LD_INT 2
1055: PUSH
1056: LD_INT 11
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_INT 33
1068: PUSH
1069: LD_INT 194
1071: PUSH
1072: LD_INT 146
1074: PUSH
1075: LD_INT 4
1077: PUSH
1078: LD_INT 7
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: LD_INT 33
1090: PUSH
1091: LD_INT 190
1093: PUSH
1094: LD_INT 142
1096: PUSH
1097: LD_INT 4
1099: PUSH
1100: LD_INT 7
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 28
1112: PUSH
1113: LD_INT 204
1115: PUSH
1116: LD_INT 133
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 201
1133: PUSH
1134: LD_INT 133
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 28
1148: PUSH
1149: LD_INT 199
1151: PUSH
1152: LD_INT 119
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: ST_TO_ADDR
// for i in list do
1188: LD_ADDR_VAR 0 2
1192: PUSH
1193: LD_VAR 0 3
1197: PUSH
1198: FOR_IN
1199: IFFALSE 1377
// begin uc_side := 4 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 4
1208: ST_TO_ADDR
// uc_nation := 1 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// bc_kind1 := - 1 ;
1231: LD_ADDR_OWVAR 44
1235: PUSH
1236: LD_INT 1
1238: NEG
1239: ST_TO_ADDR
// bc_kind2 := - 1 ;
1240: LD_ADDR_OWVAR 45
1244: PUSH
1245: LD_INT 1
1247: NEG
1248: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1249: LD_VAR 0 2
1253: PUSH
1254: LD_INT 1
1256: ARRAY
1257: PUSH
1258: LD_INT 6
1260: EQUAL
1261: IFFALSE 1299
// begin bc_type := b_lab_full ;
1263: LD_ADDR_OWVAR 42
1267: PUSH
1268: LD_INT 8
1270: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1271: LD_ADDR_OWVAR 44
1275: PUSH
1276: LD_VAR 0 2
1280: PUSH
1281: LD_INT 5
1283: ARRAY
1284: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1285: LD_ADDR_OWVAR 45
1289: PUSH
1290: LD_VAR 0 2
1294: PUSH
1295: LD_INT 6
1297: ARRAY
1298: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1299: LD_ADDR_VAR 0 4
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 2
1311: ARRAY
1312: PPUSH
1313: LD_VAR 0 2
1317: PUSH
1318: LD_INT 3
1320: ARRAY
1321: PPUSH
1322: LD_VAR 0 2
1326: PUSH
1327: LD_INT 4
1329: ARRAY
1330: PPUSH
1331: CALL_OW 47
1335: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1336: LD_VAR 0 2
1340: PUSH
1341: LD_INT 1
1343: ARRAY
1344: PUSH
1345: LD_INT 33
1347: PUSH
1348: LD_INT 32
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: IN
1355: IFFALSE 1375
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1357: LD_VAR 0 4
1361: PPUSH
1362: LD_VAR 0 2
1366: PUSH
1367: LD_INT 5
1369: ARRAY
1370: PPUSH
1371: CALL_OW 431
// end ;
1375: GO 1198
1377: POP
1378: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1379: LD_ADDR_VAR 0 5
1383: PUSH
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_STRING 
1392: PPUSH
1393: LD_INT 8
1395: PUSH
1396: LD_INT 7
1398: PUSH
1399: LD_INT 6
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: PUSH
1407: LD_OWVAR 67
1411: ARRAY
1412: PPUSH
1413: LD_INT 5500
1415: PUSH
1416: LD_INT 500
1418: PUSH
1419: LD_INT 0
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: LIST
1426: PPUSH
1427: LD_INT 6
1429: PUSH
1430: LD_INT 6
1432: PUSH
1433: LD_INT 6
1435: PUSH
1436: LD_INT 6
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 19314 0 6
1449: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1450: LD_ADDR_EXP 23
1454: PUSH
1455: LD_EXP 23
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: LD_VAR 0 5
1467: PUSH
1468: LD_INT 22
1470: PUSH
1471: LD_INT 4
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: PUSH
1478: LD_INT 21
1480: PUSH
1481: LD_INT 3
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PPUSH
1492: CALL_OW 69
1496: UNION
1497: PPUSH
1498: CALL_OW 1
1502: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1503: LD_ADDR_EXP 12
1507: PUSH
1508: EMPTY
1509: ST_TO_ADDR
// end ;
1510: LD_VAR 0 1
1514: RET
// export function InitMC_Powell ( ) ; begin
1515: LD_INT 0
1517: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1518: LD_INT 1
1520: PPUSH
1521: LD_INT 1
1523: PPUSH
1524: CALL 75224 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1528: LD_INT 1
1530: PPUSH
1531: LD_INT 6
1533: PPUSH
1534: CALL 75168 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1538: LD_INT 1
1540: PPUSH
1541: LD_INT 167
1543: PUSH
1544: LD_INT 102
1546: PUSH
1547: LD_INT 0
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 173
1557: PUSH
1558: LD_INT 83
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 171
1571: PUSH
1572: LD_INT 141
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 178
1585: PUSH
1586: LD_INT 148
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: PPUSH
1603: CALL 74227 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1607: LD_INT 1
1609: PPUSH
1610: LD_INT 11
1612: PUSH
1613: LD_INT 6
1615: PUSH
1616: LD_INT 7
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PPUSH
1624: CALL 75056 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 5
1633: PPUSH
1634: CALL 74738 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 4
1643: PPUSH
1644: CALL 74469 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1648: LD_INT 1
1650: PPUSH
1651: LD_INT 4
1653: PPUSH
1654: CALL 74088 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 3
1663: PUSH
1664: LD_INT 1
1666: PUSH
1667: LD_INT 2
1669: PUSH
1670: LD_INT 5
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: PUSH
1679: LD_INT 4
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 6
1690: PUSH
1691: EMPTY
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_INT 4
1699: PUSH
1700: LD_INT 1
1702: PUSH
1703: LD_INT 2
1705: PUSH
1706: LD_INT 7
1708: PUSH
1709: EMPTY
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 6
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: PUSH
1733: EMPTY
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PPUSH
1739: CALL 73903 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1743: LD_INT 1
1745: PPUSH
1746: LD_INT 201
1748: PPUSH
1749: LD_INT 140
1751: PPUSH
1752: LD_INT 4
1754: PPUSH
1755: LD_INT 19
1757: PUSH
1758: LD_INT 16
1760: PUSH
1761: LD_INT 17
1763: PUSH
1764: LD_INT 18
1766: PUSH
1767: LD_INT 22
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 74850 0 5
// end ;
1781: LD_VAR 0 1
1785: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1786: LD_INT 4
1788: PPUSH
1789: CALL_OW 302
1793: IFFALSE 2453
1795: GO 1797
1797: DISABLE
1798: LD_INT 0
1800: PPUSH
1801: PPUSH
1802: PPUSH
1803: PPUSH
1804: PPUSH
// begin enable ;
1805: ENABLE
// base := 1 ;
1806: LD_ADDR_VAR 0 2
1810: PUSH
1811: LD_INT 1
1813: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: LD_INT 4
1821: PUSH
1822: LD_INT 1
1824: PUSH
1825: LD_INT 2
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 4
1839: PUSH
1840: LD_INT 1
1842: PUSH
1843: LD_INT 2
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: LD_INT 1
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: LD_INT 7
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PUSH
1873: LD_INT 3
1875: PUSH
1876: LD_INT 1
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 7
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_OWVAR 1
1911: PUSH
1912: LD_INT 21000
1914: DIV
1915: PLUS
1916: ST_TO_ADDR
// if amount > 8 then
1917: LD_VAR 0 5
1921: PUSH
1922: LD_INT 8
1924: GREATER
1925: IFFALSE 1935
// amount := 8 ;
1927: LD_ADDR_VAR 0 5
1931: PUSH
1932: LD_INT 8
1934: ST_TO_ADDR
// for i = 1 to amount do
1935: LD_ADDR_VAR 0 1
1939: PUSH
1940: DOUBLE
1941: LD_INT 1
1943: DEC
1944: ST_TO_ADDR
1945: LD_VAR 0 5
1949: PUSH
1950: FOR_TO
1951: IFFALSE 2035
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1953: LD_ADDR_VAR 0 3
1957: PUSH
1958: LD_VAR 0 3
1962: PPUSH
1963: LD_VAR 0 3
1967: PUSH
1968: LD_INT 1
1970: PLUS
1971: PPUSH
1972: LD_INT 3
1974: PUSH
1975: LD_INT 4
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 2
1987: PPUSH
1988: CALL_OW 12
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 2
1999: PUSH
2000: LD_INT 7
2002: PUSH
2003: LD_INT 5
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
2033: GO 1950
2035: POP
2036: POP
// MC_InsertProduceList ( base , tmp ) ;
2037: LD_VAR 0 2
2041: PPUSH
2042: LD_VAR 0 3
2046: PPUSH
2047: CALL 73951 0 2
// repeat wait ( 0 0$1 ) ;
2051: LD_INT 35
2053: PPUSH
2054: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_INT 1
2065: PPUSH
2066: CALL 75369 0 2
2070: PUSH
2071: LD_VAR 0 5
2075: GREATEREQUAL
2076: IFFALSE 2051
// wait ( 0 0$30 ) ;
2078: LD_INT 1050
2080: PPUSH
2081: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2085: LD_ADDR_VAR 0 4
2089: PUSH
2090: LD_EXP 42
2094: PUSH
2095: LD_VAR 0 2
2099: ARRAY
2100: PUSH
2101: LD_EXP 42
2105: PUSH
2106: LD_VAR 0 2
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PUSH
2115: LD_INT 34
2117: PUSH
2118: LD_INT 12
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 34
2127: PUSH
2128: LD_INT 13
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 34
2137: PUSH
2138: LD_INT 14
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: PPUSH
2151: CALL_OW 72
2155: DIFF
2156: ST_TO_ADDR
// if not attackers then
2157: LD_VAR 0 4
2161: NOT
2162: IFFALSE 2166
// exit ;
2164: GO 2453
// DialogPowellsAttack ;
2166: CALL 9597 0 0
// powellAttackGroup := attackers ;
2170: LD_ADDR_EXP 12
2174: PUSH
2175: LD_VAR 0 4
2179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2180: LD_ADDR_EXP 42
2184: PUSH
2185: LD_EXP 42
2189: PPUSH
2190: LD_VAR 0 2
2194: PPUSH
2195: LD_EXP 42
2199: PUSH
2200: LD_VAR 0 2
2204: ARRAY
2205: PUSH
2206: LD_VAR 0 4
2210: DIFF
2211: PPUSH
2212: CALL_OW 1
2216: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2217: LD_EXP 9
2221: PUSH
2222: LD_INT 16
2224: PPUSH
2225: LD_INT 81
2227: PUSH
2228: LD_INT 4
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PPUSH
2235: CALL_OW 70
2239: AND
2240: IFFALSE 2259
// ComAgressiveMove ( attackers , 135 , 21 ) else
2242: LD_VAR 0 4
2246: PPUSH
2247: LD_INT 135
2249: PPUSH
2250: LD_INT 21
2252: PPUSH
2253: CALL_OW 114
2257: GO 2274
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2259: LD_VAR 0 4
2263: PPUSH
2264: LD_INT 146
2266: PPUSH
2267: LD_INT 103
2269: PPUSH
2270: CALL_OW 114
// wait ( 0 0$5 ) ;
2274: LD_INT 175
2276: PPUSH
2277: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2281: LD_INT 35
2283: PPUSH
2284: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2288: LD_VAR 0 4
2292: PPUSH
2293: LD_INT 60
2295: PUSH
2296: EMPTY
2297: LIST
2298: PPUSH
2299: CALL_OW 72
2303: NOT
2304: IFFALSE 2281
// if FilterAllUnits ( [ f_side , 3 ] ) then
2306: LD_INT 22
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: IFFALSE 2339
// ComAgressiveMove ( attackers , 102 , 116 ) else
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 102
2329: PPUSH
2330: LD_INT 116
2332: PPUSH
2333: CALL_OW 114
2337: GO 2354
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 66
2346: PPUSH
2347: LD_INT 41
2349: PPUSH
2350: CALL_OW 114
// wait ( 0 0$10 ) ;
2354: LD_INT 350
2356: PPUSH
2357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2361: LD_INT 35
2363: PPUSH
2364: CALL_OW 67
// for i in attackers do
2368: LD_ADDR_VAR 0 1
2372: PUSH
2373: LD_VAR 0 4
2377: PUSH
2378: FOR_IN
2379: IFFALSE 2429
// if not HasTask ( i ) then
2381: LD_VAR 0 1
2385: PPUSH
2386: CALL_OW 314
2390: NOT
2391: IFFALSE 2427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 81
2400: PUSH
2401: LD_INT 4
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PPUSH
2408: CALL_OW 69
2412: PPUSH
2413: LD_VAR 0 1
2417: PPUSH
2418: CALL_OW 74
2422: PPUSH
2423: CALL_OW 115
2427: GO 2378
2429: POP
2430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2431: LD_VAR 0 4
2435: PPUSH
2436: LD_INT 50
2438: PUSH
2439: EMPTY
2440: LIST
2441: PPUSH
2442: CALL_OW 72
2446: NOT
2447: IFFALSE 2361
// DialogPowellsAttackFailed ;
2449: CALL 9862 0 0
// end ;
2453: PPOPN 5
2455: END
// every 0 0$2 do var vehicles , mechs , i ;
2456: GO 2458
2458: DISABLE
2459: LD_INT 0
2461: PPUSH
2462: PPUSH
2463: PPUSH
// begin enable ;
2464: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2465: LD_ADDR_VAR 0 1
2469: PUSH
2470: LD_INT 22
2472: PUSH
2473: LD_INT 1
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 21
2482: PUSH
2483: LD_INT 2
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 3
2492: PUSH
2493: LD_INT 24
2495: PUSH
2496: LD_INT 1000
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: PUSH
2507: LD_INT 92
2509: PUSH
2510: LD_INT 191
2512: PUSH
2513: LD_INT 140
2515: PUSH
2516: LD_INT 10
2518: PUSH
2519: EMPTY
2520: LIST
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 69
2535: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_INT 22
2543: PUSH
2544: LD_INT 4
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: PUSH
2551: LD_INT 25
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PPUSH
2565: CALL_OW 69
2569: ST_TO_ADDR
// if not mechs then
2570: LD_VAR 0 2
2574: NOT
2575: IFFALSE 2579
// exit ;
2577: GO 2753
// if mc_remote_driver [ 1 ] then
2579: LD_EXP 63
2583: PUSH
2584: LD_INT 1
2586: ARRAY
2587: IFFALSE 2609
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_VAR 0 2
2598: PUSH
2599: LD_EXP 63
2603: PUSH
2604: LD_INT 1
2606: ARRAY
2607: DIFF
2608: ST_TO_ADDR
// if not mechs then
2609: LD_VAR 0 2
2613: NOT
2614: IFFALSE 2618
// exit ;
2616: GO 2753
// if vehicles then
2618: LD_VAR 0 1
2622: IFFALSE 2710
// begin for i in mechs do
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: LD_VAR 0 2
2633: PUSH
2634: FOR_IN
2635: IFFALSE 2706
// begin if GetTag ( i ) <> 120 then
2637: LD_VAR 0 3
2641: PPUSH
2642: CALL_OW 110
2646: PUSH
2647: LD_INT 120
2649: NONEQUAL
2650: IFFALSE 2664
// SetTag ( i , 120 ) ;
2652: LD_VAR 0 3
2656: PPUSH
2657: LD_INT 120
2659: PPUSH
2660: CALL_OW 109
// if IsInUnit ( i ) then
2664: LD_VAR 0 3
2668: PPUSH
2669: CALL_OW 310
2673: IFFALSE 2686
// ComExitBuilding ( i ) else
2675: LD_VAR 0 3
2679: PPUSH
2680: CALL_OW 122
2684: GO 2704
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2686: LD_VAR 0 3
2690: PPUSH
2691: LD_VAR 0 1
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 129
// end ;
2704: GO 2634
2706: POP
2707: POP
// end else
2708: GO 2753
// if FilterByTag ( mechs , 120 ) then
2710: LD_VAR 0 2
2714: PPUSH
2715: LD_INT 120
2717: PPUSH
2718: CALL 45259 0 2
2722: IFFALSE 2753
// begin for i in mechs do
2724: LD_ADDR_VAR 0 3
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: FOR_IN
2735: IFFALSE 2751
// begin SetTag ( i , 0 ) ;
2737: LD_VAR 0 3
2741: PPUSH
2742: LD_INT 0
2744: PPUSH
2745: CALL_OW 109
// end ;
2749: GO 2734
2751: POP
2752: POP
// end ; end ;
2753: PPOPN 3
2755: END
// every 0 0$2 do var people , sci , i ;
2756: GO 2758
2758: DISABLE
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 1
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 21
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 3
2792: PUSH
2793: LD_INT 24
2795: PUSH
2796: LD_INT 1000
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: LD_INT 92
2809: PUSH
2810: LD_INT 188
2812: PUSH
2813: LD_INT 112
2815: PUSH
2816: LD_INT 10
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: LIST
2829: LIST
2830: PPUSH
2831: CALL_OW 69
2835: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2836: LD_ADDR_VAR 0 2
2840: PUSH
2841: LD_INT 22
2843: PUSH
2844: LD_INT 4
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: LD_INT 25
2853: PUSH
2854: LD_INT 4
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 69
2869: ST_TO_ADDR
// if not sci then
2870: LD_VAR 0 2
2874: NOT
2875: IFFALSE 2879
// exit ;
2877: GO 3014
// if people then
2879: LD_VAR 0 1
2883: IFFALSE 2971
// begin for i in sci do
2885: LD_ADDR_VAR 0 3
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2967
// begin if GetTag ( i ) <> 102 then
2898: LD_VAR 0 3
2902: PPUSH
2903: CALL_OW 110
2907: PUSH
2908: LD_INT 102
2910: NONEQUAL
2911: IFFALSE 2925
// SetTag ( i , 102 ) ;
2913: LD_VAR 0 3
2917: PPUSH
2918: LD_INT 102
2920: PPUSH
2921: CALL_OW 109
// if IsInUnit ( i ) then
2925: LD_VAR 0 3
2929: PPUSH
2930: CALL_OW 310
2934: IFFALSE 2947
// ComExitBuilding ( i ) else
2936: LD_VAR 0 3
2940: PPUSH
2941: CALL_OW 122
2945: GO 2965
// ComHeal ( i , people [ 1 ] ) ;
2947: LD_VAR 0 3
2951: PPUSH
2952: LD_VAR 0 1
2956: PUSH
2957: LD_INT 1
2959: ARRAY
2960: PPUSH
2961: CALL_OW 128
// end ;
2965: GO 2895
2967: POP
2968: POP
// end else
2969: GO 3014
// if FilterByTag ( sci , 102 ) then
2971: LD_VAR 0 2
2975: PPUSH
2976: LD_INT 102
2978: PPUSH
2979: CALL 45259 0 2
2983: IFFALSE 3014
// begin for i in sci do
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_VAR 0 2
2994: PUSH
2995: FOR_IN
2996: IFFALSE 3012
// begin SetTag ( i , 0 ) ;
2998: LD_VAR 0 3
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 109
// end ;
3010: GO 2995
3012: POP
3013: POP
// end ; end ;
3014: PPOPN 3
3016: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3017: LD_INT 22
3019: PUSH
3020: LD_INT 4
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 33
3029: PUSH
3030: LD_INT 2
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 50
3039: PUSH
3040: EMPTY
3041: LIST
3042: PUSH
3043: LD_INT 3
3045: PUSH
3046: LD_INT 61
3048: PUSH
3049: EMPTY
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PPUSH
3062: CALL_OW 69
3066: IFFALSE 3157
3068: GO 3070
3070: DISABLE
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
// begin enable ;
3075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3076: LD_ADDR_VAR 0 2
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 4
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 33
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: EMPTY
3105: LIST
3106: PUSH
3107: LD_INT 3
3109: PUSH
3110: LD_INT 61
3112: PUSH
3113: EMPTY
3114: LIST
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: CALL_OW 69
3130: ST_TO_ADDR
// for i in tmp do
3131: LD_ADDR_VAR 0 1
3135: PUSH
3136: LD_VAR 0 2
3140: PUSH
3141: FOR_IN
3142: IFFALSE 3155
// Connect ( i ) ;
3144: LD_VAR 0 1
3148: PPUSH
3149: CALL 18961 0 1
3153: GO 3141
3155: POP
3156: POP
// end ; end_of_file
3157: PPOPN 2
3159: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3160: LD_INT 0
3162: PPUSH
3163: PPUSH
3164: PPUSH
3165: PPUSH
3166: PPUSH
3167: PPUSH
// gensher_side := 2 ;
3168: LD_ADDR_EXP 14
3172: PUSH
3173: LD_INT 2
3175: ST_TO_ADDR
// uc_side := gensher_side ;
3176: LD_ADDR_OWVAR 20
3180: PUSH
3181: LD_EXP 14
3185: ST_TO_ADDR
// uc_nation := 2 ;
3186: LD_ADDR_OWVAR 21
3190: PUSH
3191: LD_INT 2
3193: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3194: LD_ADDR_VAR 0 6
3198: PUSH
3199: LD_INT 5
3201: PUSH
3202: LD_INT 42
3204: PUSH
3205: LD_INT 29
3207: PUSH
3208: LD_INT 5
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 5
3219: PUSH
3220: LD_INT 36
3222: PUSH
3223: LD_INT 40
3225: PUSH
3226: LD_INT 5
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 13
3240: PUSH
3241: LD_INT 18
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: LD_INT 10
3249: PUSH
3250: LD_INT 15
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 27
3263: PUSH
3264: LD_INT 17
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 29
3281: PUSH
3282: LD_INT 56
3284: PUSH
3285: LD_INT 23
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: PUSH
3297: LD_INT 3
3299: PUSH
3300: LD_INT 11
3302: PUSH
3303: LD_INT 7
3305: PUSH
3306: LD_INT 2
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 27
3317: PUSH
3318: LD_INT 20
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: LD_INT 0
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 27
3335: PUSH
3336: LD_INT 23
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: LD_INT 0
3344: PUSH
3345: EMPTY
3346: LIST
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 27
3353: PUSH
3354: LD_INT 26
3356: PUSH
3357: LD_INT 3
3359: PUSH
3360: LD_INT 0
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 6
3371: PUSH
3372: LD_INT 17
3374: PUSH
3375: LD_INT 27
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 13
3383: PUSH
3384: LD_INT 11
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 27
3400: PUSH
3401: LD_INT 44
3403: PUSH
3404: LD_INT 5
3406: PUSH
3407: LD_INT 27
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: PUSH
3417: LD_INT 32
3419: PUSH
3420: LD_INT 41
3422: PUSH
3423: LD_INT 41
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: LD_INT 27
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 32
3441: PUSH
3442: LD_INT 45
3444: PUSH
3445: LD_INT 24
3447: PUSH
3448: LD_INT 5
3450: PUSH
3451: LD_INT 28
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 32
3463: PUSH
3464: LD_INT 48
3466: PUSH
3467: LD_INT 19
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 28
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: PUSH
3483: LD_INT 32
3485: PUSH
3486: LD_INT 41
3488: PUSH
3489: LD_INT 3
3491: PUSH
3492: LD_INT 4
3494: PUSH
3495: LD_INT 28
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 5
3507: PUSH
3508: LD_INT 44
3510: PUSH
3511: LD_INT 9
3513: PUSH
3514: LD_INT 4
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 30
3525: PUSH
3526: LD_INT 52
3528: PUSH
3529: LD_INT 40
3531: PUSH
3532: LD_INT 3
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: ST_TO_ADDR
// for i in list do
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: FOR_IN
3571: IFFALSE 3749
// begin uc_side := 2 ;
3573: LD_ADDR_OWVAR 20
3577: PUSH
3578: LD_INT 2
3580: ST_TO_ADDR
// uc_nation := 2 ;
3581: LD_ADDR_OWVAR 21
3585: PUSH
3586: LD_INT 2
3588: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3589: LD_ADDR_OWVAR 42
3593: PUSH
3594: LD_VAR 0 2
3598: PUSH
3599: LD_INT 1
3601: ARRAY
3602: ST_TO_ADDR
// bc_kind1 := - 1 ;
3603: LD_ADDR_OWVAR 44
3607: PUSH
3608: LD_INT 1
3610: NEG
3611: ST_TO_ADDR
// bc_kind2 := - 1 ;
3612: LD_ADDR_OWVAR 45
3616: PUSH
3617: LD_INT 1
3619: NEG
3620: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3621: LD_VAR 0 2
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: PUSH
3630: LD_INT 6
3632: EQUAL
3633: IFFALSE 3671
// begin bc_type := b_lab_full ;
3635: LD_ADDR_OWVAR 42
3639: PUSH
3640: LD_INT 8
3642: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3643: LD_ADDR_OWVAR 44
3647: PUSH
3648: LD_VAR 0 2
3652: PUSH
3653: LD_INT 5
3655: ARRAY
3656: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3657: LD_ADDR_OWVAR 45
3661: PUSH
3662: LD_VAR 0 2
3666: PUSH
3667: LD_INT 6
3669: ARRAY
3670: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3671: LD_ADDR_VAR 0 3
3675: PUSH
3676: LD_VAR 0 2
3680: PUSH
3681: LD_INT 2
3683: ARRAY
3684: PPUSH
3685: LD_VAR 0 2
3689: PUSH
3690: LD_INT 3
3692: ARRAY
3693: PPUSH
3694: LD_VAR 0 2
3698: PUSH
3699: LD_INT 4
3701: ARRAY
3702: PPUSH
3703: CALL_OW 47
3707: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 1
3715: ARRAY
3716: PUSH
3717: LD_INT 33
3719: PUSH
3720: LD_INT 32
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: IN
3727: IFFALSE 3747
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3729: LD_VAR 0 3
3733: PPUSH
3734: LD_VAR 0 2
3738: PUSH
3739: LD_INT 5
3741: ARRAY
3742: PPUSH
3743: CALL_OW 431
// end ;
3747: GO 3570
3749: POP
3750: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3751: LD_ADDR_VAR 0 4
3755: PUSH
3756: LD_INT 7
3758: PPUSH
3759: LD_INT 2
3761: PPUSH
3762: LD_STRING 
3764: PPUSH
3765: LD_INT 8
3767: PUSH
3768: LD_INT 7
3770: PUSH
3771: LD_INT 6
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: LD_INT 11500
3787: PUSH
3788: LD_INT 1100
3790: PUSH
3791: LD_INT 60
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: LIST
3798: PPUSH
3799: LD_INT 6
3801: PUSH
3802: LD_INT 6
3804: PUSH
3805: LD_INT 6
3807: PUSH
3808: LD_INT 6
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL 19314 0 6
3821: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3822: LD_ADDR_EXP 23
3826: PUSH
3827: LD_EXP 23
3831: PPUSH
3832: LD_INT 2
3834: PPUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_INT 2
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 3
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PPUSH
3864: CALL_OW 69
3868: UNION
3869: PPUSH
3870: CALL_OW 1
3874: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3875: LD_ADDR_VAR 0 4
3879: PUSH
3880: LD_INT 22
3882: PUSH
3883: LD_INT 2
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_INT 30
3892: PUSH
3893: LD_INT 31
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PPUSH
3904: CALL_OW 69
3908: ST_TO_ADDR
// for i in tmp do
3909: LD_ADDR_VAR 0 2
3913: PUSH
3914: LD_VAR 0 4
3918: PUSH
3919: FOR_IN
3920: IFFALSE 3990
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 4
3930: PUSH
3931: LD_INT 3
3933: PUSH
3934: LD_INT 3
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: LD_OWVAR 67
3946: ARRAY
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 1
3969: PPUSH
3970: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3974: LD_VAR 0 5
3978: PPUSH
3979: LD_VAR 0 2
3983: PPUSH
3984: CALL_OW 52
// end ;
3988: GO 3919
3990: POP
3991: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3992: LD_ADDR_VAR 0 4
3996: PUSH
3997: LD_INT 15
3999: PPUSH
4000: LD_INT 0
4002: PPUSH
4003: CALL_OW 517
4007: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4008: LD_ADDR_VAR 0 2
4012: PUSH
4013: DOUBLE
4014: LD_INT 1
4016: DEC
4017: ST_TO_ADDR
4018: LD_VAR 0 4
4022: PUSH
4023: LD_INT 1
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4130
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4030: LD_VAR 0 4
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PUSH
4039: LD_VAR 0 2
4043: ARRAY
4044: PPUSH
4045: LD_VAR 0 4
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PUSH
4054: LD_VAR 0 2
4058: ARRAY
4059: PPUSH
4060: LD_INT 2
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4070: LD_ADDR_EXP 3
4074: PUSH
4075: LD_EXP 3
4079: PPUSH
4080: LD_EXP 3
4084: PUSH
4085: LD_INT 1
4087: PLUS
4088: PPUSH
4089: LD_VAR 0 4
4093: PUSH
4094: LD_INT 1
4096: ARRAY
4097: PUSH
4098: LD_VAR 0 2
4102: ARRAY
4103: PUSH
4104: LD_VAR 0 4
4108: PUSH
4109: LD_INT 2
4111: ARRAY
4112: PUSH
4113: LD_VAR 0 2
4117: ARRAY
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: PPUSH
4123: CALL_OW 2
4127: ST_TO_ADDR
// end ;
4128: GO 4027
4130: POP
4131: POP
// if Difficulty > 1 then
4132: LD_OWVAR 67
4136: PUSH
4137: LD_INT 1
4139: GREATER
4140: IFFALSE 4282
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4142: LD_ADDR_VAR 0 4
4146: PUSH
4147: LD_INT 19
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL_OW 517
4157: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4158: LD_ADDR_VAR 0 2
4162: PUSH
4163: DOUBLE
4164: LD_INT 1
4166: DEC
4167: ST_TO_ADDR
4168: LD_VAR 0 4
4172: PUSH
4173: LD_INT 1
4175: ARRAY
4176: PUSH
4177: FOR_TO
4178: IFFALSE 4280
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4180: LD_VAR 0 4
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: PUSH
4189: LD_VAR 0 2
4193: ARRAY
4194: PPUSH
4195: LD_VAR 0 4
4199: PUSH
4200: LD_INT 2
4202: ARRAY
4203: PUSH
4204: LD_VAR 0 2
4208: ARRAY
4209: PPUSH
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4220: LD_ADDR_EXP 3
4224: PUSH
4225: LD_EXP 3
4229: PPUSH
4230: LD_EXP 3
4234: PUSH
4235: LD_INT 1
4237: PLUS
4238: PPUSH
4239: LD_VAR 0 4
4243: PUSH
4244: LD_INT 1
4246: ARRAY
4247: PUSH
4248: LD_VAR 0 2
4252: ARRAY
4253: PUSH
4254: LD_VAR 0 4
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PUSH
4263: LD_VAR 0 2
4267: ARRAY
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PPUSH
4273: CALL_OW 2
4277: ST_TO_ADDR
// end ;
4278: GO 4177
4280: POP
4281: POP
// end ; gensherAttackGroup := [ ] ;
4282: LD_ADDR_EXP 15
4286: PUSH
4287: EMPTY
4288: ST_TO_ADDR
// end ;
4289: LD_VAR 0 1
4293: RET
// export function InitMC_Gensher ( ) ; begin
4294: LD_INT 0
4296: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4297: LD_INT 2
4299: PPUSH
4300: LD_INT 2
4302: PPUSH
4303: CALL 75224 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4307: LD_INT 2
4309: PPUSH
4310: LD_INT 9
4312: PPUSH
4313: CALL 75168 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4317: LD_INT 2
4319: PPUSH
4320: LD_INT 56
4322: PUSH
4323: LD_INT 23
4325: PUSH
4326: LD_INT 0
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: LD_INT 52
4336: PUSH
4337: LD_INT 40
4339: PUSH
4340: LD_INT 1
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PPUSH
4352: CALL 74227 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4356: LD_INT 2
4358: PPUSH
4359: LD_INT 27
4361: PUSH
4362: LD_INT 28
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PPUSH
4369: CALL 75056 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4373: LD_INT 2
4375: PPUSH
4376: LD_INT 8
4378: PPUSH
4379: CALL 74738 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4383: LD_INT 2
4385: PPUSH
4386: LD_INT 7
4388: PPUSH
4389: CALL 74469 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4393: LD_INT 2
4395: PPUSH
4396: LD_INT 4
4398: PPUSH
4399: CALL 74088 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4403: LD_INT 2
4405: PPUSH
4406: LD_INT 13
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: LD_INT 31
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: LD_INT 13
4426: PUSH
4427: LD_INT 2
4429: PUSH
4430: LD_INT 1
4432: PUSH
4433: LD_INT 31
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 14
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 27
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 14
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: LD_INT 2
4468: PUSH
4469: LD_INT 27
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 14
4480: PUSH
4481: LD_INT 1
4483: PUSH
4484: LD_INT 2
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 14
4498: PUSH
4499: LD_INT 1
4501: PUSH
4502: LD_INT 2
4504: PUSH
4505: LD_INT 26
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL 73903 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4526: LD_INT 2
4528: PPUSH
4529: LD_INT 11
4531: PPUSH
4532: LD_INT 7
4534: PPUSH
4535: LD_INT 2
4537: PPUSH
4538: LD_INT 23
4540: PUSH
4541: LD_INT 16
4543: PUSH
4544: LD_INT 17
4546: PUSH
4547: LD_INT 18
4549: PUSH
4550: LD_INT 22
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PPUSH
4560: CALL 74850 0 5
// end ;
4564: LD_VAR 0 1
4568: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4569: LD_EXP 3
4573: PUSH
4574: LD_INT 15
4576: PPUSH
4577: LD_INT 81
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 70
4591: AND
4592: IFFALSE 4805
4594: GO 4596
4596: DISABLE
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
// begin enable ;
4604: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4605: LD_ADDR_VAR 0 3
4609: PUSH
4610: LD_INT 15
4612: PPUSH
4613: LD_INT 81
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 70
4627: ST_TO_ADDR
// if not tmp then
4628: LD_VAR 0 3
4632: NOT
4633: IFFALSE 4637
// exit ;
4635: GO 4805
// for i in tmp do
4637: LD_ADDR_VAR 0 1
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: FOR_IN
4648: IFFALSE 4803
// begin x := GetX ( i ) ;
4650: LD_ADDR_VAR 0 4
4654: PUSH
4655: LD_VAR 0 1
4659: PPUSH
4660: CALL_OW 250
4664: ST_TO_ADDR
// y := GetY ( i ) ;
4665: LD_ADDR_VAR 0 5
4669: PUSH
4670: LD_VAR 0 1
4674: PPUSH
4675: CALL_OW 251
4679: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4680: LD_VAR 0 4
4684: PPUSH
4685: LD_VAR 0 5
4689: PPUSH
4690: CALL_OW 458
4694: IFFALSE 4801
// begin LaunchMineAtPos ( x , y , 2 ) ;
4696: LD_VAR 0 4
4700: PPUSH
4701: LD_VAR 0 5
4705: PPUSH
4706: LD_INT 2
4708: PPUSH
4709: CALL_OW 456
// for j = 1 to staticMines do
4713: LD_ADDR_VAR 0 2
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_EXP 3
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4799
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4731: LD_EXP 3
4735: PUSH
4736: LD_VAR 0 2
4740: ARRAY
4741: PUSH
4742: LD_INT 1
4744: ARRAY
4745: PUSH
4746: LD_VAR 0 4
4750: EQUAL
4751: PUSH
4752: LD_EXP 3
4756: PUSH
4757: LD_VAR 0 2
4761: ARRAY
4762: PUSH
4763: LD_INT 2
4765: ARRAY
4766: PUSH
4767: LD_VAR 0 5
4771: EQUAL
4772: AND
4773: IFFALSE 4797
// begin staticMines := Delete ( staticMines , j ) ;
4775: LD_ADDR_EXP 3
4779: PUSH
4780: LD_EXP 3
4784: PPUSH
4785: LD_VAR 0 2
4789: PPUSH
4790: CALL_OW 3
4794: ST_TO_ADDR
// break ;
4795: GO 4799
// end ;
4797: GO 4728
4799: POP
4800: POP
// end ; end ;
4801: GO 4647
4803: POP
4804: POP
// end ;
4805: PPOPN 5
4807: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4808: LD_INT 7
4810: PPUSH
4811: CALL_OW 302
4815: PUSH
4816: LD_EXP 4
4820: NOT
4821: AND
4822: IFFALSE 5426
4824: GO 4826
4826: DISABLE
4827: LD_INT 0
4829: PPUSH
4830: PPUSH
4831: PPUSH
4832: PPUSH
4833: PPUSH
// begin enable ;
4834: ENABLE
// base := 2 ;
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_INT 2
4842: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4843: LD_ADDR_VAR 0 3
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 27
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 27
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 14
4886: PUSH
4887: LD_INT 1
4889: PUSH
4890: LD_INT 2
4892: PUSH
4893: LD_EXP 72
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 14
4906: PUSH
4907: LD_INT 1
4909: PUSH
4910: LD_INT 2
4912: PUSH
4913: LD_INT 26
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: LIST
4926: LIST
4927: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4928: LD_ADDR_VAR 0 5
4932: PUSH
4933: LD_VAR 0 5
4937: PUSH
4938: LD_OWVAR 1
4942: PUSH
4943: LD_INT 21000
4945: DIV
4946: PLUS
4947: ST_TO_ADDR
// if amount > 8 then
4948: LD_VAR 0 5
4952: PUSH
4953: LD_INT 8
4955: GREATER
4956: IFFALSE 4966
// amount := 8 ;
4958: LD_ADDR_VAR 0 5
4962: PUSH
4963: LD_INT 8
4965: ST_TO_ADDR
// for i = 1 to amount do
4966: LD_ADDR_VAR 0 1
4970: PUSH
4971: DOUBLE
4972: LD_INT 1
4974: DEC
4975: ST_TO_ADDR
4976: LD_VAR 0 5
4980: PUSH
4981: FOR_TO
4982: IFFALSE 5070
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4984: LD_ADDR_VAR 0 3
4988: PUSH
4989: LD_VAR 0 3
4993: PPUSH
4994: LD_VAR 0 3
4998: PUSH
4999: LD_INT 1
5001: PLUS
5002: PPUSH
5003: LD_INT 14
5005: PUSH
5006: LD_INT 13
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 1
5015: PPUSH
5016: LD_INT 2
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: PUSH
5025: LD_INT 1
5027: PUSH
5028: LD_INT 2
5030: PUSH
5031: LD_INT 28
5033: PUSH
5034: LD_INT 25
5036: PUSH
5037: LD_INT 27
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: PUSH
5045: LD_INT 1
5047: PPUSH
5048: LD_INT 3
5050: PPUSH
5051: CALL_OW 12
5055: ARRAY
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 2
5067: ST_TO_ADDR
5068: GO 4981
5070: POP
5071: POP
// MC_InsertProduceList ( base , tmp ) ;
5072: LD_VAR 0 2
5076: PPUSH
5077: LD_VAR 0 3
5081: PPUSH
5082: CALL 73951 0 2
// repeat wait ( 0 0$1 ) ;
5086: LD_INT 35
5088: PPUSH
5089: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5093: LD_VAR 0 2
5097: PPUSH
5098: LD_INT 1
5100: PPUSH
5101: CALL 75369 0 2
5105: PUSH
5106: LD_VAR 0 5
5110: GREATEREQUAL
5111: IFFALSE 5086
// wait ( 0 0$30 ) ;
5113: LD_INT 1050
5115: PPUSH
5116: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5120: LD_ADDR_VAR 0 4
5124: PUSH
5125: LD_EXP 42
5129: PUSH
5130: LD_VAR 0 2
5134: ARRAY
5135: PUSH
5136: LD_EXP 42
5140: PUSH
5141: LD_VAR 0 2
5145: ARRAY
5146: PPUSH
5147: LD_INT 2
5149: PUSH
5150: LD_INT 34
5152: PUSH
5153: LD_INT 31
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 34
5162: PUSH
5163: LD_INT 32
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 34
5172: PUSH
5173: LD_EXP 73
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: LIST
5186: LIST
5187: PPUSH
5188: CALL_OW 72
5192: DIFF
5193: ST_TO_ADDR
// if not attackers then
5194: LD_VAR 0 4
5198: NOT
5199: IFFALSE 5203
// exit ;
5201: GO 5426
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5203: LD_ADDR_EXP 42
5207: PUSH
5208: LD_EXP 42
5212: PPUSH
5213: LD_VAR 0 2
5217: PPUSH
5218: LD_EXP 42
5222: PUSH
5223: LD_VAR 0 2
5227: ARRAY
5228: PUSH
5229: LD_VAR 0 4
5233: DIFF
5234: PPUSH
5235: CALL_OW 1
5239: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5240: LD_VAR 0 4
5244: PPUSH
5245: LD_INT 107
5247: PPUSH
5248: LD_INT 74
5250: PPUSH
5251: CALL_OW 114
// wait ( 0 0$5 ) ;
5255: LD_INT 175
5257: PPUSH
5258: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5262: LD_INT 35
5264: PPUSH
5265: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5269: LD_VAR 0 4
5273: PPUSH
5274: LD_INT 60
5276: PUSH
5277: EMPTY
5278: LIST
5279: PPUSH
5280: CALL_OW 72
5284: NOT
5285: IFFALSE 5262
// if rand ( 0 , 1 ) then
5287: LD_INT 0
5289: PPUSH
5290: LD_INT 1
5292: PPUSH
5293: CALL_OW 12
5297: IFFALSE 5316
// ComAgressiveMove ( attackers , 155 , 108 ) else
5299: LD_VAR 0 4
5303: PPUSH
5304: LD_INT 155
5306: PPUSH
5307: LD_INT 108
5309: PPUSH
5310: CALL_OW 114
5314: GO 5331
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5316: LD_VAR 0 4
5320: PPUSH
5321: LD_INT 149
5323: PPUSH
5324: LD_INT 55
5326: PPUSH
5327: CALL_OW 114
// wait ( 0 0$10 ) ;
5331: LD_INT 350
5333: PPUSH
5334: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5338: LD_INT 35
5340: PPUSH
5341: CALL_OW 67
// for i in attackers do
5345: LD_ADDR_VAR 0 1
5349: PUSH
5350: LD_VAR 0 4
5354: PUSH
5355: FOR_IN
5356: IFFALSE 5406
// if not HasTask ( i ) then
5358: LD_VAR 0 1
5362: PPUSH
5363: CALL_OW 314
5367: NOT
5368: IFFALSE 5404
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5370: LD_VAR 0 1
5374: PPUSH
5375: LD_INT 81
5377: PUSH
5378: LD_INT 2
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: PPUSH
5390: LD_VAR 0 1
5394: PPUSH
5395: CALL_OW 74
5399: PPUSH
5400: CALL_OW 115
5404: GO 5355
5406: POP
5407: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5408: LD_VAR 0 4
5412: PPUSH
5413: LD_INT 50
5415: PUSH
5416: EMPTY
5417: LIST
5418: PPUSH
5419: CALL_OW 72
5423: NOT
5424: IFFALSE 5338
// end ;
5426: PPOPN 5
5428: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5429: LD_EXP 4
5433: NOT
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 191100
5442: LESS
5443: AND
5444: IFFALSE 6116
5446: GO 5448
5448: DISABLE
5449: LD_INT 0
5451: PPUSH
5452: PPUSH
5453: PPUSH
// begin enable ;
5454: ENABLE
// tmp := [ ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: EMPTY
5461: ST_TO_ADDR
// if tick < 35 35$00 then
5462: LD_OWVAR 1
5466: PUSH
5467: LD_INT 73500
5469: LESS
5470: IFFALSE 5668
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5472: LD_ADDR_VAR 0 1
5476: PUSH
5477: DOUBLE
5478: LD_INT 1
5480: DEC
5481: ST_TO_ADDR
5482: LD_INT 4
5484: PUSH
5485: LD_INT 5
5487: PUSH
5488: LD_INT 5
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5664
// begin uc_side := 2 ;
5505: LD_ADDR_OWVAR 20
5509: PUSH
5510: LD_INT 2
5512: ST_TO_ADDR
// uc_nation := 2 ;
5513: LD_ADDR_OWVAR 21
5517: PUSH
5518: LD_INT 2
5520: ST_TO_ADDR
// InitHC_All ( ) ;
5521: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: LD_INT 5
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 7
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: PUSH
5545: LD_OWVAR 67
5549: ARRAY
5550: PPUSH
5551: CALL_OW 380
// un := CreateHuman ;
5555: LD_ADDR_VAR 0 2
5559: PUSH
5560: CALL_OW 44
5564: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5565: LD_VAR 0 2
5569: PPUSH
5570: LD_INT 17
5572: PPUSH
5573: LD_INT 0
5575: PPUSH
5576: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5580: LD_VAR 0 2
5584: PPUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 1
5597: PPUSH
5598: LD_INT 2
5600: PPUSH
5601: CALL_OW 12
5605: ARRAY
5606: PPUSH
5607: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5611: LD_VAR 0 2
5615: PPUSH
5616: LD_INT 111
5618: PPUSH
5619: LD_INT 34
5621: PPUSH
5622: CALL_OW 114
// wait ( 0 0$2 ) ;
5626: LD_INT 70
5628: PPUSH
5629: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5633: LD_ADDR_VAR 0 3
5637: PUSH
5638: LD_VAR 0 3
5642: PPUSH
5643: LD_VAR 0 3
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: PPUSH
5652: LD_VAR 0 2
5656: PPUSH
5657: CALL_OW 1
5661: ST_TO_ADDR
// end ;
5662: GO 5502
5664: POP
5665: POP
// end else
5666: GO 5809
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5668: LD_ADDR_VAR 0 1
5672: PUSH
5673: DOUBLE
5674: LD_INT 1
5676: DEC
5677: ST_TO_ADDR
5678: LD_INT 4
5680: PUSH
5681: LD_INT 5
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_OWVAR 67
5696: ARRAY
5697: PUSH
5698: FOR_TO
5699: IFFALSE 5807
// begin uc_side := 2 ;
5701: LD_ADDR_OWVAR 20
5705: PUSH
5706: LD_INT 2
5708: ST_TO_ADDR
// uc_nation := 0 ;
5709: LD_ADDR_OWVAR 21
5713: PUSH
5714: LD_INT 0
5716: ST_TO_ADDR
// InitHC_All ( ) ;
5717: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5721: LD_ADDR_OWVAR 28
5725: PUSH
5726: LD_INT 17
5728: ST_TO_ADDR
// un := CreateHuman ;
5729: LD_ADDR_VAR 0 2
5733: PUSH
5734: CALL_OW 44
5738: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5739: LD_VAR 0 2
5743: PPUSH
5744: LD_INT 17
5746: PPUSH
5747: LD_INT 0
5749: PPUSH
5750: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5754: LD_VAR 0 2
5758: PPUSH
5759: LD_INT 110
5761: PPUSH
5762: LD_INT 33
5764: PPUSH
5765: CALL_OW 114
// wait ( 0 0$2 ) ;
5769: LD_INT 70
5771: PPUSH
5772: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5776: LD_ADDR_VAR 0 3
5780: PUSH
5781: LD_VAR 0 3
5785: PPUSH
5786: LD_VAR 0 3
5790: PUSH
5791: LD_INT 1
5793: PLUS
5794: PPUSH
5795: LD_VAR 0 2
5799: PPUSH
5800: CALL_OW 1
5804: ST_TO_ADDR
// end ;
5805: GO 5698
5807: POP
5808: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5809: LD_ADDR_VAR 0 1
5813: PUSH
5814: DOUBLE
5815: LD_INT 1
5817: DEC
5818: ST_TO_ADDR
5819: LD_INT 3
5821: PUSH
5822: LD_INT 4
5824: PUSH
5825: LD_INT 5
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_OWVAR 67
5837: ARRAY
5838: PUSH
5839: FOR_TO
5840: IFFALSE 6005
// begin uc_side := 2 ;
5842: LD_ADDR_OWVAR 20
5846: PUSH
5847: LD_INT 2
5849: ST_TO_ADDR
// uc_nation := 2 ;
5850: LD_ADDR_OWVAR 21
5854: PUSH
5855: LD_INT 2
5857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5858: LD_INT 14
5860: PPUSH
5861: LD_INT 3
5863: PPUSH
5864: LD_INT 5
5866: PPUSH
5867: LD_INT 29
5869: PUSH
5870: LD_INT 28
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: CALL_OW 12
5891: ARRAY
5892: PPUSH
5893: LD_INT 90
5895: PPUSH
5896: CALL 15868 0 5
// un := CreateVehicle ;
5900: LD_ADDR_VAR 0 2
5904: PUSH
5905: CALL_OW 45
5909: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5910: LD_VAR 0 2
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5922: LD_VAR 0 2
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_INT 0
5932: PPUSH
5933: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5937: LD_VAR 0 2
5941: PPUSH
5942: LD_INT 66
5944: PPUSH
5945: LD_INT 23
5947: PPUSH
5948: CALL_OW 111
// wait ( 0 0$3 ) ;
5952: LD_INT 105
5954: PPUSH
5955: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_INT 147
5966: PPUSH
5967: LD_INT 103
5969: PPUSH
5970: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5974: LD_ADDR_VAR 0 3
5978: PUSH
5979: LD_VAR 0 3
5983: PPUSH
5984: LD_VAR 0 3
5988: PUSH
5989: LD_INT 1
5991: PLUS
5992: PPUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: CALL_OW 1
6002: ST_TO_ADDR
// end ;
6003: GO 5839
6005: POP
6006: POP
// if not tmp then
6007: LD_VAR 0 3
6011: NOT
6012: IFFALSE 6016
// exit ;
6014: GO 6116
// wait ( 0 0$5 ) ;
6016: LD_INT 175
6018: PPUSH
6019: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6023: LD_INT 70
6025: PPUSH
6026: CALL_OW 67
// for i in tmp do
6030: LD_ADDR_VAR 0 1
6034: PUSH
6035: LD_VAR 0 3
6039: PUSH
6040: FOR_IN
6041: IFFALSE 6107
// begin if not IsOk ( i ) then
6043: LD_VAR 0 1
6047: PPUSH
6048: CALL_OW 302
6052: NOT
6053: IFFALSE 6071
// tmp := tmp diff i ;
6055: LD_ADDR_VAR 0 3
6059: PUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_VAR 0 1
6069: DIFF
6070: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6071: LD_VAR 0 1
6075: PPUSH
6076: LD_INT 81
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 69
6090: PPUSH
6091: LD_VAR 0 1
6095: PPUSH
6096: CALL_OW 74
6100: PPUSH
6101: CALL_OW 115
// end ;
6105: GO 6040
6107: POP
6108: POP
// until not tmp ;
6109: LD_VAR 0 3
6113: NOT
6114: IFFALSE 6023
// end ;
6116: PPOPN 3
6118: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6119: LD_OWVAR 67
6123: PUSH
6124: LD_INT 1
6126: GREATER
6127: IFFALSE 6225
6129: GO 6131
6131: DISABLE
6132: LD_INT 0
6134: PPUSH
// begin uc_side := 2 ;
6135: LD_ADDR_OWVAR 20
6139: PUSH
6140: LD_INT 2
6142: ST_TO_ADDR
// uc_nation := 2 ;
6143: LD_ADDR_OWVAR 21
6147: PUSH
6148: LD_INT 2
6150: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6151: LD_INT 0
6153: PPUSH
6154: LD_INT 4
6156: PPUSH
6157: LD_INT 6
6159: PPUSH
6160: CALL_OW 380
// un := CreateHuman ;
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: CALL_OW 44
6173: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 88
6181: PPUSH
6182: LD_INT 1
6184: PPUSH
6185: LD_INT 2
6187: PPUSH
6188: LD_INT 0
6190: PPUSH
6191: CALL 49672 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 130
6202: PPUSH
6203: LD_INT 35
6205: PPUSH
6206: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6210: LD_VAR 0 1
6214: PPUSH
6215: LD_INT 132
6217: PPUSH
6218: LD_INT 39
6220: PPUSH
6221: CALL_OW 218
// end ;
6225: PPOPN 1
6227: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6228: LD_INT 22
6230: PUSH
6231: LD_INT 2
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 33
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 50
6250: PUSH
6251: EMPTY
6252: LIST
6253: PUSH
6254: LD_INT 3
6256: PUSH
6257: LD_INT 61
6259: PUSH
6260: EMPTY
6261: LIST
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: PPUSH
6273: CALL_OW 69
6277: IFFALSE 6368
6279: GO 6281
6281: DISABLE
6282: LD_INT 0
6284: PPUSH
6285: PPUSH
// begin enable ;
6286: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6287: LD_ADDR_VAR 0 2
6291: PUSH
6292: LD_INT 22
6294: PUSH
6295: LD_INT 2
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 33
6304: PUSH
6305: LD_INT 2
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: LD_INT 50
6314: PUSH
6315: EMPTY
6316: LIST
6317: PUSH
6318: LD_INT 3
6320: PUSH
6321: LD_INT 61
6323: PUSH
6324: EMPTY
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PPUSH
6337: CALL_OW 69
6341: ST_TO_ADDR
// for i in tmp do
6342: LD_ADDR_VAR 0 1
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: FOR_IN
6353: IFFALSE 6366
// Connect ( i ) ;
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL 18961 0 1
6364: GO 6352
6366: POP
6367: POP
// end ; end_of_file
6368: PPOPN 2
6370: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6371: LD_INT 0
6373: PPUSH
6374: PPUSH
6375: PPUSH
6376: PPUSH
6377: PPUSH
6378: PPUSH
// popov_side := 3 ;
6379: LD_ADDR_EXP 17
6383: PUSH
6384: LD_INT 3
6386: ST_TO_ADDR
// uc_side := popov_side ;
6387: LD_ADDR_OWVAR 20
6391: PUSH
6392: LD_EXP 17
6396: ST_TO_ADDR
// uc_nation := 3 ;
6397: LD_ADDR_OWVAR 21
6401: PUSH
6402: LD_INT 3
6404: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6405: LD_ADDR_VAR 0 6
6409: PUSH
6410: LD_INT 5
6412: PUSH
6413: LD_INT 103
6415: PUSH
6416: LD_INT 147
6418: PUSH
6419: LD_INT 3
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 5
6430: PUSH
6431: LD_INT 70
6433: PUSH
6434: LD_INT 117
6436: PUSH
6437: LD_INT 3
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: LD_INT 76
6451: PUSH
6452: LD_INT 145
6454: PUSH
6455: LD_INT 1
6457: PUSH
6458: LD_INT 10
6460: PUSH
6461: LD_INT 11
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 26
6474: PUSH
6475: LD_INT 87
6477: PUSH
6478: LD_INT 144
6480: PUSH
6481: LD_INT 0
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 29
6492: PUSH
6493: LD_INT 86
6495: PUSH
6496: LD_INT 118
6498: PUSH
6499: LD_INT 0
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 29
6510: PUSH
6511: LD_INT 98
6513: PUSH
6514: LD_INT 121
6516: PUSH
6517: LD_INT 0
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 26
6528: PUSH
6529: LD_INT 87
6531: PUSH
6532: LD_INT 147
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 30
6546: PUSH
6547: LD_INT 123
6549: PUSH
6550: LD_INT 151
6552: PUSH
6553: LD_INT 1
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 3
6564: PUSH
6565: LD_INT 94
6567: PUSH
6568: LD_INT 161
6570: PUSH
6571: LD_INT 0
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: LD_INT 6
6582: PUSH
6583: LD_INT 81
6585: PUSH
6586: LD_INT 155
6588: PUSH
6589: LD_INT 1
6591: PUSH
6592: LD_INT 12
6594: PUSH
6595: LD_INT 14
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 26
6608: PUSH
6609: LD_INT 96
6611: PUSH
6612: LD_INT 152
6614: PUSH
6615: LD_INT 0
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 26
6626: PUSH
6627: LD_INT 96
6629: PUSH
6630: LD_INT 149
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 32
6644: PUSH
6645: LD_INT 109
6647: PUSH
6648: LD_INT 142
6650: PUSH
6651: LD_INT 3
6653: PUSH
6654: LD_INT 46
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 32
6666: PUSH
6667: LD_INT 112
6669: PUSH
6670: LD_INT 148
6672: PUSH
6673: LD_INT 3
6675: PUSH
6676: LD_INT 46
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 33
6688: PUSH
6689: LD_INT 120
6691: PUSH
6692: LD_INT 159
6694: PUSH
6695: LD_INT 4
6697: PUSH
6698: LD_INT 45
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 33
6710: PUSH
6711: LD_INT 122
6713: PUSH
6714: LD_INT 163
6716: PUSH
6717: LD_INT 4
6719: PUSH
6720: LD_INT 45
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 33
6732: PUSH
6733: LD_INT 123
6735: PUSH
6736: LD_INT 167
6738: PUSH
6739: LD_INT 4
6741: PUSH
6742: LD_INT 45
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 33
6754: PUSH
6755: LD_INT 59
6757: PUSH
6758: LD_INT 111
6760: PUSH
6761: LD_INT 3
6763: PUSH
6764: LD_INT 45
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 33
6776: PUSH
6777: LD_INT 65
6779: PUSH
6780: LD_INT 111
6782: PUSH
6783: LD_INT 3
6785: PUSH
6786: LD_INT 46
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 33
6798: PUSH
6799: LD_INT 76
6801: PUSH
6802: LD_INT 117
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: LD_INT 45
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 33
6820: PUSH
6821: LD_INT 80
6823: PUSH
6824: LD_INT 119
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: LD_INT 46
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 33
6842: PUSH
6843: LD_INT 87
6845: PUSH
6846: LD_INT 125
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 45
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 92
6867: PUSH
6868: LD_INT 129
6870: PUSH
6871: LD_INT 3
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 28
6882: PUSH
6883: LD_INT 85
6885: PUSH
6886: LD_INT 165
6888: PUSH
6889: LD_INT 0
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 28
6900: PUSH
6901: LD_INT 83
6903: PUSH
6904: LD_INT 161
6906: PUSH
6907: LD_INT 4
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: LIST
6915: PUSH
6916: LD_INT 28
6918: PUSH
6919: LD_INT 91
6921: PUSH
6922: LD_INT 166
6924: PUSH
6925: LD_INT 3
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_INT 28
6936: PUSH
6937: LD_INT 102
6939: PUSH
6940: LD_INT 166
6942: PUSH
6943: LD_INT 2
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: LIST
6974: LIST
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: ST_TO_ADDR
// for i in list do
6981: LD_ADDR_VAR 0 2
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7170
// begin uc_side := 3 ;
6994: LD_ADDR_OWVAR 20
6998: PUSH
6999: LD_INT 3
7001: ST_TO_ADDR
// uc_nation := 3 ;
7002: LD_ADDR_OWVAR 21
7006: PUSH
7007: LD_INT 3
7009: ST_TO_ADDR
// bc_type := i [ 1 ] ;
7010: LD_ADDR_OWVAR 42
7014: PUSH
7015: LD_VAR 0 2
7019: PUSH
7020: LD_INT 1
7022: ARRAY
7023: ST_TO_ADDR
// bc_kind1 := - 1 ;
7024: LD_ADDR_OWVAR 44
7028: PUSH
7029: LD_INT 1
7031: NEG
7032: ST_TO_ADDR
// bc_kind2 := - 1 ;
7033: LD_ADDR_OWVAR 45
7037: PUSH
7038: LD_INT 1
7040: NEG
7041: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7042: LD_VAR 0 2
7046: PUSH
7047: LD_INT 1
7049: ARRAY
7050: PUSH
7051: LD_INT 6
7053: EQUAL
7054: IFFALSE 7092
// begin bc_type := b_lab_full ;
7056: LD_ADDR_OWVAR 42
7060: PUSH
7061: LD_INT 8
7063: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7064: LD_ADDR_OWVAR 44
7068: PUSH
7069: LD_VAR 0 2
7073: PUSH
7074: LD_INT 5
7076: ARRAY
7077: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7078: LD_ADDR_OWVAR 45
7082: PUSH
7083: LD_VAR 0 2
7087: PUSH
7088: LD_INT 6
7090: ARRAY
7091: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7092: LD_ADDR_VAR 0 5
7096: PUSH
7097: LD_VAR 0 2
7101: PUSH
7102: LD_INT 2
7104: ARRAY
7105: PPUSH
7106: LD_VAR 0 2
7110: PUSH
7111: LD_INT 3
7113: ARRAY
7114: PPUSH
7115: LD_VAR 0 2
7119: PUSH
7120: LD_INT 4
7122: ARRAY
7123: PPUSH
7124: CALL_OW 47
7128: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7129: LD_VAR 0 2
7133: PUSH
7134: LD_INT 1
7136: ARRAY
7137: PUSH
7138: LD_INT 33
7140: PUSH
7141: LD_INT 32
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: IN
7148: IFFALSE 7168
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7150: LD_VAR 0 5
7154: PPUSH
7155: LD_VAR 0 2
7159: PUSH
7160: LD_INT 5
7162: ARRAY
7163: PPUSH
7164: CALL_OW 431
// end ;
7168: GO 6991
7170: POP
7171: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7172: LD_ADDR_VAR 0 4
7176: PUSH
7177: LD_INT 9
7179: PPUSH
7180: LD_INT 3
7182: PPUSH
7183: LD_STRING 
7185: PPUSH
7186: LD_INT 8
7188: PUSH
7189: LD_INT 7
7191: PUSH
7192: LD_INT 6
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: PPUSH
7206: LD_INT 11500
7208: PUSH
7209: LD_INT 1100
7211: PUSH
7212: LD_INT 60
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: LD_INT 6
7222: PUSH
7223: LD_INT 6
7225: PUSH
7226: LD_INT 6
7228: PUSH
7229: LD_INT 6
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PPUSH
7238: CALL 19314 0 6
7242: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7243: LD_ADDR_EXP 23
7247: PUSH
7248: LD_EXP 23
7252: PPUSH
7253: LD_INT 3
7255: PPUSH
7256: LD_VAR 0 4
7260: PUSH
7261: LD_INT 22
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 3
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: UNION
7290: PPUSH
7291: CALL_OW 1
7295: ST_TO_ADDR
// extraPopovForces := [ ] ;
7296: LD_ADDR_EXP 18
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7303: LD_ADDR_VAR 0 2
7307: PUSH
7308: DOUBLE
7309: LD_INT 1
7311: DEC
7312: ST_TO_ADDR
7313: LD_INT 8
7315: PUSH
7316: LD_INT 9
7318: PUSH
7319: LD_INT 10
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: LIST
7326: PUSH
7327: LD_OWVAR 67
7331: ARRAY
7332: PUSH
7333: FOR_TO
7334: IFFALSE 7463
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7336: LD_INT 0
7338: PPUSH
7339: LD_INT 1
7341: PPUSH
7342: LD_INT 4
7344: PUSH
7345: LD_INT 5
7347: PUSH
7348: LD_INT 6
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_OWVAR 67
7360: ARRAY
7361: PPUSH
7362: CALL_OW 380
// un := CreateHuman ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: CALL_OW 44
7375: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7376: LD_INT 0
7378: PPUSH
7379: LD_INT 1
7381: PPUSH
7382: CALL_OW 12
7386: IFFALSE 7411
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_INT 131
7395: PPUSH
7396: LD_INT 110
7398: PPUSH
7399: LD_INT 8
7401: PPUSH
7402: LD_INT 0
7404: PPUSH
7405: CALL_OW 50
7409: GO 7432
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7411: LD_VAR 0 3
7415: PPUSH
7416: LD_INT 100
7418: PPUSH
7419: LD_INT 99
7421: PPUSH
7422: LD_INT 8
7424: PPUSH
7425: LD_INT 0
7427: PPUSH
7428: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7432: LD_ADDR_EXP 18
7436: PUSH
7437: LD_EXP 18
7441: PPUSH
7442: LD_EXP 18
7446: PUSH
7447: LD_INT 1
7449: PLUS
7450: PPUSH
7451: LD_VAR 0 3
7455: PPUSH
7456: CALL_OW 1
7460: ST_TO_ADDR
// end ;
7461: GO 7333
7463: POP
7464: POP
// PrepareSoldier ( false , 6 ) ;
7465: LD_INT 0
7467: PPUSH
7468: LD_INT 6
7470: PPUSH
7471: CALL_OW 381
// un := CreateHuman ;
7475: LD_ADDR_VAR 0 3
7479: PUSH
7480: CALL_OW 44
7484: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7485: LD_VAR 0 3
7489: PPUSH
7490: LD_INT 1
7492: PPUSH
7493: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7497: LD_VAR 0 3
7501: PPUSH
7502: LD_INT 150
7504: PPUSH
7505: LD_INT 158
7507: PPUSH
7508: CALL_OW 428
7512: PPUSH
7513: CALL_OW 52
// popovAttackGroup := [ ] ;
7517: LD_ADDR_EXP 19
7521: PUSH
7522: EMPTY
7523: ST_TO_ADDR
// end ;
7524: LD_VAR 0 1
7528: RET
// export function InitMC_Popov ( ) ; begin
7529: LD_INT 0
7531: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7532: LD_INT 3
7534: PPUSH
7535: LD_INT 3
7537: PPUSH
7538: CALL 75224 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7542: LD_INT 3
7544: PPUSH
7545: LD_INT 10
7547: PPUSH
7548: CALL 75168 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7552: LD_INT 3
7554: PPUSH
7555: LD_INT 86
7557: PUSH
7558: LD_INT 118
7560: PUSH
7561: LD_INT 0
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 123
7571: PUSH
7572: LD_INT 151
7574: PUSH
7575: LD_INT 1
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 98
7585: PUSH
7586: LD_INT 121
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: LIST
7601: PPUSH
7602: CALL 74227 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7606: LD_INT 3
7608: PPUSH
7609: LD_INT 46
7611: PUSH
7612: LD_INT 45
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PPUSH
7619: CALL 75056 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7623: LD_INT 3
7625: PPUSH
7626: LD_INT 12
7628: PPUSH
7629: CALL 74738 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7633: LD_INT 3
7635: PPUSH
7636: LD_INT 11
7638: PPUSH
7639: CALL 74469 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7643: LD_INT 3
7645: PPUSH
7646: LD_INT 4
7648: PPUSH
7649: CALL 74088 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7653: LD_INT 3
7655: PPUSH
7656: LD_INT 23
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 44
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 23
7676: PUSH
7677: LD_INT 1
7679: PUSH
7680: LD_INT 3
7682: PUSH
7683: LD_INT 45
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 21
7694: PUSH
7695: LD_INT 1
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 44
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 21
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 45
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL 73903 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7738: LD_INT 3
7740: PPUSH
7741: LD_INT 94
7743: PPUSH
7744: LD_INT 161
7746: PPUSH
7747: LD_INT 0
7749: PPUSH
7750: LD_INT 19
7752: PUSH
7753: LD_INT 17
7755: PUSH
7756: LD_INT 18
7758: PUSH
7759: LD_INT 24
7761: PUSH
7762: LD_INT 21
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: PPUSH
7772: CALL 74850 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7776: LD_INT 3
7778: PPUSH
7779: LD_INT 21
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: LD_INT 3
7787: PUSH
7788: LD_INT 51
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: PPUSH
7800: CALL 73951 0 2
// end ;
7804: LD_VAR 0 1
7808: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7809: LD_EXP 18
7813: PUSH
7814: LD_EXP 5
7818: NOT
7819: AND
7820: IFFALSE 7880
7822: GO 7824
7824: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7825: LD_EXP 18
7829: PPUSH
7830: LD_INT 106
7832: PPUSH
7833: LD_INT 137
7835: PPUSH
7836: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7840: LD_ADDR_EXP 23
7844: PUSH
7845: LD_EXP 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_EXP 23
7857: PUSH
7858: LD_INT 3
7860: ARRAY
7861: PUSH
7862: LD_EXP 18
7866: UNION
7867: PPUSH
7868: CALL_OW 1
7872: ST_TO_ADDR
// extraPopovForces := [ ] ;
7873: LD_ADDR_EXP 18
7877: PUSH
7878: EMPTY
7879: ST_TO_ADDR
// end ;
7880: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7881: LD_INT 9
7883: PPUSH
7884: CALL_OW 302
7888: PUSH
7889: LD_EXP 5
7893: NOT
7894: AND
7895: IFFALSE 8461
7897: GO 7899
7899: DISABLE
7900: LD_INT 0
7902: PPUSH
7903: PPUSH
7904: PPUSH
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// base := 3 ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7916: LD_ADDR_VAR 0 3
7920: PUSH
7921: LD_INT 22
7923: PUSH
7924: LD_INT 1
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 44
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 24
7941: PUSH
7942: LD_INT 1
7944: PUSH
7945: LD_INT 3
7947: PUSH
7948: LD_INT 46
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 24
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: LD_INT 3
7965: PUSH
7966: LD_INT 46
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: LD_INT 24
7977: PUSH
7978: LD_INT 1
7980: PUSH
7981: LD_INT 3
7983: PUSH
7984: LD_INT 46
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7999: LD_ADDR_VAR 0 5
8003: PUSH
8004: LD_VAR 0 5
8008: PUSH
8009: LD_OWVAR 1
8013: PUSH
8014: LD_INT 21000
8016: DIV
8017: PLUS
8018: ST_TO_ADDR
// if amount > 8 then
8019: LD_VAR 0 5
8023: PUSH
8024: LD_INT 8
8026: GREATER
8027: IFFALSE 8037
// amount := 8 ;
8029: LD_ADDR_VAR 0 5
8033: PUSH
8034: LD_INT 8
8036: ST_TO_ADDR
// for i = 1 to amount do
8037: LD_ADDR_VAR 0 1
8041: PUSH
8042: DOUBLE
8043: LD_INT 1
8045: DEC
8046: ST_TO_ADDR
8047: LD_VAR 0 5
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8118
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8055: LD_ADDR_VAR 0 3
8059: PUSH
8060: LD_VAR 0 3
8064: PPUSH
8065: LD_VAR 0 3
8069: PUSH
8070: LD_INT 1
8072: PLUS
8073: PPUSH
8074: LD_INT 24
8076: PUSH
8077: LD_INT 1
8079: PUSH
8080: LD_INT 3
8082: PUSH
8083: LD_INT 46
8085: PUSH
8086: LD_INT 45
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: PUSH
8093: LD_INT 1
8095: PPUSH
8096: LD_INT 2
8098: PPUSH
8099: CALL_OW 12
8103: ARRAY
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: LIST
8109: LIST
8110: PPUSH
8111: CALL_OW 2
8115: ST_TO_ADDR
8116: GO 8052
8118: POP
8119: POP
// MC_InsertProduceList ( base , tmp ) ;
8120: LD_VAR 0 2
8124: PPUSH
8125: LD_VAR 0 3
8129: PPUSH
8130: CALL 73951 0 2
// repeat wait ( 0 0$1 ) ;
8134: LD_INT 35
8136: PPUSH
8137: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8141: LD_VAR 0 2
8145: PPUSH
8146: LD_INT 1
8148: PPUSH
8149: CALL 75369 0 2
8153: PUSH
8154: LD_VAR 0 5
8158: GREATEREQUAL
8159: IFFALSE 8134
// wait ( 0 0$30 ) ;
8161: LD_INT 1050
8163: PPUSH
8164: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8168: LD_ADDR_VAR 0 4
8172: PUSH
8173: LD_EXP 42
8177: PUSH
8178: LD_VAR 0 2
8182: ARRAY
8183: PUSH
8184: LD_EXP 42
8188: PUSH
8189: LD_VAR 0 2
8193: ARRAY
8194: PPUSH
8195: LD_INT 2
8197: PUSH
8198: LD_INT 34
8200: PUSH
8201: LD_INT 51
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PUSH
8208: LD_INT 34
8210: PUSH
8211: LD_INT 52
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 72
8227: DIFF
8228: ST_TO_ADDR
// if not attackers then
8229: LD_VAR 0 4
8233: NOT
8234: IFFALSE 8238
// exit ;
8236: GO 8461
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8238: LD_ADDR_EXP 42
8242: PUSH
8243: LD_EXP 42
8247: PPUSH
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_EXP 42
8257: PUSH
8258: LD_VAR 0 2
8262: ARRAY
8263: PUSH
8264: LD_VAR 0 4
8268: DIFF
8269: PPUSH
8270: CALL_OW 1
8274: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8275: LD_VAR 0 4
8279: PPUSH
8280: LD_INT 107
8282: PPUSH
8283: LD_INT 74
8285: PPUSH
8286: CALL_OW 114
// wait ( 0 0$5 ) ;
8290: LD_INT 175
8292: PPUSH
8293: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8304: LD_VAR 0 4
8308: PPUSH
8309: LD_INT 60
8311: PUSH
8312: EMPTY
8313: LIST
8314: PPUSH
8315: CALL_OW 72
8319: NOT
8320: IFFALSE 8297
// if rand ( 0 , 1 ) then
8322: LD_INT 0
8324: PPUSH
8325: LD_INT 1
8327: PPUSH
8328: CALL_OW 12
8332: IFFALSE 8351
// ComAgressiveMove ( attackers , 155 , 108 ) else
8334: LD_VAR 0 4
8338: PPUSH
8339: LD_INT 155
8341: PPUSH
8342: LD_INT 108
8344: PPUSH
8345: CALL_OW 114
8349: GO 8366
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8351: LD_VAR 0 4
8355: PPUSH
8356: LD_INT 149
8358: PPUSH
8359: LD_INT 55
8361: PPUSH
8362: CALL_OW 114
// wait ( 0 0$10 ) ;
8366: LD_INT 350
8368: PPUSH
8369: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8373: LD_INT 35
8375: PPUSH
8376: CALL_OW 67
// for i in attackers do
8380: LD_ADDR_VAR 0 1
8384: PUSH
8385: LD_VAR 0 4
8389: PUSH
8390: FOR_IN
8391: IFFALSE 8441
// if not HasTask ( i ) then
8393: LD_VAR 0 1
8397: PPUSH
8398: CALL_OW 314
8402: NOT
8403: IFFALSE 8439
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8405: LD_VAR 0 1
8409: PPUSH
8410: LD_INT 81
8412: PUSH
8413: LD_INT 3
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: PPUSH
8425: LD_VAR 0 1
8429: PPUSH
8430: CALL_OW 74
8434: PPUSH
8435: CALL_OW 115
8439: GO 8390
8441: POP
8442: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8443: LD_VAR 0 4
8447: PPUSH
8448: LD_INT 50
8450: PUSH
8451: EMPTY
8452: LIST
8453: PPUSH
8454: CALL_OW 72
8458: NOT
8459: IFFALSE 8373
// end ;
8461: PPOPN 5
8463: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8464: LD_EXP 5
8468: NOT
8469: IFFALSE 9056
8471: GO 8473
8473: DISABLE
8474: LD_INT 0
8476: PPUSH
8477: PPUSH
8478: PPUSH
8479: PPUSH
// begin enable ;
8480: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8481: LD_OWVAR 67
8485: PUSH
8486: LD_INT 1
8488: EQUAL
8489: PUSH
8490: LD_OWVAR 1
8494: PUSH
8495: LD_INT 63000
8497: LESS
8498: AND
8499: IFFALSE 8503
// exit ;
8501: GO 9056
// tmp := [ ] ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// if tick < 45 45$00 then
8510: LD_OWVAR 1
8514: PUSH
8515: LD_INT 94500
8517: LESS
8518: IFFALSE 8695
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8520: LD_ADDR_VAR 0 1
8524: PUSH
8525: DOUBLE
8526: LD_INT 1
8528: DEC
8529: ST_TO_ADDR
8530: LD_INT 2
8532: PUSH
8533: LD_INT 3
8535: PUSH
8536: LD_INT 4
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PUSH
8544: LD_OWVAR 67
8548: ARRAY
8549: PUSH
8550: FOR_TO
8551: IFFALSE 8693
// begin uc_side := 3 ;
8553: LD_ADDR_OWVAR 20
8557: PUSH
8558: LD_INT 3
8560: ST_TO_ADDR
// uc_nation := 3 ;
8561: LD_ADDR_OWVAR 21
8565: PUSH
8566: LD_INT 3
8568: ST_TO_ADDR
// InitHC_All ( ) ;
8569: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_INT 1
8578: PPUSH
8579: LD_INT 5
8581: PUSH
8582: LD_INT 6
8584: PUSH
8585: LD_INT 7
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PPUSH
8599: CALL_OW 380
// un := CreateHuman ;
8603: LD_ADDR_VAR 0 2
8607: PUSH
8608: CALL_OW 44
8612: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8613: LD_VAR 0 2
8617: PPUSH
8618: LD_INT 18
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_INT 9
8635: PPUSH
8636: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8640: LD_VAR 0 2
8644: PPUSH
8645: LD_INT 147
8647: PPUSH
8648: LD_INT 161
8650: PPUSH
8651: CALL_OW 111
// wait ( 0 0$2 ) ;
8655: LD_INT 70
8657: PPUSH
8658: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8662: LD_ADDR_VAR 0 3
8666: PUSH
8667: LD_VAR 0 3
8671: PPUSH
8672: LD_VAR 0 3
8676: PUSH
8677: LD_INT 1
8679: PLUS
8680: PPUSH
8681: LD_VAR 0 2
8685: PPUSH
8686: CALL_OW 1
8690: ST_TO_ADDR
// end ;
8691: GO 8550
8693: POP
8694: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8695: LD_ADDR_VAR 0 4
8699: PUSH
8700: LD_INT 3
8702: PUSH
8703: LD_INT 4
8705: PUSH
8706: LD_INT 5
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_OWVAR 67
8718: ARRAY
8719: PUSH
8720: LD_OWVAR 1
8724: PUSH
8725: LD_INT 21000
8727: DIV
8728: PLUS
8729: ST_TO_ADDR
// if amount > 15 then
8730: LD_VAR 0 4
8734: PUSH
8735: LD_INT 15
8737: GREATER
8738: IFFALSE 8748
// amount := 15 ;
8740: LD_ADDR_VAR 0 4
8744: PUSH
8745: LD_INT 15
8747: ST_TO_ADDR
// for i := 1 to amount do
8748: LD_ADDR_VAR 0 1
8752: PUSH
8753: DOUBLE
8754: LD_INT 1
8756: DEC
8757: ST_TO_ADDR
8758: LD_VAR 0 4
8762: PUSH
8763: FOR_TO
8764: IFFALSE 8910
// begin uc_side := 3 ;
8766: LD_ADDR_OWVAR 20
8770: PUSH
8771: LD_INT 3
8773: ST_TO_ADDR
// uc_nation := 3 ;
8774: LD_ADDR_OWVAR 21
8778: PUSH
8779: LD_INT 3
8781: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8782: LD_INT 24
8784: PPUSH
8785: LD_INT 1
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: LD_INT 46
8793: PUSH
8794: LD_INT 45
8796: PUSH
8797: LD_INT 44
8799: PUSH
8800: LD_INT 43
8802: PUSH
8803: LD_INT 42
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 5
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: PPUSH
8825: LD_INT 90
8827: PPUSH
8828: CALL 15868 0 5
// un := CreateVehicle ;
8832: LD_ADDR_VAR 0 2
8836: PUSH
8837: CALL_OW 45
8841: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8842: LD_VAR 0 2
8846: PPUSH
8847: LD_INT 18
8849: PPUSH
8850: LD_INT 0
8852: PPUSH
8853: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8857: LD_VAR 0 2
8861: PPUSH
8862: LD_INT 147
8864: PPUSH
8865: LD_INT 161
8867: PPUSH
8868: CALL_OW 111
// wait ( 0 0$3 ) ;
8872: LD_INT 105
8874: PPUSH
8875: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8879: LD_ADDR_VAR 0 3
8883: PUSH
8884: LD_VAR 0 3
8888: PPUSH
8889: LD_VAR 0 3
8893: PUSH
8894: LD_INT 1
8896: PLUS
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// end ;
8908: GO 8763
8910: POP
8911: POP
// if not tmp then
8912: LD_VAR 0 3
8916: NOT
8917: IFFALSE 8921
// exit ;
8919: GO 9056
// wait ( 0 0$5 ) ;
8921: LD_INT 175
8923: PPUSH
8924: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8928: LD_INT 70
8930: PPUSH
8931: CALL_OW 67
// for i in tmp do
8935: LD_ADDR_VAR 0 1
8939: PUSH
8940: LD_VAR 0 3
8944: PUSH
8945: FOR_IN
8946: IFFALSE 9047
// begin if not IsOk ( i ) or IsDead ( i ) then
8948: LD_VAR 0 1
8952: PPUSH
8953: CALL_OW 302
8957: NOT
8958: PUSH
8959: LD_VAR 0 1
8963: PPUSH
8964: CALL_OW 301
8968: OR
8969: IFFALSE 8987
// tmp := tmp diff i ;
8971: LD_ADDR_VAR 0 3
8975: PUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 1
8985: DIFF
8986: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8987: LD_VAR 0 1
8991: PPUSH
8992: CALL_OW 257
8996: PUSH
8997: LD_INT 9
8999: EQUAL
9000: IFFALSE 9011
// ComSpaceTimeShoot ( i ) ;
9002: LD_VAR 0 1
9006: PPUSH
9007: CALL 11951 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9011: LD_VAR 0 1
9015: PPUSH
9016: LD_INT 81
9018: PUSH
9019: LD_INT 3
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: PPUSH
9031: LD_VAR 0 1
9035: PPUSH
9036: CALL_OW 74
9040: PPUSH
9041: CALL_OW 115
// end ;
9045: GO 8945
9047: POP
9048: POP
// until not tmp ;
9049: LD_VAR 0 3
9053: NOT
9054: IFFALSE 8928
// end ; end_of_file
9056: PPOPN 4
9058: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
// uc_side := 1 ;
9065: LD_ADDR_OWVAR 20
9069: PUSH
9070: LD_INT 1
9072: ST_TO_ADDR
// uc_nation := 1 ;
9073: LD_ADDR_OWVAR 21
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// hc_importance := 100 ;
9081: LD_ADDR_OWVAR 32
9085: PUSH
9086: LD_INT 100
9088: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9089: LD_ADDR_OWVAR 26
9093: PUSH
9094: LD_STRING Jeremy Sikorski
9096: ST_TO_ADDR
// hc_gallery := us ;
9097: LD_ADDR_OWVAR 33
9101: PUSH
9102: LD_STRING us
9104: ST_TO_ADDR
// hc_face_number := 19 ;
9105: LD_ADDR_OWVAR 34
9109: PUSH
9110: LD_INT 19
9112: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 4
9121: PUSH
9122: LD_INT 4
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: PUSH
9133: LD_OWVAR 67
9137: ARRAY
9138: PPUSH
9139: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9143: LD_ADDR_OWVAR 29
9147: PUSH
9148: LD_INT 10
9150: PUSH
9151: LD_INT 12
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: ST_TO_ADDR
// Sikorski := CreateHuman ;
9158: LD_ADDR_EXP 20
9162: PUSH
9163: CALL_OW 44
9167: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9168: LD_EXP 20
9172: PPUSH
9173: LD_INT 133
9175: PPUSH
9176: LD_INT 19
9178: PPUSH
9179: LD_INT 2
9181: PPUSH
9182: LD_INT 0
9184: PPUSH
9185: CALL_OW 50
// InitHc_All ( ) ;
9189: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_INT 4
9205: PUSH
9206: LD_INT 3
9208: PUSH
9209: LD_INT 3
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: LIST
9216: PUSH
9217: LD_OWVAR 67
9221: ARRAY
9222: PUSH
9223: FOR_TO
9224: IFFALSE 9340
// for j := 1 to 4 do
9226: LD_ADDR_VAR 0 3
9230: PUSH
9231: DOUBLE
9232: LD_INT 1
9234: DEC
9235: ST_TO_ADDR
9236: LD_INT 4
9238: PUSH
9239: FOR_TO
9240: IFFALSE 9336
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9242: LD_INT 0
9244: PPUSH
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 5
9252: PUSH
9253: LD_INT 4
9255: PUSH
9256: LD_INT 3
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: LIST
9263: PUSH
9264: LD_OWVAR 67
9268: ARRAY
9269: PPUSH
9270: CALL_OW 380
// un := CreateHuman ;
9274: LD_ADDR_VAR 0 4
9278: PUSH
9279: CALL_OW 44
9283: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9284: LD_VAR 0 4
9288: PPUSH
9289: LD_INT 0
9291: PPUSH
9292: LD_INT 5
9294: PPUSH
9295: CALL_OW 12
9299: PPUSH
9300: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9304: LD_VAR 0 4
9308: PPUSH
9309: LD_INT 133
9311: PPUSH
9312: LD_INT 19
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 0
9320: PPUSH
9321: CALL_OW 50
// ComHold ( un ) ;
9325: LD_VAR 0 4
9329: PPUSH
9330: CALL_OW 140
// end ;
9334: GO 9239
9336: POP
9337: POP
9338: GO 9223
9340: POP
9341: POP
// vc_chassis := us_heavy_tracked ;
9342: LD_ADDR_OWVAR 37
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// vc_engine := engine_combustion ;
9350: LD_ADDR_OWVAR 39
9354: PUSH
9355: LD_INT 1
9357: ST_TO_ADDR
// vc_control := control_manual ;
9358: LD_ADDR_OWVAR 38
9362: PUSH
9363: LD_INT 1
9365: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9366: LD_ADDR_OWVAR 40
9370: PUSH
9371: LD_INT 14
9373: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9374: LD_ADDR_OWVAR 41
9378: PUSH
9379: LD_INT 60
9381: ST_TO_ADDR
// un := CreateVehicle ;
9382: LD_ADDR_VAR 0 4
9386: PUSH
9387: CALL_OW 45
9391: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 2
9399: PPUSH
9400: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9404: LD_VAR 0 4
9408: PPUSH
9409: LD_INT 128
9411: PPUSH
9412: LD_INT 12
9414: PPUSH
9415: LD_INT 0
9417: PPUSH
9418: CALL_OW 48
// for i := 1 to 3 do
9422: LD_ADDR_VAR 0 2
9426: PUSH
9427: DOUBLE
9428: LD_INT 1
9430: DEC
9431: ST_TO_ADDR
9432: LD_INT 3
9434: PUSH
9435: FOR_TO
9436: IFFALSE 9459
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9438: LD_INT 5
9440: PPUSH
9441: LD_INT 133
9443: PPUSH
9444: LD_INT 19
9446: PPUSH
9447: LD_INT 3
9449: PPUSH
9450: LD_INT 0
9452: PPUSH
9453: CALL_OW 56
9457: GO 9435
9459: POP
9460: POP
// end ; end_of_file
9461: LD_VAR 0 1
9465: RET
// export function Action ; begin
9466: LD_INT 0
9468: PPUSH
// InGameOn ;
9469: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9473: LD_INT 133
9475: PPUSH
9476: LD_INT 19
9478: PPUSH
9479: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9483: LD_EXP 20
9487: PPUSH
9488: LD_STRING WT-DS-1
9490: PPUSH
9491: CALL_OW 88
// InGameOff ;
9495: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9499: LD_STRING DestroyEnemy
9501: PPUSH
9502: CALL_OW 337
// wait ( 0 0$20 ) ;
9506: LD_INT 700
9508: PPUSH
9509: CALL_OW 67
// DialogueOn ;
9513: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9517: LD_INT 100
9519: PPUSH
9520: LD_INT 37
9522: PPUSH
9523: LD_INT 1
9525: PPUSH
9526: LD_INT 30
9528: NEG
9529: PPUSH
9530: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9534: LD_INT 100
9536: PPUSH
9537: LD_INT 37
9539: PPUSH
9540: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9544: LD_EXP 10
9548: PPUSH
9549: LD_STRING WT-PL-1
9551: PPUSH
9552: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9556: LD_EXP 20
9560: PPUSH
9561: LD_STRING WT-DS-2
9563: PPUSH
9564: CALL_OW 88
// DialogueOff ;
9568: CALL_OW 7
// wait ( 0 0$2 ) ;
9572: LD_INT 70
9574: PPUSH
9575: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9579: LD_INT 100
9581: PPUSH
9582: LD_INT 37
9584: PPUSH
9585: LD_INT 1
9587: PPUSH
9588: CALL_OW 331
// end ;
9592: LD_VAR 0 1
9596: RET
// export function DialogPowellsAttack ; begin
9597: LD_INT 0
9599: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9600: LD_EXP 10
9604: PPUSH
9605: LD_STRING WT-PL-8
9607: PPUSH
9608: CALL_OW 94
// end ;
9612: LD_VAR 0 1
9616: RET
// export function DialogContaminateSib ( x , y ) ; begin
9617: LD_INT 0
9619: PPUSH
// DialogueOn ;
9620: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9624: LD_VAR 0 1
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9638: LD_EXP 20
9642: PPUSH
9643: LD_STRING WT-DS-3
9645: PPUSH
9646: CALL_OW 88
// DialogueOff ;
9650: CALL_OW 7
// end ;
9654: LD_VAR 0 3
9658: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9659: LD_EXP 8
9663: NOT
9664: PUSH
9665: LD_INT 1
9667: PPUSH
9668: LD_INT 81
9670: PUSH
9671: LD_INT 4
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL_OW 70
9682: PUSH
9683: LD_INT 3
9685: GREATER
9686: AND
9687: IFFALSE 9759
9689: GO 9691
9691: DISABLE
// begin powellInTrouble := true ;
9692: LD_ADDR_EXP 8
9696: PUSH
9697: LD_INT 1
9699: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9700: LD_EXP 20
9704: PPUSH
9705: LD_STRING WT-DS-6
9707: PPUSH
9708: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9712: LD_INT 1
9714: PPUSH
9715: LD_INT 22
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 70
9729: NOT
9730: IFFALSE 9744
// SayRadio ( Powell , WT-PL-6 ) ;
9732: LD_EXP 10
9736: PPUSH
9737: LD_STRING WT-PL-6
9739: PPUSH
9740: CALL_OW 94
// wait ( 1 1$30 ) ;
9744: LD_INT 3150
9746: PPUSH
9747: CALL_OW 67
// powellInTrouble := false ;
9751: LD_ADDR_EXP 8
9755: PUSH
9756: LD_INT 0
9758: ST_TO_ADDR
// end ;
9759: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9760: LD_EXP 9
9764: NOT
9765: PUSH
9766: LD_INT 16
9768: PPUSH
9769: LD_INT 81
9771: PUSH
9772: LD_INT 1
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 70
9783: PUSH
9784: LD_INT 6
9786: GREATER
9787: AND
9788: IFFALSE 9861
9790: GO 9792
9792: DISABLE
// begin sikorskiInTrouble := true ;
9793: LD_ADDR_EXP 9
9797: PUSH
9798: LD_INT 1
9800: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9801: LD_EXP 20
9805: PPUSH
9806: LD_STRING WT-DS-7
9808: PPUSH
9809: CALL_OW 88
// if not powellAttackGroup then
9813: LD_EXP 12
9817: NOT
9818: IFFALSE 9834
// SayRadio ( Powell , WT-PL-7n ) else
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-7n
9827: PPUSH
9828: CALL_OW 94
9832: GO 9846
// SayRadio ( Powell , WT-PL-7y ) ;
9834: LD_EXP 10
9838: PPUSH
9839: LD_STRING WT-PL-7y
9841: PPUSH
9842: CALL_OW 94
// wait ( 1 1$30 ) ;
9846: LD_INT 3150
9848: PPUSH
9849: CALL_OW 67
// sikorskiInTrouble := false ;
9853: LD_ADDR_EXP 9
9857: PUSH
9858: LD_INT 0
9860: ST_TO_ADDR
// end ;
9861: END
// export function DialogPowellsAttackFailed ; begin
9862: LD_INT 0
9864: PPUSH
// if not ruDestroyed then
9865: LD_EXP 5
9869: NOT
9870: IFFALSE 9886
// SayRadio ( Powell , WT-PL-9 ) else
9872: LD_EXP 10
9876: PPUSH
9877: LD_STRING WT-PL-9
9879: PPUSH
9880: CALL_OW 94
9884: GO 9898
// SayRadio ( Powell , WT-PL-10 ) ;
9886: LD_EXP 10
9890: PPUSH
9891: LD_STRING WT-PL-10
9893: PPUSH
9894: CALL_OW 94
// end ;
9898: LD_VAR 0 1
9902: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9903: LD_INT 22
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 1
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: PPUSH
9927: CALL_OW 69
9931: PUSH
9932: LD_INT 0
9934: EQUAL
9935: IFFALSE 9979
9937: GO 9939
9939: DISABLE
// begin arDestroyed := true ;
9940: LD_ADDR_EXP 4
9944: PUSH
9945: LD_INT 1
9947: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9948: LD_INT 2
9950: PPUSH
9951: CALL 50120 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9955: LD_EXP 20
9959: PPUSH
9960: LD_STRING WT-DS-4
9962: PPUSH
9963: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9967: LD_EXP 10
9971: PPUSH
9972: LD_STRING WT-PL-4
9974: PPUSH
9975: CALL_OW 94
// end ;
9979: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9980: LD_INT 22
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 21
9992: PUSH
9993: LD_INT 1
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PPUSH
10004: CALL_OW 69
10008: PUSH
10009: LD_INT 0
10011: EQUAL
10012: IFFALSE 10056
10014: GO 10016
10016: DISABLE
// begin ruDestroyed := true ;
10017: LD_ADDR_EXP 5
10021: PUSH
10022: LD_INT 1
10024: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10025: LD_INT 3
10027: PPUSH
10028: CALL 50120 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10032: LD_EXP 20
10036: PPUSH
10037: LD_STRING WT-DS-5
10039: PPUSH
10040: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10044: LD_EXP 10
10048: PPUSH
10049: LD_STRING WT-PL-5
10051: PPUSH
10052: CALL_OW 94
// end ;
10056: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10057: LD_EXP 5
10061: PUSH
10062: LD_EXP 4
10066: AND
10067: IFFALSE 10240
10069: GO 10071
10071: DISABLE
// begin wait ( 0 0$3 ) ;
10072: LD_INT 105
10074: PPUSH
10075: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10079: LD_OWVAR 1
10083: PUSH
10084: LD_INT 126000
10086: PUSH
10087: LD_INT 105000
10089: PUSH
10090: LD_INT 94500
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: PUSH
10098: LD_OWVAR 67
10102: ARRAY
10103: GREATEREQUAL
10104: IFFALSE 10119
// AddMedal ( WoT-med-1 , - 1 ) else
10106: LD_STRING WoT-med-1
10108: PPUSH
10109: LD_INT 1
10111: NEG
10112: PPUSH
10113: CALL_OW 101
10117: GO 10129
// AddMedal ( WoT-med-1 , 1 ) ;
10119: LD_STRING WoT-med-1
10121: PPUSH
10122: LD_INT 1
10124: PPUSH
10125: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10129: LD_EXP 6
10133: PUSH
10134: LD_INT 4
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 2
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_OWVAR 67
10152: ARRAY
10153: GREATEREQUAL
10154: IFFALSE 10169
// AddMedal ( WoT-med-2 , - 1 ) else
10156: LD_STRING WoT-med-2
10158: PPUSH
10159: LD_INT 1
10161: NEG
10162: PPUSH
10163: CALL_OW 101
10167: GO 10179
// AddMedal ( WoT-med-2 , 1 ) ;
10169: LD_STRING WoT-med-2
10171: PPUSH
10172: LD_INT 1
10174: PPUSH
10175: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10179: LD_EXP 7
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 5
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: LIST
10197: PUSH
10198: LD_OWVAR 67
10202: ARRAY
10203: GREATEREQUAL
10204: IFFALSE 10219
// AddMedal ( WoT-med-3 , - 1 ) else
10206: LD_STRING WoT-med-3
10208: PPUSH
10209: LD_INT 1
10211: NEG
10212: PPUSH
10213: CALL_OW 101
10217: GO 10229
// AddMedal ( WoT-med-3 , 1 ) ;
10219: LD_STRING WoT-med-3
10221: PPUSH
10222: LD_INT 1
10224: PPUSH
10225: CALL_OW 101
// GiveMedals ( MAIN ) ;
10229: LD_STRING MAIN
10231: PPUSH
10232: CALL_OW 102
// YouWin ;
10236: CALL_OW 103
// end ; end_of_file
10240: END
// export function CustomEvent ( event ) ; begin
10241: LD_INT 0
10243: PPUSH
// end ;
10244: LD_VAR 0 2
10248: RET
// on Command ( com ) do var i , j , temp ;
10249: LD_INT 0
10251: PPUSH
10252: PPUSH
10253: PPUSH
// begin if com = 60 then
10254: LD_VAR 0 1
10258: PUSH
10259: LD_INT 60
10261: EQUAL
10262: IFFALSE 10441
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10264: LD_ADDR_VAR 0 2
10268: PUSH
10269: LD_INT 22
10271: PUSH
10272: LD_INT 1
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 2
10281: PUSH
10282: LD_INT 21
10284: PUSH
10285: LD_INT 1
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 34
10294: PUSH
10295: LD_INT 12
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: EMPTY
10308: LIST
10309: LIST
10310: PPUSH
10311: CALL_OW 69
10315: PUSH
10316: FOR_IN
10317: IFFALSE 10439
// begin if GetTaskList ( i ) > 0 then
10319: LD_VAR 0 2
10323: PPUSH
10324: CALL_OW 437
10328: PUSH
10329: LD_INT 0
10331: GREATER
10332: IFFALSE 10437
// for j = 1 to GetTaskList ( i ) do
10334: LD_ADDR_VAR 0 3
10338: PUSH
10339: DOUBLE
10340: LD_INT 1
10342: DEC
10343: ST_TO_ADDR
10344: LD_VAR 0 2
10348: PPUSH
10349: CALL_OW 437
10353: PUSH
10354: FOR_TO
10355: IFFALSE 10435
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10357: LD_ADDR_VAR 0 4
10361: PUSH
10362: LD_VAR 0 2
10366: PPUSH
10367: CALL_OW 437
10371: PUSH
10372: LD_VAR 0 3
10376: ARRAY
10377: PUSH
10378: LD_INT 4
10380: ARRAY
10381: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10382: LD_VAR 0 4
10386: PPUSH
10387: CALL_OW 255
10391: PUSH
10392: LD_INT 4
10394: EQUAL
10395: PUSH
10396: LD_VAR 0 2
10400: PPUSH
10401: CALL_OW 437
10405: PUSH
10406: LD_VAR 0 3
10410: ARRAY
10411: PUSH
10412: LD_INT 1
10414: ARRAY
10415: PUSH
10416: LD_STRING <
10418: EQUAL
10419: AND
10420: IFFALSE 10433
// SetTaskList ( i , [ ] ) ;
10422: LD_VAR 0 2
10426: PPUSH
10427: EMPTY
10428: PPUSH
10429: CALL_OW 446
// end ;
10433: GO 10354
10435: POP
10436: POP
// end ;
10437: GO 10316
10439: POP
10440: POP
// end ; end ;
10441: PPOPN 4
10443: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10444: LD_VAR 0 2
10448: PPUSH
10449: LD_VAR 0 3
10453: PPUSH
10454: CALL_OW 428
10458: PPUSH
10459: CALL_OW 255
10463: PUSH
10464: LD_INT 1
10466: EQUAL
10467: PUSH
10468: LD_VAR 0 2
10472: PUSH
10473: LD_INT 132
10475: EQUAL
10476: PUSH
10477: LD_VAR 0 3
10481: PUSH
10482: LD_INT 39
10484: EQUAL
10485: AND
10486: OR
10487: IFFALSE 10503
// DialogContaminateSib ( x , y ) ;
10489: LD_VAR 0 2
10493: PPUSH
10494: LD_VAR 0 3
10498: PPUSH
10499: CALL 9617 0 2
// end ;
10503: PPOPN 3
10505: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
10506: LD_VAR 0 1
10510: PPUSH
10511: CALL 77371 0 1
// if un = Powell then
10515: LD_VAR 0 1
10519: PUSH
10520: LD_EXP 10
10524: EQUAL
10525: IFFALSE 10534
// YouLost ( Powell ) ;
10527: LD_STRING Powell
10529: PPUSH
10530: CALL_OW 104
// if un = Sikorski then
10534: LD_VAR 0 1
10538: PUSH
10539: LD_EXP 20
10543: EQUAL
10544: IFFALSE 10553
// YouLost ( Sikorski ) ;
10546: LD_STRING Sikorski
10548: PPUSH
10549: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10553: LD_VAR 0 1
10557: PUSH
10558: LD_INT 22
10560: PUSH
10561: LD_INT 1
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 21
10570: PUSH
10571: LD_INT 1
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PUSH
10578: EMPTY
10579: LIST
10580: LIST
10581: PPUSH
10582: CALL_OW 69
10586: IN
10587: IFFALSE 10603
// loseCounter := loseCounter + 1 ;
10589: LD_ADDR_EXP 6
10593: PUSH
10594: LD_EXP 6
10598: PUSH
10599: LD_INT 1
10601: PLUS
10602: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10603: LD_VAR 0 1
10607: PUSH
10608: LD_INT 22
10610: PUSH
10611: LD_INT 4
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: PUSH
10618: LD_INT 21
10620: PUSH
10621: LD_INT 1
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 69
10636: IN
10637: IFFALSE 10653
// powellLoseCounter := powellLoseCounter + 1 ;
10639: LD_ADDR_EXP 7
10643: PUSH
10644: LD_EXP 7
10648: PUSH
10649: LD_INT 1
10651: PLUS
10652: ST_TO_ADDR
// if un in powellAttackGroup then
10653: LD_VAR 0 1
10657: PUSH
10658: LD_EXP 12
10662: IN
10663: IFFALSE 10681
// powellAttackGroup := powellAttackGroup diff un ;
10665: LD_ADDR_EXP 12
10669: PUSH
10670: LD_EXP 12
10674: PUSH
10675: LD_VAR 0 1
10679: DIFF
10680: ST_TO_ADDR
// if un in gensherAttackGroup then
10681: LD_VAR 0 1
10685: PUSH
10686: LD_EXP 15
10690: IN
10691: IFFALSE 10709
// gensherAttackGroup := gensherAttackGroup diff un ;
10693: LD_ADDR_EXP 15
10697: PUSH
10698: LD_EXP 15
10702: PUSH
10703: LD_VAR 0 1
10707: DIFF
10708: ST_TO_ADDR
// if un in popovAttackGroup then
10709: LD_VAR 0 1
10713: PUSH
10714: LD_EXP 19
10718: IN
10719: IFFALSE 10737
// popovAttackGroup := popovAttackGroup diff un ;
10721: LD_ADDR_EXP 19
10725: PUSH
10726: LD_EXP 19
10730: PUSH
10731: LD_VAR 0 1
10735: DIFF
10736: ST_TO_ADDR
// end ;
10737: PPOPN 1
10739: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_VAR 0 2
10749: PPUSH
10750: CALL 79705 0 2
// end ;
10754: PPOPN 2
10756: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10757: LD_VAR 0 1
10761: PPUSH
10762: CALL 78773 0 1
// end ;
10766: PPOPN 1
10768: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10769: LD_VAR 0 1
10773: PPUSH
10774: CALL 79014 0 1
// end ;
10778: PPOPN 1
10780: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10781: LD_VAR 0 1
10785: PPUSH
10786: LD_VAR 0 2
10790: PPUSH
10791: CALL 77067 0 2
// end ;
10795: PPOPN 2
10797: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10798: LD_VAR 0 1
10802: PPUSH
10803: LD_VAR 0 2
10807: PPUSH
10808: LD_VAR 0 3
10812: PPUSH
10813: LD_VAR 0 4
10817: PPUSH
10818: LD_VAR 0 5
10822: PPUSH
10823: CALL 76687 0 5
// end ;
10827: PPOPN 5
10829: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10830: LD_VAR 0 1
10834: PPUSH
10835: LD_VAR 0 2
10839: PPUSH
10840: CALL 76268 0 2
// end ;
10844: PPOPN 2
10846: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10847: LD_VAR 0 1
10851: PPUSH
10852: LD_VAR 0 2
10856: PPUSH
10857: LD_VAR 0 3
10861: PPUSH
10862: LD_VAR 0 4
10866: PPUSH
10867: CALL 76106 0 4
// end ;
10871: PPOPN 4
10873: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10874: LD_VAR 0 1
10878: PPUSH
10879: LD_VAR 0 2
10883: PPUSH
10884: LD_VAR 0 3
10888: PPUSH
10889: CALL 75881 0 3
// end ;
10893: PPOPN 3
10895: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_VAR 0 2
10905: PPUSH
10906: CALL 75766 0 2
// end ;
10910: PPOPN 2
10912: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10913: LD_VAR 0 1
10917: PPUSH
10918: LD_VAR 0 2
10922: PPUSH
10923: CALL 80000 0 2
// end ;
10927: PPOPN 2
10929: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_VAR 0 2
10939: PPUSH
10940: LD_VAR 0 3
10944: PPUSH
10945: LD_VAR 0 4
10949: PPUSH
10950: CALL 80216 0 4
// end ;
10954: PPOPN 4
10956: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10957: LD_VAR 0 1
10961: PPUSH
10962: LD_VAR 0 2
10966: PPUSH
10967: CALL 75575 0 2
// end ;
10971: PPOPN 2
10973: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10974: LD_VAR 0 1
10978: PUSH
10979: LD_INT 1
10981: EQUAL
10982: PUSH
10983: LD_VAR 0 2
10987: PUSH
10988: LD_INT 4
10990: EQUAL
10991: AND
10992: IFFALSE 11001
// YouLost ( FriendlyFire ) ;
10994: LD_STRING FriendlyFire
10996: PPUSH
10997: CALL_OW 104
// end ; end_of_file
11001: PPOPN 2
11003: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11004: LD_INT 0
11006: PPUSH
11007: PPUSH
// if exist_mode then
11008: LD_VAR 0 2
11012: IFFALSE 11037
// unit := CreateCharacter ( prefix & ident ) else
11014: LD_ADDR_VAR 0 5
11018: PUSH
11019: LD_VAR 0 3
11023: PUSH
11024: LD_VAR 0 1
11028: STR
11029: PPUSH
11030: CALL_OW 34
11034: ST_TO_ADDR
11035: GO 11052
// unit := NewCharacter ( ident ) ;
11037: LD_ADDR_VAR 0 5
11041: PUSH
11042: LD_VAR 0 1
11046: PPUSH
11047: CALL_OW 25
11051: ST_TO_ADDR
// result := unit ;
11052: LD_ADDR_VAR 0 4
11056: PUSH
11057: LD_VAR 0 5
11061: ST_TO_ADDR
// end ;
11062: LD_VAR 0 4
11066: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11067: LD_INT 0
11069: PPUSH
11070: PPUSH
// if not side or not nation then
11071: LD_VAR 0 1
11075: NOT
11076: PUSH
11077: LD_VAR 0 2
11081: NOT
11082: OR
11083: IFFALSE 11087
// exit ;
11085: GO 11855
// case nation of nation_american :
11087: LD_VAR 0 2
11091: PUSH
11092: LD_INT 1
11094: DOUBLE
11095: EQUAL
11096: IFTRUE 11100
11098: GO 11314
11100: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11101: LD_ADDR_VAR 0 4
11105: PUSH
11106: LD_INT 35
11108: PUSH
11109: LD_INT 45
11111: PUSH
11112: LD_INT 46
11114: PUSH
11115: LD_INT 47
11117: PUSH
11118: LD_INT 82
11120: PUSH
11121: LD_INT 83
11123: PUSH
11124: LD_INT 84
11126: PUSH
11127: LD_INT 85
11129: PUSH
11130: LD_INT 86
11132: PUSH
11133: LD_INT 1
11135: PUSH
11136: LD_INT 2
11138: PUSH
11139: LD_INT 6
11141: PUSH
11142: LD_INT 15
11144: PUSH
11145: LD_INT 16
11147: PUSH
11148: LD_INT 7
11150: PUSH
11151: LD_INT 12
11153: PUSH
11154: LD_INT 13
11156: PUSH
11157: LD_INT 10
11159: PUSH
11160: LD_INT 14
11162: PUSH
11163: LD_INT 20
11165: PUSH
11166: LD_INT 21
11168: PUSH
11169: LD_INT 22
11171: PUSH
11172: LD_INT 25
11174: PUSH
11175: LD_INT 32
11177: PUSH
11178: LD_INT 27
11180: PUSH
11181: LD_INT 36
11183: PUSH
11184: LD_INT 69
11186: PUSH
11187: LD_INT 39
11189: PUSH
11190: LD_INT 34
11192: PUSH
11193: LD_INT 40
11195: PUSH
11196: LD_INT 48
11198: PUSH
11199: LD_INT 49
11201: PUSH
11202: LD_INT 50
11204: PUSH
11205: LD_INT 51
11207: PUSH
11208: LD_INT 52
11210: PUSH
11211: LD_INT 53
11213: PUSH
11214: LD_INT 54
11216: PUSH
11217: LD_INT 55
11219: PUSH
11220: LD_INT 56
11222: PUSH
11223: LD_INT 57
11225: PUSH
11226: LD_INT 58
11228: PUSH
11229: LD_INT 59
11231: PUSH
11232: LD_INT 60
11234: PUSH
11235: LD_INT 61
11237: PUSH
11238: LD_INT 62
11240: PUSH
11241: LD_INT 80
11243: PUSH
11244: LD_INT 82
11246: PUSH
11247: LD_INT 83
11249: PUSH
11250: LD_INT 84
11252: PUSH
11253: LD_INT 85
11255: PUSH
11256: LD_INT 86
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: ST_TO_ADDR
11312: GO 11779
11314: LD_INT 2
11316: DOUBLE
11317: EQUAL
11318: IFTRUE 11322
11320: GO 11548
11322: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11323: LD_ADDR_VAR 0 4
11327: PUSH
11328: LD_INT 35
11330: PUSH
11331: LD_INT 45
11333: PUSH
11334: LD_INT 46
11336: PUSH
11337: LD_INT 47
11339: PUSH
11340: LD_INT 82
11342: PUSH
11343: LD_INT 83
11345: PUSH
11346: LD_INT 84
11348: PUSH
11349: LD_INT 85
11351: PUSH
11352: LD_INT 87
11354: PUSH
11355: LD_INT 70
11357: PUSH
11358: LD_INT 1
11360: PUSH
11361: LD_INT 11
11363: PUSH
11364: LD_INT 3
11366: PUSH
11367: LD_INT 4
11369: PUSH
11370: LD_INT 5
11372: PUSH
11373: LD_INT 6
11375: PUSH
11376: LD_INT 15
11378: PUSH
11379: LD_INT 18
11381: PUSH
11382: LD_INT 7
11384: PUSH
11385: LD_INT 17
11387: PUSH
11388: LD_INT 8
11390: PUSH
11391: LD_INT 20
11393: PUSH
11394: LD_INT 21
11396: PUSH
11397: LD_INT 22
11399: PUSH
11400: LD_INT 72
11402: PUSH
11403: LD_INT 26
11405: PUSH
11406: LD_INT 69
11408: PUSH
11409: LD_INT 39
11411: PUSH
11412: LD_INT 40
11414: PUSH
11415: LD_INT 41
11417: PUSH
11418: LD_INT 42
11420: PUSH
11421: LD_INT 43
11423: PUSH
11424: LD_INT 48
11426: PUSH
11427: LD_INT 49
11429: PUSH
11430: LD_INT 50
11432: PUSH
11433: LD_INT 51
11435: PUSH
11436: LD_INT 52
11438: PUSH
11439: LD_INT 53
11441: PUSH
11442: LD_INT 54
11444: PUSH
11445: LD_INT 55
11447: PUSH
11448: LD_INT 56
11450: PUSH
11451: LD_INT 60
11453: PUSH
11454: LD_INT 61
11456: PUSH
11457: LD_INT 62
11459: PUSH
11460: LD_INT 66
11462: PUSH
11463: LD_INT 67
11465: PUSH
11466: LD_INT 68
11468: PUSH
11469: LD_INT 81
11471: PUSH
11472: LD_INT 82
11474: PUSH
11475: LD_INT 83
11477: PUSH
11478: LD_INT 84
11480: PUSH
11481: LD_INT 85
11483: PUSH
11484: LD_INT 87
11486: PUSH
11487: LD_INT 88
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: ST_TO_ADDR
11546: GO 11779
11548: LD_INT 3
11550: DOUBLE
11551: EQUAL
11552: IFTRUE 11556
11554: GO 11778
11556: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11557: LD_ADDR_VAR 0 4
11561: PUSH
11562: LD_INT 46
11564: PUSH
11565: LD_INT 47
11567: PUSH
11568: LD_INT 1
11570: PUSH
11571: LD_INT 2
11573: PUSH
11574: LD_INT 82
11576: PUSH
11577: LD_INT 83
11579: PUSH
11580: LD_INT 84
11582: PUSH
11583: LD_INT 85
11585: PUSH
11586: LD_INT 86
11588: PUSH
11589: LD_INT 11
11591: PUSH
11592: LD_INT 9
11594: PUSH
11595: LD_INT 20
11597: PUSH
11598: LD_INT 19
11600: PUSH
11601: LD_INT 21
11603: PUSH
11604: LD_INT 24
11606: PUSH
11607: LD_INT 22
11609: PUSH
11610: LD_INT 25
11612: PUSH
11613: LD_INT 28
11615: PUSH
11616: LD_INT 29
11618: PUSH
11619: LD_INT 30
11621: PUSH
11622: LD_INT 31
11624: PUSH
11625: LD_INT 37
11627: PUSH
11628: LD_INT 38
11630: PUSH
11631: LD_INT 32
11633: PUSH
11634: LD_INT 27
11636: PUSH
11637: LD_INT 33
11639: PUSH
11640: LD_INT 69
11642: PUSH
11643: LD_INT 39
11645: PUSH
11646: LD_INT 34
11648: PUSH
11649: LD_INT 40
11651: PUSH
11652: LD_INT 71
11654: PUSH
11655: LD_INT 23
11657: PUSH
11658: LD_INT 44
11660: PUSH
11661: LD_INT 48
11663: PUSH
11664: LD_INT 49
11666: PUSH
11667: LD_INT 50
11669: PUSH
11670: LD_INT 51
11672: PUSH
11673: LD_INT 52
11675: PUSH
11676: LD_INT 53
11678: PUSH
11679: LD_INT 54
11681: PUSH
11682: LD_INT 55
11684: PUSH
11685: LD_INT 56
11687: PUSH
11688: LD_INT 57
11690: PUSH
11691: LD_INT 58
11693: PUSH
11694: LD_INT 59
11696: PUSH
11697: LD_INT 63
11699: PUSH
11700: LD_INT 64
11702: PUSH
11703: LD_INT 65
11705: PUSH
11706: LD_INT 82
11708: PUSH
11709: LD_INT 83
11711: PUSH
11712: LD_INT 84
11714: PUSH
11715: LD_INT 85
11717: PUSH
11718: LD_INT 86
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: ST_TO_ADDR
11776: GO 11779
11778: POP
// if state > - 1 and state < 3 then
11779: LD_VAR 0 3
11783: PUSH
11784: LD_INT 1
11786: NEG
11787: GREATER
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_INT 3
11796: LESS
11797: AND
11798: IFFALSE 11855
// for i in result do
11800: LD_ADDR_VAR 0 5
11804: PUSH
11805: LD_VAR 0 4
11809: PUSH
11810: FOR_IN
11811: IFFALSE 11853
// if GetTech ( i , side ) <> state then
11813: LD_VAR 0 5
11817: PPUSH
11818: LD_VAR 0 1
11822: PPUSH
11823: CALL_OW 321
11827: PUSH
11828: LD_VAR 0 3
11832: NONEQUAL
11833: IFFALSE 11851
// result := result diff i ;
11835: LD_ADDR_VAR 0 4
11839: PUSH
11840: LD_VAR 0 4
11844: PUSH
11845: LD_VAR 0 5
11849: DIFF
11850: ST_TO_ADDR
11851: GO 11810
11853: POP
11854: POP
// end ;
11855: LD_VAR 0 4
11859: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11860: LD_INT 0
11862: PPUSH
11863: PPUSH
11864: PPUSH
// result := true ;
11865: LD_ADDR_VAR 0 3
11869: PUSH
11870: LD_INT 1
11872: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11873: LD_ADDR_VAR 0 5
11877: PUSH
11878: LD_VAR 0 2
11882: PPUSH
11883: CALL_OW 480
11887: ST_TO_ADDR
// if not tmp then
11888: LD_VAR 0 5
11892: NOT
11893: IFFALSE 11897
// exit ;
11895: GO 11946
// for i in tmp do
11897: LD_ADDR_VAR 0 4
11901: PUSH
11902: LD_VAR 0 5
11906: PUSH
11907: FOR_IN
11908: IFFALSE 11944
// if GetTech ( i , side ) <> state_researched then
11910: LD_VAR 0 4
11914: PPUSH
11915: LD_VAR 0 1
11919: PPUSH
11920: CALL_OW 321
11924: PUSH
11925: LD_INT 2
11927: NONEQUAL
11928: IFFALSE 11942
// begin result := false ;
11930: LD_ADDR_VAR 0 3
11934: PUSH
11935: LD_INT 0
11937: ST_TO_ADDR
// exit ;
11938: POP
11939: POP
11940: GO 11946
// end ;
11942: GO 11907
11944: POP
11945: POP
// end ;
11946: LD_VAR 0 3
11950: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11951: LD_INT 0
11953: PPUSH
11954: PPUSH
11955: PPUSH
11956: PPUSH
11957: PPUSH
11958: PPUSH
11959: PPUSH
11960: PPUSH
11961: PPUSH
11962: PPUSH
11963: PPUSH
11964: PPUSH
11965: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11966: LD_VAR 0 1
11970: NOT
11971: PUSH
11972: LD_VAR 0 1
11976: PPUSH
11977: CALL_OW 257
11981: PUSH
11982: LD_INT 9
11984: NONEQUAL
11985: OR
11986: IFFALSE 11990
// exit ;
11988: GO 12563
// side := GetSide ( unit ) ;
11990: LD_ADDR_VAR 0 9
11994: PUSH
11995: LD_VAR 0 1
11999: PPUSH
12000: CALL_OW 255
12004: ST_TO_ADDR
// tech_space := tech_spacanom ;
12005: LD_ADDR_VAR 0 12
12009: PUSH
12010: LD_INT 29
12012: ST_TO_ADDR
// tech_time := tech_taurad ;
12013: LD_ADDR_VAR 0 13
12017: PUSH
12018: LD_INT 28
12020: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12021: LD_ADDR_VAR 0 11
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 310
12035: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12036: LD_VAR 0 11
12040: PPUSH
12041: CALL_OW 247
12045: PUSH
12046: LD_INT 2
12048: EQUAL
12049: IFFALSE 12053
// exit ;
12051: GO 12563
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12053: LD_ADDR_VAR 0 8
12057: PUSH
12058: LD_INT 81
12060: PUSH
12061: LD_VAR 0 9
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 3
12072: PUSH
12073: LD_INT 21
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: EMPTY
12084: LIST
12085: LIST
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PPUSH
12091: CALL_OW 69
12095: ST_TO_ADDR
// if not tmp then
12096: LD_VAR 0 8
12100: NOT
12101: IFFALSE 12105
// exit ;
12103: GO 12563
// if in_unit then
12105: LD_VAR 0 11
12109: IFFALSE 12133
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12111: LD_ADDR_VAR 0 10
12115: PUSH
12116: LD_VAR 0 8
12120: PPUSH
12121: LD_VAR 0 11
12125: PPUSH
12126: CALL_OW 74
12130: ST_TO_ADDR
12131: GO 12153
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12133: LD_ADDR_VAR 0 10
12137: PUSH
12138: LD_VAR 0 8
12142: PPUSH
12143: LD_VAR 0 1
12147: PPUSH
12148: CALL_OW 74
12152: ST_TO_ADDR
// if not enemy then
12153: LD_VAR 0 10
12157: NOT
12158: IFFALSE 12162
// exit ;
12160: GO 12563
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12162: LD_VAR 0 11
12166: PUSH
12167: LD_VAR 0 11
12171: PPUSH
12172: LD_VAR 0 10
12176: PPUSH
12177: CALL_OW 296
12181: PUSH
12182: LD_INT 13
12184: GREATER
12185: AND
12186: PUSH
12187: LD_VAR 0 1
12191: PPUSH
12192: LD_VAR 0 10
12196: PPUSH
12197: CALL_OW 296
12201: PUSH
12202: LD_INT 12
12204: GREATER
12205: OR
12206: IFFALSE 12210
// exit ;
12208: GO 12563
// missile := [ 1 ] ;
12210: LD_ADDR_VAR 0 14
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12221: LD_VAR 0 9
12225: PPUSH
12226: LD_VAR 0 12
12230: PPUSH
12231: CALL_OW 325
12235: IFFALSE 12264
// missile := Insert ( missile , missile + 1 , 2 ) ;
12237: LD_ADDR_VAR 0 14
12241: PUSH
12242: LD_VAR 0 14
12246: PPUSH
12247: LD_VAR 0 14
12251: PUSH
12252: LD_INT 1
12254: PLUS
12255: PPUSH
12256: LD_INT 2
12258: PPUSH
12259: CALL_OW 2
12263: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12264: LD_VAR 0 9
12268: PPUSH
12269: LD_VAR 0 13
12273: PPUSH
12274: CALL_OW 325
12278: PUSH
12279: LD_VAR 0 10
12283: PPUSH
12284: CALL_OW 255
12288: PPUSH
12289: LD_VAR 0 13
12293: PPUSH
12294: CALL_OW 325
12298: NOT
12299: AND
12300: IFFALSE 12329
// missile := Insert ( missile , missile + 1 , 3 ) ;
12302: LD_ADDR_VAR 0 14
12306: PUSH
12307: LD_VAR 0 14
12311: PPUSH
12312: LD_VAR 0 14
12316: PUSH
12317: LD_INT 1
12319: PLUS
12320: PPUSH
12321: LD_INT 3
12323: PPUSH
12324: CALL_OW 2
12328: ST_TO_ADDR
// if missile < 2 then
12329: LD_VAR 0 14
12333: PUSH
12334: LD_INT 2
12336: LESS
12337: IFFALSE 12341
// exit ;
12339: GO 12563
// x := GetX ( enemy ) ;
12341: LD_ADDR_VAR 0 4
12345: PUSH
12346: LD_VAR 0 10
12350: PPUSH
12351: CALL_OW 250
12355: ST_TO_ADDR
// y := GetY ( enemy ) ;
12356: LD_ADDR_VAR 0 5
12360: PUSH
12361: LD_VAR 0 10
12365: PPUSH
12366: CALL_OW 251
12370: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12371: LD_ADDR_VAR 0 6
12375: PUSH
12376: LD_VAR 0 4
12380: PUSH
12381: LD_INT 1
12383: NEG
12384: PPUSH
12385: LD_INT 1
12387: PPUSH
12388: CALL_OW 12
12392: PLUS
12393: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12394: LD_ADDR_VAR 0 7
12398: PUSH
12399: LD_VAR 0 5
12403: PUSH
12404: LD_INT 1
12406: NEG
12407: PPUSH
12408: LD_INT 1
12410: PPUSH
12411: CALL_OW 12
12415: PLUS
12416: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12417: LD_VAR 0 6
12421: PPUSH
12422: LD_VAR 0 7
12426: PPUSH
12427: CALL_OW 488
12431: NOT
12432: IFFALSE 12454
// begin _x := x ;
12434: LD_ADDR_VAR 0 6
12438: PUSH
12439: LD_VAR 0 4
12443: ST_TO_ADDR
// _y := y ;
12444: LD_ADDR_VAR 0 7
12448: PUSH
12449: LD_VAR 0 5
12453: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12454: LD_ADDR_VAR 0 3
12458: PUSH
12459: LD_INT 1
12461: PPUSH
12462: LD_VAR 0 14
12466: PPUSH
12467: CALL_OW 12
12471: ST_TO_ADDR
// case i of 1 :
12472: LD_VAR 0 3
12476: PUSH
12477: LD_INT 1
12479: DOUBLE
12480: EQUAL
12481: IFTRUE 12485
12483: GO 12502
12485: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12486: LD_VAR 0 1
12490: PPUSH
12491: LD_VAR 0 10
12495: PPUSH
12496: CALL_OW 115
12500: GO 12563
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12532
12510: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12511: LD_VAR 0 1
12515: PPUSH
12516: LD_VAR 0 6
12520: PPUSH
12521: LD_VAR 0 7
12525: PPUSH
12526: CALL_OW 153
12530: GO 12563
12532: LD_INT 3
12534: DOUBLE
12535: EQUAL
12536: IFTRUE 12540
12538: GO 12562
12540: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 6
12550: PPUSH
12551: LD_VAR 0 7
12555: PPUSH
12556: CALL_OW 154
12560: GO 12563
12562: POP
// end ;
12563: LD_VAR 0 2
12567: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12568: LD_INT 0
12570: PPUSH
12571: PPUSH
12572: PPUSH
12573: PPUSH
12574: PPUSH
12575: PPUSH
// if not unit or not building then
12576: LD_VAR 0 1
12580: NOT
12581: PUSH
12582: LD_VAR 0 2
12586: NOT
12587: OR
12588: IFFALSE 12592
// exit ;
12590: GO 12750
// x := GetX ( building ) ;
12592: LD_ADDR_VAR 0 5
12596: PUSH
12597: LD_VAR 0 2
12601: PPUSH
12602: CALL_OW 250
12606: ST_TO_ADDR
// y := GetY ( building ) ;
12607: LD_ADDR_VAR 0 6
12611: PUSH
12612: LD_VAR 0 2
12616: PPUSH
12617: CALL_OW 251
12621: ST_TO_ADDR
// for i = 0 to 5 do
12622: LD_ADDR_VAR 0 4
12626: PUSH
12627: DOUBLE
12628: LD_INT 0
12630: DEC
12631: ST_TO_ADDR
12632: LD_INT 5
12634: PUSH
12635: FOR_TO
12636: IFFALSE 12748
// begin _x := ShiftX ( x , i , 3 ) ;
12638: LD_ADDR_VAR 0 7
12642: PUSH
12643: LD_VAR 0 5
12647: PPUSH
12648: LD_VAR 0 4
12652: PPUSH
12653: LD_INT 3
12655: PPUSH
12656: CALL_OW 272
12660: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12661: LD_ADDR_VAR 0 8
12665: PUSH
12666: LD_VAR 0 6
12670: PPUSH
12671: LD_VAR 0 4
12675: PPUSH
12676: LD_INT 3
12678: PPUSH
12679: CALL_OW 273
12683: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12684: LD_VAR 0 7
12688: PPUSH
12689: LD_VAR 0 8
12693: PPUSH
12694: CALL_OW 488
12698: NOT
12699: IFFALSE 12703
// continue ;
12701: GO 12635
// if HexInfo ( _x , _y ) = 0 then
12703: LD_VAR 0 7
12707: PPUSH
12708: LD_VAR 0 8
12712: PPUSH
12713: CALL_OW 428
12717: PUSH
12718: LD_INT 0
12720: EQUAL
12721: IFFALSE 12746
// begin ComMoveXY ( unit , _x , _y ) ;
12723: LD_VAR 0 1
12727: PPUSH
12728: LD_VAR 0 7
12732: PPUSH
12733: LD_VAR 0 8
12737: PPUSH
12738: CALL_OW 111
// exit ;
12742: POP
12743: POP
12744: GO 12750
// end ; end ;
12746: GO 12635
12748: POP
12749: POP
// end ;
12750: LD_VAR 0 3
12754: RET
// export function ScanBase ( side , base_area ) ; begin
12755: LD_INT 0
12757: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_VAR 0 2
12767: PPUSH
12768: LD_INT 81
12770: PUSH
12771: LD_VAR 0 1
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PPUSH
12780: CALL_OW 70
12784: ST_TO_ADDR
// end ;
12785: LD_VAR 0 3
12789: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12790: LD_INT 0
12792: PPUSH
12793: PPUSH
12794: PPUSH
12795: PPUSH
// result := false ;
12796: LD_ADDR_VAR 0 2
12800: PUSH
12801: LD_INT 0
12803: ST_TO_ADDR
// side := GetSide ( unit ) ;
12804: LD_ADDR_VAR 0 3
12808: PUSH
12809: LD_VAR 0 1
12813: PPUSH
12814: CALL_OW 255
12818: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12819: LD_ADDR_VAR 0 4
12823: PUSH
12824: LD_VAR 0 1
12828: PPUSH
12829: CALL_OW 248
12833: ST_TO_ADDR
// case nat of 1 :
12834: LD_VAR 0 4
12838: PUSH
12839: LD_INT 1
12841: DOUBLE
12842: EQUAL
12843: IFTRUE 12847
12845: GO 12858
12847: POP
// tech := tech_lassight ; 2 :
12848: LD_ADDR_VAR 0 5
12852: PUSH
12853: LD_INT 12
12855: ST_TO_ADDR
12856: GO 12897
12858: LD_INT 2
12860: DOUBLE
12861: EQUAL
12862: IFTRUE 12866
12864: GO 12877
12866: POP
// tech := tech_mortar ; 3 :
12867: LD_ADDR_VAR 0 5
12871: PUSH
12872: LD_INT 41
12874: ST_TO_ADDR
12875: GO 12897
12877: LD_INT 3
12879: DOUBLE
12880: EQUAL
12881: IFTRUE 12885
12883: GO 12896
12885: POP
// tech := tech_bazooka ; end ;
12886: LD_ADDR_VAR 0 5
12890: PUSH
12891: LD_INT 44
12893: ST_TO_ADDR
12894: GO 12897
12896: POP
// if Researched ( side , tech ) then
12897: LD_VAR 0 3
12901: PPUSH
12902: LD_VAR 0 5
12906: PPUSH
12907: CALL_OW 325
12911: IFFALSE 12938
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12913: LD_ADDR_VAR 0 2
12917: PUSH
12918: LD_INT 5
12920: PUSH
12921: LD_INT 8
12923: PUSH
12924: LD_INT 9
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: LIST
12931: PUSH
12932: LD_VAR 0 4
12936: ARRAY
12937: ST_TO_ADDR
// end ;
12938: LD_VAR 0 2
12942: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12943: LD_INT 0
12945: PPUSH
12946: PPUSH
12947: PPUSH
// if not mines then
12948: LD_VAR 0 2
12952: NOT
12953: IFFALSE 12957
// exit ;
12955: GO 13101
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12957: LD_ADDR_VAR 0 5
12961: PUSH
12962: LD_INT 81
12964: PUSH
12965: LD_VAR 0 1
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 3
12976: PUSH
12977: LD_INT 21
12979: PUSH
12980: LD_INT 3
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PPUSH
12995: CALL_OW 69
12999: ST_TO_ADDR
// for i in mines do
13000: LD_ADDR_VAR 0 4
13004: PUSH
13005: LD_VAR 0 2
13009: PUSH
13010: FOR_IN
13011: IFFALSE 13099
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13013: LD_VAR 0 4
13017: PUSH
13018: LD_INT 1
13020: ARRAY
13021: PPUSH
13022: LD_VAR 0 4
13026: PUSH
13027: LD_INT 2
13029: ARRAY
13030: PPUSH
13031: CALL_OW 458
13035: NOT
13036: IFFALSE 13040
// continue ;
13038: GO 13010
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13040: LD_VAR 0 4
13044: PUSH
13045: LD_INT 1
13047: ARRAY
13048: PPUSH
13049: LD_VAR 0 4
13053: PUSH
13054: LD_INT 2
13056: ARRAY
13057: PPUSH
13058: CALL_OW 428
13062: PUSH
13063: LD_VAR 0 5
13067: IN
13068: IFFALSE 13097
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13070: LD_VAR 0 4
13074: PUSH
13075: LD_INT 1
13077: ARRAY
13078: PPUSH
13079: LD_VAR 0 4
13083: PUSH
13084: LD_INT 2
13086: ARRAY
13087: PPUSH
13088: LD_VAR 0 1
13092: PPUSH
13093: CALL_OW 456
// end ;
13097: GO 13010
13099: POP
13100: POP
// end ;
13101: LD_VAR 0 3
13105: RET
// export function Count ( array ) ; var i ; begin
13106: LD_INT 0
13108: PPUSH
13109: PPUSH
// result := 0 ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_INT 0
13117: ST_TO_ADDR
// for i in array do
13118: LD_ADDR_VAR 0 3
13122: PUSH
13123: LD_VAR 0 1
13127: PUSH
13128: FOR_IN
13129: IFFALSE 13153
// if i then
13131: LD_VAR 0 3
13135: IFFALSE 13151
// result := result + 1 ;
13137: LD_ADDR_VAR 0 2
13141: PUSH
13142: LD_VAR 0 2
13146: PUSH
13147: LD_INT 1
13149: PLUS
13150: ST_TO_ADDR
13151: GO 13128
13153: POP
13154: POP
// end ;
13155: LD_VAR 0 2
13159: RET
// export function IsEmpty ( building ) ; begin
13160: LD_INT 0
13162: PPUSH
// if not building then
13163: LD_VAR 0 1
13167: NOT
13168: IFFALSE 13172
// exit ;
13170: GO 13215
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13172: LD_ADDR_VAR 0 2
13176: PUSH
13177: LD_VAR 0 1
13181: PUSH
13182: LD_INT 22
13184: PUSH
13185: LD_VAR 0 1
13189: PPUSH
13190: CALL_OW 255
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 58
13201: PUSH
13202: EMPTY
13203: LIST
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PPUSH
13209: CALL_OW 69
13213: IN
13214: ST_TO_ADDR
// end ;
13215: LD_VAR 0 2
13219: RET
// export function IsNotFull ( building ) ; begin
13220: LD_INT 0
13222: PPUSH
// if not building then
13223: LD_VAR 0 1
13227: NOT
13228: IFFALSE 13232
// exit ;
13230: GO 13251
// result := UnitsInside ( building ) < 6 ;
13232: LD_ADDR_VAR 0 2
13236: PUSH
13237: LD_VAR 0 1
13241: PPUSH
13242: CALL_OW 313
13246: PUSH
13247: LD_INT 6
13249: LESS
13250: ST_TO_ADDR
// end ;
13251: LD_VAR 0 2
13255: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13256: LD_INT 0
13258: PPUSH
13259: PPUSH
13260: PPUSH
13261: PPUSH
// tmp := [ ] ;
13262: LD_ADDR_VAR 0 3
13266: PUSH
13267: EMPTY
13268: ST_TO_ADDR
// list := [ ] ;
13269: LD_ADDR_VAR 0 5
13273: PUSH
13274: EMPTY
13275: ST_TO_ADDR
// for i = 16 to 25 do
13276: LD_ADDR_VAR 0 4
13280: PUSH
13281: DOUBLE
13282: LD_INT 16
13284: DEC
13285: ST_TO_ADDR
13286: LD_INT 25
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13363
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13292: LD_ADDR_VAR 0 3
13296: PUSH
13297: LD_VAR 0 3
13301: PUSH
13302: LD_INT 22
13304: PUSH
13305: LD_VAR 0 1
13309: PPUSH
13310: CALL_OW 255
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: PUSH
13319: LD_INT 91
13321: PUSH
13322: LD_VAR 0 1
13326: PUSH
13327: LD_INT 6
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 30
13337: PUSH
13338: LD_VAR 0 4
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: LIST
13351: PUSH
13352: EMPTY
13353: LIST
13354: PPUSH
13355: CALL_OW 69
13359: ADD
13360: ST_TO_ADDR
13361: GO 13289
13363: POP
13364: POP
// for i = 1 to tmp do
13365: LD_ADDR_VAR 0 4
13369: PUSH
13370: DOUBLE
13371: LD_INT 1
13373: DEC
13374: ST_TO_ADDR
13375: LD_VAR 0 3
13379: PUSH
13380: FOR_TO
13381: IFFALSE 13469
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13383: LD_ADDR_VAR 0 5
13387: PUSH
13388: LD_VAR 0 5
13392: PUSH
13393: LD_VAR 0 3
13397: PUSH
13398: LD_VAR 0 4
13402: ARRAY
13403: PPUSH
13404: CALL_OW 266
13408: PUSH
13409: LD_VAR 0 3
13413: PUSH
13414: LD_VAR 0 4
13418: ARRAY
13419: PPUSH
13420: CALL_OW 250
13424: PUSH
13425: LD_VAR 0 3
13429: PUSH
13430: LD_VAR 0 4
13434: ARRAY
13435: PPUSH
13436: CALL_OW 251
13440: PUSH
13441: LD_VAR 0 3
13445: PUSH
13446: LD_VAR 0 4
13450: ARRAY
13451: PPUSH
13452: CALL_OW 254
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: PUSH
13463: EMPTY
13464: LIST
13465: ADD
13466: ST_TO_ADDR
13467: GO 13380
13469: POP
13470: POP
// result := list ;
13471: LD_ADDR_VAR 0 2
13475: PUSH
13476: LD_VAR 0 5
13480: ST_TO_ADDR
// end ;
13481: LD_VAR 0 2
13485: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13486: LD_INT 0
13488: PPUSH
13489: PPUSH
13490: PPUSH
13491: PPUSH
13492: PPUSH
13493: PPUSH
13494: PPUSH
// if not factory then
13495: LD_VAR 0 1
13499: NOT
13500: IFFALSE 13504
// exit ;
13502: GO 14097
// if control = control_apeman then
13504: LD_VAR 0 4
13508: PUSH
13509: LD_INT 5
13511: EQUAL
13512: IFFALSE 13621
// begin tmp := UnitsInside ( factory ) ;
13514: LD_ADDR_VAR 0 8
13518: PUSH
13519: LD_VAR 0 1
13523: PPUSH
13524: CALL_OW 313
13528: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13529: LD_VAR 0 8
13533: PPUSH
13534: LD_INT 25
13536: PUSH
13537: LD_INT 12
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: PPUSH
13544: CALL_OW 72
13548: NOT
13549: IFFALSE 13559
// control := control_manual ;
13551: LD_ADDR_VAR 0 4
13555: PUSH
13556: LD_INT 1
13558: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13559: LD_ADDR_VAR 0 8
13563: PUSH
13564: LD_VAR 0 1
13568: PPUSH
13569: CALL 13256 0 1
13573: ST_TO_ADDR
// if tmp then
13574: LD_VAR 0 8
13578: IFFALSE 13621
// begin for i in tmp do
13580: LD_ADDR_VAR 0 7
13584: PUSH
13585: LD_VAR 0 8
13589: PUSH
13590: FOR_IN
13591: IFFALSE 13619
// if i [ 1 ] = b_ext_radio then
13593: LD_VAR 0 7
13597: PUSH
13598: LD_INT 1
13600: ARRAY
13601: PUSH
13602: LD_INT 22
13604: EQUAL
13605: IFFALSE 13617
// begin control := control_remote ;
13607: LD_ADDR_VAR 0 4
13611: PUSH
13612: LD_INT 2
13614: ST_TO_ADDR
// break ;
13615: GO 13619
// end ;
13617: GO 13590
13619: POP
13620: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13621: LD_VAR 0 1
13625: PPUSH
13626: LD_VAR 0 2
13630: PPUSH
13631: LD_VAR 0 3
13635: PPUSH
13636: LD_VAR 0 4
13640: PPUSH
13641: LD_VAR 0 5
13645: PPUSH
13646: CALL_OW 448
13650: IFFALSE 13685
// begin result := [ chassis , engine , control , weapon ] ;
13652: LD_ADDR_VAR 0 6
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: LD_VAR 0 3
13666: PUSH
13667: LD_VAR 0 4
13671: PUSH
13672: LD_VAR 0 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: ST_TO_ADDR
// exit ;
13683: GO 14097
// end ; _chassis := AvailableChassisList ( factory ) ;
13685: LD_ADDR_VAR 0 9
13689: PUSH
13690: LD_VAR 0 1
13694: PPUSH
13695: CALL_OW 475
13699: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13700: LD_ADDR_VAR 0 11
13704: PUSH
13705: LD_VAR 0 1
13709: PPUSH
13710: CALL_OW 476
13714: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13715: LD_ADDR_VAR 0 12
13719: PUSH
13720: LD_VAR 0 1
13724: PPUSH
13725: CALL_OW 477
13729: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13730: LD_ADDR_VAR 0 10
13734: PUSH
13735: LD_VAR 0 1
13739: PPUSH
13740: CALL_OW 478
13744: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13745: LD_VAR 0 9
13749: NOT
13750: PUSH
13751: LD_VAR 0 11
13755: NOT
13756: OR
13757: PUSH
13758: LD_VAR 0 12
13762: NOT
13763: OR
13764: PUSH
13765: LD_VAR 0 10
13769: NOT
13770: OR
13771: IFFALSE 13806
// begin result := [ chassis , engine , control , weapon ] ;
13773: LD_ADDR_VAR 0 6
13777: PUSH
13778: LD_VAR 0 2
13782: PUSH
13783: LD_VAR 0 3
13787: PUSH
13788: LD_VAR 0 4
13792: PUSH
13793: LD_VAR 0 5
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: ST_TO_ADDR
// exit ;
13804: GO 14097
// end ; if not chassis in _chassis then
13806: LD_VAR 0 2
13810: PUSH
13811: LD_VAR 0 9
13815: IN
13816: NOT
13817: IFFALSE 13843
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13819: LD_ADDR_VAR 0 2
13823: PUSH
13824: LD_VAR 0 9
13828: PUSH
13829: LD_INT 1
13831: PPUSH
13832: LD_VAR 0 9
13836: PPUSH
13837: CALL_OW 12
13841: ARRAY
13842: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13843: LD_VAR 0 2
13847: PPUSH
13848: LD_VAR 0 3
13852: PPUSH
13853: CALL 14102 0 2
13857: NOT
13858: IFFALSE 13917
// repeat engine := _engine [ 1 ] ;
13860: LD_ADDR_VAR 0 3
13864: PUSH
13865: LD_VAR 0 11
13869: PUSH
13870: LD_INT 1
13872: ARRAY
13873: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13874: LD_ADDR_VAR 0 11
13878: PUSH
13879: LD_VAR 0 11
13883: PPUSH
13884: LD_INT 1
13886: PPUSH
13887: CALL_OW 3
13891: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13892: LD_VAR 0 2
13896: PPUSH
13897: LD_VAR 0 3
13901: PPUSH
13902: CALL 14102 0 2
13906: PUSH
13907: LD_VAR 0 11
13911: PUSH
13912: EMPTY
13913: EQUAL
13914: OR
13915: IFFALSE 13860
// if not control in _control then
13917: LD_VAR 0 4
13921: PUSH
13922: LD_VAR 0 12
13926: IN
13927: NOT
13928: IFFALSE 13954
// control := _control [ rand ( 1 , _control ) ] ;
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_VAR 0 12
13939: PUSH
13940: LD_INT 1
13942: PPUSH
13943: LD_VAR 0 12
13947: PPUSH
13948: CALL_OW 12
13952: ARRAY
13953: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
13954: LD_VAR 0 2
13958: PPUSH
13959: LD_VAR 0 5
13963: PPUSH
13964: CALL 14322 0 2
13968: NOT
13969: IFFALSE 14028
// repeat weapon := _weapon [ 1 ] ;
13971: LD_ADDR_VAR 0 5
13975: PUSH
13976: LD_VAR 0 10
13980: PUSH
13981: LD_INT 1
13983: ARRAY
13984: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
13985: LD_ADDR_VAR 0 10
13989: PUSH
13990: LD_VAR 0 10
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: CALL_OW 3
14002: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14003: LD_VAR 0 2
14007: PPUSH
14008: LD_VAR 0 5
14012: PPUSH
14013: CALL 14322 0 2
14017: PUSH
14018: LD_VAR 0 10
14022: PUSH
14023: EMPTY
14024: EQUAL
14025: OR
14026: IFFALSE 13971
// result := [ ] ;
14028: LD_ADDR_VAR 0 6
14032: PUSH
14033: EMPTY
14034: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14035: LD_VAR 0 1
14039: PPUSH
14040: LD_VAR 0 2
14044: PPUSH
14045: LD_VAR 0 3
14049: PPUSH
14050: LD_VAR 0 4
14054: PPUSH
14055: LD_VAR 0 5
14059: PPUSH
14060: CALL_OW 448
14064: IFFALSE 14097
// result := [ chassis , engine , control , weapon ] ;
14066: LD_ADDR_VAR 0 6
14070: PUSH
14071: LD_VAR 0 2
14075: PUSH
14076: LD_VAR 0 3
14080: PUSH
14081: LD_VAR 0 4
14085: PUSH
14086: LD_VAR 0 5
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: ST_TO_ADDR
// end ;
14097: LD_VAR 0 6
14101: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14102: LD_INT 0
14104: PPUSH
// if not chassis or not engine then
14105: LD_VAR 0 1
14109: NOT
14110: PUSH
14111: LD_VAR 0 2
14115: NOT
14116: OR
14117: IFFALSE 14121
// exit ;
14119: GO 14317
// case engine of engine_solar :
14121: LD_VAR 0 2
14125: PUSH
14126: LD_INT 2
14128: DOUBLE
14129: EQUAL
14130: IFTRUE 14134
14132: GO 14172
14134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14135: LD_ADDR_VAR 0 3
14139: PUSH
14140: LD_INT 11
14142: PUSH
14143: LD_INT 12
14145: PUSH
14146: LD_INT 13
14148: PUSH
14149: LD_INT 14
14151: PUSH
14152: LD_INT 1
14154: PUSH
14155: LD_INT 2
14157: PUSH
14158: LD_INT 3
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: ST_TO_ADDR
14170: GO 14301
14172: LD_INT 1
14174: DOUBLE
14175: EQUAL
14176: IFTRUE 14180
14178: GO 14242
14180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14181: LD_ADDR_VAR 0 3
14185: PUSH
14186: LD_INT 11
14188: PUSH
14189: LD_INT 12
14191: PUSH
14192: LD_INT 13
14194: PUSH
14195: LD_INT 14
14197: PUSH
14198: LD_INT 1
14200: PUSH
14201: LD_INT 2
14203: PUSH
14204: LD_INT 3
14206: PUSH
14207: LD_INT 4
14209: PUSH
14210: LD_INT 5
14212: PUSH
14213: LD_INT 21
14215: PUSH
14216: LD_INT 23
14218: PUSH
14219: LD_INT 22
14221: PUSH
14222: LD_INT 24
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: ST_TO_ADDR
14240: GO 14301
14242: LD_INT 3
14244: DOUBLE
14245: EQUAL
14246: IFTRUE 14250
14248: GO 14300
14250: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14251: LD_ADDR_VAR 0 3
14255: PUSH
14256: LD_INT 13
14258: PUSH
14259: LD_INT 14
14261: PUSH
14262: LD_INT 2
14264: PUSH
14265: LD_INT 3
14267: PUSH
14268: LD_INT 4
14270: PUSH
14271: LD_INT 5
14273: PUSH
14274: LD_INT 21
14276: PUSH
14277: LD_INT 22
14279: PUSH
14280: LD_INT 23
14282: PUSH
14283: LD_INT 24
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: ST_TO_ADDR
14298: GO 14301
14300: POP
// result := ( chassis in result ) ;
14301: LD_ADDR_VAR 0 3
14305: PUSH
14306: LD_VAR 0 1
14310: PUSH
14311: LD_VAR 0 3
14315: IN
14316: ST_TO_ADDR
// end ;
14317: LD_VAR 0 3
14321: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14322: LD_INT 0
14324: PPUSH
// if not chassis or not weapon then
14325: LD_VAR 0 1
14329: NOT
14330: PUSH
14331: LD_VAR 0 2
14335: NOT
14336: OR
14337: IFFALSE 14341
// exit ;
14339: GO 15403
// case weapon of us_machine_gun :
14341: LD_VAR 0 2
14345: PUSH
14346: LD_INT 2
14348: DOUBLE
14349: EQUAL
14350: IFTRUE 14354
14352: GO 14384
14354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14355: LD_ADDR_VAR 0 3
14359: PUSH
14360: LD_INT 1
14362: PUSH
14363: LD_INT 2
14365: PUSH
14366: LD_INT 3
14368: PUSH
14369: LD_INT 4
14371: PUSH
14372: LD_INT 5
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: ST_TO_ADDR
14382: GO 15387
14384: LD_INT 3
14386: DOUBLE
14387: EQUAL
14388: IFTRUE 14392
14390: GO 14422
14392: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 1
14400: PUSH
14401: LD_INT 2
14403: PUSH
14404: LD_INT 3
14406: PUSH
14407: LD_INT 4
14409: PUSH
14410: LD_INT 5
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: ST_TO_ADDR
14420: GO 15387
14422: LD_INT 11
14424: DOUBLE
14425: EQUAL
14426: IFTRUE 14430
14428: GO 14460
14430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14431: LD_ADDR_VAR 0 3
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: LD_INT 2
14441: PUSH
14442: LD_INT 3
14444: PUSH
14445: LD_INT 4
14447: PUSH
14448: LD_INT 5
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: ST_TO_ADDR
14458: GO 15387
14460: LD_INT 4
14462: DOUBLE
14463: EQUAL
14464: IFTRUE 14468
14466: GO 14494
14468: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14469: LD_ADDR_VAR 0 3
14473: PUSH
14474: LD_INT 2
14476: PUSH
14477: LD_INT 3
14479: PUSH
14480: LD_INT 4
14482: PUSH
14483: LD_INT 5
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: ST_TO_ADDR
14492: GO 15387
14494: LD_INT 5
14496: DOUBLE
14497: EQUAL
14498: IFTRUE 14502
14500: GO 14528
14502: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14503: LD_ADDR_VAR 0 3
14507: PUSH
14508: LD_INT 2
14510: PUSH
14511: LD_INT 3
14513: PUSH
14514: LD_INT 4
14516: PUSH
14517: LD_INT 5
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: ST_TO_ADDR
14526: GO 15387
14528: LD_INT 9
14530: DOUBLE
14531: EQUAL
14532: IFTRUE 14536
14534: GO 14562
14536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 2
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: LD_INT 4
14550: PUSH
14551: LD_INT 5
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: ST_TO_ADDR
14560: GO 15387
14562: LD_INT 7
14564: DOUBLE
14565: EQUAL
14566: IFTRUE 14570
14568: GO 14596
14570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14571: LD_ADDR_VAR 0 3
14575: PUSH
14576: LD_INT 2
14578: PUSH
14579: LD_INT 3
14581: PUSH
14582: LD_INT 4
14584: PUSH
14585: LD_INT 5
14587: PUSH
14588: EMPTY
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: ST_TO_ADDR
14594: GO 15387
14596: LD_INT 12
14598: DOUBLE
14599: EQUAL
14600: IFTRUE 14604
14602: GO 14630
14604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14605: LD_ADDR_VAR 0 3
14609: PUSH
14610: LD_INT 2
14612: PUSH
14613: LD_INT 3
14615: PUSH
14616: LD_INT 4
14618: PUSH
14619: LD_INT 5
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: ST_TO_ADDR
14628: GO 15387
14630: LD_INT 13
14632: DOUBLE
14633: EQUAL
14634: IFTRUE 14638
14636: GO 14664
14638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14639: LD_ADDR_VAR 0 3
14643: PUSH
14644: LD_INT 2
14646: PUSH
14647: LD_INT 3
14649: PUSH
14650: LD_INT 4
14652: PUSH
14653: LD_INT 5
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: ST_TO_ADDR
14662: GO 15387
14664: LD_INT 14
14666: DOUBLE
14667: EQUAL
14668: IFTRUE 14672
14670: GO 14690
14672: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 4
14680: PUSH
14681: LD_INT 5
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: ST_TO_ADDR
14688: GO 15387
14690: LD_INT 6
14692: DOUBLE
14693: EQUAL
14694: IFTRUE 14698
14696: GO 14716
14698: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14699: LD_ADDR_VAR 0 3
14703: PUSH
14704: LD_INT 4
14706: PUSH
14707: LD_INT 5
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: ST_TO_ADDR
14714: GO 15387
14716: LD_INT 10
14718: DOUBLE
14719: EQUAL
14720: IFTRUE 14724
14722: GO 14742
14724: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14725: LD_ADDR_VAR 0 3
14729: PUSH
14730: LD_INT 4
14732: PUSH
14733: LD_INT 5
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: ST_TO_ADDR
14740: GO 15387
14742: LD_INT 22
14744: DOUBLE
14745: EQUAL
14746: IFTRUE 14750
14748: GO 14776
14750: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14751: LD_ADDR_VAR 0 3
14755: PUSH
14756: LD_INT 11
14758: PUSH
14759: LD_INT 12
14761: PUSH
14762: LD_INT 13
14764: PUSH
14765: LD_INT 14
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: ST_TO_ADDR
14774: GO 15387
14776: LD_INT 23
14778: DOUBLE
14779: EQUAL
14780: IFTRUE 14784
14782: GO 14810
14784: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14785: LD_ADDR_VAR 0 3
14789: PUSH
14790: LD_INT 11
14792: PUSH
14793: LD_INT 12
14795: PUSH
14796: LD_INT 13
14798: PUSH
14799: LD_INT 14
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: ST_TO_ADDR
14808: GO 15387
14810: LD_INT 24
14812: DOUBLE
14813: EQUAL
14814: IFTRUE 14818
14816: GO 14844
14818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14819: LD_ADDR_VAR 0 3
14823: PUSH
14824: LD_INT 11
14826: PUSH
14827: LD_INT 12
14829: PUSH
14830: LD_INT 13
14832: PUSH
14833: LD_INT 14
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: ST_TO_ADDR
14842: GO 15387
14844: LD_INT 30
14846: DOUBLE
14847: EQUAL
14848: IFTRUE 14852
14850: GO 14878
14852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14853: LD_ADDR_VAR 0 3
14857: PUSH
14858: LD_INT 11
14860: PUSH
14861: LD_INT 12
14863: PUSH
14864: LD_INT 13
14866: PUSH
14867: LD_INT 14
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: ST_TO_ADDR
14876: GO 15387
14878: LD_INT 25
14880: DOUBLE
14881: EQUAL
14882: IFTRUE 14886
14884: GO 14904
14886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14887: LD_ADDR_VAR 0 3
14891: PUSH
14892: LD_INT 13
14894: PUSH
14895: LD_INT 14
14897: PUSH
14898: EMPTY
14899: LIST
14900: LIST
14901: ST_TO_ADDR
14902: GO 15387
14904: LD_INT 27
14906: DOUBLE
14907: EQUAL
14908: IFTRUE 14912
14910: GO 14930
14912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
14913: LD_ADDR_VAR 0 3
14917: PUSH
14918: LD_INT 13
14920: PUSH
14921: LD_INT 14
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: ST_TO_ADDR
14928: GO 15387
14930: LD_EXP 72
14934: DOUBLE
14935: EQUAL
14936: IFTRUE 14940
14938: GO 14966
14940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_INT 11
14948: PUSH
14949: LD_INT 12
14951: PUSH
14952: LD_INT 13
14954: PUSH
14955: LD_INT 14
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: ST_TO_ADDR
14964: GO 15387
14966: LD_INT 28
14968: DOUBLE
14969: EQUAL
14970: IFTRUE 14974
14972: GO 14992
14974: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
14975: LD_ADDR_VAR 0 3
14979: PUSH
14980: LD_INT 13
14982: PUSH
14983: LD_INT 14
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: ST_TO_ADDR
14990: GO 15387
14992: LD_INT 29
14994: DOUBLE
14995: EQUAL
14996: IFTRUE 15000
14998: GO 15018
15000: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15001: LD_ADDR_VAR 0 3
15005: PUSH
15006: LD_INT 13
15008: PUSH
15009: LD_INT 14
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: ST_TO_ADDR
15016: GO 15387
15018: LD_INT 31
15020: DOUBLE
15021: EQUAL
15022: IFTRUE 15026
15024: GO 15044
15026: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15027: LD_ADDR_VAR 0 3
15031: PUSH
15032: LD_INT 13
15034: PUSH
15035: LD_INT 14
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: ST_TO_ADDR
15042: GO 15387
15044: LD_INT 26
15046: DOUBLE
15047: EQUAL
15048: IFTRUE 15052
15050: GO 15070
15052: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15053: LD_ADDR_VAR 0 3
15057: PUSH
15058: LD_INT 13
15060: PUSH
15061: LD_INT 14
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: ST_TO_ADDR
15068: GO 15387
15070: LD_INT 42
15072: DOUBLE
15073: EQUAL
15074: IFTRUE 15078
15076: GO 15104
15078: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15079: LD_ADDR_VAR 0 3
15083: PUSH
15084: LD_INT 21
15086: PUSH
15087: LD_INT 22
15089: PUSH
15090: LD_INT 23
15092: PUSH
15093: LD_INT 24
15095: PUSH
15096: EMPTY
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: ST_TO_ADDR
15102: GO 15387
15104: LD_INT 43
15106: DOUBLE
15107: EQUAL
15108: IFTRUE 15112
15110: GO 15138
15112: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15113: LD_ADDR_VAR 0 3
15117: PUSH
15118: LD_INT 21
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 23
15126: PUSH
15127: LD_INT 24
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: ST_TO_ADDR
15136: GO 15387
15138: LD_INT 44
15140: DOUBLE
15141: EQUAL
15142: IFTRUE 15146
15144: GO 15172
15146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15147: LD_ADDR_VAR 0 3
15151: PUSH
15152: LD_INT 21
15154: PUSH
15155: LD_INT 22
15157: PUSH
15158: LD_INT 23
15160: PUSH
15161: LD_INT 24
15163: PUSH
15164: EMPTY
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: ST_TO_ADDR
15170: GO 15387
15172: LD_INT 45
15174: DOUBLE
15175: EQUAL
15176: IFTRUE 15180
15178: GO 15206
15180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15181: LD_ADDR_VAR 0 3
15185: PUSH
15186: LD_INT 21
15188: PUSH
15189: LD_INT 22
15191: PUSH
15192: LD_INT 23
15194: PUSH
15195: LD_INT 24
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: ST_TO_ADDR
15204: GO 15387
15206: LD_INT 49
15208: DOUBLE
15209: EQUAL
15210: IFTRUE 15214
15212: GO 15240
15214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15215: LD_ADDR_VAR 0 3
15219: PUSH
15220: LD_INT 21
15222: PUSH
15223: LD_INT 22
15225: PUSH
15226: LD_INT 23
15228: PUSH
15229: LD_INT 24
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: ST_TO_ADDR
15238: GO 15387
15240: LD_INT 51
15242: DOUBLE
15243: EQUAL
15244: IFTRUE 15248
15246: GO 15274
15248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15249: LD_ADDR_VAR 0 3
15253: PUSH
15254: LD_INT 21
15256: PUSH
15257: LD_INT 22
15259: PUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 24
15265: PUSH
15266: EMPTY
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: ST_TO_ADDR
15272: GO 15387
15274: LD_INT 52
15276: DOUBLE
15277: EQUAL
15278: IFTRUE 15282
15280: GO 15308
15282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15283: LD_ADDR_VAR 0 3
15287: PUSH
15288: LD_INT 21
15290: PUSH
15291: LD_INT 22
15293: PUSH
15294: LD_INT 23
15296: PUSH
15297: LD_INT 24
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: ST_TO_ADDR
15306: GO 15387
15308: LD_INT 53
15310: DOUBLE
15311: EQUAL
15312: IFTRUE 15316
15314: GO 15334
15316: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15317: LD_ADDR_VAR 0 3
15321: PUSH
15322: LD_INT 23
15324: PUSH
15325: LD_INT 24
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: ST_TO_ADDR
15332: GO 15387
15334: LD_INT 46
15336: DOUBLE
15337: EQUAL
15338: IFTRUE 15342
15340: GO 15360
15342: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15343: LD_ADDR_VAR 0 3
15347: PUSH
15348: LD_INT 23
15350: PUSH
15351: LD_INT 24
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: ST_TO_ADDR
15358: GO 15387
15360: LD_INT 47
15362: DOUBLE
15363: EQUAL
15364: IFTRUE 15368
15366: GO 15386
15368: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15369: LD_ADDR_VAR 0 3
15373: PUSH
15374: LD_INT 23
15376: PUSH
15377: LD_INT 24
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: ST_TO_ADDR
15384: GO 15387
15386: POP
// result := ( chassis in result ) ;
15387: LD_ADDR_VAR 0 3
15391: PUSH
15392: LD_VAR 0 1
15396: PUSH
15397: LD_VAR 0 3
15401: IN
15402: ST_TO_ADDR
// end ;
15403: LD_VAR 0 3
15407: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15408: LD_INT 0
15410: PPUSH
15411: PPUSH
15412: PPUSH
15413: PPUSH
15414: PPUSH
15415: PPUSH
15416: PPUSH
// result := array ;
15417: LD_ADDR_VAR 0 5
15421: PUSH
15422: LD_VAR 0 1
15426: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15427: LD_VAR 0 1
15431: NOT
15432: PUSH
15433: LD_VAR 0 2
15437: NOT
15438: OR
15439: PUSH
15440: LD_VAR 0 3
15444: NOT
15445: OR
15446: PUSH
15447: LD_VAR 0 2
15451: PUSH
15452: LD_VAR 0 1
15456: GREATER
15457: OR
15458: PUSH
15459: LD_VAR 0 3
15463: PUSH
15464: LD_VAR 0 1
15468: GREATER
15469: OR
15470: IFFALSE 15474
// exit ;
15472: GO 15770
// if direction then
15474: LD_VAR 0 4
15478: IFFALSE 15542
// begin d := 1 ;
15480: LD_ADDR_VAR 0 9
15484: PUSH
15485: LD_INT 1
15487: ST_TO_ADDR
// if i_from > i_to then
15488: LD_VAR 0 2
15492: PUSH
15493: LD_VAR 0 3
15497: GREATER
15498: IFFALSE 15524
// length := ( array - i_from ) + i_to else
15500: LD_ADDR_VAR 0 11
15504: PUSH
15505: LD_VAR 0 1
15509: PUSH
15510: LD_VAR 0 2
15514: MINUS
15515: PUSH
15516: LD_VAR 0 3
15520: PLUS
15521: ST_TO_ADDR
15522: GO 15540
// length := i_to - i_from ;
15524: LD_ADDR_VAR 0 11
15528: PUSH
15529: LD_VAR 0 3
15533: PUSH
15534: LD_VAR 0 2
15538: MINUS
15539: ST_TO_ADDR
// end else
15540: GO 15603
// begin d := - 1 ;
15542: LD_ADDR_VAR 0 9
15546: PUSH
15547: LD_INT 1
15549: NEG
15550: ST_TO_ADDR
// if i_from > i_to then
15551: LD_VAR 0 2
15555: PUSH
15556: LD_VAR 0 3
15560: GREATER
15561: IFFALSE 15581
// length := i_from - i_to else
15563: LD_ADDR_VAR 0 11
15567: PUSH
15568: LD_VAR 0 2
15572: PUSH
15573: LD_VAR 0 3
15577: MINUS
15578: ST_TO_ADDR
15579: GO 15603
// length := ( array - i_to ) + i_from ;
15581: LD_ADDR_VAR 0 11
15585: PUSH
15586: LD_VAR 0 1
15590: PUSH
15591: LD_VAR 0 3
15595: MINUS
15596: PUSH
15597: LD_VAR 0 2
15601: PLUS
15602: ST_TO_ADDR
// end ; if not length then
15603: LD_VAR 0 11
15607: NOT
15608: IFFALSE 15612
// exit ;
15610: GO 15770
// tmp := array ;
15612: LD_ADDR_VAR 0 10
15616: PUSH
15617: LD_VAR 0 1
15621: ST_TO_ADDR
// for i = 1 to length do
15622: LD_ADDR_VAR 0 6
15626: PUSH
15627: DOUBLE
15628: LD_INT 1
15630: DEC
15631: ST_TO_ADDR
15632: LD_VAR 0 11
15636: PUSH
15637: FOR_TO
15638: IFFALSE 15758
// begin for j = 1 to array do
15640: LD_ADDR_VAR 0 7
15644: PUSH
15645: DOUBLE
15646: LD_INT 1
15648: DEC
15649: ST_TO_ADDR
15650: LD_VAR 0 1
15654: PUSH
15655: FOR_TO
15656: IFFALSE 15744
// begin k := j + d ;
15658: LD_ADDR_VAR 0 8
15662: PUSH
15663: LD_VAR 0 7
15667: PUSH
15668: LD_VAR 0 9
15672: PLUS
15673: ST_TO_ADDR
// if k > array then
15674: LD_VAR 0 8
15678: PUSH
15679: LD_VAR 0 1
15683: GREATER
15684: IFFALSE 15694
// k := 1 ;
15686: LD_ADDR_VAR 0 8
15690: PUSH
15691: LD_INT 1
15693: ST_TO_ADDR
// if not k then
15694: LD_VAR 0 8
15698: NOT
15699: IFFALSE 15711
// k := array ;
15701: LD_ADDR_VAR 0 8
15705: PUSH
15706: LD_VAR 0 1
15710: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15711: LD_ADDR_VAR 0 10
15715: PUSH
15716: LD_VAR 0 10
15720: PPUSH
15721: LD_VAR 0 8
15725: PPUSH
15726: LD_VAR 0 1
15730: PUSH
15731: LD_VAR 0 7
15735: ARRAY
15736: PPUSH
15737: CALL_OW 1
15741: ST_TO_ADDR
// end ;
15742: GO 15655
15744: POP
15745: POP
// array := tmp ;
15746: LD_ADDR_VAR 0 1
15750: PUSH
15751: LD_VAR 0 10
15755: ST_TO_ADDR
// end ;
15756: GO 15637
15758: POP
15759: POP
// result := array ;
15760: LD_ADDR_VAR 0 5
15764: PUSH
15765: LD_VAR 0 1
15769: ST_TO_ADDR
// end ;
15770: LD_VAR 0 5
15774: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15775: LD_INT 0
15777: PPUSH
15778: PPUSH
// result := 0 ;
15779: LD_ADDR_VAR 0 3
15783: PUSH
15784: LD_INT 0
15786: ST_TO_ADDR
// if not array or not value in array then
15787: LD_VAR 0 1
15791: NOT
15792: PUSH
15793: LD_VAR 0 2
15797: PUSH
15798: LD_VAR 0 1
15802: IN
15803: NOT
15804: OR
15805: IFFALSE 15809
// exit ;
15807: GO 15863
// for i = 1 to array do
15809: LD_ADDR_VAR 0 4
15813: PUSH
15814: DOUBLE
15815: LD_INT 1
15817: DEC
15818: ST_TO_ADDR
15819: LD_VAR 0 1
15823: PUSH
15824: FOR_TO
15825: IFFALSE 15861
// if value = array [ i ] then
15827: LD_VAR 0 2
15831: PUSH
15832: LD_VAR 0 1
15836: PUSH
15837: LD_VAR 0 4
15841: ARRAY
15842: EQUAL
15843: IFFALSE 15859
// begin result := i ;
15845: LD_ADDR_VAR 0 3
15849: PUSH
15850: LD_VAR 0 4
15854: ST_TO_ADDR
// exit ;
15855: POP
15856: POP
15857: GO 15863
// end ;
15859: GO 15824
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15868: LD_INT 0
15870: PPUSH
// vc_chassis := chassis ;
15871: LD_ADDR_OWVAR 37
15875: PUSH
15876: LD_VAR 0 1
15880: ST_TO_ADDR
// vc_engine := engine ;
15881: LD_ADDR_OWVAR 39
15885: PUSH
15886: LD_VAR 0 2
15890: ST_TO_ADDR
// vc_control := control ;
15891: LD_ADDR_OWVAR 38
15895: PUSH
15896: LD_VAR 0 3
15900: ST_TO_ADDR
// vc_weapon := weapon ;
15901: LD_ADDR_OWVAR 40
15905: PUSH
15906: LD_VAR 0 4
15910: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15911: LD_ADDR_OWVAR 41
15915: PUSH
15916: LD_VAR 0 5
15920: ST_TO_ADDR
// end ;
15921: LD_VAR 0 6
15925: RET
// export function WantPlant ( unit ) ; var task ; begin
15926: LD_INT 0
15928: PPUSH
15929: PPUSH
// result := false ;
15930: LD_ADDR_VAR 0 2
15934: PUSH
15935: LD_INT 0
15937: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
15938: LD_ADDR_VAR 0 3
15942: PUSH
15943: LD_VAR 0 1
15947: PPUSH
15948: CALL_OW 437
15952: ST_TO_ADDR
// if task then
15953: LD_VAR 0 3
15957: IFFALSE 15985
// if task [ 1 ] [ 1 ] = p then
15959: LD_VAR 0 3
15963: PUSH
15964: LD_INT 1
15966: ARRAY
15967: PUSH
15968: LD_INT 1
15970: ARRAY
15971: PUSH
15972: LD_STRING p
15974: EQUAL
15975: IFFALSE 15985
// result := true ;
15977: LD_ADDR_VAR 0 2
15981: PUSH
15982: LD_INT 1
15984: ST_TO_ADDR
// end ;
15985: LD_VAR 0 2
15989: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
15990: LD_INT 0
15992: PPUSH
15993: PPUSH
15994: PPUSH
15995: PPUSH
// if pos < 1 then
15996: LD_VAR 0 2
16000: PUSH
16001: LD_INT 1
16003: LESS
16004: IFFALSE 16008
// exit ;
16006: GO 16311
// if pos = 1 then
16008: LD_VAR 0 2
16012: PUSH
16013: LD_INT 1
16015: EQUAL
16016: IFFALSE 16049
// result := Replace ( arr , pos [ 1 ] , value ) else
16018: LD_ADDR_VAR 0 4
16022: PUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 2
16032: PUSH
16033: LD_INT 1
16035: ARRAY
16036: PPUSH
16037: LD_VAR 0 3
16041: PPUSH
16042: CALL_OW 1
16046: ST_TO_ADDR
16047: GO 16311
// begin tmp := arr ;
16049: LD_ADDR_VAR 0 6
16053: PUSH
16054: LD_VAR 0 1
16058: ST_TO_ADDR
// s_arr := [ tmp ] ;
16059: LD_ADDR_VAR 0 7
16063: PUSH
16064: LD_VAR 0 6
16068: PUSH
16069: EMPTY
16070: LIST
16071: ST_TO_ADDR
// for i = 1 to pos - 1 do
16072: LD_ADDR_VAR 0 5
16076: PUSH
16077: DOUBLE
16078: LD_INT 1
16080: DEC
16081: ST_TO_ADDR
16082: LD_VAR 0 2
16086: PUSH
16087: LD_INT 1
16089: MINUS
16090: PUSH
16091: FOR_TO
16092: IFFALSE 16137
// begin tmp := tmp [ pos [ i ] ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_VAR 0 6
16103: PUSH
16104: LD_VAR 0 2
16108: PUSH
16109: LD_VAR 0 5
16113: ARRAY
16114: ARRAY
16115: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16116: LD_ADDR_VAR 0 7
16120: PUSH
16121: LD_VAR 0 7
16125: PUSH
16126: LD_VAR 0 6
16130: PUSH
16131: EMPTY
16132: LIST
16133: ADD
16134: ST_TO_ADDR
// end ;
16135: GO 16091
16137: POP
16138: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16139: LD_ADDR_VAR 0 6
16143: PUSH
16144: LD_VAR 0 6
16148: PPUSH
16149: LD_VAR 0 2
16153: PUSH
16154: LD_VAR 0 2
16158: ARRAY
16159: PPUSH
16160: LD_VAR 0 3
16164: PPUSH
16165: CALL_OW 1
16169: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16170: LD_ADDR_VAR 0 7
16174: PUSH
16175: LD_VAR 0 7
16179: PPUSH
16180: LD_VAR 0 7
16184: PPUSH
16185: LD_VAR 0 6
16189: PPUSH
16190: CALL_OW 1
16194: ST_TO_ADDR
// for i = s_arr downto 2 do
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: DOUBLE
16201: LD_VAR 0 7
16205: INC
16206: ST_TO_ADDR
16207: LD_INT 2
16209: PUSH
16210: FOR_DOWNTO
16211: IFFALSE 16295
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16213: LD_ADDR_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: PUSH
16223: LD_VAR 0 5
16227: PUSH
16228: LD_INT 1
16230: MINUS
16231: ARRAY
16232: PPUSH
16233: LD_VAR 0 2
16237: PUSH
16238: LD_VAR 0 5
16242: PUSH
16243: LD_INT 1
16245: MINUS
16246: ARRAY
16247: PPUSH
16248: LD_VAR 0 7
16252: PUSH
16253: LD_VAR 0 5
16257: ARRAY
16258: PPUSH
16259: CALL_OW 1
16263: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16264: LD_ADDR_VAR 0 7
16268: PUSH
16269: LD_VAR 0 7
16273: PPUSH
16274: LD_VAR 0 5
16278: PUSH
16279: LD_INT 1
16281: MINUS
16282: PPUSH
16283: LD_VAR 0 6
16287: PPUSH
16288: CALL_OW 1
16292: ST_TO_ADDR
// end ;
16293: GO 16210
16295: POP
16296: POP
// result := s_arr [ 1 ] ;
16297: LD_ADDR_VAR 0 4
16301: PUSH
16302: LD_VAR 0 7
16306: PUSH
16307: LD_INT 1
16309: ARRAY
16310: ST_TO_ADDR
// end ; end ;
16311: LD_VAR 0 4
16315: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16316: LD_INT 0
16318: PPUSH
16319: PPUSH
// if not list then
16320: LD_VAR 0 1
16324: NOT
16325: IFFALSE 16329
// exit ;
16327: GO 16420
// i := list [ pos1 ] ;
16329: LD_ADDR_VAR 0 5
16333: PUSH
16334: LD_VAR 0 1
16338: PUSH
16339: LD_VAR 0 2
16343: ARRAY
16344: ST_TO_ADDR
// if not i then
16345: LD_VAR 0 5
16349: NOT
16350: IFFALSE 16354
// exit ;
16352: GO 16420
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16354: LD_ADDR_VAR 0 1
16358: PUSH
16359: LD_VAR 0 1
16363: PPUSH
16364: LD_VAR 0 2
16368: PPUSH
16369: LD_VAR 0 1
16373: PUSH
16374: LD_VAR 0 3
16378: ARRAY
16379: PPUSH
16380: CALL_OW 1
16384: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16385: LD_ADDR_VAR 0 1
16389: PUSH
16390: LD_VAR 0 1
16394: PPUSH
16395: LD_VAR 0 3
16399: PPUSH
16400: LD_VAR 0 5
16404: PPUSH
16405: CALL_OW 1
16409: ST_TO_ADDR
// result := list ;
16410: LD_ADDR_VAR 0 4
16414: PUSH
16415: LD_VAR 0 1
16419: ST_TO_ADDR
// end ;
16420: LD_VAR 0 4
16424: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16425: LD_INT 0
16427: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16428: LD_ADDR_VAR 0 5
16432: PUSH
16433: LD_VAR 0 1
16437: PPUSH
16438: CALL_OW 250
16442: PPUSH
16443: LD_VAR 0 1
16447: PPUSH
16448: CALL_OW 251
16452: PPUSH
16453: LD_VAR 0 2
16457: PPUSH
16458: LD_VAR 0 3
16462: PPUSH
16463: LD_VAR 0 4
16467: PPUSH
16468: CALL 16478 0 5
16472: ST_TO_ADDR
// end ;
16473: LD_VAR 0 5
16477: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16478: LD_INT 0
16480: PPUSH
16481: PPUSH
16482: PPUSH
16483: PPUSH
// if not list then
16484: LD_VAR 0 3
16488: NOT
16489: IFFALSE 16493
// exit ;
16491: GO 16881
// result := [ ] ;
16493: LD_ADDR_VAR 0 6
16497: PUSH
16498: EMPTY
16499: ST_TO_ADDR
// for i in list do
16500: LD_ADDR_VAR 0 7
16504: PUSH
16505: LD_VAR 0 3
16509: PUSH
16510: FOR_IN
16511: IFFALSE 16713
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16513: LD_ADDR_VAR 0 9
16517: PUSH
16518: LD_VAR 0 7
16522: PPUSH
16523: LD_VAR 0 1
16527: PPUSH
16528: LD_VAR 0 2
16532: PPUSH
16533: CALL_OW 297
16537: ST_TO_ADDR
// if not result then
16538: LD_VAR 0 6
16542: NOT
16543: IFFALSE 16569
// result := [ [ i , tmp ] ] else
16545: LD_ADDR_VAR 0 6
16549: PUSH
16550: LD_VAR 0 7
16554: PUSH
16555: LD_VAR 0 9
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: PUSH
16564: EMPTY
16565: LIST
16566: ST_TO_ADDR
16567: GO 16711
// begin if result [ result ] [ 2 ] < tmp then
16569: LD_VAR 0 6
16573: PUSH
16574: LD_VAR 0 6
16578: ARRAY
16579: PUSH
16580: LD_INT 2
16582: ARRAY
16583: PUSH
16584: LD_VAR 0 9
16588: LESS
16589: IFFALSE 16631
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16591: LD_ADDR_VAR 0 6
16595: PUSH
16596: LD_VAR 0 6
16600: PPUSH
16601: LD_VAR 0 6
16605: PUSH
16606: LD_INT 1
16608: PLUS
16609: PPUSH
16610: LD_VAR 0 7
16614: PUSH
16615: LD_VAR 0 9
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 2
16628: ST_TO_ADDR
16629: GO 16711
// for j = 1 to result do
16631: LD_ADDR_VAR 0 8
16635: PUSH
16636: DOUBLE
16637: LD_INT 1
16639: DEC
16640: ST_TO_ADDR
16641: LD_VAR 0 6
16645: PUSH
16646: FOR_TO
16647: IFFALSE 16709
// begin if tmp < result [ j ] [ 2 ] then
16649: LD_VAR 0 9
16653: PUSH
16654: LD_VAR 0 6
16658: PUSH
16659: LD_VAR 0 8
16663: ARRAY
16664: PUSH
16665: LD_INT 2
16667: ARRAY
16668: LESS
16669: IFFALSE 16707
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16671: LD_ADDR_VAR 0 6
16675: PUSH
16676: LD_VAR 0 6
16680: PPUSH
16681: LD_VAR 0 8
16685: PPUSH
16686: LD_VAR 0 7
16690: PUSH
16691: LD_VAR 0 9
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PPUSH
16700: CALL_OW 2
16704: ST_TO_ADDR
// break ;
16705: GO 16709
// end ; end ;
16707: GO 16646
16709: POP
16710: POP
// end ; end ;
16711: GO 16510
16713: POP
16714: POP
// if result and not asc then
16715: LD_VAR 0 6
16719: PUSH
16720: LD_VAR 0 4
16724: NOT
16725: AND
16726: IFFALSE 16801
// begin tmp := result ;
16728: LD_ADDR_VAR 0 9
16732: PUSH
16733: LD_VAR 0 6
16737: ST_TO_ADDR
// for i = tmp downto 1 do
16738: LD_ADDR_VAR 0 7
16742: PUSH
16743: DOUBLE
16744: LD_VAR 0 9
16748: INC
16749: ST_TO_ADDR
16750: LD_INT 1
16752: PUSH
16753: FOR_DOWNTO
16754: IFFALSE 16799
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16756: LD_ADDR_VAR 0 6
16760: PUSH
16761: LD_VAR 0 6
16765: PPUSH
16766: LD_VAR 0 9
16770: PUSH
16771: LD_VAR 0 7
16775: MINUS
16776: PUSH
16777: LD_INT 1
16779: PLUS
16780: PPUSH
16781: LD_VAR 0 9
16785: PUSH
16786: LD_VAR 0 7
16790: ARRAY
16791: PPUSH
16792: CALL_OW 1
16796: ST_TO_ADDR
16797: GO 16753
16799: POP
16800: POP
// end ; tmp := [ ] ;
16801: LD_ADDR_VAR 0 9
16805: PUSH
16806: EMPTY
16807: ST_TO_ADDR
// if mode then
16808: LD_VAR 0 5
16812: IFFALSE 16881
// begin for i = 1 to result do
16814: LD_ADDR_VAR 0 7
16818: PUSH
16819: DOUBLE
16820: LD_INT 1
16822: DEC
16823: ST_TO_ADDR
16824: LD_VAR 0 6
16828: PUSH
16829: FOR_TO
16830: IFFALSE 16869
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16832: LD_ADDR_VAR 0 9
16836: PUSH
16837: LD_VAR 0 9
16841: PPUSH
16842: LD_VAR 0 7
16846: PPUSH
16847: LD_VAR 0 6
16851: PUSH
16852: LD_VAR 0 7
16856: ARRAY
16857: PUSH
16858: LD_INT 1
16860: ARRAY
16861: PPUSH
16862: CALL_OW 1
16866: ST_TO_ADDR
16867: GO 16829
16869: POP
16870: POP
// result := tmp ;
16871: LD_ADDR_VAR 0 6
16875: PUSH
16876: LD_VAR 0 9
16880: ST_TO_ADDR
// end ; end ;
16881: LD_VAR 0 6
16885: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
16886: LD_INT 0
16888: PPUSH
16889: PPUSH
16890: PPUSH
16891: PPUSH
16892: PPUSH
16893: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
16894: LD_ADDR_VAR 0 5
16898: PUSH
16899: LD_INT 0
16901: PUSH
16902: LD_INT 0
16904: PUSH
16905: LD_INT 0
16907: PUSH
16908: EMPTY
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: ST_TO_ADDR
// if not x or not y then
16916: LD_VAR 0 2
16920: NOT
16921: PUSH
16922: LD_VAR 0 3
16926: NOT
16927: OR
16928: IFFALSE 16932
// exit ;
16930: GO 18584
// if not range then
16932: LD_VAR 0 4
16936: NOT
16937: IFFALSE 16947
// range := 10 ;
16939: LD_ADDR_VAR 0 4
16943: PUSH
16944: LD_INT 10
16946: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16947: LD_ADDR_VAR 0 8
16951: PUSH
16952: LD_INT 81
16954: PUSH
16955: LD_VAR 0 1
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PUSH
16964: LD_INT 92
16966: PUSH
16967: LD_VAR 0 2
16971: PUSH
16972: LD_VAR 0 3
16976: PUSH
16977: LD_VAR 0 4
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 3
16990: PUSH
16991: LD_INT 21
16993: PUSH
16994: LD_INT 3
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: PPUSH
17010: CALL_OW 69
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 8
17019: NOT
17020: IFFALSE 17024
// exit ;
17022: GO 18584
// for i in tmp do
17024: LD_ADDR_VAR 0 6
17028: PUSH
17029: LD_VAR 0 8
17033: PUSH
17034: FOR_IN
17035: IFFALSE 18559
// begin points := [ 0 , 0 , 0 ] ;
17037: LD_ADDR_VAR 0 9
17041: PUSH
17042: LD_INT 0
17044: PUSH
17045: LD_INT 0
17047: PUSH
17048: LD_INT 0
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: LIST
17055: ST_TO_ADDR
// bpoints := 1 ;
17056: LD_ADDR_VAR 0 10
17060: PUSH
17061: LD_INT 1
17063: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17064: LD_VAR 0 6
17068: PPUSH
17069: CALL_OW 247
17073: PUSH
17074: LD_INT 1
17076: DOUBLE
17077: EQUAL
17078: IFTRUE 17082
17080: GO 17660
17082: POP
// begin if GetClass ( i ) = 1 then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 257
17092: PUSH
17093: LD_INT 1
17095: EQUAL
17096: IFFALSE 17117
// points := [ 10 , 5 , 3 ] ;
17098: LD_ADDR_VAR 0 9
17102: PUSH
17103: LD_INT 10
17105: PUSH
17106: LD_INT 5
17108: PUSH
17109: LD_INT 3
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17117: LD_VAR 0 6
17121: PPUSH
17122: CALL_OW 257
17126: PUSH
17127: LD_INT 2
17129: PUSH
17130: LD_INT 3
17132: PUSH
17133: LD_INT 4
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: LIST
17140: IN
17141: IFFALSE 17162
// points := [ 3 , 2 , 1 ] ;
17143: LD_ADDR_VAR 0 9
17147: PUSH
17148: LD_INT 3
17150: PUSH
17151: LD_INT 2
17153: PUSH
17154: LD_INT 1
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17162: LD_VAR 0 6
17166: PPUSH
17167: CALL_OW 257
17171: PUSH
17172: LD_INT 5
17174: EQUAL
17175: IFFALSE 17196
// points := [ 130 , 5 , 2 ] ;
17177: LD_ADDR_VAR 0 9
17181: PUSH
17182: LD_INT 130
17184: PUSH
17185: LD_INT 5
17187: PUSH
17188: LD_INT 2
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: LIST
17195: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17196: LD_VAR 0 6
17200: PPUSH
17201: CALL_OW 257
17205: PUSH
17206: LD_INT 8
17208: EQUAL
17209: IFFALSE 17230
// points := [ 35 , 35 , 30 ] ;
17211: LD_ADDR_VAR 0 9
17215: PUSH
17216: LD_INT 35
17218: PUSH
17219: LD_INT 35
17221: PUSH
17222: LD_INT 30
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17230: LD_VAR 0 6
17234: PPUSH
17235: CALL_OW 257
17239: PUSH
17240: LD_INT 9
17242: EQUAL
17243: IFFALSE 17264
// points := [ 20 , 55 , 40 ] ;
17245: LD_ADDR_VAR 0 9
17249: PUSH
17250: LD_INT 20
17252: PUSH
17253: LD_INT 55
17255: PUSH
17256: LD_INT 40
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: LIST
17263: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17264: LD_VAR 0 6
17268: PPUSH
17269: CALL_OW 257
17273: PUSH
17274: LD_INT 12
17276: PUSH
17277: LD_INT 16
17279: PUSH
17280: EMPTY
17281: LIST
17282: LIST
17283: IN
17284: IFFALSE 17305
// points := [ 5 , 3 , 2 ] ;
17286: LD_ADDR_VAR 0 9
17290: PUSH
17291: LD_INT 5
17293: PUSH
17294: LD_INT 3
17296: PUSH
17297: LD_INT 2
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: LIST
17304: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17305: LD_VAR 0 6
17309: PPUSH
17310: CALL_OW 257
17314: PUSH
17315: LD_INT 17
17317: EQUAL
17318: IFFALSE 17339
// points := [ 100 , 50 , 75 ] ;
17320: LD_ADDR_VAR 0 9
17324: PUSH
17325: LD_INT 100
17327: PUSH
17328: LD_INT 50
17330: PUSH
17331: LD_INT 75
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: LIST
17338: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17339: LD_VAR 0 6
17343: PPUSH
17344: CALL_OW 257
17348: PUSH
17349: LD_INT 15
17351: EQUAL
17352: IFFALSE 17373
// points := [ 10 , 5 , 3 ] ;
17354: LD_ADDR_VAR 0 9
17358: PUSH
17359: LD_INT 10
17361: PUSH
17362: LD_INT 5
17364: PUSH
17365: LD_INT 3
17367: PUSH
17368: EMPTY
17369: LIST
17370: LIST
17371: LIST
17372: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17373: LD_VAR 0 6
17377: PPUSH
17378: CALL_OW 257
17382: PUSH
17383: LD_INT 14
17385: EQUAL
17386: IFFALSE 17407
// points := [ 10 , 0 , 0 ] ;
17388: LD_ADDR_VAR 0 9
17392: PUSH
17393: LD_INT 10
17395: PUSH
17396: LD_INT 0
17398: PUSH
17399: LD_INT 0
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: LIST
17406: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17407: LD_VAR 0 6
17411: PPUSH
17412: CALL_OW 257
17416: PUSH
17417: LD_INT 11
17419: EQUAL
17420: IFFALSE 17441
// points := [ 30 , 10 , 5 ] ;
17422: LD_ADDR_VAR 0 9
17426: PUSH
17427: LD_INT 30
17429: PUSH
17430: LD_INT 10
17432: PUSH
17433: LD_INT 5
17435: PUSH
17436: EMPTY
17437: LIST
17438: LIST
17439: LIST
17440: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17441: LD_VAR 0 1
17445: PPUSH
17446: LD_INT 5
17448: PPUSH
17449: CALL_OW 321
17453: PUSH
17454: LD_INT 2
17456: EQUAL
17457: IFFALSE 17474
// bpoints := bpoints * 1.8 ;
17459: LD_ADDR_VAR 0 10
17463: PUSH
17464: LD_VAR 0 10
17468: PUSH
17469: LD_REAL  1.80000000000000E+0000
17472: MUL
17473: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17474: LD_VAR 0 6
17478: PPUSH
17479: CALL_OW 257
17483: PUSH
17484: LD_INT 1
17486: PUSH
17487: LD_INT 2
17489: PUSH
17490: LD_INT 3
17492: PUSH
17493: LD_INT 4
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: IN
17502: PUSH
17503: LD_VAR 0 1
17507: PPUSH
17508: LD_INT 51
17510: PPUSH
17511: CALL_OW 321
17515: PUSH
17516: LD_INT 2
17518: EQUAL
17519: AND
17520: IFFALSE 17537
// bpoints := bpoints * 1.2 ;
17522: LD_ADDR_VAR 0 10
17526: PUSH
17527: LD_VAR 0 10
17531: PUSH
17532: LD_REAL  1.20000000000000E+0000
17535: MUL
17536: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17537: LD_VAR 0 6
17541: PPUSH
17542: CALL_OW 257
17546: PUSH
17547: LD_INT 5
17549: PUSH
17550: LD_INT 7
17552: PUSH
17553: LD_INT 9
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: IN
17561: PUSH
17562: LD_VAR 0 1
17566: PPUSH
17567: LD_INT 52
17569: PPUSH
17570: CALL_OW 321
17574: PUSH
17575: LD_INT 2
17577: EQUAL
17578: AND
17579: IFFALSE 17596
// bpoints := bpoints * 1.5 ;
17581: LD_ADDR_VAR 0 10
17585: PUSH
17586: LD_VAR 0 10
17590: PUSH
17591: LD_REAL  1.50000000000000E+0000
17594: MUL
17595: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17596: LD_VAR 0 1
17600: PPUSH
17601: LD_INT 66
17603: PPUSH
17604: CALL_OW 321
17608: PUSH
17609: LD_INT 2
17611: EQUAL
17612: IFFALSE 17629
// bpoints := bpoints * 1.1 ;
17614: LD_ADDR_VAR 0 10
17618: PUSH
17619: LD_VAR 0 10
17623: PUSH
17624: LD_REAL  1.10000000000000E+0000
17627: MUL
17628: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17629: LD_ADDR_VAR 0 10
17633: PUSH
17634: LD_VAR 0 10
17638: PUSH
17639: LD_VAR 0 6
17643: PPUSH
17644: LD_INT 1
17646: PPUSH
17647: CALL_OW 259
17651: PUSH
17652: LD_REAL  1.15000000000000E+0000
17655: MUL
17656: MUL
17657: ST_TO_ADDR
// end ; unit_vehicle :
17658: GO 18488
17660: LD_INT 2
17662: DOUBLE
17663: EQUAL
17664: IFTRUE 17668
17666: GO 18476
17668: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17669: LD_VAR 0 6
17673: PPUSH
17674: CALL_OW 264
17678: PUSH
17679: LD_INT 2
17681: PUSH
17682: LD_INT 42
17684: PUSH
17685: LD_INT 24
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: IN
17693: IFFALSE 17714
// points := [ 25 , 5 , 3 ] ;
17695: LD_ADDR_VAR 0 9
17699: PUSH
17700: LD_INT 25
17702: PUSH
17703: LD_INT 5
17705: PUSH
17706: LD_INT 3
17708: PUSH
17709: EMPTY
17710: LIST
17711: LIST
17712: LIST
17713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17714: LD_VAR 0 6
17718: PPUSH
17719: CALL_OW 264
17723: PUSH
17724: LD_INT 4
17726: PUSH
17727: LD_INT 43
17729: PUSH
17730: LD_INT 25
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: IN
17738: IFFALSE 17759
// points := [ 40 , 15 , 5 ] ;
17740: LD_ADDR_VAR 0 9
17744: PUSH
17745: LD_INT 40
17747: PUSH
17748: LD_INT 15
17750: PUSH
17751: LD_INT 5
17753: PUSH
17754: EMPTY
17755: LIST
17756: LIST
17757: LIST
17758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17759: LD_VAR 0 6
17763: PPUSH
17764: CALL_OW 264
17768: PUSH
17769: LD_INT 3
17771: PUSH
17772: LD_INT 23
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: IN
17779: IFFALSE 17800
// points := [ 7 , 25 , 8 ] ;
17781: LD_ADDR_VAR 0 9
17785: PUSH
17786: LD_INT 7
17788: PUSH
17789: LD_INT 25
17791: PUSH
17792: LD_INT 8
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: LIST
17799: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17800: LD_VAR 0 6
17804: PPUSH
17805: CALL_OW 264
17809: PUSH
17810: LD_INT 5
17812: PUSH
17813: LD_INT 27
17815: PUSH
17816: LD_INT 44
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: IN
17824: IFFALSE 17845
// points := [ 14 , 50 , 16 ] ;
17826: LD_ADDR_VAR 0 9
17830: PUSH
17831: LD_INT 14
17833: PUSH
17834: LD_INT 50
17836: PUSH
17837: LD_INT 16
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17845: LD_VAR 0 6
17849: PPUSH
17850: CALL_OW 264
17854: PUSH
17855: LD_INT 6
17857: PUSH
17858: LD_INT 46
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: IN
17865: IFFALSE 17886
// points := [ 32 , 120 , 70 ] ;
17867: LD_ADDR_VAR 0 9
17871: PUSH
17872: LD_INT 32
17874: PUSH
17875: LD_INT 120
17877: PUSH
17878: LD_INT 70
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: LIST
17885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
17886: LD_VAR 0 6
17890: PPUSH
17891: CALL_OW 264
17895: PUSH
17896: LD_INT 7
17898: PUSH
17899: LD_INT 28
17901: PUSH
17902: LD_INT 45
17904: PUSH
17905: LD_EXP 72
17909: PUSH
17910: EMPTY
17911: LIST
17912: LIST
17913: LIST
17914: LIST
17915: IN
17916: IFFALSE 17937
// points := [ 35 , 20 , 45 ] ;
17918: LD_ADDR_VAR 0 9
17922: PUSH
17923: LD_INT 35
17925: PUSH
17926: LD_INT 20
17928: PUSH
17929: LD_INT 45
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
17937: LD_VAR 0 6
17941: PPUSH
17942: CALL_OW 264
17946: PUSH
17947: LD_INT 47
17949: PUSH
17950: EMPTY
17951: LIST
17952: IN
17953: IFFALSE 17974
// points := [ 67 , 45 , 75 ] ;
17955: LD_ADDR_VAR 0 9
17959: PUSH
17960: LD_INT 67
17962: PUSH
17963: LD_INT 45
17965: PUSH
17966: LD_INT 75
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
17974: LD_VAR 0 6
17978: PPUSH
17979: CALL_OW 264
17983: PUSH
17984: LD_INT 26
17986: PUSH
17987: EMPTY
17988: LIST
17989: IN
17990: IFFALSE 18011
// points := [ 120 , 30 , 80 ] ;
17992: LD_ADDR_VAR 0 9
17996: PUSH
17997: LD_INT 120
17999: PUSH
18000: LD_INT 30
18002: PUSH
18003: LD_INT 80
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: LIST
18010: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18011: LD_VAR 0 6
18015: PPUSH
18016: CALL_OW 264
18020: PUSH
18021: LD_INT 22
18023: PUSH
18024: EMPTY
18025: LIST
18026: IN
18027: IFFALSE 18048
// points := [ 40 , 1 , 1 ] ;
18029: LD_ADDR_VAR 0 9
18033: PUSH
18034: LD_INT 40
18036: PUSH
18037: LD_INT 1
18039: PUSH
18040: LD_INT 1
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18048: LD_VAR 0 6
18052: PPUSH
18053: CALL_OW 264
18057: PUSH
18058: LD_INT 29
18060: PUSH
18061: EMPTY
18062: LIST
18063: IN
18064: IFFALSE 18085
// points := [ 70 , 200 , 400 ] ;
18066: LD_ADDR_VAR 0 9
18070: PUSH
18071: LD_INT 70
18073: PUSH
18074: LD_INT 200
18076: PUSH
18077: LD_INT 400
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: LIST
18084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18085: LD_VAR 0 6
18089: PPUSH
18090: CALL_OW 264
18094: PUSH
18095: LD_INT 14
18097: PUSH
18098: LD_INT 53
18100: PUSH
18101: EMPTY
18102: LIST
18103: LIST
18104: IN
18105: IFFALSE 18126
// points := [ 40 , 10 , 20 ] ;
18107: LD_ADDR_VAR 0 9
18111: PUSH
18112: LD_INT 40
18114: PUSH
18115: LD_INT 10
18117: PUSH
18118: LD_INT 20
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: LIST
18125: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18126: LD_VAR 0 6
18130: PPUSH
18131: CALL_OW 264
18135: PUSH
18136: LD_INT 9
18138: PUSH
18139: EMPTY
18140: LIST
18141: IN
18142: IFFALSE 18163
// points := [ 5 , 70 , 20 ] ;
18144: LD_ADDR_VAR 0 9
18148: PUSH
18149: LD_INT 5
18151: PUSH
18152: LD_INT 70
18154: PUSH
18155: LD_INT 20
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18163: LD_VAR 0 6
18167: PPUSH
18168: CALL_OW 264
18172: PUSH
18173: LD_INT 10
18175: PUSH
18176: EMPTY
18177: LIST
18178: IN
18179: IFFALSE 18200
// points := [ 35 , 110 , 70 ] ;
18181: LD_ADDR_VAR 0 9
18185: PUSH
18186: LD_INT 35
18188: PUSH
18189: LD_INT 110
18191: PUSH
18192: LD_INT 70
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: LIST
18199: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18200: LD_VAR 0 6
18204: PPUSH
18205: CALL_OW 265
18209: PUSH
18210: LD_INT 25
18212: EQUAL
18213: IFFALSE 18234
// points := [ 80 , 65 , 100 ] ;
18215: LD_ADDR_VAR 0 9
18219: PUSH
18220: LD_INT 80
18222: PUSH
18223: LD_INT 65
18225: PUSH
18226: LD_INT 100
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: LIST
18233: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18234: LD_VAR 0 6
18238: PPUSH
18239: CALL_OW 263
18243: PUSH
18244: LD_INT 1
18246: EQUAL
18247: IFFALSE 18282
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18249: LD_ADDR_VAR 0 10
18253: PUSH
18254: LD_VAR 0 10
18258: PUSH
18259: LD_VAR 0 6
18263: PPUSH
18264: CALL_OW 311
18268: PPUSH
18269: LD_INT 3
18271: PPUSH
18272: CALL_OW 259
18276: PUSH
18277: LD_INT 4
18279: MUL
18280: MUL
18281: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18282: LD_VAR 0 6
18286: PPUSH
18287: CALL_OW 263
18291: PUSH
18292: LD_INT 2
18294: EQUAL
18295: IFFALSE 18346
// begin j := IsControledBy ( i ) ;
18297: LD_ADDR_VAR 0 7
18301: PUSH
18302: LD_VAR 0 6
18306: PPUSH
18307: CALL_OW 312
18311: ST_TO_ADDR
// if j then
18312: LD_VAR 0 7
18316: IFFALSE 18346
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18318: LD_ADDR_VAR 0 10
18322: PUSH
18323: LD_VAR 0 10
18327: PUSH
18328: LD_VAR 0 7
18332: PPUSH
18333: LD_INT 3
18335: PPUSH
18336: CALL_OW 259
18340: PUSH
18341: LD_INT 3
18343: MUL
18344: MUL
18345: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18346: LD_VAR 0 6
18350: PPUSH
18351: CALL_OW 264
18355: PUSH
18356: LD_INT 5
18358: PUSH
18359: LD_INT 6
18361: PUSH
18362: LD_INT 46
18364: PUSH
18365: LD_INT 44
18367: PUSH
18368: LD_INT 47
18370: PUSH
18371: LD_INT 45
18373: PUSH
18374: LD_INT 28
18376: PUSH
18377: LD_INT 7
18379: PUSH
18380: LD_INT 27
18382: PUSH
18383: LD_INT 29
18385: PUSH
18386: EMPTY
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: IN
18398: PUSH
18399: LD_VAR 0 1
18403: PPUSH
18404: LD_INT 52
18406: PPUSH
18407: CALL_OW 321
18411: PUSH
18412: LD_INT 2
18414: EQUAL
18415: AND
18416: IFFALSE 18433
// bpoints := bpoints * 1.2 ;
18418: LD_ADDR_VAR 0 10
18422: PUSH
18423: LD_VAR 0 10
18427: PUSH
18428: LD_REAL  1.20000000000000E+0000
18431: MUL
18432: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18433: LD_VAR 0 6
18437: PPUSH
18438: CALL_OW 264
18442: PUSH
18443: LD_INT 6
18445: PUSH
18446: LD_INT 46
18448: PUSH
18449: LD_INT 47
18451: PUSH
18452: EMPTY
18453: LIST
18454: LIST
18455: LIST
18456: IN
18457: IFFALSE 18474
// bpoints := bpoints * 1.2 ;
18459: LD_ADDR_VAR 0 10
18463: PUSH
18464: LD_VAR 0 10
18468: PUSH
18469: LD_REAL  1.20000000000000E+0000
18472: MUL
18473: ST_TO_ADDR
// end ; unit_building :
18474: GO 18488
18476: LD_INT 3
18478: DOUBLE
18479: EQUAL
18480: IFTRUE 18484
18482: GO 18487
18484: POP
// ; end ;
18485: GO 18488
18487: POP
// for j = 1 to 3 do
18488: LD_ADDR_VAR 0 7
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_INT 3
18500: PUSH
18501: FOR_TO
18502: IFFALSE 18555
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18504: LD_ADDR_VAR 0 5
18508: PUSH
18509: LD_VAR 0 5
18513: PPUSH
18514: LD_VAR 0 7
18518: PPUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_VAR 0 7
18528: ARRAY
18529: PUSH
18530: LD_VAR 0 9
18534: PUSH
18535: LD_VAR 0 7
18539: ARRAY
18540: PUSH
18541: LD_VAR 0 10
18545: MUL
18546: PLUS
18547: PPUSH
18548: CALL_OW 1
18552: ST_TO_ADDR
18553: GO 18501
18555: POP
18556: POP
// end ;
18557: GO 17034
18559: POP
18560: POP
// result := Replace ( result , 4 , tmp ) ;
18561: LD_ADDR_VAR 0 5
18565: PUSH
18566: LD_VAR 0 5
18570: PPUSH
18571: LD_INT 4
18573: PPUSH
18574: LD_VAR 0 8
18578: PPUSH
18579: CALL_OW 1
18583: ST_TO_ADDR
// end ;
18584: LD_VAR 0 5
18588: RET
// export function DangerAtRange ( unit , range ) ; begin
18589: LD_INT 0
18591: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18592: LD_ADDR_VAR 0 3
18596: PUSH
18597: LD_VAR 0 1
18601: PPUSH
18602: CALL_OW 255
18606: PPUSH
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL_OW 250
18616: PPUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL_OW 251
18626: PPUSH
18627: LD_VAR 0 2
18631: PPUSH
18632: CALL 16886 0 4
18636: ST_TO_ADDR
// end ;
18637: LD_VAR 0 3
18641: RET
// export function DangerInArea ( side , area ) ; begin
18642: LD_INT 0
18644: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18645: LD_ADDR_VAR 0 3
18649: PUSH
18650: LD_VAR 0 2
18654: PPUSH
18655: LD_INT 81
18657: PUSH
18658: LD_VAR 0 1
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PPUSH
18667: CALL_OW 70
18671: ST_TO_ADDR
// end ;
18672: LD_VAR 0 3
18676: RET
// export function IsExtension ( b ) ; begin
18677: LD_INT 0
18679: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18680: LD_ADDR_VAR 0 2
18684: PUSH
18685: LD_VAR 0 1
18689: PUSH
18690: LD_INT 23
18692: PUSH
18693: LD_INT 20
18695: PUSH
18696: LD_INT 22
18698: PUSH
18699: LD_INT 17
18701: PUSH
18702: LD_INT 24
18704: PUSH
18705: LD_INT 21
18707: PUSH
18708: LD_INT 19
18710: PUSH
18711: LD_INT 16
18713: PUSH
18714: LD_INT 25
18716: PUSH
18717: LD_INT 18
18719: PUSH
18720: EMPTY
18721: LIST
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: IN
18732: ST_TO_ADDR
// end ;
18733: LD_VAR 0 2
18737: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18738: LD_INT 0
18740: PPUSH
18741: PPUSH
18742: PPUSH
// result := [ ] ;
18743: LD_ADDR_VAR 0 4
18747: PUSH
18748: EMPTY
18749: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18750: LD_ADDR_VAR 0 5
18754: PUSH
18755: LD_VAR 0 2
18759: PPUSH
18760: LD_INT 21
18762: PUSH
18763: LD_INT 3
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PPUSH
18770: CALL_OW 70
18774: ST_TO_ADDR
// if not tmp then
18775: LD_VAR 0 5
18779: NOT
18780: IFFALSE 18784
// exit ;
18782: GO 18848
// if checkLink then
18784: LD_VAR 0 3
18788: IFFALSE 18838
// begin for i in tmp do
18790: LD_ADDR_VAR 0 6
18794: PUSH
18795: LD_VAR 0 5
18799: PUSH
18800: FOR_IN
18801: IFFALSE 18836
// if GetBase ( i ) <> base then
18803: LD_VAR 0 6
18807: PPUSH
18808: CALL_OW 274
18812: PUSH
18813: LD_VAR 0 1
18817: NONEQUAL
18818: IFFALSE 18834
// ComLinkToBase ( base , i ) ;
18820: LD_VAR 0 1
18824: PPUSH
18825: LD_VAR 0 6
18829: PPUSH
18830: CALL_OW 169
18834: GO 18800
18836: POP
18837: POP
// end ; result := tmp ;
18838: LD_ADDR_VAR 0 4
18842: PUSH
18843: LD_VAR 0 5
18847: ST_TO_ADDR
// end ;
18848: LD_VAR 0 4
18852: RET
// export function ComComplete ( units , b ) ; var i ; begin
18853: LD_INT 0
18855: PPUSH
18856: PPUSH
// if not units then
18857: LD_VAR 0 1
18861: NOT
18862: IFFALSE 18866
// exit ;
18864: GO 18956
// for i in units do
18866: LD_ADDR_VAR 0 4
18870: PUSH
18871: LD_VAR 0 1
18875: PUSH
18876: FOR_IN
18877: IFFALSE 18954
// if BuildingStatus ( b ) = bs_build then
18879: LD_VAR 0 2
18883: PPUSH
18884: CALL_OW 461
18888: PUSH
18889: LD_INT 1
18891: EQUAL
18892: IFFALSE 18952
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
18894: LD_VAR 0 4
18898: PPUSH
18899: LD_STRING h
18901: PUSH
18902: LD_VAR 0 2
18906: PPUSH
18907: CALL_OW 250
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: CALL_OW 251
18921: PUSH
18922: LD_VAR 0 2
18926: PUSH
18927: LD_INT 0
18929: PUSH
18930: LD_INT 0
18932: PUSH
18933: LD_INT 0
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: PUSH
18945: EMPTY
18946: LIST
18947: PPUSH
18948: CALL_OW 446
18952: GO 18876
18954: POP
18955: POP
// end ;
18956: LD_VAR 0 3
18960: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
18961: LD_INT 0
18963: PPUSH
18964: PPUSH
18965: PPUSH
18966: PPUSH
18967: PPUSH
18968: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
18969: LD_VAR 0 1
18973: NOT
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: CALL_OW 263
18984: PUSH
18985: LD_INT 2
18987: NONEQUAL
18988: OR
18989: IFFALSE 18993
// exit ;
18991: GO 19309
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
18993: LD_ADDR_VAR 0 6
18997: PUSH
18998: LD_INT 22
19000: PUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 255
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: PUSH
19015: LD_INT 2
19017: PUSH
19018: LD_INT 30
19020: PUSH
19021: LD_INT 36
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: LD_INT 34
19030: PUSH
19031: LD_INT 31
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: LIST
19042: PUSH
19043: EMPTY
19044: LIST
19045: LIST
19046: PPUSH
19047: CALL_OW 69
19051: ST_TO_ADDR
// if not tmp then
19052: LD_VAR 0 6
19056: NOT
19057: IFFALSE 19061
// exit ;
19059: GO 19309
// result := [ ] ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: EMPTY
19067: ST_TO_ADDR
// for i in tmp do
19068: LD_ADDR_VAR 0 3
19072: PUSH
19073: LD_VAR 0 6
19077: PUSH
19078: FOR_IN
19079: IFFALSE 19150
// begin t := UnitsInside ( i ) ;
19081: LD_ADDR_VAR 0 4
19085: PUSH
19086: LD_VAR 0 3
19090: PPUSH
19091: CALL_OW 313
19095: ST_TO_ADDR
// if t then
19096: LD_VAR 0 4
19100: IFFALSE 19148
// for j in t do
19102: LD_ADDR_VAR 0 7
19106: PUSH
19107: LD_VAR 0 4
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19146
// result := Replace ( result , result + 1 , j ) ;
19115: LD_ADDR_VAR 0 2
19119: PUSH
19120: LD_VAR 0 2
19124: PPUSH
19125: LD_VAR 0 2
19129: PUSH
19130: LD_INT 1
19132: PLUS
19133: PPUSH
19134: LD_VAR 0 7
19138: PPUSH
19139: CALL_OW 1
19143: ST_TO_ADDR
19144: GO 19112
19146: POP
19147: POP
// end ;
19148: GO 19078
19150: POP
19151: POP
// if not result then
19152: LD_VAR 0 2
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 19309
// mech := result [ 1 ] ;
19161: LD_ADDR_VAR 0 5
19165: PUSH
19166: LD_VAR 0 2
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: ST_TO_ADDR
// if result > 1 then
19175: LD_VAR 0 2
19179: PUSH
19180: LD_INT 1
19182: GREATER
19183: IFFALSE 19295
// begin for i = 2 to result do
19185: LD_ADDR_VAR 0 3
19189: PUSH
19190: DOUBLE
19191: LD_INT 2
19193: DEC
19194: ST_TO_ADDR
19195: LD_VAR 0 2
19199: PUSH
19200: FOR_TO
19201: IFFALSE 19293
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19203: LD_ADDR_VAR 0 4
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_VAR 0 3
19217: ARRAY
19218: PPUSH
19219: LD_INT 3
19221: PPUSH
19222: CALL_OW 259
19226: PUSH
19227: LD_VAR 0 2
19231: PUSH
19232: LD_VAR 0 3
19236: ARRAY
19237: PPUSH
19238: CALL_OW 432
19242: MINUS
19243: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19244: LD_VAR 0 4
19248: PUSH
19249: LD_VAR 0 5
19253: PPUSH
19254: LD_INT 3
19256: PPUSH
19257: CALL_OW 259
19261: PUSH
19262: LD_VAR 0 5
19266: PPUSH
19267: CALL_OW 432
19271: MINUS
19272: GREATEREQUAL
19273: IFFALSE 19291
// mech := result [ i ] ;
19275: LD_ADDR_VAR 0 5
19279: PUSH
19280: LD_VAR 0 2
19284: PUSH
19285: LD_VAR 0 3
19289: ARRAY
19290: ST_TO_ADDR
// end ;
19291: GO 19200
19293: POP
19294: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 5
19304: PPUSH
19305: CALL_OW 135
// end ;
19309: LD_VAR 0 2
19313: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19314: LD_INT 0
19316: PPUSH
19317: PPUSH
19318: PPUSH
19319: PPUSH
19320: PPUSH
19321: PPUSH
19322: PPUSH
19323: PPUSH
19324: PPUSH
19325: PPUSH
19326: PPUSH
19327: PPUSH
19328: PPUSH
// result := [ ] ;
19329: LD_ADDR_VAR 0 7
19333: PUSH
19334: EMPTY
19335: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 266
19345: PUSH
19346: LD_INT 0
19348: PUSH
19349: LD_INT 1
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: IN
19356: NOT
19357: IFFALSE 19361
// exit ;
19359: GO 20995
// if name then
19361: LD_VAR 0 3
19365: IFFALSE 19381
// SetBName ( base_dep , name ) ;
19367: LD_VAR 0 1
19371: PPUSH
19372: LD_VAR 0 3
19376: PPUSH
19377: CALL_OW 500
// base := GetBase ( base_dep ) ;
19381: LD_ADDR_VAR 0 15
19385: PUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: CALL_OW 274
19395: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19396: LD_ADDR_VAR 0 16
19400: PUSH
19401: LD_VAR 0 1
19405: PPUSH
19406: CALL_OW 255
19410: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19411: LD_ADDR_VAR 0 17
19415: PUSH
19416: LD_VAR 0 1
19420: PPUSH
19421: CALL_OW 248
19425: ST_TO_ADDR
// if sources then
19426: LD_VAR 0 5
19430: IFFALSE 19477
// for i = 1 to 3 do
19432: LD_ADDR_VAR 0 8
19436: PUSH
19437: DOUBLE
19438: LD_INT 1
19440: DEC
19441: ST_TO_ADDR
19442: LD_INT 3
19444: PUSH
19445: FOR_TO
19446: IFFALSE 19475
// AddResourceType ( base , i , sources [ i ] ) ;
19448: LD_VAR 0 15
19452: PPUSH
19453: LD_VAR 0 8
19457: PPUSH
19458: LD_VAR 0 5
19462: PUSH
19463: LD_VAR 0 8
19467: ARRAY
19468: PPUSH
19469: CALL_OW 276
19473: GO 19445
19475: POP
19476: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19477: LD_ADDR_VAR 0 18
19481: PUSH
19482: LD_VAR 0 15
19486: PPUSH
19487: LD_VAR 0 2
19491: PPUSH
19492: LD_INT 1
19494: PPUSH
19495: CALL 18738 0 3
19499: ST_TO_ADDR
// InitHc ;
19500: CALL_OW 19
// InitUc ;
19504: CALL_OW 18
// uc_side := side ;
19508: LD_ADDR_OWVAR 20
19512: PUSH
19513: LD_VAR 0 16
19517: ST_TO_ADDR
// uc_nation := nation ;
19518: LD_ADDR_OWVAR 21
19522: PUSH
19523: LD_VAR 0 17
19527: ST_TO_ADDR
// if buildings then
19528: LD_VAR 0 18
19532: IFFALSE 20854
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19534: LD_ADDR_VAR 0 19
19538: PUSH
19539: LD_VAR 0 18
19543: PPUSH
19544: LD_INT 2
19546: PUSH
19547: LD_INT 30
19549: PUSH
19550: LD_INT 29
19552: PUSH
19553: EMPTY
19554: LIST
19555: LIST
19556: PUSH
19557: LD_INT 30
19559: PUSH
19560: LD_INT 30
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 72
19576: ST_TO_ADDR
// if tmp then
19577: LD_VAR 0 19
19581: IFFALSE 19629
// for i in tmp do
19583: LD_ADDR_VAR 0 8
19587: PUSH
19588: LD_VAR 0 19
19592: PUSH
19593: FOR_IN
19594: IFFALSE 19627
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19596: LD_VAR 0 8
19600: PPUSH
19601: CALL_OW 250
19605: PPUSH
19606: LD_VAR 0 8
19610: PPUSH
19611: CALL_OW 251
19615: PPUSH
19616: LD_VAR 0 16
19620: PPUSH
19621: CALL_OW 441
19625: GO 19593
19627: POP
19628: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19629: LD_VAR 0 18
19633: PPUSH
19634: LD_INT 2
19636: PUSH
19637: LD_INT 30
19639: PUSH
19640: LD_INT 32
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: PUSH
19647: LD_INT 30
19649: PUSH
19650: LD_INT 33
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: PUSH
19657: EMPTY
19658: LIST
19659: LIST
19660: LIST
19661: PPUSH
19662: CALL_OW 72
19666: IFFALSE 19754
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19668: LD_ADDR_VAR 0 8
19672: PUSH
19673: LD_VAR 0 18
19677: PPUSH
19678: LD_INT 2
19680: PUSH
19681: LD_INT 30
19683: PUSH
19684: LD_INT 32
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: PUSH
19691: LD_INT 30
19693: PUSH
19694: LD_INT 33
19696: PUSH
19697: EMPTY
19698: LIST
19699: LIST
19700: PUSH
19701: EMPTY
19702: LIST
19703: LIST
19704: LIST
19705: PPUSH
19706: CALL_OW 72
19710: PUSH
19711: FOR_IN
19712: IFFALSE 19752
// begin if not GetBWeapon ( i ) then
19714: LD_VAR 0 8
19718: PPUSH
19719: CALL_OW 269
19723: NOT
19724: IFFALSE 19750
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19726: LD_VAR 0 8
19730: PPUSH
19731: LD_VAR 0 8
19735: PPUSH
19736: LD_VAR 0 2
19740: PPUSH
19741: CALL 21000 0 2
19745: PPUSH
19746: CALL_OW 431
// end ;
19750: GO 19711
19752: POP
19753: POP
// end ; for i = 1 to personel do
19754: LD_ADDR_VAR 0 8
19758: PUSH
19759: DOUBLE
19760: LD_INT 1
19762: DEC
19763: ST_TO_ADDR
19764: LD_VAR 0 6
19768: PUSH
19769: FOR_TO
19770: IFFALSE 20834
// begin if i > 4 then
19772: LD_VAR 0 8
19776: PUSH
19777: LD_INT 4
19779: GREATER
19780: IFFALSE 19784
// break ;
19782: GO 20834
// case i of 1 :
19784: LD_VAR 0 8
19788: PUSH
19789: LD_INT 1
19791: DOUBLE
19792: EQUAL
19793: IFTRUE 19797
19795: GO 19877
19797: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19798: LD_ADDR_VAR 0 12
19802: PUSH
19803: LD_VAR 0 18
19807: PPUSH
19808: LD_INT 22
19810: PUSH
19811: LD_VAR 0 16
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 58
19822: PUSH
19823: EMPTY
19824: LIST
19825: PUSH
19826: LD_INT 2
19828: PUSH
19829: LD_INT 30
19831: PUSH
19832: LD_INT 32
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 4
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: PUSH
19849: LD_INT 30
19851: PUSH
19852: LD_INT 5
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: LIST
19869: PPUSH
19870: CALL_OW 72
19874: ST_TO_ADDR
19875: GO 20099
19877: LD_INT 2
19879: DOUBLE
19880: EQUAL
19881: IFTRUE 19885
19883: GO 19947
19885: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
19886: LD_ADDR_VAR 0 12
19890: PUSH
19891: LD_VAR 0 18
19895: PPUSH
19896: LD_INT 22
19898: PUSH
19899: LD_VAR 0 16
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: LD_INT 2
19910: PUSH
19911: LD_INT 30
19913: PUSH
19914: LD_INT 0
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: PUSH
19921: LD_INT 30
19923: PUSH
19924: LD_INT 1
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: LIST
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: PPUSH
19940: CALL_OW 72
19944: ST_TO_ADDR
19945: GO 20099
19947: LD_INT 3
19949: DOUBLE
19950: EQUAL
19951: IFTRUE 19955
19953: GO 20017
19955: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
19956: LD_ADDR_VAR 0 12
19960: PUSH
19961: LD_VAR 0 18
19965: PPUSH
19966: LD_INT 22
19968: PUSH
19969: LD_VAR 0 16
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: PUSH
19978: LD_INT 2
19980: PUSH
19981: LD_INT 30
19983: PUSH
19984: LD_INT 2
19986: PUSH
19987: EMPTY
19988: LIST
19989: LIST
19990: PUSH
19991: LD_INT 30
19993: PUSH
19994: LD_INT 3
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PUSH
20001: EMPTY
20002: LIST
20003: LIST
20004: LIST
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PPUSH
20010: CALL_OW 72
20014: ST_TO_ADDR
20015: GO 20099
20017: LD_INT 4
20019: DOUBLE
20020: EQUAL
20021: IFTRUE 20025
20023: GO 20098
20025: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20026: LD_ADDR_VAR 0 12
20030: PUSH
20031: LD_VAR 0 18
20035: PPUSH
20036: LD_INT 22
20038: PUSH
20039: LD_VAR 0 16
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: PUSH
20048: LD_INT 2
20050: PUSH
20051: LD_INT 30
20053: PUSH
20054: LD_INT 6
20056: PUSH
20057: EMPTY
20058: LIST
20059: LIST
20060: PUSH
20061: LD_INT 30
20063: PUSH
20064: LD_INT 7
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: PUSH
20071: LD_INT 30
20073: PUSH
20074: LD_INT 8
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: PPUSH
20091: CALL_OW 72
20095: ST_TO_ADDR
20096: GO 20099
20098: POP
// if i = 1 then
20099: LD_VAR 0 8
20103: PUSH
20104: LD_INT 1
20106: EQUAL
20107: IFFALSE 20218
// begin tmp := [ ] ;
20109: LD_ADDR_VAR 0 19
20113: PUSH
20114: EMPTY
20115: ST_TO_ADDR
// for j in f do
20116: LD_ADDR_VAR 0 9
20120: PUSH
20121: LD_VAR 0 12
20125: PUSH
20126: FOR_IN
20127: IFFALSE 20200
// if GetBType ( j ) = b_bunker then
20129: LD_VAR 0 9
20133: PPUSH
20134: CALL_OW 266
20138: PUSH
20139: LD_INT 32
20141: EQUAL
20142: IFFALSE 20169
// tmp := Insert ( tmp , 1 , j ) else
20144: LD_ADDR_VAR 0 19
20148: PUSH
20149: LD_VAR 0 19
20153: PPUSH
20154: LD_INT 1
20156: PPUSH
20157: LD_VAR 0 9
20161: PPUSH
20162: CALL_OW 2
20166: ST_TO_ADDR
20167: GO 20198
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20169: LD_ADDR_VAR 0 19
20173: PUSH
20174: LD_VAR 0 19
20178: PPUSH
20179: LD_VAR 0 19
20183: PUSH
20184: LD_INT 1
20186: PLUS
20187: PPUSH
20188: LD_VAR 0 9
20192: PPUSH
20193: CALL_OW 2
20197: ST_TO_ADDR
20198: GO 20126
20200: POP
20201: POP
// if tmp then
20202: LD_VAR 0 19
20206: IFFALSE 20218
// f := tmp ;
20208: LD_ADDR_VAR 0 12
20212: PUSH
20213: LD_VAR 0 19
20217: ST_TO_ADDR
// end ; x := personel [ i ] ;
20218: LD_ADDR_VAR 0 13
20222: PUSH
20223: LD_VAR 0 6
20227: PUSH
20228: LD_VAR 0 8
20232: ARRAY
20233: ST_TO_ADDR
// if x = - 1 then
20234: LD_VAR 0 13
20238: PUSH
20239: LD_INT 1
20241: NEG
20242: EQUAL
20243: IFFALSE 20452
// begin for j in f do
20245: LD_ADDR_VAR 0 9
20249: PUSH
20250: LD_VAR 0 12
20254: PUSH
20255: FOR_IN
20256: IFFALSE 20448
// repeat InitHc ;
20258: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20262: LD_VAR 0 9
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 5
20274: EQUAL
20275: IFFALSE 20345
// begin if UnitsInside ( j ) < 3 then
20277: LD_VAR 0 9
20281: PPUSH
20282: CALL_OW 313
20286: PUSH
20287: LD_INT 3
20289: LESS
20290: IFFALSE 20326
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20292: LD_INT 0
20294: PPUSH
20295: LD_INT 5
20297: PUSH
20298: LD_INT 8
20300: PUSH
20301: LD_INT 9
20303: PUSH
20304: EMPTY
20305: LIST
20306: LIST
20307: LIST
20308: PUSH
20309: LD_VAR 0 17
20313: ARRAY
20314: PPUSH
20315: LD_VAR 0 4
20319: PPUSH
20320: CALL_OW 380
20324: GO 20343
// PrepareHuman ( false , i , skill ) ;
20326: LD_INT 0
20328: PPUSH
20329: LD_VAR 0 8
20333: PPUSH
20334: LD_VAR 0 4
20338: PPUSH
20339: CALL_OW 380
// end else
20343: GO 20362
// PrepareHuman ( false , i , skill ) ;
20345: LD_INT 0
20347: PPUSH
20348: LD_VAR 0 8
20352: PPUSH
20353: LD_VAR 0 4
20357: PPUSH
20358: CALL_OW 380
// un := CreateHuman ;
20362: LD_ADDR_VAR 0 14
20366: PUSH
20367: CALL_OW 44
20371: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20372: LD_ADDR_VAR 0 7
20376: PUSH
20377: LD_VAR 0 7
20381: PPUSH
20382: LD_INT 1
20384: PPUSH
20385: LD_VAR 0 14
20389: PPUSH
20390: CALL_OW 2
20394: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20395: LD_VAR 0 14
20399: PPUSH
20400: LD_VAR 0 9
20404: PPUSH
20405: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20409: LD_VAR 0 9
20413: PPUSH
20414: CALL_OW 313
20418: PUSH
20419: LD_INT 6
20421: EQUAL
20422: PUSH
20423: LD_VAR 0 9
20427: PPUSH
20428: CALL_OW 266
20432: PUSH
20433: LD_INT 32
20435: PUSH
20436: LD_INT 31
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: IN
20443: OR
20444: IFFALSE 20258
20446: GO 20255
20448: POP
20449: POP
// end else
20450: GO 20832
// for j = 1 to x do
20452: LD_ADDR_VAR 0 9
20456: PUSH
20457: DOUBLE
20458: LD_INT 1
20460: DEC
20461: ST_TO_ADDR
20462: LD_VAR 0 13
20466: PUSH
20467: FOR_TO
20468: IFFALSE 20830
// begin InitHc ;
20470: CALL_OW 19
// if not f then
20474: LD_VAR 0 12
20478: NOT
20479: IFFALSE 20568
// begin PrepareHuman ( false , i , skill ) ;
20481: LD_INT 0
20483: PPUSH
20484: LD_VAR 0 8
20488: PPUSH
20489: LD_VAR 0 4
20493: PPUSH
20494: CALL_OW 380
// un := CreateHuman ;
20498: LD_ADDR_VAR 0 14
20502: PUSH
20503: CALL_OW 44
20507: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20508: LD_ADDR_VAR 0 7
20512: PUSH
20513: LD_VAR 0 7
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: LD_VAR 0 14
20525: PPUSH
20526: CALL_OW 2
20530: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20531: LD_VAR 0 14
20535: PPUSH
20536: LD_VAR 0 1
20540: PPUSH
20541: CALL_OW 250
20545: PPUSH
20546: LD_VAR 0 1
20550: PPUSH
20551: CALL_OW 251
20555: PPUSH
20556: LD_INT 10
20558: PPUSH
20559: LD_INT 0
20561: PPUSH
20562: CALL_OW 50
// continue ;
20566: GO 20467
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20568: LD_VAR 0 12
20572: PUSH
20573: LD_INT 1
20575: ARRAY
20576: PPUSH
20577: CALL_OW 313
20581: PUSH
20582: LD_VAR 0 12
20586: PUSH
20587: LD_INT 1
20589: ARRAY
20590: PPUSH
20591: CALL_OW 266
20595: PUSH
20596: LD_INT 32
20598: PUSH
20599: LD_INT 31
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: IN
20606: AND
20607: PUSH
20608: LD_VAR 0 12
20612: PUSH
20613: LD_INT 1
20615: ARRAY
20616: PPUSH
20617: CALL_OW 313
20621: PUSH
20622: LD_INT 6
20624: EQUAL
20625: OR
20626: IFFALSE 20646
// f := Delete ( f , 1 ) ;
20628: LD_ADDR_VAR 0 12
20632: PUSH
20633: LD_VAR 0 12
20637: PPUSH
20638: LD_INT 1
20640: PPUSH
20641: CALL_OW 3
20645: ST_TO_ADDR
// if not f then
20646: LD_VAR 0 12
20650: NOT
20651: IFFALSE 20669
// begin x := x + 2 ;
20653: LD_ADDR_VAR 0 13
20657: PUSH
20658: LD_VAR 0 13
20662: PUSH
20663: LD_INT 2
20665: PLUS
20666: ST_TO_ADDR
// continue ;
20667: GO 20467
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20669: LD_VAR 0 12
20673: PUSH
20674: LD_INT 1
20676: ARRAY
20677: PPUSH
20678: CALL_OW 266
20682: PUSH
20683: LD_INT 5
20685: EQUAL
20686: IFFALSE 20760
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20688: LD_VAR 0 12
20692: PUSH
20693: LD_INT 1
20695: ARRAY
20696: PPUSH
20697: CALL_OW 313
20701: PUSH
20702: LD_INT 3
20704: LESS
20705: IFFALSE 20741
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20707: LD_INT 0
20709: PPUSH
20710: LD_INT 5
20712: PUSH
20713: LD_INT 8
20715: PUSH
20716: LD_INT 9
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: LIST
20723: PUSH
20724: LD_VAR 0 17
20728: ARRAY
20729: PPUSH
20730: LD_VAR 0 4
20734: PPUSH
20735: CALL_OW 380
20739: GO 20758
// PrepareHuman ( false , i , skill ) ;
20741: LD_INT 0
20743: PPUSH
20744: LD_VAR 0 8
20748: PPUSH
20749: LD_VAR 0 4
20753: PPUSH
20754: CALL_OW 380
// end else
20758: GO 20777
// PrepareHuman ( false , i , skill ) ;
20760: LD_INT 0
20762: PPUSH
20763: LD_VAR 0 8
20767: PPUSH
20768: LD_VAR 0 4
20772: PPUSH
20773: CALL_OW 380
// un := CreateHuman ;
20777: LD_ADDR_VAR 0 14
20781: PUSH
20782: CALL_OW 44
20786: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20787: LD_ADDR_VAR 0 7
20791: PUSH
20792: LD_VAR 0 7
20796: PPUSH
20797: LD_INT 1
20799: PPUSH
20800: LD_VAR 0 14
20804: PPUSH
20805: CALL_OW 2
20809: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20810: LD_VAR 0 14
20814: PPUSH
20815: LD_VAR 0 12
20819: PUSH
20820: LD_INT 1
20822: ARRAY
20823: PPUSH
20824: CALL_OW 52
// end ;
20828: GO 20467
20830: POP
20831: POP
// end ;
20832: GO 19769
20834: POP
20835: POP
// result := result ^ buildings ;
20836: LD_ADDR_VAR 0 7
20840: PUSH
20841: LD_VAR 0 7
20845: PUSH
20846: LD_VAR 0 18
20850: ADD
20851: ST_TO_ADDR
// end else
20852: GO 20995
// begin for i = 1 to personel do
20854: LD_ADDR_VAR 0 8
20858: PUSH
20859: DOUBLE
20860: LD_INT 1
20862: DEC
20863: ST_TO_ADDR
20864: LD_VAR 0 6
20868: PUSH
20869: FOR_TO
20870: IFFALSE 20993
// begin if i > 4 then
20872: LD_VAR 0 8
20876: PUSH
20877: LD_INT 4
20879: GREATER
20880: IFFALSE 20884
// break ;
20882: GO 20993
// x := personel [ i ] ;
20884: LD_ADDR_VAR 0 13
20888: PUSH
20889: LD_VAR 0 6
20893: PUSH
20894: LD_VAR 0 8
20898: ARRAY
20899: ST_TO_ADDR
// if x = - 1 then
20900: LD_VAR 0 13
20904: PUSH
20905: LD_INT 1
20907: NEG
20908: EQUAL
20909: IFFALSE 20913
// continue ;
20911: GO 20869
// PrepareHuman ( false , i , skill ) ;
20913: LD_INT 0
20915: PPUSH
20916: LD_VAR 0 8
20920: PPUSH
20921: LD_VAR 0 4
20925: PPUSH
20926: CALL_OW 380
// un := CreateHuman ;
20930: LD_ADDR_VAR 0 14
20934: PUSH
20935: CALL_OW 44
20939: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20940: LD_VAR 0 14
20944: PPUSH
20945: LD_VAR 0 1
20949: PPUSH
20950: CALL_OW 250
20954: PPUSH
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 251
20964: PPUSH
20965: LD_INT 10
20967: PPUSH
20968: LD_INT 0
20970: PPUSH
20971: CALL_OW 50
// result := result ^ un ;
20975: LD_ADDR_VAR 0 7
20979: PUSH
20980: LD_VAR 0 7
20984: PUSH
20985: LD_VAR 0 14
20989: ADD
20990: ST_TO_ADDR
// end ;
20991: GO 20869
20993: POP
20994: POP
// end ; end ;
20995: LD_VAR 0 7
20999: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21000: LD_INT 0
21002: PPUSH
21003: PPUSH
21004: PPUSH
21005: PPUSH
21006: PPUSH
21007: PPUSH
21008: PPUSH
21009: PPUSH
21010: PPUSH
21011: PPUSH
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
21016: PPUSH
21017: PPUSH
// result := false ;
21018: LD_ADDR_VAR 0 3
21022: PUSH
21023: LD_INT 0
21025: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21026: LD_VAR 0 1
21030: NOT
21031: PUSH
21032: LD_VAR 0 1
21036: PPUSH
21037: CALL_OW 266
21041: PUSH
21042: LD_INT 32
21044: PUSH
21045: LD_INT 33
21047: PUSH
21048: EMPTY
21049: LIST
21050: LIST
21051: IN
21052: NOT
21053: OR
21054: IFFALSE 21058
// exit ;
21056: GO 22167
// nat := GetNation ( tower ) ;
21058: LD_ADDR_VAR 0 12
21062: PUSH
21063: LD_VAR 0 1
21067: PPUSH
21068: CALL_OW 248
21072: ST_TO_ADDR
// side := GetSide ( tower ) ;
21073: LD_ADDR_VAR 0 16
21077: PUSH
21078: LD_VAR 0 1
21082: PPUSH
21083: CALL_OW 255
21087: ST_TO_ADDR
// x := GetX ( tower ) ;
21088: LD_ADDR_VAR 0 10
21092: PUSH
21093: LD_VAR 0 1
21097: PPUSH
21098: CALL_OW 250
21102: ST_TO_ADDR
// y := GetY ( tower ) ;
21103: LD_ADDR_VAR 0 11
21107: PUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 251
21117: ST_TO_ADDR
// if not x or not y then
21118: LD_VAR 0 10
21122: NOT
21123: PUSH
21124: LD_VAR 0 11
21128: NOT
21129: OR
21130: IFFALSE 21134
// exit ;
21132: GO 22167
// weapon := 0 ;
21134: LD_ADDR_VAR 0 18
21138: PUSH
21139: LD_INT 0
21141: ST_TO_ADDR
// fac_list := [ ] ;
21142: LD_ADDR_VAR 0 17
21146: PUSH
21147: EMPTY
21148: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21149: LD_ADDR_VAR 0 6
21153: PUSH
21154: LD_VAR 0 1
21158: PPUSH
21159: CALL_OW 274
21163: PPUSH
21164: LD_VAR 0 2
21168: PPUSH
21169: LD_INT 0
21171: PPUSH
21172: CALL 18738 0 3
21176: PPUSH
21177: LD_INT 30
21179: PUSH
21180: LD_INT 3
21182: PUSH
21183: EMPTY
21184: LIST
21185: LIST
21186: PPUSH
21187: CALL_OW 72
21191: ST_TO_ADDR
// if not factories then
21192: LD_VAR 0 6
21196: NOT
21197: IFFALSE 21201
// exit ;
21199: GO 22167
// for i in factories do
21201: LD_ADDR_VAR 0 8
21205: PUSH
21206: LD_VAR 0 6
21210: PUSH
21211: FOR_IN
21212: IFFALSE 21237
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21214: LD_ADDR_VAR 0 17
21218: PUSH
21219: LD_VAR 0 17
21223: PUSH
21224: LD_VAR 0 8
21228: PPUSH
21229: CALL_OW 478
21233: UNION
21234: ST_TO_ADDR
21235: GO 21211
21237: POP
21238: POP
// if not fac_list then
21239: LD_VAR 0 17
21243: NOT
21244: IFFALSE 21248
// exit ;
21246: GO 22167
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21248: LD_ADDR_VAR 0 5
21252: PUSH
21253: LD_INT 4
21255: PUSH
21256: LD_INT 5
21258: PUSH
21259: LD_INT 9
21261: PUSH
21262: LD_INT 10
21264: PUSH
21265: LD_INT 6
21267: PUSH
21268: LD_INT 7
21270: PUSH
21271: LD_INT 11
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 27
21285: PUSH
21286: LD_INT 28
21288: PUSH
21289: LD_INT 26
21291: PUSH
21292: LD_INT 30
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: PUSH
21301: LD_INT 43
21303: PUSH
21304: LD_INT 44
21306: PUSH
21307: LD_INT 46
21309: PUSH
21310: LD_INT 45
21312: PUSH
21313: LD_INT 47
21315: PUSH
21316: LD_INT 49
21318: PUSH
21319: EMPTY
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: LIST
21331: PUSH
21332: LD_VAR 0 12
21336: ARRAY
21337: ST_TO_ADDR
// list := list isect fac_list ;
21338: LD_ADDR_VAR 0 5
21342: PUSH
21343: LD_VAR 0 5
21347: PUSH
21348: LD_VAR 0 17
21352: ISECT
21353: ST_TO_ADDR
// if not list then
21354: LD_VAR 0 5
21358: NOT
21359: IFFALSE 21363
// exit ;
21361: GO 22167
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21363: LD_VAR 0 12
21367: PUSH
21368: LD_INT 3
21370: EQUAL
21371: PUSH
21372: LD_INT 49
21374: PUSH
21375: LD_VAR 0 5
21379: IN
21380: AND
21381: PUSH
21382: LD_INT 31
21384: PPUSH
21385: LD_VAR 0 16
21389: PPUSH
21390: CALL_OW 321
21394: PUSH
21395: LD_INT 2
21397: EQUAL
21398: AND
21399: IFFALSE 21459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21401: LD_INT 22
21403: PUSH
21404: LD_VAR 0 16
21408: PUSH
21409: EMPTY
21410: LIST
21411: LIST
21412: PUSH
21413: LD_INT 35
21415: PUSH
21416: LD_INT 49
21418: PUSH
21419: EMPTY
21420: LIST
21421: LIST
21422: PUSH
21423: LD_INT 91
21425: PUSH
21426: LD_VAR 0 1
21430: PUSH
21431: LD_INT 10
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: LIST
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: LIST
21443: PPUSH
21444: CALL_OW 69
21448: NOT
21449: IFFALSE 21459
// weapon := ru_time_lapser ;
21451: LD_ADDR_VAR 0 18
21455: PUSH
21456: LD_INT 49
21458: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21459: LD_VAR 0 12
21463: PUSH
21464: LD_INT 1
21466: PUSH
21467: LD_INT 2
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: IN
21474: PUSH
21475: LD_INT 11
21477: PUSH
21478: LD_VAR 0 5
21482: IN
21483: PUSH
21484: LD_INT 30
21486: PUSH
21487: LD_VAR 0 5
21491: IN
21492: OR
21493: AND
21494: PUSH
21495: LD_INT 6
21497: PPUSH
21498: LD_VAR 0 16
21502: PPUSH
21503: CALL_OW 321
21507: PUSH
21508: LD_INT 2
21510: EQUAL
21511: AND
21512: IFFALSE 21677
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21514: LD_INT 22
21516: PUSH
21517: LD_VAR 0 16
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: PUSH
21526: LD_INT 2
21528: PUSH
21529: LD_INT 35
21531: PUSH
21532: LD_INT 11
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 35
21541: PUSH
21542: LD_INT 30
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: LIST
21553: PUSH
21554: LD_INT 91
21556: PUSH
21557: LD_VAR 0 1
21561: PUSH
21562: LD_INT 18
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: LIST
21569: PUSH
21570: EMPTY
21571: LIST
21572: LIST
21573: LIST
21574: PPUSH
21575: CALL_OW 69
21579: NOT
21580: PUSH
21581: LD_INT 22
21583: PUSH
21584: LD_VAR 0 16
21588: PUSH
21589: EMPTY
21590: LIST
21591: LIST
21592: PUSH
21593: LD_INT 2
21595: PUSH
21596: LD_INT 30
21598: PUSH
21599: LD_INT 32
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: PUSH
21606: LD_INT 30
21608: PUSH
21609: LD_INT 33
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: PUSH
21616: EMPTY
21617: LIST
21618: LIST
21619: LIST
21620: PUSH
21621: LD_INT 91
21623: PUSH
21624: LD_VAR 0 1
21628: PUSH
21629: LD_INT 12
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: LIST
21636: PUSH
21637: EMPTY
21638: LIST
21639: LIST
21640: LIST
21641: PUSH
21642: EMPTY
21643: LIST
21644: PPUSH
21645: CALL_OW 69
21649: PUSH
21650: LD_INT 2
21652: GREATER
21653: AND
21654: IFFALSE 21677
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21656: LD_ADDR_VAR 0 18
21660: PUSH
21661: LD_INT 11
21663: PUSH
21664: LD_INT 30
21666: PUSH
21667: EMPTY
21668: LIST
21669: LIST
21670: PUSH
21671: LD_VAR 0 12
21675: ARRAY
21676: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21677: LD_VAR 0 18
21681: NOT
21682: PUSH
21683: LD_INT 40
21685: PPUSH
21686: LD_VAR 0 16
21690: PPUSH
21691: CALL_OW 321
21695: PUSH
21696: LD_INT 2
21698: EQUAL
21699: AND
21700: PUSH
21701: LD_INT 7
21703: PUSH
21704: LD_VAR 0 5
21708: IN
21709: PUSH
21710: LD_INT 28
21712: PUSH
21713: LD_VAR 0 5
21717: IN
21718: OR
21719: PUSH
21720: LD_INT 45
21722: PUSH
21723: LD_VAR 0 5
21727: IN
21728: OR
21729: AND
21730: IFFALSE 21984
// begin hex := GetHexInfo ( x , y ) ;
21732: LD_ADDR_VAR 0 4
21736: PUSH
21737: LD_VAR 0 10
21741: PPUSH
21742: LD_VAR 0 11
21746: PPUSH
21747: CALL_OW 546
21751: ST_TO_ADDR
// if hex [ 1 ] then
21752: LD_VAR 0 4
21756: PUSH
21757: LD_INT 1
21759: ARRAY
21760: IFFALSE 21764
// exit ;
21762: GO 22167
// height := hex [ 2 ] ;
21764: LD_ADDR_VAR 0 15
21768: PUSH
21769: LD_VAR 0 4
21773: PUSH
21774: LD_INT 2
21776: ARRAY
21777: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21778: LD_ADDR_VAR 0 14
21782: PUSH
21783: LD_INT 0
21785: PUSH
21786: LD_INT 2
21788: PUSH
21789: LD_INT 3
21791: PUSH
21792: LD_INT 5
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: ST_TO_ADDR
// for i in tmp do
21801: LD_ADDR_VAR 0 8
21805: PUSH
21806: LD_VAR 0 14
21810: PUSH
21811: FOR_IN
21812: IFFALSE 21982
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21814: LD_ADDR_VAR 0 9
21818: PUSH
21819: LD_VAR 0 10
21823: PPUSH
21824: LD_VAR 0 8
21828: PPUSH
21829: LD_INT 5
21831: PPUSH
21832: CALL_OW 272
21836: PUSH
21837: LD_VAR 0 11
21841: PPUSH
21842: LD_VAR 0 8
21846: PPUSH
21847: LD_INT 5
21849: PPUSH
21850: CALL_OW 273
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21859: LD_VAR 0 9
21863: PUSH
21864: LD_INT 1
21866: ARRAY
21867: PPUSH
21868: LD_VAR 0 9
21872: PUSH
21873: LD_INT 2
21875: ARRAY
21876: PPUSH
21877: CALL_OW 488
21881: IFFALSE 21980
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
21883: LD_ADDR_VAR 0 4
21887: PUSH
21888: LD_VAR 0 9
21892: PUSH
21893: LD_INT 1
21895: ARRAY
21896: PPUSH
21897: LD_VAR 0 9
21901: PUSH
21902: LD_INT 2
21904: ARRAY
21905: PPUSH
21906: CALL_OW 546
21910: ST_TO_ADDR
// if hex [ 1 ] then
21911: LD_VAR 0 4
21915: PUSH
21916: LD_INT 1
21918: ARRAY
21919: IFFALSE 21923
// continue ;
21921: GO 21811
// h := hex [ 2 ] ;
21923: LD_ADDR_VAR 0 13
21927: PUSH
21928: LD_VAR 0 4
21932: PUSH
21933: LD_INT 2
21935: ARRAY
21936: ST_TO_ADDR
// if h + 7 < height then
21937: LD_VAR 0 13
21941: PUSH
21942: LD_INT 7
21944: PLUS
21945: PUSH
21946: LD_VAR 0 15
21950: LESS
21951: IFFALSE 21980
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
21953: LD_ADDR_VAR 0 18
21957: PUSH
21958: LD_INT 7
21960: PUSH
21961: LD_INT 28
21963: PUSH
21964: LD_INT 45
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: LIST
21971: PUSH
21972: LD_VAR 0 12
21976: ARRAY
21977: ST_TO_ADDR
// break ;
21978: GO 21982
// end ; end ; end ;
21980: GO 21811
21982: POP
21983: POP
// end ; if not weapon then
21984: LD_VAR 0 18
21988: NOT
21989: IFFALSE 22049
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
21991: LD_ADDR_VAR 0 5
21995: PUSH
21996: LD_VAR 0 5
22000: PUSH
22001: LD_INT 11
22003: PUSH
22004: LD_INT 30
22006: PUSH
22007: LD_INT 49
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: LIST
22014: DIFF
22015: ST_TO_ADDR
// if not list then
22016: LD_VAR 0 5
22020: NOT
22021: IFFALSE 22025
// exit ;
22023: GO 22167
// weapon := list [ rand ( 1 , list ) ] ;
22025: LD_ADDR_VAR 0 18
22029: PUSH
22030: LD_VAR 0 5
22034: PUSH
22035: LD_INT 1
22037: PPUSH
22038: LD_VAR 0 5
22042: PPUSH
22043: CALL_OW 12
22047: ARRAY
22048: ST_TO_ADDR
// end ; if weapon then
22049: LD_VAR 0 18
22053: IFFALSE 22167
// begin tmp := CostOfWeapon ( weapon ) ;
22055: LD_ADDR_VAR 0 14
22059: PUSH
22060: LD_VAR 0 18
22064: PPUSH
22065: CALL_OW 451
22069: ST_TO_ADDR
// j := GetBase ( tower ) ;
22070: LD_ADDR_VAR 0 9
22074: PUSH
22075: LD_VAR 0 1
22079: PPUSH
22080: CALL_OW 274
22084: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22085: LD_VAR 0 9
22089: PPUSH
22090: LD_INT 1
22092: PPUSH
22093: CALL_OW 275
22097: PUSH
22098: LD_VAR 0 14
22102: PUSH
22103: LD_INT 1
22105: ARRAY
22106: GREATEREQUAL
22107: PUSH
22108: LD_VAR 0 9
22112: PPUSH
22113: LD_INT 2
22115: PPUSH
22116: CALL_OW 275
22120: PUSH
22121: LD_VAR 0 14
22125: PUSH
22126: LD_INT 2
22128: ARRAY
22129: GREATEREQUAL
22130: AND
22131: PUSH
22132: LD_VAR 0 9
22136: PPUSH
22137: LD_INT 3
22139: PPUSH
22140: CALL_OW 275
22144: PUSH
22145: LD_VAR 0 14
22149: PUSH
22150: LD_INT 3
22152: ARRAY
22153: GREATEREQUAL
22154: AND
22155: IFFALSE 22167
// result := weapon ;
22157: LD_ADDR_VAR 0 3
22161: PUSH
22162: LD_VAR 0 18
22166: ST_TO_ADDR
// end ; end ;
22167: LD_VAR 0 3
22171: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22172: LD_INT 0
22174: PPUSH
22175: PPUSH
// result := true ;
22176: LD_ADDR_VAR 0 3
22180: PUSH
22181: LD_INT 1
22183: ST_TO_ADDR
// if array1 = array2 then
22184: LD_VAR 0 1
22188: PUSH
22189: LD_VAR 0 2
22193: EQUAL
22194: IFFALSE 22254
// begin for i = 1 to array1 do
22196: LD_ADDR_VAR 0 4
22200: PUSH
22201: DOUBLE
22202: LD_INT 1
22204: DEC
22205: ST_TO_ADDR
22206: LD_VAR 0 1
22210: PUSH
22211: FOR_TO
22212: IFFALSE 22250
// if array1 [ i ] <> array2 [ i ] then
22214: LD_VAR 0 1
22218: PUSH
22219: LD_VAR 0 4
22223: ARRAY
22224: PUSH
22225: LD_VAR 0 2
22229: PUSH
22230: LD_VAR 0 4
22234: ARRAY
22235: NONEQUAL
22236: IFFALSE 22248
// begin result := false ;
22238: LD_ADDR_VAR 0 3
22242: PUSH
22243: LD_INT 0
22245: ST_TO_ADDR
// break ;
22246: GO 22250
// end ;
22248: GO 22211
22250: POP
22251: POP
// end else
22252: GO 22262
// result := false ;
22254: LD_ADDR_VAR 0 3
22258: PUSH
22259: LD_INT 0
22261: ST_TO_ADDR
// end ;
22262: LD_VAR 0 3
22266: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22267: LD_INT 0
22269: PPUSH
22270: PPUSH
// if not array1 or not array2 then
22271: LD_VAR 0 1
22275: NOT
22276: PUSH
22277: LD_VAR 0 2
22281: NOT
22282: OR
22283: IFFALSE 22287
// exit ;
22285: GO 22351
// result := true ;
22287: LD_ADDR_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ST_TO_ADDR
// for i = 1 to array1 do
22295: LD_ADDR_VAR 0 4
22299: PUSH
22300: DOUBLE
22301: LD_INT 1
22303: DEC
22304: ST_TO_ADDR
22305: LD_VAR 0 1
22309: PUSH
22310: FOR_TO
22311: IFFALSE 22349
// if array1 [ i ] <> array2 [ i ] then
22313: LD_VAR 0 1
22317: PUSH
22318: LD_VAR 0 4
22322: ARRAY
22323: PUSH
22324: LD_VAR 0 2
22328: PUSH
22329: LD_VAR 0 4
22333: ARRAY
22334: NONEQUAL
22335: IFFALSE 22347
// begin result := false ;
22337: LD_ADDR_VAR 0 3
22341: PUSH
22342: LD_INT 0
22344: ST_TO_ADDR
// break ;
22345: GO 22349
// end ;
22347: GO 22310
22349: POP
22350: POP
// end ;
22351: LD_VAR 0 3
22355: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22356: LD_INT 0
22358: PPUSH
22359: PPUSH
22360: PPUSH
// pom := GetBase ( fac ) ;
22361: LD_ADDR_VAR 0 5
22365: PUSH
22366: LD_VAR 0 1
22370: PPUSH
22371: CALL_OW 274
22375: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22376: LD_ADDR_VAR 0 4
22380: PUSH
22381: LD_VAR 0 2
22385: PUSH
22386: LD_INT 1
22388: ARRAY
22389: PPUSH
22390: LD_VAR 0 2
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: PPUSH
22399: LD_VAR 0 2
22403: PUSH
22404: LD_INT 3
22406: ARRAY
22407: PPUSH
22408: LD_VAR 0 2
22412: PUSH
22413: LD_INT 4
22415: ARRAY
22416: PPUSH
22417: CALL_OW 449
22421: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22422: LD_ADDR_VAR 0 3
22426: PUSH
22427: LD_VAR 0 5
22431: PPUSH
22432: LD_INT 1
22434: PPUSH
22435: CALL_OW 275
22439: PUSH
22440: LD_VAR 0 4
22444: PUSH
22445: LD_INT 1
22447: ARRAY
22448: GREATEREQUAL
22449: PUSH
22450: LD_VAR 0 5
22454: PPUSH
22455: LD_INT 2
22457: PPUSH
22458: CALL_OW 275
22462: PUSH
22463: LD_VAR 0 4
22467: PUSH
22468: LD_INT 2
22470: ARRAY
22471: GREATEREQUAL
22472: AND
22473: PUSH
22474: LD_VAR 0 5
22478: PPUSH
22479: LD_INT 3
22481: PPUSH
22482: CALL_OW 275
22486: PUSH
22487: LD_VAR 0 4
22491: PUSH
22492: LD_INT 3
22494: ARRAY
22495: GREATEREQUAL
22496: AND
22497: ST_TO_ADDR
// end ;
22498: LD_VAR 0 3
22502: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22503: LD_INT 0
22505: PPUSH
22506: PPUSH
22507: PPUSH
22508: PPUSH
// pom := GetBase ( building ) ;
22509: LD_ADDR_VAR 0 3
22513: PUSH
22514: LD_VAR 0 1
22518: PPUSH
22519: CALL_OW 274
22523: ST_TO_ADDR
// if not pom then
22524: LD_VAR 0 3
22528: NOT
22529: IFFALSE 22533
// exit ;
22531: GO 22703
// btype := GetBType ( building ) ;
22533: LD_ADDR_VAR 0 5
22537: PUSH
22538: LD_VAR 0 1
22542: PPUSH
22543: CALL_OW 266
22547: ST_TO_ADDR
// if btype = b_armoury then
22548: LD_VAR 0 5
22552: PUSH
22553: LD_INT 4
22555: EQUAL
22556: IFFALSE 22566
// btype := b_barracks ;
22558: LD_ADDR_VAR 0 5
22562: PUSH
22563: LD_INT 5
22565: ST_TO_ADDR
// if btype = b_depot then
22566: LD_VAR 0 5
22570: PUSH
22571: LD_INT 0
22573: EQUAL
22574: IFFALSE 22584
// btype := b_warehouse ;
22576: LD_ADDR_VAR 0 5
22580: PUSH
22581: LD_INT 1
22583: ST_TO_ADDR
// if btype = b_workshop then
22584: LD_VAR 0 5
22588: PUSH
22589: LD_INT 2
22591: EQUAL
22592: IFFALSE 22602
// btype := b_factory ;
22594: LD_ADDR_VAR 0 5
22598: PUSH
22599: LD_INT 3
22601: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22602: LD_ADDR_VAR 0 4
22606: PUSH
22607: LD_VAR 0 5
22611: PPUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 248
22621: PPUSH
22622: CALL_OW 450
22626: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22627: LD_ADDR_VAR 0 2
22631: PUSH
22632: LD_VAR 0 3
22636: PPUSH
22637: LD_INT 1
22639: PPUSH
22640: CALL_OW 275
22644: PUSH
22645: LD_VAR 0 4
22649: PUSH
22650: LD_INT 1
22652: ARRAY
22653: GREATEREQUAL
22654: PUSH
22655: LD_VAR 0 3
22659: PPUSH
22660: LD_INT 2
22662: PPUSH
22663: CALL_OW 275
22667: PUSH
22668: LD_VAR 0 4
22672: PUSH
22673: LD_INT 2
22675: ARRAY
22676: GREATEREQUAL
22677: AND
22678: PUSH
22679: LD_VAR 0 3
22683: PPUSH
22684: LD_INT 3
22686: PPUSH
22687: CALL_OW 275
22691: PUSH
22692: LD_VAR 0 4
22696: PUSH
22697: LD_INT 3
22699: ARRAY
22700: GREATEREQUAL
22701: AND
22702: ST_TO_ADDR
// end ;
22703: LD_VAR 0 2
22707: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22708: LD_INT 0
22710: PPUSH
22711: PPUSH
22712: PPUSH
// pom := GetBase ( building ) ;
22713: LD_ADDR_VAR 0 4
22717: PUSH
22718: LD_VAR 0 1
22722: PPUSH
22723: CALL_OW 274
22727: ST_TO_ADDR
// if not pom then
22728: LD_VAR 0 4
22732: NOT
22733: IFFALSE 22737
// exit ;
22735: GO 22838
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22737: LD_ADDR_VAR 0 5
22741: PUSH
22742: LD_VAR 0 2
22746: PPUSH
22747: LD_VAR 0 1
22751: PPUSH
22752: CALL_OW 248
22756: PPUSH
22757: CALL_OW 450
22761: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22762: LD_ADDR_VAR 0 3
22766: PUSH
22767: LD_VAR 0 4
22771: PPUSH
22772: LD_INT 1
22774: PPUSH
22775: CALL_OW 275
22779: PUSH
22780: LD_VAR 0 5
22784: PUSH
22785: LD_INT 1
22787: ARRAY
22788: GREATEREQUAL
22789: PUSH
22790: LD_VAR 0 4
22794: PPUSH
22795: LD_INT 2
22797: PPUSH
22798: CALL_OW 275
22802: PUSH
22803: LD_VAR 0 5
22807: PUSH
22808: LD_INT 2
22810: ARRAY
22811: GREATEREQUAL
22812: AND
22813: PUSH
22814: LD_VAR 0 4
22818: PPUSH
22819: LD_INT 3
22821: PPUSH
22822: CALL_OW 275
22826: PUSH
22827: LD_VAR 0 5
22831: PUSH
22832: LD_INT 3
22834: ARRAY
22835: GREATEREQUAL
22836: AND
22837: ST_TO_ADDR
// end ;
22838: LD_VAR 0 3
22842: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22843: LD_INT 0
22845: PPUSH
22846: PPUSH
22847: PPUSH
22848: PPUSH
22849: PPUSH
22850: PPUSH
22851: PPUSH
22852: PPUSH
22853: PPUSH
22854: PPUSH
22855: PPUSH
// result := false ;
22856: LD_ADDR_VAR 0 8
22860: PUSH
22861: LD_INT 0
22863: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22864: LD_VAR 0 5
22868: NOT
22869: PUSH
22870: LD_VAR 0 1
22874: NOT
22875: OR
22876: PUSH
22877: LD_VAR 0 2
22881: NOT
22882: OR
22883: PUSH
22884: LD_VAR 0 3
22888: NOT
22889: OR
22890: IFFALSE 22894
// exit ;
22892: GO 23708
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
22894: LD_ADDR_VAR 0 14
22898: PUSH
22899: LD_VAR 0 1
22903: PPUSH
22904: LD_VAR 0 2
22908: PPUSH
22909: LD_VAR 0 3
22913: PPUSH
22914: LD_VAR 0 4
22918: PPUSH
22919: LD_VAR 0 5
22923: PUSH
22924: LD_INT 1
22926: ARRAY
22927: PPUSH
22928: CALL_OW 248
22932: PPUSH
22933: LD_INT 0
22935: PPUSH
22936: CALL 24945 0 6
22940: ST_TO_ADDR
// if not hexes then
22941: LD_VAR 0 14
22945: NOT
22946: IFFALSE 22950
// exit ;
22948: GO 23708
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22950: LD_ADDR_VAR 0 17
22954: PUSH
22955: LD_VAR 0 5
22959: PPUSH
22960: LD_INT 22
22962: PUSH
22963: LD_VAR 0 13
22967: PPUSH
22968: CALL_OW 255
22972: PUSH
22973: EMPTY
22974: LIST
22975: LIST
22976: PUSH
22977: LD_INT 2
22979: PUSH
22980: LD_INT 30
22982: PUSH
22983: LD_INT 0
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PUSH
22990: LD_INT 30
22992: PUSH
22993: LD_INT 1
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: LIST
23004: PUSH
23005: EMPTY
23006: LIST
23007: LIST
23008: PPUSH
23009: CALL_OW 72
23013: ST_TO_ADDR
// for i = 1 to hexes do
23014: LD_ADDR_VAR 0 9
23018: PUSH
23019: DOUBLE
23020: LD_INT 1
23022: DEC
23023: ST_TO_ADDR
23024: LD_VAR 0 14
23028: PUSH
23029: FOR_TO
23030: IFFALSE 23706
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23032: LD_ADDR_VAR 0 13
23036: PUSH
23037: LD_VAR 0 14
23041: PUSH
23042: LD_VAR 0 9
23046: ARRAY
23047: PUSH
23048: LD_INT 1
23050: ARRAY
23051: PPUSH
23052: LD_VAR 0 14
23056: PUSH
23057: LD_VAR 0 9
23061: ARRAY
23062: PUSH
23063: LD_INT 2
23065: ARRAY
23066: PPUSH
23067: CALL_OW 428
23071: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23072: LD_VAR 0 14
23076: PUSH
23077: LD_VAR 0 9
23081: ARRAY
23082: PUSH
23083: LD_INT 1
23085: ARRAY
23086: PPUSH
23087: LD_VAR 0 14
23091: PUSH
23092: LD_VAR 0 9
23096: ARRAY
23097: PUSH
23098: LD_INT 2
23100: ARRAY
23101: PPUSH
23102: CALL_OW 351
23106: PUSH
23107: LD_VAR 0 14
23111: PUSH
23112: LD_VAR 0 9
23116: ARRAY
23117: PUSH
23118: LD_INT 1
23120: ARRAY
23121: PPUSH
23122: LD_VAR 0 14
23126: PUSH
23127: LD_VAR 0 9
23131: ARRAY
23132: PUSH
23133: LD_INT 2
23135: ARRAY
23136: PPUSH
23137: CALL_OW 488
23141: NOT
23142: OR
23143: PUSH
23144: LD_VAR 0 13
23148: PPUSH
23149: CALL_OW 247
23153: PUSH
23154: LD_INT 3
23156: EQUAL
23157: OR
23158: IFFALSE 23164
// exit ;
23160: POP
23161: POP
23162: GO 23708
// if not tmp then
23164: LD_VAR 0 13
23168: NOT
23169: IFFALSE 23173
// continue ;
23171: GO 23029
// result := true ;
23173: LD_ADDR_VAR 0 8
23177: PUSH
23178: LD_INT 1
23180: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23181: LD_VAR 0 6
23185: PUSH
23186: LD_VAR 0 13
23190: PPUSH
23191: CALL_OW 247
23195: PUSH
23196: LD_INT 2
23198: EQUAL
23199: AND
23200: PUSH
23201: LD_VAR 0 13
23205: PPUSH
23206: CALL_OW 263
23210: PUSH
23211: LD_INT 1
23213: EQUAL
23214: AND
23215: IFFALSE 23379
// begin if IsDrivenBy ( tmp ) then
23217: LD_VAR 0 13
23221: PPUSH
23222: CALL_OW 311
23226: IFFALSE 23230
// continue ;
23228: GO 23029
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23230: LD_VAR 0 6
23234: PPUSH
23235: LD_INT 3
23237: PUSH
23238: LD_INT 60
23240: PUSH
23241: EMPTY
23242: LIST
23243: PUSH
23244: EMPTY
23245: LIST
23246: LIST
23247: PUSH
23248: LD_INT 3
23250: PUSH
23251: LD_INT 55
23253: PUSH
23254: EMPTY
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PPUSH
23265: CALL_OW 72
23269: IFFALSE 23377
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23271: LD_ADDR_VAR 0 18
23275: PUSH
23276: LD_VAR 0 6
23280: PPUSH
23281: LD_INT 3
23283: PUSH
23284: LD_INT 60
23286: PUSH
23287: EMPTY
23288: LIST
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 3
23296: PUSH
23297: LD_INT 55
23299: PUSH
23300: EMPTY
23301: LIST
23302: PUSH
23303: EMPTY
23304: LIST
23305: LIST
23306: PUSH
23307: EMPTY
23308: LIST
23309: LIST
23310: PPUSH
23311: CALL_OW 72
23315: PUSH
23316: LD_INT 1
23318: ARRAY
23319: ST_TO_ADDR
// if IsInUnit ( driver ) then
23320: LD_VAR 0 18
23324: PPUSH
23325: CALL_OW 310
23329: IFFALSE 23340
// ComExit ( driver ) ;
23331: LD_VAR 0 18
23335: PPUSH
23336: CALL 48129 0 1
// AddComEnterUnit ( driver , tmp ) ;
23340: LD_VAR 0 18
23344: PPUSH
23345: LD_VAR 0 13
23349: PPUSH
23350: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23354: LD_VAR 0 18
23358: PPUSH
23359: LD_VAR 0 7
23363: PPUSH
23364: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23368: LD_VAR 0 18
23372: PPUSH
23373: CALL_OW 181
// end ; continue ;
23377: GO 23029
// end ; if not cleaners or not tmp in cleaners then
23379: LD_VAR 0 6
23383: NOT
23384: PUSH
23385: LD_VAR 0 13
23389: PUSH
23390: LD_VAR 0 6
23394: IN
23395: NOT
23396: OR
23397: IFFALSE 23704
// begin if dep then
23399: LD_VAR 0 17
23403: IFFALSE 23539
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23405: LD_ADDR_VAR 0 16
23409: PUSH
23410: LD_VAR 0 17
23414: PUSH
23415: LD_INT 1
23417: ARRAY
23418: PPUSH
23419: CALL_OW 250
23423: PPUSH
23424: LD_VAR 0 17
23428: PUSH
23429: LD_INT 1
23431: ARRAY
23432: PPUSH
23433: CALL_OW 254
23437: PPUSH
23438: LD_INT 5
23440: PPUSH
23441: CALL_OW 272
23445: PUSH
23446: LD_VAR 0 17
23450: PUSH
23451: LD_INT 1
23453: ARRAY
23454: PPUSH
23455: CALL_OW 251
23459: PPUSH
23460: LD_VAR 0 17
23464: PUSH
23465: LD_INT 1
23467: ARRAY
23468: PPUSH
23469: CALL_OW 254
23473: PPUSH
23474: LD_INT 5
23476: PPUSH
23477: CALL_OW 273
23481: PUSH
23482: EMPTY
23483: LIST
23484: LIST
23485: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23486: LD_VAR 0 16
23490: PUSH
23491: LD_INT 1
23493: ARRAY
23494: PPUSH
23495: LD_VAR 0 16
23499: PUSH
23500: LD_INT 2
23502: ARRAY
23503: PPUSH
23504: CALL_OW 488
23508: IFFALSE 23539
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23510: LD_VAR 0 13
23514: PPUSH
23515: LD_VAR 0 16
23519: PUSH
23520: LD_INT 1
23522: ARRAY
23523: PPUSH
23524: LD_VAR 0 16
23528: PUSH
23529: LD_INT 2
23531: ARRAY
23532: PPUSH
23533: CALL_OW 111
// continue ;
23537: GO 23029
// end ; end ; r := GetDir ( tmp ) ;
23539: LD_ADDR_VAR 0 15
23543: PUSH
23544: LD_VAR 0 13
23548: PPUSH
23549: CALL_OW 254
23553: ST_TO_ADDR
// if r = 5 then
23554: LD_VAR 0 15
23558: PUSH
23559: LD_INT 5
23561: EQUAL
23562: IFFALSE 23572
// r := 0 ;
23564: LD_ADDR_VAR 0 15
23568: PUSH
23569: LD_INT 0
23571: ST_TO_ADDR
// for j = r to 5 do
23572: LD_ADDR_VAR 0 10
23576: PUSH
23577: DOUBLE
23578: LD_VAR 0 15
23582: DEC
23583: ST_TO_ADDR
23584: LD_INT 5
23586: PUSH
23587: FOR_TO
23588: IFFALSE 23702
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23590: LD_ADDR_VAR 0 11
23594: PUSH
23595: LD_VAR 0 13
23599: PPUSH
23600: CALL_OW 250
23604: PPUSH
23605: LD_VAR 0 10
23609: PPUSH
23610: LD_INT 2
23612: PPUSH
23613: CALL_OW 272
23617: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23618: LD_ADDR_VAR 0 12
23622: PUSH
23623: LD_VAR 0 13
23627: PPUSH
23628: CALL_OW 251
23632: PPUSH
23633: LD_VAR 0 10
23637: PPUSH
23638: LD_INT 2
23640: PPUSH
23641: CALL_OW 273
23645: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23646: LD_VAR 0 11
23650: PPUSH
23651: LD_VAR 0 12
23655: PPUSH
23656: CALL_OW 488
23660: PUSH
23661: LD_VAR 0 11
23665: PPUSH
23666: LD_VAR 0 12
23670: PPUSH
23671: CALL_OW 428
23675: NOT
23676: AND
23677: IFFALSE 23700
// begin ComMoveXY ( tmp , _x , _y ) ;
23679: LD_VAR 0 13
23683: PPUSH
23684: LD_VAR 0 11
23688: PPUSH
23689: LD_VAR 0 12
23693: PPUSH
23694: CALL_OW 111
// break ;
23698: GO 23702
// end ; end ;
23700: GO 23587
23702: POP
23703: POP
// end ; end ;
23704: GO 23029
23706: POP
23707: POP
// end ;
23708: LD_VAR 0 8
23712: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23713: LD_INT 0
23715: PPUSH
// result := true ;
23716: LD_ADDR_VAR 0 3
23720: PUSH
23721: LD_INT 1
23723: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23724: LD_VAR 0 2
23728: PUSH
23729: LD_INT 24
23731: DOUBLE
23732: EQUAL
23733: IFTRUE 23743
23735: LD_INT 33
23737: DOUBLE
23738: EQUAL
23739: IFTRUE 23743
23741: GO 23768
23743: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23744: LD_ADDR_VAR 0 3
23748: PUSH
23749: LD_INT 32
23751: PPUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 321
23761: PUSH
23762: LD_INT 2
23764: EQUAL
23765: ST_TO_ADDR
23766: GO 24088
23768: LD_INT 20
23770: DOUBLE
23771: EQUAL
23772: IFTRUE 23776
23774: GO 23801
23776: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23777: LD_ADDR_VAR 0 3
23781: PUSH
23782: LD_INT 6
23784: PPUSH
23785: LD_VAR 0 1
23789: PPUSH
23790: CALL_OW 321
23794: PUSH
23795: LD_INT 2
23797: EQUAL
23798: ST_TO_ADDR
23799: GO 24088
23801: LD_INT 22
23803: DOUBLE
23804: EQUAL
23805: IFTRUE 23815
23807: LD_INT 36
23809: DOUBLE
23810: EQUAL
23811: IFTRUE 23815
23813: GO 23840
23815: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23816: LD_ADDR_VAR 0 3
23820: PUSH
23821: LD_INT 15
23823: PPUSH
23824: LD_VAR 0 1
23828: PPUSH
23829: CALL_OW 321
23833: PUSH
23834: LD_INT 2
23836: EQUAL
23837: ST_TO_ADDR
23838: GO 24088
23840: LD_INT 30
23842: DOUBLE
23843: EQUAL
23844: IFTRUE 23848
23846: GO 23873
23848: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23849: LD_ADDR_VAR 0 3
23853: PUSH
23854: LD_INT 20
23856: PPUSH
23857: LD_VAR 0 1
23861: PPUSH
23862: CALL_OW 321
23866: PUSH
23867: LD_INT 2
23869: EQUAL
23870: ST_TO_ADDR
23871: GO 24088
23873: LD_INT 28
23875: DOUBLE
23876: EQUAL
23877: IFTRUE 23887
23879: LD_INT 21
23881: DOUBLE
23882: EQUAL
23883: IFTRUE 23887
23885: GO 23912
23887: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
23888: LD_ADDR_VAR 0 3
23892: PUSH
23893: LD_INT 21
23895: PPUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: CALL_OW 321
23905: PUSH
23906: LD_INT 2
23908: EQUAL
23909: ST_TO_ADDR
23910: GO 24088
23912: LD_INT 16
23914: DOUBLE
23915: EQUAL
23916: IFTRUE 23920
23918: GO 23947
23920: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
23921: LD_ADDR_VAR 0 3
23925: PUSH
23926: LD_EXP 79
23930: PPUSH
23931: LD_VAR 0 1
23935: PPUSH
23936: CALL_OW 321
23940: PUSH
23941: LD_INT 2
23943: EQUAL
23944: ST_TO_ADDR
23945: GO 24088
23947: LD_INT 19
23949: DOUBLE
23950: EQUAL
23951: IFTRUE 23961
23953: LD_INT 23
23955: DOUBLE
23956: EQUAL
23957: IFTRUE 23961
23959: GO 23988
23961: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
23962: LD_ADDR_VAR 0 3
23966: PUSH
23967: LD_EXP 78
23971: PPUSH
23972: LD_VAR 0 1
23976: PPUSH
23977: CALL_OW 321
23981: PUSH
23982: LD_INT 2
23984: EQUAL
23985: ST_TO_ADDR
23986: GO 24088
23988: LD_INT 17
23990: DOUBLE
23991: EQUAL
23992: IFTRUE 23996
23994: GO 24021
23996: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
23997: LD_ADDR_VAR 0 3
24001: PUSH
24002: LD_INT 39
24004: PPUSH
24005: LD_VAR 0 1
24009: PPUSH
24010: CALL_OW 321
24014: PUSH
24015: LD_INT 2
24017: EQUAL
24018: ST_TO_ADDR
24019: GO 24088
24021: LD_INT 18
24023: DOUBLE
24024: EQUAL
24025: IFTRUE 24029
24027: GO 24054
24029: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24030: LD_ADDR_VAR 0 3
24034: PUSH
24035: LD_INT 40
24037: PPUSH
24038: LD_VAR 0 1
24042: PPUSH
24043: CALL_OW 321
24047: PUSH
24048: LD_INT 2
24050: EQUAL
24051: ST_TO_ADDR
24052: GO 24088
24054: LD_INT 27
24056: DOUBLE
24057: EQUAL
24058: IFTRUE 24062
24060: GO 24087
24062: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24063: LD_ADDR_VAR 0 3
24067: PUSH
24068: LD_INT 35
24070: PPUSH
24071: LD_VAR 0 1
24075: PPUSH
24076: CALL_OW 321
24080: PUSH
24081: LD_INT 2
24083: EQUAL
24084: ST_TO_ADDR
24085: GO 24088
24087: POP
// end ;
24088: LD_VAR 0 3
24092: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24093: LD_INT 0
24095: PPUSH
24096: PPUSH
24097: PPUSH
24098: PPUSH
24099: PPUSH
24100: PPUSH
24101: PPUSH
24102: PPUSH
24103: PPUSH
24104: PPUSH
24105: PPUSH
// result := false ;
24106: LD_ADDR_VAR 0 6
24110: PUSH
24111: LD_INT 0
24113: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24114: LD_VAR 0 1
24118: NOT
24119: PUSH
24120: LD_VAR 0 1
24124: PPUSH
24125: CALL_OW 266
24129: PUSH
24130: LD_INT 0
24132: PUSH
24133: LD_INT 1
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: IN
24140: NOT
24141: OR
24142: PUSH
24143: LD_VAR 0 2
24147: NOT
24148: OR
24149: PUSH
24150: LD_VAR 0 5
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: LD_INT 1
24160: PUSH
24161: LD_INT 2
24163: PUSH
24164: LD_INT 3
24166: PUSH
24167: LD_INT 4
24169: PUSH
24170: LD_INT 5
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: IN
24181: NOT
24182: OR
24183: PUSH
24184: LD_VAR 0 3
24188: PPUSH
24189: LD_VAR 0 4
24193: PPUSH
24194: CALL_OW 488
24198: NOT
24199: OR
24200: IFFALSE 24204
// exit ;
24202: GO 24940
// side := GetSide ( depot ) ;
24204: LD_ADDR_VAR 0 9
24208: PUSH
24209: LD_VAR 0 1
24213: PPUSH
24214: CALL_OW 255
24218: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24219: LD_VAR 0 9
24223: PPUSH
24224: LD_VAR 0 2
24228: PPUSH
24229: CALL 23713 0 2
24233: NOT
24234: IFFALSE 24238
// exit ;
24236: GO 24940
// pom := GetBase ( depot ) ;
24238: LD_ADDR_VAR 0 10
24242: PUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: CALL_OW 274
24252: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24253: LD_ADDR_VAR 0 11
24257: PUSH
24258: LD_VAR 0 2
24262: PPUSH
24263: LD_VAR 0 1
24267: PPUSH
24268: CALL_OW 248
24272: PPUSH
24273: CALL_OW 450
24277: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24278: LD_VAR 0 10
24282: PPUSH
24283: LD_INT 1
24285: PPUSH
24286: CALL_OW 275
24290: PUSH
24291: LD_VAR 0 11
24295: PUSH
24296: LD_INT 1
24298: ARRAY
24299: GREATEREQUAL
24300: PUSH
24301: LD_VAR 0 10
24305: PPUSH
24306: LD_INT 2
24308: PPUSH
24309: CALL_OW 275
24313: PUSH
24314: LD_VAR 0 11
24318: PUSH
24319: LD_INT 2
24321: ARRAY
24322: GREATEREQUAL
24323: AND
24324: PUSH
24325: LD_VAR 0 10
24329: PPUSH
24330: LD_INT 3
24332: PPUSH
24333: CALL_OW 275
24337: PUSH
24338: LD_VAR 0 11
24342: PUSH
24343: LD_INT 3
24345: ARRAY
24346: GREATEREQUAL
24347: AND
24348: NOT
24349: IFFALSE 24353
// exit ;
24351: GO 24940
// if GetBType ( depot ) = b_depot then
24353: LD_VAR 0 1
24357: PPUSH
24358: CALL_OW 266
24362: PUSH
24363: LD_INT 0
24365: EQUAL
24366: IFFALSE 24378
// dist := 28 else
24368: LD_ADDR_VAR 0 14
24372: PUSH
24373: LD_INT 28
24375: ST_TO_ADDR
24376: GO 24386
// dist := 36 ;
24378: LD_ADDR_VAR 0 14
24382: PUSH
24383: LD_INT 36
24385: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24386: LD_VAR 0 1
24390: PPUSH
24391: LD_VAR 0 3
24395: PPUSH
24396: LD_VAR 0 4
24400: PPUSH
24401: CALL_OW 297
24405: PUSH
24406: LD_VAR 0 14
24410: GREATER
24411: IFFALSE 24415
// exit ;
24413: GO 24940
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24415: LD_ADDR_VAR 0 12
24419: PUSH
24420: LD_VAR 0 2
24424: PPUSH
24425: LD_VAR 0 3
24429: PPUSH
24430: LD_VAR 0 4
24434: PPUSH
24435: LD_VAR 0 5
24439: PPUSH
24440: LD_VAR 0 1
24444: PPUSH
24445: CALL_OW 248
24449: PPUSH
24450: LD_INT 0
24452: PPUSH
24453: CALL 24945 0 6
24457: ST_TO_ADDR
// if not hexes then
24458: LD_VAR 0 12
24462: NOT
24463: IFFALSE 24467
// exit ;
24465: GO 24940
// hex := GetHexInfo ( x , y ) ;
24467: LD_ADDR_VAR 0 15
24471: PUSH
24472: LD_VAR 0 3
24476: PPUSH
24477: LD_VAR 0 4
24481: PPUSH
24482: CALL_OW 546
24486: ST_TO_ADDR
// if hex [ 1 ] then
24487: LD_VAR 0 15
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: IFFALSE 24499
// exit ;
24497: GO 24940
// height := hex [ 2 ] ;
24499: LD_ADDR_VAR 0 13
24503: PUSH
24504: LD_VAR 0 15
24508: PUSH
24509: LD_INT 2
24511: ARRAY
24512: ST_TO_ADDR
// for i = 1 to hexes do
24513: LD_ADDR_VAR 0 7
24517: PUSH
24518: DOUBLE
24519: LD_INT 1
24521: DEC
24522: ST_TO_ADDR
24523: LD_VAR 0 12
24527: PUSH
24528: FOR_TO
24529: IFFALSE 24859
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24531: LD_VAR 0 12
24535: PUSH
24536: LD_VAR 0 7
24540: ARRAY
24541: PUSH
24542: LD_INT 1
24544: ARRAY
24545: PPUSH
24546: LD_VAR 0 12
24550: PUSH
24551: LD_VAR 0 7
24555: ARRAY
24556: PUSH
24557: LD_INT 2
24559: ARRAY
24560: PPUSH
24561: CALL_OW 488
24565: NOT
24566: PUSH
24567: LD_VAR 0 12
24571: PUSH
24572: LD_VAR 0 7
24576: ARRAY
24577: PUSH
24578: LD_INT 1
24580: ARRAY
24581: PPUSH
24582: LD_VAR 0 12
24586: PUSH
24587: LD_VAR 0 7
24591: ARRAY
24592: PUSH
24593: LD_INT 2
24595: ARRAY
24596: PPUSH
24597: CALL_OW 428
24601: PUSH
24602: LD_INT 0
24604: GREATER
24605: OR
24606: PUSH
24607: LD_VAR 0 12
24611: PUSH
24612: LD_VAR 0 7
24616: ARRAY
24617: PUSH
24618: LD_INT 1
24620: ARRAY
24621: PPUSH
24622: LD_VAR 0 12
24626: PUSH
24627: LD_VAR 0 7
24631: ARRAY
24632: PUSH
24633: LD_INT 2
24635: ARRAY
24636: PPUSH
24637: CALL_OW 351
24641: OR
24642: IFFALSE 24648
// exit ;
24644: POP
24645: POP
24646: GO 24940
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24648: LD_ADDR_VAR 0 8
24652: PUSH
24653: LD_VAR 0 12
24657: PUSH
24658: LD_VAR 0 7
24662: ARRAY
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PPUSH
24668: LD_VAR 0 12
24672: PUSH
24673: LD_VAR 0 7
24677: ARRAY
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PPUSH
24683: CALL_OW 546
24687: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24688: LD_VAR 0 8
24692: PUSH
24693: LD_INT 1
24695: ARRAY
24696: PUSH
24697: LD_VAR 0 8
24701: PUSH
24702: LD_INT 2
24704: ARRAY
24705: PUSH
24706: LD_VAR 0 13
24710: PUSH
24711: LD_INT 2
24713: PLUS
24714: GREATER
24715: OR
24716: PUSH
24717: LD_VAR 0 8
24721: PUSH
24722: LD_INT 2
24724: ARRAY
24725: PUSH
24726: LD_VAR 0 13
24730: PUSH
24731: LD_INT 2
24733: MINUS
24734: LESS
24735: OR
24736: PUSH
24737: LD_VAR 0 8
24741: PUSH
24742: LD_INT 3
24744: ARRAY
24745: PUSH
24746: LD_INT 0
24748: PUSH
24749: LD_INT 8
24751: PUSH
24752: LD_INT 9
24754: PUSH
24755: LD_INT 10
24757: PUSH
24758: LD_INT 11
24760: PUSH
24761: LD_INT 12
24763: PUSH
24764: LD_INT 13
24766: PUSH
24767: LD_INT 16
24769: PUSH
24770: LD_INT 17
24772: PUSH
24773: LD_INT 18
24775: PUSH
24776: LD_INT 19
24778: PUSH
24779: LD_INT 20
24781: PUSH
24782: LD_INT 21
24784: PUSH
24785: EMPTY
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: LIST
24796: LIST
24797: LIST
24798: LIST
24799: IN
24800: NOT
24801: OR
24802: PUSH
24803: LD_VAR 0 8
24807: PUSH
24808: LD_INT 5
24810: ARRAY
24811: NOT
24812: OR
24813: PUSH
24814: LD_VAR 0 8
24818: PUSH
24819: LD_INT 6
24821: ARRAY
24822: PUSH
24823: LD_INT 1
24825: PUSH
24826: LD_INT 2
24828: PUSH
24829: LD_INT 7
24831: PUSH
24832: LD_INT 9
24834: PUSH
24835: LD_INT 10
24837: PUSH
24838: LD_INT 11
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: LIST
24845: LIST
24846: LIST
24847: LIST
24848: IN
24849: NOT
24850: OR
24851: IFFALSE 24857
// exit ;
24853: POP
24854: POP
24855: GO 24940
// end ;
24857: GO 24528
24859: POP
24860: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24861: LD_VAR 0 9
24865: PPUSH
24866: LD_VAR 0 3
24870: PPUSH
24871: LD_VAR 0 4
24875: PPUSH
24876: LD_INT 20
24878: PPUSH
24879: CALL 16886 0 4
24883: PUSH
24884: LD_INT 4
24886: ARRAY
24887: IFFALSE 24891
// exit ;
24889: GO 24940
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
24891: LD_VAR 0 2
24895: PUSH
24896: LD_INT 29
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: IN
24906: PUSH
24907: LD_VAR 0 3
24911: PPUSH
24912: LD_VAR 0 4
24916: PPUSH
24917: LD_VAR 0 9
24921: PPUSH
24922: CALL_OW 440
24926: NOT
24927: AND
24928: IFFALSE 24932
// exit ;
24930: GO 24940
// result := true ;
24932: LD_ADDR_VAR 0 6
24936: PUSH
24937: LD_INT 1
24939: ST_TO_ADDR
// end ;
24940: LD_VAR 0 6
24944: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
24945: LD_INT 0
24947: PPUSH
24948: PPUSH
24949: PPUSH
24950: PPUSH
24951: PPUSH
24952: PPUSH
24953: PPUSH
24954: PPUSH
24955: PPUSH
24956: PPUSH
24957: PPUSH
24958: PPUSH
24959: PPUSH
24960: PPUSH
24961: PPUSH
24962: PPUSH
24963: PPUSH
24964: PPUSH
24965: PPUSH
24966: PPUSH
24967: PPUSH
24968: PPUSH
24969: PPUSH
24970: PPUSH
24971: PPUSH
24972: PPUSH
24973: PPUSH
24974: PPUSH
24975: PPUSH
24976: PPUSH
24977: PPUSH
24978: PPUSH
24979: PPUSH
24980: PPUSH
24981: PPUSH
24982: PPUSH
24983: PPUSH
24984: PPUSH
24985: PPUSH
24986: PPUSH
24987: PPUSH
24988: PPUSH
24989: PPUSH
24990: PPUSH
24991: PPUSH
24992: PPUSH
24993: PPUSH
24994: PPUSH
24995: PPUSH
24996: PPUSH
24997: PPUSH
24998: PPUSH
24999: PPUSH
25000: PPUSH
25001: PPUSH
25002: PPUSH
25003: PPUSH
25004: PPUSH
// result = [ ] ;
25005: LD_ADDR_VAR 0 7
25009: PUSH
25010: EMPTY
25011: ST_TO_ADDR
// temp_list = [ ] ;
25012: LD_ADDR_VAR 0 9
25016: PUSH
25017: EMPTY
25018: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25019: LD_VAR 0 4
25023: PUSH
25024: LD_INT 0
25026: PUSH
25027: LD_INT 1
25029: PUSH
25030: LD_INT 2
25032: PUSH
25033: LD_INT 3
25035: PUSH
25036: LD_INT 4
25038: PUSH
25039: LD_INT 5
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: IN
25050: NOT
25051: PUSH
25052: LD_VAR 0 1
25056: PUSH
25057: LD_INT 0
25059: PUSH
25060: LD_INT 1
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: IN
25067: PUSH
25068: LD_VAR 0 5
25072: PUSH
25073: LD_INT 1
25075: PUSH
25076: LD_INT 2
25078: PUSH
25079: LD_INT 3
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: LIST
25086: IN
25087: NOT
25088: AND
25089: OR
25090: IFFALSE 25094
// exit ;
25092: GO 43485
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25094: LD_VAR 0 1
25098: PUSH
25099: LD_INT 6
25101: PUSH
25102: LD_INT 7
25104: PUSH
25105: LD_INT 8
25107: PUSH
25108: LD_INT 13
25110: PUSH
25111: LD_INT 12
25113: PUSH
25114: LD_INT 15
25116: PUSH
25117: LD_INT 11
25119: PUSH
25120: LD_INT 14
25122: PUSH
25123: LD_INT 10
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: LIST
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: LIST
25136: IN
25137: IFFALSE 25147
// btype = b_lab ;
25139: LD_ADDR_VAR 0 1
25143: PUSH
25144: LD_INT 6
25146: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25147: LD_VAR 0 6
25151: PUSH
25152: LD_INT 0
25154: PUSH
25155: LD_INT 1
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: LIST
25165: IN
25166: NOT
25167: PUSH
25168: LD_VAR 0 1
25172: PUSH
25173: LD_INT 0
25175: PUSH
25176: LD_INT 1
25178: PUSH
25179: LD_INT 2
25181: PUSH
25182: LD_INT 3
25184: PUSH
25185: LD_INT 6
25187: PUSH
25188: LD_INT 36
25190: PUSH
25191: LD_INT 4
25193: PUSH
25194: LD_INT 5
25196: PUSH
25197: LD_INT 31
25199: PUSH
25200: LD_INT 32
25202: PUSH
25203: LD_INT 33
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: LIST
25217: LIST
25218: IN
25219: NOT
25220: PUSH
25221: LD_VAR 0 6
25225: PUSH
25226: LD_INT 1
25228: EQUAL
25229: AND
25230: OR
25231: PUSH
25232: LD_VAR 0 1
25236: PUSH
25237: LD_INT 2
25239: PUSH
25240: LD_INT 3
25242: PUSH
25243: EMPTY
25244: LIST
25245: LIST
25246: IN
25247: NOT
25248: PUSH
25249: LD_VAR 0 6
25253: PUSH
25254: LD_INT 2
25256: EQUAL
25257: AND
25258: OR
25259: IFFALSE 25269
// mode = 0 ;
25261: LD_ADDR_VAR 0 6
25265: PUSH
25266: LD_INT 0
25268: ST_TO_ADDR
// case mode of 0 :
25269: LD_VAR 0 6
25273: PUSH
25274: LD_INT 0
25276: DOUBLE
25277: EQUAL
25278: IFTRUE 25282
25280: GO 36735
25282: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25283: LD_ADDR_VAR 0 11
25287: PUSH
25288: LD_INT 0
25290: PUSH
25291: LD_INT 0
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: PUSH
25298: LD_INT 0
25300: PUSH
25301: LD_INT 1
25303: NEG
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PUSH
25309: LD_INT 1
25311: PUSH
25312: LD_INT 0
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 1
25321: PUSH
25322: LD_INT 1
25324: PUSH
25325: EMPTY
25326: LIST
25327: LIST
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: LD_INT 1
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 1
25341: NEG
25342: PUSH
25343: LD_INT 0
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 1
25352: NEG
25353: PUSH
25354: LD_INT 1
25356: NEG
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: LD_INT 1
25364: NEG
25365: PUSH
25366: LD_INT 2
25368: NEG
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PUSH
25374: LD_INT 0
25376: PUSH
25377: LD_INT 2
25379: NEG
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 1
25387: PUSH
25388: LD_INT 1
25390: NEG
25391: PUSH
25392: EMPTY
25393: LIST
25394: LIST
25395: PUSH
25396: LD_INT 1
25398: PUSH
25399: LD_INT 2
25401: PUSH
25402: EMPTY
25403: LIST
25404: LIST
25405: PUSH
25406: LD_INT 0
25408: PUSH
25409: LD_INT 2
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: LD_INT 1
25418: NEG
25419: PUSH
25420: LD_INT 1
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 1
25429: PUSH
25430: LD_INT 3
25432: PUSH
25433: EMPTY
25434: LIST
25435: LIST
25436: PUSH
25437: LD_INT 0
25439: PUSH
25440: LD_INT 3
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: LD_INT 1
25449: NEG
25450: PUSH
25451: LD_INT 2
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25476: LD_ADDR_VAR 0 12
25480: PUSH
25481: LD_INT 0
25483: PUSH
25484: LD_INT 0
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 0
25493: PUSH
25494: LD_INT 1
25496: NEG
25497: PUSH
25498: EMPTY
25499: LIST
25500: LIST
25501: PUSH
25502: LD_INT 1
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: PUSH
25512: LD_INT 1
25514: PUSH
25515: LD_INT 1
25517: PUSH
25518: EMPTY
25519: LIST
25520: LIST
25521: PUSH
25522: LD_INT 0
25524: PUSH
25525: LD_INT 1
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: PUSH
25532: LD_INT 1
25534: NEG
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: LD_INT 1
25545: NEG
25546: PUSH
25547: LD_INT 1
25549: NEG
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: PUSH
25555: LD_INT 1
25557: PUSH
25558: LD_INT 1
25560: NEG
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 2
25568: PUSH
25569: LD_INT 0
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 2
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 1
25588: NEG
25589: PUSH
25590: LD_INT 1
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 2
25599: NEG
25600: PUSH
25601: LD_INT 0
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 2
25610: NEG
25611: PUSH
25612: LD_INT 1
25614: NEG
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 2
25622: NEG
25623: PUSH
25624: LD_INT 1
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 3
25633: NEG
25634: PUSH
25635: LD_INT 0
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 3
25644: NEG
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25672: LD_ADDR_VAR 0 13
25676: PUSH
25677: LD_INT 0
25679: PUSH
25680: LD_INT 0
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: LD_INT 0
25689: PUSH
25690: LD_INT 1
25692: NEG
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 1
25700: PUSH
25701: LD_INT 0
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 1
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: LD_INT 0
25720: PUSH
25721: LD_INT 1
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PUSH
25728: LD_INT 1
25730: NEG
25731: PUSH
25732: LD_INT 0
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: LD_INT 1
25741: NEG
25742: PUSH
25743: LD_INT 1
25745: NEG
25746: PUSH
25747: EMPTY
25748: LIST
25749: LIST
25750: PUSH
25751: LD_INT 1
25753: NEG
25754: PUSH
25755: LD_INT 2
25757: NEG
25758: PUSH
25759: EMPTY
25760: LIST
25761: LIST
25762: PUSH
25763: LD_INT 2
25765: PUSH
25766: LD_INT 1
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 2
25775: PUSH
25776: LD_INT 2
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: LD_INT 1
25785: PUSH
25786: LD_INT 2
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 2
25795: NEG
25796: PUSH
25797: LD_INT 1
25799: NEG
25800: PUSH
25801: EMPTY
25802: LIST
25803: LIST
25804: PUSH
25805: LD_INT 2
25807: NEG
25808: PUSH
25809: LD_INT 2
25811: NEG
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 2
25819: NEG
25820: PUSH
25821: LD_INT 3
25823: NEG
25824: PUSH
25825: EMPTY
25826: LIST
25827: LIST
25828: PUSH
25829: LD_INT 3
25831: NEG
25832: PUSH
25833: LD_INT 2
25835: NEG
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: PUSH
25841: LD_INT 3
25843: NEG
25844: PUSH
25845: LD_INT 3
25847: NEG
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: LIST
25857: LIST
25858: LIST
25859: LIST
25860: LIST
25861: LIST
25862: LIST
25863: LIST
25864: LIST
25865: LIST
25866: LIST
25867: LIST
25868: LIST
25869: LIST
25870: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25871: LD_ADDR_VAR 0 14
25875: PUSH
25876: LD_INT 0
25878: PUSH
25879: LD_INT 0
25881: PUSH
25882: EMPTY
25883: LIST
25884: LIST
25885: PUSH
25886: LD_INT 0
25888: PUSH
25889: LD_INT 1
25891: NEG
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: LD_INT 0
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 1
25909: PUSH
25910: LD_INT 1
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 0
25919: PUSH
25920: LD_INT 1
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: PUSH
25927: LD_INT 1
25929: NEG
25930: PUSH
25931: LD_INT 0
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_INT 1
25940: NEG
25941: PUSH
25942: LD_INT 1
25944: NEG
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: LD_INT 1
25952: NEG
25953: PUSH
25954: LD_INT 2
25956: NEG
25957: PUSH
25958: EMPTY
25959: LIST
25960: LIST
25961: PUSH
25962: LD_INT 0
25964: PUSH
25965: LD_INT 2
25967: NEG
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: LD_INT 1
25975: PUSH
25976: LD_INT 1
25978: NEG
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 1
25986: PUSH
25987: LD_INT 2
25989: PUSH
25990: EMPTY
25991: LIST
25992: LIST
25993: PUSH
25994: LD_INT 0
25996: PUSH
25997: LD_INT 2
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 1
26006: NEG
26007: PUSH
26008: LD_INT 1
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: LD_INT 1
26017: NEG
26018: PUSH
26019: LD_INT 3
26021: NEG
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PUSH
26027: LD_INT 0
26029: PUSH
26030: LD_INT 3
26032: NEG
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 1
26040: PUSH
26041: LD_INT 2
26043: NEG
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: LIST
26053: LIST
26054: LIST
26055: LIST
26056: LIST
26057: LIST
26058: LIST
26059: LIST
26060: LIST
26061: LIST
26062: LIST
26063: LIST
26064: LIST
26065: LIST
26066: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26067: LD_ADDR_VAR 0 15
26071: PUSH
26072: LD_INT 0
26074: PUSH
26075: LD_INT 0
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 0
26084: PUSH
26085: LD_INT 1
26087: NEG
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 1
26095: PUSH
26096: LD_INT 0
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 1
26105: PUSH
26106: LD_INT 1
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: LD_INT 1
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 1
26125: NEG
26126: PUSH
26127: LD_INT 0
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: PUSH
26134: LD_INT 1
26136: NEG
26137: PUSH
26138: LD_INT 1
26140: NEG
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: LD_INT 1
26148: PUSH
26149: LD_INT 1
26151: NEG
26152: PUSH
26153: EMPTY
26154: LIST
26155: LIST
26156: PUSH
26157: LD_INT 2
26159: PUSH
26160: LD_INT 0
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: PUSH
26167: LD_INT 2
26169: PUSH
26170: LD_INT 1
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: LD_INT 1
26179: NEG
26180: PUSH
26181: LD_INT 1
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 2
26190: NEG
26191: PUSH
26192: LD_INT 0
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: LD_INT 2
26201: NEG
26202: PUSH
26203: LD_INT 1
26205: NEG
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: LD_INT 2
26213: PUSH
26214: LD_INT 1
26216: NEG
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 3
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 3
26234: PUSH
26235: LD_INT 1
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: LIST
26253: LIST
26254: LIST
26255: LIST
26256: LIST
26257: LIST
26258: LIST
26259: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26260: LD_ADDR_VAR 0 16
26264: PUSH
26265: LD_INT 0
26267: PUSH
26268: LD_INT 0
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 0
26277: PUSH
26278: LD_INT 1
26280: NEG
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 1
26288: PUSH
26289: LD_INT 0
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PUSH
26296: LD_INT 1
26298: PUSH
26299: LD_INT 1
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 0
26308: PUSH
26309: LD_INT 1
26311: PUSH
26312: EMPTY
26313: LIST
26314: LIST
26315: PUSH
26316: LD_INT 1
26318: NEG
26319: PUSH
26320: LD_INT 0
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: LD_INT 1
26329: NEG
26330: PUSH
26331: LD_INT 1
26333: NEG
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 1
26341: NEG
26342: PUSH
26343: LD_INT 2
26345: NEG
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PUSH
26351: LD_INT 2
26353: PUSH
26354: LD_INT 1
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PUSH
26361: LD_INT 2
26363: PUSH
26364: LD_INT 2
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PUSH
26371: LD_INT 1
26373: PUSH
26374: LD_INT 2
26376: PUSH
26377: EMPTY
26378: LIST
26379: LIST
26380: PUSH
26381: LD_INT 2
26383: NEG
26384: PUSH
26385: LD_INT 1
26387: NEG
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 2
26395: NEG
26396: PUSH
26397: LD_INT 2
26399: NEG
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 3
26407: PUSH
26408: LD_INT 2
26410: PUSH
26411: EMPTY
26412: LIST
26413: LIST
26414: PUSH
26415: LD_INT 3
26417: PUSH
26418: LD_INT 3
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 2
26427: PUSH
26428: LD_INT 3
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: LIST
26450: LIST
26451: LIST
26452: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26453: LD_ADDR_VAR 0 17
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: LD_INT 0
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: LD_INT 0
26470: PUSH
26471: LD_INT 1
26473: NEG
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 1
26481: PUSH
26482: LD_INT 0
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PUSH
26489: LD_INT 1
26491: PUSH
26492: LD_INT 1
26494: PUSH
26495: EMPTY
26496: LIST
26497: LIST
26498: PUSH
26499: LD_INT 0
26501: PUSH
26502: LD_INT 1
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 1
26511: NEG
26512: PUSH
26513: LD_INT 0
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: LD_INT 1
26522: NEG
26523: PUSH
26524: LD_INT 1
26526: NEG
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PUSH
26532: LD_INT 1
26534: NEG
26535: PUSH
26536: LD_INT 2
26538: NEG
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: LD_INT 0
26546: PUSH
26547: LD_INT 2
26549: NEG
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 1
26557: PUSH
26558: LD_INT 1
26560: NEG
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 2
26568: PUSH
26569: LD_INT 0
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: LD_INT 2
26578: PUSH
26579: LD_INT 1
26581: PUSH
26582: EMPTY
26583: LIST
26584: LIST
26585: PUSH
26586: LD_INT 2
26588: PUSH
26589: LD_INT 2
26591: PUSH
26592: EMPTY
26593: LIST
26594: LIST
26595: PUSH
26596: LD_INT 1
26598: PUSH
26599: LD_INT 2
26601: PUSH
26602: EMPTY
26603: LIST
26604: LIST
26605: PUSH
26606: LD_INT 0
26608: PUSH
26609: LD_INT 2
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: PUSH
26616: LD_INT 1
26618: NEG
26619: PUSH
26620: LD_INT 1
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 2
26629: NEG
26630: PUSH
26631: LD_INT 0
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 2
26640: NEG
26641: PUSH
26642: LD_INT 1
26644: NEG
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 2
26652: NEG
26653: PUSH
26654: LD_INT 2
26656: NEG
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26683: LD_ADDR_VAR 0 18
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: LD_INT 0
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 0
26700: PUSH
26701: LD_INT 1
26703: NEG
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: LD_INT 0
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: LD_INT 1
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: PUSH
26729: LD_INT 0
26731: PUSH
26732: LD_INT 1
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PUSH
26739: LD_INT 1
26741: NEG
26742: PUSH
26743: LD_INT 0
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PUSH
26750: LD_INT 1
26752: NEG
26753: PUSH
26754: LD_INT 1
26756: NEG
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 1
26764: NEG
26765: PUSH
26766: LD_INT 2
26768: NEG
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 0
26776: PUSH
26777: LD_INT 2
26779: NEG
26780: PUSH
26781: EMPTY
26782: LIST
26783: LIST
26784: PUSH
26785: LD_INT 1
26787: PUSH
26788: LD_INT 1
26790: NEG
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: LD_INT 2
26798: PUSH
26799: LD_INT 0
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 2
26808: PUSH
26809: LD_INT 1
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 2
26818: PUSH
26819: LD_INT 2
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 1
26828: PUSH
26829: LD_INT 2
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 2
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: PUSH
26846: LD_INT 1
26848: NEG
26849: PUSH
26850: LD_INT 1
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 2
26859: NEG
26860: PUSH
26861: LD_INT 0
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 2
26870: NEG
26871: PUSH
26872: LD_INT 1
26874: NEG
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 2
26882: NEG
26883: PUSH
26884: LD_INT 2
26886: NEG
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: LIST
26896: LIST
26897: LIST
26898: LIST
26899: LIST
26900: LIST
26901: LIST
26902: LIST
26903: LIST
26904: LIST
26905: LIST
26906: LIST
26907: LIST
26908: LIST
26909: LIST
26910: LIST
26911: LIST
26912: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26913: LD_ADDR_VAR 0 19
26917: PUSH
26918: LD_INT 0
26920: PUSH
26921: LD_INT 0
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PUSH
26928: LD_INT 0
26930: PUSH
26931: LD_INT 1
26933: NEG
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 1
26941: PUSH
26942: LD_INT 0
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 1
26951: PUSH
26952: LD_INT 1
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 0
26961: PUSH
26962: LD_INT 1
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PUSH
26969: LD_INT 1
26971: NEG
26972: PUSH
26973: LD_INT 0
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PUSH
26980: LD_INT 1
26982: NEG
26983: PUSH
26984: LD_INT 1
26986: NEG
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 1
26994: NEG
26995: PUSH
26996: LD_INT 2
26998: NEG
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: PUSH
27004: LD_INT 0
27006: PUSH
27007: LD_INT 2
27009: NEG
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: LD_INT 1
27017: PUSH
27018: LD_INT 1
27020: NEG
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: PUSH
27026: LD_INT 2
27028: PUSH
27029: LD_INT 0
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 2
27038: PUSH
27039: LD_INT 1
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 2
27048: PUSH
27049: LD_INT 2
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: PUSH
27056: LD_INT 1
27058: PUSH
27059: LD_INT 2
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: LD_INT 0
27068: PUSH
27069: LD_INT 2
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 1
27078: NEG
27079: PUSH
27080: LD_INT 1
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 2
27089: NEG
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: LD_INT 2
27100: NEG
27101: PUSH
27102: LD_INT 1
27104: NEG
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 2
27112: NEG
27113: PUSH
27114: LD_INT 2
27116: NEG
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: LIST
27130: LIST
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: LIST
27136: LIST
27137: LIST
27138: LIST
27139: LIST
27140: LIST
27141: LIST
27142: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27143: LD_ADDR_VAR 0 20
27147: PUSH
27148: LD_INT 0
27150: PUSH
27151: LD_INT 0
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 0
27160: PUSH
27161: LD_INT 1
27163: NEG
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 1
27181: PUSH
27182: LD_INT 1
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_INT 0
27191: PUSH
27192: LD_INT 1
27194: PUSH
27195: EMPTY
27196: LIST
27197: LIST
27198: PUSH
27199: LD_INT 1
27201: NEG
27202: PUSH
27203: LD_INT 0
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: LD_INT 1
27216: NEG
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 1
27224: NEG
27225: PUSH
27226: LD_INT 2
27228: NEG
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: PUSH
27234: LD_INT 0
27236: PUSH
27237: LD_INT 2
27239: NEG
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PUSH
27245: LD_INT 1
27247: PUSH
27248: LD_INT 1
27250: NEG
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 2
27258: PUSH
27259: LD_INT 0
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 2
27268: PUSH
27269: LD_INT 1
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 2
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 1
27288: PUSH
27289: LD_INT 2
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: LD_INT 2
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 1
27308: NEG
27309: PUSH
27310: LD_INT 1
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: LD_INT 2
27319: NEG
27320: PUSH
27321: LD_INT 0
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: PUSH
27328: LD_INT 2
27330: NEG
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 2
27342: NEG
27343: PUSH
27344: LD_INT 2
27346: NEG
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: LIST
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27373: LD_ADDR_VAR 0 21
27377: PUSH
27378: LD_INT 0
27380: PUSH
27381: LD_INT 0
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 0
27390: PUSH
27391: LD_INT 1
27393: NEG
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 1
27401: PUSH
27402: LD_INT 0
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: LD_INT 1
27411: PUSH
27412: LD_INT 1
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: LD_INT 1
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 1
27431: NEG
27432: PUSH
27433: LD_INT 0
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 1
27442: NEG
27443: PUSH
27444: LD_INT 1
27446: NEG
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 1
27454: NEG
27455: PUSH
27456: LD_INT 2
27458: NEG
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: PUSH
27464: LD_INT 0
27466: PUSH
27467: LD_INT 2
27469: NEG
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 1
27477: PUSH
27478: LD_INT 1
27480: NEG
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: PUSH
27486: LD_INT 2
27488: PUSH
27489: LD_INT 0
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 2
27498: PUSH
27499: LD_INT 1
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PUSH
27506: LD_INT 2
27508: PUSH
27509: LD_INT 2
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 1
27518: PUSH
27519: LD_INT 2
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: LD_INT 2
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 1
27538: NEG
27539: PUSH
27540: LD_INT 1
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: LD_INT 2
27549: NEG
27550: PUSH
27551: LD_INT 0
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: LD_INT 2
27560: NEG
27561: PUSH
27562: LD_INT 1
27564: NEG
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: LD_INT 2
27572: NEG
27573: PUSH
27574: LD_INT 2
27576: NEG
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: LIST
27600: LIST
27601: LIST
27602: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27603: LD_ADDR_VAR 0 22
27607: PUSH
27608: LD_INT 0
27610: PUSH
27611: LD_INT 0
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: LD_INT 1
27623: NEG
27624: PUSH
27625: EMPTY
27626: LIST
27627: LIST
27628: PUSH
27629: LD_INT 1
27631: PUSH
27632: LD_INT 0
27634: PUSH
27635: EMPTY
27636: LIST
27637: LIST
27638: PUSH
27639: LD_INT 1
27641: PUSH
27642: LD_INT 1
27644: PUSH
27645: EMPTY
27646: LIST
27647: LIST
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: LD_INT 1
27654: PUSH
27655: EMPTY
27656: LIST
27657: LIST
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: LD_INT 1
27672: NEG
27673: PUSH
27674: LD_INT 1
27676: NEG
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PUSH
27682: LD_INT 1
27684: NEG
27685: PUSH
27686: LD_INT 2
27688: NEG
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PUSH
27694: LD_INT 0
27696: PUSH
27697: LD_INT 2
27699: NEG
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 1
27707: PUSH
27708: LD_INT 1
27710: NEG
27711: PUSH
27712: EMPTY
27713: LIST
27714: LIST
27715: PUSH
27716: LD_INT 2
27718: PUSH
27719: LD_INT 0
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 2
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 2
27738: PUSH
27739: LD_INT 2
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 1
27748: PUSH
27749: LD_INT 2
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 0
27758: PUSH
27759: LD_INT 2
27761: PUSH
27762: EMPTY
27763: LIST
27764: LIST
27765: PUSH
27766: LD_INT 1
27768: NEG
27769: PUSH
27770: LD_INT 1
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 2
27779: NEG
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 2
27790: NEG
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 2
27802: NEG
27803: PUSH
27804: LD_INT 2
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: LIST
27825: LIST
27826: LIST
27827: LIST
27828: LIST
27829: LIST
27830: LIST
27831: LIST
27832: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27833: LD_ADDR_VAR 0 23
27837: PUSH
27838: LD_INT 0
27840: PUSH
27841: LD_INT 0
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 0
27850: PUSH
27851: LD_INT 1
27853: NEG
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 1
27861: PUSH
27862: LD_INT 0
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 1
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 0
27881: PUSH
27882: LD_INT 1
27884: PUSH
27885: EMPTY
27886: LIST
27887: LIST
27888: PUSH
27889: LD_INT 1
27891: NEG
27892: PUSH
27893: LD_INT 0
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: PUSH
27900: LD_INT 1
27902: NEG
27903: PUSH
27904: LD_INT 1
27906: NEG
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 1
27914: NEG
27915: PUSH
27916: LD_INT 2
27918: NEG
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: PUSH
27924: LD_INT 0
27926: PUSH
27927: LD_INT 2
27929: NEG
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 1
27937: PUSH
27938: LD_INT 1
27940: NEG
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 2
27948: PUSH
27949: LD_INT 0
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 2
27958: PUSH
27959: LD_INT 1
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 2
27968: PUSH
27969: LD_INT 2
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 1
27978: PUSH
27979: LD_INT 2
27981: PUSH
27982: EMPTY
27983: LIST
27984: LIST
27985: PUSH
27986: LD_INT 0
27988: PUSH
27989: LD_INT 2
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 1
27998: NEG
27999: PUSH
28000: LD_INT 1
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 2
28009: NEG
28010: PUSH
28011: LD_INT 0
28013: PUSH
28014: EMPTY
28015: LIST
28016: LIST
28017: PUSH
28018: LD_INT 2
28020: NEG
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 2
28032: NEG
28033: PUSH
28034: LD_INT 2
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 2
28044: NEG
28045: PUSH
28046: LD_INT 3
28048: NEG
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 1
28056: NEG
28057: PUSH
28058: LD_INT 3
28060: NEG
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 1
28068: PUSH
28069: LD_INT 2
28071: NEG
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 2
28079: PUSH
28080: LD_INT 1
28082: NEG
28083: PUSH
28084: EMPTY
28085: LIST
28086: LIST
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28113: LD_ADDR_VAR 0 24
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: LD_INT 0
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 0
28130: PUSH
28131: LD_INT 1
28133: NEG
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 1
28141: PUSH
28142: LD_INT 0
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 1
28151: PUSH
28152: LD_INT 1
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: LD_INT 0
28161: PUSH
28162: LD_INT 1
28164: PUSH
28165: EMPTY
28166: LIST
28167: LIST
28168: PUSH
28169: LD_INT 1
28171: NEG
28172: PUSH
28173: LD_INT 0
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: PUSH
28180: LD_INT 1
28182: NEG
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PUSH
28192: LD_INT 1
28194: NEG
28195: PUSH
28196: LD_INT 2
28198: NEG
28199: PUSH
28200: EMPTY
28201: LIST
28202: LIST
28203: PUSH
28204: LD_INT 0
28206: PUSH
28207: LD_INT 2
28209: NEG
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 1
28217: PUSH
28218: LD_INT 1
28220: NEG
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 2
28228: PUSH
28229: LD_INT 0
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 2
28238: PUSH
28239: LD_INT 1
28241: PUSH
28242: EMPTY
28243: LIST
28244: LIST
28245: PUSH
28246: LD_INT 2
28248: PUSH
28249: LD_INT 2
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: PUSH
28256: LD_INT 1
28258: PUSH
28259: LD_INT 2
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: LD_INT 2
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 1
28278: NEG
28279: PUSH
28280: LD_INT 1
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 2
28289: NEG
28290: PUSH
28291: LD_INT 0
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 2
28300: NEG
28301: PUSH
28302: LD_INT 1
28304: NEG
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 2
28312: NEG
28313: PUSH
28314: LD_INT 2
28316: NEG
28317: PUSH
28318: EMPTY
28319: LIST
28320: LIST
28321: PUSH
28322: LD_INT 1
28324: PUSH
28325: LD_INT 2
28327: NEG
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: PUSH
28336: LD_INT 1
28338: NEG
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 3
28346: PUSH
28347: LD_INT 1
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 3
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: LIST
28368: LIST
28369: LIST
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: LIST
28377: LIST
28378: LIST
28379: LIST
28380: LIST
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: LIST
28388: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28389: LD_ADDR_VAR 0 25
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 0
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 0
28406: PUSH
28407: LD_INT 1
28409: NEG
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 1
28417: PUSH
28418: LD_INT 0
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: LD_INT 1
28427: PUSH
28428: LD_INT 1
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: LD_INT 0
28437: PUSH
28438: LD_INT 1
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: PUSH
28445: LD_INT 1
28447: NEG
28448: PUSH
28449: LD_INT 0
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 1
28458: NEG
28459: PUSH
28460: LD_INT 1
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 1
28470: NEG
28471: PUSH
28472: LD_INT 2
28474: NEG
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 0
28482: PUSH
28483: LD_INT 2
28485: NEG
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 1
28493: PUSH
28494: LD_INT 1
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 2
28504: PUSH
28505: LD_INT 0
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: LD_INT 2
28514: PUSH
28515: LD_INT 1
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PUSH
28522: LD_INT 2
28524: PUSH
28525: LD_INT 2
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 1
28534: PUSH
28535: LD_INT 2
28537: PUSH
28538: EMPTY
28539: LIST
28540: LIST
28541: PUSH
28542: LD_INT 0
28544: PUSH
28545: LD_INT 2
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PUSH
28552: LD_INT 1
28554: NEG
28555: PUSH
28556: LD_INT 1
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PUSH
28563: LD_INT 2
28565: NEG
28566: PUSH
28567: LD_INT 0
28569: PUSH
28570: EMPTY
28571: LIST
28572: LIST
28573: PUSH
28574: LD_INT 2
28576: NEG
28577: PUSH
28578: LD_INT 1
28580: NEG
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: LD_INT 2
28592: NEG
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 3
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 3
28610: PUSH
28611: LD_INT 2
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 2
28620: PUSH
28621: LD_INT 3
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: PUSH
28628: LD_INT 1
28630: PUSH
28631: LD_INT 3
28633: PUSH
28634: EMPTY
28635: LIST
28636: LIST
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: LIST
28642: LIST
28643: LIST
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28663: LD_ADDR_VAR 0 26
28667: PUSH
28668: LD_INT 0
28670: PUSH
28671: LD_INT 0
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 0
28680: PUSH
28681: LD_INT 1
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 1
28691: PUSH
28692: LD_INT 0
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 1
28701: PUSH
28702: LD_INT 1
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: LD_INT 0
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 1
28721: NEG
28722: PUSH
28723: LD_INT 0
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: NEG
28733: PUSH
28734: LD_INT 1
28736: NEG
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: NEG
28745: PUSH
28746: LD_INT 2
28748: NEG
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 0
28756: PUSH
28757: LD_INT 2
28759: NEG
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 1
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 2
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 2
28798: PUSH
28799: LD_INT 2
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 0
28818: PUSH
28819: LD_INT 2
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: NEG
28829: PUSH
28830: LD_INT 1
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 2
28839: NEG
28840: PUSH
28841: LD_INT 0
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: PUSH
28848: LD_INT 2
28850: NEG
28851: PUSH
28852: LD_INT 1
28854: NEG
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PUSH
28860: LD_INT 2
28862: NEG
28863: PUSH
28864: LD_INT 2
28866: NEG
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PUSH
28872: LD_INT 2
28874: PUSH
28875: LD_INT 3
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 1
28884: PUSH
28885: LD_INT 3
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: NEG
28895: PUSH
28896: LD_INT 2
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 2
28905: NEG
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28939: LD_ADDR_VAR 0 27
28943: PUSH
28944: LD_INT 0
28946: PUSH
28947: LD_INT 0
28949: PUSH
28950: EMPTY
28951: LIST
28952: LIST
28953: PUSH
28954: LD_INT 0
28956: PUSH
28957: LD_INT 1
28959: NEG
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: LD_INT 0
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: LD_INT 1
28977: PUSH
28978: LD_INT 1
28980: PUSH
28981: EMPTY
28982: LIST
28983: LIST
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: LD_INT 1
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: PUSH
28995: LD_INT 1
28997: NEG
28998: PUSH
28999: LD_INT 0
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: LD_INT 1
29008: NEG
29009: PUSH
29010: LD_INT 1
29012: NEG
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PUSH
29018: LD_INT 1
29020: NEG
29021: PUSH
29022: LD_INT 2
29024: NEG
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 0
29032: PUSH
29033: LD_INT 2
29035: NEG
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 1
29043: PUSH
29044: LD_INT 1
29046: NEG
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 2
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: PUSH
29062: LD_INT 2
29064: PUSH
29065: LD_INT 1
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 2
29074: PUSH
29075: LD_INT 2
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 1
29084: PUSH
29085: LD_INT 2
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 0
29094: PUSH
29095: LD_INT 2
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 1
29104: NEG
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: LD_INT 2
29115: NEG
29116: PUSH
29117: LD_INT 0
29119: PUSH
29120: EMPTY
29121: LIST
29122: LIST
29123: PUSH
29124: LD_INT 2
29126: NEG
29127: PUSH
29128: LD_INT 1
29130: NEG
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 2
29138: NEG
29139: PUSH
29140: LD_INT 2
29142: NEG
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: PUSH
29148: LD_INT 1
29150: NEG
29151: PUSH
29152: LD_INT 2
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: NEG
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 3
29172: NEG
29173: PUSH
29174: LD_INT 1
29176: NEG
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 3
29184: NEG
29185: PUSH
29186: LD_INT 2
29188: NEG
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29219: LD_ADDR_VAR 0 28
29223: PUSH
29224: LD_INT 0
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: LD_INT 1
29239: NEG
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 1
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: LD_INT 1
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 0
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: EMPTY
29272: LIST
29273: LIST
29274: PUSH
29275: LD_INT 1
29277: NEG
29278: PUSH
29279: LD_INT 0
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 1
29288: NEG
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: EMPTY
29295: LIST
29296: LIST
29297: PUSH
29298: LD_INT 1
29300: NEG
29301: PUSH
29302: LD_INT 2
29304: NEG
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PUSH
29310: LD_INT 0
29312: PUSH
29313: LD_INT 2
29315: NEG
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: PUSH
29321: LD_INT 1
29323: PUSH
29324: LD_INT 1
29326: NEG
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 2
29334: PUSH
29335: LD_INT 0
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 2
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 2
29354: PUSH
29355: LD_INT 2
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: LD_INT 2
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 2
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: NEG
29385: PUSH
29386: LD_INT 1
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 2
29395: NEG
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 2
29406: NEG
29407: PUSH
29408: LD_INT 1
29410: NEG
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 2
29418: NEG
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 2
29430: NEG
29431: PUSH
29432: LD_INT 3
29434: NEG
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: NEG
29443: PUSH
29444: LD_INT 3
29446: NEG
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: LD_INT 3
29454: NEG
29455: PUSH
29456: LD_INT 1
29458: NEG
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 3
29466: NEG
29467: PUSH
29468: LD_INT 2
29470: NEG
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29501: LD_ADDR_VAR 0 29
29505: PUSH
29506: LD_INT 0
29508: PUSH
29509: LD_INT 0
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 1
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 0
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 0
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: NEG
29560: PUSH
29561: LD_INT 0
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: LD_INT 1
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: LD_INT 2
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 0
29594: PUSH
29595: LD_INT 2
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: PUSH
29617: LD_INT 0
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: PUSH
29637: LD_INT 2
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: NEG
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 2
29667: NEG
29668: PUSH
29669: LD_INT 1
29671: NEG
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 2
29679: NEG
29680: PUSH
29681: LD_INT 2
29683: NEG
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 2
29691: NEG
29692: PUSH
29693: LD_INT 3
29695: NEG
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: PUSH
29701: LD_INT 2
29703: PUSH
29704: LD_INT 1
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 3
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: LD_INT 3
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 1
29734: NEG
29735: PUSH
29736: LD_INT 2
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 3
29745: NEG
29746: PUSH
29747: LD_INT 2
29749: NEG
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: LIST
29759: LIST
29760: LIST
29761: LIST
29762: LIST
29763: LIST
29764: LIST
29765: LIST
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29780: LD_ADDR_VAR 0 30
29784: PUSH
29785: LD_INT 0
29787: PUSH
29788: LD_INT 0
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 0
29797: PUSH
29798: LD_INT 1
29800: NEG
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 1
29808: PUSH
29809: LD_INT 0
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 1
29818: PUSH
29819: LD_INT 1
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 0
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: NEG
29839: PUSH
29840: LD_INT 0
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 1
29849: NEG
29850: PUSH
29851: LD_INT 1
29853: NEG
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 1
29861: NEG
29862: PUSH
29863: LD_INT 2
29865: NEG
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 0
29873: PUSH
29874: LD_INT 2
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 2
29895: PUSH
29896: LD_INT 0
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 2
29905: PUSH
29906: LD_INT 1
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 2
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 2
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: NEG
29936: PUSH
29937: LD_INT 1
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: LD_INT 0
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 2
29957: NEG
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 1
29969: NEG
29970: PUSH
29971: LD_INT 3
29973: NEG
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: LD_INT 2
29984: NEG
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: LD_INT 2
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 2
30002: PUSH
30003: LD_INT 3
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 2
30012: NEG
30013: PUSH
30014: LD_INT 1
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: PUSH
30021: LD_INT 3
30023: NEG
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30058: LD_ADDR_VAR 0 31
30062: PUSH
30063: LD_INT 0
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 0
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 1
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 1
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: NEG
30117: PUSH
30118: LD_INT 0
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 1
30127: NEG
30128: PUSH
30129: LD_INT 1
30131: NEG
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 1
30139: NEG
30140: PUSH
30141: LD_INT 2
30143: NEG
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 1
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: PUSH
30163: LD_INT 0
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 2
30172: PUSH
30173: LD_INT 1
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 2
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 1
30192: PUSH
30193: LD_INT 2
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 0
30202: PUSH
30203: LD_INT 2
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 2
30223: NEG
30224: PUSH
30225: LD_INT 1
30227: NEG
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 2
30235: NEG
30236: PUSH
30237: LD_INT 2
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 2
30247: NEG
30248: PUSH
30249: LD_INT 3
30251: NEG
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 2
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 3
30270: PUSH
30271: LD_INT 1
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 1
30280: PUSH
30281: LD_INT 3
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 2
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 3
30301: NEG
30302: PUSH
30303: LD_INT 2
30305: NEG
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30336: LD_ADDR_VAR 0 32
30340: PUSH
30341: LD_INT 0
30343: PUSH
30344: LD_INT 0
30346: PUSH
30347: EMPTY
30348: LIST
30349: LIST
30350: PUSH
30351: LD_INT 0
30353: PUSH
30354: LD_INT 1
30356: NEG
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: LD_INT 0
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: PUSH
30375: LD_INT 1
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: LD_INT 1
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: NEG
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: NEG
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: LD_INT 2
30421: NEG
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: LD_INT 2
30432: NEG
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: LD_INT 1
30443: NEG
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 2
30451: PUSH
30452: LD_INT 1
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 2
30461: PUSH
30462: LD_INT 2
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 1
30471: PUSH
30472: LD_INT 2
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: LD_INT 2
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 1
30491: NEG
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 2
30502: NEG
30503: PUSH
30504: LD_INT 0
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 2
30513: NEG
30514: PUSH
30515: LD_INT 1
30517: NEG
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 1
30525: NEG
30526: PUSH
30527: LD_INT 3
30529: NEG
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: LD_INT 2
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 3
30548: PUSH
30549: LD_INT 2
30551: PUSH
30552: EMPTY
30553: LIST
30554: LIST
30555: PUSH
30556: LD_INT 2
30558: PUSH
30559: LD_INT 3
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 2
30568: NEG
30569: PUSH
30570: LD_INT 1
30572: PUSH
30573: EMPTY
30574: LIST
30575: LIST
30576: PUSH
30577: LD_INT 3
30579: NEG
30580: PUSH
30581: LD_INT 1
30583: NEG
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30614: LD_ADDR_VAR 0 33
30618: PUSH
30619: LD_INT 0
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 0
30631: PUSH
30632: LD_INT 1
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 1
30642: PUSH
30643: LD_INT 0
30645: PUSH
30646: EMPTY
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 1
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: LD_INT 0
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: LD_INT 1
30683: NEG
30684: PUSH
30685: LD_INT 1
30687: NEG
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 1
30695: NEG
30696: PUSH
30697: LD_INT 2
30699: NEG
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 1
30707: PUSH
30708: LD_INT 1
30710: NEG
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: LD_INT 0
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 2
30728: PUSH
30729: LD_INT 1
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: LD_INT 2
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 0
30748: PUSH
30749: LD_INT 2
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: NEG
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 2
30804: NEG
30805: PUSH
30806: LD_INT 3
30808: NEG
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: LD_INT 1
30819: NEG
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 3
30827: PUSH
30828: LD_INT 1
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 1
30837: PUSH
30838: LD_INT 3
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: LD_INT 2
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 3
30858: NEG
30859: PUSH
30860: LD_INT 2
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30893: LD_ADDR_VAR 0 34
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: LD_INT 0
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 0
30910: PUSH
30911: LD_INT 1
30913: NEG
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 1
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 0
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: NEG
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 1
30962: NEG
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: LD_INT 2
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 0
30986: PUSH
30987: LD_INT 2
30989: NEG
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 1
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 2
31008: PUSH
31009: LD_INT 1
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 2
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 1
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 2
31060: NEG
31061: PUSH
31062: LD_INT 1
31064: NEG
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: LD_INT 2
31076: NEG
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 1
31084: NEG
31085: PUSH
31086: LD_INT 3
31088: NEG
31089: PUSH
31090: EMPTY
31091: LIST
31092: LIST
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: LD_INT 2
31099: NEG
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 3
31107: PUSH
31108: LD_INT 2
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 2
31117: PUSH
31118: LD_INT 3
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: LD_INT 1
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 3
31138: NEG
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: LIST
31157: LIST
31158: LIST
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31173: LD_ADDR_VAR 0 35
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: LD_INT 0
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 0
31190: PUSH
31191: LD_INT 1
31193: NEG
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 1
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 0
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: NEG
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: NEG
31243: PUSH
31244: LD_INT 1
31246: NEG
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 2
31254: PUSH
31255: LD_INT 1
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 2
31264: NEG
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31285: LD_ADDR_VAR 0 36
31289: PUSH
31290: LD_INT 0
31292: PUSH
31293: LD_INT 0
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: LD_INT 1
31305: NEG
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: LD_INT 0
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 1
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 0
31333: PUSH
31334: LD_INT 1
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: LD_INT 0
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: LD_INT 1
31354: NEG
31355: PUSH
31356: LD_INT 1
31358: NEG
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 1
31366: NEG
31367: PUSH
31368: LD_INT 2
31370: NEG
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 1
31378: PUSH
31379: LD_INT 2
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31397: LD_ADDR_VAR 0 37
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: LD_INT 0
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: LD_INT 1
31417: NEG
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 0
31445: PUSH
31446: LD_INT 1
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: NEG
31456: PUSH
31457: LD_INT 0
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 1
31466: NEG
31467: PUSH
31468: LD_INT 1
31470: NEG
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 1
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: NEG
31490: PUSH
31491: LD_INT 1
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31509: LD_ADDR_VAR 0 38
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: LD_INT 0
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: LD_INT 1
31529: NEG
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: PUSH
31538: LD_INT 0
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: LD_INT 1
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: LD_INT 1
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: LD_INT 0
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: LD_INT 1
31582: NEG
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 2
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 2
31600: NEG
31601: PUSH
31602: LD_INT 1
31604: NEG
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31621: LD_ADDR_VAR 0 39
31625: PUSH
31626: LD_INT 0
31628: PUSH
31629: LD_INT 0
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 0
31638: PUSH
31639: LD_INT 1
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: PUSH
31660: LD_INT 1
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 0
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 0
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 1
31694: NEG
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 2
31706: NEG
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: LD_INT 2
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31733: LD_ADDR_VAR 0 40
31737: PUSH
31738: LD_INT 0
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: LD_INT 1
31753: NEG
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: PUSH
31762: LD_INT 0
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: LD_INT 1
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 0
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: NEG
31792: PUSH
31793: LD_INT 0
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: LD_INT 1
31806: NEG
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 1
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 1
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31845: LD_ADDR_VAR 0 41
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 0
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: LD_INT 1
31865: NEG
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 1
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 1
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 0
31893: PUSH
31894: LD_INT 1
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: NEG
31904: PUSH
31905: LD_INT 0
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 1
31914: NEG
31915: PUSH
31916: LD_INT 1
31918: NEG
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 1
31926: NEG
31927: PUSH
31928: LD_INT 2
31930: NEG
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: PUSH
31939: LD_INT 1
31941: NEG
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 2
31949: PUSH
31950: LD_INT 0
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: PUSH
31957: LD_INT 2
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 1
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 2
32000: NEG
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: NEG
32012: PUSH
32013: LD_INT 1
32015: NEG
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 2
32023: NEG
32024: PUSH
32025: LD_INT 2
32027: NEG
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 2
32035: NEG
32036: PUSH
32037: LD_INT 3
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 2
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 3
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 3
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 3
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 3
32088: PUSH
32089: LD_INT 3
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 2
32098: PUSH
32099: LD_INT 3
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 2
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 3
32119: NEG
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 3
32130: NEG
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 3
32142: NEG
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 3
32154: NEG
32155: PUSH
32156: LD_INT 3
32158: NEG
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32195: LD_ADDR_VAR 0 42
32199: PUSH
32200: LD_INT 0
32202: PUSH
32203: LD_INT 0
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 0
32212: PUSH
32213: LD_INT 1
32215: NEG
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 1
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 1
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 0
32243: PUSH
32244: LD_INT 1
32246: PUSH
32247: EMPTY
32248: LIST
32249: LIST
32250: PUSH
32251: LD_INT 1
32253: NEG
32254: PUSH
32255: LD_INT 0
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: NEG
32265: PUSH
32266: LD_INT 1
32268: NEG
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 1
32276: NEG
32277: PUSH
32278: LD_INT 2
32280: NEG
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: LD_INT 2
32291: NEG
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 1
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 2
32310: PUSH
32311: LD_INT 1
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 2
32320: PUSH
32321: LD_INT 2
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: PUSH
32331: LD_INT 2
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: LD_INT 2
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 1
32350: NEG
32351: PUSH
32352: LD_INT 1
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 2
32361: NEG
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 2
32373: NEG
32374: PUSH
32375: LD_INT 2
32377: NEG
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 2
32385: NEG
32386: PUSH
32387: LD_INT 3
32389: NEG
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PUSH
32399: LD_INT 3
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 3
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 3
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 3
32441: PUSH
32442: LD_INT 3
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 2
32451: PUSH
32452: LD_INT 3
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 1
32461: PUSH
32462: LD_INT 3
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 3
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: NEG
32482: PUSH
32483: LD_INT 2
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 3
32492: NEG
32493: PUSH
32494: LD_INT 2
32496: NEG
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 3
32504: NEG
32505: PUSH
32506: LD_INT 3
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32545: LD_ADDR_VAR 0 43
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: LD_INT 1
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 1
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 0
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: LD_INT 0
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 1
32614: NEG
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: LD_INT 2
32630: NEG
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 0
32638: PUSH
32639: LD_INT 2
32641: NEG
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 2
32670: PUSH
32671: LD_INT 1
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 1
32680: PUSH
32681: LD_INT 2
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: LD_INT 2
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 2
32711: NEG
32712: PUSH
32713: LD_INT 0
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: NEG
32723: PUSH
32724: LD_INT 1
32726: NEG
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 3
32738: NEG
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: LD_INT 3
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 2
32768: PUSH
32769: LD_INT 1
32771: NEG
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 3
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 3
32789: PUSH
32790: LD_INT 1
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 1
32799: PUSH
32800: LD_INT 3
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 0
32809: PUSH
32810: LD_INT 3
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: NEG
32831: PUSH
32832: LD_INT 1
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 3
32841: NEG
32842: PUSH
32843: LD_INT 0
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 3
32852: NEG
32853: PUSH
32854: LD_INT 1
32856: NEG
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32893: LD_ADDR_VAR 0 44
32897: PUSH
32898: LD_INT 0
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 1
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 1
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 1
32951: NEG
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: NEG
32963: PUSH
32964: LD_INT 1
32966: NEG
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: LD_INT 2
32978: NEG
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 1
32986: PUSH
32987: LD_INT 1
32989: NEG
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 2
32997: PUSH
32998: LD_INT 0
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 2
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 2
33017: PUSH
33018: LD_INT 2
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: NEG
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: LD_INT 0
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: NEG
33060: PUSH
33061: LD_INT 1
33063: NEG
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 2
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 2
33083: NEG
33084: PUSH
33085: LD_INT 3
33087: NEG
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 2
33095: PUSH
33096: LD_INT 1
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 3
33106: PUSH
33107: LD_INT 0
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 3
33116: PUSH
33117: LD_INT 1
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 3
33126: PUSH
33127: LD_INT 2
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 3
33136: PUSH
33137: LD_INT 3
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 2
33146: PUSH
33147: LD_INT 3
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 2
33156: NEG
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 3
33167: NEG
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 3
33178: NEG
33179: PUSH
33180: LD_INT 1
33182: NEG
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 3
33190: NEG
33191: PUSH
33192: LD_INT 2
33194: NEG
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 3
33202: NEG
33203: PUSH
33204: LD_INT 3
33206: NEG
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33243: LD_ADDR_VAR 0 45
33247: PUSH
33248: LD_INT 0
33250: PUSH
33251: LD_INT 0
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: NEG
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: LD_INT 1
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 0
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 1
33312: NEG
33313: PUSH
33314: LD_INT 1
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 0
33336: PUSH
33337: LD_INT 2
33339: NEG
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: PUSH
33348: LD_INT 1
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 2
33368: PUSH
33369: LD_INT 2
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 1
33378: PUSH
33379: LD_INT 2
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: NEG
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 2
33409: NEG
33410: PUSH
33411: LD_INT 1
33413: NEG
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 2
33421: NEG
33422: PUSH
33423: LD_INT 2
33425: NEG
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 2
33433: NEG
33434: PUSH
33435: LD_INT 3
33437: NEG
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: LD_INT 3
33449: NEG
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 3
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: PUSH
33469: LD_INT 2
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 3
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 3
33489: PUSH
33490: LD_INT 3
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 2
33499: PUSH
33500: LD_INT 3
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: LD_INT 3
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 3
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: NEG
33530: PUSH
33531: LD_INT 2
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 3
33540: NEG
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 3
33552: NEG
33553: PUSH
33554: LD_INT 3
33556: NEG
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33593: LD_ADDR_VAR 0 46
33597: PUSH
33598: LD_INT 0
33600: PUSH
33601: LD_INT 0
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 0
33610: PUSH
33611: LD_INT 1
33613: NEG
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: LD_INT 1
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: LD_INT 1
33666: NEG
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 1
33674: NEG
33675: PUSH
33676: LD_INT 2
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 0
33686: PUSH
33687: LD_INT 2
33689: NEG
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 1
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: LD_INT 0
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 2
33718: PUSH
33719: LD_INT 1
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 1
33728: PUSH
33729: LD_INT 2
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: LD_INT 2
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 1
33748: NEG
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 2
33759: NEG
33760: PUSH
33761: LD_INT 0
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: LD_INT 1
33774: NEG
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 3
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 0
33794: PUSH
33795: LD_INT 3
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 2
33816: PUSH
33817: LD_INT 1
33819: NEG
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 3
33827: PUSH
33828: LD_INT 0
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 3
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: LD_INT 3
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: LD_INT 3
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: LD_INT 2
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 2
33878: NEG
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 3
33889: NEG
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 3
33900: NEG
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: LIST
33921: LIST
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33941: LD_ADDR_VAR 0 47
33945: PUSH
33946: LD_INT 0
33948: PUSH
33949: LD_INT 0
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 1
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 1
33979: PUSH
33980: LD_INT 1
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 0
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: LD_INT 0
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: LD_INT 1
34014: NEG
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 1
34022: NEG
34023: PUSH
34024: LD_INT 2
34026: NEG
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 0
34034: PUSH
34035: LD_INT 2
34037: NEG
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: PUSH
34046: LD_INT 1
34048: NEG
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: NEG
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 2
34068: NEG
34069: PUSH
34070: LD_INT 2
34072: NEG
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34092: LD_ADDR_VAR 0 48
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: LD_INT 1
34112: NEG
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 1
34120: PUSH
34121: LD_INT 0
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 1
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: LD_INT 0
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 1
34199: NEG
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 2
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 2
34217: PUSH
34218: LD_INT 1
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34239: LD_ADDR_VAR 0 49
34243: PUSH
34244: LD_INT 0
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 0
34256: PUSH
34257: LD_INT 1
34259: NEG
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 1
34267: PUSH
34268: LD_INT 0
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 0
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: NEG
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: PUSH
34332: LD_INT 0
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 2
34341: PUSH
34342: LD_INT 1
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 2
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 1
34361: PUSH
34362: LD_INT 2
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34383: LD_ADDR_VAR 0 50
34387: PUSH
34388: LD_INT 0
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 0
34400: PUSH
34401: LD_INT 1
34403: NEG
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: LD_INT 1
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 0
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 1
34441: NEG
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: NEG
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 1
34504: NEG
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: LIST
34524: LIST
34525: LIST
34526: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34527: LD_ADDR_VAR 0 51
34531: PUSH
34532: LD_INT 0
34534: PUSH
34535: LD_INT 0
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: LD_INT 1
34547: NEG
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: LD_INT 1
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: LD_INT 0
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: LD_INT 1
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 2
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 2
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 1
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 2
34639: NEG
34640: PUSH
34641: LD_INT 0
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 2
34650: NEG
34651: PUSH
34652: LD_INT 1
34654: NEG
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34674: LD_ADDR_VAR 0 52
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: LD_INT 0
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 0
34691: PUSH
34692: LD_INT 1
34694: NEG
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 2
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 2
34778: NEG
34779: PUSH
34780: LD_INT 0
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 2
34789: NEG
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 2
34801: NEG
34802: PUSH
34803: LD_INT 2
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34825: LD_ADDR_VAR 0 53
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: LD_INT 1
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: LD_INT 1
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: LD_INT 1
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: LD_INT 1
34898: NEG
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 1
34906: NEG
34907: PUSH
34908: LD_INT 2
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: LD_INT 1
34932: NEG
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: LD_INT 0
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 2
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 2
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: PUSH
34971: LD_INT 2
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: LD_INT 2
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 1
34990: NEG
34991: PUSH
34992: LD_INT 1
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 2
35001: NEG
35002: PUSH
35003: LD_INT 0
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 2
35012: NEG
35013: PUSH
35014: LD_INT 1
35016: NEG
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: LD_INT 2
35028: NEG
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35055: LD_ADDR_VAR 0 54
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 0
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 1
35083: PUSH
35084: LD_INT 0
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 1
35093: PUSH
35094: LD_INT 1
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: LD_INT 1
35128: NEG
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: LD_INT 2
35140: NEG
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 0
35148: PUSH
35149: LD_INT 2
35151: NEG
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 2
35170: PUSH
35171: LD_INT 0
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 2
35190: PUSH
35191: LD_INT 2
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 0
35210: PUSH
35211: LD_INT 2
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 2
35231: NEG
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: NEG
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 2
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35285: LD_ADDR_VAR 0 55
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 0
35378: PUSH
35379: LD_INT 2
35381: NEG
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 1
35389: PUSH
35390: LD_INT 1
35392: NEG
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PUSH
35398: LD_INT 2
35400: PUSH
35401: LD_INT 0
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 2
35410: PUSH
35411: LD_INT 1
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: PUSH
35421: LD_INT 2
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: LD_INT 2
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 2
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 2
35461: NEG
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: EMPTY
35467: LIST
35468: LIST
35469: PUSH
35470: LD_INT 2
35472: NEG
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: LD_INT 2
35488: NEG
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: LIST
35511: LIST
35512: LIST
35513: LIST
35514: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35515: LD_ADDR_VAR 0 56
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: LD_INT 0
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: LD_INT 1
35535: NEG
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: LD_INT 0
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 1
35553: PUSH
35554: LD_INT 1
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 0
35563: PUSH
35564: LD_INT 1
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 1
35573: NEG
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: NEG
35585: PUSH
35586: LD_INT 1
35588: NEG
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: LD_INT 2
35600: NEG
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 0
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 2
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: PUSH
35641: LD_INT 1
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 2
35650: PUSH
35651: LD_INT 2
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 1
35660: PUSH
35661: LD_INT 2
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: LD_INT 2
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 1
35680: NEG
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 2
35691: NEG
35692: PUSH
35693: LD_INT 0
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 2
35702: NEG
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: LD_INT 2
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35745: LD_ADDR_VAR 0 57
35749: PUSH
35750: LD_INT 0
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 0
35762: PUSH
35763: LD_INT 1
35765: NEG
35766: PUSH
35767: EMPTY
35768: LIST
35769: LIST
35770: PUSH
35771: LD_INT 1
35773: PUSH
35774: LD_INT 0
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 1
35783: PUSH
35784: LD_INT 1
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: LD_INT 1
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: LD_INT 0
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: LD_INT 1
35818: NEG
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: LD_INT 2
35830: NEG
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: LD_INT 2
35841: NEG
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 2
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 2
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 2
35880: PUSH
35881: LD_INT 2
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 1
35890: PUSH
35891: LD_INT 2
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: LD_INT 0
35900: PUSH
35901: LD_INT 2
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 2
35921: NEG
35922: PUSH
35923: LD_INT 0
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 2
35932: NEG
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: NEG
35945: PUSH
35946: LD_INT 2
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35975: LD_ADDR_VAR 0 58
35979: PUSH
35980: LD_INT 0
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 0
35992: PUSH
35993: LD_INT 1
35995: NEG
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 1
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 1
36013: PUSH
36014: LD_INT 1
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: LD_INT 1
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: NEG
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: NEG
36045: PUSH
36046: LD_INT 1
36048: NEG
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 1
36056: NEG
36057: PUSH
36058: LD_INT 2
36060: NEG
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: LD_INT 2
36071: NEG
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 1
36079: PUSH
36080: LD_INT 1
36082: NEG
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 2
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 2
36100: PUSH
36101: LD_INT 1
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 2
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: LD_INT 2
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: LD_INT 0
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 2
36162: NEG
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 2
36174: NEG
36175: PUSH
36176: LD_INT 2
36178: NEG
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36205: LD_ADDR_VAR 0 59
36209: PUSH
36210: LD_INT 0
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 0
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 1
36233: PUSH
36234: LD_INT 0
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 1
36243: PUSH
36244: LD_INT 1
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: LD_INT 1
36263: NEG
36264: PUSH
36265: LD_INT 0
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: NEG
36275: PUSH
36276: LD_INT 1
36278: NEG
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36293: LD_ADDR_VAR 0 60
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 1
36321: PUSH
36322: LD_INT 0
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: LD_INT 1
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: NEG
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 1
36362: NEG
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36381: LD_ADDR_VAR 0 61
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 0
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: LD_INT 1
36401: NEG
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 1
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 1
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: NEG
36451: PUSH
36452: LD_INT 1
36454: NEG
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36469: LD_ADDR_VAR 0 62
36473: PUSH
36474: LD_INT 0
36476: PUSH
36477: LD_INT 0
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 0
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 1
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 1
36507: PUSH
36508: LD_INT 1
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: LD_INT 1
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 1
36527: NEG
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 1
36538: NEG
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36557: LD_ADDR_VAR 0 63
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 1
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 0
36605: PUSH
36606: LD_INT 1
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 1
36626: NEG
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: LIST
36644: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36645: LD_ADDR_VAR 0 64
36649: PUSH
36650: LD_INT 0
36652: PUSH
36653: LD_INT 0
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: LD_INT 1
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: NEG
36715: PUSH
36716: LD_INT 1
36718: NEG
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: LIST
36730: LIST
36731: LIST
36732: ST_TO_ADDR
// end ; 1 :
36733: GO 42630
36735: LD_INT 1
36737: DOUBLE
36738: EQUAL
36739: IFTRUE 36743
36741: GO 39366
36743: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36744: LD_ADDR_VAR 0 11
36748: PUSH
36749: LD_INT 1
36751: NEG
36752: PUSH
36753: LD_INT 3
36755: NEG
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: LD_INT 3
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: PUSH
36775: LD_INT 2
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: LIST
36787: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36788: LD_ADDR_VAR 0 12
36792: PUSH
36793: LD_INT 2
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 3
36806: PUSH
36807: LD_INT 0
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 3
36816: PUSH
36817: LD_INT 1
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: LIST
36828: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36829: LD_ADDR_VAR 0 13
36833: PUSH
36834: LD_INT 3
36836: PUSH
36837: LD_INT 2
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 3
36846: PUSH
36847: LD_INT 3
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 2
36856: PUSH
36857: LD_INT 3
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: LIST
36868: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36869: LD_ADDR_VAR 0 14
36873: PUSH
36874: LD_INT 1
36876: PUSH
36877: LD_INT 3
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 0
36886: PUSH
36887: LD_INT 3
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: NEG
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: LIST
36909: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36910: LD_ADDR_VAR 0 15
36914: PUSH
36915: LD_INT 2
36917: NEG
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 3
36928: NEG
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 3
36939: NEG
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: LIST
36953: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36954: LD_ADDR_VAR 0 16
36958: PUSH
36959: LD_INT 2
36961: NEG
36962: PUSH
36963: LD_INT 3
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: NEG
36974: PUSH
36975: LD_INT 2
36977: NEG
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 3
36985: NEG
36986: PUSH
36987: LD_INT 3
36989: NEG
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: LIST
36999: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37000: LD_ADDR_VAR 0 17
37004: PUSH
37005: LD_INT 1
37007: NEG
37008: PUSH
37009: LD_INT 3
37011: NEG
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: LD_INT 3
37022: NEG
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: LD_INT 2
37033: NEG
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: LIST
37043: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37044: LD_ADDR_VAR 0 18
37048: PUSH
37049: LD_INT 2
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 3
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 3
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: LIST
37084: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37085: LD_ADDR_VAR 0 19
37089: PUSH
37090: LD_INT 3
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 3
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 2
37112: PUSH
37113: LD_INT 3
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: LIST
37124: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37125: LD_ADDR_VAR 0 20
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: LD_INT 3
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 3
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: LIST
37165: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37166: LD_ADDR_VAR 0 21
37170: PUSH
37171: LD_INT 2
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 3
37184: NEG
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 3
37195: NEG
37196: PUSH
37197: LD_INT 1
37199: NEG
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: LIST
37209: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37210: LD_ADDR_VAR 0 22
37214: PUSH
37215: LD_INT 2
37217: NEG
37218: PUSH
37219: LD_INT 3
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 3
37229: NEG
37230: PUSH
37231: LD_INT 2
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: LD_INT 3
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: LIST
37255: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37256: LD_ADDR_VAR 0 23
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: LD_INT 3
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 1
37274: NEG
37275: PUSH
37276: LD_INT 4
37278: NEG
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 1
37286: PUSH
37287: LD_INT 3
37289: NEG
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: LIST
37299: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37300: LD_ADDR_VAR 0 24
37304: PUSH
37305: LD_INT 3
37307: PUSH
37308: LD_INT 0
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 3
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 4
37328: PUSH
37329: LD_INT 1
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: LIST
37340: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37341: LD_ADDR_VAR 0 25
37345: PUSH
37346: LD_INT 3
37348: PUSH
37349: LD_INT 3
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 4
37358: PUSH
37359: LD_INT 3
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 3
37368: PUSH
37369: LD_INT 4
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: LIST
37380: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37381: LD_ADDR_VAR 0 26
37385: PUSH
37386: LD_INT 0
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: PUSH
37399: LD_INT 4
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 1
37408: NEG
37409: PUSH
37410: LD_INT 3
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: LIST
37421: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37422: LD_ADDR_VAR 0 27
37426: PUSH
37427: LD_INT 3
37429: NEG
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 3
37440: NEG
37441: PUSH
37442: LD_INT 1
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 4
37451: NEG
37452: PUSH
37453: LD_INT 1
37455: NEG
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: LIST
37465: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37466: LD_ADDR_VAR 0 28
37470: PUSH
37471: LD_INT 3
37473: NEG
37474: PUSH
37475: LD_INT 3
37477: NEG
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 3
37485: NEG
37486: PUSH
37487: LD_INT 4
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 4
37497: NEG
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: LIST
37511: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37512: LD_ADDR_VAR 0 29
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 3
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 4
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 0
37565: PUSH
37566: LD_INT 4
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: PUSH
37577: LD_INT 3
37579: NEG
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 1
37587: NEG
37588: PUSH
37589: LD_INT 5
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: LD_INT 5
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 1
37610: PUSH
37611: LD_INT 4
37613: NEG
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 1
37621: NEG
37622: PUSH
37623: LD_INT 6
37625: NEG
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 6
37636: NEG
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 5
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37667: LD_ADDR_VAR 0 30
37671: PUSH
37672: LD_INT 2
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 3
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 3
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 4
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 4
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 4
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 5
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 5
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 5
37767: PUSH
37768: LD_INT 1
37770: NEG
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 6
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 6
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37810: LD_ADDR_VAR 0 31
37814: PUSH
37815: LD_INT 3
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 3
37827: PUSH
37828: LD_INT 3
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 2
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 4
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 4
37857: PUSH
37858: LD_INT 4
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 3
37867: PUSH
37868: LD_INT 4
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 5
37877: PUSH
37878: LD_INT 4
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 5
37887: PUSH
37888: LD_INT 5
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 4
37897: PUSH
37898: LD_INT 5
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 6
37907: PUSH
37908: LD_INT 5
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 6
37917: PUSH
37918: LD_INT 6
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 5
37927: PUSH
37928: LD_INT 6
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
37949: LD_ADDR_VAR 0 32
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 0
37966: PUSH
37967: LD_INT 3
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 1
37976: NEG
37977: PUSH
37978: LD_INT 2
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: LD_INT 4
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 0
37997: PUSH
37998: LD_INT 4
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 1
38007: NEG
38008: PUSH
38009: LD_INT 3
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 1
38018: PUSH
38019: LD_INT 5
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 0
38028: PUSH
38029: LD_INT 5
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: NEG
38039: PUSH
38040: LD_INT 4
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 1
38049: PUSH
38050: LD_INT 6
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 0
38059: PUSH
38060: LD_INT 6
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 5
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38092: LD_ADDR_VAR 0 33
38096: PUSH
38097: LD_INT 2
38099: NEG
38100: PUSH
38101: LD_INT 1
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 3
38110: NEG
38111: PUSH
38112: LD_INT 0
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 3
38121: NEG
38122: PUSH
38123: LD_INT 1
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 3
38133: NEG
38134: PUSH
38135: LD_INT 1
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 4
38144: NEG
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 4
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: NEG
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 4
38167: NEG
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 5
38178: NEG
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 5
38189: NEG
38190: PUSH
38191: LD_INT 1
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 5
38201: NEG
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 6
38212: NEG
38213: PUSH
38214: LD_INT 0
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 6
38223: NEG
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38247: LD_ADDR_VAR 0 34
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: LD_INT 3
38258: NEG
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 3
38266: NEG
38267: PUSH
38268: LD_INT 2
38270: NEG
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 3
38278: NEG
38279: PUSH
38280: LD_INT 3
38282: NEG
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: NEG
38291: PUSH
38292: LD_INT 4
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 4
38302: NEG
38303: PUSH
38304: LD_INT 3
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: LD_INT 4
38314: NEG
38315: PUSH
38316: LD_INT 4
38318: NEG
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 4
38326: NEG
38327: PUSH
38328: LD_INT 5
38330: NEG
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 5
38338: NEG
38339: PUSH
38340: LD_INT 4
38342: NEG
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 5
38350: NEG
38351: PUSH
38352: LD_INT 5
38354: NEG
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 5
38362: NEG
38363: PUSH
38364: LD_INT 6
38366: NEG
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 6
38374: NEG
38375: PUSH
38376: LD_INT 5
38378: NEG
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 6
38386: NEG
38387: PUSH
38388: LD_INT 6
38390: NEG
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38410: LD_ADDR_VAR 0 41
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 1
38428: NEG
38429: PUSH
38430: LD_INT 3
38432: NEG
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: LIST
38453: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38454: LD_ADDR_VAR 0 42
38458: PUSH
38459: LD_INT 2
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 2
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 3
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: LIST
38494: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38495: LD_ADDR_VAR 0 43
38499: PUSH
38500: LD_INT 2
38502: PUSH
38503: LD_INT 2
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 3
38512: PUSH
38513: LD_INT 2
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 2
38522: PUSH
38523: LD_INT 3
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: LIST
38534: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38535: LD_ADDR_VAR 0 44
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 3
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 1
38562: NEG
38563: PUSH
38564: LD_INT 2
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: LIST
38575: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38576: LD_ADDR_VAR 0 45
38580: PUSH
38581: LD_INT 2
38583: NEG
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 2
38594: NEG
38595: PUSH
38596: LD_INT 1
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 3
38605: NEG
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: LIST
38619: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38620: LD_ADDR_VAR 0 46
38624: PUSH
38625: LD_INT 2
38627: NEG
38628: PUSH
38629: LD_INT 2
38631: NEG
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: LD_INT 3
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 3
38651: NEG
38652: PUSH
38653: LD_INT 2
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: LIST
38665: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38666: LD_ADDR_VAR 0 47
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 3
38677: NEG
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 1
38685: NEG
38686: PUSH
38687: LD_INT 3
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38699: LD_ADDR_VAR 0 48
38703: PUSH
38704: LD_INT 1
38706: PUSH
38707: LD_INT 2
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 2
38717: PUSH
38718: LD_INT 1
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38730: LD_ADDR_VAR 0 49
38734: PUSH
38735: LD_INT 3
38737: PUSH
38738: LD_INT 1
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 3
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38759: LD_ADDR_VAR 0 50
38763: PUSH
38764: LD_INT 2
38766: PUSH
38767: LD_INT 3
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 3
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38788: LD_ADDR_VAR 0 51
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: LD_INT 2
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 2
38806: NEG
38807: PUSH
38808: LD_INT 1
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38819: LD_ADDR_VAR 0 52
38823: PUSH
38824: LD_INT 3
38826: NEG
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 3
38838: NEG
38839: PUSH
38840: LD_INT 2
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38852: LD_ADDR_VAR 0 53
38856: PUSH
38857: LD_INT 1
38859: NEG
38860: PUSH
38861: LD_INT 3
38863: NEG
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 0
38871: PUSH
38872: LD_INT 3
38874: NEG
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 1
38882: PUSH
38883: LD_INT 2
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: LIST
38895: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38896: LD_ADDR_VAR 0 54
38900: PUSH
38901: LD_INT 2
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 3
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: LIST
38936: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38937: LD_ADDR_VAR 0 55
38941: PUSH
38942: LD_INT 3
38944: PUSH
38945: LD_INT 2
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 3
38954: PUSH
38955: LD_INT 3
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 3
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: LIST
38976: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38977: LD_ADDR_VAR 0 56
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 3
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 3
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 2
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: LIST
39017: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39018: LD_ADDR_VAR 0 57
39022: PUSH
39023: LD_INT 2
39025: NEG
39026: PUSH
39027: LD_INT 1
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 3
39036: NEG
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: NEG
39048: PUSH
39049: LD_INT 1
39051: NEG
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39062: LD_ADDR_VAR 0 58
39066: PUSH
39067: LD_INT 2
39069: NEG
39070: PUSH
39071: LD_INT 3
39073: NEG
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 3
39081: NEG
39082: PUSH
39083: LD_INT 2
39085: NEG
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 3
39093: NEG
39094: PUSH
39095: LD_INT 3
39097: NEG
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: LIST
39107: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39108: LD_ADDR_VAR 0 59
39112: PUSH
39113: LD_INT 1
39115: NEG
39116: PUSH
39117: LD_INT 2
39119: NEG
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 0
39127: PUSH
39128: LD_INT 2
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39152: LD_ADDR_VAR 0 60
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: LD_INT 1
39162: NEG
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 2
39170: PUSH
39171: LD_INT 0
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 2
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: LIST
39192: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39193: LD_ADDR_VAR 0 61
39197: PUSH
39198: LD_INT 2
39200: PUSH
39201: LD_INT 1
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: LD_INT 2
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 1
39220: PUSH
39221: LD_INT 2
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: LIST
39232: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39233: LD_ADDR_VAR 0 62
39237: PUSH
39238: LD_INT 1
39240: PUSH
39241: LD_INT 2
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 2
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: LD_INT 1
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: LIST
39273: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39274: LD_ADDR_VAR 0 63
39278: PUSH
39279: LD_INT 1
39281: NEG
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 2
39303: NEG
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: LIST
39317: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39318: LD_ADDR_VAR 0 64
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: LD_INT 2
39329: NEG
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 2
39337: NEG
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 2
39349: NEG
39350: PUSH
39351: LD_INT 2
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: LIST
39363: ST_TO_ADDR
// end ; 2 :
39364: GO 42630
39366: LD_INT 2
39368: DOUBLE
39369: EQUAL
39370: IFTRUE 39374
39372: GO 42629
39374: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39375: LD_ADDR_VAR 0 29
39379: PUSH
39380: LD_INT 4
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 4
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 5
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 5
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 4
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 3
39433: PUSH
39434: LD_INT 0
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 3
39443: PUSH
39444: LD_INT 1
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 3
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 5
39465: PUSH
39466: LD_INT 2
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 3
39475: PUSH
39476: LD_INT 3
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: LD_INT 2
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 4
39495: PUSH
39496: LD_INT 3
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 4
39505: PUSH
39506: LD_INT 4
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 3
39515: PUSH
39516: LD_INT 4
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: PUSH
39526: LD_INT 3
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 2
39535: PUSH
39536: LD_INT 2
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 4
39545: PUSH
39546: LD_INT 2
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 2
39555: PUSH
39556: LD_INT 4
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 0
39565: PUSH
39566: LD_INT 4
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 0
39575: PUSH
39576: LD_INT 3
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 1
39585: PUSH
39586: LD_INT 4
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 5
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_INT 5
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: LD_INT 4
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 3
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 2
39637: PUSH
39638: LD_INT 5
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 2
39647: NEG
39648: PUSH
39649: LD_INT 3
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 3
39658: NEG
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 3
39669: NEG
39670: PUSH
39671: LD_INT 1
39673: NEG
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: NEG
39682: PUSH
39683: LD_INT 0
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 2
39692: NEG
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 3
39703: NEG
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 4
39714: NEG
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 4
39725: NEG
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 4
39737: NEG
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 2
39749: NEG
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 4
39760: NEG
39761: PUSH
39762: LD_INT 4
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 4
39772: NEG
39773: PUSH
39774: LD_INT 5
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 3
39784: NEG
39785: PUSH
39786: LD_INT 4
39788: NEG
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 3
39796: NEG
39797: PUSH
39798: LD_INT 3
39800: NEG
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 4
39808: NEG
39809: PUSH
39810: LD_INT 3
39812: NEG
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 5
39820: NEG
39821: PUSH
39822: LD_INT 4
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 5
39832: NEG
39833: PUSH
39834: LD_INT 5
39836: NEG
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 3
39844: NEG
39845: PUSH
39846: LD_INT 5
39848: NEG
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 5
39856: NEG
39857: PUSH
39858: LD_INT 3
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
39913: LD_ADDR_VAR 0 30
39917: PUSH
39918: LD_INT 4
39920: PUSH
39921: LD_INT 4
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 4
39930: PUSH
39931: LD_INT 3
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 5
39940: PUSH
39941: LD_INT 4
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 5
39950: PUSH
39951: LD_INT 5
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 4
39960: PUSH
39961: LD_INT 5
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 3
39970: PUSH
39971: LD_INT 4
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: PUSH
39981: LD_INT 3
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 5
39990: PUSH
39991: LD_INT 3
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: LD_INT 5
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 0
40010: PUSH
40011: LD_INT 3
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 0
40020: PUSH
40021: LD_INT 2
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 1
40030: PUSH
40031: LD_INT 3
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 1
40040: PUSH
40041: LD_INT 4
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 0
40050: PUSH
40051: LD_INT 4
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 1
40060: NEG
40061: PUSH
40062: LD_INT 3
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 1
40071: NEG
40072: PUSH
40073: LD_INT 2
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: LD_INT 4
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 2
40092: NEG
40093: PUSH
40094: LD_INT 2
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 4
40103: NEG
40104: PUSH
40105: LD_INT 0
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 4
40114: NEG
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 3
40126: NEG
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 3
40137: NEG
40138: PUSH
40139: LD_INT 1
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 4
40148: NEG
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 5
40159: NEG
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 5
40170: NEG
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 5
40182: NEG
40183: PUSH
40184: LD_INT 2
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 3
40194: NEG
40195: PUSH
40196: LD_INT 2
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 3
40205: NEG
40206: PUSH
40207: LD_INT 3
40209: NEG
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 3
40217: NEG
40218: PUSH
40219: LD_INT 4
40221: NEG
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 2
40229: NEG
40230: PUSH
40231: LD_INT 3
40233: NEG
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 2
40241: NEG
40242: PUSH
40243: LD_INT 2
40245: NEG
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 3
40253: NEG
40254: PUSH
40255: LD_INT 2
40257: NEG
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 4
40265: NEG
40266: PUSH
40267: LD_INT 3
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 4
40277: NEG
40278: PUSH
40279: LD_INT 4
40281: NEG
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: NEG
40290: PUSH
40291: LD_INT 4
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 4
40301: NEG
40302: PUSH
40303: LD_INT 2
40305: NEG
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 4
40316: NEG
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: LD_INT 5
40327: NEG
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: LD_INT 4
40338: NEG
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 1
40346: PUSH
40347: LD_INT 3
40349: NEG
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 0
40357: PUSH
40358: LD_INT 3
40360: NEG
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 4
40372: NEG
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 1
40380: NEG
40381: PUSH
40382: LD_INT 5
40384: NEG
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PUSH
40390: LD_INT 2
40392: PUSH
40393: LD_INT 3
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 2
40403: NEG
40404: PUSH
40405: LD_INT 5
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: LIST
40430: LIST
40431: LIST
40432: LIST
40433: LIST
40434: LIST
40435: LIST
40436: LIST
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40460: LD_ADDR_VAR 0 31
40464: PUSH
40465: LD_INT 0
40467: PUSH
40468: LD_INT 4
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: LD_INT 3
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: PUSH
40488: LD_INT 4
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: LD_INT 5
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: LD_INT 5
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: NEG
40518: PUSH
40519: LD_INT 4
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: NEG
40529: PUSH
40530: LD_INT 3
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 2
40539: PUSH
40540: LD_INT 5
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 2
40549: NEG
40550: PUSH
40551: LD_INT 3
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 3
40560: NEG
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 3
40571: NEG
40572: PUSH
40573: LD_INT 1
40575: NEG
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 2
40583: NEG
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 2
40594: NEG
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 3
40605: NEG
40606: PUSH
40607: LD_INT 1
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 4
40616: NEG
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 4
40627: NEG
40628: PUSH
40629: LD_INT 1
40631: NEG
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 4
40639: NEG
40640: PUSH
40641: LD_INT 2
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 2
40651: NEG
40652: PUSH
40653: LD_INT 2
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 4
40662: NEG
40663: PUSH
40664: LD_INT 4
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 4
40674: NEG
40675: PUSH
40676: LD_INT 5
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 3
40686: NEG
40687: PUSH
40688: LD_INT 4
40690: NEG
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 3
40698: NEG
40699: PUSH
40700: LD_INT 3
40702: NEG
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 4
40710: NEG
40711: PUSH
40712: LD_INT 3
40714: NEG
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: LD_INT 5
40722: NEG
40723: PUSH
40724: LD_INT 4
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 5
40734: NEG
40735: PUSH
40736: LD_INT 5
40738: NEG
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 3
40746: NEG
40747: PUSH
40748: LD_INT 5
40750: NEG
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 5
40758: NEG
40759: PUSH
40760: LD_INT 3
40762: NEG
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: LD_INT 3
40773: NEG
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: LD_INT 4
40784: NEG
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: LD_INT 3
40795: NEG
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: LD_INT 2
40806: NEG
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: LD_INT 2
40817: NEG
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 3
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 1
40837: NEG
40838: PUSH
40839: LD_INT 4
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: LD_INT 2
40852: NEG
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 2
40860: NEG
40861: PUSH
40862: LD_INT 4
40864: NEG
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 4
40872: PUSH
40873: LD_INT 0
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 4
40882: PUSH
40883: LD_INT 1
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 5
40893: PUSH
40894: LD_INT 0
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 5
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 4
40913: PUSH
40914: LD_INT 1
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 3
40923: PUSH
40924: LD_INT 0
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 3
40933: PUSH
40934: LD_INT 1
40936: NEG
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 3
40944: PUSH
40945: LD_INT 2
40947: NEG
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 5
40955: PUSH
40956: LD_INT 2
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: LIST
40982: LIST
40983: LIST
40984: LIST
40985: LIST
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41010: LD_ADDR_VAR 0 32
41014: PUSH
41015: LD_INT 4
41017: NEG
41018: PUSH
41019: LD_INT 0
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 4
41028: NEG
41029: PUSH
41030: LD_INT 1
41032: NEG
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 3
41040: NEG
41041: PUSH
41042: LD_INT 0
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: NEG
41052: PUSH
41053: LD_INT 1
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 4
41062: NEG
41063: PUSH
41064: LD_INT 1
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 5
41073: NEG
41074: PUSH
41075: LD_INT 0
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 5
41084: NEG
41085: PUSH
41086: LD_INT 1
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 5
41096: NEG
41097: PUSH
41098: LD_INT 2
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 3
41108: NEG
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 3
41119: NEG
41120: PUSH
41121: LD_INT 3
41123: NEG
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 3
41131: NEG
41132: PUSH
41133: LD_INT 4
41135: NEG
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 2
41143: NEG
41144: PUSH
41145: LD_INT 3
41147: NEG
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 2
41155: NEG
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 4
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 4
41191: NEG
41192: PUSH
41193: LD_INT 4
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: LD_INT 4
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: LD_INT 4
41215: NEG
41216: PUSH
41217: LD_INT 2
41219: NEG
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 0
41227: PUSH
41228: LD_INT 4
41230: NEG
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 0
41238: PUSH
41239: LD_INT 5
41241: NEG
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 1
41249: PUSH
41250: LD_INT 4
41252: NEG
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 1
41260: PUSH
41261: LD_INT 3
41263: NEG
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: LD_INT 0
41271: PUSH
41272: LD_INT 3
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 1
41282: NEG
41283: PUSH
41284: LD_INT 4
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 1
41294: NEG
41295: PUSH
41296: LD_INT 5
41298: NEG
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 3
41309: NEG
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 2
41317: NEG
41318: PUSH
41319: LD_INT 5
41321: NEG
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 3
41329: PUSH
41330: LD_INT 0
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 3
41339: PUSH
41340: LD_INT 1
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 4
41360: PUSH
41361: LD_INT 1
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 3
41370: PUSH
41371: LD_INT 1
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 0
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 2
41390: PUSH
41391: LD_INT 1
41393: NEG
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 2
41401: PUSH
41402: LD_INT 2
41404: NEG
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 4
41412: PUSH
41413: LD_INT 2
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 4
41422: PUSH
41423: LD_INT 4
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 4
41432: PUSH
41433: LD_INT 3
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 5
41442: PUSH
41443: LD_INT 4
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 5
41452: PUSH
41453: LD_INT 5
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: LD_INT 5
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 3
41472: PUSH
41473: LD_INT 4
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 3
41482: PUSH
41483: LD_INT 3
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 5
41492: PUSH
41493: LD_INT 3
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 3
41502: PUSH
41503: LD_INT 5
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: LIST
41516: LIST
41517: LIST
41518: LIST
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41557: LD_ADDR_VAR 0 33
41561: PUSH
41562: LD_INT 4
41564: NEG
41565: PUSH
41566: LD_INT 4
41568: NEG
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 4
41576: NEG
41577: PUSH
41578: LD_INT 5
41580: NEG
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 3
41588: NEG
41589: PUSH
41590: LD_INT 4
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 3
41600: NEG
41601: PUSH
41602: LD_INT 3
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 4
41612: NEG
41613: PUSH
41614: LD_INT 3
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 5
41624: NEG
41625: PUSH
41626: LD_INT 4
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 5
41636: NEG
41637: PUSH
41638: LD_INT 5
41640: NEG
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 3
41648: NEG
41649: PUSH
41650: LD_INT 5
41652: NEG
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: LD_INT 5
41660: NEG
41661: PUSH
41662: LD_INT 3
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 0
41672: PUSH
41673: LD_INT 3
41675: NEG
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 0
41683: PUSH
41684: LD_INT 4
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 1
41694: PUSH
41695: LD_INT 3
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 2
41708: NEG
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 0
41716: PUSH
41717: LD_INT 2
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: LD_INT 3
41731: NEG
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 1
41739: NEG
41740: PUSH
41741: LD_INT 4
41743: NEG
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 2
41751: PUSH
41752: LD_INT 2
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 2
41762: NEG
41763: PUSH
41764: LD_INT 4
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 4
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 4
41784: PUSH
41785: LD_INT 1
41787: NEG
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 5
41795: PUSH
41796: LD_INT 0
41798: PUSH
41799: EMPTY
41800: LIST
41801: LIST
41802: PUSH
41803: LD_INT 5
41805: PUSH
41806: LD_INT 1
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 4
41815: PUSH
41816: LD_INT 1
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: PUSH
41823: LD_INT 3
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: PUSH
41833: LD_INT 3
41835: PUSH
41836: LD_INT 1
41838: NEG
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 3
41846: PUSH
41847: LD_INT 2
41849: NEG
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 5
41857: PUSH
41858: LD_INT 2
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: PUSH
41865: LD_INT 3
41867: PUSH
41868: LD_INT 3
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 3
41877: PUSH
41878: LD_INT 2
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 4
41887: PUSH
41888: LD_INT 3
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 4
41897: PUSH
41898: LD_INT 4
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 3
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 2
41917: PUSH
41918: LD_INT 3
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 2
41927: PUSH
41928: LD_INT 2
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: LD_INT 4
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 2
41947: PUSH
41948: LD_INT 4
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: LD_INT 4
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 0
41967: PUSH
41968: LD_INT 3
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 1
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: PUSH
41988: LD_INT 5
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 0
41997: PUSH
41998: LD_INT 5
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 1
42007: NEG
42008: PUSH
42009: LD_INT 4
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: LD_INT 3
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 2
42029: PUSH
42030: LD_INT 5
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 2
42039: NEG
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42095: LD_ADDR_VAR 0 34
42099: PUSH
42100: LD_INT 0
42102: PUSH
42103: LD_INT 4
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: LD_INT 5
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 1
42124: PUSH
42125: LD_INT 4
42127: NEG
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: LD_INT 3
42138: NEG
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 0
42146: PUSH
42147: LD_INT 3
42149: NEG
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 1
42157: NEG
42158: PUSH
42159: LD_INT 4
42161: NEG
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 1
42169: NEG
42170: PUSH
42171: LD_INT 5
42173: NEG
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: PUSH
42182: LD_INT 3
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 2
42192: NEG
42193: PUSH
42194: LD_INT 5
42196: NEG
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PUSH
42202: LD_INT 3
42204: PUSH
42205: LD_INT 0
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: LD_INT 1
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 4
42225: PUSH
42226: LD_INT 0
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 4
42235: PUSH
42236: LD_INT 1
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 3
42245: PUSH
42246: LD_INT 1
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 2
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 2
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 2
42276: PUSH
42277: LD_INT 2
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 4
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: PUSH
42298: LD_INT 4
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 4
42307: PUSH
42308: LD_INT 3
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 5
42317: PUSH
42318: LD_INT 4
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 5
42327: PUSH
42328: LD_INT 5
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 4
42337: PUSH
42338: LD_INT 5
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 3
42347: PUSH
42348: LD_INT 4
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 3
42357: PUSH
42358: LD_INT 3
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 5
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 3
42377: PUSH
42378: LD_INT 5
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 0
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 0
42397: PUSH
42398: LD_INT 2
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: LD_INT 3
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 1
42417: PUSH
42418: LD_INT 4
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 0
42427: PUSH
42428: LD_INT 4
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 1
42437: NEG
42438: PUSH
42439: LD_INT 3
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 1
42448: NEG
42449: PUSH
42450: LD_INT 2
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: PUSH
42457: LD_INT 2
42459: PUSH
42460: LD_INT 4
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: LD_INT 2
42469: NEG
42470: PUSH
42471: LD_INT 2
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 4
42480: NEG
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 4
42491: NEG
42492: PUSH
42493: LD_INT 1
42495: NEG
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 3
42503: NEG
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: NEG
42515: PUSH
42516: LD_INT 1
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 4
42525: NEG
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 5
42536: NEG
42537: PUSH
42538: LD_INT 0
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 5
42547: NEG
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 5
42559: NEG
42560: PUSH
42561: LD_INT 2
42563: NEG
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 3
42571: NEG
42572: PUSH
42573: LD_INT 2
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: LIST
42584: LIST
42585: LIST
42586: LIST
42587: LIST
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: ST_TO_ADDR
// end ; end ;
42627: GO 42630
42629: POP
// case btype of b_depot , b_warehouse :
42630: LD_VAR 0 1
42634: PUSH
42635: LD_INT 0
42637: DOUBLE
42638: EQUAL
42639: IFTRUE 42649
42641: LD_INT 1
42643: DOUBLE
42644: EQUAL
42645: IFTRUE 42649
42647: GO 42850
42649: POP
// case nation of nation_american :
42650: LD_VAR 0 5
42654: PUSH
42655: LD_INT 1
42657: DOUBLE
42658: EQUAL
42659: IFTRUE 42663
42661: GO 42719
42663: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42664: LD_ADDR_VAR 0 9
42668: PUSH
42669: LD_VAR 0 11
42673: PUSH
42674: LD_VAR 0 12
42678: PUSH
42679: LD_VAR 0 13
42683: PUSH
42684: LD_VAR 0 14
42688: PUSH
42689: LD_VAR 0 15
42693: PUSH
42694: LD_VAR 0 16
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: PUSH
42707: LD_VAR 0 4
42711: PUSH
42712: LD_INT 1
42714: PLUS
42715: ARRAY
42716: ST_TO_ADDR
42717: GO 42848
42719: LD_INT 2
42721: DOUBLE
42722: EQUAL
42723: IFTRUE 42727
42725: GO 42783
42727: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42728: LD_ADDR_VAR 0 9
42732: PUSH
42733: LD_VAR 0 17
42737: PUSH
42738: LD_VAR 0 18
42742: PUSH
42743: LD_VAR 0 19
42747: PUSH
42748: LD_VAR 0 20
42752: PUSH
42753: LD_VAR 0 21
42757: PUSH
42758: LD_VAR 0 22
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: PUSH
42771: LD_VAR 0 4
42775: PUSH
42776: LD_INT 1
42778: PLUS
42779: ARRAY
42780: ST_TO_ADDR
42781: GO 42848
42783: LD_INT 3
42785: DOUBLE
42786: EQUAL
42787: IFTRUE 42791
42789: GO 42847
42791: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42792: LD_ADDR_VAR 0 9
42796: PUSH
42797: LD_VAR 0 23
42801: PUSH
42802: LD_VAR 0 24
42806: PUSH
42807: LD_VAR 0 25
42811: PUSH
42812: LD_VAR 0 26
42816: PUSH
42817: LD_VAR 0 27
42821: PUSH
42822: LD_VAR 0 28
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: PUSH
42835: LD_VAR 0 4
42839: PUSH
42840: LD_INT 1
42842: PLUS
42843: ARRAY
42844: ST_TO_ADDR
42845: GO 42848
42847: POP
42848: GO 43403
42850: LD_INT 2
42852: DOUBLE
42853: EQUAL
42854: IFTRUE 42864
42856: LD_INT 3
42858: DOUBLE
42859: EQUAL
42860: IFTRUE 42864
42862: GO 42920
42864: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42865: LD_ADDR_VAR 0 9
42869: PUSH
42870: LD_VAR 0 29
42874: PUSH
42875: LD_VAR 0 30
42879: PUSH
42880: LD_VAR 0 31
42884: PUSH
42885: LD_VAR 0 32
42889: PUSH
42890: LD_VAR 0 33
42894: PUSH
42895: LD_VAR 0 34
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: LIST
42907: PUSH
42908: LD_VAR 0 4
42912: PUSH
42913: LD_INT 1
42915: PLUS
42916: ARRAY
42917: ST_TO_ADDR
42918: GO 43403
42920: LD_INT 16
42922: DOUBLE
42923: EQUAL
42924: IFTRUE 42982
42926: LD_INT 17
42928: DOUBLE
42929: EQUAL
42930: IFTRUE 42982
42932: LD_INT 18
42934: DOUBLE
42935: EQUAL
42936: IFTRUE 42982
42938: LD_INT 19
42940: DOUBLE
42941: EQUAL
42942: IFTRUE 42982
42944: LD_INT 22
42946: DOUBLE
42947: EQUAL
42948: IFTRUE 42982
42950: LD_INT 20
42952: DOUBLE
42953: EQUAL
42954: IFTRUE 42982
42956: LD_INT 21
42958: DOUBLE
42959: EQUAL
42960: IFTRUE 42982
42962: LD_INT 23
42964: DOUBLE
42965: EQUAL
42966: IFTRUE 42982
42968: LD_INT 24
42970: DOUBLE
42971: EQUAL
42972: IFTRUE 42982
42974: LD_INT 25
42976: DOUBLE
42977: EQUAL
42978: IFTRUE 42982
42980: GO 43038
42982: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
42983: LD_ADDR_VAR 0 9
42987: PUSH
42988: LD_VAR 0 35
42992: PUSH
42993: LD_VAR 0 36
42997: PUSH
42998: LD_VAR 0 37
43002: PUSH
43003: LD_VAR 0 38
43007: PUSH
43008: LD_VAR 0 39
43012: PUSH
43013: LD_VAR 0 40
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: PUSH
43026: LD_VAR 0 4
43030: PUSH
43031: LD_INT 1
43033: PLUS
43034: ARRAY
43035: ST_TO_ADDR
43036: GO 43403
43038: LD_INT 6
43040: DOUBLE
43041: EQUAL
43042: IFTRUE 43094
43044: LD_INT 7
43046: DOUBLE
43047: EQUAL
43048: IFTRUE 43094
43050: LD_INT 8
43052: DOUBLE
43053: EQUAL
43054: IFTRUE 43094
43056: LD_INT 13
43058: DOUBLE
43059: EQUAL
43060: IFTRUE 43094
43062: LD_INT 12
43064: DOUBLE
43065: EQUAL
43066: IFTRUE 43094
43068: LD_INT 15
43070: DOUBLE
43071: EQUAL
43072: IFTRUE 43094
43074: LD_INT 11
43076: DOUBLE
43077: EQUAL
43078: IFTRUE 43094
43080: LD_INT 14
43082: DOUBLE
43083: EQUAL
43084: IFTRUE 43094
43086: LD_INT 10
43088: DOUBLE
43089: EQUAL
43090: IFTRUE 43094
43092: GO 43150
43094: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43095: LD_ADDR_VAR 0 9
43099: PUSH
43100: LD_VAR 0 41
43104: PUSH
43105: LD_VAR 0 42
43109: PUSH
43110: LD_VAR 0 43
43114: PUSH
43115: LD_VAR 0 44
43119: PUSH
43120: LD_VAR 0 45
43124: PUSH
43125: LD_VAR 0 46
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: PUSH
43138: LD_VAR 0 4
43142: PUSH
43143: LD_INT 1
43145: PLUS
43146: ARRAY
43147: ST_TO_ADDR
43148: GO 43403
43150: LD_INT 36
43152: DOUBLE
43153: EQUAL
43154: IFTRUE 43158
43156: GO 43214
43158: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43159: LD_ADDR_VAR 0 9
43163: PUSH
43164: LD_VAR 0 47
43168: PUSH
43169: LD_VAR 0 48
43173: PUSH
43174: LD_VAR 0 49
43178: PUSH
43179: LD_VAR 0 50
43183: PUSH
43184: LD_VAR 0 51
43188: PUSH
43189: LD_VAR 0 52
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: PUSH
43202: LD_VAR 0 4
43206: PUSH
43207: LD_INT 1
43209: PLUS
43210: ARRAY
43211: ST_TO_ADDR
43212: GO 43403
43214: LD_INT 4
43216: DOUBLE
43217: EQUAL
43218: IFTRUE 43240
43220: LD_INT 5
43222: DOUBLE
43223: EQUAL
43224: IFTRUE 43240
43226: LD_INT 34
43228: DOUBLE
43229: EQUAL
43230: IFTRUE 43240
43232: LD_INT 37
43234: DOUBLE
43235: EQUAL
43236: IFTRUE 43240
43238: GO 43296
43240: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43241: LD_ADDR_VAR 0 9
43245: PUSH
43246: LD_VAR 0 53
43250: PUSH
43251: LD_VAR 0 54
43255: PUSH
43256: LD_VAR 0 55
43260: PUSH
43261: LD_VAR 0 56
43265: PUSH
43266: LD_VAR 0 57
43270: PUSH
43271: LD_VAR 0 58
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: LIST
43280: LIST
43281: LIST
43282: LIST
43283: PUSH
43284: LD_VAR 0 4
43288: PUSH
43289: LD_INT 1
43291: PLUS
43292: ARRAY
43293: ST_TO_ADDR
43294: GO 43403
43296: LD_INT 31
43298: DOUBLE
43299: EQUAL
43300: IFTRUE 43346
43302: LD_INT 32
43304: DOUBLE
43305: EQUAL
43306: IFTRUE 43346
43308: LD_INT 33
43310: DOUBLE
43311: EQUAL
43312: IFTRUE 43346
43314: LD_INT 27
43316: DOUBLE
43317: EQUAL
43318: IFTRUE 43346
43320: LD_INT 26
43322: DOUBLE
43323: EQUAL
43324: IFTRUE 43346
43326: LD_INT 28
43328: DOUBLE
43329: EQUAL
43330: IFTRUE 43346
43332: LD_INT 29
43334: DOUBLE
43335: EQUAL
43336: IFTRUE 43346
43338: LD_INT 30
43340: DOUBLE
43341: EQUAL
43342: IFTRUE 43346
43344: GO 43402
43346: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43347: LD_ADDR_VAR 0 9
43351: PUSH
43352: LD_VAR 0 59
43356: PUSH
43357: LD_VAR 0 60
43361: PUSH
43362: LD_VAR 0 61
43366: PUSH
43367: LD_VAR 0 62
43371: PUSH
43372: LD_VAR 0 63
43376: PUSH
43377: LD_VAR 0 64
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: PUSH
43390: LD_VAR 0 4
43394: PUSH
43395: LD_INT 1
43397: PLUS
43398: ARRAY
43399: ST_TO_ADDR
43400: GO 43403
43402: POP
// temp_list2 = [ ] ;
43403: LD_ADDR_VAR 0 10
43407: PUSH
43408: EMPTY
43409: ST_TO_ADDR
// for i in temp_list do
43410: LD_ADDR_VAR 0 8
43414: PUSH
43415: LD_VAR 0 9
43419: PUSH
43420: FOR_IN
43421: IFFALSE 43473
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43423: LD_ADDR_VAR 0 10
43427: PUSH
43428: LD_VAR 0 10
43432: PUSH
43433: LD_VAR 0 8
43437: PUSH
43438: LD_INT 1
43440: ARRAY
43441: PUSH
43442: LD_VAR 0 2
43446: PLUS
43447: PUSH
43448: LD_VAR 0 8
43452: PUSH
43453: LD_INT 2
43455: ARRAY
43456: PUSH
43457: LD_VAR 0 3
43461: PLUS
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: EMPTY
43468: LIST
43469: ADD
43470: ST_TO_ADDR
43471: GO 43420
43473: POP
43474: POP
// result = temp_list2 ;
43475: LD_ADDR_VAR 0 7
43479: PUSH
43480: LD_VAR 0 10
43484: ST_TO_ADDR
// end ;
43485: LD_VAR 0 7
43489: RET
// export function EnemyInRange ( unit , dist ) ; begin
43490: LD_INT 0
43492: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43493: LD_ADDR_VAR 0 3
43497: PUSH
43498: LD_VAR 0 1
43502: PPUSH
43503: CALL_OW 255
43507: PPUSH
43508: LD_VAR 0 1
43512: PPUSH
43513: CALL_OW 250
43517: PPUSH
43518: LD_VAR 0 1
43522: PPUSH
43523: CALL_OW 251
43527: PPUSH
43528: LD_VAR 0 2
43532: PPUSH
43533: CALL 16886 0 4
43537: PUSH
43538: LD_INT 4
43540: ARRAY
43541: ST_TO_ADDR
// end ;
43542: LD_VAR 0 3
43546: RET
// export function PlayerSeeMe ( unit ) ; begin
43547: LD_INT 0
43549: PPUSH
// result := See ( your_side , unit ) ;
43550: LD_ADDR_VAR 0 2
43554: PUSH
43555: LD_OWVAR 2
43559: PPUSH
43560: LD_VAR 0 1
43564: PPUSH
43565: CALL_OW 292
43569: ST_TO_ADDR
// end ;
43570: LD_VAR 0 2
43574: RET
// export function ReverseDir ( unit ) ; begin
43575: LD_INT 0
43577: PPUSH
// if not unit then
43578: LD_VAR 0 1
43582: NOT
43583: IFFALSE 43587
// exit ;
43585: GO 43610
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43587: LD_ADDR_VAR 0 2
43591: PUSH
43592: LD_VAR 0 1
43596: PPUSH
43597: CALL_OW 254
43601: PUSH
43602: LD_INT 3
43604: PLUS
43605: PUSH
43606: LD_INT 6
43608: MOD
43609: ST_TO_ADDR
// end ;
43610: LD_VAR 0 2
43614: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
43615: LD_INT 0
43617: PPUSH
43618: PPUSH
43619: PPUSH
43620: PPUSH
43621: PPUSH
// if not hexes then
43622: LD_VAR 0 2
43626: NOT
43627: IFFALSE 43631
// exit ;
43629: GO 43779
// dist := 9999 ;
43631: LD_ADDR_VAR 0 5
43635: PUSH
43636: LD_INT 9999
43638: ST_TO_ADDR
// for i = 1 to hexes do
43639: LD_ADDR_VAR 0 4
43643: PUSH
43644: DOUBLE
43645: LD_INT 1
43647: DEC
43648: ST_TO_ADDR
43649: LD_VAR 0 2
43653: PUSH
43654: FOR_TO
43655: IFFALSE 43767
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
43657: LD_VAR 0 1
43661: PPUSH
43662: LD_VAR 0 2
43666: PUSH
43667: LD_VAR 0 4
43671: ARRAY
43672: PUSH
43673: LD_INT 1
43675: ARRAY
43676: PPUSH
43677: LD_VAR 0 2
43681: PUSH
43682: LD_VAR 0 4
43686: ARRAY
43687: PUSH
43688: LD_INT 2
43690: ARRAY
43691: PPUSH
43692: CALL_OW 297
43696: PUSH
43697: LD_VAR 0 5
43701: LESS
43702: IFFALSE 43765
// begin hex := hexes [ i ] ;
43704: LD_ADDR_VAR 0 7
43708: PUSH
43709: LD_VAR 0 2
43713: PUSH
43714: LD_VAR 0 4
43718: ARRAY
43719: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43720: LD_ADDR_VAR 0 5
43724: PUSH
43725: LD_VAR 0 1
43729: PPUSH
43730: LD_VAR 0 2
43734: PUSH
43735: LD_VAR 0 4
43739: ARRAY
43740: PUSH
43741: LD_INT 1
43743: ARRAY
43744: PPUSH
43745: LD_VAR 0 2
43749: PUSH
43750: LD_VAR 0 4
43754: ARRAY
43755: PUSH
43756: LD_INT 2
43758: ARRAY
43759: PPUSH
43760: CALL_OW 297
43764: ST_TO_ADDR
// end ; end ;
43765: GO 43654
43767: POP
43768: POP
// result := hex ;
43769: LD_ADDR_VAR 0 3
43773: PUSH
43774: LD_VAR 0 7
43778: ST_TO_ADDR
// end ;
43779: LD_VAR 0 3
43783: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43784: LD_INT 0
43786: PPUSH
43787: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43788: LD_VAR 0 1
43792: NOT
43793: PUSH
43794: LD_VAR 0 1
43798: PUSH
43799: LD_INT 21
43801: PUSH
43802: LD_INT 2
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 23
43811: PUSH
43812: LD_INT 2
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PPUSH
43823: CALL_OW 69
43827: IN
43828: NOT
43829: OR
43830: IFFALSE 43834
// exit ;
43832: GO 43881
// for i = 1 to 3 do
43834: LD_ADDR_VAR 0 3
43838: PUSH
43839: DOUBLE
43840: LD_INT 1
43842: DEC
43843: ST_TO_ADDR
43844: LD_INT 3
43846: PUSH
43847: FOR_TO
43848: IFFALSE 43879
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
43850: LD_VAR 0 1
43854: PPUSH
43855: CALL_OW 250
43859: PPUSH
43860: LD_VAR 0 1
43864: PPUSH
43865: CALL_OW 251
43869: PPUSH
43870: LD_INT 1
43872: PPUSH
43873: CALL_OW 453
43877: GO 43847
43879: POP
43880: POP
// end ;
43881: LD_VAR 0 2
43885: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
43886: LD_INT 0
43888: PPUSH
43889: PPUSH
43890: PPUSH
43891: PPUSH
43892: PPUSH
43893: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
43894: LD_VAR 0 1
43898: NOT
43899: PUSH
43900: LD_VAR 0 2
43904: NOT
43905: OR
43906: PUSH
43907: LD_VAR 0 1
43911: PPUSH
43912: CALL_OW 314
43916: OR
43917: IFFALSE 43921
// exit ;
43919: GO 44362
// x := GetX ( enemy_unit ) ;
43921: LD_ADDR_VAR 0 7
43925: PUSH
43926: LD_VAR 0 2
43930: PPUSH
43931: CALL_OW 250
43935: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43936: LD_ADDR_VAR 0 8
43940: PUSH
43941: LD_VAR 0 2
43945: PPUSH
43946: CALL_OW 251
43950: ST_TO_ADDR
// if not x or not y then
43951: LD_VAR 0 7
43955: NOT
43956: PUSH
43957: LD_VAR 0 8
43961: NOT
43962: OR
43963: IFFALSE 43967
// exit ;
43965: GO 44362
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43967: LD_ADDR_VAR 0 6
43971: PUSH
43972: LD_VAR 0 7
43976: PPUSH
43977: LD_INT 0
43979: PPUSH
43980: LD_INT 4
43982: PPUSH
43983: CALL_OW 272
43987: PUSH
43988: LD_VAR 0 8
43992: PPUSH
43993: LD_INT 0
43995: PPUSH
43996: LD_INT 4
43998: PPUSH
43999: CALL_OW 273
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_VAR 0 7
44012: PPUSH
44013: LD_INT 1
44015: PPUSH
44016: LD_INT 4
44018: PPUSH
44019: CALL_OW 272
44023: PUSH
44024: LD_VAR 0 8
44028: PPUSH
44029: LD_INT 1
44031: PPUSH
44032: LD_INT 4
44034: PPUSH
44035: CALL_OW 273
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_VAR 0 7
44048: PPUSH
44049: LD_INT 2
44051: PPUSH
44052: LD_INT 4
44054: PPUSH
44055: CALL_OW 272
44059: PUSH
44060: LD_VAR 0 8
44064: PPUSH
44065: LD_INT 2
44067: PPUSH
44068: LD_INT 4
44070: PPUSH
44071: CALL_OW 273
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_VAR 0 7
44084: PPUSH
44085: LD_INT 3
44087: PPUSH
44088: LD_INT 4
44090: PPUSH
44091: CALL_OW 272
44095: PUSH
44096: LD_VAR 0 8
44100: PPUSH
44101: LD_INT 3
44103: PPUSH
44104: LD_INT 4
44106: PPUSH
44107: CALL_OW 273
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_VAR 0 7
44120: PPUSH
44121: LD_INT 4
44123: PPUSH
44124: LD_INT 4
44126: PPUSH
44127: CALL_OW 272
44131: PUSH
44132: LD_VAR 0 8
44136: PPUSH
44137: LD_INT 4
44139: PPUSH
44140: LD_INT 4
44142: PPUSH
44143: CALL_OW 273
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_VAR 0 7
44156: PPUSH
44157: LD_INT 5
44159: PPUSH
44160: LD_INT 4
44162: PPUSH
44163: CALL_OW 272
44167: PUSH
44168: LD_VAR 0 8
44172: PPUSH
44173: LD_INT 5
44175: PPUSH
44176: LD_INT 4
44178: PPUSH
44179: CALL_OW 273
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: LIST
44195: ST_TO_ADDR
// for i = tmp downto 1 do
44196: LD_ADDR_VAR 0 4
44200: PUSH
44201: DOUBLE
44202: LD_VAR 0 6
44206: INC
44207: ST_TO_ADDR
44208: LD_INT 1
44210: PUSH
44211: FOR_DOWNTO
44212: IFFALSE 44313
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44214: LD_VAR 0 6
44218: PUSH
44219: LD_VAR 0 4
44223: ARRAY
44224: PUSH
44225: LD_INT 1
44227: ARRAY
44228: PPUSH
44229: LD_VAR 0 6
44233: PUSH
44234: LD_VAR 0 4
44238: ARRAY
44239: PUSH
44240: LD_INT 2
44242: ARRAY
44243: PPUSH
44244: CALL_OW 488
44248: NOT
44249: PUSH
44250: LD_VAR 0 6
44254: PUSH
44255: LD_VAR 0 4
44259: ARRAY
44260: PUSH
44261: LD_INT 1
44263: ARRAY
44264: PPUSH
44265: LD_VAR 0 6
44269: PUSH
44270: LD_VAR 0 4
44274: ARRAY
44275: PUSH
44276: LD_INT 2
44278: ARRAY
44279: PPUSH
44280: CALL_OW 428
44284: PUSH
44285: LD_INT 0
44287: NONEQUAL
44288: OR
44289: IFFALSE 44311
// tmp := Delete ( tmp , i ) ;
44291: LD_ADDR_VAR 0 6
44295: PUSH
44296: LD_VAR 0 6
44300: PPUSH
44301: LD_VAR 0 4
44305: PPUSH
44306: CALL_OW 3
44310: ST_TO_ADDR
44311: GO 44211
44313: POP
44314: POP
// j := GetClosestHex ( unit , tmp ) ;
44315: LD_ADDR_VAR 0 5
44319: PUSH
44320: LD_VAR 0 1
44324: PPUSH
44325: LD_VAR 0 6
44329: PPUSH
44330: CALL 43615 0 2
44334: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44335: LD_VAR 0 1
44339: PPUSH
44340: LD_VAR 0 5
44344: PUSH
44345: LD_INT 1
44347: ARRAY
44348: PPUSH
44349: LD_VAR 0 5
44353: PUSH
44354: LD_INT 2
44356: ARRAY
44357: PPUSH
44358: CALL_OW 111
// end ;
44362: LD_VAR 0 3
44366: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44367: LD_INT 0
44369: PPUSH
44370: PPUSH
44371: PPUSH
// uc_side = 0 ;
44372: LD_ADDR_OWVAR 20
44376: PUSH
44377: LD_INT 0
44379: ST_TO_ADDR
// uc_nation = 0 ;
44380: LD_ADDR_OWVAR 21
44384: PUSH
44385: LD_INT 0
44387: ST_TO_ADDR
// InitHc_All ( ) ;
44388: CALL_OW 584
// InitVc ;
44392: CALL_OW 20
// if mastodonts then
44396: LD_VAR 0 6
44400: IFFALSE 44467
// for i = 1 to mastodonts do
44402: LD_ADDR_VAR 0 11
44406: PUSH
44407: DOUBLE
44408: LD_INT 1
44410: DEC
44411: ST_TO_ADDR
44412: LD_VAR 0 6
44416: PUSH
44417: FOR_TO
44418: IFFALSE 44465
// begin vc_chassis := 31 ;
44420: LD_ADDR_OWVAR 37
44424: PUSH
44425: LD_INT 31
44427: ST_TO_ADDR
// vc_control := control_rider ;
44428: LD_ADDR_OWVAR 38
44432: PUSH
44433: LD_INT 4
44435: ST_TO_ADDR
// animal := CreateVehicle ;
44436: LD_ADDR_VAR 0 12
44440: PUSH
44441: CALL_OW 45
44445: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44446: LD_VAR 0 12
44450: PPUSH
44451: LD_VAR 0 8
44455: PPUSH
44456: LD_INT 0
44458: PPUSH
44459: CALL 46655 0 3
// end ;
44463: GO 44417
44465: POP
44466: POP
// if horses then
44467: LD_VAR 0 5
44471: IFFALSE 44538
// for i = 1 to horses do
44473: LD_ADDR_VAR 0 11
44477: PUSH
44478: DOUBLE
44479: LD_INT 1
44481: DEC
44482: ST_TO_ADDR
44483: LD_VAR 0 5
44487: PUSH
44488: FOR_TO
44489: IFFALSE 44536
// begin hc_class := 21 ;
44491: LD_ADDR_OWVAR 28
44495: PUSH
44496: LD_INT 21
44498: ST_TO_ADDR
// hc_gallery :=  ;
44499: LD_ADDR_OWVAR 33
44503: PUSH
44504: LD_STRING 
44506: ST_TO_ADDR
// animal := CreateHuman ;
44507: LD_ADDR_VAR 0 12
44511: PUSH
44512: CALL_OW 44
44516: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44517: LD_VAR 0 12
44521: PPUSH
44522: LD_VAR 0 8
44526: PPUSH
44527: LD_INT 0
44529: PPUSH
44530: CALL 46655 0 3
// end ;
44534: GO 44488
44536: POP
44537: POP
// if birds then
44538: LD_VAR 0 1
44542: IFFALSE 44609
// for i = 1 to birds do
44544: LD_ADDR_VAR 0 11
44548: PUSH
44549: DOUBLE
44550: LD_INT 1
44552: DEC
44553: ST_TO_ADDR
44554: LD_VAR 0 1
44558: PUSH
44559: FOR_TO
44560: IFFALSE 44607
// begin hc_class = 18 ;
44562: LD_ADDR_OWVAR 28
44566: PUSH
44567: LD_INT 18
44569: ST_TO_ADDR
// hc_gallery =  ;
44570: LD_ADDR_OWVAR 33
44574: PUSH
44575: LD_STRING 
44577: ST_TO_ADDR
// animal := CreateHuman ;
44578: LD_ADDR_VAR 0 12
44582: PUSH
44583: CALL_OW 44
44587: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44588: LD_VAR 0 12
44592: PPUSH
44593: LD_VAR 0 8
44597: PPUSH
44598: LD_INT 0
44600: PPUSH
44601: CALL 46655 0 3
// end ;
44605: GO 44559
44607: POP
44608: POP
// if tigers then
44609: LD_VAR 0 2
44613: IFFALSE 44697
// for i = 1 to tigers do
44615: LD_ADDR_VAR 0 11
44619: PUSH
44620: DOUBLE
44621: LD_INT 1
44623: DEC
44624: ST_TO_ADDR
44625: LD_VAR 0 2
44629: PUSH
44630: FOR_TO
44631: IFFALSE 44695
// begin hc_class = class_tiger ;
44633: LD_ADDR_OWVAR 28
44637: PUSH
44638: LD_INT 14
44640: ST_TO_ADDR
// hc_gallery =  ;
44641: LD_ADDR_OWVAR 33
44645: PUSH
44646: LD_STRING 
44648: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44649: LD_ADDR_OWVAR 35
44653: PUSH
44654: LD_INT 7
44656: NEG
44657: PPUSH
44658: LD_INT 7
44660: PPUSH
44661: CALL_OW 12
44665: ST_TO_ADDR
// animal := CreateHuman ;
44666: LD_ADDR_VAR 0 12
44670: PUSH
44671: CALL_OW 44
44675: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44676: LD_VAR 0 12
44680: PPUSH
44681: LD_VAR 0 8
44685: PPUSH
44686: LD_INT 0
44688: PPUSH
44689: CALL 46655 0 3
// end ;
44693: GO 44630
44695: POP
44696: POP
// if apemans then
44697: LD_VAR 0 3
44701: IFFALSE 44824
// for i = 1 to apemans do
44703: LD_ADDR_VAR 0 11
44707: PUSH
44708: DOUBLE
44709: LD_INT 1
44711: DEC
44712: ST_TO_ADDR
44713: LD_VAR 0 3
44717: PUSH
44718: FOR_TO
44719: IFFALSE 44822
// begin hc_class = class_apeman ;
44721: LD_ADDR_OWVAR 28
44725: PUSH
44726: LD_INT 12
44728: ST_TO_ADDR
// hc_gallery =  ;
44729: LD_ADDR_OWVAR 33
44733: PUSH
44734: LD_STRING 
44736: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44737: LD_ADDR_OWVAR 35
44741: PUSH
44742: LD_INT 2
44744: NEG
44745: PPUSH
44746: LD_INT 2
44748: PPUSH
44749: CALL_OW 12
44753: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44754: LD_ADDR_OWVAR 31
44758: PUSH
44759: LD_INT 1
44761: PPUSH
44762: LD_INT 3
44764: PPUSH
44765: CALL_OW 12
44769: PUSH
44770: LD_INT 1
44772: PPUSH
44773: LD_INT 3
44775: PPUSH
44776: CALL_OW 12
44780: PUSH
44781: LD_INT 0
44783: PUSH
44784: LD_INT 0
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: ST_TO_ADDR
// animal := CreateHuman ;
44793: LD_ADDR_VAR 0 12
44797: PUSH
44798: CALL_OW 44
44802: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44803: LD_VAR 0 12
44807: PPUSH
44808: LD_VAR 0 8
44812: PPUSH
44813: LD_INT 0
44815: PPUSH
44816: CALL 46655 0 3
// end ;
44820: GO 44718
44822: POP
44823: POP
// if enchidnas then
44824: LD_VAR 0 4
44828: IFFALSE 44895
// for i = 1 to enchidnas do
44830: LD_ADDR_VAR 0 11
44834: PUSH
44835: DOUBLE
44836: LD_INT 1
44838: DEC
44839: ST_TO_ADDR
44840: LD_VAR 0 4
44844: PUSH
44845: FOR_TO
44846: IFFALSE 44893
// begin hc_class = 13 ;
44848: LD_ADDR_OWVAR 28
44852: PUSH
44853: LD_INT 13
44855: ST_TO_ADDR
// hc_gallery =  ;
44856: LD_ADDR_OWVAR 33
44860: PUSH
44861: LD_STRING 
44863: ST_TO_ADDR
// animal := CreateHuman ;
44864: LD_ADDR_VAR 0 12
44868: PUSH
44869: CALL_OW 44
44873: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44874: LD_VAR 0 12
44878: PPUSH
44879: LD_VAR 0 8
44883: PPUSH
44884: LD_INT 0
44886: PPUSH
44887: CALL 46655 0 3
// end ;
44891: GO 44845
44893: POP
44894: POP
// if fishes then
44895: LD_VAR 0 7
44899: IFFALSE 44966
// for i = 1 to fishes do
44901: LD_ADDR_VAR 0 11
44905: PUSH
44906: DOUBLE
44907: LD_INT 1
44909: DEC
44910: ST_TO_ADDR
44911: LD_VAR 0 7
44915: PUSH
44916: FOR_TO
44917: IFFALSE 44964
// begin hc_class = 20 ;
44919: LD_ADDR_OWVAR 28
44923: PUSH
44924: LD_INT 20
44926: ST_TO_ADDR
// hc_gallery =  ;
44927: LD_ADDR_OWVAR 33
44931: PUSH
44932: LD_STRING 
44934: ST_TO_ADDR
// animal := CreateHuman ;
44935: LD_ADDR_VAR 0 12
44939: PUSH
44940: CALL_OW 44
44944: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44945: LD_VAR 0 12
44949: PPUSH
44950: LD_VAR 0 9
44954: PPUSH
44955: LD_INT 0
44957: PPUSH
44958: CALL 46655 0 3
// end ;
44962: GO 44916
44964: POP
44965: POP
// end ;
44966: LD_VAR 0 10
44970: RET
// export function WantHeal ( sci , unit ) ; begin
44971: LD_INT 0
44973: PPUSH
// if GetTaskList ( sci ) > 0 then
44974: LD_VAR 0 1
44978: PPUSH
44979: CALL_OW 437
44983: PUSH
44984: LD_INT 0
44986: GREATER
44987: IFFALSE 45057
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44989: LD_VAR 0 1
44993: PPUSH
44994: CALL_OW 437
44998: PUSH
44999: LD_INT 1
45001: ARRAY
45002: PUSH
45003: LD_INT 1
45005: ARRAY
45006: PUSH
45007: LD_STRING l
45009: EQUAL
45010: PUSH
45011: LD_VAR 0 1
45015: PPUSH
45016: CALL_OW 437
45020: PUSH
45021: LD_INT 1
45023: ARRAY
45024: PUSH
45025: LD_INT 4
45027: ARRAY
45028: PUSH
45029: LD_VAR 0 2
45033: EQUAL
45034: AND
45035: IFFALSE 45047
// result := true else
45037: LD_ADDR_VAR 0 3
45041: PUSH
45042: LD_INT 1
45044: ST_TO_ADDR
45045: GO 45055
// result := false ;
45047: LD_ADDR_VAR 0 3
45051: PUSH
45052: LD_INT 0
45054: ST_TO_ADDR
// end else
45055: GO 45065
// result := false ;
45057: LD_ADDR_VAR 0 3
45061: PUSH
45062: LD_INT 0
45064: ST_TO_ADDR
// end ;
45065: LD_VAR 0 3
45069: RET
// export function HealTarget ( sci ) ; begin
45070: LD_INT 0
45072: PPUSH
// if not sci then
45073: LD_VAR 0 1
45077: NOT
45078: IFFALSE 45082
// exit ;
45080: GO 45147
// result := 0 ;
45082: LD_ADDR_VAR 0 2
45086: PUSH
45087: LD_INT 0
45089: ST_TO_ADDR
// if GetTaskList ( sci ) then
45090: LD_VAR 0 1
45094: PPUSH
45095: CALL_OW 437
45099: IFFALSE 45147
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45101: LD_VAR 0 1
45105: PPUSH
45106: CALL_OW 437
45110: PUSH
45111: LD_INT 1
45113: ARRAY
45114: PUSH
45115: LD_INT 1
45117: ARRAY
45118: PUSH
45119: LD_STRING l
45121: EQUAL
45122: IFFALSE 45147
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45124: LD_ADDR_VAR 0 2
45128: PUSH
45129: LD_VAR 0 1
45133: PPUSH
45134: CALL_OW 437
45138: PUSH
45139: LD_INT 1
45141: ARRAY
45142: PUSH
45143: LD_INT 4
45145: ARRAY
45146: ST_TO_ADDR
// end ;
45147: LD_VAR 0 2
45151: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45152: LD_INT 0
45154: PPUSH
45155: PPUSH
45156: PPUSH
45157: PPUSH
// if not base_units then
45158: LD_VAR 0 1
45162: NOT
45163: IFFALSE 45167
// exit ;
45165: GO 45254
// result := false ;
45167: LD_ADDR_VAR 0 2
45171: PUSH
45172: LD_INT 0
45174: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45175: LD_ADDR_VAR 0 5
45179: PUSH
45180: LD_VAR 0 1
45184: PPUSH
45185: LD_INT 21
45187: PUSH
45188: LD_INT 3
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PPUSH
45195: CALL_OW 72
45199: ST_TO_ADDR
// if not tmp then
45200: LD_VAR 0 5
45204: NOT
45205: IFFALSE 45209
// exit ;
45207: GO 45254
// for i in tmp do
45209: LD_ADDR_VAR 0 3
45213: PUSH
45214: LD_VAR 0 5
45218: PUSH
45219: FOR_IN
45220: IFFALSE 45252
// begin result := EnemyInRange ( i , 22 ) ;
45222: LD_ADDR_VAR 0 2
45226: PUSH
45227: LD_VAR 0 3
45231: PPUSH
45232: LD_INT 22
45234: PPUSH
45235: CALL 43490 0 2
45239: ST_TO_ADDR
// if result then
45240: LD_VAR 0 2
45244: IFFALSE 45250
// exit ;
45246: POP
45247: POP
45248: GO 45254
// end ;
45250: GO 45219
45252: POP
45253: POP
// end ;
45254: LD_VAR 0 2
45258: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
45259: LD_INT 0
45261: PPUSH
45262: PPUSH
// if not units then
45263: LD_VAR 0 1
45267: NOT
45268: IFFALSE 45272
// exit ;
45270: GO 45342
// result := [ ] ;
45272: LD_ADDR_VAR 0 3
45276: PUSH
45277: EMPTY
45278: ST_TO_ADDR
// for i in units do
45279: LD_ADDR_VAR 0 4
45283: PUSH
45284: LD_VAR 0 1
45288: PUSH
45289: FOR_IN
45290: IFFALSE 45340
// if GetTag ( i ) = tag then
45292: LD_VAR 0 4
45296: PPUSH
45297: CALL_OW 110
45301: PUSH
45302: LD_VAR 0 2
45306: EQUAL
45307: IFFALSE 45338
// result := Replace ( result , result + 1 , i ) ;
45309: LD_ADDR_VAR 0 3
45313: PUSH
45314: LD_VAR 0 3
45318: PPUSH
45319: LD_VAR 0 3
45323: PUSH
45324: LD_INT 1
45326: PLUS
45327: PPUSH
45328: LD_VAR 0 4
45332: PPUSH
45333: CALL_OW 1
45337: ST_TO_ADDR
45338: GO 45289
45340: POP
45341: POP
// end ;
45342: LD_VAR 0 3
45346: RET
// export function IsDriver ( un ) ; begin
45347: LD_INT 0
45349: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
45350: LD_ADDR_VAR 0 2
45354: PUSH
45355: LD_VAR 0 1
45359: PUSH
45360: LD_INT 55
45362: PUSH
45363: EMPTY
45364: LIST
45365: PPUSH
45366: CALL_OW 69
45370: IN
45371: ST_TO_ADDR
// end ;
45372: LD_VAR 0 2
45376: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
45377: LD_INT 0
45379: PPUSH
45380: PPUSH
// list := [ ] ;
45381: LD_ADDR_VAR 0 5
45385: PUSH
45386: EMPTY
45387: ST_TO_ADDR
// case d of 0 :
45388: LD_VAR 0 3
45392: PUSH
45393: LD_INT 0
45395: DOUBLE
45396: EQUAL
45397: IFTRUE 45401
45399: GO 45534
45401: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
45402: LD_ADDR_VAR 0 5
45406: PUSH
45407: LD_VAR 0 1
45411: PUSH
45412: LD_INT 4
45414: MINUS
45415: PUSH
45416: LD_VAR 0 2
45420: PUSH
45421: LD_INT 4
45423: MINUS
45424: PUSH
45425: LD_INT 2
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: LIST
45432: PUSH
45433: LD_VAR 0 1
45437: PUSH
45438: LD_INT 3
45440: MINUS
45441: PUSH
45442: LD_VAR 0 2
45446: PUSH
45447: LD_INT 1
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: LIST
45454: PUSH
45455: LD_VAR 0 1
45459: PUSH
45460: LD_INT 4
45462: PLUS
45463: PUSH
45464: LD_VAR 0 2
45468: PUSH
45469: LD_INT 4
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: LIST
45476: PUSH
45477: LD_VAR 0 1
45481: PUSH
45482: LD_INT 3
45484: PLUS
45485: PUSH
45486: LD_VAR 0 2
45490: PUSH
45491: LD_INT 3
45493: PLUS
45494: PUSH
45495: LD_INT 5
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: PUSH
45503: LD_VAR 0 1
45507: PUSH
45508: LD_VAR 0 2
45512: PUSH
45513: LD_INT 4
45515: PLUS
45516: PUSH
45517: LD_INT 0
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: LIST
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: ST_TO_ADDR
// end ; 1 :
45532: GO 46232
45534: LD_INT 1
45536: DOUBLE
45537: EQUAL
45538: IFTRUE 45542
45540: GO 45675
45542: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45543: LD_ADDR_VAR 0 5
45547: PUSH
45548: LD_VAR 0 1
45552: PUSH
45553: LD_VAR 0 2
45557: PUSH
45558: LD_INT 4
45560: MINUS
45561: PUSH
45562: LD_INT 3
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: LIST
45569: PUSH
45570: LD_VAR 0 1
45574: PUSH
45575: LD_INT 3
45577: MINUS
45578: PUSH
45579: LD_VAR 0 2
45583: PUSH
45584: LD_INT 3
45586: MINUS
45587: PUSH
45588: LD_INT 2
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: LIST
45595: PUSH
45596: LD_VAR 0 1
45600: PUSH
45601: LD_INT 4
45603: MINUS
45604: PUSH
45605: LD_VAR 0 2
45609: PUSH
45610: LD_INT 1
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: LIST
45617: PUSH
45618: LD_VAR 0 1
45622: PUSH
45623: LD_VAR 0 2
45627: PUSH
45628: LD_INT 3
45630: PLUS
45631: PUSH
45632: LD_INT 0
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: LIST
45639: PUSH
45640: LD_VAR 0 1
45644: PUSH
45645: LD_INT 4
45647: PLUS
45648: PUSH
45649: LD_VAR 0 2
45653: PUSH
45654: LD_INT 4
45656: PLUS
45657: PUSH
45658: LD_INT 5
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: ST_TO_ADDR
// end ; 2 :
45673: GO 46232
45675: LD_INT 2
45677: DOUBLE
45678: EQUAL
45679: IFTRUE 45683
45681: GO 45812
45683: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45684: LD_ADDR_VAR 0 5
45688: PUSH
45689: LD_VAR 0 1
45693: PUSH
45694: LD_VAR 0 2
45698: PUSH
45699: LD_INT 3
45701: MINUS
45702: PUSH
45703: LD_INT 3
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: LIST
45710: PUSH
45711: LD_VAR 0 1
45715: PUSH
45716: LD_INT 4
45718: PLUS
45719: PUSH
45720: LD_VAR 0 2
45724: PUSH
45725: LD_INT 4
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: PUSH
45733: LD_VAR 0 1
45737: PUSH
45738: LD_VAR 0 2
45742: PUSH
45743: LD_INT 4
45745: PLUS
45746: PUSH
45747: LD_INT 0
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: LIST
45754: PUSH
45755: LD_VAR 0 1
45759: PUSH
45760: LD_INT 3
45762: MINUS
45763: PUSH
45764: LD_VAR 0 2
45768: PUSH
45769: LD_INT 1
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: LIST
45776: PUSH
45777: LD_VAR 0 1
45781: PUSH
45782: LD_INT 4
45784: MINUS
45785: PUSH
45786: LD_VAR 0 2
45790: PUSH
45791: LD_INT 4
45793: MINUS
45794: PUSH
45795: LD_INT 2
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: LIST
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: ST_TO_ADDR
// end ; 3 :
45810: GO 46232
45812: LD_INT 3
45814: DOUBLE
45815: EQUAL
45816: IFTRUE 45820
45818: GO 45953
45820: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45821: LD_ADDR_VAR 0 5
45825: PUSH
45826: LD_VAR 0 1
45830: PUSH
45831: LD_INT 3
45833: PLUS
45834: PUSH
45835: LD_VAR 0 2
45839: PUSH
45840: LD_INT 4
45842: PUSH
45843: EMPTY
45844: LIST
45845: LIST
45846: LIST
45847: PUSH
45848: LD_VAR 0 1
45852: PUSH
45853: LD_INT 4
45855: PLUS
45856: PUSH
45857: LD_VAR 0 2
45861: PUSH
45862: LD_INT 4
45864: PLUS
45865: PUSH
45866: LD_INT 5
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: LIST
45873: PUSH
45874: LD_VAR 0 1
45878: PUSH
45879: LD_INT 4
45881: MINUS
45882: PUSH
45883: LD_VAR 0 2
45887: PUSH
45888: LD_INT 1
45890: PUSH
45891: EMPTY
45892: LIST
45893: LIST
45894: LIST
45895: PUSH
45896: LD_VAR 0 1
45900: PUSH
45901: LD_VAR 0 2
45905: PUSH
45906: LD_INT 4
45908: MINUS
45909: PUSH
45910: LD_INT 3
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: LIST
45917: PUSH
45918: LD_VAR 0 1
45922: PUSH
45923: LD_INT 3
45925: MINUS
45926: PUSH
45927: LD_VAR 0 2
45931: PUSH
45932: LD_INT 3
45934: MINUS
45935: PUSH
45936: LD_INT 2
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: LIST
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: ST_TO_ADDR
// end ; 4 :
45951: GO 46232
45953: LD_INT 4
45955: DOUBLE
45956: EQUAL
45957: IFTRUE 45961
45959: GO 46094
45961: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45962: LD_ADDR_VAR 0 5
45966: PUSH
45967: LD_VAR 0 1
45971: PUSH
45972: LD_VAR 0 2
45976: PUSH
45977: LD_INT 4
45979: PLUS
45980: PUSH
45981: LD_INT 0
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: LIST
45988: PUSH
45989: LD_VAR 0 1
45993: PUSH
45994: LD_INT 3
45996: PLUS
45997: PUSH
45998: LD_VAR 0 2
46002: PUSH
46003: LD_INT 3
46005: PLUS
46006: PUSH
46007: LD_INT 5
46009: PUSH
46010: EMPTY
46011: LIST
46012: LIST
46013: LIST
46014: PUSH
46015: LD_VAR 0 1
46019: PUSH
46020: LD_INT 4
46022: PLUS
46023: PUSH
46024: LD_VAR 0 2
46028: PUSH
46029: LD_INT 4
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: LIST
46036: PUSH
46037: LD_VAR 0 1
46041: PUSH
46042: LD_VAR 0 2
46046: PUSH
46047: LD_INT 3
46049: MINUS
46050: PUSH
46051: LD_INT 3
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: LIST
46058: PUSH
46059: LD_VAR 0 1
46063: PUSH
46064: LD_INT 4
46066: MINUS
46067: PUSH
46068: LD_VAR 0 2
46072: PUSH
46073: LD_INT 4
46075: MINUS
46076: PUSH
46077: LD_INT 2
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: LIST
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: ST_TO_ADDR
// end ; 5 :
46092: GO 46232
46094: LD_INT 5
46096: DOUBLE
46097: EQUAL
46098: IFTRUE 46102
46100: GO 46231
46102: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46103: LD_ADDR_VAR 0 5
46107: PUSH
46108: LD_VAR 0 1
46112: PUSH
46113: LD_INT 4
46115: MINUS
46116: PUSH
46117: LD_VAR 0 2
46121: PUSH
46122: LD_INT 1
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: LIST
46129: PUSH
46130: LD_VAR 0 1
46134: PUSH
46135: LD_VAR 0 2
46139: PUSH
46140: LD_INT 4
46142: MINUS
46143: PUSH
46144: LD_INT 3
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: LIST
46151: PUSH
46152: LD_VAR 0 1
46156: PUSH
46157: LD_INT 4
46159: PLUS
46160: PUSH
46161: LD_VAR 0 2
46165: PUSH
46166: LD_INT 4
46168: PLUS
46169: PUSH
46170: LD_INT 5
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: LIST
46177: PUSH
46178: LD_VAR 0 1
46182: PUSH
46183: LD_INT 3
46185: PLUS
46186: PUSH
46187: LD_VAR 0 2
46191: PUSH
46192: LD_INT 4
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: LIST
46199: PUSH
46200: LD_VAR 0 1
46204: PUSH
46205: LD_VAR 0 2
46209: PUSH
46210: LD_INT 3
46212: PLUS
46213: PUSH
46214: LD_INT 0
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: LIST
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: ST_TO_ADDR
// end ; end ;
46229: GO 46232
46231: POP
// result := list ;
46232: LD_ADDR_VAR 0 4
46236: PUSH
46237: LD_VAR 0 5
46241: ST_TO_ADDR
// end ;
46242: LD_VAR 0 4
46246: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46247: LD_INT 0
46249: PPUSH
46250: PPUSH
46251: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46252: LD_VAR 0 1
46256: NOT
46257: PUSH
46258: LD_VAR 0 2
46262: PUSH
46263: LD_INT 1
46265: PUSH
46266: LD_INT 2
46268: PUSH
46269: LD_INT 3
46271: PUSH
46272: LD_INT 4
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: LIST
46279: LIST
46280: IN
46281: NOT
46282: OR
46283: IFFALSE 46287
// exit ;
46285: GO 46379
// tmp := [ ] ;
46287: LD_ADDR_VAR 0 5
46291: PUSH
46292: EMPTY
46293: ST_TO_ADDR
// for i in units do
46294: LD_ADDR_VAR 0 4
46298: PUSH
46299: LD_VAR 0 1
46303: PUSH
46304: FOR_IN
46305: IFFALSE 46348
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
46307: LD_ADDR_VAR 0 5
46311: PUSH
46312: LD_VAR 0 5
46316: PPUSH
46317: LD_VAR 0 5
46321: PUSH
46322: LD_INT 1
46324: PLUS
46325: PPUSH
46326: LD_VAR 0 4
46330: PPUSH
46331: LD_VAR 0 2
46335: PPUSH
46336: CALL_OW 259
46340: PPUSH
46341: CALL_OW 2
46345: ST_TO_ADDR
46346: GO 46304
46348: POP
46349: POP
// if not tmp then
46350: LD_VAR 0 5
46354: NOT
46355: IFFALSE 46359
// exit ;
46357: GO 46379
// result := SortListByListDesc ( units , tmp ) ;
46359: LD_ADDR_VAR 0 3
46363: PUSH
46364: LD_VAR 0 1
46368: PPUSH
46369: LD_VAR 0 5
46373: PPUSH
46374: CALL_OW 77
46378: ST_TO_ADDR
// end ;
46379: LD_VAR 0 3
46383: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
46384: LD_INT 0
46386: PPUSH
46387: PPUSH
46388: PPUSH
// result := false ;
46389: LD_ADDR_VAR 0 3
46393: PUSH
46394: LD_INT 0
46396: ST_TO_ADDR
// x := GetX ( building ) ;
46397: LD_ADDR_VAR 0 4
46401: PUSH
46402: LD_VAR 0 2
46406: PPUSH
46407: CALL_OW 250
46411: ST_TO_ADDR
// y := GetY ( building ) ;
46412: LD_ADDR_VAR 0 5
46416: PUSH
46417: LD_VAR 0 2
46421: PPUSH
46422: CALL_OW 251
46426: ST_TO_ADDR
// if not building or not x or not y then
46427: LD_VAR 0 2
46431: NOT
46432: PUSH
46433: LD_VAR 0 4
46437: NOT
46438: OR
46439: PUSH
46440: LD_VAR 0 5
46444: NOT
46445: OR
46446: IFFALSE 46450
// exit ;
46448: GO 46542
// if GetTaskList ( unit ) then
46450: LD_VAR 0 1
46454: PPUSH
46455: CALL_OW 437
46459: IFFALSE 46542
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46461: LD_STRING e
46463: PUSH
46464: LD_VAR 0 1
46468: PPUSH
46469: CALL_OW 437
46473: PUSH
46474: LD_INT 1
46476: ARRAY
46477: PUSH
46478: LD_INT 1
46480: ARRAY
46481: EQUAL
46482: PUSH
46483: LD_VAR 0 4
46487: PUSH
46488: LD_VAR 0 1
46492: PPUSH
46493: CALL_OW 437
46497: PUSH
46498: LD_INT 1
46500: ARRAY
46501: PUSH
46502: LD_INT 2
46504: ARRAY
46505: EQUAL
46506: AND
46507: PUSH
46508: LD_VAR 0 5
46512: PUSH
46513: LD_VAR 0 1
46517: PPUSH
46518: CALL_OW 437
46522: PUSH
46523: LD_INT 1
46525: ARRAY
46526: PUSH
46527: LD_INT 3
46529: ARRAY
46530: EQUAL
46531: AND
46532: IFFALSE 46542
// result := true end ;
46534: LD_ADDR_VAR 0 3
46538: PUSH
46539: LD_INT 1
46541: ST_TO_ADDR
// end ;
46542: LD_VAR 0 3
46546: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46547: LD_INT 0
46549: PPUSH
// result := false ;
46550: LD_ADDR_VAR 0 4
46554: PUSH
46555: LD_INT 0
46557: ST_TO_ADDR
// if GetTaskList ( unit ) then
46558: LD_VAR 0 1
46562: PPUSH
46563: CALL_OW 437
46567: IFFALSE 46650
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46569: LD_STRING M
46571: PUSH
46572: LD_VAR 0 1
46576: PPUSH
46577: CALL_OW 437
46581: PUSH
46582: LD_INT 1
46584: ARRAY
46585: PUSH
46586: LD_INT 1
46588: ARRAY
46589: EQUAL
46590: PUSH
46591: LD_VAR 0 2
46595: PUSH
46596: LD_VAR 0 1
46600: PPUSH
46601: CALL_OW 437
46605: PUSH
46606: LD_INT 1
46608: ARRAY
46609: PUSH
46610: LD_INT 2
46612: ARRAY
46613: EQUAL
46614: AND
46615: PUSH
46616: LD_VAR 0 3
46620: PUSH
46621: LD_VAR 0 1
46625: PPUSH
46626: CALL_OW 437
46630: PUSH
46631: LD_INT 1
46633: ARRAY
46634: PUSH
46635: LD_INT 3
46637: ARRAY
46638: EQUAL
46639: AND
46640: IFFALSE 46650
// result := true ;
46642: LD_ADDR_VAR 0 4
46646: PUSH
46647: LD_INT 1
46649: ST_TO_ADDR
// end ; end ;
46650: LD_VAR 0 4
46654: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46655: LD_INT 0
46657: PPUSH
46658: PPUSH
46659: PPUSH
46660: PPUSH
// if not unit or not area then
46661: LD_VAR 0 1
46665: NOT
46666: PUSH
46667: LD_VAR 0 2
46671: NOT
46672: OR
46673: IFFALSE 46677
// exit ;
46675: GO 46841
// tmp := AreaToList ( area , i ) ;
46677: LD_ADDR_VAR 0 6
46681: PUSH
46682: LD_VAR 0 2
46686: PPUSH
46687: LD_VAR 0 5
46691: PPUSH
46692: CALL_OW 517
46696: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46697: LD_ADDR_VAR 0 5
46701: PUSH
46702: DOUBLE
46703: LD_INT 1
46705: DEC
46706: ST_TO_ADDR
46707: LD_VAR 0 6
46711: PUSH
46712: LD_INT 1
46714: ARRAY
46715: PUSH
46716: FOR_TO
46717: IFFALSE 46839
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46719: LD_ADDR_VAR 0 7
46723: PUSH
46724: LD_VAR 0 6
46728: PUSH
46729: LD_INT 1
46731: ARRAY
46732: PUSH
46733: LD_VAR 0 5
46737: ARRAY
46738: PUSH
46739: LD_VAR 0 6
46743: PUSH
46744: LD_INT 2
46746: ARRAY
46747: PUSH
46748: LD_VAR 0 5
46752: ARRAY
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46758: LD_VAR 0 7
46762: PUSH
46763: LD_INT 1
46765: ARRAY
46766: PPUSH
46767: LD_VAR 0 7
46771: PUSH
46772: LD_INT 2
46774: ARRAY
46775: PPUSH
46776: CALL_OW 428
46780: PUSH
46781: LD_INT 0
46783: EQUAL
46784: IFFALSE 46837
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46786: LD_VAR 0 1
46790: PPUSH
46791: LD_VAR 0 7
46795: PUSH
46796: LD_INT 1
46798: ARRAY
46799: PPUSH
46800: LD_VAR 0 7
46804: PUSH
46805: LD_INT 2
46807: ARRAY
46808: PPUSH
46809: LD_VAR 0 3
46813: PPUSH
46814: CALL_OW 48
// result := IsPlaced ( unit ) ;
46818: LD_ADDR_VAR 0 4
46822: PUSH
46823: LD_VAR 0 1
46827: PPUSH
46828: CALL_OW 305
46832: ST_TO_ADDR
// exit ;
46833: POP
46834: POP
46835: GO 46841
// end ; end ;
46837: GO 46716
46839: POP
46840: POP
// end ;
46841: LD_VAR 0 4
46845: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46846: LD_INT 0
46848: PPUSH
46849: PPUSH
46850: PPUSH
// if not side or side > 8 then
46851: LD_VAR 0 1
46855: NOT
46856: PUSH
46857: LD_VAR 0 1
46861: PUSH
46862: LD_INT 8
46864: GREATER
46865: OR
46866: IFFALSE 46870
// exit ;
46868: GO 47057
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46870: LD_ADDR_VAR 0 4
46874: PUSH
46875: LD_INT 22
46877: PUSH
46878: LD_VAR 0 1
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: PUSH
46887: LD_INT 21
46889: PUSH
46890: LD_INT 3
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PPUSH
46901: CALL_OW 69
46905: ST_TO_ADDR
// if not tmp then
46906: LD_VAR 0 4
46910: NOT
46911: IFFALSE 46915
// exit ;
46913: GO 47057
// enable_addtolog := true ;
46915: LD_ADDR_OWVAR 81
46919: PUSH
46920: LD_INT 1
46922: ST_TO_ADDR
// AddToLog ( [ ) ;
46923: LD_STRING [
46925: PPUSH
46926: CALL_OW 561
// for i in tmp do
46930: LD_ADDR_VAR 0 3
46934: PUSH
46935: LD_VAR 0 4
46939: PUSH
46940: FOR_IN
46941: IFFALSE 47048
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46943: LD_STRING [
46945: PUSH
46946: LD_VAR 0 3
46950: PPUSH
46951: CALL_OW 266
46955: STR
46956: PUSH
46957: LD_STRING , 
46959: STR
46960: PUSH
46961: LD_VAR 0 3
46965: PPUSH
46966: CALL_OW 250
46970: STR
46971: PUSH
46972: LD_STRING , 
46974: STR
46975: PUSH
46976: LD_VAR 0 3
46980: PPUSH
46981: CALL_OW 251
46985: STR
46986: PUSH
46987: LD_STRING , 
46989: STR
46990: PUSH
46991: LD_VAR 0 3
46995: PPUSH
46996: CALL_OW 254
47000: STR
47001: PUSH
47002: LD_STRING , 
47004: STR
47005: PUSH
47006: LD_VAR 0 3
47010: PPUSH
47011: LD_INT 1
47013: PPUSH
47014: CALL_OW 268
47018: STR
47019: PUSH
47020: LD_STRING , 
47022: STR
47023: PUSH
47024: LD_VAR 0 3
47028: PPUSH
47029: LD_INT 2
47031: PPUSH
47032: CALL_OW 268
47036: STR
47037: PUSH
47038: LD_STRING ],
47040: STR
47041: PPUSH
47042: CALL_OW 561
// end ;
47046: GO 46940
47048: POP
47049: POP
// AddToLog ( ]; ) ;
47050: LD_STRING ];
47052: PPUSH
47053: CALL_OW 561
// end ;
47057: LD_VAR 0 2
47061: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47062: LD_INT 0
47064: PPUSH
47065: PPUSH
47066: PPUSH
47067: PPUSH
47068: PPUSH
// if not area or not rate or not max then
47069: LD_VAR 0 1
47073: NOT
47074: PUSH
47075: LD_VAR 0 2
47079: NOT
47080: OR
47081: PUSH
47082: LD_VAR 0 4
47086: NOT
47087: OR
47088: IFFALSE 47092
// exit ;
47090: GO 47284
// while 1 do
47092: LD_INT 1
47094: IFFALSE 47284
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47096: LD_ADDR_VAR 0 9
47100: PUSH
47101: LD_VAR 0 1
47105: PPUSH
47106: LD_INT 1
47108: PPUSH
47109: CALL_OW 287
47113: PUSH
47114: LD_INT 10
47116: MUL
47117: ST_TO_ADDR
// r := rate / 10 ;
47118: LD_ADDR_VAR 0 7
47122: PUSH
47123: LD_VAR 0 2
47127: PUSH
47128: LD_INT 10
47130: DIVREAL
47131: ST_TO_ADDR
// time := 1 1$00 ;
47132: LD_ADDR_VAR 0 8
47136: PUSH
47137: LD_INT 2100
47139: ST_TO_ADDR
// if amount < min then
47140: LD_VAR 0 9
47144: PUSH
47145: LD_VAR 0 3
47149: LESS
47150: IFFALSE 47168
// r := r * 2 else
47152: LD_ADDR_VAR 0 7
47156: PUSH
47157: LD_VAR 0 7
47161: PUSH
47162: LD_INT 2
47164: MUL
47165: ST_TO_ADDR
47166: GO 47194
// if amount > max then
47168: LD_VAR 0 9
47172: PUSH
47173: LD_VAR 0 4
47177: GREATER
47178: IFFALSE 47194
// r := r / 2 ;
47180: LD_ADDR_VAR 0 7
47184: PUSH
47185: LD_VAR 0 7
47189: PUSH
47190: LD_INT 2
47192: DIVREAL
47193: ST_TO_ADDR
// time := time / r ;
47194: LD_ADDR_VAR 0 8
47198: PUSH
47199: LD_VAR 0 8
47203: PUSH
47204: LD_VAR 0 7
47208: DIVREAL
47209: ST_TO_ADDR
// if time < 0 then
47210: LD_VAR 0 8
47214: PUSH
47215: LD_INT 0
47217: LESS
47218: IFFALSE 47235
// time := time * - 1 ;
47220: LD_ADDR_VAR 0 8
47224: PUSH
47225: LD_VAR 0 8
47229: PUSH
47230: LD_INT 1
47232: NEG
47233: MUL
47234: ST_TO_ADDR
// wait ( time ) ;
47235: LD_VAR 0 8
47239: PPUSH
47240: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
47244: LD_INT 35
47246: PPUSH
47247: LD_INT 875
47249: PPUSH
47250: CALL_OW 12
47254: PPUSH
47255: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47259: LD_INT 1
47261: PPUSH
47262: LD_INT 5
47264: PPUSH
47265: CALL_OW 12
47269: PPUSH
47270: LD_VAR 0 1
47274: PPUSH
47275: LD_INT 1
47277: PPUSH
47278: CALL_OW 55
// end ;
47282: GO 47092
// end ;
47284: LD_VAR 0 5
47288: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47289: LD_INT 0
47291: PPUSH
47292: PPUSH
47293: PPUSH
47294: PPUSH
47295: PPUSH
47296: PPUSH
47297: PPUSH
47298: PPUSH
// if not turrets or not factories then
47299: LD_VAR 0 1
47303: NOT
47304: PUSH
47305: LD_VAR 0 2
47309: NOT
47310: OR
47311: IFFALSE 47315
// exit ;
47313: GO 47622
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47315: LD_ADDR_VAR 0 10
47319: PUSH
47320: LD_INT 5
47322: PUSH
47323: LD_INT 6
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PUSH
47330: LD_INT 2
47332: PUSH
47333: LD_INT 4
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PUSH
47340: LD_INT 3
47342: PUSH
47343: LD_INT 5
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 24
47357: PUSH
47358: LD_INT 25
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 23
47367: PUSH
47368: LD_INT 27
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: PUSH
47379: LD_INT 42
47381: PUSH
47382: LD_INT 43
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: LD_INT 44
47391: PUSH
47392: LD_INT 46
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: PUSH
47399: LD_INT 45
47401: PUSH
47402: LD_INT 47
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: EMPTY
47410: LIST
47411: LIST
47412: LIST
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: LIST
47418: ST_TO_ADDR
// result := [ ] ;
47419: LD_ADDR_VAR 0 3
47423: PUSH
47424: EMPTY
47425: ST_TO_ADDR
// for i in turrets do
47426: LD_ADDR_VAR 0 4
47430: PUSH
47431: LD_VAR 0 1
47435: PUSH
47436: FOR_IN
47437: IFFALSE 47620
// begin nat := GetNation ( i ) ;
47439: LD_ADDR_VAR 0 7
47443: PUSH
47444: LD_VAR 0 4
47448: PPUSH
47449: CALL_OW 248
47453: ST_TO_ADDR
// weapon := 0 ;
47454: LD_ADDR_VAR 0 8
47458: PUSH
47459: LD_INT 0
47461: ST_TO_ADDR
// if not nat then
47462: LD_VAR 0 7
47466: NOT
47467: IFFALSE 47471
// continue ;
47469: GO 47436
// for j in list [ nat ] do
47471: LD_ADDR_VAR 0 5
47475: PUSH
47476: LD_VAR 0 10
47480: PUSH
47481: LD_VAR 0 7
47485: ARRAY
47486: PUSH
47487: FOR_IN
47488: IFFALSE 47529
// if GetBWeapon ( i ) = j [ 1 ] then
47490: LD_VAR 0 4
47494: PPUSH
47495: CALL_OW 269
47499: PUSH
47500: LD_VAR 0 5
47504: PUSH
47505: LD_INT 1
47507: ARRAY
47508: EQUAL
47509: IFFALSE 47527
// begin weapon := j [ 2 ] ;
47511: LD_ADDR_VAR 0 8
47515: PUSH
47516: LD_VAR 0 5
47520: PUSH
47521: LD_INT 2
47523: ARRAY
47524: ST_TO_ADDR
// break ;
47525: GO 47529
// end ;
47527: GO 47487
47529: POP
47530: POP
// if not weapon then
47531: LD_VAR 0 8
47535: NOT
47536: IFFALSE 47540
// continue ;
47538: GO 47436
// for k in factories do
47540: LD_ADDR_VAR 0 6
47544: PUSH
47545: LD_VAR 0 2
47549: PUSH
47550: FOR_IN
47551: IFFALSE 47616
// begin weapons := AvailableWeaponList ( k ) ;
47553: LD_ADDR_VAR 0 9
47557: PUSH
47558: LD_VAR 0 6
47562: PPUSH
47563: CALL_OW 478
47567: ST_TO_ADDR
// if not weapons then
47568: LD_VAR 0 9
47572: NOT
47573: IFFALSE 47577
// continue ;
47575: GO 47550
// if weapon in weapons then
47577: LD_VAR 0 8
47581: PUSH
47582: LD_VAR 0 9
47586: IN
47587: IFFALSE 47614
// begin result := [ i , weapon ] ;
47589: LD_ADDR_VAR 0 3
47593: PUSH
47594: LD_VAR 0 4
47598: PUSH
47599: LD_VAR 0 8
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: ST_TO_ADDR
// exit ;
47608: POP
47609: POP
47610: POP
47611: POP
47612: GO 47622
// end ; end ;
47614: GO 47550
47616: POP
47617: POP
// end ;
47618: GO 47436
47620: POP
47621: POP
// end ;
47622: LD_VAR 0 3
47626: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47627: LD_INT 0
47629: PPUSH
// if not side or side > 8 then
47630: LD_VAR 0 3
47634: NOT
47635: PUSH
47636: LD_VAR 0 3
47640: PUSH
47641: LD_INT 8
47643: GREATER
47644: OR
47645: IFFALSE 47649
// exit ;
47647: GO 47708
// if not range then
47649: LD_VAR 0 4
47653: NOT
47654: IFFALSE 47665
// range := - 12 ;
47656: LD_ADDR_VAR 0 4
47660: PUSH
47661: LD_INT 12
47663: NEG
47664: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47665: LD_VAR 0 1
47669: PPUSH
47670: LD_VAR 0 2
47674: PPUSH
47675: LD_VAR 0 3
47679: PPUSH
47680: LD_VAR 0 4
47684: PPUSH
47685: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47689: LD_VAR 0 1
47693: PPUSH
47694: LD_VAR 0 2
47698: PPUSH
47699: LD_VAR 0 3
47703: PPUSH
47704: CALL_OW 331
// end ;
47708: LD_VAR 0 5
47712: RET
// export function Video ( mode ) ; begin
47713: LD_INT 0
47715: PPUSH
// ingame_video = mode ;
47716: LD_ADDR_OWVAR 52
47720: PUSH
47721: LD_VAR 0 1
47725: ST_TO_ADDR
// interface_hidden = mode ;
47726: LD_ADDR_OWVAR 54
47730: PUSH
47731: LD_VAR 0 1
47735: ST_TO_ADDR
// end ;
47736: LD_VAR 0 2
47740: RET
// export function Join ( array , element ) ; begin
47741: LD_INT 0
47743: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47744: LD_ADDR_VAR 0 3
47748: PUSH
47749: LD_VAR 0 1
47753: PPUSH
47754: LD_VAR 0 1
47758: PUSH
47759: LD_INT 1
47761: PLUS
47762: PPUSH
47763: LD_VAR 0 2
47767: PPUSH
47768: CALL_OW 1
47772: ST_TO_ADDR
// end ;
47773: LD_VAR 0 3
47777: RET
// export function JoinUnion ( array , element ) ; begin
47778: LD_INT 0
47780: PPUSH
// result := array union element ;
47781: LD_ADDR_VAR 0 3
47785: PUSH
47786: LD_VAR 0 1
47790: PUSH
47791: LD_VAR 0 2
47795: UNION
47796: ST_TO_ADDR
// end ;
47797: LD_VAR 0 3
47801: RET
// export function GetBehemoths ( side ) ; begin
47802: LD_INT 0
47804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
47805: LD_ADDR_VAR 0 2
47809: PUSH
47810: LD_INT 22
47812: PUSH
47813: LD_VAR 0 1
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: PUSH
47822: LD_INT 31
47824: PUSH
47825: LD_INT 25
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PPUSH
47836: CALL_OW 69
47840: ST_TO_ADDR
// end ;
47841: LD_VAR 0 2
47845: RET
// export function Shuffle ( array ) ; var i , index ; begin
47846: LD_INT 0
47848: PPUSH
47849: PPUSH
47850: PPUSH
// result := [ ] ;
47851: LD_ADDR_VAR 0 2
47855: PUSH
47856: EMPTY
47857: ST_TO_ADDR
// if not array then
47858: LD_VAR 0 1
47862: NOT
47863: IFFALSE 47867
// exit ;
47865: GO 47966
// Randomize ;
47867: CALL_OW 10
// for i = array downto 1 do
47871: LD_ADDR_VAR 0 3
47875: PUSH
47876: DOUBLE
47877: LD_VAR 0 1
47881: INC
47882: ST_TO_ADDR
47883: LD_INT 1
47885: PUSH
47886: FOR_DOWNTO
47887: IFFALSE 47964
// begin index := rand ( 1 , array ) ;
47889: LD_ADDR_VAR 0 4
47893: PUSH
47894: LD_INT 1
47896: PPUSH
47897: LD_VAR 0 1
47901: PPUSH
47902: CALL_OW 12
47906: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47907: LD_ADDR_VAR 0 2
47911: PUSH
47912: LD_VAR 0 2
47916: PPUSH
47917: LD_VAR 0 2
47921: PUSH
47922: LD_INT 1
47924: PLUS
47925: PPUSH
47926: LD_VAR 0 1
47930: PUSH
47931: LD_VAR 0 4
47935: ARRAY
47936: PPUSH
47937: CALL_OW 2
47941: ST_TO_ADDR
// array := Delete ( array , index ) ;
47942: LD_ADDR_VAR 0 1
47946: PUSH
47947: LD_VAR 0 1
47951: PPUSH
47952: LD_VAR 0 4
47956: PPUSH
47957: CALL_OW 3
47961: ST_TO_ADDR
// end ;
47962: GO 47886
47964: POP
47965: POP
// end ;
47966: LD_VAR 0 2
47970: RET
// export function GetBaseMaterials ( base ) ; begin
47971: LD_INT 0
47973: PPUSH
// result := [ 0 , 0 , 0 ] ;
47974: LD_ADDR_VAR 0 2
47978: PUSH
47979: LD_INT 0
47981: PUSH
47982: LD_INT 0
47984: PUSH
47985: LD_INT 0
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: LIST
47992: ST_TO_ADDR
// if not base then
47993: LD_VAR 0 1
47997: NOT
47998: IFFALSE 48002
// exit ;
48000: GO 48051
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48002: LD_ADDR_VAR 0 2
48006: PUSH
48007: LD_VAR 0 1
48011: PPUSH
48012: LD_INT 1
48014: PPUSH
48015: CALL_OW 275
48019: PUSH
48020: LD_VAR 0 1
48024: PPUSH
48025: LD_INT 2
48027: PPUSH
48028: CALL_OW 275
48032: PUSH
48033: LD_VAR 0 1
48037: PPUSH
48038: LD_INT 3
48040: PPUSH
48041: CALL_OW 275
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: LIST
48050: ST_TO_ADDR
// end ;
48051: LD_VAR 0 2
48055: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48056: LD_INT 0
48058: PPUSH
48059: PPUSH
// result := array ;
48060: LD_ADDR_VAR 0 3
48064: PUSH
48065: LD_VAR 0 1
48069: ST_TO_ADDR
// if size > 0 then
48070: LD_VAR 0 2
48074: PUSH
48075: LD_INT 0
48077: GREATER
48078: IFFALSE 48124
// for i := array downto size do
48080: LD_ADDR_VAR 0 4
48084: PUSH
48085: DOUBLE
48086: LD_VAR 0 1
48090: INC
48091: ST_TO_ADDR
48092: LD_VAR 0 2
48096: PUSH
48097: FOR_DOWNTO
48098: IFFALSE 48122
// result := Delete ( result , result ) ;
48100: LD_ADDR_VAR 0 3
48104: PUSH
48105: LD_VAR 0 3
48109: PPUSH
48110: LD_VAR 0 3
48114: PPUSH
48115: CALL_OW 3
48119: ST_TO_ADDR
48120: GO 48097
48122: POP
48123: POP
// end ;
48124: LD_VAR 0 3
48128: RET
// export function ComExit ( unit ) ; var tmp ; begin
48129: LD_INT 0
48131: PPUSH
48132: PPUSH
// if not IsInUnit ( unit ) then
48133: LD_VAR 0 1
48137: PPUSH
48138: CALL_OW 310
48142: NOT
48143: IFFALSE 48147
// exit ;
48145: GO 48207
// tmp := IsInUnit ( unit ) ;
48147: LD_ADDR_VAR 0 3
48151: PUSH
48152: LD_VAR 0 1
48156: PPUSH
48157: CALL_OW 310
48161: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48162: LD_VAR 0 3
48166: PPUSH
48167: CALL_OW 247
48171: PUSH
48172: LD_INT 2
48174: EQUAL
48175: IFFALSE 48188
// ComExitVehicle ( unit ) else
48177: LD_VAR 0 1
48181: PPUSH
48182: CALL_OW 121
48186: GO 48197
// ComExitBuilding ( unit ) ;
48188: LD_VAR 0 1
48192: PPUSH
48193: CALL_OW 122
// result := tmp ;
48197: LD_ADDR_VAR 0 2
48201: PUSH
48202: LD_VAR 0 3
48206: ST_TO_ADDR
// end ;
48207: LD_VAR 0 2
48211: RET
// export function ComExitAll ( units ) ; var i ; begin
48212: LD_INT 0
48214: PPUSH
48215: PPUSH
// if not units then
48216: LD_VAR 0 1
48220: NOT
48221: IFFALSE 48225
// exit ;
48223: GO 48251
// for i in units do
48225: LD_ADDR_VAR 0 3
48229: PUSH
48230: LD_VAR 0 1
48234: PUSH
48235: FOR_IN
48236: IFFALSE 48249
// ComExit ( i ) ;
48238: LD_VAR 0 3
48242: PPUSH
48243: CALL 48129 0 1
48247: GO 48235
48249: POP
48250: POP
// end ;
48251: LD_VAR 0 2
48255: RET
// export function ResetHc ; begin
48256: LD_INT 0
48258: PPUSH
// InitHc ;
48259: CALL_OW 19
// hc_importance := 0 ;
48263: LD_ADDR_OWVAR 32
48267: PUSH
48268: LD_INT 0
48270: ST_TO_ADDR
// end ;
48271: LD_VAR 0 1
48275: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48276: LD_INT 0
48278: PPUSH
48279: PPUSH
48280: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48281: LD_ADDR_VAR 0 6
48285: PUSH
48286: LD_VAR 0 1
48290: PUSH
48291: LD_VAR 0 3
48295: PLUS
48296: PUSH
48297: LD_INT 2
48299: DIV
48300: ST_TO_ADDR
// if _x < 0 then
48301: LD_VAR 0 6
48305: PUSH
48306: LD_INT 0
48308: LESS
48309: IFFALSE 48326
// _x := _x * - 1 ;
48311: LD_ADDR_VAR 0 6
48315: PUSH
48316: LD_VAR 0 6
48320: PUSH
48321: LD_INT 1
48323: NEG
48324: MUL
48325: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
48326: LD_ADDR_VAR 0 7
48330: PUSH
48331: LD_VAR 0 2
48335: PUSH
48336: LD_VAR 0 4
48340: PLUS
48341: PUSH
48342: LD_INT 2
48344: DIV
48345: ST_TO_ADDR
// if _y < 0 then
48346: LD_VAR 0 7
48350: PUSH
48351: LD_INT 0
48353: LESS
48354: IFFALSE 48371
// _y := _y * - 1 ;
48356: LD_ADDR_VAR 0 7
48360: PUSH
48361: LD_VAR 0 7
48365: PUSH
48366: LD_INT 1
48368: NEG
48369: MUL
48370: ST_TO_ADDR
// result := [ _x , _y ] ;
48371: LD_ADDR_VAR 0 5
48375: PUSH
48376: LD_VAR 0 6
48380: PUSH
48381: LD_VAR 0 7
48385: PUSH
48386: EMPTY
48387: LIST
48388: LIST
48389: ST_TO_ADDR
// end ;
48390: LD_VAR 0 5
48394: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
48395: LD_INT 0
48397: PPUSH
48398: PPUSH
48399: PPUSH
48400: PPUSH
// task := GetTaskList ( unit ) ;
48401: LD_ADDR_VAR 0 7
48405: PUSH
48406: LD_VAR 0 1
48410: PPUSH
48411: CALL_OW 437
48415: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48416: LD_VAR 0 7
48420: NOT
48421: PUSH
48422: LD_VAR 0 1
48426: PPUSH
48427: LD_VAR 0 2
48431: PPUSH
48432: CALL_OW 308
48436: NOT
48437: AND
48438: IFFALSE 48442
// exit ;
48440: GO 48560
// if IsInArea ( unit , area ) then
48442: LD_VAR 0 1
48446: PPUSH
48447: LD_VAR 0 2
48451: PPUSH
48452: CALL_OW 308
48456: IFFALSE 48474
// begin ComMoveToArea ( unit , goAway ) ;
48458: LD_VAR 0 1
48462: PPUSH
48463: LD_VAR 0 3
48467: PPUSH
48468: CALL_OW 113
// exit ;
48472: GO 48560
// end ; if task [ 1 ] [ 1 ] <> M then
48474: LD_VAR 0 7
48478: PUSH
48479: LD_INT 1
48481: ARRAY
48482: PUSH
48483: LD_INT 1
48485: ARRAY
48486: PUSH
48487: LD_STRING M
48489: NONEQUAL
48490: IFFALSE 48494
// exit ;
48492: GO 48560
// x := task [ 1 ] [ 2 ] ;
48494: LD_ADDR_VAR 0 5
48498: PUSH
48499: LD_VAR 0 7
48503: PUSH
48504: LD_INT 1
48506: ARRAY
48507: PUSH
48508: LD_INT 2
48510: ARRAY
48511: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48512: LD_ADDR_VAR 0 6
48516: PUSH
48517: LD_VAR 0 7
48521: PUSH
48522: LD_INT 1
48524: ARRAY
48525: PUSH
48526: LD_INT 3
48528: ARRAY
48529: ST_TO_ADDR
// if InArea ( x , y , area ) then
48530: LD_VAR 0 5
48534: PPUSH
48535: LD_VAR 0 6
48539: PPUSH
48540: LD_VAR 0 2
48544: PPUSH
48545: CALL_OW 309
48549: IFFALSE 48560
// ComStop ( unit ) ;
48551: LD_VAR 0 1
48555: PPUSH
48556: CALL_OW 141
// end ;
48560: LD_VAR 0 4
48564: RET
// export function Abs ( value ) ; begin
48565: LD_INT 0
48567: PPUSH
// result := value ;
48568: LD_ADDR_VAR 0 2
48572: PUSH
48573: LD_VAR 0 1
48577: ST_TO_ADDR
// if value < 0 then
48578: LD_VAR 0 1
48582: PUSH
48583: LD_INT 0
48585: LESS
48586: IFFALSE 48603
// result := value * - 1 ;
48588: LD_ADDR_VAR 0 2
48592: PUSH
48593: LD_VAR 0 1
48597: PUSH
48598: LD_INT 1
48600: NEG
48601: MUL
48602: ST_TO_ADDR
// end ;
48603: LD_VAR 0 2
48607: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48608: LD_INT 0
48610: PPUSH
48611: PPUSH
48612: PPUSH
48613: PPUSH
48614: PPUSH
48615: PPUSH
48616: PPUSH
48617: PPUSH
// if not unit or not building then
48618: LD_VAR 0 1
48622: NOT
48623: PUSH
48624: LD_VAR 0 2
48628: NOT
48629: OR
48630: IFFALSE 48634
// exit ;
48632: GO 48860
// x := GetX ( building ) ;
48634: LD_ADDR_VAR 0 4
48638: PUSH
48639: LD_VAR 0 2
48643: PPUSH
48644: CALL_OW 250
48648: ST_TO_ADDR
// y := GetY ( building ) ;
48649: LD_ADDR_VAR 0 6
48653: PUSH
48654: LD_VAR 0 2
48658: PPUSH
48659: CALL_OW 251
48663: ST_TO_ADDR
// d := GetDir ( building ) ;
48664: LD_ADDR_VAR 0 8
48668: PUSH
48669: LD_VAR 0 2
48673: PPUSH
48674: CALL_OW 254
48678: ST_TO_ADDR
// r := 4 ;
48679: LD_ADDR_VAR 0 9
48683: PUSH
48684: LD_INT 4
48686: ST_TO_ADDR
// for i := 1 to 5 do
48687: LD_ADDR_VAR 0 10
48691: PUSH
48692: DOUBLE
48693: LD_INT 1
48695: DEC
48696: ST_TO_ADDR
48697: LD_INT 5
48699: PUSH
48700: FOR_TO
48701: IFFALSE 48858
// begin _x := ShiftX ( x , d , r + i ) ;
48703: LD_ADDR_VAR 0 5
48707: PUSH
48708: LD_VAR 0 4
48712: PPUSH
48713: LD_VAR 0 8
48717: PPUSH
48718: LD_VAR 0 9
48722: PUSH
48723: LD_VAR 0 10
48727: PLUS
48728: PPUSH
48729: CALL_OW 272
48733: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48734: LD_ADDR_VAR 0 7
48738: PUSH
48739: LD_VAR 0 6
48743: PPUSH
48744: LD_VAR 0 8
48748: PPUSH
48749: LD_VAR 0 9
48753: PUSH
48754: LD_VAR 0 10
48758: PLUS
48759: PPUSH
48760: CALL_OW 273
48764: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48765: LD_VAR 0 5
48769: PPUSH
48770: LD_VAR 0 7
48774: PPUSH
48775: CALL_OW 488
48779: PUSH
48780: LD_VAR 0 5
48784: PPUSH
48785: LD_VAR 0 7
48789: PPUSH
48790: CALL_OW 428
48794: PPUSH
48795: CALL_OW 247
48799: PUSH
48800: LD_INT 3
48802: PUSH
48803: LD_INT 2
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: IN
48810: NOT
48811: AND
48812: IFFALSE 48856
// begin ComMoveXY ( unit , _x , _y ) ;
48814: LD_VAR 0 1
48818: PPUSH
48819: LD_VAR 0 5
48823: PPUSH
48824: LD_VAR 0 7
48828: PPUSH
48829: CALL_OW 111
// result := [ _x , _y ] ;
48833: LD_ADDR_VAR 0 3
48837: PUSH
48838: LD_VAR 0 5
48842: PUSH
48843: LD_VAR 0 7
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: ST_TO_ADDR
// exit ;
48852: POP
48853: POP
48854: GO 48860
// end ; end ;
48856: GO 48700
48858: POP
48859: POP
// end ;
48860: LD_VAR 0 3
48864: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48865: LD_INT 0
48867: PPUSH
48868: PPUSH
48869: PPUSH
// result := 0 ;
48870: LD_ADDR_VAR 0 3
48874: PUSH
48875: LD_INT 0
48877: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48878: LD_VAR 0 1
48882: PUSH
48883: LD_INT 0
48885: LESS
48886: PUSH
48887: LD_VAR 0 1
48891: PUSH
48892: LD_INT 8
48894: GREATER
48895: OR
48896: PUSH
48897: LD_VAR 0 2
48901: PUSH
48902: LD_INT 0
48904: LESS
48905: OR
48906: PUSH
48907: LD_VAR 0 2
48911: PUSH
48912: LD_INT 8
48914: GREATER
48915: OR
48916: IFFALSE 48920
// exit ;
48918: GO 48995
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48920: LD_ADDR_VAR 0 4
48924: PUSH
48925: LD_INT 22
48927: PUSH
48928: LD_VAR 0 2
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PPUSH
48937: CALL_OW 69
48941: PUSH
48942: FOR_IN
48943: IFFALSE 48993
// begin un := UnitShoot ( i ) ;
48945: LD_ADDR_VAR 0 5
48949: PUSH
48950: LD_VAR 0 4
48954: PPUSH
48955: CALL_OW 504
48959: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48960: LD_VAR 0 5
48964: PPUSH
48965: CALL_OW 255
48969: PUSH
48970: LD_VAR 0 1
48974: EQUAL
48975: IFFALSE 48991
// begin result := un ;
48977: LD_ADDR_VAR 0 3
48981: PUSH
48982: LD_VAR 0 5
48986: ST_TO_ADDR
// exit ;
48987: POP
48988: POP
48989: GO 48995
// end ; end ;
48991: GO 48942
48993: POP
48994: POP
// end ;
48995: LD_VAR 0 3
48999: RET
// export function GetCargoBay ( units ) ; begin
49000: LD_INT 0
49002: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49003: LD_ADDR_VAR 0 2
49007: PUSH
49008: LD_VAR 0 1
49012: PPUSH
49013: LD_INT 2
49015: PUSH
49016: LD_INT 34
49018: PUSH
49019: LD_INT 12
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: PUSH
49026: LD_INT 34
49028: PUSH
49029: LD_INT 51
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 34
49038: PUSH
49039: LD_INT 32
49041: PUSH
49042: EMPTY
49043: LIST
49044: LIST
49045: PUSH
49046: LD_INT 34
49048: PUSH
49049: LD_EXP 68
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: PPUSH
49065: CALL_OW 72
49069: ST_TO_ADDR
// end ;
49070: LD_VAR 0 2
49074: RET
// export function Negate ( value ) ; begin
49075: LD_INT 0
49077: PPUSH
// result := not value ;
49078: LD_ADDR_VAR 0 2
49082: PUSH
49083: LD_VAR 0 1
49087: NOT
49088: ST_TO_ADDR
// end ;
49089: LD_VAR 0 2
49093: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
49094: LD_INT 0
49096: PPUSH
// if x1 = x2 then
49097: LD_VAR 0 1
49101: PUSH
49102: LD_VAR 0 3
49106: EQUAL
49107: IFFALSE 49141
// begin if y1 > y2 then
49109: LD_VAR 0 2
49113: PUSH
49114: LD_VAR 0 4
49118: GREATER
49119: IFFALSE 49131
// result := 0 else
49121: LD_ADDR_VAR 0 5
49125: PUSH
49126: LD_INT 0
49128: ST_TO_ADDR
49129: GO 49139
// result := 3 ;
49131: LD_ADDR_VAR 0 5
49135: PUSH
49136: LD_INT 3
49138: ST_TO_ADDR
// exit ;
49139: GO 49227
// end ; if y1 = y2 then
49141: LD_VAR 0 2
49145: PUSH
49146: LD_VAR 0 4
49150: EQUAL
49151: IFFALSE 49185
// begin if x1 > x2 then
49153: LD_VAR 0 1
49157: PUSH
49158: LD_VAR 0 3
49162: GREATER
49163: IFFALSE 49175
// result := 1 else
49165: LD_ADDR_VAR 0 5
49169: PUSH
49170: LD_INT 1
49172: ST_TO_ADDR
49173: GO 49183
// result := 4 ;
49175: LD_ADDR_VAR 0 5
49179: PUSH
49180: LD_INT 4
49182: ST_TO_ADDR
// exit ;
49183: GO 49227
// end ; if x1 > x2 and y1 > y2 then
49185: LD_VAR 0 1
49189: PUSH
49190: LD_VAR 0 3
49194: GREATER
49195: PUSH
49196: LD_VAR 0 2
49200: PUSH
49201: LD_VAR 0 4
49205: GREATER
49206: AND
49207: IFFALSE 49219
// result := 2 else
49209: LD_ADDR_VAR 0 5
49213: PUSH
49214: LD_INT 2
49216: ST_TO_ADDR
49217: GO 49227
// result := 5 ;
49219: LD_ADDR_VAR 0 5
49223: PUSH
49224: LD_INT 5
49226: ST_TO_ADDR
// end ;
49227: LD_VAR 0 5
49231: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49232: LD_INT 0
49234: PPUSH
49235: PPUSH
// if not driver or not IsInUnit ( driver ) then
49236: LD_VAR 0 1
49240: NOT
49241: PUSH
49242: LD_VAR 0 1
49246: PPUSH
49247: CALL_OW 310
49251: NOT
49252: OR
49253: IFFALSE 49257
// exit ;
49255: GO 49347
// vehicle := IsInUnit ( driver ) ;
49257: LD_ADDR_VAR 0 3
49261: PUSH
49262: LD_VAR 0 1
49266: PPUSH
49267: CALL_OW 310
49271: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49272: LD_VAR 0 1
49276: PPUSH
49277: LD_STRING \
49279: PUSH
49280: LD_INT 0
49282: PUSH
49283: LD_INT 0
49285: PUSH
49286: LD_INT 0
49288: PUSH
49289: LD_INT 0
49291: PUSH
49292: LD_INT 0
49294: PUSH
49295: LD_INT 0
49297: PUSH
49298: EMPTY
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: PUSH
49307: LD_STRING E
49309: PUSH
49310: LD_INT 0
49312: PUSH
49313: LD_INT 0
49315: PUSH
49316: LD_VAR 0 3
49320: PUSH
49321: LD_INT 0
49323: PUSH
49324: LD_INT 0
49326: PUSH
49327: LD_INT 0
49329: PUSH
49330: EMPTY
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: PPUSH
49343: CALL_OW 446
// end ;
49347: LD_VAR 0 2
49351: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49352: LD_INT 0
49354: PPUSH
49355: PPUSH
// if not driver or not IsInUnit ( driver ) then
49356: LD_VAR 0 1
49360: NOT
49361: PUSH
49362: LD_VAR 0 1
49366: PPUSH
49367: CALL_OW 310
49371: NOT
49372: OR
49373: IFFALSE 49377
// exit ;
49375: GO 49467
// vehicle := IsInUnit ( driver ) ;
49377: LD_ADDR_VAR 0 3
49381: PUSH
49382: LD_VAR 0 1
49386: PPUSH
49387: CALL_OW 310
49391: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49392: LD_VAR 0 1
49396: PPUSH
49397: LD_STRING \
49399: PUSH
49400: LD_INT 0
49402: PUSH
49403: LD_INT 0
49405: PUSH
49406: LD_INT 0
49408: PUSH
49409: LD_INT 0
49411: PUSH
49412: LD_INT 0
49414: PUSH
49415: LD_INT 0
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: LIST
49422: LIST
49423: LIST
49424: LIST
49425: LIST
49426: PUSH
49427: LD_STRING E
49429: PUSH
49430: LD_INT 0
49432: PUSH
49433: LD_INT 0
49435: PUSH
49436: LD_VAR 0 3
49440: PUSH
49441: LD_INT 0
49443: PUSH
49444: LD_INT 0
49446: PUSH
49447: LD_INT 0
49449: PUSH
49450: EMPTY
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: PUSH
49459: EMPTY
49460: LIST
49461: LIST
49462: PPUSH
49463: CALL_OW 447
// end ;
49467: LD_VAR 0 2
49471: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49472: LD_INT 0
49474: PPUSH
49475: PPUSH
49476: PPUSH
// tmp := [ ] ;
49477: LD_ADDR_VAR 0 5
49481: PUSH
49482: EMPTY
49483: ST_TO_ADDR
// for i in units do
49484: LD_ADDR_VAR 0 4
49488: PUSH
49489: LD_VAR 0 1
49493: PUSH
49494: FOR_IN
49495: IFFALSE 49533
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49497: LD_ADDR_VAR 0 5
49501: PUSH
49502: LD_VAR 0 5
49506: PPUSH
49507: LD_VAR 0 5
49511: PUSH
49512: LD_INT 1
49514: PLUS
49515: PPUSH
49516: LD_VAR 0 4
49520: PPUSH
49521: CALL_OW 256
49525: PPUSH
49526: CALL_OW 2
49530: ST_TO_ADDR
49531: GO 49494
49533: POP
49534: POP
// if not tmp then
49535: LD_VAR 0 5
49539: NOT
49540: IFFALSE 49544
// exit ;
49542: GO 49592
// if asc then
49544: LD_VAR 0 2
49548: IFFALSE 49572
// result := SortListByListAsc ( units , tmp ) else
49550: LD_ADDR_VAR 0 3
49554: PUSH
49555: LD_VAR 0 1
49559: PPUSH
49560: LD_VAR 0 5
49564: PPUSH
49565: CALL_OW 76
49569: ST_TO_ADDR
49570: GO 49592
// result := SortListByListDesc ( units , tmp ) ;
49572: LD_ADDR_VAR 0 3
49576: PUSH
49577: LD_VAR 0 1
49581: PPUSH
49582: LD_VAR 0 5
49586: PPUSH
49587: CALL_OW 77
49591: ST_TO_ADDR
// end ;
49592: LD_VAR 0 3
49596: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49597: LD_INT 0
49599: PPUSH
49600: PPUSH
// task := GetTaskList ( mech ) ;
49601: LD_ADDR_VAR 0 4
49605: PUSH
49606: LD_VAR 0 1
49610: PPUSH
49611: CALL_OW 437
49615: ST_TO_ADDR
// if not task then
49616: LD_VAR 0 4
49620: NOT
49621: IFFALSE 49625
// exit ;
49623: GO 49667
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49625: LD_ADDR_VAR 0 3
49629: PUSH
49630: LD_VAR 0 4
49634: PUSH
49635: LD_INT 1
49637: ARRAY
49638: PUSH
49639: LD_INT 1
49641: ARRAY
49642: PUSH
49643: LD_STRING r
49645: EQUAL
49646: PUSH
49647: LD_VAR 0 4
49651: PUSH
49652: LD_INT 1
49654: ARRAY
49655: PUSH
49656: LD_INT 4
49658: ARRAY
49659: PUSH
49660: LD_VAR 0 2
49664: EQUAL
49665: AND
49666: ST_TO_ADDR
// end ;
49667: LD_VAR 0 3
49671: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49672: LD_INT 0
49674: PPUSH
// SetDir ( unit , d ) ;
49675: LD_VAR 0 1
49679: PPUSH
49680: LD_VAR 0 4
49684: PPUSH
49685: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49689: LD_VAR 0 1
49693: PPUSH
49694: LD_VAR 0 2
49698: PPUSH
49699: LD_VAR 0 3
49703: PPUSH
49704: LD_VAR 0 5
49708: PPUSH
49709: CALL_OW 48
// end ;
49713: LD_VAR 0 6
49717: RET
// export function ToNaturalNumber ( number ) ; begin
49718: LD_INT 0
49720: PPUSH
// result := number div 1 ;
49721: LD_ADDR_VAR 0 2
49725: PUSH
49726: LD_VAR 0 1
49730: PUSH
49731: LD_INT 1
49733: DIV
49734: ST_TO_ADDR
// if number < 0 then
49735: LD_VAR 0 1
49739: PUSH
49740: LD_INT 0
49742: LESS
49743: IFFALSE 49753
// result := 0 ;
49745: LD_ADDR_VAR 0 2
49749: PUSH
49750: LD_INT 0
49752: ST_TO_ADDR
// end ;
49753: LD_VAR 0 2
49757: RET
// export function SortByClass ( units , class ) ; var un ; begin
49758: LD_INT 0
49760: PPUSH
49761: PPUSH
// if not units or not class then
49762: LD_VAR 0 1
49766: NOT
49767: PUSH
49768: LD_VAR 0 2
49772: NOT
49773: OR
49774: IFFALSE 49778
// exit ;
49776: GO 49873
// result := [ ] ;
49778: LD_ADDR_VAR 0 3
49782: PUSH
49783: EMPTY
49784: ST_TO_ADDR
// for un in units do
49785: LD_ADDR_VAR 0 4
49789: PUSH
49790: LD_VAR 0 1
49794: PUSH
49795: FOR_IN
49796: IFFALSE 49871
// if GetClass ( un ) = class then
49798: LD_VAR 0 4
49802: PPUSH
49803: CALL_OW 257
49807: PUSH
49808: LD_VAR 0 2
49812: EQUAL
49813: IFFALSE 49840
// result := Insert ( result , 1 , un ) else
49815: LD_ADDR_VAR 0 3
49819: PUSH
49820: LD_VAR 0 3
49824: PPUSH
49825: LD_INT 1
49827: PPUSH
49828: LD_VAR 0 4
49832: PPUSH
49833: CALL_OW 2
49837: ST_TO_ADDR
49838: GO 49869
// result := Replace ( result , result + 1 , un ) ;
49840: LD_ADDR_VAR 0 3
49844: PUSH
49845: LD_VAR 0 3
49849: PPUSH
49850: LD_VAR 0 3
49854: PUSH
49855: LD_INT 1
49857: PLUS
49858: PPUSH
49859: LD_VAR 0 4
49863: PPUSH
49864: CALL_OW 1
49868: ST_TO_ADDR
49869: GO 49795
49871: POP
49872: POP
// end ; end_of_file
49873: LD_VAR 0 3
49877: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
49878: LD_INT 0
49880: PPUSH
49881: PPUSH
// skirmish := false ;
49882: LD_ADDR_EXP 21
49886: PUSH
49887: LD_INT 0
49889: ST_TO_ADDR
// debug_mc := false ;
49890: LD_ADDR_EXP 22
49894: PUSH
49895: LD_INT 0
49897: ST_TO_ADDR
// mc_bases := [ ] ;
49898: LD_ADDR_EXP 23
49902: PUSH
49903: EMPTY
49904: ST_TO_ADDR
// mc_sides := [ ] ;
49905: LD_ADDR_EXP 49
49909: PUSH
49910: EMPTY
49911: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
49912: LD_ADDR_EXP 24
49916: PUSH
49917: EMPTY
49918: ST_TO_ADDR
// mc_building_repairs := [ ] ;
49919: LD_ADDR_EXP 25
49923: PUSH
49924: EMPTY
49925: ST_TO_ADDR
// mc_need_heal := [ ] ;
49926: LD_ADDR_EXP 26
49930: PUSH
49931: EMPTY
49932: ST_TO_ADDR
// mc_healers := [ ] ;
49933: LD_ADDR_EXP 27
49937: PUSH
49938: EMPTY
49939: ST_TO_ADDR
// mc_build_list := [ ] ;
49940: LD_ADDR_EXP 28
49944: PUSH
49945: EMPTY
49946: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
49947: LD_ADDR_EXP 55
49951: PUSH
49952: EMPTY
49953: ST_TO_ADDR
// mc_builders := [ ] ;
49954: LD_ADDR_EXP 29
49958: PUSH
49959: EMPTY
49960: ST_TO_ADDR
// mc_construct_list := [ ] ;
49961: LD_ADDR_EXP 30
49965: PUSH
49966: EMPTY
49967: ST_TO_ADDR
// mc_turret_list := [ ] ;
49968: LD_ADDR_EXP 31
49972: PUSH
49973: EMPTY
49974: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
49975: LD_ADDR_EXP 32
49979: PUSH
49980: EMPTY
49981: ST_TO_ADDR
// mc_miners := [ ] ;
49982: LD_ADDR_EXP 37
49986: PUSH
49987: EMPTY
49988: ST_TO_ADDR
// mc_mines := [ ] ;
49989: LD_ADDR_EXP 36
49993: PUSH
49994: EMPTY
49995: ST_TO_ADDR
// mc_minefields := [ ] ;
49996: LD_ADDR_EXP 38
50000: PUSH
50001: EMPTY
50002: ST_TO_ADDR
// mc_crates := [ ] ;
50003: LD_ADDR_EXP 39
50007: PUSH
50008: EMPTY
50009: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50010: LD_ADDR_EXP 40
50014: PUSH
50015: EMPTY
50016: ST_TO_ADDR
// mc_crates_area := [ ] ;
50017: LD_ADDR_EXP 41
50021: PUSH
50022: EMPTY
50023: ST_TO_ADDR
// mc_vehicles := [ ] ;
50024: LD_ADDR_EXP 42
50028: PUSH
50029: EMPTY
50030: ST_TO_ADDR
// mc_attack := [ ] ;
50031: LD_ADDR_EXP 43
50035: PUSH
50036: EMPTY
50037: ST_TO_ADDR
// mc_produce := [ ] ;
50038: LD_ADDR_EXP 44
50042: PUSH
50043: EMPTY
50044: ST_TO_ADDR
// mc_defender := [ ] ;
50045: LD_ADDR_EXP 45
50049: PUSH
50050: EMPTY
50051: ST_TO_ADDR
// mc_parking := [ ] ;
50052: LD_ADDR_EXP 47
50056: PUSH
50057: EMPTY
50058: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50059: LD_ADDR_EXP 33
50063: PUSH
50064: EMPTY
50065: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50066: LD_ADDR_EXP 35
50070: PUSH
50071: EMPTY
50072: ST_TO_ADDR
// mc_scan := [ ] ;
50073: LD_ADDR_EXP 46
50077: PUSH
50078: EMPTY
50079: ST_TO_ADDR
// mc_scan_area := [ ] ;
50080: LD_ADDR_EXP 48
50084: PUSH
50085: EMPTY
50086: ST_TO_ADDR
// mc_tech := [ ] ;
50087: LD_ADDR_EXP 50
50091: PUSH
50092: EMPTY
50093: ST_TO_ADDR
// mc_class := [ ] ;
50094: LD_ADDR_EXP 64
50098: PUSH
50099: EMPTY
50100: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50101: LD_ADDR_EXP 65
50105: PUSH
50106: EMPTY
50107: ST_TO_ADDR
// mc_is_defending := [ ] ;
50108: LD_ADDR_EXP 66
50112: PUSH
50113: EMPTY
50114: ST_TO_ADDR
// end ;
50115: LD_VAR 0 1
50119: RET
// export function MC_Kill ( base ) ; begin
50120: LD_INT 0
50122: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50123: LD_ADDR_EXP 23
50127: PUSH
50128: LD_EXP 23
50132: PPUSH
50133: LD_VAR 0 1
50137: PPUSH
50138: EMPTY
50139: PPUSH
50140: CALL_OW 1
50144: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50145: LD_ADDR_EXP 24
50149: PUSH
50150: LD_EXP 24
50154: PPUSH
50155: LD_VAR 0 1
50159: PPUSH
50160: EMPTY
50161: PPUSH
50162: CALL_OW 1
50166: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50167: LD_ADDR_EXP 25
50171: PUSH
50172: LD_EXP 25
50176: PPUSH
50177: LD_VAR 0 1
50181: PPUSH
50182: EMPTY
50183: PPUSH
50184: CALL_OW 1
50188: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50189: LD_ADDR_EXP 26
50193: PUSH
50194: LD_EXP 26
50198: PPUSH
50199: LD_VAR 0 1
50203: PPUSH
50204: EMPTY
50205: PPUSH
50206: CALL_OW 1
50210: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50211: LD_ADDR_EXP 27
50215: PUSH
50216: LD_EXP 27
50220: PPUSH
50221: LD_VAR 0 1
50225: PPUSH
50226: EMPTY
50227: PPUSH
50228: CALL_OW 1
50232: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50233: LD_ADDR_EXP 28
50237: PUSH
50238: LD_EXP 28
50242: PPUSH
50243: LD_VAR 0 1
50247: PPUSH
50248: EMPTY
50249: PPUSH
50250: CALL_OW 1
50254: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50255: LD_ADDR_EXP 29
50259: PUSH
50260: LD_EXP 29
50264: PPUSH
50265: LD_VAR 0 1
50269: PPUSH
50270: EMPTY
50271: PPUSH
50272: CALL_OW 1
50276: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50277: LD_ADDR_EXP 30
50281: PUSH
50282: LD_EXP 30
50286: PPUSH
50287: LD_VAR 0 1
50291: PPUSH
50292: EMPTY
50293: PPUSH
50294: CALL_OW 1
50298: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50299: LD_ADDR_EXP 31
50303: PUSH
50304: LD_EXP 31
50308: PPUSH
50309: LD_VAR 0 1
50313: PPUSH
50314: EMPTY
50315: PPUSH
50316: CALL_OW 1
50320: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50321: LD_ADDR_EXP 32
50325: PUSH
50326: LD_EXP 32
50330: PPUSH
50331: LD_VAR 0 1
50335: PPUSH
50336: EMPTY
50337: PPUSH
50338: CALL_OW 1
50342: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50343: LD_ADDR_EXP 33
50347: PUSH
50348: LD_EXP 33
50352: PPUSH
50353: LD_VAR 0 1
50357: PPUSH
50358: EMPTY
50359: PPUSH
50360: CALL_OW 1
50364: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50365: LD_ADDR_EXP 34
50369: PUSH
50370: LD_EXP 34
50374: PPUSH
50375: LD_VAR 0 1
50379: PPUSH
50380: LD_INT 0
50382: PPUSH
50383: CALL_OW 1
50387: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50388: LD_ADDR_EXP 35
50392: PUSH
50393: LD_EXP 35
50397: PPUSH
50398: LD_VAR 0 1
50402: PPUSH
50403: EMPTY
50404: PPUSH
50405: CALL_OW 1
50409: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50410: LD_ADDR_EXP 36
50414: PUSH
50415: LD_EXP 36
50419: PPUSH
50420: LD_VAR 0 1
50424: PPUSH
50425: EMPTY
50426: PPUSH
50427: CALL_OW 1
50431: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50432: LD_ADDR_EXP 37
50436: PUSH
50437: LD_EXP 37
50441: PPUSH
50442: LD_VAR 0 1
50446: PPUSH
50447: EMPTY
50448: PPUSH
50449: CALL_OW 1
50453: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50454: LD_ADDR_EXP 38
50458: PUSH
50459: LD_EXP 38
50463: PPUSH
50464: LD_VAR 0 1
50468: PPUSH
50469: EMPTY
50470: PPUSH
50471: CALL_OW 1
50475: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50476: LD_ADDR_EXP 39
50480: PUSH
50481: LD_EXP 39
50485: PPUSH
50486: LD_VAR 0 1
50490: PPUSH
50491: EMPTY
50492: PPUSH
50493: CALL_OW 1
50497: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
50498: LD_ADDR_EXP 40
50502: PUSH
50503: LD_EXP 40
50507: PPUSH
50508: LD_VAR 0 1
50512: PPUSH
50513: EMPTY
50514: PPUSH
50515: CALL_OW 1
50519: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
50520: LD_ADDR_EXP 41
50524: PUSH
50525: LD_EXP 41
50529: PPUSH
50530: LD_VAR 0 1
50534: PPUSH
50535: EMPTY
50536: PPUSH
50537: CALL_OW 1
50541: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
50542: LD_ADDR_EXP 42
50546: PUSH
50547: LD_EXP 42
50551: PPUSH
50552: LD_VAR 0 1
50556: PPUSH
50557: EMPTY
50558: PPUSH
50559: CALL_OW 1
50563: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
50564: LD_ADDR_EXP 43
50568: PUSH
50569: LD_EXP 43
50573: PPUSH
50574: LD_VAR 0 1
50578: PPUSH
50579: EMPTY
50580: PPUSH
50581: CALL_OW 1
50585: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
50586: LD_ADDR_EXP 44
50590: PUSH
50591: LD_EXP 44
50595: PPUSH
50596: LD_VAR 0 1
50600: PPUSH
50601: EMPTY
50602: PPUSH
50603: CALL_OW 1
50607: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
50608: LD_ADDR_EXP 45
50612: PUSH
50613: LD_EXP 45
50617: PPUSH
50618: LD_VAR 0 1
50622: PPUSH
50623: EMPTY
50624: PPUSH
50625: CALL_OW 1
50629: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
50630: LD_ADDR_EXP 46
50634: PUSH
50635: LD_EXP 46
50639: PPUSH
50640: LD_VAR 0 1
50644: PPUSH
50645: EMPTY
50646: PPUSH
50647: CALL_OW 1
50651: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
50652: LD_ADDR_EXP 47
50656: PUSH
50657: LD_EXP 47
50661: PPUSH
50662: LD_VAR 0 1
50666: PPUSH
50667: EMPTY
50668: PPUSH
50669: CALL_OW 1
50673: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
50674: LD_ADDR_EXP 48
50678: PUSH
50679: LD_EXP 48
50683: PPUSH
50684: LD_VAR 0 1
50688: PPUSH
50689: EMPTY
50690: PPUSH
50691: CALL_OW 1
50695: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
50696: LD_ADDR_EXP 50
50700: PUSH
50701: LD_EXP 50
50705: PPUSH
50706: LD_VAR 0 1
50710: PPUSH
50711: EMPTY
50712: PPUSH
50713: CALL_OW 1
50717: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
50718: LD_ADDR_EXP 52
50722: PUSH
50723: LD_EXP 52
50727: PPUSH
50728: LD_VAR 0 1
50732: PPUSH
50733: EMPTY
50734: PPUSH
50735: CALL_OW 1
50739: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
50740: LD_ADDR_EXP 53
50744: PUSH
50745: LD_EXP 53
50749: PPUSH
50750: LD_VAR 0 1
50754: PPUSH
50755: EMPTY
50756: PPUSH
50757: CALL_OW 1
50761: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
50762: LD_ADDR_EXP 54
50766: PUSH
50767: LD_EXP 54
50771: PPUSH
50772: LD_VAR 0 1
50776: PPUSH
50777: EMPTY
50778: PPUSH
50779: CALL_OW 1
50783: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
50784: LD_ADDR_EXP 55
50788: PUSH
50789: LD_EXP 55
50793: PPUSH
50794: LD_VAR 0 1
50798: PPUSH
50799: EMPTY
50800: PPUSH
50801: CALL_OW 1
50805: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
50806: LD_ADDR_EXP 56
50810: PUSH
50811: LD_EXP 56
50815: PPUSH
50816: LD_VAR 0 1
50820: PPUSH
50821: EMPTY
50822: PPUSH
50823: CALL_OW 1
50827: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
50828: LD_ADDR_EXP 57
50832: PUSH
50833: LD_EXP 57
50837: PPUSH
50838: LD_VAR 0 1
50842: PPUSH
50843: EMPTY
50844: PPUSH
50845: CALL_OW 1
50849: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
50850: LD_ADDR_EXP 58
50854: PUSH
50855: LD_EXP 58
50859: PPUSH
50860: LD_VAR 0 1
50864: PPUSH
50865: EMPTY
50866: PPUSH
50867: CALL_OW 1
50871: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
50872: LD_ADDR_EXP 59
50876: PUSH
50877: LD_EXP 59
50881: PPUSH
50882: LD_VAR 0 1
50886: PPUSH
50887: EMPTY
50888: PPUSH
50889: CALL_OW 1
50893: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
50894: LD_ADDR_EXP 60
50898: PUSH
50899: LD_EXP 60
50903: PPUSH
50904: LD_VAR 0 1
50908: PPUSH
50909: EMPTY
50910: PPUSH
50911: CALL_OW 1
50915: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
50916: LD_ADDR_EXP 61
50920: PUSH
50921: LD_EXP 61
50925: PPUSH
50926: LD_VAR 0 1
50930: PPUSH
50931: EMPTY
50932: PPUSH
50933: CALL_OW 1
50937: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
50938: LD_ADDR_EXP 62
50942: PUSH
50943: LD_EXP 62
50947: PPUSH
50948: LD_VAR 0 1
50952: PPUSH
50953: EMPTY
50954: PPUSH
50955: CALL_OW 1
50959: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
50960: LD_ADDR_EXP 63
50964: PUSH
50965: LD_EXP 63
50969: PPUSH
50970: LD_VAR 0 1
50974: PPUSH
50975: EMPTY
50976: PPUSH
50977: CALL_OW 1
50981: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
50982: LD_ADDR_EXP 64
50986: PUSH
50987: LD_EXP 64
50991: PPUSH
50992: LD_VAR 0 1
50996: PPUSH
50997: EMPTY
50998: PPUSH
50999: CALL_OW 1
51003: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51004: LD_ADDR_EXP 65
51008: PUSH
51009: LD_EXP 65
51013: PPUSH
51014: LD_VAR 0 1
51018: PPUSH
51019: LD_INT 0
51021: PPUSH
51022: CALL_OW 1
51026: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
51027: LD_ADDR_EXP 66
51031: PUSH
51032: LD_EXP 66
51036: PPUSH
51037: LD_VAR 0 1
51041: PPUSH
51042: LD_INT 0
51044: PPUSH
51045: CALL_OW 1
51049: ST_TO_ADDR
// end ;
51050: LD_VAR 0 2
51054: RET
// export function MC_Add ( side , units ) ; var base ; begin
51055: LD_INT 0
51057: PPUSH
51058: PPUSH
// base := mc_bases + 1 ;
51059: LD_ADDR_VAR 0 4
51063: PUSH
51064: LD_EXP 23
51068: PUSH
51069: LD_INT 1
51071: PLUS
51072: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51073: LD_ADDR_EXP 49
51077: PUSH
51078: LD_EXP 49
51082: PPUSH
51083: LD_VAR 0 4
51087: PPUSH
51088: LD_VAR 0 1
51092: PPUSH
51093: CALL_OW 1
51097: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51098: LD_ADDR_EXP 23
51102: PUSH
51103: LD_EXP 23
51107: PPUSH
51108: LD_VAR 0 4
51112: PPUSH
51113: LD_VAR 0 2
51117: PPUSH
51118: CALL_OW 1
51122: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51123: LD_ADDR_EXP 24
51127: PUSH
51128: LD_EXP 24
51132: PPUSH
51133: LD_VAR 0 4
51137: PPUSH
51138: EMPTY
51139: PPUSH
51140: CALL_OW 1
51144: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51145: LD_ADDR_EXP 25
51149: PUSH
51150: LD_EXP 25
51154: PPUSH
51155: LD_VAR 0 4
51159: PPUSH
51160: EMPTY
51161: PPUSH
51162: CALL_OW 1
51166: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51167: LD_ADDR_EXP 26
51171: PUSH
51172: LD_EXP 26
51176: PPUSH
51177: LD_VAR 0 4
51181: PPUSH
51182: EMPTY
51183: PPUSH
51184: CALL_OW 1
51188: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51189: LD_ADDR_EXP 27
51193: PUSH
51194: LD_EXP 27
51198: PPUSH
51199: LD_VAR 0 4
51203: PPUSH
51204: EMPTY
51205: PPUSH
51206: CALL_OW 1
51210: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51211: LD_ADDR_EXP 28
51215: PUSH
51216: LD_EXP 28
51220: PPUSH
51221: LD_VAR 0 4
51225: PPUSH
51226: EMPTY
51227: PPUSH
51228: CALL_OW 1
51232: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51233: LD_ADDR_EXP 29
51237: PUSH
51238: LD_EXP 29
51242: PPUSH
51243: LD_VAR 0 4
51247: PPUSH
51248: EMPTY
51249: PPUSH
51250: CALL_OW 1
51254: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51255: LD_ADDR_EXP 30
51259: PUSH
51260: LD_EXP 30
51264: PPUSH
51265: LD_VAR 0 4
51269: PPUSH
51270: EMPTY
51271: PPUSH
51272: CALL_OW 1
51276: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51277: LD_ADDR_EXP 31
51281: PUSH
51282: LD_EXP 31
51286: PPUSH
51287: LD_VAR 0 4
51291: PPUSH
51292: EMPTY
51293: PPUSH
51294: CALL_OW 1
51298: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51299: LD_ADDR_EXP 32
51303: PUSH
51304: LD_EXP 32
51308: PPUSH
51309: LD_VAR 0 4
51313: PPUSH
51314: EMPTY
51315: PPUSH
51316: CALL_OW 1
51320: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51321: LD_ADDR_EXP 33
51325: PUSH
51326: LD_EXP 33
51330: PPUSH
51331: LD_VAR 0 4
51335: PPUSH
51336: EMPTY
51337: PPUSH
51338: CALL_OW 1
51342: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51343: LD_ADDR_EXP 34
51347: PUSH
51348: LD_EXP 34
51352: PPUSH
51353: LD_VAR 0 4
51357: PPUSH
51358: LD_INT 0
51360: PPUSH
51361: CALL_OW 1
51365: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51366: LD_ADDR_EXP 35
51370: PUSH
51371: LD_EXP 35
51375: PPUSH
51376: LD_VAR 0 4
51380: PPUSH
51381: EMPTY
51382: PPUSH
51383: CALL_OW 1
51387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51388: LD_ADDR_EXP 36
51392: PUSH
51393: LD_EXP 36
51397: PPUSH
51398: LD_VAR 0 4
51402: PPUSH
51403: EMPTY
51404: PPUSH
51405: CALL_OW 1
51409: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51410: LD_ADDR_EXP 37
51414: PUSH
51415: LD_EXP 37
51419: PPUSH
51420: LD_VAR 0 4
51424: PPUSH
51425: EMPTY
51426: PPUSH
51427: CALL_OW 1
51431: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51432: LD_ADDR_EXP 38
51436: PUSH
51437: LD_EXP 38
51441: PPUSH
51442: LD_VAR 0 4
51446: PPUSH
51447: EMPTY
51448: PPUSH
51449: CALL_OW 1
51453: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51454: LD_ADDR_EXP 39
51458: PUSH
51459: LD_EXP 39
51463: PPUSH
51464: LD_VAR 0 4
51468: PPUSH
51469: EMPTY
51470: PPUSH
51471: CALL_OW 1
51475: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51476: LD_ADDR_EXP 40
51480: PUSH
51481: LD_EXP 40
51485: PPUSH
51486: LD_VAR 0 4
51490: PPUSH
51491: EMPTY
51492: PPUSH
51493: CALL_OW 1
51497: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51498: LD_ADDR_EXP 41
51502: PUSH
51503: LD_EXP 41
51507: PPUSH
51508: LD_VAR 0 4
51512: PPUSH
51513: EMPTY
51514: PPUSH
51515: CALL_OW 1
51519: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51520: LD_ADDR_EXP 42
51524: PUSH
51525: LD_EXP 42
51529: PPUSH
51530: LD_VAR 0 4
51534: PPUSH
51535: EMPTY
51536: PPUSH
51537: CALL_OW 1
51541: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51542: LD_ADDR_EXP 43
51546: PUSH
51547: LD_EXP 43
51551: PPUSH
51552: LD_VAR 0 4
51556: PPUSH
51557: EMPTY
51558: PPUSH
51559: CALL_OW 1
51563: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51564: LD_ADDR_EXP 44
51568: PUSH
51569: LD_EXP 44
51573: PPUSH
51574: LD_VAR 0 4
51578: PPUSH
51579: EMPTY
51580: PPUSH
51581: CALL_OW 1
51585: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51586: LD_ADDR_EXP 45
51590: PUSH
51591: LD_EXP 45
51595: PPUSH
51596: LD_VAR 0 4
51600: PPUSH
51601: EMPTY
51602: PPUSH
51603: CALL_OW 1
51607: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51608: LD_ADDR_EXP 46
51612: PUSH
51613: LD_EXP 46
51617: PPUSH
51618: LD_VAR 0 4
51622: PPUSH
51623: EMPTY
51624: PPUSH
51625: CALL_OW 1
51629: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51630: LD_ADDR_EXP 47
51634: PUSH
51635: LD_EXP 47
51639: PPUSH
51640: LD_VAR 0 4
51644: PPUSH
51645: EMPTY
51646: PPUSH
51647: CALL_OW 1
51651: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51652: LD_ADDR_EXP 48
51656: PUSH
51657: LD_EXP 48
51661: PPUSH
51662: LD_VAR 0 4
51666: PPUSH
51667: EMPTY
51668: PPUSH
51669: CALL_OW 1
51673: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51674: LD_ADDR_EXP 50
51678: PUSH
51679: LD_EXP 50
51683: PPUSH
51684: LD_VAR 0 4
51688: PPUSH
51689: EMPTY
51690: PPUSH
51691: CALL_OW 1
51695: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51696: LD_ADDR_EXP 52
51700: PUSH
51701: LD_EXP 52
51705: PPUSH
51706: LD_VAR 0 4
51710: PPUSH
51711: EMPTY
51712: PPUSH
51713: CALL_OW 1
51717: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51718: LD_ADDR_EXP 53
51722: PUSH
51723: LD_EXP 53
51727: PPUSH
51728: LD_VAR 0 4
51732: PPUSH
51733: EMPTY
51734: PPUSH
51735: CALL_OW 1
51739: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51740: LD_ADDR_EXP 54
51744: PUSH
51745: LD_EXP 54
51749: PPUSH
51750: LD_VAR 0 4
51754: PPUSH
51755: EMPTY
51756: PPUSH
51757: CALL_OW 1
51761: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51762: LD_ADDR_EXP 55
51766: PUSH
51767: LD_EXP 55
51771: PPUSH
51772: LD_VAR 0 4
51776: PPUSH
51777: EMPTY
51778: PPUSH
51779: CALL_OW 1
51783: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51784: LD_ADDR_EXP 56
51788: PUSH
51789: LD_EXP 56
51793: PPUSH
51794: LD_VAR 0 4
51798: PPUSH
51799: EMPTY
51800: PPUSH
51801: CALL_OW 1
51805: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51806: LD_ADDR_EXP 57
51810: PUSH
51811: LD_EXP 57
51815: PPUSH
51816: LD_VAR 0 4
51820: PPUSH
51821: EMPTY
51822: PPUSH
51823: CALL_OW 1
51827: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51828: LD_ADDR_EXP 58
51832: PUSH
51833: LD_EXP 58
51837: PPUSH
51838: LD_VAR 0 4
51842: PPUSH
51843: EMPTY
51844: PPUSH
51845: CALL_OW 1
51849: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51850: LD_ADDR_EXP 59
51854: PUSH
51855: LD_EXP 59
51859: PPUSH
51860: LD_VAR 0 4
51864: PPUSH
51865: EMPTY
51866: PPUSH
51867: CALL_OW 1
51871: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51872: LD_ADDR_EXP 60
51876: PUSH
51877: LD_EXP 60
51881: PPUSH
51882: LD_VAR 0 4
51886: PPUSH
51887: EMPTY
51888: PPUSH
51889: CALL_OW 1
51893: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51894: LD_ADDR_EXP 61
51898: PUSH
51899: LD_EXP 61
51903: PPUSH
51904: LD_VAR 0 4
51908: PPUSH
51909: EMPTY
51910: PPUSH
51911: CALL_OW 1
51915: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51916: LD_ADDR_EXP 62
51920: PUSH
51921: LD_EXP 62
51925: PPUSH
51926: LD_VAR 0 4
51930: PPUSH
51931: EMPTY
51932: PPUSH
51933: CALL_OW 1
51937: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51938: LD_ADDR_EXP 63
51942: PUSH
51943: LD_EXP 63
51947: PPUSH
51948: LD_VAR 0 4
51952: PPUSH
51953: EMPTY
51954: PPUSH
51955: CALL_OW 1
51959: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51960: LD_ADDR_EXP 64
51964: PUSH
51965: LD_EXP 64
51969: PPUSH
51970: LD_VAR 0 4
51974: PPUSH
51975: EMPTY
51976: PPUSH
51977: CALL_OW 1
51981: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51982: LD_ADDR_EXP 65
51986: PUSH
51987: LD_EXP 65
51991: PPUSH
51992: LD_VAR 0 4
51996: PPUSH
51997: LD_INT 0
51999: PPUSH
52000: CALL_OW 1
52004: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52005: LD_ADDR_EXP 66
52009: PUSH
52010: LD_EXP 66
52014: PPUSH
52015: LD_VAR 0 4
52019: PPUSH
52020: LD_INT 0
52022: PPUSH
52023: CALL_OW 1
52027: ST_TO_ADDR
// result := base ;
52028: LD_ADDR_VAR 0 3
52032: PUSH
52033: LD_VAR 0 4
52037: ST_TO_ADDR
// end ;
52038: LD_VAR 0 3
52042: RET
// export function MC_Start ( ) ; var i ; begin
52043: LD_INT 0
52045: PPUSH
52046: PPUSH
// for i = 1 to mc_bases do
52047: LD_ADDR_VAR 0 2
52051: PUSH
52052: DOUBLE
52053: LD_INT 1
52055: DEC
52056: ST_TO_ADDR
52057: LD_EXP 23
52061: PUSH
52062: FOR_TO
52063: IFFALSE 53163
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52065: LD_ADDR_EXP 23
52069: PUSH
52070: LD_EXP 23
52074: PPUSH
52075: LD_VAR 0 2
52079: PPUSH
52080: LD_EXP 23
52084: PUSH
52085: LD_VAR 0 2
52089: ARRAY
52090: PUSH
52091: LD_INT 0
52093: DIFF
52094: PPUSH
52095: CALL_OW 1
52099: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52100: LD_ADDR_EXP 24
52104: PUSH
52105: LD_EXP 24
52109: PPUSH
52110: LD_VAR 0 2
52114: PPUSH
52115: EMPTY
52116: PPUSH
52117: CALL_OW 1
52121: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52122: LD_ADDR_EXP 25
52126: PUSH
52127: LD_EXP 25
52131: PPUSH
52132: LD_VAR 0 2
52136: PPUSH
52137: EMPTY
52138: PPUSH
52139: CALL_OW 1
52143: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52144: LD_ADDR_EXP 26
52148: PUSH
52149: LD_EXP 26
52153: PPUSH
52154: LD_VAR 0 2
52158: PPUSH
52159: EMPTY
52160: PPUSH
52161: CALL_OW 1
52165: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52166: LD_ADDR_EXP 27
52170: PUSH
52171: LD_EXP 27
52175: PPUSH
52176: LD_VAR 0 2
52180: PPUSH
52181: EMPTY
52182: PUSH
52183: EMPTY
52184: PUSH
52185: EMPTY
52186: LIST
52187: LIST
52188: PPUSH
52189: CALL_OW 1
52193: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52194: LD_ADDR_EXP 28
52198: PUSH
52199: LD_EXP 28
52203: PPUSH
52204: LD_VAR 0 2
52208: PPUSH
52209: EMPTY
52210: PPUSH
52211: CALL_OW 1
52215: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52216: LD_ADDR_EXP 55
52220: PUSH
52221: LD_EXP 55
52225: PPUSH
52226: LD_VAR 0 2
52230: PPUSH
52231: EMPTY
52232: PPUSH
52233: CALL_OW 1
52237: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52238: LD_ADDR_EXP 29
52242: PUSH
52243: LD_EXP 29
52247: PPUSH
52248: LD_VAR 0 2
52252: PPUSH
52253: EMPTY
52254: PPUSH
52255: CALL_OW 1
52259: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52260: LD_ADDR_EXP 30
52264: PUSH
52265: LD_EXP 30
52269: PPUSH
52270: LD_VAR 0 2
52274: PPUSH
52275: EMPTY
52276: PPUSH
52277: CALL_OW 1
52281: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52282: LD_ADDR_EXP 31
52286: PUSH
52287: LD_EXP 31
52291: PPUSH
52292: LD_VAR 0 2
52296: PPUSH
52297: LD_EXP 23
52301: PUSH
52302: LD_VAR 0 2
52306: ARRAY
52307: PPUSH
52308: LD_INT 2
52310: PUSH
52311: LD_INT 30
52313: PUSH
52314: LD_INT 32
52316: PUSH
52317: EMPTY
52318: LIST
52319: LIST
52320: PUSH
52321: LD_INT 30
52323: PUSH
52324: LD_INT 33
52326: PUSH
52327: EMPTY
52328: LIST
52329: LIST
52330: PUSH
52331: EMPTY
52332: LIST
52333: LIST
52334: LIST
52335: PPUSH
52336: CALL_OW 72
52340: PPUSH
52341: CALL_OW 1
52345: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52346: LD_ADDR_EXP 32
52350: PUSH
52351: LD_EXP 32
52355: PPUSH
52356: LD_VAR 0 2
52360: PPUSH
52361: LD_EXP 23
52365: PUSH
52366: LD_VAR 0 2
52370: ARRAY
52371: PPUSH
52372: LD_INT 2
52374: PUSH
52375: LD_INT 30
52377: PUSH
52378: LD_INT 32
52380: PUSH
52381: EMPTY
52382: LIST
52383: LIST
52384: PUSH
52385: LD_INT 30
52387: PUSH
52388: LD_INT 31
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: PUSH
52395: EMPTY
52396: LIST
52397: LIST
52398: LIST
52399: PUSH
52400: LD_INT 58
52402: PUSH
52403: EMPTY
52404: LIST
52405: PUSH
52406: EMPTY
52407: LIST
52408: LIST
52409: PPUSH
52410: CALL_OW 72
52414: PPUSH
52415: CALL_OW 1
52419: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
52420: LD_ADDR_EXP 33
52424: PUSH
52425: LD_EXP 33
52429: PPUSH
52430: LD_VAR 0 2
52434: PPUSH
52435: EMPTY
52436: PPUSH
52437: CALL_OW 1
52441: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
52442: LD_ADDR_EXP 37
52446: PUSH
52447: LD_EXP 37
52451: PPUSH
52452: LD_VAR 0 2
52456: PPUSH
52457: EMPTY
52458: PPUSH
52459: CALL_OW 1
52463: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
52464: LD_ADDR_EXP 36
52468: PUSH
52469: LD_EXP 36
52473: PPUSH
52474: LD_VAR 0 2
52478: PPUSH
52479: EMPTY
52480: PPUSH
52481: CALL_OW 1
52485: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
52486: LD_ADDR_EXP 38
52490: PUSH
52491: LD_EXP 38
52495: PPUSH
52496: LD_VAR 0 2
52500: PPUSH
52501: EMPTY
52502: PPUSH
52503: CALL_OW 1
52507: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
52508: LD_ADDR_EXP 39
52512: PUSH
52513: LD_EXP 39
52517: PPUSH
52518: LD_VAR 0 2
52522: PPUSH
52523: EMPTY
52524: PPUSH
52525: CALL_OW 1
52529: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52530: LD_ADDR_EXP 40
52534: PUSH
52535: LD_EXP 40
52539: PPUSH
52540: LD_VAR 0 2
52544: PPUSH
52545: EMPTY
52546: PPUSH
52547: CALL_OW 1
52551: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
52552: LD_ADDR_EXP 41
52556: PUSH
52557: LD_EXP 41
52561: PPUSH
52562: LD_VAR 0 2
52566: PPUSH
52567: EMPTY
52568: PPUSH
52569: CALL_OW 1
52573: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
52574: LD_ADDR_EXP 42
52578: PUSH
52579: LD_EXP 42
52583: PPUSH
52584: LD_VAR 0 2
52588: PPUSH
52589: EMPTY
52590: PPUSH
52591: CALL_OW 1
52595: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52596: LD_ADDR_EXP 43
52600: PUSH
52601: LD_EXP 43
52605: PPUSH
52606: LD_VAR 0 2
52610: PPUSH
52611: EMPTY
52612: PPUSH
52613: CALL_OW 1
52617: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
52618: LD_ADDR_EXP 44
52622: PUSH
52623: LD_EXP 44
52627: PPUSH
52628: LD_VAR 0 2
52632: PPUSH
52633: EMPTY
52634: PPUSH
52635: CALL_OW 1
52639: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
52640: LD_ADDR_EXP 45
52644: PUSH
52645: LD_EXP 45
52649: PPUSH
52650: LD_VAR 0 2
52654: PPUSH
52655: EMPTY
52656: PPUSH
52657: CALL_OW 1
52661: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
52662: LD_ADDR_EXP 34
52666: PUSH
52667: LD_EXP 34
52671: PPUSH
52672: LD_VAR 0 2
52676: PPUSH
52677: LD_INT 0
52679: PPUSH
52680: CALL_OW 1
52684: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
52685: LD_ADDR_EXP 47
52689: PUSH
52690: LD_EXP 47
52694: PPUSH
52695: LD_VAR 0 2
52699: PPUSH
52700: LD_INT 0
52702: PPUSH
52703: CALL_OW 1
52707: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52708: LD_ADDR_EXP 35
52712: PUSH
52713: LD_EXP 35
52717: PPUSH
52718: LD_VAR 0 2
52722: PPUSH
52723: EMPTY
52724: PPUSH
52725: CALL_OW 1
52729: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
52730: LD_ADDR_EXP 46
52734: PUSH
52735: LD_EXP 46
52739: PPUSH
52740: LD_VAR 0 2
52744: PPUSH
52745: LD_INT 0
52747: PPUSH
52748: CALL_OW 1
52752: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
52753: LD_ADDR_EXP 48
52757: PUSH
52758: LD_EXP 48
52762: PPUSH
52763: LD_VAR 0 2
52767: PPUSH
52768: EMPTY
52769: PPUSH
52770: CALL_OW 1
52774: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
52775: LD_ADDR_EXP 51
52779: PUSH
52780: LD_EXP 51
52784: PPUSH
52785: LD_VAR 0 2
52789: PPUSH
52790: LD_INT 0
52792: PPUSH
52793: CALL_OW 1
52797: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
52798: LD_ADDR_EXP 52
52802: PUSH
52803: LD_EXP 52
52807: PPUSH
52808: LD_VAR 0 2
52812: PPUSH
52813: EMPTY
52814: PPUSH
52815: CALL_OW 1
52819: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
52820: LD_ADDR_EXP 53
52824: PUSH
52825: LD_EXP 53
52829: PPUSH
52830: LD_VAR 0 2
52834: PPUSH
52835: EMPTY
52836: PPUSH
52837: CALL_OW 1
52841: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52842: LD_ADDR_EXP 54
52846: PUSH
52847: LD_EXP 54
52851: PPUSH
52852: LD_VAR 0 2
52856: PPUSH
52857: EMPTY
52858: PPUSH
52859: CALL_OW 1
52863: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
52864: LD_ADDR_EXP 56
52868: PUSH
52869: LD_EXP 56
52873: PPUSH
52874: LD_VAR 0 2
52878: PPUSH
52879: LD_EXP 23
52883: PUSH
52884: LD_VAR 0 2
52888: ARRAY
52889: PPUSH
52890: LD_INT 2
52892: PUSH
52893: LD_INT 30
52895: PUSH
52896: LD_INT 6
52898: PUSH
52899: EMPTY
52900: LIST
52901: LIST
52902: PUSH
52903: LD_INT 30
52905: PUSH
52906: LD_INT 7
52908: PUSH
52909: EMPTY
52910: LIST
52911: LIST
52912: PUSH
52913: LD_INT 30
52915: PUSH
52916: LD_INT 8
52918: PUSH
52919: EMPTY
52920: LIST
52921: LIST
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: LIST
52927: LIST
52928: PPUSH
52929: CALL_OW 72
52933: PPUSH
52934: CALL_OW 1
52938: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
52939: LD_ADDR_EXP 57
52943: PUSH
52944: LD_EXP 57
52948: PPUSH
52949: LD_VAR 0 2
52953: PPUSH
52954: EMPTY
52955: PPUSH
52956: CALL_OW 1
52960: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
52961: LD_ADDR_EXP 58
52965: PUSH
52966: LD_EXP 58
52970: PPUSH
52971: LD_VAR 0 2
52975: PPUSH
52976: EMPTY
52977: PPUSH
52978: CALL_OW 1
52982: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
52983: LD_ADDR_EXP 59
52987: PUSH
52988: LD_EXP 59
52992: PPUSH
52993: LD_VAR 0 2
52997: PPUSH
52998: EMPTY
52999: PPUSH
53000: CALL_OW 1
53004: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53005: LD_ADDR_EXP 60
53009: PUSH
53010: LD_EXP 60
53014: PPUSH
53015: LD_VAR 0 2
53019: PPUSH
53020: EMPTY
53021: PPUSH
53022: CALL_OW 1
53026: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53027: LD_ADDR_EXP 61
53031: PUSH
53032: LD_EXP 61
53036: PPUSH
53037: LD_VAR 0 2
53041: PPUSH
53042: EMPTY
53043: PPUSH
53044: CALL_OW 1
53048: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53049: LD_ADDR_EXP 62
53053: PUSH
53054: LD_EXP 62
53058: PPUSH
53059: LD_VAR 0 2
53063: PPUSH
53064: EMPTY
53065: PPUSH
53066: CALL_OW 1
53070: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53071: LD_ADDR_EXP 63
53075: PUSH
53076: LD_EXP 63
53080: PPUSH
53081: LD_VAR 0 2
53085: PPUSH
53086: EMPTY
53087: PPUSH
53088: CALL_OW 1
53092: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53093: LD_ADDR_EXP 64
53097: PUSH
53098: LD_EXP 64
53102: PPUSH
53103: LD_VAR 0 2
53107: PPUSH
53108: EMPTY
53109: PPUSH
53110: CALL_OW 1
53114: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53115: LD_ADDR_EXP 65
53119: PUSH
53120: LD_EXP 65
53124: PPUSH
53125: LD_VAR 0 2
53129: PPUSH
53130: LD_INT 0
53132: PPUSH
53133: CALL_OW 1
53137: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
53138: LD_ADDR_EXP 66
53142: PUSH
53143: LD_EXP 66
53147: PPUSH
53148: LD_VAR 0 2
53152: PPUSH
53153: LD_INT 0
53155: PPUSH
53156: CALL_OW 1
53160: ST_TO_ADDR
// end ;
53161: GO 52062
53163: POP
53164: POP
// MC_InitSides ( ) ;
53165: CALL 53451 0 0
// MC_InitResearch ( ) ;
53169: CALL 53190 0 0
// CustomInitMacro ( ) ;
53173: CALL 277 0 0
// skirmish := true ;
53177: LD_ADDR_EXP 21
53181: PUSH
53182: LD_INT 1
53184: ST_TO_ADDR
// end ;
53185: LD_VAR 0 1
53189: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53190: LD_INT 0
53192: PPUSH
53193: PPUSH
53194: PPUSH
53195: PPUSH
53196: PPUSH
53197: PPUSH
// if not mc_bases then
53198: LD_EXP 23
53202: NOT
53203: IFFALSE 53207
// exit ;
53205: GO 53446
// for i = 1 to 8 do
53207: LD_ADDR_VAR 0 2
53211: PUSH
53212: DOUBLE
53213: LD_INT 1
53215: DEC
53216: ST_TO_ADDR
53217: LD_INT 8
53219: PUSH
53220: FOR_TO
53221: IFFALSE 53247
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53223: LD_ADDR_EXP 50
53227: PUSH
53228: LD_EXP 50
53232: PPUSH
53233: LD_VAR 0 2
53237: PPUSH
53238: EMPTY
53239: PPUSH
53240: CALL_OW 1
53244: ST_TO_ADDR
53245: GO 53220
53247: POP
53248: POP
// tmp := [ ] ;
53249: LD_ADDR_VAR 0 5
53253: PUSH
53254: EMPTY
53255: ST_TO_ADDR
// for i = 1 to mc_sides do
53256: LD_ADDR_VAR 0 2
53260: PUSH
53261: DOUBLE
53262: LD_INT 1
53264: DEC
53265: ST_TO_ADDR
53266: LD_EXP 49
53270: PUSH
53271: FOR_TO
53272: IFFALSE 53330
// if not mc_sides [ i ] in tmp then
53274: LD_EXP 49
53278: PUSH
53279: LD_VAR 0 2
53283: ARRAY
53284: PUSH
53285: LD_VAR 0 5
53289: IN
53290: NOT
53291: IFFALSE 53328
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53293: LD_ADDR_VAR 0 5
53297: PUSH
53298: LD_VAR 0 5
53302: PPUSH
53303: LD_VAR 0 5
53307: PUSH
53308: LD_INT 1
53310: PLUS
53311: PPUSH
53312: LD_EXP 49
53316: PUSH
53317: LD_VAR 0 2
53321: ARRAY
53322: PPUSH
53323: CALL_OW 2
53327: ST_TO_ADDR
53328: GO 53271
53330: POP
53331: POP
// if not tmp then
53332: LD_VAR 0 5
53336: NOT
53337: IFFALSE 53341
// exit ;
53339: GO 53446
// for j in tmp do
53341: LD_ADDR_VAR 0 3
53345: PUSH
53346: LD_VAR 0 5
53350: PUSH
53351: FOR_IN
53352: IFFALSE 53444
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53354: LD_ADDR_VAR 0 6
53358: PUSH
53359: LD_INT 22
53361: PUSH
53362: LD_VAR 0 3
53366: PUSH
53367: EMPTY
53368: LIST
53369: LIST
53370: PPUSH
53371: CALL_OW 69
53375: ST_TO_ADDR
// if not un then
53376: LD_VAR 0 6
53380: NOT
53381: IFFALSE 53385
// continue ;
53383: GO 53351
// nation := GetNation ( un [ 1 ] ) ;
53385: LD_ADDR_VAR 0 4
53389: PUSH
53390: LD_VAR 0 6
53394: PUSH
53395: LD_INT 1
53397: ARRAY
53398: PPUSH
53399: CALL_OW 248
53403: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
53404: LD_ADDR_EXP 50
53408: PUSH
53409: LD_EXP 50
53413: PPUSH
53414: LD_VAR 0 3
53418: PPUSH
53419: LD_VAR 0 3
53423: PPUSH
53424: LD_VAR 0 4
53428: PPUSH
53429: LD_INT 1
53431: PPUSH
53432: CALL 11067 0 3
53436: PPUSH
53437: CALL_OW 1
53441: ST_TO_ADDR
// end ;
53442: GO 53351
53444: POP
53445: POP
// end ;
53446: LD_VAR 0 1
53450: RET
// export function MC_InitSides ( ) ; var i ; begin
53451: LD_INT 0
53453: PPUSH
53454: PPUSH
// if not mc_bases then
53455: LD_EXP 23
53459: NOT
53460: IFFALSE 53464
// exit ;
53462: GO 53538
// for i = 1 to mc_bases do
53464: LD_ADDR_VAR 0 2
53468: PUSH
53469: DOUBLE
53470: LD_INT 1
53472: DEC
53473: ST_TO_ADDR
53474: LD_EXP 23
53478: PUSH
53479: FOR_TO
53480: IFFALSE 53536
// if mc_bases [ i ] then
53482: LD_EXP 23
53486: PUSH
53487: LD_VAR 0 2
53491: ARRAY
53492: IFFALSE 53534
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
53494: LD_ADDR_EXP 49
53498: PUSH
53499: LD_EXP 49
53503: PPUSH
53504: LD_VAR 0 2
53508: PPUSH
53509: LD_EXP 23
53513: PUSH
53514: LD_VAR 0 2
53518: ARRAY
53519: PUSH
53520: LD_INT 1
53522: ARRAY
53523: PPUSH
53524: CALL_OW 255
53528: PPUSH
53529: CALL_OW 1
53533: ST_TO_ADDR
53534: GO 53479
53536: POP
53537: POP
// end ;
53538: LD_VAR 0 1
53542: RET
// every 0 0$03 trigger skirmish do
53543: LD_EXP 21
53547: IFFALSE 53701
53549: GO 53551
53551: DISABLE
// begin enable ;
53552: ENABLE
// MC_CheckBuildings ( ) ;
53553: CALL 58199 0 0
// MC_CheckPeopleLife ( ) ;
53557: CALL 58360 0 0
// RaiseSailEvent ( 100 ) ;
53561: LD_INT 100
53563: PPUSH
53564: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
53568: LD_INT 103
53570: PPUSH
53571: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
53575: LD_INT 104
53577: PPUSH
53578: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
53582: LD_INT 105
53584: PPUSH
53585: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
53589: LD_INT 106
53591: PPUSH
53592: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
53596: LD_INT 107
53598: PPUSH
53599: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
53603: LD_INT 108
53605: PPUSH
53606: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
53610: LD_INT 109
53612: PPUSH
53613: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
53617: LD_INT 110
53619: PPUSH
53620: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
53624: LD_INT 111
53626: PPUSH
53627: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
53631: LD_INT 112
53633: PPUSH
53634: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
53638: LD_INT 113
53640: PPUSH
53641: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
53645: LD_INT 120
53647: PPUSH
53648: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
53652: LD_INT 121
53654: PPUSH
53655: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
53659: LD_INT 122
53661: PPUSH
53662: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
53666: LD_INT 123
53668: PPUSH
53669: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
53673: LD_INT 124
53675: PPUSH
53676: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
53680: LD_INT 125
53682: PPUSH
53683: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
53687: LD_INT 126
53689: PPUSH
53690: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
53694: LD_INT 200
53696: PPUSH
53697: CALL_OW 427
// end ;
53701: END
// on SailEvent ( event ) do begin if event < 100 then
53702: LD_VAR 0 1
53706: PUSH
53707: LD_INT 100
53709: LESS
53710: IFFALSE 53721
// CustomEvent ( event ) ;
53712: LD_VAR 0 1
53716: PPUSH
53717: CALL 10241 0 1
// if event = 100 then
53721: LD_VAR 0 1
53725: PUSH
53726: LD_INT 100
53728: EQUAL
53729: IFFALSE 53735
// MC_ClassManager ( ) ;
53731: CALL 54127 0 0
// if event = 101 then
53735: LD_VAR 0 1
53739: PUSH
53740: LD_INT 101
53742: EQUAL
53743: IFFALSE 53749
// MC_RepairBuildings ( ) ;
53745: CALL 58945 0 0
// if event = 102 then
53749: LD_VAR 0 1
53753: PUSH
53754: LD_INT 102
53756: EQUAL
53757: IFFALSE 53763
// MC_Heal ( ) ;
53759: CALL 59852 0 0
// if event = 103 then
53763: LD_VAR 0 1
53767: PUSH
53768: LD_INT 103
53770: EQUAL
53771: IFFALSE 53777
// MC_Build ( ) ;
53773: CALL 60274 0 0
// if event = 104 then
53777: LD_VAR 0 1
53781: PUSH
53782: LD_INT 104
53784: EQUAL
53785: IFFALSE 53791
// MC_TurretWeapon ( ) ;
53787: CALL 61915 0 0
// if event = 105 then
53791: LD_VAR 0 1
53795: PUSH
53796: LD_INT 105
53798: EQUAL
53799: IFFALSE 53805
// MC_BuildUpgrade ( ) ;
53801: CALL 61466 0 0
// if event = 106 then
53805: LD_VAR 0 1
53809: PUSH
53810: LD_INT 106
53812: EQUAL
53813: IFFALSE 53819
// MC_PlantMines ( ) ;
53815: CALL 62345 0 0
// if event = 107 then
53819: LD_VAR 0 1
53823: PUSH
53824: LD_INT 107
53826: EQUAL
53827: IFFALSE 53833
// MC_CollectCrates ( ) ;
53829: CALL 63136 0 0
// if event = 108 then
53833: LD_VAR 0 1
53837: PUSH
53838: LD_INT 108
53840: EQUAL
53841: IFFALSE 53847
// MC_LinkRemoteControl ( ) ;
53843: CALL 64986 0 0
// if event = 109 then
53847: LD_VAR 0 1
53851: PUSH
53852: LD_INT 109
53854: EQUAL
53855: IFFALSE 53861
// MC_ProduceVehicle ( ) ;
53857: CALL 65167 0 0
// if event = 110 then
53861: LD_VAR 0 1
53865: PUSH
53866: LD_INT 110
53868: EQUAL
53869: IFFALSE 53875
// MC_SendAttack ( ) ;
53871: CALL 65633 0 0
// if event = 111 then
53875: LD_VAR 0 1
53879: PUSH
53880: LD_INT 111
53882: EQUAL
53883: IFFALSE 53889
// MC_Defend ( ) ;
53885: CALL 65741 0 0
// if event = 112 then
53889: LD_VAR 0 1
53893: PUSH
53894: LD_INT 112
53896: EQUAL
53897: IFFALSE 53903
// MC_Research ( ) ;
53899: CALL 66474 0 0
// if event = 113 then
53903: LD_VAR 0 1
53907: PUSH
53908: LD_INT 113
53910: EQUAL
53911: IFFALSE 53917
// MC_MinesTrigger ( ) ;
53913: CALL 67588 0 0
// if event = 120 then
53917: LD_VAR 0 1
53921: PUSH
53922: LD_INT 120
53924: EQUAL
53925: IFFALSE 53931
// MC_RepairVehicle ( ) ;
53927: CALL 67687 0 0
// if event = 121 then
53931: LD_VAR 0 1
53935: PUSH
53936: LD_INT 121
53938: EQUAL
53939: IFFALSE 53945
// MC_TameApe ( ) ;
53941: CALL 68428 0 0
// if event = 122 then
53945: LD_VAR 0 1
53949: PUSH
53950: LD_INT 122
53952: EQUAL
53953: IFFALSE 53959
// MC_ChangeApeClass ( ) ;
53955: CALL 69257 0 0
// if event = 123 then
53959: LD_VAR 0 1
53963: PUSH
53964: LD_INT 123
53966: EQUAL
53967: IFFALSE 53973
// MC_Bazooka ( ) ;
53969: CALL 69907 0 0
// if event = 124 then
53973: LD_VAR 0 1
53977: PUSH
53978: LD_INT 124
53980: EQUAL
53981: IFFALSE 53987
// MC_TeleportExit ( ) ;
53983: CALL 70105 0 0
// if event = 125 then
53987: LD_VAR 0 1
53991: PUSH
53992: LD_INT 125
53994: EQUAL
53995: IFFALSE 54001
// MC_Deposits ( ) ;
53997: CALL 70752 0 0
// if event = 126 then
54001: LD_VAR 0 1
54005: PUSH
54006: LD_INT 126
54008: EQUAL
54009: IFFALSE 54015
// MC_RemoteDriver ( ) ;
54011: CALL 71377 0 0
// if event = 200 then
54015: LD_VAR 0 1
54019: PUSH
54020: LD_INT 200
54022: EQUAL
54023: IFFALSE 54029
// MC_Idle ( ) ;
54025: CALL 73326 0 0
// end ;
54029: PPOPN 1
54031: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54032: LD_INT 0
54034: PPUSH
54035: PPUSH
// if not mc_bases [ base ] or not tag then
54036: LD_EXP 23
54040: PUSH
54041: LD_VAR 0 1
54045: ARRAY
54046: NOT
54047: PUSH
54048: LD_VAR 0 2
54052: NOT
54053: OR
54054: IFFALSE 54058
// exit ;
54056: GO 54122
// for i in mc_bases [ base ] union mc_ape [ base ] do
54058: LD_ADDR_VAR 0 4
54062: PUSH
54063: LD_EXP 23
54067: PUSH
54068: LD_VAR 0 1
54072: ARRAY
54073: PUSH
54074: LD_EXP 52
54078: PUSH
54079: LD_VAR 0 1
54083: ARRAY
54084: UNION
54085: PUSH
54086: FOR_IN
54087: IFFALSE 54120
// if GetTag ( i ) = tag then
54089: LD_VAR 0 4
54093: PPUSH
54094: CALL_OW 110
54098: PUSH
54099: LD_VAR 0 2
54103: EQUAL
54104: IFFALSE 54118
// SetTag ( i , 0 ) ;
54106: LD_VAR 0 4
54110: PPUSH
54111: LD_INT 0
54113: PPUSH
54114: CALL_OW 109
54118: GO 54086
54120: POP
54121: POP
// end ;
54122: LD_VAR 0 3
54126: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54127: LD_INT 0
54129: PPUSH
54130: PPUSH
54131: PPUSH
54132: PPUSH
54133: PPUSH
54134: PPUSH
54135: PPUSH
54136: PPUSH
// if not mc_bases then
54137: LD_EXP 23
54141: NOT
54142: IFFALSE 54146
// exit ;
54144: GO 54604
// for i = 1 to mc_bases do
54146: LD_ADDR_VAR 0 2
54150: PUSH
54151: DOUBLE
54152: LD_INT 1
54154: DEC
54155: ST_TO_ADDR
54156: LD_EXP 23
54160: PUSH
54161: FOR_TO
54162: IFFALSE 54602
// begin tmp := MC_ClassCheckReq ( i ) ;
54164: LD_ADDR_VAR 0 4
54168: PUSH
54169: LD_VAR 0 2
54173: PPUSH
54174: CALL 54609 0 1
54178: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54179: LD_ADDR_EXP 64
54183: PUSH
54184: LD_EXP 64
54188: PPUSH
54189: LD_VAR 0 2
54193: PPUSH
54194: LD_VAR 0 4
54198: PPUSH
54199: CALL_OW 1
54203: ST_TO_ADDR
// if not tmp then
54204: LD_VAR 0 4
54208: NOT
54209: IFFALSE 54213
// continue ;
54211: GO 54161
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54213: LD_ADDR_VAR 0 6
54217: PUSH
54218: LD_EXP 23
54222: PUSH
54223: LD_VAR 0 2
54227: ARRAY
54228: PPUSH
54229: LD_INT 2
54231: PUSH
54232: LD_INT 30
54234: PUSH
54235: LD_INT 4
54237: PUSH
54238: EMPTY
54239: LIST
54240: LIST
54241: PUSH
54242: LD_INT 30
54244: PUSH
54245: LD_INT 5
54247: PUSH
54248: EMPTY
54249: LIST
54250: LIST
54251: PUSH
54252: EMPTY
54253: LIST
54254: LIST
54255: LIST
54256: PPUSH
54257: CALL_OW 72
54261: PUSH
54262: LD_EXP 23
54266: PUSH
54267: LD_VAR 0 2
54271: ARRAY
54272: PPUSH
54273: LD_INT 2
54275: PUSH
54276: LD_INT 30
54278: PUSH
54279: LD_INT 0
54281: PUSH
54282: EMPTY
54283: LIST
54284: LIST
54285: PUSH
54286: LD_INT 30
54288: PUSH
54289: LD_INT 1
54291: PUSH
54292: EMPTY
54293: LIST
54294: LIST
54295: PUSH
54296: EMPTY
54297: LIST
54298: LIST
54299: LIST
54300: PPUSH
54301: CALL_OW 72
54305: PUSH
54306: LD_EXP 23
54310: PUSH
54311: LD_VAR 0 2
54315: ARRAY
54316: PPUSH
54317: LD_INT 30
54319: PUSH
54320: LD_INT 3
54322: PUSH
54323: EMPTY
54324: LIST
54325: LIST
54326: PPUSH
54327: CALL_OW 72
54331: PUSH
54332: LD_EXP 23
54336: PUSH
54337: LD_VAR 0 2
54341: ARRAY
54342: PPUSH
54343: LD_INT 2
54345: PUSH
54346: LD_INT 30
54348: PUSH
54349: LD_INT 6
54351: PUSH
54352: EMPTY
54353: LIST
54354: LIST
54355: PUSH
54356: LD_INT 30
54358: PUSH
54359: LD_INT 7
54361: PUSH
54362: EMPTY
54363: LIST
54364: LIST
54365: PUSH
54366: LD_INT 30
54368: PUSH
54369: LD_INT 8
54371: PUSH
54372: EMPTY
54373: LIST
54374: LIST
54375: PUSH
54376: EMPTY
54377: LIST
54378: LIST
54379: LIST
54380: LIST
54381: PPUSH
54382: CALL_OW 72
54386: PUSH
54387: EMPTY
54388: LIST
54389: LIST
54390: LIST
54391: LIST
54392: ST_TO_ADDR
// for j = 1 to 4 do
54393: LD_ADDR_VAR 0 3
54397: PUSH
54398: DOUBLE
54399: LD_INT 1
54401: DEC
54402: ST_TO_ADDR
54403: LD_INT 4
54405: PUSH
54406: FOR_TO
54407: IFFALSE 54598
// begin if not tmp [ j ] then
54409: LD_VAR 0 4
54413: PUSH
54414: LD_VAR 0 3
54418: ARRAY
54419: NOT
54420: IFFALSE 54424
// continue ;
54422: GO 54406
// for p in tmp [ j ] do
54424: LD_ADDR_VAR 0 5
54428: PUSH
54429: LD_VAR 0 4
54433: PUSH
54434: LD_VAR 0 3
54438: ARRAY
54439: PUSH
54440: FOR_IN
54441: IFFALSE 54594
// begin if not b [ j ] then
54443: LD_VAR 0 6
54447: PUSH
54448: LD_VAR 0 3
54452: ARRAY
54453: NOT
54454: IFFALSE 54458
// break ;
54456: GO 54594
// e := 0 ;
54458: LD_ADDR_VAR 0 7
54462: PUSH
54463: LD_INT 0
54465: ST_TO_ADDR
// for k in b [ j ] do
54466: LD_ADDR_VAR 0 8
54470: PUSH
54471: LD_VAR 0 6
54475: PUSH
54476: LD_VAR 0 3
54480: ARRAY
54481: PUSH
54482: FOR_IN
54483: IFFALSE 54510
// if IsNotFull ( k ) then
54485: LD_VAR 0 8
54489: PPUSH
54490: CALL 13220 0 1
54494: IFFALSE 54508
// begin e := k ;
54496: LD_ADDR_VAR 0 7
54500: PUSH
54501: LD_VAR 0 8
54505: ST_TO_ADDR
// break ;
54506: GO 54510
// end ;
54508: GO 54482
54510: POP
54511: POP
// if e and not UnitGoingToBuilding ( p , e ) then
54512: LD_VAR 0 7
54516: PUSH
54517: LD_VAR 0 5
54521: PPUSH
54522: LD_VAR 0 7
54526: PPUSH
54527: CALL 46384 0 2
54531: NOT
54532: AND
54533: IFFALSE 54592
// begin if IsInUnit ( p ) then
54535: LD_VAR 0 5
54539: PPUSH
54540: CALL_OW 310
54544: IFFALSE 54555
// ComExitBuilding ( p ) ;
54546: LD_VAR 0 5
54550: PPUSH
54551: CALL_OW 122
// ComEnterUnit ( p , e ) ;
54555: LD_VAR 0 5
54559: PPUSH
54560: LD_VAR 0 7
54564: PPUSH
54565: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
54569: LD_VAR 0 5
54573: PPUSH
54574: LD_VAR 0 3
54578: PPUSH
54579: CALL_OW 183
// AddComExitBuilding ( p ) ;
54583: LD_VAR 0 5
54587: PPUSH
54588: CALL_OW 182
// end ; end ;
54592: GO 54440
54594: POP
54595: POP
// end ;
54596: GO 54406
54598: POP
54599: POP
// end ;
54600: GO 54161
54602: POP
54603: POP
// end ;
54604: LD_VAR 0 1
54608: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
54609: LD_INT 0
54611: PPUSH
54612: PPUSH
54613: PPUSH
54614: PPUSH
54615: PPUSH
54616: PPUSH
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
54621: PPUSH
54622: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54623: LD_VAR 0 1
54627: NOT
54628: PUSH
54629: LD_EXP 23
54633: PUSH
54634: LD_VAR 0 1
54638: ARRAY
54639: NOT
54640: OR
54641: PUSH
54642: LD_EXP 23
54646: PUSH
54647: LD_VAR 0 1
54651: ARRAY
54652: PPUSH
54653: LD_INT 2
54655: PUSH
54656: LD_INT 30
54658: PUSH
54659: LD_INT 0
54661: PUSH
54662: EMPTY
54663: LIST
54664: LIST
54665: PUSH
54666: LD_INT 30
54668: PUSH
54669: LD_INT 1
54671: PUSH
54672: EMPTY
54673: LIST
54674: LIST
54675: PUSH
54676: EMPTY
54677: LIST
54678: LIST
54679: LIST
54680: PPUSH
54681: CALL_OW 72
54685: NOT
54686: OR
54687: IFFALSE 54691
// exit ;
54689: GO 58194
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54691: LD_ADDR_VAR 0 4
54695: PUSH
54696: LD_EXP 23
54700: PUSH
54701: LD_VAR 0 1
54705: ARRAY
54706: PPUSH
54707: LD_INT 2
54709: PUSH
54710: LD_INT 25
54712: PUSH
54713: LD_INT 1
54715: PUSH
54716: EMPTY
54717: LIST
54718: LIST
54719: PUSH
54720: LD_INT 25
54722: PUSH
54723: LD_INT 2
54725: PUSH
54726: EMPTY
54727: LIST
54728: LIST
54729: PUSH
54730: LD_INT 25
54732: PUSH
54733: LD_INT 3
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: PUSH
54740: LD_INT 25
54742: PUSH
54743: LD_INT 4
54745: PUSH
54746: EMPTY
54747: LIST
54748: LIST
54749: PUSH
54750: LD_INT 25
54752: PUSH
54753: LD_INT 5
54755: PUSH
54756: EMPTY
54757: LIST
54758: LIST
54759: PUSH
54760: LD_INT 25
54762: PUSH
54763: LD_INT 8
54765: PUSH
54766: EMPTY
54767: LIST
54768: LIST
54769: PUSH
54770: LD_INT 25
54772: PUSH
54773: LD_INT 9
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: PUSH
54780: EMPTY
54781: LIST
54782: LIST
54783: LIST
54784: LIST
54785: LIST
54786: LIST
54787: LIST
54788: LIST
54789: PPUSH
54790: CALL_OW 72
54794: ST_TO_ADDR
// if not tmp then
54795: LD_VAR 0 4
54799: NOT
54800: IFFALSE 54804
// exit ;
54802: GO 58194
// for i in tmp do
54804: LD_ADDR_VAR 0 3
54808: PUSH
54809: LD_VAR 0 4
54813: PUSH
54814: FOR_IN
54815: IFFALSE 54846
// if GetTag ( i ) then
54817: LD_VAR 0 3
54821: PPUSH
54822: CALL_OW 110
54826: IFFALSE 54844
// tmp := tmp diff i ;
54828: LD_ADDR_VAR 0 4
54832: PUSH
54833: LD_VAR 0 4
54837: PUSH
54838: LD_VAR 0 3
54842: DIFF
54843: ST_TO_ADDR
54844: GO 54814
54846: POP
54847: POP
// if not tmp then
54848: LD_VAR 0 4
54852: NOT
54853: IFFALSE 54857
// exit ;
54855: GO 58194
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54857: LD_ADDR_VAR 0 5
54861: PUSH
54862: LD_EXP 23
54866: PUSH
54867: LD_VAR 0 1
54871: ARRAY
54872: PPUSH
54873: LD_INT 2
54875: PUSH
54876: LD_INT 25
54878: PUSH
54879: LD_INT 1
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: PUSH
54886: LD_INT 25
54888: PUSH
54889: LD_INT 5
54891: PUSH
54892: EMPTY
54893: LIST
54894: LIST
54895: PUSH
54896: LD_INT 25
54898: PUSH
54899: LD_INT 8
54901: PUSH
54902: EMPTY
54903: LIST
54904: LIST
54905: PUSH
54906: LD_INT 25
54908: PUSH
54909: LD_INT 9
54911: PUSH
54912: EMPTY
54913: LIST
54914: LIST
54915: PUSH
54916: EMPTY
54917: LIST
54918: LIST
54919: LIST
54920: LIST
54921: LIST
54922: PPUSH
54923: CALL_OW 72
54927: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
54928: LD_ADDR_VAR 0 6
54932: PUSH
54933: LD_EXP 23
54937: PUSH
54938: LD_VAR 0 1
54942: ARRAY
54943: PPUSH
54944: LD_INT 25
54946: PUSH
54947: LD_INT 2
54949: PUSH
54950: EMPTY
54951: LIST
54952: LIST
54953: PPUSH
54954: CALL_OW 72
54958: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
54959: LD_ADDR_VAR 0 7
54963: PUSH
54964: LD_EXP 23
54968: PUSH
54969: LD_VAR 0 1
54973: ARRAY
54974: PPUSH
54975: LD_INT 25
54977: PUSH
54978: LD_INT 3
54980: PUSH
54981: EMPTY
54982: LIST
54983: LIST
54984: PPUSH
54985: CALL_OW 72
54989: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
54990: LD_ADDR_VAR 0 8
54994: PUSH
54995: LD_EXP 23
54999: PUSH
55000: LD_VAR 0 1
55004: ARRAY
55005: PPUSH
55006: LD_INT 25
55008: PUSH
55009: LD_INT 4
55011: PUSH
55012: EMPTY
55013: LIST
55014: LIST
55015: PUSH
55016: LD_INT 24
55018: PUSH
55019: LD_INT 251
55021: PUSH
55022: EMPTY
55023: LIST
55024: LIST
55025: PUSH
55026: EMPTY
55027: LIST
55028: LIST
55029: PPUSH
55030: CALL_OW 72
55034: ST_TO_ADDR
// if mc_is_defending [ base ] then
55035: LD_EXP 66
55039: PUSH
55040: LD_VAR 0 1
55044: ARRAY
55045: IFFALSE 55506
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55047: LD_ADDR_EXP 65
55051: PUSH
55052: LD_EXP 65
55056: PPUSH
55057: LD_VAR 0 1
55061: PPUSH
55062: LD_INT 4
55064: PPUSH
55065: CALL_OW 1
55069: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55070: LD_ADDR_VAR 0 12
55074: PUSH
55075: LD_EXP 23
55079: PUSH
55080: LD_VAR 0 1
55084: ARRAY
55085: PPUSH
55086: LD_INT 2
55088: PUSH
55089: LD_INT 30
55091: PUSH
55092: LD_INT 4
55094: PUSH
55095: EMPTY
55096: LIST
55097: LIST
55098: PUSH
55099: LD_INT 30
55101: PUSH
55102: LD_INT 5
55104: PUSH
55105: EMPTY
55106: LIST
55107: LIST
55108: PUSH
55109: EMPTY
55110: LIST
55111: LIST
55112: LIST
55113: PPUSH
55114: CALL_OW 72
55118: ST_TO_ADDR
// if not b then
55119: LD_VAR 0 12
55123: NOT
55124: IFFALSE 55128
// exit ;
55126: GO 58194
// p := [ ] ;
55128: LD_ADDR_VAR 0 11
55132: PUSH
55133: EMPTY
55134: ST_TO_ADDR
// if sci >= 2 then
55135: LD_VAR 0 8
55139: PUSH
55140: LD_INT 2
55142: GREATEREQUAL
55143: IFFALSE 55174
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55145: LD_ADDR_VAR 0 8
55149: PUSH
55150: LD_VAR 0 8
55154: PUSH
55155: LD_INT 1
55157: ARRAY
55158: PUSH
55159: LD_VAR 0 8
55163: PUSH
55164: LD_INT 2
55166: ARRAY
55167: PUSH
55168: EMPTY
55169: LIST
55170: LIST
55171: ST_TO_ADDR
55172: GO 55235
// if sci = 1 then
55174: LD_VAR 0 8
55178: PUSH
55179: LD_INT 1
55181: EQUAL
55182: IFFALSE 55203
// sci := [ sci [ 1 ] ] else
55184: LD_ADDR_VAR 0 8
55188: PUSH
55189: LD_VAR 0 8
55193: PUSH
55194: LD_INT 1
55196: ARRAY
55197: PUSH
55198: EMPTY
55199: LIST
55200: ST_TO_ADDR
55201: GO 55235
// if sci = 0 then
55203: LD_VAR 0 8
55207: PUSH
55208: LD_INT 0
55210: EQUAL
55211: IFFALSE 55235
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55213: LD_ADDR_VAR 0 11
55217: PUSH
55218: LD_VAR 0 4
55222: PPUSH
55223: LD_INT 4
55225: PPUSH
55226: CALL 46247 0 2
55230: PUSH
55231: LD_INT 1
55233: ARRAY
55234: ST_TO_ADDR
// if eng > 4 then
55235: LD_VAR 0 6
55239: PUSH
55240: LD_INT 4
55242: GREATER
55243: IFFALSE 55289
// for i = eng downto 4 do
55245: LD_ADDR_VAR 0 3
55249: PUSH
55250: DOUBLE
55251: LD_VAR 0 6
55255: INC
55256: ST_TO_ADDR
55257: LD_INT 4
55259: PUSH
55260: FOR_DOWNTO
55261: IFFALSE 55287
// eng := eng diff eng [ i ] ;
55263: LD_ADDR_VAR 0 6
55267: PUSH
55268: LD_VAR 0 6
55272: PUSH
55273: LD_VAR 0 6
55277: PUSH
55278: LD_VAR 0 3
55282: ARRAY
55283: DIFF
55284: ST_TO_ADDR
55285: GO 55260
55287: POP
55288: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55289: LD_ADDR_VAR 0 4
55293: PUSH
55294: LD_VAR 0 4
55298: PUSH
55299: LD_VAR 0 5
55303: PUSH
55304: LD_VAR 0 6
55308: UNION
55309: PUSH
55310: LD_VAR 0 7
55314: UNION
55315: PUSH
55316: LD_VAR 0 8
55320: UNION
55321: DIFF
55322: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55323: LD_ADDR_VAR 0 13
55327: PUSH
55328: LD_EXP 23
55332: PUSH
55333: LD_VAR 0 1
55337: ARRAY
55338: PPUSH
55339: LD_INT 2
55341: PUSH
55342: LD_INT 30
55344: PUSH
55345: LD_INT 32
55347: PUSH
55348: EMPTY
55349: LIST
55350: LIST
55351: PUSH
55352: LD_INT 30
55354: PUSH
55355: LD_INT 31
55357: PUSH
55358: EMPTY
55359: LIST
55360: LIST
55361: PUSH
55362: EMPTY
55363: LIST
55364: LIST
55365: LIST
55366: PPUSH
55367: CALL_OW 72
55371: PUSH
55372: LD_EXP 23
55376: PUSH
55377: LD_VAR 0 1
55381: ARRAY
55382: PPUSH
55383: LD_INT 2
55385: PUSH
55386: LD_INT 30
55388: PUSH
55389: LD_INT 4
55391: PUSH
55392: EMPTY
55393: LIST
55394: LIST
55395: PUSH
55396: LD_INT 30
55398: PUSH
55399: LD_INT 5
55401: PUSH
55402: EMPTY
55403: LIST
55404: LIST
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: LIST
55410: PPUSH
55411: CALL_OW 72
55415: PUSH
55416: LD_INT 6
55418: MUL
55419: PLUS
55420: ST_TO_ADDR
// if bcount < tmp then
55421: LD_VAR 0 13
55425: PUSH
55426: LD_VAR 0 4
55430: LESS
55431: IFFALSE 55477
// for i = tmp downto bcount do
55433: LD_ADDR_VAR 0 3
55437: PUSH
55438: DOUBLE
55439: LD_VAR 0 4
55443: INC
55444: ST_TO_ADDR
55445: LD_VAR 0 13
55449: PUSH
55450: FOR_DOWNTO
55451: IFFALSE 55475
// tmp := Delete ( tmp , tmp ) ;
55453: LD_ADDR_VAR 0 4
55457: PUSH
55458: LD_VAR 0 4
55462: PPUSH
55463: LD_VAR 0 4
55467: PPUSH
55468: CALL_OW 3
55472: ST_TO_ADDR
55473: GO 55450
55475: POP
55476: POP
// result := [ tmp , 0 , 0 , p ] ;
55477: LD_ADDR_VAR 0 2
55481: PUSH
55482: LD_VAR 0 4
55486: PUSH
55487: LD_INT 0
55489: PUSH
55490: LD_INT 0
55492: PUSH
55493: LD_VAR 0 11
55497: PUSH
55498: EMPTY
55499: LIST
55500: LIST
55501: LIST
55502: LIST
55503: ST_TO_ADDR
// exit ;
55504: GO 58194
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55506: LD_EXP 23
55510: PUSH
55511: LD_VAR 0 1
55515: ARRAY
55516: PPUSH
55517: LD_INT 2
55519: PUSH
55520: LD_INT 30
55522: PUSH
55523: LD_INT 6
55525: PUSH
55526: EMPTY
55527: LIST
55528: LIST
55529: PUSH
55530: LD_INT 30
55532: PUSH
55533: LD_INT 7
55535: PUSH
55536: EMPTY
55537: LIST
55538: LIST
55539: PUSH
55540: LD_INT 30
55542: PUSH
55543: LD_INT 8
55545: PUSH
55546: EMPTY
55547: LIST
55548: LIST
55549: PUSH
55550: EMPTY
55551: LIST
55552: LIST
55553: LIST
55554: LIST
55555: PPUSH
55556: CALL_OW 72
55560: NOT
55561: PUSH
55562: LD_EXP 23
55566: PUSH
55567: LD_VAR 0 1
55571: ARRAY
55572: PPUSH
55573: LD_INT 30
55575: PUSH
55576: LD_INT 3
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: PPUSH
55583: CALL_OW 72
55587: NOT
55588: AND
55589: IFFALSE 55661
// begin if eng = tmp then
55591: LD_VAR 0 6
55595: PUSH
55596: LD_VAR 0 4
55600: EQUAL
55601: IFFALSE 55605
// exit ;
55603: GO 58194
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
55605: LD_ADDR_EXP 65
55609: PUSH
55610: LD_EXP 65
55614: PPUSH
55615: LD_VAR 0 1
55619: PPUSH
55620: LD_INT 1
55622: PPUSH
55623: CALL_OW 1
55627: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
55628: LD_ADDR_VAR 0 2
55632: PUSH
55633: LD_INT 0
55635: PUSH
55636: LD_VAR 0 4
55640: PUSH
55641: LD_VAR 0 6
55645: DIFF
55646: PUSH
55647: LD_INT 0
55649: PUSH
55650: LD_INT 0
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: LIST
55657: LIST
55658: ST_TO_ADDR
// exit ;
55659: GO 58194
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55661: LD_EXP 50
55665: PUSH
55666: LD_EXP 49
55670: PUSH
55671: LD_VAR 0 1
55675: ARRAY
55676: ARRAY
55677: PUSH
55678: LD_EXP 23
55682: PUSH
55683: LD_VAR 0 1
55687: ARRAY
55688: PPUSH
55689: LD_INT 2
55691: PUSH
55692: LD_INT 30
55694: PUSH
55695: LD_INT 6
55697: PUSH
55698: EMPTY
55699: LIST
55700: LIST
55701: PUSH
55702: LD_INT 30
55704: PUSH
55705: LD_INT 7
55707: PUSH
55708: EMPTY
55709: LIST
55710: LIST
55711: PUSH
55712: LD_INT 30
55714: PUSH
55715: LD_INT 8
55717: PUSH
55718: EMPTY
55719: LIST
55720: LIST
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: LIST
55726: LIST
55727: PPUSH
55728: CALL_OW 72
55732: AND
55733: PUSH
55734: LD_EXP 23
55738: PUSH
55739: LD_VAR 0 1
55743: ARRAY
55744: PPUSH
55745: LD_INT 30
55747: PUSH
55748: LD_INT 3
55750: PUSH
55751: EMPTY
55752: LIST
55753: LIST
55754: PPUSH
55755: CALL_OW 72
55759: NOT
55760: AND
55761: IFFALSE 55975
// begin if sci >= 6 then
55763: LD_VAR 0 8
55767: PUSH
55768: LD_INT 6
55770: GREATEREQUAL
55771: IFFALSE 55775
// exit ;
55773: GO 58194
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
55775: LD_ADDR_EXP 65
55779: PUSH
55780: LD_EXP 65
55784: PPUSH
55785: LD_VAR 0 1
55789: PPUSH
55790: LD_INT 2
55792: PPUSH
55793: CALL_OW 1
55797: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
55798: LD_ADDR_VAR 0 9
55802: PUSH
55803: LD_VAR 0 4
55807: PUSH
55808: LD_VAR 0 8
55812: DIFF
55813: PPUSH
55814: LD_INT 4
55816: PPUSH
55817: CALL 46247 0 2
55821: ST_TO_ADDR
// p := [ ] ;
55822: LD_ADDR_VAR 0 11
55826: PUSH
55827: EMPTY
55828: ST_TO_ADDR
// if sci < 6 and sort > 6 then
55829: LD_VAR 0 8
55833: PUSH
55834: LD_INT 6
55836: LESS
55837: PUSH
55838: LD_VAR 0 9
55842: PUSH
55843: LD_INT 6
55845: GREATER
55846: AND
55847: IFFALSE 55928
// begin for i = 1 to 6 - sci do
55849: LD_ADDR_VAR 0 3
55853: PUSH
55854: DOUBLE
55855: LD_INT 1
55857: DEC
55858: ST_TO_ADDR
55859: LD_INT 6
55861: PUSH
55862: LD_VAR 0 8
55866: MINUS
55867: PUSH
55868: FOR_TO
55869: IFFALSE 55924
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
55871: LD_ADDR_VAR 0 11
55875: PUSH
55876: LD_VAR 0 11
55880: PPUSH
55881: LD_VAR 0 11
55885: PUSH
55886: LD_INT 1
55888: PLUS
55889: PPUSH
55890: LD_VAR 0 9
55894: PUSH
55895: LD_INT 1
55897: ARRAY
55898: PPUSH
55899: CALL_OW 2
55903: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
55904: LD_ADDR_VAR 0 9
55908: PUSH
55909: LD_VAR 0 9
55913: PPUSH
55914: LD_INT 1
55916: PPUSH
55917: CALL_OW 3
55921: ST_TO_ADDR
// end ;
55922: GO 55868
55924: POP
55925: POP
// end else
55926: GO 55948
// if sort then
55928: LD_VAR 0 9
55932: IFFALSE 55948
// p := sort [ 1 ] ;
55934: LD_ADDR_VAR 0 11
55938: PUSH
55939: LD_VAR 0 9
55943: PUSH
55944: LD_INT 1
55946: ARRAY
55947: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
55948: LD_ADDR_VAR 0 2
55952: PUSH
55953: LD_INT 0
55955: PUSH
55956: LD_INT 0
55958: PUSH
55959: LD_INT 0
55961: PUSH
55962: LD_VAR 0 11
55966: PUSH
55967: EMPTY
55968: LIST
55969: LIST
55970: LIST
55971: LIST
55972: ST_TO_ADDR
// exit ;
55973: GO 58194
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55975: LD_EXP 50
55979: PUSH
55980: LD_EXP 49
55984: PUSH
55985: LD_VAR 0 1
55989: ARRAY
55990: ARRAY
55991: PUSH
55992: LD_EXP 23
55996: PUSH
55997: LD_VAR 0 1
56001: ARRAY
56002: PPUSH
56003: LD_INT 2
56005: PUSH
56006: LD_INT 30
56008: PUSH
56009: LD_INT 6
56011: PUSH
56012: EMPTY
56013: LIST
56014: LIST
56015: PUSH
56016: LD_INT 30
56018: PUSH
56019: LD_INT 7
56021: PUSH
56022: EMPTY
56023: LIST
56024: LIST
56025: PUSH
56026: LD_INT 30
56028: PUSH
56029: LD_INT 8
56031: PUSH
56032: EMPTY
56033: LIST
56034: LIST
56035: PUSH
56036: EMPTY
56037: LIST
56038: LIST
56039: LIST
56040: LIST
56041: PPUSH
56042: CALL_OW 72
56046: AND
56047: PUSH
56048: LD_EXP 23
56052: PUSH
56053: LD_VAR 0 1
56057: ARRAY
56058: PPUSH
56059: LD_INT 30
56061: PUSH
56062: LD_INT 3
56064: PUSH
56065: EMPTY
56066: LIST
56067: LIST
56068: PPUSH
56069: CALL_OW 72
56073: AND
56074: IFFALSE 56808
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56076: LD_ADDR_EXP 65
56080: PUSH
56081: LD_EXP 65
56085: PPUSH
56086: LD_VAR 0 1
56090: PPUSH
56091: LD_INT 3
56093: PPUSH
56094: CALL_OW 1
56098: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56099: LD_ADDR_VAR 0 2
56103: PUSH
56104: LD_INT 0
56106: PUSH
56107: LD_INT 0
56109: PUSH
56110: LD_INT 0
56112: PUSH
56113: LD_INT 0
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: LIST
56120: LIST
56121: ST_TO_ADDR
// if not eng then
56122: LD_VAR 0 6
56126: NOT
56127: IFFALSE 56190
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56129: LD_ADDR_VAR 0 11
56133: PUSH
56134: LD_VAR 0 4
56138: PPUSH
56139: LD_INT 2
56141: PPUSH
56142: CALL 46247 0 2
56146: PUSH
56147: LD_INT 1
56149: ARRAY
56150: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56151: LD_ADDR_VAR 0 2
56155: PUSH
56156: LD_VAR 0 2
56160: PPUSH
56161: LD_INT 2
56163: PPUSH
56164: LD_VAR 0 11
56168: PPUSH
56169: CALL_OW 1
56173: ST_TO_ADDR
// tmp := tmp diff p ;
56174: LD_ADDR_VAR 0 4
56178: PUSH
56179: LD_VAR 0 4
56183: PUSH
56184: LD_VAR 0 11
56188: DIFF
56189: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56190: LD_VAR 0 4
56194: PUSH
56195: LD_VAR 0 8
56199: PUSH
56200: LD_INT 6
56202: LESS
56203: AND
56204: IFFALSE 56392
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56206: LD_ADDR_VAR 0 9
56210: PUSH
56211: LD_VAR 0 4
56215: PUSH
56216: LD_VAR 0 8
56220: PUSH
56221: LD_VAR 0 7
56225: UNION
56226: DIFF
56227: PPUSH
56228: LD_INT 4
56230: PPUSH
56231: CALL 46247 0 2
56235: ST_TO_ADDR
// p := [ ] ;
56236: LD_ADDR_VAR 0 11
56240: PUSH
56241: EMPTY
56242: ST_TO_ADDR
// if sort then
56243: LD_VAR 0 9
56247: IFFALSE 56363
// for i = 1 to 6 - sci do
56249: LD_ADDR_VAR 0 3
56253: PUSH
56254: DOUBLE
56255: LD_INT 1
56257: DEC
56258: ST_TO_ADDR
56259: LD_INT 6
56261: PUSH
56262: LD_VAR 0 8
56266: MINUS
56267: PUSH
56268: FOR_TO
56269: IFFALSE 56361
// begin if i = sort then
56271: LD_VAR 0 3
56275: PUSH
56276: LD_VAR 0 9
56280: EQUAL
56281: IFFALSE 56285
// break ;
56283: GO 56361
// if GetClass ( i ) = 4 then
56285: LD_VAR 0 3
56289: PPUSH
56290: CALL_OW 257
56294: PUSH
56295: LD_INT 4
56297: EQUAL
56298: IFFALSE 56302
// continue ;
56300: GO 56268
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56302: LD_ADDR_VAR 0 11
56306: PUSH
56307: LD_VAR 0 11
56311: PPUSH
56312: LD_VAR 0 11
56316: PUSH
56317: LD_INT 1
56319: PLUS
56320: PPUSH
56321: LD_VAR 0 9
56325: PUSH
56326: LD_VAR 0 3
56330: ARRAY
56331: PPUSH
56332: CALL_OW 2
56336: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56337: LD_ADDR_VAR 0 4
56341: PUSH
56342: LD_VAR 0 4
56346: PUSH
56347: LD_VAR 0 9
56351: PUSH
56352: LD_VAR 0 3
56356: ARRAY
56357: DIFF
56358: ST_TO_ADDR
// end ;
56359: GO 56268
56361: POP
56362: POP
// if p then
56363: LD_VAR 0 11
56367: IFFALSE 56392
// result := Replace ( result , 4 , p ) ;
56369: LD_ADDR_VAR 0 2
56373: PUSH
56374: LD_VAR 0 2
56378: PPUSH
56379: LD_INT 4
56381: PPUSH
56382: LD_VAR 0 11
56386: PPUSH
56387: CALL_OW 1
56391: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56392: LD_VAR 0 4
56396: PUSH
56397: LD_VAR 0 7
56401: PUSH
56402: LD_INT 6
56404: LESS
56405: AND
56406: IFFALSE 56594
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56408: LD_ADDR_VAR 0 9
56412: PUSH
56413: LD_VAR 0 4
56417: PUSH
56418: LD_VAR 0 8
56422: PUSH
56423: LD_VAR 0 7
56427: UNION
56428: DIFF
56429: PPUSH
56430: LD_INT 3
56432: PPUSH
56433: CALL 46247 0 2
56437: ST_TO_ADDR
// p := [ ] ;
56438: LD_ADDR_VAR 0 11
56442: PUSH
56443: EMPTY
56444: ST_TO_ADDR
// if sort then
56445: LD_VAR 0 9
56449: IFFALSE 56565
// for i = 1 to 6 - mech do
56451: LD_ADDR_VAR 0 3
56455: PUSH
56456: DOUBLE
56457: LD_INT 1
56459: DEC
56460: ST_TO_ADDR
56461: LD_INT 6
56463: PUSH
56464: LD_VAR 0 7
56468: MINUS
56469: PUSH
56470: FOR_TO
56471: IFFALSE 56563
// begin if i = sort then
56473: LD_VAR 0 3
56477: PUSH
56478: LD_VAR 0 9
56482: EQUAL
56483: IFFALSE 56487
// break ;
56485: GO 56563
// if GetClass ( i ) = 3 then
56487: LD_VAR 0 3
56491: PPUSH
56492: CALL_OW 257
56496: PUSH
56497: LD_INT 3
56499: EQUAL
56500: IFFALSE 56504
// continue ;
56502: GO 56470
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56504: LD_ADDR_VAR 0 11
56508: PUSH
56509: LD_VAR 0 11
56513: PPUSH
56514: LD_VAR 0 11
56518: PUSH
56519: LD_INT 1
56521: PLUS
56522: PPUSH
56523: LD_VAR 0 9
56527: PUSH
56528: LD_VAR 0 3
56532: ARRAY
56533: PPUSH
56534: CALL_OW 2
56538: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56539: LD_ADDR_VAR 0 4
56543: PUSH
56544: LD_VAR 0 4
56548: PUSH
56549: LD_VAR 0 9
56553: PUSH
56554: LD_VAR 0 3
56558: ARRAY
56559: DIFF
56560: ST_TO_ADDR
// end ;
56561: GO 56470
56563: POP
56564: POP
// if p then
56565: LD_VAR 0 11
56569: IFFALSE 56594
// result := Replace ( result , 3 , p ) ;
56571: LD_ADDR_VAR 0 2
56575: PUSH
56576: LD_VAR 0 2
56580: PPUSH
56581: LD_INT 3
56583: PPUSH
56584: LD_VAR 0 11
56588: PPUSH
56589: CALL_OW 1
56593: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
56594: LD_VAR 0 4
56598: PUSH
56599: LD_INT 6
56601: GREATER
56602: PUSH
56603: LD_VAR 0 6
56607: PUSH
56608: LD_INT 6
56610: LESS
56611: AND
56612: IFFALSE 56806
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56614: LD_ADDR_VAR 0 9
56618: PUSH
56619: LD_VAR 0 4
56623: PUSH
56624: LD_VAR 0 8
56628: PUSH
56629: LD_VAR 0 7
56633: UNION
56634: PUSH
56635: LD_VAR 0 6
56639: UNION
56640: DIFF
56641: PPUSH
56642: LD_INT 2
56644: PPUSH
56645: CALL 46247 0 2
56649: ST_TO_ADDR
// p := [ ] ;
56650: LD_ADDR_VAR 0 11
56654: PUSH
56655: EMPTY
56656: ST_TO_ADDR
// if sort then
56657: LD_VAR 0 9
56661: IFFALSE 56777
// for i = 1 to 6 - eng do
56663: LD_ADDR_VAR 0 3
56667: PUSH
56668: DOUBLE
56669: LD_INT 1
56671: DEC
56672: ST_TO_ADDR
56673: LD_INT 6
56675: PUSH
56676: LD_VAR 0 6
56680: MINUS
56681: PUSH
56682: FOR_TO
56683: IFFALSE 56775
// begin if i = sort then
56685: LD_VAR 0 3
56689: PUSH
56690: LD_VAR 0 9
56694: EQUAL
56695: IFFALSE 56699
// break ;
56697: GO 56775
// if GetClass ( i ) = 2 then
56699: LD_VAR 0 3
56703: PPUSH
56704: CALL_OW 257
56708: PUSH
56709: LD_INT 2
56711: EQUAL
56712: IFFALSE 56716
// continue ;
56714: GO 56682
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56716: LD_ADDR_VAR 0 11
56720: PUSH
56721: LD_VAR 0 11
56725: PPUSH
56726: LD_VAR 0 11
56730: PUSH
56731: LD_INT 1
56733: PLUS
56734: PPUSH
56735: LD_VAR 0 9
56739: PUSH
56740: LD_VAR 0 3
56744: ARRAY
56745: PPUSH
56746: CALL_OW 2
56750: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56751: LD_ADDR_VAR 0 4
56755: PUSH
56756: LD_VAR 0 4
56760: PUSH
56761: LD_VAR 0 9
56765: PUSH
56766: LD_VAR 0 3
56770: ARRAY
56771: DIFF
56772: ST_TO_ADDR
// end ;
56773: GO 56682
56775: POP
56776: POP
// if p then
56777: LD_VAR 0 11
56781: IFFALSE 56806
// result := Replace ( result , 2 , p ) ;
56783: LD_ADDR_VAR 0 2
56787: PUSH
56788: LD_VAR 0 2
56792: PPUSH
56793: LD_INT 2
56795: PPUSH
56796: LD_VAR 0 11
56800: PPUSH
56801: CALL_OW 1
56805: ST_TO_ADDR
// end ; exit ;
56806: GO 58194
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
56808: LD_EXP 50
56812: PUSH
56813: LD_EXP 49
56817: PUSH
56818: LD_VAR 0 1
56822: ARRAY
56823: ARRAY
56824: NOT
56825: PUSH
56826: LD_EXP 23
56830: PUSH
56831: LD_VAR 0 1
56835: ARRAY
56836: PPUSH
56837: LD_INT 30
56839: PUSH
56840: LD_INT 3
56842: PUSH
56843: EMPTY
56844: LIST
56845: LIST
56846: PPUSH
56847: CALL_OW 72
56851: AND
56852: PUSH
56853: LD_EXP 28
56857: PUSH
56858: LD_VAR 0 1
56862: ARRAY
56863: AND
56864: IFFALSE 57472
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
56866: LD_ADDR_EXP 65
56870: PUSH
56871: LD_EXP 65
56875: PPUSH
56876: LD_VAR 0 1
56880: PPUSH
56881: LD_INT 5
56883: PPUSH
56884: CALL_OW 1
56888: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56889: LD_ADDR_VAR 0 2
56893: PUSH
56894: LD_INT 0
56896: PUSH
56897: LD_INT 0
56899: PUSH
56900: LD_INT 0
56902: PUSH
56903: LD_INT 0
56905: PUSH
56906: EMPTY
56907: LIST
56908: LIST
56909: LIST
56910: LIST
56911: ST_TO_ADDR
// if sci > 1 then
56912: LD_VAR 0 8
56916: PUSH
56917: LD_INT 1
56919: GREATER
56920: IFFALSE 56948
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
56922: LD_ADDR_VAR 0 4
56926: PUSH
56927: LD_VAR 0 4
56931: PUSH
56932: LD_VAR 0 8
56936: PUSH
56937: LD_VAR 0 8
56941: PUSH
56942: LD_INT 1
56944: ARRAY
56945: DIFF
56946: DIFF
56947: ST_TO_ADDR
// if tmp and not sci then
56948: LD_VAR 0 4
56952: PUSH
56953: LD_VAR 0 8
56957: NOT
56958: AND
56959: IFFALSE 57028
// begin sort := SortBySkill ( tmp , 4 ) ;
56961: LD_ADDR_VAR 0 9
56965: PUSH
56966: LD_VAR 0 4
56970: PPUSH
56971: LD_INT 4
56973: PPUSH
56974: CALL 46247 0 2
56978: ST_TO_ADDR
// if sort then
56979: LD_VAR 0 9
56983: IFFALSE 56999
// p := sort [ 1 ] ;
56985: LD_ADDR_VAR 0 11
56989: PUSH
56990: LD_VAR 0 9
56994: PUSH
56995: LD_INT 1
56997: ARRAY
56998: ST_TO_ADDR
// if p then
56999: LD_VAR 0 11
57003: IFFALSE 57028
// result := Replace ( result , 4 , p ) ;
57005: LD_ADDR_VAR 0 2
57009: PUSH
57010: LD_VAR 0 2
57014: PPUSH
57015: LD_INT 4
57017: PPUSH
57018: LD_VAR 0 11
57022: PPUSH
57023: CALL_OW 1
57027: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57028: LD_ADDR_VAR 0 4
57032: PUSH
57033: LD_VAR 0 4
57037: PUSH
57038: LD_VAR 0 7
57042: DIFF
57043: ST_TO_ADDR
// if tmp and mech < 6 then
57044: LD_VAR 0 4
57048: PUSH
57049: LD_VAR 0 7
57053: PUSH
57054: LD_INT 6
57056: LESS
57057: AND
57058: IFFALSE 57246
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57060: LD_ADDR_VAR 0 9
57064: PUSH
57065: LD_VAR 0 4
57069: PUSH
57070: LD_VAR 0 8
57074: PUSH
57075: LD_VAR 0 7
57079: UNION
57080: DIFF
57081: PPUSH
57082: LD_INT 3
57084: PPUSH
57085: CALL 46247 0 2
57089: ST_TO_ADDR
// p := [ ] ;
57090: LD_ADDR_VAR 0 11
57094: PUSH
57095: EMPTY
57096: ST_TO_ADDR
// if sort then
57097: LD_VAR 0 9
57101: IFFALSE 57217
// for i = 1 to 6 - mech do
57103: LD_ADDR_VAR 0 3
57107: PUSH
57108: DOUBLE
57109: LD_INT 1
57111: DEC
57112: ST_TO_ADDR
57113: LD_INT 6
57115: PUSH
57116: LD_VAR 0 7
57120: MINUS
57121: PUSH
57122: FOR_TO
57123: IFFALSE 57215
// begin if i = sort then
57125: LD_VAR 0 3
57129: PUSH
57130: LD_VAR 0 9
57134: EQUAL
57135: IFFALSE 57139
// break ;
57137: GO 57215
// if GetClass ( i ) = 3 then
57139: LD_VAR 0 3
57143: PPUSH
57144: CALL_OW 257
57148: PUSH
57149: LD_INT 3
57151: EQUAL
57152: IFFALSE 57156
// continue ;
57154: GO 57122
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57156: LD_ADDR_VAR 0 11
57160: PUSH
57161: LD_VAR 0 11
57165: PPUSH
57166: LD_VAR 0 11
57170: PUSH
57171: LD_INT 1
57173: PLUS
57174: PPUSH
57175: LD_VAR 0 9
57179: PUSH
57180: LD_VAR 0 3
57184: ARRAY
57185: PPUSH
57186: CALL_OW 2
57190: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57191: LD_ADDR_VAR 0 4
57195: PUSH
57196: LD_VAR 0 4
57200: PUSH
57201: LD_VAR 0 9
57205: PUSH
57206: LD_VAR 0 3
57210: ARRAY
57211: DIFF
57212: ST_TO_ADDR
// end ;
57213: GO 57122
57215: POP
57216: POP
// if p then
57217: LD_VAR 0 11
57221: IFFALSE 57246
// result := Replace ( result , 3 , p ) ;
57223: LD_ADDR_VAR 0 2
57227: PUSH
57228: LD_VAR 0 2
57232: PPUSH
57233: LD_INT 3
57235: PPUSH
57236: LD_VAR 0 11
57240: PPUSH
57241: CALL_OW 1
57245: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57246: LD_ADDR_VAR 0 4
57250: PUSH
57251: LD_VAR 0 4
57255: PUSH
57256: LD_VAR 0 6
57260: DIFF
57261: ST_TO_ADDR
// if tmp and eng < 6 then
57262: LD_VAR 0 4
57266: PUSH
57267: LD_VAR 0 6
57271: PUSH
57272: LD_INT 6
57274: LESS
57275: AND
57276: IFFALSE 57470
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57278: LD_ADDR_VAR 0 9
57282: PUSH
57283: LD_VAR 0 4
57287: PUSH
57288: LD_VAR 0 8
57292: PUSH
57293: LD_VAR 0 7
57297: UNION
57298: PUSH
57299: LD_VAR 0 6
57303: UNION
57304: DIFF
57305: PPUSH
57306: LD_INT 2
57308: PPUSH
57309: CALL 46247 0 2
57313: ST_TO_ADDR
// p := [ ] ;
57314: LD_ADDR_VAR 0 11
57318: PUSH
57319: EMPTY
57320: ST_TO_ADDR
// if sort then
57321: LD_VAR 0 9
57325: IFFALSE 57441
// for i = 1 to 6 - eng do
57327: LD_ADDR_VAR 0 3
57331: PUSH
57332: DOUBLE
57333: LD_INT 1
57335: DEC
57336: ST_TO_ADDR
57337: LD_INT 6
57339: PUSH
57340: LD_VAR 0 6
57344: MINUS
57345: PUSH
57346: FOR_TO
57347: IFFALSE 57439
// begin if i = sort then
57349: LD_VAR 0 3
57353: PUSH
57354: LD_VAR 0 9
57358: EQUAL
57359: IFFALSE 57363
// break ;
57361: GO 57439
// if GetClass ( i ) = 2 then
57363: LD_VAR 0 3
57367: PPUSH
57368: CALL_OW 257
57372: PUSH
57373: LD_INT 2
57375: EQUAL
57376: IFFALSE 57380
// continue ;
57378: GO 57346
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57380: LD_ADDR_VAR 0 11
57384: PUSH
57385: LD_VAR 0 11
57389: PPUSH
57390: LD_VAR 0 11
57394: PUSH
57395: LD_INT 1
57397: PLUS
57398: PPUSH
57399: LD_VAR 0 9
57403: PUSH
57404: LD_VAR 0 3
57408: ARRAY
57409: PPUSH
57410: CALL_OW 2
57414: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57415: LD_ADDR_VAR 0 4
57419: PUSH
57420: LD_VAR 0 4
57424: PUSH
57425: LD_VAR 0 9
57429: PUSH
57430: LD_VAR 0 3
57434: ARRAY
57435: DIFF
57436: ST_TO_ADDR
// end ;
57437: GO 57346
57439: POP
57440: POP
// if p then
57441: LD_VAR 0 11
57445: IFFALSE 57470
// result := Replace ( result , 2 , p ) ;
57447: LD_ADDR_VAR 0 2
57451: PUSH
57452: LD_VAR 0 2
57456: PPUSH
57457: LD_INT 2
57459: PPUSH
57460: LD_VAR 0 11
57464: PPUSH
57465: CALL_OW 1
57469: ST_TO_ADDR
// end ; exit ;
57470: GO 58194
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
57472: LD_EXP 50
57476: PUSH
57477: LD_EXP 49
57481: PUSH
57482: LD_VAR 0 1
57486: ARRAY
57487: ARRAY
57488: NOT
57489: PUSH
57490: LD_EXP 23
57494: PUSH
57495: LD_VAR 0 1
57499: ARRAY
57500: PPUSH
57501: LD_INT 30
57503: PUSH
57504: LD_INT 3
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: PPUSH
57511: CALL_OW 72
57515: AND
57516: PUSH
57517: LD_EXP 28
57521: PUSH
57522: LD_VAR 0 1
57526: ARRAY
57527: NOT
57528: AND
57529: IFFALSE 58194
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
57531: LD_ADDR_EXP 65
57535: PUSH
57536: LD_EXP 65
57540: PPUSH
57541: LD_VAR 0 1
57545: PPUSH
57546: LD_INT 6
57548: PPUSH
57549: CALL_OW 1
57553: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57554: LD_ADDR_VAR 0 2
57558: PUSH
57559: LD_INT 0
57561: PUSH
57562: LD_INT 0
57564: PUSH
57565: LD_INT 0
57567: PUSH
57568: LD_INT 0
57570: PUSH
57571: EMPTY
57572: LIST
57573: LIST
57574: LIST
57575: LIST
57576: ST_TO_ADDR
// if sci >= 1 then
57577: LD_VAR 0 8
57581: PUSH
57582: LD_INT 1
57584: GREATEREQUAL
57585: IFFALSE 57607
// tmp := tmp diff sci [ 1 ] ;
57587: LD_ADDR_VAR 0 4
57591: PUSH
57592: LD_VAR 0 4
57596: PUSH
57597: LD_VAR 0 8
57601: PUSH
57602: LD_INT 1
57604: ARRAY
57605: DIFF
57606: ST_TO_ADDR
// if tmp and not sci then
57607: LD_VAR 0 4
57611: PUSH
57612: LD_VAR 0 8
57616: NOT
57617: AND
57618: IFFALSE 57687
// begin sort := SortBySkill ( tmp , 4 ) ;
57620: LD_ADDR_VAR 0 9
57624: PUSH
57625: LD_VAR 0 4
57629: PPUSH
57630: LD_INT 4
57632: PPUSH
57633: CALL 46247 0 2
57637: ST_TO_ADDR
// if sort then
57638: LD_VAR 0 9
57642: IFFALSE 57658
// p := sort [ 1 ] ;
57644: LD_ADDR_VAR 0 11
57648: PUSH
57649: LD_VAR 0 9
57653: PUSH
57654: LD_INT 1
57656: ARRAY
57657: ST_TO_ADDR
// if p then
57658: LD_VAR 0 11
57662: IFFALSE 57687
// result := Replace ( result , 4 , p ) ;
57664: LD_ADDR_VAR 0 2
57668: PUSH
57669: LD_VAR 0 2
57673: PPUSH
57674: LD_INT 4
57676: PPUSH
57677: LD_VAR 0 11
57681: PPUSH
57682: CALL_OW 1
57686: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57687: LD_ADDR_VAR 0 4
57691: PUSH
57692: LD_VAR 0 4
57696: PUSH
57697: LD_VAR 0 7
57701: DIFF
57702: ST_TO_ADDR
// if tmp and mech < 6 then
57703: LD_VAR 0 4
57707: PUSH
57708: LD_VAR 0 7
57712: PUSH
57713: LD_INT 6
57715: LESS
57716: AND
57717: IFFALSE 57899
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
57719: LD_ADDR_VAR 0 9
57723: PUSH
57724: LD_VAR 0 4
57728: PUSH
57729: LD_VAR 0 7
57733: DIFF
57734: PPUSH
57735: LD_INT 3
57737: PPUSH
57738: CALL 46247 0 2
57742: ST_TO_ADDR
// p := [ ] ;
57743: LD_ADDR_VAR 0 11
57747: PUSH
57748: EMPTY
57749: ST_TO_ADDR
// if sort then
57750: LD_VAR 0 9
57754: IFFALSE 57870
// for i = 1 to 6 - mech do
57756: LD_ADDR_VAR 0 3
57760: PUSH
57761: DOUBLE
57762: LD_INT 1
57764: DEC
57765: ST_TO_ADDR
57766: LD_INT 6
57768: PUSH
57769: LD_VAR 0 7
57773: MINUS
57774: PUSH
57775: FOR_TO
57776: IFFALSE 57868
// begin if i = sort then
57778: LD_VAR 0 3
57782: PUSH
57783: LD_VAR 0 9
57787: EQUAL
57788: IFFALSE 57792
// break ;
57790: GO 57868
// if GetClass ( i ) = 3 then
57792: LD_VAR 0 3
57796: PPUSH
57797: CALL_OW 257
57801: PUSH
57802: LD_INT 3
57804: EQUAL
57805: IFFALSE 57809
// continue ;
57807: GO 57775
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57809: LD_ADDR_VAR 0 11
57813: PUSH
57814: LD_VAR 0 11
57818: PPUSH
57819: LD_VAR 0 11
57823: PUSH
57824: LD_INT 1
57826: PLUS
57827: PPUSH
57828: LD_VAR 0 9
57832: PUSH
57833: LD_VAR 0 3
57837: ARRAY
57838: PPUSH
57839: CALL_OW 2
57843: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57844: LD_ADDR_VAR 0 4
57848: PUSH
57849: LD_VAR 0 4
57853: PUSH
57854: LD_VAR 0 9
57858: PUSH
57859: LD_VAR 0 3
57863: ARRAY
57864: DIFF
57865: ST_TO_ADDR
// end ;
57866: GO 57775
57868: POP
57869: POP
// if p then
57870: LD_VAR 0 11
57874: IFFALSE 57899
// result := Replace ( result , 3 , p ) ;
57876: LD_ADDR_VAR 0 2
57880: PUSH
57881: LD_VAR 0 2
57885: PPUSH
57886: LD_INT 3
57888: PPUSH
57889: LD_VAR 0 11
57893: PPUSH
57894: CALL_OW 1
57898: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57899: LD_ADDR_VAR 0 4
57903: PUSH
57904: LD_VAR 0 4
57908: PUSH
57909: LD_VAR 0 6
57913: DIFF
57914: ST_TO_ADDR
// if tmp and eng < 4 then
57915: LD_VAR 0 4
57919: PUSH
57920: LD_VAR 0 6
57924: PUSH
57925: LD_INT 4
57927: LESS
57928: AND
57929: IFFALSE 58119
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
57931: LD_ADDR_VAR 0 9
57935: PUSH
57936: LD_VAR 0 4
57940: PUSH
57941: LD_VAR 0 7
57945: PUSH
57946: LD_VAR 0 6
57950: UNION
57951: DIFF
57952: PPUSH
57953: LD_INT 2
57955: PPUSH
57956: CALL 46247 0 2
57960: ST_TO_ADDR
// p := [ ] ;
57961: LD_ADDR_VAR 0 11
57965: PUSH
57966: EMPTY
57967: ST_TO_ADDR
// if sort then
57968: LD_VAR 0 9
57972: IFFALSE 58088
// for i = 1 to 4 - eng do
57974: LD_ADDR_VAR 0 3
57978: PUSH
57979: DOUBLE
57980: LD_INT 1
57982: DEC
57983: ST_TO_ADDR
57984: LD_INT 4
57986: PUSH
57987: LD_VAR 0 6
57991: MINUS
57992: PUSH
57993: FOR_TO
57994: IFFALSE 58086
// begin if i = sort then
57996: LD_VAR 0 3
58000: PUSH
58001: LD_VAR 0 9
58005: EQUAL
58006: IFFALSE 58010
// break ;
58008: GO 58086
// if GetClass ( i ) = 2 then
58010: LD_VAR 0 3
58014: PPUSH
58015: CALL_OW 257
58019: PUSH
58020: LD_INT 2
58022: EQUAL
58023: IFFALSE 58027
// continue ;
58025: GO 57993
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58027: LD_ADDR_VAR 0 11
58031: PUSH
58032: LD_VAR 0 11
58036: PPUSH
58037: LD_VAR 0 11
58041: PUSH
58042: LD_INT 1
58044: PLUS
58045: PPUSH
58046: LD_VAR 0 9
58050: PUSH
58051: LD_VAR 0 3
58055: ARRAY
58056: PPUSH
58057: CALL_OW 2
58061: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58062: LD_ADDR_VAR 0 4
58066: PUSH
58067: LD_VAR 0 4
58071: PUSH
58072: LD_VAR 0 9
58076: PUSH
58077: LD_VAR 0 3
58081: ARRAY
58082: DIFF
58083: ST_TO_ADDR
// end ;
58084: GO 57993
58086: POP
58087: POP
// if p then
58088: LD_VAR 0 11
58092: IFFALSE 58117
// result := Replace ( result , 2 , p ) ;
58094: LD_ADDR_VAR 0 2
58098: PUSH
58099: LD_VAR 0 2
58103: PPUSH
58104: LD_INT 2
58106: PPUSH
58107: LD_VAR 0 11
58111: PPUSH
58112: CALL_OW 1
58116: ST_TO_ADDR
// end else
58117: GO 58163
// for i = eng downto 5 do
58119: LD_ADDR_VAR 0 3
58123: PUSH
58124: DOUBLE
58125: LD_VAR 0 6
58129: INC
58130: ST_TO_ADDR
58131: LD_INT 5
58133: PUSH
58134: FOR_DOWNTO
58135: IFFALSE 58161
// tmp := tmp union eng [ i ] ;
58137: LD_ADDR_VAR 0 4
58141: PUSH
58142: LD_VAR 0 4
58146: PUSH
58147: LD_VAR 0 6
58151: PUSH
58152: LD_VAR 0 3
58156: ARRAY
58157: UNION
58158: ST_TO_ADDR
58159: GO 58134
58161: POP
58162: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58163: LD_ADDR_VAR 0 2
58167: PUSH
58168: LD_VAR 0 2
58172: PPUSH
58173: LD_INT 1
58175: PPUSH
58176: LD_VAR 0 4
58180: PUSH
58181: LD_VAR 0 5
58185: DIFF
58186: PPUSH
58187: CALL_OW 1
58191: ST_TO_ADDR
// exit ;
58192: GO 58194
// end ; end ;
58194: LD_VAR 0 2
58198: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58199: LD_INT 0
58201: PPUSH
58202: PPUSH
58203: PPUSH
// if not mc_bases then
58204: LD_EXP 23
58208: NOT
58209: IFFALSE 58213
// exit ;
58211: GO 58355
// for i = 1 to mc_bases do
58213: LD_ADDR_VAR 0 2
58217: PUSH
58218: DOUBLE
58219: LD_INT 1
58221: DEC
58222: ST_TO_ADDR
58223: LD_EXP 23
58227: PUSH
58228: FOR_TO
58229: IFFALSE 58346
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58231: LD_ADDR_VAR 0 3
58235: PUSH
58236: LD_EXP 23
58240: PUSH
58241: LD_VAR 0 2
58245: ARRAY
58246: PPUSH
58247: LD_INT 21
58249: PUSH
58250: LD_INT 3
58252: PUSH
58253: EMPTY
58254: LIST
58255: LIST
58256: PUSH
58257: LD_INT 3
58259: PUSH
58260: LD_INT 2
58262: PUSH
58263: LD_INT 30
58265: PUSH
58266: LD_INT 29
58268: PUSH
58269: EMPTY
58270: LIST
58271: LIST
58272: PUSH
58273: LD_INT 30
58275: PUSH
58276: LD_INT 30
58278: PUSH
58279: EMPTY
58280: LIST
58281: LIST
58282: PUSH
58283: EMPTY
58284: LIST
58285: LIST
58286: LIST
58287: PUSH
58288: EMPTY
58289: LIST
58290: LIST
58291: PUSH
58292: LD_INT 3
58294: PUSH
58295: LD_INT 24
58297: PUSH
58298: LD_INT 1000
58300: PUSH
58301: EMPTY
58302: LIST
58303: LIST
58304: PUSH
58305: EMPTY
58306: LIST
58307: LIST
58308: PUSH
58309: EMPTY
58310: LIST
58311: LIST
58312: LIST
58313: PPUSH
58314: CALL_OW 72
58318: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58319: LD_ADDR_EXP 24
58323: PUSH
58324: LD_EXP 24
58328: PPUSH
58329: LD_VAR 0 2
58333: PPUSH
58334: LD_VAR 0 3
58338: PPUSH
58339: CALL_OW 1
58343: ST_TO_ADDR
// end ;
58344: GO 58228
58346: POP
58347: POP
// RaiseSailEvent ( 101 ) ;
58348: LD_INT 101
58350: PPUSH
58351: CALL_OW 427
// end ;
58355: LD_VAR 0 1
58359: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58360: LD_INT 0
58362: PPUSH
58363: PPUSH
58364: PPUSH
58365: PPUSH
58366: PPUSH
58367: PPUSH
58368: PPUSH
// if not mc_bases then
58369: LD_EXP 23
58373: NOT
58374: IFFALSE 58378
// exit ;
58376: GO 58940
// for i = 1 to mc_bases do
58378: LD_ADDR_VAR 0 2
58382: PUSH
58383: DOUBLE
58384: LD_INT 1
58386: DEC
58387: ST_TO_ADDR
58388: LD_EXP 23
58392: PUSH
58393: FOR_TO
58394: IFFALSE 58931
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
58396: LD_ADDR_VAR 0 5
58400: PUSH
58401: LD_EXP 23
58405: PUSH
58406: LD_VAR 0 2
58410: ARRAY
58411: PUSH
58412: LD_EXP 52
58416: PUSH
58417: LD_VAR 0 2
58421: ARRAY
58422: UNION
58423: PPUSH
58424: LD_INT 21
58426: PUSH
58427: LD_INT 1
58429: PUSH
58430: EMPTY
58431: LIST
58432: LIST
58433: PUSH
58434: LD_INT 1
58436: PUSH
58437: LD_INT 3
58439: PUSH
58440: LD_INT 54
58442: PUSH
58443: EMPTY
58444: LIST
58445: PUSH
58446: EMPTY
58447: LIST
58448: LIST
58449: PUSH
58450: LD_INT 3
58452: PUSH
58453: LD_INT 24
58455: PUSH
58456: LD_INT 1000
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: PUSH
58467: EMPTY
58468: LIST
58469: LIST
58470: LIST
58471: PUSH
58472: EMPTY
58473: LIST
58474: LIST
58475: PPUSH
58476: CALL_OW 72
58480: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
58481: LD_ADDR_VAR 0 6
58485: PUSH
58486: LD_EXP 23
58490: PUSH
58491: LD_VAR 0 2
58495: ARRAY
58496: PPUSH
58497: LD_INT 21
58499: PUSH
58500: LD_INT 1
58502: PUSH
58503: EMPTY
58504: LIST
58505: LIST
58506: PUSH
58507: LD_INT 1
58509: PUSH
58510: LD_INT 3
58512: PUSH
58513: LD_INT 54
58515: PUSH
58516: EMPTY
58517: LIST
58518: PUSH
58519: EMPTY
58520: LIST
58521: LIST
58522: PUSH
58523: LD_INT 3
58525: PUSH
58526: LD_INT 24
58528: PUSH
58529: LD_INT 250
58531: PUSH
58532: EMPTY
58533: LIST
58534: LIST
58535: PUSH
58536: EMPTY
58537: LIST
58538: LIST
58539: PUSH
58540: EMPTY
58541: LIST
58542: LIST
58543: LIST
58544: PUSH
58545: EMPTY
58546: LIST
58547: LIST
58548: PPUSH
58549: CALL_OW 72
58553: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
58554: LD_ADDR_VAR 0 7
58558: PUSH
58559: LD_VAR 0 5
58563: PUSH
58564: LD_VAR 0 6
58568: DIFF
58569: ST_TO_ADDR
// if not need_heal_1 then
58570: LD_VAR 0 6
58574: NOT
58575: IFFALSE 58608
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
58577: LD_ADDR_EXP 26
58581: PUSH
58582: LD_EXP 26
58586: PPUSH
58587: LD_VAR 0 2
58591: PUSH
58592: LD_INT 1
58594: PUSH
58595: EMPTY
58596: LIST
58597: LIST
58598: PPUSH
58599: EMPTY
58600: PPUSH
58601: CALL 15990 0 3
58605: ST_TO_ADDR
58606: GO 58678
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
58608: LD_ADDR_EXP 26
58612: PUSH
58613: LD_EXP 26
58617: PPUSH
58618: LD_VAR 0 2
58622: PUSH
58623: LD_INT 1
58625: PUSH
58626: EMPTY
58627: LIST
58628: LIST
58629: PPUSH
58630: LD_EXP 26
58634: PUSH
58635: LD_VAR 0 2
58639: ARRAY
58640: PUSH
58641: LD_INT 1
58643: ARRAY
58644: PPUSH
58645: LD_INT 3
58647: PUSH
58648: LD_INT 24
58650: PUSH
58651: LD_INT 1000
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: PUSH
58658: EMPTY
58659: LIST
58660: LIST
58661: PPUSH
58662: CALL_OW 72
58666: PUSH
58667: LD_VAR 0 6
58671: UNION
58672: PPUSH
58673: CALL 15990 0 3
58677: ST_TO_ADDR
// if not need_heal_2 then
58678: LD_VAR 0 7
58682: NOT
58683: IFFALSE 58716
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
58685: LD_ADDR_EXP 26
58689: PUSH
58690: LD_EXP 26
58694: PPUSH
58695: LD_VAR 0 2
58699: PUSH
58700: LD_INT 2
58702: PUSH
58703: EMPTY
58704: LIST
58705: LIST
58706: PPUSH
58707: EMPTY
58708: PPUSH
58709: CALL 15990 0 3
58713: ST_TO_ADDR
58714: GO 58748
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
58716: LD_ADDR_EXP 26
58720: PUSH
58721: LD_EXP 26
58725: PPUSH
58726: LD_VAR 0 2
58730: PUSH
58731: LD_INT 2
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: PPUSH
58738: LD_VAR 0 7
58742: PPUSH
58743: CALL 15990 0 3
58747: ST_TO_ADDR
// if need_heal_2 then
58748: LD_VAR 0 7
58752: IFFALSE 58913
// for j in need_heal_2 do
58754: LD_ADDR_VAR 0 3
58758: PUSH
58759: LD_VAR 0 7
58763: PUSH
58764: FOR_IN
58765: IFFALSE 58911
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58767: LD_ADDR_VAR 0 5
58771: PUSH
58772: LD_EXP 23
58776: PUSH
58777: LD_VAR 0 2
58781: ARRAY
58782: PPUSH
58783: LD_INT 2
58785: PUSH
58786: LD_INT 30
58788: PUSH
58789: LD_INT 6
58791: PUSH
58792: EMPTY
58793: LIST
58794: LIST
58795: PUSH
58796: LD_INT 30
58798: PUSH
58799: LD_INT 7
58801: PUSH
58802: EMPTY
58803: LIST
58804: LIST
58805: PUSH
58806: LD_INT 30
58808: PUSH
58809: LD_INT 8
58811: PUSH
58812: EMPTY
58813: LIST
58814: LIST
58815: PUSH
58816: LD_INT 30
58818: PUSH
58819: LD_INT 0
58821: PUSH
58822: EMPTY
58823: LIST
58824: LIST
58825: PUSH
58826: LD_INT 30
58828: PUSH
58829: LD_INT 1
58831: PUSH
58832: EMPTY
58833: LIST
58834: LIST
58835: PUSH
58836: EMPTY
58837: LIST
58838: LIST
58839: LIST
58840: LIST
58841: LIST
58842: LIST
58843: PPUSH
58844: CALL_OW 72
58848: ST_TO_ADDR
// if tmp then
58849: LD_VAR 0 5
58853: IFFALSE 58909
// begin k := NearestUnitToUnit ( tmp , j ) ;
58855: LD_ADDR_VAR 0 4
58859: PUSH
58860: LD_VAR 0 5
58864: PPUSH
58865: LD_VAR 0 3
58869: PPUSH
58870: CALL_OW 74
58874: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
58875: LD_VAR 0 3
58879: PPUSH
58880: LD_VAR 0 4
58884: PPUSH
58885: CALL_OW 296
58889: PUSH
58890: LD_INT 5
58892: GREATER
58893: IFFALSE 58909
// ComMoveToNearbyEntrance ( j , k ) ;
58895: LD_VAR 0 3
58899: PPUSH
58900: LD_VAR 0 4
58904: PPUSH
58905: CALL 48608 0 2
// end ; end ;
58909: GO 58764
58911: POP
58912: POP
// if not need_heal_1 and not need_heal_2 then
58913: LD_VAR 0 6
58917: NOT
58918: PUSH
58919: LD_VAR 0 7
58923: NOT
58924: AND
58925: IFFALSE 58929
// continue ;
58927: GO 58393
// end ;
58929: GO 58393
58931: POP
58932: POP
// RaiseSailEvent ( 102 ) ;
58933: LD_INT 102
58935: PPUSH
58936: CALL_OW 427
// end ;
58940: LD_VAR 0 1
58944: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
58945: LD_INT 0
58947: PPUSH
58948: PPUSH
58949: PPUSH
58950: PPUSH
58951: PPUSH
58952: PPUSH
58953: PPUSH
58954: PPUSH
// if not mc_bases then
58955: LD_EXP 23
58959: NOT
58960: IFFALSE 58964
// exit ;
58962: GO 59847
// for i = 1 to mc_bases do
58964: LD_ADDR_VAR 0 2
58968: PUSH
58969: DOUBLE
58970: LD_INT 1
58972: DEC
58973: ST_TO_ADDR
58974: LD_EXP 23
58978: PUSH
58979: FOR_TO
58980: IFFALSE 59845
// begin if not mc_building_need_repair [ i ] then
58982: LD_EXP 24
58986: PUSH
58987: LD_VAR 0 2
58991: ARRAY
58992: NOT
58993: IFFALSE 59180
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
58995: LD_ADDR_VAR 0 6
58999: PUSH
59000: LD_EXP 42
59004: PUSH
59005: LD_VAR 0 2
59009: ARRAY
59010: PPUSH
59011: LD_INT 3
59013: PUSH
59014: LD_INT 24
59016: PUSH
59017: LD_INT 1000
59019: PUSH
59020: EMPTY
59021: LIST
59022: LIST
59023: PUSH
59024: EMPTY
59025: LIST
59026: LIST
59027: PUSH
59028: LD_INT 2
59030: PUSH
59031: LD_INT 34
59033: PUSH
59034: LD_INT 13
59036: PUSH
59037: EMPTY
59038: LIST
59039: LIST
59040: PUSH
59041: LD_INT 34
59043: PUSH
59044: LD_INT 52
59046: PUSH
59047: EMPTY
59048: LIST
59049: LIST
59050: PUSH
59051: LD_INT 34
59053: PUSH
59054: LD_EXP 73
59058: PUSH
59059: EMPTY
59060: LIST
59061: LIST
59062: PUSH
59063: EMPTY
59064: LIST
59065: LIST
59066: LIST
59067: LIST
59068: PUSH
59069: EMPTY
59070: LIST
59071: LIST
59072: PPUSH
59073: CALL_OW 72
59077: ST_TO_ADDR
// if cranes then
59078: LD_VAR 0 6
59082: IFFALSE 59144
// for j in cranes do
59084: LD_ADDR_VAR 0 3
59088: PUSH
59089: LD_VAR 0 6
59093: PUSH
59094: FOR_IN
59095: IFFALSE 59142
// if not IsInArea ( j , mc_parking [ i ] ) then
59097: LD_VAR 0 3
59101: PPUSH
59102: LD_EXP 47
59106: PUSH
59107: LD_VAR 0 2
59111: ARRAY
59112: PPUSH
59113: CALL_OW 308
59117: NOT
59118: IFFALSE 59140
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59120: LD_VAR 0 3
59124: PPUSH
59125: LD_EXP 47
59129: PUSH
59130: LD_VAR 0 2
59134: ARRAY
59135: PPUSH
59136: CALL_OW 113
59140: GO 59094
59142: POP
59143: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59144: LD_ADDR_EXP 25
59148: PUSH
59149: LD_EXP 25
59153: PPUSH
59154: LD_VAR 0 2
59158: PPUSH
59159: EMPTY
59160: PPUSH
59161: CALL_OW 1
59165: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59166: LD_VAR 0 2
59170: PPUSH
59171: LD_INT 101
59173: PPUSH
59174: CALL 54032 0 2
// continue ;
59178: GO 58979
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59180: LD_ADDR_EXP 29
59184: PUSH
59185: LD_EXP 29
59189: PPUSH
59190: LD_VAR 0 2
59194: PPUSH
59195: EMPTY
59196: PPUSH
59197: CALL_OW 1
59201: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59202: LD_VAR 0 2
59206: PPUSH
59207: LD_INT 103
59209: PPUSH
59210: CALL 54032 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
59214: LD_ADDR_VAR 0 5
59218: PUSH
59219: LD_EXP 23
59223: PUSH
59224: LD_VAR 0 2
59228: ARRAY
59229: PUSH
59230: LD_EXP 52
59234: PUSH
59235: LD_VAR 0 2
59239: ARRAY
59240: UNION
59241: PPUSH
59242: LD_INT 2
59244: PUSH
59245: LD_INT 25
59247: PUSH
59248: LD_INT 2
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: PUSH
59255: LD_INT 25
59257: PUSH
59258: LD_INT 16
59260: PUSH
59261: EMPTY
59262: LIST
59263: LIST
59264: PUSH
59265: EMPTY
59266: LIST
59267: LIST
59268: LIST
59269: PUSH
59270: EMPTY
59271: LIST
59272: PPUSH
59273: CALL_OW 72
59277: ST_TO_ADDR
// if mc_need_heal [ i ] then
59278: LD_EXP 26
59282: PUSH
59283: LD_VAR 0 2
59287: ARRAY
59288: IFFALSE 59332
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59290: LD_ADDR_VAR 0 5
59294: PUSH
59295: LD_VAR 0 5
59299: PUSH
59300: LD_EXP 26
59304: PUSH
59305: LD_VAR 0 2
59309: ARRAY
59310: PUSH
59311: LD_INT 1
59313: ARRAY
59314: PUSH
59315: LD_EXP 26
59319: PUSH
59320: LD_VAR 0 2
59324: ARRAY
59325: PUSH
59326: LD_INT 2
59328: ARRAY
59329: UNION
59330: DIFF
59331: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
59332: LD_ADDR_VAR 0 6
59336: PUSH
59337: LD_EXP 42
59341: PUSH
59342: LD_VAR 0 2
59346: ARRAY
59347: PPUSH
59348: LD_INT 2
59350: PUSH
59351: LD_INT 34
59353: PUSH
59354: LD_INT 13
59356: PUSH
59357: EMPTY
59358: LIST
59359: LIST
59360: PUSH
59361: LD_INT 34
59363: PUSH
59364: LD_INT 52
59366: PUSH
59367: EMPTY
59368: LIST
59369: LIST
59370: PUSH
59371: LD_INT 34
59373: PUSH
59374: LD_EXP 73
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: PPUSH
59389: CALL_OW 72
59393: ST_TO_ADDR
// if cranes then
59394: LD_VAR 0 6
59398: IFFALSE 59534
// begin for j in cranes do
59400: LD_ADDR_VAR 0 3
59404: PUSH
59405: LD_VAR 0 6
59409: PUSH
59410: FOR_IN
59411: IFFALSE 59532
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
59413: LD_VAR 0 3
59417: PPUSH
59418: CALL_OW 256
59422: PUSH
59423: LD_INT 1000
59425: EQUAL
59426: PUSH
59427: LD_VAR 0 3
59431: PPUSH
59432: CALL_OW 314
59436: NOT
59437: AND
59438: IFFALSE 59472
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59440: LD_VAR 0 3
59444: PPUSH
59445: LD_EXP 24
59449: PUSH
59450: LD_VAR 0 2
59454: ARRAY
59455: PPUSH
59456: LD_VAR 0 3
59460: PPUSH
59461: CALL_OW 74
59465: PPUSH
59466: CALL_OW 130
59470: GO 59530
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59472: LD_VAR 0 3
59476: PPUSH
59477: CALL_OW 256
59481: PUSH
59482: LD_INT 500
59484: LESS
59485: PUSH
59486: LD_VAR 0 3
59490: PPUSH
59491: LD_EXP 47
59495: PUSH
59496: LD_VAR 0 2
59500: ARRAY
59501: PPUSH
59502: CALL_OW 308
59506: NOT
59507: AND
59508: IFFALSE 59530
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59510: LD_VAR 0 3
59514: PPUSH
59515: LD_EXP 47
59519: PUSH
59520: LD_VAR 0 2
59524: ARRAY
59525: PPUSH
59526: CALL_OW 113
// end ;
59530: GO 59410
59532: POP
59533: POP
// end ; if tmp > 3 then
59534: LD_VAR 0 5
59538: PUSH
59539: LD_INT 3
59541: GREATER
59542: IFFALSE 59562
// tmp := ShrinkArray ( tmp , 4 ) ;
59544: LD_ADDR_VAR 0 5
59548: PUSH
59549: LD_VAR 0 5
59553: PPUSH
59554: LD_INT 4
59556: PPUSH
59557: CALL 48056 0 2
59561: ST_TO_ADDR
// if not tmp then
59562: LD_VAR 0 5
59566: NOT
59567: IFFALSE 59571
// continue ;
59569: GO 58979
// for j in tmp do
59571: LD_ADDR_VAR 0 3
59575: PUSH
59576: LD_VAR 0 5
59580: PUSH
59581: FOR_IN
59582: IFFALSE 59841
// begin if IsInUnit ( j ) then
59584: LD_VAR 0 3
59588: PPUSH
59589: CALL_OW 310
59593: IFFALSE 59604
// ComExitBuilding ( j ) ;
59595: LD_VAR 0 3
59599: PPUSH
59600: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
59604: LD_VAR 0 3
59608: PUSH
59609: LD_EXP 25
59613: PUSH
59614: LD_VAR 0 2
59618: ARRAY
59619: IN
59620: NOT
59621: IFFALSE 59679
// begin SetTag ( j , 101 ) ;
59623: LD_VAR 0 3
59627: PPUSH
59628: LD_INT 101
59630: PPUSH
59631: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
59635: LD_ADDR_EXP 25
59639: PUSH
59640: LD_EXP 25
59644: PPUSH
59645: LD_VAR 0 2
59649: PUSH
59650: LD_EXP 25
59654: PUSH
59655: LD_VAR 0 2
59659: ARRAY
59660: PUSH
59661: LD_INT 1
59663: PLUS
59664: PUSH
59665: EMPTY
59666: LIST
59667: LIST
59668: PPUSH
59669: LD_VAR 0 3
59673: PPUSH
59674: CALL 15990 0 3
59678: ST_TO_ADDR
// end ; wait ( 1 ) ;
59679: LD_INT 1
59681: PPUSH
59682: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
59686: LD_ADDR_VAR 0 7
59690: PUSH
59691: LD_EXP 24
59695: PUSH
59696: LD_VAR 0 2
59700: ARRAY
59701: ST_TO_ADDR
// if mc_scan [ i ] then
59702: LD_EXP 46
59706: PUSH
59707: LD_VAR 0 2
59711: ARRAY
59712: IFFALSE 59774
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
59714: LD_ADDR_VAR 0 7
59718: PUSH
59719: LD_EXP 24
59723: PUSH
59724: LD_VAR 0 2
59728: ARRAY
59729: PPUSH
59730: LD_INT 3
59732: PUSH
59733: LD_INT 30
59735: PUSH
59736: LD_INT 32
59738: PUSH
59739: EMPTY
59740: LIST
59741: LIST
59742: PUSH
59743: LD_INT 30
59745: PUSH
59746: LD_INT 33
59748: PUSH
59749: EMPTY
59750: LIST
59751: LIST
59752: PUSH
59753: LD_INT 30
59755: PUSH
59756: LD_INT 31
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: PUSH
59763: EMPTY
59764: LIST
59765: LIST
59766: LIST
59767: LIST
59768: PPUSH
59769: CALL_OW 72
59773: ST_TO_ADDR
// if not to_repair_tmp then
59774: LD_VAR 0 7
59778: NOT
59779: IFFALSE 59783
// continue ;
59781: GO 59581
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
59783: LD_ADDR_VAR 0 8
59787: PUSH
59788: LD_VAR 0 7
59792: PPUSH
59793: LD_VAR 0 3
59797: PPUSH
59798: CALL_OW 74
59802: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
59803: LD_VAR 0 8
59807: PPUSH
59808: LD_INT 16
59810: PPUSH
59811: CALL 18589 0 2
59815: PUSH
59816: LD_INT 4
59818: ARRAY
59819: PUSH
59820: LD_INT 10
59822: LESS
59823: IFFALSE 59839
// ComRepairBuilding ( j , to_repair ) ;
59825: LD_VAR 0 3
59829: PPUSH
59830: LD_VAR 0 8
59834: PPUSH
59835: CALL_OW 130
// end ;
59839: GO 59581
59841: POP
59842: POP
// end ;
59843: GO 58979
59845: POP
59846: POP
// end ;
59847: LD_VAR 0 1
59851: RET
// export function MC_Heal ; var i , j , tmp ; begin
59852: LD_INT 0
59854: PPUSH
59855: PPUSH
59856: PPUSH
59857: PPUSH
// if not mc_bases then
59858: LD_EXP 23
59862: NOT
59863: IFFALSE 59867
// exit ;
59865: GO 60269
// for i = 1 to mc_bases do
59867: LD_ADDR_VAR 0 2
59871: PUSH
59872: DOUBLE
59873: LD_INT 1
59875: DEC
59876: ST_TO_ADDR
59877: LD_EXP 23
59881: PUSH
59882: FOR_TO
59883: IFFALSE 60267
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
59885: LD_EXP 26
59889: PUSH
59890: LD_VAR 0 2
59894: ARRAY
59895: PUSH
59896: LD_INT 1
59898: ARRAY
59899: NOT
59900: PUSH
59901: LD_EXP 26
59905: PUSH
59906: LD_VAR 0 2
59910: ARRAY
59911: PUSH
59912: LD_INT 2
59914: ARRAY
59915: NOT
59916: AND
59917: IFFALSE 59955
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
59919: LD_ADDR_EXP 27
59923: PUSH
59924: LD_EXP 27
59928: PPUSH
59929: LD_VAR 0 2
59933: PPUSH
59934: EMPTY
59935: PPUSH
59936: CALL_OW 1
59940: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
59941: LD_VAR 0 2
59945: PPUSH
59946: LD_INT 102
59948: PPUSH
59949: CALL 54032 0 2
// continue ;
59953: GO 59882
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59955: LD_ADDR_VAR 0 4
59959: PUSH
59960: LD_EXP 23
59964: PUSH
59965: LD_VAR 0 2
59969: ARRAY
59970: PPUSH
59971: LD_INT 25
59973: PUSH
59974: LD_INT 4
59976: PUSH
59977: EMPTY
59978: LIST
59979: LIST
59980: PPUSH
59981: CALL_OW 72
59985: ST_TO_ADDR
// if not tmp then
59986: LD_VAR 0 4
59990: NOT
59991: IFFALSE 59995
// continue ;
59993: GO 59882
// if mc_taming [ i ] then
59995: LD_EXP 54
59999: PUSH
60000: LD_VAR 0 2
60004: ARRAY
60005: IFFALSE 60029
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60007: LD_ADDR_EXP 54
60011: PUSH
60012: LD_EXP 54
60016: PPUSH
60017: LD_VAR 0 2
60021: PPUSH
60022: EMPTY
60023: PPUSH
60024: CALL_OW 1
60028: ST_TO_ADDR
// for j in tmp do
60029: LD_ADDR_VAR 0 3
60033: PUSH
60034: LD_VAR 0 4
60038: PUSH
60039: FOR_IN
60040: IFFALSE 60263
// begin if IsInUnit ( j ) then
60042: LD_VAR 0 3
60046: PPUSH
60047: CALL_OW 310
60051: IFFALSE 60062
// ComExitBuilding ( j ) ;
60053: LD_VAR 0 3
60057: PPUSH
60058: CALL_OW 122
// if not j in mc_healers [ i ] then
60062: LD_VAR 0 3
60066: PUSH
60067: LD_EXP 27
60071: PUSH
60072: LD_VAR 0 2
60076: ARRAY
60077: IN
60078: NOT
60079: IFFALSE 60125
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60081: LD_ADDR_EXP 27
60085: PUSH
60086: LD_EXP 27
60090: PPUSH
60091: LD_VAR 0 2
60095: PUSH
60096: LD_EXP 27
60100: PUSH
60101: LD_VAR 0 2
60105: ARRAY
60106: PUSH
60107: LD_INT 1
60109: PLUS
60110: PUSH
60111: EMPTY
60112: LIST
60113: LIST
60114: PPUSH
60115: LD_VAR 0 3
60119: PPUSH
60120: CALL 15990 0 3
60124: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60125: LD_VAR 0 3
60129: PPUSH
60130: CALL_OW 110
60134: PUSH
60135: LD_INT 102
60137: NONEQUAL
60138: IFFALSE 60152
// SetTag ( j , 102 ) ;
60140: LD_VAR 0 3
60144: PPUSH
60145: LD_INT 102
60147: PPUSH
60148: CALL_OW 109
// Wait ( 3 ) ;
60152: LD_INT 3
60154: PPUSH
60155: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60159: LD_EXP 26
60163: PUSH
60164: LD_VAR 0 2
60168: ARRAY
60169: PUSH
60170: LD_INT 1
60172: ARRAY
60173: IFFALSE 60205
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60175: LD_VAR 0 3
60179: PPUSH
60180: LD_EXP 26
60184: PUSH
60185: LD_VAR 0 2
60189: ARRAY
60190: PUSH
60191: LD_INT 1
60193: ARRAY
60194: PUSH
60195: LD_INT 1
60197: ARRAY
60198: PPUSH
60199: CALL_OW 128
60203: GO 60261
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60205: LD_VAR 0 3
60209: PPUSH
60210: CALL_OW 314
60214: NOT
60215: PUSH
60216: LD_EXP 26
60220: PUSH
60221: LD_VAR 0 2
60225: ARRAY
60226: PUSH
60227: LD_INT 2
60229: ARRAY
60230: AND
60231: IFFALSE 60261
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60233: LD_VAR 0 3
60237: PPUSH
60238: LD_EXP 26
60242: PUSH
60243: LD_VAR 0 2
60247: ARRAY
60248: PUSH
60249: LD_INT 2
60251: ARRAY
60252: PUSH
60253: LD_INT 1
60255: ARRAY
60256: PPUSH
60257: CALL_OW 128
// end ;
60261: GO 60039
60263: POP
60264: POP
// end ;
60265: GO 59882
60267: POP
60268: POP
// end ;
60269: LD_VAR 0 1
60273: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60274: LD_INT 0
60276: PPUSH
60277: PPUSH
60278: PPUSH
60279: PPUSH
60280: PPUSH
// if not mc_bases then
60281: LD_EXP 23
60285: NOT
60286: IFFALSE 60290
// exit ;
60288: GO 61461
// for i = 1 to mc_bases do
60290: LD_ADDR_VAR 0 2
60294: PUSH
60295: DOUBLE
60296: LD_INT 1
60298: DEC
60299: ST_TO_ADDR
60300: LD_EXP 23
60304: PUSH
60305: FOR_TO
60306: IFFALSE 61459
// begin if mc_scan [ i ] then
60308: LD_EXP 46
60312: PUSH
60313: LD_VAR 0 2
60317: ARRAY
60318: IFFALSE 60322
// continue ;
60320: GO 60305
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60322: LD_EXP 28
60326: PUSH
60327: LD_VAR 0 2
60331: ARRAY
60332: NOT
60333: PUSH
60334: LD_EXP 30
60338: PUSH
60339: LD_VAR 0 2
60343: ARRAY
60344: NOT
60345: AND
60346: PUSH
60347: LD_EXP 29
60351: PUSH
60352: LD_VAR 0 2
60356: ARRAY
60357: AND
60358: IFFALSE 60396
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60360: LD_ADDR_EXP 29
60364: PUSH
60365: LD_EXP 29
60369: PPUSH
60370: LD_VAR 0 2
60374: PPUSH
60375: EMPTY
60376: PPUSH
60377: CALL_OW 1
60381: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60382: LD_VAR 0 2
60386: PPUSH
60387: LD_INT 103
60389: PPUSH
60390: CALL 54032 0 2
// continue ;
60394: GO 60305
// end ; if mc_construct_list [ i ] then
60396: LD_EXP 30
60400: PUSH
60401: LD_VAR 0 2
60405: ARRAY
60406: IFFALSE 60626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60408: LD_ADDR_VAR 0 4
60412: PUSH
60413: LD_EXP 23
60417: PUSH
60418: LD_VAR 0 2
60422: ARRAY
60423: PPUSH
60424: LD_INT 25
60426: PUSH
60427: LD_INT 2
60429: PUSH
60430: EMPTY
60431: LIST
60432: LIST
60433: PPUSH
60434: CALL_OW 72
60438: PUSH
60439: LD_EXP 25
60443: PUSH
60444: LD_VAR 0 2
60448: ARRAY
60449: DIFF
60450: ST_TO_ADDR
// if not tmp then
60451: LD_VAR 0 4
60455: NOT
60456: IFFALSE 60460
// continue ;
60458: GO 60305
// for j in tmp do
60460: LD_ADDR_VAR 0 3
60464: PUSH
60465: LD_VAR 0 4
60469: PUSH
60470: FOR_IN
60471: IFFALSE 60622
// begin if not mc_builders [ i ] then
60473: LD_EXP 29
60477: PUSH
60478: LD_VAR 0 2
60482: ARRAY
60483: NOT
60484: IFFALSE 60542
// begin SetTag ( j , 103 ) ;
60486: LD_VAR 0 3
60490: PPUSH
60491: LD_INT 103
60493: PPUSH
60494: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60498: LD_ADDR_EXP 29
60502: PUSH
60503: LD_EXP 29
60507: PPUSH
60508: LD_VAR 0 2
60512: PUSH
60513: LD_EXP 29
60517: PUSH
60518: LD_VAR 0 2
60522: ARRAY
60523: PUSH
60524: LD_INT 1
60526: PLUS
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: PPUSH
60532: LD_VAR 0 3
60536: PPUSH
60537: CALL 15990 0 3
60541: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60542: LD_VAR 0 3
60546: PPUSH
60547: CALL_OW 310
60551: IFFALSE 60562
// ComExitBuilding ( j ) ;
60553: LD_VAR 0 3
60557: PPUSH
60558: CALL_OW 122
// wait ( 3 ) ;
60562: LD_INT 3
60564: PPUSH
60565: CALL_OW 67
// if not mc_construct_list [ i ] then
60569: LD_EXP 30
60573: PUSH
60574: LD_VAR 0 2
60578: ARRAY
60579: NOT
60580: IFFALSE 60584
// break ;
60582: GO 60622
// if not HasTask ( j ) then
60584: LD_VAR 0 3
60588: PPUSH
60589: CALL_OW 314
60593: NOT
60594: IFFALSE 60620
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
60596: LD_VAR 0 3
60600: PPUSH
60601: LD_EXP 30
60605: PUSH
60606: LD_VAR 0 2
60610: ARRAY
60611: PUSH
60612: LD_INT 1
60614: ARRAY
60615: PPUSH
60616: CALL 18853 0 2
// end ;
60620: GO 60470
60622: POP
60623: POP
// end else
60624: GO 61457
// if mc_build_list [ i ] then
60626: LD_EXP 28
60630: PUSH
60631: LD_VAR 0 2
60635: ARRAY
60636: IFFALSE 61457
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60638: LD_ADDR_VAR 0 5
60642: PUSH
60643: LD_EXP 23
60647: PUSH
60648: LD_VAR 0 2
60652: ARRAY
60653: PPUSH
60654: LD_INT 2
60656: PUSH
60657: LD_INT 30
60659: PUSH
60660: LD_INT 0
60662: PUSH
60663: EMPTY
60664: LIST
60665: LIST
60666: PUSH
60667: LD_INT 30
60669: PUSH
60670: LD_INT 1
60672: PUSH
60673: EMPTY
60674: LIST
60675: LIST
60676: PUSH
60677: EMPTY
60678: LIST
60679: LIST
60680: LIST
60681: PPUSH
60682: CALL_OW 72
60686: ST_TO_ADDR
// if depot then
60687: LD_VAR 0 5
60691: IFFALSE 60709
// depot := depot [ 1 ] else
60693: LD_ADDR_VAR 0 5
60697: PUSH
60698: LD_VAR 0 5
60702: PUSH
60703: LD_INT 1
60705: ARRAY
60706: ST_TO_ADDR
60707: GO 60717
// depot := 0 ;
60709: LD_ADDR_VAR 0 5
60713: PUSH
60714: LD_INT 0
60716: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
60717: LD_EXP 28
60721: PUSH
60722: LD_VAR 0 2
60726: ARRAY
60727: PUSH
60728: LD_INT 1
60730: ARRAY
60731: PUSH
60732: LD_INT 1
60734: ARRAY
60735: PPUSH
60736: CALL 18677 0 1
60740: PUSH
60741: LD_EXP 23
60745: PUSH
60746: LD_VAR 0 2
60750: ARRAY
60751: PPUSH
60752: LD_INT 2
60754: PUSH
60755: LD_INT 30
60757: PUSH
60758: LD_INT 2
60760: PUSH
60761: EMPTY
60762: LIST
60763: LIST
60764: PUSH
60765: LD_INT 30
60767: PUSH
60768: LD_INT 3
60770: PUSH
60771: EMPTY
60772: LIST
60773: LIST
60774: PUSH
60775: EMPTY
60776: LIST
60777: LIST
60778: LIST
60779: PPUSH
60780: CALL_OW 72
60784: NOT
60785: AND
60786: IFFALSE 60891
// begin for j = 1 to mc_build_list [ i ] do
60788: LD_ADDR_VAR 0 3
60792: PUSH
60793: DOUBLE
60794: LD_INT 1
60796: DEC
60797: ST_TO_ADDR
60798: LD_EXP 28
60802: PUSH
60803: LD_VAR 0 2
60807: ARRAY
60808: PUSH
60809: FOR_TO
60810: IFFALSE 60889
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
60812: LD_EXP 28
60816: PUSH
60817: LD_VAR 0 2
60821: ARRAY
60822: PUSH
60823: LD_VAR 0 3
60827: ARRAY
60828: PUSH
60829: LD_INT 1
60831: ARRAY
60832: PUSH
60833: LD_INT 2
60835: EQUAL
60836: IFFALSE 60887
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
60838: LD_ADDR_EXP 28
60842: PUSH
60843: LD_EXP 28
60847: PPUSH
60848: LD_VAR 0 2
60852: PPUSH
60853: LD_EXP 28
60857: PUSH
60858: LD_VAR 0 2
60862: ARRAY
60863: PPUSH
60864: LD_VAR 0 3
60868: PPUSH
60869: LD_INT 1
60871: PPUSH
60872: LD_INT 0
60874: PPUSH
60875: CALL 15408 0 4
60879: PPUSH
60880: CALL_OW 1
60884: ST_TO_ADDR
// break ;
60885: GO 60889
// end ;
60887: GO 60809
60889: POP
60890: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
60891: LD_EXP 28
60895: PUSH
60896: LD_VAR 0 2
60900: ARRAY
60901: PUSH
60902: LD_INT 1
60904: ARRAY
60905: PUSH
60906: LD_INT 1
60908: ARRAY
60909: PUSH
60910: LD_INT 0
60912: EQUAL
60913: PUSH
60914: LD_VAR 0 5
60918: PUSH
60919: LD_VAR 0 5
60923: PPUSH
60924: LD_EXP 28
60928: PUSH
60929: LD_VAR 0 2
60933: ARRAY
60934: PUSH
60935: LD_INT 1
60937: ARRAY
60938: PUSH
60939: LD_INT 1
60941: ARRAY
60942: PPUSH
60943: LD_EXP 28
60947: PUSH
60948: LD_VAR 0 2
60952: ARRAY
60953: PUSH
60954: LD_INT 1
60956: ARRAY
60957: PUSH
60958: LD_INT 2
60960: ARRAY
60961: PPUSH
60962: LD_EXP 28
60966: PUSH
60967: LD_VAR 0 2
60971: ARRAY
60972: PUSH
60973: LD_INT 1
60975: ARRAY
60976: PUSH
60977: LD_INT 3
60979: ARRAY
60980: PPUSH
60981: LD_EXP 28
60985: PUSH
60986: LD_VAR 0 2
60990: ARRAY
60991: PUSH
60992: LD_INT 1
60994: ARRAY
60995: PUSH
60996: LD_INT 4
60998: ARRAY
60999: PPUSH
61000: CALL 24093 0 5
61004: AND
61005: OR
61006: IFFALSE 61287
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61008: LD_ADDR_VAR 0 4
61012: PUSH
61013: LD_EXP 23
61017: PUSH
61018: LD_VAR 0 2
61022: ARRAY
61023: PPUSH
61024: LD_INT 25
61026: PUSH
61027: LD_INT 2
61029: PUSH
61030: EMPTY
61031: LIST
61032: LIST
61033: PPUSH
61034: CALL_OW 72
61038: PUSH
61039: LD_EXP 25
61043: PUSH
61044: LD_VAR 0 2
61048: ARRAY
61049: DIFF
61050: ST_TO_ADDR
// if not tmp then
61051: LD_VAR 0 4
61055: NOT
61056: IFFALSE 61060
// continue ;
61058: GO 60305
// for j in tmp do
61060: LD_ADDR_VAR 0 3
61064: PUSH
61065: LD_VAR 0 4
61069: PUSH
61070: FOR_IN
61071: IFFALSE 61283
// begin if not mc_builders [ i ] then
61073: LD_EXP 29
61077: PUSH
61078: LD_VAR 0 2
61082: ARRAY
61083: NOT
61084: IFFALSE 61142
// begin SetTag ( j , 103 ) ;
61086: LD_VAR 0 3
61090: PPUSH
61091: LD_INT 103
61093: PPUSH
61094: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61098: LD_ADDR_EXP 29
61102: PUSH
61103: LD_EXP 29
61107: PPUSH
61108: LD_VAR 0 2
61112: PUSH
61113: LD_EXP 29
61117: PUSH
61118: LD_VAR 0 2
61122: ARRAY
61123: PUSH
61124: LD_INT 1
61126: PLUS
61127: PUSH
61128: EMPTY
61129: LIST
61130: LIST
61131: PPUSH
61132: LD_VAR 0 3
61136: PPUSH
61137: CALL 15990 0 3
61141: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61142: LD_VAR 0 3
61146: PPUSH
61147: CALL_OW 310
61151: IFFALSE 61162
// ComExitBuilding ( j ) ;
61153: LD_VAR 0 3
61157: PPUSH
61158: CALL_OW 122
// wait ( 3 ) ;
61162: LD_INT 3
61164: PPUSH
61165: CALL_OW 67
// if not mc_build_list [ i ] then
61169: LD_EXP 28
61173: PUSH
61174: LD_VAR 0 2
61178: ARRAY
61179: NOT
61180: IFFALSE 61184
// break ;
61182: GO 61283
// if not HasTask ( j ) then
61184: LD_VAR 0 3
61188: PPUSH
61189: CALL_OW 314
61193: NOT
61194: IFFALSE 61281
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61196: LD_VAR 0 3
61200: PPUSH
61201: LD_EXP 28
61205: PUSH
61206: LD_VAR 0 2
61210: ARRAY
61211: PUSH
61212: LD_INT 1
61214: ARRAY
61215: PUSH
61216: LD_INT 1
61218: ARRAY
61219: PPUSH
61220: LD_EXP 28
61224: PUSH
61225: LD_VAR 0 2
61229: ARRAY
61230: PUSH
61231: LD_INT 1
61233: ARRAY
61234: PUSH
61235: LD_INT 2
61237: ARRAY
61238: PPUSH
61239: LD_EXP 28
61243: PUSH
61244: LD_VAR 0 2
61248: ARRAY
61249: PUSH
61250: LD_INT 1
61252: ARRAY
61253: PUSH
61254: LD_INT 3
61256: ARRAY
61257: PPUSH
61258: LD_EXP 28
61262: PUSH
61263: LD_VAR 0 2
61267: ARRAY
61268: PUSH
61269: LD_INT 1
61271: ARRAY
61272: PUSH
61273: LD_INT 4
61275: ARRAY
61276: PPUSH
61277: CALL_OW 145
// end ;
61281: GO 61070
61283: POP
61284: POP
// end else
61285: GO 61457
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
61287: LD_EXP 23
61291: PUSH
61292: LD_VAR 0 2
61296: ARRAY
61297: PPUSH
61298: LD_EXP 28
61302: PUSH
61303: LD_VAR 0 2
61307: ARRAY
61308: PUSH
61309: LD_INT 1
61311: ARRAY
61312: PUSH
61313: LD_INT 1
61315: ARRAY
61316: PPUSH
61317: LD_EXP 28
61321: PUSH
61322: LD_VAR 0 2
61326: ARRAY
61327: PUSH
61328: LD_INT 1
61330: ARRAY
61331: PUSH
61332: LD_INT 2
61334: ARRAY
61335: PPUSH
61336: LD_EXP 28
61340: PUSH
61341: LD_VAR 0 2
61345: ARRAY
61346: PUSH
61347: LD_INT 1
61349: ARRAY
61350: PUSH
61351: LD_INT 3
61353: ARRAY
61354: PPUSH
61355: LD_EXP 28
61359: PUSH
61360: LD_VAR 0 2
61364: ARRAY
61365: PUSH
61366: LD_INT 1
61368: ARRAY
61369: PUSH
61370: LD_INT 4
61372: ARRAY
61373: PPUSH
61374: LD_EXP 23
61378: PUSH
61379: LD_VAR 0 2
61383: ARRAY
61384: PPUSH
61385: LD_INT 21
61387: PUSH
61388: LD_INT 3
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: PPUSH
61395: CALL_OW 72
61399: PPUSH
61400: EMPTY
61401: PPUSH
61402: CALL 22843 0 7
61406: NOT
61407: IFFALSE 61457
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61409: LD_ADDR_EXP 28
61413: PUSH
61414: LD_EXP 28
61418: PPUSH
61419: LD_VAR 0 2
61423: PPUSH
61424: LD_EXP 28
61428: PUSH
61429: LD_VAR 0 2
61433: ARRAY
61434: PPUSH
61435: LD_INT 1
61437: PPUSH
61438: LD_INT 1
61440: NEG
61441: PPUSH
61442: LD_INT 0
61444: PPUSH
61445: CALL 15408 0 4
61449: PPUSH
61450: CALL_OW 1
61454: ST_TO_ADDR
// continue ;
61455: GO 60305
// end ; end ; end ;
61457: GO 60305
61459: POP
61460: POP
// end ;
61461: LD_VAR 0 1
61465: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61466: LD_INT 0
61468: PPUSH
61469: PPUSH
61470: PPUSH
61471: PPUSH
61472: PPUSH
61473: PPUSH
// if not mc_bases then
61474: LD_EXP 23
61478: NOT
61479: IFFALSE 61483
// exit ;
61481: GO 61910
// for i = 1 to mc_bases do
61483: LD_ADDR_VAR 0 2
61487: PUSH
61488: DOUBLE
61489: LD_INT 1
61491: DEC
61492: ST_TO_ADDR
61493: LD_EXP 23
61497: PUSH
61498: FOR_TO
61499: IFFALSE 61908
// begin tmp := mc_build_upgrade [ i ] ;
61501: LD_ADDR_VAR 0 4
61505: PUSH
61506: LD_EXP 55
61510: PUSH
61511: LD_VAR 0 2
61515: ARRAY
61516: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61517: LD_ADDR_VAR 0 6
61521: PUSH
61522: LD_EXP 56
61526: PUSH
61527: LD_VAR 0 2
61531: ARRAY
61532: PPUSH
61533: LD_INT 2
61535: PUSH
61536: LD_INT 30
61538: PUSH
61539: LD_INT 6
61541: PUSH
61542: EMPTY
61543: LIST
61544: LIST
61545: PUSH
61546: LD_INT 30
61548: PUSH
61549: LD_INT 7
61551: PUSH
61552: EMPTY
61553: LIST
61554: LIST
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: LIST
61560: PPUSH
61561: CALL_OW 72
61565: ST_TO_ADDR
// if not tmp and not lab then
61566: LD_VAR 0 4
61570: NOT
61571: PUSH
61572: LD_VAR 0 6
61576: NOT
61577: AND
61578: IFFALSE 61582
// continue ;
61580: GO 61498
// if tmp then
61582: LD_VAR 0 4
61586: IFFALSE 61706
// for j in tmp do
61588: LD_ADDR_VAR 0 3
61592: PUSH
61593: LD_VAR 0 4
61597: PUSH
61598: FOR_IN
61599: IFFALSE 61704
// begin if UpgradeCost ( j ) then
61601: LD_VAR 0 3
61605: PPUSH
61606: CALL 22503 0 1
61610: IFFALSE 61702
// begin ComUpgrade ( j ) ;
61612: LD_VAR 0 3
61616: PPUSH
61617: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
61621: LD_ADDR_EXP 55
61625: PUSH
61626: LD_EXP 55
61630: PPUSH
61631: LD_VAR 0 2
61635: PPUSH
61636: LD_EXP 55
61640: PUSH
61641: LD_VAR 0 2
61645: ARRAY
61646: PUSH
61647: LD_VAR 0 3
61651: DIFF
61652: PPUSH
61653: CALL_OW 1
61657: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61658: LD_ADDR_EXP 30
61662: PUSH
61663: LD_EXP 30
61667: PPUSH
61668: LD_VAR 0 2
61672: PUSH
61673: LD_EXP 30
61677: PUSH
61678: LD_VAR 0 2
61682: ARRAY
61683: PUSH
61684: LD_INT 1
61686: PLUS
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PPUSH
61692: LD_VAR 0 3
61696: PPUSH
61697: CALL 15990 0 3
61701: ST_TO_ADDR
// end ; end ;
61702: GO 61598
61704: POP
61705: POP
// if not lab or not mc_lab_upgrade [ i ] then
61706: LD_VAR 0 6
61710: NOT
61711: PUSH
61712: LD_EXP 57
61716: PUSH
61717: LD_VAR 0 2
61721: ARRAY
61722: NOT
61723: OR
61724: IFFALSE 61728
// continue ;
61726: GO 61498
// for j in lab do
61728: LD_ADDR_VAR 0 3
61732: PUSH
61733: LD_VAR 0 6
61737: PUSH
61738: FOR_IN
61739: IFFALSE 61904
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
61741: LD_VAR 0 3
61745: PPUSH
61746: CALL_OW 266
61750: PUSH
61751: LD_INT 6
61753: PUSH
61754: LD_INT 7
61756: PUSH
61757: EMPTY
61758: LIST
61759: LIST
61760: IN
61761: PUSH
61762: LD_VAR 0 3
61766: PPUSH
61767: CALL_OW 461
61771: PUSH
61772: LD_INT 1
61774: NONEQUAL
61775: AND
61776: IFFALSE 61902
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
61778: LD_VAR 0 3
61782: PPUSH
61783: LD_EXP 57
61787: PUSH
61788: LD_VAR 0 2
61792: ARRAY
61793: PUSH
61794: LD_INT 1
61796: ARRAY
61797: PPUSH
61798: CALL 22708 0 2
61802: IFFALSE 61902
// begin ComCancel ( j ) ;
61804: LD_VAR 0 3
61808: PPUSH
61809: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
61813: LD_VAR 0 3
61817: PPUSH
61818: LD_EXP 57
61822: PUSH
61823: LD_VAR 0 2
61827: ARRAY
61828: PUSH
61829: LD_INT 1
61831: ARRAY
61832: PPUSH
61833: CALL_OW 207
// if not j in mc_construct_list [ i ] then
61837: LD_VAR 0 3
61841: PUSH
61842: LD_EXP 30
61846: PUSH
61847: LD_VAR 0 2
61851: ARRAY
61852: IN
61853: NOT
61854: IFFALSE 61900
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61856: LD_ADDR_EXP 30
61860: PUSH
61861: LD_EXP 30
61865: PPUSH
61866: LD_VAR 0 2
61870: PUSH
61871: LD_EXP 30
61875: PUSH
61876: LD_VAR 0 2
61880: ARRAY
61881: PUSH
61882: LD_INT 1
61884: PLUS
61885: PUSH
61886: EMPTY
61887: LIST
61888: LIST
61889: PPUSH
61890: LD_VAR 0 3
61894: PPUSH
61895: CALL 15990 0 3
61899: ST_TO_ADDR
// break ;
61900: GO 61904
// end ; end ; end ;
61902: GO 61738
61904: POP
61905: POP
// end ;
61906: GO 61498
61908: POP
61909: POP
// end ;
61910: LD_VAR 0 1
61914: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
61915: LD_INT 0
61917: PPUSH
61918: PPUSH
61919: PPUSH
61920: PPUSH
61921: PPUSH
61922: PPUSH
61923: PPUSH
61924: PPUSH
61925: PPUSH
// if not mc_bases then
61926: LD_EXP 23
61930: NOT
61931: IFFALSE 61935
// exit ;
61933: GO 62340
// for i = 1 to mc_bases do
61935: LD_ADDR_VAR 0 2
61939: PUSH
61940: DOUBLE
61941: LD_INT 1
61943: DEC
61944: ST_TO_ADDR
61945: LD_EXP 23
61949: PUSH
61950: FOR_TO
61951: IFFALSE 62338
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
61953: LD_EXP 31
61957: PUSH
61958: LD_VAR 0 2
61962: ARRAY
61963: NOT
61964: PUSH
61965: LD_EXP 23
61969: PUSH
61970: LD_VAR 0 2
61974: ARRAY
61975: PPUSH
61976: LD_INT 30
61978: PUSH
61979: LD_INT 3
61981: PUSH
61982: EMPTY
61983: LIST
61984: LIST
61985: PPUSH
61986: CALL_OW 72
61990: NOT
61991: OR
61992: IFFALSE 61996
// continue ;
61994: GO 61950
// busy := false ;
61996: LD_ADDR_VAR 0 8
62000: PUSH
62001: LD_INT 0
62003: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62004: LD_ADDR_VAR 0 4
62008: PUSH
62009: LD_EXP 23
62013: PUSH
62014: LD_VAR 0 2
62018: ARRAY
62019: PPUSH
62020: LD_INT 30
62022: PUSH
62023: LD_INT 3
62025: PUSH
62026: EMPTY
62027: LIST
62028: LIST
62029: PPUSH
62030: CALL_OW 72
62034: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62035: LD_ADDR_VAR 0 6
62039: PUSH
62040: LD_EXP 31
62044: PUSH
62045: LD_VAR 0 2
62049: ARRAY
62050: PPUSH
62051: LD_INT 2
62053: PUSH
62054: LD_INT 30
62056: PUSH
62057: LD_INT 32
62059: PUSH
62060: EMPTY
62061: LIST
62062: LIST
62063: PUSH
62064: LD_INT 30
62066: PUSH
62067: LD_INT 33
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: PUSH
62074: EMPTY
62075: LIST
62076: LIST
62077: LIST
62078: PPUSH
62079: CALL_OW 72
62083: ST_TO_ADDR
// if not t then
62084: LD_VAR 0 6
62088: NOT
62089: IFFALSE 62093
// continue ;
62091: GO 61950
// for j in tmp do
62093: LD_ADDR_VAR 0 3
62097: PUSH
62098: LD_VAR 0 4
62102: PUSH
62103: FOR_IN
62104: IFFALSE 62134
// if not BuildingStatus ( j ) = bs_idle then
62106: LD_VAR 0 3
62110: PPUSH
62111: CALL_OW 461
62115: PUSH
62116: LD_INT 2
62118: EQUAL
62119: NOT
62120: IFFALSE 62132
// begin busy := true ;
62122: LD_ADDR_VAR 0 8
62126: PUSH
62127: LD_INT 1
62129: ST_TO_ADDR
// break ;
62130: GO 62134
// end ;
62132: GO 62103
62134: POP
62135: POP
// if busy then
62136: LD_VAR 0 8
62140: IFFALSE 62144
// continue ;
62142: GO 61950
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62144: LD_ADDR_VAR 0 7
62148: PUSH
62149: LD_VAR 0 6
62153: PPUSH
62154: LD_INT 35
62156: PUSH
62157: LD_INT 0
62159: PUSH
62160: EMPTY
62161: LIST
62162: LIST
62163: PPUSH
62164: CALL_OW 72
62168: ST_TO_ADDR
// if tw then
62169: LD_VAR 0 7
62173: IFFALSE 62250
// begin tw := tw [ 1 ] ;
62175: LD_ADDR_VAR 0 7
62179: PUSH
62180: LD_VAR 0 7
62184: PUSH
62185: LD_INT 1
62187: ARRAY
62188: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62189: LD_ADDR_VAR 0 9
62193: PUSH
62194: LD_VAR 0 7
62198: PPUSH
62199: LD_EXP 48
62203: PUSH
62204: LD_VAR 0 2
62208: ARRAY
62209: PPUSH
62210: CALL 21000 0 2
62214: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62215: LD_EXP 62
62219: PUSH
62220: LD_VAR 0 2
62224: ARRAY
62225: IFFALSE 62248
// if not weapon in mc_allowed_tower_weapons [ i ] then
62227: LD_VAR 0 9
62231: PUSH
62232: LD_EXP 62
62236: PUSH
62237: LD_VAR 0 2
62241: ARRAY
62242: IN
62243: NOT
62244: IFFALSE 62248
// continue ;
62246: GO 61950
// end else
62248: GO 62313
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62250: LD_ADDR_VAR 0 5
62254: PUSH
62255: LD_EXP 31
62259: PUSH
62260: LD_VAR 0 2
62264: ARRAY
62265: PPUSH
62266: LD_VAR 0 4
62270: PPUSH
62271: CALL 47289 0 2
62275: ST_TO_ADDR
// if not tmp2 then
62276: LD_VAR 0 5
62280: NOT
62281: IFFALSE 62285
// continue ;
62283: GO 61950
// tw := tmp2 [ 1 ] ;
62285: LD_ADDR_VAR 0 7
62289: PUSH
62290: LD_VAR 0 5
62294: PUSH
62295: LD_INT 1
62297: ARRAY
62298: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62299: LD_ADDR_VAR 0 9
62303: PUSH
62304: LD_VAR 0 5
62308: PUSH
62309: LD_INT 2
62311: ARRAY
62312: ST_TO_ADDR
// end ; if not weapon then
62313: LD_VAR 0 9
62317: NOT
62318: IFFALSE 62322
// continue ;
62320: GO 61950
// ComPlaceWeapon ( tw , weapon ) ;
62322: LD_VAR 0 7
62326: PPUSH
62327: LD_VAR 0 9
62331: PPUSH
62332: CALL_OW 148
// end ;
62336: GO 61950
62338: POP
62339: POP
// end ;
62340: LD_VAR 0 1
62344: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
62345: LD_INT 0
62347: PPUSH
62348: PPUSH
62349: PPUSH
62350: PPUSH
62351: PPUSH
62352: PPUSH
62353: PPUSH
// if not mc_bases then
62354: LD_EXP 23
62358: NOT
62359: IFFALSE 62363
// exit ;
62361: GO 63131
// for i = 1 to mc_bases do
62363: LD_ADDR_VAR 0 2
62367: PUSH
62368: DOUBLE
62369: LD_INT 1
62371: DEC
62372: ST_TO_ADDR
62373: LD_EXP 23
62377: PUSH
62378: FOR_TO
62379: IFFALSE 63129
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62381: LD_EXP 36
62385: PUSH
62386: LD_VAR 0 2
62390: ARRAY
62391: NOT
62392: PUSH
62393: LD_EXP 36
62397: PUSH
62398: LD_VAR 0 2
62402: ARRAY
62403: PUSH
62404: LD_EXP 37
62408: PUSH
62409: LD_VAR 0 2
62413: ARRAY
62414: EQUAL
62415: OR
62416: PUSH
62417: LD_EXP 46
62421: PUSH
62422: LD_VAR 0 2
62426: ARRAY
62427: OR
62428: IFFALSE 62432
// continue ;
62430: GO 62378
// if mc_miners [ i ] then
62432: LD_EXP 37
62436: PUSH
62437: LD_VAR 0 2
62441: ARRAY
62442: IFFALSE 62816
// begin for j = mc_miners [ i ] downto 1 do
62444: LD_ADDR_VAR 0 3
62448: PUSH
62449: DOUBLE
62450: LD_EXP 37
62454: PUSH
62455: LD_VAR 0 2
62459: ARRAY
62460: INC
62461: ST_TO_ADDR
62462: LD_INT 1
62464: PUSH
62465: FOR_DOWNTO
62466: IFFALSE 62814
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62468: LD_EXP 37
62472: PUSH
62473: LD_VAR 0 2
62477: ARRAY
62478: PUSH
62479: LD_VAR 0 3
62483: ARRAY
62484: PPUSH
62485: CALL_OW 301
62489: PUSH
62490: LD_EXP 37
62494: PUSH
62495: LD_VAR 0 2
62499: ARRAY
62500: PUSH
62501: LD_VAR 0 3
62505: ARRAY
62506: PPUSH
62507: CALL_OW 257
62511: PUSH
62512: LD_INT 1
62514: NONEQUAL
62515: OR
62516: IFFALSE 62579
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62518: LD_ADDR_VAR 0 5
62522: PUSH
62523: LD_EXP 37
62527: PUSH
62528: LD_VAR 0 2
62532: ARRAY
62533: PUSH
62534: LD_EXP 37
62538: PUSH
62539: LD_VAR 0 2
62543: ARRAY
62544: PUSH
62545: LD_VAR 0 3
62549: ARRAY
62550: DIFF
62551: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
62552: LD_ADDR_EXP 37
62556: PUSH
62557: LD_EXP 37
62561: PPUSH
62562: LD_VAR 0 2
62566: PPUSH
62567: LD_VAR 0 5
62571: PPUSH
62572: CALL_OW 1
62576: ST_TO_ADDR
// continue ;
62577: GO 62465
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
62579: LD_EXP 37
62583: PUSH
62584: LD_VAR 0 2
62588: ARRAY
62589: PUSH
62590: LD_VAR 0 3
62594: ARRAY
62595: PPUSH
62596: CALL_OW 257
62600: PUSH
62601: LD_INT 1
62603: EQUAL
62604: PUSH
62605: LD_EXP 37
62609: PUSH
62610: LD_VAR 0 2
62614: ARRAY
62615: PUSH
62616: LD_VAR 0 3
62620: ARRAY
62621: PPUSH
62622: CALL_OW 459
62626: NOT
62627: AND
62628: PUSH
62629: LD_EXP 37
62633: PUSH
62634: LD_VAR 0 2
62638: ARRAY
62639: PUSH
62640: LD_VAR 0 3
62644: ARRAY
62645: PPUSH
62646: CALL_OW 314
62650: NOT
62651: AND
62652: IFFALSE 62812
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
62654: LD_EXP 37
62658: PUSH
62659: LD_VAR 0 2
62663: ARRAY
62664: PUSH
62665: LD_VAR 0 3
62669: ARRAY
62670: PPUSH
62671: CALL_OW 310
62675: IFFALSE 62698
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
62677: LD_EXP 37
62681: PUSH
62682: LD_VAR 0 2
62686: ARRAY
62687: PUSH
62688: LD_VAR 0 3
62692: ARRAY
62693: PPUSH
62694: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
62698: LD_EXP 37
62702: PUSH
62703: LD_VAR 0 2
62707: ARRAY
62708: PUSH
62709: LD_VAR 0 3
62713: ARRAY
62714: PPUSH
62715: CALL_OW 314
62719: NOT
62720: IFFALSE 62812
// begin r := rand ( 1 , mc_mines [ i ] ) ;
62722: LD_ADDR_VAR 0 7
62726: PUSH
62727: LD_INT 1
62729: PPUSH
62730: LD_EXP 36
62734: PUSH
62735: LD_VAR 0 2
62739: ARRAY
62740: PPUSH
62741: CALL_OW 12
62745: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
62746: LD_EXP 37
62750: PUSH
62751: LD_VAR 0 2
62755: ARRAY
62756: PUSH
62757: LD_VAR 0 3
62761: ARRAY
62762: PPUSH
62763: LD_EXP 36
62767: PUSH
62768: LD_VAR 0 2
62772: ARRAY
62773: PUSH
62774: LD_VAR 0 7
62778: ARRAY
62779: PUSH
62780: LD_INT 1
62782: ARRAY
62783: PPUSH
62784: LD_EXP 36
62788: PUSH
62789: LD_VAR 0 2
62793: ARRAY
62794: PUSH
62795: LD_VAR 0 7
62799: ARRAY
62800: PUSH
62801: LD_INT 2
62803: ARRAY
62804: PPUSH
62805: LD_INT 0
62807: PPUSH
62808: CALL_OW 193
// end ; end ; end ;
62812: GO 62465
62814: POP
62815: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
62816: LD_ADDR_VAR 0 5
62820: PUSH
62821: LD_EXP 23
62825: PUSH
62826: LD_VAR 0 2
62830: ARRAY
62831: PPUSH
62832: LD_INT 2
62834: PUSH
62835: LD_INT 30
62837: PUSH
62838: LD_INT 4
62840: PUSH
62841: EMPTY
62842: LIST
62843: LIST
62844: PUSH
62845: LD_INT 30
62847: PUSH
62848: LD_INT 5
62850: PUSH
62851: EMPTY
62852: LIST
62853: LIST
62854: PUSH
62855: LD_INT 30
62857: PUSH
62858: LD_INT 32
62860: PUSH
62861: EMPTY
62862: LIST
62863: LIST
62864: PUSH
62865: EMPTY
62866: LIST
62867: LIST
62868: LIST
62869: LIST
62870: PPUSH
62871: CALL_OW 72
62875: ST_TO_ADDR
// if not tmp then
62876: LD_VAR 0 5
62880: NOT
62881: IFFALSE 62885
// continue ;
62883: GO 62378
// list := [ ] ;
62885: LD_ADDR_VAR 0 6
62889: PUSH
62890: EMPTY
62891: ST_TO_ADDR
// for j in tmp do
62892: LD_ADDR_VAR 0 3
62896: PUSH
62897: LD_VAR 0 5
62901: PUSH
62902: FOR_IN
62903: IFFALSE 62972
// begin for k in UnitsInside ( j ) do
62905: LD_ADDR_VAR 0 4
62909: PUSH
62910: LD_VAR 0 3
62914: PPUSH
62915: CALL_OW 313
62919: PUSH
62920: FOR_IN
62921: IFFALSE 62968
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
62923: LD_VAR 0 4
62927: PPUSH
62928: CALL_OW 257
62932: PUSH
62933: LD_INT 1
62935: EQUAL
62936: PUSH
62937: LD_VAR 0 4
62941: PPUSH
62942: CALL_OW 459
62946: NOT
62947: AND
62948: IFFALSE 62966
// list := list ^ k ;
62950: LD_ADDR_VAR 0 6
62954: PUSH
62955: LD_VAR 0 6
62959: PUSH
62960: LD_VAR 0 4
62964: ADD
62965: ST_TO_ADDR
62966: GO 62920
62968: POP
62969: POP
// end ;
62970: GO 62902
62972: POP
62973: POP
// list := list diff mc_miners [ i ] ;
62974: LD_ADDR_VAR 0 6
62978: PUSH
62979: LD_VAR 0 6
62983: PUSH
62984: LD_EXP 37
62988: PUSH
62989: LD_VAR 0 2
62993: ARRAY
62994: DIFF
62995: ST_TO_ADDR
// if not list then
62996: LD_VAR 0 6
63000: NOT
63001: IFFALSE 63005
// continue ;
63003: GO 62378
// k := mc_mines [ i ] - mc_miners [ i ] ;
63005: LD_ADDR_VAR 0 4
63009: PUSH
63010: LD_EXP 36
63014: PUSH
63015: LD_VAR 0 2
63019: ARRAY
63020: PUSH
63021: LD_EXP 37
63025: PUSH
63026: LD_VAR 0 2
63030: ARRAY
63031: MINUS
63032: ST_TO_ADDR
// if k > list then
63033: LD_VAR 0 4
63037: PUSH
63038: LD_VAR 0 6
63042: GREATER
63043: IFFALSE 63055
// k := list ;
63045: LD_ADDR_VAR 0 4
63049: PUSH
63050: LD_VAR 0 6
63054: ST_TO_ADDR
// for j = 1 to k do
63055: LD_ADDR_VAR 0 3
63059: PUSH
63060: DOUBLE
63061: LD_INT 1
63063: DEC
63064: ST_TO_ADDR
63065: LD_VAR 0 4
63069: PUSH
63070: FOR_TO
63071: IFFALSE 63125
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63073: LD_ADDR_EXP 37
63077: PUSH
63078: LD_EXP 37
63082: PPUSH
63083: LD_VAR 0 2
63087: PUSH
63088: LD_EXP 37
63092: PUSH
63093: LD_VAR 0 2
63097: ARRAY
63098: PUSH
63099: LD_INT 1
63101: PLUS
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: PPUSH
63107: LD_VAR 0 6
63111: PUSH
63112: LD_VAR 0 3
63116: ARRAY
63117: PPUSH
63118: CALL 15990 0 3
63122: ST_TO_ADDR
63123: GO 63070
63125: POP
63126: POP
// end ;
63127: GO 62378
63129: POP
63130: POP
// end ;
63131: LD_VAR 0 1
63135: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
63136: LD_INT 0
63138: PPUSH
63139: PPUSH
63140: PPUSH
63141: PPUSH
63142: PPUSH
63143: PPUSH
63144: PPUSH
63145: PPUSH
63146: PPUSH
63147: PPUSH
63148: PPUSH
// if not mc_bases then
63149: LD_EXP 23
63153: NOT
63154: IFFALSE 63158
// exit ;
63156: GO 64981
// for i = 1 to mc_bases do
63158: LD_ADDR_VAR 0 2
63162: PUSH
63163: DOUBLE
63164: LD_INT 1
63166: DEC
63167: ST_TO_ADDR
63168: LD_EXP 23
63172: PUSH
63173: FOR_TO
63174: IFFALSE 64979
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63176: LD_EXP 23
63180: PUSH
63181: LD_VAR 0 2
63185: ARRAY
63186: NOT
63187: PUSH
63188: LD_EXP 30
63192: PUSH
63193: LD_VAR 0 2
63197: ARRAY
63198: OR
63199: IFFALSE 63203
// continue ;
63201: GO 63173
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63203: LD_EXP 39
63207: PUSH
63208: LD_VAR 0 2
63212: ARRAY
63213: NOT
63214: PUSH
63215: LD_EXP 40
63219: PUSH
63220: LD_VAR 0 2
63224: ARRAY
63225: AND
63226: IFFALSE 63264
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63228: LD_ADDR_EXP 40
63232: PUSH
63233: LD_EXP 40
63237: PPUSH
63238: LD_VAR 0 2
63242: PPUSH
63243: EMPTY
63244: PPUSH
63245: CALL_OW 1
63249: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63250: LD_VAR 0 2
63254: PPUSH
63255: LD_INT 107
63257: PPUSH
63258: CALL 54032 0 2
// continue ;
63262: GO 63173
// end ; target := [ ] ;
63264: LD_ADDR_VAR 0 7
63268: PUSH
63269: EMPTY
63270: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
63271: LD_ADDR_VAR 0 6
63275: PUSH
63276: LD_EXP 23
63280: PUSH
63281: LD_VAR 0 2
63285: ARRAY
63286: PUSH
63287: LD_INT 1
63289: ARRAY
63290: PPUSH
63291: CALL_OW 255
63295: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63296: LD_ADDR_VAR 0 9
63300: PUSH
63301: LD_EXP 23
63305: PUSH
63306: LD_VAR 0 2
63310: ARRAY
63311: PPUSH
63312: LD_INT 2
63314: PUSH
63315: LD_INT 30
63317: PUSH
63318: LD_INT 0
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PUSH
63325: LD_INT 30
63327: PUSH
63328: LD_INT 1
63330: PUSH
63331: EMPTY
63332: LIST
63333: LIST
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: LIST
63339: PPUSH
63340: CALL_OW 72
63344: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63345: LD_ADDR_VAR 0 3
63349: PUSH
63350: DOUBLE
63351: LD_EXP 39
63355: PUSH
63356: LD_VAR 0 2
63360: ARRAY
63361: INC
63362: ST_TO_ADDR
63363: LD_INT 1
63365: PUSH
63366: FOR_DOWNTO
63367: IFFALSE 63612
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63369: LD_EXP 39
63373: PUSH
63374: LD_VAR 0 2
63378: ARRAY
63379: PUSH
63380: LD_VAR 0 3
63384: ARRAY
63385: PUSH
63386: LD_INT 2
63388: ARRAY
63389: PPUSH
63390: LD_EXP 39
63394: PUSH
63395: LD_VAR 0 2
63399: ARRAY
63400: PUSH
63401: LD_VAR 0 3
63405: ARRAY
63406: PUSH
63407: LD_INT 3
63409: ARRAY
63410: PPUSH
63411: CALL_OW 488
63415: PUSH
63416: LD_EXP 39
63420: PUSH
63421: LD_VAR 0 2
63425: ARRAY
63426: PUSH
63427: LD_VAR 0 3
63431: ARRAY
63432: PUSH
63433: LD_INT 2
63435: ARRAY
63436: PPUSH
63437: LD_EXP 39
63441: PUSH
63442: LD_VAR 0 2
63446: ARRAY
63447: PUSH
63448: LD_VAR 0 3
63452: ARRAY
63453: PUSH
63454: LD_INT 3
63456: ARRAY
63457: PPUSH
63458: CALL_OW 284
63462: PUSH
63463: LD_INT 0
63465: EQUAL
63466: AND
63467: IFFALSE 63522
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63469: LD_ADDR_VAR 0 5
63473: PUSH
63474: LD_EXP 39
63478: PUSH
63479: LD_VAR 0 2
63483: ARRAY
63484: PPUSH
63485: LD_VAR 0 3
63489: PPUSH
63490: CALL_OW 3
63494: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63495: LD_ADDR_EXP 39
63499: PUSH
63500: LD_EXP 39
63504: PPUSH
63505: LD_VAR 0 2
63509: PPUSH
63510: LD_VAR 0 5
63514: PPUSH
63515: CALL_OW 1
63519: ST_TO_ADDR
// continue ;
63520: GO 63366
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63522: LD_VAR 0 6
63526: PPUSH
63527: LD_EXP 39
63531: PUSH
63532: LD_VAR 0 2
63536: ARRAY
63537: PUSH
63538: LD_VAR 0 3
63542: ARRAY
63543: PUSH
63544: LD_INT 2
63546: ARRAY
63547: PPUSH
63548: LD_EXP 39
63552: PUSH
63553: LD_VAR 0 2
63557: ARRAY
63558: PUSH
63559: LD_VAR 0 3
63563: ARRAY
63564: PUSH
63565: LD_INT 3
63567: ARRAY
63568: PPUSH
63569: LD_INT 30
63571: PPUSH
63572: CALL 16886 0 4
63576: PUSH
63577: LD_INT 4
63579: ARRAY
63580: PUSH
63581: LD_INT 0
63583: EQUAL
63584: IFFALSE 63610
// begin target := mc_crates [ i ] [ j ] ;
63586: LD_ADDR_VAR 0 7
63590: PUSH
63591: LD_EXP 39
63595: PUSH
63596: LD_VAR 0 2
63600: ARRAY
63601: PUSH
63602: LD_VAR 0 3
63606: ARRAY
63607: ST_TO_ADDR
// break ;
63608: GO 63612
// end ; end ;
63610: GO 63366
63612: POP
63613: POP
// if not target then
63614: LD_VAR 0 7
63618: NOT
63619: IFFALSE 63623
// continue ;
63621: GO 63173
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
63623: LD_ADDR_VAR 0 8
63627: PUSH
63628: LD_EXP 42
63632: PUSH
63633: LD_VAR 0 2
63637: ARRAY
63638: PPUSH
63639: LD_INT 2
63641: PUSH
63642: LD_INT 3
63644: PUSH
63645: LD_INT 58
63647: PUSH
63648: EMPTY
63649: LIST
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: LD_INT 61
63657: PUSH
63658: EMPTY
63659: LIST
63660: PUSH
63661: LD_INT 33
63663: PUSH
63664: LD_INT 5
63666: PUSH
63667: EMPTY
63668: LIST
63669: LIST
63670: PUSH
63671: LD_INT 33
63673: PUSH
63674: LD_INT 3
63676: PUSH
63677: EMPTY
63678: LIST
63679: LIST
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: LIST
63685: LIST
63686: LIST
63687: PUSH
63688: LD_INT 2
63690: PUSH
63691: LD_INT 34
63693: PUSH
63694: LD_INT 32
63696: PUSH
63697: EMPTY
63698: LIST
63699: LIST
63700: PUSH
63701: LD_INT 34
63703: PUSH
63704: LD_INT 51
63706: PUSH
63707: EMPTY
63708: LIST
63709: LIST
63710: PUSH
63711: LD_INT 34
63713: PUSH
63714: LD_INT 12
63716: PUSH
63717: EMPTY
63718: LIST
63719: LIST
63720: PUSH
63721: EMPTY
63722: LIST
63723: LIST
63724: LIST
63725: LIST
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PPUSH
63731: CALL_OW 72
63735: ST_TO_ADDR
// if not cargo then
63736: LD_VAR 0 8
63740: NOT
63741: IFFALSE 64447
// begin if mc_crates_collector [ i ] < 5 then
63743: LD_EXP 40
63747: PUSH
63748: LD_VAR 0 2
63752: ARRAY
63753: PUSH
63754: LD_INT 5
63756: LESS
63757: IFFALSE 64123
// begin if mc_ape [ i ] then
63759: LD_EXP 52
63763: PUSH
63764: LD_VAR 0 2
63768: ARRAY
63769: IFFALSE 63816
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
63771: LD_ADDR_VAR 0 5
63775: PUSH
63776: LD_EXP 52
63780: PUSH
63781: LD_VAR 0 2
63785: ARRAY
63786: PPUSH
63787: LD_INT 25
63789: PUSH
63790: LD_INT 16
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 24
63799: PUSH
63800: LD_INT 750
63802: PUSH
63803: EMPTY
63804: LIST
63805: LIST
63806: PUSH
63807: EMPTY
63808: LIST
63809: LIST
63810: PPUSH
63811: CALL_OW 72
63815: ST_TO_ADDR
// if not tmp then
63816: LD_VAR 0 5
63820: NOT
63821: IFFALSE 63868
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
63823: LD_ADDR_VAR 0 5
63827: PUSH
63828: LD_EXP 23
63832: PUSH
63833: LD_VAR 0 2
63837: ARRAY
63838: PPUSH
63839: LD_INT 25
63841: PUSH
63842: LD_INT 2
63844: PUSH
63845: EMPTY
63846: LIST
63847: LIST
63848: PUSH
63849: LD_INT 24
63851: PUSH
63852: LD_INT 750
63854: PUSH
63855: EMPTY
63856: LIST
63857: LIST
63858: PUSH
63859: EMPTY
63860: LIST
63861: LIST
63862: PPUSH
63863: CALL_OW 72
63867: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
63868: LD_EXP 52
63872: PUSH
63873: LD_VAR 0 2
63877: ARRAY
63878: PUSH
63879: LD_EXP 23
63883: PUSH
63884: LD_VAR 0 2
63888: ARRAY
63889: PPUSH
63890: LD_INT 25
63892: PUSH
63893: LD_INT 2
63895: PUSH
63896: EMPTY
63897: LIST
63898: LIST
63899: PUSH
63900: LD_INT 24
63902: PUSH
63903: LD_INT 750
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PUSH
63910: EMPTY
63911: LIST
63912: LIST
63913: PPUSH
63914: CALL_OW 72
63918: AND
63919: PUSH
63920: LD_VAR 0 5
63924: PUSH
63925: LD_INT 5
63927: LESS
63928: AND
63929: IFFALSE 64011
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
63931: LD_ADDR_VAR 0 3
63935: PUSH
63936: LD_EXP 23
63940: PUSH
63941: LD_VAR 0 2
63945: ARRAY
63946: PPUSH
63947: LD_INT 25
63949: PUSH
63950: LD_INT 2
63952: PUSH
63953: EMPTY
63954: LIST
63955: LIST
63956: PUSH
63957: LD_INT 24
63959: PUSH
63960: LD_INT 750
63962: PUSH
63963: EMPTY
63964: LIST
63965: LIST
63966: PUSH
63967: EMPTY
63968: LIST
63969: LIST
63970: PPUSH
63971: CALL_OW 72
63975: PUSH
63976: FOR_IN
63977: IFFALSE 64009
// begin tmp := tmp union j ;
63979: LD_ADDR_VAR 0 5
63983: PUSH
63984: LD_VAR 0 5
63988: PUSH
63989: LD_VAR 0 3
63993: UNION
63994: ST_TO_ADDR
// if tmp >= 5 then
63995: LD_VAR 0 5
63999: PUSH
64000: LD_INT 5
64002: GREATEREQUAL
64003: IFFALSE 64007
// break ;
64005: GO 64009
// end ;
64007: GO 63976
64009: POP
64010: POP
// end ; if not tmp then
64011: LD_VAR 0 5
64015: NOT
64016: IFFALSE 64020
// continue ;
64018: GO 63173
// for j in tmp do
64020: LD_ADDR_VAR 0 3
64024: PUSH
64025: LD_VAR 0 5
64029: PUSH
64030: FOR_IN
64031: IFFALSE 64121
// if not GetTag ( j ) then
64033: LD_VAR 0 3
64037: PPUSH
64038: CALL_OW 110
64042: NOT
64043: IFFALSE 64119
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64045: LD_ADDR_EXP 40
64049: PUSH
64050: LD_EXP 40
64054: PPUSH
64055: LD_VAR 0 2
64059: PUSH
64060: LD_EXP 40
64064: PUSH
64065: LD_VAR 0 2
64069: ARRAY
64070: PUSH
64071: LD_INT 1
64073: PLUS
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PPUSH
64079: LD_VAR 0 3
64083: PPUSH
64084: CALL 15990 0 3
64088: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64089: LD_VAR 0 3
64093: PPUSH
64094: LD_INT 107
64096: PPUSH
64097: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64101: LD_EXP 40
64105: PUSH
64106: LD_VAR 0 2
64110: ARRAY
64111: PUSH
64112: LD_INT 5
64114: GREATEREQUAL
64115: IFFALSE 64119
// break ;
64117: GO 64121
// end ;
64119: GO 64030
64121: POP
64122: POP
// end ; if mc_crates_collector [ i ] and target then
64123: LD_EXP 40
64127: PUSH
64128: LD_VAR 0 2
64132: ARRAY
64133: PUSH
64134: LD_VAR 0 7
64138: AND
64139: IFFALSE 64445
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64141: LD_EXP 40
64145: PUSH
64146: LD_VAR 0 2
64150: ARRAY
64151: PUSH
64152: LD_VAR 0 7
64156: PUSH
64157: LD_INT 1
64159: ARRAY
64160: LESS
64161: IFFALSE 64181
// tmp := mc_crates_collector [ i ] else
64163: LD_ADDR_VAR 0 5
64167: PUSH
64168: LD_EXP 40
64172: PUSH
64173: LD_VAR 0 2
64177: ARRAY
64178: ST_TO_ADDR
64179: GO 64195
// tmp := target [ 1 ] ;
64181: LD_ADDR_VAR 0 5
64185: PUSH
64186: LD_VAR 0 7
64190: PUSH
64191: LD_INT 1
64193: ARRAY
64194: ST_TO_ADDR
// k := 0 ;
64195: LD_ADDR_VAR 0 4
64199: PUSH
64200: LD_INT 0
64202: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64203: LD_ADDR_VAR 0 3
64207: PUSH
64208: LD_EXP 40
64212: PUSH
64213: LD_VAR 0 2
64217: ARRAY
64218: PUSH
64219: FOR_IN
64220: IFFALSE 64443
// begin k := k + 1 ;
64222: LD_ADDR_VAR 0 4
64226: PUSH
64227: LD_VAR 0 4
64231: PUSH
64232: LD_INT 1
64234: PLUS
64235: ST_TO_ADDR
// if k > tmp then
64236: LD_VAR 0 4
64240: PUSH
64241: LD_VAR 0 5
64245: GREATER
64246: IFFALSE 64250
// break ;
64248: GO 64443
// if not GetClass ( j ) in [ 2 , 16 ] then
64250: LD_VAR 0 3
64254: PPUSH
64255: CALL_OW 257
64259: PUSH
64260: LD_INT 2
64262: PUSH
64263: LD_INT 16
64265: PUSH
64266: EMPTY
64267: LIST
64268: LIST
64269: IN
64270: NOT
64271: IFFALSE 64324
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64273: LD_ADDR_EXP 40
64277: PUSH
64278: LD_EXP 40
64282: PPUSH
64283: LD_VAR 0 2
64287: PPUSH
64288: LD_EXP 40
64292: PUSH
64293: LD_VAR 0 2
64297: ARRAY
64298: PUSH
64299: LD_VAR 0 3
64303: DIFF
64304: PPUSH
64305: CALL_OW 1
64309: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64310: LD_VAR 0 3
64314: PPUSH
64315: LD_INT 0
64317: PPUSH
64318: CALL_OW 109
// continue ;
64322: GO 64219
// end ; if IsInUnit ( j ) then
64324: LD_VAR 0 3
64328: PPUSH
64329: CALL_OW 310
64333: IFFALSE 64344
// ComExitBuilding ( j ) ;
64335: LD_VAR 0 3
64339: PPUSH
64340: CALL_OW 122
// wait ( 3 ) ;
64344: LD_INT 3
64346: PPUSH
64347: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
64351: LD_VAR 0 3
64355: PPUSH
64356: CALL_OW 314
64360: PUSH
64361: LD_VAR 0 6
64365: PPUSH
64366: LD_VAR 0 7
64370: PUSH
64371: LD_INT 2
64373: ARRAY
64374: PPUSH
64375: LD_VAR 0 7
64379: PUSH
64380: LD_INT 3
64382: ARRAY
64383: PPUSH
64384: LD_INT 30
64386: PPUSH
64387: CALL 16886 0 4
64391: PUSH
64392: LD_INT 4
64394: ARRAY
64395: AND
64396: IFFALSE 64414
// ComStandNearbyBuilding ( j , depot ) else
64398: LD_VAR 0 3
64402: PPUSH
64403: LD_VAR 0 9
64407: PPUSH
64408: CALL 12568 0 2
64412: GO 64441
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64414: LD_VAR 0 3
64418: PPUSH
64419: LD_VAR 0 7
64423: PUSH
64424: LD_INT 2
64426: ARRAY
64427: PPUSH
64428: LD_VAR 0 7
64432: PUSH
64433: LD_INT 3
64435: ARRAY
64436: PPUSH
64437: CALL_OW 117
// end ;
64441: GO 64219
64443: POP
64444: POP
// end ; end else
64445: GO 64977
// begin for j in cargo do
64447: LD_ADDR_VAR 0 3
64451: PUSH
64452: LD_VAR 0 8
64456: PUSH
64457: FOR_IN
64458: IFFALSE 64975
// begin if GetTag ( j ) <> 0 then
64460: LD_VAR 0 3
64464: PPUSH
64465: CALL_OW 110
64469: PUSH
64470: LD_INT 0
64472: NONEQUAL
64473: IFFALSE 64477
// continue ;
64475: GO 64457
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64477: LD_VAR 0 3
64481: PPUSH
64482: CALL_OW 256
64486: PUSH
64487: LD_INT 1000
64489: LESS
64490: PUSH
64491: LD_VAR 0 3
64495: PPUSH
64496: LD_EXP 47
64500: PUSH
64501: LD_VAR 0 2
64505: ARRAY
64506: PPUSH
64507: CALL_OW 308
64511: NOT
64512: AND
64513: IFFALSE 64535
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64515: LD_VAR 0 3
64519: PPUSH
64520: LD_EXP 47
64524: PUSH
64525: LD_VAR 0 2
64529: ARRAY
64530: PPUSH
64531: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64535: LD_VAR 0 3
64539: PPUSH
64540: CALL_OW 256
64544: PUSH
64545: LD_INT 1000
64547: LESS
64548: PUSH
64549: LD_VAR 0 3
64553: PPUSH
64554: LD_EXP 47
64558: PUSH
64559: LD_VAR 0 2
64563: ARRAY
64564: PPUSH
64565: CALL_OW 308
64569: AND
64570: IFFALSE 64574
// continue ;
64572: GO 64457
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64574: LD_VAR 0 3
64578: PPUSH
64579: CALL_OW 262
64583: PUSH
64584: LD_INT 2
64586: EQUAL
64587: PUSH
64588: LD_VAR 0 3
64592: PPUSH
64593: CALL_OW 261
64597: PUSH
64598: LD_INT 15
64600: LESS
64601: AND
64602: IFFALSE 64606
// continue ;
64604: GO 64457
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64606: LD_VAR 0 3
64610: PPUSH
64611: CALL_OW 262
64615: PUSH
64616: LD_INT 1
64618: EQUAL
64619: PUSH
64620: LD_VAR 0 3
64624: PPUSH
64625: CALL_OW 261
64629: PUSH
64630: LD_INT 10
64632: LESS
64633: AND
64634: IFFALSE 64914
// begin if not depot then
64636: LD_VAR 0 9
64640: NOT
64641: IFFALSE 64645
// continue ;
64643: GO 64457
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
64645: LD_VAR 0 3
64649: PPUSH
64650: LD_VAR 0 9
64654: PPUSH
64655: LD_VAR 0 3
64659: PPUSH
64660: CALL_OW 74
64664: PPUSH
64665: CALL_OW 296
64669: PUSH
64670: LD_INT 6
64672: LESS
64673: IFFALSE 64689
// SetFuel ( j , 100 ) else
64675: LD_VAR 0 3
64679: PPUSH
64680: LD_INT 100
64682: PPUSH
64683: CALL_OW 240
64687: GO 64914
// if GetFuel ( j ) = 0 then
64689: LD_VAR 0 3
64693: PPUSH
64694: CALL_OW 261
64698: PUSH
64699: LD_INT 0
64701: EQUAL
64702: IFFALSE 64914
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
64704: LD_ADDR_EXP 42
64708: PUSH
64709: LD_EXP 42
64713: PPUSH
64714: LD_VAR 0 2
64718: PPUSH
64719: LD_EXP 42
64723: PUSH
64724: LD_VAR 0 2
64728: ARRAY
64729: PUSH
64730: LD_VAR 0 3
64734: DIFF
64735: PPUSH
64736: CALL_OW 1
64740: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
64741: LD_VAR 0 3
64745: PPUSH
64746: CALL_OW 263
64750: PUSH
64751: LD_INT 1
64753: EQUAL
64754: IFFALSE 64770
// ComExitVehicle ( IsInUnit ( j ) ) ;
64756: LD_VAR 0 3
64760: PPUSH
64761: CALL_OW 310
64765: PPUSH
64766: CALL_OW 121
// if GetControl ( j ) = control_remote then
64770: LD_VAR 0 3
64774: PPUSH
64775: CALL_OW 263
64779: PUSH
64780: LD_INT 2
64782: EQUAL
64783: IFFALSE 64794
// ComUnlink ( j ) ;
64785: LD_VAR 0 3
64789: PPUSH
64790: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
64794: LD_ADDR_VAR 0 10
64798: PUSH
64799: LD_VAR 0 2
64803: PPUSH
64804: LD_INT 3
64806: PPUSH
64807: CALL 74406 0 2
64811: ST_TO_ADDR
// if fac then
64812: LD_VAR 0 10
64816: IFFALSE 64912
// begin for k in fac do
64818: LD_ADDR_VAR 0 4
64822: PUSH
64823: LD_VAR 0 10
64827: PUSH
64828: FOR_IN
64829: IFFALSE 64910
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
64831: LD_ADDR_VAR 0 11
64835: PUSH
64836: LD_VAR 0 10
64840: PPUSH
64841: LD_VAR 0 3
64845: PPUSH
64846: CALL_OW 265
64850: PPUSH
64851: LD_VAR 0 3
64855: PPUSH
64856: CALL_OW 262
64860: PPUSH
64861: LD_VAR 0 3
64865: PPUSH
64866: CALL_OW 263
64870: PPUSH
64871: LD_VAR 0 3
64875: PPUSH
64876: CALL_OW 264
64880: PPUSH
64881: CALL 13486 0 5
64885: ST_TO_ADDR
// if components then
64886: LD_VAR 0 11
64890: IFFALSE 64908
// begin MC_InsertProduceList ( i , components ) ;
64892: LD_VAR 0 2
64896: PPUSH
64897: LD_VAR 0 11
64901: PPUSH
64902: CALL 73951 0 2
// break ;
64906: GO 64910
// end ; end ;
64908: GO 64828
64910: POP
64911: POP
// end ; continue ;
64912: GO 64457
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
64914: LD_VAR 0 3
64918: PPUSH
64919: LD_INT 1
64921: PPUSH
64922: CALL_OW 289
64926: PUSH
64927: LD_INT 100
64929: LESS
64930: PUSH
64931: LD_VAR 0 3
64935: PPUSH
64936: CALL_OW 314
64940: NOT
64941: AND
64942: IFFALSE 64971
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64944: LD_VAR 0 3
64948: PPUSH
64949: LD_VAR 0 7
64953: PUSH
64954: LD_INT 2
64956: ARRAY
64957: PPUSH
64958: LD_VAR 0 7
64962: PUSH
64963: LD_INT 3
64965: ARRAY
64966: PPUSH
64967: CALL_OW 117
// break ;
64971: GO 64975
// end ;
64973: GO 64457
64975: POP
64976: POP
// end ; end ;
64977: GO 63173
64979: POP
64980: POP
// end ;
64981: LD_VAR 0 1
64985: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
64986: LD_INT 0
64988: PPUSH
64989: PPUSH
64990: PPUSH
64991: PPUSH
// if not mc_bases then
64992: LD_EXP 23
64996: NOT
64997: IFFALSE 65001
// exit ;
64999: GO 65162
// for i = 1 to mc_bases do
65001: LD_ADDR_VAR 0 2
65005: PUSH
65006: DOUBLE
65007: LD_INT 1
65009: DEC
65010: ST_TO_ADDR
65011: LD_EXP 23
65015: PUSH
65016: FOR_TO
65017: IFFALSE 65160
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65019: LD_ADDR_VAR 0 4
65023: PUSH
65024: LD_EXP 42
65028: PUSH
65029: LD_VAR 0 2
65033: ARRAY
65034: PUSH
65035: LD_EXP 45
65039: PUSH
65040: LD_VAR 0 2
65044: ARRAY
65045: UNION
65046: PPUSH
65047: LD_INT 33
65049: PUSH
65050: LD_INT 2
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PPUSH
65057: CALL_OW 72
65061: ST_TO_ADDR
// if tmp then
65062: LD_VAR 0 4
65066: IFFALSE 65158
// for j in tmp do
65068: LD_ADDR_VAR 0 3
65072: PUSH
65073: LD_VAR 0 4
65077: PUSH
65078: FOR_IN
65079: IFFALSE 65156
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65081: LD_VAR 0 3
65085: PPUSH
65086: CALL_OW 312
65090: NOT
65091: PUSH
65092: LD_VAR 0 3
65096: PPUSH
65097: CALL_OW 256
65101: PUSH
65102: LD_INT 250
65104: GREATEREQUAL
65105: AND
65106: IFFALSE 65119
// Connect ( j ) else
65108: LD_VAR 0 3
65112: PPUSH
65113: CALL 18961 0 1
65117: GO 65154
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65119: LD_VAR 0 3
65123: PPUSH
65124: CALL_OW 256
65128: PUSH
65129: LD_INT 250
65131: LESS
65132: PUSH
65133: LD_VAR 0 3
65137: PPUSH
65138: CALL_OW 312
65142: AND
65143: IFFALSE 65154
// ComUnlink ( j ) ;
65145: LD_VAR 0 3
65149: PPUSH
65150: CALL_OW 136
65154: GO 65078
65156: POP
65157: POP
// end ;
65158: GO 65016
65160: POP
65161: POP
// end ;
65162: LD_VAR 0 1
65166: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65167: LD_INT 0
65169: PPUSH
65170: PPUSH
65171: PPUSH
65172: PPUSH
65173: PPUSH
// if not mc_bases then
65174: LD_EXP 23
65178: NOT
65179: IFFALSE 65183
// exit ;
65181: GO 65628
// for i = 1 to mc_bases do
65183: LD_ADDR_VAR 0 2
65187: PUSH
65188: DOUBLE
65189: LD_INT 1
65191: DEC
65192: ST_TO_ADDR
65193: LD_EXP 23
65197: PUSH
65198: FOR_TO
65199: IFFALSE 65626
// begin if not mc_produce [ i ] then
65201: LD_EXP 44
65205: PUSH
65206: LD_VAR 0 2
65210: ARRAY
65211: NOT
65212: IFFALSE 65216
// continue ;
65214: GO 65198
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65216: LD_ADDR_VAR 0 5
65220: PUSH
65221: LD_EXP 23
65225: PUSH
65226: LD_VAR 0 2
65230: ARRAY
65231: PPUSH
65232: LD_INT 30
65234: PUSH
65235: LD_INT 3
65237: PUSH
65238: EMPTY
65239: LIST
65240: LIST
65241: PPUSH
65242: CALL_OW 72
65246: ST_TO_ADDR
// if not fac then
65247: LD_VAR 0 5
65251: NOT
65252: IFFALSE 65256
// continue ;
65254: GO 65198
// for j in fac do
65256: LD_ADDR_VAR 0 3
65260: PUSH
65261: LD_VAR 0 5
65265: PUSH
65266: FOR_IN
65267: IFFALSE 65622
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65269: LD_VAR 0 3
65273: PPUSH
65274: CALL_OW 461
65278: PUSH
65279: LD_INT 2
65281: NONEQUAL
65282: PUSH
65283: LD_VAR 0 3
65287: PPUSH
65288: LD_INT 15
65290: PPUSH
65291: CALL 18589 0 2
65295: PUSH
65296: LD_INT 4
65298: ARRAY
65299: OR
65300: IFFALSE 65304
// continue ;
65302: GO 65266
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65304: LD_VAR 0 3
65308: PPUSH
65309: LD_EXP 44
65313: PUSH
65314: LD_VAR 0 2
65318: ARRAY
65319: PUSH
65320: LD_INT 1
65322: ARRAY
65323: PUSH
65324: LD_INT 1
65326: ARRAY
65327: PPUSH
65328: LD_EXP 44
65332: PUSH
65333: LD_VAR 0 2
65337: ARRAY
65338: PUSH
65339: LD_INT 1
65341: ARRAY
65342: PUSH
65343: LD_INT 2
65345: ARRAY
65346: PPUSH
65347: LD_EXP 44
65351: PUSH
65352: LD_VAR 0 2
65356: ARRAY
65357: PUSH
65358: LD_INT 1
65360: ARRAY
65361: PUSH
65362: LD_INT 3
65364: ARRAY
65365: PPUSH
65366: LD_EXP 44
65370: PUSH
65371: LD_VAR 0 2
65375: ARRAY
65376: PUSH
65377: LD_INT 1
65379: ARRAY
65380: PUSH
65381: LD_INT 4
65383: ARRAY
65384: PPUSH
65385: CALL_OW 448
65389: PUSH
65390: LD_VAR 0 3
65394: PPUSH
65395: LD_EXP 44
65399: PUSH
65400: LD_VAR 0 2
65404: ARRAY
65405: PUSH
65406: LD_INT 1
65408: ARRAY
65409: PUSH
65410: LD_INT 1
65412: ARRAY
65413: PUSH
65414: LD_EXP 44
65418: PUSH
65419: LD_VAR 0 2
65423: ARRAY
65424: PUSH
65425: LD_INT 1
65427: ARRAY
65428: PUSH
65429: LD_INT 2
65431: ARRAY
65432: PUSH
65433: LD_EXP 44
65437: PUSH
65438: LD_VAR 0 2
65442: ARRAY
65443: PUSH
65444: LD_INT 1
65446: ARRAY
65447: PUSH
65448: LD_INT 3
65450: ARRAY
65451: PUSH
65452: LD_EXP 44
65456: PUSH
65457: LD_VAR 0 2
65461: ARRAY
65462: PUSH
65463: LD_INT 1
65465: ARRAY
65466: PUSH
65467: LD_INT 4
65469: ARRAY
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: LIST
65475: LIST
65476: PPUSH
65477: CALL 22356 0 2
65481: AND
65482: IFFALSE 65620
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65484: LD_VAR 0 3
65488: PPUSH
65489: LD_EXP 44
65493: PUSH
65494: LD_VAR 0 2
65498: ARRAY
65499: PUSH
65500: LD_INT 1
65502: ARRAY
65503: PUSH
65504: LD_INT 1
65506: ARRAY
65507: PPUSH
65508: LD_EXP 44
65512: PUSH
65513: LD_VAR 0 2
65517: ARRAY
65518: PUSH
65519: LD_INT 1
65521: ARRAY
65522: PUSH
65523: LD_INT 2
65525: ARRAY
65526: PPUSH
65527: LD_EXP 44
65531: PUSH
65532: LD_VAR 0 2
65536: ARRAY
65537: PUSH
65538: LD_INT 1
65540: ARRAY
65541: PUSH
65542: LD_INT 3
65544: ARRAY
65545: PPUSH
65546: LD_EXP 44
65550: PUSH
65551: LD_VAR 0 2
65555: ARRAY
65556: PUSH
65557: LD_INT 1
65559: ARRAY
65560: PUSH
65561: LD_INT 4
65563: ARRAY
65564: PPUSH
65565: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65569: LD_ADDR_VAR 0 4
65573: PUSH
65574: LD_EXP 44
65578: PUSH
65579: LD_VAR 0 2
65583: ARRAY
65584: PPUSH
65585: LD_INT 1
65587: PPUSH
65588: CALL_OW 3
65592: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65593: LD_ADDR_EXP 44
65597: PUSH
65598: LD_EXP 44
65602: PPUSH
65603: LD_VAR 0 2
65607: PPUSH
65608: LD_VAR 0 4
65612: PPUSH
65613: CALL_OW 1
65617: ST_TO_ADDR
// break ;
65618: GO 65622
// end ; end ;
65620: GO 65266
65622: POP
65623: POP
// end ;
65624: GO 65198
65626: POP
65627: POP
// end ;
65628: LD_VAR 0 1
65632: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
65633: LD_INT 0
65635: PPUSH
65636: PPUSH
65637: PPUSH
// if not mc_bases then
65638: LD_EXP 23
65642: NOT
65643: IFFALSE 65647
// exit ;
65645: GO 65736
// for i = 1 to mc_bases do
65647: LD_ADDR_VAR 0 2
65651: PUSH
65652: DOUBLE
65653: LD_INT 1
65655: DEC
65656: ST_TO_ADDR
65657: LD_EXP 23
65661: PUSH
65662: FOR_TO
65663: IFFALSE 65734
// begin if mc_attack [ i ] then
65665: LD_EXP 43
65669: PUSH
65670: LD_VAR 0 2
65674: ARRAY
65675: IFFALSE 65732
// begin tmp := mc_attack [ i ] [ 1 ] ;
65677: LD_ADDR_VAR 0 3
65681: PUSH
65682: LD_EXP 43
65686: PUSH
65687: LD_VAR 0 2
65691: ARRAY
65692: PUSH
65693: LD_INT 1
65695: ARRAY
65696: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65697: LD_ADDR_EXP 43
65701: PUSH
65702: LD_EXP 43
65706: PPUSH
65707: LD_VAR 0 2
65711: PPUSH
65712: EMPTY
65713: PPUSH
65714: CALL_OW 1
65718: ST_TO_ADDR
// Attack ( tmp ) ;
65719: LD_VAR 0 3
65723: PPUSH
65724: CALL 80525 0 1
// exit ;
65728: POP
65729: POP
65730: GO 65736
// end ; end ;
65732: GO 65662
65734: POP
65735: POP
// end ;
65736: LD_VAR 0 1
65740: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
65741: LD_INT 0
65743: PPUSH
65744: PPUSH
65745: PPUSH
65746: PPUSH
65747: PPUSH
65748: PPUSH
65749: PPUSH
// if not mc_bases then
65750: LD_EXP 23
65754: NOT
65755: IFFALSE 65759
// exit ;
65757: GO 66469
// for i = 1 to mc_bases do
65759: LD_ADDR_VAR 0 2
65763: PUSH
65764: DOUBLE
65765: LD_INT 1
65767: DEC
65768: ST_TO_ADDR
65769: LD_EXP 23
65773: PUSH
65774: FOR_TO
65775: IFFALSE 66467
// begin if not mc_bases [ i ] then
65777: LD_EXP 23
65781: PUSH
65782: LD_VAR 0 2
65786: ARRAY
65787: NOT
65788: IFFALSE 65792
// continue ;
65790: GO 65774
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
65792: LD_ADDR_VAR 0 7
65796: PUSH
65797: LD_EXP 23
65801: PUSH
65802: LD_VAR 0 2
65806: ARRAY
65807: PUSH
65808: LD_INT 1
65810: ARRAY
65811: PPUSH
65812: CALL 12790 0 1
65816: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
65817: LD_ADDR_EXP 46
65821: PUSH
65822: LD_EXP 46
65826: PPUSH
65827: LD_VAR 0 2
65831: PPUSH
65832: LD_EXP 23
65836: PUSH
65837: LD_VAR 0 2
65841: ARRAY
65842: PUSH
65843: LD_INT 1
65845: ARRAY
65846: PPUSH
65847: CALL_OW 255
65851: PPUSH
65852: LD_EXP 48
65856: PUSH
65857: LD_VAR 0 2
65861: ARRAY
65862: PPUSH
65863: CALL 12755 0 2
65867: PPUSH
65868: CALL_OW 1
65872: ST_TO_ADDR
// if not mc_scan [ i ] then
65873: LD_EXP 46
65877: PUSH
65878: LD_VAR 0 2
65882: ARRAY
65883: NOT
65884: IFFALSE 66062
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
65886: LD_ADDR_EXP 66
65890: PUSH
65891: LD_EXP 66
65895: PPUSH
65896: LD_VAR 0 2
65900: PPUSH
65901: LD_INT 0
65903: PPUSH
65904: CALL_OW 1
65908: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65909: LD_ADDR_VAR 0 4
65913: PUSH
65914: LD_EXP 23
65918: PUSH
65919: LD_VAR 0 2
65923: ARRAY
65924: PPUSH
65925: LD_INT 2
65927: PUSH
65928: LD_INT 25
65930: PUSH
65931: LD_INT 5
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 25
65940: PUSH
65941: LD_INT 8
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 25
65950: PUSH
65951: LD_INT 9
65953: PUSH
65954: EMPTY
65955: LIST
65956: LIST
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: LIST
65962: LIST
65963: PPUSH
65964: CALL_OW 72
65968: ST_TO_ADDR
// if not tmp then
65969: LD_VAR 0 4
65973: NOT
65974: IFFALSE 65978
// continue ;
65976: GO 65774
// for j in tmp do
65978: LD_ADDR_VAR 0 3
65982: PUSH
65983: LD_VAR 0 4
65987: PUSH
65988: FOR_IN
65989: IFFALSE 66060
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
65991: LD_VAR 0 3
65995: PPUSH
65996: CALL_OW 310
66000: PPUSH
66001: CALL_OW 266
66005: PUSH
66006: LD_INT 5
66008: EQUAL
66009: PUSH
66010: LD_VAR 0 3
66014: PPUSH
66015: CALL_OW 257
66019: PUSH
66020: LD_INT 1
66022: EQUAL
66023: AND
66024: PUSH
66025: LD_VAR 0 3
66029: PPUSH
66030: CALL_OW 459
66034: NOT
66035: AND
66036: PUSH
66037: LD_VAR 0 7
66041: AND
66042: IFFALSE 66058
// ComChangeProfession ( j , class ) ;
66044: LD_VAR 0 3
66048: PPUSH
66049: LD_VAR 0 7
66053: PPUSH
66054: CALL_OW 123
66058: GO 65988
66060: POP
66061: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
66062: LD_EXP 46
66066: PUSH
66067: LD_VAR 0 2
66071: ARRAY
66072: PUSH
66073: LD_EXP 66
66077: PUSH
66078: LD_VAR 0 2
66082: ARRAY
66083: NOT
66084: AND
66085: PUSH
66086: LD_EXP 45
66090: PUSH
66091: LD_VAR 0 2
66095: ARRAY
66096: NOT
66097: AND
66098: IFFALSE 66349
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66100: LD_ADDR_EXP 66
66104: PUSH
66105: LD_EXP 66
66109: PPUSH
66110: LD_VAR 0 2
66114: PPUSH
66115: LD_INT 1
66117: PPUSH
66118: CALL_OW 1
66122: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66123: LD_ADDR_VAR 0 4
66127: PUSH
66128: LD_EXP 23
66132: PUSH
66133: LD_VAR 0 2
66137: ARRAY
66138: PPUSH
66139: LD_INT 2
66141: PUSH
66142: LD_INT 25
66144: PUSH
66145: LD_INT 1
66147: PUSH
66148: EMPTY
66149: LIST
66150: LIST
66151: PUSH
66152: LD_INT 25
66154: PUSH
66155: LD_INT 5
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 25
66164: PUSH
66165: LD_INT 8
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 25
66174: PUSH
66175: LD_INT 9
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: EMPTY
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: PPUSH
66189: CALL_OW 72
66193: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66194: LD_ADDR_VAR 0 4
66198: PUSH
66199: LD_VAR 0 4
66203: PUSH
66204: LD_VAR 0 4
66208: PPUSH
66209: LD_INT 18
66211: PPUSH
66212: CALL 45259 0 2
66216: DIFF
66217: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66218: LD_VAR 0 4
66222: NOT
66223: PUSH
66224: LD_EXP 23
66228: PUSH
66229: LD_VAR 0 2
66233: ARRAY
66234: PPUSH
66235: LD_INT 2
66237: PUSH
66238: LD_INT 30
66240: PUSH
66241: LD_INT 4
66243: PUSH
66244: EMPTY
66245: LIST
66246: LIST
66247: PUSH
66248: LD_INT 30
66250: PUSH
66251: LD_INT 5
66253: PUSH
66254: EMPTY
66255: LIST
66256: LIST
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: LIST
66262: PPUSH
66263: CALL_OW 72
66267: NOT
66268: AND
66269: IFFALSE 66331
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
66271: LD_ADDR_VAR 0 4
66275: PUSH
66276: LD_EXP 23
66280: PUSH
66281: LD_VAR 0 2
66285: ARRAY
66286: PPUSH
66287: LD_INT 2
66289: PUSH
66290: LD_INT 25
66292: PUSH
66293: LD_INT 2
66295: PUSH
66296: EMPTY
66297: LIST
66298: LIST
66299: PUSH
66300: LD_INT 25
66302: PUSH
66303: LD_INT 3
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 25
66312: PUSH
66313: LD_INT 4
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: EMPTY
66321: LIST
66322: LIST
66323: LIST
66324: LIST
66325: PPUSH
66326: CALL_OW 72
66330: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
66331: LD_VAR 0 2
66335: PPUSH
66336: LD_VAR 0 4
66340: PPUSH
66341: CALL 85234 0 2
// exit ;
66345: POP
66346: POP
66347: GO 66469
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
66349: LD_EXP 46
66353: PUSH
66354: LD_VAR 0 2
66358: ARRAY
66359: PUSH
66360: LD_EXP 66
66364: PUSH
66365: LD_VAR 0 2
66369: ARRAY
66370: NOT
66371: AND
66372: PUSH
66373: LD_EXP 45
66377: PUSH
66378: LD_VAR 0 2
66382: ARRAY
66383: AND
66384: IFFALSE 66465
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66386: LD_ADDR_EXP 66
66390: PUSH
66391: LD_EXP 66
66395: PPUSH
66396: LD_VAR 0 2
66400: PPUSH
66401: LD_INT 1
66403: PPUSH
66404: CALL_OW 1
66408: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
66409: LD_ADDR_VAR 0 4
66413: PUSH
66414: LD_EXP 45
66418: PUSH
66419: LD_VAR 0 2
66423: ARRAY
66424: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
66425: LD_ADDR_EXP 45
66429: PUSH
66430: LD_EXP 45
66434: PPUSH
66435: LD_VAR 0 2
66439: PPUSH
66440: EMPTY
66441: PPUSH
66442: CALL_OW 1
66446: ST_TO_ADDR
// Defend ( i , tmp ) ;
66447: LD_VAR 0 2
66451: PPUSH
66452: LD_VAR 0 4
66456: PPUSH
66457: CALL 85804 0 2
// exit ;
66461: POP
66462: POP
66463: GO 66469
// end ; end ;
66465: GO 65774
66467: POP
66468: POP
// end ;
66469: LD_VAR 0 1
66473: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66474: LD_INT 0
66476: PPUSH
66477: PPUSH
66478: PPUSH
66479: PPUSH
66480: PPUSH
66481: PPUSH
66482: PPUSH
66483: PPUSH
66484: PPUSH
66485: PPUSH
66486: PPUSH
// if not mc_bases then
66487: LD_EXP 23
66491: NOT
66492: IFFALSE 66496
// exit ;
66494: GO 67583
// for i = 1 to mc_bases do
66496: LD_ADDR_VAR 0 2
66500: PUSH
66501: DOUBLE
66502: LD_INT 1
66504: DEC
66505: ST_TO_ADDR
66506: LD_EXP 23
66510: PUSH
66511: FOR_TO
66512: IFFALSE 67581
// begin tmp := mc_lab [ i ] ;
66514: LD_ADDR_VAR 0 6
66518: PUSH
66519: LD_EXP 56
66523: PUSH
66524: LD_VAR 0 2
66528: ARRAY
66529: ST_TO_ADDR
// if not tmp then
66530: LD_VAR 0 6
66534: NOT
66535: IFFALSE 66539
// continue ;
66537: GO 66511
// idle_lab := 0 ;
66539: LD_ADDR_VAR 0 11
66543: PUSH
66544: LD_INT 0
66546: ST_TO_ADDR
// for j in tmp do
66547: LD_ADDR_VAR 0 3
66551: PUSH
66552: LD_VAR 0 6
66556: PUSH
66557: FOR_IN
66558: IFFALSE 67577
// begin researching := false ;
66560: LD_ADDR_VAR 0 10
66564: PUSH
66565: LD_INT 0
66567: ST_TO_ADDR
// side := GetSide ( j ) ;
66568: LD_ADDR_VAR 0 4
66572: PUSH
66573: LD_VAR 0 3
66577: PPUSH
66578: CALL_OW 255
66582: ST_TO_ADDR
// if not mc_tech [ side ] then
66583: LD_EXP 50
66587: PUSH
66588: LD_VAR 0 4
66592: ARRAY
66593: NOT
66594: IFFALSE 66598
// continue ;
66596: GO 66557
// if BuildingStatus ( j ) = bs_idle then
66598: LD_VAR 0 3
66602: PPUSH
66603: CALL_OW 461
66607: PUSH
66608: LD_INT 2
66610: EQUAL
66611: IFFALSE 66799
// begin if idle_lab and UnitsInside ( j ) < 6 then
66613: LD_VAR 0 11
66617: PUSH
66618: LD_VAR 0 3
66622: PPUSH
66623: CALL_OW 313
66627: PUSH
66628: LD_INT 6
66630: LESS
66631: AND
66632: IFFALSE 66703
// begin tmp2 := UnitsInside ( idle_lab ) ;
66634: LD_ADDR_VAR 0 9
66638: PUSH
66639: LD_VAR 0 11
66643: PPUSH
66644: CALL_OW 313
66648: ST_TO_ADDR
// if tmp2 then
66649: LD_VAR 0 9
66653: IFFALSE 66695
// for x in tmp2 do
66655: LD_ADDR_VAR 0 7
66659: PUSH
66660: LD_VAR 0 9
66664: PUSH
66665: FOR_IN
66666: IFFALSE 66693
// begin ComExitBuilding ( x ) ;
66668: LD_VAR 0 7
66672: PPUSH
66673: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66677: LD_VAR 0 7
66681: PPUSH
66682: LD_VAR 0 3
66686: PPUSH
66687: CALL_OW 180
// end ;
66691: GO 66665
66693: POP
66694: POP
// idle_lab := 0 ;
66695: LD_ADDR_VAR 0 11
66699: PUSH
66700: LD_INT 0
66702: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66703: LD_ADDR_VAR 0 5
66707: PUSH
66708: LD_EXP 50
66712: PUSH
66713: LD_VAR 0 4
66717: ARRAY
66718: PUSH
66719: FOR_IN
66720: IFFALSE 66780
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66722: LD_VAR 0 3
66726: PPUSH
66727: LD_VAR 0 5
66731: PPUSH
66732: CALL_OW 430
66736: PUSH
66737: LD_VAR 0 4
66741: PPUSH
66742: LD_VAR 0 5
66746: PPUSH
66747: CALL 11860 0 2
66751: AND
66752: IFFALSE 66778
// begin researching := true ;
66754: LD_ADDR_VAR 0 10
66758: PUSH
66759: LD_INT 1
66761: ST_TO_ADDR
// ComResearch ( j , t ) ;
66762: LD_VAR 0 3
66766: PPUSH
66767: LD_VAR 0 5
66771: PPUSH
66772: CALL_OW 124
// break ;
66776: GO 66780
// end ;
66778: GO 66719
66780: POP
66781: POP
// if not researching then
66782: LD_VAR 0 10
66786: NOT
66787: IFFALSE 66799
// idle_lab := j ;
66789: LD_ADDR_VAR 0 11
66793: PUSH
66794: LD_VAR 0 3
66798: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
66799: LD_VAR 0 3
66803: PPUSH
66804: CALL_OW 461
66808: PUSH
66809: LD_INT 10
66811: EQUAL
66812: IFFALSE 67400
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
66814: LD_EXP 52
66818: PUSH
66819: LD_VAR 0 2
66823: ARRAY
66824: NOT
66825: PUSH
66826: LD_EXP 53
66830: PUSH
66831: LD_VAR 0 2
66835: ARRAY
66836: NOT
66837: AND
66838: PUSH
66839: LD_EXP 50
66843: PUSH
66844: LD_VAR 0 4
66848: ARRAY
66849: PUSH
66850: LD_INT 1
66852: GREATER
66853: AND
66854: IFFALSE 66985
// begin ComCancel ( j ) ;
66856: LD_VAR 0 3
66860: PPUSH
66861: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
66865: LD_ADDR_EXP 50
66869: PUSH
66870: LD_EXP 50
66874: PPUSH
66875: LD_VAR 0 4
66879: PPUSH
66880: LD_EXP 50
66884: PUSH
66885: LD_VAR 0 4
66889: ARRAY
66890: PPUSH
66891: LD_EXP 50
66895: PUSH
66896: LD_VAR 0 4
66900: ARRAY
66901: PUSH
66902: LD_INT 1
66904: MINUS
66905: PPUSH
66906: LD_EXP 50
66910: PUSH
66911: LD_VAR 0 4
66915: ARRAY
66916: PPUSH
66917: LD_INT 0
66919: PPUSH
66920: CALL 15408 0 4
66924: PPUSH
66925: CALL_OW 1
66929: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
66930: LD_ADDR_EXP 50
66934: PUSH
66935: LD_EXP 50
66939: PPUSH
66940: LD_VAR 0 4
66944: PPUSH
66945: LD_EXP 50
66949: PUSH
66950: LD_VAR 0 4
66954: ARRAY
66955: PPUSH
66956: LD_EXP 50
66960: PUSH
66961: LD_VAR 0 4
66965: ARRAY
66966: PPUSH
66967: LD_INT 1
66969: PPUSH
66970: LD_INT 0
66972: PPUSH
66973: CALL 15408 0 4
66977: PPUSH
66978: CALL_OW 1
66982: ST_TO_ADDR
// continue ;
66983: GO 66557
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
66985: LD_EXP 52
66989: PUSH
66990: LD_VAR 0 2
66994: ARRAY
66995: PUSH
66996: LD_EXP 53
67000: PUSH
67001: LD_VAR 0 2
67005: ARRAY
67006: NOT
67007: AND
67008: IFFALSE 67135
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67010: LD_ADDR_EXP 53
67014: PUSH
67015: LD_EXP 53
67019: PPUSH
67020: LD_VAR 0 2
67024: PUSH
67025: LD_EXP 53
67029: PUSH
67030: LD_VAR 0 2
67034: ARRAY
67035: PUSH
67036: LD_INT 1
67038: PLUS
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PPUSH
67044: LD_EXP 52
67048: PUSH
67049: LD_VAR 0 2
67053: ARRAY
67054: PUSH
67055: LD_INT 1
67057: ARRAY
67058: PPUSH
67059: CALL 15990 0 3
67063: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67064: LD_EXP 52
67068: PUSH
67069: LD_VAR 0 2
67073: ARRAY
67074: PUSH
67075: LD_INT 1
67077: ARRAY
67078: PPUSH
67079: LD_INT 112
67081: PPUSH
67082: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67086: LD_ADDR_VAR 0 9
67090: PUSH
67091: LD_EXP 52
67095: PUSH
67096: LD_VAR 0 2
67100: ARRAY
67101: PPUSH
67102: LD_INT 1
67104: PPUSH
67105: CALL_OW 3
67109: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67110: LD_ADDR_EXP 52
67114: PUSH
67115: LD_EXP 52
67119: PPUSH
67120: LD_VAR 0 2
67124: PPUSH
67125: LD_VAR 0 9
67129: PPUSH
67130: CALL_OW 1
67134: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67135: LD_EXP 52
67139: PUSH
67140: LD_VAR 0 2
67144: ARRAY
67145: PUSH
67146: LD_EXP 53
67150: PUSH
67151: LD_VAR 0 2
67155: ARRAY
67156: AND
67157: PUSH
67158: LD_EXP 53
67162: PUSH
67163: LD_VAR 0 2
67167: ARRAY
67168: PUSH
67169: LD_INT 1
67171: ARRAY
67172: PPUSH
67173: CALL_OW 310
67177: NOT
67178: AND
67179: PUSH
67180: LD_VAR 0 3
67184: PPUSH
67185: CALL_OW 313
67189: PUSH
67190: LD_INT 6
67192: EQUAL
67193: AND
67194: IFFALSE 67250
// begin tmp2 := UnitsInside ( j ) ;
67196: LD_ADDR_VAR 0 9
67200: PUSH
67201: LD_VAR 0 3
67205: PPUSH
67206: CALL_OW 313
67210: ST_TO_ADDR
// if tmp2 = 6 then
67211: LD_VAR 0 9
67215: PUSH
67216: LD_INT 6
67218: EQUAL
67219: IFFALSE 67250
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67221: LD_VAR 0 9
67225: PUSH
67226: LD_INT 1
67228: ARRAY
67229: PPUSH
67230: LD_INT 112
67232: PPUSH
67233: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67237: LD_VAR 0 9
67241: PUSH
67242: LD_INT 1
67244: ARRAY
67245: PPUSH
67246: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67250: LD_EXP 53
67254: PUSH
67255: LD_VAR 0 2
67259: ARRAY
67260: PUSH
67261: LD_EXP 53
67265: PUSH
67266: LD_VAR 0 2
67270: ARRAY
67271: PUSH
67272: LD_INT 1
67274: ARRAY
67275: PPUSH
67276: CALL_OW 314
67280: NOT
67281: AND
67282: PUSH
67283: LD_EXP 53
67287: PUSH
67288: LD_VAR 0 2
67292: ARRAY
67293: PUSH
67294: LD_INT 1
67296: ARRAY
67297: PPUSH
67298: CALL_OW 310
67302: NOT
67303: AND
67304: IFFALSE 67330
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67306: LD_EXP 53
67310: PUSH
67311: LD_VAR 0 2
67315: ARRAY
67316: PUSH
67317: LD_INT 1
67319: ARRAY
67320: PPUSH
67321: LD_VAR 0 3
67325: PPUSH
67326: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67330: LD_EXP 53
67334: PUSH
67335: LD_VAR 0 2
67339: ARRAY
67340: PUSH
67341: LD_INT 1
67343: ARRAY
67344: PPUSH
67345: CALL_OW 310
67349: PUSH
67350: LD_EXP 53
67354: PUSH
67355: LD_VAR 0 2
67359: ARRAY
67360: PUSH
67361: LD_INT 1
67363: ARRAY
67364: PPUSH
67365: CALL_OW 310
67369: PPUSH
67370: CALL_OW 461
67374: PUSH
67375: LD_INT 3
67377: NONEQUAL
67378: AND
67379: IFFALSE 67400
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67381: LD_EXP 53
67385: PUSH
67386: LD_VAR 0 2
67390: ARRAY
67391: PUSH
67392: LD_INT 1
67394: ARRAY
67395: PPUSH
67396: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67400: LD_VAR 0 3
67404: PPUSH
67405: CALL_OW 461
67409: PUSH
67410: LD_INT 6
67412: EQUAL
67413: PUSH
67414: LD_VAR 0 6
67418: PUSH
67419: LD_INT 1
67421: GREATER
67422: AND
67423: IFFALSE 67575
// begin sci := [ ] ;
67425: LD_ADDR_VAR 0 8
67429: PUSH
67430: EMPTY
67431: ST_TO_ADDR
// for x in ( tmp diff j ) do
67432: LD_ADDR_VAR 0 7
67436: PUSH
67437: LD_VAR 0 6
67441: PUSH
67442: LD_VAR 0 3
67446: DIFF
67447: PUSH
67448: FOR_IN
67449: IFFALSE 67501
// begin if sci = 6 then
67451: LD_VAR 0 8
67455: PUSH
67456: LD_INT 6
67458: EQUAL
67459: IFFALSE 67463
// break ;
67461: GO 67501
// if BuildingStatus ( x ) = bs_idle then
67463: LD_VAR 0 7
67467: PPUSH
67468: CALL_OW 461
67472: PUSH
67473: LD_INT 2
67475: EQUAL
67476: IFFALSE 67499
// sci := sci ^ UnitsInside ( x ) ;
67478: LD_ADDR_VAR 0 8
67482: PUSH
67483: LD_VAR 0 8
67487: PUSH
67488: LD_VAR 0 7
67492: PPUSH
67493: CALL_OW 313
67497: ADD
67498: ST_TO_ADDR
// end ;
67499: GO 67448
67501: POP
67502: POP
// if not sci then
67503: LD_VAR 0 8
67507: NOT
67508: IFFALSE 67512
// continue ;
67510: GO 66557
// for x in sci do
67512: LD_ADDR_VAR 0 7
67516: PUSH
67517: LD_VAR 0 8
67521: PUSH
67522: FOR_IN
67523: IFFALSE 67573
// if IsInUnit ( x ) and not HasTask ( x ) then
67525: LD_VAR 0 7
67529: PPUSH
67530: CALL_OW 310
67534: PUSH
67535: LD_VAR 0 7
67539: PPUSH
67540: CALL_OW 314
67544: NOT
67545: AND
67546: IFFALSE 67571
// begin ComExitBuilding ( x ) ;
67548: LD_VAR 0 7
67552: PPUSH
67553: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67557: LD_VAR 0 7
67561: PPUSH
67562: LD_VAR 0 3
67566: PPUSH
67567: CALL_OW 180
// end ;
67571: GO 67522
67573: POP
67574: POP
// end ; end ;
67575: GO 66557
67577: POP
67578: POP
// end ;
67579: GO 66511
67581: POP
67582: POP
// end ;
67583: LD_VAR 0 1
67587: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67588: LD_INT 0
67590: PPUSH
67591: PPUSH
// if not mc_bases then
67592: LD_EXP 23
67596: NOT
67597: IFFALSE 67601
// exit ;
67599: GO 67682
// for i = 1 to mc_bases do
67601: LD_ADDR_VAR 0 2
67605: PUSH
67606: DOUBLE
67607: LD_INT 1
67609: DEC
67610: ST_TO_ADDR
67611: LD_EXP 23
67615: PUSH
67616: FOR_TO
67617: IFFALSE 67680
// if mc_mines [ i ] and mc_miners [ i ] then
67619: LD_EXP 36
67623: PUSH
67624: LD_VAR 0 2
67628: ARRAY
67629: PUSH
67630: LD_EXP 37
67634: PUSH
67635: LD_VAR 0 2
67639: ARRAY
67640: AND
67641: IFFALSE 67678
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67643: LD_EXP 37
67647: PUSH
67648: LD_VAR 0 2
67652: ARRAY
67653: PUSH
67654: LD_INT 1
67656: ARRAY
67657: PPUSH
67658: CALL_OW 255
67662: PPUSH
67663: LD_EXP 36
67667: PUSH
67668: LD_VAR 0 2
67672: ARRAY
67673: PPUSH
67674: CALL 12943 0 2
67678: GO 67616
67680: POP
67681: POP
// end ;
67682: LD_VAR 0 1
67686: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67687: LD_INT 0
67689: PPUSH
67690: PPUSH
67691: PPUSH
67692: PPUSH
67693: PPUSH
67694: PPUSH
67695: PPUSH
67696: PPUSH
// if not mc_bases or not mc_parking then
67697: LD_EXP 23
67701: NOT
67702: PUSH
67703: LD_EXP 47
67707: NOT
67708: OR
67709: IFFALSE 67713
// exit ;
67711: GO 68423
// for i = 1 to mc_bases do
67713: LD_ADDR_VAR 0 2
67717: PUSH
67718: DOUBLE
67719: LD_INT 1
67721: DEC
67722: ST_TO_ADDR
67723: LD_EXP 23
67727: PUSH
67728: FOR_TO
67729: IFFALSE 68421
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
67731: LD_EXP 23
67735: PUSH
67736: LD_VAR 0 2
67740: ARRAY
67741: NOT
67742: PUSH
67743: LD_EXP 47
67747: PUSH
67748: LD_VAR 0 2
67752: ARRAY
67753: NOT
67754: OR
67755: IFFALSE 67759
// continue ;
67757: GO 67728
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67759: LD_ADDR_VAR 0 5
67763: PUSH
67764: LD_EXP 23
67768: PUSH
67769: LD_VAR 0 2
67773: ARRAY
67774: PUSH
67775: LD_INT 1
67777: ARRAY
67778: PPUSH
67779: CALL_OW 255
67783: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67784: LD_ADDR_VAR 0 6
67788: PUSH
67789: LD_EXP 23
67793: PUSH
67794: LD_VAR 0 2
67798: ARRAY
67799: PPUSH
67800: LD_INT 30
67802: PUSH
67803: LD_INT 3
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: PPUSH
67810: CALL_OW 72
67814: ST_TO_ADDR
// if not fac then
67815: LD_VAR 0 6
67819: NOT
67820: IFFALSE 67871
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67822: LD_ADDR_VAR 0 6
67826: PUSH
67827: LD_EXP 23
67831: PUSH
67832: LD_VAR 0 2
67836: ARRAY
67837: PPUSH
67838: LD_INT 2
67840: PUSH
67841: LD_INT 30
67843: PUSH
67844: LD_INT 0
67846: PUSH
67847: EMPTY
67848: LIST
67849: LIST
67850: PUSH
67851: LD_INT 30
67853: PUSH
67854: LD_INT 1
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PUSH
67861: EMPTY
67862: LIST
67863: LIST
67864: LIST
67865: PPUSH
67866: CALL_OW 72
67870: ST_TO_ADDR
// if not fac then
67871: LD_VAR 0 6
67875: NOT
67876: IFFALSE 67880
// continue ;
67878: GO 67728
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67880: LD_ADDR_VAR 0 7
67884: PUSH
67885: LD_EXP 47
67889: PUSH
67890: LD_VAR 0 2
67894: ARRAY
67895: PPUSH
67896: LD_INT 22
67898: PUSH
67899: LD_VAR 0 5
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 21
67910: PUSH
67911: LD_INT 2
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 3
67920: PUSH
67921: LD_INT 24
67923: PUSH
67924: LD_INT 1000
67926: PUSH
67927: EMPTY
67928: LIST
67929: LIST
67930: PUSH
67931: EMPTY
67932: LIST
67933: LIST
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: LIST
67939: PPUSH
67940: CALL_OW 70
67944: ST_TO_ADDR
// for j in fac do
67945: LD_ADDR_VAR 0 3
67949: PUSH
67950: LD_VAR 0 6
67954: PUSH
67955: FOR_IN
67956: IFFALSE 68037
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67958: LD_ADDR_VAR 0 7
67962: PUSH
67963: LD_VAR 0 7
67967: PUSH
67968: LD_INT 22
67970: PUSH
67971: LD_VAR 0 5
67975: PUSH
67976: EMPTY
67977: LIST
67978: LIST
67979: PUSH
67980: LD_INT 91
67982: PUSH
67983: LD_VAR 0 3
67987: PUSH
67988: LD_INT 15
67990: PUSH
67991: EMPTY
67992: LIST
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 21
67998: PUSH
67999: LD_INT 2
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 3
68008: PUSH
68009: LD_INT 24
68011: PUSH
68012: LD_INT 1000
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: LIST
68027: LIST
68028: PPUSH
68029: CALL_OW 69
68033: UNION
68034: ST_TO_ADDR
68035: GO 67955
68037: POP
68038: POP
// if not vehs then
68039: LD_VAR 0 7
68043: NOT
68044: IFFALSE 68070
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68046: LD_ADDR_EXP 35
68050: PUSH
68051: LD_EXP 35
68055: PPUSH
68056: LD_VAR 0 2
68060: PPUSH
68061: EMPTY
68062: PPUSH
68063: CALL_OW 1
68067: ST_TO_ADDR
// continue ;
68068: GO 67728
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68070: LD_ADDR_VAR 0 8
68074: PUSH
68075: LD_EXP 23
68079: PUSH
68080: LD_VAR 0 2
68084: ARRAY
68085: PPUSH
68086: LD_INT 30
68088: PUSH
68089: LD_INT 3
68091: PUSH
68092: EMPTY
68093: LIST
68094: LIST
68095: PPUSH
68096: CALL_OW 72
68100: ST_TO_ADDR
// if tmp then
68101: LD_VAR 0 8
68105: IFFALSE 68208
// begin for j in tmp do
68107: LD_ADDR_VAR 0 3
68111: PUSH
68112: LD_VAR 0 8
68116: PUSH
68117: FOR_IN
68118: IFFALSE 68206
// for k in UnitsInside ( j ) do
68120: LD_ADDR_VAR 0 4
68124: PUSH
68125: LD_VAR 0 3
68129: PPUSH
68130: CALL_OW 313
68134: PUSH
68135: FOR_IN
68136: IFFALSE 68202
// if k then
68138: LD_VAR 0 4
68142: IFFALSE 68200
// if not k in mc_repair_vehicle [ i ] then
68144: LD_VAR 0 4
68148: PUSH
68149: LD_EXP 35
68153: PUSH
68154: LD_VAR 0 2
68158: ARRAY
68159: IN
68160: NOT
68161: IFFALSE 68200
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68163: LD_ADDR_EXP 35
68167: PUSH
68168: LD_EXP 35
68172: PPUSH
68173: LD_VAR 0 2
68177: PPUSH
68178: LD_EXP 35
68182: PUSH
68183: LD_VAR 0 2
68187: ARRAY
68188: PUSH
68189: LD_VAR 0 4
68193: UNION
68194: PPUSH
68195: CALL_OW 1
68199: ST_TO_ADDR
68200: GO 68135
68202: POP
68203: POP
68204: GO 68117
68206: POP
68207: POP
// end ; if not mc_repair_vehicle [ i ] then
68208: LD_EXP 35
68212: PUSH
68213: LD_VAR 0 2
68217: ARRAY
68218: NOT
68219: IFFALSE 68223
// continue ;
68221: GO 67728
// for j in mc_repair_vehicle [ i ] do
68223: LD_ADDR_VAR 0 3
68227: PUSH
68228: LD_EXP 35
68232: PUSH
68233: LD_VAR 0 2
68237: ARRAY
68238: PUSH
68239: FOR_IN
68240: IFFALSE 68417
// begin if GetClass ( j ) <> 3 then
68242: LD_VAR 0 3
68246: PPUSH
68247: CALL_OW 257
68251: PUSH
68252: LD_INT 3
68254: NONEQUAL
68255: IFFALSE 68296
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68257: LD_ADDR_EXP 35
68261: PUSH
68262: LD_EXP 35
68266: PPUSH
68267: LD_VAR 0 2
68271: PPUSH
68272: LD_EXP 35
68276: PUSH
68277: LD_VAR 0 2
68281: ARRAY
68282: PUSH
68283: LD_VAR 0 3
68287: DIFF
68288: PPUSH
68289: CALL_OW 1
68293: ST_TO_ADDR
// continue ;
68294: GO 68239
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68296: LD_VAR 0 3
68300: PPUSH
68301: CALL_OW 311
68305: NOT
68306: PUSH
68307: LD_VAR 0 3
68311: PUSH
68312: LD_EXP 26
68316: PUSH
68317: LD_VAR 0 2
68321: ARRAY
68322: PUSH
68323: LD_INT 1
68325: ARRAY
68326: IN
68327: NOT
68328: AND
68329: PUSH
68330: LD_VAR 0 3
68334: PUSH
68335: LD_EXP 26
68339: PUSH
68340: LD_VAR 0 2
68344: ARRAY
68345: PUSH
68346: LD_INT 2
68348: ARRAY
68349: IN
68350: NOT
68351: AND
68352: IFFALSE 68415
// begin if IsInUnit ( j ) then
68354: LD_VAR 0 3
68358: PPUSH
68359: CALL_OW 310
68363: IFFALSE 68376
// ComExitBuilding ( j ) else
68365: LD_VAR 0 3
68369: PPUSH
68370: CALL_OW 122
68374: GO 68415
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
68376: LD_VAR 0 3
68380: PPUSH
68381: LD_VAR 0 7
68385: PUSH
68386: LD_INT 1
68388: ARRAY
68389: PPUSH
68390: CALL 49597 0 2
68394: NOT
68395: IFFALSE 68415
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
68397: LD_VAR 0 3
68401: PPUSH
68402: LD_VAR 0 7
68406: PUSH
68407: LD_INT 1
68409: ARRAY
68410: PPUSH
68411: CALL_OW 129
// end ; end ;
68415: GO 68239
68417: POP
68418: POP
// end ;
68419: GO 67728
68421: POP
68422: POP
// end ;
68423: LD_VAR 0 1
68427: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68428: LD_INT 0
68430: PPUSH
68431: PPUSH
68432: PPUSH
68433: PPUSH
68434: PPUSH
68435: PPUSH
68436: PPUSH
68437: PPUSH
68438: PPUSH
68439: PPUSH
68440: PPUSH
// if not mc_bases then
68441: LD_EXP 23
68445: NOT
68446: IFFALSE 68450
// exit ;
68448: GO 69252
// for i = 1 to mc_bases do
68450: LD_ADDR_VAR 0 2
68454: PUSH
68455: DOUBLE
68456: LD_INT 1
68458: DEC
68459: ST_TO_ADDR
68460: LD_EXP 23
68464: PUSH
68465: FOR_TO
68466: IFFALSE 69250
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68468: LD_EXP 51
68472: PUSH
68473: LD_VAR 0 2
68477: ARRAY
68478: NOT
68479: PUSH
68480: LD_EXP 26
68484: PUSH
68485: LD_VAR 0 2
68489: ARRAY
68490: PUSH
68491: LD_INT 1
68493: ARRAY
68494: OR
68495: PUSH
68496: LD_EXP 26
68500: PUSH
68501: LD_VAR 0 2
68505: ARRAY
68506: PUSH
68507: LD_INT 2
68509: ARRAY
68510: OR
68511: PUSH
68512: LD_EXP 49
68516: PUSH
68517: LD_VAR 0 2
68521: ARRAY
68522: PPUSH
68523: LD_INT 1
68525: PPUSH
68526: CALL_OW 325
68530: NOT
68531: OR
68532: PUSH
68533: LD_EXP 46
68537: PUSH
68538: LD_VAR 0 2
68542: ARRAY
68543: OR
68544: IFFALSE 68548
// continue ;
68546: GO 68465
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68548: LD_ADDR_VAR 0 8
68552: PUSH
68553: LD_EXP 23
68557: PUSH
68558: LD_VAR 0 2
68562: ARRAY
68563: PPUSH
68564: LD_INT 25
68566: PUSH
68567: LD_INT 4
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 50
68576: PUSH
68577: EMPTY
68578: LIST
68579: PUSH
68580: LD_INT 3
68582: PUSH
68583: LD_INT 60
68585: PUSH
68586: EMPTY
68587: LIST
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: LIST
68597: PPUSH
68598: CALL_OW 72
68602: PUSH
68603: LD_EXP 27
68607: PUSH
68608: LD_VAR 0 2
68612: ARRAY
68613: DIFF
68614: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68615: LD_ADDR_VAR 0 9
68619: PUSH
68620: LD_EXP 23
68624: PUSH
68625: LD_VAR 0 2
68629: ARRAY
68630: PPUSH
68631: LD_INT 2
68633: PUSH
68634: LD_INT 30
68636: PUSH
68637: LD_INT 0
68639: PUSH
68640: EMPTY
68641: LIST
68642: LIST
68643: PUSH
68644: LD_INT 30
68646: PUSH
68647: LD_INT 1
68649: PUSH
68650: EMPTY
68651: LIST
68652: LIST
68653: PUSH
68654: EMPTY
68655: LIST
68656: LIST
68657: LIST
68658: PPUSH
68659: CALL_OW 72
68663: ST_TO_ADDR
// if not tmp or not dep then
68664: LD_VAR 0 8
68668: NOT
68669: PUSH
68670: LD_VAR 0 9
68674: NOT
68675: OR
68676: IFFALSE 68680
// continue ;
68678: GO 68465
// side := GetSide ( tmp [ 1 ] ) ;
68680: LD_ADDR_VAR 0 11
68684: PUSH
68685: LD_VAR 0 8
68689: PUSH
68690: LD_INT 1
68692: ARRAY
68693: PPUSH
68694: CALL_OW 255
68698: ST_TO_ADDR
// dep := dep [ 1 ] ;
68699: LD_ADDR_VAR 0 9
68703: PUSH
68704: LD_VAR 0 9
68708: PUSH
68709: LD_INT 1
68711: ARRAY
68712: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68713: LD_ADDR_VAR 0 7
68717: PUSH
68718: LD_EXP 51
68722: PUSH
68723: LD_VAR 0 2
68727: ARRAY
68728: PPUSH
68729: LD_INT 22
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 25
68741: PUSH
68742: LD_INT 12
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PPUSH
68753: CALL_OW 70
68757: PUSH
68758: LD_INT 22
68760: PUSH
68761: LD_INT 0
68763: PUSH
68764: EMPTY
68765: LIST
68766: LIST
68767: PUSH
68768: LD_INT 25
68770: PUSH
68771: LD_INT 12
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: PUSH
68778: LD_INT 91
68780: PUSH
68781: LD_VAR 0 9
68785: PUSH
68786: LD_INT 20
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: LIST
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: LIST
68798: PPUSH
68799: CALL_OW 69
68803: UNION
68804: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
68805: LD_ADDR_VAR 0 10
68809: PUSH
68810: LD_EXP 51
68814: PUSH
68815: LD_VAR 0 2
68819: ARRAY
68820: PPUSH
68821: LD_INT 81
68823: PUSH
68824: LD_VAR 0 11
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PPUSH
68833: CALL_OW 70
68837: ST_TO_ADDR
// if not apes or danger_at_area then
68838: LD_VAR 0 7
68842: NOT
68843: PUSH
68844: LD_VAR 0 10
68848: OR
68849: IFFALSE 68899
// begin if mc_taming [ i ] then
68851: LD_EXP 54
68855: PUSH
68856: LD_VAR 0 2
68860: ARRAY
68861: IFFALSE 68897
// begin MC_Reset ( i , 121 ) ;
68863: LD_VAR 0 2
68867: PPUSH
68868: LD_INT 121
68870: PPUSH
68871: CALL 54032 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
68875: LD_ADDR_EXP 54
68879: PUSH
68880: LD_EXP 54
68884: PPUSH
68885: LD_VAR 0 2
68889: PPUSH
68890: EMPTY
68891: PPUSH
68892: CALL_OW 1
68896: ST_TO_ADDR
// end ; continue ;
68897: GO 68465
// end ; for j in tmp do
68899: LD_ADDR_VAR 0 3
68903: PUSH
68904: LD_VAR 0 8
68908: PUSH
68909: FOR_IN
68910: IFFALSE 69246
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
68912: LD_VAR 0 3
68916: PUSH
68917: LD_EXP 54
68921: PUSH
68922: LD_VAR 0 2
68926: ARRAY
68927: IN
68928: NOT
68929: PUSH
68930: LD_EXP 54
68934: PUSH
68935: LD_VAR 0 2
68939: ARRAY
68940: PUSH
68941: LD_INT 3
68943: LESS
68944: AND
68945: IFFALSE 69003
// begin SetTag ( j , 121 ) ;
68947: LD_VAR 0 3
68951: PPUSH
68952: LD_INT 121
68954: PPUSH
68955: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
68959: LD_ADDR_EXP 54
68963: PUSH
68964: LD_EXP 54
68968: PPUSH
68969: LD_VAR 0 2
68973: PUSH
68974: LD_EXP 54
68978: PUSH
68979: LD_VAR 0 2
68983: ARRAY
68984: PUSH
68985: LD_INT 1
68987: PLUS
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PPUSH
68993: LD_VAR 0 3
68997: PPUSH
68998: CALL 15990 0 3
69002: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69003: LD_VAR 0 3
69007: PUSH
69008: LD_EXP 54
69012: PUSH
69013: LD_VAR 0 2
69017: ARRAY
69018: IN
69019: IFFALSE 69244
// begin if GetClass ( j ) <> 4 then
69021: LD_VAR 0 3
69025: PPUSH
69026: CALL_OW 257
69030: PUSH
69031: LD_INT 4
69033: NONEQUAL
69034: IFFALSE 69087
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69036: LD_ADDR_EXP 54
69040: PUSH
69041: LD_EXP 54
69045: PPUSH
69046: LD_VAR 0 2
69050: PPUSH
69051: LD_EXP 54
69055: PUSH
69056: LD_VAR 0 2
69060: ARRAY
69061: PUSH
69062: LD_VAR 0 3
69066: DIFF
69067: PPUSH
69068: CALL_OW 1
69072: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69073: LD_VAR 0 3
69077: PPUSH
69078: LD_INT 0
69080: PPUSH
69081: CALL_OW 109
// continue ;
69085: GO 68909
// end ; if IsInUnit ( j ) then
69087: LD_VAR 0 3
69091: PPUSH
69092: CALL_OW 310
69096: IFFALSE 69107
// ComExitBuilding ( j ) ;
69098: LD_VAR 0 3
69102: PPUSH
69103: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69107: LD_ADDR_VAR 0 6
69111: PUSH
69112: LD_VAR 0 7
69116: PPUSH
69117: LD_VAR 0 3
69121: PPUSH
69122: CALL_OW 74
69126: ST_TO_ADDR
// if not ape then
69127: LD_VAR 0 6
69131: NOT
69132: IFFALSE 69136
// break ;
69134: GO 69246
// x := GetX ( ape ) ;
69136: LD_ADDR_VAR 0 4
69140: PUSH
69141: LD_VAR 0 6
69145: PPUSH
69146: CALL_OW 250
69150: ST_TO_ADDR
// y := GetY ( ape ) ;
69151: LD_ADDR_VAR 0 5
69155: PUSH
69156: LD_VAR 0 6
69160: PPUSH
69161: CALL_OW 251
69165: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69166: LD_VAR 0 4
69170: PPUSH
69171: LD_VAR 0 5
69175: PPUSH
69176: CALL_OW 488
69180: NOT
69181: PUSH
69182: LD_VAR 0 11
69186: PPUSH
69187: LD_VAR 0 4
69191: PPUSH
69192: LD_VAR 0 5
69196: PPUSH
69197: LD_INT 20
69199: PPUSH
69200: CALL 16886 0 4
69204: PUSH
69205: LD_INT 4
69207: ARRAY
69208: OR
69209: IFFALSE 69213
// break ;
69211: GO 69246
// if not HasTask ( j ) then
69213: LD_VAR 0 3
69217: PPUSH
69218: CALL_OW 314
69222: NOT
69223: IFFALSE 69244
// ComTameXY ( j , x , y ) ;
69225: LD_VAR 0 3
69229: PPUSH
69230: LD_VAR 0 4
69234: PPUSH
69235: LD_VAR 0 5
69239: PPUSH
69240: CALL_OW 131
// end ; end ;
69244: GO 68909
69246: POP
69247: POP
// end ;
69248: GO 68465
69250: POP
69251: POP
// end ;
69252: LD_VAR 0 1
69256: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69257: LD_INT 0
69259: PPUSH
69260: PPUSH
69261: PPUSH
69262: PPUSH
69263: PPUSH
69264: PPUSH
69265: PPUSH
69266: PPUSH
// if not mc_bases then
69267: LD_EXP 23
69271: NOT
69272: IFFALSE 69276
// exit ;
69274: GO 69902
// for i = 1 to mc_bases do
69276: LD_ADDR_VAR 0 2
69280: PUSH
69281: DOUBLE
69282: LD_INT 1
69284: DEC
69285: ST_TO_ADDR
69286: LD_EXP 23
69290: PUSH
69291: FOR_TO
69292: IFFALSE 69900
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69294: LD_EXP 52
69298: PUSH
69299: LD_VAR 0 2
69303: ARRAY
69304: NOT
69305: PUSH
69306: LD_EXP 52
69310: PUSH
69311: LD_VAR 0 2
69315: ARRAY
69316: PPUSH
69317: LD_INT 25
69319: PUSH
69320: LD_INT 12
69322: PUSH
69323: EMPTY
69324: LIST
69325: LIST
69326: PPUSH
69327: CALL_OW 72
69331: NOT
69332: OR
69333: IFFALSE 69337
// continue ;
69335: GO 69291
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69337: LD_ADDR_VAR 0 5
69341: PUSH
69342: LD_EXP 52
69346: PUSH
69347: LD_VAR 0 2
69351: ARRAY
69352: PUSH
69353: LD_INT 1
69355: ARRAY
69356: PPUSH
69357: CALL_OW 255
69361: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69362: LD_VAR 0 5
69366: PPUSH
69367: LD_INT 2
69369: PPUSH
69370: CALL_OW 325
69374: IFFALSE 69627
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69376: LD_ADDR_VAR 0 4
69380: PUSH
69381: LD_EXP 52
69385: PUSH
69386: LD_VAR 0 2
69390: ARRAY
69391: PPUSH
69392: LD_INT 25
69394: PUSH
69395: LD_INT 16
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PPUSH
69402: CALL_OW 72
69406: ST_TO_ADDR
// if tmp < 6 then
69407: LD_VAR 0 4
69411: PUSH
69412: LD_INT 6
69414: LESS
69415: IFFALSE 69627
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69417: LD_ADDR_VAR 0 6
69421: PUSH
69422: LD_EXP 23
69426: PUSH
69427: LD_VAR 0 2
69431: ARRAY
69432: PPUSH
69433: LD_INT 2
69435: PUSH
69436: LD_INT 30
69438: PUSH
69439: LD_INT 0
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: LD_INT 30
69448: PUSH
69449: LD_INT 1
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: LIST
69460: PPUSH
69461: CALL_OW 72
69465: ST_TO_ADDR
// if depot then
69466: LD_VAR 0 6
69470: IFFALSE 69627
// begin selected := 0 ;
69472: LD_ADDR_VAR 0 7
69476: PUSH
69477: LD_INT 0
69479: ST_TO_ADDR
// for j in depot do
69480: LD_ADDR_VAR 0 3
69484: PUSH
69485: LD_VAR 0 6
69489: PUSH
69490: FOR_IN
69491: IFFALSE 69522
// begin if UnitsInside ( j ) < 6 then
69493: LD_VAR 0 3
69497: PPUSH
69498: CALL_OW 313
69502: PUSH
69503: LD_INT 6
69505: LESS
69506: IFFALSE 69520
// begin selected := j ;
69508: LD_ADDR_VAR 0 7
69512: PUSH
69513: LD_VAR 0 3
69517: ST_TO_ADDR
// break ;
69518: GO 69522
// end ; end ;
69520: GO 69490
69522: POP
69523: POP
// if selected then
69524: LD_VAR 0 7
69528: IFFALSE 69627
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69530: LD_ADDR_VAR 0 3
69534: PUSH
69535: LD_EXP 52
69539: PUSH
69540: LD_VAR 0 2
69544: ARRAY
69545: PPUSH
69546: LD_INT 25
69548: PUSH
69549: LD_INT 12
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PPUSH
69556: CALL_OW 72
69560: PUSH
69561: FOR_IN
69562: IFFALSE 69625
// if not HasTask ( j ) then
69564: LD_VAR 0 3
69568: PPUSH
69569: CALL_OW 314
69573: NOT
69574: IFFALSE 69623
// begin if not IsInUnit ( j ) then
69576: LD_VAR 0 3
69580: PPUSH
69581: CALL_OW 310
69585: NOT
69586: IFFALSE 69602
// ComEnterUnit ( j , selected ) ;
69588: LD_VAR 0 3
69592: PPUSH
69593: LD_VAR 0 7
69597: PPUSH
69598: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
69602: LD_VAR 0 3
69606: PPUSH
69607: LD_INT 16
69609: PPUSH
69610: CALL_OW 183
// AddComExitBuilding ( j ) ;
69614: LD_VAR 0 3
69618: PPUSH
69619: CALL_OW 182
// end ;
69623: GO 69561
69625: POP
69626: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69627: LD_VAR 0 5
69631: PPUSH
69632: LD_INT 11
69634: PPUSH
69635: CALL_OW 325
69639: IFFALSE 69898
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69641: LD_ADDR_VAR 0 4
69645: PUSH
69646: LD_EXP 52
69650: PUSH
69651: LD_VAR 0 2
69655: ARRAY
69656: PPUSH
69657: LD_INT 25
69659: PUSH
69660: LD_INT 16
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PPUSH
69667: CALL_OW 72
69671: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69672: LD_VAR 0 4
69676: PUSH
69677: LD_INT 6
69679: GREATEREQUAL
69680: PUSH
69681: LD_VAR 0 5
69685: PPUSH
69686: LD_INT 2
69688: PPUSH
69689: CALL_OW 325
69693: NOT
69694: OR
69695: IFFALSE 69898
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69697: LD_ADDR_VAR 0 8
69701: PUSH
69702: LD_EXP 23
69706: PUSH
69707: LD_VAR 0 2
69711: ARRAY
69712: PPUSH
69713: LD_INT 2
69715: PUSH
69716: LD_INT 30
69718: PUSH
69719: LD_INT 4
69721: PUSH
69722: EMPTY
69723: LIST
69724: LIST
69725: PUSH
69726: LD_INT 30
69728: PUSH
69729: LD_INT 5
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: EMPTY
69737: LIST
69738: LIST
69739: LIST
69740: PPUSH
69741: CALL_OW 72
69745: ST_TO_ADDR
// if barracks then
69746: LD_VAR 0 8
69750: IFFALSE 69898
// begin selected := 0 ;
69752: LD_ADDR_VAR 0 7
69756: PUSH
69757: LD_INT 0
69759: ST_TO_ADDR
// for j in barracks do
69760: LD_ADDR_VAR 0 3
69764: PUSH
69765: LD_VAR 0 8
69769: PUSH
69770: FOR_IN
69771: IFFALSE 69802
// begin if UnitsInside ( j ) < 6 then
69773: LD_VAR 0 3
69777: PPUSH
69778: CALL_OW 313
69782: PUSH
69783: LD_INT 6
69785: LESS
69786: IFFALSE 69800
// begin selected := j ;
69788: LD_ADDR_VAR 0 7
69792: PUSH
69793: LD_VAR 0 3
69797: ST_TO_ADDR
// break ;
69798: GO 69802
// end ; end ;
69800: GO 69770
69802: POP
69803: POP
// if selected then
69804: LD_VAR 0 7
69808: IFFALSE 69898
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69810: LD_ADDR_VAR 0 3
69814: PUSH
69815: LD_EXP 52
69819: PUSH
69820: LD_VAR 0 2
69824: ARRAY
69825: PPUSH
69826: LD_INT 25
69828: PUSH
69829: LD_INT 12
69831: PUSH
69832: EMPTY
69833: LIST
69834: LIST
69835: PPUSH
69836: CALL_OW 72
69840: PUSH
69841: FOR_IN
69842: IFFALSE 69896
// if not IsInUnit ( j ) and not HasTask ( j ) then
69844: LD_VAR 0 3
69848: PPUSH
69849: CALL_OW 310
69853: NOT
69854: PUSH
69855: LD_VAR 0 3
69859: PPUSH
69860: CALL_OW 314
69864: NOT
69865: AND
69866: IFFALSE 69894
// begin ComEnterUnit ( j , selected ) ;
69868: LD_VAR 0 3
69872: PPUSH
69873: LD_VAR 0 7
69877: PPUSH
69878: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
69882: LD_VAR 0 3
69886: PPUSH
69887: LD_INT 15
69889: PPUSH
69890: CALL_OW 183
// end ;
69894: GO 69841
69896: POP
69897: POP
// end ; end ; end ; end ; end ;
69898: GO 69291
69900: POP
69901: POP
// end ;
69902: LD_VAR 0 1
69906: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
69907: LD_INT 0
69909: PPUSH
69910: PPUSH
69911: PPUSH
69912: PPUSH
// if not mc_bases then
69913: LD_EXP 23
69917: NOT
69918: IFFALSE 69922
// exit ;
69920: GO 70100
// for i = 1 to mc_bases do
69922: LD_ADDR_VAR 0 2
69926: PUSH
69927: DOUBLE
69928: LD_INT 1
69930: DEC
69931: ST_TO_ADDR
69932: LD_EXP 23
69936: PUSH
69937: FOR_TO
69938: IFFALSE 70098
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
69940: LD_ADDR_VAR 0 4
69944: PUSH
69945: LD_EXP 23
69949: PUSH
69950: LD_VAR 0 2
69954: ARRAY
69955: PPUSH
69956: LD_INT 25
69958: PUSH
69959: LD_INT 9
69961: PUSH
69962: EMPTY
69963: LIST
69964: LIST
69965: PPUSH
69966: CALL_OW 72
69970: ST_TO_ADDR
// if not tmp then
69971: LD_VAR 0 4
69975: NOT
69976: IFFALSE 69980
// continue ;
69978: GO 69937
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
69980: LD_EXP 49
69984: PUSH
69985: LD_VAR 0 2
69989: ARRAY
69990: PPUSH
69991: LD_INT 29
69993: PPUSH
69994: CALL_OW 325
69998: NOT
69999: PUSH
70000: LD_EXP 49
70004: PUSH
70005: LD_VAR 0 2
70009: ARRAY
70010: PPUSH
70011: LD_INT 28
70013: PPUSH
70014: CALL_OW 325
70018: NOT
70019: AND
70020: IFFALSE 70024
// continue ;
70022: GO 69937
// for j in tmp do
70024: LD_ADDR_VAR 0 3
70028: PUSH
70029: LD_VAR 0 4
70033: PUSH
70034: FOR_IN
70035: IFFALSE 70094
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70037: LD_VAR 0 3
70041: PUSH
70042: LD_EXP 26
70046: PUSH
70047: LD_VAR 0 2
70051: ARRAY
70052: PUSH
70053: LD_INT 1
70055: ARRAY
70056: IN
70057: NOT
70058: PUSH
70059: LD_VAR 0 3
70063: PUSH
70064: LD_EXP 26
70068: PUSH
70069: LD_VAR 0 2
70073: ARRAY
70074: PUSH
70075: LD_INT 2
70077: ARRAY
70078: IN
70079: NOT
70080: AND
70081: IFFALSE 70092
// ComSpaceTimeShoot ( j ) ;
70083: LD_VAR 0 3
70087: PPUSH
70088: CALL 11951 0 1
70092: GO 70034
70094: POP
70095: POP
// end ;
70096: GO 69937
70098: POP
70099: POP
// end ;
70100: LD_VAR 0 1
70104: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70105: LD_INT 0
70107: PPUSH
70108: PPUSH
70109: PPUSH
70110: PPUSH
70111: PPUSH
70112: PPUSH
70113: PPUSH
70114: PPUSH
70115: PPUSH
// if not mc_bases then
70116: LD_EXP 23
70120: NOT
70121: IFFALSE 70125
// exit ;
70123: GO 70747
// for i = 1 to mc_bases do
70125: LD_ADDR_VAR 0 2
70129: PUSH
70130: DOUBLE
70131: LD_INT 1
70133: DEC
70134: ST_TO_ADDR
70135: LD_EXP 23
70139: PUSH
70140: FOR_TO
70141: IFFALSE 70745
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70143: LD_EXP 58
70147: PUSH
70148: LD_VAR 0 2
70152: ARRAY
70153: NOT
70154: PUSH
70155: LD_INT 38
70157: PPUSH
70158: LD_EXP 49
70162: PUSH
70163: LD_VAR 0 2
70167: ARRAY
70168: PPUSH
70169: CALL_OW 321
70173: PUSH
70174: LD_INT 2
70176: NONEQUAL
70177: OR
70178: IFFALSE 70182
// continue ;
70180: GO 70140
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70182: LD_ADDR_VAR 0 8
70186: PUSH
70187: LD_EXP 23
70191: PUSH
70192: LD_VAR 0 2
70196: ARRAY
70197: PPUSH
70198: LD_INT 30
70200: PUSH
70201: LD_INT 34
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PPUSH
70208: CALL_OW 72
70212: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70213: LD_ADDR_VAR 0 9
70217: PUSH
70218: LD_EXP 23
70222: PUSH
70223: LD_VAR 0 2
70227: ARRAY
70228: PPUSH
70229: LD_INT 25
70231: PUSH
70232: LD_INT 4
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: PPUSH
70239: CALL_OW 72
70243: PPUSH
70244: LD_INT 0
70246: PPUSH
70247: CALL 45259 0 2
70251: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70252: LD_VAR 0 9
70256: NOT
70257: PUSH
70258: LD_VAR 0 8
70262: NOT
70263: OR
70264: PUSH
70265: LD_EXP 23
70269: PUSH
70270: LD_VAR 0 2
70274: ARRAY
70275: PPUSH
70276: LD_INT 124
70278: PPUSH
70279: CALL 45259 0 2
70283: OR
70284: IFFALSE 70288
// continue ;
70286: GO 70140
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70288: LD_EXP 59
70292: PUSH
70293: LD_VAR 0 2
70297: ARRAY
70298: PUSH
70299: LD_EXP 58
70303: PUSH
70304: LD_VAR 0 2
70308: ARRAY
70309: LESS
70310: PUSH
70311: LD_EXP 59
70315: PUSH
70316: LD_VAR 0 2
70320: ARRAY
70321: PUSH
70322: LD_VAR 0 8
70326: LESS
70327: AND
70328: IFFALSE 70743
// begin tmp := sci [ 1 ] ;
70330: LD_ADDR_VAR 0 7
70334: PUSH
70335: LD_VAR 0 9
70339: PUSH
70340: LD_INT 1
70342: ARRAY
70343: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70344: LD_VAR 0 7
70348: PPUSH
70349: LD_INT 124
70351: PPUSH
70352: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70356: LD_ADDR_VAR 0 3
70360: PUSH
70361: DOUBLE
70362: LD_EXP 58
70366: PUSH
70367: LD_VAR 0 2
70371: ARRAY
70372: INC
70373: ST_TO_ADDR
70374: LD_EXP 58
70378: PUSH
70379: LD_VAR 0 2
70383: ARRAY
70384: PUSH
70385: FOR_DOWNTO
70386: IFFALSE 70729
// begin if IsInUnit ( tmp ) then
70388: LD_VAR 0 7
70392: PPUSH
70393: CALL_OW 310
70397: IFFALSE 70408
// ComExitBuilding ( tmp ) ;
70399: LD_VAR 0 7
70403: PPUSH
70404: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70408: LD_INT 35
70410: PPUSH
70411: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70415: LD_VAR 0 7
70419: PPUSH
70420: CALL_OW 310
70424: NOT
70425: PUSH
70426: LD_VAR 0 7
70430: PPUSH
70431: CALL_OW 314
70435: NOT
70436: AND
70437: IFFALSE 70408
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70439: LD_ADDR_VAR 0 6
70443: PUSH
70444: LD_VAR 0 7
70448: PPUSH
70449: CALL_OW 250
70453: PUSH
70454: LD_VAR 0 7
70458: PPUSH
70459: CALL_OW 251
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70468: LD_INT 35
70470: PPUSH
70471: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70475: LD_ADDR_VAR 0 4
70479: PUSH
70480: LD_EXP 58
70484: PUSH
70485: LD_VAR 0 2
70489: ARRAY
70490: PUSH
70491: LD_VAR 0 3
70495: ARRAY
70496: PUSH
70497: LD_INT 1
70499: ARRAY
70500: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70501: LD_ADDR_VAR 0 5
70505: PUSH
70506: LD_EXP 58
70510: PUSH
70511: LD_VAR 0 2
70515: ARRAY
70516: PUSH
70517: LD_VAR 0 3
70521: ARRAY
70522: PUSH
70523: LD_INT 2
70525: ARRAY
70526: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70527: LD_VAR 0 7
70531: PPUSH
70532: LD_INT 10
70534: PPUSH
70535: CALL 18589 0 2
70539: PUSH
70540: LD_INT 4
70542: ARRAY
70543: IFFALSE 70581
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70545: LD_VAR 0 7
70549: PPUSH
70550: LD_VAR 0 6
70554: PUSH
70555: LD_INT 1
70557: ARRAY
70558: PPUSH
70559: LD_VAR 0 6
70563: PUSH
70564: LD_INT 2
70566: ARRAY
70567: PPUSH
70568: CALL_OW 111
// wait ( 0 0$10 ) ;
70572: LD_INT 350
70574: PPUSH
70575: CALL_OW 67
// end else
70579: GO 70607
// begin ComMoveXY ( tmp , x , y ) ;
70581: LD_VAR 0 7
70585: PPUSH
70586: LD_VAR 0 4
70590: PPUSH
70591: LD_VAR 0 5
70595: PPUSH
70596: CALL_OW 111
// wait ( 0 0$3 ) ;
70600: LD_INT 105
70602: PPUSH
70603: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
70607: LD_VAR 0 7
70611: PPUSH
70612: LD_VAR 0 4
70616: PPUSH
70617: LD_VAR 0 5
70621: PPUSH
70622: CALL_OW 307
70626: IFFALSE 70468
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70628: LD_VAR 0 7
70632: PPUSH
70633: LD_VAR 0 4
70637: PPUSH
70638: LD_VAR 0 5
70642: PPUSH
70643: LD_VAR 0 8
70647: PUSH
70648: LD_VAR 0 3
70652: ARRAY
70653: PPUSH
70654: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
70658: LD_INT 35
70660: PPUSH
70661: CALL_OW 67
// until not HasTask ( tmp ) ;
70665: LD_VAR 0 7
70669: PPUSH
70670: CALL_OW 314
70674: NOT
70675: IFFALSE 70658
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70677: LD_ADDR_EXP 59
70681: PUSH
70682: LD_EXP 59
70686: PPUSH
70687: LD_VAR 0 2
70691: PUSH
70692: LD_EXP 59
70696: PUSH
70697: LD_VAR 0 2
70701: ARRAY
70702: PUSH
70703: LD_INT 1
70705: PLUS
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PPUSH
70711: LD_VAR 0 8
70715: PUSH
70716: LD_VAR 0 3
70720: ARRAY
70721: PPUSH
70722: CALL 15990 0 3
70726: ST_TO_ADDR
// end ;
70727: GO 70385
70729: POP
70730: POP
// MC_Reset ( i , 124 ) ;
70731: LD_VAR 0 2
70735: PPUSH
70736: LD_INT 124
70738: PPUSH
70739: CALL 54032 0 2
// end ; end ;
70743: GO 70140
70745: POP
70746: POP
// end ;
70747: LD_VAR 0 1
70751: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
70752: LD_INT 0
70754: PPUSH
70755: PPUSH
70756: PPUSH
// if not mc_bases then
70757: LD_EXP 23
70761: NOT
70762: IFFALSE 70766
// exit ;
70764: GO 71372
// for i = 1 to mc_bases do
70766: LD_ADDR_VAR 0 2
70770: PUSH
70771: DOUBLE
70772: LD_INT 1
70774: DEC
70775: ST_TO_ADDR
70776: LD_EXP 23
70780: PUSH
70781: FOR_TO
70782: IFFALSE 71370
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70784: LD_ADDR_VAR 0 3
70788: PUSH
70789: LD_EXP 23
70793: PUSH
70794: LD_VAR 0 2
70798: ARRAY
70799: PPUSH
70800: LD_INT 25
70802: PUSH
70803: LD_INT 4
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PPUSH
70810: CALL_OW 72
70814: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
70815: LD_VAR 0 3
70819: NOT
70820: PUSH
70821: LD_EXP 60
70825: PUSH
70826: LD_VAR 0 2
70830: ARRAY
70831: NOT
70832: OR
70833: PUSH
70834: LD_EXP 23
70838: PUSH
70839: LD_VAR 0 2
70843: ARRAY
70844: PPUSH
70845: LD_INT 2
70847: PUSH
70848: LD_INT 30
70850: PUSH
70851: LD_INT 0
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 30
70860: PUSH
70861: LD_INT 1
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: LIST
70872: PPUSH
70873: CALL_OW 72
70877: NOT
70878: OR
70879: IFFALSE 70929
// begin if mc_deposits_finder [ i ] then
70881: LD_EXP 61
70885: PUSH
70886: LD_VAR 0 2
70890: ARRAY
70891: IFFALSE 70927
// begin MC_Reset ( i , 125 ) ;
70893: LD_VAR 0 2
70897: PPUSH
70898: LD_INT 125
70900: PPUSH
70901: CALL 54032 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
70905: LD_ADDR_EXP 61
70909: PUSH
70910: LD_EXP 61
70914: PPUSH
70915: LD_VAR 0 2
70919: PPUSH
70920: EMPTY
70921: PPUSH
70922: CALL_OW 1
70926: ST_TO_ADDR
// end ; continue ;
70927: GO 70781
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
70929: LD_EXP 60
70933: PUSH
70934: LD_VAR 0 2
70938: ARRAY
70939: PUSH
70940: LD_INT 1
70942: ARRAY
70943: PUSH
70944: LD_INT 3
70946: ARRAY
70947: PUSH
70948: LD_INT 1
70950: EQUAL
70951: PUSH
70952: LD_INT 20
70954: PPUSH
70955: LD_EXP 49
70959: PUSH
70960: LD_VAR 0 2
70964: ARRAY
70965: PPUSH
70966: CALL_OW 321
70970: PUSH
70971: LD_INT 2
70973: NONEQUAL
70974: AND
70975: IFFALSE 71025
// begin if mc_deposits_finder [ i ] then
70977: LD_EXP 61
70981: PUSH
70982: LD_VAR 0 2
70986: ARRAY
70987: IFFALSE 71023
// begin MC_Reset ( i , 125 ) ;
70989: LD_VAR 0 2
70993: PPUSH
70994: LD_INT 125
70996: PPUSH
70997: CALL 54032 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71001: LD_ADDR_EXP 61
71005: PUSH
71006: LD_EXP 61
71010: PPUSH
71011: LD_VAR 0 2
71015: PPUSH
71016: EMPTY
71017: PPUSH
71018: CALL_OW 1
71022: ST_TO_ADDR
// end ; continue ;
71023: GO 70781
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71025: LD_EXP 60
71029: PUSH
71030: LD_VAR 0 2
71034: ARRAY
71035: PUSH
71036: LD_INT 1
71038: ARRAY
71039: PUSH
71040: LD_INT 1
71042: ARRAY
71043: PPUSH
71044: LD_EXP 60
71048: PUSH
71049: LD_VAR 0 2
71053: ARRAY
71054: PUSH
71055: LD_INT 1
71057: ARRAY
71058: PUSH
71059: LD_INT 2
71061: ARRAY
71062: PPUSH
71063: LD_EXP 49
71067: PUSH
71068: LD_VAR 0 2
71072: ARRAY
71073: PPUSH
71074: CALL_OW 440
71078: IFFALSE 71121
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71080: LD_ADDR_EXP 60
71084: PUSH
71085: LD_EXP 60
71089: PPUSH
71090: LD_VAR 0 2
71094: PPUSH
71095: LD_EXP 60
71099: PUSH
71100: LD_VAR 0 2
71104: ARRAY
71105: PPUSH
71106: LD_INT 1
71108: PPUSH
71109: CALL_OW 3
71113: PPUSH
71114: CALL_OW 1
71118: ST_TO_ADDR
71119: GO 71368
// begin if not mc_deposits_finder [ i ] then
71121: LD_EXP 61
71125: PUSH
71126: LD_VAR 0 2
71130: ARRAY
71131: NOT
71132: IFFALSE 71184
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71134: LD_ADDR_EXP 61
71138: PUSH
71139: LD_EXP 61
71143: PPUSH
71144: LD_VAR 0 2
71148: PPUSH
71149: LD_VAR 0 3
71153: PUSH
71154: LD_INT 1
71156: ARRAY
71157: PUSH
71158: EMPTY
71159: LIST
71160: PPUSH
71161: CALL_OW 1
71165: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71166: LD_VAR 0 3
71170: PUSH
71171: LD_INT 1
71173: ARRAY
71174: PPUSH
71175: LD_INT 125
71177: PPUSH
71178: CALL_OW 109
// end else
71182: GO 71368
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71184: LD_EXP 61
71188: PUSH
71189: LD_VAR 0 2
71193: ARRAY
71194: PUSH
71195: LD_INT 1
71197: ARRAY
71198: PPUSH
71199: CALL_OW 310
71203: IFFALSE 71226
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71205: LD_EXP 61
71209: PUSH
71210: LD_VAR 0 2
71214: ARRAY
71215: PUSH
71216: LD_INT 1
71218: ARRAY
71219: PPUSH
71220: CALL_OW 122
71224: GO 71368
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71226: LD_EXP 61
71230: PUSH
71231: LD_VAR 0 2
71235: ARRAY
71236: PUSH
71237: LD_INT 1
71239: ARRAY
71240: PPUSH
71241: CALL_OW 314
71245: NOT
71246: PUSH
71247: LD_EXP 61
71251: PUSH
71252: LD_VAR 0 2
71256: ARRAY
71257: PUSH
71258: LD_INT 1
71260: ARRAY
71261: PPUSH
71262: LD_EXP 60
71266: PUSH
71267: LD_VAR 0 2
71271: ARRAY
71272: PUSH
71273: LD_INT 1
71275: ARRAY
71276: PUSH
71277: LD_INT 1
71279: ARRAY
71280: PPUSH
71281: LD_EXP 60
71285: PUSH
71286: LD_VAR 0 2
71290: ARRAY
71291: PUSH
71292: LD_INT 1
71294: ARRAY
71295: PUSH
71296: LD_INT 2
71298: ARRAY
71299: PPUSH
71300: CALL_OW 297
71304: PUSH
71305: LD_INT 6
71307: GREATER
71308: AND
71309: IFFALSE 71368
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71311: LD_EXP 61
71315: PUSH
71316: LD_VAR 0 2
71320: ARRAY
71321: PUSH
71322: LD_INT 1
71324: ARRAY
71325: PPUSH
71326: LD_EXP 60
71330: PUSH
71331: LD_VAR 0 2
71335: ARRAY
71336: PUSH
71337: LD_INT 1
71339: ARRAY
71340: PUSH
71341: LD_INT 1
71343: ARRAY
71344: PPUSH
71345: LD_EXP 60
71349: PUSH
71350: LD_VAR 0 2
71354: ARRAY
71355: PUSH
71356: LD_INT 1
71358: ARRAY
71359: PUSH
71360: LD_INT 2
71362: ARRAY
71363: PPUSH
71364: CALL_OW 111
// end ; end ; end ;
71368: GO 70781
71370: POP
71371: POP
// end ;
71372: LD_VAR 0 1
71376: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71377: LD_INT 0
71379: PPUSH
71380: PPUSH
71381: PPUSH
71382: PPUSH
71383: PPUSH
71384: PPUSH
71385: PPUSH
71386: PPUSH
71387: PPUSH
71388: PPUSH
71389: PPUSH
// if not mc_bases then
71390: LD_EXP 23
71394: NOT
71395: IFFALSE 71399
// exit ;
71397: GO 72339
// for i = 1 to mc_bases do
71399: LD_ADDR_VAR 0 2
71403: PUSH
71404: DOUBLE
71405: LD_INT 1
71407: DEC
71408: ST_TO_ADDR
71409: LD_EXP 23
71413: PUSH
71414: FOR_TO
71415: IFFALSE 72337
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71417: LD_EXP 23
71421: PUSH
71422: LD_VAR 0 2
71426: ARRAY
71427: NOT
71428: PUSH
71429: LD_EXP 46
71433: PUSH
71434: LD_VAR 0 2
71438: ARRAY
71439: OR
71440: IFFALSE 71444
// continue ;
71442: GO 71414
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71444: LD_ADDR_VAR 0 7
71448: PUSH
71449: LD_EXP 23
71453: PUSH
71454: LD_VAR 0 2
71458: ARRAY
71459: PUSH
71460: LD_INT 1
71462: ARRAY
71463: PPUSH
71464: CALL_OW 248
71468: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71469: LD_VAR 0 7
71473: PUSH
71474: LD_INT 3
71476: EQUAL
71477: PUSH
71478: LD_EXP 42
71482: PUSH
71483: LD_VAR 0 2
71487: ARRAY
71488: PUSH
71489: LD_EXP 45
71493: PUSH
71494: LD_VAR 0 2
71498: ARRAY
71499: UNION
71500: PPUSH
71501: LD_INT 33
71503: PUSH
71504: LD_INT 2
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PPUSH
71511: CALL_OW 72
71515: NOT
71516: OR
71517: IFFALSE 71521
// continue ;
71519: GO 71414
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71521: LD_ADDR_VAR 0 9
71525: PUSH
71526: LD_EXP 23
71530: PUSH
71531: LD_VAR 0 2
71535: ARRAY
71536: PPUSH
71537: LD_INT 30
71539: PUSH
71540: LD_INT 36
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PPUSH
71547: CALL_OW 72
71551: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71552: LD_ADDR_VAR 0 10
71556: PUSH
71557: LD_EXP 42
71561: PUSH
71562: LD_VAR 0 2
71566: ARRAY
71567: PPUSH
71568: LD_INT 34
71570: PUSH
71571: LD_INT 31
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PPUSH
71578: CALL_OW 72
71582: ST_TO_ADDR
// if not cts and not mcts then
71583: LD_VAR 0 9
71587: NOT
71588: PUSH
71589: LD_VAR 0 10
71593: NOT
71594: AND
71595: IFFALSE 71599
// continue ;
71597: GO 71414
// x := cts ;
71599: LD_ADDR_VAR 0 11
71603: PUSH
71604: LD_VAR 0 9
71608: ST_TO_ADDR
// if not x then
71609: LD_VAR 0 11
71613: NOT
71614: IFFALSE 71626
// x := mcts ;
71616: LD_ADDR_VAR 0 11
71620: PUSH
71621: LD_VAR 0 10
71625: ST_TO_ADDR
// if not x then
71626: LD_VAR 0 11
71630: NOT
71631: IFFALSE 71635
// continue ;
71633: GO 71414
// if mc_remote_driver [ i ] then
71635: LD_EXP 63
71639: PUSH
71640: LD_VAR 0 2
71644: ARRAY
71645: IFFALSE 72032
// for j in mc_remote_driver [ i ] do
71647: LD_ADDR_VAR 0 3
71651: PUSH
71652: LD_EXP 63
71656: PUSH
71657: LD_VAR 0 2
71661: ARRAY
71662: PUSH
71663: FOR_IN
71664: IFFALSE 72030
// begin if GetClass ( j ) <> 3 then
71666: LD_VAR 0 3
71670: PPUSH
71671: CALL_OW 257
71675: PUSH
71676: LD_INT 3
71678: NONEQUAL
71679: IFFALSE 71732
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71681: LD_ADDR_EXP 63
71685: PUSH
71686: LD_EXP 63
71690: PPUSH
71691: LD_VAR 0 2
71695: PPUSH
71696: LD_EXP 63
71700: PUSH
71701: LD_VAR 0 2
71705: ARRAY
71706: PUSH
71707: LD_VAR 0 3
71711: DIFF
71712: PPUSH
71713: CALL_OW 1
71717: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71718: LD_VAR 0 3
71722: PPUSH
71723: LD_INT 0
71725: PPUSH
71726: CALL_OW 109
// continue ;
71730: GO 71663
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71732: LD_EXP 42
71736: PUSH
71737: LD_VAR 0 2
71741: ARRAY
71742: PPUSH
71743: LD_INT 34
71745: PUSH
71746: LD_INT 31
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 58
71755: PUSH
71756: EMPTY
71757: LIST
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PPUSH
71763: CALL_OW 72
71767: PUSH
71768: LD_VAR 0 3
71772: PPUSH
71773: CALL 45347 0 1
71777: NOT
71778: AND
71779: IFFALSE 71850
// begin if IsInUnit ( j ) then
71781: LD_VAR 0 3
71785: PPUSH
71786: CALL_OW 310
71790: IFFALSE 71801
// ComExitBuilding ( j ) ;
71792: LD_VAR 0 3
71796: PPUSH
71797: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
71801: LD_VAR 0 3
71805: PPUSH
71806: LD_EXP 42
71810: PUSH
71811: LD_VAR 0 2
71815: ARRAY
71816: PPUSH
71817: LD_INT 34
71819: PUSH
71820: LD_INT 31
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 58
71829: PUSH
71830: EMPTY
71831: LIST
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PPUSH
71837: CALL_OW 72
71841: PUSH
71842: LD_INT 1
71844: ARRAY
71845: PPUSH
71846: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
71850: LD_VAR 0 3
71854: PPUSH
71855: CALL_OW 310
71859: NOT
71860: PUSH
71861: LD_VAR 0 3
71865: PPUSH
71866: CALL_OW 310
71870: PPUSH
71871: CALL_OW 266
71875: PUSH
71876: LD_INT 36
71878: NONEQUAL
71879: PUSH
71880: LD_VAR 0 3
71884: PPUSH
71885: CALL 45347 0 1
71889: NOT
71890: AND
71891: OR
71892: IFFALSE 72028
// begin if IsInUnit ( j ) then
71894: LD_VAR 0 3
71898: PPUSH
71899: CALL_OW 310
71903: IFFALSE 71914
// ComExitBuilding ( j ) ;
71905: LD_VAR 0 3
71909: PPUSH
71910: CALL_OW 122
// ct := 0 ;
71914: LD_ADDR_VAR 0 8
71918: PUSH
71919: LD_INT 0
71921: ST_TO_ADDR
// for k in x do
71922: LD_ADDR_VAR 0 4
71926: PUSH
71927: LD_VAR 0 11
71931: PUSH
71932: FOR_IN
71933: IFFALSE 72006
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
71935: LD_VAR 0 4
71939: PPUSH
71940: CALL_OW 264
71944: PUSH
71945: LD_INT 31
71947: EQUAL
71948: PUSH
71949: LD_VAR 0 4
71953: PPUSH
71954: CALL_OW 311
71958: NOT
71959: AND
71960: PUSH
71961: LD_VAR 0 4
71965: PPUSH
71966: CALL_OW 266
71970: PUSH
71971: LD_INT 36
71973: EQUAL
71974: PUSH
71975: LD_VAR 0 4
71979: PPUSH
71980: CALL_OW 313
71984: PUSH
71985: LD_INT 3
71987: LESS
71988: AND
71989: OR
71990: IFFALSE 72004
// begin ct := k ;
71992: LD_ADDR_VAR 0 8
71996: PUSH
71997: LD_VAR 0 4
72001: ST_TO_ADDR
// break ;
72002: GO 72006
// end ;
72004: GO 71932
72006: POP
72007: POP
// if ct then
72008: LD_VAR 0 8
72012: IFFALSE 72028
// ComEnterUnit ( j , ct ) ;
72014: LD_VAR 0 3
72018: PPUSH
72019: LD_VAR 0 8
72023: PPUSH
72024: CALL_OW 120
// end ; end ;
72028: GO 71663
72030: POP
72031: POP
// places := 0 ;
72032: LD_ADDR_VAR 0 5
72036: PUSH
72037: LD_INT 0
72039: ST_TO_ADDR
// for j = 1 to x do
72040: LD_ADDR_VAR 0 3
72044: PUSH
72045: DOUBLE
72046: LD_INT 1
72048: DEC
72049: ST_TO_ADDR
72050: LD_VAR 0 11
72054: PUSH
72055: FOR_TO
72056: IFFALSE 72132
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72058: LD_VAR 0 11
72062: PUSH
72063: LD_VAR 0 3
72067: ARRAY
72068: PPUSH
72069: CALL_OW 264
72073: PUSH
72074: LD_INT 31
72076: EQUAL
72077: IFFALSE 72095
// places := places + 1 else
72079: LD_ADDR_VAR 0 5
72083: PUSH
72084: LD_VAR 0 5
72088: PUSH
72089: LD_INT 1
72091: PLUS
72092: ST_TO_ADDR
72093: GO 72130
// if GetBType ( x [ j ] ) = b_control_tower then
72095: LD_VAR 0 11
72099: PUSH
72100: LD_VAR 0 3
72104: ARRAY
72105: PPUSH
72106: CALL_OW 266
72110: PUSH
72111: LD_INT 36
72113: EQUAL
72114: IFFALSE 72130
// places := places + 3 ;
72116: LD_ADDR_VAR 0 5
72120: PUSH
72121: LD_VAR 0 5
72125: PUSH
72126: LD_INT 3
72128: PLUS
72129: ST_TO_ADDR
72130: GO 72055
72132: POP
72133: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72134: LD_VAR 0 5
72138: PUSH
72139: LD_INT 0
72141: EQUAL
72142: PUSH
72143: LD_VAR 0 5
72147: PUSH
72148: LD_EXP 63
72152: PUSH
72153: LD_VAR 0 2
72157: ARRAY
72158: LESSEQUAL
72159: OR
72160: IFFALSE 72164
// continue ;
72162: GO 71414
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72164: LD_ADDR_VAR 0 6
72168: PUSH
72169: LD_EXP 23
72173: PUSH
72174: LD_VAR 0 2
72178: ARRAY
72179: PPUSH
72180: LD_INT 25
72182: PUSH
72183: LD_INT 3
72185: PUSH
72186: EMPTY
72187: LIST
72188: LIST
72189: PPUSH
72190: CALL_OW 72
72194: PUSH
72195: LD_EXP 63
72199: PUSH
72200: LD_VAR 0 2
72204: ARRAY
72205: DIFF
72206: PPUSH
72207: LD_INT 3
72209: PPUSH
72210: CALL 46247 0 2
72214: ST_TO_ADDR
// for j in tmp do
72215: LD_ADDR_VAR 0 3
72219: PUSH
72220: LD_VAR 0 6
72224: PUSH
72225: FOR_IN
72226: IFFALSE 72261
// if GetTag ( j ) > 0 then
72228: LD_VAR 0 3
72232: PPUSH
72233: CALL_OW 110
72237: PUSH
72238: LD_INT 0
72240: GREATER
72241: IFFALSE 72259
// tmp := tmp diff j ;
72243: LD_ADDR_VAR 0 6
72247: PUSH
72248: LD_VAR 0 6
72252: PUSH
72253: LD_VAR 0 3
72257: DIFF
72258: ST_TO_ADDR
72259: GO 72225
72261: POP
72262: POP
// if not tmp then
72263: LD_VAR 0 6
72267: NOT
72268: IFFALSE 72272
// continue ;
72270: GO 71414
// if places then
72272: LD_VAR 0 5
72276: IFFALSE 72335
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72278: LD_ADDR_EXP 63
72282: PUSH
72283: LD_EXP 63
72287: PPUSH
72288: LD_VAR 0 2
72292: PPUSH
72293: LD_EXP 63
72297: PUSH
72298: LD_VAR 0 2
72302: ARRAY
72303: PUSH
72304: LD_VAR 0 6
72308: PUSH
72309: LD_INT 1
72311: ARRAY
72312: UNION
72313: PPUSH
72314: CALL_OW 1
72318: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72319: LD_VAR 0 6
72323: PUSH
72324: LD_INT 1
72326: ARRAY
72327: PPUSH
72328: LD_INT 126
72330: PPUSH
72331: CALL_OW 109
// end ; end ;
72335: GO 71414
72337: POP
72338: POP
// end ;
72339: LD_VAR 0 1
72343: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72344: LD_INT 0
72346: PPUSH
72347: PPUSH
72348: PPUSH
72349: PPUSH
72350: PPUSH
72351: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72352: LD_VAR 0 1
72356: NOT
72357: PUSH
72358: LD_VAR 0 2
72362: NOT
72363: OR
72364: PUSH
72365: LD_VAR 0 3
72369: NOT
72370: OR
72371: PUSH
72372: LD_VAR 0 4
72376: PUSH
72377: LD_INT 1
72379: PUSH
72380: LD_INT 2
72382: PUSH
72383: LD_INT 3
72385: PUSH
72386: LD_INT 4
72388: PUSH
72389: LD_INT 5
72391: PUSH
72392: LD_INT 8
72394: PUSH
72395: LD_INT 9
72397: PUSH
72398: LD_INT 15
72400: PUSH
72401: LD_INT 16
72403: PUSH
72404: EMPTY
72405: LIST
72406: LIST
72407: LIST
72408: LIST
72409: LIST
72410: LIST
72411: LIST
72412: LIST
72413: LIST
72414: IN
72415: NOT
72416: OR
72417: IFFALSE 72421
// exit ;
72419: GO 73321
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72421: LD_ADDR_VAR 0 2
72425: PUSH
72426: LD_VAR 0 2
72430: PPUSH
72431: LD_INT 21
72433: PUSH
72434: LD_INT 3
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 24
72443: PUSH
72444: LD_INT 250
72446: PUSH
72447: EMPTY
72448: LIST
72449: LIST
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PPUSH
72455: CALL_OW 72
72459: ST_TO_ADDR
// case class of 1 , 15 :
72460: LD_VAR 0 4
72464: PUSH
72465: LD_INT 1
72467: DOUBLE
72468: EQUAL
72469: IFTRUE 72479
72471: LD_INT 15
72473: DOUBLE
72474: EQUAL
72475: IFTRUE 72479
72477: GO 72564
72479: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72480: LD_ADDR_VAR 0 8
72484: PUSH
72485: LD_VAR 0 2
72489: PPUSH
72490: LD_INT 2
72492: PUSH
72493: LD_INT 30
72495: PUSH
72496: LD_INT 32
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 30
72505: PUSH
72506: LD_INT 31
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: EMPTY
72514: LIST
72515: LIST
72516: LIST
72517: PPUSH
72518: CALL_OW 72
72522: PUSH
72523: LD_VAR 0 2
72527: PPUSH
72528: LD_INT 2
72530: PUSH
72531: LD_INT 30
72533: PUSH
72534: LD_INT 4
72536: PUSH
72537: EMPTY
72538: LIST
72539: LIST
72540: PUSH
72541: LD_INT 30
72543: PUSH
72544: LD_INT 5
72546: PUSH
72547: EMPTY
72548: LIST
72549: LIST
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: LIST
72555: PPUSH
72556: CALL_OW 72
72560: ADD
72561: ST_TO_ADDR
72562: GO 72810
72564: LD_INT 2
72566: DOUBLE
72567: EQUAL
72568: IFTRUE 72578
72570: LD_INT 16
72572: DOUBLE
72573: EQUAL
72574: IFTRUE 72578
72576: GO 72624
72578: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72579: LD_ADDR_VAR 0 8
72583: PUSH
72584: LD_VAR 0 2
72588: PPUSH
72589: LD_INT 2
72591: PUSH
72592: LD_INT 30
72594: PUSH
72595: LD_INT 0
72597: PUSH
72598: EMPTY
72599: LIST
72600: LIST
72601: PUSH
72602: LD_INT 30
72604: PUSH
72605: LD_INT 1
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: PUSH
72612: EMPTY
72613: LIST
72614: LIST
72615: LIST
72616: PPUSH
72617: CALL_OW 72
72621: ST_TO_ADDR
72622: GO 72810
72624: LD_INT 3
72626: DOUBLE
72627: EQUAL
72628: IFTRUE 72632
72630: GO 72678
72632: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72633: LD_ADDR_VAR 0 8
72637: PUSH
72638: LD_VAR 0 2
72642: PPUSH
72643: LD_INT 2
72645: PUSH
72646: LD_INT 30
72648: PUSH
72649: LD_INT 2
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: LD_INT 30
72658: PUSH
72659: LD_INT 3
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: EMPTY
72667: LIST
72668: LIST
72669: LIST
72670: PPUSH
72671: CALL_OW 72
72675: ST_TO_ADDR
72676: GO 72810
72678: LD_INT 4
72680: DOUBLE
72681: EQUAL
72682: IFTRUE 72686
72684: GO 72743
72686: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72687: LD_ADDR_VAR 0 8
72691: PUSH
72692: LD_VAR 0 2
72696: PPUSH
72697: LD_INT 2
72699: PUSH
72700: LD_INT 30
72702: PUSH
72703: LD_INT 6
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PUSH
72710: LD_INT 30
72712: PUSH
72713: LD_INT 7
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: LD_INT 30
72722: PUSH
72723: LD_INT 8
72725: PUSH
72726: EMPTY
72727: LIST
72728: LIST
72729: PUSH
72730: EMPTY
72731: LIST
72732: LIST
72733: LIST
72734: LIST
72735: PPUSH
72736: CALL_OW 72
72740: ST_TO_ADDR
72741: GO 72810
72743: LD_INT 5
72745: DOUBLE
72746: EQUAL
72747: IFTRUE 72763
72749: LD_INT 8
72751: DOUBLE
72752: EQUAL
72753: IFTRUE 72763
72755: LD_INT 9
72757: DOUBLE
72758: EQUAL
72759: IFTRUE 72763
72761: GO 72809
72763: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
72764: LD_ADDR_VAR 0 8
72768: PUSH
72769: LD_VAR 0 2
72773: PPUSH
72774: LD_INT 2
72776: PUSH
72777: LD_INT 30
72779: PUSH
72780: LD_INT 4
72782: PUSH
72783: EMPTY
72784: LIST
72785: LIST
72786: PUSH
72787: LD_INT 30
72789: PUSH
72790: LD_INT 5
72792: PUSH
72793: EMPTY
72794: LIST
72795: LIST
72796: PUSH
72797: EMPTY
72798: LIST
72799: LIST
72800: LIST
72801: PPUSH
72802: CALL_OW 72
72806: ST_TO_ADDR
72807: GO 72810
72809: POP
// if not tmp then
72810: LD_VAR 0 8
72814: NOT
72815: IFFALSE 72819
// exit ;
72817: GO 73321
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
72819: LD_VAR 0 4
72823: PUSH
72824: LD_INT 1
72826: PUSH
72827: LD_INT 15
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: IN
72834: PUSH
72835: LD_EXP 32
72839: PUSH
72840: LD_VAR 0 1
72844: ARRAY
72845: AND
72846: IFFALSE 73002
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
72848: LD_ADDR_VAR 0 9
72852: PUSH
72853: LD_EXP 32
72857: PUSH
72858: LD_VAR 0 1
72862: ARRAY
72863: PUSH
72864: LD_INT 1
72866: ARRAY
72867: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
72868: LD_VAR 0 9
72872: PUSH
72873: LD_EXP 33
72877: PUSH
72878: LD_VAR 0 1
72882: ARRAY
72883: IN
72884: NOT
72885: IFFALSE 73000
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
72887: LD_ADDR_EXP 33
72891: PUSH
72892: LD_EXP 33
72896: PPUSH
72897: LD_VAR 0 1
72901: PUSH
72902: LD_EXP 33
72906: PUSH
72907: LD_VAR 0 1
72911: ARRAY
72912: PUSH
72913: LD_INT 1
72915: PLUS
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: PPUSH
72921: LD_VAR 0 9
72925: PPUSH
72926: CALL 15990 0 3
72930: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
72931: LD_ADDR_EXP 32
72935: PUSH
72936: LD_EXP 32
72940: PPUSH
72941: LD_VAR 0 1
72945: PPUSH
72946: LD_EXP 32
72950: PUSH
72951: LD_VAR 0 1
72955: ARRAY
72956: PUSH
72957: LD_VAR 0 9
72961: DIFF
72962: PPUSH
72963: CALL_OW 1
72967: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
72968: LD_VAR 0 3
72972: PPUSH
72973: LD_EXP 33
72977: PUSH
72978: LD_VAR 0 1
72982: ARRAY
72983: PUSH
72984: LD_EXP 33
72988: PUSH
72989: LD_VAR 0 1
72993: ARRAY
72994: ARRAY
72995: PPUSH
72996: CALL_OW 120
// end ; exit ;
73000: GO 73321
// end ; if tmp > 1 then
73002: LD_VAR 0 8
73006: PUSH
73007: LD_INT 1
73009: GREATER
73010: IFFALSE 73114
// for i = 2 to tmp do
73012: LD_ADDR_VAR 0 6
73016: PUSH
73017: DOUBLE
73018: LD_INT 2
73020: DEC
73021: ST_TO_ADDR
73022: LD_VAR 0 8
73026: PUSH
73027: FOR_TO
73028: IFFALSE 73112
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73030: LD_VAR 0 8
73034: PUSH
73035: LD_VAR 0 6
73039: ARRAY
73040: PPUSH
73041: CALL_OW 461
73045: PUSH
73046: LD_INT 6
73048: EQUAL
73049: IFFALSE 73110
// begin x := tmp [ i ] ;
73051: LD_ADDR_VAR 0 9
73055: PUSH
73056: LD_VAR 0 8
73060: PUSH
73061: LD_VAR 0 6
73065: ARRAY
73066: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73067: LD_ADDR_VAR 0 8
73071: PUSH
73072: LD_VAR 0 8
73076: PPUSH
73077: LD_VAR 0 6
73081: PPUSH
73082: CALL_OW 3
73086: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73087: LD_ADDR_VAR 0 8
73091: PUSH
73092: LD_VAR 0 8
73096: PPUSH
73097: LD_INT 1
73099: PPUSH
73100: LD_VAR 0 9
73104: PPUSH
73105: CALL_OW 2
73109: ST_TO_ADDR
// end ;
73110: GO 73027
73112: POP
73113: POP
// for i in tmp do
73114: LD_ADDR_VAR 0 6
73118: PUSH
73119: LD_VAR 0 8
73123: PUSH
73124: FOR_IN
73125: IFFALSE 73194
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73127: LD_VAR 0 6
73131: PPUSH
73132: CALL_OW 313
73136: PUSH
73137: LD_INT 6
73139: LESS
73140: PUSH
73141: LD_VAR 0 6
73145: PPUSH
73146: CALL_OW 266
73150: PUSH
73151: LD_INT 31
73153: PUSH
73154: LD_INT 32
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: IN
73161: NOT
73162: AND
73163: PUSH
73164: LD_VAR 0 6
73168: PPUSH
73169: CALL_OW 313
73173: PUSH
73174: LD_INT 0
73176: EQUAL
73177: OR
73178: IFFALSE 73192
// begin j := i ;
73180: LD_ADDR_VAR 0 7
73184: PUSH
73185: LD_VAR 0 6
73189: ST_TO_ADDR
// break ;
73190: GO 73194
// end ; end ;
73192: GO 73124
73194: POP
73195: POP
// if j then
73196: LD_VAR 0 7
73200: IFFALSE 73218
// ComEnterUnit ( unit , j ) else
73202: LD_VAR 0 3
73206: PPUSH
73207: LD_VAR 0 7
73211: PPUSH
73212: CALL_OW 120
73216: GO 73321
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73218: LD_ADDR_VAR 0 10
73222: PUSH
73223: LD_VAR 0 2
73227: PPUSH
73228: LD_INT 2
73230: PUSH
73231: LD_INT 30
73233: PUSH
73234: LD_INT 0
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: PUSH
73241: LD_INT 30
73243: PUSH
73244: LD_INT 1
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: LIST
73255: PPUSH
73256: CALL_OW 72
73260: ST_TO_ADDR
// if depot then
73261: LD_VAR 0 10
73265: IFFALSE 73321
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73267: LD_ADDR_VAR 0 10
73271: PUSH
73272: LD_VAR 0 10
73276: PPUSH
73277: LD_VAR 0 3
73281: PPUSH
73282: CALL_OW 74
73286: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73287: LD_VAR 0 3
73291: PPUSH
73292: LD_VAR 0 10
73296: PPUSH
73297: CALL_OW 296
73301: PUSH
73302: LD_INT 10
73304: GREATER
73305: IFFALSE 73321
// ComStandNearbyBuilding ( unit , depot ) ;
73307: LD_VAR 0 3
73311: PPUSH
73312: LD_VAR 0 10
73316: PPUSH
73317: CALL 12568 0 2
// end ; end ; end ;
73321: LD_VAR 0 5
73325: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73326: LD_INT 0
73328: PPUSH
73329: PPUSH
73330: PPUSH
73331: PPUSH
// if not mc_bases then
73332: LD_EXP 23
73336: NOT
73337: IFFALSE 73341
// exit ;
73339: GO 73580
// for i = 1 to mc_bases do
73341: LD_ADDR_VAR 0 2
73345: PUSH
73346: DOUBLE
73347: LD_INT 1
73349: DEC
73350: ST_TO_ADDR
73351: LD_EXP 23
73355: PUSH
73356: FOR_TO
73357: IFFALSE 73578
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73359: LD_ADDR_VAR 0 4
73363: PUSH
73364: LD_EXP 23
73368: PUSH
73369: LD_VAR 0 2
73373: ARRAY
73374: PPUSH
73375: LD_INT 21
73377: PUSH
73378: LD_INT 1
73380: PUSH
73381: EMPTY
73382: LIST
73383: LIST
73384: PPUSH
73385: CALL_OW 72
73389: PUSH
73390: LD_EXP 52
73394: PUSH
73395: LD_VAR 0 2
73399: ARRAY
73400: UNION
73401: ST_TO_ADDR
// if not tmp then
73402: LD_VAR 0 4
73406: NOT
73407: IFFALSE 73411
// continue ;
73409: GO 73356
// for j in tmp do
73411: LD_ADDR_VAR 0 3
73415: PUSH
73416: LD_VAR 0 4
73420: PUSH
73421: FOR_IN
73422: IFFALSE 73574
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73424: LD_VAR 0 3
73428: PPUSH
73429: CALL_OW 110
73433: NOT
73434: PUSH
73435: LD_VAR 0 3
73439: PPUSH
73440: CALL_OW 314
73444: NOT
73445: AND
73446: PUSH
73447: LD_VAR 0 3
73451: PPUSH
73452: CALL_OW 311
73456: NOT
73457: AND
73458: PUSH
73459: LD_VAR 0 3
73463: PPUSH
73464: CALL_OW 310
73468: NOT
73469: AND
73470: PUSH
73471: LD_VAR 0 3
73475: PUSH
73476: LD_EXP 26
73480: PUSH
73481: LD_VAR 0 2
73485: ARRAY
73486: PUSH
73487: LD_INT 1
73489: ARRAY
73490: IN
73491: NOT
73492: AND
73493: PUSH
73494: LD_VAR 0 3
73498: PUSH
73499: LD_EXP 26
73503: PUSH
73504: LD_VAR 0 2
73508: ARRAY
73509: PUSH
73510: LD_INT 2
73512: ARRAY
73513: IN
73514: NOT
73515: AND
73516: PUSH
73517: LD_VAR 0 3
73521: PUSH
73522: LD_EXP 35
73526: PUSH
73527: LD_VAR 0 2
73531: ARRAY
73532: IN
73533: NOT
73534: AND
73535: IFFALSE 73572
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73537: LD_VAR 0 2
73541: PPUSH
73542: LD_EXP 23
73546: PUSH
73547: LD_VAR 0 2
73551: ARRAY
73552: PPUSH
73553: LD_VAR 0 3
73557: PPUSH
73558: LD_VAR 0 3
73562: PPUSH
73563: CALL_OW 257
73567: PPUSH
73568: CALL 72344 0 4
// end ;
73572: GO 73421
73574: POP
73575: POP
// end ;
73576: GO 73356
73578: POP
73579: POP
// end ;
73580: LD_VAR 0 1
73584: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73585: LD_INT 0
73587: PPUSH
73588: PPUSH
73589: PPUSH
73590: PPUSH
73591: PPUSH
73592: PPUSH
// if not mc_bases [ base ] then
73593: LD_EXP 23
73597: PUSH
73598: LD_VAR 0 1
73602: ARRAY
73603: NOT
73604: IFFALSE 73608
// exit ;
73606: GO 73790
// tmp := [ ] ;
73608: LD_ADDR_VAR 0 6
73612: PUSH
73613: EMPTY
73614: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73615: LD_ADDR_VAR 0 7
73619: PUSH
73620: LD_VAR 0 3
73624: PPUSH
73625: LD_INT 0
73627: PPUSH
73628: CALL_OW 517
73632: ST_TO_ADDR
// if not list then
73633: LD_VAR 0 7
73637: NOT
73638: IFFALSE 73642
// exit ;
73640: GO 73790
// for i = 1 to amount do
73642: LD_ADDR_VAR 0 5
73646: PUSH
73647: DOUBLE
73648: LD_INT 1
73650: DEC
73651: ST_TO_ADDR
73652: LD_VAR 0 2
73656: PUSH
73657: FOR_TO
73658: IFFALSE 73738
// begin x := rand ( 1 , list [ 1 ] ) ;
73660: LD_ADDR_VAR 0 8
73664: PUSH
73665: LD_INT 1
73667: PPUSH
73668: LD_VAR 0 7
73672: PUSH
73673: LD_INT 1
73675: ARRAY
73676: PPUSH
73677: CALL_OW 12
73681: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73682: LD_ADDR_VAR 0 6
73686: PUSH
73687: LD_VAR 0 6
73691: PPUSH
73692: LD_VAR 0 5
73696: PPUSH
73697: LD_VAR 0 7
73701: PUSH
73702: LD_INT 1
73704: ARRAY
73705: PUSH
73706: LD_VAR 0 8
73710: ARRAY
73711: PUSH
73712: LD_VAR 0 7
73716: PUSH
73717: LD_INT 2
73719: ARRAY
73720: PUSH
73721: LD_VAR 0 8
73725: ARRAY
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PPUSH
73731: CALL_OW 1
73735: ST_TO_ADDR
// end ;
73736: GO 73657
73738: POP
73739: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
73740: LD_ADDR_EXP 36
73744: PUSH
73745: LD_EXP 36
73749: PPUSH
73750: LD_VAR 0 1
73754: PPUSH
73755: LD_VAR 0 6
73759: PPUSH
73760: CALL_OW 1
73764: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
73765: LD_ADDR_EXP 38
73769: PUSH
73770: LD_EXP 38
73774: PPUSH
73775: LD_VAR 0 1
73779: PPUSH
73780: LD_VAR 0 3
73784: PPUSH
73785: CALL_OW 1
73789: ST_TO_ADDR
// end ;
73790: LD_VAR 0 4
73794: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
73795: LD_INT 0
73797: PPUSH
// if not mc_bases [ base ] then
73798: LD_EXP 23
73802: PUSH
73803: LD_VAR 0 1
73807: ARRAY
73808: NOT
73809: IFFALSE 73813
// exit ;
73811: GO 73838
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
73813: LD_ADDR_EXP 28
73817: PUSH
73818: LD_EXP 28
73822: PPUSH
73823: LD_VAR 0 1
73827: PPUSH
73828: LD_VAR 0 2
73832: PPUSH
73833: CALL_OW 1
73837: ST_TO_ADDR
// end ;
73838: LD_VAR 0 3
73842: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
73843: LD_INT 0
73845: PPUSH
// if not mc_bases [ base ] then
73846: LD_EXP 23
73850: PUSH
73851: LD_VAR 0 1
73855: ARRAY
73856: NOT
73857: IFFALSE 73861
// exit ;
73859: GO 73898
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
73861: LD_ADDR_EXP 28
73865: PUSH
73866: LD_EXP 28
73870: PPUSH
73871: LD_VAR 0 1
73875: PPUSH
73876: LD_EXP 28
73880: PUSH
73881: LD_VAR 0 1
73885: ARRAY
73886: PUSH
73887: LD_VAR 0 2
73891: UNION
73892: PPUSH
73893: CALL_OW 1
73897: ST_TO_ADDR
// end ;
73898: LD_VAR 0 3
73902: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
73903: LD_INT 0
73905: PPUSH
// if not mc_bases [ base ] then
73906: LD_EXP 23
73910: PUSH
73911: LD_VAR 0 1
73915: ARRAY
73916: NOT
73917: IFFALSE 73921
// exit ;
73919: GO 73946
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
73921: LD_ADDR_EXP 44
73925: PUSH
73926: LD_EXP 44
73930: PPUSH
73931: LD_VAR 0 1
73935: PPUSH
73936: LD_VAR 0 2
73940: PPUSH
73941: CALL_OW 1
73945: ST_TO_ADDR
// end ;
73946: LD_VAR 0 3
73950: RET
// export function MC_InsertProduceList ( base , components ) ; begin
73951: LD_INT 0
73953: PPUSH
// if not mc_bases [ base ] then
73954: LD_EXP 23
73958: PUSH
73959: LD_VAR 0 1
73963: ARRAY
73964: NOT
73965: IFFALSE 73969
// exit ;
73967: GO 74006
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
73969: LD_ADDR_EXP 44
73973: PUSH
73974: LD_EXP 44
73978: PPUSH
73979: LD_VAR 0 1
73983: PPUSH
73984: LD_EXP 44
73988: PUSH
73989: LD_VAR 0 1
73993: ARRAY
73994: PUSH
73995: LD_VAR 0 2
73999: ADD
74000: PPUSH
74001: CALL_OW 1
74005: ST_TO_ADDR
// end ;
74006: LD_VAR 0 3
74010: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74011: LD_INT 0
74013: PPUSH
// if not mc_bases [ base ] then
74014: LD_EXP 23
74018: PUSH
74019: LD_VAR 0 1
74023: ARRAY
74024: NOT
74025: IFFALSE 74029
// exit ;
74027: GO 74083
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74029: LD_ADDR_EXP 45
74033: PUSH
74034: LD_EXP 45
74038: PPUSH
74039: LD_VAR 0 1
74043: PPUSH
74044: LD_VAR 0 2
74048: PPUSH
74049: CALL_OW 1
74053: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74054: LD_ADDR_EXP 34
74058: PUSH
74059: LD_EXP 34
74063: PPUSH
74064: LD_VAR 0 1
74068: PPUSH
74069: LD_VAR 0 2
74073: PUSH
74074: LD_INT 0
74076: PLUS
74077: PPUSH
74078: CALL_OW 1
74082: ST_TO_ADDR
// end ;
74083: LD_VAR 0 3
74087: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74088: LD_INT 0
74090: PPUSH
// if not mc_bases [ base ] then
74091: LD_EXP 23
74095: PUSH
74096: LD_VAR 0 1
74100: ARRAY
74101: NOT
74102: IFFALSE 74106
// exit ;
74104: GO 74131
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74106: LD_ADDR_EXP 34
74110: PUSH
74111: LD_EXP 34
74115: PPUSH
74116: LD_VAR 0 1
74120: PPUSH
74121: LD_VAR 0 2
74125: PPUSH
74126: CALL_OW 1
74130: ST_TO_ADDR
// end ;
74131: LD_VAR 0 3
74135: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74136: LD_INT 0
74138: PPUSH
74139: PPUSH
74140: PPUSH
74141: PPUSH
// if not mc_bases [ base ] then
74142: LD_EXP 23
74146: PUSH
74147: LD_VAR 0 1
74151: ARRAY
74152: NOT
74153: IFFALSE 74157
// exit ;
74155: GO 74222
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74157: LD_ADDR_EXP 43
74161: PUSH
74162: LD_EXP 43
74166: PPUSH
74167: LD_VAR 0 1
74171: PUSH
74172: LD_EXP 43
74176: PUSH
74177: LD_VAR 0 1
74181: ARRAY
74182: PUSH
74183: LD_INT 1
74185: PLUS
74186: PUSH
74187: EMPTY
74188: LIST
74189: LIST
74190: PPUSH
74191: LD_VAR 0 1
74195: PUSH
74196: LD_VAR 0 2
74200: PUSH
74201: LD_VAR 0 3
74205: PUSH
74206: LD_VAR 0 4
74210: PUSH
74211: EMPTY
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: PPUSH
74217: CALL 15990 0 3
74221: ST_TO_ADDR
// end ;
74222: LD_VAR 0 5
74226: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74227: LD_INT 0
74229: PPUSH
// if not mc_bases [ base ] then
74230: LD_EXP 23
74234: PUSH
74235: LD_VAR 0 1
74239: ARRAY
74240: NOT
74241: IFFALSE 74245
// exit ;
74243: GO 74270
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74245: LD_ADDR_EXP 60
74249: PUSH
74250: LD_EXP 60
74254: PPUSH
74255: LD_VAR 0 1
74259: PPUSH
74260: LD_VAR 0 2
74264: PPUSH
74265: CALL_OW 1
74269: ST_TO_ADDR
// end ;
74270: LD_VAR 0 3
74274: RET
// export function MC_GetMinesField ( base ) ; begin
74275: LD_INT 0
74277: PPUSH
// result := mc_mines [ base ] ;
74278: LD_ADDR_VAR 0 2
74282: PUSH
74283: LD_EXP 36
74287: PUSH
74288: LD_VAR 0 1
74292: ARRAY
74293: ST_TO_ADDR
// end ;
74294: LD_VAR 0 2
74298: RET
// export function MC_GetProduceList ( base ) ; begin
74299: LD_INT 0
74301: PPUSH
// result := mc_produce [ base ] ;
74302: LD_ADDR_VAR 0 2
74306: PUSH
74307: LD_EXP 44
74311: PUSH
74312: LD_VAR 0 1
74316: ARRAY
74317: ST_TO_ADDR
// end ;
74318: LD_VAR 0 2
74322: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74323: LD_INT 0
74325: PPUSH
74326: PPUSH
// if not mc_bases then
74327: LD_EXP 23
74331: NOT
74332: IFFALSE 74336
// exit ;
74334: GO 74401
// if mc_bases [ base ] then
74336: LD_EXP 23
74340: PUSH
74341: LD_VAR 0 1
74345: ARRAY
74346: IFFALSE 74401
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74348: LD_ADDR_VAR 0 3
74352: PUSH
74353: LD_EXP 23
74357: PUSH
74358: LD_VAR 0 1
74362: ARRAY
74363: PPUSH
74364: LD_INT 30
74366: PUSH
74367: LD_VAR 0 2
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PPUSH
74376: CALL_OW 72
74380: ST_TO_ADDR
// if result then
74381: LD_VAR 0 3
74385: IFFALSE 74401
// result := result [ 1 ] ;
74387: LD_ADDR_VAR 0 3
74391: PUSH
74392: LD_VAR 0 3
74396: PUSH
74397: LD_INT 1
74399: ARRAY
74400: ST_TO_ADDR
// end ; end ;
74401: LD_VAR 0 3
74405: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74406: LD_INT 0
74408: PPUSH
74409: PPUSH
// if not mc_bases then
74410: LD_EXP 23
74414: NOT
74415: IFFALSE 74419
// exit ;
74417: GO 74464
// if mc_bases [ base ] then
74419: LD_EXP 23
74423: PUSH
74424: LD_VAR 0 1
74428: ARRAY
74429: IFFALSE 74464
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74431: LD_ADDR_VAR 0 3
74435: PUSH
74436: LD_EXP 23
74440: PUSH
74441: LD_VAR 0 1
74445: ARRAY
74446: PPUSH
74447: LD_INT 30
74449: PUSH
74450: LD_VAR 0 2
74454: PUSH
74455: EMPTY
74456: LIST
74457: LIST
74458: PPUSH
74459: CALL_OW 72
74463: ST_TO_ADDR
// end ;
74464: LD_VAR 0 3
74468: RET
// export function MC_SetTame ( base , area ) ; begin
74469: LD_INT 0
74471: PPUSH
// if not mc_bases or not base then
74472: LD_EXP 23
74476: NOT
74477: PUSH
74478: LD_VAR 0 1
74482: NOT
74483: OR
74484: IFFALSE 74488
// exit ;
74486: GO 74513
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74488: LD_ADDR_EXP 51
74492: PUSH
74493: LD_EXP 51
74497: PPUSH
74498: LD_VAR 0 1
74502: PPUSH
74503: LD_VAR 0 2
74507: PPUSH
74508: CALL_OW 1
74512: ST_TO_ADDR
// end ;
74513: LD_VAR 0 3
74517: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74518: LD_INT 0
74520: PPUSH
74521: PPUSH
// if not mc_bases or not base then
74522: LD_EXP 23
74526: NOT
74527: PUSH
74528: LD_VAR 0 1
74532: NOT
74533: OR
74534: IFFALSE 74538
// exit ;
74536: GO 74640
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74538: LD_ADDR_VAR 0 4
74542: PUSH
74543: LD_EXP 23
74547: PUSH
74548: LD_VAR 0 1
74552: ARRAY
74553: PPUSH
74554: LD_INT 30
74556: PUSH
74557: LD_VAR 0 2
74561: PUSH
74562: EMPTY
74563: LIST
74564: LIST
74565: PPUSH
74566: CALL_OW 72
74570: ST_TO_ADDR
// if not tmp then
74571: LD_VAR 0 4
74575: NOT
74576: IFFALSE 74580
// exit ;
74578: GO 74640
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74580: LD_ADDR_EXP 55
74584: PUSH
74585: LD_EXP 55
74589: PPUSH
74590: LD_VAR 0 1
74594: PPUSH
74595: LD_EXP 55
74599: PUSH
74600: LD_VAR 0 1
74604: ARRAY
74605: PPUSH
74606: LD_EXP 55
74610: PUSH
74611: LD_VAR 0 1
74615: ARRAY
74616: PUSH
74617: LD_INT 1
74619: PLUS
74620: PPUSH
74621: LD_VAR 0 4
74625: PUSH
74626: LD_INT 1
74628: ARRAY
74629: PPUSH
74630: CALL_OW 2
74634: PPUSH
74635: CALL_OW 1
74639: ST_TO_ADDR
// end ;
74640: LD_VAR 0 3
74644: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74645: LD_INT 0
74647: PPUSH
74648: PPUSH
// if not mc_bases or not base or not kinds then
74649: LD_EXP 23
74653: NOT
74654: PUSH
74655: LD_VAR 0 1
74659: NOT
74660: OR
74661: PUSH
74662: LD_VAR 0 2
74666: NOT
74667: OR
74668: IFFALSE 74672
// exit ;
74670: GO 74733
// for i in kinds do
74672: LD_ADDR_VAR 0 4
74676: PUSH
74677: LD_VAR 0 2
74681: PUSH
74682: FOR_IN
74683: IFFALSE 74731
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74685: LD_ADDR_EXP 57
74689: PUSH
74690: LD_EXP 57
74694: PPUSH
74695: LD_VAR 0 1
74699: PUSH
74700: LD_EXP 57
74704: PUSH
74705: LD_VAR 0 1
74709: ARRAY
74710: PUSH
74711: LD_INT 1
74713: PLUS
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PPUSH
74719: LD_VAR 0 4
74723: PPUSH
74724: CALL 15990 0 3
74728: ST_TO_ADDR
74729: GO 74682
74731: POP
74732: POP
// end ;
74733: LD_VAR 0 3
74737: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
74738: LD_INT 0
74740: PPUSH
// if not mc_bases or not base or not areas then
74741: LD_EXP 23
74745: NOT
74746: PUSH
74747: LD_VAR 0 1
74751: NOT
74752: OR
74753: PUSH
74754: LD_VAR 0 2
74758: NOT
74759: OR
74760: IFFALSE 74764
// exit ;
74762: GO 74789
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
74764: LD_ADDR_EXP 41
74768: PUSH
74769: LD_EXP 41
74773: PPUSH
74774: LD_VAR 0 1
74778: PPUSH
74779: LD_VAR 0 2
74783: PPUSH
74784: CALL_OW 1
74788: ST_TO_ADDR
// end ;
74789: LD_VAR 0 3
74793: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
74794: LD_INT 0
74796: PPUSH
// if not mc_bases or not base or not teleports_exit then
74797: LD_EXP 23
74801: NOT
74802: PUSH
74803: LD_VAR 0 1
74807: NOT
74808: OR
74809: PUSH
74810: LD_VAR 0 2
74814: NOT
74815: OR
74816: IFFALSE 74820
// exit ;
74818: GO 74845
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
74820: LD_ADDR_EXP 58
74824: PUSH
74825: LD_EXP 58
74829: PPUSH
74830: LD_VAR 0 1
74834: PPUSH
74835: LD_VAR 0 2
74839: PPUSH
74840: CALL_OW 1
74844: ST_TO_ADDR
// end ;
74845: LD_VAR 0 3
74849: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
74850: LD_INT 0
74852: PPUSH
74853: PPUSH
74854: PPUSH
// if not mc_bases or not base or not ext_list then
74855: LD_EXP 23
74859: NOT
74860: PUSH
74861: LD_VAR 0 1
74865: NOT
74866: OR
74867: PUSH
74868: LD_VAR 0 5
74872: NOT
74873: OR
74874: IFFALSE 74878
// exit ;
74876: GO 75051
// tmp := GetFacExtXYD ( x , y , d ) ;
74878: LD_ADDR_VAR 0 8
74882: PUSH
74883: LD_VAR 0 2
74887: PPUSH
74888: LD_VAR 0 3
74892: PPUSH
74893: LD_VAR 0 4
74897: PPUSH
74898: CALL 45377 0 3
74902: ST_TO_ADDR
// if not tmp then
74903: LD_VAR 0 8
74907: NOT
74908: IFFALSE 74912
// exit ;
74910: GO 75051
// for i in tmp do
74912: LD_ADDR_VAR 0 7
74916: PUSH
74917: LD_VAR 0 8
74921: PUSH
74922: FOR_IN
74923: IFFALSE 75049
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
74925: LD_ADDR_EXP 28
74929: PUSH
74930: LD_EXP 28
74934: PPUSH
74935: LD_VAR 0 1
74939: PPUSH
74940: LD_EXP 28
74944: PUSH
74945: LD_VAR 0 1
74949: ARRAY
74950: PPUSH
74951: LD_EXP 28
74955: PUSH
74956: LD_VAR 0 1
74960: ARRAY
74961: PUSH
74962: LD_INT 1
74964: PLUS
74965: PPUSH
74966: LD_VAR 0 5
74970: PUSH
74971: LD_INT 1
74973: ARRAY
74974: PUSH
74975: LD_VAR 0 7
74979: PUSH
74980: LD_INT 1
74982: ARRAY
74983: PUSH
74984: LD_VAR 0 7
74988: PUSH
74989: LD_INT 2
74991: ARRAY
74992: PUSH
74993: LD_VAR 0 7
74997: PUSH
74998: LD_INT 3
75000: ARRAY
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: PPUSH
75008: CALL_OW 2
75012: PPUSH
75013: CALL_OW 1
75017: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75018: LD_ADDR_VAR 0 5
75022: PUSH
75023: LD_VAR 0 5
75027: PPUSH
75028: LD_INT 1
75030: PPUSH
75031: CALL_OW 3
75035: ST_TO_ADDR
// if not ext_list then
75036: LD_VAR 0 5
75040: NOT
75041: IFFALSE 75047
// exit ;
75043: POP
75044: POP
75045: GO 75051
// end ;
75047: GO 74922
75049: POP
75050: POP
// end ;
75051: LD_VAR 0 6
75055: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75056: LD_INT 0
75058: PPUSH
// if not mc_bases or not base or not weapon_list then
75059: LD_EXP 23
75063: NOT
75064: PUSH
75065: LD_VAR 0 1
75069: NOT
75070: OR
75071: PUSH
75072: LD_VAR 0 2
75076: NOT
75077: OR
75078: IFFALSE 75082
// exit ;
75080: GO 75107
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75082: LD_ADDR_EXP 62
75086: PUSH
75087: LD_EXP 62
75091: PPUSH
75092: LD_VAR 0 1
75096: PPUSH
75097: LD_VAR 0 2
75101: PPUSH
75102: CALL_OW 1
75106: ST_TO_ADDR
// end ;
75107: LD_VAR 0 3
75111: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75112: LD_INT 0
75114: PPUSH
// if not mc_bases or not base or not tech_list then
75115: LD_EXP 23
75119: NOT
75120: PUSH
75121: LD_VAR 0 1
75125: NOT
75126: OR
75127: PUSH
75128: LD_VAR 0 2
75132: NOT
75133: OR
75134: IFFALSE 75138
// exit ;
75136: GO 75163
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75138: LD_ADDR_EXP 50
75142: PUSH
75143: LD_EXP 50
75147: PPUSH
75148: LD_VAR 0 1
75152: PPUSH
75153: LD_VAR 0 2
75157: PPUSH
75158: CALL_OW 1
75162: ST_TO_ADDR
// end ;
75163: LD_VAR 0 3
75167: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75168: LD_INT 0
75170: PPUSH
// if not mc_bases or not parking_area or not base then
75171: LD_EXP 23
75175: NOT
75176: PUSH
75177: LD_VAR 0 2
75181: NOT
75182: OR
75183: PUSH
75184: LD_VAR 0 1
75188: NOT
75189: OR
75190: IFFALSE 75194
// exit ;
75192: GO 75219
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75194: LD_ADDR_EXP 47
75198: PUSH
75199: LD_EXP 47
75203: PPUSH
75204: LD_VAR 0 1
75208: PPUSH
75209: LD_VAR 0 2
75213: PPUSH
75214: CALL_OW 1
75218: ST_TO_ADDR
// end ;
75219: LD_VAR 0 3
75223: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75224: LD_INT 0
75226: PPUSH
// if not mc_bases or not base or not scan_area then
75227: LD_EXP 23
75231: NOT
75232: PUSH
75233: LD_VAR 0 1
75237: NOT
75238: OR
75239: PUSH
75240: LD_VAR 0 2
75244: NOT
75245: OR
75246: IFFALSE 75250
// exit ;
75248: GO 75275
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75250: LD_ADDR_EXP 48
75254: PUSH
75255: LD_EXP 48
75259: PPUSH
75260: LD_VAR 0 1
75264: PPUSH
75265: LD_VAR 0 2
75269: PPUSH
75270: CALL_OW 1
75274: ST_TO_ADDR
// end ;
75275: LD_VAR 0 3
75279: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75280: LD_INT 0
75282: PPUSH
75283: PPUSH
// if not mc_bases or not base then
75284: LD_EXP 23
75288: NOT
75289: PUSH
75290: LD_VAR 0 1
75294: NOT
75295: OR
75296: IFFALSE 75300
// exit ;
75298: GO 75364
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75300: LD_ADDR_VAR 0 3
75304: PUSH
75305: LD_INT 1
75307: PUSH
75308: LD_INT 2
75310: PUSH
75311: LD_INT 3
75313: PUSH
75314: LD_INT 4
75316: PUSH
75317: LD_INT 11
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: LIST
75324: LIST
75325: LIST
75326: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75327: LD_ADDR_EXP 50
75331: PUSH
75332: LD_EXP 50
75336: PPUSH
75337: LD_VAR 0 1
75341: PPUSH
75342: LD_EXP 50
75346: PUSH
75347: LD_VAR 0 1
75351: ARRAY
75352: PUSH
75353: LD_VAR 0 3
75357: DIFF
75358: PPUSH
75359: CALL_OW 1
75363: ST_TO_ADDR
// end ;
75364: LD_VAR 0 2
75368: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75369: LD_INT 0
75371: PPUSH
// result := mc_vehicles [ base ] ;
75372: LD_ADDR_VAR 0 3
75376: PUSH
75377: LD_EXP 42
75381: PUSH
75382: LD_VAR 0 1
75386: ARRAY
75387: ST_TO_ADDR
// if onlyCombat then
75388: LD_VAR 0 2
75392: IFFALSE 75570
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75394: LD_ADDR_VAR 0 3
75398: PUSH
75399: LD_VAR 0 3
75403: PUSH
75404: LD_VAR 0 3
75408: PPUSH
75409: LD_INT 2
75411: PUSH
75412: LD_INT 34
75414: PUSH
75415: LD_INT 12
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: PUSH
75422: LD_INT 34
75424: PUSH
75425: LD_INT 51
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 34
75434: PUSH
75435: LD_EXP 68
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 34
75446: PUSH
75447: LD_INT 32
75449: PUSH
75450: EMPTY
75451: LIST
75452: LIST
75453: PUSH
75454: LD_INT 34
75456: PUSH
75457: LD_INT 13
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PUSH
75464: LD_INT 34
75466: PUSH
75467: LD_INT 52
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 34
75476: PUSH
75477: LD_EXP 73
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 34
75488: PUSH
75489: LD_INT 14
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 34
75498: PUSH
75499: LD_INT 53
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 34
75508: PUSH
75509: LD_EXP 67
75513: PUSH
75514: EMPTY
75515: LIST
75516: LIST
75517: PUSH
75518: LD_INT 34
75520: PUSH
75521: LD_INT 31
75523: PUSH
75524: EMPTY
75525: LIST
75526: LIST
75527: PUSH
75528: LD_INT 34
75530: PUSH
75531: LD_INT 48
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 34
75540: PUSH
75541: LD_INT 8
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: EMPTY
75549: LIST
75550: LIST
75551: LIST
75552: LIST
75553: LIST
75554: LIST
75555: LIST
75556: LIST
75557: LIST
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: PPUSH
75564: CALL_OW 72
75568: DIFF
75569: ST_TO_ADDR
// end ; end_of_file
75570: LD_VAR 0 3
75574: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75575: LD_INT 0
75577: PPUSH
75578: PPUSH
75579: PPUSH
// if not mc_bases or not skirmish then
75580: LD_EXP 23
75584: NOT
75585: PUSH
75586: LD_EXP 21
75590: NOT
75591: OR
75592: IFFALSE 75596
// exit ;
75594: GO 75761
// for i = 1 to mc_bases do
75596: LD_ADDR_VAR 0 4
75600: PUSH
75601: DOUBLE
75602: LD_INT 1
75604: DEC
75605: ST_TO_ADDR
75606: LD_EXP 23
75610: PUSH
75611: FOR_TO
75612: IFFALSE 75759
// begin if sci in mc_bases [ i ] then
75614: LD_VAR 0 2
75618: PUSH
75619: LD_EXP 23
75623: PUSH
75624: LD_VAR 0 4
75628: ARRAY
75629: IN
75630: IFFALSE 75757
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75632: LD_ADDR_EXP 52
75636: PUSH
75637: LD_EXP 52
75641: PPUSH
75642: LD_VAR 0 4
75646: PUSH
75647: LD_EXP 52
75651: PUSH
75652: LD_VAR 0 4
75656: ARRAY
75657: PUSH
75658: LD_INT 1
75660: PLUS
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PPUSH
75666: LD_VAR 0 1
75670: PPUSH
75671: CALL 15990 0 3
75675: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75676: LD_ADDR_VAR 0 5
75680: PUSH
75681: LD_EXP 23
75685: PUSH
75686: LD_VAR 0 4
75690: ARRAY
75691: PPUSH
75692: LD_INT 2
75694: PUSH
75695: LD_INT 30
75697: PUSH
75698: LD_INT 0
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: PUSH
75705: LD_INT 30
75707: PUSH
75708: LD_INT 1
75710: PUSH
75711: EMPTY
75712: LIST
75713: LIST
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: LIST
75719: PPUSH
75720: CALL_OW 72
75724: PPUSH
75725: LD_VAR 0 1
75729: PPUSH
75730: CALL_OW 74
75734: ST_TO_ADDR
// if tmp then
75735: LD_VAR 0 5
75739: IFFALSE 75755
// ComStandNearbyBuilding ( ape , tmp ) ;
75741: LD_VAR 0 1
75745: PPUSH
75746: LD_VAR 0 5
75750: PPUSH
75751: CALL 12568 0 2
// break ;
75755: GO 75759
// end ; end ;
75757: GO 75611
75759: POP
75760: POP
// end ;
75761: LD_VAR 0 3
75765: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
75766: LD_INT 0
75768: PPUSH
75769: PPUSH
75770: PPUSH
// if not mc_bases or not skirmish then
75771: LD_EXP 23
75775: NOT
75776: PUSH
75777: LD_EXP 21
75781: NOT
75782: OR
75783: IFFALSE 75787
// exit ;
75785: GO 75876
// for i = 1 to mc_bases do
75787: LD_ADDR_VAR 0 4
75791: PUSH
75792: DOUBLE
75793: LD_INT 1
75795: DEC
75796: ST_TO_ADDR
75797: LD_EXP 23
75801: PUSH
75802: FOR_TO
75803: IFFALSE 75874
// begin if building in mc_busy_turret_list [ i ] then
75805: LD_VAR 0 1
75809: PUSH
75810: LD_EXP 33
75814: PUSH
75815: LD_VAR 0 4
75819: ARRAY
75820: IN
75821: IFFALSE 75872
// begin tmp := mc_busy_turret_list [ i ] diff building ;
75823: LD_ADDR_VAR 0 5
75827: PUSH
75828: LD_EXP 33
75832: PUSH
75833: LD_VAR 0 4
75837: ARRAY
75838: PUSH
75839: LD_VAR 0 1
75843: DIFF
75844: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
75845: LD_ADDR_EXP 33
75849: PUSH
75850: LD_EXP 33
75854: PPUSH
75855: LD_VAR 0 4
75859: PPUSH
75860: LD_VAR 0 5
75864: PPUSH
75865: CALL_OW 1
75869: ST_TO_ADDR
// break ;
75870: GO 75874
// end ; end ;
75872: GO 75802
75874: POP
75875: POP
// end ;
75876: LD_VAR 0 3
75880: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
75881: LD_INT 0
75883: PPUSH
75884: PPUSH
75885: PPUSH
// if not mc_bases or not skirmish then
75886: LD_EXP 23
75890: NOT
75891: PUSH
75892: LD_EXP 21
75896: NOT
75897: OR
75898: IFFALSE 75902
// exit ;
75900: GO 76101
// for i = 1 to mc_bases do
75902: LD_ADDR_VAR 0 5
75906: PUSH
75907: DOUBLE
75908: LD_INT 1
75910: DEC
75911: ST_TO_ADDR
75912: LD_EXP 23
75916: PUSH
75917: FOR_TO
75918: IFFALSE 76099
// if building in mc_bases [ i ] then
75920: LD_VAR 0 1
75924: PUSH
75925: LD_EXP 23
75929: PUSH
75930: LD_VAR 0 5
75934: ARRAY
75935: IN
75936: IFFALSE 76097
// begin tmp := mc_bases [ i ] diff building ;
75938: LD_ADDR_VAR 0 6
75942: PUSH
75943: LD_EXP 23
75947: PUSH
75948: LD_VAR 0 5
75952: ARRAY
75953: PUSH
75954: LD_VAR 0 1
75958: DIFF
75959: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
75960: LD_ADDR_EXP 23
75964: PUSH
75965: LD_EXP 23
75969: PPUSH
75970: LD_VAR 0 5
75974: PPUSH
75975: LD_VAR 0 6
75979: PPUSH
75980: CALL_OW 1
75984: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
75985: LD_VAR 0 1
75989: PUSH
75990: LD_EXP 31
75994: PUSH
75995: LD_VAR 0 5
75999: ARRAY
76000: IN
76001: IFFALSE 76040
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76003: LD_ADDR_EXP 31
76007: PUSH
76008: LD_EXP 31
76012: PPUSH
76013: LD_VAR 0 5
76017: PPUSH
76018: LD_EXP 31
76022: PUSH
76023: LD_VAR 0 5
76027: ARRAY
76028: PUSH
76029: LD_VAR 0 1
76033: DIFF
76034: PPUSH
76035: CALL_OW 1
76039: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76040: LD_VAR 0 1
76044: PUSH
76045: LD_EXP 32
76049: PUSH
76050: LD_VAR 0 5
76054: ARRAY
76055: IN
76056: IFFALSE 76095
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76058: LD_ADDR_EXP 32
76062: PUSH
76063: LD_EXP 32
76067: PPUSH
76068: LD_VAR 0 5
76072: PPUSH
76073: LD_EXP 32
76077: PUSH
76078: LD_VAR 0 5
76082: ARRAY
76083: PUSH
76084: LD_VAR 0 1
76088: DIFF
76089: PPUSH
76090: CALL_OW 1
76094: ST_TO_ADDR
// break ;
76095: GO 76099
// end ;
76097: GO 75917
76099: POP
76100: POP
// end ;
76101: LD_VAR 0 4
76105: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76106: LD_INT 0
76108: PPUSH
76109: PPUSH
76110: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76111: LD_EXP 23
76115: NOT
76116: PUSH
76117: LD_EXP 21
76121: NOT
76122: OR
76123: PUSH
76124: LD_VAR 0 3
76128: PUSH
76129: LD_EXP 49
76133: IN
76134: NOT
76135: OR
76136: IFFALSE 76140
// exit ;
76138: GO 76263
// for i = 1 to mc_vehicles do
76140: LD_ADDR_VAR 0 6
76144: PUSH
76145: DOUBLE
76146: LD_INT 1
76148: DEC
76149: ST_TO_ADDR
76150: LD_EXP 42
76154: PUSH
76155: FOR_TO
76156: IFFALSE 76261
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76158: LD_VAR 0 2
76162: PUSH
76163: LD_EXP 42
76167: PUSH
76168: LD_VAR 0 6
76172: ARRAY
76173: IN
76174: PUSH
76175: LD_VAR 0 1
76179: PUSH
76180: LD_EXP 42
76184: PUSH
76185: LD_VAR 0 6
76189: ARRAY
76190: IN
76191: OR
76192: IFFALSE 76259
// begin tmp := mc_vehicles [ i ] diff old ;
76194: LD_ADDR_VAR 0 7
76198: PUSH
76199: LD_EXP 42
76203: PUSH
76204: LD_VAR 0 6
76208: ARRAY
76209: PUSH
76210: LD_VAR 0 2
76214: DIFF
76215: ST_TO_ADDR
// tmp := tmp diff new ;
76216: LD_ADDR_VAR 0 7
76220: PUSH
76221: LD_VAR 0 7
76225: PUSH
76226: LD_VAR 0 1
76230: DIFF
76231: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76232: LD_ADDR_EXP 42
76236: PUSH
76237: LD_EXP 42
76241: PPUSH
76242: LD_VAR 0 6
76246: PPUSH
76247: LD_VAR 0 7
76251: PPUSH
76252: CALL_OW 1
76256: ST_TO_ADDR
// break ;
76257: GO 76261
// end ;
76259: GO 76155
76261: POP
76262: POP
// end ;
76263: LD_VAR 0 5
76267: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76268: LD_INT 0
76270: PPUSH
76271: PPUSH
76272: PPUSH
76273: PPUSH
// if not mc_bases or not skirmish then
76274: LD_EXP 23
76278: NOT
76279: PUSH
76280: LD_EXP 21
76284: NOT
76285: OR
76286: IFFALSE 76290
// exit ;
76288: GO 76682
// side := GetSide ( vehicle ) ;
76290: LD_ADDR_VAR 0 5
76294: PUSH
76295: LD_VAR 0 1
76299: PPUSH
76300: CALL_OW 255
76304: ST_TO_ADDR
// for i = 1 to mc_bases do
76305: LD_ADDR_VAR 0 4
76309: PUSH
76310: DOUBLE
76311: LD_INT 1
76313: DEC
76314: ST_TO_ADDR
76315: LD_EXP 23
76319: PUSH
76320: FOR_TO
76321: IFFALSE 76680
// begin if factory in mc_bases [ i ] then
76323: LD_VAR 0 2
76327: PUSH
76328: LD_EXP 23
76332: PUSH
76333: LD_VAR 0 4
76337: ARRAY
76338: IN
76339: IFFALSE 76678
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
76341: LD_EXP 45
76345: PUSH
76346: LD_VAR 0 4
76350: ARRAY
76351: PUSH
76352: LD_EXP 34
76356: PUSH
76357: LD_VAR 0 4
76361: ARRAY
76362: LESS
76363: PUSH
76364: LD_VAR 0 1
76368: PPUSH
76369: CALL_OW 264
76373: PUSH
76374: LD_INT 31
76376: PUSH
76377: LD_INT 32
76379: PUSH
76380: LD_INT 51
76382: PUSH
76383: LD_EXP 68
76387: PUSH
76388: LD_INT 12
76390: PUSH
76391: LD_INT 30
76393: PUSH
76394: LD_EXP 67
76398: PUSH
76399: LD_INT 11
76401: PUSH
76402: LD_INT 53
76404: PUSH
76405: LD_INT 14
76407: PUSH
76408: LD_EXP 71
76412: PUSH
76413: LD_INT 29
76415: PUSH
76416: LD_EXP 69
76420: PUSH
76421: LD_INT 13
76423: PUSH
76424: LD_INT 52
76426: PUSH
76427: LD_EXP 73
76431: PUSH
76432: LD_INT 48
76434: PUSH
76435: LD_INT 8
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: LIST
76442: LIST
76443: LIST
76444: LIST
76445: LIST
76446: LIST
76447: LIST
76448: LIST
76449: LIST
76450: LIST
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: IN
76458: NOT
76459: AND
76460: IFFALSE 76508
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76462: LD_ADDR_EXP 45
76466: PUSH
76467: LD_EXP 45
76471: PPUSH
76472: LD_VAR 0 4
76476: PUSH
76477: LD_EXP 45
76481: PUSH
76482: LD_VAR 0 4
76486: ARRAY
76487: PUSH
76488: LD_INT 1
76490: PLUS
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PPUSH
76496: LD_VAR 0 1
76500: PPUSH
76501: CALL 15990 0 3
76505: ST_TO_ADDR
76506: GO 76552
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76508: LD_ADDR_EXP 42
76512: PUSH
76513: LD_EXP 42
76517: PPUSH
76518: LD_VAR 0 4
76522: PUSH
76523: LD_EXP 42
76527: PUSH
76528: LD_VAR 0 4
76532: ARRAY
76533: PUSH
76534: LD_INT 1
76536: PLUS
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PPUSH
76542: LD_VAR 0 1
76546: PPUSH
76547: CALL 15990 0 3
76551: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76552: LD_VAR 0 1
76556: PPUSH
76557: CALL_OW 263
76561: PUSH
76562: LD_INT 2
76564: EQUAL
76565: IFFALSE 76594
// begin repeat wait ( 0 0$3 ) ;
76567: LD_INT 105
76569: PPUSH
76570: CALL_OW 67
// Connect ( vehicle ) ;
76574: LD_VAR 0 1
76578: PPUSH
76579: CALL 18961 0 1
// until IsControledBy ( vehicle ) ;
76583: LD_VAR 0 1
76587: PPUSH
76588: CALL_OW 312
76592: IFFALSE 76567
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76594: LD_VAR 0 1
76598: PPUSH
76599: LD_EXP 47
76603: PUSH
76604: LD_VAR 0 4
76608: ARRAY
76609: PPUSH
76610: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
76614: LD_VAR 0 1
76618: PPUSH
76619: CALL_OW 263
76623: PUSH
76624: LD_INT 1
76626: NONEQUAL
76627: IFFALSE 76631
// break ;
76629: GO 76680
// repeat wait ( 0 0$1 ) ;
76631: LD_INT 35
76633: PPUSH
76634: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76638: LD_VAR 0 1
76642: PPUSH
76643: LD_EXP 47
76647: PUSH
76648: LD_VAR 0 4
76652: ARRAY
76653: PPUSH
76654: CALL_OW 308
76658: IFFALSE 76631
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76660: LD_VAR 0 1
76664: PPUSH
76665: CALL_OW 311
76669: PPUSH
76670: CALL_OW 121
// exit ;
76674: POP
76675: POP
76676: GO 76682
// end ; end ;
76678: GO 76320
76680: POP
76681: POP
// end ;
76682: LD_VAR 0 3
76686: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76687: LD_INT 0
76689: PPUSH
76690: PPUSH
76691: PPUSH
76692: PPUSH
// if not mc_bases or not skirmish then
76693: LD_EXP 23
76697: NOT
76698: PUSH
76699: LD_EXP 21
76703: NOT
76704: OR
76705: IFFALSE 76709
// exit ;
76707: GO 77062
// repeat wait ( 0 0$1 ) ;
76709: LD_INT 35
76711: PPUSH
76712: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
76716: LD_VAR 0 2
76720: PPUSH
76721: LD_VAR 0 3
76725: PPUSH
76726: CALL_OW 284
76730: IFFALSE 76709
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76732: LD_VAR 0 2
76736: PPUSH
76737: LD_VAR 0 3
76741: PPUSH
76742: CALL_OW 283
76746: PUSH
76747: LD_INT 4
76749: EQUAL
76750: IFFALSE 76754
// exit ;
76752: GO 77062
// for i = 1 to mc_bases do
76754: LD_ADDR_VAR 0 7
76758: PUSH
76759: DOUBLE
76760: LD_INT 1
76762: DEC
76763: ST_TO_ADDR
76764: LD_EXP 23
76768: PUSH
76769: FOR_TO
76770: IFFALSE 77060
// begin if mc_crates_area [ i ] then
76772: LD_EXP 41
76776: PUSH
76777: LD_VAR 0 7
76781: ARRAY
76782: IFFALSE 76893
// for j in mc_crates_area [ i ] do
76784: LD_ADDR_VAR 0 8
76788: PUSH
76789: LD_EXP 41
76793: PUSH
76794: LD_VAR 0 7
76798: ARRAY
76799: PUSH
76800: FOR_IN
76801: IFFALSE 76891
// if InArea ( x , y , j ) then
76803: LD_VAR 0 2
76807: PPUSH
76808: LD_VAR 0 3
76812: PPUSH
76813: LD_VAR 0 8
76817: PPUSH
76818: CALL_OW 309
76822: IFFALSE 76889
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76824: LD_ADDR_EXP 39
76828: PUSH
76829: LD_EXP 39
76833: PPUSH
76834: LD_VAR 0 7
76838: PUSH
76839: LD_EXP 39
76843: PUSH
76844: LD_VAR 0 7
76848: ARRAY
76849: PUSH
76850: LD_INT 1
76852: PLUS
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PPUSH
76858: LD_VAR 0 4
76862: PUSH
76863: LD_VAR 0 2
76867: PUSH
76868: LD_VAR 0 3
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: LIST
76877: PPUSH
76878: CALL 15990 0 3
76882: ST_TO_ADDR
// exit ;
76883: POP
76884: POP
76885: POP
76886: POP
76887: GO 77062
// end ;
76889: GO 76800
76891: POP
76892: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76893: LD_ADDR_VAR 0 9
76897: PUSH
76898: LD_EXP 23
76902: PUSH
76903: LD_VAR 0 7
76907: ARRAY
76908: PPUSH
76909: LD_INT 2
76911: PUSH
76912: LD_INT 30
76914: PUSH
76915: LD_INT 0
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 30
76924: PUSH
76925: LD_INT 1
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: LIST
76936: PPUSH
76937: CALL_OW 72
76941: ST_TO_ADDR
// if not depot then
76942: LD_VAR 0 9
76946: NOT
76947: IFFALSE 76951
// continue ;
76949: GO 76769
// for j in depot do
76951: LD_ADDR_VAR 0 8
76955: PUSH
76956: LD_VAR 0 9
76960: PUSH
76961: FOR_IN
76962: IFFALSE 77056
// if GetDistUnitXY ( j , x , y ) < 30 then
76964: LD_VAR 0 8
76968: PPUSH
76969: LD_VAR 0 2
76973: PPUSH
76974: LD_VAR 0 3
76978: PPUSH
76979: CALL_OW 297
76983: PUSH
76984: LD_INT 30
76986: LESS
76987: IFFALSE 77054
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76989: LD_ADDR_EXP 39
76993: PUSH
76994: LD_EXP 39
76998: PPUSH
76999: LD_VAR 0 7
77003: PUSH
77004: LD_EXP 39
77008: PUSH
77009: LD_VAR 0 7
77013: ARRAY
77014: PUSH
77015: LD_INT 1
77017: PLUS
77018: PUSH
77019: EMPTY
77020: LIST
77021: LIST
77022: PPUSH
77023: LD_VAR 0 4
77027: PUSH
77028: LD_VAR 0 2
77032: PUSH
77033: LD_VAR 0 3
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: LIST
77042: PPUSH
77043: CALL 15990 0 3
77047: ST_TO_ADDR
// exit ;
77048: POP
77049: POP
77050: POP
77051: POP
77052: GO 77062
// end ;
77054: GO 76961
77056: POP
77057: POP
// end ;
77058: GO 76769
77060: POP
77061: POP
// end ;
77062: LD_VAR 0 6
77066: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77067: LD_INT 0
77069: PPUSH
77070: PPUSH
77071: PPUSH
77072: PPUSH
// if not mc_bases or not skirmish then
77073: LD_EXP 23
77077: NOT
77078: PUSH
77079: LD_EXP 21
77083: NOT
77084: OR
77085: IFFALSE 77089
// exit ;
77087: GO 77366
// side := GetSide ( lab ) ;
77089: LD_ADDR_VAR 0 4
77093: PUSH
77094: LD_VAR 0 2
77098: PPUSH
77099: CALL_OW 255
77103: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77104: LD_VAR 0 4
77108: PUSH
77109: LD_EXP 49
77113: IN
77114: NOT
77115: PUSH
77116: LD_EXP 50
77120: NOT
77121: OR
77122: PUSH
77123: LD_EXP 23
77127: NOT
77128: OR
77129: IFFALSE 77133
// exit ;
77131: GO 77366
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77133: LD_ADDR_EXP 50
77137: PUSH
77138: LD_EXP 50
77142: PPUSH
77143: LD_VAR 0 4
77147: PPUSH
77148: LD_EXP 50
77152: PUSH
77153: LD_VAR 0 4
77157: ARRAY
77158: PUSH
77159: LD_VAR 0 1
77163: DIFF
77164: PPUSH
77165: CALL_OW 1
77169: ST_TO_ADDR
// for i = 1 to mc_bases do
77170: LD_ADDR_VAR 0 5
77174: PUSH
77175: DOUBLE
77176: LD_INT 1
77178: DEC
77179: ST_TO_ADDR
77180: LD_EXP 23
77184: PUSH
77185: FOR_TO
77186: IFFALSE 77364
// begin if lab in mc_bases [ i ] then
77188: LD_VAR 0 2
77192: PUSH
77193: LD_EXP 23
77197: PUSH
77198: LD_VAR 0 5
77202: ARRAY
77203: IN
77204: IFFALSE 77362
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77206: LD_VAR 0 1
77210: PUSH
77211: LD_INT 11
77213: PUSH
77214: LD_INT 4
77216: PUSH
77217: LD_INT 3
77219: PUSH
77220: LD_INT 2
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: LIST
77227: LIST
77228: IN
77229: PUSH
77230: LD_EXP 53
77234: PUSH
77235: LD_VAR 0 5
77239: ARRAY
77240: AND
77241: IFFALSE 77362
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77243: LD_ADDR_VAR 0 6
77247: PUSH
77248: LD_EXP 53
77252: PUSH
77253: LD_VAR 0 5
77257: ARRAY
77258: PUSH
77259: LD_INT 1
77261: ARRAY
77262: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77263: LD_ADDR_EXP 53
77267: PUSH
77268: LD_EXP 53
77272: PPUSH
77273: LD_VAR 0 5
77277: PPUSH
77278: EMPTY
77279: PPUSH
77280: CALL_OW 1
77284: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77285: LD_VAR 0 6
77289: PPUSH
77290: LD_INT 0
77292: PPUSH
77293: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77297: LD_VAR 0 6
77301: PPUSH
77302: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77306: LD_ADDR_EXP 52
77310: PUSH
77311: LD_EXP 52
77315: PPUSH
77316: LD_VAR 0 5
77320: PPUSH
77321: LD_EXP 52
77325: PUSH
77326: LD_VAR 0 5
77330: ARRAY
77331: PPUSH
77332: LD_INT 1
77334: PPUSH
77335: LD_VAR 0 6
77339: PPUSH
77340: CALL_OW 2
77344: PPUSH
77345: CALL_OW 1
77349: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77350: LD_VAR 0 5
77354: PPUSH
77355: LD_INT 112
77357: PPUSH
77358: CALL 54032 0 2
// end ; end ; end ;
77362: GO 77185
77364: POP
77365: POP
// end ;
77366: LD_VAR 0 3
77370: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77371: LD_INT 0
77373: PPUSH
77374: PPUSH
77375: PPUSH
77376: PPUSH
77377: PPUSH
77378: PPUSH
77379: PPUSH
77380: PPUSH
// if not mc_bases or not skirmish then
77381: LD_EXP 23
77385: NOT
77386: PUSH
77387: LD_EXP 21
77391: NOT
77392: OR
77393: IFFALSE 77397
// exit ;
77395: GO 78768
// for i = 1 to mc_bases do
77397: LD_ADDR_VAR 0 3
77401: PUSH
77402: DOUBLE
77403: LD_INT 1
77405: DEC
77406: ST_TO_ADDR
77407: LD_EXP 23
77411: PUSH
77412: FOR_TO
77413: IFFALSE 78766
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77415: LD_VAR 0 1
77419: PUSH
77420: LD_EXP 23
77424: PUSH
77425: LD_VAR 0 3
77429: ARRAY
77430: IN
77431: PUSH
77432: LD_VAR 0 1
77436: PUSH
77437: LD_EXP 30
77441: PUSH
77442: LD_VAR 0 3
77446: ARRAY
77447: IN
77448: OR
77449: PUSH
77450: LD_VAR 0 1
77454: PUSH
77455: LD_EXP 45
77459: PUSH
77460: LD_VAR 0 3
77464: ARRAY
77465: IN
77466: OR
77467: PUSH
77468: LD_VAR 0 1
77472: PUSH
77473: LD_EXP 42
77477: PUSH
77478: LD_VAR 0 3
77482: ARRAY
77483: IN
77484: OR
77485: PUSH
77486: LD_VAR 0 1
77490: PUSH
77491: LD_EXP 52
77495: PUSH
77496: LD_VAR 0 3
77500: ARRAY
77501: IN
77502: OR
77503: PUSH
77504: LD_VAR 0 1
77508: PUSH
77509: LD_EXP 53
77513: PUSH
77514: LD_VAR 0 3
77518: ARRAY
77519: IN
77520: OR
77521: IFFALSE 78764
// begin if un in mc_ape [ i ] then
77523: LD_VAR 0 1
77527: PUSH
77528: LD_EXP 52
77532: PUSH
77533: LD_VAR 0 3
77537: ARRAY
77538: IN
77539: IFFALSE 77578
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77541: LD_ADDR_EXP 52
77545: PUSH
77546: LD_EXP 52
77550: PPUSH
77551: LD_VAR 0 3
77555: PPUSH
77556: LD_EXP 52
77560: PUSH
77561: LD_VAR 0 3
77565: ARRAY
77566: PUSH
77567: LD_VAR 0 1
77571: DIFF
77572: PPUSH
77573: CALL_OW 1
77577: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77578: LD_VAR 0 1
77582: PUSH
77583: LD_EXP 53
77587: PUSH
77588: LD_VAR 0 3
77592: ARRAY
77593: IN
77594: IFFALSE 77618
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77596: LD_ADDR_EXP 53
77600: PUSH
77601: LD_EXP 53
77605: PPUSH
77606: LD_VAR 0 3
77610: PPUSH
77611: EMPTY
77612: PPUSH
77613: CALL_OW 1
77617: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77618: LD_VAR 0 1
77622: PPUSH
77623: CALL_OW 247
77627: PUSH
77628: LD_INT 2
77630: EQUAL
77631: PUSH
77632: LD_VAR 0 1
77636: PPUSH
77637: CALL_OW 110
77641: PUSH
77642: LD_INT 20
77644: EQUAL
77645: PUSH
77646: LD_VAR 0 1
77650: PUSH
77651: LD_EXP 45
77655: PUSH
77656: LD_VAR 0 3
77660: ARRAY
77661: IN
77662: OR
77663: PUSH
77664: LD_VAR 0 1
77668: PPUSH
77669: CALL_OW 264
77673: PUSH
77674: LD_INT 12
77676: PUSH
77677: LD_INT 51
77679: PUSH
77680: LD_EXP 68
77684: PUSH
77685: LD_INT 32
77687: PUSH
77688: LD_INT 13
77690: PUSH
77691: LD_INT 52
77693: PUSH
77694: LD_INT 31
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: IN
77706: OR
77707: AND
77708: IFFALSE 78016
// begin if un in mc_defender [ i ] then
77710: LD_VAR 0 1
77714: PUSH
77715: LD_EXP 45
77719: PUSH
77720: LD_VAR 0 3
77724: ARRAY
77725: IN
77726: IFFALSE 77765
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77728: LD_ADDR_EXP 45
77732: PUSH
77733: LD_EXP 45
77737: PPUSH
77738: LD_VAR 0 3
77742: PPUSH
77743: LD_EXP 45
77747: PUSH
77748: LD_VAR 0 3
77752: ARRAY
77753: PUSH
77754: LD_VAR 0 1
77758: DIFF
77759: PPUSH
77760: CALL_OW 1
77764: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
77765: LD_ADDR_VAR 0 8
77769: PUSH
77770: LD_VAR 0 3
77774: PPUSH
77775: LD_INT 3
77777: PPUSH
77778: CALL 74406 0 2
77782: ST_TO_ADDR
// if fac then
77783: LD_VAR 0 8
77787: IFFALSE 78016
// begin for j in fac do
77789: LD_ADDR_VAR 0 4
77793: PUSH
77794: LD_VAR 0 8
77798: PUSH
77799: FOR_IN
77800: IFFALSE 78014
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
77802: LD_ADDR_VAR 0 9
77806: PUSH
77807: LD_VAR 0 8
77811: PPUSH
77812: LD_VAR 0 1
77816: PPUSH
77817: CALL_OW 265
77821: PPUSH
77822: LD_VAR 0 1
77826: PPUSH
77827: CALL_OW 262
77831: PPUSH
77832: LD_VAR 0 1
77836: PPUSH
77837: CALL_OW 263
77841: PPUSH
77842: LD_VAR 0 1
77846: PPUSH
77847: CALL_OW 264
77851: PPUSH
77852: CALL 13486 0 5
77856: ST_TO_ADDR
// if components then
77857: LD_VAR 0 9
77861: IFFALSE 78012
// begin if GetWeapon ( un ) = ar_control_tower then
77863: LD_VAR 0 1
77867: PPUSH
77868: CALL_OW 264
77872: PUSH
77873: LD_INT 31
77875: EQUAL
77876: IFFALSE 77993
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
77878: LD_VAR 0 1
77882: PPUSH
77883: CALL_OW 311
77887: PPUSH
77888: LD_INT 0
77890: PPUSH
77891: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
77895: LD_ADDR_EXP 63
77899: PUSH
77900: LD_EXP 63
77904: PPUSH
77905: LD_VAR 0 3
77909: PPUSH
77910: LD_EXP 63
77914: PUSH
77915: LD_VAR 0 3
77919: ARRAY
77920: PUSH
77921: LD_VAR 0 1
77925: PPUSH
77926: CALL_OW 311
77930: DIFF
77931: PPUSH
77932: CALL_OW 1
77936: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
77937: LD_ADDR_VAR 0 7
77941: PUSH
77942: LD_EXP 44
77946: PUSH
77947: LD_VAR 0 3
77951: ARRAY
77952: PPUSH
77953: LD_INT 1
77955: PPUSH
77956: LD_VAR 0 9
77960: PPUSH
77961: CALL_OW 2
77965: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77966: LD_ADDR_EXP 44
77970: PUSH
77971: LD_EXP 44
77975: PPUSH
77976: LD_VAR 0 3
77980: PPUSH
77981: LD_VAR 0 7
77985: PPUSH
77986: CALL_OW 1
77990: ST_TO_ADDR
// end else
77991: GO 78010
// MC_InsertProduceList ( i , [ components ] ) ;
77993: LD_VAR 0 3
77997: PPUSH
77998: LD_VAR 0 9
78002: PUSH
78003: EMPTY
78004: LIST
78005: PPUSH
78006: CALL 73951 0 2
// break ;
78010: GO 78014
// end ; end ;
78012: GO 77799
78014: POP
78015: POP
// end ; end ; if GetType ( un ) = unit_building then
78016: LD_VAR 0 1
78020: PPUSH
78021: CALL_OW 247
78025: PUSH
78026: LD_INT 3
78028: EQUAL
78029: IFFALSE 78432
// begin btype := GetBType ( un ) ;
78031: LD_ADDR_VAR 0 5
78035: PUSH
78036: LD_VAR 0 1
78040: PPUSH
78041: CALL_OW 266
78045: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78046: LD_VAR 0 5
78050: PUSH
78051: LD_INT 29
78053: PUSH
78054: LD_INT 30
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: IN
78061: IFFALSE 78134
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78063: LD_VAR 0 1
78067: PPUSH
78068: CALL_OW 250
78072: PPUSH
78073: LD_VAR 0 1
78077: PPUSH
78078: CALL_OW 251
78082: PPUSH
78083: LD_VAR 0 1
78087: PPUSH
78088: CALL_OW 255
78092: PPUSH
78093: CALL_OW 440
78097: NOT
78098: IFFALSE 78134
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78100: LD_VAR 0 1
78104: PPUSH
78105: CALL_OW 250
78109: PPUSH
78110: LD_VAR 0 1
78114: PPUSH
78115: CALL_OW 251
78119: PPUSH
78120: LD_VAR 0 1
78124: PPUSH
78125: CALL_OW 255
78129: PPUSH
78130: CALL_OW 441
// end ; if btype = b_warehouse then
78134: LD_VAR 0 5
78138: PUSH
78139: LD_INT 1
78141: EQUAL
78142: IFFALSE 78160
// begin btype := b_depot ;
78144: LD_ADDR_VAR 0 5
78148: PUSH
78149: LD_INT 0
78151: ST_TO_ADDR
// pos := 1 ;
78152: LD_ADDR_VAR 0 6
78156: PUSH
78157: LD_INT 1
78159: ST_TO_ADDR
// end ; if btype = b_factory then
78160: LD_VAR 0 5
78164: PUSH
78165: LD_INT 3
78167: EQUAL
78168: IFFALSE 78186
// begin btype := b_workshop ;
78170: LD_ADDR_VAR 0 5
78174: PUSH
78175: LD_INT 2
78177: ST_TO_ADDR
// pos := 1 ;
78178: LD_ADDR_VAR 0 6
78182: PUSH
78183: LD_INT 1
78185: ST_TO_ADDR
// end ; if btype = b_barracks then
78186: LD_VAR 0 5
78190: PUSH
78191: LD_INT 5
78193: EQUAL
78194: IFFALSE 78204
// btype := b_armoury ;
78196: LD_ADDR_VAR 0 5
78200: PUSH
78201: LD_INT 4
78203: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78204: LD_VAR 0 5
78208: PUSH
78209: LD_INT 7
78211: PUSH
78212: LD_INT 8
78214: PUSH
78215: EMPTY
78216: LIST
78217: LIST
78218: IN
78219: IFFALSE 78229
// btype := b_lab ;
78221: LD_ADDR_VAR 0 5
78225: PUSH
78226: LD_INT 6
78228: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78229: LD_ADDR_EXP 28
78233: PUSH
78234: LD_EXP 28
78238: PPUSH
78239: LD_VAR 0 3
78243: PUSH
78244: LD_EXP 28
78248: PUSH
78249: LD_VAR 0 3
78253: ARRAY
78254: PUSH
78255: LD_INT 1
78257: PLUS
78258: PUSH
78259: EMPTY
78260: LIST
78261: LIST
78262: PPUSH
78263: LD_VAR 0 5
78267: PUSH
78268: LD_VAR 0 1
78272: PPUSH
78273: CALL_OW 250
78277: PUSH
78278: LD_VAR 0 1
78282: PPUSH
78283: CALL_OW 251
78287: PUSH
78288: LD_VAR 0 1
78292: PPUSH
78293: CALL_OW 254
78297: PUSH
78298: EMPTY
78299: LIST
78300: LIST
78301: LIST
78302: LIST
78303: PPUSH
78304: CALL 15990 0 3
78308: ST_TO_ADDR
// if pos = 1 then
78309: LD_VAR 0 6
78313: PUSH
78314: LD_INT 1
78316: EQUAL
78317: IFFALSE 78432
// begin tmp := mc_build_list [ i ] ;
78319: LD_ADDR_VAR 0 7
78323: PUSH
78324: LD_EXP 28
78328: PUSH
78329: LD_VAR 0 3
78333: ARRAY
78334: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78335: LD_VAR 0 7
78339: PPUSH
78340: LD_INT 2
78342: PUSH
78343: LD_INT 30
78345: PUSH
78346: LD_INT 0
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 30
78355: PUSH
78356: LD_INT 1
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: LIST
78367: PPUSH
78368: CALL_OW 72
78372: IFFALSE 78382
// pos := 2 ;
78374: LD_ADDR_VAR 0 6
78378: PUSH
78379: LD_INT 2
78381: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78382: LD_ADDR_VAR 0 7
78386: PUSH
78387: LD_VAR 0 7
78391: PPUSH
78392: LD_VAR 0 6
78396: PPUSH
78397: LD_VAR 0 7
78401: PPUSH
78402: CALL 16316 0 3
78406: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78407: LD_ADDR_EXP 28
78411: PUSH
78412: LD_EXP 28
78416: PPUSH
78417: LD_VAR 0 3
78421: PPUSH
78422: LD_VAR 0 7
78426: PPUSH
78427: CALL_OW 1
78431: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78432: LD_VAR 0 1
78436: PUSH
78437: LD_EXP 23
78441: PUSH
78442: LD_VAR 0 3
78446: ARRAY
78447: IN
78448: IFFALSE 78487
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78450: LD_ADDR_EXP 23
78454: PUSH
78455: LD_EXP 23
78459: PPUSH
78460: LD_VAR 0 3
78464: PPUSH
78465: LD_EXP 23
78469: PUSH
78470: LD_VAR 0 3
78474: ARRAY
78475: PUSH
78476: LD_VAR 0 1
78480: DIFF
78481: PPUSH
78482: CALL_OW 1
78486: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78487: LD_VAR 0 1
78491: PUSH
78492: LD_EXP 30
78496: PUSH
78497: LD_VAR 0 3
78501: ARRAY
78502: IN
78503: IFFALSE 78542
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78505: LD_ADDR_EXP 30
78509: PUSH
78510: LD_EXP 30
78514: PPUSH
78515: LD_VAR 0 3
78519: PPUSH
78520: LD_EXP 30
78524: PUSH
78525: LD_VAR 0 3
78529: ARRAY
78530: PUSH
78531: LD_VAR 0 1
78535: DIFF
78536: PPUSH
78537: CALL_OW 1
78541: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78542: LD_VAR 0 1
78546: PUSH
78547: LD_EXP 42
78551: PUSH
78552: LD_VAR 0 3
78556: ARRAY
78557: IN
78558: IFFALSE 78597
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78560: LD_ADDR_EXP 42
78564: PUSH
78565: LD_EXP 42
78569: PPUSH
78570: LD_VAR 0 3
78574: PPUSH
78575: LD_EXP 42
78579: PUSH
78580: LD_VAR 0 3
78584: ARRAY
78585: PUSH
78586: LD_VAR 0 1
78590: DIFF
78591: PPUSH
78592: CALL_OW 1
78596: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78597: LD_VAR 0 1
78601: PUSH
78602: LD_EXP 45
78606: PUSH
78607: LD_VAR 0 3
78611: ARRAY
78612: IN
78613: IFFALSE 78652
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78615: LD_ADDR_EXP 45
78619: PUSH
78620: LD_EXP 45
78624: PPUSH
78625: LD_VAR 0 3
78629: PPUSH
78630: LD_EXP 45
78634: PUSH
78635: LD_VAR 0 3
78639: ARRAY
78640: PUSH
78641: LD_VAR 0 1
78645: DIFF
78646: PPUSH
78647: CALL_OW 1
78651: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78652: LD_VAR 0 1
78656: PUSH
78657: LD_EXP 32
78661: PUSH
78662: LD_VAR 0 3
78666: ARRAY
78667: IN
78668: IFFALSE 78707
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78670: LD_ADDR_EXP 32
78674: PUSH
78675: LD_EXP 32
78679: PPUSH
78680: LD_VAR 0 3
78684: PPUSH
78685: LD_EXP 32
78689: PUSH
78690: LD_VAR 0 3
78694: ARRAY
78695: PUSH
78696: LD_VAR 0 1
78700: DIFF
78701: PPUSH
78702: CALL_OW 1
78706: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78707: LD_VAR 0 1
78711: PUSH
78712: LD_EXP 31
78716: PUSH
78717: LD_VAR 0 3
78721: ARRAY
78722: IN
78723: IFFALSE 78762
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78725: LD_ADDR_EXP 31
78729: PUSH
78730: LD_EXP 31
78734: PPUSH
78735: LD_VAR 0 3
78739: PPUSH
78740: LD_EXP 31
78744: PUSH
78745: LD_VAR 0 3
78749: ARRAY
78750: PUSH
78751: LD_VAR 0 1
78755: DIFF
78756: PPUSH
78757: CALL_OW 1
78761: ST_TO_ADDR
// end ; break ;
78762: GO 78766
// end ;
78764: GO 77412
78766: POP
78767: POP
// end ;
78768: LD_VAR 0 2
78772: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
78773: LD_INT 0
78775: PPUSH
78776: PPUSH
78777: PPUSH
// if not mc_bases or not skirmish then
78778: LD_EXP 23
78782: NOT
78783: PUSH
78784: LD_EXP 21
78788: NOT
78789: OR
78790: IFFALSE 78794
// exit ;
78792: GO 79009
// for i = 1 to mc_bases do
78794: LD_ADDR_VAR 0 3
78798: PUSH
78799: DOUBLE
78800: LD_INT 1
78802: DEC
78803: ST_TO_ADDR
78804: LD_EXP 23
78808: PUSH
78809: FOR_TO
78810: IFFALSE 79007
// begin if building in mc_construct_list [ i ] then
78812: LD_VAR 0 1
78816: PUSH
78817: LD_EXP 30
78821: PUSH
78822: LD_VAR 0 3
78826: ARRAY
78827: IN
78828: IFFALSE 79005
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
78830: LD_ADDR_EXP 30
78834: PUSH
78835: LD_EXP 30
78839: PPUSH
78840: LD_VAR 0 3
78844: PPUSH
78845: LD_EXP 30
78849: PUSH
78850: LD_VAR 0 3
78854: ARRAY
78855: PUSH
78856: LD_VAR 0 1
78860: DIFF
78861: PPUSH
78862: CALL_OW 1
78866: ST_TO_ADDR
// if building in mc_lab [ i ] then
78867: LD_VAR 0 1
78871: PUSH
78872: LD_EXP 56
78876: PUSH
78877: LD_VAR 0 3
78881: ARRAY
78882: IN
78883: IFFALSE 78938
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
78885: LD_ADDR_EXP 57
78889: PUSH
78890: LD_EXP 57
78894: PPUSH
78895: LD_VAR 0 3
78899: PPUSH
78900: LD_EXP 57
78904: PUSH
78905: LD_VAR 0 3
78909: ARRAY
78910: PPUSH
78911: LD_INT 1
78913: PPUSH
78914: LD_EXP 57
78918: PUSH
78919: LD_VAR 0 3
78923: ARRAY
78924: PPUSH
78925: LD_INT 0
78927: PPUSH
78928: CALL 15408 0 4
78932: PPUSH
78933: CALL_OW 1
78937: ST_TO_ADDR
// if not building in mc_bases [ i ] then
78938: LD_VAR 0 1
78942: PUSH
78943: LD_EXP 23
78947: PUSH
78948: LD_VAR 0 3
78952: ARRAY
78953: IN
78954: NOT
78955: IFFALSE 79001
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
78957: LD_ADDR_EXP 23
78961: PUSH
78962: LD_EXP 23
78966: PPUSH
78967: LD_VAR 0 3
78971: PUSH
78972: LD_EXP 23
78976: PUSH
78977: LD_VAR 0 3
78981: ARRAY
78982: PUSH
78983: LD_INT 1
78985: PLUS
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PPUSH
78991: LD_VAR 0 1
78995: PPUSH
78996: CALL 15990 0 3
79000: ST_TO_ADDR
// exit ;
79001: POP
79002: POP
79003: GO 79009
// end ; end ;
79005: GO 78809
79007: POP
79008: POP
// end ;
79009: LD_VAR 0 2
79013: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79014: LD_INT 0
79016: PPUSH
79017: PPUSH
79018: PPUSH
79019: PPUSH
79020: PPUSH
79021: PPUSH
79022: PPUSH
// if not mc_bases or not skirmish then
79023: LD_EXP 23
79027: NOT
79028: PUSH
79029: LD_EXP 21
79033: NOT
79034: OR
79035: IFFALSE 79039
// exit ;
79037: GO 79700
// for i = 1 to mc_bases do
79039: LD_ADDR_VAR 0 3
79043: PUSH
79044: DOUBLE
79045: LD_INT 1
79047: DEC
79048: ST_TO_ADDR
79049: LD_EXP 23
79053: PUSH
79054: FOR_TO
79055: IFFALSE 79698
// begin if building in mc_construct_list [ i ] then
79057: LD_VAR 0 1
79061: PUSH
79062: LD_EXP 30
79066: PUSH
79067: LD_VAR 0 3
79071: ARRAY
79072: IN
79073: IFFALSE 79696
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79075: LD_ADDR_EXP 30
79079: PUSH
79080: LD_EXP 30
79084: PPUSH
79085: LD_VAR 0 3
79089: PPUSH
79090: LD_EXP 30
79094: PUSH
79095: LD_VAR 0 3
79099: ARRAY
79100: PUSH
79101: LD_VAR 0 1
79105: DIFF
79106: PPUSH
79107: CALL_OW 1
79111: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79112: LD_ADDR_EXP 23
79116: PUSH
79117: LD_EXP 23
79121: PPUSH
79122: LD_VAR 0 3
79126: PUSH
79127: LD_EXP 23
79131: PUSH
79132: LD_VAR 0 3
79136: ARRAY
79137: PUSH
79138: LD_INT 1
79140: PLUS
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PPUSH
79146: LD_VAR 0 1
79150: PPUSH
79151: CALL 15990 0 3
79155: ST_TO_ADDR
// btype := GetBType ( building ) ;
79156: LD_ADDR_VAR 0 5
79160: PUSH
79161: LD_VAR 0 1
79165: PPUSH
79166: CALL_OW 266
79170: ST_TO_ADDR
// side := GetSide ( building ) ;
79171: LD_ADDR_VAR 0 8
79175: PUSH
79176: LD_VAR 0 1
79180: PPUSH
79181: CALL_OW 255
79185: ST_TO_ADDR
// if btype = b_lab then
79186: LD_VAR 0 5
79190: PUSH
79191: LD_INT 6
79193: EQUAL
79194: IFFALSE 79244
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79196: LD_ADDR_EXP 56
79200: PUSH
79201: LD_EXP 56
79205: PPUSH
79206: LD_VAR 0 3
79210: PUSH
79211: LD_EXP 56
79215: PUSH
79216: LD_VAR 0 3
79220: ARRAY
79221: PUSH
79222: LD_INT 1
79224: PLUS
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: PPUSH
79230: LD_VAR 0 1
79234: PPUSH
79235: CALL 15990 0 3
79239: ST_TO_ADDR
// exit ;
79240: POP
79241: POP
79242: GO 79700
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79244: LD_VAR 0 5
79248: PUSH
79249: LD_INT 0
79251: PUSH
79252: LD_INT 2
79254: PUSH
79255: LD_INT 4
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: LIST
79262: IN
79263: IFFALSE 79387
// begin if btype = b_armoury then
79265: LD_VAR 0 5
79269: PUSH
79270: LD_INT 4
79272: EQUAL
79273: IFFALSE 79283
// btype := b_barracks ;
79275: LD_ADDR_VAR 0 5
79279: PUSH
79280: LD_INT 5
79282: ST_TO_ADDR
// if btype = b_depot then
79283: LD_VAR 0 5
79287: PUSH
79288: LD_INT 0
79290: EQUAL
79291: IFFALSE 79301
// btype := b_warehouse ;
79293: LD_ADDR_VAR 0 5
79297: PUSH
79298: LD_INT 1
79300: ST_TO_ADDR
// if btype = b_workshop then
79301: LD_VAR 0 5
79305: PUSH
79306: LD_INT 2
79308: EQUAL
79309: IFFALSE 79319
// btype := b_factory ;
79311: LD_ADDR_VAR 0 5
79315: PUSH
79316: LD_INT 3
79318: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79319: LD_VAR 0 5
79323: PPUSH
79324: LD_VAR 0 8
79328: PPUSH
79329: CALL_OW 323
79333: PUSH
79334: LD_INT 1
79336: EQUAL
79337: IFFALSE 79383
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79339: LD_ADDR_EXP 55
79343: PUSH
79344: LD_EXP 55
79348: PPUSH
79349: LD_VAR 0 3
79353: PUSH
79354: LD_EXP 55
79358: PUSH
79359: LD_VAR 0 3
79363: ARRAY
79364: PUSH
79365: LD_INT 1
79367: PLUS
79368: PUSH
79369: EMPTY
79370: LIST
79371: LIST
79372: PPUSH
79373: LD_VAR 0 1
79377: PPUSH
79378: CALL 15990 0 3
79382: ST_TO_ADDR
// exit ;
79383: POP
79384: POP
79385: GO 79700
// end ; if btype in [ b_bunker , b_turret ] then
79387: LD_VAR 0 5
79391: PUSH
79392: LD_INT 32
79394: PUSH
79395: LD_INT 33
79397: PUSH
79398: EMPTY
79399: LIST
79400: LIST
79401: IN
79402: IFFALSE 79692
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79404: LD_ADDR_EXP 31
79408: PUSH
79409: LD_EXP 31
79413: PPUSH
79414: LD_VAR 0 3
79418: PUSH
79419: LD_EXP 31
79423: PUSH
79424: LD_VAR 0 3
79428: ARRAY
79429: PUSH
79430: LD_INT 1
79432: PLUS
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PPUSH
79438: LD_VAR 0 1
79442: PPUSH
79443: CALL 15990 0 3
79447: ST_TO_ADDR
// if btype = b_bunker then
79448: LD_VAR 0 5
79452: PUSH
79453: LD_INT 32
79455: EQUAL
79456: IFFALSE 79692
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79458: LD_ADDR_EXP 32
79462: PUSH
79463: LD_EXP 32
79467: PPUSH
79468: LD_VAR 0 3
79472: PUSH
79473: LD_EXP 32
79477: PUSH
79478: LD_VAR 0 3
79482: ARRAY
79483: PUSH
79484: LD_INT 1
79486: PLUS
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PPUSH
79492: LD_VAR 0 1
79496: PPUSH
79497: CALL 15990 0 3
79501: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79502: LD_ADDR_VAR 0 6
79506: PUSH
79507: LD_EXP 23
79511: PUSH
79512: LD_VAR 0 3
79516: ARRAY
79517: PPUSH
79518: LD_INT 25
79520: PUSH
79521: LD_INT 1
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 3
79530: PUSH
79531: LD_INT 54
79533: PUSH
79534: EMPTY
79535: LIST
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: PUSH
79541: EMPTY
79542: LIST
79543: LIST
79544: PPUSH
79545: CALL_OW 72
79549: ST_TO_ADDR
// if tmp then
79550: LD_VAR 0 6
79554: IFFALSE 79560
// exit ;
79556: POP
79557: POP
79558: GO 79700
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79560: LD_ADDR_VAR 0 6
79564: PUSH
79565: LD_EXP 23
79569: PUSH
79570: LD_VAR 0 3
79574: ARRAY
79575: PPUSH
79576: LD_INT 2
79578: PUSH
79579: LD_INT 30
79581: PUSH
79582: LD_INT 4
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 30
79591: PUSH
79592: LD_INT 5
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: PPUSH
79604: CALL_OW 72
79608: ST_TO_ADDR
// if not tmp then
79609: LD_VAR 0 6
79613: NOT
79614: IFFALSE 79620
// exit ;
79616: POP
79617: POP
79618: GO 79700
// for j in tmp do
79620: LD_ADDR_VAR 0 4
79624: PUSH
79625: LD_VAR 0 6
79629: PUSH
79630: FOR_IN
79631: IFFALSE 79690
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79633: LD_ADDR_VAR 0 7
79637: PUSH
79638: LD_VAR 0 4
79642: PPUSH
79643: CALL_OW 313
79647: PPUSH
79648: LD_INT 25
79650: PUSH
79651: LD_INT 1
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PPUSH
79658: CALL_OW 72
79662: ST_TO_ADDR
// if units then
79663: LD_VAR 0 7
79667: IFFALSE 79688
// begin ComExitBuilding ( units [ 1 ] ) ;
79669: LD_VAR 0 7
79673: PUSH
79674: LD_INT 1
79676: ARRAY
79677: PPUSH
79678: CALL_OW 122
// exit ;
79682: POP
79683: POP
79684: POP
79685: POP
79686: GO 79700
// end ; end ;
79688: GO 79630
79690: POP
79691: POP
// end ; end ; exit ;
79692: POP
79693: POP
79694: GO 79700
// end ; end ;
79696: GO 79054
79698: POP
79699: POP
// end ;
79700: LD_VAR 0 2
79704: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79705: LD_INT 0
79707: PPUSH
79708: PPUSH
79709: PPUSH
79710: PPUSH
79711: PPUSH
79712: PPUSH
79713: PPUSH
// if not mc_bases or not skirmish then
79714: LD_EXP 23
79718: NOT
79719: PUSH
79720: LD_EXP 21
79724: NOT
79725: OR
79726: IFFALSE 79730
// exit ;
79728: GO 79995
// btype := GetBType ( building ) ;
79730: LD_ADDR_VAR 0 6
79734: PUSH
79735: LD_VAR 0 1
79739: PPUSH
79740: CALL_OW 266
79744: ST_TO_ADDR
// x := GetX ( building ) ;
79745: LD_ADDR_VAR 0 7
79749: PUSH
79750: LD_VAR 0 1
79754: PPUSH
79755: CALL_OW 250
79759: ST_TO_ADDR
// y := GetY ( building ) ;
79760: LD_ADDR_VAR 0 8
79764: PUSH
79765: LD_VAR 0 1
79769: PPUSH
79770: CALL_OW 251
79774: ST_TO_ADDR
// d := GetDir ( building ) ;
79775: LD_ADDR_VAR 0 9
79779: PUSH
79780: LD_VAR 0 1
79784: PPUSH
79785: CALL_OW 254
79789: ST_TO_ADDR
// for i = 1 to mc_bases do
79790: LD_ADDR_VAR 0 4
79794: PUSH
79795: DOUBLE
79796: LD_INT 1
79798: DEC
79799: ST_TO_ADDR
79800: LD_EXP 23
79804: PUSH
79805: FOR_TO
79806: IFFALSE 79993
// begin if not mc_build_list [ i ] then
79808: LD_EXP 28
79812: PUSH
79813: LD_VAR 0 4
79817: ARRAY
79818: NOT
79819: IFFALSE 79823
// continue ;
79821: GO 79805
// for j := 1 to mc_build_list [ i ] do
79823: LD_ADDR_VAR 0 5
79827: PUSH
79828: DOUBLE
79829: LD_INT 1
79831: DEC
79832: ST_TO_ADDR
79833: LD_EXP 28
79837: PUSH
79838: LD_VAR 0 4
79842: ARRAY
79843: PUSH
79844: FOR_TO
79845: IFFALSE 79989
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
79847: LD_VAR 0 6
79851: PUSH
79852: LD_VAR 0 7
79856: PUSH
79857: LD_VAR 0 8
79861: PUSH
79862: LD_VAR 0 9
79866: PUSH
79867: EMPTY
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: PPUSH
79873: LD_EXP 28
79877: PUSH
79878: LD_VAR 0 4
79882: ARRAY
79883: PUSH
79884: LD_VAR 0 5
79888: ARRAY
79889: PPUSH
79890: CALL 22172 0 2
79894: IFFALSE 79987
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
79896: LD_ADDR_EXP 28
79900: PUSH
79901: LD_EXP 28
79905: PPUSH
79906: LD_VAR 0 4
79910: PPUSH
79911: LD_EXP 28
79915: PUSH
79916: LD_VAR 0 4
79920: ARRAY
79921: PPUSH
79922: LD_VAR 0 5
79926: PPUSH
79927: CALL_OW 3
79931: PPUSH
79932: CALL_OW 1
79936: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
79937: LD_ADDR_EXP 30
79941: PUSH
79942: LD_EXP 30
79946: PPUSH
79947: LD_VAR 0 4
79951: PUSH
79952: LD_EXP 30
79956: PUSH
79957: LD_VAR 0 4
79961: ARRAY
79962: PUSH
79963: LD_INT 1
79965: PLUS
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PPUSH
79971: LD_VAR 0 1
79975: PPUSH
79976: CALL 15990 0 3
79980: ST_TO_ADDR
// exit ;
79981: POP
79982: POP
79983: POP
79984: POP
79985: GO 79995
// end ;
79987: GO 79844
79989: POP
79990: POP
// end ;
79991: GO 79805
79993: POP
79994: POP
// end ;
79995: LD_VAR 0 3
79999: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80000: LD_INT 0
80002: PPUSH
80003: PPUSH
80004: PPUSH
// if not mc_bases or not skirmish then
80005: LD_EXP 23
80009: NOT
80010: PUSH
80011: LD_EXP 21
80015: NOT
80016: OR
80017: IFFALSE 80021
// exit ;
80019: GO 80211
// for i = 1 to mc_bases do
80021: LD_ADDR_VAR 0 4
80025: PUSH
80026: DOUBLE
80027: LD_INT 1
80029: DEC
80030: ST_TO_ADDR
80031: LD_EXP 23
80035: PUSH
80036: FOR_TO
80037: IFFALSE 80124
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80039: LD_VAR 0 1
80043: PUSH
80044: LD_EXP 31
80048: PUSH
80049: LD_VAR 0 4
80053: ARRAY
80054: IN
80055: PUSH
80056: LD_VAR 0 1
80060: PUSH
80061: LD_EXP 32
80065: PUSH
80066: LD_VAR 0 4
80070: ARRAY
80071: IN
80072: NOT
80073: AND
80074: IFFALSE 80122
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80076: LD_ADDR_EXP 32
80080: PUSH
80081: LD_EXP 32
80085: PPUSH
80086: LD_VAR 0 4
80090: PUSH
80091: LD_EXP 32
80095: PUSH
80096: LD_VAR 0 4
80100: ARRAY
80101: PUSH
80102: LD_INT 1
80104: PLUS
80105: PUSH
80106: EMPTY
80107: LIST
80108: LIST
80109: PPUSH
80110: LD_VAR 0 1
80114: PPUSH
80115: CALL 15990 0 3
80119: ST_TO_ADDR
// break ;
80120: GO 80124
// end ; end ;
80122: GO 80036
80124: POP
80125: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80126: LD_VAR 0 1
80130: PPUSH
80131: CALL_OW 257
80135: PUSH
80136: LD_EXP 49
80140: IN
80141: PUSH
80142: LD_VAR 0 1
80146: PPUSH
80147: CALL_OW 266
80151: PUSH
80152: LD_INT 5
80154: EQUAL
80155: AND
80156: PUSH
80157: LD_VAR 0 2
80161: PPUSH
80162: CALL_OW 110
80166: PUSH
80167: LD_INT 18
80169: NONEQUAL
80170: AND
80171: IFFALSE 80211
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80173: LD_VAR 0 2
80177: PPUSH
80178: CALL_OW 257
80182: PUSH
80183: LD_INT 5
80185: PUSH
80186: LD_INT 8
80188: PUSH
80189: LD_INT 9
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: LIST
80196: IN
80197: IFFALSE 80211
// SetClass ( unit , 1 ) ;
80199: LD_VAR 0 2
80203: PPUSH
80204: LD_INT 1
80206: PPUSH
80207: CALL_OW 336
// end ;
80211: LD_VAR 0 3
80215: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80216: LD_INT 0
80218: PPUSH
80219: PPUSH
// if not mc_bases or not skirmish then
80220: LD_EXP 23
80224: NOT
80225: PUSH
80226: LD_EXP 21
80230: NOT
80231: OR
80232: IFFALSE 80236
// exit ;
80234: GO 80352
// if GetLives ( abandoned_vehicle ) > 250 then
80236: LD_VAR 0 2
80240: PPUSH
80241: CALL_OW 256
80245: PUSH
80246: LD_INT 250
80248: GREATER
80249: IFFALSE 80253
// exit ;
80251: GO 80352
// for i = 1 to mc_bases do
80253: LD_ADDR_VAR 0 6
80257: PUSH
80258: DOUBLE
80259: LD_INT 1
80261: DEC
80262: ST_TO_ADDR
80263: LD_EXP 23
80267: PUSH
80268: FOR_TO
80269: IFFALSE 80350
// begin if driver in mc_bases [ i ] then
80271: LD_VAR 0 1
80275: PUSH
80276: LD_EXP 23
80280: PUSH
80281: LD_VAR 0 6
80285: ARRAY
80286: IN
80287: IFFALSE 80348
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80289: LD_VAR 0 1
80293: PPUSH
80294: LD_EXP 23
80298: PUSH
80299: LD_VAR 0 6
80303: ARRAY
80304: PPUSH
80305: LD_INT 2
80307: PUSH
80308: LD_INT 30
80310: PUSH
80311: LD_INT 0
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 30
80320: PUSH
80321: LD_INT 1
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: EMPTY
80329: LIST
80330: LIST
80331: LIST
80332: PPUSH
80333: CALL_OW 72
80337: PUSH
80338: LD_INT 1
80340: ARRAY
80341: PPUSH
80342: CALL 48608 0 2
// break ;
80346: GO 80350
// end ; end ;
80348: GO 80268
80350: POP
80351: POP
// end ; end_of_file
80352: LD_VAR 0 5
80356: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
80357: LD_INT 0
80359: PPUSH
// ar_miner := 81 ;
80360: LD_ADDR_EXP 74
80364: PUSH
80365: LD_INT 81
80367: ST_TO_ADDR
// ar_crane := 88 ;
80368: LD_ADDR_EXP 73
80372: PUSH
80373: LD_INT 88
80375: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80376: LD_ADDR_EXP 68
80380: PUSH
80381: LD_INT 89
80383: ST_TO_ADDR
// us_hack := 99 ;
80384: LD_ADDR_EXP 69
80388: PUSH
80389: LD_INT 99
80391: ST_TO_ADDR
// us_artillery := 97 ;
80392: LD_ADDR_EXP 70
80396: PUSH
80397: LD_INT 97
80399: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80400: LD_ADDR_EXP 71
80404: PUSH
80405: LD_INT 91
80407: ST_TO_ADDR
// ar_mortar := 92 ;
80408: LD_ADDR_EXP 72
80412: PUSH
80413: LD_INT 92
80415: ST_TO_ADDR
// ru_radar := 98 ;
80416: LD_ADDR_EXP 67
80420: PUSH
80421: LD_INT 98
80423: ST_TO_ADDR
// tech_Artillery := 80 ;
80424: LD_ADDR_EXP 75
80428: PUSH
80429: LD_INT 80
80431: ST_TO_ADDR
// tech_RadMat := 81 ;
80432: LD_ADDR_EXP 76
80436: PUSH
80437: LD_INT 81
80439: ST_TO_ADDR
// tech_BasicTools := 82 ;
80440: LD_ADDR_EXP 77
80444: PUSH
80445: LD_INT 82
80447: ST_TO_ADDR
// tech_Cargo := 83 ;
80448: LD_ADDR_EXP 78
80452: PUSH
80453: LD_INT 83
80455: ST_TO_ADDR
// tech_Track := 84 ;
80456: LD_ADDR_EXP 79
80460: PUSH
80461: LD_INT 84
80463: ST_TO_ADDR
// tech_Crane := 85 ;
80464: LD_ADDR_EXP 80
80468: PUSH
80469: LD_INT 85
80471: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80472: LD_ADDR_EXP 81
80476: PUSH
80477: LD_INT 86
80479: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80480: LD_ADDR_EXP 82
80484: PUSH
80485: LD_INT 87
80487: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
80488: LD_ADDR_EXP 83
80492: PUSH
80493: LD_INT 88
80495: ST_TO_ADDR
// class_mastodont := 31 ;
80496: LD_ADDR_EXP 84
80500: PUSH
80501: LD_INT 31
80503: ST_TO_ADDR
// class_horse := 21 ;
80504: LD_ADDR_EXP 85
80508: PUSH
80509: LD_INT 21
80511: ST_TO_ADDR
// end ;
80512: LD_VAR 0 1
80516: RET
// every 1 do
80517: GO 80519
80519: DISABLE
// InitGlobalVariables ; end_of_file
80520: CALL 80357 0 0
80524: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80525: LD_INT 0
80527: PPUSH
80528: PPUSH
80529: PPUSH
80530: PPUSH
80531: PPUSH
80532: PPUSH
80533: PPUSH
80534: PPUSH
80535: PPUSH
80536: PPUSH
80537: PPUSH
80538: PPUSH
80539: PPUSH
80540: PPUSH
80541: PPUSH
80542: PPUSH
80543: PPUSH
80544: PPUSH
80545: PPUSH
80546: PPUSH
80547: PPUSH
80548: PPUSH
80549: PPUSH
80550: PPUSH
80551: PPUSH
80552: PPUSH
80553: PPUSH
80554: PPUSH
80555: PPUSH
80556: PPUSH
80557: PPUSH
80558: PPUSH
80559: PPUSH
80560: PPUSH
// if not list then
80561: LD_VAR 0 1
80565: NOT
80566: IFFALSE 80570
// exit ;
80568: GO 85229
// base := list [ 1 ] ;
80570: LD_ADDR_VAR 0 3
80574: PUSH
80575: LD_VAR 0 1
80579: PUSH
80580: LD_INT 1
80582: ARRAY
80583: ST_TO_ADDR
// group := list [ 2 ] ;
80584: LD_ADDR_VAR 0 4
80588: PUSH
80589: LD_VAR 0 1
80593: PUSH
80594: LD_INT 2
80596: ARRAY
80597: ST_TO_ADDR
// path := list [ 3 ] ;
80598: LD_ADDR_VAR 0 5
80602: PUSH
80603: LD_VAR 0 1
80607: PUSH
80608: LD_INT 3
80610: ARRAY
80611: ST_TO_ADDR
// flags := list [ 4 ] ;
80612: LD_ADDR_VAR 0 6
80616: PUSH
80617: LD_VAR 0 1
80621: PUSH
80622: LD_INT 4
80624: ARRAY
80625: ST_TO_ADDR
// mined := [ ] ;
80626: LD_ADDR_VAR 0 27
80630: PUSH
80631: EMPTY
80632: ST_TO_ADDR
// bombed := [ ] ;
80633: LD_ADDR_VAR 0 28
80637: PUSH
80638: EMPTY
80639: ST_TO_ADDR
// healers := [ ] ;
80640: LD_ADDR_VAR 0 31
80644: PUSH
80645: EMPTY
80646: ST_TO_ADDR
// to_heal := [ ] ;
80647: LD_ADDR_VAR 0 30
80651: PUSH
80652: EMPTY
80653: ST_TO_ADDR
// repairs := [ ] ;
80654: LD_ADDR_VAR 0 33
80658: PUSH
80659: EMPTY
80660: ST_TO_ADDR
// to_repair := [ ] ;
80661: LD_ADDR_VAR 0 32
80665: PUSH
80666: EMPTY
80667: ST_TO_ADDR
// if not group or not path then
80668: LD_VAR 0 4
80672: NOT
80673: PUSH
80674: LD_VAR 0 5
80678: NOT
80679: OR
80680: IFFALSE 80684
// exit ;
80682: GO 85229
// side := GetSide ( group [ 1 ] ) ;
80684: LD_ADDR_VAR 0 35
80688: PUSH
80689: LD_VAR 0 4
80693: PUSH
80694: LD_INT 1
80696: ARRAY
80697: PPUSH
80698: CALL_OW 255
80702: ST_TO_ADDR
// if flags then
80703: LD_VAR 0 6
80707: IFFALSE 80851
// begin f_ignore_area := flags [ 1 ] ;
80709: LD_ADDR_VAR 0 17
80713: PUSH
80714: LD_VAR 0 6
80718: PUSH
80719: LD_INT 1
80721: ARRAY
80722: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
80723: LD_ADDR_VAR 0 18
80727: PUSH
80728: LD_VAR 0 6
80732: PUSH
80733: LD_INT 2
80735: ARRAY
80736: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
80737: LD_ADDR_VAR 0 19
80741: PUSH
80742: LD_VAR 0 6
80746: PUSH
80747: LD_INT 3
80749: ARRAY
80750: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
80751: LD_ADDR_VAR 0 20
80755: PUSH
80756: LD_VAR 0 6
80760: PUSH
80761: LD_INT 4
80763: ARRAY
80764: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
80765: LD_ADDR_VAR 0 21
80769: PUSH
80770: LD_VAR 0 6
80774: PUSH
80775: LD_INT 5
80777: ARRAY
80778: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
80779: LD_ADDR_VAR 0 22
80783: PUSH
80784: LD_VAR 0 6
80788: PUSH
80789: LD_INT 6
80791: ARRAY
80792: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
80793: LD_ADDR_VAR 0 23
80797: PUSH
80798: LD_VAR 0 6
80802: PUSH
80803: LD_INT 7
80805: ARRAY
80806: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
80807: LD_ADDR_VAR 0 24
80811: PUSH
80812: LD_VAR 0 6
80816: PUSH
80817: LD_INT 8
80819: ARRAY
80820: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
80821: LD_ADDR_VAR 0 25
80825: PUSH
80826: LD_VAR 0 6
80830: PUSH
80831: LD_INT 9
80833: ARRAY
80834: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
80835: LD_ADDR_VAR 0 26
80839: PUSH
80840: LD_VAR 0 6
80844: PUSH
80845: LD_INT 10
80847: ARRAY
80848: ST_TO_ADDR
// end else
80849: GO 80931
// begin f_ignore_area := false ;
80851: LD_ADDR_VAR 0 17
80855: PUSH
80856: LD_INT 0
80858: ST_TO_ADDR
// f_capture := false ;
80859: LD_ADDR_VAR 0 18
80863: PUSH
80864: LD_INT 0
80866: ST_TO_ADDR
// f_ignore_civ := false ;
80867: LD_ADDR_VAR 0 19
80871: PUSH
80872: LD_INT 0
80874: ST_TO_ADDR
// f_murder := false ;
80875: LD_ADDR_VAR 0 20
80879: PUSH
80880: LD_INT 0
80882: ST_TO_ADDR
// f_mines := false ;
80883: LD_ADDR_VAR 0 21
80887: PUSH
80888: LD_INT 0
80890: ST_TO_ADDR
// f_repair := false ;
80891: LD_ADDR_VAR 0 22
80895: PUSH
80896: LD_INT 0
80898: ST_TO_ADDR
// f_heal := false ;
80899: LD_ADDR_VAR 0 23
80903: PUSH
80904: LD_INT 0
80906: ST_TO_ADDR
// f_spacetime := false ;
80907: LD_ADDR_VAR 0 24
80911: PUSH
80912: LD_INT 0
80914: ST_TO_ADDR
// f_attack_depot := false ;
80915: LD_ADDR_VAR 0 25
80919: PUSH
80920: LD_INT 0
80922: ST_TO_ADDR
// f_crawl := false ;
80923: LD_ADDR_VAR 0 26
80927: PUSH
80928: LD_INT 0
80930: ST_TO_ADDR
// end ; if f_heal then
80931: LD_VAR 0 23
80935: IFFALSE 80962
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
80937: LD_ADDR_VAR 0 31
80941: PUSH
80942: LD_VAR 0 4
80946: PPUSH
80947: LD_INT 25
80949: PUSH
80950: LD_INT 4
80952: PUSH
80953: EMPTY
80954: LIST
80955: LIST
80956: PPUSH
80957: CALL_OW 72
80961: ST_TO_ADDR
// if f_repair then
80962: LD_VAR 0 22
80966: IFFALSE 80993
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
80968: LD_ADDR_VAR 0 33
80972: PUSH
80973: LD_VAR 0 4
80977: PPUSH
80978: LD_INT 25
80980: PUSH
80981: LD_INT 3
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PPUSH
80988: CALL_OW 72
80992: ST_TO_ADDR
// units_path := [ ] ;
80993: LD_ADDR_VAR 0 16
80997: PUSH
80998: EMPTY
80999: ST_TO_ADDR
// for i = 1 to group do
81000: LD_ADDR_VAR 0 7
81004: PUSH
81005: DOUBLE
81006: LD_INT 1
81008: DEC
81009: ST_TO_ADDR
81010: LD_VAR 0 4
81014: PUSH
81015: FOR_TO
81016: IFFALSE 81045
// units_path := Replace ( units_path , i , path ) ;
81018: LD_ADDR_VAR 0 16
81022: PUSH
81023: LD_VAR 0 16
81027: PPUSH
81028: LD_VAR 0 7
81032: PPUSH
81033: LD_VAR 0 5
81037: PPUSH
81038: CALL_OW 1
81042: ST_TO_ADDR
81043: GO 81015
81045: POP
81046: POP
// repeat for i = group downto 1 do
81047: LD_ADDR_VAR 0 7
81051: PUSH
81052: DOUBLE
81053: LD_VAR 0 4
81057: INC
81058: ST_TO_ADDR
81059: LD_INT 1
81061: PUSH
81062: FOR_DOWNTO
81063: IFFALSE 85185
// begin wait ( 5 ) ;
81065: LD_INT 5
81067: PPUSH
81068: CALL_OW 67
// tmp := [ ] ;
81072: LD_ADDR_VAR 0 14
81076: PUSH
81077: EMPTY
81078: ST_TO_ADDR
// attacking := false ;
81079: LD_ADDR_VAR 0 29
81083: PUSH
81084: LD_INT 0
81086: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81087: LD_VAR 0 4
81091: PUSH
81092: LD_VAR 0 7
81096: ARRAY
81097: PPUSH
81098: CALL_OW 301
81102: PUSH
81103: LD_VAR 0 4
81107: PUSH
81108: LD_VAR 0 7
81112: ARRAY
81113: NOT
81114: OR
81115: IFFALSE 81224
// begin if GetType ( group [ i ] ) = unit_human then
81117: LD_VAR 0 4
81121: PUSH
81122: LD_VAR 0 7
81126: ARRAY
81127: PPUSH
81128: CALL_OW 247
81132: PUSH
81133: LD_INT 1
81135: EQUAL
81136: IFFALSE 81182
// begin to_heal := to_heal diff group [ i ] ;
81138: LD_ADDR_VAR 0 30
81142: PUSH
81143: LD_VAR 0 30
81147: PUSH
81148: LD_VAR 0 4
81152: PUSH
81153: LD_VAR 0 7
81157: ARRAY
81158: DIFF
81159: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81160: LD_ADDR_VAR 0 31
81164: PUSH
81165: LD_VAR 0 31
81169: PUSH
81170: LD_VAR 0 4
81174: PUSH
81175: LD_VAR 0 7
81179: ARRAY
81180: DIFF
81181: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
81182: LD_ADDR_VAR 0 4
81186: PUSH
81187: LD_VAR 0 4
81191: PPUSH
81192: LD_VAR 0 7
81196: PPUSH
81197: CALL_OW 3
81201: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
81202: LD_ADDR_VAR 0 16
81206: PUSH
81207: LD_VAR 0 16
81211: PPUSH
81212: LD_VAR 0 7
81216: PPUSH
81217: CALL_OW 3
81221: ST_TO_ADDR
// continue ;
81222: GO 81062
// end ; if f_repair then
81224: LD_VAR 0 22
81228: IFFALSE 81717
// begin if GetType ( group [ i ] ) = unit_vehicle then
81230: LD_VAR 0 4
81234: PUSH
81235: LD_VAR 0 7
81239: ARRAY
81240: PPUSH
81241: CALL_OW 247
81245: PUSH
81246: LD_INT 2
81248: EQUAL
81249: IFFALSE 81439
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
81251: LD_VAR 0 4
81255: PUSH
81256: LD_VAR 0 7
81260: ARRAY
81261: PPUSH
81262: CALL_OW 256
81266: PUSH
81267: LD_INT 700
81269: LESS
81270: PUSH
81271: LD_VAR 0 4
81275: PUSH
81276: LD_VAR 0 7
81280: ARRAY
81281: PUSH
81282: LD_VAR 0 32
81286: IN
81287: NOT
81288: AND
81289: IFFALSE 81313
// to_repair := to_repair union group [ i ] ;
81291: LD_ADDR_VAR 0 32
81295: PUSH
81296: LD_VAR 0 32
81300: PUSH
81301: LD_VAR 0 4
81305: PUSH
81306: LD_VAR 0 7
81310: ARRAY
81311: UNION
81312: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81313: LD_VAR 0 4
81317: PUSH
81318: LD_VAR 0 7
81322: ARRAY
81323: PPUSH
81324: CALL_OW 256
81328: PUSH
81329: LD_INT 1000
81331: EQUAL
81332: PUSH
81333: LD_VAR 0 4
81337: PUSH
81338: LD_VAR 0 7
81342: ARRAY
81343: PUSH
81344: LD_VAR 0 32
81348: IN
81349: AND
81350: IFFALSE 81374
// to_repair := to_repair diff group [ i ] ;
81352: LD_ADDR_VAR 0 32
81356: PUSH
81357: LD_VAR 0 32
81361: PUSH
81362: LD_VAR 0 4
81366: PUSH
81367: LD_VAR 0 7
81371: ARRAY
81372: DIFF
81373: ST_TO_ADDR
// if group [ i ] in to_repair then
81374: LD_VAR 0 4
81378: PUSH
81379: LD_VAR 0 7
81383: ARRAY
81384: PUSH
81385: LD_VAR 0 32
81389: IN
81390: IFFALSE 81437
// begin if not IsInArea ( group [ i ] , f_repair ) then
81392: LD_VAR 0 4
81396: PUSH
81397: LD_VAR 0 7
81401: ARRAY
81402: PPUSH
81403: LD_VAR 0 22
81407: PPUSH
81408: CALL_OW 308
81412: NOT
81413: IFFALSE 81435
// ComMoveToArea ( group [ i ] , f_repair ) ;
81415: LD_VAR 0 4
81419: PUSH
81420: LD_VAR 0 7
81424: ARRAY
81425: PPUSH
81426: LD_VAR 0 22
81430: PPUSH
81431: CALL_OW 113
// continue ;
81435: GO 81062
// end ; end else
81437: GO 81717
// if group [ i ] in repairs then
81439: LD_VAR 0 4
81443: PUSH
81444: LD_VAR 0 7
81448: ARRAY
81449: PUSH
81450: LD_VAR 0 33
81454: IN
81455: IFFALSE 81717
// begin if IsInUnit ( group [ i ] ) then
81457: LD_VAR 0 4
81461: PUSH
81462: LD_VAR 0 7
81466: ARRAY
81467: PPUSH
81468: CALL_OW 310
81472: IFFALSE 81540
// begin z := IsInUnit ( group [ i ] ) ;
81474: LD_ADDR_VAR 0 13
81478: PUSH
81479: LD_VAR 0 4
81483: PUSH
81484: LD_VAR 0 7
81488: ARRAY
81489: PPUSH
81490: CALL_OW 310
81494: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81495: LD_VAR 0 13
81499: PUSH
81500: LD_VAR 0 32
81504: IN
81505: PUSH
81506: LD_VAR 0 13
81510: PPUSH
81511: LD_VAR 0 22
81515: PPUSH
81516: CALL_OW 308
81520: AND
81521: IFFALSE 81538
// ComExitVehicle ( group [ i ] ) ;
81523: LD_VAR 0 4
81527: PUSH
81528: LD_VAR 0 7
81532: ARRAY
81533: PPUSH
81534: CALL_OW 121
// end else
81538: GO 81717
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81540: LD_ADDR_VAR 0 13
81544: PUSH
81545: LD_VAR 0 4
81549: PPUSH
81550: LD_INT 95
81552: PUSH
81553: LD_VAR 0 22
81557: PUSH
81558: EMPTY
81559: LIST
81560: LIST
81561: PUSH
81562: LD_INT 58
81564: PUSH
81565: EMPTY
81566: LIST
81567: PUSH
81568: EMPTY
81569: LIST
81570: LIST
81571: PPUSH
81572: CALL_OW 72
81576: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81577: LD_VAR 0 4
81581: PUSH
81582: LD_VAR 0 7
81586: ARRAY
81587: PPUSH
81588: CALL_OW 314
81592: NOT
81593: IFFALSE 81715
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81595: LD_ADDR_VAR 0 10
81599: PUSH
81600: LD_VAR 0 13
81604: PPUSH
81605: LD_VAR 0 4
81609: PUSH
81610: LD_VAR 0 7
81614: ARRAY
81615: PPUSH
81616: CALL_OW 74
81620: ST_TO_ADDR
// if not x then
81621: LD_VAR 0 10
81625: NOT
81626: IFFALSE 81630
// continue ;
81628: GO 81062
// if GetLives ( x ) < 1000 then
81630: LD_VAR 0 10
81634: PPUSH
81635: CALL_OW 256
81639: PUSH
81640: LD_INT 1000
81642: LESS
81643: IFFALSE 81667
// ComRepairVehicle ( group [ i ] , x ) else
81645: LD_VAR 0 4
81649: PUSH
81650: LD_VAR 0 7
81654: ARRAY
81655: PPUSH
81656: LD_VAR 0 10
81660: PPUSH
81661: CALL_OW 129
81665: GO 81715
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
81667: LD_VAR 0 23
81671: PUSH
81672: LD_VAR 0 4
81676: PUSH
81677: LD_VAR 0 7
81681: ARRAY
81682: PPUSH
81683: CALL_OW 256
81687: PUSH
81688: LD_INT 1000
81690: LESS
81691: AND
81692: NOT
81693: IFFALSE 81715
// ComEnterUnit ( group [ i ] , x ) ;
81695: LD_VAR 0 4
81699: PUSH
81700: LD_VAR 0 7
81704: ARRAY
81705: PPUSH
81706: LD_VAR 0 10
81710: PPUSH
81711: CALL_OW 120
// end ; continue ;
81715: GO 81062
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
81717: LD_VAR 0 23
81721: PUSH
81722: LD_VAR 0 4
81726: PUSH
81727: LD_VAR 0 7
81731: ARRAY
81732: PPUSH
81733: CALL_OW 247
81737: PUSH
81738: LD_INT 1
81740: EQUAL
81741: AND
81742: IFFALSE 82220
// begin if group [ i ] in healers then
81744: LD_VAR 0 4
81748: PUSH
81749: LD_VAR 0 7
81753: ARRAY
81754: PUSH
81755: LD_VAR 0 31
81759: IN
81760: IFFALSE 82033
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
81762: LD_VAR 0 4
81766: PUSH
81767: LD_VAR 0 7
81771: ARRAY
81772: PPUSH
81773: LD_VAR 0 23
81777: PPUSH
81778: CALL_OW 308
81782: NOT
81783: PUSH
81784: LD_VAR 0 4
81788: PUSH
81789: LD_VAR 0 7
81793: ARRAY
81794: PPUSH
81795: CALL_OW 314
81799: NOT
81800: AND
81801: IFFALSE 81825
// ComMoveToArea ( group [ i ] , f_heal ) else
81803: LD_VAR 0 4
81807: PUSH
81808: LD_VAR 0 7
81812: ARRAY
81813: PPUSH
81814: LD_VAR 0 23
81818: PPUSH
81819: CALL_OW 113
81823: GO 82031
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
81825: LD_VAR 0 4
81829: PUSH
81830: LD_VAR 0 7
81834: ARRAY
81835: PPUSH
81836: CALL 45070 0 1
81840: PPUSH
81841: CALL_OW 256
81845: PUSH
81846: LD_INT 1000
81848: EQUAL
81849: IFFALSE 81868
// ComStop ( group [ i ] ) else
81851: LD_VAR 0 4
81855: PUSH
81856: LD_VAR 0 7
81860: ARRAY
81861: PPUSH
81862: CALL_OW 141
81866: GO 82031
// if not HasTask ( group [ i ] ) and to_heal then
81868: LD_VAR 0 4
81872: PUSH
81873: LD_VAR 0 7
81877: ARRAY
81878: PPUSH
81879: CALL_OW 314
81883: NOT
81884: PUSH
81885: LD_VAR 0 30
81889: AND
81890: IFFALSE 82031
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
81892: LD_ADDR_VAR 0 13
81896: PUSH
81897: LD_VAR 0 30
81901: PPUSH
81902: LD_INT 3
81904: PUSH
81905: LD_INT 54
81907: PUSH
81908: EMPTY
81909: LIST
81910: PUSH
81911: EMPTY
81912: LIST
81913: LIST
81914: PPUSH
81915: CALL_OW 72
81919: PPUSH
81920: LD_VAR 0 4
81924: PUSH
81925: LD_VAR 0 7
81929: ARRAY
81930: PPUSH
81931: CALL_OW 74
81935: ST_TO_ADDR
// if z then
81936: LD_VAR 0 13
81940: IFFALSE 82031
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
81942: LD_INT 91
81944: PUSH
81945: LD_VAR 0 13
81949: PUSH
81950: LD_INT 10
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 81
81960: PUSH
81961: LD_VAR 0 13
81965: PPUSH
81966: CALL_OW 255
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PPUSH
81979: CALL_OW 69
81983: PUSH
81984: LD_INT 0
81986: EQUAL
81987: IFFALSE 82011
// ComHeal ( group [ i ] , z ) else
81989: LD_VAR 0 4
81993: PUSH
81994: LD_VAR 0 7
81998: ARRAY
81999: PPUSH
82000: LD_VAR 0 13
82004: PPUSH
82005: CALL_OW 128
82009: GO 82031
// ComMoveToArea ( group [ i ] , f_heal ) ;
82011: LD_VAR 0 4
82015: PUSH
82016: LD_VAR 0 7
82020: ARRAY
82021: PPUSH
82022: LD_VAR 0 23
82026: PPUSH
82027: CALL_OW 113
// end ; continue ;
82031: GO 81062
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82033: LD_VAR 0 4
82037: PUSH
82038: LD_VAR 0 7
82042: ARRAY
82043: PPUSH
82044: CALL_OW 256
82048: PUSH
82049: LD_INT 700
82051: LESS
82052: PUSH
82053: LD_VAR 0 4
82057: PUSH
82058: LD_VAR 0 7
82062: ARRAY
82063: PUSH
82064: LD_VAR 0 30
82068: IN
82069: NOT
82070: AND
82071: IFFALSE 82095
// to_heal := to_heal union group [ i ] ;
82073: LD_ADDR_VAR 0 30
82077: PUSH
82078: LD_VAR 0 30
82082: PUSH
82083: LD_VAR 0 4
82087: PUSH
82088: LD_VAR 0 7
82092: ARRAY
82093: UNION
82094: ST_TO_ADDR
// if group [ i ] in to_heal then
82095: LD_VAR 0 4
82099: PUSH
82100: LD_VAR 0 7
82104: ARRAY
82105: PUSH
82106: LD_VAR 0 30
82110: IN
82111: IFFALSE 82220
// begin if GetLives ( group [ i ] ) = 1000 then
82113: LD_VAR 0 4
82117: PUSH
82118: LD_VAR 0 7
82122: ARRAY
82123: PPUSH
82124: CALL_OW 256
82128: PUSH
82129: LD_INT 1000
82131: EQUAL
82132: IFFALSE 82158
// to_heal := to_heal diff group [ i ] else
82134: LD_ADDR_VAR 0 30
82138: PUSH
82139: LD_VAR 0 30
82143: PUSH
82144: LD_VAR 0 4
82148: PUSH
82149: LD_VAR 0 7
82153: ARRAY
82154: DIFF
82155: ST_TO_ADDR
82156: GO 82220
// begin if not IsInArea ( group [ i ] , to_heal ) then
82158: LD_VAR 0 4
82162: PUSH
82163: LD_VAR 0 7
82167: ARRAY
82168: PPUSH
82169: LD_VAR 0 30
82173: PPUSH
82174: CALL_OW 308
82178: NOT
82179: IFFALSE 82203
// ComMoveToArea ( group [ i ] , f_heal ) else
82181: LD_VAR 0 4
82185: PUSH
82186: LD_VAR 0 7
82190: ARRAY
82191: PPUSH
82192: LD_VAR 0 23
82196: PPUSH
82197: CALL_OW 113
82201: GO 82218
// ComHold ( group [ i ] ) ;
82203: LD_VAR 0 4
82207: PUSH
82208: LD_VAR 0 7
82212: ARRAY
82213: PPUSH
82214: CALL_OW 140
// continue ;
82218: GO 81062
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
82220: LD_VAR 0 4
82224: PUSH
82225: LD_VAR 0 7
82229: ARRAY
82230: PPUSH
82231: LD_INT 10
82233: PPUSH
82234: CALL 43490 0 2
82238: NOT
82239: PUSH
82240: LD_VAR 0 16
82244: PUSH
82245: LD_VAR 0 7
82249: ARRAY
82250: PUSH
82251: EMPTY
82252: EQUAL
82253: NOT
82254: AND
82255: IFFALSE 82521
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
82257: LD_VAR 0 4
82261: PUSH
82262: LD_VAR 0 7
82266: ARRAY
82267: PPUSH
82268: CALL_OW 262
82272: PUSH
82273: LD_INT 1
82275: PUSH
82276: LD_INT 2
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: IN
82283: IFFALSE 82324
// if GetFuel ( group [ i ] ) < 10 then
82285: LD_VAR 0 4
82289: PUSH
82290: LD_VAR 0 7
82294: ARRAY
82295: PPUSH
82296: CALL_OW 261
82300: PUSH
82301: LD_INT 10
82303: LESS
82304: IFFALSE 82324
// SetFuel ( group [ i ] , 12 ) ;
82306: LD_VAR 0 4
82310: PUSH
82311: LD_VAR 0 7
82315: ARRAY
82316: PPUSH
82317: LD_INT 12
82319: PPUSH
82320: CALL_OW 240
// if units_path [ i ] then
82324: LD_VAR 0 16
82328: PUSH
82329: LD_VAR 0 7
82333: ARRAY
82334: IFFALSE 82519
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82336: LD_VAR 0 4
82340: PUSH
82341: LD_VAR 0 7
82345: ARRAY
82346: PPUSH
82347: LD_VAR 0 16
82351: PUSH
82352: LD_VAR 0 7
82356: ARRAY
82357: PUSH
82358: LD_INT 1
82360: ARRAY
82361: PUSH
82362: LD_INT 1
82364: ARRAY
82365: PPUSH
82366: LD_VAR 0 16
82370: PUSH
82371: LD_VAR 0 7
82375: ARRAY
82376: PUSH
82377: LD_INT 1
82379: ARRAY
82380: PUSH
82381: LD_INT 2
82383: ARRAY
82384: PPUSH
82385: CALL_OW 297
82389: PUSH
82390: LD_INT 6
82392: GREATER
82393: IFFALSE 82468
// begin if not HasTask ( group [ i ] ) then
82395: LD_VAR 0 4
82399: PUSH
82400: LD_VAR 0 7
82404: ARRAY
82405: PPUSH
82406: CALL_OW 314
82410: NOT
82411: IFFALSE 82466
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82413: LD_VAR 0 4
82417: PUSH
82418: LD_VAR 0 7
82422: ARRAY
82423: PPUSH
82424: LD_VAR 0 16
82428: PUSH
82429: LD_VAR 0 7
82433: ARRAY
82434: PUSH
82435: LD_INT 1
82437: ARRAY
82438: PUSH
82439: LD_INT 1
82441: ARRAY
82442: PPUSH
82443: LD_VAR 0 16
82447: PUSH
82448: LD_VAR 0 7
82452: ARRAY
82453: PUSH
82454: LD_INT 1
82456: ARRAY
82457: PUSH
82458: LD_INT 2
82460: ARRAY
82461: PPUSH
82462: CALL_OW 114
// end else
82466: GO 82519
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82468: LD_ADDR_VAR 0 15
82472: PUSH
82473: LD_VAR 0 16
82477: PUSH
82478: LD_VAR 0 7
82482: ARRAY
82483: PPUSH
82484: LD_INT 1
82486: PPUSH
82487: CALL_OW 3
82491: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82492: LD_ADDR_VAR 0 16
82496: PUSH
82497: LD_VAR 0 16
82501: PPUSH
82502: LD_VAR 0 7
82506: PPUSH
82507: LD_VAR 0 15
82511: PPUSH
82512: CALL_OW 1
82516: ST_TO_ADDR
// continue ;
82517: GO 81062
// end ; end ; end else
82519: GO 85183
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82521: LD_ADDR_VAR 0 14
82525: PUSH
82526: LD_INT 81
82528: PUSH
82529: LD_VAR 0 4
82533: PUSH
82534: LD_VAR 0 7
82538: ARRAY
82539: PPUSH
82540: CALL_OW 255
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PPUSH
82549: CALL_OW 69
82553: ST_TO_ADDR
// if not tmp then
82554: LD_VAR 0 14
82558: NOT
82559: IFFALSE 82563
// continue ;
82561: GO 81062
// if f_ignore_area then
82563: LD_VAR 0 17
82567: IFFALSE 82655
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82569: LD_ADDR_VAR 0 15
82573: PUSH
82574: LD_VAR 0 14
82578: PPUSH
82579: LD_INT 3
82581: PUSH
82582: LD_INT 92
82584: PUSH
82585: LD_VAR 0 17
82589: PUSH
82590: LD_INT 1
82592: ARRAY
82593: PUSH
82594: LD_VAR 0 17
82598: PUSH
82599: LD_INT 2
82601: ARRAY
82602: PUSH
82603: LD_VAR 0 17
82607: PUSH
82608: LD_INT 3
82610: ARRAY
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: LIST
82616: LIST
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PPUSH
82622: CALL_OW 72
82626: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82627: LD_VAR 0 14
82631: PUSH
82632: LD_VAR 0 15
82636: DIFF
82637: IFFALSE 82655
// tmp := tmp diff tmp2 ;
82639: LD_ADDR_VAR 0 14
82643: PUSH
82644: LD_VAR 0 14
82648: PUSH
82649: LD_VAR 0 15
82653: DIFF
82654: ST_TO_ADDR
// end ; if not f_murder then
82655: LD_VAR 0 20
82659: NOT
82660: IFFALSE 82718
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
82662: LD_ADDR_VAR 0 15
82666: PUSH
82667: LD_VAR 0 14
82671: PPUSH
82672: LD_INT 3
82674: PUSH
82675: LD_INT 50
82677: PUSH
82678: EMPTY
82679: LIST
82680: PUSH
82681: EMPTY
82682: LIST
82683: LIST
82684: PPUSH
82685: CALL_OW 72
82689: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82690: LD_VAR 0 14
82694: PUSH
82695: LD_VAR 0 15
82699: DIFF
82700: IFFALSE 82718
// tmp := tmp diff tmp2 ;
82702: LD_ADDR_VAR 0 14
82706: PUSH
82707: LD_VAR 0 14
82711: PUSH
82712: LD_VAR 0 15
82716: DIFF
82717: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
82718: LD_ADDR_VAR 0 14
82722: PUSH
82723: LD_VAR 0 4
82727: PUSH
82728: LD_VAR 0 7
82732: ARRAY
82733: PPUSH
82734: LD_VAR 0 14
82738: PPUSH
82739: LD_INT 1
82741: PPUSH
82742: LD_INT 1
82744: PPUSH
82745: CALL 16425 0 4
82749: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
82750: LD_VAR 0 4
82754: PUSH
82755: LD_VAR 0 7
82759: ARRAY
82760: PPUSH
82761: CALL_OW 257
82765: PUSH
82766: LD_INT 1
82768: EQUAL
82769: IFFALSE 83217
// begin if WantPlant ( group [ i ] ) then
82771: LD_VAR 0 4
82775: PUSH
82776: LD_VAR 0 7
82780: ARRAY
82781: PPUSH
82782: CALL 15926 0 1
82786: IFFALSE 82790
// continue ;
82788: GO 81062
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
82790: LD_VAR 0 18
82794: PUSH
82795: LD_VAR 0 4
82799: PUSH
82800: LD_VAR 0 7
82804: ARRAY
82805: PPUSH
82806: CALL_OW 310
82810: NOT
82811: AND
82812: PUSH
82813: LD_VAR 0 14
82817: PUSH
82818: LD_INT 1
82820: ARRAY
82821: PUSH
82822: LD_VAR 0 14
82826: PPUSH
82827: LD_INT 21
82829: PUSH
82830: LD_INT 2
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 58
82839: PUSH
82840: EMPTY
82841: LIST
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PPUSH
82847: CALL_OW 72
82851: IN
82852: AND
82853: IFFALSE 82889
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
82855: LD_VAR 0 4
82859: PUSH
82860: LD_VAR 0 7
82864: ARRAY
82865: PPUSH
82866: LD_VAR 0 14
82870: PUSH
82871: LD_INT 1
82873: ARRAY
82874: PPUSH
82875: CALL_OW 120
// attacking := true ;
82879: LD_ADDR_VAR 0 29
82883: PUSH
82884: LD_INT 1
82886: ST_TO_ADDR
// continue ;
82887: GO 81062
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
82889: LD_VAR 0 26
82893: PUSH
82894: LD_VAR 0 4
82898: PUSH
82899: LD_VAR 0 7
82903: ARRAY
82904: PPUSH
82905: CALL_OW 257
82909: PUSH
82910: LD_INT 1
82912: EQUAL
82913: AND
82914: PUSH
82915: LD_VAR 0 4
82919: PUSH
82920: LD_VAR 0 7
82924: ARRAY
82925: PPUSH
82926: CALL_OW 256
82930: PUSH
82931: LD_INT 800
82933: LESS
82934: AND
82935: PUSH
82936: LD_VAR 0 4
82940: PUSH
82941: LD_VAR 0 7
82945: ARRAY
82946: PPUSH
82947: CALL_OW 318
82951: NOT
82952: AND
82953: IFFALSE 82970
// ComCrawl ( group [ i ] ) ;
82955: LD_VAR 0 4
82959: PUSH
82960: LD_VAR 0 7
82964: ARRAY
82965: PPUSH
82966: CALL_OW 137
// if f_mines then
82970: LD_VAR 0 21
82974: IFFALSE 83217
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
82976: LD_VAR 0 14
82980: PUSH
82981: LD_INT 1
82983: ARRAY
82984: PPUSH
82985: CALL_OW 247
82989: PUSH
82990: LD_INT 3
82992: EQUAL
82993: PUSH
82994: LD_VAR 0 14
82998: PUSH
82999: LD_INT 1
83001: ARRAY
83002: PUSH
83003: LD_VAR 0 27
83007: IN
83008: NOT
83009: AND
83010: IFFALSE 83217
// begin x := GetX ( tmp [ 1 ] ) ;
83012: LD_ADDR_VAR 0 10
83016: PUSH
83017: LD_VAR 0 14
83021: PUSH
83022: LD_INT 1
83024: ARRAY
83025: PPUSH
83026: CALL_OW 250
83030: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83031: LD_ADDR_VAR 0 11
83035: PUSH
83036: LD_VAR 0 14
83040: PUSH
83041: LD_INT 1
83043: ARRAY
83044: PPUSH
83045: CALL_OW 251
83049: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83050: LD_ADDR_VAR 0 12
83054: PUSH
83055: LD_VAR 0 4
83059: PUSH
83060: LD_VAR 0 7
83064: ARRAY
83065: PPUSH
83066: CALL 43575 0 1
83070: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83071: LD_VAR 0 4
83075: PUSH
83076: LD_VAR 0 7
83080: ARRAY
83081: PPUSH
83082: LD_VAR 0 10
83086: PPUSH
83087: LD_VAR 0 11
83091: PPUSH
83092: LD_VAR 0 14
83096: PUSH
83097: LD_INT 1
83099: ARRAY
83100: PPUSH
83101: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83105: LD_VAR 0 4
83109: PUSH
83110: LD_VAR 0 7
83114: ARRAY
83115: PPUSH
83116: LD_VAR 0 10
83120: PPUSH
83121: LD_VAR 0 12
83125: PPUSH
83126: LD_INT 7
83128: PPUSH
83129: CALL_OW 272
83133: PPUSH
83134: LD_VAR 0 11
83138: PPUSH
83139: LD_VAR 0 12
83143: PPUSH
83144: LD_INT 7
83146: PPUSH
83147: CALL_OW 273
83151: PPUSH
83152: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
83156: LD_VAR 0 4
83160: PUSH
83161: LD_VAR 0 7
83165: ARRAY
83166: PPUSH
83167: LD_INT 71
83169: PPUSH
83170: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
83174: LD_ADDR_VAR 0 27
83178: PUSH
83179: LD_VAR 0 27
83183: PPUSH
83184: LD_VAR 0 27
83188: PUSH
83189: LD_INT 1
83191: PLUS
83192: PPUSH
83193: LD_VAR 0 14
83197: PUSH
83198: LD_INT 1
83200: ARRAY
83201: PPUSH
83202: CALL_OW 1
83206: ST_TO_ADDR
// attacking := true ;
83207: LD_ADDR_VAR 0 29
83211: PUSH
83212: LD_INT 1
83214: ST_TO_ADDR
// continue ;
83215: GO 81062
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
83217: LD_VAR 0 4
83221: PUSH
83222: LD_VAR 0 7
83226: ARRAY
83227: PPUSH
83228: CALL_OW 257
83232: PUSH
83233: LD_INT 17
83235: EQUAL
83236: PUSH
83237: LD_VAR 0 4
83241: PUSH
83242: LD_VAR 0 7
83246: ARRAY
83247: PPUSH
83248: CALL_OW 110
83252: PUSH
83253: LD_INT 71
83255: EQUAL
83256: NOT
83257: AND
83258: IFFALSE 83404
// begin attacking := false ;
83260: LD_ADDR_VAR 0 29
83264: PUSH
83265: LD_INT 0
83267: ST_TO_ADDR
// k := 5 ;
83268: LD_ADDR_VAR 0 9
83272: PUSH
83273: LD_INT 5
83275: ST_TO_ADDR
// if tmp < k then
83276: LD_VAR 0 14
83280: PUSH
83281: LD_VAR 0 9
83285: LESS
83286: IFFALSE 83298
// k := tmp ;
83288: LD_ADDR_VAR 0 9
83292: PUSH
83293: LD_VAR 0 14
83297: ST_TO_ADDR
// for j = 1 to k do
83298: LD_ADDR_VAR 0 8
83302: PUSH
83303: DOUBLE
83304: LD_INT 1
83306: DEC
83307: ST_TO_ADDR
83308: LD_VAR 0 9
83312: PUSH
83313: FOR_TO
83314: IFFALSE 83402
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83316: LD_VAR 0 14
83320: PUSH
83321: LD_VAR 0 8
83325: ARRAY
83326: PUSH
83327: LD_VAR 0 14
83331: PPUSH
83332: LD_INT 58
83334: PUSH
83335: EMPTY
83336: LIST
83337: PPUSH
83338: CALL_OW 72
83342: IN
83343: NOT
83344: IFFALSE 83400
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83346: LD_VAR 0 4
83350: PUSH
83351: LD_VAR 0 7
83355: ARRAY
83356: PPUSH
83357: LD_VAR 0 14
83361: PUSH
83362: LD_VAR 0 8
83366: ARRAY
83367: PPUSH
83368: CALL_OW 115
// attacking := true ;
83372: LD_ADDR_VAR 0 29
83376: PUSH
83377: LD_INT 1
83379: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83380: LD_VAR 0 4
83384: PUSH
83385: LD_VAR 0 7
83389: ARRAY
83390: PPUSH
83391: LD_INT 71
83393: PPUSH
83394: CALL_OW 109
// continue ;
83398: GO 83313
// end ; end ;
83400: GO 83313
83402: POP
83403: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83404: LD_VAR 0 4
83408: PUSH
83409: LD_VAR 0 7
83413: ARRAY
83414: PPUSH
83415: CALL_OW 257
83419: PUSH
83420: LD_INT 8
83422: EQUAL
83423: PUSH
83424: LD_VAR 0 4
83428: PUSH
83429: LD_VAR 0 7
83433: ARRAY
83434: PPUSH
83435: CALL_OW 264
83439: PUSH
83440: LD_INT 28
83442: PUSH
83443: LD_INT 45
83445: PUSH
83446: LD_INT 7
83448: PUSH
83449: LD_INT 47
83451: PUSH
83452: EMPTY
83453: LIST
83454: LIST
83455: LIST
83456: LIST
83457: IN
83458: OR
83459: IFFALSE 83715
// begin attacking := false ;
83461: LD_ADDR_VAR 0 29
83465: PUSH
83466: LD_INT 0
83468: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83469: LD_VAR 0 14
83473: PUSH
83474: LD_INT 1
83476: ARRAY
83477: PPUSH
83478: CALL_OW 266
83482: PUSH
83483: LD_INT 32
83485: PUSH
83486: LD_INT 31
83488: PUSH
83489: LD_INT 33
83491: PUSH
83492: LD_INT 4
83494: PUSH
83495: LD_INT 5
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: LIST
83504: IN
83505: IFFALSE 83691
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83507: LD_ADDR_VAR 0 9
83511: PUSH
83512: LD_VAR 0 14
83516: PUSH
83517: LD_INT 1
83519: ARRAY
83520: PPUSH
83521: CALL_OW 266
83525: PPUSH
83526: LD_VAR 0 14
83530: PUSH
83531: LD_INT 1
83533: ARRAY
83534: PPUSH
83535: CALL_OW 250
83539: PPUSH
83540: LD_VAR 0 14
83544: PUSH
83545: LD_INT 1
83547: ARRAY
83548: PPUSH
83549: CALL_OW 251
83553: PPUSH
83554: LD_VAR 0 14
83558: PUSH
83559: LD_INT 1
83561: ARRAY
83562: PPUSH
83563: CALL_OW 254
83567: PPUSH
83568: LD_VAR 0 14
83572: PUSH
83573: LD_INT 1
83575: ARRAY
83576: PPUSH
83577: CALL_OW 248
83581: PPUSH
83582: LD_INT 0
83584: PPUSH
83585: CALL 24945 0 6
83589: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83590: LD_ADDR_VAR 0 8
83594: PUSH
83595: LD_VAR 0 4
83599: PUSH
83600: LD_VAR 0 7
83604: ARRAY
83605: PPUSH
83606: LD_VAR 0 9
83610: PPUSH
83611: CALL 43615 0 2
83615: ST_TO_ADDR
// if j then
83616: LD_VAR 0 8
83620: IFFALSE 83689
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83622: LD_VAR 0 8
83626: PUSH
83627: LD_INT 1
83629: ARRAY
83630: PPUSH
83631: LD_VAR 0 8
83635: PUSH
83636: LD_INT 2
83638: ARRAY
83639: PPUSH
83640: CALL_OW 488
83644: IFFALSE 83689
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
83646: LD_VAR 0 4
83650: PUSH
83651: LD_VAR 0 7
83655: ARRAY
83656: PPUSH
83657: LD_VAR 0 8
83661: PUSH
83662: LD_INT 1
83664: ARRAY
83665: PPUSH
83666: LD_VAR 0 8
83670: PUSH
83671: LD_INT 2
83673: ARRAY
83674: PPUSH
83675: CALL_OW 116
// attacking := true ;
83679: LD_ADDR_VAR 0 29
83683: PUSH
83684: LD_INT 1
83686: ST_TO_ADDR
// continue ;
83687: GO 81062
// end ; end else
83689: GO 83715
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83691: LD_VAR 0 4
83695: PUSH
83696: LD_VAR 0 7
83700: ARRAY
83701: PPUSH
83702: LD_VAR 0 14
83706: PUSH
83707: LD_INT 1
83709: ARRAY
83710: PPUSH
83711: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
83715: LD_VAR 0 4
83719: PUSH
83720: LD_VAR 0 7
83724: ARRAY
83725: PPUSH
83726: CALL_OW 265
83730: PUSH
83731: LD_INT 11
83733: EQUAL
83734: IFFALSE 84012
// begin k := 10 ;
83736: LD_ADDR_VAR 0 9
83740: PUSH
83741: LD_INT 10
83743: ST_TO_ADDR
// x := 0 ;
83744: LD_ADDR_VAR 0 10
83748: PUSH
83749: LD_INT 0
83751: ST_TO_ADDR
// if tmp < k then
83752: LD_VAR 0 14
83756: PUSH
83757: LD_VAR 0 9
83761: LESS
83762: IFFALSE 83774
// k := tmp ;
83764: LD_ADDR_VAR 0 9
83768: PUSH
83769: LD_VAR 0 14
83773: ST_TO_ADDR
// for j = k downto 1 do
83774: LD_ADDR_VAR 0 8
83778: PUSH
83779: DOUBLE
83780: LD_VAR 0 9
83784: INC
83785: ST_TO_ADDR
83786: LD_INT 1
83788: PUSH
83789: FOR_DOWNTO
83790: IFFALSE 83865
// begin if GetType ( tmp [ j ] ) = unit_human then
83792: LD_VAR 0 14
83796: PUSH
83797: LD_VAR 0 8
83801: ARRAY
83802: PPUSH
83803: CALL_OW 247
83807: PUSH
83808: LD_INT 1
83810: EQUAL
83811: IFFALSE 83863
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
83813: LD_VAR 0 4
83817: PUSH
83818: LD_VAR 0 7
83822: ARRAY
83823: PPUSH
83824: LD_VAR 0 14
83828: PUSH
83829: LD_VAR 0 8
83833: ARRAY
83834: PPUSH
83835: CALL 43886 0 2
// x := tmp [ j ] ;
83839: LD_ADDR_VAR 0 10
83843: PUSH
83844: LD_VAR 0 14
83848: PUSH
83849: LD_VAR 0 8
83853: ARRAY
83854: ST_TO_ADDR
// attacking := true ;
83855: LD_ADDR_VAR 0 29
83859: PUSH
83860: LD_INT 1
83862: ST_TO_ADDR
// end ; end ;
83863: GO 83789
83865: POP
83866: POP
// if not x then
83867: LD_VAR 0 10
83871: NOT
83872: IFFALSE 84012
// begin attacking := true ;
83874: LD_ADDR_VAR 0 29
83878: PUSH
83879: LD_INT 1
83881: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
83882: LD_VAR 0 4
83886: PUSH
83887: LD_VAR 0 7
83891: ARRAY
83892: PPUSH
83893: CALL_OW 250
83897: PPUSH
83898: LD_VAR 0 4
83902: PUSH
83903: LD_VAR 0 7
83907: ARRAY
83908: PPUSH
83909: CALL_OW 251
83913: PPUSH
83914: CALL_OW 546
83918: PUSH
83919: LD_INT 2
83921: ARRAY
83922: PUSH
83923: LD_VAR 0 14
83927: PUSH
83928: LD_INT 1
83930: ARRAY
83931: PPUSH
83932: CALL_OW 250
83936: PPUSH
83937: LD_VAR 0 14
83941: PUSH
83942: LD_INT 1
83944: ARRAY
83945: PPUSH
83946: CALL_OW 251
83950: PPUSH
83951: CALL_OW 546
83955: PUSH
83956: LD_INT 2
83958: ARRAY
83959: EQUAL
83960: IFFALSE 83988
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
83962: LD_VAR 0 4
83966: PUSH
83967: LD_VAR 0 7
83971: ARRAY
83972: PPUSH
83973: LD_VAR 0 14
83977: PUSH
83978: LD_INT 1
83980: ARRAY
83981: PPUSH
83982: CALL 43886 0 2
83986: GO 84012
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83988: LD_VAR 0 4
83992: PUSH
83993: LD_VAR 0 7
83997: ARRAY
83998: PPUSH
83999: LD_VAR 0 14
84003: PUSH
84004: LD_INT 1
84006: ARRAY
84007: PPUSH
84008: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84012: LD_VAR 0 4
84016: PUSH
84017: LD_VAR 0 7
84021: ARRAY
84022: PPUSH
84023: CALL_OW 264
84027: PUSH
84028: LD_INT 29
84030: EQUAL
84031: IFFALSE 84397
// begin if WantsToAttack ( group [ i ] ) in bombed then
84033: LD_VAR 0 4
84037: PUSH
84038: LD_VAR 0 7
84042: ARRAY
84043: PPUSH
84044: CALL_OW 319
84048: PUSH
84049: LD_VAR 0 28
84053: IN
84054: IFFALSE 84058
// continue ;
84056: GO 81062
// k := 8 ;
84058: LD_ADDR_VAR 0 9
84062: PUSH
84063: LD_INT 8
84065: ST_TO_ADDR
// x := 0 ;
84066: LD_ADDR_VAR 0 10
84070: PUSH
84071: LD_INT 0
84073: ST_TO_ADDR
// if tmp < k then
84074: LD_VAR 0 14
84078: PUSH
84079: LD_VAR 0 9
84083: LESS
84084: IFFALSE 84096
// k := tmp ;
84086: LD_ADDR_VAR 0 9
84090: PUSH
84091: LD_VAR 0 14
84095: ST_TO_ADDR
// for j = 1 to k do
84096: LD_ADDR_VAR 0 8
84100: PUSH
84101: DOUBLE
84102: LD_INT 1
84104: DEC
84105: ST_TO_ADDR
84106: LD_VAR 0 9
84110: PUSH
84111: FOR_TO
84112: IFFALSE 84244
// begin if GetType ( tmp [ j ] ) = unit_building then
84114: LD_VAR 0 14
84118: PUSH
84119: LD_VAR 0 8
84123: ARRAY
84124: PPUSH
84125: CALL_OW 247
84129: PUSH
84130: LD_INT 3
84132: EQUAL
84133: IFFALSE 84242
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84135: LD_VAR 0 14
84139: PUSH
84140: LD_VAR 0 8
84144: ARRAY
84145: PUSH
84146: LD_VAR 0 28
84150: IN
84151: NOT
84152: PUSH
84153: LD_VAR 0 14
84157: PUSH
84158: LD_VAR 0 8
84162: ARRAY
84163: PPUSH
84164: CALL_OW 313
84168: AND
84169: IFFALSE 84242
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84171: LD_VAR 0 4
84175: PUSH
84176: LD_VAR 0 7
84180: ARRAY
84181: PPUSH
84182: LD_VAR 0 14
84186: PUSH
84187: LD_VAR 0 8
84191: ARRAY
84192: PPUSH
84193: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
84197: LD_ADDR_VAR 0 28
84201: PUSH
84202: LD_VAR 0 28
84206: PPUSH
84207: LD_VAR 0 28
84211: PUSH
84212: LD_INT 1
84214: PLUS
84215: PPUSH
84216: LD_VAR 0 14
84220: PUSH
84221: LD_VAR 0 8
84225: ARRAY
84226: PPUSH
84227: CALL_OW 1
84231: ST_TO_ADDR
// attacking := true ;
84232: LD_ADDR_VAR 0 29
84236: PUSH
84237: LD_INT 1
84239: ST_TO_ADDR
// break ;
84240: GO 84244
// end ; end ;
84242: GO 84111
84244: POP
84245: POP
// if not attacking and f_attack_depot then
84246: LD_VAR 0 29
84250: NOT
84251: PUSH
84252: LD_VAR 0 25
84256: AND
84257: IFFALSE 84352
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84259: LD_ADDR_VAR 0 13
84263: PUSH
84264: LD_VAR 0 14
84268: PPUSH
84269: LD_INT 2
84271: PUSH
84272: LD_INT 30
84274: PUSH
84275: LD_INT 0
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 30
84284: PUSH
84285: LD_INT 1
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: LIST
84296: PPUSH
84297: CALL_OW 72
84301: ST_TO_ADDR
// if z then
84302: LD_VAR 0 13
84306: IFFALSE 84352
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84308: LD_VAR 0 4
84312: PUSH
84313: LD_VAR 0 7
84317: ARRAY
84318: PPUSH
84319: LD_VAR 0 13
84323: PPUSH
84324: LD_VAR 0 4
84328: PUSH
84329: LD_VAR 0 7
84333: ARRAY
84334: PPUSH
84335: CALL_OW 74
84339: PPUSH
84340: CALL_OW 115
// attacking := true ;
84344: LD_ADDR_VAR 0 29
84348: PUSH
84349: LD_INT 1
84351: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84352: LD_VAR 0 4
84356: PUSH
84357: LD_VAR 0 7
84361: ARRAY
84362: PPUSH
84363: CALL_OW 256
84367: PUSH
84368: LD_INT 500
84370: LESS
84371: IFFALSE 84397
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84373: LD_VAR 0 4
84377: PUSH
84378: LD_VAR 0 7
84382: ARRAY
84383: PPUSH
84384: LD_VAR 0 14
84388: PUSH
84389: LD_INT 1
84391: ARRAY
84392: PPUSH
84393: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84397: LD_VAR 0 4
84401: PUSH
84402: LD_VAR 0 7
84406: ARRAY
84407: PPUSH
84408: CALL_OW 264
84412: PUSH
84413: LD_INT 49
84415: EQUAL
84416: IFFALSE 84537
// begin if not HasTask ( group [ i ] ) then
84418: LD_VAR 0 4
84422: PUSH
84423: LD_VAR 0 7
84427: ARRAY
84428: PPUSH
84429: CALL_OW 314
84433: NOT
84434: IFFALSE 84537
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84436: LD_ADDR_VAR 0 9
84440: PUSH
84441: LD_INT 81
84443: PUSH
84444: LD_VAR 0 4
84448: PUSH
84449: LD_VAR 0 7
84453: ARRAY
84454: PPUSH
84455: CALL_OW 255
84459: PUSH
84460: EMPTY
84461: LIST
84462: LIST
84463: PPUSH
84464: CALL_OW 69
84468: PPUSH
84469: LD_VAR 0 4
84473: PUSH
84474: LD_VAR 0 7
84478: ARRAY
84479: PPUSH
84480: CALL_OW 74
84484: ST_TO_ADDR
// if k then
84485: LD_VAR 0 9
84489: IFFALSE 84537
// if GetDistUnits ( group [ i ] , k ) > 10 then
84491: LD_VAR 0 4
84495: PUSH
84496: LD_VAR 0 7
84500: ARRAY
84501: PPUSH
84502: LD_VAR 0 9
84506: PPUSH
84507: CALL_OW 296
84511: PUSH
84512: LD_INT 10
84514: GREATER
84515: IFFALSE 84537
// ComMoveUnit ( group [ i ] , k ) ;
84517: LD_VAR 0 4
84521: PUSH
84522: LD_VAR 0 7
84526: ARRAY
84527: PPUSH
84528: LD_VAR 0 9
84532: PPUSH
84533: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84537: LD_VAR 0 4
84541: PUSH
84542: LD_VAR 0 7
84546: ARRAY
84547: PPUSH
84548: CALL_OW 256
84552: PUSH
84553: LD_INT 250
84555: LESS
84556: PUSH
84557: LD_VAR 0 4
84561: PUSH
84562: LD_VAR 0 7
84566: ARRAY
84567: PUSH
84568: LD_INT 21
84570: PUSH
84571: LD_INT 2
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: PUSH
84578: LD_INT 23
84580: PUSH
84581: LD_INT 2
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: PUSH
84588: EMPTY
84589: LIST
84590: LIST
84591: PPUSH
84592: CALL_OW 69
84596: IN
84597: AND
84598: IFFALSE 84723
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84600: LD_ADDR_VAR 0 9
84604: PUSH
84605: LD_OWVAR 3
84609: PUSH
84610: LD_VAR 0 4
84614: PUSH
84615: LD_VAR 0 7
84619: ARRAY
84620: DIFF
84621: PPUSH
84622: LD_VAR 0 4
84626: PUSH
84627: LD_VAR 0 7
84631: ARRAY
84632: PPUSH
84633: CALL_OW 74
84637: ST_TO_ADDR
// if not k then
84638: LD_VAR 0 9
84642: NOT
84643: IFFALSE 84647
// continue ;
84645: GO 81062
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
84647: LD_VAR 0 9
84651: PUSH
84652: LD_INT 81
84654: PUSH
84655: LD_VAR 0 4
84659: PUSH
84660: LD_VAR 0 7
84664: ARRAY
84665: PPUSH
84666: CALL_OW 255
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PPUSH
84675: CALL_OW 69
84679: IN
84680: PUSH
84681: LD_VAR 0 9
84685: PPUSH
84686: LD_VAR 0 4
84690: PUSH
84691: LD_VAR 0 7
84695: ARRAY
84696: PPUSH
84697: CALL_OW 296
84701: PUSH
84702: LD_INT 5
84704: LESS
84705: AND
84706: IFFALSE 84723
// ComAutodestruct ( group [ i ] ) ;
84708: LD_VAR 0 4
84712: PUSH
84713: LD_VAR 0 7
84717: ARRAY
84718: PPUSH
84719: CALL 43784 0 1
// end ; if f_attack_depot then
84723: LD_VAR 0 25
84727: IFFALSE 84839
// begin k := 6 ;
84729: LD_ADDR_VAR 0 9
84733: PUSH
84734: LD_INT 6
84736: ST_TO_ADDR
// if tmp < k then
84737: LD_VAR 0 14
84741: PUSH
84742: LD_VAR 0 9
84746: LESS
84747: IFFALSE 84759
// k := tmp ;
84749: LD_ADDR_VAR 0 9
84753: PUSH
84754: LD_VAR 0 14
84758: ST_TO_ADDR
// for j = 1 to k do
84759: LD_ADDR_VAR 0 8
84763: PUSH
84764: DOUBLE
84765: LD_INT 1
84767: DEC
84768: ST_TO_ADDR
84769: LD_VAR 0 9
84773: PUSH
84774: FOR_TO
84775: IFFALSE 84837
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
84777: LD_VAR 0 8
84781: PPUSH
84782: CALL_OW 266
84786: PUSH
84787: LD_INT 0
84789: PUSH
84790: LD_INT 1
84792: PUSH
84793: EMPTY
84794: LIST
84795: LIST
84796: IN
84797: IFFALSE 84835
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84799: LD_VAR 0 4
84803: PUSH
84804: LD_VAR 0 7
84808: ARRAY
84809: PPUSH
84810: LD_VAR 0 14
84814: PUSH
84815: LD_VAR 0 8
84819: ARRAY
84820: PPUSH
84821: CALL_OW 115
// attacking := true ;
84825: LD_ADDR_VAR 0 29
84829: PUSH
84830: LD_INT 1
84832: ST_TO_ADDR
// break ;
84833: GO 84837
// end ;
84835: GO 84774
84837: POP
84838: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
84839: LD_VAR 0 4
84843: PUSH
84844: LD_VAR 0 7
84848: ARRAY
84849: PPUSH
84850: CALL_OW 302
84854: PUSH
84855: LD_VAR 0 29
84859: NOT
84860: AND
84861: IFFALSE 85183
// begin if GetTag ( group [ i ] ) = 71 then
84863: LD_VAR 0 4
84867: PUSH
84868: LD_VAR 0 7
84872: ARRAY
84873: PPUSH
84874: CALL_OW 110
84878: PUSH
84879: LD_INT 71
84881: EQUAL
84882: IFFALSE 84923
// begin if HasTask ( group [ i ] ) then
84884: LD_VAR 0 4
84888: PUSH
84889: LD_VAR 0 7
84893: ARRAY
84894: PPUSH
84895: CALL_OW 314
84899: IFFALSE 84905
// continue else
84901: GO 81062
84903: GO 84923
// SetTag ( group [ i ] , 0 ) ;
84905: LD_VAR 0 4
84909: PUSH
84910: LD_VAR 0 7
84914: ARRAY
84915: PPUSH
84916: LD_INT 0
84918: PPUSH
84919: CALL_OW 109
// end ; k := 8 ;
84923: LD_ADDR_VAR 0 9
84927: PUSH
84928: LD_INT 8
84930: ST_TO_ADDR
// x := 0 ;
84931: LD_ADDR_VAR 0 10
84935: PUSH
84936: LD_INT 0
84938: ST_TO_ADDR
// if tmp < k then
84939: LD_VAR 0 14
84943: PUSH
84944: LD_VAR 0 9
84948: LESS
84949: IFFALSE 84961
// k := tmp ;
84951: LD_ADDR_VAR 0 9
84955: PUSH
84956: LD_VAR 0 14
84960: ST_TO_ADDR
// for j = 1 to k do
84961: LD_ADDR_VAR 0 8
84965: PUSH
84966: DOUBLE
84967: LD_INT 1
84969: DEC
84970: ST_TO_ADDR
84971: LD_VAR 0 9
84975: PUSH
84976: FOR_TO
84977: IFFALSE 85075
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
84979: LD_VAR 0 14
84983: PUSH
84984: LD_VAR 0 8
84988: ARRAY
84989: PPUSH
84990: CALL_OW 247
84994: PUSH
84995: LD_INT 1
84997: EQUAL
84998: PUSH
84999: LD_VAR 0 14
85003: PUSH
85004: LD_VAR 0 8
85008: ARRAY
85009: PPUSH
85010: CALL_OW 256
85014: PUSH
85015: LD_INT 250
85017: LESS
85018: PUSH
85019: LD_VAR 0 20
85023: AND
85024: PUSH
85025: LD_VAR 0 20
85029: NOT
85030: PUSH
85031: LD_VAR 0 14
85035: PUSH
85036: LD_VAR 0 8
85040: ARRAY
85041: PPUSH
85042: CALL_OW 256
85046: PUSH
85047: LD_INT 250
85049: GREATEREQUAL
85050: AND
85051: OR
85052: AND
85053: IFFALSE 85073
// begin x := tmp [ j ] ;
85055: LD_ADDR_VAR 0 10
85059: PUSH
85060: LD_VAR 0 14
85064: PUSH
85065: LD_VAR 0 8
85069: ARRAY
85070: ST_TO_ADDR
// break ;
85071: GO 85075
// end ;
85073: GO 84976
85075: POP
85076: POP
// if x then
85077: LD_VAR 0 10
85081: IFFALSE 85105
// ComAttackUnit ( group [ i ] , x ) else
85083: LD_VAR 0 4
85087: PUSH
85088: LD_VAR 0 7
85092: ARRAY
85093: PPUSH
85094: LD_VAR 0 10
85098: PPUSH
85099: CALL_OW 115
85103: GO 85129
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85105: LD_VAR 0 4
85109: PUSH
85110: LD_VAR 0 7
85114: ARRAY
85115: PPUSH
85116: LD_VAR 0 14
85120: PUSH
85121: LD_INT 1
85123: ARRAY
85124: PPUSH
85125: CALL_OW 115
// if not HasTask ( group [ i ] ) then
85129: LD_VAR 0 4
85133: PUSH
85134: LD_VAR 0 7
85138: ARRAY
85139: PPUSH
85140: CALL_OW 314
85144: NOT
85145: IFFALSE 85183
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85147: LD_VAR 0 4
85151: PUSH
85152: LD_VAR 0 7
85156: ARRAY
85157: PPUSH
85158: LD_VAR 0 14
85162: PPUSH
85163: LD_VAR 0 4
85167: PUSH
85168: LD_VAR 0 7
85172: ARRAY
85173: PPUSH
85174: CALL_OW 74
85178: PPUSH
85179: CALL_OW 115
// end ; end ; end ;
85183: GO 81062
85185: POP
85186: POP
// wait ( 0 0$2 ) ;
85187: LD_INT 70
85189: PPUSH
85190: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
85194: LD_VAR 0 4
85198: NOT
85199: PUSH
85200: LD_VAR 0 4
85204: PUSH
85205: EMPTY
85206: EQUAL
85207: OR
85208: PUSH
85209: LD_INT 81
85211: PUSH
85212: LD_VAR 0 35
85216: PUSH
85217: EMPTY
85218: LIST
85219: LIST
85220: PPUSH
85221: CALL_OW 69
85225: NOT
85226: OR
85227: IFFALSE 81047
// end ;
85229: LD_VAR 0 2
85233: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
85234: LD_INT 0
85236: PPUSH
85237: PPUSH
85238: PPUSH
85239: PPUSH
85240: PPUSH
// if not base or not mc_bases [ base ] or not solds then
85241: LD_VAR 0 1
85245: NOT
85246: PUSH
85247: LD_EXP 23
85251: PUSH
85252: LD_VAR 0 1
85256: ARRAY
85257: NOT
85258: OR
85259: PUSH
85260: LD_VAR 0 2
85264: NOT
85265: OR
85266: IFFALSE 85270
// exit ;
85268: GO 85799
// side := mc_sides [ base ] ;
85270: LD_ADDR_VAR 0 5
85274: PUSH
85275: LD_EXP 49
85279: PUSH
85280: LD_VAR 0 1
85284: ARRAY
85285: ST_TO_ADDR
// if not side then
85286: LD_VAR 0 5
85290: NOT
85291: IFFALSE 85295
// exit ;
85293: GO 85799
// for i in solds do
85295: LD_ADDR_VAR 0 6
85299: PUSH
85300: LD_VAR 0 2
85304: PUSH
85305: FOR_IN
85306: IFFALSE 85367
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85308: LD_VAR 0 6
85312: PPUSH
85313: CALL_OW 310
85317: PPUSH
85318: CALL_OW 266
85322: PUSH
85323: LD_INT 32
85325: PUSH
85326: LD_INT 31
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: IN
85333: IFFALSE 85353
// solds := solds diff i else
85335: LD_ADDR_VAR 0 2
85339: PUSH
85340: LD_VAR 0 2
85344: PUSH
85345: LD_VAR 0 6
85349: DIFF
85350: ST_TO_ADDR
85351: GO 85365
// SetTag ( i , 18 ) ;
85353: LD_VAR 0 6
85357: PPUSH
85358: LD_INT 18
85360: PPUSH
85361: CALL_OW 109
85365: GO 85305
85367: POP
85368: POP
// if not solds then
85369: LD_VAR 0 2
85373: NOT
85374: IFFALSE 85378
// exit ;
85376: GO 85799
// repeat wait ( 0 0$2 ) ;
85378: LD_INT 70
85380: PPUSH
85381: CALL_OW 67
// enemy := mc_scan [ base ] ;
85385: LD_ADDR_VAR 0 4
85389: PUSH
85390: LD_EXP 46
85394: PUSH
85395: LD_VAR 0 1
85399: ARRAY
85400: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85401: LD_EXP 23
85405: PUSH
85406: LD_VAR 0 1
85410: ARRAY
85411: NOT
85412: PUSH
85413: LD_EXP 23
85417: PUSH
85418: LD_VAR 0 1
85422: ARRAY
85423: PUSH
85424: EMPTY
85425: EQUAL
85426: OR
85427: IFFALSE 85464
// begin for i in solds do
85429: LD_ADDR_VAR 0 6
85433: PUSH
85434: LD_VAR 0 2
85438: PUSH
85439: FOR_IN
85440: IFFALSE 85453
// ComStop ( i ) ;
85442: LD_VAR 0 6
85446: PPUSH
85447: CALL_OW 141
85451: GO 85439
85453: POP
85454: POP
// solds := [ ] ;
85455: LD_ADDR_VAR 0 2
85459: PUSH
85460: EMPTY
85461: ST_TO_ADDR
// exit ;
85462: GO 85799
// end ; for i in solds do
85464: LD_ADDR_VAR 0 6
85468: PUSH
85469: LD_VAR 0 2
85473: PUSH
85474: FOR_IN
85475: IFFALSE 85771
// begin if IsInUnit ( i ) then
85477: LD_VAR 0 6
85481: PPUSH
85482: CALL_OW 310
85486: IFFALSE 85497
// ComExitBuilding ( i ) ;
85488: LD_VAR 0 6
85492: PPUSH
85493: CALL_OW 122
// if GetLives ( i ) > 333 then
85497: LD_VAR 0 6
85501: PPUSH
85502: CALL_OW 256
85506: PUSH
85507: LD_INT 333
85509: GREATER
85510: IFFALSE 85538
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
85512: LD_VAR 0 6
85516: PPUSH
85517: LD_VAR 0 4
85521: PPUSH
85522: LD_VAR 0 6
85526: PPUSH
85527: CALL_OW 74
85531: PPUSH
85532: CALL_OW 115
85536: GO 85769
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85538: LD_VAR 0 6
85542: PPUSH
85543: LD_EXP 23
85547: PUSH
85548: LD_VAR 0 1
85552: ARRAY
85553: PPUSH
85554: LD_INT 2
85556: PUSH
85557: LD_INT 30
85559: PUSH
85560: LD_INT 0
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: LD_INT 30
85569: PUSH
85570: LD_INT 1
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: PUSH
85577: LD_INT 30
85579: PUSH
85580: LD_INT 6
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: EMPTY
85588: LIST
85589: LIST
85590: LIST
85591: LIST
85592: PPUSH
85593: CALL_OW 72
85597: PPUSH
85598: LD_VAR 0 6
85602: PPUSH
85603: CALL_OW 74
85607: PPUSH
85608: CALL_OW 296
85612: PUSH
85613: LD_INT 10
85615: GREATER
85616: IFFALSE 85769
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
85618: LD_ADDR_VAR 0 7
85622: PUSH
85623: LD_EXP 23
85627: PUSH
85628: LD_VAR 0 1
85632: ARRAY
85633: PPUSH
85634: LD_INT 2
85636: PUSH
85637: LD_INT 30
85639: PUSH
85640: LD_INT 0
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 30
85649: PUSH
85650: LD_INT 1
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: PUSH
85657: LD_INT 30
85659: PUSH
85660: LD_INT 6
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: PPUSH
85673: CALL_OW 72
85677: PPUSH
85678: LD_VAR 0 6
85682: PPUSH
85683: CALL_OW 74
85687: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
85688: LD_VAR 0 6
85692: PPUSH
85693: LD_VAR 0 7
85697: PPUSH
85698: CALL_OW 250
85702: PPUSH
85703: LD_INT 3
85705: PPUSH
85706: LD_INT 5
85708: PPUSH
85709: CALL_OW 272
85713: PPUSH
85714: LD_VAR 0 7
85718: PPUSH
85719: CALL_OW 251
85723: PPUSH
85724: LD_INT 3
85726: PPUSH
85727: LD_INT 5
85729: PPUSH
85730: CALL_OW 273
85734: PPUSH
85735: CALL_OW 111
// SetTag ( i , 0 ) ;
85739: LD_VAR 0 6
85743: PPUSH
85744: LD_INT 0
85746: PPUSH
85747: CALL_OW 109
// solds := solds diff i ;
85751: LD_ADDR_VAR 0 2
85755: PUSH
85756: LD_VAR 0 2
85760: PUSH
85761: LD_VAR 0 6
85765: DIFF
85766: ST_TO_ADDR
// continue ;
85767: GO 85474
// end ; end ;
85769: GO 85474
85771: POP
85772: POP
// until not solds or not enemy ;
85773: LD_VAR 0 2
85777: NOT
85778: PUSH
85779: LD_VAR 0 4
85783: NOT
85784: OR
85785: IFFALSE 85378
// MC_Reset ( base , 18 ) ;
85787: LD_VAR 0 1
85791: PPUSH
85792: LD_INT 18
85794: PPUSH
85795: CALL 54032 0 2
// end ;
85799: LD_VAR 0 3
85803: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
85804: LD_INT 0
85806: PPUSH
85807: PPUSH
85808: PPUSH
85809: PPUSH
85810: PPUSH
85811: PPUSH
85812: PPUSH
85813: PPUSH
85814: PPUSH
85815: PPUSH
85816: PPUSH
85817: PPUSH
85818: PPUSH
85819: PPUSH
85820: PPUSH
85821: PPUSH
85822: PPUSH
85823: PPUSH
85824: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
85825: LD_ADDR_VAR 0 12
85829: PUSH
85830: LD_EXP 23
85834: PUSH
85835: LD_VAR 0 1
85839: ARRAY
85840: PPUSH
85841: LD_INT 25
85843: PUSH
85844: LD_INT 3
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: PPUSH
85851: CALL_OW 72
85855: ST_TO_ADDR
// if mc_remote_driver [ base ] then
85856: LD_EXP 63
85860: PUSH
85861: LD_VAR 0 1
85865: ARRAY
85866: IFFALSE 85890
// mechs := mechs diff mc_remote_driver [ base ] ;
85868: LD_ADDR_VAR 0 12
85872: PUSH
85873: LD_VAR 0 12
85877: PUSH
85878: LD_EXP 63
85882: PUSH
85883: LD_VAR 0 1
85887: ARRAY
85888: DIFF
85889: ST_TO_ADDR
// for i in mechs do
85890: LD_ADDR_VAR 0 4
85894: PUSH
85895: LD_VAR 0 12
85899: PUSH
85900: FOR_IN
85901: IFFALSE 85936
// if GetTag ( i ) > 0 then
85903: LD_VAR 0 4
85907: PPUSH
85908: CALL_OW 110
85912: PUSH
85913: LD_INT 0
85915: GREATER
85916: IFFALSE 85934
// mechs := mechs diff i ;
85918: LD_ADDR_VAR 0 12
85922: PUSH
85923: LD_VAR 0 12
85927: PUSH
85928: LD_VAR 0 4
85932: DIFF
85933: ST_TO_ADDR
85934: GO 85900
85936: POP
85937: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
85938: LD_ADDR_VAR 0 8
85942: PUSH
85943: LD_EXP 23
85947: PUSH
85948: LD_VAR 0 1
85952: ARRAY
85953: PPUSH
85954: LD_INT 2
85956: PUSH
85957: LD_INT 25
85959: PUSH
85960: LD_INT 1
85962: PUSH
85963: EMPTY
85964: LIST
85965: LIST
85966: PUSH
85967: LD_INT 25
85969: PUSH
85970: LD_INT 5
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: PUSH
85977: LD_INT 25
85979: PUSH
85980: LD_INT 8
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 25
85989: PUSH
85990: LD_INT 9
85992: PUSH
85993: EMPTY
85994: LIST
85995: LIST
85996: PUSH
85997: EMPTY
85998: LIST
85999: LIST
86000: LIST
86001: LIST
86002: LIST
86003: PPUSH
86004: CALL_OW 72
86008: ST_TO_ADDR
// if not defenders and not solds then
86009: LD_VAR 0 2
86013: NOT
86014: PUSH
86015: LD_VAR 0 8
86019: NOT
86020: AND
86021: IFFALSE 86025
// exit ;
86023: GO 87795
// depot_under_attack := false ;
86025: LD_ADDR_VAR 0 16
86029: PUSH
86030: LD_INT 0
86032: ST_TO_ADDR
// sold_defenders := [ ] ;
86033: LD_ADDR_VAR 0 17
86037: PUSH
86038: EMPTY
86039: ST_TO_ADDR
// if mechs then
86040: LD_VAR 0 12
86044: IFFALSE 86197
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86046: LD_ADDR_VAR 0 4
86050: PUSH
86051: LD_VAR 0 2
86055: PPUSH
86056: LD_INT 21
86058: PUSH
86059: LD_INT 2
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PPUSH
86066: CALL_OW 72
86070: PUSH
86071: FOR_IN
86072: IFFALSE 86195
// begin if GetTag ( i ) <> 20 then
86074: LD_VAR 0 4
86078: PPUSH
86079: CALL_OW 110
86083: PUSH
86084: LD_INT 20
86086: NONEQUAL
86087: IFFALSE 86101
// SetTag ( i , 20 ) ;
86089: LD_VAR 0 4
86093: PPUSH
86094: LD_INT 20
86096: PPUSH
86097: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86101: LD_VAR 0 4
86105: PPUSH
86106: CALL_OW 263
86110: PUSH
86111: LD_INT 1
86113: EQUAL
86114: PUSH
86115: LD_VAR 0 4
86119: PPUSH
86120: CALL_OW 311
86124: NOT
86125: AND
86126: IFFALSE 86193
// begin un := mechs [ 1 ] ;
86128: LD_ADDR_VAR 0 10
86132: PUSH
86133: LD_VAR 0 12
86137: PUSH
86138: LD_INT 1
86140: ARRAY
86141: ST_TO_ADDR
// ComExit ( un ) ;
86142: LD_VAR 0 10
86146: PPUSH
86147: CALL 48129 0 1
// AddComEnterUnit ( un , i ) ;
86151: LD_VAR 0 10
86155: PPUSH
86156: LD_VAR 0 4
86160: PPUSH
86161: CALL_OW 180
// SetTag ( un , 19 ) ;
86165: LD_VAR 0 10
86169: PPUSH
86170: LD_INT 19
86172: PPUSH
86173: CALL_OW 109
// mechs := mechs diff un ;
86177: LD_ADDR_VAR 0 12
86181: PUSH
86182: LD_VAR 0 12
86186: PUSH
86187: LD_VAR 0 10
86191: DIFF
86192: ST_TO_ADDR
// end ; end ;
86193: GO 86071
86195: POP
86196: POP
// if solds then
86197: LD_VAR 0 8
86201: IFFALSE 86260
// for i in solds do
86203: LD_ADDR_VAR 0 4
86207: PUSH
86208: LD_VAR 0 8
86212: PUSH
86213: FOR_IN
86214: IFFALSE 86258
// if not GetTag ( i ) then
86216: LD_VAR 0 4
86220: PPUSH
86221: CALL_OW 110
86225: NOT
86226: IFFALSE 86256
// begin defenders := defenders union i ;
86228: LD_ADDR_VAR 0 2
86232: PUSH
86233: LD_VAR 0 2
86237: PUSH
86238: LD_VAR 0 4
86242: UNION
86243: ST_TO_ADDR
// SetTag ( i , 18 ) ;
86244: LD_VAR 0 4
86248: PPUSH
86249: LD_INT 18
86251: PPUSH
86252: CALL_OW 109
// end ;
86256: GO 86213
86258: POP
86259: POP
// repeat wait ( 0 0$2 ) ;
86260: LD_INT 70
86262: PPUSH
86263: CALL_OW 67
// enemy := mc_scan [ base ] ;
86267: LD_ADDR_VAR 0 21
86271: PUSH
86272: LD_EXP 46
86276: PUSH
86277: LD_VAR 0 1
86281: ARRAY
86282: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86283: LD_EXP 23
86287: PUSH
86288: LD_VAR 0 1
86292: ARRAY
86293: NOT
86294: PUSH
86295: LD_EXP 23
86299: PUSH
86300: LD_VAR 0 1
86304: ARRAY
86305: PUSH
86306: EMPTY
86307: EQUAL
86308: OR
86309: IFFALSE 86346
// begin for i in defenders do
86311: LD_ADDR_VAR 0 4
86315: PUSH
86316: LD_VAR 0 2
86320: PUSH
86321: FOR_IN
86322: IFFALSE 86335
// ComStop ( i ) ;
86324: LD_VAR 0 4
86328: PPUSH
86329: CALL_OW 141
86333: GO 86321
86335: POP
86336: POP
// defenders := [ ] ;
86337: LD_ADDR_VAR 0 2
86341: PUSH
86342: EMPTY
86343: ST_TO_ADDR
// exit ;
86344: GO 87795
// end ; for i in defenders do
86346: LD_ADDR_VAR 0 4
86350: PUSH
86351: LD_VAR 0 2
86355: PUSH
86356: FOR_IN
86357: IFFALSE 87255
// begin e := NearestUnitToUnit ( enemy , i ) ;
86359: LD_ADDR_VAR 0 13
86363: PUSH
86364: LD_VAR 0 21
86368: PPUSH
86369: LD_VAR 0 4
86373: PPUSH
86374: CALL_OW 74
86378: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86379: LD_ADDR_VAR 0 7
86383: PUSH
86384: LD_EXP 23
86388: PUSH
86389: LD_VAR 0 1
86393: ARRAY
86394: PPUSH
86395: LD_INT 2
86397: PUSH
86398: LD_INT 30
86400: PUSH
86401: LD_INT 0
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 30
86410: PUSH
86411: LD_INT 1
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PUSH
86418: EMPTY
86419: LIST
86420: LIST
86421: LIST
86422: PPUSH
86423: CALL_OW 72
86427: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86428: LD_ADDR_VAR 0 16
86432: PUSH
86433: LD_VAR 0 7
86437: NOT
86438: PUSH
86439: LD_VAR 0 7
86443: PPUSH
86444: LD_INT 3
86446: PUSH
86447: LD_INT 24
86449: PUSH
86450: LD_INT 600
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: PPUSH
86461: CALL_OW 72
86465: OR
86466: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86467: LD_VAR 0 4
86471: PPUSH
86472: CALL_OW 247
86476: PUSH
86477: LD_INT 2
86479: DOUBLE
86480: EQUAL
86481: IFTRUE 86485
86483: GO 86881
86485: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86486: LD_VAR 0 4
86490: PPUSH
86491: CALL_OW 256
86495: PUSH
86496: LD_INT 1000
86498: EQUAL
86499: PUSH
86500: LD_VAR 0 4
86504: PPUSH
86505: LD_VAR 0 13
86509: PPUSH
86510: CALL_OW 296
86514: PUSH
86515: LD_INT 40
86517: LESS
86518: PUSH
86519: LD_VAR 0 13
86523: PPUSH
86524: LD_EXP 48
86528: PUSH
86529: LD_VAR 0 1
86533: ARRAY
86534: PPUSH
86535: CALL_OW 308
86539: OR
86540: AND
86541: IFFALSE 86663
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86543: LD_VAR 0 4
86547: PPUSH
86548: CALL_OW 262
86552: PUSH
86553: LD_INT 1
86555: EQUAL
86556: PUSH
86557: LD_VAR 0 4
86561: PPUSH
86562: CALL_OW 261
86566: PUSH
86567: LD_INT 30
86569: LESS
86570: AND
86571: PUSH
86572: LD_VAR 0 7
86576: AND
86577: IFFALSE 86647
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86579: LD_VAR 0 4
86583: PPUSH
86584: LD_VAR 0 7
86588: PPUSH
86589: LD_VAR 0 4
86593: PPUSH
86594: CALL_OW 74
86598: PPUSH
86599: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
86603: LD_VAR 0 4
86607: PPUSH
86608: LD_VAR 0 7
86612: PPUSH
86613: LD_VAR 0 4
86617: PPUSH
86618: CALL_OW 74
86622: PPUSH
86623: CALL_OW 296
86627: PUSH
86628: LD_INT 6
86630: LESS
86631: IFFALSE 86645
// SetFuel ( i , 100 ) ;
86633: LD_VAR 0 4
86637: PPUSH
86638: LD_INT 100
86640: PPUSH
86641: CALL_OW 240
// end else
86645: GO 86661
// ComAttackUnit ( i , e ) ;
86647: LD_VAR 0 4
86651: PPUSH
86652: LD_VAR 0 13
86656: PPUSH
86657: CALL_OW 115
// end else
86661: GO 86764
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
86663: LD_VAR 0 13
86667: PPUSH
86668: LD_EXP 48
86672: PUSH
86673: LD_VAR 0 1
86677: ARRAY
86678: PPUSH
86679: CALL_OW 308
86683: NOT
86684: PUSH
86685: LD_VAR 0 4
86689: PPUSH
86690: LD_VAR 0 13
86694: PPUSH
86695: CALL_OW 296
86699: PUSH
86700: LD_INT 40
86702: GREATEREQUAL
86703: AND
86704: PUSH
86705: LD_VAR 0 4
86709: PPUSH
86710: CALL_OW 256
86714: PUSH
86715: LD_INT 650
86717: LESSEQUAL
86718: OR
86719: PUSH
86720: LD_VAR 0 4
86724: PPUSH
86725: LD_EXP 47
86729: PUSH
86730: LD_VAR 0 1
86734: ARRAY
86735: PPUSH
86736: CALL_OW 308
86740: NOT
86741: AND
86742: IFFALSE 86764
// ComMoveToArea ( i , mc_parking [ base ] ) ;
86744: LD_VAR 0 4
86748: PPUSH
86749: LD_EXP 47
86753: PUSH
86754: LD_VAR 0 1
86758: ARRAY
86759: PPUSH
86760: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
86764: LD_VAR 0 4
86768: PPUSH
86769: CALL_OW 256
86773: PUSH
86774: LD_INT 1000
86776: LESS
86777: PUSH
86778: LD_VAR 0 4
86782: PPUSH
86783: CALL_OW 263
86787: PUSH
86788: LD_INT 1
86790: EQUAL
86791: AND
86792: PUSH
86793: LD_VAR 0 4
86797: PPUSH
86798: CALL_OW 311
86802: AND
86803: PUSH
86804: LD_VAR 0 4
86808: PPUSH
86809: LD_EXP 47
86813: PUSH
86814: LD_VAR 0 1
86818: ARRAY
86819: PPUSH
86820: CALL_OW 308
86824: AND
86825: IFFALSE 86879
// begin mech := IsDrivenBy ( i ) ;
86827: LD_ADDR_VAR 0 9
86831: PUSH
86832: LD_VAR 0 4
86836: PPUSH
86837: CALL_OW 311
86841: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
86842: LD_VAR 0 9
86846: PPUSH
86847: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
86851: LD_VAR 0 9
86855: PPUSH
86856: LD_VAR 0 4
86860: PPUSH
86861: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
86865: LD_VAR 0 9
86869: PPUSH
86870: LD_VAR 0 4
86874: PPUSH
86875: CALL_OW 180
// end ; end ; unit_human :
86879: GO 87226
86881: LD_INT 1
86883: DOUBLE
86884: EQUAL
86885: IFTRUE 86889
86887: GO 87225
86889: POP
// begin b := IsInUnit ( i ) ;
86890: LD_ADDR_VAR 0 18
86894: PUSH
86895: LD_VAR 0 4
86899: PPUSH
86900: CALL_OW 310
86904: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
86905: LD_ADDR_VAR 0 19
86909: PUSH
86910: LD_VAR 0 18
86914: NOT
86915: PUSH
86916: LD_VAR 0 18
86920: PPUSH
86921: CALL_OW 266
86925: PUSH
86926: LD_INT 32
86928: PUSH
86929: LD_INT 31
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: IN
86936: OR
86937: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
86938: LD_VAR 0 18
86942: PPUSH
86943: CALL_OW 266
86947: PUSH
86948: LD_INT 5
86950: EQUAL
86951: PUSH
86952: LD_VAR 0 4
86956: PPUSH
86957: CALL_OW 257
86961: PUSH
86962: LD_INT 1
86964: PUSH
86965: LD_INT 2
86967: PUSH
86968: LD_INT 3
86970: PUSH
86971: LD_INT 4
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: IN
86980: AND
86981: IFFALSE 87018
// begin class := AllowSpecClass ( i ) ;
86983: LD_ADDR_VAR 0 20
86987: PUSH
86988: LD_VAR 0 4
86992: PPUSH
86993: CALL 12790 0 1
86997: ST_TO_ADDR
// if class then
86998: LD_VAR 0 20
87002: IFFALSE 87018
// ComChangeProfession ( i , class ) ;
87004: LD_VAR 0 4
87008: PPUSH
87009: LD_VAR 0 20
87013: PPUSH
87014: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87018: LD_VAR 0 16
87022: PUSH
87023: LD_VAR 0 2
87027: PPUSH
87028: LD_INT 21
87030: PUSH
87031: LD_INT 2
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: PPUSH
87038: CALL_OW 72
87042: PUSH
87043: LD_INT 1
87045: LESSEQUAL
87046: OR
87047: PUSH
87048: LD_VAR 0 19
87052: AND
87053: PUSH
87054: LD_VAR 0 4
87058: PUSH
87059: LD_VAR 0 17
87063: IN
87064: NOT
87065: AND
87066: IFFALSE 87159
// begin if b then
87068: LD_VAR 0 18
87072: IFFALSE 87121
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87074: LD_VAR 0 18
87078: PPUSH
87079: LD_VAR 0 21
87083: PPUSH
87084: LD_VAR 0 18
87088: PPUSH
87089: CALL_OW 74
87093: PPUSH
87094: CALL_OW 296
87098: PUSH
87099: LD_INT 10
87101: LESS
87102: PUSH
87103: LD_VAR 0 18
87107: PPUSH
87108: CALL_OW 461
87112: PUSH
87113: LD_INT 7
87115: NONEQUAL
87116: AND
87117: IFFALSE 87121
// continue ;
87119: GO 86356
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87121: LD_ADDR_VAR 0 17
87125: PUSH
87126: LD_VAR 0 17
87130: PPUSH
87131: LD_VAR 0 17
87135: PUSH
87136: LD_INT 1
87138: PLUS
87139: PPUSH
87140: LD_VAR 0 4
87144: PPUSH
87145: CALL_OW 1
87149: ST_TO_ADDR
// ComExitBuilding ( i ) ;
87150: LD_VAR 0 4
87154: PPUSH
87155: CALL_OW 122
// end ; if sold_defenders then
87159: LD_VAR 0 17
87163: IFFALSE 87223
// if i in sold_defenders then
87165: LD_VAR 0 4
87169: PUSH
87170: LD_VAR 0 17
87174: IN
87175: IFFALSE 87223
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
87177: LD_VAR 0 4
87181: PPUSH
87182: CALL_OW 314
87186: NOT
87187: PUSH
87188: LD_VAR 0 4
87192: PPUSH
87193: LD_VAR 0 13
87197: PPUSH
87198: CALL_OW 296
87202: PUSH
87203: LD_INT 30
87205: LESS
87206: AND
87207: IFFALSE 87223
// ComAttackUnit ( i , e ) ;
87209: LD_VAR 0 4
87213: PPUSH
87214: LD_VAR 0 13
87218: PPUSH
87219: CALL_OW 115
// end ; end ; end ;
87223: GO 87226
87225: POP
// if IsDead ( i ) then
87226: LD_VAR 0 4
87230: PPUSH
87231: CALL_OW 301
87235: IFFALSE 87253
// defenders := defenders diff i ;
87237: LD_ADDR_VAR 0 2
87241: PUSH
87242: LD_VAR 0 2
87246: PUSH
87247: LD_VAR 0 4
87251: DIFF
87252: ST_TO_ADDR
// end ;
87253: GO 86356
87255: POP
87256: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
87257: LD_VAR 0 21
87261: NOT
87262: PUSH
87263: LD_VAR 0 2
87267: NOT
87268: OR
87269: PUSH
87270: LD_EXP 23
87274: PUSH
87275: LD_VAR 0 1
87279: ARRAY
87280: NOT
87281: OR
87282: IFFALSE 86260
// MC_Reset ( base , 18 ) ;
87284: LD_VAR 0 1
87288: PPUSH
87289: LD_INT 18
87291: PPUSH
87292: CALL 54032 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87296: LD_ADDR_VAR 0 2
87300: PUSH
87301: LD_VAR 0 2
87305: PUSH
87306: LD_VAR 0 2
87310: PPUSH
87311: LD_INT 2
87313: PUSH
87314: LD_INT 25
87316: PUSH
87317: LD_INT 1
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 25
87326: PUSH
87327: LD_INT 5
87329: PUSH
87330: EMPTY
87331: LIST
87332: LIST
87333: PUSH
87334: LD_INT 25
87336: PUSH
87337: LD_INT 8
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: PUSH
87344: LD_INT 25
87346: PUSH
87347: LD_INT 9
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PUSH
87354: EMPTY
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: PPUSH
87361: CALL_OW 72
87365: DIFF
87366: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87367: LD_VAR 0 21
87371: NOT
87372: PUSH
87373: LD_VAR 0 2
87377: PPUSH
87378: LD_INT 21
87380: PUSH
87381: LD_INT 2
87383: PUSH
87384: EMPTY
87385: LIST
87386: LIST
87387: PPUSH
87388: CALL_OW 72
87392: AND
87393: IFFALSE 87731
// begin tmp := FilterByTag ( defenders , 19 ) ;
87395: LD_ADDR_VAR 0 11
87399: PUSH
87400: LD_VAR 0 2
87404: PPUSH
87405: LD_INT 19
87407: PPUSH
87408: CALL 45259 0 2
87412: ST_TO_ADDR
// if tmp then
87413: LD_VAR 0 11
87417: IFFALSE 87487
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87419: LD_ADDR_VAR 0 11
87423: PUSH
87424: LD_VAR 0 11
87428: PPUSH
87429: LD_INT 25
87431: PUSH
87432: LD_INT 3
87434: PUSH
87435: EMPTY
87436: LIST
87437: LIST
87438: PPUSH
87439: CALL_OW 72
87443: ST_TO_ADDR
// if tmp then
87444: LD_VAR 0 11
87448: IFFALSE 87487
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87450: LD_ADDR_EXP 35
87454: PUSH
87455: LD_EXP 35
87459: PPUSH
87460: LD_VAR 0 1
87464: PPUSH
87465: LD_EXP 35
87469: PUSH
87470: LD_VAR 0 1
87474: ARRAY
87475: PUSH
87476: LD_VAR 0 11
87480: UNION
87481: PPUSH
87482: CALL_OW 1
87486: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87487: LD_VAR 0 1
87491: PPUSH
87492: LD_INT 19
87494: PPUSH
87495: CALL 54032 0 2
// repeat wait ( 0 0$1 ) ;
87499: LD_INT 35
87501: PPUSH
87502: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87506: LD_EXP 23
87510: PUSH
87511: LD_VAR 0 1
87515: ARRAY
87516: NOT
87517: PUSH
87518: LD_EXP 23
87522: PUSH
87523: LD_VAR 0 1
87527: ARRAY
87528: PUSH
87529: EMPTY
87530: EQUAL
87531: OR
87532: IFFALSE 87569
// begin for i in defenders do
87534: LD_ADDR_VAR 0 4
87538: PUSH
87539: LD_VAR 0 2
87543: PUSH
87544: FOR_IN
87545: IFFALSE 87558
// ComStop ( i ) ;
87547: LD_VAR 0 4
87551: PPUSH
87552: CALL_OW 141
87556: GO 87544
87558: POP
87559: POP
// defenders := [ ] ;
87560: LD_ADDR_VAR 0 2
87564: PUSH
87565: EMPTY
87566: ST_TO_ADDR
// exit ;
87567: GO 87795
// end ; for i in defenders do
87569: LD_ADDR_VAR 0 4
87573: PUSH
87574: LD_VAR 0 2
87578: PUSH
87579: FOR_IN
87580: IFFALSE 87669
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87582: LD_VAR 0 4
87586: PPUSH
87587: LD_EXP 47
87591: PUSH
87592: LD_VAR 0 1
87596: ARRAY
87597: PPUSH
87598: CALL_OW 308
87602: NOT
87603: IFFALSE 87627
// ComMoveToArea ( i , mc_parking [ base ] ) else
87605: LD_VAR 0 4
87609: PPUSH
87610: LD_EXP 47
87614: PUSH
87615: LD_VAR 0 1
87619: ARRAY
87620: PPUSH
87621: CALL_OW 113
87625: GO 87667
// if GetControl ( i ) = control_manual then
87627: LD_VAR 0 4
87631: PPUSH
87632: CALL_OW 263
87636: PUSH
87637: LD_INT 1
87639: EQUAL
87640: IFFALSE 87667
// if IsDrivenBy ( i ) then
87642: LD_VAR 0 4
87646: PPUSH
87647: CALL_OW 311
87651: IFFALSE 87667
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
87653: LD_VAR 0 4
87657: PPUSH
87658: CALL_OW 311
87662: PPUSH
87663: CALL_OW 121
// end ;
87667: GO 87579
87669: POP
87670: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
87671: LD_VAR 0 2
87675: PPUSH
87676: LD_INT 95
87678: PUSH
87679: LD_EXP 47
87683: PUSH
87684: LD_VAR 0 1
87688: ARRAY
87689: PUSH
87690: EMPTY
87691: LIST
87692: LIST
87693: PPUSH
87694: CALL_OW 72
87698: PUSH
87699: LD_VAR 0 2
87703: EQUAL
87704: PUSH
87705: LD_EXP 46
87709: PUSH
87710: LD_VAR 0 1
87714: ARRAY
87715: OR
87716: PUSH
87717: LD_EXP 23
87721: PUSH
87722: LD_VAR 0 1
87726: ARRAY
87727: NOT
87728: OR
87729: IFFALSE 87499
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
87731: LD_ADDR_EXP 45
87735: PUSH
87736: LD_EXP 45
87740: PPUSH
87741: LD_VAR 0 1
87745: PPUSH
87746: LD_VAR 0 2
87750: PPUSH
87751: LD_INT 21
87753: PUSH
87754: LD_INT 2
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PPUSH
87761: CALL_OW 72
87765: PPUSH
87766: CALL_OW 1
87770: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
87771: LD_VAR 0 1
87775: PPUSH
87776: LD_INT 19
87778: PPUSH
87779: CALL 54032 0 2
// MC_Reset ( base , 20 ) ;
87783: LD_VAR 0 1
87787: PPUSH
87788: LD_INT 20
87790: PPUSH
87791: CALL 54032 0 2
// end ; end_of_file
87795: LD_VAR 0 3
87799: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
87800: LD_INT 0
87802: PPUSH
87803: PPUSH
87804: PPUSH
87805: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87806: LD_VAR 0 1
87810: PPUSH
87811: CALL_OW 264
87815: PUSH
87816: LD_EXP 71
87820: EQUAL
87821: IFFALSE 87893
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87823: LD_INT 68
87825: PPUSH
87826: LD_VAR 0 1
87830: PPUSH
87831: CALL_OW 255
87835: PPUSH
87836: CALL_OW 321
87840: PUSH
87841: LD_INT 2
87843: EQUAL
87844: IFFALSE 87856
// eff := 70 else
87846: LD_ADDR_VAR 0 4
87850: PUSH
87851: LD_INT 70
87853: ST_TO_ADDR
87854: GO 87864
// eff := 30 ;
87856: LD_ADDR_VAR 0 4
87860: PUSH
87861: LD_INT 30
87863: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87864: LD_VAR 0 1
87868: PPUSH
87869: CALL_OW 250
87873: PPUSH
87874: LD_VAR 0 1
87878: PPUSH
87879: CALL_OW 251
87883: PPUSH
87884: LD_VAR 0 4
87888: PPUSH
87889: CALL_OW 495
// end ; end ;
87893: LD_VAR 0 2
87897: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
87898: LD_INT 0
87900: PPUSH
// end ;
87901: LD_VAR 0 4
87905: RET
// export function SOS_Command ( cmd ) ; begin
87906: LD_INT 0
87908: PPUSH
// end ;
87909: LD_VAR 0 2
87913: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
87914: LD_INT 0
87916: PPUSH
// if cmd = 121 then
87917: LD_VAR 0 1
87921: PUSH
87922: LD_INT 121
87924: EQUAL
87925: IFFALSE 87927
// end ;
87927: LD_VAR 0 6
87931: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
87932: LD_INT 0
87934: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
87935: LD_VAR 0 1
87939: PUSH
87940: LD_INT 250
87942: EQUAL
87943: PUSH
87944: LD_VAR 0 2
87948: PPUSH
87949: CALL_OW 264
87953: PUSH
87954: LD_EXP 74
87958: EQUAL
87959: AND
87960: IFFALSE 87981
// MinerPlaceMine ( unit , x , y ) ;
87962: LD_VAR 0 2
87966: PPUSH
87967: LD_VAR 0 4
87971: PPUSH
87972: LD_VAR 0 5
87976: PPUSH
87977: CALL 90330 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
87981: LD_VAR 0 1
87985: PUSH
87986: LD_INT 251
87988: EQUAL
87989: PUSH
87990: LD_VAR 0 2
87994: PPUSH
87995: CALL_OW 264
87999: PUSH
88000: LD_EXP 74
88004: EQUAL
88005: AND
88006: IFFALSE 88027
// MinerDetonateMine ( unit , x , y ) ;
88008: LD_VAR 0 2
88012: PPUSH
88013: LD_VAR 0 4
88017: PPUSH
88018: LD_VAR 0 5
88022: PPUSH
88023: CALL 90607 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
88027: LD_VAR 0 1
88031: PUSH
88032: LD_INT 252
88034: EQUAL
88035: PUSH
88036: LD_VAR 0 2
88040: PPUSH
88041: CALL_OW 264
88045: PUSH
88046: LD_EXP 74
88050: EQUAL
88051: AND
88052: IFFALSE 88073
// MinerCreateMinefield ( unit , x , y ) ;
88054: LD_VAR 0 2
88058: PPUSH
88059: LD_VAR 0 4
88063: PPUSH
88064: LD_VAR 0 5
88068: PPUSH
88069: CALL 91024 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
88073: LD_VAR 0 1
88077: PUSH
88078: LD_INT 253
88080: EQUAL
88081: PUSH
88082: LD_VAR 0 2
88086: PPUSH
88087: CALL_OW 257
88091: PUSH
88092: LD_INT 5
88094: EQUAL
88095: AND
88096: IFFALSE 88117
// ComBinocular ( unit , x , y ) ;
88098: LD_VAR 0 2
88102: PPUSH
88103: LD_VAR 0 4
88107: PPUSH
88108: LD_VAR 0 5
88112: PPUSH
88113: CALL 91395 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
88117: LD_VAR 0 1
88121: PUSH
88122: LD_INT 254
88124: EQUAL
88125: PUSH
88126: LD_VAR 0 2
88130: PPUSH
88131: CALL_OW 264
88135: PUSH
88136: LD_EXP 69
88140: EQUAL
88141: AND
88142: PUSH
88143: LD_VAR 0 3
88147: PPUSH
88148: CALL_OW 263
88152: PUSH
88153: LD_INT 3
88155: EQUAL
88156: AND
88157: IFFALSE 88173
// HackDestroyVehicle ( unit , selectedUnit ) ;
88159: LD_VAR 0 2
88163: PPUSH
88164: LD_VAR 0 3
88168: PPUSH
88169: CALL 89690 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
88173: LD_VAR 0 1
88177: PUSH
88178: LD_INT 255
88180: EQUAL
88181: PUSH
88182: LD_VAR 0 2
88186: PPUSH
88187: CALL_OW 264
88191: PUSH
88192: LD_INT 14
88194: PUSH
88195: LD_INT 53
88197: PUSH
88198: EMPTY
88199: LIST
88200: LIST
88201: IN
88202: AND
88203: PUSH
88204: LD_VAR 0 4
88208: PPUSH
88209: LD_VAR 0 5
88213: PPUSH
88214: CALL_OW 488
88218: AND
88219: IFFALSE 88243
// CutTreeXYR ( unit , x , y , 12 ) ;
88221: LD_VAR 0 2
88225: PPUSH
88226: LD_VAR 0 4
88230: PPUSH
88231: LD_VAR 0 5
88235: PPUSH
88236: LD_INT 12
88238: PPUSH
88239: CALL 88256 0 4
// end ;
88243: LD_VAR 0 6
88247: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
88248: LD_INT 0
88250: PPUSH
// end ;
88251: LD_VAR 0 4
88255: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
88256: LD_INT 0
88258: PPUSH
88259: PPUSH
88260: PPUSH
88261: PPUSH
88262: PPUSH
88263: PPUSH
88264: PPUSH
88265: PPUSH
88266: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
88267: LD_VAR 0 1
88271: NOT
88272: PUSH
88273: LD_VAR 0 2
88277: PPUSH
88278: LD_VAR 0 3
88282: PPUSH
88283: CALL_OW 488
88287: NOT
88288: OR
88289: PUSH
88290: LD_VAR 0 4
88294: NOT
88295: OR
88296: IFFALSE 88300
// exit ;
88298: GO 88640
// list := [ ] ;
88300: LD_ADDR_VAR 0 13
88304: PUSH
88305: EMPTY
88306: ST_TO_ADDR
// if x - r < 0 then
88307: LD_VAR 0 2
88311: PUSH
88312: LD_VAR 0 4
88316: MINUS
88317: PUSH
88318: LD_INT 0
88320: LESS
88321: IFFALSE 88333
// min_x := 0 else
88323: LD_ADDR_VAR 0 7
88327: PUSH
88328: LD_INT 0
88330: ST_TO_ADDR
88331: GO 88349
// min_x := x - r ;
88333: LD_ADDR_VAR 0 7
88337: PUSH
88338: LD_VAR 0 2
88342: PUSH
88343: LD_VAR 0 4
88347: MINUS
88348: ST_TO_ADDR
// if y - r < 0 then
88349: LD_VAR 0 3
88353: PUSH
88354: LD_VAR 0 4
88358: MINUS
88359: PUSH
88360: LD_INT 0
88362: LESS
88363: IFFALSE 88375
// min_y := 0 else
88365: LD_ADDR_VAR 0 8
88369: PUSH
88370: LD_INT 0
88372: ST_TO_ADDR
88373: GO 88391
// min_y := y - r ;
88375: LD_ADDR_VAR 0 8
88379: PUSH
88380: LD_VAR 0 3
88384: PUSH
88385: LD_VAR 0 4
88389: MINUS
88390: ST_TO_ADDR
// max_x := x + r ;
88391: LD_ADDR_VAR 0 9
88395: PUSH
88396: LD_VAR 0 2
88400: PUSH
88401: LD_VAR 0 4
88405: PLUS
88406: ST_TO_ADDR
// max_y := y + r ;
88407: LD_ADDR_VAR 0 10
88411: PUSH
88412: LD_VAR 0 3
88416: PUSH
88417: LD_VAR 0 4
88421: PLUS
88422: ST_TO_ADDR
// for _x = min_x to max_x do
88423: LD_ADDR_VAR 0 11
88427: PUSH
88428: DOUBLE
88429: LD_VAR 0 7
88433: DEC
88434: ST_TO_ADDR
88435: LD_VAR 0 9
88439: PUSH
88440: FOR_TO
88441: IFFALSE 88558
// for _y = min_y to max_y do
88443: LD_ADDR_VAR 0 12
88447: PUSH
88448: DOUBLE
88449: LD_VAR 0 8
88453: DEC
88454: ST_TO_ADDR
88455: LD_VAR 0 10
88459: PUSH
88460: FOR_TO
88461: IFFALSE 88554
// begin if not ValidHex ( _x , _y ) then
88463: LD_VAR 0 11
88467: PPUSH
88468: LD_VAR 0 12
88472: PPUSH
88473: CALL_OW 488
88477: NOT
88478: IFFALSE 88482
// continue ;
88480: GO 88460
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88482: LD_VAR 0 11
88486: PPUSH
88487: LD_VAR 0 12
88491: PPUSH
88492: CALL_OW 351
88496: PUSH
88497: LD_VAR 0 11
88501: PPUSH
88502: LD_VAR 0 12
88506: PPUSH
88507: CALL_OW 554
88511: AND
88512: IFFALSE 88552
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88514: LD_ADDR_VAR 0 13
88518: PUSH
88519: LD_VAR 0 13
88523: PPUSH
88524: LD_VAR 0 13
88528: PUSH
88529: LD_INT 1
88531: PLUS
88532: PPUSH
88533: LD_VAR 0 11
88537: PUSH
88538: LD_VAR 0 12
88542: PUSH
88543: EMPTY
88544: LIST
88545: LIST
88546: PPUSH
88547: CALL_OW 2
88551: ST_TO_ADDR
// end ;
88552: GO 88460
88554: POP
88555: POP
88556: GO 88440
88558: POP
88559: POP
// if not list then
88560: LD_VAR 0 13
88564: NOT
88565: IFFALSE 88569
// exit ;
88567: GO 88640
// for i in list do
88569: LD_ADDR_VAR 0 6
88573: PUSH
88574: LD_VAR 0 13
88578: PUSH
88579: FOR_IN
88580: IFFALSE 88638
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88582: LD_VAR 0 1
88586: PPUSH
88587: LD_STRING M
88589: PUSH
88590: LD_VAR 0 6
88594: PUSH
88595: LD_INT 1
88597: ARRAY
88598: PUSH
88599: LD_VAR 0 6
88603: PUSH
88604: LD_INT 2
88606: ARRAY
88607: PUSH
88608: LD_INT 0
88610: PUSH
88611: LD_INT 0
88613: PUSH
88614: LD_INT 0
88616: PUSH
88617: LD_INT 0
88619: PUSH
88620: EMPTY
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: PUSH
88629: EMPTY
88630: LIST
88631: PPUSH
88632: CALL_OW 447
88636: GO 88579
88638: POP
88639: POP
// end ;
88640: LD_VAR 0 5
88644: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
88645: LD_EXP 88
88649: NOT
88650: IFFALSE 88700
88652: GO 88654
88654: DISABLE
// begin initHack := true ;
88655: LD_ADDR_EXP 88
88659: PUSH
88660: LD_INT 1
88662: ST_TO_ADDR
// hackTanks := [ ] ;
88663: LD_ADDR_EXP 89
88667: PUSH
88668: EMPTY
88669: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
88670: LD_ADDR_EXP 90
88674: PUSH
88675: EMPTY
88676: ST_TO_ADDR
// hackLimit := 3 ;
88677: LD_ADDR_EXP 91
88681: PUSH
88682: LD_INT 3
88684: ST_TO_ADDR
// hackDist := 12 ;
88685: LD_ADDR_EXP 92
88689: PUSH
88690: LD_INT 12
88692: ST_TO_ADDR
// hackCounter := [ ] ;
88693: LD_ADDR_EXP 93
88697: PUSH
88698: EMPTY
88699: ST_TO_ADDR
// end ;
88700: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
88701: LD_EXP 88
88705: PUSH
88706: LD_INT 34
88708: PUSH
88709: LD_EXP 69
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PPUSH
88718: CALL_OW 69
88722: AND
88723: IFFALSE 88978
88725: GO 88727
88727: DISABLE
88728: LD_INT 0
88730: PPUSH
88731: PPUSH
// begin enable ;
88732: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
88733: LD_ADDR_VAR 0 1
88737: PUSH
88738: LD_INT 34
88740: PUSH
88741: LD_EXP 69
88745: PUSH
88746: EMPTY
88747: LIST
88748: LIST
88749: PPUSH
88750: CALL_OW 69
88754: PUSH
88755: FOR_IN
88756: IFFALSE 88976
// begin if not i in hackTanks then
88758: LD_VAR 0 1
88762: PUSH
88763: LD_EXP 89
88767: IN
88768: NOT
88769: IFFALSE 88852
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
88771: LD_ADDR_EXP 89
88775: PUSH
88776: LD_EXP 89
88780: PPUSH
88781: LD_EXP 89
88785: PUSH
88786: LD_INT 1
88788: PLUS
88789: PPUSH
88790: LD_VAR 0 1
88794: PPUSH
88795: CALL_OW 1
88799: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
88800: LD_ADDR_EXP 90
88804: PUSH
88805: LD_EXP 90
88809: PPUSH
88810: LD_EXP 90
88814: PUSH
88815: LD_INT 1
88817: PLUS
88818: PPUSH
88819: EMPTY
88820: PPUSH
88821: CALL_OW 1
88825: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
88826: LD_ADDR_EXP 93
88830: PUSH
88831: LD_EXP 93
88835: PPUSH
88836: LD_EXP 93
88840: PUSH
88841: LD_INT 1
88843: PLUS
88844: PPUSH
88845: EMPTY
88846: PPUSH
88847: CALL_OW 1
88851: ST_TO_ADDR
// end ; if not IsOk ( i ) then
88852: LD_VAR 0 1
88856: PPUSH
88857: CALL_OW 302
88861: NOT
88862: IFFALSE 88875
// begin HackUnlinkAll ( i ) ;
88864: LD_VAR 0 1
88868: PPUSH
88869: CALL 88981 0 1
// continue ;
88873: GO 88755
// end ; HackCheckCapturedStatus ( i ) ;
88875: LD_VAR 0 1
88879: PPUSH
88880: CALL 89424 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
88884: LD_ADDR_VAR 0 2
88888: PUSH
88889: LD_INT 81
88891: PUSH
88892: LD_VAR 0 1
88896: PPUSH
88897: CALL_OW 255
88901: PUSH
88902: EMPTY
88903: LIST
88904: LIST
88905: PUSH
88906: LD_INT 33
88908: PUSH
88909: LD_INT 3
88911: PUSH
88912: EMPTY
88913: LIST
88914: LIST
88915: PUSH
88916: LD_INT 91
88918: PUSH
88919: LD_VAR 0 1
88923: PUSH
88924: LD_EXP 92
88928: PUSH
88929: EMPTY
88930: LIST
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 50
88936: PUSH
88937: EMPTY
88938: LIST
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: PPUSH
88946: CALL_OW 69
88950: ST_TO_ADDR
// if not tmp then
88951: LD_VAR 0 2
88955: NOT
88956: IFFALSE 88960
// continue ;
88958: GO 88755
// HackLink ( i , tmp ) ;
88960: LD_VAR 0 1
88964: PPUSH
88965: LD_VAR 0 2
88969: PPUSH
88970: CALL 89117 0 2
// end ;
88974: GO 88755
88976: POP
88977: POP
// end ;
88978: PPOPN 2
88980: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
88981: LD_INT 0
88983: PPUSH
88984: PPUSH
88985: PPUSH
// if not hack in hackTanks then
88986: LD_VAR 0 1
88990: PUSH
88991: LD_EXP 89
88995: IN
88996: NOT
88997: IFFALSE 89001
// exit ;
88999: GO 89112
// index := GetElementIndex ( hackTanks , hack ) ;
89001: LD_ADDR_VAR 0 4
89005: PUSH
89006: LD_EXP 89
89010: PPUSH
89011: LD_VAR 0 1
89015: PPUSH
89016: CALL 15775 0 2
89020: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
89021: LD_EXP 90
89025: PUSH
89026: LD_VAR 0 4
89030: ARRAY
89031: IFFALSE 89112
// begin for i in hackTanksCaptured [ index ] do
89033: LD_ADDR_VAR 0 3
89037: PUSH
89038: LD_EXP 90
89042: PUSH
89043: LD_VAR 0 4
89047: ARRAY
89048: PUSH
89049: FOR_IN
89050: IFFALSE 89076
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
89052: LD_VAR 0 3
89056: PUSH
89057: LD_INT 1
89059: ARRAY
89060: PPUSH
89061: LD_VAR 0 3
89065: PUSH
89066: LD_INT 2
89068: ARRAY
89069: PPUSH
89070: CALL_OW 235
89074: GO 89049
89076: POP
89077: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
89078: LD_ADDR_EXP 90
89082: PUSH
89083: LD_EXP 90
89087: PPUSH
89088: LD_VAR 0 4
89092: PPUSH
89093: EMPTY
89094: PPUSH
89095: CALL_OW 1
89099: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
89100: LD_VAR 0 1
89104: PPUSH
89105: LD_INT 0
89107: PPUSH
89108: CALL_OW 505
// end ; end ;
89112: LD_VAR 0 2
89116: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
89117: LD_INT 0
89119: PPUSH
89120: PPUSH
89121: PPUSH
// if not hack in hackTanks or not vehicles then
89122: LD_VAR 0 1
89126: PUSH
89127: LD_EXP 89
89131: IN
89132: NOT
89133: PUSH
89134: LD_VAR 0 2
89138: NOT
89139: OR
89140: IFFALSE 89144
// exit ;
89142: GO 89419
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
89144: LD_ADDR_VAR 0 2
89148: PUSH
89149: LD_VAR 0 1
89153: PPUSH
89154: LD_VAR 0 2
89158: PPUSH
89159: LD_INT 1
89161: PPUSH
89162: LD_INT 1
89164: PPUSH
89165: CALL 16425 0 4
89169: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
89170: LD_ADDR_VAR 0 5
89174: PUSH
89175: LD_EXP 89
89179: PPUSH
89180: LD_VAR 0 1
89184: PPUSH
89185: CALL 15775 0 2
89189: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
89190: LD_EXP 90
89194: PUSH
89195: LD_VAR 0 5
89199: ARRAY
89200: PUSH
89201: LD_EXP 91
89205: LESS
89206: IFFALSE 89395
// begin for i := 1 to vehicles do
89208: LD_ADDR_VAR 0 4
89212: PUSH
89213: DOUBLE
89214: LD_INT 1
89216: DEC
89217: ST_TO_ADDR
89218: LD_VAR 0 2
89222: PUSH
89223: FOR_TO
89224: IFFALSE 89393
// begin if hackTanksCaptured [ index ] = hackLimit then
89226: LD_EXP 90
89230: PUSH
89231: LD_VAR 0 5
89235: ARRAY
89236: PUSH
89237: LD_EXP 91
89241: EQUAL
89242: IFFALSE 89246
// break ;
89244: GO 89393
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
89246: LD_ADDR_EXP 93
89250: PUSH
89251: LD_EXP 93
89255: PPUSH
89256: LD_VAR 0 5
89260: PPUSH
89261: LD_EXP 93
89265: PUSH
89266: LD_VAR 0 5
89270: ARRAY
89271: PUSH
89272: LD_INT 1
89274: PLUS
89275: PPUSH
89276: CALL_OW 1
89280: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
89281: LD_ADDR_EXP 90
89285: PUSH
89286: LD_EXP 90
89290: PPUSH
89291: LD_VAR 0 5
89295: PUSH
89296: LD_EXP 90
89300: PUSH
89301: LD_VAR 0 5
89305: ARRAY
89306: PUSH
89307: LD_INT 1
89309: PLUS
89310: PUSH
89311: EMPTY
89312: LIST
89313: LIST
89314: PPUSH
89315: LD_VAR 0 2
89319: PUSH
89320: LD_VAR 0 4
89324: ARRAY
89325: PUSH
89326: LD_VAR 0 2
89330: PUSH
89331: LD_VAR 0 4
89335: ARRAY
89336: PPUSH
89337: CALL_OW 255
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PPUSH
89346: CALL 15990 0 3
89350: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
89351: LD_VAR 0 2
89355: PUSH
89356: LD_VAR 0 4
89360: ARRAY
89361: PPUSH
89362: LD_VAR 0 1
89366: PPUSH
89367: CALL_OW 255
89371: PPUSH
89372: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
89376: LD_VAR 0 2
89380: PUSH
89381: LD_VAR 0 4
89385: ARRAY
89386: PPUSH
89387: CALL_OW 141
// end ;
89391: GO 89223
89393: POP
89394: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
89395: LD_VAR 0 1
89399: PPUSH
89400: LD_EXP 90
89404: PUSH
89405: LD_VAR 0 5
89409: ARRAY
89410: PUSH
89411: LD_INT 0
89413: PLUS
89414: PPUSH
89415: CALL_OW 505
// end ;
89419: LD_VAR 0 3
89423: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
89424: LD_INT 0
89426: PPUSH
89427: PPUSH
89428: PPUSH
89429: PPUSH
// if not hack in hackTanks then
89430: LD_VAR 0 1
89434: PUSH
89435: LD_EXP 89
89439: IN
89440: NOT
89441: IFFALSE 89445
// exit ;
89443: GO 89685
// index := GetElementIndex ( hackTanks , hack ) ;
89445: LD_ADDR_VAR 0 4
89449: PUSH
89450: LD_EXP 89
89454: PPUSH
89455: LD_VAR 0 1
89459: PPUSH
89460: CALL 15775 0 2
89464: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
89465: LD_ADDR_VAR 0 3
89469: PUSH
89470: DOUBLE
89471: LD_EXP 90
89475: PUSH
89476: LD_VAR 0 4
89480: ARRAY
89481: INC
89482: ST_TO_ADDR
89483: LD_INT 1
89485: PUSH
89486: FOR_DOWNTO
89487: IFFALSE 89659
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
89489: LD_ADDR_VAR 0 5
89493: PUSH
89494: LD_EXP 90
89498: PUSH
89499: LD_VAR 0 4
89503: ARRAY
89504: PUSH
89505: LD_VAR 0 3
89509: ARRAY
89510: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
89511: LD_VAR 0 5
89515: PUSH
89516: LD_INT 1
89518: ARRAY
89519: PPUSH
89520: CALL_OW 302
89524: NOT
89525: PUSH
89526: LD_VAR 0 5
89530: PUSH
89531: LD_INT 1
89533: ARRAY
89534: PPUSH
89535: CALL_OW 255
89539: PUSH
89540: LD_VAR 0 1
89544: PPUSH
89545: CALL_OW 255
89549: NONEQUAL
89550: OR
89551: IFFALSE 89657
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
89553: LD_VAR 0 5
89557: PUSH
89558: LD_INT 1
89560: ARRAY
89561: PPUSH
89562: CALL_OW 305
89566: PUSH
89567: LD_VAR 0 5
89571: PUSH
89572: LD_INT 1
89574: ARRAY
89575: PPUSH
89576: CALL_OW 255
89580: PUSH
89581: LD_VAR 0 1
89585: PPUSH
89586: CALL_OW 255
89590: EQUAL
89591: AND
89592: IFFALSE 89616
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
89594: LD_VAR 0 5
89598: PUSH
89599: LD_INT 1
89601: ARRAY
89602: PPUSH
89603: LD_VAR 0 5
89607: PUSH
89608: LD_INT 2
89610: ARRAY
89611: PPUSH
89612: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
89616: LD_ADDR_EXP 90
89620: PUSH
89621: LD_EXP 90
89625: PPUSH
89626: LD_VAR 0 4
89630: PPUSH
89631: LD_EXP 90
89635: PUSH
89636: LD_VAR 0 4
89640: ARRAY
89641: PPUSH
89642: LD_VAR 0 3
89646: PPUSH
89647: CALL_OW 3
89651: PPUSH
89652: CALL_OW 1
89656: ST_TO_ADDR
// end ; end ;
89657: GO 89486
89659: POP
89660: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
89661: LD_VAR 0 1
89665: PPUSH
89666: LD_EXP 90
89670: PUSH
89671: LD_VAR 0 4
89675: ARRAY
89676: PUSH
89677: LD_INT 0
89679: PLUS
89680: PPUSH
89681: CALL_OW 505
// end ;
89685: LD_VAR 0 2
89689: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
89690: LD_INT 0
89692: PPUSH
89693: PPUSH
89694: PPUSH
89695: PPUSH
// if not hack in hackTanks then
89696: LD_VAR 0 1
89700: PUSH
89701: LD_EXP 89
89705: IN
89706: NOT
89707: IFFALSE 89711
// exit ;
89709: GO 89796
// index := GetElementIndex ( hackTanks , hack ) ;
89711: LD_ADDR_VAR 0 5
89715: PUSH
89716: LD_EXP 89
89720: PPUSH
89721: LD_VAR 0 1
89725: PPUSH
89726: CALL 15775 0 2
89730: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
89731: LD_ADDR_VAR 0 4
89735: PUSH
89736: DOUBLE
89737: LD_INT 1
89739: DEC
89740: ST_TO_ADDR
89741: LD_EXP 90
89745: PUSH
89746: LD_VAR 0 5
89750: ARRAY
89751: PUSH
89752: FOR_TO
89753: IFFALSE 89794
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
89755: LD_EXP 90
89759: PUSH
89760: LD_VAR 0 5
89764: ARRAY
89765: PUSH
89766: LD_VAR 0 4
89770: ARRAY
89771: PUSH
89772: LD_INT 1
89774: ARRAY
89775: PUSH
89776: LD_VAR 0 2
89780: EQUAL
89781: IFFALSE 89792
// KillUnit ( vehicle ) ;
89783: LD_VAR 0 2
89787: PPUSH
89788: CALL_OW 66
89792: GO 89752
89794: POP
89795: POP
// end ;
89796: LD_VAR 0 3
89800: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
89801: LD_EXP 94
89805: NOT
89806: IFFALSE 89841
89808: GO 89810
89810: DISABLE
// begin initMiner := true ;
89811: LD_ADDR_EXP 94
89815: PUSH
89816: LD_INT 1
89818: ST_TO_ADDR
// minersList := [ ] ;
89819: LD_ADDR_EXP 95
89823: PUSH
89824: EMPTY
89825: ST_TO_ADDR
// minerMinesList := [ ] ;
89826: LD_ADDR_EXP 96
89830: PUSH
89831: EMPTY
89832: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
89833: LD_ADDR_EXP 97
89837: PUSH
89838: LD_INT 5
89840: ST_TO_ADDR
// end ;
89841: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
89842: LD_EXP 94
89846: PUSH
89847: LD_INT 34
89849: PUSH
89850: LD_EXP 74
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PPUSH
89859: CALL_OW 69
89863: AND
89864: IFFALSE 90327
89866: GO 89868
89868: DISABLE
89869: LD_INT 0
89871: PPUSH
89872: PPUSH
89873: PPUSH
89874: PPUSH
// begin enable ;
89875: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
89876: LD_ADDR_VAR 0 1
89880: PUSH
89881: LD_INT 34
89883: PUSH
89884: LD_EXP 74
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: PPUSH
89893: CALL_OW 69
89897: PUSH
89898: FOR_IN
89899: IFFALSE 89971
// begin if not i in minersList then
89901: LD_VAR 0 1
89905: PUSH
89906: LD_EXP 95
89910: IN
89911: NOT
89912: IFFALSE 89969
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
89914: LD_ADDR_EXP 95
89918: PUSH
89919: LD_EXP 95
89923: PPUSH
89924: LD_EXP 95
89928: PUSH
89929: LD_INT 1
89931: PLUS
89932: PPUSH
89933: LD_VAR 0 1
89937: PPUSH
89938: CALL_OW 1
89942: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
89943: LD_ADDR_EXP 96
89947: PUSH
89948: LD_EXP 96
89952: PPUSH
89953: LD_EXP 96
89957: PUSH
89958: LD_INT 1
89960: PLUS
89961: PPUSH
89962: EMPTY
89963: PPUSH
89964: CALL_OW 1
89968: ST_TO_ADDR
// end end ;
89969: GO 89898
89971: POP
89972: POP
// for i := minerMinesList downto 1 do
89973: LD_ADDR_VAR 0 1
89977: PUSH
89978: DOUBLE
89979: LD_EXP 96
89983: INC
89984: ST_TO_ADDR
89985: LD_INT 1
89987: PUSH
89988: FOR_DOWNTO
89989: IFFALSE 90325
// begin if IsLive ( minersList [ i ] ) then
89991: LD_EXP 95
89995: PUSH
89996: LD_VAR 0 1
90000: ARRAY
90001: PPUSH
90002: CALL_OW 300
90006: IFFALSE 90034
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
90008: LD_EXP 95
90012: PUSH
90013: LD_VAR 0 1
90017: ARRAY
90018: PPUSH
90019: LD_EXP 96
90023: PUSH
90024: LD_VAR 0 1
90028: ARRAY
90029: PPUSH
90030: CALL_OW 505
// if not minerMinesList [ i ] then
90034: LD_EXP 96
90038: PUSH
90039: LD_VAR 0 1
90043: ARRAY
90044: NOT
90045: IFFALSE 90049
// continue ;
90047: GO 89988
// for j := minerMinesList [ i ] downto 1 do
90049: LD_ADDR_VAR 0 2
90053: PUSH
90054: DOUBLE
90055: LD_EXP 96
90059: PUSH
90060: LD_VAR 0 1
90064: ARRAY
90065: INC
90066: ST_TO_ADDR
90067: LD_INT 1
90069: PUSH
90070: FOR_DOWNTO
90071: IFFALSE 90321
// begin side := GetSide ( minersList [ i ] ) ;
90073: LD_ADDR_VAR 0 3
90077: PUSH
90078: LD_EXP 95
90082: PUSH
90083: LD_VAR 0 1
90087: ARRAY
90088: PPUSH
90089: CALL_OW 255
90093: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
90094: LD_ADDR_VAR 0 4
90098: PUSH
90099: LD_EXP 96
90103: PUSH
90104: LD_VAR 0 1
90108: ARRAY
90109: PUSH
90110: LD_VAR 0 2
90114: ARRAY
90115: PUSH
90116: LD_INT 1
90118: ARRAY
90119: PPUSH
90120: LD_EXP 96
90124: PUSH
90125: LD_VAR 0 1
90129: ARRAY
90130: PUSH
90131: LD_VAR 0 2
90135: ARRAY
90136: PUSH
90137: LD_INT 2
90139: ARRAY
90140: PPUSH
90141: CALL_OW 428
90145: ST_TO_ADDR
// if not tmp then
90146: LD_VAR 0 4
90150: NOT
90151: IFFALSE 90155
// continue ;
90153: GO 90070
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
90155: LD_VAR 0 4
90159: PUSH
90160: LD_INT 81
90162: PUSH
90163: LD_VAR 0 3
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: PPUSH
90172: CALL_OW 69
90176: IN
90177: PUSH
90178: LD_EXP 96
90182: PUSH
90183: LD_VAR 0 1
90187: ARRAY
90188: PUSH
90189: LD_VAR 0 2
90193: ARRAY
90194: PUSH
90195: LD_INT 1
90197: ARRAY
90198: PPUSH
90199: LD_EXP 96
90203: PUSH
90204: LD_VAR 0 1
90208: ARRAY
90209: PUSH
90210: LD_VAR 0 2
90214: ARRAY
90215: PUSH
90216: LD_INT 2
90218: ARRAY
90219: PPUSH
90220: CALL_OW 458
90224: AND
90225: IFFALSE 90319
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
90227: LD_EXP 96
90231: PUSH
90232: LD_VAR 0 1
90236: ARRAY
90237: PUSH
90238: LD_VAR 0 2
90242: ARRAY
90243: PUSH
90244: LD_INT 1
90246: ARRAY
90247: PPUSH
90248: LD_EXP 96
90252: PUSH
90253: LD_VAR 0 1
90257: ARRAY
90258: PUSH
90259: LD_VAR 0 2
90263: ARRAY
90264: PUSH
90265: LD_INT 2
90267: ARRAY
90268: PPUSH
90269: LD_VAR 0 3
90273: PPUSH
90274: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
90278: LD_ADDR_EXP 96
90282: PUSH
90283: LD_EXP 96
90287: PPUSH
90288: LD_VAR 0 1
90292: PPUSH
90293: LD_EXP 96
90297: PUSH
90298: LD_VAR 0 1
90302: ARRAY
90303: PPUSH
90304: LD_VAR 0 2
90308: PPUSH
90309: CALL_OW 3
90313: PPUSH
90314: CALL_OW 1
90318: ST_TO_ADDR
// end ; end ;
90319: GO 90070
90321: POP
90322: POP
// end ;
90323: GO 89988
90325: POP
90326: POP
// end ;
90327: PPOPN 4
90329: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
90330: LD_INT 0
90332: PPUSH
90333: PPUSH
// result := false ;
90334: LD_ADDR_VAR 0 4
90338: PUSH
90339: LD_INT 0
90341: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
90342: LD_VAR 0 1
90346: PPUSH
90347: CALL_OW 264
90351: PUSH
90352: LD_EXP 74
90356: EQUAL
90357: NOT
90358: IFFALSE 90362
// exit ;
90360: GO 90602
// index := GetElementIndex ( minersList , unit ) ;
90362: LD_ADDR_VAR 0 5
90366: PUSH
90367: LD_EXP 95
90371: PPUSH
90372: LD_VAR 0 1
90376: PPUSH
90377: CALL 15775 0 2
90381: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
90382: LD_EXP 96
90386: PUSH
90387: LD_VAR 0 5
90391: ARRAY
90392: PUSH
90393: LD_EXP 97
90397: GREATEREQUAL
90398: IFFALSE 90402
// exit ;
90400: GO 90602
// ComMoveXY ( unit , x , y ) ;
90402: LD_VAR 0 1
90406: PPUSH
90407: LD_VAR 0 2
90411: PPUSH
90412: LD_VAR 0 3
90416: PPUSH
90417: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
90421: LD_INT 35
90423: PPUSH
90424: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
90428: LD_VAR 0 1
90432: PPUSH
90433: LD_VAR 0 2
90437: PPUSH
90438: LD_VAR 0 3
90442: PPUSH
90443: CALL 46547 0 3
90447: NOT
90448: PUSH
90449: LD_VAR 0 1
90453: PPUSH
90454: CALL_OW 314
90458: AND
90459: IFFALSE 90463
// exit ;
90461: GO 90602
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
90463: LD_VAR 0 2
90467: PPUSH
90468: LD_VAR 0 3
90472: PPUSH
90473: CALL_OW 428
90477: PUSH
90478: LD_VAR 0 1
90482: EQUAL
90483: PUSH
90484: LD_VAR 0 1
90488: PPUSH
90489: CALL_OW 314
90493: NOT
90494: AND
90495: IFFALSE 90421
// PlaySoundXY ( x , y , PlantMine ) ;
90497: LD_VAR 0 2
90501: PPUSH
90502: LD_VAR 0 3
90506: PPUSH
90507: LD_STRING PlantMine
90509: PPUSH
90510: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
90514: LD_VAR 0 2
90518: PPUSH
90519: LD_VAR 0 3
90523: PPUSH
90524: LD_VAR 0 1
90528: PPUSH
90529: CALL_OW 255
90533: PPUSH
90534: LD_INT 0
90536: PPUSH
90537: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
90541: LD_ADDR_EXP 96
90545: PUSH
90546: LD_EXP 96
90550: PPUSH
90551: LD_VAR 0 5
90555: PUSH
90556: LD_EXP 96
90560: PUSH
90561: LD_VAR 0 5
90565: ARRAY
90566: PUSH
90567: LD_INT 1
90569: PLUS
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PPUSH
90575: LD_VAR 0 2
90579: PUSH
90580: LD_VAR 0 3
90584: PUSH
90585: EMPTY
90586: LIST
90587: LIST
90588: PPUSH
90589: CALL 15990 0 3
90593: ST_TO_ADDR
// result := true ;
90594: LD_ADDR_VAR 0 4
90598: PUSH
90599: LD_INT 1
90601: ST_TO_ADDR
// end ;
90602: LD_VAR 0 4
90606: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
90607: LD_INT 0
90609: PPUSH
90610: PPUSH
90611: PPUSH
// if not unit in minersList then
90612: LD_VAR 0 1
90616: PUSH
90617: LD_EXP 95
90621: IN
90622: NOT
90623: IFFALSE 90627
// exit ;
90625: GO 91019
// index := GetElementIndex ( minersList , unit ) ;
90627: LD_ADDR_VAR 0 6
90631: PUSH
90632: LD_EXP 95
90636: PPUSH
90637: LD_VAR 0 1
90641: PPUSH
90642: CALL 15775 0 2
90646: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
90647: LD_ADDR_VAR 0 5
90651: PUSH
90652: DOUBLE
90653: LD_EXP 96
90657: PUSH
90658: LD_VAR 0 6
90662: ARRAY
90663: INC
90664: ST_TO_ADDR
90665: LD_INT 1
90667: PUSH
90668: FOR_DOWNTO
90669: IFFALSE 90830
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
90671: LD_EXP 96
90675: PUSH
90676: LD_VAR 0 6
90680: ARRAY
90681: PUSH
90682: LD_VAR 0 5
90686: ARRAY
90687: PUSH
90688: LD_INT 1
90690: ARRAY
90691: PUSH
90692: LD_VAR 0 2
90696: EQUAL
90697: PUSH
90698: LD_EXP 96
90702: PUSH
90703: LD_VAR 0 6
90707: ARRAY
90708: PUSH
90709: LD_VAR 0 5
90713: ARRAY
90714: PUSH
90715: LD_INT 2
90717: ARRAY
90718: PUSH
90719: LD_VAR 0 3
90723: EQUAL
90724: AND
90725: IFFALSE 90828
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
90727: LD_EXP 96
90731: PUSH
90732: LD_VAR 0 6
90736: ARRAY
90737: PUSH
90738: LD_VAR 0 5
90742: ARRAY
90743: PUSH
90744: LD_INT 1
90746: ARRAY
90747: PPUSH
90748: LD_EXP 96
90752: PUSH
90753: LD_VAR 0 6
90757: ARRAY
90758: PUSH
90759: LD_VAR 0 5
90763: ARRAY
90764: PUSH
90765: LD_INT 2
90767: ARRAY
90768: PPUSH
90769: LD_VAR 0 1
90773: PPUSH
90774: CALL_OW 255
90778: PPUSH
90779: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
90783: LD_ADDR_EXP 96
90787: PUSH
90788: LD_EXP 96
90792: PPUSH
90793: LD_VAR 0 6
90797: PPUSH
90798: LD_EXP 96
90802: PUSH
90803: LD_VAR 0 6
90807: ARRAY
90808: PPUSH
90809: LD_VAR 0 5
90813: PPUSH
90814: CALL_OW 3
90818: PPUSH
90819: CALL_OW 1
90823: ST_TO_ADDR
// exit ;
90824: POP
90825: POP
90826: GO 91019
// end ; end ;
90828: GO 90668
90830: POP
90831: POP
// for i := minerMinesList [ index ] downto 1 do
90832: LD_ADDR_VAR 0 5
90836: PUSH
90837: DOUBLE
90838: LD_EXP 96
90842: PUSH
90843: LD_VAR 0 6
90847: ARRAY
90848: INC
90849: ST_TO_ADDR
90850: LD_INT 1
90852: PUSH
90853: FOR_DOWNTO
90854: IFFALSE 91017
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
90856: LD_EXP 96
90860: PUSH
90861: LD_VAR 0 6
90865: ARRAY
90866: PUSH
90867: LD_VAR 0 5
90871: ARRAY
90872: PUSH
90873: LD_INT 1
90875: ARRAY
90876: PPUSH
90877: LD_EXP 96
90881: PUSH
90882: LD_VAR 0 6
90886: ARRAY
90887: PUSH
90888: LD_VAR 0 5
90892: ARRAY
90893: PUSH
90894: LD_INT 2
90896: ARRAY
90897: PPUSH
90898: LD_VAR 0 2
90902: PPUSH
90903: LD_VAR 0 3
90907: PPUSH
90908: CALL_OW 298
90912: PUSH
90913: LD_INT 6
90915: LESS
90916: IFFALSE 91015
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
90918: LD_EXP 96
90922: PUSH
90923: LD_VAR 0 6
90927: ARRAY
90928: PUSH
90929: LD_VAR 0 5
90933: ARRAY
90934: PUSH
90935: LD_INT 1
90937: ARRAY
90938: PPUSH
90939: LD_EXP 96
90943: PUSH
90944: LD_VAR 0 6
90948: ARRAY
90949: PUSH
90950: LD_VAR 0 5
90954: ARRAY
90955: PUSH
90956: LD_INT 2
90958: ARRAY
90959: PPUSH
90960: LD_VAR 0 1
90964: PPUSH
90965: CALL_OW 255
90969: PPUSH
90970: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
90974: LD_ADDR_EXP 96
90978: PUSH
90979: LD_EXP 96
90983: PPUSH
90984: LD_VAR 0 6
90988: PPUSH
90989: LD_EXP 96
90993: PUSH
90994: LD_VAR 0 6
90998: ARRAY
90999: PPUSH
91000: LD_VAR 0 5
91004: PPUSH
91005: CALL_OW 3
91009: PPUSH
91010: CALL_OW 1
91014: ST_TO_ADDR
// end ; end ;
91015: GO 90853
91017: POP
91018: POP
// end ;
91019: LD_VAR 0 4
91023: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
91024: LD_INT 0
91026: PPUSH
91027: PPUSH
91028: PPUSH
91029: PPUSH
91030: PPUSH
91031: PPUSH
91032: PPUSH
91033: PPUSH
91034: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
91035: LD_VAR 0 1
91039: PPUSH
91040: CALL_OW 264
91044: PUSH
91045: LD_EXP 74
91049: EQUAL
91050: NOT
91051: PUSH
91052: LD_VAR 0 1
91056: PUSH
91057: LD_EXP 95
91061: IN
91062: NOT
91063: OR
91064: IFFALSE 91068
// exit ;
91066: GO 91390
// index := GetElementIndex ( minersList , unit ) ;
91068: LD_ADDR_VAR 0 6
91072: PUSH
91073: LD_EXP 95
91077: PPUSH
91078: LD_VAR 0 1
91082: PPUSH
91083: CALL 15775 0 2
91087: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
91088: LD_ADDR_VAR 0 8
91092: PUSH
91093: LD_EXP 97
91097: PUSH
91098: LD_EXP 96
91102: PUSH
91103: LD_VAR 0 6
91107: ARRAY
91108: MINUS
91109: ST_TO_ADDR
// if not minesFreeAmount then
91110: LD_VAR 0 8
91114: NOT
91115: IFFALSE 91119
// exit ;
91117: GO 91390
// tmp := [ ] ;
91119: LD_ADDR_VAR 0 7
91123: PUSH
91124: EMPTY
91125: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
91126: LD_ADDR_VAR 0 5
91130: PUSH
91131: DOUBLE
91132: LD_INT 1
91134: DEC
91135: ST_TO_ADDR
91136: LD_VAR 0 8
91140: PUSH
91141: FOR_TO
91142: IFFALSE 91337
// begin _d := rand ( 0 , 5 ) ;
91144: LD_ADDR_VAR 0 11
91148: PUSH
91149: LD_INT 0
91151: PPUSH
91152: LD_INT 5
91154: PPUSH
91155: CALL_OW 12
91159: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
91160: LD_ADDR_VAR 0 12
91164: PUSH
91165: LD_INT 2
91167: PPUSH
91168: LD_INT 6
91170: PPUSH
91171: CALL_OW 12
91175: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
91176: LD_ADDR_VAR 0 9
91180: PUSH
91181: LD_VAR 0 2
91185: PPUSH
91186: LD_VAR 0 11
91190: PPUSH
91191: LD_VAR 0 12
91195: PPUSH
91196: CALL_OW 272
91200: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
91201: LD_ADDR_VAR 0 10
91205: PUSH
91206: LD_VAR 0 3
91210: PPUSH
91211: LD_VAR 0 11
91215: PPUSH
91216: LD_VAR 0 12
91220: PPUSH
91221: CALL_OW 273
91225: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
91226: LD_VAR 0 9
91230: PPUSH
91231: LD_VAR 0 10
91235: PPUSH
91236: CALL_OW 488
91240: PUSH
91241: LD_VAR 0 9
91245: PUSH
91246: LD_VAR 0 10
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: LD_VAR 0 7
91259: IN
91260: NOT
91261: AND
91262: PUSH
91263: LD_VAR 0 9
91267: PPUSH
91268: LD_VAR 0 10
91272: PPUSH
91273: CALL_OW 458
91277: NOT
91278: AND
91279: IFFALSE 91321
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
91281: LD_ADDR_VAR 0 7
91285: PUSH
91286: LD_VAR 0 7
91290: PPUSH
91291: LD_VAR 0 7
91295: PUSH
91296: LD_INT 1
91298: PLUS
91299: PPUSH
91300: LD_VAR 0 9
91304: PUSH
91305: LD_VAR 0 10
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PPUSH
91314: CALL_OW 1
91318: ST_TO_ADDR
91319: GO 91335
// i := i - 1 ;
91321: LD_ADDR_VAR 0 5
91325: PUSH
91326: LD_VAR 0 5
91330: PUSH
91331: LD_INT 1
91333: MINUS
91334: ST_TO_ADDR
// end ;
91335: GO 91141
91337: POP
91338: POP
// for i in tmp do
91339: LD_ADDR_VAR 0 5
91343: PUSH
91344: LD_VAR 0 7
91348: PUSH
91349: FOR_IN
91350: IFFALSE 91388
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
91352: LD_VAR 0 1
91356: PPUSH
91357: LD_VAR 0 5
91361: PUSH
91362: LD_INT 1
91364: ARRAY
91365: PPUSH
91366: LD_VAR 0 5
91370: PUSH
91371: LD_INT 2
91373: ARRAY
91374: PPUSH
91375: CALL 90330 0 3
91379: NOT
91380: IFFALSE 91386
// exit ;
91382: POP
91383: POP
91384: GO 91390
91386: GO 91349
91388: POP
91389: POP
// end ;
91390: LD_VAR 0 4
91394: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
91395: LD_INT 0
91397: PPUSH
91398: PPUSH
91399: PPUSH
91400: PPUSH
91401: PPUSH
91402: PPUSH
91403: PPUSH
// if not GetClass ( unit ) = class_sniper then
91404: LD_VAR 0 1
91408: PPUSH
91409: CALL_OW 257
91413: PUSH
91414: LD_INT 5
91416: EQUAL
91417: NOT
91418: IFFALSE 91422
// exit ;
91420: GO 91810
// dist := 8 ;
91422: LD_ADDR_VAR 0 5
91426: PUSH
91427: LD_INT 8
91429: ST_TO_ADDR
// viewRange := 12 ;
91430: LD_ADDR_VAR 0 7
91434: PUSH
91435: LD_INT 12
91437: ST_TO_ADDR
// side := GetSide ( unit ) ;
91438: LD_ADDR_VAR 0 6
91442: PUSH
91443: LD_VAR 0 1
91447: PPUSH
91448: CALL_OW 255
91452: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
91453: LD_INT 61
91455: PPUSH
91456: LD_VAR 0 6
91460: PPUSH
91461: CALL_OW 321
91465: PUSH
91466: LD_INT 2
91468: EQUAL
91469: IFFALSE 91479
// viewRange := 16 ;
91471: LD_ADDR_VAR 0 7
91475: PUSH
91476: LD_INT 16
91478: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
91479: LD_VAR 0 1
91483: PPUSH
91484: LD_VAR 0 2
91488: PPUSH
91489: LD_VAR 0 3
91493: PPUSH
91494: CALL_OW 297
91498: PUSH
91499: LD_VAR 0 5
91503: GREATER
91504: IFFALSE 91583
// begin ComMoveXY ( unit , x , y ) ;
91506: LD_VAR 0 1
91510: PPUSH
91511: LD_VAR 0 2
91515: PPUSH
91516: LD_VAR 0 3
91520: PPUSH
91521: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
91525: LD_INT 35
91527: PPUSH
91528: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
91532: LD_VAR 0 1
91536: PPUSH
91537: LD_VAR 0 2
91541: PPUSH
91542: LD_VAR 0 3
91546: PPUSH
91547: CALL 46547 0 3
91551: NOT
91552: IFFALSE 91556
// exit ;
91554: GO 91810
// until GetDistUnitXY ( unit , x , y ) < dist ;
91556: LD_VAR 0 1
91560: PPUSH
91561: LD_VAR 0 2
91565: PPUSH
91566: LD_VAR 0 3
91570: PPUSH
91571: CALL_OW 297
91575: PUSH
91576: LD_VAR 0 5
91580: LESS
91581: IFFALSE 91525
// end ; ComTurnXY ( unit , x , y ) ;
91583: LD_VAR 0 1
91587: PPUSH
91588: LD_VAR 0 2
91592: PPUSH
91593: LD_VAR 0 3
91597: PPUSH
91598: CALL_OW 118
// wait ( 5 ) ;
91602: LD_INT 5
91604: PPUSH
91605: CALL_OW 67
// _d := GetDir ( unit ) ;
91609: LD_ADDR_VAR 0 10
91613: PUSH
91614: LD_VAR 0 1
91618: PPUSH
91619: CALL_OW 254
91623: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
91624: LD_ADDR_VAR 0 8
91628: PUSH
91629: LD_VAR 0 1
91633: PPUSH
91634: CALL_OW 250
91638: PPUSH
91639: LD_VAR 0 10
91643: PPUSH
91644: LD_VAR 0 5
91648: PPUSH
91649: CALL_OW 272
91653: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
91654: LD_ADDR_VAR 0 9
91658: PUSH
91659: LD_VAR 0 1
91663: PPUSH
91664: CALL_OW 251
91668: PPUSH
91669: LD_VAR 0 10
91673: PPUSH
91674: LD_VAR 0 5
91678: PPUSH
91679: CALL_OW 273
91683: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91684: LD_VAR 0 8
91688: PPUSH
91689: LD_VAR 0 9
91693: PPUSH
91694: CALL_OW 488
91698: NOT
91699: IFFALSE 91703
// exit ;
91701: GO 91810
// ComAnimCustom ( unit , 1 ) ;
91703: LD_VAR 0 1
91707: PPUSH
91708: LD_INT 1
91710: PPUSH
91711: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
91715: LD_VAR 0 8
91719: PPUSH
91720: LD_VAR 0 9
91724: PPUSH
91725: LD_VAR 0 6
91729: PPUSH
91730: LD_VAR 0 7
91734: PPUSH
91735: CALL_OW 330
// repeat wait ( 1 ) ;
91739: LD_INT 1
91741: PPUSH
91742: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
91746: LD_VAR 0 1
91750: PPUSH
91751: CALL_OW 316
91755: PUSH
91756: LD_VAR 0 1
91760: PPUSH
91761: CALL_OW 314
91765: OR
91766: PUSH
91767: LD_VAR 0 1
91771: PPUSH
91772: CALL_OW 302
91776: NOT
91777: OR
91778: PUSH
91779: LD_VAR 0 1
91783: PPUSH
91784: CALL_OW 301
91788: OR
91789: IFFALSE 91739
// RemoveSeeing ( _x , _y , side ) ;
91791: LD_VAR 0 8
91795: PPUSH
91796: LD_VAR 0 9
91800: PPUSH
91801: LD_VAR 0 6
91805: PPUSH
91806: CALL_OW 331
// end ; end_of_file end_of_file
91810: LD_VAR 0 4
91814: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
91815: LD_VAR 0 1
91819: PUSH
91820: LD_INT 200
91822: DOUBLE
91823: GREATEREQUAL
91824: IFFALSE 91832
91826: LD_INT 299
91828: DOUBLE
91829: LESSEQUAL
91830: IFTRUE 91834
91832: GO 91866
91834: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
91835: LD_VAR 0 1
91839: PPUSH
91840: LD_VAR 0 2
91844: PPUSH
91845: LD_VAR 0 3
91849: PPUSH
91850: LD_VAR 0 4
91854: PPUSH
91855: LD_VAR 0 5
91859: PPUSH
91860: CALL 87932 0 5
91864: GO 91943
91866: LD_INT 300
91868: DOUBLE
91869: GREATEREQUAL
91870: IFFALSE 91878
91872: LD_INT 399
91874: DOUBLE
91875: LESSEQUAL
91876: IFTRUE 91880
91878: GO 91942
91880: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
91881: LD_VAR 0 1
91885: PPUSH
91886: LD_VAR 0 2
91890: PPUSH
91891: LD_VAR 0 3
91895: PPUSH
91896: LD_VAR 0 4
91900: PPUSH
91901: LD_VAR 0 5
91905: PPUSH
91906: LD_VAR 0 6
91910: PPUSH
91911: LD_VAR 0 7
91915: PPUSH
91916: LD_VAR 0 8
91920: PPUSH
91921: LD_VAR 0 9
91925: PPUSH
91926: LD_VAR 0 10
91930: PPUSH
91931: LD_VAR 0 11
91935: PPUSH
91936: CALL 103170 0 11
91940: GO 91943
91942: POP
// end ;
91943: PPOPN 11
91945: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
91946: LD_VAR 0 1
91950: PPUSH
91951: LD_VAR 0 2
91955: PPUSH
91956: LD_VAR 0 3
91960: PPUSH
91961: LD_VAR 0 4
91965: PPUSH
91966: LD_VAR 0 5
91970: PPUSH
91971: CALL 87914 0 5
// end ; end_of_file
91975: PPOPN 5
91977: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91978: LD_INT 0
91980: PPUSH
// if p2 = 100 then
91981: LD_VAR 0 2
91985: PUSH
91986: LD_INT 100
91988: EQUAL
91989: IFFALSE 92938
// begin if not StreamModeActive then
91991: LD_EXP 98
91995: NOT
91996: IFFALSE 92006
// StreamModeActive := true ;
91998: LD_ADDR_EXP 98
92002: PUSH
92003: LD_INT 1
92005: ST_TO_ADDR
// if p3 = 0 then
92006: LD_VAR 0 3
92010: PUSH
92011: LD_INT 0
92013: EQUAL
92014: IFFALSE 92020
// InitStreamMode ;
92016: CALL 93098 0 0
// if p3 = 1 then
92020: LD_VAR 0 3
92024: PUSH
92025: LD_INT 1
92027: EQUAL
92028: IFFALSE 92038
// sRocket := true ;
92030: LD_ADDR_EXP 103
92034: PUSH
92035: LD_INT 1
92037: ST_TO_ADDR
// if p3 = 2 then
92038: LD_VAR 0 3
92042: PUSH
92043: LD_INT 2
92045: EQUAL
92046: IFFALSE 92056
// sSpeed := true ;
92048: LD_ADDR_EXP 102
92052: PUSH
92053: LD_INT 1
92055: ST_TO_ADDR
// if p3 = 3 then
92056: LD_VAR 0 3
92060: PUSH
92061: LD_INT 3
92063: EQUAL
92064: IFFALSE 92074
// sEngine := true ;
92066: LD_ADDR_EXP 104
92070: PUSH
92071: LD_INT 1
92073: ST_TO_ADDR
// if p3 = 4 then
92074: LD_VAR 0 3
92078: PUSH
92079: LD_INT 4
92081: EQUAL
92082: IFFALSE 92092
// sSpec := true ;
92084: LD_ADDR_EXP 101
92088: PUSH
92089: LD_INT 1
92091: ST_TO_ADDR
// if p3 = 5 then
92092: LD_VAR 0 3
92096: PUSH
92097: LD_INT 5
92099: EQUAL
92100: IFFALSE 92110
// sLevel := true ;
92102: LD_ADDR_EXP 105
92106: PUSH
92107: LD_INT 1
92109: ST_TO_ADDR
// if p3 = 6 then
92110: LD_VAR 0 3
92114: PUSH
92115: LD_INT 6
92117: EQUAL
92118: IFFALSE 92128
// sArmoury := true ;
92120: LD_ADDR_EXP 106
92124: PUSH
92125: LD_INT 1
92127: ST_TO_ADDR
// if p3 = 7 then
92128: LD_VAR 0 3
92132: PUSH
92133: LD_INT 7
92135: EQUAL
92136: IFFALSE 92146
// sRadar := true ;
92138: LD_ADDR_EXP 107
92142: PUSH
92143: LD_INT 1
92145: ST_TO_ADDR
// if p3 = 8 then
92146: LD_VAR 0 3
92150: PUSH
92151: LD_INT 8
92153: EQUAL
92154: IFFALSE 92164
// sBunker := true ;
92156: LD_ADDR_EXP 108
92160: PUSH
92161: LD_INT 1
92163: ST_TO_ADDR
// if p3 = 9 then
92164: LD_VAR 0 3
92168: PUSH
92169: LD_INT 9
92171: EQUAL
92172: IFFALSE 92182
// sHack := true ;
92174: LD_ADDR_EXP 109
92178: PUSH
92179: LD_INT 1
92181: ST_TO_ADDR
// if p3 = 10 then
92182: LD_VAR 0 3
92186: PUSH
92187: LD_INT 10
92189: EQUAL
92190: IFFALSE 92200
// sFire := true ;
92192: LD_ADDR_EXP 110
92196: PUSH
92197: LD_INT 1
92199: ST_TO_ADDR
// if p3 = 11 then
92200: LD_VAR 0 3
92204: PUSH
92205: LD_INT 11
92207: EQUAL
92208: IFFALSE 92218
// sRefresh := true ;
92210: LD_ADDR_EXP 111
92214: PUSH
92215: LD_INT 1
92217: ST_TO_ADDR
// if p3 = 12 then
92218: LD_VAR 0 3
92222: PUSH
92223: LD_INT 12
92225: EQUAL
92226: IFFALSE 92236
// sExp := true ;
92228: LD_ADDR_EXP 112
92232: PUSH
92233: LD_INT 1
92235: ST_TO_ADDR
// if p3 = 13 then
92236: LD_VAR 0 3
92240: PUSH
92241: LD_INT 13
92243: EQUAL
92244: IFFALSE 92254
// sDepot := true ;
92246: LD_ADDR_EXP 113
92250: PUSH
92251: LD_INT 1
92253: ST_TO_ADDR
// if p3 = 14 then
92254: LD_VAR 0 3
92258: PUSH
92259: LD_INT 14
92261: EQUAL
92262: IFFALSE 92272
// sFlag := true ;
92264: LD_ADDR_EXP 114
92268: PUSH
92269: LD_INT 1
92271: ST_TO_ADDR
// if p3 = 15 then
92272: LD_VAR 0 3
92276: PUSH
92277: LD_INT 15
92279: EQUAL
92280: IFFALSE 92290
// sKamikadze := true ;
92282: LD_ADDR_EXP 122
92286: PUSH
92287: LD_INT 1
92289: ST_TO_ADDR
// if p3 = 16 then
92290: LD_VAR 0 3
92294: PUSH
92295: LD_INT 16
92297: EQUAL
92298: IFFALSE 92308
// sTroll := true ;
92300: LD_ADDR_EXP 123
92304: PUSH
92305: LD_INT 1
92307: ST_TO_ADDR
// if p3 = 17 then
92308: LD_VAR 0 3
92312: PUSH
92313: LD_INT 17
92315: EQUAL
92316: IFFALSE 92326
// sSlow := true ;
92318: LD_ADDR_EXP 124
92322: PUSH
92323: LD_INT 1
92325: ST_TO_ADDR
// if p3 = 18 then
92326: LD_VAR 0 3
92330: PUSH
92331: LD_INT 18
92333: EQUAL
92334: IFFALSE 92344
// sLack := true ;
92336: LD_ADDR_EXP 125
92340: PUSH
92341: LD_INT 1
92343: ST_TO_ADDR
// if p3 = 19 then
92344: LD_VAR 0 3
92348: PUSH
92349: LD_INT 19
92351: EQUAL
92352: IFFALSE 92362
// sTank := true ;
92354: LD_ADDR_EXP 127
92358: PUSH
92359: LD_INT 1
92361: ST_TO_ADDR
// if p3 = 20 then
92362: LD_VAR 0 3
92366: PUSH
92367: LD_INT 20
92369: EQUAL
92370: IFFALSE 92380
// sRemote := true ;
92372: LD_ADDR_EXP 128
92376: PUSH
92377: LD_INT 1
92379: ST_TO_ADDR
// if p3 = 21 then
92380: LD_VAR 0 3
92384: PUSH
92385: LD_INT 21
92387: EQUAL
92388: IFFALSE 92398
// sPowell := true ;
92390: LD_ADDR_EXP 129
92394: PUSH
92395: LD_INT 1
92397: ST_TO_ADDR
// if p3 = 22 then
92398: LD_VAR 0 3
92402: PUSH
92403: LD_INT 22
92405: EQUAL
92406: IFFALSE 92416
// sTeleport := true ;
92408: LD_ADDR_EXP 132
92412: PUSH
92413: LD_INT 1
92415: ST_TO_ADDR
// if p3 = 23 then
92416: LD_VAR 0 3
92420: PUSH
92421: LD_INT 23
92423: EQUAL
92424: IFFALSE 92434
// sOilTower := true ;
92426: LD_ADDR_EXP 134
92430: PUSH
92431: LD_INT 1
92433: ST_TO_ADDR
// if p3 = 24 then
92434: LD_VAR 0 3
92438: PUSH
92439: LD_INT 24
92441: EQUAL
92442: IFFALSE 92452
// sShovel := true ;
92444: LD_ADDR_EXP 135
92448: PUSH
92449: LD_INT 1
92451: ST_TO_ADDR
// if p3 = 25 then
92452: LD_VAR 0 3
92456: PUSH
92457: LD_INT 25
92459: EQUAL
92460: IFFALSE 92470
// sSheik := true ;
92462: LD_ADDR_EXP 136
92466: PUSH
92467: LD_INT 1
92469: ST_TO_ADDR
// if p3 = 26 then
92470: LD_VAR 0 3
92474: PUSH
92475: LD_INT 26
92477: EQUAL
92478: IFFALSE 92488
// sEarthquake := true ;
92480: LD_ADDR_EXP 138
92484: PUSH
92485: LD_INT 1
92487: ST_TO_ADDR
// if p3 = 27 then
92488: LD_VAR 0 3
92492: PUSH
92493: LD_INT 27
92495: EQUAL
92496: IFFALSE 92506
// sAI := true ;
92498: LD_ADDR_EXP 139
92502: PUSH
92503: LD_INT 1
92505: ST_TO_ADDR
// if p3 = 28 then
92506: LD_VAR 0 3
92510: PUSH
92511: LD_INT 28
92513: EQUAL
92514: IFFALSE 92524
// sCargo := true ;
92516: LD_ADDR_EXP 142
92520: PUSH
92521: LD_INT 1
92523: ST_TO_ADDR
// if p3 = 29 then
92524: LD_VAR 0 3
92528: PUSH
92529: LD_INT 29
92531: EQUAL
92532: IFFALSE 92542
// sDLaser := true ;
92534: LD_ADDR_EXP 143
92538: PUSH
92539: LD_INT 1
92541: ST_TO_ADDR
// if p3 = 30 then
92542: LD_VAR 0 3
92546: PUSH
92547: LD_INT 30
92549: EQUAL
92550: IFFALSE 92560
// sExchange := true ;
92552: LD_ADDR_EXP 144
92556: PUSH
92557: LD_INT 1
92559: ST_TO_ADDR
// if p3 = 31 then
92560: LD_VAR 0 3
92564: PUSH
92565: LD_INT 31
92567: EQUAL
92568: IFFALSE 92578
// sFac := true ;
92570: LD_ADDR_EXP 145
92574: PUSH
92575: LD_INT 1
92577: ST_TO_ADDR
// if p3 = 32 then
92578: LD_VAR 0 3
92582: PUSH
92583: LD_INT 32
92585: EQUAL
92586: IFFALSE 92596
// sPower := true ;
92588: LD_ADDR_EXP 146
92592: PUSH
92593: LD_INT 1
92595: ST_TO_ADDR
// if p3 = 33 then
92596: LD_VAR 0 3
92600: PUSH
92601: LD_INT 33
92603: EQUAL
92604: IFFALSE 92614
// sRandom := true ;
92606: LD_ADDR_EXP 147
92610: PUSH
92611: LD_INT 1
92613: ST_TO_ADDR
// if p3 = 34 then
92614: LD_VAR 0 3
92618: PUSH
92619: LD_INT 34
92621: EQUAL
92622: IFFALSE 92632
// sShield := true ;
92624: LD_ADDR_EXP 148
92628: PUSH
92629: LD_INT 1
92631: ST_TO_ADDR
// if p3 = 35 then
92632: LD_VAR 0 3
92636: PUSH
92637: LD_INT 35
92639: EQUAL
92640: IFFALSE 92650
// sTime := true ;
92642: LD_ADDR_EXP 149
92646: PUSH
92647: LD_INT 1
92649: ST_TO_ADDR
// if p3 = 36 then
92650: LD_VAR 0 3
92654: PUSH
92655: LD_INT 36
92657: EQUAL
92658: IFFALSE 92668
// sTools := true ;
92660: LD_ADDR_EXP 150
92664: PUSH
92665: LD_INT 1
92667: ST_TO_ADDR
// if p3 = 101 then
92668: LD_VAR 0 3
92672: PUSH
92673: LD_INT 101
92675: EQUAL
92676: IFFALSE 92686
// sSold := true ;
92678: LD_ADDR_EXP 115
92682: PUSH
92683: LD_INT 1
92685: ST_TO_ADDR
// if p3 = 102 then
92686: LD_VAR 0 3
92690: PUSH
92691: LD_INT 102
92693: EQUAL
92694: IFFALSE 92704
// sDiff := true ;
92696: LD_ADDR_EXP 116
92700: PUSH
92701: LD_INT 1
92703: ST_TO_ADDR
// if p3 = 103 then
92704: LD_VAR 0 3
92708: PUSH
92709: LD_INT 103
92711: EQUAL
92712: IFFALSE 92722
// sFog := true ;
92714: LD_ADDR_EXP 119
92718: PUSH
92719: LD_INT 1
92721: ST_TO_ADDR
// if p3 = 104 then
92722: LD_VAR 0 3
92726: PUSH
92727: LD_INT 104
92729: EQUAL
92730: IFFALSE 92740
// sReset := true ;
92732: LD_ADDR_EXP 120
92736: PUSH
92737: LD_INT 1
92739: ST_TO_ADDR
// if p3 = 105 then
92740: LD_VAR 0 3
92744: PUSH
92745: LD_INT 105
92747: EQUAL
92748: IFFALSE 92758
// sSun := true ;
92750: LD_ADDR_EXP 121
92754: PUSH
92755: LD_INT 1
92757: ST_TO_ADDR
// if p3 = 106 then
92758: LD_VAR 0 3
92762: PUSH
92763: LD_INT 106
92765: EQUAL
92766: IFFALSE 92776
// sTiger := true ;
92768: LD_ADDR_EXP 117
92772: PUSH
92773: LD_INT 1
92775: ST_TO_ADDR
// if p3 = 107 then
92776: LD_VAR 0 3
92780: PUSH
92781: LD_INT 107
92783: EQUAL
92784: IFFALSE 92794
// sBomb := true ;
92786: LD_ADDR_EXP 118
92790: PUSH
92791: LD_INT 1
92793: ST_TO_ADDR
// if p3 = 108 then
92794: LD_VAR 0 3
92798: PUSH
92799: LD_INT 108
92801: EQUAL
92802: IFFALSE 92812
// sWound := true ;
92804: LD_ADDR_EXP 126
92808: PUSH
92809: LD_INT 1
92811: ST_TO_ADDR
// if p3 = 109 then
92812: LD_VAR 0 3
92816: PUSH
92817: LD_INT 109
92819: EQUAL
92820: IFFALSE 92830
// sBetray := true ;
92822: LD_ADDR_EXP 130
92826: PUSH
92827: LD_INT 1
92829: ST_TO_ADDR
// if p3 = 110 then
92830: LD_VAR 0 3
92834: PUSH
92835: LD_INT 110
92837: EQUAL
92838: IFFALSE 92848
// sContamin := true ;
92840: LD_ADDR_EXP 131
92844: PUSH
92845: LD_INT 1
92847: ST_TO_ADDR
// if p3 = 111 then
92848: LD_VAR 0 3
92852: PUSH
92853: LD_INT 111
92855: EQUAL
92856: IFFALSE 92866
// sOil := true ;
92858: LD_ADDR_EXP 133
92862: PUSH
92863: LD_INT 1
92865: ST_TO_ADDR
// if p3 = 112 then
92866: LD_VAR 0 3
92870: PUSH
92871: LD_INT 112
92873: EQUAL
92874: IFFALSE 92884
// sStu := true ;
92876: LD_ADDR_EXP 137
92880: PUSH
92881: LD_INT 1
92883: ST_TO_ADDR
// if p3 = 113 then
92884: LD_VAR 0 3
92888: PUSH
92889: LD_INT 113
92891: EQUAL
92892: IFFALSE 92902
// sBazooka := true ;
92894: LD_ADDR_EXP 140
92898: PUSH
92899: LD_INT 1
92901: ST_TO_ADDR
// if p3 = 114 then
92902: LD_VAR 0 3
92906: PUSH
92907: LD_INT 114
92909: EQUAL
92910: IFFALSE 92920
// sMortar := true ;
92912: LD_ADDR_EXP 141
92916: PUSH
92917: LD_INT 1
92919: ST_TO_ADDR
// if p3 = 115 then
92920: LD_VAR 0 3
92924: PUSH
92925: LD_INT 115
92927: EQUAL
92928: IFFALSE 92938
// sRanger := true ;
92930: LD_ADDR_EXP 151
92934: PUSH
92935: LD_INT 1
92937: ST_TO_ADDR
// end ; if p2 = 101 then
92938: LD_VAR 0 2
92942: PUSH
92943: LD_INT 101
92945: EQUAL
92946: IFFALSE 93074
// begin case p3 of 1 :
92948: LD_VAR 0 3
92952: PUSH
92953: LD_INT 1
92955: DOUBLE
92956: EQUAL
92957: IFTRUE 92961
92959: GO 92968
92961: POP
// hHackUnlimitedResources ; 2 :
92962: CALL 104111 0 0
92966: GO 93074
92968: LD_INT 2
92970: DOUBLE
92971: EQUAL
92972: IFTRUE 92976
92974: GO 92983
92976: POP
// hHackSetLevel10 ; 3 :
92977: CALL 104244 0 0
92981: GO 93074
92983: LD_INT 3
92985: DOUBLE
92986: EQUAL
92987: IFTRUE 92991
92989: GO 92998
92991: POP
// hHackSetLevel10YourUnits ; 4 :
92992: CALL 104329 0 0
92996: GO 93074
92998: LD_INT 4
93000: DOUBLE
93001: EQUAL
93002: IFTRUE 93006
93004: GO 93013
93006: POP
// hHackInvincible ; 5 :
93007: CALL 104777 0 0
93011: GO 93074
93013: LD_INT 5
93015: DOUBLE
93016: EQUAL
93017: IFTRUE 93021
93019: GO 93028
93021: POP
// hHackInvisible ; 6 :
93022: CALL 104888 0 0
93026: GO 93074
93028: LD_INT 6
93030: DOUBLE
93031: EQUAL
93032: IFTRUE 93036
93034: GO 93043
93036: POP
// hHackChangeYourSide ; 7 :
93037: CALL 104945 0 0
93041: GO 93074
93043: LD_INT 7
93045: DOUBLE
93046: EQUAL
93047: IFTRUE 93051
93049: GO 93058
93051: POP
// hHackChangeUnitSide ; 8 :
93052: CALL 104987 0 0
93056: GO 93074
93058: LD_INT 8
93060: DOUBLE
93061: EQUAL
93062: IFTRUE 93066
93064: GO 93073
93066: POP
// hHackFog ; end ;
93067: CALL 105088 0 0
93071: GO 93074
93073: POP
// end ; end ;
93074: LD_VAR 0 7
93078: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
93079: GO 93081
93081: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93082: LD_STRING initStreamRollete();
93084: PPUSH
93085: CALL_OW 559
// InitStreamMode ;
93089: CALL 93098 0 0
// DefineStreamItems ( ) ;
93093: CALL 93538 0 0
// end ;
93097: END
// function InitStreamMode ; begin
93098: LD_INT 0
93100: PPUSH
// streamModeActive := false ;
93101: LD_ADDR_EXP 98
93105: PUSH
93106: LD_INT 0
93108: ST_TO_ADDR
// normalCounter := 36 ;
93109: LD_ADDR_EXP 99
93113: PUSH
93114: LD_INT 36
93116: ST_TO_ADDR
// hardcoreCounter := 16 ;
93117: LD_ADDR_EXP 100
93121: PUSH
93122: LD_INT 16
93124: ST_TO_ADDR
// sRocket := false ;
93125: LD_ADDR_EXP 103
93129: PUSH
93130: LD_INT 0
93132: ST_TO_ADDR
// sSpeed := false ;
93133: LD_ADDR_EXP 102
93137: PUSH
93138: LD_INT 0
93140: ST_TO_ADDR
// sEngine := false ;
93141: LD_ADDR_EXP 104
93145: PUSH
93146: LD_INT 0
93148: ST_TO_ADDR
// sSpec := false ;
93149: LD_ADDR_EXP 101
93153: PUSH
93154: LD_INT 0
93156: ST_TO_ADDR
// sLevel := false ;
93157: LD_ADDR_EXP 105
93161: PUSH
93162: LD_INT 0
93164: ST_TO_ADDR
// sArmoury := false ;
93165: LD_ADDR_EXP 106
93169: PUSH
93170: LD_INT 0
93172: ST_TO_ADDR
// sRadar := false ;
93173: LD_ADDR_EXP 107
93177: PUSH
93178: LD_INT 0
93180: ST_TO_ADDR
// sBunker := false ;
93181: LD_ADDR_EXP 108
93185: PUSH
93186: LD_INT 0
93188: ST_TO_ADDR
// sHack := false ;
93189: LD_ADDR_EXP 109
93193: PUSH
93194: LD_INT 0
93196: ST_TO_ADDR
// sFire := false ;
93197: LD_ADDR_EXP 110
93201: PUSH
93202: LD_INT 0
93204: ST_TO_ADDR
// sRefresh := false ;
93205: LD_ADDR_EXP 111
93209: PUSH
93210: LD_INT 0
93212: ST_TO_ADDR
// sExp := false ;
93213: LD_ADDR_EXP 112
93217: PUSH
93218: LD_INT 0
93220: ST_TO_ADDR
// sDepot := false ;
93221: LD_ADDR_EXP 113
93225: PUSH
93226: LD_INT 0
93228: ST_TO_ADDR
// sFlag := false ;
93229: LD_ADDR_EXP 114
93233: PUSH
93234: LD_INT 0
93236: ST_TO_ADDR
// sKamikadze := false ;
93237: LD_ADDR_EXP 122
93241: PUSH
93242: LD_INT 0
93244: ST_TO_ADDR
// sTroll := false ;
93245: LD_ADDR_EXP 123
93249: PUSH
93250: LD_INT 0
93252: ST_TO_ADDR
// sSlow := false ;
93253: LD_ADDR_EXP 124
93257: PUSH
93258: LD_INT 0
93260: ST_TO_ADDR
// sLack := false ;
93261: LD_ADDR_EXP 125
93265: PUSH
93266: LD_INT 0
93268: ST_TO_ADDR
// sTank := false ;
93269: LD_ADDR_EXP 127
93273: PUSH
93274: LD_INT 0
93276: ST_TO_ADDR
// sRemote := false ;
93277: LD_ADDR_EXP 128
93281: PUSH
93282: LD_INT 0
93284: ST_TO_ADDR
// sPowell := false ;
93285: LD_ADDR_EXP 129
93289: PUSH
93290: LD_INT 0
93292: ST_TO_ADDR
// sTeleport := false ;
93293: LD_ADDR_EXP 132
93297: PUSH
93298: LD_INT 0
93300: ST_TO_ADDR
// sOilTower := false ;
93301: LD_ADDR_EXP 134
93305: PUSH
93306: LD_INT 0
93308: ST_TO_ADDR
// sShovel := false ;
93309: LD_ADDR_EXP 135
93313: PUSH
93314: LD_INT 0
93316: ST_TO_ADDR
// sSheik := false ;
93317: LD_ADDR_EXP 136
93321: PUSH
93322: LD_INT 0
93324: ST_TO_ADDR
// sEarthquake := false ;
93325: LD_ADDR_EXP 138
93329: PUSH
93330: LD_INT 0
93332: ST_TO_ADDR
// sAI := false ;
93333: LD_ADDR_EXP 139
93337: PUSH
93338: LD_INT 0
93340: ST_TO_ADDR
// sCargo := false ;
93341: LD_ADDR_EXP 142
93345: PUSH
93346: LD_INT 0
93348: ST_TO_ADDR
// sDLaser := false ;
93349: LD_ADDR_EXP 143
93353: PUSH
93354: LD_INT 0
93356: ST_TO_ADDR
// sExchange := false ;
93357: LD_ADDR_EXP 144
93361: PUSH
93362: LD_INT 0
93364: ST_TO_ADDR
// sFac := false ;
93365: LD_ADDR_EXP 145
93369: PUSH
93370: LD_INT 0
93372: ST_TO_ADDR
// sPower := false ;
93373: LD_ADDR_EXP 146
93377: PUSH
93378: LD_INT 0
93380: ST_TO_ADDR
// sRandom := false ;
93381: LD_ADDR_EXP 147
93385: PUSH
93386: LD_INT 0
93388: ST_TO_ADDR
// sShield := false ;
93389: LD_ADDR_EXP 148
93393: PUSH
93394: LD_INT 0
93396: ST_TO_ADDR
// sTime := false ;
93397: LD_ADDR_EXP 149
93401: PUSH
93402: LD_INT 0
93404: ST_TO_ADDR
// sTools := false ;
93405: LD_ADDR_EXP 150
93409: PUSH
93410: LD_INT 0
93412: ST_TO_ADDR
// sSold := false ;
93413: LD_ADDR_EXP 115
93417: PUSH
93418: LD_INT 0
93420: ST_TO_ADDR
// sDiff := false ;
93421: LD_ADDR_EXP 116
93425: PUSH
93426: LD_INT 0
93428: ST_TO_ADDR
// sFog := false ;
93429: LD_ADDR_EXP 119
93433: PUSH
93434: LD_INT 0
93436: ST_TO_ADDR
// sReset := false ;
93437: LD_ADDR_EXP 120
93441: PUSH
93442: LD_INT 0
93444: ST_TO_ADDR
// sSun := false ;
93445: LD_ADDR_EXP 121
93449: PUSH
93450: LD_INT 0
93452: ST_TO_ADDR
// sTiger := false ;
93453: LD_ADDR_EXP 117
93457: PUSH
93458: LD_INT 0
93460: ST_TO_ADDR
// sBomb := false ;
93461: LD_ADDR_EXP 118
93465: PUSH
93466: LD_INT 0
93468: ST_TO_ADDR
// sWound := false ;
93469: LD_ADDR_EXP 126
93473: PUSH
93474: LD_INT 0
93476: ST_TO_ADDR
// sBetray := false ;
93477: LD_ADDR_EXP 130
93481: PUSH
93482: LD_INT 0
93484: ST_TO_ADDR
// sContamin := false ;
93485: LD_ADDR_EXP 131
93489: PUSH
93490: LD_INT 0
93492: ST_TO_ADDR
// sOil := false ;
93493: LD_ADDR_EXP 133
93497: PUSH
93498: LD_INT 0
93500: ST_TO_ADDR
// sStu := false ;
93501: LD_ADDR_EXP 137
93505: PUSH
93506: LD_INT 0
93508: ST_TO_ADDR
// sBazooka := false ;
93509: LD_ADDR_EXP 140
93513: PUSH
93514: LD_INT 0
93516: ST_TO_ADDR
// sMortar := false ;
93517: LD_ADDR_EXP 141
93521: PUSH
93522: LD_INT 0
93524: ST_TO_ADDR
// sRanger := false ;
93525: LD_ADDR_EXP 151
93529: PUSH
93530: LD_INT 0
93532: ST_TO_ADDR
// end ;
93533: LD_VAR 0 1
93537: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
93538: LD_INT 0
93540: PPUSH
93541: PPUSH
93542: PPUSH
93543: PPUSH
93544: PPUSH
// result := [ ] ;
93545: LD_ADDR_VAR 0 1
93549: PUSH
93550: EMPTY
93551: ST_TO_ADDR
// if campaign_id = 1 then
93552: LD_OWVAR 69
93556: PUSH
93557: LD_INT 1
93559: EQUAL
93560: IFFALSE 96498
// begin case mission_number of 1 :
93562: LD_OWVAR 70
93566: PUSH
93567: LD_INT 1
93569: DOUBLE
93570: EQUAL
93571: IFTRUE 93575
93573: GO 93639
93575: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
93576: LD_ADDR_VAR 0 1
93580: PUSH
93581: LD_INT 2
93583: PUSH
93584: LD_INT 4
93586: PUSH
93587: LD_INT 11
93589: PUSH
93590: LD_INT 12
93592: PUSH
93593: LD_INT 15
93595: PUSH
93596: LD_INT 16
93598: PUSH
93599: LD_INT 22
93601: PUSH
93602: LD_INT 23
93604: PUSH
93605: LD_INT 26
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 101
93621: PUSH
93622: LD_INT 102
93624: PUSH
93625: LD_INT 106
93627: PUSH
93628: EMPTY
93629: LIST
93630: LIST
93631: LIST
93632: PUSH
93633: EMPTY
93634: LIST
93635: LIST
93636: ST_TO_ADDR
93637: GO 96496
93639: LD_INT 2
93641: DOUBLE
93642: EQUAL
93643: IFTRUE 93647
93645: GO 93719
93647: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
93648: LD_ADDR_VAR 0 1
93652: PUSH
93653: LD_INT 2
93655: PUSH
93656: LD_INT 4
93658: PUSH
93659: LD_INT 11
93661: PUSH
93662: LD_INT 12
93664: PUSH
93665: LD_INT 15
93667: PUSH
93668: LD_INT 16
93670: PUSH
93671: LD_INT 22
93673: PUSH
93674: LD_INT 23
93676: PUSH
93677: LD_INT 26
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: PUSH
93691: LD_INT 101
93693: PUSH
93694: LD_INT 102
93696: PUSH
93697: LD_INT 105
93699: PUSH
93700: LD_INT 106
93702: PUSH
93703: LD_INT 108
93705: PUSH
93706: EMPTY
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: ST_TO_ADDR
93717: GO 96496
93719: LD_INT 3
93721: DOUBLE
93722: EQUAL
93723: IFTRUE 93727
93725: GO 93803
93727: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
93728: LD_ADDR_VAR 0 1
93732: PUSH
93733: LD_INT 2
93735: PUSH
93736: LD_INT 4
93738: PUSH
93739: LD_INT 5
93741: PUSH
93742: LD_INT 11
93744: PUSH
93745: LD_INT 12
93747: PUSH
93748: LD_INT 15
93750: PUSH
93751: LD_INT 16
93753: PUSH
93754: LD_INT 22
93756: PUSH
93757: LD_INT 26
93759: PUSH
93760: LD_INT 36
93762: PUSH
93763: EMPTY
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: PUSH
93775: LD_INT 101
93777: PUSH
93778: LD_INT 102
93780: PUSH
93781: LD_INT 105
93783: PUSH
93784: LD_INT 106
93786: PUSH
93787: LD_INT 108
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: ST_TO_ADDR
93801: GO 96496
93803: LD_INT 4
93805: DOUBLE
93806: EQUAL
93807: IFTRUE 93811
93809: GO 93895
93811: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
93812: LD_ADDR_VAR 0 1
93816: PUSH
93817: LD_INT 2
93819: PUSH
93820: LD_INT 4
93822: PUSH
93823: LD_INT 5
93825: PUSH
93826: LD_INT 8
93828: PUSH
93829: LD_INT 11
93831: PUSH
93832: LD_INT 12
93834: PUSH
93835: LD_INT 15
93837: PUSH
93838: LD_INT 16
93840: PUSH
93841: LD_INT 22
93843: PUSH
93844: LD_INT 23
93846: PUSH
93847: LD_INT 26
93849: PUSH
93850: LD_INT 36
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: LIST
93857: LIST
93858: LIST
93859: LIST
93860: LIST
93861: LIST
93862: LIST
93863: LIST
93864: LIST
93865: LIST
93866: PUSH
93867: LD_INT 101
93869: PUSH
93870: LD_INT 102
93872: PUSH
93873: LD_INT 105
93875: PUSH
93876: LD_INT 106
93878: PUSH
93879: LD_INT 108
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: ST_TO_ADDR
93893: GO 96496
93895: LD_INT 5
93897: DOUBLE
93898: EQUAL
93899: IFTRUE 93903
93901: GO 94003
93903: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
93904: LD_ADDR_VAR 0 1
93908: PUSH
93909: LD_INT 2
93911: PUSH
93912: LD_INT 4
93914: PUSH
93915: LD_INT 5
93917: PUSH
93918: LD_INT 6
93920: PUSH
93921: LD_INT 8
93923: PUSH
93924: LD_INT 11
93926: PUSH
93927: LD_INT 12
93929: PUSH
93930: LD_INT 15
93932: PUSH
93933: LD_INT 16
93935: PUSH
93936: LD_INT 22
93938: PUSH
93939: LD_INT 23
93941: PUSH
93942: LD_INT 25
93944: PUSH
93945: LD_INT 26
93947: PUSH
93948: LD_INT 36
93950: PUSH
93951: EMPTY
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: PUSH
93967: LD_INT 101
93969: PUSH
93970: LD_INT 102
93972: PUSH
93973: LD_INT 105
93975: PUSH
93976: LD_INT 106
93978: PUSH
93979: LD_INT 108
93981: PUSH
93982: LD_INT 109
93984: PUSH
93985: LD_INT 112
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: PUSH
93997: EMPTY
93998: LIST
93999: LIST
94000: ST_TO_ADDR
94001: GO 96496
94003: LD_INT 6
94005: DOUBLE
94006: EQUAL
94007: IFTRUE 94011
94009: GO 94131
94011: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
94012: LD_ADDR_VAR 0 1
94016: PUSH
94017: LD_INT 2
94019: PUSH
94020: LD_INT 4
94022: PUSH
94023: LD_INT 5
94025: PUSH
94026: LD_INT 6
94028: PUSH
94029: LD_INT 8
94031: PUSH
94032: LD_INT 11
94034: PUSH
94035: LD_INT 12
94037: PUSH
94038: LD_INT 15
94040: PUSH
94041: LD_INT 16
94043: PUSH
94044: LD_INT 20
94046: PUSH
94047: LD_INT 21
94049: PUSH
94050: LD_INT 22
94052: PUSH
94053: LD_INT 23
94055: PUSH
94056: LD_INT 25
94058: PUSH
94059: LD_INT 26
94061: PUSH
94062: LD_INT 30
94064: PUSH
94065: LD_INT 31
94067: PUSH
94068: LD_INT 32
94070: PUSH
94071: LD_INT 36
94073: PUSH
94074: EMPTY
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 101
94097: PUSH
94098: LD_INT 102
94100: PUSH
94101: LD_INT 105
94103: PUSH
94104: LD_INT 106
94106: PUSH
94107: LD_INT 108
94109: PUSH
94110: LD_INT 109
94112: PUSH
94113: LD_INT 112
94115: PUSH
94116: EMPTY
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: ST_TO_ADDR
94129: GO 96496
94131: LD_INT 7
94133: DOUBLE
94134: EQUAL
94135: IFTRUE 94139
94137: GO 94239
94139: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
94140: LD_ADDR_VAR 0 1
94144: PUSH
94145: LD_INT 2
94147: PUSH
94148: LD_INT 4
94150: PUSH
94151: LD_INT 5
94153: PUSH
94154: LD_INT 7
94156: PUSH
94157: LD_INT 11
94159: PUSH
94160: LD_INT 12
94162: PUSH
94163: LD_INT 15
94165: PUSH
94166: LD_INT 16
94168: PUSH
94169: LD_INT 20
94171: PUSH
94172: LD_INT 21
94174: PUSH
94175: LD_INT 22
94177: PUSH
94178: LD_INT 23
94180: PUSH
94181: LD_INT 25
94183: PUSH
94184: LD_INT 26
94186: PUSH
94187: EMPTY
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 101
94205: PUSH
94206: LD_INT 102
94208: PUSH
94209: LD_INT 103
94211: PUSH
94212: LD_INT 105
94214: PUSH
94215: LD_INT 106
94217: PUSH
94218: LD_INT 108
94220: PUSH
94221: LD_INT 112
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: LIST
94228: LIST
94229: LIST
94230: LIST
94231: LIST
94232: PUSH
94233: EMPTY
94234: LIST
94235: LIST
94236: ST_TO_ADDR
94237: GO 96496
94239: LD_INT 8
94241: DOUBLE
94242: EQUAL
94243: IFTRUE 94247
94245: GO 94375
94247: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
94248: LD_ADDR_VAR 0 1
94252: PUSH
94253: LD_INT 2
94255: PUSH
94256: LD_INT 4
94258: PUSH
94259: LD_INT 5
94261: PUSH
94262: LD_INT 6
94264: PUSH
94265: LD_INT 7
94267: PUSH
94268: LD_INT 8
94270: PUSH
94271: LD_INT 11
94273: PUSH
94274: LD_INT 12
94276: PUSH
94277: LD_INT 15
94279: PUSH
94280: LD_INT 16
94282: PUSH
94283: LD_INT 20
94285: PUSH
94286: LD_INT 21
94288: PUSH
94289: LD_INT 22
94291: PUSH
94292: LD_INT 23
94294: PUSH
94295: LD_INT 25
94297: PUSH
94298: LD_INT 26
94300: PUSH
94301: LD_INT 30
94303: PUSH
94304: LD_INT 31
94306: PUSH
94307: LD_INT 32
94309: PUSH
94310: LD_INT 36
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: LIST
94317: LIST
94318: LIST
94319: LIST
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: PUSH
94335: LD_INT 101
94337: PUSH
94338: LD_INT 102
94340: PUSH
94341: LD_INT 103
94343: PUSH
94344: LD_INT 105
94346: PUSH
94347: LD_INT 106
94349: PUSH
94350: LD_INT 108
94352: PUSH
94353: LD_INT 109
94355: PUSH
94356: LD_INT 112
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: ST_TO_ADDR
94373: GO 96496
94375: LD_INT 9
94377: DOUBLE
94378: EQUAL
94379: IFTRUE 94383
94381: GO 94519
94383: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
94384: LD_ADDR_VAR 0 1
94388: PUSH
94389: LD_INT 2
94391: PUSH
94392: LD_INT 4
94394: PUSH
94395: LD_INT 5
94397: PUSH
94398: LD_INT 6
94400: PUSH
94401: LD_INT 7
94403: PUSH
94404: LD_INT 8
94406: PUSH
94407: LD_INT 11
94409: PUSH
94410: LD_INT 12
94412: PUSH
94413: LD_INT 15
94415: PUSH
94416: LD_INT 16
94418: PUSH
94419: LD_INT 20
94421: PUSH
94422: LD_INT 21
94424: PUSH
94425: LD_INT 22
94427: PUSH
94428: LD_INT 23
94430: PUSH
94431: LD_INT 25
94433: PUSH
94434: LD_INT 26
94436: PUSH
94437: LD_INT 28
94439: PUSH
94440: LD_INT 30
94442: PUSH
94443: LD_INT 31
94445: PUSH
94446: LD_INT 32
94448: PUSH
94449: LD_INT 36
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: LIST
94456: LIST
94457: LIST
94458: LIST
94459: LIST
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: PUSH
94475: LD_INT 101
94477: PUSH
94478: LD_INT 102
94480: PUSH
94481: LD_INT 103
94483: PUSH
94484: LD_INT 105
94486: PUSH
94487: LD_INT 106
94489: PUSH
94490: LD_INT 108
94492: PUSH
94493: LD_INT 109
94495: PUSH
94496: LD_INT 112
94498: PUSH
94499: LD_INT 114
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: ST_TO_ADDR
94517: GO 96496
94519: LD_INT 10
94521: DOUBLE
94522: EQUAL
94523: IFTRUE 94527
94525: GO 94711
94527: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
94528: LD_ADDR_VAR 0 1
94532: PUSH
94533: LD_INT 2
94535: PUSH
94536: LD_INT 4
94538: PUSH
94539: LD_INT 5
94541: PUSH
94542: LD_INT 6
94544: PUSH
94545: LD_INT 7
94547: PUSH
94548: LD_INT 8
94550: PUSH
94551: LD_INT 9
94553: PUSH
94554: LD_INT 10
94556: PUSH
94557: LD_INT 11
94559: PUSH
94560: LD_INT 12
94562: PUSH
94563: LD_INT 13
94565: PUSH
94566: LD_INT 14
94568: PUSH
94569: LD_INT 15
94571: PUSH
94572: LD_INT 16
94574: PUSH
94575: LD_INT 17
94577: PUSH
94578: LD_INT 18
94580: PUSH
94581: LD_INT 19
94583: PUSH
94584: LD_INT 20
94586: PUSH
94587: LD_INT 21
94589: PUSH
94590: LD_INT 22
94592: PUSH
94593: LD_INT 23
94595: PUSH
94596: LD_INT 24
94598: PUSH
94599: LD_INT 25
94601: PUSH
94602: LD_INT 26
94604: PUSH
94605: LD_INT 28
94607: PUSH
94608: LD_INT 30
94610: PUSH
94611: LD_INT 31
94613: PUSH
94614: LD_INT 32
94616: PUSH
94617: LD_INT 36
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: LIST
94635: LIST
94636: LIST
94637: LIST
94638: LIST
94639: LIST
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 101
94653: PUSH
94654: LD_INT 102
94656: PUSH
94657: LD_INT 103
94659: PUSH
94660: LD_INT 104
94662: PUSH
94663: LD_INT 105
94665: PUSH
94666: LD_INT 106
94668: PUSH
94669: LD_INT 107
94671: PUSH
94672: LD_INT 108
94674: PUSH
94675: LD_INT 109
94677: PUSH
94678: LD_INT 110
94680: PUSH
94681: LD_INT 111
94683: PUSH
94684: LD_INT 112
94686: PUSH
94687: LD_INT 114
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: PUSH
94705: EMPTY
94706: LIST
94707: LIST
94708: ST_TO_ADDR
94709: GO 96496
94711: LD_INT 11
94713: DOUBLE
94714: EQUAL
94715: IFTRUE 94719
94717: GO 94911
94719: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
94720: LD_ADDR_VAR 0 1
94724: PUSH
94725: LD_INT 2
94727: PUSH
94728: LD_INT 3
94730: PUSH
94731: LD_INT 4
94733: PUSH
94734: LD_INT 5
94736: PUSH
94737: LD_INT 6
94739: PUSH
94740: LD_INT 7
94742: PUSH
94743: LD_INT 8
94745: PUSH
94746: LD_INT 9
94748: PUSH
94749: LD_INT 10
94751: PUSH
94752: LD_INT 11
94754: PUSH
94755: LD_INT 12
94757: PUSH
94758: LD_INT 13
94760: PUSH
94761: LD_INT 14
94763: PUSH
94764: LD_INT 15
94766: PUSH
94767: LD_INT 16
94769: PUSH
94770: LD_INT 17
94772: PUSH
94773: LD_INT 18
94775: PUSH
94776: LD_INT 19
94778: PUSH
94779: LD_INT 20
94781: PUSH
94782: LD_INT 21
94784: PUSH
94785: LD_INT 22
94787: PUSH
94788: LD_INT 23
94790: PUSH
94791: LD_INT 24
94793: PUSH
94794: LD_INT 25
94796: PUSH
94797: LD_INT 26
94799: PUSH
94800: LD_INT 28
94802: PUSH
94803: LD_INT 30
94805: PUSH
94806: LD_INT 31
94808: PUSH
94809: LD_INT 32
94811: PUSH
94812: LD_INT 34
94814: PUSH
94815: LD_INT 36
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: PUSH
94851: LD_INT 101
94853: PUSH
94854: LD_INT 102
94856: PUSH
94857: LD_INT 103
94859: PUSH
94860: LD_INT 104
94862: PUSH
94863: LD_INT 105
94865: PUSH
94866: LD_INT 106
94868: PUSH
94869: LD_INT 107
94871: PUSH
94872: LD_INT 108
94874: PUSH
94875: LD_INT 109
94877: PUSH
94878: LD_INT 110
94880: PUSH
94881: LD_INT 111
94883: PUSH
94884: LD_INT 112
94886: PUSH
94887: LD_INT 114
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: ST_TO_ADDR
94909: GO 96496
94911: LD_INT 12
94913: DOUBLE
94914: EQUAL
94915: IFTRUE 94919
94917: GO 95127
94919: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
94920: LD_ADDR_VAR 0 1
94924: PUSH
94925: LD_INT 1
94927: PUSH
94928: LD_INT 2
94930: PUSH
94931: LD_INT 3
94933: PUSH
94934: LD_INT 4
94936: PUSH
94937: LD_INT 5
94939: PUSH
94940: LD_INT 6
94942: PUSH
94943: LD_INT 7
94945: PUSH
94946: LD_INT 8
94948: PUSH
94949: LD_INT 9
94951: PUSH
94952: LD_INT 10
94954: PUSH
94955: LD_INT 11
94957: PUSH
94958: LD_INT 12
94960: PUSH
94961: LD_INT 13
94963: PUSH
94964: LD_INT 14
94966: PUSH
94967: LD_INT 15
94969: PUSH
94970: LD_INT 16
94972: PUSH
94973: LD_INT 17
94975: PUSH
94976: LD_INT 18
94978: PUSH
94979: LD_INT 19
94981: PUSH
94982: LD_INT 20
94984: PUSH
94985: LD_INT 21
94987: PUSH
94988: LD_INT 22
94990: PUSH
94991: LD_INT 23
94993: PUSH
94994: LD_INT 24
94996: PUSH
94997: LD_INT 25
94999: PUSH
95000: LD_INT 26
95002: PUSH
95003: LD_INT 27
95005: PUSH
95006: LD_INT 28
95008: PUSH
95009: LD_INT 30
95011: PUSH
95012: LD_INT 31
95014: PUSH
95015: LD_INT 32
95017: PUSH
95018: LD_INT 33
95020: PUSH
95021: LD_INT 34
95023: PUSH
95024: LD_INT 36
95026: PUSH
95027: EMPTY
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: PUSH
95063: LD_INT 101
95065: PUSH
95066: LD_INT 102
95068: PUSH
95069: LD_INT 103
95071: PUSH
95072: LD_INT 104
95074: PUSH
95075: LD_INT 105
95077: PUSH
95078: LD_INT 106
95080: PUSH
95081: LD_INT 107
95083: PUSH
95084: LD_INT 108
95086: PUSH
95087: LD_INT 109
95089: PUSH
95090: LD_INT 110
95092: PUSH
95093: LD_INT 111
95095: PUSH
95096: LD_INT 112
95098: PUSH
95099: LD_INT 113
95101: PUSH
95102: LD_INT 114
95104: PUSH
95105: EMPTY
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: PUSH
95121: EMPTY
95122: LIST
95123: LIST
95124: ST_TO_ADDR
95125: GO 96496
95127: LD_INT 13
95129: DOUBLE
95130: EQUAL
95131: IFTRUE 95135
95133: GO 95331
95135: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
95136: LD_ADDR_VAR 0 1
95140: PUSH
95141: LD_INT 1
95143: PUSH
95144: LD_INT 2
95146: PUSH
95147: LD_INT 3
95149: PUSH
95150: LD_INT 4
95152: PUSH
95153: LD_INT 5
95155: PUSH
95156: LD_INT 8
95158: PUSH
95159: LD_INT 9
95161: PUSH
95162: LD_INT 10
95164: PUSH
95165: LD_INT 11
95167: PUSH
95168: LD_INT 12
95170: PUSH
95171: LD_INT 14
95173: PUSH
95174: LD_INT 15
95176: PUSH
95177: LD_INT 16
95179: PUSH
95180: LD_INT 17
95182: PUSH
95183: LD_INT 18
95185: PUSH
95186: LD_INT 19
95188: PUSH
95189: LD_INT 20
95191: PUSH
95192: LD_INT 21
95194: PUSH
95195: LD_INT 22
95197: PUSH
95198: LD_INT 23
95200: PUSH
95201: LD_INT 24
95203: PUSH
95204: LD_INT 25
95206: PUSH
95207: LD_INT 26
95209: PUSH
95210: LD_INT 27
95212: PUSH
95213: LD_INT 28
95215: PUSH
95216: LD_INT 30
95218: PUSH
95219: LD_INT 31
95221: PUSH
95222: LD_INT 32
95224: PUSH
95225: LD_INT 33
95227: PUSH
95228: LD_INT 34
95230: PUSH
95231: LD_INT 36
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 101
95269: PUSH
95270: LD_INT 102
95272: PUSH
95273: LD_INT 103
95275: PUSH
95276: LD_INT 104
95278: PUSH
95279: LD_INT 105
95281: PUSH
95282: LD_INT 106
95284: PUSH
95285: LD_INT 107
95287: PUSH
95288: LD_INT 108
95290: PUSH
95291: LD_INT 109
95293: PUSH
95294: LD_INT 110
95296: PUSH
95297: LD_INT 111
95299: PUSH
95300: LD_INT 112
95302: PUSH
95303: LD_INT 113
95305: PUSH
95306: LD_INT 114
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: ST_TO_ADDR
95329: GO 96496
95331: LD_INT 14
95333: DOUBLE
95334: EQUAL
95335: IFTRUE 95339
95337: GO 95551
95339: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
95340: LD_ADDR_VAR 0 1
95344: PUSH
95345: LD_INT 1
95347: PUSH
95348: LD_INT 2
95350: PUSH
95351: LD_INT 3
95353: PUSH
95354: LD_INT 4
95356: PUSH
95357: LD_INT 5
95359: PUSH
95360: LD_INT 6
95362: PUSH
95363: LD_INT 7
95365: PUSH
95366: LD_INT 8
95368: PUSH
95369: LD_INT 9
95371: PUSH
95372: LD_INT 10
95374: PUSH
95375: LD_INT 11
95377: PUSH
95378: LD_INT 12
95380: PUSH
95381: LD_INT 13
95383: PUSH
95384: LD_INT 14
95386: PUSH
95387: LD_INT 15
95389: PUSH
95390: LD_INT 16
95392: PUSH
95393: LD_INT 17
95395: PUSH
95396: LD_INT 18
95398: PUSH
95399: LD_INT 19
95401: PUSH
95402: LD_INT 20
95404: PUSH
95405: LD_INT 21
95407: PUSH
95408: LD_INT 22
95410: PUSH
95411: LD_INT 23
95413: PUSH
95414: LD_INT 24
95416: PUSH
95417: LD_INT 25
95419: PUSH
95420: LD_INT 26
95422: PUSH
95423: LD_INT 27
95425: PUSH
95426: LD_INT 28
95428: PUSH
95429: LD_INT 29
95431: PUSH
95432: LD_INT 30
95434: PUSH
95435: LD_INT 31
95437: PUSH
95438: LD_INT 32
95440: PUSH
95441: LD_INT 33
95443: PUSH
95444: LD_INT 34
95446: PUSH
95447: LD_INT 36
95449: PUSH
95450: EMPTY
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: PUSH
95487: LD_INT 101
95489: PUSH
95490: LD_INT 102
95492: PUSH
95493: LD_INT 103
95495: PUSH
95496: LD_INT 104
95498: PUSH
95499: LD_INT 105
95501: PUSH
95502: LD_INT 106
95504: PUSH
95505: LD_INT 107
95507: PUSH
95508: LD_INT 108
95510: PUSH
95511: LD_INT 109
95513: PUSH
95514: LD_INT 110
95516: PUSH
95517: LD_INT 111
95519: PUSH
95520: LD_INT 112
95522: PUSH
95523: LD_INT 113
95525: PUSH
95526: LD_INT 114
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: ST_TO_ADDR
95549: GO 96496
95551: LD_INT 15
95553: DOUBLE
95554: EQUAL
95555: IFTRUE 95559
95557: GO 95771
95559: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
95560: LD_ADDR_VAR 0 1
95564: PUSH
95565: LD_INT 1
95567: PUSH
95568: LD_INT 2
95570: PUSH
95571: LD_INT 3
95573: PUSH
95574: LD_INT 4
95576: PUSH
95577: LD_INT 5
95579: PUSH
95580: LD_INT 6
95582: PUSH
95583: LD_INT 7
95585: PUSH
95586: LD_INT 8
95588: PUSH
95589: LD_INT 9
95591: PUSH
95592: LD_INT 10
95594: PUSH
95595: LD_INT 11
95597: PUSH
95598: LD_INT 12
95600: PUSH
95601: LD_INT 13
95603: PUSH
95604: LD_INT 14
95606: PUSH
95607: LD_INT 15
95609: PUSH
95610: LD_INT 16
95612: PUSH
95613: LD_INT 17
95615: PUSH
95616: LD_INT 18
95618: PUSH
95619: LD_INT 19
95621: PUSH
95622: LD_INT 20
95624: PUSH
95625: LD_INT 21
95627: PUSH
95628: LD_INT 22
95630: PUSH
95631: LD_INT 23
95633: PUSH
95634: LD_INT 24
95636: PUSH
95637: LD_INT 25
95639: PUSH
95640: LD_INT 26
95642: PUSH
95643: LD_INT 27
95645: PUSH
95646: LD_INT 28
95648: PUSH
95649: LD_INT 29
95651: PUSH
95652: LD_INT 30
95654: PUSH
95655: LD_INT 31
95657: PUSH
95658: LD_INT 32
95660: PUSH
95661: LD_INT 33
95663: PUSH
95664: LD_INT 34
95666: PUSH
95667: LD_INT 36
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: PUSH
95707: LD_INT 101
95709: PUSH
95710: LD_INT 102
95712: PUSH
95713: LD_INT 103
95715: PUSH
95716: LD_INT 104
95718: PUSH
95719: LD_INT 105
95721: PUSH
95722: LD_INT 106
95724: PUSH
95725: LD_INT 107
95727: PUSH
95728: LD_INT 108
95730: PUSH
95731: LD_INT 109
95733: PUSH
95734: LD_INT 110
95736: PUSH
95737: LD_INT 111
95739: PUSH
95740: LD_INT 112
95742: PUSH
95743: LD_INT 113
95745: PUSH
95746: LD_INT 114
95748: PUSH
95749: EMPTY
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: PUSH
95765: EMPTY
95766: LIST
95767: LIST
95768: ST_TO_ADDR
95769: GO 96496
95771: LD_INT 16
95773: DOUBLE
95774: EQUAL
95775: IFTRUE 95779
95777: GO 95903
95779: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
95780: LD_ADDR_VAR 0 1
95784: PUSH
95785: LD_INT 2
95787: PUSH
95788: LD_INT 4
95790: PUSH
95791: LD_INT 5
95793: PUSH
95794: LD_INT 7
95796: PUSH
95797: LD_INT 11
95799: PUSH
95800: LD_INT 12
95802: PUSH
95803: LD_INT 15
95805: PUSH
95806: LD_INT 16
95808: PUSH
95809: LD_INT 20
95811: PUSH
95812: LD_INT 21
95814: PUSH
95815: LD_INT 22
95817: PUSH
95818: LD_INT 23
95820: PUSH
95821: LD_INT 25
95823: PUSH
95824: LD_INT 26
95826: PUSH
95827: LD_INT 30
95829: PUSH
95830: LD_INT 31
95832: PUSH
95833: LD_INT 32
95835: PUSH
95836: LD_INT 33
95838: PUSH
95839: LD_INT 34
95841: PUSH
95842: EMPTY
95843: LIST
95844: LIST
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: PUSH
95863: LD_INT 101
95865: PUSH
95866: LD_INT 102
95868: PUSH
95869: LD_INT 103
95871: PUSH
95872: LD_INT 106
95874: PUSH
95875: LD_INT 108
95877: PUSH
95878: LD_INT 112
95880: PUSH
95881: LD_INT 113
95883: PUSH
95884: LD_INT 114
95886: PUSH
95887: EMPTY
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: PUSH
95897: EMPTY
95898: LIST
95899: LIST
95900: ST_TO_ADDR
95901: GO 96496
95903: LD_INT 17
95905: DOUBLE
95906: EQUAL
95907: IFTRUE 95911
95909: GO 96123
95911: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
95912: LD_ADDR_VAR 0 1
95916: PUSH
95917: LD_INT 1
95919: PUSH
95920: LD_INT 2
95922: PUSH
95923: LD_INT 3
95925: PUSH
95926: LD_INT 4
95928: PUSH
95929: LD_INT 5
95931: PUSH
95932: LD_INT 6
95934: PUSH
95935: LD_INT 7
95937: PUSH
95938: LD_INT 8
95940: PUSH
95941: LD_INT 9
95943: PUSH
95944: LD_INT 10
95946: PUSH
95947: LD_INT 11
95949: PUSH
95950: LD_INT 12
95952: PUSH
95953: LD_INT 13
95955: PUSH
95956: LD_INT 14
95958: PUSH
95959: LD_INT 15
95961: PUSH
95962: LD_INT 16
95964: PUSH
95965: LD_INT 17
95967: PUSH
95968: LD_INT 18
95970: PUSH
95971: LD_INT 19
95973: PUSH
95974: LD_INT 20
95976: PUSH
95977: LD_INT 21
95979: PUSH
95980: LD_INT 22
95982: PUSH
95983: LD_INT 23
95985: PUSH
95986: LD_INT 24
95988: PUSH
95989: LD_INT 25
95991: PUSH
95992: LD_INT 26
95994: PUSH
95995: LD_INT 27
95997: PUSH
95998: LD_INT 28
96000: PUSH
96001: LD_INT 29
96003: PUSH
96004: LD_INT 30
96006: PUSH
96007: LD_INT 31
96009: PUSH
96010: LD_INT 32
96012: PUSH
96013: LD_INT 33
96015: PUSH
96016: LD_INT 34
96018: PUSH
96019: LD_INT 36
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: PUSH
96059: LD_INT 101
96061: PUSH
96062: LD_INT 102
96064: PUSH
96065: LD_INT 103
96067: PUSH
96068: LD_INT 104
96070: PUSH
96071: LD_INT 105
96073: PUSH
96074: LD_INT 106
96076: PUSH
96077: LD_INT 107
96079: PUSH
96080: LD_INT 108
96082: PUSH
96083: LD_INT 109
96085: PUSH
96086: LD_INT 110
96088: PUSH
96089: LD_INT 111
96091: PUSH
96092: LD_INT 112
96094: PUSH
96095: LD_INT 113
96097: PUSH
96098: LD_INT 114
96100: PUSH
96101: EMPTY
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: ST_TO_ADDR
96121: GO 96496
96123: LD_INT 18
96125: DOUBLE
96126: EQUAL
96127: IFTRUE 96131
96129: GO 96267
96131: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
96132: LD_ADDR_VAR 0 1
96136: PUSH
96137: LD_INT 2
96139: PUSH
96140: LD_INT 4
96142: PUSH
96143: LD_INT 5
96145: PUSH
96146: LD_INT 7
96148: PUSH
96149: LD_INT 11
96151: PUSH
96152: LD_INT 12
96154: PUSH
96155: LD_INT 15
96157: PUSH
96158: LD_INT 16
96160: PUSH
96161: LD_INT 20
96163: PUSH
96164: LD_INT 21
96166: PUSH
96167: LD_INT 22
96169: PUSH
96170: LD_INT 23
96172: PUSH
96173: LD_INT 25
96175: PUSH
96176: LD_INT 26
96178: PUSH
96179: LD_INT 30
96181: PUSH
96182: LD_INT 31
96184: PUSH
96185: LD_INT 32
96187: PUSH
96188: LD_INT 33
96190: PUSH
96191: LD_INT 34
96193: PUSH
96194: LD_INT 35
96196: PUSH
96197: LD_INT 36
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: PUSH
96223: LD_INT 101
96225: PUSH
96226: LD_INT 102
96228: PUSH
96229: LD_INT 103
96231: PUSH
96232: LD_INT 106
96234: PUSH
96235: LD_INT 108
96237: PUSH
96238: LD_INT 112
96240: PUSH
96241: LD_INT 113
96243: PUSH
96244: LD_INT 114
96246: PUSH
96247: LD_INT 115
96249: PUSH
96250: EMPTY
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: PUSH
96261: EMPTY
96262: LIST
96263: LIST
96264: ST_TO_ADDR
96265: GO 96496
96267: LD_INT 19
96269: DOUBLE
96270: EQUAL
96271: IFTRUE 96275
96273: GO 96495
96275: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
96276: LD_ADDR_VAR 0 1
96280: PUSH
96281: LD_INT 1
96283: PUSH
96284: LD_INT 2
96286: PUSH
96287: LD_INT 3
96289: PUSH
96290: LD_INT 4
96292: PUSH
96293: LD_INT 5
96295: PUSH
96296: LD_INT 6
96298: PUSH
96299: LD_INT 7
96301: PUSH
96302: LD_INT 8
96304: PUSH
96305: LD_INT 9
96307: PUSH
96308: LD_INT 10
96310: PUSH
96311: LD_INT 11
96313: PUSH
96314: LD_INT 12
96316: PUSH
96317: LD_INT 13
96319: PUSH
96320: LD_INT 14
96322: PUSH
96323: LD_INT 15
96325: PUSH
96326: LD_INT 16
96328: PUSH
96329: LD_INT 17
96331: PUSH
96332: LD_INT 18
96334: PUSH
96335: LD_INT 19
96337: PUSH
96338: LD_INT 20
96340: PUSH
96341: LD_INT 21
96343: PUSH
96344: LD_INT 22
96346: PUSH
96347: LD_INT 23
96349: PUSH
96350: LD_INT 24
96352: PUSH
96353: LD_INT 25
96355: PUSH
96356: LD_INT 26
96358: PUSH
96359: LD_INT 27
96361: PUSH
96362: LD_INT 28
96364: PUSH
96365: LD_INT 29
96367: PUSH
96368: LD_INT 30
96370: PUSH
96371: LD_INT 31
96373: PUSH
96374: LD_INT 32
96376: PUSH
96377: LD_INT 33
96379: PUSH
96380: LD_INT 34
96382: PUSH
96383: LD_INT 35
96385: PUSH
96386: LD_INT 36
96388: PUSH
96389: EMPTY
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: PUSH
96427: LD_INT 101
96429: PUSH
96430: LD_INT 102
96432: PUSH
96433: LD_INT 103
96435: PUSH
96436: LD_INT 104
96438: PUSH
96439: LD_INT 105
96441: PUSH
96442: LD_INT 106
96444: PUSH
96445: LD_INT 107
96447: PUSH
96448: LD_INT 108
96450: PUSH
96451: LD_INT 109
96453: PUSH
96454: LD_INT 110
96456: PUSH
96457: LD_INT 111
96459: PUSH
96460: LD_INT 112
96462: PUSH
96463: LD_INT 113
96465: PUSH
96466: LD_INT 114
96468: PUSH
96469: LD_INT 115
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: PUSH
96489: EMPTY
96490: LIST
96491: LIST
96492: ST_TO_ADDR
96493: GO 96496
96495: POP
// end else
96496: GO 96715
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
96498: LD_ADDR_VAR 0 1
96502: PUSH
96503: LD_INT 1
96505: PUSH
96506: LD_INT 2
96508: PUSH
96509: LD_INT 3
96511: PUSH
96512: LD_INT 4
96514: PUSH
96515: LD_INT 5
96517: PUSH
96518: LD_INT 6
96520: PUSH
96521: LD_INT 7
96523: PUSH
96524: LD_INT 8
96526: PUSH
96527: LD_INT 9
96529: PUSH
96530: LD_INT 10
96532: PUSH
96533: LD_INT 11
96535: PUSH
96536: LD_INT 12
96538: PUSH
96539: LD_INT 13
96541: PUSH
96542: LD_INT 14
96544: PUSH
96545: LD_INT 15
96547: PUSH
96548: LD_INT 16
96550: PUSH
96551: LD_INT 17
96553: PUSH
96554: LD_INT 18
96556: PUSH
96557: LD_INT 19
96559: PUSH
96560: LD_INT 20
96562: PUSH
96563: LD_INT 21
96565: PUSH
96566: LD_INT 22
96568: PUSH
96569: LD_INT 23
96571: PUSH
96572: LD_INT 24
96574: PUSH
96575: LD_INT 25
96577: PUSH
96578: LD_INT 26
96580: PUSH
96581: LD_INT 27
96583: PUSH
96584: LD_INT 28
96586: PUSH
96587: LD_INT 29
96589: PUSH
96590: LD_INT 30
96592: PUSH
96593: LD_INT 31
96595: PUSH
96596: LD_INT 32
96598: PUSH
96599: LD_INT 33
96601: PUSH
96602: LD_INT 34
96604: PUSH
96605: LD_INT 35
96607: PUSH
96608: LD_INT 36
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: LIST
96645: LIST
96646: LIST
96647: LIST
96648: PUSH
96649: LD_INT 101
96651: PUSH
96652: LD_INT 102
96654: PUSH
96655: LD_INT 103
96657: PUSH
96658: LD_INT 104
96660: PUSH
96661: LD_INT 105
96663: PUSH
96664: LD_INT 106
96666: PUSH
96667: LD_INT 107
96669: PUSH
96670: LD_INT 108
96672: PUSH
96673: LD_INT 109
96675: PUSH
96676: LD_INT 110
96678: PUSH
96679: LD_INT 111
96681: PUSH
96682: LD_INT 112
96684: PUSH
96685: LD_INT 113
96687: PUSH
96688: LD_INT 114
96690: PUSH
96691: LD_INT 115
96693: PUSH
96694: EMPTY
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: PUSH
96711: EMPTY
96712: LIST
96713: LIST
96714: ST_TO_ADDR
// if result then
96715: LD_VAR 0 1
96719: IFFALSE 97008
// begin normal :=  ;
96721: LD_ADDR_VAR 0 3
96725: PUSH
96726: LD_STRING 
96728: ST_TO_ADDR
// hardcore :=  ;
96729: LD_ADDR_VAR 0 4
96733: PUSH
96734: LD_STRING 
96736: ST_TO_ADDR
// for i = 1 to normalCounter do
96737: LD_ADDR_VAR 0 5
96741: PUSH
96742: DOUBLE
96743: LD_INT 1
96745: DEC
96746: ST_TO_ADDR
96747: LD_EXP 99
96751: PUSH
96752: FOR_TO
96753: IFFALSE 96854
// begin tmp := 0 ;
96755: LD_ADDR_VAR 0 2
96759: PUSH
96760: LD_STRING 0
96762: ST_TO_ADDR
// if result [ 1 ] then
96763: LD_VAR 0 1
96767: PUSH
96768: LD_INT 1
96770: ARRAY
96771: IFFALSE 96836
// if result [ 1 ] [ 1 ] = i then
96773: LD_VAR 0 1
96777: PUSH
96778: LD_INT 1
96780: ARRAY
96781: PUSH
96782: LD_INT 1
96784: ARRAY
96785: PUSH
96786: LD_VAR 0 5
96790: EQUAL
96791: IFFALSE 96836
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96793: LD_ADDR_VAR 0 1
96797: PUSH
96798: LD_VAR 0 1
96802: PPUSH
96803: LD_INT 1
96805: PPUSH
96806: LD_VAR 0 1
96810: PUSH
96811: LD_INT 1
96813: ARRAY
96814: PPUSH
96815: LD_INT 1
96817: PPUSH
96818: CALL_OW 3
96822: PPUSH
96823: CALL_OW 1
96827: ST_TO_ADDR
// tmp := 1 ;
96828: LD_ADDR_VAR 0 2
96832: PUSH
96833: LD_STRING 1
96835: ST_TO_ADDR
// end ; normal := normal & tmp ;
96836: LD_ADDR_VAR 0 3
96840: PUSH
96841: LD_VAR 0 3
96845: PUSH
96846: LD_VAR 0 2
96850: STR
96851: ST_TO_ADDR
// end ;
96852: GO 96752
96854: POP
96855: POP
// for i = 1 to hardcoreCounter do
96856: LD_ADDR_VAR 0 5
96860: PUSH
96861: DOUBLE
96862: LD_INT 1
96864: DEC
96865: ST_TO_ADDR
96866: LD_EXP 100
96870: PUSH
96871: FOR_TO
96872: IFFALSE 96977
// begin tmp := 0 ;
96874: LD_ADDR_VAR 0 2
96878: PUSH
96879: LD_STRING 0
96881: ST_TO_ADDR
// if result [ 2 ] then
96882: LD_VAR 0 1
96886: PUSH
96887: LD_INT 2
96889: ARRAY
96890: IFFALSE 96959
// if result [ 2 ] [ 1 ] = 100 + i then
96892: LD_VAR 0 1
96896: PUSH
96897: LD_INT 2
96899: ARRAY
96900: PUSH
96901: LD_INT 1
96903: ARRAY
96904: PUSH
96905: LD_INT 100
96907: PUSH
96908: LD_VAR 0 5
96912: PLUS
96913: EQUAL
96914: IFFALSE 96959
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96916: LD_ADDR_VAR 0 1
96920: PUSH
96921: LD_VAR 0 1
96925: PPUSH
96926: LD_INT 2
96928: PPUSH
96929: LD_VAR 0 1
96933: PUSH
96934: LD_INT 2
96936: ARRAY
96937: PPUSH
96938: LD_INT 1
96940: PPUSH
96941: CALL_OW 3
96945: PPUSH
96946: CALL_OW 1
96950: ST_TO_ADDR
// tmp := 1 ;
96951: LD_ADDR_VAR 0 2
96955: PUSH
96956: LD_STRING 1
96958: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96959: LD_ADDR_VAR 0 4
96963: PUSH
96964: LD_VAR 0 4
96968: PUSH
96969: LD_VAR 0 2
96973: STR
96974: ST_TO_ADDR
// end ;
96975: GO 96871
96977: POP
96978: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
96979: LD_STRING getStreamItemsFromMission("
96981: PUSH
96982: LD_VAR 0 3
96986: STR
96987: PUSH
96988: LD_STRING ","
96990: STR
96991: PUSH
96992: LD_VAR 0 4
96996: STR
96997: PUSH
96998: LD_STRING ")
97000: STR
97001: PPUSH
97002: CALL_OW 559
// end else
97006: GO 97015
// ToLua ( getStreamItemsFromMission("","") ) ;
97008: LD_STRING getStreamItemsFromMission("","")
97010: PPUSH
97011: CALL_OW 559
// end ;
97015: LD_VAR 0 1
97019: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
97020: LD_EXP 98
97024: PUSH
97025: LD_EXP 103
97029: AND
97030: IFFALSE 97154
97032: GO 97034
97034: DISABLE
97035: LD_INT 0
97037: PPUSH
97038: PPUSH
// begin enable ;
97039: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
97040: LD_ADDR_VAR 0 2
97044: PUSH
97045: LD_INT 22
97047: PUSH
97048: LD_OWVAR 2
97052: PUSH
97053: EMPTY
97054: LIST
97055: LIST
97056: PUSH
97057: LD_INT 2
97059: PUSH
97060: LD_INT 34
97062: PUSH
97063: LD_INT 7
97065: PUSH
97066: EMPTY
97067: LIST
97068: LIST
97069: PUSH
97070: LD_INT 34
97072: PUSH
97073: LD_INT 45
97075: PUSH
97076: EMPTY
97077: LIST
97078: LIST
97079: PUSH
97080: LD_INT 34
97082: PUSH
97083: LD_INT 28
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: PUSH
97090: LD_INT 34
97092: PUSH
97093: LD_INT 47
97095: PUSH
97096: EMPTY
97097: LIST
97098: LIST
97099: PUSH
97100: EMPTY
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: PUSH
97107: EMPTY
97108: LIST
97109: LIST
97110: PPUSH
97111: CALL_OW 69
97115: ST_TO_ADDR
// if not tmp then
97116: LD_VAR 0 2
97120: NOT
97121: IFFALSE 97125
// exit ;
97123: GO 97154
// for i in tmp do
97125: LD_ADDR_VAR 0 1
97129: PUSH
97130: LD_VAR 0 2
97134: PUSH
97135: FOR_IN
97136: IFFALSE 97152
// begin SetLives ( i , 0 ) ;
97138: LD_VAR 0 1
97142: PPUSH
97143: LD_INT 0
97145: PPUSH
97146: CALL_OW 234
// end ;
97150: GO 97135
97152: POP
97153: POP
// end ;
97154: PPOPN 2
97156: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97157: LD_EXP 98
97161: PUSH
97162: LD_EXP 104
97166: AND
97167: IFFALSE 97251
97169: GO 97171
97171: DISABLE
97172: LD_INT 0
97174: PPUSH
97175: PPUSH
// begin enable ;
97176: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97177: LD_ADDR_VAR 0 2
97181: PUSH
97182: LD_INT 22
97184: PUSH
97185: LD_OWVAR 2
97189: PUSH
97190: EMPTY
97191: LIST
97192: LIST
97193: PUSH
97194: LD_INT 32
97196: PUSH
97197: LD_INT 3
97199: PUSH
97200: EMPTY
97201: LIST
97202: LIST
97203: PUSH
97204: EMPTY
97205: LIST
97206: LIST
97207: PPUSH
97208: CALL_OW 69
97212: ST_TO_ADDR
// if not tmp then
97213: LD_VAR 0 2
97217: NOT
97218: IFFALSE 97222
// exit ;
97220: GO 97251
// for i in tmp do
97222: LD_ADDR_VAR 0 1
97226: PUSH
97227: LD_VAR 0 2
97231: PUSH
97232: FOR_IN
97233: IFFALSE 97249
// begin SetLives ( i , 0 ) ;
97235: LD_VAR 0 1
97239: PPUSH
97240: LD_INT 0
97242: PPUSH
97243: CALL_OW 234
// end ;
97247: GO 97232
97249: POP
97250: POP
// end ;
97251: PPOPN 2
97253: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97254: LD_EXP 98
97258: PUSH
97259: LD_EXP 101
97263: AND
97264: IFFALSE 97357
97266: GO 97268
97268: DISABLE
97269: LD_INT 0
97271: PPUSH
// begin enable ;
97272: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97273: LD_ADDR_VAR 0 1
97277: PUSH
97278: LD_INT 22
97280: PUSH
97281: LD_OWVAR 2
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: LD_INT 2
97292: PUSH
97293: LD_INT 25
97295: PUSH
97296: LD_INT 5
97298: PUSH
97299: EMPTY
97300: LIST
97301: LIST
97302: PUSH
97303: LD_INT 25
97305: PUSH
97306: LD_INT 9
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: PUSH
97313: LD_INT 25
97315: PUSH
97316: LD_INT 8
97318: PUSH
97319: EMPTY
97320: LIST
97321: LIST
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: LIST
97327: LIST
97328: PUSH
97329: EMPTY
97330: LIST
97331: LIST
97332: PPUSH
97333: CALL_OW 69
97337: PUSH
97338: FOR_IN
97339: IFFALSE 97355
// begin SetClass ( i , 1 ) ;
97341: LD_VAR 0 1
97345: PPUSH
97346: LD_INT 1
97348: PPUSH
97349: CALL_OW 336
// end ;
97353: GO 97338
97355: POP
97356: POP
// end ;
97357: PPOPN 1
97359: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97360: LD_EXP 98
97364: PUSH
97365: LD_EXP 102
97369: AND
97370: PUSH
97371: LD_OWVAR 65
97375: PUSH
97376: LD_INT 7
97378: LESS
97379: AND
97380: IFFALSE 97394
97382: GO 97384
97384: DISABLE
// begin enable ;
97385: ENABLE
// game_speed := 7 ;
97386: LD_ADDR_OWVAR 65
97390: PUSH
97391: LD_INT 7
97393: ST_TO_ADDR
// end ;
97394: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97395: LD_EXP 98
97399: PUSH
97400: LD_EXP 105
97404: AND
97405: IFFALSE 97607
97407: GO 97409
97409: DISABLE
97410: LD_INT 0
97412: PPUSH
97413: PPUSH
97414: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97415: LD_ADDR_VAR 0 3
97419: PUSH
97420: LD_INT 81
97422: PUSH
97423: LD_OWVAR 2
97427: PUSH
97428: EMPTY
97429: LIST
97430: LIST
97431: PUSH
97432: LD_INT 21
97434: PUSH
97435: LD_INT 1
97437: PUSH
97438: EMPTY
97439: LIST
97440: LIST
97441: PUSH
97442: EMPTY
97443: LIST
97444: LIST
97445: PPUSH
97446: CALL_OW 69
97450: ST_TO_ADDR
// if not tmp then
97451: LD_VAR 0 3
97455: NOT
97456: IFFALSE 97460
// exit ;
97458: GO 97607
// if tmp > 5 then
97460: LD_VAR 0 3
97464: PUSH
97465: LD_INT 5
97467: GREATER
97468: IFFALSE 97480
// k := 5 else
97470: LD_ADDR_VAR 0 2
97474: PUSH
97475: LD_INT 5
97477: ST_TO_ADDR
97478: GO 97490
// k := tmp ;
97480: LD_ADDR_VAR 0 2
97484: PUSH
97485: LD_VAR 0 3
97489: ST_TO_ADDR
// for i := 1 to k do
97490: LD_ADDR_VAR 0 1
97494: PUSH
97495: DOUBLE
97496: LD_INT 1
97498: DEC
97499: ST_TO_ADDR
97500: LD_VAR 0 2
97504: PUSH
97505: FOR_TO
97506: IFFALSE 97605
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97508: LD_VAR 0 3
97512: PUSH
97513: LD_VAR 0 1
97517: ARRAY
97518: PPUSH
97519: LD_VAR 0 1
97523: PUSH
97524: LD_INT 4
97526: MOD
97527: PUSH
97528: LD_INT 1
97530: PLUS
97531: PPUSH
97532: CALL_OW 259
97536: PUSH
97537: LD_INT 10
97539: LESS
97540: IFFALSE 97603
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97542: LD_VAR 0 3
97546: PUSH
97547: LD_VAR 0 1
97551: ARRAY
97552: PPUSH
97553: LD_VAR 0 1
97557: PUSH
97558: LD_INT 4
97560: MOD
97561: PUSH
97562: LD_INT 1
97564: PLUS
97565: PPUSH
97566: LD_VAR 0 3
97570: PUSH
97571: LD_VAR 0 1
97575: ARRAY
97576: PPUSH
97577: LD_VAR 0 1
97581: PUSH
97582: LD_INT 4
97584: MOD
97585: PUSH
97586: LD_INT 1
97588: PLUS
97589: PPUSH
97590: CALL_OW 259
97594: PUSH
97595: LD_INT 1
97597: PLUS
97598: PPUSH
97599: CALL_OW 237
97603: GO 97505
97605: POP
97606: POP
// end ;
97607: PPOPN 3
97609: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97610: LD_EXP 98
97614: PUSH
97615: LD_EXP 106
97619: AND
97620: IFFALSE 97640
97622: GO 97624
97624: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97625: LD_INT 4
97627: PPUSH
97628: LD_OWVAR 2
97632: PPUSH
97633: LD_INT 0
97635: PPUSH
97636: CALL_OW 324
97640: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97641: LD_EXP 98
97645: PUSH
97646: LD_EXP 135
97650: AND
97651: IFFALSE 97671
97653: GO 97655
97655: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97656: LD_INT 19
97658: PPUSH
97659: LD_OWVAR 2
97663: PPUSH
97664: LD_INT 0
97666: PPUSH
97667: CALL_OW 324
97671: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97672: LD_EXP 98
97676: PUSH
97677: LD_EXP 107
97681: AND
97682: IFFALSE 97784
97684: GO 97686
97686: DISABLE
97687: LD_INT 0
97689: PPUSH
97690: PPUSH
// begin enable ;
97691: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97692: LD_ADDR_VAR 0 2
97696: PUSH
97697: LD_INT 22
97699: PUSH
97700: LD_OWVAR 2
97704: PUSH
97705: EMPTY
97706: LIST
97707: LIST
97708: PUSH
97709: LD_INT 2
97711: PUSH
97712: LD_INT 34
97714: PUSH
97715: LD_INT 11
97717: PUSH
97718: EMPTY
97719: LIST
97720: LIST
97721: PUSH
97722: LD_INT 34
97724: PUSH
97725: LD_INT 30
97727: PUSH
97728: EMPTY
97729: LIST
97730: LIST
97731: PUSH
97732: EMPTY
97733: LIST
97734: LIST
97735: LIST
97736: PUSH
97737: EMPTY
97738: LIST
97739: LIST
97740: PPUSH
97741: CALL_OW 69
97745: ST_TO_ADDR
// if not tmp then
97746: LD_VAR 0 2
97750: NOT
97751: IFFALSE 97755
// exit ;
97753: GO 97784
// for i in tmp do
97755: LD_ADDR_VAR 0 1
97759: PUSH
97760: LD_VAR 0 2
97764: PUSH
97765: FOR_IN
97766: IFFALSE 97782
// begin SetLives ( i , 0 ) ;
97768: LD_VAR 0 1
97772: PPUSH
97773: LD_INT 0
97775: PPUSH
97776: CALL_OW 234
// end ;
97780: GO 97765
97782: POP
97783: POP
// end ;
97784: PPOPN 2
97786: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97787: LD_EXP 98
97791: PUSH
97792: LD_EXP 108
97796: AND
97797: IFFALSE 97817
97799: GO 97801
97801: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97802: LD_INT 32
97804: PPUSH
97805: LD_OWVAR 2
97809: PPUSH
97810: LD_INT 0
97812: PPUSH
97813: CALL_OW 324
97817: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97818: LD_EXP 98
97822: PUSH
97823: LD_EXP 109
97827: AND
97828: IFFALSE 98009
97830: GO 97832
97832: DISABLE
97833: LD_INT 0
97835: PPUSH
97836: PPUSH
97837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97838: LD_ADDR_VAR 0 2
97842: PUSH
97843: LD_INT 22
97845: PUSH
97846: LD_OWVAR 2
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: PUSH
97855: LD_INT 33
97857: PUSH
97858: LD_INT 3
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: PPUSH
97869: CALL_OW 69
97873: ST_TO_ADDR
// if not tmp then
97874: LD_VAR 0 2
97878: NOT
97879: IFFALSE 97883
// exit ;
97881: GO 98009
// side := 0 ;
97883: LD_ADDR_VAR 0 3
97887: PUSH
97888: LD_INT 0
97890: ST_TO_ADDR
// for i := 1 to 8 do
97891: LD_ADDR_VAR 0 1
97895: PUSH
97896: DOUBLE
97897: LD_INT 1
97899: DEC
97900: ST_TO_ADDR
97901: LD_INT 8
97903: PUSH
97904: FOR_TO
97905: IFFALSE 97953
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97907: LD_OWVAR 2
97911: PUSH
97912: LD_VAR 0 1
97916: NONEQUAL
97917: PUSH
97918: LD_OWVAR 2
97922: PPUSH
97923: LD_VAR 0 1
97927: PPUSH
97928: CALL_OW 81
97932: PUSH
97933: LD_INT 2
97935: EQUAL
97936: AND
97937: IFFALSE 97951
// begin side := i ;
97939: LD_ADDR_VAR 0 3
97943: PUSH
97944: LD_VAR 0 1
97948: ST_TO_ADDR
// break ;
97949: GO 97953
// end ;
97951: GO 97904
97953: POP
97954: POP
// if not side then
97955: LD_VAR 0 3
97959: NOT
97960: IFFALSE 97964
// exit ;
97962: GO 98009
// for i := 1 to tmp do
97964: LD_ADDR_VAR 0 1
97968: PUSH
97969: DOUBLE
97970: LD_INT 1
97972: DEC
97973: ST_TO_ADDR
97974: LD_VAR 0 2
97978: PUSH
97979: FOR_TO
97980: IFFALSE 98007
// if Prob ( 60 ) then
97982: LD_INT 60
97984: PPUSH
97985: CALL_OW 13
97989: IFFALSE 98005
// SetSide ( i , side ) ;
97991: LD_VAR 0 1
97995: PPUSH
97996: LD_VAR 0 3
98000: PPUSH
98001: CALL_OW 235
98005: GO 97979
98007: POP
98008: POP
// end ;
98009: PPOPN 3
98011: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
98012: LD_EXP 98
98016: PUSH
98017: LD_EXP 111
98021: AND
98022: IFFALSE 98141
98024: GO 98026
98026: DISABLE
98027: LD_INT 0
98029: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
98030: LD_ADDR_VAR 0 1
98034: PUSH
98035: LD_INT 22
98037: PUSH
98038: LD_OWVAR 2
98042: PUSH
98043: EMPTY
98044: LIST
98045: LIST
98046: PUSH
98047: LD_INT 21
98049: PUSH
98050: LD_INT 1
98052: PUSH
98053: EMPTY
98054: LIST
98055: LIST
98056: PUSH
98057: LD_INT 3
98059: PUSH
98060: LD_INT 23
98062: PUSH
98063: LD_INT 0
98065: PUSH
98066: EMPTY
98067: LIST
98068: LIST
98069: PUSH
98070: EMPTY
98071: LIST
98072: LIST
98073: PUSH
98074: EMPTY
98075: LIST
98076: LIST
98077: LIST
98078: PPUSH
98079: CALL_OW 69
98083: PUSH
98084: FOR_IN
98085: IFFALSE 98139
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98087: LD_VAR 0 1
98091: PPUSH
98092: CALL_OW 257
98096: PUSH
98097: LD_INT 1
98099: PUSH
98100: LD_INT 2
98102: PUSH
98103: LD_INT 3
98105: PUSH
98106: LD_INT 4
98108: PUSH
98109: EMPTY
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: IN
98115: IFFALSE 98137
// SetClass ( un , rand ( 1 , 4 ) ) ;
98117: LD_VAR 0 1
98121: PPUSH
98122: LD_INT 1
98124: PPUSH
98125: LD_INT 4
98127: PPUSH
98128: CALL_OW 12
98132: PPUSH
98133: CALL_OW 336
98137: GO 98084
98139: POP
98140: POP
// end ;
98141: PPOPN 1
98143: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98144: LD_EXP 98
98148: PUSH
98149: LD_EXP 110
98153: AND
98154: IFFALSE 98233
98156: GO 98158
98158: DISABLE
98159: LD_INT 0
98161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98162: LD_ADDR_VAR 0 1
98166: PUSH
98167: LD_INT 22
98169: PUSH
98170: LD_OWVAR 2
98174: PUSH
98175: EMPTY
98176: LIST
98177: LIST
98178: PUSH
98179: LD_INT 21
98181: PUSH
98182: LD_INT 3
98184: PUSH
98185: EMPTY
98186: LIST
98187: LIST
98188: PUSH
98189: EMPTY
98190: LIST
98191: LIST
98192: PPUSH
98193: CALL_OW 69
98197: ST_TO_ADDR
// if not tmp then
98198: LD_VAR 0 1
98202: NOT
98203: IFFALSE 98207
// exit ;
98205: GO 98233
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98207: LD_VAR 0 1
98211: PUSH
98212: LD_INT 1
98214: PPUSH
98215: LD_VAR 0 1
98219: PPUSH
98220: CALL_OW 12
98224: ARRAY
98225: PPUSH
98226: LD_INT 100
98228: PPUSH
98229: CALL_OW 234
// end ;
98233: PPOPN 1
98235: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98236: LD_EXP 98
98240: PUSH
98241: LD_EXP 112
98245: AND
98246: IFFALSE 98344
98248: GO 98250
98250: DISABLE
98251: LD_INT 0
98253: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98254: LD_ADDR_VAR 0 1
98258: PUSH
98259: LD_INT 22
98261: PUSH
98262: LD_OWVAR 2
98266: PUSH
98267: EMPTY
98268: LIST
98269: LIST
98270: PUSH
98271: LD_INT 21
98273: PUSH
98274: LD_INT 1
98276: PUSH
98277: EMPTY
98278: LIST
98279: LIST
98280: PUSH
98281: EMPTY
98282: LIST
98283: LIST
98284: PPUSH
98285: CALL_OW 69
98289: ST_TO_ADDR
// if not tmp then
98290: LD_VAR 0 1
98294: NOT
98295: IFFALSE 98299
// exit ;
98297: GO 98344
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98299: LD_VAR 0 1
98303: PUSH
98304: LD_INT 1
98306: PPUSH
98307: LD_VAR 0 1
98311: PPUSH
98312: CALL_OW 12
98316: ARRAY
98317: PPUSH
98318: LD_INT 1
98320: PPUSH
98321: LD_INT 4
98323: PPUSH
98324: CALL_OW 12
98328: PPUSH
98329: LD_INT 3000
98331: PPUSH
98332: LD_INT 9000
98334: PPUSH
98335: CALL_OW 12
98339: PPUSH
98340: CALL_OW 492
// end ;
98344: PPOPN 1
98346: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98347: LD_EXP 98
98351: PUSH
98352: LD_EXP 113
98356: AND
98357: IFFALSE 98377
98359: GO 98361
98361: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98362: LD_INT 1
98364: PPUSH
98365: LD_OWVAR 2
98369: PPUSH
98370: LD_INT 0
98372: PPUSH
98373: CALL_OW 324
98377: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98378: LD_EXP 98
98382: PUSH
98383: LD_EXP 114
98387: AND
98388: IFFALSE 98471
98390: GO 98392
98392: DISABLE
98393: LD_INT 0
98395: PPUSH
98396: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98397: LD_ADDR_VAR 0 2
98401: PUSH
98402: LD_INT 22
98404: PUSH
98405: LD_OWVAR 2
98409: PUSH
98410: EMPTY
98411: LIST
98412: LIST
98413: PUSH
98414: LD_INT 21
98416: PUSH
98417: LD_INT 3
98419: PUSH
98420: EMPTY
98421: LIST
98422: LIST
98423: PUSH
98424: EMPTY
98425: LIST
98426: LIST
98427: PPUSH
98428: CALL_OW 69
98432: ST_TO_ADDR
// if not tmp then
98433: LD_VAR 0 2
98437: NOT
98438: IFFALSE 98442
// exit ;
98440: GO 98471
// for i in tmp do
98442: LD_ADDR_VAR 0 1
98446: PUSH
98447: LD_VAR 0 2
98451: PUSH
98452: FOR_IN
98453: IFFALSE 98469
// SetBLevel ( i , 10 ) ;
98455: LD_VAR 0 1
98459: PPUSH
98460: LD_INT 10
98462: PPUSH
98463: CALL_OW 241
98467: GO 98452
98469: POP
98470: POP
// end ;
98471: PPOPN 2
98473: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98474: LD_EXP 98
98478: PUSH
98479: LD_EXP 115
98483: AND
98484: IFFALSE 98595
98486: GO 98488
98488: DISABLE
98489: LD_INT 0
98491: PPUSH
98492: PPUSH
98493: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98494: LD_ADDR_VAR 0 3
98498: PUSH
98499: LD_INT 22
98501: PUSH
98502: LD_OWVAR 2
98506: PUSH
98507: EMPTY
98508: LIST
98509: LIST
98510: PUSH
98511: LD_INT 25
98513: PUSH
98514: LD_INT 1
98516: PUSH
98517: EMPTY
98518: LIST
98519: LIST
98520: PUSH
98521: EMPTY
98522: LIST
98523: LIST
98524: PPUSH
98525: CALL_OW 69
98529: ST_TO_ADDR
// if not tmp then
98530: LD_VAR 0 3
98534: NOT
98535: IFFALSE 98539
// exit ;
98537: GO 98595
// un := tmp [ rand ( 1 , tmp ) ] ;
98539: LD_ADDR_VAR 0 2
98543: PUSH
98544: LD_VAR 0 3
98548: PUSH
98549: LD_INT 1
98551: PPUSH
98552: LD_VAR 0 3
98556: PPUSH
98557: CALL_OW 12
98561: ARRAY
98562: ST_TO_ADDR
// if Crawls ( un ) then
98563: LD_VAR 0 2
98567: PPUSH
98568: CALL_OW 318
98572: IFFALSE 98583
// ComWalk ( un ) ;
98574: LD_VAR 0 2
98578: PPUSH
98579: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98583: LD_VAR 0 2
98587: PPUSH
98588: LD_INT 5
98590: PPUSH
98591: CALL_OW 336
// end ;
98595: PPOPN 3
98597: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
98598: LD_EXP 98
98602: PUSH
98603: LD_EXP 116
98607: AND
98608: PUSH
98609: LD_OWVAR 67
98613: PUSH
98614: LD_INT 3
98616: LESS
98617: AND
98618: IFFALSE 98637
98620: GO 98622
98622: DISABLE
// Difficulty := Difficulty + 1 ;
98623: LD_ADDR_OWVAR 67
98627: PUSH
98628: LD_OWVAR 67
98632: PUSH
98633: LD_INT 1
98635: PLUS
98636: ST_TO_ADDR
98637: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98638: LD_EXP 98
98642: PUSH
98643: LD_EXP 117
98647: AND
98648: IFFALSE 98751
98650: GO 98652
98652: DISABLE
98653: LD_INT 0
98655: PPUSH
// begin for i := 1 to 5 do
98656: LD_ADDR_VAR 0 1
98660: PUSH
98661: DOUBLE
98662: LD_INT 1
98664: DEC
98665: ST_TO_ADDR
98666: LD_INT 5
98668: PUSH
98669: FOR_TO
98670: IFFALSE 98749
// begin uc_nation := nation_nature ;
98672: LD_ADDR_OWVAR 21
98676: PUSH
98677: LD_INT 0
98679: ST_TO_ADDR
// uc_side := 0 ;
98680: LD_ADDR_OWVAR 20
98684: PUSH
98685: LD_INT 0
98687: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98688: LD_ADDR_OWVAR 29
98692: PUSH
98693: LD_INT 12
98695: PUSH
98696: LD_INT 12
98698: PUSH
98699: EMPTY
98700: LIST
98701: LIST
98702: ST_TO_ADDR
// hc_agressivity := 20 ;
98703: LD_ADDR_OWVAR 35
98707: PUSH
98708: LD_INT 20
98710: ST_TO_ADDR
// hc_class := class_tiger ;
98711: LD_ADDR_OWVAR 28
98715: PUSH
98716: LD_INT 14
98718: ST_TO_ADDR
// hc_gallery :=  ;
98719: LD_ADDR_OWVAR 33
98723: PUSH
98724: LD_STRING 
98726: ST_TO_ADDR
// hc_name :=  ;
98727: LD_ADDR_OWVAR 26
98731: PUSH
98732: LD_STRING 
98734: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98735: CALL_OW 44
98739: PPUSH
98740: LD_INT 0
98742: PPUSH
98743: CALL_OW 51
// end ;
98747: GO 98669
98749: POP
98750: POP
// end ;
98751: PPOPN 1
98753: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98754: LD_EXP 98
98758: PUSH
98759: LD_EXP 118
98763: AND
98764: IFFALSE 98773
98766: GO 98768
98768: DISABLE
// StreamSibBomb ;
98769: CALL 98774 0 0
98773: END
// export function StreamSibBomb ; var i , x , y ; begin
98774: LD_INT 0
98776: PPUSH
98777: PPUSH
98778: PPUSH
98779: PPUSH
// result := false ;
98780: LD_ADDR_VAR 0 1
98784: PUSH
98785: LD_INT 0
98787: ST_TO_ADDR
// for i := 1 to 16 do
98788: LD_ADDR_VAR 0 2
98792: PUSH
98793: DOUBLE
98794: LD_INT 1
98796: DEC
98797: ST_TO_ADDR
98798: LD_INT 16
98800: PUSH
98801: FOR_TO
98802: IFFALSE 99001
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98804: LD_ADDR_VAR 0 3
98808: PUSH
98809: LD_INT 10
98811: PUSH
98812: LD_INT 20
98814: PUSH
98815: LD_INT 30
98817: PUSH
98818: LD_INT 40
98820: PUSH
98821: LD_INT 50
98823: PUSH
98824: LD_INT 60
98826: PUSH
98827: LD_INT 70
98829: PUSH
98830: LD_INT 80
98832: PUSH
98833: LD_INT 90
98835: PUSH
98836: LD_INT 100
98838: PUSH
98839: LD_INT 110
98841: PUSH
98842: LD_INT 120
98844: PUSH
98845: LD_INT 130
98847: PUSH
98848: LD_INT 140
98850: PUSH
98851: LD_INT 150
98853: PUSH
98854: EMPTY
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: PUSH
98871: LD_INT 1
98873: PPUSH
98874: LD_INT 15
98876: PPUSH
98877: CALL_OW 12
98881: ARRAY
98882: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98883: LD_ADDR_VAR 0 4
98887: PUSH
98888: LD_INT 10
98890: PUSH
98891: LD_INT 20
98893: PUSH
98894: LD_INT 30
98896: PUSH
98897: LD_INT 40
98899: PUSH
98900: LD_INT 50
98902: PUSH
98903: LD_INT 60
98905: PUSH
98906: LD_INT 70
98908: PUSH
98909: LD_INT 80
98911: PUSH
98912: LD_INT 90
98914: PUSH
98915: LD_INT 100
98917: PUSH
98918: LD_INT 110
98920: PUSH
98921: LD_INT 120
98923: PUSH
98924: LD_INT 130
98926: PUSH
98927: LD_INT 140
98929: PUSH
98930: LD_INT 150
98932: PUSH
98933: EMPTY
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: LIST
98943: LIST
98944: LIST
98945: LIST
98946: LIST
98947: LIST
98948: LIST
98949: PUSH
98950: LD_INT 1
98952: PPUSH
98953: LD_INT 15
98955: PPUSH
98956: CALL_OW 12
98960: ARRAY
98961: ST_TO_ADDR
// if ValidHex ( x , y ) then
98962: LD_VAR 0 3
98966: PPUSH
98967: LD_VAR 0 4
98971: PPUSH
98972: CALL_OW 488
98976: IFFALSE 98999
// begin result := [ x , y ] ;
98978: LD_ADDR_VAR 0 1
98982: PUSH
98983: LD_VAR 0 3
98987: PUSH
98988: LD_VAR 0 4
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: ST_TO_ADDR
// break ;
98997: GO 99001
// end ; end ;
98999: GO 98801
99001: POP
99002: POP
// if result then
99003: LD_VAR 0 1
99007: IFFALSE 99067
// begin ToLua ( playSibBomb() ) ;
99009: LD_STRING playSibBomb()
99011: PPUSH
99012: CALL_OW 559
// wait ( 0 0$14 ) ;
99016: LD_INT 490
99018: PPUSH
99019: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
99023: LD_VAR 0 1
99027: PUSH
99028: LD_INT 1
99030: ARRAY
99031: PPUSH
99032: LD_VAR 0 1
99036: PUSH
99037: LD_INT 2
99039: ARRAY
99040: PPUSH
99041: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
99045: LD_VAR 0 1
99049: PUSH
99050: LD_INT 1
99052: ARRAY
99053: PPUSH
99054: LD_VAR 0 1
99058: PUSH
99059: LD_INT 2
99061: ARRAY
99062: PPUSH
99063: CALL_OW 429
// end ; end ;
99067: LD_VAR 0 1
99071: RET
// every 0 0$1 trigger StreamModeActive and sReset do
99072: LD_EXP 98
99076: PUSH
99077: LD_EXP 120
99081: AND
99082: IFFALSE 99094
99084: GO 99086
99086: DISABLE
// YouLost (  ) ;
99087: LD_STRING 
99089: PPUSH
99090: CALL_OW 104
99094: END
// every 0 0$1 trigger StreamModeActive and sFog do
99095: LD_EXP 98
99099: PUSH
99100: LD_EXP 119
99104: AND
99105: IFFALSE 99119
99107: GO 99109
99109: DISABLE
// FogOff ( your_side ) ;
99110: LD_OWVAR 2
99114: PPUSH
99115: CALL_OW 344
99119: END
// every 0 0$1 trigger StreamModeActive and sSun do
99120: LD_EXP 98
99124: PUSH
99125: LD_EXP 121
99129: AND
99130: IFFALSE 99158
99132: GO 99134
99134: DISABLE
// begin solar_recharge_percent := 0 ;
99135: LD_ADDR_OWVAR 79
99139: PUSH
99140: LD_INT 0
99142: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99143: LD_INT 10500
99145: PPUSH
99146: CALL_OW 67
// solar_recharge_percent := 100 ;
99150: LD_ADDR_OWVAR 79
99154: PUSH
99155: LD_INT 100
99157: ST_TO_ADDR
// end ;
99158: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99159: LD_EXP 98
99163: PUSH
99164: LD_EXP 122
99168: AND
99169: IFFALSE 99408
99171: GO 99173
99173: DISABLE
99174: LD_INT 0
99176: PPUSH
99177: PPUSH
99178: PPUSH
// begin tmp := [ ] ;
99179: LD_ADDR_VAR 0 3
99183: PUSH
99184: EMPTY
99185: ST_TO_ADDR
// for i := 1 to 6 do
99186: LD_ADDR_VAR 0 1
99190: PUSH
99191: DOUBLE
99192: LD_INT 1
99194: DEC
99195: ST_TO_ADDR
99196: LD_INT 6
99198: PUSH
99199: FOR_TO
99200: IFFALSE 99305
// begin uc_nation := nation_nature ;
99202: LD_ADDR_OWVAR 21
99206: PUSH
99207: LD_INT 0
99209: ST_TO_ADDR
// uc_side := 0 ;
99210: LD_ADDR_OWVAR 20
99214: PUSH
99215: LD_INT 0
99217: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99218: LD_ADDR_OWVAR 29
99222: PUSH
99223: LD_INT 12
99225: PUSH
99226: LD_INT 12
99228: PUSH
99229: EMPTY
99230: LIST
99231: LIST
99232: ST_TO_ADDR
// hc_agressivity := 20 ;
99233: LD_ADDR_OWVAR 35
99237: PUSH
99238: LD_INT 20
99240: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99241: LD_ADDR_OWVAR 28
99245: PUSH
99246: LD_INT 17
99248: ST_TO_ADDR
// hc_gallery :=  ;
99249: LD_ADDR_OWVAR 33
99253: PUSH
99254: LD_STRING 
99256: ST_TO_ADDR
// hc_name :=  ;
99257: LD_ADDR_OWVAR 26
99261: PUSH
99262: LD_STRING 
99264: ST_TO_ADDR
// un := CreateHuman ;
99265: LD_ADDR_VAR 0 2
99269: PUSH
99270: CALL_OW 44
99274: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99275: LD_VAR 0 2
99279: PPUSH
99280: LD_INT 1
99282: PPUSH
99283: CALL_OW 51
// tmp := tmp ^ un ;
99287: LD_ADDR_VAR 0 3
99291: PUSH
99292: LD_VAR 0 3
99296: PUSH
99297: LD_VAR 0 2
99301: ADD
99302: ST_TO_ADDR
// end ;
99303: GO 99199
99305: POP
99306: POP
// repeat wait ( 0 0$1 ) ;
99307: LD_INT 35
99309: PPUSH
99310: CALL_OW 67
// for un in tmp do
99314: LD_ADDR_VAR 0 2
99318: PUSH
99319: LD_VAR 0 3
99323: PUSH
99324: FOR_IN
99325: IFFALSE 99399
// begin if IsDead ( un ) then
99327: LD_VAR 0 2
99331: PPUSH
99332: CALL_OW 301
99336: IFFALSE 99356
// begin tmp := tmp diff un ;
99338: LD_ADDR_VAR 0 3
99342: PUSH
99343: LD_VAR 0 3
99347: PUSH
99348: LD_VAR 0 2
99352: DIFF
99353: ST_TO_ADDR
// continue ;
99354: GO 99324
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99356: LD_VAR 0 2
99360: PPUSH
99361: LD_INT 3
99363: PUSH
99364: LD_INT 22
99366: PUSH
99367: LD_INT 0
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: PUSH
99374: EMPTY
99375: LIST
99376: LIST
99377: PPUSH
99378: CALL_OW 69
99382: PPUSH
99383: LD_VAR 0 2
99387: PPUSH
99388: CALL_OW 74
99392: PPUSH
99393: CALL_OW 115
// end ;
99397: GO 99324
99399: POP
99400: POP
// until not tmp ;
99401: LD_VAR 0 3
99405: NOT
99406: IFFALSE 99307
// end ;
99408: PPOPN 3
99410: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99411: LD_EXP 98
99415: PUSH
99416: LD_EXP 123
99420: AND
99421: IFFALSE 99475
99423: GO 99425
99425: DISABLE
// begin ToLua ( displayTroll(); ) ;
99426: LD_STRING displayTroll();
99428: PPUSH
99429: CALL_OW 559
// wait ( 3 3$00 ) ;
99433: LD_INT 6300
99435: PPUSH
99436: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99440: LD_STRING hideTroll();
99442: PPUSH
99443: CALL_OW 559
// wait ( 1 1$00 ) ;
99447: LD_INT 2100
99449: PPUSH
99450: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99454: LD_STRING displayTroll();
99456: PPUSH
99457: CALL_OW 559
// wait ( 1 1$00 ) ;
99461: LD_INT 2100
99463: PPUSH
99464: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99468: LD_STRING hideTroll();
99470: PPUSH
99471: CALL_OW 559
// end ;
99475: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99476: LD_EXP 98
99480: PUSH
99481: LD_EXP 124
99485: AND
99486: IFFALSE 99549
99488: GO 99490
99490: DISABLE
99491: LD_INT 0
99493: PPUSH
// begin p := 0 ;
99494: LD_ADDR_VAR 0 1
99498: PUSH
99499: LD_INT 0
99501: ST_TO_ADDR
// repeat game_speed := 1 ;
99502: LD_ADDR_OWVAR 65
99506: PUSH
99507: LD_INT 1
99509: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99510: LD_INT 35
99512: PPUSH
99513: CALL_OW 67
// p := p + 1 ;
99517: LD_ADDR_VAR 0 1
99521: PUSH
99522: LD_VAR 0 1
99526: PUSH
99527: LD_INT 1
99529: PLUS
99530: ST_TO_ADDR
// until p >= 60 ;
99531: LD_VAR 0 1
99535: PUSH
99536: LD_INT 60
99538: GREATEREQUAL
99539: IFFALSE 99502
// game_speed := 4 ;
99541: LD_ADDR_OWVAR 65
99545: PUSH
99546: LD_INT 4
99548: ST_TO_ADDR
// end ;
99549: PPOPN 1
99551: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99552: LD_EXP 98
99556: PUSH
99557: LD_EXP 125
99561: AND
99562: IFFALSE 99708
99564: GO 99566
99566: DISABLE
99567: LD_INT 0
99569: PPUSH
99570: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99571: LD_ADDR_VAR 0 1
99575: PUSH
99576: LD_INT 22
99578: PUSH
99579: LD_OWVAR 2
99583: PUSH
99584: EMPTY
99585: LIST
99586: LIST
99587: PUSH
99588: LD_INT 2
99590: PUSH
99591: LD_INT 30
99593: PUSH
99594: LD_INT 0
99596: PUSH
99597: EMPTY
99598: LIST
99599: LIST
99600: PUSH
99601: LD_INT 30
99603: PUSH
99604: LD_INT 1
99606: PUSH
99607: EMPTY
99608: LIST
99609: LIST
99610: PUSH
99611: EMPTY
99612: LIST
99613: LIST
99614: LIST
99615: PUSH
99616: EMPTY
99617: LIST
99618: LIST
99619: PPUSH
99620: CALL_OW 69
99624: ST_TO_ADDR
// if not depot then
99625: LD_VAR 0 1
99629: NOT
99630: IFFALSE 99634
// exit ;
99632: GO 99708
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99634: LD_ADDR_VAR 0 2
99638: PUSH
99639: LD_VAR 0 1
99643: PUSH
99644: LD_INT 1
99646: PPUSH
99647: LD_VAR 0 1
99651: PPUSH
99652: CALL_OW 12
99656: ARRAY
99657: PPUSH
99658: CALL_OW 274
99662: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99663: LD_VAR 0 2
99667: PPUSH
99668: LD_INT 1
99670: PPUSH
99671: LD_INT 0
99673: PPUSH
99674: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99678: LD_VAR 0 2
99682: PPUSH
99683: LD_INT 2
99685: PPUSH
99686: LD_INT 0
99688: PPUSH
99689: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99693: LD_VAR 0 2
99697: PPUSH
99698: LD_INT 3
99700: PPUSH
99701: LD_INT 0
99703: PPUSH
99704: CALL_OW 277
// end ;
99708: PPOPN 2
99710: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99711: LD_EXP 98
99715: PUSH
99716: LD_EXP 126
99720: AND
99721: IFFALSE 99818
99723: GO 99725
99725: DISABLE
99726: LD_INT 0
99728: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99729: LD_ADDR_VAR 0 1
99733: PUSH
99734: LD_INT 22
99736: PUSH
99737: LD_OWVAR 2
99741: PUSH
99742: EMPTY
99743: LIST
99744: LIST
99745: PUSH
99746: LD_INT 21
99748: PUSH
99749: LD_INT 1
99751: PUSH
99752: EMPTY
99753: LIST
99754: LIST
99755: PUSH
99756: LD_INT 3
99758: PUSH
99759: LD_INT 23
99761: PUSH
99762: LD_INT 0
99764: PUSH
99765: EMPTY
99766: LIST
99767: LIST
99768: PUSH
99769: EMPTY
99770: LIST
99771: LIST
99772: PUSH
99773: EMPTY
99774: LIST
99775: LIST
99776: LIST
99777: PPUSH
99778: CALL_OW 69
99782: ST_TO_ADDR
// if not tmp then
99783: LD_VAR 0 1
99787: NOT
99788: IFFALSE 99792
// exit ;
99790: GO 99818
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99792: LD_VAR 0 1
99796: PUSH
99797: LD_INT 1
99799: PPUSH
99800: LD_VAR 0 1
99804: PPUSH
99805: CALL_OW 12
99809: ARRAY
99810: PPUSH
99811: LD_INT 200
99813: PPUSH
99814: CALL_OW 234
// end ;
99818: PPOPN 1
99820: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99821: LD_EXP 98
99825: PUSH
99826: LD_EXP 127
99830: AND
99831: IFFALSE 99910
99833: GO 99835
99835: DISABLE
99836: LD_INT 0
99838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99839: LD_ADDR_VAR 0 1
99843: PUSH
99844: LD_INT 22
99846: PUSH
99847: LD_OWVAR 2
99851: PUSH
99852: EMPTY
99853: LIST
99854: LIST
99855: PUSH
99856: LD_INT 21
99858: PUSH
99859: LD_INT 2
99861: PUSH
99862: EMPTY
99863: LIST
99864: LIST
99865: PUSH
99866: EMPTY
99867: LIST
99868: LIST
99869: PPUSH
99870: CALL_OW 69
99874: ST_TO_ADDR
// if not tmp then
99875: LD_VAR 0 1
99879: NOT
99880: IFFALSE 99884
// exit ;
99882: GO 99910
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99884: LD_VAR 0 1
99888: PUSH
99889: LD_INT 1
99891: PPUSH
99892: LD_VAR 0 1
99896: PPUSH
99897: CALL_OW 12
99901: ARRAY
99902: PPUSH
99903: LD_INT 60
99905: PPUSH
99906: CALL_OW 234
// end ;
99910: PPOPN 1
99912: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99913: LD_EXP 98
99917: PUSH
99918: LD_EXP 128
99922: AND
99923: IFFALSE 100022
99925: GO 99927
99927: DISABLE
99928: LD_INT 0
99930: PPUSH
99931: PPUSH
// begin enable ;
99932: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99933: LD_ADDR_VAR 0 1
99937: PUSH
99938: LD_INT 22
99940: PUSH
99941: LD_OWVAR 2
99945: PUSH
99946: EMPTY
99947: LIST
99948: LIST
99949: PUSH
99950: LD_INT 61
99952: PUSH
99953: EMPTY
99954: LIST
99955: PUSH
99956: LD_INT 33
99958: PUSH
99959: LD_INT 2
99961: PUSH
99962: EMPTY
99963: LIST
99964: LIST
99965: PUSH
99966: EMPTY
99967: LIST
99968: LIST
99969: LIST
99970: PPUSH
99971: CALL_OW 69
99975: ST_TO_ADDR
// if not tmp then
99976: LD_VAR 0 1
99980: NOT
99981: IFFALSE 99985
// exit ;
99983: GO 100022
// for i in tmp do
99985: LD_ADDR_VAR 0 2
99989: PUSH
99990: LD_VAR 0 1
99994: PUSH
99995: FOR_IN
99996: IFFALSE 100020
// if IsControledBy ( i ) then
99998: LD_VAR 0 2
100002: PPUSH
100003: CALL_OW 312
100007: IFFALSE 100018
// ComUnlink ( i ) ;
100009: LD_VAR 0 2
100013: PPUSH
100014: CALL_OW 136
100018: GO 99995
100020: POP
100021: POP
// end ;
100022: PPOPN 2
100024: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
100025: LD_EXP 98
100029: PUSH
100030: LD_EXP 129
100034: AND
100035: IFFALSE 100175
100037: GO 100039
100039: DISABLE
100040: LD_INT 0
100042: PPUSH
100043: PPUSH
// begin ToLua ( displayPowell(); ) ;
100044: LD_STRING displayPowell();
100046: PPUSH
100047: CALL_OW 559
// uc_side := 0 ;
100051: LD_ADDR_OWVAR 20
100055: PUSH
100056: LD_INT 0
100058: ST_TO_ADDR
// uc_nation := 2 ;
100059: LD_ADDR_OWVAR 21
100063: PUSH
100064: LD_INT 2
100066: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
100067: LD_ADDR_OWVAR 37
100071: PUSH
100072: LD_INT 14
100074: ST_TO_ADDR
// vc_engine := engine_siberite ;
100075: LD_ADDR_OWVAR 39
100079: PUSH
100080: LD_INT 3
100082: ST_TO_ADDR
// vc_control := control_apeman ;
100083: LD_ADDR_OWVAR 38
100087: PUSH
100088: LD_INT 5
100090: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100091: LD_ADDR_OWVAR 40
100095: PUSH
100096: LD_INT 29
100098: ST_TO_ADDR
// un := CreateVehicle ;
100099: LD_ADDR_VAR 0 2
100103: PUSH
100104: CALL_OW 45
100108: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100109: LD_VAR 0 2
100113: PPUSH
100114: LD_INT 1
100116: PPUSH
100117: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100121: LD_INT 35
100123: PPUSH
100124: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100128: LD_VAR 0 2
100132: PPUSH
100133: LD_INT 22
100135: PUSH
100136: LD_OWVAR 2
100140: PUSH
100141: EMPTY
100142: LIST
100143: LIST
100144: PPUSH
100145: CALL_OW 69
100149: PPUSH
100150: LD_VAR 0 2
100154: PPUSH
100155: CALL_OW 74
100159: PPUSH
100160: CALL_OW 115
// until IsDead ( un ) ;
100164: LD_VAR 0 2
100168: PPUSH
100169: CALL_OW 301
100173: IFFALSE 100121
// end ;
100175: PPOPN 2
100177: END
// every 0 0$1 trigger StreamModeActive and sStu do
100178: LD_EXP 98
100182: PUSH
100183: LD_EXP 137
100187: AND
100188: IFFALSE 100204
100190: GO 100192
100192: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100193: LD_STRING displayStucuk();
100195: PPUSH
100196: CALL_OW 559
// ResetFog ;
100200: CALL_OW 335
// end ;
100204: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100205: LD_EXP 98
100209: PUSH
100210: LD_EXP 130
100214: AND
100215: IFFALSE 100356
100217: GO 100219
100219: DISABLE
100220: LD_INT 0
100222: PPUSH
100223: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100224: LD_ADDR_VAR 0 2
100228: PUSH
100229: LD_INT 22
100231: PUSH
100232: LD_OWVAR 2
100236: PUSH
100237: EMPTY
100238: LIST
100239: LIST
100240: PUSH
100241: LD_INT 21
100243: PUSH
100244: LD_INT 1
100246: PUSH
100247: EMPTY
100248: LIST
100249: LIST
100250: PUSH
100251: EMPTY
100252: LIST
100253: LIST
100254: PPUSH
100255: CALL_OW 69
100259: ST_TO_ADDR
// if not tmp then
100260: LD_VAR 0 2
100264: NOT
100265: IFFALSE 100269
// exit ;
100267: GO 100356
// un := tmp [ rand ( 1 , tmp ) ] ;
100269: LD_ADDR_VAR 0 1
100273: PUSH
100274: LD_VAR 0 2
100278: PUSH
100279: LD_INT 1
100281: PPUSH
100282: LD_VAR 0 2
100286: PPUSH
100287: CALL_OW 12
100291: ARRAY
100292: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100293: LD_VAR 0 1
100297: PPUSH
100298: LD_INT 0
100300: PPUSH
100301: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100305: LD_VAR 0 1
100309: PPUSH
100310: LD_OWVAR 3
100314: PUSH
100315: LD_VAR 0 1
100319: DIFF
100320: PPUSH
100321: LD_VAR 0 1
100325: PPUSH
100326: CALL_OW 74
100330: PPUSH
100331: CALL_OW 115
// wait ( 0 0$20 ) ;
100335: LD_INT 700
100337: PPUSH
100338: CALL_OW 67
// SetSide ( un , your_side ) ;
100342: LD_VAR 0 1
100346: PPUSH
100347: LD_OWVAR 2
100351: PPUSH
100352: CALL_OW 235
// end ;
100356: PPOPN 2
100358: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100359: LD_EXP 98
100363: PUSH
100364: LD_EXP 131
100368: AND
100369: IFFALSE 100475
100371: GO 100373
100373: DISABLE
100374: LD_INT 0
100376: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100377: LD_ADDR_VAR 0 1
100381: PUSH
100382: LD_INT 22
100384: PUSH
100385: LD_OWVAR 2
100389: PUSH
100390: EMPTY
100391: LIST
100392: LIST
100393: PUSH
100394: LD_INT 2
100396: PUSH
100397: LD_INT 30
100399: PUSH
100400: LD_INT 0
100402: PUSH
100403: EMPTY
100404: LIST
100405: LIST
100406: PUSH
100407: LD_INT 30
100409: PUSH
100410: LD_INT 1
100412: PUSH
100413: EMPTY
100414: LIST
100415: LIST
100416: PUSH
100417: EMPTY
100418: LIST
100419: LIST
100420: LIST
100421: PUSH
100422: EMPTY
100423: LIST
100424: LIST
100425: PPUSH
100426: CALL_OW 69
100430: ST_TO_ADDR
// if not depot then
100431: LD_VAR 0 1
100435: NOT
100436: IFFALSE 100440
// exit ;
100438: GO 100475
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100440: LD_VAR 0 1
100444: PUSH
100445: LD_INT 1
100447: ARRAY
100448: PPUSH
100449: CALL_OW 250
100453: PPUSH
100454: LD_VAR 0 1
100458: PUSH
100459: LD_INT 1
100461: ARRAY
100462: PPUSH
100463: CALL_OW 251
100467: PPUSH
100468: LD_INT 70
100470: PPUSH
100471: CALL_OW 495
// end ;
100475: PPOPN 1
100477: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100478: LD_EXP 98
100482: PUSH
100483: LD_EXP 132
100487: AND
100488: IFFALSE 100699
100490: GO 100492
100492: DISABLE
100493: LD_INT 0
100495: PPUSH
100496: PPUSH
100497: PPUSH
100498: PPUSH
100499: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100500: LD_ADDR_VAR 0 5
100504: PUSH
100505: LD_INT 22
100507: PUSH
100508: LD_OWVAR 2
100512: PUSH
100513: EMPTY
100514: LIST
100515: LIST
100516: PUSH
100517: LD_INT 21
100519: PUSH
100520: LD_INT 1
100522: PUSH
100523: EMPTY
100524: LIST
100525: LIST
100526: PUSH
100527: EMPTY
100528: LIST
100529: LIST
100530: PPUSH
100531: CALL_OW 69
100535: ST_TO_ADDR
// if not tmp then
100536: LD_VAR 0 5
100540: NOT
100541: IFFALSE 100545
// exit ;
100543: GO 100699
// for i in tmp do
100545: LD_ADDR_VAR 0 1
100549: PUSH
100550: LD_VAR 0 5
100554: PUSH
100555: FOR_IN
100556: IFFALSE 100697
// begin d := rand ( 0 , 5 ) ;
100558: LD_ADDR_VAR 0 4
100562: PUSH
100563: LD_INT 0
100565: PPUSH
100566: LD_INT 5
100568: PPUSH
100569: CALL_OW 12
100573: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100574: LD_ADDR_VAR 0 2
100578: PUSH
100579: LD_VAR 0 1
100583: PPUSH
100584: CALL_OW 250
100588: PPUSH
100589: LD_VAR 0 4
100593: PPUSH
100594: LD_INT 3
100596: PPUSH
100597: LD_INT 12
100599: PPUSH
100600: CALL_OW 12
100604: PPUSH
100605: CALL_OW 272
100609: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100610: LD_ADDR_VAR 0 3
100614: PUSH
100615: LD_VAR 0 1
100619: PPUSH
100620: CALL_OW 251
100624: PPUSH
100625: LD_VAR 0 4
100629: PPUSH
100630: LD_INT 3
100632: PPUSH
100633: LD_INT 12
100635: PPUSH
100636: CALL_OW 12
100640: PPUSH
100641: CALL_OW 273
100645: ST_TO_ADDR
// if ValidHex ( x , y ) then
100646: LD_VAR 0 2
100650: PPUSH
100651: LD_VAR 0 3
100655: PPUSH
100656: CALL_OW 488
100660: IFFALSE 100695
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100662: LD_VAR 0 1
100666: PPUSH
100667: LD_VAR 0 2
100671: PPUSH
100672: LD_VAR 0 3
100676: PPUSH
100677: LD_INT 3
100679: PPUSH
100680: LD_INT 6
100682: PPUSH
100683: CALL_OW 12
100687: PPUSH
100688: LD_INT 1
100690: PPUSH
100691: CALL_OW 483
// end ;
100695: GO 100555
100697: POP
100698: POP
// end ;
100699: PPOPN 5
100701: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100702: LD_EXP 98
100706: PUSH
100707: LD_EXP 133
100711: AND
100712: IFFALSE 100806
100714: GO 100716
100716: DISABLE
100717: LD_INT 0
100719: PPUSH
100720: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100721: LD_ADDR_VAR 0 2
100725: PUSH
100726: LD_INT 22
100728: PUSH
100729: LD_OWVAR 2
100733: PUSH
100734: EMPTY
100735: LIST
100736: LIST
100737: PUSH
100738: LD_INT 32
100740: PUSH
100741: LD_INT 1
100743: PUSH
100744: EMPTY
100745: LIST
100746: LIST
100747: PUSH
100748: LD_INT 21
100750: PUSH
100751: LD_INT 2
100753: PUSH
100754: EMPTY
100755: LIST
100756: LIST
100757: PUSH
100758: EMPTY
100759: LIST
100760: LIST
100761: LIST
100762: PPUSH
100763: CALL_OW 69
100767: ST_TO_ADDR
// if not tmp then
100768: LD_VAR 0 2
100772: NOT
100773: IFFALSE 100777
// exit ;
100775: GO 100806
// for i in tmp do
100777: LD_ADDR_VAR 0 1
100781: PUSH
100782: LD_VAR 0 2
100786: PUSH
100787: FOR_IN
100788: IFFALSE 100804
// SetFuel ( i , 0 ) ;
100790: LD_VAR 0 1
100794: PPUSH
100795: LD_INT 0
100797: PPUSH
100798: CALL_OW 240
100802: GO 100787
100804: POP
100805: POP
// end ;
100806: PPOPN 2
100808: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100809: LD_EXP 98
100813: PUSH
100814: LD_EXP 134
100818: AND
100819: IFFALSE 100885
100821: GO 100823
100823: DISABLE
100824: LD_INT 0
100826: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100827: LD_ADDR_VAR 0 1
100831: PUSH
100832: LD_INT 22
100834: PUSH
100835: LD_OWVAR 2
100839: PUSH
100840: EMPTY
100841: LIST
100842: LIST
100843: PUSH
100844: LD_INT 30
100846: PUSH
100847: LD_INT 29
100849: PUSH
100850: EMPTY
100851: LIST
100852: LIST
100853: PUSH
100854: EMPTY
100855: LIST
100856: LIST
100857: PPUSH
100858: CALL_OW 69
100862: ST_TO_ADDR
// if not tmp then
100863: LD_VAR 0 1
100867: NOT
100868: IFFALSE 100872
// exit ;
100870: GO 100885
// DestroyUnit ( tmp [ 1 ] ) ;
100872: LD_VAR 0 1
100876: PUSH
100877: LD_INT 1
100879: ARRAY
100880: PPUSH
100881: CALL_OW 65
// end ;
100885: PPOPN 1
100887: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100888: LD_EXP 98
100892: PUSH
100893: LD_EXP 136
100897: AND
100898: IFFALSE 101027
100900: GO 100902
100902: DISABLE
100903: LD_INT 0
100905: PPUSH
// begin uc_side := 0 ;
100906: LD_ADDR_OWVAR 20
100910: PUSH
100911: LD_INT 0
100913: ST_TO_ADDR
// uc_nation := nation_arabian ;
100914: LD_ADDR_OWVAR 21
100918: PUSH
100919: LD_INT 2
100921: ST_TO_ADDR
// hc_gallery :=  ;
100922: LD_ADDR_OWVAR 33
100926: PUSH
100927: LD_STRING 
100929: ST_TO_ADDR
// hc_name :=  ;
100930: LD_ADDR_OWVAR 26
100934: PUSH
100935: LD_STRING 
100937: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100938: LD_INT 1
100940: PPUSH
100941: LD_INT 11
100943: PPUSH
100944: LD_INT 10
100946: PPUSH
100947: CALL_OW 380
// un := CreateHuman ;
100951: LD_ADDR_VAR 0 1
100955: PUSH
100956: CALL_OW 44
100960: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100961: LD_VAR 0 1
100965: PPUSH
100966: LD_INT 1
100968: PPUSH
100969: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100973: LD_INT 35
100975: PPUSH
100976: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100980: LD_VAR 0 1
100984: PPUSH
100985: LD_INT 22
100987: PUSH
100988: LD_OWVAR 2
100992: PUSH
100993: EMPTY
100994: LIST
100995: LIST
100996: PPUSH
100997: CALL_OW 69
101001: PPUSH
101002: LD_VAR 0 1
101006: PPUSH
101007: CALL_OW 74
101011: PPUSH
101012: CALL_OW 115
// until IsDead ( un ) ;
101016: LD_VAR 0 1
101020: PPUSH
101021: CALL_OW 301
101025: IFFALSE 100973
// end ;
101027: PPOPN 1
101029: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
101030: LD_EXP 98
101034: PUSH
101035: LD_EXP 138
101039: AND
101040: IFFALSE 101052
101042: GO 101044
101044: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
101045: LD_STRING earthquake(getX(game), 0, 32)
101047: PPUSH
101048: CALL_OW 559
101052: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
101053: LD_EXP 98
101057: PUSH
101058: LD_EXP 139
101062: AND
101063: IFFALSE 101154
101065: GO 101067
101067: DISABLE
101068: LD_INT 0
101070: PPUSH
// begin enable ;
101071: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
101072: LD_ADDR_VAR 0 1
101076: PUSH
101077: LD_INT 22
101079: PUSH
101080: LD_OWVAR 2
101084: PUSH
101085: EMPTY
101086: LIST
101087: LIST
101088: PUSH
101089: LD_INT 21
101091: PUSH
101092: LD_INT 2
101094: PUSH
101095: EMPTY
101096: LIST
101097: LIST
101098: PUSH
101099: LD_INT 33
101101: PUSH
101102: LD_INT 3
101104: PUSH
101105: EMPTY
101106: LIST
101107: LIST
101108: PUSH
101109: EMPTY
101110: LIST
101111: LIST
101112: LIST
101113: PPUSH
101114: CALL_OW 69
101118: ST_TO_ADDR
// if not tmp then
101119: LD_VAR 0 1
101123: NOT
101124: IFFALSE 101128
// exit ;
101126: GO 101154
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101128: LD_VAR 0 1
101132: PUSH
101133: LD_INT 1
101135: PPUSH
101136: LD_VAR 0 1
101140: PPUSH
101141: CALL_OW 12
101145: ARRAY
101146: PPUSH
101147: LD_INT 1
101149: PPUSH
101150: CALL_OW 234
// end ;
101154: PPOPN 1
101156: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101157: LD_EXP 98
101161: PUSH
101162: LD_EXP 140
101166: AND
101167: IFFALSE 101308
101169: GO 101171
101171: DISABLE
101172: LD_INT 0
101174: PPUSH
101175: PPUSH
101176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101177: LD_ADDR_VAR 0 3
101181: PUSH
101182: LD_INT 22
101184: PUSH
101185: LD_OWVAR 2
101189: PUSH
101190: EMPTY
101191: LIST
101192: LIST
101193: PUSH
101194: LD_INT 25
101196: PUSH
101197: LD_INT 1
101199: PUSH
101200: EMPTY
101201: LIST
101202: LIST
101203: PUSH
101204: EMPTY
101205: LIST
101206: LIST
101207: PPUSH
101208: CALL_OW 69
101212: ST_TO_ADDR
// if not tmp then
101213: LD_VAR 0 3
101217: NOT
101218: IFFALSE 101222
// exit ;
101220: GO 101308
// un := tmp [ rand ( 1 , tmp ) ] ;
101222: LD_ADDR_VAR 0 2
101226: PUSH
101227: LD_VAR 0 3
101231: PUSH
101232: LD_INT 1
101234: PPUSH
101235: LD_VAR 0 3
101239: PPUSH
101240: CALL_OW 12
101244: ARRAY
101245: ST_TO_ADDR
// if Crawls ( un ) then
101246: LD_VAR 0 2
101250: PPUSH
101251: CALL_OW 318
101255: IFFALSE 101266
// ComWalk ( un ) ;
101257: LD_VAR 0 2
101261: PPUSH
101262: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101266: LD_VAR 0 2
101270: PPUSH
101271: LD_INT 9
101273: PPUSH
101274: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101278: LD_INT 28
101280: PPUSH
101281: LD_OWVAR 2
101285: PPUSH
101286: LD_INT 2
101288: PPUSH
101289: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101293: LD_INT 29
101295: PPUSH
101296: LD_OWVAR 2
101300: PPUSH
101301: LD_INT 2
101303: PPUSH
101304: CALL_OW 322
// end ;
101308: PPOPN 3
101310: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101311: LD_EXP 98
101315: PUSH
101316: LD_EXP 141
101320: AND
101321: IFFALSE 101432
101323: GO 101325
101325: DISABLE
101326: LD_INT 0
101328: PPUSH
101329: PPUSH
101330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101331: LD_ADDR_VAR 0 3
101335: PUSH
101336: LD_INT 22
101338: PUSH
101339: LD_OWVAR 2
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: PUSH
101348: LD_INT 25
101350: PUSH
101351: LD_INT 1
101353: PUSH
101354: EMPTY
101355: LIST
101356: LIST
101357: PUSH
101358: EMPTY
101359: LIST
101360: LIST
101361: PPUSH
101362: CALL_OW 69
101366: ST_TO_ADDR
// if not tmp then
101367: LD_VAR 0 3
101371: NOT
101372: IFFALSE 101376
// exit ;
101374: GO 101432
// un := tmp [ rand ( 1 , tmp ) ] ;
101376: LD_ADDR_VAR 0 2
101380: PUSH
101381: LD_VAR 0 3
101385: PUSH
101386: LD_INT 1
101388: PPUSH
101389: LD_VAR 0 3
101393: PPUSH
101394: CALL_OW 12
101398: ARRAY
101399: ST_TO_ADDR
// if Crawls ( un ) then
101400: LD_VAR 0 2
101404: PPUSH
101405: CALL_OW 318
101409: IFFALSE 101420
// ComWalk ( un ) ;
101411: LD_VAR 0 2
101415: PPUSH
101416: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101420: LD_VAR 0 2
101424: PPUSH
101425: LD_INT 8
101427: PPUSH
101428: CALL_OW 336
// end ;
101432: PPOPN 3
101434: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101435: LD_EXP 98
101439: PUSH
101440: LD_EXP 142
101444: AND
101445: IFFALSE 101589
101447: GO 101449
101449: DISABLE
101450: LD_INT 0
101452: PPUSH
101453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101454: LD_ADDR_VAR 0 2
101458: PUSH
101459: LD_INT 22
101461: PUSH
101462: LD_OWVAR 2
101466: PUSH
101467: EMPTY
101468: LIST
101469: LIST
101470: PUSH
101471: LD_INT 21
101473: PUSH
101474: LD_INT 2
101476: PUSH
101477: EMPTY
101478: LIST
101479: LIST
101480: PUSH
101481: LD_INT 2
101483: PUSH
101484: LD_INT 34
101486: PUSH
101487: LD_INT 12
101489: PUSH
101490: EMPTY
101491: LIST
101492: LIST
101493: PUSH
101494: LD_INT 34
101496: PUSH
101497: LD_INT 51
101499: PUSH
101500: EMPTY
101501: LIST
101502: LIST
101503: PUSH
101504: LD_INT 34
101506: PUSH
101507: LD_INT 32
101509: PUSH
101510: EMPTY
101511: LIST
101512: LIST
101513: PUSH
101514: EMPTY
101515: LIST
101516: LIST
101517: LIST
101518: LIST
101519: PUSH
101520: EMPTY
101521: LIST
101522: LIST
101523: LIST
101524: PPUSH
101525: CALL_OW 69
101529: ST_TO_ADDR
// if not tmp then
101530: LD_VAR 0 2
101534: NOT
101535: IFFALSE 101539
// exit ;
101537: GO 101589
// for i in tmp do
101539: LD_ADDR_VAR 0 1
101543: PUSH
101544: LD_VAR 0 2
101548: PUSH
101549: FOR_IN
101550: IFFALSE 101587
// if GetCargo ( i , mat_artifact ) = 0 then
101552: LD_VAR 0 1
101556: PPUSH
101557: LD_INT 4
101559: PPUSH
101560: CALL_OW 289
101564: PUSH
101565: LD_INT 0
101567: EQUAL
101568: IFFALSE 101585
// SetCargo ( i , mat_siberit , 100 ) ;
101570: LD_VAR 0 1
101574: PPUSH
101575: LD_INT 3
101577: PPUSH
101578: LD_INT 100
101580: PPUSH
101581: CALL_OW 290
101585: GO 101549
101587: POP
101588: POP
// end ;
101589: PPOPN 2
101591: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101592: LD_EXP 98
101596: PUSH
101597: LD_EXP 143
101601: AND
101602: IFFALSE 101785
101604: GO 101606
101606: DISABLE
101607: LD_INT 0
101609: PPUSH
101610: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101611: LD_ADDR_VAR 0 2
101615: PUSH
101616: LD_INT 22
101618: PUSH
101619: LD_OWVAR 2
101623: PUSH
101624: EMPTY
101625: LIST
101626: LIST
101627: PPUSH
101628: CALL_OW 69
101632: ST_TO_ADDR
// if not tmp then
101633: LD_VAR 0 2
101637: NOT
101638: IFFALSE 101642
// exit ;
101640: GO 101785
// for i := 1 to 2 do
101642: LD_ADDR_VAR 0 1
101646: PUSH
101647: DOUBLE
101648: LD_INT 1
101650: DEC
101651: ST_TO_ADDR
101652: LD_INT 2
101654: PUSH
101655: FOR_TO
101656: IFFALSE 101783
// begin uc_side := your_side ;
101658: LD_ADDR_OWVAR 20
101662: PUSH
101663: LD_OWVAR 2
101667: ST_TO_ADDR
// uc_nation := nation_american ;
101668: LD_ADDR_OWVAR 21
101672: PUSH
101673: LD_INT 1
101675: ST_TO_ADDR
// vc_chassis := us_morphling ;
101676: LD_ADDR_OWVAR 37
101680: PUSH
101681: LD_INT 5
101683: ST_TO_ADDR
// vc_engine := engine_siberite ;
101684: LD_ADDR_OWVAR 39
101688: PUSH
101689: LD_INT 3
101691: ST_TO_ADDR
// vc_control := control_computer ;
101692: LD_ADDR_OWVAR 38
101696: PUSH
101697: LD_INT 3
101699: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101700: LD_ADDR_OWVAR 40
101704: PUSH
101705: LD_INT 10
101707: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101708: LD_VAR 0 2
101712: PUSH
101713: LD_INT 1
101715: ARRAY
101716: PPUSH
101717: CALL_OW 310
101721: NOT
101722: IFFALSE 101769
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101724: CALL_OW 45
101728: PPUSH
101729: LD_VAR 0 2
101733: PUSH
101734: LD_INT 1
101736: ARRAY
101737: PPUSH
101738: CALL_OW 250
101742: PPUSH
101743: LD_VAR 0 2
101747: PUSH
101748: LD_INT 1
101750: ARRAY
101751: PPUSH
101752: CALL_OW 251
101756: PPUSH
101757: LD_INT 12
101759: PPUSH
101760: LD_INT 1
101762: PPUSH
101763: CALL_OW 50
101767: GO 101781
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101769: CALL_OW 45
101773: PPUSH
101774: LD_INT 1
101776: PPUSH
101777: CALL_OW 51
// end ;
101781: GO 101655
101783: POP
101784: POP
// end ;
101785: PPOPN 2
101787: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101788: LD_EXP 98
101792: PUSH
101793: LD_EXP 144
101797: AND
101798: IFFALSE 102020
101800: GO 101802
101802: DISABLE
101803: LD_INT 0
101805: PPUSH
101806: PPUSH
101807: PPUSH
101808: PPUSH
101809: PPUSH
101810: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101811: LD_ADDR_VAR 0 6
101815: PUSH
101816: LD_INT 22
101818: PUSH
101819: LD_OWVAR 2
101823: PUSH
101824: EMPTY
101825: LIST
101826: LIST
101827: PUSH
101828: LD_INT 21
101830: PUSH
101831: LD_INT 1
101833: PUSH
101834: EMPTY
101835: LIST
101836: LIST
101837: PUSH
101838: LD_INT 3
101840: PUSH
101841: LD_INT 23
101843: PUSH
101844: LD_INT 0
101846: PUSH
101847: EMPTY
101848: LIST
101849: LIST
101850: PUSH
101851: EMPTY
101852: LIST
101853: LIST
101854: PUSH
101855: EMPTY
101856: LIST
101857: LIST
101858: LIST
101859: PPUSH
101860: CALL_OW 69
101864: ST_TO_ADDR
// if not tmp then
101865: LD_VAR 0 6
101869: NOT
101870: IFFALSE 101874
// exit ;
101872: GO 102020
// s1 := rand ( 1 , 4 ) ;
101874: LD_ADDR_VAR 0 2
101878: PUSH
101879: LD_INT 1
101881: PPUSH
101882: LD_INT 4
101884: PPUSH
101885: CALL_OW 12
101889: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101890: LD_ADDR_VAR 0 4
101894: PUSH
101895: LD_VAR 0 6
101899: PUSH
101900: LD_INT 1
101902: ARRAY
101903: PPUSH
101904: LD_VAR 0 2
101908: PPUSH
101909: CALL_OW 259
101913: ST_TO_ADDR
// if s1 = 1 then
101914: LD_VAR 0 2
101918: PUSH
101919: LD_INT 1
101921: EQUAL
101922: IFFALSE 101942
// s2 := rand ( 2 , 4 ) else
101924: LD_ADDR_VAR 0 3
101928: PUSH
101929: LD_INT 2
101931: PPUSH
101932: LD_INT 4
101934: PPUSH
101935: CALL_OW 12
101939: ST_TO_ADDR
101940: GO 101950
// s2 := 1 ;
101942: LD_ADDR_VAR 0 3
101946: PUSH
101947: LD_INT 1
101949: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101950: LD_ADDR_VAR 0 5
101954: PUSH
101955: LD_VAR 0 6
101959: PUSH
101960: LD_INT 1
101962: ARRAY
101963: PPUSH
101964: LD_VAR 0 3
101968: PPUSH
101969: CALL_OW 259
101973: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101974: LD_VAR 0 6
101978: PUSH
101979: LD_INT 1
101981: ARRAY
101982: PPUSH
101983: LD_VAR 0 2
101987: PPUSH
101988: LD_VAR 0 5
101992: PPUSH
101993: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101997: LD_VAR 0 6
102001: PUSH
102002: LD_INT 1
102004: ARRAY
102005: PPUSH
102006: LD_VAR 0 3
102010: PPUSH
102011: LD_VAR 0 4
102015: PPUSH
102016: CALL_OW 237
// end ;
102020: PPOPN 6
102022: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
102023: LD_EXP 98
102027: PUSH
102028: LD_EXP 145
102032: AND
102033: IFFALSE 102112
102035: GO 102037
102037: DISABLE
102038: LD_INT 0
102040: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
102041: LD_ADDR_VAR 0 1
102045: PUSH
102046: LD_INT 22
102048: PUSH
102049: LD_OWVAR 2
102053: PUSH
102054: EMPTY
102055: LIST
102056: LIST
102057: PUSH
102058: LD_INT 30
102060: PUSH
102061: LD_INT 3
102063: PUSH
102064: EMPTY
102065: LIST
102066: LIST
102067: PUSH
102068: EMPTY
102069: LIST
102070: LIST
102071: PPUSH
102072: CALL_OW 69
102076: ST_TO_ADDR
// if not tmp then
102077: LD_VAR 0 1
102081: NOT
102082: IFFALSE 102086
// exit ;
102084: GO 102112
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102086: LD_VAR 0 1
102090: PUSH
102091: LD_INT 1
102093: PPUSH
102094: LD_VAR 0 1
102098: PPUSH
102099: CALL_OW 12
102103: ARRAY
102104: PPUSH
102105: LD_INT 1
102107: PPUSH
102108: CALL_OW 234
// end ;
102112: PPOPN 1
102114: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102115: LD_EXP 98
102119: PUSH
102120: LD_EXP 146
102124: AND
102125: IFFALSE 102237
102127: GO 102129
102129: DISABLE
102130: LD_INT 0
102132: PPUSH
102133: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102134: LD_ADDR_VAR 0 2
102138: PUSH
102139: LD_INT 22
102141: PUSH
102142: LD_OWVAR 2
102146: PUSH
102147: EMPTY
102148: LIST
102149: LIST
102150: PUSH
102151: LD_INT 2
102153: PUSH
102154: LD_INT 30
102156: PUSH
102157: LD_INT 27
102159: PUSH
102160: EMPTY
102161: LIST
102162: LIST
102163: PUSH
102164: LD_INT 30
102166: PUSH
102167: LD_INT 26
102169: PUSH
102170: EMPTY
102171: LIST
102172: LIST
102173: PUSH
102174: LD_INT 30
102176: PUSH
102177: LD_INT 28
102179: PUSH
102180: EMPTY
102181: LIST
102182: LIST
102183: PUSH
102184: EMPTY
102185: LIST
102186: LIST
102187: LIST
102188: LIST
102189: PUSH
102190: EMPTY
102191: LIST
102192: LIST
102193: PPUSH
102194: CALL_OW 69
102198: ST_TO_ADDR
// if not tmp then
102199: LD_VAR 0 2
102203: NOT
102204: IFFALSE 102208
// exit ;
102206: GO 102237
// for i in tmp do
102208: LD_ADDR_VAR 0 1
102212: PUSH
102213: LD_VAR 0 2
102217: PUSH
102218: FOR_IN
102219: IFFALSE 102235
// SetLives ( i , 1 ) ;
102221: LD_VAR 0 1
102225: PPUSH
102226: LD_INT 1
102228: PPUSH
102229: CALL_OW 234
102233: GO 102218
102235: POP
102236: POP
// end ;
102237: PPOPN 2
102239: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102240: LD_EXP 98
102244: PUSH
102245: LD_EXP 147
102249: AND
102250: IFFALSE 102524
102252: GO 102254
102254: DISABLE
102255: LD_INT 0
102257: PPUSH
102258: PPUSH
102259: PPUSH
// begin i := rand ( 1 , 7 ) ;
102260: LD_ADDR_VAR 0 1
102264: PUSH
102265: LD_INT 1
102267: PPUSH
102268: LD_INT 7
102270: PPUSH
102271: CALL_OW 12
102275: ST_TO_ADDR
// case i of 1 :
102276: LD_VAR 0 1
102280: PUSH
102281: LD_INT 1
102283: DOUBLE
102284: EQUAL
102285: IFTRUE 102289
102287: GO 102299
102289: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102290: LD_STRING earthquake(getX(game), 0, 32)
102292: PPUSH
102293: CALL_OW 559
102297: GO 102524
102299: LD_INT 2
102301: DOUBLE
102302: EQUAL
102303: IFTRUE 102307
102305: GO 102321
102307: POP
// begin ToLua ( displayStucuk(); ) ;
102308: LD_STRING displayStucuk();
102310: PPUSH
102311: CALL_OW 559
// ResetFog ;
102315: CALL_OW 335
// end ; 3 :
102319: GO 102524
102321: LD_INT 3
102323: DOUBLE
102324: EQUAL
102325: IFTRUE 102329
102327: GO 102433
102329: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102330: LD_ADDR_VAR 0 2
102334: PUSH
102335: LD_INT 22
102337: PUSH
102338: LD_OWVAR 2
102342: PUSH
102343: EMPTY
102344: LIST
102345: LIST
102346: PUSH
102347: LD_INT 25
102349: PUSH
102350: LD_INT 1
102352: PUSH
102353: EMPTY
102354: LIST
102355: LIST
102356: PUSH
102357: EMPTY
102358: LIST
102359: LIST
102360: PPUSH
102361: CALL_OW 69
102365: ST_TO_ADDR
// if not tmp then
102366: LD_VAR 0 2
102370: NOT
102371: IFFALSE 102375
// exit ;
102373: GO 102524
// un := tmp [ rand ( 1 , tmp ) ] ;
102375: LD_ADDR_VAR 0 3
102379: PUSH
102380: LD_VAR 0 2
102384: PUSH
102385: LD_INT 1
102387: PPUSH
102388: LD_VAR 0 2
102392: PPUSH
102393: CALL_OW 12
102397: ARRAY
102398: ST_TO_ADDR
// if Crawls ( un ) then
102399: LD_VAR 0 3
102403: PPUSH
102404: CALL_OW 318
102408: IFFALSE 102419
// ComWalk ( un ) ;
102410: LD_VAR 0 3
102414: PPUSH
102415: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102419: LD_VAR 0 3
102423: PPUSH
102424: LD_INT 8
102426: PPUSH
102427: CALL_OW 336
// end ; 4 :
102431: GO 102524
102433: LD_INT 4
102435: DOUBLE
102436: EQUAL
102437: IFTRUE 102441
102439: GO 102502
102441: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102442: LD_ADDR_VAR 0 2
102446: PUSH
102447: LD_INT 22
102449: PUSH
102450: LD_OWVAR 2
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: PUSH
102459: LD_INT 30
102461: PUSH
102462: LD_INT 29
102464: PUSH
102465: EMPTY
102466: LIST
102467: LIST
102468: PUSH
102469: EMPTY
102470: LIST
102471: LIST
102472: PPUSH
102473: CALL_OW 69
102477: ST_TO_ADDR
// if not tmp then
102478: LD_VAR 0 2
102482: NOT
102483: IFFALSE 102487
// exit ;
102485: GO 102524
// DestroyUnit ( tmp [ 1 ] ) ;
102487: LD_VAR 0 2
102491: PUSH
102492: LD_INT 1
102494: ARRAY
102495: PPUSH
102496: CALL_OW 65
// end ; 5 .. 7 :
102500: GO 102524
102502: LD_INT 5
102504: DOUBLE
102505: GREATEREQUAL
102506: IFFALSE 102514
102508: LD_INT 7
102510: DOUBLE
102511: LESSEQUAL
102512: IFTRUE 102516
102514: GO 102523
102516: POP
// StreamSibBomb ; end ;
102517: CALL 98774 0 0
102521: GO 102524
102523: POP
// end ;
102524: PPOPN 3
102526: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102527: LD_EXP 98
102531: PUSH
102532: LD_EXP 148
102536: AND
102537: IFFALSE 102693
102539: GO 102541
102541: DISABLE
102542: LD_INT 0
102544: PPUSH
102545: PPUSH
102546: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102547: LD_ADDR_VAR 0 2
102551: PUSH
102552: LD_INT 81
102554: PUSH
102555: LD_OWVAR 2
102559: PUSH
102560: EMPTY
102561: LIST
102562: LIST
102563: PUSH
102564: LD_INT 2
102566: PUSH
102567: LD_INT 21
102569: PUSH
102570: LD_INT 1
102572: PUSH
102573: EMPTY
102574: LIST
102575: LIST
102576: PUSH
102577: LD_INT 21
102579: PUSH
102580: LD_INT 2
102582: PUSH
102583: EMPTY
102584: LIST
102585: LIST
102586: PUSH
102587: EMPTY
102588: LIST
102589: LIST
102590: LIST
102591: PUSH
102592: EMPTY
102593: LIST
102594: LIST
102595: PPUSH
102596: CALL_OW 69
102600: ST_TO_ADDR
// if not tmp then
102601: LD_VAR 0 2
102605: NOT
102606: IFFALSE 102610
// exit ;
102608: GO 102693
// p := 0 ;
102610: LD_ADDR_VAR 0 3
102614: PUSH
102615: LD_INT 0
102617: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102618: LD_INT 35
102620: PPUSH
102621: CALL_OW 67
// p := p + 1 ;
102625: LD_ADDR_VAR 0 3
102629: PUSH
102630: LD_VAR 0 3
102634: PUSH
102635: LD_INT 1
102637: PLUS
102638: ST_TO_ADDR
// for i in tmp do
102639: LD_ADDR_VAR 0 1
102643: PUSH
102644: LD_VAR 0 2
102648: PUSH
102649: FOR_IN
102650: IFFALSE 102681
// if GetLives ( i ) < 1000 then
102652: LD_VAR 0 1
102656: PPUSH
102657: CALL_OW 256
102661: PUSH
102662: LD_INT 1000
102664: LESS
102665: IFFALSE 102679
// SetLives ( i , 1000 ) ;
102667: LD_VAR 0 1
102671: PPUSH
102672: LD_INT 1000
102674: PPUSH
102675: CALL_OW 234
102679: GO 102649
102681: POP
102682: POP
// until p > 20 ;
102683: LD_VAR 0 3
102687: PUSH
102688: LD_INT 20
102690: GREATER
102691: IFFALSE 102618
// end ;
102693: PPOPN 3
102695: END
// every 0 0$1 trigger StreamModeActive and sTime do
102696: LD_EXP 98
102700: PUSH
102701: LD_EXP 149
102705: AND
102706: IFFALSE 102741
102708: GO 102710
102710: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102711: LD_INT 28
102713: PPUSH
102714: LD_OWVAR 2
102718: PPUSH
102719: LD_INT 2
102721: PPUSH
102722: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102726: LD_INT 30
102728: PPUSH
102729: LD_OWVAR 2
102733: PPUSH
102734: LD_INT 2
102736: PPUSH
102737: CALL_OW 322
// end ;
102741: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102742: LD_EXP 98
102746: PUSH
102747: LD_EXP 150
102751: AND
102752: IFFALSE 102873
102754: GO 102756
102756: DISABLE
102757: LD_INT 0
102759: PPUSH
102760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102761: LD_ADDR_VAR 0 2
102765: PUSH
102766: LD_INT 22
102768: PUSH
102769: LD_OWVAR 2
102773: PUSH
102774: EMPTY
102775: LIST
102776: LIST
102777: PUSH
102778: LD_INT 21
102780: PUSH
102781: LD_INT 1
102783: PUSH
102784: EMPTY
102785: LIST
102786: LIST
102787: PUSH
102788: LD_INT 3
102790: PUSH
102791: LD_INT 23
102793: PUSH
102794: LD_INT 0
102796: PUSH
102797: EMPTY
102798: LIST
102799: LIST
102800: PUSH
102801: EMPTY
102802: LIST
102803: LIST
102804: PUSH
102805: EMPTY
102806: LIST
102807: LIST
102808: LIST
102809: PPUSH
102810: CALL_OW 69
102814: ST_TO_ADDR
// if not tmp then
102815: LD_VAR 0 2
102819: NOT
102820: IFFALSE 102824
// exit ;
102822: GO 102873
// for i in tmp do
102824: LD_ADDR_VAR 0 1
102828: PUSH
102829: LD_VAR 0 2
102833: PUSH
102834: FOR_IN
102835: IFFALSE 102871
// begin if Crawls ( i ) then
102837: LD_VAR 0 1
102841: PPUSH
102842: CALL_OW 318
102846: IFFALSE 102857
// ComWalk ( i ) ;
102848: LD_VAR 0 1
102852: PPUSH
102853: CALL_OW 138
// SetClass ( i , 2 ) ;
102857: LD_VAR 0 1
102861: PPUSH
102862: LD_INT 2
102864: PPUSH
102865: CALL_OW 336
// end ;
102869: GO 102834
102871: POP
102872: POP
// end ;
102873: PPOPN 2
102875: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102876: LD_EXP 98
102880: PUSH
102881: LD_EXP 151
102885: AND
102886: IFFALSE 103167
102888: GO 102890
102890: DISABLE
102891: LD_INT 0
102893: PPUSH
102894: PPUSH
102895: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102896: LD_OWVAR 2
102900: PPUSH
102901: LD_INT 9
102903: PPUSH
102904: LD_INT 1
102906: PPUSH
102907: LD_INT 1
102909: PPUSH
102910: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102914: LD_INT 9
102916: PPUSH
102917: LD_OWVAR 2
102921: PPUSH
102922: CALL_OW 343
// uc_side := 9 ;
102926: LD_ADDR_OWVAR 20
102930: PUSH
102931: LD_INT 9
102933: ST_TO_ADDR
// uc_nation := 2 ;
102934: LD_ADDR_OWVAR 21
102938: PUSH
102939: LD_INT 2
102941: ST_TO_ADDR
// hc_name := Dark Warrior ;
102942: LD_ADDR_OWVAR 26
102946: PUSH
102947: LD_STRING Dark Warrior
102949: ST_TO_ADDR
// hc_gallery :=  ;
102950: LD_ADDR_OWVAR 33
102954: PUSH
102955: LD_STRING 
102957: ST_TO_ADDR
// hc_noskilllimit := true ;
102958: LD_ADDR_OWVAR 76
102962: PUSH
102963: LD_INT 1
102965: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102966: LD_ADDR_OWVAR 31
102970: PUSH
102971: LD_INT 30
102973: PUSH
102974: LD_INT 30
102976: PUSH
102977: LD_INT 30
102979: PUSH
102980: LD_INT 30
102982: PUSH
102983: EMPTY
102984: LIST
102985: LIST
102986: LIST
102987: LIST
102988: ST_TO_ADDR
// un := CreateHuman ;
102989: LD_ADDR_VAR 0 3
102993: PUSH
102994: CALL_OW 44
102998: ST_TO_ADDR
// hc_noskilllimit := false ;
102999: LD_ADDR_OWVAR 76
103003: PUSH
103004: LD_INT 0
103006: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103007: LD_VAR 0 3
103011: PPUSH
103012: LD_INT 1
103014: PPUSH
103015: CALL_OW 51
// p := 0 ;
103019: LD_ADDR_VAR 0 2
103023: PUSH
103024: LD_INT 0
103026: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103027: LD_INT 35
103029: PPUSH
103030: CALL_OW 67
// p := p + 1 ;
103034: LD_ADDR_VAR 0 2
103038: PUSH
103039: LD_VAR 0 2
103043: PUSH
103044: LD_INT 1
103046: PLUS
103047: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
103048: LD_VAR 0 3
103052: PPUSH
103053: CALL_OW 256
103057: PUSH
103058: LD_INT 1000
103060: LESS
103061: IFFALSE 103075
// SetLives ( un , 1000 ) ;
103063: LD_VAR 0 3
103067: PPUSH
103068: LD_INT 1000
103070: PPUSH
103071: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103075: LD_VAR 0 3
103079: PPUSH
103080: LD_INT 81
103082: PUSH
103083: LD_OWVAR 2
103087: PUSH
103088: EMPTY
103089: LIST
103090: LIST
103091: PUSH
103092: LD_INT 91
103094: PUSH
103095: LD_VAR 0 3
103099: PUSH
103100: LD_INT 30
103102: PUSH
103103: EMPTY
103104: LIST
103105: LIST
103106: LIST
103107: PUSH
103108: EMPTY
103109: LIST
103110: LIST
103111: PPUSH
103112: CALL_OW 69
103116: PPUSH
103117: LD_VAR 0 3
103121: PPUSH
103122: CALL_OW 74
103126: PPUSH
103127: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
103131: LD_VAR 0 2
103135: PUSH
103136: LD_INT 60
103138: GREATER
103139: PUSH
103140: LD_VAR 0 3
103144: PPUSH
103145: CALL_OW 301
103149: OR
103150: IFFALSE 103027
// if un then
103152: LD_VAR 0 3
103156: IFFALSE 103167
// RemoveUnit ( un ) ;
103158: LD_VAR 0 3
103162: PPUSH
103163: CALL_OW 64
// end ;
103167: PPOPN 3
103169: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103170: LD_INT 0
103172: PPUSH
// case cmd of 301 :
103173: LD_VAR 0 1
103177: PUSH
103178: LD_INT 301
103180: DOUBLE
103181: EQUAL
103182: IFTRUE 103186
103184: GO 103218
103186: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103187: LD_VAR 0 6
103191: PPUSH
103192: LD_VAR 0 7
103196: PPUSH
103197: LD_VAR 0 8
103201: PPUSH
103202: LD_VAR 0 4
103206: PPUSH
103207: LD_VAR 0 5
103211: PPUSH
103212: CALL 104419 0 5
103216: GO 103339
103218: LD_INT 302
103220: DOUBLE
103221: EQUAL
103222: IFTRUE 103226
103224: GO 103263
103226: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103227: LD_VAR 0 6
103231: PPUSH
103232: LD_VAR 0 7
103236: PPUSH
103237: LD_VAR 0 8
103241: PPUSH
103242: LD_VAR 0 9
103246: PPUSH
103247: LD_VAR 0 4
103251: PPUSH
103252: LD_VAR 0 5
103256: PPUSH
103257: CALL 104510 0 6
103261: GO 103339
103263: LD_INT 303
103265: DOUBLE
103266: EQUAL
103267: IFTRUE 103271
103269: GO 103308
103271: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103272: LD_VAR 0 6
103276: PPUSH
103277: LD_VAR 0 7
103281: PPUSH
103282: LD_VAR 0 8
103286: PPUSH
103287: LD_VAR 0 9
103291: PPUSH
103292: LD_VAR 0 4
103296: PPUSH
103297: LD_VAR 0 5
103301: PPUSH
103302: CALL 103344 0 6
103306: GO 103339
103308: LD_INT 304
103310: DOUBLE
103311: EQUAL
103312: IFTRUE 103316
103314: GO 103338
103316: POP
// hHackTeleport ( unit , x , y ) ; end ;
103317: LD_VAR 0 2
103321: PPUSH
103322: LD_VAR 0 4
103326: PPUSH
103327: LD_VAR 0 5
103331: PPUSH
103332: CALL 105103 0 3
103336: GO 103339
103338: POP
// end ;
103339: LD_VAR 0 12
103343: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103344: LD_INT 0
103346: PPUSH
103347: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103348: LD_VAR 0 1
103352: PUSH
103353: LD_INT 1
103355: LESS
103356: PUSH
103357: LD_VAR 0 1
103361: PUSH
103362: LD_INT 3
103364: GREATER
103365: OR
103366: PUSH
103367: LD_VAR 0 5
103371: PPUSH
103372: LD_VAR 0 6
103376: PPUSH
103377: CALL_OW 428
103381: OR
103382: IFFALSE 103386
// exit ;
103384: GO 104106
// uc_side := your_side ;
103386: LD_ADDR_OWVAR 20
103390: PUSH
103391: LD_OWVAR 2
103395: ST_TO_ADDR
// uc_nation := nation ;
103396: LD_ADDR_OWVAR 21
103400: PUSH
103401: LD_VAR 0 1
103405: ST_TO_ADDR
// bc_level = 1 ;
103406: LD_ADDR_OWVAR 43
103410: PUSH
103411: LD_INT 1
103413: ST_TO_ADDR
// case btype of 1 :
103414: LD_VAR 0 2
103418: PUSH
103419: LD_INT 1
103421: DOUBLE
103422: EQUAL
103423: IFTRUE 103427
103425: GO 103438
103427: POP
// bc_type := b_depot ; 2 :
103428: LD_ADDR_OWVAR 42
103432: PUSH
103433: LD_INT 0
103435: ST_TO_ADDR
103436: GO 104050
103438: LD_INT 2
103440: DOUBLE
103441: EQUAL
103442: IFTRUE 103446
103444: GO 103457
103446: POP
// bc_type := b_warehouse ; 3 :
103447: LD_ADDR_OWVAR 42
103451: PUSH
103452: LD_INT 1
103454: ST_TO_ADDR
103455: GO 104050
103457: LD_INT 3
103459: DOUBLE
103460: EQUAL
103461: IFTRUE 103465
103463: GO 103476
103465: POP
// bc_type := b_lab ; 4 .. 9 :
103466: LD_ADDR_OWVAR 42
103470: PUSH
103471: LD_INT 6
103473: ST_TO_ADDR
103474: GO 104050
103476: LD_INT 4
103478: DOUBLE
103479: GREATEREQUAL
103480: IFFALSE 103488
103482: LD_INT 9
103484: DOUBLE
103485: LESSEQUAL
103486: IFTRUE 103490
103488: GO 103542
103490: POP
// begin bc_type := b_lab_half ;
103491: LD_ADDR_OWVAR 42
103495: PUSH
103496: LD_INT 7
103498: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103499: LD_ADDR_OWVAR 44
103503: PUSH
103504: LD_INT 10
103506: PUSH
103507: LD_INT 11
103509: PUSH
103510: LD_INT 12
103512: PUSH
103513: LD_INT 15
103515: PUSH
103516: LD_INT 14
103518: PUSH
103519: LD_INT 13
103521: PUSH
103522: EMPTY
103523: LIST
103524: LIST
103525: LIST
103526: LIST
103527: LIST
103528: LIST
103529: PUSH
103530: LD_VAR 0 2
103534: PUSH
103535: LD_INT 3
103537: MINUS
103538: ARRAY
103539: ST_TO_ADDR
// end ; 10 .. 13 :
103540: GO 104050
103542: LD_INT 10
103544: DOUBLE
103545: GREATEREQUAL
103546: IFFALSE 103554
103548: LD_INT 13
103550: DOUBLE
103551: LESSEQUAL
103552: IFTRUE 103556
103554: GO 103633
103556: POP
// begin bc_type := b_lab_full ;
103557: LD_ADDR_OWVAR 42
103561: PUSH
103562: LD_INT 8
103564: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103565: LD_ADDR_OWVAR 44
103569: PUSH
103570: LD_INT 10
103572: PUSH
103573: LD_INT 12
103575: PUSH
103576: LD_INT 14
103578: PUSH
103579: LD_INT 13
103581: PUSH
103582: EMPTY
103583: LIST
103584: LIST
103585: LIST
103586: LIST
103587: PUSH
103588: LD_VAR 0 2
103592: PUSH
103593: LD_INT 9
103595: MINUS
103596: ARRAY
103597: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103598: LD_ADDR_OWVAR 45
103602: PUSH
103603: LD_INT 11
103605: PUSH
103606: LD_INT 15
103608: PUSH
103609: LD_INT 12
103611: PUSH
103612: LD_INT 15
103614: PUSH
103615: EMPTY
103616: LIST
103617: LIST
103618: LIST
103619: LIST
103620: PUSH
103621: LD_VAR 0 2
103625: PUSH
103626: LD_INT 9
103628: MINUS
103629: ARRAY
103630: ST_TO_ADDR
// end ; 14 :
103631: GO 104050
103633: LD_INT 14
103635: DOUBLE
103636: EQUAL
103637: IFTRUE 103641
103639: GO 103652
103641: POP
// bc_type := b_workshop ; 15 :
103642: LD_ADDR_OWVAR 42
103646: PUSH
103647: LD_INT 2
103649: ST_TO_ADDR
103650: GO 104050
103652: LD_INT 15
103654: DOUBLE
103655: EQUAL
103656: IFTRUE 103660
103658: GO 103671
103660: POP
// bc_type := b_factory ; 16 :
103661: LD_ADDR_OWVAR 42
103665: PUSH
103666: LD_INT 3
103668: ST_TO_ADDR
103669: GO 104050
103671: LD_INT 16
103673: DOUBLE
103674: EQUAL
103675: IFTRUE 103679
103677: GO 103690
103679: POP
// bc_type := b_ext_gun ; 17 :
103680: LD_ADDR_OWVAR 42
103684: PUSH
103685: LD_INT 17
103687: ST_TO_ADDR
103688: GO 104050
103690: LD_INT 17
103692: DOUBLE
103693: EQUAL
103694: IFTRUE 103698
103696: GO 103726
103698: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103699: LD_ADDR_OWVAR 42
103703: PUSH
103704: LD_INT 19
103706: PUSH
103707: LD_INT 23
103709: PUSH
103710: LD_INT 19
103712: PUSH
103713: EMPTY
103714: LIST
103715: LIST
103716: LIST
103717: PUSH
103718: LD_VAR 0 1
103722: ARRAY
103723: ST_TO_ADDR
103724: GO 104050
103726: LD_INT 18
103728: DOUBLE
103729: EQUAL
103730: IFTRUE 103734
103732: GO 103745
103734: POP
// bc_type := b_ext_radar ; 19 :
103735: LD_ADDR_OWVAR 42
103739: PUSH
103740: LD_INT 20
103742: ST_TO_ADDR
103743: GO 104050
103745: LD_INT 19
103747: DOUBLE
103748: EQUAL
103749: IFTRUE 103753
103751: GO 103764
103753: POP
// bc_type := b_ext_radio ; 20 :
103754: LD_ADDR_OWVAR 42
103758: PUSH
103759: LD_INT 22
103761: ST_TO_ADDR
103762: GO 104050
103764: LD_INT 20
103766: DOUBLE
103767: EQUAL
103768: IFTRUE 103772
103770: GO 103783
103772: POP
// bc_type := b_ext_siberium ; 21 :
103773: LD_ADDR_OWVAR 42
103777: PUSH
103778: LD_INT 21
103780: ST_TO_ADDR
103781: GO 104050
103783: LD_INT 21
103785: DOUBLE
103786: EQUAL
103787: IFTRUE 103791
103789: GO 103802
103791: POP
// bc_type := b_ext_computer ; 22 :
103792: LD_ADDR_OWVAR 42
103796: PUSH
103797: LD_INT 24
103799: ST_TO_ADDR
103800: GO 104050
103802: LD_INT 22
103804: DOUBLE
103805: EQUAL
103806: IFTRUE 103810
103808: GO 103821
103810: POP
// bc_type := b_ext_track ; 23 :
103811: LD_ADDR_OWVAR 42
103815: PUSH
103816: LD_INT 16
103818: ST_TO_ADDR
103819: GO 104050
103821: LD_INT 23
103823: DOUBLE
103824: EQUAL
103825: IFTRUE 103829
103827: GO 103840
103829: POP
// bc_type := b_ext_laser ; 24 :
103830: LD_ADDR_OWVAR 42
103834: PUSH
103835: LD_INT 25
103837: ST_TO_ADDR
103838: GO 104050
103840: LD_INT 24
103842: DOUBLE
103843: EQUAL
103844: IFTRUE 103848
103846: GO 103859
103848: POP
// bc_type := b_control_tower ; 25 :
103849: LD_ADDR_OWVAR 42
103853: PUSH
103854: LD_INT 36
103856: ST_TO_ADDR
103857: GO 104050
103859: LD_INT 25
103861: DOUBLE
103862: EQUAL
103863: IFTRUE 103867
103865: GO 103878
103867: POP
// bc_type := b_breastwork ; 26 :
103868: LD_ADDR_OWVAR 42
103872: PUSH
103873: LD_INT 31
103875: ST_TO_ADDR
103876: GO 104050
103878: LD_INT 26
103880: DOUBLE
103881: EQUAL
103882: IFTRUE 103886
103884: GO 103897
103886: POP
// bc_type := b_bunker ; 27 :
103887: LD_ADDR_OWVAR 42
103891: PUSH
103892: LD_INT 32
103894: ST_TO_ADDR
103895: GO 104050
103897: LD_INT 27
103899: DOUBLE
103900: EQUAL
103901: IFTRUE 103905
103903: GO 103916
103905: POP
// bc_type := b_turret ; 28 :
103906: LD_ADDR_OWVAR 42
103910: PUSH
103911: LD_INT 33
103913: ST_TO_ADDR
103914: GO 104050
103916: LD_INT 28
103918: DOUBLE
103919: EQUAL
103920: IFTRUE 103924
103922: GO 103935
103924: POP
// bc_type := b_armoury ; 29 :
103925: LD_ADDR_OWVAR 42
103929: PUSH
103930: LD_INT 4
103932: ST_TO_ADDR
103933: GO 104050
103935: LD_INT 29
103937: DOUBLE
103938: EQUAL
103939: IFTRUE 103943
103941: GO 103954
103943: POP
// bc_type := b_barracks ; 30 :
103944: LD_ADDR_OWVAR 42
103948: PUSH
103949: LD_INT 5
103951: ST_TO_ADDR
103952: GO 104050
103954: LD_INT 30
103956: DOUBLE
103957: EQUAL
103958: IFTRUE 103962
103960: GO 103973
103962: POP
// bc_type := b_solar_power ; 31 :
103963: LD_ADDR_OWVAR 42
103967: PUSH
103968: LD_INT 27
103970: ST_TO_ADDR
103971: GO 104050
103973: LD_INT 31
103975: DOUBLE
103976: EQUAL
103977: IFTRUE 103981
103979: GO 103992
103981: POP
// bc_type := b_oil_power ; 32 :
103982: LD_ADDR_OWVAR 42
103986: PUSH
103987: LD_INT 26
103989: ST_TO_ADDR
103990: GO 104050
103992: LD_INT 32
103994: DOUBLE
103995: EQUAL
103996: IFTRUE 104000
103998: GO 104011
104000: POP
// bc_type := b_siberite_power ; 33 :
104001: LD_ADDR_OWVAR 42
104005: PUSH
104006: LD_INT 28
104008: ST_TO_ADDR
104009: GO 104050
104011: LD_INT 33
104013: DOUBLE
104014: EQUAL
104015: IFTRUE 104019
104017: GO 104030
104019: POP
// bc_type := b_oil_mine ; 34 :
104020: LD_ADDR_OWVAR 42
104024: PUSH
104025: LD_INT 29
104027: ST_TO_ADDR
104028: GO 104050
104030: LD_INT 34
104032: DOUBLE
104033: EQUAL
104034: IFTRUE 104038
104036: GO 104049
104038: POP
// bc_type := b_siberite_mine ; end ;
104039: LD_ADDR_OWVAR 42
104043: PUSH
104044: LD_INT 30
104046: ST_TO_ADDR
104047: GO 104050
104049: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104050: LD_ADDR_VAR 0 8
104054: PUSH
104055: LD_VAR 0 5
104059: PPUSH
104060: LD_VAR 0 6
104064: PPUSH
104065: LD_VAR 0 3
104069: PPUSH
104070: CALL_OW 47
104074: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104075: LD_OWVAR 42
104079: PUSH
104080: LD_INT 32
104082: PUSH
104083: LD_INT 33
104085: PUSH
104086: EMPTY
104087: LIST
104088: LIST
104089: IN
104090: IFFALSE 104106
// PlaceWeaponTurret ( b , weapon ) ;
104092: LD_VAR 0 8
104096: PPUSH
104097: LD_VAR 0 4
104101: PPUSH
104102: CALL_OW 431
// end ;
104106: LD_VAR 0 7
104110: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104111: LD_INT 0
104113: PPUSH
104114: PPUSH
104115: PPUSH
104116: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104117: LD_ADDR_VAR 0 4
104121: PUSH
104122: LD_INT 22
104124: PUSH
104125: LD_OWVAR 2
104129: PUSH
104130: EMPTY
104131: LIST
104132: LIST
104133: PUSH
104134: LD_INT 2
104136: PUSH
104137: LD_INT 30
104139: PUSH
104140: LD_INT 0
104142: PUSH
104143: EMPTY
104144: LIST
104145: LIST
104146: PUSH
104147: LD_INT 30
104149: PUSH
104150: LD_INT 1
104152: PUSH
104153: EMPTY
104154: LIST
104155: LIST
104156: PUSH
104157: EMPTY
104158: LIST
104159: LIST
104160: LIST
104161: PUSH
104162: EMPTY
104163: LIST
104164: LIST
104165: PPUSH
104166: CALL_OW 69
104170: ST_TO_ADDR
// if not tmp then
104171: LD_VAR 0 4
104175: NOT
104176: IFFALSE 104180
// exit ;
104178: GO 104239
// for i in tmp do
104180: LD_ADDR_VAR 0 2
104184: PUSH
104185: LD_VAR 0 4
104189: PUSH
104190: FOR_IN
104191: IFFALSE 104237
// for j = 1 to 3 do
104193: LD_ADDR_VAR 0 3
104197: PUSH
104198: DOUBLE
104199: LD_INT 1
104201: DEC
104202: ST_TO_ADDR
104203: LD_INT 3
104205: PUSH
104206: FOR_TO
104207: IFFALSE 104233
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104209: LD_VAR 0 2
104213: PPUSH
104214: CALL_OW 274
104218: PPUSH
104219: LD_VAR 0 3
104223: PPUSH
104224: LD_INT 99999
104226: PPUSH
104227: CALL_OW 277
104231: GO 104206
104233: POP
104234: POP
104235: GO 104190
104237: POP
104238: POP
// end ;
104239: LD_VAR 0 1
104243: RET
// export function hHackSetLevel10 ; var i , j ; begin
104244: LD_INT 0
104246: PPUSH
104247: PPUSH
104248: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104249: LD_ADDR_VAR 0 2
104253: PUSH
104254: LD_INT 21
104256: PUSH
104257: LD_INT 1
104259: PUSH
104260: EMPTY
104261: LIST
104262: LIST
104263: PPUSH
104264: CALL_OW 69
104268: PUSH
104269: FOR_IN
104270: IFFALSE 104322
// if IsSelected ( i ) then
104272: LD_VAR 0 2
104276: PPUSH
104277: CALL_OW 306
104281: IFFALSE 104320
// begin for j := 1 to 4 do
104283: LD_ADDR_VAR 0 3
104287: PUSH
104288: DOUBLE
104289: LD_INT 1
104291: DEC
104292: ST_TO_ADDR
104293: LD_INT 4
104295: PUSH
104296: FOR_TO
104297: IFFALSE 104318
// SetSkill ( i , j , 10 ) ;
104299: LD_VAR 0 2
104303: PPUSH
104304: LD_VAR 0 3
104308: PPUSH
104309: LD_INT 10
104311: PPUSH
104312: CALL_OW 237
104316: GO 104296
104318: POP
104319: POP
// end ;
104320: GO 104269
104322: POP
104323: POP
// end ;
104324: LD_VAR 0 1
104328: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104329: LD_INT 0
104331: PPUSH
104332: PPUSH
104333: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104334: LD_ADDR_VAR 0 2
104338: PUSH
104339: LD_INT 22
104341: PUSH
104342: LD_OWVAR 2
104346: PUSH
104347: EMPTY
104348: LIST
104349: LIST
104350: PUSH
104351: LD_INT 21
104353: PUSH
104354: LD_INT 1
104356: PUSH
104357: EMPTY
104358: LIST
104359: LIST
104360: PUSH
104361: EMPTY
104362: LIST
104363: LIST
104364: PPUSH
104365: CALL_OW 69
104369: PUSH
104370: FOR_IN
104371: IFFALSE 104412
// begin for j := 1 to 4 do
104373: LD_ADDR_VAR 0 3
104377: PUSH
104378: DOUBLE
104379: LD_INT 1
104381: DEC
104382: ST_TO_ADDR
104383: LD_INT 4
104385: PUSH
104386: FOR_TO
104387: IFFALSE 104408
// SetSkill ( i , j , 10 ) ;
104389: LD_VAR 0 2
104393: PPUSH
104394: LD_VAR 0 3
104398: PPUSH
104399: LD_INT 10
104401: PPUSH
104402: CALL_OW 237
104406: GO 104386
104408: POP
104409: POP
// end ;
104410: GO 104370
104412: POP
104413: POP
// end ;
104414: LD_VAR 0 1
104418: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104419: LD_INT 0
104421: PPUSH
// uc_side := your_side ;
104422: LD_ADDR_OWVAR 20
104426: PUSH
104427: LD_OWVAR 2
104431: ST_TO_ADDR
// uc_nation := nation ;
104432: LD_ADDR_OWVAR 21
104436: PUSH
104437: LD_VAR 0 1
104441: ST_TO_ADDR
// InitHc ;
104442: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104446: LD_INT 0
104448: PPUSH
104449: LD_VAR 0 2
104453: PPUSH
104454: LD_VAR 0 3
104458: PPUSH
104459: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104463: LD_VAR 0 4
104467: PPUSH
104468: LD_VAR 0 5
104472: PPUSH
104473: CALL_OW 428
104477: PUSH
104478: LD_INT 0
104480: EQUAL
104481: IFFALSE 104505
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104483: CALL_OW 44
104487: PPUSH
104488: LD_VAR 0 4
104492: PPUSH
104493: LD_VAR 0 5
104497: PPUSH
104498: LD_INT 1
104500: PPUSH
104501: CALL_OW 48
// end ;
104505: LD_VAR 0 6
104509: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104510: LD_INT 0
104512: PPUSH
104513: PPUSH
// uc_side := your_side ;
104514: LD_ADDR_OWVAR 20
104518: PUSH
104519: LD_OWVAR 2
104523: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104524: LD_VAR 0 1
104528: PUSH
104529: LD_INT 1
104531: PUSH
104532: LD_INT 2
104534: PUSH
104535: LD_INT 3
104537: PUSH
104538: LD_INT 4
104540: PUSH
104541: LD_INT 5
104543: PUSH
104544: EMPTY
104545: LIST
104546: LIST
104547: LIST
104548: LIST
104549: LIST
104550: IN
104551: IFFALSE 104563
// uc_nation := nation_american else
104553: LD_ADDR_OWVAR 21
104557: PUSH
104558: LD_INT 1
104560: ST_TO_ADDR
104561: GO 104606
// if chassis in [ 11 , 12 , 13 , 14 ] then
104563: LD_VAR 0 1
104567: PUSH
104568: LD_INT 11
104570: PUSH
104571: LD_INT 12
104573: PUSH
104574: LD_INT 13
104576: PUSH
104577: LD_INT 14
104579: PUSH
104580: EMPTY
104581: LIST
104582: LIST
104583: LIST
104584: LIST
104585: IN
104586: IFFALSE 104598
// uc_nation := nation_arabian else
104588: LD_ADDR_OWVAR 21
104592: PUSH
104593: LD_INT 2
104595: ST_TO_ADDR
104596: GO 104606
// uc_nation := nation_russian ;
104598: LD_ADDR_OWVAR 21
104602: PUSH
104603: LD_INT 3
104605: ST_TO_ADDR
// vc_chassis := chassis ;
104606: LD_ADDR_OWVAR 37
104610: PUSH
104611: LD_VAR 0 1
104615: ST_TO_ADDR
// vc_engine := engine ;
104616: LD_ADDR_OWVAR 39
104620: PUSH
104621: LD_VAR 0 2
104625: ST_TO_ADDR
// vc_control := control ;
104626: LD_ADDR_OWVAR 38
104630: PUSH
104631: LD_VAR 0 3
104635: ST_TO_ADDR
// vc_weapon := weapon ;
104636: LD_ADDR_OWVAR 40
104640: PUSH
104641: LD_VAR 0 4
104645: ST_TO_ADDR
// un := CreateVehicle ;
104646: LD_ADDR_VAR 0 8
104650: PUSH
104651: CALL_OW 45
104655: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104656: LD_VAR 0 8
104660: PPUSH
104661: LD_INT 0
104663: PPUSH
104664: LD_INT 5
104666: PPUSH
104667: CALL_OW 12
104671: PPUSH
104672: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104676: LD_VAR 0 8
104680: PPUSH
104681: LD_VAR 0 5
104685: PPUSH
104686: LD_VAR 0 6
104690: PPUSH
104691: LD_INT 1
104693: PPUSH
104694: CALL_OW 48
// end ;
104698: LD_VAR 0 7
104702: RET
// export hInvincible ; every 1 do
104703: GO 104705
104705: DISABLE
// hInvincible := [ ] ;
104706: LD_ADDR_EXP 152
104710: PUSH
104711: EMPTY
104712: ST_TO_ADDR
104713: END
// every 10 do var i ;
104714: GO 104716
104716: DISABLE
104717: LD_INT 0
104719: PPUSH
// begin enable ;
104720: ENABLE
// if not hInvincible then
104721: LD_EXP 152
104725: NOT
104726: IFFALSE 104730
// exit ;
104728: GO 104774
// for i in hInvincible do
104730: LD_ADDR_VAR 0 1
104734: PUSH
104735: LD_EXP 152
104739: PUSH
104740: FOR_IN
104741: IFFALSE 104772
// if GetLives ( i ) < 1000 then
104743: LD_VAR 0 1
104747: PPUSH
104748: CALL_OW 256
104752: PUSH
104753: LD_INT 1000
104755: LESS
104756: IFFALSE 104770
// SetLives ( i , 1000 ) ;
104758: LD_VAR 0 1
104762: PPUSH
104763: LD_INT 1000
104765: PPUSH
104766: CALL_OW 234
104770: GO 104740
104772: POP
104773: POP
// end ;
104774: PPOPN 1
104776: END
// export function hHackInvincible ; var i ; begin
104777: LD_INT 0
104779: PPUSH
104780: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104781: LD_ADDR_VAR 0 2
104785: PUSH
104786: LD_INT 2
104788: PUSH
104789: LD_INT 21
104791: PUSH
104792: LD_INT 1
104794: PUSH
104795: EMPTY
104796: LIST
104797: LIST
104798: PUSH
104799: LD_INT 21
104801: PUSH
104802: LD_INT 2
104804: PUSH
104805: EMPTY
104806: LIST
104807: LIST
104808: PUSH
104809: EMPTY
104810: LIST
104811: LIST
104812: LIST
104813: PPUSH
104814: CALL_OW 69
104818: PUSH
104819: FOR_IN
104820: IFFALSE 104881
// if IsSelected ( i ) then
104822: LD_VAR 0 2
104826: PPUSH
104827: CALL_OW 306
104831: IFFALSE 104879
// begin if i in hInvincible then
104833: LD_VAR 0 2
104837: PUSH
104838: LD_EXP 152
104842: IN
104843: IFFALSE 104863
// hInvincible := hInvincible diff i else
104845: LD_ADDR_EXP 152
104849: PUSH
104850: LD_EXP 152
104854: PUSH
104855: LD_VAR 0 2
104859: DIFF
104860: ST_TO_ADDR
104861: GO 104879
// hInvincible := hInvincible union i ;
104863: LD_ADDR_EXP 152
104867: PUSH
104868: LD_EXP 152
104872: PUSH
104873: LD_VAR 0 2
104877: UNION
104878: ST_TO_ADDR
// end ;
104879: GO 104819
104881: POP
104882: POP
// end ;
104883: LD_VAR 0 1
104887: RET
// export function hHackInvisible ; var i , j ; begin
104888: LD_INT 0
104890: PPUSH
104891: PPUSH
104892: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104893: LD_ADDR_VAR 0 2
104897: PUSH
104898: LD_INT 21
104900: PUSH
104901: LD_INT 1
104903: PUSH
104904: EMPTY
104905: LIST
104906: LIST
104907: PPUSH
104908: CALL_OW 69
104912: PUSH
104913: FOR_IN
104914: IFFALSE 104938
// if IsSelected ( i ) then
104916: LD_VAR 0 2
104920: PPUSH
104921: CALL_OW 306
104925: IFFALSE 104936
// ComForceInvisible ( i ) ;
104927: LD_VAR 0 2
104931: PPUSH
104932: CALL_OW 496
104936: GO 104913
104938: POP
104939: POP
// end ;
104940: LD_VAR 0 1
104944: RET
// export function hHackChangeYourSide ; begin
104945: LD_INT 0
104947: PPUSH
// if your_side = 8 then
104948: LD_OWVAR 2
104952: PUSH
104953: LD_INT 8
104955: EQUAL
104956: IFFALSE 104968
// your_side := 0 else
104958: LD_ADDR_OWVAR 2
104962: PUSH
104963: LD_INT 0
104965: ST_TO_ADDR
104966: GO 104982
// your_side := your_side + 1 ;
104968: LD_ADDR_OWVAR 2
104972: PUSH
104973: LD_OWVAR 2
104977: PUSH
104978: LD_INT 1
104980: PLUS
104981: ST_TO_ADDR
// end ;
104982: LD_VAR 0 1
104986: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104987: LD_INT 0
104989: PPUSH
104990: PPUSH
104991: PPUSH
// for i in all_units do
104992: LD_ADDR_VAR 0 2
104996: PUSH
104997: LD_OWVAR 3
105001: PUSH
105002: FOR_IN
105003: IFFALSE 105081
// if IsSelected ( i ) then
105005: LD_VAR 0 2
105009: PPUSH
105010: CALL_OW 306
105014: IFFALSE 105079
// begin j := GetSide ( i ) ;
105016: LD_ADDR_VAR 0 3
105020: PUSH
105021: LD_VAR 0 2
105025: PPUSH
105026: CALL_OW 255
105030: ST_TO_ADDR
// if j = 8 then
105031: LD_VAR 0 3
105035: PUSH
105036: LD_INT 8
105038: EQUAL
105039: IFFALSE 105051
// j := 0 else
105041: LD_ADDR_VAR 0 3
105045: PUSH
105046: LD_INT 0
105048: ST_TO_ADDR
105049: GO 105065
// j := j + 1 ;
105051: LD_ADDR_VAR 0 3
105055: PUSH
105056: LD_VAR 0 3
105060: PUSH
105061: LD_INT 1
105063: PLUS
105064: ST_TO_ADDR
// SetSide ( i , j ) ;
105065: LD_VAR 0 2
105069: PPUSH
105070: LD_VAR 0 3
105074: PPUSH
105075: CALL_OW 235
// end ;
105079: GO 105002
105081: POP
105082: POP
// end ;
105083: LD_VAR 0 1
105087: RET
// export function hHackFog ; begin
105088: LD_INT 0
105090: PPUSH
// FogOff ( true ) ;
105091: LD_INT 1
105093: PPUSH
105094: CALL_OW 344
// end ;
105098: LD_VAR 0 1
105102: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105103: LD_INT 0
105105: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105106: LD_VAR 0 1
105110: PPUSH
105111: LD_VAR 0 2
105115: PPUSH
105116: LD_VAR 0 3
105120: PPUSH
105121: LD_INT 1
105123: PPUSH
105124: LD_INT 1
105126: PPUSH
105127: CALL_OW 483
// CenterOnXY ( x , y ) ;
105131: LD_VAR 0 2
105135: PPUSH
105136: LD_VAR 0 3
105140: PPUSH
105141: CALL_OW 84
// end ; end_of_file
105145: LD_VAR 0 4
105149: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
105150: LD_VAR 0 1
105154: PPUSH
105155: LD_VAR 0 2
105159: PPUSH
105160: LD_VAR 0 3
105164: PPUSH
105165: LD_VAR 0 4
105169: PPUSH
105170: LD_VAR 0 5
105174: PPUSH
105175: LD_VAR 0 6
105179: PPUSH
105180: CALL 91978 0 6
// end ;
105184: PPOPN 6
105186: END
