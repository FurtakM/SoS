// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 210 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45483 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45483 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45483 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45483 0 9
// PrepareGensher ;
 185: CALL 3188 0 0
// PreparePopov ;
 189: CALL 6427 0 0
// PreparePowell ;
 193: CALL 589 0 0
// PrepareSikorski ;
 197: CALL 9147 0 0
// MC_Start ( ) ;
 201: CALL 56066 0 0
// Action ;
 205: CALL 9554 0 0
// end ;
 209: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 210: LD_INT 0
 212: PPUSH
// debug := false ;
 213: LD_ADDR_EXP 1
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// game := true ;
 221: LD_ADDR_EXP 2
 225: PUSH
 226: LD_INT 1
 228: ST_TO_ADDR
// staticMines := [ ] ;
 229: LD_ADDR_EXP 3
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// arDestroyed := false ;
 236: LD_ADDR_EXP 4
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// ruDestroyed := false ;
 244: LD_ADDR_EXP 5
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// powellInTrouble := false ;
 252: LD_ADDR_EXP 8
 256: PUSH
 257: LD_INT 0
 259: ST_TO_ADDR
// sikorskiInTrouble := false ;
 260: LD_ADDR_EXP 9
 264: PUSH
 265: LD_INT 0
 267: ST_TO_ADDR
// end ;
 268: LD_VAR 0 1
 272: RET
// export function CustomInitMacro ; begin
 273: LD_INT 0
 275: PPUSH
// InitMC_Gensher ( ) ;
 276: CALL 4354 0 0
// InitMC_Powell ( ) ;
 280: CALL 1543 0 0
// InitMC_Popov ( ) ;
 284: CALL 7617 0 0
// end ;
 288: LD_VAR 0 1
 292: RET
// every 0 0$10 do var cr , time , i ;
 293: GO 295
 295: DISABLE
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
 300: PPUSH
// begin time := 0 0$20 ;
 301: LD_ADDR_VAR 0 2
 305: PUSH
 306: LD_INT 700
 308: ST_TO_ADDR
// repeat wait ( time ) ;
 309: LD_VAR 0 2
 313: PPUSH
 314: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 318: LD_ADDR_VAR 0 1
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 5
 328: PPUSH
 329: CALL_OW 12
 333: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 334: LD_ADDR_VAR 0 3
 338: PUSH
 339: LD_INT 5
 341: PUSH
 342: LD_INT 8
 344: PUSH
 345: LD_INT 12
 347: PUSH
 348: LD_INT 13
 350: PUSH
 351: EMPTY
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: PUSH
 357: FOR_IN
 358: IFFALSE 412
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 360: LD_VAR 0 3
 364: PPUSH
 365: LD_INT 1
 367: PPUSH
 368: CALL_OW 287
 372: PUSH
 373: LD_INT 40
 375: LESS
 376: IFFALSE 395
// CreateCratesArea ( cr , i , true ) ;
 378: LD_VAR 0 1
 382: PPUSH
 383: LD_VAR 0 3
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 395: LD_INT 175
 397: PPUSH
 398: LD_INT 525
 400: PPUSH
 401: CALL_OW 12
 405: PPUSH
 406: CALL_OW 67
// end ;
 410: GO 357
 412: POP
 413: POP
// time := time + 0 0$2 ;
 414: LD_ADDR_VAR 0 2
 418: PUSH
 419: LD_VAR 0 2
 423: PUSH
 424: LD_INT 70
 426: PLUS
 427: ST_TO_ADDR
// if time > 0 0$35 then
 428: LD_VAR 0 2
 432: PUSH
 433: LD_INT 1225
 435: GREATER
 436: IFFALSE 446
// time := 0 0$25 ;
 438: LD_ADDR_VAR 0 2
 442: PUSH
 443: LD_INT 875
 445: ST_TO_ADDR
// until not game ;
 446: LD_EXP 2
 450: NOT
 451: IFFALSE 309
// end ;
 453: PPOPN 3
 455: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 456: LD_INT 3
 458: PUSH
 459: LD_INT 22
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: LD_INT 32
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: IFFALSE 586
 493: GO 495
 495: DISABLE
 496: LD_INT 0
 498: PPUSH
 499: PPUSH
// begin enable ;
 500: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 501: LD_ADDR_VAR 0 2
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: LD_INT 22
 511: PUSH
 512: LD_INT 1
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 32
 525: PUSH
 526: LD_INT 1
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL_OW 69
 541: ST_TO_ADDR
// for i in tmp do
 542: LD_ADDR_VAR 0 1
 546: PUSH
 547: LD_VAR 0 2
 551: PUSH
 552: FOR_IN
 553: IFFALSE 584
// if GetFuel ( i ) < 5 then
 555: LD_VAR 0 1
 559: PPUSH
 560: CALL_OW 261
 564: PUSH
 565: LD_INT 5
 567: LESS
 568: IFFALSE 582
// SetFuel ( i , 5 ) ;
 570: LD_VAR 0 1
 574: PPUSH
 575: LD_INT 5
 577: PPUSH
 578: CALL_OW 240
 582: GO 552
 584: POP
 585: POP
// end ; end_of_file
 586: PPOPN 2
 588: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
 593: PPUSH
 594: PPUSH
 595: PPUSH
// powell_side := 4 ;
 596: LD_ADDR_EXP 11
 600: PUSH
 601: LD_INT 4
 603: ST_TO_ADDR
// uc_side := powell_side ;
 604: LD_ADDR_OWVAR 20
 608: PUSH
 609: LD_EXP 11
 613: ST_TO_ADDR
// uc_nation := 1 ;
 614: LD_ADDR_OWVAR 21
 618: PUSH
 619: LD_INT 1
 621: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 622: LD_ADDR_EXP 10
 626: PUSH
 627: LD_STRING Powell
 629: PPUSH
 630: CALL_OW 25
 634: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 7
 645: PPUSH
 646: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 650: LD_EXP 10
 654: PPUSH
 655: LD_INT 2
 657: PPUSH
 658: LD_INT 5
 660: PPUSH
 661: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 665: LD_EXP 10
 669: PPUSH
 670: LD_INT 3
 672: PPUSH
 673: LD_INT 6
 675: PPUSH
 676: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 680: LD_EXP 10
 684: PPUSH
 685: LD_INT 4
 687: PPUSH
 688: LD_INT 4
 690: PPUSH
 691: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 695: LD_EXP 10
 699: PPUSH
 700: LD_INT 4
 702: PPUSH
 703: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 707: LD_ADDR_VAR 0 3
 711: PUSH
 712: LD_INT 5
 714: PUSH
 715: LD_INT 178
 717: PUSH
 718: LD_INT 117
 720: PUSH
 721: LD_INT 2
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PUSH
 730: LD_INT 29
 732: PUSH
 733: LD_INT 167
 735: PUSH
 736: LD_INT 102
 738: PUSH
 739: LD_INT 0
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 200
 753: PUSH
 754: LD_INT 111
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 10
 762: PUSH
 763: LD_INT 11
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: LIST
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 201
 779: PUSH
 780: LD_INT 140
 782: PUSH
 783: LD_INT 4
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_INT 27
 794: PUSH
 795: LD_INT 206
 797: PUSH
 798: LD_INT 124
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: LIST
 808: LIST
 809: PUSH
 810: LD_INT 27
 812: PUSH
 813: LD_INT 209
 815: PUSH
 816: LD_INT 128
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PUSH
 828: LD_INT 27
 830: PUSH
 831: LD_INT 211
 833: PUSH
 834: LD_INT 132
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 30
 848: PUSH
 849: LD_INT 173
 851: PUSH
 852: LD_INT 83
 854: PUSH
 855: LD_INT 3
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 6
 866: PUSH
 867: LD_INT 186
 869: PUSH
 870: LD_INT 103
 872: PUSH
 873: LD_INT 2
 875: PUSH
 876: LD_INT 12
 878: PUSH
 879: LD_INT 15
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 33
 892: PUSH
 893: LD_INT 173
 895: PUSH
 896: LD_INT 99
 898: PUSH
 899: LD_INT 2
 901: PUSH
 902: LD_INT 6
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: PUSH
 912: LD_INT 32
 914: PUSH
 915: LD_INT 174
 917: PUSH
 918: LD_INT 102
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: LD_INT 178
 939: PUSH
 940: LD_INT 100
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 6
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 33
 958: PUSH
 959: LD_INT 174
 961: PUSH
 962: LD_INT 108
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 7
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 33
 980: PUSH
 981: LD_INT 182
 983: PUSH
 984: LD_INT 122
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 7
 992: PUSH
 993: EMPTY
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 36
1002: PUSH
1003: LD_INT 194
1005: PUSH
1006: LD_INT 124
1008: PUSH
1009: LD_INT 5
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 33
1020: PUSH
1021: LD_INT 184
1023: PUSH
1024: LD_INT 141
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 6
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 33
1042: PUSH
1043: LD_INT 183
1045: PUSH
1046: LD_INT 131
1048: PUSH
1049: LD_INT 2
1051: PUSH
1052: LD_INT 11
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_INT 33
1064: PUSH
1065: LD_INT 194
1067: PUSH
1068: LD_INT 146
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: LD_INT 7
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 33
1086: PUSH
1087: LD_INT 190
1089: PUSH
1090: LD_INT 142
1092: PUSH
1093: LD_INT 4
1095: PUSH
1096: LD_INT 7
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_INT 28
1108: PUSH
1109: LD_INT 204
1111: PUSH
1112: LD_INT 133
1114: PUSH
1115: LD_INT 3
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_INT 27
1126: PUSH
1127: LD_INT 201
1129: PUSH
1130: LD_INT 133
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: PUSH
1142: LD_INT 28
1144: PUSH
1145: LD_INT 199
1147: PUSH
1148: LD_INT 119
1150: PUSH
1151: LD_INT 5
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: LIST
1158: LIST
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// for i in list do
1184: LD_ADDR_VAR 0 2
1188: PUSH
1189: LD_VAR 0 3
1193: PUSH
1194: FOR_IN
1195: IFFALSE 1405
// begin uc_side := 4 ;
1197: LD_ADDR_OWVAR 20
1201: PUSH
1202: LD_INT 4
1204: ST_TO_ADDR
// uc_nation := 1 ;
1205: LD_ADDR_OWVAR 21
1209: PUSH
1210: LD_INT 1
1212: ST_TO_ADDR
// InitBc ;
1213: CALL_OW 21
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
1231: LD_VAR 0 2
1235: PUSH
1236: LD_INT 1
1238: ARRAY
1239: PUSH
1240: LD_INT 29
1242: PUSH
1243: LD_INT 30
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: IN
1250: IFFALSE 1277
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 4 ) ;
1252: LD_VAR 0 2
1256: PUSH
1257: LD_INT 2
1259: ARRAY
1260: PPUSH
1261: LD_VAR 0 2
1265: PUSH
1266: LD_INT 3
1268: ARRAY
1269: PPUSH
1270: LD_INT 4
1272: PPUSH
1273: CALL_OW 441
// if i [ 1 ] = b_lab then
1277: LD_VAR 0 2
1281: PUSH
1282: LD_INT 1
1284: ARRAY
1285: PUSH
1286: LD_INT 6
1288: EQUAL
1289: IFFALSE 1327
// begin bc_type := b_lab_full ;
1291: LD_ADDR_OWVAR 42
1295: PUSH
1296: LD_INT 8
1298: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1299: LD_ADDR_OWVAR 44
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 5
1311: ARRAY
1312: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1313: LD_ADDR_OWVAR 45
1317: PUSH
1318: LD_VAR 0 2
1322: PUSH
1323: LD_INT 6
1325: ARRAY
1326: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1327: LD_ADDR_VAR 0 4
1331: PUSH
1332: LD_VAR 0 2
1336: PUSH
1337: LD_INT 2
1339: ARRAY
1340: PPUSH
1341: LD_VAR 0 2
1345: PUSH
1346: LD_INT 3
1348: ARRAY
1349: PPUSH
1350: LD_VAR 0 2
1354: PUSH
1355: LD_INT 4
1357: ARRAY
1358: PPUSH
1359: CALL_OW 47
1363: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1364: LD_VAR 0 2
1368: PUSH
1369: LD_INT 1
1371: ARRAY
1372: PUSH
1373: LD_INT 33
1375: PUSH
1376: LD_INT 32
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: IN
1383: IFFALSE 1403
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1385: LD_VAR 0 4
1389: PPUSH
1390: LD_VAR 0 2
1394: PUSH
1395: LD_INT 5
1397: ARRAY
1398: PPUSH
1399: CALL_OW 431
// end ;
1403: GO 1194
1405: POP
1406: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1407: LD_ADDR_VAR 0 5
1411: PUSH
1412: LD_INT 4
1414: PPUSH
1415: LD_INT 1
1417: PPUSH
1418: LD_STRING 
1420: PPUSH
1421: LD_INT 8
1423: PUSH
1424: LD_INT 7
1426: PUSH
1427: LD_INT 6
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: PUSH
1435: LD_OWVAR 67
1439: ARRAY
1440: PPUSH
1441: LD_INT 5500
1443: PUSH
1444: LD_INT 500
1446: PUSH
1447: LD_INT 0
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: PPUSH
1455: LD_INT 6
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 6
1463: PUSH
1464: LD_INT 6
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: PPUSH
1473: CALL 19776 0 6
1477: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1478: LD_ADDR_EXP 23
1482: PUSH
1483: LD_EXP 23
1487: PPUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_INT 22
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 21
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: EMPTY
1517: LIST
1518: LIST
1519: PPUSH
1520: CALL_OW 69
1524: UNION
1525: PPUSH
1526: CALL_OW 1
1530: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1531: LD_ADDR_EXP 12
1535: PUSH
1536: EMPTY
1537: ST_TO_ADDR
// end ;
1538: LD_VAR 0 1
1542: RET
// export function InitMC_Powell ( ) ; begin
1543: LD_INT 0
1545: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1546: LD_INT 1
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL 79441 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1556: LD_INT 1
1558: PPUSH
1559: LD_INT 6
1561: PPUSH
1562: CALL 79385 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1566: LD_INT 1
1568: PPUSH
1569: LD_INT 167
1571: PUSH
1572: LD_INT 102
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 173
1585: PUSH
1586: LD_INT 83
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: LD_INT 171
1599: PUSH
1600: LD_INT 141
1602: PUSH
1603: LD_INT 0
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: PUSH
1611: LD_INT 178
1613: PUSH
1614: LD_INT 148
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: LIST
1624: PUSH
1625: EMPTY
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL 78444 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1635: LD_INT 1
1637: PPUSH
1638: LD_INT 11
1640: PUSH
1641: LD_INT 6
1643: PUSH
1644: LD_INT 7
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: PPUSH
1652: CALL 79273 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: CALL 78955 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1666: LD_INT 1
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: CALL 78686 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 4
1681: PPUSH
1682: CALL 78305 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 3
1691: PUSH
1692: LD_INT 1
1694: PUSH
1695: LD_INT 2
1697: PUSH
1698: LD_INT 5
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 1
1712: PUSH
1713: LD_INT 2
1715: PUSH
1716: LD_INT 6
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_INT 4
1727: PUSH
1728: LD_INT 1
1730: PUSH
1731: LD_INT 2
1733: PUSH
1734: LD_INT 7
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: PUSH
1743: LD_INT 4
1745: PUSH
1746: LD_INT 1
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: LD_INT 6
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: LIST
1765: LIST
1766: PPUSH
1767: CALL 78120 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1771: LD_INT 1
1773: PPUSH
1774: LD_INT 201
1776: PPUSH
1777: LD_INT 140
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 19
1785: PUSH
1786: LD_INT 16
1788: PUSH
1789: LD_INT 17
1791: PUSH
1792: LD_INT 18
1794: PUSH
1795: LD_INT 22
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL 79067 0 5
// end ;
1809: LD_VAR 0 1
1813: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1814: LD_INT 4
1816: PPUSH
1817: CALL_OW 302
1821: IFFALSE 2481
1823: GO 1825
1825: DISABLE
1826: LD_INT 0
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// begin enable ;
1833: ENABLE
// base := 1 ;
1834: LD_ADDR_VAR 0 2
1838: PUSH
1839: LD_INT 1
1841: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: LD_INT 4
1849: PUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 6
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 4
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 2
1873: PUSH
1874: LD_INT 6
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: LD_INT 3
1885: PUSH
1886: LD_INT 1
1888: PUSH
1889: LD_INT 2
1891: PUSH
1892: LD_INT 7
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 3
1903: PUSH
1904: LD_INT 1
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 7
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1925: LD_ADDR_VAR 0 5
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_OWVAR 1
1939: PUSH
1940: LD_INT 21000
1942: DIV
1943: PLUS
1944: ST_TO_ADDR
// if amount > 8 then
1945: LD_VAR 0 5
1949: PUSH
1950: LD_INT 8
1952: GREATER
1953: IFFALSE 1963
// amount := 8 ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_INT 8
1962: ST_TO_ADDR
// for i = 1 to amount do
1963: LD_ADDR_VAR 0 1
1967: PUSH
1968: DOUBLE
1969: LD_INT 1
1971: DEC
1972: ST_TO_ADDR
1973: LD_VAR 0 5
1977: PUSH
1978: FOR_TO
1979: IFFALSE 2063
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1981: LD_ADDR_VAR 0 3
1985: PUSH
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 3
1995: PUSH
1996: LD_INT 1
1998: PLUS
1999: PPUSH
2000: LD_INT 3
2002: PUSH
2003: LD_INT 4
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: LD_INT 5
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 1
2040: PPUSH
2041: LD_INT 2
2043: PPUSH
2044: CALL_OW 12
2048: ARRAY
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: PPUSH
2056: CALL_OW 2
2060: ST_TO_ADDR
2061: GO 1978
2063: POP
2064: POP
// MC_InsertProduceList ( base , tmp ) ;
2065: LD_VAR 0 2
2069: PPUSH
2070: LD_VAR 0 3
2074: PPUSH
2075: CALL 78168 0 2
// repeat wait ( 0 0$1 ) ;
2079: LD_INT 35
2081: PPUSH
2082: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2086: LD_VAR 0 2
2090: PPUSH
2091: LD_INT 1
2093: PPUSH
2094: CALL 79586 0 2
2098: PUSH
2099: LD_VAR 0 5
2103: GREATEREQUAL
2104: IFFALSE 2079
// wait ( 0 0$30 ) ;
2106: LD_INT 1050
2108: PPUSH
2109: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2113: LD_ADDR_VAR 0 4
2117: PUSH
2118: LD_EXP 42
2122: PUSH
2123: LD_VAR 0 2
2127: ARRAY
2128: PUSH
2129: LD_EXP 42
2133: PUSH
2134: LD_VAR 0 2
2138: ARRAY
2139: PPUSH
2140: LD_INT 2
2142: PUSH
2143: LD_INT 34
2145: PUSH
2146: LD_INT 12
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 34
2155: PUSH
2156: LD_INT 13
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: LD_INT 34
2165: PUSH
2166: LD_INT 14
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: PPUSH
2179: CALL_OW 72
2183: DIFF
2184: ST_TO_ADDR
// if not attackers then
2185: LD_VAR 0 4
2189: NOT
2190: IFFALSE 2194
// exit ;
2192: GO 2481
// DialogPowellsAttack ;
2194: CALL 9685 0 0
// powellAttackGroup := attackers ;
2198: LD_ADDR_EXP 12
2202: PUSH
2203: LD_VAR 0 4
2207: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2208: LD_ADDR_EXP 42
2212: PUSH
2213: LD_EXP 42
2217: PPUSH
2218: LD_VAR 0 2
2222: PPUSH
2223: LD_EXP 42
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PUSH
2234: LD_VAR 0 4
2238: DIFF
2239: PPUSH
2240: CALL_OW 1
2244: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2245: LD_EXP 9
2249: PUSH
2250: LD_INT 16
2252: PPUSH
2253: LD_INT 81
2255: PUSH
2256: LD_INT 4
2258: PUSH
2259: EMPTY
2260: LIST
2261: LIST
2262: PPUSH
2263: CALL_OW 70
2267: AND
2268: IFFALSE 2287
// ComAgressiveMove ( attackers , 135 , 21 ) else
2270: LD_VAR 0 4
2274: PPUSH
2275: LD_INT 135
2277: PPUSH
2278: LD_INT 21
2280: PPUSH
2281: CALL_OW 114
2285: GO 2302
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2287: LD_VAR 0 4
2291: PPUSH
2292: LD_INT 146
2294: PPUSH
2295: LD_INT 103
2297: PPUSH
2298: CALL_OW 114
// wait ( 0 0$5 ) ;
2302: LD_INT 175
2304: PPUSH
2305: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2309: LD_INT 35
2311: PPUSH
2312: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2316: LD_VAR 0 4
2320: PPUSH
2321: LD_INT 60
2323: PUSH
2324: EMPTY
2325: LIST
2326: PPUSH
2327: CALL_OW 72
2331: NOT
2332: IFFALSE 2309
// if FilterAllUnits ( [ f_side , 3 ] ) then
2334: LD_INT 22
2336: PUSH
2337: LD_INT 3
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PPUSH
2344: CALL_OW 69
2348: IFFALSE 2367
// ComAgressiveMove ( attackers , 102 , 116 ) else
2350: LD_VAR 0 4
2354: PPUSH
2355: LD_INT 102
2357: PPUSH
2358: LD_INT 116
2360: PPUSH
2361: CALL_OW 114
2365: GO 2382
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2367: LD_VAR 0 4
2371: PPUSH
2372: LD_INT 66
2374: PPUSH
2375: LD_INT 41
2377: PPUSH
2378: CALL_OW 114
// wait ( 0 0$10 ) ;
2382: LD_INT 350
2384: PPUSH
2385: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2389: LD_INT 35
2391: PPUSH
2392: CALL_OW 67
// for i in attackers do
2396: LD_ADDR_VAR 0 1
2400: PUSH
2401: LD_VAR 0 4
2405: PUSH
2406: FOR_IN
2407: IFFALSE 2457
// if not HasTask ( i ) then
2409: LD_VAR 0 1
2413: PPUSH
2414: CALL_OW 314
2418: NOT
2419: IFFALSE 2455
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 81
2428: PUSH
2429: LD_INT 4
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PPUSH
2436: CALL_OW 69
2440: PPUSH
2441: LD_VAR 0 1
2445: PPUSH
2446: CALL_OW 74
2450: PPUSH
2451: CALL_OW 115
2455: GO 2406
2457: POP
2458: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2459: LD_VAR 0 4
2463: PPUSH
2464: LD_INT 50
2466: PUSH
2467: EMPTY
2468: LIST
2469: PPUSH
2470: CALL_OW 72
2474: NOT
2475: IFFALSE 2389
// DialogPowellsAttackFailed ;
2477: CALL 9950 0 0
// end ;
2481: PPOPN 5
2483: END
// every 0 0$2 do var vehicles , mechs , i ;
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
2490: PPUSH
2491: PPUSH
// begin enable ;
2492: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2493: LD_ADDR_VAR 0 1
2497: PUSH
2498: LD_INT 22
2500: PUSH
2501: LD_INT 1
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: LD_INT 21
2510: PUSH
2511: LD_INT 2
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: PUSH
2518: LD_INT 3
2520: PUSH
2521: LD_INT 24
2523: PUSH
2524: LD_INT 1000
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PUSH
2535: LD_INT 92
2537: PUSH
2538: LD_INT 191
2540: PUSH
2541: LD_INT 140
2543: PUSH
2544: LD_INT 10
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: LIST
2557: LIST
2558: PPUSH
2559: CALL_OW 69
2563: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2564: LD_ADDR_VAR 0 2
2568: PUSH
2569: LD_INT 22
2571: PUSH
2572: LD_INT 4
2574: PUSH
2575: EMPTY
2576: LIST
2577: LIST
2578: PUSH
2579: LD_INT 25
2581: PUSH
2582: LD_INT 3
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: PPUSH
2593: CALL_OW 69
2597: ST_TO_ADDR
// if not mechs then
2598: LD_VAR 0 2
2602: NOT
2603: IFFALSE 2607
// exit ;
2605: GO 2781
// if mc_remote_driver [ 1 ] then
2607: LD_EXP 63
2611: PUSH
2612: LD_INT 1
2614: ARRAY
2615: IFFALSE 2637
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2617: LD_ADDR_VAR 0 2
2621: PUSH
2622: LD_VAR 0 2
2626: PUSH
2627: LD_EXP 63
2631: PUSH
2632: LD_INT 1
2634: ARRAY
2635: DIFF
2636: ST_TO_ADDR
// if not mechs then
2637: LD_VAR 0 2
2641: NOT
2642: IFFALSE 2646
// exit ;
2644: GO 2781
// if vehicles then
2646: LD_VAR 0 1
2650: IFFALSE 2738
// begin for i in mechs do
2652: LD_ADDR_VAR 0 3
2656: PUSH
2657: LD_VAR 0 2
2661: PUSH
2662: FOR_IN
2663: IFFALSE 2734
// begin if GetTag ( i ) <> 120 then
2665: LD_VAR 0 3
2669: PPUSH
2670: CALL_OW 110
2674: PUSH
2675: LD_INT 120
2677: NONEQUAL
2678: IFFALSE 2692
// SetTag ( i , 120 ) ;
2680: LD_VAR 0 3
2684: PPUSH
2685: LD_INT 120
2687: PPUSH
2688: CALL_OW 109
// if IsInUnit ( i ) then
2692: LD_VAR 0 3
2696: PPUSH
2697: CALL_OW 310
2701: IFFALSE 2714
// ComExitBuilding ( i ) else
2703: LD_VAR 0 3
2707: PPUSH
2708: CALL_OW 122
2712: GO 2732
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2714: LD_VAR 0 3
2718: PPUSH
2719: LD_VAR 0 1
2723: PUSH
2724: LD_INT 1
2726: ARRAY
2727: PPUSH
2728: CALL_OW 129
// end ;
2732: GO 2662
2734: POP
2735: POP
// end else
2736: GO 2781
// if FilterByTag ( mechs , 120 ) then
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 120
2745: PPUSH
2746: CALL 46375 0 2
2750: IFFALSE 2781
// begin for i in mechs do
2752: LD_ADDR_VAR 0 3
2756: PUSH
2757: LD_VAR 0 2
2761: PUSH
2762: FOR_IN
2763: IFFALSE 2779
// begin SetTag ( i , 0 ) ;
2765: LD_VAR 0 3
2769: PPUSH
2770: LD_INT 0
2772: PPUSH
2773: CALL_OW 109
// end ;
2777: GO 2762
2779: POP
2780: POP
// end ; end ;
2781: PPOPN 3
2783: END
// every 0 0$2 do var people , sci , i ;
2784: GO 2786
2786: DISABLE
2787: LD_INT 0
2789: PPUSH
2790: PPUSH
2791: PPUSH
// begin enable ;
2792: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2793: LD_ADDR_VAR 0 1
2797: PUSH
2798: LD_INT 22
2800: PUSH
2801: LD_INT 1
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: PUSH
2808: LD_INT 21
2810: PUSH
2811: LD_INT 1
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PUSH
2818: LD_INT 3
2820: PUSH
2821: LD_INT 24
2823: PUSH
2824: LD_INT 1000
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: PUSH
2835: LD_INT 92
2837: PUSH
2838: LD_INT 188
2840: PUSH
2841: LD_INT 112
2843: PUSH
2844: LD_INT 10
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: LIST
2851: LIST
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: PPUSH
2859: CALL_OW 69
2863: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: LD_INT 22
2871: PUSH
2872: LD_INT 4
2874: PUSH
2875: EMPTY
2876: LIST
2877: LIST
2878: PUSH
2879: LD_INT 25
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PPUSH
2893: CALL_OW 69
2897: ST_TO_ADDR
// if not sci then
2898: LD_VAR 0 2
2902: NOT
2903: IFFALSE 2907
// exit ;
2905: GO 3042
// if people then
2907: LD_VAR 0 1
2911: IFFALSE 2999
// begin for i in sci do
2913: LD_ADDR_VAR 0 3
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: FOR_IN
2924: IFFALSE 2995
// begin if GetTag ( i ) <> 102 then
2926: LD_VAR 0 3
2930: PPUSH
2931: CALL_OW 110
2935: PUSH
2936: LD_INT 102
2938: NONEQUAL
2939: IFFALSE 2953
// SetTag ( i , 102 ) ;
2941: LD_VAR 0 3
2945: PPUSH
2946: LD_INT 102
2948: PPUSH
2949: CALL_OW 109
// if IsInUnit ( i ) then
2953: LD_VAR 0 3
2957: PPUSH
2958: CALL_OW 310
2962: IFFALSE 2975
// ComExitBuilding ( i ) else
2964: LD_VAR 0 3
2968: PPUSH
2969: CALL_OW 122
2973: GO 2993
// ComHeal ( i , people [ 1 ] ) ;
2975: LD_VAR 0 3
2979: PPUSH
2980: LD_VAR 0 1
2984: PUSH
2985: LD_INT 1
2987: ARRAY
2988: PPUSH
2989: CALL_OW 128
// end ;
2993: GO 2923
2995: POP
2996: POP
// end else
2997: GO 3042
// if FilterByTag ( sci , 102 ) then
2999: LD_VAR 0 2
3003: PPUSH
3004: LD_INT 102
3006: PPUSH
3007: CALL 46375 0 2
3011: IFFALSE 3042
// begin for i in sci do
3013: LD_ADDR_VAR 0 3
3017: PUSH
3018: LD_VAR 0 2
3022: PUSH
3023: FOR_IN
3024: IFFALSE 3040
// begin SetTag ( i , 0 ) ;
3026: LD_VAR 0 3
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 109
// end ;
3038: GO 3023
3040: POP
3041: POP
// end ; end ;
3042: PPOPN 3
3044: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3045: LD_INT 22
3047: PUSH
3048: LD_INT 4
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 33
3057: PUSH
3058: LD_INT 2
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: PUSH
3065: LD_INT 50
3067: PUSH
3068: EMPTY
3069: LIST
3070: PUSH
3071: LD_INT 3
3073: PUSH
3074: LD_INT 61
3076: PUSH
3077: EMPTY
3078: LIST
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL_OW 69
3094: IFFALSE 3185
3096: GO 3098
3098: DISABLE
3099: LD_INT 0
3101: PPUSH
3102: PPUSH
// begin enable ;
3103: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3104: LD_ADDR_VAR 0 2
3108: PUSH
3109: LD_INT 22
3111: PUSH
3112: LD_INT 4
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: PUSH
3119: LD_INT 33
3121: PUSH
3122: LD_INT 2
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: PUSH
3129: LD_INT 50
3131: PUSH
3132: EMPTY
3133: LIST
3134: PUSH
3135: LD_INT 3
3137: PUSH
3138: LD_INT 61
3140: PUSH
3141: EMPTY
3142: LIST
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: PPUSH
3154: CALL_OW 69
3158: ST_TO_ADDR
// for i in tmp do
3159: LD_ADDR_VAR 0 1
3163: PUSH
3164: LD_VAR 0 2
3168: PUSH
3169: FOR_IN
3170: IFFALSE 3183
// Connect ( i ) ;
3172: LD_VAR 0 1
3176: PPUSH
3177: CALL 19423 0 1
3181: GO 3169
3183: POP
3184: POP
// end ; end_of_file
3185: PPOPN 2
3187: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3188: LD_INT 0
3190: PPUSH
3191: PPUSH
3192: PPUSH
3193: PPUSH
3194: PPUSH
3195: PPUSH
// gensher_side := 2 ;
3196: LD_ADDR_EXP 14
3200: PUSH
3201: LD_INT 2
3203: ST_TO_ADDR
// uc_side := gensher_side ;
3204: LD_ADDR_OWVAR 20
3208: PUSH
3209: LD_EXP 14
3213: ST_TO_ADDR
// uc_nation := 2 ;
3214: LD_ADDR_OWVAR 21
3218: PUSH
3219: LD_INT 2
3221: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3222: LD_ADDR_VAR 0 6
3226: PUSH
3227: LD_INT 5
3229: PUSH
3230: LD_INT 42
3232: PUSH
3233: LD_INT 29
3235: PUSH
3236: LD_INT 5
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: PUSH
3245: LD_INT 5
3247: PUSH
3248: LD_INT 36
3250: PUSH
3251: LD_INT 40
3253: PUSH
3254: LD_INT 5
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: LIST
3261: LIST
3262: PUSH
3263: LD_INT 6
3265: PUSH
3266: LD_INT 13
3268: PUSH
3269: LD_INT 18
3271: PUSH
3272: LD_INT 1
3274: PUSH
3275: LD_INT 10
3277: PUSH
3278: LD_INT 15
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 27
3291: PUSH
3292: LD_INT 17
3294: PUSH
3295: LD_INT 3
3297: PUSH
3298: LD_INT 0
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 29
3309: PUSH
3310: LD_INT 56
3312: PUSH
3313: LD_INT 23
3315: PUSH
3316: LD_INT 0
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 11
3330: PUSH
3331: LD_INT 7
3333: PUSH
3334: LD_INT 2
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 27
3345: PUSH
3346: LD_INT 20
3348: PUSH
3349: LD_INT 3
3351: PUSH
3352: LD_INT 0
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 27
3363: PUSH
3364: LD_INT 23
3366: PUSH
3367: LD_INT 3
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 27
3381: PUSH
3382: LD_INT 26
3384: PUSH
3385: LD_INT 3
3387: PUSH
3388: LD_INT 0
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 6
3399: PUSH
3400: LD_INT 17
3402: PUSH
3403: LD_INT 27
3405: PUSH
3406: LD_INT 1
3408: PUSH
3409: LD_INT 13
3411: PUSH
3412: LD_INT 11
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: PUSH
3423: LD_INT 32
3425: PUSH
3426: LD_INT 27
3428: PUSH
3429: LD_INT 44
3431: PUSH
3432: LD_INT 5
3434: PUSH
3435: LD_INT 27
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: LIST
3442: LIST
3443: LIST
3444: PUSH
3445: LD_INT 32
3447: PUSH
3448: LD_INT 41
3450: PUSH
3451: LD_INT 41
3453: PUSH
3454: LD_INT 5
3456: PUSH
3457: LD_INT 27
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: LIST
3466: PUSH
3467: LD_INT 32
3469: PUSH
3470: LD_INT 45
3472: PUSH
3473: LD_INT 24
3475: PUSH
3476: LD_INT 5
3478: PUSH
3479: LD_INT 28
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: LIST
3488: PUSH
3489: LD_INT 32
3491: PUSH
3492: LD_INT 48
3494: PUSH
3495: LD_INT 19
3497: PUSH
3498: LD_INT 5
3500: PUSH
3501: LD_INT 28
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: PUSH
3511: LD_INT 32
3513: PUSH
3514: LD_INT 41
3516: PUSH
3517: LD_INT 3
3519: PUSH
3520: LD_INT 4
3522: PUSH
3523: LD_INT 28
3525: PUSH
3526: EMPTY
3527: LIST
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: PUSH
3533: LD_INT 5
3535: PUSH
3536: LD_INT 44
3538: PUSH
3539: LD_INT 9
3541: PUSH
3542: LD_INT 4
3544: PUSH
3545: EMPTY
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: PUSH
3551: LD_INT 30
3553: PUSH
3554: LD_INT 52
3556: PUSH
3557: LD_INT 40
3559: PUSH
3560: LD_INT 3
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: LIST
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: ST_TO_ADDR
// for i in list do
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: LD_VAR 0 6
3597: PUSH
3598: FOR_IN
3599: IFFALSE 3809
// begin uc_side := 2 ;
3601: LD_ADDR_OWVAR 20
3605: PUSH
3606: LD_INT 2
3608: ST_TO_ADDR
// uc_nation := 2 ;
3609: LD_ADDR_OWVAR 21
3613: PUSH
3614: LD_INT 2
3616: ST_TO_ADDR
// InitBc ;
3617: CALL_OW 21
// bc_type := i [ 1 ] ;
3621: LD_ADDR_OWVAR 42
3625: PUSH
3626: LD_VAR 0 2
3630: PUSH
3631: LD_INT 1
3633: ARRAY
3634: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
3635: LD_VAR 0 2
3639: PUSH
3640: LD_INT 1
3642: ARRAY
3643: PUSH
3644: LD_INT 29
3646: PUSH
3647: LD_INT 30
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: IN
3654: IFFALSE 3681
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 2 ) ;
3656: LD_VAR 0 2
3660: PUSH
3661: LD_INT 2
3663: ARRAY
3664: PPUSH
3665: LD_VAR 0 2
3669: PUSH
3670: LD_INT 3
3672: ARRAY
3673: PPUSH
3674: LD_INT 2
3676: PPUSH
3677: CALL_OW 441
// if i [ 1 ] = b_lab then
3681: LD_VAR 0 2
3685: PUSH
3686: LD_INT 1
3688: ARRAY
3689: PUSH
3690: LD_INT 6
3692: EQUAL
3693: IFFALSE 3731
// begin bc_type := b_lab_full ;
3695: LD_ADDR_OWVAR 42
3699: PUSH
3700: LD_INT 8
3702: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3703: LD_ADDR_OWVAR 44
3707: PUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 5
3715: ARRAY
3716: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3717: LD_ADDR_OWVAR 45
3721: PUSH
3722: LD_VAR 0 2
3726: PUSH
3727: LD_INT 6
3729: ARRAY
3730: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3731: LD_ADDR_VAR 0 3
3735: PUSH
3736: LD_VAR 0 2
3740: PUSH
3741: LD_INT 2
3743: ARRAY
3744: PPUSH
3745: LD_VAR 0 2
3749: PUSH
3750: LD_INT 3
3752: ARRAY
3753: PPUSH
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 4
3761: ARRAY
3762: PPUSH
3763: CALL_OW 47
3767: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3768: LD_VAR 0 2
3772: PUSH
3773: LD_INT 1
3775: ARRAY
3776: PUSH
3777: LD_INT 33
3779: PUSH
3780: LD_INT 32
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: IN
3787: IFFALSE 3807
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3789: LD_VAR 0 3
3793: PPUSH
3794: LD_VAR 0 2
3798: PUSH
3799: LD_INT 5
3801: ARRAY
3802: PPUSH
3803: CALL_OW 431
// end ;
3807: GO 3598
3809: POP
3810: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3811: LD_ADDR_VAR 0 4
3815: PUSH
3816: LD_INT 7
3818: PPUSH
3819: LD_INT 2
3821: PPUSH
3822: LD_STRING 
3824: PPUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 7
3830: PUSH
3831: LD_INT 6
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: LIST
3838: PUSH
3839: LD_OWVAR 67
3843: ARRAY
3844: PPUSH
3845: LD_INT 11500
3847: PUSH
3848: LD_INT 1100
3850: PUSH
3851: LD_INT 60
3853: PUSH
3854: EMPTY
3855: LIST
3856: LIST
3857: LIST
3858: PPUSH
3859: LD_INT 6
3861: PUSH
3862: LD_INT 6
3864: PUSH
3865: LD_INT 6
3867: PUSH
3868: LD_INT 6
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PPUSH
3877: CALL 19776 0 6
3881: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3882: LD_ADDR_EXP 23
3886: PUSH
3887: LD_EXP 23
3891: PPUSH
3892: LD_INT 2
3894: PPUSH
3895: LD_VAR 0 4
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 2
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 21
3912: PUSH
3913: LD_INT 3
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: UNION
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3935: LD_ADDR_VAR 0 4
3939: PUSH
3940: LD_INT 22
3942: PUSH
3943: LD_INT 2
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 30
3952: PUSH
3953: LD_INT 31
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PPUSH
3964: CALL_OW 69
3968: ST_TO_ADDR
// for i in tmp do
3969: LD_ADDR_VAR 0 2
3973: PUSH
3974: LD_VAR 0 4
3978: PUSH
3979: FOR_IN
3980: IFFALSE 4050
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3982: LD_INT 0
3984: PPUSH
3985: LD_INT 1
3987: PPUSH
3988: LD_INT 4
3990: PUSH
3991: LD_INT 3
3993: PUSH
3994: LD_INT 3
3996: PUSH
3997: EMPTY
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_OWVAR 67
4006: ARRAY
4007: PPUSH
4008: CALL_OW 380
// un := CreateHuman ;
4012: LD_ADDR_VAR 0 5
4016: PUSH
4017: CALL_OW 44
4021: ST_TO_ADDR
// SetDir ( un , 1 ) ;
4022: LD_VAR 0 5
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4034: LD_VAR 0 5
4038: PPUSH
4039: LD_VAR 0 2
4043: PPUSH
4044: CALL_OW 52
// end ;
4048: GO 3979
4050: POP
4051: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
4052: LD_ADDR_VAR 0 4
4056: PUSH
4057: LD_INT 15
4059: PPUSH
4060: LD_INT 0
4062: PPUSH
4063: CALL_OW 517
4067: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_VAR 0 4
4082: PUSH
4083: LD_INT 1
4085: ARRAY
4086: PUSH
4087: FOR_TO
4088: IFFALSE 4190
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4090: LD_VAR 0 4
4094: PUSH
4095: LD_INT 1
4097: ARRAY
4098: PUSH
4099: LD_VAR 0 2
4103: ARRAY
4104: PPUSH
4105: LD_VAR 0 4
4109: PUSH
4110: LD_INT 2
4112: ARRAY
4113: PUSH
4114: LD_VAR 0 2
4118: ARRAY
4119: PPUSH
4120: LD_INT 2
4122: PPUSH
4123: LD_INT 0
4125: PPUSH
4126: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4130: LD_ADDR_EXP 3
4134: PUSH
4135: LD_EXP 3
4139: PPUSH
4140: LD_EXP 3
4144: PUSH
4145: LD_INT 1
4147: PLUS
4148: PPUSH
4149: LD_VAR 0 4
4153: PUSH
4154: LD_INT 1
4156: ARRAY
4157: PUSH
4158: LD_VAR 0 2
4162: ARRAY
4163: PUSH
4164: LD_VAR 0 4
4168: PUSH
4169: LD_INT 2
4171: ARRAY
4172: PUSH
4173: LD_VAR 0 2
4177: ARRAY
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: PPUSH
4183: CALL_OW 2
4187: ST_TO_ADDR
// end ;
4188: GO 4087
4190: POP
4191: POP
// if Difficulty > 1 then
4192: LD_OWVAR 67
4196: PUSH
4197: LD_INT 1
4199: GREATER
4200: IFFALSE 4342
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4202: LD_ADDR_VAR 0 4
4206: PUSH
4207: LD_INT 19
4209: PPUSH
4210: LD_INT 0
4212: PPUSH
4213: CALL_OW 517
4217: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_VAR 0 4
4232: PUSH
4233: LD_INT 1
4235: ARRAY
4236: PUSH
4237: FOR_TO
4238: IFFALSE 4340
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4240: LD_VAR 0 4
4244: PUSH
4245: LD_INT 1
4247: ARRAY
4248: PUSH
4249: LD_VAR 0 2
4253: ARRAY
4254: PPUSH
4255: LD_VAR 0 4
4259: PUSH
4260: LD_INT 2
4262: ARRAY
4263: PUSH
4264: LD_VAR 0 2
4268: ARRAY
4269: PPUSH
4270: LD_INT 2
4272: PPUSH
4273: LD_INT 0
4275: PPUSH
4276: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4280: LD_ADDR_EXP 3
4284: PUSH
4285: LD_EXP 3
4289: PPUSH
4290: LD_EXP 3
4294: PUSH
4295: LD_INT 1
4297: PLUS
4298: PPUSH
4299: LD_VAR 0 4
4303: PUSH
4304: LD_INT 1
4306: ARRAY
4307: PUSH
4308: LD_VAR 0 2
4312: ARRAY
4313: PUSH
4314: LD_VAR 0 4
4318: PUSH
4319: LD_INT 2
4321: ARRAY
4322: PUSH
4323: LD_VAR 0 2
4327: ARRAY
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: PPUSH
4333: CALL_OW 2
4337: ST_TO_ADDR
// end ;
4338: GO 4237
4340: POP
4341: POP
// end ; gensherAttackGroup := [ ] ;
4342: LD_ADDR_EXP 15
4346: PUSH
4347: EMPTY
4348: ST_TO_ADDR
// end ;
4349: LD_VAR 0 1
4353: RET
// export function InitMC_Gensher ( ) ; begin
4354: LD_INT 0
4356: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4357: LD_INT 2
4359: PPUSH
4360: LD_INT 2
4362: PPUSH
4363: CALL 79441 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4367: LD_INT 2
4369: PPUSH
4370: LD_INT 9
4372: PPUSH
4373: CALL 79385 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4377: LD_INT 2
4379: PPUSH
4380: LD_INT 56
4382: PUSH
4383: LD_INT 23
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 52
4396: PUSH
4397: LD_INT 40
4399: PUSH
4400: LD_INT 1
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: LIST
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PPUSH
4412: CALL 78444 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4416: LD_INT 2
4418: PPUSH
4419: LD_INT 27
4421: PUSH
4422: LD_INT 28
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PPUSH
4429: CALL 79273 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4433: LD_INT 2
4435: PPUSH
4436: LD_INT 8
4438: PPUSH
4439: CALL 78955 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4443: LD_INT 2
4445: PPUSH
4446: LD_INT 7
4448: PPUSH
4449: CALL 78686 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4453: LD_INT 2
4455: PPUSH
4456: LD_INT 4
4458: PPUSH
4459: CALL 78305 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4463: LD_INT 2
4465: PPUSH
4466: LD_INT 13
4468: PUSH
4469: LD_INT 2
4471: PUSH
4472: LD_INT 1
4474: PUSH
4475: LD_INT 31
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: PUSH
4484: LD_INT 13
4486: PUSH
4487: LD_INT 2
4489: PUSH
4490: LD_INT 1
4492: PUSH
4493: LD_INT 31
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: PUSH
4502: LD_INT 14
4504: PUSH
4505: LD_INT 1
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 27
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: PUSH
4520: LD_INT 14
4522: PUSH
4523: LD_INT 1
4525: PUSH
4526: LD_INT 2
4528: PUSH
4529: LD_INT 27
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: PUSH
4538: LD_INT 14
4540: PUSH
4541: LD_INT 1
4543: PUSH
4544: LD_INT 2
4546: PUSH
4547: LD_INT 28
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 14
4558: PUSH
4559: LD_INT 1
4561: PUSH
4562: LD_INT 2
4564: PUSH
4565: LD_INT 26
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: PPUSH
4582: CALL 78120 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4586: LD_INT 2
4588: PPUSH
4589: LD_INT 11
4591: PPUSH
4592: LD_INT 7
4594: PPUSH
4595: LD_INT 2
4597: PPUSH
4598: LD_INT 23
4600: PUSH
4601: LD_INT 16
4603: PUSH
4604: LD_INT 17
4606: PUSH
4607: LD_INT 18
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: LIST
4618: LIST
4619: PPUSH
4620: CALL 79067 0 5
// end ;
4624: LD_VAR 0 1
4628: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4629: LD_EXP 3
4633: PUSH
4634: LD_INT 15
4636: PPUSH
4637: LD_INT 81
4639: PUSH
4640: LD_INT 2
4642: PUSH
4643: EMPTY
4644: LIST
4645: LIST
4646: PPUSH
4647: CALL_OW 70
4651: AND
4652: IFFALSE 4865
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
4660: PPUSH
4661: PPUSH
4662: PPUSH
4663: PPUSH
// begin enable ;
4664: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: LD_INT 15
4672: PPUSH
4673: LD_INT 81
4675: PUSH
4676: LD_INT 2
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: PPUSH
4683: CALL_OW 70
4687: ST_TO_ADDR
// if not tmp then
4688: LD_VAR 0 3
4692: NOT
4693: IFFALSE 4697
// exit ;
4695: GO 4865
// for i in tmp do
4697: LD_ADDR_VAR 0 1
4701: PUSH
4702: LD_VAR 0 3
4706: PUSH
4707: FOR_IN
4708: IFFALSE 4863
// begin x := GetX ( i ) ;
4710: LD_ADDR_VAR 0 4
4714: PUSH
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 250
4724: ST_TO_ADDR
// y := GetY ( i ) ;
4725: LD_ADDR_VAR 0 5
4729: PUSH
4730: LD_VAR 0 1
4734: PPUSH
4735: CALL_OW 251
4739: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4740: LD_VAR 0 4
4744: PPUSH
4745: LD_VAR 0 5
4749: PPUSH
4750: CALL_OW 458
4754: IFFALSE 4861
// begin LaunchMineAtPos ( x , y , 2 ) ;
4756: LD_VAR 0 4
4760: PPUSH
4761: LD_VAR 0 5
4765: PPUSH
4766: LD_INT 2
4768: PPUSH
4769: CALL_OW 456
// for j = 1 to staticMines do
4773: LD_ADDR_VAR 0 2
4777: PUSH
4778: DOUBLE
4779: LD_INT 1
4781: DEC
4782: ST_TO_ADDR
4783: LD_EXP 3
4787: PUSH
4788: FOR_TO
4789: IFFALSE 4859
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4791: LD_EXP 3
4795: PUSH
4796: LD_VAR 0 2
4800: ARRAY
4801: PUSH
4802: LD_INT 1
4804: ARRAY
4805: PUSH
4806: LD_VAR 0 4
4810: EQUAL
4811: PUSH
4812: LD_EXP 3
4816: PUSH
4817: LD_VAR 0 2
4821: ARRAY
4822: PUSH
4823: LD_INT 2
4825: ARRAY
4826: PUSH
4827: LD_VAR 0 5
4831: EQUAL
4832: AND
4833: IFFALSE 4857
// begin staticMines := Delete ( staticMines , j ) ;
4835: LD_ADDR_EXP 3
4839: PUSH
4840: LD_EXP 3
4844: PPUSH
4845: LD_VAR 0 2
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
// break ;
4855: GO 4859
// end ;
4857: GO 4788
4859: POP
4860: POP
// end ; end ;
4861: GO 4707
4863: POP
4864: POP
// end ;
4865: PPOPN 5
4867: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4868: LD_INT 7
4870: PPUSH
4871: CALL_OW 302
4875: PUSH
4876: LD_EXP 4
4880: NOT
4881: AND
4882: IFFALSE 5482
4884: GO 4886
4886: DISABLE
4887: LD_INT 0
4889: PPUSH
4890: PPUSH
4891: PPUSH
4892: PPUSH
4893: PPUSH
// begin enable ;
4894: ENABLE
// base := 2 ;
4895: LD_ADDR_VAR 0 2
4899: PUSH
4900: LD_INT 2
4902: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4903: LD_ADDR_VAR 0 3
4907: PUSH
4908: LD_INT 14
4910: PUSH
4911: LD_INT 1
4913: PUSH
4914: LD_INT 2
4916: PUSH
4917: LD_INT 27
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 14
4928: PUSH
4929: LD_INT 1
4931: PUSH
4932: LD_INT 2
4934: PUSH
4935: LD_INT 27
4937: PUSH
4938: EMPTY
4939: LIST
4940: LIST
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 14
4946: PUSH
4947: LD_INT 1
4949: PUSH
4950: LD_INT 2
4952: PUSH
4953: LD_INT 28
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 14
4964: PUSH
4965: LD_INT 1
4967: PUSH
4968: LD_INT 2
4970: PUSH
4971: LD_INT 26
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: PUSH
4980: EMPTY
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4986: LD_ADDR_VAR 0 5
4990: PUSH
4991: LD_VAR 0 5
4995: PUSH
4996: LD_OWVAR 1
5000: PUSH
5001: LD_INT 21000
5003: DIV
5004: PLUS
5005: ST_TO_ADDR
// if amount > 8 then
5006: LD_VAR 0 5
5010: PUSH
5011: LD_INT 8
5013: GREATER
5014: IFFALSE 5024
// amount := 8 ;
5016: LD_ADDR_VAR 0 5
5020: PUSH
5021: LD_INT 8
5023: ST_TO_ADDR
// for i = 1 to amount do
5024: LD_ADDR_VAR 0 1
5028: PUSH
5029: DOUBLE
5030: LD_INT 1
5032: DEC
5033: ST_TO_ADDR
5034: LD_VAR 0 5
5038: PUSH
5039: FOR_TO
5040: IFFALSE 5128
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
5042: LD_ADDR_VAR 0 3
5046: PUSH
5047: LD_VAR 0 3
5051: PPUSH
5052: LD_VAR 0 3
5056: PUSH
5057: LD_INT 1
5059: PLUS
5060: PPUSH
5061: LD_INT 14
5063: PUSH
5064: LD_INT 13
5066: PUSH
5067: EMPTY
5068: LIST
5069: LIST
5070: PUSH
5071: LD_INT 1
5073: PPUSH
5074: LD_INT 2
5076: PPUSH
5077: CALL_OW 12
5081: ARRAY
5082: PUSH
5083: LD_INT 1
5085: PUSH
5086: LD_INT 2
5088: PUSH
5089: LD_INT 28
5091: PUSH
5092: LD_INT 25
5094: PUSH
5095: LD_INT 27
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 1
5105: PPUSH
5106: LD_INT 3
5108: PPUSH
5109: CALL_OW 12
5113: ARRAY
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: PPUSH
5121: CALL_OW 2
5125: ST_TO_ADDR
5126: GO 5039
5128: POP
5129: POP
// MC_InsertProduceList ( base , tmp ) ;
5130: LD_VAR 0 2
5134: PPUSH
5135: LD_VAR 0 3
5139: PPUSH
5140: CALL 78168 0 2
// repeat wait ( 0 0$1 ) ;
5144: LD_INT 35
5146: PPUSH
5147: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5151: LD_VAR 0 2
5155: PPUSH
5156: LD_INT 1
5158: PPUSH
5159: CALL 79586 0 2
5163: PUSH
5164: LD_VAR 0 5
5168: GREATEREQUAL
5169: IFFALSE 5144
// wait ( 0 0$30 ) ;
5171: LD_INT 1050
5173: PPUSH
5174: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5178: LD_ADDR_VAR 0 4
5182: PUSH
5183: LD_EXP 42
5187: PUSH
5188: LD_VAR 0 2
5192: ARRAY
5193: PUSH
5194: LD_EXP 42
5198: PUSH
5199: LD_VAR 0 2
5203: ARRAY
5204: PPUSH
5205: LD_INT 2
5207: PUSH
5208: LD_INT 34
5210: PUSH
5211: LD_INT 31
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: PUSH
5218: LD_INT 34
5220: PUSH
5221: LD_INT 32
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: PUSH
5228: LD_INT 34
5230: PUSH
5231: LD_INT 88
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: PPUSH
5244: CALL_OW 72
5248: DIFF
5249: ST_TO_ADDR
// if not attackers then
5250: LD_VAR 0 4
5254: NOT
5255: IFFALSE 5259
// exit ;
5257: GO 5482
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5259: LD_ADDR_EXP 42
5263: PUSH
5264: LD_EXP 42
5268: PPUSH
5269: LD_VAR 0 2
5273: PPUSH
5274: LD_EXP 42
5278: PUSH
5279: LD_VAR 0 2
5283: ARRAY
5284: PUSH
5285: LD_VAR 0 4
5289: DIFF
5290: PPUSH
5291: CALL_OW 1
5295: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5296: LD_VAR 0 4
5300: PPUSH
5301: LD_INT 107
5303: PPUSH
5304: LD_INT 74
5306: PPUSH
5307: CALL_OW 114
// wait ( 0 0$5 ) ;
5311: LD_INT 175
5313: PPUSH
5314: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5318: LD_INT 35
5320: PPUSH
5321: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5325: LD_VAR 0 4
5329: PPUSH
5330: LD_INT 60
5332: PUSH
5333: EMPTY
5334: LIST
5335: PPUSH
5336: CALL_OW 72
5340: NOT
5341: IFFALSE 5318
// if rand ( 0 , 1 ) then
5343: LD_INT 0
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 12
5353: IFFALSE 5372
// ComAgressiveMove ( attackers , 155 , 108 ) else
5355: LD_VAR 0 4
5359: PPUSH
5360: LD_INT 155
5362: PPUSH
5363: LD_INT 108
5365: PPUSH
5366: CALL_OW 114
5370: GO 5387
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5372: LD_VAR 0 4
5376: PPUSH
5377: LD_INT 149
5379: PPUSH
5380: LD_INT 55
5382: PPUSH
5383: CALL_OW 114
// wait ( 0 0$10 ) ;
5387: LD_INT 350
5389: PPUSH
5390: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5394: LD_INT 35
5396: PPUSH
5397: CALL_OW 67
// for i in attackers do
5401: LD_ADDR_VAR 0 1
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: FOR_IN
5412: IFFALSE 5462
// if not HasTask ( i ) then
5414: LD_VAR 0 1
5418: PPUSH
5419: CALL_OW 314
5423: NOT
5424: IFFALSE 5460
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5426: LD_VAR 0 1
5430: PPUSH
5431: LD_INT 81
5433: PUSH
5434: LD_INT 2
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: PPUSH
5441: CALL_OW 69
5445: PPUSH
5446: LD_VAR 0 1
5450: PPUSH
5451: CALL_OW 74
5455: PPUSH
5456: CALL_OW 115
5460: GO 5411
5462: POP
5463: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5464: LD_VAR 0 4
5468: PPUSH
5469: LD_INT 50
5471: PUSH
5472: EMPTY
5473: LIST
5474: PPUSH
5475: CALL_OW 72
5479: NOT
5480: IFFALSE 5394
// end ;
5482: PPOPN 5
5484: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5485: LD_EXP 4
5489: NOT
5490: PUSH
5491: LD_OWVAR 1
5495: PUSH
5496: LD_INT 191100
5498: LESS
5499: AND
5500: IFFALSE 6172
5502: GO 5504
5504: DISABLE
5505: LD_INT 0
5507: PPUSH
5508: PPUSH
5509: PPUSH
// begin enable ;
5510: ENABLE
// tmp := [ ] ;
5511: LD_ADDR_VAR 0 3
5515: PUSH
5516: EMPTY
5517: ST_TO_ADDR
// if tick < 35 35$00 then
5518: LD_OWVAR 1
5522: PUSH
5523: LD_INT 73500
5525: LESS
5526: IFFALSE 5724
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5528: LD_ADDR_VAR 0 1
5532: PUSH
5533: DOUBLE
5534: LD_INT 1
5536: DEC
5537: ST_TO_ADDR
5538: LD_INT 4
5540: PUSH
5541: LD_INT 5
5543: PUSH
5544: LD_INT 5
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PUSH
5558: FOR_TO
5559: IFFALSE 5720
// begin uc_side := 2 ;
5561: LD_ADDR_OWVAR 20
5565: PUSH
5566: LD_INT 2
5568: ST_TO_ADDR
// uc_nation := 2 ;
5569: LD_ADDR_OWVAR 21
5573: PUSH
5574: LD_INT 2
5576: ST_TO_ADDR
// InitHC_All ( ) ;
5577: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5581: LD_INT 0
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: LD_INT 5
5589: PUSH
5590: LD_INT 6
5592: PUSH
5593: LD_INT 7
5595: PUSH
5596: EMPTY
5597: LIST
5598: LIST
5599: LIST
5600: PUSH
5601: LD_OWVAR 67
5605: ARRAY
5606: PPUSH
5607: CALL_OW 380
// un := CreateHuman ;
5611: LD_ADDR_VAR 0 2
5615: PUSH
5616: CALL_OW 44
5620: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5621: LD_VAR 0 2
5625: PPUSH
5626: LD_INT 17
5628: PPUSH
5629: LD_INT 0
5631: PPUSH
5632: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5636: LD_VAR 0 2
5640: PPUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 8
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PUSH
5651: LD_INT 1
5653: PPUSH
5654: LD_INT 2
5656: PPUSH
5657: CALL_OW 12
5661: ARRAY
5662: PPUSH
5663: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_INT 111
5674: PPUSH
5675: LD_INT 34
5677: PPUSH
5678: CALL_OW 114
// wait ( 0 0$2 ) ;
5682: LD_INT 70
5684: PPUSH
5685: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5689: LD_ADDR_VAR 0 3
5693: PUSH
5694: LD_VAR 0 3
5698: PPUSH
5699: LD_VAR 0 3
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PPUSH
5708: LD_VAR 0 2
5712: PPUSH
5713: CALL_OW 1
5717: ST_TO_ADDR
// end ;
5718: GO 5558
5720: POP
5721: POP
// end else
5722: GO 5865
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5724: LD_ADDR_VAR 0 1
5728: PUSH
5729: DOUBLE
5730: LD_INT 1
5732: DEC
5733: ST_TO_ADDR
5734: LD_INT 4
5736: PUSH
5737: LD_INT 5
5739: PUSH
5740: LD_INT 5
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_OWVAR 67
5752: ARRAY
5753: PUSH
5754: FOR_TO
5755: IFFALSE 5863
// begin uc_side := 2 ;
5757: LD_ADDR_OWVAR 20
5761: PUSH
5762: LD_INT 2
5764: ST_TO_ADDR
// uc_nation := 0 ;
5765: LD_ADDR_OWVAR 21
5769: PUSH
5770: LD_INT 0
5772: ST_TO_ADDR
// InitHC_All ( ) ;
5773: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5777: LD_ADDR_OWVAR 28
5781: PUSH
5782: LD_INT 17
5784: ST_TO_ADDR
// un := CreateHuman ;
5785: LD_ADDR_VAR 0 2
5789: PUSH
5790: CALL_OW 44
5794: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5795: LD_VAR 0 2
5799: PPUSH
5800: LD_INT 17
5802: PPUSH
5803: LD_INT 0
5805: PPUSH
5806: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5810: LD_VAR 0 2
5814: PPUSH
5815: LD_INT 110
5817: PPUSH
5818: LD_INT 33
5820: PPUSH
5821: CALL_OW 114
// wait ( 0 0$2 ) ;
5825: LD_INT 70
5827: PPUSH
5828: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5832: LD_ADDR_VAR 0 3
5836: PUSH
5837: LD_VAR 0 3
5841: PPUSH
5842: LD_VAR 0 3
5846: PUSH
5847: LD_INT 1
5849: PLUS
5850: PPUSH
5851: LD_VAR 0 2
5855: PPUSH
5856: CALL_OW 1
5860: ST_TO_ADDR
// end ;
5861: GO 5754
5863: POP
5864: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5865: LD_ADDR_VAR 0 1
5869: PUSH
5870: DOUBLE
5871: LD_INT 1
5873: DEC
5874: ST_TO_ADDR
5875: LD_INT 3
5877: PUSH
5878: LD_INT 4
5880: PUSH
5881: LD_INT 5
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PUSH
5889: LD_OWVAR 67
5893: ARRAY
5894: PUSH
5895: FOR_TO
5896: IFFALSE 6061
// begin uc_side := 2 ;
5898: LD_ADDR_OWVAR 20
5902: PUSH
5903: LD_INT 2
5905: ST_TO_ADDR
// uc_nation := 2 ;
5906: LD_ADDR_OWVAR 21
5910: PUSH
5911: LD_INT 2
5913: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5914: LD_INT 14
5916: PPUSH
5917: LD_INT 3
5919: PPUSH
5920: LD_INT 5
5922: PPUSH
5923: LD_INT 29
5925: PUSH
5926: LD_INT 28
5928: PUSH
5929: LD_INT 27
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 1
5939: PPUSH
5940: LD_INT 3
5942: PPUSH
5943: CALL_OW 12
5947: ARRAY
5948: PPUSH
5949: LD_INT 90
5951: PPUSH
5952: CALL 15955 0 5
// un := CreateVehicle ;
5956: LD_ADDR_VAR 0 2
5960: PUSH
5961: CALL_OW 45
5965: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5966: LD_VAR 0 2
5970: PPUSH
5971: LD_INT 2
5973: PPUSH
5974: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_INT 17
5985: PPUSH
5986: LD_INT 0
5988: PPUSH
5989: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5993: LD_VAR 0 2
5997: PPUSH
5998: LD_INT 66
6000: PPUSH
6001: LD_INT 23
6003: PPUSH
6004: CALL_OW 111
// wait ( 0 0$3 ) ;
6008: LD_INT 105
6010: PPUSH
6011: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 147
6022: PPUSH
6023: LD_INT 103
6025: PPUSH
6026: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6030: LD_ADDR_VAR 0 3
6034: PUSH
6035: LD_VAR 0 3
6039: PPUSH
6040: LD_VAR 0 3
6044: PUSH
6045: LD_INT 1
6047: PLUS
6048: PPUSH
6049: LD_VAR 0 2
6053: PPUSH
6054: CALL_OW 1
6058: ST_TO_ADDR
// end ;
6059: GO 5895
6061: POP
6062: POP
// if not tmp then
6063: LD_VAR 0 3
6067: NOT
6068: IFFALSE 6072
// exit ;
6070: GO 6172
// wait ( 0 0$5 ) ;
6072: LD_INT 175
6074: PPUSH
6075: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6079: LD_INT 70
6081: PPUSH
6082: CALL_OW 67
// for i in tmp do
6086: LD_ADDR_VAR 0 1
6090: PUSH
6091: LD_VAR 0 3
6095: PUSH
6096: FOR_IN
6097: IFFALSE 6163
// begin if not IsOk ( i ) then
6099: LD_VAR 0 1
6103: PPUSH
6104: CALL_OW 302
6108: NOT
6109: IFFALSE 6127
// tmp := tmp diff i ;
6111: LD_ADDR_VAR 0 3
6115: PUSH
6116: LD_VAR 0 3
6120: PUSH
6121: LD_VAR 0 1
6125: DIFF
6126: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6127: LD_VAR 0 1
6131: PPUSH
6132: LD_INT 81
6134: PUSH
6135: LD_INT 2
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 69
6146: PPUSH
6147: LD_VAR 0 1
6151: PPUSH
6152: CALL_OW 74
6156: PPUSH
6157: CALL_OW 115
// end ;
6161: GO 6096
6163: POP
6164: POP
// until not tmp ;
6165: LD_VAR 0 3
6169: NOT
6170: IFFALSE 6079
// end ;
6172: PPOPN 3
6174: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6175: LD_OWVAR 67
6179: PUSH
6180: LD_INT 1
6182: GREATER
6183: IFFALSE 6281
6185: GO 6187
6187: DISABLE
6188: LD_INT 0
6190: PPUSH
// begin uc_side := 2 ;
6191: LD_ADDR_OWVAR 20
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// uc_nation := 2 ;
6199: LD_ADDR_OWVAR 21
6203: PUSH
6204: LD_INT 2
6206: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 4
6212: PPUSH
6213: LD_INT 6
6215: PPUSH
6216: CALL_OW 380
// un := CreateHuman ;
6220: LD_ADDR_VAR 0 1
6224: PUSH
6225: CALL_OW 44
6229: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6230: LD_VAR 0 1
6234: PPUSH
6235: LD_INT 88
6237: PPUSH
6238: LD_INT 1
6240: PPUSH
6241: LD_INT 2
6243: PPUSH
6244: LD_INT 0
6246: PPUSH
6247: CALL 50946 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6251: LD_VAR 0 1
6255: PPUSH
6256: LD_INT 130
6258: PPUSH
6259: LD_INT 35
6261: PPUSH
6262: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 132
6273: PPUSH
6274: LD_INT 39
6276: PPUSH
6277: CALL_OW 218
// end ;
6281: PPOPN 1
6283: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6284: LD_INT 22
6286: PUSH
6287: LD_INT 2
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 33
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 50
6306: PUSH
6307: EMPTY
6308: LIST
6309: PUSH
6310: LD_INT 3
6312: PUSH
6313: LD_INT 61
6315: PUSH
6316: EMPTY
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: PPUSH
6329: CALL_OW 69
6333: IFFALSE 6424
6335: GO 6337
6337: DISABLE
6338: LD_INT 0
6340: PPUSH
6341: PPUSH
// begin enable ;
6342: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6343: LD_ADDR_VAR 0 2
6347: PUSH
6348: LD_INT 22
6350: PUSH
6351: LD_INT 2
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PUSH
6358: LD_INT 33
6360: PUSH
6361: LD_INT 2
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 50
6370: PUSH
6371: EMPTY
6372: LIST
6373: PUSH
6374: LD_INT 3
6376: PUSH
6377: LD_INT 61
6379: PUSH
6380: EMPTY
6381: LIST
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: PPUSH
6393: CALL_OW 69
6397: ST_TO_ADDR
// for i in tmp do
6398: LD_ADDR_VAR 0 1
6402: PUSH
6403: LD_VAR 0 2
6407: PUSH
6408: FOR_IN
6409: IFFALSE 6422
// Connect ( i ) ;
6411: LD_VAR 0 1
6415: PPUSH
6416: CALL 19423 0 1
6420: GO 6408
6422: POP
6423: POP
// end ; end_of_file
6424: PPOPN 2
6426: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6427: LD_INT 0
6429: PPUSH
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
6434: PPUSH
// popov_side := 3 ;
6435: LD_ADDR_EXP 17
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// uc_side := popov_side ;
6443: LD_ADDR_OWVAR 20
6447: PUSH
6448: LD_EXP 17
6452: ST_TO_ADDR
// uc_nation := 3 ;
6453: LD_ADDR_OWVAR 21
6457: PUSH
6458: LD_INT 3
6460: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6461: LD_ADDR_VAR 0 6
6465: PUSH
6466: LD_INT 5
6468: PUSH
6469: LD_INT 103
6471: PUSH
6472: LD_INT 147
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 5
6486: PUSH
6487: LD_INT 70
6489: PUSH
6490: LD_INT 117
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: PUSH
6502: LD_INT 6
6504: PUSH
6505: LD_INT 76
6507: PUSH
6508: LD_INT 145
6510: PUSH
6511: LD_INT 1
6513: PUSH
6514: LD_INT 10
6516: PUSH
6517: LD_INT 11
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: LIST
6526: LIST
6527: PUSH
6528: LD_INT 26
6530: PUSH
6531: LD_INT 87
6533: PUSH
6534: LD_INT 144
6536: PUSH
6537: LD_INT 0
6539: PUSH
6540: EMPTY
6541: LIST
6542: LIST
6543: LIST
6544: LIST
6545: PUSH
6546: LD_INT 29
6548: PUSH
6549: LD_INT 86
6551: PUSH
6552: LD_INT 118
6554: PUSH
6555: LD_INT 0
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: PUSH
6564: LD_INT 29
6566: PUSH
6567: LD_INT 98
6569: PUSH
6570: LD_INT 121
6572: PUSH
6573: LD_INT 0
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: LIST
6580: LIST
6581: PUSH
6582: LD_INT 26
6584: PUSH
6585: LD_INT 87
6587: PUSH
6588: LD_INT 147
6590: PUSH
6591: LD_INT 1
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 30
6602: PUSH
6603: LD_INT 123
6605: PUSH
6606: LD_INT 151
6608: PUSH
6609: LD_INT 1
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PUSH
6618: LD_INT 3
6620: PUSH
6621: LD_INT 94
6623: PUSH
6624: LD_INT 161
6626: PUSH
6627: LD_INT 0
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 6
6638: PUSH
6639: LD_INT 81
6641: PUSH
6642: LD_INT 155
6644: PUSH
6645: LD_INT 1
6647: PUSH
6648: LD_INT 12
6650: PUSH
6651: LD_INT 14
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 26
6664: PUSH
6665: LD_INT 96
6667: PUSH
6668: LD_INT 152
6670: PUSH
6671: LD_INT 0
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 96
6685: PUSH
6686: LD_INT 149
6688: PUSH
6689: LD_INT 3
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: PUSH
6698: LD_INT 32
6700: PUSH
6701: LD_INT 109
6703: PUSH
6704: LD_INT 142
6706: PUSH
6707: LD_INT 3
6709: PUSH
6710: LD_INT 46
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: PUSH
6720: LD_INT 32
6722: PUSH
6723: LD_INT 112
6725: PUSH
6726: LD_INT 148
6728: PUSH
6729: LD_INT 3
6731: PUSH
6732: LD_INT 46
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 33
6744: PUSH
6745: LD_INT 120
6747: PUSH
6748: LD_INT 159
6750: PUSH
6751: LD_INT 4
6753: PUSH
6754: LD_INT 45
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: PUSH
6764: LD_INT 33
6766: PUSH
6767: LD_INT 122
6769: PUSH
6770: LD_INT 163
6772: PUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 45
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: PUSH
6786: LD_INT 33
6788: PUSH
6789: LD_INT 123
6791: PUSH
6792: LD_INT 167
6794: PUSH
6795: LD_INT 4
6797: PUSH
6798: LD_INT 45
6800: PUSH
6801: EMPTY
6802: LIST
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 33
6810: PUSH
6811: LD_INT 59
6813: PUSH
6814: LD_INT 111
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 45
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: LIST
6829: PUSH
6830: LD_INT 33
6832: PUSH
6833: LD_INT 65
6835: PUSH
6836: LD_INT 111
6838: PUSH
6839: LD_INT 3
6841: PUSH
6842: LD_INT 46
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: LIST
6850: LIST
6851: PUSH
6852: LD_INT 33
6854: PUSH
6855: LD_INT 76
6857: PUSH
6858: LD_INT 117
6860: PUSH
6861: LD_INT 3
6863: PUSH
6864: LD_INT 45
6866: PUSH
6867: EMPTY
6868: LIST
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 33
6876: PUSH
6877: LD_INT 80
6879: PUSH
6880: LD_INT 119
6882: PUSH
6883: LD_INT 3
6885: PUSH
6886: LD_INT 46
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: LIST
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 33
6898: PUSH
6899: LD_INT 87
6901: PUSH
6902: LD_INT 125
6904: PUSH
6905: LD_INT 3
6907: PUSH
6908: LD_INT 45
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_INT 5
6920: PUSH
6921: LD_INT 92
6923: PUSH
6924: LD_INT 129
6926: PUSH
6927: LD_INT 3
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: LD_INT 28
6938: PUSH
6939: LD_INT 85
6941: PUSH
6942: LD_INT 165
6944: PUSH
6945: LD_INT 0
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: PUSH
6954: LD_INT 28
6956: PUSH
6957: LD_INT 83
6959: PUSH
6960: LD_INT 161
6962: PUSH
6963: LD_INT 4
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: PUSH
6972: LD_INT 28
6974: PUSH
6975: LD_INT 91
6977: PUSH
6978: LD_INT 166
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: LIST
6988: LIST
6989: PUSH
6990: LD_INT 28
6992: PUSH
6993: LD_INT 102
6995: PUSH
6996: LD_INT 166
6998: PUSH
6999: LD_INT 2
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: LIST
7006: LIST
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: LIST
7016: LIST
7017: LIST
7018: LIST
7019: LIST
7020: LIST
7021: LIST
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: ST_TO_ADDR
// for i in list do
7037: LD_ADDR_VAR 0 2
7041: PUSH
7042: LD_VAR 0 6
7046: PUSH
7047: FOR_IN
7048: IFFALSE 7258
// begin uc_side := 3 ;
7050: LD_ADDR_OWVAR 20
7054: PUSH
7055: LD_INT 3
7057: ST_TO_ADDR
// uc_nation := 3 ;
7058: LD_ADDR_OWVAR 21
7062: PUSH
7063: LD_INT 3
7065: ST_TO_ADDR
// InitBc ;
7066: CALL_OW 21
// bc_type := i [ 1 ] ;
7070: LD_ADDR_OWVAR 42
7074: PUSH
7075: LD_VAR 0 2
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
7084: LD_VAR 0 2
7088: PUSH
7089: LD_INT 1
7091: ARRAY
7092: PUSH
7093: LD_INT 29
7095: PUSH
7096: LD_INT 30
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: IN
7103: IFFALSE 7130
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 3 ) ;
7105: LD_VAR 0 2
7109: PUSH
7110: LD_INT 2
7112: ARRAY
7113: PPUSH
7114: LD_VAR 0 2
7118: PUSH
7119: LD_INT 3
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: CALL_OW 441
// if i [ 1 ] = b_lab then
7130: LD_VAR 0 2
7134: PUSH
7135: LD_INT 1
7137: ARRAY
7138: PUSH
7139: LD_INT 6
7141: EQUAL
7142: IFFALSE 7180
// begin bc_type := b_lab_full ;
7144: LD_ADDR_OWVAR 42
7148: PUSH
7149: LD_INT 8
7151: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7152: LD_ADDR_OWVAR 44
7156: PUSH
7157: LD_VAR 0 2
7161: PUSH
7162: LD_INT 5
7164: ARRAY
7165: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7166: LD_ADDR_OWVAR 45
7170: PUSH
7171: LD_VAR 0 2
7175: PUSH
7176: LD_INT 6
7178: ARRAY
7179: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7180: LD_ADDR_VAR 0 5
7184: PUSH
7185: LD_VAR 0 2
7189: PUSH
7190: LD_INT 2
7192: ARRAY
7193: PPUSH
7194: LD_VAR 0 2
7198: PUSH
7199: LD_INT 3
7201: ARRAY
7202: PPUSH
7203: LD_VAR 0 2
7207: PUSH
7208: LD_INT 4
7210: ARRAY
7211: PPUSH
7212: CALL_OW 47
7216: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7217: LD_VAR 0 2
7221: PUSH
7222: LD_INT 1
7224: ARRAY
7225: PUSH
7226: LD_INT 33
7228: PUSH
7229: LD_INT 32
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: IN
7236: IFFALSE 7256
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7238: LD_VAR 0 5
7242: PPUSH
7243: LD_VAR 0 2
7247: PUSH
7248: LD_INT 5
7250: ARRAY
7251: PPUSH
7252: CALL_OW 431
// end ;
7256: GO 7047
7258: POP
7259: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7260: LD_ADDR_VAR 0 4
7264: PUSH
7265: LD_INT 9
7267: PPUSH
7268: LD_INT 3
7270: PPUSH
7271: LD_STRING 
7273: PPUSH
7274: LD_INT 8
7276: PUSH
7277: LD_INT 7
7279: PUSH
7280: LD_INT 6
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: LIST
7287: PUSH
7288: LD_OWVAR 67
7292: ARRAY
7293: PPUSH
7294: LD_INT 11500
7296: PUSH
7297: LD_INT 1100
7299: PUSH
7300: LD_INT 60
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: LIST
7307: PPUSH
7308: LD_INT 6
7310: PUSH
7311: LD_INT 6
7313: PUSH
7314: LD_INT 6
7316: PUSH
7317: LD_INT 6
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PPUSH
7326: CALL 19776 0 6
7330: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7331: LD_ADDR_EXP 23
7335: PUSH
7336: LD_EXP 23
7340: PPUSH
7341: LD_INT 3
7343: PPUSH
7344: LD_VAR 0 4
7348: PUSH
7349: LD_INT 22
7351: PUSH
7352: LD_INT 3
7354: PUSH
7355: EMPTY
7356: LIST
7357: LIST
7358: PUSH
7359: LD_INT 21
7361: PUSH
7362: LD_INT 3
7364: PUSH
7365: EMPTY
7366: LIST
7367: LIST
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: PPUSH
7373: CALL_OW 69
7377: UNION
7378: PPUSH
7379: CALL_OW 1
7383: ST_TO_ADDR
// extraPopovForces := [ ] ;
7384: LD_ADDR_EXP 18
7388: PUSH
7389: EMPTY
7390: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7391: LD_ADDR_VAR 0 2
7395: PUSH
7396: DOUBLE
7397: LD_INT 1
7399: DEC
7400: ST_TO_ADDR
7401: LD_INT 8
7403: PUSH
7404: LD_INT 9
7406: PUSH
7407: LD_INT 10
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: PUSH
7415: LD_OWVAR 67
7419: ARRAY
7420: PUSH
7421: FOR_TO
7422: IFFALSE 7551
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7424: LD_INT 0
7426: PPUSH
7427: LD_INT 1
7429: PPUSH
7430: LD_INT 4
7432: PUSH
7433: LD_INT 5
7435: PUSH
7436: LD_INT 6
7438: PUSH
7439: EMPTY
7440: LIST
7441: LIST
7442: LIST
7443: PUSH
7444: LD_OWVAR 67
7448: ARRAY
7449: PPUSH
7450: CALL_OW 380
// un := CreateHuman ;
7454: LD_ADDR_VAR 0 3
7458: PUSH
7459: CALL_OW 44
7463: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7464: LD_INT 0
7466: PPUSH
7467: LD_INT 1
7469: PPUSH
7470: CALL_OW 12
7474: IFFALSE 7499
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7476: LD_VAR 0 3
7480: PPUSH
7481: LD_INT 131
7483: PPUSH
7484: LD_INT 110
7486: PPUSH
7487: LD_INT 8
7489: PPUSH
7490: LD_INT 0
7492: PPUSH
7493: CALL_OW 50
7497: GO 7520
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7499: LD_VAR 0 3
7503: PPUSH
7504: LD_INT 100
7506: PPUSH
7507: LD_INT 99
7509: PPUSH
7510: LD_INT 8
7512: PPUSH
7513: LD_INT 0
7515: PPUSH
7516: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7520: LD_ADDR_EXP 18
7524: PUSH
7525: LD_EXP 18
7529: PPUSH
7530: LD_EXP 18
7534: PUSH
7535: LD_INT 1
7537: PLUS
7538: PPUSH
7539: LD_VAR 0 3
7543: PPUSH
7544: CALL_OW 1
7548: ST_TO_ADDR
// end ;
7549: GO 7421
7551: POP
7552: POP
// PrepareSoldier ( false , 6 ) ;
7553: LD_INT 0
7555: PPUSH
7556: LD_INT 6
7558: PPUSH
7559: CALL_OW 381
// un := CreateHuman ;
7563: LD_ADDR_VAR 0 3
7567: PUSH
7568: CALL_OW 44
7572: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7573: LD_VAR 0 3
7577: PPUSH
7578: LD_INT 1
7580: PPUSH
7581: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7585: LD_VAR 0 3
7589: PPUSH
7590: LD_INT 150
7592: PPUSH
7593: LD_INT 158
7595: PPUSH
7596: CALL_OW 428
7600: PPUSH
7601: CALL_OW 52
// popovAttackGroup := [ ] ;
7605: LD_ADDR_EXP 19
7609: PUSH
7610: EMPTY
7611: ST_TO_ADDR
// end ;
7612: LD_VAR 0 1
7616: RET
// export function InitMC_Popov ( ) ; begin
7617: LD_INT 0
7619: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7620: LD_INT 3
7622: PPUSH
7623: LD_INT 3
7625: PPUSH
7626: CALL 79441 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7630: LD_INT 3
7632: PPUSH
7633: LD_INT 10
7635: PPUSH
7636: CALL 79385 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7640: LD_INT 3
7642: PPUSH
7643: LD_INT 86
7645: PUSH
7646: LD_INT 118
7648: PUSH
7649: LD_INT 0
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: LIST
7656: PUSH
7657: LD_INT 123
7659: PUSH
7660: LD_INT 151
7662: PUSH
7663: LD_INT 1
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 98
7673: PUSH
7674: LD_INT 121
7676: PUSH
7677: LD_INT 0
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: PPUSH
7690: CALL 78444 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7694: LD_INT 3
7696: PPUSH
7697: LD_INT 46
7699: PUSH
7700: LD_INT 45
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PPUSH
7707: CALL 79273 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7711: LD_INT 3
7713: PPUSH
7714: LD_INT 12
7716: PPUSH
7717: CALL 78955 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7721: LD_INT 3
7723: PPUSH
7724: LD_INT 11
7726: PPUSH
7727: CALL 78686 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7731: LD_INT 3
7733: PPUSH
7734: LD_INT 4
7736: PPUSH
7737: CALL 78305 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7741: LD_INT 3
7743: PPUSH
7744: LD_INT 23
7746: PUSH
7747: LD_INT 1
7749: PUSH
7750: LD_INT 3
7752: PUSH
7753: LD_INT 44
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 23
7764: PUSH
7765: LD_INT 1
7767: PUSH
7768: LD_INT 3
7770: PUSH
7771: LD_INT 45
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 21
7782: PUSH
7783: LD_INT 1
7785: PUSH
7786: LD_INT 3
7788: PUSH
7789: LD_INT 44
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: LIST
7797: PUSH
7798: LD_INT 21
7800: PUSH
7801: LD_INT 1
7803: PUSH
7804: LD_INT 3
7806: PUSH
7807: LD_INT 45
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: LIST
7820: LIST
7821: PPUSH
7822: CALL 78120 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7826: LD_INT 3
7828: PPUSH
7829: LD_INT 94
7831: PPUSH
7832: LD_INT 161
7834: PPUSH
7835: LD_INT 0
7837: PPUSH
7838: LD_INT 19
7840: PUSH
7841: LD_INT 17
7843: PUSH
7844: LD_INT 18
7846: PUSH
7847: LD_INT 24
7849: PUSH
7850: LD_INT 21
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: LIST
7857: LIST
7858: LIST
7859: PPUSH
7860: CALL 79067 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7864: LD_INT 3
7866: PPUSH
7867: LD_INT 21
7869: PUSH
7870: LD_INT 1
7872: PUSH
7873: LD_INT 3
7875: PUSH
7876: LD_INT 51
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: PUSH
7885: EMPTY
7886: LIST
7887: PPUSH
7888: CALL 78168 0 2
// end ;
7892: LD_VAR 0 1
7896: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7897: LD_EXP 18
7901: PUSH
7902: LD_EXP 5
7906: NOT
7907: AND
7908: IFFALSE 7968
7910: GO 7912
7912: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7913: LD_EXP 18
7917: PPUSH
7918: LD_INT 106
7920: PPUSH
7921: LD_INT 137
7923: PPUSH
7924: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7928: LD_ADDR_EXP 23
7932: PUSH
7933: LD_EXP 23
7937: PPUSH
7938: LD_INT 3
7940: PPUSH
7941: LD_EXP 23
7945: PUSH
7946: LD_INT 3
7948: ARRAY
7949: PUSH
7950: LD_EXP 18
7954: UNION
7955: PPUSH
7956: CALL_OW 1
7960: ST_TO_ADDR
// extraPopovForces := [ ] ;
7961: LD_ADDR_EXP 18
7965: PUSH
7966: EMPTY
7967: ST_TO_ADDR
// end ;
7968: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7969: LD_INT 9
7971: PPUSH
7972: CALL_OW 302
7976: PUSH
7977: LD_EXP 5
7981: NOT
7982: AND
7983: IFFALSE 8549
7985: GO 7987
7987: DISABLE
7988: LD_INT 0
7990: PPUSH
7991: PPUSH
7992: PPUSH
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// base := 3 ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 3
8003: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
8004: LD_ADDR_VAR 0 3
8008: PUSH
8009: LD_INT 21
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: LD_INT 3
8017: PUSH
8018: LD_INT 44
8020: PUSH
8021: EMPTY
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: PUSH
8027: LD_INT 23
8029: PUSH
8030: LD_INT 1
8032: PUSH
8033: LD_INT 3
8035: PUSH
8036: LD_INT 46
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 23
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: LD_INT 3
8053: PUSH
8054: LD_INT 46
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: LIST
8061: LIST
8062: PUSH
8063: LD_INT 23
8065: PUSH
8066: LD_INT 1
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: LD_INT 46
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: LIST
8085: LIST
8086: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
8087: LD_ADDR_VAR 0 5
8091: PUSH
8092: LD_VAR 0 5
8096: PUSH
8097: LD_OWVAR 1
8101: PUSH
8102: LD_INT 21000
8104: DIV
8105: PLUS
8106: ST_TO_ADDR
// if amount > 8 then
8107: LD_VAR 0 5
8111: PUSH
8112: LD_INT 8
8114: GREATER
8115: IFFALSE 8125
// amount := 8 ;
8117: LD_ADDR_VAR 0 5
8121: PUSH
8122: LD_INT 8
8124: ST_TO_ADDR
// for i = 1 to amount do
8125: LD_ADDR_VAR 0 1
8129: PUSH
8130: DOUBLE
8131: LD_INT 1
8133: DEC
8134: ST_TO_ADDR
8135: LD_VAR 0 5
8139: PUSH
8140: FOR_TO
8141: IFFALSE 8206
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_wheeled , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8143: LD_ADDR_VAR 0 3
8147: PUSH
8148: LD_VAR 0 3
8152: PPUSH
8153: LD_VAR 0 3
8157: PUSH
8158: LD_INT 1
8160: PLUS
8161: PPUSH
8162: LD_INT 23
8164: PUSH
8165: LD_INT 1
8167: PUSH
8168: LD_INT 3
8170: PUSH
8171: LD_INT 46
8173: PUSH
8174: LD_INT 45
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: LIST
8197: LIST
8198: PPUSH
8199: CALL_OW 2
8203: ST_TO_ADDR
8204: GO 8140
8206: POP
8207: POP
// MC_InsertProduceList ( base , tmp ) ;
8208: LD_VAR 0 2
8212: PPUSH
8213: LD_VAR 0 3
8217: PPUSH
8218: CALL 78168 0 2
// repeat wait ( 0 0$1 ) ;
8222: LD_INT 35
8224: PPUSH
8225: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8229: LD_VAR 0 2
8233: PPUSH
8234: LD_INT 1
8236: PPUSH
8237: CALL 79586 0 2
8241: PUSH
8242: LD_VAR 0 5
8246: GREATEREQUAL
8247: IFFALSE 8222
// wait ( 0 0$30 ) ;
8249: LD_INT 1050
8251: PPUSH
8252: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8256: LD_ADDR_VAR 0 4
8260: PUSH
8261: LD_EXP 42
8265: PUSH
8266: LD_VAR 0 2
8270: ARRAY
8271: PUSH
8272: LD_EXP 42
8276: PUSH
8277: LD_VAR 0 2
8281: ARRAY
8282: PPUSH
8283: LD_INT 2
8285: PUSH
8286: LD_INT 34
8288: PUSH
8289: LD_INT 51
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PUSH
8296: LD_INT 34
8298: PUSH
8299: LD_INT 52
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: LIST
8310: PPUSH
8311: CALL_OW 72
8315: DIFF
8316: ST_TO_ADDR
// if not attackers then
8317: LD_VAR 0 4
8321: NOT
8322: IFFALSE 8326
// exit ;
8324: GO 8549
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8326: LD_ADDR_EXP 42
8330: PUSH
8331: LD_EXP 42
8335: PPUSH
8336: LD_VAR 0 2
8340: PPUSH
8341: LD_EXP 42
8345: PUSH
8346: LD_VAR 0 2
8350: ARRAY
8351: PUSH
8352: LD_VAR 0 4
8356: DIFF
8357: PPUSH
8358: CALL_OW 1
8362: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8363: LD_VAR 0 4
8367: PPUSH
8368: LD_INT 107
8370: PPUSH
8371: LD_INT 74
8373: PPUSH
8374: CALL_OW 114
// wait ( 0 0$5 ) ;
8378: LD_INT 175
8380: PPUSH
8381: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8385: LD_INT 35
8387: PPUSH
8388: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8392: LD_VAR 0 4
8396: PPUSH
8397: LD_INT 60
8399: PUSH
8400: EMPTY
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: NOT
8408: IFFALSE 8385
// if rand ( 0 , 1 ) then
8410: LD_INT 0
8412: PPUSH
8413: LD_INT 1
8415: PPUSH
8416: CALL_OW 12
8420: IFFALSE 8439
// ComAgressiveMove ( attackers , 155 , 108 ) else
8422: LD_VAR 0 4
8426: PPUSH
8427: LD_INT 155
8429: PPUSH
8430: LD_INT 108
8432: PPUSH
8433: CALL_OW 114
8437: GO 8454
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8439: LD_VAR 0 4
8443: PPUSH
8444: LD_INT 149
8446: PPUSH
8447: LD_INT 55
8449: PPUSH
8450: CALL_OW 114
// wait ( 0 0$10 ) ;
8454: LD_INT 350
8456: PPUSH
8457: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// for i in attackers do
8468: LD_ADDR_VAR 0 1
8472: PUSH
8473: LD_VAR 0 4
8477: PUSH
8478: FOR_IN
8479: IFFALSE 8529
// if not HasTask ( i ) then
8481: LD_VAR 0 1
8485: PPUSH
8486: CALL_OW 314
8490: NOT
8491: IFFALSE 8527
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8493: LD_VAR 0 1
8497: PPUSH
8498: LD_INT 81
8500: PUSH
8501: LD_INT 3
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: PPUSH
8508: CALL_OW 69
8512: PPUSH
8513: LD_VAR 0 1
8517: PPUSH
8518: CALL_OW 74
8522: PPUSH
8523: CALL_OW 115
8527: GO 8478
8529: POP
8530: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8531: LD_VAR 0 4
8535: PPUSH
8536: LD_INT 50
8538: PUSH
8539: EMPTY
8540: LIST
8541: PPUSH
8542: CALL_OW 72
8546: NOT
8547: IFFALSE 8461
// end ;
8549: PPOPN 5
8551: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8552: LD_EXP 5
8556: NOT
8557: IFFALSE 9144
8559: GO 8561
8561: DISABLE
8562: LD_INT 0
8564: PPUSH
8565: PPUSH
8566: PPUSH
8567: PPUSH
// begin enable ;
8568: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8569: LD_OWVAR 67
8573: PUSH
8574: LD_INT 1
8576: EQUAL
8577: PUSH
8578: LD_OWVAR 1
8582: PUSH
8583: LD_INT 63000
8585: LESS
8586: AND
8587: IFFALSE 8591
// exit ;
8589: GO 9144
// tmp := [ ] ;
8591: LD_ADDR_VAR 0 3
8595: PUSH
8596: EMPTY
8597: ST_TO_ADDR
// if tick < 45 45$00 then
8598: LD_OWVAR 1
8602: PUSH
8603: LD_INT 94500
8605: LESS
8606: IFFALSE 8783
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8608: LD_ADDR_VAR 0 1
8612: PUSH
8613: DOUBLE
8614: LD_INT 1
8616: DEC
8617: ST_TO_ADDR
8618: LD_INT 2
8620: PUSH
8621: LD_INT 3
8623: PUSH
8624: LD_INT 4
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: LD_OWVAR 67
8636: ARRAY
8637: PUSH
8638: FOR_TO
8639: IFFALSE 8781
// begin uc_side := 3 ;
8641: LD_ADDR_OWVAR 20
8645: PUSH
8646: LD_INT 3
8648: ST_TO_ADDR
// uc_nation := 3 ;
8649: LD_ADDR_OWVAR 21
8653: PUSH
8654: LD_INT 3
8656: ST_TO_ADDR
// InitHC_All ( ) ;
8657: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8661: LD_INT 0
8663: PPUSH
8664: LD_INT 1
8666: PPUSH
8667: LD_INT 5
8669: PUSH
8670: LD_INT 6
8672: PUSH
8673: LD_INT 7
8675: PUSH
8676: EMPTY
8677: LIST
8678: LIST
8679: LIST
8680: PUSH
8681: LD_OWVAR 67
8685: ARRAY
8686: PPUSH
8687: CALL_OW 380
// un := CreateHuman ;
8691: LD_ADDR_VAR 0 2
8695: PUSH
8696: CALL_OW 44
8700: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8701: LD_VAR 0 2
8705: PPUSH
8706: LD_INT 18
8708: PPUSH
8709: LD_INT 0
8711: PPUSH
8712: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8716: LD_VAR 0 2
8720: PPUSH
8721: LD_INT 9
8723: PPUSH
8724: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8728: LD_VAR 0 2
8732: PPUSH
8733: LD_INT 147
8735: PPUSH
8736: LD_INT 161
8738: PPUSH
8739: CALL_OW 111
// wait ( 0 0$2 ) ;
8743: LD_INT 70
8745: PPUSH
8746: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8750: LD_ADDR_VAR 0 3
8754: PUSH
8755: LD_VAR 0 3
8759: PPUSH
8760: LD_VAR 0 3
8764: PUSH
8765: LD_INT 1
8767: PLUS
8768: PPUSH
8769: LD_VAR 0 2
8773: PPUSH
8774: CALL_OW 1
8778: ST_TO_ADDR
// end ;
8779: GO 8638
8781: POP
8782: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8783: LD_ADDR_VAR 0 4
8787: PUSH
8788: LD_INT 3
8790: PUSH
8791: LD_INT 4
8793: PUSH
8794: LD_INT 5
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: LIST
8801: PUSH
8802: LD_OWVAR 67
8806: ARRAY
8807: PUSH
8808: LD_OWVAR 1
8812: PUSH
8813: LD_INT 21000
8815: DIV
8816: PLUS
8817: ST_TO_ADDR
// if amount > 15 then
8818: LD_VAR 0 4
8822: PUSH
8823: LD_INT 15
8825: GREATER
8826: IFFALSE 8836
// amount := 15 ;
8828: LD_ADDR_VAR 0 4
8832: PUSH
8833: LD_INT 15
8835: ST_TO_ADDR
// for i := 1 to amount do
8836: LD_ADDR_VAR 0 1
8840: PUSH
8841: DOUBLE
8842: LD_INT 1
8844: DEC
8845: ST_TO_ADDR
8846: LD_VAR 0 4
8850: PUSH
8851: FOR_TO
8852: IFFALSE 8998
// begin uc_side := 3 ;
8854: LD_ADDR_OWVAR 20
8858: PUSH
8859: LD_INT 3
8861: ST_TO_ADDR
// uc_nation := 3 ;
8862: LD_ADDR_OWVAR 21
8866: PUSH
8867: LD_INT 3
8869: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8870: LD_INT 24
8872: PPUSH
8873: LD_INT 1
8875: PPUSH
8876: LD_INT 3
8878: PPUSH
8879: LD_INT 46
8881: PUSH
8882: LD_INT 45
8884: PUSH
8885: LD_INT 44
8887: PUSH
8888: LD_INT 43
8890: PUSH
8891: LD_INT 42
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_INT 1
8903: PPUSH
8904: LD_INT 5
8906: PPUSH
8907: CALL_OW 12
8911: ARRAY
8912: PPUSH
8913: LD_INT 90
8915: PPUSH
8916: CALL 15955 0 5
// un := CreateVehicle ;
8920: LD_ADDR_VAR 0 2
8924: PUSH
8925: CALL_OW 45
8929: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8930: LD_VAR 0 2
8934: PPUSH
8935: LD_INT 18
8937: PPUSH
8938: LD_INT 0
8940: PPUSH
8941: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8945: LD_VAR 0 2
8949: PPUSH
8950: LD_INT 147
8952: PPUSH
8953: LD_INT 161
8955: PPUSH
8956: CALL_OW 111
// wait ( 0 0$3 ) ;
8960: LD_INT 105
8962: PPUSH
8963: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PPUSH
8977: LD_VAR 0 3
8981: PUSH
8982: LD_INT 1
8984: PLUS
8985: PPUSH
8986: LD_VAR 0 2
8990: PPUSH
8991: CALL_OW 1
8995: ST_TO_ADDR
// end ;
8996: GO 8851
8998: POP
8999: POP
// if not tmp then
9000: LD_VAR 0 3
9004: NOT
9005: IFFALSE 9009
// exit ;
9007: GO 9144
// wait ( 0 0$5 ) ;
9009: LD_INT 175
9011: PPUSH
9012: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
9016: LD_INT 70
9018: PPUSH
9019: CALL_OW 67
// for i in tmp do
9023: LD_ADDR_VAR 0 1
9027: PUSH
9028: LD_VAR 0 3
9032: PUSH
9033: FOR_IN
9034: IFFALSE 9135
// begin if not IsOk ( i ) or IsDead ( i ) then
9036: LD_VAR 0 1
9040: PPUSH
9041: CALL_OW 302
9045: NOT
9046: PUSH
9047: LD_VAR 0 1
9051: PPUSH
9052: CALL_OW 301
9056: OR
9057: IFFALSE 9075
// tmp := tmp diff i ;
9059: LD_ADDR_VAR 0 3
9063: PUSH
9064: LD_VAR 0 3
9068: PUSH
9069: LD_VAR 0 1
9073: DIFF
9074: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
9075: LD_VAR 0 1
9079: PPUSH
9080: CALL_OW 257
9084: PUSH
9085: LD_INT 9
9087: EQUAL
9088: IFFALSE 9099
// ComSpaceTimeShoot ( i ) ;
9090: LD_VAR 0 1
9094: PPUSH
9095: CALL 12062 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9099: LD_VAR 0 1
9103: PPUSH
9104: LD_INT 81
9106: PUSH
9107: LD_INT 3
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: PPUSH
9114: CALL_OW 69
9118: PPUSH
9119: LD_VAR 0 1
9123: PPUSH
9124: CALL_OW 74
9128: PPUSH
9129: CALL_OW 115
// end ;
9133: GO 9033
9135: POP
9136: POP
// until not tmp ;
9137: LD_VAR 0 3
9141: NOT
9142: IFFALSE 9016
// end ; end_of_file
9144: PPOPN 4
9146: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9147: LD_INT 0
9149: PPUSH
9150: PPUSH
9151: PPUSH
9152: PPUSH
// uc_side := 1 ;
9153: LD_ADDR_OWVAR 20
9157: PUSH
9158: LD_INT 1
9160: ST_TO_ADDR
// uc_nation := 1 ;
9161: LD_ADDR_OWVAR 21
9165: PUSH
9166: LD_INT 1
9168: ST_TO_ADDR
// hc_importance := 100 ;
9169: LD_ADDR_OWVAR 32
9173: PUSH
9174: LD_INT 100
9176: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9177: LD_ADDR_OWVAR 26
9181: PUSH
9182: LD_STRING Jeremy Sikorski
9184: ST_TO_ADDR
// hc_gallery := us ;
9185: LD_ADDR_OWVAR 33
9189: PUSH
9190: LD_STRING us
9192: ST_TO_ADDR
// hc_face_number := 19 ;
9193: LD_ADDR_OWVAR 34
9197: PUSH
9198: LD_INT 19
9200: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9201: LD_INT 1
9203: PPUSH
9204: LD_INT 1
9206: PPUSH
9207: LD_INT 4
9209: PUSH
9210: LD_INT 4
9212: PUSH
9213: LD_INT 3
9215: PUSH
9216: EMPTY
9217: LIST
9218: LIST
9219: LIST
9220: PUSH
9221: LD_OWVAR 67
9225: ARRAY
9226: PPUSH
9227: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9231: LD_ADDR_OWVAR 29
9235: PUSH
9236: LD_INT 10
9238: PUSH
9239: LD_INT 12
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: ST_TO_ADDR
// Sikorski := CreateHuman ;
9246: LD_ADDR_EXP 20
9250: PUSH
9251: CALL_OW 44
9255: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9256: LD_EXP 20
9260: PPUSH
9261: LD_INT 133
9263: PPUSH
9264: LD_INT 19
9266: PPUSH
9267: LD_INT 2
9269: PPUSH
9270: LD_INT 0
9272: PPUSH
9273: CALL_OW 50
// InitHc_All ( ) ;
9277: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9281: LD_ADDR_VAR 0 2
9285: PUSH
9286: DOUBLE
9287: LD_INT 1
9289: DEC
9290: ST_TO_ADDR
9291: LD_INT 4
9293: PUSH
9294: LD_INT 3
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: LIST
9304: PUSH
9305: LD_OWVAR 67
9309: ARRAY
9310: PUSH
9311: FOR_TO
9312: IFFALSE 9428
// for j := 1 to 4 do
9314: LD_ADDR_VAR 0 3
9318: PUSH
9319: DOUBLE
9320: LD_INT 1
9322: DEC
9323: ST_TO_ADDR
9324: LD_INT 4
9326: PUSH
9327: FOR_TO
9328: IFFALSE 9424
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9330: LD_INT 0
9332: PPUSH
9333: LD_VAR 0 3
9337: PPUSH
9338: LD_INT 5
9340: PUSH
9341: LD_INT 4
9343: PUSH
9344: LD_INT 3
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PUSH
9352: LD_OWVAR 67
9356: ARRAY
9357: PPUSH
9358: CALL_OW 380
// un := CreateHuman ;
9362: LD_ADDR_VAR 0 4
9366: PUSH
9367: CALL_OW 44
9371: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9372: LD_VAR 0 4
9376: PPUSH
9377: LD_INT 0
9379: PPUSH
9380: LD_INT 5
9382: PPUSH
9383: CALL_OW 12
9387: PPUSH
9388: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 133
9399: PPUSH
9400: LD_INT 19
9402: PPUSH
9403: LD_INT 6
9405: PPUSH
9406: LD_INT 0
9408: PPUSH
9409: CALL_OW 50
// ComHold ( un ) ;
9413: LD_VAR 0 4
9417: PPUSH
9418: CALL_OW 140
// end ;
9422: GO 9327
9424: POP
9425: POP
9426: GO 9311
9428: POP
9429: POP
// vc_chassis := us_heavy_tracked ;
9430: LD_ADDR_OWVAR 37
9434: PUSH
9435: LD_INT 4
9437: ST_TO_ADDR
// vc_engine := engine_combustion ;
9438: LD_ADDR_OWVAR 39
9442: PUSH
9443: LD_INT 1
9445: ST_TO_ADDR
// vc_control := control_manual ;
9446: LD_ADDR_OWVAR 38
9450: PUSH
9451: LD_INT 1
9453: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9454: LD_ADDR_OWVAR 40
9458: PUSH
9459: LD_INT 14
9461: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9462: LD_ADDR_OWVAR 41
9466: PUSH
9467: LD_INT 60
9469: ST_TO_ADDR
// un := CreateVehicle ;
9470: LD_ADDR_VAR 0 4
9474: PUSH
9475: CALL_OW 45
9479: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9480: LD_VAR 0 4
9484: PPUSH
9485: LD_INT 2
9487: PPUSH
9488: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9492: LD_VAR 0 4
9496: PPUSH
9497: LD_INT 128
9499: PPUSH
9500: LD_INT 12
9502: PPUSH
9503: LD_INT 0
9505: PPUSH
9506: CALL_OW 48
// for i := 1 to 3 do
9510: LD_ADDR_VAR 0 2
9514: PUSH
9515: DOUBLE
9516: LD_INT 1
9518: DEC
9519: ST_TO_ADDR
9520: LD_INT 3
9522: PUSH
9523: FOR_TO
9524: IFFALSE 9547
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9526: LD_INT 5
9528: PPUSH
9529: LD_INT 133
9531: PPUSH
9532: LD_INT 19
9534: PPUSH
9535: LD_INT 3
9537: PPUSH
9538: LD_INT 0
9540: PPUSH
9541: CALL_OW 56
9545: GO 9523
9547: POP
9548: POP
// end ; end_of_file
9549: LD_VAR 0 1
9553: RET
// export function Action ; begin
9554: LD_INT 0
9556: PPUSH
// InGameOn ;
9557: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9561: LD_INT 133
9563: PPUSH
9564: LD_INT 19
9566: PPUSH
9567: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9571: LD_EXP 20
9575: PPUSH
9576: LD_STRING WT-DS-1
9578: PPUSH
9579: CALL_OW 88
// InGameOff ;
9583: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9587: LD_STRING DestroyEnemy
9589: PPUSH
9590: CALL_OW 337
// wait ( 0 0$20 ) ;
9594: LD_INT 700
9596: PPUSH
9597: CALL_OW 67
// DialogueOn ;
9601: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9605: LD_INT 100
9607: PPUSH
9608: LD_INT 37
9610: PPUSH
9611: LD_INT 1
9613: PPUSH
9614: LD_INT 30
9616: NEG
9617: PPUSH
9618: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9622: LD_INT 100
9624: PPUSH
9625: LD_INT 37
9627: PPUSH
9628: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9632: LD_EXP 10
9636: PPUSH
9637: LD_STRING WT-PL-1
9639: PPUSH
9640: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9644: LD_EXP 20
9648: PPUSH
9649: LD_STRING WT-DS-2
9651: PPUSH
9652: CALL_OW 88
// DialogueOff ;
9656: CALL_OW 7
// wait ( 0 0$2 ) ;
9660: LD_INT 70
9662: PPUSH
9663: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9667: LD_INT 100
9669: PPUSH
9670: LD_INT 37
9672: PPUSH
9673: LD_INT 1
9675: PPUSH
9676: CALL_OW 331
// end ;
9680: LD_VAR 0 1
9684: RET
// export function DialogPowellsAttack ; begin
9685: LD_INT 0
9687: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9688: LD_EXP 10
9692: PPUSH
9693: LD_STRING WT-PL-8
9695: PPUSH
9696: CALL_OW 94
// end ;
9700: LD_VAR 0 1
9704: RET
// export function DialogContaminateSib ( x , y ) ; begin
9705: LD_INT 0
9707: PPUSH
// DialogueOn ;
9708: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9712: LD_VAR 0 1
9716: PPUSH
9717: LD_VAR 0 2
9721: PPUSH
9722: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9726: LD_EXP 20
9730: PPUSH
9731: LD_STRING WT-DS-3
9733: PPUSH
9734: CALL_OW 88
// DialogueOff ;
9738: CALL_OW 7
// end ;
9742: LD_VAR 0 3
9746: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9747: LD_EXP 8
9751: NOT
9752: PUSH
9753: LD_INT 1
9755: PPUSH
9756: LD_INT 81
9758: PUSH
9759: LD_INT 4
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PPUSH
9766: CALL_OW 70
9770: PUSH
9771: LD_INT 3
9773: GREATER
9774: AND
9775: IFFALSE 9847
9777: GO 9779
9779: DISABLE
// begin powellInTrouble := true ;
9780: LD_ADDR_EXP 8
9784: PUSH
9785: LD_INT 1
9787: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9788: LD_EXP 20
9792: PPUSH
9793: LD_STRING WT-DS-6
9795: PPUSH
9796: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9800: LD_INT 1
9802: PPUSH
9803: LD_INT 22
9805: PUSH
9806: LD_INT 1
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PPUSH
9813: CALL_OW 70
9817: NOT
9818: IFFALSE 9832
// SayRadio ( Powell , WT-PL-6 ) ;
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-6
9827: PPUSH
9828: CALL_OW 94
// wait ( 1 1$30 ) ;
9832: LD_INT 3150
9834: PPUSH
9835: CALL_OW 67
// powellInTrouble := false ;
9839: LD_ADDR_EXP 8
9843: PUSH
9844: LD_INT 0
9846: ST_TO_ADDR
// end ;
9847: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9848: LD_EXP 9
9852: NOT
9853: PUSH
9854: LD_INT 16
9856: PPUSH
9857: LD_INT 81
9859: PUSH
9860: LD_INT 1
9862: PUSH
9863: EMPTY
9864: LIST
9865: LIST
9866: PPUSH
9867: CALL_OW 70
9871: PUSH
9872: LD_INT 6
9874: GREATER
9875: AND
9876: IFFALSE 9949
9878: GO 9880
9880: DISABLE
// begin sikorskiInTrouble := true ;
9881: LD_ADDR_EXP 9
9885: PUSH
9886: LD_INT 1
9888: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9889: LD_EXP 20
9893: PPUSH
9894: LD_STRING WT-DS-7
9896: PPUSH
9897: CALL_OW 88
// if not powellAttackGroup then
9901: LD_EXP 12
9905: NOT
9906: IFFALSE 9922
// SayRadio ( Powell , WT-PL-7n ) else
9908: LD_EXP 10
9912: PPUSH
9913: LD_STRING WT-PL-7n
9915: PPUSH
9916: CALL_OW 94
9920: GO 9934
// SayRadio ( Powell , WT-PL-7y ) ;
9922: LD_EXP 10
9926: PPUSH
9927: LD_STRING WT-PL-7y
9929: PPUSH
9930: CALL_OW 94
// wait ( 1 1$30 ) ;
9934: LD_INT 3150
9936: PPUSH
9937: CALL_OW 67
// sikorskiInTrouble := false ;
9941: LD_ADDR_EXP 9
9945: PUSH
9946: LD_INT 0
9948: ST_TO_ADDR
// end ;
9949: END
// export function DialogPowellsAttackFailed ; begin
9950: LD_INT 0
9952: PPUSH
// if not ruDestroyed then
9953: LD_EXP 5
9957: NOT
9958: IFFALSE 9974
// SayRadio ( Powell , WT-PL-9 ) else
9960: LD_EXP 10
9964: PPUSH
9965: LD_STRING WT-PL-9
9967: PPUSH
9968: CALL_OW 94
9972: GO 9986
// SayRadio ( Powell , WT-PL-10 ) ;
9974: LD_EXP 10
9978: PPUSH
9979: LD_STRING WT-PL-10
9981: PPUSH
9982: CALL_OW 94
// end ;
9986: LD_VAR 0 1
9990: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9991: LD_INT 22
9993: PUSH
9994: LD_INT 2
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: LD_INT 21
10003: PUSH
10004: LD_INT 1
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PPUSH
10015: CALL_OW 69
10019: PUSH
10020: LD_INT 0
10022: EQUAL
10023: IFFALSE 10067
10025: GO 10027
10027: DISABLE
// begin arDestroyed := true ;
10028: LD_ADDR_EXP 4
10032: PUSH
10033: LD_INT 1
10035: ST_TO_ADDR
// MC_Kill ( 2 ) ;
10036: LD_INT 2
10038: PPUSH
10039: CALL 54143 0 1
// Say ( Sikorski , WT-DS-4 ) ;
10043: LD_EXP 20
10047: PPUSH
10048: LD_STRING WT-DS-4
10050: PPUSH
10051: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
10055: LD_EXP 10
10059: PPUSH
10060: LD_STRING WT-PL-4
10062: PPUSH
10063: CALL_OW 94
// end ;
10067: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10068: LD_INT 22
10070: PUSH
10071: LD_INT 3
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 21
10080: PUSH
10081: LD_INT 1
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: PPUSH
10092: CALL_OW 69
10096: PUSH
10097: LD_INT 0
10099: EQUAL
10100: IFFALSE 10144
10102: GO 10104
10104: DISABLE
// begin ruDestroyed := true ;
10105: LD_ADDR_EXP 5
10109: PUSH
10110: LD_INT 1
10112: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10113: LD_INT 3
10115: PPUSH
10116: CALL 54143 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10120: LD_EXP 20
10124: PPUSH
10125: LD_STRING WT-DS-5
10127: PPUSH
10128: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10132: LD_EXP 10
10136: PPUSH
10137: LD_STRING WT-PL-5
10139: PPUSH
10140: CALL_OW 94
// end ;
10144: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10145: LD_EXP 5
10149: PUSH
10150: LD_EXP 4
10154: AND
10155: IFFALSE 10328
10157: GO 10159
10159: DISABLE
// begin wait ( 0 0$3 ) ;
10160: LD_INT 105
10162: PPUSH
10163: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10167: LD_OWVAR 1
10171: PUSH
10172: LD_INT 126000
10174: PUSH
10175: LD_INT 105000
10177: PUSH
10178: LD_INT 94500
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: LD_OWVAR 67
10190: ARRAY
10191: GREATEREQUAL
10192: IFFALSE 10207
// AddMedal ( WoT-med-1 , - 1 ) else
10194: LD_STRING WoT-med-1
10196: PPUSH
10197: LD_INT 1
10199: NEG
10200: PPUSH
10201: CALL_OW 101
10205: GO 10217
// AddMedal ( WoT-med-1 , 1 ) ;
10207: LD_STRING WoT-med-1
10209: PPUSH
10210: LD_INT 1
10212: PPUSH
10213: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10217: LD_EXP 6
10221: PUSH
10222: LD_INT 4
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 2
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: LIST
10235: PUSH
10236: LD_OWVAR 67
10240: ARRAY
10241: GREATEREQUAL
10242: IFFALSE 10257
// AddMedal ( WoT-med-2 , - 1 ) else
10244: LD_STRING WoT-med-2
10246: PPUSH
10247: LD_INT 1
10249: NEG
10250: PPUSH
10251: CALL_OW 101
10255: GO 10267
// AddMedal ( WoT-med-2 , 1 ) ;
10257: LD_STRING WoT-med-2
10259: PPUSH
10260: LD_INT 1
10262: PPUSH
10263: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10267: LD_EXP 7
10271: PUSH
10272: LD_INT 8
10274: PUSH
10275: LD_INT 6
10277: PUSH
10278: LD_INT 5
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: PUSH
10286: LD_OWVAR 67
10290: ARRAY
10291: GREATEREQUAL
10292: IFFALSE 10307
// AddMedal ( WoT-med-3 , - 1 ) else
10294: LD_STRING WoT-med-3
10296: PPUSH
10297: LD_INT 1
10299: NEG
10300: PPUSH
10301: CALL_OW 101
10305: GO 10317
// AddMedal ( WoT-med-3 , 1 ) ;
10307: LD_STRING WoT-med-3
10309: PPUSH
10310: LD_INT 1
10312: PPUSH
10313: CALL_OW 101
// GiveMedals ( MAIN ) ;
10317: LD_STRING MAIN
10319: PPUSH
10320: CALL_OW 102
// YouWin ;
10324: CALL_OW 103
// end ; end_of_file
10328: END
// export function CustomEvent ( event ) ; begin
10329: LD_INT 0
10331: PPUSH
// end ;
10332: LD_VAR 0 2
10336: RET
// on Command ( com ) do var i , j , temp ;
10337: LD_INT 0
10339: PPUSH
10340: PPUSH
10341: PPUSH
// begin if com = 60 then
10342: LD_VAR 0 1
10346: PUSH
10347: LD_INT 60
10349: EQUAL
10350: IFFALSE 10529
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10352: LD_ADDR_VAR 0 2
10356: PUSH
10357: LD_INT 22
10359: PUSH
10360: LD_INT 1
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: PUSH
10367: LD_INT 2
10369: PUSH
10370: LD_INT 21
10372: PUSH
10373: LD_INT 1
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 34
10382: PUSH
10383: LD_INT 12
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: PPUSH
10399: CALL_OW 69
10403: PUSH
10404: FOR_IN
10405: IFFALSE 10527
// begin if GetTaskList ( i ) > 0 then
10407: LD_VAR 0 2
10411: PPUSH
10412: CALL_OW 437
10416: PUSH
10417: LD_INT 0
10419: GREATER
10420: IFFALSE 10525
// for j = 1 to GetTaskList ( i ) do
10422: LD_ADDR_VAR 0 3
10426: PUSH
10427: DOUBLE
10428: LD_INT 1
10430: DEC
10431: ST_TO_ADDR
10432: LD_VAR 0 2
10436: PPUSH
10437: CALL_OW 437
10441: PUSH
10442: FOR_TO
10443: IFFALSE 10523
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10445: LD_ADDR_VAR 0 4
10449: PUSH
10450: LD_VAR 0 2
10454: PPUSH
10455: CALL_OW 437
10459: PUSH
10460: LD_VAR 0 3
10464: ARRAY
10465: PUSH
10466: LD_INT 4
10468: ARRAY
10469: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10470: LD_VAR 0 4
10474: PPUSH
10475: CALL_OW 255
10479: PUSH
10480: LD_INT 4
10482: EQUAL
10483: PUSH
10484: LD_VAR 0 2
10488: PPUSH
10489: CALL_OW 437
10493: PUSH
10494: LD_VAR 0 3
10498: ARRAY
10499: PUSH
10500: LD_INT 1
10502: ARRAY
10503: PUSH
10504: LD_STRING <
10506: EQUAL
10507: AND
10508: IFFALSE 10521
// SetTaskList ( i , [ ] ) ;
10510: LD_VAR 0 2
10514: PPUSH
10515: EMPTY
10516: PPUSH
10517: CALL_OW 446
// end ;
10521: GO 10442
10523: POP
10524: POP
// end ;
10525: GO 10404
10527: POP
10528: POP
// end ; end ;
10529: PPOPN 4
10531: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10532: LD_VAR 0 2
10536: PPUSH
10537: LD_VAR 0 3
10541: PPUSH
10542: CALL_OW 428
10546: PPUSH
10547: CALL_OW 255
10551: PUSH
10552: LD_INT 1
10554: EQUAL
10555: PUSH
10556: LD_VAR 0 2
10560: PUSH
10561: LD_INT 132
10563: EQUAL
10564: PUSH
10565: LD_VAR 0 3
10569: PUSH
10570: LD_INT 39
10572: EQUAL
10573: AND
10574: OR
10575: IFFALSE 10591
// DialogContaminateSib ( x , y ) ;
10577: LD_VAR 0 2
10581: PPUSH
10582: LD_VAR 0 3
10586: PPUSH
10587: CALL 9705 0 2
// end ;
10591: PPOPN 3
10593: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10594: LD_VAR 0 1
10598: PPUSH
10599: CALL 91895 0 1
// MCE_UnitDestroyed ( un ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: CALL 81610 0 1
// if un = Powell then
10612: LD_VAR 0 1
10616: PUSH
10617: LD_EXP 10
10621: EQUAL
10622: IFFALSE 10631
// YouLost ( Powell ) ;
10624: LD_STRING Powell
10626: PPUSH
10627: CALL_OW 104
// if un = Sikorski then
10631: LD_VAR 0 1
10635: PUSH
10636: LD_EXP 20
10640: EQUAL
10641: IFFALSE 10650
// YouLost ( Sikorski ) ;
10643: LD_STRING Sikorski
10645: PPUSH
10646: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10650: LD_VAR 0 1
10654: PUSH
10655: LD_INT 22
10657: PUSH
10658: LD_INT 1
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: PUSH
10665: LD_INT 21
10667: PUSH
10668: LD_INT 1
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: PPUSH
10679: CALL_OW 69
10683: IN
10684: IFFALSE 10700
// loseCounter := loseCounter + 1 ;
10686: LD_ADDR_EXP 6
10690: PUSH
10691: LD_EXP 6
10695: PUSH
10696: LD_INT 1
10698: PLUS
10699: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10700: LD_VAR 0 1
10704: PUSH
10705: LD_INT 22
10707: PUSH
10708: LD_INT 4
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: PUSH
10715: LD_INT 21
10717: PUSH
10718: LD_INT 1
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: PPUSH
10729: CALL_OW 69
10733: IN
10734: IFFALSE 10750
// powellLoseCounter := powellLoseCounter + 1 ;
10736: LD_ADDR_EXP 7
10740: PUSH
10741: LD_EXP 7
10745: PUSH
10746: LD_INT 1
10748: PLUS
10749: ST_TO_ADDR
// if un in powellAttackGroup then
10750: LD_VAR 0 1
10754: PUSH
10755: LD_EXP 12
10759: IN
10760: IFFALSE 10778
// powellAttackGroup := powellAttackGroup diff un ;
10762: LD_ADDR_EXP 12
10766: PUSH
10767: LD_EXP 12
10771: PUSH
10772: LD_VAR 0 1
10776: DIFF
10777: ST_TO_ADDR
// if un in gensherAttackGroup then
10778: LD_VAR 0 1
10782: PUSH
10783: LD_EXP 15
10787: IN
10788: IFFALSE 10806
// gensherAttackGroup := gensherAttackGroup diff un ;
10790: LD_ADDR_EXP 15
10794: PUSH
10795: LD_EXP 15
10799: PUSH
10800: LD_VAR 0 1
10804: DIFF
10805: ST_TO_ADDR
// if un in popovAttackGroup then
10806: LD_VAR 0 1
10810: PUSH
10811: LD_EXP 19
10815: IN
10816: IFFALSE 10834
// popovAttackGroup := popovAttackGroup diff un ;
10818: LD_ADDR_EXP 19
10822: PUSH
10823: LD_EXP 19
10827: PUSH
10828: LD_VAR 0 1
10832: DIFF
10833: ST_TO_ADDR
// end ;
10834: PPOPN 1
10836: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10837: LD_VAR 0 1
10841: PPUSH
10842: LD_VAR 0 2
10846: PPUSH
10847: CALL 83942 0 2
// end ;
10851: PPOPN 2
10853: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10854: LD_VAR 0 1
10858: PPUSH
10859: CALL 83010 0 1
// end ;
10863: PPOPN 1
10865: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10866: LD_VAR 0 1
10870: PPUSH
10871: CALL 83251 0 1
// end ;
10875: PPOPN 1
10877: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_VAR 0 2
10887: PPUSH
10888: CALL 81306 0 2
// end ;
10892: PPOPN 2
10894: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10895: LD_VAR 0 1
10899: PPUSH
10900: LD_VAR 0 2
10904: PPUSH
10905: LD_VAR 0 3
10909: PPUSH
10910: LD_VAR 0 4
10914: PPUSH
10915: LD_VAR 0 5
10919: PPUSH
10920: CALL 80926 0 5
// end ;
10924: PPOPN 5
10926: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10927: LD_VAR 0 1
10931: PPUSH
10932: LD_VAR 0 2
10936: PPUSH
10937: CALL 92015 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_VAR 0 2
10950: PPUSH
10951: CALL 80479 0 2
// end ;
10955: PPOPN 2
10957: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10958: LD_VAR 0 1
10962: PPUSH
10963: LD_VAR 0 2
10967: PPUSH
10968: LD_VAR 0 3
10972: PPUSH
10973: LD_VAR 0 4
10977: PPUSH
10978: CALL 80317 0 4
// end ;
10982: PPOPN 4
10984: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10985: LD_VAR 0 1
10989: PPUSH
10990: LD_VAR 0 2
10994: PPUSH
10995: LD_VAR 0 3
10999: PPUSH
11000: CALL 80092 0 3
// end ;
11004: PPOPN 3
11006: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11007: LD_VAR 0 1
11011: PPUSH
11012: LD_VAR 0 2
11016: PPUSH
11017: CALL 79977 0 2
// end ;
11021: PPOPN 2
11023: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11024: LD_VAR 0 1
11028: PPUSH
11029: LD_VAR 0 2
11033: PPUSH
11034: CALL 84237 0 2
// end ;
11038: PPOPN 2
11040: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11041: LD_VAR 0 1
11045: PPUSH
11046: LD_VAR 0 2
11050: PPUSH
11051: LD_VAR 0 3
11055: PPUSH
11056: LD_VAR 0 4
11060: PPUSH
11061: CALL 84453 0 4
// end ;
11065: PPOPN 4
11067: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11068: LD_VAR 0 1
11072: PPUSH
11073: LD_VAR 0 2
11077: PPUSH
11078: CALL 79786 0 2
// end ;
11082: PPOPN 2
11084: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
11085: LD_VAR 0 1
11089: PUSH
11090: LD_INT 1
11092: EQUAL
11093: PUSH
11094: LD_VAR 0 2
11098: PUSH
11099: LD_INT 4
11101: EQUAL
11102: AND
11103: IFFALSE 11112
// YouLost ( FriendlyFire ) ;
11105: LD_STRING FriendlyFire
11107: PPUSH
11108: CALL_OW 104
// end ; end_of_file
11112: PPOPN 2
11114: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11115: LD_INT 0
11117: PPUSH
11118: PPUSH
// if exist_mode then
11119: LD_VAR 0 2
11123: IFFALSE 11148
// unit := CreateCharacter ( prefix & ident ) else
11125: LD_ADDR_VAR 0 5
11129: PUSH
11130: LD_VAR 0 3
11134: PUSH
11135: LD_VAR 0 1
11139: STR
11140: PPUSH
11141: CALL_OW 34
11145: ST_TO_ADDR
11146: GO 11163
// unit := NewCharacter ( ident ) ;
11148: LD_ADDR_VAR 0 5
11152: PUSH
11153: LD_VAR 0 1
11157: PPUSH
11158: CALL_OW 25
11162: ST_TO_ADDR
// result := unit ;
11163: LD_ADDR_VAR 0 4
11167: PUSH
11168: LD_VAR 0 5
11172: ST_TO_ADDR
// end ;
11173: LD_VAR 0 4
11177: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11178: LD_INT 0
11180: PPUSH
11181: PPUSH
// if not side or not nation then
11182: LD_VAR 0 1
11186: NOT
11187: PUSH
11188: LD_VAR 0 2
11192: NOT
11193: OR
11194: IFFALSE 11198
// exit ;
11196: GO 11966
// case nation of nation_american :
11198: LD_VAR 0 2
11202: PUSH
11203: LD_INT 1
11205: DOUBLE
11206: EQUAL
11207: IFTRUE 11211
11209: GO 11425
11211: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11212: LD_ADDR_VAR 0 4
11216: PUSH
11217: LD_INT 35
11219: PUSH
11220: LD_INT 45
11222: PUSH
11223: LD_INT 46
11225: PUSH
11226: LD_INT 47
11228: PUSH
11229: LD_INT 82
11231: PUSH
11232: LD_INT 83
11234: PUSH
11235: LD_INT 84
11237: PUSH
11238: LD_INT 85
11240: PUSH
11241: LD_INT 86
11243: PUSH
11244: LD_INT 1
11246: PUSH
11247: LD_INT 2
11249: PUSH
11250: LD_INT 6
11252: PUSH
11253: LD_INT 15
11255: PUSH
11256: LD_INT 16
11258: PUSH
11259: LD_INT 7
11261: PUSH
11262: LD_INT 12
11264: PUSH
11265: LD_INT 13
11267: PUSH
11268: LD_INT 10
11270: PUSH
11271: LD_INT 14
11273: PUSH
11274: LD_INT 20
11276: PUSH
11277: LD_INT 21
11279: PUSH
11280: LD_INT 22
11282: PUSH
11283: LD_INT 25
11285: PUSH
11286: LD_INT 32
11288: PUSH
11289: LD_INT 27
11291: PUSH
11292: LD_INT 36
11294: PUSH
11295: LD_INT 69
11297: PUSH
11298: LD_INT 39
11300: PUSH
11301: LD_INT 34
11303: PUSH
11304: LD_INT 40
11306: PUSH
11307: LD_INT 48
11309: PUSH
11310: LD_INT 49
11312: PUSH
11313: LD_INT 50
11315: PUSH
11316: LD_INT 51
11318: PUSH
11319: LD_INT 52
11321: PUSH
11322: LD_INT 53
11324: PUSH
11325: LD_INT 54
11327: PUSH
11328: LD_INT 55
11330: PUSH
11331: LD_INT 56
11333: PUSH
11334: LD_INT 57
11336: PUSH
11337: LD_INT 58
11339: PUSH
11340: LD_INT 59
11342: PUSH
11343: LD_INT 60
11345: PUSH
11346: LD_INT 61
11348: PUSH
11349: LD_INT 62
11351: PUSH
11352: LD_INT 80
11354: PUSH
11355: LD_INT 82
11357: PUSH
11358: LD_INT 83
11360: PUSH
11361: LD_INT 84
11363: PUSH
11364: LD_INT 85
11366: PUSH
11367: LD_INT 86
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: LIST
11374: LIST
11375: LIST
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: LIST
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: ST_TO_ADDR
11423: GO 11890
11425: LD_INT 2
11427: DOUBLE
11428: EQUAL
11429: IFTRUE 11433
11431: GO 11659
11433: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11434: LD_ADDR_VAR 0 4
11438: PUSH
11439: LD_INT 35
11441: PUSH
11442: LD_INT 45
11444: PUSH
11445: LD_INT 46
11447: PUSH
11448: LD_INT 47
11450: PUSH
11451: LD_INT 82
11453: PUSH
11454: LD_INT 83
11456: PUSH
11457: LD_INT 84
11459: PUSH
11460: LD_INT 85
11462: PUSH
11463: LD_INT 87
11465: PUSH
11466: LD_INT 70
11468: PUSH
11469: LD_INT 1
11471: PUSH
11472: LD_INT 11
11474: PUSH
11475: LD_INT 3
11477: PUSH
11478: LD_INT 4
11480: PUSH
11481: LD_INT 5
11483: PUSH
11484: LD_INT 6
11486: PUSH
11487: LD_INT 15
11489: PUSH
11490: LD_INT 18
11492: PUSH
11493: LD_INT 7
11495: PUSH
11496: LD_INT 17
11498: PUSH
11499: LD_INT 8
11501: PUSH
11502: LD_INT 20
11504: PUSH
11505: LD_INT 21
11507: PUSH
11508: LD_INT 22
11510: PUSH
11511: LD_INT 72
11513: PUSH
11514: LD_INT 26
11516: PUSH
11517: LD_INT 69
11519: PUSH
11520: LD_INT 39
11522: PUSH
11523: LD_INT 40
11525: PUSH
11526: LD_INT 41
11528: PUSH
11529: LD_INT 42
11531: PUSH
11532: LD_INT 43
11534: PUSH
11535: LD_INT 48
11537: PUSH
11538: LD_INT 49
11540: PUSH
11541: LD_INT 50
11543: PUSH
11544: LD_INT 51
11546: PUSH
11547: LD_INT 52
11549: PUSH
11550: LD_INT 53
11552: PUSH
11553: LD_INT 54
11555: PUSH
11556: LD_INT 55
11558: PUSH
11559: LD_INT 56
11561: PUSH
11562: LD_INT 60
11564: PUSH
11565: LD_INT 61
11567: PUSH
11568: LD_INT 62
11570: PUSH
11571: LD_INT 66
11573: PUSH
11574: LD_INT 67
11576: PUSH
11577: LD_INT 68
11579: PUSH
11580: LD_INT 81
11582: PUSH
11583: LD_INT 82
11585: PUSH
11586: LD_INT 83
11588: PUSH
11589: LD_INT 84
11591: PUSH
11592: LD_INT 85
11594: PUSH
11595: LD_INT 87
11597: PUSH
11598: LD_INT 88
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: ST_TO_ADDR
11657: GO 11890
11659: LD_INT 3
11661: DOUBLE
11662: EQUAL
11663: IFTRUE 11667
11665: GO 11889
11667: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11668: LD_ADDR_VAR 0 4
11672: PUSH
11673: LD_INT 46
11675: PUSH
11676: LD_INT 47
11678: PUSH
11679: LD_INT 1
11681: PUSH
11682: LD_INT 2
11684: PUSH
11685: LD_INT 82
11687: PUSH
11688: LD_INT 83
11690: PUSH
11691: LD_INT 84
11693: PUSH
11694: LD_INT 85
11696: PUSH
11697: LD_INT 86
11699: PUSH
11700: LD_INT 11
11702: PUSH
11703: LD_INT 9
11705: PUSH
11706: LD_INT 20
11708: PUSH
11709: LD_INT 19
11711: PUSH
11712: LD_INT 21
11714: PUSH
11715: LD_INT 24
11717: PUSH
11718: LD_INT 22
11720: PUSH
11721: LD_INT 25
11723: PUSH
11724: LD_INT 28
11726: PUSH
11727: LD_INT 29
11729: PUSH
11730: LD_INT 30
11732: PUSH
11733: LD_INT 31
11735: PUSH
11736: LD_INT 37
11738: PUSH
11739: LD_INT 38
11741: PUSH
11742: LD_INT 32
11744: PUSH
11745: LD_INT 27
11747: PUSH
11748: LD_INT 33
11750: PUSH
11751: LD_INT 69
11753: PUSH
11754: LD_INT 39
11756: PUSH
11757: LD_INT 34
11759: PUSH
11760: LD_INT 40
11762: PUSH
11763: LD_INT 71
11765: PUSH
11766: LD_INT 23
11768: PUSH
11769: LD_INT 44
11771: PUSH
11772: LD_INT 48
11774: PUSH
11775: LD_INT 49
11777: PUSH
11778: LD_INT 50
11780: PUSH
11781: LD_INT 51
11783: PUSH
11784: LD_INT 52
11786: PUSH
11787: LD_INT 53
11789: PUSH
11790: LD_INT 54
11792: PUSH
11793: LD_INT 55
11795: PUSH
11796: LD_INT 56
11798: PUSH
11799: LD_INT 57
11801: PUSH
11802: LD_INT 58
11804: PUSH
11805: LD_INT 59
11807: PUSH
11808: LD_INT 63
11810: PUSH
11811: LD_INT 64
11813: PUSH
11814: LD_INT 65
11816: PUSH
11817: LD_INT 82
11819: PUSH
11820: LD_INT 83
11822: PUSH
11823: LD_INT 84
11825: PUSH
11826: LD_INT 85
11828: PUSH
11829: LD_INT 86
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: ST_TO_ADDR
11887: GO 11890
11889: POP
// if state > - 1 and state < 3 then
11890: LD_VAR 0 3
11894: PUSH
11895: LD_INT 1
11897: NEG
11898: GREATER
11899: PUSH
11900: LD_VAR 0 3
11904: PUSH
11905: LD_INT 3
11907: LESS
11908: AND
11909: IFFALSE 11966
// for i in result do
11911: LD_ADDR_VAR 0 5
11915: PUSH
11916: LD_VAR 0 4
11920: PUSH
11921: FOR_IN
11922: IFFALSE 11964
// if GetTech ( i , side ) <> state then
11924: LD_VAR 0 5
11928: PPUSH
11929: LD_VAR 0 1
11933: PPUSH
11934: CALL_OW 321
11938: PUSH
11939: LD_VAR 0 3
11943: NONEQUAL
11944: IFFALSE 11962
// result := result diff i ;
11946: LD_ADDR_VAR 0 4
11950: PUSH
11951: LD_VAR 0 4
11955: PUSH
11956: LD_VAR 0 5
11960: DIFF
11961: ST_TO_ADDR
11962: GO 11921
11964: POP
11965: POP
// end ;
11966: LD_VAR 0 4
11970: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11971: LD_INT 0
11973: PPUSH
11974: PPUSH
11975: PPUSH
// result := true ;
11976: LD_ADDR_VAR 0 3
11980: PUSH
11981: LD_INT 1
11983: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11984: LD_ADDR_VAR 0 5
11988: PUSH
11989: LD_VAR 0 2
11993: PPUSH
11994: CALL_OW 480
11998: ST_TO_ADDR
// if not tmp then
11999: LD_VAR 0 5
12003: NOT
12004: IFFALSE 12008
// exit ;
12006: GO 12057
// for i in tmp do
12008: LD_ADDR_VAR 0 4
12012: PUSH
12013: LD_VAR 0 5
12017: PUSH
12018: FOR_IN
12019: IFFALSE 12055
// if GetTech ( i , side ) <> state_researched then
12021: LD_VAR 0 4
12025: PPUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 321
12035: PUSH
12036: LD_INT 2
12038: NONEQUAL
12039: IFFALSE 12053
// begin result := false ;
12041: LD_ADDR_VAR 0 3
12045: PUSH
12046: LD_INT 0
12048: ST_TO_ADDR
// exit ;
12049: POP
12050: POP
12051: GO 12057
// end ;
12053: GO 12018
12055: POP
12056: POP
// end ;
12057: LD_VAR 0 3
12061: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
12062: LD_INT 0
12064: PPUSH
12065: PPUSH
12066: PPUSH
12067: PPUSH
12068: PPUSH
12069: PPUSH
12070: PPUSH
12071: PPUSH
12072: PPUSH
12073: PPUSH
12074: PPUSH
12075: PPUSH
12076: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
12077: LD_VAR 0 1
12081: NOT
12082: PUSH
12083: LD_VAR 0 1
12087: PPUSH
12088: CALL_OW 257
12092: PUSH
12093: LD_INT 9
12095: NONEQUAL
12096: OR
12097: IFFALSE 12101
// exit ;
12099: GO 12674
// side := GetSide ( unit ) ;
12101: LD_ADDR_VAR 0 9
12105: PUSH
12106: LD_VAR 0 1
12110: PPUSH
12111: CALL_OW 255
12115: ST_TO_ADDR
// tech_space := tech_spacanom ;
12116: LD_ADDR_VAR 0 12
12120: PUSH
12121: LD_INT 29
12123: ST_TO_ADDR
// tech_time := tech_taurad ;
12124: LD_ADDR_VAR 0 13
12128: PUSH
12129: LD_INT 28
12131: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12132: LD_ADDR_VAR 0 11
12136: PUSH
12137: LD_VAR 0 1
12141: PPUSH
12142: CALL_OW 310
12146: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12147: LD_VAR 0 11
12151: PPUSH
12152: CALL_OW 247
12156: PUSH
12157: LD_INT 2
12159: EQUAL
12160: IFFALSE 12164
// exit ;
12162: GO 12674
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12164: LD_ADDR_VAR 0 8
12168: PUSH
12169: LD_INT 81
12171: PUSH
12172: LD_VAR 0 9
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: PUSH
12181: LD_INT 3
12183: PUSH
12184: LD_INT 21
12186: PUSH
12187: LD_INT 3
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PPUSH
12202: CALL_OW 69
12206: ST_TO_ADDR
// if not tmp then
12207: LD_VAR 0 8
12211: NOT
12212: IFFALSE 12216
// exit ;
12214: GO 12674
// if in_unit then
12216: LD_VAR 0 11
12220: IFFALSE 12244
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12222: LD_ADDR_VAR 0 10
12226: PUSH
12227: LD_VAR 0 8
12231: PPUSH
12232: LD_VAR 0 11
12236: PPUSH
12237: CALL_OW 74
12241: ST_TO_ADDR
12242: GO 12264
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12244: LD_ADDR_VAR 0 10
12248: PUSH
12249: LD_VAR 0 8
12253: PPUSH
12254: LD_VAR 0 1
12258: PPUSH
12259: CALL_OW 74
12263: ST_TO_ADDR
// if not enemy then
12264: LD_VAR 0 10
12268: NOT
12269: IFFALSE 12273
// exit ;
12271: GO 12674
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12273: LD_VAR 0 11
12277: PUSH
12278: LD_VAR 0 11
12282: PPUSH
12283: LD_VAR 0 10
12287: PPUSH
12288: CALL_OW 296
12292: PUSH
12293: LD_INT 13
12295: GREATER
12296: AND
12297: PUSH
12298: LD_VAR 0 1
12302: PPUSH
12303: LD_VAR 0 10
12307: PPUSH
12308: CALL_OW 296
12312: PUSH
12313: LD_INT 12
12315: GREATER
12316: OR
12317: IFFALSE 12321
// exit ;
12319: GO 12674
// missile := [ 1 ] ;
12321: LD_ADDR_VAR 0 14
12325: PUSH
12326: LD_INT 1
12328: PUSH
12329: EMPTY
12330: LIST
12331: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12332: LD_VAR 0 9
12336: PPUSH
12337: LD_VAR 0 12
12341: PPUSH
12342: CALL_OW 325
12346: IFFALSE 12375
// missile := Replace ( missile , missile + 1 , 2 ) ;
12348: LD_ADDR_VAR 0 14
12352: PUSH
12353: LD_VAR 0 14
12357: PPUSH
12358: LD_VAR 0 14
12362: PUSH
12363: LD_INT 1
12365: PLUS
12366: PPUSH
12367: LD_INT 2
12369: PPUSH
12370: CALL_OW 1
12374: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12375: LD_VAR 0 9
12379: PPUSH
12380: LD_VAR 0 13
12384: PPUSH
12385: CALL_OW 325
12389: PUSH
12390: LD_VAR 0 10
12394: PPUSH
12395: CALL_OW 255
12399: PPUSH
12400: LD_VAR 0 13
12404: PPUSH
12405: CALL_OW 325
12409: NOT
12410: AND
12411: IFFALSE 12440
// missile := Replace ( missile , missile + 1 , 3 ) ;
12413: LD_ADDR_VAR 0 14
12417: PUSH
12418: LD_VAR 0 14
12422: PPUSH
12423: LD_VAR 0 14
12427: PUSH
12428: LD_INT 1
12430: PLUS
12431: PPUSH
12432: LD_INT 3
12434: PPUSH
12435: CALL_OW 1
12439: ST_TO_ADDR
// if missile < 2 then
12440: LD_VAR 0 14
12444: PUSH
12445: LD_INT 2
12447: LESS
12448: IFFALSE 12452
// exit ;
12450: GO 12674
// x := GetX ( enemy ) ;
12452: LD_ADDR_VAR 0 4
12456: PUSH
12457: LD_VAR 0 10
12461: PPUSH
12462: CALL_OW 250
12466: ST_TO_ADDR
// y := GetY ( enemy ) ;
12467: LD_ADDR_VAR 0 5
12471: PUSH
12472: LD_VAR 0 10
12476: PPUSH
12477: CALL_OW 251
12481: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12482: LD_ADDR_VAR 0 6
12486: PUSH
12487: LD_VAR 0 4
12491: PUSH
12492: LD_INT 1
12494: NEG
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 12
12503: PLUS
12504: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12505: LD_ADDR_VAR 0 7
12509: PUSH
12510: LD_VAR 0 5
12514: PUSH
12515: LD_INT 1
12517: NEG
12518: PPUSH
12519: LD_INT 1
12521: PPUSH
12522: CALL_OW 12
12526: PLUS
12527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12528: LD_VAR 0 6
12532: PPUSH
12533: LD_VAR 0 7
12537: PPUSH
12538: CALL_OW 488
12542: NOT
12543: IFFALSE 12565
// begin _x := x ;
12545: LD_ADDR_VAR 0 6
12549: PUSH
12550: LD_VAR 0 4
12554: ST_TO_ADDR
// _y := y ;
12555: LD_ADDR_VAR 0 7
12559: PUSH
12560: LD_VAR 0 5
12564: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12565: LD_ADDR_VAR 0 3
12569: PUSH
12570: LD_INT 1
12572: PPUSH
12573: LD_VAR 0 14
12577: PPUSH
12578: CALL_OW 12
12582: ST_TO_ADDR
// case i of 1 :
12583: LD_VAR 0 3
12587: PUSH
12588: LD_INT 1
12590: DOUBLE
12591: EQUAL
12592: IFTRUE 12596
12594: GO 12613
12596: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12597: LD_VAR 0 1
12601: PPUSH
12602: LD_VAR 0 10
12606: PPUSH
12607: CALL_OW 115
12611: GO 12674
12613: LD_INT 2
12615: DOUBLE
12616: EQUAL
12617: IFTRUE 12621
12619: GO 12643
12621: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12622: LD_VAR 0 1
12626: PPUSH
12627: LD_VAR 0 6
12631: PPUSH
12632: LD_VAR 0 7
12636: PPUSH
12637: CALL_OW 153
12641: GO 12674
12643: LD_INT 3
12645: DOUBLE
12646: EQUAL
12647: IFTRUE 12651
12649: GO 12673
12651: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12652: LD_VAR 0 1
12656: PPUSH
12657: LD_VAR 0 6
12661: PPUSH
12662: LD_VAR 0 7
12666: PPUSH
12667: CALL_OW 154
12671: GO 12674
12673: POP
// end ;
12674: LD_VAR 0 2
12678: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12679: LD_INT 0
12681: PPUSH
12682: PPUSH
12683: PPUSH
12684: PPUSH
12685: PPUSH
12686: PPUSH
// if not unit or not building then
12687: LD_VAR 0 1
12691: NOT
12692: PUSH
12693: LD_VAR 0 2
12697: NOT
12698: OR
12699: IFFALSE 12703
// exit ;
12701: GO 12861
// x := GetX ( building ) ;
12703: LD_ADDR_VAR 0 5
12707: PUSH
12708: LD_VAR 0 2
12712: PPUSH
12713: CALL_OW 250
12717: ST_TO_ADDR
// y := GetY ( building ) ;
12718: LD_ADDR_VAR 0 6
12722: PUSH
12723: LD_VAR 0 2
12727: PPUSH
12728: CALL_OW 251
12732: ST_TO_ADDR
// for i = 0 to 5 do
12733: LD_ADDR_VAR 0 4
12737: PUSH
12738: DOUBLE
12739: LD_INT 0
12741: DEC
12742: ST_TO_ADDR
12743: LD_INT 5
12745: PUSH
12746: FOR_TO
12747: IFFALSE 12859
// begin _x := ShiftX ( x , i , 3 ) ;
12749: LD_ADDR_VAR 0 7
12753: PUSH
12754: LD_VAR 0 5
12758: PPUSH
12759: LD_VAR 0 4
12763: PPUSH
12764: LD_INT 3
12766: PPUSH
12767: CALL_OW 272
12771: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12772: LD_ADDR_VAR 0 8
12776: PUSH
12777: LD_VAR 0 6
12781: PPUSH
12782: LD_VAR 0 4
12786: PPUSH
12787: LD_INT 3
12789: PPUSH
12790: CALL_OW 273
12794: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12795: LD_VAR 0 7
12799: PPUSH
12800: LD_VAR 0 8
12804: PPUSH
12805: CALL_OW 488
12809: NOT
12810: IFFALSE 12814
// continue ;
12812: GO 12746
// if HexInfo ( _x , _y ) = 0 then
12814: LD_VAR 0 7
12818: PPUSH
12819: LD_VAR 0 8
12823: PPUSH
12824: CALL_OW 428
12828: PUSH
12829: LD_INT 0
12831: EQUAL
12832: IFFALSE 12857
// begin ComMoveXY ( unit , _x , _y ) ;
12834: LD_VAR 0 1
12838: PPUSH
12839: LD_VAR 0 7
12843: PPUSH
12844: LD_VAR 0 8
12848: PPUSH
12849: CALL_OW 111
// exit ;
12853: POP
12854: POP
12855: GO 12861
// end ; end ;
12857: GO 12746
12859: POP
12860: POP
// end ;
12861: LD_VAR 0 3
12865: RET
// export function ScanBase ( side , base_area ) ; begin
12866: LD_INT 0
12868: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12869: LD_ADDR_VAR 0 3
12873: PUSH
12874: LD_VAR 0 2
12878: PPUSH
12879: LD_INT 81
12881: PUSH
12882: LD_VAR 0 1
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: PPUSH
12891: CALL_OW 70
12895: ST_TO_ADDR
// end ;
12896: LD_VAR 0 3
12900: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12901: LD_INT 0
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// result := false ;
12907: LD_ADDR_VAR 0 2
12911: PUSH
12912: LD_INT 0
12914: ST_TO_ADDR
// side := GetSide ( unit ) ;
12915: LD_ADDR_VAR 0 3
12919: PUSH
12920: LD_VAR 0 1
12924: PPUSH
12925: CALL_OW 255
12929: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12930: LD_ADDR_VAR 0 4
12934: PUSH
12935: LD_VAR 0 1
12939: PPUSH
12940: CALL_OW 248
12944: ST_TO_ADDR
// case nat of 1 :
12945: LD_VAR 0 4
12949: PUSH
12950: LD_INT 1
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12969
12958: POP
// tech := tech_lassight ; 2 :
12959: LD_ADDR_VAR 0 5
12963: PUSH
12964: LD_INT 12
12966: ST_TO_ADDR
12967: GO 13008
12969: LD_INT 2
12971: DOUBLE
12972: EQUAL
12973: IFTRUE 12977
12975: GO 12988
12977: POP
// tech := tech_mortar ; 3 :
12978: LD_ADDR_VAR 0 5
12982: PUSH
12983: LD_INT 41
12985: ST_TO_ADDR
12986: GO 13008
12988: LD_INT 3
12990: DOUBLE
12991: EQUAL
12992: IFTRUE 12996
12994: GO 13007
12996: POP
// tech := tech_bazooka ; end ;
12997: LD_ADDR_VAR 0 5
13001: PUSH
13002: LD_INT 44
13004: ST_TO_ADDR
13005: GO 13008
13007: POP
// if Researched ( side , tech ) then
13008: LD_VAR 0 3
13012: PPUSH
13013: LD_VAR 0 5
13017: PPUSH
13018: CALL_OW 325
13022: IFFALSE 13049
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
13024: LD_ADDR_VAR 0 2
13028: PUSH
13029: LD_INT 5
13031: PUSH
13032: LD_INT 8
13034: PUSH
13035: LD_INT 9
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: LD_VAR 0 4
13047: ARRAY
13048: ST_TO_ADDR
// end ;
13049: LD_VAR 0 2
13053: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
13054: LD_INT 0
13056: PPUSH
13057: PPUSH
13058: PPUSH
// if not mines then
13059: LD_VAR 0 2
13063: NOT
13064: IFFALSE 13068
// exit ;
13066: GO 13212
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_INT 81
13075: PUSH
13076: LD_VAR 0 1
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: LD_INT 21
13090: PUSH
13091: LD_INT 3
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL_OW 69
13110: ST_TO_ADDR
// for i in mines do
13111: LD_ADDR_VAR 0 4
13115: PUSH
13116: LD_VAR 0 2
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13210
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13124: LD_VAR 0 4
13128: PUSH
13129: LD_INT 1
13131: ARRAY
13132: PPUSH
13133: LD_VAR 0 4
13137: PUSH
13138: LD_INT 2
13140: ARRAY
13141: PPUSH
13142: CALL_OW 458
13146: NOT
13147: IFFALSE 13151
// continue ;
13149: GO 13121
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13151: LD_VAR 0 4
13155: PUSH
13156: LD_INT 1
13158: ARRAY
13159: PPUSH
13160: LD_VAR 0 4
13164: PUSH
13165: LD_INT 2
13167: ARRAY
13168: PPUSH
13169: CALL_OW 428
13173: PUSH
13174: LD_VAR 0 5
13178: IN
13179: IFFALSE 13208
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13181: LD_VAR 0 4
13185: PUSH
13186: LD_INT 1
13188: ARRAY
13189: PPUSH
13190: LD_VAR 0 4
13194: PUSH
13195: LD_INT 2
13197: ARRAY
13198: PPUSH
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 456
// end ;
13208: GO 13121
13210: POP
13211: POP
// end ;
13212: LD_VAR 0 3
13216: RET
// export function Count ( array ) ; begin
13217: LD_INT 0
13219: PPUSH
// result := array + 0 ;
13220: LD_ADDR_VAR 0 2
13224: PUSH
13225: LD_VAR 0 1
13229: PUSH
13230: LD_INT 0
13232: PLUS
13233: ST_TO_ADDR
// end ;
13234: LD_VAR 0 2
13238: RET
// export function IsEmpty ( building ) ; begin
13239: LD_INT 0
13241: PPUSH
// if not building then
13242: LD_VAR 0 1
13246: NOT
13247: IFFALSE 13251
// exit ;
13249: GO 13294
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13251: LD_ADDR_VAR 0 2
13255: PUSH
13256: LD_VAR 0 1
13260: PUSH
13261: LD_INT 22
13263: PUSH
13264: LD_VAR 0 1
13268: PPUSH
13269: CALL_OW 255
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: PUSH
13278: LD_INT 58
13280: PUSH
13281: EMPTY
13282: LIST
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: PPUSH
13288: CALL_OW 69
13292: IN
13293: ST_TO_ADDR
// end ;
13294: LD_VAR 0 2
13298: RET
// export function IsNotFull ( building ) ; var places ; begin
13299: LD_INT 0
13301: PPUSH
13302: PPUSH
// if not building then
13303: LD_VAR 0 1
13307: NOT
13308: IFFALSE 13312
// exit ;
13310: GO 13340
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_VAR 0 1
13321: PPUSH
13322: LD_INT 3
13324: PUSH
13325: LD_INT 62
13327: PUSH
13328: EMPTY
13329: LIST
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PPUSH
13335: CALL_OW 72
13339: ST_TO_ADDR
// end ;
13340: LD_VAR 0 2
13344: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13345: LD_INT 0
13347: PPUSH
13348: PPUSH
13349: PPUSH
13350: PPUSH
// tmp := [ ] ;
13351: LD_ADDR_VAR 0 3
13355: PUSH
13356: EMPTY
13357: ST_TO_ADDR
// list := [ ] ;
13358: LD_ADDR_VAR 0 5
13362: PUSH
13363: EMPTY
13364: ST_TO_ADDR
// for i = 16 to 25 do
13365: LD_ADDR_VAR 0 4
13369: PUSH
13370: DOUBLE
13371: LD_INT 16
13373: DEC
13374: ST_TO_ADDR
13375: LD_INT 25
13377: PUSH
13378: FOR_TO
13379: IFFALSE 13452
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13381: LD_ADDR_VAR 0 3
13385: PUSH
13386: LD_VAR 0 3
13390: PUSH
13391: LD_INT 22
13393: PUSH
13394: LD_VAR 0 1
13398: PPUSH
13399: CALL_OW 255
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: PUSH
13408: LD_INT 91
13410: PUSH
13411: LD_VAR 0 1
13415: PUSH
13416: LD_INT 6
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: PUSH
13424: LD_INT 30
13426: PUSH
13427: LD_VAR 0 4
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: LIST
13440: PUSH
13441: EMPTY
13442: LIST
13443: PPUSH
13444: CALL_OW 69
13448: ADD
13449: ST_TO_ADDR
13450: GO 13378
13452: POP
13453: POP
// for i = 1 to tmp do
13454: LD_ADDR_VAR 0 4
13458: PUSH
13459: DOUBLE
13460: LD_INT 1
13462: DEC
13463: ST_TO_ADDR
13464: LD_VAR 0 3
13468: PUSH
13469: FOR_TO
13470: IFFALSE 13558
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: LD_VAR 0 5
13481: PUSH
13482: LD_VAR 0 3
13486: PUSH
13487: LD_VAR 0 4
13491: ARRAY
13492: PPUSH
13493: CALL_OW 266
13497: PUSH
13498: LD_VAR 0 3
13502: PUSH
13503: LD_VAR 0 4
13507: ARRAY
13508: PPUSH
13509: CALL_OW 250
13513: PUSH
13514: LD_VAR 0 3
13518: PUSH
13519: LD_VAR 0 4
13523: ARRAY
13524: PPUSH
13525: CALL_OW 251
13529: PUSH
13530: LD_VAR 0 3
13534: PUSH
13535: LD_VAR 0 4
13539: ARRAY
13540: PPUSH
13541: CALL_OW 254
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: LIST
13550: LIST
13551: PUSH
13552: EMPTY
13553: LIST
13554: ADD
13555: ST_TO_ADDR
13556: GO 13469
13558: POP
13559: POP
// result := list ;
13560: LD_ADDR_VAR 0 2
13564: PUSH
13565: LD_VAR 0 5
13569: ST_TO_ADDR
// end ;
13570: LD_VAR 0 2
13574: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13575: LD_INT 0
13577: PPUSH
13578: PPUSH
13579: PPUSH
13580: PPUSH
13581: PPUSH
13582: PPUSH
13583: PPUSH
// if not factory then
13584: LD_VAR 0 1
13588: NOT
13589: IFFALSE 13593
// exit ;
13591: GO 14186
// if control = control_apeman then
13593: LD_VAR 0 4
13597: PUSH
13598: LD_INT 5
13600: EQUAL
13601: IFFALSE 13710
// begin tmp := UnitsInside ( factory ) ;
13603: LD_ADDR_VAR 0 8
13607: PUSH
13608: LD_VAR 0 1
13612: PPUSH
13613: CALL_OW 313
13617: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13618: LD_VAR 0 8
13622: PPUSH
13623: LD_INT 25
13625: PUSH
13626: LD_INT 12
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: PPUSH
13633: CALL_OW 72
13637: NOT
13638: IFFALSE 13648
// control := control_manual ;
13640: LD_ADDR_VAR 0 4
13644: PUSH
13645: LD_INT 1
13647: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13648: LD_ADDR_VAR 0 8
13652: PUSH
13653: LD_VAR 0 1
13657: PPUSH
13658: CALL 13345 0 1
13662: ST_TO_ADDR
// if tmp then
13663: LD_VAR 0 8
13667: IFFALSE 13710
// begin for i in tmp do
13669: LD_ADDR_VAR 0 7
13673: PUSH
13674: LD_VAR 0 8
13678: PUSH
13679: FOR_IN
13680: IFFALSE 13708
// if i [ 1 ] = b_ext_radio then
13682: LD_VAR 0 7
13686: PUSH
13687: LD_INT 1
13689: ARRAY
13690: PUSH
13691: LD_INT 22
13693: EQUAL
13694: IFFALSE 13706
// begin control := control_remote ;
13696: LD_ADDR_VAR 0 4
13700: PUSH
13701: LD_INT 2
13703: ST_TO_ADDR
// break ;
13704: GO 13708
// end ;
13706: GO 13679
13708: POP
13709: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13710: LD_VAR 0 1
13714: PPUSH
13715: LD_VAR 0 2
13719: PPUSH
13720: LD_VAR 0 3
13724: PPUSH
13725: LD_VAR 0 4
13729: PPUSH
13730: LD_VAR 0 5
13734: PPUSH
13735: CALL_OW 448
13739: IFFALSE 13774
// begin result := [ chassis , engine , control , weapon ] ;
13741: LD_ADDR_VAR 0 6
13745: PUSH
13746: LD_VAR 0 2
13750: PUSH
13751: LD_VAR 0 3
13755: PUSH
13756: LD_VAR 0 4
13760: PUSH
13761: LD_VAR 0 5
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: ST_TO_ADDR
// exit ;
13772: GO 14186
// end ; _chassis := AvailableChassisList ( factory ) ;
13774: LD_ADDR_VAR 0 9
13778: PUSH
13779: LD_VAR 0 1
13783: PPUSH
13784: CALL_OW 475
13788: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13789: LD_ADDR_VAR 0 11
13793: PUSH
13794: LD_VAR 0 1
13798: PPUSH
13799: CALL_OW 476
13803: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13804: LD_ADDR_VAR 0 12
13808: PUSH
13809: LD_VAR 0 1
13813: PPUSH
13814: CALL_OW 477
13818: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13819: LD_ADDR_VAR 0 10
13823: PUSH
13824: LD_VAR 0 1
13828: PPUSH
13829: CALL_OW 478
13833: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13834: LD_VAR 0 9
13838: NOT
13839: PUSH
13840: LD_VAR 0 11
13844: NOT
13845: OR
13846: PUSH
13847: LD_VAR 0 12
13851: NOT
13852: OR
13853: PUSH
13854: LD_VAR 0 10
13858: NOT
13859: OR
13860: IFFALSE 13895
// begin result := [ chassis , engine , control , weapon ] ;
13862: LD_ADDR_VAR 0 6
13866: PUSH
13867: LD_VAR 0 2
13871: PUSH
13872: LD_VAR 0 3
13876: PUSH
13877: LD_VAR 0 4
13881: PUSH
13882: LD_VAR 0 5
13886: PUSH
13887: EMPTY
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: ST_TO_ADDR
// exit ;
13893: GO 14186
// end ; if not chassis in _chassis then
13895: LD_VAR 0 2
13899: PUSH
13900: LD_VAR 0 9
13904: IN
13905: NOT
13906: IFFALSE 13932
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 9
13917: PUSH
13918: LD_INT 1
13920: PPUSH
13921: LD_VAR 0 9
13925: PPUSH
13926: CALL_OW 12
13930: ARRAY
13931: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13932: LD_VAR 0 2
13936: PPUSH
13937: LD_VAR 0 3
13941: PPUSH
13942: CALL 14191 0 2
13946: NOT
13947: IFFALSE 14006
// repeat engine := _engine [ 1 ] ;
13949: LD_ADDR_VAR 0 3
13953: PUSH
13954: LD_VAR 0 11
13958: PUSH
13959: LD_INT 1
13961: ARRAY
13962: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13963: LD_ADDR_VAR 0 11
13967: PUSH
13968: LD_VAR 0 11
13972: PPUSH
13973: LD_INT 1
13975: PPUSH
13976: CALL_OW 3
13980: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13981: LD_VAR 0 2
13985: PPUSH
13986: LD_VAR 0 3
13990: PPUSH
13991: CALL 14191 0 2
13995: PUSH
13996: LD_VAR 0 11
14000: PUSH
14001: EMPTY
14002: EQUAL
14003: OR
14004: IFFALSE 13949
// if not control in _control then
14006: LD_VAR 0 4
14010: PUSH
14011: LD_VAR 0 12
14015: IN
14016: NOT
14017: IFFALSE 14043
// control := _control [ rand ( 1 , _control ) ] ;
14019: LD_ADDR_VAR 0 4
14023: PUSH
14024: LD_VAR 0 12
14028: PUSH
14029: LD_INT 1
14031: PPUSH
14032: LD_VAR 0 12
14036: PPUSH
14037: CALL_OW 12
14041: ARRAY
14042: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14043: LD_VAR 0 2
14047: PPUSH
14048: LD_VAR 0 5
14052: PPUSH
14053: CALL 14411 0 2
14057: NOT
14058: IFFALSE 14117
// repeat weapon := _weapon [ 1 ] ;
14060: LD_ADDR_VAR 0 5
14064: PUSH
14065: LD_VAR 0 10
14069: PUSH
14070: LD_INT 1
14072: ARRAY
14073: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14074: LD_ADDR_VAR 0 10
14078: PUSH
14079: LD_VAR 0 10
14083: PPUSH
14084: LD_INT 1
14086: PPUSH
14087: CALL_OW 3
14091: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14092: LD_VAR 0 2
14096: PPUSH
14097: LD_VAR 0 5
14101: PPUSH
14102: CALL 14411 0 2
14106: PUSH
14107: LD_VAR 0 10
14111: PUSH
14112: EMPTY
14113: EQUAL
14114: OR
14115: IFFALSE 14060
// result := [ ] ;
14117: LD_ADDR_VAR 0 6
14121: PUSH
14122: EMPTY
14123: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14124: LD_VAR 0 1
14128: PPUSH
14129: LD_VAR 0 2
14133: PPUSH
14134: LD_VAR 0 3
14138: PPUSH
14139: LD_VAR 0 4
14143: PPUSH
14144: LD_VAR 0 5
14148: PPUSH
14149: CALL_OW 448
14153: IFFALSE 14186
// result := [ chassis , engine , control , weapon ] ;
14155: LD_ADDR_VAR 0 6
14159: PUSH
14160: LD_VAR 0 2
14164: PUSH
14165: LD_VAR 0 3
14169: PUSH
14170: LD_VAR 0 4
14174: PUSH
14175: LD_VAR 0 5
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: ST_TO_ADDR
// end ;
14186: LD_VAR 0 6
14190: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14191: LD_INT 0
14193: PPUSH
// if not chassis or not engine then
14194: LD_VAR 0 1
14198: NOT
14199: PUSH
14200: LD_VAR 0 2
14204: NOT
14205: OR
14206: IFFALSE 14210
// exit ;
14208: GO 14406
// case engine of engine_solar :
14210: LD_VAR 0 2
14214: PUSH
14215: LD_INT 2
14217: DOUBLE
14218: EQUAL
14219: IFTRUE 14223
14221: GO 14261
14223: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14224: LD_ADDR_VAR 0 3
14228: PUSH
14229: LD_INT 11
14231: PUSH
14232: LD_INT 12
14234: PUSH
14235: LD_INT 13
14237: PUSH
14238: LD_INT 14
14240: PUSH
14241: LD_INT 1
14243: PUSH
14244: LD_INT 2
14246: PUSH
14247: LD_INT 3
14249: PUSH
14250: EMPTY
14251: LIST
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: LIST
14257: LIST
14258: ST_TO_ADDR
14259: GO 14390
14261: LD_INT 1
14263: DOUBLE
14264: EQUAL
14265: IFTRUE 14269
14267: GO 14331
14269: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14270: LD_ADDR_VAR 0 3
14274: PUSH
14275: LD_INT 11
14277: PUSH
14278: LD_INT 12
14280: PUSH
14281: LD_INT 13
14283: PUSH
14284: LD_INT 14
14286: PUSH
14287: LD_INT 1
14289: PUSH
14290: LD_INT 2
14292: PUSH
14293: LD_INT 3
14295: PUSH
14296: LD_INT 4
14298: PUSH
14299: LD_INT 5
14301: PUSH
14302: LD_INT 21
14304: PUSH
14305: LD_INT 23
14307: PUSH
14308: LD_INT 22
14310: PUSH
14311: LD_INT 24
14313: PUSH
14314: EMPTY
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: ST_TO_ADDR
14329: GO 14390
14331: LD_INT 3
14333: DOUBLE
14334: EQUAL
14335: IFTRUE 14339
14337: GO 14389
14339: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14340: LD_ADDR_VAR 0 3
14344: PUSH
14345: LD_INT 13
14347: PUSH
14348: LD_INT 14
14350: PUSH
14351: LD_INT 2
14353: PUSH
14354: LD_INT 3
14356: PUSH
14357: LD_INT 4
14359: PUSH
14360: LD_INT 5
14362: PUSH
14363: LD_INT 21
14365: PUSH
14366: LD_INT 22
14368: PUSH
14369: LD_INT 23
14371: PUSH
14372: LD_INT 24
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: ST_TO_ADDR
14387: GO 14390
14389: POP
// result := ( chassis in result ) ;
14390: LD_ADDR_VAR 0 3
14394: PUSH
14395: LD_VAR 0 1
14399: PUSH
14400: LD_VAR 0 3
14404: IN
14405: ST_TO_ADDR
// end ;
14406: LD_VAR 0 3
14410: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14411: LD_INT 0
14413: PPUSH
// if not chassis or not weapon then
14414: LD_VAR 0 1
14418: NOT
14419: PUSH
14420: LD_VAR 0 2
14424: NOT
14425: OR
14426: IFFALSE 14430
// exit ;
14428: GO 15490
// case weapon of us_machine_gun :
14430: LD_VAR 0 2
14434: PUSH
14435: LD_INT 2
14437: DOUBLE
14438: EQUAL
14439: IFTRUE 14443
14441: GO 14473
14443: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14444: LD_ADDR_VAR 0 3
14448: PUSH
14449: LD_INT 1
14451: PUSH
14452: LD_INT 2
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: LD_INT 4
14460: PUSH
14461: LD_INT 5
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: ST_TO_ADDR
14471: GO 15474
14473: LD_INT 3
14475: DOUBLE
14476: EQUAL
14477: IFTRUE 14481
14479: GO 14511
14481: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: LD_INT 1
14489: PUSH
14490: LD_INT 2
14492: PUSH
14493: LD_INT 3
14495: PUSH
14496: LD_INT 4
14498: PUSH
14499: LD_INT 5
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: ST_TO_ADDR
14509: GO 15474
14511: LD_INT 11
14513: DOUBLE
14514: EQUAL
14515: IFTRUE 14519
14517: GO 14549
14519: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14520: LD_ADDR_VAR 0 3
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: LD_INT 2
14530: PUSH
14531: LD_INT 3
14533: PUSH
14534: LD_INT 4
14536: PUSH
14537: LD_INT 5
14539: PUSH
14540: EMPTY
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: ST_TO_ADDR
14547: GO 15474
14549: LD_INT 4
14551: DOUBLE
14552: EQUAL
14553: IFTRUE 14557
14555: GO 14583
14557: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14558: LD_ADDR_VAR 0 3
14562: PUSH
14563: LD_INT 2
14565: PUSH
14566: LD_INT 3
14568: PUSH
14569: LD_INT 4
14571: PUSH
14572: LD_INT 5
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: ST_TO_ADDR
14581: GO 15474
14583: LD_INT 5
14585: DOUBLE
14586: EQUAL
14587: IFTRUE 14591
14589: GO 14617
14591: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14592: LD_ADDR_VAR 0 3
14596: PUSH
14597: LD_INT 2
14599: PUSH
14600: LD_INT 3
14602: PUSH
14603: LD_INT 4
14605: PUSH
14606: LD_INT 5
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: ST_TO_ADDR
14615: GO 15474
14617: LD_INT 9
14619: DOUBLE
14620: EQUAL
14621: IFTRUE 14625
14623: GO 14651
14625: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14626: LD_ADDR_VAR 0 3
14630: PUSH
14631: LD_INT 2
14633: PUSH
14634: LD_INT 3
14636: PUSH
14637: LD_INT 4
14639: PUSH
14640: LD_INT 5
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: LIST
14647: LIST
14648: ST_TO_ADDR
14649: GO 15474
14651: LD_INT 7
14653: DOUBLE
14654: EQUAL
14655: IFTRUE 14659
14657: GO 14685
14659: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14660: LD_ADDR_VAR 0 3
14664: PUSH
14665: LD_INT 2
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 4
14673: PUSH
14674: LD_INT 5
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: LIST
14681: LIST
14682: ST_TO_ADDR
14683: GO 15474
14685: LD_INT 12
14687: DOUBLE
14688: EQUAL
14689: IFTRUE 14693
14691: GO 14719
14693: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14694: LD_ADDR_VAR 0 3
14698: PUSH
14699: LD_INT 2
14701: PUSH
14702: LD_INT 3
14704: PUSH
14705: LD_INT 4
14707: PUSH
14708: LD_INT 5
14710: PUSH
14711: EMPTY
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: ST_TO_ADDR
14717: GO 15474
14719: LD_INT 13
14721: DOUBLE
14722: EQUAL
14723: IFTRUE 14727
14725: GO 14753
14727: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14728: LD_ADDR_VAR 0 3
14732: PUSH
14733: LD_INT 2
14735: PUSH
14736: LD_INT 3
14738: PUSH
14739: LD_INT 4
14741: PUSH
14742: LD_INT 5
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: ST_TO_ADDR
14751: GO 15474
14753: LD_INT 14
14755: DOUBLE
14756: EQUAL
14757: IFTRUE 14761
14759: GO 14779
14761: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14762: LD_ADDR_VAR 0 3
14766: PUSH
14767: LD_INT 4
14769: PUSH
14770: LD_INT 5
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: ST_TO_ADDR
14777: GO 15474
14779: LD_INT 6
14781: DOUBLE
14782: EQUAL
14783: IFTRUE 14787
14785: GO 14805
14787: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14788: LD_ADDR_VAR 0 3
14792: PUSH
14793: LD_INT 4
14795: PUSH
14796: LD_INT 5
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: ST_TO_ADDR
14803: GO 15474
14805: LD_INT 10
14807: DOUBLE
14808: EQUAL
14809: IFTRUE 14813
14811: GO 14831
14813: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14814: LD_ADDR_VAR 0 3
14818: PUSH
14819: LD_INT 4
14821: PUSH
14822: LD_INT 5
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: ST_TO_ADDR
14829: GO 15474
14831: LD_INT 22
14833: DOUBLE
14834: EQUAL
14835: IFTRUE 14839
14837: GO 14865
14839: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14840: LD_ADDR_VAR 0 3
14844: PUSH
14845: LD_INT 11
14847: PUSH
14848: LD_INT 12
14850: PUSH
14851: LD_INT 13
14853: PUSH
14854: LD_INT 14
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: LIST
14861: LIST
14862: ST_TO_ADDR
14863: GO 15474
14865: LD_INT 23
14867: DOUBLE
14868: EQUAL
14869: IFTRUE 14873
14871: GO 14899
14873: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14874: LD_ADDR_VAR 0 3
14878: PUSH
14879: LD_INT 11
14881: PUSH
14882: LD_INT 12
14884: PUSH
14885: LD_INT 13
14887: PUSH
14888: LD_INT 14
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: ST_TO_ADDR
14897: GO 15474
14899: LD_INT 24
14901: DOUBLE
14902: EQUAL
14903: IFTRUE 14907
14905: GO 14933
14907: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14908: LD_ADDR_VAR 0 3
14912: PUSH
14913: LD_INT 11
14915: PUSH
14916: LD_INT 12
14918: PUSH
14919: LD_INT 13
14921: PUSH
14922: LD_INT 14
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: ST_TO_ADDR
14931: GO 15474
14933: LD_INT 30
14935: DOUBLE
14936: EQUAL
14937: IFTRUE 14941
14939: GO 14967
14941: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14942: LD_ADDR_VAR 0 3
14946: PUSH
14947: LD_INT 11
14949: PUSH
14950: LD_INT 12
14952: PUSH
14953: LD_INT 13
14955: PUSH
14956: LD_INT 14
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: ST_TO_ADDR
14965: GO 15474
14967: LD_INT 25
14969: DOUBLE
14970: EQUAL
14971: IFTRUE 14975
14973: GO 14993
14975: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14976: LD_ADDR_VAR 0 3
14980: PUSH
14981: LD_INT 13
14983: PUSH
14984: LD_INT 14
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: ST_TO_ADDR
14991: GO 15474
14993: LD_INT 27
14995: DOUBLE
14996: EQUAL
14997: IFTRUE 15001
14999: GO 15019
15001: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15002: LD_ADDR_VAR 0 3
15006: PUSH
15007: LD_INT 13
15009: PUSH
15010: LD_INT 14
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: ST_TO_ADDR
15017: GO 15474
15019: LD_INT 92
15021: DOUBLE
15022: EQUAL
15023: IFTRUE 15027
15025: GO 15053
15027: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15028: LD_ADDR_VAR 0 3
15032: PUSH
15033: LD_INT 11
15035: PUSH
15036: LD_INT 12
15038: PUSH
15039: LD_INT 13
15041: PUSH
15042: LD_INT 14
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: ST_TO_ADDR
15051: GO 15474
15053: LD_INT 28
15055: DOUBLE
15056: EQUAL
15057: IFTRUE 15061
15059: GO 15079
15061: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15062: LD_ADDR_VAR 0 3
15066: PUSH
15067: LD_INT 13
15069: PUSH
15070: LD_INT 14
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: ST_TO_ADDR
15077: GO 15474
15079: LD_INT 29
15081: DOUBLE
15082: EQUAL
15083: IFTRUE 15087
15085: GO 15105
15087: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15088: LD_ADDR_VAR 0 3
15092: PUSH
15093: LD_INT 13
15095: PUSH
15096: LD_INT 14
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: ST_TO_ADDR
15103: GO 15474
15105: LD_INT 31
15107: DOUBLE
15108: EQUAL
15109: IFTRUE 15113
15111: GO 15131
15113: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15114: LD_ADDR_VAR 0 3
15118: PUSH
15119: LD_INT 13
15121: PUSH
15122: LD_INT 14
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: ST_TO_ADDR
15129: GO 15474
15131: LD_INT 26
15133: DOUBLE
15134: EQUAL
15135: IFTRUE 15139
15137: GO 15157
15139: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15140: LD_ADDR_VAR 0 3
15144: PUSH
15145: LD_INT 13
15147: PUSH
15148: LD_INT 14
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: ST_TO_ADDR
15155: GO 15474
15157: LD_INT 42
15159: DOUBLE
15160: EQUAL
15161: IFTRUE 15165
15163: GO 15191
15165: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15166: LD_ADDR_VAR 0 3
15170: PUSH
15171: LD_INT 21
15173: PUSH
15174: LD_INT 22
15176: PUSH
15177: LD_INT 23
15179: PUSH
15180: LD_INT 24
15182: PUSH
15183: EMPTY
15184: LIST
15185: LIST
15186: LIST
15187: LIST
15188: ST_TO_ADDR
15189: GO 15474
15191: LD_INT 43
15193: DOUBLE
15194: EQUAL
15195: IFTRUE 15199
15197: GO 15225
15199: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15200: LD_ADDR_VAR 0 3
15204: PUSH
15205: LD_INT 21
15207: PUSH
15208: LD_INT 22
15210: PUSH
15211: LD_INT 23
15213: PUSH
15214: LD_INT 24
15216: PUSH
15217: EMPTY
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: ST_TO_ADDR
15223: GO 15474
15225: LD_INT 44
15227: DOUBLE
15228: EQUAL
15229: IFTRUE 15233
15231: GO 15259
15233: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15234: LD_ADDR_VAR 0 3
15238: PUSH
15239: LD_INT 21
15241: PUSH
15242: LD_INT 22
15244: PUSH
15245: LD_INT 23
15247: PUSH
15248: LD_INT 24
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: ST_TO_ADDR
15257: GO 15474
15259: LD_INT 45
15261: DOUBLE
15262: EQUAL
15263: IFTRUE 15267
15265: GO 15293
15267: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15268: LD_ADDR_VAR 0 3
15272: PUSH
15273: LD_INT 21
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 23
15281: PUSH
15282: LD_INT 24
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: LIST
15289: LIST
15290: ST_TO_ADDR
15291: GO 15474
15293: LD_INT 49
15295: DOUBLE
15296: EQUAL
15297: IFTRUE 15301
15299: GO 15327
15301: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15302: LD_ADDR_VAR 0 3
15306: PUSH
15307: LD_INT 21
15309: PUSH
15310: LD_INT 22
15312: PUSH
15313: LD_INT 23
15315: PUSH
15316: LD_INT 24
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: LIST
15323: LIST
15324: ST_TO_ADDR
15325: GO 15474
15327: LD_INT 51
15329: DOUBLE
15330: EQUAL
15331: IFTRUE 15335
15333: GO 15361
15335: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15336: LD_ADDR_VAR 0 3
15340: PUSH
15341: LD_INT 21
15343: PUSH
15344: LD_INT 22
15346: PUSH
15347: LD_INT 23
15349: PUSH
15350: LD_INT 24
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: ST_TO_ADDR
15359: GO 15474
15361: LD_INT 52
15363: DOUBLE
15364: EQUAL
15365: IFTRUE 15369
15367: GO 15395
15369: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15370: LD_ADDR_VAR 0 3
15374: PUSH
15375: LD_INT 21
15377: PUSH
15378: LD_INT 22
15380: PUSH
15381: LD_INT 23
15383: PUSH
15384: LD_INT 24
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: LIST
15391: LIST
15392: ST_TO_ADDR
15393: GO 15474
15395: LD_INT 53
15397: DOUBLE
15398: EQUAL
15399: IFTRUE 15403
15401: GO 15421
15403: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15404: LD_ADDR_VAR 0 3
15408: PUSH
15409: LD_INT 23
15411: PUSH
15412: LD_INT 24
15414: PUSH
15415: EMPTY
15416: LIST
15417: LIST
15418: ST_TO_ADDR
15419: GO 15474
15421: LD_INT 46
15423: DOUBLE
15424: EQUAL
15425: IFTRUE 15429
15427: GO 15447
15429: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15430: LD_ADDR_VAR 0 3
15434: PUSH
15435: LD_INT 23
15437: PUSH
15438: LD_INT 24
15440: PUSH
15441: EMPTY
15442: LIST
15443: LIST
15444: ST_TO_ADDR
15445: GO 15474
15447: LD_INT 47
15449: DOUBLE
15450: EQUAL
15451: IFTRUE 15455
15453: GO 15473
15455: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15456: LD_ADDR_VAR 0 3
15460: PUSH
15461: LD_INT 23
15463: PUSH
15464: LD_INT 24
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: ST_TO_ADDR
15471: GO 15474
15473: POP
// result := ( chassis in result ) ;
15474: LD_ADDR_VAR 0 3
15478: PUSH
15479: LD_VAR 0 1
15483: PUSH
15484: LD_VAR 0 3
15488: IN
15489: ST_TO_ADDR
// end ;
15490: LD_VAR 0 3
15494: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15495: LD_INT 0
15497: PPUSH
15498: PPUSH
15499: PPUSH
15500: PPUSH
15501: PPUSH
15502: PPUSH
15503: PPUSH
// result := array ;
15504: LD_ADDR_VAR 0 5
15508: PUSH
15509: LD_VAR 0 1
15513: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15514: LD_VAR 0 1
15518: NOT
15519: PUSH
15520: LD_VAR 0 2
15524: NOT
15525: OR
15526: PUSH
15527: LD_VAR 0 3
15531: NOT
15532: OR
15533: PUSH
15534: LD_VAR 0 2
15538: PUSH
15539: LD_VAR 0 1
15543: GREATER
15544: OR
15545: PUSH
15546: LD_VAR 0 3
15550: PUSH
15551: LD_VAR 0 1
15555: GREATER
15556: OR
15557: IFFALSE 15561
// exit ;
15559: GO 15857
// if direction then
15561: LD_VAR 0 4
15565: IFFALSE 15629
// begin d := 1 ;
15567: LD_ADDR_VAR 0 9
15571: PUSH
15572: LD_INT 1
15574: ST_TO_ADDR
// if i_from > i_to then
15575: LD_VAR 0 2
15579: PUSH
15580: LD_VAR 0 3
15584: GREATER
15585: IFFALSE 15611
// length := ( array - i_from ) + i_to else
15587: LD_ADDR_VAR 0 11
15591: PUSH
15592: LD_VAR 0 1
15596: PUSH
15597: LD_VAR 0 2
15601: MINUS
15602: PUSH
15603: LD_VAR 0 3
15607: PLUS
15608: ST_TO_ADDR
15609: GO 15627
// length := i_to - i_from ;
15611: LD_ADDR_VAR 0 11
15615: PUSH
15616: LD_VAR 0 3
15620: PUSH
15621: LD_VAR 0 2
15625: MINUS
15626: ST_TO_ADDR
// end else
15627: GO 15690
// begin d := - 1 ;
15629: LD_ADDR_VAR 0 9
15633: PUSH
15634: LD_INT 1
15636: NEG
15637: ST_TO_ADDR
// if i_from > i_to then
15638: LD_VAR 0 2
15642: PUSH
15643: LD_VAR 0 3
15647: GREATER
15648: IFFALSE 15668
// length := i_from - i_to else
15650: LD_ADDR_VAR 0 11
15654: PUSH
15655: LD_VAR 0 2
15659: PUSH
15660: LD_VAR 0 3
15664: MINUS
15665: ST_TO_ADDR
15666: GO 15690
// length := ( array - i_to ) + i_from ;
15668: LD_ADDR_VAR 0 11
15672: PUSH
15673: LD_VAR 0 1
15677: PUSH
15678: LD_VAR 0 3
15682: MINUS
15683: PUSH
15684: LD_VAR 0 2
15688: PLUS
15689: ST_TO_ADDR
// end ; if not length then
15690: LD_VAR 0 11
15694: NOT
15695: IFFALSE 15699
// exit ;
15697: GO 15857
// tmp := array ;
15699: LD_ADDR_VAR 0 10
15703: PUSH
15704: LD_VAR 0 1
15708: ST_TO_ADDR
// for i = 1 to length do
15709: LD_ADDR_VAR 0 6
15713: PUSH
15714: DOUBLE
15715: LD_INT 1
15717: DEC
15718: ST_TO_ADDR
15719: LD_VAR 0 11
15723: PUSH
15724: FOR_TO
15725: IFFALSE 15845
// begin for j = 1 to array do
15727: LD_ADDR_VAR 0 7
15731: PUSH
15732: DOUBLE
15733: LD_INT 1
15735: DEC
15736: ST_TO_ADDR
15737: LD_VAR 0 1
15741: PUSH
15742: FOR_TO
15743: IFFALSE 15831
// begin k := j + d ;
15745: LD_ADDR_VAR 0 8
15749: PUSH
15750: LD_VAR 0 7
15754: PUSH
15755: LD_VAR 0 9
15759: PLUS
15760: ST_TO_ADDR
// if k > array then
15761: LD_VAR 0 8
15765: PUSH
15766: LD_VAR 0 1
15770: GREATER
15771: IFFALSE 15781
// k := 1 ;
15773: LD_ADDR_VAR 0 8
15777: PUSH
15778: LD_INT 1
15780: ST_TO_ADDR
// if not k then
15781: LD_VAR 0 8
15785: NOT
15786: IFFALSE 15798
// k := array ;
15788: LD_ADDR_VAR 0 8
15792: PUSH
15793: LD_VAR 0 1
15797: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15798: LD_ADDR_VAR 0 10
15802: PUSH
15803: LD_VAR 0 10
15807: PPUSH
15808: LD_VAR 0 8
15812: PPUSH
15813: LD_VAR 0 1
15817: PUSH
15818: LD_VAR 0 7
15822: ARRAY
15823: PPUSH
15824: CALL_OW 1
15828: ST_TO_ADDR
// end ;
15829: GO 15742
15831: POP
15832: POP
// array := tmp ;
15833: LD_ADDR_VAR 0 1
15837: PUSH
15838: LD_VAR 0 10
15842: ST_TO_ADDR
// end ;
15843: GO 15724
15845: POP
15846: POP
// result := array ;
15847: LD_ADDR_VAR 0 5
15851: PUSH
15852: LD_VAR 0 1
15856: ST_TO_ADDR
// end ;
15857: LD_VAR 0 5
15861: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15862: LD_INT 0
15864: PPUSH
15865: PPUSH
// result := 0 ;
15866: LD_ADDR_VAR 0 3
15870: PUSH
15871: LD_INT 0
15873: ST_TO_ADDR
// if not array or not value in array then
15874: LD_VAR 0 1
15878: NOT
15879: PUSH
15880: LD_VAR 0 2
15884: PUSH
15885: LD_VAR 0 1
15889: IN
15890: NOT
15891: OR
15892: IFFALSE 15896
// exit ;
15894: GO 15950
// for i = 1 to array do
15896: LD_ADDR_VAR 0 4
15900: PUSH
15901: DOUBLE
15902: LD_INT 1
15904: DEC
15905: ST_TO_ADDR
15906: LD_VAR 0 1
15910: PUSH
15911: FOR_TO
15912: IFFALSE 15948
// if value = array [ i ] then
15914: LD_VAR 0 2
15918: PUSH
15919: LD_VAR 0 1
15923: PUSH
15924: LD_VAR 0 4
15928: ARRAY
15929: EQUAL
15930: IFFALSE 15946
// begin result := i ;
15932: LD_ADDR_VAR 0 3
15936: PUSH
15937: LD_VAR 0 4
15941: ST_TO_ADDR
// exit ;
15942: POP
15943: POP
15944: GO 15950
// end ;
15946: GO 15911
15948: POP
15949: POP
// end ;
15950: LD_VAR 0 3
15954: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15955: LD_INT 0
15957: PPUSH
// vc_chassis := chassis ;
15958: LD_ADDR_OWVAR 37
15962: PUSH
15963: LD_VAR 0 1
15967: ST_TO_ADDR
// vc_engine := engine ;
15968: LD_ADDR_OWVAR 39
15972: PUSH
15973: LD_VAR 0 2
15977: ST_TO_ADDR
// vc_control := control ;
15978: LD_ADDR_OWVAR 38
15982: PUSH
15983: LD_VAR 0 3
15987: ST_TO_ADDR
// vc_weapon := weapon ;
15988: LD_ADDR_OWVAR 40
15992: PUSH
15993: LD_VAR 0 4
15997: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15998: LD_ADDR_OWVAR 41
16002: PUSH
16003: LD_VAR 0 5
16007: ST_TO_ADDR
// end ;
16008: LD_VAR 0 6
16012: RET
// export function WantPlant ( unit ) ; var task ; begin
16013: LD_INT 0
16015: PPUSH
16016: PPUSH
// result := false ;
16017: LD_ADDR_VAR 0 2
16021: PUSH
16022: LD_INT 0
16024: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16025: LD_ADDR_VAR 0 3
16029: PUSH
16030: LD_VAR 0 1
16034: PPUSH
16035: CALL_OW 437
16039: ST_TO_ADDR
// if task then
16040: LD_VAR 0 3
16044: IFFALSE 16072
// if task [ 1 ] [ 1 ] = p then
16046: LD_VAR 0 3
16050: PUSH
16051: LD_INT 1
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PUSH
16059: LD_STRING p
16061: EQUAL
16062: IFFALSE 16072
// result := true ;
16064: LD_ADDR_VAR 0 2
16068: PUSH
16069: LD_INT 1
16071: ST_TO_ADDR
// end ;
16072: LD_VAR 0 2
16076: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16077: LD_INT 0
16079: PPUSH
16080: PPUSH
16081: PPUSH
16082: PPUSH
// if pos < 1 then
16083: LD_VAR 0 2
16087: PUSH
16088: LD_INT 1
16090: LESS
16091: IFFALSE 16095
// exit ;
16093: GO 16398
// if pos = 1 then
16095: LD_VAR 0 2
16099: PUSH
16100: LD_INT 1
16102: EQUAL
16103: IFFALSE 16136
// result := Replace ( arr , pos [ 1 ] , value ) else
16105: LD_ADDR_VAR 0 4
16109: PUSH
16110: LD_VAR 0 1
16114: PPUSH
16115: LD_VAR 0 2
16119: PUSH
16120: LD_INT 1
16122: ARRAY
16123: PPUSH
16124: LD_VAR 0 3
16128: PPUSH
16129: CALL_OW 1
16133: ST_TO_ADDR
16134: GO 16398
// begin tmp := arr ;
16136: LD_ADDR_VAR 0 6
16140: PUSH
16141: LD_VAR 0 1
16145: ST_TO_ADDR
// s_arr := [ tmp ] ;
16146: LD_ADDR_VAR 0 7
16150: PUSH
16151: LD_VAR 0 6
16155: PUSH
16156: EMPTY
16157: LIST
16158: ST_TO_ADDR
// for i = 1 to pos - 1 do
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: DOUBLE
16165: LD_INT 1
16167: DEC
16168: ST_TO_ADDR
16169: LD_VAR 0 2
16173: PUSH
16174: LD_INT 1
16176: MINUS
16177: PUSH
16178: FOR_TO
16179: IFFALSE 16224
// begin tmp := tmp [ pos [ i ] ] ;
16181: LD_ADDR_VAR 0 6
16185: PUSH
16186: LD_VAR 0 6
16190: PUSH
16191: LD_VAR 0 2
16195: PUSH
16196: LD_VAR 0 5
16200: ARRAY
16201: ARRAY
16202: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16203: LD_ADDR_VAR 0 7
16207: PUSH
16208: LD_VAR 0 7
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: EMPTY
16219: LIST
16220: ADD
16221: ST_TO_ADDR
// end ;
16222: GO 16178
16224: POP
16225: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16226: LD_ADDR_VAR 0 6
16230: PUSH
16231: LD_VAR 0 6
16235: PPUSH
16236: LD_VAR 0 2
16240: PUSH
16241: LD_VAR 0 2
16245: ARRAY
16246: PPUSH
16247: LD_VAR 0 3
16251: PPUSH
16252: CALL_OW 1
16256: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16257: LD_ADDR_VAR 0 7
16261: PUSH
16262: LD_VAR 0 7
16266: PPUSH
16267: LD_VAR 0 7
16271: PPUSH
16272: LD_VAR 0 6
16276: PPUSH
16277: CALL_OW 1
16281: ST_TO_ADDR
// for i = s_arr downto 2 do
16282: LD_ADDR_VAR 0 5
16286: PUSH
16287: DOUBLE
16288: LD_VAR 0 7
16292: INC
16293: ST_TO_ADDR
16294: LD_INT 2
16296: PUSH
16297: FOR_DOWNTO
16298: IFFALSE 16382
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16300: LD_ADDR_VAR 0 6
16304: PUSH
16305: LD_VAR 0 7
16309: PUSH
16310: LD_VAR 0 5
16314: PUSH
16315: LD_INT 1
16317: MINUS
16318: ARRAY
16319: PPUSH
16320: LD_VAR 0 2
16324: PUSH
16325: LD_VAR 0 5
16329: PUSH
16330: LD_INT 1
16332: MINUS
16333: ARRAY
16334: PPUSH
16335: LD_VAR 0 7
16339: PUSH
16340: LD_VAR 0 5
16344: ARRAY
16345: PPUSH
16346: CALL_OW 1
16350: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16351: LD_ADDR_VAR 0 7
16355: PUSH
16356: LD_VAR 0 7
16360: PPUSH
16361: LD_VAR 0 5
16365: PUSH
16366: LD_INT 1
16368: MINUS
16369: PPUSH
16370: LD_VAR 0 6
16374: PPUSH
16375: CALL_OW 1
16379: ST_TO_ADDR
// end ;
16380: GO 16297
16382: POP
16383: POP
// result := s_arr [ 1 ] ;
16384: LD_ADDR_VAR 0 4
16388: PUSH
16389: LD_VAR 0 7
16393: PUSH
16394: LD_INT 1
16396: ARRAY
16397: ST_TO_ADDR
// end ; end ;
16398: LD_VAR 0 4
16402: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16403: LD_INT 0
16405: PPUSH
16406: PPUSH
// if not list then
16407: LD_VAR 0 1
16411: NOT
16412: IFFALSE 16416
// exit ;
16414: GO 16507
// i := list [ pos1 ] ;
16416: LD_ADDR_VAR 0 5
16420: PUSH
16421: LD_VAR 0 1
16425: PUSH
16426: LD_VAR 0 2
16430: ARRAY
16431: ST_TO_ADDR
// if not i then
16432: LD_VAR 0 5
16436: NOT
16437: IFFALSE 16441
// exit ;
16439: GO 16507
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16441: LD_ADDR_VAR 0 1
16445: PUSH
16446: LD_VAR 0 1
16450: PPUSH
16451: LD_VAR 0 2
16455: PPUSH
16456: LD_VAR 0 1
16460: PUSH
16461: LD_VAR 0 3
16465: ARRAY
16466: PPUSH
16467: CALL_OW 1
16471: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16472: LD_ADDR_VAR 0 1
16476: PUSH
16477: LD_VAR 0 1
16481: PPUSH
16482: LD_VAR 0 3
16486: PPUSH
16487: LD_VAR 0 5
16491: PPUSH
16492: CALL_OW 1
16496: ST_TO_ADDR
// result := list ;
16497: LD_ADDR_VAR 0 4
16501: PUSH
16502: LD_VAR 0 1
16506: ST_TO_ADDR
// end ;
16507: LD_VAR 0 4
16511: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16512: LD_INT 0
16514: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16515: LD_ADDR_VAR 0 5
16519: PUSH
16520: LD_VAR 0 1
16524: PPUSH
16525: CALL_OW 250
16529: PPUSH
16530: LD_VAR 0 1
16534: PPUSH
16535: CALL_OW 251
16539: PPUSH
16540: LD_VAR 0 2
16544: PPUSH
16545: LD_VAR 0 3
16549: PPUSH
16550: LD_VAR 0 4
16554: PPUSH
16555: CALL 16933 0 5
16559: ST_TO_ADDR
// end ;
16560: LD_VAR 0 5
16564: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
16565: LD_INT 0
16567: PPUSH
16568: PPUSH
16569: PPUSH
16570: PPUSH
// if not list or not unit then
16571: LD_VAR 0 2
16575: NOT
16576: PUSH
16577: LD_VAR 0 1
16581: NOT
16582: OR
16583: IFFALSE 16587
// exit ;
16585: GO 16928
// result := [ ] ;
16587: LD_ADDR_VAR 0 5
16591: PUSH
16592: EMPTY
16593: ST_TO_ADDR
// for i in list do
16594: LD_ADDR_VAR 0 6
16598: PUSH
16599: LD_VAR 0 2
16603: PUSH
16604: FOR_IN
16605: IFFALSE 16823
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
16607: LD_ADDR_VAR 0 8
16611: PUSH
16612: LD_VAR 0 1
16616: PPUSH
16617: LD_VAR 0 6
16621: PUSH
16622: LD_INT 1
16624: ARRAY
16625: PPUSH
16626: LD_VAR 0 6
16630: PUSH
16631: LD_INT 2
16633: ARRAY
16634: PPUSH
16635: CALL_OW 297
16639: ST_TO_ADDR
// if not Count ( result ) then
16640: LD_VAR 0 5
16644: PPUSH
16645: CALL 13217 0 1
16649: NOT
16650: IFFALSE 16683
// begin result := Join ( result , [ i , tmp ] ) ;
16652: LD_ADDR_VAR 0 5
16656: PUSH
16657: LD_VAR 0 5
16661: PPUSH
16662: LD_VAR 0 6
16666: PUSH
16667: LD_VAR 0 8
16671: PUSH
16672: EMPTY
16673: LIST
16674: LIST
16675: PPUSH
16676: CALL 48806 0 2
16680: ST_TO_ADDR
// continue ;
16681: GO 16604
// end ; if result [ result ] [ 2 ] <= tmp then
16683: LD_VAR 0 5
16687: PUSH
16688: LD_VAR 0 5
16692: ARRAY
16693: PUSH
16694: LD_INT 2
16696: ARRAY
16697: PUSH
16698: LD_VAR 0 8
16702: LESSEQUAL
16703: IFFALSE 16736
// result := Join ( result , [ i , tmp ] ) else
16705: LD_ADDR_VAR 0 5
16709: PUSH
16710: LD_VAR 0 5
16714: PPUSH
16715: LD_VAR 0 6
16719: PUSH
16720: LD_VAR 0 8
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: PPUSH
16729: CALL 48806 0 2
16733: ST_TO_ADDR
16734: GO 16821
// begin for j := 1 to Count ( result ) do
16736: LD_ADDR_VAR 0 7
16740: PUSH
16741: DOUBLE
16742: LD_INT 1
16744: DEC
16745: ST_TO_ADDR
16746: LD_VAR 0 5
16750: PPUSH
16751: CALL 13217 0 1
16755: PUSH
16756: FOR_TO
16757: IFFALSE 16819
// begin if tmp < result [ j ] [ 2 ] then
16759: LD_VAR 0 8
16763: PUSH
16764: LD_VAR 0 5
16768: PUSH
16769: LD_VAR 0 7
16773: ARRAY
16774: PUSH
16775: LD_INT 2
16777: ARRAY
16778: LESS
16779: IFFALSE 16817
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16781: LD_ADDR_VAR 0 5
16785: PUSH
16786: LD_VAR 0 5
16790: PPUSH
16791: LD_VAR 0 7
16795: PPUSH
16796: LD_VAR 0 6
16800: PUSH
16801: LD_VAR 0 8
16805: PUSH
16806: EMPTY
16807: LIST
16808: LIST
16809: PPUSH
16810: CALL_OW 2
16814: ST_TO_ADDR
// break ;
16815: GO 16819
// end ; end ;
16817: GO 16756
16819: POP
16820: POP
// end ; end ;
16821: GO 16604
16823: POP
16824: POP
// if result and not asc then
16825: LD_VAR 0 5
16829: PUSH
16830: LD_VAR 0 3
16834: NOT
16835: AND
16836: IFFALSE 16853
// result := ReverseArray ( result ) ;
16838: LD_ADDR_VAR 0 5
16842: PUSH
16843: LD_VAR 0 5
16847: PPUSH
16848: CALL 44093 0 1
16852: ST_TO_ADDR
// tmp := [ ] ;
16853: LD_ADDR_VAR 0 8
16857: PUSH
16858: EMPTY
16859: ST_TO_ADDR
// if mode then
16860: LD_VAR 0 4
16864: IFFALSE 16928
// begin for i := 1 to result do
16866: LD_ADDR_VAR 0 6
16870: PUSH
16871: DOUBLE
16872: LD_INT 1
16874: DEC
16875: ST_TO_ADDR
16876: LD_VAR 0 5
16880: PUSH
16881: FOR_TO
16882: IFFALSE 16916
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
16884: LD_ADDR_VAR 0 8
16888: PUSH
16889: LD_VAR 0 8
16893: PPUSH
16894: LD_VAR 0 5
16898: PUSH
16899: LD_VAR 0 6
16903: ARRAY
16904: PUSH
16905: LD_INT 1
16907: ARRAY
16908: PPUSH
16909: CALL 48806 0 2
16913: ST_TO_ADDR
16914: GO 16881
16916: POP
16917: POP
// result := tmp ;
16918: LD_ADDR_VAR 0 5
16922: PUSH
16923: LD_VAR 0 8
16927: ST_TO_ADDR
// end ; end ;
16928: LD_VAR 0 5
16932: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16933: LD_INT 0
16935: PPUSH
16936: PPUSH
16937: PPUSH
16938: PPUSH
// if not list then
16939: LD_VAR 0 3
16943: NOT
16944: IFFALSE 16948
// exit ;
16946: GO 17336
// result := [ ] ;
16948: LD_ADDR_VAR 0 6
16952: PUSH
16953: EMPTY
16954: ST_TO_ADDR
// for i in list do
16955: LD_ADDR_VAR 0 7
16959: PUSH
16960: LD_VAR 0 3
16964: PUSH
16965: FOR_IN
16966: IFFALSE 17168
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16968: LD_ADDR_VAR 0 9
16972: PUSH
16973: LD_VAR 0 7
16977: PPUSH
16978: LD_VAR 0 1
16982: PPUSH
16983: LD_VAR 0 2
16987: PPUSH
16988: CALL_OW 297
16992: ST_TO_ADDR
// if not result then
16993: LD_VAR 0 6
16997: NOT
16998: IFFALSE 17024
// result := [ [ i , tmp ] ] else
17000: LD_ADDR_VAR 0 6
17004: PUSH
17005: LD_VAR 0 7
17009: PUSH
17010: LD_VAR 0 9
17014: PUSH
17015: EMPTY
17016: LIST
17017: LIST
17018: PUSH
17019: EMPTY
17020: LIST
17021: ST_TO_ADDR
17022: GO 17166
// begin if result [ result ] [ 2 ] < tmp then
17024: LD_VAR 0 6
17028: PUSH
17029: LD_VAR 0 6
17033: ARRAY
17034: PUSH
17035: LD_INT 2
17037: ARRAY
17038: PUSH
17039: LD_VAR 0 9
17043: LESS
17044: IFFALSE 17086
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
17046: LD_ADDR_VAR 0 6
17050: PUSH
17051: LD_VAR 0 6
17055: PPUSH
17056: LD_VAR 0 6
17060: PUSH
17061: LD_INT 1
17063: PLUS
17064: PPUSH
17065: LD_VAR 0 7
17069: PUSH
17070: LD_VAR 0 9
17074: PUSH
17075: EMPTY
17076: LIST
17077: LIST
17078: PPUSH
17079: CALL_OW 2
17083: ST_TO_ADDR
17084: GO 17166
// for j = 1 to result do
17086: LD_ADDR_VAR 0 8
17090: PUSH
17091: DOUBLE
17092: LD_INT 1
17094: DEC
17095: ST_TO_ADDR
17096: LD_VAR 0 6
17100: PUSH
17101: FOR_TO
17102: IFFALSE 17164
// begin if tmp < result [ j ] [ 2 ] then
17104: LD_VAR 0 9
17108: PUSH
17109: LD_VAR 0 6
17113: PUSH
17114: LD_VAR 0 8
17118: ARRAY
17119: PUSH
17120: LD_INT 2
17122: ARRAY
17123: LESS
17124: IFFALSE 17162
// begin result := Insert ( result , j , [ i , tmp ] ) ;
17126: LD_ADDR_VAR 0 6
17130: PUSH
17131: LD_VAR 0 6
17135: PPUSH
17136: LD_VAR 0 8
17140: PPUSH
17141: LD_VAR 0 7
17145: PUSH
17146: LD_VAR 0 9
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: PPUSH
17155: CALL_OW 2
17159: ST_TO_ADDR
// break ;
17160: GO 17164
// end ; end ;
17162: GO 17101
17164: POP
17165: POP
// end ; end ;
17166: GO 16965
17168: POP
17169: POP
// if result and not asc then
17170: LD_VAR 0 6
17174: PUSH
17175: LD_VAR 0 4
17179: NOT
17180: AND
17181: IFFALSE 17256
// begin tmp := result ;
17183: LD_ADDR_VAR 0 9
17187: PUSH
17188: LD_VAR 0 6
17192: ST_TO_ADDR
// for i = tmp downto 1 do
17193: LD_ADDR_VAR 0 7
17197: PUSH
17198: DOUBLE
17199: LD_VAR 0 9
17203: INC
17204: ST_TO_ADDR
17205: LD_INT 1
17207: PUSH
17208: FOR_DOWNTO
17209: IFFALSE 17254
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
17211: LD_ADDR_VAR 0 6
17215: PUSH
17216: LD_VAR 0 6
17220: PPUSH
17221: LD_VAR 0 9
17225: PUSH
17226: LD_VAR 0 7
17230: MINUS
17231: PUSH
17232: LD_INT 1
17234: PLUS
17235: PPUSH
17236: LD_VAR 0 9
17240: PUSH
17241: LD_VAR 0 7
17245: ARRAY
17246: PPUSH
17247: CALL_OW 1
17251: ST_TO_ADDR
17252: GO 17208
17254: POP
17255: POP
// end ; tmp := [ ] ;
17256: LD_ADDR_VAR 0 9
17260: PUSH
17261: EMPTY
17262: ST_TO_ADDR
// if mode then
17263: LD_VAR 0 5
17267: IFFALSE 17336
// begin for i = 1 to result do
17269: LD_ADDR_VAR 0 7
17273: PUSH
17274: DOUBLE
17275: LD_INT 1
17277: DEC
17278: ST_TO_ADDR
17279: LD_VAR 0 6
17283: PUSH
17284: FOR_TO
17285: IFFALSE 17324
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
17287: LD_ADDR_VAR 0 9
17291: PUSH
17292: LD_VAR 0 9
17296: PPUSH
17297: LD_VAR 0 7
17301: PPUSH
17302: LD_VAR 0 6
17306: PUSH
17307: LD_VAR 0 7
17311: ARRAY
17312: PUSH
17313: LD_INT 1
17315: ARRAY
17316: PPUSH
17317: CALL_OW 1
17321: ST_TO_ADDR
17322: GO 17284
17324: POP
17325: POP
// result := tmp ;
17326: LD_ADDR_VAR 0 6
17330: PUSH
17331: LD_VAR 0 9
17335: ST_TO_ADDR
// end ; end ;
17336: LD_VAR 0 6
17340: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17341: LD_INT 0
17343: PPUSH
17344: PPUSH
17345: PPUSH
17346: PPUSH
17347: PPUSH
17348: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17349: LD_ADDR_VAR 0 5
17353: PUSH
17354: LD_INT 0
17356: PUSH
17357: LD_INT 0
17359: PUSH
17360: LD_INT 0
17362: PUSH
17363: EMPTY
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: LIST
17369: LIST
17370: ST_TO_ADDR
// if not x or not y then
17371: LD_VAR 0 2
17375: NOT
17376: PUSH
17377: LD_VAR 0 3
17381: NOT
17382: OR
17383: IFFALSE 17387
// exit ;
17385: GO 19037
// if not range then
17387: LD_VAR 0 4
17391: NOT
17392: IFFALSE 17402
// range := 10 ;
17394: LD_ADDR_VAR 0 4
17398: PUSH
17399: LD_INT 10
17401: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17402: LD_ADDR_VAR 0 8
17406: PUSH
17407: LD_INT 81
17409: PUSH
17410: LD_VAR 0 1
17414: PUSH
17415: EMPTY
17416: LIST
17417: LIST
17418: PUSH
17419: LD_INT 92
17421: PUSH
17422: LD_VAR 0 2
17426: PUSH
17427: LD_VAR 0 3
17431: PUSH
17432: LD_VAR 0 4
17436: PUSH
17437: EMPTY
17438: LIST
17439: LIST
17440: LIST
17441: LIST
17442: PUSH
17443: LD_INT 3
17445: PUSH
17446: LD_INT 21
17448: PUSH
17449: LD_INT 3
17451: PUSH
17452: EMPTY
17453: LIST
17454: LIST
17455: PUSH
17456: EMPTY
17457: LIST
17458: LIST
17459: PUSH
17460: EMPTY
17461: LIST
17462: LIST
17463: LIST
17464: PPUSH
17465: CALL_OW 69
17469: ST_TO_ADDR
// if not tmp then
17470: LD_VAR 0 8
17474: NOT
17475: IFFALSE 17479
// exit ;
17477: GO 19037
// for i in tmp do
17479: LD_ADDR_VAR 0 6
17483: PUSH
17484: LD_VAR 0 8
17488: PUSH
17489: FOR_IN
17490: IFFALSE 19012
// begin points := [ 0 , 0 , 0 ] ;
17492: LD_ADDR_VAR 0 9
17496: PUSH
17497: LD_INT 0
17499: PUSH
17500: LD_INT 0
17502: PUSH
17503: LD_INT 0
17505: PUSH
17506: EMPTY
17507: LIST
17508: LIST
17509: LIST
17510: ST_TO_ADDR
// bpoints := 1 ;
17511: LD_ADDR_VAR 0 10
17515: PUSH
17516: LD_INT 1
17518: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17519: LD_VAR 0 6
17523: PPUSH
17524: CALL_OW 247
17528: PUSH
17529: LD_INT 1
17531: DOUBLE
17532: EQUAL
17533: IFTRUE 17537
17535: GO 18115
17537: POP
// begin if GetClass ( i ) = 1 then
17538: LD_VAR 0 6
17542: PPUSH
17543: CALL_OW 257
17547: PUSH
17548: LD_INT 1
17550: EQUAL
17551: IFFALSE 17572
// points := [ 10 , 5 , 3 ] ;
17553: LD_ADDR_VAR 0 9
17557: PUSH
17558: LD_INT 10
17560: PUSH
17561: LD_INT 5
17563: PUSH
17564: LD_INT 3
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: LIST
17571: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17572: LD_VAR 0 6
17576: PPUSH
17577: CALL_OW 257
17581: PUSH
17582: LD_INT 2
17584: PUSH
17585: LD_INT 3
17587: PUSH
17588: LD_INT 4
17590: PUSH
17591: EMPTY
17592: LIST
17593: LIST
17594: LIST
17595: IN
17596: IFFALSE 17617
// points := [ 3 , 2 , 1 ] ;
17598: LD_ADDR_VAR 0 9
17602: PUSH
17603: LD_INT 3
17605: PUSH
17606: LD_INT 2
17608: PUSH
17609: LD_INT 1
17611: PUSH
17612: EMPTY
17613: LIST
17614: LIST
17615: LIST
17616: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17617: LD_VAR 0 6
17621: PPUSH
17622: CALL_OW 257
17626: PUSH
17627: LD_INT 5
17629: EQUAL
17630: IFFALSE 17651
// points := [ 130 , 5 , 2 ] ;
17632: LD_ADDR_VAR 0 9
17636: PUSH
17637: LD_INT 130
17639: PUSH
17640: LD_INT 5
17642: PUSH
17643: LD_INT 2
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: LIST
17650: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17651: LD_VAR 0 6
17655: PPUSH
17656: CALL_OW 257
17660: PUSH
17661: LD_INT 8
17663: EQUAL
17664: IFFALSE 17685
// points := [ 35 , 35 , 30 ] ;
17666: LD_ADDR_VAR 0 9
17670: PUSH
17671: LD_INT 35
17673: PUSH
17674: LD_INT 35
17676: PUSH
17677: LD_INT 30
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: LIST
17684: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17685: LD_VAR 0 6
17689: PPUSH
17690: CALL_OW 257
17694: PUSH
17695: LD_INT 9
17697: EQUAL
17698: IFFALSE 17719
// points := [ 20 , 55 , 40 ] ;
17700: LD_ADDR_VAR 0 9
17704: PUSH
17705: LD_INT 20
17707: PUSH
17708: LD_INT 55
17710: PUSH
17711: LD_INT 40
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: LIST
17718: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17719: LD_VAR 0 6
17723: PPUSH
17724: CALL_OW 257
17728: PUSH
17729: LD_INT 12
17731: PUSH
17732: LD_INT 16
17734: PUSH
17735: EMPTY
17736: LIST
17737: LIST
17738: IN
17739: IFFALSE 17760
// points := [ 5 , 3 , 2 ] ;
17741: LD_ADDR_VAR 0 9
17745: PUSH
17746: LD_INT 5
17748: PUSH
17749: LD_INT 3
17751: PUSH
17752: LD_INT 2
17754: PUSH
17755: EMPTY
17756: LIST
17757: LIST
17758: LIST
17759: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17760: LD_VAR 0 6
17764: PPUSH
17765: CALL_OW 257
17769: PUSH
17770: LD_INT 17
17772: EQUAL
17773: IFFALSE 17794
// points := [ 100 , 50 , 75 ] ;
17775: LD_ADDR_VAR 0 9
17779: PUSH
17780: LD_INT 100
17782: PUSH
17783: LD_INT 50
17785: PUSH
17786: LD_INT 75
17788: PUSH
17789: EMPTY
17790: LIST
17791: LIST
17792: LIST
17793: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17794: LD_VAR 0 6
17798: PPUSH
17799: CALL_OW 257
17803: PUSH
17804: LD_INT 15
17806: EQUAL
17807: IFFALSE 17828
// points := [ 10 , 5 , 3 ] ;
17809: LD_ADDR_VAR 0 9
17813: PUSH
17814: LD_INT 10
17816: PUSH
17817: LD_INT 5
17819: PUSH
17820: LD_INT 3
17822: PUSH
17823: EMPTY
17824: LIST
17825: LIST
17826: LIST
17827: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17828: LD_VAR 0 6
17832: PPUSH
17833: CALL_OW 257
17837: PUSH
17838: LD_INT 14
17840: EQUAL
17841: IFFALSE 17862
// points := [ 10 , 0 , 0 ] ;
17843: LD_ADDR_VAR 0 9
17847: PUSH
17848: LD_INT 10
17850: PUSH
17851: LD_INT 0
17853: PUSH
17854: LD_INT 0
17856: PUSH
17857: EMPTY
17858: LIST
17859: LIST
17860: LIST
17861: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17862: LD_VAR 0 6
17866: PPUSH
17867: CALL_OW 257
17871: PUSH
17872: LD_INT 11
17874: EQUAL
17875: IFFALSE 17896
// points := [ 30 , 10 , 5 ] ;
17877: LD_ADDR_VAR 0 9
17881: PUSH
17882: LD_INT 30
17884: PUSH
17885: LD_INT 10
17887: PUSH
17888: LD_INT 5
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: LIST
17895: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17896: LD_VAR 0 1
17900: PPUSH
17901: LD_INT 5
17903: PPUSH
17904: CALL_OW 321
17908: PUSH
17909: LD_INT 2
17911: EQUAL
17912: IFFALSE 17929
// bpoints := bpoints * 1.8 ;
17914: LD_ADDR_VAR 0 10
17918: PUSH
17919: LD_VAR 0 10
17923: PUSH
17924: LD_REAL  1.80000000000000E+0000
17927: MUL
17928: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17929: LD_VAR 0 6
17933: PPUSH
17934: CALL_OW 257
17938: PUSH
17939: LD_INT 1
17941: PUSH
17942: LD_INT 2
17944: PUSH
17945: LD_INT 3
17947: PUSH
17948: LD_INT 4
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: LIST
17955: LIST
17956: IN
17957: PUSH
17958: LD_VAR 0 1
17962: PPUSH
17963: LD_INT 51
17965: PPUSH
17966: CALL_OW 321
17970: PUSH
17971: LD_INT 2
17973: EQUAL
17974: AND
17975: IFFALSE 17992
// bpoints := bpoints * 1.2 ;
17977: LD_ADDR_VAR 0 10
17981: PUSH
17982: LD_VAR 0 10
17986: PUSH
17987: LD_REAL  1.20000000000000E+0000
17990: MUL
17991: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17992: LD_VAR 0 6
17996: PPUSH
17997: CALL_OW 257
18001: PUSH
18002: LD_INT 5
18004: PUSH
18005: LD_INT 7
18007: PUSH
18008: LD_INT 9
18010: PUSH
18011: EMPTY
18012: LIST
18013: LIST
18014: LIST
18015: IN
18016: PUSH
18017: LD_VAR 0 1
18021: PPUSH
18022: LD_INT 52
18024: PPUSH
18025: CALL_OW 321
18029: PUSH
18030: LD_INT 2
18032: EQUAL
18033: AND
18034: IFFALSE 18051
// bpoints := bpoints * 1.5 ;
18036: LD_ADDR_VAR 0 10
18040: PUSH
18041: LD_VAR 0 10
18045: PUSH
18046: LD_REAL  1.50000000000000E+0000
18049: MUL
18050: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
18051: LD_VAR 0 1
18055: PPUSH
18056: LD_INT 66
18058: PPUSH
18059: CALL_OW 321
18063: PUSH
18064: LD_INT 2
18066: EQUAL
18067: IFFALSE 18084
// bpoints := bpoints * 1.1 ;
18069: LD_ADDR_VAR 0 10
18073: PUSH
18074: LD_VAR 0 10
18078: PUSH
18079: LD_REAL  1.10000000000000E+0000
18082: MUL
18083: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
18084: LD_ADDR_VAR 0 10
18088: PUSH
18089: LD_VAR 0 10
18093: PUSH
18094: LD_VAR 0 6
18098: PPUSH
18099: LD_INT 1
18101: PPUSH
18102: CALL_OW 259
18106: PUSH
18107: LD_REAL  1.15000000000000E+0000
18110: MUL
18111: MUL
18112: ST_TO_ADDR
// end ; unit_vehicle :
18113: GO 18941
18115: LD_INT 2
18117: DOUBLE
18118: EQUAL
18119: IFTRUE 18123
18121: GO 18929
18123: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
18124: LD_VAR 0 6
18128: PPUSH
18129: CALL_OW 264
18133: PUSH
18134: LD_INT 2
18136: PUSH
18137: LD_INT 42
18139: PUSH
18140: LD_INT 24
18142: PUSH
18143: EMPTY
18144: LIST
18145: LIST
18146: LIST
18147: IN
18148: IFFALSE 18169
// points := [ 25 , 5 , 3 ] ;
18150: LD_ADDR_VAR 0 9
18154: PUSH
18155: LD_INT 25
18157: PUSH
18158: LD_INT 5
18160: PUSH
18161: LD_INT 3
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: LIST
18168: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
18169: LD_VAR 0 6
18173: PPUSH
18174: CALL_OW 264
18178: PUSH
18179: LD_INT 4
18181: PUSH
18182: LD_INT 43
18184: PUSH
18185: LD_INT 25
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: LIST
18192: IN
18193: IFFALSE 18214
// points := [ 40 , 15 , 5 ] ;
18195: LD_ADDR_VAR 0 9
18199: PUSH
18200: LD_INT 40
18202: PUSH
18203: LD_INT 15
18205: PUSH
18206: LD_INT 5
18208: PUSH
18209: EMPTY
18210: LIST
18211: LIST
18212: LIST
18213: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
18214: LD_VAR 0 6
18218: PPUSH
18219: CALL_OW 264
18223: PUSH
18224: LD_INT 3
18226: PUSH
18227: LD_INT 23
18229: PUSH
18230: EMPTY
18231: LIST
18232: LIST
18233: IN
18234: IFFALSE 18255
// points := [ 7 , 25 , 8 ] ;
18236: LD_ADDR_VAR 0 9
18240: PUSH
18241: LD_INT 7
18243: PUSH
18244: LD_INT 25
18246: PUSH
18247: LD_INT 8
18249: PUSH
18250: EMPTY
18251: LIST
18252: LIST
18253: LIST
18254: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
18255: LD_VAR 0 6
18259: PPUSH
18260: CALL_OW 264
18264: PUSH
18265: LD_INT 5
18267: PUSH
18268: LD_INT 27
18270: PUSH
18271: LD_INT 44
18273: PUSH
18274: EMPTY
18275: LIST
18276: LIST
18277: LIST
18278: IN
18279: IFFALSE 18300
// points := [ 14 , 50 , 16 ] ;
18281: LD_ADDR_VAR 0 9
18285: PUSH
18286: LD_INT 14
18288: PUSH
18289: LD_INT 50
18291: PUSH
18292: LD_INT 16
18294: PUSH
18295: EMPTY
18296: LIST
18297: LIST
18298: LIST
18299: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18300: LD_VAR 0 6
18304: PPUSH
18305: CALL_OW 264
18309: PUSH
18310: LD_INT 6
18312: PUSH
18313: LD_INT 46
18315: PUSH
18316: EMPTY
18317: LIST
18318: LIST
18319: IN
18320: IFFALSE 18341
// points := [ 32 , 120 , 70 ] ;
18322: LD_ADDR_VAR 0 9
18326: PUSH
18327: LD_INT 32
18329: PUSH
18330: LD_INT 120
18332: PUSH
18333: LD_INT 70
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18341: LD_VAR 0 6
18345: PPUSH
18346: CALL_OW 264
18350: PUSH
18351: LD_INT 7
18353: PUSH
18354: LD_INT 28
18356: PUSH
18357: LD_INT 45
18359: PUSH
18360: LD_INT 92
18362: PUSH
18363: EMPTY
18364: LIST
18365: LIST
18366: LIST
18367: LIST
18368: IN
18369: IFFALSE 18390
// points := [ 35 , 20 , 45 ] ;
18371: LD_ADDR_VAR 0 9
18375: PUSH
18376: LD_INT 35
18378: PUSH
18379: LD_INT 20
18381: PUSH
18382: LD_INT 45
18384: PUSH
18385: EMPTY
18386: LIST
18387: LIST
18388: LIST
18389: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18390: LD_VAR 0 6
18394: PPUSH
18395: CALL_OW 264
18399: PUSH
18400: LD_INT 47
18402: PUSH
18403: EMPTY
18404: LIST
18405: IN
18406: IFFALSE 18427
// points := [ 67 , 45 , 75 ] ;
18408: LD_ADDR_VAR 0 9
18412: PUSH
18413: LD_INT 67
18415: PUSH
18416: LD_INT 45
18418: PUSH
18419: LD_INT 75
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: LIST
18426: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18427: LD_VAR 0 6
18431: PPUSH
18432: CALL_OW 264
18436: PUSH
18437: LD_INT 26
18439: PUSH
18440: EMPTY
18441: LIST
18442: IN
18443: IFFALSE 18464
// points := [ 120 , 30 , 80 ] ;
18445: LD_ADDR_VAR 0 9
18449: PUSH
18450: LD_INT 120
18452: PUSH
18453: LD_INT 30
18455: PUSH
18456: LD_INT 80
18458: PUSH
18459: EMPTY
18460: LIST
18461: LIST
18462: LIST
18463: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18464: LD_VAR 0 6
18468: PPUSH
18469: CALL_OW 264
18473: PUSH
18474: LD_INT 22
18476: PUSH
18477: EMPTY
18478: LIST
18479: IN
18480: IFFALSE 18501
// points := [ 40 , 1 , 1 ] ;
18482: LD_ADDR_VAR 0 9
18486: PUSH
18487: LD_INT 40
18489: PUSH
18490: LD_INT 1
18492: PUSH
18493: LD_INT 1
18495: PUSH
18496: EMPTY
18497: LIST
18498: LIST
18499: LIST
18500: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18501: LD_VAR 0 6
18505: PPUSH
18506: CALL_OW 264
18510: PUSH
18511: LD_INT 29
18513: PUSH
18514: EMPTY
18515: LIST
18516: IN
18517: IFFALSE 18538
// points := [ 70 , 200 , 400 ] ;
18519: LD_ADDR_VAR 0 9
18523: PUSH
18524: LD_INT 70
18526: PUSH
18527: LD_INT 200
18529: PUSH
18530: LD_INT 400
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18538: LD_VAR 0 6
18542: PPUSH
18543: CALL_OW 264
18547: PUSH
18548: LD_INT 14
18550: PUSH
18551: LD_INT 53
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: IN
18558: IFFALSE 18579
// points := [ 40 , 10 , 20 ] ;
18560: LD_ADDR_VAR 0 9
18564: PUSH
18565: LD_INT 40
18567: PUSH
18568: LD_INT 10
18570: PUSH
18571: LD_INT 20
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: LIST
18578: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18579: LD_VAR 0 6
18583: PPUSH
18584: CALL_OW 264
18588: PUSH
18589: LD_INT 9
18591: PUSH
18592: EMPTY
18593: LIST
18594: IN
18595: IFFALSE 18616
// points := [ 5 , 70 , 20 ] ;
18597: LD_ADDR_VAR 0 9
18601: PUSH
18602: LD_INT 5
18604: PUSH
18605: LD_INT 70
18607: PUSH
18608: LD_INT 20
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: LIST
18615: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18616: LD_VAR 0 6
18620: PPUSH
18621: CALL_OW 264
18625: PUSH
18626: LD_INT 10
18628: PUSH
18629: EMPTY
18630: LIST
18631: IN
18632: IFFALSE 18653
// points := [ 35 , 110 , 70 ] ;
18634: LD_ADDR_VAR 0 9
18638: PUSH
18639: LD_INT 35
18641: PUSH
18642: LD_INT 110
18644: PUSH
18645: LD_INT 70
18647: PUSH
18648: EMPTY
18649: LIST
18650: LIST
18651: LIST
18652: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18653: LD_VAR 0 6
18657: PPUSH
18658: CALL_OW 265
18662: PUSH
18663: LD_INT 25
18665: EQUAL
18666: IFFALSE 18687
// points := [ 80 , 65 , 100 ] ;
18668: LD_ADDR_VAR 0 9
18672: PUSH
18673: LD_INT 80
18675: PUSH
18676: LD_INT 65
18678: PUSH
18679: LD_INT 100
18681: PUSH
18682: EMPTY
18683: LIST
18684: LIST
18685: LIST
18686: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18687: LD_VAR 0 6
18691: PPUSH
18692: CALL_OW 263
18696: PUSH
18697: LD_INT 1
18699: EQUAL
18700: IFFALSE 18735
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18702: LD_ADDR_VAR 0 10
18706: PUSH
18707: LD_VAR 0 10
18711: PUSH
18712: LD_VAR 0 6
18716: PPUSH
18717: CALL_OW 311
18721: PPUSH
18722: LD_INT 3
18724: PPUSH
18725: CALL_OW 259
18729: PUSH
18730: LD_INT 4
18732: MUL
18733: MUL
18734: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18735: LD_VAR 0 6
18739: PPUSH
18740: CALL_OW 263
18744: PUSH
18745: LD_INT 2
18747: EQUAL
18748: IFFALSE 18799
// begin j := IsControledBy ( i ) ;
18750: LD_ADDR_VAR 0 7
18754: PUSH
18755: LD_VAR 0 6
18759: PPUSH
18760: CALL_OW 312
18764: ST_TO_ADDR
// if j then
18765: LD_VAR 0 7
18769: IFFALSE 18799
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18771: LD_ADDR_VAR 0 10
18775: PUSH
18776: LD_VAR 0 10
18780: PUSH
18781: LD_VAR 0 7
18785: PPUSH
18786: LD_INT 3
18788: PPUSH
18789: CALL_OW 259
18793: PUSH
18794: LD_INT 3
18796: MUL
18797: MUL
18798: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18799: LD_VAR 0 6
18803: PPUSH
18804: CALL_OW 264
18808: PUSH
18809: LD_INT 5
18811: PUSH
18812: LD_INT 6
18814: PUSH
18815: LD_INT 46
18817: PUSH
18818: LD_INT 44
18820: PUSH
18821: LD_INT 47
18823: PUSH
18824: LD_INT 45
18826: PUSH
18827: LD_INT 28
18829: PUSH
18830: LD_INT 7
18832: PUSH
18833: LD_INT 27
18835: PUSH
18836: LD_INT 29
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: LIST
18849: LIST
18850: IN
18851: PUSH
18852: LD_VAR 0 1
18856: PPUSH
18857: LD_INT 52
18859: PPUSH
18860: CALL_OW 321
18864: PUSH
18865: LD_INT 2
18867: EQUAL
18868: AND
18869: IFFALSE 18886
// bpoints := bpoints * 1.2 ;
18871: LD_ADDR_VAR 0 10
18875: PUSH
18876: LD_VAR 0 10
18880: PUSH
18881: LD_REAL  1.20000000000000E+0000
18884: MUL
18885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18886: LD_VAR 0 6
18890: PPUSH
18891: CALL_OW 264
18895: PUSH
18896: LD_INT 6
18898: PUSH
18899: LD_INT 46
18901: PUSH
18902: LD_INT 47
18904: PUSH
18905: EMPTY
18906: LIST
18907: LIST
18908: LIST
18909: IN
18910: IFFALSE 18927
// bpoints := bpoints * 1.2 ;
18912: LD_ADDR_VAR 0 10
18916: PUSH
18917: LD_VAR 0 10
18921: PUSH
18922: LD_REAL  1.20000000000000E+0000
18925: MUL
18926: ST_TO_ADDR
// end ; unit_building :
18927: GO 18941
18929: LD_INT 3
18931: DOUBLE
18932: EQUAL
18933: IFTRUE 18937
18935: GO 18940
18937: POP
// ; end ;
18938: GO 18941
18940: POP
// for j = 1 to 3 do
18941: LD_ADDR_VAR 0 7
18945: PUSH
18946: DOUBLE
18947: LD_INT 1
18949: DEC
18950: ST_TO_ADDR
18951: LD_INT 3
18953: PUSH
18954: FOR_TO
18955: IFFALSE 19008
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18957: LD_ADDR_VAR 0 5
18961: PUSH
18962: LD_VAR 0 5
18966: PPUSH
18967: LD_VAR 0 7
18971: PPUSH
18972: LD_VAR 0 5
18976: PUSH
18977: LD_VAR 0 7
18981: ARRAY
18982: PUSH
18983: LD_VAR 0 9
18987: PUSH
18988: LD_VAR 0 7
18992: ARRAY
18993: PUSH
18994: LD_VAR 0 10
18998: MUL
18999: PLUS
19000: PPUSH
19001: CALL_OW 1
19005: ST_TO_ADDR
19006: GO 18954
19008: POP
19009: POP
// end ;
19010: GO 17489
19012: POP
19013: POP
// result := Replace ( result , 4 , tmp ) ;
19014: LD_ADDR_VAR 0 5
19018: PUSH
19019: LD_VAR 0 5
19023: PPUSH
19024: LD_INT 4
19026: PPUSH
19027: LD_VAR 0 8
19031: PPUSH
19032: CALL_OW 1
19036: ST_TO_ADDR
// end ;
19037: LD_VAR 0 5
19041: RET
// export function DangerAtRange ( unit , range ) ; begin
19042: LD_INT 0
19044: PPUSH
// if not unit then
19045: LD_VAR 0 1
19049: NOT
19050: IFFALSE 19054
// exit ;
19052: GO 19099
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
19054: LD_ADDR_VAR 0 3
19058: PUSH
19059: LD_VAR 0 1
19063: PPUSH
19064: CALL_OW 255
19068: PPUSH
19069: LD_VAR 0 1
19073: PPUSH
19074: CALL_OW 250
19078: PPUSH
19079: LD_VAR 0 1
19083: PPUSH
19084: CALL_OW 251
19088: PPUSH
19089: LD_VAR 0 2
19093: PPUSH
19094: CALL 17341 0 4
19098: ST_TO_ADDR
// end ;
19099: LD_VAR 0 3
19103: RET
// export function DangerInArea ( side , area ) ; begin
19104: LD_INT 0
19106: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
19107: LD_ADDR_VAR 0 3
19111: PUSH
19112: LD_VAR 0 2
19116: PPUSH
19117: LD_INT 81
19119: PUSH
19120: LD_VAR 0 1
19124: PUSH
19125: EMPTY
19126: LIST
19127: LIST
19128: PPUSH
19129: CALL_OW 70
19133: ST_TO_ADDR
// end ;
19134: LD_VAR 0 3
19138: RET
// export function IsExtension ( b ) ; begin
19139: LD_INT 0
19141: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
19142: LD_ADDR_VAR 0 2
19146: PUSH
19147: LD_VAR 0 1
19151: PUSH
19152: LD_INT 23
19154: PUSH
19155: LD_INT 20
19157: PUSH
19158: LD_INT 22
19160: PUSH
19161: LD_INT 17
19163: PUSH
19164: LD_INT 24
19166: PUSH
19167: LD_INT 21
19169: PUSH
19170: LD_INT 19
19172: PUSH
19173: LD_INT 16
19175: PUSH
19176: LD_INT 25
19178: PUSH
19179: LD_INT 18
19181: PUSH
19182: EMPTY
19183: LIST
19184: LIST
19185: LIST
19186: LIST
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: LIST
19193: IN
19194: ST_TO_ADDR
// end ;
19195: LD_VAR 0 2
19199: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
19200: LD_INT 0
19202: PPUSH
19203: PPUSH
19204: PPUSH
// result := [ ] ;
19205: LD_ADDR_VAR 0 4
19209: PUSH
19210: EMPTY
19211: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
19212: LD_ADDR_VAR 0 5
19216: PUSH
19217: LD_VAR 0 2
19221: PPUSH
19222: LD_INT 21
19224: PUSH
19225: LD_INT 3
19227: PUSH
19228: EMPTY
19229: LIST
19230: LIST
19231: PPUSH
19232: CALL_OW 70
19236: ST_TO_ADDR
// if not tmp then
19237: LD_VAR 0 5
19241: NOT
19242: IFFALSE 19246
// exit ;
19244: GO 19310
// if checkLink then
19246: LD_VAR 0 3
19250: IFFALSE 19300
// begin for i in tmp do
19252: LD_ADDR_VAR 0 6
19256: PUSH
19257: LD_VAR 0 5
19261: PUSH
19262: FOR_IN
19263: IFFALSE 19298
// if GetBase ( i ) <> base then
19265: LD_VAR 0 6
19269: PPUSH
19270: CALL_OW 274
19274: PUSH
19275: LD_VAR 0 1
19279: NONEQUAL
19280: IFFALSE 19296
// ComLinkToBase ( base , i ) ;
19282: LD_VAR 0 1
19286: PPUSH
19287: LD_VAR 0 6
19291: PPUSH
19292: CALL_OW 169
19296: GO 19262
19298: POP
19299: POP
// end ; result := tmp ;
19300: LD_ADDR_VAR 0 4
19304: PUSH
19305: LD_VAR 0 5
19309: ST_TO_ADDR
// end ;
19310: LD_VAR 0 4
19314: RET
// export function ComComplete ( units , b ) ; var i ; begin
19315: LD_INT 0
19317: PPUSH
19318: PPUSH
// if not units then
19319: LD_VAR 0 1
19323: NOT
19324: IFFALSE 19328
// exit ;
19326: GO 19418
// for i in units do
19328: LD_ADDR_VAR 0 4
19332: PUSH
19333: LD_VAR 0 1
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19416
// if BuildingStatus ( b ) = bs_build then
19341: LD_VAR 0 2
19345: PPUSH
19346: CALL_OW 461
19350: PUSH
19351: LD_INT 1
19353: EQUAL
19354: IFFALSE 19414
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19356: LD_VAR 0 4
19360: PPUSH
19361: LD_STRING h
19363: PUSH
19364: LD_VAR 0 2
19368: PPUSH
19369: CALL_OW 250
19373: PUSH
19374: LD_VAR 0 2
19378: PPUSH
19379: CALL_OW 251
19383: PUSH
19384: LD_VAR 0 2
19388: PUSH
19389: LD_INT 0
19391: PUSH
19392: LD_INT 0
19394: PUSH
19395: LD_INT 0
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: PUSH
19407: EMPTY
19408: LIST
19409: PPUSH
19410: CALL_OW 446
19414: GO 19338
19416: POP
19417: POP
// end ;
19418: LD_VAR 0 3
19422: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19423: LD_INT 0
19425: PPUSH
19426: PPUSH
19427: PPUSH
19428: PPUSH
19429: PPUSH
19430: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19431: LD_VAR 0 1
19435: NOT
19436: PUSH
19437: LD_VAR 0 1
19441: PPUSH
19442: CALL_OW 263
19446: PUSH
19447: LD_INT 2
19449: NONEQUAL
19450: OR
19451: IFFALSE 19455
// exit ;
19453: GO 19771
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19455: LD_ADDR_VAR 0 6
19459: PUSH
19460: LD_INT 22
19462: PUSH
19463: LD_VAR 0 1
19467: PPUSH
19468: CALL_OW 255
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: PUSH
19477: LD_INT 2
19479: PUSH
19480: LD_INT 30
19482: PUSH
19483: LD_INT 36
19485: PUSH
19486: EMPTY
19487: LIST
19488: LIST
19489: PUSH
19490: LD_INT 34
19492: PUSH
19493: LD_INT 31
19495: PUSH
19496: EMPTY
19497: LIST
19498: LIST
19499: PUSH
19500: EMPTY
19501: LIST
19502: LIST
19503: LIST
19504: PUSH
19505: EMPTY
19506: LIST
19507: LIST
19508: PPUSH
19509: CALL_OW 69
19513: ST_TO_ADDR
// if not tmp then
19514: LD_VAR 0 6
19518: NOT
19519: IFFALSE 19523
// exit ;
19521: GO 19771
// result := [ ] ;
19523: LD_ADDR_VAR 0 2
19527: PUSH
19528: EMPTY
19529: ST_TO_ADDR
// for i in tmp do
19530: LD_ADDR_VAR 0 3
19534: PUSH
19535: LD_VAR 0 6
19539: PUSH
19540: FOR_IN
19541: IFFALSE 19612
// begin t := UnitsInside ( i ) ;
19543: LD_ADDR_VAR 0 4
19547: PUSH
19548: LD_VAR 0 3
19552: PPUSH
19553: CALL_OW 313
19557: ST_TO_ADDR
// if t then
19558: LD_VAR 0 4
19562: IFFALSE 19610
// for j in t do
19564: LD_ADDR_VAR 0 7
19568: PUSH
19569: LD_VAR 0 4
19573: PUSH
19574: FOR_IN
19575: IFFALSE 19608
// result := Replace ( result , result + 1 , j ) ;
19577: LD_ADDR_VAR 0 2
19581: PUSH
19582: LD_VAR 0 2
19586: PPUSH
19587: LD_VAR 0 2
19591: PUSH
19592: LD_INT 1
19594: PLUS
19595: PPUSH
19596: LD_VAR 0 7
19600: PPUSH
19601: CALL_OW 1
19605: ST_TO_ADDR
19606: GO 19574
19608: POP
19609: POP
// end ;
19610: GO 19540
19612: POP
19613: POP
// if not result then
19614: LD_VAR 0 2
19618: NOT
19619: IFFALSE 19623
// exit ;
19621: GO 19771
// mech := result [ 1 ] ;
19623: LD_ADDR_VAR 0 5
19627: PUSH
19628: LD_VAR 0 2
19632: PUSH
19633: LD_INT 1
19635: ARRAY
19636: ST_TO_ADDR
// if result > 1 then
19637: LD_VAR 0 2
19641: PUSH
19642: LD_INT 1
19644: GREATER
19645: IFFALSE 19757
// begin for i = 2 to result do
19647: LD_ADDR_VAR 0 3
19651: PUSH
19652: DOUBLE
19653: LD_INT 2
19655: DEC
19656: ST_TO_ADDR
19657: LD_VAR 0 2
19661: PUSH
19662: FOR_TO
19663: IFFALSE 19755
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19665: LD_ADDR_VAR 0 4
19669: PUSH
19670: LD_VAR 0 2
19674: PUSH
19675: LD_VAR 0 3
19679: ARRAY
19680: PPUSH
19681: LD_INT 3
19683: PPUSH
19684: CALL_OW 259
19688: PUSH
19689: LD_VAR 0 2
19693: PUSH
19694: LD_VAR 0 3
19698: ARRAY
19699: PPUSH
19700: CALL_OW 432
19704: MINUS
19705: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19706: LD_VAR 0 4
19710: PUSH
19711: LD_VAR 0 5
19715: PPUSH
19716: LD_INT 3
19718: PPUSH
19719: CALL_OW 259
19723: PUSH
19724: LD_VAR 0 5
19728: PPUSH
19729: CALL_OW 432
19733: MINUS
19734: GREATEREQUAL
19735: IFFALSE 19753
// mech := result [ i ] ;
19737: LD_ADDR_VAR 0 5
19741: PUSH
19742: LD_VAR 0 2
19746: PUSH
19747: LD_VAR 0 3
19751: ARRAY
19752: ST_TO_ADDR
// end ;
19753: GO 19662
19755: POP
19756: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19757: LD_VAR 0 1
19761: PPUSH
19762: LD_VAR 0 5
19766: PPUSH
19767: CALL_OW 135
// end ;
19771: LD_VAR 0 2
19775: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19776: LD_INT 0
19778: PPUSH
19779: PPUSH
19780: PPUSH
19781: PPUSH
19782: PPUSH
19783: PPUSH
19784: PPUSH
19785: PPUSH
19786: PPUSH
19787: PPUSH
19788: PPUSH
19789: PPUSH
19790: PPUSH
// result := [ ] ;
19791: LD_ADDR_VAR 0 7
19795: PUSH
19796: EMPTY
19797: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19798: LD_VAR 0 1
19802: PPUSH
19803: CALL_OW 266
19807: PUSH
19808: LD_INT 0
19810: PUSH
19811: LD_INT 1
19813: PUSH
19814: EMPTY
19815: LIST
19816: LIST
19817: IN
19818: NOT
19819: IFFALSE 19823
// exit ;
19821: GO 21457
// if name then
19823: LD_VAR 0 3
19827: IFFALSE 19843
// SetBName ( base_dep , name ) ;
19829: LD_VAR 0 1
19833: PPUSH
19834: LD_VAR 0 3
19838: PPUSH
19839: CALL_OW 500
// base := GetBase ( base_dep ) ;
19843: LD_ADDR_VAR 0 15
19847: PUSH
19848: LD_VAR 0 1
19852: PPUSH
19853: CALL_OW 274
19857: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19858: LD_ADDR_VAR 0 16
19862: PUSH
19863: LD_VAR 0 1
19867: PPUSH
19868: CALL_OW 255
19872: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19873: LD_ADDR_VAR 0 17
19877: PUSH
19878: LD_VAR 0 1
19882: PPUSH
19883: CALL_OW 248
19887: ST_TO_ADDR
// if sources then
19888: LD_VAR 0 5
19892: IFFALSE 19939
// for i = 1 to 3 do
19894: LD_ADDR_VAR 0 8
19898: PUSH
19899: DOUBLE
19900: LD_INT 1
19902: DEC
19903: ST_TO_ADDR
19904: LD_INT 3
19906: PUSH
19907: FOR_TO
19908: IFFALSE 19937
// AddResourceType ( base , i , sources [ i ] ) ;
19910: LD_VAR 0 15
19914: PPUSH
19915: LD_VAR 0 8
19919: PPUSH
19920: LD_VAR 0 5
19924: PUSH
19925: LD_VAR 0 8
19929: ARRAY
19930: PPUSH
19931: CALL_OW 276
19935: GO 19907
19937: POP
19938: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19939: LD_ADDR_VAR 0 18
19943: PUSH
19944: LD_VAR 0 15
19948: PPUSH
19949: LD_VAR 0 2
19953: PPUSH
19954: LD_INT 1
19956: PPUSH
19957: CALL 19200 0 3
19961: ST_TO_ADDR
// InitHc ;
19962: CALL_OW 19
// InitUc ;
19966: CALL_OW 18
// uc_side := side ;
19970: LD_ADDR_OWVAR 20
19974: PUSH
19975: LD_VAR 0 16
19979: ST_TO_ADDR
// uc_nation := nation ;
19980: LD_ADDR_OWVAR 21
19984: PUSH
19985: LD_VAR 0 17
19989: ST_TO_ADDR
// if buildings then
19990: LD_VAR 0 18
19994: IFFALSE 21316
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19996: LD_ADDR_VAR 0 19
20000: PUSH
20001: LD_VAR 0 18
20005: PPUSH
20006: LD_INT 2
20008: PUSH
20009: LD_INT 30
20011: PUSH
20012: LD_INT 29
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: PUSH
20019: LD_INT 30
20021: PUSH
20022: LD_INT 30
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: LIST
20033: PPUSH
20034: CALL_OW 72
20038: ST_TO_ADDR
// if tmp then
20039: LD_VAR 0 19
20043: IFFALSE 20091
// for i in tmp do
20045: LD_ADDR_VAR 0 8
20049: PUSH
20050: LD_VAR 0 19
20054: PUSH
20055: FOR_IN
20056: IFFALSE 20089
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
20058: LD_VAR 0 8
20062: PPUSH
20063: CALL_OW 250
20067: PPUSH
20068: LD_VAR 0 8
20072: PPUSH
20073: CALL_OW 251
20077: PPUSH
20078: LD_VAR 0 16
20082: PPUSH
20083: CALL_OW 441
20087: GO 20055
20089: POP
20090: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
20091: LD_VAR 0 18
20095: PPUSH
20096: LD_INT 2
20098: PUSH
20099: LD_INT 30
20101: PUSH
20102: LD_INT 32
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: LD_INT 30
20111: PUSH
20112: LD_INT 33
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: LIST
20123: PPUSH
20124: CALL_OW 72
20128: IFFALSE 20216
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
20130: LD_ADDR_VAR 0 8
20134: PUSH
20135: LD_VAR 0 18
20139: PPUSH
20140: LD_INT 2
20142: PUSH
20143: LD_INT 30
20145: PUSH
20146: LD_INT 32
20148: PUSH
20149: EMPTY
20150: LIST
20151: LIST
20152: PUSH
20153: LD_INT 30
20155: PUSH
20156: LD_INT 33
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: LIST
20167: PPUSH
20168: CALL_OW 72
20172: PUSH
20173: FOR_IN
20174: IFFALSE 20214
// begin if not GetBWeapon ( i ) then
20176: LD_VAR 0 8
20180: PPUSH
20181: CALL_OW 269
20185: NOT
20186: IFFALSE 20212
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
20188: LD_VAR 0 8
20192: PPUSH
20193: LD_VAR 0 8
20197: PPUSH
20198: LD_VAR 0 2
20202: PPUSH
20203: CALL 21462 0 2
20207: PPUSH
20208: CALL_OW 431
// end ;
20212: GO 20173
20214: POP
20215: POP
// end ; for i = 1 to personel do
20216: LD_ADDR_VAR 0 8
20220: PUSH
20221: DOUBLE
20222: LD_INT 1
20224: DEC
20225: ST_TO_ADDR
20226: LD_VAR 0 6
20230: PUSH
20231: FOR_TO
20232: IFFALSE 21296
// begin if i > 4 then
20234: LD_VAR 0 8
20238: PUSH
20239: LD_INT 4
20241: GREATER
20242: IFFALSE 20246
// break ;
20244: GO 21296
// case i of 1 :
20246: LD_VAR 0 8
20250: PUSH
20251: LD_INT 1
20253: DOUBLE
20254: EQUAL
20255: IFTRUE 20259
20257: GO 20339
20259: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
20260: LD_ADDR_VAR 0 12
20264: PUSH
20265: LD_VAR 0 18
20269: PPUSH
20270: LD_INT 22
20272: PUSH
20273: LD_VAR 0 16
20277: PUSH
20278: EMPTY
20279: LIST
20280: LIST
20281: PUSH
20282: LD_INT 58
20284: PUSH
20285: EMPTY
20286: LIST
20287: PUSH
20288: LD_INT 2
20290: PUSH
20291: LD_INT 30
20293: PUSH
20294: LD_INT 32
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 30
20303: PUSH
20304: LD_INT 4
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PUSH
20311: LD_INT 30
20313: PUSH
20314: LD_INT 5
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: LIST
20331: PPUSH
20332: CALL_OW 72
20336: ST_TO_ADDR
20337: GO 20561
20339: LD_INT 2
20341: DOUBLE
20342: EQUAL
20343: IFTRUE 20347
20345: GO 20409
20347: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20348: LD_ADDR_VAR 0 12
20352: PUSH
20353: LD_VAR 0 18
20357: PPUSH
20358: LD_INT 22
20360: PUSH
20361: LD_VAR 0 16
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: PUSH
20370: LD_INT 2
20372: PUSH
20373: LD_INT 30
20375: PUSH
20376: LD_INT 0
20378: PUSH
20379: EMPTY
20380: LIST
20381: LIST
20382: PUSH
20383: LD_INT 30
20385: PUSH
20386: LD_INT 1
20388: PUSH
20389: EMPTY
20390: LIST
20391: LIST
20392: PUSH
20393: EMPTY
20394: LIST
20395: LIST
20396: LIST
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PPUSH
20402: CALL_OW 72
20406: ST_TO_ADDR
20407: GO 20561
20409: LD_INT 3
20411: DOUBLE
20412: EQUAL
20413: IFTRUE 20417
20415: GO 20479
20417: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20418: LD_ADDR_VAR 0 12
20422: PUSH
20423: LD_VAR 0 18
20427: PPUSH
20428: LD_INT 22
20430: PUSH
20431: LD_VAR 0 16
20435: PUSH
20436: EMPTY
20437: LIST
20438: LIST
20439: PUSH
20440: LD_INT 2
20442: PUSH
20443: LD_INT 30
20445: PUSH
20446: LD_INT 2
20448: PUSH
20449: EMPTY
20450: LIST
20451: LIST
20452: PUSH
20453: LD_INT 30
20455: PUSH
20456: LD_INT 3
20458: PUSH
20459: EMPTY
20460: LIST
20461: LIST
20462: PUSH
20463: EMPTY
20464: LIST
20465: LIST
20466: LIST
20467: PUSH
20468: EMPTY
20469: LIST
20470: LIST
20471: PPUSH
20472: CALL_OW 72
20476: ST_TO_ADDR
20477: GO 20561
20479: LD_INT 4
20481: DOUBLE
20482: EQUAL
20483: IFTRUE 20487
20485: GO 20560
20487: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20488: LD_ADDR_VAR 0 12
20492: PUSH
20493: LD_VAR 0 18
20497: PPUSH
20498: LD_INT 22
20500: PUSH
20501: LD_VAR 0 16
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: PUSH
20510: LD_INT 2
20512: PUSH
20513: LD_INT 30
20515: PUSH
20516: LD_INT 6
20518: PUSH
20519: EMPTY
20520: LIST
20521: LIST
20522: PUSH
20523: LD_INT 30
20525: PUSH
20526: LD_INT 7
20528: PUSH
20529: EMPTY
20530: LIST
20531: LIST
20532: PUSH
20533: LD_INT 30
20535: PUSH
20536: LD_INT 8
20538: PUSH
20539: EMPTY
20540: LIST
20541: LIST
20542: PUSH
20543: EMPTY
20544: LIST
20545: LIST
20546: LIST
20547: LIST
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: PPUSH
20553: CALL_OW 72
20557: ST_TO_ADDR
20558: GO 20561
20560: POP
// if i = 1 then
20561: LD_VAR 0 8
20565: PUSH
20566: LD_INT 1
20568: EQUAL
20569: IFFALSE 20680
// begin tmp := [ ] ;
20571: LD_ADDR_VAR 0 19
20575: PUSH
20576: EMPTY
20577: ST_TO_ADDR
// for j in f do
20578: LD_ADDR_VAR 0 9
20582: PUSH
20583: LD_VAR 0 12
20587: PUSH
20588: FOR_IN
20589: IFFALSE 20662
// if GetBType ( j ) = b_bunker then
20591: LD_VAR 0 9
20595: PPUSH
20596: CALL_OW 266
20600: PUSH
20601: LD_INT 32
20603: EQUAL
20604: IFFALSE 20631
// tmp := Insert ( tmp , 1 , j ) else
20606: LD_ADDR_VAR 0 19
20610: PUSH
20611: LD_VAR 0 19
20615: PPUSH
20616: LD_INT 1
20618: PPUSH
20619: LD_VAR 0 9
20623: PPUSH
20624: CALL_OW 2
20628: ST_TO_ADDR
20629: GO 20660
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20631: LD_ADDR_VAR 0 19
20635: PUSH
20636: LD_VAR 0 19
20640: PPUSH
20641: LD_VAR 0 19
20645: PUSH
20646: LD_INT 1
20648: PLUS
20649: PPUSH
20650: LD_VAR 0 9
20654: PPUSH
20655: CALL_OW 2
20659: ST_TO_ADDR
20660: GO 20588
20662: POP
20663: POP
// if tmp then
20664: LD_VAR 0 19
20668: IFFALSE 20680
// f := tmp ;
20670: LD_ADDR_VAR 0 12
20674: PUSH
20675: LD_VAR 0 19
20679: ST_TO_ADDR
// end ; x := personel [ i ] ;
20680: LD_ADDR_VAR 0 13
20684: PUSH
20685: LD_VAR 0 6
20689: PUSH
20690: LD_VAR 0 8
20694: ARRAY
20695: ST_TO_ADDR
// if x = - 1 then
20696: LD_VAR 0 13
20700: PUSH
20701: LD_INT 1
20703: NEG
20704: EQUAL
20705: IFFALSE 20914
// begin for j in f do
20707: LD_ADDR_VAR 0 9
20711: PUSH
20712: LD_VAR 0 12
20716: PUSH
20717: FOR_IN
20718: IFFALSE 20910
// repeat InitHc ;
20720: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20724: LD_VAR 0 9
20728: PPUSH
20729: CALL_OW 266
20733: PUSH
20734: LD_INT 5
20736: EQUAL
20737: IFFALSE 20807
// begin if UnitsInside ( j ) < 3 then
20739: LD_VAR 0 9
20743: PPUSH
20744: CALL_OW 313
20748: PUSH
20749: LD_INT 3
20751: LESS
20752: IFFALSE 20788
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20754: LD_INT 0
20756: PPUSH
20757: LD_INT 5
20759: PUSH
20760: LD_INT 8
20762: PUSH
20763: LD_INT 9
20765: PUSH
20766: EMPTY
20767: LIST
20768: LIST
20769: LIST
20770: PUSH
20771: LD_VAR 0 17
20775: ARRAY
20776: PPUSH
20777: LD_VAR 0 4
20781: PPUSH
20782: CALL_OW 380
20786: GO 20805
// PrepareHuman ( false , i , skill ) ;
20788: LD_INT 0
20790: PPUSH
20791: LD_VAR 0 8
20795: PPUSH
20796: LD_VAR 0 4
20800: PPUSH
20801: CALL_OW 380
// end else
20805: GO 20824
// PrepareHuman ( false , i , skill ) ;
20807: LD_INT 0
20809: PPUSH
20810: LD_VAR 0 8
20814: PPUSH
20815: LD_VAR 0 4
20819: PPUSH
20820: CALL_OW 380
// un := CreateHuman ;
20824: LD_ADDR_VAR 0 14
20828: PUSH
20829: CALL_OW 44
20833: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20834: LD_ADDR_VAR 0 7
20838: PUSH
20839: LD_VAR 0 7
20843: PPUSH
20844: LD_INT 1
20846: PPUSH
20847: LD_VAR 0 14
20851: PPUSH
20852: CALL_OW 2
20856: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20857: LD_VAR 0 14
20861: PPUSH
20862: LD_VAR 0 9
20866: PPUSH
20867: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20871: LD_VAR 0 9
20875: PPUSH
20876: CALL_OW 313
20880: PUSH
20881: LD_INT 6
20883: EQUAL
20884: PUSH
20885: LD_VAR 0 9
20889: PPUSH
20890: CALL_OW 266
20894: PUSH
20895: LD_INT 32
20897: PUSH
20898: LD_INT 31
20900: PUSH
20901: EMPTY
20902: LIST
20903: LIST
20904: IN
20905: OR
20906: IFFALSE 20720
20908: GO 20717
20910: POP
20911: POP
// end else
20912: GO 21294
// for j = 1 to x do
20914: LD_ADDR_VAR 0 9
20918: PUSH
20919: DOUBLE
20920: LD_INT 1
20922: DEC
20923: ST_TO_ADDR
20924: LD_VAR 0 13
20928: PUSH
20929: FOR_TO
20930: IFFALSE 21292
// begin InitHc ;
20932: CALL_OW 19
// if not f then
20936: LD_VAR 0 12
20940: NOT
20941: IFFALSE 21030
// begin PrepareHuman ( false , i , skill ) ;
20943: LD_INT 0
20945: PPUSH
20946: LD_VAR 0 8
20950: PPUSH
20951: LD_VAR 0 4
20955: PPUSH
20956: CALL_OW 380
// un := CreateHuman ;
20960: LD_ADDR_VAR 0 14
20964: PUSH
20965: CALL_OW 44
20969: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20970: LD_ADDR_VAR 0 7
20974: PUSH
20975: LD_VAR 0 7
20979: PPUSH
20980: LD_INT 1
20982: PPUSH
20983: LD_VAR 0 14
20987: PPUSH
20988: CALL_OW 2
20992: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20993: LD_VAR 0 14
20997: PPUSH
20998: LD_VAR 0 1
21002: PPUSH
21003: CALL_OW 250
21007: PPUSH
21008: LD_VAR 0 1
21012: PPUSH
21013: CALL_OW 251
21017: PPUSH
21018: LD_INT 10
21020: PPUSH
21021: LD_INT 0
21023: PPUSH
21024: CALL_OW 50
// continue ;
21028: GO 20929
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
21030: LD_VAR 0 12
21034: PUSH
21035: LD_INT 1
21037: ARRAY
21038: PPUSH
21039: CALL_OW 313
21043: PUSH
21044: LD_VAR 0 12
21048: PUSH
21049: LD_INT 1
21051: ARRAY
21052: PPUSH
21053: CALL_OW 266
21057: PUSH
21058: LD_INT 32
21060: PUSH
21061: LD_INT 31
21063: PUSH
21064: EMPTY
21065: LIST
21066: LIST
21067: IN
21068: AND
21069: PUSH
21070: LD_VAR 0 12
21074: PUSH
21075: LD_INT 1
21077: ARRAY
21078: PPUSH
21079: CALL_OW 313
21083: PUSH
21084: LD_INT 6
21086: EQUAL
21087: OR
21088: IFFALSE 21108
// f := Delete ( f , 1 ) ;
21090: LD_ADDR_VAR 0 12
21094: PUSH
21095: LD_VAR 0 12
21099: PPUSH
21100: LD_INT 1
21102: PPUSH
21103: CALL_OW 3
21107: ST_TO_ADDR
// if not f then
21108: LD_VAR 0 12
21112: NOT
21113: IFFALSE 21131
// begin x := x + 2 ;
21115: LD_ADDR_VAR 0 13
21119: PUSH
21120: LD_VAR 0 13
21124: PUSH
21125: LD_INT 2
21127: PLUS
21128: ST_TO_ADDR
// continue ;
21129: GO 20929
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
21131: LD_VAR 0 12
21135: PUSH
21136: LD_INT 1
21138: ARRAY
21139: PPUSH
21140: CALL_OW 266
21144: PUSH
21145: LD_INT 5
21147: EQUAL
21148: IFFALSE 21222
// begin if UnitsInside ( f [ 1 ] ) < 3 then
21150: LD_VAR 0 12
21154: PUSH
21155: LD_INT 1
21157: ARRAY
21158: PPUSH
21159: CALL_OW 313
21163: PUSH
21164: LD_INT 3
21166: LESS
21167: IFFALSE 21203
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
21169: LD_INT 0
21171: PPUSH
21172: LD_INT 5
21174: PUSH
21175: LD_INT 8
21177: PUSH
21178: LD_INT 9
21180: PUSH
21181: EMPTY
21182: LIST
21183: LIST
21184: LIST
21185: PUSH
21186: LD_VAR 0 17
21190: ARRAY
21191: PPUSH
21192: LD_VAR 0 4
21196: PPUSH
21197: CALL_OW 380
21201: GO 21220
// PrepareHuman ( false , i , skill ) ;
21203: LD_INT 0
21205: PPUSH
21206: LD_VAR 0 8
21210: PPUSH
21211: LD_VAR 0 4
21215: PPUSH
21216: CALL_OW 380
// end else
21220: GO 21239
// PrepareHuman ( false , i , skill ) ;
21222: LD_INT 0
21224: PPUSH
21225: LD_VAR 0 8
21229: PPUSH
21230: LD_VAR 0 4
21234: PPUSH
21235: CALL_OW 380
// un := CreateHuman ;
21239: LD_ADDR_VAR 0 14
21243: PUSH
21244: CALL_OW 44
21248: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21249: LD_ADDR_VAR 0 7
21253: PUSH
21254: LD_VAR 0 7
21258: PPUSH
21259: LD_INT 1
21261: PPUSH
21262: LD_VAR 0 14
21266: PPUSH
21267: CALL_OW 2
21271: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
21272: LD_VAR 0 14
21276: PPUSH
21277: LD_VAR 0 12
21281: PUSH
21282: LD_INT 1
21284: ARRAY
21285: PPUSH
21286: CALL_OW 52
// end ;
21290: GO 20929
21292: POP
21293: POP
// end ;
21294: GO 20231
21296: POP
21297: POP
// result := result ^ buildings ;
21298: LD_ADDR_VAR 0 7
21302: PUSH
21303: LD_VAR 0 7
21307: PUSH
21308: LD_VAR 0 18
21312: ADD
21313: ST_TO_ADDR
// end else
21314: GO 21457
// begin for i = 1 to personel do
21316: LD_ADDR_VAR 0 8
21320: PUSH
21321: DOUBLE
21322: LD_INT 1
21324: DEC
21325: ST_TO_ADDR
21326: LD_VAR 0 6
21330: PUSH
21331: FOR_TO
21332: IFFALSE 21455
// begin if i > 4 then
21334: LD_VAR 0 8
21338: PUSH
21339: LD_INT 4
21341: GREATER
21342: IFFALSE 21346
// break ;
21344: GO 21455
// x := personel [ i ] ;
21346: LD_ADDR_VAR 0 13
21350: PUSH
21351: LD_VAR 0 6
21355: PUSH
21356: LD_VAR 0 8
21360: ARRAY
21361: ST_TO_ADDR
// if x = - 1 then
21362: LD_VAR 0 13
21366: PUSH
21367: LD_INT 1
21369: NEG
21370: EQUAL
21371: IFFALSE 21375
// continue ;
21373: GO 21331
// PrepareHuman ( false , i , skill ) ;
21375: LD_INT 0
21377: PPUSH
21378: LD_VAR 0 8
21382: PPUSH
21383: LD_VAR 0 4
21387: PPUSH
21388: CALL_OW 380
// un := CreateHuman ;
21392: LD_ADDR_VAR 0 14
21396: PUSH
21397: CALL_OW 44
21401: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21402: LD_VAR 0 14
21406: PPUSH
21407: LD_VAR 0 1
21411: PPUSH
21412: CALL_OW 250
21416: PPUSH
21417: LD_VAR 0 1
21421: PPUSH
21422: CALL_OW 251
21426: PPUSH
21427: LD_INT 10
21429: PPUSH
21430: LD_INT 0
21432: PPUSH
21433: CALL_OW 50
// result := result ^ un ;
21437: LD_ADDR_VAR 0 7
21441: PUSH
21442: LD_VAR 0 7
21446: PUSH
21447: LD_VAR 0 14
21451: ADD
21452: ST_TO_ADDR
// end ;
21453: GO 21331
21455: POP
21456: POP
// end ; end ;
21457: LD_VAR 0 7
21461: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21462: LD_INT 0
21464: PPUSH
21465: PPUSH
21466: PPUSH
21467: PPUSH
21468: PPUSH
21469: PPUSH
21470: PPUSH
21471: PPUSH
21472: PPUSH
21473: PPUSH
21474: PPUSH
21475: PPUSH
21476: PPUSH
21477: PPUSH
21478: PPUSH
21479: PPUSH
// result := false ;
21480: LD_ADDR_VAR 0 3
21484: PUSH
21485: LD_INT 0
21487: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21488: LD_VAR 0 1
21492: NOT
21493: PUSH
21494: LD_VAR 0 1
21498: PPUSH
21499: CALL_OW 266
21503: PUSH
21504: LD_INT 32
21506: PUSH
21507: LD_INT 33
21509: PUSH
21510: EMPTY
21511: LIST
21512: LIST
21513: IN
21514: NOT
21515: OR
21516: IFFALSE 21520
// exit ;
21518: GO 22629
// nat := GetNation ( tower ) ;
21520: LD_ADDR_VAR 0 12
21524: PUSH
21525: LD_VAR 0 1
21529: PPUSH
21530: CALL_OW 248
21534: ST_TO_ADDR
// side := GetSide ( tower ) ;
21535: LD_ADDR_VAR 0 16
21539: PUSH
21540: LD_VAR 0 1
21544: PPUSH
21545: CALL_OW 255
21549: ST_TO_ADDR
// x := GetX ( tower ) ;
21550: LD_ADDR_VAR 0 10
21554: PUSH
21555: LD_VAR 0 1
21559: PPUSH
21560: CALL_OW 250
21564: ST_TO_ADDR
// y := GetY ( tower ) ;
21565: LD_ADDR_VAR 0 11
21569: PUSH
21570: LD_VAR 0 1
21574: PPUSH
21575: CALL_OW 251
21579: ST_TO_ADDR
// if not x or not y then
21580: LD_VAR 0 10
21584: NOT
21585: PUSH
21586: LD_VAR 0 11
21590: NOT
21591: OR
21592: IFFALSE 21596
// exit ;
21594: GO 22629
// weapon := 0 ;
21596: LD_ADDR_VAR 0 18
21600: PUSH
21601: LD_INT 0
21603: ST_TO_ADDR
// fac_list := [ ] ;
21604: LD_ADDR_VAR 0 17
21608: PUSH
21609: EMPTY
21610: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21611: LD_ADDR_VAR 0 6
21615: PUSH
21616: LD_VAR 0 1
21620: PPUSH
21621: CALL_OW 274
21625: PPUSH
21626: LD_VAR 0 2
21630: PPUSH
21631: LD_INT 0
21633: PPUSH
21634: CALL 19200 0 3
21638: PPUSH
21639: LD_INT 30
21641: PUSH
21642: LD_INT 3
21644: PUSH
21645: EMPTY
21646: LIST
21647: LIST
21648: PPUSH
21649: CALL_OW 72
21653: ST_TO_ADDR
// if not factories then
21654: LD_VAR 0 6
21658: NOT
21659: IFFALSE 21663
// exit ;
21661: GO 22629
// for i in factories do
21663: LD_ADDR_VAR 0 8
21667: PUSH
21668: LD_VAR 0 6
21672: PUSH
21673: FOR_IN
21674: IFFALSE 21699
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21676: LD_ADDR_VAR 0 17
21680: PUSH
21681: LD_VAR 0 17
21685: PUSH
21686: LD_VAR 0 8
21690: PPUSH
21691: CALL_OW 478
21695: UNION
21696: ST_TO_ADDR
21697: GO 21673
21699: POP
21700: POP
// if not fac_list then
21701: LD_VAR 0 17
21705: NOT
21706: IFFALSE 21710
// exit ;
21708: GO 22629
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21710: LD_ADDR_VAR 0 5
21714: PUSH
21715: LD_INT 4
21717: PUSH
21718: LD_INT 5
21720: PUSH
21721: LD_INT 9
21723: PUSH
21724: LD_INT 10
21726: PUSH
21727: LD_INT 6
21729: PUSH
21730: LD_INT 7
21732: PUSH
21733: LD_INT 11
21735: PUSH
21736: EMPTY
21737: LIST
21738: LIST
21739: LIST
21740: LIST
21741: LIST
21742: LIST
21743: LIST
21744: PUSH
21745: LD_INT 27
21747: PUSH
21748: LD_INT 28
21750: PUSH
21751: LD_INT 26
21753: PUSH
21754: LD_INT 30
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: LIST
21761: LIST
21762: PUSH
21763: LD_INT 43
21765: PUSH
21766: LD_INT 44
21768: PUSH
21769: LD_INT 46
21771: PUSH
21772: LD_INT 45
21774: PUSH
21775: LD_INT 47
21777: PUSH
21778: LD_INT 49
21780: PUSH
21781: EMPTY
21782: LIST
21783: LIST
21784: LIST
21785: LIST
21786: LIST
21787: LIST
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: LIST
21793: PUSH
21794: LD_VAR 0 12
21798: ARRAY
21799: ST_TO_ADDR
// list := list isect fac_list ;
21800: LD_ADDR_VAR 0 5
21804: PUSH
21805: LD_VAR 0 5
21809: PUSH
21810: LD_VAR 0 17
21814: ISECT
21815: ST_TO_ADDR
// if not list then
21816: LD_VAR 0 5
21820: NOT
21821: IFFALSE 21825
// exit ;
21823: GO 22629
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21825: LD_VAR 0 12
21829: PUSH
21830: LD_INT 3
21832: EQUAL
21833: PUSH
21834: LD_INT 49
21836: PUSH
21837: LD_VAR 0 5
21841: IN
21842: AND
21843: PUSH
21844: LD_INT 31
21846: PPUSH
21847: LD_VAR 0 16
21851: PPUSH
21852: CALL_OW 321
21856: PUSH
21857: LD_INT 2
21859: EQUAL
21860: AND
21861: IFFALSE 21921
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21863: LD_INT 22
21865: PUSH
21866: LD_VAR 0 16
21870: PUSH
21871: EMPTY
21872: LIST
21873: LIST
21874: PUSH
21875: LD_INT 35
21877: PUSH
21878: LD_INT 49
21880: PUSH
21881: EMPTY
21882: LIST
21883: LIST
21884: PUSH
21885: LD_INT 91
21887: PUSH
21888: LD_VAR 0 1
21892: PUSH
21893: LD_INT 10
21895: PUSH
21896: EMPTY
21897: LIST
21898: LIST
21899: LIST
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: LIST
21905: PPUSH
21906: CALL_OW 69
21910: NOT
21911: IFFALSE 21921
// weapon := ru_time_lapser ;
21913: LD_ADDR_VAR 0 18
21917: PUSH
21918: LD_INT 49
21920: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21921: LD_VAR 0 12
21925: PUSH
21926: LD_INT 1
21928: PUSH
21929: LD_INT 2
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: IN
21936: PUSH
21937: LD_INT 11
21939: PUSH
21940: LD_VAR 0 5
21944: IN
21945: PUSH
21946: LD_INT 30
21948: PUSH
21949: LD_VAR 0 5
21953: IN
21954: OR
21955: AND
21956: PUSH
21957: LD_INT 6
21959: PPUSH
21960: LD_VAR 0 16
21964: PPUSH
21965: CALL_OW 321
21969: PUSH
21970: LD_INT 2
21972: EQUAL
21973: AND
21974: IFFALSE 22139
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21976: LD_INT 22
21978: PUSH
21979: LD_VAR 0 16
21983: PUSH
21984: EMPTY
21985: LIST
21986: LIST
21987: PUSH
21988: LD_INT 2
21990: PUSH
21991: LD_INT 35
21993: PUSH
21994: LD_INT 11
21996: PUSH
21997: EMPTY
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 35
22003: PUSH
22004: LD_INT 30
22006: PUSH
22007: EMPTY
22008: LIST
22009: LIST
22010: PUSH
22011: EMPTY
22012: LIST
22013: LIST
22014: LIST
22015: PUSH
22016: LD_INT 91
22018: PUSH
22019: LD_VAR 0 1
22023: PUSH
22024: LD_INT 18
22026: PUSH
22027: EMPTY
22028: LIST
22029: LIST
22030: LIST
22031: PUSH
22032: EMPTY
22033: LIST
22034: LIST
22035: LIST
22036: PPUSH
22037: CALL_OW 69
22041: NOT
22042: PUSH
22043: LD_INT 22
22045: PUSH
22046: LD_VAR 0 16
22050: PUSH
22051: EMPTY
22052: LIST
22053: LIST
22054: PUSH
22055: LD_INT 2
22057: PUSH
22058: LD_INT 30
22060: PUSH
22061: LD_INT 32
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: PUSH
22068: LD_INT 30
22070: PUSH
22071: LD_INT 33
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: PUSH
22078: EMPTY
22079: LIST
22080: LIST
22081: LIST
22082: PUSH
22083: LD_INT 91
22085: PUSH
22086: LD_VAR 0 1
22090: PUSH
22091: LD_INT 12
22093: PUSH
22094: EMPTY
22095: LIST
22096: LIST
22097: LIST
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: LIST
22103: PUSH
22104: EMPTY
22105: LIST
22106: PPUSH
22107: CALL_OW 69
22111: PUSH
22112: LD_INT 2
22114: GREATER
22115: AND
22116: IFFALSE 22139
// weapon := [ us_radar , ar_radar ] [ nat ] ;
22118: LD_ADDR_VAR 0 18
22122: PUSH
22123: LD_INT 11
22125: PUSH
22126: LD_INT 30
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: PUSH
22133: LD_VAR 0 12
22137: ARRAY
22138: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
22139: LD_VAR 0 18
22143: NOT
22144: PUSH
22145: LD_INT 40
22147: PPUSH
22148: LD_VAR 0 16
22152: PPUSH
22153: CALL_OW 321
22157: PUSH
22158: LD_INT 2
22160: EQUAL
22161: AND
22162: PUSH
22163: LD_INT 7
22165: PUSH
22166: LD_VAR 0 5
22170: IN
22171: PUSH
22172: LD_INT 28
22174: PUSH
22175: LD_VAR 0 5
22179: IN
22180: OR
22181: PUSH
22182: LD_INT 45
22184: PUSH
22185: LD_VAR 0 5
22189: IN
22190: OR
22191: AND
22192: IFFALSE 22446
// begin hex := GetHexInfo ( x , y ) ;
22194: LD_ADDR_VAR 0 4
22198: PUSH
22199: LD_VAR 0 10
22203: PPUSH
22204: LD_VAR 0 11
22208: PPUSH
22209: CALL_OW 546
22213: ST_TO_ADDR
// if hex [ 1 ] then
22214: LD_VAR 0 4
22218: PUSH
22219: LD_INT 1
22221: ARRAY
22222: IFFALSE 22226
// exit ;
22224: GO 22629
// height := hex [ 2 ] ;
22226: LD_ADDR_VAR 0 15
22230: PUSH
22231: LD_VAR 0 4
22235: PUSH
22236: LD_INT 2
22238: ARRAY
22239: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
22240: LD_ADDR_VAR 0 14
22244: PUSH
22245: LD_INT 0
22247: PUSH
22248: LD_INT 2
22250: PUSH
22251: LD_INT 3
22253: PUSH
22254: LD_INT 5
22256: PUSH
22257: EMPTY
22258: LIST
22259: LIST
22260: LIST
22261: LIST
22262: ST_TO_ADDR
// for i in tmp do
22263: LD_ADDR_VAR 0 8
22267: PUSH
22268: LD_VAR 0 14
22272: PUSH
22273: FOR_IN
22274: IFFALSE 22444
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
22276: LD_ADDR_VAR 0 9
22280: PUSH
22281: LD_VAR 0 10
22285: PPUSH
22286: LD_VAR 0 8
22290: PPUSH
22291: LD_INT 5
22293: PPUSH
22294: CALL_OW 272
22298: PUSH
22299: LD_VAR 0 11
22303: PPUSH
22304: LD_VAR 0 8
22308: PPUSH
22309: LD_INT 5
22311: PPUSH
22312: CALL_OW 273
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22321: LD_VAR 0 9
22325: PUSH
22326: LD_INT 1
22328: ARRAY
22329: PPUSH
22330: LD_VAR 0 9
22334: PUSH
22335: LD_INT 2
22337: ARRAY
22338: PPUSH
22339: CALL_OW 488
22343: IFFALSE 22442
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22345: LD_ADDR_VAR 0 4
22349: PUSH
22350: LD_VAR 0 9
22354: PUSH
22355: LD_INT 1
22357: ARRAY
22358: PPUSH
22359: LD_VAR 0 9
22363: PUSH
22364: LD_INT 2
22366: ARRAY
22367: PPUSH
22368: CALL_OW 546
22372: ST_TO_ADDR
// if hex [ 1 ] then
22373: LD_VAR 0 4
22377: PUSH
22378: LD_INT 1
22380: ARRAY
22381: IFFALSE 22385
// continue ;
22383: GO 22273
// h := hex [ 2 ] ;
22385: LD_ADDR_VAR 0 13
22389: PUSH
22390: LD_VAR 0 4
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: ST_TO_ADDR
// if h + 7 < height then
22399: LD_VAR 0 13
22403: PUSH
22404: LD_INT 7
22406: PLUS
22407: PUSH
22408: LD_VAR 0 15
22412: LESS
22413: IFFALSE 22442
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22415: LD_ADDR_VAR 0 18
22419: PUSH
22420: LD_INT 7
22422: PUSH
22423: LD_INT 28
22425: PUSH
22426: LD_INT 45
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: PUSH
22434: LD_VAR 0 12
22438: ARRAY
22439: ST_TO_ADDR
// break ;
22440: GO 22444
// end ; end ; end ;
22442: GO 22273
22444: POP
22445: POP
// end ; if not weapon then
22446: LD_VAR 0 18
22450: NOT
22451: IFFALSE 22511
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22453: LD_ADDR_VAR 0 5
22457: PUSH
22458: LD_VAR 0 5
22462: PUSH
22463: LD_INT 11
22465: PUSH
22466: LD_INT 30
22468: PUSH
22469: LD_INT 49
22471: PUSH
22472: EMPTY
22473: LIST
22474: LIST
22475: LIST
22476: DIFF
22477: ST_TO_ADDR
// if not list then
22478: LD_VAR 0 5
22482: NOT
22483: IFFALSE 22487
// exit ;
22485: GO 22629
// weapon := list [ rand ( 1 , list ) ] ;
22487: LD_ADDR_VAR 0 18
22491: PUSH
22492: LD_VAR 0 5
22496: PUSH
22497: LD_INT 1
22499: PPUSH
22500: LD_VAR 0 5
22504: PPUSH
22505: CALL_OW 12
22509: ARRAY
22510: ST_TO_ADDR
// end ; if weapon then
22511: LD_VAR 0 18
22515: IFFALSE 22629
// begin tmp := CostOfWeapon ( weapon ) ;
22517: LD_ADDR_VAR 0 14
22521: PUSH
22522: LD_VAR 0 18
22526: PPUSH
22527: CALL_OW 451
22531: ST_TO_ADDR
// j := GetBase ( tower ) ;
22532: LD_ADDR_VAR 0 9
22536: PUSH
22537: LD_VAR 0 1
22541: PPUSH
22542: CALL_OW 274
22546: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22547: LD_VAR 0 9
22551: PPUSH
22552: LD_INT 1
22554: PPUSH
22555: CALL_OW 275
22559: PUSH
22560: LD_VAR 0 14
22564: PUSH
22565: LD_INT 1
22567: ARRAY
22568: GREATEREQUAL
22569: PUSH
22570: LD_VAR 0 9
22574: PPUSH
22575: LD_INT 2
22577: PPUSH
22578: CALL_OW 275
22582: PUSH
22583: LD_VAR 0 14
22587: PUSH
22588: LD_INT 2
22590: ARRAY
22591: GREATEREQUAL
22592: AND
22593: PUSH
22594: LD_VAR 0 9
22598: PPUSH
22599: LD_INT 3
22601: PPUSH
22602: CALL_OW 275
22606: PUSH
22607: LD_VAR 0 14
22611: PUSH
22612: LD_INT 3
22614: ARRAY
22615: GREATEREQUAL
22616: AND
22617: IFFALSE 22629
// result := weapon ;
22619: LD_ADDR_VAR 0 3
22623: PUSH
22624: LD_VAR 0 18
22628: ST_TO_ADDR
// end ; end ;
22629: LD_VAR 0 3
22633: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22634: LD_INT 0
22636: PPUSH
22637: PPUSH
// result := true ;
22638: LD_ADDR_VAR 0 3
22642: PUSH
22643: LD_INT 1
22645: ST_TO_ADDR
// if array1 = array2 then
22646: LD_VAR 0 1
22650: PUSH
22651: LD_VAR 0 2
22655: EQUAL
22656: IFFALSE 22716
// begin for i = 1 to array1 do
22658: LD_ADDR_VAR 0 4
22662: PUSH
22663: DOUBLE
22664: LD_INT 1
22666: DEC
22667: ST_TO_ADDR
22668: LD_VAR 0 1
22672: PUSH
22673: FOR_TO
22674: IFFALSE 22712
// if array1 [ i ] <> array2 [ i ] then
22676: LD_VAR 0 1
22680: PUSH
22681: LD_VAR 0 4
22685: ARRAY
22686: PUSH
22687: LD_VAR 0 2
22691: PUSH
22692: LD_VAR 0 4
22696: ARRAY
22697: NONEQUAL
22698: IFFALSE 22710
// begin result := false ;
22700: LD_ADDR_VAR 0 3
22704: PUSH
22705: LD_INT 0
22707: ST_TO_ADDR
// break ;
22708: GO 22712
// end ;
22710: GO 22673
22712: POP
22713: POP
// end else
22714: GO 22724
// result := false ;
22716: LD_ADDR_VAR 0 3
22720: PUSH
22721: LD_INT 0
22723: ST_TO_ADDR
// end ;
22724: LD_VAR 0 3
22728: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22729: LD_INT 0
22731: PPUSH
22732: PPUSH
// if not array1 or not array2 then
22733: LD_VAR 0 1
22737: NOT
22738: PUSH
22739: LD_VAR 0 2
22743: NOT
22744: OR
22745: IFFALSE 22749
// exit ;
22747: GO 22813
// result := true ;
22749: LD_ADDR_VAR 0 3
22753: PUSH
22754: LD_INT 1
22756: ST_TO_ADDR
// for i = 1 to array1 do
22757: LD_ADDR_VAR 0 4
22761: PUSH
22762: DOUBLE
22763: LD_INT 1
22765: DEC
22766: ST_TO_ADDR
22767: LD_VAR 0 1
22771: PUSH
22772: FOR_TO
22773: IFFALSE 22811
// if array1 [ i ] <> array2 [ i ] then
22775: LD_VAR 0 1
22779: PUSH
22780: LD_VAR 0 4
22784: ARRAY
22785: PUSH
22786: LD_VAR 0 2
22790: PUSH
22791: LD_VAR 0 4
22795: ARRAY
22796: NONEQUAL
22797: IFFALSE 22809
// begin result := false ;
22799: LD_ADDR_VAR 0 3
22803: PUSH
22804: LD_INT 0
22806: ST_TO_ADDR
// break ;
22807: GO 22811
// end ;
22809: GO 22772
22811: POP
22812: POP
// end ;
22813: LD_VAR 0 3
22817: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22818: LD_INT 0
22820: PPUSH
22821: PPUSH
22822: PPUSH
// pom := GetBase ( fac ) ;
22823: LD_ADDR_VAR 0 5
22827: PUSH
22828: LD_VAR 0 1
22832: PPUSH
22833: CALL_OW 274
22837: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22838: LD_ADDR_VAR 0 4
22842: PUSH
22843: LD_VAR 0 2
22847: PUSH
22848: LD_INT 1
22850: ARRAY
22851: PPUSH
22852: LD_VAR 0 2
22856: PUSH
22857: LD_INT 2
22859: ARRAY
22860: PPUSH
22861: LD_VAR 0 2
22865: PUSH
22866: LD_INT 3
22868: ARRAY
22869: PPUSH
22870: LD_VAR 0 2
22874: PUSH
22875: LD_INT 4
22877: ARRAY
22878: PPUSH
22879: CALL_OW 449
22883: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22884: LD_ADDR_VAR 0 3
22888: PUSH
22889: LD_VAR 0 5
22893: PPUSH
22894: LD_INT 1
22896: PPUSH
22897: CALL_OW 275
22901: PUSH
22902: LD_VAR 0 4
22906: PUSH
22907: LD_INT 1
22909: ARRAY
22910: GREATEREQUAL
22911: PUSH
22912: LD_VAR 0 5
22916: PPUSH
22917: LD_INT 2
22919: PPUSH
22920: CALL_OW 275
22924: PUSH
22925: LD_VAR 0 4
22929: PUSH
22930: LD_INT 2
22932: ARRAY
22933: GREATEREQUAL
22934: AND
22935: PUSH
22936: LD_VAR 0 5
22940: PPUSH
22941: LD_INT 3
22943: PPUSH
22944: CALL_OW 275
22948: PUSH
22949: LD_VAR 0 4
22953: PUSH
22954: LD_INT 3
22956: ARRAY
22957: GREATEREQUAL
22958: AND
22959: ST_TO_ADDR
// end ;
22960: LD_VAR 0 3
22964: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22965: LD_INT 0
22967: PPUSH
22968: PPUSH
22969: PPUSH
22970: PPUSH
// pom := GetBase ( building ) ;
22971: LD_ADDR_VAR 0 3
22975: PUSH
22976: LD_VAR 0 1
22980: PPUSH
22981: CALL_OW 274
22985: ST_TO_ADDR
// if not pom then
22986: LD_VAR 0 3
22990: NOT
22991: IFFALSE 22995
// exit ;
22993: GO 23165
// btype := GetBType ( building ) ;
22995: LD_ADDR_VAR 0 5
22999: PUSH
23000: LD_VAR 0 1
23004: PPUSH
23005: CALL_OW 266
23009: ST_TO_ADDR
// if btype = b_armoury then
23010: LD_VAR 0 5
23014: PUSH
23015: LD_INT 4
23017: EQUAL
23018: IFFALSE 23028
// btype := b_barracks ;
23020: LD_ADDR_VAR 0 5
23024: PUSH
23025: LD_INT 5
23027: ST_TO_ADDR
// if btype = b_depot then
23028: LD_VAR 0 5
23032: PUSH
23033: LD_INT 0
23035: EQUAL
23036: IFFALSE 23046
// btype := b_warehouse ;
23038: LD_ADDR_VAR 0 5
23042: PUSH
23043: LD_INT 1
23045: ST_TO_ADDR
// if btype = b_workshop then
23046: LD_VAR 0 5
23050: PUSH
23051: LD_INT 2
23053: EQUAL
23054: IFFALSE 23064
// btype := b_factory ;
23056: LD_ADDR_VAR 0 5
23060: PUSH
23061: LD_INT 3
23063: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
23064: LD_ADDR_VAR 0 4
23068: PUSH
23069: LD_VAR 0 5
23073: PPUSH
23074: LD_VAR 0 1
23078: PPUSH
23079: CALL_OW 248
23083: PPUSH
23084: CALL_OW 450
23088: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23089: LD_ADDR_VAR 0 2
23093: PUSH
23094: LD_VAR 0 3
23098: PPUSH
23099: LD_INT 1
23101: PPUSH
23102: CALL_OW 275
23106: PUSH
23107: LD_VAR 0 4
23111: PUSH
23112: LD_INT 1
23114: ARRAY
23115: GREATEREQUAL
23116: PUSH
23117: LD_VAR 0 3
23121: PPUSH
23122: LD_INT 2
23124: PPUSH
23125: CALL_OW 275
23129: PUSH
23130: LD_VAR 0 4
23134: PUSH
23135: LD_INT 2
23137: ARRAY
23138: GREATEREQUAL
23139: AND
23140: PUSH
23141: LD_VAR 0 3
23145: PPUSH
23146: LD_INT 3
23148: PPUSH
23149: CALL_OW 275
23153: PUSH
23154: LD_VAR 0 4
23158: PUSH
23159: LD_INT 3
23161: ARRAY
23162: GREATEREQUAL
23163: AND
23164: ST_TO_ADDR
// end ;
23165: LD_VAR 0 2
23169: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
23170: LD_INT 0
23172: PPUSH
23173: PPUSH
23174: PPUSH
// pom := GetBase ( building ) ;
23175: LD_ADDR_VAR 0 4
23179: PUSH
23180: LD_VAR 0 1
23184: PPUSH
23185: CALL_OW 274
23189: ST_TO_ADDR
// if not pom then
23190: LD_VAR 0 4
23194: NOT
23195: IFFALSE 23199
// exit ;
23197: GO 23300
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
23199: LD_ADDR_VAR 0 5
23203: PUSH
23204: LD_VAR 0 2
23208: PPUSH
23209: LD_VAR 0 1
23213: PPUSH
23214: CALL_OW 248
23218: PPUSH
23219: CALL_OW 450
23223: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23224: LD_ADDR_VAR 0 3
23228: PUSH
23229: LD_VAR 0 4
23233: PPUSH
23234: LD_INT 1
23236: PPUSH
23237: CALL_OW 275
23241: PUSH
23242: LD_VAR 0 5
23246: PUSH
23247: LD_INT 1
23249: ARRAY
23250: GREATEREQUAL
23251: PUSH
23252: LD_VAR 0 4
23256: PPUSH
23257: LD_INT 2
23259: PPUSH
23260: CALL_OW 275
23264: PUSH
23265: LD_VAR 0 5
23269: PUSH
23270: LD_INT 2
23272: ARRAY
23273: GREATEREQUAL
23274: AND
23275: PUSH
23276: LD_VAR 0 4
23280: PPUSH
23281: LD_INT 3
23283: PPUSH
23284: CALL_OW 275
23288: PUSH
23289: LD_VAR 0 5
23293: PUSH
23294: LD_INT 3
23296: ARRAY
23297: GREATEREQUAL
23298: AND
23299: ST_TO_ADDR
// end ;
23300: LD_VAR 0 3
23304: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23305: LD_INT 0
23307: PPUSH
23308: PPUSH
23309: PPUSH
23310: PPUSH
23311: PPUSH
23312: PPUSH
23313: PPUSH
23314: PPUSH
23315: PPUSH
23316: PPUSH
23317: PPUSH
// result := false ;
23318: LD_ADDR_VAR 0 8
23322: PUSH
23323: LD_INT 0
23325: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23326: LD_VAR 0 5
23330: NOT
23331: PUSH
23332: LD_VAR 0 1
23336: NOT
23337: OR
23338: PUSH
23339: LD_VAR 0 2
23343: NOT
23344: OR
23345: PUSH
23346: LD_VAR 0 3
23350: NOT
23351: OR
23352: IFFALSE 23356
// exit ;
23354: GO 24170
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23356: LD_ADDR_VAR 0 14
23360: PUSH
23361: LD_VAR 0 1
23365: PPUSH
23366: LD_VAR 0 2
23370: PPUSH
23371: LD_VAR 0 3
23375: PPUSH
23376: LD_VAR 0 4
23380: PPUSH
23381: LD_VAR 0 5
23385: PUSH
23386: LD_INT 1
23388: ARRAY
23389: PPUSH
23390: CALL_OW 248
23394: PPUSH
23395: LD_INT 0
23397: PPUSH
23398: CALL 25423 0 6
23402: ST_TO_ADDR
// if not hexes then
23403: LD_VAR 0 14
23407: NOT
23408: IFFALSE 23412
// exit ;
23410: GO 24170
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23412: LD_ADDR_VAR 0 17
23416: PUSH
23417: LD_VAR 0 5
23421: PPUSH
23422: LD_INT 22
23424: PUSH
23425: LD_VAR 0 13
23429: PPUSH
23430: CALL_OW 255
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: PUSH
23439: LD_INT 2
23441: PUSH
23442: LD_INT 30
23444: PUSH
23445: LD_INT 0
23447: PUSH
23448: EMPTY
23449: LIST
23450: LIST
23451: PUSH
23452: LD_INT 30
23454: PUSH
23455: LD_INT 1
23457: PUSH
23458: EMPTY
23459: LIST
23460: LIST
23461: PUSH
23462: EMPTY
23463: LIST
23464: LIST
23465: LIST
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 72
23475: ST_TO_ADDR
// for i = 1 to hexes do
23476: LD_ADDR_VAR 0 9
23480: PUSH
23481: DOUBLE
23482: LD_INT 1
23484: DEC
23485: ST_TO_ADDR
23486: LD_VAR 0 14
23490: PUSH
23491: FOR_TO
23492: IFFALSE 24168
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23494: LD_ADDR_VAR 0 13
23498: PUSH
23499: LD_VAR 0 14
23503: PUSH
23504: LD_VAR 0 9
23508: ARRAY
23509: PUSH
23510: LD_INT 1
23512: ARRAY
23513: PPUSH
23514: LD_VAR 0 14
23518: PUSH
23519: LD_VAR 0 9
23523: ARRAY
23524: PUSH
23525: LD_INT 2
23527: ARRAY
23528: PPUSH
23529: CALL_OW 428
23533: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23534: LD_VAR 0 14
23538: PUSH
23539: LD_VAR 0 9
23543: ARRAY
23544: PUSH
23545: LD_INT 1
23547: ARRAY
23548: PPUSH
23549: LD_VAR 0 14
23553: PUSH
23554: LD_VAR 0 9
23558: ARRAY
23559: PUSH
23560: LD_INT 2
23562: ARRAY
23563: PPUSH
23564: CALL_OW 351
23568: PUSH
23569: LD_VAR 0 14
23573: PUSH
23574: LD_VAR 0 9
23578: ARRAY
23579: PUSH
23580: LD_INT 1
23582: ARRAY
23583: PPUSH
23584: LD_VAR 0 14
23588: PUSH
23589: LD_VAR 0 9
23593: ARRAY
23594: PUSH
23595: LD_INT 2
23597: ARRAY
23598: PPUSH
23599: CALL_OW 488
23603: NOT
23604: OR
23605: PUSH
23606: LD_VAR 0 13
23610: PPUSH
23611: CALL_OW 247
23615: PUSH
23616: LD_INT 3
23618: EQUAL
23619: OR
23620: IFFALSE 23626
// exit ;
23622: POP
23623: POP
23624: GO 24170
// if not tmp then
23626: LD_VAR 0 13
23630: NOT
23631: IFFALSE 23635
// continue ;
23633: GO 23491
// result := true ;
23635: LD_ADDR_VAR 0 8
23639: PUSH
23640: LD_INT 1
23642: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23643: LD_VAR 0 6
23647: PUSH
23648: LD_VAR 0 13
23652: PPUSH
23653: CALL_OW 247
23657: PUSH
23658: LD_INT 2
23660: EQUAL
23661: AND
23662: PUSH
23663: LD_VAR 0 13
23667: PPUSH
23668: CALL_OW 263
23672: PUSH
23673: LD_INT 1
23675: EQUAL
23676: AND
23677: IFFALSE 23841
// begin if IsDrivenBy ( tmp ) then
23679: LD_VAR 0 13
23683: PPUSH
23684: CALL_OW 311
23688: IFFALSE 23692
// continue ;
23690: GO 23491
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23692: LD_VAR 0 6
23696: PPUSH
23697: LD_INT 3
23699: PUSH
23700: LD_INT 60
23702: PUSH
23703: EMPTY
23704: LIST
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: PUSH
23710: LD_INT 3
23712: PUSH
23713: LD_INT 55
23715: PUSH
23716: EMPTY
23717: LIST
23718: PUSH
23719: EMPTY
23720: LIST
23721: LIST
23722: PUSH
23723: EMPTY
23724: LIST
23725: LIST
23726: PPUSH
23727: CALL_OW 72
23731: IFFALSE 23839
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23733: LD_ADDR_VAR 0 18
23737: PUSH
23738: LD_VAR 0 6
23742: PPUSH
23743: LD_INT 3
23745: PUSH
23746: LD_INT 60
23748: PUSH
23749: EMPTY
23750: LIST
23751: PUSH
23752: EMPTY
23753: LIST
23754: LIST
23755: PUSH
23756: LD_INT 3
23758: PUSH
23759: LD_INT 55
23761: PUSH
23762: EMPTY
23763: LIST
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: EMPTY
23770: LIST
23771: LIST
23772: PPUSH
23773: CALL_OW 72
23777: PUSH
23778: LD_INT 1
23780: ARRAY
23781: ST_TO_ADDR
// if IsInUnit ( driver ) then
23782: LD_VAR 0 18
23786: PPUSH
23787: CALL_OW 310
23791: IFFALSE 23802
// ComExit ( driver ) ;
23793: LD_VAR 0 18
23797: PPUSH
23798: CALL 49204 0 1
// AddComEnterUnit ( driver , tmp ) ;
23802: LD_VAR 0 18
23806: PPUSH
23807: LD_VAR 0 13
23811: PPUSH
23812: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23816: LD_VAR 0 18
23820: PPUSH
23821: LD_VAR 0 7
23825: PPUSH
23826: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23830: LD_VAR 0 18
23834: PPUSH
23835: CALL_OW 181
// end ; continue ;
23839: GO 23491
// end ; if not cleaners or not tmp in cleaners then
23841: LD_VAR 0 6
23845: NOT
23846: PUSH
23847: LD_VAR 0 13
23851: PUSH
23852: LD_VAR 0 6
23856: IN
23857: NOT
23858: OR
23859: IFFALSE 24166
// begin if dep then
23861: LD_VAR 0 17
23865: IFFALSE 24001
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23867: LD_ADDR_VAR 0 16
23871: PUSH
23872: LD_VAR 0 17
23876: PUSH
23877: LD_INT 1
23879: ARRAY
23880: PPUSH
23881: CALL_OW 250
23885: PPUSH
23886: LD_VAR 0 17
23890: PUSH
23891: LD_INT 1
23893: ARRAY
23894: PPUSH
23895: CALL_OW 254
23899: PPUSH
23900: LD_INT 5
23902: PPUSH
23903: CALL_OW 272
23907: PUSH
23908: LD_VAR 0 17
23912: PUSH
23913: LD_INT 1
23915: ARRAY
23916: PPUSH
23917: CALL_OW 251
23921: PPUSH
23922: LD_VAR 0 17
23926: PUSH
23927: LD_INT 1
23929: ARRAY
23930: PPUSH
23931: CALL_OW 254
23935: PPUSH
23936: LD_INT 5
23938: PPUSH
23939: CALL_OW 273
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23948: LD_VAR 0 16
23952: PUSH
23953: LD_INT 1
23955: ARRAY
23956: PPUSH
23957: LD_VAR 0 16
23961: PUSH
23962: LD_INT 2
23964: ARRAY
23965: PPUSH
23966: CALL_OW 488
23970: IFFALSE 24001
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23972: LD_VAR 0 13
23976: PPUSH
23977: LD_VAR 0 16
23981: PUSH
23982: LD_INT 1
23984: ARRAY
23985: PPUSH
23986: LD_VAR 0 16
23990: PUSH
23991: LD_INT 2
23993: ARRAY
23994: PPUSH
23995: CALL_OW 111
// continue ;
23999: GO 23491
// end ; end ; r := GetDir ( tmp ) ;
24001: LD_ADDR_VAR 0 15
24005: PUSH
24006: LD_VAR 0 13
24010: PPUSH
24011: CALL_OW 254
24015: ST_TO_ADDR
// if r = 5 then
24016: LD_VAR 0 15
24020: PUSH
24021: LD_INT 5
24023: EQUAL
24024: IFFALSE 24034
// r := 0 ;
24026: LD_ADDR_VAR 0 15
24030: PUSH
24031: LD_INT 0
24033: ST_TO_ADDR
// for j = r to 5 do
24034: LD_ADDR_VAR 0 10
24038: PUSH
24039: DOUBLE
24040: LD_VAR 0 15
24044: DEC
24045: ST_TO_ADDR
24046: LD_INT 5
24048: PUSH
24049: FOR_TO
24050: IFFALSE 24164
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
24052: LD_ADDR_VAR 0 11
24056: PUSH
24057: LD_VAR 0 13
24061: PPUSH
24062: CALL_OW 250
24066: PPUSH
24067: LD_VAR 0 10
24071: PPUSH
24072: LD_INT 2
24074: PPUSH
24075: CALL_OW 272
24079: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
24080: LD_ADDR_VAR 0 12
24084: PUSH
24085: LD_VAR 0 13
24089: PPUSH
24090: CALL_OW 251
24094: PPUSH
24095: LD_VAR 0 10
24099: PPUSH
24100: LD_INT 2
24102: PPUSH
24103: CALL_OW 273
24107: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
24108: LD_VAR 0 11
24112: PPUSH
24113: LD_VAR 0 12
24117: PPUSH
24118: CALL_OW 488
24122: PUSH
24123: LD_VAR 0 11
24127: PPUSH
24128: LD_VAR 0 12
24132: PPUSH
24133: CALL_OW 428
24137: NOT
24138: AND
24139: IFFALSE 24162
// begin ComMoveXY ( tmp , _x , _y ) ;
24141: LD_VAR 0 13
24145: PPUSH
24146: LD_VAR 0 11
24150: PPUSH
24151: LD_VAR 0 12
24155: PPUSH
24156: CALL_OW 111
// break ;
24160: GO 24164
// end ; end ;
24162: GO 24049
24164: POP
24165: POP
// end ; end ;
24166: GO 23491
24168: POP
24169: POP
// end ;
24170: LD_VAR 0 8
24174: RET
// export function BuildingTechInvented ( side , btype ) ; begin
24175: LD_INT 0
24177: PPUSH
// result := true ;
24178: LD_ADDR_VAR 0 3
24182: PUSH
24183: LD_INT 1
24185: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
24186: LD_VAR 0 2
24190: PUSH
24191: LD_INT 24
24193: DOUBLE
24194: EQUAL
24195: IFTRUE 24205
24197: LD_INT 33
24199: DOUBLE
24200: EQUAL
24201: IFTRUE 24205
24203: GO 24230
24205: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
24206: LD_ADDR_VAR 0 3
24210: PUSH
24211: LD_INT 32
24213: PPUSH
24214: LD_VAR 0 1
24218: PPUSH
24219: CALL_OW 321
24223: PUSH
24224: LD_INT 2
24226: EQUAL
24227: ST_TO_ADDR
24228: GO 24546
24230: LD_INT 20
24232: DOUBLE
24233: EQUAL
24234: IFTRUE 24238
24236: GO 24263
24238: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
24239: LD_ADDR_VAR 0 3
24243: PUSH
24244: LD_INT 6
24246: PPUSH
24247: LD_VAR 0 1
24251: PPUSH
24252: CALL_OW 321
24256: PUSH
24257: LD_INT 2
24259: EQUAL
24260: ST_TO_ADDR
24261: GO 24546
24263: LD_INT 22
24265: DOUBLE
24266: EQUAL
24267: IFTRUE 24277
24269: LD_INT 36
24271: DOUBLE
24272: EQUAL
24273: IFTRUE 24277
24275: GO 24302
24277: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
24278: LD_ADDR_VAR 0 3
24282: PUSH
24283: LD_INT 15
24285: PPUSH
24286: LD_VAR 0 1
24290: PPUSH
24291: CALL_OW 321
24295: PUSH
24296: LD_INT 2
24298: EQUAL
24299: ST_TO_ADDR
24300: GO 24546
24302: LD_INT 30
24304: DOUBLE
24305: EQUAL
24306: IFTRUE 24310
24308: GO 24335
24310: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24311: LD_ADDR_VAR 0 3
24315: PUSH
24316: LD_INT 20
24318: PPUSH
24319: LD_VAR 0 1
24323: PPUSH
24324: CALL_OW 321
24328: PUSH
24329: LD_INT 2
24331: EQUAL
24332: ST_TO_ADDR
24333: GO 24546
24335: LD_INT 28
24337: DOUBLE
24338: EQUAL
24339: IFTRUE 24349
24341: LD_INT 21
24343: DOUBLE
24344: EQUAL
24345: IFTRUE 24349
24347: GO 24374
24349: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24350: LD_ADDR_VAR 0 3
24354: PUSH
24355: LD_INT 21
24357: PPUSH
24358: LD_VAR 0 1
24362: PPUSH
24363: CALL_OW 321
24367: PUSH
24368: LD_INT 2
24370: EQUAL
24371: ST_TO_ADDR
24372: GO 24546
24374: LD_INT 16
24376: DOUBLE
24377: EQUAL
24378: IFTRUE 24382
24380: GO 24407
24382: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24383: LD_ADDR_VAR 0 3
24387: PUSH
24388: LD_INT 84
24390: PPUSH
24391: LD_VAR 0 1
24395: PPUSH
24396: CALL_OW 321
24400: PUSH
24401: LD_INT 2
24403: EQUAL
24404: ST_TO_ADDR
24405: GO 24546
24407: LD_INT 19
24409: DOUBLE
24410: EQUAL
24411: IFTRUE 24421
24413: LD_INT 23
24415: DOUBLE
24416: EQUAL
24417: IFTRUE 24421
24419: GO 24446
24421: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24422: LD_ADDR_VAR 0 3
24426: PUSH
24427: LD_INT 83
24429: PPUSH
24430: LD_VAR 0 1
24434: PPUSH
24435: CALL_OW 321
24439: PUSH
24440: LD_INT 2
24442: EQUAL
24443: ST_TO_ADDR
24444: GO 24546
24446: LD_INT 17
24448: DOUBLE
24449: EQUAL
24450: IFTRUE 24454
24452: GO 24479
24454: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24455: LD_ADDR_VAR 0 3
24459: PUSH
24460: LD_INT 39
24462: PPUSH
24463: LD_VAR 0 1
24467: PPUSH
24468: CALL_OW 321
24472: PUSH
24473: LD_INT 2
24475: EQUAL
24476: ST_TO_ADDR
24477: GO 24546
24479: LD_INT 18
24481: DOUBLE
24482: EQUAL
24483: IFTRUE 24487
24485: GO 24512
24487: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24488: LD_ADDR_VAR 0 3
24492: PUSH
24493: LD_INT 40
24495: PPUSH
24496: LD_VAR 0 1
24500: PPUSH
24501: CALL_OW 321
24505: PUSH
24506: LD_INT 2
24508: EQUAL
24509: ST_TO_ADDR
24510: GO 24546
24512: LD_INT 27
24514: DOUBLE
24515: EQUAL
24516: IFTRUE 24520
24518: GO 24545
24520: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24521: LD_ADDR_VAR 0 3
24525: PUSH
24526: LD_INT 35
24528: PPUSH
24529: LD_VAR 0 1
24533: PPUSH
24534: CALL_OW 321
24538: PUSH
24539: LD_INT 2
24541: EQUAL
24542: ST_TO_ADDR
24543: GO 24546
24545: POP
// end ;
24546: LD_VAR 0 3
24550: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24551: LD_INT 0
24553: PPUSH
24554: PPUSH
24555: PPUSH
24556: PPUSH
24557: PPUSH
24558: PPUSH
24559: PPUSH
24560: PPUSH
24561: PPUSH
24562: PPUSH
24563: PPUSH
// result := false ;
24564: LD_ADDR_VAR 0 6
24568: PUSH
24569: LD_INT 0
24571: ST_TO_ADDR
// if btype = b_depot then
24572: LD_VAR 0 2
24576: PUSH
24577: LD_INT 0
24579: EQUAL
24580: IFFALSE 24592
// begin result := true ;
24582: LD_ADDR_VAR 0 6
24586: PUSH
24587: LD_INT 1
24589: ST_TO_ADDR
// exit ;
24590: GO 25418
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24592: LD_VAR 0 1
24596: NOT
24597: PUSH
24598: LD_VAR 0 1
24602: PPUSH
24603: CALL_OW 266
24607: PUSH
24608: LD_INT 0
24610: PUSH
24611: LD_INT 1
24613: PUSH
24614: EMPTY
24615: LIST
24616: LIST
24617: IN
24618: NOT
24619: OR
24620: PUSH
24621: LD_VAR 0 2
24625: NOT
24626: OR
24627: PUSH
24628: LD_VAR 0 5
24632: PUSH
24633: LD_INT 0
24635: PUSH
24636: LD_INT 1
24638: PUSH
24639: LD_INT 2
24641: PUSH
24642: LD_INT 3
24644: PUSH
24645: LD_INT 4
24647: PUSH
24648: LD_INT 5
24650: PUSH
24651: EMPTY
24652: LIST
24653: LIST
24654: LIST
24655: LIST
24656: LIST
24657: LIST
24658: IN
24659: NOT
24660: OR
24661: PUSH
24662: LD_VAR 0 3
24666: PPUSH
24667: LD_VAR 0 4
24671: PPUSH
24672: CALL_OW 488
24676: NOT
24677: OR
24678: IFFALSE 24682
// exit ;
24680: GO 25418
// side := GetSide ( depot ) ;
24682: LD_ADDR_VAR 0 9
24686: PUSH
24687: LD_VAR 0 1
24691: PPUSH
24692: CALL_OW 255
24696: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24697: LD_VAR 0 9
24701: PPUSH
24702: LD_VAR 0 2
24706: PPUSH
24707: CALL 24175 0 2
24711: NOT
24712: IFFALSE 24716
// exit ;
24714: GO 25418
// pom := GetBase ( depot ) ;
24716: LD_ADDR_VAR 0 10
24720: PUSH
24721: LD_VAR 0 1
24725: PPUSH
24726: CALL_OW 274
24730: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24731: LD_ADDR_VAR 0 11
24735: PUSH
24736: LD_VAR 0 2
24740: PPUSH
24741: LD_VAR 0 1
24745: PPUSH
24746: CALL_OW 248
24750: PPUSH
24751: CALL_OW 450
24755: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24756: LD_VAR 0 10
24760: PPUSH
24761: LD_INT 1
24763: PPUSH
24764: CALL_OW 275
24768: PUSH
24769: LD_VAR 0 11
24773: PUSH
24774: LD_INT 1
24776: ARRAY
24777: GREATEREQUAL
24778: PUSH
24779: LD_VAR 0 10
24783: PPUSH
24784: LD_INT 2
24786: PPUSH
24787: CALL_OW 275
24791: PUSH
24792: LD_VAR 0 11
24796: PUSH
24797: LD_INT 2
24799: ARRAY
24800: GREATEREQUAL
24801: AND
24802: PUSH
24803: LD_VAR 0 10
24807: PPUSH
24808: LD_INT 3
24810: PPUSH
24811: CALL_OW 275
24815: PUSH
24816: LD_VAR 0 11
24820: PUSH
24821: LD_INT 3
24823: ARRAY
24824: GREATEREQUAL
24825: AND
24826: NOT
24827: IFFALSE 24831
// exit ;
24829: GO 25418
// if GetBType ( depot ) = b_depot then
24831: LD_VAR 0 1
24835: PPUSH
24836: CALL_OW 266
24840: PUSH
24841: LD_INT 0
24843: EQUAL
24844: IFFALSE 24856
// dist := 28 else
24846: LD_ADDR_VAR 0 14
24850: PUSH
24851: LD_INT 28
24853: ST_TO_ADDR
24854: GO 24864
// dist := 36 ;
24856: LD_ADDR_VAR 0 14
24860: PUSH
24861: LD_INT 36
24863: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24864: LD_VAR 0 1
24868: PPUSH
24869: LD_VAR 0 3
24873: PPUSH
24874: LD_VAR 0 4
24878: PPUSH
24879: CALL_OW 297
24883: PUSH
24884: LD_VAR 0 14
24888: GREATER
24889: IFFALSE 24893
// exit ;
24891: GO 25418
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24893: LD_ADDR_VAR 0 12
24897: PUSH
24898: LD_VAR 0 2
24902: PPUSH
24903: LD_VAR 0 3
24907: PPUSH
24908: LD_VAR 0 4
24912: PPUSH
24913: LD_VAR 0 5
24917: PPUSH
24918: LD_VAR 0 1
24922: PPUSH
24923: CALL_OW 248
24927: PPUSH
24928: LD_INT 0
24930: PPUSH
24931: CALL 25423 0 6
24935: ST_TO_ADDR
// if not hexes then
24936: LD_VAR 0 12
24940: NOT
24941: IFFALSE 24945
// exit ;
24943: GO 25418
// hex := GetHexInfo ( x , y ) ;
24945: LD_ADDR_VAR 0 15
24949: PUSH
24950: LD_VAR 0 3
24954: PPUSH
24955: LD_VAR 0 4
24959: PPUSH
24960: CALL_OW 546
24964: ST_TO_ADDR
// if hex [ 1 ] then
24965: LD_VAR 0 15
24969: PUSH
24970: LD_INT 1
24972: ARRAY
24973: IFFALSE 24977
// exit ;
24975: GO 25418
// height := hex [ 2 ] ;
24977: LD_ADDR_VAR 0 13
24981: PUSH
24982: LD_VAR 0 15
24986: PUSH
24987: LD_INT 2
24989: ARRAY
24990: ST_TO_ADDR
// for i = 1 to hexes do
24991: LD_ADDR_VAR 0 7
24995: PUSH
24996: DOUBLE
24997: LD_INT 1
24999: DEC
25000: ST_TO_ADDR
25001: LD_VAR 0 12
25005: PUSH
25006: FOR_TO
25007: IFFALSE 25337
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
25009: LD_VAR 0 12
25013: PUSH
25014: LD_VAR 0 7
25018: ARRAY
25019: PUSH
25020: LD_INT 1
25022: ARRAY
25023: PPUSH
25024: LD_VAR 0 12
25028: PUSH
25029: LD_VAR 0 7
25033: ARRAY
25034: PUSH
25035: LD_INT 2
25037: ARRAY
25038: PPUSH
25039: CALL_OW 488
25043: NOT
25044: PUSH
25045: LD_VAR 0 12
25049: PUSH
25050: LD_VAR 0 7
25054: ARRAY
25055: PUSH
25056: LD_INT 1
25058: ARRAY
25059: PPUSH
25060: LD_VAR 0 12
25064: PUSH
25065: LD_VAR 0 7
25069: ARRAY
25070: PUSH
25071: LD_INT 2
25073: ARRAY
25074: PPUSH
25075: CALL_OW 428
25079: PUSH
25080: LD_INT 0
25082: GREATER
25083: OR
25084: PUSH
25085: LD_VAR 0 12
25089: PUSH
25090: LD_VAR 0 7
25094: ARRAY
25095: PUSH
25096: LD_INT 1
25098: ARRAY
25099: PPUSH
25100: LD_VAR 0 12
25104: PUSH
25105: LD_VAR 0 7
25109: ARRAY
25110: PUSH
25111: LD_INT 2
25113: ARRAY
25114: PPUSH
25115: CALL_OW 351
25119: OR
25120: IFFALSE 25126
// exit ;
25122: POP
25123: POP
25124: GO 25418
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25126: LD_ADDR_VAR 0 8
25130: PUSH
25131: LD_VAR 0 12
25135: PUSH
25136: LD_VAR 0 7
25140: ARRAY
25141: PUSH
25142: LD_INT 1
25144: ARRAY
25145: PPUSH
25146: LD_VAR 0 12
25150: PUSH
25151: LD_VAR 0 7
25155: ARRAY
25156: PUSH
25157: LD_INT 2
25159: ARRAY
25160: PPUSH
25161: CALL_OW 546
25165: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
25166: LD_VAR 0 8
25170: PUSH
25171: LD_INT 1
25173: ARRAY
25174: PUSH
25175: LD_VAR 0 8
25179: PUSH
25180: LD_INT 2
25182: ARRAY
25183: PUSH
25184: LD_VAR 0 13
25188: PUSH
25189: LD_INT 2
25191: PLUS
25192: GREATER
25193: OR
25194: PUSH
25195: LD_VAR 0 8
25199: PUSH
25200: LD_INT 2
25202: ARRAY
25203: PUSH
25204: LD_VAR 0 13
25208: PUSH
25209: LD_INT 2
25211: MINUS
25212: LESS
25213: OR
25214: PUSH
25215: LD_VAR 0 8
25219: PUSH
25220: LD_INT 3
25222: ARRAY
25223: PUSH
25224: LD_INT 0
25226: PUSH
25227: LD_INT 8
25229: PUSH
25230: LD_INT 9
25232: PUSH
25233: LD_INT 10
25235: PUSH
25236: LD_INT 11
25238: PUSH
25239: LD_INT 12
25241: PUSH
25242: LD_INT 13
25244: PUSH
25245: LD_INT 16
25247: PUSH
25248: LD_INT 17
25250: PUSH
25251: LD_INT 18
25253: PUSH
25254: LD_INT 19
25256: PUSH
25257: LD_INT 20
25259: PUSH
25260: LD_INT 21
25262: PUSH
25263: EMPTY
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: LIST
25270: LIST
25271: LIST
25272: LIST
25273: LIST
25274: LIST
25275: LIST
25276: LIST
25277: IN
25278: NOT
25279: OR
25280: PUSH
25281: LD_VAR 0 8
25285: PUSH
25286: LD_INT 5
25288: ARRAY
25289: NOT
25290: OR
25291: PUSH
25292: LD_VAR 0 8
25296: PUSH
25297: LD_INT 6
25299: ARRAY
25300: PUSH
25301: LD_INT 1
25303: PUSH
25304: LD_INT 2
25306: PUSH
25307: LD_INT 7
25309: PUSH
25310: LD_INT 9
25312: PUSH
25313: LD_INT 10
25315: PUSH
25316: LD_INT 11
25318: PUSH
25319: EMPTY
25320: LIST
25321: LIST
25322: LIST
25323: LIST
25324: LIST
25325: LIST
25326: IN
25327: NOT
25328: OR
25329: IFFALSE 25335
// exit ;
25331: POP
25332: POP
25333: GO 25418
// end ;
25335: GO 25006
25337: POP
25338: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25339: LD_VAR 0 9
25343: PPUSH
25344: LD_VAR 0 3
25348: PPUSH
25349: LD_VAR 0 4
25353: PPUSH
25354: LD_INT 20
25356: PPUSH
25357: CALL 17341 0 4
25361: PUSH
25362: LD_INT 4
25364: ARRAY
25365: IFFALSE 25369
// exit ;
25367: GO 25418
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25369: LD_VAR 0 2
25373: PUSH
25374: LD_INT 29
25376: PUSH
25377: LD_INT 30
25379: PUSH
25380: EMPTY
25381: LIST
25382: LIST
25383: IN
25384: PUSH
25385: LD_VAR 0 3
25389: PPUSH
25390: LD_VAR 0 4
25394: PPUSH
25395: LD_VAR 0 9
25399: PPUSH
25400: CALL_OW 440
25404: NOT
25405: AND
25406: IFFALSE 25410
// exit ;
25408: GO 25418
// result := true ;
25410: LD_ADDR_VAR 0 6
25414: PUSH
25415: LD_INT 1
25417: ST_TO_ADDR
// end ;
25418: LD_VAR 0 6
25422: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25423: LD_INT 0
25425: PPUSH
25426: PPUSH
25427: PPUSH
25428: PPUSH
25429: PPUSH
25430: PPUSH
25431: PPUSH
25432: PPUSH
25433: PPUSH
25434: PPUSH
25435: PPUSH
25436: PPUSH
25437: PPUSH
25438: PPUSH
25439: PPUSH
25440: PPUSH
25441: PPUSH
25442: PPUSH
25443: PPUSH
25444: PPUSH
25445: PPUSH
25446: PPUSH
25447: PPUSH
25448: PPUSH
25449: PPUSH
25450: PPUSH
25451: PPUSH
25452: PPUSH
25453: PPUSH
25454: PPUSH
25455: PPUSH
25456: PPUSH
25457: PPUSH
25458: PPUSH
25459: PPUSH
25460: PPUSH
25461: PPUSH
25462: PPUSH
25463: PPUSH
25464: PPUSH
25465: PPUSH
25466: PPUSH
25467: PPUSH
25468: PPUSH
25469: PPUSH
25470: PPUSH
25471: PPUSH
25472: PPUSH
25473: PPUSH
25474: PPUSH
25475: PPUSH
25476: PPUSH
25477: PPUSH
25478: PPUSH
25479: PPUSH
25480: PPUSH
25481: PPUSH
25482: PPUSH
// result = [ ] ;
25483: LD_ADDR_VAR 0 7
25487: PUSH
25488: EMPTY
25489: ST_TO_ADDR
// temp_list = [ ] ;
25490: LD_ADDR_VAR 0 9
25494: PUSH
25495: EMPTY
25496: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25497: LD_VAR 0 4
25501: PUSH
25502: LD_INT 0
25504: PUSH
25505: LD_INT 1
25507: PUSH
25508: LD_INT 2
25510: PUSH
25511: LD_INT 3
25513: PUSH
25514: LD_INT 4
25516: PUSH
25517: LD_INT 5
25519: PUSH
25520: EMPTY
25521: LIST
25522: LIST
25523: LIST
25524: LIST
25525: LIST
25526: LIST
25527: IN
25528: NOT
25529: PUSH
25530: LD_VAR 0 1
25534: PUSH
25535: LD_INT 0
25537: PUSH
25538: LD_INT 1
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: IN
25545: PUSH
25546: LD_VAR 0 5
25550: PUSH
25551: LD_INT 1
25553: PUSH
25554: LD_INT 2
25556: PUSH
25557: LD_INT 3
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: LIST
25564: IN
25565: NOT
25566: AND
25567: OR
25568: IFFALSE 25572
// exit ;
25570: GO 43963
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25572: LD_VAR 0 1
25576: PUSH
25577: LD_INT 6
25579: PUSH
25580: LD_INT 7
25582: PUSH
25583: LD_INT 8
25585: PUSH
25586: LD_INT 13
25588: PUSH
25589: LD_INT 12
25591: PUSH
25592: LD_INT 15
25594: PUSH
25595: LD_INT 11
25597: PUSH
25598: LD_INT 14
25600: PUSH
25601: LD_INT 10
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: LIST
25613: LIST
25614: IN
25615: IFFALSE 25625
// btype = b_lab ;
25617: LD_ADDR_VAR 0 1
25621: PUSH
25622: LD_INT 6
25624: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25625: LD_VAR 0 6
25629: PUSH
25630: LD_INT 0
25632: PUSH
25633: LD_INT 1
25635: PUSH
25636: LD_INT 2
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: LIST
25643: IN
25644: NOT
25645: PUSH
25646: LD_VAR 0 1
25650: PUSH
25651: LD_INT 0
25653: PUSH
25654: LD_INT 1
25656: PUSH
25657: LD_INT 2
25659: PUSH
25660: LD_INT 3
25662: PUSH
25663: LD_INT 6
25665: PUSH
25666: LD_INT 36
25668: PUSH
25669: LD_INT 4
25671: PUSH
25672: LD_INT 5
25674: PUSH
25675: LD_INT 31
25677: PUSH
25678: LD_INT 32
25680: PUSH
25681: LD_INT 33
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: LIST
25688: LIST
25689: LIST
25690: LIST
25691: LIST
25692: LIST
25693: LIST
25694: LIST
25695: LIST
25696: IN
25697: NOT
25698: PUSH
25699: LD_VAR 0 6
25703: PUSH
25704: LD_INT 1
25706: EQUAL
25707: AND
25708: OR
25709: PUSH
25710: LD_VAR 0 1
25714: PUSH
25715: LD_INT 2
25717: PUSH
25718: LD_INT 3
25720: PUSH
25721: EMPTY
25722: LIST
25723: LIST
25724: IN
25725: NOT
25726: PUSH
25727: LD_VAR 0 6
25731: PUSH
25732: LD_INT 2
25734: EQUAL
25735: AND
25736: OR
25737: IFFALSE 25747
// mode = 0 ;
25739: LD_ADDR_VAR 0 6
25743: PUSH
25744: LD_INT 0
25746: ST_TO_ADDR
// case mode of 0 :
25747: LD_VAR 0 6
25751: PUSH
25752: LD_INT 0
25754: DOUBLE
25755: EQUAL
25756: IFTRUE 25760
25758: GO 37213
25760: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25761: LD_ADDR_VAR 0 11
25765: PUSH
25766: LD_INT 0
25768: PUSH
25769: LD_INT 0
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 0
25778: PUSH
25779: LD_INT 1
25781: NEG
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 1
25789: PUSH
25790: LD_INT 0
25792: PUSH
25793: EMPTY
25794: LIST
25795: LIST
25796: PUSH
25797: LD_INT 1
25799: PUSH
25800: LD_INT 1
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: PUSH
25807: LD_INT 0
25809: PUSH
25810: LD_INT 1
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 1
25819: NEG
25820: PUSH
25821: LD_INT 0
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 1
25830: NEG
25831: PUSH
25832: LD_INT 1
25834: NEG
25835: PUSH
25836: EMPTY
25837: LIST
25838: LIST
25839: PUSH
25840: LD_INT 1
25842: NEG
25843: PUSH
25844: LD_INT 2
25846: NEG
25847: PUSH
25848: EMPTY
25849: LIST
25850: LIST
25851: PUSH
25852: LD_INT 0
25854: PUSH
25855: LD_INT 2
25857: NEG
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: LD_INT 1
25865: PUSH
25866: LD_INT 1
25868: NEG
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: LD_INT 1
25876: PUSH
25877: LD_INT 2
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 0
25886: PUSH
25887: LD_INT 2
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 1
25896: NEG
25897: PUSH
25898: LD_INT 1
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: LD_INT 1
25907: PUSH
25908: LD_INT 3
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 0
25917: PUSH
25918: LD_INT 3
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: PUSH
25925: LD_INT 1
25927: NEG
25928: PUSH
25929: LD_INT 2
25931: PUSH
25932: EMPTY
25933: LIST
25934: LIST
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: LIST
25940: LIST
25941: LIST
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: LIST
25951: LIST
25952: LIST
25953: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25954: LD_ADDR_VAR 0 12
25958: PUSH
25959: LD_INT 0
25961: PUSH
25962: LD_INT 0
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: LD_INT 0
25971: PUSH
25972: LD_INT 1
25974: NEG
25975: PUSH
25976: EMPTY
25977: LIST
25978: LIST
25979: PUSH
25980: LD_INT 1
25982: PUSH
25983: LD_INT 0
25985: PUSH
25986: EMPTY
25987: LIST
25988: LIST
25989: PUSH
25990: LD_INT 1
25992: PUSH
25993: LD_INT 1
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 0
26002: PUSH
26003: LD_INT 1
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: LD_INT 1
26012: NEG
26013: PUSH
26014: LD_INT 0
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: LD_INT 1
26023: NEG
26024: PUSH
26025: LD_INT 1
26027: NEG
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PUSH
26033: LD_INT 1
26035: PUSH
26036: LD_INT 1
26038: NEG
26039: PUSH
26040: EMPTY
26041: LIST
26042: LIST
26043: PUSH
26044: LD_INT 2
26046: PUSH
26047: LD_INT 0
26049: PUSH
26050: EMPTY
26051: LIST
26052: LIST
26053: PUSH
26054: LD_INT 2
26056: PUSH
26057: LD_INT 1
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: PUSH
26064: LD_INT 1
26066: NEG
26067: PUSH
26068: LD_INT 1
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 2
26077: NEG
26078: PUSH
26079: LD_INT 0
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: PUSH
26086: LD_INT 2
26088: NEG
26089: PUSH
26090: LD_INT 1
26092: NEG
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: LD_INT 2
26100: NEG
26101: PUSH
26102: LD_INT 1
26104: PUSH
26105: EMPTY
26106: LIST
26107: LIST
26108: PUSH
26109: LD_INT 3
26111: NEG
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: EMPTY
26117: LIST
26118: LIST
26119: PUSH
26120: LD_INT 3
26122: NEG
26123: PUSH
26124: LD_INT 1
26126: NEG
26127: PUSH
26128: EMPTY
26129: LIST
26130: LIST
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: LIST
26136: LIST
26137: LIST
26138: LIST
26139: LIST
26140: LIST
26141: LIST
26142: LIST
26143: LIST
26144: LIST
26145: LIST
26146: LIST
26147: LIST
26148: LIST
26149: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
26150: LD_ADDR_VAR 0 13
26154: PUSH
26155: LD_INT 0
26157: PUSH
26158: LD_INT 0
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: LD_INT 0
26167: PUSH
26168: LD_INT 1
26170: NEG
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 1
26178: PUSH
26179: LD_INT 0
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: LD_INT 1
26188: PUSH
26189: LD_INT 1
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: PUSH
26196: LD_INT 0
26198: PUSH
26199: LD_INT 1
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: PUSH
26206: LD_INT 1
26208: NEG
26209: PUSH
26210: LD_INT 0
26212: PUSH
26213: EMPTY
26214: LIST
26215: LIST
26216: PUSH
26217: LD_INT 1
26219: NEG
26220: PUSH
26221: LD_INT 1
26223: NEG
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: PUSH
26229: LD_INT 1
26231: NEG
26232: PUSH
26233: LD_INT 2
26235: NEG
26236: PUSH
26237: EMPTY
26238: LIST
26239: LIST
26240: PUSH
26241: LD_INT 2
26243: PUSH
26244: LD_INT 1
26246: PUSH
26247: EMPTY
26248: LIST
26249: LIST
26250: PUSH
26251: LD_INT 2
26253: PUSH
26254: LD_INT 2
26256: PUSH
26257: EMPTY
26258: LIST
26259: LIST
26260: PUSH
26261: LD_INT 1
26263: PUSH
26264: LD_INT 2
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 2
26273: NEG
26274: PUSH
26275: LD_INT 1
26277: NEG
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 2
26285: NEG
26286: PUSH
26287: LD_INT 2
26289: NEG
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: PUSH
26295: LD_INT 2
26297: NEG
26298: PUSH
26299: LD_INT 3
26301: NEG
26302: PUSH
26303: EMPTY
26304: LIST
26305: LIST
26306: PUSH
26307: LD_INT 3
26309: NEG
26310: PUSH
26311: LD_INT 2
26313: NEG
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: PUSH
26319: LD_INT 3
26321: NEG
26322: PUSH
26323: LD_INT 3
26325: NEG
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: LIST
26335: LIST
26336: LIST
26337: LIST
26338: LIST
26339: LIST
26340: LIST
26341: LIST
26342: LIST
26343: LIST
26344: LIST
26345: LIST
26346: LIST
26347: LIST
26348: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26349: LD_ADDR_VAR 0 14
26353: PUSH
26354: LD_INT 0
26356: PUSH
26357: LD_INT 0
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 0
26366: PUSH
26367: LD_INT 1
26369: NEG
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: LD_INT 1
26377: PUSH
26378: LD_INT 0
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 1
26387: PUSH
26388: LD_INT 1
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: PUSH
26395: LD_INT 0
26397: PUSH
26398: LD_INT 1
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 1
26407: NEG
26408: PUSH
26409: LD_INT 0
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: LD_INT 1
26418: NEG
26419: PUSH
26420: LD_INT 1
26422: NEG
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 1
26430: NEG
26431: PUSH
26432: LD_INT 2
26434: NEG
26435: PUSH
26436: EMPTY
26437: LIST
26438: LIST
26439: PUSH
26440: LD_INT 0
26442: PUSH
26443: LD_INT 2
26445: NEG
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 1
26453: PUSH
26454: LD_INT 1
26456: NEG
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 1
26464: PUSH
26465: LD_INT 2
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 0
26474: PUSH
26475: LD_INT 2
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: LD_INT 1
26484: NEG
26485: PUSH
26486: LD_INT 1
26488: PUSH
26489: EMPTY
26490: LIST
26491: LIST
26492: PUSH
26493: LD_INT 1
26495: NEG
26496: PUSH
26497: LD_INT 3
26499: NEG
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: PUSH
26505: LD_INT 0
26507: PUSH
26508: LD_INT 3
26510: NEG
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 1
26518: PUSH
26519: LD_INT 2
26521: NEG
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: LIST
26531: LIST
26532: LIST
26533: LIST
26534: LIST
26535: LIST
26536: LIST
26537: LIST
26538: LIST
26539: LIST
26540: LIST
26541: LIST
26542: LIST
26543: LIST
26544: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26545: LD_ADDR_VAR 0 15
26549: PUSH
26550: LD_INT 0
26552: PUSH
26553: LD_INT 0
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: LD_INT 0
26562: PUSH
26563: LD_INT 1
26565: NEG
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 1
26573: PUSH
26574: LD_INT 0
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 1
26583: PUSH
26584: LD_INT 1
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 0
26593: PUSH
26594: LD_INT 1
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: LD_INT 1
26603: NEG
26604: PUSH
26605: LD_INT 0
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 1
26614: NEG
26615: PUSH
26616: LD_INT 1
26618: NEG
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 1
26626: PUSH
26627: LD_INT 1
26629: NEG
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 2
26637: PUSH
26638: LD_INT 0
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 2
26647: PUSH
26648: LD_INT 1
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: PUSH
26655: LD_INT 1
26657: NEG
26658: PUSH
26659: LD_INT 1
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: PUSH
26666: LD_INT 2
26668: NEG
26669: PUSH
26670: LD_INT 0
26672: PUSH
26673: EMPTY
26674: LIST
26675: LIST
26676: PUSH
26677: LD_INT 2
26679: NEG
26680: PUSH
26681: LD_INT 1
26683: NEG
26684: PUSH
26685: EMPTY
26686: LIST
26687: LIST
26688: PUSH
26689: LD_INT 2
26691: PUSH
26692: LD_INT 1
26694: NEG
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: LD_INT 3
26702: PUSH
26703: LD_INT 0
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PUSH
26710: LD_INT 3
26712: PUSH
26713: LD_INT 1
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: LIST
26724: LIST
26725: LIST
26726: LIST
26727: LIST
26728: LIST
26729: LIST
26730: LIST
26731: LIST
26732: LIST
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26738: LD_ADDR_VAR 0 16
26742: PUSH
26743: LD_INT 0
26745: PUSH
26746: LD_INT 0
26748: PUSH
26749: EMPTY
26750: LIST
26751: LIST
26752: PUSH
26753: LD_INT 0
26755: PUSH
26756: LD_INT 1
26758: NEG
26759: PUSH
26760: EMPTY
26761: LIST
26762: LIST
26763: PUSH
26764: LD_INT 1
26766: PUSH
26767: LD_INT 0
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 1
26776: PUSH
26777: LD_INT 1
26779: PUSH
26780: EMPTY
26781: LIST
26782: LIST
26783: PUSH
26784: LD_INT 0
26786: PUSH
26787: LD_INT 1
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: LD_INT 1
26796: NEG
26797: PUSH
26798: LD_INT 0
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 1
26807: NEG
26808: PUSH
26809: LD_INT 1
26811: NEG
26812: PUSH
26813: EMPTY
26814: LIST
26815: LIST
26816: PUSH
26817: LD_INT 1
26819: NEG
26820: PUSH
26821: LD_INT 2
26823: NEG
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: PUSH
26829: LD_INT 2
26831: PUSH
26832: LD_INT 1
26834: PUSH
26835: EMPTY
26836: LIST
26837: LIST
26838: PUSH
26839: LD_INT 2
26841: PUSH
26842: LD_INT 2
26844: PUSH
26845: EMPTY
26846: LIST
26847: LIST
26848: PUSH
26849: LD_INT 1
26851: PUSH
26852: LD_INT 2
26854: PUSH
26855: EMPTY
26856: LIST
26857: LIST
26858: PUSH
26859: LD_INT 2
26861: NEG
26862: PUSH
26863: LD_INT 1
26865: NEG
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 2
26873: NEG
26874: PUSH
26875: LD_INT 2
26877: NEG
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 3
26885: PUSH
26886: LD_INT 2
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: PUSH
26893: LD_INT 3
26895: PUSH
26896: LD_INT 3
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PUSH
26903: LD_INT 2
26905: PUSH
26906: LD_INT 3
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: LIST
26917: LIST
26918: LIST
26919: LIST
26920: LIST
26921: LIST
26922: LIST
26923: LIST
26924: LIST
26925: LIST
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26931: LD_ADDR_VAR 0 17
26935: PUSH
26936: LD_INT 0
26938: PUSH
26939: LD_INT 0
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 0
26948: PUSH
26949: LD_INT 1
26951: NEG
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: PUSH
26957: LD_INT 1
26959: PUSH
26960: LD_INT 0
26962: PUSH
26963: EMPTY
26964: LIST
26965: LIST
26966: PUSH
26967: LD_INT 1
26969: PUSH
26970: LD_INT 1
26972: PUSH
26973: EMPTY
26974: LIST
26975: LIST
26976: PUSH
26977: LD_INT 0
26979: PUSH
26980: LD_INT 1
26982: PUSH
26983: EMPTY
26984: LIST
26985: LIST
26986: PUSH
26987: LD_INT 1
26989: NEG
26990: PUSH
26991: LD_INT 0
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 1
27000: NEG
27001: PUSH
27002: LD_INT 1
27004: NEG
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 1
27012: NEG
27013: PUSH
27014: LD_INT 2
27016: NEG
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 0
27024: PUSH
27025: LD_INT 2
27027: NEG
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: PUSH
27033: LD_INT 1
27035: PUSH
27036: LD_INT 1
27038: NEG
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 2
27046: PUSH
27047: LD_INT 0
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 2
27056: PUSH
27057: LD_INT 1
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: LD_INT 2
27066: PUSH
27067: LD_INT 2
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: PUSH
27074: LD_INT 1
27076: PUSH
27077: LD_INT 2
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: LD_INT 0
27086: PUSH
27087: LD_INT 2
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 1
27096: NEG
27097: PUSH
27098: LD_INT 1
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 2
27107: NEG
27108: PUSH
27109: LD_INT 0
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: LD_INT 2
27118: NEG
27119: PUSH
27120: LD_INT 1
27122: NEG
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 2
27130: NEG
27131: PUSH
27132: LD_INT 2
27134: NEG
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: EMPTY
27141: LIST
27142: LIST
27143: LIST
27144: LIST
27145: LIST
27146: LIST
27147: LIST
27148: LIST
27149: LIST
27150: LIST
27151: LIST
27152: LIST
27153: LIST
27154: LIST
27155: LIST
27156: LIST
27157: LIST
27158: LIST
27159: LIST
27160: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27161: LD_ADDR_VAR 0 18
27165: PUSH
27166: LD_INT 0
27168: PUSH
27169: LD_INT 0
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PUSH
27176: LD_INT 0
27178: PUSH
27179: LD_INT 1
27181: NEG
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: PUSH
27187: LD_INT 1
27189: PUSH
27190: LD_INT 0
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 1
27199: PUSH
27200: LD_INT 1
27202: PUSH
27203: EMPTY
27204: LIST
27205: LIST
27206: PUSH
27207: LD_INT 0
27209: PUSH
27210: LD_INT 1
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: LD_INT 1
27219: NEG
27220: PUSH
27221: LD_INT 0
27223: PUSH
27224: EMPTY
27225: LIST
27226: LIST
27227: PUSH
27228: LD_INT 1
27230: NEG
27231: PUSH
27232: LD_INT 1
27234: NEG
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: PUSH
27240: LD_INT 1
27242: NEG
27243: PUSH
27244: LD_INT 2
27246: NEG
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 0
27254: PUSH
27255: LD_INT 2
27257: NEG
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: PUSH
27263: LD_INT 1
27265: PUSH
27266: LD_INT 1
27268: NEG
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: LD_INT 2
27276: PUSH
27277: LD_INT 0
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: PUSH
27284: LD_INT 2
27286: PUSH
27287: LD_INT 1
27289: PUSH
27290: EMPTY
27291: LIST
27292: LIST
27293: PUSH
27294: LD_INT 2
27296: PUSH
27297: LD_INT 2
27299: PUSH
27300: EMPTY
27301: LIST
27302: LIST
27303: PUSH
27304: LD_INT 1
27306: PUSH
27307: LD_INT 2
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 0
27316: PUSH
27317: LD_INT 2
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: LD_INT 1
27326: NEG
27327: PUSH
27328: LD_INT 1
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 2
27337: NEG
27338: PUSH
27339: LD_INT 0
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: LD_INT 2
27348: NEG
27349: PUSH
27350: LD_INT 1
27352: NEG
27353: PUSH
27354: EMPTY
27355: LIST
27356: LIST
27357: PUSH
27358: LD_INT 2
27360: NEG
27361: PUSH
27362: LD_INT 2
27364: NEG
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: LIST
27374: LIST
27375: LIST
27376: LIST
27377: LIST
27378: LIST
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: LIST
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27391: LD_ADDR_VAR 0 19
27395: PUSH
27396: LD_INT 0
27398: PUSH
27399: LD_INT 0
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: PUSH
27406: LD_INT 0
27408: PUSH
27409: LD_INT 1
27411: NEG
27412: PUSH
27413: EMPTY
27414: LIST
27415: LIST
27416: PUSH
27417: LD_INT 1
27419: PUSH
27420: LD_INT 0
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: LD_INT 1
27429: PUSH
27430: LD_INT 1
27432: PUSH
27433: EMPTY
27434: LIST
27435: LIST
27436: PUSH
27437: LD_INT 0
27439: PUSH
27440: LD_INT 1
27442: PUSH
27443: EMPTY
27444: LIST
27445: LIST
27446: PUSH
27447: LD_INT 1
27449: NEG
27450: PUSH
27451: LD_INT 0
27453: PUSH
27454: EMPTY
27455: LIST
27456: LIST
27457: PUSH
27458: LD_INT 1
27460: NEG
27461: PUSH
27462: LD_INT 1
27464: NEG
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 1
27472: NEG
27473: PUSH
27474: LD_INT 2
27476: NEG
27477: PUSH
27478: EMPTY
27479: LIST
27480: LIST
27481: PUSH
27482: LD_INT 0
27484: PUSH
27485: LD_INT 2
27487: NEG
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PUSH
27493: LD_INT 1
27495: PUSH
27496: LD_INT 1
27498: NEG
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 2
27506: PUSH
27507: LD_INT 0
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 2
27516: PUSH
27517: LD_INT 1
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 2
27526: PUSH
27527: LD_INT 2
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 1
27536: PUSH
27537: LD_INT 2
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 0
27546: PUSH
27547: LD_INT 2
27549: PUSH
27550: EMPTY
27551: LIST
27552: LIST
27553: PUSH
27554: LD_INT 1
27556: NEG
27557: PUSH
27558: LD_INT 1
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: PUSH
27565: LD_INT 2
27567: NEG
27568: PUSH
27569: LD_INT 0
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: PUSH
27576: LD_INT 2
27578: NEG
27579: PUSH
27580: LD_INT 1
27582: NEG
27583: PUSH
27584: EMPTY
27585: LIST
27586: LIST
27587: PUSH
27588: LD_INT 2
27590: NEG
27591: PUSH
27592: LD_INT 2
27594: NEG
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: LIST
27604: LIST
27605: LIST
27606: LIST
27607: LIST
27608: LIST
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: LIST
27615: LIST
27616: LIST
27617: LIST
27618: LIST
27619: LIST
27620: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27621: LD_ADDR_VAR 0 20
27625: PUSH
27626: LD_INT 0
27628: PUSH
27629: LD_INT 0
27631: PUSH
27632: EMPTY
27633: LIST
27634: LIST
27635: PUSH
27636: LD_INT 0
27638: PUSH
27639: LD_INT 1
27641: NEG
27642: PUSH
27643: EMPTY
27644: LIST
27645: LIST
27646: PUSH
27647: LD_INT 1
27649: PUSH
27650: LD_INT 0
27652: PUSH
27653: EMPTY
27654: LIST
27655: LIST
27656: PUSH
27657: LD_INT 1
27659: PUSH
27660: LD_INT 1
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 0
27669: PUSH
27670: LD_INT 1
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 1
27679: NEG
27680: PUSH
27681: LD_INT 0
27683: PUSH
27684: EMPTY
27685: LIST
27686: LIST
27687: PUSH
27688: LD_INT 1
27690: NEG
27691: PUSH
27692: LD_INT 1
27694: NEG
27695: PUSH
27696: EMPTY
27697: LIST
27698: LIST
27699: PUSH
27700: LD_INT 1
27702: NEG
27703: PUSH
27704: LD_INT 2
27706: NEG
27707: PUSH
27708: EMPTY
27709: LIST
27710: LIST
27711: PUSH
27712: LD_INT 0
27714: PUSH
27715: LD_INT 2
27717: NEG
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: PUSH
27723: LD_INT 1
27725: PUSH
27726: LD_INT 1
27728: NEG
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: LD_INT 2
27736: PUSH
27737: LD_INT 0
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PUSH
27744: LD_INT 2
27746: PUSH
27747: LD_INT 1
27749: PUSH
27750: EMPTY
27751: LIST
27752: LIST
27753: PUSH
27754: LD_INT 2
27756: PUSH
27757: LD_INT 2
27759: PUSH
27760: EMPTY
27761: LIST
27762: LIST
27763: PUSH
27764: LD_INT 1
27766: PUSH
27767: LD_INT 2
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 0
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: PUSH
27784: LD_INT 1
27786: NEG
27787: PUSH
27788: LD_INT 1
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: LD_INT 2
27797: NEG
27798: PUSH
27799: LD_INT 0
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: LD_INT 2
27808: NEG
27809: PUSH
27810: LD_INT 1
27812: NEG
27813: PUSH
27814: EMPTY
27815: LIST
27816: LIST
27817: PUSH
27818: LD_INT 2
27820: NEG
27821: PUSH
27822: LD_INT 2
27824: NEG
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: LIST
27834: LIST
27835: LIST
27836: LIST
27837: LIST
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27851: LD_ADDR_VAR 0 21
27855: PUSH
27856: LD_INT 0
27858: PUSH
27859: LD_INT 0
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: LD_INT 0
27868: PUSH
27869: LD_INT 1
27871: NEG
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 1
27879: PUSH
27880: LD_INT 0
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PUSH
27887: LD_INT 1
27889: PUSH
27890: LD_INT 1
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: LD_INT 0
27899: PUSH
27900: LD_INT 1
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 1
27909: NEG
27910: PUSH
27911: LD_INT 0
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: PUSH
27918: LD_INT 1
27920: NEG
27921: PUSH
27922: LD_INT 1
27924: NEG
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: PUSH
27930: LD_INT 1
27932: NEG
27933: PUSH
27934: LD_INT 2
27936: NEG
27937: PUSH
27938: EMPTY
27939: LIST
27940: LIST
27941: PUSH
27942: LD_INT 0
27944: PUSH
27945: LD_INT 2
27947: NEG
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: LD_INT 1
27958: NEG
27959: PUSH
27960: EMPTY
27961: LIST
27962: LIST
27963: PUSH
27964: LD_INT 2
27966: PUSH
27967: LD_INT 0
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: PUSH
27974: LD_INT 2
27976: PUSH
27977: LD_INT 1
27979: PUSH
27980: EMPTY
27981: LIST
27982: LIST
27983: PUSH
27984: LD_INT 2
27986: PUSH
27987: LD_INT 2
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: LD_INT 2
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: PUSH
28014: LD_INT 1
28016: NEG
28017: PUSH
28018: LD_INT 1
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 2
28027: NEG
28028: PUSH
28029: LD_INT 0
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 2
28038: NEG
28039: PUSH
28040: LD_INT 1
28042: NEG
28043: PUSH
28044: EMPTY
28045: LIST
28046: LIST
28047: PUSH
28048: LD_INT 2
28050: NEG
28051: PUSH
28052: LD_INT 2
28054: NEG
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: LIST
28066: LIST
28067: LIST
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: LIST
28074: LIST
28075: LIST
28076: LIST
28077: LIST
28078: LIST
28079: LIST
28080: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28081: LD_ADDR_VAR 0 22
28085: PUSH
28086: LD_INT 0
28088: PUSH
28089: LD_INT 0
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: LD_INT 0
28098: PUSH
28099: LD_INT 1
28101: NEG
28102: PUSH
28103: EMPTY
28104: LIST
28105: LIST
28106: PUSH
28107: LD_INT 1
28109: PUSH
28110: LD_INT 0
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 1
28119: PUSH
28120: LD_INT 1
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: LD_INT 0
28129: PUSH
28130: LD_INT 1
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 1
28139: NEG
28140: PUSH
28141: LD_INT 0
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 1
28150: NEG
28151: PUSH
28152: LD_INT 1
28154: NEG
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: LD_INT 1
28162: NEG
28163: PUSH
28164: LD_INT 2
28166: NEG
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PUSH
28172: LD_INT 0
28174: PUSH
28175: LD_INT 2
28177: NEG
28178: PUSH
28179: EMPTY
28180: LIST
28181: LIST
28182: PUSH
28183: LD_INT 1
28185: PUSH
28186: LD_INT 1
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: LD_INT 2
28196: PUSH
28197: LD_INT 0
28199: PUSH
28200: EMPTY
28201: LIST
28202: LIST
28203: PUSH
28204: LD_INT 2
28206: PUSH
28207: LD_INT 1
28209: PUSH
28210: EMPTY
28211: LIST
28212: LIST
28213: PUSH
28214: LD_INT 2
28216: PUSH
28217: LD_INT 2
28219: PUSH
28220: EMPTY
28221: LIST
28222: LIST
28223: PUSH
28224: LD_INT 1
28226: PUSH
28227: LD_INT 2
28229: PUSH
28230: EMPTY
28231: LIST
28232: LIST
28233: PUSH
28234: LD_INT 0
28236: PUSH
28237: LD_INT 2
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: PUSH
28244: LD_INT 1
28246: NEG
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: PUSH
28255: LD_INT 2
28257: NEG
28258: PUSH
28259: LD_INT 0
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 2
28268: NEG
28269: PUSH
28270: LD_INT 1
28272: NEG
28273: PUSH
28274: EMPTY
28275: LIST
28276: LIST
28277: PUSH
28278: LD_INT 2
28280: NEG
28281: PUSH
28282: LD_INT 2
28284: NEG
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: LIST
28294: LIST
28295: LIST
28296: LIST
28297: LIST
28298: LIST
28299: LIST
28300: LIST
28301: LIST
28302: LIST
28303: LIST
28304: LIST
28305: LIST
28306: LIST
28307: LIST
28308: LIST
28309: LIST
28310: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
28311: LD_ADDR_VAR 0 23
28315: PUSH
28316: LD_INT 0
28318: PUSH
28319: LD_INT 0
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: LD_INT 0
28328: PUSH
28329: LD_INT 1
28331: NEG
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: PUSH
28337: LD_INT 1
28339: PUSH
28340: LD_INT 0
28342: PUSH
28343: EMPTY
28344: LIST
28345: LIST
28346: PUSH
28347: LD_INT 1
28349: PUSH
28350: LD_INT 1
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 0
28359: PUSH
28360: LD_INT 1
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: PUSH
28367: LD_INT 1
28369: NEG
28370: PUSH
28371: LD_INT 0
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: PUSH
28378: LD_INT 1
28380: NEG
28381: PUSH
28382: LD_INT 1
28384: NEG
28385: PUSH
28386: EMPTY
28387: LIST
28388: LIST
28389: PUSH
28390: LD_INT 1
28392: NEG
28393: PUSH
28394: LD_INT 2
28396: NEG
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: LD_INT 0
28404: PUSH
28405: LD_INT 2
28407: NEG
28408: PUSH
28409: EMPTY
28410: LIST
28411: LIST
28412: PUSH
28413: LD_INT 1
28415: PUSH
28416: LD_INT 1
28418: NEG
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 2
28426: PUSH
28427: LD_INT 0
28429: PUSH
28430: EMPTY
28431: LIST
28432: LIST
28433: PUSH
28434: LD_INT 2
28436: PUSH
28437: LD_INT 1
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 2
28446: PUSH
28447: LD_INT 2
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: LD_INT 1
28456: PUSH
28457: LD_INT 2
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: LD_INT 2
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: PUSH
28474: LD_INT 1
28476: NEG
28477: PUSH
28478: LD_INT 1
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PUSH
28485: LD_INT 2
28487: NEG
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: PUSH
28496: LD_INT 2
28498: NEG
28499: PUSH
28500: LD_INT 1
28502: NEG
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PUSH
28508: LD_INT 2
28510: NEG
28511: PUSH
28512: LD_INT 2
28514: NEG
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: LD_INT 2
28522: NEG
28523: PUSH
28524: LD_INT 3
28526: NEG
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 1
28534: NEG
28535: PUSH
28536: LD_INT 3
28538: NEG
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: PUSH
28547: LD_INT 2
28549: NEG
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 2
28557: PUSH
28558: LD_INT 1
28560: NEG
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: LIST
28570: LIST
28571: LIST
28572: LIST
28573: LIST
28574: LIST
28575: LIST
28576: LIST
28577: LIST
28578: LIST
28579: LIST
28580: LIST
28581: LIST
28582: LIST
28583: LIST
28584: LIST
28585: LIST
28586: LIST
28587: LIST
28588: LIST
28589: LIST
28590: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28591: LD_ADDR_VAR 0 24
28595: PUSH
28596: LD_INT 0
28598: PUSH
28599: LD_INT 0
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 0
28608: PUSH
28609: LD_INT 1
28611: NEG
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: LD_INT 1
28619: PUSH
28620: LD_INT 0
28622: PUSH
28623: EMPTY
28624: LIST
28625: LIST
28626: PUSH
28627: LD_INT 1
28629: PUSH
28630: LD_INT 1
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PUSH
28637: LD_INT 0
28639: PUSH
28640: LD_INT 1
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: LD_INT 1
28649: NEG
28650: PUSH
28651: LD_INT 0
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: LD_INT 1
28660: NEG
28661: PUSH
28662: LD_INT 1
28664: NEG
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 1
28672: NEG
28673: PUSH
28674: LD_INT 2
28676: NEG
28677: PUSH
28678: EMPTY
28679: LIST
28680: LIST
28681: PUSH
28682: LD_INT 0
28684: PUSH
28685: LD_INT 2
28687: NEG
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: LD_INT 1
28695: PUSH
28696: LD_INT 1
28698: NEG
28699: PUSH
28700: EMPTY
28701: LIST
28702: LIST
28703: PUSH
28704: LD_INT 2
28706: PUSH
28707: LD_INT 0
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: PUSH
28714: LD_INT 2
28716: PUSH
28717: LD_INT 1
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 2
28726: PUSH
28727: LD_INT 2
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 1
28736: PUSH
28737: LD_INT 2
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 0
28746: PUSH
28747: LD_INT 2
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 1
28756: NEG
28757: PUSH
28758: LD_INT 1
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 2
28767: NEG
28768: PUSH
28769: LD_INT 0
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: NEG
28779: PUSH
28780: LD_INT 1
28782: NEG
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 2
28790: NEG
28791: PUSH
28792: LD_INT 2
28794: NEG
28795: PUSH
28796: EMPTY
28797: LIST
28798: LIST
28799: PUSH
28800: LD_INT 1
28802: PUSH
28803: LD_INT 2
28805: NEG
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: PUSH
28811: LD_INT 2
28813: PUSH
28814: LD_INT 1
28816: NEG
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: PUSH
28822: LD_INT 3
28824: PUSH
28825: LD_INT 1
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: LD_INT 3
28834: PUSH
28835: LD_INT 2
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28867: LD_ADDR_VAR 0 25
28871: PUSH
28872: LD_INT 0
28874: PUSH
28875: LD_INT 0
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 0
28884: PUSH
28885: LD_INT 1
28887: NEG
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 1
28895: PUSH
28896: LD_INT 0
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 1
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: LD_INT 0
28915: PUSH
28916: LD_INT 1
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: PUSH
28923: LD_INT 1
28925: NEG
28926: PUSH
28927: LD_INT 0
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PUSH
28934: LD_INT 1
28936: NEG
28937: PUSH
28938: LD_INT 1
28940: NEG
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 1
28948: NEG
28949: PUSH
28950: LD_INT 2
28952: NEG
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 0
28960: PUSH
28961: LD_INT 2
28963: NEG
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PUSH
28969: LD_INT 1
28971: PUSH
28972: LD_INT 1
28974: NEG
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: PUSH
28980: LD_INT 2
28982: PUSH
28983: LD_INT 0
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 2
28992: PUSH
28993: LD_INT 1
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 2
29002: PUSH
29003: LD_INT 2
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 1
29012: PUSH
29013: LD_INT 2
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 0
29022: PUSH
29023: LD_INT 2
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 1
29032: NEG
29033: PUSH
29034: LD_INT 1
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 2
29043: NEG
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 2
29054: NEG
29055: PUSH
29056: LD_INT 1
29058: NEG
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 2
29066: NEG
29067: PUSH
29068: LD_INT 2
29070: NEG
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 3
29078: PUSH
29079: LD_INT 1
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 3
29088: PUSH
29089: LD_INT 2
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 2
29098: PUSH
29099: LD_INT 3
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: LD_INT 3
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: LIST
29120: LIST
29121: LIST
29122: LIST
29123: LIST
29124: LIST
29125: LIST
29126: LIST
29127: LIST
29128: LIST
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: LIST
29137: LIST
29138: LIST
29139: LIST
29140: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
29141: LD_ADDR_VAR 0 26
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: LD_INT 0
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 0
29158: PUSH
29159: LD_INT 1
29161: NEG
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 1
29169: PUSH
29170: LD_INT 0
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 1
29179: PUSH
29180: LD_INT 1
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: LD_INT 0
29189: PUSH
29190: LD_INT 1
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: LD_INT 1
29199: NEG
29200: PUSH
29201: LD_INT 0
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 1
29210: NEG
29211: PUSH
29212: LD_INT 1
29214: NEG
29215: PUSH
29216: EMPTY
29217: LIST
29218: LIST
29219: PUSH
29220: LD_INT 1
29222: NEG
29223: PUSH
29224: LD_INT 2
29226: NEG
29227: PUSH
29228: EMPTY
29229: LIST
29230: LIST
29231: PUSH
29232: LD_INT 0
29234: PUSH
29235: LD_INT 2
29237: NEG
29238: PUSH
29239: EMPTY
29240: LIST
29241: LIST
29242: PUSH
29243: LD_INT 1
29245: PUSH
29246: LD_INT 1
29248: NEG
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: PUSH
29254: LD_INT 2
29256: PUSH
29257: LD_INT 0
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PUSH
29264: LD_INT 2
29266: PUSH
29267: LD_INT 1
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 2
29276: PUSH
29277: LD_INT 2
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 1
29286: PUSH
29287: LD_INT 2
29289: PUSH
29290: EMPTY
29291: LIST
29292: LIST
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: LD_INT 2
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: LD_INT 1
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: LD_INT 0
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 2
29328: NEG
29329: PUSH
29330: LD_INT 1
29332: NEG
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 2
29340: NEG
29341: PUSH
29342: LD_INT 2
29344: NEG
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: LD_INT 2
29352: PUSH
29353: LD_INT 3
29355: PUSH
29356: EMPTY
29357: LIST
29358: LIST
29359: PUSH
29360: LD_INT 1
29362: PUSH
29363: LD_INT 3
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 1
29372: NEG
29373: PUSH
29374: LD_INT 2
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 2
29383: NEG
29384: PUSH
29385: LD_INT 1
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: LIST
29396: LIST
29397: LIST
29398: LIST
29399: LIST
29400: LIST
29401: LIST
29402: LIST
29403: LIST
29404: LIST
29405: LIST
29406: LIST
29407: LIST
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29417: LD_ADDR_VAR 0 27
29421: PUSH
29422: LD_INT 0
29424: PUSH
29425: LD_INT 0
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: LD_INT 0
29434: PUSH
29435: LD_INT 1
29437: NEG
29438: PUSH
29439: EMPTY
29440: LIST
29441: LIST
29442: PUSH
29443: LD_INT 1
29445: PUSH
29446: LD_INT 0
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 1
29455: PUSH
29456: LD_INT 1
29458: PUSH
29459: EMPTY
29460: LIST
29461: LIST
29462: PUSH
29463: LD_INT 0
29465: PUSH
29466: LD_INT 1
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: PUSH
29473: LD_INT 1
29475: NEG
29476: PUSH
29477: LD_INT 0
29479: PUSH
29480: EMPTY
29481: LIST
29482: LIST
29483: PUSH
29484: LD_INT 1
29486: NEG
29487: PUSH
29488: LD_INT 1
29490: NEG
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: LD_INT 2
29502: NEG
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 0
29510: PUSH
29511: LD_INT 2
29513: NEG
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 1
29521: PUSH
29522: LD_INT 1
29524: NEG
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 2
29532: PUSH
29533: LD_INT 0
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 2
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 2
29552: PUSH
29553: LD_INT 2
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 1
29562: PUSH
29563: LD_INT 2
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PUSH
29570: LD_INT 0
29572: PUSH
29573: LD_INT 2
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: LD_INT 1
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 2
29593: NEG
29594: PUSH
29595: LD_INT 0
29597: PUSH
29598: EMPTY
29599: LIST
29600: LIST
29601: PUSH
29602: LD_INT 2
29604: NEG
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: NEG
29617: PUSH
29618: LD_INT 2
29620: NEG
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 1
29628: NEG
29629: PUSH
29630: LD_INT 2
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 2
29639: NEG
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PUSH
29648: LD_INT 3
29650: NEG
29651: PUSH
29652: LD_INT 1
29654: NEG
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 3
29662: NEG
29663: PUSH
29664: LD_INT 2
29666: NEG
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: EMPTY
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: LIST
29683: LIST
29684: LIST
29685: LIST
29686: LIST
29687: LIST
29688: LIST
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: LIST
29696: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29697: LD_ADDR_VAR 0 28
29701: PUSH
29702: LD_INT 0
29704: PUSH
29705: LD_INT 0
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: LD_INT 1
29717: NEG
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 1
29725: PUSH
29726: LD_INT 0
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 1
29735: PUSH
29736: LD_INT 1
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: LD_INT 1
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 1
29755: NEG
29756: PUSH
29757: LD_INT 0
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 1
29778: NEG
29779: PUSH
29780: LD_INT 2
29782: NEG
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PUSH
29788: LD_INT 0
29790: PUSH
29791: LD_INT 2
29793: NEG
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 1
29801: PUSH
29802: LD_INT 1
29804: NEG
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 2
29812: PUSH
29813: LD_INT 0
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: LD_INT 2
29822: PUSH
29823: LD_INT 1
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 2
29832: PUSH
29833: LD_INT 2
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: LD_INT 2
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 0
29852: PUSH
29853: LD_INT 2
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: LD_INT 1
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 2
29873: NEG
29874: PUSH
29875: LD_INT 0
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 2
29884: NEG
29885: PUSH
29886: LD_INT 1
29888: NEG
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 2
29896: NEG
29897: PUSH
29898: LD_INT 2
29900: NEG
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 2
29908: NEG
29909: PUSH
29910: LD_INT 3
29912: NEG
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 1
29920: NEG
29921: PUSH
29922: LD_INT 3
29924: NEG
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: LD_INT 3
29932: NEG
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: PUSH
29942: LD_INT 3
29944: NEG
29945: PUSH
29946: LD_INT 2
29948: NEG
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: LIST
29972: LIST
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29979: LD_ADDR_VAR 0 29
29983: PUSH
29984: LD_INT 0
29986: PUSH
29987: LD_INT 0
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 0
29996: PUSH
29997: LD_INT 1
29999: NEG
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 1
30007: PUSH
30008: LD_INT 0
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 1
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: LD_INT 1
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 1
30037: NEG
30038: PUSH
30039: LD_INT 0
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 1
30048: NEG
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 1
30060: NEG
30061: PUSH
30062: LD_INT 2
30064: NEG
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: LD_INT 0
30072: PUSH
30073: LD_INT 2
30075: NEG
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 1
30083: PUSH
30084: LD_INT 1
30086: NEG
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: PUSH
30092: LD_INT 2
30094: PUSH
30095: LD_INT 0
30097: PUSH
30098: EMPTY
30099: LIST
30100: LIST
30101: PUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 1
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: LD_INT 2
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: LD_INT 0
30124: PUSH
30125: LD_INT 2
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 1
30134: NEG
30135: PUSH
30136: LD_INT 1
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 2
30145: NEG
30146: PUSH
30147: LD_INT 1
30149: NEG
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 2
30157: NEG
30158: PUSH
30159: LD_INT 2
30161: NEG
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 2
30169: NEG
30170: PUSH
30171: LD_INT 3
30173: NEG
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 2
30181: PUSH
30182: LD_INT 1
30184: NEG
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 3
30192: PUSH
30193: LD_INT 1
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 1
30202: PUSH
30203: LD_INT 3
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 2
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 3
30223: NEG
30224: PUSH
30225: LD_INT 2
30227: NEG
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: LIST
30244: LIST
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: LIST
30255: LIST
30256: LIST
30257: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30258: LD_ADDR_VAR 0 30
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 0
30275: PUSH
30276: LD_INT 1
30278: NEG
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 1
30286: PUSH
30287: LD_INT 0
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 1
30296: PUSH
30297: LD_INT 1
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 0
30306: PUSH
30307: LD_INT 1
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: LD_INT 0
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 1
30327: NEG
30328: PUSH
30329: LD_INT 1
30331: NEG
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 1
30339: NEG
30340: PUSH
30341: LD_INT 2
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 0
30351: PUSH
30352: LD_INT 2
30354: NEG
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 1
30362: PUSH
30363: LD_INT 1
30365: NEG
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 2
30373: PUSH
30374: LD_INT 0
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 2
30383: PUSH
30384: LD_INT 1
30386: PUSH
30387: EMPTY
30388: LIST
30389: LIST
30390: PUSH
30391: LD_INT 2
30393: PUSH
30394: LD_INT 2
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 1
30403: PUSH
30404: LD_INT 2
30406: PUSH
30407: EMPTY
30408: LIST
30409: LIST
30410: PUSH
30411: LD_INT 1
30413: NEG
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 2
30424: NEG
30425: PUSH
30426: LD_INT 0
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: LD_INT 2
30435: NEG
30436: PUSH
30437: LD_INT 1
30439: NEG
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: NEG
30448: PUSH
30449: LD_INT 3
30451: NEG
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: LD_INT 2
30462: NEG
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 3
30470: PUSH
30471: LD_INT 2
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: PUSH
30478: LD_INT 2
30480: PUSH
30481: LD_INT 3
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 2
30490: NEG
30491: PUSH
30492: LD_INT 1
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: LD_INT 3
30501: NEG
30502: PUSH
30503: LD_INT 1
30505: NEG
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: LIST
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30536: LD_ADDR_VAR 0 31
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 0
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: LD_INT 1
30556: NEG
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 1
30564: PUSH
30565: LD_INT 0
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 1
30574: PUSH
30575: LD_INT 1
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 0
30584: PUSH
30585: LD_INT 1
30587: PUSH
30588: EMPTY
30589: LIST
30590: LIST
30591: PUSH
30592: LD_INT 1
30594: NEG
30595: PUSH
30596: LD_INT 0
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 1
30605: NEG
30606: PUSH
30607: LD_INT 1
30609: NEG
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 1
30617: NEG
30618: PUSH
30619: LD_INT 2
30621: NEG
30622: PUSH
30623: EMPTY
30624: LIST
30625: LIST
30626: PUSH
30627: LD_INT 1
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 2
30640: PUSH
30641: LD_INT 0
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 2
30650: PUSH
30651: LD_INT 1
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: LD_INT 2
30660: PUSH
30661: LD_INT 2
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 1
30670: PUSH
30671: LD_INT 2
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 0
30680: PUSH
30681: LD_INT 2
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: NEG
30691: PUSH
30692: LD_INT 1
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 2
30701: NEG
30702: PUSH
30703: LD_INT 1
30705: NEG
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 2
30713: NEG
30714: PUSH
30715: LD_INT 2
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 2
30725: NEG
30726: PUSH
30727: LD_INT 3
30729: NEG
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 2
30737: PUSH
30738: LD_INT 1
30740: NEG
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 3
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: PUSH
30759: LD_INT 3
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 1
30768: NEG
30769: PUSH
30770: LD_INT 2
30772: PUSH
30773: EMPTY
30774: LIST
30775: LIST
30776: PUSH
30777: LD_INT 3
30779: NEG
30780: PUSH
30781: LD_INT 2
30783: NEG
30784: PUSH
30785: EMPTY
30786: LIST
30787: LIST
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: LIST
30793: LIST
30794: LIST
30795: LIST
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30814: LD_ADDR_VAR 0 32
30818: PUSH
30819: LD_INT 0
30821: PUSH
30822: LD_INT 0
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 0
30831: PUSH
30832: LD_INT 1
30834: NEG
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 1
30842: PUSH
30843: LD_INT 0
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: LD_INT 1
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 0
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 1
30872: NEG
30873: PUSH
30874: LD_INT 0
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 1
30883: NEG
30884: PUSH
30885: LD_INT 1
30887: NEG
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 1
30895: NEG
30896: PUSH
30897: LD_INT 2
30899: NEG
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 0
30907: PUSH
30908: LD_INT 2
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: LD_INT 1
30921: NEG
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 2
30929: PUSH
30930: LD_INT 1
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 2
30939: PUSH
30940: LD_INT 2
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 1
30949: PUSH
30950: LD_INT 2
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 0
30959: PUSH
30960: LD_INT 2
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 1
30969: NEG
30970: PUSH
30971: LD_INT 1
30973: PUSH
30974: EMPTY
30975: LIST
30976: LIST
30977: PUSH
30978: LD_INT 2
30980: NEG
30981: PUSH
30982: LD_INT 0
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 2
30991: NEG
30992: PUSH
30993: LD_INT 1
30995: NEG
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 1
31003: NEG
31004: PUSH
31005: LD_INT 3
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 2
31018: NEG
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: LD_INT 3
31026: PUSH
31027: LD_INT 2
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: LD_INT 2
31036: PUSH
31037: LD_INT 3
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: LD_INT 2
31046: NEG
31047: PUSH
31048: LD_INT 1
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 3
31057: NEG
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: LIST
31071: LIST
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31092: LD_ADDR_VAR 0 33
31096: PUSH
31097: LD_INT 0
31099: PUSH
31100: LD_INT 0
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 1
31130: PUSH
31131: LD_INT 1
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 0
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 0
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 1
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 1
31173: NEG
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: PUSH
31186: LD_INT 1
31188: NEG
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 2
31196: PUSH
31197: LD_INT 0
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 2
31206: PUSH
31207: LD_INT 1
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 1
31216: PUSH
31217: LD_INT 2
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 0
31226: PUSH
31227: LD_INT 2
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PUSH
31234: LD_INT 1
31236: NEG
31237: PUSH
31238: LD_INT 1
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 2
31247: NEG
31248: PUSH
31249: LD_INT 0
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 2
31258: NEG
31259: PUSH
31260: LD_INT 1
31262: NEG
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PUSH
31268: LD_INT 2
31270: NEG
31271: PUSH
31272: LD_INT 2
31274: NEG
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 2
31282: NEG
31283: PUSH
31284: LD_INT 3
31286: NEG
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 2
31294: PUSH
31295: LD_INT 1
31297: NEG
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: LD_INT 3
31305: PUSH
31306: LD_INT 1
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: LD_INT 1
31315: PUSH
31316: LD_INT 3
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 1
31325: NEG
31326: PUSH
31327: LD_INT 2
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PUSH
31334: LD_INT 3
31336: NEG
31337: PUSH
31338: LD_INT 2
31340: NEG
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: LIST
31350: LIST
31351: LIST
31352: LIST
31353: LIST
31354: LIST
31355: LIST
31356: LIST
31357: LIST
31358: LIST
31359: LIST
31360: LIST
31361: LIST
31362: LIST
31363: LIST
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31371: LD_ADDR_VAR 0 34
31375: PUSH
31376: LD_INT 0
31378: PUSH
31379: LD_INT 0
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 0
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 1
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 1
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 0
31419: PUSH
31420: LD_INT 1
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 1
31429: NEG
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 1
31440: NEG
31441: PUSH
31442: LD_INT 1
31444: NEG
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 1
31452: NEG
31453: PUSH
31454: LD_INT 2
31456: NEG
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: LD_INT 2
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 1
31475: PUSH
31476: LD_INT 1
31478: NEG
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: LD_INT 2
31486: PUSH
31487: LD_INT 1
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 2
31496: PUSH
31497: LD_INT 2
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 1
31506: PUSH
31507: LD_INT 2
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 2
31527: NEG
31528: PUSH
31529: LD_INT 0
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 2
31538: NEG
31539: PUSH
31540: LD_INT 1
31542: NEG
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 2
31550: NEG
31551: PUSH
31552: LD_INT 2
31554: NEG
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 1
31562: NEG
31563: PUSH
31564: LD_INT 3
31566: NEG
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: PUSH
31575: LD_INT 2
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 3
31585: PUSH
31586: LD_INT 2
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 2
31595: PUSH
31596: LD_INT 3
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 2
31605: NEG
31606: PUSH
31607: LD_INT 1
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 3
31616: NEG
31617: PUSH
31618: LD_INT 1
31620: NEG
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: EMPTY
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31651: LD_ADDR_VAR 0 35
31655: PUSH
31656: LD_INT 0
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: LD_INT 0
31668: PUSH
31669: LD_INT 1
31671: NEG
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: EMPTY
31684: LIST
31685: LIST
31686: PUSH
31687: LD_INT 1
31689: PUSH
31690: LD_INT 1
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 0
31699: PUSH
31700: LD_INT 1
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 1
31709: NEG
31710: PUSH
31711: LD_INT 0
31713: PUSH
31714: EMPTY
31715: LIST
31716: LIST
31717: PUSH
31718: LD_INT 1
31720: NEG
31721: PUSH
31722: LD_INT 1
31724: NEG
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 2
31732: PUSH
31733: LD_INT 1
31735: PUSH
31736: EMPTY
31737: LIST
31738: LIST
31739: PUSH
31740: LD_INT 2
31742: NEG
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: LIST
31756: LIST
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31763: LD_ADDR_VAR 0 36
31767: PUSH
31768: LD_INT 0
31770: PUSH
31771: LD_INT 0
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 0
31780: PUSH
31781: LD_INT 1
31783: NEG
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 1
31801: PUSH
31802: LD_INT 1
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 0
31811: PUSH
31812: LD_INT 1
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: LD_INT 1
31821: NEG
31822: PUSH
31823: LD_INT 0
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: LD_INT 1
31836: NEG
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 1
31844: NEG
31845: PUSH
31846: LD_INT 2
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 1
31856: PUSH
31857: LD_INT 2
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31875: LD_ADDR_VAR 0 37
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 0
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: PUSH
31890: LD_INT 0
31892: PUSH
31893: LD_INT 1
31895: NEG
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: LD_INT 0
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: LD_INT 1
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: PUSH
31921: LD_INT 0
31923: PUSH
31924: LD_INT 1
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 1
31944: NEG
31945: PUSH
31946: LD_INT 1
31948: NEG
31949: PUSH
31950: EMPTY
31951: LIST
31952: LIST
31953: PUSH
31954: LD_INT 1
31956: PUSH
31957: LD_INT 1
31959: NEG
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 1
31967: NEG
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: LIST
31980: LIST
31981: LIST
31982: LIST
31983: LIST
31984: LIST
31985: LIST
31986: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31987: LD_ADDR_VAR 0 38
31991: PUSH
31992: LD_INT 0
31994: PUSH
31995: LD_INT 0
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: LD_INT 1
32007: NEG
32008: PUSH
32009: EMPTY
32010: LIST
32011: LIST
32012: PUSH
32013: LD_INT 1
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 1
32025: PUSH
32026: LD_INT 1
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 0
32035: PUSH
32036: LD_INT 1
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 1
32045: NEG
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 1
32056: NEG
32057: PUSH
32058: LD_INT 1
32060: NEG
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 2
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: NEG
32079: PUSH
32080: LD_INT 1
32082: NEG
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32099: LD_ADDR_VAR 0 39
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 0
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: PUSH
32138: LD_INT 1
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: LD_INT 1
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: LD_INT 0
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 1
32168: NEG
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 2
32184: NEG
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 1
32192: PUSH
32193: LD_INT 2
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32211: LD_ADDR_VAR 0 40
32215: PUSH
32216: LD_INT 0
32218: PUSH
32219: LD_INT 0
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 0
32228: PUSH
32229: LD_INT 1
32231: NEG
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: PUSH
32237: LD_INT 1
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: LD_INT 1
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: LD_INT 0
32259: PUSH
32260: LD_INT 1
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: LD_INT 0
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 1
32280: NEG
32281: PUSH
32282: LD_INT 1
32284: NEG
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: LD_INT 1
32295: NEG
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: PUSH
32301: LD_INT 1
32303: NEG
32304: PUSH
32305: LD_INT 1
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: EMPTY
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32323: LD_ADDR_VAR 0 41
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: LD_INT 0
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: LD_INT 1
32343: NEG
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 1
32351: PUSH
32352: LD_INT 0
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: LD_INT 1
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: LD_INT 0
32371: PUSH
32372: LD_INT 1
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 1
32381: NEG
32382: PUSH
32383: LD_INT 0
32385: PUSH
32386: EMPTY
32387: LIST
32388: LIST
32389: PUSH
32390: LD_INT 1
32392: NEG
32393: PUSH
32394: LD_INT 1
32396: NEG
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 1
32404: NEG
32405: PUSH
32406: LD_INT 2
32408: NEG
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 2
32427: PUSH
32428: LD_INT 0
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 2
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 2
32447: PUSH
32448: LD_INT 2
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 1
32457: PUSH
32458: LD_INT 2
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 1
32467: NEG
32468: PUSH
32469: LD_INT 1
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 2
32478: NEG
32479: PUSH
32480: LD_INT 0
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 2
32489: NEG
32490: PUSH
32491: LD_INT 1
32493: NEG
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 2
32501: NEG
32502: PUSH
32503: LD_INT 2
32505: NEG
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 2
32513: NEG
32514: PUSH
32515: LD_INT 3
32517: NEG
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 2
32525: PUSH
32526: LD_INT 1
32528: NEG
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 3
32536: PUSH
32537: LD_INT 0
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: PUSH
32544: LD_INT 3
32546: PUSH
32547: LD_INT 1
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 3
32556: PUSH
32557: LD_INT 2
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 3
32566: PUSH
32567: LD_INT 3
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 2
32576: PUSH
32577: LD_INT 3
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 2
32586: NEG
32587: PUSH
32588: LD_INT 1
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 3
32597: NEG
32598: PUSH
32599: LD_INT 0
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 3
32608: NEG
32609: PUSH
32610: LD_INT 1
32612: NEG
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PUSH
32618: LD_INT 3
32620: NEG
32621: PUSH
32622: LD_INT 2
32624: NEG
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 3
32632: NEG
32633: PUSH
32634: LD_INT 3
32636: NEG
32637: PUSH
32638: EMPTY
32639: LIST
32640: LIST
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32673: LD_ADDR_VAR 0 42
32677: PUSH
32678: LD_INT 0
32680: PUSH
32681: LD_INT 0
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: LD_INT 1
32693: NEG
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: PUSH
32699: LD_INT 1
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 1
32711: PUSH
32712: LD_INT 1
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: LD_INT 1
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: PUSH
32733: LD_INT 0
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 1
32742: NEG
32743: PUSH
32744: LD_INT 1
32746: NEG
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 1
32754: NEG
32755: PUSH
32756: LD_INT 2
32758: NEG
32759: PUSH
32760: EMPTY
32761: LIST
32762: LIST
32763: PUSH
32764: LD_INT 0
32766: PUSH
32767: LD_INT 2
32769: NEG
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: PUSH
32778: LD_INT 1
32780: NEG
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: PUSH
32789: LD_INT 1
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 2
32798: PUSH
32799: LD_INT 2
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 1
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 0
32818: PUSH
32819: LD_INT 2
32821: PUSH
32822: EMPTY
32823: LIST
32824: LIST
32825: PUSH
32826: LD_INT 1
32828: NEG
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 2
32839: NEG
32840: PUSH
32841: LD_INT 1
32843: NEG
32844: PUSH
32845: EMPTY
32846: LIST
32847: LIST
32848: PUSH
32849: LD_INT 2
32851: NEG
32852: PUSH
32853: LD_INT 2
32855: NEG
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: LD_INT 3
32867: NEG
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 1
32875: NEG
32876: PUSH
32877: LD_INT 3
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 0
32887: PUSH
32888: LD_INT 3
32890: NEG
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 1
32898: PUSH
32899: LD_INT 2
32901: NEG
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 3
32909: PUSH
32910: LD_INT 2
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 3
32919: PUSH
32920: LD_INT 3
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: LD_INT 2
32929: PUSH
32930: LD_INT 3
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 1
32939: PUSH
32940: LD_INT 3
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: LD_INT 3
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 1
32959: NEG
32960: PUSH
32961: LD_INT 2
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 3
32970: NEG
32971: PUSH
32972: LD_INT 2
32974: NEG
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 3
32982: NEG
32983: PUSH
32984: LD_INT 3
32986: NEG
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: LIST
33020: LIST
33021: LIST
33022: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33023: LD_ADDR_VAR 0 43
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: LD_INT 0
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: LD_INT 1
33043: NEG
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: LD_INT 0
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 1
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: LD_INT 1
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: NEG
33082: PUSH
33083: LD_INT 0
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: LD_INT 1
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 1
33104: NEG
33105: PUSH
33106: LD_INT 2
33108: NEG
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 0
33116: PUSH
33117: LD_INT 2
33119: NEG
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 1
33127: PUSH
33128: LD_INT 1
33130: NEG
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 2
33138: PUSH
33139: LD_INT 0
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: LD_INT 2
33148: PUSH
33149: LD_INT 1
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: LD_INT 2
33161: PUSH
33162: EMPTY
33163: LIST
33164: LIST
33165: PUSH
33166: LD_INT 0
33168: PUSH
33169: LD_INT 2
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 1
33178: NEG
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 2
33189: NEG
33190: PUSH
33191: LD_INT 0
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 2
33200: NEG
33201: PUSH
33202: LD_INT 1
33204: NEG
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: LD_INT 3
33216: NEG
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 0
33224: PUSH
33225: LD_INT 3
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: PUSH
33236: LD_INT 2
33238: NEG
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 2
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 3
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 3
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: LD_INT 3
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 0
33287: PUSH
33288: LD_INT 3
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 1
33297: NEG
33298: PUSH
33299: LD_INT 2
33301: PUSH
33302: EMPTY
33303: LIST
33304: LIST
33305: PUSH
33306: LD_INT 2
33308: NEG
33309: PUSH
33310: LD_INT 1
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: PUSH
33317: LD_INT 3
33319: NEG
33320: PUSH
33321: LD_INT 0
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 3
33330: NEG
33331: PUSH
33332: LD_INT 1
33334: NEG
33335: PUSH
33336: EMPTY
33337: LIST
33338: LIST
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: LIST
33359: LIST
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33371: LD_ADDR_VAR 0 44
33375: PUSH
33376: LD_INT 0
33378: PUSH
33379: LD_INT 0
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: LD_INT 1
33391: NEG
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PUSH
33397: LD_INT 1
33399: PUSH
33400: LD_INT 0
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 1
33409: PUSH
33410: LD_INT 1
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: LD_INT 1
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 1
33429: NEG
33430: PUSH
33431: LD_INT 0
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 1
33440: NEG
33441: PUSH
33442: LD_INT 1
33444: NEG
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 1
33452: NEG
33453: PUSH
33454: LD_INT 2
33456: NEG
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: LD_INT 1
33464: PUSH
33465: LD_INT 1
33467: NEG
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 2
33475: PUSH
33476: LD_INT 0
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 2
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 2
33495: PUSH
33496: LD_INT 2
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: LD_INT 2
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 2
33526: NEG
33527: PUSH
33528: LD_INT 0
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 2
33537: NEG
33538: PUSH
33539: LD_INT 1
33541: NEG
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 2
33549: NEG
33550: PUSH
33551: LD_INT 2
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 2
33561: NEG
33562: PUSH
33563: LD_INT 3
33565: NEG
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: LD_INT 2
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 3
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: LD_INT 3
33594: PUSH
33595: LD_INT 1
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 3
33604: PUSH
33605: LD_INT 2
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 3
33614: PUSH
33615: LD_INT 3
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 2
33624: PUSH
33625: LD_INT 3
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 2
33634: NEG
33635: PUSH
33636: LD_INT 1
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 3
33645: NEG
33646: PUSH
33647: LD_INT 0
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 3
33656: NEG
33657: PUSH
33658: LD_INT 1
33660: NEG
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 3
33668: NEG
33669: PUSH
33670: LD_INT 2
33672: NEG
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 3
33680: NEG
33681: PUSH
33682: LD_INT 3
33684: NEG
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33721: LD_ADDR_VAR 0 45
33725: PUSH
33726: LD_INT 0
33728: PUSH
33729: LD_INT 0
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: LD_INT 1
33741: NEG
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: PUSH
33747: LD_INT 1
33749: PUSH
33750: LD_INT 0
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: LD_INT 1
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: LD_INT 1
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 1
33779: NEG
33780: PUSH
33781: LD_INT 0
33783: PUSH
33784: EMPTY
33785: LIST
33786: LIST
33787: PUSH
33788: LD_INT 1
33790: NEG
33791: PUSH
33792: LD_INT 1
33794: NEG
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 1
33802: NEG
33803: PUSH
33804: LD_INT 2
33806: NEG
33807: PUSH
33808: EMPTY
33809: LIST
33810: LIST
33811: PUSH
33812: LD_INT 0
33814: PUSH
33815: LD_INT 2
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 1
33825: PUSH
33826: LD_INT 1
33828: NEG
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: LD_INT 1
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: LD_INT 2
33846: PUSH
33847: LD_INT 2
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 1
33856: PUSH
33857: LD_INT 2
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: LD_INT 2
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 1
33876: NEG
33877: PUSH
33878: LD_INT 1
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 2
33887: NEG
33888: PUSH
33889: LD_INT 1
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 2
33899: NEG
33900: PUSH
33901: LD_INT 2
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 2
33911: NEG
33912: PUSH
33913: LD_INT 3
33915: NEG
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: LD_INT 3
33927: NEG
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 0
33935: PUSH
33936: LD_INT 3
33938: NEG
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: LD_INT 2
33949: NEG
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: LD_INT 3
33957: PUSH
33958: LD_INT 2
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 3
33967: PUSH
33968: LD_INT 3
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 2
33977: PUSH
33978: LD_INT 3
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: PUSH
33985: LD_INT 1
33987: PUSH
33988: LD_INT 3
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 0
33997: PUSH
33998: LD_INT 3
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 1
34007: NEG
34008: PUSH
34009: LD_INT 2
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 3
34018: NEG
34019: PUSH
34020: LD_INT 2
34022: NEG
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: PUSH
34028: LD_INT 3
34030: NEG
34031: PUSH
34032: LD_INT 3
34034: NEG
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34071: LD_ADDR_VAR 0 46
34075: PUSH
34076: LD_INT 0
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 0
34088: PUSH
34089: LD_INT 1
34091: NEG
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 1
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 0
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: NEG
34130: PUSH
34131: LD_INT 0
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 1
34140: NEG
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: LD_INT 2
34156: NEG
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: LD_INT 2
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 1
34175: PUSH
34176: LD_INT 1
34178: NEG
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 2
34186: PUSH
34187: LD_INT 0
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 2
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 2
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 2
34237: NEG
34238: PUSH
34239: LD_INT 0
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 2
34248: NEG
34249: PUSH
34250: LD_INT 1
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 1
34260: NEG
34261: PUSH
34262: LD_INT 3
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 0
34272: PUSH
34273: LD_INT 3
34275: NEG
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 1
34283: PUSH
34284: LD_INT 2
34286: NEG
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 2
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 3
34305: PUSH
34306: LD_INT 0
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 3
34315: PUSH
34316: LD_INT 1
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: PUSH
34326: LD_INT 3
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: LD_INT 3
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: LD_INT 2
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 2
34356: NEG
34357: PUSH
34358: LD_INT 1
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 3
34367: NEG
34368: PUSH
34369: LD_INT 0
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 3
34378: NEG
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: EMPTY
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34419: LD_ADDR_VAR 0 47
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: LD_INT 0
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 0
34436: PUSH
34437: LD_INT 1
34439: NEG
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 1
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: LD_INT 1
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 0
34467: PUSH
34468: LD_INT 1
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 1
34477: NEG
34478: PUSH
34479: LD_INT 0
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 1
34488: NEG
34489: PUSH
34490: LD_INT 1
34492: NEG
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 1
34500: NEG
34501: PUSH
34502: LD_INT 2
34504: NEG
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 0
34512: PUSH
34513: LD_INT 2
34515: NEG
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: LD_INT 1
34526: NEG
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 2
34534: NEG
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: EMPTY
34541: LIST
34542: LIST
34543: PUSH
34544: LD_INT 2
34546: NEG
34547: PUSH
34548: LD_INT 2
34550: NEG
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: LIST
34564: LIST
34565: LIST
34566: LIST
34567: LIST
34568: LIST
34569: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34570: LD_ADDR_VAR 0 48
34574: PUSH
34575: LD_INT 0
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 1
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: LD_INT 1
34643: NEG
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 1
34651: NEG
34652: PUSH
34653: LD_INT 2
34655: NEG
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: LD_INT 2
34666: NEG
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 1
34674: PUSH
34675: LD_INT 1
34677: NEG
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 2
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 2
34695: PUSH
34696: LD_INT 1
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34717: LD_ADDR_VAR 0 49
34721: PUSH
34722: LD_INT 0
34724: PUSH
34725: LD_INT 0
34727: PUSH
34728: EMPTY
34729: LIST
34730: LIST
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: LD_INT 1
34737: NEG
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 1
34745: PUSH
34746: LD_INT 0
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: PUSH
34756: LD_INT 1
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 0
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: LD_INT 0
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: NEG
34787: PUSH
34788: LD_INT 1
34790: NEG
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 1
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 2
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 2
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 2
34829: PUSH
34830: LD_INT 2
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 2
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: LIST
34851: LIST
34852: LIST
34853: LIST
34854: LIST
34855: LIST
34856: LIST
34857: LIST
34858: LIST
34859: LIST
34860: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34861: LD_ADDR_VAR 0 50
34865: PUSH
34866: LD_INT 0
34868: PUSH
34869: LD_INT 0
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 0
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: EMPTY
34884: LIST
34885: LIST
34886: PUSH
34887: LD_INT 1
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 1
34899: PUSH
34900: LD_INT 1
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 0
34909: PUSH
34910: LD_INT 1
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 1
34919: NEG
34920: PUSH
34921: LD_INT 0
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: LD_INT 1
34934: NEG
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 2
34942: PUSH
34943: LD_INT 1
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 2
34952: PUSH
34953: LD_INT 2
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 1
34962: PUSH
34963: LD_INT 2
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: PUSH
34970: LD_INT 0
34972: PUSH
34973: LD_INT 2
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: NEG
34983: PUSH
34984: LD_INT 1
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
35005: LD_ADDR_VAR 0 51
35009: PUSH
35010: LD_INT 0
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: PUSH
35020: LD_INT 0
35022: PUSH
35023: LD_INT 1
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: PUSH
35034: LD_INT 0
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: PUSH
35044: LD_INT 1
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 0
35053: PUSH
35054: LD_INT 1
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 1
35063: NEG
35064: PUSH
35065: LD_INT 0
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: LD_INT 1
35078: NEG
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: PUSH
35087: LD_INT 2
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 0
35096: PUSH
35097: LD_INT 2
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 1
35106: NEG
35107: PUSH
35108: LD_INT 1
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: PUSH
35115: LD_INT 2
35117: NEG
35118: PUSH
35119: LD_INT 0
35121: PUSH
35122: EMPTY
35123: LIST
35124: LIST
35125: PUSH
35126: LD_INT 2
35128: NEG
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35152: LD_ADDR_VAR 0 52
35156: PUSH
35157: LD_INT 0
35159: PUSH
35160: LD_INT 0
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 0
35169: PUSH
35170: LD_INT 1
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: LD_INT 0
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 1
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 1
35210: NEG
35211: PUSH
35212: LD_INT 0
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: NEG
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: NEG
35234: PUSH
35235: LD_INT 2
35237: NEG
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 1
35245: NEG
35246: PUSH
35247: LD_INT 1
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 2
35256: NEG
35257: PUSH
35258: LD_INT 0
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 2
35267: NEG
35268: PUSH
35269: LD_INT 1
35271: NEG
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 2
35279: NEG
35280: PUSH
35281: LD_INT 2
35283: NEG
35284: PUSH
35285: EMPTY
35286: LIST
35287: LIST
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35303: LD_ADDR_VAR 0 53
35307: PUSH
35308: LD_INT 0
35310: PUSH
35311: LD_INT 0
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: LD_INT 1
35323: NEG
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: LD_INT 0
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 1
35341: PUSH
35342: LD_INT 1
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 1
35361: NEG
35362: PUSH
35363: LD_INT 0
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: LD_INT 1
35376: NEG
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: NEG
35385: PUSH
35386: LD_INT 2
35388: NEG
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: LD_INT 2
35399: NEG
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 1
35407: PUSH
35408: LD_INT 1
35410: NEG
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 2
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: PUSH
35429: LD_INT 1
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 2
35438: PUSH
35439: LD_INT 2
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 1
35448: PUSH
35449: LD_INT 2
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: LD_INT 2
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 2
35479: NEG
35480: PUSH
35481: LD_INT 0
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 2
35490: NEG
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 2
35502: NEG
35503: PUSH
35504: LD_INT 2
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: LIST
35516: LIST
35517: LIST
35518: LIST
35519: LIST
35520: LIST
35521: LIST
35522: LIST
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35533: LD_ADDR_VAR 0 54
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: LD_INT 0
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 0
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 1
35571: PUSH
35572: LD_INT 1
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 0
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 1
35591: NEG
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 1
35614: NEG
35615: PUSH
35616: LD_INT 2
35618: NEG
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 0
35626: PUSH
35627: LD_INT 2
35629: NEG
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: LD_INT 1
35637: PUSH
35638: LD_INT 1
35640: NEG
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 2
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 2
35658: PUSH
35659: LD_INT 1
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 2
35668: PUSH
35669: LD_INT 2
35671: PUSH
35672: EMPTY
35673: LIST
35674: LIST
35675: PUSH
35676: LD_INT 1
35678: PUSH
35679: LD_INT 2
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: LD_INT 2
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 1
35698: NEG
35699: PUSH
35700: LD_INT 1
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 2
35709: NEG
35710: PUSH
35711: LD_INT 0
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 2
35720: NEG
35721: PUSH
35722: LD_INT 1
35724: NEG
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 2
35732: NEG
35733: PUSH
35734: LD_INT 2
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35763: LD_ADDR_VAR 0 55
35767: PUSH
35768: LD_INT 0
35770: PUSH
35771: LD_INT 0
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: LD_INT 1
35783: NEG
35784: PUSH
35785: EMPTY
35786: LIST
35787: LIST
35788: PUSH
35789: LD_INT 1
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 1
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: LD_INT 1
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: NEG
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 1
35832: NEG
35833: PUSH
35834: LD_INT 1
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 1
35844: NEG
35845: PUSH
35846: LD_INT 2
35848: NEG
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: LD_INT 2
35859: NEG
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 1
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 2
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 2
35888: PUSH
35889: LD_INT 1
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 2
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: LD_INT 2
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: NEG
35929: PUSH
35930: LD_INT 1
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: NEG
35940: PUSH
35941: LD_INT 0
35943: PUSH
35944: EMPTY
35945: LIST
35946: LIST
35947: PUSH
35948: LD_INT 2
35950: NEG
35951: PUSH
35952: LD_INT 1
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 2
35962: NEG
35963: PUSH
35964: LD_INT 2
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35993: LD_ADDR_VAR 0 56
35997: PUSH
35998: LD_INT 0
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: LD_INT 1
36013: NEG
36014: PUSH
36015: EMPTY
36016: LIST
36017: LIST
36018: PUSH
36019: LD_INT 1
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 1
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: LD_INT 0
36041: PUSH
36042: LD_INT 1
36044: PUSH
36045: EMPTY
36046: LIST
36047: LIST
36048: PUSH
36049: LD_INT 1
36051: NEG
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 1
36062: NEG
36063: PUSH
36064: LD_INT 1
36066: NEG
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: NEG
36075: PUSH
36076: LD_INT 2
36078: NEG
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 0
36086: PUSH
36087: LD_INT 2
36089: NEG
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 1
36097: PUSH
36098: LD_INT 1
36100: NEG
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 2
36108: PUSH
36109: LD_INT 0
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 2
36118: PUSH
36119: LD_INT 1
36121: PUSH
36122: EMPTY
36123: LIST
36124: LIST
36125: PUSH
36126: LD_INT 2
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 1
36138: PUSH
36139: LD_INT 2
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: LD_INT 2
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 2
36169: NEG
36170: PUSH
36171: LD_INT 0
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 2
36180: NEG
36181: PUSH
36182: LD_INT 1
36184: NEG
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 2
36192: NEG
36193: PUSH
36194: LD_INT 2
36196: NEG
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: LIST
36206: LIST
36207: LIST
36208: LIST
36209: LIST
36210: LIST
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36223: LD_ADDR_VAR 0 57
36227: PUSH
36228: LD_INT 0
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: LD_INT 1
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 1
36251: PUSH
36252: LD_INT 0
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: LD_INT 1
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: LD_INT 1
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: LD_INT 0
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 1
36292: NEG
36293: PUSH
36294: LD_INT 1
36296: NEG
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: LD_INT 2
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 0
36316: PUSH
36317: LD_INT 2
36319: NEG
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: PUSH
36328: LD_INT 1
36330: NEG
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 2
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: EMPTY
36343: LIST
36344: LIST
36345: PUSH
36346: LD_INT 2
36348: PUSH
36349: LD_INT 1
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 2
36358: PUSH
36359: LD_INT 2
36361: PUSH
36362: EMPTY
36363: LIST
36364: LIST
36365: PUSH
36366: LD_INT 1
36368: PUSH
36369: LD_INT 2
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: LD_INT 2
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: LD_INT 1
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 2
36399: NEG
36400: PUSH
36401: LD_INT 0
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 2
36410: NEG
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 2
36422: NEG
36423: PUSH
36424: LD_INT 2
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: LIST
36452: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36453: LD_ADDR_VAR 0 58
36457: PUSH
36458: LD_INT 0
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 0
36470: PUSH
36471: LD_INT 1
36473: NEG
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 1
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: LD_INT 0
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 1
36522: NEG
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: LD_INT 2
36538: NEG
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 2
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: LD_INT 1
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 2
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 2
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 2
36588: PUSH
36589: LD_INT 2
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: LD_INT 2
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 0
36608: PUSH
36609: LD_INT 2
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 1
36618: NEG
36619: PUSH
36620: LD_INT 1
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 2
36629: NEG
36630: PUSH
36631: LD_INT 0
36633: PUSH
36634: EMPTY
36635: LIST
36636: LIST
36637: PUSH
36638: LD_INT 2
36640: NEG
36641: PUSH
36642: LD_INT 1
36644: NEG
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 2
36652: NEG
36653: PUSH
36654: LD_INT 2
36656: NEG
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36683: LD_ADDR_VAR 0 59
36687: PUSH
36688: LD_INT 0
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 1
36711: PUSH
36712: LD_INT 0
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: LD_INT 1
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: LD_INT 1
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 1
36741: NEG
36742: PUSH
36743: LD_INT 0
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 1
36752: NEG
36753: PUSH
36754: LD_INT 1
36756: NEG
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: LIST
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36771: LD_ADDR_VAR 0 60
36775: PUSH
36776: LD_INT 0
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 0
36788: PUSH
36789: LD_INT 1
36791: NEG
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 1
36799: PUSH
36800: LD_INT 0
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: LD_INT 1
36809: PUSH
36810: LD_INT 1
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 0
36819: PUSH
36820: LD_INT 1
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 1
36829: NEG
36830: PUSH
36831: LD_INT 0
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 1
36840: NEG
36841: PUSH
36842: LD_INT 1
36844: NEG
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36859: LD_ADDR_VAR 0 61
36863: PUSH
36864: LD_INT 0
36866: PUSH
36867: LD_INT 0
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PUSH
36874: LD_INT 0
36876: PUSH
36877: LD_INT 1
36879: NEG
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 1
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 1
36897: PUSH
36898: LD_INT 1
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 0
36907: PUSH
36908: LD_INT 1
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 1
36917: NEG
36918: PUSH
36919: LD_INT 0
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 1
36928: NEG
36929: PUSH
36930: LD_INT 1
36932: NEG
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36947: LD_ADDR_VAR 0 62
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: LD_INT 0
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 0
36964: PUSH
36965: LD_INT 1
36967: NEG
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 1
36975: PUSH
36976: LD_INT 0
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 1
36985: PUSH
36986: LD_INT 1
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 0
36995: PUSH
36996: LD_INT 1
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 1
37005: NEG
37006: PUSH
37007: LD_INT 0
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: LD_INT 1
37016: NEG
37017: PUSH
37018: LD_INT 1
37020: NEG
37021: PUSH
37022: EMPTY
37023: LIST
37024: LIST
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37035: LD_ADDR_VAR 0 63
37039: PUSH
37040: LD_INT 0
37042: PUSH
37043: LD_INT 0
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 0
37052: PUSH
37053: LD_INT 1
37055: NEG
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: LD_INT 0
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: LD_INT 1
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 0
37083: PUSH
37084: LD_INT 1
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 1
37093: NEG
37094: PUSH
37095: LD_INT 0
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 1
37104: NEG
37105: PUSH
37106: LD_INT 1
37108: NEG
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37123: LD_ADDR_VAR 0 64
37127: PUSH
37128: LD_INT 0
37130: PUSH
37131: LD_INT 0
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 0
37140: PUSH
37141: LD_INT 1
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 1
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: PUSH
37162: LD_INT 1
37164: PUSH
37165: EMPTY
37166: LIST
37167: LIST
37168: PUSH
37169: LD_INT 0
37171: PUSH
37172: LD_INT 1
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: PUSH
37179: LD_INT 1
37181: NEG
37182: PUSH
37183: LD_INT 0
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: LD_INT 1
37192: NEG
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: ST_TO_ADDR
// end ; 1 :
37211: GO 43108
37213: LD_INT 1
37215: DOUBLE
37216: EQUAL
37217: IFTRUE 37221
37219: GO 39844
37221: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37222: LD_ADDR_VAR 0 11
37226: PUSH
37227: LD_INT 1
37229: NEG
37230: PUSH
37231: LD_INT 3
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 0
37241: PUSH
37242: LD_INT 3
37244: NEG
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: LD_INT 2
37255: NEG
37256: PUSH
37257: EMPTY
37258: LIST
37259: LIST
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: LIST
37265: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37266: LD_ADDR_VAR 0 12
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 1
37276: NEG
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 3
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 3
37294: PUSH
37295: LD_INT 1
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: LIST
37306: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37307: LD_ADDR_VAR 0 13
37311: PUSH
37312: LD_INT 3
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 3
37324: PUSH
37325: LD_INT 3
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 2
37334: PUSH
37335: LD_INT 3
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: LIST
37346: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37347: LD_ADDR_VAR 0 14
37351: PUSH
37352: LD_INT 1
37354: PUSH
37355: LD_INT 3
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: PUSH
37362: LD_INT 0
37364: PUSH
37365: LD_INT 3
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 1
37374: NEG
37375: PUSH
37376: LD_INT 2
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: LIST
37387: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37388: LD_ADDR_VAR 0 15
37392: PUSH
37393: LD_INT 2
37395: NEG
37396: PUSH
37397: LD_INT 1
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 3
37406: NEG
37407: PUSH
37408: LD_INT 0
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 3
37417: NEG
37418: PUSH
37419: LD_INT 1
37421: NEG
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: LIST
37431: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37432: LD_ADDR_VAR 0 16
37436: PUSH
37437: LD_INT 2
37439: NEG
37440: PUSH
37441: LD_INT 3
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 3
37451: NEG
37452: PUSH
37453: LD_INT 2
37455: NEG
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 3
37463: NEG
37464: PUSH
37465: LD_INT 3
37467: NEG
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: LIST
37477: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37478: LD_ADDR_VAR 0 17
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: LD_INT 3
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 0
37497: PUSH
37498: LD_INT 3
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: PUSH
37509: LD_INT 2
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: LIST
37521: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37522: LD_ADDR_VAR 0 18
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: LD_INT 1
37532: NEG
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: PUSH
37538: LD_INT 3
37540: PUSH
37541: LD_INT 0
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 3
37550: PUSH
37551: LD_INT 1
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: LIST
37562: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37563: LD_ADDR_VAR 0 19
37567: PUSH
37568: LD_INT 3
37570: PUSH
37571: LD_INT 2
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 3
37580: PUSH
37581: LD_INT 3
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: PUSH
37591: LD_INT 3
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: LIST
37602: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37603: LD_ADDR_VAR 0 20
37607: PUSH
37608: LD_INT 1
37610: PUSH
37611: LD_INT 3
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 0
37620: PUSH
37621: LD_INT 3
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: LD_INT 2
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: LIST
37643: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37644: LD_ADDR_VAR 0 21
37648: PUSH
37649: LD_INT 2
37651: NEG
37652: PUSH
37653: LD_INT 1
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 3
37662: NEG
37663: PUSH
37664: LD_INT 0
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 3
37673: NEG
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37688: LD_ADDR_VAR 0 22
37692: PUSH
37693: LD_INT 2
37695: NEG
37696: PUSH
37697: LD_INT 3
37699: NEG
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 3
37707: NEG
37708: PUSH
37709: LD_INT 2
37711: NEG
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 3
37719: NEG
37720: PUSH
37721: LD_INT 3
37723: NEG
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: LIST
37733: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37734: LD_ADDR_VAR 0 23
37738: PUSH
37739: LD_INT 0
37741: PUSH
37742: LD_INT 3
37744: NEG
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 1
37752: NEG
37753: PUSH
37754: LD_INT 4
37756: NEG
37757: PUSH
37758: EMPTY
37759: LIST
37760: LIST
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: LD_INT 3
37767: NEG
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: LIST
37777: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37778: LD_ADDR_VAR 0 24
37782: PUSH
37783: LD_INT 3
37785: PUSH
37786: LD_INT 0
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 3
37795: PUSH
37796: LD_INT 1
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 4
37806: PUSH
37807: LD_INT 1
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: LIST
37818: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37819: LD_ADDR_VAR 0 25
37823: PUSH
37824: LD_INT 3
37826: PUSH
37827: LD_INT 3
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 4
37836: PUSH
37837: LD_INT 3
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 3
37846: PUSH
37847: LD_INT 4
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: LIST
37858: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37859: LD_ADDR_VAR 0 26
37863: PUSH
37864: LD_INT 0
37866: PUSH
37867: LD_INT 3
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: LD_INT 4
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 1
37886: NEG
37887: PUSH
37888: LD_INT 3
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: LIST
37899: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37900: LD_ADDR_VAR 0 27
37904: PUSH
37905: LD_INT 3
37907: NEG
37908: PUSH
37909: LD_INT 0
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 3
37918: NEG
37919: PUSH
37920: LD_INT 1
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 4
37929: NEG
37930: PUSH
37931: LD_INT 1
37933: NEG
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37944: LD_ADDR_VAR 0 28
37948: PUSH
37949: LD_INT 3
37951: NEG
37952: PUSH
37953: LD_INT 3
37955: NEG
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: PUSH
37961: LD_INT 3
37963: NEG
37964: PUSH
37965: LD_INT 4
37967: NEG
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 4
37975: NEG
37976: PUSH
37977: LD_INT 3
37979: NEG
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: LIST
37989: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37990: LD_ADDR_VAR 0 29
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: LD_INT 3
38001: NEG
38002: PUSH
38003: EMPTY
38004: LIST
38005: LIST
38006: PUSH
38007: LD_INT 0
38009: PUSH
38010: LD_INT 3
38012: NEG
38013: PUSH
38014: EMPTY
38015: LIST
38016: LIST
38017: PUSH
38018: LD_INT 1
38020: PUSH
38021: LD_INT 2
38023: NEG
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 1
38031: NEG
38032: PUSH
38033: LD_INT 4
38035: NEG
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 0
38043: PUSH
38044: LD_INT 4
38046: NEG
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: LD_INT 1
38054: PUSH
38055: LD_INT 3
38057: NEG
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 1
38065: NEG
38066: PUSH
38067: LD_INT 5
38069: NEG
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 0
38077: PUSH
38078: LD_INT 5
38080: NEG
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 1
38088: PUSH
38089: LD_INT 4
38091: NEG
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 1
38099: NEG
38100: PUSH
38101: LD_INT 6
38103: NEG
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 0
38111: PUSH
38112: LD_INT 6
38114: NEG
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 1
38122: PUSH
38123: LD_INT 5
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: LIST
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: LIST
38140: LIST
38141: LIST
38142: LIST
38143: LIST
38144: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
38145: LD_ADDR_VAR 0 30
38149: PUSH
38150: LD_INT 2
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 3
38163: PUSH
38164: LD_INT 0
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 3
38173: PUSH
38174: LD_INT 1
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 3
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 4
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 4
38204: PUSH
38205: LD_INT 1
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 4
38214: PUSH
38215: LD_INT 1
38217: NEG
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 5
38225: PUSH
38226: LD_INT 0
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 5
38235: PUSH
38236: LD_INT 1
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 5
38245: PUSH
38246: LD_INT 1
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 6
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 6
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: LIST
38285: LIST
38286: LIST
38287: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
38288: LD_ADDR_VAR 0 31
38292: PUSH
38293: LD_INT 3
38295: PUSH
38296: LD_INT 2
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 3
38305: PUSH
38306: LD_INT 3
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 2
38315: PUSH
38316: LD_INT 3
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 4
38325: PUSH
38326: LD_INT 3
38328: PUSH
38329: EMPTY
38330: LIST
38331: LIST
38332: PUSH
38333: LD_INT 4
38335: PUSH
38336: LD_INT 4
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 3
38345: PUSH
38346: LD_INT 4
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 5
38355: PUSH
38356: LD_INT 4
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 5
38365: PUSH
38366: LD_INT 5
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 4
38375: PUSH
38376: LD_INT 5
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 6
38385: PUSH
38386: LD_INT 5
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 6
38395: PUSH
38396: LD_INT 6
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 5
38405: PUSH
38406: LD_INT 6
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: LIST
38426: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38427: LD_ADDR_VAR 0 32
38431: PUSH
38432: LD_INT 1
38434: PUSH
38435: LD_INT 3
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 0
38444: PUSH
38445: LD_INT 3
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 1
38454: NEG
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: PUSH
38466: LD_INT 4
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 0
38475: PUSH
38476: LD_INT 4
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: NEG
38486: PUSH
38487: LD_INT 3
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 1
38496: PUSH
38497: LD_INT 5
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 0
38506: PUSH
38507: LD_INT 5
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: NEG
38517: PUSH
38518: LD_INT 4
38520: PUSH
38521: EMPTY
38522: LIST
38523: LIST
38524: PUSH
38525: LD_INT 1
38527: PUSH
38528: LD_INT 6
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 0
38537: PUSH
38538: LD_INT 6
38540: PUSH
38541: EMPTY
38542: LIST
38543: LIST
38544: PUSH
38545: LD_INT 1
38547: NEG
38548: PUSH
38549: LD_INT 5
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: LIST
38568: LIST
38569: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38570: LD_ADDR_VAR 0 33
38574: PUSH
38575: LD_INT 2
38577: NEG
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 3
38588: NEG
38589: PUSH
38590: LD_INT 0
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 3
38599: NEG
38600: PUSH
38601: LD_INT 1
38603: NEG
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: LD_INT 3
38611: NEG
38612: PUSH
38613: LD_INT 1
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 4
38622: NEG
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 4
38633: NEG
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 4
38645: NEG
38646: PUSH
38647: LD_INT 1
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 5
38656: NEG
38657: PUSH
38658: LD_INT 0
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 5
38667: NEG
38668: PUSH
38669: LD_INT 1
38671: NEG
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 5
38679: NEG
38680: PUSH
38681: LD_INT 1
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 6
38690: NEG
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: PUSH
38699: LD_INT 6
38701: NEG
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: LIST
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38725: LD_ADDR_VAR 0 34
38729: PUSH
38730: LD_INT 2
38732: NEG
38733: PUSH
38734: LD_INT 3
38736: NEG
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 3
38744: NEG
38745: PUSH
38746: LD_INT 2
38748: NEG
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 3
38756: NEG
38757: PUSH
38758: LD_INT 3
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 3
38768: NEG
38769: PUSH
38770: LD_INT 4
38772: NEG
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 4
38780: NEG
38781: PUSH
38782: LD_INT 3
38784: NEG
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 4
38792: NEG
38793: PUSH
38794: LD_INT 4
38796: NEG
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 4
38804: NEG
38805: PUSH
38806: LD_INT 5
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 5
38816: NEG
38817: PUSH
38818: LD_INT 4
38820: NEG
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 5
38828: NEG
38829: PUSH
38830: LD_INT 5
38832: NEG
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: LD_INT 5
38840: NEG
38841: PUSH
38842: LD_INT 6
38844: NEG
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 6
38852: NEG
38853: PUSH
38854: LD_INT 5
38856: NEG
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 6
38864: NEG
38865: PUSH
38866: LD_INT 6
38868: NEG
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: EMPTY
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38888: LD_ADDR_VAR 0 41
38892: PUSH
38893: LD_INT 0
38895: PUSH
38896: LD_INT 2
38898: NEG
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: LD_INT 3
38910: NEG
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: PUSH
38916: LD_INT 1
38918: PUSH
38919: LD_INT 2
38921: NEG
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: LIST
38931: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38932: LD_ADDR_VAR 0 42
38936: PUSH
38937: LD_INT 2
38939: PUSH
38940: LD_INT 0
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 2
38949: PUSH
38950: LD_INT 1
38952: NEG
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 3
38960: PUSH
38961: LD_INT 1
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: LIST
38972: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38973: LD_ADDR_VAR 0 43
38977: PUSH
38978: LD_INT 2
38980: PUSH
38981: LD_INT 2
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 3
38990: PUSH
38991: LD_INT 2
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 2
39000: PUSH
39001: LD_INT 3
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: LIST
39012: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
39013: LD_ADDR_VAR 0 44
39017: PUSH
39018: LD_INT 0
39020: PUSH
39021: LD_INT 2
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: PUSH
39028: LD_INT 1
39030: PUSH
39031: LD_INT 3
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 1
39040: NEG
39041: PUSH
39042: LD_INT 2
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: LIST
39053: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39054: LD_ADDR_VAR 0 45
39058: PUSH
39059: LD_INT 2
39061: NEG
39062: PUSH
39063: LD_INT 0
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 2
39072: NEG
39073: PUSH
39074: LD_INT 1
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 3
39083: NEG
39084: PUSH
39085: LD_INT 1
39087: NEG
39088: PUSH
39089: EMPTY
39090: LIST
39091: LIST
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: LIST
39097: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
39098: LD_ADDR_VAR 0 46
39102: PUSH
39103: LD_INT 2
39105: NEG
39106: PUSH
39107: LD_INT 2
39109: NEG
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 2
39117: NEG
39118: PUSH
39119: LD_INT 3
39121: NEG
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 3
39129: NEG
39130: PUSH
39131: LD_INT 2
39133: NEG
39134: PUSH
39135: EMPTY
39136: LIST
39137: LIST
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: LIST
39143: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
39144: LD_ADDR_VAR 0 47
39148: PUSH
39149: LD_INT 2
39151: NEG
39152: PUSH
39153: LD_INT 3
39155: NEG
39156: PUSH
39157: EMPTY
39158: LIST
39159: LIST
39160: PUSH
39161: LD_INT 1
39163: NEG
39164: PUSH
39165: LD_INT 3
39167: NEG
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
39177: LD_ADDR_VAR 0 48
39181: PUSH
39182: LD_INT 1
39184: PUSH
39185: LD_INT 2
39187: NEG
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 2
39195: PUSH
39196: LD_INT 1
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
39208: LD_ADDR_VAR 0 49
39212: PUSH
39213: LD_INT 3
39215: PUSH
39216: LD_INT 1
39218: PUSH
39219: EMPTY
39220: LIST
39221: LIST
39222: PUSH
39223: LD_INT 3
39225: PUSH
39226: LD_INT 2
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
39237: LD_ADDR_VAR 0 50
39241: PUSH
39242: LD_INT 2
39244: PUSH
39245: LD_INT 3
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 1
39254: PUSH
39255: LD_INT 3
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
39266: LD_ADDR_VAR 0 51
39270: PUSH
39271: LD_INT 1
39273: NEG
39274: PUSH
39275: LD_INT 2
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: NEG
39285: PUSH
39286: LD_INT 1
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
39297: LD_ADDR_VAR 0 52
39301: PUSH
39302: LD_INT 3
39304: NEG
39305: PUSH
39306: LD_INT 1
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 3
39316: NEG
39317: PUSH
39318: LD_INT 2
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39330: LD_ADDR_VAR 0 53
39334: PUSH
39335: LD_INT 1
39337: NEG
39338: PUSH
39339: LD_INT 3
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: LD_INT 3
39352: NEG
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 1
39360: PUSH
39361: LD_INT 2
39363: NEG
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: LIST
39373: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39374: LD_ADDR_VAR 0 54
39378: PUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 1
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 3
39392: PUSH
39393: LD_INT 0
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 3
39402: PUSH
39403: LD_INT 1
39405: PUSH
39406: EMPTY
39407: LIST
39408: LIST
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: LIST
39414: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39415: LD_ADDR_VAR 0 55
39419: PUSH
39420: LD_INT 3
39422: PUSH
39423: LD_INT 2
39425: PUSH
39426: EMPTY
39427: LIST
39428: LIST
39429: PUSH
39430: LD_INT 3
39432: PUSH
39433: LD_INT 3
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 2
39442: PUSH
39443: LD_INT 3
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: LIST
39454: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39455: LD_ADDR_VAR 0 56
39459: PUSH
39460: LD_INT 1
39462: PUSH
39463: LD_INT 3
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 0
39472: PUSH
39473: LD_INT 3
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 1
39482: NEG
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: LIST
39495: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39496: LD_ADDR_VAR 0 57
39500: PUSH
39501: LD_INT 2
39503: NEG
39504: PUSH
39505: LD_INT 1
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 3
39514: NEG
39515: PUSH
39516: LD_INT 0
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 3
39525: NEG
39526: PUSH
39527: LD_INT 1
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39540: LD_ADDR_VAR 0 58
39544: PUSH
39545: LD_INT 2
39547: NEG
39548: PUSH
39549: LD_INT 3
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 3
39559: NEG
39560: PUSH
39561: LD_INT 2
39563: NEG
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 3
39571: NEG
39572: PUSH
39573: LD_INT 3
39575: NEG
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: LIST
39585: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39586: LD_ADDR_VAR 0 59
39590: PUSH
39591: LD_INT 1
39593: NEG
39594: PUSH
39595: LD_INT 2
39597: NEG
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_INT 2
39608: NEG
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 1
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: LIST
39629: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39630: LD_ADDR_VAR 0 60
39634: PUSH
39635: LD_INT 1
39637: PUSH
39638: LD_INT 1
39640: NEG
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 2
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 2
39658: PUSH
39659: LD_INT 1
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: LIST
39670: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39671: LD_ADDR_VAR 0 61
39675: PUSH
39676: LD_INT 2
39678: PUSH
39679: LD_INT 1
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: LD_INT 2
39688: PUSH
39689: LD_INT 2
39691: PUSH
39692: EMPTY
39693: LIST
39694: LIST
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: LD_INT 2
39701: PUSH
39702: EMPTY
39703: LIST
39704: LIST
39705: PUSH
39706: EMPTY
39707: LIST
39708: LIST
39709: LIST
39710: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39711: LD_ADDR_VAR 0 62
39715: PUSH
39716: LD_INT 1
39718: PUSH
39719: LD_INT 2
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 0
39728: PUSH
39729: LD_INT 2
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 1
39738: NEG
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: EMPTY
39748: LIST
39749: LIST
39750: LIST
39751: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39752: LD_ADDR_VAR 0 63
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: LD_INT 1
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 2
39770: NEG
39771: PUSH
39772: LD_INT 0
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 2
39781: NEG
39782: PUSH
39783: LD_INT 1
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39796: LD_ADDR_VAR 0 64
39800: PUSH
39801: LD_INT 1
39803: NEG
39804: PUSH
39805: LD_INT 2
39807: NEG
39808: PUSH
39809: EMPTY
39810: LIST
39811: LIST
39812: PUSH
39813: LD_INT 2
39815: NEG
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 2
39827: NEG
39828: PUSH
39829: LD_INT 2
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: LIST
39841: ST_TO_ADDR
// end ; 2 :
39842: GO 43108
39844: LD_INT 2
39846: DOUBLE
39847: EQUAL
39848: IFTRUE 39852
39850: GO 43107
39852: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39853: LD_ADDR_VAR 0 29
39857: PUSH
39858: LD_INT 4
39860: PUSH
39861: LD_INT 0
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 4
39870: PUSH
39871: LD_INT 1
39873: NEG
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 5
39881: PUSH
39882: LD_INT 0
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 5
39891: PUSH
39892: LD_INT 1
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 4
39901: PUSH
39902: LD_INT 1
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 3
39911: PUSH
39912: LD_INT 0
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 3
39921: PUSH
39922: LD_INT 1
39924: NEG
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 3
39932: PUSH
39933: LD_INT 2
39935: NEG
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 5
39943: PUSH
39944: LD_INT 2
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: PUSH
39951: LD_INT 3
39953: PUSH
39954: LD_INT 3
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 3
39963: PUSH
39964: LD_INT 2
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 4
39973: PUSH
39974: LD_INT 3
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 4
39983: PUSH
39984: LD_INT 4
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 3
39993: PUSH
39994: LD_INT 4
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 2
40003: PUSH
40004: LD_INT 3
40006: PUSH
40007: EMPTY
40008: LIST
40009: LIST
40010: PUSH
40011: LD_INT 2
40013: PUSH
40014: LD_INT 2
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: LD_INT 4
40023: PUSH
40024: LD_INT 2
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 2
40033: PUSH
40034: LD_INT 4
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 0
40043: PUSH
40044: LD_INT 4
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 0
40053: PUSH
40054: LD_INT 3
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: PUSH
40064: LD_INT 4
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 1
40073: PUSH
40074: LD_INT 5
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: LD_INT 0
40083: PUSH
40084: LD_INT 5
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: NEG
40094: PUSH
40095: LD_INT 4
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 1
40104: NEG
40105: PUSH
40106: LD_INT 3
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 2
40115: PUSH
40116: LD_INT 5
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 2
40125: NEG
40126: PUSH
40127: LD_INT 3
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 3
40136: NEG
40137: PUSH
40138: LD_INT 0
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 3
40147: NEG
40148: PUSH
40149: LD_INT 1
40151: NEG
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 2
40159: NEG
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 2
40170: NEG
40171: PUSH
40172: LD_INT 1
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 3
40181: NEG
40182: PUSH
40183: LD_INT 1
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 4
40192: NEG
40193: PUSH
40194: LD_INT 0
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 4
40203: NEG
40204: PUSH
40205: LD_INT 1
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 4
40215: NEG
40216: PUSH
40217: LD_INT 2
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 2
40227: NEG
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 4
40238: NEG
40239: PUSH
40240: LD_INT 4
40242: NEG
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 4
40250: NEG
40251: PUSH
40252: LD_INT 5
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 3
40262: NEG
40263: PUSH
40264: LD_INT 4
40266: NEG
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 3
40274: NEG
40275: PUSH
40276: LD_INT 3
40278: NEG
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 4
40286: NEG
40287: PUSH
40288: LD_INT 3
40290: NEG
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 5
40298: NEG
40299: PUSH
40300: LD_INT 4
40302: NEG
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 5
40310: NEG
40311: PUSH
40312: LD_INT 5
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 3
40322: NEG
40323: PUSH
40324: LD_INT 5
40326: NEG
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 5
40334: NEG
40335: PUSH
40336: LD_INT 3
40338: NEG
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: LIST
40348: LIST
40349: LIST
40350: LIST
40351: LIST
40352: LIST
40353: LIST
40354: LIST
40355: LIST
40356: LIST
40357: LIST
40358: LIST
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: LIST
40375: LIST
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: LIST
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40391: LD_ADDR_VAR 0 30
40395: PUSH
40396: LD_INT 4
40398: PUSH
40399: LD_INT 4
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 4
40408: PUSH
40409: LD_INT 3
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: LD_INT 5
40418: PUSH
40419: LD_INT 4
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 5
40428: PUSH
40429: LD_INT 5
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 4
40438: PUSH
40439: LD_INT 5
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 3
40448: PUSH
40449: LD_INT 4
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 3
40458: PUSH
40459: LD_INT 3
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 5
40468: PUSH
40469: LD_INT 3
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 3
40478: PUSH
40479: LD_INT 5
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 0
40488: PUSH
40489: LD_INT 3
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: PUSH
40496: LD_INT 0
40498: PUSH
40499: LD_INT 2
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 1
40508: PUSH
40509: LD_INT 3
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: LD_INT 4
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 0
40528: PUSH
40529: LD_INT 4
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 1
40538: NEG
40539: PUSH
40540: LD_INT 3
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 1
40549: NEG
40550: PUSH
40551: LD_INT 2
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 2
40560: PUSH
40561: LD_INT 4
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 2
40570: NEG
40571: PUSH
40572: LD_INT 2
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 4
40581: NEG
40582: PUSH
40583: LD_INT 0
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 4
40592: NEG
40593: PUSH
40594: LD_INT 1
40596: NEG
40597: PUSH
40598: EMPTY
40599: LIST
40600: LIST
40601: PUSH
40602: LD_INT 3
40604: NEG
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 3
40615: NEG
40616: PUSH
40617: LD_INT 1
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 4
40626: NEG
40627: PUSH
40628: LD_INT 1
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 5
40637: NEG
40638: PUSH
40639: LD_INT 0
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 5
40648: NEG
40649: PUSH
40650: LD_INT 1
40652: NEG
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 5
40660: NEG
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: PUSH
40670: LD_INT 3
40672: NEG
40673: PUSH
40674: LD_INT 2
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 3
40683: NEG
40684: PUSH
40685: LD_INT 3
40687: NEG
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 3
40695: NEG
40696: PUSH
40697: LD_INT 4
40699: NEG
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 2
40707: NEG
40708: PUSH
40709: LD_INT 3
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 2
40719: NEG
40720: PUSH
40721: LD_INT 2
40723: NEG
40724: PUSH
40725: EMPTY
40726: LIST
40727: LIST
40728: PUSH
40729: LD_INT 3
40731: NEG
40732: PUSH
40733: LD_INT 2
40735: NEG
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 4
40743: NEG
40744: PUSH
40745: LD_INT 3
40747: NEG
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 4
40755: NEG
40756: PUSH
40757: LD_INT 4
40759: NEG
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 2
40767: NEG
40768: PUSH
40769: LD_INT 4
40771: NEG
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 4
40779: NEG
40780: PUSH
40781: LD_INT 2
40783: NEG
40784: PUSH
40785: EMPTY
40786: LIST
40787: LIST
40788: PUSH
40789: LD_INT 0
40791: PUSH
40792: LD_INT 4
40794: NEG
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 0
40802: PUSH
40803: LD_INT 5
40805: NEG
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PUSH
40811: LD_INT 1
40813: PUSH
40814: LD_INT 4
40816: NEG
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 1
40824: PUSH
40825: LD_INT 3
40827: NEG
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 0
40835: PUSH
40836: LD_INT 3
40838: NEG
40839: PUSH
40840: EMPTY
40841: LIST
40842: LIST
40843: PUSH
40844: LD_INT 1
40846: NEG
40847: PUSH
40848: LD_INT 4
40850: NEG
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 1
40858: NEG
40859: PUSH
40860: LD_INT 5
40862: NEG
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 2
40870: PUSH
40871: LD_INT 3
40873: NEG
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 2
40881: NEG
40882: PUSH
40883: LD_INT 5
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: LIST
40895: LIST
40896: LIST
40897: LIST
40898: LIST
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: LIST
40914: LIST
40915: LIST
40916: LIST
40917: LIST
40918: LIST
40919: LIST
40920: LIST
40921: LIST
40922: LIST
40923: LIST
40924: LIST
40925: LIST
40926: LIST
40927: LIST
40928: LIST
40929: LIST
40930: LIST
40931: LIST
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: LIST
40937: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40938: LD_ADDR_VAR 0 31
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: LD_INT 4
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 0
40955: PUSH
40956: LD_INT 3
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: LD_INT 1
40965: PUSH
40966: LD_INT 4
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: PUSH
40973: LD_INT 1
40975: PUSH
40976: LD_INT 5
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: LD_INT 0
40985: PUSH
40986: LD_INT 5
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: LD_INT 1
40995: NEG
40996: PUSH
40997: LD_INT 4
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: PUSH
41004: LD_INT 1
41006: NEG
41007: PUSH
41008: LD_INT 3
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: LD_INT 2
41017: PUSH
41018: LD_INT 5
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 2
41027: NEG
41028: PUSH
41029: LD_INT 3
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 3
41038: NEG
41039: PUSH
41040: LD_INT 0
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 3
41049: NEG
41050: PUSH
41051: LD_INT 1
41053: NEG
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 2
41061: NEG
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: LD_INT 2
41072: NEG
41073: PUSH
41074: LD_INT 1
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: PUSH
41081: LD_INT 3
41083: NEG
41084: PUSH
41085: LD_INT 1
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 4
41094: NEG
41095: PUSH
41096: LD_INT 0
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 4
41105: NEG
41106: PUSH
41107: LD_INT 1
41109: NEG
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 4
41117: NEG
41118: PUSH
41119: LD_INT 2
41121: NEG
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: LD_INT 2
41129: NEG
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 4
41140: NEG
41141: PUSH
41142: LD_INT 4
41144: NEG
41145: PUSH
41146: EMPTY
41147: LIST
41148: LIST
41149: PUSH
41150: LD_INT 4
41152: NEG
41153: PUSH
41154: LD_INT 5
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 3
41164: NEG
41165: PUSH
41166: LD_INT 4
41168: NEG
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 3
41176: NEG
41177: PUSH
41178: LD_INT 3
41180: NEG
41181: PUSH
41182: EMPTY
41183: LIST
41184: LIST
41185: PUSH
41186: LD_INT 4
41188: NEG
41189: PUSH
41190: LD_INT 3
41192: NEG
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 5
41200: NEG
41201: PUSH
41202: LD_INT 4
41204: NEG
41205: PUSH
41206: EMPTY
41207: LIST
41208: LIST
41209: PUSH
41210: LD_INT 5
41212: NEG
41213: PUSH
41214: LD_INT 5
41216: NEG
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: LD_INT 3
41224: NEG
41225: PUSH
41226: LD_INT 5
41228: NEG
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 5
41236: NEG
41237: PUSH
41238: LD_INT 3
41240: NEG
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: PUSH
41246: LD_INT 0
41248: PUSH
41249: LD_INT 3
41251: NEG
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 0
41259: PUSH
41260: LD_INT 4
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 1
41270: PUSH
41271: LD_INT 3
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 1
41281: PUSH
41282: LD_INT 2
41284: NEG
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 0
41292: PUSH
41293: LD_INT 2
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 1
41303: NEG
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 1
41315: NEG
41316: PUSH
41317: LD_INT 4
41319: NEG
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 2
41327: PUSH
41328: LD_INT 2
41330: NEG
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 2
41338: NEG
41339: PUSH
41340: LD_INT 4
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 4
41360: PUSH
41361: LD_INT 1
41363: NEG
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 5
41371: PUSH
41372: LD_INT 0
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 5
41381: PUSH
41382: LD_INT 1
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 4
41391: PUSH
41392: LD_INT 1
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 3
41401: PUSH
41402: LD_INT 0
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 3
41411: PUSH
41412: LD_INT 1
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 3
41422: PUSH
41423: LD_INT 2
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 5
41433: PUSH
41434: LD_INT 2
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: LIST
41465: LIST
41466: LIST
41467: LIST
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: LIST
41474: LIST
41475: LIST
41476: LIST
41477: LIST
41478: LIST
41479: LIST
41480: LIST
41481: LIST
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: LIST
41487: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41488: LD_ADDR_VAR 0 32
41492: PUSH
41493: LD_INT 4
41495: NEG
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 4
41506: NEG
41507: PUSH
41508: LD_INT 1
41510: NEG
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: PUSH
41516: LD_INT 3
41518: NEG
41519: PUSH
41520: LD_INT 0
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 3
41529: NEG
41530: PUSH
41531: LD_INT 1
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 4
41540: NEG
41541: PUSH
41542: LD_INT 1
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 5
41551: NEG
41552: PUSH
41553: LD_INT 0
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 5
41562: NEG
41563: PUSH
41564: LD_INT 1
41566: NEG
41567: PUSH
41568: EMPTY
41569: LIST
41570: LIST
41571: PUSH
41572: LD_INT 5
41574: NEG
41575: PUSH
41576: LD_INT 2
41578: NEG
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 3
41586: NEG
41587: PUSH
41588: LD_INT 2
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 3
41597: NEG
41598: PUSH
41599: LD_INT 3
41601: NEG
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: LD_INT 3
41609: NEG
41610: PUSH
41611: LD_INT 4
41613: NEG
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 2
41621: NEG
41622: PUSH
41623: LD_INT 3
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 2
41633: NEG
41634: PUSH
41635: LD_INT 2
41637: NEG
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: LD_INT 3
41645: NEG
41646: PUSH
41647: LD_INT 2
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 4
41657: NEG
41658: PUSH
41659: LD_INT 3
41661: NEG
41662: PUSH
41663: EMPTY
41664: LIST
41665: LIST
41666: PUSH
41667: LD_INT 4
41669: NEG
41670: PUSH
41671: LD_INT 4
41673: NEG
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: PUSH
41679: LD_INT 2
41681: NEG
41682: PUSH
41683: LD_INT 4
41685: NEG
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: PUSH
41691: LD_INT 4
41693: NEG
41694: PUSH
41695: LD_INT 2
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 0
41705: PUSH
41706: LD_INT 4
41708: NEG
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 0
41716: PUSH
41717: LD_INT 5
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: PUSH
41728: LD_INT 4
41730: NEG
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 1
41738: PUSH
41739: LD_INT 3
41741: NEG
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 0
41749: PUSH
41750: LD_INT 3
41752: NEG
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 1
41760: NEG
41761: PUSH
41762: LD_INT 4
41764: NEG
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 1
41772: NEG
41773: PUSH
41774: LD_INT 5
41776: NEG
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 2
41784: PUSH
41785: LD_INT 3
41787: NEG
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 2
41795: NEG
41796: PUSH
41797: LD_INT 5
41799: NEG
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 3
41807: PUSH
41808: LD_INT 0
41810: PUSH
41811: EMPTY
41812: LIST
41813: LIST
41814: PUSH
41815: LD_INT 3
41817: PUSH
41818: LD_INT 1
41820: NEG
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 4
41828: PUSH
41829: LD_INT 0
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: LD_INT 4
41838: PUSH
41839: LD_INT 1
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 3
41848: PUSH
41849: LD_INT 1
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: PUSH
41856: LD_INT 2
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 2
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: EMPTY
41874: LIST
41875: LIST
41876: PUSH
41877: LD_INT 2
41879: PUSH
41880: LD_INT 2
41882: NEG
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 4
41890: PUSH
41891: LD_INT 2
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: LD_INT 4
41900: PUSH
41901: LD_INT 4
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: LD_INT 3
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 5
41920: PUSH
41921: LD_INT 4
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 5
41930: PUSH
41931: LD_INT 5
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 4
41940: PUSH
41941: LD_INT 5
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 3
41950: PUSH
41951: LD_INT 4
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 3
41960: PUSH
41961: LD_INT 3
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 5
41970: PUSH
41971: LD_INT 3
41973: PUSH
41974: EMPTY
41975: LIST
41976: LIST
41977: PUSH
41978: LD_INT 3
41980: PUSH
41981: LD_INT 5
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: LIST
41992: LIST
41993: LIST
41994: LIST
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: LIST
42003: LIST
42004: LIST
42005: LIST
42006: LIST
42007: LIST
42008: LIST
42009: LIST
42010: LIST
42011: LIST
42012: LIST
42013: LIST
42014: LIST
42015: LIST
42016: LIST
42017: LIST
42018: LIST
42019: LIST
42020: LIST
42021: LIST
42022: LIST
42023: LIST
42024: LIST
42025: LIST
42026: LIST
42027: LIST
42028: LIST
42029: LIST
42030: LIST
42031: LIST
42032: LIST
42033: LIST
42034: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
42035: LD_ADDR_VAR 0 33
42039: PUSH
42040: LD_INT 4
42042: NEG
42043: PUSH
42044: LD_INT 4
42046: NEG
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: PUSH
42052: LD_INT 4
42054: NEG
42055: PUSH
42056: LD_INT 5
42058: NEG
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 3
42066: NEG
42067: PUSH
42068: LD_INT 4
42070: NEG
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 3
42078: NEG
42079: PUSH
42080: LD_INT 3
42082: NEG
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 4
42090: NEG
42091: PUSH
42092: LD_INT 3
42094: NEG
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 5
42102: NEG
42103: PUSH
42104: LD_INT 4
42106: NEG
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: PUSH
42112: LD_INT 5
42114: NEG
42115: PUSH
42116: LD_INT 5
42118: NEG
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: PUSH
42124: LD_INT 3
42126: NEG
42127: PUSH
42128: LD_INT 5
42130: NEG
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 5
42138: NEG
42139: PUSH
42140: LD_INT 3
42142: NEG
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 0
42150: PUSH
42151: LD_INT 3
42153: NEG
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 0
42161: PUSH
42162: LD_INT 4
42164: NEG
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 1
42172: PUSH
42173: LD_INT 3
42175: NEG
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 1
42183: PUSH
42184: LD_INT 2
42186: NEG
42187: PUSH
42188: EMPTY
42189: LIST
42190: LIST
42191: PUSH
42192: LD_INT 0
42194: PUSH
42195: LD_INT 2
42197: NEG
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 1
42205: NEG
42206: PUSH
42207: LD_INT 3
42209: NEG
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_INT 1
42217: NEG
42218: PUSH
42219: LD_INT 4
42221: NEG
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 2
42229: PUSH
42230: LD_INT 2
42232: NEG
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: LD_INT 2
42240: NEG
42241: PUSH
42242: LD_INT 4
42244: NEG
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: PUSH
42250: LD_INT 4
42252: PUSH
42253: LD_INT 0
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: LD_INT 4
42262: PUSH
42263: LD_INT 1
42265: NEG
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 5
42273: PUSH
42274: LD_INT 0
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 5
42283: PUSH
42284: LD_INT 1
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 4
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 3
42303: PUSH
42304: LD_INT 0
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: LD_INT 3
42313: PUSH
42314: LD_INT 1
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 3
42324: PUSH
42325: LD_INT 2
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 5
42335: PUSH
42336: LD_INT 2
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 3
42345: PUSH
42346: LD_INT 3
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 3
42355: PUSH
42356: LD_INT 2
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 4
42365: PUSH
42366: LD_INT 3
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 4
42375: PUSH
42376: LD_INT 4
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PUSH
42383: LD_INT 3
42385: PUSH
42386: LD_INT 4
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 2
42395: PUSH
42396: LD_INT 3
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 2
42405: PUSH
42406: LD_INT 2
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 4
42415: PUSH
42416: LD_INT 2
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 2
42425: PUSH
42426: LD_INT 4
42428: PUSH
42429: EMPTY
42430: LIST
42431: LIST
42432: PUSH
42433: LD_INT 0
42435: PUSH
42436: LD_INT 4
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: LD_INT 0
42445: PUSH
42446: LD_INT 3
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 1
42455: PUSH
42456: LD_INT 4
42458: PUSH
42459: EMPTY
42460: LIST
42461: LIST
42462: PUSH
42463: LD_INT 1
42465: PUSH
42466: LD_INT 5
42468: PUSH
42469: EMPTY
42470: LIST
42471: LIST
42472: PUSH
42473: LD_INT 0
42475: PUSH
42476: LD_INT 5
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 1
42485: NEG
42486: PUSH
42487: LD_INT 4
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 1
42496: NEG
42497: PUSH
42498: LD_INT 3
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 2
42507: PUSH
42508: LD_INT 5
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 2
42517: NEG
42518: PUSH
42519: LD_INT 3
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: LIST
42530: LIST
42531: LIST
42532: LIST
42533: LIST
42534: LIST
42535: LIST
42536: LIST
42537: LIST
42538: LIST
42539: LIST
42540: LIST
42541: LIST
42542: LIST
42543: LIST
42544: LIST
42545: LIST
42546: LIST
42547: LIST
42548: LIST
42549: LIST
42550: LIST
42551: LIST
42552: LIST
42553: LIST
42554: LIST
42555: LIST
42556: LIST
42557: LIST
42558: LIST
42559: LIST
42560: LIST
42561: LIST
42562: LIST
42563: LIST
42564: LIST
42565: LIST
42566: LIST
42567: LIST
42568: LIST
42569: LIST
42570: LIST
42571: LIST
42572: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42573: LD_ADDR_VAR 0 34
42577: PUSH
42578: LD_INT 0
42580: PUSH
42581: LD_INT 4
42583: NEG
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: LD_INT 0
42591: PUSH
42592: LD_INT 5
42594: NEG
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: PUSH
42600: LD_INT 1
42602: PUSH
42603: LD_INT 4
42605: NEG
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 1
42613: PUSH
42614: LD_INT 3
42616: NEG
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 0
42624: PUSH
42625: LD_INT 3
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 1
42635: NEG
42636: PUSH
42637: LD_INT 4
42639: NEG
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 1
42647: NEG
42648: PUSH
42649: LD_INT 5
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: LD_INT 2
42659: PUSH
42660: LD_INT 3
42662: NEG
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 2
42670: NEG
42671: PUSH
42672: LD_INT 5
42674: NEG
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 3
42682: PUSH
42683: LD_INT 0
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 3
42692: PUSH
42693: LD_INT 1
42695: NEG
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 4
42703: PUSH
42704: LD_INT 0
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: LD_INT 4
42713: PUSH
42714: LD_INT 1
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: LD_INT 3
42723: PUSH
42724: LD_INT 1
42726: PUSH
42727: EMPTY
42728: LIST
42729: LIST
42730: PUSH
42731: LD_INT 2
42733: PUSH
42734: LD_INT 0
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: PUSH
42744: LD_INT 1
42746: NEG
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 2
42754: PUSH
42755: LD_INT 2
42757: NEG
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 4
42765: PUSH
42766: LD_INT 2
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 4
42775: PUSH
42776: LD_INT 4
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 4
42785: PUSH
42786: LD_INT 3
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 5
42795: PUSH
42796: LD_INT 4
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 5
42805: PUSH
42806: LD_INT 5
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 4
42815: PUSH
42816: LD_INT 5
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: LD_INT 3
42825: PUSH
42826: LD_INT 4
42828: PUSH
42829: EMPTY
42830: LIST
42831: LIST
42832: PUSH
42833: LD_INT 3
42835: PUSH
42836: LD_INT 3
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: LD_INT 5
42845: PUSH
42846: LD_INT 3
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: PUSH
42853: LD_INT 3
42855: PUSH
42856: LD_INT 5
42858: PUSH
42859: EMPTY
42860: LIST
42861: LIST
42862: PUSH
42863: LD_INT 0
42865: PUSH
42866: LD_INT 3
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 0
42875: PUSH
42876: LD_INT 2
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: PUSH
42883: LD_INT 1
42885: PUSH
42886: LD_INT 3
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 1
42895: PUSH
42896: LD_INT 4
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: PUSH
42903: LD_INT 0
42905: PUSH
42906: LD_INT 4
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: PUSH
42913: LD_INT 1
42915: NEG
42916: PUSH
42917: LD_INT 3
42919: PUSH
42920: EMPTY
42921: LIST
42922: LIST
42923: PUSH
42924: LD_INT 1
42926: NEG
42927: PUSH
42928: LD_INT 2
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 2
42937: PUSH
42938: LD_INT 4
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 2
42947: NEG
42948: PUSH
42949: LD_INT 2
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 4
42958: NEG
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 4
42969: NEG
42970: PUSH
42971: LD_INT 1
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 3
42981: NEG
42982: PUSH
42983: LD_INT 0
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 3
42992: NEG
42993: PUSH
42994: LD_INT 1
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 4
43003: NEG
43004: PUSH
43005: LD_INT 1
43007: PUSH
43008: EMPTY
43009: LIST
43010: LIST
43011: PUSH
43012: LD_INT 5
43014: NEG
43015: PUSH
43016: LD_INT 0
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: PUSH
43023: LD_INT 5
43025: NEG
43026: PUSH
43027: LD_INT 1
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 5
43037: NEG
43038: PUSH
43039: LD_INT 2
43041: NEG
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 3
43049: NEG
43050: PUSH
43051: LD_INT 2
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: LIST
43064: LIST
43065: LIST
43066: LIST
43067: LIST
43068: LIST
43069: LIST
43070: LIST
43071: LIST
43072: LIST
43073: LIST
43074: LIST
43075: LIST
43076: LIST
43077: LIST
43078: LIST
43079: LIST
43080: LIST
43081: LIST
43082: LIST
43083: LIST
43084: LIST
43085: LIST
43086: LIST
43087: LIST
43088: LIST
43089: LIST
43090: LIST
43091: LIST
43092: LIST
43093: LIST
43094: LIST
43095: LIST
43096: LIST
43097: LIST
43098: LIST
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: LIST
43104: ST_TO_ADDR
// end ; end ;
43105: GO 43108
43107: POP
// case btype of b_depot , b_warehouse :
43108: LD_VAR 0 1
43112: PUSH
43113: LD_INT 0
43115: DOUBLE
43116: EQUAL
43117: IFTRUE 43127
43119: LD_INT 1
43121: DOUBLE
43122: EQUAL
43123: IFTRUE 43127
43125: GO 43328
43127: POP
// case nation of nation_american :
43128: LD_VAR 0 5
43132: PUSH
43133: LD_INT 1
43135: DOUBLE
43136: EQUAL
43137: IFTRUE 43141
43139: GO 43197
43141: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
43142: LD_ADDR_VAR 0 9
43146: PUSH
43147: LD_VAR 0 11
43151: PUSH
43152: LD_VAR 0 12
43156: PUSH
43157: LD_VAR 0 13
43161: PUSH
43162: LD_VAR 0 14
43166: PUSH
43167: LD_VAR 0 15
43171: PUSH
43172: LD_VAR 0 16
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: LIST
43181: LIST
43182: LIST
43183: LIST
43184: PUSH
43185: LD_VAR 0 4
43189: PUSH
43190: LD_INT 1
43192: PLUS
43193: ARRAY
43194: ST_TO_ADDR
43195: GO 43326
43197: LD_INT 2
43199: DOUBLE
43200: EQUAL
43201: IFTRUE 43205
43203: GO 43261
43205: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
43206: LD_ADDR_VAR 0 9
43210: PUSH
43211: LD_VAR 0 17
43215: PUSH
43216: LD_VAR 0 18
43220: PUSH
43221: LD_VAR 0 19
43225: PUSH
43226: LD_VAR 0 20
43230: PUSH
43231: LD_VAR 0 21
43235: PUSH
43236: LD_VAR 0 22
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: LIST
43245: LIST
43246: LIST
43247: LIST
43248: PUSH
43249: LD_VAR 0 4
43253: PUSH
43254: LD_INT 1
43256: PLUS
43257: ARRAY
43258: ST_TO_ADDR
43259: GO 43326
43261: LD_INT 3
43263: DOUBLE
43264: EQUAL
43265: IFTRUE 43269
43267: GO 43325
43269: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
43270: LD_ADDR_VAR 0 9
43274: PUSH
43275: LD_VAR 0 23
43279: PUSH
43280: LD_VAR 0 24
43284: PUSH
43285: LD_VAR 0 25
43289: PUSH
43290: LD_VAR 0 26
43294: PUSH
43295: LD_VAR 0 27
43299: PUSH
43300: LD_VAR 0 28
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: LIST
43309: LIST
43310: LIST
43311: LIST
43312: PUSH
43313: LD_VAR 0 4
43317: PUSH
43318: LD_INT 1
43320: PLUS
43321: ARRAY
43322: ST_TO_ADDR
43323: GO 43326
43325: POP
43326: GO 43881
43328: LD_INT 2
43330: DOUBLE
43331: EQUAL
43332: IFTRUE 43342
43334: LD_INT 3
43336: DOUBLE
43337: EQUAL
43338: IFTRUE 43342
43340: GO 43398
43342: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43343: LD_ADDR_VAR 0 9
43347: PUSH
43348: LD_VAR 0 29
43352: PUSH
43353: LD_VAR 0 30
43357: PUSH
43358: LD_VAR 0 31
43362: PUSH
43363: LD_VAR 0 32
43367: PUSH
43368: LD_VAR 0 33
43372: PUSH
43373: LD_VAR 0 34
43377: PUSH
43378: EMPTY
43379: LIST
43380: LIST
43381: LIST
43382: LIST
43383: LIST
43384: LIST
43385: PUSH
43386: LD_VAR 0 4
43390: PUSH
43391: LD_INT 1
43393: PLUS
43394: ARRAY
43395: ST_TO_ADDR
43396: GO 43881
43398: LD_INT 16
43400: DOUBLE
43401: EQUAL
43402: IFTRUE 43460
43404: LD_INT 17
43406: DOUBLE
43407: EQUAL
43408: IFTRUE 43460
43410: LD_INT 18
43412: DOUBLE
43413: EQUAL
43414: IFTRUE 43460
43416: LD_INT 19
43418: DOUBLE
43419: EQUAL
43420: IFTRUE 43460
43422: LD_INT 22
43424: DOUBLE
43425: EQUAL
43426: IFTRUE 43460
43428: LD_INT 20
43430: DOUBLE
43431: EQUAL
43432: IFTRUE 43460
43434: LD_INT 21
43436: DOUBLE
43437: EQUAL
43438: IFTRUE 43460
43440: LD_INT 23
43442: DOUBLE
43443: EQUAL
43444: IFTRUE 43460
43446: LD_INT 24
43448: DOUBLE
43449: EQUAL
43450: IFTRUE 43460
43452: LD_INT 25
43454: DOUBLE
43455: EQUAL
43456: IFTRUE 43460
43458: GO 43516
43460: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43461: LD_ADDR_VAR 0 9
43465: PUSH
43466: LD_VAR 0 35
43470: PUSH
43471: LD_VAR 0 36
43475: PUSH
43476: LD_VAR 0 37
43480: PUSH
43481: LD_VAR 0 38
43485: PUSH
43486: LD_VAR 0 39
43490: PUSH
43491: LD_VAR 0 40
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: PUSH
43504: LD_VAR 0 4
43508: PUSH
43509: LD_INT 1
43511: PLUS
43512: ARRAY
43513: ST_TO_ADDR
43514: GO 43881
43516: LD_INT 6
43518: DOUBLE
43519: EQUAL
43520: IFTRUE 43572
43522: LD_INT 7
43524: DOUBLE
43525: EQUAL
43526: IFTRUE 43572
43528: LD_INT 8
43530: DOUBLE
43531: EQUAL
43532: IFTRUE 43572
43534: LD_INT 13
43536: DOUBLE
43537: EQUAL
43538: IFTRUE 43572
43540: LD_INT 12
43542: DOUBLE
43543: EQUAL
43544: IFTRUE 43572
43546: LD_INT 15
43548: DOUBLE
43549: EQUAL
43550: IFTRUE 43572
43552: LD_INT 11
43554: DOUBLE
43555: EQUAL
43556: IFTRUE 43572
43558: LD_INT 14
43560: DOUBLE
43561: EQUAL
43562: IFTRUE 43572
43564: LD_INT 10
43566: DOUBLE
43567: EQUAL
43568: IFTRUE 43572
43570: GO 43628
43572: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43573: LD_ADDR_VAR 0 9
43577: PUSH
43578: LD_VAR 0 41
43582: PUSH
43583: LD_VAR 0 42
43587: PUSH
43588: LD_VAR 0 43
43592: PUSH
43593: LD_VAR 0 44
43597: PUSH
43598: LD_VAR 0 45
43602: PUSH
43603: LD_VAR 0 46
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: LIST
43612: LIST
43613: LIST
43614: LIST
43615: PUSH
43616: LD_VAR 0 4
43620: PUSH
43621: LD_INT 1
43623: PLUS
43624: ARRAY
43625: ST_TO_ADDR
43626: GO 43881
43628: LD_INT 36
43630: DOUBLE
43631: EQUAL
43632: IFTRUE 43636
43634: GO 43692
43636: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43637: LD_ADDR_VAR 0 9
43641: PUSH
43642: LD_VAR 0 47
43646: PUSH
43647: LD_VAR 0 48
43651: PUSH
43652: LD_VAR 0 49
43656: PUSH
43657: LD_VAR 0 50
43661: PUSH
43662: LD_VAR 0 51
43666: PUSH
43667: LD_VAR 0 52
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: LIST
43676: LIST
43677: LIST
43678: LIST
43679: PUSH
43680: LD_VAR 0 4
43684: PUSH
43685: LD_INT 1
43687: PLUS
43688: ARRAY
43689: ST_TO_ADDR
43690: GO 43881
43692: LD_INT 4
43694: DOUBLE
43695: EQUAL
43696: IFTRUE 43718
43698: LD_INT 5
43700: DOUBLE
43701: EQUAL
43702: IFTRUE 43718
43704: LD_INT 34
43706: DOUBLE
43707: EQUAL
43708: IFTRUE 43718
43710: LD_INT 37
43712: DOUBLE
43713: EQUAL
43714: IFTRUE 43718
43716: GO 43774
43718: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43719: LD_ADDR_VAR 0 9
43723: PUSH
43724: LD_VAR 0 53
43728: PUSH
43729: LD_VAR 0 54
43733: PUSH
43734: LD_VAR 0 55
43738: PUSH
43739: LD_VAR 0 56
43743: PUSH
43744: LD_VAR 0 57
43748: PUSH
43749: LD_VAR 0 58
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: PUSH
43762: LD_VAR 0 4
43766: PUSH
43767: LD_INT 1
43769: PLUS
43770: ARRAY
43771: ST_TO_ADDR
43772: GO 43881
43774: LD_INT 31
43776: DOUBLE
43777: EQUAL
43778: IFTRUE 43824
43780: LD_INT 32
43782: DOUBLE
43783: EQUAL
43784: IFTRUE 43824
43786: LD_INT 33
43788: DOUBLE
43789: EQUAL
43790: IFTRUE 43824
43792: LD_INT 27
43794: DOUBLE
43795: EQUAL
43796: IFTRUE 43824
43798: LD_INT 26
43800: DOUBLE
43801: EQUAL
43802: IFTRUE 43824
43804: LD_INT 28
43806: DOUBLE
43807: EQUAL
43808: IFTRUE 43824
43810: LD_INT 29
43812: DOUBLE
43813: EQUAL
43814: IFTRUE 43824
43816: LD_INT 30
43818: DOUBLE
43819: EQUAL
43820: IFTRUE 43824
43822: GO 43880
43824: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43825: LD_ADDR_VAR 0 9
43829: PUSH
43830: LD_VAR 0 59
43834: PUSH
43835: LD_VAR 0 60
43839: PUSH
43840: LD_VAR 0 61
43844: PUSH
43845: LD_VAR 0 62
43849: PUSH
43850: LD_VAR 0 63
43854: PUSH
43855: LD_VAR 0 64
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: PUSH
43868: LD_VAR 0 4
43872: PUSH
43873: LD_INT 1
43875: PLUS
43876: ARRAY
43877: ST_TO_ADDR
43878: GO 43881
43880: POP
// temp_list2 = [ ] ;
43881: LD_ADDR_VAR 0 10
43885: PUSH
43886: EMPTY
43887: ST_TO_ADDR
// for i in temp_list do
43888: LD_ADDR_VAR 0 8
43892: PUSH
43893: LD_VAR 0 9
43897: PUSH
43898: FOR_IN
43899: IFFALSE 43951
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43901: LD_ADDR_VAR 0 10
43905: PUSH
43906: LD_VAR 0 10
43910: PUSH
43911: LD_VAR 0 8
43915: PUSH
43916: LD_INT 1
43918: ARRAY
43919: PUSH
43920: LD_VAR 0 2
43924: PLUS
43925: PUSH
43926: LD_VAR 0 8
43930: PUSH
43931: LD_INT 2
43933: ARRAY
43934: PUSH
43935: LD_VAR 0 3
43939: PLUS
43940: PUSH
43941: EMPTY
43942: LIST
43943: LIST
43944: PUSH
43945: EMPTY
43946: LIST
43947: ADD
43948: ST_TO_ADDR
43949: GO 43898
43951: POP
43952: POP
// result = temp_list2 ;
43953: LD_ADDR_VAR 0 7
43957: PUSH
43958: LD_VAR 0 10
43962: ST_TO_ADDR
// end ;
43963: LD_VAR 0 7
43967: RET
// export function EnemyInRange ( unit , dist ) ; begin
43968: LD_INT 0
43970: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43971: LD_ADDR_VAR 0 3
43975: PUSH
43976: LD_VAR 0 1
43980: PPUSH
43981: CALL_OW 255
43985: PPUSH
43986: LD_VAR 0 1
43990: PPUSH
43991: CALL_OW 250
43995: PPUSH
43996: LD_VAR 0 1
44000: PPUSH
44001: CALL_OW 251
44005: PPUSH
44006: LD_VAR 0 2
44010: PPUSH
44011: CALL 17341 0 4
44015: PUSH
44016: LD_INT 4
44018: ARRAY
44019: ST_TO_ADDR
// end ;
44020: LD_VAR 0 3
44024: RET
// export function PlayerSeeMe ( unit ) ; begin
44025: LD_INT 0
44027: PPUSH
// result := See ( your_side , unit ) ;
44028: LD_ADDR_VAR 0 2
44032: PUSH
44033: LD_OWVAR 2
44037: PPUSH
44038: LD_VAR 0 1
44042: PPUSH
44043: CALL_OW 292
44047: ST_TO_ADDR
// end ;
44048: LD_VAR 0 2
44052: RET
// export function ReverseDir ( unit ) ; begin
44053: LD_INT 0
44055: PPUSH
// if not unit then
44056: LD_VAR 0 1
44060: NOT
44061: IFFALSE 44065
// exit ;
44063: GO 44088
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
44065: LD_ADDR_VAR 0 2
44069: PUSH
44070: LD_VAR 0 1
44074: PPUSH
44075: CALL_OW 254
44079: PUSH
44080: LD_INT 3
44082: PLUS
44083: PUSH
44084: LD_INT 6
44086: MOD
44087: ST_TO_ADDR
// end ;
44088: LD_VAR 0 2
44092: RET
// export function ReverseArray ( array ) ; var i ; begin
44093: LD_INT 0
44095: PPUSH
44096: PPUSH
// if not array then
44097: LD_VAR 0 1
44101: NOT
44102: IFFALSE 44106
// exit ;
44104: GO 44161
// result := [ ] ;
44106: LD_ADDR_VAR 0 2
44110: PUSH
44111: EMPTY
44112: ST_TO_ADDR
// for i := array downto 1 do
44113: LD_ADDR_VAR 0 3
44117: PUSH
44118: DOUBLE
44119: LD_VAR 0 1
44123: INC
44124: ST_TO_ADDR
44125: LD_INT 1
44127: PUSH
44128: FOR_DOWNTO
44129: IFFALSE 44159
// result := Join ( result , array [ i ] ) ;
44131: LD_ADDR_VAR 0 2
44135: PUSH
44136: LD_VAR 0 2
44140: PPUSH
44141: LD_VAR 0 1
44145: PUSH
44146: LD_VAR 0 3
44150: ARRAY
44151: PPUSH
44152: CALL 48806 0 2
44156: ST_TO_ADDR
44157: GO 44128
44159: POP
44160: POP
// end ;
44161: LD_VAR 0 2
44165: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
44166: LD_INT 0
44168: PPUSH
44169: PPUSH
44170: PPUSH
44171: PPUSH
44172: PPUSH
44173: PPUSH
// if not unit or not hexes then
44174: LD_VAR 0 1
44178: NOT
44179: PUSH
44180: LD_VAR 0 2
44184: NOT
44185: OR
44186: IFFALSE 44190
// exit ;
44188: GO 44313
// dist := 9999 ;
44190: LD_ADDR_VAR 0 5
44194: PUSH
44195: LD_INT 9999
44197: ST_TO_ADDR
// for i = 1 to hexes do
44198: LD_ADDR_VAR 0 4
44202: PUSH
44203: DOUBLE
44204: LD_INT 1
44206: DEC
44207: ST_TO_ADDR
44208: LD_VAR 0 2
44212: PUSH
44213: FOR_TO
44214: IFFALSE 44301
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
44216: LD_ADDR_VAR 0 6
44220: PUSH
44221: LD_VAR 0 1
44225: PPUSH
44226: LD_VAR 0 2
44230: PUSH
44231: LD_VAR 0 4
44235: ARRAY
44236: PUSH
44237: LD_INT 1
44239: ARRAY
44240: PPUSH
44241: LD_VAR 0 2
44245: PUSH
44246: LD_VAR 0 4
44250: ARRAY
44251: PUSH
44252: LD_INT 2
44254: ARRAY
44255: PPUSH
44256: CALL_OW 297
44260: ST_TO_ADDR
// if tdist < dist then
44261: LD_VAR 0 6
44265: PUSH
44266: LD_VAR 0 5
44270: LESS
44271: IFFALSE 44299
// begin hex := hexes [ i ] ;
44273: LD_ADDR_VAR 0 8
44277: PUSH
44278: LD_VAR 0 2
44282: PUSH
44283: LD_VAR 0 4
44287: ARRAY
44288: ST_TO_ADDR
// dist := tdist ;
44289: LD_ADDR_VAR 0 5
44293: PUSH
44294: LD_VAR 0 6
44298: ST_TO_ADDR
// end ; end ;
44299: GO 44213
44301: POP
44302: POP
// result := hex ;
44303: LD_ADDR_VAR 0 3
44307: PUSH
44308: LD_VAR 0 8
44312: ST_TO_ADDR
// end ;
44313: LD_VAR 0 3
44317: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
44318: LD_INT 0
44320: PPUSH
44321: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
44322: LD_VAR 0 1
44326: NOT
44327: PUSH
44328: LD_VAR 0 1
44332: PUSH
44333: LD_INT 21
44335: PUSH
44336: LD_INT 2
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 23
44345: PUSH
44346: LD_INT 2
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PPUSH
44357: CALL_OW 69
44361: IN
44362: NOT
44363: OR
44364: IFFALSE 44368
// exit ;
44366: GO 44415
// for i = 1 to 3 do
44368: LD_ADDR_VAR 0 3
44372: PUSH
44373: DOUBLE
44374: LD_INT 1
44376: DEC
44377: ST_TO_ADDR
44378: LD_INT 3
44380: PUSH
44381: FOR_TO
44382: IFFALSE 44413
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44384: LD_VAR 0 1
44388: PPUSH
44389: CALL_OW 250
44393: PPUSH
44394: LD_VAR 0 1
44398: PPUSH
44399: CALL_OW 251
44403: PPUSH
44404: LD_INT 1
44406: PPUSH
44407: CALL_OW 453
44411: GO 44381
44413: POP
44414: POP
// end ;
44415: LD_VAR 0 2
44419: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44420: LD_INT 0
44422: PPUSH
44423: PPUSH
44424: PPUSH
44425: PPUSH
44426: PPUSH
44427: PPUSH
// if not unit or not enemy_unit then
44428: LD_VAR 0 1
44432: NOT
44433: PUSH
44434: LD_VAR 0 2
44438: NOT
44439: OR
44440: IFFALSE 44444
// exit ;
44442: GO 44911
// if GetLives ( i ) < 250 then
44444: LD_VAR 0 4
44448: PPUSH
44449: CALL_OW 256
44453: PUSH
44454: LD_INT 250
44456: LESS
44457: IFFALSE 44470
// begin ComAutodestruct ( i ) ;
44459: LD_VAR 0 4
44463: PPUSH
44464: CALL 44318 0 1
// exit ;
44468: GO 44911
// end ; x := GetX ( enemy_unit ) ;
44470: LD_ADDR_VAR 0 7
44474: PUSH
44475: LD_VAR 0 2
44479: PPUSH
44480: CALL_OW 250
44484: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44485: LD_ADDR_VAR 0 8
44489: PUSH
44490: LD_VAR 0 2
44494: PPUSH
44495: CALL_OW 251
44499: ST_TO_ADDR
// if not x or not y then
44500: LD_VAR 0 7
44504: NOT
44505: PUSH
44506: LD_VAR 0 8
44510: NOT
44511: OR
44512: IFFALSE 44516
// exit ;
44514: GO 44911
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44516: LD_ADDR_VAR 0 6
44520: PUSH
44521: LD_VAR 0 7
44525: PPUSH
44526: LD_INT 0
44528: PPUSH
44529: LD_INT 4
44531: PPUSH
44532: CALL_OW 272
44536: PUSH
44537: LD_VAR 0 8
44541: PPUSH
44542: LD_INT 0
44544: PPUSH
44545: LD_INT 4
44547: PPUSH
44548: CALL_OW 273
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: LD_VAR 0 7
44561: PPUSH
44562: LD_INT 1
44564: PPUSH
44565: LD_INT 4
44567: PPUSH
44568: CALL_OW 272
44572: PUSH
44573: LD_VAR 0 8
44577: PPUSH
44578: LD_INT 1
44580: PPUSH
44581: LD_INT 4
44583: PPUSH
44584: CALL_OW 273
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_VAR 0 7
44597: PPUSH
44598: LD_INT 2
44600: PPUSH
44601: LD_INT 4
44603: PPUSH
44604: CALL_OW 272
44608: PUSH
44609: LD_VAR 0 8
44613: PPUSH
44614: LD_INT 2
44616: PPUSH
44617: LD_INT 4
44619: PPUSH
44620: CALL_OW 273
44624: PUSH
44625: EMPTY
44626: LIST
44627: LIST
44628: PUSH
44629: LD_VAR 0 7
44633: PPUSH
44634: LD_INT 3
44636: PPUSH
44637: LD_INT 4
44639: PPUSH
44640: CALL_OW 272
44644: PUSH
44645: LD_VAR 0 8
44649: PPUSH
44650: LD_INT 3
44652: PPUSH
44653: LD_INT 4
44655: PPUSH
44656: CALL_OW 273
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_VAR 0 7
44669: PPUSH
44670: LD_INT 4
44672: PPUSH
44673: LD_INT 4
44675: PPUSH
44676: CALL_OW 272
44680: PUSH
44681: LD_VAR 0 8
44685: PPUSH
44686: LD_INT 4
44688: PPUSH
44689: LD_INT 4
44691: PPUSH
44692: CALL_OW 273
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: PUSH
44701: LD_VAR 0 7
44705: PPUSH
44706: LD_INT 5
44708: PPUSH
44709: LD_INT 4
44711: PPUSH
44712: CALL_OW 272
44716: PUSH
44717: LD_VAR 0 8
44721: PPUSH
44722: LD_INT 5
44724: PPUSH
44725: LD_INT 4
44727: PPUSH
44728: CALL_OW 273
44732: PUSH
44733: EMPTY
44734: LIST
44735: LIST
44736: PUSH
44737: EMPTY
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: ST_TO_ADDR
// for i = tmp downto 1 do
44745: LD_ADDR_VAR 0 4
44749: PUSH
44750: DOUBLE
44751: LD_VAR 0 6
44755: INC
44756: ST_TO_ADDR
44757: LD_INT 1
44759: PUSH
44760: FOR_DOWNTO
44761: IFFALSE 44862
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44763: LD_VAR 0 6
44767: PUSH
44768: LD_VAR 0 4
44772: ARRAY
44773: PUSH
44774: LD_INT 1
44776: ARRAY
44777: PPUSH
44778: LD_VAR 0 6
44782: PUSH
44783: LD_VAR 0 4
44787: ARRAY
44788: PUSH
44789: LD_INT 2
44791: ARRAY
44792: PPUSH
44793: CALL_OW 488
44797: NOT
44798: PUSH
44799: LD_VAR 0 6
44803: PUSH
44804: LD_VAR 0 4
44808: ARRAY
44809: PUSH
44810: LD_INT 1
44812: ARRAY
44813: PPUSH
44814: LD_VAR 0 6
44818: PUSH
44819: LD_VAR 0 4
44823: ARRAY
44824: PUSH
44825: LD_INT 2
44827: ARRAY
44828: PPUSH
44829: CALL_OW 428
44833: PUSH
44834: LD_INT 0
44836: NONEQUAL
44837: OR
44838: IFFALSE 44860
// tmp := Delete ( tmp , i ) ;
44840: LD_ADDR_VAR 0 6
44844: PUSH
44845: LD_VAR 0 6
44849: PPUSH
44850: LD_VAR 0 4
44854: PPUSH
44855: CALL_OW 3
44859: ST_TO_ADDR
44860: GO 44760
44862: POP
44863: POP
// j := GetClosestHex ( unit , tmp ) ;
44864: LD_ADDR_VAR 0 5
44868: PUSH
44869: LD_VAR 0 1
44873: PPUSH
44874: LD_VAR 0 6
44878: PPUSH
44879: CALL 44166 0 2
44883: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44884: LD_VAR 0 1
44888: PPUSH
44889: LD_VAR 0 5
44893: PUSH
44894: LD_INT 1
44896: ARRAY
44897: PPUSH
44898: LD_VAR 0 5
44902: PUSH
44903: LD_INT 2
44905: ARRAY
44906: PPUSH
44907: CALL_OW 111
// end ;
44911: LD_VAR 0 3
44915: RET
// export function PrepareApemanSoldier ( ) ; begin
44916: LD_INT 0
44918: PPUSH
// uc_nation := 0 ;
44919: LD_ADDR_OWVAR 21
44923: PUSH
44924: LD_INT 0
44926: ST_TO_ADDR
// hc_sex := sex_male ;
44927: LD_ADDR_OWVAR 27
44931: PUSH
44932: LD_INT 1
44934: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44935: LD_ADDR_OWVAR 28
44939: PUSH
44940: LD_INT 15
44942: ST_TO_ADDR
// hc_gallery :=  ;
44943: LD_ADDR_OWVAR 33
44947: PUSH
44948: LD_STRING 
44950: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44951: LD_ADDR_OWVAR 31
44955: PUSH
44956: LD_INT 0
44958: PPUSH
44959: LD_INT 3
44961: PPUSH
44962: CALL_OW 12
44966: PUSH
44967: LD_INT 0
44969: PPUSH
44970: LD_INT 3
44972: PPUSH
44973: CALL_OW 12
44977: PUSH
44978: LD_INT 0
44980: PUSH
44981: LD_INT 0
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: ST_TO_ADDR
// end ;
44990: LD_VAR 0 1
44994: RET
// export function PrepareApemanEngineer ( ) ; begin
44995: LD_INT 0
44997: PPUSH
// uc_nation := 0 ;
44998: LD_ADDR_OWVAR 21
45002: PUSH
45003: LD_INT 0
45005: ST_TO_ADDR
// hc_sex := sex_male ;
45006: LD_ADDR_OWVAR 27
45010: PUSH
45011: LD_INT 1
45013: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
45014: LD_ADDR_OWVAR 28
45018: PUSH
45019: LD_INT 16
45021: ST_TO_ADDR
// hc_gallery :=  ;
45022: LD_ADDR_OWVAR 33
45026: PUSH
45027: LD_STRING 
45029: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45030: LD_ADDR_OWVAR 31
45034: PUSH
45035: LD_INT 0
45037: PPUSH
45038: LD_INT 3
45040: PPUSH
45041: CALL_OW 12
45045: PUSH
45046: LD_INT 0
45048: PPUSH
45049: LD_INT 3
45051: PPUSH
45052: CALL_OW 12
45056: PUSH
45057: LD_INT 0
45059: PUSH
45060: LD_INT 0
45062: PUSH
45063: EMPTY
45064: LIST
45065: LIST
45066: LIST
45067: LIST
45068: ST_TO_ADDR
// end ;
45069: LD_VAR 0 1
45073: RET
// export function PrepareApeman ( agressivity ) ; begin
45074: LD_INT 0
45076: PPUSH
// uc_side := 0 ;
45077: LD_ADDR_OWVAR 20
45081: PUSH
45082: LD_INT 0
45084: ST_TO_ADDR
// uc_nation := 0 ;
45085: LD_ADDR_OWVAR 21
45089: PUSH
45090: LD_INT 0
45092: ST_TO_ADDR
// hc_sex := sex_male ;
45093: LD_ADDR_OWVAR 27
45097: PUSH
45098: LD_INT 1
45100: ST_TO_ADDR
// hc_class := class_apeman ;
45101: LD_ADDR_OWVAR 28
45105: PUSH
45106: LD_INT 12
45108: ST_TO_ADDR
// hc_gallery :=  ;
45109: LD_ADDR_OWVAR 33
45113: PUSH
45114: LD_STRING 
45116: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45117: LD_ADDR_OWVAR 35
45121: PUSH
45122: LD_VAR 0 1
45126: NEG
45127: PPUSH
45128: LD_VAR 0 1
45132: PPUSH
45133: CALL_OW 12
45137: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45138: LD_ADDR_OWVAR 31
45142: PUSH
45143: LD_INT 0
45145: PPUSH
45146: LD_INT 3
45148: PPUSH
45149: CALL_OW 12
45153: PUSH
45154: LD_INT 0
45156: PPUSH
45157: LD_INT 3
45159: PPUSH
45160: CALL_OW 12
45164: PUSH
45165: LD_INT 0
45167: PUSH
45168: LD_INT 0
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: LIST
45175: LIST
45176: ST_TO_ADDR
// end ;
45177: LD_VAR 0 2
45181: RET
// export function PrepareTiger ( agressivity ) ; begin
45182: LD_INT 0
45184: PPUSH
// uc_side := 0 ;
45185: LD_ADDR_OWVAR 20
45189: PUSH
45190: LD_INT 0
45192: ST_TO_ADDR
// uc_nation := 0 ;
45193: LD_ADDR_OWVAR 21
45197: PUSH
45198: LD_INT 0
45200: ST_TO_ADDR
// hc_class := class_tiger ;
45201: LD_ADDR_OWVAR 28
45205: PUSH
45206: LD_INT 14
45208: ST_TO_ADDR
// hc_gallery :=  ;
45209: LD_ADDR_OWVAR 33
45213: PUSH
45214: LD_STRING 
45216: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45217: LD_ADDR_OWVAR 35
45221: PUSH
45222: LD_VAR 0 1
45226: NEG
45227: PPUSH
45228: LD_VAR 0 1
45232: PPUSH
45233: CALL_OW 12
45237: ST_TO_ADDR
// end ;
45238: LD_VAR 0 2
45242: RET
// export function PrepareEnchidna ( ) ; begin
45243: LD_INT 0
45245: PPUSH
// uc_side := 0 ;
45246: LD_ADDR_OWVAR 20
45250: PUSH
45251: LD_INT 0
45253: ST_TO_ADDR
// uc_nation := 0 ;
45254: LD_ADDR_OWVAR 21
45258: PUSH
45259: LD_INT 0
45261: ST_TO_ADDR
// hc_class := class_baggie ;
45262: LD_ADDR_OWVAR 28
45266: PUSH
45267: LD_INT 13
45269: ST_TO_ADDR
// hc_gallery :=  ;
45270: LD_ADDR_OWVAR 33
45274: PUSH
45275: LD_STRING 
45277: ST_TO_ADDR
// end ;
45278: LD_VAR 0 1
45282: RET
// export function PrepareFrog ( ) ; begin
45283: LD_INT 0
45285: PPUSH
// uc_side := 0 ;
45286: LD_ADDR_OWVAR 20
45290: PUSH
45291: LD_INT 0
45293: ST_TO_ADDR
// uc_nation := 0 ;
45294: LD_ADDR_OWVAR 21
45298: PUSH
45299: LD_INT 0
45301: ST_TO_ADDR
// hc_class := class_frog ;
45302: LD_ADDR_OWVAR 28
45306: PUSH
45307: LD_INT 19
45309: ST_TO_ADDR
// hc_gallery :=  ;
45310: LD_ADDR_OWVAR 33
45314: PUSH
45315: LD_STRING 
45317: ST_TO_ADDR
// end ;
45318: LD_VAR 0 1
45322: RET
// export function PrepareFish ( ) ; begin
45323: LD_INT 0
45325: PPUSH
// uc_side := 0 ;
45326: LD_ADDR_OWVAR 20
45330: PUSH
45331: LD_INT 0
45333: ST_TO_ADDR
// uc_nation := 0 ;
45334: LD_ADDR_OWVAR 21
45338: PUSH
45339: LD_INT 0
45341: ST_TO_ADDR
// hc_class := class_fish ;
45342: LD_ADDR_OWVAR 28
45346: PUSH
45347: LD_INT 20
45349: ST_TO_ADDR
// hc_gallery :=  ;
45350: LD_ADDR_OWVAR 33
45354: PUSH
45355: LD_STRING 
45357: ST_TO_ADDR
// end ;
45358: LD_VAR 0 1
45362: RET
// export function PrepareBird ( ) ; begin
45363: LD_INT 0
45365: PPUSH
// uc_side := 0 ;
45366: LD_ADDR_OWVAR 20
45370: PUSH
45371: LD_INT 0
45373: ST_TO_ADDR
// uc_nation := 0 ;
45374: LD_ADDR_OWVAR 21
45378: PUSH
45379: LD_INT 0
45381: ST_TO_ADDR
// hc_class := class_phororhacos ;
45382: LD_ADDR_OWVAR 28
45386: PUSH
45387: LD_INT 18
45389: ST_TO_ADDR
// hc_gallery :=  ;
45390: LD_ADDR_OWVAR 33
45394: PUSH
45395: LD_STRING 
45397: ST_TO_ADDR
// end ;
45398: LD_VAR 0 1
45402: RET
// export function PrepareHorse ( ) ; begin
45403: LD_INT 0
45405: PPUSH
// uc_side := 0 ;
45406: LD_ADDR_OWVAR 20
45410: PUSH
45411: LD_INT 0
45413: ST_TO_ADDR
// uc_nation := 0 ;
45414: LD_ADDR_OWVAR 21
45418: PUSH
45419: LD_INT 0
45421: ST_TO_ADDR
// hc_class := class_horse ;
45422: LD_ADDR_OWVAR 28
45426: PUSH
45427: LD_INT 21
45429: ST_TO_ADDR
// hc_gallery :=  ;
45430: LD_ADDR_OWVAR 33
45434: PUSH
45435: LD_STRING 
45437: ST_TO_ADDR
// end ;
45438: LD_VAR 0 1
45442: RET
// export function PrepareMastodont ( ) ; begin
45443: LD_INT 0
45445: PPUSH
// uc_side := 0 ;
45446: LD_ADDR_OWVAR 20
45450: PUSH
45451: LD_INT 0
45453: ST_TO_ADDR
// uc_nation := 0 ;
45454: LD_ADDR_OWVAR 21
45458: PUSH
45459: LD_INT 0
45461: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45462: LD_ADDR_OWVAR 37
45466: PUSH
45467: LD_INT 31
45469: ST_TO_ADDR
// vc_control := control_rider ;
45470: LD_ADDR_OWVAR 38
45474: PUSH
45475: LD_INT 4
45477: ST_TO_ADDR
// end ;
45478: LD_VAR 0 1
45482: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45483: LD_INT 0
45485: PPUSH
45486: PPUSH
45487: PPUSH
// uc_side = 0 ;
45488: LD_ADDR_OWVAR 20
45492: PUSH
45493: LD_INT 0
45495: ST_TO_ADDR
// uc_nation = 0 ;
45496: LD_ADDR_OWVAR 21
45500: PUSH
45501: LD_INT 0
45503: ST_TO_ADDR
// InitHc_All ( ) ;
45504: CALL_OW 584
// InitVc ;
45508: CALL_OW 20
// if mastodonts then
45512: LD_VAR 0 6
45516: IFFALSE 45583
// for i = 1 to mastodonts do
45518: LD_ADDR_VAR 0 11
45522: PUSH
45523: DOUBLE
45524: LD_INT 1
45526: DEC
45527: ST_TO_ADDR
45528: LD_VAR 0 6
45532: PUSH
45533: FOR_TO
45534: IFFALSE 45581
// begin vc_chassis := 31 ;
45536: LD_ADDR_OWVAR 37
45540: PUSH
45541: LD_INT 31
45543: ST_TO_ADDR
// vc_control := control_rider ;
45544: LD_ADDR_OWVAR 38
45548: PUSH
45549: LD_INT 4
45551: ST_TO_ADDR
// animal := CreateVehicle ;
45552: LD_ADDR_VAR 0 12
45556: PUSH
45557: CALL_OW 45
45561: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45562: LD_VAR 0 12
45566: PPUSH
45567: LD_VAR 0 8
45571: PPUSH
45572: LD_INT 0
45574: PPUSH
45575: CALL 47711 0 3
// end ;
45579: GO 45533
45581: POP
45582: POP
// if horses then
45583: LD_VAR 0 5
45587: IFFALSE 45654
// for i = 1 to horses do
45589: LD_ADDR_VAR 0 11
45593: PUSH
45594: DOUBLE
45595: LD_INT 1
45597: DEC
45598: ST_TO_ADDR
45599: LD_VAR 0 5
45603: PUSH
45604: FOR_TO
45605: IFFALSE 45652
// begin hc_class := 21 ;
45607: LD_ADDR_OWVAR 28
45611: PUSH
45612: LD_INT 21
45614: ST_TO_ADDR
// hc_gallery :=  ;
45615: LD_ADDR_OWVAR 33
45619: PUSH
45620: LD_STRING 
45622: ST_TO_ADDR
// animal := CreateHuman ;
45623: LD_ADDR_VAR 0 12
45627: PUSH
45628: CALL_OW 44
45632: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45633: LD_VAR 0 12
45637: PPUSH
45638: LD_VAR 0 8
45642: PPUSH
45643: LD_INT 0
45645: PPUSH
45646: CALL 47711 0 3
// end ;
45650: GO 45604
45652: POP
45653: POP
// if birds then
45654: LD_VAR 0 1
45658: IFFALSE 45725
// for i = 1 to birds do
45660: LD_ADDR_VAR 0 11
45664: PUSH
45665: DOUBLE
45666: LD_INT 1
45668: DEC
45669: ST_TO_ADDR
45670: LD_VAR 0 1
45674: PUSH
45675: FOR_TO
45676: IFFALSE 45723
// begin hc_class := 18 ;
45678: LD_ADDR_OWVAR 28
45682: PUSH
45683: LD_INT 18
45685: ST_TO_ADDR
// hc_gallery =  ;
45686: LD_ADDR_OWVAR 33
45690: PUSH
45691: LD_STRING 
45693: ST_TO_ADDR
// animal := CreateHuman ;
45694: LD_ADDR_VAR 0 12
45698: PUSH
45699: CALL_OW 44
45703: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45704: LD_VAR 0 12
45708: PPUSH
45709: LD_VAR 0 8
45713: PPUSH
45714: LD_INT 0
45716: PPUSH
45717: CALL 47711 0 3
// end ;
45721: GO 45675
45723: POP
45724: POP
// if tigers then
45725: LD_VAR 0 2
45729: IFFALSE 45813
// for i = 1 to tigers do
45731: LD_ADDR_VAR 0 11
45735: PUSH
45736: DOUBLE
45737: LD_INT 1
45739: DEC
45740: ST_TO_ADDR
45741: LD_VAR 0 2
45745: PUSH
45746: FOR_TO
45747: IFFALSE 45811
// begin hc_class = class_tiger ;
45749: LD_ADDR_OWVAR 28
45753: PUSH
45754: LD_INT 14
45756: ST_TO_ADDR
// hc_gallery =  ;
45757: LD_ADDR_OWVAR 33
45761: PUSH
45762: LD_STRING 
45764: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45765: LD_ADDR_OWVAR 35
45769: PUSH
45770: LD_INT 7
45772: NEG
45773: PPUSH
45774: LD_INT 7
45776: PPUSH
45777: CALL_OW 12
45781: ST_TO_ADDR
// animal := CreateHuman ;
45782: LD_ADDR_VAR 0 12
45786: PUSH
45787: CALL_OW 44
45791: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45792: LD_VAR 0 12
45796: PPUSH
45797: LD_VAR 0 8
45801: PPUSH
45802: LD_INT 0
45804: PPUSH
45805: CALL 47711 0 3
// end ;
45809: GO 45746
45811: POP
45812: POP
// if apemans then
45813: LD_VAR 0 3
45817: IFFALSE 45940
// for i = 1 to apemans do
45819: LD_ADDR_VAR 0 11
45823: PUSH
45824: DOUBLE
45825: LD_INT 1
45827: DEC
45828: ST_TO_ADDR
45829: LD_VAR 0 3
45833: PUSH
45834: FOR_TO
45835: IFFALSE 45938
// begin hc_class = class_apeman ;
45837: LD_ADDR_OWVAR 28
45841: PUSH
45842: LD_INT 12
45844: ST_TO_ADDR
// hc_gallery =  ;
45845: LD_ADDR_OWVAR 33
45849: PUSH
45850: LD_STRING 
45852: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45853: LD_ADDR_OWVAR 35
45857: PUSH
45858: LD_INT 2
45860: NEG
45861: PPUSH
45862: LD_INT 2
45864: PPUSH
45865: CALL_OW 12
45869: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45870: LD_ADDR_OWVAR 31
45874: PUSH
45875: LD_INT 1
45877: PPUSH
45878: LD_INT 3
45880: PPUSH
45881: CALL_OW 12
45885: PUSH
45886: LD_INT 1
45888: PPUSH
45889: LD_INT 3
45891: PPUSH
45892: CALL_OW 12
45896: PUSH
45897: LD_INT 0
45899: PUSH
45900: LD_INT 0
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: LIST
45907: LIST
45908: ST_TO_ADDR
// animal := CreateHuman ;
45909: LD_ADDR_VAR 0 12
45913: PUSH
45914: CALL_OW 44
45918: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45919: LD_VAR 0 12
45923: PPUSH
45924: LD_VAR 0 8
45928: PPUSH
45929: LD_INT 0
45931: PPUSH
45932: CALL 47711 0 3
// end ;
45936: GO 45834
45938: POP
45939: POP
// if enchidnas then
45940: LD_VAR 0 4
45944: IFFALSE 46011
// for i = 1 to enchidnas do
45946: LD_ADDR_VAR 0 11
45950: PUSH
45951: DOUBLE
45952: LD_INT 1
45954: DEC
45955: ST_TO_ADDR
45956: LD_VAR 0 4
45960: PUSH
45961: FOR_TO
45962: IFFALSE 46009
// begin hc_class = 13 ;
45964: LD_ADDR_OWVAR 28
45968: PUSH
45969: LD_INT 13
45971: ST_TO_ADDR
// hc_gallery =  ;
45972: LD_ADDR_OWVAR 33
45976: PUSH
45977: LD_STRING 
45979: ST_TO_ADDR
// animal := CreateHuman ;
45980: LD_ADDR_VAR 0 12
45984: PUSH
45985: CALL_OW 44
45989: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45990: LD_VAR 0 12
45994: PPUSH
45995: LD_VAR 0 8
45999: PPUSH
46000: LD_INT 0
46002: PPUSH
46003: CALL 47711 0 3
// end ;
46007: GO 45961
46009: POP
46010: POP
// if fishes then
46011: LD_VAR 0 7
46015: IFFALSE 46082
// for i = 1 to fishes do
46017: LD_ADDR_VAR 0 11
46021: PUSH
46022: DOUBLE
46023: LD_INT 1
46025: DEC
46026: ST_TO_ADDR
46027: LD_VAR 0 7
46031: PUSH
46032: FOR_TO
46033: IFFALSE 46080
// begin hc_class = 20 ;
46035: LD_ADDR_OWVAR 28
46039: PUSH
46040: LD_INT 20
46042: ST_TO_ADDR
// hc_gallery =  ;
46043: LD_ADDR_OWVAR 33
46047: PUSH
46048: LD_STRING 
46050: ST_TO_ADDR
// animal := CreateHuman ;
46051: LD_ADDR_VAR 0 12
46055: PUSH
46056: CALL_OW 44
46060: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46061: LD_VAR 0 12
46065: PPUSH
46066: LD_VAR 0 9
46070: PPUSH
46071: LD_INT 0
46073: PPUSH
46074: CALL 47711 0 3
// end ;
46078: GO 46032
46080: POP
46081: POP
// end ;
46082: LD_VAR 0 10
46086: RET
// export function WantHeal ( sci , unit ) ; begin
46087: LD_INT 0
46089: PPUSH
// if GetTaskList ( sci ) > 0 then
46090: LD_VAR 0 1
46094: PPUSH
46095: CALL_OW 437
46099: PUSH
46100: LD_INT 0
46102: GREATER
46103: IFFALSE 46173
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46105: LD_VAR 0 1
46109: PPUSH
46110: CALL_OW 437
46114: PUSH
46115: LD_INT 1
46117: ARRAY
46118: PUSH
46119: LD_INT 1
46121: ARRAY
46122: PUSH
46123: LD_STRING l
46125: EQUAL
46126: PUSH
46127: LD_VAR 0 1
46131: PPUSH
46132: CALL_OW 437
46136: PUSH
46137: LD_INT 1
46139: ARRAY
46140: PUSH
46141: LD_INT 4
46143: ARRAY
46144: PUSH
46145: LD_VAR 0 2
46149: EQUAL
46150: AND
46151: IFFALSE 46163
// result := true else
46153: LD_ADDR_VAR 0 3
46157: PUSH
46158: LD_INT 1
46160: ST_TO_ADDR
46161: GO 46171
// result := false ;
46163: LD_ADDR_VAR 0 3
46167: PUSH
46168: LD_INT 0
46170: ST_TO_ADDR
// end else
46171: GO 46181
// result := false ;
46173: LD_ADDR_VAR 0 3
46177: PUSH
46178: LD_INT 0
46180: ST_TO_ADDR
// end ;
46181: LD_VAR 0 3
46185: RET
// export function HealTarget ( sci ) ; begin
46186: LD_INT 0
46188: PPUSH
// if not sci then
46189: LD_VAR 0 1
46193: NOT
46194: IFFALSE 46198
// exit ;
46196: GO 46263
// result := 0 ;
46198: LD_ADDR_VAR 0 2
46202: PUSH
46203: LD_INT 0
46205: ST_TO_ADDR
// if GetTaskList ( sci ) then
46206: LD_VAR 0 1
46210: PPUSH
46211: CALL_OW 437
46215: IFFALSE 46263
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46217: LD_VAR 0 1
46221: PPUSH
46222: CALL_OW 437
46226: PUSH
46227: LD_INT 1
46229: ARRAY
46230: PUSH
46231: LD_INT 1
46233: ARRAY
46234: PUSH
46235: LD_STRING l
46237: EQUAL
46238: IFFALSE 46263
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46240: LD_ADDR_VAR 0 2
46244: PUSH
46245: LD_VAR 0 1
46249: PPUSH
46250: CALL_OW 437
46254: PUSH
46255: LD_INT 1
46257: ARRAY
46258: PUSH
46259: LD_INT 4
46261: ARRAY
46262: ST_TO_ADDR
// end ;
46263: LD_VAR 0 2
46267: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
46268: LD_INT 0
46270: PPUSH
46271: PPUSH
46272: PPUSH
46273: PPUSH
// if not base_units then
46274: LD_VAR 0 1
46278: NOT
46279: IFFALSE 46283
// exit ;
46281: GO 46370
// result := false ;
46283: LD_ADDR_VAR 0 2
46287: PUSH
46288: LD_INT 0
46290: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
46291: LD_ADDR_VAR 0 5
46295: PUSH
46296: LD_VAR 0 1
46300: PPUSH
46301: LD_INT 21
46303: PUSH
46304: LD_INT 3
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PPUSH
46311: CALL_OW 72
46315: ST_TO_ADDR
// if not tmp then
46316: LD_VAR 0 5
46320: NOT
46321: IFFALSE 46325
// exit ;
46323: GO 46370
// for i in tmp do
46325: LD_ADDR_VAR 0 3
46329: PUSH
46330: LD_VAR 0 5
46334: PUSH
46335: FOR_IN
46336: IFFALSE 46368
// begin result := EnemyInRange ( i , 22 ) ;
46338: LD_ADDR_VAR 0 2
46342: PUSH
46343: LD_VAR 0 3
46347: PPUSH
46348: LD_INT 22
46350: PPUSH
46351: CALL 43968 0 2
46355: ST_TO_ADDR
// if result then
46356: LD_VAR 0 2
46360: IFFALSE 46366
// exit ;
46362: POP
46363: POP
46364: GO 46370
// end ;
46366: GO 46335
46368: POP
46369: POP
// end ;
46370: LD_VAR 0 2
46374: RET
// export function FilterByTag ( units , tag ) ; begin
46375: LD_INT 0
46377: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46378: LD_ADDR_VAR 0 3
46382: PUSH
46383: LD_VAR 0 1
46387: PPUSH
46388: LD_INT 120
46390: PUSH
46391: LD_VAR 0 2
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: PPUSH
46400: CALL_OW 72
46404: ST_TO_ADDR
// end ;
46405: LD_VAR 0 3
46409: RET
// export function IsDriver ( un ) ; begin
46410: LD_INT 0
46412: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46413: LD_ADDR_VAR 0 2
46417: PUSH
46418: LD_VAR 0 1
46422: PUSH
46423: LD_INT 55
46425: PUSH
46426: EMPTY
46427: LIST
46428: PPUSH
46429: CALL_OW 69
46433: IN
46434: ST_TO_ADDR
// end ;
46435: LD_VAR 0 2
46439: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46440: LD_INT 0
46442: PPUSH
46443: PPUSH
// list := [ ] ;
46444: LD_ADDR_VAR 0 5
46448: PUSH
46449: EMPTY
46450: ST_TO_ADDR
// case d of 0 :
46451: LD_VAR 0 3
46455: PUSH
46456: LD_INT 0
46458: DOUBLE
46459: EQUAL
46460: IFTRUE 46464
46462: GO 46597
46464: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46465: LD_ADDR_VAR 0 5
46469: PUSH
46470: LD_VAR 0 1
46474: PUSH
46475: LD_INT 4
46477: MINUS
46478: PUSH
46479: LD_VAR 0 2
46483: PUSH
46484: LD_INT 4
46486: MINUS
46487: PUSH
46488: LD_INT 2
46490: PUSH
46491: EMPTY
46492: LIST
46493: LIST
46494: LIST
46495: PUSH
46496: LD_VAR 0 1
46500: PUSH
46501: LD_INT 3
46503: MINUS
46504: PUSH
46505: LD_VAR 0 2
46509: PUSH
46510: LD_INT 1
46512: PUSH
46513: EMPTY
46514: LIST
46515: LIST
46516: LIST
46517: PUSH
46518: LD_VAR 0 1
46522: PUSH
46523: LD_INT 4
46525: PLUS
46526: PUSH
46527: LD_VAR 0 2
46531: PUSH
46532: LD_INT 4
46534: PUSH
46535: EMPTY
46536: LIST
46537: LIST
46538: LIST
46539: PUSH
46540: LD_VAR 0 1
46544: PUSH
46545: LD_INT 3
46547: PLUS
46548: PUSH
46549: LD_VAR 0 2
46553: PUSH
46554: LD_INT 3
46556: PLUS
46557: PUSH
46558: LD_INT 5
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: LIST
46565: PUSH
46566: LD_VAR 0 1
46570: PUSH
46571: LD_VAR 0 2
46575: PUSH
46576: LD_INT 4
46578: PLUS
46579: PUSH
46580: LD_INT 0
46582: PUSH
46583: EMPTY
46584: LIST
46585: LIST
46586: LIST
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: ST_TO_ADDR
// end ; 1 :
46595: GO 47295
46597: LD_INT 1
46599: DOUBLE
46600: EQUAL
46601: IFTRUE 46605
46603: GO 46738
46605: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46606: LD_ADDR_VAR 0 5
46610: PUSH
46611: LD_VAR 0 1
46615: PUSH
46616: LD_VAR 0 2
46620: PUSH
46621: LD_INT 4
46623: MINUS
46624: PUSH
46625: LD_INT 3
46627: PUSH
46628: EMPTY
46629: LIST
46630: LIST
46631: LIST
46632: PUSH
46633: LD_VAR 0 1
46637: PUSH
46638: LD_INT 3
46640: MINUS
46641: PUSH
46642: LD_VAR 0 2
46646: PUSH
46647: LD_INT 3
46649: MINUS
46650: PUSH
46651: LD_INT 2
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: LIST
46658: PUSH
46659: LD_VAR 0 1
46663: PUSH
46664: LD_INT 4
46666: MINUS
46667: PUSH
46668: LD_VAR 0 2
46672: PUSH
46673: LD_INT 1
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: LIST
46680: PUSH
46681: LD_VAR 0 1
46685: PUSH
46686: LD_VAR 0 2
46690: PUSH
46691: LD_INT 3
46693: PLUS
46694: PUSH
46695: LD_INT 0
46697: PUSH
46698: EMPTY
46699: LIST
46700: LIST
46701: LIST
46702: PUSH
46703: LD_VAR 0 1
46707: PUSH
46708: LD_INT 4
46710: PLUS
46711: PUSH
46712: LD_VAR 0 2
46716: PUSH
46717: LD_INT 4
46719: PLUS
46720: PUSH
46721: LD_INT 5
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: LIST
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: ST_TO_ADDR
// end ; 2 :
46736: GO 47295
46738: LD_INT 2
46740: DOUBLE
46741: EQUAL
46742: IFTRUE 46746
46744: GO 46875
46746: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46747: LD_ADDR_VAR 0 5
46751: PUSH
46752: LD_VAR 0 1
46756: PUSH
46757: LD_VAR 0 2
46761: PUSH
46762: LD_INT 3
46764: MINUS
46765: PUSH
46766: LD_INT 3
46768: PUSH
46769: EMPTY
46770: LIST
46771: LIST
46772: LIST
46773: PUSH
46774: LD_VAR 0 1
46778: PUSH
46779: LD_INT 4
46781: PLUS
46782: PUSH
46783: LD_VAR 0 2
46787: PUSH
46788: LD_INT 4
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: LIST
46795: PUSH
46796: LD_VAR 0 1
46800: PUSH
46801: LD_VAR 0 2
46805: PUSH
46806: LD_INT 4
46808: PLUS
46809: PUSH
46810: LD_INT 0
46812: PUSH
46813: EMPTY
46814: LIST
46815: LIST
46816: LIST
46817: PUSH
46818: LD_VAR 0 1
46822: PUSH
46823: LD_INT 3
46825: MINUS
46826: PUSH
46827: LD_VAR 0 2
46831: PUSH
46832: LD_INT 1
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: PUSH
46840: LD_VAR 0 1
46844: PUSH
46845: LD_INT 4
46847: MINUS
46848: PUSH
46849: LD_VAR 0 2
46853: PUSH
46854: LD_INT 4
46856: MINUS
46857: PUSH
46858: LD_INT 2
46860: PUSH
46861: EMPTY
46862: LIST
46863: LIST
46864: LIST
46865: PUSH
46866: EMPTY
46867: LIST
46868: LIST
46869: LIST
46870: LIST
46871: LIST
46872: ST_TO_ADDR
// end ; 3 :
46873: GO 47295
46875: LD_INT 3
46877: DOUBLE
46878: EQUAL
46879: IFTRUE 46883
46881: GO 47016
46883: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46884: LD_ADDR_VAR 0 5
46888: PUSH
46889: LD_VAR 0 1
46893: PUSH
46894: LD_INT 3
46896: PLUS
46897: PUSH
46898: LD_VAR 0 2
46902: PUSH
46903: LD_INT 4
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: LIST
46910: PUSH
46911: LD_VAR 0 1
46915: PUSH
46916: LD_INT 4
46918: PLUS
46919: PUSH
46920: LD_VAR 0 2
46924: PUSH
46925: LD_INT 4
46927: PLUS
46928: PUSH
46929: LD_INT 5
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: LIST
46936: PUSH
46937: LD_VAR 0 1
46941: PUSH
46942: LD_INT 4
46944: MINUS
46945: PUSH
46946: LD_VAR 0 2
46950: PUSH
46951: LD_INT 1
46953: PUSH
46954: EMPTY
46955: LIST
46956: LIST
46957: LIST
46958: PUSH
46959: LD_VAR 0 1
46963: PUSH
46964: LD_VAR 0 2
46968: PUSH
46969: LD_INT 4
46971: MINUS
46972: PUSH
46973: LD_INT 3
46975: PUSH
46976: EMPTY
46977: LIST
46978: LIST
46979: LIST
46980: PUSH
46981: LD_VAR 0 1
46985: PUSH
46986: LD_INT 3
46988: MINUS
46989: PUSH
46990: LD_VAR 0 2
46994: PUSH
46995: LD_INT 3
46997: MINUS
46998: PUSH
46999: LD_INT 2
47001: PUSH
47002: EMPTY
47003: LIST
47004: LIST
47005: LIST
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: LIST
47011: LIST
47012: LIST
47013: ST_TO_ADDR
// end ; 4 :
47014: GO 47295
47016: LD_INT 4
47018: DOUBLE
47019: EQUAL
47020: IFTRUE 47024
47022: GO 47157
47024: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
47025: LD_ADDR_VAR 0 5
47029: PUSH
47030: LD_VAR 0 1
47034: PUSH
47035: LD_VAR 0 2
47039: PUSH
47040: LD_INT 4
47042: PLUS
47043: PUSH
47044: LD_INT 0
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: LIST
47051: PUSH
47052: LD_VAR 0 1
47056: PUSH
47057: LD_INT 3
47059: PLUS
47060: PUSH
47061: LD_VAR 0 2
47065: PUSH
47066: LD_INT 3
47068: PLUS
47069: PUSH
47070: LD_INT 5
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: LIST
47077: PUSH
47078: LD_VAR 0 1
47082: PUSH
47083: LD_INT 4
47085: PLUS
47086: PUSH
47087: LD_VAR 0 2
47091: PUSH
47092: LD_INT 4
47094: PUSH
47095: EMPTY
47096: LIST
47097: LIST
47098: LIST
47099: PUSH
47100: LD_VAR 0 1
47104: PUSH
47105: LD_VAR 0 2
47109: PUSH
47110: LD_INT 3
47112: MINUS
47113: PUSH
47114: LD_INT 3
47116: PUSH
47117: EMPTY
47118: LIST
47119: LIST
47120: LIST
47121: PUSH
47122: LD_VAR 0 1
47126: PUSH
47127: LD_INT 4
47129: MINUS
47130: PUSH
47131: LD_VAR 0 2
47135: PUSH
47136: LD_INT 4
47138: MINUS
47139: PUSH
47140: LD_INT 2
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: LIST
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: LIST
47152: LIST
47153: LIST
47154: ST_TO_ADDR
// end ; 5 :
47155: GO 47295
47157: LD_INT 5
47159: DOUBLE
47160: EQUAL
47161: IFTRUE 47165
47163: GO 47294
47165: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
47166: LD_ADDR_VAR 0 5
47170: PUSH
47171: LD_VAR 0 1
47175: PUSH
47176: LD_INT 4
47178: MINUS
47179: PUSH
47180: LD_VAR 0 2
47184: PUSH
47185: LD_INT 1
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: LIST
47192: PUSH
47193: LD_VAR 0 1
47197: PUSH
47198: LD_VAR 0 2
47202: PUSH
47203: LD_INT 4
47205: MINUS
47206: PUSH
47207: LD_INT 3
47209: PUSH
47210: EMPTY
47211: LIST
47212: LIST
47213: LIST
47214: PUSH
47215: LD_VAR 0 1
47219: PUSH
47220: LD_INT 4
47222: PLUS
47223: PUSH
47224: LD_VAR 0 2
47228: PUSH
47229: LD_INT 4
47231: PLUS
47232: PUSH
47233: LD_INT 5
47235: PUSH
47236: EMPTY
47237: LIST
47238: LIST
47239: LIST
47240: PUSH
47241: LD_VAR 0 1
47245: PUSH
47246: LD_INT 3
47248: PLUS
47249: PUSH
47250: LD_VAR 0 2
47254: PUSH
47255: LD_INT 4
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: LIST
47262: PUSH
47263: LD_VAR 0 1
47267: PUSH
47268: LD_VAR 0 2
47272: PUSH
47273: LD_INT 3
47275: PLUS
47276: PUSH
47277: LD_INT 0
47279: PUSH
47280: EMPTY
47281: LIST
47282: LIST
47283: LIST
47284: PUSH
47285: EMPTY
47286: LIST
47287: LIST
47288: LIST
47289: LIST
47290: LIST
47291: ST_TO_ADDR
// end ; end ;
47292: GO 47295
47294: POP
// result := list ;
47295: LD_ADDR_VAR 0 4
47299: PUSH
47300: LD_VAR 0 5
47304: ST_TO_ADDR
// end ;
47305: LD_VAR 0 4
47309: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
47310: LD_INT 0
47312: PPUSH
47313: PPUSH
47314: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
47315: LD_VAR 0 1
47319: NOT
47320: PUSH
47321: LD_VAR 0 2
47325: PUSH
47326: LD_INT 1
47328: PUSH
47329: LD_INT 2
47331: PUSH
47332: LD_INT 3
47334: PUSH
47335: LD_INT 4
47337: PUSH
47338: EMPTY
47339: LIST
47340: LIST
47341: LIST
47342: LIST
47343: IN
47344: NOT
47345: OR
47346: IFFALSE 47350
// exit ;
47348: GO 47433
// tmp := [ ] ;
47350: LD_ADDR_VAR 0 5
47354: PUSH
47355: EMPTY
47356: ST_TO_ADDR
// for i in units do
47357: LD_ADDR_VAR 0 4
47361: PUSH
47362: LD_VAR 0 1
47366: PUSH
47367: FOR_IN
47368: IFFALSE 47402
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
47370: LD_ADDR_VAR 0 5
47374: PUSH
47375: LD_VAR 0 5
47379: PPUSH
47380: LD_VAR 0 4
47384: PPUSH
47385: LD_VAR 0 2
47389: PPUSH
47390: CALL_OW 259
47394: PPUSH
47395: CALL 48806 0 2
47399: ST_TO_ADDR
47400: GO 47367
47402: POP
47403: POP
// if not tmp then
47404: LD_VAR 0 5
47408: NOT
47409: IFFALSE 47413
// exit ;
47411: GO 47433
// result := SortListByListDesc ( units , tmp ) ;
47413: LD_ADDR_VAR 0 3
47417: PUSH
47418: LD_VAR 0 1
47422: PPUSH
47423: LD_VAR 0 5
47427: PPUSH
47428: CALL_OW 77
47432: ST_TO_ADDR
// end ;
47433: LD_VAR 0 3
47437: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47438: LD_INT 0
47440: PPUSH
47441: PPUSH
47442: PPUSH
// result := false ;
47443: LD_ADDR_VAR 0 3
47447: PUSH
47448: LD_INT 0
47450: ST_TO_ADDR
// if not building then
47451: LD_VAR 0 2
47455: NOT
47456: IFFALSE 47460
// exit ;
47458: GO 47598
// x := GetX ( building ) ;
47460: LD_ADDR_VAR 0 4
47464: PUSH
47465: LD_VAR 0 2
47469: PPUSH
47470: CALL_OW 250
47474: ST_TO_ADDR
// y := GetY ( building ) ;
47475: LD_ADDR_VAR 0 5
47479: PUSH
47480: LD_VAR 0 2
47484: PPUSH
47485: CALL_OW 251
47489: ST_TO_ADDR
// if not x or not y then
47490: LD_VAR 0 4
47494: NOT
47495: PUSH
47496: LD_VAR 0 5
47500: NOT
47501: OR
47502: IFFALSE 47506
// exit ;
47504: GO 47598
// if GetTaskList ( unit ) then
47506: LD_VAR 0 1
47510: PPUSH
47511: CALL_OW 437
47515: IFFALSE 47598
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47517: LD_STRING e
47519: PUSH
47520: LD_VAR 0 1
47524: PPUSH
47525: CALL_OW 437
47529: PUSH
47530: LD_INT 1
47532: ARRAY
47533: PUSH
47534: LD_INT 1
47536: ARRAY
47537: EQUAL
47538: PUSH
47539: LD_VAR 0 4
47543: PUSH
47544: LD_VAR 0 1
47548: PPUSH
47549: CALL_OW 437
47553: PUSH
47554: LD_INT 1
47556: ARRAY
47557: PUSH
47558: LD_INT 2
47560: ARRAY
47561: EQUAL
47562: AND
47563: PUSH
47564: LD_VAR 0 5
47568: PUSH
47569: LD_VAR 0 1
47573: PPUSH
47574: CALL_OW 437
47578: PUSH
47579: LD_INT 1
47581: ARRAY
47582: PUSH
47583: LD_INT 3
47585: ARRAY
47586: EQUAL
47587: AND
47588: IFFALSE 47598
// result := true end ;
47590: LD_ADDR_VAR 0 3
47594: PUSH
47595: LD_INT 1
47597: ST_TO_ADDR
// end ;
47598: LD_VAR 0 3
47602: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47603: LD_INT 0
47605: PPUSH
// result := false ;
47606: LD_ADDR_VAR 0 4
47610: PUSH
47611: LD_INT 0
47613: ST_TO_ADDR
// if GetTaskList ( unit ) then
47614: LD_VAR 0 1
47618: PPUSH
47619: CALL_OW 437
47623: IFFALSE 47706
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47625: LD_STRING M
47627: PUSH
47628: LD_VAR 0 1
47632: PPUSH
47633: CALL_OW 437
47637: PUSH
47638: LD_INT 1
47640: ARRAY
47641: PUSH
47642: LD_INT 1
47644: ARRAY
47645: EQUAL
47646: PUSH
47647: LD_VAR 0 2
47651: PUSH
47652: LD_VAR 0 1
47656: PPUSH
47657: CALL_OW 437
47661: PUSH
47662: LD_INT 1
47664: ARRAY
47665: PUSH
47666: LD_INT 2
47668: ARRAY
47669: EQUAL
47670: AND
47671: PUSH
47672: LD_VAR 0 3
47676: PUSH
47677: LD_VAR 0 1
47681: PPUSH
47682: CALL_OW 437
47686: PUSH
47687: LD_INT 1
47689: ARRAY
47690: PUSH
47691: LD_INT 3
47693: ARRAY
47694: EQUAL
47695: AND
47696: IFFALSE 47706
// result := true ;
47698: LD_ADDR_VAR 0 4
47702: PUSH
47703: LD_INT 1
47705: ST_TO_ADDR
// end ; end ;
47706: LD_VAR 0 4
47710: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47711: LD_INT 0
47713: PPUSH
47714: PPUSH
47715: PPUSH
47716: PPUSH
// if not unit or not area then
47717: LD_VAR 0 1
47721: NOT
47722: PUSH
47723: LD_VAR 0 2
47727: NOT
47728: OR
47729: IFFALSE 47733
// exit ;
47731: GO 47909
// tmp := AreaToList ( area , i ) ;
47733: LD_ADDR_VAR 0 6
47737: PUSH
47738: LD_VAR 0 2
47742: PPUSH
47743: LD_VAR 0 5
47747: PPUSH
47748: CALL_OW 517
47752: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47753: LD_ADDR_VAR 0 5
47757: PUSH
47758: DOUBLE
47759: LD_INT 1
47761: DEC
47762: ST_TO_ADDR
47763: LD_VAR 0 6
47767: PUSH
47768: LD_INT 1
47770: ARRAY
47771: PUSH
47772: FOR_TO
47773: IFFALSE 47907
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47775: LD_ADDR_VAR 0 7
47779: PUSH
47780: LD_VAR 0 6
47784: PUSH
47785: LD_INT 1
47787: ARRAY
47788: PUSH
47789: LD_VAR 0 5
47793: ARRAY
47794: PUSH
47795: LD_VAR 0 6
47799: PUSH
47800: LD_INT 2
47802: ARRAY
47803: PUSH
47804: LD_VAR 0 5
47808: ARRAY
47809: PUSH
47810: EMPTY
47811: LIST
47812: LIST
47813: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
47814: LD_INT 92
47816: PUSH
47817: LD_VAR 0 7
47821: PUSH
47822: LD_INT 1
47824: ARRAY
47825: PUSH
47826: LD_VAR 0 7
47830: PUSH
47831: LD_INT 2
47833: ARRAY
47834: PUSH
47835: LD_INT 2
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: PPUSH
47844: CALL_OW 69
47848: PUSH
47849: LD_INT 0
47851: EQUAL
47852: IFFALSE 47905
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47854: LD_VAR 0 1
47858: PPUSH
47859: LD_VAR 0 7
47863: PUSH
47864: LD_INT 1
47866: ARRAY
47867: PPUSH
47868: LD_VAR 0 7
47872: PUSH
47873: LD_INT 2
47875: ARRAY
47876: PPUSH
47877: LD_VAR 0 3
47881: PPUSH
47882: CALL_OW 48
// result := IsPlaced ( unit ) ;
47886: LD_ADDR_VAR 0 4
47890: PUSH
47891: LD_VAR 0 1
47895: PPUSH
47896: CALL_OW 305
47900: ST_TO_ADDR
// exit ;
47901: POP
47902: POP
47903: GO 47909
// end ; end ;
47905: GO 47772
47907: POP
47908: POP
// end ;
47909: LD_VAR 0 4
47913: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47914: LD_INT 0
47916: PPUSH
47917: PPUSH
47918: PPUSH
// if not side or side > 8 then
47919: LD_VAR 0 1
47923: NOT
47924: PUSH
47925: LD_VAR 0 1
47929: PUSH
47930: LD_INT 8
47932: GREATER
47933: OR
47934: IFFALSE 47938
// exit ;
47936: GO 48125
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47938: LD_ADDR_VAR 0 4
47942: PUSH
47943: LD_INT 22
47945: PUSH
47946: LD_VAR 0 1
47950: PUSH
47951: EMPTY
47952: LIST
47953: LIST
47954: PUSH
47955: LD_INT 21
47957: PUSH
47958: LD_INT 3
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: PUSH
47965: EMPTY
47966: LIST
47967: LIST
47968: PPUSH
47969: CALL_OW 69
47973: ST_TO_ADDR
// if not tmp then
47974: LD_VAR 0 4
47978: NOT
47979: IFFALSE 47983
// exit ;
47981: GO 48125
// enable_addtolog := true ;
47983: LD_ADDR_OWVAR 81
47987: PUSH
47988: LD_INT 1
47990: ST_TO_ADDR
// AddToLog ( [ ) ;
47991: LD_STRING [
47993: PPUSH
47994: CALL_OW 561
// for i in tmp do
47998: LD_ADDR_VAR 0 3
48002: PUSH
48003: LD_VAR 0 4
48007: PUSH
48008: FOR_IN
48009: IFFALSE 48116
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
48011: LD_STRING [
48013: PUSH
48014: LD_VAR 0 3
48018: PPUSH
48019: CALL_OW 266
48023: STR
48024: PUSH
48025: LD_STRING , 
48027: STR
48028: PUSH
48029: LD_VAR 0 3
48033: PPUSH
48034: CALL_OW 250
48038: STR
48039: PUSH
48040: LD_STRING , 
48042: STR
48043: PUSH
48044: LD_VAR 0 3
48048: PPUSH
48049: CALL_OW 251
48053: STR
48054: PUSH
48055: LD_STRING , 
48057: STR
48058: PUSH
48059: LD_VAR 0 3
48063: PPUSH
48064: CALL_OW 254
48068: STR
48069: PUSH
48070: LD_STRING , 
48072: STR
48073: PUSH
48074: LD_VAR 0 3
48078: PPUSH
48079: LD_INT 1
48081: PPUSH
48082: CALL_OW 268
48086: STR
48087: PUSH
48088: LD_STRING , 
48090: STR
48091: PUSH
48092: LD_VAR 0 3
48096: PPUSH
48097: LD_INT 2
48099: PPUSH
48100: CALL_OW 268
48104: STR
48105: PUSH
48106: LD_STRING ],
48108: STR
48109: PPUSH
48110: CALL_OW 561
// end ;
48114: GO 48008
48116: POP
48117: POP
// AddToLog ( ]; ) ;
48118: LD_STRING ];
48120: PPUSH
48121: CALL_OW 561
// end ;
48125: LD_VAR 0 2
48129: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
48130: LD_INT 0
48132: PPUSH
48133: PPUSH
48134: PPUSH
48135: PPUSH
48136: PPUSH
// if not area or not rate or not max then
48137: LD_VAR 0 1
48141: NOT
48142: PUSH
48143: LD_VAR 0 2
48147: NOT
48148: OR
48149: PUSH
48150: LD_VAR 0 4
48154: NOT
48155: OR
48156: IFFALSE 48160
// exit ;
48158: GO 48349
// while 1 do
48160: LD_INT 1
48162: IFFALSE 48349
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
48164: LD_ADDR_VAR 0 9
48168: PUSH
48169: LD_VAR 0 1
48173: PPUSH
48174: LD_INT 1
48176: PPUSH
48177: CALL_OW 287
48181: PUSH
48182: LD_INT 10
48184: MUL
48185: ST_TO_ADDR
// r := rate / 10 ;
48186: LD_ADDR_VAR 0 7
48190: PUSH
48191: LD_VAR 0 2
48195: PUSH
48196: LD_INT 10
48198: DIVREAL
48199: ST_TO_ADDR
// time := 1 1$00 ;
48200: LD_ADDR_VAR 0 8
48204: PUSH
48205: LD_INT 2100
48207: ST_TO_ADDR
// if amount < min then
48208: LD_VAR 0 9
48212: PUSH
48213: LD_VAR 0 3
48217: LESS
48218: IFFALSE 48236
// r := r * 2 else
48220: LD_ADDR_VAR 0 7
48224: PUSH
48225: LD_VAR 0 7
48229: PUSH
48230: LD_INT 2
48232: MUL
48233: ST_TO_ADDR
48234: GO 48262
// if amount > max then
48236: LD_VAR 0 9
48240: PUSH
48241: LD_VAR 0 4
48245: GREATER
48246: IFFALSE 48262
// r := r / 2 ;
48248: LD_ADDR_VAR 0 7
48252: PUSH
48253: LD_VAR 0 7
48257: PUSH
48258: LD_INT 2
48260: DIVREAL
48261: ST_TO_ADDR
// time := time / r ;
48262: LD_ADDR_VAR 0 8
48266: PUSH
48267: LD_VAR 0 8
48271: PUSH
48272: LD_VAR 0 7
48276: DIVREAL
48277: ST_TO_ADDR
// if time < 0 then
48278: LD_VAR 0 8
48282: PUSH
48283: LD_INT 0
48285: LESS
48286: IFFALSE 48303
// time := time * - 1 ;
48288: LD_ADDR_VAR 0 8
48292: PUSH
48293: LD_VAR 0 8
48297: PUSH
48298: LD_INT 1
48300: NEG
48301: MUL
48302: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
48303: LD_VAR 0 8
48307: PUSH
48308: LD_INT 35
48310: PPUSH
48311: LD_INT 875
48313: PPUSH
48314: CALL_OW 12
48318: PLUS
48319: PPUSH
48320: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
48324: LD_INT 1
48326: PPUSH
48327: LD_INT 5
48329: PPUSH
48330: CALL_OW 12
48334: PPUSH
48335: LD_VAR 0 1
48339: PPUSH
48340: LD_INT 1
48342: PPUSH
48343: CALL_OW 55
// end ;
48347: GO 48160
// end ;
48349: LD_VAR 0 5
48353: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
48354: LD_INT 0
48356: PPUSH
48357: PPUSH
48358: PPUSH
48359: PPUSH
48360: PPUSH
48361: PPUSH
48362: PPUSH
48363: PPUSH
// if not turrets or not factories then
48364: LD_VAR 0 1
48368: NOT
48369: PUSH
48370: LD_VAR 0 2
48374: NOT
48375: OR
48376: IFFALSE 48380
// exit ;
48378: GO 48687
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48380: LD_ADDR_VAR 0 10
48384: PUSH
48385: LD_INT 5
48387: PUSH
48388: LD_INT 6
48390: PUSH
48391: EMPTY
48392: LIST
48393: LIST
48394: PUSH
48395: LD_INT 2
48397: PUSH
48398: LD_INT 4
48400: PUSH
48401: EMPTY
48402: LIST
48403: LIST
48404: PUSH
48405: LD_INT 3
48407: PUSH
48408: LD_INT 5
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: EMPTY
48416: LIST
48417: LIST
48418: LIST
48419: PUSH
48420: LD_INT 24
48422: PUSH
48423: LD_INT 25
48425: PUSH
48426: EMPTY
48427: LIST
48428: LIST
48429: PUSH
48430: LD_INT 23
48432: PUSH
48433: LD_INT 27
48435: PUSH
48436: EMPTY
48437: LIST
48438: LIST
48439: PUSH
48440: EMPTY
48441: LIST
48442: LIST
48443: PUSH
48444: LD_INT 42
48446: PUSH
48447: LD_INT 43
48449: PUSH
48450: EMPTY
48451: LIST
48452: LIST
48453: PUSH
48454: LD_INT 44
48456: PUSH
48457: LD_INT 46
48459: PUSH
48460: EMPTY
48461: LIST
48462: LIST
48463: PUSH
48464: LD_INT 45
48466: PUSH
48467: LD_INT 47
48469: PUSH
48470: EMPTY
48471: LIST
48472: LIST
48473: PUSH
48474: EMPTY
48475: LIST
48476: LIST
48477: LIST
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: LIST
48483: ST_TO_ADDR
// result := [ ] ;
48484: LD_ADDR_VAR 0 3
48488: PUSH
48489: EMPTY
48490: ST_TO_ADDR
// for i in turrets do
48491: LD_ADDR_VAR 0 4
48495: PUSH
48496: LD_VAR 0 1
48500: PUSH
48501: FOR_IN
48502: IFFALSE 48685
// begin nat := GetNation ( i ) ;
48504: LD_ADDR_VAR 0 7
48508: PUSH
48509: LD_VAR 0 4
48513: PPUSH
48514: CALL_OW 248
48518: ST_TO_ADDR
// weapon := 0 ;
48519: LD_ADDR_VAR 0 8
48523: PUSH
48524: LD_INT 0
48526: ST_TO_ADDR
// if not nat then
48527: LD_VAR 0 7
48531: NOT
48532: IFFALSE 48536
// continue ;
48534: GO 48501
// for j in list [ nat ] do
48536: LD_ADDR_VAR 0 5
48540: PUSH
48541: LD_VAR 0 10
48545: PUSH
48546: LD_VAR 0 7
48550: ARRAY
48551: PUSH
48552: FOR_IN
48553: IFFALSE 48594
// if GetBWeapon ( i ) = j [ 1 ] then
48555: LD_VAR 0 4
48559: PPUSH
48560: CALL_OW 269
48564: PUSH
48565: LD_VAR 0 5
48569: PUSH
48570: LD_INT 1
48572: ARRAY
48573: EQUAL
48574: IFFALSE 48592
// begin weapon := j [ 2 ] ;
48576: LD_ADDR_VAR 0 8
48580: PUSH
48581: LD_VAR 0 5
48585: PUSH
48586: LD_INT 2
48588: ARRAY
48589: ST_TO_ADDR
// break ;
48590: GO 48594
// end ;
48592: GO 48552
48594: POP
48595: POP
// if not weapon then
48596: LD_VAR 0 8
48600: NOT
48601: IFFALSE 48605
// continue ;
48603: GO 48501
// for k in factories do
48605: LD_ADDR_VAR 0 6
48609: PUSH
48610: LD_VAR 0 2
48614: PUSH
48615: FOR_IN
48616: IFFALSE 48681
// begin weapons := AvailableWeaponList ( k ) ;
48618: LD_ADDR_VAR 0 9
48622: PUSH
48623: LD_VAR 0 6
48627: PPUSH
48628: CALL_OW 478
48632: ST_TO_ADDR
// if not weapons then
48633: LD_VAR 0 9
48637: NOT
48638: IFFALSE 48642
// continue ;
48640: GO 48615
// if weapon in weapons then
48642: LD_VAR 0 8
48646: PUSH
48647: LD_VAR 0 9
48651: IN
48652: IFFALSE 48679
// begin result := [ i , weapon ] ;
48654: LD_ADDR_VAR 0 3
48658: PUSH
48659: LD_VAR 0 4
48663: PUSH
48664: LD_VAR 0 8
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: ST_TO_ADDR
// exit ;
48673: POP
48674: POP
48675: POP
48676: POP
48677: GO 48687
// end ; end ;
48679: GO 48615
48681: POP
48682: POP
// end ;
48683: GO 48501
48685: POP
48686: POP
// end ;
48687: LD_VAR 0 3
48691: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48692: LD_INT 0
48694: PPUSH
// if not side or side > 8 then
48695: LD_VAR 0 3
48699: NOT
48700: PUSH
48701: LD_VAR 0 3
48705: PUSH
48706: LD_INT 8
48708: GREATER
48709: OR
48710: IFFALSE 48714
// exit ;
48712: GO 48773
// if not range then
48714: LD_VAR 0 4
48718: NOT
48719: IFFALSE 48730
// range := - 12 ;
48721: LD_ADDR_VAR 0 4
48725: PUSH
48726: LD_INT 12
48728: NEG
48729: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48730: LD_VAR 0 1
48734: PPUSH
48735: LD_VAR 0 2
48739: PPUSH
48740: LD_VAR 0 3
48744: PPUSH
48745: LD_VAR 0 4
48749: PPUSH
48750: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48754: LD_VAR 0 1
48758: PPUSH
48759: LD_VAR 0 2
48763: PPUSH
48764: LD_VAR 0 3
48768: PPUSH
48769: CALL_OW 331
// end ;
48773: LD_VAR 0 5
48777: RET
// export function Video ( mode ) ; begin
48778: LD_INT 0
48780: PPUSH
// ingame_video = mode ;
48781: LD_ADDR_OWVAR 52
48785: PUSH
48786: LD_VAR 0 1
48790: ST_TO_ADDR
// interface_hidden = mode ;
48791: LD_ADDR_OWVAR 54
48795: PUSH
48796: LD_VAR 0 1
48800: ST_TO_ADDR
// end ;
48801: LD_VAR 0 2
48805: RET
// export function Join ( array , element ) ; begin
48806: LD_INT 0
48808: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48809: LD_ADDR_VAR 0 3
48813: PUSH
48814: LD_VAR 0 1
48818: PPUSH
48819: LD_VAR 0 1
48823: PUSH
48824: LD_INT 1
48826: PLUS
48827: PPUSH
48828: LD_VAR 0 2
48832: PPUSH
48833: CALL_OW 1
48837: ST_TO_ADDR
// end ;
48838: LD_VAR 0 3
48842: RET
// export function JoinUnion ( array , element ) ; begin
48843: LD_INT 0
48845: PPUSH
// result := array union element ;
48846: LD_ADDR_VAR 0 3
48850: PUSH
48851: LD_VAR 0 1
48855: PUSH
48856: LD_VAR 0 2
48860: UNION
48861: ST_TO_ADDR
// end ;
48862: LD_VAR 0 3
48866: RET
// export function GetBehemoths ( side ) ; begin
48867: LD_INT 0
48869: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48870: LD_ADDR_VAR 0 2
48874: PUSH
48875: LD_INT 22
48877: PUSH
48878: LD_VAR 0 1
48882: PUSH
48883: EMPTY
48884: LIST
48885: LIST
48886: PUSH
48887: LD_INT 31
48889: PUSH
48890: LD_INT 25
48892: PUSH
48893: EMPTY
48894: LIST
48895: LIST
48896: PUSH
48897: EMPTY
48898: LIST
48899: LIST
48900: PPUSH
48901: CALL_OW 69
48905: ST_TO_ADDR
// end ;
48906: LD_VAR 0 2
48910: RET
// export function Shuffle ( array ) ; var i , index ; begin
48911: LD_INT 0
48913: PPUSH
48914: PPUSH
48915: PPUSH
// result := [ ] ;
48916: LD_ADDR_VAR 0 2
48920: PUSH
48921: EMPTY
48922: ST_TO_ADDR
// if not array then
48923: LD_VAR 0 1
48927: NOT
48928: IFFALSE 48932
// exit ;
48930: GO 49031
// Randomize ;
48932: CALL_OW 10
// for i = array downto 1 do
48936: LD_ADDR_VAR 0 3
48940: PUSH
48941: DOUBLE
48942: LD_VAR 0 1
48946: INC
48947: ST_TO_ADDR
48948: LD_INT 1
48950: PUSH
48951: FOR_DOWNTO
48952: IFFALSE 49029
// begin index := rand ( 1 , array ) ;
48954: LD_ADDR_VAR 0 4
48958: PUSH
48959: LD_INT 1
48961: PPUSH
48962: LD_VAR 0 1
48966: PPUSH
48967: CALL_OW 12
48971: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48972: LD_ADDR_VAR 0 2
48976: PUSH
48977: LD_VAR 0 2
48981: PPUSH
48982: LD_VAR 0 2
48986: PUSH
48987: LD_INT 1
48989: PLUS
48990: PPUSH
48991: LD_VAR 0 1
48995: PUSH
48996: LD_VAR 0 4
49000: ARRAY
49001: PPUSH
49002: CALL_OW 2
49006: ST_TO_ADDR
// array := Delete ( array , index ) ;
49007: LD_ADDR_VAR 0 1
49011: PUSH
49012: LD_VAR 0 1
49016: PPUSH
49017: LD_VAR 0 4
49021: PPUSH
49022: CALL_OW 3
49026: ST_TO_ADDR
// end ;
49027: GO 48951
49029: POP
49030: POP
// end ;
49031: LD_VAR 0 2
49035: RET
// export function GetBaseMaterials ( base ) ; begin
49036: LD_INT 0
49038: PPUSH
// result := [ 0 , 0 , 0 ] ;
49039: LD_ADDR_VAR 0 2
49043: PUSH
49044: LD_INT 0
49046: PUSH
49047: LD_INT 0
49049: PUSH
49050: LD_INT 0
49052: PUSH
49053: EMPTY
49054: LIST
49055: LIST
49056: LIST
49057: ST_TO_ADDR
// if not base then
49058: LD_VAR 0 1
49062: NOT
49063: IFFALSE 49067
// exit ;
49065: GO 49116
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
49067: LD_ADDR_VAR 0 2
49071: PUSH
49072: LD_VAR 0 1
49076: PPUSH
49077: LD_INT 1
49079: PPUSH
49080: CALL_OW 275
49084: PUSH
49085: LD_VAR 0 1
49089: PPUSH
49090: LD_INT 2
49092: PPUSH
49093: CALL_OW 275
49097: PUSH
49098: LD_VAR 0 1
49102: PPUSH
49103: LD_INT 3
49105: PPUSH
49106: CALL_OW 275
49110: PUSH
49111: EMPTY
49112: LIST
49113: LIST
49114: LIST
49115: ST_TO_ADDR
// end ;
49116: LD_VAR 0 2
49120: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
49121: LD_INT 0
49123: PPUSH
49124: PPUSH
// result := array ;
49125: LD_ADDR_VAR 0 3
49129: PUSH
49130: LD_VAR 0 1
49134: ST_TO_ADDR
// if size >= result then
49135: LD_VAR 0 2
49139: PUSH
49140: LD_VAR 0 3
49144: GREATEREQUAL
49145: IFFALSE 49149
// exit ;
49147: GO 49199
// if size then
49149: LD_VAR 0 2
49153: IFFALSE 49199
// for i := array downto size do
49155: LD_ADDR_VAR 0 4
49159: PUSH
49160: DOUBLE
49161: LD_VAR 0 1
49165: INC
49166: ST_TO_ADDR
49167: LD_VAR 0 2
49171: PUSH
49172: FOR_DOWNTO
49173: IFFALSE 49197
// result := Delete ( result , result ) ;
49175: LD_ADDR_VAR 0 3
49179: PUSH
49180: LD_VAR 0 3
49184: PPUSH
49185: LD_VAR 0 3
49189: PPUSH
49190: CALL_OW 3
49194: ST_TO_ADDR
49195: GO 49172
49197: POP
49198: POP
// end ;
49199: LD_VAR 0 3
49203: RET
// export function ComExit ( unit ) ; var tmp ; begin
49204: LD_INT 0
49206: PPUSH
49207: PPUSH
// if not IsInUnit ( unit ) then
49208: LD_VAR 0 1
49212: PPUSH
49213: CALL_OW 310
49217: NOT
49218: IFFALSE 49222
// exit ;
49220: GO 49282
// tmp := IsInUnit ( unit ) ;
49222: LD_ADDR_VAR 0 3
49226: PUSH
49227: LD_VAR 0 1
49231: PPUSH
49232: CALL_OW 310
49236: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
49237: LD_VAR 0 3
49241: PPUSH
49242: CALL_OW 247
49246: PUSH
49247: LD_INT 2
49249: EQUAL
49250: IFFALSE 49263
// ComExitVehicle ( unit ) else
49252: LD_VAR 0 1
49256: PPUSH
49257: CALL_OW 121
49261: GO 49272
// ComExitBuilding ( unit ) ;
49263: LD_VAR 0 1
49267: PPUSH
49268: CALL_OW 122
// result := tmp ;
49272: LD_ADDR_VAR 0 2
49276: PUSH
49277: LD_VAR 0 3
49281: ST_TO_ADDR
// end ;
49282: LD_VAR 0 2
49286: RET
// export function ComExitAll ( units ) ; var i ; begin
49287: LD_INT 0
49289: PPUSH
49290: PPUSH
// if not units then
49291: LD_VAR 0 1
49295: NOT
49296: IFFALSE 49300
// exit ;
49298: GO 49326
// for i in units do
49300: LD_ADDR_VAR 0 3
49304: PUSH
49305: LD_VAR 0 1
49309: PUSH
49310: FOR_IN
49311: IFFALSE 49324
// ComExit ( i ) ;
49313: LD_VAR 0 3
49317: PPUSH
49318: CALL 49204 0 1
49322: GO 49310
49324: POP
49325: POP
// end ;
49326: LD_VAR 0 2
49330: RET
// export function ResetHc ; begin
49331: LD_INT 0
49333: PPUSH
// InitHc ;
49334: CALL_OW 19
// hc_importance := 0 ;
49338: LD_ADDR_OWVAR 32
49342: PUSH
49343: LD_INT 0
49345: ST_TO_ADDR
// end ;
49346: LD_VAR 0 1
49350: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
49351: LD_INT 0
49353: PPUSH
49354: PPUSH
49355: PPUSH
// _x := ( x1 + x2 ) div 2 ;
49356: LD_ADDR_VAR 0 6
49360: PUSH
49361: LD_VAR 0 1
49365: PUSH
49366: LD_VAR 0 3
49370: PLUS
49371: PUSH
49372: LD_INT 2
49374: DIV
49375: ST_TO_ADDR
// if _x < 0 then
49376: LD_VAR 0 6
49380: PUSH
49381: LD_INT 0
49383: LESS
49384: IFFALSE 49401
// _x := _x * - 1 ;
49386: LD_ADDR_VAR 0 6
49390: PUSH
49391: LD_VAR 0 6
49395: PUSH
49396: LD_INT 1
49398: NEG
49399: MUL
49400: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49401: LD_ADDR_VAR 0 7
49405: PUSH
49406: LD_VAR 0 2
49410: PUSH
49411: LD_VAR 0 4
49415: PLUS
49416: PUSH
49417: LD_INT 2
49419: DIV
49420: ST_TO_ADDR
// if _y < 0 then
49421: LD_VAR 0 7
49425: PUSH
49426: LD_INT 0
49428: LESS
49429: IFFALSE 49446
// _y := _y * - 1 ;
49431: LD_ADDR_VAR 0 7
49435: PUSH
49436: LD_VAR 0 7
49440: PUSH
49441: LD_INT 1
49443: NEG
49444: MUL
49445: ST_TO_ADDR
// result := [ _x , _y ] ;
49446: LD_ADDR_VAR 0 5
49450: PUSH
49451: LD_VAR 0 6
49455: PUSH
49456: LD_VAR 0 7
49460: PUSH
49461: EMPTY
49462: LIST
49463: LIST
49464: ST_TO_ADDR
// end ;
49465: LD_VAR 0 5
49469: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49470: LD_INT 0
49472: PPUSH
49473: PPUSH
49474: PPUSH
49475: PPUSH
// task := GetTaskList ( unit ) ;
49476: LD_ADDR_VAR 0 7
49480: PUSH
49481: LD_VAR 0 1
49485: PPUSH
49486: CALL_OW 437
49490: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49491: LD_VAR 0 7
49495: NOT
49496: PUSH
49497: LD_VAR 0 1
49501: PPUSH
49502: LD_VAR 0 2
49506: PPUSH
49507: CALL_OW 308
49511: NOT
49512: AND
49513: IFFALSE 49517
// exit ;
49515: GO 49635
// if IsInArea ( unit , area ) then
49517: LD_VAR 0 1
49521: PPUSH
49522: LD_VAR 0 2
49526: PPUSH
49527: CALL_OW 308
49531: IFFALSE 49549
// begin ComMoveToArea ( unit , goAway ) ;
49533: LD_VAR 0 1
49537: PPUSH
49538: LD_VAR 0 3
49542: PPUSH
49543: CALL_OW 113
// exit ;
49547: GO 49635
// end ; if task [ 1 ] [ 1 ] <> M then
49549: LD_VAR 0 7
49553: PUSH
49554: LD_INT 1
49556: ARRAY
49557: PUSH
49558: LD_INT 1
49560: ARRAY
49561: PUSH
49562: LD_STRING M
49564: NONEQUAL
49565: IFFALSE 49569
// exit ;
49567: GO 49635
// x := task [ 1 ] [ 2 ] ;
49569: LD_ADDR_VAR 0 5
49573: PUSH
49574: LD_VAR 0 7
49578: PUSH
49579: LD_INT 1
49581: ARRAY
49582: PUSH
49583: LD_INT 2
49585: ARRAY
49586: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49587: LD_ADDR_VAR 0 6
49591: PUSH
49592: LD_VAR 0 7
49596: PUSH
49597: LD_INT 1
49599: ARRAY
49600: PUSH
49601: LD_INT 3
49603: ARRAY
49604: ST_TO_ADDR
// if InArea ( x , y , area ) then
49605: LD_VAR 0 5
49609: PPUSH
49610: LD_VAR 0 6
49614: PPUSH
49615: LD_VAR 0 2
49619: PPUSH
49620: CALL_OW 309
49624: IFFALSE 49635
// ComStop ( unit ) ;
49626: LD_VAR 0 1
49630: PPUSH
49631: CALL_OW 141
// end ;
49635: LD_VAR 0 4
49639: RET
// export function Abs ( value ) ; begin
49640: LD_INT 0
49642: PPUSH
// result := value ;
49643: LD_ADDR_VAR 0 2
49647: PUSH
49648: LD_VAR 0 1
49652: ST_TO_ADDR
// if value < 0 then
49653: LD_VAR 0 1
49657: PUSH
49658: LD_INT 0
49660: LESS
49661: IFFALSE 49678
// result := value * - 1 ;
49663: LD_ADDR_VAR 0 2
49667: PUSH
49668: LD_VAR 0 1
49672: PUSH
49673: LD_INT 1
49675: NEG
49676: MUL
49677: ST_TO_ADDR
// end ;
49678: LD_VAR 0 2
49682: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49683: LD_INT 0
49685: PPUSH
49686: PPUSH
49687: PPUSH
49688: PPUSH
49689: PPUSH
49690: PPUSH
49691: PPUSH
49692: PPUSH
// if not unit or not building then
49693: LD_VAR 0 1
49697: NOT
49698: PUSH
49699: LD_VAR 0 2
49703: NOT
49704: OR
49705: IFFALSE 49709
// exit ;
49707: GO 49935
// x := GetX ( building ) ;
49709: LD_ADDR_VAR 0 4
49713: PUSH
49714: LD_VAR 0 2
49718: PPUSH
49719: CALL_OW 250
49723: ST_TO_ADDR
// y := GetY ( building ) ;
49724: LD_ADDR_VAR 0 6
49728: PUSH
49729: LD_VAR 0 2
49733: PPUSH
49734: CALL_OW 251
49738: ST_TO_ADDR
// d := GetDir ( building ) ;
49739: LD_ADDR_VAR 0 8
49743: PUSH
49744: LD_VAR 0 2
49748: PPUSH
49749: CALL_OW 254
49753: ST_TO_ADDR
// r := 4 ;
49754: LD_ADDR_VAR 0 9
49758: PUSH
49759: LD_INT 4
49761: ST_TO_ADDR
// for i := 1 to 5 do
49762: LD_ADDR_VAR 0 10
49766: PUSH
49767: DOUBLE
49768: LD_INT 1
49770: DEC
49771: ST_TO_ADDR
49772: LD_INT 5
49774: PUSH
49775: FOR_TO
49776: IFFALSE 49933
// begin _x := ShiftX ( x , d , r + i ) ;
49778: LD_ADDR_VAR 0 5
49782: PUSH
49783: LD_VAR 0 4
49787: PPUSH
49788: LD_VAR 0 8
49792: PPUSH
49793: LD_VAR 0 9
49797: PUSH
49798: LD_VAR 0 10
49802: PLUS
49803: PPUSH
49804: CALL_OW 272
49808: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49809: LD_ADDR_VAR 0 7
49813: PUSH
49814: LD_VAR 0 6
49818: PPUSH
49819: LD_VAR 0 8
49823: PPUSH
49824: LD_VAR 0 9
49828: PUSH
49829: LD_VAR 0 10
49833: PLUS
49834: PPUSH
49835: CALL_OW 273
49839: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49840: LD_VAR 0 5
49844: PPUSH
49845: LD_VAR 0 7
49849: PPUSH
49850: CALL_OW 488
49854: PUSH
49855: LD_VAR 0 5
49859: PPUSH
49860: LD_VAR 0 7
49864: PPUSH
49865: CALL_OW 428
49869: PPUSH
49870: CALL_OW 247
49874: PUSH
49875: LD_INT 3
49877: PUSH
49878: LD_INT 2
49880: PUSH
49881: EMPTY
49882: LIST
49883: LIST
49884: IN
49885: NOT
49886: AND
49887: IFFALSE 49931
// begin ComMoveXY ( unit , _x , _y ) ;
49889: LD_VAR 0 1
49893: PPUSH
49894: LD_VAR 0 5
49898: PPUSH
49899: LD_VAR 0 7
49903: PPUSH
49904: CALL_OW 111
// result := [ _x , _y ] ;
49908: LD_ADDR_VAR 0 3
49912: PUSH
49913: LD_VAR 0 5
49917: PUSH
49918: LD_VAR 0 7
49922: PUSH
49923: EMPTY
49924: LIST
49925: LIST
49926: ST_TO_ADDR
// exit ;
49927: POP
49928: POP
49929: GO 49935
// end ; end ;
49931: GO 49775
49933: POP
49934: POP
// end ;
49935: LD_VAR 0 3
49939: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49940: LD_INT 0
49942: PPUSH
49943: PPUSH
49944: PPUSH
// result := 0 ;
49945: LD_ADDR_VAR 0 3
49949: PUSH
49950: LD_INT 0
49952: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49953: LD_VAR 0 1
49957: PUSH
49958: LD_INT 0
49960: LESS
49961: PUSH
49962: LD_VAR 0 1
49966: PUSH
49967: LD_INT 8
49969: GREATER
49970: OR
49971: PUSH
49972: LD_VAR 0 2
49976: PUSH
49977: LD_INT 0
49979: LESS
49980: OR
49981: PUSH
49982: LD_VAR 0 2
49986: PUSH
49987: LD_INT 8
49989: GREATER
49990: OR
49991: IFFALSE 49995
// exit ;
49993: GO 50070
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49995: LD_ADDR_VAR 0 4
49999: PUSH
50000: LD_INT 22
50002: PUSH
50003: LD_VAR 0 2
50007: PUSH
50008: EMPTY
50009: LIST
50010: LIST
50011: PPUSH
50012: CALL_OW 69
50016: PUSH
50017: FOR_IN
50018: IFFALSE 50068
// begin un := UnitShoot ( i ) ;
50020: LD_ADDR_VAR 0 5
50024: PUSH
50025: LD_VAR 0 4
50029: PPUSH
50030: CALL_OW 504
50034: ST_TO_ADDR
// if GetSide ( un ) = side1 then
50035: LD_VAR 0 5
50039: PPUSH
50040: CALL_OW 255
50044: PUSH
50045: LD_VAR 0 1
50049: EQUAL
50050: IFFALSE 50066
// begin result := un ;
50052: LD_ADDR_VAR 0 3
50056: PUSH
50057: LD_VAR 0 5
50061: ST_TO_ADDR
// exit ;
50062: POP
50063: POP
50064: GO 50070
// end ; end ;
50066: GO 50017
50068: POP
50069: POP
// end ;
50070: LD_VAR 0 3
50074: RET
// export function GetCargoBay ( units ) ; begin
50075: LD_INT 0
50077: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
50078: LD_ADDR_VAR 0 2
50082: PUSH
50083: LD_VAR 0 1
50087: PPUSH
50088: LD_INT 2
50090: PUSH
50091: LD_INT 34
50093: PUSH
50094: LD_INT 12
50096: PUSH
50097: EMPTY
50098: LIST
50099: LIST
50100: PUSH
50101: LD_INT 34
50103: PUSH
50104: LD_INT 51
50106: PUSH
50107: EMPTY
50108: LIST
50109: LIST
50110: PUSH
50111: LD_INT 34
50113: PUSH
50114: LD_INT 32
50116: PUSH
50117: EMPTY
50118: LIST
50119: LIST
50120: PUSH
50121: LD_INT 34
50123: PUSH
50124: LD_INT 89
50126: PUSH
50127: EMPTY
50128: LIST
50129: LIST
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: LIST
50135: LIST
50136: LIST
50137: PPUSH
50138: CALL_OW 72
50142: ST_TO_ADDR
// end ;
50143: LD_VAR 0 2
50147: RET
// export function Negate ( value ) ; begin
50148: LD_INT 0
50150: PPUSH
// result := not value ;
50151: LD_ADDR_VAR 0 2
50155: PUSH
50156: LD_VAR 0 1
50160: NOT
50161: ST_TO_ADDR
// end ;
50162: LD_VAR 0 2
50166: RET
// export function Inc ( value ) ; begin
50167: LD_INT 0
50169: PPUSH
// result := value + 1 ;
50170: LD_ADDR_VAR 0 2
50174: PUSH
50175: LD_VAR 0 1
50179: PUSH
50180: LD_INT 1
50182: PLUS
50183: ST_TO_ADDR
// end ;
50184: LD_VAR 0 2
50188: RET
// export function Dec ( value ) ; begin
50189: LD_INT 0
50191: PPUSH
// result := value - 1 ;
50192: LD_ADDR_VAR 0 2
50196: PUSH
50197: LD_VAR 0 1
50201: PUSH
50202: LD_INT 1
50204: MINUS
50205: ST_TO_ADDR
// end ;
50206: LD_VAR 0 2
50210: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
50211: LD_INT 0
50213: PPUSH
50214: PPUSH
50215: PPUSH
50216: PPUSH
50217: PPUSH
50218: PPUSH
50219: PPUSH
50220: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
50221: LD_VAR 0 1
50225: PPUSH
50226: LD_VAR 0 2
50230: PPUSH
50231: CALL_OW 488
50235: NOT
50236: PUSH
50237: LD_VAR 0 3
50241: PPUSH
50242: LD_VAR 0 4
50246: PPUSH
50247: CALL_OW 488
50251: NOT
50252: OR
50253: IFFALSE 50266
// begin result := - 1 ;
50255: LD_ADDR_VAR 0 5
50259: PUSH
50260: LD_INT 1
50262: NEG
50263: ST_TO_ADDR
// exit ;
50264: GO 50501
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
50266: LD_ADDR_VAR 0 12
50270: PUSH
50271: LD_VAR 0 1
50275: PPUSH
50276: LD_VAR 0 2
50280: PPUSH
50281: LD_VAR 0 3
50285: PPUSH
50286: LD_VAR 0 4
50290: PPUSH
50291: CALL 49351 0 4
50295: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
50296: LD_ADDR_VAR 0 11
50300: PUSH
50301: LD_VAR 0 1
50305: PPUSH
50306: LD_VAR 0 2
50310: PPUSH
50311: LD_VAR 0 12
50315: PUSH
50316: LD_INT 1
50318: ARRAY
50319: PPUSH
50320: LD_VAR 0 12
50324: PUSH
50325: LD_INT 2
50327: ARRAY
50328: PPUSH
50329: CALL_OW 298
50333: ST_TO_ADDR
// distance := 9999 ;
50334: LD_ADDR_VAR 0 10
50338: PUSH
50339: LD_INT 9999
50341: ST_TO_ADDR
// for i := 0 to 5 do
50342: LD_ADDR_VAR 0 6
50346: PUSH
50347: DOUBLE
50348: LD_INT 0
50350: DEC
50351: ST_TO_ADDR
50352: LD_INT 5
50354: PUSH
50355: FOR_TO
50356: IFFALSE 50499
// begin _x := ShiftX ( x1 , i , centerDist ) ;
50358: LD_ADDR_VAR 0 7
50362: PUSH
50363: LD_VAR 0 1
50367: PPUSH
50368: LD_VAR 0 6
50372: PPUSH
50373: LD_VAR 0 11
50377: PPUSH
50378: CALL_OW 272
50382: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50383: LD_ADDR_VAR 0 8
50387: PUSH
50388: LD_VAR 0 2
50392: PPUSH
50393: LD_VAR 0 6
50397: PPUSH
50398: LD_VAR 0 11
50402: PPUSH
50403: CALL_OW 273
50407: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50408: LD_VAR 0 7
50412: PPUSH
50413: LD_VAR 0 8
50417: PPUSH
50418: CALL_OW 488
50422: NOT
50423: IFFALSE 50427
// continue ;
50425: GO 50355
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50427: LD_ADDR_VAR 0 9
50431: PUSH
50432: LD_VAR 0 12
50436: PUSH
50437: LD_INT 1
50439: ARRAY
50440: PPUSH
50441: LD_VAR 0 12
50445: PUSH
50446: LD_INT 2
50448: ARRAY
50449: PPUSH
50450: LD_VAR 0 7
50454: PPUSH
50455: LD_VAR 0 8
50459: PPUSH
50460: CALL_OW 298
50464: ST_TO_ADDR
// if tmp < distance then
50465: LD_VAR 0 9
50469: PUSH
50470: LD_VAR 0 10
50474: LESS
50475: IFFALSE 50497
// begin result := i ;
50477: LD_ADDR_VAR 0 5
50481: PUSH
50482: LD_VAR 0 6
50486: ST_TO_ADDR
// distance := tmp ;
50487: LD_ADDR_VAR 0 10
50491: PUSH
50492: LD_VAR 0 9
50496: ST_TO_ADDR
// end ; end ;
50497: GO 50355
50499: POP
50500: POP
// end ;
50501: LD_VAR 0 5
50505: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50506: LD_INT 0
50508: PPUSH
50509: PPUSH
// if not driver or not IsInUnit ( driver ) then
50510: LD_VAR 0 1
50514: NOT
50515: PUSH
50516: LD_VAR 0 1
50520: PPUSH
50521: CALL_OW 310
50525: NOT
50526: OR
50527: IFFALSE 50531
// exit ;
50529: GO 50621
// vehicle := IsInUnit ( driver ) ;
50531: LD_ADDR_VAR 0 3
50535: PUSH
50536: LD_VAR 0 1
50540: PPUSH
50541: CALL_OW 310
50545: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50546: LD_VAR 0 1
50550: PPUSH
50551: LD_STRING \
50553: PUSH
50554: LD_INT 0
50556: PUSH
50557: LD_INT 0
50559: PUSH
50560: LD_INT 0
50562: PUSH
50563: LD_INT 0
50565: PUSH
50566: LD_INT 0
50568: PUSH
50569: LD_INT 0
50571: PUSH
50572: EMPTY
50573: LIST
50574: LIST
50575: LIST
50576: LIST
50577: LIST
50578: LIST
50579: LIST
50580: PUSH
50581: LD_STRING E
50583: PUSH
50584: LD_INT 0
50586: PUSH
50587: LD_INT 0
50589: PUSH
50590: LD_VAR 0 3
50594: PUSH
50595: LD_INT 0
50597: PUSH
50598: LD_INT 0
50600: PUSH
50601: LD_INT 0
50603: PUSH
50604: EMPTY
50605: LIST
50606: LIST
50607: LIST
50608: LIST
50609: LIST
50610: LIST
50611: LIST
50612: PUSH
50613: EMPTY
50614: LIST
50615: LIST
50616: PPUSH
50617: CALL_OW 446
// end ;
50621: LD_VAR 0 2
50625: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50626: LD_INT 0
50628: PPUSH
50629: PPUSH
// if not driver or not IsInUnit ( driver ) then
50630: LD_VAR 0 1
50634: NOT
50635: PUSH
50636: LD_VAR 0 1
50640: PPUSH
50641: CALL_OW 310
50645: NOT
50646: OR
50647: IFFALSE 50651
// exit ;
50649: GO 50741
// vehicle := IsInUnit ( driver ) ;
50651: LD_ADDR_VAR 0 3
50655: PUSH
50656: LD_VAR 0 1
50660: PPUSH
50661: CALL_OW 310
50665: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50666: LD_VAR 0 1
50670: PPUSH
50671: LD_STRING \
50673: PUSH
50674: LD_INT 0
50676: PUSH
50677: LD_INT 0
50679: PUSH
50680: LD_INT 0
50682: PUSH
50683: LD_INT 0
50685: PUSH
50686: LD_INT 0
50688: PUSH
50689: LD_INT 0
50691: PUSH
50692: EMPTY
50693: LIST
50694: LIST
50695: LIST
50696: LIST
50697: LIST
50698: LIST
50699: LIST
50700: PUSH
50701: LD_STRING E
50703: PUSH
50704: LD_INT 0
50706: PUSH
50707: LD_INT 0
50709: PUSH
50710: LD_VAR 0 3
50714: PUSH
50715: LD_INT 0
50717: PUSH
50718: LD_INT 0
50720: PUSH
50721: LD_INT 0
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: LIST
50728: LIST
50729: LIST
50730: LIST
50731: LIST
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: PPUSH
50737: CALL_OW 447
// end ;
50741: LD_VAR 0 2
50745: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50746: LD_INT 0
50748: PPUSH
50749: PPUSH
50750: PPUSH
// tmp := [ ] ;
50751: LD_ADDR_VAR 0 5
50755: PUSH
50756: EMPTY
50757: ST_TO_ADDR
// for i in units do
50758: LD_ADDR_VAR 0 4
50762: PUSH
50763: LD_VAR 0 1
50767: PUSH
50768: FOR_IN
50769: IFFALSE 50807
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50771: LD_ADDR_VAR 0 5
50775: PUSH
50776: LD_VAR 0 5
50780: PPUSH
50781: LD_VAR 0 5
50785: PUSH
50786: LD_INT 1
50788: PLUS
50789: PPUSH
50790: LD_VAR 0 4
50794: PPUSH
50795: CALL_OW 256
50799: PPUSH
50800: CALL_OW 2
50804: ST_TO_ADDR
50805: GO 50768
50807: POP
50808: POP
// if not tmp then
50809: LD_VAR 0 5
50813: NOT
50814: IFFALSE 50818
// exit ;
50816: GO 50866
// if asc then
50818: LD_VAR 0 2
50822: IFFALSE 50846
// result := SortListByListAsc ( units , tmp ) else
50824: LD_ADDR_VAR 0 3
50828: PUSH
50829: LD_VAR 0 1
50833: PPUSH
50834: LD_VAR 0 5
50838: PPUSH
50839: CALL_OW 76
50843: ST_TO_ADDR
50844: GO 50866
// result := SortListByListDesc ( units , tmp ) ;
50846: LD_ADDR_VAR 0 3
50850: PUSH
50851: LD_VAR 0 1
50855: PPUSH
50856: LD_VAR 0 5
50860: PPUSH
50861: CALL_OW 77
50865: ST_TO_ADDR
// end ;
50866: LD_VAR 0 3
50870: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50871: LD_INT 0
50873: PPUSH
50874: PPUSH
// task := GetTaskList ( mech ) ;
50875: LD_ADDR_VAR 0 4
50879: PUSH
50880: LD_VAR 0 1
50884: PPUSH
50885: CALL_OW 437
50889: ST_TO_ADDR
// if not task then
50890: LD_VAR 0 4
50894: NOT
50895: IFFALSE 50899
// exit ;
50897: GO 50941
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50899: LD_ADDR_VAR 0 3
50903: PUSH
50904: LD_VAR 0 4
50908: PUSH
50909: LD_INT 1
50911: ARRAY
50912: PUSH
50913: LD_INT 1
50915: ARRAY
50916: PUSH
50917: LD_STRING r
50919: EQUAL
50920: PUSH
50921: LD_VAR 0 4
50925: PUSH
50926: LD_INT 1
50928: ARRAY
50929: PUSH
50930: LD_INT 4
50932: ARRAY
50933: PUSH
50934: LD_VAR 0 2
50938: EQUAL
50939: AND
50940: ST_TO_ADDR
// end ;
50941: LD_VAR 0 3
50945: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50946: LD_INT 0
50948: PPUSH
// SetDir ( unit , d ) ;
50949: LD_VAR 0 1
50953: PPUSH
50954: LD_VAR 0 4
50958: PPUSH
50959: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50963: LD_VAR 0 1
50967: PPUSH
50968: LD_VAR 0 2
50972: PPUSH
50973: LD_VAR 0 3
50977: PPUSH
50978: LD_VAR 0 5
50982: PPUSH
50983: CALL_OW 48
// end ;
50987: LD_VAR 0 6
50991: RET
// export function ToNaturalNumber ( number ) ; begin
50992: LD_INT 0
50994: PPUSH
// result := number div 1 ;
50995: LD_ADDR_VAR 0 2
50999: PUSH
51000: LD_VAR 0 1
51004: PUSH
51005: LD_INT 1
51007: DIV
51008: ST_TO_ADDR
// if number < 0 then
51009: LD_VAR 0 1
51013: PUSH
51014: LD_INT 0
51016: LESS
51017: IFFALSE 51027
// result := 0 ;
51019: LD_ADDR_VAR 0 2
51023: PUSH
51024: LD_INT 0
51026: ST_TO_ADDR
// end ;
51027: LD_VAR 0 2
51031: RET
// export function SortByClass ( units , class ) ; var un ; begin
51032: LD_INT 0
51034: PPUSH
51035: PPUSH
// if not units or not class then
51036: LD_VAR 0 1
51040: NOT
51041: PUSH
51042: LD_VAR 0 2
51046: NOT
51047: OR
51048: IFFALSE 51052
// exit ;
51050: GO 51147
// result := [ ] ;
51052: LD_ADDR_VAR 0 3
51056: PUSH
51057: EMPTY
51058: ST_TO_ADDR
// for un in units do
51059: LD_ADDR_VAR 0 4
51063: PUSH
51064: LD_VAR 0 1
51068: PUSH
51069: FOR_IN
51070: IFFALSE 51145
// if GetClass ( un ) = class then
51072: LD_VAR 0 4
51076: PPUSH
51077: CALL_OW 257
51081: PUSH
51082: LD_VAR 0 2
51086: EQUAL
51087: IFFALSE 51114
// result := Insert ( result , 1 , un ) else
51089: LD_ADDR_VAR 0 3
51093: PUSH
51094: LD_VAR 0 3
51098: PPUSH
51099: LD_INT 1
51101: PPUSH
51102: LD_VAR 0 4
51106: PPUSH
51107: CALL_OW 2
51111: ST_TO_ADDR
51112: GO 51143
// result := Replace ( result , result + 1 , un ) ;
51114: LD_ADDR_VAR 0 3
51118: PUSH
51119: LD_VAR 0 3
51123: PPUSH
51124: LD_VAR 0 3
51128: PUSH
51129: LD_INT 1
51131: PLUS
51132: PPUSH
51133: LD_VAR 0 4
51137: PPUSH
51138: CALL_OW 1
51142: ST_TO_ADDR
51143: GO 51069
51145: POP
51146: POP
// end ;
51147: LD_VAR 0 3
51151: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
51152: LD_INT 0
51154: PPUSH
51155: PPUSH
51156: PPUSH
51157: PPUSH
51158: PPUSH
51159: PPUSH
51160: PPUSH
// result := [ ] ;
51161: LD_ADDR_VAR 0 4
51165: PUSH
51166: EMPTY
51167: ST_TO_ADDR
// if x - r < 0 then
51168: LD_VAR 0 1
51172: PUSH
51173: LD_VAR 0 3
51177: MINUS
51178: PUSH
51179: LD_INT 0
51181: LESS
51182: IFFALSE 51194
// min_x := 0 else
51184: LD_ADDR_VAR 0 8
51188: PUSH
51189: LD_INT 0
51191: ST_TO_ADDR
51192: GO 51210
// min_x := x - r ;
51194: LD_ADDR_VAR 0 8
51198: PUSH
51199: LD_VAR 0 1
51203: PUSH
51204: LD_VAR 0 3
51208: MINUS
51209: ST_TO_ADDR
// if y - r < 0 then
51210: LD_VAR 0 2
51214: PUSH
51215: LD_VAR 0 3
51219: MINUS
51220: PUSH
51221: LD_INT 0
51223: LESS
51224: IFFALSE 51236
// min_y := 0 else
51226: LD_ADDR_VAR 0 7
51230: PUSH
51231: LD_INT 0
51233: ST_TO_ADDR
51234: GO 51252
// min_y := y - r ;
51236: LD_ADDR_VAR 0 7
51240: PUSH
51241: LD_VAR 0 2
51245: PUSH
51246: LD_VAR 0 3
51250: MINUS
51251: ST_TO_ADDR
// max_x := x + r ;
51252: LD_ADDR_VAR 0 9
51256: PUSH
51257: LD_VAR 0 1
51261: PUSH
51262: LD_VAR 0 3
51266: PLUS
51267: ST_TO_ADDR
// max_y := y + r ;
51268: LD_ADDR_VAR 0 10
51272: PUSH
51273: LD_VAR 0 2
51277: PUSH
51278: LD_VAR 0 3
51282: PLUS
51283: ST_TO_ADDR
// for _x = min_x to max_x do
51284: LD_ADDR_VAR 0 5
51288: PUSH
51289: DOUBLE
51290: LD_VAR 0 8
51294: DEC
51295: ST_TO_ADDR
51296: LD_VAR 0 9
51300: PUSH
51301: FOR_TO
51302: IFFALSE 51403
// for _y = min_y to max_y do
51304: LD_ADDR_VAR 0 6
51308: PUSH
51309: DOUBLE
51310: LD_VAR 0 7
51314: DEC
51315: ST_TO_ADDR
51316: LD_VAR 0 10
51320: PUSH
51321: FOR_TO
51322: IFFALSE 51399
// begin if not ValidHex ( _x , _y ) then
51324: LD_VAR 0 5
51328: PPUSH
51329: LD_VAR 0 6
51333: PPUSH
51334: CALL_OW 488
51338: NOT
51339: IFFALSE 51343
// continue ;
51341: GO 51321
// if GetResourceTypeXY ( _x , _y ) then
51343: LD_VAR 0 5
51347: PPUSH
51348: LD_VAR 0 6
51352: PPUSH
51353: CALL_OW 283
51357: IFFALSE 51397
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
51359: LD_ADDR_VAR 0 4
51363: PUSH
51364: LD_VAR 0 4
51368: PPUSH
51369: LD_VAR 0 4
51373: PUSH
51374: LD_INT 1
51376: PLUS
51377: PPUSH
51378: LD_VAR 0 5
51382: PUSH
51383: LD_VAR 0 6
51387: PUSH
51388: EMPTY
51389: LIST
51390: LIST
51391: PPUSH
51392: CALL_OW 1
51396: ST_TO_ADDR
// end ;
51397: GO 51321
51399: POP
51400: POP
51401: GO 51301
51403: POP
51404: POP
// end ;
51405: LD_VAR 0 4
51409: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51410: LD_INT 0
51412: PPUSH
51413: PPUSH
51414: PPUSH
51415: PPUSH
51416: PPUSH
51417: PPUSH
51418: PPUSH
51419: PPUSH
// if not units then
51420: LD_VAR 0 1
51424: NOT
51425: IFFALSE 51429
// exit ;
51427: GO 51953
// result := UnitFilter ( units , [ f_ok ] ) ;
51429: LD_ADDR_VAR 0 3
51433: PUSH
51434: LD_VAR 0 1
51438: PPUSH
51439: LD_INT 50
51441: PUSH
51442: EMPTY
51443: LIST
51444: PPUSH
51445: CALL_OW 72
51449: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51450: LD_ADDR_VAR 0 8
51454: PUSH
51455: LD_VAR 0 1
51459: PUSH
51460: LD_INT 1
51462: ARRAY
51463: PPUSH
51464: CALL_OW 255
51468: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51469: LD_ADDR_VAR 0 10
51473: PUSH
51474: LD_INT 29
51476: PUSH
51477: LD_INT 91
51479: PUSH
51480: LD_INT 49
51482: PUSH
51483: EMPTY
51484: LIST
51485: LIST
51486: LIST
51487: ST_TO_ADDR
// if not result then
51488: LD_VAR 0 3
51492: NOT
51493: IFFALSE 51497
// exit ;
51495: GO 51953
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51497: LD_ADDR_VAR 0 5
51501: PUSH
51502: LD_INT 81
51504: PUSH
51505: LD_VAR 0 8
51509: PUSH
51510: EMPTY
51511: LIST
51512: LIST
51513: PPUSH
51514: CALL_OW 69
51518: ST_TO_ADDR
// for i in result do
51519: LD_ADDR_VAR 0 4
51523: PUSH
51524: LD_VAR 0 3
51528: PUSH
51529: FOR_IN
51530: IFFALSE 51951
// begin tag := GetTag ( i ) + 1 ;
51532: LD_ADDR_VAR 0 9
51536: PUSH
51537: LD_VAR 0 4
51541: PPUSH
51542: CALL_OW 110
51546: PUSH
51547: LD_INT 1
51549: PLUS
51550: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51551: LD_ADDR_VAR 0 7
51555: PUSH
51556: LD_VAR 0 4
51560: PPUSH
51561: CALL_OW 250
51565: PPUSH
51566: LD_VAR 0 4
51570: PPUSH
51571: CALL_OW 251
51575: PPUSH
51576: LD_INT 6
51578: PPUSH
51579: CALL 51152 0 3
51583: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51584: LD_VAR 0 4
51588: PPUSH
51589: CALL_OW 247
51593: PUSH
51594: LD_INT 2
51596: EQUAL
51597: PUSH
51598: LD_VAR 0 7
51602: AND
51603: PUSH
51604: LD_VAR 0 4
51608: PPUSH
51609: CALL_OW 264
51613: PUSH
51614: LD_VAR 0 10
51618: IN
51619: NOT
51620: AND
51621: IFFALSE 51660
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51623: LD_VAR 0 4
51627: PPUSH
51628: LD_VAR 0 7
51632: PUSH
51633: LD_INT 1
51635: ARRAY
51636: PUSH
51637: LD_INT 1
51639: ARRAY
51640: PPUSH
51641: LD_VAR 0 7
51645: PUSH
51646: LD_INT 1
51648: ARRAY
51649: PUSH
51650: LD_INT 2
51652: ARRAY
51653: PPUSH
51654: CALL_OW 116
51658: GO 51949
// if path > tag then
51660: LD_VAR 0 2
51664: PUSH
51665: LD_VAR 0 9
51669: GREATER
51670: IFFALSE 51878
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51672: LD_ADDR_VAR 0 6
51676: PUSH
51677: LD_VAR 0 5
51681: PPUSH
51682: LD_INT 91
51684: PUSH
51685: LD_VAR 0 4
51689: PUSH
51690: LD_INT 8
51692: PUSH
51693: EMPTY
51694: LIST
51695: LIST
51696: LIST
51697: PPUSH
51698: CALL_OW 72
51702: ST_TO_ADDR
// if nearEnemy then
51703: LD_VAR 0 6
51707: IFFALSE 51776
// begin if GetWeapon ( i ) = ru_time_lapser then
51709: LD_VAR 0 4
51713: PPUSH
51714: CALL_OW 264
51718: PUSH
51719: LD_INT 49
51721: EQUAL
51722: IFFALSE 51750
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51724: LD_VAR 0 4
51728: PPUSH
51729: LD_VAR 0 6
51733: PPUSH
51734: LD_VAR 0 4
51738: PPUSH
51739: CALL_OW 74
51743: PPUSH
51744: CALL_OW 112
51748: GO 51774
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51750: LD_VAR 0 4
51754: PPUSH
51755: LD_VAR 0 6
51759: PPUSH
51760: LD_VAR 0 4
51764: PPUSH
51765: CALL_OW 74
51769: PPUSH
51770: CALL 52878 0 2
// end else
51774: GO 51876
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51776: LD_VAR 0 4
51780: PPUSH
51781: LD_VAR 0 2
51785: PUSH
51786: LD_VAR 0 9
51790: ARRAY
51791: PUSH
51792: LD_INT 1
51794: ARRAY
51795: PPUSH
51796: LD_VAR 0 2
51800: PUSH
51801: LD_VAR 0 9
51805: ARRAY
51806: PUSH
51807: LD_INT 2
51809: ARRAY
51810: PPUSH
51811: CALL_OW 297
51815: PUSH
51816: LD_INT 6
51818: GREATER
51819: IFFALSE 51862
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51821: LD_VAR 0 4
51825: PPUSH
51826: LD_VAR 0 2
51830: PUSH
51831: LD_VAR 0 9
51835: ARRAY
51836: PUSH
51837: LD_INT 1
51839: ARRAY
51840: PPUSH
51841: LD_VAR 0 2
51845: PUSH
51846: LD_VAR 0 9
51850: ARRAY
51851: PUSH
51852: LD_INT 2
51854: ARRAY
51855: PPUSH
51856: CALL_OW 114
51860: GO 51876
// SetTag ( i , tag ) ;
51862: LD_VAR 0 4
51866: PPUSH
51867: LD_VAR 0 9
51871: PPUSH
51872: CALL_OW 109
// end else
51876: GO 51949
// if enemy then
51878: LD_VAR 0 5
51882: IFFALSE 51949
// begin if GetWeapon ( i ) = ru_time_lapser then
51884: LD_VAR 0 4
51888: PPUSH
51889: CALL_OW 264
51893: PUSH
51894: LD_INT 49
51896: EQUAL
51897: IFFALSE 51925
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51899: LD_VAR 0 4
51903: PPUSH
51904: LD_VAR 0 5
51908: PPUSH
51909: LD_VAR 0 4
51913: PPUSH
51914: CALL_OW 74
51918: PPUSH
51919: CALL_OW 112
51923: GO 51949
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51925: LD_VAR 0 4
51929: PPUSH
51930: LD_VAR 0 5
51934: PPUSH
51935: LD_VAR 0 4
51939: PPUSH
51940: CALL_OW 74
51944: PPUSH
51945: CALL 52878 0 2
// end ; end ;
51949: GO 51529
51951: POP
51952: POP
// end ;
51953: LD_VAR 0 3
51957: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51958: LD_INT 0
51960: PPUSH
51961: PPUSH
51962: PPUSH
// if not unit or IsInUnit ( unit ) then
51963: LD_VAR 0 1
51967: NOT
51968: PUSH
51969: LD_VAR 0 1
51973: PPUSH
51974: CALL_OW 310
51978: OR
51979: IFFALSE 51983
// exit ;
51981: GO 52074
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51983: LD_ADDR_VAR 0 4
51987: PUSH
51988: LD_VAR 0 1
51992: PPUSH
51993: CALL_OW 250
51997: PPUSH
51998: LD_VAR 0 2
52002: PPUSH
52003: LD_INT 1
52005: PPUSH
52006: CALL_OW 272
52010: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
52011: LD_ADDR_VAR 0 5
52015: PUSH
52016: LD_VAR 0 1
52020: PPUSH
52021: CALL_OW 251
52025: PPUSH
52026: LD_VAR 0 2
52030: PPUSH
52031: LD_INT 1
52033: PPUSH
52034: CALL_OW 273
52038: ST_TO_ADDR
// if ValidHex ( x , y ) then
52039: LD_VAR 0 4
52043: PPUSH
52044: LD_VAR 0 5
52048: PPUSH
52049: CALL_OW 488
52053: IFFALSE 52074
// ComTurnXY ( unit , x , y ) ;
52055: LD_VAR 0 1
52059: PPUSH
52060: LD_VAR 0 4
52064: PPUSH
52065: LD_VAR 0 5
52069: PPUSH
52070: CALL_OW 118
// end ;
52074: LD_VAR 0 3
52078: RET
// export function SeeUnits ( side , units ) ; var i ; begin
52079: LD_INT 0
52081: PPUSH
52082: PPUSH
// result := false ;
52083: LD_ADDR_VAR 0 3
52087: PUSH
52088: LD_INT 0
52090: ST_TO_ADDR
// if not units then
52091: LD_VAR 0 2
52095: NOT
52096: IFFALSE 52100
// exit ;
52098: GO 52145
// for i in units do
52100: LD_ADDR_VAR 0 4
52104: PUSH
52105: LD_VAR 0 2
52109: PUSH
52110: FOR_IN
52111: IFFALSE 52143
// if See ( side , i ) then
52113: LD_VAR 0 1
52117: PPUSH
52118: LD_VAR 0 4
52122: PPUSH
52123: CALL_OW 292
52127: IFFALSE 52141
// begin result := true ;
52129: LD_ADDR_VAR 0 3
52133: PUSH
52134: LD_INT 1
52136: ST_TO_ADDR
// exit ;
52137: POP
52138: POP
52139: GO 52145
// end ;
52141: GO 52110
52143: POP
52144: POP
// end ;
52145: LD_VAR 0 3
52149: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
52150: LD_INT 0
52152: PPUSH
52153: PPUSH
52154: PPUSH
52155: PPUSH
// if not unit or not points then
52156: LD_VAR 0 1
52160: NOT
52161: PUSH
52162: LD_VAR 0 2
52166: NOT
52167: OR
52168: IFFALSE 52172
// exit ;
52170: GO 52262
// dist := 99999 ;
52172: LD_ADDR_VAR 0 5
52176: PUSH
52177: LD_INT 99999
52179: ST_TO_ADDR
// for i in points do
52180: LD_ADDR_VAR 0 4
52184: PUSH
52185: LD_VAR 0 2
52189: PUSH
52190: FOR_IN
52191: IFFALSE 52260
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
52193: LD_ADDR_VAR 0 6
52197: PUSH
52198: LD_VAR 0 1
52202: PPUSH
52203: LD_VAR 0 4
52207: PUSH
52208: LD_INT 1
52210: ARRAY
52211: PPUSH
52212: LD_VAR 0 4
52216: PUSH
52217: LD_INT 2
52219: ARRAY
52220: PPUSH
52221: CALL_OW 297
52225: ST_TO_ADDR
// if tmpDist < dist then
52226: LD_VAR 0 6
52230: PUSH
52231: LD_VAR 0 5
52235: LESS
52236: IFFALSE 52258
// begin result := i ;
52238: LD_ADDR_VAR 0 3
52242: PUSH
52243: LD_VAR 0 4
52247: ST_TO_ADDR
// dist := tmpDist ;
52248: LD_ADDR_VAR 0 5
52252: PUSH
52253: LD_VAR 0 6
52257: ST_TO_ADDR
// end ; end ;
52258: GO 52190
52260: POP
52261: POP
// end ;
52262: LD_VAR 0 3
52266: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
52267: LD_INT 0
52269: PPUSH
// uc_side := side ;
52270: LD_ADDR_OWVAR 20
52274: PUSH
52275: LD_VAR 0 1
52279: ST_TO_ADDR
// uc_nation := 3 ;
52280: LD_ADDR_OWVAR 21
52284: PUSH
52285: LD_INT 3
52287: ST_TO_ADDR
// vc_chassis := 25 ;
52288: LD_ADDR_OWVAR 37
52292: PUSH
52293: LD_INT 25
52295: ST_TO_ADDR
// vc_engine := engine_siberite ;
52296: LD_ADDR_OWVAR 39
52300: PUSH
52301: LD_INT 3
52303: ST_TO_ADDR
// vc_control := control_computer ;
52304: LD_ADDR_OWVAR 38
52308: PUSH
52309: LD_INT 3
52311: ST_TO_ADDR
// vc_weapon := 59 ;
52312: LD_ADDR_OWVAR 40
52316: PUSH
52317: LD_INT 59
52319: ST_TO_ADDR
// result := CreateVehicle ;
52320: LD_ADDR_VAR 0 5
52324: PUSH
52325: CALL_OW 45
52329: ST_TO_ADDR
// SetDir ( result , d ) ;
52330: LD_VAR 0 5
52334: PPUSH
52335: LD_VAR 0 4
52339: PPUSH
52340: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
52344: LD_VAR 0 5
52348: PPUSH
52349: LD_VAR 0 2
52353: PPUSH
52354: LD_VAR 0 3
52358: PPUSH
52359: LD_INT 0
52361: PPUSH
52362: CALL_OW 48
// end ;
52366: LD_VAR 0 5
52370: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
52371: LD_INT 0
52373: PPUSH
52374: PPUSH
52375: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
52376: LD_ADDR_VAR 0 2
52380: PUSH
52381: LD_INT 0
52383: PUSH
52384: LD_INT 0
52386: PUSH
52387: LD_INT 0
52389: PUSH
52390: LD_INT 0
52392: PUSH
52393: EMPTY
52394: LIST
52395: LIST
52396: LIST
52397: LIST
52398: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52399: LD_VAR 0 1
52403: NOT
52404: PUSH
52405: LD_VAR 0 1
52409: PPUSH
52410: CALL_OW 264
52414: PUSH
52415: LD_INT 12
52417: PUSH
52418: LD_INT 51
52420: PUSH
52421: LD_INT 32
52423: PUSH
52424: LD_INT 89
52426: PUSH
52427: EMPTY
52428: LIST
52429: LIST
52430: LIST
52431: LIST
52432: IN
52433: NOT
52434: OR
52435: IFFALSE 52439
// exit ;
52437: GO 52537
// for i := 1 to 3 do
52439: LD_ADDR_VAR 0 3
52443: PUSH
52444: DOUBLE
52445: LD_INT 1
52447: DEC
52448: ST_TO_ADDR
52449: LD_INT 3
52451: PUSH
52452: FOR_TO
52453: IFFALSE 52535
// begin tmp := GetCargo ( cargo , i ) ;
52455: LD_ADDR_VAR 0 4
52459: PUSH
52460: LD_VAR 0 1
52464: PPUSH
52465: LD_VAR 0 3
52469: PPUSH
52470: CALL_OW 289
52474: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52475: LD_ADDR_VAR 0 2
52479: PUSH
52480: LD_VAR 0 2
52484: PPUSH
52485: LD_VAR 0 3
52489: PPUSH
52490: LD_VAR 0 4
52494: PPUSH
52495: CALL_OW 1
52499: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52500: LD_ADDR_VAR 0 2
52504: PUSH
52505: LD_VAR 0 2
52509: PPUSH
52510: LD_INT 4
52512: PPUSH
52513: LD_VAR 0 2
52517: PUSH
52518: LD_INT 4
52520: ARRAY
52521: PUSH
52522: LD_VAR 0 4
52526: PLUS
52527: PPUSH
52528: CALL_OW 1
52532: ST_TO_ADDR
// end ;
52533: GO 52452
52535: POP
52536: POP
// end ;
52537: LD_VAR 0 2
52541: RET
// export function Length ( array ) ; begin
52542: LD_INT 0
52544: PPUSH
// result := array + 0 ;
52545: LD_ADDR_VAR 0 2
52549: PUSH
52550: LD_VAR 0 1
52554: PUSH
52555: LD_INT 0
52557: PLUS
52558: ST_TO_ADDR
// end ;
52559: LD_VAR 0 2
52563: RET
// export function PrepareArray ( array ) ; begin
52564: LD_INT 0
52566: PPUSH
// result := array diff 0 ;
52567: LD_ADDR_VAR 0 2
52571: PUSH
52572: LD_VAR 0 1
52576: PUSH
52577: LD_INT 0
52579: DIFF
52580: ST_TO_ADDR
// if not result [ 1 ] then
52581: LD_VAR 0 2
52585: PUSH
52586: LD_INT 1
52588: ARRAY
52589: NOT
52590: IFFALSE 52610
// result := Delete ( result , 1 ) ;
52592: LD_ADDR_VAR 0 2
52596: PUSH
52597: LD_VAR 0 2
52601: PPUSH
52602: LD_INT 1
52604: PPUSH
52605: CALL_OW 3
52609: ST_TO_ADDR
// end ;
52610: LD_VAR 0 2
52614: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
52615: LD_INT 0
52617: PPUSH
52618: PPUSH
52619: PPUSH
52620: PPUSH
// sibRocketRange := 25 ;
52621: LD_ADDR_VAR 0 6
52625: PUSH
52626: LD_INT 25
52628: ST_TO_ADDR
// result := false ;
52629: LD_ADDR_VAR 0 4
52633: PUSH
52634: LD_INT 0
52636: ST_TO_ADDR
// for i := 0 to 5 do
52637: LD_ADDR_VAR 0 5
52641: PUSH
52642: DOUBLE
52643: LD_INT 0
52645: DEC
52646: ST_TO_ADDR
52647: LD_INT 5
52649: PUSH
52650: FOR_TO
52651: IFFALSE 52718
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
52653: LD_VAR 0 1
52657: PPUSH
52658: LD_VAR 0 5
52662: PPUSH
52663: LD_VAR 0 6
52667: PPUSH
52668: CALL_OW 272
52672: PPUSH
52673: LD_VAR 0 2
52677: PPUSH
52678: LD_VAR 0 5
52682: PPUSH
52683: LD_VAR 0 6
52687: PPUSH
52688: CALL_OW 273
52692: PPUSH
52693: LD_VAR 0 3
52697: PPUSH
52698: CALL_OW 309
52702: IFFALSE 52716
// begin result := true ;
52704: LD_ADDR_VAR 0 4
52708: PUSH
52709: LD_INT 1
52711: ST_TO_ADDR
// exit ;
52712: POP
52713: POP
52714: GO 52720
// end ;
52716: GO 52650
52718: POP
52719: POP
// end ;
52720: LD_VAR 0 4
52724: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
52725: LD_INT 0
52727: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
52728: LD_VAR 0 1
52732: PPUSH
52733: LD_VAR 0 2
52737: PPUSH
52738: LD_INT 0
52740: PPUSH
52741: LD_INT 0
52743: PPUSH
52744: LD_INT 1
52746: PPUSH
52747: LD_INT 0
52749: PPUSH
52750: CALL_OW 587
// end ;
52754: LD_VAR 0 3
52758: RET
// export function CenterOnNow ( unit ) ; begin
52759: LD_INT 0
52761: PPUSH
// result := IsInUnit ( unit ) ;
52762: LD_ADDR_VAR 0 2
52766: PUSH
52767: LD_VAR 0 1
52771: PPUSH
52772: CALL_OW 310
52776: ST_TO_ADDR
// if not result then
52777: LD_VAR 0 2
52781: NOT
52782: IFFALSE 52794
// result := unit ;
52784: LD_ADDR_VAR 0 2
52788: PUSH
52789: LD_VAR 0 1
52793: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
52794: LD_VAR 0 1
52798: PPUSH
52799: CALL_OW 87
// end ;
52803: LD_VAR 0 2
52807: RET
// export function ComMoveHex ( unit , hex ) ; begin
52808: LD_INT 0
52810: PPUSH
// if not hex then
52811: LD_VAR 0 2
52815: NOT
52816: IFFALSE 52820
// exit ;
52818: GO 52873
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
52820: LD_VAR 0 2
52824: PUSH
52825: LD_INT 1
52827: ARRAY
52828: PPUSH
52829: LD_VAR 0 2
52833: PUSH
52834: LD_INT 2
52836: ARRAY
52837: PPUSH
52838: CALL_OW 428
52842: IFFALSE 52846
// exit ;
52844: GO 52873
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
52846: LD_VAR 0 1
52850: PPUSH
52851: LD_VAR 0 2
52855: PUSH
52856: LD_INT 1
52858: ARRAY
52859: PPUSH
52860: LD_VAR 0 2
52864: PUSH
52865: LD_INT 2
52867: ARRAY
52868: PPUSH
52869: CALL_OW 111
// end ;
52873: LD_VAR 0 3
52877: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
52878: LD_INT 0
52880: PPUSH
52881: PPUSH
52882: PPUSH
// if not unit or not enemy then
52883: LD_VAR 0 1
52887: NOT
52888: PUSH
52889: LD_VAR 0 2
52893: NOT
52894: OR
52895: IFFALSE 52899
// exit ;
52897: GO 53023
// x := GetX ( enemy ) ;
52899: LD_ADDR_VAR 0 4
52903: PUSH
52904: LD_VAR 0 2
52908: PPUSH
52909: CALL_OW 250
52913: ST_TO_ADDR
// y := GetY ( enemy ) ;
52914: LD_ADDR_VAR 0 5
52918: PUSH
52919: LD_VAR 0 2
52923: PPUSH
52924: CALL_OW 251
52928: ST_TO_ADDR
// if ValidHex ( x , y ) then
52929: LD_VAR 0 4
52933: PPUSH
52934: LD_VAR 0 5
52938: PPUSH
52939: CALL_OW 488
52943: IFFALSE 53023
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
52945: LD_VAR 0 2
52949: PPUSH
52950: CALL_OW 247
52954: PUSH
52955: LD_INT 3
52957: PUSH
52958: LD_INT 2
52960: PUSH
52961: EMPTY
52962: LIST
52963: LIST
52964: IN
52965: PUSH
52966: LD_VAR 0 1
52970: PPUSH
52971: CALL_OW 255
52975: PPUSH
52976: LD_VAR 0 2
52980: PPUSH
52981: CALL_OW 292
52985: OR
52986: IFFALSE 53004
// ComAttackUnit ( unit , enemy ) else
52988: LD_VAR 0 1
52992: PPUSH
52993: LD_VAR 0 2
52997: PPUSH
52998: CALL_OW 115
53002: GO 53023
// ComAgressiveMove ( unit , x , y ) ;
53004: LD_VAR 0 1
53008: PPUSH
53009: LD_VAR 0 4
53013: PPUSH
53014: LD_VAR 0 5
53018: PPUSH
53019: CALL_OW 114
// end ;
53023: LD_VAR 0 3
53027: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
53028: LD_INT 0
53030: PPUSH
53031: PPUSH
53032: PPUSH
// list := AreaToList ( area , 0 ) ;
53033: LD_ADDR_VAR 0 5
53037: PUSH
53038: LD_VAR 0 1
53042: PPUSH
53043: LD_INT 0
53045: PPUSH
53046: CALL_OW 517
53050: ST_TO_ADDR
// if not list then
53051: LD_VAR 0 5
53055: NOT
53056: IFFALSE 53060
// exit ;
53058: GO 53190
// if all then
53060: LD_VAR 0 2
53064: IFFALSE 53152
// begin for i := 1 to list [ 1 ] do
53066: LD_ADDR_VAR 0 4
53070: PUSH
53071: DOUBLE
53072: LD_INT 1
53074: DEC
53075: ST_TO_ADDR
53076: LD_VAR 0 5
53080: PUSH
53081: LD_INT 1
53083: ARRAY
53084: PUSH
53085: FOR_TO
53086: IFFALSE 53148
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
53088: LD_ADDR_VAR 0 3
53092: PUSH
53093: LD_VAR 0 3
53097: PPUSH
53098: LD_VAR 0 3
53102: PUSH
53103: LD_INT 1
53105: PLUS
53106: PPUSH
53107: LD_VAR 0 5
53111: PUSH
53112: LD_INT 1
53114: ARRAY
53115: PUSH
53116: LD_VAR 0 4
53120: ARRAY
53121: PUSH
53122: LD_VAR 0 5
53126: PUSH
53127: LD_INT 2
53129: ARRAY
53130: PUSH
53131: LD_VAR 0 4
53135: ARRAY
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PPUSH
53141: CALL_OW 1
53145: ST_TO_ADDR
53146: GO 53085
53148: POP
53149: POP
// exit ;
53150: GO 53190
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
53152: LD_ADDR_VAR 0 3
53156: PUSH
53157: LD_VAR 0 5
53161: PUSH
53162: LD_INT 1
53164: ARRAY
53165: PUSH
53166: LD_INT 1
53168: ARRAY
53169: PUSH
53170: LD_VAR 0 5
53174: PUSH
53175: LD_INT 2
53177: ARRAY
53178: PUSH
53179: LD_INT 1
53181: ARRAY
53182: PUSH
53183: EMPTY
53184: LIST
53185: LIST
53186: PUSH
53187: EMPTY
53188: LIST
53189: ST_TO_ADDR
// end ;
53190: LD_VAR 0 3
53194: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
53195: LD_INT 0
53197: PPUSH
53198: PPUSH
// list := AreaToList ( area , 0 ) ;
53199: LD_ADDR_VAR 0 4
53203: PUSH
53204: LD_VAR 0 1
53208: PPUSH
53209: LD_INT 0
53211: PPUSH
53212: CALL_OW 517
53216: ST_TO_ADDR
// if not list then
53217: LD_VAR 0 4
53221: NOT
53222: IFFALSE 53226
// exit ;
53224: GO 53267
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
53226: LD_ADDR_VAR 0 3
53230: PUSH
53231: LD_VAR 0 4
53235: PUSH
53236: LD_INT 1
53238: ARRAY
53239: PUSH
53240: LD_INT 1
53242: ARRAY
53243: PUSH
53244: LD_VAR 0 4
53248: PUSH
53249: LD_INT 2
53251: ARRAY
53252: PUSH
53253: LD_INT 1
53255: ARRAY
53256: PUSH
53257: LD_VAR 0 2
53261: PUSH
53262: EMPTY
53263: LIST
53264: LIST
53265: LIST
53266: ST_TO_ADDR
// end ;
53267: LD_VAR 0 3
53271: RET
// export function First ( array ) ; begin
53272: LD_INT 0
53274: PPUSH
// if not array then
53275: LD_VAR 0 1
53279: NOT
53280: IFFALSE 53284
// exit ;
53282: GO 53298
// result := array [ 1 ] ;
53284: LD_ADDR_VAR 0 2
53288: PUSH
53289: LD_VAR 0 1
53293: PUSH
53294: LD_INT 1
53296: ARRAY
53297: ST_TO_ADDR
// end ;
53298: LD_VAR 0 2
53302: RET
// export function Last ( array ) ; begin
53303: LD_INT 0
53305: PPUSH
// if not array then
53306: LD_VAR 0 1
53310: NOT
53311: IFFALSE 53315
// exit ;
53313: GO 53331
// result := array [ array ] ;
53315: LD_ADDR_VAR 0 2
53319: PUSH
53320: LD_VAR 0 1
53324: PUSH
53325: LD_VAR 0 1
53329: ARRAY
53330: ST_TO_ADDR
// end ;
53331: LD_VAR 0 2
53335: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
53336: LD_INT 0
53338: PPUSH
53339: PPUSH
// result := [ ] ;
53340: LD_ADDR_VAR 0 5
53344: PUSH
53345: EMPTY
53346: ST_TO_ADDR
// if not array then
53347: LD_VAR 0 1
53351: NOT
53352: IFFALSE 53356
// exit ;
53354: GO 53468
// for i := 1 to array do
53356: LD_ADDR_VAR 0 6
53360: PUSH
53361: DOUBLE
53362: LD_INT 1
53364: DEC
53365: ST_TO_ADDR
53366: LD_VAR 0 1
53370: PUSH
53371: FOR_TO
53372: IFFALSE 53466
// if array [ i ] [ index ] = value then
53374: LD_VAR 0 1
53378: PUSH
53379: LD_VAR 0 6
53383: ARRAY
53384: PUSH
53385: LD_VAR 0 2
53389: ARRAY
53390: PUSH
53391: LD_VAR 0 3
53395: EQUAL
53396: IFFALSE 53464
// begin if indexColumn then
53398: LD_VAR 0 4
53402: IFFALSE 53438
// result := Join ( result , array [ i ] [ indexColumn ] ) else
53404: LD_ADDR_VAR 0 5
53408: PUSH
53409: LD_VAR 0 5
53413: PPUSH
53414: LD_VAR 0 1
53418: PUSH
53419: LD_VAR 0 6
53423: ARRAY
53424: PUSH
53425: LD_VAR 0 4
53429: ARRAY
53430: PPUSH
53431: CALL 48806 0 2
53435: ST_TO_ADDR
53436: GO 53464
// result := Join ( result , array [ i ] ) ;
53438: LD_ADDR_VAR 0 5
53442: PUSH
53443: LD_VAR 0 5
53447: PPUSH
53448: LD_VAR 0 1
53452: PUSH
53453: LD_VAR 0 6
53457: ARRAY
53458: PPUSH
53459: CALL 48806 0 2
53463: ST_TO_ADDR
// end ;
53464: GO 53371
53466: POP
53467: POP
// end ;
53468: LD_VAR 0 5
53472: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
53473: LD_INT 0
53475: PPUSH
53476: PPUSH
53477: PPUSH
// if btype = b_depot then
53478: LD_VAR 0 2
53482: PUSH
53483: LD_INT 0
53485: EQUAL
53486: IFFALSE 53498
// begin result := true ;
53488: LD_ADDR_VAR 0 3
53492: PUSH
53493: LD_INT 1
53495: ST_TO_ADDR
// exit ;
53496: GO 53614
// end ; pom := GetBase ( depot ) ;
53498: LD_ADDR_VAR 0 4
53502: PUSH
53503: LD_VAR 0 1
53507: PPUSH
53508: CALL_OW 274
53512: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
53513: LD_ADDR_VAR 0 5
53517: PUSH
53518: LD_VAR 0 2
53522: PPUSH
53523: LD_VAR 0 1
53527: PPUSH
53528: CALL_OW 248
53532: PPUSH
53533: CALL_OW 450
53537: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
53538: LD_ADDR_VAR 0 3
53542: PUSH
53543: LD_VAR 0 4
53547: PPUSH
53548: LD_INT 1
53550: PPUSH
53551: CALL_OW 275
53555: PUSH
53556: LD_VAR 0 5
53560: PUSH
53561: LD_INT 1
53563: ARRAY
53564: GREATEREQUAL
53565: PUSH
53566: LD_VAR 0 4
53570: PPUSH
53571: LD_INT 2
53573: PPUSH
53574: CALL_OW 275
53578: PUSH
53579: LD_VAR 0 5
53583: PUSH
53584: LD_INT 2
53586: ARRAY
53587: GREATEREQUAL
53588: AND
53589: PUSH
53590: LD_VAR 0 4
53594: PPUSH
53595: LD_INT 3
53597: PPUSH
53598: CALL_OW 275
53602: PUSH
53603: LD_VAR 0 5
53607: PUSH
53608: LD_INT 3
53610: ARRAY
53611: GREATEREQUAL
53612: AND
53613: ST_TO_ADDR
// end ;
53614: LD_VAR 0 3
53618: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
53619: LD_INT 0
53621: PPUSH
// if not vehicles or not parkingPoint then
53622: LD_VAR 0 1
53626: NOT
53627: PUSH
53628: LD_VAR 0 2
53632: NOT
53633: OR
53634: IFFALSE 53638
// exit ;
53636: GO 53736
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
53638: LD_ADDR_VAR 0 1
53642: PUSH
53643: LD_VAR 0 1
53647: PPUSH
53648: LD_INT 50
53650: PUSH
53651: EMPTY
53652: LIST
53653: PUSH
53654: LD_INT 3
53656: PUSH
53657: LD_INT 92
53659: PUSH
53660: LD_VAR 0 2
53664: PUSH
53665: LD_INT 1
53667: ARRAY
53668: PUSH
53669: LD_VAR 0 2
53673: PUSH
53674: LD_INT 2
53676: ARRAY
53677: PUSH
53678: LD_INT 8
53680: PUSH
53681: EMPTY
53682: LIST
53683: LIST
53684: LIST
53685: LIST
53686: PUSH
53687: EMPTY
53688: LIST
53689: LIST
53690: PUSH
53691: EMPTY
53692: LIST
53693: LIST
53694: PPUSH
53695: CALL_OW 72
53699: ST_TO_ADDR
// if not vehicles then
53700: LD_VAR 0 1
53704: NOT
53705: IFFALSE 53709
// exit ;
53707: GO 53736
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
53709: LD_VAR 0 1
53713: PPUSH
53714: LD_VAR 0 2
53718: PUSH
53719: LD_INT 1
53721: ARRAY
53722: PPUSH
53723: LD_VAR 0 2
53727: PUSH
53728: LD_INT 2
53730: ARRAY
53731: PPUSH
53732: CALL_OW 111
// end ;
53736: LD_VAR 0 3
53740: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
53741: LD_INT 0
53743: PPUSH
53744: PPUSH
53745: PPUSH
// if not side or not area then
53746: LD_VAR 0 1
53750: NOT
53751: PUSH
53752: LD_VAR 0 2
53756: NOT
53757: OR
53758: IFFALSE 53762
// exit ;
53760: GO 53881
// tmp := AreaToList ( area , 0 ) ;
53762: LD_ADDR_VAR 0 5
53766: PUSH
53767: LD_VAR 0 2
53771: PPUSH
53772: LD_INT 0
53774: PPUSH
53775: CALL_OW 517
53779: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
53780: LD_ADDR_VAR 0 4
53784: PUSH
53785: DOUBLE
53786: LD_INT 1
53788: DEC
53789: ST_TO_ADDR
53790: LD_VAR 0 5
53794: PUSH
53795: LD_INT 1
53797: ARRAY
53798: PUSH
53799: FOR_TO
53800: IFFALSE 53879
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
53802: LD_VAR 0 5
53806: PUSH
53807: LD_INT 1
53809: ARRAY
53810: PUSH
53811: LD_VAR 0 4
53815: ARRAY
53816: PPUSH
53817: LD_VAR 0 5
53821: PUSH
53822: LD_INT 2
53824: ARRAY
53825: PUSH
53826: LD_VAR 0 4
53830: ARRAY
53831: PPUSH
53832: CALL_OW 351
53836: IFFALSE 53877
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
53838: LD_VAR 0 5
53842: PUSH
53843: LD_INT 1
53845: ARRAY
53846: PUSH
53847: LD_VAR 0 4
53851: ARRAY
53852: PPUSH
53853: LD_VAR 0 5
53857: PUSH
53858: LD_INT 2
53860: ARRAY
53861: PUSH
53862: LD_VAR 0 4
53866: ARRAY
53867: PPUSH
53868: LD_VAR 0 1
53872: PPUSH
53873: CALL_OW 244
// end ;
53877: GO 53799
53879: POP
53880: POP
// end ; end_of_file
53881: LD_VAR 0 3
53885: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
53886: LD_INT 0
53888: PPUSH
53889: PPUSH
// skirmish := false ;
53890: LD_ADDR_EXP 21
53894: PUSH
53895: LD_INT 0
53897: ST_TO_ADDR
// debug_mc := false ;
53898: LD_ADDR_EXP 22
53902: PUSH
53903: LD_INT 0
53905: ST_TO_ADDR
// mc_bases := [ ] ;
53906: LD_ADDR_EXP 23
53910: PUSH
53911: EMPTY
53912: ST_TO_ADDR
// mc_sides := [ ] ;
53913: LD_ADDR_EXP 49
53917: PUSH
53918: EMPTY
53919: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
53920: LD_ADDR_EXP 24
53924: PUSH
53925: EMPTY
53926: ST_TO_ADDR
// mc_building_repairs := [ ] ;
53927: LD_ADDR_EXP 25
53931: PUSH
53932: EMPTY
53933: ST_TO_ADDR
// mc_need_heal := [ ] ;
53934: LD_ADDR_EXP 26
53938: PUSH
53939: EMPTY
53940: ST_TO_ADDR
// mc_healers := [ ] ;
53941: LD_ADDR_EXP 27
53945: PUSH
53946: EMPTY
53947: ST_TO_ADDR
// mc_build_list := [ ] ;
53948: LD_ADDR_EXP 28
53952: PUSH
53953: EMPTY
53954: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
53955: LD_ADDR_EXP 55
53959: PUSH
53960: EMPTY
53961: ST_TO_ADDR
// mc_builders := [ ] ;
53962: LD_ADDR_EXP 29
53966: PUSH
53967: EMPTY
53968: ST_TO_ADDR
// mc_construct_list := [ ] ;
53969: LD_ADDR_EXP 30
53973: PUSH
53974: EMPTY
53975: ST_TO_ADDR
// mc_turret_list := [ ] ;
53976: LD_ADDR_EXP 31
53980: PUSH
53981: EMPTY
53982: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
53983: LD_ADDR_EXP 32
53987: PUSH
53988: EMPTY
53989: ST_TO_ADDR
// mc_miners := [ ] ;
53990: LD_ADDR_EXP 37
53994: PUSH
53995: EMPTY
53996: ST_TO_ADDR
// mc_mines := [ ] ;
53997: LD_ADDR_EXP 36
54001: PUSH
54002: EMPTY
54003: ST_TO_ADDR
// mc_minefields := [ ] ;
54004: LD_ADDR_EXP 38
54008: PUSH
54009: EMPTY
54010: ST_TO_ADDR
// mc_crates := [ ] ;
54011: LD_ADDR_EXP 39
54015: PUSH
54016: EMPTY
54017: ST_TO_ADDR
// mc_crates_collector := [ ] ;
54018: LD_ADDR_EXP 40
54022: PUSH
54023: EMPTY
54024: ST_TO_ADDR
// mc_crates_area := [ ] ;
54025: LD_ADDR_EXP 41
54029: PUSH
54030: EMPTY
54031: ST_TO_ADDR
// mc_vehicles := [ ] ;
54032: LD_ADDR_EXP 42
54036: PUSH
54037: EMPTY
54038: ST_TO_ADDR
// mc_attack := [ ] ;
54039: LD_ADDR_EXP 43
54043: PUSH
54044: EMPTY
54045: ST_TO_ADDR
// mc_produce := [ ] ;
54046: LD_ADDR_EXP 44
54050: PUSH
54051: EMPTY
54052: ST_TO_ADDR
// mc_defender := [ ] ;
54053: LD_ADDR_EXP 45
54057: PUSH
54058: EMPTY
54059: ST_TO_ADDR
// mc_parking := [ ] ;
54060: LD_ADDR_EXP 47
54064: PUSH
54065: EMPTY
54066: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54067: LD_ADDR_EXP 33
54071: PUSH
54072: EMPTY
54073: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54074: LD_ADDR_EXP 35
54078: PUSH
54079: EMPTY
54080: ST_TO_ADDR
// mc_scan := [ ] ;
54081: LD_ADDR_EXP 46
54085: PUSH
54086: EMPTY
54087: ST_TO_ADDR
// mc_scan_area := [ ] ;
54088: LD_ADDR_EXP 48
54092: PUSH
54093: EMPTY
54094: ST_TO_ADDR
// mc_tech := [ ] ;
54095: LD_ADDR_EXP 50
54099: PUSH
54100: EMPTY
54101: ST_TO_ADDR
// mc_class := [ ] ;
54102: LD_ADDR_EXP 64
54106: PUSH
54107: EMPTY
54108: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54109: LD_ADDR_EXP 65
54113: PUSH
54114: EMPTY
54115: ST_TO_ADDR
// mc_is_defending := [ ] ;
54116: LD_ADDR_EXP 66
54120: PUSH
54121: EMPTY
54122: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
54123: LD_ADDR_EXP 57
54127: PUSH
54128: EMPTY
54129: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
54130: LD_ADDR_EXP 67
54134: PUSH
54135: LD_INT 0
54137: ST_TO_ADDR
// end ;
54138: LD_VAR 0 1
54142: RET
// export function MC_Kill ( base ) ; begin
54143: LD_INT 0
54145: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54146: LD_ADDR_EXP 23
54150: PUSH
54151: LD_EXP 23
54155: PPUSH
54156: LD_VAR 0 1
54160: PPUSH
54161: EMPTY
54162: PPUSH
54163: CALL_OW 1
54167: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54168: LD_ADDR_EXP 24
54172: PUSH
54173: LD_EXP 24
54177: PPUSH
54178: LD_VAR 0 1
54182: PPUSH
54183: EMPTY
54184: PPUSH
54185: CALL_OW 1
54189: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54190: LD_ADDR_EXP 25
54194: PUSH
54195: LD_EXP 25
54199: PPUSH
54200: LD_VAR 0 1
54204: PPUSH
54205: EMPTY
54206: PPUSH
54207: CALL_OW 1
54211: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54212: LD_ADDR_EXP 26
54216: PUSH
54217: LD_EXP 26
54221: PPUSH
54222: LD_VAR 0 1
54226: PPUSH
54227: EMPTY
54228: PPUSH
54229: CALL_OW 1
54233: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54234: LD_ADDR_EXP 27
54238: PUSH
54239: LD_EXP 27
54243: PPUSH
54244: LD_VAR 0 1
54248: PPUSH
54249: EMPTY
54250: PPUSH
54251: CALL_OW 1
54255: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54256: LD_ADDR_EXP 28
54260: PUSH
54261: LD_EXP 28
54265: PPUSH
54266: LD_VAR 0 1
54270: PPUSH
54271: EMPTY
54272: PPUSH
54273: CALL_OW 1
54277: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54278: LD_ADDR_EXP 29
54282: PUSH
54283: LD_EXP 29
54287: PPUSH
54288: LD_VAR 0 1
54292: PPUSH
54293: EMPTY
54294: PPUSH
54295: CALL_OW 1
54299: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54300: LD_ADDR_EXP 30
54304: PUSH
54305: LD_EXP 30
54309: PPUSH
54310: LD_VAR 0 1
54314: PPUSH
54315: EMPTY
54316: PPUSH
54317: CALL_OW 1
54321: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54322: LD_ADDR_EXP 31
54326: PUSH
54327: LD_EXP 31
54331: PPUSH
54332: LD_VAR 0 1
54336: PPUSH
54337: EMPTY
54338: PPUSH
54339: CALL_OW 1
54343: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54344: LD_ADDR_EXP 32
54348: PUSH
54349: LD_EXP 32
54353: PPUSH
54354: LD_VAR 0 1
54358: PPUSH
54359: EMPTY
54360: PPUSH
54361: CALL_OW 1
54365: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54366: LD_ADDR_EXP 33
54370: PUSH
54371: LD_EXP 33
54375: PPUSH
54376: LD_VAR 0 1
54380: PPUSH
54381: EMPTY
54382: PPUSH
54383: CALL_OW 1
54387: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54388: LD_ADDR_EXP 34
54392: PUSH
54393: LD_EXP 34
54397: PPUSH
54398: LD_VAR 0 1
54402: PPUSH
54403: LD_INT 0
54405: PPUSH
54406: CALL_OW 1
54410: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54411: LD_ADDR_EXP 35
54415: PUSH
54416: LD_EXP 35
54420: PPUSH
54421: LD_VAR 0 1
54425: PPUSH
54426: EMPTY
54427: PPUSH
54428: CALL_OW 1
54432: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54433: LD_ADDR_EXP 36
54437: PUSH
54438: LD_EXP 36
54442: PPUSH
54443: LD_VAR 0 1
54447: PPUSH
54448: EMPTY
54449: PPUSH
54450: CALL_OW 1
54454: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54455: LD_ADDR_EXP 37
54459: PUSH
54460: LD_EXP 37
54464: PPUSH
54465: LD_VAR 0 1
54469: PPUSH
54470: EMPTY
54471: PPUSH
54472: CALL_OW 1
54476: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54477: LD_ADDR_EXP 38
54481: PUSH
54482: LD_EXP 38
54486: PPUSH
54487: LD_VAR 0 1
54491: PPUSH
54492: EMPTY
54493: PPUSH
54494: CALL_OW 1
54498: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54499: LD_ADDR_EXP 39
54503: PUSH
54504: LD_EXP 39
54508: PPUSH
54509: LD_VAR 0 1
54513: PPUSH
54514: EMPTY
54515: PPUSH
54516: CALL_OW 1
54520: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54521: LD_ADDR_EXP 40
54525: PUSH
54526: LD_EXP 40
54530: PPUSH
54531: LD_VAR 0 1
54535: PPUSH
54536: EMPTY
54537: PPUSH
54538: CALL_OW 1
54542: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54543: LD_ADDR_EXP 41
54547: PUSH
54548: LD_EXP 41
54552: PPUSH
54553: LD_VAR 0 1
54557: PPUSH
54558: EMPTY
54559: PPUSH
54560: CALL_OW 1
54564: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54565: LD_ADDR_EXP 42
54569: PUSH
54570: LD_EXP 42
54574: PPUSH
54575: LD_VAR 0 1
54579: PPUSH
54580: EMPTY
54581: PPUSH
54582: CALL_OW 1
54586: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54587: LD_ADDR_EXP 43
54591: PUSH
54592: LD_EXP 43
54596: PPUSH
54597: LD_VAR 0 1
54601: PPUSH
54602: EMPTY
54603: PPUSH
54604: CALL_OW 1
54608: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54609: LD_ADDR_EXP 44
54613: PUSH
54614: LD_EXP 44
54618: PPUSH
54619: LD_VAR 0 1
54623: PPUSH
54624: EMPTY
54625: PPUSH
54626: CALL_OW 1
54630: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54631: LD_ADDR_EXP 45
54635: PUSH
54636: LD_EXP 45
54640: PPUSH
54641: LD_VAR 0 1
54645: PPUSH
54646: EMPTY
54647: PPUSH
54648: CALL_OW 1
54652: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54653: LD_ADDR_EXP 46
54657: PUSH
54658: LD_EXP 46
54662: PPUSH
54663: LD_VAR 0 1
54667: PPUSH
54668: EMPTY
54669: PPUSH
54670: CALL_OW 1
54674: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54675: LD_ADDR_EXP 47
54679: PUSH
54680: LD_EXP 47
54684: PPUSH
54685: LD_VAR 0 1
54689: PPUSH
54690: EMPTY
54691: PPUSH
54692: CALL_OW 1
54696: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54697: LD_ADDR_EXP 48
54701: PUSH
54702: LD_EXP 48
54706: PPUSH
54707: LD_VAR 0 1
54711: PPUSH
54712: EMPTY
54713: PPUSH
54714: CALL_OW 1
54718: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54719: LD_ADDR_EXP 50
54723: PUSH
54724: LD_EXP 50
54728: PPUSH
54729: LD_VAR 0 1
54733: PPUSH
54734: EMPTY
54735: PPUSH
54736: CALL_OW 1
54740: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54741: LD_ADDR_EXP 52
54745: PUSH
54746: LD_EXP 52
54750: PPUSH
54751: LD_VAR 0 1
54755: PPUSH
54756: EMPTY
54757: PPUSH
54758: CALL_OW 1
54762: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54763: LD_ADDR_EXP 53
54767: PUSH
54768: LD_EXP 53
54772: PPUSH
54773: LD_VAR 0 1
54777: PPUSH
54778: EMPTY
54779: PPUSH
54780: CALL_OW 1
54784: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54785: LD_ADDR_EXP 54
54789: PUSH
54790: LD_EXP 54
54794: PPUSH
54795: LD_VAR 0 1
54799: PPUSH
54800: EMPTY
54801: PPUSH
54802: CALL_OW 1
54806: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54807: LD_ADDR_EXP 55
54811: PUSH
54812: LD_EXP 55
54816: PPUSH
54817: LD_VAR 0 1
54821: PPUSH
54822: EMPTY
54823: PPUSH
54824: CALL_OW 1
54828: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54829: LD_ADDR_EXP 56
54833: PUSH
54834: LD_EXP 56
54838: PPUSH
54839: LD_VAR 0 1
54843: PPUSH
54844: EMPTY
54845: PPUSH
54846: CALL_OW 1
54850: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54851: LD_ADDR_EXP 57
54855: PUSH
54856: LD_EXP 57
54860: PPUSH
54861: LD_VAR 0 1
54865: PPUSH
54866: EMPTY
54867: PPUSH
54868: CALL_OW 1
54872: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54873: LD_ADDR_EXP 58
54877: PUSH
54878: LD_EXP 58
54882: PPUSH
54883: LD_VAR 0 1
54887: PPUSH
54888: EMPTY
54889: PPUSH
54890: CALL_OW 1
54894: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54895: LD_ADDR_EXP 59
54899: PUSH
54900: LD_EXP 59
54904: PPUSH
54905: LD_VAR 0 1
54909: PPUSH
54910: EMPTY
54911: PPUSH
54912: CALL_OW 1
54916: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54917: LD_ADDR_EXP 60
54921: PUSH
54922: LD_EXP 60
54926: PPUSH
54927: LD_VAR 0 1
54931: PPUSH
54932: EMPTY
54933: PPUSH
54934: CALL_OW 1
54938: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54939: LD_ADDR_EXP 61
54943: PUSH
54944: LD_EXP 61
54948: PPUSH
54949: LD_VAR 0 1
54953: PPUSH
54954: EMPTY
54955: PPUSH
54956: CALL_OW 1
54960: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54961: LD_ADDR_EXP 62
54965: PUSH
54966: LD_EXP 62
54970: PPUSH
54971: LD_VAR 0 1
54975: PPUSH
54976: EMPTY
54977: PPUSH
54978: CALL_OW 1
54982: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54983: LD_ADDR_EXP 63
54987: PUSH
54988: LD_EXP 63
54992: PPUSH
54993: LD_VAR 0 1
54997: PPUSH
54998: EMPTY
54999: PPUSH
55000: CALL_OW 1
55004: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55005: LD_ADDR_EXP 64
55009: PUSH
55010: LD_EXP 64
55014: PPUSH
55015: LD_VAR 0 1
55019: PPUSH
55020: EMPTY
55021: PPUSH
55022: CALL_OW 1
55026: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55027: LD_ADDR_EXP 65
55031: PUSH
55032: LD_EXP 65
55036: PPUSH
55037: LD_VAR 0 1
55041: PPUSH
55042: LD_INT 0
55044: PPUSH
55045: CALL_OW 1
55049: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55050: LD_ADDR_EXP 66
55054: PUSH
55055: LD_EXP 66
55059: PPUSH
55060: LD_VAR 0 1
55064: PPUSH
55065: LD_INT 0
55067: PPUSH
55068: CALL_OW 1
55072: ST_TO_ADDR
// end ;
55073: LD_VAR 0 2
55077: RET
// export function MC_Add ( side , units ) ; var base ; begin
55078: LD_INT 0
55080: PPUSH
55081: PPUSH
// base := mc_bases + 1 ;
55082: LD_ADDR_VAR 0 4
55086: PUSH
55087: LD_EXP 23
55091: PUSH
55092: LD_INT 1
55094: PLUS
55095: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55096: LD_ADDR_EXP 49
55100: PUSH
55101: LD_EXP 49
55105: PPUSH
55106: LD_VAR 0 4
55110: PPUSH
55111: LD_VAR 0 1
55115: PPUSH
55116: CALL_OW 1
55120: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55121: LD_ADDR_EXP 23
55125: PUSH
55126: LD_EXP 23
55130: PPUSH
55131: LD_VAR 0 4
55135: PPUSH
55136: LD_VAR 0 2
55140: PPUSH
55141: CALL_OW 1
55145: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55146: LD_ADDR_EXP 24
55150: PUSH
55151: LD_EXP 24
55155: PPUSH
55156: LD_VAR 0 4
55160: PPUSH
55161: EMPTY
55162: PPUSH
55163: CALL_OW 1
55167: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55168: LD_ADDR_EXP 25
55172: PUSH
55173: LD_EXP 25
55177: PPUSH
55178: LD_VAR 0 4
55182: PPUSH
55183: EMPTY
55184: PPUSH
55185: CALL_OW 1
55189: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55190: LD_ADDR_EXP 26
55194: PUSH
55195: LD_EXP 26
55199: PPUSH
55200: LD_VAR 0 4
55204: PPUSH
55205: EMPTY
55206: PPUSH
55207: CALL_OW 1
55211: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55212: LD_ADDR_EXP 27
55216: PUSH
55217: LD_EXP 27
55221: PPUSH
55222: LD_VAR 0 4
55226: PPUSH
55227: EMPTY
55228: PPUSH
55229: CALL_OW 1
55233: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55234: LD_ADDR_EXP 28
55238: PUSH
55239: LD_EXP 28
55243: PPUSH
55244: LD_VAR 0 4
55248: PPUSH
55249: EMPTY
55250: PPUSH
55251: CALL_OW 1
55255: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55256: LD_ADDR_EXP 29
55260: PUSH
55261: LD_EXP 29
55265: PPUSH
55266: LD_VAR 0 4
55270: PPUSH
55271: EMPTY
55272: PPUSH
55273: CALL_OW 1
55277: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55278: LD_ADDR_EXP 30
55282: PUSH
55283: LD_EXP 30
55287: PPUSH
55288: LD_VAR 0 4
55292: PPUSH
55293: EMPTY
55294: PPUSH
55295: CALL_OW 1
55299: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55300: LD_ADDR_EXP 31
55304: PUSH
55305: LD_EXP 31
55309: PPUSH
55310: LD_VAR 0 4
55314: PPUSH
55315: EMPTY
55316: PPUSH
55317: CALL_OW 1
55321: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55322: LD_ADDR_EXP 32
55326: PUSH
55327: LD_EXP 32
55331: PPUSH
55332: LD_VAR 0 4
55336: PPUSH
55337: EMPTY
55338: PPUSH
55339: CALL_OW 1
55343: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55344: LD_ADDR_EXP 33
55348: PUSH
55349: LD_EXP 33
55353: PPUSH
55354: LD_VAR 0 4
55358: PPUSH
55359: EMPTY
55360: PPUSH
55361: CALL_OW 1
55365: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55366: LD_ADDR_EXP 34
55370: PUSH
55371: LD_EXP 34
55375: PPUSH
55376: LD_VAR 0 4
55380: PPUSH
55381: LD_INT 0
55383: PPUSH
55384: CALL_OW 1
55388: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55389: LD_ADDR_EXP 35
55393: PUSH
55394: LD_EXP 35
55398: PPUSH
55399: LD_VAR 0 4
55403: PPUSH
55404: EMPTY
55405: PPUSH
55406: CALL_OW 1
55410: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55411: LD_ADDR_EXP 36
55415: PUSH
55416: LD_EXP 36
55420: PPUSH
55421: LD_VAR 0 4
55425: PPUSH
55426: EMPTY
55427: PPUSH
55428: CALL_OW 1
55432: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55433: LD_ADDR_EXP 37
55437: PUSH
55438: LD_EXP 37
55442: PPUSH
55443: LD_VAR 0 4
55447: PPUSH
55448: EMPTY
55449: PPUSH
55450: CALL_OW 1
55454: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55455: LD_ADDR_EXP 38
55459: PUSH
55460: LD_EXP 38
55464: PPUSH
55465: LD_VAR 0 4
55469: PPUSH
55470: EMPTY
55471: PPUSH
55472: CALL_OW 1
55476: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55477: LD_ADDR_EXP 39
55481: PUSH
55482: LD_EXP 39
55486: PPUSH
55487: LD_VAR 0 4
55491: PPUSH
55492: EMPTY
55493: PPUSH
55494: CALL_OW 1
55498: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55499: LD_ADDR_EXP 40
55503: PUSH
55504: LD_EXP 40
55508: PPUSH
55509: LD_VAR 0 4
55513: PPUSH
55514: EMPTY
55515: PPUSH
55516: CALL_OW 1
55520: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55521: LD_ADDR_EXP 41
55525: PUSH
55526: LD_EXP 41
55530: PPUSH
55531: LD_VAR 0 4
55535: PPUSH
55536: EMPTY
55537: PPUSH
55538: CALL_OW 1
55542: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55543: LD_ADDR_EXP 42
55547: PUSH
55548: LD_EXP 42
55552: PPUSH
55553: LD_VAR 0 4
55557: PPUSH
55558: EMPTY
55559: PPUSH
55560: CALL_OW 1
55564: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55565: LD_ADDR_EXP 43
55569: PUSH
55570: LD_EXP 43
55574: PPUSH
55575: LD_VAR 0 4
55579: PPUSH
55580: EMPTY
55581: PPUSH
55582: CALL_OW 1
55586: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55587: LD_ADDR_EXP 44
55591: PUSH
55592: LD_EXP 44
55596: PPUSH
55597: LD_VAR 0 4
55601: PPUSH
55602: EMPTY
55603: PPUSH
55604: CALL_OW 1
55608: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55609: LD_ADDR_EXP 45
55613: PUSH
55614: LD_EXP 45
55618: PPUSH
55619: LD_VAR 0 4
55623: PPUSH
55624: EMPTY
55625: PPUSH
55626: CALL_OW 1
55630: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55631: LD_ADDR_EXP 46
55635: PUSH
55636: LD_EXP 46
55640: PPUSH
55641: LD_VAR 0 4
55645: PPUSH
55646: EMPTY
55647: PPUSH
55648: CALL_OW 1
55652: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55653: LD_ADDR_EXP 47
55657: PUSH
55658: LD_EXP 47
55662: PPUSH
55663: LD_VAR 0 4
55667: PPUSH
55668: EMPTY
55669: PPUSH
55670: CALL_OW 1
55674: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55675: LD_ADDR_EXP 48
55679: PUSH
55680: LD_EXP 48
55684: PPUSH
55685: LD_VAR 0 4
55689: PPUSH
55690: EMPTY
55691: PPUSH
55692: CALL_OW 1
55696: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55697: LD_ADDR_EXP 50
55701: PUSH
55702: LD_EXP 50
55706: PPUSH
55707: LD_VAR 0 4
55711: PPUSH
55712: EMPTY
55713: PPUSH
55714: CALL_OW 1
55718: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55719: LD_ADDR_EXP 52
55723: PUSH
55724: LD_EXP 52
55728: PPUSH
55729: LD_VAR 0 4
55733: PPUSH
55734: EMPTY
55735: PPUSH
55736: CALL_OW 1
55740: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55741: LD_ADDR_EXP 53
55745: PUSH
55746: LD_EXP 53
55750: PPUSH
55751: LD_VAR 0 4
55755: PPUSH
55756: EMPTY
55757: PPUSH
55758: CALL_OW 1
55762: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55763: LD_ADDR_EXP 54
55767: PUSH
55768: LD_EXP 54
55772: PPUSH
55773: LD_VAR 0 4
55777: PPUSH
55778: EMPTY
55779: PPUSH
55780: CALL_OW 1
55784: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55785: LD_ADDR_EXP 55
55789: PUSH
55790: LD_EXP 55
55794: PPUSH
55795: LD_VAR 0 4
55799: PPUSH
55800: EMPTY
55801: PPUSH
55802: CALL_OW 1
55806: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55807: LD_ADDR_EXP 56
55811: PUSH
55812: LD_EXP 56
55816: PPUSH
55817: LD_VAR 0 4
55821: PPUSH
55822: EMPTY
55823: PPUSH
55824: CALL_OW 1
55828: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55829: LD_ADDR_EXP 57
55833: PUSH
55834: LD_EXP 57
55838: PPUSH
55839: LD_VAR 0 4
55843: PPUSH
55844: EMPTY
55845: PPUSH
55846: CALL_OW 1
55850: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55851: LD_ADDR_EXP 58
55855: PUSH
55856: LD_EXP 58
55860: PPUSH
55861: LD_VAR 0 4
55865: PPUSH
55866: EMPTY
55867: PPUSH
55868: CALL_OW 1
55872: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55873: LD_ADDR_EXP 59
55877: PUSH
55878: LD_EXP 59
55882: PPUSH
55883: LD_VAR 0 4
55887: PPUSH
55888: EMPTY
55889: PPUSH
55890: CALL_OW 1
55894: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55895: LD_ADDR_EXP 60
55899: PUSH
55900: LD_EXP 60
55904: PPUSH
55905: LD_VAR 0 4
55909: PPUSH
55910: EMPTY
55911: PPUSH
55912: CALL_OW 1
55916: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55917: LD_ADDR_EXP 61
55921: PUSH
55922: LD_EXP 61
55926: PPUSH
55927: LD_VAR 0 4
55931: PPUSH
55932: EMPTY
55933: PPUSH
55934: CALL_OW 1
55938: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55939: LD_ADDR_EXP 62
55943: PUSH
55944: LD_EXP 62
55948: PPUSH
55949: LD_VAR 0 4
55953: PPUSH
55954: EMPTY
55955: PPUSH
55956: CALL_OW 1
55960: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55961: LD_ADDR_EXP 63
55965: PUSH
55966: LD_EXP 63
55970: PPUSH
55971: LD_VAR 0 4
55975: PPUSH
55976: EMPTY
55977: PPUSH
55978: CALL_OW 1
55982: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55983: LD_ADDR_EXP 64
55987: PUSH
55988: LD_EXP 64
55992: PPUSH
55993: LD_VAR 0 4
55997: PPUSH
55998: EMPTY
55999: PPUSH
56000: CALL_OW 1
56004: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56005: LD_ADDR_EXP 65
56009: PUSH
56010: LD_EXP 65
56014: PPUSH
56015: LD_VAR 0 4
56019: PPUSH
56020: LD_INT 0
56022: PPUSH
56023: CALL_OW 1
56027: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56028: LD_ADDR_EXP 66
56032: PUSH
56033: LD_EXP 66
56037: PPUSH
56038: LD_VAR 0 4
56042: PPUSH
56043: LD_INT 0
56045: PPUSH
56046: CALL_OW 1
56050: ST_TO_ADDR
// result := base ;
56051: LD_ADDR_VAR 0 3
56055: PUSH
56056: LD_VAR 0 4
56060: ST_TO_ADDR
// end ;
56061: LD_VAR 0 3
56065: RET
// export function MC_Start ( ) ; var i ; begin
56066: LD_INT 0
56068: PPUSH
56069: PPUSH
// for i = 1 to mc_bases do
56070: LD_ADDR_VAR 0 2
56074: PUSH
56075: DOUBLE
56076: LD_INT 1
56078: DEC
56079: ST_TO_ADDR
56080: LD_EXP 23
56084: PUSH
56085: FOR_TO
56086: IFFALSE 57186
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56088: LD_ADDR_EXP 23
56092: PUSH
56093: LD_EXP 23
56097: PPUSH
56098: LD_VAR 0 2
56102: PPUSH
56103: LD_EXP 23
56107: PUSH
56108: LD_VAR 0 2
56112: ARRAY
56113: PUSH
56114: LD_INT 0
56116: DIFF
56117: PPUSH
56118: CALL_OW 1
56122: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56123: LD_ADDR_EXP 24
56127: PUSH
56128: LD_EXP 24
56132: PPUSH
56133: LD_VAR 0 2
56137: PPUSH
56138: EMPTY
56139: PPUSH
56140: CALL_OW 1
56144: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56145: LD_ADDR_EXP 25
56149: PUSH
56150: LD_EXP 25
56154: PPUSH
56155: LD_VAR 0 2
56159: PPUSH
56160: EMPTY
56161: PPUSH
56162: CALL_OW 1
56166: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56167: LD_ADDR_EXP 26
56171: PUSH
56172: LD_EXP 26
56176: PPUSH
56177: LD_VAR 0 2
56181: PPUSH
56182: EMPTY
56183: PPUSH
56184: CALL_OW 1
56188: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56189: LD_ADDR_EXP 27
56193: PUSH
56194: LD_EXP 27
56198: PPUSH
56199: LD_VAR 0 2
56203: PPUSH
56204: EMPTY
56205: PUSH
56206: EMPTY
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: PPUSH
56212: CALL_OW 1
56216: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56217: LD_ADDR_EXP 28
56221: PUSH
56222: LD_EXP 28
56226: PPUSH
56227: LD_VAR 0 2
56231: PPUSH
56232: EMPTY
56233: PPUSH
56234: CALL_OW 1
56238: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56239: LD_ADDR_EXP 55
56243: PUSH
56244: LD_EXP 55
56248: PPUSH
56249: LD_VAR 0 2
56253: PPUSH
56254: EMPTY
56255: PPUSH
56256: CALL_OW 1
56260: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56261: LD_ADDR_EXP 29
56265: PUSH
56266: LD_EXP 29
56270: PPUSH
56271: LD_VAR 0 2
56275: PPUSH
56276: EMPTY
56277: PPUSH
56278: CALL_OW 1
56282: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56283: LD_ADDR_EXP 30
56287: PUSH
56288: LD_EXP 30
56292: PPUSH
56293: LD_VAR 0 2
56297: PPUSH
56298: EMPTY
56299: PPUSH
56300: CALL_OW 1
56304: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56305: LD_ADDR_EXP 31
56309: PUSH
56310: LD_EXP 31
56314: PPUSH
56315: LD_VAR 0 2
56319: PPUSH
56320: LD_EXP 23
56324: PUSH
56325: LD_VAR 0 2
56329: ARRAY
56330: PPUSH
56331: LD_INT 2
56333: PUSH
56334: LD_INT 30
56336: PUSH
56337: LD_INT 32
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: PUSH
56344: LD_INT 30
56346: PUSH
56347: LD_INT 33
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: PUSH
56354: EMPTY
56355: LIST
56356: LIST
56357: LIST
56358: PPUSH
56359: CALL_OW 72
56363: PPUSH
56364: CALL_OW 1
56368: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56369: LD_ADDR_EXP 32
56373: PUSH
56374: LD_EXP 32
56378: PPUSH
56379: LD_VAR 0 2
56383: PPUSH
56384: LD_EXP 23
56388: PUSH
56389: LD_VAR 0 2
56393: ARRAY
56394: PPUSH
56395: LD_INT 2
56397: PUSH
56398: LD_INT 30
56400: PUSH
56401: LD_INT 32
56403: PUSH
56404: EMPTY
56405: LIST
56406: LIST
56407: PUSH
56408: LD_INT 30
56410: PUSH
56411: LD_INT 31
56413: PUSH
56414: EMPTY
56415: LIST
56416: LIST
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: LIST
56422: PUSH
56423: LD_INT 58
56425: PUSH
56426: EMPTY
56427: LIST
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PPUSH
56433: CALL_OW 72
56437: PPUSH
56438: CALL_OW 1
56442: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56443: LD_ADDR_EXP 33
56447: PUSH
56448: LD_EXP 33
56452: PPUSH
56453: LD_VAR 0 2
56457: PPUSH
56458: EMPTY
56459: PPUSH
56460: CALL_OW 1
56464: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56465: LD_ADDR_EXP 37
56469: PUSH
56470: LD_EXP 37
56474: PPUSH
56475: LD_VAR 0 2
56479: PPUSH
56480: EMPTY
56481: PPUSH
56482: CALL_OW 1
56486: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56487: LD_ADDR_EXP 36
56491: PUSH
56492: LD_EXP 36
56496: PPUSH
56497: LD_VAR 0 2
56501: PPUSH
56502: EMPTY
56503: PPUSH
56504: CALL_OW 1
56508: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56509: LD_ADDR_EXP 38
56513: PUSH
56514: LD_EXP 38
56518: PPUSH
56519: LD_VAR 0 2
56523: PPUSH
56524: EMPTY
56525: PPUSH
56526: CALL_OW 1
56530: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56531: LD_ADDR_EXP 39
56535: PUSH
56536: LD_EXP 39
56540: PPUSH
56541: LD_VAR 0 2
56545: PPUSH
56546: EMPTY
56547: PPUSH
56548: CALL_OW 1
56552: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
56553: LD_ADDR_EXP 40
56557: PUSH
56558: LD_EXP 40
56562: PPUSH
56563: LD_VAR 0 2
56567: PPUSH
56568: EMPTY
56569: PPUSH
56570: CALL_OW 1
56574: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
56575: LD_ADDR_EXP 41
56579: PUSH
56580: LD_EXP 41
56584: PPUSH
56585: LD_VAR 0 2
56589: PPUSH
56590: EMPTY
56591: PPUSH
56592: CALL_OW 1
56596: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
56597: LD_ADDR_EXP 42
56601: PUSH
56602: LD_EXP 42
56606: PPUSH
56607: LD_VAR 0 2
56611: PPUSH
56612: EMPTY
56613: PPUSH
56614: CALL_OW 1
56618: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
56619: LD_ADDR_EXP 43
56623: PUSH
56624: LD_EXP 43
56628: PPUSH
56629: LD_VAR 0 2
56633: PPUSH
56634: EMPTY
56635: PPUSH
56636: CALL_OW 1
56640: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
56641: LD_ADDR_EXP 44
56645: PUSH
56646: LD_EXP 44
56650: PPUSH
56651: LD_VAR 0 2
56655: PPUSH
56656: EMPTY
56657: PPUSH
56658: CALL_OW 1
56662: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56663: LD_ADDR_EXP 45
56667: PUSH
56668: LD_EXP 45
56672: PPUSH
56673: LD_VAR 0 2
56677: PPUSH
56678: EMPTY
56679: PPUSH
56680: CALL_OW 1
56684: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
56685: LD_ADDR_EXP 34
56689: PUSH
56690: LD_EXP 34
56694: PPUSH
56695: LD_VAR 0 2
56699: PPUSH
56700: LD_INT 0
56702: PPUSH
56703: CALL_OW 1
56707: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
56708: LD_ADDR_EXP 47
56712: PUSH
56713: LD_EXP 47
56717: PPUSH
56718: LD_VAR 0 2
56722: PPUSH
56723: LD_INT 0
56725: PPUSH
56726: CALL_OW 1
56730: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56731: LD_ADDR_EXP 35
56735: PUSH
56736: LD_EXP 35
56740: PPUSH
56741: LD_VAR 0 2
56745: PPUSH
56746: EMPTY
56747: PPUSH
56748: CALL_OW 1
56752: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
56753: LD_ADDR_EXP 46
56757: PUSH
56758: LD_EXP 46
56762: PPUSH
56763: LD_VAR 0 2
56767: PPUSH
56768: LD_INT 0
56770: PPUSH
56771: CALL_OW 1
56775: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
56776: LD_ADDR_EXP 48
56780: PUSH
56781: LD_EXP 48
56785: PPUSH
56786: LD_VAR 0 2
56790: PPUSH
56791: EMPTY
56792: PPUSH
56793: CALL_OW 1
56797: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
56798: LD_ADDR_EXP 51
56802: PUSH
56803: LD_EXP 51
56807: PPUSH
56808: LD_VAR 0 2
56812: PPUSH
56813: LD_INT 0
56815: PPUSH
56816: CALL_OW 1
56820: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
56821: LD_ADDR_EXP 52
56825: PUSH
56826: LD_EXP 52
56830: PPUSH
56831: LD_VAR 0 2
56835: PPUSH
56836: EMPTY
56837: PPUSH
56838: CALL_OW 1
56842: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56843: LD_ADDR_EXP 53
56847: PUSH
56848: LD_EXP 53
56852: PPUSH
56853: LD_VAR 0 2
56857: PPUSH
56858: EMPTY
56859: PPUSH
56860: CALL_OW 1
56864: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
56865: LD_ADDR_EXP 54
56869: PUSH
56870: LD_EXP 54
56874: PPUSH
56875: LD_VAR 0 2
56879: PPUSH
56880: EMPTY
56881: PPUSH
56882: CALL_OW 1
56886: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
56887: LD_ADDR_EXP 56
56891: PUSH
56892: LD_EXP 56
56896: PPUSH
56897: LD_VAR 0 2
56901: PPUSH
56902: LD_EXP 23
56906: PUSH
56907: LD_VAR 0 2
56911: ARRAY
56912: PPUSH
56913: LD_INT 2
56915: PUSH
56916: LD_INT 30
56918: PUSH
56919: LD_INT 6
56921: PUSH
56922: EMPTY
56923: LIST
56924: LIST
56925: PUSH
56926: LD_INT 30
56928: PUSH
56929: LD_INT 7
56931: PUSH
56932: EMPTY
56933: LIST
56934: LIST
56935: PUSH
56936: LD_INT 30
56938: PUSH
56939: LD_INT 8
56941: PUSH
56942: EMPTY
56943: LIST
56944: LIST
56945: PUSH
56946: EMPTY
56947: LIST
56948: LIST
56949: LIST
56950: LIST
56951: PPUSH
56952: CALL_OW 72
56956: PPUSH
56957: CALL_OW 1
56961: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
56962: LD_ADDR_EXP 57
56966: PUSH
56967: LD_EXP 57
56971: PPUSH
56972: LD_VAR 0 2
56976: PPUSH
56977: EMPTY
56978: PPUSH
56979: CALL_OW 1
56983: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
56984: LD_ADDR_EXP 58
56988: PUSH
56989: LD_EXP 58
56993: PPUSH
56994: LD_VAR 0 2
56998: PPUSH
56999: EMPTY
57000: PPUSH
57001: CALL_OW 1
57005: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57006: LD_ADDR_EXP 59
57010: PUSH
57011: LD_EXP 59
57015: PPUSH
57016: LD_VAR 0 2
57020: PPUSH
57021: EMPTY
57022: PPUSH
57023: CALL_OW 1
57027: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57028: LD_ADDR_EXP 60
57032: PUSH
57033: LD_EXP 60
57037: PPUSH
57038: LD_VAR 0 2
57042: PPUSH
57043: EMPTY
57044: PPUSH
57045: CALL_OW 1
57049: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57050: LD_ADDR_EXP 61
57054: PUSH
57055: LD_EXP 61
57059: PPUSH
57060: LD_VAR 0 2
57064: PPUSH
57065: EMPTY
57066: PPUSH
57067: CALL_OW 1
57071: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57072: LD_ADDR_EXP 62
57076: PUSH
57077: LD_EXP 62
57081: PPUSH
57082: LD_VAR 0 2
57086: PPUSH
57087: EMPTY
57088: PPUSH
57089: CALL_OW 1
57093: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57094: LD_ADDR_EXP 63
57098: PUSH
57099: LD_EXP 63
57103: PPUSH
57104: LD_VAR 0 2
57108: PPUSH
57109: EMPTY
57110: PPUSH
57111: CALL_OW 1
57115: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57116: LD_ADDR_EXP 64
57120: PUSH
57121: LD_EXP 64
57125: PPUSH
57126: LD_VAR 0 2
57130: PPUSH
57131: EMPTY
57132: PPUSH
57133: CALL_OW 1
57137: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57138: LD_ADDR_EXP 65
57142: PUSH
57143: LD_EXP 65
57147: PPUSH
57148: LD_VAR 0 2
57152: PPUSH
57153: LD_INT 0
57155: PPUSH
57156: CALL_OW 1
57160: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
57161: LD_ADDR_EXP 66
57165: PUSH
57166: LD_EXP 66
57170: PPUSH
57171: LD_VAR 0 2
57175: PPUSH
57176: LD_INT 0
57178: PPUSH
57179: CALL_OW 1
57183: ST_TO_ADDR
// end ;
57184: GO 56085
57186: POP
57187: POP
// MC_InitSides ( ) ;
57188: CALL 57474 0 0
// MC_InitResearch ( ) ;
57192: CALL 57213 0 0
// CustomInitMacro ( ) ;
57196: CALL 273 0 0
// skirmish := true ;
57200: LD_ADDR_EXP 21
57204: PUSH
57205: LD_INT 1
57207: ST_TO_ADDR
// end ;
57208: LD_VAR 0 1
57212: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57213: LD_INT 0
57215: PPUSH
57216: PPUSH
57217: PPUSH
57218: PPUSH
57219: PPUSH
57220: PPUSH
// if not mc_bases then
57221: LD_EXP 23
57225: NOT
57226: IFFALSE 57230
// exit ;
57228: GO 57469
// for i = 1 to 8 do
57230: LD_ADDR_VAR 0 2
57234: PUSH
57235: DOUBLE
57236: LD_INT 1
57238: DEC
57239: ST_TO_ADDR
57240: LD_INT 8
57242: PUSH
57243: FOR_TO
57244: IFFALSE 57270
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57246: LD_ADDR_EXP 50
57250: PUSH
57251: LD_EXP 50
57255: PPUSH
57256: LD_VAR 0 2
57260: PPUSH
57261: EMPTY
57262: PPUSH
57263: CALL_OW 1
57267: ST_TO_ADDR
57268: GO 57243
57270: POP
57271: POP
// tmp := [ ] ;
57272: LD_ADDR_VAR 0 5
57276: PUSH
57277: EMPTY
57278: ST_TO_ADDR
// for i = 1 to mc_sides do
57279: LD_ADDR_VAR 0 2
57283: PUSH
57284: DOUBLE
57285: LD_INT 1
57287: DEC
57288: ST_TO_ADDR
57289: LD_EXP 49
57293: PUSH
57294: FOR_TO
57295: IFFALSE 57353
// if not mc_sides [ i ] in tmp then
57297: LD_EXP 49
57301: PUSH
57302: LD_VAR 0 2
57306: ARRAY
57307: PUSH
57308: LD_VAR 0 5
57312: IN
57313: NOT
57314: IFFALSE 57351
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57316: LD_ADDR_VAR 0 5
57320: PUSH
57321: LD_VAR 0 5
57325: PPUSH
57326: LD_VAR 0 5
57330: PUSH
57331: LD_INT 1
57333: PLUS
57334: PPUSH
57335: LD_EXP 49
57339: PUSH
57340: LD_VAR 0 2
57344: ARRAY
57345: PPUSH
57346: CALL_OW 2
57350: ST_TO_ADDR
57351: GO 57294
57353: POP
57354: POP
// if not tmp then
57355: LD_VAR 0 5
57359: NOT
57360: IFFALSE 57364
// exit ;
57362: GO 57469
// for j in tmp do
57364: LD_ADDR_VAR 0 3
57368: PUSH
57369: LD_VAR 0 5
57373: PUSH
57374: FOR_IN
57375: IFFALSE 57467
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57377: LD_ADDR_VAR 0 6
57381: PUSH
57382: LD_INT 22
57384: PUSH
57385: LD_VAR 0 3
57389: PUSH
57390: EMPTY
57391: LIST
57392: LIST
57393: PPUSH
57394: CALL_OW 69
57398: ST_TO_ADDR
// if not un then
57399: LD_VAR 0 6
57403: NOT
57404: IFFALSE 57408
// continue ;
57406: GO 57374
// nation := GetNation ( un [ 1 ] ) ;
57408: LD_ADDR_VAR 0 4
57412: PUSH
57413: LD_VAR 0 6
57417: PUSH
57418: LD_INT 1
57420: ARRAY
57421: PPUSH
57422: CALL_OW 248
57426: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57427: LD_ADDR_EXP 50
57431: PUSH
57432: LD_EXP 50
57436: PPUSH
57437: LD_VAR 0 3
57441: PPUSH
57442: LD_VAR 0 3
57446: PPUSH
57447: LD_VAR 0 4
57451: PPUSH
57452: LD_INT 1
57454: PPUSH
57455: CALL 11178 0 3
57459: PPUSH
57460: CALL_OW 1
57464: ST_TO_ADDR
// end ;
57465: GO 57374
57467: POP
57468: POP
// end ;
57469: LD_VAR 0 1
57473: RET
// export function MC_InitSides ( ) ; var i ; begin
57474: LD_INT 0
57476: PPUSH
57477: PPUSH
// if not mc_bases then
57478: LD_EXP 23
57482: NOT
57483: IFFALSE 57487
// exit ;
57485: GO 57561
// for i = 1 to mc_bases do
57487: LD_ADDR_VAR 0 2
57491: PUSH
57492: DOUBLE
57493: LD_INT 1
57495: DEC
57496: ST_TO_ADDR
57497: LD_EXP 23
57501: PUSH
57502: FOR_TO
57503: IFFALSE 57559
// if mc_bases [ i ] then
57505: LD_EXP 23
57509: PUSH
57510: LD_VAR 0 2
57514: ARRAY
57515: IFFALSE 57557
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57517: LD_ADDR_EXP 49
57521: PUSH
57522: LD_EXP 49
57526: PPUSH
57527: LD_VAR 0 2
57531: PPUSH
57532: LD_EXP 23
57536: PUSH
57537: LD_VAR 0 2
57541: ARRAY
57542: PUSH
57543: LD_INT 1
57545: ARRAY
57546: PPUSH
57547: CALL_OW 255
57551: PPUSH
57552: CALL_OW 1
57556: ST_TO_ADDR
57557: GO 57502
57559: POP
57560: POP
// end ;
57561: LD_VAR 0 1
57565: RET
// every 0 0$03 trigger skirmish do
57566: LD_EXP 21
57570: IFFALSE 57724
57572: GO 57574
57574: DISABLE
// begin enable ;
57575: ENABLE
// MC_CheckBuildings ( ) ;
57576: CALL 62236 0 0
// MC_CheckPeopleLife ( ) ;
57580: CALL 62397 0 0
// RaiseSailEvent ( 100 ) ;
57584: LD_INT 100
57586: PPUSH
57587: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
57591: LD_INT 103
57593: PPUSH
57594: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
57598: LD_INT 104
57600: PPUSH
57601: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
57605: LD_INT 105
57607: PPUSH
57608: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
57612: LD_INT 106
57614: PPUSH
57615: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
57619: LD_INT 107
57621: PPUSH
57622: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
57626: LD_INT 108
57628: PPUSH
57629: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
57633: LD_INT 109
57635: PPUSH
57636: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
57640: LD_INT 110
57642: PPUSH
57643: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
57647: LD_INT 111
57649: PPUSH
57650: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
57654: LD_INT 112
57656: PPUSH
57657: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
57661: LD_INT 113
57663: PPUSH
57664: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
57668: LD_INT 120
57670: PPUSH
57671: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
57675: LD_INT 121
57677: PPUSH
57678: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
57682: LD_INT 122
57684: PPUSH
57685: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
57689: LD_INT 123
57691: PPUSH
57692: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
57696: LD_INT 124
57698: PPUSH
57699: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
57703: LD_INT 125
57705: PPUSH
57706: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
57710: LD_INT 126
57712: PPUSH
57713: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
57717: LD_INT 200
57719: PPUSH
57720: CALL_OW 427
// end ;
57724: END
// on SailEvent ( event ) do begin if event < 100 then
57725: LD_VAR 0 1
57729: PUSH
57730: LD_INT 100
57732: LESS
57733: IFFALSE 57744
// CustomEvent ( event ) ;
57735: LD_VAR 0 1
57739: PPUSH
57740: CALL 10329 0 1
// if event = 100 then
57744: LD_VAR 0 1
57748: PUSH
57749: LD_INT 100
57751: EQUAL
57752: IFFALSE 57758
// MC_ClassManager ( ) ;
57754: CALL 58150 0 0
// if event = 101 then
57758: LD_VAR 0 1
57762: PUSH
57763: LD_INT 101
57765: EQUAL
57766: IFFALSE 57772
// MC_RepairBuildings ( ) ;
57768: CALL 62982 0 0
// if event = 102 then
57772: LD_VAR 0 1
57776: PUSH
57777: LD_INT 102
57779: EQUAL
57780: IFFALSE 57786
// MC_Heal ( ) ;
57782: CALL 63917 0 0
// if event = 103 then
57786: LD_VAR 0 1
57790: PUSH
57791: LD_INT 103
57793: EQUAL
57794: IFFALSE 57800
// MC_Build ( ) ;
57796: CALL 64339 0 0
// if event = 104 then
57800: LD_VAR 0 1
57804: PUSH
57805: LD_INT 104
57807: EQUAL
57808: IFFALSE 57814
// MC_TurretWeapon ( ) ;
57810: CALL 65973 0 0
// if event = 105 then
57814: LD_VAR 0 1
57818: PUSH
57819: LD_INT 105
57821: EQUAL
57822: IFFALSE 57828
// MC_BuildUpgrade ( ) ;
57824: CALL 65524 0 0
// if event = 106 then
57828: LD_VAR 0 1
57832: PUSH
57833: LD_INT 106
57835: EQUAL
57836: IFFALSE 57842
// MC_PlantMines ( ) ;
57838: CALL 66403 0 0
// if event = 107 then
57842: LD_VAR 0 1
57846: PUSH
57847: LD_INT 107
57849: EQUAL
57850: IFFALSE 57856
// MC_CollectCrates ( ) ;
57852: CALL 67201 0 0
// if event = 108 then
57856: LD_VAR 0 1
57860: PUSH
57861: LD_INT 108
57863: EQUAL
57864: IFFALSE 57870
// MC_LinkRemoteControl ( ) ;
57866: CALL 69051 0 0
// if event = 109 then
57870: LD_VAR 0 1
57874: PUSH
57875: LD_INT 109
57877: EQUAL
57878: IFFALSE 57884
// MC_ProduceVehicle ( ) ;
57880: CALL 69232 0 0
// if event = 110 then
57884: LD_VAR 0 1
57888: PUSH
57889: LD_INT 110
57891: EQUAL
57892: IFFALSE 57898
// MC_SendAttack ( ) ;
57894: CALL 69698 0 0
// if event = 111 then
57898: LD_VAR 0 1
57902: PUSH
57903: LD_INT 111
57905: EQUAL
57906: IFFALSE 57912
// MC_Defend ( ) ;
57908: CALL 69806 0 0
// if event = 112 then
57912: LD_VAR 0 1
57916: PUSH
57917: LD_INT 112
57919: EQUAL
57920: IFFALSE 57926
// MC_Research ( ) ;
57922: CALL 70686 0 0
// if event = 113 then
57926: LD_VAR 0 1
57930: PUSH
57931: LD_INT 113
57933: EQUAL
57934: IFFALSE 57940
// MC_MinesTrigger ( ) ;
57936: CALL 71800 0 0
// if event = 120 then
57940: LD_VAR 0 1
57944: PUSH
57945: LD_INT 120
57947: EQUAL
57948: IFFALSE 57954
// MC_RepairVehicle ( ) ;
57950: CALL 71899 0 0
// if event = 121 then
57954: LD_VAR 0 1
57958: PUSH
57959: LD_INT 121
57961: EQUAL
57962: IFFALSE 57968
// MC_TameApe ( ) ;
57964: CALL 72668 0 0
// if event = 122 then
57968: LD_VAR 0 1
57972: PUSH
57973: LD_INT 122
57975: EQUAL
57976: IFFALSE 57982
// MC_ChangeApeClass ( ) ;
57978: CALL 73497 0 0
// if event = 123 then
57982: LD_VAR 0 1
57986: PUSH
57987: LD_INT 123
57989: EQUAL
57990: IFFALSE 57996
// MC_Bazooka ( ) ;
57992: CALL 74147 0 0
// if event = 124 then
57996: LD_VAR 0 1
58000: PUSH
58001: LD_INT 124
58003: EQUAL
58004: IFFALSE 58010
// MC_TeleportExit ( ) ;
58006: CALL 74345 0 0
// if event = 125 then
58010: LD_VAR 0 1
58014: PUSH
58015: LD_INT 125
58017: EQUAL
58018: IFFALSE 58024
// MC_Deposits ( ) ;
58020: CALL 74992 0 0
// if event = 126 then
58024: LD_VAR 0 1
58028: PUSH
58029: LD_INT 126
58031: EQUAL
58032: IFFALSE 58038
// MC_RemoteDriver ( ) ;
58034: CALL 75617 0 0
// if event = 200 then
58038: LD_VAR 0 1
58042: PUSH
58043: LD_INT 200
58045: EQUAL
58046: IFFALSE 58052
// MC_Idle ( ) ;
58048: CALL 77524 0 0
// end ;
58052: PPOPN 1
58054: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58055: LD_INT 0
58057: PPUSH
58058: PPUSH
// if not mc_bases [ base ] or not tag then
58059: LD_EXP 23
58063: PUSH
58064: LD_VAR 0 1
58068: ARRAY
58069: NOT
58070: PUSH
58071: LD_VAR 0 2
58075: NOT
58076: OR
58077: IFFALSE 58081
// exit ;
58079: GO 58145
// for i in mc_bases [ base ] union mc_ape [ base ] do
58081: LD_ADDR_VAR 0 4
58085: PUSH
58086: LD_EXP 23
58090: PUSH
58091: LD_VAR 0 1
58095: ARRAY
58096: PUSH
58097: LD_EXP 52
58101: PUSH
58102: LD_VAR 0 1
58106: ARRAY
58107: UNION
58108: PUSH
58109: FOR_IN
58110: IFFALSE 58143
// if GetTag ( i ) = tag then
58112: LD_VAR 0 4
58116: PPUSH
58117: CALL_OW 110
58121: PUSH
58122: LD_VAR 0 2
58126: EQUAL
58127: IFFALSE 58141
// SetTag ( i , 0 ) ;
58129: LD_VAR 0 4
58133: PPUSH
58134: LD_INT 0
58136: PPUSH
58137: CALL_OW 109
58141: GO 58109
58143: POP
58144: POP
// end ;
58145: LD_VAR 0 3
58149: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58150: LD_INT 0
58152: PPUSH
58153: PPUSH
58154: PPUSH
58155: PPUSH
58156: PPUSH
58157: PPUSH
58158: PPUSH
58159: PPUSH
// if not mc_bases then
58160: LD_EXP 23
58164: NOT
58165: IFFALSE 58169
// exit ;
58167: GO 58618
// for i = 1 to mc_bases do
58169: LD_ADDR_VAR 0 2
58173: PUSH
58174: DOUBLE
58175: LD_INT 1
58177: DEC
58178: ST_TO_ADDR
58179: LD_EXP 23
58183: PUSH
58184: FOR_TO
58185: IFFALSE 58616
// begin tmp := MC_ClassCheckReq ( i ) ;
58187: LD_ADDR_VAR 0 4
58191: PUSH
58192: LD_VAR 0 2
58196: PPUSH
58197: CALL 58623 0 1
58201: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58202: LD_ADDR_EXP 64
58206: PUSH
58207: LD_EXP 64
58211: PPUSH
58212: LD_VAR 0 2
58216: PPUSH
58217: LD_VAR 0 4
58221: PPUSH
58222: CALL_OW 1
58226: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58227: LD_ADDR_VAR 0 6
58231: PUSH
58232: LD_EXP 23
58236: PUSH
58237: LD_VAR 0 2
58241: ARRAY
58242: PPUSH
58243: LD_INT 2
58245: PUSH
58246: LD_INT 30
58248: PUSH
58249: LD_INT 4
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: PUSH
58256: LD_INT 30
58258: PUSH
58259: LD_INT 5
58261: PUSH
58262: EMPTY
58263: LIST
58264: LIST
58265: PUSH
58266: EMPTY
58267: LIST
58268: LIST
58269: LIST
58270: PPUSH
58271: CALL_OW 72
58275: PUSH
58276: LD_EXP 23
58280: PUSH
58281: LD_VAR 0 2
58285: ARRAY
58286: PPUSH
58287: LD_INT 2
58289: PUSH
58290: LD_INT 30
58292: PUSH
58293: LD_INT 0
58295: PUSH
58296: EMPTY
58297: LIST
58298: LIST
58299: PUSH
58300: LD_INT 30
58302: PUSH
58303: LD_INT 1
58305: PUSH
58306: EMPTY
58307: LIST
58308: LIST
58309: PUSH
58310: EMPTY
58311: LIST
58312: LIST
58313: LIST
58314: PPUSH
58315: CALL_OW 72
58319: PUSH
58320: LD_EXP 23
58324: PUSH
58325: LD_VAR 0 2
58329: ARRAY
58330: PPUSH
58331: LD_INT 30
58333: PUSH
58334: LD_INT 3
58336: PUSH
58337: EMPTY
58338: LIST
58339: LIST
58340: PPUSH
58341: CALL_OW 72
58345: PUSH
58346: LD_EXP 23
58350: PUSH
58351: LD_VAR 0 2
58355: ARRAY
58356: PPUSH
58357: LD_INT 2
58359: PUSH
58360: LD_INT 30
58362: PUSH
58363: LD_INT 6
58365: PUSH
58366: EMPTY
58367: LIST
58368: LIST
58369: PUSH
58370: LD_INT 30
58372: PUSH
58373: LD_INT 7
58375: PUSH
58376: EMPTY
58377: LIST
58378: LIST
58379: PUSH
58380: LD_INT 30
58382: PUSH
58383: LD_INT 8
58385: PUSH
58386: EMPTY
58387: LIST
58388: LIST
58389: PUSH
58390: EMPTY
58391: LIST
58392: LIST
58393: LIST
58394: LIST
58395: PPUSH
58396: CALL_OW 72
58400: PUSH
58401: EMPTY
58402: LIST
58403: LIST
58404: LIST
58405: LIST
58406: ST_TO_ADDR
// for j := 1 to 4 do
58407: LD_ADDR_VAR 0 3
58411: PUSH
58412: DOUBLE
58413: LD_INT 1
58415: DEC
58416: ST_TO_ADDR
58417: LD_INT 4
58419: PUSH
58420: FOR_TO
58421: IFFALSE 58612
// begin if not tmp [ j ] then
58423: LD_VAR 0 4
58427: PUSH
58428: LD_VAR 0 3
58432: ARRAY
58433: NOT
58434: IFFALSE 58438
// continue ;
58436: GO 58420
// for p in tmp [ j ] do
58438: LD_ADDR_VAR 0 5
58442: PUSH
58443: LD_VAR 0 4
58447: PUSH
58448: LD_VAR 0 3
58452: ARRAY
58453: PUSH
58454: FOR_IN
58455: IFFALSE 58608
// begin if not b [ j ] then
58457: LD_VAR 0 6
58461: PUSH
58462: LD_VAR 0 3
58466: ARRAY
58467: NOT
58468: IFFALSE 58472
// break ;
58470: GO 58608
// e := 0 ;
58472: LD_ADDR_VAR 0 7
58476: PUSH
58477: LD_INT 0
58479: ST_TO_ADDR
// for k in b [ j ] do
58480: LD_ADDR_VAR 0 8
58484: PUSH
58485: LD_VAR 0 6
58489: PUSH
58490: LD_VAR 0 3
58494: ARRAY
58495: PUSH
58496: FOR_IN
58497: IFFALSE 58524
// if IsNotFull ( k ) then
58499: LD_VAR 0 8
58503: PPUSH
58504: CALL 13299 0 1
58508: IFFALSE 58522
// begin e := k ;
58510: LD_ADDR_VAR 0 7
58514: PUSH
58515: LD_VAR 0 8
58519: ST_TO_ADDR
// break ;
58520: GO 58524
// end ;
58522: GO 58496
58524: POP
58525: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58526: LD_VAR 0 7
58530: PUSH
58531: LD_VAR 0 5
58535: PPUSH
58536: LD_VAR 0 7
58540: PPUSH
58541: CALL 47438 0 2
58545: NOT
58546: AND
58547: IFFALSE 58606
// begin if IsInUnit ( p ) then
58549: LD_VAR 0 5
58553: PPUSH
58554: CALL_OW 310
58558: IFFALSE 58569
// ComExitBuilding ( p ) ;
58560: LD_VAR 0 5
58564: PPUSH
58565: CALL_OW 122
// ComEnterUnit ( p , e ) ;
58569: LD_VAR 0 5
58573: PPUSH
58574: LD_VAR 0 7
58578: PPUSH
58579: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
58583: LD_VAR 0 5
58587: PPUSH
58588: LD_VAR 0 3
58592: PPUSH
58593: CALL_OW 183
// AddComExitBuilding ( p ) ;
58597: LD_VAR 0 5
58601: PPUSH
58602: CALL_OW 182
// end ; end ;
58606: GO 58454
58608: POP
58609: POP
// end ;
58610: GO 58420
58612: POP
58613: POP
// end ;
58614: GO 58184
58616: POP
58617: POP
// end ;
58618: LD_VAR 0 1
58622: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
58623: LD_INT 0
58625: PPUSH
58626: PPUSH
58627: PPUSH
58628: PPUSH
58629: PPUSH
58630: PPUSH
58631: PPUSH
58632: PPUSH
58633: PPUSH
58634: PPUSH
58635: PPUSH
58636: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
58637: LD_ADDR_VAR 0 2
58641: PUSH
58642: LD_INT 0
58644: PUSH
58645: LD_INT 0
58647: PUSH
58648: LD_INT 0
58650: PUSH
58651: LD_INT 0
58653: PUSH
58654: EMPTY
58655: LIST
58656: LIST
58657: LIST
58658: LIST
58659: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
58660: LD_VAR 0 1
58664: NOT
58665: PUSH
58666: LD_EXP 23
58670: PUSH
58671: LD_VAR 0 1
58675: ARRAY
58676: NOT
58677: OR
58678: PUSH
58679: LD_EXP 23
58683: PUSH
58684: LD_VAR 0 1
58688: ARRAY
58689: PPUSH
58690: LD_INT 2
58692: PUSH
58693: LD_INT 30
58695: PUSH
58696: LD_INT 0
58698: PUSH
58699: EMPTY
58700: LIST
58701: LIST
58702: PUSH
58703: LD_INT 30
58705: PUSH
58706: LD_INT 1
58708: PUSH
58709: EMPTY
58710: LIST
58711: LIST
58712: PUSH
58713: EMPTY
58714: LIST
58715: LIST
58716: LIST
58717: PPUSH
58718: CALL_OW 72
58722: NOT
58723: OR
58724: IFFALSE 58728
// exit ;
58726: GO 62231
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58728: LD_ADDR_VAR 0 4
58732: PUSH
58733: LD_EXP 23
58737: PUSH
58738: LD_VAR 0 1
58742: ARRAY
58743: PPUSH
58744: LD_INT 2
58746: PUSH
58747: LD_INT 25
58749: PUSH
58750: LD_INT 1
58752: PUSH
58753: EMPTY
58754: LIST
58755: LIST
58756: PUSH
58757: LD_INT 25
58759: PUSH
58760: LD_INT 2
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: PUSH
58767: LD_INT 25
58769: PUSH
58770: LD_INT 3
58772: PUSH
58773: EMPTY
58774: LIST
58775: LIST
58776: PUSH
58777: LD_INT 25
58779: PUSH
58780: LD_INT 4
58782: PUSH
58783: EMPTY
58784: LIST
58785: LIST
58786: PUSH
58787: LD_INT 25
58789: PUSH
58790: LD_INT 5
58792: PUSH
58793: EMPTY
58794: LIST
58795: LIST
58796: PUSH
58797: LD_INT 25
58799: PUSH
58800: LD_INT 8
58802: PUSH
58803: EMPTY
58804: LIST
58805: LIST
58806: PUSH
58807: LD_INT 25
58809: PUSH
58810: LD_INT 9
58812: PUSH
58813: EMPTY
58814: LIST
58815: LIST
58816: PUSH
58817: EMPTY
58818: LIST
58819: LIST
58820: LIST
58821: LIST
58822: LIST
58823: LIST
58824: LIST
58825: LIST
58826: PPUSH
58827: CALL_OW 72
58831: ST_TO_ADDR
// if not tmp then
58832: LD_VAR 0 4
58836: NOT
58837: IFFALSE 58841
// exit ;
58839: GO 62231
// for i in tmp do
58841: LD_ADDR_VAR 0 3
58845: PUSH
58846: LD_VAR 0 4
58850: PUSH
58851: FOR_IN
58852: IFFALSE 58883
// if GetTag ( i ) then
58854: LD_VAR 0 3
58858: PPUSH
58859: CALL_OW 110
58863: IFFALSE 58881
// tmp := tmp diff i ;
58865: LD_ADDR_VAR 0 4
58869: PUSH
58870: LD_VAR 0 4
58874: PUSH
58875: LD_VAR 0 3
58879: DIFF
58880: ST_TO_ADDR
58881: GO 58851
58883: POP
58884: POP
// if not tmp then
58885: LD_VAR 0 4
58889: NOT
58890: IFFALSE 58894
// exit ;
58892: GO 62231
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58894: LD_ADDR_VAR 0 5
58898: PUSH
58899: LD_EXP 23
58903: PUSH
58904: LD_VAR 0 1
58908: ARRAY
58909: PPUSH
58910: LD_INT 2
58912: PUSH
58913: LD_INT 25
58915: PUSH
58916: LD_INT 1
58918: PUSH
58919: EMPTY
58920: LIST
58921: LIST
58922: PUSH
58923: LD_INT 25
58925: PUSH
58926: LD_INT 5
58928: PUSH
58929: EMPTY
58930: LIST
58931: LIST
58932: PUSH
58933: LD_INT 25
58935: PUSH
58936: LD_INT 8
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: PUSH
58943: LD_INT 25
58945: PUSH
58946: LD_INT 9
58948: PUSH
58949: EMPTY
58950: LIST
58951: LIST
58952: PUSH
58953: EMPTY
58954: LIST
58955: LIST
58956: LIST
58957: LIST
58958: LIST
58959: PPUSH
58960: CALL_OW 72
58964: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
58965: LD_ADDR_VAR 0 6
58969: PUSH
58970: LD_EXP 23
58974: PUSH
58975: LD_VAR 0 1
58979: ARRAY
58980: PPUSH
58981: LD_INT 25
58983: PUSH
58984: LD_INT 2
58986: PUSH
58987: EMPTY
58988: LIST
58989: LIST
58990: PPUSH
58991: CALL_OW 72
58995: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
58996: LD_ADDR_VAR 0 7
59000: PUSH
59001: LD_EXP 23
59005: PUSH
59006: LD_VAR 0 1
59010: ARRAY
59011: PPUSH
59012: LD_INT 25
59014: PUSH
59015: LD_INT 3
59017: PUSH
59018: EMPTY
59019: LIST
59020: LIST
59021: PPUSH
59022: CALL_OW 72
59026: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59027: LD_ADDR_VAR 0 8
59031: PUSH
59032: LD_EXP 23
59036: PUSH
59037: LD_VAR 0 1
59041: ARRAY
59042: PPUSH
59043: LD_INT 25
59045: PUSH
59046: LD_INT 4
59048: PUSH
59049: EMPTY
59050: LIST
59051: LIST
59052: PUSH
59053: LD_INT 24
59055: PUSH
59056: LD_INT 251
59058: PUSH
59059: EMPTY
59060: LIST
59061: LIST
59062: PUSH
59063: EMPTY
59064: LIST
59065: LIST
59066: PPUSH
59067: CALL_OW 72
59071: ST_TO_ADDR
// if mc_is_defending [ base ] then
59072: LD_EXP 66
59076: PUSH
59077: LD_VAR 0 1
59081: ARRAY
59082: IFFALSE 59543
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59084: LD_ADDR_EXP 65
59088: PUSH
59089: LD_EXP 65
59093: PPUSH
59094: LD_VAR 0 1
59098: PPUSH
59099: LD_INT 4
59101: PPUSH
59102: CALL_OW 1
59106: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59107: LD_ADDR_VAR 0 12
59111: PUSH
59112: LD_EXP 23
59116: PUSH
59117: LD_VAR 0 1
59121: ARRAY
59122: PPUSH
59123: LD_INT 2
59125: PUSH
59126: LD_INT 30
59128: PUSH
59129: LD_INT 4
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: PUSH
59136: LD_INT 30
59138: PUSH
59139: LD_INT 5
59141: PUSH
59142: EMPTY
59143: LIST
59144: LIST
59145: PUSH
59146: EMPTY
59147: LIST
59148: LIST
59149: LIST
59150: PPUSH
59151: CALL_OW 72
59155: ST_TO_ADDR
// if not b then
59156: LD_VAR 0 12
59160: NOT
59161: IFFALSE 59165
// exit ;
59163: GO 62231
// p := [ ] ;
59165: LD_ADDR_VAR 0 11
59169: PUSH
59170: EMPTY
59171: ST_TO_ADDR
// if sci >= 2 then
59172: LD_VAR 0 8
59176: PUSH
59177: LD_INT 2
59179: GREATEREQUAL
59180: IFFALSE 59211
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59182: LD_ADDR_VAR 0 8
59186: PUSH
59187: LD_VAR 0 8
59191: PUSH
59192: LD_INT 1
59194: ARRAY
59195: PUSH
59196: LD_VAR 0 8
59200: PUSH
59201: LD_INT 2
59203: ARRAY
59204: PUSH
59205: EMPTY
59206: LIST
59207: LIST
59208: ST_TO_ADDR
59209: GO 59272
// if sci = 1 then
59211: LD_VAR 0 8
59215: PUSH
59216: LD_INT 1
59218: EQUAL
59219: IFFALSE 59240
// sci := [ sci [ 1 ] ] else
59221: LD_ADDR_VAR 0 8
59225: PUSH
59226: LD_VAR 0 8
59230: PUSH
59231: LD_INT 1
59233: ARRAY
59234: PUSH
59235: EMPTY
59236: LIST
59237: ST_TO_ADDR
59238: GO 59272
// if sci = 0 then
59240: LD_VAR 0 8
59244: PUSH
59245: LD_INT 0
59247: EQUAL
59248: IFFALSE 59272
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59250: LD_ADDR_VAR 0 11
59254: PUSH
59255: LD_VAR 0 4
59259: PPUSH
59260: LD_INT 4
59262: PPUSH
59263: CALL 47310 0 2
59267: PUSH
59268: LD_INT 1
59270: ARRAY
59271: ST_TO_ADDR
// if eng > 4 then
59272: LD_VAR 0 6
59276: PUSH
59277: LD_INT 4
59279: GREATER
59280: IFFALSE 59326
// for i = eng downto 4 do
59282: LD_ADDR_VAR 0 3
59286: PUSH
59287: DOUBLE
59288: LD_VAR 0 6
59292: INC
59293: ST_TO_ADDR
59294: LD_INT 4
59296: PUSH
59297: FOR_DOWNTO
59298: IFFALSE 59324
// eng := eng diff eng [ i ] ;
59300: LD_ADDR_VAR 0 6
59304: PUSH
59305: LD_VAR 0 6
59309: PUSH
59310: LD_VAR 0 6
59314: PUSH
59315: LD_VAR 0 3
59319: ARRAY
59320: DIFF
59321: ST_TO_ADDR
59322: GO 59297
59324: POP
59325: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59326: LD_ADDR_VAR 0 4
59330: PUSH
59331: LD_VAR 0 4
59335: PUSH
59336: LD_VAR 0 5
59340: PUSH
59341: LD_VAR 0 6
59345: UNION
59346: PUSH
59347: LD_VAR 0 7
59351: UNION
59352: PUSH
59353: LD_VAR 0 8
59357: UNION
59358: DIFF
59359: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59360: LD_ADDR_VAR 0 13
59364: PUSH
59365: LD_EXP 23
59369: PUSH
59370: LD_VAR 0 1
59374: ARRAY
59375: PPUSH
59376: LD_INT 2
59378: PUSH
59379: LD_INT 30
59381: PUSH
59382: LD_INT 32
59384: PUSH
59385: EMPTY
59386: LIST
59387: LIST
59388: PUSH
59389: LD_INT 30
59391: PUSH
59392: LD_INT 31
59394: PUSH
59395: EMPTY
59396: LIST
59397: LIST
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: LIST
59403: PPUSH
59404: CALL_OW 72
59408: PUSH
59409: LD_EXP 23
59413: PUSH
59414: LD_VAR 0 1
59418: ARRAY
59419: PPUSH
59420: LD_INT 2
59422: PUSH
59423: LD_INT 30
59425: PUSH
59426: LD_INT 4
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: PUSH
59433: LD_INT 30
59435: PUSH
59436: LD_INT 5
59438: PUSH
59439: EMPTY
59440: LIST
59441: LIST
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: LIST
59447: PPUSH
59448: CALL_OW 72
59452: PUSH
59453: LD_INT 6
59455: MUL
59456: PLUS
59457: ST_TO_ADDR
// if bcount < tmp then
59458: LD_VAR 0 13
59462: PUSH
59463: LD_VAR 0 4
59467: LESS
59468: IFFALSE 59514
// for i = tmp downto bcount do
59470: LD_ADDR_VAR 0 3
59474: PUSH
59475: DOUBLE
59476: LD_VAR 0 4
59480: INC
59481: ST_TO_ADDR
59482: LD_VAR 0 13
59486: PUSH
59487: FOR_DOWNTO
59488: IFFALSE 59512
// tmp := Delete ( tmp , tmp ) ;
59490: LD_ADDR_VAR 0 4
59494: PUSH
59495: LD_VAR 0 4
59499: PPUSH
59500: LD_VAR 0 4
59504: PPUSH
59505: CALL_OW 3
59509: ST_TO_ADDR
59510: GO 59487
59512: POP
59513: POP
// result := [ tmp , 0 , 0 , p ] ;
59514: LD_ADDR_VAR 0 2
59518: PUSH
59519: LD_VAR 0 4
59523: PUSH
59524: LD_INT 0
59526: PUSH
59527: LD_INT 0
59529: PUSH
59530: LD_VAR 0 11
59534: PUSH
59535: EMPTY
59536: LIST
59537: LIST
59538: LIST
59539: LIST
59540: ST_TO_ADDR
// exit ;
59541: GO 62231
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59543: LD_EXP 23
59547: PUSH
59548: LD_VAR 0 1
59552: ARRAY
59553: PPUSH
59554: LD_INT 2
59556: PUSH
59557: LD_INT 30
59559: PUSH
59560: LD_INT 6
59562: PUSH
59563: EMPTY
59564: LIST
59565: LIST
59566: PUSH
59567: LD_INT 30
59569: PUSH
59570: LD_INT 7
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: PUSH
59577: LD_INT 30
59579: PUSH
59580: LD_INT 8
59582: PUSH
59583: EMPTY
59584: LIST
59585: LIST
59586: PUSH
59587: EMPTY
59588: LIST
59589: LIST
59590: LIST
59591: LIST
59592: PPUSH
59593: CALL_OW 72
59597: NOT
59598: PUSH
59599: LD_EXP 23
59603: PUSH
59604: LD_VAR 0 1
59608: ARRAY
59609: PPUSH
59610: LD_INT 30
59612: PUSH
59613: LD_INT 3
59615: PUSH
59616: EMPTY
59617: LIST
59618: LIST
59619: PPUSH
59620: CALL_OW 72
59624: NOT
59625: AND
59626: IFFALSE 59698
// begin if eng = tmp then
59628: LD_VAR 0 6
59632: PUSH
59633: LD_VAR 0 4
59637: EQUAL
59638: IFFALSE 59642
// exit ;
59640: GO 62231
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
59642: LD_ADDR_EXP 65
59646: PUSH
59647: LD_EXP 65
59651: PPUSH
59652: LD_VAR 0 1
59656: PPUSH
59657: LD_INT 1
59659: PPUSH
59660: CALL_OW 1
59664: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
59665: LD_ADDR_VAR 0 2
59669: PUSH
59670: LD_INT 0
59672: PUSH
59673: LD_VAR 0 4
59677: PUSH
59678: LD_VAR 0 6
59682: DIFF
59683: PUSH
59684: LD_INT 0
59686: PUSH
59687: LD_INT 0
59689: PUSH
59690: EMPTY
59691: LIST
59692: LIST
59693: LIST
59694: LIST
59695: ST_TO_ADDR
// exit ;
59696: GO 62231
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59698: LD_EXP 50
59702: PUSH
59703: LD_EXP 49
59707: PUSH
59708: LD_VAR 0 1
59712: ARRAY
59713: ARRAY
59714: PUSH
59715: LD_EXP 23
59719: PUSH
59720: LD_VAR 0 1
59724: ARRAY
59725: PPUSH
59726: LD_INT 2
59728: PUSH
59729: LD_INT 30
59731: PUSH
59732: LD_INT 6
59734: PUSH
59735: EMPTY
59736: LIST
59737: LIST
59738: PUSH
59739: LD_INT 30
59741: PUSH
59742: LD_INT 7
59744: PUSH
59745: EMPTY
59746: LIST
59747: LIST
59748: PUSH
59749: LD_INT 30
59751: PUSH
59752: LD_INT 8
59754: PUSH
59755: EMPTY
59756: LIST
59757: LIST
59758: PUSH
59759: EMPTY
59760: LIST
59761: LIST
59762: LIST
59763: LIST
59764: PPUSH
59765: CALL_OW 72
59769: AND
59770: PUSH
59771: LD_EXP 23
59775: PUSH
59776: LD_VAR 0 1
59780: ARRAY
59781: PPUSH
59782: LD_INT 30
59784: PUSH
59785: LD_INT 3
59787: PUSH
59788: EMPTY
59789: LIST
59790: LIST
59791: PPUSH
59792: CALL_OW 72
59796: NOT
59797: AND
59798: IFFALSE 60012
// begin if sci >= 6 then
59800: LD_VAR 0 8
59804: PUSH
59805: LD_INT 6
59807: GREATEREQUAL
59808: IFFALSE 59812
// exit ;
59810: GO 62231
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
59812: LD_ADDR_EXP 65
59816: PUSH
59817: LD_EXP 65
59821: PPUSH
59822: LD_VAR 0 1
59826: PPUSH
59827: LD_INT 2
59829: PPUSH
59830: CALL_OW 1
59834: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
59835: LD_ADDR_VAR 0 9
59839: PUSH
59840: LD_VAR 0 4
59844: PUSH
59845: LD_VAR 0 8
59849: DIFF
59850: PPUSH
59851: LD_INT 4
59853: PPUSH
59854: CALL 47310 0 2
59858: ST_TO_ADDR
// p := [ ] ;
59859: LD_ADDR_VAR 0 11
59863: PUSH
59864: EMPTY
59865: ST_TO_ADDR
// if sci < 6 and sort > 6 then
59866: LD_VAR 0 8
59870: PUSH
59871: LD_INT 6
59873: LESS
59874: PUSH
59875: LD_VAR 0 9
59879: PUSH
59880: LD_INT 6
59882: GREATER
59883: AND
59884: IFFALSE 59965
// begin for i = 1 to 6 - sci do
59886: LD_ADDR_VAR 0 3
59890: PUSH
59891: DOUBLE
59892: LD_INT 1
59894: DEC
59895: ST_TO_ADDR
59896: LD_INT 6
59898: PUSH
59899: LD_VAR 0 8
59903: MINUS
59904: PUSH
59905: FOR_TO
59906: IFFALSE 59961
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
59908: LD_ADDR_VAR 0 11
59912: PUSH
59913: LD_VAR 0 11
59917: PPUSH
59918: LD_VAR 0 11
59922: PUSH
59923: LD_INT 1
59925: PLUS
59926: PPUSH
59927: LD_VAR 0 9
59931: PUSH
59932: LD_INT 1
59934: ARRAY
59935: PPUSH
59936: CALL_OW 2
59940: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
59941: LD_ADDR_VAR 0 9
59945: PUSH
59946: LD_VAR 0 9
59950: PPUSH
59951: LD_INT 1
59953: PPUSH
59954: CALL_OW 3
59958: ST_TO_ADDR
// end ;
59959: GO 59905
59961: POP
59962: POP
// end else
59963: GO 59985
// if sort then
59965: LD_VAR 0 9
59969: IFFALSE 59985
// p := sort [ 1 ] ;
59971: LD_ADDR_VAR 0 11
59975: PUSH
59976: LD_VAR 0 9
59980: PUSH
59981: LD_INT 1
59983: ARRAY
59984: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
59985: LD_ADDR_VAR 0 2
59989: PUSH
59990: LD_INT 0
59992: PUSH
59993: LD_INT 0
59995: PUSH
59996: LD_INT 0
59998: PUSH
59999: LD_VAR 0 11
60003: PUSH
60004: EMPTY
60005: LIST
60006: LIST
60007: LIST
60008: LIST
60009: ST_TO_ADDR
// exit ;
60010: GO 62231
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60012: LD_EXP 50
60016: PUSH
60017: LD_EXP 49
60021: PUSH
60022: LD_VAR 0 1
60026: ARRAY
60027: ARRAY
60028: PUSH
60029: LD_EXP 23
60033: PUSH
60034: LD_VAR 0 1
60038: ARRAY
60039: PPUSH
60040: LD_INT 2
60042: PUSH
60043: LD_INT 30
60045: PUSH
60046: LD_INT 6
60048: PUSH
60049: EMPTY
60050: LIST
60051: LIST
60052: PUSH
60053: LD_INT 30
60055: PUSH
60056: LD_INT 7
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PUSH
60063: LD_INT 30
60065: PUSH
60066: LD_INT 8
60068: PUSH
60069: EMPTY
60070: LIST
60071: LIST
60072: PUSH
60073: EMPTY
60074: LIST
60075: LIST
60076: LIST
60077: LIST
60078: PPUSH
60079: CALL_OW 72
60083: AND
60084: PUSH
60085: LD_EXP 23
60089: PUSH
60090: LD_VAR 0 1
60094: ARRAY
60095: PPUSH
60096: LD_INT 30
60098: PUSH
60099: LD_INT 3
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: PPUSH
60106: CALL_OW 72
60110: AND
60111: IFFALSE 60845
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60113: LD_ADDR_EXP 65
60117: PUSH
60118: LD_EXP 65
60122: PPUSH
60123: LD_VAR 0 1
60127: PPUSH
60128: LD_INT 3
60130: PPUSH
60131: CALL_OW 1
60135: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60136: LD_ADDR_VAR 0 2
60140: PUSH
60141: LD_INT 0
60143: PUSH
60144: LD_INT 0
60146: PUSH
60147: LD_INT 0
60149: PUSH
60150: LD_INT 0
60152: PUSH
60153: EMPTY
60154: LIST
60155: LIST
60156: LIST
60157: LIST
60158: ST_TO_ADDR
// if not eng then
60159: LD_VAR 0 6
60163: NOT
60164: IFFALSE 60227
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60166: LD_ADDR_VAR 0 11
60170: PUSH
60171: LD_VAR 0 4
60175: PPUSH
60176: LD_INT 2
60178: PPUSH
60179: CALL 47310 0 2
60183: PUSH
60184: LD_INT 1
60186: ARRAY
60187: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60188: LD_ADDR_VAR 0 2
60192: PUSH
60193: LD_VAR 0 2
60197: PPUSH
60198: LD_INT 2
60200: PPUSH
60201: LD_VAR 0 11
60205: PPUSH
60206: CALL_OW 1
60210: ST_TO_ADDR
// tmp := tmp diff p ;
60211: LD_ADDR_VAR 0 4
60215: PUSH
60216: LD_VAR 0 4
60220: PUSH
60221: LD_VAR 0 11
60225: DIFF
60226: ST_TO_ADDR
// end ; if tmp and sci < 6 then
60227: LD_VAR 0 4
60231: PUSH
60232: LD_VAR 0 8
60236: PUSH
60237: LD_INT 6
60239: LESS
60240: AND
60241: IFFALSE 60429
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
60243: LD_ADDR_VAR 0 9
60247: PUSH
60248: LD_VAR 0 4
60252: PUSH
60253: LD_VAR 0 8
60257: PUSH
60258: LD_VAR 0 7
60262: UNION
60263: DIFF
60264: PPUSH
60265: LD_INT 4
60267: PPUSH
60268: CALL 47310 0 2
60272: ST_TO_ADDR
// p := [ ] ;
60273: LD_ADDR_VAR 0 11
60277: PUSH
60278: EMPTY
60279: ST_TO_ADDR
// if sort then
60280: LD_VAR 0 9
60284: IFFALSE 60400
// for i = 1 to 6 - sci do
60286: LD_ADDR_VAR 0 3
60290: PUSH
60291: DOUBLE
60292: LD_INT 1
60294: DEC
60295: ST_TO_ADDR
60296: LD_INT 6
60298: PUSH
60299: LD_VAR 0 8
60303: MINUS
60304: PUSH
60305: FOR_TO
60306: IFFALSE 60398
// begin if i = sort then
60308: LD_VAR 0 3
60312: PUSH
60313: LD_VAR 0 9
60317: EQUAL
60318: IFFALSE 60322
// break ;
60320: GO 60398
// if GetClass ( i ) = 4 then
60322: LD_VAR 0 3
60326: PPUSH
60327: CALL_OW 257
60331: PUSH
60332: LD_INT 4
60334: EQUAL
60335: IFFALSE 60339
// continue ;
60337: GO 60305
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60339: LD_ADDR_VAR 0 11
60343: PUSH
60344: LD_VAR 0 11
60348: PPUSH
60349: LD_VAR 0 11
60353: PUSH
60354: LD_INT 1
60356: PLUS
60357: PPUSH
60358: LD_VAR 0 9
60362: PUSH
60363: LD_VAR 0 3
60367: ARRAY
60368: PPUSH
60369: CALL_OW 2
60373: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60374: LD_ADDR_VAR 0 4
60378: PUSH
60379: LD_VAR 0 4
60383: PUSH
60384: LD_VAR 0 9
60388: PUSH
60389: LD_VAR 0 3
60393: ARRAY
60394: DIFF
60395: ST_TO_ADDR
// end ;
60396: GO 60305
60398: POP
60399: POP
// if p then
60400: LD_VAR 0 11
60404: IFFALSE 60429
// result := Replace ( result , 4 , p ) ;
60406: LD_ADDR_VAR 0 2
60410: PUSH
60411: LD_VAR 0 2
60415: PPUSH
60416: LD_INT 4
60418: PPUSH
60419: LD_VAR 0 11
60423: PPUSH
60424: CALL_OW 1
60428: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60429: LD_VAR 0 4
60433: PUSH
60434: LD_VAR 0 7
60438: PUSH
60439: LD_INT 6
60441: LESS
60442: AND
60443: IFFALSE 60631
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60445: LD_ADDR_VAR 0 9
60449: PUSH
60450: LD_VAR 0 4
60454: PUSH
60455: LD_VAR 0 8
60459: PUSH
60460: LD_VAR 0 7
60464: UNION
60465: DIFF
60466: PPUSH
60467: LD_INT 3
60469: PPUSH
60470: CALL 47310 0 2
60474: ST_TO_ADDR
// p := [ ] ;
60475: LD_ADDR_VAR 0 11
60479: PUSH
60480: EMPTY
60481: ST_TO_ADDR
// if sort then
60482: LD_VAR 0 9
60486: IFFALSE 60602
// for i = 1 to 6 - mech do
60488: LD_ADDR_VAR 0 3
60492: PUSH
60493: DOUBLE
60494: LD_INT 1
60496: DEC
60497: ST_TO_ADDR
60498: LD_INT 6
60500: PUSH
60501: LD_VAR 0 7
60505: MINUS
60506: PUSH
60507: FOR_TO
60508: IFFALSE 60600
// begin if i = sort then
60510: LD_VAR 0 3
60514: PUSH
60515: LD_VAR 0 9
60519: EQUAL
60520: IFFALSE 60524
// break ;
60522: GO 60600
// if GetClass ( i ) = 3 then
60524: LD_VAR 0 3
60528: PPUSH
60529: CALL_OW 257
60533: PUSH
60534: LD_INT 3
60536: EQUAL
60537: IFFALSE 60541
// continue ;
60539: GO 60507
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60541: LD_ADDR_VAR 0 11
60545: PUSH
60546: LD_VAR 0 11
60550: PPUSH
60551: LD_VAR 0 11
60555: PUSH
60556: LD_INT 1
60558: PLUS
60559: PPUSH
60560: LD_VAR 0 9
60564: PUSH
60565: LD_VAR 0 3
60569: ARRAY
60570: PPUSH
60571: CALL_OW 2
60575: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60576: LD_ADDR_VAR 0 4
60580: PUSH
60581: LD_VAR 0 4
60585: PUSH
60586: LD_VAR 0 9
60590: PUSH
60591: LD_VAR 0 3
60595: ARRAY
60596: DIFF
60597: ST_TO_ADDR
// end ;
60598: GO 60507
60600: POP
60601: POP
// if p then
60602: LD_VAR 0 11
60606: IFFALSE 60631
// result := Replace ( result , 3 , p ) ;
60608: LD_ADDR_VAR 0 2
60612: PUSH
60613: LD_VAR 0 2
60617: PPUSH
60618: LD_INT 3
60620: PPUSH
60621: LD_VAR 0 11
60625: PPUSH
60626: CALL_OW 1
60630: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
60631: LD_VAR 0 4
60635: PUSH
60636: LD_INT 6
60638: GREATER
60639: PUSH
60640: LD_VAR 0 6
60644: PUSH
60645: LD_INT 6
60647: LESS
60648: AND
60649: IFFALSE 60843
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60651: LD_ADDR_VAR 0 9
60655: PUSH
60656: LD_VAR 0 4
60660: PUSH
60661: LD_VAR 0 8
60665: PUSH
60666: LD_VAR 0 7
60670: UNION
60671: PUSH
60672: LD_VAR 0 6
60676: UNION
60677: DIFF
60678: PPUSH
60679: LD_INT 2
60681: PPUSH
60682: CALL 47310 0 2
60686: ST_TO_ADDR
// p := [ ] ;
60687: LD_ADDR_VAR 0 11
60691: PUSH
60692: EMPTY
60693: ST_TO_ADDR
// if sort then
60694: LD_VAR 0 9
60698: IFFALSE 60814
// for i = 1 to 6 - eng do
60700: LD_ADDR_VAR 0 3
60704: PUSH
60705: DOUBLE
60706: LD_INT 1
60708: DEC
60709: ST_TO_ADDR
60710: LD_INT 6
60712: PUSH
60713: LD_VAR 0 6
60717: MINUS
60718: PUSH
60719: FOR_TO
60720: IFFALSE 60812
// begin if i = sort then
60722: LD_VAR 0 3
60726: PUSH
60727: LD_VAR 0 9
60731: EQUAL
60732: IFFALSE 60736
// break ;
60734: GO 60812
// if GetClass ( i ) = 2 then
60736: LD_VAR 0 3
60740: PPUSH
60741: CALL_OW 257
60745: PUSH
60746: LD_INT 2
60748: EQUAL
60749: IFFALSE 60753
// continue ;
60751: GO 60719
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60753: LD_ADDR_VAR 0 11
60757: PUSH
60758: LD_VAR 0 11
60762: PPUSH
60763: LD_VAR 0 11
60767: PUSH
60768: LD_INT 1
60770: PLUS
60771: PPUSH
60772: LD_VAR 0 9
60776: PUSH
60777: LD_VAR 0 3
60781: ARRAY
60782: PPUSH
60783: CALL_OW 2
60787: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60788: LD_ADDR_VAR 0 4
60792: PUSH
60793: LD_VAR 0 4
60797: PUSH
60798: LD_VAR 0 9
60802: PUSH
60803: LD_VAR 0 3
60807: ARRAY
60808: DIFF
60809: ST_TO_ADDR
// end ;
60810: GO 60719
60812: POP
60813: POP
// if p then
60814: LD_VAR 0 11
60818: IFFALSE 60843
// result := Replace ( result , 2 , p ) ;
60820: LD_ADDR_VAR 0 2
60824: PUSH
60825: LD_VAR 0 2
60829: PPUSH
60830: LD_INT 2
60832: PPUSH
60833: LD_VAR 0 11
60837: PPUSH
60838: CALL_OW 1
60842: ST_TO_ADDR
// end ; exit ;
60843: GO 62231
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
60845: LD_EXP 50
60849: PUSH
60850: LD_EXP 49
60854: PUSH
60855: LD_VAR 0 1
60859: ARRAY
60860: ARRAY
60861: NOT
60862: PUSH
60863: LD_EXP 23
60867: PUSH
60868: LD_VAR 0 1
60872: ARRAY
60873: PPUSH
60874: LD_INT 30
60876: PUSH
60877: LD_INT 3
60879: PUSH
60880: EMPTY
60881: LIST
60882: LIST
60883: PPUSH
60884: CALL_OW 72
60888: AND
60889: PUSH
60890: LD_EXP 28
60894: PUSH
60895: LD_VAR 0 1
60899: ARRAY
60900: AND
60901: IFFALSE 61509
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
60903: LD_ADDR_EXP 65
60907: PUSH
60908: LD_EXP 65
60912: PPUSH
60913: LD_VAR 0 1
60917: PPUSH
60918: LD_INT 5
60920: PPUSH
60921: CALL_OW 1
60925: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60926: LD_ADDR_VAR 0 2
60930: PUSH
60931: LD_INT 0
60933: PUSH
60934: LD_INT 0
60936: PUSH
60937: LD_INT 0
60939: PUSH
60940: LD_INT 0
60942: PUSH
60943: EMPTY
60944: LIST
60945: LIST
60946: LIST
60947: LIST
60948: ST_TO_ADDR
// if sci > 1 then
60949: LD_VAR 0 8
60953: PUSH
60954: LD_INT 1
60956: GREATER
60957: IFFALSE 60985
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
60959: LD_ADDR_VAR 0 4
60963: PUSH
60964: LD_VAR 0 4
60968: PUSH
60969: LD_VAR 0 8
60973: PUSH
60974: LD_VAR 0 8
60978: PUSH
60979: LD_INT 1
60981: ARRAY
60982: DIFF
60983: DIFF
60984: ST_TO_ADDR
// if tmp and not sci then
60985: LD_VAR 0 4
60989: PUSH
60990: LD_VAR 0 8
60994: NOT
60995: AND
60996: IFFALSE 61065
// begin sort := SortBySkill ( tmp , 4 ) ;
60998: LD_ADDR_VAR 0 9
61002: PUSH
61003: LD_VAR 0 4
61007: PPUSH
61008: LD_INT 4
61010: PPUSH
61011: CALL 47310 0 2
61015: ST_TO_ADDR
// if sort then
61016: LD_VAR 0 9
61020: IFFALSE 61036
// p := sort [ 1 ] ;
61022: LD_ADDR_VAR 0 11
61026: PUSH
61027: LD_VAR 0 9
61031: PUSH
61032: LD_INT 1
61034: ARRAY
61035: ST_TO_ADDR
// if p then
61036: LD_VAR 0 11
61040: IFFALSE 61065
// result := Replace ( result , 4 , p ) ;
61042: LD_ADDR_VAR 0 2
61046: PUSH
61047: LD_VAR 0 2
61051: PPUSH
61052: LD_INT 4
61054: PPUSH
61055: LD_VAR 0 11
61059: PPUSH
61060: CALL_OW 1
61064: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61065: LD_ADDR_VAR 0 4
61069: PUSH
61070: LD_VAR 0 4
61074: PUSH
61075: LD_VAR 0 7
61079: DIFF
61080: ST_TO_ADDR
// if tmp and mech < 6 then
61081: LD_VAR 0 4
61085: PUSH
61086: LD_VAR 0 7
61090: PUSH
61091: LD_INT 6
61093: LESS
61094: AND
61095: IFFALSE 61283
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61097: LD_ADDR_VAR 0 9
61101: PUSH
61102: LD_VAR 0 4
61106: PUSH
61107: LD_VAR 0 8
61111: PUSH
61112: LD_VAR 0 7
61116: UNION
61117: DIFF
61118: PPUSH
61119: LD_INT 3
61121: PPUSH
61122: CALL 47310 0 2
61126: ST_TO_ADDR
// p := [ ] ;
61127: LD_ADDR_VAR 0 11
61131: PUSH
61132: EMPTY
61133: ST_TO_ADDR
// if sort then
61134: LD_VAR 0 9
61138: IFFALSE 61254
// for i = 1 to 6 - mech do
61140: LD_ADDR_VAR 0 3
61144: PUSH
61145: DOUBLE
61146: LD_INT 1
61148: DEC
61149: ST_TO_ADDR
61150: LD_INT 6
61152: PUSH
61153: LD_VAR 0 7
61157: MINUS
61158: PUSH
61159: FOR_TO
61160: IFFALSE 61252
// begin if i = sort then
61162: LD_VAR 0 3
61166: PUSH
61167: LD_VAR 0 9
61171: EQUAL
61172: IFFALSE 61176
// break ;
61174: GO 61252
// if GetClass ( i ) = 3 then
61176: LD_VAR 0 3
61180: PPUSH
61181: CALL_OW 257
61185: PUSH
61186: LD_INT 3
61188: EQUAL
61189: IFFALSE 61193
// continue ;
61191: GO 61159
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61193: LD_ADDR_VAR 0 11
61197: PUSH
61198: LD_VAR 0 11
61202: PPUSH
61203: LD_VAR 0 11
61207: PUSH
61208: LD_INT 1
61210: PLUS
61211: PPUSH
61212: LD_VAR 0 9
61216: PUSH
61217: LD_VAR 0 3
61221: ARRAY
61222: PPUSH
61223: CALL_OW 2
61227: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61228: LD_ADDR_VAR 0 4
61232: PUSH
61233: LD_VAR 0 4
61237: PUSH
61238: LD_VAR 0 9
61242: PUSH
61243: LD_VAR 0 3
61247: ARRAY
61248: DIFF
61249: ST_TO_ADDR
// end ;
61250: GO 61159
61252: POP
61253: POP
// if p then
61254: LD_VAR 0 11
61258: IFFALSE 61283
// result := Replace ( result , 3 , p ) ;
61260: LD_ADDR_VAR 0 2
61264: PUSH
61265: LD_VAR 0 2
61269: PPUSH
61270: LD_INT 3
61272: PPUSH
61273: LD_VAR 0 11
61277: PPUSH
61278: CALL_OW 1
61282: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61283: LD_ADDR_VAR 0 4
61287: PUSH
61288: LD_VAR 0 4
61292: PUSH
61293: LD_VAR 0 6
61297: DIFF
61298: ST_TO_ADDR
// if tmp and eng < 6 then
61299: LD_VAR 0 4
61303: PUSH
61304: LD_VAR 0 6
61308: PUSH
61309: LD_INT 6
61311: LESS
61312: AND
61313: IFFALSE 61507
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61315: LD_ADDR_VAR 0 9
61319: PUSH
61320: LD_VAR 0 4
61324: PUSH
61325: LD_VAR 0 8
61329: PUSH
61330: LD_VAR 0 7
61334: UNION
61335: PUSH
61336: LD_VAR 0 6
61340: UNION
61341: DIFF
61342: PPUSH
61343: LD_INT 2
61345: PPUSH
61346: CALL 47310 0 2
61350: ST_TO_ADDR
// p := [ ] ;
61351: LD_ADDR_VAR 0 11
61355: PUSH
61356: EMPTY
61357: ST_TO_ADDR
// if sort then
61358: LD_VAR 0 9
61362: IFFALSE 61478
// for i = 1 to 6 - eng do
61364: LD_ADDR_VAR 0 3
61368: PUSH
61369: DOUBLE
61370: LD_INT 1
61372: DEC
61373: ST_TO_ADDR
61374: LD_INT 6
61376: PUSH
61377: LD_VAR 0 6
61381: MINUS
61382: PUSH
61383: FOR_TO
61384: IFFALSE 61476
// begin if i = sort then
61386: LD_VAR 0 3
61390: PUSH
61391: LD_VAR 0 9
61395: EQUAL
61396: IFFALSE 61400
// break ;
61398: GO 61476
// if GetClass ( i ) = 2 then
61400: LD_VAR 0 3
61404: PPUSH
61405: CALL_OW 257
61409: PUSH
61410: LD_INT 2
61412: EQUAL
61413: IFFALSE 61417
// continue ;
61415: GO 61383
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61417: LD_ADDR_VAR 0 11
61421: PUSH
61422: LD_VAR 0 11
61426: PPUSH
61427: LD_VAR 0 11
61431: PUSH
61432: LD_INT 1
61434: PLUS
61435: PPUSH
61436: LD_VAR 0 9
61440: PUSH
61441: LD_VAR 0 3
61445: ARRAY
61446: PPUSH
61447: CALL_OW 2
61451: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61452: LD_ADDR_VAR 0 4
61456: PUSH
61457: LD_VAR 0 4
61461: PUSH
61462: LD_VAR 0 9
61466: PUSH
61467: LD_VAR 0 3
61471: ARRAY
61472: DIFF
61473: ST_TO_ADDR
// end ;
61474: GO 61383
61476: POP
61477: POP
// if p then
61478: LD_VAR 0 11
61482: IFFALSE 61507
// result := Replace ( result , 2 , p ) ;
61484: LD_ADDR_VAR 0 2
61488: PUSH
61489: LD_VAR 0 2
61493: PPUSH
61494: LD_INT 2
61496: PPUSH
61497: LD_VAR 0 11
61501: PPUSH
61502: CALL_OW 1
61506: ST_TO_ADDR
// end ; exit ;
61507: GO 62231
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61509: LD_EXP 50
61513: PUSH
61514: LD_EXP 49
61518: PUSH
61519: LD_VAR 0 1
61523: ARRAY
61524: ARRAY
61525: NOT
61526: PUSH
61527: LD_EXP 23
61531: PUSH
61532: LD_VAR 0 1
61536: ARRAY
61537: PPUSH
61538: LD_INT 30
61540: PUSH
61541: LD_INT 3
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PPUSH
61548: CALL_OW 72
61552: AND
61553: PUSH
61554: LD_EXP 28
61558: PUSH
61559: LD_VAR 0 1
61563: ARRAY
61564: NOT
61565: AND
61566: IFFALSE 62231
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61568: LD_ADDR_EXP 65
61572: PUSH
61573: LD_EXP 65
61577: PPUSH
61578: LD_VAR 0 1
61582: PPUSH
61583: LD_INT 6
61585: PPUSH
61586: CALL_OW 1
61590: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61591: LD_ADDR_VAR 0 2
61595: PUSH
61596: LD_INT 0
61598: PUSH
61599: LD_INT 0
61601: PUSH
61602: LD_INT 0
61604: PUSH
61605: LD_INT 0
61607: PUSH
61608: EMPTY
61609: LIST
61610: LIST
61611: LIST
61612: LIST
61613: ST_TO_ADDR
// if sci >= 1 then
61614: LD_VAR 0 8
61618: PUSH
61619: LD_INT 1
61621: GREATEREQUAL
61622: IFFALSE 61644
// tmp := tmp diff sci [ 1 ] ;
61624: LD_ADDR_VAR 0 4
61628: PUSH
61629: LD_VAR 0 4
61633: PUSH
61634: LD_VAR 0 8
61638: PUSH
61639: LD_INT 1
61641: ARRAY
61642: DIFF
61643: ST_TO_ADDR
// if tmp and not sci then
61644: LD_VAR 0 4
61648: PUSH
61649: LD_VAR 0 8
61653: NOT
61654: AND
61655: IFFALSE 61724
// begin sort := SortBySkill ( tmp , 4 ) ;
61657: LD_ADDR_VAR 0 9
61661: PUSH
61662: LD_VAR 0 4
61666: PPUSH
61667: LD_INT 4
61669: PPUSH
61670: CALL 47310 0 2
61674: ST_TO_ADDR
// if sort then
61675: LD_VAR 0 9
61679: IFFALSE 61695
// p := sort [ 1 ] ;
61681: LD_ADDR_VAR 0 11
61685: PUSH
61686: LD_VAR 0 9
61690: PUSH
61691: LD_INT 1
61693: ARRAY
61694: ST_TO_ADDR
// if p then
61695: LD_VAR 0 11
61699: IFFALSE 61724
// result := Replace ( result , 4 , p ) ;
61701: LD_ADDR_VAR 0 2
61705: PUSH
61706: LD_VAR 0 2
61710: PPUSH
61711: LD_INT 4
61713: PPUSH
61714: LD_VAR 0 11
61718: PPUSH
61719: CALL_OW 1
61723: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61724: LD_ADDR_VAR 0 4
61728: PUSH
61729: LD_VAR 0 4
61733: PUSH
61734: LD_VAR 0 7
61738: DIFF
61739: ST_TO_ADDR
// if tmp and mech < 6 then
61740: LD_VAR 0 4
61744: PUSH
61745: LD_VAR 0 7
61749: PUSH
61750: LD_INT 6
61752: LESS
61753: AND
61754: IFFALSE 61936
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
61756: LD_ADDR_VAR 0 9
61760: PUSH
61761: LD_VAR 0 4
61765: PUSH
61766: LD_VAR 0 7
61770: DIFF
61771: PPUSH
61772: LD_INT 3
61774: PPUSH
61775: CALL 47310 0 2
61779: ST_TO_ADDR
// p := [ ] ;
61780: LD_ADDR_VAR 0 11
61784: PUSH
61785: EMPTY
61786: ST_TO_ADDR
// if sort then
61787: LD_VAR 0 9
61791: IFFALSE 61907
// for i = 1 to 6 - mech do
61793: LD_ADDR_VAR 0 3
61797: PUSH
61798: DOUBLE
61799: LD_INT 1
61801: DEC
61802: ST_TO_ADDR
61803: LD_INT 6
61805: PUSH
61806: LD_VAR 0 7
61810: MINUS
61811: PUSH
61812: FOR_TO
61813: IFFALSE 61905
// begin if i = sort then
61815: LD_VAR 0 3
61819: PUSH
61820: LD_VAR 0 9
61824: EQUAL
61825: IFFALSE 61829
// break ;
61827: GO 61905
// if GetClass ( i ) = 3 then
61829: LD_VAR 0 3
61833: PPUSH
61834: CALL_OW 257
61838: PUSH
61839: LD_INT 3
61841: EQUAL
61842: IFFALSE 61846
// continue ;
61844: GO 61812
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61846: LD_ADDR_VAR 0 11
61850: PUSH
61851: LD_VAR 0 11
61855: PPUSH
61856: LD_VAR 0 11
61860: PUSH
61861: LD_INT 1
61863: PLUS
61864: PPUSH
61865: LD_VAR 0 9
61869: PUSH
61870: LD_VAR 0 3
61874: ARRAY
61875: PPUSH
61876: CALL_OW 2
61880: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61881: LD_ADDR_VAR 0 4
61885: PUSH
61886: LD_VAR 0 4
61890: PUSH
61891: LD_VAR 0 9
61895: PUSH
61896: LD_VAR 0 3
61900: ARRAY
61901: DIFF
61902: ST_TO_ADDR
// end ;
61903: GO 61812
61905: POP
61906: POP
// if p then
61907: LD_VAR 0 11
61911: IFFALSE 61936
// result := Replace ( result , 3 , p ) ;
61913: LD_ADDR_VAR 0 2
61917: PUSH
61918: LD_VAR 0 2
61922: PPUSH
61923: LD_INT 3
61925: PPUSH
61926: LD_VAR 0 11
61930: PPUSH
61931: CALL_OW 1
61935: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61936: LD_ADDR_VAR 0 4
61940: PUSH
61941: LD_VAR 0 4
61945: PUSH
61946: LD_VAR 0 6
61950: DIFF
61951: ST_TO_ADDR
// if tmp and eng < 4 then
61952: LD_VAR 0 4
61956: PUSH
61957: LD_VAR 0 6
61961: PUSH
61962: LD_INT 4
61964: LESS
61965: AND
61966: IFFALSE 62156
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
61968: LD_ADDR_VAR 0 9
61972: PUSH
61973: LD_VAR 0 4
61977: PUSH
61978: LD_VAR 0 7
61982: PUSH
61983: LD_VAR 0 6
61987: UNION
61988: DIFF
61989: PPUSH
61990: LD_INT 2
61992: PPUSH
61993: CALL 47310 0 2
61997: ST_TO_ADDR
// p := [ ] ;
61998: LD_ADDR_VAR 0 11
62002: PUSH
62003: EMPTY
62004: ST_TO_ADDR
// if sort then
62005: LD_VAR 0 9
62009: IFFALSE 62125
// for i = 1 to 4 - eng do
62011: LD_ADDR_VAR 0 3
62015: PUSH
62016: DOUBLE
62017: LD_INT 1
62019: DEC
62020: ST_TO_ADDR
62021: LD_INT 4
62023: PUSH
62024: LD_VAR 0 6
62028: MINUS
62029: PUSH
62030: FOR_TO
62031: IFFALSE 62123
// begin if i = sort then
62033: LD_VAR 0 3
62037: PUSH
62038: LD_VAR 0 9
62042: EQUAL
62043: IFFALSE 62047
// break ;
62045: GO 62123
// if GetClass ( i ) = 2 then
62047: LD_VAR 0 3
62051: PPUSH
62052: CALL_OW 257
62056: PUSH
62057: LD_INT 2
62059: EQUAL
62060: IFFALSE 62064
// continue ;
62062: GO 62030
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62064: LD_ADDR_VAR 0 11
62068: PUSH
62069: LD_VAR 0 11
62073: PPUSH
62074: LD_VAR 0 11
62078: PUSH
62079: LD_INT 1
62081: PLUS
62082: PPUSH
62083: LD_VAR 0 9
62087: PUSH
62088: LD_VAR 0 3
62092: ARRAY
62093: PPUSH
62094: CALL_OW 2
62098: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62099: LD_ADDR_VAR 0 4
62103: PUSH
62104: LD_VAR 0 4
62108: PUSH
62109: LD_VAR 0 9
62113: PUSH
62114: LD_VAR 0 3
62118: ARRAY
62119: DIFF
62120: ST_TO_ADDR
// end ;
62121: GO 62030
62123: POP
62124: POP
// if p then
62125: LD_VAR 0 11
62129: IFFALSE 62154
// result := Replace ( result , 2 , p ) ;
62131: LD_ADDR_VAR 0 2
62135: PUSH
62136: LD_VAR 0 2
62140: PPUSH
62141: LD_INT 2
62143: PPUSH
62144: LD_VAR 0 11
62148: PPUSH
62149: CALL_OW 1
62153: ST_TO_ADDR
// end else
62154: GO 62200
// for i = eng downto 5 do
62156: LD_ADDR_VAR 0 3
62160: PUSH
62161: DOUBLE
62162: LD_VAR 0 6
62166: INC
62167: ST_TO_ADDR
62168: LD_INT 5
62170: PUSH
62171: FOR_DOWNTO
62172: IFFALSE 62198
// tmp := tmp union eng [ i ] ;
62174: LD_ADDR_VAR 0 4
62178: PUSH
62179: LD_VAR 0 4
62183: PUSH
62184: LD_VAR 0 6
62188: PUSH
62189: LD_VAR 0 3
62193: ARRAY
62194: UNION
62195: ST_TO_ADDR
62196: GO 62171
62198: POP
62199: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62200: LD_ADDR_VAR 0 2
62204: PUSH
62205: LD_VAR 0 2
62209: PPUSH
62210: LD_INT 1
62212: PPUSH
62213: LD_VAR 0 4
62217: PUSH
62218: LD_VAR 0 5
62222: DIFF
62223: PPUSH
62224: CALL_OW 1
62228: ST_TO_ADDR
// exit ;
62229: GO 62231
// end ; end ;
62231: LD_VAR 0 2
62235: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62236: LD_INT 0
62238: PPUSH
62239: PPUSH
62240: PPUSH
// if not mc_bases then
62241: LD_EXP 23
62245: NOT
62246: IFFALSE 62250
// exit ;
62248: GO 62392
// for i = 1 to mc_bases do
62250: LD_ADDR_VAR 0 2
62254: PUSH
62255: DOUBLE
62256: LD_INT 1
62258: DEC
62259: ST_TO_ADDR
62260: LD_EXP 23
62264: PUSH
62265: FOR_TO
62266: IFFALSE 62383
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62268: LD_ADDR_VAR 0 3
62272: PUSH
62273: LD_EXP 23
62277: PUSH
62278: LD_VAR 0 2
62282: ARRAY
62283: PPUSH
62284: LD_INT 21
62286: PUSH
62287: LD_INT 3
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: PUSH
62294: LD_INT 3
62296: PUSH
62297: LD_INT 2
62299: PUSH
62300: LD_INT 30
62302: PUSH
62303: LD_INT 29
62305: PUSH
62306: EMPTY
62307: LIST
62308: LIST
62309: PUSH
62310: LD_INT 30
62312: PUSH
62313: LD_INT 30
62315: PUSH
62316: EMPTY
62317: LIST
62318: LIST
62319: PUSH
62320: EMPTY
62321: LIST
62322: LIST
62323: LIST
62324: PUSH
62325: EMPTY
62326: LIST
62327: LIST
62328: PUSH
62329: LD_INT 3
62331: PUSH
62332: LD_INT 24
62334: PUSH
62335: LD_INT 1000
62337: PUSH
62338: EMPTY
62339: LIST
62340: LIST
62341: PUSH
62342: EMPTY
62343: LIST
62344: LIST
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: LIST
62350: PPUSH
62351: CALL_OW 72
62355: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62356: LD_ADDR_EXP 24
62360: PUSH
62361: LD_EXP 24
62365: PPUSH
62366: LD_VAR 0 2
62370: PPUSH
62371: LD_VAR 0 3
62375: PPUSH
62376: CALL_OW 1
62380: ST_TO_ADDR
// end ;
62381: GO 62265
62383: POP
62384: POP
// RaiseSailEvent ( 101 ) ;
62385: LD_INT 101
62387: PPUSH
62388: CALL_OW 427
// end ;
62392: LD_VAR 0 1
62396: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62397: LD_INT 0
62399: PPUSH
62400: PPUSH
62401: PPUSH
62402: PPUSH
62403: PPUSH
62404: PPUSH
62405: PPUSH
// if not mc_bases then
62406: LD_EXP 23
62410: NOT
62411: IFFALSE 62415
// exit ;
62413: GO 62977
// for i = 1 to mc_bases do
62415: LD_ADDR_VAR 0 2
62419: PUSH
62420: DOUBLE
62421: LD_INT 1
62423: DEC
62424: ST_TO_ADDR
62425: LD_EXP 23
62429: PUSH
62430: FOR_TO
62431: IFFALSE 62968
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
62433: LD_ADDR_VAR 0 5
62437: PUSH
62438: LD_EXP 23
62442: PUSH
62443: LD_VAR 0 2
62447: ARRAY
62448: PUSH
62449: LD_EXP 52
62453: PUSH
62454: LD_VAR 0 2
62458: ARRAY
62459: UNION
62460: PPUSH
62461: LD_INT 21
62463: PUSH
62464: LD_INT 1
62466: PUSH
62467: EMPTY
62468: LIST
62469: LIST
62470: PUSH
62471: LD_INT 1
62473: PUSH
62474: LD_INT 3
62476: PUSH
62477: LD_INT 54
62479: PUSH
62480: EMPTY
62481: LIST
62482: PUSH
62483: EMPTY
62484: LIST
62485: LIST
62486: PUSH
62487: LD_INT 3
62489: PUSH
62490: LD_INT 24
62492: PUSH
62493: LD_INT 1000
62495: PUSH
62496: EMPTY
62497: LIST
62498: LIST
62499: PUSH
62500: EMPTY
62501: LIST
62502: LIST
62503: PUSH
62504: EMPTY
62505: LIST
62506: LIST
62507: LIST
62508: PUSH
62509: EMPTY
62510: LIST
62511: LIST
62512: PPUSH
62513: CALL_OW 72
62517: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62518: LD_ADDR_VAR 0 6
62522: PUSH
62523: LD_EXP 23
62527: PUSH
62528: LD_VAR 0 2
62532: ARRAY
62533: PPUSH
62534: LD_INT 21
62536: PUSH
62537: LD_INT 1
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PUSH
62544: LD_INT 1
62546: PUSH
62547: LD_INT 3
62549: PUSH
62550: LD_INT 54
62552: PUSH
62553: EMPTY
62554: LIST
62555: PUSH
62556: EMPTY
62557: LIST
62558: LIST
62559: PUSH
62560: LD_INT 3
62562: PUSH
62563: LD_INT 24
62565: PUSH
62566: LD_INT 250
62568: PUSH
62569: EMPTY
62570: LIST
62571: LIST
62572: PUSH
62573: EMPTY
62574: LIST
62575: LIST
62576: PUSH
62577: EMPTY
62578: LIST
62579: LIST
62580: LIST
62581: PUSH
62582: EMPTY
62583: LIST
62584: LIST
62585: PPUSH
62586: CALL_OW 72
62590: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62591: LD_ADDR_VAR 0 7
62595: PUSH
62596: LD_VAR 0 5
62600: PUSH
62601: LD_VAR 0 6
62605: DIFF
62606: ST_TO_ADDR
// if not need_heal_1 then
62607: LD_VAR 0 6
62611: NOT
62612: IFFALSE 62645
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
62614: LD_ADDR_EXP 26
62618: PUSH
62619: LD_EXP 26
62623: PPUSH
62624: LD_VAR 0 2
62628: PUSH
62629: LD_INT 1
62631: PUSH
62632: EMPTY
62633: LIST
62634: LIST
62635: PPUSH
62636: EMPTY
62637: PPUSH
62638: CALL 16077 0 3
62642: ST_TO_ADDR
62643: GO 62715
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
62645: LD_ADDR_EXP 26
62649: PUSH
62650: LD_EXP 26
62654: PPUSH
62655: LD_VAR 0 2
62659: PUSH
62660: LD_INT 1
62662: PUSH
62663: EMPTY
62664: LIST
62665: LIST
62666: PPUSH
62667: LD_EXP 26
62671: PUSH
62672: LD_VAR 0 2
62676: ARRAY
62677: PUSH
62678: LD_INT 1
62680: ARRAY
62681: PPUSH
62682: LD_INT 3
62684: PUSH
62685: LD_INT 24
62687: PUSH
62688: LD_INT 1000
62690: PUSH
62691: EMPTY
62692: LIST
62693: LIST
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PPUSH
62699: CALL_OW 72
62703: PUSH
62704: LD_VAR 0 6
62708: UNION
62709: PPUSH
62710: CALL 16077 0 3
62714: ST_TO_ADDR
// if not need_heal_2 then
62715: LD_VAR 0 7
62719: NOT
62720: IFFALSE 62753
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
62722: LD_ADDR_EXP 26
62726: PUSH
62727: LD_EXP 26
62731: PPUSH
62732: LD_VAR 0 2
62736: PUSH
62737: LD_INT 2
62739: PUSH
62740: EMPTY
62741: LIST
62742: LIST
62743: PPUSH
62744: EMPTY
62745: PPUSH
62746: CALL 16077 0 3
62750: ST_TO_ADDR
62751: GO 62785
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62753: LD_ADDR_EXP 26
62757: PUSH
62758: LD_EXP 26
62762: PPUSH
62763: LD_VAR 0 2
62767: PUSH
62768: LD_INT 2
62770: PUSH
62771: EMPTY
62772: LIST
62773: LIST
62774: PPUSH
62775: LD_VAR 0 7
62779: PPUSH
62780: CALL 16077 0 3
62784: ST_TO_ADDR
// if need_heal_2 then
62785: LD_VAR 0 7
62789: IFFALSE 62950
// for j in need_heal_2 do
62791: LD_ADDR_VAR 0 3
62795: PUSH
62796: LD_VAR 0 7
62800: PUSH
62801: FOR_IN
62802: IFFALSE 62948
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62804: LD_ADDR_VAR 0 5
62808: PUSH
62809: LD_EXP 23
62813: PUSH
62814: LD_VAR 0 2
62818: ARRAY
62819: PPUSH
62820: LD_INT 2
62822: PUSH
62823: LD_INT 30
62825: PUSH
62826: LD_INT 6
62828: PUSH
62829: EMPTY
62830: LIST
62831: LIST
62832: PUSH
62833: LD_INT 30
62835: PUSH
62836: LD_INT 7
62838: PUSH
62839: EMPTY
62840: LIST
62841: LIST
62842: PUSH
62843: LD_INT 30
62845: PUSH
62846: LD_INT 8
62848: PUSH
62849: EMPTY
62850: LIST
62851: LIST
62852: PUSH
62853: LD_INT 30
62855: PUSH
62856: LD_INT 0
62858: PUSH
62859: EMPTY
62860: LIST
62861: LIST
62862: PUSH
62863: LD_INT 30
62865: PUSH
62866: LD_INT 1
62868: PUSH
62869: EMPTY
62870: LIST
62871: LIST
62872: PUSH
62873: EMPTY
62874: LIST
62875: LIST
62876: LIST
62877: LIST
62878: LIST
62879: LIST
62880: PPUSH
62881: CALL_OW 72
62885: ST_TO_ADDR
// if tmp then
62886: LD_VAR 0 5
62890: IFFALSE 62946
// begin k := NearestUnitToUnit ( tmp , j ) ;
62892: LD_ADDR_VAR 0 4
62896: PUSH
62897: LD_VAR 0 5
62901: PPUSH
62902: LD_VAR 0 3
62906: PPUSH
62907: CALL_OW 74
62911: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
62912: LD_VAR 0 3
62916: PPUSH
62917: LD_VAR 0 4
62921: PPUSH
62922: CALL_OW 296
62926: PUSH
62927: LD_INT 5
62929: GREATER
62930: IFFALSE 62946
// ComMoveToNearbyEntrance ( j , k ) ;
62932: LD_VAR 0 3
62936: PPUSH
62937: LD_VAR 0 4
62941: PPUSH
62942: CALL 49683 0 2
// end ; end ;
62946: GO 62801
62948: POP
62949: POP
// if not need_heal_1 and not need_heal_2 then
62950: LD_VAR 0 6
62954: NOT
62955: PUSH
62956: LD_VAR 0 7
62960: NOT
62961: AND
62962: IFFALSE 62966
// continue ;
62964: GO 62430
// end ;
62966: GO 62430
62968: POP
62969: POP
// RaiseSailEvent ( 102 ) ;
62970: LD_INT 102
62972: PPUSH
62973: CALL_OW 427
// end ;
62977: LD_VAR 0 1
62981: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
62982: LD_INT 0
62984: PPUSH
62985: PPUSH
62986: PPUSH
62987: PPUSH
62988: PPUSH
62989: PPUSH
62990: PPUSH
62991: PPUSH
// if not mc_bases then
62992: LD_EXP 23
62996: NOT
62997: IFFALSE 63001
// exit ;
62999: GO 63912
// for i = 1 to mc_bases do
63001: LD_ADDR_VAR 0 2
63005: PUSH
63006: DOUBLE
63007: LD_INT 1
63009: DEC
63010: ST_TO_ADDR
63011: LD_EXP 23
63015: PUSH
63016: FOR_TO
63017: IFFALSE 63910
// begin if not mc_building_need_repair [ i ] then
63019: LD_EXP 24
63023: PUSH
63024: LD_VAR 0 2
63028: ARRAY
63029: NOT
63030: IFFALSE 63215
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
63032: LD_ADDR_VAR 0 6
63036: PUSH
63037: LD_EXP 42
63041: PUSH
63042: LD_VAR 0 2
63046: ARRAY
63047: PPUSH
63048: LD_INT 3
63050: PUSH
63051: LD_INT 24
63053: PUSH
63054: LD_INT 1000
63056: PUSH
63057: EMPTY
63058: LIST
63059: LIST
63060: PUSH
63061: EMPTY
63062: LIST
63063: LIST
63064: PUSH
63065: LD_INT 2
63067: PUSH
63068: LD_INT 34
63070: PUSH
63071: LD_INT 13
63073: PUSH
63074: EMPTY
63075: LIST
63076: LIST
63077: PUSH
63078: LD_INT 34
63080: PUSH
63081: LD_INT 52
63083: PUSH
63084: EMPTY
63085: LIST
63086: LIST
63087: PUSH
63088: LD_INT 34
63090: PUSH
63091: LD_INT 88
63093: PUSH
63094: EMPTY
63095: LIST
63096: LIST
63097: PUSH
63098: EMPTY
63099: LIST
63100: LIST
63101: LIST
63102: LIST
63103: PUSH
63104: EMPTY
63105: LIST
63106: LIST
63107: PPUSH
63108: CALL_OW 72
63112: ST_TO_ADDR
// if cranes then
63113: LD_VAR 0 6
63117: IFFALSE 63179
// for j in cranes do
63119: LD_ADDR_VAR 0 3
63123: PUSH
63124: LD_VAR 0 6
63128: PUSH
63129: FOR_IN
63130: IFFALSE 63177
// if not IsInArea ( j , mc_parking [ i ] ) then
63132: LD_VAR 0 3
63136: PPUSH
63137: LD_EXP 47
63141: PUSH
63142: LD_VAR 0 2
63146: ARRAY
63147: PPUSH
63148: CALL_OW 308
63152: NOT
63153: IFFALSE 63175
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63155: LD_VAR 0 3
63159: PPUSH
63160: LD_EXP 47
63164: PUSH
63165: LD_VAR 0 2
63169: ARRAY
63170: PPUSH
63171: CALL_OW 113
63175: GO 63129
63177: POP
63178: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63179: LD_ADDR_EXP 25
63183: PUSH
63184: LD_EXP 25
63188: PPUSH
63189: LD_VAR 0 2
63193: PPUSH
63194: EMPTY
63195: PPUSH
63196: CALL_OW 1
63200: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63201: LD_VAR 0 2
63205: PPUSH
63206: LD_INT 101
63208: PPUSH
63209: CALL 58055 0 2
// continue ;
63213: GO 63016
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63215: LD_ADDR_EXP 29
63219: PUSH
63220: LD_EXP 29
63224: PPUSH
63225: LD_VAR 0 2
63229: PPUSH
63230: EMPTY
63231: PPUSH
63232: CALL_OW 1
63236: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63237: LD_VAR 0 2
63241: PPUSH
63242: LD_INT 103
63244: PPUSH
63245: CALL 58055 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63249: LD_ADDR_VAR 0 5
63253: PUSH
63254: LD_EXP 23
63258: PUSH
63259: LD_VAR 0 2
63263: ARRAY
63264: PUSH
63265: LD_EXP 52
63269: PUSH
63270: LD_VAR 0 2
63274: ARRAY
63275: UNION
63276: PPUSH
63277: LD_INT 2
63279: PUSH
63280: LD_INT 25
63282: PUSH
63283: LD_INT 2
63285: PUSH
63286: EMPTY
63287: LIST
63288: LIST
63289: PUSH
63290: LD_INT 25
63292: PUSH
63293: LD_INT 16
63295: PUSH
63296: EMPTY
63297: LIST
63298: LIST
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: LIST
63304: PUSH
63305: EMPTY
63306: LIST
63307: PPUSH
63308: CALL_OW 72
63312: ST_TO_ADDR
// if mc_need_heal [ i ] then
63313: LD_EXP 26
63317: PUSH
63318: LD_VAR 0 2
63322: ARRAY
63323: IFFALSE 63367
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
63325: LD_ADDR_VAR 0 5
63329: PUSH
63330: LD_VAR 0 5
63334: PUSH
63335: LD_EXP 26
63339: PUSH
63340: LD_VAR 0 2
63344: ARRAY
63345: PUSH
63346: LD_INT 1
63348: ARRAY
63349: PUSH
63350: LD_EXP 26
63354: PUSH
63355: LD_VAR 0 2
63359: ARRAY
63360: PUSH
63361: LD_INT 2
63363: ARRAY
63364: UNION
63365: DIFF
63366: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
63367: LD_ADDR_VAR 0 6
63371: PUSH
63372: LD_EXP 42
63376: PUSH
63377: LD_VAR 0 2
63381: ARRAY
63382: PPUSH
63383: LD_INT 2
63385: PUSH
63386: LD_INT 34
63388: PUSH
63389: LD_INT 13
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PUSH
63396: LD_INT 34
63398: PUSH
63399: LD_INT 52
63401: PUSH
63402: EMPTY
63403: LIST
63404: LIST
63405: PUSH
63406: LD_INT 34
63408: PUSH
63409: LD_INT 88
63411: PUSH
63412: EMPTY
63413: LIST
63414: LIST
63415: PUSH
63416: EMPTY
63417: LIST
63418: LIST
63419: LIST
63420: LIST
63421: PPUSH
63422: CALL_OW 72
63426: ST_TO_ADDR
// if cranes then
63427: LD_VAR 0 6
63431: IFFALSE 63599
// begin for j in cranes do
63433: LD_ADDR_VAR 0 3
63437: PUSH
63438: LD_VAR 0 6
63442: PUSH
63443: FOR_IN
63444: IFFALSE 63597
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
63446: LD_VAR 0 3
63450: PPUSH
63451: CALL_OW 256
63455: PUSH
63456: LD_INT 1000
63458: EQUAL
63459: PUSH
63460: LD_VAR 0 3
63464: PPUSH
63465: CALL_OW 314
63469: NOT
63470: AND
63471: IFFALSE 63537
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
63473: LD_ADDR_VAR 0 8
63477: PUSH
63478: LD_EXP 24
63482: PUSH
63483: LD_VAR 0 2
63487: ARRAY
63488: PPUSH
63489: LD_VAR 0 3
63493: PPUSH
63494: CALL_OW 74
63498: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
63499: LD_VAR 0 8
63503: PPUSH
63504: LD_INT 16
63506: PPUSH
63507: CALL 19042 0 2
63511: PUSH
63512: LD_INT 4
63514: ARRAY
63515: PUSH
63516: LD_INT 10
63518: LESS
63519: IFFALSE 63535
// ComRepairBuilding ( j , to_repair ) ;
63521: LD_VAR 0 3
63525: PPUSH
63526: LD_VAR 0 8
63530: PPUSH
63531: CALL_OW 130
// end else
63535: GO 63595
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63537: LD_VAR 0 3
63541: PPUSH
63542: CALL_OW 256
63546: PUSH
63547: LD_INT 500
63549: LESS
63550: PUSH
63551: LD_VAR 0 3
63555: PPUSH
63556: LD_EXP 47
63560: PUSH
63561: LD_VAR 0 2
63565: ARRAY
63566: PPUSH
63567: CALL_OW 308
63571: NOT
63572: AND
63573: IFFALSE 63595
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63575: LD_VAR 0 3
63579: PPUSH
63580: LD_EXP 47
63584: PUSH
63585: LD_VAR 0 2
63589: ARRAY
63590: PPUSH
63591: CALL_OW 113
// end ;
63595: GO 63443
63597: POP
63598: POP
// end ; if tmp > 3 then
63599: LD_VAR 0 5
63603: PUSH
63604: LD_INT 3
63606: GREATER
63607: IFFALSE 63627
// tmp := ShrinkArray ( tmp , 4 ) ;
63609: LD_ADDR_VAR 0 5
63613: PUSH
63614: LD_VAR 0 5
63618: PPUSH
63619: LD_INT 4
63621: PPUSH
63622: CALL 49121 0 2
63626: ST_TO_ADDR
// if not tmp then
63627: LD_VAR 0 5
63631: NOT
63632: IFFALSE 63636
// continue ;
63634: GO 63016
// for j in tmp do
63636: LD_ADDR_VAR 0 3
63640: PUSH
63641: LD_VAR 0 5
63645: PUSH
63646: FOR_IN
63647: IFFALSE 63906
// begin if IsInUnit ( j ) then
63649: LD_VAR 0 3
63653: PPUSH
63654: CALL_OW 310
63658: IFFALSE 63669
// ComExitBuilding ( j ) ;
63660: LD_VAR 0 3
63664: PPUSH
63665: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63669: LD_VAR 0 3
63673: PUSH
63674: LD_EXP 25
63678: PUSH
63679: LD_VAR 0 2
63683: ARRAY
63684: IN
63685: NOT
63686: IFFALSE 63744
// begin SetTag ( j , 101 ) ;
63688: LD_VAR 0 3
63692: PPUSH
63693: LD_INT 101
63695: PPUSH
63696: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63700: LD_ADDR_EXP 25
63704: PUSH
63705: LD_EXP 25
63709: PPUSH
63710: LD_VAR 0 2
63714: PUSH
63715: LD_EXP 25
63719: PUSH
63720: LD_VAR 0 2
63724: ARRAY
63725: PUSH
63726: LD_INT 1
63728: PLUS
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: PPUSH
63734: LD_VAR 0 3
63738: PPUSH
63739: CALL 16077 0 3
63743: ST_TO_ADDR
// end ; wait ( 1 ) ;
63744: LD_INT 1
63746: PPUSH
63747: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
63751: LD_ADDR_VAR 0 7
63755: PUSH
63756: LD_EXP 24
63760: PUSH
63761: LD_VAR 0 2
63765: ARRAY
63766: ST_TO_ADDR
// if mc_scan [ i ] then
63767: LD_EXP 46
63771: PUSH
63772: LD_VAR 0 2
63776: ARRAY
63777: IFFALSE 63839
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
63779: LD_ADDR_VAR 0 7
63783: PUSH
63784: LD_EXP 24
63788: PUSH
63789: LD_VAR 0 2
63793: ARRAY
63794: PPUSH
63795: LD_INT 3
63797: PUSH
63798: LD_INT 30
63800: PUSH
63801: LD_INT 32
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 30
63810: PUSH
63811: LD_INT 33
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 30
63820: PUSH
63821: LD_INT 31
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: EMPTY
63829: LIST
63830: LIST
63831: LIST
63832: LIST
63833: PPUSH
63834: CALL_OW 72
63838: ST_TO_ADDR
// if not to_repair_tmp then
63839: LD_VAR 0 7
63843: NOT
63844: IFFALSE 63848
// continue ;
63846: GO 63646
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
63848: LD_ADDR_VAR 0 8
63852: PUSH
63853: LD_VAR 0 7
63857: PPUSH
63858: LD_VAR 0 3
63862: PPUSH
63863: CALL_OW 74
63867: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
63868: LD_VAR 0 8
63872: PPUSH
63873: LD_INT 16
63875: PPUSH
63876: CALL 19042 0 2
63880: PUSH
63881: LD_INT 4
63883: ARRAY
63884: PUSH
63885: LD_INT 14
63887: LESS
63888: IFFALSE 63904
// ComRepairBuilding ( j , to_repair ) ;
63890: LD_VAR 0 3
63894: PPUSH
63895: LD_VAR 0 8
63899: PPUSH
63900: CALL_OW 130
// end ;
63904: GO 63646
63906: POP
63907: POP
// end ;
63908: GO 63016
63910: POP
63911: POP
// end ;
63912: LD_VAR 0 1
63916: RET
// export function MC_Heal ; var i , j , tmp ; begin
63917: LD_INT 0
63919: PPUSH
63920: PPUSH
63921: PPUSH
63922: PPUSH
// if not mc_bases then
63923: LD_EXP 23
63927: NOT
63928: IFFALSE 63932
// exit ;
63930: GO 64334
// for i = 1 to mc_bases do
63932: LD_ADDR_VAR 0 2
63936: PUSH
63937: DOUBLE
63938: LD_INT 1
63940: DEC
63941: ST_TO_ADDR
63942: LD_EXP 23
63946: PUSH
63947: FOR_TO
63948: IFFALSE 64332
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63950: LD_EXP 26
63954: PUSH
63955: LD_VAR 0 2
63959: ARRAY
63960: PUSH
63961: LD_INT 1
63963: ARRAY
63964: NOT
63965: PUSH
63966: LD_EXP 26
63970: PUSH
63971: LD_VAR 0 2
63975: ARRAY
63976: PUSH
63977: LD_INT 2
63979: ARRAY
63980: NOT
63981: AND
63982: IFFALSE 64020
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63984: LD_ADDR_EXP 27
63988: PUSH
63989: LD_EXP 27
63993: PPUSH
63994: LD_VAR 0 2
63998: PPUSH
63999: EMPTY
64000: PPUSH
64001: CALL_OW 1
64005: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64006: LD_VAR 0 2
64010: PPUSH
64011: LD_INT 102
64013: PPUSH
64014: CALL 58055 0 2
// continue ;
64018: GO 63947
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64020: LD_ADDR_VAR 0 4
64024: PUSH
64025: LD_EXP 23
64029: PUSH
64030: LD_VAR 0 2
64034: ARRAY
64035: PPUSH
64036: LD_INT 25
64038: PUSH
64039: LD_INT 4
64041: PUSH
64042: EMPTY
64043: LIST
64044: LIST
64045: PPUSH
64046: CALL_OW 72
64050: ST_TO_ADDR
// if not tmp then
64051: LD_VAR 0 4
64055: NOT
64056: IFFALSE 64060
// continue ;
64058: GO 63947
// if mc_taming [ i ] then
64060: LD_EXP 54
64064: PUSH
64065: LD_VAR 0 2
64069: ARRAY
64070: IFFALSE 64094
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64072: LD_ADDR_EXP 54
64076: PUSH
64077: LD_EXP 54
64081: PPUSH
64082: LD_VAR 0 2
64086: PPUSH
64087: EMPTY
64088: PPUSH
64089: CALL_OW 1
64093: ST_TO_ADDR
// for j in tmp do
64094: LD_ADDR_VAR 0 3
64098: PUSH
64099: LD_VAR 0 4
64103: PUSH
64104: FOR_IN
64105: IFFALSE 64328
// begin if IsInUnit ( j ) then
64107: LD_VAR 0 3
64111: PPUSH
64112: CALL_OW 310
64116: IFFALSE 64127
// ComExitBuilding ( j ) ;
64118: LD_VAR 0 3
64122: PPUSH
64123: CALL_OW 122
// if not j in mc_healers [ i ] then
64127: LD_VAR 0 3
64131: PUSH
64132: LD_EXP 27
64136: PUSH
64137: LD_VAR 0 2
64141: ARRAY
64142: IN
64143: NOT
64144: IFFALSE 64190
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64146: LD_ADDR_EXP 27
64150: PUSH
64151: LD_EXP 27
64155: PPUSH
64156: LD_VAR 0 2
64160: PUSH
64161: LD_EXP 27
64165: PUSH
64166: LD_VAR 0 2
64170: ARRAY
64171: PUSH
64172: LD_INT 1
64174: PLUS
64175: PUSH
64176: EMPTY
64177: LIST
64178: LIST
64179: PPUSH
64180: LD_VAR 0 3
64184: PPUSH
64185: CALL 16077 0 3
64189: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64190: LD_VAR 0 3
64194: PPUSH
64195: CALL_OW 110
64199: PUSH
64200: LD_INT 102
64202: NONEQUAL
64203: IFFALSE 64217
// SetTag ( j , 102 ) ;
64205: LD_VAR 0 3
64209: PPUSH
64210: LD_INT 102
64212: PPUSH
64213: CALL_OW 109
// Wait ( 3 ) ;
64217: LD_INT 3
64219: PPUSH
64220: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64224: LD_EXP 26
64228: PUSH
64229: LD_VAR 0 2
64233: ARRAY
64234: PUSH
64235: LD_INT 1
64237: ARRAY
64238: IFFALSE 64270
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64240: LD_VAR 0 3
64244: PPUSH
64245: LD_EXP 26
64249: PUSH
64250: LD_VAR 0 2
64254: ARRAY
64255: PUSH
64256: LD_INT 1
64258: ARRAY
64259: PUSH
64260: LD_INT 1
64262: ARRAY
64263: PPUSH
64264: CALL_OW 128
64268: GO 64326
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64270: LD_VAR 0 3
64274: PPUSH
64275: CALL_OW 314
64279: NOT
64280: PUSH
64281: LD_EXP 26
64285: PUSH
64286: LD_VAR 0 2
64290: ARRAY
64291: PUSH
64292: LD_INT 2
64294: ARRAY
64295: AND
64296: IFFALSE 64326
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64298: LD_VAR 0 3
64302: PPUSH
64303: LD_EXP 26
64307: PUSH
64308: LD_VAR 0 2
64312: ARRAY
64313: PUSH
64314: LD_INT 2
64316: ARRAY
64317: PUSH
64318: LD_INT 1
64320: ARRAY
64321: PPUSH
64322: CALL_OW 128
// end ;
64326: GO 64104
64328: POP
64329: POP
// end ;
64330: GO 63947
64332: POP
64333: POP
// end ;
64334: LD_VAR 0 1
64338: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
64339: LD_INT 0
64341: PPUSH
64342: PPUSH
64343: PPUSH
64344: PPUSH
64345: PPUSH
64346: PPUSH
// if not mc_bases then
64347: LD_EXP 23
64351: NOT
64352: IFFALSE 64356
// exit ;
64354: GO 65519
// for i = 1 to mc_bases do
64356: LD_ADDR_VAR 0 2
64360: PUSH
64361: DOUBLE
64362: LD_INT 1
64364: DEC
64365: ST_TO_ADDR
64366: LD_EXP 23
64370: PUSH
64371: FOR_TO
64372: IFFALSE 65517
// begin if mc_scan [ i ] then
64374: LD_EXP 46
64378: PUSH
64379: LD_VAR 0 2
64383: ARRAY
64384: IFFALSE 64388
// continue ;
64386: GO 64371
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64388: LD_EXP 28
64392: PUSH
64393: LD_VAR 0 2
64397: ARRAY
64398: NOT
64399: PUSH
64400: LD_EXP 30
64404: PUSH
64405: LD_VAR 0 2
64409: ARRAY
64410: NOT
64411: AND
64412: PUSH
64413: LD_EXP 29
64417: PUSH
64418: LD_VAR 0 2
64422: ARRAY
64423: AND
64424: IFFALSE 64462
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64426: LD_ADDR_EXP 29
64430: PUSH
64431: LD_EXP 29
64435: PPUSH
64436: LD_VAR 0 2
64440: PPUSH
64441: EMPTY
64442: PPUSH
64443: CALL_OW 1
64447: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64448: LD_VAR 0 2
64452: PPUSH
64453: LD_INT 103
64455: PPUSH
64456: CALL 58055 0 2
// continue ;
64460: GO 64371
// end ; if mc_construct_list [ i ] then
64462: LD_EXP 30
64466: PUSH
64467: LD_VAR 0 2
64471: ARRAY
64472: IFFALSE 64692
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64474: LD_ADDR_VAR 0 5
64478: PUSH
64479: LD_EXP 23
64483: PUSH
64484: LD_VAR 0 2
64488: ARRAY
64489: PPUSH
64490: LD_INT 25
64492: PUSH
64493: LD_INT 2
64495: PUSH
64496: EMPTY
64497: LIST
64498: LIST
64499: PPUSH
64500: CALL_OW 72
64504: PUSH
64505: LD_EXP 25
64509: PUSH
64510: LD_VAR 0 2
64514: ARRAY
64515: DIFF
64516: ST_TO_ADDR
// if not tmp then
64517: LD_VAR 0 5
64521: NOT
64522: IFFALSE 64526
// continue ;
64524: GO 64371
// for j in tmp do
64526: LD_ADDR_VAR 0 3
64530: PUSH
64531: LD_VAR 0 5
64535: PUSH
64536: FOR_IN
64537: IFFALSE 64688
// begin if not mc_builders [ i ] then
64539: LD_EXP 29
64543: PUSH
64544: LD_VAR 0 2
64548: ARRAY
64549: NOT
64550: IFFALSE 64608
// begin SetTag ( j , 103 ) ;
64552: LD_VAR 0 3
64556: PPUSH
64557: LD_INT 103
64559: PPUSH
64560: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64564: LD_ADDR_EXP 29
64568: PUSH
64569: LD_EXP 29
64573: PPUSH
64574: LD_VAR 0 2
64578: PUSH
64579: LD_EXP 29
64583: PUSH
64584: LD_VAR 0 2
64588: ARRAY
64589: PUSH
64590: LD_INT 1
64592: PLUS
64593: PUSH
64594: EMPTY
64595: LIST
64596: LIST
64597: PPUSH
64598: LD_VAR 0 3
64602: PPUSH
64603: CALL 16077 0 3
64607: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64608: LD_VAR 0 3
64612: PPUSH
64613: CALL_OW 310
64617: IFFALSE 64628
// ComExitBuilding ( j ) ;
64619: LD_VAR 0 3
64623: PPUSH
64624: CALL_OW 122
// wait ( 3 ) ;
64628: LD_INT 3
64630: PPUSH
64631: CALL_OW 67
// if not mc_construct_list [ i ] then
64635: LD_EXP 30
64639: PUSH
64640: LD_VAR 0 2
64644: ARRAY
64645: NOT
64646: IFFALSE 64650
// break ;
64648: GO 64688
// if not HasTask ( j ) then
64650: LD_VAR 0 3
64654: PPUSH
64655: CALL_OW 314
64659: NOT
64660: IFFALSE 64686
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64662: LD_VAR 0 3
64666: PPUSH
64667: LD_EXP 30
64671: PUSH
64672: LD_VAR 0 2
64676: ARRAY
64677: PUSH
64678: LD_INT 1
64680: ARRAY
64681: PPUSH
64682: CALL 19315 0 2
// end ;
64686: GO 64536
64688: POP
64689: POP
// end else
64690: GO 65515
// if mc_build_list [ i ] then
64692: LD_EXP 28
64696: PUSH
64697: LD_VAR 0 2
64701: ARRAY
64702: IFFALSE 65515
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64704: LD_EXP 28
64708: PUSH
64709: LD_VAR 0 2
64713: ARRAY
64714: PUSH
64715: LD_INT 1
64717: ARRAY
64718: PUSH
64719: LD_INT 1
64721: ARRAY
64722: PPUSH
64723: CALL 19139 0 1
64727: PUSH
64728: LD_EXP 23
64732: PUSH
64733: LD_VAR 0 2
64737: ARRAY
64738: PPUSH
64739: LD_INT 2
64741: PUSH
64742: LD_INT 30
64744: PUSH
64745: LD_INT 2
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PUSH
64752: LD_INT 30
64754: PUSH
64755: LD_INT 3
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: LIST
64766: PPUSH
64767: CALL_OW 72
64771: NOT
64772: AND
64773: IFFALSE 64878
// begin for j = 1 to mc_build_list [ i ] do
64775: LD_ADDR_VAR 0 3
64779: PUSH
64780: DOUBLE
64781: LD_INT 1
64783: DEC
64784: ST_TO_ADDR
64785: LD_EXP 28
64789: PUSH
64790: LD_VAR 0 2
64794: ARRAY
64795: PUSH
64796: FOR_TO
64797: IFFALSE 64876
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64799: LD_EXP 28
64803: PUSH
64804: LD_VAR 0 2
64808: ARRAY
64809: PUSH
64810: LD_VAR 0 3
64814: ARRAY
64815: PUSH
64816: LD_INT 1
64818: ARRAY
64819: PUSH
64820: LD_INT 2
64822: EQUAL
64823: IFFALSE 64874
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64825: LD_ADDR_EXP 28
64829: PUSH
64830: LD_EXP 28
64834: PPUSH
64835: LD_VAR 0 2
64839: PPUSH
64840: LD_EXP 28
64844: PUSH
64845: LD_VAR 0 2
64849: ARRAY
64850: PPUSH
64851: LD_VAR 0 3
64855: PPUSH
64856: LD_INT 1
64858: PPUSH
64859: LD_INT 0
64861: PPUSH
64862: CALL 15495 0 4
64866: PPUSH
64867: CALL_OW 1
64871: ST_TO_ADDR
// break ;
64872: GO 64876
// end ;
64874: GO 64796
64876: POP
64877: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64878: LD_ADDR_VAR 0 6
64882: PUSH
64883: LD_EXP 23
64887: PUSH
64888: LD_VAR 0 2
64892: ARRAY
64893: PPUSH
64894: LD_INT 2
64896: PUSH
64897: LD_INT 30
64899: PUSH
64900: LD_INT 0
64902: PUSH
64903: EMPTY
64904: LIST
64905: LIST
64906: PUSH
64907: LD_INT 30
64909: PUSH
64910: LD_INT 1
64912: PUSH
64913: EMPTY
64914: LIST
64915: LIST
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: LIST
64921: PPUSH
64922: CALL_OW 72
64926: ST_TO_ADDR
// for k := 1 to depot do
64927: LD_ADDR_VAR 0 4
64931: PUSH
64932: DOUBLE
64933: LD_INT 1
64935: DEC
64936: ST_TO_ADDR
64937: LD_VAR 0 6
64941: PUSH
64942: FOR_TO
64943: IFFALSE 65513
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
64945: LD_EXP 28
64949: PUSH
64950: LD_VAR 0 2
64954: ARRAY
64955: PUSH
64956: LD_INT 1
64958: ARRAY
64959: PUSH
64960: LD_INT 1
64962: ARRAY
64963: PUSH
64964: LD_INT 0
64966: EQUAL
64967: PUSH
64968: LD_VAR 0 6
64972: PUSH
64973: LD_VAR 0 4
64977: ARRAY
64978: PPUSH
64979: LD_EXP 28
64983: PUSH
64984: LD_VAR 0 2
64988: ARRAY
64989: PUSH
64990: LD_INT 1
64992: ARRAY
64993: PUSH
64994: LD_INT 1
64996: ARRAY
64997: PPUSH
64998: LD_EXP 28
65002: PUSH
65003: LD_VAR 0 2
65007: ARRAY
65008: PUSH
65009: LD_INT 1
65011: ARRAY
65012: PUSH
65013: LD_INT 2
65015: ARRAY
65016: PPUSH
65017: LD_EXP 28
65021: PUSH
65022: LD_VAR 0 2
65026: ARRAY
65027: PUSH
65028: LD_INT 1
65030: ARRAY
65031: PUSH
65032: LD_INT 3
65034: ARRAY
65035: PPUSH
65036: LD_EXP 28
65040: PUSH
65041: LD_VAR 0 2
65045: ARRAY
65046: PUSH
65047: LD_INT 1
65049: ARRAY
65050: PUSH
65051: LD_INT 4
65053: ARRAY
65054: PPUSH
65055: CALL 24551 0 5
65059: OR
65060: IFFALSE 65341
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65062: LD_ADDR_VAR 0 5
65066: PUSH
65067: LD_EXP 23
65071: PUSH
65072: LD_VAR 0 2
65076: ARRAY
65077: PPUSH
65078: LD_INT 25
65080: PUSH
65081: LD_INT 2
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PPUSH
65088: CALL_OW 72
65092: PUSH
65093: LD_EXP 25
65097: PUSH
65098: LD_VAR 0 2
65102: ARRAY
65103: DIFF
65104: ST_TO_ADDR
// if not tmp then
65105: LD_VAR 0 5
65109: NOT
65110: IFFALSE 65114
// continue ;
65112: GO 64942
// for j in tmp do
65114: LD_ADDR_VAR 0 3
65118: PUSH
65119: LD_VAR 0 5
65123: PUSH
65124: FOR_IN
65125: IFFALSE 65337
// begin if not mc_builders [ i ] then
65127: LD_EXP 29
65131: PUSH
65132: LD_VAR 0 2
65136: ARRAY
65137: NOT
65138: IFFALSE 65196
// begin SetTag ( j , 103 ) ;
65140: LD_VAR 0 3
65144: PPUSH
65145: LD_INT 103
65147: PPUSH
65148: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65152: LD_ADDR_EXP 29
65156: PUSH
65157: LD_EXP 29
65161: PPUSH
65162: LD_VAR 0 2
65166: PUSH
65167: LD_EXP 29
65171: PUSH
65172: LD_VAR 0 2
65176: ARRAY
65177: PUSH
65178: LD_INT 1
65180: PLUS
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: PPUSH
65186: LD_VAR 0 3
65190: PPUSH
65191: CALL 16077 0 3
65195: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65196: LD_VAR 0 3
65200: PPUSH
65201: CALL_OW 310
65205: IFFALSE 65216
// ComExitBuilding ( j ) ;
65207: LD_VAR 0 3
65211: PPUSH
65212: CALL_OW 122
// wait ( 3 ) ;
65216: LD_INT 3
65218: PPUSH
65219: CALL_OW 67
// if not mc_build_list [ i ] then
65223: LD_EXP 28
65227: PUSH
65228: LD_VAR 0 2
65232: ARRAY
65233: NOT
65234: IFFALSE 65238
// break ;
65236: GO 65337
// if not HasTask ( j ) then
65238: LD_VAR 0 3
65242: PPUSH
65243: CALL_OW 314
65247: NOT
65248: IFFALSE 65335
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65250: LD_VAR 0 3
65254: PPUSH
65255: LD_EXP 28
65259: PUSH
65260: LD_VAR 0 2
65264: ARRAY
65265: PUSH
65266: LD_INT 1
65268: ARRAY
65269: PUSH
65270: LD_INT 1
65272: ARRAY
65273: PPUSH
65274: LD_EXP 28
65278: PUSH
65279: LD_VAR 0 2
65283: ARRAY
65284: PUSH
65285: LD_INT 1
65287: ARRAY
65288: PUSH
65289: LD_INT 2
65291: ARRAY
65292: PPUSH
65293: LD_EXP 28
65297: PUSH
65298: LD_VAR 0 2
65302: ARRAY
65303: PUSH
65304: LD_INT 1
65306: ARRAY
65307: PUSH
65308: LD_INT 3
65310: ARRAY
65311: PPUSH
65312: LD_EXP 28
65316: PUSH
65317: LD_VAR 0 2
65321: ARRAY
65322: PUSH
65323: LD_INT 1
65325: ARRAY
65326: PUSH
65327: LD_INT 4
65329: ARRAY
65330: PPUSH
65331: CALL_OW 145
// end ;
65335: GO 65124
65337: POP
65338: POP
// end else
65339: GO 65511
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
65341: LD_EXP 23
65345: PUSH
65346: LD_VAR 0 2
65350: ARRAY
65351: PPUSH
65352: LD_EXP 28
65356: PUSH
65357: LD_VAR 0 2
65361: ARRAY
65362: PUSH
65363: LD_INT 1
65365: ARRAY
65366: PUSH
65367: LD_INT 1
65369: ARRAY
65370: PPUSH
65371: LD_EXP 28
65375: PUSH
65376: LD_VAR 0 2
65380: ARRAY
65381: PUSH
65382: LD_INT 1
65384: ARRAY
65385: PUSH
65386: LD_INT 2
65388: ARRAY
65389: PPUSH
65390: LD_EXP 28
65394: PUSH
65395: LD_VAR 0 2
65399: ARRAY
65400: PUSH
65401: LD_INT 1
65403: ARRAY
65404: PUSH
65405: LD_INT 3
65407: ARRAY
65408: PPUSH
65409: LD_EXP 28
65413: PUSH
65414: LD_VAR 0 2
65418: ARRAY
65419: PUSH
65420: LD_INT 1
65422: ARRAY
65423: PUSH
65424: LD_INT 4
65426: ARRAY
65427: PPUSH
65428: LD_EXP 23
65432: PUSH
65433: LD_VAR 0 2
65437: ARRAY
65438: PPUSH
65439: LD_INT 21
65441: PUSH
65442: LD_INT 3
65444: PUSH
65445: EMPTY
65446: LIST
65447: LIST
65448: PPUSH
65449: CALL_OW 72
65453: PPUSH
65454: EMPTY
65455: PPUSH
65456: CALL 23305 0 7
65460: NOT
65461: IFFALSE 65511
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65463: LD_ADDR_EXP 28
65467: PUSH
65468: LD_EXP 28
65472: PPUSH
65473: LD_VAR 0 2
65477: PPUSH
65478: LD_EXP 28
65482: PUSH
65483: LD_VAR 0 2
65487: ARRAY
65488: PPUSH
65489: LD_INT 1
65491: PPUSH
65492: LD_INT 1
65494: NEG
65495: PPUSH
65496: LD_INT 0
65498: PPUSH
65499: CALL 15495 0 4
65503: PPUSH
65504: CALL_OW 1
65508: ST_TO_ADDR
// continue ;
65509: GO 64942
// end ; end ;
65511: GO 64942
65513: POP
65514: POP
// end ; end ;
65515: GO 64371
65517: POP
65518: POP
// end ;
65519: LD_VAR 0 1
65523: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65524: LD_INT 0
65526: PPUSH
65527: PPUSH
65528: PPUSH
65529: PPUSH
65530: PPUSH
65531: PPUSH
// if not mc_bases then
65532: LD_EXP 23
65536: NOT
65537: IFFALSE 65541
// exit ;
65539: GO 65968
// for i = 1 to mc_bases do
65541: LD_ADDR_VAR 0 2
65545: PUSH
65546: DOUBLE
65547: LD_INT 1
65549: DEC
65550: ST_TO_ADDR
65551: LD_EXP 23
65555: PUSH
65556: FOR_TO
65557: IFFALSE 65966
// begin tmp := mc_build_upgrade [ i ] ;
65559: LD_ADDR_VAR 0 4
65563: PUSH
65564: LD_EXP 55
65568: PUSH
65569: LD_VAR 0 2
65573: ARRAY
65574: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65575: LD_ADDR_VAR 0 6
65579: PUSH
65580: LD_EXP 56
65584: PUSH
65585: LD_VAR 0 2
65589: ARRAY
65590: PPUSH
65591: LD_INT 2
65593: PUSH
65594: LD_INT 30
65596: PUSH
65597: LD_INT 6
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: LD_INT 30
65606: PUSH
65607: LD_INT 7
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: PUSH
65614: EMPTY
65615: LIST
65616: LIST
65617: LIST
65618: PPUSH
65619: CALL_OW 72
65623: ST_TO_ADDR
// if not tmp and not lab then
65624: LD_VAR 0 4
65628: NOT
65629: PUSH
65630: LD_VAR 0 6
65634: NOT
65635: AND
65636: IFFALSE 65640
// continue ;
65638: GO 65556
// if tmp then
65640: LD_VAR 0 4
65644: IFFALSE 65764
// for j in tmp do
65646: LD_ADDR_VAR 0 3
65650: PUSH
65651: LD_VAR 0 4
65655: PUSH
65656: FOR_IN
65657: IFFALSE 65762
// begin if UpgradeCost ( j ) then
65659: LD_VAR 0 3
65663: PPUSH
65664: CALL 22965 0 1
65668: IFFALSE 65760
// begin ComUpgrade ( j ) ;
65670: LD_VAR 0 3
65674: PPUSH
65675: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65679: LD_ADDR_EXP 55
65683: PUSH
65684: LD_EXP 55
65688: PPUSH
65689: LD_VAR 0 2
65693: PPUSH
65694: LD_EXP 55
65698: PUSH
65699: LD_VAR 0 2
65703: ARRAY
65704: PUSH
65705: LD_VAR 0 3
65709: DIFF
65710: PPUSH
65711: CALL_OW 1
65715: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65716: LD_ADDR_EXP 30
65720: PUSH
65721: LD_EXP 30
65725: PPUSH
65726: LD_VAR 0 2
65730: PUSH
65731: LD_EXP 30
65735: PUSH
65736: LD_VAR 0 2
65740: ARRAY
65741: PUSH
65742: LD_INT 1
65744: PLUS
65745: PUSH
65746: EMPTY
65747: LIST
65748: LIST
65749: PPUSH
65750: LD_VAR 0 3
65754: PPUSH
65755: CALL 16077 0 3
65759: ST_TO_ADDR
// end ; end ;
65760: GO 65656
65762: POP
65763: POP
// if not lab or not mc_lab_upgrade [ i ] then
65764: LD_VAR 0 6
65768: NOT
65769: PUSH
65770: LD_EXP 57
65774: PUSH
65775: LD_VAR 0 2
65779: ARRAY
65780: NOT
65781: OR
65782: IFFALSE 65786
// continue ;
65784: GO 65556
// for j in lab do
65786: LD_ADDR_VAR 0 3
65790: PUSH
65791: LD_VAR 0 6
65795: PUSH
65796: FOR_IN
65797: IFFALSE 65962
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65799: LD_VAR 0 3
65803: PPUSH
65804: CALL_OW 266
65808: PUSH
65809: LD_INT 6
65811: PUSH
65812: LD_INT 7
65814: PUSH
65815: EMPTY
65816: LIST
65817: LIST
65818: IN
65819: PUSH
65820: LD_VAR 0 3
65824: PPUSH
65825: CALL_OW 461
65829: PUSH
65830: LD_INT 1
65832: NONEQUAL
65833: AND
65834: IFFALSE 65960
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65836: LD_VAR 0 3
65840: PPUSH
65841: LD_EXP 57
65845: PUSH
65846: LD_VAR 0 2
65850: ARRAY
65851: PUSH
65852: LD_INT 1
65854: ARRAY
65855: PPUSH
65856: CALL 23170 0 2
65860: IFFALSE 65960
// begin ComCancel ( j ) ;
65862: LD_VAR 0 3
65866: PPUSH
65867: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65871: LD_VAR 0 3
65875: PPUSH
65876: LD_EXP 57
65880: PUSH
65881: LD_VAR 0 2
65885: ARRAY
65886: PUSH
65887: LD_INT 1
65889: ARRAY
65890: PPUSH
65891: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65895: LD_VAR 0 3
65899: PUSH
65900: LD_EXP 30
65904: PUSH
65905: LD_VAR 0 2
65909: ARRAY
65910: IN
65911: NOT
65912: IFFALSE 65958
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65914: LD_ADDR_EXP 30
65918: PUSH
65919: LD_EXP 30
65923: PPUSH
65924: LD_VAR 0 2
65928: PUSH
65929: LD_EXP 30
65933: PUSH
65934: LD_VAR 0 2
65938: ARRAY
65939: PUSH
65940: LD_INT 1
65942: PLUS
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PPUSH
65948: LD_VAR 0 3
65952: PPUSH
65953: CALL 16077 0 3
65957: ST_TO_ADDR
// break ;
65958: GO 65962
// end ; end ; end ;
65960: GO 65796
65962: POP
65963: POP
// end ;
65964: GO 65556
65966: POP
65967: POP
// end ;
65968: LD_VAR 0 1
65972: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65973: LD_INT 0
65975: PPUSH
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
65980: PPUSH
65981: PPUSH
65982: PPUSH
65983: PPUSH
// if not mc_bases then
65984: LD_EXP 23
65988: NOT
65989: IFFALSE 65993
// exit ;
65991: GO 66398
// for i = 1 to mc_bases do
65993: LD_ADDR_VAR 0 2
65997: PUSH
65998: DOUBLE
65999: LD_INT 1
66001: DEC
66002: ST_TO_ADDR
66003: LD_EXP 23
66007: PUSH
66008: FOR_TO
66009: IFFALSE 66396
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66011: LD_EXP 31
66015: PUSH
66016: LD_VAR 0 2
66020: ARRAY
66021: NOT
66022: PUSH
66023: LD_EXP 23
66027: PUSH
66028: LD_VAR 0 2
66032: ARRAY
66033: PPUSH
66034: LD_INT 30
66036: PUSH
66037: LD_INT 3
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PPUSH
66044: CALL_OW 72
66048: NOT
66049: OR
66050: IFFALSE 66054
// continue ;
66052: GO 66008
// busy := false ;
66054: LD_ADDR_VAR 0 8
66058: PUSH
66059: LD_INT 0
66061: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66062: LD_ADDR_VAR 0 4
66066: PUSH
66067: LD_EXP 23
66071: PUSH
66072: LD_VAR 0 2
66076: ARRAY
66077: PPUSH
66078: LD_INT 30
66080: PUSH
66081: LD_INT 3
66083: PUSH
66084: EMPTY
66085: LIST
66086: LIST
66087: PPUSH
66088: CALL_OW 72
66092: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66093: LD_ADDR_VAR 0 6
66097: PUSH
66098: LD_EXP 31
66102: PUSH
66103: LD_VAR 0 2
66107: ARRAY
66108: PPUSH
66109: LD_INT 2
66111: PUSH
66112: LD_INT 30
66114: PUSH
66115: LD_INT 32
66117: PUSH
66118: EMPTY
66119: LIST
66120: LIST
66121: PUSH
66122: LD_INT 30
66124: PUSH
66125: LD_INT 33
66127: PUSH
66128: EMPTY
66129: LIST
66130: LIST
66131: PUSH
66132: EMPTY
66133: LIST
66134: LIST
66135: LIST
66136: PPUSH
66137: CALL_OW 72
66141: ST_TO_ADDR
// if not t then
66142: LD_VAR 0 6
66146: NOT
66147: IFFALSE 66151
// continue ;
66149: GO 66008
// for j in tmp do
66151: LD_ADDR_VAR 0 3
66155: PUSH
66156: LD_VAR 0 4
66160: PUSH
66161: FOR_IN
66162: IFFALSE 66192
// if not BuildingStatus ( j ) = bs_idle then
66164: LD_VAR 0 3
66168: PPUSH
66169: CALL_OW 461
66173: PUSH
66174: LD_INT 2
66176: EQUAL
66177: NOT
66178: IFFALSE 66190
// begin busy := true ;
66180: LD_ADDR_VAR 0 8
66184: PUSH
66185: LD_INT 1
66187: ST_TO_ADDR
// break ;
66188: GO 66192
// end ;
66190: GO 66161
66192: POP
66193: POP
// if busy then
66194: LD_VAR 0 8
66198: IFFALSE 66202
// continue ;
66200: GO 66008
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66202: LD_ADDR_VAR 0 7
66206: PUSH
66207: LD_VAR 0 6
66211: PPUSH
66212: LD_INT 35
66214: PUSH
66215: LD_INT 0
66217: PUSH
66218: EMPTY
66219: LIST
66220: LIST
66221: PPUSH
66222: CALL_OW 72
66226: ST_TO_ADDR
// if tw then
66227: LD_VAR 0 7
66231: IFFALSE 66308
// begin tw := tw [ 1 ] ;
66233: LD_ADDR_VAR 0 7
66237: PUSH
66238: LD_VAR 0 7
66242: PUSH
66243: LD_INT 1
66245: ARRAY
66246: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66247: LD_ADDR_VAR 0 9
66251: PUSH
66252: LD_VAR 0 7
66256: PPUSH
66257: LD_EXP 48
66261: PUSH
66262: LD_VAR 0 2
66266: ARRAY
66267: PPUSH
66268: CALL 21462 0 2
66272: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66273: LD_EXP 62
66277: PUSH
66278: LD_VAR 0 2
66282: ARRAY
66283: IFFALSE 66306
// if not weapon in mc_allowed_tower_weapons [ i ] then
66285: LD_VAR 0 9
66289: PUSH
66290: LD_EXP 62
66294: PUSH
66295: LD_VAR 0 2
66299: ARRAY
66300: IN
66301: NOT
66302: IFFALSE 66306
// continue ;
66304: GO 66008
// end else
66306: GO 66371
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66308: LD_ADDR_VAR 0 5
66312: PUSH
66313: LD_EXP 31
66317: PUSH
66318: LD_VAR 0 2
66322: ARRAY
66323: PPUSH
66324: LD_VAR 0 4
66328: PPUSH
66329: CALL 48354 0 2
66333: ST_TO_ADDR
// if not tmp2 then
66334: LD_VAR 0 5
66338: NOT
66339: IFFALSE 66343
// continue ;
66341: GO 66008
// tw := tmp2 [ 1 ] ;
66343: LD_ADDR_VAR 0 7
66347: PUSH
66348: LD_VAR 0 5
66352: PUSH
66353: LD_INT 1
66355: ARRAY
66356: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66357: LD_ADDR_VAR 0 9
66361: PUSH
66362: LD_VAR 0 5
66366: PUSH
66367: LD_INT 2
66369: ARRAY
66370: ST_TO_ADDR
// end ; if not weapon then
66371: LD_VAR 0 9
66375: NOT
66376: IFFALSE 66380
// continue ;
66378: GO 66008
// ComPlaceWeapon ( tw , weapon ) ;
66380: LD_VAR 0 7
66384: PPUSH
66385: LD_VAR 0 9
66389: PPUSH
66390: CALL_OW 148
// end ;
66394: GO 66008
66396: POP
66397: POP
// end ;
66398: LD_VAR 0 1
66402: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
66403: LD_INT 0
66405: PPUSH
66406: PPUSH
66407: PPUSH
66408: PPUSH
66409: PPUSH
66410: PPUSH
66411: PPUSH
// if not mc_bases then
66412: LD_EXP 23
66416: NOT
66417: IFFALSE 66421
// exit ;
66419: GO 67196
// for i = 1 to mc_bases do
66421: LD_ADDR_VAR 0 2
66425: PUSH
66426: DOUBLE
66427: LD_INT 1
66429: DEC
66430: ST_TO_ADDR
66431: LD_EXP 23
66435: PUSH
66436: FOR_TO
66437: IFFALSE 67194
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
66439: LD_EXP 36
66443: PUSH
66444: LD_VAR 0 2
66448: ARRAY
66449: NOT
66450: PUSH
66451: LD_EXP 36
66455: PUSH
66456: LD_VAR 0 2
66460: ARRAY
66461: PUSH
66462: LD_EXP 37
66466: PUSH
66467: LD_VAR 0 2
66471: ARRAY
66472: EQUAL
66473: OR
66474: PUSH
66475: LD_EXP 46
66479: PUSH
66480: LD_VAR 0 2
66484: ARRAY
66485: OR
66486: IFFALSE 66490
// continue ;
66488: GO 66436
// if mc_miners [ i ] then
66490: LD_EXP 37
66494: PUSH
66495: LD_VAR 0 2
66499: ARRAY
66500: IFFALSE 66881
// begin for j = mc_miners [ i ] downto 1 do
66502: LD_ADDR_VAR 0 3
66506: PUSH
66507: DOUBLE
66508: LD_EXP 37
66512: PUSH
66513: LD_VAR 0 2
66517: ARRAY
66518: INC
66519: ST_TO_ADDR
66520: LD_INT 1
66522: PUSH
66523: FOR_DOWNTO
66524: IFFALSE 66879
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66526: LD_EXP 37
66530: PUSH
66531: LD_VAR 0 2
66535: ARRAY
66536: PUSH
66537: LD_VAR 0 3
66541: ARRAY
66542: PPUSH
66543: CALL_OW 301
66547: PUSH
66548: LD_EXP 37
66552: PUSH
66553: LD_VAR 0 2
66557: ARRAY
66558: PUSH
66559: LD_VAR 0 3
66563: ARRAY
66564: PPUSH
66565: CALL_OW 257
66569: PUSH
66570: LD_INT 1
66572: NONEQUAL
66573: OR
66574: IFFALSE 66637
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66576: LD_ADDR_VAR 0 5
66580: PUSH
66581: LD_EXP 37
66585: PUSH
66586: LD_VAR 0 2
66590: ARRAY
66591: PUSH
66592: LD_EXP 37
66596: PUSH
66597: LD_VAR 0 2
66601: ARRAY
66602: PUSH
66603: LD_VAR 0 3
66607: ARRAY
66608: DIFF
66609: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66610: LD_ADDR_EXP 37
66614: PUSH
66615: LD_EXP 37
66619: PPUSH
66620: LD_VAR 0 2
66624: PPUSH
66625: LD_VAR 0 5
66629: PPUSH
66630: CALL_OW 1
66634: ST_TO_ADDR
// continue ;
66635: GO 66523
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
66637: LD_EXP 37
66641: PUSH
66642: LD_VAR 0 2
66646: ARRAY
66647: PUSH
66648: LD_VAR 0 3
66652: ARRAY
66653: PPUSH
66654: CALL_OW 257
66658: PUSH
66659: LD_INT 1
66661: EQUAL
66662: PUSH
66663: LD_EXP 37
66667: PUSH
66668: LD_VAR 0 2
66672: ARRAY
66673: PUSH
66674: LD_VAR 0 3
66678: ARRAY
66679: PPUSH
66680: CALL_OW 459
66684: NOT
66685: AND
66686: PUSH
66687: LD_EXP 37
66691: PUSH
66692: LD_VAR 0 2
66696: ARRAY
66697: PUSH
66698: LD_VAR 0 3
66702: ARRAY
66703: PPUSH
66704: CALL_OW 314
66708: NOT
66709: AND
66710: IFFALSE 66877
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66712: LD_EXP 37
66716: PUSH
66717: LD_VAR 0 2
66721: ARRAY
66722: PUSH
66723: LD_VAR 0 3
66727: ARRAY
66728: PPUSH
66729: CALL_OW 310
66733: IFFALSE 66756
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66735: LD_EXP 37
66739: PUSH
66740: LD_VAR 0 2
66744: ARRAY
66745: PUSH
66746: LD_VAR 0 3
66750: ARRAY
66751: PPUSH
66752: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66756: LD_EXP 37
66760: PUSH
66761: LD_VAR 0 2
66765: ARRAY
66766: PUSH
66767: LD_VAR 0 3
66771: ARRAY
66772: PPUSH
66773: CALL_OW 314
66777: NOT
66778: IFFALSE 66877
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
66780: LD_ADDR_VAR 0 7
66784: PUSH
66785: LD_VAR 0 3
66789: PUSH
66790: LD_EXP 36
66794: PUSH
66795: LD_VAR 0 2
66799: ARRAY
66800: PPUSH
66801: CALL 13217 0 1
66805: MOD
66806: PUSH
66807: LD_INT 1
66809: PLUS
66810: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
66811: LD_EXP 37
66815: PUSH
66816: LD_VAR 0 2
66820: ARRAY
66821: PUSH
66822: LD_VAR 0 3
66826: ARRAY
66827: PPUSH
66828: LD_EXP 36
66832: PUSH
66833: LD_VAR 0 2
66837: ARRAY
66838: PUSH
66839: LD_VAR 0 7
66843: ARRAY
66844: PUSH
66845: LD_INT 1
66847: ARRAY
66848: PPUSH
66849: LD_EXP 36
66853: PUSH
66854: LD_VAR 0 2
66858: ARRAY
66859: PUSH
66860: LD_VAR 0 7
66864: ARRAY
66865: PUSH
66866: LD_INT 2
66868: ARRAY
66869: PPUSH
66870: LD_INT 0
66872: PPUSH
66873: CALL_OW 193
// end ; end ; end ;
66877: GO 66523
66879: POP
66880: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66881: LD_ADDR_VAR 0 5
66885: PUSH
66886: LD_EXP 23
66890: PUSH
66891: LD_VAR 0 2
66895: ARRAY
66896: PPUSH
66897: LD_INT 2
66899: PUSH
66900: LD_INT 30
66902: PUSH
66903: LD_INT 4
66905: PUSH
66906: EMPTY
66907: LIST
66908: LIST
66909: PUSH
66910: LD_INT 30
66912: PUSH
66913: LD_INT 5
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PUSH
66920: LD_INT 30
66922: PUSH
66923: LD_INT 32
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: EMPTY
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: PPUSH
66936: CALL_OW 72
66940: ST_TO_ADDR
// if not tmp then
66941: LD_VAR 0 5
66945: NOT
66946: IFFALSE 66950
// continue ;
66948: GO 66436
// list := [ ] ;
66950: LD_ADDR_VAR 0 6
66954: PUSH
66955: EMPTY
66956: ST_TO_ADDR
// for j in tmp do
66957: LD_ADDR_VAR 0 3
66961: PUSH
66962: LD_VAR 0 5
66966: PUSH
66967: FOR_IN
66968: IFFALSE 67037
// begin for k in UnitsInside ( j ) do
66970: LD_ADDR_VAR 0 4
66974: PUSH
66975: LD_VAR 0 3
66979: PPUSH
66980: CALL_OW 313
66984: PUSH
66985: FOR_IN
66986: IFFALSE 67033
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66988: LD_VAR 0 4
66992: PPUSH
66993: CALL_OW 257
66997: PUSH
66998: LD_INT 1
67000: EQUAL
67001: PUSH
67002: LD_VAR 0 4
67006: PPUSH
67007: CALL_OW 459
67011: NOT
67012: AND
67013: IFFALSE 67031
// list := list ^ k ;
67015: LD_ADDR_VAR 0 6
67019: PUSH
67020: LD_VAR 0 6
67024: PUSH
67025: LD_VAR 0 4
67029: ADD
67030: ST_TO_ADDR
67031: GO 66985
67033: POP
67034: POP
// end ;
67035: GO 66967
67037: POP
67038: POP
// list := list diff mc_miners [ i ] ;
67039: LD_ADDR_VAR 0 6
67043: PUSH
67044: LD_VAR 0 6
67048: PUSH
67049: LD_EXP 37
67053: PUSH
67054: LD_VAR 0 2
67058: ARRAY
67059: DIFF
67060: ST_TO_ADDR
// if not list then
67061: LD_VAR 0 6
67065: NOT
67066: IFFALSE 67070
// continue ;
67068: GO 66436
// k := mc_mines [ i ] - mc_miners [ i ] ;
67070: LD_ADDR_VAR 0 4
67074: PUSH
67075: LD_EXP 36
67079: PUSH
67080: LD_VAR 0 2
67084: ARRAY
67085: PUSH
67086: LD_EXP 37
67090: PUSH
67091: LD_VAR 0 2
67095: ARRAY
67096: MINUS
67097: ST_TO_ADDR
// if k > list then
67098: LD_VAR 0 4
67102: PUSH
67103: LD_VAR 0 6
67107: GREATER
67108: IFFALSE 67120
// k := list ;
67110: LD_ADDR_VAR 0 4
67114: PUSH
67115: LD_VAR 0 6
67119: ST_TO_ADDR
// for j = 1 to k do
67120: LD_ADDR_VAR 0 3
67124: PUSH
67125: DOUBLE
67126: LD_INT 1
67128: DEC
67129: ST_TO_ADDR
67130: LD_VAR 0 4
67134: PUSH
67135: FOR_TO
67136: IFFALSE 67190
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67138: LD_ADDR_EXP 37
67142: PUSH
67143: LD_EXP 37
67147: PPUSH
67148: LD_VAR 0 2
67152: PUSH
67153: LD_EXP 37
67157: PUSH
67158: LD_VAR 0 2
67162: ARRAY
67163: PUSH
67164: LD_INT 1
67166: PLUS
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PPUSH
67172: LD_VAR 0 6
67176: PUSH
67177: LD_VAR 0 3
67181: ARRAY
67182: PPUSH
67183: CALL 16077 0 3
67187: ST_TO_ADDR
67188: GO 67135
67190: POP
67191: POP
// end ;
67192: GO 66436
67194: POP
67195: POP
// end ;
67196: LD_VAR 0 1
67200: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
67201: LD_INT 0
67203: PPUSH
67204: PPUSH
67205: PPUSH
67206: PPUSH
67207: PPUSH
67208: PPUSH
67209: PPUSH
67210: PPUSH
67211: PPUSH
67212: PPUSH
67213: PPUSH
// if not mc_bases then
67214: LD_EXP 23
67218: NOT
67219: IFFALSE 67223
// exit ;
67221: GO 69046
// for i = 1 to mc_bases do
67223: LD_ADDR_VAR 0 2
67227: PUSH
67228: DOUBLE
67229: LD_INT 1
67231: DEC
67232: ST_TO_ADDR
67233: LD_EXP 23
67237: PUSH
67238: FOR_TO
67239: IFFALSE 69044
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67241: LD_EXP 23
67245: PUSH
67246: LD_VAR 0 2
67250: ARRAY
67251: NOT
67252: PUSH
67253: LD_EXP 30
67257: PUSH
67258: LD_VAR 0 2
67262: ARRAY
67263: OR
67264: IFFALSE 67268
// continue ;
67266: GO 67238
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67268: LD_EXP 39
67272: PUSH
67273: LD_VAR 0 2
67277: ARRAY
67278: NOT
67279: PUSH
67280: LD_EXP 40
67284: PUSH
67285: LD_VAR 0 2
67289: ARRAY
67290: AND
67291: IFFALSE 67329
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67293: LD_ADDR_EXP 40
67297: PUSH
67298: LD_EXP 40
67302: PPUSH
67303: LD_VAR 0 2
67307: PPUSH
67308: EMPTY
67309: PPUSH
67310: CALL_OW 1
67314: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67315: LD_VAR 0 2
67319: PPUSH
67320: LD_INT 107
67322: PPUSH
67323: CALL 58055 0 2
// continue ;
67327: GO 67238
// end ; target := [ ] ;
67329: LD_ADDR_VAR 0 7
67333: PUSH
67334: EMPTY
67335: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67336: LD_ADDR_VAR 0 6
67340: PUSH
67341: LD_EXP 23
67345: PUSH
67346: LD_VAR 0 2
67350: ARRAY
67351: PUSH
67352: LD_INT 1
67354: ARRAY
67355: PPUSH
67356: CALL_OW 255
67360: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67361: LD_ADDR_VAR 0 9
67365: PUSH
67366: LD_EXP 23
67370: PUSH
67371: LD_VAR 0 2
67375: ARRAY
67376: PPUSH
67377: LD_INT 2
67379: PUSH
67380: LD_INT 30
67382: PUSH
67383: LD_INT 0
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: LD_INT 30
67392: PUSH
67393: LD_INT 1
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: LIST
67404: PPUSH
67405: CALL_OW 72
67409: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67410: LD_ADDR_VAR 0 3
67414: PUSH
67415: DOUBLE
67416: LD_EXP 39
67420: PUSH
67421: LD_VAR 0 2
67425: ARRAY
67426: INC
67427: ST_TO_ADDR
67428: LD_INT 1
67430: PUSH
67431: FOR_DOWNTO
67432: IFFALSE 67677
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67434: LD_EXP 39
67438: PUSH
67439: LD_VAR 0 2
67443: ARRAY
67444: PUSH
67445: LD_VAR 0 3
67449: ARRAY
67450: PUSH
67451: LD_INT 2
67453: ARRAY
67454: PPUSH
67455: LD_EXP 39
67459: PUSH
67460: LD_VAR 0 2
67464: ARRAY
67465: PUSH
67466: LD_VAR 0 3
67470: ARRAY
67471: PUSH
67472: LD_INT 3
67474: ARRAY
67475: PPUSH
67476: CALL_OW 488
67480: PUSH
67481: LD_EXP 39
67485: PUSH
67486: LD_VAR 0 2
67490: ARRAY
67491: PUSH
67492: LD_VAR 0 3
67496: ARRAY
67497: PUSH
67498: LD_INT 2
67500: ARRAY
67501: PPUSH
67502: LD_EXP 39
67506: PUSH
67507: LD_VAR 0 2
67511: ARRAY
67512: PUSH
67513: LD_VAR 0 3
67517: ARRAY
67518: PUSH
67519: LD_INT 3
67521: ARRAY
67522: PPUSH
67523: CALL_OW 284
67527: PUSH
67528: LD_INT 0
67530: EQUAL
67531: AND
67532: IFFALSE 67587
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67534: LD_ADDR_VAR 0 5
67538: PUSH
67539: LD_EXP 39
67543: PUSH
67544: LD_VAR 0 2
67548: ARRAY
67549: PPUSH
67550: LD_VAR 0 3
67554: PPUSH
67555: CALL_OW 3
67559: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67560: LD_ADDR_EXP 39
67564: PUSH
67565: LD_EXP 39
67569: PPUSH
67570: LD_VAR 0 2
67574: PPUSH
67575: LD_VAR 0 5
67579: PPUSH
67580: CALL_OW 1
67584: ST_TO_ADDR
// continue ;
67585: GO 67431
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67587: LD_VAR 0 6
67591: PPUSH
67592: LD_EXP 39
67596: PUSH
67597: LD_VAR 0 2
67601: ARRAY
67602: PUSH
67603: LD_VAR 0 3
67607: ARRAY
67608: PUSH
67609: LD_INT 2
67611: ARRAY
67612: PPUSH
67613: LD_EXP 39
67617: PUSH
67618: LD_VAR 0 2
67622: ARRAY
67623: PUSH
67624: LD_VAR 0 3
67628: ARRAY
67629: PUSH
67630: LD_INT 3
67632: ARRAY
67633: PPUSH
67634: LD_INT 30
67636: PPUSH
67637: CALL 17341 0 4
67641: PUSH
67642: LD_INT 4
67644: ARRAY
67645: PUSH
67646: LD_INT 0
67648: EQUAL
67649: IFFALSE 67675
// begin target := mc_crates [ i ] [ j ] ;
67651: LD_ADDR_VAR 0 7
67655: PUSH
67656: LD_EXP 39
67660: PUSH
67661: LD_VAR 0 2
67665: ARRAY
67666: PUSH
67667: LD_VAR 0 3
67671: ARRAY
67672: ST_TO_ADDR
// break ;
67673: GO 67677
// end ; end ;
67675: GO 67431
67677: POP
67678: POP
// if not target then
67679: LD_VAR 0 7
67683: NOT
67684: IFFALSE 67688
// continue ;
67686: GO 67238
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67688: LD_ADDR_VAR 0 8
67692: PUSH
67693: LD_EXP 42
67697: PUSH
67698: LD_VAR 0 2
67702: ARRAY
67703: PPUSH
67704: LD_INT 2
67706: PUSH
67707: LD_INT 3
67709: PUSH
67710: LD_INT 58
67712: PUSH
67713: EMPTY
67714: LIST
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: PUSH
67720: LD_INT 61
67722: PUSH
67723: EMPTY
67724: LIST
67725: PUSH
67726: LD_INT 33
67728: PUSH
67729: LD_INT 5
67731: PUSH
67732: EMPTY
67733: LIST
67734: LIST
67735: PUSH
67736: LD_INT 33
67738: PUSH
67739: LD_INT 3
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: PUSH
67746: EMPTY
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: PUSH
67753: LD_INT 2
67755: PUSH
67756: LD_INT 34
67758: PUSH
67759: LD_INT 32
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: PUSH
67766: LD_INT 34
67768: PUSH
67769: LD_INT 51
67771: PUSH
67772: EMPTY
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 34
67778: PUSH
67779: LD_INT 12
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: LIST
67790: LIST
67791: PUSH
67792: EMPTY
67793: LIST
67794: LIST
67795: PPUSH
67796: CALL_OW 72
67800: ST_TO_ADDR
// if not cargo then
67801: LD_VAR 0 8
67805: NOT
67806: IFFALSE 68512
// begin if mc_crates_collector [ i ] < 5 then
67808: LD_EXP 40
67812: PUSH
67813: LD_VAR 0 2
67817: ARRAY
67818: PUSH
67819: LD_INT 5
67821: LESS
67822: IFFALSE 68188
// begin if mc_ape [ i ] then
67824: LD_EXP 52
67828: PUSH
67829: LD_VAR 0 2
67833: ARRAY
67834: IFFALSE 67881
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67836: LD_ADDR_VAR 0 5
67840: PUSH
67841: LD_EXP 52
67845: PUSH
67846: LD_VAR 0 2
67850: ARRAY
67851: PPUSH
67852: LD_INT 25
67854: PUSH
67855: LD_INT 16
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: LD_INT 24
67864: PUSH
67865: LD_INT 750
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PPUSH
67876: CALL_OW 72
67880: ST_TO_ADDR
// if not tmp then
67881: LD_VAR 0 5
67885: NOT
67886: IFFALSE 67933
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67888: LD_ADDR_VAR 0 5
67892: PUSH
67893: LD_EXP 23
67897: PUSH
67898: LD_VAR 0 2
67902: ARRAY
67903: PPUSH
67904: LD_INT 25
67906: PUSH
67907: LD_INT 2
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PUSH
67914: LD_INT 24
67916: PUSH
67917: LD_INT 750
67919: PUSH
67920: EMPTY
67921: LIST
67922: LIST
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PPUSH
67928: CALL_OW 72
67932: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67933: LD_EXP 52
67937: PUSH
67938: LD_VAR 0 2
67942: ARRAY
67943: PUSH
67944: LD_EXP 23
67948: PUSH
67949: LD_VAR 0 2
67953: ARRAY
67954: PPUSH
67955: LD_INT 25
67957: PUSH
67958: LD_INT 2
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 24
67967: PUSH
67968: LD_INT 750
67970: PUSH
67971: EMPTY
67972: LIST
67973: LIST
67974: PUSH
67975: EMPTY
67976: LIST
67977: LIST
67978: PPUSH
67979: CALL_OW 72
67983: AND
67984: PUSH
67985: LD_VAR 0 5
67989: PUSH
67990: LD_INT 5
67992: LESS
67993: AND
67994: IFFALSE 68076
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67996: LD_ADDR_VAR 0 3
68000: PUSH
68001: LD_EXP 23
68005: PUSH
68006: LD_VAR 0 2
68010: ARRAY
68011: PPUSH
68012: LD_INT 25
68014: PUSH
68015: LD_INT 2
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: LD_INT 24
68024: PUSH
68025: LD_INT 750
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: PUSH
68032: EMPTY
68033: LIST
68034: LIST
68035: PPUSH
68036: CALL_OW 72
68040: PUSH
68041: FOR_IN
68042: IFFALSE 68074
// begin tmp := tmp union j ;
68044: LD_ADDR_VAR 0 5
68048: PUSH
68049: LD_VAR 0 5
68053: PUSH
68054: LD_VAR 0 3
68058: UNION
68059: ST_TO_ADDR
// if tmp >= 5 then
68060: LD_VAR 0 5
68064: PUSH
68065: LD_INT 5
68067: GREATEREQUAL
68068: IFFALSE 68072
// break ;
68070: GO 68074
// end ;
68072: GO 68041
68074: POP
68075: POP
// end ; if not tmp then
68076: LD_VAR 0 5
68080: NOT
68081: IFFALSE 68085
// continue ;
68083: GO 67238
// for j in tmp do
68085: LD_ADDR_VAR 0 3
68089: PUSH
68090: LD_VAR 0 5
68094: PUSH
68095: FOR_IN
68096: IFFALSE 68186
// if not GetTag ( j ) then
68098: LD_VAR 0 3
68102: PPUSH
68103: CALL_OW 110
68107: NOT
68108: IFFALSE 68184
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68110: LD_ADDR_EXP 40
68114: PUSH
68115: LD_EXP 40
68119: PPUSH
68120: LD_VAR 0 2
68124: PUSH
68125: LD_EXP 40
68129: PUSH
68130: LD_VAR 0 2
68134: ARRAY
68135: PUSH
68136: LD_INT 1
68138: PLUS
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PPUSH
68144: LD_VAR 0 3
68148: PPUSH
68149: CALL 16077 0 3
68153: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68154: LD_VAR 0 3
68158: PPUSH
68159: LD_INT 107
68161: PPUSH
68162: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68166: LD_EXP 40
68170: PUSH
68171: LD_VAR 0 2
68175: ARRAY
68176: PUSH
68177: LD_INT 5
68179: GREATEREQUAL
68180: IFFALSE 68184
// break ;
68182: GO 68186
// end ;
68184: GO 68095
68186: POP
68187: POP
// end ; if mc_crates_collector [ i ] and target then
68188: LD_EXP 40
68192: PUSH
68193: LD_VAR 0 2
68197: ARRAY
68198: PUSH
68199: LD_VAR 0 7
68203: AND
68204: IFFALSE 68510
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68206: LD_EXP 40
68210: PUSH
68211: LD_VAR 0 2
68215: ARRAY
68216: PUSH
68217: LD_VAR 0 7
68221: PUSH
68222: LD_INT 1
68224: ARRAY
68225: LESS
68226: IFFALSE 68246
// tmp := mc_crates_collector [ i ] else
68228: LD_ADDR_VAR 0 5
68232: PUSH
68233: LD_EXP 40
68237: PUSH
68238: LD_VAR 0 2
68242: ARRAY
68243: ST_TO_ADDR
68244: GO 68260
// tmp := target [ 1 ] ;
68246: LD_ADDR_VAR 0 5
68250: PUSH
68251: LD_VAR 0 7
68255: PUSH
68256: LD_INT 1
68258: ARRAY
68259: ST_TO_ADDR
// k := 0 ;
68260: LD_ADDR_VAR 0 4
68264: PUSH
68265: LD_INT 0
68267: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68268: LD_ADDR_VAR 0 3
68272: PUSH
68273: LD_EXP 40
68277: PUSH
68278: LD_VAR 0 2
68282: ARRAY
68283: PUSH
68284: FOR_IN
68285: IFFALSE 68508
// begin k := k + 1 ;
68287: LD_ADDR_VAR 0 4
68291: PUSH
68292: LD_VAR 0 4
68296: PUSH
68297: LD_INT 1
68299: PLUS
68300: ST_TO_ADDR
// if k > tmp then
68301: LD_VAR 0 4
68305: PUSH
68306: LD_VAR 0 5
68310: GREATER
68311: IFFALSE 68315
// break ;
68313: GO 68508
// if not GetClass ( j ) in [ 2 , 16 ] then
68315: LD_VAR 0 3
68319: PPUSH
68320: CALL_OW 257
68324: PUSH
68325: LD_INT 2
68327: PUSH
68328: LD_INT 16
68330: PUSH
68331: EMPTY
68332: LIST
68333: LIST
68334: IN
68335: NOT
68336: IFFALSE 68389
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68338: LD_ADDR_EXP 40
68342: PUSH
68343: LD_EXP 40
68347: PPUSH
68348: LD_VAR 0 2
68352: PPUSH
68353: LD_EXP 40
68357: PUSH
68358: LD_VAR 0 2
68362: ARRAY
68363: PUSH
68364: LD_VAR 0 3
68368: DIFF
68369: PPUSH
68370: CALL_OW 1
68374: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68375: LD_VAR 0 3
68379: PPUSH
68380: LD_INT 0
68382: PPUSH
68383: CALL_OW 109
// continue ;
68387: GO 68284
// end ; if IsInUnit ( j ) then
68389: LD_VAR 0 3
68393: PPUSH
68394: CALL_OW 310
68398: IFFALSE 68409
// ComExitBuilding ( j ) ;
68400: LD_VAR 0 3
68404: PPUSH
68405: CALL_OW 122
// wait ( 3 ) ;
68409: LD_INT 3
68411: PPUSH
68412: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
68416: LD_VAR 0 3
68420: PPUSH
68421: CALL_OW 314
68425: PUSH
68426: LD_VAR 0 6
68430: PPUSH
68431: LD_VAR 0 7
68435: PUSH
68436: LD_INT 2
68438: ARRAY
68439: PPUSH
68440: LD_VAR 0 7
68444: PUSH
68445: LD_INT 3
68447: ARRAY
68448: PPUSH
68449: LD_INT 30
68451: PPUSH
68452: CALL 17341 0 4
68456: PUSH
68457: LD_INT 4
68459: ARRAY
68460: AND
68461: IFFALSE 68479
// ComStandNearbyBuilding ( j , depot ) else
68463: LD_VAR 0 3
68467: PPUSH
68468: LD_VAR 0 9
68472: PPUSH
68473: CALL 12679 0 2
68477: GO 68506
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68479: LD_VAR 0 3
68483: PPUSH
68484: LD_VAR 0 7
68488: PUSH
68489: LD_INT 2
68491: ARRAY
68492: PPUSH
68493: LD_VAR 0 7
68497: PUSH
68498: LD_INT 3
68500: ARRAY
68501: PPUSH
68502: CALL_OW 117
// end ;
68506: GO 68284
68508: POP
68509: POP
// end ; end else
68510: GO 69042
// begin for j in cargo do
68512: LD_ADDR_VAR 0 3
68516: PUSH
68517: LD_VAR 0 8
68521: PUSH
68522: FOR_IN
68523: IFFALSE 69040
// begin if GetTag ( j ) <> 0 then
68525: LD_VAR 0 3
68529: PPUSH
68530: CALL_OW 110
68534: PUSH
68535: LD_INT 0
68537: NONEQUAL
68538: IFFALSE 68542
// continue ;
68540: GO 68522
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68542: LD_VAR 0 3
68546: PPUSH
68547: CALL_OW 256
68551: PUSH
68552: LD_INT 1000
68554: LESS
68555: PUSH
68556: LD_VAR 0 3
68560: PPUSH
68561: LD_EXP 47
68565: PUSH
68566: LD_VAR 0 2
68570: ARRAY
68571: PPUSH
68572: CALL_OW 308
68576: NOT
68577: AND
68578: IFFALSE 68600
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68580: LD_VAR 0 3
68584: PPUSH
68585: LD_EXP 47
68589: PUSH
68590: LD_VAR 0 2
68594: ARRAY
68595: PPUSH
68596: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68600: LD_VAR 0 3
68604: PPUSH
68605: CALL_OW 256
68609: PUSH
68610: LD_INT 1000
68612: LESS
68613: PUSH
68614: LD_VAR 0 3
68618: PPUSH
68619: LD_EXP 47
68623: PUSH
68624: LD_VAR 0 2
68628: ARRAY
68629: PPUSH
68630: CALL_OW 308
68634: AND
68635: IFFALSE 68639
// continue ;
68637: GO 68522
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68639: LD_VAR 0 3
68643: PPUSH
68644: CALL_OW 262
68648: PUSH
68649: LD_INT 2
68651: EQUAL
68652: PUSH
68653: LD_VAR 0 3
68657: PPUSH
68658: CALL_OW 261
68662: PUSH
68663: LD_INT 15
68665: LESS
68666: AND
68667: IFFALSE 68671
// continue ;
68669: GO 68522
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68671: LD_VAR 0 3
68675: PPUSH
68676: CALL_OW 262
68680: PUSH
68681: LD_INT 1
68683: EQUAL
68684: PUSH
68685: LD_VAR 0 3
68689: PPUSH
68690: CALL_OW 261
68694: PUSH
68695: LD_INT 10
68697: LESS
68698: AND
68699: IFFALSE 68979
// begin if not depot then
68701: LD_VAR 0 9
68705: NOT
68706: IFFALSE 68710
// continue ;
68708: GO 68522
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68710: LD_VAR 0 3
68714: PPUSH
68715: LD_VAR 0 9
68719: PPUSH
68720: LD_VAR 0 3
68724: PPUSH
68725: CALL_OW 74
68729: PPUSH
68730: CALL_OW 296
68734: PUSH
68735: LD_INT 6
68737: LESS
68738: IFFALSE 68754
// SetFuel ( j , 100 ) else
68740: LD_VAR 0 3
68744: PPUSH
68745: LD_INT 100
68747: PPUSH
68748: CALL_OW 240
68752: GO 68979
// if GetFuel ( j ) = 0 then
68754: LD_VAR 0 3
68758: PPUSH
68759: CALL_OW 261
68763: PUSH
68764: LD_INT 0
68766: EQUAL
68767: IFFALSE 68979
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68769: LD_ADDR_EXP 42
68773: PUSH
68774: LD_EXP 42
68778: PPUSH
68779: LD_VAR 0 2
68783: PPUSH
68784: LD_EXP 42
68788: PUSH
68789: LD_VAR 0 2
68793: ARRAY
68794: PUSH
68795: LD_VAR 0 3
68799: DIFF
68800: PPUSH
68801: CALL_OW 1
68805: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68806: LD_VAR 0 3
68810: PPUSH
68811: CALL_OW 263
68815: PUSH
68816: LD_INT 1
68818: EQUAL
68819: IFFALSE 68835
// ComExitVehicle ( IsInUnit ( j ) ) ;
68821: LD_VAR 0 3
68825: PPUSH
68826: CALL_OW 310
68830: PPUSH
68831: CALL_OW 121
// if GetControl ( j ) = control_remote then
68835: LD_VAR 0 3
68839: PPUSH
68840: CALL_OW 263
68844: PUSH
68845: LD_INT 2
68847: EQUAL
68848: IFFALSE 68859
// ComUnlink ( j ) ;
68850: LD_VAR 0 3
68854: PPUSH
68855: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
68859: LD_ADDR_VAR 0 10
68863: PUSH
68864: LD_VAR 0 2
68868: PPUSH
68869: LD_INT 3
68871: PPUSH
68872: CALL 78623 0 2
68876: ST_TO_ADDR
// if fac then
68877: LD_VAR 0 10
68881: IFFALSE 68977
// begin for k in fac do
68883: LD_ADDR_VAR 0 4
68887: PUSH
68888: LD_VAR 0 10
68892: PUSH
68893: FOR_IN
68894: IFFALSE 68975
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68896: LD_ADDR_VAR 0 11
68900: PUSH
68901: LD_VAR 0 10
68905: PPUSH
68906: LD_VAR 0 3
68910: PPUSH
68911: CALL_OW 265
68915: PPUSH
68916: LD_VAR 0 3
68920: PPUSH
68921: CALL_OW 262
68925: PPUSH
68926: LD_VAR 0 3
68930: PPUSH
68931: CALL_OW 263
68935: PPUSH
68936: LD_VAR 0 3
68940: PPUSH
68941: CALL_OW 264
68945: PPUSH
68946: CALL 13575 0 5
68950: ST_TO_ADDR
// if components then
68951: LD_VAR 0 11
68955: IFFALSE 68973
// begin MC_InsertProduceList ( i , components ) ;
68957: LD_VAR 0 2
68961: PPUSH
68962: LD_VAR 0 11
68966: PPUSH
68967: CALL 78168 0 2
// break ;
68971: GO 68975
// end ; end ;
68973: GO 68893
68975: POP
68976: POP
// end ; continue ;
68977: GO 68522
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68979: LD_VAR 0 3
68983: PPUSH
68984: LD_INT 1
68986: PPUSH
68987: CALL_OW 289
68991: PUSH
68992: LD_INT 100
68994: LESS
68995: PUSH
68996: LD_VAR 0 3
69000: PPUSH
69001: CALL_OW 314
69005: NOT
69006: AND
69007: IFFALSE 69036
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69009: LD_VAR 0 3
69013: PPUSH
69014: LD_VAR 0 7
69018: PUSH
69019: LD_INT 2
69021: ARRAY
69022: PPUSH
69023: LD_VAR 0 7
69027: PUSH
69028: LD_INT 3
69030: ARRAY
69031: PPUSH
69032: CALL_OW 117
// break ;
69036: GO 69040
// end ;
69038: GO 68522
69040: POP
69041: POP
// end ; end ;
69042: GO 67238
69044: POP
69045: POP
// end ;
69046: LD_VAR 0 1
69050: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69051: LD_INT 0
69053: PPUSH
69054: PPUSH
69055: PPUSH
69056: PPUSH
// if not mc_bases then
69057: LD_EXP 23
69061: NOT
69062: IFFALSE 69066
// exit ;
69064: GO 69227
// for i = 1 to mc_bases do
69066: LD_ADDR_VAR 0 2
69070: PUSH
69071: DOUBLE
69072: LD_INT 1
69074: DEC
69075: ST_TO_ADDR
69076: LD_EXP 23
69080: PUSH
69081: FOR_TO
69082: IFFALSE 69225
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69084: LD_ADDR_VAR 0 4
69088: PUSH
69089: LD_EXP 42
69093: PUSH
69094: LD_VAR 0 2
69098: ARRAY
69099: PUSH
69100: LD_EXP 45
69104: PUSH
69105: LD_VAR 0 2
69109: ARRAY
69110: UNION
69111: PPUSH
69112: LD_INT 33
69114: PUSH
69115: LD_INT 2
69117: PUSH
69118: EMPTY
69119: LIST
69120: LIST
69121: PPUSH
69122: CALL_OW 72
69126: ST_TO_ADDR
// if tmp then
69127: LD_VAR 0 4
69131: IFFALSE 69223
// for j in tmp do
69133: LD_ADDR_VAR 0 3
69137: PUSH
69138: LD_VAR 0 4
69142: PUSH
69143: FOR_IN
69144: IFFALSE 69221
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69146: LD_VAR 0 3
69150: PPUSH
69151: CALL_OW 312
69155: NOT
69156: PUSH
69157: LD_VAR 0 3
69161: PPUSH
69162: CALL_OW 256
69166: PUSH
69167: LD_INT 250
69169: GREATEREQUAL
69170: AND
69171: IFFALSE 69184
// Connect ( j ) else
69173: LD_VAR 0 3
69177: PPUSH
69178: CALL 19423 0 1
69182: GO 69219
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69184: LD_VAR 0 3
69188: PPUSH
69189: CALL_OW 256
69193: PUSH
69194: LD_INT 250
69196: LESS
69197: PUSH
69198: LD_VAR 0 3
69202: PPUSH
69203: CALL_OW 312
69207: AND
69208: IFFALSE 69219
// ComUnlink ( j ) ;
69210: LD_VAR 0 3
69214: PPUSH
69215: CALL_OW 136
69219: GO 69143
69221: POP
69222: POP
// end ;
69223: GO 69081
69225: POP
69226: POP
// end ;
69227: LD_VAR 0 1
69231: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69232: LD_INT 0
69234: PPUSH
69235: PPUSH
69236: PPUSH
69237: PPUSH
69238: PPUSH
// if not mc_bases then
69239: LD_EXP 23
69243: NOT
69244: IFFALSE 69248
// exit ;
69246: GO 69693
// for i = 1 to mc_bases do
69248: LD_ADDR_VAR 0 2
69252: PUSH
69253: DOUBLE
69254: LD_INT 1
69256: DEC
69257: ST_TO_ADDR
69258: LD_EXP 23
69262: PUSH
69263: FOR_TO
69264: IFFALSE 69691
// begin if not mc_produce [ i ] then
69266: LD_EXP 44
69270: PUSH
69271: LD_VAR 0 2
69275: ARRAY
69276: NOT
69277: IFFALSE 69281
// continue ;
69279: GO 69263
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69281: LD_ADDR_VAR 0 5
69285: PUSH
69286: LD_EXP 23
69290: PUSH
69291: LD_VAR 0 2
69295: ARRAY
69296: PPUSH
69297: LD_INT 30
69299: PUSH
69300: LD_INT 3
69302: PUSH
69303: EMPTY
69304: LIST
69305: LIST
69306: PPUSH
69307: CALL_OW 72
69311: ST_TO_ADDR
// if not fac then
69312: LD_VAR 0 5
69316: NOT
69317: IFFALSE 69321
// continue ;
69319: GO 69263
// for j in fac do
69321: LD_ADDR_VAR 0 3
69325: PUSH
69326: LD_VAR 0 5
69330: PUSH
69331: FOR_IN
69332: IFFALSE 69687
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69334: LD_VAR 0 3
69338: PPUSH
69339: CALL_OW 461
69343: PUSH
69344: LD_INT 2
69346: NONEQUAL
69347: PUSH
69348: LD_VAR 0 3
69352: PPUSH
69353: LD_INT 15
69355: PPUSH
69356: CALL 19042 0 2
69360: PUSH
69361: LD_INT 4
69363: ARRAY
69364: OR
69365: IFFALSE 69369
// continue ;
69367: GO 69331
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69369: LD_VAR 0 3
69373: PPUSH
69374: LD_EXP 44
69378: PUSH
69379: LD_VAR 0 2
69383: ARRAY
69384: PUSH
69385: LD_INT 1
69387: ARRAY
69388: PUSH
69389: LD_INT 1
69391: ARRAY
69392: PPUSH
69393: LD_EXP 44
69397: PUSH
69398: LD_VAR 0 2
69402: ARRAY
69403: PUSH
69404: LD_INT 1
69406: ARRAY
69407: PUSH
69408: LD_INT 2
69410: ARRAY
69411: PPUSH
69412: LD_EXP 44
69416: PUSH
69417: LD_VAR 0 2
69421: ARRAY
69422: PUSH
69423: LD_INT 1
69425: ARRAY
69426: PUSH
69427: LD_INT 3
69429: ARRAY
69430: PPUSH
69431: LD_EXP 44
69435: PUSH
69436: LD_VAR 0 2
69440: ARRAY
69441: PUSH
69442: LD_INT 1
69444: ARRAY
69445: PUSH
69446: LD_INT 4
69448: ARRAY
69449: PPUSH
69450: CALL_OW 448
69454: PUSH
69455: LD_VAR 0 3
69459: PPUSH
69460: LD_EXP 44
69464: PUSH
69465: LD_VAR 0 2
69469: ARRAY
69470: PUSH
69471: LD_INT 1
69473: ARRAY
69474: PUSH
69475: LD_INT 1
69477: ARRAY
69478: PUSH
69479: LD_EXP 44
69483: PUSH
69484: LD_VAR 0 2
69488: ARRAY
69489: PUSH
69490: LD_INT 1
69492: ARRAY
69493: PUSH
69494: LD_INT 2
69496: ARRAY
69497: PUSH
69498: LD_EXP 44
69502: PUSH
69503: LD_VAR 0 2
69507: ARRAY
69508: PUSH
69509: LD_INT 1
69511: ARRAY
69512: PUSH
69513: LD_INT 3
69515: ARRAY
69516: PUSH
69517: LD_EXP 44
69521: PUSH
69522: LD_VAR 0 2
69526: ARRAY
69527: PUSH
69528: LD_INT 1
69530: ARRAY
69531: PUSH
69532: LD_INT 4
69534: ARRAY
69535: PUSH
69536: EMPTY
69537: LIST
69538: LIST
69539: LIST
69540: LIST
69541: PPUSH
69542: CALL 22818 0 2
69546: AND
69547: IFFALSE 69685
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69549: LD_VAR 0 3
69553: PPUSH
69554: LD_EXP 44
69558: PUSH
69559: LD_VAR 0 2
69563: ARRAY
69564: PUSH
69565: LD_INT 1
69567: ARRAY
69568: PUSH
69569: LD_INT 1
69571: ARRAY
69572: PPUSH
69573: LD_EXP 44
69577: PUSH
69578: LD_VAR 0 2
69582: ARRAY
69583: PUSH
69584: LD_INT 1
69586: ARRAY
69587: PUSH
69588: LD_INT 2
69590: ARRAY
69591: PPUSH
69592: LD_EXP 44
69596: PUSH
69597: LD_VAR 0 2
69601: ARRAY
69602: PUSH
69603: LD_INT 1
69605: ARRAY
69606: PUSH
69607: LD_INT 3
69609: ARRAY
69610: PPUSH
69611: LD_EXP 44
69615: PUSH
69616: LD_VAR 0 2
69620: ARRAY
69621: PUSH
69622: LD_INT 1
69624: ARRAY
69625: PUSH
69626: LD_INT 4
69628: ARRAY
69629: PPUSH
69630: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69634: LD_ADDR_VAR 0 4
69638: PUSH
69639: LD_EXP 44
69643: PUSH
69644: LD_VAR 0 2
69648: ARRAY
69649: PPUSH
69650: LD_INT 1
69652: PPUSH
69653: CALL_OW 3
69657: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69658: LD_ADDR_EXP 44
69662: PUSH
69663: LD_EXP 44
69667: PPUSH
69668: LD_VAR 0 2
69672: PPUSH
69673: LD_VAR 0 4
69677: PPUSH
69678: CALL_OW 1
69682: ST_TO_ADDR
// break ;
69683: GO 69687
// end ; end ;
69685: GO 69331
69687: POP
69688: POP
// end ;
69689: GO 69263
69691: POP
69692: POP
// end ;
69693: LD_VAR 0 1
69697: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69698: LD_INT 0
69700: PPUSH
69701: PPUSH
69702: PPUSH
// if not mc_bases then
69703: LD_EXP 23
69707: NOT
69708: IFFALSE 69712
// exit ;
69710: GO 69801
// for i = 1 to mc_bases do
69712: LD_ADDR_VAR 0 2
69716: PUSH
69717: DOUBLE
69718: LD_INT 1
69720: DEC
69721: ST_TO_ADDR
69722: LD_EXP 23
69726: PUSH
69727: FOR_TO
69728: IFFALSE 69799
// begin if mc_attack [ i ] then
69730: LD_EXP 43
69734: PUSH
69735: LD_VAR 0 2
69739: ARRAY
69740: IFFALSE 69797
// begin tmp := mc_attack [ i ] [ 1 ] ;
69742: LD_ADDR_VAR 0 3
69746: PUSH
69747: LD_EXP 43
69751: PUSH
69752: LD_VAR 0 2
69756: ARRAY
69757: PUSH
69758: LD_INT 1
69760: ARRAY
69761: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69762: LD_ADDR_EXP 43
69766: PUSH
69767: LD_EXP 43
69771: PPUSH
69772: LD_VAR 0 2
69776: PPUSH
69777: EMPTY
69778: PPUSH
69779: CALL_OW 1
69783: ST_TO_ADDR
// Attack ( tmp ) ;
69784: LD_VAR 0 3
69788: PPUSH
69789: CALL 84594 0 1
// exit ;
69793: POP
69794: POP
69795: GO 69801
// end ; end ;
69797: GO 69727
69799: POP
69800: POP
// end ;
69801: LD_VAR 0 1
69805: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69806: LD_INT 0
69808: PPUSH
69809: PPUSH
69810: PPUSH
69811: PPUSH
69812: PPUSH
69813: PPUSH
69814: PPUSH
// if not mc_bases then
69815: LD_EXP 23
69819: NOT
69820: IFFALSE 69824
// exit ;
69822: GO 70681
// for i = 1 to mc_bases do
69824: LD_ADDR_VAR 0 2
69828: PUSH
69829: DOUBLE
69830: LD_INT 1
69832: DEC
69833: ST_TO_ADDR
69834: LD_EXP 23
69838: PUSH
69839: FOR_TO
69840: IFFALSE 70679
// begin if not mc_bases [ i ] then
69842: LD_EXP 23
69846: PUSH
69847: LD_VAR 0 2
69851: ARRAY
69852: NOT
69853: IFFALSE 69857
// continue ;
69855: GO 69839
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69857: LD_ADDR_VAR 0 7
69861: PUSH
69862: LD_EXP 23
69866: PUSH
69867: LD_VAR 0 2
69871: ARRAY
69872: PUSH
69873: LD_INT 1
69875: ARRAY
69876: PPUSH
69877: CALL 12901 0 1
69881: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69882: LD_ADDR_EXP 46
69886: PUSH
69887: LD_EXP 46
69891: PPUSH
69892: LD_VAR 0 2
69896: PPUSH
69897: LD_EXP 23
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: PUSH
69908: LD_INT 1
69910: ARRAY
69911: PPUSH
69912: CALL_OW 255
69916: PPUSH
69917: LD_EXP 48
69921: PUSH
69922: LD_VAR 0 2
69926: ARRAY
69927: PPUSH
69928: CALL 12866 0 2
69932: PPUSH
69933: CALL_OW 1
69937: ST_TO_ADDR
// if not mc_scan [ i ] then
69938: LD_EXP 46
69942: PUSH
69943: LD_VAR 0 2
69947: ARRAY
69948: NOT
69949: IFFALSE 70127
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
69951: LD_ADDR_EXP 66
69955: PUSH
69956: LD_EXP 66
69960: PPUSH
69961: LD_VAR 0 2
69965: PPUSH
69966: LD_INT 0
69968: PPUSH
69969: CALL_OW 1
69973: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69974: LD_ADDR_VAR 0 4
69978: PUSH
69979: LD_EXP 23
69983: PUSH
69984: LD_VAR 0 2
69988: ARRAY
69989: PPUSH
69990: LD_INT 2
69992: PUSH
69993: LD_INT 25
69995: PUSH
69996: LD_INT 5
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 25
70005: PUSH
70006: LD_INT 8
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: LD_INT 25
70015: PUSH
70016: LD_INT 9
70018: PUSH
70019: EMPTY
70020: LIST
70021: LIST
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: PPUSH
70029: CALL_OW 72
70033: ST_TO_ADDR
// if not tmp then
70034: LD_VAR 0 4
70038: NOT
70039: IFFALSE 70043
// continue ;
70041: GO 69839
// for j in tmp do
70043: LD_ADDR_VAR 0 3
70047: PUSH
70048: LD_VAR 0 4
70052: PUSH
70053: FOR_IN
70054: IFFALSE 70125
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70056: LD_VAR 0 3
70060: PPUSH
70061: CALL_OW 310
70065: PPUSH
70066: CALL_OW 266
70070: PUSH
70071: LD_INT 5
70073: EQUAL
70074: PUSH
70075: LD_VAR 0 3
70079: PPUSH
70080: CALL_OW 257
70084: PUSH
70085: LD_INT 1
70087: EQUAL
70088: AND
70089: PUSH
70090: LD_VAR 0 3
70094: PPUSH
70095: CALL_OW 459
70099: NOT
70100: AND
70101: PUSH
70102: LD_VAR 0 7
70106: AND
70107: IFFALSE 70123
// ComChangeProfession ( j , class ) ;
70109: LD_VAR 0 3
70113: PPUSH
70114: LD_VAR 0 7
70118: PPUSH
70119: CALL_OW 123
70123: GO 70053
70125: POP
70126: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
70127: LD_EXP 46
70131: PUSH
70132: LD_VAR 0 2
70136: ARRAY
70137: PUSH
70138: LD_EXP 66
70142: PUSH
70143: LD_VAR 0 2
70147: ARRAY
70148: NOT
70149: AND
70150: PUSH
70151: LD_EXP 45
70155: PUSH
70156: LD_VAR 0 2
70160: ARRAY
70161: NOT
70162: AND
70163: PUSH
70164: LD_EXP 23
70168: PUSH
70169: LD_VAR 0 2
70173: ARRAY
70174: PPUSH
70175: LD_INT 50
70177: PUSH
70178: EMPTY
70179: LIST
70180: PUSH
70181: LD_INT 2
70183: PUSH
70184: LD_INT 30
70186: PUSH
70187: LD_INT 32
70189: PUSH
70190: EMPTY
70191: LIST
70192: LIST
70193: PUSH
70194: LD_INT 30
70196: PUSH
70197: LD_INT 33
70199: PUSH
70200: EMPTY
70201: LIST
70202: LIST
70203: PUSH
70204: LD_INT 30
70206: PUSH
70207: LD_INT 4
70209: PUSH
70210: EMPTY
70211: LIST
70212: LIST
70213: PUSH
70214: LD_INT 30
70216: PUSH
70217: LD_INT 5
70219: PUSH
70220: EMPTY
70221: LIST
70222: LIST
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: LIST
70228: LIST
70229: LIST
70230: PUSH
70231: EMPTY
70232: LIST
70233: LIST
70234: PPUSH
70235: CALL_OW 72
70239: PUSH
70240: LD_INT 4
70242: LESS
70243: PUSH
70244: LD_EXP 23
70248: PUSH
70249: LD_VAR 0 2
70253: ARRAY
70254: PPUSH
70255: LD_INT 3
70257: PUSH
70258: LD_INT 24
70260: PUSH
70261: LD_INT 1000
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 2
70274: PUSH
70275: LD_INT 30
70277: PUSH
70278: LD_INT 0
70280: PUSH
70281: EMPTY
70282: LIST
70283: LIST
70284: PUSH
70285: LD_INT 30
70287: PUSH
70288: LD_INT 1
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: LIST
70299: PUSH
70300: EMPTY
70301: LIST
70302: LIST
70303: PPUSH
70304: CALL_OW 72
70308: OR
70309: AND
70310: IFFALSE 70561
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70312: LD_ADDR_EXP 66
70316: PUSH
70317: LD_EXP 66
70321: PPUSH
70322: LD_VAR 0 2
70326: PPUSH
70327: LD_INT 1
70329: PPUSH
70330: CALL_OW 1
70334: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70335: LD_ADDR_VAR 0 4
70339: PUSH
70340: LD_EXP 23
70344: PUSH
70345: LD_VAR 0 2
70349: ARRAY
70350: PPUSH
70351: LD_INT 2
70353: PUSH
70354: LD_INT 25
70356: PUSH
70357: LD_INT 1
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 25
70366: PUSH
70367: LD_INT 5
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 25
70376: PUSH
70377: LD_INT 8
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 25
70386: PUSH
70387: LD_INT 9
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: EMPTY
70395: LIST
70396: LIST
70397: LIST
70398: LIST
70399: LIST
70400: PPUSH
70401: CALL_OW 72
70405: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70406: LD_ADDR_VAR 0 4
70410: PUSH
70411: LD_VAR 0 4
70415: PUSH
70416: LD_VAR 0 4
70420: PPUSH
70421: LD_INT 18
70423: PPUSH
70424: CALL 46375 0 2
70428: DIFF
70429: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70430: LD_VAR 0 4
70434: NOT
70435: PUSH
70436: LD_EXP 23
70440: PUSH
70441: LD_VAR 0 2
70445: ARRAY
70446: PPUSH
70447: LD_INT 2
70449: PUSH
70450: LD_INT 30
70452: PUSH
70453: LD_INT 4
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: LD_INT 30
70462: PUSH
70463: LD_INT 5
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: LIST
70474: PPUSH
70475: CALL_OW 72
70479: NOT
70480: AND
70481: IFFALSE 70543
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
70483: LD_ADDR_VAR 0 4
70487: PUSH
70488: LD_EXP 23
70492: PUSH
70493: LD_VAR 0 2
70497: ARRAY
70498: PPUSH
70499: LD_INT 2
70501: PUSH
70502: LD_INT 25
70504: PUSH
70505: LD_INT 2
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: PUSH
70512: LD_INT 25
70514: PUSH
70515: LD_INT 3
70517: PUSH
70518: EMPTY
70519: LIST
70520: LIST
70521: PUSH
70522: LD_INT 25
70524: PUSH
70525: LD_INT 4
70527: PUSH
70528: EMPTY
70529: LIST
70530: LIST
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: LIST
70536: LIST
70537: PPUSH
70538: CALL_OW 72
70542: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
70543: LD_VAR 0 2
70547: PPUSH
70548: LD_VAR 0 4
70552: PPUSH
70553: CALL 89303 0 2
// exit ;
70557: POP
70558: POP
70559: GO 70681
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
70561: LD_EXP 46
70565: PUSH
70566: LD_VAR 0 2
70570: ARRAY
70571: PUSH
70572: LD_EXP 66
70576: PUSH
70577: LD_VAR 0 2
70581: ARRAY
70582: NOT
70583: AND
70584: PUSH
70585: LD_EXP 45
70589: PUSH
70590: LD_VAR 0 2
70594: ARRAY
70595: AND
70596: IFFALSE 70677
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70598: LD_ADDR_EXP 66
70602: PUSH
70603: LD_EXP 66
70607: PPUSH
70608: LD_VAR 0 2
70612: PPUSH
70613: LD_INT 1
70615: PPUSH
70616: CALL_OW 1
70620: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
70621: LD_ADDR_VAR 0 4
70625: PUSH
70626: LD_EXP 45
70630: PUSH
70631: LD_VAR 0 2
70635: ARRAY
70636: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70637: LD_ADDR_EXP 45
70641: PUSH
70642: LD_EXP 45
70646: PPUSH
70647: LD_VAR 0 2
70651: PPUSH
70652: EMPTY
70653: PPUSH
70654: CALL_OW 1
70658: ST_TO_ADDR
// Defend ( i , tmp ) ;
70659: LD_VAR 0 2
70663: PPUSH
70664: LD_VAR 0 4
70668: PPUSH
70669: CALL 89899 0 2
// exit ;
70673: POP
70674: POP
70675: GO 70681
// end ; end ;
70677: GO 69839
70679: POP
70680: POP
// end ;
70681: LD_VAR 0 1
70685: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70686: LD_INT 0
70688: PPUSH
70689: PPUSH
70690: PPUSH
70691: PPUSH
70692: PPUSH
70693: PPUSH
70694: PPUSH
70695: PPUSH
70696: PPUSH
70697: PPUSH
70698: PPUSH
// if not mc_bases then
70699: LD_EXP 23
70703: NOT
70704: IFFALSE 70708
// exit ;
70706: GO 71795
// for i = 1 to mc_bases do
70708: LD_ADDR_VAR 0 2
70712: PUSH
70713: DOUBLE
70714: LD_INT 1
70716: DEC
70717: ST_TO_ADDR
70718: LD_EXP 23
70722: PUSH
70723: FOR_TO
70724: IFFALSE 71793
// begin tmp := mc_lab [ i ] ;
70726: LD_ADDR_VAR 0 6
70730: PUSH
70731: LD_EXP 56
70735: PUSH
70736: LD_VAR 0 2
70740: ARRAY
70741: ST_TO_ADDR
// if not tmp then
70742: LD_VAR 0 6
70746: NOT
70747: IFFALSE 70751
// continue ;
70749: GO 70723
// idle_lab := 0 ;
70751: LD_ADDR_VAR 0 11
70755: PUSH
70756: LD_INT 0
70758: ST_TO_ADDR
// for j in tmp do
70759: LD_ADDR_VAR 0 3
70763: PUSH
70764: LD_VAR 0 6
70768: PUSH
70769: FOR_IN
70770: IFFALSE 71789
// begin researching := false ;
70772: LD_ADDR_VAR 0 10
70776: PUSH
70777: LD_INT 0
70779: ST_TO_ADDR
// side := GetSide ( j ) ;
70780: LD_ADDR_VAR 0 4
70784: PUSH
70785: LD_VAR 0 3
70789: PPUSH
70790: CALL_OW 255
70794: ST_TO_ADDR
// if not mc_tech [ side ] then
70795: LD_EXP 50
70799: PUSH
70800: LD_VAR 0 4
70804: ARRAY
70805: NOT
70806: IFFALSE 70810
// continue ;
70808: GO 70769
// if BuildingStatus ( j ) = bs_idle then
70810: LD_VAR 0 3
70814: PPUSH
70815: CALL_OW 461
70819: PUSH
70820: LD_INT 2
70822: EQUAL
70823: IFFALSE 71011
// begin if idle_lab and UnitsInside ( j ) < 6 then
70825: LD_VAR 0 11
70829: PUSH
70830: LD_VAR 0 3
70834: PPUSH
70835: CALL_OW 313
70839: PUSH
70840: LD_INT 6
70842: LESS
70843: AND
70844: IFFALSE 70915
// begin tmp2 := UnitsInside ( idle_lab ) ;
70846: LD_ADDR_VAR 0 9
70850: PUSH
70851: LD_VAR 0 11
70855: PPUSH
70856: CALL_OW 313
70860: ST_TO_ADDR
// if tmp2 then
70861: LD_VAR 0 9
70865: IFFALSE 70907
// for x in tmp2 do
70867: LD_ADDR_VAR 0 7
70871: PUSH
70872: LD_VAR 0 9
70876: PUSH
70877: FOR_IN
70878: IFFALSE 70905
// begin ComExitBuilding ( x ) ;
70880: LD_VAR 0 7
70884: PPUSH
70885: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70889: LD_VAR 0 7
70893: PPUSH
70894: LD_VAR 0 3
70898: PPUSH
70899: CALL_OW 180
// end ;
70903: GO 70877
70905: POP
70906: POP
// idle_lab := 0 ;
70907: LD_ADDR_VAR 0 11
70911: PUSH
70912: LD_INT 0
70914: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70915: LD_ADDR_VAR 0 5
70919: PUSH
70920: LD_EXP 50
70924: PUSH
70925: LD_VAR 0 4
70929: ARRAY
70930: PUSH
70931: FOR_IN
70932: IFFALSE 70992
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70934: LD_VAR 0 3
70938: PPUSH
70939: LD_VAR 0 5
70943: PPUSH
70944: CALL_OW 430
70948: PUSH
70949: LD_VAR 0 4
70953: PPUSH
70954: LD_VAR 0 5
70958: PPUSH
70959: CALL 11971 0 2
70963: AND
70964: IFFALSE 70990
// begin researching := true ;
70966: LD_ADDR_VAR 0 10
70970: PUSH
70971: LD_INT 1
70973: ST_TO_ADDR
// ComResearch ( j , t ) ;
70974: LD_VAR 0 3
70978: PPUSH
70979: LD_VAR 0 5
70983: PPUSH
70984: CALL_OW 124
// break ;
70988: GO 70992
// end ;
70990: GO 70931
70992: POP
70993: POP
// if not researching then
70994: LD_VAR 0 10
70998: NOT
70999: IFFALSE 71011
// idle_lab := j ;
71001: LD_ADDR_VAR 0 11
71005: PUSH
71006: LD_VAR 0 3
71010: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71011: LD_VAR 0 3
71015: PPUSH
71016: CALL_OW 461
71020: PUSH
71021: LD_INT 10
71023: EQUAL
71024: IFFALSE 71612
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71026: LD_EXP 52
71030: PUSH
71031: LD_VAR 0 2
71035: ARRAY
71036: NOT
71037: PUSH
71038: LD_EXP 53
71042: PUSH
71043: LD_VAR 0 2
71047: ARRAY
71048: NOT
71049: AND
71050: PUSH
71051: LD_EXP 50
71055: PUSH
71056: LD_VAR 0 4
71060: ARRAY
71061: PUSH
71062: LD_INT 1
71064: GREATER
71065: AND
71066: IFFALSE 71197
// begin ComCancel ( j ) ;
71068: LD_VAR 0 3
71072: PPUSH
71073: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71077: LD_ADDR_EXP 50
71081: PUSH
71082: LD_EXP 50
71086: PPUSH
71087: LD_VAR 0 4
71091: PPUSH
71092: LD_EXP 50
71096: PUSH
71097: LD_VAR 0 4
71101: ARRAY
71102: PPUSH
71103: LD_EXP 50
71107: PUSH
71108: LD_VAR 0 4
71112: ARRAY
71113: PUSH
71114: LD_INT 1
71116: MINUS
71117: PPUSH
71118: LD_EXP 50
71122: PUSH
71123: LD_VAR 0 4
71127: ARRAY
71128: PPUSH
71129: LD_INT 0
71131: PPUSH
71132: CALL 15495 0 4
71136: PPUSH
71137: CALL_OW 1
71141: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71142: LD_ADDR_EXP 50
71146: PUSH
71147: LD_EXP 50
71151: PPUSH
71152: LD_VAR 0 4
71156: PPUSH
71157: LD_EXP 50
71161: PUSH
71162: LD_VAR 0 4
71166: ARRAY
71167: PPUSH
71168: LD_EXP 50
71172: PUSH
71173: LD_VAR 0 4
71177: ARRAY
71178: PPUSH
71179: LD_INT 1
71181: PPUSH
71182: LD_INT 0
71184: PPUSH
71185: CALL 15495 0 4
71189: PPUSH
71190: CALL_OW 1
71194: ST_TO_ADDR
// continue ;
71195: GO 70769
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71197: LD_EXP 52
71201: PUSH
71202: LD_VAR 0 2
71206: ARRAY
71207: PUSH
71208: LD_EXP 53
71212: PUSH
71213: LD_VAR 0 2
71217: ARRAY
71218: NOT
71219: AND
71220: IFFALSE 71347
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71222: LD_ADDR_EXP 53
71226: PUSH
71227: LD_EXP 53
71231: PPUSH
71232: LD_VAR 0 2
71236: PUSH
71237: LD_EXP 53
71241: PUSH
71242: LD_VAR 0 2
71246: ARRAY
71247: PUSH
71248: LD_INT 1
71250: PLUS
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PPUSH
71256: LD_EXP 52
71260: PUSH
71261: LD_VAR 0 2
71265: ARRAY
71266: PUSH
71267: LD_INT 1
71269: ARRAY
71270: PPUSH
71271: CALL 16077 0 3
71275: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71276: LD_EXP 52
71280: PUSH
71281: LD_VAR 0 2
71285: ARRAY
71286: PUSH
71287: LD_INT 1
71289: ARRAY
71290: PPUSH
71291: LD_INT 112
71293: PPUSH
71294: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71298: LD_ADDR_VAR 0 9
71302: PUSH
71303: LD_EXP 52
71307: PUSH
71308: LD_VAR 0 2
71312: ARRAY
71313: PPUSH
71314: LD_INT 1
71316: PPUSH
71317: CALL_OW 3
71321: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71322: LD_ADDR_EXP 52
71326: PUSH
71327: LD_EXP 52
71331: PPUSH
71332: LD_VAR 0 2
71336: PPUSH
71337: LD_VAR 0 9
71341: PPUSH
71342: CALL_OW 1
71346: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71347: LD_EXP 52
71351: PUSH
71352: LD_VAR 0 2
71356: ARRAY
71357: PUSH
71358: LD_EXP 53
71362: PUSH
71363: LD_VAR 0 2
71367: ARRAY
71368: AND
71369: PUSH
71370: LD_EXP 53
71374: PUSH
71375: LD_VAR 0 2
71379: ARRAY
71380: PUSH
71381: LD_INT 1
71383: ARRAY
71384: PPUSH
71385: CALL_OW 310
71389: NOT
71390: AND
71391: PUSH
71392: LD_VAR 0 3
71396: PPUSH
71397: CALL_OW 313
71401: PUSH
71402: LD_INT 6
71404: EQUAL
71405: AND
71406: IFFALSE 71462
// begin tmp2 := UnitsInside ( j ) ;
71408: LD_ADDR_VAR 0 9
71412: PUSH
71413: LD_VAR 0 3
71417: PPUSH
71418: CALL_OW 313
71422: ST_TO_ADDR
// if tmp2 = 6 then
71423: LD_VAR 0 9
71427: PUSH
71428: LD_INT 6
71430: EQUAL
71431: IFFALSE 71462
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71433: LD_VAR 0 9
71437: PUSH
71438: LD_INT 1
71440: ARRAY
71441: PPUSH
71442: LD_INT 112
71444: PPUSH
71445: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71449: LD_VAR 0 9
71453: PUSH
71454: LD_INT 1
71456: ARRAY
71457: PPUSH
71458: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71462: LD_EXP 53
71466: PUSH
71467: LD_VAR 0 2
71471: ARRAY
71472: PUSH
71473: LD_EXP 53
71477: PUSH
71478: LD_VAR 0 2
71482: ARRAY
71483: PUSH
71484: LD_INT 1
71486: ARRAY
71487: PPUSH
71488: CALL_OW 314
71492: NOT
71493: AND
71494: PUSH
71495: LD_EXP 53
71499: PUSH
71500: LD_VAR 0 2
71504: ARRAY
71505: PUSH
71506: LD_INT 1
71508: ARRAY
71509: PPUSH
71510: CALL_OW 310
71514: NOT
71515: AND
71516: IFFALSE 71542
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71518: LD_EXP 53
71522: PUSH
71523: LD_VAR 0 2
71527: ARRAY
71528: PUSH
71529: LD_INT 1
71531: ARRAY
71532: PPUSH
71533: LD_VAR 0 3
71537: PPUSH
71538: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71542: LD_EXP 53
71546: PUSH
71547: LD_VAR 0 2
71551: ARRAY
71552: PUSH
71553: LD_INT 1
71555: ARRAY
71556: PPUSH
71557: CALL_OW 310
71561: PUSH
71562: LD_EXP 53
71566: PUSH
71567: LD_VAR 0 2
71571: ARRAY
71572: PUSH
71573: LD_INT 1
71575: ARRAY
71576: PPUSH
71577: CALL_OW 310
71581: PPUSH
71582: CALL_OW 461
71586: PUSH
71587: LD_INT 3
71589: NONEQUAL
71590: AND
71591: IFFALSE 71612
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71593: LD_EXP 53
71597: PUSH
71598: LD_VAR 0 2
71602: ARRAY
71603: PUSH
71604: LD_INT 1
71606: ARRAY
71607: PPUSH
71608: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71612: LD_VAR 0 3
71616: PPUSH
71617: CALL_OW 461
71621: PUSH
71622: LD_INT 6
71624: EQUAL
71625: PUSH
71626: LD_VAR 0 6
71630: PUSH
71631: LD_INT 1
71633: GREATER
71634: AND
71635: IFFALSE 71787
// begin sci := [ ] ;
71637: LD_ADDR_VAR 0 8
71641: PUSH
71642: EMPTY
71643: ST_TO_ADDR
// for x in ( tmp diff j ) do
71644: LD_ADDR_VAR 0 7
71648: PUSH
71649: LD_VAR 0 6
71653: PUSH
71654: LD_VAR 0 3
71658: DIFF
71659: PUSH
71660: FOR_IN
71661: IFFALSE 71713
// begin if sci = 6 then
71663: LD_VAR 0 8
71667: PUSH
71668: LD_INT 6
71670: EQUAL
71671: IFFALSE 71675
// break ;
71673: GO 71713
// if BuildingStatus ( x ) = bs_idle then
71675: LD_VAR 0 7
71679: PPUSH
71680: CALL_OW 461
71684: PUSH
71685: LD_INT 2
71687: EQUAL
71688: IFFALSE 71711
// sci := sci ^ UnitsInside ( x ) ;
71690: LD_ADDR_VAR 0 8
71694: PUSH
71695: LD_VAR 0 8
71699: PUSH
71700: LD_VAR 0 7
71704: PPUSH
71705: CALL_OW 313
71709: ADD
71710: ST_TO_ADDR
// end ;
71711: GO 71660
71713: POP
71714: POP
// if not sci then
71715: LD_VAR 0 8
71719: NOT
71720: IFFALSE 71724
// continue ;
71722: GO 70769
// for x in sci do
71724: LD_ADDR_VAR 0 7
71728: PUSH
71729: LD_VAR 0 8
71733: PUSH
71734: FOR_IN
71735: IFFALSE 71785
// if IsInUnit ( x ) and not HasTask ( x ) then
71737: LD_VAR 0 7
71741: PPUSH
71742: CALL_OW 310
71746: PUSH
71747: LD_VAR 0 7
71751: PPUSH
71752: CALL_OW 314
71756: NOT
71757: AND
71758: IFFALSE 71783
// begin ComExitBuilding ( x ) ;
71760: LD_VAR 0 7
71764: PPUSH
71765: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71769: LD_VAR 0 7
71773: PPUSH
71774: LD_VAR 0 3
71778: PPUSH
71779: CALL_OW 180
// end ;
71783: GO 71734
71785: POP
71786: POP
// end ; end ;
71787: GO 70769
71789: POP
71790: POP
// end ;
71791: GO 70723
71793: POP
71794: POP
// end ;
71795: LD_VAR 0 1
71799: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71800: LD_INT 0
71802: PPUSH
71803: PPUSH
// if not mc_bases then
71804: LD_EXP 23
71808: NOT
71809: IFFALSE 71813
// exit ;
71811: GO 71894
// for i = 1 to mc_bases do
71813: LD_ADDR_VAR 0 2
71817: PUSH
71818: DOUBLE
71819: LD_INT 1
71821: DEC
71822: ST_TO_ADDR
71823: LD_EXP 23
71827: PUSH
71828: FOR_TO
71829: IFFALSE 71892
// if mc_mines [ i ] and mc_miners [ i ] then
71831: LD_EXP 36
71835: PUSH
71836: LD_VAR 0 2
71840: ARRAY
71841: PUSH
71842: LD_EXP 37
71846: PUSH
71847: LD_VAR 0 2
71851: ARRAY
71852: AND
71853: IFFALSE 71890
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71855: LD_EXP 37
71859: PUSH
71860: LD_VAR 0 2
71864: ARRAY
71865: PUSH
71866: LD_INT 1
71868: ARRAY
71869: PPUSH
71870: CALL_OW 255
71874: PPUSH
71875: LD_EXP 36
71879: PUSH
71880: LD_VAR 0 2
71884: ARRAY
71885: PPUSH
71886: CALL 13054 0 2
71890: GO 71828
71892: POP
71893: POP
// end ;
71894: LD_VAR 0 1
71898: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71899: LD_INT 0
71901: PPUSH
71902: PPUSH
71903: PPUSH
71904: PPUSH
71905: PPUSH
71906: PPUSH
71907: PPUSH
71908: PPUSH
// if not mc_bases or not mc_parking then
71909: LD_EXP 23
71913: NOT
71914: PUSH
71915: LD_EXP 47
71919: NOT
71920: OR
71921: IFFALSE 71925
// exit ;
71923: GO 72663
// for i = 1 to mc_bases do
71925: LD_ADDR_VAR 0 2
71929: PUSH
71930: DOUBLE
71931: LD_INT 1
71933: DEC
71934: ST_TO_ADDR
71935: LD_EXP 23
71939: PUSH
71940: FOR_TO
71941: IFFALSE 72661
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71943: LD_EXP 23
71947: PUSH
71948: LD_VAR 0 2
71952: ARRAY
71953: NOT
71954: PUSH
71955: LD_EXP 47
71959: PUSH
71960: LD_VAR 0 2
71964: ARRAY
71965: NOT
71966: OR
71967: IFFALSE 71971
// continue ;
71969: GO 71940
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71971: LD_ADDR_VAR 0 5
71975: PUSH
71976: LD_EXP 23
71980: PUSH
71981: LD_VAR 0 2
71985: ARRAY
71986: PUSH
71987: LD_INT 1
71989: ARRAY
71990: PPUSH
71991: CALL_OW 255
71995: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71996: LD_ADDR_VAR 0 6
72000: PUSH
72001: LD_EXP 23
72005: PUSH
72006: LD_VAR 0 2
72010: ARRAY
72011: PPUSH
72012: LD_INT 30
72014: PUSH
72015: LD_INT 3
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: PPUSH
72022: CALL_OW 72
72026: ST_TO_ADDR
// if not fac then
72027: LD_VAR 0 6
72031: NOT
72032: IFFALSE 72083
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72034: LD_ADDR_VAR 0 6
72038: PUSH
72039: LD_EXP 23
72043: PUSH
72044: LD_VAR 0 2
72048: ARRAY
72049: PPUSH
72050: LD_INT 2
72052: PUSH
72053: LD_INT 30
72055: PUSH
72056: LD_INT 0
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PUSH
72063: LD_INT 30
72065: PUSH
72066: LD_INT 1
72068: PUSH
72069: EMPTY
72070: LIST
72071: LIST
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: LIST
72077: PPUSH
72078: CALL_OW 72
72082: ST_TO_ADDR
// if not fac then
72083: LD_VAR 0 6
72087: NOT
72088: IFFALSE 72092
// continue ;
72090: GO 71940
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72092: LD_ADDR_VAR 0 7
72096: PUSH
72097: LD_EXP 47
72101: PUSH
72102: LD_VAR 0 2
72106: ARRAY
72107: PPUSH
72108: LD_INT 22
72110: PUSH
72111: LD_VAR 0 5
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 21
72122: PUSH
72123: LD_INT 2
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: LD_INT 3
72132: PUSH
72133: LD_INT 60
72135: PUSH
72136: EMPTY
72137: LIST
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 3
72145: PUSH
72146: LD_INT 24
72148: PUSH
72149: LD_INT 1000
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: LIST
72164: LIST
72165: PPUSH
72166: CALL_OW 70
72170: ST_TO_ADDR
// for j in fac do
72171: LD_ADDR_VAR 0 3
72175: PUSH
72176: LD_VAR 0 6
72180: PUSH
72181: FOR_IN
72182: IFFALSE 72277
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72184: LD_ADDR_VAR 0 7
72188: PUSH
72189: LD_VAR 0 7
72193: PUSH
72194: LD_INT 22
72196: PUSH
72197: LD_VAR 0 5
72201: PUSH
72202: EMPTY
72203: LIST
72204: LIST
72205: PUSH
72206: LD_INT 91
72208: PUSH
72209: LD_VAR 0 3
72213: PUSH
72214: LD_INT 15
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: LIST
72221: PUSH
72222: LD_INT 21
72224: PUSH
72225: LD_INT 2
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 3
72234: PUSH
72235: LD_INT 60
72237: PUSH
72238: EMPTY
72239: LIST
72240: PUSH
72241: EMPTY
72242: LIST
72243: LIST
72244: PUSH
72245: LD_INT 3
72247: PUSH
72248: LD_INT 24
72250: PUSH
72251: LD_INT 1000
72253: PUSH
72254: EMPTY
72255: LIST
72256: LIST
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: EMPTY
72263: LIST
72264: LIST
72265: LIST
72266: LIST
72267: LIST
72268: PPUSH
72269: CALL_OW 69
72273: UNION
72274: ST_TO_ADDR
72275: GO 72181
72277: POP
72278: POP
// if not vehs then
72279: LD_VAR 0 7
72283: NOT
72284: IFFALSE 72310
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72286: LD_ADDR_EXP 35
72290: PUSH
72291: LD_EXP 35
72295: PPUSH
72296: LD_VAR 0 2
72300: PPUSH
72301: EMPTY
72302: PPUSH
72303: CALL_OW 1
72307: ST_TO_ADDR
// continue ;
72308: GO 71940
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72310: LD_ADDR_VAR 0 8
72314: PUSH
72315: LD_EXP 23
72319: PUSH
72320: LD_VAR 0 2
72324: ARRAY
72325: PPUSH
72326: LD_INT 30
72328: PUSH
72329: LD_INT 3
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PPUSH
72336: CALL_OW 72
72340: ST_TO_ADDR
// if tmp then
72341: LD_VAR 0 8
72345: IFFALSE 72448
// begin for j in tmp do
72347: LD_ADDR_VAR 0 3
72351: PUSH
72352: LD_VAR 0 8
72356: PUSH
72357: FOR_IN
72358: IFFALSE 72446
// for k in UnitsInside ( j ) do
72360: LD_ADDR_VAR 0 4
72364: PUSH
72365: LD_VAR 0 3
72369: PPUSH
72370: CALL_OW 313
72374: PUSH
72375: FOR_IN
72376: IFFALSE 72442
// if k then
72378: LD_VAR 0 4
72382: IFFALSE 72440
// if not k in mc_repair_vehicle [ i ] then
72384: LD_VAR 0 4
72388: PUSH
72389: LD_EXP 35
72393: PUSH
72394: LD_VAR 0 2
72398: ARRAY
72399: IN
72400: NOT
72401: IFFALSE 72440
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72403: LD_ADDR_EXP 35
72407: PUSH
72408: LD_EXP 35
72412: PPUSH
72413: LD_VAR 0 2
72417: PPUSH
72418: LD_EXP 35
72422: PUSH
72423: LD_VAR 0 2
72427: ARRAY
72428: PUSH
72429: LD_VAR 0 4
72433: UNION
72434: PPUSH
72435: CALL_OW 1
72439: ST_TO_ADDR
72440: GO 72375
72442: POP
72443: POP
72444: GO 72357
72446: POP
72447: POP
// end ; if not mc_repair_vehicle [ i ] then
72448: LD_EXP 35
72452: PUSH
72453: LD_VAR 0 2
72457: ARRAY
72458: NOT
72459: IFFALSE 72463
// continue ;
72461: GO 71940
// for j in mc_repair_vehicle [ i ] do
72463: LD_ADDR_VAR 0 3
72467: PUSH
72468: LD_EXP 35
72472: PUSH
72473: LD_VAR 0 2
72477: ARRAY
72478: PUSH
72479: FOR_IN
72480: IFFALSE 72657
// begin if GetClass ( j ) <> 3 then
72482: LD_VAR 0 3
72486: PPUSH
72487: CALL_OW 257
72491: PUSH
72492: LD_INT 3
72494: NONEQUAL
72495: IFFALSE 72536
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72497: LD_ADDR_EXP 35
72501: PUSH
72502: LD_EXP 35
72506: PPUSH
72507: LD_VAR 0 2
72511: PPUSH
72512: LD_EXP 35
72516: PUSH
72517: LD_VAR 0 2
72521: ARRAY
72522: PUSH
72523: LD_VAR 0 3
72527: DIFF
72528: PPUSH
72529: CALL_OW 1
72533: ST_TO_ADDR
// continue ;
72534: GO 72479
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72536: LD_VAR 0 3
72540: PPUSH
72541: CALL_OW 311
72545: NOT
72546: PUSH
72547: LD_VAR 0 3
72551: PUSH
72552: LD_EXP 26
72556: PUSH
72557: LD_VAR 0 2
72561: ARRAY
72562: PUSH
72563: LD_INT 1
72565: ARRAY
72566: IN
72567: NOT
72568: AND
72569: PUSH
72570: LD_VAR 0 3
72574: PUSH
72575: LD_EXP 26
72579: PUSH
72580: LD_VAR 0 2
72584: ARRAY
72585: PUSH
72586: LD_INT 2
72588: ARRAY
72589: IN
72590: NOT
72591: AND
72592: IFFALSE 72655
// begin if IsInUnit ( j ) then
72594: LD_VAR 0 3
72598: PPUSH
72599: CALL_OW 310
72603: IFFALSE 72616
// ComExitBuilding ( j ) else
72605: LD_VAR 0 3
72609: PPUSH
72610: CALL_OW 122
72614: GO 72655
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
72616: LD_VAR 0 3
72620: PPUSH
72621: LD_VAR 0 7
72625: PUSH
72626: LD_INT 1
72628: ARRAY
72629: PPUSH
72630: CALL 50871 0 2
72634: NOT
72635: IFFALSE 72655
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
72637: LD_VAR 0 3
72641: PPUSH
72642: LD_VAR 0 7
72646: PUSH
72647: LD_INT 1
72649: ARRAY
72650: PPUSH
72651: CALL_OW 129
// end ; end ;
72655: GO 72479
72657: POP
72658: POP
// end ;
72659: GO 71940
72661: POP
72662: POP
// end ;
72663: LD_VAR 0 1
72667: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72668: LD_INT 0
72670: PPUSH
72671: PPUSH
72672: PPUSH
72673: PPUSH
72674: PPUSH
72675: PPUSH
72676: PPUSH
72677: PPUSH
72678: PPUSH
72679: PPUSH
72680: PPUSH
// if not mc_bases then
72681: LD_EXP 23
72685: NOT
72686: IFFALSE 72690
// exit ;
72688: GO 73492
// for i = 1 to mc_bases do
72690: LD_ADDR_VAR 0 2
72694: PUSH
72695: DOUBLE
72696: LD_INT 1
72698: DEC
72699: ST_TO_ADDR
72700: LD_EXP 23
72704: PUSH
72705: FOR_TO
72706: IFFALSE 73490
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72708: LD_EXP 51
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: NOT
72719: PUSH
72720: LD_EXP 26
72724: PUSH
72725: LD_VAR 0 2
72729: ARRAY
72730: PUSH
72731: LD_INT 1
72733: ARRAY
72734: OR
72735: PUSH
72736: LD_EXP 26
72740: PUSH
72741: LD_VAR 0 2
72745: ARRAY
72746: PUSH
72747: LD_INT 2
72749: ARRAY
72750: OR
72751: PUSH
72752: LD_EXP 49
72756: PUSH
72757: LD_VAR 0 2
72761: ARRAY
72762: PPUSH
72763: LD_INT 1
72765: PPUSH
72766: CALL_OW 325
72770: NOT
72771: OR
72772: PUSH
72773: LD_EXP 46
72777: PUSH
72778: LD_VAR 0 2
72782: ARRAY
72783: OR
72784: IFFALSE 72788
// continue ;
72786: GO 72705
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72788: LD_ADDR_VAR 0 8
72792: PUSH
72793: LD_EXP 23
72797: PUSH
72798: LD_VAR 0 2
72802: ARRAY
72803: PPUSH
72804: LD_INT 25
72806: PUSH
72807: LD_INT 4
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: LD_INT 50
72816: PUSH
72817: EMPTY
72818: LIST
72819: PUSH
72820: LD_INT 3
72822: PUSH
72823: LD_INT 60
72825: PUSH
72826: EMPTY
72827: LIST
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: LIST
72837: PPUSH
72838: CALL_OW 72
72842: PUSH
72843: LD_EXP 27
72847: PUSH
72848: LD_VAR 0 2
72852: ARRAY
72853: DIFF
72854: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72855: LD_ADDR_VAR 0 9
72859: PUSH
72860: LD_EXP 23
72864: PUSH
72865: LD_VAR 0 2
72869: ARRAY
72870: PPUSH
72871: LD_INT 2
72873: PUSH
72874: LD_INT 30
72876: PUSH
72877: LD_INT 0
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 30
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: LIST
72898: PPUSH
72899: CALL_OW 72
72903: ST_TO_ADDR
// if not tmp or not dep then
72904: LD_VAR 0 8
72908: NOT
72909: PUSH
72910: LD_VAR 0 9
72914: NOT
72915: OR
72916: IFFALSE 72920
// continue ;
72918: GO 72705
// side := GetSide ( tmp [ 1 ] ) ;
72920: LD_ADDR_VAR 0 11
72924: PUSH
72925: LD_VAR 0 8
72929: PUSH
72930: LD_INT 1
72932: ARRAY
72933: PPUSH
72934: CALL_OW 255
72938: ST_TO_ADDR
// dep := dep [ 1 ] ;
72939: LD_ADDR_VAR 0 9
72943: PUSH
72944: LD_VAR 0 9
72948: PUSH
72949: LD_INT 1
72951: ARRAY
72952: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72953: LD_ADDR_VAR 0 7
72957: PUSH
72958: LD_EXP 51
72962: PUSH
72963: LD_VAR 0 2
72967: ARRAY
72968: PPUSH
72969: LD_INT 22
72971: PUSH
72972: LD_INT 0
72974: PUSH
72975: EMPTY
72976: LIST
72977: LIST
72978: PUSH
72979: LD_INT 25
72981: PUSH
72982: LD_INT 12
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PPUSH
72993: CALL_OW 70
72997: PUSH
72998: LD_INT 22
73000: PUSH
73001: LD_INT 0
73003: PUSH
73004: EMPTY
73005: LIST
73006: LIST
73007: PUSH
73008: LD_INT 25
73010: PUSH
73011: LD_INT 12
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PUSH
73018: LD_INT 91
73020: PUSH
73021: LD_VAR 0 9
73025: PUSH
73026: LD_INT 20
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: LIST
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: LIST
73038: PPUSH
73039: CALL_OW 69
73043: UNION
73044: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73045: LD_ADDR_VAR 0 10
73049: PUSH
73050: LD_EXP 51
73054: PUSH
73055: LD_VAR 0 2
73059: ARRAY
73060: PPUSH
73061: LD_INT 81
73063: PUSH
73064: LD_VAR 0 11
73068: PUSH
73069: EMPTY
73070: LIST
73071: LIST
73072: PPUSH
73073: CALL_OW 70
73077: ST_TO_ADDR
// if not apes or danger_at_area then
73078: LD_VAR 0 7
73082: NOT
73083: PUSH
73084: LD_VAR 0 10
73088: OR
73089: IFFALSE 73139
// begin if mc_taming [ i ] then
73091: LD_EXP 54
73095: PUSH
73096: LD_VAR 0 2
73100: ARRAY
73101: IFFALSE 73137
// begin MC_Reset ( i , 121 ) ;
73103: LD_VAR 0 2
73107: PPUSH
73108: LD_INT 121
73110: PPUSH
73111: CALL 58055 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73115: LD_ADDR_EXP 54
73119: PUSH
73120: LD_EXP 54
73124: PPUSH
73125: LD_VAR 0 2
73129: PPUSH
73130: EMPTY
73131: PPUSH
73132: CALL_OW 1
73136: ST_TO_ADDR
// end ; continue ;
73137: GO 72705
// end ; for j in tmp do
73139: LD_ADDR_VAR 0 3
73143: PUSH
73144: LD_VAR 0 8
73148: PUSH
73149: FOR_IN
73150: IFFALSE 73486
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73152: LD_VAR 0 3
73156: PUSH
73157: LD_EXP 54
73161: PUSH
73162: LD_VAR 0 2
73166: ARRAY
73167: IN
73168: NOT
73169: PUSH
73170: LD_EXP 54
73174: PUSH
73175: LD_VAR 0 2
73179: ARRAY
73180: PUSH
73181: LD_INT 3
73183: LESS
73184: AND
73185: IFFALSE 73243
// begin SetTag ( j , 121 ) ;
73187: LD_VAR 0 3
73191: PPUSH
73192: LD_INT 121
73194: PPUSH
73195: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73199: LD_ADDR_EXP 54
73203: PUSH
73204: LD_EXP 54
73208: PPUSH
73209: LD_VAR 0 2
73213: PUSH
73214: LD_EXP 54
73218: PUSH
73219: LD_VAR 0 2
73223: ARRAY
73224: PUSH
73225: LD_INT 1
73227: PLUS
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PPUSH
73233: LD_VAR 0 3
73237: PPUSH
73238: CALL 16077 0 3
73242: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73243: LD_VAR 0 3
73247: PUSH
73248: LD_EXP 54
73252: PUSH
73253: LD_VAR 0 2
73257: ARRAY
73258: IN
73259: IFFALSE 73484
// begin if GetClass ( j ) <> 4 then
73261: LD_VAR 0 3
73265: PPUSH
73266: CALL_OW 257
73270: PUSH
73271: LD_INT 4
73273: NONEQUAL
73274: IFFALSE 73327
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73276: LD_ADDR_EXP 54
73280: PUSH
73281: LD_EXP 54
73285: PPUSH
73286: LD_VAR 0 2
73290: PPUSH
73291: LD_EXP 54
73295: PUSH
73296: LD_VAR 0 2
73300: ARRAY
73301: PUSH
73302: LD_VAR 0 3
73306: DIFF
73307: PPUSH
73308: CALL_OW 1
73312: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73313: LD_VAR 0 3
73317: PPUSH
73318: LD_INT 0
73320: PPUSH
73321: CALL_OW 109
// continue ;
73325: GO 73149
// end ; if IsInUnit ( j ) then
73327: LD_VAR 0 3
73331: PPUSH
73332: CALL_OW 310
73336: IFFALSE 73347
// ComExitBuilding ( j ) ;
73338: LD_VAR 0 3
73342: PPUSH
73343: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73347: LD_ADDR_VAR 0 6
73351: PUSH
73352: LD_VAR 0 7
73356: PPUSH
73357: LD_VAR 0 3
73361: PPUSH
73362: CALL_OW 74
73366: ST_TO_ADDR
// if not ape then
73367: LD_VAR 0 6
73371: NOT
73372: IFFALSE 73376
// break ;
73374: GO 73486
// x := GetX ( ape ) ;
73376: LD_ADDR_VAR 0 4
73380: PUSH
73381: LD_VAR 0 6
73385: PPUSH
73386: CALL_OW 250
73390: ST_TO_ADDR
// y := GetY ( ape ) ;
73391: LD_ADDR_VAR 0 5
73395: PUSH
73396: LD_VAR 0 6
73400: PPUSH
73401: CALL_OW 251
73405: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73406: LD_VAR 0 4
73410: PPUSH
73411: LD_VAR 0 5
73415: PPUSH
73416: CALL_OW 488
73420: NOT
73421: PUSH
73422: LD_VAR 0 11
73426: PPUSH
73427: LD_VAR 0 4
73431: PPUSH
73432: LD_VAR 0 5
73436: PPUSH
73437: LD_INT 20
73439: PPUSH
73440: CALL 17341 0 4
73444: PUSH
73445: LD_INT 4
73447: ARRAY
73448: OR
73449: IFFALSE 73453
// break ;
73451: GO 73486
// if not HasTask ( j ) then
73453: LD_VAR 0 3
73457: PPUSH
73458: CALL_OW 314
73462: NOT
73463: IFFALSE 73484
// ComTameXY ( j , x , y ) ;
73465: LD_VAR 0 3
73469: PPUSH
73470: LD_VAR 0 4
73474: PPUSH
73475: LD_VAR 0 5
73479: PPUSH
73480: CALL_OW 131
// end ; end ;
73484: GO 73149
73486: POP
73487: POP
// end ;
73488: GO 72705
73490: POP
73491: POP
// end ;
73492: LD_VAR 0 1
73496: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73497: LD_INT 0
73499: PPUSH
73500: PPUSH
73501: PPUSH
73502: PPUSH
73503: PPUSH
73504: PPUSH
73505: PPUSH
73506: PPUSH
// if not mc_bases then
73507: LD_EXP 23
73511: NOT
73512: IFFALSE 73516
// exit ;
73514: GO 74142
// for i = 1 to mc_bases do
73516: LD_ADDR_VAR 0 2
73520: PUSH
73521: DOUBLE
73522: LD_INT 1
73524: DEC
73525: ST_TO_ADDR
73526: LD_EXP 23
73530: PUSH
73531: FOR_TO
73532: IFFALSE 74140
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73534: LD_EXP 52
73538: PUSH
73539: LD_VAR 0 2
73543: ARRAY
73544: NOT
73545: PUSH
73546: LD_EXP 52
73550: PUSH
73551: LD_VAR 0 2
73555: ARRAY
73556: PPUSH
73557: LD_INT 25
73559: PUSH
73560: LD_INT 12
73562: PUSH
73563: EMPTY
73564: LIST
73565: LIST
73566: PPUSH
73567: CALL_OW 72
73571: NOT
73572: OR
73573: IFFALSE 73577
// continue ;
73575: GO 73531
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73577: LD_ADDR_VAR 0 5
73581: PUSH
73582: LD_EXP 52
73586: PUSH
73587: LD_VAR 0 2
73591: ARRAY
73592: PUSH
73593: LD_INT 1
73595: ARRAY
73596: PPUSH
73597: CALL_OW 255
73601: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73602: LD_VAR 0 5
73606: PPUSH
73607: LD_INT 2
73609: PPUSH
73610: CALL_OW 325
73614: IFFALSE 73867
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73616: LD_ADDR_VAR 0 4
73620: PUSH
73621: LD_EXP 52
73625: PUSH
73626: LD_VAR 0 2
73630: ARRAY
73631: PPUSH
73632: LD_INT 25
73634: PUSH
73635: LD_INT 16
73637: PUSH
73638: EMPTY
73639: LIST
73640: LIST
73641: PPUSH
73642: CALL_OW 72
73646: ST_TO_ADDR
// if tmp < 6 then
73647: LD_VAR 0 4
73651: PUSH
73652: LD_INT 6
73654: LESS
73655: IFFALSE 73867
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73657: LD_ADDR_VAR 0 6
73661: PUSH
73662: LD_EXP 23
73666: PUSH
73667: LD_VAR 0 2
73671: ARRAY
73672: PPUSH
73673: LD_INT 2
73675: PUSH
73676: LD_INT 30
73678: PUSH
73679: LD_INT 0
73681: PUSH
73682: EMPTY
73683: LIST
73684: LIST
73685: PUSH
73686: LD_INT 30
73688: PUSH
73689: LD_INT 1
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: LIST
73700: PPUSH
73701: CALL_OW 72
73705: ST_TO_ADDR
// if depot then
73706: LD_VAR 0 6
73710: IFFALSE 73867
// begin selected := 0 ;
73712: LD_ADDR_VAR 0 7
73716: PUSH
73717: LD_INT 0
73719: ST_TO_ADDR
// for j in depot do
73720: LD_ADDR_VAR 0 3
73724: PUSH
73725: LD_VAR 0 6
73729: PUSH
73730: FOR_IN
73731: IFFALSE 73762
// begin if UnitsInside ( j ) < 6 then
73733: LD_VAR 0 3
73737: PPUSH
73738: CALL_OW 313
73742: PUSH
73743: LD_INT 6
73745: LESS
73746: IFFALSE 73760
// begin selected := j ;
73748: LD_ADDR_VAR 0 7
73752: PUSH
73753: LD_VAR 0 3
73757: ST_TO_ADDR
// break ;
73758: GO 73762
// end ; end ;
73760: GO 73730
73762: POP
73763: POP
// if selected then
73764: LD_VAR 0 7
73768: IFFALSE 73867
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73770: LD_ADDR_VAR 0 3
73774: PUSH
73775: LD_EXP 52
73779: PUSH
73780: LD_VAR 0 2
73784: ARRAY
73785: PPUSH
73786: LD_INT 25
73788: PUSH
73789: LD_INT 12
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PPUSH
73796: CALL_OW 72
73800: PUSH
73801: FOR_IN
73802: IFFALSE 73865
// if not HasTask ( j ) then
73804: LD_VAR 0 3
73808: PPUSH
73809: CALL_OW 314
73813: NOT
73814: IFFALSE 73863
// begin if not IsInUnit ( j ) then
73816: LD_VAR 0 3
73820: PPUSH
73821: CALL_OW 310
73825: NOT
73826: IFFALSE 73842
// ComEnterUnit ( j , selected ) ;
73828: LD_VAR 0 3
73832: PPUSH
73833: LD_VAR 0 7
73837: PPUSH
73838: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73842: LD_VAR 0 3
73846: PPUSH
73847: LD_INT 16
73849: PPUSH
73850: CALL_OW 183
// AddComExitBuilding ( j ) ;
73854: LD_VAR 0 3
73858: PPUSH
73859: CALL_OW 182
// end ;
73863: GO 73801
73865: POP
73866: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73867: LD_VAR 0 5
73871: PPUSH
73872: LD_INT 11
73874: PPUSH
73875: CALL_OW 325
73879: IFFALSE 74138
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73881: LD_ADDR_VAR 0 4
73885: PUSH
73886: LD_EXP 52
73890: PUSH
73891: LD_VAR 0 2
73895: ARRAY
73896: PPUSH
73897: LD_INT 25
73899: PUSH
73900: LD_INT 16
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PPUSH
73907: CALL_OW 72
73911: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73912: LD_VAR 0 4
73916: PUSH
73917: LD_INT 6
73919: GREATEREQUAL
73920: PUSH
73921: LD_VAR 0 5
73925: PPUSH
73926: LD_INT 2
73928: PPUSH
73929: CALL_OW 325
73933: NOT
73934: OR
73935: IFFALSE 74138
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73937: LD_ADDR_VAR 0 8
73941: PUSH
73942: LD_EXP 23
73946: PUSH
73947: LD_VAR 0 2
73951: ARRAY
73952: PPUSH
73953: LD_INT 2
73955: PUSH
73956: LD_INT 30
73958: PUSH
73959: LD_INT 4
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 30
73968: PUSH
73969: LD_INT 5
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: LIST
73980: PPUSH
73981: CALL_OW 72
73985: ST_TO_ADDR
// if barracks then
73986: LD_VAR 0 8
73990: IFFALSE 74138
// begin selected := 0 ;
73992: LD_ADDR_VAR 0 7
73996: PUSH
73997: LD_INT 0
73999: ST_TO_ADDR
// for j in barracks do
74000: LD_ADDR_VAR 0 3
74004: PUSH
74005: LD_VAR 0 8
74009: PUSH
74010: FOR_IN
74011: IFFALSE 74042
// begin if UnitsInside ( j ) < 6 then
74013: LD_VAR 0 3
74017: PPUSH
74018: CALL_OW 313
74022: PUSH
74023: LD_INT 6
74025: LESS
74026: IFFALSE 74040
// begin selected := j ;
74028: LD_ADDR_VAR 0 7
74032: PUSH
74033: LD_VAR 0 3
74037: ST_TO_ADDR
// break ;
74038: GO 74042
// end ; end ;
74040: GO 74010
74042: POP
74043: POP
// if selected then
74044: LD_VAR 0 7
74048: IFFALSE 74138
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74050: LD_ADDR_VAR 0 3
74054: PUSH
74055: LD_EXP 52
74059: PUSH
74060: LD_VAR 0 2
74064: ARRAY
74065: PPUSH
74066: LD_INT 25
74068: PUSH
74069: LD_INT 12
74071: PUSH
74072: EMPTY
74073: LIST
74074: LIST
74075: PPUSH
74076: CALL_OW 72
74080: PUSH
74081: FOR_IN
74082: IFFALSE 74136
// if not IsInUnit ( j ) and not HasTask ( j ) then
74084: LD_VAR 0 3
74088: PPUSH
74089: CALL_OW 310
74093: NOT
74094: PUSH
74095: LD_VAR 0 3
74099: PPUSH
74100: CALL_OW 314
74104: NOT
74105: AND
74106: IFFALSE 74134
// begin ComEnterUnit ( j , selected ) ;
74108: LD_VAR 0 3
74112: PPUSH
74113: LD_VAR 0 7
74117: PPUSH
74118: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74122: LD_VAR 0 3
74126: PPUSH
74127: LD_INT 15
74129: PPUSH
74130: CALL_OW 183
// end ;
74134: GO 74081
74136: POP
74137: POP
// end ; end ; end ; end ; end ;
74138: GO 73531
74140: POP
74141: POP
// end ;
74142: LD_VAR 0 1
74146: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74147: LD_INT 0
74149: PPUSH
74150: PPUSH
74151: PPUSH
74152: PPUSH
// if not mc_bases then
74153: LD_EXP 23
74157: NOT
74158: IFFALSE 74162
// exit ;
74160: GO 74340
// for i = 1 to mc_bases do
74162: LD_ADDR_VAR 0 2
74166: PUSH
74167: DOUBLE
74168: LD_INT 1
74170: DEC
74171: ST_TO_ADDR
74172: LD_EXP 23
74176: PUSH
74177: FOR_TO
74178: IFFALSE 74338
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74180: LD_ADDR_VAR 0 4
74184: PUSH
74185: LD_EXP 23
74189: PUSH
74190: LD_VAR 0 2
74194: ARRAY
74195: PPUSH
74196: LD_INT 25
74198: PUSH
74199: LD_INT 9
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PPUSH
74206: CALL_OW 72
74210: ST_TO_ADDR
// if not tmp then
74211: LD_VAR 0 4
74215: NOT
74216: IFFALSE 74220
// continue ;
74218: GO 74177
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74220: LD_EXP 49
74224: PUSH
74225: LD_VAR 0 2
74229: ARRAY
74230: PPUSH
74231: LD_INT 29
74233: PPUSH
74234: CALL_OW 325
74238: NOT
74239: PUSH
74240: LD_EXP 49
74244: PUSH
74245: LD_VAR 0 2
74249: ARRAY
74250: PPUSH
74251: LD_INT 28
74253: PPUSH
74254: CALL_OW 325
74258: NOT
74259: AND
74260: IFFALSE 74264
// continue ;
74262: GO 74177
// for j in tmp do
74264: LD_ADDR_VAR 0 3
74268: PUSH
74269: LD_VAR 0 4
74273: PUSH
74274: FOR_IN
74275: IFFALSE 74334
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74277: LD_VAR 0 3
74281: PUSH
74282: LD_EXP 26
74286: PUSH
74287: LD_VAR 0 2
74291: ARRAY
74292: PUSH
74293: LD_INT 1
74295: ARRAY
74296: IN
74297: NOT
74298: PUSH
74299: LD_VAR 0 3
74303: PUSH
74304: LD_EXP 26
74308: PUSH
74309: LD_VAR 0 2
74313: ARRAY
74314: PUSH
74315: LD_INT 2
74317: ARRAY
74318: IN
74319: NOT
74320: AND
74321: IFFALSE 74332
// ComSpaceTimeShoot ( j ) ;
74323: LD_VAR 0 3
74327: PPUSH
74328: CALL 12062 0 1
74332: GO 74274
74334: POP
74335: POP
// end ;
74336: GO 74177
74338: POP
74339: POP
// end ;
74340: LD_VAR 0 1
74344: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74345: LD_INT 0
74347: PPUSH
74348: PPUSH
74349: PPUSH
74350: PPUSH
74351: PPUSH
74352: PPUSH
74353: PPUSH
74354: PPUSH
74355: PPUSH
// if not mc_bases then
74356: LD_EXP 23
74360: NOT
74361: IFFALSE 74365
// exit ;
74363: GO 74987
// for i = 1 to mc_bases do
74365: LD_ADDR_VAR 0 2
74369: PUSH
74370: DOUBLE
74371: LD_INT 1
74373: DEC
74374: ST_TO_ADDR
74375: LD_EXP 23
74379: PUSH
74380: FOR_TO
74381: IFFALSE 74985
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74383: LD_EXP 58
74387: PUSH
74388: LD_VAR 0 2
74392: ARRAY
74393: NOT
74394: PUSH
74395: LD_INT 38
74397: PPUSH
74398: LD_EXP 49
74402: PUSH
74403: LD_VAR 0 2
74407: ARRAY
74408: PPUSH
74409: CALL_OW 321
74413: PUSH
74414: LD_INT 2
74416: NONEQUAL
74417: OR
74418: IFFALSE 74422
// continue ;
74420: GO 74380
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74422: LD_ADDR_VAR 0 8
74426: PUSH
74427: LD_EXP 23
74431: PUSH
74432: LD_VAR 0 2
74436: ARRAY
74437: PPUSH
74438: LD_INT 30
74440: PUSH
74441: LD_INT 34
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PPUSH
74448: CALL_OW 72
74452: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74453: LD_ADDR_VAR 0 9
74457: PUSH
74458: LD_EXP 23
74462: PUSH
74463: LD_VAR 0 2
74467: ARRAY
74468: PPUSH
74469: LD_INT 25
74471: PUSH
74472: LD_INT 4
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: PPUSH
74479: CALL_OW 72
74483: PPUSH
74484: LD_INT 0
74486: PPUSH
74487: CALL 46375 0 2
74491: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74492: LD_VAR 0 9
74496: NOT
74497: PUSH
74498: LD_VAR 0 8
74502: NOT
74503: OR
74504: PUSH
74505: LD_EXP 23
74509: PUSH
74510: LD_VAR 0 2
74514: ARRAY
74515: PPUSH
74516: LD_INT 124
74518: PPUSH
74519: CALL 46375 0 2
74523: OR
74524: IFFALSE 74528
// continue ;
74526: GO 74380
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74528: LD_EXP 59
74532: PUSH
74533: LD_VAR 0 2
74537: ARRAY
74538: PUSH
74539: LD_EXP 58
74543: PUSH
74544: LD_VAR 0 2
74548: ARRAY
74549: LESS
74550: PUSH
74551: LD_EXP 59
74555: PUSH
74556: LD_VAR 0 2
74560: ARRAY
74561: PUSH
74562: LD_VAR 0 8
74566: LESS
74567: AND
74568: IFFALSE 74983
// begin tmp := sci [ 1 ] ;
74570: LD_ADDR_VAR 0 7
74574: PUSH
74575: LD_VAR 0 9
74579: PUSH
74580: LD_INT 1
74582: ARRAY
74583: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74584: LD_VAR 0 7
74588: PPUSH
74589: LD_INT 124
74591: PPUSH
74592: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74596: LD_ADDR_VAR 0 3
74600: PUSH
74601: DOUBLE
74602: LD_EXP 58
74606: PUSH
74607: LD_VAR 0 2
74611: ARRAY
74612: INC
74613: ST_TO_ADDR
74614: LD_EXP 58
74618: PUSH
74619: LD_VAR 0 2
74623: ARRAY
74624: PUSH
74625: FOR_DOWNTO
74626: IFFALSE 74969
// begin if IsInUnit ( tmp ) then
74628: LD_VAR 0 7
74632: PPUSH
74633: CALL_OW 310
74637: IFFALSE 74648
// ComExitBuilding ( tmp ) ;
74639: LD_VAR 0 7
74643: PPUSH
74644: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74648: LD_INT 35
74650: PPUSH
74651: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74655: LD_VAR 0 7
74659: PPUSH
74660: CALL_OW 310
74664: NOT
74665: PUSH
74666: LD_VAR 0 7
74670: PPUSH
74671: CALL_OW 314
74675: NOT
74676: AND
74677: IFFALSE 74648
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74679: LD_ADDR_VAR 0 6
74683: PUSH
74684: LD_VAR 0 7
74688: PPUSH
74689: CALL_OW 250
74693: PUSH
74694: LD_VAR 0 7
74698: PPUSH
74699: CALL_OW 251
74703: PUSH
74704: EMPTY
74705: LIST
74706: LIST
74707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74708: LD_INT 35
74710: PPUSH
74711: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74715: LD_ADDR_VAR 0 4
74719: PUSH
74720: LD_EXP 58
74724: PUSH
74725: LD_VAR 0 2
74729: ARRAY
74730: PUSH
74731: LD_VAR 0 3
74735: ARRAY
74736: PUSH
74737: LD_INT 1
74739: ARRAY
74740: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74741: LD_ADDR_VAR 0 5
74745: PUSH
74746: LD_EXP 58
74750: PUSH
74751: LD_VAR 0 2
74755: ARRAY
74756: PUSH
74757: LD_VAR 0 3
74761: ARRAY
74762: PUSH
74763: LD_INT 2
74765: ARRAY
74766: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74767: LD_VAR 0 7
74771: PPUSH
74772: LD_INT 10
74774: PPUSH
74775: CALL 19042 0 2
74779: PUSH
74780: LD_INT 4
74782: ARRAY
74783: IFFALSE 74821
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74785: LD_VAR 0 7
74789: PPUSH
74790: LD_VAR 0 6
74794: PUSH
74795: LD_INT 1
74797: ARRAY
74798: PPUSH
74799: LD_VAR 0 6
74803: PUSH
74804: LD_INT 2
74806: ARRAY
74807: PPUSH
74808: CALL_OW 111
// wait ( 0 0$10 ) ;
74812: LD_INT 350
74814: PPUSH
74815: CALL_OW 67
// end else
74819: GO 74847
// begin ComMoveXY ( tmp , x , y ) ;
74821: LD_VAR 0 7
74825: PPUSH
74826: LD_VAR 0 4
74830: PPUSH
74831: LD_VAR 0 5
74835: PPUSH
74836: CALL_OW 111
// wait ( 0 0$3 ) ;
74840: LD_INT 105
74842: PPUSH
74843: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74847: LD_VAR 0 7
74851: PPUSH
74852: LD_VAR 0 4
74856: PPUSH
74857: LD_VAR 0 5
74861: PPUSH
74862: CALL_OW 307
74866: IFFALSE 74708
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74868: LD_VAR 0 7
74872: PPUSH
74873: LD_VAR 0 4
74877: PPUSH
74878: LD_VAR 0 5
74882: PPUSH
74883: LD_VAR 0 8
74887: PUSH
74888: LD_VAR 0 3
74892: ARRAY
74893: PPUSH
74894: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74898: LD_INT 35
74900: PPUSH
74901: CALL_OW 67
// until not HasTask ( tmp ) ;
74905: LD_VAR 0 7
74909: PPUSH
74910: CALL_OW 314
74914: NOT
74915: IFFALSE 74898
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74917: LD_ADDR_EXP 59
74921: PUSH
74922: LD_EXP 59
74926: PPUSH
74927: LD_VAR 0 2
74931: PUSH
74932: LD_EXP 59
74936: PUSH
74937: LD_VAR 0 2
74941: ARRAY
74942: PUSH
74943: LD_INT 1
74945: PLUS
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: PPUSH
74951: LD_VAR 0 8
74955: PUSH
74956: LD_VAR 0 3
74960: ARRAY
74961: PPUSH
74962: CALL 16077 0 3
74966: ST_TO_ADDR
// end ;
74967: GO 74625
74969: POP
74970: POP
// MC_Reset ( i , 124 ) ;
74971: LD_VAR 0 2
74975: PPUSH
74976: LD_INT 124
74978: PPUSH
74979: CALL 58055 0 2
// end ; end ;
74983: GO 74380
74985: POP
74986: POP
// end ;
74987: LD_VAR 0 1
74991: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74992: LD_INT 0
74994: PPUSH
74995: PPUSH
74996: PPUSH
// if not mc_bases then
74997: LD_EXP 23
75001: NOT
75002: IFFALSE 75006
// exit ;
75004: GO 75612
// for i = 1 to mc_bases do
75006: LD_ADDR_VAR 0 2
75010: PUSH
75011: DOUBLE
75012: LD_INT 1
75014: DEC
75015: ST_TO_ADDR
75016: LD_EXP 23
75020: PUSH
75021: FOR_TO
75022: IFFALSE 75610
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75024: LD_ADDR_VAR 0 3
75028: PUSH
75029: LD_EXP 23
75033: PUSH
75034: LD_VAR 0 2
75038: ARRAY
75039: PPUSH
75040: LD_INT 25
75042: PUSH
75043: LD_INT 4
75045: PUSH
75046: EMPTY
75047: LIST
75048: LIST
75049: PPUSH
75050: CALL_OW 72
75054: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75055: LD_VAR 0 3
75059: NOT
75060: PUSH
75061: LD_EXP 60
75065: PUSH
75066: LD_VAR 0 2
75070: ARRAY
75071: NOT
75072: OR
75073: PUSH
75074: LD_EXP 23
75078: PUSH
75079: LD_VAR 0 2
75083: ARRAY
75084: PPUSH
75085: LD_INT 2
75087: PUSH
75088: LD_INT 30
75090: PUSH
75091: LD_INT 0
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: LD_INT 30
75100: PUSH
75101: LD_INT 1
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: EMPTY
75109: LIST
75110: LIST
75111: LIST
75112: PPUSH
75113: CALL_OW 72
75117: NOT
75118: OR
75119: IFFALSE 75169
// begin if mc_deposits_finder [ i ] then
75121: LD_EXP 61
75125: PUSH
75126: LD_VAR 0 2
75130: ARRAY
75131: IFFALSE 75167
// begin MC_Reset ( i , 125 ) ;
75133: LD_VAR 0 2
75137: PPUSH
75138: LD_INT 125
75140: PPUSH
75141: CALL 58055 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75145: LD_ADDR_EXP 61
75149: PUSH
75150: LD_EXP 61
75154: PPUSH
75155: LD_VAR 0 2
75159: PPUSH
75160: EMPTY
75161: PPUSH
75162: CALL_OW 1
75166: ST_TO_ADDR
// end ; continue ;
75167: GO 75021
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75169: LD_EXP 60
75173: PUSH
75174: LD_VAR 0 2
75178: ARRAY
75179: PUSH
75180: LD_INT 1
75182: ARRAY
75183: PUSH
75184: LD_INT 3
75186: ARRAY
75187: PUSH
75188: LD_INT 1
75190: EQUAL
75191: PUSH
75192: LD_INT 20
75194: PPUSH
75195: LD_EXP 49
75199: PUSH
75200: LD_VAR 0 2
75204: ARRAY
75205: PPUSH
75206: CALL_OW 321
75210: PUSH
75211: LD_INT 2
75213: NONEQUAL
75214: AND
75215: IFFALSE 75265
// begin if mc_deposits_finder [ i ] then
75217: LD_EXP 61
75221: PUSH
75222: LD_VAR 0 2
75226: ARRAY
75227: IFFALSE 75263
// begin MC_Reset ( i , 125 ) ;
75229: LD_VAR 0 2
75233: PPUSH
75234: LD_INT 125
75236: PPUSH
75237: CALL 58055 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75241: LD_ADDR_EXP 61
75245: PUSH
75246: LD_EXP 61
75250: PPUSH
75251: LD_VAR 0 2
75255: PPUSH
75256: EMPTY
75257: PPUSH
75258: CALL_OW 1
75262: ST_TO_ADDR
// end ; continue ;
75263: GO 75021
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75265: LD_EXP 60
75269: PUSH
75270: LD_VAR 0 2
75274: ARRAY
75275: PUSH
75276: LD_INT 1
75278: ARRAY
75279: PUSH
75280: LD_INT 1
75282: ARRAY
75283: PPUSH
75284: LD_EXP 60
75288: PUSH
75289: LD_VAR 0 2
75293: ARRAY
75294: PUSH
75295: LD_INT 1
75297: ARRAY
75298: PUSH
75299: LD_INT 2
75301: ARRAY
75302: PPUSH
75303: LD_EXP 49
75307: PUSH
75308: LD_VAR 0 2
75312: ARRAY
75313: PPUSH
75314: CALL_OW 440
75318: IFFALSE 75361
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75320: LD_ADDR_EXP 60
75324: PUSH
75325: LD_EXP 60
75329: PPUSH
75330: LD_VAR 0 2
75334: PPUSH
75335: LD_EXP 60
75339: PUSH
75340: LD_VAR 0 2
75344: ARRAY
75345: PPUSH
75346: LD_INT 1
75348: PPUSH
75349: CALL_OW 3
75353: PPUSH
75354: CALL_OW 1
75358: ST_TO_ADDR
75359: GO 75608
// begin if not mc_deposits_finder [ i ] then
75361: LD_EXP 61
75365: PUSH
75366: LD_VAR 0 2
75370: ARRAY
75371: NOT
75372: IFFALSE 75424
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75374: LD_ADDR_EXP 61
75378: PUSH
75379: LD_EXP 61
75383: PPUSH
75384: LD_VAR 0 2
75388: PPUSH
75389: LD_VAR 0 3
75393: PUSH
75394: LD_INT 1
75396: ARRAY
75397: PUSH
75398: EMPTY
75399: LIST
75400: PPUSH
75401: CALL_OW 1
75405: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75406: LD_VAR 0 3
75410: PUSH
75411: LD_INT 1
75413: ARRAY
75414: PPUSH
75415: LD_INT 125
75417: PPUSH
75418: CALL_OW 109
// end else
75422: GO 75608
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75424: LD_EXP 61
75428: PUSH
75429: LD_VAR 0 2
75433: ARRAY
75434: PUSH
75435: LD_INT 1
75437: ARRAY
75438: PPUSH
75439: CALL_OW 310
75443: IFFALSE 75466
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75445: LD_EXP 61
75449: PUSH
75450: LD_VAR 0 2
75454: ARRAY
75455: PUSH
75456: LD_INT 1
75458: ARRAY
75459: PPUSH
75460: CALL_OW 122
75464: GO 75608
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75466: LD_EXP 61
75470: PUSH
75471: LD_VAR 0 2
75475: ARRAY
75476: PUSH
75477: LD_INT 1
75479: ARRAY
75480: PPUSH
75481: CALL_OW 314
75485: NOT
75486: PUSH
75487: LD_EXP 61
75491: PUSH
75492: LD_VAR 0 2
75496: ARRAY
75497: PUSH
75498: LD_INT 1
75500: ARRAY
75501: PPUSH
75502: LD_EXP 60
75506: PUSH
75507: LD_VAR 0 2
75511: ARRAY
75512: PUSH
75513: LD_INT 1
75515: ARRAY
75516: PUSH
75517: LD_INT 1
75519: ARRAY
75520: PPUSH
75521: LD_EXP 60
75525: PUSH
75526: LD_VAR 0 2
75530: ARRAY
75531: PUSH
75532: LD_INT 1
75534: ARRAY
75535: PUSH
75536: LD_INT 2
75538: ARRAY
75539: PPUSH
75540: CALL_OW 297
75544: PUSH
75545: LD_INT 6
75547: GREATER
75548: AND
75549: IFFALSE 75608
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75551: LD_EXP 61
75555: PUSH
75556: LD_VAR 0 2
75560: ARRAY
75561: PUSH
75562: LD_INT 1
75564: ARRAY
75565: PPUSH
75566: LD_EXP 60
75570: PUSH
75571: LD_VAR 0 2
75575: ARRAY
75576: PUSH
75577: LD_INT 1
75579: ARRAY
75580: PUSH
75581: LD_INT 1
75583: ARRAY
75584: PPUSH
75585: LD_EXP 60
75589: PUSH
75590: LD_VAR 0 2
75594: ARRAY
75595: PUSH
75596: LD_INT 1
75598: ARRAY
75599: PUSH
75600: LD_INT 2
75602: ARRAY
75603: PPUSH
75604: CALL_OW 111
// end ; end ; end ;
75608: GO 75021
75610: POP
75611: POP
// end ;
75612: LD_VAR 0 1
75616: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75617: LD_INT 0
75619: PPUSH
75620: PPUSH
75621: PPUSH
75622: PPUSH
75623: PPUSH
75624: PPUSH
75625: PPUSH
75626: PPUSH
75627: PPUSH
75628: PPUSH
75629: PPUSH
// if not mc_bases then
75630: LD_EXP 23
75634: NOT
75635: IFFALSE 75639
// exit ;
75637: GO 76579
// for i = 1 to mc_bases do
75639: LD_ADDR_VAR 0 2
75643: PUSH
75644: DOUBLE
75645: LD_INT 1
75647: DEC
75648: ST_TO_ADDR
75649: LD_EXP 23
75653: PUSH
75654: FOR_TO
75655: IFFALSE 76577
// begin if not mc_bases [ i ] or mc_scan [ i ] then
75657: LD_EXP 23
75661: PUSH
75662: LD_VAR 0 2
75666: ARRAY
75667: NOT
75668: PUSH
75669: LD_EXP 46
75673: PUSH
75674: LD_VAR 0 2
75678: ARRAY
75679: OR
75680: IFFALSE 75684
// continue ;
75682: GO 75654
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75684: LD_ADDR_VAR 0 7
75688: PUSH
75689: LD_EXP 23
75693: PUSH
75694: LD_VAR 0 2
75698: ARRAY
75699: PUSH
75700: LD_INT 1
75702: ARRAY
75703: PPUSH
75704: CALL_OW 248
75708: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75709: LD_VAR 0 7
75713: PUSH
75714: LD_INT 3
75716: EQUAL
75717: PUSH
75718: LD_EXP 42
75722: PUSH
75723: LD_VAR 0 2
75727: ARRAY
75728: PUSH
75729: LD_EXP 45
75733: PUSH
75734: LD_VAR 0 2
75738: ARRAY
75739: UNION
75740: PPUSH
75741: LD_INT 33
75743: PUSH
75744: LD_INT 2
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PPUSH
75751: CALL_OW 72
75755: NOT
75756: OR
75757: IFFALSE 75761
// continue ;
75759: GO 75654
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75761: LD_ADDR_VAR 0 9
75765: PUSH
75766: LD_EXP 23
75770: PUSH
75771: LD_VAR 0 2
75775: ARRAY
75776: PPUSH
75777: LD_INT 30
75779: PUSH
75780: LD_INT 36
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PPUSH
75787: CALL_OW 72
75791: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75792: LD_ADDR_VAR 0 10
75796: PUSH
75797: LD_EXP 42
75801: PUSH
75802: LD_VAR 0 2
75806: ARRAY
75807: PPUSH
75808: LD_INT 34
75810: PUSH
75811: LD_INT 31
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PPUSH
75818: CALL_OW 72
75822: ST_TO_ADDR
// if not cts and not mcts then
75823: LD_VAR 0 9
75827: NOT
75828: PUSH
75829: LD_VAR 0 10
75833: NOT
75834: AND
75835: IFFALSE 75839
// continue ;
75837: GO 75654
// x := cts ;
75839: LD_ADDR_VAR 0 11
75843: PUSH
75844: LD_VAR 0 9
75848: ST_TO_ADDR
// if not x then
75849: LD_VAR 0 11
75853: NOT
75854: IFFALSE 75866
// x := mcts ;
75856: LD_ADDR_VAR 0 11
75860: PUSH
75861: LD_VAR 0 10
75865: ST_TO_ADDR
// if not x then
75866: LD_VAR 0 11
75870: NOT
75871: IFFALSE 75875
// continue ;
75873: GO 75654
// if mc_remote_driver [ i ] then
75875: LD_EXP 63
75879: PUSH
75880: LD_VAR 0 2
75884: ARRAY
75885: IFFALSE 76272
// for j in mc_remote_driver [ i ] do
75887: LD_ADDR_VAR 0 3
75891: PUSH
75892: LD_EXP 63
75896: PUSH
75897: LD_VAR 0 2
75901: ARRAY
75902: PUSH
75903: FOR_IN
75904: IFFALSE 76270
// begin if GetClass ( j ) <> 3 then
75906: LD_VAR 0 3
75910: PPUSH
75911: CALL_OW 257
75915: PUSH
75916: LD_INT 3
75918: NONEQUAL
75919: IFFALSE 75972
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75921: LD_ADDR_EXP 63
75925: PUSH
75926: LD_EXP 63
75930: PPUSH
75931: LD_VAR 0 2
75935: PPUSH
75936: LD_EXP 63
75940: PUSH
75941: LD_VAR 0 2
75945: ARRAY
75946: PUSH
75947: LD_VAR 0 3
75951: DIFF
75952: PPUSH
75953: CALL_OW 1
75957: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75958: LD_VAR 0 3
75962: PPUSH
75963: LD_INT 0
75965: PPUSH
75966: CALL_OW 109
// continue ;
75970: GO 75903
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
75972: LD_EXP 42
75976: PUSH
75977: LD_VAR 0 2
75981: ARRAY
75982: PPUSH
75983: LD_INT 34
75985: PUSH
75986: LD_INT 31
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: PUSH
75993: LD_INT 58
75995: PUSH
75996: EMPTY
75997: LIST
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PPUSH
76003: CALL_OW 72
76007: PUSH
76008: LD_VAR 0 3
76012: PPUSH
76013: CALL 46410 0 1
76017: NOT
76018: AND
76019: IFFALSE 76090
// begin if IsInUnit ( j ) then
76021: LD_VAR 0 3
76025: PPUSH
76026: CALL_OW 310
76030: IFFALSE 76041
// ComExitBuilding ( j ) ;
76032: LD_VAR 0 3
76036: PPUSH
76037: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
76041: LD_VAR 0 3
76045: PPUSH
76046: LD_EXP 42
76050: PUSH
76051: LD_VAR 0 2
76055: ARRAY
76056: PPUSH
76057: LD_INT 34
76059: PUSH
76060: LD_INT 31
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 58
76069: PUSH
76070: EMPTY
76071: LIST
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PPUSH
76077: CALL_OW 72
76081: PUSH
76082: LD_INT 1
76084: ARRAY
76085: PPUSH
76086: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76090: LD_VAR 0 3
76094: PPUSH
76095: CALL_OW 310
76099: NOT
76100: PUSH
76101: LD_VAR 0 3
76105: PPUSH
76106: CALL_OW 310
76110: PPUSH
76111: CALL_OW 266
76115: PUSH
76116: LD_INT 36
76118: NONEQUAL
76119: PUSH
76120: LD_VAR 0 3
76124: PPUSH
76125: CALL 46410 0 1
76129: NOT
76130: AND
76131: OR
76132: IFFALSE 76268
// begin if IsInUnit ( j ) then
76134: LD_VAR 0 3
76138: PPUSH
76139: CALL_OW 310
76143: IFFALSE 76154
// ComExitBuilding ( j ) ;
76145: LD_VAR 0 3
76149: PPUSH
76150: CALL_OW 122
// ct := 0 ;
76154: LD_ADDR_VAR 0 8
76158: PUSH
76159: LD_INT 0
76161: ST_TO_ADDR
// for k in x do
76162: LD_ADDR_VAR 0 4
76166: PUSH
76167: LD_VAR 0 11
76171: PUSH
76172: FOR_IN
76173: IFFALSE 76246
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76175: LD_VAR 0 4
76179: PPUSH
76180: CALL_OW 264
76184: PUSH
76185: LD_INT 31
76187: EQUAL
76188: PUSH
76189: LD_VAR 0 4
76193: PPUSH
76194: CALL_OW 311
76198: NOT
76199: AND
76200: PUSH
76201: LD_VAR 0 4
76205: PPUSH
76206: CALL_OW 266
76210: PUSH
76211: LD_INT 36
76213: EQUAL
76214: PUSH
76215: LD_VAR 0 4
76219: PPUSH
76220: CALL_OW 313
76224: PUSH
76225: LD_INT 3
76227: LESS
76228: AND
76229: OR
76230: IFFALSE 76244
// begin ct := k ;
76232: LD_ADDR_VAR 0 8
76236: PUSH
76237: LD_VAR 0 4
76241: ST_TO_ADDR
// break ;
76242: GO 76246
// end ;
76244: GO 76172
76246: POP
76247: POP
// if ct then
76248: LD_VAR 0 8
76252: IFFALSE 76268
// ComEnterUnit ( j , ct ) ;
76254: LD_VAR 0 3
76258: PPUSH
76259: LD_VAR 0 8
76263: PPUSH
76264: CALL_OW 120
// end ; end ;
76268: GO 75903
76270: POP
76271: POP
// places := 0 ;
76272: LD_ADDR_VAR 0 5
76276: PUSH
76277: LD_INT 0
76279: ST_TO_ADDR
// for j = 1 to x do
76280: LD_ADDR_VAR 0 3
76284: PUSH
76285: DOUBLE
76286: LD_INT 1
76288: DEC
76289: ST_TO_ADDR
76290: LD_VAR 0 11
76294: PUSH
76295: FOR_TO
76296: IFFALSE 76372
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76298: LD_VAR 0 11
76302: PUSH
76303: LD_VAR 0 3
76307: ARRAY
76308: PPUSH
76309: CALL_OW 264
76313: PUSH
76314: LD_INT 31
76316: EQUAL
76317: IFFALSE 76335
// places := places + 1 else
76319: LD_ADDR_VAR 0 5
76323: PUSH
76324: LD_VAR 0 5
76328: PUSH
76329: LD_INT 1
76331: PLUS
76332: ST_TO_ADDR
76333: GO 76370
// if GetBType ( x [ j ] ) = b_control_tower then
76335: LD_VAR 0 11
76339: PUSH
76340: LD_VAR 0 3
76344: ARRAY
76345: PPUSH
76346: CALL_OW 266
76350: PUSH
76351: LD_INT 36
76353: EQUAL
76354: IFFALSE 76370
// places := places + 3 ;
76356: LD_ADDR_VAR 0 5
76360: PUSH
76361: LD_VAR 0 5
76365: PUSH
76366: LD_INT 3
76368: PLUS
76369: ST_TO_ADDR
76370: GO 76295
76372: POP
76373: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
76374: LD_VAR 0 5
76378: PUSH
76379: LD_INT 0
76381: EQUAL
76382: PUSH
76383: LD_VAR 0 5
76387: PUSH
76388: LD_EXP 63
76392: PUSH
76393: LD_VAR 0 2
76397: ARRAY
76398: LESSEQUAL
76399: OR
76400: IFFALSE 76404
// continue ;
76402: GO 75654
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76404: LD_ADDR_VAR 0 6
76408: PUSH
76409: LD_EXP 23
76413: PUSH
76414: LD_VAR 0 2
76418: ARRAY
76419: PPUSH
76420: LD_INT 25
76422: PUSH
76423: LD_INT 3
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PPUSH
76430: CALL_OW 72
76434: PUSH
76435: LD_EXP 63
76439: PUSH
76440: LD_VAR 0 2
76444: ARRAY
76445: DIFF
76446: PPUSH
76447: LD_INT 3
76449: PPUSH
76450: CALL 47310 0 2
76454: ST_TO_ADDR
// for j in tmp do
76455: LD_ADDR_VAR 0 3
76459: PUSH
76460: LD_VAR 0 6
76464: PUSH
76465: FOR_IN
76466: IFFALSE 76501
// if GetTag ( j ) > 0 then
76468: LD_VAR 0 3
76472: PPUSH
76473: CALL_OW 110
76477: PUSH
76478: LD_INT 0
76480: GREATER
76481: IFFALSE 76499
// tmp := tmp diff j ;
76483: LD_ADDR_VAR 0 6
76487: PUSH
76488: LD_VAR 0 6
76492: PUSH
76493: LD_VAR 0 3
76497: DIFF
76498: ST_TO_ADDR
76499: GO 76465
76501: POP
76502: POP
// if not tmp then
76503: LD_VAR 0 6
76507: NOT
76508: IFFALSE 76512
// continue ;
76510: GO 75654
// if places then
76512: LD_VAR 0 5
76516: IFFALSE 76575
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76518: LD_ADDR_EXP 63
76522: PUSH
76523: LD_EXP 63
76527: PPUSH
76528: LD_VAR 0 2
76532: PPUSH
76533: LD_EXP 63
76537: PUSH
76538: LD_VAR 0 2
76542: ARRAY
76543: PUSH
76544: LD_VAR 0 6
76548: PUSH
76549: LD_INT 1
76551: ARRAY
76552: UNION
76553: PPUSH
76554: CALL_OW 1
76558: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76559: LD_VAR 0 6
76563: PUSH
76564: LD_INT 1
76566: ARRAY
76567: PPUSH
76568: LD_INT 126
76570: PPUSH
76571: CALL_OW 109
// end ; end ;
76575: GO 75654
76577: POP
76578: POP
// end ;
76579: LD_VAR 0 1
76583: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76584: LD_INT 0
76586: PPUSH
76587: PPUSH
76588: PPUSH
76589: PPUSH
76590: PPUSH
76591: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76592: LD_VAR 0 1
76596: NOT
76597: PUSH
76598: LD_VAR 0 2
76602: NOT
76603: OR
76604: PUSH
76605: LD_VAR 0 3
76609: NOT
76610: OR
76611: PUSH
76612: LD_VAR 0 4
76616: PUSH
76617: LD_INT 1
76619: PUSH
76620: LD_INT 2
76622: PUSH
76623: LD_INT 3
76625: PUSH
76626: LD_INT 4
76628: PUSH
76629: LD_INT 5
76631: PUSH
76632: LD_INT 8
76634: PUSH
76635: LD_INT 9
76637: PUSH
76638: LD_INT 15
76640: PUSH
76641: LD_INT 16
76643: PUSH
76644: EMPTY
76645: LIST
76646: LIST
76647: LIST
76648: LIST
76649: LIST
76650: LIST
76651: LIST
76652: LIST
76653: LIST
76654: IN
76655: NOT
76656: OR
76657: IFFALSE 76661
// exit ;
76659: GO 77519
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76661: LD_ADDR_VAR 0 2
76665: PUSH
76666: LD_VAR 0 2
76670: PPUSH
76671: LD_INT 21
76673: PUSH
76674: LD_INT 3
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: LD_INT 24
76683: PUSH
76684: LD_INT 250
76686: PUSH
76687: EMPTY
76688: LIST
76689: LIST
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PPUSH
76695: CALL_OW 72
76699: ST_TO_ADDR
// case class of 1 , 15 :
76700: LD_VAR 0 4
76704: PUSH
76705: LD_INT 1
76707: DOUBLE
76708: EQUAL
76709: IFTRUE 76719
76711: LD_INT 15
76713: DOUBLE
76714: EQUAL
76715: IFTRUE 76719
76717: GO 76804
76719: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76720: LD_ADDR_VAR 0 8
76724: PUSH
76725: LD_VAR 0 2
76729: PPUSH
76730: LD_INT 2
76732: PUSH
76733: LD_INT 30
76735: PUSH
76736: LD_INT 32
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PUSH
76743: LD_INT 30
76745: PUSH
76746: LD_INT 31
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: LIST
76757: PPUSH
76758: CALL_OW 72
76762: PUSH
76763: LD_VAR 0 2
76767: PPUSH
76768: LD_INT 2
76770: PUSH
76771: LD_INT 30
76773: PUSH
76774: LD_INT 4
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: PUSH
76781: LD_INT 30
76783: PUSH
76784: LD_INT 5
76786: PUSH
76787: EMPTY
76788: LIST
76789: LIST
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: LIST
76795: PPUSH
76796: CALL_OW 72
76800: ADD
76801: ST_TO_ADDR
76802: GO 77050
76804: LD_INT 2
76806: DOUBLE
76807: EQUAL
76808: IFTRUE 76818
76810: LD_INT 16
76812: DOUBLE
76813: EQUAL
76814: IFTRUE 76818
76816: GO 76864
76818: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76819: LD_ADDR_VAR 0 8
76823: PUSH
76824: LD_VAR 0 2
76828: PPUSH
76829: LD_INT 2
76831: PUSH
76832: LD_INT 30
76834: PUSH
76835: LD_INT 0
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PUSH
76842: LD_INT 30
76844: PUSH
76845: LD_INT 1
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: EMPTY
76853: LIST
76854: LIST
76855: LIST
76856: PPUSH
76857: CALL_OW 72
76861: ST_TO_ADDR
76862: GO 77050
76864: LD_INT 3
76866: DOUBLE
76867: EQUAL
76868: IFTRUE 76872
76870: GO 76918
76872: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76873: LD_ADDR_VAR 0 8
76877: PUSH
76878: LD_VAR 0 2
76882: PPUSH
76883: LD_INT 2
76885: PUSH
76886: LD_INT 30
76888: PUSH
76889: LD_INT 2
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 30
76898: PUSH
76899: LD_INT 3
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: LIST
76910: PPUSH
76911: CALL_OW 72
76915: ST_TO_ADDR
76916: GO 77050
76918: LD_INT 4
76920: DOUBLE
76921: EQUAL
76922: IFTRUE 76926
76924: GO 76983
76926: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76927: LD_ADDR_VAR 0 8
76931: PUSH
76932: LD_VAR 0 2
76936: PPUSH
76937: LD_INT 2
76939: PUSH
76940: LD_INT 30
76942: PUSH
76943: LD_INT 6
76945: PUSH
76946: EMPTY
76947: LIST
76948: LIST
76949: PUSH
76950: LD_INT 30
76952: PUSH
76953: LD_INT 7
76955: PUSH
76956: EMPTY
76957: LIST
76958: LIST
76959: PUSH
76960: LD_INT 30
76962: PUSH
76963: LD_INT 8
76965: PUSH
76966: EMPTY
76967: LIST
76968: LIST
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: LIST
76974: LIST
76975: PPUSH
76976: CALL_OW 72
76980: ST_TO_ADDR
76981: GO 77050
76983: LD_INT 5
76985: DOUBLE
76986: EQUAL
76987: IFTRUE 77003
76989: LD_INT 8
76991: DOUBLE
76992: EQUAL
76993: IFTRUE 77003
76995: LD_INT 9
76997: DOUBLE
76998: EQUAL
76999: IFTRUE 77003
77001: GO 77049
77003: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77004: LD_ADDR_VAR 0 8
77008: PUSH
77009: LD_VAR 0 2
77013: PPUSH
77014: LD_INT 2
77016: PUSH
77017: LD_INT 30
77019: PUSH
77020: LD_INT 4
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: LD_INT 30
77029: PUSH
77030: LD_INT 5
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: LIST
77041: PPUSH
77042: CALL_OW 72
77046: ST_TO_ADDR
77047: GO 77050
77049: POP
// if not tmp then
77050: LD_VAR 0 8
77054: NOT
77055: IFFALSE 77059
// exit ;
77057: GO 77519
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77059: LD_VAR 0 4
77063: PUSH
77064: LD_INT 1
77066: PUSH
77067: LD_INT 15
77069: PUSH
77070: EMPTY
77071: LIST
77072: LIST
77073: IN
77074: PUSH
77075: LD_EXP 32
77079: PUSH
77080: LD_VAR 0 1
77084: ARRAY
77085: AND
77086: IFFALSE 77242
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77088: LD_ADDR_VAR 0 9
77092: PUSH
77093: LD_EXP 32
77097: PUSH
77098: LD_VAR 0 1
77102: ARRAY
77103: PUSH
77104: LD_INT 1
77106: ARRAY
77107: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77108: LD_VAR 0 9
77112: PUSH
77113: LD_EXP 33
77117: PUSH
77118: LD_VAR 0 1
77122: ARRAY
77123: IN
77124: NOT
77125: IFFALSE 77240
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77127: LD_ADDR_EXP 33
77131: PUSH
77132: LD_EXP 33
77136: PPUSH
77137: LD_VAR 0 1
77141: PUSH
77142: LD_EXP 33
77146: PUSH
77147: LD_VAR 0 1
77151: ARRAY
77152: PUSH
77153: LD_INT 1
77155: PLUS
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PPUSH
77161: LD_VAR 0 9
77165: PPUSH
77166: CALL 16077 0 3
77170: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77171: LD_ADDR_EXP 32
77175: PUSH
77176: LD_EXP 32
77180: PPUSH
77181: LD_VAR 0 1
77185: PPUSH
77186: LD_EXP 32
77190: PUSH
77191: LD_VAR 0 1
77195: ARRAY
77196: PUSH
77197: LD_VAR 0 9
77201: DIFF
77202: PPUSH
77203: CALL_OW 1
77207: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77208: LD_VAR 0 3
77212: PPUSH
77213: LD_EXP 33
77217: PUSH
77218: LD_VAR 0 1
77222: ARRAY
77223: PUSH
77224: LD_EXP 33
77228: PUSH
77229: LD_VAR 0 1
77233: ARRAY
77234: ARRAY
77235: PPUSH
77236: CALL_OW 120
// end ; exit ;
77240: GO 77519
// end ; if tmp > 1 then
77242: LD_VAR 0 8
77246: PUSH
77247: LD_INT 1
77249: GREATER
77250: IFFALSE 77354
// for i = 2 to tmp do
77252: LD_ADDR_VAR 0 6
77256: PUSH
77257: DOUBLE
77258: LD_INT 2
77260: DEC
77261: ST_TO_ADDR
77262: LD_VAR 0 8
77266: PUSH
77267: FOR_TO
77268: IFFALSE 77352
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77270: LD_VAR 0 8
77274: PUSH
77275: LD_VAR 0 6
77279: ARRAY
77280: PPUSH
77281: CALL_OW 461
77285: PUSH
77286: LD_INT 6
77288: EQUAL
77289: IFFALSE 77350
// begin x := tmp [ i ] ;
77291: LD_ADDR_VAR 0 9
77295: PUSH
77296: LD_VAR 0 8
77300: PUSH
77301: LD_VAR 0 6
77305: ARRAY
77306: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77307: LD_ADDR_VAR 0 8
77311: PUSH
77312: LD_VAR 0 8
77316: PPUSH
77317: LD_VAR 0 6
77321: PPUSH
77322: CALL_OW 3
77326: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77327: LD_ADDR_VAR 0 8
77331: PUSH
77332: LD_VAR 0 8
77336: PPUSH
77337: LD_INT 1
77339: PPUSH
77340: LD_VAR 0 9
77344: PPUSH
77345: CALL_OW 2
77349: ST_TO_ADDR
// end ;
77350: GO 77267
77352: POP
77353: POP
// for i in tmp do
77354: LD_ADDR_VAR 0 6
77358: PUSH
77359: LD_VAR 0 8
77363: PUSH
77364: FOR_IN
77365: IFFALSE 77392
// begin if IsNotFull ( i ) then
77367: LD_VAR 0 6
77371: PPUSH
77372: CALL 13299 0 1
77376: IFFALSE 77390
// begin j := i ;
77378: LD_ADDR_VAR 0 7
77382: PUSH
77383: LD_VAR 0 6
77387: ST_TO_ADDR
// break ;
77388: GO 77392
// end ; end ;
77390: GO 77364
77392: POP
77393: POP
// if j then
77394: LD_VAR 0 7
77398: IFFALSE 77416
// ComEnterUnit ( unit , j ) else
77400: LD_VAR 0 3
77404: PPUSH
77405: LD_VAR 0 7
77409: PPUSH
77410: CALL_OW 120
77414: GO 77519
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77416: LD_ADDR_VAR 0 10
77420: PUSH
77421: LD_VAR 0 2
77425: PPUSH
77426: LD_INT 2
77428: PUSH
77429: LD_INT 30
77431: PUSH
77432: LD_INT 0
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: LD_INT 30
77441: PUSH
77442: LD_INT 1
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: LIST
77453: PPUSH
77454: CALL_OW 72
77458: ST_TO_ADDR
// if depot then
77459: LD_VAR 0 10
77463: IFFALSE 77519
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77465: LD_ADDR_VAR 0 10
77469: PUSH
77470: LD_VAR 0 10
77474: PPUSH
77475: LD_VAR 0 3
77479: PPUSH
77480: CALL_OW 74
77484: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77485: LD_VAR 0 3
77489: PPUSH
77490: LD_VAR 0 10
77494: PPUSH
77495: CALL_OW 296
77499: PUSH
77500: LD_INT 10
77502: GREATER
77503: IFFALSE 77519
// ComStandNearbyBuilding ( unit , depot ) ;
77505: LD_VAR 0 3
77509: PPUSH
77510: LD_VAR 0 10
77514: PPUSH
77515: CALL 12679 0 2
// end ; end ; end ;
77519: LD_VAR 0 5
77523: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77524: LD_INT 0
77526: PPUSH
77527: PPUSH
77528: PPUSH
77529: PPUSH
// if not mc_bases then
77530: LD_EXP 23
77534: NOT
77535: IFFALSE 77539
// exit ;
77537: GO 77778
// for i = 1 to mc_bases do
77539: LD_ADDR_VAR 0 2
77543: PUSH
77544: DOUBLE
77545: LD_INT 1
77547: DEC
77548: ST_TO_ADDR
77549: LD_EXP 23
77553: PUSH
77554: FOR_TO
77555: IFFALSE 77776
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77557: LD_ADDR_VAR 0 4
77561: PUSH
77562: LD_EXP 23
77566: PUSH
77567: LD_VAR 0 2
77571: ARRAY
77572: PPUSH
77573: LD_INT 21
77575: PUSH
77576: LD_INT 1
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PPUSH
77583: CALL_OW 72
77587: PUSH
77588: LD_EXP 52
77592: PUSH
77593: LD_VAR 0 2
77597: ARRAY
77598: UNION
77599: ST_TO_ADDR
// if not tmp then
77600: LD_VAR 0 4
77604: NOT
77605: IFFALSE 77609
// continue ;
77607: GO 77554
// for j in tmp do
77609: LD_ADDR_VAR 0 3
77613: PUSH
77614: LD_VAR 0 4
77618: PUSH
77619: FOR_IN
77620: IFFALSE 77772
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77622: LD_VAR 0 3
77626: PPUSH
77627: CALL_OW 110
77631: NOT
77632: PUSH
77633: LD_VAR 0 3
77637: PPUSH
77638: CALL_OW 314
77642: NOT
77643: AND
77644: PUSH
77645: LD_VAR 0 3
77649: PPUSH
77650: CALL_OW 311
77654: NOT
77655: AND
77656: PUSH
77657: LD_VAR 0 3
77661: PPUSH
77662: CALL_OW 310
77666: NOT
77667: AND
77668: PUSH
77669: LD_VAR 0 3
77673: PUSH
77674: LD_EXP 26
77678: PUSH
77679: LD_VAR 0 2
77683: ARRAY
77684: PUSH
77685: LD_INT 1
77687: ARRAY
77688: IN
77689: NOT
77690: AND
77691: PUSH
77692: LD_VAR 0 3
77696: PUSH
77697: LD_EXP 26
77701: PUSH
77702: LD_VAR 0 2
77706: ARRAY
77707: PUSH
77708: LD_INT 2
77710: ARRAY
77711: IN
77712: NOT
77713: AND
77714: PUSH
77715: LD_VAR 0 3
77719: PUSH
77720: LD_EXP 35
77724: PUSH
77725: LD_VAR 0 2
77729: ARRAY
77730: IN
77731: NOT
77732: AND
77733: IFFALSE 77770
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77735: LD_VAR 0 2
77739: PPUSH
77740: LD_EXP 23
77744: PUSH
77745: LD_VAR 0 2
77749: ARRAY
77750: PPUSH
77751: LD_VAR 0 3
77755: PPUSH
77756: LD_VAR 0 3
77760: PPUSH
77761: CALL_OW 257
77765: PPUSH
77766: CALL 76584 0 4
// end ;
77770: GO 77619
77772: POP
77773: POP
// end ;
77774: GO 77554
77776: POP
77777: POP
// end ;
77778: LD_VAR 0 1
77782: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
77783: LD_INT 0
77785: PPUSH
77786: PPUSH
77787: PPUSH
77788: PPUSH
77789: PPUSH
77790: PPUSH
// if not mc_bases [ base ] then
77791: LD_EXP 23
77795: PUSH
77796: LD_VAR 0 1
77800: ARRAY
77801: NOT
77802: IFFALSE 77806
// exit ;
77804: GO 78007
// tmp := [ ] ;
77806: LD_ADDR_VAR 0 6
77810: PUSH
77811: EMPTY
77812: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77813: LD_ADDR_VAR 0 7
77817: PUSH
77818: LD_VAR 0 3
77822: PPUSH
77823: LD_INT 0
77825: PPUSH
77826: CALL_OW 517
77830: ST_TO_ADDR
// if not list then
77831: LD_VAR 0 7
77835: NOT
77836: IFFALSE 77840
// exit ;
77838: GO 78007
// c := Count ( list [ 1 ] ) ;
77840: LD_ADDR_VAR 0 9
77844: PUSH
77845: LD_VAR 0 7
77849: PUSH
77850: LD_INT 1
77852: ARRAY
77853: PPUSH
77854: CALL 13217 0 1
77858: ST_TO_ADDR
// if amount > c then
77859: LD_VAR 0 2
77863: PUSH
77864: LD_VAR 0 9
77868: GREATER
77869: IFFALSE 77881
// amount := c ;
77871: LD_ADDR_VAR 0 2
77875: PUSH
77876: LD_VAR 0 9
77880: ST_TO_ADDR
// for i := 1 to amount do
77881: LD_ADDR_VAR 0 5
77885: PUSH
77886: DOUBLE
77887: LD_INT 1
77889: DEC
77890: ST_TO_ADDR
77891: LD_VAR 0 2
77895: PUSH
77896: FOR_TO
77897: IFFALSE 77955
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
77899: LD_ADDR_VAR 0 6
77903: PUSH
77904: LD_VAR 0 6
77908: PPUSH
77909: LD_VAR 0 5
77913: PPUSH
77914: LD_VAR 0 7
77918: PUSH
77919: LD_INT 1
77921: ARRAY
77922: PUSH
77923: LD_VAR 0 5
77927: ARRAY
77928: PUSH
77929: LD_VAR 0 7
77933: PUSH
77934: LD_INT 2
77936: ARRAY
77937: PUSH
77938: LD_VAR 0 5
77942: ARRAY
77943: PUSH
77944: EMPTY
77945: LIST
77946: LIST
77947: PPUSH
77948: CALL_OW 1
77952: ST_TO_ADDR
77953: GO 77896
77955: POP
77956: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77957: LD_ADDR_EXP 36
77961: PUSH
77962: LD_EXP 36
77966: PPUSH
77967: LD_VAR 0 1
77971: PPUSH
77972: LD_VAR 0 6
77976: PPUSH
77977: CALL_OW 1
77981: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77982: LD_ADDR_EXP 38
77986: PUSH
77987: LD_EXP 38
77991: PPUSH
77992: LD_VAR 0 1
77996: PPUSH
77997: LD_VAR 0 3
78001: PPUSH
78002: CALL_OW 1
78006: ST_TO_ADDR
// end ;
78007: LD_VAR 0 4
78011: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78012: LD_INT 0
78014: PPUSH
// if not mc_bases [ base ] then
78015: LD_EXP 23
78019: PUSH
78020: LD_VAR 0 1
78024: ARRAY
78025: NOT
78026: IFFALSE 78030
// exit ;
78028: GO 78055
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78030: LD_ADDR_EXP 28
78034: PUSH
78035: LD_EXP 28
78039: PPUSH
78040: LD_VAR 0 1
78044: PPUSH
78045: LD_VAR 0 2
78049: PPUSH
78050: CALL_OW 1
78054: ST_TO_ADDR
// end ;
78055: LD_VAR 0 3
78059: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78060: LD_INT 0
78062: PPUSH
// if not mc_bases [ base ] then
78063: LD_EXP 23
78067: PUSH
78068: LD_VAR 0 1
78072: ARRAY
78073: NOT
78074: IFFALSE 78078
// exit ;
78076: GO 78115
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78078: LD_ADDR_EXP 28
78082: PUSH
78083: LD_EXP 28
78087: PPUSH
78088: LD_VAR 0 1
78092: PPUSH
78093: LD_EXP 28
78097: PUSH
78098: LD_VAR 0 1
78102: ARRAY
78103: PUSH
78104: LD_VAR 0 2
78108: UNION
78109: PPUSH
78110: CALL_OW 1
78114: ST_TO_ADDR
// end ;
78115: LD_VAR 0 3
78119: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78120: LD_INT 0
78122: PPUSH
// if not mc_bases [ base ] then
78123: LD_EXP 23
78127: PUSH
78128: LD_VAR 0 1
78132: ARRAY
78133: NOT
78134: IFFALSE 78138
// exit ;
78136: GO 78163
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78138: LD_ADDR_EXP 44
78142: PUSH
78143: LD_EXP 44
78147: PPUSH
78148: LD_VAR 0 1
78152: PPUSH
78153: LD_VAR 0 2
78157: PPUSH
78158: CALL_OW 1
78162: ST_TO_ADDR
// end ;
78163: LD_VAR 0 3
78167: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78168: LD_INT 0
78170: PPUSH
// if not mc_bases [ base ] then
78171: LD_EXP 23
78175: PUSH
78176: LD_VAR 0 1
78180: ARRAY
78181: NOT
78182: IFFALSE 78186
// exit ;
78184: GO 78223
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78186: LD_ADDR_EXP 44
78190: PUSH
78191: LD_EXP 44
78195: PPUSH
78196: LD_VAR 0 1
78200: PPUSH
78201: LD_EXP 44
78205: PUSH
78206: LD_VAR 0 1
78210: ARRAY
78211: PUSH
78212: LD_VAR 0 2
78216: ADD
78217: PPUSH
78218: CALL_OW 1
78222: ST_TO_ADDR
// end ;
78223: LD_VAR 0 3
78227: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78228: LD_INT 0
78230: PPUSH
// if not mc_bases [ base ] then
78231: LD_EXP 23
78235: PUSH
78236: LD_VAR 0 1
78240: ARRAY
78241: NOT
78242: IFFALSE 78246
// exit ;
78244: GO 78300
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78246: LD_ADDR_EXP 45
78250: PUSH
78251: LD_EXP 45
78255: PPUSH
78256: LD_VAR 0 1
78260: PPUSH
78261: LD_VAR 0 2
78265: PPUSH
78266: CALL_OW 1
78270: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78271: LD_ADDR_EXP 34
78275: PUSH
78276: LD_EXP 34
78280: PPUSH
78281: LD_VAR 0 1
78285: PPUSH
78286: LD_VAR 0 2
78290: PUSH
78291: LD_INT 0
78293: PLUS
78294: PPUSH
78295: CALL_OW 1
78299: ST_TO_ADDR
// end ;
78300: LD_VAR 0 3
78304: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78305: LD_INT 0
78307: PPUSH
// if not mc_bases [ base ] then
78308: LD_EXP 23
78312: PUSH
78313: LD_VAR 0 1
78317: ARRAY
78318: NOT
78319: IFFALSE 78323
// exit ;
78321: GO 78348
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78323: LD_ADDR_EXP 34
78327: PUSH
78328: LD_EXP 34
78332: PPUSH
78333: LD_VAR 0 1
78337: PPUSH
78338: LD_VAR 0 2
78342: PPUSH
78343: CALL_OW 1
78347: ST_TO_ADDR
// end ;
78348: LD_VAR 0 3
78352: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78353: LD_INT 0
78355: PPUSH
78356: PPUSH
78357: PPUSH
78358: PPUSH
// if not mc_bases [ base ] then
78359: LD_EXP 23
78363: PUSH
78364: LD_VAR 0 1
78368: ARRAY
78369: NOT
78370: IFFALSE 78374
// exit ;
78372: GO 78439
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78374: LD_ADDR_EXP 43
78378: PUSH
78379: LD_EXP 43
78383: PPUSH
78384: LD_VAR 0 1
78388: PUSH
78389: LD_EXP 43
78393: PUSH
78394: LD_VAR 0 1
78398: ARRAY
78399: PUSH
78400: LD_INT 1
78402: PLUS
78403: PUSH
78404: EMPTY
78405: LIST
78406: LIST
78407: PPUSH
78408: LD_VAR 0 1
78412: PUSH
78413: LD_VAR 0 2
78417: PUSH
78418: LD_VAR 0 3
78422: PUSH
78423: LD_VAR 0 4
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: LIST
78432: LIST
78433: PPUSH
78434: CALL 16077 0 3
78438: ST_TO_ADDR
// end ;
78439: LD_VAR 0 5
78443: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78444: LD_INT 0
78446: PPUSH
// if not mc_bases [ base ] then
78447: LD_EXP 23
78451: PUSH
78452: LD_VAR 0 1
78456: ARRAY
78457: NOT
78458: IFFALSE 78462
// exit ;
78460: GO 78487
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78462: LD_ADDR_EXP 60
78466: PUSH
78467: LD_EXP 60
78471: PPUSH
78472: LD_VAR 0 1
78476: PPUSH
78477: LD_VAR 0 2
78481: PPUSH
78482: CALL_OW 1
78486: ST_TO_ADDR
// end ;
78487: LD_VAR 0 3
78491: RET
// export function MC_GetMinesField ( base ) ; begin
78492: LD_INT 0
78494: PPUSH
// result := mc_mines [ base ] ;
78495: LD_ADDR_VAR 0 2
78499: PUSH
78500: LD_EXP 36
78504: PUSH
78505: LD_VAR 0 1
78509: ARRAY
78510: ST_TO_ADDR
// end ;
78511: LD_VAR 0 2
78515: RET
// export function MC_GetProduceList ( base ) ; begin
78516: LD_INT 0
78518: PPUSH
// result := mc_produce [ base ] ;
78519: LD_ADDR_VAR 0 2
78523: PUSH
78524: LD_EXP 44
78528: PUSH
78529: LD_VAR 0 1
78533: ARRAY
78534: ST_TO_ADDR
// end ;
78535: LD_VAR 0 2
78539: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78540: LD_INT 0
78542: PPUSH
78543: PPUSH
// if not mc_bases then
78544: LD_EXP 23
78548: NOT
78549: IFFALSE 78553
// exit ;
78551: GO 78618
// if mc_bases [ base ] then
78553: LD_EXP 23
78557: PUSH
78558: LD_VAR 0 1
78562: ARRAY
78563: IFFALSE 78618
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78565: LD_ADDR_VAR 0 3
78569: PUSH
78570: LD_EXP 23
78574: PUSH
78575: LD_VAR 0 1
78579: ARRAY
78580: PPUSH
78581: LD_INT 30
78583: PUSH
78584: LD_VAR 0 2
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PPUSH
78593: CALL_OW 72
78597: ST_TO_ADDR
// if result then
78598: LD_VAR 0 3
78602: IFFALSE 78618
// result := result [ 1 ] ;
78604: LD_ADDR_VAR 0 3
78608: PUSH
78609: LD_VAR 0 3
78613: PUSH
78614: LD_INT 1
78616: ARRAY
78617: ST_TO_ADDR
// end ; end ;
78618: LD_VAR 0 3
78622: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78623: LD_INT 0
78625: PPUSH
78626: PPUSH
// if not mc_bases then
78627: LD_EXP 23
78631: NOT
78632: IFFALSE 78636
// exit ;
78634: GO 78681
// if mc_bases [ base ] then
78636: LD_EXP 23
78640: PUSH
78641: LD_VAR 0 1
78645: ARRAY
78646: IFFALSE 78681
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78648: LD_ADDR_VAR 0 3
78652: PUSH
78653: LD_EXP 23
78657: PUSH
78658: LD_VAR 0 1
78662: ARRAY
78663: PPUSH
78664: LD_INT 30
78666: PUSH
78667: LD_VAR 0 2
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: PPUSH
78676: CALL_OW 72
78680: ST_TO_ADDR
// end ;
78681: LD_VAR 0 3
78685: RET
// export function MC_SetTame ( base , area ) ; begin
78686: LD_INT 0
78688: PPUSH
// if not mc_bases or not base then
78689: LD_EXP 23
78693: NOT
78694: PUSH
78695: LD_VAR 0 1
78699: NOT
78700: OR
78701: IFFALSE 78705
// exit ;
78703: GO 78730
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78705: LD_ADDR_EXP 51
78709: PUSH
78710: LD_EXP 51
78714: PPUSH
78715: LD_VAR 0 1
78719: PPUSH
78720: LD_VAR 0 2
78724: PPUSH
78725: CALL_OW 1
78729: ST_TO_ADDR
// end ;
78730: LD_VAR 0 3
78734: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78735: LD_INT 0
78737: PPUSH
78738: PPUSH
// if not mc_bases or not base then
78739: LD_EXP 23
78743: NOT
78744: PUSH
78745: LD_VAR 0 1
78749: NOT
78750: OR
78751: IFFALSE 78755
// exit ;
78753: GO 78857
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78755: LD_ADDR_VAR 0 4
78759: PUSH
78760: LD_EXP 23
78764: PUSH
78765: LD_VAR 0 1
78769: ARRAY
78770: PPUSH
78771: LD_INT 30
78773: PUSH
78774: LD_VAR 0 2
78778: PUSH
78779: EMPTY
78780: LIST
78781: LIST
78782: PPUSH
78783: CALL_OW 72
78787: ST_TO_ADDR
// if not tmp then
78788: LD_VAR 0 4
78792: NOT
78793: IFFALSE 78797
// exit ;
78795: GO 78857
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78797: LD_ADDR_EXP 55
78801: PUSH
78802: LD_EXP 55
78806: PPUSH
78807: LD_VAR 0 1
78811: PPUSH
78812: LD_EXP 55
78816: PUSH
78817: LD_VAR 0 1
78821: ARRAY
78822: PPUSH
78823: LD_EXP 55
78827: PUSH
78828: LD_VAR 0 1
78832: ARRAY
78833: PUSH
78834: LD_INT 1
78836: PLUS
78837: PPUSH
78838: LD_VAR 0 4
78842: PUSH
78843: LD_INT 1
78845: ARRAY
78846: PPUSH
78847: CALL_OW 2
78851: PPUSH
78852: CALL_OW 1
78856: ST_TO_ADDR
// end ;
78857: LD_VAR 0 3
78861: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78862: LD_INT 0
78864: PPUSH
78865: PPUSH
// if not mc_bases or not base or not kinds then
78866: LD_EXP 23
78870: NOT
78871: PUSH
78872: LD_VAR 0 1
78876: NOT
78877: OR
78878: PUSH
78879: LD_VAR 0 2
78883: NOT
78884: OR
78885: IFFALSE 78889
// exit ;
78887: GO 78950
// for i in kinds do
78889: LD_ADDR_VAR 0 4
78893: PUSH
78894: LD_VAR 0 2
78898: PUSH
78899: FOR_IN
78900: IFFALSE 78948
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78902: LD_ADDR_EXP 57
78906: PUSH
78907: LD_EXP 57
78911: PPUSH
78912: LD_VAR 0 1
78916: PUSH
78917: LD_EXP 57
78921: PUSH
78922: LD_VAR 0 1
78926: ARRAY
78927: PUSH
78928: LD_INT 1
78930: PLUS
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: PPUSH
78936: LD_VAR 0 4
78940: PPUSH
78941: CALL 16077 0 3
78945: ST_TO_ADDR
78946: GO 78899
78948: POP
78949: POP
// end ;
78950: LD_VAR 0 3
78954: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78955: LD_INT 0
78957: PPUSH
// if not mc_bases or not base or not areas then
78958: LD_EXP 23
78962: NOT
78963: PUSH
78964: LD_VAR 0 1
78968: NOT
78969: OR
78970: PUSH
78971: LD_VAR 0 2
78975: NOT
78976: OR
78977: IFFALSE 78981
// exit ;
78979: GO 79006
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78981: LD_ADDR_EXP 41
78985: PUSH
78986: LD_EXP 41
78990: PPUSH
78991: LD_VAR 0 1
78995: PPUSH
78996: LD_VAR 0 2
79000: PPUSH
79001: CALL_OW 1
79005: ST_TO_ADDR
// end ;
79006: LD_VAR 0 3
79010: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79011: LD_INT 0
79013: PPUSH
// if not mc_bases or not base or not teleports_exit then
79014: LD_EXP 23
79018: NOT
79019: PUSH
79020: LD_VAR 0 1
79024: NOT
79025: OR
79026: PUSH
79027: LD_VAR 0 2
79031: NOT
79032: OR
79033: IFFALSE 79037
// exit ;
79035: GO 79062
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79037: LD_ADDR_EXP 58
79041: PUSH
79042: LD_EXP 58
79046: PPUSH
79047: LD_VAR 0 1
79051: PPUSH
79052: LD_VAR 0 2
79056: PPUSH
79057: CALL_OW 1
79061: ST_TO_ADDR
// end ;
79062: LD_VAR 0 3
79066: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79067: LD_INT 0
79069: PPUSH
79070: PPUSH
79071: PPUSH
// if not mc_bases or not base or not ext_list then
79072: LD_EXP 23
79076: NOT
79077: PUSH
79078: LD_VAR 0 1
79082: NOT
79083: OR
79084: PUSH
79085: LD_VAR 0 5
79089: NOT
79090: OR
79091: IFFALSE 79095
// exit ;
79093: GO 79268
// tmp := GetFacExtXYD ( x , y , d ) ;
79095: LD_ADDR_VAR 0 8
79099: PUSH
79100: LD_VAR 0 2
79104: PPUSH
79105: LD_VAR 0 3
79109: PPUSH
79110: LD_VAR 0 4
79114: PPUSH
79115: CALL 46440 0 3
79119: ST_TO_ADDR
// if not tmp then
79120: LD_VAR 0 8
79124: NOT
79125: IFFALSE 79129
// exit ;
79127: GO 79268
// for i in tmp do
79129: LD_ADDR_VAR 0 7
79133: PUSH
79134: LD_VAR 0 8
79138: PUSH
79139: FOR_IN
79140: IFFALSE 79266
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79142: LD_ADDR_EXP 28
79146: PUSH
79147: LD_EXP 28
79151: PPUSH
79152: LD_VAR 0 1
79156: PPUSH
79157: LD_EXP 28
79161: PUSH
79162: LD_VAR 0 1
79166: ARRAY
79167: PPUSH
79168: LD_EXP 28
79172: PUSH
79173: LD_VAR 0 1
79177: ARRAY
79178: PUSH
79179: LD_INT 1
79181: PLUS
79182: PPUSH
79183: LD_VAR 0 5
79187: PUSH
79188: LD_INT 1
79190: ARRAY
79191: PUSH
79192: LD_VAR 0 7
79196: PUSH
79197: LD_INT 1
79199: ARRAY
79200: PUSH
79201: LD_VAR 0 7
79205: PUSH
79206: LD_INT 2
79208: ARRAY
79209: PUSH
79210: LD_VAR 0 7
79214: PUSH
79215: LD_INT 3
79217: ARRAY
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: PPUSH
79225: CALL_OW 2
79229: PPUSH
79230: CALL_OW 1
79234: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79235: LD_ADDR_VAR 0 5
79239: PUSH
79240: LD_VAR 0 5
79244: PPUSH
79245: LD_INT 1
79247: PPUSH
79248: CALL_OW 3
79252: ST_TO_ADDR
// if not ext_list then
79253: LD_VAR 0 5
79257: NOT
79258: IFFALSE 79264
// exit ;
79260: POP
79261: POP
79262: GO 79268
// end ;
79264: GO 79139
79266: POP
79267: POP
// end ;
79268: LD_VAR 0 6
79272: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79273: LD_INT 0
79275: PPUSH
// if not mc_bases or not base or not weapon_list then
79276: LD_EXP 23
79280: NOT
79281: PUSH
79282: LD_VAR 0 1
79286: NOT
79287: OR
79288: PUSH
79289: LD_VAR 0 2
79293: NOT
79294: OR
79295: IFFALSE 79299
// exit ;
79297: GO 79324
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79299: LD_ADDR_EXP 62
79303: PUSH
79304: LD_EXP 62
79308: PPUSH
79309: LD_VAR 0 1
79313: PPUSH
79314: LD_VAR 0 2
79318: PPUSH
79319: CALL_OW 1
79323: ST_TO_ADDR
// end ;
79324: LD_VAR 0 3
79328: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79329: LD_INT 0
79331: PPUSH
// if not mc_bases or not base or not tech_list then
79332: LD_EXP 23
79336: NOT
79337: PUSH
79338: LD_VAR 0 1
79342: NOT
79343: OR
79344: PUSH
79345: LD_VAR 0 2
79349: NOT
79350: OR
79351: IFFALSE 79355
// exit ;
79353: GO 79380
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79355: LD_ADDR_EXP 50
79359: PUSH
79360: LD_EXP 50
79364: PPUSH
79365: LD_VAR 0 1
79369: PPUSH
79370: LD_VAR 0 2
79374: PPUSH
79375: CALL_OW 1
79379: ST_TO_ADDR
// end ;
79380: LD_VAR 0 3
79384: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79385: LD_INT 0
79387: PPUSH
// if not mc_bases or not parking_area or not base then
79388: LD_EXP 23
79392: NOT
79393: PUSH
79394: LD_VAR 0 2
79398: NOT
79399: OR
79400: PUSH
79401: LD_VAR 0 1
79405: NOT
79406: OR
79407: IFFALSE 79411
// exit ;
79409: GO 79436
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79411: LD_ADDR_EXP 47
79415: PUSH
79416: LD_EXP 47
79420: PPUSH
79421: LD_VAR 0 1
79425: PPUSH
79426: LD_VAR 0 2
79430: PPUSH
79431: CALL_OW 1
79435: ST_TO_ADDR
// end ;
79436: LD_VAR 0 3
79440: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79441: LD_INT 0
79443: PPUSH
// if not mc_bases or not base or not scan_area then
79444: LD_EXP 23
79448: NOT
79449: PUSH
79450: LD_VAR 0 1
79454: NOT
79455: OR
79456: PUSH
79457: LD_VAR 0 2
79461: NOT
79462: OR
79463: IFFALSE 79467
// exit ;
79465: GO 79492
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79467: LD_ADDR_EXP 48
79471: PUSH
79472: LD_EXP 48
79476: PPUSH
79477: LD_VAR 0 1
79481: PPUSH
79482: LD_VAR 0 2
79486: PPUSH
79487: CALL_OW 1
79491: ST_TO_ADDR
// end ;
79492: LD_VAR 0 3
79496: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79497: LD_INT 0
79499: PPUSH
79500: PPUSH
// if not mc_bases or not base then
79501: LD_EXP 23
79505: NOT
79506: PUSH
79507: LD_VAR 0 1
79511: NOT
79512: OR
79513: IFFALSE 79517
// exit ;
79515: GO 79581
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79517: LD_ADDR_VAR 0 3
79521: PUSH
79522: LD_INT 1
79524: PUSH
79525: LD_INT 2
79527: PUSH
79528: LD_INT 3
79530: PUSH
79531: LD_INT 4
79533: PUSH
79534: LD_INT 11
79536: PUSH
79537: EMPTY
79538: LIST
79539: LIST
79540: LIST
79541: LIST
79542: LIST
79543: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79544: LD_ADDR_EXP 50
79548: PUSH
79549: LD_EXP 50
79553: PPUSH
79554: LD_VAR 0 1
79558: PPUSH
79559: LD_EXP 50
79563: PUSH
79564: LD_VAR 0 1
79568: ARRAY
79569: PUSH
79570: LD_VAR 0 3
79574: DIFF
79575: PPUSH
79576: CALL_OW 1
79580: ST_TO_ADDR
// end ;
79581: LD_VAR 0 2
79585: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79586: LD_INT 0
79588: PPUSH
// result := mc_vehicles [ base ] ;
79589: LD_ADDR_VAR 0 3
79593: PUSH
79594: LD_EXP 42
79598: PUSH
79599: LD_VAR 0 1
79603: ARRAY
79604: ST_TO_ADDR
// if onlyCombat then
79605: LD_VAR 0 2
79609: IFFALSE 79781
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79611: LD_ADDR_VAR 0 3
79615: PUSH
79616: LD_VAR 0 3
79620: PUSH
79621: LD_VAR 0 3
79625: PPUSH
79626: LD_INT 2
79628: PUSH
79629: LD_INT 34
79631: PUSH
79632: LD_INT 12
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 34
79641: PUSH
79642: LD_INT 51
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 34
79651: PUSH
79652: LD_INT 89
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 34
79661: PUSH
79662: LD_INT 32
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: PUSH
79669: LD_INT 34
79671: PUSH
79672: LD_INT 13
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 34
79681: PUSH
79682: LD_INT 52
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 34
79691: PUSH
79692: LD_INT 88
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 34
79701: PUSH
79702: LD_INT 14
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 34
79711: PUSH
79712: LD_INT 53
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 34
79721: PUSH
79722: LD_INT 98
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 34
79731: PUSH
79732: LD_INT 31
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 34
79741: PUSH
79742: LD_INT 48
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 34
79751: PUSH
79752: LD_INT 8
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: LIST
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: LIST
79771: LIST
79772: LIST
79773: LIST
79774: PPUSH
79775: CALL_OW 72
79779: DIFF
79780: ST_TO_ADDR
// end ; end_of_file
79781: LD_VAR 0 3
79785: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79786: LD_INT 0
79788: PPUSH
79789: PPUSH
79790: PPUSH
// if not mc_bases or not skirmish then
79791: LD_EXP 23
79795: NOT
79796: PUSH
79797: LD_EXP 21
79801: NOT
79802: OR
79803: IFFALSE 79807
// exit ;
79805: GO 79972
// for i = 1 to mc_bases do
79807: LD_ADDR_VAR 0 4
79811: PUSH
79812: DOUBLE
79813: LD_INT 1
79815: DEC
79816: ST_TO_ADDR
79817: LD_EXP 23
79821: PUSH
79822: FOR_TO
79823: IFFALSE 79970
// begin if sci in mc_bases [ i ] then
79825: LD_VAR 0 2
79829: PUSH
79830: LD_EXP 23
79834: PUSH
79835: LD_VAR 0 4
79839: ARRAY
79840: IN
79841: IFFALSE 79968
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79843: LD_ADDR_EXP 52
79847: PUSH
79848: LD_EXP 52
79852: PPUSH
79853: LD_VAR 0 4
79857: PUSH
79858: LD_EXP 52
79862: PUSH
79863: LD_VAR 0 4
79867: ARRAY
79868: PUSH
79869: LD_INT 1
79871: PLUS
79872: PUSH
79873: EMPTY
79874: LIST
79875: LIST
79876: PPUSH
79877: LD_VAR 0 1
79881: PPUSH
79882: CALL 16077 0 3
79886: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79887: LD_ADDR_VAR 0 5
79891: PUSH
79892: LD_EXP 23
79896: PUSH
79897: LD_VAR 0 4
79901: ARRAY
79902: PPUSH
79903: LD_INT 2
79905: PUSH
79906: LD_INT 30
79908: PUSH
79909: LD_INT 0
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 30
79918: PUSH
79919: LD_INT 1
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: LIST
79930: PPUSH
79931: CALL_OW 72
79935: PPUSH
79936: LD_VAR 0 1
79940: PPUSH
79941: CALL_OW 74
79945: ST_TO_ADDR
// if tmp then
79946: LD_VAR 0 5
79950: IFFALSE 79966
// ComStandNearbyBuilding ( ape , tmp ) ;
79952: LD_VAR 0 1
79956: PPUSH
79957: LD_VAR 0 5
79961: PPUSH
79962: CALL 12679 0 2
// break ;
79966: GO 79970
// end ; end ;
79968: GO 79822
79970: POP
79971: POP
// end ;
79972: LD_VAR 0 3
79976: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79977: LD_INT 0
79979: PPUSH
79980: PPUSH
79981: PPUSH
// if not mc_bases or not skirmish then
79982: LD_EXP 23
79986: NOT
79987: PUSH
79988: LD_EXP 21
79992: NOT
79993: OR
79994: IFFALSE 79998
// exit ;
79996: GO 80087
// for i = 1 to mc_bases do
79998: LD_ADDR_VAR 0 4
80002: PUSH
80003: DOUBLE
80004: LD_INT 1
80006: DEC
80007: ST_TO_ADDR
80008: LD_EXP 23
80012: PUSH
80013: FOR_TO
80014: IFFALSE 80085
// begin if building in mc_busy_turret_list [ i ] then
80016: LD_VAR 0 1
80020: PUSH
80021: LD_EXP 33
80025: PUSH
80026: LD_VAR 0 4
80030: ARRAY
80031: IN
80032: IFFALSE 80083
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80034: LD_ADDR_VAR 0 5
80038: PUSH
80039: LD_EXP 33
80043: PUSH
80044: LD_VAR 0 4
80048: ARRAY
80049: PUSH
80050: LD_VAR 0 1
80054: DIFF
80055: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80056: LD_ADDR_EXP 33
80060: PUSH
80061: LD_EXP 33
80065: PPUSH
80066: LD_VAR 0 4
80070: PPUSH
80071: LD_VAR 0 5
80075: PPUSH
80076: CALL_OW 1
80080: ST_TO_ADDR
// break ;
80081: GO 80085
// end ; end ;
80083: GO 80013
80085: POP
80086: POP
// end ;
80087: LD_VAR 0 3
80091: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80092: LD_INT 0
80094: PPUSH
80095: PPUSH
80096: PPUSH
// if not mc_bases or not skirmish then
80097: LD_EXP 23
80101: NOT
80102: PUSH
80103: LD_EXP 21
80107: NOT
80108: OR
80109: IFFALSE 80113
// exit ;
80111: GO 80312
// for i = 1 to mc_bases do
80113: LD_ADDR_VAR 0 5
80117: PUSH
80118: DOUBLE
80119: LD_INT 1
80121: DEC
80122: ST_TO_ADDR
80123: LD_EXP 23
80127: PUSH
80128: FOR_TO
80129: IFFALSE 80310
// if building in mc_bases [ i ] then
80131: LD_VAR 0 1
80135: PUSH
80136: LD_EXP 23
80140: PUSH
80141: LD_VAR 0 5
80145: ARRAY
80146: IN
80147: IFFALSE 80308
// begin tmp := mc_bases [ i ] diff building ;
80149: LD_ADDR_VAR 0 6
80153: PUSH
80154: LD_EXP 23
80158: PUSH
80159: LD_VAR 0 5
80163: ARRAY
80164: PUSH
80165: LD_VAR 0 1
80169: DIFF
80170: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80171: LD_ADDR_EXP 23
80175: PUSH
80176: LD_EXP 23
80180: PPUSH
80181: LD_VAR 0 5
80185: PPUSH
80186: LD_VAR 0 6
80190: PPUSH
80191: CALL_OW 1
80195: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80196: LD_VAR 0 1
80200: PUSH
80201: LD_EXP 31
80205: PUSH
80206: LD_VAR 0 5
80210: ARRAY
80211: IN
80212: IFFALSE 80251
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80214: LD_ADDR_EXP 31
80218: PUSH
80219: LD_EXP 31
80223: PPUSH
80224: LD_VAR 0 5
80228: PPUSH
80229: LD_EXP 31
80233: PUSH
80234: LD_VAR 0 5
80238: ARRAY
80239: PUSH
80240: LD_VAR 0 1
80244: DIFF
80245: PPUSH
80246: CALL_OW 1
80250: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80251: LD_VAR 0 1
80255: PUSH
80256: LD_EXP 32
80260: PUSH
80261: LD_VAR 0 5
80265: ARRAY
80266: IN
80267: IFFALSE 80306
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80269: LD_ADDR_EXP 32
80273: PUSH
80274: LD_EXP 32
80278: PPUSH
80279: LD_VAR 0 5
80283: PPUSH
80284: LD_EXP 32
80288: PUSH
80289: LD_VAR 0 5
80293: ARRAY
80294: PUSH
80295: LD_VAR 0 1
80299: DIFF
80300: PPUSH
80301: CALL_OW 1
80305: ST_TO_ADDR
// break ;
80306: GO 80310
// end ;
80308: GO 80128
80310: POP
80311: POP
// end ;
80312: LD_VAR 0 4
80316: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80317: LD_INT 0
80319: PPUSH
80320: PPUSH
80321: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80322: LD_EXP 23
80326: NOT
80327: PUSH
80328: LD_EXP 21
80332: NOT
80333: OR
80334: PUSH
80335: LD_VAR 0 3
80339: PUSH
80340: LD_EXP 49
80344: IN
80345: NOT
80346: OR
80347: IFFALSE 80351
// exit ;
80349: GO 80474
// for i = 1 to mc_vehicles do
80351: LD_ADDR_VAR 0 6
80355: PUSH
80356: DOUBLE
80357: LD_INT 1
80359: DEC
80360: ST_TO_ADDR
80361: LD_EXP 42
80365: PUSH
80366: FOR_TO
80367: IFFALSE 80472
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80369: LD_VAR 0 2
80373: PUSH
80374: LD_EXP 42
80378: PUSH
80379: LD_VAR 0 6
80383: ARRAY
80384: IN
80385: PUSH
80386: LD_VAR 0 1
80390: PUSH
80391: LD_EXP 42
80395: PUSH
80396: LD_VAR 0 6
80400: ARRAY
80401: IN
80402: OR
80403: IFFALSE 80470
// begin tmp := mc_vehicles [ i ] diff old ;
80405: LD_ADDR_VAR 0 7
80409: PUSH
80410: LD_EXP 42
80414: PUSH
80415: LD_VAR 0 6
80419: ARRAY
80420: PUSH
80421: LD_VAR 0 2
80425: DIFF
80426: ST_TO_ADDR
// tmp := tmp diff new ;
80427: LD_ADDR_VAR 0 7
80431: PUSH
80432: LD_VAR 0 7
80436: PUSH
80437: LD_VAR 0 1
80441: DIFF
80442: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80443: LD_ADDR_EXP 42
80447: PUSH
80448: LD_EXP 42
80452: PPUSH
80453: LD_VAR 0 6
80457: PPUSH
80458: LD_VAR 0 7
80462: PPUSH
80463: CALL_OW 1
80467: ST_TO_ADDR
// break ;
80468: GO 80472
// end ;
80470: GO 80366
80472: POP
80473: POP
// end ;
80474: LD_VAR 0 5
80478: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80479: LD_INT 0
80481: PPUSH
80482: PPUSH
80483: PPUSH
80484: PPUSH
// if not mc_bases or not skirmish then
80485: LD_EXP 23
80489: NOT
80490: PUSH
80491: LD_EXP 21
80495: NOT
80496: OR
80497: IFFALSE 80501
// exit ;
80499: GO 80921
// repeat wait ( 0 0$1 ) ;
80501: LD_INT 35
80503: PPUSH
80504: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
80508: LD_EXP 67
80512: NOT
80513: IFFALSE 80501
// mc_block_vehicle_constructed_thread := true ;
80515: LD_ADDR_EXP 67
80519: PUSH
80520: LD_INT 1
80522: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
80523: LD_ADDR_VAR 0 5
80527: PUSH
80528: LD_VAR 0 1
80532: PPUSH
80533: CALL_OW 255
80537: ST_TO_ADDR
// for i = 1 to mc_bases do
80538: LD_ADDR_VAR 0 4
80542: PUSH
80543: DOUBLE
80544: LD_INT 1
80546: DEC
80547: ST_TO_ADDR
80548: LD_EXP 23
80552: PUSH
80553: FOR_TO
80554: IFFALSE 80911
// begin if factory in mc_bases [ i ] then
80556: LD_VAR 0 2
80560: PUSH
80561: LD_EXP 23
80565: PUSH
80566: LD_VAR 0 4
80570: ARRAY
80571: IN
80572: IFFALSE 80909
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
80574: LD_EXP 45
80578: PUSH
80579: LD_VAR 0 4
80583: ARRAY
80584: PUSH
80585: LD_EXP 34
80589: PUSH
80590: LD_VAR 0 4
80594: ARRAY
80595: LESS
80596: PUSH
80597: LD_VAR 0 1
80601: PPUSH
80602: CALL_OW 264
80606: PUSH
80607: LD_INT 31
80609: PUSH
80610: LD_INT 32
80612: PUSH
80613: LD_INT 51
80615: PUSH
80616: LD_INT 89
80618: PUSH
80619: LD_INT 12
80621: PUSH
80622: LD_INT 30
80624: PUSH
80625: LD_INT 98
80627: PUSH
80628: LD_INT 11
80630: PUSH
80631: LD_INT 53
80633: PUSH
80634: LD_INT 14
80636: PUSH
80637: LD_INT 91
80639: PUSH
80640: LD_INT 29
80642: PUSH
80643: LD_INT 99
80645: PUSH
80646: LD_INT 13
80648: PUSH
80649: LD_INT 52
80651: PUSH
80652: LD_INT 88
80654: PUSH
80655: LD_INT 48
80657: PUSH
80658: LD_INT 8
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: LIST
80665: LIST
80666: LIST
80667: LIST
80668: LIST
80669: LIST
80670: LIST
80671: LIST
80672: LIST
80673: LIST
80674: LIST
80675: LIST
80676: LIST
80677: LIST
80678: LIST
80679: LIST
80680: IN
80681: NOT
80682: AND
80683: IFFALSE 80731
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80685: LD_ADDR_EXP 45
80689: PUSH
80690: LD_EXP 45
80694: PPUSH
80695: LD_VAR 0 4
80699: PUSH
80700: LD_EXP 45
80704: PUSH
80705: LD_VAR 0 4
80709: ARRAY
80710: PUSH
80711: LD_INT 1
80713: PLUS
80714: PUSH
80715: EMPTY
80716: LIST
80717: LIST
80718: PPUSH
80719: LD_VAR 0 1
80723: PPUSH
80724: CALL 16077 0 3
80728: ST_TO_ADDR
80729: GO 80775
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80731: LD_ADDR_EXP 42
80735: PUSH
80736: LD_EXP 42
80740: PPUSH
80741: LD_VAR 0 4
80745: PUSH
80746: LD_EXP 42
80750: PUSH
80751: LD_VAR 0 4
80755: ARRAY
80756: PUSH
80757: LD_INT 1
80759: PLUS
80760: PUSH
80761: EMPTY
80762: LIST
80763: LIST
80764: PPUSH
80765: LD_VAR 0 1
80769: PPUSH
80770: CALL 16077 0 3
80774: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
80775: LD_ADDR_EXP 67
80779: PUSH
80780: LD_INT 0
80782: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
80783: LD_VAR 0 1
80787: PPUSH
80788: CALL_OW 263
80792: PUSH
80793: LD_INT 2
80795: EQUAL
80796: IFFALSE 80825
// begin repeat wait ( 0 0$3 ) ;
80798: LD_INT 105
80800: PPUSH
80801: CALL_OW 67
// Connect ( vehicle ) ;
80805: LD_VAR 0 1
80809: PPUSH
80810: CALL 19423 0 1
// until IsControledBy ( vehicle ) ;
80814: LD_VAR 0 1
80818: PPUSH
80819: CALL_OW 312
80823: IFFALSE 80798
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80825: LD_VAR 0 1
80829: PPUSH
80830: LD_EXP 47
80834: PUSH
80835: LD_VAR 0 4
80839: ARRAY
80840: PPUSH
80841: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80845: LD_VAR 0 1
80849: PPUSH
80850: CALL_OW 263
80854: PUSH
80855: LD_INT 1
80857: NONEQUAL
80858: IFFALSE 80862
// break ;
80860: GO 80911
// repeat wait ( 0 0$1 ) ;
80862: LD_INT 35
80864: PPUSH
80865: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80869: LD_VAR 0 1
80873: PPUSH
80874: LD_EXP 47
80878: PUSH
80879: LD_VAR 0 4
80883: ARRAY
80884: PPUSH
80885: CALL_OW 308
80889: IFFALSE 80862
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80891: LD_VAR 0 1
80895: PPUSH
80896: CALL_OW 311
80900: PPUSH
80901: CALL_OW 121
// exit ;
80905: POP
80906: POP
80907: GO 80921
// end ; end ;
80909: GO 80553
80911: POP
80912: POP
// mc_block_vehicle_constructed_thread := false ;
80913: LD_ADDR_EXP 67
80917: PUSH
80918: LD_INT 0
80920: ST_TO_ADDR
// end ;
80921: LD_VAR 0 3
80925: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80926: LD_INT 0
80928: PPUSH
80929: PPUSH
80930: PPUSH
80931: PPUSH
// if not mc_bases or not skirmish then
80932: LD_EXP 23
80936: NOT
80937: PUSH
80938: LD_EXP 21
80942: NOT
80943: OR
80944: IFFALSE 80948
// exit ;
80946: GO 81301
// repeat wait ( 0 0$1 ) ;
80948: LD_INT 35
80950: PPUSH
80951: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80955: LD_VAR 0 2
80959: PPUSH
80960: LD_VAR 0 3
80964: PPUSH
80965: CALL_OW 284
80969: IFFALSE 80948
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80971: LD_VAR 0 2
80975: PPUSH
80976: LD_VAR 0 3
80980: PPUSH
80981: CALL_OW 283
80985: PUSH
80986: LD_INT 4
80988: EQUAL
80989: IFFALSE 80993
// exit ;
80991: GO 81301
// for i = 1 to mc_bases do
80993: LD_ADDR_VAR 0 7
80997: PUSH
80998: DOUBLE
80999: LD_INT 1
81001: DEC
81002: ST_TO_ADDR
81003: LD_EXP 23
81007: PUSH
81008: FOR_TO
81009: IFFALSE 81299
// begin if mc_crates_area [ i ] then
81011: LD_EXP 41
81015: PUSH
81016: LD_VAR 0 7
81020: ARRAY
81021: IFFALSE 81132
// for j in mc_crates_area [ i ] do
81023: LD_ADDR_VAR 0 8
81027: PUSH
81028: LD_EXP 41
81032: PUSH
81033: LD_VAR 0 7
81037: ARRAY
81038: PUSH
81039: FOR_IN
81040: IFFALSE 81130
// if InArea ( x , y , j ) then
81042: LD_VAR 0 2
81046: PPUSH
81047: LD_VAR 0 3
81051: PPUSH
81052: LD_VAR 0 8
81056: PPUSH
81057: CALL_OW 309
81061: IFFALSE 81128
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81063: LD_ADDR_EXP 39
81067: PUSH
81068: LD_EXP 39
81072: PPUSH
81073: LD_VAR 0 7
81077: PUSH
81078: LD_EXP 39
81082: PUSH
81083: LD_VAR 0 7
81087: ARRAY
81088: PUSH
81089: LD_INT 1
81091: PLUS
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PPUSH
81097: LD_VAR 0 4
81101: PUSH
81102: LD_VAR 0 2
81106: PUSH
81107: LD_VAR 0 3
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: LIST
81116: PPUSH
81117: CALL 16077 0 3
81121: ST_TO_ADDR
// exit ;
81122: POP
81123: POP
81124: POP
81125: POP
81126: GO 81301
// end ;
81128: GO 81039
81130: POP
81131: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81132: LD_ADDR_VAR 0 9
81136: PUSH
81137: LD_EXP 23
81141: PUSH
81142: LD_VAR 0 7
81146: ARRAY
81147: PPUSH
81148: LD_INT 2
81150: PUSH
81151: LD_INT 30
81153: PUSH
81154: LD_INT 0
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 30
81163: PUSH
81164: LD_INT 1
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: LIST
81175: PPUSH
81176: CALL_OW 72
81180: ST_TO_ADDR
// if not depot then
81181: LD_VAR 0 9
81185: NOT
81186: IFFALSE 81190
// continue ;
81188: GO 81008
// for j in depot do
81190: LD_ADDR_VAR 0 8
81194: PUSH
81195: LD_VAR 0 9
81199: PUSH
81200: FOR_IN
81201: IFFALSE 81295
// if GetDistUnitXY ( j , x , y ) < 30 then
81203: LD_VAR 0 8
81207: PPUSH
81208: LD_VAR 0 2
81212: PPUSH
81213: LD_VAR 0 3
81217: PPUSH
81218: CALL_OW 297
81222: PUSH
81223: LD_INT 30
81225: LESS
81226: IFFALSE 81293
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81228: LD_ADDR_EXP 39
81232: PUSH
81233: LD_EXP 39
81237: PPUSH
81238: LD_VAR 0 7
81242: PUSH
81243: LD_EXP 39
81247: PUSH
81248: LD_VAR 0 7
81252: ARRAY
81253: PUSH
81254: LD_INT 1
81256: PLUS
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PPUSH
81262: LD_VAR 0 4
81266: PUSH
81267: LD_VAR 0 2
81271: PUSH
81272: LD_VAR 0 3
81276: PUSH
81277: EMPTY
81278: LIST
81279: LIST
81280: LIST
81281: PPUSH
81282: CALL 16077 0 3
81286: ST_TO_ADDR
// exit ;
81287: POP
81288: POP
81289: POP
81290: POP
81291: GO 81301
// end ;
81293: GO 81200
81295: POP
81296: POP
// end ;
81297: GO 81008
81299: POP
81300: POP
// end ;
81301: LD_VAR 0 6
81305: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81306: LD_INT 0
81308: PPUSH
81309: PPUSH
81310: PPUSH
81311: PPUSH
// if not mc_bases or not skirmish then
81312: LD_EXP 23
81316: NOT
81317: PUSH
81318: LD_EXP 21
81322: NOT
81323: OR
81324: IFFALSE 81328
// exit ;
81326: GO 81605
// side := GetSide ( lab ) ;
81328: LD_ADDR_VAR 0 4
81332: PUSH
81333: LD_VAR 0 2
81337: PPUSH
81338: CALL_OW 255
81342: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81343: LD_VAR 0 4
81347: PUSH
81348: LD_EXP 49
81352: IN
81353: NOT
81354: PUSH
81355: LD_EXP 50
81359: NOT
81360: OR
81361: PUSH
81362: LD_EXP 23
81366: NOT
81367: OR
81368: IFFALSE 81372
// exit ;
81370: GO 81605
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81372: LD_ADDR_EXP 50
81376: PUSH
81377: LD_EXP 50
81381: PPUSH
81382: LD_VAR 0 4
81386: PPUSH
81387: LD_EXP 50
81391: PUSH
81392: LD_VAR 0 4
81396: ARRAY
81397: PUSH
81398: LD_VAR 0 1
81402: DIFF
81403: PPUSH
81404: CALL_OW 1
81408: ST_TO_ADDR
// for i = 1 to mc_bases do
81409: LD_ADDR_VAR 0 5
81413: PUSH
81414: DOUBLE
81415: LD_INT 1
81417: DEC
81418: ST_TO_ADDR
81419: LD_EXP 23
81423: PUSH
81424: FOR_TO
81425: IFFALSE 81603
// begin if lab in mc_bases [ i ] then
81427: LD_VAR 0 2
81431: PUSH
81432: LD_EXP 23
81436: PUSH
81437: LD_VAR 0 5
81441: ARRAY
81442: IN
81443: IFFALSE 81601
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81445: LD_VAR 0 1
81449: PUSH
81450: LD_INT 11
81452: PUSH
81453: LD_INT 4
81455: PUSH
81456: LD_INT 3
81458: PUSH
81459: LD_INT 2
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: LIST
81466: LIST
81467: IN
81468: PUSH
81469: LD_EXP 53
81473: PUSH
81474: LD_VAR 0 5
81478: ARRAY
81479: AND
81480: IFFALSE 81601
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81482: LD_ADDR_VAR 0 6
81486: PUSH
81487: LD_EXP 53
81491: PUSH
81492: LD_VAR 0 5
81496: ARRAY
81497: PUSH
81498: LD_INT 1
81500: ARRAY
81501: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81502: LD_ADDR_EXP 53
81506: PUSH
81507: LD_EXP 53
81511: PPUSH
81512: LD_VAR 0 5
81516: PPUSH
81517: EMPTY
81518: PPUSH
81519: CALL_OW 1
81523: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81524: LD_VAR 0 6
81528: PPUSH
81529: LD_INT 0
81531: PPUSH
81532: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81536: LD_VAR 0 6
81540: PPUSH
81541: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81545: LD_ADDR_EXP 52
81549: PUSH
81550: LD_EXP 52
81554: PPUSH
81555: LD_VAR 0 5
81559: PPUSH
81560: LD_EXP 52
81564: PUSH
81565: LD_VAR 0 5
81569: ARRAY
81570: PPUSH
81571: LD_INT 1
81573: PPUSH
81574: LD_VAR 0 6
81578: PPUSH
81579: CALL_OW 2
81583: PPUSH
81584: CALL_OW 1
81588: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81589: LD_VAR 0 5
81593: PPUSH
81594: LD_INT 112
81596: PPUSH
81597: CALL 58055 0 2
// end ; end ; end ;
81601: GO 81424
81603: POP
81604: POP
// end ;
81605: LD_VAR 0 3
81609: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81610: LD_INT 0
81612: PPUSH
81613: PPUSH
81614: PPUSH
81615: PPUSH
81616: PPUSH
81617: PPUSH
81618: PPUSH
81619: PPUSH
// if not mc_bases or not skirmish then
81620: LD_EXP 23
81624: NOT
81625: PUSH
81626: LD_EXP 21
81630: NOT
81631: OR
81632: IFFALSE 81636
// exit ;
81634: GO 83005
// for i = 1 to mc_bases do
81636: LD_ADDR_VAR 0 3
81640: PUSH
81641: DOUBLE
81642: LD_INT 1
81644: DEC
81645: ST_TO_ADDR
81646: LD_EXP 23
81650: PUSH
81651: FOR_TO
81652: IFFALSE 83003
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81654: LD_VAR 0 1
81658: PUSH
81659: LD_EXP 23
81663: PUSH
81664: LD_VAR 0 3
81668: ARRAY
81669: IN
81670: PUSH
81671: LD_VAR 0 1
81675: PUSH
81676: LD_EXP 30
81680: PUSH
81681: LD_VAR 0 3
81685: ARRAY
81686: IN
81687: OR
81688: PUSH
81689: LD_VAR 0 1
81693: PUSH
81694: LD_EXP 45
81698: PUSH
81699: LD_VAR 0 3
81703: ARRAY
81704: IN
81705: OR
81706: PUSH
81707: LD_VAR 0 1
81711: PUSH
81712: LD_EXP 42
81716: PUSH
81717: LD_VAR 0 3
81721: ARRAY
81722: IN
81723: OR
81724: PUSH
81725: LD_VAR 0 1
81729: PUSH
81730: LD_EXP 52
81734: PUSH
81735: LD_VAR 0 3
81739: ARRAY
81740: IN
81741: OR
81742: PUSH
81743: LD_VAR 0 1
81747: PUSH
81748: LD_EXP 53
81752: PUSH
81753: LD_VAR 0 3
81757: ARRAY
81758: IN
81759: OR
81760: IFFALSE 83001
// begin if un in mc_ape [ i ] then
81762: LD_VAR 0 1
81766: PUSH
81767: LD_EXP 52
81771: PUSH
81772: LD_VAR 0 3
81776: ARRAY
81777: IN
81778: IFFALSE 81817
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81780: LD_ADDR_EXP 52
81784: PUSH
81785: LD_EXP 52
81789: PPUSH
81790: LD_VAR 0 3
81794: PPUSH
81795: LD_EXP 52
81799: PUSH
81800: LD_VAR 0 3
81804: ARRAY
81805: PUSH
81806: LD_VAR 0 1
81810: DIFF
81811: PPUSH
81812: CALL_OW 1
81816: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81817: LD_VAR 0 1
81821: PUSH
81822: LD_EXP 53
81826: PUSH
81827: LD_VAR 0 3
81831: ARRAY
81832: IN
81833: IFFALSE 81857
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81835: LD_ADDR_EXP 53
81839: PUSH
81840: LD_EXP 53
81844: PPUSH
81845: LD_VAR 0 3
81849: PPUSH
81850: EMPTY
81851: PPUSH
81852: CALL_OW 1
81856: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
81857: LD_VAR 0 1
81861: PPUSH
81862: CALL_OW 247
81866: PUSH
81867: LD_INT 2
81869: EQUAL
81870: PUSH
81871: LD_VAR 0 1
81875: PPUSH
81876: CALL_OW 110
81880: PUSH
81881: LD_INT 20
81883: EQUAL
81884: PUSH
81885: LD_VAR 0 1
81889: PUSH
81890: LD_EXP 45
81894: PUSH
81895: LD_VAR 0 3
81899: ARRAY
81900: IN
81901: OR
81902: PUSH
81903: LD_VAR 0 1
81907: PPUSH
81908: CALL_OW 264
81912: PUSH
81913: LD_INT 12
81915: PUSH
81916: LD_INT 51
81918: PUSH
81919: LD_INT 89
81921: PUSH
81922: LD_INT 32
81924: PUSH
81925: LD_INT 13
81927: PUSH
81928: LD_INT 52
81930: PUSH
81931: LD_INT 31
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: IN
81943: OR
81944: AND
81945: IFFALSE 82253
// begin if un in mc_defender [ i ] then
81947: LD_VAR 0 1
81951: PUSH
81952: LD_EXP 45
81956: PUSH
81957: LD_VAR 0 3
81961: ARRAY
81962: IN
81963: IFFALSE 82002
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81965: LD_ADDR_EXP 45
81969: PUSH
81970: LD_EXP 45
81974: PPUSH
81975: LD_VAR 0 3
81979: PPUSH
81980: LD_EXP 45
81984: PUSH
81985: LD_VAR 0 3
81989: ARRAY
81990: PUSH
81991: LD_VAR 0 1
81995: DIFF
81996: PPUSH
81997: CALL_OW 1
82001: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
82002: LD_ADDR_VAR 0 8
82006: PUSH
82007: LD_VAR 0 3
82011: PPUSH
82012: LD_INT 3
82014: PPUSH
82015: CALL 78623 0 2
82019: ST_TO_ADDR
// if fac then
82020: LD_VAR 0 8
82024: IFFALSE 82253
// begin for j in fac do
82026: LD_ADDR_VAR 0 4
82030: PUSH
82031: LD_VAR 0 8
82035: PUSH
82036: FOR_IN
82037: IFFALSE 82251
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82039: LD_ADDR_VAR 0 9
82043: PUSH
82044: LD_VAR 0 8
82048: PPUSH
82049: LD_VAR 0 1
82053: PPUSH
82054: CALL_OW 265
82058: PPUSH
82059: LD_VAR 0 1
82063: PPUSH
82064: CALL_OW 262
82068: PPUSH
82069: LD_VAR 0 1
82073: PPUSH
82074: CALL_OW 263
82078: PPUSH
82079: LD_VAR 0 1
82083: PPUSH
82084: CALL_OW 264
82088: PPUSH
82089: CALL 13575 0 5
82093: ST_TO_ADDR
// if components then
82094: LD_VAR 0 9
82098: IFFALSE 82249
// begin if GetWeapon ( un ) = ar_control_tower then
82100: LD_VAR 0 1
82104: PPUSH
82105: CALL_OW 264
82109: PUSH
82110: LD_INT 31
82112: EQUAL
82113: IFFALSE 82230
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
82115: LD_VAR 0 1
82119: PPUSH
82120: CALL_OW 311
82124: PPUSH
82125: LD_INT 0
82127: PPUSH
82128: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
82132: LD_ADDR_EXP 63
82136: PUSH
82137: LD_EXP 63
82141: PPUSH
82142: LD_VAR 0 3
82146: PPUSH
82147: LD_EXP 63
82151: PUSH
82152: LD_VAR 0 3
82156: ARRAY
82157: PUSH
82158: LD_VAR 0 1
82162: PPUSH
82163: CALL_OW 311
82167: DIFF
82168: PPUSH
82169: CALL_OW 1
82173: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
82174: LD_ADDR_VAR 0 7
82178: PUSH
82179: LD_EXP 44
82183: PUSH
82184: LD_VAR 0 3
82188: ARRAY
82189: PPUSH
82190: LD_INT 1
82192: PPUSH
82193: LD_VAR 0 9
82197: PPUSH
82198: CALL_OW 2
82202: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
82203: LD_ADDR_EXP 44
82207: PUSH
82208: LD_EXP 44
82212: PPUSH
82213: LD_VAR 0 3
82217: PPUSH
82218: LD_VAR 0 7
82222: PPUSH
82223: CALL_OW 1
82227: ST_TO_ADDR
// end else
82228: GO 82247
// MC_InsertProduceList ( i , [ components ] ) ;
82230: LD_VAR 0 3
82234: PPUSH
82235: LD_VAR 0 9
82239: PUSH
82240: EMPTY
82241: LIST
82242: PPUSH
82243: CALL 78168 0 2
// break ;
82247: GO 82251
// end ; end ;
82249: GO 82036
82251: POP
82252: POP
// end ; end ; if GetType ( un ) = unit_building then
82253: LD_VAR 0 1
82257: PPUSH
82258: CALL_OW 247
82262: PUSH
82263: LD_INT 3
82265: EQUAL
82266: IFFALSE 82669
// begin btype := GetBType ( un ) ;
82268: LD_ADDR_VAR 0 5
82272: PUSH
82273: LD_VAR 0 1
82277: PPUSH
82278: CALL_OW 266
82282: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
82283: LD_VAR 0 5
82287: PUSH
82288: LD_INT 29
82290: PUSH
82291: LD_INT 30
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: IN
82298: IFFALSE 82371
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
82300: LD_VAR 0 1
82304: PPUSH
82305: CALL_OW 250
82309: PPUSH
82310: LD_VAR 0 1
82314: PPUSH
82315: CALL_OW 251
82319: PPUSH
82320: LD_VAR 0 1
82324: PPUSH
82325: CALL_OW 255
82329: PPUSH
82330: CALL_OW 440
82334: NOT
82335: IFFALSE 82371
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
82337: LD_VAR 0 1
82341: PPUSH
82342: CALL_OW 250
82346: PPUSH
82347: LD_VAR 0 1
82351: PPUSH
82352: CALL_OW 251
82356: PPUSH
82357: LD_VAR 0 1
82361: PPUSH
82362: CALL_OW 255
82366: PPUSH
82367: CALL_OW 441
// end ; if btype = b_warehouse then
82371: LD_VAR 0 5
82375: PUSH
82376: LD_INT 1
82378: EQUAL
82379: IFFALSE 82397
// begin btype := b_depot ;
82381: LD_ADDR_VAR 0 5
82385: PUSH
82386: LD_INT 0
82388: ST_TO_ADDR
// pos := 1 ;
82389: LD_ADDR_VAR 0 6
82393: PUSH
82394: LD_INT 1
82396: ST_TO_ADDR
// end ; if btype = b_factory then
82397: LD_VAR 0 5
82401: PUSH
82402: LD_INT 3
82404: EQUAL
82405: IFFALSE 82423
// begin btype := b_workshop ;
82407: LD_ADDR_VAR 0 5
82411: PUSH
82412: LD_INT 2
82414: ST_TO_ADDR
// pos := 1 ;
82415: LD_ADDR_VAR 0 6
82419: PUSH
82420: LD_INT 1
82422: ST_TO_ADDR
// end ; if btype = b_barracks then
82423: LD_VAR 0 5
82427: PUSH
82428: LD_INT 5
82430: EQUAL
82431: IFFALSE 82441
// btype := b_armoury ;
82433: LD_ADDR_VAR 0 5
82437: PUSH
82438: LD_INT 4
82440: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82441: LD_VAR 0 5
82445: PUSH
82446: LD_INT 7
82448: PUSH
82449: LD_INT 8
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: IN
82456: IFFALSE 82466
// btype := b_lab ;
82458: LD_ADDR_VAR 0 5
82462: PUSH
82463: LD_INT 6
82465: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82466: LD_ADDR_EXP 28
82470: PUSH
82471: LD_EXP 28
82475: PPUSH
82476: LD_VAR 0 3
82480: PUSH
82481: LD_EXP 28
82485: PUSH
82486: LD_VAR 0 3
82490: ARRAY
82491: PUSH
82492: LD_INT 1
82494: PLUS
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: PPUSH
82500: LD_VAR 0 5
82504: PUSH
82505: LD_VAR 0 1
82509: PPUSH
82510: CALL_OW 250
82514: PUSH
82515: LD_VAR 0 1
82519: PPUSH
82520: CALL_OW 251
82524: PUSH
82525: LD_VAR 0 1
82529: PPUSH
82530: CALL_OW 254
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: LIST
82539: LIST
82540: PPUSH
82541: CALL 16077 0 3
82545: ST_TO_ADDR
// if pos = 1 then
82546: LD_VAR 0 6
82550: PUSH
82551: LD_INT 1
82553: EQUAL
82554: IFFALSE 82669
// begin tmp := mc_build_list [ i ] ;
82556: LD_ADDR_VAR 0 7
82560: PUSH
82561: LD_EXP 28
82565: PUSH
82566: LD_VAR 0 3
82570: ARRAY
82571: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82572: LD_VAR 0 7
82576: PPUSH
82577: LD_INT 2
82579: PUSH
82580: LD_INT 30
82582: PUSH
82583: LD_INT 0
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: PUSH
82590: LD_INT 30
82592: PUSH
82593: LD_INT 1
82595: PUSH
82596: EMPTY
82597: LIST
82598: LIST
82599: PUSH
82600: EMPTY
82601: LIST
82602: LIST
82603: LIST
82604: PPUSH
82605: CALL_OW 72
82609: IFFALSE 82619
// pos := 2 ;
82611: LD_ADDR_VAR 0 6
82615: PUSH
82616: LD_INT 2
82618: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82619: LD_ADDR_VAR 0 7
82623: PUSH
82624: LD_VAR 0 7
82628: PPUSH
82629: LD_VAR 0 6
82633: PPUSH
82634: LD_VAR 0 7
82638: PPUSH
82639: CALL 16403 0 3
82643: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82644: LD_ADDR_EXP 28
82648: PUSH
82649: LD_EXP 28
82653: PPUSH
82654: LD_VAR 0 3
82658: PPUSH
82659: LD_VAR 0 7
82663: PPUSH
82664: CALL_OW 1
82668: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82669: LD_VAR 0 1
82673: PUSH
82674: LD_EXP 23
82678: PUSH
82679: LD_VAR 0 3
82683: ARRAY
82684: IN
82685: IFFALSE 82724
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82687: LD_ADDR_EXP 23
82691: PUSH
82692: LD_EXP 23
82696: PPUSH
82697: LD_VAR 0 3
82701: PPUSH
82702: LD_EXP 23
82706: PUSH
82707: LD_VAR 0 3
82711: ARRAY
82712: PUSH
82713: LD_VAR 0 1
82717: DIFF
82718: PPUSH
82719: CALL_OW 1
82723: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82724: LD_VAR 0 1
82728: PUSH
82729: LD_EXP 30
82733: PUSH
82734: LD_VAR 0 3
82738: ARRAY
82739: IN
82740: IFFALSE 82779
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82742: LD_ADDR_EXP 30
82746: PUSH
82747: LD_EXP 30
82751: PPUSH
82752: LD_VAR 0 3
82756: PPUSH
82757: LD_EXP 30
82761: PUSH
82762: LD_VAR 0 3
82766: ARRAY
82767: PUSH
82768: LD_VAR 0 1
82772: DIFF
82773: PPUSH
82774: CALL_OW 1
82778: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82779: LD_VAR 0 1
82783: PUSH
82784: LD_EXP 42
82788: PUSH
82789: LD_VAR 0 3
82793: ARRAY
82794: IN
82795: IFFALSE 82834
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82797: LD_ADDR_EXP 42
82801: PUSH
82802: LD_EXP 42
82806: PPUSH
82807: LD_VAR 0 3
82811: PPUSH
82812: LD_EXP 42
82816: PUSH
82817: LD_VAR 0 3
82821: ARRAY
82822: PUSH
82823: LD_VAR 0 1
82827: DIFF
82828: PPUSH
82829: CALL_OW 1
82833: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82834: LD_VAR 0 1
82838: PUSH
82839: LD_EXP 45
82843: PUSH
82844: LD_VAR 0 3
82848: ARRAY
82849: IN
82850: IFFALSE 82889
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82852: LD_ADDR_EXP 45
82856: PUSH
82857: LD_EXP 45
82861: PPUSH
82862: LD_VAR 0 3
82866: PPUSH
82867: LD_EXP 45
82871: PUSH
82872: LD_VAR 0 3
82876: ARRAY
82877: PUSH
82878: LD_VAR 0 1
82882: DIFF
82883: PPUSH
82884: CALL_OW 1
82888: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82889: LD_VAR 0 1
82893: PUSH
82894: LD_EXP 32
82898: PUSH
82899: LD_VAR 0 3
82903: ARRAY
82904: IN
82905: IFFALSE 82944
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82907: LD_ADDR_EXP 32
82911: PUSH
82912: LD_EXP 32
82916: PPUSH
82917: LD_VAR 0 3
82921: PPUSH
82922: LD_EXP 32
82926: PUSH
82927: LD_VAR 0 3
82931: ARRAY
82932: PUSH
82933: LD_VAR 0 1
82937: DIFF
82938: PPUSH
82939: CALL_OW 1
82943: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82944: LD_VAR 0 1
82948: PUSH
82949: LD_EXP 31
82953: PUSH
82954: LD_VAR 0 3
82958: ARRAY
82959: IN
82960: IFFALSE 82999
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82962: LD_ADDR_EXP 31
82966: PUSH
82967: LD_EXP 31
82971: PPUSH
82972: LD_VAR 0 3
82976: PPUSH
82977: LD_EXP 31
82981: PUSH
82982: LD_VAR 0 3
82986: ARRAY
82987: PUSH
82988: LD_VAR 0 1
82992: DIFF
82993: PPUSH
82994: CALL_OW 1
82998: ST_TO_ADDR
// end ; break ;
82999: GO 83003
// end ;
83001: GO 81651
83003: POP
83004: POP
// end ;
83005: LD_VAR 0 2
83009: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
83010: LD_INT 0
83012: PPUSH
83013: PPUSH
83014: PPUSH
// if not mc_bases or not skirmish then
83015: LD_EXP 23
83019: NOT
83020: PUSH
83021: LD_EXP 21
83025: NOT
83026: OR
83027: IFFALSE 83031
// exit ;
83029: GO 83246
// for i = 1 to mc_bases do
83031: LD_ADDR_VAR 0 3
83035: PUSH
83036: DOUBLE
83037: LD_INT 1
83039: DEC
83040: ST_TO_ADDR
83041: LD_EXP 23
83045: PUSH
83046: FOR_TO
83047: IFFALSE 83244
// begin if building in mc_construct_list [ i ] then
83049: LD_VAR 0 1
83053: PUSH
83054: LD_EXP 30
83058: PUSH
83059: LD_VAR 0 3
83063: ARRAY
83064: IN
83065: IFFALSE 83242
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83067: LD_ADDR_EXP 30
83071: PUSH
83072: LD_EXP 30
83076: PPUSH
83077: LD_VAR 0 3
83081: PPUSH
83082: LD_EXP 30
83086: PUSH
83087: LD_VAR 0 3
83091: ARRAY
83092: PUSH
83093: LD_VAR 0 1
83097: DIFF
83098: PPUSH
83099: CALL_OW 1
83103: ST_TO_ADDR
// if building in mc_lab [ i ] then
83104: LD_VAR 0 1
83108: PUSH
83109: LD_EXP 56
83113: PUSH
83114: LD_VAR 0 3
83118: ARRAY
83119: IN
83120: IFFALSE 83175
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83122: LD_ADDR_EXP 57
83126: PUSH
83127: LD_EXP 57
83131: PPUSH
83132: LD_VAR 0 3
83136: PPUSH
83137: LD_EXP 57
83141: PUSH
83142: LD_VAR 0 3
83146: ARRAY
83147: PPUSH
83148: LD_INT 1
83150: PPUSH
83151: LD_EXP 57
83155: PUSH
83156: LD_VAR 0 3
83160: ARRAY
83161: PPUSH
83162: LD_INT 0
83164: PPUSH
83165: CALL 15495 0 4
83169: PPUSH
83170: CALL_OW 1
83174: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83175: LD_VAR 0 1
83179: PUSH
83180: LD_EXP 23
83184: PUSH
83185: LD_VAR 0 3
83189: ARRAY
83190: IN
83191: NOT
83192: IFFALSE 83238
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83194: LD_ADDR_EXP 23
83198: PUSH
83199: LD_EXP 23
83203: PPUSH
83204: LD_VAR 0 3
83208: PUSH
83209: LD_EXP 23
83213: PUSH
83214: LD_VAR 0 3
83218: ARRAY
83219: PUSH
83220: LD_INT 1
83222: PLUS
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PPUSH
83228: LD_VAR 0 1
83232: PPUSH
83233: CALL 16077 0 3
83237: ST_TO_ADDR
// exit ;
83238: POP
83239: POP
83240: GO 83246
// end ; end ;
83242: GO 83046
83244: POP
83245: POP
// end ;
83246: LD_VAR 0 2
83250: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83251: LD_INT 0
83253: PPUSH
83254: PPUSH
83255: PPUSH
83256: PPUSH
83257: PPUSH
83258: PPUSH
83259: PPUSH
// if not mc_bases or not skirmish then
83260: LD_EXP 23
83264: NOT
83265: PUSH
83266: LD_EXP 21
83270: NOT
83271: OR
83272: IFFALSE 83276
// exit ;
83274: GO 83937
// for i = 1 to mc_bases do
83276: LD_ADDR_VAR 0 3
83280: PUSH
83281: DOUBLE
83282: LD_INT 1
83284: DEC
83285: ST_TO_ADDR
83286: LD_EXP 23
83290: PUSH
83291: FOR_TO
83292: IFFALSE 83935
// begin if building in mc_construct_list [ i ] then
83294: LD_VAR 0 1
83298: PUSH
83299: LD_EXP 30
83303: PUSH
83304: LD_VAR 0 3
83308: ARRAY
83309: IN
83310: IFFALSE 83933
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83312: LD_ADDR_EXP 30
83316: PUSH
83317: LD_EXP 30
83321: PPUSH
83322: LD_VAR 0 3
83326: PPUSH
83327: LD_EXP 30
83331: PUSH
83332: LD_VAR 0 3
83336: ARRAY
83337: PUSH
83338: LD_VAR 0 1
83342: DIFF
83343: PPUSH
83344: CALL_OW 1
83348: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83349: LD_ADDR_EXP 23
83353: PUSH
83354: LD_EXP 23
83358: PPUSH
83359: LD_VAR 0 3
83363: PUSH
83364: LD_EXP 23
83368: PUSH
83369: LD_VAR 0 3
83373: ARRAY
83374: PUSH
83375: LD_INT 1
83377: PLUS
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PPUSH
83383: LD_VAR 0 1
83387: PPUSH
83388: CALL 16077 0 3
83392: ST_TO_ADDR
// btype := GetBType ( building ) ;
83393: LD_ADDR_VAR 0 5
83397: PUSH
83398: LD_VAR 0 1
83402: PPUSH
83403: CALL_OW 266
83407: ST_TO_ADDR
// side := GetSide ( building ) ;
83408: LD_ADDR_VAR 0 8
83412: PUSH
83413: LD_VAR 0 1
83417: PPUSH
83418: CALL_OW 255
83422: ST_TO_ADDR
// if btype = b_lab then
83423: LD_VAR 0 5
83427: PUSH
83428: LD_INT 6
83430: EQUAL
83431: IFFALSE 83481
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83433: LD_ADDR_EXP 56
83437: PUSH
83438: LD_EXP 56
83442: PPUSH
83443: LD_VAR 0 3
83447: PUSH
83448: LD_EXP 56
83452: PUSH
83453: LD_VAR 0 3
83457: ARRAY
83458: PUSH
83459: LD_INT 1
83461: PLUS
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PPUSH
83467: LD_VAR 0 1
83471: PPUSH
83472: CALL 16077 0 3
83476: ST_TO_ADDR
// exit ;
83477: POP
83478: POP
83479: GO 83937
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83481: LD_VAR 0 5
83485: PUSH
83486: LD_INT 0
83488: PUSH
83489: LD_INT 2
83491: PUSH
83492: LD_INT 4
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: LIST
83499: IN
83500: IFFALSE 83624
// begin if btype = b_armoury then
83502: LD_VAR 0 5
83506: PUSH
83507: LD_INT 4
83509: EQUAL
83510: IFFALSE 83520
// btype := b_barracks ;
83512: LD_ADDR_VAR 0 5
83516: PUSH
83517: LD_INT 5
83519: ST_TO_ADDR
// if btype = b_depot then
83520: LD_VAR 0 5
83524: PUSH
83525: LD_INT 0
83527: EQUAL
83528: IFFALSE 83538
// btype := b_warehouse ;
83530: LD_ADDR_VAR 0 5
83534: PUSH
83535: LD_INT 1
83537: ST_TO_ADDR
// if btype = b_workshop then
83538: LD_VAR 0 5
83542: PUSH
83543: LD_INT 2
83545: EQUAL
83546: IFFALSE 83556
// btype := b_factory ;
83548: LD_ADDR_VAR 0 5
83552: PUSH
83553: LD_INT 3
83555: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83556: LD_VAR 0 5
83560: PPUSH
83561: LD_VAR 0 8
83565: PPUSH
83566: CALL_OW 323
83570: PUSH
83571: LD_INT 1
83573: EQUAL
83574: IFFALSE 83620
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83576: LD_ADDR_EXP 55
83580: PUSH
83581: LD_EXP 55
83585: PPUSH
83586: LD_VAR 0 3
83590: PUSH
83591: LD_EXP 55
83595: PUSH
83596: LD_VAR 0 3
83600: ARRAY
83601: PUSH
83602: LD_INT 1
83604: PLUS
83605: PUSH
83606: EMPTY
83607: LIST
83608: LIST
83609: PPUSH
83610: LD_VAR 0 1
83614: PPUSH
83615: CALL 16077 0 3
83619: ST_TO_ADDR
// exit ;
83620: POP
83621: POP
83622: GO 83937
// end ; if btype in [ b_bunker , b_turret ] then
83624: LD_VAR 0 5
83628: PUSH
83629: LD_INT 32
83631: PUSH
83632: LD_INT 33
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: IN
83639: IFFALSE 83929
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83641: LD_ADDR_EXP 31
83645: PUSH
83646: LD_EXP 31
83650: PPUSH
83651: LD_VAR 0 3
83655: PUSH
83656: LD_EXP 31
83660: PUSH
83661: LD_VAR 0 3
83665: ARRAY
83666: PUSH
83667: LD_INT 1
83669: PLUS
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PPUSH
83675: LD_VAR 0 1
83679: PPUSH
83680: CALL 16077 0 3
83684: ST_TO_ADDR
// if btype = b_bunker then
83685: LD_VAR 0 5
83689: PUSH
83690: LD_INT 32
83692: EQUAL
83693: IFFALSE 83929
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83695: LD_ADDR_EXP 32
83699: PUSH
83700: LD_EXP 32
83704: PPUSH
83705: LD_VAR 0 3
83709: PUSH
83710: LD_EXP 32
83714: PUSH
83715: LD_VAR 0 3
83719: ARRAY
83720: PUSH
83721: LD_INT 1
83723: PLUS
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PPUSH
83729: LD_VAR 0 1
83733: PPUSH
83734: CALL 16077 0 3
83738: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83739: LD_ADDR_VAR 0 6
83743: PUSH
83744: LD_EXP 23
83748: PUSH
83749: LD_VAR 0 3
83753: ARRAY
83754: PPUSH
83755: LD_INT 25
83757: PUSH
83758: LD_INT 1
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 3
83767: PUSH
83768: LD_INT 54
83770: PUSH
83771: EMPTY
83772: LIST
83773: PUSH
83774: EMPTY
83775: LIST
83776: LIST
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PPUSH
83782: CALL_OW 72
83786: ST_TO_ADDR
// if tmp then
83787: LD_VAR 0 6
83791: IFFALSE 83797
// exit ;
83793: POP
83794: POP
83795: GO 83937
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83797: LD_ADDR_VAR 0 6
83801: PUSH
83802: LD_EXP 23
83806: PUSH
83807: LD_VAR 0 3
83811: ARRAY
83812: PPUSH
83813: LD_INT 2
83815: PUSH
83816: LD_INT 30
83818: PUSH
83819: LD_INT 4
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: PUSH
83826: LD_INT 30
83828: PUSH
83829: LD_INT 5
83831: PUSH
83832: EMPTY
83833: LIST
83834: LIST
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: LIST
83840: PPUSH
83841: CALL_OW 72
83845: ST_TO_ADDR
// if not tmp then
83846: LD_VAR 0 6
83850: NOT
83851: IFFALSE 83857
// exit ;
83853: POP
83854: POP
83855: GO 83937
// for j in tmp do
83857: LD_ADDR_VAR 0 4
83861: PUSH
83862: LD_VAR 0 6
83866: PUSH
83867: FOR_IN
83868: IFFALSE 83927
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83870: LD_ADDR_VAR 0 7
83874: PUSH
83875: LD_VAR 0 4
83879: PPUSH
83880: CALL_OW 313
83884: PPUSH
83885: LD_INT 25
83887: PUSH
83888: LD_INT 1
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PPUSH
83895: CALL_OW 72
83899: ST_TO_ADDR
// if units then
83900: LD_VAR 0 7
83904: IFFALSE 83925
// begin ComExitBuilding ( units [ 1 ] ) ;
83906: LD_VAR 0 7
83910: PUSH
83911: LD_INT 1
83913: ARRAY
83914: PPUSH
83915: CALL_OW 122
// exit ;
83919: POP
83920: POP
83921: POP
83922: POP
83923: GO 83937
// end ; end ;
83925: GO 83867
83927: POP
83928: POP
// end ; end ; exit ;
83929: POP
83930: POP
83931: GO 83937
// end ; end ;
83933: GO 83291
83935: POP
83936: POP
// end ;
83937: LD_VAR 0 2
83941: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83942: LD_INT 0
83944: PPUSH
83945: PPUSH
83946: PPUSH
83947: PPUSH
83948: PPUSH
83949: PPUSH
83950: PPUSH
// if not mc_bases or not skirmish then
83951: LD_EXP 23
83955: NOT
83956: PUSH
83957: LD_EXP 21
83961: NOT
83962: OR
83963: IFFALSE 83967
// exit ;
83965: GO 84232
// btype := GetBType ( building ) ;
83967: LD_ADDR_VAR 0 6
83971: PUSH
83972: LD_VAR 0 1
83976: PPUSH
83977: CALL_OW 266
83981: ST_TO_ADDR
// x := GetX ( building ) ;
83982: LD_ADDR_VAR 0 7
83986: PUSH
83987: LD_VAR 0 1
83991: PPUSH
83992: CALL_OW 250
83996: ST_TO_ADDR
// y := GetY ( building ) ;
83997: LD_ADDR_VAR 0 8
84001: PUSH
84002: LD_VAR 0 1
84006: PPUSH
84007: CALL_OW 251
84011: ST_TO_ADDR
// d := GetDir ( building ) ;
84012: LD_ADDR_VAR 0 9
84016: PUSH
84017: LD_VAR 0 1
84021: PPUSH
84022: CALL_OW 254
84026: ST_TO_ADDR
// for i = 1 to mc_bases do
84027: LD_ADDR_VAR 0 4
84031: PUSH
84032: DOUBLE
84033: LD_INT 1
84035: DEC
84036: ST_TO_ADDR
84037: LD_EXP 23
84041: PUSH
84042: FOR_TO
84043: IFFALSE 84230
// begin if not mc_build_list [ i ] then
84045: LD_EXP 28
84049: PUSH
84050: LD_VAR 0 4
84054: ARRAY
84055: NOT
84056: IFFALSE 84060
// continue ;
84058: GO 84042
// for j := 1 to mc_build_list [ i ] do
84060: LD_ADDR_VAR 0 5
84064: PUSH
84065: DOUBLE
84066: LD_INT 1
84068: DEC
84069: ST_TO_ADDR
84070: LD_EXP 28
84074: PUSH
84075: LD_VAR 0 4
84079: ARRAY
84080: PUSH
84081: FOR_TO
84082: IFFALSE 84226
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
84084: LD_VAR 0 6
84088: PUSH
84089: LD_VAR 0 7
84093: PUSH
84094: LD_VAR 0 8
84098: PUSH
84099: LD_VAR 0 9
84103: PUSH
84104: EMPTY
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: PPUSH
84110: LD_EXP 28
84114: PUSH
84115: LD_VAR 0 4
84119: ARRAY
84120: PUSH
84121: LD_VAR 0 5
84125: ARRAY
84126: PPUSH
84127: CALL 22634 0 2
84131: IFFALSE 84224
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
84133: LD_ADDR_EXP 28
84137: PUSH
84138: LD_EXP 28
84142: PPUSH
84143: LD_VAR 0 4
84147: PPUSH
84148: LD_EXP 28
84152: PUSH
84153: LD_VAR 0 4
84157: ARRAY
84158: PPUSH
84159: LD_VAR 0 5
84163: PPUSH
84164: CALL_OW 3
84168: PPUSH
84169: CALL_OW 1
84173: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84174: LD_ADDR_EXP 30
84178: PUSH
84179: LD_EXP 30
84183: PPUSH
84184: LD_VAR 0 4
84188: PUSH
84189: LD_EXP 30
84193: PUSH
84194: LD_VAR 0 4
84198: ARRAY
84199: PUSH
84200: LD_INT 1
84202: PLUS
84203: PUSH
84204: EMPTY
84205: LIST
84206: LIST
84207: PPUSH
84208: LD_VAR 0 1
84212: PPUSH
84213: CALL 16077 0 3
84217: ST_TO_ADDR
// exit ;
84218: POP
84219: POP
84220: POP
84221: POP
84222: GO 84232
// end ;
84224: GO 84081
84226: POP
84227: POP
// end ;
84228: GO 84042
84230: POP
84231: POP
// end ;
84232: LD_VAR 0 3
84236: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84237: LD_INT 0
84239: PPUSH
84240: PPUSH
84241: PPUSH
// if not mc_bases or not skirmish then
84242: LD_EXP 23
84246: NOT
84247: PUSH
84248: LD_EXP 21
84252: NOT
84253: OR
84254: IFFALSE 84258
// exit ;
84256: GO 84448
// for i = 1 to mc_bases do
84258: LD_ADDR_VAR 0 4
84262: PUSH
84263: DOUBLE
84264: LD_INT 1
84266: DEC
84267: ST_TO_ADDR
84268: LD_EXP 23
84272: PUSH
84273: FOR_TO
84274: IFFALSE 84361
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84276: LD_VAR 0 1
84280: PUSH
84281: LD_EXP 31
84285: PUSH
84286: LD_VAR 0 4
84290: ARRAY
84291: IN
84292: PUSH
84293: LD_VAR 0 1
84297: PUSH
84298: LD_EXP 32
84302: PUSH
84303: LD_VAR 0 4
84307: ARRAY
84308: IN
84309: NOT
84310: AND
84311: IFFALSE 84359
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84313: LD_ADDR_EXP 32
84317: PUSH
84318: LD_EXP 32
84322: PPUSH
84323: LD_VAR 0 4
84327: PUSH
84328: LD_EXP 32
84332: PUSH
84333: LD_VAR 0 4
84337: ARRAY
84338: PUSH
84339: LD_INT 1
84341: PLUS
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PPUSH
84347: LD_VAR 0 1
84351: PPUSH
84352: CALL 16077 0 3
84356: ST_TO_ADDR
// break ;
84357: GO 84361
// end ; end ;
84359: GO 84273
84361: POP
84362: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84363: LD_VAR 0 1
84367: PPUSH
84368: CALL_OW 257
84372: PUSH
84373: LD_EXP 49
84377: IN
84378: PUSH
84379: LD_VAR 0 1
84383: PPUSH
84384: CALL_OW 266
84388: PUSH
84389: LD_INT 5
84391: EQUAL
84392: AND
84393: PUSH
84394: LD_VAR 0 2
84398: PPUSH
84399: CALL_OW 110
84403: PUSH
84404: LD_INT 18
84406: NONEQUAL
84407: AND
84408: IFFALSE 84448
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84410: LD_VAR 0 2
84414: PPUSH
84415: CALL_OW 257
84419: PUSH
84420: LD_INT 5
84422: PUSH
84423: LD_INT 8
84425: PUSH
84426: LD_INT 9
84428: PUSH
84429: EMPTY
84430: LIST
84431: LIST
84432: LIST
84433: IN
84434: IFFALSE 84448
// SetClass ( unit , 1 ) ;
84436: LD_VAR 0 2
84440: PPUSH
84441: LD_INT 1
84443: PPUSH
84444: CALL_OW 336
// end ;
84448: LD_VAR 0 3
84452: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84453: LD_INT 0
84455: PPUSH
84456: PPUSH
// if not mc_bases or not skirmish then
84457: LD_EXP 23
84461: NOT
84462: PUSH
84463: LD_EXP 21
84467: NOT
84468: OR
84469: IFFALSE 84473
// exit ;
84471: GO 84589
// if GetLives ( abandoned_vehicle ) > 250 then
84473: LD_VAR 0 2
84477: PPUSH
84478: CALL_OW 256
84482: PUSH
84483: LD_INT 250
84485: GREATER
84486: IFFALSE 84490
// exit ;
84488: GO 84589
// for i = 1 to mc_bases do
84490: LD_ADDR_VAR 0 6
84494: PUSH
84495: DOUBLE
84496: LD_INT 1
84498: DEC
84499: ST_TO_ADDR
84500: LD_EXP 23
84504: PUSH
84505: FOR_TO
84506: IFFALSE 84587
// begin if driver in mc_bases [ i ] then
84508: LD_VAR 0 1
84512: PUSH
84513: LD_EXP 23
84517: PUSH
84518: LD_VAR 0 6
84522: ARRAY
84523: IN
84524: IFFALSE 84585
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84526: LD_VAR 0 1
84530: PPUSH
84531: LD_EXP 23
84535: PUSH
84536: LD_VAR 0 6
84540: ARRAY
84541: PPUSH
84542: LD_INT 2
84544: PUSH
84545: LD_INT 30
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 30
84557: PUSH
84558: LD_INT 1
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: LIST
84569: PPUSH
84570: CALL_OW 72
84574: PUSH
84575: LD_INT 1
84577: ARRAY
84578: PPUSH
84579: CALL 49683 0 2
// break ;
84583: GO 84587
// end ; end ;
84585: GO 84505
84587: POP
84588: POP
// end ; end_of_file
84589: LD_VAR 0 5
84593: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
84594: LD_INT 0
84596: PPUSH
84597: PPUSH
84598: PPUSH
84599: PPUSH
84600: PPUSH
84601: PPUSH
84602: PPUSH
84603: PPUSH
84604: PPUSH
84605: PPUSH
84606: PPUSH
84607: PPUSH
84608: PPUSH
84609: PPUSH
84610: PPUSH
84611: PPUSH
84612: PPUSH
84613: PPUSH
84614: PPUSH
84615: PPUSH
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
84620: PPUSH
84621: PPUSH
84622: PPUSH
84623: PPUSH
84624: PPUSH
84625: PPUSH
84626: PPUSH
84627: PPUSH
84628: PPUSH
84629: PPUSH
// if not list then
84630: LD_VAR 0 1
84634: NOT
84635: IFFALSE 84639
// exit ;
84637: GO 89298
// base := list [ 1 ] ;
84639: LD_ADDR_VAR 0 3
84643: PUSH
84644: LD_VAR 0 1
84648: PUSH
84649: LD_INT 1
84651: ARRAY
84652: ST_TO_ADDR
// group := list [ 2 ] ;
84653: LD_ADDR_VAR 0 4
84657: PUSH
84658: LD_VAR 0 1
84662: PUSH
84663: LD_INT 2
84665: ARRAY
84666: ST_TO_ADDR
// path := list [ 3 ] ;
84667: LD_ADDR_VAR 0 5
84671: PUSH
84672: LD_VAR 0 1
84676: PUSH
84677: LD_INT 3
84679: ARRAY
84680: ST_TO_ADDR
// flags := list [ 4 ] ;
84681: LD_ADDR_VAR 0 6
84685: PUSH
84686: LD_VAR 0 1
84690: PUSH
84691: LD_INT 4
84693: ARRAY
84694: ST_TO_ADDR
// mined := [ ] ;
84695: LD_ADDR_VAR 0 27
84699: PUSH
84700: EMPTY
84701: ST_TO_ADDR
// bombed := [ ] ;
84702: LD_ADDR_VAR 0 28
84706: PUSH
84707: EMPTY
84708: ST_TO_ADDR
// healers := [ ] ;
84709: LD_ADDR_VAR 0 31
84713: PUSH
84714: EMPTY
84715: ST_TO_ADDR
// to_heal := [ ] ;
84716: LD_ADDR_VAR 0 30
84720: PUSH
84721: EMPTY
84722: ST_TO_ADDR
// repairs := [ ] ;
84723: LD_ADDR_VAR 0 33
84727: PUSH
84728: EMPTY
84729: ST_TO_ADDR
// to_repair := [ ] ;
84730: LD_ADDR_VAR 0 32
84734: PUSH
84735: EMPTY
84736: ST_TO_ADDR
// if not group or not path then
84737: LD_VAR 0 4
84741: NOT
84742: PUSH
84743: LD_VAR 0 5
84747: NOT
84748: OR
84749: IFFALSE 84753
// exit ;
84751: GO 89298
// side := GetSide ( group [ 1 ] ) ;
84753: LD_ADDR_VAR 0 35
84757: PUSH
84758: LD_VAR 0 4
84762: PUSH
84763: LD_INT 1
84765: ARRAY
84766: PPUSH
84767: CALL_OW 255
84771: ST_TO_ADDR
// if flags then
84772: LD_VAR 0 6
84776: IFFALSE 84920
// begin f_ignore_area := flags [ 1 ] ;
84778: LD_ADDR_VAR 0 17
84782: PUSH
84783: LD_VAR 0 6
84787: PUSH
84788: LD_INT 1
84790: ARRAY
84791: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
84792: LD_ADDR_VAR 0 18
84796: PUSH
84797: LD_VAR 0 6
84801: PUSH
84802: LD_INT 2
84804: ARRAY
84805: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
84806: LD_ADDR_VAR 0 19
84810: PUSH
84811: LD_VAR 0 6
84815: PUSH
84816: LD_INT 3
84818: ARRAY
84819: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
84820: LD_ADDR_VAR 0 20
84824: PUSH
84825: LD_VAR 0 6
84829: PUSH
84830: LD_INT 4
84832: ARRAY
84833: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
84834: LD_ADDR_VAR 0 21
84838: PUSH
84839: LD_VAR 0 6
84843: PUSH
84844: LD_INT 5
84846: ARRAY
84847: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
84848: LD_ADDR_VAR 0 22
84852: PUSH
84853: LD_VAR 0 6
84857: PUSH
84858: LD_INT 6
84860: ARRAY
84861: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
84862: LD_ADDR_VAR 0 23
84866: PUSH
84867: LD_VAR 0 6
84871: PUSH
84872: LD_INT 7
84874: ARRAY
84875: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
84876: LD_ADDR_VAR 0 24
84880: PUSH
84881: LD_VAR 0 6
84885: PUSH
84886: LD_INT 8
84888: ARRAY
84889: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
84890: LD_ADDR_VAR 0 25
84894: PUSH
84895: LD_VAR 0 6
84899: PUSH
84900: LD_INT 9
84902: ARRAY
84903: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
84904: LD_ADDR_VAR 0 26
84908: PUSH
84909: LD_VAR 0 6
84913: PUSH
84914: LD_INT 10
84916: ARRAY
84917: ST_TO_ADDR
// end else
84918: GO 85000
// begin f_ignore_area := false ;
84920: LD_ADDR_VAR 0 17
84924: PUSH
84925: LD_INT 0
84927: ST_TO_ADDR
// f_capture := false ;
84928: LD_ADDR_VAR 0 18
84932: PUSH
84933: LD_INT 0
84935: ST_TO_ADDR
// f_ignore_civ := false ;
84936: LD_ADDR_VAR 0 19
84940: PUSH
84941: LD_INT 0
84943: ST_TO_ADDR
// f_murder := false ;
84944: LD_ADDR_VAR 0 20
84948: PUSH
84949: LD_INT 0
84951: ST_TO_ADDR
// f_mines := false ;
84952: LD_ADDR_VAR 0 21
84956: PUSH
84957: LD_INT 0
84959: ST_TO_ADDR
// f_repair := false ;
84960: LD_ADDR_VAR 0 22
84964: PUSH
84965: LD_INT 0
84967: ST_TO_ADDR
// f_heal := false ;
84968: LD_ADDR_VAR 0 23
84972: PUSH
84973: LD_INT 0
84975: ST_TO_ADDR
// f_spacetime := false ;
84976: LD_ADDR_VAR 0 24
84980: PUSH
84981: LD_INT 0
84983: ST_TO_ADDR
// f_attack_depot := false ;
84984: LD_ADDR_VAR 0 25
84988: PUSH
84989: LD_INT 0
84991: ST_TO_ADDR
// f_crawl := false ;
84992: LD_ADDR_VAR 0 26
84996: PUSH
84997: LD_INT 0
84999: ST_TO_ADDR
// end ; if f_heal then
85000: LD_VAR 0 23
85004: IFFALSE 85031
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
85006: LD_ADDR_VAR 0 31
85010: PUSH
85011: LD_VAR 0 4
85015: PPUSH
85016: LD_INT 25
85018: PUSH
85019: LD_INT 4
85021: PUSH
85022: EMPTY
85023: LIST
85024: LIST
85025: PPUSH
85026: CALL_OW 72
85030: ST_TO_ADDR
// if f_repair then
85031: LD_VAR 0 22
85035: IFFALSE 85062
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
85037: LD_ADDR_VAR 0 33
85041: PUSH
85042: LD_VAR 0 4
85046: PPUSH
85047: LD_INT 25
85049: PUSH
85050: LD_INT 3
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PPUSH
85057: CALL_OW 72
85061: ST_TO_ADDR
// units_path := [ ] ;
85062: LD_ADDR_VAR 0 16
85066: PUSH
85067: EMPTY
85068: ST_TO_ADDR
// for i = 1 to group do
85069: LD_ADDR_VAR 0 7
85073: PUSH
85074: DOUBLE
85075: LD_INT 1
85077: DEC
85078: ST_TO_ADDR
85079: LD_VAR 0 4
85083: PUSH
85084: FOR_TO
85085: IFFALSE 85114
// units_path := Replace ( units_path , i , path ) ;
85087: LD_ADDR_VAR 0 16
85091: PUSH
85092: LD_VAR 0 16
85096: PPUSH
85097: LD_VAR 0 7
85101: PPUSH
85102: LD_VAR 0 5
85106: PPUSH
85107: CALL_OW 1
85111: ST_TO_ADDR
85112: GO 85084
85114: POP
85115: POP
// repeat for i = group downto 1 do
85116: LD_ADDR_VAR 0 7
85120: PUSH
85121: DOUBLE
85122: LD_VAR 0 4
85126: INC
85127: ST_TO_ADDR
85128: LD_INT 1
85130: PUSH
85131: FOR_DOWNTO
85132: IFFALSE 89254
// begin wait ( 5 ) ;
85134: LD_INT 5
85136: PPUSH
85137: CALL_OW 67
// tmp := [ ] ;
85141: LD_ADDR_VAR 0 14
85145: PUSH
85146: EMPTY
85147: ST_TO_ADDR
// attacking := false ;
85148: LD_ADDR_VAR 0 29
85152: PUSH
85153: LD_INT 0
85155: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
85156: LD_VAR 0 4
85160: PUSH
85161: LD_VAR 0 7
85165: ARRAY
85166: PPUSH
85167: CALL_OW 301
85171: PUSH
85172: LD_VAR 0 4
85176: PUSH
85177: LD_VAR 0 7
85181: ARRAY
85182: NOT
85183: OR
85184: IFFALSE 85293
// begin if GetType ( group [ i ] ) = unit_human then
85186: LD_VAR 0 4
85190: PUSH
85191: LD_VAR 0 7
85195: ARRAY
85196: PPUSH
85197: CALL_OW 247
85201: PUSH
85202: LD_INT 1
85204: EQUAL
85205: IFFALSE 85251
// begin to_heal := to_heal diff group [ i ] ;
85207: LD_ADDR_VAR 0 30
85211: PUSH
85212: LD_VAR 0 30
85216: PUSH
85217: LD_VAR 0 4
85221: PUSH
85222: LD_VAR 0 7
85226: ARRAY
85227: DIFF
85228: ST_TO_ADDR
// healers := healers diff group [ i ] ;
85229: LD_ADDR_VAR 0 31
85233: PUSH
85234: LD_VAR 0 31
85238: PUSH
85239: LD_VAR 0 4
85243: PUSH
85244: LD_VAR 0 7
85248: ARRAY
85249: DIFF
85250: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
85251: LD_ADDR_VAR 0 4
85255: PUSH
85256: LD_VAR 0 4
85260: PPUSH
85261: LD_VAR 0 7
85265: PPUSH
85266: CALL_OW 3
85270: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
85271: LD_ADDR_VAR 0 16
85275: PUSH
85276: LD_VAR 0 16
85280: PPUSH
85281: LD_VAR 0 7
85285: PPUSH
85286: CALL_OW 3
85290: ST_TO_ADDR
// continue ;
85291: GO 85131
// end ; if f_repair then
85293: LD_VAR 0 22
85297: IFFALSE 85786
// begin if GetType ( group [ i ] ) = unit_vehicle then
85299: LD_VAR 0 4
85303: PUSH
85304: LD_VAR 0 7
85308: ARRAY
85309: PPUSH
85310: CALL_OW 247
85314: PUSH
85315: LD_INT 2
85317: EQUAL
85318: IFFALSE 85508
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
85320: LD_VAR 0 4
85324: PUSH
85325: LD_VAR 0 7
85329: ARRAY
85330: PPUSH
85331: CALL_OW 256
85335: PUSH
85336: LD_INT 700
85338: LESS
85339: PUSH
85340: LD_VAR 0 4
85344: PUSH
85345: LD_VAR 0 7
85349: ARRAY
85350: PUSH
85351: LD_VAR 0 32
85355: IN
85356: NOT
85357: AND
85358: IFFALSE 85382
// to_repair := to_repair union group [ i ] ;
85360: LD_ADDR_VAR 0 32
85364: PUSH
85365: LD_VAR 0 32
85369: PUSH
85370: LD_VAR 0 4
85374: PUSH
85375: LD_VAR 0 7
85379: ARRAY
85380: UNION
85381: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
85382: LD_VAR 0 4
85386: PUSH
85387: LD_VAR 0 7
85391: ARRAY
85392: PPUSH
85393: CALL_OW 256
85397: PUSH
85398: LD_INT 1000
85400: EQUAL
85401: PUSH
85402: LD_VAR 0 4
85406: PUSH
85407: LD_VAR 0 7
85411: ARRAY
85412: PUSH
85413: LD_VAR 0 32
85417: IN
85418: AND
85419: IFFALSE 85443
// to_repair := to_repair diff group [ i ] ;
85421: LD_ADDR_VAR 0 32
85425: PUSH
85426: LD_VAR 0 32
85430: PUSH
85431: LD_VAR 0 4
85435: PUSH
85436: LD_VAR 0 7
85440: ARRAY
85441: DIFF
85442: ST_TO_ADDR
// if group [ i ] in to_repair then
85443: LD_VAR 0 4
85447: PUSH
85448: LD_VAR 0 7
85452: ARRAY
85453: PUSH
85454: LD_VAR 0 32
85458: IN
85459: IFFALSE 85506
// begin if not IsInArea ( group [ i ] , f_repair ) then
85461: LD_VAR 0 4
85465: PUSH
85466: LD_VAR 0 7
85470: ARRAY
85471: PPUSH
85472: LD_VAR 0 22
85476: PPUSH
85477: CALL_OW 308
85481: NOT
85482: IFFALSE 85504
// ComMoveToArea ( group [ i ] , f_repair ) ;
85484: LD_VAR 0 4
85488: PUSH
85489: LD_VAR 0 7
85493: ARRAY
85494: PPUSH
85495: LD_VAR 0 22
85499: PPUSH
85500: CALL_OW 113
// continue ;
85504: GO 85131
// end ; end else
85506: GO 85786
// if group [ i ] in repairs then
85508: LD_VAR 0 4
85512: PUSH
85513: LD_VAR 0 7
85517: ARRAY
85518: PUSH
85519: LD_VAR 0 33
85523: IN
85524: IFFALSE 85786
// begin if IsInUnit ( group [ i ] ) then
85526: LD_VAR 0 4
85530: PUSH
85531: LD_VAR 0 7
85535: ARRAY
85536: PPUSH
85537: CALL_OW 310
85541: IFFALSE 85609
// begin z := IsInUnit ( group [ i ] ) ;
85543: LD_ADDR_VAR 0 13
85547: PUSH
85548: LD_VAR 0 4
85552: PUSH
85553: LD_VAR 0 7
85557: ARRAY
85558: PPUSH
85559: CALL_OW 310
85563: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
85564: LD_VAR 0 13
85568: PUSH
85569: LD_VAR 0 32
85573: IN
85574: PUSH
85575: LD_VAR 0 13
85579: PPUSH
85580: LD_VAR 0 22
85584: PPUSH
85585: CALL_OW 308
85589: AND
85590: IFFALSE 85607
// ComExitVehicle ( group [ i ] ) ;
85592: LD_VAR 0 4
85596: PUSH
85597: LD_VAR 0 7
85601: ARRAY
85602: PPUSH
85603: CALL_OW 121
// end else
85607: GO 85786
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
85609: LD_ADDR_VAR 0 13
85613: PUSH
85614: LD_VAR 0 4
85618: PPUSH
85619: LD_INT 95
85621: PUSH
85622: LD_VAR 0 22
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 58
85633: PUSH
85634: EMPTY
85635: LIST
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: PPUSH
85641: CALL_OW 72
85645: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
85646: LD_VAR 0 4
85650: PUSH
85651: LD_VAR 0 7
85655: ARRAY
85656: PPUSH
85657: CALL_OW 314
85661: NOT
85662: IFFALSE 85784
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
85664: LD_ADDR_VAR 0 10
85668: PUSH
85669: LD_VAR 0 13
85673: PPUSH
85674: LD_VAR 0 4
85678: PUSH
85679: LD_VAR 0 7
85683: ARRAY
85684: PPUSH
85685: CALL_OW 74
85689: ST_TO_ADDR
// if not x then
85690: LD_VAR 0 10
85694: NOT
85695: IFFALSE 85699
// continue ;
85697: GO 85131
// if GetLives ( x ) < 1000 then
85699: LD_VAR 0 10
85703: PPUSH
85704: CALL_OW 256
85708: PUSH
85709: LD_INT 1000
85711: LESS
85712: IFFALSE 85736
// ComRepairVehicle ( group [ i ] , x ) else
85714: LD_VAR 0 4
85718: PUSH
85719: LD_VAR 0 7
85723: ARRAY
85724: PPUSH
85725: LD_VAR 0 10
85729: PPUSH
85730: CALL_OW 129
85734: GO 85784
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
85736: LD_VAR 0 23
85740: PUSH
85741: LD_VAR 0 4
85745: PUSH
85746: LD_VAR 0 7
85750: ARRAY
85751: PPUSH
85752: CALL_OW 256
85756: PUSH
85757: LD_INT 1000
85759: LESS
85760: AND
85761: NOT
85762: IFFALSE 85784
// ComEnterUnit ( group [ i ] , x ) ;
85764: LD_VAR 0 4
85768: PUSH
85769: LD_VAR 0 7
85773: ARRAY
85774: PPUSH
85775: LD_VAR 0 10
85779: PPUSH
85780: CALL_OW 120
// end ; continue ;
85784: GO 85131
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
85786: LD_VAR 0 23
85790: PUSH
85791: LD_VAR 0 4
85795: PUSH
85796: LD_VAR 0 7
85800: ARRAY
85801: PPUSH
85802: CALL_OW 247
85806: PUSH
85807: LD_INT 1
85809: EQUAL
85810: AND
85811: IFFALSE 86289
// begin if group [ i ] in healers then
85813: LD_VAR 0 4
85817: PUSH
85818: LD_VAR 0 7
85822: ARRAY
85823: PUSH
85824: LD_VAR 0 31
85828: IN
85829: IFFALSE 86102
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
85831: LD_VAR 0 4
85835: PUSH
85836: LD_VAR 0 7
85840: ARRAY
85841: PPUSH
85842: LD_VAR 0 23
85846: PPUSH
85847: CALL_OW 308
85851: NOT
85852: PUSH
85853: LD_VAR 0 4
85857: PUSH
85858: LD_VAR 0 7
85862: ARRAY
85863: PPUSH
85864: CALL_OW 314
85868: NOT
85869: AND
85870: IFFALSE 85894
// ComMoveToArea ( group [ i ] , f_heal ) else
85872: LD_VAR 0 4
85876: PUSH
85877: LD_VAR 0 7
85881: ARRAY
85882: PPUSH
85883: LD_VAR 0 23
85887: PPUSH
85888: CALL_OW 113
85892: GO 86100
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
85894: LD_VAR 0 4
85898: PUSH
85899: LD_VAR 0 7
85903: ARRAY
85904: PPUSH
85905: CALL 46186 0 1
85909: PPUSH
85910: CALL_OW 256
85914: PUSH
85915: LD_INT 1000
85917: EQUAL
85918: IFFALSE 85937
// ComStop ( group [ i ] ) else
85920: LD_VAR 0 4
85924: PUSH
85925: LD_VAR 0 7
85929: ARRAY
85930: PPUSH
85931: CALL_OW 141
85935: GO 86100
// if not HasTask ( group [ i ] ) and to_heal then
85937: LD_VAR 0 4
85941: PUSH
85942: LD_VAR 0 7
85946: ARRAY
85947: PPUSH
85948: CALL_OW 314
85952: NOT
85953: PUSH
85954: LD_VAR 0 30
85958: AND
85959: IFFALSE 86100
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
85961: LD_ADDR_VAR 0 13
85965: PUSH
85966: LD_VAR 0 30
85970: PPUSH
85971: LD_INT 3
85973: PUSH
85974: LD_INT 54
85976: PUSH
85977: EMPTY
85978: LIST
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PPUSH
85984: CALL_OW 72
85988: PPUSH
85989: LD_VAR 0 4
85993: PUSH
85994: LD_VAR 0 7
85998: ARRAY
85999: PPUSH
86000: CALL_OW 74
86004: ST_TO_ADDR
// if z then
86005: LD_VAR 0 13
86009: IFFALSE 86100
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
86011: LD_INT 91
86013: PUSH
86014: LD_VAR 0 13
86018: PUSH
86019: LD_INT 10
86021: PUSH
86022: EMPTY
86023: LIST
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 81
86029: PUSH
86030: LD_VAR 0 13
86034: PPUSH
86035: CALL_OW 255
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PPUSH
86048: CALL_OW 69
86052: PUSH
86053: LD_INT 0
86055: EQUAL
86056: IFFALSE 86080
// ComHeal ( group [ i ] , z ) else
86058: LD_VAR 0 4
86062: PUSH
86063: LD_VAR 0 7
86067: ARRAY
86068: PPUSH
86069: LD_VAR 0 13
86073: PPUSH
86074: CALL_OW 128
86078: GO 86100
// ComMoveToArea ( group [ i ] , f_heal ) ;
86080: LD_VAR 0 4
86084: PUSH
86085: LD_VAR 0 7
86089: ARRAY
86090: PPUSH
86091: LD_VAR 0 23
86095: PPUSH
86096: CALL_OW 113
// end ; continue ;
86100: GO 85131
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
86102: LD_VAR 0 4
86106: PUSH
86107: LD_VAR 0 7
86111: ARRAY
86112: PPUSH
86113: CALL_OW 256
86117: PUSH
86118: LD_INT 700
86120: LESS
86121: PUSH
86122: LD_VAR 0 4
86126: PUSH
86127: LD_VAR 0 7
86131: ARRAY
86132: PUSH
86133: LD_VAR 0 30
86137: IN
86138: NOT
86139: AND
86140: IFFALSE 86164
// to_heal := to_heal union group [ i ] ;
86142: LD_ADDR_VAR 0 30
86146: PUSH
86147: LD_VAR 0 30
86151: PUSH
86152: LD_VAR 0 4
86156: PUSH
86157: LD_VAR 0 7
86161: ARRAY
86162: UNION
86163: ST_TO_ADDR
// if group [ i ] in to_heal then
86164: LD_VAR 0 4
86168: PUSH
86169: LD_VAR 0 7
86173: ARRAY
86174: PUSH
86175: LD_VAR 0 30
86179: IN
86180: IFFALSE 86289
// begin if GetLives ( group [ i ] ) = 1000 then
86182: LD_VAR 0 4
86186: PUSH
86187: LD_VAR 0 7
86191: ARRAY
86192: PPUSH
86193: CALL_OW 256
86197: PUSH
86198: LD_INT 1000
86200: EQUAL
86201: IFFALSE 86227
// to_heal := to_heal diff group [ i ] else
86203: LD_ADDR_VAR 0 30
86207: PUSH
86208: LD_VAR 0 30
86212: PUSH
86213: LD_VAR 0 4
86217: PUSH
86218: LD_VAR 0 7
86222: ARRAY
86223: DIFF
86224: ST_TO_ADDR
86225: GO 86289
// begin if not IsInArea ( group [ i ] , to_heal ) then
86227: LD_VAR 0 4
86231: PUSH
86232: LD_VAR 0 7
86236: ARRAY
86237: PPUSH
86238: LD_VAR 0 30
86242: PPUSH
86243: CALL_OW 308
86247: NOT
86248: IFFALSE 86272
// ComMoveToArea ( group [ i ] , f_heal ) else
86250: LD_VAR 0 4
86254: PUSH
86255: LD_VAR 0 7
86259: ARRAY
86260: PPUSH
86261: LD_VAR 0 23
86265: PPUSH
86266: CALL_OW 113
86270: GO 86287
// ComHold ( group [ i ] ) ;
86272: LD_VAR 0 4
86276: PUSH
86277: LD_VAR 0 7
86281: ARRAY
86282: PPUSH
86283: CALL_OW 140
// continue ;
86287: GO 85131
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
86289: LD_VAR 0 4
86293: PUSH
86294: LD_VAR 0 7
86298: ARRAY
86299: PPUSH
86300: LD_INT 10
86302: PPUSH
86303: CALL 43968 0 2
86307: NOT
86308: PUSH
86309: LD_VAR 0 16
86313: PUSH
86314: LD_VAR 0 7
86318: ARRAY
86319: PUSH
86320: EMPTY
86321: EQUAL
86322: NOT
86323: AND
86324: IFFALSE 86590
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
86326: LD_VAR 0 4
86330: PUSH
86331: LD_VAR 0 7
86335: ARRAY
86336: PPUSH
86337: CALL_OW 262
86341: PUSH
86342: LD_INT 1
86344: PUSH
86345: LD_INT 2
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: IN
86352: IFFALSE 86393
// if GetFuel ( group [ i ] ) < 10 then
86354: LD_VAR 0 4
86358: PUSH
86359: LD_VAR 0 7
86363: ARRAY
86364: PPUSH
86365: CALL_OW 261
86369: PUSH
86370: LD_INT 10
86372: LESS
86373: IFFALSE 86393
// SetFuel ( group [ i ] , 12 ) ;
86375: LD_VAR 0 4
86379: PUSH
86380: LD_VAR 0 7
86384: ARRAY
86385: PPUSH
86386: LD_INT 12
86388: PPUSH
86389: CALL_OW 240
// if units_path [ i ] then
86393: LD_VAR 0 16
86397: PUSH
86398: LD_VAR 0 7
86402: ARRAY
86403: IFFALSE 86588
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
86405: LD_VAR 0 4
86409: PUSH
86410: LD_VAR 0 7
86414: ARRAY
86415: PPUSH
86416: LD_VAR 0 16
86420: PUSH
86421: LD_VAR 0 7
86425: ARRAY
86426: PUSH
86427: LD_INT 1
86429: ARRAY
86430: PUSH
86431: LD_INT 1
86433: ARRAY
86434: PPUSH
86435: LD_VAR 0 16
86439: PUSH
86440: LD_VAR 0 7
86444: ARRAY
86445: PUSH
86446: LD_INT 1
86448: ARRAY
86449: PUSH
86450: LD_INT 2
86452: ARRAY
86453: PPUSH
86454: CALL_OW 297
86458: PUSH
86459: LD_INT 6
86461: GREATER
86462: IFFALSE 86537
// begin if not HasTask ( group [ i ] ) then
86464: LD_VAR 0 4
86468: PUSH
86469: LD_VAR 0 7
86473: ARRAY
86474: PPUSH
86475: CALL_OW 314
86479: NOT
86480: IFFALSE 86535
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
86482: LD_VAR 0 4
86486: PUSH
86487: LD_VAR 0 7
86491: ARRAY
86492: PPUSH
86493: LD_VAR 0 16
86497: PUSH
86498: LD_VAR 0 7
86502: ARRAY
86503: PUSH
86504: LD_INT 1
86506: ARRAY
86507: PUSH
86508: LD_INT 1
86510: ARRAY
86511: PPUSH
86512: LD_VAR 0 16
86516: PUSH
86517: LD_VAR 0 7
86521: ARRAY
86522: PUSH
86523: LD_INT 1
86525: ARRAY
86526: PUSH
86527: LD_INT 2
86529: ARRAY
86530: PPUSH
86531: CALL_OW 114
// end else
86535: GO 86588
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
86537: LD_ADDR_VAR 0 15
86541: PUSH
86542: LD_VAR 0 16
86546: PUSH
86547: LD_VAR 0 7
86551: ARRAY
86552: PPUSH
86553: LD_INT 1
86555: PPUSH
86556: CALL_OW 3
86560: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
86561: LD_ADDR_VAR 0 16
86565: PUSH
86566: LD_VAR 0 16
86570: PPUSH
86571: LD_VAR 0 7
86575: PPUSH
86576: LD_VAR 0 15
86580: PPUSH
86581: CALL_OW 1
86585: ST_TO_ADDR
// continue ;
86586: GO 85131
// end ; end ; end else
86588: GO 89252
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
86590: LD_ADDR_VAR 0 14
86594: PUSH
86595: LD_INT 81
86597: PUSH
86598: LD_VAR 0 4
86602: PUSH
86603: LD_VAR 0 7
86607: ARRAY
86608: PPUSH
86609: CALL_OW 255
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PPUSH
86618: CALL_OW 69
86622: ST_TO_ADDR
// if not tmp then
86623: LD_VAR 0 14
86627: NOT
86628: IFFALSE 86632
// continue ;
86630: GO 85131
// if f_ignore_area then
86632: LD_VAR 0 17
86636: IFFALSE 86724
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
86638: LD_ADDR_VAR 0 15
86642: PUSH
86643: LD_VAR 0 14
86647: PPUSH
86648: LD_INT 3
86650: PUSH
86651: LD_INT 92
86653: PUSH
86654: LD_VAR 0 17
86658: PUSH
86659: LD_INT 1
86661: ARRAY
86662: PUSH
86663: LD_VAR 0 17
86667: PUSH
86668: LD_INT 2
86670: ARRAY
86671: PUSH
86672: LD_VAR 0 17
86676: PUSH
86677: LD_INT 3
86679: ARRAY
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: PUSH
86687: EMPTY
86688: LIST
86689: LIST
86690: PPUSH
86691: CALL_OW 72
86695: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
86696: LD_VAR 0 14
86700: PUSH
86701: LD_VAR 0 15
86705: DIFF
86706: IFFALSE 86724
// tmp := tmp diff tmp2 ;
86708: LD_ADDR_VAR 0 14
86712: PUSH
86713: LD_VAR 0 14
86717: PUSH
86718: LD_VAR 0 15
86722: DIFF
86723: ST_TO_ADDR
// end ; if not f_murder then
86724: LD_VAR 0 20
86728: NOT
86729: IFFALSE 86787
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
86731: LD_ADDR_VAR 0 15
86735: PUSH
86736: LD_VAR 0 14
86740: PPUSH
86741: LD_INT 3
86743: PUSH
86744: LD_INT 50
86746: PUSH
86747: EMPTY
86748: LIST
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PPUSH
86754: CALL_OW 72
86758: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
86759: LD_VAR 0 14
86763: PUSH
86764: LD_VAR 0 15
86768: DIFF
86769: IFFALSE 86787
// tmp := tmp diff tmp2 ;
86771: LD_ADDR_VAR 0 14
86775: PUSH
86776: LD_VAR 0 14
86780: PUSH
86781: LD_VAR 0 15
86785: DIFF
86786: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
86787: LD_ADDR_VAR 0 14
86791: PUSH
86792: LD_VAR 0 4
86796: PUSH
86797: LD_VAR 0 7
86801: ARRAY
86802: PPUSH
86803: LD_VAR 0 14
86807: PPUSH
86808: LD_INT 1
86810: PPUSH
86811: LD_INT 1
86813: PPUSH
86814: CALL 16512 0 4
86818: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
86819: LD_VAR 0 4
86823: PUSH
86824: LD_VAR 0 7
86828: ARRAY
86829: PPUSH
86830: CALL_OW 257
86834: PUSH
86835: LD_INT 1
86837: EQUAL
86838: IFFALSE 87286
// begin if WantPlant ( group [ i ] ) then
86840: LD_VAR 0 4
86844: PUSH
86845: LD_VAR 0 7
86849: ARRAY
86850: PPUSH
86851: CALL 16013 0 1
86855: IFFALSE 86859
// continue ;
86857: GO 85131
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
86859: LD_VAR 0 18
86863: PUSH
86864: LD_VAR 0 4
86868: PUSH
86869: LD_VAR 0 7
86873: ARRAY
86874: PPUSH
86875: CALL_OW 310
86879: NOT
86880: AND
86881: PUSH
86882: LD_VAR 0 14
86886: PUSH
86887: LD_INT 1
86889: ARRAY
86890: PUSH
86891: LD_VAR 0 14
86895: PPUSH
86896: LD_INT 21
86898: PUSH
86899: LD_INT 2
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 58
86908: PUSH
86909: EMPTY
86910: LIST
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PPUSH
86916: CALL_OW 72
86920: IN
86921: AND
86922: IFFALSE 86958
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
86924: LD_VAR 0 4
86928: PUSH
86929: LD_VAR 0 7
86933: ARRAY
86934: PPUSH
86935: LD_VAR 0 14
86939: PUSH
86940: LD_INT 1
86942: ARRAY
86943: PPUSH
86944: CALL_OW 120
// attacking := true ;
86948: LD_ADDR_VAR 0 29
86952: PUSH
86953: LD_INT 1
86955: ST_TO_ADDR
// continue ;
86956: GO 85131
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
86958: LD_VAR 0 26
86962: PUSH
86963: LD_VAR 0 4
86967: PUSH
86968: LD_VAR 0 7
86972: ARRAY
86973: PPUSH
86974: CALL_OW 257
86978: PUSH
86979: LD_INT 1
86981: EQUAL
86982: AND
86983: PUSH
86984: LD_VAR 0 4
86988: PUSH
86989: LD_VAR 0 7
86993: ARRAY
86994: PPUSH
86995: CALL_OW 256
86999: PUSH
87000: LD_INT 800
87002: LESS
87003: AND
87004: PUSH
87005: LD_VAR 0 4
87009: PUSH
87010: LD_VAR 0 7
87014: ARRAY
87015: PPUSH
87016: CALL_OW 318
87020: NOT
87021: AND
87022: IFFALSE 87039
// ComCrawl ( group [ i ] ) ;
87024: LD_VAR 0 4
87028: PUSH
87029: LD_VAR 0 7
87033: ARRAY
87034: PPUSH
87035: CALL_OW 137
// if f_mines then
87039: LD_VAR 0 21
87043: IFFALSE 87286
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
87045: LD_VAR 0 14
87049: PUSH
87050: LD_INT 1
87052: ARRAY
87053: PPUSH
87054: CALL_OW 247
87058: PUSH
87059: LD_INT 3
87061: EQUAL
87062: PUSH
87063: LD_VAR 0 14
87067: PUSH
87068: LD_INT 1
87070: ARRAY
87071: PUSH
87072: LD_VAR 0 27
87076: IN
87077: NOT
87078: AND
87079: IFFALSE 87286
// begin x := GetX ( tmp [ 1 ] ) ;
87081: LD_ADDR_VAR 0 10
87085: PUSH
87086: LD_VAR 0 14
87090: PUSH
87091: LD_INT 1
87093: ARRAY
87094: PPUSH
87095: CALL_OW 250
87099: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
87100: LD_ADDR_VAR 0 11
87104: PUSH
87105: LD_VAR 0 14
87109: PUSH
87110: LD_INT 1
87112: ARRAY
87113: PPUSH
87114: CALL_OW 251
87118: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
87119: LD_ADDR_VAR 0 12
87123: PUSH
87124: LD_VAR 0 4
87128: PUSH
87129: LD_VAR 0 7
87133: ARRAY
87134: PPUSH
87135: CALL 44053 0 1
87139: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
87140: LD_VAR 0 4
87144: PUSH
87145: LD_VAR 0 7
87149: ARRAY
87150: PPUSH
87151: LD_VAR 0 10
87155: PPUSH
87156: LD_VAR 0 11
87160: PPUSH
87161: LD_VAR 0 14
87165: PUSH
87166: LD_INT 1
87168: ARRAY
87169: PPUSH
87170: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
87174: LD_VAR 0 4
87178: PUSH
87179: LD_VAR 0 7
87183: ARRAY
87184: PPUSH
87185: LD_VAR 0 10
87189: PPUSH
87190: LD_VAR 0 12
87194: PPUSH
87195: LD_INT 7
87197: PPUSH
87198: CALL_OW 272
87202: PPUSH
87203: LD_VAR 0 11
87207: PPUSH
87208: LD_VAR 0 12
87212: PPUSH
87213: LD_INT 7
87215: PPUSH
87216: CALL_OW 273
87220: PPUSH
87221: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
87225: LD_VAR 0 4
87229: PUSH
87230: LD_VAR 0 7
87234: ARRAY
87235: PPUSH
87236: LD_INT 71
87238: PPUSH
87239: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
87243: LD_ADDR_VAR 0 27
87247: PUSH
87248: LD_VAR 0 27
87252: PPUSH
87253: LD_VAR 0 27
87257: PUSH
87258: LD_INT 1
87260: PLUS
87261: PPUSH
87262: LD_VAR 0 14
87266: PUSH
87267: LD_INT 1
87269: ARRAY
87270: PPUSH
87271: CALL_OW 1
87275: ST_TO_ADDR
// attacking := true ;
87276: LD_ADDR_VAR 0 29
87280: PUSH
87281: LD_INT 1
87283: ST_TO_ADDR
// continue ;
87284: GO 85131
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
87286: LD_VAR 0 4
87290: PUSH
87291: LD_VAR 0 7
87295: ARRAY
87296: PPUSH
87297: CALL_OW 257
87301: PUSH
87302: LD_INT 17
87304: EQUAL
87305: PUSH
87306: LD_VAR 0 4
87310: PUSH
87311: LD_VAR 0 7
87315: ARRAY
87316: PPUSH
87317: CALL_OW 110
87321: PUSH
87322: LD_INT 71
87324: EQUAL
87325: NOT
87326: AND
87327: IFFALSE 87473
// begin attacking := false ;
87329: LD_ADDR_VAR 0 29
87333: PUSH
87334: LD_INT 0
87336: ST_TO_ADDR
// k := 5 ;
87337: LD_ADDR_VAR 0 9
87341: PUSH
87342: LD_INT 5
87344: ST_TO_ADDR
// if tmp < k then
87345: LD_VAR 0 14
87349: PUSH
87350: LD_VAR 0 9
87354: LESS
87355: IFFALSE 87367
// k := tmp ;
87357: LD_ADDR_VAR 0 9
87361: PUSH
87362: LD_VAR 0 14
87366: ST_TO_ADDR
// for j = 1 to k do
87367: LD_ADDR_VAR 0 8
87371: PUSH
87372: DOUBLE
87373: LD_INT 1
87375: DEC
87376: ST_TO_ADDR
87377: LD_VAR 0 9
87381: PUSH
87382: FOR_TO
87383: IFFALSE 87471
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
87385: LD_VAR 0 14
87389: PUSH
87390: LD_VAR 0 8
87394: ARRAY
87395: PUSH
87396: LD_VAR 0 14
87400: PPUSH
87401: LD_INT 58
87403: PUSH
87404: EMPTY
87405: LIST
87406: PPUSH
87407: CALL_OW 72
87411: IN
87412: NOT
87413: IFFALSE 87469
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87415: LD_VAR 0 4
87419: PUSH
87420: LD_VAR 0 7
87424: ARRAY
87425: PPUSH
87426: LD_VAR 0 14
87430: PUSH
87431: LD_VAR 0 8
87435: ARRAY
87436: PPUSH
87437: CALL_OW 115
// attacking := true ;
87441: LD_ADDR_VAR 0 29
87445: PUSH
87446: LD_INT 1
87448: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
87449: LD_VAR 0 4
87453: PUSH
87454: LD_VAR 0 7
87458: ARRAY
87459: PPUSH
87460: LD_INT 71
87462: PPUSH
87463: CALL_OW 109
// continue ;
87467: GO 87382
// end ; end ;
87469: GO 87382
87471: POP
87472: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
87473: LD_VAR 0 4
87477: PUSH
87478: LD_VAR 0 7
87482: ARRAY
87483: PPUSH
87484: CALL_OW 257
87488: PUSH
87489: LD_INT 8
87491: EQUAL
87492: PUSH
87493: LD_VAR 0 4
87497: PUSH
87498: LD_VAR 0 7
87502: ARRAY
87503: PPUSH
87504: CALL_OW 264
87508: PUSH
87509: LD_INT 28
87511: PUSH
87512: LD_INT 45
87514: PUSH
87515: LD_INT 7
87517: PUSH
87518: LD_INT 47
87520: PUSH
87521: EMPTY
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: IN
87527: OR
87528: IFFALSE 87784
// begin attacking := false ;
87530: LD_ADDR_VAR 0 29
87534: PUSH
87535: LD_INT 0
87537: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
87538: LD_VAR 0 14
87542: PUSH
87543: LD_INT 1
87545: ARRAY
87546: PPUSH
87547: CALL_OW 266
87551: PUSH
87552: LD_INT 32
87554: PUSH
87555: LD_INT 31
87557: PUSH
87558: LD_INT 33
87560: PUSH
87561: LD_INT 4
87563: PUSH
87564: LD_INT 5
87566: PUSH
87567: EMPTY
87568: LIST
87569: LIST
87570: LIST
87571: LIST
87572: LIST
87573: IN
87574: IFFALSE 87760
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
87576: LD_ADDR_VAR 0 9
87580: PUSH
87581: LD_VAR 0 14
87585: PUSH
87586: LD_INT 1
87588: ARRAY
87589: PPUSH
87590: CALL_OW 266
87594: PPUSH
87595: LD_VAR 0 14
87599: PUSH
87600: LD_INT 1
87602: ARRAY
87603: PPUSH
87604: CALL_OW 250
87608: PPUSH
87609: LD_VAR 0 14
87613: PUSH
87614: LD_INT 1
87616: ARRAY
87617: PPUSH
87618: CALL_OW 251
87622: PPUSH
87623: LD_VAR 0 14
87627: PUSH
87628: LD_INT 1
87630: ARRAY
87631: PPUSH
87632: CALL_OW 254
87636: PPUSH
87637: LD_VAR 0 14
87641: PUSH
87642: LD_INT 1
87644: ARRAY
87645: PPUSH
87646: CALL_OW 248
87650: PPUSH
87651: LD_INT 0
87653: PPUSH
87654: CALL 25423 0 6
87658: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
87659: LD_ADDR_VAR 0 8
87663: PUSH
87664: LD_VAR 0 4
87668: PUSH
87669: LD_VAR 0 7
87673: ARRAY
87674: PPUSH
87675: LD_VAR 0 9
87679: PPUSH
87680: CALL 44166 0 2
87684: ST_TO_ADDR
// if j then
87685: LD_VAR 0 8
87689: IFFALSE 87758
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
87691: LD_VAR 0 8
87695: PUSH
87696: LD_INT 1
87698: ARRAY
87699: PPUSH
87700: LD_VAR 0 8
87704: PUSH
87705: LD_INT 2
87707: ARRAY
87708: PPUSH
87709: CALL_OW 488
87713: IFFALSE 87758
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
87715: LD_VAR 0 4
87719: PUSH
87720: LD_VAR 0 7
87724: ARRAY
87725: PPUSH
87726: LD_VAR 0 8
87730: PUSH
87731: LD_INT 1
87733: ARRAY
87734: PPUSH
87735: LD_VAR 0 8
87739: PUSH
87740: LD_INT 2
87742: ARRAY
87743: PPUSH
87744: CALL_OW 116
// attacking := true ;
87748: LD_ADDR_VAR 0 29
87752: PUSH
87753: LD_INT 1
87755: ST_TO_ADDR
// continue ;
87756: GO 85131
// end ; end else
87758: GO 87784
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87760: LD_VAR 0 4
87764: PUSH
87765: LD_VAR 0 7
87769: ARRAY
87770: PPUSH
87771: LD_VAR 0 14
87775: PUSH
87776: LD_INT 1
87778: ARRAY
87779: PPUSH
87780: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
87784: LD_VAR 0 4
87788: PUSH
87789: LD_VAR 0 7
87793: ARRAY
87794: PPUSH
87795: CALL_OW 265
87799: PUSH
87800: LD_INT 11
87802: EQUAL
87803: IFFALSE 88081
// begin k := 10 ;
87805: LD_ADDR_VAR 0 9
87809: PUSH
87810: LD_INT 10
87812: ST_TO_ADDR
// x := 0 ;
87813: LD_ADDR_VAR 0 10
87817: PUSH
87818: LD_INT 0
87820: ST_TO_ADDR
// if tmp < k then
87821: LD_VAR 0 14
87825: PUSH
87826: LD_VAR 0 9
87830: LESS
87831: IFFALSE 87843
// k := tmp ;
87833: LD_ADDR_VAR 0 9
87837: PUSH
87838: LD_VAR 0 14
87842: ST_TO_ADDR
// for j = k downto 1 do
87843: LD_ADDR_VAR 0 8
87847: PUSH
87848: DOUBLE
87849: LD_VAR 0 9
87853: INC
87854: ST_TO_ADDR
87855: LD_INT 1
87857: PUSH
87858: FOR_DOWNTO
87859: IFFALSE 87934
// begin if GetType ( tmp [ j ] ) = unit_human then
87861: LD_VAR 0 14
87865: PUSH
87866: LD_VAR 0 8
87870: ARRAY
87871: PPUSH
87872: CALL_OW 247
87876: PUSH
87877: LD_INT 1
87879: EQUAL
87880: IFFALSE 87932
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
87882: LD_VAR 0 4
87886: PUSH
87887: LD_VAR 0 7
87891: ARRAY
87892: PPUSH
87893: LD_VAR 0 14
87897: PUSH
87898: LD_VAR 0 8
87902: ARRAY
87903: PPUSH
87904: CALL 44420 0 2
// x := tmp [ j ] ;
87908: LD_ADDR_VAR 0 10
87912: PUSH
87913: LD_VAR 0 14
87917: PUSH
87918: LD_VAR 0 8
87922: ARRAY
87923: ST_TO_ADDR
// attacking := true ;
87924: LD_ADDR_VAR 0 29
87928: PUSH
87929: LD_INT 1
87931: ST_TO_ADDR
// end ; end ;
87932: GO 87858
87934: POP
87935: POP
// if not x then
87936: LD_VAR 0 10
87940: NOT
87941: IFFALSE 88081
// begin attacking := true ;
87943: LD_ADDR_VAR 0 29
87947: PUSH
87948: LD_INT 1
87950: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
87951: LD_VAR 0 4
87955: PUSH
87956: LD_VAR 0 7
87960: ARRAY
87961: PPUSH
87962: CALL_OW 250
87966: PPUSH
87967: LD_VAR 0 4
87971: PUSH
87972: LD_VAR 0 7
87976: ARRAY
87977: PPUSH
87978: CALL_OW 251
87982: PPUSH
87983: CALL_OW 546
87987: PUSH
87988: LD_INT 2
87990: ARRAY
87991: PUSH
87992: LD_VAR 0 14
87996: PUSH
87997: LD_INT 1
87999: ARRAY
88000: PPUSH
88001: CALL_OW 250
88005: PPUSH
88006: LD_VAR 0 14
88010: PUSH
88011: LD_INT 1
88013: ARRAY
88014: PPUSH
88015: CALL_OW 251
88019: PPUSH
88020: CALL_OW 546
88024: PUSH
88025: LD_INT 2
88027: ARRAY
88028: EQUAL
88029: IFFALSE 88057
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
88031: LD_VAR 0 4
88035: PUSH
88036: LD_VAR 0 7
88040: ARRAY
88041: PPUSH
88042: LD_VAR 0 14
88046: PUSH
88047: LD_INT 1
88049: ARRAY
88050: PPUSH
88051: CALL 44420 0 2
88055: GO 88081
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88057: LD_VAR 0 4
88061: PUSH
88062: LD_VAR 0 7
88066: ARRAY
88067: PPUSH
88068: LD_VAR 0 14
88072: PUSH
88073: LD_INT 1
88075: ARRAY
88076: PPUSH
88077: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
88081: LD_VAR 0 4
88085: PUSH
88086: LD_VAR 0 7
88090: ARRAY
88091: PPUSH
88092: CALL_OW 264
88096: PUSH
88097: LD_INT 29
88099: EQUAL
88100: IFFALSE 88466
// begin if WantsToAttack ( group [ i ] ) in bombed then
88102: LD_VAR 0 4
88106: PUSH
88107: LD_VAR 0 7
88111: ARRAY
88112: PPUSH
88113: CALL_OW 319
88117: PUSH
88118: LD_VAR 0 28
88122: IN
88123: IFFALSE 88127
// continue ;
88125: GO 85131
// k := 8 ;
88127: LD_ADDR_VAR 0 9
88131: PUSH
88132: LD_INT 8
88134: ST_TO_ADDR
// x := 0 ;
88135: LD_ADDR_VAR 0 10
88139: PUSH
88140: LD_INT 0
88142: ST_TO_ADDR
// if tmp < k then
88143: LD_VAR 0 14
88147: PUSH
88148: LD_VAR 0 9
88152: LESS
88153: IFFALSE 88165
// k := tmp ;
88155: LD_ADDR_VAR 0 9
88159: PUSH
88160: LD_VAR 0 14
88164: ST_TO_ADDR
// for j = 1 to k do
88165: LD_ADDR_VAR 0 8
88169: PUSH
88170: DOUBLE
88171: LD_INT 1
88173: DEC
88174: ST_TO_ADDR
88175: LD_VAR 0 9
88179: PUSH
88180: FOR_TO
88181: IFFALSE 88313
// begin if GetType ( tmp [ j ] ) = unit_building then
88183: LD_VAR 0 14
88187: PUSH
88188: LD_VAR 0 8
88192: ARRAY
88193: PPUSH
88194: CALL_OW 247
88198: PUSH
88199: LD_INT 3
88201: EQUAL
88202: IFFALSE 88311
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
88204: LD_VAR 0 14
88208: PUSH
88209: LD_VAR 0 8
88213: ARRAY
88214: PUSH
88215: LD_VAR 0 28
88219: IN
88220: NOT
88221: PUSH
88222: LD_VAR 0 14
88226: PUSH
88227: LD_VAR 0 8
88231: ARRAY
88232: PPUSH
88233: CALL_OW 313
88237: AND
88238: IFFALSE 88311
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88240: LD_VAR 0 4
88244: PUSH
88245: LD_VAR 0 7
88249: ARRAY
88250: PPUSH
88251: LD_VAR 0 14
88255: PUSH
88256: LD_VAR 0 8
88260: ARRAY
88261: PPUSH
88262: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
88266: LD_ADDR_VAR 0 28
88270: PUSH
88271: LD_VAR 0 28
88275: PPUSH
88276: LD_VAR 0 28
88280: PUSH
88281: LD_INT 1
88283: PLUS
88284: PPUSH
88285: LD_VAR 0 14
88289: PUSH
88290: LD_VAR 0 8
88294: ARRAY
88295: PPUSH
88296: CALL_OW 1
88300: ST_TO_ADDR
// attacking := true ;
88301: LD_ADDR_VAR 0 29
88305: PUSH
88306: LD_INT 1
88308: ST_TO_ADDR
// break ;
88309: GO 88313
// end ; end ;
88311: GO 88180
88313: POP
88314: POP
// if not attacking and f_attack_depot then
88315: LD_VAR 0 29
88319: NOT
88320: PUSH
88321: LD_VAR 0 25
88325: AND
88326: IFFALSE 88421
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88328: LD_ADDR_VAR 0 13
88332: PUSH
88333: LD_VAR 0 14
88337: PPUSH
88338: LD_INT 2
88340: PUSH
88341: LD_INT 30
88343: PUSH
88344: LD_INT 0
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 30
88353: PUSH
88354: LD_INT 1
88356: PUSH
88357: EMPTY
88358: LIST
88359: LIST
88360: PUSH
88361: EMPTY
88362: LIST
88363: LIST
88364: LIST
88365: PPUSH
88366: CALL_OW 72
88370: ST_TO_ADDR
// if z then
88371: LD_VAR 0 13
88375: IFFALSE 88421
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
88377: LD_VAR 0 4
88381: PUSH
88382: LD_VAR 0 7
88386: ARRAY
88387: PPUSH
88388: LD_VAR 0 13
88392: PPUSH
88393: LD_VAR 0 4
88397: PUSH
88398: LD_VAR 0 7
88402: ARRAY
88403: PPUSH
88404: CALL_OW 74
88408: PPUSH
88409: CALL_OW 115
// attacking := true ;
88413: LD_ADDR_VAR 0 29
88417: PUSH
88418: LD_INT 1
88420: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
88421: LD_VAR 0 4
88425: PUSH
88426: LD_VAR 0 7
88430: ARRAY
88431: PPUSH
88432: CALL_OW 256
88436: PUSH
88437: LD_INT 500
88439: LESS
88440: IFFALSE 88466
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88442: LD_VAR 0 4
88446: PUSH
88447: LD_VAR 0 7
88451: ARRAY
88452: PPUSH
88453: LD_VAR 0 14
88457: PUSH
88458: LD_INT 1
88460: ARRAY
88461: PPUSH
88462: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
88466: LD_VAR 0 4
88470: PUSH
88471: LD_VAR 0 7
88475: ARRAY
88476: PPUSH
88477: CALL_OW 264
88481: PUSH
88482: LD_INT 49
88484: EQUAL
88485: IFFALSE 88606
// begin if not HasTask ( group [ i ] ) then
88487: LD_VAR 0 4
88491: PUSH
88492: LD_VAR 0 7
88496: ARRAY
88497: PPUSH
88498: CALL_OW 314
88502: NOT
88503: IFFALSE 88606
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
88505: LD_ADDR_VAR 0 9
88509: PUSH
88510: LD_INT 81
88512: PUSH
88513: LD_VAR 0 4
88517: PUSH
88518: LD_VAR 0 7
88522: ARRAY
88523: PPUSH
88524: CALL_OW 255
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PPUSH
88533: CALL_OW 69
88537: PPUSH
88538: LD_VAR 0 4
88542: PUSH
88543: LD_VAR 0 7
88547: ARRAY
88548: PPUSH
88549: CALL_OW 74
88553: ST_TO_ADDR
// if k then
88554: LD_VAR 0 9
88558: IFFALSE 88606
// if GetDistUnits ( group [ i ] , k ) > 10 then
88560: LD_VAR 0 4
88564: PUSH
88565: LD_VAR 0 7
88569: ARRAY
88570: PPUSH
88571: LD_VAR 0 9
88575: PPUSH
88576: CALL_OW 296
88580: PUSH
88581: LD_INT 10
88583: GREATER
88584: IFFALSE 88606
// ComMoveUnit ( group [ i ] , k ) ;
88586: LD_VAR 0 4
88590: PUSH
88591: LD_VAR 0 7
88595: ARRAY
88596: PPUSH
88597: LD_VAR 0 9
88601: PPUSH
88602: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
88606: LD_VAR 0 4
88610: PUSH
88611: LD_VAR 0 7
88615: ARRAY
88616: PPUSH
88617: CALL_OW 256
88621: PUSH
88622: LD_INT 250
88624: LESS
88625: PUSH
88626: LD_VAR 0 4
88630: PUSH
88631: LD_VAR 0 7
88635: ARRAY
88636: PUSH
88637: LD_INT 21
88639: PUSH
88640: LD_INT 2
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 23
88649: PUSH
88650: LD_INT 2
88652: PUSH
88653: EMPTY
88654: LIST
88655: LIST
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PPUSH
88661: CALL_OW 69
88665: IN
88666: AND
88667: IFFALSE 88792
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
88669: LD_ADDR_VAR 0 9
88673: PUSH
88674: LD_OWVAR 3
88678: PUSH
88679: LD_VAR 0 4
88683: PUSH
88684: LD_VAR 0 7
88688: ARRAY
88689: DIFF
88690: PPUSH
88691: LD_VAR 0 4
88695: PUSH
88696: LD_VAR 0 7
88700: ARRAY
88701: PPUSH
88702: CALL_OW 74
88706: ST_TO_ADDR
// if not k then
88707: LD_VAR 0 9
88711: NOT
88712: IFFALSE 88716
// continue ;
88714: GO 85131
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
88716: LD_VAR 0 9
88720: PUSH
88721: LD_INT 81
88723: PUSH
88724: LD_VAR 0 4
88728: PUSH
88729: LD_VAR 0 7
88733: ARRAY
88734: PPUSH
88735: CALL_OW 255
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PPUSH
88744: CALL_OW 69
88748: IN
88749: PUSH
88750: LD_VAR 0 9
88754: PPUSH
88755: LD_VAR 0 4
88759: PUSH
88760: LD_VAR 0 7
88764: ARRAY
88765: PPUSH
88766: CALL_OW 296
88770: PUSH
88771: LD_INT 5
88773: LESS
88774: AND
88775: IFFALSE 88792
// ComAutodestruct ( group [ i ] ) ;
88777: LD_VAR 0 4
88781: PUSH
88782: LD_VAR 0 7
88786: ARRAY
88787: PPUSH
88788: CALL 44318 0 1
// end ; if f_attack_depot then
88792: LD_VAR 0 25
88796: IFFALSE 88908
// begin k := 6 ;
88798: LD_ADDR_VAR 0 9
88802: PUSH
88803: LD_INT 6
88805: ST_TO_ADDR
// if tmp < k then
88806: LD_VAR 0 14
88810: PUSH
88811: LD_VAR 0 9
88815: LESS
88816: IFFALSE 88828
// k := tmp ;
88818: LD_ADDR_VAR 0 9
88822: PUSH
88823: LD_VAR 0 14
88827: ST_TO_ADDR
// for j = 1 to k do
88828: LD_ADDR_VAR 0 8
88832: PUSH
88833: DOUBLE
88834: LD_INT 1
88836: DEC
88837: ST_TO_ADDR
88838: LD_VAR 0 9
88842: PUSH
88843: FOR_TO
88844: IFFALSE 88906
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
88846: LD_VAR 0 8
88850: PPUSH
88851: CALL_OW 266
88855: PUSH
88856: LD_INT 0
88858: PUSH
88859: LD_INT 1
88861: PUSH
88862: EMPTY
88863: LIST
88864: LIST
88865: IN
88866: IFFALSE 88904
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88868: LD_VAR 0 4
88872: PUSH
88873: LD_VAR 0 7
88877: ARRAY
88878: PPUSH
88879: LD_VAR 0 14
88883: PUSH
88884: LD_VAR 0 8
88888: ARRAY
88889: PPUSH
88890: CALL_OW 115
// attacking := true ;
88894: LD_ADDR_VAR 0 29
88898: PUSH
88899: LD_INT 1
88901: ST_TO_ADDR
// break ;
88902: GO 88906
// end ;
88904: GO 88843
88906: POP
88907: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
88908: LD_VAR 0 4
88912: PUSH
88913: LD_VAR 0 7
88917: ARRAY
88918: PPUSH
88919: CALL_OW 302
88923: PUSH
88924: LD_VAR 0 29
88928: NOT
88929: AND
88930: IFFALSE 89252
// begin if GetTag ( group [ i ] ) = 71 then
88932: LD_VAR 0 4
88936: PUSH
88937: LD_VAR 0 7
88941: ARRAY
88942: PPUSH
88943: CALL_OW 110
88947: PUSH
88948: LD_INT 71
88950: EQUAL
88951: IFFALSE 88992
// begin if HasTask ( group [ i ] ) then
88953: LD_VAR 0 4
88957: PUSH
88958: LD_VAR 0 7
88962: ARRAY
88963: PPUSH
88964: CALL_OW 314
88968: IFFALSE 88974
// continue else
88970: GO 85131
88972: GO 88992
// SetTag ( group [ i ] , 0 ) ;
88974: LD_VAR 0 4
88978: PUSH
88979: LD_VAR 0 7
88983: ARRAY
88984: PPUSH
88985: LD_INT 0
88987: PPUSH
88988: CALL_OW 109
// end ; k := 8 ;
88992: LD_ADDR_VAR 0 9
88996: PUSH
88997: LD_INT 8
88999: ST_TO_ADDR
// x := 0 ;
89000: LD_ADDR_VAR 0 10
89004: PUSH
89005: LD_INT 0
89007: ST_TO_ADDR
// if tmp < k then
89008: LD_VAR 0 14
89012: PUSH
89013: LD_VAR 0 9
89017: LESS
89018: IFFALSE 89030
// k := tmp ;
89020: LD_ADDR_VAR 0 9
89024: PUSH
89025: LD_VAR 0 14
89029: ST_TO_ADDR
// for j = 1 to k do
89030: LD_ADDR_VAR 0 8
89034: PUSH
89035: DOUBLE
89036: LD_INT 1
89038: DEC
89039: ST_TO_ADDR
89040: LD_VAR 0 9
89044: PUSH
89045: FOR_TO
89046: IFFALSE 89144
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
89048: LD_VAR 0 14
89052: PUSH
89053: LD_VAR 0 8
89057: ARRAY
89058: PPUSH
89059: CALL_OW 247
89063: PUSH
89064: LD_INT 1
89066: EQUAL
89067: PUSH
89068: LD_VAR 0 14
89072: PUSH
89073: LD_VAR 0 8
89077: ARRAY
89078: PPUSH
89079: CALL_OW 256
89083: PUSH
89084: LD_INT 250
89086: LESS
89087: PUSH
89088: LD_VAR 0 20
89092: AND
89093: PUSH
89094: LD_VAR 0 20
89098: NOT
89099: PUSH
89100: LD_VAR 0 14
89104: PUSH
89105: LD_VAR 0 8
89109: ARRAY
89110: PPUSH
89111: CALL_OW 256
89115: PUSH
89116: LD_INT 250
89118: GREATEREQUAL
89119: AND
89120: OR
89121: AND
89122: IFFALSE 89142
// begin x := tmp [ j ] ;
89124: LD_ADDR_VAR 0 10
89128: PUSH
89129: LD_VAR 0 14
89133: PUSH
89134: LD_VAR 0 8
89138: ARRAY
89139: ST_TO_ADDR
// break ;
89140: GO 89144
// end ;
89142: GO 89045
89144: POP
89145: POP
// if x then
89146: LD_VAR 0 10
89150: IFFALSE 89174
// ComAttackUnit ( group [ i ] , x ) else
89152: LD_VAR 0 4
89156: PUSH
89157: LD_VAR 0 7
89161: ARRAY
89162: PPUSH
89163: LD_VAR 0 10
89167: PPUSH
89168: CALL_OW 115
89172: GO 89198
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89174: LD_VAR 0 4
89178: PUSH
89179: LD_VAR 0 7
89183: ARRAY
89184: PPUSH
89185: LD_VAR 0 14
89189: PUSH
89190: LD_INT 1
89192: ARRAY
89193: PPUSH
89194: CALL_OW 115
// if not HasTask ( group [ i ] ) then
89198: LD_VAR 0 4
89202: PUSH
89203: LD_VAR 0 7
89207: ARRAY
89208: PPUSH
89209: CALL_OW 314
89213: NOT
89214: IFFALSE 89252
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
89216: LD_VAR 0 4
89220: PUSH
89221: LD_VAR 0 7
89225: ARRAY
89226: PPUSH
89227: LD_VAR 0 14
89231: PPUSH
89232: LD_VAR 0 4
89236: PUSH
89237: LD_VAR 0 7
89241: ARRAY
89242: PPUSH
89243: CALL_OW 74
89247: PPUSH
89248: CALL_OW 115
// end ; end ; end ;
89252: GO 85131
89254: POP
89255: POP
// wait ( 0 0$2 ) ;
89256: LD_INT 70
89258: PPUSH
89259: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
89263: LD_VAR 0 4
89267: NOT
89268: PUSH
89269: LD_VAR 0 4
89273: PUSH
89274: EMPTY
89275: EQUAL
89276: OR
89277: PUSH
89278: LD_INT 81
89280: PUSH
89281: LD_VAR 0 35
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PPUSH
89290: CALL_OW 69
89294: NOT
89295: OR
89296: IFFALSE 85116
// end ;
89298: LD_VAR 0 2
89302: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
89303: LD_INT 0
89305: PPUSH
89306: PPUSH
89307: PPUSH
89308: PPUSH
89309: PPUSH
89310: PPUSH
// if not base or not mc_bases [ base ] or not solds then
89311: LD_VAR 0 1
89315: NOT
89316: PUSH
89317: LD_EXP 23
89321: PUSH
89322: LD_VAR 0 1
89326: ARRAY
89327: NOT
89328: OR
89329: PUSH
89330: LD_VAR 0 2
89334: NOT
89335: OR
89336: IFFALSE 89340
// exit ;
89338: GO 89894
// side := mc_sides [ base ] ;
89340: LD_ADDR_VAR 0 6
89344: PUSH
89345: LD_EXP 49
89349: PUSH
89350: LD_VAR 0 1
89354: ARRAY
89355: ST_TO_ADDR
// if not side then
89356: LD_VAR 0 6
89360: NOT
89361: IFFALSE 89365
// exit ;
89363: GO 89894
// for i in solds do
89365: LD_ADDR_VAR 0 7
89369: PUSH
89370: LD_VAR 0 2
89374: PUSH
89375: FOR_IN
89376: IFFALSE 89437
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
89378: LD_VAR 0 7
89382: PPUSH
89383: CALL_OW 310
89387: PPUSH
89388: CALL_OW 266
89392: PUSH
89393: LD_INT 32
89395: PUSH
89396: LD_INT 31
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: IN
89403: IFFALSE 89423
// solds := solds diff i else
89405: LD_ADDR_VAR 0 2
89409: PUSH
89410: LD_VAR 0 2
89414: PUSH
89415: LD_VAR 0 7
89419: DIFF
89420: ST_TO_ADDR
89421: GO 89435
// SetTag ( i , 18 ) ;
89423: LD_VAR 0 7
89427: PPUSH
89428: LD_INT 18
89430: PPUSH
89431: CALL_OW 109
89435: GO 89375
89437: POP
89438: POP
// if not solds then
89439: LD_VAR 0 2
89443: NOT
89444: IFFALSE 89448
// exit ;
89446: GO 89894
// repeat wait ( 0 0$2 ) ;
89448: LD_INT 70
89450: PPUSH
89451: CALL_OW 67
// enemy := mc_scan [ base ] ;
89455: LD_ADDR_VAR 0 4
89459: PUSH
89460: LD_EXP 46
89464: PUSH
89465: LD_VAR 0 1
89469: ARRAY
89470: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
89471: LD_EXP 23
89475: PUSH
89476: LD_VAR 0 1
89480: ARRAY
89481: NOT
89482: PUSH
89483: LD_EXP 23
89487: PUSH
89488: LD_VAR 0 1
89492: ARRAY
89493: PUSH
89494: EMPTY
89495: EQUAL
89496: OR
89497: IFFALSE 89534
// begin for i in solds do
89499: LD_ADDR_VAR 0 7
89503: PUSH
89504: LD_VAR 0 2
89508: PUSH
89509: FOR_IN
89510: IFFALSE 89523
// ComStop ( i ) ;
89512: LD_VAR 0 7
89516: PPUSH
89517: CALL_OW 141
89521: GO 89509
89523: POP
89524: POP
// solds := [ ] ;
89525: LD_ADDR_VAR 0 2
89529: PUSH
89530: EMPTY
89531: ST_TO_ADDR
// exit ;
89532: GO 89894
// end ; for i in solds do
89534: LD_ADDR_VAR 0 7
89538: PUSH
89539: LD_VAR 0 2
89543: PUSH
89544: FOR_IN
89545: IFFALSE 89866
// begin if IsInUnit ( i ) then
89547: LD_VAR 0 7
89551: PPUSH
89552: CALL_OW 310
89556: IFFALSE 89567
// ComExitBuilding ( i ) ;
89558: LD_VAR 0 7
89562: PPUSH
89563: CALL_OW 122
// if GetLives ( i ) > 500 then
89567: LD_VAR 0 7
89571: PPUSH
89572: CALL_OW 256
89576: PUSH
89577: LD_INT 500
89579: GREATER
89580: IFFALSE 89633
// begin e := NearestUnitToUnit ( enemy , i ) ;
89582: LD_ADDR_VAR 0 5
89586: PUSH
89587: LD_VAR 0 4
89591: PPUSH
89592: LD_VAR 0 7
89596: PPUSH
89597: CALL_OW 74
89601: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
89602: LD_VAR 0 7
89606: PPUSH
89607: LD_VAR 0 5
89611: PPUSH
89612: CALL_OW 250
89616: PPUSH
89617: LD_VAR 0 5
89621: PPUSH
89622: CALL_OW 251
89626: PPUSH
89627: CALL_OW 114
// end else
89631: GO 89864
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
89633: LD_VAR 0 7
89637: PPUSH
89638: LD_EXP 23
89642: PUSH
89643: LD_VAR 0 1
89647: ARRAY
89648: PPUSH
89649: LD_INT 2
89651: PUSH
89652: LD_INT 30
89654: PUSH
89655: LD_INT 0
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 30
89664: PUSH
89665: LD_INT 1
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 30
89674: PUSH
89675: LD_INT 6
89677: PUSH
89678: EMPTY
89679: LIST
89680: LIST
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: PPUSH
89688: CALL_OW 72
89692: PPUSH
89693: LD_VAR 0 7
89697: PPUSH
89698: CALL_OW 74
89702: PPUSH
89703: CALL_OW 296
89707: PUSH
89708: LD_INT 10
89710: GREATER
89711: IFFALSE 89864
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
89713: LD_ADDR_VAR 0 8
89717: PUSH
89718: LD_EXP 23
89722: PUSH
89723: LD_VAR 0 1
89727: ARRAY
89728: PPUSH
89729: LD_INT 2
89731: PUSH
89732: LD_INT 30
89734: PUSH
89735: LD_INT 0
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 30
89744: PUSH
89745: LD_INT 1
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 30
89754: PUSH
89755: LD_INT 6
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: EMPTY
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: PPUSH
89768: CALL_OW 72
89772: PPUSH
89773: LD_VAR 0 7
89777: PPUSH
89778: CALL_OW 74
89782: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
89783: LD_VAR 0 7
89787: PPUSH
89788: LD_VAR 0 8
89792: PPUSH
89793: CALL_OW 250
89797: PPUSH
89798: LD_INT 3
89800: PPUSH
89801: LD_INT 5
89803: PPUSH
89804: CALL_OW 272
89808: PPUSH
89809: LD_VAR 0 8
89813: PPUSH
89814: CALL_OW 251
89818: PPUSH
89819: LD_INT 3
89821: PPUSH
89822: LD_INT 5
89824: PPUSH
89825: CALL_OW 273
89829: PPUSH
89830: CALL_OW 111
// SetTag ( i , 0 ) ;
89834: LD_VAR 0 7
89838: PPUSH
89839: LD_INT 0
89841: PPUSH
89842: CALL_OW 109
// solds := solds diff i ;
89846: LD_ADDR_VAR 0 2
89850: PUSH
89851: LD_VAR 0 2
89855: PUSH
89856: LD_VAR 0 7
89860: DIFF
89861: ST_TO_ADDR
// continue ;
89862: GO 89544
// end ; end ;
89864: GO 89544
89866: POP
89867: POP
// until not solds or not enemy ;
89868: LD_VAR 0 2
89872: NOT
89873: PUSH
89874: LD_VAR 0 4
89878: NOT
89879: OR
89880: IFFALSE 89448
// MC_Reset ( base , 18 ) ;
89882: LD_VAR 0 1
89886: PPUSH
89887: LD_INT 18
89889: PPUSH
89890: CALL 58055 0 2
// end ;
89894: LD_VAR 0 3
89898: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
89899: LD_INT 0
89901: PPUSH
89902: PPUSH
89903: PPUSH
89904: PPUSH
89905: PPUSH
89906: PPUSH
89907: PPUSH
89908: PPUSH
89909: PPUSH
89910: PPUSH
89911: PPUSH
89912: PPUSH
89913: PPUSH
89914: PPUSH
89915: PPUSH
89916: PPUSH
89917: PPUSH
89918: PPUSH
89919: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
89920: LD_ADDR_VAR 0 12
89924: PUSH
89925: LD_EXP 23
89929: PUSH
89930: LD_VAR 0 1
89934: ARRAY
89935: PPUSH
89936: LD_INT 25
89938: PUSH
89939: LD_INT 3
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PPUSH
89946: CALL_OW 72
89950: ST_TO_ADDR
// if mc_remote_driver [ base ] then
89951: LD_EXP 63
89955: PUSH
89956: LD_VAR 0 1
89960: ARRAY
89961: IFFALSE 89985
// mechs := mechs diff mc_remote_driver [ base ] ;
89963: LD_ADDR_VAR 0 12
89967: PUSH
89968: LD_VAR 0 12
89972: PUSH
89973: LD_EXP 63
89977: PUSH
89978: LD_VAR 0 1
89982: ARRAY
89983: DIFF
89984: ST_TO_ADDR
// for i in mechs do
89985: LD_ADDR_VAR 0 4
89989: PUSH
89990: LD_VAR 0 12
89994: PUSH
89995: FOR_IN
89996: IFFALSE 90031
// if GetTag ( i ) > 0 then
89998: LD_VAR 0 4
90002: PPUSH
90003: CALL_OW 110
90007: PUSH
90008: LD_INT 0
90010: GREATER
90011: IFFALSE 90029
// mechs := mechs diff i ;
90013: LD_ADDR_VAR 0 12
90017: PUSH
90018: LD_VAR 0 12
90022: PUSH
90023: LD_VAR 0 4
90027: DIFF
90028: ST_TO_ADDR
90029: GO 89995
90031: POP
90032: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
90033: LD_ADDR_VAR 0 8
90037: PUSH
90038: LD_EXP 23
90042: PUSH
90043: LD_VAR 0 1
90047: ARRAY
90048: PPUSH
90049: LD_INT 2
90051: PUSH
90052: LD_INT 25
90054: PUSH
90055: LD_INT 1
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 25
90064: PUSH
90065: LD_INT 5
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 25
90074: PUSH
90075: LD_INT 8
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 25
90084: PUSH
90085: LD_INT 9
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: PPUSH
90099: CALL_OW 72
90103: ST_TO_ADDR
// if not defenders and not solds then
90104: LD_VAR 0 2
90108: NOT
90109: PUSH
90110: LD_VAR 0 8
90114: NOT
90115: AND
90116: IFFALSE 90120
// exit ;
90118: GO 91890
// depot_under_attack := false ;
90120: LD_ADDR_VAR 0 16
90124: PUSH
90125: LD_INT 0
90127: ST_TO_ADDR
// sold_defenders := [ ] ;
90128: LD_ADDR_VAR 0 17
90132: PUSH
90133: EMPTY
90134: ST_TO_ADDR
// if mechs then
90135: LD_VAR 0 12
90139: IFFALSE 90292
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
90141: LD_ADDR_VAR 0 4
90145: PUSH
90146: LD_VAR 0 2
90150: PPUSH
90151: LD_INT 21
90153: PUSH
90154: LD_INT 2
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: PPUSH
90161: CALL_OW 72
90165: PUSH
90166: FOR_IN
90167: IFFALSE 90290
// begin if GetTag ( i ) <> 20 then
90169: LD_VAR 0 4
90173: PPUSH
90174: CALL_OW 110
90178: PUSH
90179: LD_INT 20
90181: NONEQUAL
90182: IFFALSE 90196
// SetTag ( i , 20 ) ;
90184: LD_VAR 0 4
90188: PPUSH
90189: LD_INT 20
90191: PPUSH
90192: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
90196: LD_VAR 0 4
90200: PPUSH
90201: CALL_OW 263
90205: PUSH
90206: LD_INT 1
90208: EQUAL
90209: PUSH
90210: LD_VAR 0 4
90214: PPUSH
90215: CALL_OW 311
90219: NOT
90220: AND
90221: IFFALSE 90288
// begin un := mechs [ 1 ] ;
90223: LD_ADDR_VAR 0 10
90227: PUSH
90228: LD_VAR 0 12
90232: PUSH
90233: LD_INT 1
90235: ARRAY
90236: ST_TO_ADDR
// ComExit ( un ) ;
90237: LD_VAR 0 10
90241: PPUSH
90242: CALL 49204 0 1
// AddComEnterUnit ( un , i ) ;
90246: LD_VAR 0 10
90250: PPUSH
90251: LD_VAR 0 4
90255: PPUSH
90256: CALL_OW 180
// SetTag ( un , 19 ) ;
90260: LD_VAR 0 10
90264: PPUSH
90265: LD_INT 19
90267: PPUSH
90268: CALL_OW 109
// mechs := mechs diff un ;
90272: LD_ADDR_VAR 0 12
90276: PUSH
90277: LD_VAR 0 12
90281: PUSH
90282: LD_VAR 0 10
90286: DIFF
90287: ST_TO_ADDR
// end ; end ;
90288: GO 90166
90290: POP
90291: POP
// if solds then
90292: LD_VAR 0 8
90296: IFFALSE 90355
// for i in solds do
90298: LD_ADDR_VAR 0 4
90302: PUSH
90303: LD_VAR 0 8
90307: PUSH
90308: FOR_IN
90309: IFFALSE 90353
// if not GetTag ( i ) then
90311: LD_VAR 0 4
90315: PPUSH
90316: CALL_OW 110
90320: NOT
90321: IFFALSE 90351
// begin defenders := defenders union i ;
90323: LD_ADDR_VAR 0 2
90327: PUSH
90328: LD_VAR 0 2
90332: PUSH
90333: LD_VAR 0 4
90337: UNION
90338: ST_TO_ADDR
// SetTag ( i , 18 ) ;
90339: LD_VAR 0 4
90343: PPUSH
90344: LD_INT 18
90346: PPUSH
90347: CALL_OW 109
// end ;
90351: GO 90308
90353: POP
90354: POP
// repeat wait ( 0 0$2 ) ;
90355: LD_INT 70
90357: PPUSH
90358: CALL_OW 67
// enemy := mc_scan [ base ] ;
90362: LD_ADDR_VAR 0 21
90366: PUSH
90367: LD_EXP 46
90371: PUSH
90372: LD_VAR 0 1
90376: ARRAY
90377: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90378: LD_EXP 23
90382: PUSH
90383: LD_VAR 0 1
90387: ARRAY
90388: NOT
90389: PUSH
90390: LD_EXP 23
90394: PUSH
90395: LD_VAR 0 1
90399: ARRAY
90400: PUSH
90401: EMPTY
90402: EQUAL
90403: OR
90404: IFFALSE 90441
// begin for i in defenders do
90406: LD_ADDR_VAR 0 4
90410: PUSH
90411: LD_VAR 0 2
90415: PUSH
90416: FOR_IN
90417: IFFALSE 90430
// ComStop ( i ) ;
90419: LD_VAR 0 4
90423: PPUSH
90424: CALL_OW 141
90428: GO 90416
90430: POP
90431: POP
// defenders := [ ] ;
90432: LD_ADDR_VAR 0 2
90436: PUSH
90437: EMPTY
90438: ST_TO_ADDR
// exit ;
90439: GO 91890
// end ; for i in defenders do
90441: LD_ADDR_VAR 0 4
90445: PUSH
90446: LD_VAR 0 2
90450: PUSH
90451: FOR_IN
90452: IFFALSE 91350
// begin e := NearestUnitToUnit ( enemy , i ) ;
90454: LD_ADDR_VAR 0 13
90458: PUSH
90459: LD_VAR 0 21
90463: PPUSH
90464: LD_VAR 0 4
90468: PPUSH
90469: CALL_OW 74
90473: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
90474: LD_ADDR_VAR 0 7
90478: PUSH
90479: LD_EXP 23
90483: PUSH
90484: LD_VAR 0 1
90488: ARRAY
90489: PPUSH
90490: LD_INT 2
90492: PUSH
90493: LD_INT 30
90495: PUSH
90496: LD_INT 0
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 30
90505: PUSH
90506: LD_INT 1
90508: PUSH
90509: EMPTY
90510: LIST
90511: LIST
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: LIST
90517: PPUSH
90518: CALL_OW 72
90522: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
90523: LD_ADDR_VAR 0 16
90527: PUSH
90528: LD_VAR 0 7
90532: NOT
90533: PUSH
90534: LD_VAR 0 7
90538: PPUSH
90539: LD_INT 3
90541: PUSH
90542: LD_INT 24
90544: PUSH
90545: LD_INT 600
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PUSH
90552: EMPTY
90553: LIST
90554: LIST
90555: PPUSH
90556: CALL_OW 72
90560: OR
90561: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
90562: LD_VAR 0 4
90566: PPUSH
90567: CALL_OW 247
90571: PUSH
90572: LD_INT 2
90574: DOUBLE
90575: EQUAL
90576: IFTRUE 90580
90578: GO 90976
90580: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
90581: LD_VAR 0 4
90585: PPUSH
90586: CALL_OW 256
90590: PUSH
90591: LD_INT 1000
90593: EQUAL
90594: PUSH
90595: LD_VAR 0 4
90599: PPUSH
90600: LD_VAR 0 13
90604: PPUSH
90605: CALL_OW 296
90609: PUSH
90610: LD_INT 40
90612: LESS
90613: PUSH
90614: LD_VAR 0 13
90618: PPUSH
90619: LD_EXP 48
90623: PUSH
90624: LD_VAR 0 1
90628: ARRAY
90629: PPUSH
90630: CALL_OW 308
90634: OR
90635: AND
90636: IFFALSE 90758
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
90638: LD_VAR 0 4
90642: PPUSH
90643: CALL_OW 262
90647: PUSH
90648: LD_INT 1
90650: EQUAL
90651: PUSH
90652: LD_VAR 0 4
90656: PPUSH
90657: CALL_OW 261
90661: PUSH
90662: LD_INT 30
90664: LESS
90665: AND
90666: PUSH
90667: LD_VAR 0 7
90671: AND
90672: IFFALSE 90742
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
90674: LD_VAR 0 4
90678: PPUSH
90679: LD_VAR 0 7
90683: PPUSH
90684: LD_VAR 0 4
90688: PPUSH
90689: CALL_OW 74
90693: PPUSH
90694: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
90698: LD_VAR 0 4
90702: PPUSH
90703: LD_VAR 0 7
90707: PPUSH
90708: LD_VAR 0 4
90712: PPUSH
90713: CALL_OW 74
90717: PPUSH
90718: CALL_OW 296
90722: PUSH
90723: LD_INT 6
90725: LESS
90726: IFFALSE 90740
// SetFuel ( i , 100 ) ;
90728: LD_VAR 0 4
90732: PPUSH
90733: LD_INT 100
90735: PPUSH
90736: CALL_OW 240
// end else
90740: GO 90756
// ComAttackUnit ( i , e ) ;
90742: LD_VAR 0 4
90746: PPUSH
90747: LD_VAR 0 13
90751: PPUSH
90752: CALL_OW 115
// end else
90756: GO 90859
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
90758: LD_VAR 0 13
90762: PPUSH
90763: LD_EXP 48
90767: PUSH
90768: LD_VAR 0 1
90772: ARRAY
90773: PPUSH
90774: CALL_OW 308
90778: NOT
90779: PUSH
90780: LD_VAR 0 4
90784: PPUSH
90785: LD_VAR 0 13
90789: PPUSH
90790: CALL_OW 296
90794: PUSH
90795: LD_INT 40
90797: GREATEREQUAL
90798: AND
90799: PUSH
90800: LD_VAR 0 4
90804: PPUSH
90805: CALL_OW 256
90809: PUSH
90810: LD_INT 650
90812: LESSEQUAL
90813: OR
90814: PUSH
90815: LD_VAR 0 4
90819: PPUSH
90820: LD_EXP 47
90824: PUSH
90825: LD_VAR 0 1
90829: ARRAY
90830: PPUSH
90831: CALL_OW 308
90835: NOT
90836: AND
90837: IFFALSE 90859
// ComMoveToArea ( i , mc_parking [ base ] ) ;
90839: LD_VAR 0 4
90843: PPUSH
90844: LD_EXP 47
90848: PUSH
90849: LD_VAR 0 1
90853: ARRAY
90854: PPUSH
90855: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
90859: LD_VAR 0 4
90863: PPUSH
90864: CALL_OW 256
90868: PUSH
90869: LD_INT 1000
90871: LESS
90872: PUSH
90873: LD_VAR 0 4
90877: PPUSH
90878: CALL_OW 263
90882: PUSH
90883: LD_INT 1
90885: EQUAL
90886: AND
90887: PUSH
90888: LD_VAR 0 4
90892: PPUSH
90893: CALL_OW 311
90897: AND
90898: PUSH
90899: LD_VAR 0 4
90903: PPUSH
90904: LD_EXP 47
90908: PUSH
90909: LD_VAR 0 1
90913: ARRAY
90914: PPUSH
90915: CALL_OW 308
90919: AND
90920: IFFALSE 90974
// begin mech := IsDrivenBy ( i ) ;
90922: LD_ADDR_VAR 0 9
90926: PUSH
90927: LD_VAR 0 4
90931: PPUSH
90932: CALL_OW 311
90936: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
90937: LD_VAR 0 9
90941: PPUSH
90942: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
90946: LD_VAR 0 9
90950: PPUSH
90951: LD_VAR 0 4
90955: PPUSH
90956: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
90960: LD_VAR 0 9
90964: PPUSH
90965: LD_VAR 0 4
90969: PPUSH
90970: CALL_OW 180
// end ; end ; unit_human :
90974: GO 91321
90976: LD_INT 1
90978: DOUBLE
90979: EQUAL
90980: IFTRUE 90984
90982: GO 91320
90984: POP
// begin b := IsInUnit ( i ) ;
90985: LD_ADDR_VAR 0 18
90989: PUSH
90990: LD_VAR 0 4
90994: PPUSH
90995: CALL_OW 310
90999: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
91000: LD_ADDR_VAR 0 19
91004: PUSH
91005: LD_VAR 0 18
91009: NOT
91010: PUSH
91011: LD_VAR 0 18
91015: PPUSH
91016: CALL_OW 266
91020: PUSH
91021: LD_INT 32
91023: PUSH
91024: LD_INT 31
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: IN
91031: OR
91032: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
91033: LD_VAR 0 18
91037: PPUSH
91038: CALL_OW 266
91042: PUSH
91043: LD_INT 5
91045: EQUAL
91046: PUSH
91047: LD_VAR 0 4
91051: PPUSH
91052: CALL_OW 257
91056: PUSH
91057: LD_INT 1
91059: PUSH
91060: LD_INT 2
91062: PUSH
91063: LD_INT 3
91065: PUSH
91066: LD_INT 4
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: IN
91075: AND
91076: IFFALSE 91113
// begin class := AllowSpecClass ( i ) ;
91078: LD_ADDR_VAR 0 20
91082: PUSH
91083: LD_VAR 0 4
91087: PPUSH
91088: CALL 12901 0 1
91092: ST_TO_ADDR
// if class then
91093: LD_VAR 0 20
91097: IFFALSE 91113
// ComChangeProfession ( i , class ) ;
91099: LD_VAR 0 4
91103: PPUSH
91104: LD_VAR 0 20
91108: PPUSH
91109: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
91113: LD_VAR 0 16
91117: PUSH
91118: LD_VAR 0 2
91122: PPUSH
91123: LD_INT 21
91125: PUSH
91126: LD_INT 2
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PPUSH
91133: CALL_OW 72
91137: PUSH
91138: LD_INT 1
91140: LESSEQUAL
91141: OR
91142: PUSH
91143: LD_VAR 0 19
91147: AND
91148: PUSH
91149: LD_VAR 0 4
91153: PUSH
91154: LD_VAR 0 17
91158: IN
91159: NOT
91160: AND
91161: IFFALSE 91254
// begin if b then
91163: LD_VAR 0 18
91167: IFFALSE 91216
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
91169: LD_VAR 0 18
91173: PPUSH
91174: LD_VAR 0 21
91178: PPUSH
91179: LD_VAR 0 18
91183: PPUSH
91184: CALL_OW 74
91188: PPUSH
91189: CALL_OW 296
91193: PUSH
91194: LD_INT 10
91196: LESS
91197: PUSH
91198: LD_VAR 0 18
91202: PPUSH
91203: CALL_OW 461
91207: PUSH
91208: LD_INT 7
91210: NONEQUAL
91211: AND
91212: IFFALSE 91216
// continue ;
91214: GO 90451
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
91216: LD_ADDR_VAR 0 17
91220: PUSH
91221: LD_VAR 0 17
91225: PPUSH
91226: LD_VAR 0 17
91230: PUSH
91231: LD_INT 1
91233: PLUS
91234: PPUSH
91235: LD_VAR 0 4
91239: PPUSH
91240: CALL_OW 1
91244: ST_TO_ADDR
// ComExitBuilding ( i ) ;
91245: LD_VAR 0 4
91249: PPUSH
91250: CALL_OW 122
// end ; if sold_defenders then
91254: LD_VAR 0 17
91258: IFFALSE 91318
// if i in sold_defenders then
91260: LD_VAR 0 4
91264: PUSH
91265: LD_VAR 0 17
91269: IN
91270: IFFALSE 91318
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
91272: LD_VAR 0 4
91276: PPUSH
91277: CALL_OW 314
91281: NOT
91282: PUSH
91283: LD_VAR 0 4
91287: PPUSH
91288: LD_VAR 0 13
91292: PPUSH
91293: CALL_OW 296
91297: PUSH
91298: LD_INT 30
91300: LESS
91301: AND
91302: IFFALSE 91318
// ComAttackUnit ( i , e ) ;
91304: LD_VAR 0 4
91308: PPUSH
91309: LD_VAR 0 13
91313: PPUSH
91314: CALL_OW 115
// end ; end ; end ;
91318: GO 91321
91320: POP
// if IsDead ( i ) then
91321: LD_VAR 0 4
91325: PPUSH
91326: CALL_OW 301
91330: IFFALSE 91348
// defenders := defenders diff i ;
91332: LD_ADDR_VAR 0 2
91336: PUSH
91337: LD_VAR 0 2
91341: PUSH
91342: LD_VAR 0 4
91346: DIFF
91347: ST_TO_ADDR
// end ;
91348: GO 90451
91350: POP
91351: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
91352: LD_VAR 0 21
91356: NOT
91357: PUSH
91358: LD_VAR 0 2
91362: NOT
91363: OR
91364: PUSH
91365: LD_EXP 23
91369: PUSH
91370: LD_VAR 0 1
91374: ARRAY
91375: NOT
91376: OR
91377: IFFALSE 90355
// MC_Reset ( base , 18 ) ;
91379: LD_VAR 0 1
91383: PPUSH
91384: LD_INT 18
91386: PPUSH
91387: CALL 58055 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
91391: LD_ADDR_VAR 0 2
91395: PUSH
91396: LD_VAR 0 2
91400: PUSH
91401: LD_VAR 0 2
91405: PPUSH
91406: LD_INT 2
91408: PUSH
91409: LD_INT 25
91411: PUSH
91412: LD_INT 1
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PUSH
91419: LD_INT 25
91421: PUSH
91422: LD_INT 5
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 25
91431: PUSH
91432: LD_INT 8
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: PUSH
91439: LD_INT 25
91441: PUSH
91442: LD_INT 9
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: PPUSH
91456: CALL_OW 72
91460: DIFF
91461: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
91462: LD_VAR 0 21
91466: NOT
91467: PUSH
91468: LD_VAR 0 2
91472: PPUSH
91473: LD_INT 21
91475: PUSH
91476: LD_INT 2
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PPUSH
91483: CALL_OW 72
91487: AND
91488: IFFALSE 91826
// begin tmp := FilterByTag ( defenders , 19 ) ;
91490: LD_ADDR_VAR 0 11
91494: PUSH
91495: LD_VAR 0 2
91499: PPUSH
91500: LD_INT 19
91502: PPUSH
91503: CALL 46375 0 2
91507: ST_TO_ADDR
// if tmp then
91508: LD_VAR 0 11
91512: IFFALSE 91582
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
91514: LD_ADDR_VAR 0 11
91518: PUSH
91519: LD_VAR 0 11
91523: PPUSH
91524: LD_INT 25
91526: PUSH
91527: LD_INT 3
91529: PUSH
91530: EMPTY
91531: LIST
91532: LIST
91533: PPUSH
91534: CALL_OW 72
91538: ST_TO_ADDR
// if tmp then
91539: LD_VAR 0 11
91543: IFFALSE 91582
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
91545: LD_ADDR_EXP 35
91549: PUSH
91550: LD_EXP 35
91554: PPUSH
91555: LD_VAR 0 1
91559: PPUSH
91560: LD_EXP 35
91564: PUSH
91565: LD_VAR 0 1
91569: ARRAY
91570: PUSH
91571: LD_VAR 0 11
91575: UNION
91576: PPUSH
91577: CALL_OW 1
91581: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
91582: LD_VAR 0 1
91586: PPUSH
91587: LD_INT 19
91589: PPUSH
91590: CALL 58055 0 2
// repeat wait ( 0 0$1 ) ;
91594: LD_INT 35
91596: PPUSH
91597: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
91601: LD_EXP 23
91605: PUSH
91606: LD_VAR 0 1
91610: ARRAY
91611: NOT
91612: PUSH
91613: LD_EXP 23
91617: PUSH
91618: LD_VAR 0 1
91622: ARRAY
91623: PUSH
91624: EMPTY
91625: EQUAL
91626: OR
91627: IFFALSE 91664
// begin for i in defenders do
91629: LD_ADDR_VAR 0 4
91633: PUSH
91634: LD_VAR 0 2
91638: PUSH
91639: FOR_IN
91640: IFFALSE 91653
// ComStop ( i ) ;
91642: LD_VAR 0 4
91646: PPUSH
91647: CALL_OW 141
91651: GO 91639
91653: POP
91654: POP
// defenders := [ ] ;
91655: LD_ADDR_VAR 0 2
91659: PUSH
91660: EMPTY
91661: ST_TO_ADDR
// exit ;
91662: GO 91890
// end ; for i in defenders do
91664: LD_ADDR_VAR 0 4
91668: PUSH
91669: LD_VAR 0 2
91673: PUSH
91674: FOR_IN
91675: IFFALSE 91764
// begin if not IsInArea ( i , mc_parking [ base ] ) then
91677: LD_VAR 0 4
91681: PPUSH
91682: LD_EXP 47
91686: PUSH
91687: LD_VAR 0 1
91691: ARRAY
91692: PPUSH
91693: CALL_OW 308
91697: NOT
91698: IFFALSE 91722
// ComMoveToArea ( i , mc_parking [ base ] ) else
91700: LD_VAR 0 4
91704: PPUSH
91705: LD_EXP 47
91709: PUSH
91710: LD_VAR 0 1
91714: ARRAY
91715: PPUSH
91716: CALL_OW 113
91720: GO 91762
// if GetControl ( i ) = control_manual then
91722: LD_VAR 0 4
91726: PPUSH
91727: CALL_OW 263
91731: PUSH
91732: LD_INT 1
91734: EQUAL
91735: IFFALSE 91762
// if IsDrivenBy ( i ) then
91737: LD_VAR 0 4
91741: PPUSH
91742: CALL_OW 311
91746: IFFALSE 91762
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
91748: LD_VAR 0 4
91752: PPUSH
91753: CALL_OW 311
91757: PPUSH
91758: CALL_OW 121
// end ;
91762: GO 91674
91764: POP
91765: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
91766: LD_VAR 0 2
91770: PPUSH
91771: LD_INT 95
91773: PUSH
91774: LD_EXP 47
91778: PUSH
91779: LD_VAR 0 1
91783: ARRAY
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PPUSH
91789: CALL_OW 72
91793: PUSH
91794: LD_VAR 0 2
91798: EQUAL
91799: PUSH
91800: LD_EXP 46
91804: PUSH
91805: LD_VAR 0 1
91809: ARRAY
91810: OR
91811: PUSH
91812: LD_EXP 23
91816: PUSH
91817: LD_VAR 0 1
91821: ARRAY
91822: NOT
91823: OR
91824: IFFALSE 91594
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
91826: LD_ADDR_EXP 45
91830: PUSH
91831: LD_EXP 45
91835: PPUSH
91836: LD_VAR 0 1
91840: PPUSH
91841: LD_VAR 0 2
91845: PPUSH
91846: LD_INT 21
91848: PUSH
91849: LD_INT 2
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PPUSH
91856: CALL_OW 72
91860: PPUSH
91861: CALL_OW 1
91865: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
91866: LD_VAR 0 1
91870: PPUSH
91871: LD_INT 19
91873: PPUSH
91874: CALL 58055 0 2
// MC_Reset ( base , 20 ) ;
91878: LD_VAR 0 1
91882: PPUSH
91883: LD_INT 20
91885: PPUSH
91886: CALL 58055 0 2
// end ; end_of_file
91890: LD_VAR 0 3
91894: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
91895: LD_INT 0
91897: PPUSH
91898: PPUSH
91899: PPUSH
91900: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
91901: LD_VAR 0 1
91905: PPUSH
91906: CALL_OW 264
91910: PUSH
91911: LD_INT 91
91913: EQUAL
91914: IFFALSE 91986
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
91916: LD_INT 68
91918: PPUSH
91919: LD_VAR 0 1
91923: PPUSH
91924: CALL_OW 255
91928: PPUSH
91929: CALL_OW 321
91933: PUSH
91934: LD_INT 2
91936: EQUAL
91937: IFFALSE 91949
// eff := 70 else
91939: LD_ADDR_VAR 0 4
91943: PUSH
91944: LD_INT 70
91946: ST_TO_ADDR
91947: GO 91957
// eff := 30 ;
91949: LD_ADDR_VAR 0 4
91953: PUSH
91954: LD_INT 30
91956: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
91957: LD_VAR 0 1
91961: PPUSH
91962: CALL_OW 250
91966: PPUSH
91967: LD_VAR 0 1
91971: PPUSH
91972: CALL_OW 251
91976: PPUSH
91977: LD_VAR 0 4
91981: PPUSH
91982: CALL_OW 495
// end ; end ;
91986: LD_VAR 0 2
91990: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
91991: LD_INT 0
91993: PPUSH
// end ;
91994: LD_VAR 0 4
91998: RET
// export function SOS_Command ( cmd ) ; begin
91999: LD_INT 0
92001: PPUSH
// end ;
92002: LD_VAR 0 2
92006: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
92007: LD_INT 0
92009: PPUSH
// end ;
92010: LD_VAR 0 6
92014: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
92015: LD_INT 0
92017: PPUSH
92018: PPUSH
// if not vehicle or not factory then
92019: LD_VAR 0 1
92023: NOT
92024: PUSH
92025: LD_VAR 0 2
92029: NOT
92030: OR
92031: IFFALSE 92035
// exit ;
92033: GO 92266
// if factoryWaypoints >= factory then
92035: LD_EXP 137
92039: PUSH
92040: LD_VAR 0 2
92044: GREATEREQUAL
92045: IFFALSE 92266
// if factoryWaypoints [ factory ] then
92047: LD_EXP 137
92051: PUSH
92052: LD_VAR 0 2
92056: ARRAY
92057: IFFALSE 92266
// begin if GetControl ( vehicle ) = control_manual then
92059: LD_VAR 0 1
92063: PPUSH
92064: CALL_OW 263
92068: PUSH
92069: LD_INT 1
92071: EQUAL
92072: IFFALSE 92153
// begin driver := IsDrivenBy ( vehicle ) ;
92074: LD_ADDR_VAR 0 4
92078: PUSH
92079: LD_VAR 0 1
92083: PPUSH
92084: CALL_OW 311
92088: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
92089: LD_VAR 0 4
92093: PPUSH
92094: LD_EXP 137
92098: PUSH
92099: LD_VAR 0 2
92103: ARRAY
92104: PUSH
92105: LD_INT 3
92107: ARRAY
92108: PPUSH
92109: LD_EXP 137
92113: PUSH
92114: LD_VAR 0 2
92118: ARRAY
92119: PUSH
92120: LD_INT 4
92122: ARRAY
92123: PPUSH
92124: CALL_OW 171
// AddComExitVehicle ( driver ) ;
92128: LD_VAR 0 4
92132: PPUSH
92133: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
92137: LD_VAR 0 4
92141: PPUSH
92142: LD_VAR 0 2
92146: PPUSH
92147: CALL_OW 180
// end else
92151: GO 92266
// if GetControl ( vehicle ) = control_remote then
92153: LD_VAR 0 1
92157: PPUSH
92158: CALL_OW 263
92162: PUSH
92163: LD_INT 2
92165: EQUAL
92166: IFFALSE 92227
// begin wait ( 0 0$2 ) ;
92168: LD_INT 70
92170: PPUSH
92171: CALL_OW 67
// if Connect ( vehicle ) then
92175: LD_VAR 0 1
92179: PPUSH
92180: CALL 19423 0 1
92184: IFFALSE 92225
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
92186: LD_VAR 0 1
92190: PPUSH
92191: LD_EXP 137
92195: PUSH
92196: LD_VAR 0 2
92200: ARRAY
92201: PUSH
92202: LD_INT 3
92204: ARRAY
92205: PPUSH
92206: LD_EXP 137
92210: PUSH
92211: LD_VAR 0 2
92215: ARRAY
92216: PUSH
92217: LD_INT 4
92219: ARRAY
92220: PPUSH
92221: CALL_OW 171
// end else
92225: GO 92266
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
92227: LD_VAR 0 1
92231: PPUSH
92232: LD_EXP 137
92236: PUSH
92237: LD_VAR 0 2
92241: ARRAY
92242: PUSH
92243: LD_INT 3
92245: ARRAY
92246: PPUSH
92247: LD_EXP 137
92251: PUSH
92252: LD_VAR 0 2
92256: ARRAY
92257: PUSH
92258: LD_INT 4
92260: ARRAY
92261: PPUSH
92262: CALL_OW 171
// end ; end ;
92266: LD_VAR 0 3
92270: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
92271: LD_INT 0
92273: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
92274: LD_VAR 0 1
92278: PUSH
92279: LD_INT 250
92281: EQUAL
92282: PUSH
92283: LD_VAR 0 2
92287: PPUSH
92288: CALL_OW 264
92292: PUSH
92293: LD_INT 81
92295: EQUAL
92296: AND
92297: IFFALSE 92318
// MinerPlaceMine ( unit , x , y ) ;
92299: LD_VAR 0 2
92303: PPUSH
92304: LD_VAR 0 4
92308: PPUSH
92309: LD_VAR 0 5
92313: PPUSH
92314: CALL 95308 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
92318: LD_VAR 0 1
92322: PUSH
92323: LD_INT 251
92325: EQUAL
92326: PUSH
92327: LD_VAR 0 2
92331: PPUSH
92332: CALL_OW 264
92336: PUSH
92337: LD_INT 81
92339: EQUAL
92340: AND
92341: IFFALSE 92362
// MinerDetonateMine ( unit , x , y ) ;
92343: LD_VAR 0 2
92347: PPUSH
92348: LD_VAR 0 4
92352: PPUSH
92353: LD_VAR 0 5
92357: PPUSH
92358: CALL 95583 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
92362: LD_VAR 0 1
92366: PUSH
92367: LD_INT 252
92369: EQUAL
92370: PUSH
92371: LD_VAR 0 2
92375: PPUSH
92376: CALL_OW 264
92380: PUSH
92381: LD_INT 81
92383: EQUAL
92384: AND
92385: IFFALSE 92406
// MinerCreateMinefield ( unit , x , y ) ;
92387: LD_VAR 0 2
92391: PPUSH
92392: LD_VAR 0 4
92396: PPUSH
92397: LD_VAR 0 5
92401: PPUSH
92402: CALL 96000 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
92406: LD_VAR 0 1
92410: PUSH
92411: LD_INT 253
92413: EQUAL
92414: PUSH
92415: LD_VAR 0 2
92419: PPUSH
92420: CALL_OW 257
92424: PUSH
92425: LD_INT 5
92427: EQUAL
92428: AND
92429: IFFALSE 92450
// ComBinocular ( unit , x , y ) ;
92431: LD_VAR 0 2
92435: PPUSH
92436: LD_VAR 0 4
92440: PPUSH
92441: LD_VAR 0 5
92445: PPUSH
92446: CALL 96369 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
92450: LD_VAR 0 1
92454: PUSH
92455: LD_INT 254
92457: EQUAL
92458: PUSH
92459: LD_VAR 0 2
92463: PPUSH
92464: CALL_OW 264
92468: PUSH
92469: LD_INT 99
92471: EQUAL
92472: AND
92473: PUSH
92474: LD_VAR 0 3
92478: PPUSH
92479: CALL_OW 263
92483: PUSH
92484: LD_INT 3
92486: EQUAL
92487: AND
92488: IFFALSE 92504
// HackDestroyVehicle ( unit , selectedUnit ) ;
92490: LD_VAR 0 2
92494: PPUSH
92495: LD_VAR 0 3
92499: PPUSH
92500: CALL 94672 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
92504: LD_VAR 0 1
92508: PUSH
92509: LD_INT 255
92511: EQUAL
92512: PUSH
92513: LD_VAR 0 2
92517: PPUSH
92518: CALL_OW 264
92522: PUSH
92523: LD_INT 14
92525: PUSH
92526: LD_INT 53
92528: PUSH
92529: EMPTY
92530: LIST
92531: LIST
92532: IN
92533: AND
92534: PUSH
92535: LD_VAR 0 4
92539: PPUSH
92540: LD_VAR 0 5
92544: PPUSH
92545: CALL_OW 488
92549: AND
92550: IFFALSE 92574
// CutTreeXYR ( unit , x , y , 12 ) ;
92552: LD_VAR 0 2
92556: PPUSH
92557: LD_VAR 0 4
92561: PPUSH
92562: LD_VAR 0 5
92566: PPUSH
92567: LD_INT 12
92569: PPUSH
92570: CALL 92669 0 4
// if cmd = 256 then
92574: LD_VAR 0 1
92578: PUSH
92579: LD_INT 256
92581: EQUAL
92582: IFFALSE 92603
// SetFactoryWaypoint ( unit , x , y ) ;
92584: LD_VAR 0 2
92588: PPUSH
92589: LD_VAR 0 4
92593: PPUSH
92594: LD_VAR 0 5
92598: PPUSH
92599: CALL 111460 0 3
// if cmd = 257 then
92603: LD_VAR 0 1
92607: PUSH
92608: LD_INT 257
92610: EQUAL
92611: IFFALSE 92632
// SetWarehouseGatheringPoint ( unit , x , y ) ;
92613: LD_VAR 0 2
92617: PPUSH
92618: LD_VAR 0 4
92622: PPUSH
92623: LD_VAR 0 5
92627: PPUSH
92628: CALL 111822 0 3
// if cmd = 258 then
92632: LD_VAR 0 1
92636: PUSH
92637: LD_INT 258
92639: EQUAL
92640: IFFALSE 92664
// BurnTreeXYR ( unit , x , y , 8 ) ;
92642: LD_VAR 0 2
92646: PPUSH
92647: LD_VAR 0 4
92651: PPUSH
92652: LD_VAR 0 5
92656: PPUSH
92657: LD_INT 8
92659: PPUSH
92660: CALL 93063 0 4
// end ;
92664: LD_VAR 0 6
92668: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
92669: LD_INT 0
92671: PPUSH
92672: PPUSH
92673: PPUSH
92674: PPUSH
92675: PPUSH
92676: PPUSH
92677: PPUSH
92678: PPUSH
92679: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
92680: LD_VAR 0 1
92684: PPUSH
92685: CALL_OW 302
92689: NOT
92690: PUSH
92691: LD_VAR 0 2
92695: PPUSH
92696: LD_VAR 0 3
92700: PPUSH
92701: CALL_OW 488
92705: NOT
92706: OR
92707: PUSH
92708: LD_VAR 0 4
92712: NOT
92713: OR
92714: IFFALSE 92718
// exit ;
92716: GO 93058
// list := [ ] ;
92718: LD_ADDR_VAR 0 13
92722: PUSH
92723: EMPTY
92724: ST_TO_ADDR
// if x - r < 0 then
92725: LD_VAR 0 2
92729: PUSH
92730: LD_VAR 0 4
92734: MINUS
92735: PUSH
92736: LD_INT 0
92738: LESS
92739: IFFALSE 92751
// min_x := 0 else
92741: LD_ADDR_VAR 0 7
92745: PUSH
92746: LD_INT 0
92748: ST_TO_ADDR
92749: GO 92767
// min_x := x - r ;
92751: LD_ADDR_VAR 0 7
92755: PUSH
92756: LD_VAR 0 2
92760: PUSH
92761: LD_VAR 0 4
92765: MINUS
92766: ST_TO_ADDR
// if y - r < 0 then
92767: LD_VAR 0 3
92771: PUSH
92772: LD_VAR 0 4
92776: MINUS
92777: PUSH
92778: LD_INT 0
92780: LESS
92781: IFFALSE 92793
// min_y := 0 else
92783: LD_ADDR_VAR 0 8
92787: PUSH
92788: LD_INT 0
92790: ST_TO_ADDR
92791: GO 92809
// min_y := y - r ;
92793: LD_ADDR_VAR 0 8
92797: PUSH
92798: LD_VAR 0 3
92802: PUSH
92803: LD_VAR 0 4
92807: MINUS
92808: ST_TO_ADDR
// max_x := x + r ;
92809: LD_ADDR_VAR 0 9
92813: PUSH
92814: LD_VAR 0 2
92818: PUSH
92819: LD_VAR 0 4
92823: PLUS
92824: ST_TO_ADDR
// max_y := y + r ;
92825: LD_ADDR_VAR 0 10
92829: PUSH
92830: LD_VAR 0 3
92834: PUSH
92835: LD_VAR 0 4
92839: PLUS
92840: ST_TO_ADDR
// for _x = min_x to max_x do
92841: LD_ADDR_VAR 0 11
92845: PUSH
92846: DOUBLE
92847: LD_VAR 0 7
92851: DEC
92852: ST_TO_ADDR
92853: LD_VAR 0 9
92857: PUSH
92858: FOR_TO
92859: IFFALSE 92976
// for _y = min_y to max_y do
92861: LD_ADDR_VAR 0 12
92865: PUSH
92866: DOUBLE
92867: LD_VAR 0 8
92871: DEC
92872: ST_TO_ADDR
92873: LD_VAR 0 10
92877: PUSH
92878: FOR_TO
92879: IFFALSE 92972
// begin if not ValidHex ( _x , _y ) then
92881: LD_VAR 0 11
92885: PPUSH
92886: LD_VAR 0 12
92890: PPUSH
92891: CALL_OW 488
92895: NOT
92896: IFFALSE 92900
// continue ;
92898: GO 92878
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
92900: LD_VAR 0 11
92904: PPUSH
92905: LD_VAR 0 12
92909: PPUSH
92910: CALL_OW 351
92914: PUSH
92915: LD_VAR 0 11
92919: PPUSH
92920: LD_VAR 0 12
92924: PPUSH
92925: CALL_OW 554
92929: AND
92930: IFFALSE 92970
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
92932: LD_ADDR_VAR 0 13
92936: PUSH
92937: LD_VAR 0 13
92941: PPUSH
92942: LD_VAR 0 13
92946: PUSH
92947: LD_INT 1
92949: PLUS
92950: PPUSH
92951: LD_VAR 0 11
92955: PUSH
92956: LD_VAR 0 12
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PPUSH
92965: CALL_OW 2
92969: ST_TO_ADDR
// end ;
92970: GO 92878
92972: POP
92973: POP
92974: GO 92858
92976: POP
92977: POP
// if not list then
92978: LD_VAR 0 13
92982: NOT
92983: IFFALSE 92987
// exit ;
92985: GO 93058
// for i in list do
92987: LD_ADDR_VAR 0 6
92991: PUSH
92992: LD_VAR 0 13
92996: PUSH
92997: FOR_IN
92998: IFFALSE 93056
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
93000: LD_VAR 0 1
93004: PPUSH
93005: LD_STRING M
93007: PUSH
93008: LD_VAR 0 6
93012: PUSH
93013: LD_INT 1
93015: ARRAY
93016: PUSH
93017: LD_VAR 0 6
93021: PUSH
93022: LD_INT 2
93024: ARRAY
93025: PUSH
93026: LD_INT 0
93028: PUSH
93029: LD_INT 0
93031: PUSH
93032: LD_INT 0
93034: PUSH
93035: LD_INT 0
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: LIST
93042: LIST
93043: LIST
93044: LIST
93045: LIST
93046: PUSH
93047: EMPTY
93048: LIST
93049: PPUSH
93050: CALL_OW 447
93054: GO 92997
93056: POP
93057: POP
// end ;
93058: LD_VAR 0 5
93062: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
93063: LD_INT 0
93065: PPUSH
93066: PPUSH
93067: PPUSH
93068: PPUSH
93069: PPUSH
93070: PPUSH
93071: PPUSH
93072: PPUSH
93073: PPUSH
93074: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
93075: LD_VAR 0 1
93079: PPUSH
93080: CALL_OW 302
93084: NOT
93085: PUSH
93086: LD_VAR 0 2
93090: PPUSH
93091: LD_VAR 0 3
93095: PPUSH
93096: CALL_OW 488
93100: NOT
93101: OR
93102: PUSH
93103: LD_VAR 0 4
93107: NOT
93108: OR
93109: IFFALSE 93113
// exit ;
93111: GO 93626
// list := [ ] ;
93113: LD_ADDR_VAR 0 13
93117: PUSH
93118: EMPTY
93119: ST_TO_ADDR
// if x - r < 0 then
93120: LD_VAR 0 2
93124: PUSH
93125: LD_VAR 0 4
93129: MINUS
93130: PUSH
93131: LD_INT 0
93133: LESS
93134: IFFALSE 93146
// min_x := 0 else
93136: LD_ADDR_VAR 0 7
93140: PUSH
93141: LD_INT 0
93143: ST_TO_ADDR
93144: GO 93162
// min_x := x - r ;
93146: LD_ADDR_VAR 0 7
93150: PUSH
93151: LD_VAR 0 2
93155: PUSH
93156: LD_VAR 0 4
93160: MINUS
93161: ST_TO_ADDR
// if y - r < 0 then
93162: LD_VAR 0 3
93166: PUSH
93167: LD_VAR 0 4
93171: MINUS
93172: PUSH
93173: LD_INT 0
93175: LESS
93176: IFFALSE 93188
// min_y := 0 else
93178: LD_ADDR_VAR 0 8
93182: PUSH
93183: LD_INT 0
93185: ST_TO_ADDR
93186: GO 93204
// min_y := y - r ;
93188: LD_ADDR_VAR 0 8
93192: PUSH
93193: LD_VAR 0 3
93197: PUSH
93198: LD_VAR 0 4
93202: MINUS
93203: ST_TO_ADDR
// max_x := x + r ;
93204: LD_ADDR_VAR 0 9
93208: PUSH
93209: LD_VAR 0 2
93213: PUSH
93214: LD_VAR 0 4
93218: PLUS
93219: ST_TO_ADDR
// max_y := y + r ;
93220: LD_ADDR_VAR 0 10
93224: PUSH
93225: LD_VAR 0 3
93229: PUSH
93230: LD_VAR 0 4
93234: PLUS
93235: ST_TO_ADDR
// for _x = min_x to max_x do
93236: LD_ADDR_VAR 0 11
93240: PUSH
93241: DOUBLE
93242: LD_VAR 0 7
93246: DEC
93247: ST_TO_ADDR
93248: LD_VAR 0 9
93252: PUSH
93253: FOR_TO
93254: IFFALSE 93371
// for _y = min_y to max_y do
93256: LD_ADDR_VAR 0 12
93260: PUSH
93261: DOUBLE
93262: LD_VAR 0 8
93266: DEC
93267: ST_TO_ADDR
93268: LD_VAR 0 10
93272: PUSH
93273: FOR_TO
93274: IFFALSE 93367
// begin if not ValidHex ( _x , _y ) then
93276: LD_VAR 0 11
93280: PPUSH
93281: LD_VAR 0 12
93285: PPUSH
93286: CALL_OW 488
93290: NOT
93291: IFFALSE 93295
// continue ;
93293: GO 93273
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93295: LD_VAR 0 11
93299: PPUSH
93300: LD_VAR 0 12
93304: PPUSH
93305: CALL_OW 351
93309: PUSH
93310: LD_VAR 0 11
93314: PPUSH
93315: LD_VAR 0 12
93319: PPUSH
93320: CALL_OW 554
93324: AND
93325: IFFALSE 93365
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93327: LD_ADDR_VAR 0 13
93331: PUSH
93332: LD_VAR 0 13
93336: PPUSH
93337: LD_VAR 0 13
93341: PUSH
93342: LD_INT 1
93344: PLUS
93345: PPUSH
93346: LD_VAR 0 11
93350: PUSH
93351: LD_VAR 0 12
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PPUSH
93360: CALL_OW 2
93364: ST_TO_ADDR
// end ;
93365: GO 93273
93367: POP
93368: POP
93369: GO 93253
93371: POP
93372: POP
// if not list then
93373: LD_VAR 0 13
93377: NOT
93378: IFFALSE 93382
// exit ;
93380: GO 93626
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
93382: LD_ADDR_VAR 0 13
93386: PUSH
93387: LD_VAR 0 1
93391: PPUSH
93392: LD_VAR 0 13
93396: PPUSH
93397: LD_INT 1
93399: PPUSH
93400: LD_INT 1
93402: PPUSH
93403: CALL 16565 0 4
93407: ST_TO_ADDR
// ComStop ( flame ) ;
93408: LD_VAR 0 1
93412: PPUSH
93413: CALL_OW 141
// for i in list do
93417: LD_ADDR_VAR 0 6
93421: PUSH
93422: LD_VAR 0 13
93426: PUSH
93427: FOR_IN
93428: IFFALSE 93459
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
93430: LD_VAR 0 1
93434: PPUSH
93435: LD_VAR 0 6
93439: PUSH
93440: LD_INT 1
93442: ARRAY
93443: PPUSH
93444: LD_VAR 0 6
93448: PUSH
93449: LD_INT 2
93451: ARRAY
93452: PPUSH
93453: CALL_OW 176
93457: GO 93427
93459: POP
93460: POP
// repeat wait ( 0 0$1 ) ;
93461: LD_INT 35
93463: PPUSH
93464: CALL_OW 67
// task := GetTaskList ( flame ) ;
93468: LD_ADDR_VAR 0 14
93472: PUSH
93473: LD_VAR 0 1
93477: PPUSH
93478: CALL_OW 437
93482: ST_TO_ADDR
// if not task then
93483: LD_VAR 0 14
93487: NOT
93488: IFFALSE 93492
// exit ;
93490: GO 93626
// if task [ 1 ] [ 1 ] <> | then
93492: LD_VAR 0 14
93496: PUSH
93497: LD_INT 1
93499: ARRAY
93500: PUSH
93501: LD_INT 1
93503: ARRAY
93504: PUSH
93505: LD_STRING |
93507: NONEQUAL
93508: IFFALSE 93512
// exit ;
93510: GO 93626
// _x := task [ 1 ] [ 2 ] ;
93512: LD_ADDR_VAR 0 11
93516: PUSH
93517: LD_VAR 0 14
93521: PUSH
93522: LD_INT 1
93524: ARRAY
93525: PUSH
93526: LD_INT 2
93528: ARRAY
93529: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
93530: LD_ADDR_VAR 0 12
93534: PUSH
93535: LD_VAR 0 14
93539: PUSH
93540: LD_INT 1
93542: ARRAY
93543: PUSH
93544: LD_INT 3
93546: ARRAY
93547: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
93548: LD_VAR 0 11
93552: PPUSH
93553: LD_VAR 0 12
93557: PPUSH
93558: CALL_OW 351
93562: NOT
93563: PUSH
93564: LD_VAR 0 11
93568: PPUSH
93569: LD_VAR 0 12
93573: PPUSH
93574: CALL_OW 554
93578: NOT
93579: OR
93580: IFFALSE 93614
// begin task := Delete ( task , 1 ) ;
93582: LD_ADDR_VAR 0 14
93586: PUSH
93587: LD_VAR 0 14
93591: PPUSH
93592: LD_INT 1
93594: PPUSH
93595: CALL_OW 3
93599: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
93600: LD_VAR 0 1
93604: PPUSH
93605: LD_VAR 0 14
93609: PPUSH
93610: CALL_OW 446
// end ; until not HasTask ( flame ) ;
93614: LD_VAR 0 1
93618: PPUSH
93619: CALL_OW 314
93623: NOT
93624: IFFALSE 93461
// end ;
93626: LD_VAR 0 5
93630: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
93631: LD_EXP 68
93635: NOT
93636: IFFALSE 93686
93638: GO 93640
93640: DISABLE
// begin initHack := true ;
93641: LD_ADDR_EXP 68
93645: PUSH
93646: LD_INT 1
93648: ST_TO_ADDR
// hackTanks := [ ] ;
93649: LD_ADDR_EXP 69
93653: PUSH
93654: EMPTY
93655: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
93656: LD_ADDR_EXP 70
93660: PUSH
93661: EMPTY
93662: ST_TO_ADDR
// hackLimit := 3 ;
93663: LD_ADDR_EXP 71
93667: PUSH
93668: LD_INT 3
93670: ST_TO_ADDR
// hackDist := 12 ;
93671: LD_ADDR_EXP 72
93675: PUSH
93676: LD_INT 12
93678: ST_TO_ADDR
// hackCounter := [ ] ;
93679: LD_ADDR_EXP 73
93683: PUSH
93684: EMPTY
93685: ST_TO_ADDR
// end ;
93686: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
93687: LD_EXP 68
93691: PUSH
93692: LD_INT 34
93694: PUSH
93695: LD_INT 99
93697: PUSH
93698: EMPTY
93699: LIST
93700: LIST
93701: PPUSH
93702: CALL_OW 69
93706: AND
93707: IFFALSE 93960
93709: GO 93711
93711: DISABLE
93712: LD_INT 0
93714: PPUSH
93715: PPUSH
// begin enable ;
93716: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
93717: LD_ADDR_VAR 0 1
93721: PUSH
93722: LD_INT 34
93724: PUSH
93725: LD_INT 99
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PPUSH
93732: CALL_OW 69
93736: PUSH
93737: FOR_IN
93738: IFFALSE 93958
// begin if not i in hackTanks then
93740: LD_VAR 0 1
93744: PUSH
93745: LD_EXP 69
93749: IN
93750: NOT
93751: IFFALSE 93834
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
93753: LD_ADDR_EXP 69
93757: PUSH
93758: LD_EXP 69
93762: PPUSH
93763: LD_EXP 69
93767: PUSH
93768: LD_INT 1
93770: PLUS
93771: PPUSH
93772: LD_VAR 0 1
93776: PPUSH
93777: CALL_OW 1
93781: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
93782: LD_ADDR_EXP 70
93786: PUSH
93787: LD_EXP 70
93791: PPUSH
93792: LD_EXP 70
93796: PUSH
93797: LD_INT 1
93799: PLUS
93800: PPUSH
93801: EMPTY
93802: PPUSH
93803: CALL_OW 1
93807: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
93808: LD_ADDR_EXP 73
93812: PUSH
93813: LD_EXP 73
93817: PPUSH
93818: LD_EXP 73
93822: PUSH
93823: LD_INT 1
93825: PLUS
93826: PPUSH
93827: EMPTY
93828: PPUSH
93829: CALL_OW 1
93833: ST_TO_ADDR
// end ; if not IsOk ( i ) then
93834: LD_VAR 0 1
93838: PPUSH
93839: CALL_OW 302
93843: NOT
93844: IFFALSE 93857
// begin HackUnlinkAll ( i ) ;
93846: LD_VAR 0 1
93850: PPUSH
93851: CALL 93963 0 1
// continue ;
93855: GO 93737
// end ; HackCheckCapturedStatus ( i ) ;
93857: LD_VAR 0 1
93861: PPUSH
93862: CALL 94406 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
93866: LD_ADDR_VAR 0 2
93870: PUSH
93871: LD_INT 81
93873: PUSH
93874: LD_VAR 0 1
93878: PPUSH
93879: CALL_OW 255
93883: PUSH
93884: EMPTY
93885: LIST
93886: LIST
93887: PUSH
93888: LD_INT 33
93890: PUSH
93891: LD_INT 3
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: LD_INT 91
93900: PUSH
93901: LD_VAR 0 1
93905: PUSH
93906: LD_EXP 72
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: LIST
93915: PUSH
93916: LD_INT 50
93918: PUSH
93919: EMPTY
93920: LIST
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: PPUSH
93928: CALL_OW 69
93932: ST_TO_ADDR
// if not tmp then
93933: LD_VAR 0 2
93937: NOT
93938: IFFALSE 93942
// continue ;
93940: GO 93737
// HackLink ( i , tmp ) ;
93942: LD_VAR 0 1
93946: PPUSH
93947: LD_VAR 0 2
93951: PPUSH
93952: CALL 94099 0 2
// end ;
93956: GO 93737
93958: POP
93959: POP
// end ;
93960: PPOPN 2
93962: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
93963: LD_INT 0
93965: PPUSH
93966: PPUSH
93967: PPUSH
// if not hack in hackTanks then
93968: LD_VAR 0 1
93972: PUSH
93973: LD_EXP 69
93977: IN
93978: NOT
93979: IFFALSE 93983
// exit ;
93981: GO 94094
// index := GetElementIndex ( hackTanks , hack ) ;
93983: LD_ADDR_VAR 0 4
93987: PUSH
93988: LD_EXP 69
93992: PPUSH
93993: LD_VAR 0 1
93997: PPUSH
93998: CALL 15862 0 2
94002: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
94003: LD_EXP 70
94007: PUSH
94008: LD_VAR 0 4
94012: ARRAY
94013: IFFALSE 94094
// begin for i in hackTanksCaptured [ index ] do
94015: LD_ADDR_VAR 0 3
94019: PUSH
94020: LD_EXP 70
94024: PUSH
94025: LD_VAR 0 4
94029: ARRAY
94030: PUSH
94031: FOR_IN
94032: IFFALSE 94058
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
94034: LD_VAR 0 3
94038: PUSH
94039: LD_INT 1
94041: ARRAY
94042: PPUSH
94043: LD_VAR 0 3
94047: PUSH
94048: LD_INT 2
94050: ARRAY
94051: PPUSH
94052: CALL_OW 235
94056: GO 94031
94058: POP
94059: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
94060: LD_ADDR_EXP 70
94064: PUSH
94065: LD_EXP 70
94069: PPUSH
94070: LD_VAR 0 4
94074: PPUSH
94075: EMPTY
94076: PPUSH
94077: CALL_OW 1
94081: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
94082: LD_VAR 0 1
94086: PPUSH
94087: LD_INT 0
94089: PPUSH
94090: CALL_OW 505
// end ; end ;
94094: LD_VAR 0 2
94098: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
94099: LD_INT 0
94101: PPUSH
94102: PPUSH
94103: PPUSH
// if not hack in hackTanks or not vehicles then
94104: LD_VAR 0 1
94108: PUSH
94109: LD_EXP 69
94113: IN
94114: NOT
94115: PUSH
94116: LD_VAR 0 2
94120: NOT
94121: OR
94122: IFFALSE 94126
// exit ;
94124: GO 94401
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
94126: LD_ADDR_VAR 0 2
94130: PUSH
94131: LD_VAR 0 1
94135: PPUSH
94136: LD_VAR 0 2
94140: PPUSH
94141: LD_INT 1
94143: PPUSH
94144: LD_INT 1
94146: PPUSH
94147: CALL 16512 0 4
94151: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
94152: LD_ADDR_VAR 0 5
94156: PUSH
94157: LD_EXP 69
94161: PPUSH
94162: LD_VAR 0 1
94166: PPUSH
94167: CALL 15862 0 2
94171: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
94172: LD_EXP 70
94176: PUSH
94177: LD_VAR 0 5
94181: ARRAY
94182: PUSH
94183: LD_EXP 71
94187: LESS
94188: IFFALSE 94377
// begin for i := 1 to vehicles do
94190: LD_ADDR_VAR 0 4
94194: PUSH
94195: DOUBLE
94196: LD_INT 1
94198: DEC
94199: ST_TO_ADDR
94200: LD_VAR 0 2
94204: PUSH
94205: FOR_TO
94206: IFFALSE 94375
// begin if hackTanksCaptured [ index ] = hackLimit then
94208: LD_EXP 70
94212: PUSH
94213: LD_VAR 0 5
94217: ARRAY
94218: PUSH
94219: LD_EXP 71
94223: EQUAL
94224: IFFALSE 94228
// break ;
94226: GO 94375
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
94228: LD_ADDR_EXP 73
94232: PUSH
94233: LD_EXP 73
94237: PPUSH
94238: LD_VAR 0 5
94242: PPUSH
94243: LD_EXP 73
94247: PUSH
94248: LD_VAR 0 5
94252: ARRAY
94253: PUSH
94254: LD_INT 1
94256: PLUS
94257: PPUSH
94258: CALL_OW 1
94262: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
94263: LD_ADDR_EXP 70
94267: PUSH
94268: LD_EXP 70
94272: PPUSH
94273: LD_VAR 0 5
94277: PUSH
94278: LD_EXP 70
94282: PUSH
94283: LD_VAR 0 5
94287: ARRAY
94288: PUSH
94289: LD_INT 1
94291: PLUS
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PPUSH
94297: LD_VAR 0 2
94301: PUSH
94302: LD_VAR 0 4
94306: ARRAY
94307: PUSH
94308: LD_VAR 0 2
94312: PUSH
94313: LD_VAR 0 4
94317: ARRAY
94318: PPUSH
94319: CALL_OW 255
94323: PUSH
94324: EMPTY
94325: LIST
94326: LIST
94327: PPUSH
94328: CALL 16077 0 3
94332: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
94333: LD_VAR 0 2
94337: PUSH
94338: LD_VAR 0 4
94342: ARRAY
94343: PPUSH
94344: LD_VAR 0 1
94348: PPUSH
94349: CALL_OW 255
94353: PPUSH
94354: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
94358: LD_VAR 0 2
94362: PUSH
94363: LD_VAR 0 4
94367: ARRAY
94368: PPUSH
94369: CALL_OW 141
// end ;
94373: GO 94205
94375: POP
94376: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
94377: LD_VAR 0 1
94381: PPUSH
94382: LD_EXP 70
94386: PUSH
94387: LD_VAR 0 5
94391: ARRAY
94392: PUSH
94393: LD_INT 0
94395: PLUS
94396: PPUSH
94397: CALL_OW 505
// end ;
94401: LD_VAR 0 3
94405: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
94406: LD_INT 0
94408: PPUSH
94409: PPUSH
94410: PPUSH
94411: PPUSH
// if not hack in hackTanks then
94412: LD_VAR 0 1
94416: PUSH
94417: LD_EXP 69
94421: IN
94422: NOT
94423: IFFALSE 94427
// exit ;
94425: GO 94667
// index := GetElementIndex ( hackTanks , hack ) ;
94427: LD_ADDR_VAR 0 4
94431: PUSH
94432: LD_EXP 69
94436: PPUSH
94437: LD_VAR 0 1
94441: PPUSH
94442: CALL 15862 0 2
94446: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
94447: LD_ADDR_VAR 0 3
94451: PUSH
94452: DOUBLE
94453: LD_EXP 70
94457: PUSH
94458: LD_VAR 0 4
94462: ARRAY
94463: INC
94464: ST_TO_ADDR
94465: LD_INT 1
94467: PUSH
94468: FOR_DOWNTO
94469: IFFALSE 94641
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
94471: LD_ADDR_VAR 0 5
94475: PUSH
94476: LD_EXP 70
94480: PUSH
94481: LD_VAR 0 4
94485: ARRAY
94486: PUSH
94487: LD_VAR 0 3
94491: ARRAY
94492: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
94493: LD_VAR 0 5
94497: PUSH
94498: LD_INT 1
94500: ARRAY
94501: PPUSH
94502: CALL_OW 302
94506: NOT
94507: PUSH
94508: LD_VAR 0 5
94512: PUSH
94513: LD_INT 1
94515: ARRAY
94516: PPUSH
94517: CALL_OW 255
94521: PUSH
94522: LD_VAR 0 1
94526: PPUSH
94527: CALL_OW 255
94531: NONEQUAL
94532: OR
94533: IFFALSE 94639
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
94535: LD_VAR 0 5
94539: PUSH
94540: LD_INT 1
94542: ARRAY
94543: PPUSH
94544: CALL_OW 305
94548: PUSH
94549: LD_VAR 0 5
94553: PUSH
94554: LD_INT 1
94556: ARRAY
94557: PPUSH
94558: CALL_OW 255
94562: PUSH
94563: LD_VAR 0 1
94567: PPUSH
94568: CALL_OW 255
94572: EQUAL
94573: AND
94574: IFFALSE 94598
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
94576: LD_VAR 0 5
94580: PUSH
94581: LD_INT 1
94583: ARRAY
94584: PPUSH
94585: LD_VAR 0 5
94589: PUSH
94590: LD_INT 2
94592: ARRAY
94593: PPUSH
94594: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
94598: LD_ADDR_EXP 70
94602: PUSH
94603: LD_EXP 70
94607: PPUSH
94608: LD_VAR 0 4
94612: PPUSH
94613: LD_EXP 70
94617: PUSH
94618: LD_VAR 0 4
94622: ARRAY
94623: PPUSH
94624: LD_VAR 0 3
94628: PPUSH
94629: CALL_OW 3
94633: PPUSH
94634: CALL_OW 1
94638: ST_TO_ADDR
// end ; end ;
94639: GO 94468
94641: POP
94642: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
94643: LD_VAR 0 1
94647: PPUSH
94648: LD_EXP 70
94652: PUSH
94653: LD_VAR 0 4
94657: ARRAY
94658: PUSH
94659: LD_INT 0
94661: PLUS
94662: PPUSH
94663: CALL_OW 505
// end ;
94667: LD_VAR 0 2
94671: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
94672: LD_INT 0
94674: PPUSH
94675: PPUSH
94676: PPUSH
94677: PPUSH
// if not hack in hackTanks then
94678: LD_VAR 0 1
94682: PUSH
94683: LD_EXP 69
94687: IN
94688: NOT
94689: IFFALSE 94693
// exit ;
94691: GO 94778
// index := GetElementIndex ( hackTanks , hack ) ;
94693: LD_ADDR_VAR 0 5
94697: PUSH
94698: LD_EXP 69
94702: PPUSH
94703: LD_VAR 0 1
94707: PPUSH
94708: CALL 15862 0 2
94712: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
94713: LD_ADDR_VAR 0 4
94717: PUSH
94718: DOUBLE
94719: LD_INT 1
94721: DEC
94722: ST_TO_ADDR
94723: LD_EXP 70
94727: PUSH
94728: LD_VAR 0 5
94732: ARRAY
94733: PUSH
94734: FOR_TO
94735: IFFALSE 94776
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
94737: LD_EXP 70
94741: PUSH
94742: LD_VAR 0 5
94746: ARRAY
94747: PUSH
94748: LD_VAR 0 4
94752: ARRAY
94753: PUSH
94754: LD_INT 1
94756: ARRAY
94757: PUSH
94758: LD_VAR 0 2
94762: EQUAL
94763: IFFALSE 94774
// KillUnit ( vehicle ) ;
94765: LD_VAR 0 2
94769: PPUSH
94770: CALL_OW 66
94774: GO 94734
94776: POP
94777: POP
// end ;
94778: LD_VAR 0 3
94782: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
94783: LD_EXP 74
94787: NOT
94788: IFFALSE 94823
94790: GO 94792
94792: DISABLE
// begin initMiner := true ;
94793: LD_ADDR_EXP 74
94797: PUSH
94798: LD_INT 1
94800: ST_TO_ADDR
// minersList := [ ] ;
94801: LD_ADDR_EXP 75
94805: PUSH
94806: EMPTY
94807: ST_TO_ADDR
// minerMinesList := [ ] ;
94808: LD_ADDR_EXP 76
94812: PUSH
94813: EMPTY
94814: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
94815: LD_ADDR_EXP 77
94819: PUSH
94820: LD_INT 5
94822: ST_TO_ADDR
// end ;
94823: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
94824: LD_EXP 74
94828: PUSH
94829: LD_INT 34
94831: PUSH
94832: LD_INT 81
94834: PUSH
94835: EMPTY
94836: LIST
94837: LIST
94838: PPUSH
94839: CALL_OW 69
94843: AND
94844: IFFALSE 95305
94846: GO 94848
94848: DISABLE
94849: LD_INT 0
94851: PPUSH
94852: PPUSH
94853: PPUSH
94854: PPUSH
// begin enable ;
94855: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
94856: LD_ADDR_VAR 0 1
94860: PUSH
94861: LD_INT 34
94863: PUSH
94864: LD_INT 81
94866: PUSH
94867: EMPTY
94868: LIST
94869: LIST
94870: PPUSH
94871: CALL_OW 69
94875: PUSH
94876: FOR_IN
94877: IFFALSE 94949
// begin if not i in minersList then
94879: LD_VAR 0 1
94883: PUSH
94884: LD_EXP 75
94888: IN
94889: NOT
94890: IFFALSE 94947
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
94892: LD_ADDR_EXP 75
94896: PUSH
94897: LD_EXP 75
94901: PPUSH
94902: LD_EXP 75
94906: PUSH
94907: LD_INT 1
94909: PLUS
94910: PPUSH
94911: LD_VAR 0 1
94915: PPUSH
94916: CALL_OW 1
94920: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
94921: LD_ADDR_EXP 76
94925: PUSH
94926: LD_EXP 76
94930: PPUSH
94931: LD_EXP 76
94935: PUSH
94936: LD_INT 1
94938: PLUS
94939: PPUSH
94940: EMPTY
94941: PPUSH
94942: CALL_OW 1
94946: ST_TO_ADDR
// end end ;
94947: GO 94876
94949: POP
94950: POP
// for i := minerMinesList downto 1 do
94951: LD_ADDR_VAR 0 1
94955: PUSH
94956: DOUBLE
94957: LD_EXP 76
94961: INC
94962: ST_TO_ADDR
94963: LD_INT 1
94965: PUSH
94966: FOR_DOWNTO
94967: IFFALSE 95303
// begin if IsLive ( minersList [ i ] ) then
94969: LD_EXP 75
94973: PUSH
94974: LD_VAR 0 1
94978: ARRAY
94979: PPUSH
94980: CALL_OW 300
94984: IFFALSE 95012
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
94986: LD_EXP 75
94990: PUSH
94991: LD_VAR 0 1
94995: ARRAY
94996: PPUSH
94997: LD_EXP 76
95001: PUSH
95002: LD_VAR 0 1
95006: ARRAY
95007: PPUSH
95008: CALL_OW 505
// if not minerMinesList [ i ] then
95012: LD_EXP 76
95016: PUSH
95017: LD_VAR 0 1
95021: ARRAY
95022: NOT
95023: IFFALSE 95027
// continue ;
95025: GO 94966
// for j := minerMinesList [ i ] downto 1 do
95027: LD_ADDR_VAR 0 2
95031: PUSH
95032: DOUBLE
95033: LD_EXP 76
95037: PUSH
95038: LD_VAR 0 1
95042: ARRAY
95043: INC
95044: ST_TO_ADDR
95045: LD_INT 1
95047: PUSH
95048: FOR_DOWNTO
95049: IFFALSE 95299
// begin side := GetSide ( minersList [ i ] ) ;
95051: LD_ADDR_VAR 0 3
95055: PUSH
95056: LD_EXP 75
95060: PUSH
95061: LD_VAR 0 1
95065: ARRAY
95066: PPUSH
95067: CALL_OW 255
95071: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
95072: LD_ADDR_VAR 0 4
95076: PUSH
95077: LD_EXP 76
95081: PUSH
95082: LD_VAR 0 1
95086: ARRAY
95087: PUSH
95088: LD_VAR 0 2
95092: ARRAY
95093: PUSH
95094: LD_INT 1
95096: ARRAY
95097: PPUSH
95098: LD_EXP 76
95102: PUSH
95103: LD_VAR 0 1
95107: ARRAY
95108: PUSH
95109: LD_VAR 0 2
95113: ARRAY
95114: PUSH
95115: LD_INT 2
95117: ARRAY
95118: PPUSH
95119: CALL_OW 428
95123: ST_TO_ADDR
// if not tmp then
95124: LD_VAR 0 4
95128: NOT
95129: IFFALSE 95133
// continue ;
95131: GO 95048
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
95133: LD_VAR 0 4
95137: PUSH
95138: LD_INT 81
95140: PUSH
95141: LD_VAR 0 3
95145: PUSH
95146: EMPTY
95147: LIST
95148: LIST
95149: PPUSH
95150: CALL_OW 69
95154: IN
95155: PUSH
95156: LD_EXP 76
95160: PUSH
95161: LD_VAR 0 1
95165: ARRAY
95166: PUSH
95167: LD_VAR 0 2
95171: ARRAY
95172: PUSH
95173: LD_INT 1
95175: ARRAY
95176: PPUSH
95177: LD_EXP 76
95181: PUSH
95182: LD_VAR 0 1
95186: ARRAY
95187: PUSH
95188: LD_VAR 0 2
95192: ARRAY
95193: PUSH
95194: LD_INT 2
95196: ARRAY
95197: PPUSH
95198: CALL_OW 458
95202: AND
95203: IFFALSE 95297
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
95205: LD_EXP 76
95209: PUSH
95210: LD_VAR 0 1
95214: ARRAY
95215: PUSH
95216: LD_VAR 0 2
95220: ARRAY
95221: PUSH
95222: LD_INT 1
95224: ARRAY
95225: PPUSH
95226: LD_EXP 76
95230: PUSH
95231: LD_VAR 0 1
95235: ARRAY
95236: PUSH
95237: LD_VAR 0 2
95241: ARRAY
95242: PUSH
95243: LD_INT 2
95245: ARRAY
95246: PPUSH
95247: LD_VAR 0 3
95251: PPUSH
95252: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
95256: LD_ADDR_EXP 76
95260: PUSH
95261: LD_EXP 76
95265: PPUSH
95266: LD_VAR 0 1
95270: PPUSH
95271: LD_EXP 76
95275: PUSH
95276: LD_VAR 0 1
95280: ARRAY
95281: PPUSH
95282: LD_VAR 0 2
95286: PPUSH
95287: CALL_OW 3
95291: PPUSH
95292: CALL_OW 1
95296: ST_TO_ADDR
// end ; end ;
95297: GO 95048
95299: POP
95300: POP
// end ;
95301: GO 94966
95303: POP
95304: POP
// end ;
95305: PPOPN 4
95307: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
95308: LD_INT 0
95310: PPUSH
95311: PPUSH
// result := false ;
95312: LD_ADDR_VAR 0 4
95316: PUSH
95317: LD_INT 0
95319: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
95320: LD_VAR 0 1
95324: PPUSH
95325: CALL_OW 264
95329: PUSH
95330: LD_INT 81
95332: EQUAL
95333: NOT
95334: IFFALSE 95338
// exit ;
95336: GO 95578
// index := GetElementIndex ( minersList , unit ) ;
95338: LD_ADDR_VAR 0 5
95342: PUSH
95343: LD_EXP 75
95347: PPUSH
95348: LD_VAR 0 1
95352: PPUSH
95353: CALL 15862 0 2
95357: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
95358: LD_EXP 76
95362: PUSH
95363: LD_VAR 0 5
95367: ARRAY
95368: PUSH
95369: LD_EXP 77
95373: GREATEREQUAL
95374: IFFALSE 95378
// exit ;
95376: GO 95578
// ComMoveXY ( unit , x , y ) ;
95378: LD_VAR 0 1
95382: PPUSH
95383: LD_VAR 0 2
95387: PPUSH
95388: LD_VAR 0 3
95392: PPUSH
95393: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
95397: LD_INT 35
95399: PPUSH
95400: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
95404: LD_VAR 0 1
95408: PPUSH
95409: LD_VAR 0 2
95413: PPUSH
95414: LD_VAR 0 3
95418: PPUSH
95419: CALL 47603 0 3
95423: NOT
95424: PUSH
95425: LD_VAR 0 1
95429: PPUSH
95430: CALL_OW 314
95434: AND
95435: IFFALSE 95439
// exit ;
95437: GO 95578
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
95439: LD_VAR 0 2
95443: PPUSH
95444: LD_VAR 0 3
95448: PPUSH
95449: CALL_OW 428
95453: PUSH
95454: LD_VAR 0 1
95458: EQUAL
95459: PUSH
95460: LD_VAR 0 1
95464: PPUSH
95465: CALL_OW 314
95469: NOT
95470: AND
95471: IFFALSE 95397
// PlaySoundXY ( x , y , PlantMine ) ;
95473: LD_VAR 0 2
95477: PPUSH
95478: LD_VAR 0 3
95482: PPUSH
95483: LD_STRING PlantMine
95485: PPUSH
95486: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
95490: LD_VAR 0 2
95494: PPUSH
95495: LD_VAR 0 3
95499: PPUSH
95500: LD_VAR 0 1
95504: PPUSH
95505: CALL_OW 255
95509: PPUSH
95510: LD_INT 0
95512: PPUSH
95513: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
95517: LD_ADDR_EXP 76
95521: PUSH
95522: LD_EXP 76
95526: PPUSH
95527: LD_VAR 0 5
95531: PUSH
95532: LD_EXP 76
95536: PUSH
95537: LD_VAR 0 5
95541: ARRAY
95542: PUSH
95543: LD_INT 1
95545: PLUS
95546: PUSH
95547: EMPTY
95548: LIST
95549: LIST
95550: PPUSH
95551: LD_VAR 0 2
95555: PUSH
95556: LD_VAR 0 3
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PPUSH
95565: CALL 16077 0 3
95569: ST_TO_ADDR
// result := true ;
95570: LD_ADDR_VAR 0 4
95574: PUSH
95575: LD_INT 1
95577: ST_TO_ADDR
// end ;
95578: LD_VAR 0 4
95582: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
95583: LD_INT 0
95585: PPUSH
95586: PPUSH
95587: PPUSH
// if not unit in minersList then
95588: LD_VAR 0 1
95592: PUSH
95593: LD_EXP 75
95597: IN
95598: NOT
95599: IFFALSE 95603
// exit ;
95601: GO 95995
// index := GetElementIndex ( minersList , unit ) ;
95603: LD_ADDR_VAR 0 6
95607: PUSH
95608: LD_EXP 75
95612: PPUSH
95613: LD_VAR 0 1
95617: PPUSH
95618: CALL 15862 0 2
95622: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
95623: LD_ADDR_VAR 0 5
95627: PUSH
95628: DOUBLE
95629: LD_EXP 76
95633: PUSH
95634: LD_VAR 0 6
95638: ARRAY
95639: INC
95640: ST_TO_ADDR
95641: LD_INT 1
95643: PUSH
95644: FOR_DOWNTO
95645: IFFALSE 95806
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
95647: LD_EXP 76
95651: PUSH
95652: LD_VAR 0 6
95656: ARRAY
95657: PUSH
95658: LD_VAR 0 5
95662: ARRAY
95663: PUSH
95664: LD_INT 1
95666: ARRAY
95667: PUSH
95668: LD_VAR 0 2
95672: EQUAL
95673: PUSH
95674: LD_EXP 76
95678: PUSH
95679: LD_VAR 0 6
95683: ARRAY
95684: PUSH
95685: LD_VAR 0 5
95689: ARRAY
95690: PUSH
95691: LD_INT 2
95693: ARRAY
95694: PUSH
95695: LD_VAR 0 3
95699: EQUAL
95700: AND
95701: IFFALSE 95804
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
95703: LD_EXP 76
95707: PUSH
95708: LD_VAR 0 6
95712: ARRAY
95713: PUSH
95714: LD_VAR 0 5
95718: ARRAY
95719: PUSH
95720: LD_INT 1
95722: ARRAY
95723: PPUSH
95724: LD_EXP 76
95728: PUSH
95729: LD_VAR 0 6
95733: ARRAY
95734: PUSH
95735: LD_VAR 0 5
95739: ARRAY
95740: PUSH
95741: LD_INT 2
95743: ARRAY
95744: PPUSH
95745: LD_VAR 0 1
95749: PPUSH
95750: CALL_OW 255
95754: PPUSH
95755: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
95759: LD_ADDR_EXP 76
95763: PUSH
95764: LD_EXP 76
95768: PPUSH
95769: LD_VAR 0 6
95773: PPUSH
95774: LD_EXP 76
95778: PUSH
95779: LD_VAR 0 6
95783: ARRAY
95784: PPUSH
95785: LD_VAR 0 5
95789: PPUSH
95790: CALL_OW 3
95794: PPUSH
95795: CALL_OW 1
95799: ST_TO_ADDR
// exit ;
95800: POP
95801: POP
95802: GO 95995
// end ; end ;
95804: GO 95644
95806: POP
95807: POP
// for i := minerMinesList [ index ] downto 1 do
95808: LD_ADDR_VAR 0 5
95812: PUSH
95813: DOUBLE
95814: LD_EXP 76
95818: PUSH
95819: LD_VAR 0 6
95823: ARRAY
95824: INC
95825: ST_TO_ADDR
95826: LD_INT 1
95828: PUSH
95829: FOR_DOWNTO
95830: IFFALSE 95993
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
95832: LD_EXP 76
95836: PUSH
95837: LD_VAR 0 6
95841: ARRAY
95842: PUSH
95843: LD_VAR 0 5
95847: ARRAY
95848: PUSH
95849: LD_INT 1
95851: ARRAY
95852: PPUSH
95853: LD_EXP 76
95857: PUSH
95858: LD_VAR 0 6
95862: ARRAY
95863: PUSH
95864: LD_VAR 0 5
95868: ARRAY
95869: PUSH
95870: LD_INT 2
95872: ARRAY
95873: PPUSH
95874: LD_VAR 0 2
95878: PPUSH
95879: LD_VAR 0 3
95883: PPUSH
95884: CALL_OW 298
95888: PUSH
95889: LD_INT 6
95891: LESS
95892: IFFALSE 95991
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
95894: LD_EXP 76
95898: PUSH
95899: LD_VAR 0 6
95903: ARRAY
95904: PUSH
95905: LD_VAR 0 5
95909: ARRAY
95910: PUSH
95911: LD_INT 1
95913: ARRAY
95914: PPUSH
95915: LD_EXP 76
95919: PUSH
95920: LD_VAR 0 6
95924: ARRAY
95925: PUSH
95926: LD_VAR 0 5
95930: ARRAY
95931: PUSH
95932: LD_INT 2
95934: ARRAY
95935: PPUSH
95936: LD_VAR 0 1
95940: PPUSH
95941: CALL_OW 255
95945: PPUSH
95946: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
95950: LD_ADDR_EXP 76
95954: PUSH
95955: LD_EXP 76
95959: PPUSH
95960: LD_VAR 0 6
95964: PPUSH
95965: LD_EXP 76
95969: PUSH
95970: LD_VAR 0 6
95974: ARRAY
95975: PPUSH
95976: LD_VAR 0 5
95980: PPUSH
95981: CALL_OW 3
95985: PPUSH
95986: CALL_OW 1
95990: ST_TO_ADDR
// end ; end ;
95991: GO 95829
95993: POP
95994: POP
// end ;
95995: LD_VAR 0 4
95999: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
96000: LD_INT 0
96002: PPUSH
96003: PPUSH
96004: PPUSH
96005: PPUSH
96006: PPUSH
96007: PPUSH
96008: PPUSH
96009: PPUSH
96010: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
96011: LD_VAR 0 1
96015: PPUSH
96016: CALL_OW 264
96020: PUSH
96021: LD_INT 81
96023: EQUAL
96024: NOT
96025: PUSH
96026: LD_VAR 0 1
96030: PUSH
96031: LD_EXP 75
96035: IN
96036: NOT
96037: OR
96038: IFFALSE 96042
// exit ;
96040: GO 96364
// index := GetElementIndex ( minersList , unit ) ;
96042: LD_ADDR_VAR 0 6
96046: PUSH
96047: LD_EXP 75
96051: PPUSH
96052: LD_VAR 0 1
96056: PPUSH
96057: CALL 15862 0 2
96061: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
96062: LD_ADDR_VAR 0 8
96066: PUSH
96067: LD_EXP 77
96071: PUSH
96072: LD_EXP 76
96076: PUSH
96077: LD_VAR 0 6
96081: ARRAY
96082: MINUS
96083: ST_TO_ADDR
// if not minesFreeAmount then
96084: LD_VAR 0 8
96088: NOT
96089: IFFALSE 96093
// exit ;
96091: GO 96364
// tmp := [ ] ;
96093: LD_ADDR_VAR 0 7
96097: PUSH
96098: EMPTY
96099: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
96100: LD_ADDR_VAR 0 5
96104: PUSH
96105: DOUBLE
96106: LD_INT 1
96108: DEC
96109: ST_TO_ADDR
96110: LD_VAR 0 8
96114: PUSH
96115: FOR_TO
96116: IFFALSE 96311
// begin _d := rand ( 0 , 5 ) ;
96118: LD_ADDR_VAR 0 11
96122: PUSH
96123: LD_INT 0
96125: PPUSH
96126: LD_INT 5
96128: PPUSH
96129: CALL_OW 12
96133: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
96134: LD_ADDR_VAR 0 12
96138: PUSH
96139: LD_INT 2
96141: PPUSH
96142: LD_INT 6
96144: PPUSH
96145: CALL_OW 12
96149: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
96150: LD_ADDR_VAR 0 9
96154: PUSH
96155: LD_VAR 0 2
96159: PPUSH
96160: LD_VAR 0 11
96164: PPUSH
96165: LD_VAR 0 12
96169: PPUSH
96170: CALL_OW 272
96174: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
96175: LD_ADDR_VAR 0 10
96179: PUSH
96180: LD_VAR 0 3
96184: PPUSH
96185: LD_VAR 0 11
96189: PPUSH
96190: LD_VAR 0 12
96194: PPUSH
96195: CALL_OW 273
96199: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
96200: LD_VAR 0 9
96204: PPUSH
96205: LD_VAR 0 10
96209: PPUSH
96210: CALL_OW 488
96214: PUSH
96215: LD_VAR 0 9
96219: PUSH
96220: LD_VAR 0 10
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PUSH
96229: LD_VAR 0 7
96233: IN
96234: NOT
96235: AND
96236: PUSH
96237: LD_VAR 0 9
96241: PPUSH
96242: LD_VAR 0 10
96246: PPUSH
96247: CALL_OW 458
96251: NOT
96252: AND
96253: IFFALSE 96295
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
96255: LD_ADDR_VAR 0 7
96259: PUSH
96260: LD_VAR 0 7
96264: PPUSH
96265: LD_VAR 0 7
96269: PUSH
96270: LD_INT 1
96272: PLUS
96273: PPUSH
96274: LD_VAR 0 9
96278: PUSH
96279: LD_VAR 0 10
96283: PUSH
96284: EMPTY
96285: LIST
96286: LIST
96287: PPUSH
96288: CALL_OW 1
96292: ST_TO_ADDR
96293: GO 96309
// i := i - 1 ;
96295: LD_ADDR_VAR 0 5
96299: PUSH
96300: LD_VAR 0 5
96304: PUSH
96305: LD_INT 1
96307: MINUS
96308: ST_TO_ADDR
// end ;
96309: GO 96115
96311: POP
96312: POP
// for i in tmp do
96313: LD_ADDR_VAR 0 5
96317: PUSH
96318: LD_VAR 0 7
96322: PUSH
96323: FOR_IN
96324: IFFALSE 96362
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
96326: LD_VAR 0 1
96330: PPUSH
96331: LD_VAR 0 5
96335: PUSH
96336: LD_INT 1
96338: ARRAY
96339: PPUSH
96340: LD_VAR 0 5
96344: PUSH
96345: LD_INT 2
96347: ARRAY
96348: PPUSH
96349: CALL 95308 0 3
96353: NOT
96354: IFFALSE 96360
// exit ;
96356: POP
96357: POP
96358: GO 96364
96360: GO 96323
96362: POP
96363: POP
// end ;
96364: LD_VAR 0 4
96368: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
96369: LD_INT 0
96371: PPUSH
96372: PPUSH
96373: PPUSH
96374: PPUSH
96375: PPUSH
96376: PPUSH
96377: PPUSH
// if not GetClass ( unit ) = class_sniper then
96378: LD_VAR 0 1
96382: PPUSH
96383: CALL_OW 257
96387: PUSH
96388: LD_INT 5
96390: EQUAL
96391: NOT
96392: IFFALSE 96396
// exit ;
96394: GO 96784
// dist := 8 ;
96396: LD_ADDR_VAR 0 5
96400: PUSH
96401: LD_INT 8
96403: ST_TO_ADDR
// viewRange := 12 ;
96404: LD_ADDR_VAR 0 7
96408: PUSH
96409: LD_INT 12
96411: ST_TO_ADDR
// side := GetSide ( unit ) ;
96412: LD_ADDR_VAR 0 6
96416: PUSH
96417: LD_VAR 0 1
96421: PPUSH
96422: CALL_OW 255
96426: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
96427: LD_INT 61
96429: PPUSH
96430: LD_VAR 0 6
96434: PPUSH
96435: CALL_OW 321
96439: PUSH
96440: LD_INT 2
96442: EQUAL
96443: IFFALSE 96453
// viewRange := 16 ;
96445: LD_ADDR_VAR 0 7
96449: PUSH
96450: LD_INT 16
96452: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
96453: LD_VAR 0 1
96457: PPUSH
96458: LD_VAR 0 2
96462: PPUSH
96463: LD_VAR 0 3
96467: PPUSH
96468: CALL_OW 297
96472: PUSH
96473: LD_VAR 0 5
96477: GREATER
96478: IFFALSE 96557
// begin ComMoveXY ( unit , x , y ) ;
96480: LD_VAR 0 1
96484: PPUSH
96485: LD_VAR 0 2
96489: PPUSH
96490: LD_VAR 0 3
96494: PPUSH
96495: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
96499: LD_INT 35
96501: PPUSH
96502: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
96506: LD_VAR 0 1
96510: PPUSH
96511: LD_VAR 0 2
96515: PPUSH
96516: LD_VAR 0 3
96520: PPUSH
96521: CALL 47603 0 3
96525: NOT
96526: IFFALSE 96530
// exit ;
96528: GO 96784
// until GetDistUnitXY ( unit , x , y ) < dist ;
96530: LD_VAR 0 1
96534: PPUSH
96535: LD_VAR 0 2
96539: PPUSH
96540: LD_VAR 0 3
96544: PPUSH
96545: CALL_OW 297
96549: PUSH
96550: LD_VAR 0 5
96554: LESS
96555: IFFALSE 96499
// end ; ComTurnXY ( unit , x , y ) ;
96557: LD_VAR 0 1
96561: PPUSH
96562: LD_VAR 0 2
96566: PPUSH
96567: LD_VAR 0 3
96571: PPUSH
96572: CALL_OW 118
// wait ( 5 ) ;
96576: LD_INT 5
96578: PPUSH
96579: CALL_OW 67
// _d := GetDir ( unit ) ;
96583: LD_ADDR_VAR 0 10
96587: PUSH
96588: LD_VAR 0 1
96592: PPUSH
96593: CALL_OW 254
96597: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
96598: LD_ADDR_VAR 0 8
96602: PUSH
96603: LD_VAR 0 1
96607: PPUSH
96608: CALL_OW 250
96612: PPUSH
96613: LD_VAR 0 10
96617: PPUSH
96618: LD_VAR 0 5
96622: PPUSH
96623: CALL_OW 272
96627: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
96628: LD_ADDR_VAR 0 9
96632: PUSH
96633: LD_VAR 0 1
96637: PPUSH
96638: CALL_OW 251
96642: PPUSH
96643: LD_VAR 0 10
96647: PPUSH
96648: LD_VAR 0 5
96652: PPUSH
96653: CALL_OW 273
96657: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
96658: LD_VAR 0 8
96662: PPUSH
96663: LD_VAR 0 9
96667: PPUSH
96668: CALL_OW 488
96672: NOT
96673: IFFALSE 96677
// exit ;
96675: GO 96784
// ComAnimCustom ( unit , 1 ) ;
96677: LD_VAR 0 1
96681: PPUSH
96682: LD_INT 1
96684: PPUSH
96685: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
96689: LD_VAR 0 8
96693: PPUSH
96694: LD_VAR 0 9
96698: PPUSH
96699: LD_VAR 0 6
96703: PPUSH
96704: LD_VAR 0 7
96708: PPUSH
96709: CALL_OW 330
// repeat wait ( 1 ) ;
96713: LD_INT 1
96715: PPUSH
96716: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
96720: LD_VAR 0 1
96724: PPUSH
96725: CALL_OW 316
96729: PUSH
96730: LD_VAR 0 1
96734: PPUSH
96735: CALL_OW 314
96739: OR
96740: PUSH
96741: LD_VAR 0 1
96745: PPUSH
96746: CALL_OW 302
96750: NOT
96751: OR
96752: PUSH
96753: LD_VAR 0 1
96757: PPUSH
96758: CALL_OW 301
96762: OR
96763: IFFALSE 96713
// RemoveSeeing ( _x , _y , side ) ;
96765: LD_VAR 0 8
96769: PPUSH
96770: LD_VAR 0 9
96774: PPUSH
96775: LD_VAR 0 6
96779: PPUSH
96780: CALL_OW 331
// end ; end_of_file end_of_file
96784: LD_VAR 0 4
96788: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
96789: LD_VAR 0 1
96793: PUSH
96794: LD_INT 200
96796: DOUBLE
96797: GREATEREQUAL
96798: IFFALSE 96806
96800: LD_INT 299
96802: DOUBLE
96803: LESSEQUAL
96804: IFTRUE 96808
96806: GO 96840
96808: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
96809: LD_VAR 0 1
96813: PPUSH
96814: LD_VAR 0 2
96818: PPUSH
96819: LD_VAR 0 3
96823: PPUSH
96824: LD_VAR 0 4
96828: PPUSH
96829: LD_VAR 0 5
96833: PPUSH
96834: CALL 92271 0 5
96838: GO 96917
96840: LD_INT 300
96842: DOUBLE
96843: GREATEREQUAL
96844: IFFALSE 96852
96846: LD_INT 399
96848: DOUBLE
96849: LESSEQUAL
96850: IFTRUE 96854
96852: GO 96916
96854: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
96855: LD_VAR 0 1
96859: PPUSH
96860: LD_VAR 0 2
96864: PPUSH
96865: LD_VAR 0 3
96869: PPUSH
96870: LD_VAR 0 4
96874: PPUSH
96875: LD_VAR 0 5
96879: PPUSH
96880: LD_VAR 0 6
96884: PPUSH
96885: LD_VAR 0 7
96889: PPUSH
96890: LD_VAR 0 8
96894: PPUSH
96895: LD_VAR 0 9
96899: PPUSH
96900: LD_VAR 0 10
96904: PPUSH
96905: LD_VAR 0 11
96909: PPUSH
96910: CALL 109472 0 11
96914: GO 96917
96916: POP
// end ;
96917: PPOPN 11
96919: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
96920: LD_VAR 0 1
96924: PPUSH
96925: LD_VAR 0 2
96929: PPUSH
96930: LD_VAR 0 3
96934: PPUSH
96935: LD_VAR 0 4
96939: PPUSH
96940: LD_VAR 0 5
96944: PPUSH
96945: CALL 92007 0 5
// end ; end_of_file
96949: PPOPN 5
96951: END
// export globalGameSaveCounter ; every 0 0$1 do
96952: GO 96954
96954: DISABLE
// begin enable ;
96955: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
96956: LD_STRING updateTimer(
96958: PUSH
96959: LD_OWVAR 1
96963: STR
96964: PUSH
96965: LD_STRING );
96967: STR
96968: PPUSH
96969: CALL_OW 559
// end ;
96973: END
// every 0 0$1 do
96974: GO 96976
96976: DISABLE
// begin globalGameSaveCounter := 0 ;
96977: LD_ADDR_EXP 78
96981: PUSH
96982: LD_INT 0
96984: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
96985: LD_STRING setGameSaveCounter(0)
96987: PPUSH
96988: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
96992: LD_STRING initStreamRollete();
96994: PPUSH
96995: CALL_OW 559
// InitStreamMode ;
96999: CALL 98342 0 0
// DefineStreamItems ( false ) ;
97003: LD_INT 0
97005: PPUSH
97006: CALL 98806 0 1
// end ;
97010: END
// export function SOS_MapStart ( ) ; begin
97011: LD_INT 0
97013: PPUSH
// if streamModeActive then
97014: LD_EXP 79
97018: IFFALSE 97027
// DefineStreamItems ( true ) ;
97020: LD_INT 1
97022: PPUSH
97023: CALL 98806 0 1
// UpdateLuaVariables ( ) ;
97027: CALL 97044 0 0
// UpdateFactoryWaypoints ( ) ;
97031: CALL 111675 0 0
// UpdateWarehouseGatheringPoints ( ) ;
97035: CALL 111932 0 0
// end ;
97039: LD_VAR 0 1
97043: RET
// function UpdateLuaVariables ( ) ; begin
97044: LD_INT 0
97046: PPUSH
// if globalGameSaveCounter then
97047: LD_EXP 78
97051: IFFALSE 97085
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
97053: LD_ADDR_EXP 78
97057: PUSH
97058: LD_EXP 78
97062: PPUSH
97063: CALL 50167 0 1
97067: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
97068: LD_STRING setGameSaveCounter(
97070: PUSH
97071: LD_EXP 78
97075: STR
97076: PUSH
97077: LD_STRING )
97079: STR
97080: PPUSH
97081: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
97085: LD_STRING setGameDifficulty(
97087: PUSH
97088: LD_OWVAR 67
97092: STR
97093: PUSH
97094: LD_STRING )
97096: STR
97097: PPUSH
97098: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
97102: LD_STRING displayDifficulty(
97104: PUSH
97105: LD_OWVAR 67
97109: STR
97110: PUSH
97111: LD_STRING )
97113: STR
97114: PPUSH
97115: CALL_OW 559
// end ;
97119: LD_VAR 0 1
97123: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
97124: LD_INT 0
97126: PPUSH
// if p2 = stream_mode then
97127: LD_VAR 0 2
97131: PUSH
97132: LD_INT 100
97134: EQUAL
97135: IFFALSE 98138
// begin if not StreamModeActive then
97137: LD_EXP 79
97141: NOT
97142: IFFALSE 97152
// StreamModeActive := true ;
97144: LD_ADDR_EXP 79
97148: PUSH
97149: LD_INT 1
97151: ST_TO_ADDR
// if p3 = 0 then
97152: LD_VAR 0 3
97156: PUSH
97157: LD_INT 0
97159: EQUAL
97160: IFFALSE 97166
// InitStreamMode ;
97162: CALL 98342 0 0
// if p3 = 1 then
97166: LD_VAR 0 3
97170: PUSH
97171: LD_INT 1
97173: EQUAL
97174: IFFALSE 97184
// sRocket := true ;
97176: LD_ADDR_EXP 84
97180: PUSH
97181: LD_INT 1
97183: ST_TO_ADDR
// if p3 = 2 then
97184: LD_VAR 0 3
97188: PUSH
97189: LD_INT 2
97191: EQUAL
97192: IFFALSE 97202
// sSpeed := true ;
97194: LD_ADDR_EXP 83
97198: PUSH
97199: LD_INT 1
97201: ST_TO_ADDR
// if p3 = 3 then
97202: LD_VAR 0 3
97206: PUSH
97207: LD_INT 3
97209: EQUAL
97210: IFFALSE 97220
// sEngine := true ;
97212: LD_ADDR_EXP 85
97216: PUSH
97217: LD_INT 1
97219: ST_TO_ADDR
// if p3 = 4 then
97220: LD_VAR 0 3
97224: PUSH
97225: LD_INT 4
97227: EQUAL
97228: IFFALSE 97238
// sSpec := true ;
97230: LD_ADDR_EXP 82
97234: PUSH
97235: LD_INT 1
97237: ST_TO_ADDR
// if p3 = 5 then
97238: LD_VAR 0 3
97242: PUSH
97243: LD_INT 5
97245: EQUAL
97246: IFFALSE 97256
// sLevel := true ;
97248: LD_ADDR_EXP 86
97252: PUSH
97253: LD_INT 1
97255: ST_TO_ADDR
// if p3 = 6 then
97256: LD_VAR 0 3
97260: PUSH
97261: LD_INT 6
97263: EQUAL
97264: IFFALSE 97274
// sArmoury := true ;
97266: LD_ADDR_EXP 87
97270: PUSH
97271: LD_INT 1
97273: ST_TO_ADDR
// if p3 = 7 then
97274: LD_VAR 0 3
97278: PUSH
97279: LD_INT 7
97281: EQUAL
97282: IFFALSE 97292
// sRadar := true ;
97284: LD_ADDR_EXP 88
97288: PUSH
97289: LD_INT 1
97291: ST_TO_ADDR
// if p3 = 8 then
97292: LD_VAR 0 3
97296: PUSH
97297: LD_INT 8
97299: EQUAL
97300: IFFALSE 97310
// sBunker := true ;
97302: LD_ADDR_EXP 89
97306: PUSH
97307: LD_INT 1
97309: ST_TO_ADDR
// if p3 = 9 then
97310: LD_VAR 0 3
97314: PUSH
97315: LD_INT 9
97317: EQUAL
97318: IFFALSE 97328
// sHack := true ;
97320: LD_ADDR_EXP 90
97324: PUSH
97325: LD_INT 1
97327: ST_TO_ADDR
// if p3 = 10 then
97328: LD_VAR 0 3
97332: PUSH
97333: LD_INT 10
97335: EQUAL
97336: IFFALSE 97346
// sFire := true ;
97338: LD_ADDR_EXP 91
97342: PUSH
97343: LD_INT 1
97345: ST_TO_ADDR
// if p3 = 11 then
97346: LD_VAR 0 3
97350: PUSH
97351: LD_INT 11
97353: EQUAL
97354: IFFALSE 97364
// sRefresh := true ;
97356: LD_ADDR_EXP 92
97360: PUSH
97361: LD_INT 1
97363: ST_TO_ADDR
// if p3 = 12 then
97364: LD_VAR 0 3
97368: PUSH
97369: LD_INT 12
97371: EQUAL
97372: IFFALSE 97382
// sExp := true ;
97374: LD_ADDR_EXP 93
97378: PUSH
97379: LD_INT 1
97381: ST_TO_ADDR
// if p3 = 13 then
97382: LD_VAR 0 3
97386: PUSH
97387: LD_INT 13
97389: EQUAL
97390: IFFALSE 97400
// sDepot := true ;
97392: LD_ADDR_EXP 94
97396: PUSH
97397: LD_INT 1
97399: ST_TO_ADDR
// if p3 = 14 then
97400: LD_VAR 0 3
97404: PUSH
97405: LD_INT 14
97407: EQUAL
97408: IFFALSE 97418
// sFlag := true ;
97410: LD_ADDR_EXP 95
97414: PUSH
97415: LD_INT 1
97417: ST_TO_ADDR
// if p3 = 15 then
97418: LD_VAR 0 3
97422: PUSH
97423: LD_INT 15
97425: EQUAL
97426: IFFALSE 97436
// sKamikadze := true ;
97428: LD_ADDR_EXP 103
97432: PUSH
97433: LD_INT 1
97435: ST_TO_ADDR
// if p3 = 16 then
97436: LD_VAR 0 3
97440: PUSH
97441: LD_INT 16
97443: EQUAL
97444: IFFALSE 97454
// sTroll := true ;
97446: LD_ADDR_EXP 104
97450: PUSH
97451: LD_INT 1
97453: ST_TO_ADDR
// if p3 = 17 then
97454: LD_VAR 0 3
97458: PUSH
97459: LD_INT 17
97461: EQUAL
97462: IFFALSE 97472
// sSlow := true ;
97464: LD_ADDR_EXP 105
97468: PUSH
97469: LD_INT 1
97471: ST_TO_ADDR
// if p3 = 18 then
97472: LD_VAR 0 3
97476: PUSH
97477: LD_INT 18
97479: EQUAL
97480: IFFALSE 97490
// sLack := true ;
97482: LD_ADDR_EXP 106
97486: PUSH
97487: LD_INT 1
97489: ST_TO_ADDR
// if p3 = 19 then
97490: LD_VAR 0 3
97494: PUSH
97495: LD_INT 19
97497: EQUAL
97498: IFFALSE 97508
// sTank := true ;
97500: LD_ADDR_EXP 108
97504: PUSH
97505: LD_INT 1
97507: ST_TO_ADDR
// if p3 = 20 then
97508: LD_VAR 0 3
97512: PUSH
97513: LD_INT 20
97515: EQUAL
97516: IFFALSE 97526
// sRemote := true ;
97518: LD_ADDR_EXP 109
97522: PUSH
97523: LD_INT 1
97525: ST_TO_ADDR
// if p3 = 21 then
97526: LD_VAR 0 3
97530: PUSH
97531: LD_INT 21
97533: EQUAL
97534: IFFALSE 97544
// sPowell := true ;
97536: LD_ADDR_EXP 110
97540: PUSH
97541: LD_INT 1
97543: ST_TO_ADDR
// if p3 = 22 then
97544: LD_VAR 0 3
97548: PUSH
97549: LD_INT 22
97551: EQUAL
97552: IFFALSE 97562
// sTeleport := true ;
97554: LD_ADDR_EXP 113
97558: PUSH
97559: LD_INT 1
97561: ST_TO_ADDR
// if p3 = 23 then
97562: LD_VAR 0 3
97566: PUSH
97567: LD_INT 23
97569: EQUAL
97570: IFFALSE 97580
// sOilTower := true ;
97572: LD_ADDR_EXP 115
97576: PUSH
97577: LD_INT 1
97579: ST_TO_ADDR
// if p3 = 24 then
97580: LD_VAR 0 3
97584: PUSH
97585: LD_INT 24
97587: EQUAL
97588: IFFALSE 97598
// sShovel := true ;
97590: LD_ADDR_EXP 116
97594: PUSH
97595: LD_INT 1
97597: ST_TO_ADDR
// if p3 = 25 then
97598: LD_VAR 0 3
97602: PUSH
97603: LD_INT 25
97605: EQUAL
97606: IFFALSE 97616
// sSheik := true ;
97608: LD_ADDR_EXP 117
97612: PUSH
97613: LD_INT 1
97615: ST_TO_ADDR
// if p3 = 26 then
97616: LD_VAR 0 3
97620: PUSH
97621: LD_INT 26
97623: EQUAL
97624: IFFALSE 97634
// sEarthquake := true ;
97626: LD_ADDR_EXP 119
97630: PUSH
97631: LD_INT 1
97633: ST_TO_ADDR
// if p3 = 27 then
97634: LD_VAR 0 3
97638: PUSH
97639: LD_INT 27
97641: EQUAL
97642: IFFALSE 97652
// sAI := true ;
97644: LD_ADDR_EXP 120
97648: PUSH
97649: LD_INT 1
97651: ST_TO_ADDR
// if p3 = 28 then
97652: LD_VAR 0 3
97656: PUSH
97657: LD_INT 28
97659: EQUAL
97660: IFFALSE 97670
// sCargo := true ;
97662: LD_ADDR_EXP 123
97666: PUSH
97667: LD_INT 1
97669: ST_TO_ADDR
// if p3 = 29 then
97670: LD_VAR 0 3
97674: PUSH
97675: LD_INT 29
97677: EQUAL
97678: IFFALSE 97688
// sDLaser := true ;
97680: LD_ADDR_EXP 124
97684: PUSH
97685: LD_INT 1
97687: ST_TO_ADDR
// if p3 = 30 then
97688: LD_VAR 0 3
97692: PUSH
97693: LD_INT 30
97695: EQUAL
97696: IFFALSE 97706
// sExchange := true ;
97698: LD_ADDR_EXP 125
97702: PUSH
97703: LD_INT 1
97705: ST_TO_ADDR
// if p3 = 31 then
97706: LD_VAR 0 3
97710: PUSH
97711: LD_INT 31
97713: EQUAL
97714: IFFALSE 97724
// sFac := true ;
97716: LD_ADDR_EXP 126
97720: PUSH
97721: LD_INT 1
97723: ST_TO_ADDR
// if p3 = 32 then
97724: LD_VAR 0 3
97728: PUSH
97729: LD_INT 32
97731: EQUAL
97732: IFFALSE 97742
// sPower := true ;
97734: LD_ADDR_EXP 127
97738: PUSH
97739: LD_INT 1
97741: ST_TO_ADDR
// if p3 = 33 then
97742: LD_VAR 0 3
97746: PUSH
97747: LD_INT 33
97749: EQUAL
97750: IFFALSE 97760
// sRandom := true ;
97752: LD_ADDR_EXP 128
97756: PUSH
97757: LD_INT 1
97759: ST_TO_ADDR
// if p3 = 34 then
97760: LD_VAR 0 3
97764: PUSH
97765: LD_INT 34
97767: EQUAL
97768: IFFALSE 97778
// sShield := true ;
97770: LD_ADDR_EXP 129
97774: PUSH
97775: LD_INT 1
97777: ST_TO_ADDR
// if p3 = 35 then
97778: LD_VAR 0 3
97782: PUSH
97783: LD_INT 35
97785: EQUAL
97786: IFFALSE 97796
// sTime := true ;
97788: LD_ADDR_EXP 130
97792: PUSH
97793: LD_INT 1
97795: ST_TO_ADDR
// if p3 = 36 then
97796: LD_VAR 0 3
97800: PUSH
97801: LD_INT 36
97803: EQUAL
97804: IFFALSE 97814
// sTools := true ;
97806: LD_ADDR_EXP 131
97810: PUSH
97811: LD_INT 1
97813: ST_TO_ADDR
// if p3 = 101 then
97814: LD_VAR 0 3
97818: PUSH
97819: LD_INT 101
97821: EQUAL
97822: IFFALSE 97832
// sSold := true ;
97824: LD_ADDR_EXP 96
97828: PUSH
97829: LD_INT 1
97831: ST_TO_ADDR
// if p3 = 102 then
97832: LD_VAR 0 3
97836: PUSH
97837: LD_INT 102
97839: EQUAL
97840: IFFALSE 97850
// sDiff := true ;
97842: LD_ADDR_EXP 97
97846: PUSH
97847: LD_INT 1
97849: ST_TO_ADDR
// if p3 = 103 then
97850: LD_VAR 0 3
97854: PUSH
97855: LD_INT 103
97857: EQUAL
97858: IFFALSE 97868
// sFog := true ;
97860: LD_ADDR_EXP 100
97864: PUSH
97865: LD_INT 1
97867: ST_TO_ADDR
// if p3 = 104 then
97868: LD_VAR 0 3
97872: PUSH
97873: LD_INT 104
97875: EQUAL
97876: IFFALSE 97886
// sReset := true ;
97878: LD_ADDR_EXP 101
97882: PUSH
97883: LD_INT 1
97885: ST_TO_ADDR
// if p3 = 105 then
97886: LD_VAR 0 3
97890: PUSH
97891: LD_INT 105
97893: EQUAL
97894: IFFALSE 97904
// sSun := true ;
97896: LD_ADDR_EXP 102
97900: PUSH
97901: LD_INT 1
97903: ST_TO_ADDR
// if p3 = 106 then
97904: LD_VAR 0 3
97908: PUSH
97909: LD_INT 106
97911: EQUAL
97912: IFFALSE 97922
// sTiger := true ;
97914: LD_ADDR_EXP 98
97918: PUSH
97919: LD_INT 1
97921: ST_TO_ADDR
// if p3 = 107 then
97922: LD_VAR 0 3
97926: PUSH
97927: LD_INT 107
97929: EQUAL
97930: IFFALSE 97940
// sBomb := true ;
97932: LD_ADDR_EXP 99
97936: PUSH
97937: LD_INT 1
97939: ST_TO_ADDR
// if p3 = 108 then
97940: LD_VAR 0 3
97944: PUSH
97945: LD_INT 108
97947: EQUAL
97948: IFFALSE 97958
// sWound := true ;
97950: LD_ADDR_EXP 107
97954: PUSH
97955: LD_INT 1
97957: ST_TO_ADDR
// if p3 = 109 then
97958: LD_VAR 0 3
97962: PUSH
97963: LD_INT 109
97965: EQUAL
97966: IFFALSE 97976
// sBetray := true ;
97968: LD_ADDR_EXP 111
97972: PUSH
97973: LD_INT 1
97975: ST_TO_ADDR
// if p3 = 110 then
97976: LD_VAR 0 3
97980: PUSH
97981: LD_INT 110
97983: EQUAL
97984: IFFALSE 97994
// sContamin := true ;
97986: LD_ADDR_EXP 112
97990: PUSH
97991: LD_INT 1
97993: ST_TO_ADDR
// if p3 = 111 then
97994: LD_VAR 0 3
97998: PUSH
97999: LD_INT 111
98001: EQUAL
98002: IFFALSE 98012
// sOil := true ;
98004: LD_ADDR_EXP 114
98008: PUSH
98009: LD_INT 1
98011: ST_TO_ADDR
// if p3 = 112 then
98012: LD_VAR 0 3
98016: PUSH
98017: LD_INT 112
98019: EQUAL
98020: IFFALSE 98030
// sStu := true ;
98022: LD_ADDR_EXP 118
98026: PUSH
98027: LD_INT 1
98029: ST_TO_ADDR
// if p3 = 113 then
98030: LD_VAR 0 3
98034: PUSH
98035: LD_INT 113
98037: EQUAL
98038: IFFALSE 98048
// sBazooka := true ;
98040: LD_ADDR_EXP 121
98044: PUSH
98045: LD_INT 1
98047: ST_TO_ADDR
// if p3 = 114 then
98048: LD_VAR 0 3
98052: PUSH
98053: LD_INT 114
98055: EQUAL
98056: IFFALSE 98066
// sMortar := true ;
98058: LD_ADDR_EXP 122
98062: PUSH
98063: LD_INT 1
98065: ST_TO_ADDR
// if p3 = 115 then
98066: LD_VAR 0 3
98070: PUSH
98071: LD_INT 115
98073: EQUAL
98074: IFFALSE 98084
// sRanger := true ;
98076: LD_ADDR_EXP 132
98080: PUSH
98081: LD_INT 1
98083: ST_TO_ADDR
// if p3 = 116 then
98084: LD_VAR 0 3
98088: PUSH
98089: LD_INT 116
98091: EQUAL
98092: IFFALSE 98102
// sComputer := true ;
98094: LD_ADDR_EXP 133
98098: PUSH
98099: LD_INT 1
98101: ST_TO_ADDR
// if p3 = 117 then
98102: LD_VAR 0 3
98106: PUSH
98107: LD_INT 117
98109: EQUAL
98110: IFFALSE 98120
// s30 := true ;
98112: LD_ADDR_EXP 134
98116: PUSH
98117: LD_INT 1
98119: ST_TO_ADDR
// if p3 = 118 then
98120: LD_VAR 0 3
98124: PUSH
98125: LD_INT 118
98127: EQUAL
98128: IFFALSE 98138
// s60 := true ;
98130: LD_ADDR_EXP 135
98134: PUSH
98135: LD_INT 1
98137: ST_TO_ADDR
// end ; if p2 = hack_mode then
98138: LD_VAR 0 2
98142: PUSH
98143: LD_INT 101
98145: EQUAL
98146: IFFALSE 98274
// begin case p3 of 1 :
98148: LD_VAR 0 3
98152: PUSH
98153: LD_INT 1
98155: DOUBLE
98156: EQUAL
98157: IFTRUE 98161
98159: GO 98168
98161: POP
// hHackUnlimitedResources ; 2 :
98162: CALL 110421 0 0
98166: GO 98274
98168: LD_INT 2
98170: DOUBLE
98171: EQUAL
98172: IFTRUE 98176
98174: GO 98183
98176: POP
// hHackSetLevel10 ; 3 :
98177: CALL 110554 0 0
98181: GO 98274
98183: LD_INT 3
98185: DOUBLE
98186: EQUAL
98187: IFTRUE 98191
98189: GO 98198
98191: POP
// hHackSetLevel10YourUnits ; 4 :
98192: CALL 110639 0 0
98196: GO 98274
98198: LD_INT 4
98200: DOUBLE
98201: EQUAL
98202: IFTRUE 98206
98204: GO 98213
98206: POP
// hHackInvincible ; 5 :
98207: CALL 111087 0 0
98211: GO 98274
98213: LD_INT 5
98215: DOUBLE
98216: EQUAL
98217: IFTRUE 98221
98219: GO 98228
98221: POP
// hHackInvisible ; 6 :
98222: CALL 111198 0 0
98226: GO 98274
98228: LD_INT 6
98230: DOUBLE
98231: EQUAL
98232: IFTRUE 98236
98234: GO 98243
98236: POP
// hHackChangeYourSide ; 7 :
98237: CALL 111255 0 0
98241: GO 98274
98243: LD_INT 7
98245: DOUBLE
98246: EQUAL
98247: IFTRUE 98251
98249: GO 98258
98251: POP
// hHackChangeUnitSide ; 8 :
98252: CALL 111297 0 0
98256: GO 98274
98258: LD_INT 8
98260: DOUBLE
98261: EQUAL
98262: IFTRUE 98266
98264: GO 98273
98266: POP
// hHackFog ; end ;
98267: CALL 111398 0 0
98271: GO 98274
98273: POP
// end ; if p2 = game_save_mode then
98274: LD_VAR 0 2
98278: PUSH
98279: LD_INT 102
98281: EQUAL
98282: IFFALSE 98337
// begin if p3 = 1 then
98284: LD_VAR 0 3
98288: PUSH
98289: LD_INT 1
98291: EQUAL
98292: IFFALSE 98304
// globalGameSaveCounter := p4 ;
98294: LD_ADDR_EXP 78
98298: PUSH
98299: LD_VAR 0 4
98303: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
98304: LD_VAR 0 3
98308: PUSH
98309: LD_INT 2
98311: EQUAL
98312: PUSH
98313: LD_EXP 78
98317: AND
98318: IFFALSE 98337
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
98320: LD_STRING setGameSaveCounter(
98322: PUSH
98323: LD_EXP 78
98327: STR
98328: PUSH
98329: LD_STRING )
98331: STR
98332: PPUSH
98333: CALL_OW 559
// end ; end ;
98337: LD_VAR 0 7
98341: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
98342: LD_INT 0
98344: PPUSH
// streamModeActive := false ;
98345: LD_ADDR_EXP 79
98349: PUSH
98350: LD_INT 0
98352: ST_TO_ADDR
// normalCounter := 36 ;
98353: LD_ADDR_EXP 80
98357: PUSH
98358: LD_INT 36
98360: ST_TO_ADDR
// hardcoreCounter := 18 ;
98361: LD_ADDR_EXP 81
98365: PUSH
98366: LD_INT 18
98368: ST_TO_ADDR
// sRocket := false ;
98369: LD_ADDR_EXP 84
98373: PUSH
98374: LD_INT 0
98376: ST_TO_ADDR
// sSpeed := false ;
98377: LD_ADDR_EXP 83
98381: PUSH
98382: LD_INT 0
98384: ST_TO_ADDR
// sEngine := false ;
98385: LD_ADDR_EXP 85
98389: PUSH
98390: LD_INT 0
98392: ST_TO_ADDR
// sSpec := false ;
98393: LD_ADDR_EXP 82
98397: PUSH
98398: LD_INT 0
98400: ST_TO_ADDR
// sLevel := false ;
98401: LD_ADDR_EXP 86
98405: PUSH
98406: LD_INT 0
98408: ST_TO_ADDR
// sArmoury := false ;
98409: LD_ADDR_EXP 87
98413: PUSH
98414: LD_INT 0
98416: ST_TO_ADDR
// sRadar := false ;
98417: LD_ADDR_EXP 88
98421: PUSH
98422: LD_INT 0
98424: ST_TO_ADDR
// sBunker := false ;
98425: LD_ADDR_EXP 89
98429: PUSH
98430: LD_INT 0
98432: ST_TO_ADDR
// sHack := false ;
98433: LD_ADDR_EXP 90
98437: PUSH
98438: LD_INT 0
98440: ST_TO_ADDR
// sFire := false ;
98441: LD_ADDR_EXP 91
98445: PUSH
98446: LD_INT 0
98448: ST_TO_ADDR
// sRefresh := false ;
98449: LD_ADDR_EXP 92
98453: PUSH
98454: LD_INT 0
98456: ST_TO_ADDR
// sExp := false ;
98457: LD_ADDR_EXP 93
98461: PUSH
98462: LD_INT 0
98464: ST_TO_ADDR
// sDepot := false ;
98465: LD_ADDR_EXP 94
98469: PUSH
98470: LD_INT 0
98472: ST_TO_ADDR
// sFlag := false ;
98473: LD_ADDR_EXP 95
98477: PUSH
98478: LD_INT 0
98480: ST_TO_ADDR
// sKamikadze := false ;
98481: LD_ADDR_EXP 103
98485: PUSH
98486: LD_INT 0
98488: ST_TO_ADDR
// sTroll := false ;
98489: LD_ADDR_EXP 104
98493: PUSH
98494: LD_INT 0
98496: ST_TO_ADDR
// sSlow := false ;
98497: LD_ADDR_EXP 105
98501: PUSH
98502: LD_INT 0
98504: ST_TO_ADDR
// sLack := false ;
98505: LD_ADDR_EXP 106
98509: PUSH
98510: LD_INT 0
98512: ST_TO_ADDR
// sTank := false ;
98513: LD_ADDR_EXP 108
98517: PUSH
98518: LD_INT 0
98520: ST_TO_ADDR
// sRemote := false ;
98521: LD_ADDR_EXP 109
98525: PUSH
98526: LD_INT 0
98528: ST_TO_ADDR
// sPowell := false ;
98529: LD_ADDR_EXP 110
98533: PUSH
98534: LD_INT 0
98536: ST_TO_ADDR
// sTeleport := false ;
98537: LD_ADDR_EXP 113
98541: PUSH
98542: LD_INT 0
98544: ST_TO_ADDR
// sOilTower := false ;
98545: LD_ADDR_EXP 115
98549: PUSH
98550: LD_INT 0
98552: ST_TO_ADDR
// sShovel := false ;
98553: LD_ADDR_EXP 116
98557: PUSH
98558: LD_INT 0
98560: ST_TO_ADDR
// sSheik := false ;
98561: LD_ADDR_EXP 117
98565: PUSH
98566: LD_INT 0
98568: ST_TO_ADDR
// sEarthquake := false ;
98569: LD_ADDR_EXP 119
98573: PUSH
98574: LD_INT 0
98576: ST_TO_ADDR
// sAI := false ;
98577: LD_ADDR_EXP 120
98581: PUSH
98582: LD_INT 0
98584: ST_TO_ADDR
// sCargo := false ;
98585: LD_ADDR_EXP 123
98589: PUSH
98590: LD_INT 0
98592: ST_TO_ADDR
// sDLaser := false ;
98593: LD_ADDR_EXP 124
98597: PUSH
98598: LD_INT 0
98600: ST_TO_ADDR
// sExchange := false ;
98601: LD_ADDR_EXP 125
98605: PUSH
98606: LD_INT 0
98608: ST_TO_ADDR
// sFac := false ;
98609: LD_ADDR_EXP 126
98613: PUSH
98614: LD_INT 0
98616: ST_TO_ADDR
// sPower := false ;
98617: LD_ADDR_EXP 127
98621: PUSH
98622: LD_INT 0
98624: ST_TO_ADDR
// sRandom := false ;
98625: LD_ADDR_EXP 128
98629: PUSH
98630: LD_INT 0
98632: ST_TO_ADDR
// sShield := false ;
98633: LD_ADDR_EXP 129
98637: PUSH
98638: LD_INT 0
98640: ST_TO_ADDR
// sTime := false ;
98641: LD_ADDR_EXP 130
98645: PUSH
98646: LD_INT 0
98648: ST_TO_ADDR
// sTools := false ;
98649: LD_ADDR_EXP 131
98653: PUSH
98654: LD_INT 0
98656: ST_TO_ADDR
// sSold := false ;
98657: LD_ADDR_EXP 96
98661: PUSH
98662: LD_INT 0
98664: ST_TO_ADDR
// sDiff := false ;
98665: LD_ADDR_EXP 97
98669: PUSH
98670: LD_INT 0
98672: ST_TO_ADDR
// sFog := false ;
98673: LD_ADDR_EXP 100
98677: PUSH
98678: LD_INT 0
98680: ST_TO_ADDR
// sReset := false ;
98681: LD_ADDR_EXP 101
98685: PUSH
98686: LD_INT 0
98688: ST_TO_ADDR
// sSun := false ;
98689: LD_ADDR_EXP 102
98693: PUSH
98694: LD_INT 0
98696: ST_TO_ADDR
// sTiger := false ;
98697: LD_ADDR_EXP 98
98701: PUSH
98702: LD_INT 0
98704: ST_TO_ADDR
// sBomb := false ;
98705: LD_ADDR_EXP 99
98709: PUSH
98710: LD_INT 0
98712: ST_TO_ADDR
// sWound := false ;
98713: LD_ADDR_EXP 107
98717: PUSH
98718: LD_INT 0
98720: ST_TO_ADDR
// sBetray := false ;
98721: LD_ADDR_EXP 111
98725: PUSH
98726: LD_INT 0
98728: ST_TO_ADDR
// sContamin := false ;
98729: LD_ADDR_EXP 112
98733: PUSH
98734: LD_INT 0
98736: ST_TO_ADDR
// sOil := false ;
98737: LD_ADDR_EXP 114
98741: PUSH
98742: LD_INT 0
98744: ST_TO_ADDR
// sStu := false ;
98745: LD_ADDR_EXP 118
98749: PUSH
98750: LD_INT 0
98752: ST_TO_ADDR
// sBazooka := false ;
98753: LD_ADDR_EXP 121
98757: PUSH
98758: LD_INT 0
98760: ST_TO_ADDR
// sMortar := false ;
98761: LD_ADDR_EXP 122
98765: PUSH
98766: LD_INT 0
98768: ST_TO_ADDR
// sRanger := false ;
98769: LD_ADDR_EXP 132
98773: PUSH
98774: LD_INT 0
98776: ST_TO_ADDR
// sComputer := false ;
98777: LD_ADDR_EXP 133
98781: PUSH
98782: LD_INT 0
98784: ST_TO_ADDR
// s30 := false ;
98785: LD_ADDR_EXP 134
98789: PUSH
98790: LD_INT 0
98792: ST_TO_ADDR
// s60 := false ;
98793: LD_ADDR_EXP 135
98797: PUSH
98798: LD_INT 0
98800: ST_TO_ADDR
// end ;
98801: LD_VAR 0 1
98805: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
98806: LD_INT 0
98808: PPUSH
98809: PPUSH
98810: PPUSH
98811: PPUSH
98812: PPUSH
98813: PPUSH
98814: PPUSH
// result := [ ] ;
98815: LD_ADDR_VAR 0 2
98819: PUSH
98820: EMPTY
98821: ST_TO_ADDR
// if campaign_id = 1 then
98822: LD_OWVAR 69
98826: PUSH
98827: LD_INT 1
98829: EQUAL
98830: IFFALSE 101996
// begin case mission_number of 1 :
98832: LD_OWVAR 70
98836: PUSH
98837: LD_INT 1
98839: DOUBLE
98840: EQUAL
98841: IFTRUE 98845
98843: GO 98921
98845: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
98846: LD_ADDR_VAR 0 2
98850: PUSH
98851: LD_INT 2
98853: PUSH
98854: LD_INT 4
98856: PUSH
98857: LD_INT 11
98859: PUSH
98860: LD_INT 12
98862: PUSH
98863: LD_INT 15
98865: PUSH
98866: LD_INT 16
98868: PUSH
98869: LD_INT 22
98871: PUSH
98872: LD_INT 23
98874: PUSH
98875: LD_INT 26
98877: PUSH
98878: EMPTY
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: LIST
98884: LIST
98885: LIST
98886: LIST
98887: LIST
98888: PUSH
98889: LD_INT 101
98891: PUSH
98892: LD_INT 102
98894: PUSH
98895: LD_INT 106
98897: PUSH
98898: LD_INT 116
98900: PUSH
98901: LD_INT 117
98903: PUSH
98904: LD_INT 118
98906: PUSH
98907: EMPTY
98908: LIST
98909: LIST
98910: LIST
98911: LIST
98912: LIST
98913: LIST
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: ST_TO_ADDR
98919: GO 101994
98921: LD_INT 2
98923: DOUBLE
98924: EQUAL
98925: IFTRUE 98929
98927: GO 99013
98929: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
98930: LD_ADDR_VAR 0 2
98934: PUSH
98935: LD_INT 2
98937: PUSH
98938: LD_INT 4
98940: PUSH
98941: LD_INT 11
98943: PUSH
98944: LD_INT 12
98946: PUSH
98947: LD_INT 15
98949: PUSH
98950: LD_INT 16
98952: PUSH
98953: LD_INT 22
98955: PUSH
98956: LD_INT 23
98958: PUSH
98959: LD_INT 26
98961: PUSH
98962: EMPTY
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: PUSH
98973: LD_INT 101
98975: PUSH
98976: LD_INT 102
98978: PUSH
98979: LD_INT 105
98981: PUSH
98982: LD_INT 106
98984: PUSH
98985: LD_INT 108
98987: PUSH
98988: LD_INT 116
98990: PUSH
98991: LD_INT 117
98993: PUSH
98994: LD_INT 118
98996: PUSH
98997: EMPTY
98998: LIST
98999: LIST
99000: LIST
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: PUSH
99007: EMPTY
99008: LIST
99009: LIST
99010: ST_TO_ADDR
99011: GO 101994
99013: LD_INT 3
99015: DOUBLE
99016: EQUAL
99017: IFTRUE 99021
99019: GO 99109
99021: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
99022: LD_ADDR_VAR 0 2
99026: PUSH
99027: LD_INT 2
99029: PUSH
99030: LD_INT 4
99032: PUSH
99033: LD_INT 5
99035: PUSH
99036: LD_INT 11
99038: PUSH
99039: LD_INT 12
99041: PUSH
99042: LD_INT 15
99044: PUSH
99045: LD_INT 16
99047: PUSH
99048: LD_INT 22
99050: PUSH
99051: LD_INT 26
99053: PUSH
99054: LD_INT 36
99056: PUSH
99057: EMPTY
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: PUSH
99069: LD_INT 101
99071: PUSH
99072: LD_INT 102
99074: PUSH
99075: LD_INT 105
99077: PUSH
99078: LD_INT 106
99080: PUSH
99081: LD_INT 108
99083: PUSH
99084: LD_INT 116
99086: PUSH
99087: LD_INT 117
99089: PUSH
99090: LD_INT 118
99092: PUSH
99093: EMPTY
99094: LIST
99095: LIST
99096: LIST
99097: LIST
99098: LIST
99099: LIST
99100: LIST
99101: LIST
99102: PUSH
99103: EMPTY
99104: LIST
99105: LIST
99106: ST_TO_ADDR
99107: GO 101994
99109: LD_INT 4
99111: DOUBLE
99112: EQUAL
99113: IFTRUE 99117
99115: GO 99213
99117: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
99118: LD_ADDR_VAR 0 2
99122: PUSH
99123: LD_INT 2
99125: PUSH
99126: LD_INT 4
99128: PUSH
99129: LD_INT 5
99131: PUSH
99132: LD_INT 8
99134: PUSH
99135: LD_INT 11
99137: PUSH
99138: LD_INT 12
99140: PUSH
99141: LD_INT 15
99143: PUSH
99144: LD_INT 16
99146: PUSH
99147: LD_INT 22
99149: PUSH
99150: LD_INT 23
99152: PUSH
99153: LD_INT 26
99155: PUSH
99156: LD_INT 36
99158: PUSH
99159: EMPTY
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: PUSH
99173: LD_INT 101
99175: PUSH
99176: LD_INT 102
99178: PUSH
99179: LD_INT 105
99181: PUSH
99182: LD_INT 106
99184: PUSH
99185: LD_INT 108
99187: PUSH
99188: LD_INT 116
99190: PUSH
99191: LD_INT 117
99193: PUSH
99194: LD_INT 118
99196: PUSH
99197: EMPTY
99198: LIST
99199: LIST
99200: LIST
99201: LIST
99202: LIST
99203: LIST
99204: LIST
99205: LIST
99206: PUSH
99207: EMPTY
99208: LIST
99209: LIST
99210: ST_TO_ADDR
99211: GO 101994
99213: LD_INT 5
99215: DOUBLE
99216: EQUAL
99217: IFTRUE 99221
99219: GO 99333
99221: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
99222: LD_ADDR_VAR 0 2
99226: PUSH
99227: LD_INT 2
99229: PUSH
99230: LD_INT 4
99232: PUSH
99233: LD_INT 5
99235: PUSH
99236: LD_INT 6
99238: PUSH
99239: LD_INT 8
99241: PUSH
99242: LD_INT 11
99244: PUSH
99245: LD_INT 12
99247: PUSH
99248: LD_INT 15
99250: PUSH
99251: LD_INT 16
99253: PUSH
99254: LD_INT 22
99256: PUSH
99257: LD_INT 23
99259: PUSH
99260: LD_INT 25
99262: PUSH
99263: LD_INT 26
99265: PUSH
99266: LD_INT 36
99268: PUSH
99269: EMPTY
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: LIST
99277: LIST
99278: LIST
99279: LIST
99280: LIST
99281: LIST
99282: LIST
99283: LIST
99284: PUSH
99285: LD_INT 101
99287: PUSH
99288: LD_INT 102
99290: PUSH
99291: LD_INT 105
99293: PUSH
99294: LD_INT 106
99296: PUSH
99297: LD_INT 108
99299: PUSH
99300: LD_INT 109
99302: PUSH
99303: LD_INT 112
99305: PUSH
99306: LD_INT 116
99308: PUSH
99309: LD_INT 117
99311: PUSH
99312: LD_INT 118
99314: PUSH
99315: EMPTY
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: PUSH
99327: EMPTY
99328: LIST
99329: LIST
99330: ST_TO_ADDR
99331: GO 101994
99333: LD_INT 6
99335: DOUBLE
99336: EQUAL
99337: IFTRUE 99341
99339: GO 99473
99341: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
99342: LD_ADDR_VAR 0 2
99346: PUSH
99347: LD_INT 2
99349: PUSH
99350: LD_INT 4
99352: PUSH
99353: LD_INT 5
99355: PUSH
99356: LD_INT 6
99358: PUSH
99359: LD_INT 8
99361: PUSH
99362: LD_INT 11
99364: PUSH
99365: LD_INT 12
99367: PUSH
99368: LD_INT 15
99370: PUSH
99371: LD_INT 16
99373: PUSH
99374: LD_INT 20
99376: PUSH
99377: LD_INT 21
99379: PUSH
99380: LD_INT 22
99382: PUSH
99383: LD_INT 23
99385: PUSH
99386: LD_INT 25
99388: PUSH
99389: LD_INT 26
99391: PUSH
99392: LD_INT 30
99394: PUSH
99395: LD_INT 31
99397: PUSH
99398: LD_INT 32
99400: PUSH
99401: LD_INT 36
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: PUSH
99425: LD_INT 101
99427: PUSH
99428: LD_INT 102
99430: PUSH
99431: LD_INT 105
99433: PUSH
99434: LD_INT 106
99436: PUSH
99437: LD_INT 108
99439: PUSH
99440: LD_INT 109
99442: PUSH
99443: LD_INT 112
99445: PUSH
99446: LD_INT 116
99448: PUSH
99449: LD_INT 117
99451: PUSH
99452: LD_INT 118
99454: PUSH
99455: EMPTY
99456: LIST
99457: LIST
99458: LIST
99459: LIST
99460: LIST
99461: LIST
99462: LIST
99463: LIST
99464: LIST
99465: LIST
99466: PUSH
99467: EMPTY
99468: LIST
99469: LIST
99470: ST_TO_ADDR
99471: GO 101994
99473: LD_INT 7
99475: DOUBLE
99476: EQUAL
99477: IFTRUE 99481
99479: GO 99593
99481: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
99482: LD_ADDR_VAR 0 2
99486: PUSH
99487: LD_INT 2
99489: PUSH
99490: LD_INT 4
99492: PUSH
99493: LD_INT 5
99495: PUSH
99496: LD_INT 7
99498: PUSH
99499: LD_INT 11
99501: PUSH
99502: LD_INT 12
99504: PUSH
99505: LD_INT 15
99507: PUSH
99508: LD_INT 16
99510: PUSH
99511: LD_INT 20
99513: PUSH
99514: LD_INT 21
99516: PUSH
99517: LD_INT 22
99519: PUSH
99520: LD_INT 23
99522: PUSH
99523: LD_INT 25
99525: PUSH
99526: LD_INT 26
99528: PUSH
99529: EMPTY
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: PUSH
99545: LD_INT 101
99547: PUSH
99548: LD_INT 102
99550: PUSH
99551: LD_INT 103
99553: PUSH
99554: LD_INT 105
99556: PUSH
99557: LD_INT 106
99559: PUSH
99560: LD_INT 108
99562: PUSH
99563: LD_INT 112
99565: PUSH
99566: LD_INT 116
99568: PUSH
99569: LD_INT 117
99571: PUSH
99572: LD_INT 118
99574: PUSH
99575: EMPTY
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: LIST
99585: LIST
99586: PUSH
99587: EMPTY
99588: LIST
99589: LIST
99590: ST_TO_ADDR
99591: GO 101994
99593: LD_INT 8
99595: DOUBLE
99596: EQUAL
99597: IFTRUE 99601
99599: GO 99741
99601: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
99602: LD_ADDR_VAR 0 2
99606: PUSH
99607: LD_INT 2
99609: PUSH
99610: LD_INT 4
99612: PUSH
99613: LD_INT 5
99615: PUSH
99616: LD_INT 6
99618: PUSH
99619: LD_INT 7
99621: PUSH
99622: LD_INT 8
99624: PUSH
99625: LD_INT 11
99627: PUSH
99628: LD_INT 12
99630: PUSH
99631: LD_INT 15
99633: PUSH
99634: LD_INT 16
99636: PUSH
99637: LD_INT 20
99639: PUSH
99640: LD_INT 21
99642: PUSH
99643: LD_INT 22
99645: PUSH
99646: LD_INT 23
99648: PUSH
99649: LD_INT 25
99651: PUSH
99652: LD_INT 26
99654: PUSH
99655: LD_INT 30
99657: PUSH
99658: LD_INT 31
99660: PUSH
99661: LD_INT 32
99663: PUSH
99664: LD_INT 36
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: LIST
99677: LIST
99678: LIST
99679: LIST
99680: LIST
99681: LIST
99682: LIST
99683: LIST
99684: LIST
99685: LIST
99686: LIST
99687: LIST
99688: PUSH
99689: LD_INT 101
99691: PUSH
99692: LD_INT 102
99694: PUSH
99695: LD_INT 103
99697: PUSH
99698: LD_INT 105
99700: PUSH
99701: LD_INT 106
99703: PUSH
99704: LD_INT 108
99706: PUSH
99707: LD_INT 109
99709: PUSH
99710: LD_INT 112
99712: PUSH
99713: LD_INT 116
99715: PUSH
99716: LD_INT 117
99718: PUSH
99719: LD_INT 118
99721: PUSH
99722: EMPTY
99723: LIST
99724: LIST
99725: LIST
99726: LIST
99727: LIST
99728: LIST
99729: LIST
99730: LIST
99731: LIST
99732: LIST
99733: LIST
99734: PUSH
99735: EMPTY
99736: LIST
99737: LIST
99738: ST_TO_ADDR
99739: GO 101994
99741: LD_INT 9
99743: DOUBLE
99744: EQUAL
99745: IFTRUE 99749
99747: GO 99897
99749: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
99750: LD_ADDR_VAR 0 2
99754: PUSH
99755: LD_INT 2
99757: PUSH
99758: LD_INT 4
99760: PUSH
99761: LD_INT 5
99763: PUSH
99764: LD_INT 6
99766: PUSH
99767: LD_INT 7
99769: PUSH
99770: LD_INT 8
99772: PUSH
99773: LD_INT 11
99775: PUSH
99776: LD_INT 12
99778: PUSH
99779: LD_INT 15
99781: PUSH
99782: LD_INT 16
99784: PUSH
99785: LD_INT 20
99787: PUSH
99788: LD_INT 21
99790: PUSH
99791: LD_INT 22
99793: PUSH
99794: LD_INT 23
99796: PUSH
99797: LD_INT 25
99799: PUSH
99800: LD_INT 26
99802: PUSH
99803: LD_INT 28
99805: PUSH
99806: LD_INT 30
99808: PUSH
99809: LD_INT 31
99811: PUSH
99812: LD_INT 32
99814: PUSH
99815: LD_INT 36
99817: PUSH
99818: EMPTY
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: LIST
99824: LIST
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: LIST
99833: LIST
99834: LIST
99835: LIST
99836: LIST
99837: LIST
99838: LIST
99839: LIST
99840: PUSH
99841: LD_INT 101
99843: PUSH
99844: LD_INT 102
99846: PUSH
99847: LD_INT 103
99849: PUSH
99850: LD_INT 105
99852: PUSH
99853: LD_INT 106
99855: PUSH
99856: LD_INT 108
99858: PUSH
99859: LD_INT 109
99861: PUSH
99862: LD_INT 112
99864: PUSH
99865: LD_INT 114
99867: PUSH
99868: LD_INT 116
99870: PUSH
99871: LD_INT 117
99873: PUSH
99874: LD_INT 118
99876: PUSH
99877: EMPTY
99878: LIST
99879: LIST
99880: LIST
99881: LIST
99882: LIST
99883: LIST
99884: LIST
99885: LIST
99886: LIST
99887: LIST
99888: LIST
99889: LIST
99890: PUSH
99891: EMPTY
99892: LIST
99893: LIST
99894: ST_TO_ADDR
99895: GO 101994
99897: LD_INT 10
99899: DOUBLE
99900: EQUAL
99901: IFTRUE 99905
99903: GO 100101
99905: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
99906: LD_ADDR_VAR 0 2
99910: PUSH
99911: LD_INT 2
99913: PUSH
99914: LD_INT 4
99916: PUSH
99917: LD_INT 5
99919: PUSH
99920: LD_INT 6
99922: PUSH
99923: LD_INT 7
99925: PUSH
99926: LD_INT 8
99928: PUSH
99929: LD_INT 9
99931: PUSH
99932: LD_INT 10
99934: PUSH
99935: LD_INT 11
99937: PUSH
99938: LD_INT 12
99940: PUSH
99941: LD_INT 13
99943: PUSH
99944: LD_INT 14
99946: PUSH
99947: LD_INT 15
99949: PUSH
99950: LD_INT 16
99952: PUSH
99953: LD_INT 17
99955: PUSH
99956: LD_INT 18
99958: PUSH
99959: LD_INT 19
99961: PUSH
99962: LD_INT 20
99964: PUSH
99965: LD_INT 21
99967: PUSH
99968: LD_INT 22
99970: PUSH
99971: LD_INT 23
99973: PUSH
99974: LD_INT 24
99976: PUSH
99977: LD_INT 25
99979: PUSH
99980: LD_INT 26
99982: PUSH
99983: LD_INT 28
99985: PUSH
99986: LD_INT 30
99988: PUSH
99989: LD_INT 31
99991: PUSH
99992: LD_INT 32
99994: PUSH
99995: LD_INT 36
99997: PUSH
99998: EMPTY
99999: LIST
100000: LIST
100001: LIST
100002: LIST
100003: LIST
100004: LIST
100005: LIST
100006: LIST
100007: LIST
100008: LIST
100009: LIST
100010: LIST
100011: LIST
100012: LIST
100013: LIST
100014: LIST
100015: LIST
100016: LIST
100017: LIST
100018: LIST
100019: LIST
100020: LIST
100021: LIST
100022: LIST
100023: LIST
100024: LIST
100025: LIST
100026: LIST
100027: LIST
100028: PUSH
100029: LD_INT 101
100031: PUSH
100032: LD_INT 102
100034: PUSH
100035: LD_INT 103
100037: PUSH
100038: LD_INT 104
100040: PUSH
100041: LD_INT 105
100043: PUSH
100044: LD_INT 106
100046: PUSH
100047: LD_INT 107
100049: PUSH
100050: LD_INT 108
100052: PUSH
100053: LD_INT 109
100055: PUSH
100056: LD_INT 110
100058: PUSH
100059: LD_INT 111
100061: PUSH
100062: LD_INT 112
100064: PUSH
100065: LD_INT 114
100067: PUSH
100068: LD_INT 116
100070: PUSH
100071: LD_INT 117
100073: PUSH
100074: LD_INT 118
100076: PUSH
100077: EMPTY
100078: LIST
100079: LIST
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: LIST
100085: LIST
100086: LIST
100087: LIST
100088: LIST
100089: LIST
100090: LIST
100091: LIST
100092: LIST
100093: LIST
100094: PUSH
100095: EMPTY
100096: LIST
100097: LIST
100098: ST_TO_ADDR
100099: GO 101994
100101: LD_INT 11
100103: DOUBLE
100104: EQUAL
100105: IFTRUE 100109
100107: GO 100313
100109: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
100110: LD_ADDR_VAR 0 2
100114: PUSH
100115: LD_INT 2
100117: PUSH
100118: LD_INT 3
100120: PUSH
100121: LD_INT 4
100123: PUSH
100124: LD_INT 5
100126: PUSH
100127: LD_INT 6
100129: PUSH
100130: LD_INT 7
100132: PUSH
100133: LD_INT 8
100135: PUSH
100136: LD_INT 9
100138: PUSH
100139: LD_INT 10
100141: PUSH
100142: LD_INT 11
100144: PUSH
100145: LD_INT 12
100147: PUSH
100148: LD_INT 13
100150: PUSH
100151: LD_INT 14
100153: PUSH
100154: LD_INT 15
100156: PUSH
100157: LD_INT 16
100159: PUSH
100160: LD_INT 17
100162: PUSH
100163: LD_INT 18
100165: PUSH
100166: LD_INT 19
100168: PUSH
100169: LD_INT 20
100171: PUSH
100172: LD_INT 21
100174: PUSH
100175: LD_INT 22
100177: PUSH
100178: LD_INT 23
100180: PUSH
100181: LD_INT 24
100183: PUSH
100184: LD_INT 25
100186: PUSH
100187: LD_INT 26
100189: PUSH
100190: LD_INT 28
100192: PUSH
100193: LD_INT 30
100195: PUSH
100196: LD_INT 31
100198: PUSH
100199: LD_INT 32
100201: PUSH
100202: LD_INT 34
100204: PUSH
100205: LD_INT 36
100207: PUSH
100208: EMPTY
100209: LIST
100210: LIST
100211: LIST
100212: LIST
100213: LIST
100214: LIST
100215: LIST
100216: LIST
100217: LIST
100218: LIST
100219: LIST
100220: LIST
100221: LIST
100222: LIST
100223: LIST
100224: LIST
100225: LIST
100226: LIST
100227: LIST
100228: LIST
100229: LIST
100230: LIST
100231: LIST
100232: LIST
100233: LIST
100234: LIST
100235: LIST
100236: LIST
100237: LIST
100238: LIST
100239: LIST
100240: PUSH
100241: LD_INT 101
100243: PUSH
100244: LD_INT 102
100246: PUSH
100247: LD_INT 103
100249: PUSH
100250: LD_INT 104
100252: PUSH
100253: LD_INT 105
100255: PUSH
100256: LD_INT 106
100258: PUSH
100259: LD_INT 107
100261: PUSH
100262: LD_INT 108
100264: PUSH
100265: LD_INT 109
100267: PUSH
100268: LD_INT 110
100270: PUSH
100271: LD_INT 111
100273: PUSH
100274: LD_INT 112
100276: PUSH
100277: LD_INT 114
100279: PUSH
100280: LD_INT 116
100282: PUSH
100283: LD_INT 117
100285: PUSH
100286: LD_INT 118
100288: PUSH
100289: EMPTY
100290: LIST
100291: LIST
100292: LIST
100293: LIST
100294: LIST
100295: LIST
100296: LIST
100297: LIST
100298: LIST
100299: LIST
100300: LIST
100301: LIST
100302: LIST
100303: LIST
100304: LIST
100305: LIST
100306: PUSH
100307: EMPTY
100308: LIST
100309: LIST
100310: ST_TO_ADDR
100311: GO 101994
100313: LD_INT 12
100315: DOUBLE
100316: EQUAL
100317: IFTRUE 100321
100319: GO 100541
100321: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
100322: LD_ADDR_VAR 0 2
100326: PUSH
100327: LD_INT 1
100329: PUSH
100330: LD_INT 2
100332: PUSH
100333: LD_INT 3
100335: PUSH
100336: LD_INT 4
100338: PUSH
100339: LD_INT 5
100341: PUSH
100342: LD_INT 6
100344: PUSH
100345: LD_INT 7
100347: PUSH
100348: LD_INT 8
100350: PUSH
100351: LD_INT 9
100353: PUSH
100354: LD_INT 10
100356: PUSH
100357: LD_INT 11
100359: PUSH
100360: LD_INT 12
100362: PUSH
100363: LD_INT 13
100365: PUSH
100366: LD_INT 14
100368: PUSH
100369: LD_INT 15
100371: PUSH
100372: LD_INT 16
100374: PUSH
100375: LD_INT 17
100377: PUSH
100378: LD_INT 18
100380: PUSH
100381: LD_INT 19
100383: PUSH
100384: LD_INT 20
100386: PUSH
100387: LD_INT 21
100389: PUSH
100390: LD_INT 22
100392: PUSH
100393: LD_INT 23
100395: PUSH
100396: LD_INT 24
100398: PUSH
100399: LD_INT 25
100401: PUSH
100402: LD_INT 26
100404: PUSH
100405: LD_INT 27
100407: PUSH
100408: LD_INT 28
100410: PUSH
100411: LD_INT 30
100413: PUSH
100414: LD_INT 31
100416: PUSH
100417: LD_INT 32
100419: PUSH
100420: LD_INT 33
100422: PUSH
100423: LD_INT 34
100425: PUSH
100426: LD_INT 36
100428: PUSH
100429: EMPTY
100430: LIST
100431: LIST
100432: LIST
100433: LIST
100434: LIST
100435: LIST
100436: LIST
100437: LIST
100438: LIST
100439: LIST
100440: LIST
100441: LIST
100442: LIST
100443: LIST
100444: LIST
100445: LIST
100446: LIST
100447: LIST
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: LIST
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: LIST
100464: PUSH
100465: LD_INT 101
100467: PUSH
100468: LD_INT 102
100470: PUSH
100471: LD_INT 103
100473: PUSH
100474: LD_INT 104
100476: PUSH
100477: LD_INT 105
100479: PUSH
100480: LD_INT 106
100482: PUSH
100483: LD_INT 107
100485: PUSH
100486: LD_INT 108
100488: PUSH
100489: LD_INT 109
100491: PUSH
100492: LD_INT 110
100494: PUSH
100495: LD_INT 111
100497: PUSH
100498: LD_INT 112
100500: PUSH
100501: LD_INT 113
100503: PUSH
100504: LD_INT 114
100506: PUSH
100507: LD_INT 116
100509: PUSH
100510: LD_INT 117
100512: PUSH
100513: LD_INT 118
100515: PUSH
100516: EMPTY
100517: LIST
100518: LIST
100519: LIST
100520: LIST
100521: LIST
100522: LIST
100523: LIST
100524: LIST
100525: LIST
100526: LIST
100527: LIST
100528: LIST
100529: LIST
100530: LIST
100531: LIST
100532: LIST
100533: LIST
100534: PUSH
100535: EMPTY
100536: LIST
100537: LIST
100538: ST_TO_ADDR
100539: GO 101994
100541: LD_INT 13
100543: DOUBLE
100544: EQUAL
100545: IFTRUE 100549
100547: GO 100757
100549: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
100550: LD_ADDR_VAR 0 2
100554: PUSH
100555: LD_INT 1
100557: PUSH
100558: LD_INT 2
100560: PUSH
100561: LD_INT 3
100563: PUSH
100564: LD_INT 4
100566: PUSH
100567: LD_INT 5
100569: PUSH
100570: LD_INT 8
100572: PUSH
100573: LD_INT 9
100575: PUSH
100576: LD_INT 10
100578: PUSH
100579: LD_INT 11
100581: PUSH
100582: LD_INT 12
100584: PUSH
100585: LD_INT 14
100587: PUSH
100588: LD_INT 15
100590: PUSH
100591: LD_INT 16
100593: PUSH
100594: LD_INT 17
100596: PUSH
100597: LD_INT 18
100599: PUSH
100600: LD_INT 19
100602: PUSH
100603: LD_INT 20
100605: PUSH
100606: LD_INT 21
100608: PUSH
100609: LD_INT 22
100611: PUSH
100612: LD_INT 23
100614: PUSH
100615: LD_INT 24
100617: PUSH
100618: LD_INT 25
100620: PUSH
100621: LD_INT 26
100623: PUSH
100624: LD_INT 27
100626: PUSH
100627: LD_INT 28
100629: PUSH
100630: LD_INT 30
100632: PUSH
100633: LD_INT 31
100635: PUSH
100636: LD_INT 32
100638: PUSH
100639: LD_INT 33
100641: PUSH
100642: LD_INT 34
100644: PUSH
100645: LD_INT 36
100647: PUSH
100648: EMPTY
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: LIST
100661: LIST
100662: LIST
100663: LIST
100664: LIST
100665: LIST
100666: LIST
100667: LIST
100668: LIST
100669: LIST
100670: LIST
100671: LIST
100672: LIST
100673: LIST
100674: LIST
100675: LIST
100676: LIST
100677: LIST
100678: LIST
100679: LIST
100680: PUSH
100681: LD_INT 101
100683: PUSH
100684: LD_INT 102
100686: PUSH
100687: LD_INT 103
100689: PUSH
100690: LD_INT 104
100692: PUSH
100693: LD_INT 105
100695: PUSH
100696: LD_INT 106
100698: PUSH
100699: LD_INT 107
100701: PUSH
100702: LD_INT 108
100704: PUSH
100705: LD_INT 109
100707: PUSH
100708: LD_INT 110
100710: PUSH
100711: LD_INT 111
100713: PUSH
100714: LD_INT 112
100716: PUSH
100717: LD_INT 113
100719: PUSH
100720: LD_INT 114
100722: PUSH
100723: LD_INT 116
100725: PUSH
100726: LD_INT 117
100728: PUSH
100729: LD_INT 118
100731: PUSH
100732: EMPTY
100733: LIST
100734: LIST
100735: LIST
100736: LIST
100737: LIST
100738: LIST
100739: LIST
100740: LIST
100741: LIST
100742: LIST
100743: LIST
100744: LIST
100745: LIST
100746: LIST
100747: LIST
100748: LIST
100749: LIST
100750: PUSH
100751: EMPTY
100752: LIST
100753: LIST
100754: ST_TO_ADDR
100755: GO 101994
100757: LD_INT 14
100759: DOUBLE
100760: EQUAL
100761: IFTRUE 100765
100763: GO 100989
100765: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
100766: LD_ADDR_VAR 0 2
100770: PUSH
100771: LD_INT 1
100773: PUSH
100774: LD_INT 2
100776: PUSH
100777: LD_INT 3
100779: PUSH
100780: LD_INT 4
100782: PUSH
100783: LD_INT 5
100785: PUSH
100786: LD_INT 6
100788: PUSH
100789: LD_INT 7
100791: PUSH
100792: LD_INT 8
100794: PUSH
100795: LD_INT 9
100797: PUSH
100798: LD_INT 10
100800: PUSH
100801: LD_INT 11
100803: PUSH
100804: LD_INT 12
100806: PUSH
100807: LD_INT 13
100809: PUSH
100810: LD_INT 14
100812: PUSH
100813: LD_INT 15
100815: PUSH
100816: LD_INT 16
100818: PUSH
100819: LD_INT 17
100821: PUSH
100822: LD_INT 18
100824: PUSH
100825: LD_INT 19
100827: PUSH
100828: LD_INT 20
100830: PUSH
100831: LD_INT 21
100833: PUSH
100834: LD_INT 22
100836: PUSH
100837: LD_INT 23
100839: PUSH
100840: LD_INT 24
100842: PUSH
100843: LD_INT 25
100845: PUSH
100846: LD_INT 26
100848: PUSH
100849: LD_INT 27
100851: PUSH
100852: LD_INT 28
100854: PUSH
100855: LD_INT 29
100857: PUSH
100858: LD_INT 30
100860: PUSH
100861: LD_INT 31
100863: PUSH
100864: LD_INT 32
100866: PUSH
100867: LD_INT 33
100869: PUSH
100870: LD_INT 34
100872: PUSH
100873: LD_INT 36
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: LIST
100880: LIST
100881: LIST
100882: LIST
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: LIST
100888: LIST
100889: LIST
100890: LIST
100891: LIST
100892: LIST
100893: LIST
100894: LIST
100895: LIST
100896: LIST
100897: LIST
100898: LIST
100899: LIST
100900: LIST
100901: LIST
100902: LIST
100903: LIST
100904: LIST
100905: LIST
100906: LIST
100907: LIST
100908: LIST
100909: LIST
100910: LIST
100911: LIST
100912: PUSH
100913: LD_INT 101
100915: PUSH
100916: LD_INT 102
100918: PUSH
100919: LD_INT 103
100921: PUSH
100922: LD_INT 104
100924: PUSH
100925: LD_INT 105
100927: PUSH
100928: LD_INT 106
100930: PUSH
100931: LD_INT 107
100933: PUSH
100934: LD_INT 108
100936: PUSH
100937: LD_INT 109
100939: PUSH
100940: LD_INT 110
100942: PUSH
100943: LD_INT 111
100945: PUSH
100946: LD_INT 112
100948: PUSH
100949: LD_INT 113
100951: PUSH
100952: LD_INT 114
100954: PUSH
100955: LD_INT 116
100957: PUSH
100958: LD_INT 117
100960: PUSH
100961: LD_INT 118
100963: PUSH
100964: EMPTY
100965: LIST
100966: LIST
100967: LIST
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: LIST
100973: LIST
100974: LIST
100975: LIST
100976: LIST
100977: LIST
100978: LIST
100979: LIST
100980: LIST
100981: LIST
100982: PUSH
100983: EMPTY
100984: LIST
100985: LIST
100986: ST_TO_ADDR
100987: GO 101994
100989: LD_INT 15
100991: DOUBLE
100992: EQUAL
100993: IFTRUE 100997
100995: GO 101221
100997: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
100998: LD_ADDR_VAR 0 2
101002: PUSH
101003: LD_INT 1
101005: PUSH
101006: LD_INT 2
101008: PUSH
101009: LD_INT 3
101011: PUSH
101012: LD_INT 4
101014: PUSH
101015: LD_INT 5
101017: PUSH
101018: LD_INT 6
101020: PUSH
101021: LD_INT 7
101023: PUSH
101024: LD_INT 8
101026: PUSH
101027: LD_INT 9
101029: PUSH
101030: LD_INT 10
101032: PUSH
101033: LD_INT 11
101035: PUSH
101036: LD_INT 12
101038: PUSH
101039: LD_INT 13
101041: PUSH
101042: LD_INT 14
101044: PUSH
101045: LD_INT 15
101047: PUSH
101048: LD_INT 16
101050: PUSH
101051: LD_INT 17
101053: PUSH
101054: LD_INT 18
101056: PUSH
101057: LD_INT 19
101059: PUSH
101060: LD_INT 20
101062: PUSH
101063: LD_INT 21
101065: PUSH
101066: LD_INT 22
101068: PUSH
101069: LD_INT 23
101071: PUSH
101072: LD_INT 24
101074: PUSH
101075: LD_INT 25
101077: PUSH
101078: LD_INT 26
101080: PUSH
101081: LD_INT 27
101083: PUSH
101084: LD_INT 28
101086: PUSH
101087: LD_INT 29
101089: PUSH
101090: LD_INT 30
101092: PUSH
101093: LD_INT 31
101095: PUSH
101096: LD_INT 32
101098: PUSH
101099: LD_INT 33
101101: PUSH
101102: LD_INT 34
101104: PUSH
101105: LD_INT 36
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: LIST
101112: LIST
101113: LIST
101114: LIST
101115: LIST
101116: LIST
101117: LIST
101118: LIST
101119: LIST
101120: LIST
101121: LIST
101122: LIST
101123: LIST
101124: LIST
101125: LIST
101126: LIST
101127: LIST
101128: LIST
101129: LIST
101130: LIST
101131: LIST
101132: LIST
101133: LIST
101134: LIST
101135: LIST
101136: LIST
101137: LIST
101138: LIST
101139: LIST
101140: LIST
101141: LIST
101142: LIST
101143: LIST
101144: PUSH
101145: LD_INT 101
101147: PUSH
101148: LD_INT 102
101150: PUSH
101151: LD_INT 103
101153: PUSH
101154: LD_INT 104
101156: PUSH
101157: LD_INT 105
101159: PUSH
101160: LD_INT 106
101162: PUSH
101163: LD_INT 107
101165: PUSH
101166: LD_INT 108
101168: PUSH
101169: LD_INT 109
101171: PUSH
101172: LD_INT 110
101174: PUSH
101175: LD_INT 111
101177: PUSH
101178: LD_INT 112
101180: PUSH
101181: LD_INT 113
101183: PUSH
101184: LD_INT 114
101186: PUSH
101187: LD_INT 116
101189: PUSH
101190: LD_INT 117
101192: PUSH
101193: LD_INT 118
101195: PUSH
101196: EMPTY
101197: LIST
101198: LIST
101199: LIST
101200: LIST
101201: LIST
101202: LIST
101203: LIST
101204: LIST
101205: LIST
101206: LIST
101207: LIST
101208: LIST
101209: LIST
101210: LIST
101211: LIST
101212: LIST
101213: LIST
101214: PUSH
101215: EMPTY
101216: LIST
101217: LIST
101218: ST_TO_ADDR
101219: GO 101994
101221: LD_INT 16
101223: DOUBLE
101224: EQUAL
101225: IFTRUE 101229
101227: GO 101365
101229: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
101230: LD_ADDR_VAR 0 2
101234: PUSH
101235: LD_INT 2
101237: PUSH
101238: LD_INT 4
101240: PUSH
101241: LD_INT 5
101243: PUSH
101244: LD_INT 7
101246: PUSH
101247: LD_INT 11
101249: PUSH
101250: LD_INT 12
101252: PUSH
101253: LD_INT 15
101255: PUSH
101256: LD_INT 16
101258: PUSH
101259: LD_INT 20
101261: PUSH
101262: LD_INT 21
101264: PUSH
101265: LD_INT 22
101267: PUSH
101268: LD_INT 23
101270: PUSH
101271: LD_INT 25
101273: PUSH
101274: LD_INT 26
101276: PUSH
101277: LD_INT 30
101279: PUSH
101280: LD_INT 31
101282: PUSH
101283: LD_INT 32
101285: PUSH
101286: LD_INT 33
101288: PUSH
101289: LD_INT 34
101291: PUSH
101292: EMPTY
101293: LIST
101294: LIST
101295: LIST
101296: LIST
101297: LIST
101298: LIST
101299: LIST
101300: LIST
101301: LIST
101302: LIST
101303: LIST
101304: LIST
101305: LIST
101306: LIST
101307: LIST
101308: LIST
101309: LIST
101310: LIST
101311: LIST
101312: PUSH
101313: LD_INT 101
101315: PUSH
101316: LD_INT 102
101318: PUSH
101319: LD_INT 103
101321: PUSH
101322: LD_INT 106
101324: PUSH
101325: LD_INT 108
101327: PUSH
101328: LD_INT 112
101330: PUSH
101331: LD_INT 113
101333: PUSH
101334: LD_INT 114
101336: PUSH
101337: LD_INT 116
101339: PUSH
101340: LD_INT 117
101342: PUSH
101343: LD_INT 118
101345: PUSH
101346: EMPTY
101347: LIST
101348: LIST
101349: LIST
101350: LIST
101351: LIST
101352: LIST
101353: LIST
101354: LIST
101355: LIST
101356: LIST
101357: LIST
101358: PUSH
101359: EMPTY
101360: LIST
101361: LIST
101362: ST_TO_ADDR
101363: GO 101994
101365: LD_INT 17
101367: DOUBLE
101368: EQUAL
101369: IFTRUE 101373
101371: GO 101597
101373: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
101374: LD_ADDR_VAR 0 2
101378: PUSH
101379: LD_INT 1
101381: PUSH
101382: LD_INT 2
101384: PUSH
101385: LD_INT 3
101387: PUSH
101388: LD_INT 4
101390: PUSH
101391: LD_INT 5
101393: PUSH
101394: LD_INT 6
101396: PUSH
101397: LD_INT 7
101399: PUSH
101400: LD_INT 8
101402: PUSH
101403: LD_INT 9
101405: PUSH
101406: LD_INT 10
101408: PUSH
101409: LD_INT 11
101411: PUSH
101412: LD_INT 12
101414: PUSH
101415: LD_INT 13
101417: PUSH
101418: LD_INT 14
101420: PUSH
101421: LD_INT 15
101423: PUSH
101424: LD_INT 16
101426: PUSH
101427: LD_INT 17
101429: PUSH
101430: LD_INT 18
101432: PUSH
101433: LD_INT 19
101435: PUSH
101436: LD_INT 20
101438: PUSH
101439: LD_INT 21
101441: PUSH
101442: LD_INT 22
101444: PUSH
101445: LD_INT 23
101447: PUSH
101448: LD_INT 24
101450: PUSH
101451: LD_INT 25
101453: PUSH
101454: LD_INT 26
101456: PUSH
101457: LD_INT 27
101459: PUSH
101460: LD_INT 28
101462: PUSH
101463: LD_INT 29
101465: PUSH
101466: LD_INT 30
101468: PUSH
101469: LD_INT 31
101471: PUSH
101472: LD_INT 32
101474: PUSH
101475: LD_INT 33
101477: PUSH
101478: LD_INT 34
101480: PUSH
101481: LD_INT 36
101483: PUSH
101484: EMPTY
101485: LIST
101486: LIST
101487: LIST
101488: LIST
101489: LIST
101490: LIST
101491: LIST
101492: LIST
101493: LIST
101494: LIST
101495: LIST
101496: LIST
101497: LIST
101498: LIST
101499: LIST
101500: LIST
101501: LIST
101502: LIST
101503: LIST
101504: LIST
101505: LIST
101506: LIST
101507: LIST
101508: LIST
101509: LIST
101510: LIST
101511: LIST
101512: LIST
101513: LIST
101514: LIST
101515: LIST
101516: LIST
101517: LIST
101518: LIST
101519: LIST
101520: PUSH
101521: LD_INT 101
101523: PUSH
101524: LD_INT 102
101526: PUSH
101527: LD_INT 103
101529: PUSH
101530: LD_INT 104
101532: PUSH
101533: LD_INT 105
101535: PUSH
101536: LD_INT 106
101538: PUSH
101539: LD_INT 107
101541: PUSH
101542: LD_INT 108
101544: PUSH
101545: LD_INT 109
101547: PUSH
101548: LD_INT 110
101550: PUSH
101551: LD_INT 111
101553: PUSH
101554: LD_INT 112
101556: PUSH
101557: LD_INT 113
101559: PUSH
101560: LD_INT 114
101562: PUSH
101563: LD_INT 116
101565: PUSH
101566: LD_INT 117
101568: PUSH
101569: LD_INT 118
101571: PUSH
101572: EMPTY
101573: LIST
101574: LIST
101575: LIST
101576: LIST
101577: LIST
101578: LIST
101579: LIST
101580: LIST
101581: LIST
101582: LIST
101583: LIST
101584: LIST
101585: LIST
101586: LIST
101587: LIST
101588: LIST
101589: LIST
101590: PUSH
101591: EMPTY
101592: LIST
101593: LIST
101594: ST_TO_ADDR
101595: GO 101994
101597: LD_INT 18
101599: DOUBLE
101600: EQUAL
101601: IFTRUE 101605
101603: GO 101753
101605: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
101606: LD_ADDR_VAR 0 2
101610: PUSH
101611: LD_INT 2
101613: PUSH
101614: LD_INT 4
101616: PUSH
101617: LD_INT 5
101619: PUSH
101620: LD_INT 7
101622: PUSH
101623: LD_INT 11
101625: PUSH
101626: LD_INT 12
101628: PUSH
101629: LD_INT 15
101631: PUSH
101632: LD_INT 16
101634: PUSH
101635: LD_INT 20
101637: PUSH
101638: LD_INT 21
101640: PUSH
101641: LD_INT 22
101643: PUSH
101644: LD_INT 23
101646: PUSH
101647: LD_INT 25
101649: PUSH
101650: LD_INT 26
101652: PUSH
101653: LD_INT 30
101655: PUSH
101656: LD_INT 31
101658: PUSH
101659: LD_INT 32
101661: PUSH
101662: LD_INT 33
101664: PUSH
101665: LD_INT 34
101667: PUSH
101668: LD_INT 35
101670: PUSH
101671: LD_INT 36
101673: PUSH
101674: EMPTY
101675: LIST
101676: LIST
101677: LIST
101678: LIST
101679: LIST
101680: LIST
101681: LIST
101682: LIST
101683: LIST
101684: LIST
101685: LIST
101686: LIST
101687: LIST
101688: LIST
101689: LIST
101690: LIST
101691: LIST
101692: LIST
101693: LIST
101694: LIST
101695: LIST
101696: PUSH
101697: LD_INT 101
101699: PUSH
101700: LD_INT 102
101702: PUSH
101703: LD_INT 103
101705: PUSH
101706: LD_INT 106
101708: PUSH
101709: LD_INT 108
101711: PUSH
101712: LD_INT 112
101714: PUSH
101715: LD_INT 113
101717: PUSH
101718: LD_INT 114
101720: PUSH
101721: LD_INT 115
101723: PUSH
101724: LD_INT 116
101726: PUSH
101727: LD_INT 117
101729: PUSH
101730: LD_INT 118
101732: PUSH
101733: EMPTY
101734: LIST
101735: LIST
101736: LIST
101737: LIST
101738: LIST
101739: LIST
101740: LIST
101741: LIST
101742: LIST
101743: LIST
101744: LIST
101745: LIST
101746: PUSH
101747: EMPTY
101748: LIST
101749: LIST
101750: ST_TO_ADDR
101751: GO 101994
101753: LD_INT 19
101755: DOUBLE
101756: EQUAL
101757: IFTRUE 101761
101759: GO 101993
101761: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
101762: LD_ADDR_VAR 0 2
101766: PUSH
101767: LD_INT 1
101769: PUSH
101770: LD_INT 2
101772: PUSH
101773: LD_INT 3
101775: PUSH
101776: LD_INT 4
101778: PUSH
101779: LD_INT 5
101781: PUSH
101782: LD_INT 6
101784: PUSH
101785: LD_INT 7
101787: PUSH
101788: LD_INT 8
101790: PUSH
101791: LD_INT 9
101793: PUSH
101794: LD_INT 10
101796: PUSH
101797: LD_INT 11
101799: PUSH
101800: LD_INT 12
101802: PUSH
101803: LD_INT 13
101805: PUSH
101806: LD_INT 14
101808: PUSH
101809: LD_INT 15
101811: PUSH
101812: LD_INT 16
101814: PUSH
101815: LD_INT 17
101817: PUSH
101818: LD_INT 18
101820: PUSH
101821: LD_INT 19
101823: PUSH
101824: LD_INT 20
101826: PUSH
101827: LD_INT 21
101829: PUSH
101830: LD_INT 22
101832: PUSH
101833: LD_INT 23
101835: PUSH
101836: LD_INT 24
101838: PUSH
101839: LD_INT 25
101841: PUSH
101842: LD_INT 26
101844: PUSH
101845: LD_INT 27
101847: PUSH
101848: LD_INT 28
101850: PUSH
101851: LD_INT 29
101853: PUSH
101854: LD_INT 30
101856: PUSH
101857: LD_INT 31
101859: PUSH
101860: LD_INT 32
101862: PUSH
101863: LD_INT 33
101865: PUSH
101866: LD_INT 34
101868: PUSH
101869: LD_INT 35
101871: PUSH
101872: LD_INT 36
101874: PUSH
101875: EMPTY
101876: LIST
101877: LIST
101878: LIST
101879: LIST
101880: LIST
101881: LIST
101882: LIST
101883: LIST
101884: LIST
101885: LIST
101886: LIST
101887: LIST
101888: LIST
101889: LIST
101890: LIST
101891: LIST
101892: LIST
101893: LIST
101894: LIST
101895: LIST
101896: LIST
101897: LIST
101898: LIST
101899: LIST
101900: LIST
101901: LIST
101902: LIST
101903: LIST
101904: LIST
101905: LIST
101906: LIST
101907: LIST
101908: LIST
101909: LIST
101910: LIST
101911: LIST
101912: PUSH
101913: LD_INT 101
101915: PUSH
101916: LD_INT 102
101918: PUSH
101919: LD_INT 103
101921: PUSH
101922: LD_INT 104
101924: PUSH
101925: LD_INT 105
101927: PUSH
101928: LD_INT 106
101930: PUSH
101931: LD_INT 107
101933: PUSH
101934: LD_INT 108
101936: PUSH
101937: LD_INT 109
101939: PUSH
101940: LD_INT 110
101942: PUSH
101943: LD_INT 111
101945: PUSH
101946: LD_INT 112
101948: PUSH
101949: LD_INT 113
101951: PUSH
101952: LD_INT 114
101954: PUSH
101955: LD_INT 115
101957: PUSH
101958: LD_INT 116
101960: PUSH
101961: LD_INT 117
101963: PUSH
101964: LD_INT 118
101966: PUSH
101967: EMPTY
101968: LIST
101969: LIST
101970: LIST
101971: LIST
101972: LIST
101973: LIST
101974: LIST
101975: LIST
101976: LIST
101977: LIST
101978: LIST
101979: LIST
101980: LIST
101981: LIST
101982: LIST
101983: LIST
101984: LIST
101985: LIST
101986: PUSH
101987: EMPTY
101988: LIST
101989: LIST
101990: ST_TO_ADDR
101991: GO 101994
101993: POP
// end else
101994: GO 102225
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
101996: LD_ADDR_VAR 0 2
102000: PUSH
102001: LD_INT 1
102003: PUSH
102004: LD_INT 2
102006: PUSH
102007: LD_INT 3
102009: PUSH
102010: LD_INT 4
102012: PUSH
102013: LD_INT 5
102015: PUSH
102016: LD_INT 6
102018: PUSH
102019: LD_INT 7
102021: PUSH
102022: LD_INT 8
102024: PUSH
102025: LD_INT 9
102027: PUSH
102028: LD_INT 10
102030: PUSH
102031: LD_INT 11
102033: PUSH
102034: LD_INT 12
102036: PUSH
102037: LD_INT 13
102039: PUSH
102040: LD_INT 14
102042: PUSH
102043: LD_INT 15
102045: PUSH
102046: LD_INT 16
102048: PUSH
102049: LD_INT 17
102051: PUSH
102052: LD_INT 18
102054: PUSH
102055: LD_INT 19
102057: PUSH
102058: LD_INT 20
102060: PUSH
102061: LD_INT 21
102063: PUSH
102064: LD_INT 22
102066: PUSH
102067: LD_INT 23
102069: PUSH
102070: LD_INT 24
102072: PUSH
102073: LD_INT 25
102075: PUSH
102076: LD_INT 26
102078: PUSH
102079: LD_INT 27
102081: PUSH
102082: LD_INT 28
102084: PUSH
102085: LD_INT 29
102087: PUSH
102088: LD_INT 30
102090: PUSH
102091: LD_INT 31
102093: PUSH
102094: LD_INT 32
102096: PUSH
102097: LD_INT 33
102099: PUSH
102100: LD_INT 34
102102: PUSH
102103: LD_INT 35
102105: PUSH
102106: LD_INT 36
102108: PUSH
102109: EMPTY
102110: LIST
102111: LIST
102112: LIST
102113: LIST
102114: LIST
102115: LIST
102116: LIST
102117: LIST
102118: LIST
102119: LIST
102120: LIST
102121: LIST
102122: LIST
102123: LIST
102124: LIST
102125: LIST
102126: LIST
102127: LIST
102128: LIST
102129: LIST
102130: LIST
102131: LIST
102132: LIST
102133: LIST
102134: LIST
102135: LIST
102136: LIST
102137: LIST
102138: LIST
102139: LIST
102140: LIST
102141: LIST
102142: LIST
102143: LIST
102144: LIST
102145: LIST
102146: PUSH
102147: LD_INT 101
102149: PUSH
102150: LD_INT 102
102152: PUSH
102153: LD_INT 103
102155: PUSH
102156: LD_INT 104
102158: PUSH
102159: LD_INT 105
102161: PUSH
102162: LD_INT 106
102164: PUSH
102165: LD_INT 107
102167: PUSH
102168: LD_INT 108
102170: PUSH
102171: LD_INT 109
102173: PUSH
102174: LD_INT 110
102176: PUSH
102177: LD_INT 111
102179: PUSH
102180: LD_INT 112
102182: PUSH
102183: LD_INT 113
102185: PUSH
102186: LD_INT 114
102188: PUSH
102189: LD_INT 115
102191: PUSH
102192: LD_INT 116
102194: PUSH
102195: LD_INT 117
102197: PUSH
102198: LD_INT 118
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: LIST
102205: LIST
102206: LIST
102207: LIST
102208: LIST
102209: LIST
102210: LIST
102211: LIST
102212: LIST
102213: LIST
102214: LIST
102215: LIST
102216: LIST
102217: LIST
102218: LIST
102219: LIST
102220: PUSH
102221: EMPTY
102222: LIST
102223: LIST
102224: ST_TO_ADDR
// if result then
102225: LD_VAR 0 2
102229: IFFALSE 103015
// begin normal :=  ;
102231: LD_ADDR_VAR 0 5
102235: PUSH
102236: LD_STRING 
102238: ST_TO_ADDR
// hardcore :=  ;
102239: LD_ADDR_VAR 0 6
102243: PUSH
102244: LD_STRING 
102246: ST_TO_ADDR
// active :=  ;
102247: LD_ADDR_VAR 0 7
102251: PUSH
102252: LD_STRING 
102254: ST_TO_ADDR
// for i = 1 to normalCounter do
102255: LD_ADDR_VAR 0 8
102259: PUSH
102260: DOUBLE
102261: LD_INT 1
102263: DEC
102264: ST_TO_ADDR
102265: LD_EXP 80
102269: PUSH
102270: FOR_TO
102271: IFFALSE 102372
// begin tmp := 0 ;
102273: LD_ADDR_VAR 0 3
102277: PUSH
102278: LD_STRING 0
102280: ST_TO_ADDR
// if result [ 1 ] then
102281: LD_VAR 0 2
102285: PUSH
102286: LD_INT 1
102288: ARRAY
102289: IFFALSE 102354
// if result [ 1 ] [ 1 ] = i then
102291: LD_VAR 0 2
102295: PUSH
102296: LD_INT 1
102298: ARRAY
102299: PUSH
102300: LD_INT 1
102302: ARRAY
102303: PUSH
102304: LD_VAR 0 8
102308: EQUAL
102309: IFFALSE 102354
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
102311: LD_ADDR_VAR 0 2
102315: PUSH
102316: LD_VAR 0 2
102320: PPUSH
102321: LD_INT 1
102323: PPUSH
102324: LD_VAR 0 2
102328: PUSH
102329: LD_INT 1
102331: ARRAY
102332: PPUSH
102333: LD_INT 1
102335: PPUSH
102336: CALL_OW 3
102340: PPUSH
102341: CALL_OW 1
102345: ST_TO_ADDR
// tmp := 1 ;
102346: LD_ADDR_VAR 0 3
102350: PUSH
102351: LD_STRING 1
102353: ST_TO_ADDR
// end ; normal := normal & tmp ;
102354: LD_ADDR_VAR 0 5
102358: PUSH
102359: LD_VAR 0 5
102363: PUSH
102364: LD_VAR 0 3
102368: STR
102369: ST_TO_ADDR
// end ;
102370: GO 102270
102372: POP
102373: POP
// for i = 1 to hardcoreCounter do
102374: LD_ADDR_VAR 0 8
102378: PUSH
102379: DOUBLE
102380: LD_INT 1
102382: DEC
102383: ST_TO_ADDR
102384: LD_EXP 81
102388: PUSH
102389: FOR_TO
102390: IFFALSE 102495
// begin tmp := 0 ;
102392: LD_ADDR_VAR 0 3
102396: PUSH
102397: LD_STRING 0
102399: ST_TO_ADDR
// if result [ 2 ] then
102400: LD_VAR 0 2
102404: PUSH
102405: LD_INT 2
102407: ARRAY
102408: IFFALSE 102477
// if result [ 2 ] [ 1 ] = 100 + i then
102410: LD_VAR 0 2
102414: PUSH
102415: LD_INT 2
102417: ARRAY
102418: PUSH
102419: LD_INT 1
102421: ARRAY
102422: PUSH
102423: LD_INT 100
102425: PUSH
102426: LD_VAR 0 8
102430: PLUS
102431: EQUAL
102432: IFFALSE 102477
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
102434: LD_ADDR_VAR 0 2
102438: PUSH
102439: LD_VAR 0 2
102443: PPUSH
102444: LD_INT 2
102446: PPUSH
102447: LD_VAR 0 2
102451: PUSH
102452: LD_INT 2
102454: ARRAY
102455: PPUSH
102456: LD_INT 1
102458: PPUSH
102459: CALL_OW 3
102463: PPUSH
102464: CALL_OW 1
102468: ST_TO_ADDR
// tmp := 1 ;
102469: LD_ADDR_VAR 0 3
102473: PUSH
102474: LD_STRING 1
102476: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
102477: LD_ADDR_VAR 0 6
102481: PUSH
102482: LD_VAR 0 6
102486: PUSH
102487: LD_VAR 0 3
102491: STR
102492: ST_TO_ADDR
// end ;
102493: GO 102389
102495: POP
102496: POP
// if isGameLoad then
102497: LD_VAR 0 1
102501: IFFALSE 102976
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
102503: LD_ADDR_VAR 0 4
102507: PUSH
102508: LD_EXP 84
102512: PUSH
102513: LD_EXP 83
102517: PUSH
102518: LD_EXP 85
102522: PUSH
102523: LD_EXP 82
102527: PUSH
102528: LD_EXP 86
102532: PUSH
102533: LD_EXP 87
102537: PUSH
102538: LD_EXP 88
102542: PUSH
102543: LD_EXP 89
102547: PUSH
102548: LD_EXP 90
102552: PUSH
102553: LD_EXP 91
102557: PUSH
102558: LD_EXP 92
102562: PUSH
102563: LD_EXP 93
102567: PUSH
102568: LD_EXP 94
102572: PUSH
102573: LD_EXP 95
102577: PUSH
102578: LD_EXP 103
102582: PUSH
102583: LD_EXP 104
102587: PUSH
102588: LD_EXP 105
102592: PUSH
102593: LD_EXP 106
102597: PUSH
102598: LD_EXP 108
102602: PUSH
102603: LD_EXP 109
102607: PUSH
102608: LD_EXP 110
102612: PUSH
102613: LD_EXP 113
102617: PUSH
102618: LD_EXP 115
102622: PUSH
102623: LD_EXP 116
102627: PUSH
102628: LD_EXP 117
102632: PUSH
102633: LD_EXP 119
102637: PUSH
102638: LD_EXP 120
102642: PUSH
102643: LD_EXP 123
102647: PUSH
102648: LD_EXP 124
102652: PUSH
102653: LD_EXP 125
102657: PUSH
102658: LD_EXP 126
102662: PUSH
102663: LD_EXP 127
102667: PUSH
102668: LD_EXP 128
102672: PUSH
102673: LD_EXP 129
102677: PUSH
102678: LD_EXP 130
102682: PUSH
102683: LD_EXP 131
102687: PUSH
102688: LD_EXP 96
102692: PUSH
102693: LD_EXP 97
102697: PUSH
102698: LD_EXP 100
102702: PUSH
102703: LD_EXP 101
102707: PUSH
102708: LD_EXP 102
102712: PUSH
102713: LD_EXP 98
102717: PUSH
102718: LD_EXP 99
102722: PUSH
102723: LD_EXP 107
102727: PUSH
102728: LD_EXP 111
102732: PUSH
102733: LD_EXP 112
102737: PUSH
102738: LD_EXP 114
102742: PUSH
102743: LD_EXP 118
102747: PUSH
102748: LD_EXP 121
102752: PUSH
102753: LD_EXP 122
102757: PUSH
102758: LD_EXP 132
102762: PUSH
102763: LD_EXP 133
102767: PUSH
102768: LD_EXP 134
102772: PUSH
102773: LD_EXP 135
102777: PUSH
102778: EMPTY
102779: LIST
102780: LIST
102781: LIST
102782: LIST
102783: LIST
102784: LIST
102785: LIST
102786: LIST
102787: LIST
102788: LIST
102789: LIST
102790: LIST
102791: LIST
102792: LIST
102793: LIST
102794: LIST
102795: LIST
102796: LIST
102797: LIST
102798: LIST
102799: LIST
102800: LIST
102801: LIST
102802: LIST
102803: LIST
102804: LIST
102805: LIST
102806: LIST
102807: LIST
102808: LIST
102809: LIST
102810: LIST
102811: LIST
102812: LIST
102813: LIST
102814: LIST
102815: LIST
102816: LIST
102817: LIST
102818: LIST
102819: LIST
102820: LIST
102821: LIST
102822: LIST
102823: LIST
102824: LIST
102825: LIST
102826: LIST
102827: LIST
102828: LIST
102829: LIST
102830: LIST
102831: LIST
102832: LIST
102833: ST_TO_ADDR
// tmp :=  ;
102834: LD_ADDR_VAR 0 3
102838: PUSH
102839: LD_STRING 
102841: ST_TO_ADDR
// for i = 1 to normalCounter do
102842: LD_ADDR_VAR 0 8
102846: PUSH
102847: DOUBLE
102848: LD_INT 1
102850: DEC
102851: ST_TO_ADDR
102852: LD_EXP 80
102856: PUSH
102857: FOR_TO
102858: IFFALSE 102894
// begin if flags [ i ] then
102860: LD_VAR 0 4
102864: PUSH
102865: LD_VAR 0 8
102869: ARRAY
102870: IFFALSE 102892
// tmp := tmp & i & ; ;
102872: LD_ADDR_VAR 0 3
102876: PUSH
102877: LD_VAR 0 3
102881: PUSH
102882: LD_VAR 0 8
102886: STR
102887: PUSH
102888: LD_STRING ;
102890: STR
102891: ST_TO_ADDR
// end ;
102892: GO 102857
102894: POP
102895: POP
// for i = 1 to hardcoreCounter do
102896: LD_ADDR_VAR 0 8
102900: PUSH
102901: DOUBLE
102902: LD_INT 1
102904: DEC
102905: ST_TO_ADDR
102906: LD_EXP 81
102910: PUSH
102911: FOR_TO
102912: IFFALSE 102958
// begin if flags [ normalCounter + i ] then
102914: LD_VAR 0 4
102918: PUSH
102919: LD_EXP 80
102923: PUSH
102924: LD_VAR 0 8
102928: PLUS
102929: ARRAY
102930: IFFALSE 102956
// tmp := tmp & ( 100 + i ) & ; ;
102932: LD_ADDR_VAR 0 3
102936: PUSH
102937: LD_VAR 0 3
102941: PUSH
102942: LD_INT 100
102944: PUSH
102945: LD_VAR 0 8
102949: PLUS
102950: STR
102951: PUSH
102952: LD_STRING ;
102954: STR
102955: ST_TO_ADDR
// end ;
102956: GO 102911
102958: POP
102959: POP
// if tmp then
102960: LD_VAR 0 3
102964: IFFALSE 102976
// active := tmp ;
102966: LD_ADDR_VAR 0 7
102970: PUSH
102971: LD_VAR 0 3
102975: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
102976: LD_STRING getStreamItemsFromMission("
102978: PUSH
102979: LD_VAR 0 5
102983: STR
102984: PUSH
102985: LD_STRING ","
102987: STR
102988: PUSH
102989: LD_VAR 0 6
102993: STR
102994: PUSH
102995: LD_STRING ","
102997: STR
102998: PUSH
102999: LD_VAR 0 7
103003: STR
103004: PUSH
103005: LD_STRING ")
103007: STR
103008: PPUSH
103009: CALL_OW 559
// end else
103013: GO 103022
// ToLua ( getStreamItemsFromMission("","","") ) ;
103015: LD_STRING getStreamItemsFromMission("","","")
103017: PPUSH
103018: CALL_OW 559
// end ;
103022: LD_VAR 0 2
103026: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
103027: LD_EXP 79
103031: PUSH
103032: LD_EXP 84
103036: AND
103037: IFFALSE 103161
103039: GO 103041
103041: DISABLE
103042: LD_INT 0
103044: PPUSH
103045: PPUSH
// begin enable ;
103046: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
103047: LD_ADDR_VAR 0 2
103051: PUSH
103052: LD_INT 22
103054: PUSH
103055: LD_OWVAR 2
103059: PUSH
103060: EMPTY
103061: LIST
103062: LIST
103063: PUSH
103064: LD_INT 2
103066: PUSH
103067: LD_INT 34
103069: PUSH
103070: LD_INT 7
103072: PUSH
103073: EMPTY
103074: LIST
103075: LIST
103076: PUSH
103077: LD_INT 34
103079: PUSH
103080: LD_INT 45
103082: PUSH
103083: EMPTY
103084: LIST
103085: LIST
103086: PUSH
103087: LD_INT 34
103089: PUSH
103090: LD_INT 28
103092: PUSH
103093: EMPTY
103094: LIST
103095: LIST
103096: PUSH
103097: LD_INT 34
103099: PUSH
103100: LD_INT 47
103102: PUSH
103103: EMPTY
103104: LIST
103105: LIST
103106: PUSH
103107: EMPTY
103108: LIST
103109: LIST
103110: LIST
103111: LIST
103112: LIST
103113: PUSH
103114: EMPTY
103115: LIST
103116: LIST
103117: PPUSH
103118: CALL_OW 69
103122: ST_TO_ADDR
// if not tmp then
103123: LD_VAR 0 2
103127: NOT
103128: IFFALSE 103132
// exit ;
103130: GO 103161
// for i in tmp do
103132: LD_ADDR_VAR 0 1
103136: PUSH
103137: LD_VAR 0 2
103141: PUSH
103142: FOR_IN
103143: IFFALSE 103159
// begin SetLives ( i , 0 ) ;
103145: LD_VAR 0 1
103149: PPUSH
103150: LD_INT 0
103152: PPUSH
103153: CALL_OW 234
// end ;
103157: GO 103142
103159: POP
103160: POP
// end ;
103161: PPOPN 2
103163: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
103164: LD_EXP 79
103168: PUSH
103169: LD_EXP 85
103173: AND
103174: IFFALSE 103258
103176: GO 103178
103178: DISABLE
103179: LD_INT 0
103181: PPUSH
103182: PPUSH
// begin enable ;
103183: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
103184: LD_ADDR_VAR 0 2
103188: PUSH
103189: LD_INT 22
103191: PUSH
103192: LD_OWVAR 2
103196: PUSH
103197: EMPTY
103198: LIST
103199: LIST
103200: PUSH
103201: LD_INT 32
103203: PUSH
103204: LD_INT 3
103206: PUSH
103207: EMPTY
103208: LIST
103209: LIST
103210: PUSH
103211: EMPTY
103212: LIST
103213: LIST
103214: PPUSH
103215: CALL_OW 69
103219: ST_TO_ADDR
// if not tmp then
103220: LD_VAR 0 2
103224: NOT
103225: IFFALSE 103229
// exit ;
103227: GO 103258
// for i in tmp do
103229: LD_ADDR_VAR 0 1
103233: PUSH
103234: LD_VAR 0 2
103238: PUSH
103239: FOR_IN
103240: IFFALSE 103256
// begin SetLives ( i , 0 ) ;
103242: LD_VAR 0 1
103246: PPUSH
103247: LD_INT 0
103249: PPUSH
103250: CALL_OW 234
// end ;
103254: GO 103239
103256: POP
103257: POP
// end ;
103258: PPOPN 2
103260: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
103261: LD_EXP 79
103265: PUSH
103266: LD_EXP 82
103270: AND
103271: IFFALSE 103364
103273: GO 103275
103275: DISABLE
103276: LD_INT 0
103278: PPUSH
// begin enable ;
103279: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
103280: LD_ADDR_VAR 0 1
103284: PUSH
103285: LD_INT 22
103287: PUSH
103288: LD_OWVAR 2
103292: PUSH
103293: EMPTY
103294: LIST
103295: LIST
103296: PUSH
103297: LD_INT 2
103299: PUSH
103300: LD_INT 25
103302: PUSH
103303: LD_INT 5
103305: PUSH
103306: EMPTY
103307: LIST
103308: LIST
103309: PUSH
103310: LD_INT 25
103312: PUSH
103313: LD_INT 9
103315: PUSH
103316: EMPTY
103317: LIST
103318: LIST
103319: PUSH
103320: LD_INT 25
103322: PUSH
103323: LD_INT 8
103325: PUSH
103326: EMPTY
103327: LIST
103328: LIST
103329: PUSH
103330: EMPTY
103331: LIST
103332: LIST
103333: LIST
103334: LIST
103335: PUSH
103336: EMPTY
103337: LIST
103338: LIST
103339: PPUSH
103340: CALL_OW 69
103344: PUSH
103345: FOR_IN
103346: IFFALSE 103362
// begin SetClass ( i , 1 ) ;
103348: LD_VAR 0 1
103352: PPUSH
103353: LD_INT 1
103355: PPUSH
103356: CALL_OW 336
// end ;
103360: GO 103345
103362: POP
103363: POP
// end ;
103364: PPOPN 1
103366: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
103367: LD_EXP 79
103371: PUSH
103372: LD_EXP 83
103376: AND
103377: PUSH
103378: LD_OWVAR 65
103382: PUSH
103383: LD_INT 7
103385: LESS
103386: AND
103387: IFFALSE 103401
103389: GO 103391
103391: DISABLE
// begin enable ;
103392: ENABLE
// game_speed := 7 ;
103393: LD_ADDR_OWVAR 65
103397: PUSH
103398: LD_INT 7
103400: ST_TO_ADDR
// end ;
103401: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
103402: LD_EXP 79
103406: PUSH
103407: LD_EXP 86
103411: AND
103412: IFFALSE 103614
103414: GO 103416
103416: DISABLE
103417: LD_INT 0
103419: PPUSH
103420: PPUSH
103421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103422: LD_ADDR_VAR 0 3
103426: PUSH
103427: LD_INT 81
103429: PUSH
103430: LD_OWVAR 2
103434: PUSH
103435: EMPTY
103436: LIST
103437: LIST
103438: PUSH
103439: LD_INT 21
103441: PUSH
103442: LD_INT 1
103444: PUSH
103445: EMPTY
103446: LIST
103447: LIST
103448: PUSH
103449: EMPTY
103450: LIST
103451: LIST
103452: PPUSH
103453: CALL_OW 69
103457: ST_TO_ADDR
// if not tmp then
103458: LD_VAR 0 3
103462: NOT
103463: IFFALSE 103467
// exit ;
103465: GO 103614
// if tmp > 5 then
103467: LD_VAR 0 3
103471: PUSH
103472: LD_INT 5
103474: GREATER
103475: IFFALSE 103487
// k := 5 else
103477: LD_ADDR_VAR 0 2
103481: PUSH
103482: LD_INT 5
103484: ST_TO_ADDR
103485: GO 103497
// k := tmp ;
103487: LD_ADDR_VAR 0 2
103491: PUSH
103492: LD_VAR 0 3
103496: ST_TO_ADDR
// for i := 1 to k do
103497: LD_ADDR_VAR 0 1
103501: PUSH
103502: DOUBLE
103503: LD_INT 1
103505: DEC
103506: ST_TO_ADDR
103507: LD_VAR 0 2
103511: PUSH
103512: FOR_TO
103513: IFFALSE 103612
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
103515: LD_VAR 0 3
103519: PUSH
103520: LD_VAR 0 1
103524: ARRAY
103525: PPUSH
103526: LD_VAR 0 1
103530: PUSH
103531: LD_INT 4
103533: MOD
103534: PUSH
103535: LD_INT 1
103537: PLUS
103538: PPUSH
103539: CALL_OW 259
103543: PUSH
103544: LD_INT 10
103546: LESS
103547: IFFALSE 103610
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
103549: LD_VAR 0 3
103553: PUSH
103554: LD_VAR 0 1
103558: ARRAY
103559: PPUSH
103560: LD_VAR 0 1
103564: PUSH
103565: LD_INT 4
103567: MOD
103568: PUSH
103569: LD_INT 1
103571: PLUS
103572: PPUSH
103573: LD_VAR 0 3
103577: PUSH
103578: LD_VAR 0 1
103582: ARRAY
103583: PPUSH
103584: LD_VAR 0 1
103588: PUSH
103589: LD_INT 4
103591: MOD
103592: PUSH
103593: LD_INT 1
103595: PLUS
103596: PPUSH
103597: CALL_OW 259
103601: PUSH
103602: LD_INT 1
103604: PLUS
103605: PPUSH
103606: CALL_OW 237
103610: GO 103512
103612: POP
103613: POP
// end ;
103614: PPOPN 3
103616: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
103617: LD_EXP 79
103621: PUSH
103622: LD_EXP 87
103626: AND
103627: IFFALSE 103647
103629: GO 103631
103631: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
103632: LD_INT 4
103634: PPUSH
103635: LD_OWVAR 2
103639: PPUSH
103640: LD_INT 0
103642: PPUSH
103643: CALL_OW 324
103647: END
// every 0 0$1 trigger StreamModeActive and sShovel do
103648: LD_EXP 79
103652: PUSH
103653: LD_EXP 116
103657: AND
103658: IFFALSE 103678
103660: GO 103662
103662: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
103663: LD_INT 19
103665: PPUSH
103666: LD_OWVAR 2
103670: PPUSH
103671: LD_INT 0
103673: PPUSH
103674: CALL_OW 324
103678: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
103679: LD_EXP 79
103683: PUSH
103684: LD_EXP 88
103688: AND
103689: IFFALSE 103791
103691: GO 103693
103693: DISABLE
103694: LD_INT 0
103696: PPUSH
103697: PPUSH
// begin enable ;
103698: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
103699: LD_ADDR_VAR 0 2
103703: PUSH
103704: LD_INT 22
103706: PUSH
103707: LD_OWVAR 2
103711: PUSH
103712: EMPTY
103713: LIST
103714: LIST
103715: PUSH
103716: LD_INT 2
103718: PUSH
103719: LD_INT 34
103721: PUSH
103722: LD_INT 11
103724: PUSH
103725: EMPTY
103726: LIST
103727: LIST
103728: PUSH
103729: LD_INT 34
103731: PUSH
103732: LD_INT 30
103734: PUSH
103735: EMPTY
103736: LIST
103737: LIST
103738: PUSH
103739: EMPTY
103740: LIST
103741: LIST
103742: LIST
103743: PUSH
103744: EMPTY
103745: LIST
103746: LIST
103747: PPUSH
103748: CALL_OW 69
103752: ST_TO_ADDR
// if not tmp then
103753: LD_VAR 0 2
103757: NOT
103758: IFFALSE 103762
// exit ;
103760: GO 103791
// for i in tmp do
103762: LD_ADDR_VAR 0 1
103766: PUSH
103767: LD_VAR 0 2
103771: PUSH
103772: FOR_IN
103773: IFFALSE 103789
// begin SetLives ( i , 0 ) ;
103775: LD_VAR 0 1
103779: PPUSH
103780: LD_INT 0
103782: PPUSH
103783: CALL_OW 234
// end ;
103787: GO 103772
103789: POP
103790: POP
// end ;
103791: PPOPN 2
103793: END
// every 0 0$1 trigger StreamModeActive and sBunker do
103794: LD_EXP 79
103798: PUSH
103799: LD_EXP 89
103803: AND
103804: IFFALSE 103824
103806: GO 103808
103808: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
103809: LD_INT 32
103811: PPUSH
103812: LD_OWVAR 2
103816: PPUSH
103817: LD_INT 0
103819: PPUSH
103820: CALL_OW 324
103824: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
103825: LD_EXP 79
103829: PUSH
103830: LD_EXP 90
103834: AND
103835: IFFALSE 104016
103837: GO 103839
103839: DISABLE
103840: LD_INT 0
103842: PPUSH
103843: PPUSH
103844: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
103845: LD_ADDR_VAR 0 2
103849: PUSH
103850: LD_INT 22
103852: PUSH
103853: LD_OWVAR 2
103857: PUSH
103858: EMPTY
103859: LIST
103860: LIST
103861: PUSH
103862: LD_INT 33
103864: PUSH
103865: LD_INT 3
103867: PUSH
103868: EMPTY
103869: LIST
103870: LIST
103871: PUSH
103872: EMPTY
103873: LIST
103874: LIST
103875: PPUSH
103876: CALL_OW 69
103880: ST_TO_ADDR
// if not tmp then
103881: LD_VAR 0 2
103885: NOT
103886: IFFALSE 103890
// exit ;
103888: GO 104016
// side := 0 ;
103890: LD_ADDR_VAR 0 3
103894: PUSH
103895: LD_INT 0
103897: ST_TO_ADDR
// for i := 1 to 8 do
103898: LD_ADDR_VAR 0 1
103902: PUSH
103903: DOUBLE
103904: LD_INT 1
103906: DEC
103907: ST_TO_ADDR
103908: LD_INT 8
103910: PUSH
103911: FOR_TO
103912: IFFALSE 103960
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
103914: LD_OWVAR 2
103918: PUSH
103919: LD_VAR 0 1
103923: NONEQUAL
103924: PUSH
103925: LD_OWVAR 2
103929: PPUSH
103930: LD_VAR 0 1
103934: PPUSH
103935: CALL_OW 81
103939: PUSH
103940: LD_INT 2
103942: EQUAL
103943: AND
103944: IFFALSE 103958
// begin side := i ;
103946: LD_ADDR_VAR 0 3
103950: PUSH
103951: LD_VAR 0 1
103955: ST_TO_ADDR
// break ;
103956: GO 103960
// end ;
103958: GO 103911
103960: POP
103961: POP
// if not side then
103962: LD_VAR 0 3
103966: NOT
103967: IFFALSE 103971
// exit ;
103969: GO 104016
// for i := 1 to tmp do
103971: LD_ADDR_VAR 0 1
103975: PUSH
103976: DOUBLE
103977: LD_INT 1
103979: DEC
103980: ST_TO_ADDR
103981: LD_VAR 0 2
103985: PUSH
103986: FOR_TO
103987: IFFALSE 104014
// if Prob ( 60 ) then
103989: LD_INT 60
103991: PPUSH
103992: CALL_OW 13
103996: IFFALSE 104012
// SetSide ( i , side ) ;
103998: LD_VAR 0 1
104002: PPUSH
104003: LD_VAR 0 3
104007: PPUSH
104008: CALL_OW 235
104012: GO 103986
104014: POP
104015: POP
// end ;
104016: PPOPN 3
104018: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
104019: LD_EXP 79
104023: PUSH
104024: LD_EXP 92
104028: AND
104029: IFFALSE 104148
104031: GO 104033
104033: DISABLE
104034: LD_INT 0
104036: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
104037: LD_ADDR_VAR 0 1
104041: PUSH
104042: LD_INT 22
104044: PUSH
104045: LD_OWVAR 2
104049: PUSH
104050: EMPTY
104051: LIST
104052: LIST
104053: PUSH
104054: LD_INT 21
104056: PUSH
104057: LD_INT 1
104059: PUSH
104060: EMPTY
104061: LIST
104062: LIST
104063: PUSH
104064: LD_INT 3
104066: PUSH
104067: LD_INT 23
104069: PUSH
104070: LD_INT 0
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: PUSH
104077: EMPTY
104078: LIST
104079: LIST
104080: PUSH
104081: EMPTY
104082: LIST
104083: LIST
104084: LIST
104085: PPUSH
104086: CALL_OW 69
104090: PUSH
104091: FOR_IN
104092: IFFALSE 104146
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
104094: LD_VAR 0 1
104098: PPUSH
104099: CALL_OW 257
104103: PUSH
104104: LD_INT 1
104106: PUSH
104107: LD_INT 2
104109: PUSH
104110: LD_INT 3
104112: PUSH
104113: LD_INT 4
104115: PUSH
104116: EMPTY
104117: LIST
104118: LIST
104119: LIST
104120: LIST
104121: IN
104122: IFFALSE 104144
// SetClass ( un , rand ( 1 , 4 ) ) ;
104124: LD_VAR 0 1
104128: PPUSH
104129: LD_INT 1
104131: PPUSH
104132: LD_INT 4
104134: PPUSH
104135: CALL_OW 12
104139: PPUSH
104140: CALL_OW 336
104144: GO 104091
104146: POP
104147: POP
// end ;
104148: PPOPN 1
104150: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
104151: LD_EXP 79
104155: PUSH
104156: LD_EXP 91
104160: AND
104161: IFFALSE 104240
104163: GO 104165
104165: DISABLE
104166: LD_INT 0
104168: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
104169: LD_ADDR_VAR 0 1
104173: PUSH
104174: LD_INT 22
104176: PUSH
104177: LD_OWVAR 2
104181: PUSH
104182: EMPTY
104183: LIST
104184: LIST
104185: PUSH
104186: LD_INT 21
104188: PUSH
104189: LD_INT 3
104191: PUSH
104192: EMPTY
104193: LIST
104194: LIST
104195: PUSH
104196: EMPTY
104197: LIST
104198: LIST
104199: PPUSH
104200: CALL_OW 69
104204: ST_TO_ADDR
// if not tmp then
104205: LD_VAR 0 1
104209: NOT
104210: IFFALSE 104214
// exit ;
104212: GO 104240
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
104214: LD_VAR 0 1
104218: PUSH
104219: LD_INT 1
104221: PPUSH
104222: LD_VAR 0 1
104226: PPUSH
104227: CALL_OW 12
104231: ARRAY
104232: PPUSH
104233: LD_INT 100
104235: PPUSH
104236: CALL_OW 234
// end ;
104240: PPOPN 1
104242: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
104243: LD_EXP 79
104247: PUSH
104248: LD_EXP 93
104252: AND
104253: IFFALSE 104351
104255: GO 104257
104257: DISABLE
104258: LD_INT 0
104260: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104261: LD_ADDR_VAR 0 1
104265: PUSH
104266: LD_INT 22
104268: PUSH
104269: LD_OWVAR 2
104273: PUSH
104274: EMPTY
104275: LIST
104276: LIST
104277: PUSH
104278: LD_INT 21
104280: PUSH
104281: LD_INT 1
104283: PUSH
104284: EMPTY
104285: LIST
104286: LIST
104287: PUSH
104288: EMPTY
104289: LIST
104290: LIST
104291: PPUSH
104292: CALL_OW 69
104296: ST_TO_ADDR
// if not tmp then
104297: LD_VAR 0 1
104301: NOT
104302: IFFALSE 104306
// exit ;
104304: GO 104351
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
104306: LD_VAR 0 1
104310: PUSH
104311: LD_INT 1
104313: PPUSH
104314: LD_VAR 0 1
104318: PPUSH
104319: CALL_OW 12
104323: ARRAY
104324: PPUSH
104325: LD_INT 1
104327: PPUSH
104328: LD_INT 4
104330: PPUSH
104331: CALL_OW 12
104335: PPUSH
104336: LD_INT 3000
104338: PPUSH
104339: LD_INT 9000
104341: PPUSH
104342: CALL_OW 12
104346: PPUSH
104347: CALL_OW 492
// end ;
104351: PPOPN 1
104353: END
// every 0 0$1 trigger StreamModeActive and sDepot do
104354: LD_EXP 79
104358: PUSH
104359: LD_EXP 94
104363: AND
104364: IFFALSE 104384
104366: GO 104368
104368: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
104369: LD_INT 1
104371: PPUSH
104372: LD_OWVAR 2
104376: PPUSH
104377: LD_INT 0
104379: PPUSH
104380: CALL_OW 324
104384: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
104385: LD_EXP 79
104389: PUSH
104390: LD_EXP 95
104394: AND
104395: IFFALSE 104478
104397: GO 104399
104399: DISABLE
104400: LD_INT 0
104402: PPUSH
104403: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
104404: LD_ADDR_VAR 0 2
104408: PUSH
104409: LD_INT 22
104411: PUSH
104412: LD_OWVAR 2
104416: PUSH
104417: EMPTY
104418: LIST
104419: LIST
104420: PUSH
104421: LD_INT 21
104423: PUSH
104424: LD_INT 3
104426: PUSH
104427: EMPTY
104428: LIST
104429: LIST
104430: PUSH
104431: EMPTY
104432: LIST
104433: LIST
104434: PPUSH
104435: CALL_OW 69
104439: ST_TO_ADDR
// if not tmp then
104440: LD_VAR 0 2
104444: NOT
104445: IFFALSE 104449
// exit ;
104447: GO 104478
// for i in tmp do
104449: LD_ADDR_VAR 0 1
104453: PUSH
104454: LD_VAR 0 2
104458: PUSH
104459: FOR_IN
104460: IFFALSE 104476
// SetBLevel ( i , 10 ) ;
104462: LD_VAR 0 1
104466: PPUSH
104467: LD_INT 10
104469: PPUSH
104470: CALL_OW 241
104474: GO 104459
104476: POP
104477: POP
// end ;
104478: PPOPN 2
104480: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
104481: LD_EXP 79
104485: PUSH
104486: LD_EXP 96
104490: AND
104491: IFFALSE 104602
104493: GO 104495
104495: DISABLE
104496: LD_INT 0
104498: PPUSH
104499: PPUSH
104500: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104501: LD_ADDR_VAR 0 3
104505: PUSH
104506: LD_INT 22
104508: PUSH
104509: LD_OWVAR 2
104513: PUSH
104514: EMPTY
104515: LIST
104516: LIST
104517: PUSH
104518: LD_INT 25
104520: PUSH
104521: LD_INT 1
104523: PUSH
104524: EMPTY
104525: LIST
104526: LIST
104527: PUSH
104528: EMPTY
104529: LIST
104530: LIST
104531: PPUSH
104532: CALL_OW 69
104536: ST_TO_ADDR
// if not tmp then
104537: LD_VAR 0 3
104541: NOT
104542: IFFALSE 104546
// exit ;
104544: GO 104602
// un := tmp [ rand ( 1 , tmp ) ] ;
104546: LD_ADDR_VAR 0 2
104550: PUSH
104551: LD_VAR 0 3
104555: PUSH
104556: LD_INT 1
104558: PPUSH
104559: LD_VAR 0 3
104563: PPUSH
104564: CALL_OW 12
104568: ARRAY
104569: ST_TO_ADDR
// if Crawls ( un ) then
104570: LD_VAR 0 2
104574: PPUSH
104575: CALL_OW 318
104579: IFFALSE 104590
// ComWalk ( un ) ;
104581: LD_VAR 0 2
104585: PPUSH
104586: CALL_OW 138
// SetClass ( un , class_sniper ) ;
104590: LD_VAR 0 2
104594: PPUSH
104595: LD_INT 5
104597: PPUSH
104598: CALL_OW 336
// end ;
104602: PPOPN 3
104604: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
104605: LD_EXP 79
104609: PUSH
104610: LD_EXP 97
104614: AND
104615: PUSH
104616: LD_OWVAR 67
104620: PUSH
104621: LD_INT 4
104623: LESS
104624: AND
104625: IFFALSE 104644
104627: GO 104629
104629: DISABLE
// begin Difficulty := Difficulty + 1 ;
104630: LD_ADDR_OWVAR 67
104634: PUSH
104635: LD_OWVAR 67
104639: PUSH
104640: LD_INT 1
104642: PLUS
104643: ST_TO_ADDR
// end ;
104644: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
104645: LD_EXP 79
104649: PUSH
104650: LD_EXP 98
104654: AND
104655: IFFALSE 104758
104657: GO 104659
104659: DISABLE
104660: LD_INT 0
104662: PPUSH
// begin for i := 1 to 5 do
104663: LD_ADDR_VAR 0 1
104667: PUSH
104668: DOUBLE
104669: LD_INT 1
104671: DEC
104672: ST_TO_ADDR
104673: LD_INT 5
104675: PUSH
104676: FOR_TO
104677: IFFALSE 104756
// begin uc_nation := nation_nature ;
104679: LD_ADDR_OWVAR 21
104683: PUSH
104684: LD_INT 0
104686: ST_TO_ADDR
// uc_side := 0 ;
104687: LD_ADDR_OWVAR 20
104691: PUSH
104692: LD_INT 0
104694: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
104695: LD_ADDR_OWVAR 29
104699: PUSH
104700: LD_INT 12
104702: PUSH
104703: LD_INT 12
104705: PUSH
104706: EMPTY
104707: LIST
104708: LIST
104709: ST_TO_ADDR
// hc_agressivity := 20 ;
104710: LD_ADDR_OWVAR 35
104714: PUSH
104715: LD_INT 20
104717: ST_TO_ADDR
// hc_class := class_tiger ;
104718: LD_ADDR_OWVAR 28
104722: PUSH
104723: LD_INT 14
104725: ST_TO_ADDR
// hc_gallery :=  ;
104726: LD_ADDR_OWVAR 33
104730: PUSH
104731: LD_STRING 
104733: ST_TO_ADDR
// hc_name :=  ;
104734: LD_ADDR_OWVAR 26
104738: PUSH
104739: LD_STRING 
104741: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
104742: CALL_OW 44
104746: PPUSH
104747: LD_INT 0
104749: PPUSH
104750: CALL_OW 51
// end ;
104754: GO 104676
104756: POP
104757: POP
// end ;
104758: PPOPN 1
104760: END
// every 0 0$1 trigger StreamModeActive and sBomb do
104761: LD_EXP 79
104765: PUSH
104766: LD_EXP 99
104770: AND
104771: IFFALSE 104780
104773: GO 104775
104775: DISABLE
// StreamSibBomb ;
104776: CALL 104781 0 0
104780: END
// export function StreamSibBomb ; var i , x , y ; begin
104781: LD_INT 0
104783: PPUSH
104784: PPUSH
104785: PPUSH
104786: PPUSH
// result := false ;
104787: LD_ADDR_VAR 0 1
104791: PUSH
104792: LD_INT 0
104794: ST_TO_ADDR
// for i := 1 to 16 do
104795: LD_ADDR_VAR 0 2
104799: PUSH
104800: DOUBLE
104801: LD_INT 1
104803: DEC
104804: ST_TO_ADDR
104805: LD_INT 16
104807: PUSH
104808: FOR_TO
104809: IFFALSE 105008
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104811: LD_ADDR_VAR 0 3
104815: PUSH
104816: LD_INT 10
104818: PUSH
104819: LD_INT 20
104821: PUSH
104822: LD_INT 30
104824: PUSH
104825: LD_INT 40
104827: PUSH
104828: LD_INT 50
104830: PUSH
104831: LD_INT 60
104833: PUSH
104834: LD_INT 70
104836: PUSH
104837: LD_INT 80
104839: PUSH
104840: LD_INT 90
104842: PUSH
104843: LD_INT 100
104845: PUSH
104846: LD_INT 110
104848: PUSH
104849: LD_INT 120
104851: PUSH
104852: LD_INT 130
104854: PUSH
104855: LD_INT 140
104857: PUSH
104858: LD_INT 150
104860: PUSH
104861: EMPTY
104862: LIST
104863: LIST
104864: LIST
104865: LIST
104866: LIST
104867: LIST
104868: LIST
104869: LIST
104870: LIST
104871: LIST
104872: LIST
104873: LIST
104874: LIST
104875: LIST
104876: LIST
104877: PUSH
104878: LD_INT 1
104880: PPUSH
104881: LD_INT 15
104883: PPUSH
104884: CALL_OW 12
104888: ARRAY
104889: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
104890: LD_ADDR_VAR 0 4
104894: PUSH
104895: LD_INT 10
104897: PUSH
104898: LD_INT 20
104900: PUSH
104901: LD_INT 30
104903: PUSH
104904: LD_INT 40
104906: PUSH
104907: LD_INT 50
104909: PUSH
104910: LD_INT 60
104912: PUSH
104913: LD_INT 70
104915: PUSH
104916: LD_INT 80
104918: PUSH
104919: LD_INT 90
104921: PUSH
104922: LD_INT 100
104924: PUSH
104925: LD_INT 110
104927: PUSH
104928: LD_INT 120
104930: PUSH
104931: LD_INT 130
104933: PUSH
104934: LD_INT 140
104936: PUSH
104937: LD_INT 150
104939: PUSH
104940: EMPTY
104941: LIST
104942: LIST
104943: LIST
104944: LIST
104945: LIST
104946: LIST
104947: LIST
104948: LIST
104949: LIST
104950: LIST
104951: LIST
104952: LIST
104953: LIST
104954: LIST
104955: LIST
104956: PUSH
104957: LD_INT 1
104959: PPUSH
104960: LD_INT 15
104962: PPUSH
104963: CALL_OW 12
104967: ARRAY
104968: ST_TO_ADDR
// if ValidHex ( x , y ) then
104969: LD_VAR 0 3
104973: PPUSH
104974: LD_VAR 0 4
104978: PPUSH
104979: CALL_OW 488
104983: IFFALSE 105006
// begin result := [ x , y ] ;
104985: LD_ADDR_VAR 0 1
104989: PUSH
104990: LD_VAR 0 3
104994: PUSH
104995: LD_VAR 0 4
104999: PUSH
105000: EMPTY
105001: LIST
105002: LIST
105003: ST_TO_ADDR
// break ;
105004: GO 105008
// end ; end ;
105006: GO 104808
105008: POP
105009: POP
// if result then
105010: LD_VAR 0 1
105014: IFFALSE 105074
// begin ToLua ( playSibBomb() ) ;
105016: LD_STRING playSibBomb()
105018: PPUSH
105019: CALL_OW 559
// wait ( 0 0$14 ) ;
105023: LD_INT 490
105025: PPUSH
105026: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
105030: LD_VAR 0 1
105034: PUSH
105035: LD_INT 1
105037: ARRAY
105038: PPUSH
105039: LD_VAR 0 1
105043: PUSH
105044: LD_INT 2
105046: ARRAY
105047: PPUSH
105048: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
105052: LD_VAR 0 1
105056: PUSH
105057: LD_INT 1
105059: ARRAY
105060: PPUSH
105061: LD_VAR 0 1
105065: PUSH
105066: LD_INT 2
105068: ARRAY
105069: PPUSH
105070: CALL_OW 429
// end ; end ;
105074: LD_VAR 0 1
105078: RET
// every 0 0$1 trigger StreamModeActive and sReset do
105079: LD_EXP 79
105083: PUSH
105084: LD_EXP 101
105088: AND
105089: IFFALSE 105101
105091: GO 105093
105093: DISABLE
// YouLost (  ) ;
105094: LD_STRING 
105096: PPUSH
105097: CALL_OW 104
105101: END
// every 0 0$1 trigger StreamModeActive and sFog do
105102: LD_EXP 79
105106: PUSH
105107: LD_EXP 100
105111: AND
105112: IFFALSE 105126
105114: GO 105116
105116: DISABLE
// FogOff ( your_side ) ;
105117: LD_OWVAR 2
105121: PPUSH
105122: CALL_OW 344
105126: END
// every 0 0$1 trigger StreamModeActive and sSun do
105127: LD_EXP 79
105131: PUSH
105132: LD_EXP 102
105136: AND
105137: IFFALSE 105165
105139: GO 105141
105141: DISABLE
// begin solar_recharge_percent := 0 ;
105142: LD_ADDR_OWVAR 79
105146: PUSH
105147: LD_INT 0
105149: ST_TO_ADDR
// wait ( 5 5$00 ) ;
105150: LD_INT 10500
105152: PPUSH
105153: CALL_OW 67
// solar_recharge_percent := 100 ;
105157: LD_ADDR_OWVAR 79
105161: PUSH
105162: LD_INT 100
105164: ST_TO_ADDR
// end ;
105165: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
105166: LD_EXP 79
105170: PUSH
105171: LD_EXP 103
105175: AND
105176: IFFALSE 105415
105178: GO 105180
105180: DISABLE
105181: LD_INT 0
105183: PPUSH
105184: PPUSH
105185: PPUSH
// begin tmp := [ ] ;
105186: LD_ADDR_VAR 0 3
105190: PUSH
105191: EMPTY
105192: ST_TO_ADDR
// for i := 1 to 6 do
105193: LD_ADDR_VAR 0 1
105197: PUSH
105198: DOUBLE
105199: LD_INT 1
105201: DEC
105202: ST_TO_ADDR
105203: LD_INT 6
105205: PUSH
105206: FOR_TO
105207: IFFALSE 105312
// begin uc_nation := nation_nature ;
105209: LD_ADDR_OWVAR 21
105213: PUSH
105214: LD_INT 0
105216: ST_TO_ADDR
// uc_side := 0 ;
105217: LD_ADDR_OWVAR 20
105221: PUSH
105222: LD_INT 0
105224: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
105225: LD_ADDR_OWVAR 29
105229: PUSH
105230: LD_INT 12
105232: PUSH
105233: LD_INT 12
105235: PUSH
105236: EMPTY
105237: LIST
105238: LIST
105239: ST_TO_ADDR
// hc_agressivity := 20 ;
105240: LD_ADDR_OWVAR 35
105244: PUSH
105245: LD_INT 20
105247: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
105248: LD_ADDR_OWVAR 28
105252: PUSH
105253: LD_INT 17
105255: ST_TO_ADDR
// hc_gallery :=  ;
105256: LD_ADDR_OWVAR 33
105260: PUSH
105261: LD_STRING 
105263: ST_TO_ADDR
// hc_name :=  ;
105264: LD_ADDR_OWVAR 26
105268: PUSH
105269: LD_STRING 
105271: ST_TO_ADDR
// un := CreateHuman ;
105272: LD_ADDR_VAR 0 2
105276: PUSH
105277: CALL_OW 44
105281: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
105282: LD_VAR 0 2
105286: PPUSH
105287: LD_INT 1
105289: PPUSH
105290: CALL_OW 51
// tmp := tmp ^ un ;
105294: LD_ADDR_VAR 0 3
105298: PUSH
105299: LD_VAR 0 3
105303: PUSH
105304: LD_VAR 0 2
105308: ADD
105309: ST_TO_ADDR
// end ;
105310: GO 105206
105312: POP
105313: POP
// repeat wait ( 0 0$1 ) ;
105314: LD_INT 35
105316: PPUSH
105317: CALL_OW 67
// for un in tmp do
105321: LD_ADDR_VAR 0 2
105325: PUSH
105326: LD_VAR 0 3
105330: PUSH
105331: FOR_IN
105332: IFFALSE 105406
// begin if IsDead ( un ) then
105334: LD_VAR 0 2
105338: PPUSH
105339: CALL_OW 301
105343: IFFALSE 105363
// begin tmp := tmp diff un ;
105345: LD_ADDR_VAR 0 3
105349: PUSH
105350: LD_VAR 0 3
105354: PUSH
105355: LD_VAR 0 2
105359: DIFF
105360: ST_TO_ADDR
// continue ;
105361: GO 105331
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
105363: LD_VAR 0 2
105367: PPUSH
105368: LD_INT 3
105370: PUSH
105371: LD_INT 22
105373: PUSH
105374: LD_INT 0
105376: PUSH
105377: EMPTY
105378: LIST
105379: LIST
105380: PUSH
105381: EMPTY
105382: LIST
105383: LIST
105384: PPUSH
105385: CALL_OW 69
105389: PPUSH
105390: LD_VAR 0 2
105394: PPUSH
105395: CALL_OW 74
105399: PPUSH
105400: CALL_OW 115
// end ;
105404: GO 105331
105406: POP
105407: POP
// until not tmp ;
105408: LD_VAR 0 3
105412: NOT
105413: IFFALSE 105314
// end ;
105415: PPOPN 3
105417: END
// every 0 0$1 trigger StreamModeActive and sTroll do
105418: LD_EXP 79
105422: PUSH
105423: LD_EXP 104
105427: AND
105428: IFFALSE 105482
105430: GO 105432
105432: DISABLE
// begin ToLua ( displayTroll(); ) ;
105433: LD_STRING displayTroll();
105435: PPUSH
105436: CALL_OW 559
// wait ( 3 3$00 ) ;
105440: LD_INT 6300
105442: PPUSH
105443: CALL_OW 67
// ToLua ( hideTroll(); ) ;
105447: LD_STRING hideTroll();
105449: PPUSH
105450: CALL_OW 559
// wait ( 1 1$00 ) ;
105454: LD_INT 2100
105456: PPUSH
105457: CALL_OW 67
// ToLua ( displayTroll(); ) ;
105461: LD_STRING displayTroll();
105463: PPUSH
105464: CALL_OW 559
// wait ( 1 1$00 ) ;
105468: LD_INT 2100
105470: PPUSH
105471: CALL_OW 67
// ToLua ( hideTroll(); ) ;
105475: LD_STRING hideTroll();
105477: PPUSH
105478: CALL_OW 559
// end ;
105482: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
105483: LD_EXP 79
105487: PUSH
105488: LD_EXP 105
105492: AND
105493: IFFALSE 105556
105495: GO 105497
105497: DISABLE
105498: LD_INT 0
105500: PPUSH
// begin p := 0 ;
105501: LD_ADDR_VAR 0 1
105505: PUSH
105506: LD_INT 0
105508: ST_TO_ADDR
// repeat game_speed := 1 ;
105509: LD_ADDR_OWVAR 65
105513: PUSH
105514: LD_INT 1
105516: ST_TO_ADDR
// wait ( 0 0$1 ) ;
105517: LD_INT 35
105519: PPUSH
105520: CALL_OW 67
// p := p + 1 ;
105524: LD_ADDR_VAR 0 1
105528: PUSH
105529: LD_VAR 0 1
105533: PUSH
105534: LD_INT 1
105536: PLUS
105537: ST_TO_ADDR
// until p >= 60 ;
105538: LD_VAR 0 1
105542: PUSH
105543: LD_INT 60
105545: GREATEREQUAL
105546: IFFALSE 105509
// game_speed := 4 ;
105548: LD_ADDR_OWVAR 65
105552: PUSH
105553: LD_INT 4
105555: ST_TO_ADDR
// end ;
105556: PPOPN 1
105558: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
105559: LD_EXP 79
105563: PUSH
105564: LD_EXP 106
105568: AND
105569: IFFALSE 105715
105571: GO 105573
105573: DISABLE
105574: LD_INT 0
105576: PPUSH
105577: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105578: LD_ADDR_VAR 0 1
105582: PUSH
105583: LD_INT 22
105585: PUSH
105586: LD_OWVAR 2
105590: PUSH
105591: EMPTY
105592: LIST
105593: LIST
105594: PUSH
105595: LD_INT 2
105597: PUSH
105598: LD_INT 30
105600: PUSH
105601: LD_INT 0
105603: PUSH
105604: EMPTY
105605: LIST
105606: LIST
105607: PUSH
105608: LD_INT 30
105610: PUSH
105611: LD_INT 1
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: PUSH
105618: EMPTY
105619: LIST
105620: LIST
105621: LIST
105622: PUSH
105623: EMPTY
105624: LIST
105625: LIST
105626: PPUSH
105627: CALL_OW 69
105631: ST_TO_ADDR
// if not depot then
105632: LD_VAR 0 1
105636: NOT
105637: IFFALSE 105641
// exit ;
105639: GO 105715
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
105641: LD_ADDR_VAR 0 2
105645: PUSH
105646: LD_VAR 0 1
105650: PUSH
105651: LD_INT 1
105653: PPUSH
105654: LD_VAR 0 1
105658: PPUSH
105659: CALL_OW 12
105663: ARRAY
105664: PPUSH
105665: CALL_OW 274
105669: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
105670: LD_VAR 0 2
105674: PPUSH
105675: LD_INT 1
105677: PPUSH
105678: LD_INT 0
105680: PPUSH
105681: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
105685: LD_VAR 0 2
105689: PPUSH
105690: LD_INT 2
105692: PPUSH
105693: LD_INT 0
105695: PPUSH
105696: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
105700: LD_VAR 0 2
105704: PPUSH
105705: LD_INT 3
105707: PPUSH
105708: LD_INT 0
105710: PPUSH
105711: CALL_OW 277
// end ;
105715: PPOPN 2
105717: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
105718: LD_EXP 79
105722: PUSH
105723: LD_EXP 107
105727: AND
105728: IFFALSE 105825
105730: GO 105732
105732: DISABLE
105733: LD_INT 0
105735: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105736: LD_ADDR_VAR 0 1
105740: PUSH
105741: LD_INT 22
105743: PUSH
105744: LD_OWVAR 2
105748: PUSH
105749: EMPTY
105750: LIST
105751: LIST
105752: PUSH
105753: LD_INT 21
105755: PUSH
105756: LD_INT 1
105758: PUSH
105759: EMPTY
105760: LIST
105761: LIST
105762: PUSH
105763: LD_INT 3
105765: PUSH
105766: LD_INT 23
105768: PUSH
105769: LD_INT 0
105771: PUSH
105772: EMPTY
105773: LIST
105774: LIST
105775: PUSH
105776: EMPTY
105777: LIST
105778: LIST
105779: PUSH
105780: EMPTY
105781: LIST
105782: LIST
105783: LIST
105784: PPUSH
105785: CALL_OW 69
105789: ST_TO_ADDR
// if not tmp then
105790: LD_VAR 0 1
105794: NOT
105795: IFFALSE 105799
// exit ;
105797: GO 105825
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
105799: LD_VAR 0 1
105803: PUSH
105804: LD_INT 1
105806: PPUSH
105807: LD_VAR 0 1
105811: PPUSH
105812: CALL_OW 12
105816: ARRAY
105817: PPUSH
105818: LD_INT 200
105820: PPUSH
105821: CALL_OW 234
// end ;
105825: PPOPN 1
105827: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
105828: LD_EXP 79
105832: PUSH
105833: LD_EXP 108
105837: AND
105838: IFFALSE 105917
105840: GO 105842
105842: DISABLE
105843: LD_INT 0
105845: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
105846: LD_ADDR_VAR 0 1
105850: PUSH
105851: LD_INT 22
105853: PUSH
105854: LD_OWVAR 2
105858: PUSH
105859: EMPTY
105860: LIST
105861: LIST
105862: PUSH
105863: LD_INT 21
105865: PUSH
105866: LD_INT 2
105868: PUSH
105869: EMPTY
105870: LIST
105871: LIST
105872: PUSH
105873: EMPTY
105874: LIST
105875: LIST
105876: PPUSH
105877: CALL_OW 69
105881: ST_TO_ADDR
// if not tmp then
105882: LD_VAR 0 1
105886: NOT
105887: IFFALSE 105891
// exit ;
105889: GO 105917
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
105891: LD_VAR 0 1
105895: PUSH
105896: LD_INT 1
105898: PPUSH
105899: LD_VAR 0 1
105903: PPUSH
105904: CALL_OW 12
105908: ARRAY
105909: PPUSH
105910: LD_INT 60
105912: PPUSH
105913: CALL_OW 234
// end ;
105917: PPOPN 1
105919: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
105920: LD_EXP 79
105924: PUSH
105925: LD_EXP 109
105929: AND
105930: IFFALSE 106029
105932: GO 105934
105934: DISABLE
105935: LD_INT 0
105937: PPUSH
105938: PPUSH
// begin enable ;
105939: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
105940: LD_ADDR_VAR 0 1
105944: PUSH
105945: LD_INT 22
105947: PUSH
105948: LD_OWVAR 2
105952: PUSH
105953: EMPTY
105954: LIST
105955: LIST
105956: PUSH
105957: LD_INT 61
105959: PUSH
105960: EMPTY
105961: LIST
105962: PUSH
105963: LD_INT 33
105965: PUSH
105966: LD_INT 2
105968: PUSH
105969: EMPTY
105970: LIST
105971: LIST
105972: PUSH
105973: EMPTY
105974: LIST
105975: LIST
105976: LIST
105977: PPUSH
105978: CALL_OW 69
105982: ST_TO_ADDR
// if not tmp then
105983: LD_VAR 0 1
105987: NOT
105988: IFFALSE 105992
// exit ;
105990: GO 106029
// for i in tmp do
105992: LD_ADDR_VAR 0 2
105996: PUSH
105997: LD_VAR 0 1
106001: PUSH
106002: FOR_IN
106003: IFFALSE 106027
// if IsControledBy ( i ) then
106005: LD_VAR 0 2
106009: PPUSH
106010: CALL_OW 312
106014: IFFALSE 106025
// ComUnlink ( i ) ;
106016: LD_VAR 0 2
106020: PPUSH
106021: CALL_OW 136
106025: GO 106002
106027: POP
106028: POP
// end ;
106029: PPOPN 2
106031: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
106032: LD_EXP 79
106036: PUSH
106037: LD_EXP 110
106041: AND
106042: IFFALSE 106182
106044: GO 106046
106046: DISABLE
106047: LD_INT 0
106049: PPUSH
106050: PPUSH
// begin ToLua ( displayPowell(); ) ;
106051: LD_STRING displayPowell();
106053: PPUSH
106054: CALL_OW 559
// uc_side := 0 ;
106058: LD_ADDR_OWVAR 20
106062: PUSH
106063: LD_INT 0
106065: ST_TO_ADDR
// uc_nation := 2 ;
106066: LD_ADDR_OWVAR 21
106070: PUSH
106071: LD_INT 2
106073: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
106074: LD_ADDR_OWVAR 37
106078: PUSH
106079: LD_INT 14
106081: ST_TO_ADDR
// vc_engine := engine_siberite ;
106082: LD_ADDR_OWVAR 39
106086: PUSH
106087: LD_INT 3
106089: ST_TO_ADDR
// vc_control := control_apeman ;
106090: LD_ADDR_OWVAR 38
106094: PUSH
106095: LD_INT 5
106097: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
106098: LD_ADDR_OWVAR 40
106102: PUSH
106103: LD_INT 29
106105: ST_TO_ADDR
// un := CreateVehicle ;
106106: LD_ADDR_VAR 0 2
106110: PUSH
106111: CALL_OW 45
106115: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106116: LD_VAR 0 2
106120: PPUSH
106121: LD_INT 1
106123: PPUSH
106124: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
106128: LD_INT 35
106130: PPUSH
106131: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
106135: LD_VAR 0 2
106139: PPUSH
106140: LD_INT 22
106142: PUSH
106143: LD_OWVAR 2
106147: PUSH
106148: EMPTY
106149: LIST
106150: LIST
106151: PPUSH
106152: CALL_OW 69
106156: PPUSH
106157: LD_VAR 0 2
106161: PPUSH
106162: CALL_OW 74
106166: PPUSH
106167: CALL_OW 115
// until IsDead ( un ) ;
106171: LD_VAR 0 2
106175: PPUSH
106176: CALL_OW 301
106180: IFFALSE 106128
// end ;
106182: PPOPN 2
106184: END
// every 0 0$1 trigger StreamModeActive and sStu do
106185: LD_EXP 79
106189: PUSH
106190: LD_EXP 118
106194: AND
106195: IFFALSE 106211
106197: GO 106199
106199: DISABLE
// begin ToLua ( displayStucuk(); ) ;
106200: LD_STRING displayStucuk();
106202: PPUSH
106203: CALL_OW 559
// ResetFog ;
106207: CALL_OW 335
// end ;
106211: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
106212: LD_EXP 79
106216: PUSH
106217: LD_EXP 111
106221: AND
106222: IFFALSE 106363
106224: GO 106226
106226: DISABLE
106227: LD_INT 0
106229: PPUSH
106230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
106231: LD_ADDR_VAR 0 2
106235: PUSH
106236: LD_INT 22
106238: PUSH
106239: LD_OWVAR 2
106243: PUSH
106244: EMPTY
106245: LIST
106246: LIST
106247: PUSH
106248: LD_INT 21
106250: PUSH
106251: LD_INT 1
106253: PUSH
106254: EMPTY
106255: LIST
106256: LIST
106257: PUSH
106258: EMPTY
106259: LIST
106260: LIST
106261: PPUSH
106262: CALL_OW 69
106266: ST_TO_ADDR
// if not tmp then
106267: LD_VAR 0 2
106271: NOT
106272: IFFALSE 106276
// exit ;
106274: GO 106363
// un := tmp [ rand ( 1 , tmp ) ] ;
106276: LD_ADDR_VAR 0 1
106280: PUSH
106281: LD_VAR 0 2
106285: PUSH
106286: LD_INT 1
106288: PPUSH
106289: LD_VAR 0 2
106293: PPUSH
106294: CALL_OW 12
106298: ARRAY
106299: ST_TO_ADDR
// SetSide ( un , 0 ) ;
106300: LD_VAR 0 1
106304: PPUSH
106305: LD_INT 0
106307: PPUSH
106308: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
106312: LD_VAR 0 1
106316: PPUSH
106317: LD_OWVAR 3
106321: PUSH
106322: LD_VAR 0 1
106326: DIFF
106327: PPUSH
106328: LD_VAR 0 1
106332: PPUSH
106333: CALL_OW 74
106337: PPUSH
106338: CALL_OW 115
// wait ( 0 0$20 ) ;
106342: LD_INT 700
106344: PPUSH
106345: CALL_OW 67
// SetSide ( un , your_side ) ;
106349: LD_VAR 0 1
106353: PPUSH
106354: LD_OWVAR 2
106358: PPUSH
106359: CALL_OW 235
// end ;
106363: PPOPN 2
106365: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
106366: LD_EXP 79
106370: PUSH
106371: LD_EXP 112
106375: AND
106376: IFFALSE 106482
106378: GO 106380
106380: DISABLE
106381: LD_INT 0
106383: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
106384: LD_ADDR_VAR 0 1
106388: PUSH
106389: LD_INT 22
106391: PUSH
106392: LD_OWVAR 2
106396: PUSH
106397: EMPTY
106398: LIST
106399: LIST
106400: PUSH
106401: LD_INT 2
106403: PUSH
106404: LD_INT 30
106406: PUSH
106407: LD_INT 0
106409: PUSH
106410: EMPTY
106411: LIST
106412: LIST
106413: PUSH
106414: LD_INT 30
106416: PUSH
106417: LD_INT 1
106419: PUSH
106420: EMPTY
106421: LIST
106422: LIST
106423: PUSH
106424: EMPTY
106425: LIST
106426: LIST
106427: LIST
106428: PUSH
106429: EMPTY
106430: LIST
106431: LIST
106432: PPUSH
106433: CALL_OW 69
106437: ST_TO_ADDR
// if not depot then
106438: LD_VAR 0 1
106442: NOT
106443: IFFALSE 106447
// exit ;
106445: GO 106482
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
106447: LD_VAR 0 1
106451: PUSH
106452: LD_INT 1
106454: ARRAY
106455: PPUSH
106456: CALL_OW 250
106460: PPUSH
106461: LD_VAR 0 1
106465: PUSH
106466: LD_INT 1
106468: ARRAY
106469: PPUSH
106470: CALL_OW 251
106474: PPUSH
106475: LD_INT 70
106477: PPUSH
106478: CALL_OW 495
// end ;
106482: PPOPN 1
106484: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
106485: LD_EXP 79
106489: PUSH
106490: LD_EXP 113
106494: AND
106495: IFFALSE 106706
106497: GO 106499
106499: DISABLE
106500: LD_INT 0
106502: PPUSH
106503: PPUSH
106504: PPUSH
106505: PPUSH
106506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
106507: LD_ADDR_VAR 0 5
106511: PUSH
106512: LD_INT 22
106514: PUSH
106515: LD_OWVAR 2
106519: PUSH
106520: EMPTY
106521: LIST
106522: LIST
106523: PUSH
106524: LD_INT 21
106526: PUSH
106527: LD_INT 1
106529: PUSH
106530: EMPTY
106531: LIST
106532: LIST
106533: PUSH
106534: EMPTY
106535: LIST
106536: LIST
106537: PPUSH
106538: CALL_OW 69
106542: ST_TO_ADDR
// if not tmp then
106543: LD_VAR 0 5
106547: NOT
106548: IFFALSE 106552
// exit ;
106550: GO 106706
// for i in tmp do
106552: LD_ADDR_VAR 0 1
106556: PUSH
106557: LD_VAR 0 5
106561: PUSH
106562: FOR_IN
106563: IFFALSE 106704
// begin d := rand ( 0 , 5 ) ;
106565: LD_ADDR_VAR 0 4
106569: PUSH
106570: LD_INT 0
106572: PPUSH
106573: LD_INT 5
106575: PPUSH
106576: CALL_OW 12
106580: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
106581: LD_ADDR_VAR 0 2
106585: PUSH
106586: LD_VAR 0 1
106590: PPUSH
106591: CALL_OW 250
106595: PPUSH
106596: LD_VAR 0 4
106600: PPUSH
106601: LD_INT 3
106603: PPUSH
106604: LD_INT 12
106606: PPUSH
106607: CALL_OW 12
106611: PPUSH
106612: CALL_OW 272
106616: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
106617: LD_ADDR_VAR 0 3
106621: PUSH
106622: LD_VAR 0 1
106626: PPUSH
106627: CALL_OW 251
106631: PPUSH
106632: LD_VAR 0 4
106636: PPUSH
106637: LD_INT 3
106639: PPUSH
106640: LD_INT 12
106642: PPUSH
106643: CALL_OW 12
106647: PPUSH
106648: CALL_OW 273
106652: ST_TO_ADDR
// if ValidHex ( x , y ) then
106653: LD_VAR 0 2
106657: PPUSH
106658: LD_VAR 0 3
106662: PPUSH
106663: CALL_OW 488
106667: IFFALSE 106702
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
106669: LD_VAR 0 1
106673: PPUSH
106674: LD_VAR 0 2
106678: PPUSH
106679: LD_VAR 0 3
106683: PPUSH
106684: LD_INT 3
106686: PPUSH
106687: LD_INT 6
106689: PPUSH
106690: CALL_OW 12
106694: PPUSH
106695: LD_INT 1
106697: PPUSH
106698: CALL_OW 483
// end ;
106702: GO 106562
106704: POP
106705: POP
// end ;
106706: PPOPN 5
106708: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
106709: LD_EXP 79
106713: PUSH
106714: LD_EXP 114
106718: AND
106719: IFFALSE 106813
106721: GO 106723
106723: DISABLE
106724: LD_INT 0
106726: PPUSH
106727: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
106728: LD_ADDR_VAR 0 2
106732: PUSH
106733: LD_INT 22
106735: PUSH
106736: LD_OWVAR 2
106740: PUSH
106741: EMPTY
106742: LIST
106743: LIST
106744: PUSH
106745: LD_INT 32
106747: PUSH
106748: LD_INT 1
106750: PUSH
106751: EMPTY
106752: LIST
106753: LIST
106754: PUSH
106755: LD_INT 21
106757: PUSH
106758: LD_INT 2
106760: PUSH
106761: EMPTY
106762: LIST
106763: LIST
106764: PUSH
106765: EMPTY
106766: LIST
106767: LIST
106768: LIST
106769: PPUSH
106770: CALL_OW 69
106774: ST_TO_ADDR
// if not tmp then
106775: LD_VAR 0 2
106779: NOT
106780: IFFALSE 106784
// exit ;
106782: GO 106813
// for i in tmp do
106784: LD_ADDR_VAR 0 1
106788: PUSH
106789: LD_VAR 0 2
106793: PUSH
106794: FOR_IN
106795: IFFALSE 106811
// SetFuel ( i , 0 ) ;
106797: LD_VAR 0 1
106801: PPUSH
106802: LD_INT 0
106804: PPUSH
106805: CALL_OW 240
106809: GO 106794
106811: POP
106812: POP
// end ;
106813: PPOPN 2
106815: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
106816: LD_EXP 79
106820: PUSH
106821: LD_EXP 115
106825: AND
106826: IFFALSE 106892
106828: GO 106830
106830: DISABLE
106831: LD_INT 0
106833: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106834: LD_ADDR_VAR 0 1
106838: PUSH
106839: LD_INT 22
106841: PUSH
106842: LD_OWVAR 2
106846: PUSH
106847: EMPTY
106848: LIST
106849: LIST
106850: PUSH
106851: LD_INT 30
106853: PUSH
106854: LD_INT 29
106856: PUSH
106857: EMPTY
106858: LIST
106859: LIST
106860: PUSH
106861: EMPTY
106862: LIST
106863: LIST
106864: PPUSH
106865: CALL_OW 69
106869: ST_TO_ADDR
// if not tmp then
106870: LD_VAR 0 1
106874: NOT
106875: IFFALSE 106879
// exit ;
106877: GO 106892
// DestroyUnit ( tmp [ 1 ] ) ;
106879: LD_VAR 0 1
106883: PUSH
106884: LD_INT 1
106886: ARRAY
106887: PPUSH
106888: CALL_OW 65
// end ;
106892: PPOPN 1
106894: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
106895: LD_EXP 79
106899: PUSH
106900: LD_EXP 117
106904: AND
106905: IFFALSE 107034
106907: GO 106909
106909: DISABLE
106910: LD_INT 0
106912: PPUSH
// begin uc_side := 0 ;
106913: LD_ADDR_OWVAR 20
106917: PUSH
106918: LD_INT 0
106920: ST_TO_ADDR
// uc_nation := nation_arabian ;
106921: LD_ADDR_OWVAR 21
106925: PUSH
106926: LD_INT 2
106928: ST_TO_ADDR
// hc_gallery :=  ;
106929: LD_ADDR_OWVAR 33
106933: PUSH
106934: LD_STRING 
106936: ST_TO_ADDR
// hc_name :=  ;
106937: LD_ADDR_OWVAR 26
106941: PUSH
106942: LD_STRING 
106944: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
106945: LD_INT 1
106947: PPUSH
106948: LD_INT 11
106950: PPUSH
106951: LD_INT 10
106953: PPUSH
106954: CALL_OW 380
// un := CreateHuman ;
106958: LD_ADDR_VAR 0 1
106962: PUSH
106963: CALL_OW 44
106967: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106968: LD_VAR 0 1
106972: PPUSH
106973: LD_INT 1
106975: PPUSH
106976: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
106980: LD_INT 35
106982: PPUSH
106983: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
106987: LD_VAR 0 1
106991: PPUSH
106992: LD_INT 22
106994: PUSH
106995: LD_OWVAR 2
106999: PUSH
107000: EMPTY
107001: LIST
107002: LIST
107003: PPUSH
107004: CALL_OW 69
107008: PPUSH
107009: LD_VAR 0 1
107013: PPUSH
107014: CALL_OW 74
107018: PPUSH
107019: CALL_OW 115
// until IsDead ( un ) ;
107023: LD_VAR 0 1
107027: PPUSH
107028: CALL_OW 301
107032: IFFALSE 106980
// end ;
107034: PPOPN 1
107036: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
107037: LD_EXP 79
107041: PUSH
107042: LD_EXP 119
107046: AND
107047: IFFALSE 107059
107049: GO 107051
107051: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
107052: LD_STRING earthquake(getX(game), 0, 32)
107054: PPUSH
107055: CALL_OW 559
107059: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
107060: LD_EXP 79
107064: PUSH
107065: LD_EXP 120
107069: AND
107070: IFFALSE 107161
107072: GO 107074
107074: DISABLE
107075: LD_INT 0
107077: PPUSH
// begin enable ;
107078: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
107079: LD_ADDR_VAR 0 1
107083: PUSH
107084: LD_INT 22
107086: PUSH
107087: LD_OWVAR 2
107091: PUSH
107092: EMPTY
107093: LIST
107094: LIST
107095: PUSH
107096: LD_INT 21
107098: PUSH
107099: LD_INT 2
107101: PUSH
107102: EMPTY
107103: LIST
107104: LIST
107105: PUSH
107106: LD_INT 33
107108: PUSH
107109: LD_INT 3
107111: PUSH
107112: EMPTY
107113: LIST
107114: LIST
107115: PUSH
107116: EMPTY
107117: LIST
107118: LIST
107119: LIST
107120: PPUSH
107121: CALL_OW 69
107125: ST_TO_ADDR
// if not tmp then
107126: LD_VAR 0 1
107130: NOT
107131: IFFALSE 107135
// exit ;
107133: GO 107161
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
107135: LD_VAR 0 1
107139: PUSH
107140: LD_INT 1
107142: PPUSH
107143: LD_VAR 0 1
107147: PPUSH
107148: CALL_OW 12
107152: ARRAY
107153: PPUSH
107154: LD_INT 1
107156: PPUSH
107157: CALL_OW 234
// end ;
107161: PPOPN 1
107163: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
107164: LD_EXP 79
107168: PUSH
107169: LD_EXP 121
107173: AND
107174: IFFALSE 107315
107176: GO 107178
107178: DISABLE
107179: LD_INT 0
107181: PPUSH
107182: PPUSH
107183: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107184: LD_ADDR_VAR 0 3
107188: PUSH
107189: LD_INT 22
107191: PUSH
107192: LD_OWVAR 2
107196: PUSH
107197: EMPTY
107198: LIST
107199: LIST
107200: PUSH
107201: LD_INT 25
107203: PUSH
107204: LD_INT 1
107206: PUSH
107207: EMPTY
107208: LIST
107209: LIST
107210: PUSH
107211: EMPTY
107212: LIST
107213: LIST
107214: PPUSH
107215: CALL_OW 69
107219: ST_TO_ADDR
// if not tmp then
107220: LD_VAR 0 3
107224: NOT
107225: IFFALSE 107229
// exit ;
107227: GO 107315
// un := tmp [ rand ( 1 , tmp ) ] ;
107229: LD_ADDR_VAR 0 2
107233: PUSH
107234: LD_VAR 0 3
107238: PUSH
107239: LD_INT 1
107241: PPUSH
107242: LD_VAR 0 3
107246: PPUSH
107247: CALL_OW 12
107251: ARRAY
107252: ST_TO_ADDR
// if Crawls ( un ) then
107253: LD_VAR 0 2
107257: PPUSH
107258: CALL_OW 318
107262: IFFALSE 107273
// ComWalk ( un ) ;
107264: LD_VAR 0 2
107268: PPUSH
107269: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
107273: LD_VAR 0 2
107277: PPUSH
107278: LD_INT 9
107280: PPUSH
107281: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
107285: LD_INT 28
107287: PPUSH
107288: LD_OWVAR 2
107292: PPUSH
107293: LD_INT 2
107295: PPUSH
107296: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
107300: LD_INT 29
107302: PPUSH
107303: LD_OWVAR 2
107307: PPUSH
107308: LD_INT 2
107310: PPUSH
107311: CALL_OW 322
// end ;
107315: PPOPN 3
107317: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
107318: LD_EXP 79
107322: PUSH
107323: LD_EXP 122
107327: AND
107328: IFFALSE 107439
107330: GO 107332
107332: DISABLE
107333: LD_INT 0
107335: PPUSH
107336: PPUSH
107337: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107338: LD_ADDR_VAR 0 3
107342: PUSH
107343: LD_INT 22
107345: PUSH
107346: LD_OWVAR 2
107350: PUSH
107351: EMPTY
107352: LIST
107353: LIST
107354: PUSH
107355: LD_INT 25
107357: PUSH
107358: LD_INT 1
107360: PUSH
107361: EMPTY
107362: LIST
107363: LIST
107364: PUSH
107365: EMPTY
107366: LIST
107367: LIST
107368: PPUSH
107369: CALL_OW 69
107373: ST_TO_ADDR
// if not tmp then
107374: LD_VAR 0 3
107378: NOT
107379: IFFALSE 107383
// exit ;
107381: GO 107439
// un := tmp [ rand ( 1 , tmp ) ] ;
107383: LD_ADDR_VAR 0 2
107387: PUSH
107388: LD_VAR 0 3
107392: PUSH
107393: LD_INT 1
107395: PPUSH
107396: LD_VAR 0 3
107400: PPUSH
107401: CALL_OW 12
107405: ARRAY
107406: ST_TO_ADDR
// if Crawls ( un ) then
107407: LD_VAR 0 2
107411: PPUSH
107412: CALL_OW 318
107416: IFFALSE 107427
// ComWalk ( un ) ;
107418: LD_VAR 0 2
107422: PPUSH
107423: CALL_OW 138
// SetClass ( un , class_mortar ) ;
107427: LD_VAR 0 2
107431: PPUSH
107432: LD_INT 8
107434: PPUSH
107435: CALL_OW 336
// end ;
107439: PPOPN 3
107441: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
107442: LD_EXP 79
107446: PUSH
107447: LD_EXP 123
107451: AND
107452: IFFALSE 107596
107454: GO 107456
107456: DISABLE
107457: LD_INT 0
107459: PPUSH
107460: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
107461: LD_ADDR_VAR 0 2
107465: PUSH
107466: LD_INT 22
107468: PUSH
107469: LD_OWVAR 2
107473: PUSH
107474: EMPTY
107475: LIST
107476: LIST
107477: PUSH
107478: LD_INT 21
107480: PUSH
107481: LD_INT 2
107483: PUSH
107484: EMPTY
107485: LIST
107486: LIST
107487: PUSH
107488: LD_INT 2
107490: PUSH
107491: LD_INT 34
107493: PUSH
107494: LD_INT 12
107496: PUSH
107497: EMPTY
107498: LIST
107499: LIST
107500: PUSH
107501: LD_INT 34
107503: PUSH
107504: LD_INT 51
107506: PUSH
107507: EMPTY
107508: LIST
107509: LIST
107510: PUSH
107511: LD_INT 34
107513: PUSH
107514: LD_INT 32
107516: PUSH
107517: EMPTY
107518: LIST
107519: LIST
107520: PUSH
107521: EMPTY
107522: LIST
107523: LIST
107524: LIST
107525: LIST
107526: PUSH
107527: EMPTY
107528: LIST
107529: LIST
107530: LIST
107531: PPUSH
107532: CALL_OW 69
107536: ST_TO_ADDR
// if not tmp then
107537: LD_VAR 0 2
107541: NOT
107542: IFFALSE 107546
// exit ;
107544: GO 107596
// for i in tmp do
107546: LD_ADDR_VAR 0 1
107550: PUSH
107551: LD_VAR 0 2
107555: PUSH
107556: FOR_IN
107557: IFFALSE 107594
// if GetCargo ( i , mat_artifact ) = 0 then
107559: LD_VAR 0 1
107563: PPUSH
107564: LD_INT 4
107566: PPUSH
107567: CALL_OW 289
107571: PUSH
107572: LD_INT 0
107574: EQUAL
107575: IFFALSE 107592
// SetCargo ( i , mat_siberit , 100 ) ;
107577: LD_VAR 0 1
107581: PPUSH
107582: LD_INT 3
107584: PPUSH
107585: LD_INT 100
107587: PPUSH
107588: CALL_OW 290
107592: GO 107556
107594: POP
107595: POP
// end ;
107596: PPOPN 2
107598: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
107599: LD_EXP 79
107603: PUSH
107604: LD_EXP 124
107608: AND
107609: IFFALSE 107792
107611: GO 107613
107613: DISABLE
107614: LD_INT 0
107616: PPUSH
107617: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107618: LD_ADDR_VAR 0 2
107622: PUSH
107623: LD_INT 22
107625: PUSH
107626: LD_OWVAR 2
107630: PUSH
107631: EMPTY
107632: LIST
107633: LIST
107634: PPUSH
107635: CALL_OW 69
107639: ST_TO_ADDR
// if not tmp then
107640: LD_VAR 0 2
107644: NOT
107645: IFFALSE 107649
// exit ;
107647: GO 107792
// for i := 1 to 2 do
107649: LD_ADDR_VAR 0 1
107653: PUSH
107654: DOUBLE
107655: LD_INT 1
107657: DEC
107658: ST_TO_ADDR
107659: LD_INT 2
107661: PUSH
107662: FOR_TO
107663: IFFALSE 107790
// begin uc_side := your_side ;
107665: LD_ADDR_OWVAR 20
107669: PUSH
107670: LD_OWVAR 2
107674: ST_TO_ADDR
// uc_nation := nation_american ;
107675: LD_ADDR_OWVAR 21
107679: PUSH
107680: LD_INT 1
107682: ST_TO_ADDR
// vc_chassis := us_morphling ;
107683: LD_ADDR_OWVAR 37
107687: PUSH
107688: LD_INT 5
107690: ST_TO_ADDR
// vc_engine := engine_siberite ;
107691: LD_ADDR_OWVAR 39
107695: PUSH
107696: LD_INT 3
107698: ST_TO_ADDR
// vc_control := control_computer ;
107699: LD_ADDR_OWVAR 38
107703: PUSH
107704: LD_INT 3
107706: ST_TO_ADDR
// vc_weapon := us_double_laser ;
107707: LD_ADDR_OWVAR 40
107711: PUSH
107712: LD_INT 10
107714: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
107715: LD_VAR 0 2
107719: PUSH
107720: LD_INT 1
107722: ARRAY
107723: PPUSH
107724: CALL_OW 310
107728: NOT
107729: IFFALSE 107776
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
107731: CALL_OW 45
107735: PPUSH
107736: LD_VAR 0 2
107740: PUSH
107741: LD_INT 1
107743: ARRAY
107744: PPUSH
107745: CALL_OW 250
107749: PPUSH
107750: LD_VAR 0 2
107754: PUSH
107755: LD_INT 1
107757: ARRAY
107758: PPUSH
107759: CALL_OW 251
107763: PPUSH
107764: LD_INT 12
107766: PPUSH
107767: LD_INT 1
107769: PPUSH
107770: CALL_OW 50
107774: GO 107788
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
107776: CALL_OW 45
107780: PPUSH
107781: LD_INT 1
107783: PPUSH
107784: CALL_OW 51
// end ;
107788: GO 107662
107790: POP
107791: POP
// end ;
107792: PPOPN 2
107794: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
107795: LD_EXP 79
107799: PUSH
107800: LD_EXP 125
107804: AND
107805: IFFALSE 108027
107807: GO 107809
107809: DISABLE
107810: LD_INT 0
107812: PPUSH
107813: PPUSH
107814: PPUSH
107815: PPUSH
107816: PPUSH
107817: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
107818: LD_ADDR_VAR 0 6
107822: PUSH
107823: LD_INT 22
107825: PUSH
107826: LD_OWVAR 2
107830: PUSH
107831: EMPTY
107832: LIST
107833: LIST
107834: PUSH
107835: LD_INT 21
107837: PUSH
107838: LD_INT 1
107840: PUSH
107841: EMPTY
107842: LIST
107843: LIST
107844: PUSH
107845: LD_INT 3
107847: PUSH
107848: LD_INT 23
107850: PUSH
107851: LD_INT 0
107853: PUSH
107854: EMPTY
107855: LIST
107856: LIST
107857: PUSH
107858: EMPTY
107859: LIST
107860: LIST
107861: PUSH
107862: EMPTY
107863: LIST
107864: LIST
107865: LIST
107866: PPUSH
107867: CALL_OW 69
107871: ST_TO_ADDR
// if not tmp then
107872: LD_VAR 0 6
107876: NOT
107877: IFFALSE 107881
// exit ;
107879: GO 108027
// s1 := rand ( 1 , 4 ) ;
107881: LD_ADDR_VAR 0 2
107885: PUSH
107886: LD_INT 1
107888: PPUSH
107889: LD_INT 4
107891: PPUSH
107892: CALL_OW 12
107896: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
107897: LD_ADDR_VAR 0 4
107901: PUSH
107902: LD_VAR 0 6
107906: PUSH
107907: LD_INT 1
107909: ARRAY
107910: PPUSH
107911: LD_VAR 0 2
107915: PPUSH
107916: CALL_OW 259
107920: ST_TO_ADDR
// if s1 = 1 then
107921: LD_VAR 0 2
107925: PUSH
107926: LD_INT 1
107928: EQUAL
107929: IFFALSE 107949
// s2 := rand ( 2 , 4 ) else
107931: LD_ADDR_VAR 0 3
107935: PUSH
107936: LD_INT 2
107938: PPUSH
107939: LD_INT 4
107941: PPUSH
107942: CALL_OW 12
107946: ST_TO_ADDR
107947: GO 107957
// s2 := 1 ;
107949: LD_ADDR_VAR 0 3
107953: PUSH
107954: LD_INT 1
107956: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
107957: LD_ADDR_VAR 0 5
107961: PUSH
107962: LD_VAR 0 6
107966: PUSH
107967: LD_INT 1
107969: ARRAY
107970: PPUSH
107971: LD_VAR 0 3
107975: PPUSH
107976: CALL_OW 259
107980: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
107981: LD_VAR 0 6
107985: PUSH
107986: LD_INT 1
107988: ARRAY
107989: PPUSH
107990: LD_VAR 0 2
107994: PPUSH
107995: LD_VAR 0 5
107999: PPUSH
108000: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
108004: LD_VAR 0 6
108008: PUSH
108009: LD_INT 1
108011: ARRAY
108012: PPUSH
108013: LD_VAR 0 3
108017: PPUSH
108018: LD_VAR 0 4
108022: PPUSH
108023: CALL_OW 237
// end ;
108027: PPOPN 6
108029: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
108030: LD_EXP 79
108034: PUSH
108035: LD_EXP 126
108039: AND
108040: IFFALSE 108119
108042: GO 108044
108044: DISABLE
108045: LD_INT 0
108047: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
108048: LD_ADDR_VAR 0 1
108052: PUSH
108053: LD_INT 22
108055: PUSH
108056: LD_OWVAR 2
108060: PUSH
108061: EMPTY
108062: LIST
108063: LIST
108064: PUSH
108065: LD_INT 30
108067: PUSH
108068: LD_INT 3
108070: PUSH
108071: EMPTY
108072: LIST
108073: LIST
108074: PUSH
108075: EMPTY
108076: LIST
108077: LIST
108078: PPUSH
108079: CALL_OW 69
108083: ST_TO_ADDR
// if not tmp then
108084: LD_VAR 0 1
108088: NOT
108089: IFFALSE 108093
// exit ;
108091: GO 108119
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
108093: LD_VAR 0 1
108097: PUSH
108098: LD_INT 1
108100: PPUSH
108101: LD_VAR 0 1
108105: PPUSH
108106: CALL_OW 12
108110: ARRAY
108111: PPUSH
108112: LD_INT 1
108114: PPUSH
108115: CALL_OW 234
// end ;
108119: PPOPN 1
108121: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
108122: LD_EXP 79
108126: PUSH
108127: LD_EXP 127
108131: AND
108132: IFFALSE 108244
108134: GO 108136
108136: DISABLE
108137: LD_INT 0
108139: PPUSH
108140: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
108141: LD_ADDR_VAR 0 2
108145: PUSH
108146: LD_INT 22
108148: PUSH
108149: LD_OWVAR 2
108153: PUSH
108154: EMPTY
108155: LIST
108156: LIST
108157: PUSH
108158: LD_INT 2
108160: PUSH
108161: LD_INT 30
108163: PUSH
108164: LD_INT 27
108166: PUSH
108167: EMPTY
108168: LIST
108169: LIST
108170: PUSH
108171: LD_INT 30
108173: PUSH
108174: LD_INT 26
108176: PUSH
108177: EMPTY
108178: LIST
108179: LIST
108180: PUSH
108181: LD_INT 30
108183: PUSH
108184: LD_INT 28
108186: PUSH
108187: EMPTY
108188: LIST
108189: LIST
108190: PUSH
108191: EMPTY
108192: LIST
108193: LIST
108194: LIST
108195: LIST
108196: PUSH
108197: EMPTY
108198: LIST
108199: LIST
108200: PPUSH
108201: CALL_OW 69
108205: ST_TO_ADDR
// if not tmp then
108206: LD_VAR 0 2
108210: NOT
108211: IFFALSE 108215
// exit ;
108213: GO 108244
// for i in tmp do
108215: LD_ADDR_VAR 0 1
108219: PUSH
108220: LD_VAR 0 2
108224: PUSH
108225: FOR_IN
108226: IFFALSE 108242
// SetLives ( i , 1 ) ;
108228: LD_VAR 0 1
108232: PPUSH
108233: LD_INT 1
108235: PPUSH
108236: CALL_OW 234
108240: GO 108225
108242: POP
108243: POP
// end ;
108244: PPOPN 2
108246: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
108247: LD_EXP 79
108251: PUSH
108252: LD_EXP 128
108256: AND
108257: IFFALSE 108544
108259: GO 108261
108261: DISABLE
108262: LD_INT 0
108264: PPUSH
108265: PPUSH
108266: PPUSH
// begin i := rand ( 1 , 7 ) ;
108267: LD_ADDR_VAR 0 1
108271: PUSH
108272: LD_INT 1
108274: PPUSH
108275: LD_INT 7
108277: PPUSH
108278: CALL_OW 12
108282: ST_TO_ADDR
// case i of 1 :
108283: LD_VAR 0 1
108287: PUSH
108288: LD_INT 1
108290: DOUBLE
108291: EQUAL
108292: IFTRUE 108296
108294: GO 108306
108296: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
108297: LD_STRING earthquake(getX(game), 0, 32)
108299: PPUSH
108300: CALL_OW 559
108304: GO 108544
108306: LD_INT 2
108308: DOUBLE
108309: EQUAL
108310: IFTRUE 108314
108312: GO 108328
108314: POP
// begin ToLua ( displayStucuk(); ) ;
108315: LD_STRING displayStucuk();
108317: PPUSH
108318: CALL_OW 559
// ResetFog ;
108322: CALL_OW 335
// end ; 3 :
108326: GO 108544
108328: LD_INT 3
108330: DOUBLE
108331: EQUAL
108332: IFTRUE 108336
108334: GO 108440
108336: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
108337: LD_ADDR_VAR 0 2
108341: PUSH
108342: LD_INT 22
108344: PUSH
108345: LD_OWVAR 2
108349: PUSH
108350: EMPTY
108351: LIST
108352: LIST
108353: PUSH
108354: LD_INT 25
108356: PUSH
108357: LD_INT 1
108359: PUSH
108360: EMPTY
108361: LIST
108362: LIST
108363: PUSH
108364: EMPTY
108365: LIST
108366: LIST
108367: PPUSH
108368: CALL_OW 69
108372: ST_TO_ADDR
// if not tmp then
108373: LD_VAR 0 2
108377: NOT
108378: IFFALSE 108382
// exit ;
108380: GO 108544
// un := tmp [ rand ( 1 , tmp ) ] ;
108382: LD_ADDR_VAR 0 3
108386: PUSH
108387: LD_VAR 0 2
108391: PUSH
108392: LD_INT 1
108394: PPUSH
108395: LD_VAR 0 2
108399: PPUSH
108400: CALL_OW 12
108404: ARRAY
108405: ST_TO_ADDR
// if Crawls ( un ) then
108406: LD_VAR 0 3
108410: PPUSH
108411: CALL_OW 318
108415: IFFALSE 108426
// ComWalk ( un ) ;
108417: LD_VAR 0 3
108421: PPUSH
108422: CALL_OW 138
// SetClass ( un , class_mortar ) ;
108426: LD_VAR 0 3
108430: PPUSH
108431: LD_INT 8
108433: PPUSH
108434: CALL_OW 336
// end ; 4 :
108438: GO 108544
108440: LD_INT 4
108442: DOUBLE
108443: EQUAL
108444: IFTRUE 108448
108446: GO 108522
108448: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
108449: LD_ADDR_VAR 0 2
108453: PUSH
108454: LD_INT 22
108456: PUSH
108457: LD_OWVAR 2
108461: PUSH
108462: EMPTY
108463: LIST
108464: LIST
108465: PUSH
108466: LD_INT 30
108468: PUSH
108469: LD_INT 29
108471: PUSH
108472: EMPTY
108473: LIST
108474: LIST
108475: PUSH
108476: EMPTY
108477: LIST
108478: LIST
108479: PPUSH
108480: CALL_OW 69
108484: ST_TO_ADDR
// if not tmp then
108485: LD_VAR 0 2
108489: NOT
108490: IFFALSE 108494
// exit ;
108492: GO 108544
// CenterNowOnUnits ( tmp [ 1 ] ) ;
108494: LD_VAR 0 2
108498: PUSH
108499: LD_INT 1
108501: ARRAY
108502: PPUSH
108503: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
108507: LD_VAR 0 2
108511: PUSH
108512: LD_INT 1
108514: ARRAY
108515: PPUSH
108516: CALL_OW 65
// end ; 5 .. 7 :
108520: GO 108544
108522: LD_INT 5
108524: DOUBLE
108525: GREATEREQUAL
108526: IFFALSE 108534
108528: LD_INT 7
108530: DOUBLE
108531: LESSEQUAL
108532: IFTRUE 108536
108534: GO 108543
108536: POP
// StreamSibBomb ; end ;
108537: CALL 104781 0 0
108541: GO 108544
108543: POP
// end ;
108544: PPOPN 3
108546: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
108547: LD_EXP 79
108551: PUSH
108552: LD_EXP 129
108556: AND
108557: IFFALSE 108713
108559: GO 108561
108561: DISABLE
108562: LD_INT 0
108564: PPUSH
108565: PPUSH
108566: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
108567: LD_ADDR_VAR 0 2
108571: PUSH
108572: LD_INT 81
108574: PUSH
108575: LD_OWVAR 2
108579: PUSH
108580: EMPTY
108581: LIST
108582: LIST
108583: PUSH
108584: LD_INT 2
108586: PUSH
108587: LD_INT 21
108589: PUSH
108590: LD_INT 1
108592: PUSH
108593: EMPTY
108594: LIST
108595: LIST
108596: PUSH
108597: LD_INT 21
108599: PUSH
108600: LD_INT 2
108602: PUSH
108603: EMPTY
108604: LIST
108605: LIST
108606: PUSH
108607: EMPTY
108608: LIST
108609: LIST
108610: LIST
108611: PUSH
108612: EMPTY
108613: LIST
108614: LIST
108615: PPUSH
108616: CALL_OW 69
108620: ST_TO_ADDR
// if not tmp then
108621: LD_VAR 0 2
108625: NOT
108626: IFFALSE 108630
// exit ;
108628: GO 108713
// p := 0 ;
108630: LD_ADDR_VAR 0 3
108634: PUSH
108635: LD_INT 0
108637: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
108638: LD_INT 35
108640: PPUSH
108641: CALL_OW 67
// p := p + 1 ;
108645: LD_ADDR_VAR 0 3
108649: PUSH
108650: LD_VAR 0 3
108654: PUSH
108655: LD_INT 1
108657: PLUS
108658: ST_TO_ADDR
// for i in tmp do
108659: LD_ADDR_VAR 0 1
108663: PUSH
108664: LD_VAR 0 2
108668: PUSH
108669: FOR_IN
108670: IFFALSE 108701
// if GetLives ( i ) < 1000 then
108672: LD_VAR 0 1
108676: PPUSH
108677: CALL_OW 256
108681: PUSH
108682: LD_INT 1000
108684: LESS
108685: IFFALSE 108699
// SetLives ( i , 1000 ) ;
108687: LD_VAR 0 1
108691: PPUSH
108692: LD_INT 1000
108694: PPUSH
108695: CALL_OW 234
108699: GO 108669
108701: POP
108702: POP
// until p > 20 ;
108703: LD_VAR 0 3
108707: PUSH
108708: LD_INT 20
108710: GREATER
108711: IFFALSE 108638
// end ;
108713: PPOPN 3
108715: END
// every 0 0$1 trigger StreamModeActive and sTime do
108716: LD_EXP 79
108720: PUSH
108721: LD_EXP 130
108725: AND
108726: IFFALSE 108761
108728: GO 108730
108730: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
108731: LD_INT 28
108733: PPUSH
108734: LD_OWVAR 2
108738: PPUSH
108739: LD_INT 2
108741: PPUSH
108742: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
108746: LD_INT 30
108748: PPUSH
108749: LD_OWVAR 2
108753: PPUSH
108754: LD_INT 2
108756: PPUSH
108757: CALL_OW 322
// end ;
108761: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
108762: LD_EXP 79
108766: PUSH
108767: LD_EXP 131
108771: AND
108772: IFFALSE 108893
108774: GO 108776
108776: DISABLE
108777: LD_INT 0
108779: PPUSH
108780: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108781: LD_ADDR_VAR 0 2
108785: PUSH
108786: LD_INT 22
108788: PUSH
108789: LD_OWVAR 2
108793: PUSH
108794: EMPTY
108795: LIST
108796: LIST
108797: PUSH
108798: LD_INT 21
108800: PUSH
108801: LD_INT 1
108803: PUSH
108804: EMPTY
108805: LIST
108806: LIST
108807: PUSH
108808: LD_INT 3
108810: PUSH
108811: LD_INT 23
108813: PUSH
108814: LD_INT 0
108816: PUSH
108817: EMPTY
108818: LIST
108819: LIST
108820: PUSH
108821: EMPTY
108822: LIST
108823: LIST
108824: PUSH
108825: EMPTY
108826: LIST
108827: LIST
108828: LIST
108829: PPUSH
108830: CALL_OW 69
108834: ST_TO_ADDR
// if not tmp then
108835: LD_VAR 0 2
108839: NOT
108840: IFFALSE 108844
// exit ;
108842: GO 108893
// for i in tmp do
108844: LD_ADDR_VAR 0 1
108848: PUSH
108849: LD_VAR 0 2
108853: PUSH
108854: FOR_IN
108855: IFFALSE 108891
// begin if Crawls ( i ) then
108857: LD_VAR 0 1
108861: PPUSH
108862: CALL_OW 318
108866: IFFALSE 108877
// ComWalk ( i ) ;
108868: LD_VAR 0 1
108872: PPUSH
108873: CALL_OW 138
// SetClass ( i , 2 ) ;
108877: LD_VAR 0 1
108881: PPUSH
108882: LD_INT 2
108884: PPUSH
108885: CALL_OW 336
// end ;
108889: GO 108854
108891: POP
108892: POP
// end ;
108893: PPOPN 2
108895: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
108896: LD_EXP 79
108900: PUSH
108901: LD_EXP 132
108905: AND
108906: IFFALSE 109194
108908: GO 108910
108910: DISABLE
108911: LD_INT 0
108913: PPUSH
108914: PPUSH
108915: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
108916: LD_OWVAR 2
108920: PPUSH
108921: LD_INT 9
108923: PPUSH
108924: LD_INT 1
108926: PPUSH
108927: LD_INT 1
108929: PPUSH
108930: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
108934: LD_INT 9
108936: PPUSH
108937: LD_OWVAR 2
108941: PPUSH
108942: CALL_OW 343
// uc_side := 9 ;
108946: LD_ADDR_OWVAR 20
108950: PUSH
108951: LD_INT 9
108953: ST_TO_ADDR
// uc_nation := 2 ;
108954: LD_ADDR_OWVAR 21
108958: PUSH
108959: LD_INT 2
108961: ST_TO_ADDR
// hc_name := Dark Warrior ;
108962: LD_ADDR_OWVAR 26
108966: PUSH
108967: LD_STRING Dark Warrior
108969: ST_TO_ADDR
// hc_gallery :=  ;
108970: LD_ADDR_OWVAR 33
108974: PUSH
108975: LD_STRING 
108977: ST_TO_ADDR
// hc_noskilllimit := true ;
108978: LD_ADDR_OWVAR 76
108982: PUSH
108983: LD_INT 1
108985: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
108986: LD_ADDR_OWVAR 31
108990: PUSH
108991: LD_INT 30
108993: PUSH
108994: LD_INT 30
108996: PUSH
108997: LD_INT 30
108999: PUSH
109000: LD_INT 30
109002: PUSH
109003: EMPTY
109004: LIST
109005: LIST
109006: LIST
109007: LIST
109008: ST_TO_ADDR
// un := CreateHuman ;
109009: LD_ADDR_VAR 0 3
109013: PUSH
109014: CALL_OW 44
109018: ST_TO_ADDR
// hc_noskilllimit := false ;
109019: LD_ADDR_OWVAR 76
109023: PUSH
109024: LD_INT 0
109026: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109027: LD_VAR 0 3
109031: PPUSH
109032: LD_INT 1
109034: PPUSH
109035: CALL_OW 51
// ToLua ( playRanger() ) ;
109039: LD_STRING playRanger()
109041: PPUSH
109042: CALL_OW 559
// p := 0 ;
109046: LD_ADDR_VAR 0 2
109050: PUSH
109051: LD_INT 0
109053: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
109054: LD_INT 35
109056: PPUSH
109057: CALL_OW 67
// p := p + 1 ;
109061: LD_ADDR_VAR 0 2
109065: PUSH
109066: LD_VAR 0 2
109070: PUSH
109071: LD_INT 1
109073: PLUS
109074: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
109075: LD_VAR 0 3
109079: PPUSH
109080: CALL_OW 256
109084: PUSH
109085: LD_INT 1000
109087: LESS
109088: IFFALSE 109102
// SetLives ( un , 1000 ) ;
109090: LD_VAR 0 3
109094: PPUSH
109095: LD_INT 1000
109097: PPUSH
109098: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
109102: LD_VAR 0 3
109106: PPUSH
109107: LD_INT 81
109109: PUSH
109110: LD_OWVAR 2
109114: PUSH
109115: EMPTY
109116: LIST
109117: LIST
109118: PUSH
109119: LD_INT 91
109121: PUSH
109122: LD_VAR 0 3
109126: PUSH
109127: LD_INT 30
109129: PUSH
109130: EMPTY
109131: LIST
109132: LIST
109133: LIST
109134: PUSH
109135: EMPTY
109136: LIST
109137: LIST
109138: PPUSH
109139: CALL_OW 69
109143: PPUSH
109144: LD_VAR 0 3
109148: PPUSH
109149: CALL_OW 74
109153: PPUSH
109154: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
109158: LD_VAR 0 2
109162: PUSH
109163: LD_INT 80
109165: GREATER
109166: PUSH
109167: LD_VAR 0 3
109171: PPUSH
109172: CALL_OW 301
109176: OR
109177: IFFALSE 109054
// if un then
109179: LD_VAR 0 3
109183: IFFALSE 109194
// RemoveUnit ( un ) ;
109185: LD_VAR 0 3
109189: PPUSH
109190: CALL_OW 64
// end ;
109194: PPOPN 3
109196: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
109197: LD_EXP 133
109201: IFFALSE 109317
109203: GO 109205
109205: DISABLE
109206: LD_INT 0
109208: PPUSH
109209: PPUSH
109210: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
109211: LD_ADDR_VAR 0 2
109215: PUSH
109216: LD_INT 81
109218: PUSH
109219: LD_OWVAR 2
109223: PUSH
109224: EMPTY
109225: LIST
109226: LIST
109227: PUSH
109228: LD_INT 21
109230: PUSH
109231: LD_INT 1
109233: PUSH
109234: EMPTY
109235: LIST
109236: LIST
109237: PUSH
109238: EMPTY
109239: LIST
109240: LIST
109241: PPUSH
109242: CALL_OW 69
109246: ST_TO_ADDR
// ToLua ( playComputer() ) ;
109247: LD_STRING playComputer()
109249: PPUSH
109250: CALL_OW 559
// if not tmp then
109254: LD_VAR 0 2
109258: NOT
109259: IFFALSE 109263
// exit ;
109261: GO 109317
// for i in tmp do
109263: LD_ADDR_VAR 0 1
109267: PUSH
109268: LD_VAR 0 2
109272: PUSH
109273: FOR_IN
109274: IFFALSE 109315
// for j := 1 to 4 do
109276: LD_ADDR_VAR 0 3
109280: PUSH
109281: DOUBLE
109282: LD_INT 1
109284: DEC
109285: ST_TO_ADDR
109286: LD_INT 4
109288: PUSH
109289: FOR_TO
109290: IFFALSE 109311
// SetSkill ( i , j , 10 ) ;
109292: LD_VAR 0 1
109296: PPUSH
109297: LD_VAR 0 3
109301: PPUSH
109302: LD_INT 10
109304: PPUSH
109305: CALL_OW 237
109309: GO 109289
109311: POP
109312: POP
109313: GO 109273
109315: POP
109316: POP
// end ;
109317: PPOPN 3
109319: END
// every 0 0$1 trigger s30 do var i , tmp ;
109320: LD_EXP 134
109324: IFFALSE 109393
109326: GO 109328
109328: DISABLE
109329: LD_INT 0
109331: PPUSH
109332: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
109333: LD_ADDR_VAR 0 2
109337: PUSH
109338: LD_INT 22
109340: PUSH
109341: LD_OWVAR 2
109345: PUSH
109346: EMPTY
109347: LIST
109348: LIST
109349: PPUSH
109350: CALL_OW 69
109354: ST_TO_ADDR
// if not tmp then
109355: LD_VAR 0 2
109359: NOT
109360: IFFALSE 109364
// exit ;
109362: GO 109393
// for i in tmp do
109364: LD_ADDR_VAR 0 1
109368: PUSH
109369: LD_VAR 0 2
109373: PUSH
109374: FOR_IN
109375: IFFALSE 109391
// SetLives ( i , 300 ) ;
109377: LD_VAR 0 1
109381: PPUSH
109382: LD_INT 300
109384: PPUSH
109385: CALL_OW 234
109389: GO 109374
109391: POP
109392: POP
// end ;
109393: PPOPN 2
109395: END
// every 0 0$1 trigger s60 do var i , tmp ;
109396: LD_EXP 135
109400: IFFALSE 109469
109402: GO 109404
109404: DISABLE
109405: LD_INT 0
109407: PPUSH
109408: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
109409: LD_ADDR_VAR 0 2
109413: PUSH
109414: LD_INT 22
109416: PUSH
109417: LD_OWVAR 2
109421: PUSH
109422: EMPTY
109423: LIST
109424: LIST
109425: PPUSH
109426: CALL_OW 69
109430: ST_TO_ADDR
// if not tmp then
109431: LD_VAR 0 2
109435: NOT
109436: IFFALSE 109440
// exit ;
109438: GO 109469
// for i in tmp do
109440: LD_ADDR_VAR 0 1
109444: PUSH
109445: LD_VAR 0 2
109449: PUSH
109450: FOR_IN
109451: IFFALSE 109467
// SetLives ( i , 600 ) ;
109453: LD_VAR 0 1
109457: PPUSH
109458: LD_INT 600
109460: PPUSH
109461: CALL_OW 234
109465: GO 109450
109467: POP
109468: POP
// end ;
109469: PPOPN 2
109471: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
109472: LD_INT 0
109474: PPUSH
// case cmd of 301 :
109475: LD_VAR 0 1
109479: PUSH
109480: LD_INT 301
109482: DOUBLE
109483: EQUAL
109484: IFTRUE 109488
109486: GO 109520
109488: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
109489: LD_VAR 0 6
109493: PPUSH
109494: LD_VAR 0 7
109498: PPUSH
109499: LD_VAR 0 8
109503: PPUSH
109504: LD_VAR 0 4
109508: PPUSH
109509: LD_VAR 0 5
109513: PPUSH
109514: CALL 110729 0 5
109518: GO 109641
109520: LD_INT 302
109522: DOUBLE
109523: EQUAL
109524: IFTRUE 109528
109526: GO 109565
109528: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
109529: LD_VAR 0 6
109533: PPUSH
109534: LD_VAR 0 7
109538: PPUSH
109539: LD_VAR 0 8
109543: PPUSH
109544: LD_VAR 0 9
109548: PPUSH
109549: LD_VAR 0 4
109553: PPUSH
109554: LD_VAR 0 5
109558: PPUSH
109559: CALL 110820 0 6
109563: GO 109641
109565: LD_INT 303
109567: DOUBLE
109568: EQUAL
109569: IFTRUE 109573
109571: GO 109610
109573: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
109574: LD_VAR 0 6
109578: PPUSH
109579: LD_VAR 0 7
109583: PPUSH
109584: LD_VAR 0 8
109588: PPUSH
109589: LD_VAR 0 9
109593: PPUSH
109594: LD_VAR 0 4
109598: PPUSH
109599: LD_VAR 0 5
109603: PPUSH
109604: CALL 109646 0 6
109608: GO 109641
109610: LD_INT 304
109612: DOUBLE
109613: EQUAL
109614: IFTRUE 109618
109616: GO 109640
109618: POP
// hHackTeleport ( unit , x , y ) ; end ;
109619: LD_VAR 0 2
109623: PPUSH
109624: LD_VAR 0 4
109628: PPUSH
109629: LD_VAR 0 5
109633: PPUSH
109634: CALL 111413 0 3
109638: GO 109641
109640: POP
// end ;
109641: LD_VAR 0 12
109645: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
109646: LD_INT 0
109648: PPUSH
109649: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
109650: LD_VAR 0 1
109654: PUSH
109655: LD_INT 1
109657: LESS
109658: PUSH
109659: LD_VAR 0 1
109663: PUSH
109664: LD_INT 3
109666: GREATER
109667: OR
109668: PUSH
109669: LD_VAR 0 5
109673: PPUSH
109674: LD_VAR 0 6
109678: PPUSH
109679: CALL_OW 428
109683: OR
109684: IFFALSE 109688
// exit ;
109686: GO 110416
// uc_side := your_side ;
109688: LD_ADDR_OWVAR 20
109692: PUSH
109693: LD_OWVAR 2
109697: ST_TO_ADDR
// uc_nation := nation ;
109698: LD_ADDR_OWVAR 21
109702: PUSH
109703: LD_VAR 0 1
109707: ST_TO_ADDR
// bc_level = 1 ;
109708: LD_ADDR_OWVAR 43
109712: PUSH
109713: LD_INT 1
109715: ST_TO_ADDR
// case btype of 1 :
109716: LD_VAR 0 2
109720: PUSH
109721: LD_INT 1
109723: DOUBLE
109724: EQUAL
109725: IFTRUE 109729
109727: GO 109740
109729: POP
// bc_type := b_depot ; 2 :
109730: LD_ADDR_OWVAR 42
109734: PUSH
109735: LD_INT 0
109737: ST_TO_ADDR
109738: GO 110360
109740: LD_INT 2
109742: DOUBLE
109743: EQUAL
109744: IFTRUE 109748
109746: GO 109759
109748: POP
// bc_type := b_warehouse ; 3 :
109749: LD_ADDR_OWVAR 42
109753: PUSH
109754: LD_INT 1
109756: ST_TO_ADDR
109757: GO 110360
109759: LD_INT 3
109761: DOUBLE
109762: EQUAL
109763: IFTRUE 109767
109765: GO 109778
109767: POP
// bc_type := b_lab ; 4 .. 9 :
109768: LD_ADDR_OWVAR 42
109772: PUSH
109773: LD_INT 6
109775: ST_TO_ADDR
109776: GO 110360
109778: LD_INT 4
109780: DOUBLE
109781: GREATEREQUAL
109782: IFFALSE 109790
109784: LD_INT 9
109786: DOUBLE
109787: LESSEQUAL
109788: IFTRUE 109792
109790: GO 109852
109792: POP
// begin bc_type := b_lab_half ;
109793: LD_ADDR_OWVAR 42
109797: PUSH
109798: LD_INT 7
109800: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
109801: LD_ADDR_OWVAR 44
109805: PUSH
109806: LD_INT 10
109808: PUSH
109809: LD_INT 11
109811: PUSH
109812: LD_INT 12
109814: PUSH
109815: LD_INT 15
109817: PUSH
109818: LD_INT 14
109820: PUSH
109821: LD_INT 13
109823: PUSH
109824: EMPTY
109825: LIST
109826: LIST
109827: LIST
109828: LIST
109829: LIST
109830: LIST
109831: PUSH
109832: LD_VAR 0 2
109836: PUSH
109837: LD_INT 3
109839: MINUS
109840: ARRAY
109841: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
109842: LD_ADDR_OWVAR 45
109846: PUSH
109847: LD_INT 9
109849: ST_TO_ADDR
// end ; 10 .. 13 :
109850: GO 110360
109852: LD_INT 10
109854: DOUBLE
109855: GREATEREQUAL
109856: IFFALSE 109864
109858: LD_INT 13
109860: DOUBLE
109861: LESSEQUAL
109862: IFTRUE 109866
109864: GO 109943
109866: POP
// begin bc_type := b_lab_full ;
109867: LD_ADDR_OWVAR 42
109871: PUSH
109872: LD_INT 8
109874: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
109875: LD_ADDR_OWVAR 44
109879: PUSH
109880: LD_INT 10
109882: PUSH
109883: LD_INT 12
109885: PUSH
109886: LD_INT 14
109888: PUSH
109889: LD_INT 13
109891: PUSH
109892: EMPTY
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: PUSH
109898: LD_VAR 0 2
109902: PUSH
109903: LD_INT 9
109905: MINUS
109906: ARRAY
109907: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
109908: LD_ADDR_OWVAR 45
109912: PUSH
109913: LD_INT 11
109915: PUSH
109916: LD_INT 15
109918: PUSH
109919: LD_INT 12
109921: PUSH
109922: LD_INT 15
109924: PUSH
109925: EMPTY
109926: LIST
109927: LIST
109928: LIST
109929: LIST
109930: PUSH
109931: LD_VAR 0 2
109935: PUSH
109936: LD_INT 9
109938: MINUS
109939: ARRAY
109940: ST_TO_ADDR
// end ; 14 :
109941: GO 110360
109943: LD_INT 14
109945: DOUBLE
109946: EQUAL
109947: IFTRUE 109951
109949: GO 109962
109951: POP
// bc_type := b_workshop ; 15 :
109952: LD_ADDR_OWVAR 42
109956: PUSH
109957: LD_INT 2
109959: ST_TO_ADDR
109960: GO 110360
109962: LD_INT 15
109964: DOUBLE
109965: EQUAL
109966: IFTRUE 109970
109968: GO 109981
109970: POP
// bc_type := b_factory ; 16 :
109971: LD_ADDR_OWVAR 42
109975: PUSH
109976: LD_INT 3
109978: ST_TO_ADDR
109979: GO 110360
109981: LD_INT 16
109983: DOUBLE
109984: EQUAL
109985: IFTRUE 109989
109987: GO 110000
109989: POP
// bc_type := b_ext_gun ; 17 :
109990: LD_ADDR_OWVAR 42
109994: PUSH
109995: LD_INT 17
109997: ST_TO_ADDR
109998: GO 110360
110000: LD_INT 17
110002: DOUBLE
110003: EQUAL
110004: IFTRUE 110008
110006: GO 110036
110008: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
110009: LD_ADDR_OWVAR 42
110013: PUSH
110014: LD_INT 19
110016: PUSH
110017: LD_INT 23
110019: PUSH
110020: LD_INT 19
110022: PUSH
110023: EMPTY
110024: LIST
110025: LIST
110026: LIST
110027: PUSH
110028: LD_VAR 0 1
110032: ARRAY
110033: ST_TO_ADDR
110034: GO 110360
110036: LD_INT 18
110038: DOUBLE
110039: EQUAL
110040: IFTRUE 110044
110042: GO 110055
110044: POP
// bc_type := b_ext_radar ; 19 :
110045: LD_ADDR_OWVAR 42
110049: PUSH
110050: LD_INT 20
110052: ST_TO_ADDR
110053: GO 110360
110055: LD_INT 19
110057: DOUBLE
110058: EQUAL
110059: IFTRUE 110063
110061: GO 110074
110063: POP
// bc_type := b_ext_radio ; 20 :
110064: LD_ADDR_OWVAR 42
110068: PUSH
110069: LD_INT 22
110071: ST_TO_ADDR
110072: GO 110360
110074: LD_INT 20
110076: DOUBLE
110077: EQUAL
110078: IFTRUE 110082
110080: GO 110093
110082: POP
// bc_type := b_ext_siberium ; 21 :
110083: LD_ADDR_OWVAR 42
110087: PUSH
110088: LD_INT 21
110090: ST_TO_ADDR
110091: GO 110360
110093: LD_INT 21
110095: DOUBLE
110096: EQUAL
110097: IFTRUE 110101
110099: GO 110112
110101: POP
// bc_type := b_ext_computer ; 22 :
110102: LD_ADDR_OWVAR 42
110106: PUSH
110107: LD_INT 24
110109: ST_TO_ADDR
110110: GO 110360
110112: LD_INT 22
110114: DOUBLE
110115: EQUAL
110116: IFTRUE 110120
110118: GO 110131
110120: POP
// bc_type := b_ext_track ; 23 :
110121: LD_ADDR_OWVAR 42
110125: PUSH
110126: LD_INT 16
110128: ST_TO_ADDR
110129: GO 110360
110131: LD_INT 23
110133: DOUBLE
110134: EQUAL
110135: IFTRUE 110139
110137: GO 110150
110139: POP
// bc_type := b_ext_laser ; 24 :
110140: LD_ADDR_OWVAR 42
110144: PUSH
110145: LD_INT 25
110147: ST_TO_ADDR
110148: GO 110360
110150: LD_INT 24
110152: DOUBLE
110153: EQUAL
110154: IFTRUE 110158
110156: GO 110169
110158: POP
// bc_type := b_control_tower ; 25 :
110159: LD_ADDR_OWVAR 42
110163: PUSH
110164: LD_INT 36
110166: ST_TO_ADDR
110167: GO 110360
110169: LD_INT 25
110171: DOUBLE
110172: EQUAL
110173: IFTRUE 110177
110175: GO 110188
110177: POP
// bc_type := b_breastwork ; 26 :
110178: LD_ADDR_OWVAR 42
110182: PUSH
110183: LD_INT 31
110185: ST_TO_ADDR
110186: GO 110360
110188: LD_INT 26
110190: DOUBLE
110191: EQUAL
110192: IFTRUE 110196
110194: GO 110207
110196: POP
// bc_type := b_bunker ; 27 :
110197: LD_ADDR_OWVAR 42
110201: PUSH
110202: LD_INT 32
110204: ST_TO_ADDR
110205: GO 110360
110207: LD_INT 27
110209: DOUBLE
110210: EQUAL
110211: IFTRUE 110215
110213: GO 110226
110215: POP
// bc_type := b_turret ; 28 :
110216: LD_ADDR_OWVAR 42
110220: PUSH
110221: LD_INT 33
110223: ST_TO_ADDR
110224: GO 110360
110226: LD_INT 28
110228: DOUBLE
110229: EQUAL
110230: IFTRUE 110234
110232: GO 110245
110234: POP
// bc_type := b_armoury ; 29 :
110235: LD_ADDR_OWVAR 42
110239: PUSH
110240: LD_INT 4
110242: ST_TO_ADDR
110243: GO 110360
110245: LD_INT 29
110247: DOUBLE
110248: EQUAL
110249: IFTRUE 110253
110251: GO 110264
110253: POP
// bc_type := b_barracks ; 30 :
110254: LD_ADDR_OWVAR 42
110258: PUSH
110259: LD_INT 5
110261: ST_TO_ADDR
110262: GO 110360
110264: LD_INT 30
110266: DOUBLE
110267: EQUAL
110268: IFTRUE 110272
110270: GO 110283
110272: POP
// bc_type := b_solar_power ; 31 :
110273: LD_ADDR_OWVAR 42
110277: PUSH
110278: LD_INT 27
110280: ST_TO_ADDR
110281: GO 110360
110283: LD_INT 31
110285: DOUBLE
110286: EQUAL
110287: IFTRUE 110291
110289: GO 110302
110291: POP
// bc_type := b_oil_power ; 32 :
110292: LD_ADDR_OWVAR 42
110296: PUSH
110297: LD_INT 26
110299: ST_TO_ADDR
110300: GO 110360
110302: LD_INT 32
110304: DOUBLE
110305: EQUAL
110306: IFTRUE 110310
110308: GO 110321
110310: POP
// bc_type := b_siberite_power ; 33 :
110311: LD_ADDR_OWVAR 42
110315: PUSH
110316: LD_INT 28
110318: ST_TO_ADDR
110319: GO 110360
110321: LD_INT 33
110323: DOUBLE
110324: EQUAL
110325: IFTRUE 110329
110327: GO 110340
110329: POP
// bc_type := b_oil_mine ; 34 :
110330: LD_ADDR_OWVAR 42
110334: PUSH
110335: LD_INT 29
110337: ST_TO_ADDR
110338: GO 110360
110340: LD_INT 34
110342: DOUBLE
110343: EQUAL
110344: IFTRUE 110348
110346: GO 110359
110348: POP
// bc_type := b_siberite_mine ; end ;
110349: LD_ADDR_OWVAR 42
110353: PUSH
110354: LD_INT 30
110356: ST_TO_ADDR
110357: GO 110360
110359: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
110360: LD_ADDR_VAR 0 8
110364: PUSH
110365: LD_VAR 0 5
110369: PPUSH
110370: LD_VAR 0 6
110374: PPUSH
110375: LD_VAR 0 3
110379: PPUSH
110380: CALL_OW 47
110384: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
110385: LD_OWVAR 42
110389: PUSH
110390: LD_INT 32
110392: PUSH
110393: LD_INT 33
110395: PUSH
110396: EMPTY
110397: LIST
110398: LIST
110399: IN
110400: IFFALSE 110416
// PlaceWeaponTurret ( b , weapon ) ;
110402: LD_VAR 0 8
110406: PPUSH
110407: LD_VAR 0 4
110411: PPUSH
110412: CALL_OW 431
// end ;
110416: LD_VAR 0 7
110420: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
110421: LD_INT 0
110423: PPUSH
110424: PPUSH
110425: PPUSH
110426: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
110427: LD_ADDR_VAR 0 4
110431: PUSH
110432: LD_INT 22
110434: PUSH
110435: LD_OWVAR 2
110439: PUSH
110440: EMPTY
110441: LIST
110442: LIST
110443: PUSH
110444: LD_INT 2
110446: PUSH
110447: LD_INT 30
110449: PUSH
110450: LD_INT 0
110452: PUSH
110453: EMPTY
110454: LIST
110455: LIST
110456: PUSH
110457: LD_INT 30
110459: PUSH
110460: LD_INT 1
110462: PUSH
110463: EMPTY
110464: LIST
110465: LIST
110466: PUSH
110467: EMPTY
110468: LIST
110469: LIST
110470: LIST
110471: PUSH
110472: EMPTY
110473: LIST
110474: LIST
110475: PPUSH
110476: CALL_OW 69
110480: ST_TO_ADDR
// if not tmp then
110481: LD_VAR 0 4
110485: NOT
110486: IFFALSE 110490
// exit ;
110488: GO 110549
// for i in tmp do
110490: LD_ADDR_VAR 0 2
110494: PUSH
110495: LD_VAR 0 4
110499: PUSH
110500: FOR_IN
110501: IFFALSE 110547
// for j = 1 to 3 do
110503: LD_ADDR_VAR 0 3
110507: PUSH
110508: DOUBLE
110509: LD_INT 1
110511: DEC
110512: ST_TO_ADDR
110513: LD_INT 3
110515: PUSH
110516: FOR_TO
110517: IFFALSE 110543
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
110519: LD_VAR 0 2
110523: PPUSH
110524: CALL_OW 274
110528: PPUSH
110529: LD_VAR 0 3
110533: PPUSH
110534: LD_INT 99999
110536: PPUSH
110537: CALL_OW 277
110541: GO 110516
110543: POP
110544: POP
110545: GO 110500
110547: POP
110548: POP
// end ;
110549: LD_VAR 0 1
110553: RET
// export function hHackSetLevel10 ; var i , j ; begin
110554: LD_INT 0
110556: PPUSH
110557: PPUSH
110558: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
110559: LD_ADDR_VAR 0 2
110563: PUSH
110564: LD_INT 21
110566: PUSH
110567: LD_INT 1
110569: PUSH
110570: EMPTY
110571: LIST
110572: LIST
110573: PPUSH
110574: CALL_OW 69
110578: PUSH
110579: FOR_IN
110580: IFFALSE 110632
// if IsSelected ( i ) then
110582: LD_VAR 0 2
110586: PPUSH
110587: CALL_OW 306
110591: IFFALSE 110630
// begin for j := 1 to 4 do
110593: LD_ADDR_VAR 0 3
110597: PUSH
110598: DOUBLE
110599: LD_INT 1
110601: DEC
110602: ST_TO_ADDR
110603: LD_INT 4
110605: PUSH
110606: FOR_TO
110607: IFFALSE 110628
// SetSkill ( i , j , 10 ) ;
110609: LD_VAR 0 2
110613: PPUSH
110614: LD_VAR 0 3
110618: PPUSH
110619: LD_INT 10
110621: PPUSH
110622: CALL_OW 237
110626: GO 110606
110628: POP
110629: POP
// end ;
110630: GO 110579
110632: POP
110633: POP
// end ;
110634: LD_VAR 0 1
110638: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
110639: LD_INT 0
110641: PPUSH
110642: PPUSH
110643: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
110644: LD_ADDR_VAR 0 2
110648: PUSH
110649: LD_INT 22
110651: PUSH
110652: LD_OWVAR 2
110656: PUSH
110657: EMPTY
110658: LIST
110659: LIST
110660: PUSH
110661: LD_INT 21
110663: PUSH
110664: LD_INT 1
110666: PUSH
110667: EMPTY
110668: LIST
110669: LIST
110670: PUSH
110671: EMPTY
110672: LIST
110673: LIST
110674: PPUSH
110675: CALL_OW 69
110679: PUSH
110680: FOR_IN
110681: IFFALSE 110722
// begin for j := 1 to 4 do
110683: LD_ADDR_VAR 0 3
110687: PUSH
110688: DOUBLE
110689: LD_INT 1
110691: DEC
110692: ST_TO_ADDR
110693: LD_INT 4
110695: PUSH
110696: FOR_TO
110697: IFFALSE 110718
// SetSkill ( i , j , 10 ) ;
110699: LD_VAR 0 2
110703: PPUSH
110704: LD_VAR 0 3
110708: PPUSH
110709: LD_INT 10
110711: PPUSH
110712: CALL_OW 237
110716: GO 110696
110718: POP
110719: POP
// end ;
110720: GO 110680
110722: POP
110723: POP
// end ;
110724: LD_VAR 0 1
110728: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
110729: LD_INT 0
110731: PPUSH
// uc_side := your_side ;
110732: LD_ADDR_OWVAR 20
110736: PUSH
110737: LD_OWVAR 2
110741: ST_TO_ADDR
// uc_nation := nation ;
110742: LD_ADDR_OWVAR 21
110746: PUSH
110747: LD_VAR 0 1
110751: ST_TO_ADDR
// InitHc ;
110752: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
110756: LD_INT 0
110758: PPUSH
110759: LD_VAR 0 2
110763: PPUSH
110764: LD_VAR 0 3
110768: PPUSH
110769: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
110773: LD_VAR 0 4
110777: PPUSH
110778: LD_VAR 0 5
110782: PPUSH
110783: CALL_OW 428
110787: PUSH
110788: LD_INT 0
110790: EQUAL
110791: IFFALSE 110815
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
110793: CALL_OW 44
110797: PPUSH
110798: LD_VAR 0 4
110802: PPUSH
110803: LD_VAR 0 5
110807: PPUSH
110808: LD_INT 1
110810: PPUSH
110811: CALL_OW 48
// end ;
110815: LD_VAR 0 6
110819: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
110820: LD_INT 0
110822: PPUSH
110823: PPUSH
// uc_side := your_side ;
110824: LD_ADDR_OWVAR 20
110828: PUSH
110829: LD_OWVAR 2
110833: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
110834: LD_VAR 0 1
110838: PUSH
110839: LD_INT 1
110841: PUSH
110842: LD_INT 2
110844: PUSH
110845: LD_INT 3
110847: PUSH
110848: LD_INT 4
110850: PUSH
110851: LD_INT 5
110853: PUSH
110854: EMPTY
110855: LIST
110856: LIST
110857: LIST
110858: LIST
110859: LIST
110860: IN
110861: IFFALSE 110873
// uc_nation := nation_american else
110863: LD_ADDR_OWVAR 21
110867: PUSH
110868: LD_INT 1
110870: ST_TO_ADDR
110871: GO 110916
// if chassis in [ 11 , 12 , 13 , 14 ] then
110873: LD_VAR 0 1
110877: PUSH
110878: LD_INT 11
110880: PUSH
110881: LD_INT 12
110883: PUSH
110884: LD_INT 13
110886: PUSH
110887: LD_INT 14
110889: PUSH
110890: EMPTY
110891: LIST
110892: LIST
110893: LIST
110894: LIST
110895: IN
110896: IFFALSE 110908
// uc_nation := nation_arabian else
110898: LD_ADDR_OWVAR 21
110902: PUSH
110903: LD_INT 2
110905: ST_TO_ADDR
110906: GO 110916
// uc_nation := nation_russian ;
110908: LD_ADDR_OWVAR 21
110912: PUSH
110913: LD_INT 3
110915: ST_TO_ADDR
// vc_chassis := chassis ;
110916: LD_ADDR_OWVAR 37
110920: PUSH
110921: LD_VAR 0 1
110925: ST_TO_ADDR
// vc_engine := engine ;
110926: LD_ADDR_OWVAR 39
110930: PUSH
110931: LD_VAR 0 2
110935: ST_TO_ADDR
// vc_control := control ;
110936: LD_ADDR_OWVAR 38
110940: PUSH
110941: LD_VAR 0 3
110945: ST_TO_ADDR
// vc_weapon := weapon ;
110946: LD_ADDR_OWVAR 40
110950: PUSH
110951: LD_VAR 0 4
110955: ST_TO_ADDR
// un := CreateVehicle ;
110956: LD_ADDR_VAR 0 8
110960: PUSH
110961: CALL_OW 45
110965: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
110966: LD_VAR 0 8
110970: PPUSH
110971: LD_INT 0
110973: PPUSH
110974: LD_INT 5
110976: PPUSH
110977: CALL_OW 12
110981: PPUSH
110982: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
110986: LD_VAR 0 8
110990: PPUSH
110991: LD_VAR 0 5
110995: PPUSH
110996: LD_VAR 0 6
111000: PPUSH
111001: LD_INT 1
111003: PPUSH
111004: CALL_OW 48
// end ;
111008: LD_VAR 0 7
111012: RET
// export hInvincible ; every 1 do
111013: GO 111015
111015: DISABLE
// hInvincible := [ ] ;
111016: LD_ADDR_EXP 136
111020: PUSH
111021: EMPTY
111022: ST_TO_ADDR
111023: END
// every 10 do var i ;
111024: GO 111026
111026: DISABLE
111027: LD_INT 0
111029: PPUSH
// begin enable ;
111030: ENABLE
// if not hInvincible then
111031: LD_EXP 136
111035: NOT
111036: IFFALSE 111040
// exit ;
111038: GO 111084
// for i in hInvincible do
111040: LD_ADDR_VAR 0 1
111044: PUSH
111045: LD_EXP 136
111049: PUSH
111050: FOR_IN
111051: IFFALSE 111082
// if GetLives ( i ) < 1000 then
111053: LD_VAR 0 1
111057: PPUSH
111058: CALL_OW 256
111062: PUSH
111063: LD_INT 1000
111065: LESS
111066: IFFALSE 111080
// SetLives ( i , 1000 ) ;
111068: LD_VAR 0 1
111072: PPUSH
111073: LD_INT 1000
111075: PPUSH
111076: CALL_OW 234
111080: GO 111050
111082: POP
111083: POP
// end ;
111084: PPOPN 1
111086: END
// export function hHackInvincible ; var i ; begin
111087: LD_INT 0
111089: PPUSH
111090: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
111091: LD_ADDR_VAR 0 2
111095: PUSH
111096: LD_INT 2
111098: PUSH
111099: LD_INT 21
111101: PUSH
111102: LD_INT 1
111104: PUSH
111105: EMPTY
111106: LIST
111107: LIST
111108: PUSH
111109: LD_INT 21
111111: PUSH
111112: LD_INT 2
111114: PUSH
111115: EMPTY
111116: LIST
111117: LIST
111118: PUSH
111119: EMPTY
111120: LIST
111121: LIST
111122: LIST
111123: PPUSH
111124: CALL_OW 69
111128: PUSH
111129: FOR_IN
111130: IFFALSE 111191
// if IsSelected ( i ) then
111132: LD_VAR 0 2
111136: PPUSH
111137: CALL_OW 306
111141: IFFALSE 111189
// begin if i in hInvincible then
111143: LD_VAR 0 2
111147: PUSH
111148: LD_EXP 136
111152: IN
111153: IFFALSE 111173
// hInvincible := hInvincible diff i else
111155: LD_ADDR_EXP 136
111159: PUSH
111160: LD_EXP 136
111164: PUSH
111165: LD_VAR 0 2
111169: DIFF
111170: ST_TO_ADDR
111171: GO 111189
// hInvincible := hInvincible union i ;
111173: LD_ADDR_EXP 136
111177: PUSH
111178: LD_EXP 136
111182: PUSH
111183: LD_VAR 0 2
111187: UNION
111188: ST_TO_ADDR
// end ;
111189: GO 111129
111191: POP
111192: POP
// end ;
111193: LD_VAR 0 1
111197: RET
// export function hHackInvisible ; var i , j ; begin
111198: LD_INT 0
111200: PPUSH
111201: PPUSH
111202: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
111203: LD_ADDR_VAR 0 2
111207: PUSH
111208: LD_INT 21
111210: PUSH
111211: LD_INT 1
111213: PUSH
111214: EMPTY
111215: LIST
111216: LIST
111217: PPUSH
111218: CALL_OW 69
111222: PUSH
111223: FOR_IN
111224: IFFALSE 111248
// if IsSelected ( i ) then
111226: LD_VAR 0 2
111230: PPUSH
111231: CALL_OW 306
111235: IFFALSE 111246
// ComForceInvisible ( i ) ;
111237: LD_VAR 0 2
111241: PPUSH
111242: CALL_OW 496
111246: GO 111223
111248: POP
111249: POP
// end ;
111250: LD_VAR 0 1
111254: RET
// export function hHackChangeYourSide ; begin
111255: LD_INT 0
111257: PPUSH
// if your_side = 8 then
111258: LD_OWVAR 2
111262: PUSH
111263: LD_INT 8
111265: EQUAL
111266: IFFALSE 111278
// your_side := 0 else
111268: LD_ADDR_OWVAR 2
111272: PUSH
111273: LD_INT 0
111275: ST_TO_ADDR
111276: GO 111292
// your_side := your_side + 1 ;
111278: LD_ADDR_OWVAR 2
111282: PUSH
111283: LD_OWVAR 2
111287: PUSH
111288: LD_INT 1
111290: PLUS
111291: ST_TO_ADDR
// end ;
111292: LD_VAR 0 1
111296: RET
// export function hHackChangeUnitSide ; var i , j ; begin
111297: LD_INT 0
111299: PPUSH
111300: PPUSH
111301: PPUSH
// for i in all_units do
111302: LD_ADDR_VAR 0 2
111306: PUSH
111307: LD_OWVAR 3
111311: PUSH
111312: FOR_IN
111313: IFFALSE 111391
// if IsSelected ( i ) then
111315: LD_VAR 0 2
111319: PPUSH
111320: CALL_OW 306
111324: IFFALSE 111389
// begin j := GetSide ( i ) ;
111326: LD_ADDR_VAR 0 3
111330: PUSH
111331: LD_VAR 0 2
111335: PPUSH
111336: CALL_OW 255
111340: ST_TO_ADDR
// if j = 8 then
111341: LD_VAR 0 3
111345: PUSH
111346: LD_INT 8
111348: EQUAL
111349: IFFALSE 111361
// j := 0 else
111351: LD_ADDR_VAR 0 3
111355: PUSH
111356: LD_INT 0
111358: ST_TO_ADDR
111359: GO 111375
// j := j + 1 ;
111361: LD_ADDR_VAR 0 3
111365: PUSH
111366: LD_VAR 0 3
111370: PUSH
111371: LD_INT 1
111373: PLUS
111374: ST_TO_ADDR
// SetSide ( i , j ) ;
111375: LD_VAR 0 2
111379: PPUSH
111380: LD_VAR 0 3
111384: PPUSH
111385: CALL_OW 235
// end ;
111389: GO 111312
111391: POP
111392: POP
// end ;
111393: LD_VAR 0 1
111397: RET
// export function hHackFog ; begin
111398: LD_INT 0
111400: PPUSH
// FogOff ( true ) ;
111401: LD_INT 1
111403: PPUSH
111404: CALL_OW 344
// end ;
111408: LD_VAR 0 1
111412: RET
// export function hHackTeleport ( unit , x , y ) ; begin
111413: LD_INT 0
111415: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
111416: LD_VAR 0 1
111420: PPUSH
111421: LD_VAR 0 2
111425: PPUSH
111426: LD_VAR 0 3
111430: PPUSH
111431: LD_INT 1
111433: PPUSH
111434: LD_INT 1
111436: PPUSH
111437: CALL_OW 483
// CenterOnXY ( x , y ) ;
111441: LD_VAR 0 2
111445: PPUSH
111446: LD_VAR 0 3
111450: PPUSH
111451: CALL_OW 84
// end ;
111455: LD_VAR 0 4
111459: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
111460: LD_INT 0
111462: PPUSH
111463: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
111464: LD_VAR 0 1
111468: NOT
111469: PUSH
111470: LD_VAR 0 2
111474: PPUSH
111475: LD_VAR 0 3
111479: PPUSH
111480: CALL_OW 488
111484: NOT
111485: OR
111486: PUSH
111487: LD_VAR 0 1
111491: PPUSH
111492: CALL_OW 266
111496: PUSH
111497: LD_INT 3
111499: NONEQUAL
111500: PUSH
111501: LD_VAR 0 1
111505: PPUSH
111506: CALL_OW 247
111510: PUSH
111511: LD_INT 1
111513: EQUAL
111514: NOT
111515: AND
111516: OR
111517: IFFALSE 111521
// exit ;
111519: GO 111670
// if GetType ( factory ) = unit_human then
111521: LD_VAR 0 1
111525: PPUSH
111526: CALL_OW 247
111530: PUSH
111531: LD_INT 1
111533: EQUAL
111534: IFFALSE 111551
// factory := IsInUnit ( factory ) ;
111536: LD_ADDR_VAR 0 1
111540: PUSH
111541: LD_VAR 0 1
111545: PPUSH
111546: CALL_OW 310
111550: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
111551: LD_VAR 0 1
111555: PPUSH
111556: CALL_OW 266
111560: PUSH
111561: LD_INT 3
111563: NONEQUAL
111564: IFFALSE 111568
// exit ;
111566: GO 111670
// if HexInfo ( x , y ) = factory then
111568: LD_VAR 0 2
111572: PPUSH
111573: LD_VAR 0 3
111577: PPUSH
111578: CALL_OW 428
111582: PUSH
111583: LD_VAR 0 1
111587: EQUAL
111588: IFFALSE 111615
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
111590: LD_ADDR_EXP 137
111594: PUSH
111595: LD_EXP 137
111599: PPUSH
111600: LD_VAR 0 1
111604: PPUSH
111605: LD_INT 0
111607: PPUSH
111608: CALL_OW 1
111612: ST_TO_ADDR
111613: GO 111666
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
111615: LD_ADDR_EXP 137
111619: PUSH
111620: LD_EXP 137
111624: PPUSH
111625: LD_VAR 0 1
111629: PPUSH
111630: LD_VAR 0 1
111634: PPUSH
111635: CALL_OW 255
111639: PUSH
111640: LD_VAR 0 1
111644: PUSH
111645: LD_VAR 0 2
111649: PUSH
111650: LD_VAR 0 3
111654: PUSH
111655: EMPTY
111656: LIST
111657: LIST
111658: LIST
111659: LIST
111660: PPUSH
111661: CALL_OW 1
111665: ST_TO_ADDR
// UpdateFactoryWaypoints ;
111666: CALL 111675 0 0
// end ;
111670: LD_VAR 0 4
111674: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
111675: LD_INT 0
111677: PPUSH
111678: PPUSH
111679: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
111680: LD_STRING resetFactoryWaypoint();
111682: PPUSH
111683: CALL_OW 559
// if factoryWaypoints then
111687: LD_EXP 137
111691: IFFALSE 111817
// begin list := PrepareArray ( factoryWaypoints ) ;
111693: LD_ADDR_VAR 0 3
111697: PUSH
111698: LD_EXP 137
111702: PPUSH
111703: CALL 52564 0 1
111707: ST_TO_ADDR
// for i := 1 to list do
111708: LD_ADDR_VAR 0 2
111712: PUSH
111713: DOUBLE
111714: LD_INT 1
111716: DEC
111717: ST_TO_ADDR
111718: LD_VAR 0 3
111722: PUSH
111723: FOR_TO
111724: IFFALSE 111815
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111726: LD_STRING setFactoryWaypointXY(
111728: PUSH
111729: LD_VAR 0 3
111733: PUSH
111734: LD_VAR 0 2
111738: ARRAY
111739: PUSH
111740: LD_INT 1
111742: ARRAY
111743: STR
111744: PUSH
111745: LD_STRING ,
111747: STR
111748: PUSH
111749: LD_VAR 0 3
111753: PUSH
111754: LD_VAR 0 2
111758: ARRAY
111759: PUSH
111760: LD_INT 2
111762: ARRAY
111763: STR
111764: PUSH
111765: LD_STRING ,
111767: STR
111768: PUSH
111769: LD_VAR 0 3
111773: PUSH
111774: LD_VAR 0 2
111778: ARRAY
111779: PUSH
111780: LD_INT 3
111782: ARRAY
111783: STR
111784: PUSH
111785: LD_STRING ,
111787: STR
111788: PUSH
111789: LD_VAR 0 3
111793: PUSH
111794: LD_VAR 0 2
111798: ARRAY
111799: PUSH
111800: LD_INT 4
111802: ARRAY
111803: STR
111804: PUSH
111805: LD_STRING )
111807: STR
111808: PPUSH
111809: CALL_OW 559
111813: GO 111723
111815: POP
111816: POP
// end ; end ;
111817: LD_VAR 0 1
111821: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
111822: LD_INT 0
111824: PPUSH
// if HexInfo ( x , y ) = warehouse then
111825: LD_VAR 0 2
111829: PPUSH
111830: LD_VAR 0 3
111834: PPUSH
111835: CALL_OW 428
111839: PUSH
111840: LD_VAR 0 1
111844: EQUAL
111845: IFFALSE 111872
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
111847: LD_ADDR_EXP 138
111851: PUSH
111852: LD_EXP 138
111856: PPUSH
111857: LD_VAR 0 1
111861: PPUSH
111862: LD_INT 0
111864: PPUSH
111865: CALL_OW 1
111869: ST_TO_ADDR
111870: GO 111923
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
111872: LD_ADDR_EXP 138
111876: PUSH
111877: LD_EXP 138
111881: PPUSH
111882: LD_VAR 0 1
111886: PPUSH
111887: LD_VAR 0 1
111891: PPUSH
111892: CALL_OW 255
111896: PUSH
111897: LD_VAR 0 1
111901: PUSH
111902: LD_VAR 0 2
111906: PUSH
111907: LD_VAR 0 3
111911: PUSH
111912: EMPTY
111913: LIST
111914: LIST
111915: LIST
111916: LIST
111917: PPUSH
111918: CALL_OW 1
111922: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
111923: CALL 111932 0 0
// end ;
111927: LD_VAR 0 4
111931: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
111932: LD_INT 0
111934: PPUSH
111935: PPUSH
111936: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
111937: LD_STRING resetWarehouseGatheringPoints();
111939: PPUSH
111940: CALL_OW 559
// if warehouseGatheringPoints then
111944: LD_EXP 138
111948: IFFALSE 112074
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
111950: LD_ADDR_VAR 0 3
111954: PUSH
111955: LD_EXP 138
111959: PPUSH
111960: CALL 52564 0 1
111964: ST_TO_ADDR
// for i := 1 to list do
111965: LD_ADDR_VAR 0 2
111969: PUSH
111970: DOUBLE
111971: LD_INT 1
111973: DEC
111974: ST_TO_ADDR
111975: LD_VAR 0 3
111979: PUSH
111980: FOR_TO
111981: IFFALSE 112072
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
111983: LD_STRING setWarehouseGatheringPointXY(
111985: PUSH
111986: LD_VAR 0 3
111990: PUSH
111991: LD_VAR 0 2
111995: ARRAY
111996: PUSH
111997: LD_INT 1
111999: ARRAY
112000: STR
112001: PUSH
112002: LD_STRING ,
112004: STR
112005: PUSH
112006: LD_VAR 0 3
112010: PUSH
112011: LD_VAR 0 2
112015: ARRAY
112016: PUSH
112017: LD_INT 2
112019: ARRAY
112020: STR
112021: PUSH
112022: LD_STRING ,
112024: STR
112025: PUSH
112026: LD_VAR 0 3
112030: PUSH
112031: LD_VAR 0 2
112035: ARRAY
112036: PUSH
112037: LD_INT 3
112039: ARRAY
112040: STR
112041: PUSH
112042: LD_STRING ,
112044: STR
112045: PUSH
112046: LD_VAR 0 3
112050: PUSH
112051: LD_VAR 0 2
112055: ARRAY
112056: PUSH
112057: LD_INT 4
112059: ARRAY
112060: STR
112061: PUSH
112062: LD_STRING )
112064: STR
112065: PPUSH
112066: CALL_OW 559
112070: GO 111980
112072: POP
112073: POP
// end ; end ;
112074: LD_VAR 0 1
112078: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
112079: LD_EXP 138
112083: IFFALSE 112768
112085: GO 112087
112087: DISABLE
112088: LD_INT 0
112090: PPUSH
112091: PPUSH
112092: PPUSH
112093: PPUSH
112094: PPUSH
112095: PPUSH
112096: PPUSH
112097: PPUSH
112098: PPUSH
// begin enable ;
112099: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
112100: LD_ADDR_VAR 0 3
112104: PUSH
112105: LD_EXP 138
112109: PPUSH
112110: CALL 52564 0 1
112114: ST_TO_ADDR
// if not list then
112115: LD_VAR 0 3
112119: NOT
112120: IFFALSE 112124
// exit ;
112122: GO 112768
// for i := 1 to list do
112124: LD_ADDR_VAR 0 1
112128: PUSH
112129: DOUBLE
112130: LD_INT 1
112132: DEC
112133: ST_TO_ADDR
112134: LD_VAR 0 3
112138: PUSH
112139: FOR_TO
112140: IFFALSE 112766
// begin depot := list [ i ] [ 2 ] ;
112142: LD_ADDR_VAR 0 8
112146: PUSH
112147: LD_VAR 0 3
112151: PUSH
112152: LD_VAR 0 1
112156: ARRAY
112157: PUSH
112158: LD_INT 2
112160: ARRAY
112161: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
112162: LD_ADDR_VAR 0 5
112166: PUSH
112167: LD_VAR 0 3
112171: PUSH
112172: LD_VAR 0 1
112176: ARRAY
112177: PUSH
112178: LD_INT 1
112180: ARRAY
112181: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
112182: LD_VAR 0 8
112186: PPUSH
112187: CALL_OW 301
112191: PUSH
112192: LD_VAR 0 5
112196: PUSH
112197: LD_VAR 0 8
112201: PPUSH
112202: CALL_OW 255
112206: NONEQUAL
112207: OR
112208: IFFALSE 112237
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
112210: LD_ADDR_EXP 138
112214: PUSH
112215: LD_EXP 138
112219: PPUSH
112220: LD_VAR 0 8
112224: PPUSH
112225: LD_INT 0
112227: PPUSH
112228: CALL_OW 1
112232: ST_TO_ADDR
// exit ;
112233: POP
112234: POP
112235: GO 112768
// end ; x := list [ i ] [ 3 ] ;
112237: LD_ADDR_VAR 0 6
112241: PUSH
112242: LD_VAR 0 3
112246: PUSH
112247: LD_VAR 0 1
112251: ARRAY
112252: PUSH
112253: LD_INT 3
112255: ARRAY
112256: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
112257: LD_ADDR_VAR 0 7
112261: PUSH
112262: LD_VAR 0 3
112266: PUSH
112267: LD_VAR 0 1
112271: ARRAY
112272: PUSH
112273: LD_INT 4
112275: ARRAY
112276: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
112277: LD_ADDR_VAR 0 9
112281: PUSH
112282: LD_VAR 0 6
112286: PPUSH
112287: LD_VAR 0 7
112291: PPUSH
112292: LD_INT 16
112294: PPUSH
112295: CALL 51152 0 3
112299: ST_TO_ADDR
// if not cratesNearbyPoint then
112300: LD_VAR 0 9
112304: NOT
112305: IFFALSE 112311
// exit ;
112307: POP
112308: POP
112309: GO 112768
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
112311: LD_ADDR_VAR 0 4
112315: PUSH
112316: LD_INT 22
112318: PUSH
112319: LD_VAR 0 5
112323: PUSH
112324: EMPTY
112325: LIST
112326: LIST
112327: PUSH
112328: LD_INT 3
112330: PUSH
112331: LD_INT 60
112333: PUSH
112334: EMPTY
112335: LIST
112336: PUSH
112337: EMPTY
112338: LIST
112339: LIST
112340: PUSH
112341: LD_INT 91
112343: PUSH
112344: LD_VAR 0 8
112348: PUSH
112349: LD_INT 6
112351: PUSH
112352: EMPTY
112353: LIST
112354: LIST
112355: LIST
112356: PUSH
112357: LD_INT 2
112359: PUSH
112360: LD_INT 25
112362: PUSH
112363: LD_INT 2
112365: PUSH
112366: EMPTY
112367: LIST
112368: LIST
112369: PUSH
112370: LD_INT 25
112372: PUSH
112373: LD_INT 16
112375: PUSH
112376: EMPTY
112377: LIST
112378: LIST
112379: PUSH
112380: EMPTY
112381: LIST
112382: LIST
112383: LIST
112384: PUSH
112385: EMPTY
112386: LIST
112387: LIST
112388: LIST
112389: LIST
112390: PPUSH
112391: CALL_OW 69
112395: PUSH
112396: LD_VAR 0 8
112400: PPUSH
112401: CALL_OW 313
112405: PPUSH
112406: LD_INT 3
112408: PUSH
112409: LD_INT 60
112411: PUSH
112412: EMPTY
112413: LIST
112414: PUSH
112415: EMPTY
112416: LIST
112417: LIST
112418: PUSH
112419: LD_INT 2
112421: PUSH
112422: LD_INT 25
112424: PUSH
112425: LD_INT 2
112427: PUSH
112428: EMPTY
112429: LIST
112430: LIST
112431: PUSH
112432: LD_INT 25
112434: PUSH
112435: LD_INT 16
112437: PUSH
112438: EMPTY
112439: LIST
112440: LIST
112441: PUSH
112442: EMPTY
112443: LIST
112444: LIST
112445: LIST
112446: PUSH
112447: EMPTY
112448: LIST
112449: LIST
112450: PPUSH
112451: CALL_OW 72
112455: UNION
112456: ST_TO_ADDR
// if tmp then
112457: LD_VAR 0 4
112461: IFFALSE 112541
// begin tmp := ShrinkArray ( tmp , 3 ) ;
112463: LD_ADDR_VAR 0 4
112467: PUSH
112468: LD_VAR 0 4
112472: PPUSH
112473: LD_INT 3
112475: PPUSH
112476: CALL 49121 0 2
112480: ST_TO_ADDR
// for j in tmp do
112481: LD_ADDR_VAR 0 2
112485: PUSH
112486: LD_VAR 0 4
112490: PUSH
112491: FOR_IN
112492: IFFALSE 112535
// begin if IsInUnit ( j ) then
112494: LD_VAR 0 2
112498: PPUSH
112499: CALL_OW 310
112503: IFFALSE 112514
// ComExit ( j ) ;
112505: LD_VAR 0 2
112509: PPUSH
112510: CALL 49204 0 1
// AddComCollect ( j , x , y ) ;
112514: LD_VAR 0 2
112518: PPUSH
112519: LD_VAR 0 6
112523: PPUSH
112524: LD_VAR 0 7
112528: PPUSH
112529: CALL_OW 177
// end ;
112533: GO 112491
112535: POP
112536: POP
// exit ;
112537: POP
112538: POP
112539: GO 112768
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
112541: LD_ADDR_VAR 0 4
112545: PUSH
112546: LD_INT 22
112548: PUSH
112549: LD_VAR 0 5
112553: PUSH
112554: EMPTY
112555: LIST
112556: LIST
112557: PUSH
112558: LD_INT 91
112560: PUSH
112561: LD_VAR 0 8
112565: PUSH
112566: LD_INT 8
112568: PUSH
112569: EMPTY
112570: LIST
112571: LIST
112572: LIST
112573: PUSH
112574: LD_INT 2
112576: PUSH
112577: LD_INT 34
112579: PUSH
112580: LD_INT 12
112582: PUSH
112583: EMPTY
112584: LIST
112585: LIST
112586: PUSH
112587: LD_INT 34
112589: PUSH
112590: LD_INT 51
112592: PUSH
112593: EMPTY
112594: LIST
112595: LIST
112596: PUSH
112597: LD_INT 34
112599: PUSH
112600: LD_INT 32
112602: PUSH
112603: EMPTY
112604: LIST
112605: LIST
112606: PUSH
112607: LD_INT 34
112609: PUSH
112610: LD_INT 89
112612: PUSH
112613: EMPTY
112614: LIST
112615: LIST
112616: PUSH
112617: EMPTY
112618: LIST
112619: LIST
112620: LIST
112621: LIST
112622: LIST
112623: PUSH
112624: EMPTY
112625: LIST
112626: LIST
112627: LIST
112628: PPUSH
112629: CALL_OW 69
112633: ST_TO_ADDR
// if tmp then
112634: LD_VAR 0 4
112638: IFFALSE 112764
// begin for j in tmp do
112640: LD_ADDR_VAR 0 2
112644: PUSH
112645: LD_VAR 0 4
112649: PUSH
112650: FOR_IN
112651: IFFALSE 112762
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
112653: LD_VAR 0 2
112657: PPUSH
112658: CALL_OW 262
112662: PUSH
112663: LD_INT 3
112665: EQUAL
112666: PUSH
112667: LD_VAR 0 2
112671: PPUSH
112672: CALL_OW 261
112676: PUSH
112677: LD_INT 20
112679: GREATER
112680: OR
112681: PUSH
112682: LD_VAR 0 2
112686: PPUSH
112687: CALL_OW 314
112691: NOT
112692: AND
112693: PUSH
112694: LD_VAR 0 2
112698: PPUSH
112699: CALL_OW 263
112703: PUSH
112704: LD_INT 1
112706: NONEQUAL
112707: PUSH
112708: LD_VAR 0 2
112712: PPUSH
112713: CALL_OW 311
112717: OR
112718: AND
112719: IFFALSE 112760
// begin ComCollect ( j , x , y ) ;
112721: LD_VAR 0 2
112725: PPUSH
112726: LD_VAR 0 6
112730: PPUSH
112731: LD_VAR 0 7
112735: PPUSH
112736: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
112740: LD_VAR 0 2
112744: PPUSH
112745: LD_VAR 0 8
112749: PPUSH
112750: CALL_OW 172
// exit ;
112754: POP
112755: POP
112756: POP
112757: POP
112758: GO 112768
// end ;
112760: GO 112650
112762: POP
112763: POP
// end ; end ;
112764: GO 112139
112766: POP
112767: POP
// end ; end_of_file
112768: PPOPN 9
112770: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
112771: LD_VAR 0 1
112775: PPUSH
112776: LD_VAR 0 2
112780: PPUSH
112781: LD_VAR 0 3
112785: PPUSH
112786: LD_VAR 0 4
112790: PPUSH
112791: LD_VAR 0 5
112795: PPUSH
112796: LD_VAR 0 6
112800: PPUSH
112801: CALL 97124 0 6
// end ;
112805: PPOPN 6
112807: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
112808: LD_INT 0
112810: PPUSH
// begin if not units then
112811: LD_VAR 0 1
112815: NOT
112816: IFFALSE 112820
// exit ;
112818: GO 112820
// end ;
112820: PPOPN 7
112822: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
112823: CALL 97011 0 0
// end ;
112827: PPOPN 1
112829: END
