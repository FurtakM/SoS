// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 206 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45146 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45146 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45146 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45146 0 9
// PrepareGensher ;
 185: CALL 3152 0 0
// PreparePopov ;
 189: CALL 6359 0 0
// PreparePowell ;
 193: CALL 585 0 0
// PrepareSikorski ;
 197: CALL 9047 0 0
// MC_Start ( ) ;
 201: CALL 54445 0 0
// end ;
 205: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 206: LD_INT 0
 208: PPUSH
// debug := 1 ;
 209: LD_ADDR_EXP 1
 213: PUSH
 214: LD_INT 1
 216: ST_TO_ADDR
// game := true ;
 217: LD_ADDR_EXP 2
 221: PUSH
 222: LD_INT 1
 224: ST_TO_ADDR
// staticMines := [ ] ;
 225: LD_ADDR_EXP 3
 229: PUSH
 230: EMPTY
 231: ST_TO_ADDR
// arDestroyed := false ;
 232: LD_ADDR_EXP 4
 236: PUSH
 237: LD_INT 0
 239: ST_TO_ADDR
// ruDestroyed := false ;
 240: LD_ADDR_EXP 5
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// powellInTrouble := false ;
 248: LD_ADDR_EXP 8
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// sikorskiInTrouble := false ;
 256: LD_ADDR_EXP 9
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// end ;
 264: LD_VAR 0 1
 268: RET
// export function CustomInitMacro ; begin
 269: LD_INT 0
 271: PPUSH
// InitMC_Gensher ( ) ;
 272: CALL 4286 0 0
// InitMC_Powell ( ) ;
 276: CALL 1507 0 0
// InitMC_Popov ( ) ;
 280: CALL 7517 0 0
// end ;
 284: LD_VAR 0 1
 288: RET
// every 0 0$10 do var cr , time , i ;
 289: GO 291
 291: DISABLE
 292: LD_INT 0
 294: PPUSH
 295: PPUSH
 296: PPUSH
// begin time := 0 0$20 ;
 297: LD_ADDR_VAR 0 2
 301: PUSH
 302: LD_INT 700
 304: ST_TO_ADDR
// repeat wait ( time ) ;
 305: LD_VAR 0 2
 309: PPUSH
 310: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 314: LD_ADDR_VAR 0 1
 318: PUSH
 319: LD_INT 1
 321: PPUSH
 322: LD_INT 5
 324: PPUSH
 325: CALL_OW 12
 329: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 330: LD_ADDR_VAR 0 3
 334: PUSH
 335: LD_INT 5
 337: PUSH
 338: LD_INT 8
 340: PUSH
 341: LD_INT 12
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: EMPTY
 348: LIST
 349: LIST
 350: LIST
 351: LIST
 352: PUSH
 353: FOR_IN
 354: IFFALSE 408
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 356: LD_VAR 0 3
 360: PPUSH
 361: LD_INT 1
 363: PPUSH
 364: CALL_OW 287
 368: PUSH
 369: LD_INT 40
 371: LESS
 372: IFFALSE 391
// CreateCratesArea ( cr , i , true ) ;
 374: LD_VAR 0 1
 378: PPUSH
 379: LD_VAR 0 3
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 391: LD_INT 175
 393: PPUSH
 394: LD_INT 525
 396: PPUSH
 397: CALL_OW 12
 401: PPUSH
 402: CALL_OW 67
// end ;
 406: GO 353
 408: POP
 409: POP
// time := time + 0 0$2 ;
 410: LD_ADDR_VAR 0 2
 414: PUSH
 415: LD_VAR 0 2
 419: PUSH
 420: LD_INT 70
 422: PLUS
 423: ST_TO_ADDR
// if time > 0 0$35 then
 424: LD_VAR 0 2
 428: PUSH
 429: LD_INT 1225
 431: GREATER
 432: IFFALSE 442
// time := 0 0$25 ;
 434: LD_ADDR_VAR 0 2
 438: PUSH
 439: LD_INT 875
 441: ST_TO_ADDR
// until not game ;
 442: LD_EXP 2
 446: NOT
 447: IFFALSE 305
// end ;
 449: PPOPN 3
 451: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 452: LD_INT 3
 454: PUSH
 455: LD_INT 22
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 32
 471: PUSH
 472: LD_INT 1
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 69
 487: IFFALSE 582
 489: GO 491
 491: DISABLE
 492: LD_INT 0
 494: PPUSH
 495: PPUSH
// begin enable ;
 496: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 497: LD_ADDR_VAR 0 2
 501: PUSH
 502: LD_INT 3
 504: PUSH
 505: LD_INT 22
 507: PUSH
 508: LD_INT 1
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 32
 521: PUSH
 522: LD_INT 1
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL_OW 69
 537: ST_TO_ADDR
// for i in tmp do
 538: LD_ADDR_VAR 0 1
 542: PUSH
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_IN
 549: IFFALSE 580
// if GetFuel ( i ) < 5 then
 551: LD_VAR 0 1
 555: PPUSH
 556: CALL_OW 261
 560: PUSH
 561: LD_INT 5
 563: LESS
 564: IFFALSE 578
// SetFuel ( i , 5 ) ;
 566: LD_VAR 0 1
 570: PPUSH
 571: LD_INT 5
 573: PPUSH
 574: CALL_OW 240
 578: GO 548
 580: POP
 581: POP
// end ; end_of_file
 582: PPOPN 2
 584: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 585: LD_INT 0
 587: PPUSH
 588: PPUSH
 589: PPUSH
 590: PPUSH
 591: PPUSH
// powell_side := 4 ;
 592: LD_ADDR_EXP 11
 596: PUSH
 597: LD_INT 4
 599: ST_TO_ADDR
// uc_side := powell_side ;
 600: LD_ADDR_OWVAR 20
 604: PUSH
 605: LD_EXP 11
 609: ST_TO_ADDR
// uc_nation := 1 ;
 610: LD_ADDR_OWVAR 21
 614: PUSH
 615: LD_INT 1
 617: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 618: LD_ADDR_EXP 10
 622: PUSH
 623: LD_STRING Powell
 625: PPUSH
 626: CALL_OW 25
 630: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 631: LD_EXP 10
 635: PPUSH
 636: LD_INT 1
 638: PPUSH
 639: LD_INT 7
 641: PPUSH
 642: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 646: LD_EXP 10
 650: PPUSH
 651: LD_INT 2
 653: PPUSH
 654: LD_INT 5
 656: PPUSH
 657: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 661: LD_EXP 10
 665: PPUSH
 666: LD_INT 3
 668: PPUSH
 669: LD_INT 6
 671: PPUSH
 672: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 676: LD_EXP 10
 680: PPUSH
 681: LD_INT 4
 683: PPUSH
 684: LD_INT 4
 686: PPUSH
 687: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 691: LD_EXP 10
 695: PPUSH
 696: LD_INT 4
 698: PPUSH
 699: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 703: LD_ADDR_VAR 0 3
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 178
 713: PUSH
 714: LD_INT 117
 716: PUSH
 717: LD_INT 2
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PUSH
 726: LD_INT 29
 728: PUSH
 729: LD_INT 167
 731: PUSH
 732: LD_INT 102
 734: PUSH
 735: LD_INT 0
 737: PUSH
 738: EMPTY
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_INT 6
 746: PUSH
 747: LD_INT 200
 749: PUSH
 750: LD_INT 111
 752: PUSH
 753: LD_INT 4
 755: PUSH
 756: LD_INT 10
 758: PUSH
 759: LD_INT 11
 761: PUSH
 762: EMPTY
 763: LIST
 764: LIST
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 3
 772: PUSH
 773: LD_INT 201
 775: PUSH
 776: LD_INT 140
 778: PUSH
 779: LD_INT 4
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 27
 790: PUSH
 791: LD_INT 206
 793: PUSH
 794: LD_INT 124
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 27
 808: PUSH
 809: LD_INT 209
 811: PUSH
 812: LD_INT 128
 814: PUSH
 815: LD_INT 3
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 27
 826: PUSH
 827: LD_INT 211
 829: PUSH
 830: LD_INT 132
 832: PUSH
 833: LD_INT 3
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: LD_INT 30
 844: PUSH
 845: LD_INT 173
 847: PUSH
 848: LD_INT 83
 850: PUSH
 851: LD_INT 3
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PUSH
 860: LD_INT 6
 862: PUSH
 863: LD_INT 186
 865: PUSH
 866: LD_INT 103
 868: PUSH
 869: LD_INT 2
 871: PUSH
 872: LD_INT 12
 874: PUSH
 875: LD_INT 15
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 33
 888: PUSH
 889: LD_INT 173
 891: PUSH
 892: LD_INT 99
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 6
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 32
 910: PUSH
 911: LD_INT 174
 913: PUSH
 914: LD_INT 102
 916: PUSH
 917: LD_INT 2
 919: PUSH
 920: LD_INT 6
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: LIST
 927: LIST
 928: LIST
 929: PUSH
 930: LD_INT 32
 932: PUSH
 933: LD_INT 178
 935: PUSH
 936: LD_INT 100
 938: PUSH
 939: LD_INT 2
 941: PUSH
 942: LD_INT 6
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: PUSH
 952: LD_INT 33
 954: PUSH
 955: LD_INT 174
 957: PUSH
 958: LD_INT 108
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 7
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 33
 976: PUSH
 977: LD_INT 182
 979: PUSH
 980: LD_INT 122
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 7
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 36
 998: PUSH
 999: LD_INT 194
1001: PUSH
1002: LD_INT 124
1004: PUSH
1005: LD_INT 5
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 33
1016: PUSH
1017: LD_INT 184
1019: PUSH
1020: LD_INT 141
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 6
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 33
1038: PUSH
1039: LD_INT 183
1041: PUSH
1042: LD_INT 131
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 11
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 33
1060: PUSH
1061: LD_INT 194
1063: PUSH
1064: LD_INT 146
1066: PUSH
1067: LD_INT 4
1069: PUSH
1070: LD_INT 7
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: LIST
1079: PUSH
1080: LD_INT 33
1082: PUSH
1083: LD_INT 190
1085: PUSH
1086: LD_INT 142
1088: PUSH
1089: LD_INT 4
1091: PUSH
1092: LD_INT 7
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PUSH
1102: LD_INT 28
1104: PUSH
1105: LD_INT 204
1107: PUSH
1108: LD_INT 133
1110: PUSH
1111: LD_INT 3
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PUSH
1120: LD_INT 27
1122: PUSH
1123: LD_INT 201
1125: PUSH
1126: LD_INT 133
1128: PUSH
1129: LD_INT 3
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: LIST
1136: LIST
1137: PUSH
1138: LD_INT 28
1140: PUSH
1141: LD_INT 199
1143: PUSH
1144: LD_INT 119
1146: PUSH
1147: LD_INT 5
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: LIST
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: ST_TO_ADDR
// for i in list do
1180: LD_ADDR_VAR 0 2
1184: PUSH
1185: LD_VAR 0 3
1189: PUSH
1190: FOR_IN
1191: IFFALSE 1369
// begin uc_side := 4 ;
1193: LD_ADDR_OWVAR 20
1197: PUSH
1198: LD_INT 4
1200: ST_TO_ADDR
// uc_nation := 1 ;
1201: LD_ADDR_OWVAR 21
1205: PUSH
1206: LD_INT 1
1208: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1209: LD_ADDR_OWVAR 42
1213: PUSH
1214: LD_VAR 0 2
1218: PUSH
1219: LD_INT 1
1221: ARRAY
1222: ST_TO_ADDR
// bc_kind1 := - 1 ;
1223: LD_ADDR_OWVAR 44
1227: PUSH
1228: LD_INT 1
1230: NEG
1231: ST_TO_ADDR
// bc_kind2 := - 1 ;
1232: LD_ADDR_OWVAR 45
1236: PUSH
1237: LD_INT 1
1239: NEG
1240: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1241: LD_VAR 0 2
1245: PUSH
1246: LD_INT 1
1248: ARRAY
1249: PUSH
1250: LD_INT 6
1252: EQUAL
1253: IFFALSE 1291
// begin bc_type := b_lab_full ;
1255: LD_ADDR_OWVAR 42
1259: PUSH
1260: LD_INT 8
1262: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1263: LD_ADDR_OWVAR 44
1267: PUSH
1268: LD_VAR 0 2
1272: PUSH
1273: LD_INT 5
1275: ARRAY
1276: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1277: LD_ADDR_OWVAR 45
1281: PUSH
1282: LD_VAR 0 2
1286: PUSH
1287: LD_INT 6
1289: ARRAY
1290: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1291: LD_ADDR_VAR 0 4
1295: PUSH
1296: LD_VAR 0 2
1300: PUSH
1301: LD_INT 2
1303: ARRAY
1304: PPUSH
1305: LD_VAR 0 2
1309: PUSH
1310: LD_INT 3
1312: ARRAY
1313: PPUSH
1314: LD_VAR 0 2
1318: PUSH
1319: LD_INT 4
1321: ARRAY
1322: PPUSH
1323: CALL_OW 47
1327: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1328: LD_VAR 0 2
1332: PUSH
1333: LD_INT 1
1335: ARRAY
1336: PUSH
1337: LD_INT 33
1339: PUSH
1340: LD_INT 32
1342: PUSH
1343: EMPTY
1344: LIST
1345: LIST
1346: IN
1347: IFFALSE 1367
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1349: LD_VAR 0 4
1353: PPUSH
1354: LD_VAR 0 2
1358: PUSH
1359: LD_INT 5
1361: ARRAY
1362: PPUSH
1363: CALL_OW 431
// end ;
1367: GO 1190
1369: POP
1370: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1371: LD_ADDR_VAR 0 5
1375: PUSH
1376: LD_INT 4
1378: PPUSH
1379: LD_INT 1
1381: PPUSH
1382: LD_STRING 
1384: PPUSH
1385: LD_INT 8
1387: PUSH
1388: LD_INT 7
1390: PUSH
1391: LD_INT 6
1393: PUSH
1394: EMPTY
1395: LIST
1396: LIST
1397: LIST
1398: PUSH
1399: LD_OWVAR 67
1403: ARRAY
1404: PPUSH
1405: LD_INT 5500
1407: PUSH
1408: LD_INT 500
1410: PUSH
1411: LD_INT 0
1413: PUSH
1414: EMPTY
1415: LIST
1416: LIST
1417: LIST
1418: PPUSH
1419: LD_INT 6
1421: PUSH
1422: LD_INT 6
1424: PUSH
1425: LD_INT 6
1427: PUSH
1428: LD_INT 6
1430: PUSH
1431: EMPTY
1432: LIST
1433: LIST
1434: LIST
1435: LIST
1436: PPUSH
1437: CALL 19474 0 6
1441: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1442: LD_ADDR_EXP 23
1446: PUSH
1447: LD_EXP 23
1451: PPUSH
1452: LD_INT 1
1454: PPUSH
1455: LD_VAR 0 5
1459: PUSH
1460: LD_INT 22
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 21
1472: PUSH
1473: LD_INT 3
1475: PUSH
1476: EMPTY
1477: LIST
1478: LIST
1479: PUSH
1480: EMPTY
1481: LIST
1482: LIST
1483: PPUSH
1484: CALL_OW 69
1488: UNION
1489: PPUSH
1490: CALL_OW 1
1494: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1495: LD_ADDR_EXP 12
1499: PUSH
1500: EMPTY
1501: ST_TO_ADDR
// end ;
1502: LD_VAR 0 1
1506: RET
// export function InitMC_Powell ( ) ; begin
1507: LD_INT 0
1509: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1510: LD_INT 1
1512: PPUSH
1513: LD_INT 1
1515: PPUSH
1516: CALL 77822 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1520: LD_INT 1
1522: PPUSH
1523: LD_INT 6
1525: PPUSH
1526: CALL 77766 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1530: LD_INT 1
1532: PPUSH
1533: LD_INT 167
1535: PUSH
1536: LD_INT 102
1538: PUSH
1539: LD_INT 0
1541: PUSH
1542: EMPTY
1543: LIST
1544: LIST
1545: LIST
1546: PUSH
1547: LD_INT 173
1549: PUSH
1550: LD_INT 83
1552: PUSH
1553: LD_INT 1
1555: PUSH
1556: EMPTY
1557: LIST
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 171
1563: PUSH
1564: LD_INT 141
1566: PUSH
1567: LD_INT 0
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: PUSH
1575: LD_INT 178
1577: PUSH
1578: LD_INT 148
1580: PUSH
1581: LD_INT 1
1583: PUSH
1584: EMPTY
1585: LIST
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: LIST
1594: PPUSH
1595: CALL 76825 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1599: LD_INT 1
1601: PPUSH
1602: LD_INT 11
1604: PUSH
1605: LD_INT 6
1607: PUSH
1608: LD_INT 7
1610: PUSH
1611: EMPTY
1612: LIST
1613: LIST
1614: LIST
1615: PPUSH
1616: CALL 77654 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1620: LD_INT 1
1622: PPUSH
1623: LD_INT 5
1625: PPUSH
1626: CALL 77336 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1630: LD_INT 1
1632: PPUSH
1633: LD_INT 4
1635: PPUSH
1636: CALL 77067 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1640: LD_INT 1
1642: PPUSH
1643: LD_INT 4
1645: PPUSH
1646: CALL 76686 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1650: LD_INT 1
1652: PPUSH
1653: LD_INT 3
1655: PUSH
1656: LD_INT 1
1658: PUSH
1659: LD_INT 2
1661: PUSH
1662: LD_INT 5
1664: PUSH
1665: EMPTY
1666: LIST
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: LD_INT 4
1673: PUSH
1674: LD_INT 1
1676: PUSH
1677: LD_INT 2
1679: PUSH
1680: LD_INT 6
1682: PUSH
1683: EMPTY
1684: LIST
1685: LIST
1686: LIST
1687: LIST
1688: PUSH
1689: LD_INT 4
1691: PUSH
1692: LD_INT 1
1694: PUSH
1695: LD_INT 2
1697: PUSH
1698: LD_INT 7
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 1
1712: PUSH
1713: LD_INT 2
1715: PUSH
1716: LD_INT 6
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: EMPTY
1726: LIST
1727: LIST
1728: LIST
1729: LIST
1730: PPUSH
1731: CALL 76501 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1735: LD_INT 1
1737: PPUSH
1738: LD_INT 201
1740: PPUSH
1741: LD_INT 140
1743: PPUSH
1744: LD_INT 4
1746: PPUSH
1747: LD_INT 19
1749: PUSH
1750: LD_INT 16
1752: PUSH
1753: LD_INT 17
1755: PUSH
1756: LD_INT 18
1758: PUSH
1759: LD_INT 22
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: LIST
1767: LIST
1768: PPUSH
1769: CALL 77448 0 5
// end ;
1773: LD_VAR 0 1
1777: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1778: LD_INT 4
1780: PPUSH
1781: CALL_OW 302
1785: IFFALSE 2445
1787: GO 1789
1789: DISABLE
1790: LD_INT 0
1792: PPUSH
1793: PPUSH
1794: PPUSH
1795: PPUSH
1796: PPUSH
// begin enable ;
1797: ENABLE
// base := 1 ;
1798: LD_ADDR_VAR 0 2
1802: PUSH
1803: LD_INT 1
1805: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1806: LD_ADDR_VAR 0 3
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 1
1816: PUSH
1817: LD_INT 2
1819: PUSH
1820: LD_INT 6
1822: PUSH
1823: EMPTY
1824: LIST
1825: LIST
1826: LIST
1827: LIST
1828: PUSH
1829: LD_INT 4
1831: PUSH
1832: LD_INT 1
1834: PUSH
1835: LD_INT 2
1837: PUSH
1838: LD_INT 6
1840: PUSH
1841: EMPTY
1842: LIST
1843: LIST
1844: LIST
1845: LIST
1846: PUSH
1847: LD_INT 3
1849: PUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 7
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 3
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 2
1873: PUSH
1874: LD_INT 7
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: EMPTY
1884: LIST
1885: LIST
1886: LIST
1887: LIST
1888: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1889: LD_ADDR_VAR 0 5
1893: PUSH
1894: LD_VAR 0 5
1898: PUSH
1899: LD_OWVAR 1
1903: PUSH
1904: LD_INT 21000
1906: DIV
1907: PLUS
1908: ST_TO_ADDR
// if amount > 8 then
1909: LD_VAR 0 5
1913: PUSH
1914: LD_INT 8
1916: GREATER
1917: IFFALSE 1927
// amount := 8 ;
1919: LD_ADDR_VAR 0 5
1923: PUSH
1924: LD_INT 8
1926: ST_TO_ADDR
// for i = 1 to amount do
1927: LD_ADDR_VAR 0 1
1931: PUSH
1932: DOUBLE
1933: LD_INT 1
1935: DEC
1936: ST_TO_ADDR
1937: LD_VAR 0 5
1941: PUSH
1942: FOR_TO
1943: IFFALSE 2027
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1945: LD_ADDR_VAR 0 3
1949: PUSH
1950: LD_VAR 0 3
1954: PPUSH
1955: LD_VAR 0 3
1959: PUSH
1960: LD_INT 1
1962: PLUS
1963: PPUSH
1964: LD_INT 3
1966: PUSH
1967: LD_INT 4
1969: PUSH
1970: EMPTY
1971: LIST
1972: LIST
1973: PUSH
1974: LD_INT 1
1976: PPUSH
1977: LD_INT 2
1979: PPUSH
1980: CALL_OW 12
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: PUSH
1989: LD_INT 2
1991: PUSH
1992: LD_INT 7
1994: PUSH
1995: LD_INT 5
1997: PUSH
1998: EMPTY
1999: LIST
2000: LIST
2001: PUSH
2002: LD_INT 1
2004: PPUSH
2005: LD_INT 2
2007: PPUSH
2008: CALL_OW 12
2012: ARRAY
2013: PUSH
2014: EMPTY
2015: LIST
2016: LIST
2017: LIST
2018: LIST
2019: PPUSH
2020: CALL_OW 2
2024: ST_TO_ADDR
2025: GO 1942
2027: POP
2028: POP
// MC_InsertProduceList ( base , tmp ) ;
2029: LD_VAR 0 2
2033: PPUSH
2034: LD_VAR 0 3
2038: PPUSH
2039: CALL 76549 0 2
// repeat wait ( 0 0$1 ) ;
2043: LD_INT 35
2045: PPUSH
2046: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2050: LD_VAR 0 2
2054: PPUSH
2055: LD_INT 1
2057: PPUSH
2058: CALL 77967 0 2
2062: PUSH
2063: LD_VAR 0 5
2067: GREATEREQUAL
2068: IFFALSE 2043
// wait ( 0 0$30 ) ;
2070: LD_INT 1050
2072: PPUSH
2073: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2077: LD_ADDR_VAR 0 4
2081: PUSH
2082: LD_EXP 42
2086: PUSH
2087: LD_VAR 0 2
2091: ARRAY
2092: PUSH
2093: LD_EXP 42
2097: PUSH
2098: LD_VAR 0 2
2102: ARRAY
2103: PPUSH
2104: LD_INT 2
2106: PUSH
2107: LD_INT 34
2109: PUSH
2110: LD_INT 12
2112: PUSH
2113: EMPTY
2114: LIST
2115: LIST
2116: PUSH
2117: LD_INT 34
2119: PUSH
2120: LD_INT 13
2122: PUSH
2123: EMPTY
2124: LIST
2125: LIST
2126: PUSH
2127: LD_INT 34
2129: PUSH
2130: LD_INT 14
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: PUSH
2137: EMPTY
2138: LIST
2139: LIST
2140: LIST
2141: LIST
2142: PPUSH
2143: CALL_OW 72
2147: DIFF
2148: ST_TO_ADDR
// if not attackers then
2149: LD_VAR 0 4
2153: NOT
2154: IFFALSE 2158
// exit ;
2156: GO 2445
// DialogPowellsAttack ;
2158: CALL 9585 0 0
// powellAttackGroup := attackers ;
2162: LD_ADDR_EXP 12
2166: PUSH
2167: LD_VAR 0 4
2171: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2172: LD_ADDR_EXP 42
2176: PUSH
2177: LD_EXP 42
2181: PPUSH
2182: LD_VAR 0 2
2186: PPUSH
2187: LD_EXP 42
2191: PUSH
2192: LD_VAR 0 2
2196: ARRAY
2197: PUSH
2198: LD_VAR 0 4
2202: DIFF
2203: PPUSH
2204: CALL_OW 1
2208: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2209: LD_EXP 9
2213: PUSH
2214: LD_INT 16
2216: PPUSH
2217: LD_INT 81
2219: PUSH
2220: LD_INT 4
2222: PUSH
2223: EMPTY
2224: LIST
2225: LIST
2226: PPUSH
2227: CALL_OW 70
2231: AND
2232: IFFALSE 2251
// ComAgressiveMove ( attackers , 135 , 21 ) else
2234: LD_VAR 0 4
2238: PPUSH
2239: LD_INT 135
2241: PPUSH
2242: LD_INT 21
2244: PPUSH
2245: CALL_OW 114
2249: GO 2266
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2251: LD_VAR 0 4
2255: PPUSH
2256: LD_INT 146
2258: PPUSH
2259: LD_INT 103
2261: PPUSH
2262: CALL_OW 114
// wait ( 0 0$5 ) ;
2266: LD_INT 175
2268: PPUSH
2269: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2273: LD_INT 35
2275: PPUSH
2276: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2280: LD_VAR 0 4
2284: PPUSH
2285: LD_INT 60
2287: PUSH
2288: EMPTY
2289: LIST
2290: PPUSH
2291: CALL_OW 72
2295: NOT
2296: IFFALSE 2273
// if FilterAllUnits ( [ f_side , 3 ] ) then
2298: LD_INT 22
2300: PUSH
2301: LD_INT 3
2303: PUSH
2304: EMPTY
2305: LIST
2306: LIST
2307: PPUSH
2308: CALL_OW 69
2312: IFFALSE 2331
// ComAgressiveMove ( attackers , 102 , 116 ) else
2314: LD_VAR 0 4
2318: PPUSH
2319: LD_INT 102
2321: PPUSH
2322: LD_INT 116
2324: PPUSH
2325: CALL_OW 114
2329: GO 2346
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2331: LD_VAR 0 4
2335: PPUSH
2336: LD_INT 66
2338: PPUSH
2339: LD_INT 41
2341: PPUSH
2342: CALL_OW 114
// wait ( 0 0$10 ) ;
2346: LD_INT 350
2348: PPUSH
2349: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2353: LD_INT 35
2355: PPUSH
2356: CALL_OW 67
// for i in attackers do
2360: LD_ADDR_VAR 0 1
2364: PUSH
2365: LD_VAR 0 4
2369: PUSH
2370: FOR_IN
2371: IFFALSE 2421
// if not HasTask ( i ) then
2373: LD_VAR 0 1
2377: PPUSH
2378: CALL_OW 314
2382: NOT
2383: IFFALSE 2419
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2385: LD_VAR 0 1
2389: PPUSH
2390: LD_INT 81
2392: PUSH
2393: LD_INT 4
2395: PUSH
2396: EMPTY
2397: LIST
2398: LIST
2399: PPUSH
2400: CALL_OW 69
2404: PPUSH
2405: LD_VAR 0 1
2409: PPUSH
2410: CALL_OW 74
2414: PPUSH
2415: CALL_OW 115
2419: GO 2370
2421: POP
2422: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2423: LD_VAR 0 4
2427: PPUSH
2428: LD_INT 50
2430: PUSH
2431: EMPTY
2432: LIST
2433: PPUSH
2434: CALL_OW 72
2438: NOT
2439: IFFALSE 2353
// DialogPowellsAttackFailed ;
2441: CALL 9850 0 0
// end ;
2445: PPOPN 5
2447: END
// every 0 0$2 do var vehicles , mechs , i ;
2448: GO 2450
2450: DISABLE
2451: LD_INT 0
2453: PPUSH
2454: PPUSH
2455: PPUSH
// begin enable ;
2456: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2457: LD_ADDR_VAR 0 1
2461: PUSH
2462: LD_INT 22
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: EMPTY
2469: LIST
2470: LIST
2471: PUSH
2472: LD_INT 21
2474: PUSH
2475: LD_INT 2
2477: PUSH
2478: EMPTY
2479: LIST
2480: LIST
2481: PUSH
2482: LD_INT 3
2484: PUSH
2485: LD_INT 24
2487: PUSH
2488: LD_INT 1000
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: PUSH
2495: EMPTY
2496: LIST
2497: LIST
2498: PUSH
2499: LD_INT 92
2501: PUSH
2502: LD_INT 191
2504: PUSH
2505: LD_INT 140
2507: PUSH
2508: LD_INT 10
2510: PUSH
2511: EMPTY
2512: LIST
2513: LIST
2514: LIST
2515: LIST
2516: PUSH
2517: EMPTY
2518: LIST
2519: LIST
2520: LIST
2521: LIST
2522: PPUSH
2523: CALL_OW 69
2527: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2528: LD_ADDR_VAR 0 2
2532: PUSH
2533: LD_INT 22
2535: PUSH
2536: LD_INT 4
2538: PUSH
2539: EMPTY
2540: LIST
2541: LIST
2542: PUSH
2543: LD_INT 25
2545: PUSH
2546: LD_INT 3
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 69
2561: ST_TO_ADDR
// if not mechs then
2562: LD_VAR 0 2
2566: NOT
2567: IFFALSE 2571
// exit ;
2569: GO 2745
// if mc_remote_driver [ 1 ] then
2571: LD_EXP 63
2575: PUSH
2576: LD_INT 1
2578: ARRAY
2579: IFFALSE 2601
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2581: LD_ADDR_VAR 0 2
2585: PUSH
2586: LD_VAR 0 2
2590: PUSH
2591: LD_EXP 63
2595: PUSH
2596: LD_INT 1
2598: ARRAY
2599: DIFF
2600: ST_TO_ADDR
// if not mechs then
2601: LD_VAR 0 2
2605: NOT
2606: IFFALSE 2610
// exit ;
2608: GO 2745
// if vehicles then
2610: LD_VAR 0 1
2614: IFFALSE 2702
// begin for i in mechs do
2616: LD_ADDR_VAR 0 3
2620: PUSH
2621: LD_VAR 0 2
2625: PUSH
2626: FOR_IN
2627: IFFALSE 2698
// begin if GetTag ( i ) <> 120 then
2629: LD_VAR 0 3
2633: PPUSH
2634: CALL_OW 110
2638: PUSH
2639: LD_INT 120
2641: NONEQUAL
2642: IFFALSE 2656
// SetTag ( i , 120 ) ;
2644: LD_VAR 0 3
2648: PPUSH
2649: LD_INT 120
2651: PPUSH
2652: CALL_OW 109
// if IsInUnit ( i ) then
2656: LD_VAR 0 3
2660: PPUSH
2661: CALL_OW 310
2665: IFFALSE 2678
// ComExitBuilding ( i ) else
2667: LD_VAR 0 3
2671: PPUSH
2672: CALL_OW 122
2676: GO 2696
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2678: LD_VAR 0 3
2682: PPUSH
2683: LD_VAR 0 1
2687: PUSH
2688: LD_INT 1
2690: ARRAY
2691: PPUSH
2692: CALL_OW 129
// end ;
2696: GO 2626
2698: POP
2699: POP
// end else
2700: GO 2745
// if FilterByTag ( mechs , 120 ) then
2702: LD_VAR 0 2
2706: PPUSH
2707: LD_INT 120
2709: PPUSH
2710: CALL 46038 0 2
2714: IFFALSE 2745
// begin for i in mechs do
2716: LD_ADDR_VAR 0 3
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: FOR_IN
2727: IFFALSE 2743
// begin SetTag ( i , 0 ) ;
2729: LD_VAR 0 3
2733: PPUSH
2734: LD_INT 0
2736: PPUSH
2737: CALL_OW 109
// end ;
2741: GO 2726
2743: POP
2744: POP
// end ; end ;
2745: PPOPN 3
2747: END
// every 0 0$2 do var people , sci , i ;
2748: GO 2750
2750: DISABLE
2751: LD_INT 0
2753: PPUSH
2754: PPUSH
2755: PPUSH
// begin enable ;
2756: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2757: LD_ADDR_VAR 0 1
2761: PUSH
2762: LD_INT 22
2764: PUSH
2765: LD_INT 1
2767: PUSH
2768: EMPTY
2769: LIST
2770: LIST
2771: PUSH
2772: LD_INT 21
2774: PUSH
2775: LD_INT 1
2777: PUSH
2778: EMPTY
2779: LIST
2780: LIST
2781: PUSH
2782: LD_INT 3
2784: PUSH
2785: LD_INT 24
2787: PUSH
2788: LD_INT 1000
2790: PUSH
2791: EMPTY
2792: LIST
2793: LIST
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: PUSH
2799: LD_INT 92
2801: PUSH
2802: LD_INT 188
2804: PUSH
2805: LD_INT 112
2807: PUSH
2808: LD_INT 10
2810: PUSH
2811: EMPTY
2812: LIST
2813: LIST
2814: LIST
2815: LIST
2816: PUSH
2817: EMPTY
2818: LIST
2819: LIST
2820: LIST
2821: LIST
2822: PPUSH
2823: CALL_OW 69
2827: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2828: LD_ADDR_VAR 0 2
2832: PUSH
2833: LD_INT 22
2835: PUSH
2836: LD_INT 4
2838: PUSH
2839: EMPTY
2840: LIST
2841: LIST
2842: PUSH
2843: LD_INT 25
2845: PUSH
2846: LD_INT 4
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: PPUSH
2857: CALL_OW 69
2861: ST_TO_ADDR
// if not sci then
2862: LD_VAR 0 2
2866: NOT
2867: IFFALSE 2871
// exit ;
2869: GO 3006
// if people then
2871: LD_VAR 0 1
2875: IFFALSE 2963
// begin for i in sci do
2877: LD_ADDR_VAR 0 3
2881: PUSH
2882: LD_VAR 0 2
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2959
// begin if GetTag ( i ) <> 102 then
2890: LD_VAR 0 3
2894: PPUSH
2895: CALL_OW 110
2899: PUSH
2900: LD_INT 102
2902: NONEQUAL
2903: IFFALSE 2917
// SetTag ( i , 102 ) ;
2905: LD_VAR 0 3
2909: PPUSH
2910: LD_INT 102
2912: PPUSH
2913: CALL_OW 109
// if IsInUnit ( i ) then
2917: LD_VAR 0 3
2921: PPUSH
2922: CALL_OW 310
2926: IFFALSE 2939
// ComExitBuilding ( i ) else
2928: LD_VAR 0 3
2932: PPUSH
2933: CALL_OW 122
2937: GO 2957
// ComHeal ( i , people [ 1 ] ) ;
2939: LD_VAR 0 3
2943: PPUSH
2944: LD_VAR 0 1
2948: PUSH
2949: LD_INT 1
2951: ARRAY
2952: PPUSH
2953: CALL_OW 128
// end ;
2957: GO 2887
2959: POP
2960: POP
// end else
2961: GO 3006
// if FilterByTag ( sci , 102 ) then
2963: LD_VAR 0 2
2967: PPUSH
2968: LD_INT 102
2970: PPUSH
2971: CALL 46038 0 2
2975: IFFALSE 3006
// begin for i in sci do
2977: LD_ADDR_VAR 0 3
2981: PUSH
2982: LD_VAR 0 2
2986: PUSH
2987: FOR_IN
2988: IFFALSE 3004
// begin SetTag ( i , 0 ) ;
2990: LD_VAR 0 3
2994: PPUSH
2995: LD_INT 0
2997: PPUSH
2998: CALL_OW 109
// end ;
3002: GO 2987
3004: POP
3005: POP
// end ; end ;
3006: PPOPN 3
3008: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3009: LD_INT 22
3011: PUSH
3012: LD_INT 4
3014: PUSH
3015: EMPTY
3016: LIST
3017: LIST
3018: PUSH
3019: LD_INT 33
3021: PUSH
3022: LD_INT 2
3024: PUSH
3025: EMPTY
3026: LIST
3027: LIST
3028: PUSH
3029: LD_INT 50
3031: PUSH
3032: EMPTY
3033: LIST
3034: PUSH
3035: LD_INT 3
3037: PUSH
3038: LD_INT 61
3040: PUSH
3041: EMPTY
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: PUSH
3048: EMPTY
3049: LIST
3050: LIST
3051: LIST
3052: LIST
3053: PPUSH
3054: CALL_OW 69
3058: IFFALSE 3149
3060: GO 3062
3062: DISABLE
3063: LD_INT 0
3065: PPUSH
3066: PPUSH
// begin enable ;
3067: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3068: LD_ADDR_VAR 0 2
3072: PUSH
3073: LD_INT 22
3075: PUSH
3076: LD_INT 4
3078: PUSH
3079: EMPTY
3080: LIST
3081: LIST
3082: PUSH
3083: LD_INT 33
3085: PUSH
3086: LD_INT 2
3088: PUSH
3089: EMPTY
3090: LIST
3091: LIST
3092: PUSH
3093: LD_INT 50
3095: PUSH
3096: EMPTY
3097: LIST
3098: PUSH
3099: LD_INT 3
3101: PUSH
3102: LD_INT 61
3104: PUSH
3105: EMPTY
3106: LIST
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: PUSH
3112: EMPTY
3113: LIST
3114: LIST
3115: LIST
3116: LIST
3117: PPUSH
3118: CALL_OW 69
3122: ST_TO_ADDR
// for i in tmp do
3123: LD_ADDR_VAR 0 1
3127: PUSH
3128: LD_VAR 0 2
3132: PUSH
3133: FOR_IN
3134: IFFALSE 3147
// Connect ( i ) ;
3136: LD_VAR 0 1
3140: PPUSH
3141: CALL 19121 0 1
3145: GO 3133
3147: POP
3148: POP
// end ; end_of_file
3149: PPOPN 2
3151: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3152: LD_INT 0
3154: PPUSH
3155: PPUSH
3156: PPUSH
3157: PPUSH
3158: PPUSH
3159: PPUSH
// gensher_side := 2 ;
3160: LD_ADDR_EXP 14
3164: PUSH
3165: LD_INT 2
3167: ST_TO_ADDR
// uc_side := gensher_side ;
3168: LD_ADDR_OWVAR 20
3172: PUSH
3173: LD_EXP 14
3177: ST_TO_ADDR
// uc_nation := 2 ;
3178: LD_ADDR_OWVAR 21
3182: PUSH
3183: LD_INT 2
3185: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3186: LD_ADDR_VAR 0 6
3190: PUSH
3191: LD_INT 5
3193: PUSH
3194: LD_INT 42
3196: PUSH
3197: LD_INT 29
3199: PUSH
3200: LD_INT 5
3202: PUSH
3203: EMPTY
3204: LIST
3205: LIST
3206: LIST
3207: LIST
3208: PUSH
3209: LD_INT 5
3211: PUSH
3212: LD_INT 36
3214: PUSH
3215: LD_INT 40
3217: PUSH
3218: LD_INT 5
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 6
3229: PUSH
3230: LD_INT 13
3232: PUSH
3233: LD_INT 18
3235: PUSH
3236: LD_INT 1
3238: PUSH
3239: LD_INT 10
3241: PUSH
3242: LD_INT 15
3244: PUSH
3245: EMPTY
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 27
3255: PUSH
3256: LD_INT 17
3258: PUSH
3259: LD_INT 3
3261: PUSH
3262: LD_INT 0
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 29
3273: PUSH
3274: LD_INT 56
3276: PUSH
3277: LD_INT 23
3279: PUSH
3280: LD_INT 0
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 3
3291: PUSH
3292: LD_INT 11
3294: PUSH
3295: LD_INT 7
3297: PUSH
3298: LD_INT 2
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 27
3309: PUSH
3310: LD_INT 20
3312: PUSH
3313: LD_INT 3
3315: PUSH
3316: LD_INT 0
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 27
3327: PUSH
3328: LD_INT 23
3330: PUSH
3331: LD_INT 3
3333: PUSH
3334: LD_INT 0
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 27
3345: PUSH
3346: LD_INT 26
3348: PUSH
3349: LD_INT 3
3351: PUSH
3352: LD_INT 0
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 6
3363: PUSH
3364: LD_INT 17
3366: PUSH
3367: LD_INT 27
3369: PUSH
3370: LD_INT 1
3372: PUSH
3373: LD_INT 13
3375: PUSH
3376: LD_INT 11
3378: PUSH
3379: EMPTY
3380: LIST
3381: LIST
3382: LIST
3383: LIST
3384: LIST
3385: LIST
3386: PUSH
3387: LD_INT 32
3389: PUSH
3390: LD_INT 27
3392: PUSH
3393: LD_INT 44
3395: PUSH
3396: LD_INT 5
3398: PUSH
3399: LD_INT 27
3401: PUSH
3402: EMPTY
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: PUSH
3409: LD_INT 32
3411: PUSH
3412: LD_INT 41
3414: PUSH
3415: LD_INT 41
3417: PUSH
3418: LD_INT 5
3420: PUSH
3421: LD_INT 27
3423: PUSH
3424: EMPTY
3425: LIST
3426: LIST
3427: LIST
3428: LIST
3429: LIST
3430: PUSH
3431: LD_INT 32
3433: PUSH
3434: LD_INT 45
3436: PUSH
3437: LD_INT 24
3439: PUSH
3440: LD_INT 5
3442: PUSH
3443: LD_INT 28
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: LIST
3451: LIST
3452: PUSH
3453: LD_INT 32
3455: PUSH
3456: LD_INT 48
3458: PUSH
3459: LD_INT 19
3461: PUSH
3462: LD_INT 5
3464: PUSH
3465: LD_INT 28
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: LIST
3474: PUSH
3475: LD_INT 32
3477: PUSH
3478: LD_INT 41
3480: PUSH
3481: LD_INT 3
3483: PUSH
3484: LD_INT 4
3486: PUSH
3487: LD_INT 28
3489: PUSH
3490: EMPTY
3491: LIST
3492: LIST
3493: LIST
3494: LIST
3495: LIST
3496: PUSH
3497: LD_INT 5
3499: PUSH
3500: LD_INT 44
3502: PUSH
3503: LD_INT 9
3505: PUSH
3506: LD_INT 4
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: LIST
3513: LIST
3514: PUSH
3515: LD_INT 30
3517: PUSH
3518: LD_INT 52
3520: PUSH
3521: LD_INT 40
3523: PUSH
3524: LD_INT 3
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: PUSH
3533: EMPTY
3534: LIST
3535: LIST
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: LIST
3541: LIST
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: ST_TO_ADDR
// for i in list do
3552: LD_ADDR_VAR 0 2
3556: PUSH
3557: LD_VAR 0 6
3561: PUSH
3562: FOR_IN
3563: IFFALSE 3741
// begin uc_side := 2 ;
3565: LD_ADDR_OWVAR 20
3569: PUSH
3570: LD_INT 2
3572: ST_TO_ADDR
// uc_nation := 2 ;
3573: LD_ADDR_OWVAR 21
3577: PUSH
3578: LD_INT 2
3580: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3581: LD_ADDR_OWVAR 42
3585: PUSH
3586: LD_VAR 0 2
3590: PUSH
3591: LD_INT 1
3593: ARRAY
3594: ST_TO_ADDR
// bc_kind1 := - 1 ;
3595: LD_ADDR_OWVAR 44
3599: PUSH
3600: LD_INT 1
3602: NEG
3603: ST_TO_ADDR
// bc_kind2 := - 1 ;
3604: LD_ADDR_OWVAR 45
3608: PUSH
3609: LD_INT 1
3611: NEG
3612: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3613: LD_VAR 0 2
3617: PUSH
3618: LD_INT 1
3620: ARRAY
3621: PUSH
3622: LD_INT 6
3624: EQUAL
3625: IFFALSE 3663
// begin bc_type := b_lab_full ;
3627: LD_ADDR_OWVAR 42
3631: PUSH
3632: LD_INT 8
3634: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3635: LD_ADDR_OWVAR 44
3639: PUSH
3640: LD_VAR 0 2
3644: PUSH
3645: LD_INT 5
3647: ARRAY
3648: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3649: LD_ADDR_OWVAR 45
3653: PUSH
3654: LD_VAR 0 2
3658: PUSH
3659: LD_INT 6
3661: ARRAY
3662: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3663: LD_ADDR_VAR 0 3
3667: PUSH
3668: LD_VAR 0 2
3672: PUSH
3673: LD_INT 2
3675: ARRAY
3676: PPUSH
3677: LD_VAR 0 2
3681: PUSH
3682: LD_INT 3
3684: ARRAY
3685: PPUSH
3686: LD_VAR 0 2
3690: PUSH
3691: LD_INT 4
3693: ARRAY
3694: PPUSH
3695: CALL_OW 47
3699: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3700: LD_VAR 0 2
3704: PUSH
3705: LD_INT 1
3707: ARRAY
3708: PUSH
3709: LD_INT 33
3711: PUSH
3712: LD_INT 32
3714: PUSH
3715: EMPTY
3716: LIST
3717: LIST
3718: IN
3719: IFFALSE 3739
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3721: LD_VAR 0 3
3725: PPUSH
3726: LD_VAR 0 2
3730: PUSH
3731: LD_INT 5
3733: ARRAY
3734: PPUSH
3735: CALL_OW 431
// end ;
3739: GO 3562
3741: POP
3742: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3743: LD_ADDR_VAR 0 4
3747: PUSH
3748: LD_INT 7
3750: PPUSH
3751: LD_INT 2
3753: PPUSH
3754: LD_STRING 
3756: PPUSH
3757: LD_INT 8
3759: PUSH
3760: LD_INT 7
3762: PUSH
3763: LD_INT 6
3765: PUSH
3766: EMPTY
3767: LIST
3768: LIST
3769: LIST
3770: PUSH
3771: LD_OWVAR 67
3775: ARRAY
3776: PPUSH
3777: LD_INT 11500
3779: PUSH
3780: LD_INT 1100
3782: PUSH
3783: LD_INT 60
3785: PUSH
3786: EMPTY
3787: LIST
3788: LIST
3789: LIST
3790: PPUSH
3791: LD_INT 6
3793: PUSH
3794: LD_INT 6
3796: PUSH
3797: LD_INT 6
3799: PUSH
3800: LD_INT 6
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: LIST
3807: LIST
3808: PPUSH
3809: CALL 19474 0 6
3813: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3814: LD_ADDR_EXP 23
3818: PUSH
3819: LD_EXP 23
3823: PPUSH
3824: LD_INT 2
3826: PPUSH
3827: LD_VAR 0 4
3831: PUSH
3832: LD_INT 22
3834: PUSH
3835: LD_INT 2
3837: PUSH
3838: EMPTY
3839: LIST
3840: LIST
3841: PUSH
3842: LD_INT 21
3844: PUSH
3845: LD_INT 3
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: PPUSH
3856: CALL_OW 69
3860: UNION
3861: PPUSH
3862: CALL_OW 1
3866: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3867: LD_ADDR_VAR 0 4
3871: PUSH
3872: LD_INT 22
3874: PUSH
3875: LD_INT 2
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: LD_INT 30
3884: PUSH
3885: LD_INT 31
3887: PUSH
3888: EMPTY
3889: LIST
3890: LIST
3891: PUSH
3892: EMPTY
3893: LIST
3894: LIST
3895: PPUSH
3896: CALL_OW 69
3900: ST_TO_ADDR
// for i in tmp do
3901: LD_ADDR_VAR 0 2
3905: PUSH
3906: LD_VAR 0 4
3910: PUSH
3911: FOR_IN
3912: IFFALSE 3982
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3914: LD_INT 0
3916: PPUSH
3917: LD_INT 1
3919: PPUSH
3920: LD_INT 4
3922: PUSH
3923: LD_INT 3
3925: PUSH
3926: LD_INT 3
3928: PUSH
3929: EMPTY
3930: LIST
3931: LIST
3932: LIST
3933: PUSH
3934: LD_OWVAR 67
3938: ARRAY
3939: PPUSH
3940: CALL_OW 380
// un := CreateHuman ;
3944: LD_ADDR_VAR 0 5
3948: PUSH
3949: CALL_OW 44
3953: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3954: LD_VAR 0 5
3958: PPUSH
3959: LD_INT 1
3961: PPUSH
3962: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3966: LD_VAR 0 5
3970: PPUSH
3971: LD_VAR 0 2
3975: PPUSH
3976: CALL_OW 52
// end ;
3980: GO 3911
3982: POP
3983: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3984: LD_ADDR_VAR 0 4
3988: PUSH
3989: LD_INT 15
3991: PPUSH
3992: LD_INT 0
3994: PPUSH
3995: CALL_OW 517
3999: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: DOUBLE
4006: LD_INT 1
4008: DEC
4009: ST_TO_ADDR
4010: LD_VAR 0 4
4014: PUSH
4015: LD_INT 1
4017: ARRAY
4018: PUSH
4019: FOR_TO
4020: IFFALSE 4122
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4022: LD_VAR 0 4
4026: PUSH
4027: LD_INT 1
4029: ARRAY
4030: PUSH
4031: LD_VAR 0 2
4035: ARRAY
4036: PPUSH
4037: LD_VAR 0 4
4041: PUSH
4042: LD_INT 2
4044: ARRAY
4045: PUSH
4046: LD_VAR 0 2
4050: ARRAY
4051: PPUSH
4052: LD_INT 2
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4062: LD_ADDR_EXP 3
4066: PUSH
4067: LD_EXP 3
4071: PPUSH
4072: LD_EXP 3
4076: PUSH
4077: LD_INT 1
4079: PLUS
4080: PPUSH
4081: LD_VAR 0 4
4085: PUSH
4086: LD_INT 1
4088: ARRAY
4089: PUSH
4090: LD_VAR 0 2
4094: ARRAY
4095: PUSH
4096: LD_VAR 0 4
4100: PUSH
4101: LD_INT 2
4103: ARRAY
4104: PUSH
4105: LD_VAR 0 2
4109: ARRAY
4110: PUSH
4111: EMPTY
4112: LIST
4113: LIST
4114: PPUSH
4115: CALL_OW 2
4119: ST_TO_ADDR
// end ;
4120: GO 4019
4122: POP
4123: POP
// if Difficulty > 1 then
4124: LD_OWVAR 67
4128: PUSH
4129: LD_INT 1
4131: GREATER
4132: IFFALSE 4274
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4134: LD_ADDR_VAR 0 4
4138: PUSH
4139: LD_INT 19
4141: PPUSH
4142: LD_INT 0
4144: PPUSH
4145: CALL_OW 517
4149: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4150: LD_ADDR_VAR 0 2
4154: PUSH
4155: DOUBLE
4156: LD_INT 1
4158: DEC
4159: ST_TO_ADDR
4160: LD_VAR 0 4
4164: PUSH
4165: LD_INT 1
4167: ARRAY
4168: PUSH
4169: FOR_TO
4170: IFFALSE 4272
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4172: LD_VAR 0 4
4176: PUSH
4177: LD_INT 1
4179: ARRAY
4180: PUSH
4181: LD_VAR 0 2
4185: ARRAY
4186: PPUSH
4187: LD_VAR 0 4
4191: PUSH
4192: LD_INT 2
4194: ARRAY
4195: PUSH
4196: LD_VAR 0 2
4200: ARRAY
4201: PPUSH
4202: LD_INT 2
4204: PPUSH
4205: LD_INT 0
4207: PPUSH
4208: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4212: LD_ADDR_EXP 3
4216: PUSH
4217: LD_EXP 3
4221: PPUSH
4222: LD_EXP 3
4226: PUSH
4227: LD_INT 1
4229: PLUS
4230: PPUSH
4231: LD_VAR 0 4
4235: PUSH
4236: LD_INT 1
4238: ARRAY
4239: PUSH
4240: LD_VAR 0 2
4244: ARRAY
4245: PUSH
4246: LD_VAR 0 4
4250: PUSH
4251: LD_INT 2
4253: ARRAY
4254: PUSH
4255: LD_VAR 0 2
4259: ARRAY
4260: PUSH
4261: EMPTY
4262: LIST
4263: LIST
4264: PPUSH
4265: CALL_OW 2
4269: ST_TO_ADDR
// end ;
4270: GO 4169
4272: POP
4273: POP
// end ; gensherAttackGroup := [ ] ;
4274: LD_ADDR_EXP 15
4278: PUSH
4279: EMPTY
4280: ST_TO_ADDR
// end ;
4281: LD_VAR 0 1
4285: RET
// export function InitMC_Gensher ( ) ; begin
4286: LD_INT 0
4288: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4289: LD_INT 2
4291: PPUSH
4292: LD_INT 2
4294: PPUSH
4295: CALL 77822 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4299: LD_INT 2
4301: PPUSH
4302: LD_INT 9
4304: PPUSH
4305: CALL 77766 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4309: LD_INT 2
4311: PPUSH
4312: LD_INT 56
4314: PUSH
4315: LD_INT 23
4317: PUSH
4318: LD_INT 0
4320: PUSH
4321: EMPTY
4322: LIST
4323: LIST
4324: LIST
4325: PUSH
4326: LD_INT 52
4328: PUSH
4329: LD_INT 40
4331: PUSH
4332: LD_INT 1
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: LIST
4339: PUSH
4340: EMPTY
4341: LIST
4342: LIST
4343: PPUSH
4344: CALL 76825 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4348: LD_INT 2
4350: PPUSH
4351: LD_INT 27
4353: PUSH
4354: LD_INT 28
4356: PUSH
4357: EMPTY
4358: LIST
4359: LIST
4360: PPUSH
4361: CALL 77654 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4365: LD_INT 2
4367: PPUSH
4368: LD_INT 8
4370: PPUSH
4371: CALL 77336 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4375: LD_INT 2
4377: PPUSH
4378: LD_INT 7
4380: PPUSH
4381: CALL 77067 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4385: LD_INT 2
4387: PPUSH
4388: LD_INT 4
4390: PPUSH
4391: CALL 76686 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4395: LD_INT 2
4397: PPUSH
4398: LD_INT 13
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: LD_INT 1
4406: PUSH
4407: LD_INT 31
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_INT 13
4418: PUSH
4419: LD_INT 2
4421: PUSH
4422: LD_INT 1
4424: PUSH
4425: LD_INT 31
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: LIST
4432: LIST
4433: PUSH
4434: LD_INT 14
4436: PUSH
4437: LD_INT 1
4439: PUSH
4440: LD_INT 2
4442: PUSH
4443: LD_INT 27
4445: PUSH
4446: EMPTY
4447: LIST
4448: LIST
4449: LIST
4450: LIST
4451: PUSH
4452: LD_INT 14
4454: PUSH
4455: LD_INT 1
4457: PUSH
4458: LD_INT 2
4460: PUSH
4461: LD_INT 27
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: PUSH
4470: LD_INT 14
4472: PUSH
4473: LD_INT 1
4475: PUSH
4476: LD_INT 2
4478: PUSH
4479: LD_INT 28
4481: PUSH
4482: EMPTY
4483: LIST
4484: LIST
4485: LIST
4486: LIST
4487: PUSH
4488: LD_INT 14
4490: PUSH
4491: LD_INT 1
4493: PUSH
4494: LD_INT 2
4496: PUSH
4497: LD_INT 26
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: EMPTY
4507: LIST
4508: LIST
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PPUSH
4514: CALL 76501 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4518: LD_INT 2
4520: PPUSH
4521: LD_INT 11
4523: PPUSH
4524: LD_INT 7
4526: PPUSH
4527: LD_INT 2
4529: PPUSH
4530: LD_INT 23
4532: PUSH
4533: LD_INT 16
4535: PUSH
4536: LD_INT 17
4538: PUSH
4539: LD_INT 18
4541: PUSH
4542: LD_INT 22
4544: PUSH
4545: EMPTY
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: PPUSH
4552: CALL 77448 0 5
// end ;
4556: LD_VAR 0 1
4560: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4561: LD_EXP 3
4565: PUSH
4566: LD_INT 15
4568: PPUSH
4569: LD_INT 81
4571: PUSH
4572: LD_INT 2
4574: PUSH
4575: EMPTY
4576: LIST
4577: LIST
4578: PPUSH
4579: CALL_OW 70
4583: AND
4584: IFFALSE 4797
4586: GO 4588
4588: DISABLE
4589: LD_INT 0
4591: PPUSH
4592: PPUSH
4593: PPUSH
4594: PPUSH
4595: PPUSH
// begin enable ;
4596: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4597: LD_ADDR_VAR 0 3
4601: PUSH
4602: LD_INT 15
4604: PPUSH
4605: LD_INT 81
4607: PUSH
4608: LD_INT 2
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: PPUSH
4615: CALL_OW 70
4619: ST_TO_ADDR
// if not tmp then
4620: LD_VAR 0 3
4624: NOT
4625: IFFALSE 4629
// exit ;
4627: GO 4797
// for i in tmp do
4629: LD_ADDR_VAR 0 1
4633: PUSH
4634: LD_VAR 0 3
4638: PUSH
4639: FOR_IN
4640: IFFALSE 4795
// begin x := GetX ( i ) ;
4642: LD_ADDR_VAR 0 4
4646: PUSH
4647: LD_VAR 0 1
4651: PPUSH
4652: CALL_OW 250
4656: ST_TO_ADDR
// y := GetY ( i ) ;
4657: LD_ADDR_VAR 0 5
4661: PUSH
4662: LD_VAR 0 1
4666: PPUSH
4667: CALL_OW 251
4671: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4672: LD_VAR 0 4
4676: PPUSH
4677: LD_VAR 0 5
4681: PPUSH
4682: CALL_OW 458
4686: IFFALSE 4793
// begin LaunchMineAtPos ( x , y , 2 ) ;
4688: LD_VAR 0 4
4692: PPUSH
4693: LD_VAR 0 5
4697: PPUSH
4698: LD_INT 2
4700: PPUSH
4701: CALL_OW 456
// for j = 1 to staticMines do
4705: LD_ADDR_VAR 0 2
4709: PUSH
4710: DOUBLE
4711: LD_INT 1
4713: DEC
4714: ST_TO_ADDR
4715: LD_EXP 3
4719: PUSH
4720: FOR_TO
4721: IFFALSE 4791
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4723: LD_EXP 3
4727: PUSH
4728: LD_VAR 0 2
4732: ARRAY
4733: PUSH
4734: LD_INT 1
4736: ARRAY
4737: PUSH
4738: LD_VAR 0 4
4742: EQUAL
4743: PUSH
4744: LD_EXP 3
4748: PUSH
4749: LD_VAR 0 2
4753: ARRAY
4754: PUSH
4755: LD_INT 2
4757: ARRAY
4758: PUSH
4759: LD_VAR 0 5
4763: EQUAL
4764: AND
4765: IFFALSE 4789
// begin staticMines := Delete ( staticMines , j ) ;
4767: LD_ADDR_EXP 3
4771: PUSH
4772: LD_EXP 3
4776: PPUSH
4777: LD_VAR 0 2
4781: PPUSH
4782: CALL_OW 3
4786: ST_TO_ADDR
// break ;
4787: GO 4791
// end ;
4789: GO 4720
4791: POP
4792: POP
// end ; end ;
4793: GO 4639
4795: POP
4796: POP
// end ;
4797: PPOPN 5
4799: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4800: LD_INT 7
4802: PPUSH
4803: CALL_OW 302
4807: PUSH
4808: LD_EXP 4
4812: NOT
4813: AND
4814: IFFALSE 5414
4816: GO 4818
4818: DISABLE
4819: LD_INT 0
4821: PPUSH
4822: PPUSH
4823: PPUSH
4824: PPUSH
4825: PPUSH
// begin enable ;
4826: ENABLE
// base := 2 ;
4827: LD_ADDR_VAR 0 2
4831: PUSH
4832: LD_INT 2
4834: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4835: LD_ADDR_VAR 0 3
4839: PUSH
4840: LD_INT 14
4842: PUSH
4843: LD_INT 1
4845: PUSH
4846: LD_INT 2
4848: PUSH
4849: LD_INT 27
4851: PUSH
4852: EMPTY
4853: LIST
4854: LIST
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 14
4860: PUSH
4861: LD_INT 1
4863: PUSH
4864: LD_INT 2
4866: PUSH
4867: LD_INT 27
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: PUSH
4876: LD_INT 14
4878: PUSH
4879: LD_INT 1
4881: PUSH
4882: LD_INT 2
4884: PUSH
4885: LD_INT 92
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 14
4896: PUSH
4897: LD_INT 1
4899: PUSH
4900: LD_INT 2
4902: PUSH
4903: LD_INT 26
4905: PUSH
4906: EMPTY
4907: LIST
4908: LIST
4909: LIST
4910: LIST
4911: PUSH
4912: EMPTY
4913: LIST
4914: LIST
4915: LIST
4916: LIST
4917: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4918: LD_ADDR_VAR 0 5
4922: PUSH
4923: LD_VAR 0 5
4927: PUSH
4928: LD_OWVAR 1
4932: PUSH
4933: LD_INT 21000
4935: DIV
4936: PLUS
4937: ST_TO_ADDR
// if amount > 8 then
4938: LD_VAR 0 5
4942: PUSH
4943: LD_INT 8
4945: GREATER
4946: IFFALSE 4956
// amount := 8 ;
4948: LD_ADDR_VAR 0 5
4952: PUSH
4953: LD_INT 8
4955: ST_TO_ADDR
// for i = 1 to amount do
4956: LD_ADDR_VAR 0 1
4960: PUSH
4961: DOUBLE
4962: LD_INT 1
4964: DEC
4965: ST_TO_ADDR
4966: LD_VAR 0 5
4970: PUSH
4971: FOR_TO
4972: IFFALSE 5060
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4974: LD_ADDR_VAR 0 3
4978: PUSH
4979: LD_VAR 0 3
4983: PPUSH
4984: LD_VAR 0 3
4988: PUSH
4989: LD_INT 1
4991: PLUS
4992: PPUSH
4993: LD_INT 14
4995: PUSH
4996: LD_INT 13
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 1
5005: PPUSH
5006: LD_INT 2
5008: PPUSH
5009: CALL_OW 12
5013: ARRAY
5014: PUSH
5015: LD_INT 1
5017: PUSH
5018: LD_INT 2
5020: PUSH
5021: LD_INT 28
5023: PUSH
5024: LD_INT 25
5026: PUSH
5027: LD_INT 27
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: PUSH
5035: LD_INT 1
5037: PPUSH
5038: LD_INT 3
5040: PPUSH
5041: CALL_OW 12
5045: ARRAY
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: LIST
5051: LIST
5052: PPUSH
5053: CALL_OW 2
5057: ST_TO_ADDR
5058: GO 4971
5060: POP
5061: POP
// MC_InsertProduceList ( base , tmp ) ;
5062: LD_VAR 0 2
5066: PPUSH
5067: LD_VAR 0 3
5071: PPUSH
5072: CALL 76549 0 2
// repeat wait ( 0 0$1 ) ;
5076: LD_INT 35
5078: PPUSH
5079: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5083: LD_VAR 0 2
5087: PPUSH
5088: LD_INT 1
5090: PPUSH
5091: CALL 77967 0 2
5095: PUSH
5096: LD_VAR 0 5
5100: GREATEREQUAL
5101: IFFALSE 5076
// wait ( 0 0$30 ) ;
5103: LD_INT 1050
5105: PPUSH
5106: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5110: LD_ADDR_VAR 0 4
5114: PUSH
5115: LD_EXP 42
5119: PUSH
5120: LD_VAR 0 2
5124: ARRAY
5125: PUSH
5126: LD_EXP 42
5130: PUSH
5131: LD_VAR 0 2
5135: ARRAY
5136: PPUSH
5137: LD_INT 2
5139: PUSH
5140: LD_INT 34
5142: PUSH
5143: LD_INT 31
5145: PUSH
5146: EMPTY
5147: LIST
5148: LIST
5149: PUSH
5150: LD_INT 34
5152: PUSH
5153: LD_INT 32
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 34
5162: PUSH
5163: LD_INT 88
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PPUSH
5176: CALL_OW 72
5180: DIFF
5181: ST_TO_ADDR
// if not attackers then
5182: LD_VAR 0 4
5186: NOT
5187: IFFALSE 5191
// exit ;
5189: GO 5414
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5191: LD_ADDR_EXP 42
5195: PUSH
5196: LD_EXP 42
5200: PPUSH
5201: LD_VAR 0 2
5205: PPUSH
5206: LD_EXP 42
5210: PUSH
5211: LD_VAR 0 2
5215: ARRAY
5216: PUSH
5217: LD_VAR 0 4
5221: DIFF
5222: PPUSH
5223: CALL_OW 1
5227: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5228: LD_VAR 0 4
5232: PPUSH
5233: LD_INT 107
5235: PPUSH
5236: LD_INT 74
5238: PPUSH
5239: CALL_OW 114
// wait ( 0 0$5 ) ;
5243: LD_INT 175
5245: PPUSH
5246: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5250: LD_INT 35
5252: PPUSH
5253: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5257: LD_VAR 0 4
5261: PPUSH
5262: LD_INT 60
5264: PUSH
5265: EMPTY
5266: LIST
5267: PPUSH
5268: CALL_OW 72
5272: NOT
5273: IFFALSE 5250
// if rand ( 0 , 1 ) then
5275: LD_INT 0
5277: PPUSH
5278: LD_INT 1
5280: PPUSH
5281: CALL_OW 12
5285: IFFALSE 5304
// ComAgressiveMove ( attackers , 155 , 108 ) else
5287: LD_VAR 0 4
5291: PPUSH
5292: LD_INT 155
5294: PPUSH
5295: LD_INT 108
5297: PPUSH
5298: CALL_OW 114
5302: GO 5319
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5304: LD_VAR 0 4
5308: PPUSH
5309: LD_INT 149
5311: PPUSH
5312: LD_INT 55
5314: PPUSH
5315: CALL_OW 114
// wait ( 0 0$10 ) ;
5319: LD_INT 350
5321: PPUSH
5322: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5326: LD_INT 35
5328: PPUSH
5329: CALL_OW 67
// for i in attackers do
5333: LD_ADDR_VAR 0 1
5337: PUSH
5338: LD_VAR 0 4
5342: PUSH
5343: FOR_IN
5344: IFFALSE 5394
// if not HasTask ( i ) then
5346: LD_VAR 0 1
5350: PPUSH
5351: CALL_OW 314
5355: NOT
5356: IFFALSE 5392
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5358: LD_VAR 0 1
5362: PPUSH
5363: LD_INT 81
5365: PUSH
5366: LD_INT 2
5368: PUSH
5369: EMPTY
5370: LIST
5371: LIST
5372: PPUSH
5373: CALL_OW 69
5377: PPUSH
5378: LD_VAR 0 1
5382: PPUSH
5383: CALL_OW 74
5387: PPUSH
5388: CALL_OW 115
5392: GO 5343
5394: POP
5395: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5396: LD_VAR 0 4
5400: PPUSH
5401: LD_INT 50
5403: PUSH
5404: EMPTY
5405: LIST
5406: PPUSH
5407: CALL_OW 72
5411: NOT
5412: IFFALSE 5326
// end ;
5414: PPOPN 5
5416: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5417: LD_EXP 4
5421: NOT
5422: PUSH
5423: LD_OWVAR 1
5427: PUSH
5428: LD_INT 191100
5430: LESS
5431: AND
5432: IFFALSE 6104
5434: GO 5436
5436: DISABLE
5437: LD_INT 0
5439: PPUSH
5440: PPUSH
5441: PPUSH
// begin enable ;
5442: ENABLE
// tmp := [ ] ;
5443: LD_ADDR_VAR 0 3
5447: PUSH
5448: EMPTY
5449: ST_TO_ADDR
// if tick < 35 35$00 then
5450: LD_OWVAR 1
5454: PUSH
5455: LD_INT 73500
5457: LESS
5458: IFFALSE 5656
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5460: LD_ADDR_VAR 0 1
5464: PUSH
5465: DOUBLE
5466: LD_INT 1
5468: DEC
5469: ST_TO_ADDR
5470: LD_INT 4
5472: PUSH
5473: LD_INT 5
5475: PUSH
5476: LD_INT 5
5478: PUSH
5479: EMPTY
5480: LIST
5481: LIST
5482: LIST
5483: PUSH
5484: LD_OWVAR 67
5488: ARRAY
5489: PUSH
5490: FOR_TO
5491: IFFALSE 5652
// begin uc_side := 2 ;
5493: LD_ADDR_OWVAR 20
5497: PUSH
5498: LD_INT 2
5500: ST_TO_ADDR
// uc_nation := 2 ;
5501: LD_ADDR_OWVAR 21
5505: PUSH
5506: LD_INT 2
5508: ST_TO_ADDR
// InitHC_All ( ) ;
5509: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5513: LD_INT 0
5515: PPUSH
5516: LD_INT 1
5518: PPUSH
5519: LD_INT 5
5521: PUSH
5522: LD_INT 6
5524: PUSH
5525: LD_INT 7
5527: PUSH
5528: EMPTY
5529: LIST
5530: LIST
5531: LIST
5532: PUSH
5533: LD_OWVAR 67
5537: ARRAY
5538: PPUSH
5539: CALL_OW 380
// un := CreateHuman ;
5543: LD_ADDR_VAR 0 2
5547: PUSH
5548: CALL_OW 44
5552: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5553: LD_VAR 0 2
5557: PPUSH
5558: LD_INT 17
5560: PPUSH
5561: LD_INT 0
5563: PPUSH
5564: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5568: LD_VAR 0 2
5572: PPUSH
5573: LD_INT 1
5575: PUSH
5576: LD_INT 8
5578: PUSH
5579: EMPTY
5580: LIST
5581: LIST
5582: PUSH
5583: LD_INT 1
5585: PPUSH
5586: LD_INT 2
5588: PPUSH
5589: CALL_OW 12
5593: ARRAY
5594: PPUSH
5595: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5599: LD_VAR 0 2
5603: PPUSH
5604: LD_INT 111
5606: PPUSH
5607: LD_INT 34
5609: PPUSH
5610: CALL_OW 114
// wait ( 0 0$2 ) ;
5614: LD_INT 70
5616: PPUSH
5617: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5621: LD_ADDR_VAR 0 3
5625: PUSH
5626: LD_VAR 0 3
5630: PPUSH
5631: LD_VAR 0 3
5635: PUSH
5636: LD_INT 1
5638: PLUS
5639: PPUSH
5640: LD_VAR 0 2
5644: PPUSH
5645: CALL_OW 1
5649: ST_TO_ADDR
// end ;
5650: GO 5490
5652: POP
5653: POP
// end else
5654: GO 5797
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5656: LD_ADDR_VAR 0 1
5660: PUSH
5661: DOUBLE
5662: LD_INT 1
5664: DEC
5665: ST_TO_ADDR
5666: LD_INT 4
5668: PUSH
5669: LD_INT 5
5671: PUSH
5672: LD_INT 5
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: PUSH
5680: LD_OWVAR 67
5684: ARRAY
5685: PUSH
5686: FOR_TO
5687: IFFALSE 5795
// begin uc_side := 2 ;
5689: LD_ADDR_OWVAR 20
5693: PUSH
5694: LD_INT 2
5696: ST_TO_ADDR
// uc_nation := 0 ;
5697: LD_ADDR_OWVAR 21
5701: PUSH
5702: LD_INT 0
5704: ST_TO_ADDR
// InitHC_All ( ) ;
5705: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5709: LD_ADDR_OWVAR 28
5713: PUSH
5714: LD_INT 17
5716: ST_TO_ADDR
// un := CreateHuman ;
5717: LD_ADDR_VAR 0 2
5721: PUSH
5722: CALL_OW 44
5726: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5727: LD_VAR 0 2
5731: PPUSH
5732: LD_INT 17
5734: PPUSH
5735: LD_INT 0
5737: PPUSH
5738: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5742: LD_VAR 0 2
5746: PPUSH
5747: LD_INT 110
5749: PPUSH
5750: LD_INT 33
5752: PPUSH
5753: CALL_OW 114
// wait ( 0 0$2 ) ;
5757: LD_INT 70
5759: PPUSH
5760: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5764: LD_ADDR_VAR 0 3
5768: PUSH
5769: LD_VAR 0 3
5773: PPUSH
5774: LD_VAR 0 3
5778: PUSH
5779: LD_INT 1
5781: PLUS
5782: PPUSH
5783: LD_VAR 0 2
5787: PPUSH
5788: CALL_OW 1
5792: ST_TO_ADDR
// end ;
5793: GO 5686
5795: POP
5796: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5797: LD_ADDR_VAR 0 1
5801: PUSH
5802: DOUBLE
5803: LD_INT 1
5805: DEC
5806: ST_TO_ADDR
5807: LD_INT 3
5809: PUSH
5810: LD_INT 4
5812: PUSH
5813: LD_INT 5
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: LIST
5820: PUSH
5821: LD_OWVAR 67
5825: ARRAY
5826: PUSH
5827: FOR_TO
5828: IFFALSE 5993
// begin uc_side := 2 ;
5830: LD_ADDR_OWVAR 20
5834: PUSH
5835: LD_INT 2
5837: ST_TO_ADDR
// uc_nation := 2 ;
5838: LD_ADDR_OWVAR 21
5842: PUSH
5843: LD_INT 2
5845: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5846: LD_INT 14
5848: PPUSH
5849: LD_INT 3
5851: PPUSH
5852: LD_INT 5
5854: PPUSH
5855: LD_INT 29
5857: PUSH
5858: LD_INT 28
5860: PUSH
5861: LD_INT 27
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 1
5871: PPUSH
5872: LD_INT 3
5874: PPUSH
5875: CALL_OW 12
5879: ARRAY
5880: PPUSH
5881: LD_INT 90
5883: PPUSH
5884: CALL 16030 0 5
// un := CreateVehicle ;
5888: LD_ADDR_VAR 0 2
5892: PUSH
5893: CALL_OW 45
5897: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5898: LD_VAR 0 2
5902: PPUSH
5903: LD_INT 2
5905: PPUSH
5906: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5910: LD_VAR 0 2
5914: PPUSH
5915: LD_INT 17
5917: PPUSH
5918: LD_INT 0
5920: PPUSH
5921: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5925: LD_VAR 0 2
5929: PPUSH
5930: LD_INT 66
5932: PPUSH
5933: LD_INT 23
5935: PPUSH
5936: CALL_OW 111
// wait ( 0 0$3 ) ;
5940: LD_INT 105
5942: PPUSH
5943: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5947: LD_VAR 0 2
5951: PPUSH
5952: LD_INT 147
5954: PPUSH
5955: LD_INT 103
5957: PPUSH
5958: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5962: LD_ADDR_VAR 0 3
5966: PUSH
5967: LD_VAR 0 3
5971: PPUSH
5972: LD_VAR 0 3
5976: PUSH
5977: LD_INT 1
5979: PLUS
5980: PPUSH
5981: LD_VAR 0 2
5985: PPUSH
5986: CALL_OW 1
5990: ST_TO_ADDR
// end ;
5991: GO 5827
5993: POP
5994: POP
// if not tmp then
5995: LD_VAR 0 3
5999: NOT
6000: IFFALSE 6004
// exit ;
6002: GO 6104
// wait ( 0 0$5 ) ;
6004: LD_INT 175
6006: PPUSH
6007: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6011: LD_INT 70
6013: PPUSH
6014: CALL_OW 67
// for i in tmp do
6018: LD_ADDR_VAR 0 1
6022: PUSH
6023: LD_VAR 0 3
6027: PUSH
6028: FOR_IN
6029: IFFALSE 6095
// begin if not IsOk ( i ) then
6031: LD_VAR 0 1
6035: PPUSH
6036: CALL_OW 302
6040: NOT
6041: IFFALSE 6059
// tmp := tmp diff i ;
6043: LD_ADDR_VAR 0 3
6047: PUSH
6048: LD_VAR 0 3
6052: PUSH
6053: LD_VAR 0 1
6057: DIFF
6058: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6059: LD_VAR 0 1
6063: PPUSH
6064: LD_INT 81
6066: PUSH
6067: LD_INT 2
6069: PUSH
6070: EMPTY
6071: LIST
6072: LIST
6073: PPUSH
6074: CALL_OW 69
6078: PPUSH
6079: LD_VAR 0 1
6083: PPUSH
6084: CALL_OW 74
6088: PPUSH
6089: CALL_OW 115
// end ;
6093: GO 6028
6095: POP
6096: POP
// until not tmp ;
6097: LD_VAR 0 3
6101: NOT
6102: IFFALSE 6011
// end ;
6104: PPOPN 3
6106: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6107: LD_OWVAR 67
6111: PUSH
6112: LD_INT 1
6114: GREATER
6115: IFFALSE 6213
6117: GO 6119
6119: DISABLE
6120: LD_INT 0
6122: PPUSH
// begin uc_side := 2 ;
6123: LD_ADDR_OWVAR 20
6127: PUSH
6128: LD_INT 2
6130: ST_TO_ADDR
// uc_nation := 2 ;
6131: LD_ADDR_OWVAR 21
6135: PUSH
6136: LD_INT 2
6138: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6139: LD_INT 0
6141: PPUSH
6142: LD_INT 4
6144: PPUSH
6145: LD_INT 6
6147: PPUSH
6148: CALL_OW 380
// un := CreateHuman ;
6152: LD_ADDR_VAR 0 1
6156: PUSH
6157: CALL_OW 44
6161: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6162: LD_VAR 0 1
6166: PPUSH
6167: LD_INT 88
6169: PPUSH
6170: LD_INT 1
6172: PPUSH
6173: LD_INT 2
6175: PPUSH
6176: LD_INT 0
6178: PPUSH
6179: CALL 50604 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6183: LD_VAR 0 1
6187: PPUSH
6188: LD_INT 130
6190: PPUSH
6191: LD_INT 35
6193: PPUSH
6194: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 132
6205: PPUSH
6206: LD_INT 39
6208: PPUSH
6209: CALL_OW 218
// end ;
6213: PPOPN 1
6215: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6216: LD_INT 22
6218: PUSH
6219: LD_INT 2
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 33
6228: PUSH
6229: LD_INT 2
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 50
6238: PUSH
6239: EMPTY
6240: LIST
6241: PUSH
6242: LD_INT 3
6244: PUSH
6245: LD_INT 61
6247: PUSH
6248: EMPTY
6249: LIST
6250: PUSH
6251: EMPTY
6252: LIST
6253: LIST
6254: PUSH
6255: EMPTY
6256: LIST
6257: LIST
6258: LIST
6259: LIST
6260: PPUSH
6261: CALL_OW 69
6265: IFFALSE 6356
6267: GO 6269
6269: DISABLE
6270: LD_INT 0
6272: PPUSH
6273: PPUSH
// begin enable ;
6274: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6275: LD_ADDR_VAR 0 2
6279: PUSH
6280: LD_INT 22
6282: PUSH
6283: LD_INT 2
6285: PUSH
6286: EMPTY
6287: LIST
6288: LIST
6289: PUSH
6290: LD_INT 33
6292: PUSH
6293: LD_INT 2
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PUSH
6300: LD_INT 50
6302: PUSH
6303: EMPTY
6304: LIST
6305: PUSH
6306: LD_INT 3
6308: PUSH
6309: LD_INT 61
6311: PUSH
6312: EMPTY
6313: LIST
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PPUSH
6325: CALL_OW 69
6329: ST_TO_ADDR
// for i in tmp do
6330: LD_ADDR_VAR 0 1
6334: PUSH
6335: LD_VAR 0 2
6339: PUSH
6340: FOR_IN
6341: IFFALSE 6354
// Connect ( i ) ;
6343: LD_VAR 0 1
6347: PPUSH
6348: CALL 19121 0 1
6352: GO 6340
6354: POP
6355: POP
// end ; end_of_file
6356: PPOPN 2
6358: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
6364: PPUSH
6365: PPUSH
6366: PPUSH
// popov_side := 3 ;
6367: LD_ADDR_EXP 17
6371: PUSH
6372: LD_INT 3
6374: ST_TO_ADDR
// uc_side := popov_side ;
6375: LD_ADDR_OWVAR 20
6379: PUSH
6380: LD_EXP 17
6384: ST_TO_ADDR
// uc_nation := 3 ;
6385: LD_ADDR_OWVAR 21
6389: PUSH
6390: LD_INT 3
6392: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6393: LD_ADDR_VAR 0 6
6397: PUSH
6398: LD_INT 5
6400: PUSH
6401: LD_INT 103
6403: PUSH
6404: LD_INT 147
6406: PUSH
6407: LD_INT 3
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: LIST
6414: LIST
6415: PUSH
6416: LD_INT 5
6418: PUSH
6419: LD_INT 70
6421: PUSH
6422: LD_INT 117
6424: PUSH
6425: LD_INT 3
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: LIST
6432: LIST
6433: PUSH
6434: LD_INT 6
6436: PUSH
6437: LD_INT 76
6439: PUSH
6440: LD_INT 145
6442: PUSH
6443: LD_INT 1
6445: PUSH
6446: LD_INT 10
6448: PUSH
6449: LD_INT 11
6451: PUSH
6452: EMPTY
6453: LIST
6454: LIST
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: PUSH
6460: LD_INT 26
6462: PUSH
6463: LD_INT 87
6465: PUSH
6466: LD_INT 144
6468: PUSH
6469: LD_INT 0
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: LIST
6476: LIST
6477: PUSH
6478: LD_INT 29
6480: PUSH
6481: LD_INT 86
6483: PUSH
6484: LD_INT 118
6486: PUSH
6487: LD_INT 0
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: PUSH
6496: LD_INT 29
6498: PUSH
6499: LD_INT 98
6501: PUSH
6502: LD_INT 121
6504: PUSH
6505: LD_INT 0
6507: PUSH
6508: EMPTY
6509: LIST
6510: LIST
6511: LIST
6512: LIST
6513: PUSH
6514: LD_INT 26
6516: PUSH
6517: LD_INT 87
6519: PUSH
6520: LD_INT 147
6522: PUSH
6523: LD_INT 1
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 30
6534: PUSH
6535: LD_INT 123
6537: PUSH
6538: LD_INT 151
6540: PUSH
6541: LD_INT 1
6543: PUSH
6544: EMPTY
6545: LIST
6546: LIST
6547: LIST
6548: LIST
6549: PUSH
6550: LD_INT 3
6552: PUSH
6553: LD_INT 94
6555: PUSH
6556: LD_INT 161
6558: PUSH
6559: LD_INT 0
6561: PUSH
6562: EMPTY
6563: LIST
6564: LIST
6565: LIST
6566: LIST
6567: PUSH
6568: LD_INT 6
6570: PUSH
6571: LD_INT 81
6573: PUSH
6574: LD_INT 155
6576: PUSH
6577: LD_INT 1
6579: PUSH
6580: LD_INT 12
6582: PUSH
6583: LD_INT 14
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: LIST
6592: LIST
6593: PUSH
6594: LD_INT 26
6596: PUSH
6597: LD_INT 96
6599: PUSH
6600: LD_INT 152
6602: PUSH
6603: LD_INT 0
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: PUSH
6612: LD_INT 26
6614: PUSH
6615: LD_INT 96
6617: PUSH
6618: LD_INT 149
6620: PUSH
6621: LD_INT 3
6623: PUSH
6624: EMPTY
6625: LIST
6626: LIST
6627: LIST
6628: LIST
6629: PUSH
6630: LD_INT 32
6632: PUSH
6633: LD_INT 109
6635: PUSH
6636: LD_INT 142
6638: PUSH
6639: LD_INT 3
6641: PUSH
6642: LD_INT 46
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: LIST
6650: LIST
6651: PUSH
6652: LD_INT 32
6654: PUSH
6655: LD_INT 112
6657: PUSH
6658: LD_INT 148
6660: PUSH
6661: LD_INT 3
6663: PUSH
6664: LD_INT 46
6666: PUSH
6667: EMPTY
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: PUSH
6674: LD_INT 33
6676: PUSH
6677: LD_INT 120
6679: PUSH
6680: LD_INT 159
6682: PUSH
6683: LD_INT 4
6685: PUSH
6686: LD_INT 45
6688: PUSH
6689: EMPTY
6690: LIST
6691: LIST
6692: LIST
6693: LIST
6694: LIST
6695: PUSH
6696: LD_INT 33
6698: PUSH
6699: LD_INT 122
6701: PUSH
6702: LD_INT 163
6704: PUSH
6705: LD_INT 4
6707: PUSH
6708: LD_INT 45
6710: PUSH
6711: EMPTY
6712: LIST
6713: LIST
6714: LIST
6715: LIST
6716: LIST
6717: PUSH
6718: LD_INT 33
6720: PUSH
6721: LD_INT 123
6723: PUSH
6724: LD_INT 167
6726: PUSH
6727: LD_INT 4
6729: PUSH
6730: LD_INT 45
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: LIST
6737: LIST
6738: LIST
6739: PUSH
6740: LD_INT 33
6742: PUSH
6743: LD_INT 59
6745: PUSH
6746: LD_INT 111
6748: PUSH
6749: LD_INT 3
6751: PUSH
6752: LD_INT 45
6754: PUSH
6755: EMPTY
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_INT 33
6764: PUSH
6765: LD_INT 65
6767: PUSH
6768: LD_INT 111
6770: PUSH
6771: LD_INT 3
6773: PUSH
6774: LD_INT 46
6776: PUSH
6777: EMPTY
6778: LIST
6779: LIST
6780: LIST
6781: LIST
6782: LIST
6783: PUSH
6784: LD_INT 33
6786: PUSH
6787: LD_INT 76
6789: PUSH
6790: LD_INT 117
6792: PUSH
6793: LD_INT 3
6795: PUSH
6796: LD_INT 45
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: LIST
6803: LIST
6804: LIST
6805: PUSH
6806: LD_INT 33
6808: PUSH
6809: LD_INT 80
6811: PUSH
6812: LD_INT 119
6814: PUSH
6815: LD_INT 3
6817: PUSH
6818: LD_INT 46
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: LIST
6825: LIST
6826: LIST
6827: PUSH
6828: LD_INT 33
6830: PUSH
6831: LD_INT 87
6833: PUSH
6834: LD_INT 125
6836: PUSH
6837: LD_INT 3
6839: PUSH
6840: LD_INT 45
6842: PUSH
6843: EMPTY
6844: LIST
6845: LIST
6846: LIST
6847: LIST
6848: LIST
6849: PUSH
6850: LD_INT 5
6852: PUSH
6853: LD_INT 92
6855: PUSH
6856: LD_INT 129
6858: PUSH
6859: LD_INT 3
6861: PUSH
6862: EMPTY
6863: LIST
6864: LIST
6865: LIST
6866: LIST
6867: PUSH
6868: LD_INT 28
6870: PUSH
6871: LD_INT 85
6873: PUSH
6874: LD_INT 165
6876: PUSH
6877: LD_INT 0
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: LIST
6884: LIST
6885: PUSH
6886: LD_INT 28
6888: PUSH
6889: LD_INT 83
6891: PUSH
6892: LD_INT 161
6894: PUSH
6895: LD_INT 4
6897: PUSH
6898: EMPTY
6899: LIST
6900: LIST
6901: LIST
6902: LIST
6903: PUSH
6904: LD_INT 28
6906: PUSH
6907: LD_INT 91
6909: PUSH
6910: LD_INT 166
6912: PUSH
6913: LD_INT 3
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: LIST
6920: LIST
6921: PUSH
6922: LD_INT 28
6924: PUSH
6925: LD_INT 102
6927: PUSH
6928: LD_INT 166
6930: PUSH
6931: LD_INT 2
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: LIST
6938: LIST
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: LIST
6945: LIST
6946: LIST
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: ST_TO_ADDR
// for i in list do
6969: LD_ADDR_VAR 0 2
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: FOR_IN
6980: IFFALSE 7158
// begin uc_side := 3 ;
6982: LD_ADDR_OWVAR 20
6986: PUSH
6987: LD_INT 3
6989: ST_TO_ADDR
// uc_nation := 3 ;
6990: LD_ADDR_OWVAR 21
6994: PUSH
6995: LD_INT 3
6997: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6998: LD_ADDR_OWVAR 42
7002: PUSH
7003: LD_VAR 0 2
7007: PUSH
7008: LD_INT 1
7010: ARRAY
7011: ST_TO_ADDR
// bc_kind1 := - 1 ;
7012: LD_ADDR_OWVAR 44
7016: PUSH
7017: LD_INT 1
7019: NEG
7020: ST_TO_ADDR
// bc_kind2 := - 1 ;
7021: LD_ADDR_OWVAR 45
7025: PUSH
7026: LD_INT 1
7028: NEG
7029: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7030: LD_VAR 0 2
7034: PUSH
7035: LD_INT 1
7037: ARRAY
7038: PUSH
7039: LD_INT 6
7041: EQUAL
7042: IFFALSE 7080
// begin bc_type := b_lab_full ;
7044: LD_ADDR_OWVAR 42
7048: PUSH
7049: LD_INT 8
7051: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7052: LD_ADDR_OWVAR 44
7056: PUSH
7057: LD_VAR 0 2
7061: PUSH
7062: LD_INT 5
7064: ARRAY
7065: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7066: LD_ADDR_OWVAR 45
7070: PUSH
7071: LD_VAR 0 2
7075: PUSH
7076: LD_INT 6
7078: ARRAY
7079: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7080: LD_ADDR_VAR 0 5
7084: PUSH
7085: LD_VAR 0 2
7089: PUSH
7090: LD_INT 2
7092: ARRAY
7093: PPUSH
7094: LD_VAR 0 2
7098: PUSH
7099: LD_INT 3
7101: ARRAY
7102: PPUSH
7103: LD_VAR 0 2
7107: PUSH
7108: LD_INT 4
7110: ARRAY
7111: PPUSH
7112: CALL_OW 47
7116: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7117: LD_VAR 0 2
7121: PUSH
7122: LD_INT 1
7124: ARRAY
7125: PUSH
7126: LD_INT 33
7128: PUSH
7129: LD_INT 32
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: IN
7136: IFFALSE 7156
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7138: LD_VAR 0 5
7142: PPUSH
7143: LD_VAR 0 2
7147: PUSH
7148: LD_INT 5
7150: ARRAY
7151: PPUSH
7152: CALL_OW 431
// end ;
7156: GO 6979
7158: POP
7159: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7160: LD_ADDR_VAR 0 4
7164: PUSH
7165: LD_INT 9
7167: PPUSH
7168: LD_INT 3
7170: PPUSH
7171: LD_STRING 
7173: PPUSH
7174: LD_INT 8
7176: PUSH
7177: LD_INT 7
7179: PUSH
7180: LD_INT 6
7182: PUSH
7183: EMPTY
7184: LIST
7185: LIST
7186: LIST
7187: PUSH
7188: LD_OWVAR 67
7192: ARRAY
7193: PPUSH
7194: LD_INT 11500
7196: PUSH
7197: LD_INT 1100
7199: PUSH
7200: LD_INT 60
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_INT 6
7210: PUSH
7211: LD_INT 6
7213: PUSH
7214: LD_INT 6
7216: PUSH
7217: LD_INT 6
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: PPUSH
7226: CALL 19474 0 6
7230: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7231: LD_ADDR_EXP 23
7235: PUSH
7236: LD_EXP 23
7240: PPUSH
7241: LD_INT 3
7243: PPUSH
7244: LD_VAR 0 4
7248: PUSH
7249: LD_INT 22
7251: PUSH
7252: LD_INT 3
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: PUSH
7259: LD_INT 21
7261: PUSH
7262: LD_INT 3
7264: PUSH
7265: EMPTY
7266: LIST
7267: LIST
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PPUSH
7273: CALL_OW 69
7277: UNION
7278: PPUSH
7279: CALL_OW 1
7283: ST_TO_ADDR
// extraPopovForces := [ ] ;
7284: LD_ADDR_EXP 18
7288: PUSH
7289: EMPTY
7290: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7291: LD_ADDR_VAR 0 2
7295: PUSH
7296: DOUBLE
7297: LD_INT 1
7299: DEC
7300: ST_TO_ADDR
7301: LD_INT 8
7303: PUSH
7304: LD_INT 9
7306: PUSH
7307: LD_INT 10
7309: PUSH
7310: EMPTY
7311: LIST
7312: LIST
7313: LIST
7314: PUSH
7315: LD_OWVAR 67
7319: ARRAY
7320: PUSH
7321: FOR_TO
7322: IFFALSE 7451
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7324: LD_INT 0
7326: PPUSH
7327: LD_INT 1
7329: PPUSH
7330: LD_INT 4
7332: PUSH
7333: LD_INT 5
7335: PUSH
7336: LD_INT 6
7338: PUSH
7339: EMPTY
7340: LIST
7341: LIST
7342: LIST
7343: PUSH
7344: LD_OWVAR 67
7348: ARRAY
7349: PPUSH
7350: CALL_OW 380
// un := CreateHuman ;
7354: LD_ADDR_VAR 0 3
7358: PUSH
7359: CALL_OW 44
7363: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7364: LD_INT 0
7366: PPUSH
7367: LD_INT 1
7369: PPUSH
7370: CALL_OW 12
7374: IFFALSE 7399
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7376: LD_VAR 0 3
7380: PPUSH
7381: LD_INT 131
7383: PPUSH
7384: LD_INT 110
7386: PPUSH
7387: LD_INT 8
7389: PPUSH
7390: LD_INT 0
7392: PPUSH
7393: CALL_OW 50
7397: GO 7420
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7399: LD_VAR 0 3
7403: PPUSH
7404: LD_INT 100
7406: PPUSH
7407: LD_INT 99
7409: PPUSH
7410: LD_INT 8
7412: PPUSH
7413: LD_INT 0
7415: PPUSH
7416: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7420: LD_ADDR_EXP 18
7424: PUSH
7425: LD_EXP 18
7429: PPUSH
7430: LD_EXP 18
7434: PUSH
7435: LD_INT 1
7437: PLUS
7438: PPUSH
7439: LD_VAR 0 3
7443: PPUSH
7444: CALL_OW 1
7448: ST_TO_ADDR
// end ;
7449: GO 7321
7451: POP
7452: POP
// PrepareSoldier ( false , 6 ) ;
7453: LD_INT 0
7455: PPUSH
7456: LD_INT 6
7458: PPUSH
7459: CALL_OW 381
// un := CreateHuman ;
7463: LD_ADDR_VAR 0 3
7467: PUSH
7468: CALL_OW 44
7472: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7473: LD_VAR 0 3
7477: PPUSH
7478: LD_INT 1
7480: PPUSH
7481: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7485: LD_VAR 0 3
7489: PPUSH
7490: LD_INT 150
7492: PPUSH
7493: LD_INT 158
7495: PPUSH
7496: CALL_OW 428
7500: PPUSH
7501: CALL_OW 52
// popovAttackGroup := [ ] ;
7505: LD_ADDR_EXP 19
7509: PUSH
7510: EMPTY
7511: ST_TO_ADDR
// end ;
7512: LD_VAR 0 1
7516: RET
// export function InitMC_Popov ( ) ; begin
7517: LD_INT 0
7519: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7520: LD_INT 3
7522: PPUSH
7523: LD_INT 3
7525: PPUSH
7526: CALL 77822 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7530: LD_INT 3
7532: PPUSH
7533: LD_INT 10
7535: PPUSH
7536: CALL 77766 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7540: LD_INT 3
7542: PPUSH
7543: LD_INT 86
7545: PUSH
7546: LD_INT 118
7548: PUSH
7549: LD_INT 0
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 123
7559: PUSH
7560: LD_INT 151
7562: PUSH
7563: LD_INT 1
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: PUSH
7571: LD_INT 98
7573: PUSH
7574: LD_INT 121
7576: PUSH
7577: LD_INT 0
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: LIST
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: LIST
7589: PPUSH
7590: CALL 76825 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7594: LD_INT 3
7596: PPUSH
7597: LD_INT 46
7599: PUSH
7600: LD_INT 45
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PPUSH
7607: CALL 77654 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7611: LD_INT 3
7613: PPUSH
7614: LD_INT 12
7616: PPUSH
7617: CALL 77336 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 11
7626: PPUSH
7627: CALL 77067 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7631: LD_INT 3
7633: PPUSH
7634: LD_INT 4
7636: PPUSH
7637: CALL 76686 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7641: LD_INT 3
7643: PPUSH
7644: LD_INT 23
7646: PUSH
7647: LD_INT 1
7649: PUSH
7650: LD_INT 3
7652: PUSH
7653: LD_INT 44
7655: PUSH
7656: EMPTY
7657: LIST
7658: LIST
7659: LIST
7660: LIST
7661: PUSH
7662: LD_INT 23
7664: PUSH
7665: LD_INT 1
7667: PUSH
7668: LD_INT 3
7670: PUSH
7671: LD_INT 45
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 21
7682: PUSH
7683: LD_INT 1
7685: PUSH
7686: LD_INT 3
7688: PUSH
7689: LD_INT 44
7691: PUSH
7692: EMPTY
7693: LIST
7694: LIST
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 21
7700: PUSH
7701: LD_INT 1
7703: PUSH
7704: LD_INT 3
7706: PUSH
7707: LD_INT 45
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: LIST
7714: LIST
7715: PUSH
7716: EMPTY
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: PPUSH
7722: CALL 76501 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7726: LD_INT 3
7728: PPUSH
7729: LD_INT 94
7731: PPUSH
7732: LD_INT 161
7734: PPUSH
7735: LD_INT 0
7737: PPUSH
7738: LD_INT 19
7740: PUSH
7741: LD_INT 17
7743: PUSH
7744: LD_INT 18
7746: PUSH
7747: LD_INT 24
7749: PUSH
7750: LD_INT 21
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: PPUSH
7760: CALL 77448 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7764: LD_INT 3
7766: PPUSH
7767: LD_INT 21
7769: PUSH
7770: LD_INT 1
7772: PUSH
7773: LD_INT 3
7775: PUSH
7776: LD_INT 51
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: PPUSH
7788: CALL 76549 0 2
// end ;
7792: LD_VAR 0 1
7796: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7797: LD_EXP 18
7801: PUSH
7802: LD_EXP 5
7806: NOT
7807: AND
7808: IFFALSE 7868
7810: GO 7812
7812: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7813: LD_EXP 18
7817: PPUSH
7818: LD_INT 106
7820: PPUSH
7821: LD_INT 137
7823: PPUSH
7824: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7828: LD_ADDR_EXP 23
7832: PUSH
7833: LD_EXP 23
7837: PPUSH
7838: LD_INT 3
7840: PPUSH
7841: LD_EXP 23
7845: PUSH
7846: LD_INT 3
7848: ARRAY
7849: PUSH
7850: LD_EXP 18
7854: UNION
7855: PPUSH
7856: CALL_OW 1
7860: ST_TO_ADDR
// extraPopovForces := [ ] ;
7861: LD_ADDR_EXP 18
7865: PUSH
7866: EMPTY
7867: ST_TO_ADDR
// end ;
7868: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7869: LD_INT 9
7871: PPUSH
7872: CALL_OW 302
7876: PUSH
7877: LD_EXP 5
7881: NOT
7882: AND
7883: IFFALSE 8449
7885: GO 7887
7887: DISABLE
7888: LD_INT 0
7890: PPUSH
7891: PPUSH
7892: PPUSH
7893: PPUSH
7894: PPUSH
// begin enable ;
7895: ENABLE
// base := 3 ;
7896: LD_ADDR_VAR 0 2
7900: PUSH
7901: LD_INT 3
7903: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7904: LD_ADDR_VAR 0 3
7908: PUSH
7909: LD_INT 22
7911: PUSH
7912: LD_INT 1
7914: PUSH
7915: LD_INT 3
7917: PUSH
7918: LD_INT 44
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: LIST
7926: PUSH
7927: LD_INT 24
7929: PUSH
7930: LD_INT 1
7932: PUSH
7933: LD_INT 3
7935: PUSH
7936: LD_INT 46
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: PUSH
7945: LD_INT 24
7947: PUSH
7948: LD_INT 1
7950: PUSH
7951: LD_INT 3
7953: PUSH
7954: LD_INT 46
7956: PUSH
7957: EMPTY
7958: LIST
7959: LIST
7960: LIST
7961: LIST
7962: PUSH
7963: LD_INT 24
7965: PUSH
7966: LD_INT 1
7968: PUSH
7969: LD_INT 3
7971: PUSH
7972: LD_INT 46
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: LIST
7979: LIST
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: LIST
7985: LIST
7986: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7987: LD_ADDR_VAR 0 5
7991: PUSH
7992: LD_VAR 0 5
7996: PUSH
7997: LD_OWVAR 1
8001: PUSH
8002: LD_INT 21000
8004: DIV
8005: PLUS
8006: ST_TO_ADDR
// if amount > 8 then
8007: LD_VAR 0 5
8011: PUSH
8012: LD_INT 8
8014: GREATER
8015: IFFALSE 8025
// amount := 8 ;
8017: LD_ADDR_VAR 0 5
8021: PUSH
8022: LD_INT 8
8024: ST_TO_ADDR
// for i = 1 to amount do
8025: LD_ADDR_VAR 0 1
8029: PUSH
8030: DOUBLE
8031: LD_INT 1
8033: DEC
8034: ST_TO_ADDR
8035: LD_VAR 0 5
8039: PUSH
8040: FOR_TO
8041: IFFALSE 8106
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8043: LD_ADDR_VAR 0 3
8047: PUSH
8048: LD_VAR 0 3
8052: PPUSH
8053: LD_VAR 0 3
8057: PUSH
8058: LD_INT 1
8060: PLUS
8061: PPUSH
8062: LD_INT 24
8064: PUSH
8065: LD_INT 1
8067: PUSH
8068: LD_INT 3
8070: PUSH
8071: LD_INT 46
8073: PUSH
8074: LD_INT 45
8076: PUSH
8077: EMPTY
8078: LIST
8079: LIST
8080: PUSH
8081: LD_INT 1
8083: PPUSH
8084: LD_INT 2
8086: PPUSH
8087: CALL_OW 12
8091: ARRAY
8092: PUSH
8093: EMPTY
8094: LIST
8095: LIST
8096: LIST
8097: LIST
8098: PPUSH
8099: CALL_OW 2
8103: ST_TO_ADDR
8104: GO 8040
8106: POP
8107: POP
// MC_InsertProduceList ( base , tmp ) ;
8108: LD_VAR 0 2
8112: PPUSH
8113: LD_VAR 0 3
8117: PPUSH
8118: CALL 76549 0 2
// repeat wait ( 0 0$1 ) ;
8122: LD_INT 35
8124: PPUSH
8125: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8129: LD_VAR 0 2
8133: PPUSH
8134: LD_INT 1
8136: PPUSH
8137: CALL 77967 0 2
8141: PUSH
8142: LD_VAR 0 5
8146: GREATEREQUAL
8147: IFFALSE 8122
// wait ( 0 0$30 ) ;
8149: LD_INT 1050
8151: PPUSH
8152: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8156: LD_ADDR_VAR 0 4
8160: PUSH
8161: LD_EXP 42
8165: PUSH
8166: LD_VAR 0 2
8170: ARRAY
8171: PUSH
8172: LD_EXP 42
8176: PUSH
8177: LD_VAR 0 2
8181: ARRAY
8182: PPUSH
8183: LD_INT 2
8185: PUSH
8186: LD_INT 34
8188: PUSH
8189: LD_INT 51
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PUSH
8196: LD_INT 34
8198: PUSH
8199: LD_INT 52
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: PUSH
8206: EMPTY
8207: LIST
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 72
8215: DIFF
8216: ST_TO_ADDR
// if not attackers then
8217: LD_VAR 0 4
8221: NOT
8222: IFFALSE 8226
// exit ;
8224: GO 8449
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8226: LD_ADDR_EXP 42
8230: PUSH
8231: LD_EXP 42
8235: PPUSH
8236: LD_VAR 0 2
8240: PPUSH
8241: LD_EXP 42
8245: PUSH
8246: LD_VAR 0 2
8250: ARRAY
8251: PUSH
8252: LD_VAR 0 4
8256: DIFF
8257: PPUSH
8258: CALL_OW 1
8262: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8263: LD_VAR 0 4
8267: PPUSH
8268: LD_INT 107
8270: PPUSH
8271: LD_INT 74
8273: PPUSH
8274: CALL_OW 114
// wait ( 0 0$5 ) ;
8278: LD_INT 175
8280: PPUSH
8281: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8285: LD_INT 35
8287: PPUSH
8288: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8292: LD_VAR 0 4
8296: PPUSH
8297: LD_INT 60
8299: PUSH
8300: EMPTY
8301: LIST
8302: PPUSH
8303: CALL_OW 72
8307: NOT
8308: IFFALSE 8285
// if rand ( 0 , 1 ) then
8310: LD_INT 0
8312: PPUSH
8313: LD_INT 1
8315: PPUSH
8316: CALL_OW 12
8320: IFFALSE 8339
// ComAgressiveMove ( attackers , 155 , 108 ) else
8322: LD_VAR 0 4
8326: PPUSH
8327: LD_INT 155
8329: PPUSH
8330: LD_INT 108
8332: PPUSH
8333: CALL_OW 114
8337: GO 8354
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8339: LD_VAR 0 4
8343: PPUSH
8344: LD_INT 149
8346: PPUSH
8347: LD_INT 55
8349: PPUSH
8350: CALL_OW 114
// wait ( 0 0$10 ) ;
8354: LD_INT 350
8356: PPUSH
8357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8361: LD_INT 35
8363: PPUSH
8364: CALL_OW 67
// for i in attackers do
8368: LD_ADDR_VAR 0 1
8372: PUSH
8373: LD_VAR 0 4
8377: PUSH
8378: FOR_IN
8379: IFFALSE 8429
// if not HasTask ( i ) then
8381: LD_VAR 0 1
8385: PPUSH
8386: CALL_OW 314
8390: NOT
8391: IFFALSE 8427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8393: LD_VAR 0 1
8397: PPUSH
8398: LD_INT 81
8400: PUSH
8401: LD_INT 3
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PPUSH
8408: CALL_OW 69
8412: PPUSH
8413: LD_VAR 0 1
8417: PPUSH
8418: CALL_OW 74
8422: PPUSH
8423: CALL_OW 115
8427: GO 8378
8429: POP
8430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8431: LD_VAR 0 4
8435: PPUSH
8436: LD_INT 50
8438: PUSH
8439: EMPTY
8440: LIST
8441: PPUSH
8442: CALL_OW 72
8446: NOT
8447: IFFALSE 8361
// end ;
8449: PPOPN 5
8451: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8452: LD_EXP 5
8456: NOT
8457: IFFALSE 9044
8459: GO 8461
8461: DISABLE
8462: LD_INT 0
8464: PPUSH
8465: PPUSH
8466: PPUSH
8467: PPUSH
// begin enable ;
8468: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8469: LD_OWVAR 67
8473: PUSH
8474: LD_INT 1
8476: EQUAL
8477: PUSH
8478: LD_OWVAR 1
8482: PUSH
8483: LD_INT 63000
8485: LESS
8486: AND
8487: IFFALSE 8491
// exit ;
8489: GO 9044
// tmp := [ ] ;
8491: LD_ADDR_VAR 0 3
8495: PUSH
8496: EMPTY
8497: ST_TO_ADDR
// if tick < 45 45$00 then
8498: LD_OWVAR 1
8502: PUSH
8503: LD_INT 94500
8505: LESS
8506: IFFALSE 8683
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8508: LD_ADDR_VAR 0 1
8512: PUSH
8513: DOUBLE
8514: LD_INT 1
8516: DEC
8517: ST_TO_ADDR
8518: LD_INT 2
8520: PUSH
8521: LD_INT 3
8523: PUSH
8524: LD_INT 4
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: LIST
8531: PUSH
8532: LD_OWVAR 67
8536: ARRAY
8537: PUSH
8538: FOR_TO
8539: IFFALSE 8681
// begin uc_side := 3 ;
8541: LD_ADDR_OWVAR 20
8545: PUSH
8546: LD_INT 3
8548: ST_TO_ADDR
// uc_nation := 3 ;
8549: LD_ADDR_OWVAR 21
8553: PUSH
8554: LD_INT 3
8556: ST_TO_ADDR
// InitHC_All ( ) ;
8557: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8561: LD_INT 0
8563: PPUSH
8564: LD_INT 1
8566: PPUSH
8567: LD_INT 5
8569: PUSH
8570: LD_INT 6
8572: PUSH
8573: LD_INT 7
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: LIST
8580: PUSH
8581: LD_OWVAR 67
8585: ARRAY
8586: PPUSH
8587: CALL_OW 380
// un := CreateHuman ;
8591: LD_ADDR_VAR 0 2
8595: PUSH
8596: CALL_OW 44
8600: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8601: LD_VAR 0 2
8605: PPUSH
8606: LD_INT 18
8608: PPUSH
8609: LD_INT 0
8611: PPUSH
8612: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8616: LD_VAR 0 2
8620: PPUSH
8621: LD_INT 9
8623: PPUSH
8624: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_INT 147
8635: PPUSH
8636: LD_INT 161
8638: PPUSH
8639: CALL_OW 111
// wait ( 0 0$2 ) ;
8643: LD_INT 70
8645: PPUSH
8646: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8650: LD_ADDR_VAR 0 3
8654: PUSH
8655: LD_VAR 0 3
8659: PPUSH
8660: LD_VAR 0 3
8664: PUSH
8665: LD_INT 1
8667: PLUS
8668: PPUSH
8669: LD_VAR 0 2
8673: PPUSH
8674: CALL_OW 1
8678: ST_TO_ADDR
// end ;
8679: GO 8538
8681: POP
8682: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8683: LD_ADDR_VAR 0 4
8687: PUSH
8688: LD_INT 3
8690: PUSH
8691: LD_INT 4
8693: PUSH
8694: LD_INT 5
8696: PUSH
8697: EMPTY
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: LD_OWVAR 67
8706: ARRAY
8707: PUSH
8708: LD_OWVAR 1
8712: PUSH
8713: LD_INT 21000
8715: DIV
8716: PLUS
8717: ST_TO_ADDR
// if amount > 15 then
8718: LD_VAR 0 4
8722: PUSH
8723: LD_INT 15
8725: GREATER
8726: IFFALSE 8736
// amount := 15 ;
8728: LD_ADDR_VAR 0 4
8732: PUSH
8733: LD_INT 15
8735: ST_TO_ADDR
// for i := 1 to amount do
8736: LD_ADDR_VAR 0 1
8740: PUSH
8741: DOUBLE
8742: LD_INT 1
8744: DEC
8745: ST_TO_ADDR
8746: LD_VAR 0 4
8750: PUSH
8751: FOR_TO
8752: IFFALSE 8898
// begin uc_side := 3 ;
8754: LD_ADDR_OWVAR 20
8758: PUSH
8759: LD_INT 3
8761: ST_TO_ADDR
// uc_nation := 3 ;
8762: LD_ADDR_OWVAR 21
8766: PUSH
8767: LD_INT 3
8769: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8770: LD_INT 24
8772: PPUSH
8773: LD_INT 1
8775: PPUSH
8776: LD_INT 3
8778: PPUSH
8779: LD_INT 46
8781: PUSH
8782: LD_INT 45
8784: PUSH
8785: LD_INT 44
8787: PUSH
8788: LD_INT 43
8790: PUSH
8791: LD_INT 42
8793: PUSH
8794: EMPTY
8795: LIST
8796: LIST
8797: LIST
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 1
8803: PPUSH
8804: LD_INT 5
8806: PPUSH
8807: CALL_OW 12
8811: ARRAY
8812: PPUSH
8813: LD_INT 90
8815: PPUSH
8816: CALL 16030 0 5
// un := CreateVehicle ;
8820: LD_ADDR_VAR 0 2
8824: PUSH
8825: CALL_OW 45
8829: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8830: LD_VAR 0 2
8834: PPUSH
8835: LD_INT 18
8837: PPUSH
8838: LD_INT 0
8840: PPUSH
8841: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8845: LD_VAR 0 2
8849: PPUSH
8850: LD_INT 147
8852: PPUSH
8853: LD_INT 161
8855: PPUSH
8856: CALL_OW 111
// wait ( 0 0$3 ) ;
8860: LD_INT 105
8862: PPUSH
8863: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8867: LD_ADDR_VAR 0 3
8871: PUSH
8872: LD_VAR 0 3
8876: PPUSH
8877: LD_VAR 0 3
8881: PUSH
8882: LD_INT 1
8884: PLUS
8885: PPUSH
8886: LD_VAR 0 2
8890: PPUSH
8891: CALL_OW 1
8895: ST_TO_ADDR
// end ;
8896: GO 8751
8898: POP
8899: POP
// if not tmp then
8900: LD_VAR 0 3
8904: NOT
8905: IFFALSE 8909
// exit ;
8907: GO 9044
// wait ( 0 0$5 ) ;
8909: LD_INT 175
8911: PPUSH
8912: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8916: LD_INT 70
8918: PPUSH
8919: CALL_OW 67
// for i in tmp do
8923: LD_ADDR_VAR 0 1
8927: PUSH
8928: LD_VAR 0 3
8932: PUSH
8933: FOR_IN
8934: IFFALSE 9035
// begin if not IsOk ( i ) or IsDead ( i ) then
8936: LD_VAR 0 1
8940: PPUSH
8941: CALL_OW 302
8945: NOT
8946: PUSH
8947: LD_VAR 0 1
8951: PPUSH
8952: CALL_OW 301
8956: OR
8957: IFFALSE 8975
// tmp := tmp diff i ;
8959: LD_ADDR_VAR 0 3
8963: PUSH
8964: LD_VAR 0 3
8968: PUSH
8969: LD_VAR 0 1
8973: DIFF
8974: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8975: LD_VAR 0 1
8979: PPUSH
8980: CALL_OW 257
8984: PUSH
8985: LD_INT 9
8987: EQUAL
8988: IFFALSE 8999
// ComSpaceTimeShoot ( i ) ;
8990: LD_VAR 0 1
8994: PPUSH
8995: CALL 11962 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_INT 81
9006: PUSH
9007: LD_INT 3
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 69
9018: PPUSH
9019: LD_VAR 0 1
9023: PPUSH
9024: CALL_OW 74
9028: PPUSH
9029: CALL_OW 115
// end ;
9033: GO 8933
9035: POP
9036: POP
// until not tmp ;
9037: LD_VAR 0 3
9041: NOT
9042: IFFALSE 8916
// end ; end_of_file
9044: PPOPN 4
9046: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9047: LD_INT 0
9049: PPUSH
9050: PPUSH
9051: PPUSH
9052: PPUSH
// uc_side := 1 ;
9053: LD_ADDR_OWVAR 20
9057: PUSH
9058: LD_INT 1
9060: ST_TO_ADDR
// uc_nation := 1 ;
9061: LD_ADDR_OWVAR 21
9065: PUSH
9066: LD_INT 1
9068: ST_TO_ADDR
// hc_importance := 100 ;
9069: LD_ADDR_OWVAR 32
9073: PUSH
9074: LD_INT 100
9076: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9077: LD_ADDR_OWVAR 26
9081: PUSH
9082: LD_STRING Jeremy Sikorski
9084: ST_TO_ADDR
// hc_gallery := us ;
9085: LD_ADDR_OWVAR 33
9089: PUSH
9090: LD_STRING us
9092: ST_TO_ADDR
// hc_face_number := 19 ;
9093: LD_ADDR_OWVAR 34
9097: PUSH
9098: LD_INT 19
9100: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9101: LD_INT 1
9103: PPUSH
9104: LD_INT 1
9106: PPUSH
9107: LD_INT 4
9109: PUSH
9110: LD_INT 4
9112: PUSH
9113: LD_INT 3
9115: PUSH
9116: EMPTY
9117: LIST
9118: LIST
9119: LIST
9120: PUSH
9121: LD_OWVAR 67
9125: ARRAY
9126: PPUSH
9127: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9131: LD_ADDR_OWVAR 29
9135: PUSH
9136: LD_INT 10
9138: PUSH
9139: LD_INT 12
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: ST_TO_ADDR
// Sikorski := CreateHuman ;
9146: LD_ADDR_EXP 20
9150: PUSH
9151: CALL_OW 44
9155: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9156: LD_EXP 20
9160: PPUSH
9161: LD_INT 133
9163: PPUSH
9164: LD_INT 19
9166: PPUSH
9167: LD_INT 2
9169: PPUSH
9170: LD_INT 0
9172: PPUSH
9173: CALL_OW 50
// InitHc_All ( ) ;
9177: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9181: LD_ADDR_VAR 0 2
9185: PUSH
9186: DOUBLE
9187: LD_INT 1
9189: DEC
9190: ST_TO_ADDR
9191: LD_INT 4
9193: PUSH
9194: LD_INT 3
9196: PUSH
9197: LD_INT 3
9199: PUSH
9200: EMPTY
9201: LIST
9202: LIST
9203: LIST
9204: PUSH
9205: LD_OWVAR 67
9209: ARRAY
9210: PUSH
9211: FOR_TO
9212: IFFALSE 9328
// for j := 1 to 4 do
9214: LD_ADDR_VAR 0 3
9218: PUSH
9219: DOUBLE
9220: LD_INT 1
9222: DEC
9223: ST_TO_ADDR
9224: LD_INT 4
9226: PUSH
9227: FOR_TO
9228: IFFALSE 9324
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9230: LD_INT 0
9232: PPUSH
9233: LD_VAR 0 3
9237: PPUSH
9238: LD_INT 5
9240: PUSH
9241: LD_INT 4
9243: PUSH
9244: LD_INT 3
9246: PUSH
9247: EMPTY
9248: LIST
9249: LIST
9250: LIST
9251: PUSH
9252: LD_OWVAR 67
9256: ARRAY
9257: PPUSH
9258: CALL_OW 380
// un := CreateHuman ;
9262: LD_ADDR_VAR 0 4
9266: PUSH
9267: CALL_OW 44
9271: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9272: LD_VAR 0 4
9276: PPUSH
9277: LD_INT 0
9279: PPUSH
9280: LD_INT 5
9282: PPUSH
9283: CALL_OW 12
9287: PPUSH
9288: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9292: LD_VAR 0 4
9296: PPUSH
9297: LD_INT 133
9299: PPUSH
9300: LD_INT 19
9302: PPUSH
9303: LD_INT 6
9305: PPUSH
9306: LD_INT 0
9308: PPUSH
9309: CALL_OW 50
// ComHold ( un ) ;
9313: LD_VAR 0 4
9317: PPUSH
9318: CALL_OW 140
// end ;
9322: GO 9227
9324: POP
9325: POP
9326: GO 9211
9328: POP
9329: POP
// vc_chassis := us_heavy_tracked ;
9330: LD_ADDR_OWVAR 37
9334: PUSH
9335: LD_INT 4
9337: ST_TO_ADDR
// vc_engine := engine_combustion ;
9338: LD_ADDR_OWVAR 39
9342: PUSH
9343: LD_INT 1
9345: ST_TO_ADDR
// vc_control := control_manual ;
9346: LD_ADDR_OWVAR 38
9350: PUSH
9351: LD_INT 1
9353: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9354: LD_ADDR_OWVAR 40
9358: PUSH
9359: LD_INT 14
9361: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9362: LD_ADDR_OWVAR 41
9366: PUSH
9367: LD_INT 60
9369: ST_TO_ADDR
// un := CreateVehicle ;
9370: LD_ADDR_VAR 0 4
9374: PUSH
9375: CALL_OW 45
9379: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9380: LD_VAR 0 4
9384: PPUSH
9385: LD_INT 2
9387: PPUSH
9388: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 128
9399: PPUSH
9400: LD_INT 12
9402: PPUSH
9403: LD_INT 0
9405: PPUSH
9406: CALL_OW 48
// for i := 1 to 3 do
9410: LD_ADDR_VAR 0 2
9414: PUSH
9415: DOUBLE
9416: LD_INT 1
9418: DEC
9419: ST_TO_ADDR
9420: LD_INT 3
9422: PUSH
9423: FOR_TO
9424: IFFALSE 9447
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9426: LD_INT 5
9428: PPUSH
9429: LD_INT 133
9431: PPUSH
9432: LD_INT 19
9434: PPUSH
9435: LD_INT 3
9437: PPUSH
9438: LD_INT 0
9440: PPUSH
9441: CALL_OW 56
9445: GO 9423
9447: POP
9448: POP
// end ; end_of_file
9449: LD_VAR 0 1
9453: RET
// export function Action ; begin
9454: LD_INT 0
9456: PPUSH
// InGameOn ;
9457: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9461: LD_INT 133
9463: PPUSH
9464: LD_INT 19
9466: PPUSH
9467: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9471: LD_EXP 20
9475: PPUSH
9476: LD_STRING WT-DS-1
9478: PPUSH
9479: CALL_OW 88
// InGameOff ;
9483: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9487: LD_STRING DestroyEnemy
9489: PPUSH
9490: CALL_OW 337
// wait ( 0 0$20 ) ;
9494: LD_INT 700
9496: PPUSH
9497: CALL_OW 67
// DialogueOn ;
9501: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9505: LD_INT 100
9507: PPUSH
9508: LD_INT 37
9510: PPUSH
9511: LD_INT 1
9513: PPUSH
9514: LD_INT 30
9516: NEG
9517: PPUSH
9518: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9522: LD_INT 100
9524: PPUSH
9525: LD_INT 37
9527: PPUSH
9528: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9532: LD_EXP 10
9536: PPUSH
9537: LD_STRING WT-PL-1
9539: PPUSH
9540: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9544: LD_EXP 20
9548: PPUSH
9549: LD_STRING WT-DS-2
9551: PPUSH
9552: CALL_OW 88
// DialogueOff ;
9556: CALL_OW 7
// wait ( 0 0$2 ) ;
9560: LD_INT 70
9562: PPUSH
9563: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9567: LD_INT 100
9569: PPUSH
9570: LD_INT 37
9572: PPUSH
9573: LD_INT 1
9575: PPUSH
9576: CALL_OW 331
// end ;
9580: LD_VAR 0 1
9584: RET
// export function DialogPowellsAttack ; begin
9585: LD_INT 0
9587: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9588: LD_EXP 10
9592: PPUSH
9593: LD_STRING WT-PL-8
9595: PPUSH
9596: CALL_OW 94
// end ;
9600: LD_VAR 0 1
9604: RET
// export function DialogContaminateSib ( x , y ) ; begin
9605: LD_INT 0
9607: PPUSH
// DialogueOn ;
9608: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9612: LD_VAR 0 1
9616: PPUSH
9617: LD_VAR 0 2
9621: PPUSH
9622: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9626: LD_EXP 20
9630: PPUSH
9631: LD_STRING WT-DS-3
9633: PPUSH
9634: CALL_OW 88
// DialogueOff ;
9638: CALL_OW 7
// end ;
9642: LD_VAR 0 3
9646: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9647: LD_EXP 8
9651: NOT
9652: PUSH
9653: LD_INT 1
9655: PPUSH
9656: LD_INT 81
9658: PUSH
9659: LD_INT 4
9661: PUSH
9662: EMPTY
9663: LIST
9664: LIST
9665: PPUSH
9666: CALL_OW 70
9670: PUSH
9671: LD_INT 3
9673: GREATER
9674: AND
9675: IFFALSE 9747
9677: GO 9679
9679: DISABLE
// begin powellInTrouble := true ;
9680: LD_ADDR_EXP 8
9684: PUSH
9685: LD_INT 1
9687: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9688: LD_EXP 20
9692: PPUSH
9693: LD_STRING WT-DS-6
9695: PPUSH
9696: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9700: LD_INT 1
9702: PPUSH
9703: LD_INT 22
9705: PUSH
9706: LD_INT 1
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: PPUSH
9713: CALL_OW 70
9717: NOT
9718: IFFALSE 9732
// SayRadio ( Powell , WT-PL-6 ) ;
9720: LD_EXP 10
9724: PPUSH
9725: LD_STRING WT-PL-6
9727: PPUSH
9728: CALL_OW 94
// wait ( 1 1$30 ) ;
9732: LD_INT 3150
9734: PPUSH
9735: CALL_OW 67
// powellInTrouble := false ;
9739: LD_ADDR_EXP 8
9743: PUSH
9744: LD_INT 0
9746: ST_TO_ADDR
// end ;
9747: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9748: LD_EXP 9
9752: NOT
9753: PUSH
9754: LD_INT 16
9756: PPUSH
9757: LD_INT 81
9759: PUSH
9760: LD_INT 1
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 70
9771: PUSH
9772: LD_INT 6
9774: GREATER
9775: AND
9776: IFFALSE 9849
9778: GO 9780
9780: DISABLE
// begin sikorskiInTrouble := true ;
9781: LD_ADDR_EXP 9
9785: PUSH
9786: LD_INT 1
9788: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9789: LD_EXP 20
9793: PPUSH
9794: LD_STRING WT-DS-7
9796: PPUSH
9797: CALL_OW 88
// if not powellAttackGroup then
9801: LD_EXP 12
9805: NOT
9806: IFFALSE 9822
// SayRadio ( Powell , WT-PL-7n ) else
9808: LD_EXP 10
9812: PPUSH
9813: LD_STRING WT-PL-7n
9815: PPUSH
9816: CALL_OW 94
9820: GO 9834
// SayRadio ( Powell , WT-PL-7y ) ;
9822: LD_EXP 10
9826: PPUSH
9827: LD_STRING WT-PL-7y
9829: PPUSH
9830: CALL_OW 94
// wait ( 1 1$30 ) ;
9834: LD_INT 3150
9836: PPUSH
9837: CALL_OW 67
// sikorskiInTrouble := false ;
9841: LD_ADDR_EXP 9
9845: PUSH
9846: LD_INT 0
9848: ST_TO_ADDR
// end ;
9849: END
// export function DialogPowellsAttackFailed ; begin
9850: LD_INT 0
9852: PPUSH
// if not ruDestroyed then
9853: LD_EXP 5
9857: NOT
9858: IFFALSE 9874
// SayRadio ( Powell , WT-PL-9 ) else
9860: LD_EXP 10
9864: PPUSH
9865: LD_STRING WT-PL-9
9867: PPUSH
9868: CALL_OW 94
9872: GO 9886
// SayRadio ( Powell , WT-PL-10 ) ;
9874: LD_EXP 10
9878: PPUSH
9879: LD_STRING WT-PL-10
9881: PPUSH
9882: CALL_OW 94
// end ;
9886: LD_VAR 0 1
9890: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9891: LD_INT 22
9893: PUSH
9894: LD_INT 2
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PUSH
9901: LD_INT 21
9903: PUSH
9904: LD_INT 1
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: PUSH
9911: EMPTY
9912: LIST
9913: LIST
9914: PPUSH
9915: CALL_OW 69
9919: PUSH
9920: LD_INT 0
9922: EQUAL
9923: IFFALSE 9967
9925: GO 9927
9927: DISABLE
// begin arDestroyed := true ;
9928: LD_ADDR_EXP 4
9932: PUSH
9933: LD_INT 1
9935: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9936: LD_INT 2
9938: PPUSH
9939: CALL 52522 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9943: LD_EXP 20
9947: PPUSH
9948: LD_STRING WT-DS-4
9950: PPUSH
9951: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9955: LD_EXP 10
9959: PPUSH
9960: LD_STRING WT-PL-4
9962: PPUSH
9963: CALL_OW 94
// end ;
9967: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9968: LD_INT 22
9970: PUSH
9971: LD_INT 3
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: PUSH
9978: LD_INT 21
9980: PUSH
9981: LD_INT 1
9983: PUSH
9984: EMPTY
9985: LIST
9986: LIST
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PPUSH
9992: CALL_OW 69
9996: PUSH
9997: LD_INT 0
9999: EQUAL
10000: IFFALSE 10044
10002: GO 10004
10004: DISABLE
// begin ruDestroyed := true ;
10005: LD_ADDR_EXP 5
10009: PUSH
10010: LD_INT 1
10012: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10013: LD_INT 3
10015: PPUSH
10016: CALL 52522 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10020: LD_EXP 20
10024: PPUSH
10025: LD_STRING WT-DS-5
10027: PPUSH
10028: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10032: LD_EXP 10
10036: PPUSH
10037: LD_STRING WT-PL-5
10039: PPUSH
10040: CALL_OW 94
// end ;
10044: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10045: LD_EXP 5
10049: PUSH
10050: LD_EXP 4
10054: AND
10055: IFFALSE 10228
10057: GO 10059
10059: DISABLE
// begin wait ( 0 0$3 ) ;
10060: LD_INT 105
10062: PPUSH
10063: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10067: LD_OWVAR 1
10071: PUSH
10072: LD_INT 126000
10074: PUSH
10075: LD_INT 105000
10077: PUSH
10078: LD_INT 94500
10080: PUSH
10081: EMPTY
10082: LIST
10083: LIST
10084: LIST
10085: PUSH
10086: LD_OWVAR 67
10090: ARRAY
10091: GREATEREQUAL
10092: IFFALSE 10107
// AddMedal ( WoT-med-1 , - 1 ) else
10094: LD_STRING WoT-med-1
10096: PPUSH
10097: LD_INT 1
10099: NEG
10100: PPUSH
10101: CALL_OW 101
10105: GO 10117
// AddMedal ( WoT-med-1 , 1 ) ;
10107: LD_STRING WoT-med-1
10109: PPUSH
10110: LD_INT 1
10112: PPUSH
10113: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10117: LD_EXP 6
10121: PUSH
10122: LD_INT 4
10124: PUSH
10125: LD_INT 3
10127: PUSH
10128: LD_INT 2
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: PUSH
10136: LD_OWVAR 67
10140: ARRAY
10141: GREATEREQUAL
10142: IFFALSE 10157
// AddMedal ( WoT-med-2 , - 1 ) else
10144: LD_STRING WoT-med-2
10146: PPUSH
10147: LD_INT 1
10149: NEG
10150: PPUSH
10151: CALL_OW 101
10155: GO 10167
// AddMedal ( WoT-med-2 , 1 ) ;
10157: LD_STRING WoT-med-2
10159: PPUSH
10160: LD_INT 1
10162: PPUSH
10163: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10167: LD_EXP 7
10171: PUSH
10172: LD_INT 8
10174: PUSH
10175: LD_INT 6
10177: PUSH
10178: LD_INT 5
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: LD_OWVAR 67
10190: ARRAY
10191: GREATEREQUAL
10192: IFFALSE 10207
// AddMedal ( WoT-med-3 , - 1 ) else
10194: LD_STRING WoT-med-3
10196: PPUSH
10197: LD_INT 1
10199: NEG
10200: PPUSH
10201: CALL_OW 101
10205: GO 10217
// AddMedal ( WoT-med-3 , 1 ) ;
10207: LD_STRING WoT-med-3
10209: PPUSH
10210: LD_INT 1
10212: PPUSH
10213: CALL_OW 101
// GiveMedals ( MAIN ) ;
10217: LD_STRING MAIN
10219: PPUSH
10220: CALL_OW 102
// YouWin ;
10224: CALL_OW 103
// end ; end_of_file
10228: END
// export function CustomEvent ( event ) ; begin
10229: LD_INT 0
10231: PPUSH
// end ;
10232: LD_VAR 0 2
10236: RET
// on Command ( com ) do var i , j , temp ;
10237: LD_INT 0
10239: PPUSH
10240: PPUSH
10241: PPUSH
// begin if com = 60 then
10242: LD_VAR 0 1
10246: PUSH
10247: LD_INT 60
10249: EQUAL
10250: IFFALSE 10429
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10252: LD_ADDR_VAR 0 2
10256: PUSH
10257: LD_INT 22
10259: PUSH
10260: LD_INT 1
10262: PUSH
10263: EMPTY
10264: LIST
10265: LIST
10266: PUSH
10267: LD_INT 2
10269: PUSH
10270: LD_INT 21
10272: PUSH
10273: LD_INT 1
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PUSH
10280: LD_INT 34
10282: PUSH
10283: LD_INT 12
10285: PUSH
10286: EMPTY
10287: LIST
10288: LIST
10289: PUSH
10290: EMPTY
10291: LIST
10292: LIST
10293: LIST
10294: PUSH
10295: EMPTY
10296: LIST
10297: LIST
10298: PPUSH
10299: CALL_OW 69
10303: PUSH
10304: FOR_IN
10305: IFFALSE 10427
// begin if GetTaskList ( i ) > 0 then
10307: LD_VAR 0 2
10311: PPUSH
10312: CALL_OW 437
10316: PUSH
10317: LD_INT 0
10319: GREATER
10320: IFFALSE 10425
// for j = 1 to GetTaskList ( i ) do
10322: LD_ADDR_VAR 0 3
10326: PUSH
10327: DOUBLE
10328: LD_INT 1
10330: DEC
10331: ST_TO_ADDR
10332: LD_VAR 0 2
10336: PPUSH
10337: CALL_OW 437
10341: PUSH
10342: FOR_TO
10343: IFFALSE 10423
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10345: LD_ADDR_VAR 0 4
10349: PUSH
10350: LD_VAR 0 2
10354: PPUSH
10355: CALL_OW 437
10359: PUSH
10360: LD_VAR 0 3
10364: ARRAY
10365: PUSH
10366: LD_INT 4
10368: ARRAY
10369: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10370: LD_VAR 0 4
10374: PPUSH
10375: CALL_OW 255
10379: PUSH
10380: LD_INT 4
10382: EQUAL
10383: PUSH
10384: LD_VAR 0 2
10388: PPUSH
10389: CALL_OW 437
10393: PUSH
10394: LD_VAR 0 3
10398: ARRAY
10399: PUSH
10400: LD_INT 1
10402: ARRAY
10403: PUSH
10404: LD_STRING <
10406: EQUAL
10407: AND
10408: IFFALSE 10421
// SetTaskList ( i , [ ] ) ;
10410: LD_VAR 0 2
10414: PPUSH
10415: EMPTY
10416: PPUSH
10417: CALL_OW 446
// end ;
10421: GO 10342
10423: POP
10424: POP
// end ;
10425: GO 10304
10427: POP
10428: POP
// end ; end ;
10429: PPOPN 4
10431: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10432: LD_VAR 0 2
10436: PPUSH
10437: LD_VAR 0 3
10441: PPUSH
10442: CALL_OW 428
10446: PPUSH
10447: CALL_OW 255
10451: PUSH
10452: LD_INT 1
10454: EQUAL
10455: PUSH
10456: LD_VAR 0 2
10460: PUSH
10461: LD_INT 132
10463: EQUAL
10464: PUSH
10465: LD_VAR 0 3
10469: PUSH
10470: LD_INT 39
10472: EQUAL
10473: AND
10474: OR
10475: IFFALSE 10491
// DialogContaminateSib ( x , y ) ;
10477: LD_VAR 0 2
10481: PPUSH
10482: LD_VAR 0 3
10486: PPUSH
10487: CALL 9605 0 2
// end ;
10491: PPOPN 3
10493: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10494: LD_VAR 0 1
10498: PPUSH
10499: CALL 90238 0 1
// MCE_UnitDestroyed ( un ) ;
10503: LD_VAR 0 1
10507: PPUSH
10508: CALL 79953 0 1
// if un = Powell then
10512: LD_VAR 0 1
10516: PUSH
10517: LD_EXP 10
10521: EQUAL
10522: IFFALSE 10531
// YouLost ( Powell ) ;
10524: LD_STRING Powell
10526: PPUSH
10527: CALL_OW 104
// if un = Sikorski then
10531: LD_VAR 0 1
10535: PUSH
10536: LD_EXP 20
10540: EQUAL
10541: IFFALSE 10550
// YouLost ( Sikorski ) ;
10543: LD_STRING Sikorski
10545: PPUSH
10546: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10550: LD_VAR 0 1
10554: PUSH
10555: LD_INT 22
10557: PUSH
10558: LD_INT 1
10560: PUSH
10561: EMPTY
10562: LIST
10563: LIST
10564: PUSH
10565: LD_INT 21
10567: PUSH
10568: LD_INT 1
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: PUSH
10575: EMPTY
10576: LIST
10577: LIST
10578: PPUSH
10579: CALL_OW 69
10583: IN
10584: IFFALSE 10600
// loseCounter := loseCounter + 1 ;
10586: LD_ADDR_EXP 6
10590: PUSH
10591: LD_EXP 6
10595: PUSH
10596: LD_INT 1
10598: PLUS
10599: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10600: LD_VAR 0 1
10604: PUSH
10605: LD_INT 22
10607: PUSH
10608: LD_INT 4
10610: PUSH
10611: EMPTY
10612: LIST
10613: LIST
10614: PUSH
10615: LD_INT 21
10617: PUSH
10618: LD_INT 1
10620: PUSH
10621: EMPTY
10622: LIST
10623: LIST
10624: PUSH
10625: EMPTY
10626: LIST
10627: LIST
10628: PPUSH
10629: CALL_OW 69
10633: IN
10634: IFFALSE 10650
// powellLoseCounter := powellLoseCounter + 1 ;
10636: LD_ADDR_EXP 7
10640: PUSH
10641: LD_EXP 7
10645: PUSH
10646: LD_INT 1
10648: PLUS
10649: ST_TO_ADDR
// if un in powellAttackGroup then
10650: LD_VAR 0 1
10654: PUSH
10655: LD_EXP 12
10659: IN
10660: IFFALSE 10678
// powellAttackGroup := powellAttackGroup diff un ;
10662: LD_ADDR_EXP 12
10666: PUSH
10667: LD_EXP 12
10671: PUSH
10672: LD_VAR 0 1
10676: DIFF
10677: ST_TO_ADDR
// if un in gensherAttackGroup then
10678: LD_VAR 0 1
10682: PUSH
10683: LD_EXP 15
10687: IN
10688: IFFALSE 10706
// gensherAttackGroup := gensherAttackGroup diff un ;
10690: LD_ADDR_EXP 15
10694: PUSH
10695: LD_EXP 15
10699: PUSH
10700: LD_VAR 0 1
10704: DIFF
10705: ST_TO_ADDR
// if un in popovAttackGroup then
10706: LD_VAR 0 1
10710: PUSH
10711: LD_EXP 19
10715: IN
10716: IFFALSE 10734
// popovAttackGroup := popovAttackGroup diff un ;
10718: LD_ADDR_EXP 19
10722: PUSH
10723: LD_EXP 19
10727: PUSH
10728: LD_VAR 0 1
10732: DIFF
10733: ST_TO_ADDR
// end ;
10734: PPOPN 1
10736: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10737: LD_VAR 0 1
10741: PPUSH
10742: LD_VAR 0 2
10746: PPUSH
10747: CALL 82285 0 2
// end ;
10751: PPOPN 2
10753: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10754: LD_VAR 0 1
10758: PPUSH
10759: CALL 81353 0 1
// end ;
10763: PPOPN 1
10765: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10766: LD_VAR 0 1
10770: PPUSH
10771: CALL 81594 0 1
// end ;
10775: PPOPN 1
10777: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10778: LD_VAR 0 1
10782: PPUSH
10783: LD_VAR 0 2
10787: PPUSH
10788: CALL 79649 0 2
// end ;
10792: PPOPN 2
10794: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10795: LD_VAR 0 1
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: LD_VAR 0 3
10809: PPUSH
10810: LD_VAR 0 4
10814: PPUSH
10815: LD_VAR 0 5
10819: PPUSH
10820: CALL 79269 0 5
// end ;
10824: PPOPN 5
10826: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10827: LD_VAR 0 1
10831: PPUSH
10832: LD_VAR 0 2
10836: PPUSH
10837: CALL 90358 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10841: LD_VAR 0 1
10845: PPUSH
10846: LD_VAR 0 2
10850: PPUSH
10851: CALL 78860 0 2
// end ;
10855: PPOPN 2
10857: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10858: LD_VAR 0 1
10862: PPUSH
10863: LD_VAR 0 2
10867: PPUSH
10868: LD_VAR 0 3
10872: PPUSH
10873: LD_VAR 0 4
10877: PPUSH
10878: CALL 78698 0 4
// end ;
10882: PPOPN 4
10884: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10885: LD_VAR 0 1
10889: PPUSH
10890: LD_VAR 0 2
10894: PPUSH
10895: LD_VAR 0 3
10899: PPUSH
10900: CALL 78473 0 3
// end ;
10904: PPOPN 3
10906: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10907: LD_VAR 0 1
10911: PPUSH
10912: LD_VAR 0 2
10916: PPUSH
10917: CALL 78358 0 2
// end ;
10921: PPOPN 2
10923: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10924: LD_VAR 0 1
10928: PPUSH
10929: LD_VAR 0 2
10933: PPUSH
10934: CALL 82580 0 2
// end ;
10938: PPOPN 2
10940: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_VAR 0 2
10950: PPUSH
10951: LD_VAR 0 3
10955: PPUSH
10956: LD_VAR 0 4
10960: PPUSH
10961: CALL 82796 0 4
// end ;
10965: PPOPN 4
10967: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10968: LD_VAR 0 1
10972: PPUSH
10973: LD_VAR 0 2
10977: PPUSH
10978: CALL 78167 0 2
// end ;
10982: PPOPN 2
10984: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10985: LD_VAR 0 1
10989: PUSH
10990: LD_INT 1
10992: EQUAL
10993: PUSH
10994: LD_VAR 0 2
10998: PUSH
10999: LD_INT 4
11001: EQUAL
11002: AND
11003: IFFALSE 11012
// YouLost ( FriendlyFire ) ;
11005: LD_STRING FriendlyFire
11007: PPUSH
11008: CALL_OW 104
// end ; end_of_file
11012: PPOPN 2
11014: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11015: LD_INT 0
11017: PPUSH
11018: PPUSH
// if exist_mode then
11019: LD_VAR 0 2
11023: IFFALSE 11048
// unit := CreateCharacter ( prefix & ident ) else
11025: LD_ADDR_VAR 0 5
11029: PUSH
11030: LD_VAR 0 3
11034: PUSH
11035: LD_VAR 0 1
11039: STR
11040: PPUSH
11041: CALL_OW 34
11045: ST_TO_ADDR
11046: GO 11063
// unit := NewCharacter ( ident ) ;
11048: LD_ADDR_VAR 0 5
11052: PUSH
11053: LD_VAR 0 1
11057: PPUSH
11058: CALL_OW 25
11062: ST_TO_ADDR
// result := unit ;
11063: LD_ADDR_VAR 0 4
11067: PUSH
11068: LD_VAR 0 5
11072: ST_TO_ADDR
// end ;
11073: LD_VAR 0 4
11077: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11078: LD_INT 0
11080: PPUSH
11081: PPUSH
// if not side or not nation then
11082: LD_VAR 0 1
11086: NOT
11087: PUSH
11088: LD_VAR 0 2
11092: NOT
11093: OR
11094: IFFALSE 11098
// exit ;
11096: GO 11866
// case nation of nation_american :
11098: LD_VAR 0 2
11102: PUSH
11103: LD_INT 1
11105: DOUBLE
11106: EQUAL
11107: IFTRUE 11111
11109: GO 11325
11111: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11112: LD_ADDR_VAR 0 4
11116: PUSH
11117: LD_INT 35
11119: PUSH
11120: LD_INT 45
11122: PUSH
11123: LD_INT 46
11125: PUSH
11126: LD_INT 47
11128: PUSH
11129: LD_INT 82
11131: PUSH
11132: LD_INT 83
11134: PUSH
11135: LD_INT 84
11137: PUSH
11138: LD_INT 85
11140: PUSH
11141: LD_INT 86
11143: PUSH
11144: LD_INT 1
11146: PUSH
11147: LD_INT 2
11149: PUSH
11150: LD_INT 6
11152: PUSH
11153: LD_INT 15
11155: PUSH
11156: LD_INT 16
11158: PUSH
11159: LD_INT 7
11161: PUSH
11162: LD_INT 12
11164: PUSH
11165: LD_INT 13
11167: PUSH
11168: LD_INT 10
11170: PUSH
11171: LD_INT 14
11173: PUSH
11174: LD_INT 20
11176: PUSH
11177: LD_INT 21
11179: PUSH
11180: LD_INT 22
11182: PUSH
11183: LD_INT 25
11185: PUSH
11186: LD_INT 32
11188: PUSH
11189: LD_INT 27
11191: PUSH
11192: LD_INT 36
11194: PUSH
11195: LD_INT 69
11197: PUSH
11198: LD_INT 39
11200: PUSH
11201: LD_INT 34
11203: PUSH
11204: LD_INT 40
11206: PUSH
11207: LD_INT 48
11209: PUSH
11210: LD_INT 49
11212: PUSH
11213: LD_INT 50
11215: PUSH
11216: LD_INT 51
11218: PUSH
11219: LD_INT 52
11221: PUSH
11222: LD_INT 53
11224: PUSH
11225: LD_INT 54
11227: PUSH
11228: LD_INT 55
11230: PUSH
11231: LD_INT 56
11233: PUSH
11234: LD_INT 57
11236: PUSH
11237: LD_INT 58
11239: PUSH
11240: LD_INT 59
11242: PUSH
11243: LD_INT 60
11245: PUSH
11246: LD_INT 61
11248: PUSH
11249: LD_INT 62
11251: PUSH
11252: LD_INT 80
11254: PUSH
11255: LD_INT 82
11257: PUSH
11258: LD_INT 83
11260: PUSH
11261: LD_INT 84
11263: PUSH
11264: LD_INT 85
11266: PUSH
11267: LD_INT 86
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: ST_TO_ADDR
11323: GO 11790
11325: LD_INT 2
11327: DOUBLE
11328: EQUAL
11329: IFTRUE 11333
11331: GO 11559
11333: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11334: LD_ADDR_VAR 0 4
11338: PUSH
11339: LD_INT 35
11341: PUSH
11342: LD_INT 45
11344: PUSH
11345: LD_INT 46
11347: PUSH
11348: LD_INT 47
11350: PUSH
11351: LD_INT 82
11353: PUSH
11354: LD_INT 83
11356: PUSH
11357: LD_INT 84
11359: PUSH
11360: LD_INT 85
11362: PUSH
11363: LD_INT 87
11365: PUSH
11366: LD_INT 70
11368: PUSH
11369: LD_INT 1
11371: PUSH
11372: LD_INT 11
11374: PUSH
11375: LD_INT 3
11377: PUSH
11378: LD_INT 4
11380: PUSH
11381: LD_INT 5
11383: PUSH
11384: LD_INT 6
11386: PUSH
11387: LD_INT 15
11389: PUSH
11390: LD_INT 18
11392: PUSH
11393: LD_INT 7
11395: PUSH
11396: LD_INT 17
11398: PUSH
11399: LD_INT 8
11401: PUSH
11402: LD_INT 20
11404: PUSH
11405: LD_INT 21
11407: PUSH
11408: LD_INT 22
11410: PUSH
11411: LD_INT 72
11413: PUSH
11414: LD_INT 26
11416: PUSH
11417: LD_INT 69
11419: PUSH
11420: LD_INT 39
11422: PUSH
11423: LD_INT 40
11425: PUSH
11426: LD_INT 41
11428: PUSH
11429: LD_INT 42
11431: PUSH
11432: LD_INT 43
11434: PUSH
11435: LD_INT 48
11437: PUSH
11438: LD_INT 49
11440: PUSH
11441: LD_INT 50
11443: PUSH
11444: LD_INT 51
11446: PUSH
11447: LD_INT 52
11449: PUSH
11450: LD_INT 53
11452: PUSH
11453: LD_INT 54
11455: PUSH
11456: LD_INT 55
11458: PUSH
11459: LD_INT 56
11461: PUSH
11462: LD_INT 60
11464: PUSH
11465: LD_INT 61
11467: PUSH
11468: LD_INT 62
11470: PUSH
11471: LD_INT 66
11473: PUSH
11474: LD_INT 67
11476: PUSH
11477: LD_INT 68
11479: PUSH
11480: LD_INT 81
11482: PUSH
11483: LD_INT 82
11485: PUSH
11486: LD_INT 83
11488: PUSH
11489: LD_INT 84
11491: PUSH
11492: LD_INT 85
11494: PUSH
11495: LD_INT 87
11497: PUSH
11498: LD_INT 88
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: ST_TO_ADDR
11557: GO 11790
11559: LD_INT 3
11561: DOUBLE
11562: EQUAL
11563: IFTRUE 11567
11565: GO 11789
11567: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11568: LD_ADDR_VAR 0 4
11572: PUSH
11573: LD_INT 46
11575: PUSH
11576: LD_INT 47
11578: PUSH
11579: LD_INT 1
11581: PUSH
11582: LD_INT 2
11584: PUSH
11585: LD_INT 82
11587: PUSH
11588: LD_INT 83
11590: PUSH
11591: LD_INT 84
11593: PUSH
11594: LD_INT 85
11596: PUSH
11597: LD_INT 86
11599: PUSH
11600: LD_INT 11
11602: PUSH
11603: LD_INT 9
11605: PUSH
11606: LD_INT 20
11608: PUSH
11609: LD_INT 19
11611: PUSH
11612: LD_INT 21
11614: PUSH
11615: LD_INT 24
11617: PUSH
11618: LD_INT 22
11620: PUSH
11621: LD_INT 25
11623: PUSH
11624: LD_INT 28
11626: PUSH
11627: LD_INT 29
11629: PUSH
11630: LD_INT 30
11632: PUSH
11633: LD_INT 31
11635: PUSH
11636: LD_INT 37
11638: PUSH
11639: LD_INT 38
11641: PUSH
11642: LD_INT 32
11644: PUSH
11645: LD_INT 27
11647: PUSH
11648: LD_INT 33
11650: PUSH
11651: LD_INT 69
11653: PUSH
11654: LD_INT 39
11656: PUSH
11657: LD_INT 34
11659: PUSH
11660: LD_INT 40
11662: PUSH
11663: LD_INT 71
11665: PUSH
11666: LD_INT 23
11668: PUSH
11669: LD_INT 44
11671: PUSH
11672: LD_INT 48
11674: PUSH
11675: LD_INT 49
11677: PUSH
11678: LD_INT 50
11680: PUSH
11681: LD_INT 51
11683: PUSH
11684: LD_INT 52
11686: PUSH
11687: LD_INT 53
11689: PUSH
11690: LD_INT 54
11692: PUSH
11693: LD_INT 55
11695: PUSH
11696: LD_INT 56
11698: PUSH
11699: LD_INT 57
11701: PUSH
11702: LD_INT 58
11704: PUSH
11705: LD_INT 59
11707: PUSH
11708: LD_INT 63
11710: PUSH
11711: LD_INT 64
11713: PUSH
11714: LD_INT 65
11716: PUSH
11717: LD_INT 82
11719: PUSH
11720: LD_INT 83
11722: PUSH
11723: LD_INT 84
11725: PUSH
11726: LD_INT 85
11728: PUSH
11729: LD_INT 86
11731: PUSH
11732: EMPTY
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: ST_TO_ADDR
11787: GO 11790
11789: POP
// if state > - 1 and state < 3 then
11790: LD_VAR 0 3
11794: PUSH
11795: LD_INT 1
11797: NEG
11798: GREATER
11799: PUSH
11800: LD_VAR 0 3
11804: PUSH
11805: LD_INT 3
11807: LESS
11808: AND
11809: IFFALSE 11866
// for i in result do
11811: LD_ADDR_VAR 0 5
11815: PUSH
11816: LD_VAR 0 4
11820: PUSH
11821: FOR_IN
11822: IFFALSE 11864
// if GetTech ( i , side ) <> state then
11824: LD_VAR 0 5
11828: PPUSH
11829: LD_VAR 0 1
11833: PPUSH
11834: CALL_OW 321
11838: PUSH
11839: LD_VAR 0 3
11843: NONEQUAL
11844: IFFALSE 11862
// result := result diff i ;
11846: LD_ADDR_VAR 0 4
11850: PUSH
11851: LD_VAR 0 4
11855: PUSH
11856: LD_VAR 0 5
11860: DIFF
11861: ST_TO_ADDR
11862: GO 11821
11864: POP
11865: POP
// end ;
11866: LD_VAR 0 4
11870: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11871: LD_INT 0
11873: PPUSH
11874: PPUSH
11875: PPUSH
// result := true ;
11876: LD_ADDR_VAR 0 3
11880: PUSH
11881: LD_INT 1
11883: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11884: LD_ADDR_VAR 0 5
11888: PUSH
11889: LD_VAR 0 2
11893: PPUSH
11894: CALL_OW 480
11898: ST_TO_ADDR
// if not tmp then
11899: LD_VAR 0 5
11903: NOT
11904: IFFALSE 11908
// exit ;
11906: GO 11957
// for i in tmp do
11908: LD_ADDR_VAR 0 4
11912: PUSH
11913: LD_VAR 0 5
11917: PUSH
11918: FOR_IN
11919: IFFALSE 11955
// if GetTech ( i , side ) <> state_researched then
11921: LD_VAR 0 4
11925: PPUSH
11926: LD_VAR 0 1
11930: PPUSH
11931: CALL_OW 321
11935: PUSH
11936: LD_INT 2
11938: NONEQUAL
11939: IFFALSE 11953
// begin result := false ;
11941: LD_ADDR_VAR 0 3
11945: PUSH
11946: LD_INT 0
11948: ST_TO_ADDR
// exit ;
11949: POP
11950: POP
11951: GO 11957
// end ;
11953: GO 11918
11955: POP
11956: POP
// end ;
11957: LD_VAR 0 3
11961: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11962: LD_INT 0
11964: PPUSH
11965: PPUSH
11966: PPUSH
11967: PPUSH
11968: PPUSH
11969: PPUSH
11970: PPUSH
11971: PPUSH
11972: PPUSH
11973: PPUSH
11974: PPUSH
11975: PPUSH
11976: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11977: LD_VAR 0 1
11981: NOT
11982: PUSH
11983: LD_VAR 0 1
11987: PPUSH
11988: CALL_OW 257
11992: PUSH
11993: LD_INT 9
11995: NONEQUAL
11996: OR
11997: IFFALSE 12001
// exit ;
11999: GO 12574
// side := GetSide ( unit ) ;
12001: LD_ADDR_VAR 0 9
12005: PUSH
12006: LD_VAR 0 1
12010: PPUSH
12011: CALL_OW 255
12015: ST_TO_ADDR
// tech_space := tech_spacanom ;
12016: LD_ADDR_VAR 0 12
12020: PUSH
12021: LD_INT 29
12023: ST_TO_ADDR
// tech_time := tech_taurad ;
12024: LD_ADDR_VAR 0 13
12028: PUSH
12029: LD_INT 28
12031: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12032: LD_ADDR_VAR 0 11
12036: PUSH
12037: LD_VAR 0 1
12041: PPUSH
12042: CALL_OW 310
12046: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12047: LD_VAR 0 11
12051: PPUSH
12052: CALL_OW 247
12056: PUSH
12057: LD_INT 2
12059: EQUAL
12060: IFFALSE 12064
// exit ;
12062: GO 12574
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12064: LD_ADDR_VAR 0 8
12068: PUSH
12069: LD_INT 81
12071: PUSH
12072: LD_VAR 0 9
12076: PUSH
12077: EMPTY
12078: LIST
12079: LIST
12080: PUSH
12081: LD_INT 3
12083: PUSH
12084: LD_INT 21
12086: PUSH
12087: LD_INT 3
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PPUSH
12102: CALL_OW 69
12106: ST_TO_ADDR
// if not tmp then
12107: LD_VAR 0 8
12111: NOT
12112: IFFALSE 12116
// exit ;
12114: GO 12574
// if in_unit then
12116: LD_VAR 0 11
12120: IFFALSE 12144
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12122: LD_ADDR_VAR 0 10
12126: PUSH
12127: LD_VAR 0 8
12131: PPUSH
12132: LD_VAR 0 11
12136: PPUSH
12137: CALL_OW 74
12141: ST_TO_ADDR
12142: GO 12164
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12144: LD_ADDR_VAR 0 10
12148: PUSH
12149: LD_VAR 0 8
12153: PPUSH
12154: LD_VAR 0 1
12158: PPUSH
12159: CALL_OW 74
12163: ST_TO_ADDR
// if not enemy then
12164: LD_VAR 0 10
12168: NOT
12169: IFFALSE 12173
// exit ;
12171: GO 12574
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12173: LD_VAR 0 11
12177: PUSH
12178: LD_VAR 0 11
12182: PPUSH
12183: LD_VAR 0 10
12187: PPUSH
12188: CALL_OW 296
12192: PUSH
12193: LD_INT 13
12195: GREATER
12196: AND
12197: PUSH
12198: LD_VAR 0 1
12202: PPUSH
12203: LD_VAR 0 10
12207: PPUSH
12208: CALL_OW 296
12212: PUSH
12213: LD_INT 12
12215: GREATER
12216: OR
12217: IFFALSE 12221
// exit ;
12219: GO 12574
// missile := [ 1 ] ;
12221: LD_ADDR_VAR 0 14
12225: PUSH
12226: LD_INT 1
12228: PUSH
12229: EMPTY
12230: LIST
12231: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12232: LD_VAR 0 9
12236: PPUSH
12237: LD_VAR 0 12
12241: PPUSH
12242: CALL_OW 325
12246: IFFALSE 12275
// missile := Replace ( missile , missile + 1 , 2 ) ;
12248: LD_ADDR_VAR 0 14
12252: PUSH
12253: LD_VAR 0 14
12257: PPUSH
12258: LD_VAR 0 14
12262: PUSH
12263: LD_INT 1
12265: PLUS
12266: PPUSH
12267: LD_INT 2
12269: PPUSH
12270: CALL_OW 1
12274: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12275: LD_VAR 0 9
12279: PPUSH
12280: LD_VAR 0 13
12284: PPUSH
12285: CALL_OW 325
12289: PUSH
12290: LD_VAR 0 10
12294: PPUSH
12295: CALL_OW 255
12299: PPUSH
12300: LD_VAR 0 13
12304: PPUSH
12305: CALL_OW 325
12309: NOT
12310: AND
12311: IFFALSE 12340
// missile := Replace ( missile , missile + 1 , 3 ) ;
12313: LD_ADDR_VAR 0 14
12317: PUSH
12318: LD_VAR 0 14
12322: PPUSH
12323: LD_VAR 0 14
12327: PUSH
12328: LD_INT 1
12330: PLUS
12331: PPUSH
12332: LD_INT 3
12334: PPUSH
12335: CALL_OW 1
12339: ST_TO_ADDR
// if missile < 2 then
12340: LD_VAR 0 14
12344: PUSH
12345: LD_INT 2
12347: LESS
12348: IFFALSE 12352
// exit ;
12350: GO 12574
// x := GetX ( enemy ) ;
12352: LD_ADDR_VAR 0 4
12356: PUSH
12357: LD_VAR 0 10
12361: PPUSH
12362: CALL_OW 250
12366: ST_TO_ADDR
// y := GetY ( enemy ) ;
12367: LD_ADDR_VAR 0 5
12371: PUSH
12372: LD_VAR 0 10
12376: PPUSH
12377: CALL_OW 251
12381: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12382: LD_ADDR_VAR 0 6
12386: PUSH
12387: LD_VAR 0 4
12391: PUSH
12392: LD_INT 1
12394: NEG
12395: PPUSH
12396: LD_INT 1
12398: PPUSH
12399: CALL_OW 12
12403: PLUS
12404: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12405: LD_ADDR_VAR 0 7
12409: PUSH
12410: LD_VAR 0 5
12414: PUSH
12415: LD_INT 1
12417: NEG
12418: PPUSH
12419: LD_INT 1
12421: PPUSH
12422: CALL_OW 12
12426: PLUS
12427: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12428: LD_VAR 0 6
12432: PPUSH
12433: LD_VAR 0 7
12437: PPUSH
12438: CALL_OW 488
12442: NOT
12443: IFFALSE 12465
// begin _x := x ;
12445: LD_ADDR_VAR 0 6
12449: PUSH
12450: LD_VAR 0 4
12454: ST_TO_ADDR
// _y := y ;
12455: LD_ADDR_VAR 0 7
12459: PUSH
12460: LD_VAR 0 5
12464: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12465: LD_ADDR_VAR 0 3
12469: PUSH
12470: LD_INT 1
12472: PPUSH
12473: LD_VAR 0 14
12477: PPUSH
12478: CALL_OW 12
12482: ST_TO_ADDR
// case i of 1 :
12483: LD_VAR 0 3
12487: PUSH
12488: LD_INT 1
12490: DOUBLE
12491: EQUAL
12492: IFTRUE 12496
12494: GO 12513
12496: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12497: LD_VAR 0 1
12501: PPUSH
12502: LD_VAR 0 10
12506: PPUSH
12507: CALL_OW 115
12511: GO 12574
12513: LD_INT 2
12515: DOUBLE
12516: EQUAL
12517: IFTRUE 12521
12519: GO 12543
12521: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12522: LD_VAR 0 1
12526: PPUSH
12527: LD_VAR 0 6
12531: PPUSH
12532: LD_VAR 0 7
12536: PPUSH
12537: CALL_OW 153
12541: GO 12574
12543: LD_INT 3
12545: DOUBLE
12546: EQUAL
12547: IFTRUE 12551
12549: GO 12573
12551: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12552: LD_VAR 0 1
12556: PPUSH
12557: LD_VAR 0 6
12561: PPUSH
12562: LD_VAR 0 7
12566: PPUSH
12567: CALL_OW 154
12571: GO 12574
12573: POP
// end ;
12574: LD_VAR 0 2
12578: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12579: LD_INT 0
12581: PPUSH
12582: PPUSH
12583: PPUSH
12584: PPUSH
12585: PPUSH
12586: PPUSH
// if not unit or not building then
12587: LD_VAR 0 1
12591: NOT
12592: PUSH
12593: LD_VAR 0 2
12597: NOT
12598: OR
12599: IFFALSE 12603
// exit ;
12601: GO 12761
// x := GetX ( building ) ;
12603: LD_ADDR_VAR 0 5
12607: PUSH
12608: LD_VAR 0 2
12612: PPUSH
12613: CALL_OW 250
12617: ST_TO_ADDR
// y := GetY ( building ) ;
12618: LD_ADDR_VAR 0 6
12622: PUSH
12623: LD_VAR 0 2
12627: PPUSH
12628: CALL_OW 251
12632: ST_TO_ADDR
// for i = 0 to 5 do
12633: LD_ADDR_VAR 0 4
12637: PUSH
12638: DOUBLE
12639: LD_INT 0
12641: DEC
12642: ST_TO_ADDR
12643: LD_INT 5
12645: PUSH
12646: FOR_TO
12647: IFFALSE 12759
// begin _x := ShiftX ( x , i , 3 ) ;
12649: LD_ADDR_VAR 0 7
12653: PUSH
12654: LD_VAR 0 5
12658: PPUSH
12659: LD_VAR 0 4
12663: PPUSH
12664: LD_INT 3
12666: PPUSH
12667: CALL_OW 272
12671: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12672: LD_ADDR_VAR 0 8
12676: PUSH
12677: LD_VAR 0 6
12681: PPUSH
12682: LD_VAR 0 4
12686: PPUSH
12687: LD_INT 3
12689: PPUSH
12690: CALL_OW 273
12694: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12695: LD_VAR 0 7
12699: PPUSH
12700: LD_VAR 0 8
12704: PPUSH
12705: CALL_OW 488
12709: NOT
12710: IFFALSE 12714
// continue ;
12712: GO 12646
// if HexInfo ( _x , _y ) = 0 then
12714: LD_VAR 0 7
12718: PPUSH
12719: LD_VAR 0 8
12723: PPUSH
12724: CALL_OW 428
12728: PUSH
12729: LD_INT 0
12731: EQUAL
12732: IFFALSE 12757
// begin ComMoveXY ( unit , _x , _y ) ;
12734: LD_VAR 0 1
12738: PPUSH
12739: LD_VAR 0 7
12743: PPUSH
12744: LD_VAR 0 8
12748: PPUSH
12749: CALL_OW 111
// exit ;
12753: POP
12754: POP
12755: GO 12761
// end ; end ;
12757: GO 12646
12759: POP
12760: POP
// end ;
12761: LD_VAR 0 3
12765: RET
// export function ScanBase ( side , base_area ) ; begin
12766: LD_INT 0
12768: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12769: LD_ADDR_VAR 0 3
12773: PUSH
12774: LD_VAR 0 2
12778: PPUSH
12779: LD_INT 81
12781: PUSH
12782: LD_VAR 0 1
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PPUSH
12791: CALL_OW 70
12795: ST_TO_ADDR
// end ;
12796: LD_VAR 0 3
12800: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12801: LD_INT 0
12803: PPUSH
12804: PPUSH
12805: PPUSH
12806: PPUSH
// result := false ;
12807: LD_ADDR_VAR 0 2
12811: PUSH
12812: LD_INT 0
12814: ST_TO_ADDR
// side := GetSide ( unit ) ;
12815: LD_ADDR_VAR 0 3
12819: PUSH
12820: LD_VAR 0 1
12824: PPUSH
12825: CALL_OW 255
12829: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12830: LD_ADDR_VAR 0 4
12834: PUSH
12835: LD_VAR 0 1
12839: PPUSH
12840: CALL_OW 248
12844: ST_TO_ADDR
// case nat of 1 :
12845: LD_VAR 0 4
12849: PUSH
12850: LD_INT 1
12852: DOUBLE
12853: EQUAL
12854: IFTRUE 12858
12856: GO 12869
12858: POP
// tech := tech_lassight ; 2 :
12859: LD_ADDR_VAR 0 5
12863: PUSH
12864: LD_INT 12
12866: ST_TO_ADDR
12867: GO 12908
12869: LD_INT 2
12871: DOUBLE
12872: EQUAL
12873: IFTRUE 12877
12875: GO 12888
12877: POP
// tech := tech_mortar ; 3 :
12878: LD_ADDR_VAR 0 5
12882: PUSH
12883: LD_INT 41
12885: ST_TO_ADDR
12886: GO 12908
12888: LD_INT 3
12890: DOUBLE
12891: EQUAL
12892: IFTRUE 12896
12894: GO 12907
12896: POP
// tech := tech_bazooka ; end ;
12897: LD_ADDR_VAR 0 5
12901: PUSH
12902: LD_INT 44
12904: ST_TO_ADDR
12905: GO 12908
12907: POP
// if Researched ( side , tech ) then
12908: LD_VAR 0 3
12912: PPUSH
12913: LD_VAR 0 5
12917: PPUSH
12918: CALL_OW 325
12922: IFFALSE 12949
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12924: LD_ADDR_VAR 0 2
12928: PUSH
12929: LD_INT 5
12931: PUSH
12932: LD_INT 8
12934: PUSH
12935: LD_INT 9
12937: PUSH
12938: EMPTY
12939: LIST
12940: LIST
12941: LIST
12942: PUSH
12943: LD_VAR 0 4
12947: ARRAY
12948: ST_TO_ADDR
// end ;
12949: LD_VAR 0 2
12953: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12954: LD_INT 0
12956: PPUSH
12957: PPUSH
12958: PPUSH
// if not mines then
12959: LD_VAR 0 2
12963: NOT
12964: IFFALSE 12968
// exit ;
12966: GO 13112
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12968: LD_ADDR_VAR 0 5
12972: PUSH
12973: LD_INT 81
12975: PUSH
12976: LD_VAR 0 1
12980: PUSH
12981: EMPTY
12982: LIST
12983: LIST
12984: PUSH
12985: LD_INT 3
12987: PUSH
12988: LD_INT 21
12990: PUSH
12991: LD_INT 3
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: PPUSH
13006: CALL_OW 69
13010: ST_TO_ADDR
// for i in mines do
13011: LD_ADDR_VAR 0 4
13015: PUSH
13016: LD_VAR 0 2
13020: PUSH
13021: FOR_IN
13022: IFFALSE 13110
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13024: LD_VAR 0 4
13028: PUSH
13029: LD_INT 1
13031: ARRAY
13032: PPUSH
13033: LD_VAR 0 4
13037: PUSH
13038: LD_INT 2
13040: ARRAY
13041: PPUSH
13042: CALL_OW 458
13046: NOT
13047: IFFALSE 13051
// continue ;
13049: GO 13021
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13051: LD_VAR 0 4
13055: PUSH
13056: LD_INT 1
13058: ARRAY
13059: PPUSH
13060: LD_VAR 0 4
13064: PUSH
13065: LD_INT 2
13067: ARRAY
13068: PPUSH
13069: CALL_OW 428
13073: PUSH
13074: LD_VAR 0 5
13078: IN
13079: IFFALSE 13108
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13081: LD_VAR 0 4
13085: PUSH
13086: LD_INT 1
13088: ARRAY
13089: PPUSH
13090: LD_VAR 0 4
13094: PUSH
13095: LD_INT 2
13097: ARRAY
13098: PPUSH
13099: LD_VAR 0 1
13103: PPUSH
13104: CALL_OW 456
// end ;
13108: GO 13021
13110: POP
13111: POP
// end ;
13112: LD_VAR 0 3
13116: RET
// export function Count ( array ) ; var i ; begin
13117: LD_INT 0
13119: PPUSH
13120: PPUSH
// result := 0 ;
13121: LD_ADDR_VAR 0 2
13125: PUSH
13126: LD_INT 0
13128: ST_TO_ADDR
// for i in array do
13129: LD_ADDR_VAR 0 3
13133: PUSH
13134: LD_VAR 0 1
13138: PUSH
13139: FOR_IN
13140: IFFALSE 13164
// if i then
13142: LD_VAR 0 3
13146: IFFALSE 13162
// result := result + 1 ;
13148: LD_ADDR_VAR 0 2
13152: PUSH
13153: LD_VAR 0 2
13157: PUSH
13158: LD_INT 1
13160: PLUS
13161: ST_TO_ADDR
13162: GO 13139
13164: POP
13165: POP
// end ;
13166: LD_VAR 0 2
13170: RET
// export function IsEmpty ( building ) ; begin
13171: LD_INT 0
13173: PPUSH
// if not building then
13174: LD_VAR 0 1
13178: NOT
13179: IFFALSE 13183
// exit ;
13181: GO 13226
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13183: LD_ADDR_VAR 0 2
13187: PUSH
13188: LD_VAR 0 1
13192: PUSH
13193: LD_INT 22
13195: PUSH
13196: LD_VAR 0 1
13200: PPUSH
13201: CALL_OW 255
13205: PUSH
13206: EMPTY
13207: LIST
13208: LIST
13209: PUSH
13210: LD_INT 58
13212: PUSH
13213: EMPTY
13214: LIST
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PPUSH
13220: CALL_OW 69
13224: IN
13225: ST_TO_ADDR
// end ;
13226: LD_VAR 0 2
13230: RET
// export function IsNotFull ( building ) ; var places ; begin
13231: LD_INT 0
13233: PPUSH
13234: PPUSH
// if not building then
13235: LD_VAR 0 1
13239: NOT
13240: IFFALSE 13244
// exit ;
13242: GO 13415
// result := false ;
13244: LD_ADDR_VAR 0 2
13248: PUSH
13249: LD_INT 0
13251: ST_TO_ADDR
// places := 0 ;
13252: LD_ADDR_VAR 0 3
13256: PUSH
13257: LD_INT 0
13259: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
13260: LD_VAR 0 1
13264: PPUSH
13265: CALL_OW 266
13269: PUSH
13270: LD_INT 0
13272: DOUBLE
13273: EQUAL
13274: IFTRUE 13332
13276: LD_INT 1
13278: DOUBLE
13279: EQUAL
13280: IFTRUE 13332
13282: LD_INT 6
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13332
13288: LD_INT 7
13290: DOUBLE
13291: EQUAL
13292: IFTRUE 13332
13294: LD_INT 8
13296: DOUBLE
13297: EQUAL
13298: IFTRUE 13332
13300: LD_INT 4
13302: DOUBLE
13303: EQUAL
13304: IFTRUE 13332
13306: LD_INT 5
13308: DOUBLE
13309: EQUAL
13310: IFTRUE 13332
13312: LD_INT 2
13314: DOUBLE
13315: EQUAL
13316: IFTRUE 13332
13318: LD_INT 3
13320: DOUBLE
13321: EQUAL
13322: IFTRUE 13332
13324: LD_INT 35
13326: DOUBLE
13327: EQUAL
13328: IFTRUE 13332
13330: GO 13343
13332: POP
// places := 6 ; b_bunker , b_breastwork :
13333: LD_ADDR_VAR 0 3
13337: PUSH
13338: LD_INT 6
13340: ST_TO_ADDR
13341: GO 13388
13343: LD_INT 32
13345: DOUBLE
13346: EQUAL
13347: IFTRUE 13357
13349: LD_INT 31
13351: DOUBLE
13352: EQUAL
13353: IFTRUE 13357
13355: GO 13368
13357: POP
// places := 1 ; b_control_tower :
13358: LD_ADDR_VAR 0 3
13362: PUSH
13363: LD_INT 1
13365: ST_TO_ADDR
13366: GO 13388
13368: LD_INT 36
13370: DOUBLE
13371: EQUAL
13372: IFTRUE 13376
13374: GO 13387
13376: POP
// places := 3 ; end ;
13377: LD_ADDR_VAR 0 3
13381: PUSH
13382: LD_INT 3
13384: ST_TO_ADDR
13385: GO 13388
13387: POP
// if places then
13388: LD_VAR 0 3
13392: IFFALSE 13415
// result := UnitsInside ( building ) < places ;
13394: LD_ADDR_VAR 0 2
13398: PUSH
13399: LD_VAR 0 1
13403: PPUSH
13404: CALL_OW 313
13408: PUSH
13409: LD_VAR 0 3
13413: LESS
13414: ST_TO_ADDR
// end ;
13415: LD_VAR 0 2
13419: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13420: LD_INT 0
13422: PPUSH
13423: PPUSH
13424: PPUSH
13425: PPUSH
// tmp := [ ] ;
13426: LD_ADDR_VAR 0 3
13430: PUSH
13431: EMPTY
13432: ST_TO_ADDR
// list := [ ] ;
13433: LD_ADDR_VAR 0 5
13437: PUSH
13438: EMPTY
13439: ST_TO_ADDR
// for i = 16 to 25 do
13440: LD_ADDR_VAR 0 4
13444: PUSH
13445: DOUBLE
13446: LD_INT 16
13448: DEC
13449: ST_TO_ADDR
13450: LD_INT 25
13452: PUSH
13453: FOR_TO
13454: IFFALSE 13527
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13456: LD_ADDR_VAR 0 3
13460: PUSH
13461: LD_VAR 0 3
13465: PUSH
13466: LD_INT 22
13468: PUSH
13469: LD_VAR 0 1
13473: PPUSH
13474: CALL_OW 255
13478: PUSH
13479: EMPTY
13480: LIST
13481: LIST
13482: PUSH
13483: LD_INT 91
13485: PUSH
13486: LD_VAR 0 1
13490: PUSH
13491: LD_INT 6
13493: PUSH
13494: EMPTY
13495: LIST
13496: LIST
13497: LIST
13498: PUSH
13499: LD_INT 30
13501: PUSH
13502: LD_VAR 0 4
13506: PUSH
13507: EMPTY
13508: LIST
13509: LIST
13510: PUSH
13511: EMPTY
13512: LIST
13513: LIST
13514: LIST
13515: PUSH
13516: EMPTY
13517: LIST
13518: PPUSH
13519: CALL_OW 69
13523: ADD
13524: ST_TO_ADDR
13525: GO 13453
13527: POP
13528: POP
// for i = 1 to tmp do
13529: LD_ADDR_VAR 0 4
13533: PUSH
13534: DOUBLE
13535: LD_INT 1
13537: DEC
13538: ST_TO_ADDR
13539: LD_VAR 0 3
13543: PUSH
13544: FOR_TO
13545: IFFALSE 13633
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13547: LD_ADDR_VAR 0 5
13551: PUSH
13552: LD_VAR 0 5
13556: PUSH
13557: LD_VAR 0 3
13561: PUSH
13562: LD_VAR 0 4
13566: ARRAY
13567: PPUSH
13568: CALL_OW 266
13572: PUSH
13573: LD_VAR 0 3
13577: PUSH
13578: LD_VAR 0 4
13582: ARRAY
13583: PPUSH
13584: CALL_OW 250
13588: PUSH
13589: LD_VAR 0 3
13593: PUSH
13594: LD_VAR 0 4
13598: ARRAY
13599: PPUSH
13600: CALL_OW 251
13604: PUSH
13605: LD_VAR 0 3
13609: PUSH
13610: LD_VAR 0 4
13614: ARRAY
13615: PPUSH
13616: CALL_OW 254
13620: PUSH
13621: EMPTY
13622: LIST
13623: LIST
13624: LIST
13625: LIST
13626: PUSH
13627: EMPTY
13628: LIST
13629: ADD
13630: ST_TO_ADDR
13631: GO 13544
13633: POP
13634: POP
// result := list ;
13635: LD_ADDR_VAR 0 2
13639: PUSH
13640: LD_VAR 0 5
13644: ST_TO_ADDR
// end ;
13645: LD_VAR 0 2
13649: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13650: LD_INT 0
13652: PPUSH
13653: PPUSH
13654: PPUSH
13655: PPUSH
13656: PPUSH
13657: PPUSH
13658: PPUSH
// if not factory then
13659: LD_VAR 0 1
13663: NOT
13664: IFFALSE 13668
// exit ;
13666: GO 14261
// if control = control_apeman then
13668: LD_VAR 0 4
13672: PUSH
13673: LD_INT 5
13675: EQUAL
13676: IFFALSE 13785
// begin tmp := UnitsInside ( factory ) ;
13678: LD_ADDR_VAR 0 8
13682: PUSH
13683: LD_VAR 0 1
13687: PPUSH
13688: CALL_OW 313
13692: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13693: LD_VAR 0 8
13697: PPUSH
13698: LD_INT 25
13700: PUSH
13701: LD_INT 12
13703: PUSH
13704: EMPTY
13705: LIST
13706: LIST
13707: PPUSH
13708: CALL_OW 72
13712: NOT
13713: IFFALSE 13723
// control := control_manual ;
13715: LD_ADDR_VAR 0 4
13719: PUSH
13720: LD_INT 1
13722: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13723: LD_ADDR_VAR 0 8
13727: PUSH
13728: LD_VAR 0 1
13732: PPUSH
13733: CALL 13420 0 1
13737: ST_TO_ADDR
// if tmp then
13738: LD_VAR 0 8
13742: IFFALSE 13785
// begin for i in tmp do
13744: LD_ADDR_VAR 0 7
13748: PUSH
13749: LD_VAR 0 8
13753: PUSH
13754: FOR_IN
13755: IFFALSE 13783
// if i [ 1 ] = b_ext_radio then
13757: LD_VAR 0 7
13761: PUSH
13762: LD_INT 1
13764: ARRAY
13765: PUSH
13766: LD_INT 22
13768: EQUAL
13769: IFFALSE 13781
// begin control := control_remote ;
13771: LD_ADDR_VAR 0 4
13775: PUSH
13776: LD_INT 2
13778: ST_TO_ADDR
// break ;
13779: GO 13783
// end ;
13781: GO 13754
13783: POP
13784: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13785: LD_VAR 0 1
13789: PPUSH
13790: LD_VAR 0 2
13794: PPUSH
13795: LD_VAR 0 3
13799: PPUSH
13800: LD_VAR 0 4
13804: PPUSH
13805: LD_VAR 0 5
13809: PPUSH
13810: CALL_OW 448
13814: IFFALSE 13849
// begin result := [ chassis , engine , control , weapon ] ;
13816: LD_ADDR_VAR 0 6
13820: PUSH
13821: LD_VAR 0 2
13825: PUSH
13826: LD_VAR 0 3
13830: PUSH
13831: LD_VAR 0 4
13835: PUSH
13836: LD_VAR 0 5
13840: PUSH
13841: EMPTY
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: ST_TO_ADDR
// exit ;
13847: GO 14261
// end ; _chassis := AvailableChassisList ( factory ) ;
13849: LD_ADDR_VAR 0 9
13853: PUSH
13854: LD_VAR 0 1
13858: PPUSH
13859: CALL_OW 475
13863: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13864: LD_ADDR_VAR 0 11
13868: PUSH
13869: LD_VAR 0 1
13873: PPUSH
13874: CALL_OW 476
13878: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13879: LD_ADDR_VAR 0 12
13883: PUSH
13884: LD_VAR 0 1
13888: PPUSH
13889: CALL_OW 477
13893: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13894: LD_ADDR_VAR 0 10
13898: PUSH
13899: LD_VAR 0 1
13903: PPUSH
13904: CALL_OW 478
13908: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13909: LD_VAR 0 9
13913: NOT
13914: PUSH
13915: LD_VAR 0 11
13919: NOT
13920: OR
13921: PUSH
13922: LD_VAR 0 12
13926: NOT
13927: OR
13928: PUSH
13929: LD_VAR 0 10
13933: NOT
13934: OR
13935: IFFALSE 13970
// begin result := [ chassis , engine , control , weapon ] ;
13937: LD_ADDR_VAR 0 6
13941: PUSH
13942: LD_VAR 0 2
13946: PUSH
13947: LD_VAR 0 3
13951: PUSH
13952: LD_VAR 0 4
13956: PUSH
13957: LD_VAR 0 5
13961: PUSH
13962: EMPTY
13963: LIST
13964: LIST
13965: LIST
13966: LIST
13967: ST_TO_ADDR
// exit ;
13968: GO 14261
// end ; if not chassis in _chassis then
13970: LD_VAR 0 2
13974: PUSH
13975: LD_VAR 0 9
13979: IN
13980: NOT
13981: IFFALSE 14007
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13983: LD_ADDR_VAR 0 2
13987: PUSH
13988: LD_VAR 0 9
13992: PUSH
13993: LD_INT 1
13995: PPUSH
13996: LD_VAR 0 9
14000: PPUSH
14001: CALL_OW 12
14005: ARRAY
14006: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
14007: LD_VAR 0 2
14011: PPUSH
14012: LD_VAR 0 3
14016: PPUSH
14017: CALL 14266 0 2
14021: NOT
14022: IFFALSE 14081
// repeat engine := _engine [ 1 ] ;
14024: LD_ADDR_VAR 0 3
14028: PUSH
14029: LD_VAR 0 11
14033: PUSH
14034: LD_INT 1
14036: ARRAY
14037: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
14038: LD_ADDR_VAR 0 11
14042: PUSH
14043: LD_VAR 0 11
14047: PPUSH
14048: LD_INT 1
14050: PPUSH
14051: CALL_OW 3
14055: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14056: LD_VAR 0 2
14060: PPUSH
14061: LD_VAR 0 3
14065: PPUSH
14066: CALL 14266 0 2
14070: PUSH
14071: LD_VAR 0 11
14075: PUSH
14076: EMPTY
14077: EQUAL
14078: OR
14079: IFFALSE 14024
// if not control in _control then
14081: LD_VAR 0 4
14085: PUSH
14086: LD_VAR 0 12
14090: IN
14091: NOT
14092: IFFALSE 14118
// control := _control [ rand ( 1 , _control ) ] ;
14094: LD_ADDR_VAR 0 4
14098: PUSH
14099: LD_VAR 0 12
14103: PUSH
14104: LD_INT 1
14106: PPUSH
14107: LD_VAR 0 12
14111: PPUSH
14112: CALL_OW 12
14116: ARRAY
14117: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14118: LD_VAR 0 2
14122: PPUSH
14123: LD_VAR 0 5
14127: PPUSH
14128: CALL 14486 0 2
14132: NOT
14133: IFFALSE 14192
// repeat weapon := _weapon [ 1 ] ;
14135: LD_ADDR_VAR 0 5
14139: PUSH
14140: LD_VAR 0 10
14144: PUSH
14145: LD_INT 1
14147: ARRAY
14148: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14149: LD_ADDR_VAR 0 10
14153: PUSH
14154: LD_VAR 0 10
14158: PPUSH
14159: LD_INT 1
14161: PPUSH
14162: CALL_OW 3
14166: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14167: LD_VAR 0 2
14171: PPUSH
14172: LD_VAR 0 5
14176: PPUSH
14177: CALL 14486 0 2
14181: PUSH
14182: LD_VAR 0 10
14186: PUSH
14187: EMPTY
14188: EQUAL
14189: OR
14190: IFFALSE 14135
// result := [ ] ;
14192: LD_ADDR_VAR 0 6
14196: PUSH
14197: EMPTY
14198: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14199: LD_VAR 0 1
14203: PPUSH
14204: LD_VAR 0 2
14208: PPUSH
14209: LD_VAR 0 3
14213: PPUSH
14214: LD_VAR 0 4
14218: PPUSH
14219: LD_VAR 0 5
14223: PPUSH
14224: CALL_OW 448
14228: IFFALSE 14261
// result := [ chassis , engine , control , weapon ] ;
14230: LD_ADDR_VAR 0 6
14234: PUSH
14235: LD_VAR 0 2
14239: PUSH
14240: LD_VAR 0 3
14244: PUSH
14245: LD_VAR 0 4
14249: PUSH
14250: LD_VAR 0 5
14254: PUSH
14255: EMPTY
14256: LIST
14257: LIST
14258: LIST
14259: LIST
14260: ST_TO_ADDR
// end ;
14261: LD_VAR 0 6
14265: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14266: LD_INT 0
14268: PPUSH
// if not chassis or not engine then
14269: LD_VAR 0 1
14273: NOT
14274: PUSH
14275: LD_VAR 0 2
14279: NOT
14280: OR
14281: IFFALSE 14285
// exit ;
14283: GO 14481
// case engine of engine_solar :
14285: LD_VAR 0 2
14289: PUSH
14290: LD_INT 2
14292: DOUBLE
14293: EQUAL
14294: IFTRUE 14298
14296: GO 14336
14298: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14299: LD_ADDR_VAR 0 3
14303: PUSH
14304: LD_INT 11
14306: PUSH
14307: LD_INT 12
14309: PUSH
14310: LD_INT 13
14312: PUSH
14313: LD_INT 14
14315: PUSH
14316: LD_INT 1
14318: PUSH
14319: LD_INT 2
14321: PUSH
14322: LD_INT 3
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: ST_TO_ADDR
14334: GO 14465
14336: LD_INT 1
14338: DOUBLE
14339: EQUAL
14340: IFTRUE 14344
14342: GO 14406
14344: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14345: LD_ADDR_VAR 0 3
14349: PUSH
14350: LD_INT 11
14352: PUSH
14353: LD_INT 12
14355: PUSH
14356: LD_INT 13
14358: PUSH
14359: LD_INT 14
14361: PUSH
14362: LD_INT 1
14364: PUSH
14365: LD_INT 2
14367: PUSH
14368: LD_INT 3
14370: PUSH
14371: LD_INT 4
14373: PUSH
14374: LD_INT 5
14376: PUSH
14377: LD_INT 21
14379: PUSH
14380: LD_INT 23
14382: PUSH
14383: LD_INT 22
14385: PUSH
14386: LD_INT 24
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: ST_TO_ADDR
14404: GO 14465
14406: LD_INT 3
14408: DOUBLE
14409: EQUAL
14410: IFTRUE 14414
14412: GO 14464
14414: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14415: LD_ADDR_VAR 0 3
14419: PUSH
14420: LD_INT 13
14422: PUSH
14423: LD_INT 14
14425: PUSH
14426: LD_INT 2
14428: PUSH
14429: LD_INT 3
14431: PUSH
14432: LD_INT 4
14434: PUSH
14435: LD_INT 5
14437: PUSH
14438: LD_INT 21
14440: PUSH
14441: LD_INT 22
14443: PUSH
14444: LD_INT 23
14446: PUSH
14447: LD_INT 24
14449: PUSH
14450: EMPTY
14451: LIST
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: ST_TO_ADDR
14462: GO 14465
14464: POP
// result := ( chassis in result ) ;
14465: LD_ADDR_VAR 0 3
14469: PUSH
14470: LD_VAR 0 1
14474: PUSH
14475: LD_VAR 0 3
14479: IN
14480: ST_TO_ADDR
// end ;
14481: LD_VAR 0 3
14485: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14486: LD_INT 0
14488: PPUSH
// if not chassis or not weapon then
14489: LD_VAR 0 1
14493: NOT
14494: PUSH
14495: LD_VAR 0 2
14499: NOT
14500: OR
14501: IFFALSE 14505
// exit ;
14503: GO 15565
// case weapon of us_machine_gun :
14505: LD_VAR 0 2
14509: PUSH
14510: LD_INT 2
14512: DOUBLE
14513: EQUAL
14514: IFTRUE 14518
14516: GO 14548
14518: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14519: LD_ADDR_VAR 0 3
14523: PUSH
14524: LD_INT 1
14526: PUSH
14527: LD_INT 2
14529: PUSH
14530: LD_INT 3
14532: PUSH
14533: LD_INT 4
14535: PUSH
14536: LD_INT 5
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: ST_TO_ADDR
14546: GO 15549
14548: LD_INT 3
14550: DOUBLE
14551: EQUAL
14552: IFTRUE 14556
14554: GO 14586
14556: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14557: LD_ADDR_VAR 0 3
14561: PUSH
14562: LD_INT 1
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: LD_INT 3
14570: PUSH
14571: LD_INT 4
14573: PUSH
14574: LD_INT 5
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: ST_TO_ADDR
14584: GO 15549
14586: LD_INT 11
14588: DOUBLE
14589: EQUAL
14590: IFTRUE 14594
14592: GO 14624
14594: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14595: LD_ADDR_VAR 0 3
14599: PUSH
14600: LD_INT 1
14602: PUSH
14603: LD_INT 2
14605: PUSH
14606: LD_INT 3
14608: PUSH
14609: LD_INT 4
14611: PUSH
14612: LD_INT 5
14614: PUSH
14615: EMPTY
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: ST_TO_ADDR
14622: GO 15549
14624: LD_INT 4
14626: DOUBLE
14627: EQUAL
14628: IFTRUE 14632
14630: GO 14658
14632: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14633: LD_ADDR_VAR 0 3
14637: PUSH
14638: LD_INT 2
14640: PUSH
14641: LD_INT 3
14643: PUSH
14644: LD_INT 4
14646: PUSH
14647: LD_INT 5
14649: PUSH
14650: EMPTY
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: ST_TO_ADDR
14656: GO 15549
14658: LD_INT 5
14660: DOUBLE
14661: EQUAL
14662: IFTRUE 14666
14664: GO 14692
14666: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14667: LD_ADDR_VAR 0 3
14671: PUSH
14672: LD_INT 2
14674: PUSH
14675: LD_INT 3
14677: PUSH
14678: LD_INT 4
14680: PUSH
14681: LD_INT 5
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: LIST
14688: LIST
14689: ST_TO_ADDR
14690: GO 15549
14692: LD_INT 9
14694: DOUBLE
14695: EQUAL
14696: IFTRUE 14700
14698: GO 14726
14700: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14701: LD_ADDR_VAR 0 3
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: LD_INT 3
14711: PUSH
14712: LD_INT 4
14714: PUSH
14715: LD_INT 5
14717: PUSH
14718: EMPTY
14719: LIST
14720: LIST
14721: LIST
14722: LIST
14723: ST_TO_ADDR
14724: GO 15549
14726: LD_INT 7
14728: DOUBLE
14729: EQUAL
14730: IFTRUE 14734
14732: GO 14760
14734: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14735: LD_ADDR_VAR 0 3
14739: PUSH
14740: LD_INT 2
14742: PUSH
14743: LD_INT 3
14745: PUSH
14746: LD_INT 4
14748: PUSH
14749: LD_INT 5
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: ST_TO_ADDR
14758: GO 15549
14760: LD_INT 12
14762: DOUBLE
14763: EQUAL
14764: IFTRUE 14768
14766: GO 14794
14768: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14769: LD_ADDR_VAR 0 3
14773: PUSH
14774: LD_INT 2
14776: PUSH
14777: LD_INT 3
14779: PUSH
14780: LD_INT 4
14782: PUSH
14783: LD_INT 5
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: ST_TO_ADDR
14792: GO 15549
14794: LD_INT 13
14796: DOUBLE
14797: EQUAL
14798: IFTRUE 14802
14800: GO 14828
14802: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14803: LD_ADDR_VAR 0 3
14807: PUSH
14808: LD_INT 2
14810: PUSH
14811: LD_INT 3
14813: PUSH
14814: LD_INT 4
14816: PUSH
14817: LD_INT 5
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: ST_TO_ADDR
14826: GO 15549
14828: LD_INT 14
14830: DOUBLE
14831: EQUAL
14832: IFTRUE 14836
14834: GO 14854
14836: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14837: LD_ADDR_VAR 0 3
14841: PUSH
14842: LD_INT 4
14844: PUSH
14845: LD_INT 5
14847: PUSH
14848: EMPTY
14849: LIST
14850: LIST
14851: ST_TO_ADDR
14852: GO 15549
14854: LD_INT 6
14856: DOUBLE
14857: EQUAL
14858: IFTRUE 14862
14860: GO 14880
14862: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14863: LD_ADDR_VAR 0 3
14867: PUSH
14868: LD_INT 4
14870: PUSH
14871: LD_INT 5
14873: PUSH
14874: EMPTY
14875: LIST
14876: LIST
14877: ST_TO_ADDR
14878: GO 15549
14880: LD_INT 10
14882: DOUBLE
14883: EQUAL
14884: IFTRUE 14888
14886: GO 14906
14888: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14889: LD_ADDR_VAR 0 3
14893: PUSH
14894: LD_INT 4
14896: PUSH
14897: LD_INT 5
14899: PUSH
14900: EMPTY
14901: LIST
14902: LIST
14903: ST_TO_ADDR
14904: GO 15549
14906: LD_INT 22
14908: DOUBLE
14909: EQUAL
14910: IFTRUE 14914
14912: GO 14940
14914: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14915: LD_ADDR_VAR 0 3
14919: PUSH
14920: LD_INT 11
14922: PUSH
14923: LD_INT 12
14925: PUSH
14926: LD_INT 13
14928: PUSH
14929: LD_INT 14
14931: PUSH
14932: EMPTY
14933: LIST
14934: LIST
14935: LIST
14936: LIST
14937: ST_TO_ADDR
14938: GO 15549
14940: LD_INT 23
14942: DOUBLE
14943: EQUAL
14944: IFTRUE 14948
14946: GO 14974
14948: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14949: LD_ADDR_VAR 0 3
14953: PUSH
14954: LD_INT 11
14956: PUSH
14957: LD_INT 12
14959: PUSH
14960: LD_INT 13
14962: PUSH
14963: LD_INT 14
14965: PUSH
14966: EMPTY
14967: LIST
14968: LIST
14969: LIST
14970: LIST
14971: ST_TO_ADDR
14972: GO 15549
14974: LD_INT 24
14976: DOUBLE
14977: EQUAL
14978: IFTRUE 14982
14980: GO 15008
14982: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14983: LD_ADDR_VAR 0 3
14987: PUSH
14988: LD_INT 11
14990: PUSH
14991: LD_INT 12
14993: PUSH
14994: LD_INT 13
14996: PUSH
14997: LD_INT 14
14999: PUSH
15000: EMPTY
15001: LIST
15002: LIST
15003: LIST
15004: LIST
15005: ST_TO_ADDR
15006: GO 15549
15008: LD_INT 30
15010: DOUBLE
15011: EQUAL
15012: IFTRUE 15016
15014: GO 15042
15016: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
15017: LD_ADDR_VAR 0 3
15021: PUSH
15022: LD_INT 11
15024: PUSH
15025: LD_INT 12
15027: PUSH
15028: LD_INT 13
15030: PUSH
15031: LD_INT 14
15033: PUSH
15034: EMPTY
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: ST_TO_ADDR
15040: GO 15549
15042: LD_INT 25
15044: DOUBLE
15045: EQUAL
15046: IFTRUE 15050
15048: GO 15068
15050: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15051: LD_ADDR_VAR 0 3
15055: PUSH
15056: LD_INT 13
15058: PUSH
15059: LD_INT 14
15061: PUSH
15062: EMPTY
15063: LIST
15064: LIST
15065: ST_TO_ADDR
15066: GO 15549
15068: LD_INT 27
15070: DOUBLE
15071: EQUAL
15072: IFTRUE 15076
15074: GO 15094
15076: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15077: LD_ADDR_VAR 0 3
15081: PUSH
15082: LD_INT 13
15084: PUSH
15085: LD_INT 14
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: ST_TO_ADDR
15092: GO 15549
15094: LD_INT 92
15096: DOUBLE
15097: EQUAL
15098: IFTRUE 15102
15100: GO 15128
15102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15103: LD_ADDR_VAR 0 3
15107: PUSH
15108: LD_INT 11
15110: PUSH
15111: LD_INT 12
15113: PUSH
15114: LD_INT 13
15116: PUSH
15117: LD_INT 14
15119: PUSH
15120: EMPTY
15121: LIST
15122: LIST
15123: LIST
15124: LIST
15125: ST_TO_ADDR
15126: GO 15549
15128: LD_INT 28
15130: DOUBLE
15131: EQUAL
15132: IFTRUE 15136
15134: GO 15154
15136: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15137: LD_ADDR_VAR 0 3
15141: PUSH
15142: LD_INT 13
15144: PUSH
15145: LD_INT 14
15147: PUSH
15148: EMPTY
15149: LIST
15150: LIST
15151: ST_TO_ADDR
15152: GO 15549
15154: LD_INT 29
15156: DOUBLE
15157: EQUAL
15158: IFTRUE 15162
15160: GO 15180
15162: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15163: LD_ADDR_VAR 0 3
15167: PUSH
15168: LD_INT 13
15170: PUSH
15171: LD_INT 14
15173: PUSH
15174: EMPTY
15175: LIST
15176: LIST
15177: ST_TO_ADDR
15178: GO 15549
15180: LD_INT 31
15182: DOUBLE
15183: EQUAL
15184: IFTRUE 15188
15186: GO 15206
15188: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15189: LD_ADDR_VAR 0 3
15193: PUSH
15194: LD_INT 13
15196: PUSH
15197: LD_INT 14
15199: PUSH
15200: EMPTY
15201: LIST
15202: LIST
15203: ST_TO_ADDR
15204: GO 15549
15206: LD_INT 26
15208: DOUBLE
15209: EQUAL
15210: IFTRUE 15214
15212: GO 15232
15214: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15215: LD_ADDR_VAR 0 3
15219: PUSH
15220: LD_INT 13
15222: PUSH
15223: LD_INT 14
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: ST_TO_ADDR
15230: GO 15549
15232: LD_INT 42
15234: DOUBLE
15235: EQUAL
15236: IFTRUE 15240
15238: GO 15266
15240: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15241: LD_ADDR_VAR 0 3
15245: PUSH
15246: LD_INT 21
15248: PUSH
15249: LD_INT 22
15251: PUSH
15252: LD_INT 23
15254: PUSH
15255: LD_INT 24
15257: PUSH
15258: EMPTY
15259: LIST
15260: LIST
15261: LIST
15262: LIST
15263: ST_TO_ADDR
15264: GO 15549
15266: LD_INT 43
15268: DOUBLE
15269: EQUAL
15270: IFTRUE 15274
15272: GO 15300
15274: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15275: LD_ADDR_VAR 0 3
15279: PUSH
15280: LD_INT 21
15282: PUSH
15283: LD_INT 22
15285: PUSH
15286: LD_INT 23
15288: PUSH
15289: LD_INT 24
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: LIST
15296: LIST
15297: ST_TO_ADDR
15298: GO 15549
15300: LD_INT 44
15302: DOUBLE
15303: EQUAL
15304: IFTRUE 15308
15306: GO 15334
15308: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15309: LD_ADDR_VAR 0 3
15313: PUSH
15314: LD_INT 21
15316: PUSH
15317: LD_INT 22
15319: PUSH
15320: LD_INT 23
15322: PUSH
15323: LD_INT 24
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: LIST
15330: LIST
15331: ST_TO_ADDR
15332: GO 15549
15334: LD_INT 45
15336: DOUBLE
15337: EQUAL
15338: IFTRUE 15342
15340: GO 15368
15342: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15343: LD_ADDR_VAR 0 3
15347: PUSH
15348: LD_INT 21
15350: PUSH
15351: LD_INT 22
15353: PUSH
15354: LD_INT 23
15356: PUSH
15357: LD_INT 24
15359: PUSH
15360: EMPTY
15361: LIST
15362: LIST
15363: LIST
15364: LIST
15365: ST_TO_ADDR
15366: GO 15549
15368: LD_INT 49
15370: DOUBLE
15371: EQUAL
15372: IFTRUE 15376
15374: GO 15402
15376: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15377: LD_ADDR_VAR 0 3
15381: PUSH
15382: LD_INT 21
15384: PUSH
15385: LD_INT 22
15387: PUSH
15388: LD_INT 23
15390: PUSH
15391: LD_INT 24
15393: PUSH
15394: EMPTY
15395: LIST
15396: LIST
15397: LIST
15398: LIST
15399: ST_TO_ADDR
15400: GO 15549
15402: LD_INT 51
15404: DOUBLE
15405: EQUAL
15406: IFTRUE 15410
15408: GO 15436
15410: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15411: LD_ADDR_VAR 0 3
15415: PUSH
15416: LD_INT 21
15418: PUSH
15419: LD_INT 22
15421: PUSH
15422: LD_INT 23
15424: PUSH
15425: LD_INT 24
15427: PUSH
15428: EMPTY
15429: LIST
15430: LIST
15431: LIST
15432: LIST
15433: ST_TO_ADDR
15434: GO 15549
15436: LD_INT 52
15438: DOUBLE
15439: EQUAL
15440: IFTRUE 15444
15442: GO 15470
15444: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15445: LD_ADDR_VAR 0 3
15449: PUSH
15450: LD_INT 21
15452: PUSH
15453: LD_INT 22
15455: PUSH
15456: LD_INT 23
15458: PUSH
15459: LD_INT 24
15461: PUSH
15462: EMPTY
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: ST_TO_ADDR
15468: GO 15549
15470: LD_INT 53
15472: DOUBLE
15473: EQUAL
15474: IFTRUE 15478
15476: GO 15496
15478: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15479: LD_ADDR_VAR 0 3
15483: PUSH
15484: LD_INT 23
15486: PUSH
15487: LD_INT 24
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: ST_TO_ADDR
15494: GO 15549
15496: LD_INT 46
15498: DOUBLE
15499: EQUAL
15500: IFTRUE 15504
15502: GO 15522
15504: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15505: LD_ADDR_VAR 0 3
15509: PUSH
15510: LD_INT 23
15512: PUSH
15513: LD_INT 24
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: ST_TO_ADDR
15520: GO 15549
15522: LD_INT 47
15524: DOUBLE
15525: EQUAL
15526: IFTRUE 15530
15528: GO 15548
15530: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15531: LD_ADDR_VAR 0 3
15535: PUSH
15536: LD_INT 23
15538: PUSH
15539: LD_INT 24
15541: PUSH
15542: EMPTY
15543: LIST
15544: LIST
15545: ST_TO_ADDR
15546: GO 15549
15548: POP
// result := ( chassis in result ) ;
15549: LD_ADDR_VAR 0 3
15553: PUSH
15554: LD_VAR 0 1
15558: PUSH
15559: LD_VAR 0 3
15563: IN
15564: ST_TO_ADDR
// end ;
15565: LD_VAR 0 3
15569: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15570: LD_INT 0
15572: PPUSH
15573: PPUSH
15574: PPUSH
15575: PPUSH
15576: PPUSH
15577: PPUSH
15578: PPUSH
// result := array ;
15579: LD_ADDR_VAR 0 5
15583: PUSH
15584: LD_VAR 0 1
15588: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15589: LD_VAR 0 1
15593: NOT
15594: PUSH
15595: LD_VAR 0 2
15599: NOT
15600: OR
15601: PUSH
15602: LD_VAR 0 3
15606: NOT
15607: OR
15608: PUSH
15609: LD_VAR 0 2
15613: PUSH
15614: LD_VAR 0 1
15618: GREATER
15619: OR
15620: PUSH
15621: LD_VAR 0 3
15625: PUSH
15626: LD_VAR 0 1
15630: GREATER
15631: OR
15632: IFFALSE 15636
// exit ;
15634: GO 15932
// if direction then
15636: LD_VAR 0 4
15640: IFFALSE 15704
// begin d := 1 ;
15642: LD_ADDR_VAR 0 9
15646: PUSH
15647: LD_INT 1
15649: ST_TO_ADDR
// if i_from > i_to then
15650: LD_VAR 0 2
15654: PUSH
15655: LD_VAR 0 3
15659: GREATER
15660: IFFALSE 15686
// length := ( array - i_from ) + i_to else
15662: LD_ADDR_VAR 0 11
15666: PUSH
15667: LD_VAR 0 1
15671: PUSH
15672: LD_VAR 0 2
15676: MINUS
15677: PUSH
15678: LD_VAR 0 3
15682: PLUS
15683: ST_TO_ADDR
15684: GO 15702
// length := i_to - i_from ;
15686: LD_ADDR_VAR 0 11
15690: PUSH
15691: LD_VAR 0 3
15695: PUSH
15696: LD_VAR 0 2
15700: MINUS
15701: ST_TO_ADDR
// end else
15702: GO 15765
// begin d := - 1 ;
15704: LD_ADDR_VAR 0 9
15708: PUSH
15709: LD_INT 1
15711: NEG
15712: ST_TO_ADDR
// if i_from > i_to then
15713: LD_VAR 0 2
15717: PUSH
15718: LD_VAR 0 3
15722: GREATER
15723: IFFALSE 15743
// length := i_from - i_to else
15725: LD_ADDR_VAR 0 11
15729: PUSH
15730: LD_VAR 0 2
15734: PUSH
15735: LD_VAR 0 3
15739: MINUS
15740: ST_TO_ADDR
15741: GO 15765
// length := ( array - i_to ) + i_from ;
15743: LD_ADDR_VAR 0 11
15747: PUSH
15748: LD_VAR 0 1
15752: PUSH
15753: LD_VAR 0 3
15757: MINUS
15758: PUSH
15759: LD_VAR 0 2
15763: PLUS
15764: ST_TO_ADDR
// end ; if not length then
15765: LD_VAR 0 11
15769: NOT
15770: IFFALSE 15774
// exit ;
15772: GO 15932
// tmp := array ;
15774: LD_ADDR_VAR 0 10
15778: PUSH
15779: LD_VAR 0 1
15783: ST_TO_ADDR
// for i = 1 to length do
15784: LD_ADDR_VAR 0 6
15788: PUSH
15789: DOUBLE
15790: LD_INT 1
15792: DEC
15793: ST_TO_ADDR
15794: LD_VAR 0 11
15798: PUSH
15799: FOR_TO
15800: IFFALSE 15920
// begin for j = 1 to array do
15802: LD_ADDR_VAR 0 7
15806: PUSH
15807: DOUBLE
15808: LD_INT 1
15810: DEC
15811: ST_TO_ADDR
15812: LD_VAR 0 1
15816: PUSH
15817: FOR_TO
15818: IFFALSE 15906
// begin k := j + d ;
15820: LD_ADDR_VAR 0 8
15824: PUSH
15825: LD_VAR 0 7
15829: PUSH
15830: LD_VAR 0 9
15834: PLUS
15835: ST_TO_ADDR
// if k > array then
15836: LD_VAR 0 8
15840: PUSH
15841: LD_VAR 0 1
15845: GREATER
15846: IFFALSE 15856
// k := 1 ;
15848: LD_ADDR_VAR 0 8
15852: PUSH
15853: LD_INT 1
15855: ST_TO_ADDR
// if not k then
15856: LD_VAR 0 8
15860: NOT
15861: IFFALSE 15873
// k := array ;
15863: LD_ADDR_VAR 0 8
15867: PUSH
15868: LD_VAR 0 1
15872: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15873: LD_ADDR_VAR 0 10
15877: PUSH
15878: LD_VAR 0 10
15882: PPUSH
15883: LD_VAR 0 8
15887: PPUSH
15888: LD_VAR 0 1
15892: PUSH
15893: LD_VAR 0 7
15897: ARRAY
15898: PPUSH
15899: CALL_OW 1
15903: ST_TO_ADDR
// end ;
15904: GO 15817
15906: POP
15907: POP
// array := tmp ;
15908: LD_ADDR_VAR 0 1
15912: PUSH
15913: LD_VAR 0 10
15917: ST_TO_ADDR
// end ;
15918: GO 15799
15920: POP
15921: POP
// result := array ;
15922: LD_ADDR_VAR 0 5
15926: PUSH
15927: LD_VAR 0 1
15931: ST_TO_ADDR
// end ;
15932: LD_VAR 0 5
15936: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15937: LD_INT 0
15939: PPUSH
15940: PPUSH
// result := 0 ;
15941: LD_ADDR_VAR 0 3
15945: PUSH
15946: LD_INT 0
15948: ST_TO_ADDR
// if not array or not value in array then
15949: LD_VAR 0 1
15953: NOT
15954: PUSH
15955: LD_VAR 0 2
15959: PUSH
15960: LD_VAR 0 1
15964: IN
15965: NOT
15966: OR
15967: IFFALSE 15971
// exit ;
15969: GO 16025
// for i = 1 to array do
15971: LD_ADDR_VAR 0 4
15975: PUSH
15976: DOUBLE
15977: LD_INT 1
15979: DEC
15980: ST_TO_ADDR
15981: LD_VAR 0 1
15985: PUSH
15986: FOR_TO
15987: IFFALSE 16023
// if value = array [ i ] then
15989: LD_VAR 0 2
15993: PUSH
15994: LD_VAR 0 1
15998: PUSH
15999: LD_VAR 0 4
16003: ARRAY
16004: EQUAL
16005: IFFALSE 16021
// begin result := i ;
16007: LD_ADDR_VAR 0 3
16011: PUSH
16012: LD_VAR 0 4
16016: ST_TO_ADDR
// exit ;
16017: POP
16018: POP
16019: GO 16025
// end ;
16021: GO 15986
16023: POP
16024: POP
// end ;
16025: LD_VAR 0 3
16029: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
16030: LD_INT 0
16032: PPUSH
// vc_chassis := chassis ;
16033: LD_ADDR_OWVAR 37
16037: PUSH
16038: LD_VAR 0 1
16042: ST_TO_ADDR
// vc_engine := engine ;
16043: LD_ADDR_OWVAR 39
16047: PUSH
16048: LD_VAR 0 2
16052: ST_TO_ADDR
// vc_control := control ;
16053: LD_ADDR_OWVAR 38
16057: PUSH
16058: LD_VAR 0 3
16062: ST_TO_ADDR
// vc_weapon := weapon ;
16063: LD_ADDR_OWVAR 40
16067: PUSH
16068: LD_VAR 0 4
16072: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16073: LD_ADDR_OWVAR 41
16077: PUSH
16078: LD_VAR 0 5
16082: ST_TO_ADDR
// end ;
16083: LD_VAR 0 6
16087: RET
// export function WantPlant ( unit ) ; var task ; begin
16088: LD_INT 0
16090: PPUSH
16091: PPUSH
// result := false ;
16092: LD_ADDR_VAR 0 2
16096: PUSH
16097: LD_INT 0
16099: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16100: LD_ADDR_VAR 0 3
16104: PUSH
16105: LD_VAR 0 1
16109: PPUSH
16110: CALL_OW 437
16114: ST_TO_ADDR
// if task then
16115: LD_VAR 0 3
16119: IFFALSE 16147
// if task [ 1 ] [ 1 ] = p then
16121: LD_VAR 0 3
16125: PUSH
16126: LD_INT 1
16128: ARRAY
16129: PUSH
16130: LD_INT 1
16132: ARRAY
16133: PUSH
16134: LD_STRING p
16136: EQUAL
16137: IFFALSE 16147
// result := true ;
16139: LD_ADDR_VAR 0 2
16143: PUSH
16144: LD_INT 1
16146: ST_TO_ADDR
// end ;
16147: LD_VAR 0 2
16151: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16152: LD_INT 0
16154: PPUSH
16155: PPUSH
16156: PPUSH
16157: PPUSH
// if pos < 1 then
16158: LD_VAR 0 2
16162: PUSH
16163: LD_INT 1
16165: LESS
16166: IFFALSE 16170
// exit ;
16168: GO 16473
// if pos = 1 then
16170: LD_VAR 0 2
16174: PUSH
16175: LD_INT 1
16177: EQUAL
16178: IFFALSE 16211
// result := Replace ( arr , pos [ 1 ] , value ) else
16180: LD_ADDR_VAR 0 4
16184: PUSH
16185: LD_VAR 0 1
16189: PPUSH
16190: LD_VAR 0 2
16194: PUSH
16195: LD_INT 1
16197: ARRAY
16198: PPUSH
16199: LD_VAR 0 3
16203: PPUSH
16204: CALL_OW 1
16208: ST_TO_ADDR
16209: GO 16473
// begin tmp := arr ;
16211: LD_ADDR_VAR 0 6
16215: PUSH
16216: LD_VAR 0 1
16220: ST_TO_ADDR
// s_arr := [ tmp ] ;
16221: LD_ADDR_VAR 0 7
16225: PUSH
16226: LD_VAR 0 6
16230: PUSH
16231: EMPTY
16232: LIST
16233: ST_TO_ADDR
// for i = 1 to pos - 1 do
16234: LD_ADDR_VAR 0 5
16238: PUSH
16239: DOUBLE
16240: LD_INT 1
16242: DEC
16243: ST_TO_ADDR
16244: LD_VAR 0 2
16248: PUSH
16249: LD_INT 1
16251: MINUS
16252: PUSH
16253: FOR_TO
16254: IFFALSE 16299
// begin tmp := tmp [ pos [ i ] ] ;
16256: LD_ADDR_VAR 0 6
16260: PUSH
16261: LD_VAR 0 6
16265: PUSH
16266: LD_VAR 0 2
16270: PUSH
16271: LD_VAR 0 5
16275: ARRAY
16276: ARRAY
16277: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16278: LD_ADDR_VAR 0 7
16282: PUSH
16283: LD_VAR 0 7
16287: PUSH
16288: LD_VAR 0 6
16292: PUSH
16293: EMPTY
16294: LIST
16295: ADD
16296: ST_TO_ADDR
// end ;
16297: GO 16253
16299: POP
16300: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16301: LD_ADDR_VAR 0 6
16305: PUSH
16306: LD_VAR 0 6
16310: PPUSH
16311: LD_VAR 0 2
16315: PUSH
16316: LD_VAR 0 2
16320: ARRAY
16321: PPUSH
16322: LD_VAR 0 3
16326: PPUSH
16327: CALL_OW 1
16331: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16332: LD_ADDR_VAR 0 7
16336: PUSH
16337: LD_VAR 0 7
16341: PPUSH
16342: LD_VAR 0 7
16346: PPUSH
16347: LD_VAR 0 6
16351: PPUSH
16352: CALL_OW 1
16356: ST_TO_ADDR
// for i = s_arr downto 2 do
16357: LD_ADDR_VAR 0 5
16361: PUSH
16362: DOUBLE
16363: LD_VAR 0 7
16367: INC
16368: ST_TO_ADDR
16369: LD_INT 2
16371: PUSH
16372: FOR_DOWNTO
16373: IFFALSE 16457
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16375: LD_ADDR_VAR 0 6
16379: PUSH
16380: LD_VAR 0 7
16384: PUSH
16385: LD_VAR 0 5
16389: PUSH
16390: LD_INT 1
16392: MINUS
16393: ARRAY
16394: PPUSH
16395: LD_VAR 0 2
16399: PUSH
16400: LD_VAR 0 5
16404: PUSH
16405: LD_INT 1
16407: MINUS
16408: ARRAY
16409: PPUSH
16410: LD_VAR 0 7
16414: PUSH
16415: LD_VAR 0 5
16419: ARRAY
16420: PPUSH
16421: CALL_OW 1
16425: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16426: LD_ADDR_VAR 0 7
16430: PUSH
16431: LD_VAR 0 7
16435: PPUSH
16436: LD_VAR 0 5
16440: PUSH
16441: LD_INT 1
16443: MINUS
16444: PPUSH
16445: LD_VAR 0 6
16449: PPUSH
16450: CALL_OW 1
16454: ST_TO_ADDR
// end ;
16455: GO 16372
16457: POP
16458: POP
// result := s_arr [ 1 ] ;
16459: LD_ADDR_VAR 0 4
16463: PUSH
16464: LD_VAR 0 7
16468: PUSH
16469: LD_INT 1
16471: ARRAY
16472: ST_TO_ADDR
// end ; end ;
16473: LD_VAR 0 4
16477: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16478: LD_INT 0
16480: PPUSH
16481: PPUSH
// if not list then
16482: LD_VAR 0 1
16486: NOT
16487: IFFALSE 16491
// exit ;
16489: GO 16582
// i := list [ pos1 ] ;
16491: LD_ADDR_VAR 0 5
16495: PUSH
16496: LD_VAR 0 1
16500: PUSH
16501: LD_VAR 0 2
16505: ARRAY
16506: ST_TO_ADDR
// if not i then
16507: LD_VAR 0 5
16511: NOT
16512: IFFALSE 16516
// exit ;
16514: GO 16582
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16516: LD_ADDR_VAR 0 1
16520: PUSH
16521: LD_VAR 0 1
16525: PPUSH
16526: LD_VAR 0 2
16530: PPUSH
16531: LD_VAR 0 1
16535: PUSH
16536: LD_VAR 0 3
16540: ARRAY
16541: PPUSH
16542: CALL_OW 1
16546: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16547: LD_ADDR_VAR 0 1
16551: PUSH
16552: LD_VAR 0 1
16556: PPUSH
16557: LD_VAR 0 3
16561: PPUSH
16562: LD_VAR 0 5
16566: PPUSH
16567: CALL_OW 1
16571: ST_TO_ADDR
// result := list ;
16572: LD_ADDR_VAR 0 4
16576: PUSH
16577: LD_VAR 0 1
16581: ST_TO_ADDR
// end ;
16582: LD_VAR 0 4
16586: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16587: LD_INT 0
16589: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16590: LD_ADDR_VAR 0 5
16594: PUSH
16595: LD_VAR 0 1
16599: PPUSH
16600: CALL_OW 250
16604: PPUSH
16605: LD_VAR 0 1
16609: PPUSH
16610: CALL_OW 251
16614: PPUSH
16615: LD_VAR 0 2
16619: PPUSH
16620: LD_VAR 0 3
16624: PPUSH
16625: LD_VAR 0 4
16629: PPUSH
16630: CALL 16640 0 5
16634: ST_TO_ADDR
// end ;
16635: LD_VAR 0 5
16639: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16640: LD_INT 0
16642: PPUSH
16643: PPUSH
16644: PPUSH
16645: PPUSH
// if not list then
16646: LD_VAR 0 3
16650: NOT
16651: IFFALSE 16655
// exit ;
16653: GO 17043
// result := [ ] ;
16655: LD_ADDR_VAR 0 6
16659: PUSH
16660: EMPTY
16661: ST_TO_ADDR
// for i in list do
16662: LD_ADDR_VAR 0 7
16666: PUSH
16667: LD_VAR 0 3
16671: PUSH
16672: FOR_IN
16673: IFFALSE 16875
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16675: LD_ADDR_VAR 0 9
16679: PUSH
16680: LD_VAR 0 7
16684: PPUSH
16685: LD_VAR 0 1
16689: PPUSH
16690: LD_VAR 0 2
16694: PPUSH
16695: CALL_OW 297
16699: ST_TO_ADDR
// if not result then
16700: LD_VAR 0 6
16704: NOT
16705: IFFALSE 16731
// result := [ [ i , tmp ] ] else
16707: LD_ADDR_VAR 0 6
16711: PUSH
16712: LD_VAR 0 7
16716: PUSH
16717: LD_VAR 0 9
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PUSH
16726: EMPTY
16727: LIST
16728: ST_TO_ADDR
16729: GO 16873
// begin if result [ result ] [ 2 ] < tmp then
16731: LD_VAR 0 6
16735: PUSH
16736: LD_VAR 0 6
16740: ARRAY
16741: PUSH
16742: LD_INT 2
16744: ARRAY
16745: PUSH
16746: LD_VAR 0 9
16750: LESS
16751: IFFALSE 16793
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16753: LD_ADDR_VAR 0 6
16757: PUSH
16758: LD_VAR 0 6
16762: PPUSH
16763: LD_VAR 0 6
16767: PUSH
16768: LD_INT 1
16770: PLUS
16771: PPUSH
16772: LD_VAR 0 7
16776: PUSH
16777: LD_VAR 0 9
16781: PUSH
16782: EMPTY
16783: LIST
16784: LIST
16785: PPUSH
16786: CALL_OW 2
16790: ST_TO_ADDR
16791: GO 16873
// for j = 1 to result do
16793: LD_ADDR_VAR 0 8
16797: PUSH
16798: DOUBLE
16799: LD_INT 1
16801: DEC
16802: ST_TO_ADDR
16803: LD_VAR 0 6
16807: PUSH
16808: FOR_TO
16809: IFFALSE 16871
// begin if tmp < result [ j ] [ 2 ] then
16811: LD_VAR 0 9
16815: PUSH
16816: LD_VAR 0 6
16820: PUSH
16821: LD_VAR 0 8
16825: ARRAY
16826: PUSH
16827: LD_INT 2
16829: ARRAY
16830: LESS
16831: IFFALSE 16869
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16833: LD_ADDR_VAR 0 6
16837: PUSH
16838: LD_VAR 0 6
16842: PPUSH
16843: LD_VAR 0 8
16847: PPUSH
16848: LD_VAR 0 7
16852: PUSH
16853: LD_VAR 0 9
16857: PUSH
16858: EMPTY
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 2
16866: ST_TO_ADDR
// break ;
16867: GO 16871
// end ; end ;
16869: GO 16808
16871: POP
16872: POP
// end ; end ;
16873: GO 16672
16875: POP
16876: POP
// if result and not asc then
16877: LD_VAR 0 6
16881: PUSH
16882: LD_VAR 0 4
16886: NOT
16887: AND
16888: IFFALSE 16963
// begin tmp := result ;
16890: LD_ADDR_VAR 0 9
16894: PUSH
16895: LD_VAR 0 6
16899: ST_TO_ADDR
// for i = tmp downto 1 do
16900: LD_ADDR_VAR 0 7
16904: PUSH
16905: DOUBLE
16906: LD_VAR 0 9
16910: INC
16911: ST_TO_ADDR
16912: LD_INT 1
16914: PUSH
16915: FOR_DOWNTO
16916: IFFALSE 16961
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16918: LD_ADDR_VAR 0 6
16922: PUSH
16923: LD_VAR 0 6
16927: PPUSH
16928: LD_VAR 0 9
16932: PUSH
16933: LD_VAR 0 7
16937: MINUS
16938: PUSH
16939: LD_INT 1
16941: PLUS
16942: PPUSH
16943: LD_VAR 0 9
16947: PUSH
16948: LD_VAR 0 7
16952: ARRAY
16953: PPUSH
16954: CALL_OW 1
16958: ST_TO_ADDR
16959: GO 16915
16961: POP
16962: POP
// end ; tmp := [ ] ;
16963: LD_ADDR_VAR 0 9
16967: PUSH
16968: EMPTY
16969: ST_TO_ADDR
// if mode then
16970: LD_VAR 0 5
16974: IFFALSE 17043
// begin for i = 1 to result do
16976: LD_ADDR_VAR 0 7
16980: PUSH
16981: DOUBLE
16982: LD_INT 1
16984: DEC
16985: ST_TO_ADDR
16986: LD_VAR 0 6
16990: PUSH
16991: FOR_TO
16992: IFFALSE 17031
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16994: LD_ADDR_VAR 0 9
16998: PUSH
16999: LD_VAR 0 9
17003: PPUSH
17004: LD_VAR 0 7
17008: PPUSH
17009: LD_VAR 0 6
17013: PUSH
17014: LD_VAR 0 7
17018: ARRAY
17019: PUSH
17020: LD_INT 1
17022: ARRAY
17023: PPUSH
17024: CALL_OW 1
17028: ST_TO_ADDR
17029: GO 16991
17031: POP
17032: POP
// result := tmp ;
17033: LD_ADDR_VAR 0 6
17037: PUSH
17038: LD_VAR 0 9
17042: ST_TO_ADDR
// end ; end ;
17043: LD_VAR 0 6
17047: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17048: LD_INT 0
17050: PPUSH
17051: PPUSH
17052: PPUSH
17053: PPUSH
17054: PPUSH
17055: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17056: LD_ADDR_VAR 0 5
17060: PUSH
17061: LD_INT 0
17063: PUSH
17064: LD_INT 0
17066: PUSH
17067: LD_INT 0
17069: PUSH
17070: EMPTY
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: LIST
17076: LIST
17077: ST_TO_ADDR
// if not x or not y then
17078: LD_VAR 0 2
17082: NOT
17083: PUSH
17084: LD_VAR 0 3
17088: NOT
17089: OR
17090: IFFALSE 17094
// exit ;
17092: GO 18744
// if not range then
17094: LD_VAR 0 4
17098: NOT
17099: IFFALSE 17109
// range := 10 ;
17101: LD_ADDR_VAR 0 4
17105: PUSH
17106: LD_INT 10
17108: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17109: LD_ADDR_VAR 0 8
17113: PUSH
17114: LD_INT 81
17116: PUSH
17117: LD_VAR 0 1
17121: PUSH
17122: EMPTY
17123: LIST
17124: LIST
17125: PUSH
17126: LD_INT 92
17128: PUSH
17129: LD_VAR 0 2
17133: PUSH
17134: LD_VAR 0 3
17138: PUSH
17139: LD_VAR 0 4
17143: PUSH
17144: EMPTY
17145: LIST
17146: LIST
17147: LIST
17148: LIST
17149: PUSH
17150: LD_INT 3
17152: PUSH
17153: LD_INT 21
17155: PUSH
17156: LD_INT 3
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: PUSH
17163: EMPTY
17164: LIST
17165: LIST
17166: PUSH
17167: EMPTY
17168: LIST
17169: LIST
17170: LIST
17171: PPUSH
17172: CALL_OW 69
17176: ST_TO_ADDR
// if not tmp then
17177: LD_VAR 0 8
17181: NOT
17182: IFFALSE 17186
// exit ;
17184: GO 18744
// for i in tmp do
17186: LD_ADDR_VAR 0 6
17190: PUSH
17191: LD_VAR 0 8
17195: PUSH
17196: FOR_IN
17197: IFFALSE 18719
// begin points := [ 0 , 0 , 0 ] ;
17199: LD_ADDR_VAR 0 9
17203: PUSH
17204: LD_INT 0
17206: PUSH
17207: LD_INT 0
17209: PUSH
17210: LD_INT 0
17212: PUSH
17213: EMPTY
17214: LIST
17215: LIST
17216: LIST
17217: ST_TO_ADDR
// bpoints := 1 ;
17218: LD_ADDR_VAR 0 10
17222: PUSH
17223: LD_INT 1
17225: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17226: LD_VAR 0 6
17230: PPUSH
17231: CALL_OW 247
17235: PUSH
17236: LD_INT 1
17238: DOUBLE
17239: EQUAL
17240: IFTRUE 17244
17242: GO 17822
17244: POP
// begin if GetClass ( i ) = 1 then
17245: LD_VAR 0 6
17249: PPUSH
17250: CALL_OW 257
17254: PUSH
17255: LD_INT 1
17257: EQUAL
17258: IFFALSE 17279
// points := [ 10 , 5 , 3 ] ;
17260: LD_ADDR_VAR 0 9
17264: PUSH
17265: LD_INT 10
17267: PUSH
17268: LD_INT 5
17270: PUSH
17271: LD_INT 3
17273: PUSH
17274: EMPTY
17275: LIST
17276: LIST
17277: LIST
17278: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17279: LD_VAR 0 6
17283: PPUSH
17284: CALL_OW 257
17288: PUSH
17289: LD_INT 2
17291: PUSH
17292: LD_INT 3
17294: PUSH
17295: LD_INT 4
17297: PUSH
17298: EMPTY
17299: LIST
17300: LIST
17301: LIST
17302: IN
17303: IFFALSE 17324
// points := [ 3 , 2 , 1 ] ;
17305: LD_ADDR_VAR 0 9
17309: PUSH
17310: LD_INT 3
17312: PUSH
17313: LD_INT 2
17315: PUSH
17316: LD_INT 1
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: LIST
17323: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17324: LD_VAR 0 6
17328: PPUSH
17329: CALL_OW 257
17333: PUSH
17334: LD_INT 5
17336: EQUAL
17337: IFFALSE 17358
// points := [ 130 , 5 , 2 ] ;
17339: LD_ADDR_VAR 0 9
17343: PUSH
17344: LD_INT 130
17346: PUSH
17347: LD_INT 5
17349: PUSH
17350: LD_INT 2
17352: PUSH
17353: EMPTY
17354: LIST
17355: LIST
17356: LIST
17357: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17358: LD_VAR 0 6
17362: PPUSH
17363: CALL_OW 257
17367: PUSH
17368: LD_INT 8
17370: EQUAL
17371: IFFALSE 17392
// points := [ 35 , 35 , 30 ] ;
17373: LD_ADDR_VAR 0 9
17377: PUSH
17378: LD_INT 35
17380: PUSH
17381: LD_INT 35
17383: PUSH
17384: LD_INT 30
17386: PUSH
17387: EMPTY
17388: LIST
17389: LIST
17390: LIST
17391: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17392: LD_VAR 0 6
17396: PPUSH
17397: CALL_OW 257
17401: PUSH
17402: LD_INT 9
17404: EQUAL
17405: IFFALSE 17426
// points := [ 20 , 55 , 40 ] ;
17407: LD_ADDR_VAR 0 9
17411: PUSH
17412: LD_INT 20
17414: PUSH
17415: LD_INT 55
17417: PUSH
17418: LD_INT 40
17420: PUSH
17421: EMPTY
17422: LIST
17423: LIST
17424: LIST
17425: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17426: LD_VAR 0 6
17430: PPUSH
17431: CALL_OW 257
17435: PUSH
17436: LD_INT 12
17438: PUSH
17439: LD_INT 16
17441: PUSH
17442: EMPTY
17443: LIST
17444: LIST
17445: IN
17446: IFFALSE 17467
// points := [ 5 , 3 , 2 ] ;
17448: LD_ADDR_VAR 0 9
17452: PUSH
17453: LD_INT 5
17455: PUSH
17456: LD_INT 3
17458: PUSH
17459: LD_INT 2
17461: PUSH
17462: EMPTY
17463: LIST
17464: LIST
17465: LIST
17466: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17467: LD_VAR 0 6
17471: PPUSH
17472: CALL_OW 257
17476: PUSH
17477: LD_INT 17
17479: EQUAL
17480: IFFALSE 17501
// points := [ 100 , 50 , 75 ] ;
17482: LD_ADDR_VAR 0 9
17486: PUSH
17487: LD_INT 100
17489: PUSH
17490: LD_INT 50
17492: PUSH
17493: LD_INT 75
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: LIST
17500: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17501: LD_VAR 0 6
17505: PPUSH
17506: CALL_OW 257
17510: PUSH
17511: LD_INT 15
17513: EQUAL
17514: IFFALSE 17535
// points := [ 10 , 5 , 3 ] ;
17516: LD_ADDR_VAR 0 9
17520: PUSH
17521: LD_INT 10
17523: PUSH
17524: LD_INT 5
17526: PUSH
17527: LD_INT 3
17529: PUSH
17530: EMPTY
17531: LIST
17532: LIST
17533: LIST
17534: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17535: LD_VAR 0 6
17539: PPUSH
17540: CALL_OW 257
17544: PUSH
17545: LD_INT 14
17547: EQUAL
17548: IFFALSE 17569
// points := [ 10 , 0 , 0 ] ;
17550: LD_ADDR_VAR 0 9
17554: PUSH
17555: LD_INT 10
17557: PUSH
17558: LD_INT 0
17560: PUSH
17561: LD_INT 0
17563: PUSH
17564: EMPTY
17565: LIST
17566: LIST
17567: LIST
17568: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17569: LD_VAR 0 6
17573: PPUSH
17574: CALL_OW 257
17578: PUSH
17579: LD_INT 11
17581: EQUAL
17582: IFFALSE 17603
// points := [ 30 , 10 , 5 ] ;
17584: LD_ADDR_VAR 0 9
17588: PUSH
17589: LD_INT 30
17591: PUSH
17592: LD_INT 10
17594: PUSH
17595: LD_INT 5
17597: PUSH
17598: EMPTY
17599: LIST
17600: LIST
17601: LIST
17602: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17603: LD_VAR 0 1
17607: PPUSH
17608: LD_INT 5
17610: PPUSH
17611: CALL_OW 321
17615: PUSH
17616: LD_INT 2
17618: EQUAL
17619: IFFALSE 17636
// bpoints := bpoints * 1.8 ;
17621: LD_ADDR_VAR 0 10
17625: PUSH
17626: LD_VAR 0 10
17630: PUSH
17631: LD_REAL  1.80000000000000E+0000
17634: MUL
17635: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17636: LD_VAR 0 6
17640: PPUSH
17641: CALL_OW 257
17645: PUSH
17646: LD_INT 1
17648: PUSH
17649: LD_INT 2
17651: PUSH
17652: LD_INT 3
17654: PUSH
17655: LD_INT 4
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: LIST
17662: LIST
17663: IN
17664: PUSH
17665: LD_VAR 0 1
17669: PPUSH
17670: LD_INT 51
17672: PPUSH
17673: CALL_OW 321
17677: PUSH
17678: LD_INT 2
17680: EQUAL
17681: AND
17682: IFFALSE 17699
// bpoints := bpoints * 1.2 ;
17684: LD_ADDR_VAR 0 10
17688: PUSH
17689: LD_VAR 0 10
17693: PUSH
17694: LD_REAL  1.20000000000000E+0000
17697: MUL
17698: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17699: LD_VAR 0 6
17703: PPUSH
17704: CALL_OW 257
17708: PUSH
17709: LD_INT 5
17711: PUSH
17712: LD_INT 7
17714: PUSH
17715: LD_INT 9
17717: PUSH
17718: EMPTY
17719: LIST
17720: LIST
17721: LIST
17722: IN
17723: PUSH
17724: LD_VAR 0 1
17728: PPUSH
17729: LD_INT 52
17731: PPUSH
17732: CALL_OW 321
17736: PUSH
17737: LD_INT 2
17739: EQUAL
17740: AND
17741: IFFALSE 17758
// bpoints := bpoints * 1.5 ;
17743: LD_ADDR_VAR 0 10
17747: PUSH
17748: LD_VAR 0 10
17752: PUSH
17753: LD_REAL  1.50000000000000E+0000
17756: MUL
17757: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17758: LD_VAR 0 1
17762: PPUSH
17763: LD_INT 66
17765: PPUSH
17766: CALL_OW 321
17770: PUSH
17771: LD_INT 2
17773: EQUAL
17774: IFFALSE 17791
// bpoints := bpoints * 1.1 ;
17776: LD_ADDR_VAR 0 10
17780: PUSH
17781: LD_VAR 0 10
17785: PUSH
17786: LD_REAL  1.10000000000000E+0000
17789: MUL
17790: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17791: LD_ADDR_VAR 0 10
17795: PUSH
17796: LD_VAR 0 10
17800: PUSH
17801: LD_VAR 0 6
17805: PPUSH
17806: LD_INT 1
17808: PPUSH
17809: CALL_OW 259
17813: PUSH
17814: LD_REAL  1.15000000000000E+0000
17817: MUL
17818: MUL
17819: ST_TO_ADDR
// end ; unit_vehicle :
17820: GO 18648
17822: LD_INT 2
17824: DOUBLE
17825: EQUAL
17826: IFTRUE 17830
17828: GO 18636
17830: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17831: LD_VAR 0 6
17835: PPUSH
17836: CALL_OW 264
17840: PUSH
17841: LD_INT 2
17843: PUSH
17844: LD_INT 42
17846: PUSH
17847: LD_INT 24
17849: PUSH
17850: EMPTY
17851: LIST
17852: LIST
17853: LIST
17854: IN
17855: IFFALSE 17876
// points := [ 25 , 5 , 3 ] ;
17857: LD_ADDR_VAR 0 9
17861: PUSH
17862: LD_INT 25
17864: PUSH
17865: LD_INT 5
17867: PUSH
17868: LD_INT 3
17870: PUSH
17871: EMPTY
17872: LIST
17873: LIST
17874: LIST
17875: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17876: LD_VAR 0 6
17880: PPUSH
17881: CALL_OW 264
17885: PUSH
17886: LD_INT 4
17888: PUSH
17889: LD_INT 43
17891: PUSH
17892: LD_INT 25
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: LIST
17899: IN
17900: IFFALSE 17921
// points := [ 40 , 15 , 5 ] ;
17902: LD_ADDR_VAR 0 9
17906: PUSH
17907: LD_INT 40
17909: PUSH
17910: LD_INT 15
17912: PUSH
17913: LD_INT 5
17915: PUSH
17916: EMPTY
17917: LIST
17918: LIST
17919: LIST
17920: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17921: LD_VAR 0 6
17925: PPUSH
17926: CALL_OW 264
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: LD_INT 23
17936: PUSH
17937: EMPTY
17938: LIST
17939: LIST
17940: IN
17941: IFFALSE 17962
// points := [ 7 , 25 , 8 ] ;
17943: LD_ADDR_VAR 0 9
17947: PUSH
17948: LD_INT 7
17950: PUSH
17951: LD_INT 25
17953: PUSH
17954: LD_INT 8
17956: PUSH
17957: EMPTY
17958: LIST
17959: LIST
17960: LIST
17961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17962: LD_VAR 0 6
17966: PPUSH
17967: CALL_OW 264
17971: PUSH
17972: LD_INT 5
17974: PUSH
17975: LD_INT 27
17977: PUSH
17978: LD_INT 44
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: LIST
17985: IN
17986: IFFALSE 18007
// points := [ 14 , 50 , 16 ] ;
17988: LD_ADDR_VAR 0 9
17992: PUSH
17993: LD_INT 14
17995: PUSH
17996: LD_INT 50
17998: PUSH
17999: LD_INT 16
18001: PUSH
18002: EMPTY
18003: LIST
18004: LIST
18005: LIST
18006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18007: LD_VAR 0 6
18011: PPUSH
18012: CALL_OW 264
18016: PUSH
18017: LD_INT 6
18019: PUSH
18020: LD_INT 46
18022: PUSH
18023: EMPTY
18024: LIST
18025: LIST
18026: IN
18027: IFFALSE 18048
// points := [ 32 , 120 , 70 ] ;
18029: LD_ADDR_VAR 0 9
18033: PUSH
18034: LD_INT 32
18036: PUSH
18037: LD_INT 120
18039: PUSH
18040: LD_INT 70
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18048: LD_VAR 0 6
18052: PPUSH
18053: CALL_OW 264
18057: PUSH
18058: LD_INT 7
18060: PUSH
18061: LD_INT 28
18063: PUSH
18064: LD_INT 45
18066: PUSH
18067: LD_INT 92
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: LIST
18074: LIST
18075: IN
18076: IFFALSE 18097
// points := [ 35 , 20 , 45 ] ;
18078: LD_ADDR_VAR 0 9
18082: PUSH
18083: LD_INT 35
18085: PUSH
18086: LD_INT 20
18088: PUSH
18089: LD_INT 45
18091: PUSH
18092: EMPTY
18093: LIST
18094: LIST
18095: LIST
18096: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18097: LD_VAR 0 6
18101: PPUSH
18102: CALL_OW 264
18106: PUSH
18107: LD_INT 47
18109: PUSH
18110: EMPTY
18111: LIST
18112: IN
18113: IFFALSE 18134
// points := [ 67 , 45 , 75 ] ;
18115: LD_ADDR_VAR 0 9
18119: PUSH
18120: LD_INT 67
18122: PUSH
18123: LD_INT 45
18125: PUSH
18126: LD_INT 75
18128: PUSH
18129: EMPTY
18130: LIST
18131: LIST
18132: LIST
18133: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18134: LD_VAR 0 6
18138: PPUSH
18139: CALL_OW 264
18143: PUSH
18144: LD_INT 26
18146: PUSH
18147: EMPTY
18148: LIST
18149: IN
18150: IFFALSE 18171
// points := [ 120 , 30 , 80 ] ;
18152: LD_ADDR_VAR 0 9
18156: PUSH
18157: LD_INT 120
18159: PUSH
18160: LD_INT 30
18162: PUSH
18163: LD_INT 80
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18171: LD_VAR 0 6
18175: PPUSH
18176: CALL_OW 264
18180: PUSH
18181: LD_INT 22
18183: PUSH
18184: EMPTY
18185: LIST
18186: IN
18187: IFFALSE 18208
// points := [ 40 , 1 , 1 ] ;
18189: LD_ADDR_VAR 0 9
18193: PUSH
18194: LD_INT 40
18196: PUSH
18197: LD_INT 1
18199: PUSH
18200: LD_INT 1
18202: PUSH
18203: EMPTY
18204: LIST
18205: LIST
18206: LIST
18207: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18208: LD_VAR 0 6
18212: PPUSH
18213: CALL_OW 264
18217: PUSH
18218: LD_INT 29
18220: PUSH
18221: EMPTY
18222: LIST
18223: IN
18224: IFFALSE 18245
// points := [ 70 , 200 , 400 ] ;
18226: LD_ADDR_VAR 0 9
18230: PUSH
18231: LD_INT 70
18233: PUSH
18234: LD_INT 200
18236: PUSH
18237: LD_INT 400
18239: PUSH
18240: EMPTY
18241: LIST
18242: LIST
18243: LIST
18244: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18245: LD_VAR 0 6
18249: PPUSH
18250: CALL_OW 264
18254: PUSH
18255: LD_INT 14
18257: PUSH
18258: LD_INT 53
18260: PUSH
18261: EMPTY
18262: LIST
18263: LIST
18264: IN
18265: IFFALSE 18286
// points := [ 40 , 10 , 20 ] ;
18267: LD_ADDR_VAR 0 9
18271: PUSH
18272: LD_INT 40
18274: PUSH
18275: LD_INT 10
18277: PUSH
18278: LD_INT 20
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: LIST
18285: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18286: LD_VAR 0 6
18290: PPUSH
18291: CALL_OW 264
18295: PUSH
18296: LD_INT 9
18298: PUSH
18299: EMPTY
18300: LIST
18301: IN
18302: IFFALSE 18323
// points := [ 5 , 70 , 20 ] ;
18304: LD_ADDR_VAR 0 9
18308: PUSH
18309: LD_INT 5
18311: PUSH
18312: LD_INT 70
18314: PUSH
18315: LD_INT 20
18317: PUSH
18318: EMPTY
18319: LIST
18320: LIST
18321: LIST
18322: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18323: LD_VAR 0 6
18327: PPUSH
18328: CALL_OW 264
18332: PUSH
18333: LD_INT 10
18335: PUSH
18336: EMPTY
18337: LIST
18338: IN
18339: IFFALSE 18360
// points := [ 35 , 110 , 70 ] ;
18341: LD_ADDR_VAR 0 9
18345: PUSH
18346: LD_INT 35
18348: PUSH
18349: LD_INT 110
18351: PUSH
18352: LD_INT 70
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: LIST
18359: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18360: LD_VAR 0 6
18364: PPUSH
18365: CALL_OW 265
18369: PUSH
18370: LD_INT 25
18372: EQUAL
18373: IFFALSE 18394
// points := [ 80 , 65 , 100 ] ;
18375: LD_ADDR_VAR 0 9
18379: PUSH
18380: LD_INT 80
18382: PUSH
18383: LD_INT 65
18385: PUSH
18386: LD_INT 100
18388: PUSH
18389: EMPTY
18390: LIST
18391: LIST
18392: LIST
18393: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18394: LD_VAR 0 6
18398: PPUSH
18399: CALL_OW 263
18403: PUSH
18404: LD_INT 1
18406: EQUAL
18407: IFFALSE 18442
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18409: LD_ADDR_VAR 0 10
18413: PUSH
18414: LD_VAR 0 10
18418: PUSH
18419: LD_VAR 0 6
18423: PPUSH
18424: CALL_OW 311
18428: PPUSH
18429: LD_INT 3
18431: PPUSH
18432: CALL_OW 259
18436: PUSH
18437: LD_INT 4
18439: MUL
18440: MUL
18441: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18442: LD_VAR 0 6
18446: PPUSH
18447: CALL_OW 263
18451: PUSH
18452: LD_INT 2
18454: EQUAL
18455: IFFALSE 18506
// begin j := IsControledBy ( i ) ;
18457: LD_ADDR_VAR 0 7
18461: PUSH
18462: LD_VAR 0 6
18466: PPUSH
18467: CALL_OW 312
18471: ST_TO_ADDR
// if j then
18472: LD_VAR 0 7
18476: IFFALSE 18506
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18478: LD_ADDR_VAR 0 10
18482: PUSH
18483: LD_VAR 0 10
18487: PUSH
18488: LD_VAR 0 7
18492: PPUSH
18493: LD_INT 3
18495: PPUSH
18496: CALL_OW 259
18500: PUSH
18501: LD_INT 3
18503: MUL
18504: MUL
18505: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18506: LD_VAR 0 6
18510: PPUSH
18511: CALL_OW 264
18515: PUSH
18516: LD_INT 5
18518: PUSH
18519: LD_INT 6
18521: PUSH
18522: LD_INT 46
18524: PUSH
18525: LD_INT 44
18527: PUSH
18528: LD_INT 47
18530: PUSH
18531: LD_INT 45
18533: PUSH
18534: LD_INT 28
18536: PUSH
18537: LD_INT 7
18539: PUSH
18540: LD_INT 27
18542: PUSH
18543: LD_INT 29
18545: PUSH
18546: EMPTY
18547: LIST
18548: LIST
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: LIST
18556: LIST
18557: IN
18558: PUSH
18559: LD_VAR 0 1
18563: PPUSH
18564: LD_INT 52
18566: PPUSH
18567: CALL_OW 321
18571: PUSH
18572: LD_INT 2
18574: EQUAL
18575: AND
18576: IFFALSE 18593
// bpoints := bpoints * 1.2 ;
18578: LD_ADDR_VAR 0 10
18582: PUSH
18583: LD_VAR 0 10
18587: PUSH
18588: LD_REAL  1.20000000000000E+0000
18591: MUL
18592: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18593: LD_VAR 0 6
18597: PPUSH
18598: CALL_OW 264
18602: PUSH
18603: LD_INT 6
18605: PUSH
18606: LD_INT 46
18608: PUSH
18609: LD_INT 47
18611: PUSH
18612: EMPTY
18613: LIST
18614: LIST
18615: LIST
18616: IN
18617: IFFALSE 18634
// bpoints := bpoints * 1.2 ;
18619: LD_ADDR_VAR 0 10
18623: PUSH
18624: LD_VAR 0 10
18628: PUSH
18629: LD_REAL  1.20000000000000E+0000
18632: MUL
18633: ST_TO_ADDR
// end ; unit_building :
18634: GO 18648
18636: LD_INT 3
18638: DOUBLE
18639: EQUAL
18640: IFTRUE 18644
18642: GO 18647
18644: POP
// ; end ;
18645: GO 18648
18647: POP
// for j = 1 to 3 do
18648: LD_ADDR_VAR 0 7
18652: PUSH
18653: DOUBLE
18654: LD_INT 1
18656: DEC
18657: ST_TO_ADDR
18658: LD_INT 3
18660: PUSH
18661: FOR_TO
18662: IFFALSE 18715
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18664: LD_ADDR_VAR 0 5
18668: PUSH
18669: LD_VAR 0 5
18673: PPUSH
18674: LD_VAR 0 7
18678: PPUSH
18679: LD_VAR 0 5
18683: PUSH
18684: LD_VAR 0 7
18688: ARRAY
18689: PUSH
18690: LD_VAR 0 9
18694: PUSH
18695: LD_VAR 0 7
18699: ARRAY
18700: PUSH
18701: LD_VAR 0 10
18705: MUL
18706: PLUS
18707: PPUSH
18708: CALL_OW 1
18712: ST_TO_ADDR
18713: GO 18661
18715: POP
18716: POP
// end ;
18717: GO 17196
18719: POP
18720: POP
// result := Replace ( result , 4 , tmp ) ;
18721: LD_ADDR_VAR 0 5
18725: PUSH
18726: LD_VAR 0 5
18730: PPUSH
18731: LD_INT 4
18733: PPUSH
18734: LD_VAR 0 8
18738: PPUSH
18739: CALL_OW 1
18743: ST_TO_ADDR
// end ;
18744: LD_VAR 0 5
18748: RET
// export function DangerAtRange ( unit , range ) ; begin
18749: LD_INT 0
18751: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18752: LD_ADDR_VAR 0 3
18756: PUSH
18757: LD_VAR 0 1
18761: PPUSH
18762: CALL_OW 255
18766: PPUSH
18767: LD_VAR 0 1
18771: PPUSH
18772: CALL_OW 250
18776: PPUSH
18777: LD_VAR 0 1
18781: PPUSH
18782: CALL_OW 251
18786: PPUSH
18787: LD_VAR 0 2
18791: PPUSH
18792: CALL 17048 0 4
18796: ST_TO_ADDR
// end ;
18797: LD_VAR 0 3
18801: RET
// export function DangerInArea ( side , area ) ; begin
18802: LD_INT 0
18804: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18805: LD_ADDR_VAR 0 3
18809: PUSH
18810: LD_VAR 0 2
18814: PPUSH
18815: LD_INT 81
18817: PUSH
18818: LD_VAR 0 1
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: PPUSH
18827: CALL_OW 70
18831: ST_TO_ADDR
// end ;
18832: LD_VAR 0 3
18836: RET
// export function IsExtension ( b ) ; begin
18837: LD_INT 0
18839: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18840: LD_ADDR_VAR 0 2
18844: PUSH
18845: LD_VAR 0 1
18849: PUSH
18850: LD_INT 23
18852: PUSH
18853: LD_INT 20
18855: PUSH
18856: LD_INT 22
18858: PUSH
18859: LD_INT 17
18861: PUSH
18862: LD_INT 24
18864: PUSH
18865: LD_INT 21
18867: PUSH
18868: LD_INT 19
18870: PUSH
18871: LD_INT 16
18873: PUSH
18874: LD_INT 25
18876: PUSH
18877: LD_INT 18
18879: PUSH
18880: EMPTY
18881: LIST
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: LIST
18889: LIST
18890: LIST
18891: IN
18892: ST_TO_ADDR
// end ;
18893: LD_VAR 0 2
18897: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18898: LD_INT 0
18900: PPUSH
18901: PPUSH
18902: PPUSH
// result := [ ] ;
18903: LD_ADDR_VAR 0 4
18907: PUSH
18908: EMPTY
18909: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18910: LD_ADDR_VAR 0 5
18914: PUSH
18915: LD_VAR 0 2
18919: PPUSH
18920: LD_INT 21
18922: PUSH
18923: LD_INT 3
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: PPUSH
18930: CALL_OW 70
18934: ST_TO_ADDR
// if not tmp then
18935: LD_VAR 0 5
18939: NOT
18940: IFFALSE 18944
// exit ;
18942: GO 19008
// if checkLink then
18944: LD_VAR 0 3
18948: IFFALSE 18998
// begin for i in tmp do
18950: LD_ADDR_VAR 0 6
18954: PUSH
18955: LD_VAR 0 5
18959: PUSH
18960: FOR_IN
18961: IFFALSE 18996
// if GetBase ( i ) <> base then
18963: LD_VAR 0 6
18967: PPUSH
18968: CALL_OW 274
18972: PUSH
18973: LD_VAR 0 1
18977: NONEQUAL
18978: IFFALSE 18994
// ComLinkToBase ( base , i ) ;
18980: LD_VAR 0 1
18984: PPUSH
18985: LD_VAR 0 6
18989: PPUSH
18990: CALL_OW 169
18994: GO 18960
18996: POP
18997: POP
// end ; result := tmp ;
18998: LD_ADDR_VAR 0 4
19002: PUSH
19003: LD_VAR 0 5
19007: ST_TO_ADDR
// end ;
19008: LD_VAR 0 4
19012: RET
// export function ComComplete ( units , b ) ; var i ; begin
19013: LD_INT 0
19015: PPUSH
19016: PPUSH
// if not units then
19017: LD_VAR 0 1
19021: NOT
19022: IFFALSE 19026
// exit ;
19024: GO 19116
// for i in units do
19026: LD_ADDR_VAR 0 4
19030: PUSH
19031: LD_VAR 0 1
19035: PUSH
19036: FOR_IN
19037: IFFALSE 19114
// if BuildingStatus ( b ) = bs_build then
19039: LD_VAR 0 2
19043: PPUSH
19044: CALL_OW 461
19048: PUSH
19049: LD_INT 1
19051: EQUAL
19052: IFFALSE 19112
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19054: LD_VAR 0 4
19058: PPUSH
19059: LD_STRING h
19061: PUSH
19062: LD_VAR 0 2
19066: PPUSH
19067: CALL_OW 250
19071: PUSH
19072: LD_VAR 0 2
19076: PPUSH
19077: CALL_OW 251
19081: PUSH
19082: LD_VAR 0 2
19086: PUSH
19087: LD_INT 0
19089: PUSH
19090: LD_INT 0
19092: PUSH
19093: LD_INT 0
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: LIST
19103: LIST
19104: PUSH
19105: EMPTY
19106: LIST
19107: PPUSH
19108: CALL_OW 446
19112: GO 19036
19114: POP
19115: POP
// end ;
19116: LD_VAR 0 3
19120: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19121: LD_INT 0
19123: PPUSH
19124: PPUSH
19125: PPUSH
19126: PPUSH
19127: PPUSH
19128: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19129: LD_VAR 0 1
19133: NOT
19134: PUSH
19135: LD_VAR 0 1
19139: PPUSH
19140: CALL_OW 263
19144: PUSH
19145: LD_INT 2
19147: NONEQUAL
19148: OR
19149: IFFALSE 19153
// exit ;
19151: GO 19469
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19153: LD_ADDR_VAR 0 6
19157: PUSH
19158: LD_INT 22
19160: PUSH
19161: LD_VAR 0 1
19165: PPUSH
19166: CALL_OW 255
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PUSH
19175: LD_INT 2
19177: PUSH
19178: LD_INT 30
19180: PUSH
19181: LD_INT 36
19183: PUSH
19184: EMPTY
19185: LIST
19186: LIST
19187: PUSH
19188: LD_INT 34
19190: PUSH
19191: LD_INT 31
19193: PUSH
19194: EMPTY
19195: LIST
19196: LIST
19197: PUSH
19198: EMPTY
19199: LIST
19200: LIST
19201: LIST
19202: PUSH
19203: EMPTY
19204: LIST
19205: LIST
19206: PPUSH
19207: CALL_OW 69
19211: ST_TO_ADDR
// if not tmp then
19212: LD_VAR 0 6
19216: NOT
19217: IFFALSE 19221
// exit ;
19219: GO 19469
// result := [ ] ;
19221: LD_ADDR_VAR 0 2
19225: PUSH
19226: EMPTY
19227: ST_TO_ADDR
// for i in tmp do
19228: LD_ADDR_VAR 0 3
19232: PUSH
19233: LD_VAR 0 6
19237: PUSH
19238: FOR_IN
19239: IFFALSE 19310
// begin t := UnitsInside ( i ) ;
19241: LD_ADDR_VAR 0 4
19245: PUSH
19246: LD_VAR 0 3
19250: PPUSH
19251: CALL_OW 313
19255: ST_TO_ADDR
// if t then
19256: LD_VAR 0 4
19260: IFFALSE 19308
// for j in t do
19262: LD_ADDR_VAR 0 7
19266: PUSH
19267: LD_VAR 0 4
19271: PUSH
19272: FOR_IN
19273: IFFALSE 19306
// result := Replace ( result , result + 1 , j ) ;
19275: LD_ADDR_VAR 0 2
19279: PUSH
19280: LD_VAR 0 2
19284: PPUSH
19285: LD_VAR 0 2
19289: PUSH
19290: LD_INT 1
19292: PLUS
19293: PPUSH
19294: LD_VAR 0 7
19298: PPUSH
19299: CALL_OW 1
19303: ST_TO_ADDR
19304: GO 19272
19306: POP
19307: POP
// end ;
19308: GO 19238
19310: POP
19311: POP
// if not result then
19312: LD_VAR 0 2
19316: NOT
19317: IFFALSE 19321
// exit ;
19319: GO 19469
// mech := result [ 1 ] ;
19321: LD_ADDR_VAR 0 5
19325: PUSH
19326: LD_VAR 0 2
19330: PUSH
19331: LD_INT 1
19333: ARRAY
19334: ST_TO_ADDR
// if result > 1 then
19335: LD_VAR 0 2
19339: PUSH
19340: LD_INT 1
19342: GREATER
19343: IFFALSE 19455
// begin for i = 2 to result do
19345: LD_ADDR_VAR 0 3
19349: PUSH
19350: DOUBLE
19351: LD_INT 2
19353: DEC
19354: ST_TO_ADDR
19355: LD_VAR 0 2
19359: PUSH
19360: FOR_TO
19361: IFFALSE 19453
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19363: LD_ADDR_VAR 0 4
19367: PUSH
19368: LD_VAR 0 2
19372: PUSH
19373: LD_VAR 0 3
19377: ARRAY
19378: PPUSH
19379: LD_INT 3
19381: PPUSH
19382: CALL_OW 259
19386: PUSH
19387: LD_VAR 0 2
19391: PUSH
19392: LD_VAR 0 3
19396: ARRAY
19397: PPUSH
19398: CALL_OW 432
19402: MINUS
19403: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19404: LD_VAR 0 4
19408: PUSH
19409: LD_VAR 0 5
19413: PPUSH
19414: LD_INT 3
19416: PPUSH
19417: CALL_OW 259
19421: PUSH
19422: LD_VAR 0 5
19426: PPUSH
19427: CALL_OW 432
19431: MINUS
19432: GREATEREQUAL
19433: IFFALSE 19451
// mech := result [ i ] ;
19435: LD_ADDR_VAR 0 5
19439: PUSH
19440: LD_VAR 0 2
19444: PUSH
19445: LD_VAR 0 3
19449: ARRAY
19450: ST_TO_ADDR
// end ;
19451: GO 19360
19453: POP
19454: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19455: LD_VAR 0 1
19459: PPUSH
19460: LD_VAR 0 5
19464: PPUSH
19465: CALL_OW 135
// end ;
19469: LD_VAR 0 2
19473: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19474: LD_INT 0
19476: PPUSH
19477: PPUSH
19478: PPUSH
19479: PPUSH
19480: PPUSH
19481: PPUSH
19482: PPUSH
19483: PPUSH
19484: PPUSH
19485: PPUSH
19486: PPUSH
19487: PPUSH
19488: PPUSH
// result := [ ] ;
19489: LD_ADDR_VAR 0 7
19493: PUSH
19494: EMPTY
19495: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19496: LD_VAR 0 1
19500: PPUSH
19501: CALL_OW 266
19505: PUSH
19506: LD_INT 0
19508: PUSH
19509: LD_INT 1
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: IN
19516: NOT
19517: IFFALSE 19521
// exit ;
19519: GO 21155
// if name then
19521: LD_VAR 0 3
19525: IFFALSE 19541
// SetBName ( base_dep , name ) ;
19527: LD_VAR 0 1
19531: PPUSH
19532: LD_VAR 0 3
19536: PPUSH
19537: CALL_OW 500
// base := GetBase ( base_dep ) ;
19541: LD_ADDR_VAR 0 15
19545: PUSH
19546: LD_VAR 0 1
19550: PPUSH
19551: CALL_OW 274
19555: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19556: LD_ADDR_VAR 0 16
19560: PUSH
19561: LD_VAR 0 1
19565: PPUSH
19566: CALL_OW 255
19570: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19571: LD_ADDR_VAR 0 17
19575: PUSH
19576: LD_VAR 0 1
19580: PPUSH
19581: CALL_OW 248
19585: ST_TO_ADDR
// if sources then
19586: LD_VAR 0 5
19590: IFFALSE 19637
// for i = 1 to 3 do
19592: LD_ADDR_VAR 0 8
19596: PUSH
19597: DOUBLE
19598: LD_INT 1
19600: DEC
19601: ST_TO_ADDR
19602: LD_INT 3
19604: PUSH
19605: FOR_TO
19606: IFFALSE 19635
// AddResourceType ( base , i , sources [ i ] ) ;
19608: LD_VAR 0 15
19612: PPUSH
19613: LD_VAR 0 8
19617: PPUSH
19618: LD_VAR 0 5
19622: PUSH
19623: LD_VAR 0 8
19627: ARRAY
19628: PPUSH
19629: CALL_OW 276
19633: GO 19605
19635: POP
19636: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19637: LD_ADDR_VAR 0 18
19641: PUSH
19642: LD_VAR 0 15
19646: PPUSH
19647: LD_VAR 0 2
19651: PPUSH
19652: LD_INT 1
19654: PPUSH
19655: CALL 18898 0 3
19659: ST_TO_ADDR
// InitHc ;
19660: CALL_OW 19
// InitUc ;
19664: CALL_OW 18
// uc_side := side ;
19668: LD_ADDR_OWVAR 20
19672: PUSH
19673: LD_VAR 0 16
19677: ST_TO_ADDR
// uc_nation := nation ;
19678: LD_ADDR_OWVAR 21
19682: PUSH
19683: LD_VAR 0 17
19687: ST_TO_ADDR
// if buildings then
19688: LD_VAR 0 18
19692: IFFALSE 21014
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19694: LD_ADDR_VAR 0 19
19698: PUSH
19699: LD_VAR 0 18
19703: PPUSH
19704: LD_INT 2
19706: PUSH
19707: LD_INT 30
19709: PUSH
19710: LD_INT 29
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: PUSH
19717: LD_INT 30
19719: PUSH
19720: LD_INT 30
19722: PUSH
19723: EMPTY
19724: LIST
19725: LIST
19726: PUSH
19727: EMPTY
19728: LIST
19729: LIST
19730: LIST
19731: PPUSH
19732: CALL_OW 72
19736: ST_TO_ADDR
// if tmp then
19737: LD_VAR 0 19
19741: IFFALSE 19789
// for i in tmp do
19743: LD_ADDR_VAR 0 8
19747: PUSH
19748: LD_VAR 0 19
19752: PUSH
19753: FOR_IN
19754: IFFALSE 19787
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19756: LD_VAR 0 8
19760: PPUSH
19761: CALL_OW 250
19765: PPUSH
19766: LD_VAR 0 8
19770: PPUSH
19771: CALL_OW 251
19775: PPUSH
19776: LD_VAR 0 16
19780: PPUSH
19781: CALL_OW 441
19785: GO 19753
19787: POP
19788: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19789: LD_VAR 0 18
19793: PPUSH
19794: LD_INT 2
19796: PUSH
19797: LD_INT 30
19799: PUSH
19800: LD_INT 32
19802: PUSH
19803: EMPTY
19804: LIST
19805: LIST
19806: PUSH
19807: LD_INT 30
19809: PUSH
19810: LD_INT 33
19812: PUSH
19813: EMPTY
19814: LIST
19815: LIST
19816: PUSH
19817: EMPTY
19818: LIST
19819: LIST
19820: LIST
19821: PPUSH
19822: CALL_OW 72
19826: IFFALSE 19914
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19828: LD_ADDR_VAR 0 8
19832: PUSH
19833: LD_VAR 0 18
19837: PPUSH
19838: LD_INT 2
19840: PUSH
19841: LD_INT 30
19843: PUSH
19844: LD_INT 32
19846: PUSH
19847: EMPTY
19848: LIST
19849: LIST
19850: PUSH
19851: LD_INT 30
19853: PUSH
19854: LD_INT 33
19856: PUSH
19857: EMPTY
19858: LIST
19859: LIST
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: LIST
19865: PPUSH
19866: CALL_OW 72
19870: PUSH
19871: FOR_IN
19872: IFFALSE 19912
// begin if not GetBWeapon ( i ) then
19874: LD_VAR 0 8
19878: PPUSH
19879: CALL_OW 269
19883: NOT
19884: IFFALSE 19910
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19886: LD_VAR 0 8
19890: PPUSH
19891: LD_VAR 0 8
19895: PPUSH
19896: LD_VAR 0 2
19900: PPUSH
19901: CALL 21160 0 2
19905: PPUSH
19906: CALL_OW 431
// end ;
19910: GO 19871
19912: POP
19913: POP
// end ; for i = 1 to personel do
19914: LD_ADDR_VAR 0 8
19918: PUSH
19919: DOUBLE
19920: LD_INT 1
19922: DEC
19923: ST_TO_ADDR
19924: LD_VAR 0 6
19928: PUSH
19929: FOR_TO
19930: IFFALSE 20994
// begin if i > 4 then
19932: LD_VAR 0 8
19936: PUSH
19937: LD_INT 4
19939: GREATER
19940: IFFALSE 19944
// break ;
19942: GO 20994
// case i of 1 :
19944: LD_VAR 0 8
19948: PUSH
19949: LD_INT 1
19951: DOUBLE
19952: EQUAL
19953: IFTRUE 19957
19955: GO 20037
19957: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19958: LD_ADDR_VAR 0 12
19962: PUSH
19963: LD_VAR 0 18
19967: PPUSH
19968: LD_INT 22
19970: PUSH
19971: LD_VAR 0 16
19975: PUSH
19976: EMPTY
19977: LIST
19978: LIST
19979: PUSH
19980: LD_INT 58
19982: PUSH
19983: EMPTY
19984: LIST
19985: PUSH
19986: LD_INT 2
19988: PUSH
19989: LD_INT 30
19991: PUSH
19992: LD_INT 32
19994: PUSH
19995: EMPTY
19996: LIST
19997: LIST
19998: PUSH
19999: LD_INT 30
20001: PUSH
20002: LD_INT 4
20004: PUSH
20005: EMPTY
20006: LIST
20007: LIST
20008: PUSH
20009: LD_INT 30
20011: PUSH
20012: LD_INT 5
20014: PUSH
20015: EMPTY
20016: LIST
20017: LIST
20018: PUSH
20019: EMPTY
20020: LIST
20021: LIST
20022: LIST
20023: LIST
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: LIST
20029: PPUSH
20030: CALL_OW 72
20034: ST_TO_ADDR
20035: GO 20259
20037: LD_INT 2
20039: DOUBLE
20040: EQUAL
20041: IFTRUE 20045
20043: GO 20107
20045: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20046: LD_ADDR_VAR 0 12
20050: PUSH
20051: LD_VAR 0 18
20055: PPUSH
20056: LD_INT 22
20058: PUSH
20059: LD_VAR 0 16
20063: PUSH
20064: EMPTY
20065: LIST
20066: LIST
20067: PUSH
20068: LD_INT 2
20070: PUSH
20071: LD_INT 30
20073: PUSH
20074: LD_INT 0
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: LD_INT 30
20083: PUSH
20084: LD_INT 1
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: LIST
20095: PUSH
20096: EMPTY
20097: LIST
20098: LIST
20099: PPUSH
20100: CALL_OW 72
20104: ST_TO_ADDR
20105: GO 20259
20107: LD_INT 3
20109: DOUBLE
20110: EQUAL
20111: IFTRUE 20115
20113: GO 20177
20115: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20116: LD_ADDR_VAR 0 12
20120: PUSH
20121: LD_VAR 0 18
20125: PPUSH
20126: LD_INT 22
20128: PUSH
20129: LD_VAR 0 16
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: PUSH
20138: LD_INT 2
20140: PUSH
20141: LD_INT 30
20143: PUSH
20144: LD_INT 2
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: PUSH
20151: LD_INT 30
20153: PUSH
20154: LD_INT 3
20156: PUSH
20157: EMPTY
20158: LIST
20159: LIST
20160: PUSH
20161: EMPTY
20162: LIST
20163: LIST
20164: LIST
20165: PUSH
20166: EMPTY
20167: LIST
20168: LIST
20169: PPUSH
20170: CALL_OW 72
20174: ST_TO_ADDR
20175: GO 20259
20177: LD_INT 4
20179: DOUBLE
20180: EQUAL
20181: IFTRUE 20185
20183: GO 20258
20185: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20186: LD_ADDR_VAR 0 12
20190: PUSH
20191: LD_VAR 0 18
20195: PPUSH
20196: LD_INT 22
20198: PUSH
20199: LD_VAR 0 16
20203: PUSH
20204: EMPTY
20205: LIST
20206: LIST
20207: PUSH
20208: LD_INT 2
20210: PUSH
20211: LD_INT 30
20213: PUSH
20214: LD_INT 6
20216: PUSH
20217: EMPTY
20218: LIST
20219: LIST
20220: PUSH
20221: LD_INT 30
20223: PUSH
20224: LD_INT 7
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: PUSH
20231: LD_INT 30
20233: PUSH
20234: LD_INT 8
20236: PUSH
20237: EMPTY
20238: LIST
20239: LIST
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: LIST
20245: LIST
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PPUSH
20251: CALL_OW 72
20255: ST_TO_ADDR
20256: GO 20259
20258: POP
// if i = 1 then
20259: LD_VAR 0 8
20263: PUSH
20264: LD_INT 1
20266: EQUAL
20267: IFFALSE 20378
// begin tmp := [ ] ;
20269: LD_ADDR_VAR 0 19
20273: PUSH
20274: EMPTY
20275: ST_TO_ADDR
// for j in f do
20276: LD_ADDR_VAR 0 9
20280: PUSH
20281: LD_VAR 0 12
20285: PUSH
20286: FOR_IN
20287: IFFALSE 20360
// if GetBType ( j ) = b_bunker then
20289: LD_VAR 0 9
20293: PPUSH
20294: CALL_OW 266
20298: PUSH
20299: LD_INT 32
20301: EQUAL
20302: IFFALSE 20329
// tmp := Insert ( tmp , 1 , j ) else
20304: LD_ADDR_VAR 0 19
20308: PUSH
20309: LD_VAR 0 19
20313: PPUSH
20314: LD_INT 1
20316: PPUSH
20317: LD_VAR 0 9
20321: PPUSH
20322: CALL_OW 2
20326: ST_TO_ADDR
20327: GO 20358
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20329: LD_ADDR_VAR 0 19
20333: PUSH
20334: LD_VAR 0 19
20338: PPUSH
20339: LD_VAR 0 19
20343: PUSH
20344: LD_INT 1
20346: PLUS
20347: PPUSH
20348: LD_VAR 0 9
20352: PPUSH
20353: CALL_OW 2
20357: ST_TO_ADDR
20358: GO 20286
20360: POP
20361: POP
// if tmp then
20362: LD_VAR 0 19
20366: IFFALSE 20378
// f := tmp ;
20368: LD_ADDR_VAR 0 12
20372: PUSH
20373: LD_VAR 0 19
20377: ST_TO_ADDR
// end ; x := personel [ i ] ;
20378: LD_ADDR_VAR 0 13
20382: PUSH
20383: LD_VAR 0 6
20387: PUSH
20388: LD_VAR 0 8
20392: ARRAY
20393: ST_TO_ADDR
// if x = - 1 then
20394: LD_VAR 0 13
20398: PUSH
20399: LD_INT 1
20401: NEG
20402: EQUAL
20403: IFFALSE 20612
// begin for j in f do
20405: LD_ADDR_VAR 0 9
20409: PUSH
20410: LD_VAR 0 12
20414: PUSH
20415: FOR_IN
20416: IFFALSE 20608
// repeat InitHc ;
20418: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20422: LD_VAR 0 9
20426: PPUSH
20427: CALL_OW 266
20431: PUSH
20432: LD_INT 5
20434: EQUAL
20435: IFFALSE 20505
// begin if UnitsInside ( j ) < 3 then
20437: LD_VAR 0 9
20441: PPUSH
20442: CALL_OW 313
20446: PUSH
20447: LD_INT 3
20449: LESS
20450: IFFALSE 20486
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20452: LD_INT 0
20454: PPUSH
20455: LD_INT 5
20457: PUSH
20458: LD_INT 8
20460: PUSH
20461: LD_INT 9
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: LIST
20468: PUSH
20469: LD_VAR 0 17
20473: ARRAY
20474: PPUSH
20475: LD_VAR 0 4
20479: PPUSH
20480: CALL_OW 380
20484: GO 20503
// PrepareHuman ( false , i , skill ) ;
20486: LD_INT 0
20488: PPUSH
20489: LD_VAR 0 8
20493: PPUSH
20494: LD_VAR 0 4
20498: PPUSH
20499: CALL_OW 380
// end else
20503: GO 20522
// PrepareHuman ( false , i , skill ) ;
20505: LD_INT 0
20507: PPUSH
20508: LD_VAR 0 8
20512: PPUSH
20513: LD_VAR 0 4
20517: PPUSH
20518: CALL_OW 380
// un := CreateHuman ;
20522: LD_ADDR_VAR 0 14
20526: PUSH
20527: CALL_OW 44
20531: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20532: LD_ADDR_VAR 0 7
20536: PUSH
20537: LD_VAR 0 7
20541: PPUSH
20542: LD_INT 1
20544: PPUSH
20545: LD_VAR 0 14
20549: PPUSH
20550: CALL_OW 2
20554: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20555: LD_VAR 0 14
20559: PPUSH
20560: LD_VAR 0 9
20564: PPUSH
20565: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20569: LD_VAR 0 9
20573: PPUSH
20574: CALL_OW 313
20578: PUSH
20579: LD_INT 6
20581: EQUAL
20582: PUSH
20583: LD_VAR 0 9
20587: PPUSH
20588: CALL_OW 266
20592: PUSH
20593: LD_INT 32
20595: PUSH
20596: LD_INT 31
20598: PUSH
20599: EMPTY
20600: LIST
20601: LIST
20602: IN
20603: OR
20604: IFFALSE 20418
20606: GO 20415
20608: POP
20609: POP
// end else
20610: GO 20992
// for j = 1 to x do
20612: LD_ADDR_VAR 0 9
20616: PUSH
20617: DOUBLE
20618: LD_INT 1
20620: DEC
20621: ST_TO_ADDR
20622: LD_VAR 0 13
20626: PUSH
20627: FOR_TO
20628: IFFALSE 20990
// begin InitHc ;
20630: CALL_OW 19
// if not f then
20634: LD_VAR 0 12
20638: NOT
20639: IFFALSE 20728
// begin PrepareHuman ( false , i , skill ) ;
20641: LD_INT 0
20643: PPUSH
20644: LD_VAR 0 8
20648: PPUSH
20649: LD_VAR 0 4
20653: PPUSH
20654: CALL_OW 380
// un := CreateHuman ;
20658: LD_ADDR_VAR 0 14
20662: PUSH
20663: CALL_OW 44
20667: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20668: LD_ADDR_VAR 0 7
20672: PUSH
20673: LD_VAR 0 7
20677: PPUSH
20678: LD_INT 1
20680: PPUSH
20681: LD_VAR 0 14
20685: PPUSH
20686: CALL_OW 2
20690: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20691: LD_VAR 0 14
20695: PPUSH
20696: LD_VAR 0 1
20700: PPUSH
20701: CALL_OW 250
20705: PPUSH
20706: LD_VAR 0 1
20710: PPUSH
20711: CALL_OW 251
20715: PPUSH
20716: LD_INT 10
20718: PPUSH
20719: LD_INT 0
20721: PPUSH
20722: CALL_OW 50
// continue ;
20726: GO 20627
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20728: LD_VAR 0 12
20732: PUSH
20733: LD_INT 1
20735: ARRAY
20736: PPUSH
20737: CALL_OW 313
20741: PUSH
20742: LD_VAR 0 12
20746: PUSH
20747: LD_INT 1
20749: ARRAY
20750: PPUSH
20751: CALL_OW 266
20755: PUSH
20756: LD_INT 32
20758: PUSH
20759: LD_INT 31
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: IN
20766: AND
20767: PUSH
20768: LD_VAR 0 12
20772: PUSH
20773: LD_INT 1
20775: ARRAY
20776: PPUSH
20777: CALL_OW 313
20781: PUSH
20782: LD_INT 6
20784: EQUAL
20785: OR
20786: IFFALSE 20806
// f := Delete ( f , 1 ) ;
20788: LD_ADDR_VAR 0 12
20792: PUSH
20793: LD_VAR 0 12
20797: PPUSH
20798: LD_INT 1
20800: PPUSH
20801: CALL_OW 3
20805: ST_TO_ADDR
// if not f then
20806: LD_VAR 0 12
20810: NOT
20811: IFFALSE 20829
// begin x := x + 2 ;
20813: LD_ADDR_VAR 0 13
20817: PUSH
20818: LD_VAR 0 13
20822: PUSH
20823: LD_INT 2
20825: PLUS
20826: ST_TO_ADDR
// continue ;
20827: GO 20627
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20829: LD_VAR 0 12
20833: PUSH
20834: LD_INT 1
20836: ARRAY
20837: PPUSH
20838: CALL_OW 266
20842: PUSH
20843: LD_INT 5
20845: EQUAL
20846: IFFALSE 20920
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20848: LD_VAR 0 12
20852: PUSH
20853: LD_INT 1
20855: ARRAY
20856: PPUSH
20857: CALL_OW 313
20861: PUSH
20862: LD_INT 3
20864: LESS
20865: IFFALSE 20901
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20867: LD_INT 0
20869: PPUSH
20870: LD_INT 5
20872: PUSH
20873: LD_INT 8
20875: PUSH
20876: LD_INT 9
20878: PUSH
20879: EMPTY
20880: LIST
20881: LIST
20882: LIST
20883: PUSH
20884: LD_VAR 0 17
20888: ARRAY
20889: PPUSH
20890: LD_VAR 0 4
20894: PPUSH
20895: CALL_OW 380
20899: GO 20918
// PrepareHuman ( false , i , skill ) ;
20901: LD_INT 0
20903: PPUSH
20904: LD_VAR 0 8
20908: PPUSH
20909: LD_VAR 0 4
20913: PPUSH
20914: CALL_OW 380
// end else
20918: GO 20937
// PrepareHuman ( false , i , skill ) ;
20920: LD_INT 0
20922: PPUSH
20923: LD_VAR 0 8
20927: PPUSH
20928: LD_VAR 0 4
20932: PPUSH
20933: CALL_OW 380
// un := CreateHuman ;
20937: LD_ADDR_VAR 0 14
20941: PUSH
20942: CALL_OW 44
20946: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20947: LD_ADDR_VAR 0 7
20951: PUSH
20952: LD_VAR 0 7
20956: PPUSH
20957: LD_INT 1
20959: PPUSH
20960: LD_VAR 0 14
20964: PPUSH
20965: CALL_OW 2
20969: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20970: LD_VAR 0 14
20974: PPUSH
20975: LD_VAR 0 12
20979: PUSH
20980: LD_INT 1
20982: ARRAY
20983: PPUSH
20984: CALL_OW 52
// end ;
20988: GO 20627
20990: POP
20991: POP
// end ;
20992: GO 19929
20994: POP
20995: POP
// result := result ^ buildings ;
20996: LD_ADDR_VAR 0 7
21000: PUSH
21001: LD_VAR 0 7
21005: PUSH
21006: LD_VAR 0 18
21010: ADD
21011: ST_TO_ADDR
// end else
21012: GO 21155
// begin for i = 1 to personel do
21014: LD_ADDR_VAR 0 8
21018: PUSH
21019: DOUBLE
21020: LD_INT 1
21022: DEC
21023: ST_TO_ADDR
21024: LD_VAR 0 6
21028: PUSH
21029: FOR_TO
21030: IFFALSE 21153
// begin if i > 4 then
21032: LD_VAR 0 8
21036: PUSH
21037: LD_INT 4
21039: GREATER
21040: IFFALSE 21044
// break ;
21042: GO 21153
// x := personel [ i ] ;
21044: LD_ADDR_VAR 0 13
21048: PUSH
21049: LD_VAR 0 6
21053: PUSH
21054: LD_VAR 0 8
21058: ARRAY
21059: ST_TO_ADDR
// if x = - 1 then
21060: LD_VAR 0 13
21064: PUSH
21065: LD_INT 1
21067: NEG
21068: EQUAL
21069: IFFALSE 21073
// continue ;
21071: GO 21029
// PrepareHuman ( false , i , skill ) ;
21073: LD_INT 0
21075: PPUSH
21076: LD_VAR 0 8
21080: PPUSH
21081: LD_VAR 0 4
21085: PPUSH
21086: CALL_OW 380
// un := CreateHuman ;
21090: LD_ADDR_VAR 0 14
21094: PUSH
21095: CALL_OW 44
21099: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21100: LD_VAR 0 14
21104: PPUSH
21105: LD_VAR 0 1
21109: PPUSH
21110: CALL_OW 250
21114: PPUSH
21115: LD_VAR 0 1
21119: PPUSH
21120: CALL_OW 251
21124: PPUSH
21125: LD_INT 10
21127: PPUSH
21128: LD_INT 0
21130: PPUSH
21131: CALL_OW 50
// result := result ^ un ;
21135: LD_ADDR_VAR 0 7
21139: PUSH
21140: LD_VAR 0 7
21144: PUSH
21145: LD_VAR 0 14
21149: ADD
21150: ST_TO_ADDR
// end ;
21151: GO 21029
21153: POP
21154: POP
// end ; end ;
21155: LD_VAR 0 7
21159: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21160: LD_INT 0
21162: PPUSH
21163: PPUSH
21164: PPUSH
21165: PPUSH
21166: PPUSH
21167: PPUSH
21168: PPUSH
21169: PPUSH
21170: PPUSH
21171: PPUSH
21172: PPUSH
21173: PPUSH
21174: PPUSH
21175: PPUSH
21176: PPUSH
21177: PPUSH
// result := false ;
21178: LD_ADDR_VAR 0 3
21182: PUSH
21183: LD_INT 0
21185: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21186: LD_VAR 0 1
21190: NOT
21191: PUSH
21192: LD_VAR 0 1
21196: PPUSH
21197: CALL_OW 266
21201: PUSH
21202: LD_INT 32
21204: PUSH
21205: LD_INT 33
21207: PUSH
21208: EMPTY
21209: LIST
21210: LIST
21211: IN
21212: NOT
21213: OR
21214: IFFALSE 21218
// exit ;
21216: GO 22327
// nat := GetNation ( tower ) ;
21218: LD_ADDR_VAR 0 12
21222: PUSH
21223: LD_VAR 0 1
21227: PPUSH
21228: CALL_OW 248
21232: ST_TO_ADDR
// side := GetSide ( tower ) ;
21233: LD_ADDR_VAR 0 16
21237: PUSH
21238: LD_VAR 0 1
21242: PPUSH
21243: CALL_OW 255
21247: ST_TO_ADDR
// x := GetX ( tower ) ;
21248: LD_ADDR_VAR 0 10
21252: PUSH
21253: LD_VAR 0 1
21257: PPUSH
21258: CALL_OW 250
21262: ST_TO_ADDR
// y := GetY ( tower ) ;
21263: LD_ADDR_VAR 0 11
21267: PUSH
21268: LD_VAR 0 1
21272: PPUSH
21273: CALL_OW 251
21277: ST_TO_ADDR
// if not x or not y then
21278: LD_VAR 0 10
21282: NOT
21283: PUSH
21284: LD_VAR 0 11
21288: NOT
21289: OR
21290: IFFALSE 21294
// exit ;
21292: GO 22327
// weapon := 0 ;
21294: LD_ADDR_VAR 0 18
21298: PUSH
21299: LD_INT 0
21301: ST_TO_ADDR
// fac_list := [ ] ;
21302: LD_ADDR_VAR 0 17
21306: PUSH
21307: EMPTY
21308: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21309: LD_ADDR_VAR 0 6
21313: PUSH
21314: LD_VAR 0 1
21318: PPUSH
21319: CALL_OW 274
21323: PPUSH
21324: LD_VAR 0 2
21328: PPUSH
21329: LD_INT 0
21331: PPUSH
21332: CALL 18898 0 3
21336: PPUSH
21337: LD_INT 30
21339: PUSH
21340: LD_INT 3
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: PPUSH
21347: CALL_OW 72
21351: ST_TO_ADDR
// if not factories then
21352: LD_VAR 0 6
21356: NOT
21357: IFFALSE 21361
// exit ;
21359: GO 22327
// for i in factories do
21361: LD_ADDR_VAR 0 8
21365: PUSH
21366: LD_VAR 0 6
21370: PUSH
21371: FOR_IN
21372: IFFALSE 21397
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21374: LD_ADDR_VAR 0 17
21378: PUSH
21379: LD_VAR 0 17
21383: PUSH
21384: LD_VAR 0 8
21388: PPUSH
21389: CALL_OW 478
21393: UNION
21394: ST_TO_ADDR
21395: GO 21371
21397: POP
21398: POP
// if not fac_list then
21399: LD_VAR 0 17
21403: NOT
21404: IFFALSE 21408
// exit ;
21406: GO 22327
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21408: LD_ADDR_VAR 0 5
21412: PUSH
21413: LD_INT 4
21415: PUSH
21416: LD_INT 5
21418: PUSH
21419: LD_INT 9
21421: PUSH
21422: LD_INT 10
21424: PUSH
21425: LD_INT 6
21427: PUSH
21428: LD_INT 7
21430: PUSH
21431: LD_INT 11
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: LIST
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: PUSH
21443: LD_INT 27
21445: PUSH
21446: LD_INT 28
21448: PUSH
21449: LD_INT 26
21451: PUSH
21452: LD_INT 30
21454: PUSH
21455: EMPTY
21456: LIST
21457: LIST
21458: LIST
21459: LIST
21460: PUSH
21461: LD_INT 43
21463: PUSH
21464: LD_INT 44
21466: PUSH
21467: LD_INT 46
21469: PUSH
21470: LD_INT 45
21472: PUSH
21473: LD_INT 47
21475: PUSH
21476: LD_INT 49
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: LIST
21483: LIST
21484: LIST
21485: LIST
21486: PUSH
21487: EMPTY
21488: LIST
21489: LIST
21490: LIST
21491: PUSH
21492: LD_VAR 0 12
21496: ARRAY
21497: ST_TO_ADDR
// list := list isect fac_list ;
21498: LD_ADDR_VAR 0 5
21502: PUSH
21503: LD_VAR 0 5
21507: PUSH
21508: LD_VAR 0 17
21512: ISECT
21513: ST_TO_ADDR
// if not list then
21514: LD_VAR 0 5
21518: NOT
21519: IFFALSE 21523
// exit ;
21521: GO 22327
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21523: LD_VAR 0 12
21527: PUSH
21528: LD_INT 3
21530: EQUAL
21531: PUSH
21532: LD_INT 49
21534: PUSH
21535: LD_VAR 0 5
21539: IN
21540: AND
21541: PUSH
21542: LD_INT 31
21544: PPUSH
21545: LD_VAR 0 16
21549: PPUSH
21550: CALL_OW 321
21554: PUSH
21555: LD_INT 2
21557: EQUAL
21558: AND
21559: IFFALSE 21619
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21561: LD_INT 22
21563: PUSH
21564: LD_VAR 0 16
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: PUSH
21573: LD_INT 35
21575: PUSH
21576: LD_INT 49
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: PUSH
21583: LD_INT 91
21585: PUSH
21586: LD_VAR 0 1
21590: PUSH
21591: LD_INT 10
21593: PUSH
21594: EMPTY
21595: LIST
21596: LIST
21597: LIST
21598: PUSH
21599: EMPTY
21600: LIST
21601: LIST
21602: LIST
21603: PPUSH
21604: CALL_OW 69
21608: NOT
21609: IFFALSE 21619
// weapon := ru_time_lapser ;
21611: LD_ADDR_VAR 0 18
21615: PUSH
21616: LD_INT 49
21618: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21619: LD_VAR 0 12
21623: PUSH
21624: LD_INT 1
21626: PUSH
21627: LD_INT 2
21629: PUSH
21630: EMPTY
21631: LIST
21632: LIST
21633: IN
21634: PUSH
21635: LD_INT 11
21637: PUSH
21638: LD_VAR 0 5
21642: IN
21643: PUSH
21644: LD_INT 30
21646: PUSH
21647: LD_VAR 0 5
21651: IN
21652: OR
21653: AND
21654: PUSH
21655: LD_INT 6
21657: PPUSH
21658: LD_VAR 0 16
21662: PPUSH
21663: CALL_OW 321
21667: PUSH
21668: LD_INT 2
21670: EQUAL
21671: AND
21672: IFFALSE 21837
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21674: LD_INT 22
21676: PUSH
21677: LD_VAR 0 16
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: PUSH
21686: LD_INT 2
21688: PUSH
21689: LD_INT 35
21691: PUSH
21692: LD_INT 11
21694: PUSH
21695: EMPTY
21696: LIST
21697: LIST
21698: PUSH
21699: LD_INT 35
21701: PUSH
21702: LD_INT 30
21704: PUSH
21705: EMPTY
21706: LIST
21707: LIST
21708: PUSH
21709: EMPTY
21710: LIST
21711: LIST
21712: LIST
21713: PUSH
21714: LD_INT 91
21716: PUSH
21717: LD_VAR 0 1
21721: PUSH
21722: LD_INT 18
21724: PUSH
21725: EMPTY
21726: LIST
21727: LIST
21728: LIST
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: LIST
21734: PPUSH
21735: CALL_OW 69
21739: NOT
21740: PUSH
21741: LD_INT 22
21743: PUSH
21744: LD_VAR 0 16
21748: PUSH
21749: EMPTY
21750: LIST
21751: LIST
21752: PUSH
21753: LD_INT 2
21755: PUSH
21756: LD_INT 30
21758: PUSH
21759: LD_INT 32
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: LD_INT 30
21768: PUSH
21769: LD_INT 33
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 91
21783: PUSH
21784: LD_VAR 0 1
21788: PUSH
21789: LD_INT 12
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: PUSH
21797: EMPTY
21798: LIST
21799: LIST
21800: LIST
21801: PUSH
21802: EMPTY
21803: LIST
21804: PPUSH
21805: CALL_OW 69
21809: PUSH
21810: LD_INT 2
21812: GREATER
21813: AND
21814: IFFALSE 21837
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21816: LD_ADDR_VAR 0 18
21820: PUSH
21821: LD_INT 11
21823: PUSH
21824: LD_INT 30
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: LD_VAR 0 12
21835: ARRAY
21836: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21837: LD_VAR 0 18
21841: NOT
21842: PUSH
21843: LD_INT 40
21845: PPUSH
21846: LD_VAR 0 16
21850: PPUSH
21851: CALL_OW 321
21855: PUSH
21856: LD_INT 2
21858: EQUAL
21859: AND
21860: PUSH
21861: LD_INT 7
21863: PUSH
21864: LD_VAR 0 5
21868: IN
21869: PUSH
21870: LD_INT 28
21872: PUSH
21873: LD_VAR 0 5
21877: IN
21878: OR
21879: PUSH
21880: LD_INT 45
21882: PUSH
21883: LD_VAR 0 5
21887: IN
21888: OR
21889: AND
21890: IFFALSE 22144
// begin hex := GetHexInfo ( x , y ) ;
21892: LD_ADDR_VAR 0 4
21896: PUSH
21897: LD_VAR 0 10
21901: PPUSH
21902: LD_VAR 0 11
21906: PPUSH
21907: CALL_OW 546
21911: ST_TO_ADDR
// if hex [ 1 ] then
21912: LD_VAR 0 4
21916: PUSH
21917: LD_INT 1
21919: ARRAY
21920: IFFALSE 21924
// exit ;
21922: GO 22327
// height := hex [ 2 ] ;
21924: LD_ADDR_VAR 0 15
21928: PUSH
21929: LD_VAR 0 4
21933: PUSH
21934: LD_INT 2
21936: ARRAY
21937: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21938: LD_ADDR_VAR 0 14
21942: PUSH
21943: LD_INT 0
21945: PUSH
21946: LD_INT 2
21948: PUSH
21949: LD_INT 3
21951: PUSH
21952: LD_INT 5
21954: PUSH
21955: EMPTY
21956: LIST
21957: LIST
21958: LIST
21959: LIST
21960: ST_TO_ADDR
// for i in tmp do
21961: LD_ADDR_VAR 0 8
21965: PUSH
21966: LD_VAR 0 14
21970: PUSH
21971: FOR_IN
21972: IFFALSE 22142
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21974: LD_ADDR_VAR 0 9
21978: PUSH
21979: LD_VAR 0 10
21983: PPUSH
21984: LD_VAR 0 8
21988: PPUSH
21989: LD_INT 5
21991: PPUSH
21992: CALL_OW 272
21996: PUSH
21997: LD_VAR 0 11
22001: PPUSH
22002: LD_VAR 0 8
22006: PPUSH
22007: LD_INT 5
22009: PPUSH
22010: CALL_OW 273
22014: PUSH
22015: EMPTY
22016: LIST
22017: LIST
22018: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22019: LD_VAR 0 9
22023: PUSH
22024: LD_INT 1
22026: ARRAY
22027: PPUSH
22028: LD_VAR 0 9
22032: PUSH
22033: LD_INT 2
22035: ARRAY
22036: PPUSH
22037: CALL_OW 488
22041: IFFALSE 22140
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22043: LD_ADDR_VAR 0 4
22047: PUSH
22048: LD_VAR 0 9
22052: PUSH
22053: LD_INT 1
22055: ARRAY
22056: PPUSH
22057: LD_VAR 0 9
22061: PUSH
22062: LD_INT 2
22064: ARRAY
22065: PPUSH
22066: CALL_OW 546
22070: ST_TO_ADDR
// if hex [ 1 ] then
22071: LD_VAR 0 4
22075: PUSH
22076: LD_INT 1
22078: ARRAY
22079: IFFALSE 22083
// continue ;
22081: GO 21971
// h := hex [ 2 ] ;
22083: LD_ADDR_VAR 0 13
22087: PUSH
22088: LD_VAR 0 4
22092: PUSH
22093: LD_INT 2
22095: ARRAY
22096: ST_TO_ADDR
// if h + 7 < height then
22097: LD_VAR 0 13
22101: PUSH
22102: LD_INT 7
22104: PLUS
22105: PUSH
22106: LD_VAR 0 15
22110: LESS
22111: IFFALSE 22140
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22113: LD_ADDR_VAR 0 18
22117: PUSH
22118: LD_INT 7
22120: PUSH
22121: LD_INT 28
22123: PUSH
22124: LD_INT 45
22126: PUSH
22127: EMPTY
22128: LIST
22129: LIST
22130: LIST
22131: PUSH
22132: LD_VAR 0 12
22136: ARRAY
22137: ST_TO_ADDR
// break ;
22138: GO 22142
// end ; end ; end ;
22140: GO 21971
22142: POP
22143: POP
// end ; if not weapon then
22144: LD_VAR 0 18
22148: NOT
22149: IFFALSE 22209
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22151: LD_ADDR_VAR 0 5
22155: PUSH
22156: LD_VAR 0 5
22160: PUSH
22161: LD_INT 11
22163: PUSH
22164: LD_INT 30
22166: PUSH
22167: LD_INT 49
22169: PUSH
22170: EMPTY
22171: LIST
22172: LIST
22173: LIST
22174: DIFF
22175: ST_TO_ADDR
// if not list then
22176: LD_VAR 0 5
22180: NOT
22181: IFFALSE 22185
// exit ;
22183: GO 22327
// weapon := list [ rand ( 1 , list ) ] ;
22185: LD_ADDR_VAR 0 18
22189: PUSH
22190: LD_VAR 0 5
22194: PUSH
22195: LD_INT 1
22197: PPUSH
22198: LD_VAR 0 5
22202: PPUSH
22203: CALL_OW 12
22207: ARRAY
22208: ST_TO_ADDR
// end ; if weapon then
22209: LD_VAR 0 18
22213: IFFALSE 22327
// begin tmp := CostOfWeapon ( weapon ) ;
22215: LD_ADDR_VAR 0 14
22219: PUSH
22220: LD_VAR 0 18
22224: PPUSH
22225: CALL_OW 451
22229: ST_TO_ADDR
// j := GetBase ( tower ) ;
22230: LD_ADDR_VAR 0 9
22234: PUSH
22235: LD_VAR 0 1
22239: PPUSH
22240: CALL_OW 274
22244: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22245: LD_VAR 0 9
22249: PPUSH
22250: LD_INT 1
22252: PPUSH
22253: CALL_OW 275
22257: PUSH
22258: LD_VAR 0 14
22262: PUSH
22263: LD_INT 1
22265: ARRAY
22266: GREATEREQUAL
22267: PUSH
22268: LD_VAR 0 9
22272: PPUSH
22273: LD_INT 2
22275: PPUSH
22276: CALL_OW 275
22280: PUSH
22281: LD_VAR 0 14
22285: PUSH
22286: LD_INT 2
22288: ARRAY
22289: GREATEREQUAL
22290: AND
22291: PUSH
22292: LD_VAR 0 9
22296: PPUSH
22297: LD_INT 3
22299: PPUSH
22300: CALL_OW 275
22304: PUSH
22305: LD_VAR 0 14
22309: PUSH
22310: LD_INT 3
22312: ARRAY
22313: GREATEREQUAL
22314: AND
22315: IFFALSE 22327
// result := weapon ;
22317: LD_ADDR_VAR 0 3
22321: PUSH
22322: LD_VAR 0 18
22326: ST_TO_ADDR
// end ; end ;
22327: LD_VAR 0 3
22331: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22332: LD_INT 0
22334: PPUSH
22335: PPUSH
// result := true ;
22336: LD_ADDR_VAR 0 3
22340: PUSH
22341: LD_INT 1
22343: ST_TO_ADDR
// if array1 = array2 then
22344: LD_VAR 0 1
22348: PUSH
22349: LD_VAR 0 2
22353: EQUAL
22354: IFFALSE 22414
// begin for i = 1 to array1 do
22356: LD_ADDR_VAR 0 4
22360: PUSH
22361: DOUBLE
22362: LD_INT 1
22364: DEC
22365: ST_TO_ADDR
22366: LD_VAR 0 1
22370: PUSH
22371: FOR_TO
22372: IFFALSE 22410
// if array1 [ i ] <> array2 [ i ] then
22374: LD_VAR 0 1
22378: PUSH
22379: LD_VAR 0 4
22383: ARRAY
22384: PUSH
22385: LD_VAR 0 2
22389: PUSH
22390: LD_VAR 0 4
22394: ARRAY
22395: NONEQUAL
22396: IFFALSE 22408
// begin result := false ;
22398: LD_ADDR_VAR 0 3
22402: PUSH
22403: LD_INT 0
22405: ST_TO_ADDR
// break ;
22406: GO 22410
// end ;
22408: GO 22371
22410: POP
22411: POP
// end else
22412: GO 22422
// result := false ;
22414: LD_ADDR_VAR 0 3
22418: PUSH
22419: LD_INT 0
22421: ST_TO_ADDR
// end ;
22422: LD_VAR 0 3
22426: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22427: LD_INT 0
22429: PPUSH
22430: PPUSH
// if not array1 or not array2 then
22431: LD_VAR 0 1
22435: NOT
22436: PUSH
22437: LD_VAR 0 2
22441: NOT
22442: OR
22443: IFFALSE 22447
// exit ;
22445: GO 22511
// result := true ;
22447: LD_ADDR_VAR 0 3
22451: PUSH
22452: LD_INT 1
22454: ST_TO_ADDR
// for i = 1 to array1 do
22455: LD_ADDR_VAR 0 4
22459: PUSH
22460: DOUBLE
22461: LD_INT 1
22463: DEC
22464: ST_TO_ADDR
22465: LD_VAR 0 1
22469: PUSH
22470: FOR_TO
22471: IFFALSE 22509
// if array1 [ i ] <> array2 [ i ] then
22473: LD_VAR 0 1
22477: PUSH
22478: LD_VAR 0 4
22482: ARRAY
22483: PUSH
22484: LD_VAR 0 2
22488: PUSH
22489: LD_VAR 0 4
22493: ARRAY
22494: NONEQUAL
22495: IFFALSE 22507
// begin result := false ;
22497: LD_ADDR_VAR 0 3
22501: PUSH
22502: LD_INT 0
22504: ST_TO_ADDR
// break ;
22505: GO 22509
// end ;
22507: GO 22470
22509: POP
22510: POP
// end ;
22511: LD_VAR 0 3
22515: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22516: LD_INT 0
22518: PPUSH
22519: PPUSH
22520: PPUSH
// pom := GetBase ( fac ) ;
22521: LD_ADDR_VAR 0 5
22525: PUSH
22526: LD_VAR 0 1
22530: PPUSH
22531: CALL_OW 274
22535: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22536: LD_ADDR_VAR 0 4
22540: PUSH
22541: LD_VAR 0 2
22545: PUSH
22546: LD_INT 1
22548: ARRAY
22549: PPUSH
22550: LD_VAR 0 2
22554: PUSH
22555: LD_INT 2
22557: ARRAY
22558: PPUSH
22559: LD_VAR 0 2
22563: PUSH
22564: LD_INT 3
22566: ARRAY
22567: PPUSH
22568: LD_VAR 0 2
22572: PUSH
22573: LD_INT 4
22575: ARRAY
22576: PPUSH
22577: CALL_OW 449
22581: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22582: LD_ADDR_VAR 0 3
22586: PUSH
22587: LD_VAR 0 5
22591: PPUSH
22592: LD_INT 1
22594: PPUSH
22595: CALL_OW 275
22599: PUSH
22600: LD_VAR 0 4
22604: PUSH
22605: LD_INT 1
22607: ARRAY
22608: GREATEREQUAL
22609: PUSH
22610: LD_VAR 0 5
22614: PPUSH
22615: LD_INT 2
22617: PPUSH
22618: CALL_OW 275
22622: PUSH
22623: LD_VAR 0 4
22627: PUSH
22628: LD_INT 2
22630: ARRAY
22631: GREATEREQUAL
22632: AND
22633: PUSH
22634: LD_VAR 0 5
22638: PPUSH
22639: LD_INT 3
22641: PPUSH
22642: CALL_OW 275
22646: PUSH
22647: LD_VAR 0 4
22651: PUSH
22652: LD_INT 3
22654: ARRAY
22655: GREATEREQUAL
22656: AND
22657: ST_TO_ADDR
// end ;
22658: LD_VAR 0 3
22662: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22663: LD_INT 0
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
// pom := GetBase ( building ) ;
22669: LD_ADDR_VAR 0 3
22673: PUSH
22674: LD_VAR 0 1
22678: PPUSH
22679: CALL_OW 274
22683: ST_TO_ADDR
// if not pom then
22684: LD_VAR 0 3
22688: NOT
22689: IFFALSE 22693
// exit ;
22691: GO 22863
// btype := GetBType ( building ) ;
22693: LD_ADDR_VAR 0 5
22697: PUSH
22698: LD_VAR 0 1
22702: PPUSH
22703: CALL_OW 266
22707: ST_TO_ADDR
// if btype = b_armoury then
22708: LD_VAR 0 5
22712: PUSH
22713: LD_INT 4
22715: EQUAL
22716: IFFALSE 22726
// btype := b_barracks ;
22718: LD_ADDR_VAR 0 5
22722: PUSH
22723: LD_INT 5
22725: ST_TO_ADDR
// if btype = b_depot then
22726: LD_VAR 0 5
22730: PUSH
22731: LD_INT 0
22733: EQUAL
22734: IFFALSE 22744
// btype := b_warehouse ;
22736: LD_ADDR_VAR 0 5
22740: PUSH
22741: LD_INT 1
22743: ST_TO_ADDR
// if btype = b_workshop then
22744: LD_VAR 0 5
22748: PUSH
22749: LD_INT 2
22751: EQUAL
22752: IFFALSE 22762
// btype := b_factory ;
22754: LD_ADDR_VAR 0 5
22758: PUSH
22759: LD_INT 3
22761: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22762: LD_ADDR_VAR 0 4
22766: PUSH
22767: LD_VAR 0 5
22771: PPUSH
22772: LD_VAR 0 1
22776: PPUSH
22777: CALL_OW 248
22781: PPUSH
22782: CALL_OW 450
22786: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22787: LD_ADDR_VAR 0 2
22791: PUSH
22792: LD_VAR 0 3
22796: PPUSH
22797: LD_INT 1
22799: PPUSH
22800: CALL_OW 275
22804: PUSH
22805: LD_VAR 0 4
22809: PUSH
22810: LD_INT 1
22812: ARRAY
22813: GREATEREQUAL
22814: PUSH
22815: LD_VAR 0 3
22819: PPUSH
22820: LD_INT 2
22822: PPUSH
22823: CALL_OW 275
22827: PUSH
22828: LD_VAR 0 4
22832: PUSH
22833: LD_INT 2
22835: ARRAY
22836: GREATEREQUAL
22837: AND
22838: PUSH
22839: LD_VAR 0 3
22843: PPUSH
22844: LD_INT 3
22846: PPUSH
22847: CALL_OW 275
22851: PUSH
22852: LD_VAR 0 4
22856: PUSH
22857: LD_INT 3
22859: ARRAY
22860: GREATEREQUAL
22861: AND
22862: ST_TO_ADDR
// end ;
22863: LD_VAR 0 2
22867: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22868: LD_INT 0
22870: PPUSH
22871: PPUSH
22872: PPUSH
// pom := GetBase ( building ) ;
22873: LD_ADDR_VAR 0 4
22877: PUSH
22878: LD_VAR 0 1
22882: PPUSH
22883: CALL_OW 274
22887: ST_TO_ADDR
// if not pom then
22888: LD_VAR 0 4
22892: NOT
22893: IFFALSE 22897
// exit ;
22895: GO 22998
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22897: LD_ADDR_VAR 0 5
22901: PUSH
22902: LD_VAR 0 2
22906: PPUSH
22907: LD_VAR 0 1
22911: PPUSH
22912: CALL_OW 248
22916: PPUSH
22917: CALL_OW 450
22921: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22922: LD_ADDR_VAR 0 3
22926: PUSH
22927: LD_VAR 0 4
22931: PPUSH
22932: LD_INT 1
22934: PPUSH
22935: CALL_OW 275
22939: PUSH
22940: LD_VAR 0 5
22944: PUSH
22945: LD_INT 1
22947: ARRAY
22948: GREATEREQUAL
22949: PUSH
22950: LD_VAR 0 4
22954: PPUSH
22955: LD_INT 2
22957: PPUSH
22958: CALL_OW 275
22962: PUSH
22963: LD_VAR 0 5
22967: PUSH
22968: LD_INT 2
22970: ARRAY
22971: GREATEREQUAL
22972: AND
22973: PUSH
22974: LD_VAR 0 4
22978: PPUSH
22979: LD_INT 3
22981: PPUSH
22982: CALL_OW 275
22986: PUSH
22987: LD_VAR 0 5
22991: PUSH
22992: LD_INT 3
22994: ARRAY
22995: GREATEREQUAL
22996: AND
22997: ST_TO_ADDR
// end ;
22998: LD_VAR 0 3
23002: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23003: LD_INT 0
23005: PPUSH
23006: PPUSH
23007: PPUSH
23008: PPUSH
23009: PPUSH
23010: PPUSH
23011: PPUSH
23012: PPUSH
23013: PPUSH
23014: PPUSH
23015: PPUSH
// result := false ;
23016: LD_ADDR_VAR 0 8
23020: PUSH
23021: LD_INT 0
23023: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23024: LD_VAR 0 5
23028: NOT
23029: PUSH
23030: LD_VAR 0 1
23034: NOT
23035: OR
23036: PUSH
23037: LD_VAR 0 2
23041: NOT
23042: OR
23043: PUSH
23044: LD_VAR 0 3
23048: NOT
23049: OR
23050: IFFALSE 23054
// exit ;
23052: GO 23868
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23054: LD_ADDR_VAR 0 14
23058: PUSH
23059: LD_VAR 0 1
23063: PPUSH
23064: LD_VAR 0 2
23068: PPUSH
23069: LD_VAR 0 3
23073: PPUSH
23074: LD_VAR 0 4
23078: PPUSH
23079: LD_VAR 0 5
23083: PUSH
23084: LD_INT 1
23086: ARRAY
23087: PPUSH
23088: CALL_OW 248
23092: PPUSH
23093: LD_INT 0
23095: PPUSH
23096: CALL 25101 0 6
23100: ST_TO_ADDR
// if not hexes then
23101: LD_VAR 0 14
23105: NOT
23106: IFFALSE 23110
// exit ;
23108: GO 23868
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23110: LD_ADDR_VAR 0 17
23114: PUSH
23115: LD_VAR 0 5
23119: PPUSH
23120: LD_INT 22
23122: PUSH
23123: LD_VAR 0 13
23127: PPUSH
23128: CALL_OW 255
23132: PUSH
23133: EMPTY
23134: LIST
23135: LIST
23136: PUSH
23137: LD_INT 2
23139: PUSH
23140: LD_INT 30
23142: PUSH
23143: LD_INT 0
23145: PUSH
23146: EMPTY
23147: LIST
23148: LIST
23149: PUSH
23150: LD_INT 30
23152: PUSH
23153: LD_INT 1
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: LIST
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: PPUSH
23169: CALL_OW 72
23173: ST_TO_ADDR
// for i = 1 to hexes do
23174: LD_ADDR_VAR 0 9
23178: PUSH
23179: DOUBLE
23180: LD_INT 1
23182: DEC
23183: ST_TO_ADDR
23184: LD_VAR 0 14
23188: PUSH
23189: FOR_TO
23190: IFFALSE 23866
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23192: LD_ADDR_VAR 0 13
23196: PUSH
23197: LD_VAR 0 14
23201: PUSH
23202: LD_VAR 0 9
23206: ARRAY
23207: PUSH
23208: LD_INT 1
23210: ARRAY
23211: PPUSH
23212: LD_VAR 0 14
23216: PUSH
23217: LD_VAR 0 9
23221: ARRAY
23222: PUSH
23223: LD_INT 2
23225: ARRAY
23226: PPUSH
23227: CALL_OW 428
23231: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23232: LD_VAR 0 14
23236: PUSH
23237: LD_VAR 0 9
23241: ARRAY
23242: PUSH
23243: LD_INT 1
23245: ARRAY
23246: PPUSH
23247: LD_VAR 0 14
23251: PUSH
23252: LD_VAR 0 9
23256: ARRAY
23257: PUSH
23258: LD_INT 2
23260: ARRAY
23261: PPUSH
23262: CALL_OW 351
23266: PUSH
23267: LD_VAR 0 14
23271: PUSH
23272: LD_VAR 0 9
23276: ARRAY
23277: PUSH
23278: LD_INT 1
23280: ARRAY
23281: PPUSH
23282: LD_VAR 0 14
23286: PUSH
23287: LD_VAR 0 9
23291: ARRAY
23292: PUSH
23293: LD_INT 2
23295: ARRAY
23296: PPUSH
23297: CALL_OW 488
23301: NOT
23302: OR
23303: PUSH
23304: LD_VAR 0 13
23308: PPUSH
23309: CALL_OW 247
23313: PUSH
23314: LD_INT 3
23316: EQUAL
23317: OR
23318: IFFALSE 23324
// exit ;
23320: POP
23321: POP
23322: GO 23868
// if not tmp then
23324: LD_VAR 0 13
23328: NOT
23329: IFFALSE 23333
// continue ;
23331: GO 23189
// result := true ;
23333: LD_ADDR_VAR 0 8
23337: PUSH
23338: LD_INT 1
23340: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23341: LD_VAR 0 6
23345: PUSH
23346: LD_VAR 0 13
23350: PPUSH
23351: CALL_OW 247
23355: PUSH
23356: LD_INT 2
23358: EQUAL
23359: AND
23360: PUSH
23361: LD_VAR 0 13
23365: PPUSH
23366: CALL_OW 263
23370: PUSH
23371: LD_INT 1
23373: EQUAL
23374: AND
23375: IFFALSE 23539
// begin if IsDrivenBy ( tmp ) then
23377: LD_VAR 0 13
23381: PPUSH
23382: CALL_OW 311
23386: IFFALSE 23390
// continue ;
23388: GO 23189
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23390: LD_VAR 0 6
23394: PPUSH
23395: LD_INT 3
23397: PUSH
23398: LD_INT 60
23400: PUSH
23401: EMPTY
23402: LIST
23403: PUSH
23404: EMPTY
23405: LIST
23406: LIST
23407: PUSH
23408: LD_INT 3
23410: PUSH
23411: LD_INT 55
23413: PUSH
23414: EMPTY
23415: LIST
23416: PUSH
23417: EMPTY
23418: LIST
23419: LIST
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PPUSH
23425: CALL_OW 72
23429: IFFALSE 23537
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23431: LD_ADDR_VAR 0 18
23435: PUSH
23436: LD_VAR 0 6
23440: PPUSH
23441: LD_INT 3
23443: PUSH
23444: LD_INT 60
23446: PUSH
23447: EMPTY
23448: LIST
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 3
23456: PUSH
23457: LD_INT 55
23459: PUSH
23460: EMPTY
23461: LIST
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 72
23475: PUSH
23476: LD_INT 1
23478: ARRAY
23479: ST_TO_ADDR
// if IsInUnit ( driver ) then
23480: LD_VAR 0 18
23484: PPUSH
23485: CALL_OW 310
23489: IFFALSE 23500
// ComExit ( driver ) ;
23491: LD_VAR 0 18
23495: PPUSH
23496: CALL 48862 0 1
// AddComEnterUnit ( driver , tmp ) ;
23500: LD_VAR 0 18
23504: PPUSH
23505: LD_VAR 0 13
23509: PPUSH
23510: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23514: LD_VAR 0 18
23518: PPUSH
23519: LD_VAR 0 7
23523: PPUSH
23524: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23528: LD_VAR 0 18
23532: PPUSH
23533: CALL_OW 181
// end ; continue ;
23537: GO 23189
// end ; if not cleaners or not tmp in cleaners then
23539: LD_VAR 0 6
23543: NOT
23544: PUSH
23545: LD_VAR 0 13
23549: PUSH
23550: LD_VAR 0 6
23554: IN
23555: NOT
23556: OR
23557: IFFALSE 23864
// begin if dep then
23559: LD_VAR 0 17
23563: IFFALSE 23699
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23565: LD_ADDR_VAR 0 16
23569: PUSH
23570: LD_VAR 0 17
23574: PUSH
23575: LD_INT 1
23577: ARRAY
23578: PPUSH
23579: CALL_OW 250
23583: PPUSH
23584: LD_VAR 0 17
23588: PUSH
23589: LD_INT 1
23591: ARRAY
23592: PPUSH
23593: CALL_OW 254
23597: PPUSH
23598: LD_INT 5
23600: PPUSH
23601: CALL_OW 272
23605: PUSH
23606: LD_VAR 0 17
23610: PUSH
23611: LD_INT 1
23613: ARRAY
23614: PPUSH
23615: CALL_OW 251
23619: PPUSH
23620: LD_VAR 0 17
23624: PUSH
23625: LD_INT 1
23627: ARRAY
23628: PPUSH
23629: CALL_OW 254
23633: PPUSH
23634: LD_INT 5
23636: PPUSH
23637: CALL_OW 273
23641: PUSH
23642: EMPTY
23643: LIST
23644: LIST
23645: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23646: LD_VAR 0 16
23650: PUSH
23651: LD_INT 1
23653: ARRAY
23654: PPUSH
23655: LD_VAR 0 16
23659: PUSH
23660: LD_INT 2
23662: ARRAY
23663: PPUSH
23664: CALL_OW 488
23668: IFFALSE 23699
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23670: LD_VAR 0 13
23674: PPUSH
23675: LD_VAR 0 16
23679: PUSH
23680: LD_INT 1
23682: ARRAY
23683: PPUSH
23684: LD_VAR 0 16
23688: PUSH
23689: LD_INT 2
23691: ARRAY
23692: PPUSH
23693: CALL_OW 111
// continue ;
23697: GO 23189
// end ; end ; r := GetDir ( tmp ) ;
23699: LD_ADDR_VAR 0 15
23703: PUSH
23704: LD_VAR 0 13
23708: PPUSH
23709: CALL_OW 254
23713: ST_TO_ADDR
// if r = 5 then
23714: LD_VAR 0 15
23718: PUSH
23719: LD_INT 5
23721: EQUAL
23722: IFFALSE 23732
// r := 0 ;
23724: LD_ADDR_VAR 0 15
23728: PUSH
23729: LD_INT 0
23731: ST_TO_ADDR
// for j = r to 5 do
23732: LD_ADDR_VAR 0 10
23736: PUSH
23737: DOUBLE
23738: LD_VAR 0 15
23742: DEC
23743: ST_TO_ADDR
23744: LD_INT 5
23746: PUSH
23747: FOR_TO
23748: IFFALSE 23862
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23750: LD_ADDR_VAR 0 11
23754: PUSH
23755: LD_VAR 0 13
23759: PPUSH
23760: CALL_OW 250
23764: PPUSH
23765: LD_VAR 0 10
23769: PPUSH
23770: LD_INT 2
23772: PPUSH
23773: CALL_OW 272
23777: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23778: LD_ADDR_VAR 0 12
23782: PUSH
23783: LD_VAR 0 13
23787: PPUSH
23788: CALL_OW 251
23792: PPUSH
23793: LD_VAR 0 10
23797: PPUSH
23798: LD_INT 2
23800: PPUSH
23801: CALL_OW 273
23805: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23806: LD_VAR 0 11
23810: PPUSH
23811: LD_VAR 0 12
23815: PPUSH
23816: CALL_OW 488
23820: PUSH
23821: LD_VAR 0 11
23825: PPUSH
23826: LD_VAR 0 12
23830: PPUSH
23831: CALL_OW 428
23835: NOT
23836: AND
23837: IFFALSE 23860
// begin ComMoveXY ( tmp , _x , _y ) ;
23839: LD_VAR 0 13
23843: PPUSH
23844: LD_VAR 0 11
23848: PPUSH
23849: LD_VAR 0 12
23853: PPUSH
23854: CALL_OW 111
// break ;
23858: GO 23862
// end ; end ;
23860: GO 23747
23862: POP
23863: POP
// end ; end ;
23864: GO 23189
23866: POP
23867: POP
// end ;
23868: LD_VAR 0 8
23872: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23873: LD_INT 0
23875: PPUSH
// result := true ;
23876: LD_ADDR_VAR 0 3
23880: PUSH
23881: LD_INT 1
23883: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23884: LD_VAR 0 2
23888: PUSH
23889: LD_INT 24
23891: DOUBLE
23892: EQUAL
23893: IFTRUE 23903
23895: LD_INT 33
23897: DOUBLE
23898: EQUAL
23899: IFTRUE 23903
23901: GO 23928
23903: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23904: LD_ADDR_VAR 0 3
23908: PUSH
23909: LD_INT 32
23911: PPUSH
23912: LD_VAR 0 1
23916: PPUSH
23917: CALL_OW 321
23921: PUSH
23922: LD_INT 2
23924: EQUAL
23925: ST_TO_ADDR
23926: GO 24244
23928: LD_INT 20
23930: DOUBLE
23931: EQUAL
23932: IFTRUE 23936
23934: GO 23961
23936: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23937: LD_ADDR_VAR 0 3
23941: PUSH
23942: LD_INT 6
23944: PPUSH
23945: LD_VAR 0 1
23949: PPUSH
23950: CALL_OW 321
23954: PUSH
23955: LD_INT 2
23957: EQUAL
23958: ST_TO_ADDR
23959: GO 24244
23961: LD_INT 22
23963: DOUBLE
23964: EQUAL
23965: IFTRUE 23975
23967: LD_INT 36
23969: DOUBLE
23970: EQUAL
23971: IFTRUE 23975
23973: GO 24000
23975: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23976: LD_ADDR_VAR 0 3
23980: PUSH
23981: LD_INT 15
23983: PPUSH
23984: LD_VAR 0 1
23988: PPUSH
23989: CALL_OW 321
23993: PUSH
23994: LD_INT 2
23996: EQUAL
23997: ST_TO_ADDR
23998: GO 24244
24000: LD_INT 30
24002: DOUBLE
24003: EQUAL
24004: IFTRUE 24008
24006: GO 24033
24008: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24009: LD_ADDR_VAR 0 3
24013: PUSH
24014: LD_INT 20
24016: PPUSH
24017: LD_VAR 0 1
24021: PPUSH
24022: CALL_OW 321
24026: PUSH
24027: LD_INT 2
24029: EQUAL
24030: ST_TO_ADDR
24031: GO 24244
24033: LD_INT 28
24035: DOUBLE
24036: EQUAL
24037: IFTRUE 24047
24039: LD_INT 21
24041: DOUBLE
24042: EQUAL
24043: IFTRUE 24047
24045: GO 24072
24047: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24048: LD_ADDR_VAR 0 3
24052: PUSH
24053: LD_INT 21
24055: PPUSH
24056: LD_VAR 0 1
24060: PPUSH
24061: CALL_OW 321
24065: PUSH
24066: LD_INT 2
24068: EQUAL
24069: ST_TO_ADDR
24070: GO 24244
24072: LD_INT 16
24074: DOUBLE
24075: EQUAL
24076: IFTRUE 24080
24078: GO 24105
24080: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24081: LD_ADDR_VAR 0 3
24085: PUSH
24086: LD_INT 84
24088: PPUSH
24089: LD_VAR 0 1
24093: PPUSH
24094: CALL_OW 321
24098: PUSH
24099: LD_INT 2
24101: EQUAL
24102: ST_TO_ADDR
24103: GO 24244
24105: LD_INT 19
24107: DOUBLE
24108: EQUAL
24109: IFTRUE 24119
24111: LD_INT 23
24113: DOUBLE
24114: EQUAL
24115: IFTRUE 24119
24117: GO 24144
24119: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24120: LD_ADDR_VAR 0 3
24124: PUSH
24125: LD_INT 83
24127: PPUSH
24128: LD_VAR 0 1
24132: PPUSH
24133: CALL_OW 321
24137: PUSH
24138: LD_INT 2
24140: EQUAL
24141: ST_TO_ADDR
24142: GO 24244
24144: LD_INT 17
24146: DOUBLE
24147: EQUAL
24148: IFTRUE 24152
24150: GO 24177
24152: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24153: LD_ADDR_VAR 0 3
24157: PUSH
24158: LD_INT 39
24160: PPUSH
24161: LD_VAR 0 1
24165: PPUSH
24166: CALL_OW 321
24170: PUSH
24171: LD_INT 2
24173: EQUAL
24174: ST_TO_ADDR
24175: GO 24244
24177: LD_INT 18
24179: DOUBLE
24180: EQUAL
24181: IFTRUE 24185
24183: GO 24210
24185: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24186: LD_ADDR_VAR 0 3
24190: PUSH
24191: LD_INT 40
24193: PPUSH
24194: LD_VAR 0 1
24198: PPUSH
24199: CALL_OW 321
24203: PUSH
24204: LD_INT 2
24206: EQUAL
24207: ST_TO_ADDR
24208: GO 24244
24210: LD_INT 27
24212: DOUBLE
24213: EQUAL
24214: IFTRUE 24218
24216: GO 24243
24218: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24219: LD_ADDR_VAR 0 3
24223: PUSH
24224: LD_INT 35
24226: PPUSH
24227: LD_VAR 0 1
24231: PPUSH
24232: CALL_OW 321
24236: PUSH
24237: LD_INT 2
24239: EQUAL
24240: ST_TO_ADDR
24241: GO 24244
24243: POP
// end ;
24244: LD_VAR 0 3
24248: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24249: LD_INT 0
24251: PPUSH
24252: PPUSH
24253: PPUSH
24254: PPUSH
24255: PPUSH
24256: PPUSH
24257: PPUSH
24258: PPUSH
24259: PPUSH
24260: PPUSH
24261: PPUSH
// result := false ;
24262: LD_ADDR_VAR 0 6
24266: PUSH
24267: LD_INT 0
24269: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24270: LD_VAR 0 1
24274: NOT
24275: PUSH
24276: LD_VAR 0 1
24280: PPUSH
24281: CALL_OW 266
24285: PUSH
24286: LD_INT 0
24288: PUSH
24289: LD_INT 1
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: IN
24296: NOT
24297: OR
24298: PUSH
24299: LD_VAR 0 2
24303: NOT
24304: OR
24305: PUSH
24306: LD_VAR 0 5
24310: PUSH
24311: LD_INT 0
24313: PUSH
24314: LD_INT 1
24316: PUSH
24317: LD_INT 2
24319: PUSH
24320: LD_INT 3
24322: PUSH
24323: LD_INT 4
24325: PUSH
24326: LD_INT 5
24328: PUSH
24329: EMPTY
24330: LIST
24331: LIST
24332: LIST
24333: LIST
24334: LIST
24335: LIST
24336: IN
24337: NOT
24338: OR
24339: PUSH
24340: LD_VAR 0 3
24344: PPUSH
24345: LD_VAR 0 4
24349: PPUSH
24350: CALL_OW 488
24354: NOT
24355: OR
24356: IFFALSE 24360
// exit ;
24358: GO 25096
// side := GetSide ( depot ) ;
24360: LD_ADDR_VAR 0 9
24364: PUSH
24365: LD_VAR 0 1
24369: PPUSH
24370: CALL_OW 255
24374: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24375: LD_VAR 0 9
24379: PPUSH
24380: LD_VAR 0 2
24384: PPUSH
24385: CALL 23873 0 2
24389: NOT
24390: IFFALSE 24394
// exit ;
24392: GO 25096
// pom := GetBase ( depot ) ;
24394: LD_ADDR_VAR 0 10
24398: PUSH
24399: LD_VAR 0 1
24403: PPUSH
24404: CALL_OW 274
24408: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24409: LD_ADDR_VAR 0 11
24413: PUSH
24414: LD_VAR 0 2
24418: PPUSH
24419: LD_VAR 0 1
24423: PPUSH
24424: CALL_OW 248
24428: PPUSH
24429: CALL_OW 450
24433: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24434: LD_VAR 0 10
24438: PPUSH
24439: LD_INT 1
24441: PPUSH
24442: CALL_OW 275
24446: PUSH
24447: LD_VAR 0 11
24451: PUSH
24452: LD_INT 1
24454: ARRAY
24455: GREATEREQUAL
24456: PUSH
24457: LD_VAR 0 10
24461: PPUSH
24462: LD_INT 2
24464: PPUSH
24465: CALL_OW 275
24469: PUSH
24470: LD_VAR 0 11
24474: PUSH
24475: LD_INT 2
24477: ARRAY
24478: GREATEREQUAL
24479: AND
24480: PUSH
24481: LD_VAR 0 10
24485: PPUSH
24486: LD_INT 3
24488: PPUSH
24489: CALL_OW 275
24493: PUSH
24494: LD_VAR 0 11
24498: PUSH
24499: LD_INT 3
24501: ARRAY
24502: GREATEREQUAL
24503: AND
24504: NOT
24505: IFFALSE 24509
// exit ;
24507: GO 25096
// if GetBType ( depot ) = b_depot then
24509: LD_VAR 0 1
24513: PPUSH
24514: CALL_OW 266
24518: PUSH
24519: LD_INT 0
24521: EQUAL
24522: IFFALSE 24534
// dist := 28 else
24524: LD_ADDR_VAR 0 14
24528: PUSH
24529: LD_INT 28
24531: ST_TO_ADDR
24532: GO 24542
// dist := 36 ;
24534: LD_ADDR_VAR 0 14
24538: PUSH
24539: LD_INT 36
24541: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24542: LD_VAR 0 1
24546: PPUSH
24547: LD_VAR 0 3
24551: PPUSH
24552: LD_VAR 0 4
24556: PPUSH
24557: CALL_OW 297
24561: PUSH
24562: LD_VAR 0 14
24566: GREATER
24567: IFFALSE 24571
// exit ;
24569: GO 25096
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24571: LD_ADDR_VAR 0 12
24575: PUSH
24576: LD_VAR 0 2
24580: PPUSH
24581: LD_VAR 0 3
24585: PPUSH
24586: LD_VAR 0 4
24590: PPUSH
24591: LD_VAR 0 5
24595: PPUSH
24596: LD_VAR 0 1
24600: PPUSH
24601: CALL_OW 248
24605: PPUSH
24606: LD_INT 0
24608: PPUSH
24609: CALL 25101 0 6
24613: ST_TO_ADDR
// if not hexes then
24614: LD_VAR 0 12
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 25096
// hex := GetHexInfo ( x , y ) ;
24623: LD_ADDR_VAR 0 15
24627: PUSH
24628: LD_VAR 0 3
24632: PPUSH
24633: LD_VAR 0 4
24637: PPUSH
24638: CALL_OW 546
24642: ST_TO_ADDR
// if hex [ 1 ] then
24643: LD_VAR 0 15
24647: PUSH
24648: LD_INT 1
24650: ARRAY
24651: IFFALSE 24655
// exit ;
24653: GO 25096
// height := hex [ 2 ] ;
24655: LD_ADDR_VAR 0 13
24659: PUSH
24660: LD_VAR 0 15
24664: PUSH
24665: LD_INT 2
24667: ARRAY
24668: ST_TO_ADDR
// for i = 1 to hexes do
24669: LD_ADDR_VAR 0 7
24673: PUSH
24674: DOUBLE
24675: LD_INT 1
24677: DEC
24678: ST_TO_ADDR
24679: LD_VAR 0 12
24683: PUSH
24684: FOR_TO
24685: IFFALSE 25015
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24687: LD_VAR 0 12
24691: PUSH
24692: LD_VAR 0 7
24696: ARRAY
24697: PUSH
24698: LD_INT 1
24700: ARRAY
24701: PPUSH
24702: LD_VAR 0 12
24706: PUSH
24707: LD_VAR 0 7
24711: ARRAY
24712: PUSH
24713: LD_INT 2
24715: ARRAY
24716: PPUSH
24717: CALL_OW 488
24721: NOT
24722: PUSH
24723: LD_VAR 0 12
24727: PUSH
24728: LD_VAR 0 7
24732: ARRAY
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PPUSH
24738: LD_VAR 0 12
24742: PUSH
24743: LD_VAR 0 7
24747: ARRAY
24748: PUSH
24749: LD_INT 2
24751: ARRAY
24752: PPUSH
24753: CALL_OW 428
24757: PUSH
24758: LD_INT 0
24760: GREATER
24761: OR
24762: PUSH
24763: LD_VAR 0 12
24767: PUSH
24768: LD_VAR 0 7
24772: ARRAY
24773: PUSH
24774: LD_INT 1
24776: ARRAY
24777: PPUSH
24778: LD_VAR 0 12
24782: PUSH
24783: LD_VAR 0 7
24787: ARRAY
24788: PUSH
24789: LD_INT 2
24791: ARRAY
24792: PPUSH
24793: CALL_OW 351
24797: OR
24798: IFFALSE 24804
// exit ;
24800: POP
24801: POP
24802: GO 25096
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24804: LD_ADDR_VAR 0 8
24808: PUSH
24809: LD_VAR 0 12
24813: PUSH
24814: LD_VAR 0 7
24818: ARRAY
24819: PUSH
24820: LD_INT 1
24822: ARRAY
24823: PPUSH
24824: LD_VAR 0 12
24828: PUSH
24829: LD_VAR 0 7
24833: ARRAY
24834: PUSH
24835: LD_INT 2
24837: ARRAY
24838: PPUSH
24839: CALL_OW 546
24843: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24844: LD_VAR 0 8
24848: PUSH
24849: LD_INT 1
24851: ARRAY
24852: PUSH
24853: LD_VAR 0 8
24857: PUSH
24858: LD_INT 2
24860: ARRAY
24861: PUSH
24862: LD_VAR 0 13
24866: PUSH
24867: LD_INT 2
24869: PLUS
24870: GREATER
24871: OR
24872: PUSH
24873: LD_VAR 0 8
24877: PUSH
24878: LD_INT 2
24880: ARRAY
24881: PUSH
24882: LD_VAR 0 13
24886: PUSH
24887: LD_INT 2
24889: MINUS
24890: LESS
24891: OR
24892: PUSH
24893: LD_VAR 0 8
24897: PUSH
24898: LD_INT 3
24900: ARRAY
24901: PUSH
24902: LD_INT 0
24904: PUSH
24905: LD_INT 8
24907: PUSH
24908: LD_INT 9
24910: PUSH
24911: LD_INT 10
24913: PUSH
24914: LD_INT 11
24916: PUSH
24917: LD_INT 12
24919: PUSH
24920: LD_INT 13
24922: PUSH
24923: LD_INT 16
24925: PUSH
24926: LD_INT 17
24928: PUSH
24929: LD_INT 18
24931: PUSH
24932: LD_INT 19
24934: PUSH
24935: LD_INT 20
24937: PUSH
24938: LD_INT 21
24940: PUSH
24941: EMPTY
24942: LIST
24943: LIST
24944: LIST
24945: LIST
24946: LIST
24947: LIST
24948: LIST
24949: LIST
24950: LIST
24951: LIST
24952: LIST
24953: LIST
24954: LIST
24955: IN
24956: NOT
24957: OR
24958: PUSH
24959: LD_VAR 0 8
24963: PUSH
24964: LD_INT 5
24966: ARRAY
24967: NOT
24968: OR
24969: PUSH
24970: LD_VAR 0 8
24974: PUSH
24975: LD_INT 6
24977: ARRAY
24978: PUSH
24979: LD_INT 1
24981: PUSH
24982: LD_INT 2
24984: PUSH
24985: LD_INT 7
24987: PUSH
24988: LD_INT 9
24990: PUSH
24991: LD_INT 10
24993: PUSH
24994: LD_INT 11
24996: PUSH
24997: EMPTY
24998: LIST
24999: LIST
25000: LIST
25001: LIST
25002: LIST
25003: LIST
25004: IN
25005: NOT
25006: OR
25007: IFFALSE 25013
// exit ;
25009: POP
25010: POP
25011: GO 25096
// end ;
25013: GO 24684
25015: POP
25016: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25017: LD_VAR 0 9
25021: PPUSH
25022: LD_VAR 0 3
25026: PPUSH
25027: LD_VAR 0 4
25031: PPUSH
25032: LD_INT 20
25034: PPUSH
25035: CALL 17048 0 4
25039: PUSH
25040: LD_INT 4
25042: ARRAY
25043: IFFALSE 25047
// exit ;
25045: GO 25096
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25047: LD_VAR 0 2
25051: PUSH
25052: LD_INT 29
25054: PUSH
25055: LD_INT 30
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: IN
25062: PUSH
25063: LD_VAR 0 3
25067: PPUSH
25068: LD_VAR 0 4
25072: PPUSH
25073: LD_VAR 0 9
25077: PPUSH
25078: CALL_OW 440
25082: NOT
25083: AND
25084: IFFALSE 25088
// exit ;
25086: GO 25096
// result := true ;
25088: LD_ADDR_VAR 0 6
25092: PUSH
25093: LD_INT 1
25095: ST_TO_ADDR
// end ;
25096: LD_VAR 0 6
25100: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25101: LD_INT 0
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
25119: PPUSH
25120: PPUSH
25121: PPUSH
25122: PPUSH
25123: PPUSH
25124: PPUSH
25125: PPUSH
25126: PPUSH
25127: PPUSH
25128: PPUSH
25129: PPUSH
25130: PPUSH
25131: PPUSH
25132: PPUSH
25133: PPUSH
25134: PPUSH
25135: PPUSH
25136: PPUSH
25137: PPUSH
25138: PPUSH
25139: PPUSH
25140: PPUSH
25141: PPUSH
25142: PPUSH
25143: PPUSH
25144: PPUSH
25145: PPUSH
25146: PPUSH
25147: PPUSH
25148: PPUSH
25149: PPUSH
25150: PPUSH
25151: PPUSH
25152: PPUSH
25153: PPUSH
25154: PPUSH
25155: PPUSH
25156: PPUSH
25157: PPUSH
25158: PPUSH
25159: PPUSH
25160: PPUSH
// result = [ ] ;
25161: LD_ADDR_VAR 0 7
25165: PUSH
25166: EMPTY
25167: ST_TO_ADDR
// temp_list = [ ] ;
25168: LD_ADDR_VAR 0 9
25172: PUSH
25173: EMPTY
25174: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25175: LD_VAR 0 4
25179: PUSH
25180: LD_INT 0
25182: PUSH
25183: LD_INT 1
25185: PUSH
25186: LD_INT 2
25188: PUSH
25189: LD_INT 3
25191: PUSH
25192: LD_INT 4
25194: PUSH
25195: LD_INT 5
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: LIST
25202: LIST
25203: LIST
25204: LIST
25205: IN
25206: NOT
25207: PUSH
25208: LD_VAR 0 1
25212: PUSH
25213: LD_INT 0
25215: PUSH
25216: LD_INT 1
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: IN
25223: PUSH
25224: LD_VAR 0 5
25228: PUSH
25229: LD_INT 1
25231: PUSH
25232: LD_INT 2
25234: PUSH
25235: LD_INT 3
25237: PUSH
25238: EMPTY
25239: LIST
25240: LIST
25241: LIST
25242: IN
25243: NOT
25244: AND
25245: OR
25246: IFFALSE 25250
// exit ;
25248: GO 43641
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25250: LD_VAR 0 1
25254: PUSH
25255: LD_INT 6
25257: PUSH
25258: LD_INT 7
25260: PUSH
25261: LD_INT 8
25263: PUSH
25264: LD_INT 13
25266: PUSH
25267: LD_INT 12
25269: PUSH
25270: LD_INT 15
25272: PUSH
25273: LD_INT 11
25275: PUSH
25276: LD_INT 14
25278: PUSH
25279: LD_INT 10
25281: PUSH
25282: EMPTY
25283: LIST
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: LIST
25289: LIST
25290: LIST
25291: LIST
25292: IN
25293: IFFALSE 25303
// btype = b_lab ;
25295: LD_ADDR_VAR 0 1
25299: PUSH
25300: LD_INT 6
25302: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25303: LD_VAR 0 6
25307: PUSH
25308: LD_INT 0
25310: PUSH
25311: LD_INT 1
25313: PUSH
25314: LD_INT 2
25316: PUSH
25317: EMPTY
25318: LIST
25319: LIST
25320: LIST
25321: IN
25322: NOT
25323: PUSH
25324: LD_VAR 0 1
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: LD_INT 1
25334: PUSH
25335: LD_INT 2
25337: PUSH
25338: LD_INT 3
25340: PUSH
25341: LD_INT 6
25343: PUSH
25344: LD_INT 36
25346: PUSH
25347: LD_INT 4
25349: PUSH
25350: LD_INT 5
25352: PUSH
25353: LD_INT 31
25355: PUSH
25356: LD_INT 32
25358: PUSH
25359: LD_INT 33
25361: PUSH
25362: EMPTY
25363: LIST
25364: LIST
25365: LIST
25366: LIST
25367: LIST
25368: LIST
25369: LIST
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: IN
25375: NOT
25376: PUSH
25377: LD_VAR 0 6
25381: PUSH
25382: LD_INT 1
25384: EQUAL
25385: AND
25386: OR
25387: PUSH
25388: LD_VAR 0 1
25392: PUSH
25393: LD_INT 2
25395: PUSH
25396: LD_INT 3
25398: PUSH
25399: EMPTY
25400: LIST
25401: LIST
25402: IN
25403: NOT
25404: PUSH
25405: LD_VAR 0 6
25409: PUSH
25410: LD_INT 2
25412: EQUAL
25413: AND
25414: OR
25415: IFFALSE 25425
// mode = 0 ;
25417: LD_ADDR_VAR 0 6
25421: PUSH
25422: LD_INT 0
25424: ST_TO_ADDR
// case mode of 0 :
25425: LD_VAR 0 6
25429: PUSH
25430: LD_INT 0
25432: DOUBLE
25433: EQUAL
25434: IFTRUE 25438
25436: GO 36891
25438: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25439: LD_ADDR_VAR 0 11
25443: PUSH
25444: LD_INT 0
25446: PUSH
25447: LD_INT 0
25449: PUSH
25450: EMPTY
25451: LIST
25452: LIST
25453: PUSH
25454: LD_INT 0
25456: PUSH
25457: LD_INT 1
25459: NEG
25460: PUSH
25461: EMPTY
25462: LIST
25463: LIST
25464: PUSH
25465: LD_INT 1
25467: PUSH
25468: LD_INT 0
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: PUSH
25475: LD_INT 1
25477: PUSH
25478: LD_INT 1
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: LD_INT 0
25487: PUSH
25488: LD_INT 1
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: LD_INT 1
25497: NEG
25498: PUSH
25499: LD_INT 0
25501: PUSH
25502: EMPTY
25503: LIST
25504: LIST
25505: PUSH
25506: LD_INT 1
25508: NEG
25509: PUSH
25510: LD_INT 1
25512: NEG
25513: PUSH
25514: EMPTY
25515: LIST
25516: LIST
25517: PUSH
25518: LD_INT 1
25520: NEG
25521: PUSH
25522: LD_INT 2
25524: NEG
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 0
25532: PUSH
25533: LD_INT 2
25535: NEG
25536: PUSH
25537: EMPTY
25538: LIST
25539: LIST
25540: PUSH
25541: LD_INT 1
25543: PUSH
25544: LD_INT 1
25546: NEG
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: LD_INT 1
25554: PUSH
25555: LD_INT 2
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PUSH
25562: LD_INT 0
25564: PUSH
25565: LD_INT 2
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: LD_INT 1
25574: NEG
25575: PUSH
25576: LD_INT 1
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: PUSH
25583: LD_INT 1
25585: PUSH
25586: LD_INT 3
25588: PUSH
25589: EMPTY
25590: LIST
25591: LIST
25592: PUSH
25593: LD_INT 0
25595: PUSH
25596: LD_INT 3
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 1
25605: NEG
25606: PUSH
25607: LD_INT 2
25609: PUSH
25610: EMPTY
25611: LIST
25612: LIST
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: LIST
25622: LIST
25623: LIST
25624: LIST
25625: LIST
25626: LIST
25627: LIST
25628: LIST
25629: LIST
25630: LIST
25631: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25632: LD_ADDR_VAR 0 12
25636: PUSH
25637: LD_INT 0
25639: PUSH
25640: LD_INT 0
25642: PUSH
25643: EMPTY
25644: LIST
25645: LIST
25646: PUSH
25647: LD_INT 0
25649: PUSH
25650: LD_INT 1
25652: NEG
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: LD_INT 1
25660: PUSH
25661: LD_INT 0
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: LD_INT 1
25670: PUSH
25671: LD_INT 1
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PUSH
25678: LD_INT 0
25680: PUSH
25681: LD_INT 1
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 1
25690: NEG
25691: PUSH
25692: LD_INT 0
25694: PUSH
25695: EMPTY
25696: LIST
25697: LIST
25698: PUSH
25699: LD_INT 1
25701: NEG
25702: PUSH
25703: LD_INT 1
25705: NEG
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: LD_INT 1
25716: NEG
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 2
25724: PUSH
25725: LD_INT 0
25727: PUSH
25728: EMPTY
25729: LIST
25730: LIST
25731: PUSH
25732: LD_INT 2
25734: PUSH
25735: LD_INT 1
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 1
25744: NEG
25745: PUSH
25746: LD_INT 1
25748: PUSH
25749: EMPTY
25750: LIST
25751: LIST
25752: PUSH
25753: LD_INT 2
25755: NEG
25756: PUSH
25757: LD_INT 0
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: LD_INT 2
25766: NEG
25767: PUSH
25768: LD_INT 1
25770: NEG
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 2
25778: NEG
25779: PUSH
25780: LD_INT 1
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 3
25789: NEG
25790: PUSH
25791: LD_INT 0
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PUSH
25798: LD_INT 3
25800: NEG
25801: PUSH
25802: LD_INT 1
25804: NEG
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: EMPTY
25811: LIST
25812: LIST
25813: LIST
25814: LIST
25815: LIST
25816: LIST
25817: LIST
25818: LIST
25819: LIST
25820: LIST
25821: LIST
25822: LIST
25823: LIST
25824: LIST
25825: LIST
25826: LIST
25827: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25828: LD_ADDR_VAR 0 13
25832: PUSH
25833: LD_INT 0
25835: PUSH
25836: LD_INT 0
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: LD_INT 0
25845: PUSH
25846: LD_INT 1
25848: NEG
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PUSH
25854: LD_INT 1
25856: PUSH
25857: LD_INT 0
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 1
25866: PUSH
25867: LD_INT 1
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: LD_INT 0
25876: PUSH
25877: LD_INT 1
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 1
25886: NEG
25887: PUSH
25888: LD_INT 0
25890: PUSH
25891: EMPTY
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 1
25897: NEG
25898: PUSH
25899: LD_INT 1
25901: NEG
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 1
25909: NEG
25910: PUSH
25911: LD_INT 2
25913: NEG
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: LD_INT 2
25921: PUSH
25922: LD_INT 1
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: PUSH
25929: LD_INT 2
25931: PUSH
25932: LD_INT 2
25934: PUSH
25935: EMPTY
25936: LIST
25937: LIST
25938: PUSH
25939: LD_INT 1
25941: PUSH
25942: LD_INT 2
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PUSH
25949: LD_INT 2
25951: NEG
25952: PUSH
25953: LD_INT 1
25955: NEG
25956: PUSH
25957: EMPTY
25958: LIST
25959: LIST
25960: PUSH
25961: LD_INT 2
25963: NEG
25964: PUSH
25965: LD_INT 2
25967: NEG
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: LD_INT 2
25975: NEG
25976: PUSH
25977: LD_INT 3
25979: NEG
25980: PUSH
25981: EMPTY
25982: LIST
25983: LIST
25984: PUSH
25985: LD_INT 3
25987: NEG
25988: PUSH
25989: LD_INT 2
25991: NEG
25992: PUSH
25993: EMPTY
25994: LIST
25995: LIST
25996: PUSH
25997: LD_INT 3
25999: NEG
26000: PUSH
26001: LD_INT 3
26003: NEG
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: PUSH
26009: EMPTY
26010: LIST
26011: LIST
26012: LIST
26013: LIST
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: LIST
26023: LIST
26024: LIST
26025: LIST
26026: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26027: LD_ADDR_VAR 0 14
26031: PUSH
26032: LD_INT 0
26034: PUSH
26035: LD_INT 0
26037: PUSH
26038: EMPTY
26039: LIST
26040: LIST
26041: PUSH
26042: LD_INT 0
26044: PUSH
26045: LD_INT 1
26047: NEG
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: PUSH
26053: LD_INT 1
26055: PUSH
26056: LD_INT 0
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: LD_INT 1
26065: PUSH
26066: LD_INT 1
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: LD_INT 0
26075: PUSH
26076: LD_INT 1
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 1
26085: NEG
26086: PUSH
26087: LD_INT 0
26089: PUSH
26090: EMPTY
26091: LIST
26092: LIST
26093: PUSH
26094: LD_INT 1
26096: NEG
26097: PUSH
26098: LD_INT 1
26100: NEG
26101: PUSH
26102: EMPTY
26103: LIST
26104: LIST
26105: PUSH
26106: LD_INT 1
26108: NEG
26109: PUSH
26110: LD_INT 2
26112: NEG
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PUSH
26118: LD_INT 0
26120: PUSH
26121: LD_INT 2
26123: NEG
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 1
26131: PUSH
26132: LD_INT 1
26134: NEG
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: PUSH
26140: LD_INT 1
26142: PUSH
26143: LD_INT 2
26145: PUSH
26146: EMPTY
26147: LIST
26148: LIST
26149: PUSH
26150: LD_INT 0
26152: PUSH
26153: LD_INT 2
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: LD_INT 1
26162: NEG
26163: PUSH
26164: LD_INT 1
26166: PUSH
26167: EMPTY
26168: LIST
26169: LIST
26170: PUSH
26171: LD_INT 1
26173: NEG
26174: PUSH
26175: LD_INT 3
26177: NEG
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 0
26185: PUSH
26186: LD_INT 3
26188: NEG
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PUSH
26194: LD_INT 1
26196: PUSH
26197: LD_INT 2
26199: NEG
26200: PUSH
26201: EMPTY
26202: LIST
26203: LIST
26204: PUSH
26205: EMPTY
26206: LIST
26207: LIST
26208: LIST
26209: LIST
26210: LIST
26211: LIST
26212: LIST
26213: LIST
26214: LIST
26215: LIST
26216: LIST
26217: LIST
26218: LIST
26219: LIST
26220: LIST
26221: LIST
26222: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26223: LD_ADDR_VAR 0 15
26227: PUSH
26228: LD_INT 0
26230: PUSH
26231: LD_INT 0
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PUSH
26238: LD_INT 0
26240: PUSH
26241: LD_INT 1
26243: NEG
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 1
26251: PUSH
26252: LD_INT 0
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 1
26261: PUSH
26262: LD_INT 1
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PUSH
26269: LD_INT 0
26271: PUSH
26272: LD_INT 1
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 1
26281: NEG
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: PUSH
26290: LD_INT 1
26292: NEG
26293: PUSH
26294: LD_INT 1
26296: NEG
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 1
26304: PUSH
26305: LD_INT 1
26307: NEG
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: PUSH
26313: LD_INT 2
26315: PUSH
26316: LD_INT 0
26318: PUSH
26319: EMPTY
26320: LIST
26321: LIST
26322: PUSH
26323: LD_INT 2
26325: PUSH
26326: LD_INT 1
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 1
26335: NEG
26336: PUSH
26337: LD_INT 1
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 2
26346: NEG
26347: PUSH
26348: LD_INT 0
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: LD_INT 2
26357: NEG
26358: PUSH
26359: LD_INT 1
26361: NEG
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: LD_INT 2
26369: PUSH
26370: LD_INT 1
26372: NEG
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 3
26380: PUSH
26381: LD_INT 0
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 3
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: LIST
26402: LIST
26403: LIST
26404: LIST
26405: LIST
26406: LIST
26407: LIST
26408: LIST
26409: LIST
26410: LIST
26411: LIST
26412: LIST
26413: LIST
26414: LIST
26415: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26416: LD_ADDR_VAR 0 16
26420: PUSH
26421: LD_INT 0
26423: PUSH
26424: LD_INT 0
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PUSH
26431: LD_INT 0
26433: PUSH
26434: LD_INT 1
26436: NEG
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: PUSH
26442: LD_INT 1
26444: PUSH
26445: LD_INT 0
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: PUSH
26452: LD_INT 1
26454: PUSH
26455: LD_INT 1
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 0
26464: PUSH
26465: LD_INT 1
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 1
26474: NEG
26475: PUSH
26476: LD_INT 0
26478: PUSH
26479: EMPTY
26480: LIST
26481: LIST
26482: PUSH
26483: LD_INT 1
26485: NEG
26486: PUSH
26487: LD_INT 1
26489: NEG
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: PUSH
26495: LD_INT 1
26497: NEG
26498: PUSH
26499: LD_INT 2
26501: NEG
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PUSH
26507: LD_INT 2
26509: PUSH
26510: LD_INT 1
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 2
26519: PUSH
26520: LD_INT 2
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 1
26529: PUSH
26530: LD_INT 2
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PUSH
26537: LD_INT 2
26539: NEG
26540: PUSH
26541: LD_INT 1
26543: NEG
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: PUSH
26549: LD_INT 2
26551: NEG
26552: PUSH
26553: LD_INT 2
26555: NEG
26556: PUSH
26557: EMPTY
26558: LIST
26559: LIST
26560: PUSH
26561: LD_INT 3
26563: PUSH
26564: LD_INT 2
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 3
26573: PUSH
26574: LD_INT 3
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 2
26583: PUSH
26584: LD_INT 3
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: LIST
26595: LIST
26596: LIST
26597: LIST
26598: LIST
26599: LIST
26600: LIST
26601: LIST
26602: LIST
26603: LIST
26604: LIST
26605: LIST
26606: LIST
26607: LIST
26608: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26609: LD_ADDR_VAR 0 17
26613: PUSH
26614: LD_INT 0
26616: PUSH
26617: LD_INT 0
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 0
26626: PUSH
26627: LD_INT 1
26629: NEG
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: LD_INT 1
26637: PUSH
26638: LD_INT 0
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 1
26647: PUSH
26648: LD_INT 1
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: PUSH
26655: LD_INT 0
26657: PUSH
26658: LD_INT 1
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: PUSH
26665: LD_INT 1
26667: NEG
26668: PUSH
26669: LD_INT 0
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: PUSH
26676: LD_INT 1
26678: NEG
26679: PUSH
26680: LD_INT 1
26682: NEG
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: PUSH
26688: LD_INT 1
26690: NEG
26691: PUSH
26692: LD_INT 2
26694: NEG
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: LD_INT 0
26702: PUSH
26703: LD_INT 2
26705: NEG
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PUSH
26711: LD_INT 1
26713: PUSH
26714: LD_INT 1
26716: NEG
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: LD_INT 2
26724: PUSH
26725: LD_INT 0
26727: PUSH
26728: EMPTY
26729: LIST
26730: LIST
26731: PUSH
26732: LD_INT 2
26734: PUSH
26735: LD_INT 1
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PUSH
26742: LD_INT 2
26744: PUSH
26745: LD_INT 2
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: PUSH
26752: LD_INT 1
26754: PUSH
26755: LD_INT 2
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 0
26764: PUSH
26765: LD_INT 2
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: LD_INT 1
26774: NEG
26775: PUSH
26776: LD_INT 1
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 2
26785: NEG
26786: PUSH
26787: LD_INT 0
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: LD_INT 2
26796: NEG
26797: PUSH
26798: LD_INT 1
26800: NEG
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 2
26808: NEG
26809: PUSH
26810: LD_INT 2
26812: NEG
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: LIST
26822: LIST
26823: LIST
26824: LIST
26825: LIST
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: LIST
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26839: LD_ADDR_VAR 0 18
26843: PUSH
26844: LD_INT 0
26846: PUSH
26847: LD_INT 0
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 0
26856: PUSH
26857: LD_INT 1
26859: NEG
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 1
26867: PUSH
26868: LD_INT 0
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PUSH
26875: LD_INT 1
26877: PUSH
26878: LD_INT 1
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 0
26887: PUSH
26888: LD_INT 1
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 1
26897: NEG
26898: PUSH
26899: LD_INT 0
26901: PUSH
26902: EMPTY
26903: LIST
26904: LIST
26905: PUSH
26906: LD_INT 1
26908: NEG
26909: PUSH
26910: LD_INT 1
26912: NEG
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: LD_INT 1
26920: NEG
26921: PUSH
26922: LD_INT 2
26924: NEG
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PUSH
26930: LD_INT 0
26932: PUSH
26933: LD_INT 2
26935: NEG
26936: PUSH
26937: EMPTY
26938: LIST
26939: LIST
26940: PUSH
26941: LD_INT 1
26943: PUSH
26944: LD_INT 1
26946: NEG
26947: PUSH
26948: EMPTY
26949: LIST
26950: LIST
26951: PUSH
26952: LD_INT 2
26954: PUSH
26955: LD_INT 0
26957: PUSH
26958: EMPTY
26959: LIST
26960: LIST
26961: PUSH
26962: LD_INT 2
26964: PUSH
26965: LD_INT 1
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: LD_INT 2
26974: PUSH
26975: LD_INT 2
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 2
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 0
26994: PUSH
26995: LD_INT 2
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PUSH
27002: LD_INT 1
27004: NEG
27005: PUSH
27006: LD_INT 1
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: PUSH
27013: LD_INT 2
27015: NEG
27016: PUSH
27017: LD_INT 0
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PUSH
27024: LD_INT 2
27026: NEG
27027: PUSH
27028: LD_INT 1
27030: NEG
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 2
27038: NEG
27039: PUSH
27040: LD_INT 2
27042: NEG
27043: PUSH
27044: EMPTY
27045: LIST
27046: LIST
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: LIST
27053: LIST
27054: LIST
27055: LIST
27056: LIST
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: LIST
27065: LIST
27066: LIST
27067: LIST
27068: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27069: LD_ADDR_VAR 0 19
27073: PUSH
27074: LD_INT 0
27076: PUSH
27077: LD_INT 0
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: LD_INT 0
27086: PUSH
27087: LD_INT 1
27089: NEG
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: LD_INT 1
27097: PUSH
27098: LD_INT 0
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 1
27107: PUSH
27108: LD_INT 1
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PUSH
27115: LD_INT 0
27117: PUSH
27118: LD_INT 1
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: LD_INT 1
27127: NEG
27128: PUSH
27129: LD_INT 0
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: PUSH
27136: LD_INT 1
27138: NEG
27139: PUSH
27140: LD_INT 1
27142: NEG
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 1
27150: NEG
27151: PUSH
27152: LD_INT 2
27154: NEG
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: LD_INT 0
27162: PUSH
27163: LD_INT 2
27165: NEG
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: LD_INT 1
27173: PUSH
27174: LD_INT 1
27176: NEG
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: PUSH
27182: LD_INT 2
27184: PUSH
27185: LD_INT 0
27187: PUSH
27188: EMPTY
27189: LIST
27190: LIST
27191: PUSH
27192: LD_INT 2
27194: PUSH
27195: LD_INT 1
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 2
27204: PUSH
27205: LD_INT 2
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 1
27214: PUSH
27215: LD_INT 2
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 0
27224: PUSH
27225: LD_INT 2
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: PUSH
27232: LD_INT 1
27234: NEG
27235: PUSH
27236: LD_INT 1
27238: PUSH
27239: EMPTY
27240: LIST
27241: LIST
27242: PUSH
27243: LD_INT 2
27245: NEG
27246: PUSH
27247: LD_INT 0
27249: PUSH
27250: EMPTY
27251: LIST
27252: LIST
27253: PUSH
27254: LD_INT 2
27256: NEG
27257: PUSH
27258: LD_INT 1
27260: NEG
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 2
27268: NEG
27269: PUSH
27270: LD_INT 2
27272: NEG
27273: PUSH
27274: EMPTY
27275: LIST
27276: LIST
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: LIST
27282: LIST
27283: LIST
27284: LIST
27285: LIST
27286: LIST
27287: LIST
27288: LIST
27289: LIST
27290: LIST
27291: LIST
27292: LIST
27293: LIST
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27299: LD_ADDR_VAR 0 20
27303: PUSH
27304: LD_INT 0
27306: PUSH
27307: LD_INT 0
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: PUSH
27314: LD_INT 0
27316: PUSH
27317: LD_INT 1
27319: NEG
27320: PUSH
27321: EMPTY
27322: LIST
27323: LIST
27324: PUSH
27325: LD_INT 1
27327: PUSH
27328: LD_INT 0
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 1
27337: PUSH
27338: LD_INT 1
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 0
27347: PUSH
27348: LD_INT 1
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 1
27357: NEG
27358: PUSH
27359: LD_INT 0
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 1
27368: NEG
27369: PUSH
27370: LD_INT 1
27372: NEG
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: LD_INT 1
27380: NEG
27381: PUSH
27382: LD_INT 2
27384: NEG
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 0
27392: PUSH
27393: LD_INT 2
27395: NEG
27396: PUSH
27397: EMPTY
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 1
27403: PUSH
27404: LD_INT 1
27406: NEG
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: LD_INT 2
27414: PUSH
27415: LD_INT 0
27417: PUSH
27418: EMPTY
27419: LIST
27420: LIST
27421: PUSH
27422: LD_INT 2
27424: PUSH
27425: LD_INT 1
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 2
27434: PUSH
27435: LD_INT 2
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 1
27444: PUSH
27445: LD_INT 2
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 0
27454: PUSH
27455: LD_INT 2
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 1
27464: NEG
27465: PUSH
27466: LD_INT 1
27468: PUSH
27469: EMPTY
27470: LIST
27471: LIST
27472: PUSH
27473: LD_INT 2
27475: NEG
27476: PUSH
27477: LD_INT 0
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: PUSH
27484: LD_INT 2
27486: NEG
27487: PUSH
27488: LD_INT 1
27490: NEG
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 2
27498: NEG
27499: PUSH
27500: LD_INT 2
27502: NEG
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: LIST
27515: LIST
27516: LIST
27517: LIST
27518: LIST
27519: LIST
27520: LIST
27521: LIST
27522: LIST
27523: LIST
27524: LIST
27525: LIST
27526: LIST
27527: LIST
27528: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27529: LD_ADDR_VAR 0 21
27533: PUSH
27534: LD_INT 0
27536: PUSH
27537: LD_INT 0
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 0
27546: PUSH
27547: LD_INT 1
27549: NEG
27550: PUSH
27551: EMPTY
27552: LIST
27553: LIST
27554: PUSH
27555: LD_INT 1
27557: PUSH
27558: LD_INT 0
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: PUSH
27565: LD_INT 1
27567: PUSH
27568: LD_INT 1
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PUSH
27575: LD_INT 0
27577: PUSH
27578: LD_INT 1
27580: PUSH
27581: EMPTY
27582: LIST
27583: LIST
27584: PUSH
27585: LD_INT 1
27587: NEG
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: PUSH
27596: LD_INT 1
27598: NEG
27599: PUSH
27600: LD_INT 1
27602: NEG
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 1
27610: NEG
27611: PUSH
27612: LD_INT 2
27614: NEG
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 0
27622: PUSH
27623: LD_INT 2
27625: NEG
27626: PUSH
27627: EMPTY
27628: LIST
27629: LIST
27630: PUSH
27631: LD_INT 1
27633: PUSH
27634: LD_INT 1
27636: NEG
27637: PUSH
27638: EMPTY
27639: LIST
27640: LIST
27641: PUSH
27642: LD_INT 2
27644: PUSH
27645: LD_INT 0
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: PUSH
27652: LD_INT 2
27654: PUSH
27655: LD_INT 1
27657: PUSH
27658: EMPTY
27659: LIST
27660: LIST
27661: PUSH
27662: LD_INT 2
27664: PUSH
27665: LD_INT 2
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: PUSH
27672: LD_INT 1
27674: PUSH
27675: LD_INT 2
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PUSH
27682: LD_INT 0
27684: PUSH
27685: LD_INT 2
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: PUSH
27692: LD_INT 1
27694: NEG
27695: PUSH
27696: LD_INT 1
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: LD_INT 2
27705: NEG
27706: PUSH
27707: LD_INT 0
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: PUSH
27714: LD_INT 2
27716: NEG
27717: PUSH
27718: LD_INT 1
27720: NEG
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 2
27728: NEG
27729: PUSH
27730: LD_INT 2
27732: NEG
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: LIST
27742: LIST
27743: LIST
27744: LIST
27745: LIST
27746: LIST
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27759: LD_ADDR_VAR 0 22
27763: PUSH
27764: LD_INT 0
27766: PUSH
27767: LD_INT 0
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 0
27776: PUSH
27777: LD_INT 1
27779: NEG
27780: PUSH
27781: EMPTY
27782: LIST
27783: LIST
27784: PUSH
27785: LD_INT 1
27787: PUSH
27788: LD_INT 0
27790: PUSH
27791: EMPTY
27792: LIST
27793: LIST
27794: PUSH
27795: LD_INT 1
27797: PUSH
27798: LD_INT 1
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PUSH
27805: LD_INT 0
27807: PUSH
27808: LD_INT 1
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 1
27817: NEG
27818: PUSH
27819: LD_INT 0
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 1
27828: NEG
27829: PUSH
27830: LD_INT 1
27832: NEG
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 1
27840: NEG
27841: PUSH
27842: LD_INT 2
27844: NEG
27845: PUSH
27846: EMPTY
27847: LIST
27848: LIST
27849: PUSH
27850: LD_INT 0
27852: PUSH
27853: LD_INT 2
27855: NEG
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: PUSH
27861: LD_INT 1
27863: PUSH
27864: LD_INT 1
27866: NEG
27867: PUSH
27868: EMPTY
27869: LIST
27870: LIST
27871: PUSH
27872: LD_INT 2
27874: PUSH
27875: LD_INT 0
27877: PUSH
27878: EMPTY
27879: LIST
27880: LIST
27881: PUSH
27882: LD_INT 2
27884: PUSH
27885: LD_INT 1
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 2
27894: PUSH
27895: LD_INT 2
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 1
27904: PUSH
27905: LD_INT 2
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 0
27914: PUSH
27915: LD_INT 2
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 1
27924: NEG
27925: PUSH
27926: LD_INT 1
27928: PUSH
27929: EMPTY
27930: LIST
27931: LIST
27932: PUSH
27933: LD_INT 2
27935: NEG
27936: PUSH
27937: LD_INT 0
27939: PUSH
27940: EMPTY
27941: LIST
27942: LIST
27943: PUSH
27944: LD_INT 2
27946: NEG
27947: PUSH
27948: LD_INT 1
27950: NEG
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 2
27958: NEG
27959: PUSH
27960: LD_INT 2
27962: NEG
27963: PUSH
27964: EMPTY
27965: LIST
27966: LIST
27967: PUSH
27968: EMPTY
27969: LIST
27970: LIST
27971: LIST
27972: LIST
27973: LIST
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: LIST
27979: LIST
27980: LIST
27981: LIST
27982: LIST
27983: LIST
27984: LIST
27985: LIST
27986: LIST
27987: LIST
27988: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27989: LD_ADDR_VAR 0 23
27993: PUSH
27994: LD_INT 0
27996: PUSH
27997: LD_INT 0
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 0
28006: PUSH
28007: LD_INT 1
28009: NEG
28010: PUSH
28011: EMPTY
28012: LIST
28013: LIST
28014: PUSH
28015: LD_INT 1
28017: PUSH
28018: LD_INT 0
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: PUSH
28025: LD_INT 1
28027: PUSH
28028: LD_INT 1
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 0
28037: PUSH
28038: LD_INT 1
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 1
28047: NEG
28048: PUSH
28049: LD_INT 0
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 1
28058: NEG
28059: PUSH
28060: LD_INT 1
28062: NEG
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: LD_INT 1
28070: NEG
28071: PUSH
28072: LD_INT 2
28074: NEG
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 0
28082: PUSH
28083: LD_INT 2
28085: NEG
28086: PUSH
28087: EMPTY
28088: LIST
28089: LIST
28090: PUSH
28091: LD_INT 1
28093: PUSH
28094: LD_INT 1
28096: NEG
28097: PUSH
28098: EMPTY
28099: LIST
28100: LIST
28101: PUSH
28102: LD_INT 2
28104: PUSH
28105: LD_INT 0
28107: PUSH
28108: EMPTY
28109: LIST
28110: LIST
28111: PUSH
28112: LD_INT 2
28114: PUSH
28115: LD_INT 1
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 2
28124: PUSH
28125: LD_INT 2
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 1
28134: PUSH
28135: LD_INT 2
28137: PUSH
28138: EMPTY
28139: LIST
28140: LIST
28141: PUSH
28142: LD_INT 0
28144: PUSH
28145: LD_INT 2
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: PUSH
28152: LD_INT 1
28154: NEG
28155: PUSH
28156: LD_INT 1
28158: PUSH
28159: EMPTY
28160: LIST
28161: LIST
28162: PUSH
28163: LD_INT 2
28165: NEG
28166: PUSH
28167: LD_INT 0
28169: PUSH
28170: EMPTY
28171: LIST
28172: LIST
28173: PUSH
28174: LD_INT 2
28176: NEG
28177: PUSH
28178: LD_INT 1
28180: NEG
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: PUSH
28186: LD_INT 2
28188: NEG
28189: PUSH
28190: LD_INT 2
28192: NEG
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: LD_INT 2
28200: NEG
28201: PUSH
28202: LD_INT 3
28204: NEG
28205: PUSH
28206: EMPTY
28207: LIST
28208: LIST
28209: PUSH
28210: LD_INT 1
28212: NEG
28213: PUSH
28214: LD_INT 3
28216: NEG
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: LD_INT 1
28224: PUSH
28225: LD_INT 2
28227: NEG
28228: PUSH
28229: EMPTY
28230: LIST
28231: LIST
28232: PUSH
28233: LD_INT 2
28235: PUSH
28236: LD_INT 1
28238: NEG
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: LIST
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28269: LD_ADDR_VAR 0 24
28273: PUSH
28274: LD_INT 0
28276: PUSH
28277: LD_INT 0
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: PUSH
28284: LD_INT 0
28286: PUSH
28287: LD_INT 1
28289: NEG
28290: PUSH
28291: EMPTY
28292: LIST
28293: LIST
28294: PUSH
28295: LD_INT 1
28297: PUSH
28298: LD_INT 0
28300: PUSH
28301: EMPTY
28302: LIST
28303: LIST
28304: PUSH
28305: LD_INT 1
28307: PUSH
28308: LD_INT 1
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 0
28317: PUSH
28318: LD_INT 1
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 1
28327: NEG
28328: PUSH
28329: LD_INT 0
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: LD_INT 1
28338: NEG
28339: PUSH
28340: LD_INT 1
28342: NEG
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: PUSH
28348: LD_INT 1
28350: NEG
28351: PUSH
28352: LD_INT 2
28354: NEG
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 0
28362: PUSH
28363: LD_INT 2
28365: NEG
28366: PUSH
28367: EMPTY
28368: LIST
28369: LIST
28370: PUSH
28371: LD_INT 1
28373: PUSH
28374: LD_INT 1
28376: NEG
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 2
28384: PUSH
28385: LD_INT 0
28387: PUSH
28388: EMPTY
28389: LIST
28390: LIST
28391: PUSH
28392: LD_INT 2
28394: PUSH
28395: LD_INT 1
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: LD_INT 2
28404: PUSH
28405: LD_INT 2
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: PUSH
28412: LD_INT 1
28414: PUSH
28415: LD_INT 2
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: LD_INT 0
28424: PUSH
28425: LD_INT 2
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 1
28434: NEG
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 2
28445: NEG
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: LD_INT 2
28456: NEG
28457: PUSH
28458: LD_INT 1
28460: NEG
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: LD_INT 2
28468: NEG
28469: PUSH
28470: LD_INT 2
28472: NEG
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 1
28480: PUSH
28481: LD_INT 2
28483: NEG
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PUSH
28489: LD_INT 2
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 3
28502: PUSH
28503: LD_INT 1
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 3
28512: PUSH
28513: LD_INT 2
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: LIST
28524: LIST
28525: LIST
28526: LIST
28527: LIST
28528: LIST
28529: LIST
28530: LIST
28531: LIST
28532: LIST
28533: LIST
28534: LIST
28535: LIST
28536: LIST
28537: LIST
28538: LIST
28539: LIST
28540: LIST
28541: LIST
28542: LIST
28543: LIST
28544: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28545: LD_ADDR_VAR 0 25
28549: PUSH
28550: LD_INT 0
28552: PUSH
28553: LD_INT 0
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 0
28562: PUSH
28563: LD_INT 1
28565: NEG
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PUSH
28571: LD_INT 1
28573: PUSH
28574: LD_INT 0
28576: PUSH
28577: EMPTY
28578: LIST
28579: LIST
28580: PUSH
28581: LD_INT 1
28583: PUSH
28584: LD_INT 1
28586: PUSH
28587: EMPTY
28588: LIST
28589: LIST
28590: PUSH
28591: LD_INT 0
28593: PUSH
28594: LD_INT 1
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: PUSH
28601: LD_INT 1
28603: NEG
28604: PUSH
28605: LD_INT 0
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 1
28614: NEG
28615: PUSH
28616: LD_INT 1
28618: NEG
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: LD_INT 1
28626: NEG
28627: PUSH
28628: LD_INT 2
28630: NEG
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: LD_INT 2
28641: NEG
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: LD_INT 1
28649: PUSH
28650: LD_INT 1
28652: NEG
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: LD_INT 2
28660: PUSH
28661: LD_INT 0
28663: PUSH
28664: EMPTY
28665: LIST
28666: LIST
28667: PUSH
28668: LD_INT 2
28670: PUSH
28671: LD_INT 1
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 2
28680: PUSH
28681: LD_INT 2
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 1
28690: PUSH
28691: LD_INT 2
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: LD_INT 0
28700: PUSH
28701: LD_INT 2
28703: PUSH
28704: EMPTY
28705: LIST
28706: LIST
28707: PUSH
28708: LD_INT 1
28710: NEG
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 2
28721: NEG
28722: PUSH
28723: LD_INT 0
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 2
28732: NEG
28733: PUSH
28734: LD_INT 1
28736: NEG
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 2
28744: NEG
28745: PUSH
28746: LD_INT 2
28748: NEG
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 3
28756: PUSH
28757: LD_INT 1
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 3
28766: PUSH
28767: LD_INT 2
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: LD_INT 2
28776: PUSH
28777: LD_INT 3
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 1
28786: PUSH
28787: LD_INT 3
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: LIST
28807: LIST
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28819: LD_ADDR_VAR 0 26
28823: PUSH
28824: LD_INT 0
28826: PUSH
28827: LD_INT 0
28829: PUSH
28830: EMPTY
28831: LIST
28832: LIST
28833: PUSH
28834: LD_INT 0
28836: PUSH
28837: LD_INT 1
28839: NEG
28840: PUSH
28841: EMPTY
28842: LIST
28843: LIST
28844: PUSH
28845: LD_INT 1
28847: PUSH
28848: LD_INT 0
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 1
28857: PUSH
28858: LD_INT 1
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 0
28867: PUSH
28868: LD_INT 1
28870: PUSH
28871: EMPTY
28872: LIST
28873: LIST
28874: PUSH
28875: LD_INT 1
28877: NEG
28878: PUSH
28879: LD_INT 0
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 1
28888: NEG
28889: PUSH
28890: LD_INT 1
28892: NEG
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: PUSH
28898: LD_INT 1
28900: NEG
28901: PUSH
28902: LD_INT 2
28904: NEG
28905: PUSH
28906: EMPTY
28907: LIST
28908: LIST
28909: PUSH
28910: LD_INT 0
28912: PUSH
28913: LD_INT 2
28915: NEG
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 1
28923: PUSH
28924: LD_INT 1
28926: NEG
28927: PUSH
28928: EMPTY
28929: LIST
28930: LIST
28931: PUSH
28932: LD_INT 2
28934: PUSH
28935: LD_INT 0
28937: PUSH
28938: EMPTY
28939: LIST
28940: LIST
28941: PUSH
28942: LD_INT 2
28944: PUSH
28945: LD_INT 1
28947: PUSH
28948: EMPTY
28949: LIST
28950: LIST
28951: PUSH
28952: LD_INT 2
28954: PUSH
28955: LD_INT 2
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 1
28964: PUSH
28965: LD_INT 2
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 0
28974: PUSH
28975: LD_INT 2
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 1
28984: NEG
28985: PUSH
28986: LD_INT 1
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PUSH
28993: LD_INT 2
28995: NEG
28996: PUSH
28997: LD_INT 0
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PUSH
29004: LD_INT 2
29006: NEG
29007: PUSH
29008: LD_INT 1
29010: NEG
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PUSH
29016: LD_INT 2
29018: NEG
29019: PUSH
29020: LD_INT 2
29022: NEG
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: LD_INT 2
29030: PUSH
29031: LD_INT 3
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: LD_INT 1
29040: PUSH
29041: LD_INT 3
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 1
29050: NEG
29051: PUSH
29052: LD_INT 2
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: PUSH
29059: LD_INT 2
29061: NEG
29062: PUSH
29063: LD_INT 1
29065: PUSH
29066: EMPTY
29067: LIST
29068: LIST
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: LIST
29074: LIST
29075: LIST
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: LIST
29091: LIST
29092: LIST
29093: LIST
29094: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29095: LD_ADDR_VAR 0 27
29099: PUSH
29100: LD_INT 0
29102: PUSH
29103: LD_INT 0
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 0
29112: PUSH
29113: LD_INT 1
29115: NEG
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: PUSH
29121: LD_INT 1
29123: PUSH
29124: LD_INT 0
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 1
29133: PUSH
29134: LD_INT 1
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 0
29143: PUSH
29144: LD_INT 1
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 1
29153: NEG
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 1
29164: NEG
29165: PUSH
29166: LD_INT 1
29168: NEG
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 1
29176: NEG
29177: PUSH
29178: LD_INT 2
29180: NEG
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: LD_INT 0
29188: PUSH
29189: LD_INT 2
29191: NEG
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: LD_INT 1
29199: PUSH
29200: LD_INT 1
29202: NEG
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 2
29210: PUSH
29211: LD_INT 0
29213: PUSH
29214: EMPTY
29215: LIST
29216: LIST
29217: PUSH
29218: LD_INT 2
29220: PUSH
29221: LD_INT 1
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 2
29230: PUSH
29231: LD_INT 2
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 1
29240: PUSH
29241: LD_INT 2
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: LD_INT 2
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: NEG
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 2
29271: NEG
29272: PUSH
29273: LD_INT 0
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 2
29282: NEG
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 2
29294: NEG
29295: PUSH
29296: LD_INT 2
29298: NEG
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: LD_INT 2
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: LD_INT 1
29321: PUSH
29322: EMPTY
29323: LIST
29324: LIST
29325: PUSH
29326: LD_INT 3
29328: NEG
29329: PUSH
29330: LD_INT 1
29332: NEG
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 3
29340: NEG
29341: PUSH
29342: LD_INT 2
29344: NEG
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: LIST
29354: LIST
29355: LIST
29356: LIST
29357: LIST
29358: LIST
29359: LIST
29360: LIST
29361: LIST
29362: LIST
29363: LIST
29364: LIST
29365: LIST
29366: LIST
29367: LIST
29368: LIST
29369: LIST
29370: LIST
29371: LIST
29372: LIST
29373: LIST
29374: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29375: LD_ADDR_VAR 0 28
29379: PUSH
29380: LD_INT 0
29382: PUSH
29383: LD_INT 0
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PUSH
29390: LD_INT 0
29392: PUSH
29393: LD_INT 1
29395: NEG
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: LD_INT 1
29403: PUSH
29404: LD_INT 0
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 1
29413: PUSH
29414: LD_INT 1
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: PUSH
29421: LD_INT 0
29423: PUSH
29424: LD_INT 1
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 1
29433: NEG
29434: PUSH
29435: LD_INT 0
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 1
29444: NEG
29445: PUSH
29446: LD_INT 1
29448: NEG
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: PUSH
29454: LD_INT 1
29456: NEG
29457: PUSH
29458: LD_INT 2
29460: NEG
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 0
29468: PUSH
29469: LD_INT 2
29471: NEG
29472: PUSH
29473: EMPTY
29474: LIST
29475: LIST
29476: PUSH
29477: LD_INT 1
29479: PUSH
29480: LD_INT 1
29482: NEG
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 2
29490: PUSH
29491: LD_INT 0
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 2
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 2
29510: PUSH
29511: LD_INT 2
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 1
29520: PUSH
29521: LD_INT 2
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 0
29530: PUSH
29531: LD_INT 2
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: NEG
29541: PUSH
29542: LD_INT 1
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PUSH
29549: LD_INT 2
29551: NEG
29552: PUSH
29553: LD_INT 0
29555: PUSH
29556: EMPTY
29557: LIST
29558: LIST
29559: PUSH
29560: LD_INT 2
29562: NEG
29563: PUSH
29564: LD_INT 1
29566: NEG
29567: PUSH
29568: EMPTY
29569: LIST
29570: LIST
29571: PUSH
29572: LD_INT 2
29574: NEG
29575: PUSH
29576: LD_INT 2
29578: NEG
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 2
29586: NEG
29587: PUSH
29588: LD_INT 3
29590: NEG
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: NEG
29599: PUSH
29600: LD_INT 3
29602: NEG
29603: PUSH
29604: EMPTY
29605: LIST
29606: LIST
29607: PUSH
29608: LD_INT 3
29610: NEG
29611: PUSH
29612: LD_INT 1
29614: NEG
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 3
29622: NEG
29623: PUSH
29624: LD_INT 2
29626: NEG
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: LIST
29636: LIST
29637: LIST
29638: LIST
29639: LIST
29640: LIST
29641: LIST
29642: LIST
29643: LIST
29644: LIST
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: LIST
29650: LIST
29651: LIST
29652: LIST
29653: LIST
29654: LIST
29655: LIST
29656: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29657: LD_ADDR_VAR 0 29
29661: PUSH
29662: LD_INT 0
29664: PUSH
29665: LD_INT 0
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: LD_INT 1
29677: NEG
29678: PUSH
29679: EMPTY
29680: LIST
29681: LIST
29682: PUSH
29683: LD_INT 1
29685: PUSH
29686: LD_INT 0
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 1
29695: PUSH
29696: LD_INT 1
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 0
29705: PUSH
29706: LD_INT 1
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: PUSH
29713: LD_INT 1
29715: NEG
29716: PUSH
29717: LD_INT 0
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: LD_INT 1
29726: NEG
29727: PUSH
29728: LD_INT 1
29730: NEG
29731: PUSH
29732: EMPTY
29733: LIST
29734: LIST
29735: PUSH
29736: LD_INT 1
29738: NEG
29739: PUSH
29740: LD_INT 2
29742: NEG
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: LD_INT 0
29750: PUSH
29751: LD_INT 2
29753: NEG
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 1
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 2
29772: PUSH
29773: LD_INT 0
29775: PUSH
29776: EMPTY
29777: LIST
29778: LIST
29779: PUSH
29780: LD_INT 2
29782: PUSH
29783: LD_INT 1
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 1
29792: PUSH
29793: LD_INT 2
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 0
29802: PUSH
29803: LD_INT 2
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 1
29812: NEG
29813: PUSH
29814: LD_INT 1
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 2
29823: NEG
29824: PUSH
29825: LD_INT 1
29827: NEG
29828: PUSH
29829: EMPTY
29830: LIST
29831: LIST
29832: PUSH
29833: LD_INT 2
29835: NEG
29836: PUSH
29837: LD_INT 2
29839: NEG
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 2
29847: NEG
29848: PUSH
29849: LD_INT 3
29851: NEG
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 3
29870: PUSH
29871: LD_INT 1
29873: PUSH
29874: EMPTY
29875: LIST
29876: LIST
29877: PUSH
29878: LD_INT 1
29880: PUSH
29881: LD_INT 3
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 1
29890: NEG
29891: PUSH
29892: LD_INT 2
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 3
29901: NEG
29902: PUSH
29903: LD_INT 2
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: LIST
29915: LIST
29916: LIST
29917: LIST
29918: LIST
29919: LIST
29920: LIST
29921: LIST
29922: LIST
29923: LIST
29924: LIST
29925: LIST
29926: LIST
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29936: LD_ADDR_VAR 0 30
29940: PUSH
29941: LD_INT 0
29943: PUSH
29944: LD_INT 0
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: LD_INT 0
29953: PUSH
29954: LD_INT 1
29956: NEG
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: LD_INT 0
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 1
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 0
29984: PUSH
29985: LD_INT 1
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: LD_INT 0
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PUSH
30003: LD_INT 1
30005: NEG
30006: PUSH
30007: LD_INT 1
30009: NEG
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: NEG
30018: PUSH
30019: LD_INT 2
30021: NEG
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: PUSH
30027: LD_INT 0
30029: PUSH
30030: LD_INT 2
30032: NEG
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 1
30040: PUSH
30041: LD_INT 1
30043: NEG
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: LD_INT 0
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 2
30071: PUSH
30072: LD_INT 2
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 1
30081: PUSH
30082: LD_INT 2
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: NEG
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: LD_INT 2
30102: NEG
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: PUSH
30111: LD_INT 2
30113: NEG
30114: PUSH
30115: LD_INT 1
30117: NEG
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 1
30125: NEG
30126: PUSH
30127: LD_INT 3
30129: NEG
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 1
30137: PUSH
30138: LD_INT 2
30140: NEG
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: PUSH
30146: LD_INT 3
30148: PUSH
30149: LD_INT 2
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 2
30158: PUSH
30159: LD_INT 3
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 2
30168: NEG
30169: PUSH
30170: LD_INT 1
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 3
30179: NEG
30180: PUSH
30181: LD_INT 1
30183: NEG
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: LIST
30211: LIST
30212: LIST
30213: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30214: LD_ADDR_VAR 0 31
30218: PUSH
30219: LD_INT 0
30221: PUSH
30222: LD_INT 0
30224: PUSH
30225: EMPTY
30226: LIST
30227: LIST
30228: PUSH
30229: LD_INT 0
30231: PUSH
30232: LD_INT 1
30234: NEG
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: LD_INT 1
30242: PUSH
30243: LD_INT 0
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: PUSH
30250: LD_INT 1
30252: PUSH
30253: LD_INT 1
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 0
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: NEG
30273: PUSH
30274: LD_INT 0
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 1
30283: NEG
30284: PUSH
30285: LD_INT 1
30287: NEG
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 1
30295: NEG
30296: PUSH
30297: LD_INT 2
30299: NEG
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 1
30307: PUSH
30308: LD_INT 1
30310: NEG
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: LD_INT 2
30318: PUSH
30319: LD_INT 0
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: PUSH
30326: LD_INT 2
30328: PUSH
30329: LD_INT 1
30331: PUSH
30332: EMPTY
30333: LIST
30334: LIST
30335: PUSH
30336: LD_INT 2
30338: PUSH
30339: LD_INT 2
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: LD_INT 2
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 0
30358: PUSH
30359: LD_INT 2
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: NEG
30369: PUSH
30370: LD_INT 1
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: LD_INT 2
30379: NEG
30380: PUSH
30381: LD_INT 1
30383: NEG
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: NEG
30392: PUSH
30393: LD_INT 2
30395: NEG
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 2
30403: NEG
30404: PUSH
30405: LD_INT 3
30407: NEG
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 2
30415: PUSH
30416: LD_INT 1
30418: NEG
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 3
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: PUSH
30437: LD_INT 3
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 1
30446: NEG
30447: PUSH
30448: LD_INT 2
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 3
30457: NEG
30458: PUSH
30459: LD_INT 2
30461: NEG
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: EMPTY
30468: LIST
30469: LIST
30470: LIST
30471: LIST
30472: LIST
30473: LIST
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30492: LD_ADDR_VAR 0 32
30496: PUSH
30497: LD_INT 0
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: PUSH
30507: LD_INT 0
30509: PUSH
30510: LD_INT 1
30512: NEG
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: PUSH
30518: LD_INT 1
30520: PUSH
30521: LD_INT 0
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 1
30530: PUSH
30531: LD_INT 1
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 0
30540: PUSH
30541: LD_INT 1
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 1
30550: NEG
30551: PUSH
30552: LD_INT 0
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: NEG
30562: PUSH
30563: LD_INT 1
30565: NEG
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: PUSH
30571: LD_INT 1
30573: NEG
30574: PUSH
30575: LD_INT 2
30577: NEG
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 0
30585: PUSH
30586: LD_INT 2
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: PUSH
30597: LD_INT 1
30599: NEG
30600: PUSH
30601: EMPTY
30602: LIST
30603: LIST
30604: PUSH
30605: LD_INT 2
30607: PUSH
30608: LD_INT 1
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: PUSH
30615: LD_INT 2
30617: PUSH
30618: LD_INT 2
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 1
30627: PUSH
30628: LD_INT 2
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 0
30637: PUSH
30638: LD_INT 2
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: LD_INT 1
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 2
30658: NEG
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: EMPTY
30664: LIST
30665: LIST
30666: PUSH
30667: LD_INT 2
30669: NEG
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 1
30681: NEG
30682: PUSH
30683: LD_INT 3
30685: NEG
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 1
30693: PUSH
30694: LD_INT 2
30696: NEG
30697: PUSH
30698: EMPTY
30699: LIST
30700: LIST
30701: PUSH
30702: LD_INT 3
30704: PUSH
30705: LD_INT 2
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 2
30714: PUSH
30715: LD_INT 3
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 2
30724: NEG
30725: PUSH
30726: LD_INT 1
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: LD_INT 3
30735: NEG
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: LIST
30762: LIST
30763: LIST
30764: LIST
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30770: LD_ADDR_VAR 0 33
30774: PUSH
30775: LD_INT 0
30777: PUSH
30778: LD_INT 0
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: LD_INT 1
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 0
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 1
30808: PUSH
30809: LD_INT 1
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 0
30818: PUSH
30819: LD_INT 1
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: NEG
30829: PUSH
30830: LD_INT 0
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 1
30839: NEG
30840: PUSH
30841: LD_INT 1
30843: NEG
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: LD_INT 1
30851: NEG
30852: PUSH
30853: LD_INT 2
30855: NEG
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: LD_INT 1
30866: NEG
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: LD_INT 2
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 2
30884: PUSH
30885: LD_INT 1
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 1
30894: PUSH
30895: LD_INT 2
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: LD_INT 2
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 1
30914: NEG
30915: PUSH
30916: LD_INT 1
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 2
30925: NEG
30926: PUSH
30927: LD_INT 0
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: LD_INT 2
30936: NEG
30937: PUSH
30938: LD_INT 1
30940: NEG
30941: PUSH
30942: EMPTY
30943: LIST
30944: LIST
30945: PUSH
30946: LD_INT 2
30948: NEG
30949: PUSH
30950: LD_INT 2
30952: NEG
30953: PUSH
30954: EMPTY
30955: LIST
30956: LIST
30957: PUSH
30958: LD_INT 2
30960: NEG
30961: PUSH
30962: LD_INT 3
30964: NEG
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 2
30972: PUSH
30973: LD_INT 1
30975: NEG
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PUSH
30981: LD_INT 3
30983: PUSH
30984: LD_INT 1
30986: PUSH
30987: EMPTY
30988: LIST
30989: LIST
30990: PUSH
30991: LD_INT 1
30993: PUSH
30994: LD_INT 3
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 1
31003: NEG
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 3
31014: NEG
31015: PUSH
31016: LD_INT 2
31018: NEG
31019: PUSH
31020: EMPTY
31021: LIST
31022: LIST
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: LIST
31042: LIST
31043: LIST
31044: LIST
31045: LIST
31046: LIST
31047: LIST
31048: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31049: LD_ADDR_VAR 0 34
31053: PUSH
31054: LD_INT 0
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: EMPTY
31061: LIST
31062: LIST
31063: PUSH
31064: LD_INT 0
31066: PUSH
31067: LD_INT 1
31069: NEG
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: PUSH
31075: LD_INT 1
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: LD_INT 1
31087: PUSH
31088: LD_INT 1
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 0
31097: PUSH
31098: LD_INT 1
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 1
31107: NEG
31108: PUSH
31109: LD_INT 0
31111: PUSH
31112: EMPTY
31113: LIST
31114: LIST
31115: PUSH
31116: LD_INT 1
31118: NEG
31119: PUSH
31120: LD_INT 1
31122: NEG
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 1
31130: NEG
31131: PUSH
31132: LD_INT 2
31134: NEG
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: LD_INT 2
31145: NEG
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 1
31153: PUSH
31154: LD_INT 1
31156: NEG
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 2
31164: PUSH
31165: LD_INT 1
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: PUSH
31175: LD_INT 2
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 1
31184: PUSH
31185: LD_INT 2
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 1
31194: NEG
31195: PUSH
31196: LD_INT 1
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 2
31205: NEG
31206: PUSH
31207: LD_INT 0
31209: PUSH
31210: EMPTY
31211: LIST
31212: LIST
31213: PUSH
31214: LD_INT 2
31216: NEG
31217: PUSH
31218: LD_INT 1
31220: NEG
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 2
31228: NEG
31229: PUSH
31230: LD_INT 2
31232: NEG
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 1
31240: NEG
31241: PUSH
31242: LD_INT 3
31244: NEG
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 1
31252: PUSH
31253: LD_INT 2
31255: NEG
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 3
31263: PUSH
31264: LD_INT 2
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 2
31273: PUSH
31274: LD_INT 3
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 2
31283: NEG
31284: PUSH
31285: LD_INT 1
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 3
31294: NEG
31295: PUSH
31296: LD_INT 1
31298: NEG
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31329: LD_ADDR_VAR 0 35
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: PUSH
31358: LD_INT 0
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 1
31367: PUSH
31368: LD_INT 1
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 0
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 1
31387: NEG
31388: PUSH
31389: LD_INT 0
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 2
31410: PUSH
31411: LD_INT 1
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: LD_INT 1
31424: NEG
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31441: LD_ADDR_VAR 0 36
31445: PUSH
31446: LD_INT 0
31448: PUSH
31449: LD_INT 0
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: PUSH
31456: LD_INT 0
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 1
31469: PUSH
31470: LD_INT 0
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 1
31479: PUSH
31480: LD_INT 1
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 0
31489: PUSH
31490: LD_INT 1
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: LD_INT 0
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PUSH
31508: LD_INT 1
31510: NEG
31511: PUSH
31512: LD_INT 1
31514: NEG
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 1
31522: NEG
31523: PUSH
31524: LD_INT 2
31526: NEG
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 1
31534: PUSH
31535: LD_INT 2
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31553: LD_ADDR_VAR 0 37
31557: PUSH
31558: LD_INT 0
31560: PUSH
31561: LD_INT 0
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 0
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 1
31581: PUSH
31582: LD_INT 0
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: LD_INT 1
31591: PUSH
31592: LD_INT 1
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 0
31601: PUSH
31602: LD_INT 1
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: LD_INT 1
31611: NEG
31612: PUSH
31613: LD_INT 0
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 1
31622: NEG
31623: PUSH
31624: LD_INT 1
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 1
31634: PUSH
31635: LD_INT 1
31637: NEG
31638: PUSH
31639: EMPTY
31640: LIST
31641: LIST
31642: PUSH
31643: LD_INT 1
31645: NEG
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: EMPTY
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31665: LD_ADDR_VAR 0 38
31669: PUSH
31670: LD_INT 0
31672: PUSH
31673: LD_INT 0
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 0
31682: PUSH
31683: LD_INT 1
31685: NEG
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PUSH
31691: LD_INT 1
31693: PUSH
31694: LD_INT 0
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 1
31703: PUSH
31704: LD_INT 1
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 0
31713: PUSH
31714: LD_INT 1
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 1
31723: NEG
31724: PUSH
31725: LD_INT 0
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: NEG
31735: PUSH
31736: LD_INT 1
31738: NEG
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 2
31746: PUSH
31747: LD_INT 1
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: LD_INT 2
31756: NEG
31757: PUSH
31758: LD_INT 1
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31777: LD_ADDR_VAR 0 39
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: LD_INT 0
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: LD_INT 1
31797: NEG
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 1
31805: PUSH
31806: LD_INT 0
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: PUSH
31816: LD_INT 1
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 0
31825: PUSH
31826: LD_INT 1
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 1
31835: NEG
31836: PUSH
31837: LD_INT 0
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 1
31846: NEG
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: LD_INT 2
31862: NEG
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 1
31870: PUSH
31871: LD_INT 2
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31889: LD_ADDR_VAR 0 40
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 0
31906: PUSH
31907: LD_INT 1
31909: NEG
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 1
31917: PUSH
31918: LD_INT 0
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: PUSH
31928: LD_INT 1
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: LD_INT 1
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: LD_INT 1
31947: NEG
31948: PUSH
31949: LD_INT 0
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: NEG
31959: PUSH
31960: LD_INT 1
31962: NEG
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 1
31970: PUSH
31971: LD_INT 1
31973: NEG
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 1
31981: NEG
31982: PUSH
31983: LD_INT 1
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: LIST
31994: LIST
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32001: LD_ADDR_VAR 0 41
32005: PUSH
32006: LD_INT 0
32008: PUSH
32009: LD_INT 0
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: LD_INT 0
32018: PUSH
32019: LD_INT 1
32021: NEG
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 1
32029: PUSH
32030: LD_INT 0
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 1
32039: PUSH
32040: LD_INT 1
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 1
32059: NEG
32060: PUSH
32061: LD_INT 0
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 1
32070: NEG
32071: PUSH
32072: LD_INT 1
32074: NEG
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 1
32082: NEG
32083: PUSH
32084: LD_INT 2
32086: NEG
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: LD_INT 1
32097: NEG
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 2
32105: PUSH
32106: LD_INT 0
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 2
32115: PUSH
32116: LD_INT 1
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 2
32125: PUSH
32126: LD_INT 2
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: LD_INT 2
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 1
32145: NEG
32146: PUSH
32147: LD_INT 1
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: NEG
32157: PUSH
32158: LD_INT 0
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 2
32167: NEG
32168: PUSH
32169: LD_INT 1
32171: NEG
32172: PUSH
32173: EMPTY
32174: LIST
32175: LIST
32176: PUSH
32177: LD_INT 2
32179: NEG
32180: PUSH
32181: LD_INT 2
32183: NEG
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: NEG
32192: PUSH
32193: LD_INT 3
32195: NEG
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 2
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 3
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 3
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 3
32234: PUSH
32235: LD_INT 2
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 3
32244: PUSH
32245: LD_INT 3
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 2
32254: PUSH
32255: LD_INT 3
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 2
32264: NEG
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 3
32275: NEG
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 3
32286: NEG
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: LD_INT 3
32298: NEG
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 3
32310: NEG
32311: PUSH
32312: LD_INT 3
32314: NEG
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: LIST
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: LIST
32350: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32351: LD_ADDR_VAR 0 42
32355: PUSH
32356: LD_INT 0
32358: PUSH
32359: LD_INT 0
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: LD_INT 1
32371: NEG
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: LD_INT 0
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: LD_INT 1
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 0
32399: PUSH
32400: LD_INT 1
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 1
32409: NEG
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 1
32420: NEG
32421: PUSH
32422: LD_INT 1
32424: NEG
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 1
32432: NEG
32433: PUSH
32434: LD_INT 2
32436: NEG
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 0
32444: PUSH
32445: LD_INT 2
32447: NEG
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 1
32455: PUSH
32456: LD_INT 1
32458: NEG
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 2
32466: PUSH
32467: LD_INT 1
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 2
32476: PUSH
32477: LD_INT 2
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 1
32486: PUSH
32487: LD_INT 2
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: LD_INT 2
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: LD_INT 1
32506: NEG
32507: PUSH
32508: LD_INT 1
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: LD_INT 2
32517: NEG
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: EMPTY
32524: LIST
32525: LIST
32526: PUSH
32527: LD_INT 2
32529: NEG
32530: PUSH
32531: LD_INT 2
32533: NEG
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 2
32541: NEG
32542: PUSH
32543: LD_INT 3
32545: NEG
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 1
32553: NEG
32554: PUSH
32555: LD_INT 3
32557: NEG
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 0
32565: PUSH
32566: LD_INT 3
32568: NEG
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 1
32576: PUSH
32577: LD_INT 2
32579: NEG
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 3
32587: PUSH
32588: LD_INT 2
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 3
32597: PUSH
32598: LD_INT 3
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 2
32607: PUSH
32608: LD_INT 3
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 1
32617: PUSH
32618: LD_INT 3
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 0
32627: PUSH
32628: LD_INT 3
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 1
32637: NEG
32638: PUSH
32639: LD_INT 2
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 3
32648: NEG
32649: PUSH
32650: LD_INT 2
32652: NEG
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 3
32660: NEG
32661: PUSH
32662: LD_INT 3
32664: NEG
32665: PUSH
32666: EMPTY
32667: LIST
32668: LIST
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32701: LD_ADDR_VAR 0 43
32705: PUSH
32706: LD_INT 0
32708: PUSH
32709: LD_INT 0
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: LD_INT 1
32721: NEG
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: PUSH
32730: LD_INT 0
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: PUSH
32740: LD_INT 1
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: NEG
32760: PUSH
32761: LD_INT 0
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 1
32770: NEG
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 1
32782: NEG
32783: PUSH
32784: LD_INT 2
32786: NEG
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: LD_INT 2
32797: NEG
32798: PUSH
32799: EMPTY
32800: LIST
32801: LIST
32802: PUSH
32803: LD_INT 1
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: EMPTY
32811: LIST
32812: LIST
32813: PUSH
32814: LD_INT 2
32816: PUSH
32817: LD_INT 0
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 2
32826: PUSH
32827: LD_INT 1
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 1
32836: PUSH
32837: LD_INT 2
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 0
32846: PUSH
32847: LD_INT 2
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: NEG
32857: PUSH
32858: LD_INT 1
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 2
32867: NEG
32868: PUSH
32869: LD_INT 0
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 2
32878: NEG
32879: PUSH
32880: LD_INT 1
32882: NEG
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 1
32890: NEG
32891: PUSH
32892: LD_INT 3
32894: NEG
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 0
32902: PUSH
32903: LD_INT 3
32905: NEG
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 1
32913: PUSH
32914: LD_INT 2
32916: NEG
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 2
32924: PUSH
32925: LD_INT 1
32927: NEG
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: PUSH
32933: LD_INT 3
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 3
32945: PUSH
32946: LD_INT 1
32948: PUSH
32949: EMPTY
32950: LIST
32951: LIST
32952: PUSH
32953: LD_INT 1
32955: PUSH
32956: LD_INT 3
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 0
32965: PUSH
32966: LD_INT 3
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 1
32975: NEG
32976: PUSH
32977: LD_INT 2
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 2
32986: NEG
32987: PUSH
32988: LD_INT 1
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 3
32997: NEG
32998: PUSH
32999: LD_INT 0
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 3
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: LIST
33022: LIST
33023: LIST
33024: LIST
33025: LIST
33026: LIST
33027: LIST
33028: LIST
33029: LIST
33030: LIST
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33049: LD_ADDR_VAR 0 44
33053: PUSH
33054: LD_INT 0
33056: PUSH
33057: LD_INT 0
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 0
33066: PUSH
33067: LD_INT 1
33069: NEG
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: PUSH
33078: LD_INT 0
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 1
33087: PUSH
33088: LD_INT 1
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 0
33097: PUSH
33098: LD_INT 1
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 1
33107: NEG
33108: PUSH
33109: LD_INT 0
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 1
33118: NEG
33119: PUSH
33120: LD_INT 1
33122: NEG
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 1
33130: NEG
33131: PUSH
33132: LD_INT 2
33134: NEG
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: LD_INT 1
33142: PUSH
33143: LD_INT 1
33145: NEG
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: PUSH
33151: LD_INT 2
33153: PUSH
33154: LD_INT 0
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 2
33163: PUSH
33164: LD_INT 1
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 2
33173: PUSH
33174: LD_INT 2
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: LD_INT 2
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 1
33193: NEG
33194: PUSH
33195: LD_INT 1
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 2
33204: NEG
33205: PUSH
33206: LD_INT 0
33208: PUSH
33209: EMPTY
33210: LIST
33211: LIST
33212: PUSH
33213: LD_INT 2
33215: NEG
33216: PUSH
33217: LD_INT 1
33219: NEG
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: LD_INT 2
33227: NEG
33228: PUSH
33229: LD_INT 2
33231: NEG
33232: PUSH
33233: EMPTY
33234: LIST
33235: LIST
33236: PUSH
33237: LD_INT 2
33239: NEG
33240: PUSH
33241: LD_INT 3
33243: NEG
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PUSH
33249: LD_INT 2
33251: PUSH
33252: LD_INT 1
33254: NEG
33255: PUSH
33256: EMPTY
33257: LIST
33258: LIST
33259: PUSH
33260: LD_INT 3
33262: PUSH
33263: LD_INT 0
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 3
33272: PUSH
33273: LD_INT 1
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 3
33282: PUSH
33283: LD_INT 2
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 3
33292: PUSH
33293: LD_INT 3
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 2
33302: PUSH
33303: LD_INT 3
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 2
33312: NEG
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 3
33323: NEG
33324: PUSH
33325: LD_INT 0
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 3
33334: NEG
33335: PUSH
33336: LD_INT 1
33338: NEG
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 3
33346: NEG
33347: PUSH
33348: LD_INT 2
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 3
33358: NEG
33359: PUSH
33360: LD_INT 3
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: LIST
33379: LIST
33380: LIST
33381: LIST
33382: LIST
33383: LIST
33384: LIST
33385: LIST
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33399: LD_ADDR_VAR 0 45
33403: PUSH
33404: LD_INT 0
33406: PUSH
33407: LD_INT 0
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 0
33416: PUSH
33417: LD_INT 1
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 1
33427: PUSH
33428: LD_INT 0
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 1
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 0
33447: PUSH
33448: LD_INT 1
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 1
33457: NEG
33458: PUSH
33459: LD_INT 0
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: NEG
33469: PUSH
33470: LD_INT 1
33472: NEG
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 1
33480: NEG
33481: PUSH
33482: LD_INT 2
33484: NEG
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 0
33492: PUSH
33493: LD_INT 2
33495: NEG
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 1
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 2
33514: PUSH
33515: LD_INT 1
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 2
33524: PUSH
33525: LD_INT 2
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 1
33534: PUSH
33535: LD_INT 2
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: LD_INT 2
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: NEG
33555: PUSH
33556: LD_INT 1
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 2
33565: NEG
33566: PUSH
33567: LD_INT 1
33569: NEG
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 2
33577: NEG
33578: PUSH
33579: LD_INT 2
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 2
33589: NEG
33590: PUSH
33591: LD_INT 3
33593: NEG
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 1
33601: NEG
33602: PUSH
33603: LD_INT 3
33605: NEG
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 0
33613: PUSH
33614: LD_INT 3
33616: NEG
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: LD_INT 2
33627: NEG
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 3
33635: PUSH
33636: LD_INT 2
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 3
33645: PUSH
33646: LD_INT 3
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 2
33655: PUSH
33656: LD_INT 3
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: LD_INT 3
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 0
33675: PUSH
33676: LD_INT 3
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: LD_INT 2
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 3
33696: NEG
33697: PUSH
33698: LD_INT 2
33700: NEG
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 3
33708: NEG
33709: PUSH
33710: LD_INT 3
33712: NEG
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: LIST
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33749: LD_ADDR_VAR 0 46
33753: PUSH
33754: LD_INT 0
33756: PUSH
33757: LD_INT 0
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 0
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: LD_INT 0
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 1
33787: PUSH
33788: LD_INT 1
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 0
33797: PUSH
33798: LD_INT 1
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: NEG
33808: PUSH
33809: LD_INT 0
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 1
33818: NEG
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 1
33830: NEG
33831: PUSH
33832: LD_INT 2
33834: NEG
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 2
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: LD_INT 1
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 2
33864: PUSH
33865: LD_INT 0
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 2
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 1
33884: PUSH
33885: LD_INT 2
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 0
33894: PUSH
33895: LD_INT 2
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: LD_INT 1
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 2
33915: NEG
33916: PUSH
33917: LD_INT 0
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 2
33926: NEG
33927: PUSH
33928: LD_INT 1
33930: NEG
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 1
33938: NEG
33939: PUSH
33940: LD_INT 3
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 3
33953: NEG
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 2
33964: NEG
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 2
33972: PUSH
33973: LD_INT 1
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 3
33983: PUSH
33984: LD_INT 0
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 3
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 1
34003: PUSH
34004: LD_INT 3
34006: PUSH
34007: EMPTY
34008: LIST
34009: LIST
34010: PUSH
34011: LD_INT 0
34013: PUSH
34014: LD_INT 3
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: LD_INT 2
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 2
34034: NEG
34035: PUSH
34036: LD_INT 1
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 3
34045: NEG
34046: PUSH
34047: LD_INT 0
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 3
34056: NEG
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34097: LD_ADDR_VAR 0 47
34101: PUSH
34102: LD_INT 0
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: LD_INT 1
34117: NEG
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 1
34125: PUSH
34126: LD_INT 0
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 1
34135: PUSH
34136: LD_INT 1
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 0
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: NEG
34156: PUSH
34157: LD_INT 0
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 1
34166: NEG
34167: PUSH
34168: LD_INT 1
34170: NEG
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 1
34178: NEG
34179: PUSH
34180: LD_INT 2
34182: NEG
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 0
34190: PUSH
34191: LD_INT 2
34193: NEG
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: PUSH
34202: LD_INT 1
34204: NEG
34205: PUSH
34206: EMPTY
34207: LIST
34208: LIST
34209: PUSH
34210: LD_INT 2
34212: NEG
34213: PUSH
34214: LD_INT 1
34216: NEG
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 2
34224: NEG
34225: PUSH
34226: LD_INT 2
34228: NEG
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34248: LD_ADDR_VAR 0 48
34252: PUSH
34253: LD_INT 0
34255: PUSH
34256: LD_INT 0
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 0
34265: PUSH
34266: LD_INT 1
34268: NEG
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: LD_INT 0
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 1
34286: PUSH
34287: LD_INT 1
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 0
34296: PUSH
34297: LD_INT 1
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: LD_INT 1
34306: NEG
34307: PUSH
34308: LD_INT 0
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: LD_INT 1
34321: NEG
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 1
34329: NEG
34330: PUSH
34331: LD_INT 2
34333: NEG
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 0
34341: PUSH
34342: LD_INT 2
34344: NEG
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 1
34352: PUSH
34353: LD_INT 1
34355: NEG
34356: PUSH
34357: EMPTY
34358: LIST
34359: LIST
34360: PUSH
34361: LD_INT 2
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 2
34373: PUSH
34374: LD_INT 1
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34395: LD_ADDR_VAR 0 49
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 0
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: LD_INT 1
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: NEG
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: NEG
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: LD_INT 0
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: LD_INT 1
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: LD_INT 2
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 1
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: LIST
34529: LIST
34530: LIST
34531: LIST
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34539: LD_ADDR_VAR 0 50
34543: PUSH
34544: LD_INT 0
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 0
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 1
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: LD_INT 1
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 1
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 1
34597: NEG
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: NEG
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 2
34620: PUSH
34621: LD_INT 1
34623: PUSH
34624: EMPTY
34625: LIST
34626: LIST
34627: PUSH
34628: LD_INT 2
34630: PUSH
34631: LD_INT 2
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 1
34640: PUSH
34641: LD_INT 2
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 0
34650: PUSH
34651: LD_INT 2
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: NEG
34661: PUSH
34662: LD_INT 1
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34683: LD_ADDR_VAR 0 51
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: LD_INT 0
34693: PUSH
34694: EMPTY
34695: LIST
34696: LIST
34697: PUSH
34698: LD_INT 0
34700: PUSH
34701: LD_INT 1
34703: NEG
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 1
34721: PUSH
34722: LD_INT 1
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 0
34731: PUSH
34732: LD_INT 1
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 1
34741: NEG
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 1
34752: NEG
34753: PUSH
34754: LD_INT 1
34756: NEG
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 1
34764: PUSH
34765: LD_INT 2
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 0
34774: PUSH
34775: LD_INT 2
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 2
34795: NEG
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 2
34806: NEG
34807: PUSH
34808: LD_INT 1
34810: NEG
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34830: LD_ADDR_VAR 0 52
34834: PUSH
34835: LD_INT 0
34837: PUSH
34838: LD_INT 0
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 0
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 1
34858: PUSH
34859: LD_INT 0
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 1
34868: PUSH
34869: LD_INT 1
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 0
34878: PUSH
34879: LD_INT 1
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 1
34888: NEG
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 1
34899: NEG
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 1
34911: NEG
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: LD_INT 1
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 2
34934: NEG
34935: PUSH
34936: LD_INT 0
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 2
34945: NEG
34946: PUSH
34947: LD_INT 1
34949: NEG
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: NEG
34958: PUSH
34959: LD_INT 2
34961: NEG
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: LIST
34973: LIST
34974: LIST
34975: LIST
34976: LIST
34977: LIST
34978: LIST
34979: LIST
34980: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34981: LD_ADDR_VAR 0 53
34985: PUSH
34986: LD_INT 0
34988: PUSH
34989: LD_INT 0
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 0
34998: PUSH
34999: LD_INT 1
35001: NEG
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 1
35009: PUSH
35010: LD_INT 0
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 1
35019: PUSH
35020: LD_INT 1
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: LD_INT 0
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 1
35050: NEG
35051: PUSH
35052: LD_INT 1
35054: NEG
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 1
35062: NEG
35063: PUSH
35064: LD_INT 2
35066: NEG
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 0
35074: PUSH
35075: LD_INT 2
35077: NEG
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 1
35085: PUSH
35086: LD_INT 1
35088: NEG
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 2
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 2
35106: PUSH
35107: LD_INT 1
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 2
35116: PUSH
35117: LD_INT 2
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: LD_INT 2
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 0
35136: PUSH
35137: LD_INT 2
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: NEG
35147: PUSH
35148: LD_INT 1
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 2
35157: NEG
35158: PUSH
35159: LD_INT 0
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 2
35168: NEG
35169: PUSH
35170: LD_INT 1
35172: NEG
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: NEG
35181: PUSH
35182: LD_INT 2
35184: NEG
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: LIST
35197: LIST
35198: LIST
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: LIST
35204: LIST
35205: LIST
35206: LIST
35207: LIST
35208: LIST
35209: LIST
35210: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35211: LD_ADDR_VAR 0 54
35215: PUSH
35216: LD_INT 0
35218: PUSH
35219: LD_INT 0
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: LD_INT 1
35231: NEG
35232: PUSH
35233: EMPTY
35234: LIST
35235: LIST
35236: PUSH
35237: LD_INT 1
35239: PUSH
35240: LD_INT 0
35242: PUSH
35243: EMPTY
35244: LIST
35245: LIST
35246: PUSH
35247: LD_INT 1
35249: PUSH
35250: LD_INT 1
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: NEG
35270: PUSH
35271: LD_INT 0
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 1
35280: NEG
35281: PUSH
35282: LD_INT 1
35284: NEG
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: LD_INT 2
35296: NEG
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 2
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 2
35326: PUSH
35327: LD_INT 0
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 2
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 2
35346: PUSH
35347: LD_INT 2
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: PUSH
35357: LD_INT 2
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 0
35366: PUSH
35367: LD_INT 2
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 1
35376: NEG
35377: PUSH
35378: LD_INT 1
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 2
35387: NEG
35388: PUSH
35389: LD_INT 0
35391: PUSH
35392: EMPTY
35393: LIST
35394: LIST
35395: PUSH
35396: LD_INT 2
35398: NEG
35399: PUSH
35400: LD_INT 1
35402: NEG
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 2
35410: NEG
35411: PUSH
35412: LD_INT 2
35414: NEG
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35441: LD_ADDR_VAR 0 55
35445: PUSH
35446: LD_INT 0
35448: PUSH
35449: LD_INT 0
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: LD_INT 1
35461: NEG
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 1
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: PUSH
35480: LD_INT 1
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: LD_INT 1
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 1
35522: NEG
35523: PUSH
35524: LD_INT 2
35526: NEG
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 0
35534: PUSH
35535: LD_INT 2
35537: NEG
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PUSH
35543: LD_INT 1
35545: PUSH
35546: LD_INT 1
35548: NEG
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 2
35556: PUSH
35557: LD_INT 0
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 2
35566: PUSH
35567: LD_INT 1
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 2
35576: PUSH
35577: LD_INT 2
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 1
35586: PUSH
35587: LD_INT 2
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: LD_INT 2
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: LD_INT 1
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 2
35617: NEG
35618: PUSH
35619: LD_INT 0
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 2
35628: NEG
35629: PUSH
35630: LD_INT 1
35632: NEG
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: NEG
35641: PUSH
35642: LD_INT 2
35644: NEG
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: LIST
35662: LIST
35663: LIST
35664: LIST
35665: LIST
35666: LIST
35667: LIST
35668: LIST
35669: LIST
35670: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35671: LD_ADDR_VAR 0 56
35675: PUSH
35676: LD_INT 0
35678: PUSH
35679: LD_INT 0
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: LD_INT 1
35691: NEG
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 1
35699: PUSH
35700: LD_INT 0
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 1
35709: PUSH
35710: LD_INT 1
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: LD_INT 0
35719: PUSH
35720: LD_INT 1
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: LD_INT 1
35729: NEG
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 1
35740: NEG
35741: PUSH
35742: LD_INT 1
35744: NEG
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: LD_INT 2
35756: NEG
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 0
35764: PUSH
35765: LD_INT 2
35767: NEG
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 1
35775: PUSH
35776: LD_INT 1
35778: NEG
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 2
35786: PUSH
35787: LD_INT 0
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 2
35796: PUSH
35797: LD_INT 1
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 2
35806: PUSH
35807: LD_INT 2
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 1
35816: PUSH
35817: LD_INT 2
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 0
35826: PUSH
35827: LD_INT 2
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 1
35836: NEG
35837: PUSH
35838: LD_INT 1
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: LD_INT 2
35847: NEG
35848: PUSH
35849: LD_INT 0
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 2
35858: NEG
35859: PUSH
35860: LD_INT 1
35862: NEG
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 2
35870: NEG
35871: PUSH
35872: LD_INT 2
35874: NEG
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: LIST
35884: LIST
35885: LIST
35886: LIST
35887: LIST
35888: LIST
35889: LIST
35890: LIST
35891: LIST
35892: LIST
35893: LIST
35894: LIST
35895: LIST
35896: LIST
35897: LIST
35898: LIST
35899: LIST
35900: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35901: LD_ADDR_VAR 0 57
35905: PUSH
35906: LD_INT 0
35908: PUSH
35909: LD_INT 0
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 0
35918: PUSH
35919: LD_INT 1
35921: NEG
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: PUSH
35927: LD_INT 1
35929: PUSH
35930: LD_INT 0
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 1
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 0
35949: PUSH
35950: LD_INT 1
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: NEG
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 1
35970: NEG
35971: PUSH
35972: LD_INT 1
35974: NEG
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 1
35982: NEG
35983: PUSH
35984: LD_INT 2
35986: NEG
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 0
35994: PUSH
35995: LD_INT 2
35997: NEG
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PUSH
36003: LD_INT 1
36005: PUSH
36006: LD_INT 1
36008: NEG
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 2
36016: PUSH
36017: LD_INT 0
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 2
36026: PUSH
36027: LD_INT 1
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 2
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: LD_INT 2
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 0
36056: PUSH
36057: LD_INT 2
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 1
36066: NEG
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 2
36077: NEG
36078: PUSH
36079: LD_INT 0
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 2
36088: NEG
36089: PUSH
36090: LD_INT 1
36092: NEG
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 2
36100: NEG
36101: PUSH
36102: LD_INT 2
36104: NEG
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36131: LD_ADDR_VAR 0 58
36135: PUSH
36136: LD_INT 0
36138: PUSH
36139: LD_INT 0
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: LD_INT 1
36151: NEG
36152: PUSH
36153: EMPTY
36154: LIST
36155: LIST
36156: PUSH
36157: LD_INT 1
36159: PUSH
36160: LD_INT 0
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 1
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 0
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: NEG
36190: PUSH
36191: LD_INT 0
36193: PUSH
36194: EMPTY
36195: LIST
36196: LIST
36197: PUSH
36198: LD_INT 1
36200: NEG
36201: PUSH
36202: LD_INT 1
36204: NEG
36205: PUSH
36206: EMPTY
36207: LIST
36208: LIST
36209: PUSH
36210: LD_INT 1
36212: NEG
36213: PUSH
36214: LD_INT 2
36216: NEG
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 0
36224: PUSH
36225: LD_INT 2
36227: NEG
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: LD_INT 1
36235: PUSH
36236: LD_INT 1
36238: NEG
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 2
36246: PUSH
36247: LD_INT 0
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 2
36256: PUSH
36257: LD_INT 1
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 2
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 1
36276: PUSH
36277: LD_INT 2
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: LD_INT 2
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 1
36296: NEG
36297: PUSH
36298: LD_INT 1
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 2
36307: NEG
36308: PUSH
36309: LD_INT 0
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 2
36318: NEG
36319: PUSH
36320: LD_INT 1
36322: NEG
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: LD_INT 2
36330: NEG
36331: PUSH
36332: LD_INT 2
36334: NEG
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: LIST
36358: LIST
36359: LIST
36360: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36361: LD_ADDR_VAR 0 59
36365: PUSH
36366: LD_INT 0
36368: PUSH
36369: LD_INT 0
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 0
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 1
36389: PUSH
36390: LD_INT 0
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 1
36399: PUSH
36400: LD_INT 1
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 0
36409: PUSH
36410: LD_INT 1
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: NEG
36420: PUSH
36421: LD_INT 0
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 1
36430: NEG
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36449: LD_ADDR_VAR 0 60
36453: PUSH
36454: LD_INT 0
36456: PUSH
36457: LD_INT 0
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: PUSH
36464: LD_INT 0
36466: PUSH
36467: LD_INT 1
36469: NEG
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 1
36477: PUSH
36478: LD_INT 0
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 1
36487: PUSH
36488: LD_INT 1
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 0
36497: PUSH
36498: LD_INT 1
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 1
36507: NEG
36508: PUSH
36509: LD_INT 0
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 1
36518: NEG
36519: PUSH
36520: LD_INT 1
36522: NEG
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36537: LD_ADDR_VAR 0 61
36541: PUSH
36542: LD_INT 0
36544: PUSH
36545: LD_INT 0
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 1
36557: NEG
36558: PUSH
36559: EMPTY
36560: LIST
36561: LIST
36562: PUSH
36563: LD_INT 1
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: PUSH
36576: LD_INT 1
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 0
36585: PUSH
36586: LD_INT 1
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: NEG
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 1
36606: NEG
36607: PUSH
36608: LD_INT 1
36610: NEG
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: EMPTY
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36625: LD_ADDR_VAR 0 62
36629: PUSH
36630: LD_INT 0
36632: PUSH
36633: LD_INT 0
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: PUSH
36640: LD_INT 0
36642: PUSH
36643: LD_INT 1
36645: NEG
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: LD_INT 1
36653: PUSH
36654: LD_INT 0
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 1
36663: PUSH
36664: LD_INT 1
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 0
36673: PUSH
36674: LD_INT 1
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: NEG
36684: PUSH
36685: LD_INT 0
36687: PUSH
36688: EMPTY
36689: LIST
36690: LIST
36691: PUSH
36692: LD_INT 1
36694: NEG
36695: PUSH
36696: LD_INT 1
36698: NEG
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: LIST
36710: LIST
36711: LIST
36712: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36713: LD_ADDR_VAR 0 63
36717: PUSH
36718: LD_INT 0
36720: PUSH
36721: LD_INT 0
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: LD_INT 1
36733: NEG
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: LD_INT 0
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 1
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: LD_INT 1
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 1
36771: NEG
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 1
36782: NEG
36783: PUSH
36784: LD_INT 1
36786: NEG
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36801: LD_ADDR_VAR 0 64
36805: PUSH
36806: LD_INT 0
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 0
36818: PUSH
36819: LD_INT 1
36821: NEG
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 1
36829: PUSH
36830: LD_INT 0
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: LD_INT 1
36839: PUSH
36840: LD_INT 1
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 1
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 1
36859: NEG
36860: PUSH
36861: LD_INT 0
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 1
36870: NEG
36871: PUSH
36872: LD_INT 1
36874: NEG
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: LIST
36888: ST_TO_ADDR
// end ; 1 :
36889: GO 42786
36891: LD_INT 1
36893: DOUBLE
36894: EQUAL
36895: IFTRUE 36899
36897: GO 39522
36899: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36900: LD_ADDR_VAR 0 11
36904: PUSH
36905: LD_INT 1
36907: NEG
36908: PUSH
36909: LD_INT 3
36911: NEG
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: LD_INT 3
36922: NEG
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 1
36930: PUSH
36931: LD_INT 2
36933: NEG
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: LIST
36943: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36944: LD_ADDR_VAR 0 12
36948: PUSH
36949: LD_INT 2
36951: PUSH
36952: LD_INT 1
36954: NEG
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 3
36962: PUSH
36963: LD_INT 0
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 3
36972: PUSH
36973: LD_INT 1
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: LIST
36984: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36985: LD_ADDR_VAR 0 13
36989: PUSH
36990: LD_INT 3
36992: PUSH
36993: LD_INT 2
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 3
37002: PUSH
37003: LD_INT 3
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 2
37012: PUSH
37013: LD_INT 3
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: LIST
37024: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37025: LD_ADDR_VAR 0 14
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: LD_INT 3
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 0
37042: PUSH
37043: LD_INT 3
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 1
37052: NEG
37053: PUSH
37054: LD_INT 2
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: LIST
37065: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37066: LD_ADDR_VAR 0 15
37070: PUSH
37071: LD_INT 2
37073: NEG
37074: PUSH
37075: LD_INT 1
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 3
37084: NEG
37085: PUSH
37086: LD_INT 0
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 3
37095: NEG
37096: PUSH
37097: LD_INT 1
37099: NEG
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: LIST
37109: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37110: LD_ADDR_VAR 0 16
37114: PUSH
37115: LD_INT 2
37117: NEG
37118: PUSH
37119: LD_INT 3
37121: NEG
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 3
37129: NEG
37130: PUSH
37131: LD_INT 2
37133: NEG
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 3
37141: NEG
37142: PUSH
37143: LD_INT 3
37145: NEG
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: LIST
37155: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37156: LD_ADDR_VAR 0 17
37160: PUSH
37161: LD_INT 1
37163: NEG
37164: PUSH
37165: LD_INT 3
37167: NEG
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 0
37175: PUSH
37176: LD_INT 3
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: LD_INT 2
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: LIST
37199: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37200: LD_ADDR_VAR 0 18
37204: PUSH
37205: LD_INT 2
37207: PUSH
37208: LD_INT 1
37210: NEG
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 3
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 3
37228: PUSH
37229: LD_INT 1
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: LIST
37240: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37241: LD_ADDR_VAR 0 19
37245: PUSH
37246: LD_INT 3
37248: PUSH
37249: LD_INT 2
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 3
37258: PUSH
37259: LD_INT 3
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 2
37268: PUSH
37269: LD_INT 3
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: LIST
37280: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37281: LD_ADDR_VAR 0 20
37285: PUSH
37286: LD_INT 1
37288: PUSH
37289: LD_INT 3
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: LD_INT 3
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 1
37308: NEG
37309: PUSH
37310: LD_INT 2
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: LIST
37321: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37322: LD_ADDR_VAR 0 21
37326: PUSH
37327: LD_INT 2
37329: NEG
37330: PUSH
37331: LD_INT 1
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 3
37340: NEG
37341: PUSH
37342: LD_INT 0
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 3
37351: NEG
37352: PUSH
37353: LD_INT 1
37355: NEG
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: LIST
37365: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37366: LD_ADDR_VAR 0 22
37370: PUSH
37371: LD_INT 2
37373: NEG
37374: PUSH
37375: LD_INT 3
37377: NEG
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: LD_INT 3
37385: NEG
37386: PUSH
37387: LD_INT 2
37389: NEG
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 3
37397: NEG
37398: PUSH
37399: LD_INT 3
37401: NEG
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: LIST
37411: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37412: LD_ADDR_VAR 0 23
37416: PUSH
37417: LD_INT 0
37419: PUSH
37420: LD_INT 3
37422: NEG
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 1
37430: NEG
37431: PUSH
37432: LD_INT 4
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: PUSH
37443: LD_INT 3
37445: NEG
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: LIST
37455: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37456: LD_ADDR_VAR 0 24
37460: PUSH
37461: LD_INT 3
37463: PUSH
37464: LD_INT 0
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 3
37473: PUSH
37474: LD_INT 1
37476: NEG
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 4
37484: PUSH
37485: LD_INT 1
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: LIST
37496: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37497: LD_ADDR_VAR 0 25
37501: PUSH
37502: LD_INT 3
37504: PUSH
37505: LD_INT 3
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 4
37514: PUSH
37515: LD_INT 3
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 3
37524: PUSH
37525: LD_INT 4
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: LIST
37536: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37537: LD_ADDR_VAR 0 26
37541: PUSH
37542: LD_INT 0
37544: PUSH
37545: LD_INT 3
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 1
37554: PUSH
37555: LD_INT 4
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 1
37564: NEG
37565: PUSH
37566: LD_INT 3
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: LIST
37577: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37578: LD_ADDR_VAR 0 27
37582: PUSH
37583: LD_INT 3
37585: NEG
37586: PUSH
37587: LD_INT 0
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: LD_INT 3
37596: NEG
37597: PUSH
37598: LD_INT 1
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 4
37607: NEG
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: LIST
37621: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37622: LD_ADDR_VAR 0 28
37626: PUSH
37627: LD_INT 3
37629: NEG
37630: PUSH
37631: LD_INT 3
37633: NEG
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 3
37641: NEG
37642: PUSH
37643: LD_INT 4
37645: NEG
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 4
37653: NEG
37654: PUSH
37655: LD_INT 3
37657: NEG
37658: PUSH
37659: EMPTY
37660: LIST
37661: LIST
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: LIST
37667: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37668: LD_ADDR_VAR 0 29
37672: PUSH
37673: LD_INT 1
37675: NEG
37676: PUSH
37677: LD_INT 3
37679: NEG
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 0
37687: PUSH
37688: LD_INT 3
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: LD_INT 2
37701: NEG
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 1
37709: NEG
37710: PUSH
37711: LD_INT 4
37713: NEG
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 0
37721: PUSH
37722: LD_INT 4
37724: NEG
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 1
37732: PUSH
37733: LD_INT 3
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 1
37743: NEG
37744: PUSH
37745: LD_INT 5
37747: NEG
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 0
37755: PUSH
37756: LD_INT 5
37758: NEG
37759: PUSH
37760: EMPTY
37761: LIST
37762: LIST
37763: PUSH
37764: LD_INT 1
37766: PUSH
37767: LD_INT 4
37769: NEG
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: NEG
37778: PUSH
37779: LD_INT 6
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 0
37789: PUSH
37790: LD_INT 6
37792: NEG
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 1
37800: PUSH
37801: LD_INT 5
37803: NEG
37804: PUSH
37805: EMPTY
37806: LIST
37807: LIST
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37823: LD_ADDR_VAR 0 30
37827: PUSH
37828: LD_INT 2
37830: PUSH
37831: LD_INT 1
37833: NEG
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 3
37841: PUSH
37842: LD_INT 0
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 3
37851: PUSH
37852: LD_INT 1
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 3
37861: PUSH
37862: LD_INT 1
37864: NEG
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: PUSH
37870: LD_INT 4
37872: PUSH
37873: LD_INT 0
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 4
37882: PUSH
37883: LD_INT 1
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 4
37892: PUSH
37893: LD_INT 1
37895: NEG
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: LD_INT 5
37903: PUSH
37904: LD_INT 0
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 5
37913: PUSH
37914: LD_INT 1
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 5
37923: PUSH
37924: LD_INT 1
37926: NEG
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 6
37934: PUSH
37935: LD_INT 0
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 6
37944: PUSH
37945: LD_INT 1
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: EMPTY
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37966: LD_ADDR_VAR 0 31
37970: PUSH
37971: LD_INT 3
37973: PUSH
37974: LD_INT 2
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 3
37983: PUSH
37984: LD_INT 3
37986: PUSH
37987: EMPTY
37988: LIST
37989: LIST
37990: PUSH
37991: LD_INT 2
37993: PUSH
37994: LD_INT 3
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 4
38003: PUSH
38004: LD_INT 3
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 4
38013: PUSH
38014: LD_INT 4
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 3
38023: PUSH
38024: LD_INT 4
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 5
38033: PUSH
38034: LD_INT 4
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 5
38043: PUSH
38044: LD_INT 5
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 4
38053: PUSH
38054: LD_INT 5
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 6
38063: PUSH
38064: LD_INT 5
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 6
38073: PUSH
38074: LD_INT 6
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 5
38083: PUSH
38084: LD_INT 6
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38105: LD_ADDR_VAR 0 32
38109: PUSH
38110: LD_INT 1
38112: PUSH
38113: LD_INT 3
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: LD_INT 3
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 1
38132: NEG
38133: PUSH
38134: LD_INT 2
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: LD_INT 1
38143: PUSH
38144: LD_INT 4
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 0
38153: PUSH
38154: LD_INT 4
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: LD_INT 3
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 1
38174: PUSH
38175: LD_INT 5
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 0
38184: PUSH
38185: LD_INT 5
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 1
38194: NEG
38195: PUSH
38196: LD_INT 4
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: LD_INT 6
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 0
38215: PUSH
38216: LD_INT 6
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 1
38225: NEG
38226: PUSH
38227: LD_INT 5
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38248: LD_ADDR_VAR 0 33
38252: PUSH
38253: LD_INT 2
38255: NEG
38256: PUSH
38257: LD_INT 1
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 3
38266: NEG
38267: PUSH
38268: LD_INT 0
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PUSH
38275: LD_INT 3
38277: NEG
38278: PUSH
38279: LD_INT 1
38281: NEG
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 3
38289: NEG
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 4
38300: NEG
38301: PUSH
38302: LD_INT 0
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 4
38311: NEG
38312: PUSH
38313: LD_INT 1
38315: NEG
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 4
38323: NEG
38324: PUSH
38325: LD_INT 1
38327: PUSH
38328: EMPTY
38329: LIST
38330: LIST
38331: PUSH
38332: LD_INT 5
38334: NEG
38335: PUSH
38336: LD_INT 0
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 5
38345: NEG
38346: PUSH
38347: LD_INT 1
38349: NEG
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: PUSH
38355: LD_INT 5
38357: NEG
38358: PUSH
38359: LD_INT 1
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 6
38368: NEG
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 6
38379: NEG
38380: PUSH
38381: LD_INT 1
38383: NEG
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38403: LD_ADDR_VAR 0 34
38407: PUSH
38408: LD_INT 2
38410: NEG
38411: PUSH
38412: LD_INT 3
38414: NEG
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 3
38422: NEG
38423: PUSH
38424: LD_INT 2
38426: NEG
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 3
38434: NEG
38435: PUSH
38436: LD_INT 3
38438: NEG
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 3
38446: NEG
38447: PUSH
38448: LD_INT 4
38450: NEG
38451: PUSH
38452: EMPTY
38453: LIST
38454: LIST
38455: PUSH
38456: LD_INT 4
38458: NEG
38459: PUSH
38460: LD_INT 3
38462: NEG
38463: PUSH
38464: EMPTY
38465: LIST
38466: LIST
38467: PUSH
38468: LD_INT 4
38470: NEG
38471: PUSH
38472: LD_INT 4
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 4
38482: NEG
38483: PUSH
38484: LD_INT 5
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 5
38494: NEG
38495: PUSH
38496: LD_INT 4
38498: NEG
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 5
38506: NEG
38507: PUSH
38508: LD_INT 5
38510: NEG
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: PUSH
38516: LD_INT 5
38518: NEG
38519: PUSH
38520: LD_INT 6
38522: NEG
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PUSH
38528: LD_INT 6
38530: NEG
38531: PUSH
38532: LD_INT 5
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 6
38542: NEG
38543: PUSH
38544: LD_INT 6
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38566: LD_ADDR_VAR 0 41
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: LD_INT 2
38576: NEG
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 3
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: LD_INT 2
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: LIST
38609: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38610: LD_ADDR_VAR 0 42
38614: PUSH
38615: LD_INT 2
38617: PUSH
38618: LD_INT 0
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: PUSH
38625: LD_INT 2
38627: PUSH
38628: LD_INT 1
38630: NEG
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 3
38638: PUSH
38639: LD_INT 1
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: LIST
38650: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38651: LD_ADDR_VAR 0 43
38655: PUSH
38656: LD_INT 2
38658: PUSH
38659: LD_INT 2
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 3
38668: PUSH
38669: LD_INT 2
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 2
38678: PUSH
38679: LD_INT 3
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: LIST
38690: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38691: LD_ADDR_VAR 0 44
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: LD_INT 2
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 1
38708: PUSH
38709: LD_INT 3
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 1
38718: NEG
38719: PUSH
38720: LD_INT 2
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: LIST
38731: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38732: LD_ADDR_VAR 0 45
38736: PUSH
38737: LD_INT 2
38739: NEG
38740: PUSH
38741: LD_INT 0
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 2
38750: NEG
38751: PUSH
38752: LD_INT 1
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 3
38761: NEG
38762: PUSH
38763: LD_INT 1
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: LIST
38775: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38776: LD_ADDR_VAR 0 46
38780: PUSH
38781: LD_INT 2
38783: NEG
38784: PUSH
38785: LD_INT 2
38787: NEG
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PUSH
38793: LD_INT 2
38795: NEG
38796: PUSH
38797: LD_INT 3
38799: NEG
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 3
38807: NEG
38808: PUSH
38809: LD_INT 2
38811: NEG
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: LIST
38821: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38822: LD_ADDR_VAR 0 47
38826: PUSH
38827: LD_INT 2
38829: NEG
38830: PUSH
38831: LD_INT 3
38833: NEG
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: NEG
38842: PUSH
38843: LD_INT 3
38845: NEG
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38855: LD_ADDR_VAR 0 48
38859: PUSH
38860: LD_INT 1
38862: PUSH
38863: LD_INT 2
38865: NEG
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 2
38873: PUSH
38874: LD_INT 1
38876: NEG
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38886: LD_ADDR_VAR 0 49
38890: PUSH
38891: LD_INT 3
38893: PUSH
38894: LD_INT 1
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 3
38903: PUSH
38904: LD_INT 2
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38915: LD_ADDR_VAR 0 50
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: LD_INT 3
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 1
38932: PUSH
38933: LD_INT 3
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38944: LD_ADDR_VAR 0 51
38948: PUSH
38949: LD_INT 1
38951: NEG
38952: PUSH
38953: LD_INT 2
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: LD_INT 2
38962: NEG
38963: PUSH
38964: LD_INT 1
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: EMPTY
38972: LIST
38973: LIST
38974: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38975: LD_ADDR_VAR 0 52
38979: PUSH
38980: LD_INT 3
38982: NEG
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 3
38994: NEG
38995: PUSH
38996: LD_INT 2
38998: NEG
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39008: LD_ADDR_VAR 0 53
39012: PUSH
39013: LD_INT 1
39015: NEG
39016: PUSH
39017: LD_INT 3
39019: NEG
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: LD_INT 3
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 1
39038: PUSH
39039: LD_INT 2
39041: NEG
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: LIST
39051: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39052: LD_ADDR_VAR 0 54
39056: PUSH
39057: LD_INT 2
39059: PUSH
39060: LD_INT 1
39062: NEG
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 3
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 3
39080: PUSH
39081: LD_INT 1
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39093: LD_ADDR_VAR 0 55
39097: PUSH
39098: LD_INT 3
39100: PUSH
39101: LD_INT 2
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: LD_INT 3
39110: PUSH
39111: LD_INT 3
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 2
39120: PUSH
39121: LD_INT 3
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: LIST
39132: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39133: LD_ADDR_VAR 0 56
39137: PUSH
39138: LD_INT 1
39140: PUSH
39141: LD_INT 3
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: LD_INT 3
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 1
39160: NEG
39161: PUSH
39162: LD_INT 2
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: LIST
39173: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39174: LD_ADDR_VAR 0 57
39178: PUSH
39179: LD_INT 2
39181: NEG
39182: PUSH
39183: LD_INT 1
39185: PUSH
39186: EMPTY
39187: LIST
39188: LIST
39189: PUSH
39190: LD_INT 3
39192: NEG
39193: PUSH
39194: LD_INT 0
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 3
39203: NEG
39204: PUSH
39205: LD_INT 1
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: LIST
39217: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39218: LD_ADDR_VAR 0 58
39222: PUSH
39223: LD_INT 2
39225: NEG
39226: PUSH
39227: LD_INT 3
39229: NEG
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 3
39237: NEG
39238: PUSH
39239: LD_INT 2
39241: NEG
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 3
39249: NEG
39250: PUSH
39251: LD_INT 3
39253: NEG
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: LIST
39263: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39264: LD_ADDR_VAR 0 59
39268: PUSH
39269: LD_INT 1
39271: NEG
39272: PUSH
39273: LD_INT 2
39275: NEG
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: LD_INT 2
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: LD_INT 1
39297: NEG
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: LIST
39307: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39308: LD_ADDR_VAR 0 60
39312: PUSH
39313: LD_INT 1
39315: PUSH
39316: LD_INT 1
39318: NEG
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 2
39326: PUSH
39327: LD_INT 0
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 2
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: LIST
39348: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39349: LD_ADDR_VAR 0 61
39353: PUSH
39354: LD_INT 2
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 2
39366: PUSH
39367: LD_INT 2
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 1
39376: PUSH
39377: LD_INT 2
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: LIST
39388: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39389: LD_ADDR_VAR 0 62
39393: PUSH
39394: LD_INT 1
39396: PUSH
39397: LD_INT 2
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: LD_INT 2
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 1
39416: NEG
39417: PUSH
39418: LD_INT 1
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: LIST
39429: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39430: LD_ADDR_VAR 0 63
39434: PUSH
39435: LD_INT 1
39437: NEG
39438: PUSH
39439: LD_INT 1
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 2
39448: NEG
39449: PUSH
39450: LD_INT 0
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 2
39459: NEG
39460: PUSH
39461: LD_INT 1
39463: NEG
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: LIST
39473: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39474: LD_ADDR_VAR 0 64
39478: PUSH
39479: LD_INT 1
39481: NEG
39482: PUSH
39483: LD_INT 2
39485: NEG
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 2
39493: NEG
39494: PUSH
39495: LD_INT 1
39497: NEG
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 2
39505: NEG
39506: PUSH
39507: LD_INT 2
39509: NEG
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: LIST
39519: ST_TO_ADDR
// end ; 2 :
39520: GO 42786
39522: LD_INT 2
39524: DOUBLE
39525: EQUAL
39526: IFTRUE 39530
39528: GO 42785
39530: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39531: LD_ADDR_VAR 0 29
39535: PUSH
39536: LD_INT 4
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 4
39548: PUSH
39549: LD_INT 1
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 5
39559: PUSH
39560: LD_INT 0
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 5
39569: PUSH
39570: LD_INT 1
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 4
39579: PUSH
39580: LD_INT 1
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 3
39589: PUSH
39590: LD_INT 0
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 3
39599: PUSH
39600: LD_INT 1
39602: NEG
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 3
39610: PUSH
39611: LD_INT 2
39613: NEG
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 5
39621: PUSH
39622: LD_INT 2
39624: PUSH
39625: EMPTY
39626: LIST
39627: LIST
39628: PUSH
39629: LD_INT 3
39631: PUSH
39632: LD_INT 3
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: LD_INT 3
39641: PUSH
39642: LD_INT 2
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 4
39651: PUSH
39652: LD_INT 3
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 4
39661: PUSH
39662: LD_INT 4
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: LD_INT 3
39671: PUSH
39672: LD_INT 4
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: PUSH
39682: LD_INT 3
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 2
39691: PUSH
39692: LD_INT 2
39694: PUSH
39695: EMPTY
39696: LIST
39697: LIST
39698: PUSH
39699: LD_INT 4
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 2
39711: PUSH
39712: LD_INT 4
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 0
39721: PUSH
39722: LD_INT 4
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 0
39731: PUSH
39732: LD_INT 3
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 1
39741: PUSH
39742: LD_INT 4
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 1
39751: PUSH
39752: LD_INT 5
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 0
39761: PUSH
39762: LD_INT 5
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 1
39771: NEG
39772: PUSH
39773: LD_INT 4
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 1
39782: NEG
39783: PUSH
39784: LD_INT 3
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: LD_INT 2
39793: PUSH
39794: LD_INT 5
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 2
39803: NEG
39804: PUSH
39805: LD_INT 3
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 3
39814: NEG
39815: PUSH
39816: LD_INT 0
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 3
39825: NEG
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 2
39837: NEG
39838: PUSH
39839: LD_INT 0
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 2
39848: NEG
39849: PUSH
39850: LD_INT 1
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 3
39859: NEG
39860: PUSH
39861: LD_INT 1
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 4
39870: NEG
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 4
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 4
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 2
39905: NEG
39906: PUSH
39907: LD_INT 2
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 4
39916: NEG
39917: PUSH
39918: LD_INT 4
39920: NEG
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 4
39928: NEG
39929: PUSH
39930: LD_INT 5
39932: NEG
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 3
39940: NEG
39941: PUSH
39942: LD_INT 4
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 3
39952: NEG
39953: PUSH
39954: LD_INT 3
39956: NEG
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 4
39964: NEG
39965: PUSH
39966: LD_INT 3
39968: NEG
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: PUSH
39974: LD_INT 5
39976: NEG
39977: PUSH
39978: LD_INT 4
39980: NEG
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 5
39988: NEG
39989: PUSH
39990: LD_INT 5
39992: NEG
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 3
40000: NEG
40001: PUSH
40002: LD_INT 5
40004: NEG
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 5
40012: NEG
40013: PUSH
40014: LD_INT 3
40016: NEG
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: LIST
40041: LIST
40042: LIST
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: LIST
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: LIST
40065: LIST
40066: LIST
40067: LIST
40068: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40069: LD_ADDR_VAR 0 30
40073: PUSH
40074: LD_INT 4
40076: PUSH
40077: LD_INT 4
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 4
40086: PUSH
40087: LD_INT 3
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 5
40096: PUSH
40097: LD_INT 4
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 5
40106: PUSH
40107: LD_INT 5
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 4
40116: PUSH
40117: LD_INT 5
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 3
40126: PUSH
40127: LD_INT 4
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 3
40136: PUSH
40137: LD_INT 3
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 5
40146: PUSH
40147: LD_INT 3
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 3
40156: PUSH
40157: LD_INT 5
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: LD_INT 3
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 0
40176: PUSH
40177: LD_INT 2
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 1
40186: PUSH
40187: LD_INT 3
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: LD_INT 1
40196: PUSH
40197: LD_INT 4
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 0
40206: PUSH
40207: LD_INT 4
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 1
40216: NEG
40217: PUSH
40218: LD_INT 3
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 1
40227: NEG
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 2
40238: PUSH
40239: LD_INT 4
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 2
40248: NEG
40249: PUSH
40250: LD_INT 2
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 4
40259: NEG
40260: PUSH
40261: LD_INT 0
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 4
40270: NEG
40271: PUSH
40272: LD_INT 1
40274: NEG
40275: PUSH
40276: EMPTY
40277: LIST
40278: LIST
40279: PUSH
40280: LD_INT 3
40282: NEG
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 3
40293: NEG
40294: PUSH
40295: LD_INT 1
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 4
40304: NEG
40305: PUSH
40306: LD_INT 1
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 5
40315: NEG
40316: PUSH
40317: LD_INT 0
40319: PUSH
40320: EMPTY
40321: LIST
40322: LIST
40323: PUSH
40324: LD_INT 5
40326: NEG
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 5
40338: NEG
40339: PUSH
40340: LD_INT 2
40342: NEG
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 3
40350: NEG
40351: PUSH
40352: LD_INT 2
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: LD_INT 3
40361: NEG
40362: PUSH
40363: LD_INT 3
40365: NEG
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 3
40373: NEG
40374: PUSH
40375: LD_INT 4
40377: NEG
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 2
40385: NEG
40386: PUSH
40387: LD_INT 3
40389: NEG
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 2
40397: NEG
40398: PUSH
40399: LD_INT 2
40401: NEG
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 3
40409: NEG
40410: PUSH
40411: LD_INT 2
40413: NEG
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PUSH
40419: LD_INT 4
40421: NEG
40422: PUSH
40423: LD_INT 3
40425: NEG
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 4
40433: NEG
40434: PUSH
40435: LD_INT 4
40437: NEG
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 2
40445: NEG
40446: PUSH
40447: LD_INT 4
40449: NEG
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 4
40457: NEG
40458: PUSH
40459: LD_INT 2
40461: NEG
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: LD_INT 0
40469: PUSH
40470: LD_INT 4
40472: NEG
40473: PUSH
40474: EMPTY
40475: LIST
40476: LIST
40477: PUSH
40478: LD_INT 0
40480: PUSH
40481: LD_INT 5
40483: NEG
40484: PUSH
40485: EMPTY
40486: LIST
40487: LIST
40488: PUSH
40489: LD_INT 1
40491: PUSH
40492: LD_INT 4
40494: NEG
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 1
40502: PUSH
40503: LD_INT 3
40505: NEG
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: LD_INT 3
40516: NEG
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 1
40524: NEG
40525: PUSH
40526: LD_INT 4
40528: NEG
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: LD_INT 1
40536: NEG
40537: PUSH
40538: LD_INT 5
40540: NEG
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 2
40548: PUSH
40549: LD_INT 3
40551: NEG
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: LD_INT 2
40559: NEG
40560: PUSH
40561: LD_INT 5
40563: NEG
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: LIST
40573: LIST
40574: LIST
40575: LIST
40576: LIST
40577: LIST
40578: LIST
40579: LIST
40580: LIST
40581: LIST
40582: LIST
40583: LIST
40584: LIST
40585: LIST
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40616: LD_ADDR_VAR 0 31
40620: PUSH
40621: LD_INT 0
40623: PUSH
40624: LD_INT 4
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: PUSH
40631: LD_INT 0
40633: PUSH
40634: LD_INT 3
40636: PUSH
40637: EMPTY
40638: LIST
40639: LIST
40640: PUSH
40641: LD_INT 1
40643: PUSH
40644: LD_INT 4
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 1
40653: PUSH
40654: LD_INT 5
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: LD_INT 5
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 1
40673: NEG
40674: PUSH
40675: LD_INT 4
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 1
40684: NEG
40685: PUSH
40686: LD_INT 3
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 2
40695: PUSH
40696: LD_INT 5
40698: PUSH
40699: EMPTY
40700: LIST
40701: LIST
40702: PUSH
40703: LD_INT 2
40705: NEG
40706: PUSH
40707: LD_INT 3
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 3
40716: NEG
40717: PUSH
40718: LD_INT 0
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 3
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 2
40739: NEG
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 2
40750: NEG
40751: PUSH
40752: LD_INT 1
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: LD_INT 3
40761: NEG
40762: PUSH
40763: LD_INT 1
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 4
40772: NEG
40773: PUSH
40774: LD_INT 0
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: LD_INT 4
40783: NEG
40784: PUSH
40785: LD_INT 1
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 4
40795: NEG
40796: PUSH
40797: LD_INT 2
40799: NEG
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 2
40807: NEG
40808: PUSH
40809: LD_INT 2
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 4
40818: NEG
40819: PUSH
40820: LD_INT 4
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 4
40830: NEG
40831: PUSH
40832: LD_INT 5
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 3
40842: NEG
40843: PUSH
40844: LD_INT 4
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 3
40854: NEG
40855: PUSH
40856: LD_INT 3
40858: NEG
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 4
40866: NEG
40867: PUSH
40868: LD_INT 3
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 5
40878: NEG
40879: PUSH
40880: LD_INT 4
40882: NEG
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 5
40890: NEG
40891: PUSH
40892: LD_INT 5
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 3
40902: NEG
40903: PUSH
40904: LD_INT 5
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 5
40914: NEG
40915: PUSH
40916: LD_INT 3
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 0
40926: PUSH
40927: LD_INT 3
40929: NEG
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 0
40937: PUSH
40938: LD_INT 4
40940: NEG
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 1
40948: PUSH
40949: LD_INT 3
40951: NEG
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: LD_INT 2
40962: NEG
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 0
40970: PUSH
40971: LD_INT 2
40973: NEG
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: LD_INT 1
40981: NEG
40982: PUSH
40983: LD_INT 3
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 1
40993: NEG
40994: PUSH
40995: LD_INT 4
40997: NEG
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 2
41005: PUSH
41006: LD_INT 2
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: LD_INT 2
41016: NEG
41017: PUSH
41018: LD_INT 4
41020: NEG
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 4
41028: PUSH
41029: LD_INT 0
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: LD_INT 4
41038: PUSH
41039: LD_INT 1
41041: NEG
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 5
41049: PUSH
41050: LD_INT 0
41052: PUSH
41053: EMPTY
41054: LIST
41055: LIST
41056: PUSH
41057: LD_INT 5
41059: PUSH
41060: LD_INT 1
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 4
41069: PUSH
41070: LD_INT 1
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: LD_INT 3
41079: PUSH
41080: LD_INT 0
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: LD_INT 3
41089: PUSH
41090: LD_INT 1
41092: NEG
41093: PUSH
41094: EMPTY
41095: LIST
41096: LIST
41097: PUSH
41098: LD_INT 3
41100: PUSH
41101: LD_INT 2
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 5
41111: PUSH
41112: LD_INT 2
41114: PUSH
41115: EMPTY
41116: LIST
41117: LIST
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: LIST
41123: LIST
41124: LIST
41125: LIST
41126: LIST
41127: LIST
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: LIST
41133: LIST
41134: LIST
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: LIST
41140: LIST
41141: LIST
41142: LIST
41143: LIST
41144: LIST
41145: LIST
41146: LIST
41147: LIST
41148: LIST
41149: LIST
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41166: LD_ADDR_VAR 0 32
41170: PUSH
41171: LD_INT 4
41173: NEG
41174: PUSH
41175: LD_INT 0
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 4
41184: NEG
41185: PUSH
41186: LD_INT 1
41188: NEG
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 3
41196: NEG
41197: PUSH
41198: LD_INT 0
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: PUSH
41205: LD_INT 3
41207: NEG
41208: PUSH
41209: LD_INT 1
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 4
41218: NEG
41219: PUSH
41220: LD_INT 1
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 5
41229: NEG
41230: PUSH
41231: LD_INT 0
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 5
41240: NEG
41241: PUSH
41242: LD_INT 1
41244: NEG
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 5
41252: NEG
41253: PUSH
41254: LD_INT 2
41256: NEG
41257: PUSH
41258: EMPTY
41259: LIST
41260: LIST
41261: PUSH
41262: LD_INT 3
41264: NEG
41265: PUSH
41266: LD_INT 2
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 3
41275: NEG
41276: PUSH
41277: LD_INT 3
41279: NEG
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 3
41287: NEG
41288: PUSH
41289: LD_INT 4
41291: NEG
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 2
41299: NEG
41300: PUSH
41301: LD_INT 3
41303: NEG
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 2
41311: NEG
41312: PUSH
41313: LD_INT 2
41315: NEG
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 3
41323: NEG
41324: PUSH
41325: LD_INT 2
41327: NEG
41328: PUSH
41329: EMPTY
41330: LIST
41331: LIST
41332: PUSH
41333: LD_INT 4
41335: NEG
41336: PUSH
41337: LD_INT 3
41339: NEG
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 4
41347: NEG
41348: PUSH
41349: LD_INT 4
41351: NEG
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 2
41359: NEG
41360: PUSH
41361: LD_INT 4
41363: NEG
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 4
41371: NEG
41372: PUSH
41373: LD_INT 2
41375: NEG
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 0
41383: PUSH
41384: LD_INT 4
41386: NEG
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 0
41394: PUSH
41395: LD_INT 5
41397: NEG
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 1
41405: PUSH
41406: LD_INT 4
41408: NEG
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 1
41416: PUSH
41417: LD_INT 3
41419: NEG
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 0
41427: PUSH
41428: LD_INT 3
41430: NEG
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 1
41438: NEG
41439: PUSH
41440: LD_INT 4
41442: NEG
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: LD_INT 1
41450: NEG
41451: PUSH
41452: LD_INT 5
41454: NEG
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 2
41462: PUSH
41463: LD_INT 3
41465: NEG
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 2
41473: NEG
41474: PUSH
41475: LD_INT 5
41477: NEG
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 3
41485: PUSH
41486: LD_INT 0
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: PUSH
41493: LD_INT 3
41495: PUSH
41496: LD_INT 1
41498: NEG
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 4
41506: PUSH
41507: LD_INT 0
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 4
41516: PUSH
41517: LD_INT 1
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 3
41526: PUSH
41527: LD_INT 1
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 2
41536: PUSH
41537: LD_INT 0
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 2
41546: PUSH
41547: LD_INT 1
41549: NEG
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 2
41557: PUSH
41558: LD_INT 2
41560: NEG
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 4
41568: PUSH
41569: LD_INT 2
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 4
41578: PUSH
41579: LD_INT 4
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 4
41588: PUSH
41589: LD_INT 3
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 5
41598: PUSH
41599: LD_INT 4
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 5
41608: PUSH
41609: LD_INT 5
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 4
41618: PUSH
41619: LD_INT 5
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 3
41628: PUSH
41629: LD_INT 4
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 3
41638: PUSH
41639: LD_INT 3
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 5
41648: PUSH
41649: LD_INT 3
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: PUSH
41659: LD_INT 5
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: LIST
41670: LIST
41671: LIST
41672: LIST
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: LIST
41680: LIST
41681: LIST
41682: LIST
41683: LIST
41684: LIST
41685: LIST
41686: LIST
41687: LIST
41688: LIST
41689: LIST
41690: LIST
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: LIST
41703: LIST
41704: LIST
41705: LIST
41706: LIST
41707: LIST
41708: LIST
41709: LIST
41710: LIST
41711: LIST
41712: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41713: LD_ADDR_VAR 0 33
41717: PUSH
41718: LD_INT 4
41720: NEG
41721: PUSH
41722: LD_INT 4
41724: NEG
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 4
41732: NEG
41733: PUSH
41734: LD_INT 5
41736: NEG
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 3
41744: NEG
41745: PUSH
41746: LD_INT 4
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 3
41756: NEG
41757: PUSH
41758: LD_INT 3
41760: NEG
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 4
41768: NEG
41769: PUSH
41770: LD_INT 3
41772: NEG
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 5
41780: NEG
41781: PUSH
41782: LD_INT 4
41784: NEG
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 5
41792: NEG
41793: PUSH
41794: LD_INT 5
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 3
41804: NEG
41805: PUSH
41806: LD_INT 5
41808: NEG
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 5
41816: NEG
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: LD_INT 3
41831: NEG
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 0
41839: PUSH
41840: LD_INT 4
41842: NEG
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 1
41850: PUSH
41851: LD_INT 3
41853: NEG
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 1
41861: PUSH
41862: LD_INT 2
41864: NEG
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 0
41872: PUSH
41873: LD_INT 2
41875: NEG
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 1
41883: NEG
41884: PUSH
41885: LD_INT 3
41887: NEG
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: LD_INT 1
41895: NEG
41896: PUSH
41897: LD_INT 4
41899: NEG
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 2
41907: PUSH
41908: LD_INT 2
41910: NEG
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: PUSH
41916: LD_INT 2
41918: NEG
41919: PUSH
41920: LD_INT 4
41922: NEG
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 4
41930: PUSH
41931: LD_INT 0
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 4
41940: PUSH
41941: LD_INT 1
41943: NEG
41944: PUSH
41945: EMPTY
41946: LIST
41947: LIST
41948: PUSH
41949: LD_INT 5
41951: PUSH
41952: LD_INT 0
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: PUSH
41959: LD_INT 5
41961: PUSH
41962: LD_INT 1
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 4
41971: PUSH
41972: LD_INT 1
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 3
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 3
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: PUSH
42000: LD_INT 3
42002: PUSH
42003: LD_INT 2
42005: NEG
42006: PUSH
42007: EMPTY
42008: LIST
42009: LIST
42010: PUSH
42011: LD_INT 5
42013: PUSH
42014: LD_INT 2
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 3
42023: PUSH
42024: LD_INT 3
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PUSH
42031: LD_INT 3
42033: PUSH
42034: LD_INT 2
42036: PUSH
42037: EMPTY
42038: LIST
42039: LIST
42040: PUSH
42041: LD_INT 4
42043: PUSH
42044: LD_INT 3
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: PUSH
42051: LD_INT 4
42053: PUSH
42054: LD_INT 4
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 3
42063: PUSH
42064: LD_INT 4
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 2
42073: PUSH
42074: LD_INT 3
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 2
42083: PUSH
42084: LD_INT 2
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 4
42093: PUSH
42094: LD_INT 2
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 2
42103: PUSH
42104: LD_INT 4
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: LD_INT 4
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 0
42123: PUSH
42124: LD_INT 3
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 1
42133: PUSH
42134: LD_INT 4
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 1
42143: PUSH
42144: LD_INT 5
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 0
42153: PUSH
42154: LD_INT 5
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 1
42163: NEG
42164: PUSH
42165: LD_INT 4
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PUSH
42172: LD_INT 1
42174: NEG
42175: PUSH
42176: LD_INT 3
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 2
42185: PUSH
42186: LD_INT 5
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 2
42195: NEG
42196: PUSH
42197: LD_INT 3
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: LIST
42208: LIST
42209: LIST
42210: LIST
42211: LIST
42212: LIST
42213: LIST
42214: LIST
42215: LIST
42216: LIST
42217: LIST
42218: LIST
42219: LIST
42220: LIST
42221: LIST
42222: LIST
42223: LIST
42224: LIST
42225: LIST
42226: LIST
42227: LIST
42228: LIST
42229: LIST
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42251: LD_ADDR_VAR 0 34
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: LD_INT 4
42261: NEG
42262: PUSH
42263: EMPTY
42264: LIST
42265: LIST
42266: PUSH
42267: LD_INT 0
42269: PUSH
42270: LD_INT 5
42272: NEG
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: LD_INT 1
42280: PUSH
42281: LD_INT 4
42283: NEG
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 1
42291: PUSH
42292: LD_INT 3
42294: NEG
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 0
42302: PUSH
42303: LD_INT 3
42305: NEG
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: LD_INT 1
42313: NEG
42314: PUSH
42315: LD_INT 4
42317: NEG
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 1
42325: NEG
42326: PUSH
42327: LD_INT 5
42329: NEG
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 2
42337: PUSH
42338: LD_INT 3
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 2
42348: NEG
42349: PUSH
42350: LD_INT 5
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 3
42360: PUSH
42361: LD_INT 0
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: LD_INT 1
42373: NEG
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: PUSH
42379: LD_INT 4
42381: PUSH
42382: LD_INT 0
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: PUSH
42389: LD_INT 4
42391: PUSH
42392: LD_INT 1
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 3
42401: PUSH
42402: LD_INT 1
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: LD_INT 2
42411: PUSH
42412: LD_INT 0
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 2
42421: PUSH
42422: LD_INT 1
42424: NEG
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PUSH
42430: LD_INT 2
42432: PUSH
42433: LD_INT 2
42435: NEG
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 4
42443: PUSH
42444: LD_INT 2
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 4
42453: PUSH
42454: LD_INT 4
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 4
42463: PUSH
42464: LD_INT 3
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 5
42473: PUSH
42474: LD_INT 4
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 5
42483: PUSH
42484: LD_INT 5
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 4
42493: PUSH
42494: LD_INT 5
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 3
42503: PUSH
42504: LD_INT 4
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 3
42513: PUSH
42514: LD_INT 3
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: PUSH
42521: LD_INT 5
42523: PUSH
42524: LD_INT 3
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 3
42533: PUSH
42534: LD_INT 5
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 0
42543: PUSH
42544: LD_INT 3
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: LD_INT 0
42553: PUSH
42554: LD_INT 2
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 1
42563: PUSH
42564: LD_INT 3
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 1
42573: PUSH
42574: LD_INT 4
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 0
42583: PUSH
42584: LD_INT 4
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 1
42593: NEG
42594: PUSH
42595: LD_INT 3
42597: PUSH
42598: EMPTY
42599: LIST
42600: LIST
42601: PUSH
42602: LD_INT 1
42604: NEG
42605: PUSH
42606: LD_INT 2
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: LD_INT 4
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: LD_INT 2
42625: NEG
42626: PUSH
42627: LD_INT 2
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: LD_INT 4
42636: NEG
42637: PUSH
42638: LD_INT 0
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 4
42647: NEG
42648: PUSH
42649: LD_INT 1
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: LD_INT 3
42659: NEG
42660: PUSH
42661: LD_INT 0
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 3
42670: NEG
42671: PUSH
42672: LD_INT 1
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 4
42681: NEG
42682: PUSH
42683: LD_INT 1
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 5
42692: NEG
42693: PUSH
42694: LD_INT 0
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 5
42703: NEG
42704: PUSH
42705: LD_INT 1
42707: NEG
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 5
42715: NEG
42716: PUSH
42717: LD_INT 2
42719: NEG
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: LD_INT 3
42727: NEG
42728: PUSH
42729: LD_INT 2
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: LIST
42743: LIST
42744: LIST
42745: LIST
42746: LIST
42747: LIST
42748: LIST
42749: LIST
42750: LIST
42751: LIST
42752: LIST
42753: LIST
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: ST_TO_ADDR
// end ; end ;
42783: GO 42786
42785: POP
// case btype of b_depot , b_warehouse :
42786: LD_VAR 0 1
42790: PUSH
42791: LD_INT 0
42793: DOUBLE
42794: EQUAL
42795: IFTRUE 42805
42797: LD_INT 1
42799: DOUBLE
42800: EQUAL
42801: IFTRUE 42805
42803: GO 43006
42805: POP
// case nation of nation_american :
42806: LD_VAR 0 5
42810: PUSH
42811: LD_INT 1
42813: DOUBLE
42814: EQUAL
42815: IFTRUE 42819
42817: GO 42875
42819: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42820: LD_ADDR_VAR 0 9
42824: PUSH
42825: LD_VAR 0 11
42829: PUSH
42830: LD_VAR 0 12
42834: PUSH
42835: LD_VAR 0 13
42839: PUSH
42840: LD_VAR 0 14
42844: PUSH
42845: LD_VAR 0 15
42849: PUSH
42850: LD_VAR 0 16
42854: PUSH
42855: EMPTY
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: PUSH
42863: LD_VAR 0 4
42867: PUSH
42868: LD_INT 1
42870: PLUS
42871: ARRAY
42872: ST_TO_ADDR
42873: GO 43004
42875: LD_INT 2
42877: DOUBLE
42878: EQUAL
42879: IFTRUE 42883
42881: GO 42939
42883: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42884: LD_ADDR_VAR 0 9
42888: PUSH
42889: LD_VAR 0 17
42893: PUSH
42894: LD_VAR 0 18
42898: PUSH
42899: LD_VAR 0 19
42903: PUSH
42904: LD_VAR 0 20
42908: PUSH
42909: LD_VAR 0 21
42913: PUSH
42914: LD_VAR 0 22
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: LIST
42923: LIST
42924: LIST
42925: LIST
42926: PUSH
42927: LD_VAR 0 4
42931: PUSH
42932: LD_INT 1
42934: PLUS
42935: ARRAY
42936: ST_TO_ADDR
42937: GO 43004
42939: LD_INT 3
42941: DOUBLE
42942: EQUAL
42943: IFTRUE 42947
42945: GO 43003
42947: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42948: LD_ADDR_VAR 0 9
42952: PUSH
42953: LD_VAR 0 23
42957: PUSH
42958: LD_VAR 0 24
42962: PUSH
42963: LD_VAR 0 25
42967: PUSH
42968: LD_VAR 0 26
42972: PUSH
42973: LD_VAR 0 27
42977: PUSH
42978: LD_VAR 0 28
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: PUSH
42991: LD_VAR 0 4
42995: PUSH
42996: LD_INT 1
42998: PLUS
42999: ARRAY
43000: ST_TO_ADDR
43001: GO 43004
43003: POP
43004: GO 43559
43006: LD_INT 2
43008: DOUBLE
43009: EQUAL
43010: IFTRUE 43020
43012: LD_INT 3
43014: DOUBLE
43015: EQUAL
43016: IFTRUE 43020
43018: GO 43076
43020: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43021: LD_ADDR_VAR 0 9
43025: PUSH
43026: LD_VAR 0 29
43030: PUSH
43031: LD_VAR 0 30
43035: PUSH
43036: LD_VAR 0 31
43040: PUSH
43041: LD_VAR 0 32
43045: PUSH
43046: LD_VAR 0 33
43050: PUSH
43051: LD_VAR 0 34
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: LIST
43060: LIST
43061: LIST
43062: LIST
43063: PUSH
43064: LD_VAR 0 4
43068: PUSH
43069: LD_INT 1
43071: PLUS
43072: ARRAY
43073: ST_TO_ADDR
43074: GO 43559
43076: LD_INT 16
43078: DOUBLE
43079: EQUAL
43080: IFTRUE 43138
43082: LD_INT 17
43084: DOUBLE
43085: EQUAL
43086: IFTRUE 43138
43088: LD_INT 18
43090: DOUBLE
43091: EQUAL
43092: IFTRUE 43138
43094: LD_INT 19
43096: DOUBLE
43097: EQUAL
43098: IFTRUE 43138
43100: LD_INT 22
43102: DOUBLE
43103: EQUAL
43104: IFTRUE 43138
43106: LD_INT 20
43108: DOUBLE
43109: EQUAL
43110: IFTRUE 43138
43112: LD_INT 21
43114: DOUBLE
43115: EQUAL
43116: IFTRUE 43138
43118: LD_INT 23
43120: DOUBLE
43121: EQUAL
43122: IFTRUE 43138
43124: LD_INT 24
43126: DOUBLE
43127: EQUAL
43128: IFTRUE 43138
43130: LD_INT 25
43132: DOUBLE
43133: EQUAL
43134: IFTRUE 43138
43136: GO 43194
43138: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43139: LD_ADDR_VAR 0 9
43143: PUSH
43144: LD_VAR 0 35
43148: PUSH
43149: LD_VAR 0 36
43153: PUSH
43154: LD_VAR 0 37
43158: PUSH
43159: LD_VAR 0 38
43163: PUSH
43164: LD_VAR 0 39
43168: PUSH
43169: LD_VAR 0 40
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: LIST
43178: LIST
43179: LIST
43180: LIST
43181: PUSH
43182: LD_VAR 0 4
43186: PUSH
43187: LD_INT 1
43189: PLUS
43190: ARRAY
43191: ST_TO_ADDR
43192: GO 43559
43194: LD_INT 6
43196: DOUBLE
43197: EQUAL
43198: IFTRUE 43250
43200: LD_INT 7
43202: DOUBLE
43203: EQUAL
43204: IFTRUE 43250
43206: LD_INT 8
43208: DOUBLE
43209: EQUAL
43210: IFTRUE 43250
43212: LD_INT 13
43214: DOUBLE
43215: EQUAL
43216: IFTRUE 43250
43218: LD_INT 12
43220: DOUBLE
43221: EQUAL
43222: IFTRUE 43250
43224: LD_INT 15
43226: DOUBLE
43227: EQUAL
43228: IFTRUE 43250
43230: LD_INT 11
43232: DOUBLE
43233: EQUAL
43234: IFTRUE 43250
43236: LD_INT 14
43238: DOUBLE
43239: EQUAL
43240: IFTRUE 43250
43242: LD_INT 10
43244: DOUBLE
43245: EQUAL
43246: IFTRUE 43250
43248: GO 43306
43250: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43251: LD_ADDR_VAR 0 9
43255: PUSH
43256: LD_VAR 0 41
43260: PUSH
43261: LD_VAR 0 42
43265: PUSH
43266: LD_VAR 0 43
43270: PUSH
43271: LD_VAR 0 44
43275: PUSH
43276: LD_VAR 0 45
43280: PUSH
43281: LD_VAR 0 46
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: LIST
43290: LIST
43291: LIST
43292: LIST
43293: PUSH
43294: LD_VAR 0 4
43298: PUSH
43299: LD_INT 1
43301: PLUS
43302: ARRAY
43303: ST_TO_ADDR
43304: GO 43559
43306: LD_INT 36
43308: DOUBLE
43309: EQUAL
43310: IFTRUE 43314
43312: GO 43370
43314: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43315: LD_ADDR_VAR 0 9
43319: PUSH
43320: LD_VAR 0 47
43324: PUSH
43325: LD_VAR 0 48
43329: PUSH
43330: LD_VAR 0 49
43334: PUSH
43335: LD_VAR 0 50
43339: PUSH
43340: LD_VAR 0 51
43344: PUSH
43345: LD_VAR 0 52
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: LIST
43354: LIST
43355: LIST
43356: LIST
43357: PUSH
43358: LD_VAR 0 4
43362: PUSH
43363: LD_INT 1
43365: PLUS
43366: ARRAY
43367: ST_TO_ADDR
43368: GO 43559
43370: LD_INT 4
43372: DOUBLE
43373: EQUAL
43374: IFTRUE 43396
43376: LD_INT 5
43378: DOUBLE
43379: EQUAL
43380: IFTRUE 43396
43382: LD_INT 34
43384: DOUBLE
43385: EQUAL
43386: IFTRUE 43396
43388: LD_INT 37
43390: DOUBLE
43391: EQUAL
43392: IFTRUE 43396
43394: GO 43452
43396: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43397: LD_ADDR_VAR 0 9
43401: PUSH
43402: LD_VAR 0 53
43406: PUSH
43407: LD_VAR 0 54
43411: PUSH
43412: LD_VAR 0 55
43416: PUSH
43417: LD_VAR 0 56
43421: PUSH
43422: LD_VAR 0 57
43426: PUSH
43427: LD_VAR 0 58
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: LIST
43439: PUSH
43440: LD_VAR 0 4
43444: PUSH
43445: LD_INT 1
43447: PLUS
43448: ARRAY
43449: ST_TO_ADDR
43450: GO 43559
43452: LD_INT 31
43454: DOUBLE
43455: EQUAL
43456: IFTRUE 43502
43458: LD_INT 32
43460: DOUBLE
43461: EQUAL
43462: IFTRUE 43502
43464: LD_INT 33
43466: DOUBLE
43467: EQUAL
43468: IFTRUE 43502
43470: LD_INT 27
43472: DOUBLE
43473: EQUAL
43474: IFTRUE 43502
43476: LD_INT 26
43478: DOUBLE
43479: EQUAL
43480: IFTRUE 43502
43482: LD_INT 28
43484: DOUBLE
43485: EQUAL
43486: IFTRUE 43502
43488: LD_INT 29
43490: DOUBLE
43491: EQUAL
43492: IFTRUE 43502
43494: LD_INT 30
43496: DOUBLE
43497: EQUAL
43498: IFTRUE 43502
43500: GO 43558
43502: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43503: LD_ADDR_VAR 0 9
43507: PUSH
43508: LD_VAR 0 59
43512: PUSH
43513: LD_VAR 0 60
43517: PUSH
43518: LD_VAR 0 61
43522: PUSH
43523: LD_VAR 0 62
43527: PUSH
43528: LD_VAR 0 63
43532: PUSH
43533: LD_VAR 0 64
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: PUSH
43546: LD_VAR 0 4
43550: PUSH
43551: LD_INT 1
43553: PLUS
43554: ARRAY
43555: ST_TO_ADDR
43556: GO 43559
43558: POP
// temp_list2 = [ ] ;
43559: LD_ADDR_VAR 0 10
43563: PUSH
43564: EMPTY
43565: ST_TO_ADDR
// for i in temp_list do
43566: LD_ADDR_VAR 0 8
43570: PUSH
43571: LD_VAR 0 9
43575: PUSH
43576: FOR_IN
43577: IFFALSE 43629
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43579: LD_ADDR_VAR 0 10
43583: PUSH
43584: LD_VAR 0 10
43588: PUSH
43589: LD_VAR 0 8
43593: PUSH
43594: LD_INT 1
43596: ARRAY
43597: PUSH
43598: LD_VAR 0 2
43602: PLUS
43603: PUSH
43604: LD_VAR 0 8
43608: PUSH
43609: LD_INT 2
43611: ARRAY
43612: PUSH
43613: LD_VAR 0 3
43617: PLUS
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: EMPTY
43624: LIST
43625: ADD
43626: ST_TO_ADDR
43627: GO 43576
43629: POP
43630: POP
// result = temp_list2 ;
43631: LD_ADDR_VAR 0 7
43635: PUSH
43636: LD_VAR 0 10
43640: ST_TO_ADDR
// end ;
43641: LD_VAR 0 7
43645: RET
// export function EnemyInRange ( unit , dist ) ; begin
43646: LD_INT 0
43648: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43649: LD_ADDR_VAR 0 3
43653: PUSH
43654: LD_VAR 0 1
43658: PPUSH
43659: CALL_OW 255
43663: PPUSH
43664: LD_VAR 0 1
43668: PPUSH
43669: CALL_OW 250
43673: PPUSH
43674: LD_VAR 0 1
43678: PPUSH
43679: CALL_OW 251
43683: PPUSH
43684: LD_VAR 0 2
43688: PPUSH
43689: CALL 17048 0 4
43693: PUSH
43694: LD_INT 4
43696: ARRAY
43697: ST_TO_ADDR
// end ;
43698: LD_VAR 0 3
43702: RET
// export function PlayerSeeMe ( unit ) ; begin
43703: LD_INT 0
43705: PPUSH
// result := See ( your_side , unit ) ;
43706: LD_ADDR_VAR 0 2
43710: PUSH
43711: LD_OWVAR 2
43715: PPUSH
43716: LD_VAR 0 1
43720: PPUSH
43721: CALL_OW 292
43725: ST_TO_ADDR
// end ;
43726: LD_VAR 0 2
43730: RET
// export function ReverseDir ( unit ) ; begin
43731: LD_INT 0
43733: PPUSH
// if not unit then
43734: LD_VAR 0 1
43738: NOT
43739: IFFALSE 43743
// exit ;
43741: GO 43766
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43743: LD_ADDR_VAR 0 2
43747: PUSH
43748: LD_VAR 0 1
43752: PPUSH
43753: CALL_OW 254
43757: PUSH
43758: LD_INT 3
43760: PLUS
43761: PUSH
43762: LD_INT 6
43764: MOD
43765: ST_TO_ADDR
// end ;
43766: LD_VAR 0 2
43770: RET
// export function ReverseArray ( array ) ; var i ; begin
43771: LD_INT 0
43773: PPUSH
43774: PPUSH
// if not array then
43775: LD_VAR 0 1
43779: NOT
43780: IFFALSE 43784
// exit ;
43782: GO 43839
// result := [ ] ;
43784: LD_ADDR_VAR 0 2
43788: PUSH
43789: EMPTY
43790: ST_TO_ADDR
// for i := array downto 1 do
43791: LD_ADDR_VAR 0 3
43795: PUSH
43796: DOUBLE
43797: LD_VAR 0 1
43801: INC
43802: ST_TO_ADDR
43803: LD_INT 1
43805: PUSH
43806: FOR_DOWNTO
43807: IFFALSE 43837
// result := Join ( result , array [ i ] ) ;
43809: LD_ADDR_VAR 0 2
43813: PUSH
43814: LD_VAR 0 2
43818: PPUSH
43819: LD_VAR 0 1
43823: PUSH
43824: LD_VAR 0 3
43828: ARRAY
43829: PPUSH
43830: CALL 48464 0 2
43834: ST_TO_ADDR
43835: GO 43806
43837: POP
43838: POP
// end ;
43839: LD_VAR 0 2
43843: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
43844: LD_INT 0
43846: PPUSH
43847: PPUSH
43848: PPUSH
43849: PPUSH
43850: PPUSH
43851: PPUSH
// if not unit or not hexes then
43852: LD_VAR 0 1
43856: NOT
43857: PUSH
43858: LD_VAR 0 2
43862: NOT
43863: OR
43864: IFFALSE 43868
// exit ;
43866: GO 43991
// dist := 9999 ;
43868: LD_ADDR_VAR 0 5
43872: PUSH
43873: LD_INT 9999
43875: ST_TO_ADDR
// for i = 1 to hexes do
43876: LD_ADDR_VAR 0 4
43880: PUSH
43881: DOUBLE
43882: LD_INT 1
43884: DEC
43885: ST_TO_ADDR
43886: LD_VAR 0 2
43890: PUSH
43891: FOR_TO
43892: IFFALSE 43979
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43894: LD_ADDR_VAR 0 6
43898: PUSH
43899: LD_VAR 0 1
43903: PPUSH
43904: LD_VAR 0 2
43908: PUSH
43909: LD_VAR 0 4
43913: ARRAY
43914: PUSH
43915: LD_INT 1
43917: ARRAY
43918: PPUSH
43919: LD_VAR 0 2
43923: PUSH
43924: LD_VAR 0 4
43928: ARRAY
43929: PUSH
43930: LD_INT 2
43932: ARRAY
43933: PPUSH
43934: CALL_OW 297
43938: ST_TO_ADDR
// if tdist < dist then
43939: LD_VAR 0 6
43943: PUSH
43944: LD_VAR 0 5
43948: LESS
43949: IFFALSE 43977
// begin hex := hexes [ i ] ;
43951: LD_ADDR_VAR 0 8
43955: PUSH
43956: LD_VAR 0 2
43960: PUSH
43961: LD_VAR 0 4
43965: ARRAY
43966: ST_TO_ADDR
// dist := tdist ;
43967: LD_ADDR_VAR 0 5
43971: PUSH
43972: LD_VAR 0 6
43976: ST_TO_ADDR
// end ; end ;
43977: GO 43891
43979: POP
43980: POP
// result := hex ;
43981: LD_ADDR_VAR 0 3
43985: PUSH
43986: LD_VAR 0 8
43990: ST_TO_ADDR
// end ;
43991: LD_VAR 0 3
43995: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43996: LD_INT 0
43998: PPUSH
43999: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
44000: LD_VAR 0 1
44004: NOT
44005: PUSH
44006: LD_VAR 0 1
44010: PUSH
44011: LD_INT 21
44013: PUSH
44014: LD_INT 2
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 23
44023: PUSH
44024: LD_INT 2
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PPUSH
44035: CALL_OW 69
44039: IN
44040: NOT
44041: OR
44042: IFFALSE 44046
// exit ;
44044: GO 44093
// for i = 1 to 3 do
44046: LD_ADDR_VAR 0 3
44050: PUSH
44051: DOUBLE
44052: LD_INT 1
44054: DEC
44055: ST_TO_ADDR
44056: LD_INT 3
44058: PUSH
44059: FOR_TO
44060: IFFALSE 44091
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44062: LD_VAR 0 1
44066: PPUSH
44067: CALL_OW 250
44071: PPUSH
44072: LD_VAR 0 1
44076: PPUSH
44077: CALL_OW 251
44081: PPUSH
44082: LD_INT 1
44084: PPUSH
44085: CALL_OW 453
44089: GO 44059
44091: POP
44092: POP
// end ;
44093: LD_VAR 0 2
44097: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44098: LD_INT 0
44100: PPUSH
44101: PPUSH
44102: PPUSH
44103: PPUSH
44104: PPUSH
44105: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44106: LD_VAR 0 1
44110: NOT
44111: PUSH
44112: LD_VAR 0 2
44116: NOT
44117: OR
44118: PUSH
44119: LD_VAR 0 1
44123: PPUSH
44124: CALL_OW 314
44128: OR
44129: IFFALSE 44133
// exit ;
44131: GO 44574
// x := GetX ( enemy_unit ) ;
44133: LD_ADDR_VAR 0 7
44137: PUSH
44138: LD_VAR 0 2
44142: PPUSH
44143: CALL_OW 250
44147: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44148: LD_ADDR_VAR 0 8
44152: PUSH
44153: LD_VAR 0 2
44157: PPUSH
44158: CALL_OW 251
44162: ST_TO_ADDR
// if not x or not y then
44163: LD_VAR 0 7
44167: NOT
44168: PUSH
44169: LD_VAR 0 8
44173: NOT
44174: OR
44175: IFFALSE 44179
// exit ;
44177: GO 44574
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44179: LD_ADDR_VAR 0 6
44183: PUSH
44184: LD_VAR 0 7
44188: PPUSH
44189: LD_INT 0
44191: PPUSH
44192: LD_INT 4
44194: PPUSH
44195: CALL_OW 272
44199: PUSH
44200: LD_VAR 0 8
44204: PPUSH
44205: LD_INT 0
44207: PPUSH
44208: LD_INT 4
44210: PPUSH
44211: CALL_OW 273
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_VAR 0 7
44224: PPUSH
44225: LD_INT 1
44227: PPUSH
44228: LD_INT 4
44230: PPUSH
44231: CALL_OW 272
44235: PUSH
44236: LD_VAR 0 8
44240: PPUSH
44241: LD_INT 1
44243: PPUSH
44244: LD_INT 4
44246: PPUSH
44247: CALL_OW 273
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_VAR 0 7
44260: PPUSH
44261: LD_INT 2
44263: PPUSH
44264: LD_INT 4
44266: PPUSH
44267: CALL_OW 272
44271: PUSH
44272: LD_VAR 0 8
44276: PPUSH
44277: LD_INT 2
44279: PPUSH
44280: LD_INT 4
44282: PPUSH
44283: CALL_OW 273
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: LD_VAR 0 7
44296: PPUSH
44297: LD_INT 3
44299: PPUSH
44300: LD_INT 4
44302: PPUSH
44303: CALL_OW 272
44307: PUSH
44308: LD_VAR 0 8
44312: PPUSH
44313: LD_INT 3
44315: PPUSH
44316: LD_INT 4
44318: PPUSH
44319: CALL_OW 273
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_VAR 0 7
44332: PPUSH
44333: LD_INT 4
44335: PPUSH
44336: LD_INT 4
44338: PPUSH
44339: CALL_OW 272
44343: PUSH
44344: LD_VAR 0 8
44348: PPUSH
44349: LD_INT 4
44351: PPUSH
44352: LD_INT 4
44354: PPUSH
44355: CALL_OW 273
44359: PUSH
44360: EMPTY
44361: LIST
44362: LIST
44363: PUSH
44364: LD_VAR 0 7
44368: PPUSH
44369: LD_INT 5
44371: PPUSH
44372: LD_INT 4
44374: PPUSH
44375: CALL_OW 272
44379: PUSH
44380: LD_VAR 0 8
44384: PPUSH
44385: LD_INT 5
44387: PPUSH
44388: LD_INT 4
44390: PPUSH
44391: CALL_OW 273
44395: PUSH
44396: EMPTY
44397: LIST
44398: LIST
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: ST_TO_ADDR
// for i = tmp downto 1 do
44408: LD_ADDR_VAR 0 4
44412: PUSH
44413: DOUBLE
44414: LD_VAR 0 6
44418: INC
44419: ST_TO_ADDR
44420: LD_INT 1
44422: PUSH
44423: FOR_DOWNTO
44424: IFFALSE 44525
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44426: LD_VAR 0 6
44430: PUSH
44431: LD_VAR 0 4
44435: ARRAY
44436: PUSH
44437: LD_INT 1
44439: ARRAY
44440: PPUSH
44441: LD_VAR 0 6
44445: PUSH
44446: LD_VAR 0 4
44450: ARRAY
44451: PUSH
44452: LD_INT 2
44454: ARRAY
44455: PPUSH
44456: CALL_OW 488
44460: NOT
44461: PUSH
44462: LD_VAR 0 6
44466: PUSH
44467: LD_VAR 0 4
44471: ARRAY
44472: PUSH
44473: LD_INT 1
44475: ARRAY
44476: PPUSH
44477: LD_VAR 0 6
44481: PUSH
44482: LD_VAR 0 4
44486: ARRAY
44487: PUSH
44488: LD_INT 2
44490: ARRAY
44491: PPUSH
44492: CALL_OW 428
44496: PUSH
44497: LD_INT 0
44499: NONEQUAL
44500: OR
44501: IFFALSE 44523
// tmp := Delete ( tmp , i ) ;
44503: LD_ADDR_VAR 0 6
44507: PUSH
44508: LD_VAR 0 6
44512: PPUSH
44513: LD_VAR 0 4
44517: PPUSH
44518: CALL_OW 3
44522: ST_TO_ADDR
44523: GO 44423
44525: POP
44526: POP
// j := GetClosestHex ( unit , tmp ) ;
44527: LD_ADDR_VAR 0 5
44531: PUSH
44532: LD_VAR 0 1
44536: PPUSH
44537: LD_VAR 0 6
44541: PPUSH
44542: CALL 43844 0 2
44546: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44547: LD_VAR 0 1
44551: PPUSH
44552: LD_VAR 0 5
44556: PUSH
44557: LD_INT 1
44559: ARRAY
44560: PPUSH
44561: LD_VAR 0 5
44565: PUSH
44566: LD_INT 2
44568: ARRAY
44569: PPUSH
44570: CALL_OW 111
// end ;
44574: LD_VAR 0 3
44578: RET
// export function PrepareApemanSoldier ( ) ; begin
44579: LD_INT 0
44581: PPUSH
// uc_nation := 0 ;
44582: LD_ADDR_OWVAR 21
44586: PUSH
44587: LD_INT 0
44589: ST_TO_ADDR
// hc_sex := sex_male ;
44590: LD_ADDR_OWVAR 27
44594: PUSH
44595: LD_INT 1
44597: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44598: LD_ADDR_OWVAR 28
44602: PUSH
44603: LD_INT 15
44605: ST_TO_ADDR
// hc_gallery :=  ;
44606: LD_ADDR_OWVAR 33
44610: PUSH
44611: LD_STRING 
44613: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44614: LD_ADDR_OWVAR 31
44618: PUSH
44619: LD_INT 0
44621: PPUSH
44622: LD_INT 3
44624: PPUSH
44625: CALL_OW 12
44629: PUSH
44630: LD_INT 0
44632: PPUSH
44633: LD_INT 3
44635: PPUSH
44636: CALL_OW 12
44640: PUSH
44641: LD_INT 0
44643: PUSH
44644: LD_INT 0
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: ST_TO_ADDR
// end ;
44653: LD_VAR 0 1
44657: RET
// export function PrepareApemanEngineer ( ) ; begin
44658: LD_INT 0
44660: PPUSH
// uc_nation := 0 ;
44661: LD_ADDR_OWVAR 21
44665: PUSH
44666: LD_INT 0
44668: ST_TO_ADDR
// hc_sex := sex_male ;
44669: LD_ADDR_OWVAR 27
44673: PUSH
44674: LD_INT 1
44676: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
44677: LD_ADDR_OWVAR 28
44681: PUSH
44682: LD_INT 16
44684: ST_TO_ADDR
// hc_gallery :=  ;
44685: LD_ADDR_OWVAR 33
44689: PUSH
44690: LD_STRING 
44692: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44693: LD_ADDR_OWVAR 31
44697: PUSH
44698: LD_INT 0
44700: PPUSH
44701: LD_INT 3
44703: PPUSH
44704: CALL_OW 12
44708: PUSH
44709: LD_INT 0
44711: PPUSH
44712: LD_INT 3
44714: PPUSH
44715: CALL_OW 12
44719: PUSH
44720: LD_INT 0
44722: PUSH
44723: LD_INT 0
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: LIST
44730: LIST
44731: ST_TO_ADDR
// end ;
44732: LD_VAR 0 1
44736: RET
// export function PrepareApeman ( agressivity ) ; begin
44737: LD_INT 0
44739: PPUSH
// uc_side := 0 ;
44740: LD_ADDR_OWVAR 20
44744: PUSH
44745: LD_INT 0
44747: ST_TO_ADDR
// uc_nation := 0 ;
44748: LD_ADDR_OWVAR 21
44752: PUSH
44753: LD_INT 0
44755: ST_TO_ADDR
// hc_sex := sex_male ;
44756: LD_ADDR_OWVAR 27
44760: PUSH
44761: LD_INT 1
44763: ST_TO_ADDR
// hc_class := class_apeman ;
44764: LD_ADDR_OWVAR 28
44768: PUSH
44769: LD_INT 12
44771: ST_TO_ADDR
// hc_gallery :=  ;
44772: LD_ADDR_OWVAR 33
44776: PUSH
44777: LD_STRING 
44779: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44780: LD_ADDR_OWVAR 35
44784: PUSH
44785: LD_VAR 0 1
44789: NEG
44790: PPUSH
44791: LD_VAR 0 1
44795: PPUSH
44796: CALL_OW 12
44800: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44801: LD_ADDR_OWVAR 31
44805: PUSH
44806: LD_INT 0
44808: PPUSH
44809: LD_INT 3
44811: PPUSH
44812: CALL_OW 12
44816: PUSH
44817: LD_INT 0
44819: PPUSH
44820: LD_INT 3
44822: PPUSH
44823: CALL_OW 12
44827: PUSH
44828: LD_INT 0
44830: PUSH
44831: LD_INT 0
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: ST_TO_ADDR
// end ;
44840: LD_VAR 0 2
44844: RET
// export function PrepareTiger ( agressivity ) ; begin
44845: LD_INT 0
44847: PPUSH
// uc_side := 0 ;
44848: LD_ADDR_OWVAR 20
44852: PUSH
44853: LD_INT 0
44855: ST_TO_ADDR
// uc_nation := 0 ;
44856: LD_ADDR_OWVAR 21
44860: PUSH
44861: LD_INT 0
44863: ST_TO_ADDR
// hc_class := class_tiger ;
44864: LD_ADDR_OWVAR 28
44868: PUSH
44869: LD_INT 14
44871: ST_TO_ADDR
// hc_gallery :=  ;
44872: LD_ADDR_OWVAR 33
44876: PUSH
44877: LD_STRING 
44879: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44880: LD_ADDR_OWVAR 35
44884: PUSH
44885: LD_VAR 0 1
44889: NEG
44890: PPUSH
44891: LD_VAR 0 1
44895: PPUSH
44896: CALL_OW 12
44900: ST_TO_ADDR
// end ;
44901: LD_VAR 0 2
44905: RET
// export function PrepareEnchidna ( ) ; begin
44906: LD_INT 0
44908: PPUSH
// uc_side := 0 ;
44909: LD_ADDR_OWVAR 20
44913: PUSH
44914: LD_INT 0
44916: ST_TO_ADDR
// uc_nation := 0 ;
44917: LD_ADDR_OWVAR 21
44921: PUSH
44922: LD_INT 0
44924: ST_TO_ADDR
// hc_class := class_baggie ;
44925: LD_ADDR_OWVAR 28
44929: PUSH
44930: LD_INT 13
44932: ST_TO_ADDR
// hc_gallery :=  ;
44933: LD_ADDR_OWVAR 33
44937: PUSH
44938: LD_STRING 
44940: ST_TO_ADDR
// end ;
44941: LD_VAR 0 1
44945: RET
// export function PrepareFrog ( ) ; begin
44946: LD_INT 0
44948: PPUSH
// uc_side := 0 ;
44949: LD_ADDR_OWVAR 20
44953: PUSH
44954: LD_INT 0
44956: ST_TO_ADDR
// uc_nation := 0 ;
44957: LD_ADDR_OWVAR 21
44961: PUSH
44962: LD_INT 0
44964: ST_TO_ADDR
// hc_class := class_frog ;
44965: LD_ADDR_OWVAR 28
44969: PUSH
44970: LD_INT 19
44972: ST_TO_ADDR
// hc_gallery :=  ;
44973: LD_ADDR_OWVAR 33
44977: PUSH
44978: LD_STRING 
44980: ST_TO_ADDR
// end ;
44981: LD_VAR 0 1
44985: RET
// export function PrepareFish ( ) ; begin
44986: LD_INT 0
44988: PPUSH
// uc_side := 0 ;
44989: LD_ADDR_OWVAR 20
44993: PUSH
44994: LD_INT 0
44996: ST_TO_ADDR
// uc_nation := 0 ;
44997: LD_ADDR_OWVAR 21
45001: PUSH
45002: LD_INT 0
45004: ST_TO_ADDR
// hc_class := class_fish ;
45005: LD_ADDR_OWVAR 28
45009: PUSH
45010: LD_INT 20
45012: ST_TO_ADDR
// hc_gallery :=  ;
45013: LD_ADDR_OWVAR 33
45017: PUSH
45018: LD_STRING 
45020: ST_TO_ADDR
// end ;
45021: LD_VAR 0 1
45025: RET
// export function PrepareBird ( ) ; begin
45026: LD_INT 0
45028: PPUSH
// uc_side := 0 ;
45029: LD_ADDR_OWVAR 20
45033: PUSH
45034: LD_INT 0
45036: ST_TO_ADDR
// uc_nation := 0 ;
45037: LD_ADDR_OWVAR 21
45041: PUSH
45042: LD_INT 0
45044: ST_TO_ADDR
// hc_class := class_phororhacos ;
45045: LD_ADDR_OWVAR 28
45049: PUSH
45050: LD_INT 18
45052: ST_TO_ADDR
// hc_gallery :=  ;
45053: LD_ADDR_OWVAR 33
45057: PUSH
45058: LD_STRING 
45060: ST_TO_ADDR
// end ;
45061: LD_VAR 0 1
45065: RET
// export function PrepareHorse ( ) ; begin
45066: LD_INT 0
45068: PPUSH
// uc_side := 0 ;
45069: LD_ADDR_OWVAR 20
45073: PUSH
45074: LD_INT 0
45076: ST_TO_ADDR
// uc_nation := 0 ;
45077: LD_ADDR_OWVAR 21
45081: PUSH
45082: LD_INT 0
45084: ST_TO_ADDR
// hc_class := class_horse ;
45085: LD_ADDR_OWVAR 28
45089: PUSH
45090: LD_INT 21
45092: ST_TO_ADDR
// hc_gallery :=  ;
45093: LD_ADDR_OWVAR 33
45097: PUSH
45098: LD_STRING 
45100: ST_TO_ADDR
// end ;
45101: LD_VAR 0 1
45105: RET
// export function PrepareMastodont ( ) ; begin
45106: LD_INT 0
45108: PPUSH
// uc_side := 0 ;
45109: LD_ADDR_OWVAR 20
45113: PUSH
45114: LD_INT 0
45116: ST_TO_ADDR
// uc_nation := 0 ;
45117: LD_ADDR_OWVAR 21
45121: PUSH
45122: LD_INT 0
45124: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45125: LD_ADDR_OWVAR 37
45129: PUSH
45130: LD_INT 31
45132: ST_TO_ADDR
// vc_control := control_rider ;
45133: LD_ADDR_OWVAR 38
45137: PUSH
45138: LD_INT 4
45140: ST_TO_ADDR
// end ;
45141: LD_VAR 0 1
45145: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45146: LD_INT 0
45148: PPUSH
45149: PPUSH
45150: PPUSH
// uc_side = 0 ;
45151: LD_ADDR_OWVAR 20
45155: PUSH
45156: LD_INT 0
45158: ST_TO_ADDR
// uc_nation = 0 ;
45159: LD_ADDR_OWVAR 21
45163: PUSH
45164: LD_INT 0
45166: ST_TO_ADDR
// InitHc_All ( ) ;
45167: CALL_OW 584
// InitVc ;
45171: CALL_OW 20
// if mastodonts then
45175: LD_VAR 0 6
45179: IFFALSE 45246
// for i = 1 to mastodonts do
45181: LD_ADDR_VAR 0 11
45185: PUSH
45186: DOUBLE
45187: LD_INT 1
45189: DEC
45190: ST_TO_ADDR
45191: LD_VAR 0 6
45195: PUSH
45196: FOR_TO
45197: IFFALSE 45244
// begin vc_chassis := 31 ;
45199: LD_ADDR_OWVAR 37
45203: PUSH
45204: LD_INT 31
45206: ST_TO_ADDR
// vc_control := control_rider ;
45207: LD_ADDR_OWVAR 38
45211: PUSH
45212: LD_INT 4
45214: ST_TO_ADDR
// animal := CreateVehicle ;
45215: LD_ADDR_VAR 0 12
45219: PUSH
45220: CALL_OW 45
45224: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45225: LD_VAR 0 12
45229: PPUSH
45230: LD_VAR 0 8
45234: PPUSH
45235: LD_INT 0
45237: PPUSH
45238: CALL 47381 0 3
// end ;
45242: GO 45196
45244: POP
45245: POP
// if horses then
45246: LD_VAR 0 5
45250: IFFALSE 45317
// for i = 1 to horses do
45252: LD_ADDR_VAR 0 11
45256: PUSH
45257: DOUBLE
45258: LD_INT 1
45260: DEC
45261: ST_TO_ADDR
45262: LD_VAR 0 5
45266: PUSH
45267: FOR_TO
45268: IFFALSE 45315
// begin hc_class := 21 ;
45270: LD_ADDR_OWVAR 28
45274: PUSH
45275: LD_INT 21
45277: ST_TO_ADDR
// hc_gallery :=  ;
45278: LD_ADDR_OWVAR 33
45282: PUSH
45283: LD_STRING 
45285: ST_TO_ADDR
// animal := CreateHuman ;
45286: LD_ADDR_VAR 0 12
45290: PUSH
45291: CALL_OW 44
45295: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45296: LD_VAR 0 12
45300: PPUSH
45301: LD_VAR 0 8
45305: PPUSH
45306: LD_INT 0
45308: PPUSH
45309: CALL 47381 0 3
// end ;
45313: GO 45267
45315: POP
45316: POP
// if birds then
45317: LD_VAR 0 1
45321: IFFALSE 45388
// for i = 1 to birds do
45323: LD_ADDR_VAR 0 11
45327: PUSH
45328: DOUBLE
45329: LD_INT 1
45331: DEC
45332: ST_TO_ADDR
45333: LD_VAR 0 1
45337: PUSH
45338: FOR_TO
45339: IFFALSE 45386
// begin hc_class = 18 ;
45341: LD_ADDR_OWVAR 28
45345: PUSH
45346: LD_INT 18
45348: ST_TO_ADDR
// hc_gallery =  ;
45349: LD_ADDR_OWVAR 33
45353: PUSH
45354: LD_STRING 
45356: ST_TO_ADDR
// animal := CreateHuman ;
45357: LD_ADDR_VAR 0 12
45361: PUSH
45362: CALL_OW 44
45366: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45367: LD_VAR 0 12
45371: PPUSH
45372: LD_VAR 0 8
45376: PPUSH
45377: LD_INT 0
45379: PPUSH
45380: CALL 47381 0 3
// end ;
45384: GO 45338
45386: POP
45387: POP
// if tigers then
45388: LD_VAR 0 2
45392: IFFALSE 45476
// for i = 1 to tigers do
45394: LD_ADDR_VAR 0 11
45398: PUSH
45399: DOUBLE
45400: LD_INT 1
45402: DEC
45403: ST_TO_ADDR
45404: LD_VAR 0 2
45408: PUSH
45409: FOR_TO
45410: IFFALSE 45474
// begin hc_class = class_tiger ;
45412: LD_ADDR_OWVAR 28
45416: PUSH
45417: LD_INT 14
45419: ST_TO_ADDR
// hc_gallery =  ;
45420: LD_ADDR_OWVAR 33
45424: PUSH
45425: LD_STRING 
45427: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45428: LD_ADDR_OWVAR 35
45432: PUSH
45433: LD_INT 7
45435: NEG
45436: PPUSH
45437: LD_INT 7
45439: PPUSH
45440: CALL_OW 12
45444: ST_TO_ADDR
// animal := CreateHuman ;
45445: LD_ADDR_VAR 0 12
45449: PUSH
45450: CALL_OW 44
45454: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45455: LD_VAR 0 12
45459: PPUSH
45460: LD_VAR 0 8
45464: PPUSH
45465: LD_INT 0
45467: PPUSH
45468: CALL 47381 0 3
// end ;
45472: GO 45409
45474: POP
45475: POP
// if apemans then
45476: LD_VAR 0 3
45480: IFFALSE 45603
// for i = 1 to apemans do
45482: LD_ADDR_VAR 0 11
45486: PUSH
45487: DOUBLE
45488: LD_INT 1
45490: DEC
45491: ST_TO_ADDR
45492: LD_VAR 0 3
45496: PUSH
45497: FOR_TO
45498: IFFALSE 45601
// begin hc_class = class_apeman ;
45500: LD_ADDR_OWVAR 28
45504: PUSH
45505: LD_INT 12
45507: ST_TO_ADDR
// hc_gallery =  ;
45508: LD_ADDR_OWVAR 33
45512: PUSH
45513: LD_STRING 
45515: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45516: LD_ADDR_OWVAR 35
45520: PUSH
45521: LD_INT 2
45523: NEG
45524: PPUSH
45525: LD_INT 2
45527: PPUSH
45528: CALL_OW 12
45532: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45533: LD_ADDR_OWVAR 31
45537: PUSH
45538: LD_INT 1
45540: PPUSH
45541: LD_INT 3
45543: PPUSH
45544: CALL_OW 12
45548: PUSH
45549: LD_INT 1
45551: PPUSH
45552: LD_INT 3
45554: PPUSH
45555: CALL_OW 12
45559: PUSH
45560: LD_INT 0
45562: PUSH
45563: LD_INT 0
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: ST_TO_ADDR
// animal := CreateHuman ;
45572: LD_ADDR_VAR 0 12
45576: PUSH
45577: CALL_OW 44
45581: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45582: LD_VAR 0 12
45586: PPUSH
45587: LD_VAR 0 8
45591: PPUSH
45592: LD_INT 0
45594: PPUSH
45595: CALL 47381 0 3
// end ;
45599: GO 45497
45601: POP
45602: POP
// if enchidnas then
45603: LD_VAR 0 4
45607: IFFALSE 45674
// for i = 1 to enchidnas do
45609: LD_ADDR_VAR 0 11
45613: PUSH
45614: DOUBLE
45615: LD_INT 1
45617: DEC
45618: ST_TO_ADDR
45619: LD_VAR 0 4
45623: PUSH
45624: FOR_TO
45625: IFFALSE 45672
// begin hc_class = 13 ;
45627: LD_ADDR_OWVAR 28
45631: PUSH
45632: LD_INT 13
45634: ST_TO_ADDR
// hc_gallery =  ;
45635: LD_ADDR_OWVAR 33
45639: PUSH
45640: LD_STRING 
45642: ST_TO_ADDR
// animal := CreateHuman ;
45643: LD_ADDR_VAR 0 12
45647: PUSH
45648: CALL_OW 44
45652: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45653: LD_VAR 0 12
45657: PPUSH
45658: LD_VAR 0 8
45662: PPUSH
45663: LD_INT 0
45665: PPUSH
45666: CALL 47381 0 3
// end ;
45670: GO 45624
45672: POP
45673: POP
// if fishes then
45674: LD_VAR 0 7
45678: IFFALSE 45745
// for i = 1 to fishes do
45680: LD_ADDR_VAR 0 11
45684: PUSH
45685: DOUBLE
45686: LD_INT 1
45688: DEC
45689: ST_TO_ADDR
45690: LD_VAR 0 7
45694: PUSH
45695: FOR_TO
45696: IFFALSE 45743
// begin hc_class = 20 ;
45698: LD_ADDR_OWVAR 28
45702: PUSH
45703: LD_INT 20
45705: ST_TO_ADDR
// hc_gallery =  ;
45706: LD_ADDR_OWVAR 33
45710: PUSH
45711: LD_STRING 
45713: ST_TO_ADDR
// animal := CreateHuman ;
45714: LD_ADDR_VAR 0 12
45718: PUSH
45719: CALL_OW 44
45723: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
45724: LD_VAR 0 12
45728: PPUSH
45729: LD_VAR 0 9
45733: PPUSH
45734: LD_INT 0
45736: PPUSH
45737: CALL 47381 0 3
// end ;
45741: GO 45695
45743: POP
45744: POP
// end ;
45745: LD_VAR 0 10
45749: RET
// export function WantHeal ( sci , unit ) ; begin
45750: LD_INT 0
45752: PPUSH
// if GetTaskList ( sci ) > 0 then
45753: LD_VAR 0 1
45757: PPUSH
45758: CALL_OW 437
45762: PUSH
45763: LD_INT 0
45765: GREATER
45766: IFFALSE 45836
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45768: LD_VAR 0 1
45772: PPUSH
45773: CALL_OW 437
45777: PUSH
45778: LD_INT 1
45780: ARRAY
45781: PUSH
45782: LD_INT 1
45784: ARRAY
45785: PUSH
45786: LD_STRING l
45788: EQUAL
45789: PUSH
45790: LD_VAR 0 1
45794: PPUSH
45795: CALL_OW 437
45799: PUSH
45800: LD_INT 1
45802: ARRAY
45803: PUSH
45804: LD_INT 4
45806: ARRAY
45807: PUSH
45808: LD_VAR 0 2
45812: EQUAL
45813: AND
45814: IFFALSE 45826
// result := true else
45816: LD_ADDR_VAR 0 3
45820: PUSH
45821: LD_INT 1
45823: ST_TO_ADDR
45824: GO 45834
// result := false ;
45826: LD_ADDR_VAR 0 3
45830: PUSH
45831: LD_INT 0
45833: ST_TO_ADDR
// end else
45834: GO 45844
// result := false ;
45836: LD_ADDR_VAR 0 3
45840: PUSH
45841: LD_INT 0
45843: ST_TO_ADDR
// end ;
45844: LD_VAR 0 3
45848: RET
// export function HealTarget ( sci ) ; begin
45849: LD_INT 0
45851: PPUSH
// if not sci then
45852: LD_VAR 0 1
45856: NOT
45857: IFFALSE 45861
// exit ;
45859: GO 45926
// result := 0 ;
45861: LD_ADDR_VAR 0 2
45865: PUSH
45866: LD_INT 0
45868: ST_TO_ADDR
// if GetTaskList ( sci ) then
45869: LD_VAR 0 1
45873: PPUSH
45874: CALL_OW 437
45878: IFFALSE 45926
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45880: LD_VAR 0 1
45884: PPUSH
45885: CALL_OW 437
45889: PUSH
45890: LD_INT 1
45892: ARRAY
45893: PUSH
45894: LD_INT 1
45896: ARRAY
45897: PUSH
45898: LD_STRING l
45900: EQUAL
45901: IFFALSE 45926
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45903: LD_ADDR_VAR 0 2
45907: PUSH
45908: LD_VAR 0 1
45912: PPUSH
45913: CALL_OW 437
45917: PUSH
45918: LD_INT 1
45920: ARRAY
45921: PUSH
45922: LD_INT 4
45924: ARRAY
45925: ST_TO_ADDR
// end ;
45926: LD_VAR 0 2
45930: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45931: LD_INT 0
45933: PPUSH
45934: PPUSH
45935: PPUSH
45936: PPUSH
// if not base_units then
45937: LD_VAR 0 1
45941: NOT
45942: IFFALSE 45946
// exit ;
45944: GO 46033
// result := false ;
45946: LD_ADDR_VAR 0 2
45950: PUSH
45951: LD_INT 0
45953: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45954: LD_ADDR_VAR 0 5
45958: PUSH
45959: LD_VAR 0 1
45963: PPUSH
45964: LD_INT 21
45966: PUSH
45967: LD_INT 3
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PPUSH
45974: CALL_OW 72
45978: ST_TO_ADDR
// if not tmp then
45979: LD_VAR 0 5
45983: NOT
45984: IFFALSE 45988
// exit ;
45986: GO 46033
// for i in tmp do
45988: LD_ADDR_VAR 0 3
45992: PUSH
45993: LD_VAR 0 5
45997: PUSH
45998: FOR_IN
45999: IFFALSE 46031
// begin result := EnemyInRange ( i , 22 ) ;
46001: LD_ADDR_VAR 0 2
46005: PUSH
46006: LD_VAR 0 3
46010: PPUSH
46011: LD_INT 22
46013: PPUSH
46014: CALL 43646 0 2
46018: ST_TO_ADDR
// if result then
46019: LD_VAR 0 2
46023: IFFALSE 46029
// exit ;
46025: POP
46026: POP
46027: GO 46033
// end ;
46029: GO 45998
46031: POP
46032: POP
// end ;
46033: LD_VAR 0 2
46037: RET
// export function FilterByTag ( units , tag ) ; begin
46038: LD_INT 0
46040: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46041: LD_ADDR_VAR 0 3
46045: PUSH
46046: LD_VAR 0 1
46050: PPUSH
46051: LD_INT 120
46053: PUSH
46054: LD_VAR 0 2
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: PPUSH
46063: CALL_OW 72
46067: ST_TO_ADDR
// end ;
46068: LD_VAR 0 3
46072: RET
// export function IsDriver ( un ) ; begin
46073: LD_INT 0
46075: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46076: LD_ADDR_VAR 0 2
46080: PUSH
46081: LD_VAR 0 1
46085: PUSH
46086: LD_INT 55
46088: PUSH
46089: EMPTY
46090: LIST
46091: PPUSH
46092: CALL_OW 69
46096: IN
46097: ST_TO_ADDR
// end ;
46098: LD_VAR 0 2
46102: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46103: LD_INT 0
46105: PPUSH
46106: PPUSH
// list := [ ] ;
46107: LD_ADDR_VAR 0 5
46111: PUSH
46112: EMPTY
46113: ST_TO_ADDR
// case d of 0 :
46114: LD_VAR 0 3
46118: PUSH
46119: LD_INT 0
46121: DOUBLE
46122: EQUAL
46123: IFTRUE 46127
46125: GO 46260
46127: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46128: LD_ADDR_VAR 0 5
46132: PUSH
46133: LD_VAR 0 1
46137: PUSH
46138: LD_INT 4
46140: MINUS
46141: PUSH
46142: LD_VAR 0 2
46146: PUSH
46147: LD_INT 4
46149: MINUS
46150: PUSH
46151: LD_INT 2
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: LIST
46158: PUSH
46159: LD_VAR 0 1
46163: PUSH
46164: LD_INT 3
46166: MINUS
46167: PUSH
46168: LD_VAR 0 2
46172: PUSH
46173: LD_INT 1
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: LIST
46180: PUSH
46181: LD_VAR 0 1
46185: PUSH
46186: LD_INT 4
46188: PLUS
46189: PUSH
46190: LD_VAR 0 2
46194: PUSH
46195: LD_INT 4
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: LIST
46202: PUSH
46203: LD_VAR 0 1
46207: PUSH
46208: LD_INT 3
46210: PLUS
46211: PUSH
46212: LD_VAR 0 2
46216: PUSH
46217: LD_INT 3
46219: PLUS
46220: PUSH
46221: LD_INT 5
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: LIST
46228: PUSH
46229: LD_VAR 0 1
46233: PUSH
46234: LD_VAR 0 2
46238: PUSH
46239: LD_INT 4
46241: PLUS
46242: PUSH
46243: LD_INT 0
46245: PUSH
46246: EMPTY
46247: LIST
46248: LIST
46249: LIST
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: ST_TO_ADDR
// end ; 1 :
46258: GO 46958
46260: LD_INT 1
46262: DOUBLE
46263: EQUAL
46264: IFTRUE 46268
46266: GO 46401
46268: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46269: LD_ADDR_VAR 0 5
46273: PUSH
46274: LD_VAR 0 1
46278: PUSH
46279: LD_VAR 0 2
46283: PUSH
46284: LD_INT 4
46286: MINUS
46287: PUSH
46288: LD_INT 3
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: LIST
46295: PUSH
46296: LD_VAR 0 1
46300: PUSH
46301: LD_INT 3
46303: MINUS
46304: PUSH
46305: LD_VAR 0 2
46309: PUSH
46310: LD_INT 3
46312: MINUS
46313: PUSH
46314: LD_INT 2
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: LIST
46321: PUSH
46322: LD_VAR 0 1
46326: PUSH
46327: LD_INT 4
46329: MINUS
46330: PUSH
46331: LD_VAR 0 2
46335: PUSH
46336: LD_INT 1
46338: PUSH
46339: EMPTY
46340: LIST
46341: LIST
46342: LIST
46343: PUSH
46344: LD_VAR 0 1
46348: PUSH
46349: LD_VAR 0 2
46353: PUSH
46354: LD_INT 3
46356: PLUS
46357: PUSH
46358: LD_INT 0
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: PUSH
46366: LD_VAR 0 1
46370: PUSH
46371: LD_INT 4
46373: PLUS
46374: PUSH
46375: LD_VAR 0 2
46379: PUSH
46380: LD_INT 4
46382: PLUS
46383: PUSH
46384: LD_INT 5
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: LIST
46391: PUSH
46392: EMPTY
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: ST_TO_ADDR
// end ; 2 :
46399: GO 46958
46401: LD_INT 2
46403: DOUBLE
46404: EQUAL
46405: IFTRUE 46409
46407: GO 46538
46409: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46410: LD_ADDR_VAR 0 5
46414: PUSH
46415: LD_VAR 0 1
46419: PUSH
46420: LD_VAR 0 2
46424: PUSH
46425: LD_INT 3
46427: MINUS
46428: PUSH
46429: LD_INT 3
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: LIST
46436: PUSH
46437: LD_VAR 0 1
46441: PUSH
46442: LD_INT 4
46444: PLUS
46445: PUSH
46446: LD_VAR 0 2
46450: PUSH
46451: LD_INT 4
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: LIST
46458: PUSH
46459: LD_VAR 0 1
46463: PUSH
46464: LD_VAR 0 2
46468: PUSH
46469: LD_INT 4
46471: PLUS
46472: PUSH
46473: LD_INT 0
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: LIST
46480: PUSH
46481: LD_VAR 0 1
46485: PUSH
46486: LD_INT 3
46488: MINUS
46489: PUSH
46490: LD_VAR 0 2
46494: PUSH
46495: LD_INT 1
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: LIST
46502: PUSH
46503: LD_VAR 0 1
46507: PUSH
46508: LD_INT 4
46510: MINUS
46511: PUSH
46512: LD_VAR 0 2
46516: PUSH
46517: LD_INT 4
46519: MINUS
46520: PUSH
46521: LD_INT 2
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: LIST
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: ST_TO_ADDR
// end ; 3 :
46536: GO 46958
46538: LD_INT 3
46540: DOUBLE
46541: EQUAL
46542: IFTRUE 46546
46544: GO 46679
46546: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46547: LD_ADDR_VAR 0 5
46551: PUSH
46552: LD_VAR 0 1
46556: PUSH
46557: LD_INT 3
46559: PLUS
46560: PUSH
46561: LD_VAR 0 2
46565: PUSH
46566: LD_INT 4
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: LIST
46573: PUSH
46574: LD_VAR 0 1
46578: PUSH
46579: LD_INT 4
46581: PLUS
46582: PUSH
46583: LD_VAR 0 2
46587: PUSH
46588: LD_INT 4
46590: PLUS
46591: PUSH
46592: LD_INT 5
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: LIST
46599: PUSH
46600: LD_VAR 0 1
46604: PUSH
46605: LD_INT 4
46607: MINUS
46608: PUSH
46609: LD_VAR 0 2
46613: PUSH
46614: LD_INT 1
46616: PUSH
46617: EMPTY
46618: LIST
46619: LIST
46620: LIST
46621: PUSH
46622: LD_VAR 0 1
46626: PUSH
46627: LD_VAR 0 2
46631: PUSH
46632: LD_INT 4
46634: MINUS
46635: PUSH
46636: LD_INT 3
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: LIST
46643: PUSH
46644: LD_VAR 0 1
46648: PUSH
46649: LD_INT 3
46651: MINUS
46652: PUSH
46653: LD_VAR 0 2
46657: PUSH
46658: LD_INT 3
46660: MINUS
46661: PUSH
46662: LD_INT 2
46664: PUSH
46665: EMPTY
46666: LIST
46667: LIST
46668: LIST
46669: PUSH
46670: EMPTY
46671: LIST
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: ST_TO_ADDR
// end ; 4 :
46677: GO 46958
46679: LD_INT 4
46681: DOUBLE
46682: EQUAL
46683: IFTRUE 46687
46685: GO 46820
46687: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
46688: LD_ADDR_VAR 0 5
46692: PUSH
46693: LD_VAR 0 1
46697: PUSH
46698: LD_VAR 0 2
46702: PUSH
46703: LD_INT 4
46705: PLUS
46706: PUSH
46707: LD_INT 0
46709: PUSH
46710: EMPTY
46711: LIST
46712: LIST
46713: LIST
46714: PUSH
46715: LD_VAR 0 1
46719: PUSH
46720: LD_INT 3
46722: PLUS
46723: PUSH
46724: LD_VAR 0 2
46728: PUSH
46729: LD_INT 3
46731: PLUS
46732: PUSH
46733: LD_INT 5
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: LIST
46740: PUSH
46741: LD_VAR 0 1
46745: PUSH
46746: LD_INT 4
46748: PLUS
46749: PUSH
46750: LD_VAR 0 2
46754: PUSH
46755: LD_INT 4
46757: PUSH
46758: EMPTY
46759: LIST
46760: LIST
46761: LIST
46762: PUSH
46763: LD_VAR 0 1
46767: PUSH
46768: LD_VAR 0 2
46772: PUSH
46773: LD_INT 3
46775: MINUS
46776: PUSH
46777: LD_INT 3
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: LIST
46784: PUSH
46785: LD_VAR 0 1
46789: PUSH
46790: LD_INT 4
46792: MINUS
46793: PUSH
46794: LD_VAR 0 2
46798: PUSH
46799: LD_INT 4
46801: MINUS
46802: PUSH
46803: LD_INT 2
46805: PUSH
46806: EMPTY
46807: LIST
46808: LIST
46809: LIST
46810: PUSH
46811: EMPTY
46812: LIST
46813: LIST
46814: LIST
46815: LIST
46816: LIST
46817: ST_TO_ADDR
// end ; 5 :
46818: GO 46958
46820: LD_INT 5
46822: DOUBLE
46823: EQUAL
46824: IFTRUE 46828
46826: GO 46957
46828: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46829: LD_ADDR_VAR 0 5
46833: PUSH
46834: LD_VAR 0 1
46838: PUSH
46839: LD_INT 4
46841: MINUS
46842: PUSH
46843: LD_VAR 0 2
46847: PUSH
46848: LD_INT 1
46850: PUSH
46851: EMPTY
46852: LIST
46853: LIST
46854: LIST
46855: PUSH
46856: LD_VAR 0 1
46860: PUSH
46861: LD_VAR 0 2
46865: PUSH
46866: LD_INT 4
46868: MINUS
46869: PUSH
46870: LD_INT 3
46872: PUSH
46873: EMPTY
46874: LIST
46875: LIST
46876: LIST
46877: PUSH
46878: LD_VAR 0 1
46882: PUSH
46883: LD_INT 4
46885: PLUS
46886: PUSH
46887: LD_VAR 0 2
46891: PUSH
46892: LD_INT 4
46894: PLUS
46895: PUSH
46896: LD_INT 5
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: LIST
46903: PUSH
46904: LD_VAR 0 1
46908: PUSH
46909: LD_INT 3
46911: PLUS
46912: PUSH
46913: LD_VAR 0 2
46917: PUSH
46918: LD_INT 4
46920: PUSH
46921: EMPTY
46922: LIST
46923: LIST
46924: LIST
46925: PUSH
46926: LD_VAR 0 1
46930: PUSH
46931: LD_VAR 0 2
46935: PUSH
46936: LD_INT 3
46938: PLUS
46939: PUSH
46940: LD_INT 0
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: LIST
46947: PUSH
46948: EMPTY
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: ST_TO_ADDR
// end ; end ;
46955: GO 46958
46957: POP
// result := list ;
46958: LD_ADDR_VAR 0 4
46962: PUSH
46963: LD_VAR 0 5
46967: ST_TO_ADDR
// end ;
46968: LD_VAR 0 4
46972: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46973: LD_INT 0
46975: PPUSH
46976: PPUSH
46977: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46978: LD_VAR 0 1
46982: NOT
46983: PUSH
46984: LD_VAR 0 2
46988: PUSH
46989: LD_INT 1
46991: PUSH
46992: LD_INT 2
46994: PUSH
46995: LD_INT 3
46997: PUSH
46998: LD_INT 4
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: LIST
47005: LIST
47006: IN
47007: NOT
47008: OR
47009: IFFALSE 47013
// exit ;
47011: GO 47105
// tmp := [ ] ;
47013: LD_ADDR_VAR 0 5
47017: PUSH
47018: EMPTY
47019: ST_TO_ADDR
// for i in units do
47020: LD_ADDR_VAR 0 4
47024: PUSH
47025: LD_VAR 0 1
47029: PUSH
47030: FOR_IN
47031: IFFALSE 47074
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
47033: LD_ADDR_VAR 0 5
47037: PUSH
47038: LD_VAR 0 5
47042: PPUSH
47043: LD_VAR 0 5
47047: PUSH
47048: LD_INT 1
47050: PLUS
47051: PPUSH
47052: LD_VAR 0 4
47056: PPUSH
47057: LD_VAR 0 2
47061: PPUSH
47062: CALL_OW 259
47066: PPUSH
47067: CALL_OW 2
47071: ST_TO_ADDR
47072: GO 47030
47074: POP
47075: POP
// if not tmp then
47076: LD_VAR 0 5
47080: NOT
47081: IFFALSE 47085
// exit ;
47083: GO 47105
// result := SortListByListDesc ( units , tmp ) ;
47085: LD_ADDR_VAR 0 3
47089: PUSH
47090: LD_VAR 0 1
47094: PPUSH
47095: LD_VAR 0 5
47099: PPUSH
47100: CALL_OW 77
47104: ST_TO_ADDR
// end ;
47105: LD_VAR 0 3
47109: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47110: LD_INT 0
47112: PPUSH
47113: PPUSH
47114: PPUSH
// result := false ;
47115: LD_ADDR_VAR 0 3
47119: PUSH
47120: LD_INT 0
47122: ST_TO_ADDR
// x := GetX ( building ) ;
47123: LD_ADDR_VAR 0 4
47127: PUSH
47128: LD_VAR 0 2
47132: PPUSH
47133: CALL_OW 250
47137: ST_TO_ADDR
// y := GetY ( building ) ;
47138: LD_ADDR_VAR 0 5
47142: PUSH
47143: LD_VAR 0 2
47147: PPUSH
47148: CALL_OW 251
47152: ST_TO_ADDR
// if not building or not x or not y then
47153: LD_VAR 0 2
47157: NOT
47158: PUSH
47159: LD_VAR 0 4
47163: NOT
47164: OR
47165: PUSH
47166: LD_VAR 0 5
47170: NOT
47171: OR
47172: IFFALSE 47176
// exit ;
47174: GO 47268
// if GetTaskList ( unit ) then
47176: LD_VAR 0 1
47180: PPUSH
47181: CALL_OW 437
47185: IFFALSE 47268
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47187: LD_STRING e
47189: PUSH
47190: LD_VAR 0 1
47194: PPUSH
47195: CALL_OW 437
47199: PUSH
47200: LD_INT 1
47202: ARRAY
47203: PUSH
47204: LD_INT 1
47206: ARRAY
47207: EQUAL
47208: PUSH
47209: LD_VAR 0 4
47213: PUSH
47214: LD_VAR 0 1
47218: PPUSH
47219: CALL_OW 437
47223: PUSH
47224: LD_INT 1
47226: ARRAY
47227: PUSH
47228: LD_INT 2
47230: ARRAY
47231: EQUAL
47232: AND
47233: PUSH
47234: LD_VAR 0 5
47238: PUSH
47239: LD_VAR 0 1
47243: PPUSH
47244: CALL_OW 437
47248: PUSH
47249: LD_INT 1
47251: ARRAY
47252: PUSH
47253: LD_INT 3
47255: ARRAY
47256: EQUAL
47257: AND
47258: IFFALSE 47268
// result := true end ;
47260: LD_ADDR_VAR 0 3
47264: PUSH
47265: LD_INT 1
47267: ST_TO_ADDR
// end ;
47268: LD_VAR 0 3
47272: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47273: LD_INT 0
47275: PPUSH
// result := false ;
47276: LD_ADDR_VAR 0 4
47280: PUSH
47281: LD_INT 0
47283: ST_TO_ADDR
// if GetTaskList ( unit ) then
47284: LD_VAR 0 1
47288: PPUSH
47289: CALL_OW 437
47293: IFFALSE 47376
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47295: LD_STRING M
47297: PUSH
47298: LD_VAR 0 1
47302: PPUSH
47303: CALL_OW 437
47307: PUSH
47308: LD_INT 1
47310: ARRAY
47311: PUSH
47312: LD_INT 1
47314: ARRAY
47315: EQUAL
47316: PUSH
47317: LD_VAR 0 2
47321: PUSH
47322: LD_VAR 0 1
47326: PPUSH
47327: CALL_OW 437
47331: PUSH
47332: LD_INT 1
47334: ARRAY
47335: PUSH
47336: LD_INT 2
47338: ARRAY
47339: EQUAL
47340: AND
47341: PUSH
47342: LD_VAR 0 3
47346: PUSH
47347: LD_VAR 0 1
47351: PPUSH
47352: CALL_OW 437
47356: PUSH
47357: LD_INT 1
47359: ARRAY
47360: PUSH
47361: LD_INT 3
47363: ARRAY
47364: EQUAL
47365: AND
47366: IFFALSE 47376
// result := true ;
47368: LD_ADDR_VAR 0 4
47372: PUSH
47373: LD_INT 1
47375: ST_TO_ADDR
// end ; end ;
47376: LD_VAR 0 4
47380: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47381: LD_INT 0
47383: PPUSH
47384: PPUSH
47385: PPUSH
47386: PPUSH
// if not unit or not area then
47387: LD_VAR 0 1
47391: NOT
47392: PUSH
47393: LD_VAR 0 2
47397: NOT
47398: OR
47399: IFFALSE 47403
// exit ;
47401: GO 47567
// tmp := AreaToList ( area , i ) ;
47403: LD_ADDR_VAR 0 6
47407: PUSH
47408: LD_VAR 0 2
47412: PPUSH
47413: LD_VAR 0 5
47417: PPUSH
47418: CALL_OW 517
47422: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47423: LD_ADDR_VAR 0 5
47427: PUSH
47428: DOUBLE
47429: LD_INT 1
47431: DEC
47432: ST_TO_ADDR
47433: LD_VAR 0 6
47437: PUSH
47438: LD_INT 1
47440: ARRAY
47441: PUSH
47442: FOR_TO
47443: IFFALSE 47565
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47445: LD_ADDR_VAR 0 7
47449: PUSH
47450: LD_VAR 0 6
47454: PUSH
47455: LD_INT 1
47457: ARRAY
47458: PUSH
47459: LD_VAR 0 5
47463: ARRAY
47464: PUSH
47465: LD_VAR 0 6
47469: PUSH
47470: LD_INT 2
47472: ARRAY
47473: PUSH
47474: LD_VAR 0 5
47478: ARRAY
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
47484: LD_VAR 0 7
47488: PUSH
47489: LD_INT 1
47491: ARRAY
47492: PPUSH
47493: LD_VAR 0 7
47497: PUSH
47498: LD_INT 2
47500: ARRAY
47501: PPUSH
47502: CALL_OW 428
47506: PUSH
47507: LD_INT 0
47509: EQUAL
47510: IFFALSE 47563
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47512: LD_VAR 0 1
47516: PPUSH
47517: LD_VAR 0 7
47521: PUSH
47522: LD_INT 1
47524: ARRAY
47525: PPUSH
47526: LD_VAR 0 7
47530: PUSH
47531: LD_INT 2
47533: ARRAY
47534: PPUSH
47535: LD_VAR 0 3
47539: PPUSH
47540: CALL_OW 48
// result := IsPlaced ( unit ) ;
47544: LD_ADDR_VAR 0 4
47548: PUSH
47549: LD_VAR 0 1
47553: PPUSH
47554: CALL_OW 305
47558: ST_TO_ADDR
// exit ;
47559: POP
47560: POP
47561: GO 47567
// end ; end ;
47563: GO 47442
47565: POP
47566: POP
// end ;
47567: LD_VAR 0 4
47571: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47572: LD_INT 0
47574: PPUSH
47575: PPUSH
47576: PPUSH
// if not side or side > 8 then
47577: LD_VAR 0 1
47581: NOT
47582: PUSH
47583: LD_VAR 0 1
47587: PUSH
47588: LD_INT 8
47590: GREATER
47591: OR
47592: IFFALSE 47596
// exit ;
47594: GO 47783
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47596: LD_ADDR_VAR 0 4
47600: PUSH
47601: LD_INT 22
47603: PUSH
47604: LD_VAR 0 1
47608: PUSH
47609: EMPTY
47610: LIST
47611: LIST
47612: PUSH
47613: LD_INT 21
47615: PUSH
47616: LD_INT 3
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PUSH
47623: EMPTY
47624: LIST
47625: LIST
47626: PPUSH
47627: CALL_OW 69
47631: ST_TO_ADDR
// if not tmp then
47632: LD_VAR 0 4
47636: NOT
47637: IFFALSE 47641
// exit ;
47639: GO 47783
// enable_addtolog := true ;
47641: LD_ADDR_OWVAR 81
47645: PUSH
47646: LD_INT 1
47648: ST_TO_ADDR
// AddToLog ( [ ) ;
47649: LD_STRING [
47651: PPUSH
47652: CALL_OW 561
// for i in tmp do
47656: LD_ADDR_VAR 0 3
47660: PUSH
47661: LD_VAR 0 4
47665: PUSH
47666: FOR_IN
47667: IFFALSE 47774
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
47669: LD_STRING [
47671: PUSH
47672: LD_VAR 0 3
47676: PPUSH
47677: CALL_OW 266
47681: STR
47682: PUSH
47683: LD_STRING , 
47685: STR
47686: PUSH
47687: LD_VAR 0 3
47691: PPUSH
47692: CALL_OW 250
47696: STR
47697: PUSH
47698: LD_STRING , 
47700: STR
47701: PUSH
47702: LD_VAR 0 3
47706: PPUSH
47707: CALL_OW 251
47711: STR
47712: PUSH
47713: LD_STRING , 
47715: STR
47716: PUSH
47717: LD_VAR 0 3
47721: PPUSH
47722: CALL_OW 254
47726: STR
47727: PUSH
47728: LD_STRING , 
47730: STR
47731: PUSH
47732: LD_VAR 0 3
47736: PPUSH
47737: LD_INT 1
47739: PPUSH
47740: CALL_OW 268
47744: STR
47745: PUSH
47746: LD_STRING , 
47748: STR
47749: PUSH
47750: LD_VAR 0 3
47754: PPUSH
47755: LD_INT 2
47757: PPUSH
47758: CALL_OW 268
47762: STR
47763: PUSH
47764: LD_STRING ],
47766: STR
47767: PPUSH
47768: CALL_OW 561
// end ;
47772: GO 47666
47774: POP
47775: POP
// AddToLog ( ]; ) ;
47776: LD_STRING ];
47778: PPUSH
47779: CALL_OW 561
// end ;
47783: LD_VAR 0 2
47787: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47788: LD_INT 0
47790: PPUSH
47791: PPUSH
47792: PPUSH
47793: PPUSH
47794: PPUSH
// if not area or not rate or not max then
47795: LD_VAR 0 1
47799: NOT
47800: PUSH
47801: LD_VAR 0 2
47805: NOT
47806: OR
47807: PUSH
47808: LD_VAR 0 4
47812: NOT
47813: OR
47814: IFFALSE 47818
// exit ;
47816: GO 48007
// while 1 do
47818: LD_INT 1
47820: IFFALSE 48007
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47822: LD_ADDR_VAR 0 9
47826: PUSH
47827: LD_VAR 0 1
47831: PPUSH
47832: LD_INT 1
47834: PPUSH
47835: CALL_OW 287
47839: PUSH
47840: LD_INT 10
47842: MUL
47843: ST_TO_ADDR
// r := rate / 10 ;
47844: LD_ADDR_VAR 0 7
47848: PUSH
47849: LD_VAR 0 2
47853: PUSH
47854: LD_INT 10
47856: DIVREAL
47857: ST_TO_ADDR
// time := 1 1$00 ;
47858: LD_ADDR_VAR 0 8
47862: PUSH
47863: LD_INT 2100
47865: ST_TO_ADDR
// if amount < min then
47866: LD_VAR 0 9
47870: PUSH
47871: LD_VAR 0 3
47875: LESS
47876: IFFALSE 47894
// r := r * 2 else
47878: LD_ADDR_VAR 0 7
47882: PUSH
47883: LD_VAR 0 7
47887: PUSH
47888: LD_INT 2
47890: MUL
47891: ST_TO_ADDR
47892: GO 47920
// if amount > max then
47894: LD_VAR 0 9
47898: PUSH
47899: LD_VAR 0 4
47903: GREATER
47904: IFFALSE 47920
// r := r / 2 ;
47906: LD_ADDR_VAR 0 7
47910: PUSH
47911: LD_VAR 0 7
47915: PUSH
47916: LD_INT 2
47918: DIVREAL
47919: ST_TO_ADDR
// time := time / r ;
47920: LD_ADDR_VAR 0 8
47924: PUSH
47925: LD_VAR 0 8
47929: PUSH
47930: LD_VAR 0 7
47934: DIVREAL
47935: ST_TO_ADDR
// if time < 0 then
47936: LD_VAR 0 8
47940: PUSH
47941: LD_INT 0
47943: LESS
47944: IFFALSE 47961
// time := time * - 1 ;
47946: LD_ADDR_VAR 0 8
47950: PUSH
47951: LD_VAR 0 8
47955: PUSH
47956: LD_INT 1
47958: NEG
47959: MUL
47960: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47961: LD_VAR 0 8
47965: PUSH
47966: LD_INT 35
47968: PPUSH
47969: LD_INT 875
47971: PPUSH
47972: CALL_OW 12
47976: PLUS
47977: PPUSH
47978: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47982: LD_INT 1
47984: PPUSH
47985: LD_INT 5
47987: PPUSH
47988: CALL_OW 12
47992: PPUSH
47993: LD_VAR 0 1
47997: PPUSH
47998: LD_INT 1
48000: PPUSH
48001: CALL_OW 55
// end ;
48005: GO 47818
// end ;
48007: LD_VAR 0 5
48011: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
48012: LD_INT 0
48014: PPUSH
48015: PPUSH
48016: PPUSH
48017: PPUSH
48018: PPUSH
48019: PPUSH
48020: PPUSH
48021: PPUSH
// if not turrets or not factories then
48022: LD_VAR 0 1
48026: NOT
48027: PUSH
48028: LD_VAR 0 2
48032: NOT
48033: OR
48034: IFFALSE 48038
// exit ;
48036: GO 48345
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48038: LD_ADDR_VAR 0 10
48042: PUSH
48043: LD_INT 5
48045: PUSH
48046: LD_INT 6
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_INT 2
48055: PUSH
48056: LD_INT 4
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: PUSH
48063: LD_INT 3
48065: PUSH
48066: LD_INT 5
48068: PUSH
48069: EMPTY
48070: LIST
48071: LIST
48072: PUSH
48073: EMPTY
48074: LIST
48075: LIST
48076: LIST
48077: PUSH
48078: LD_INT 24
48080: PUSH
48081: LD_INT 25
48083: PUSH
48084: EMPTY
48085: LIST
48086: LIST
48087: PUSH
48088: LD_INT 23
48090: PUSH
48091: LD_INT 27
48093: PUSH
48094: EMPTY
48095: LIST
48096: LIST
48097: PUSH
48098: EMPTY
48099: LIST
48100: LIST
48101: PUSH
48102: LD_INT 42
48104: PUSH
48105: LD_INT 43
48107: PUSH
48108: EMPTY
48109: LIST
48110: LIST
48111: PUSH
48112: LD_INT 44
48114: PUSH
48115: LD_INT 46
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: PUSH
48122: LD_INT 45
48124: PUSH
48125: LD_INT 47
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: PUSH
48132: EMPTY
48133: LIST
48134: LIST
48135: LIST
48136: PUSH
48137: EMPTY
48138: LIST
48139: LIST
48140: LIST
48141: ST_TO_ADDR
// result := [ ] ;
48142: LD_ADDR_VAR 0 3
48146: PUSH
48147: EMPTY
48148: ST_TO_ADDR
// for i in turrets do
48149: LD_ADDR_VAR 0 4
48153: PUSH
48154: LD_VAR 0 1
48158: PUSH
48159: FOR_IN
48160: IFFALSE 48343
// begin nat := GetNation ( i ) ;
48162: LD_ADDR_VAR 0 7
48166: PUSH
48167: LD_VAR 0 4
48171: PPUSH
48172: CALL_OW 248
48176: ST_TO_ADDR
// weapon := 0 ;
48177: LD_ADDR_VAR 0 8
48181: PUSH
48182: LD_INT 0
48184: ST_TO_ADDR
// if not nat then
48185: LD_VAR 0 7
48189: NOT
48190: IFFALSE 48194
// continue ;
48192: GO 48159
// for j in list [ nat ] do
48194: LD_ADDR_VAR 0 5
48198: PUSH
48199: LD_VAR 0 10
48203: PUSH
48204: LD_VAR 0 7
48208: ARRAY
48209: PUSH
48210: FOR_IN
48211: IFFALSE 48252
// if GetBWeapon ( i ) = j [ 1 ] then
48213: LD_VAR 0 4
48217: PPUSH
48218: CALL_OW 269
48222: PUSH
48223: LD_VAR 0 5
48227: PUSH
48228: LD_INT 1
48230: ARRAY
48231: EQUAL
48232: IFFALSE 48250
// begin weapon := j [ 2 ] ;
48234: LD_ADDR_VAR 0 8
48238: PUSH
48239: LD_VAR 0 5
48243: PUSH
48244: LD_INT 2
48246: ARRAY
48247: ST_TO_ADDR
// break ;
48248: GO 48252
// end ;
48250: GO 48210
48252: POP
48253: POP
// if not weapon then
48254: LD_VAR 0 8
48258: NOT
48259: IFFALSE 48263
// continue ;
48261: GO 48159
// for k in factories do
48263: LD_ADDR_VAR 0 6
48267: PUSH
48268: LD_VAR 0 2
48272: PUSH
48273: FOR_IN
48274: IFFALSE 48339
// begin weapons := AvailableWeaponList ( k ) ;
48276: LD_ADDR_VAR 0 9
48280: PUSH
48281: LD_VAR 0 6
48285: PPUSH
48286: CALL_OW 478
48290: ST_TO_ADDR
// if not weapons then
48291: LD_VAR 0 9
48295: NOT
48296: IFFALSE 48300
// continue ;
48298: GO 48273
// if weapon in weapons then
48300: LD_VAR 0 8
48304: PUSH
48305: LD_VAR 0 9
48309: IN
48310: IFFALSE 48337
// begin result := [ i , weapon ] ;
48312: LD_ADDR_VAR 0 3
48316: PUSH
48317: LD_VAR 0 4
48321: PUSH
48322: LD_VAR 0 8
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: ST_TO_ADDR
// exit ;
48331: POP
48332: POP
48333: POP
48334: POP
48335: GO 48345
// end ; end ;
48337: GO 48273
48339: POP
48340: POP
// end ;
48341: GO 48159
48343: POP
48344: POP
// end ;
48345: LD_VAR 0 3
48349: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48350: LD_INT 0
48352: PPUSH
// if not side or side > 8 then
48353: LD_VAR 0 3
48357: NOT
48358: PUSH
48359: LD_VAR 0 3
48363: PUSH
48364: LD_INT 8
48366: GREATER
48367: OR
48368: IFFALSE 48372
// exit ;
48370: GO 48431
// if not range then
48372: LD_VAR 0 4
48376: NOT
48377: IFFALSE 48388
// range := - 12 ;
48379: LD_ADDR_VAR 0 4
48383: PUSH
48384: LD_INT 12
48386: NEG
48387: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48388: LD_VAR 0 1
48392: PPUSH
48393: LD_VAR 0 2
48397: PPUSH
48398: LD_VAR 0 3
48402: PPUSH
48403: LD_VAR 0 4
48407: PPUSH
48408: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48412: LD_VAR 0 1
48416: PPUSH
48417: LD_VAR 0 2
48421: PPUSH
48422: LD_VAR 0 3
48426: PPUSH
48427: CALL_OW 331
// end ;
48431: LD_VAR 0 5
48435: RET
// export function Video ( mode ) ; begin
48436: LD_INT 0
48438: PPUSH
// ingame_video = mode ;
48439: LD_ADDR_OWVAR 52
48443: PUSH
48444: LD_VAR 0 1
48448: ST_TO_ADDR
// interface_hidden = mode ;
48449: LD_ADDR_OWVAR 54
48453: PUSH
48454: LD_VAR 0 1
48458: ST_TO_ADDR
// end ;
48459: LD_VAR 0 2
48463: RET
// export function Join ( array , element ) ; begin
48464: LD_INT 0
48466: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48467: LD_ADDR_VAR 0 3
48471: PUSH
48472: LD_VAR 0 1
48476: PPUSH
48477: LD_VAR 0 1
48481: PUSH
48482: LD_INT 1
48484: PLUS
48485: PPUSH
48486: LD_VAR 0 2
48490: PPUSH
48491: CALL_OW 1
48495: ST_TO_ADDR
// end ;
48496: LD_VAR 0 3
48500: RET
// export function JoinUnion ( array , element ) ; begin
48501: LD_INT 0
48503: PPUSH
// result := array union element ;
48504: LD_ADDR_VAR 0 3
48508: PUSH
48509: LD_VAR 0 1
48513: PUSH
48514: LD_VAR 0 2
48518: UNION
48519: ST_TO_ADDR
// end ;
48520: LD_VAR 0 3
48524: RET
// export function GetBehemoths ( side ) ; begin
48525: LD_INT 0
48527: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48528: LD_ADDR_VAR 0 2
48532: PUSH
48533: LD_INT 22
48535: PUSH
48536: LD_VAR 0 1
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: PUSH
48545: LD_INT 31
48547: PUSH
48548: LD_INT 25
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: PUSH
48555: EMPTY
48556: LIST
48557: LIST
48558: PPUSH
48559: CALL_OW 69
48563: ST_TO_ADDR
// end ;
48564: LD_VAR 0 2
48568: RET
// export function Shuffle ( array ) ; var i , index ; begin
48569: LD_INT 0
48571: PPUSH
48572: PPUSH
48573: PPUSH
// result := [ ] ;
48574: LD_ADDR_VAR 0 2
48578: PUSH
48579: EMPTY
48580: ST_TO_ADDR
// if not array then
48581: LD_VAR 0 1
48585: NOT
48586: IFFALSE 48590
// exit ;
48588: GO 48689
// Randomize ;
48590: CALL_OW 10
// for i = array downto 1 do
48594: LD_ADDR_VAR 0 3
48598: PUSH
48599: DOUBLE
48600: LD_VAR 0 1
48604: INC
48605: ST_TO_ADDR
48606: LD_INT 1
48608: PUSH
48609: FOR_DOWNTO
48610: IFFALSE 48687
// begin index := rand ( 1 , array ) ;
48612: LD_ADDR_VAR 0 4
48616: PUSH
48617: LD_INT 1
48619: PPUSH
48620: LD_VAR 0 1
48624: PPUSH
48625: CALL_OW 12
48629: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48630: LD_ADDR_VAR 0 2
48634: PUSH
48635: LD_VAR 0 2
48639: PPUSH
48640: LD_VAR 0 2
48644: PUSH
48645: LD_INT 1
48647: PLUS
48648: PPUSH
48649: LD_VAR 0 1
48653: PUSH
48654: LD_VAR 0 4
48658: ARRAY
48659: PPUSH
48660: CALL_OW 2
48664: ST_TO_ADDR
// array := Delete ( array , index ) ;
48665: LD_ADDR_VAR 0 1
48669: PUSH
48670: LD_VAR 0 1
48674: PPUSH
48675: LD_VAR 0 4
48679: PPUSH
48680: CALL_OW 3
48684: ST_TO_ADDR
// end ;
48685: GO 48609
48687: POP
48688: POP
// end ;
48689: LD_VAR 0 2
48693: RET
// export function GetBaseMaterials ( base ) ; begin
48694: LD_INT 0
48696: PPUSH
// result := [ 0 , 0 , 0 ] ;
48697: LD_ADDR_VAR 0 2
48701: PUSH
48702: LD_INT 0
48704: PUSH
48705: LD_INT 0
48707: PUSH
48708: LD_INT 0
48710: PUSH
48711: EMPTY
48712: LIST
48713: LIST
48714: LIST
48715: ST_TO_ADDR
// if not base then
48716: LD_VAR 0 1
48720: NOT
48721: IFFALSE 48725
// exit ;
48723: GO 48774
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48725: LD_ADDR_VAR 0 2
48729: PUSH
48730: LD_VAR 0 1
48734: PPUSH
48735: LD_INT 1
48737: PPUSH
48738: CALL_OW 275
48742: PUSH
48743: LD_VAR 0 1
48747: PPUSH
48748: LD_INT 2
48750: PPUSH
48751: CALL_OW 275
48755: PUSH
48756: LD_VAR 0 1
48760: PPUSH
48761: LD_INT 3
48763: PPUSH
48764: CALL_OW 275
48768: PUSH
48769: EMPTY
48770: LIST
48771: LIST
48772: LIST
48773: ST_TO_ADDR
// end ;
48774: LD_VAR 0 2
48778: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48779: LD_INT 0
48781: PPUSH
48782: PPUSH
// result := array ;
48783: LD_ADDR_VAR 0 3
48787: PUSH
48788: LD_VAR 0 1
48792: ST_TO_ADDR
// if size >= result then
48793: LD_VAR 0 2
48797: PUSH
48798: LD_VAR 0 3
48802: GREATEREQUAL
48803: IFFALSE 48807
// exit ;
48805: GO 48857
// if size then
48807: LD_VAR 0 2
48811: IFFALSE 48857
// for i := array downto size do
48813: LD_ADDR_VAR 0 4
48817: PUSH
48818: DOUBLE
48819: LD_VAR 0 1
48823: INC
48824: ST_TO_ADDR
48825: LD_VAR 0 2
48829: PUSH
48830: FOR_DOWNTO
48831: IFFALSE 48855
// result := Delete ( result , result ) ;
48833: LD_ADDR_VAR 0 3
48837: PUSH
48838: LD_VAR 0 3
48842: PPUSH
48843: LD_VAR 0 3
48847: PPUSH
48848: CALL_OW 3
48852: ST_TO_ADDR
48853: GO 48830
48855: POP
48856: POP
// end ;
48857: LD_VAR 0 3
48861: RET
// export function ComExit ( unit ) ; var tmp ; begin
48862: LD_INT 0
48864: PPUSH
48865: PPUSH
// if not IsInUnit ( unit ) then
48866: LD_VAR 0 1
48870: PPUSH
48871: CALL_OW 310
48875: NOT
48876: IFFALSE 48880
// exit ;
48878: GO 48940
// tmp := IsInUnit ( unit ) ;
48880: LD_ADDR_VAR 0 3
48884: PUSH
48885: LD_VAR 0 1
48889: PPUSH
48890: CALL_OW 310
48894: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48895: LD_VAR 0 3
48899: PPUSH
48900: CALL_OW 247
48904: PUSH
48905: LD_INT 2
48907: EQUAL
48908: IFFALSE 48921
// ComExitVehicle ( unit ) else
48910: LD_VAR 0 1
48914: PPUSH
48915: CALL_OW 121
48919: GO 48930
// ComExitBuilding ( unit ) ;
48921: LD_VAR 0 1
48925: PPUSH
48926: CALL_OW 122
// result := tmp ;
48930: LD_ADDR_VAR 0 2
48934: PUSH
48935: LD_VAR 0 3
48939: ST_TO_ADDR
// end ;
48940: LD_VAR 0 2
48944: RET
// export function ComExitAll ( units ) ; var i ; begin
48945: LD_INT 0
48947: PPUSH
48948: PPUSH
// if not units then
48949: LD_VAR 0 1
48953: NOT
48954: IFFALSE 48958
// exit ;
48956: GO 48984
// for i in units do
48958: LD_ADDR_VAR 0 3
48962: PUSH
48963: LD_VAR 0 1
48967: PUSH
48968: FOR_IN
48969: IFFALSE 48982
// ComExit ( i ) ;
48971: LD_VAR 0 3
48975: PPUSH
48976: CALL 48862 0 1
48980: GO 48968
48982: POP
48983: POP
// end ;
48984: LD_VAR 0 2
48988: RET
// export function ResetHc ; begin
48989: LD_INT 0
48991: PPUSH
// InitHc ;
48992: CALL_OW 19
// hc_importance := 0 ;
48996: LD_ADDR_OWVAR 32
49000: PUSH
49001: LD_INT 0
49003: ST_TO_ADDR
// end ;
49004: LD_VAR 0 1
49008: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
49009: LD_INT 0
49011: PPUSH
49012: PPUSH
49013: PPUSH
// _x := ( x1 + x2 ) div 2 ;
49014: LD_ADDR_VAR 0 6
49018: PUSH
49019: LD_VAR 0 1
49023: PUSH
49024: LD_VAR 0 3
49028: PLUS
49029: PUSH
49030: LD_INT 2
49032: DIV
49033: ST_TO_ADDR
// if _x < 0 then
49034: LD_VAR 0 6
49038: PUSH
49039: LD_INT 0
49041: LESS
49042: IFFALSE 49059
// _x := _x * - 1 ;
49044: LD_ADDR_VAR 0 6
49048: PUSH
49049: LD_VAR 0 6
49053: PUSH
49054: LD_INT 1
49056: NEG
49057: MUL
49058: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49059: LD_ADDR_VAR 0 7
49063: PUSH
49064: LD_VAR 0 2
49068: PUSH
49069: LD_VAR 0 4
49073: PLUS
49074: PUSH
49075: LD_INT 2
49077: DIV
49078: ST_TO_ADDR
// if _y < 0 then
49079: LD_VAR 0 7
49083: PUSH
49084: LD_INT 0
49086: LESS
49087: IFFALSE 49104
// _y := _y * - 1 ;
49089: LD_ADDR_VAR 0 7
49093: PUSH
49094: LD_VAR 0 7
49098: PUSH
49099: LD_INT 1
49101: NEG
49102: MUL
49103: ST_TO_ADDR
// result := [ _x , _y ] ;
49104: LD_ADDR_VAR 0 5
49108: PUSH
49109: LD_VAR 0 6
49113: PUSH
49114: LD_VAR 0 7
49118: PUSH
49119: EMPTY
49120: LIST
49121: LIST
49122: ST_TO_ADDR
// end ;
49123: LD_VAR 0 5
49127: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49128: LD_INT 0
49130: PPUSH
49131: PPUSH
49132: PPUSH
49133: PPUSH
// task := GetTaskList ( unit ) ;
49134: LD_ADDR_VAR 0 7
49138: PUSH
49139: LD_VAR 0 1
49143: PPUSH
49144: CALL_OW 437
49148: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49149: LD_VAR 0 7
49153: NOT
49154: PUSH
49155: LD_VAR 0 1
49159: PPUSH
49160: LD_VAR 0 2
49164: PPUSH
49165: CALL_OW 308
49169: NOT
49170: AND
49171: IFFALSE 49175
// exit ;
49173: GO 49293
// if IsInArea ( unit , area ) then
49175: LD_VAR 0 1
49179: PPUSH
49180: LD_VAR 0 2
49184: PPUSH
49185: CALL_OW 308
49189: IFFALSE 49207
// begin ComMoveToArea ( unit , goAway ) ;
49191: LD_VAR 0 1
49195: PPUSH
49196: LD_VAR 0 3
49200: PPUSH
49201: CALL_OW 113
// exit ;
49205: GO 49293
// end ; if task [ 1 ] [ 1 ] <> M then
49207: LD_VAR 0 7
49211: PUSH
49212: LD_INT 1
49214: ARRAY
49215: PUSH
49216: LD_INT 1
49218: ARRAY
49219: PUSH
49220: LD_STRING M
49222: NONEQUAL
49223: IFFALSE 49227
// exit ;
49225: GO 49293
// x := task [ 1 ] [ 2 ] ;
49227: LD_ADDR_VAR 0 5
49231: PUSH
49232: LD_VAR 0 7
49236: PUSH
49237: LD_INT 1
49239: ARRAY
49240: PUSH
49241: LD_INT 2
49243: ARRAY
49244: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49245: LD_ADDR_VAR 0 6
49249: PUSH
49250: LD_VAR 0 7
49254: PUSH
49255: LD_INT 1
49257: ARRAY
49258: PUSH
49259: LD_INT 3
49261: ARRAY
49262: ST_TO_ADDR
// if InArea ( x , y , area ) then
49263: LD_VAR 0 5
49267: PPUSH
49268: LD_VAR 0 6
49272: PPUSH
49273: LD_VAR 0 2
49277: PPUSH
49278: CALL_OW 309
49282: IFFALSE 49293
// ComStop ( unit ) ;
49284: LD_VAR 0 1
49288: PPUSH
49289: CALL_OW 141
// end ;
49293: LD_VAR 0 4
49297: RET
// export function Abs ( value ) ; begin
49298: LD_INT 0
49300: PPUSH
// result := value ;
49301: LD_ADDR_VAR 0 2
49305: PUSH
49306: LD_VAR 0 1
49310: ST_TO_ADDR
// if value < 0 then
49311: LD_VAR 0 1
49315: PUSH
49316: LD_INT 0
49318: LESS
49319: IFFALSE 49336
// result := value * - 1 ;
49321: LD_ADDR_VAR 0 2
49325: PUSH
49326: LD_VAR 0 1
49330: PUSH
49331: LD_INT 1
49333: NEG
49334: MUL
49335: ST_TO_ADDR
// end ;
49336: LD_VAR 0 2
49340: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49341: LD_INT 0
49343: PPUSH
49344: PPUSH
49345: PPUSH
49346: PPUSH
49347: PPUSH
49348: PPUSH
49349: PPUSH
49350: PPUSH
// if not unit or not building then
49351: LD_VAR 0 1
49355: NOT
49356: PUSH
49357: LD_VAR 0 2
49361: NOT
49362: OR
49363: IFFALSE 49367
// exit ;
49365: GO 49593
// x := GetX ( building ) ;
49367: LD_ADDR_VAR 0 4
49371: PUSH
49372: LD_VAR 0 2
49376: PPUSH
49377: CALL_OW 250
49381: ST_TO_ADDR
// y := GetY ( building ) ;
49382: LD_ADDR_VAR 0 6
49386: PUSH
49387: LD_VAR 0 2
49391: PPUSH
49392: CALL_OW 251
49396: ST_TO_ADDR
// d := GetDir ( building ) ;
49397: LD_ADDR_VAR 0 8
49401: PUSH
49402: LD_VAR 0 2
49406: PPUSH
49407: CALL_OW 254
49411: ST_TO_ADDR
// r := 4 ;
49412: LD_ADDR_VAR 0 9
49416: PUSH
49417: LD_INT 4
49419: ST_TO_ADDR
// for i := 1 to 5 do
49420: LD_ADDR_VAR 0 10
49424: PUSH
49425: DOUBLE
49426: LD_INT 1
49428: DEC
49429: ST_TO_ADDR
49430: LD_INT 5
49432: PUSH
49433: FOR_TO
49434: IFFALSE 49591
// begin _x := ShiftX ( x , d , r + i ) ;
49436: LD_ADDR_VAR 0 5
49440: PUSH
49441: LD_VAR 0 4
49445: PPUSH
49446: LD_VAR 0 8
49450: PPUSH
49451: LD_VAR 0 9
49455: PUSH
49456: LD_VAR 0 10
49460: PLUS
49461: PPUSH
49462: CALL_OW 272
49466: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49467: LD_ADDR_VAR 0 7
49471: PUSH
49472: LD_VAR 0 6
49476: PPUSH
49477: LD_VAR 0 8
49481: PPUSH
49482: LD_VAR 0 9
49486: PUSH
49487: LD_VAR 0 10
49491: PLUS
49492: PPUSH
49493: CALL_OW 273
49497: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49498: LD_VAR 0 5
49502: PPUSH
49503: LD_VAR 0 7
49507: PPUSH
49508: CALL_OW 488
49512: PUSH
49513: LD_VAR 0 5
49517: PPUSH
49518: LD_VAR 0 7
49522: PPUSH
49523: CALL_OW 428
49527: PPUSH
49528: CALL_OW 247
49532: PUSH
49533: LD_INT 3
49535: PUSH
49536: LD_INT 2
49538: PUSH
49539: EMPTY
49540: LIST
49541: LIST
49542: IN
49543: NOT
49544: AND
49545: IFFALSE 49589
// begin ComMoveXY ( unit , _x , _y ) ;
49547: LD_VAR 0 1
49551: PPUSH
49552: LD_VAR 0 5
49556: PPUSH
49557: LD_VAR 0 7
49561: PPUSH
49562: CALL_OW 111
// result := [ _x , _y ] ;
49566: LD_ADDR_VAR 0 3
49570: PUSH
49571: LD_VAR 0 5
49575: PUSH
49576: LD_VAR 0 7
49580: PUSH
49581: EMPTY
49582: LIST
49583: LIST
49584: ST_TO_ADDR
// exit ;
49585: POP
49586: POP
49587: GO 49593
// end ; end ;
49589: GO 49433
49591: POP
49592: POP
// end ;
49593: LD_VAR 0 3
49597: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49598: LD_INT 0
49600: PPUSH
49601: PPUSH
49602: PPUSH
// result := 0 ;
49603: LD_ADDR_VAR 0 3
49607: PUSH
49608: LD_INT 0
49610: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49611: LD_VAR 0 1
49615: PUSH
49616: LD_INT 0
49618: LESS
49619: PUSH
49620: LD_VAR 0 1
49624: PUSH
49625: LD_INT 8
49627: GREATER
49628: OR
49629: PUSH
49630: LD_VAR 0 2
49634: PUSH
49635: LD_INT 0
49637: LESS
49638: OR
49639: PUSH
49640: LD_VAR 0 2
49644: PUSH
49645: LD_INT 8
49647: GREATER
49648: OR
49649: IFFALSE 49653
// exit ;
49651: GO 49728
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49653: LD_ADDR_VAR 0 4
49657: PUSH
49658: LD_INT 22
49660: PUSH
49661: LD_VAR 0 2
49665: PUSH
49666: EMPTY
49667: LIST
49668: LIST
49669: PPUSH
49670: CALL_OW 69
49674: PUSH
49675: FOR_IN
49676: IFFALSE 49726
// begin un := UnitShoot ( i ) ;
49678: LD_ADDR_VAR 0 5
49682: PUSH
49683: LD_VAR 0 4
49687: PPUSH
49688: CALL_OW 504
49692: ST_TO_ADDR
// if GetSide ( un ) = side1 then
49693: LD_VAR 0 5
49697: PPUSH
49698: CALL_OW 255
49702: PUSH
49703: LD_VAR 0 1
49707: EQUAL
49708: IFFALSE 49724
// begin result := un ;
49710: LD_ADDR_VAR 0 3
49714: PUSH
49715: LD_VAR 0 5
49719: ST_TO_ADDR
// exit ;
49720: POP
49721: POP
49722: GO 49728
// end ; end ;
49724: GO 49675
49726: POP
49727: POP
// end ;
49728: LD_VAR 0 3
49732: RET
// export function GetCargoBay ( units ) ; begin
49733: LD_INT 0
49735: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49736: LD_ADDR_VAR 0 2
49740: PUSH
49741: LD_VAR 0 1
49745: PPUSH
49746: LD_INT 2
49748: PUSH
49749: LD_INT 34
49751: PUSH
49752: LD_INT 12
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: PUSH
49759: LD_INT 34
49761: PUSH
49762: LD_INT 51
49764: PUSH
49765: EMPTY
49766: LIST
49767: LIST
49768: PUSH
49769: LD_INT 34
49771: PUSH
49772: LD_INT 32
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PUSH
49779: LD_INT 34
49781: PUSH
49782: LD_INT 89
49784: PUSH
49785: EMPTY
49786: LIST
49787: LIST
49788: PUSH
49789: EMPTY
49790: LIST
49791: LIST
49792: LIST
49793: LIST
49794: LIST
49795: PPUSH
49796: CALL_OW 72
49800: ST_TO_ADDR
// end ;
49801: LD_VAR 0 2
49805: RET
// export function Negate ( value ) ; begin
49806: LD_INT 0
49808: PPUSH
// result := not value ;
49809: LD_ADDR_VAR 0 2
49813: PUSH
49814: LD_VAR 0 1
49818: NOT
49819: ST_TO_ADDR
// end ;
49820: LD_VAR 0 2
49824: RET
// export function Inc ( value ) ; begin
49825: LD_INT 0
49827: PPUSH
// result := value + 1 ;
49828: LD_ADDR_VAR 0 2
49832: PUSH
49833: LD_VAR 0 1
49837: PUSH
49838: LD_INT 1
49840: PLUS
49841: ST_TO_ADDR
// end ;
49842: LD_VAR 0 2
49846: RET
// export function Dec ( value ) ; begin
49847: LD_INT 0
49849: PPUSH
// result := value - 1 ;
49850: LD_ADDR_VAR 0 2
49854: PUSH
49855: LD_VAR 0 1
49859: PUSH
49860: LD_INT 1
49862: MINUS
49863: ST_TO_ADDR
// end ;
49864: LD_VAR 0 2
49868: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49869: LD_INT 0
49871: PPUSH
49872: PPUSH
49873: PPUSH
49874: PPUSH
49875: PPUSH
49876: PPUSH
49877: PPUSH
49878: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49879: LD_VAR 0 1
49883: PPUSH
49884: LD_VAR 0 2
49888: PPUSH
49889: CALL_OW 488
49893: NOT
49894: PUSH
49895: LD_VAR 0 3
49899: PPUSH
49900: LD_VAR 0 4
49904: PPUSH
49905: CALL_OW 488
49909: NOT
49910: OR
49911: IFFALSE 49924
// begin result := - 1 ;
49913: LD_ADDR_VAR 0 5
49917: PUSH
49918: LD_INT 1
49920: NEG
49921: ST_TO_ADDR
// exit ;
49922: GO 50159
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49924: LD_ADDR_VAR 0 12
49928: PUSH
49929: LD_VAR 0 1
49933: PPUSH
49934: LD_VAR 0 2
49938: PPUSH
49939: LD_VAR 0 3
49943: PPUSH
49944: LD_VAR 0 4
49948: PPUSH
49949: CALL 49009 0 4
49953: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49954: LD_ADDR_VAR 0 11
49958: PUSH
49959: LD_VAR 0 1
49963: PPUSH
49964: LD_VAR 0 2
49968: PPUSH
49969: LD_VAR 0 12
49973: PUSH
49974: LD_INT 1
49976: ARRAY
49977: PPUSH
49978: LD_VAR 0 12
49982: PUSH
49983: LD_INT 2
49985: ARRAY
49986: PPUSH
49987: CALL_OW 298
49991: ST_TO_ADDR
// distance := 9999 ;
49992: LD_ADDR_VAR 0 10
49996: PUSH
49997: LD_INT 9999
49999: ST_TO_ADDR
// for i := 0 to 5 do
50000: LD_ADDR_VAR 0 6
50004: PUSH
50005: DOUBLE
50006: LD_INT 0
50008: DEC
50009: ST_TO_ADDR
50010: LD_INT 5
50012: PUSH
50013: FOR_TO
50014: IFFALSE 50157
// begin _x := ShiftX ( x1 , i , centerDist ) ;
50016: LD_ADDR_VAR 0 7
50020: PUSH
50021: LD_VAR 0 1
50025: PPUSH
50026: LD_VAR 0 6
50030: PPUSH
50031: LD_VAR 0 11
50035: PPUSH
50036: CALL_OW 272
50040: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50041: LD_ADDR_VAR 0 8
50045: PUSH
50046: LD_VAR 0 2
50050: PPUSH
50051: LD_VAR 0 6
50055: PPUSH
50056: LD_VAR 0 11
50060: PPUSH
50061: CALL_OW 273
50065: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50066: LD_VAR 0 7
50070: PPUSH
50071: LD_VAR 0 8
50075: PPUSH
50076: CALL_OW 488
50080: NOT
50081: IFFALSE 50085
// continue ;
50083: GO 50013
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50085: LD_ADDR_VAR 0 9
50089: PUSH
50090: LD_VAR 0 12
50094: PUSH
50095: LD_INT 1
50097: ARRAY
50098: PPUSH
50099: LD_VAR 0 12
50103: PUSH
50104: LD_INT 2
50106: ARRAY
50107: PPUSH
50108: LD_VAR 0 7
50112: PPUSH
50113: LD_VAR 0 8
50117: PPUSH
50118: CALL_OW 298
50122: ST_TO_ADDR
// if tmp < distance then
50123: LD_VAR 0 9
50127: PUSH
50128: LD_VAR 0 10
50132: LESS
50133: IFFALSE 50155
// begin result := i ;
50135: LD_ADDR_VAR 0 5
50139: PUSH
50140: LD_VAR 0 6
50144: ST_TO_ADDR
// distance := tmp ;
50145: LD_ADDR_VAR 0 10
50149: PUSH
50150: LD_VAR 0 9
50154: ST_TO_ADDR
// end ; end ;
50155: GO 50013
50157: POP
50158: POP
// end ;
50159: LD_VAR 0 5
50163: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50164: LD_INT 0
50166: PPUSH
50167: PPUSH
// if not driver or not IsInUnit ( driver ) then
50168: LD_VAR 0 1
50172: NOT
50173: PUSH
50174: LD_VAR 0 1
50178: PPUSH
50179: CALL_OW 310
50183: NOT
50184: OR
50185: IFFALSE 50189
// exit ;
50187: GO 50279
// vehicle := IsInUnit ( driver ) ;
50189: LD_ADDR_VAR 0 3
50193: PUSH
50194: LD_VAR 0 1
50198: PPUSH
50199: CALL_OW 310
50203: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50204: LD_VAR 0 1
50208: PPUSH
50209: LD_STRING \
50211: PUSH
50212: LD_INT 0
50214: PUSH
50215: LD_INT 0
50217: PUSH
50218: LD_INT 0
50220: PUSH
50221: LD_INT 0
50223: PUSH
50224: LD_INT 0
50226: PUSH
50227: LD_INT 0
50229: PUSH
50230: EMPTY
50231: LIST
50232: LIST
50233: LIST
50234: LIST
50235: LIST
50236: LIST
50237: LIST
50238: PUSH
50239: LD_STRING E
50241: PUSH
50242: LD_INT 0
50244: PUSH
50245: LD_INT 0
50247: PUSH
50248: LD_VAR 0 3
50252: PUSH
50253: LD_INT 0
50255: PUSH
50256: LD_INT 0
50258: PUSH
50259: LD_INT 0
50261: PUSH
50262: EMPTY
50263: LIST
50264: LIST
50265: LIST
50266: LIST
50267: LIST
50268: LIST
50269: LIST
50270: PUSH
50271: EMPTY
50272: LIST
50273: LIST
50274: PPUSH
50275: CALL_OW 446
// end ;
50279: LD_VAR 0 2
50283: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50284: LD_INT 0
50286: PPUSH
50287: PPUSH
// if not driver or not IsInUnit ( driver ) then
50288: LD_VAR 0 1
50292: NOT
50293: PUSH
50294: LD_VAR 0 1
50298: PPUSH
50299: CALL_OW 310
50303: NOT
50304: OR
50305: IFFALSE 50309
// exit ;
50307: GO 50399
// vehicle := IsInUnit ( driver ) ;
50309: LD_ADDR_VAR 0 3
50313: PUSH
50314: LD_VAR 0 1
50318: PPUSH
50319: CALL_OW 310
50323: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50324: LD_VAR 0 1
50328: PPUSH
50329: LD_STRING \
50331: PUSH
50332: LD_INT 0
50334: PUSH
50335: LD_INT 0
50337: PUSH
50338: LD_INT 0
50340: PUSH
50341: LD_INT 0
50343: PUSH
50344: LD_INT 0
50346: PUSH
50347: LD_INT 0
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: LIST
50354: LIST
50355: LIST
50356: LIST
50357: LIST
50358: PUSH
50359: LD_STRING E
50361: PUSH
50362: LD_INT 0
50364: PUSH
50365: LD_INT 0
50367: PUSH
50368: LD_VAR 0 3
50372: PUSH
50373: LD_INT 0
50375: PUSH
50376: LD_INT 0
50378: PUSH
50379: LD_INT 0
50381: PUSH
50382: EMPTY
50383: LIST
50384: LIST
50385: LIST
50386: LIST
50387: LIST
50388: LIST
50389: LIST
50390: PUSH
50391: EMPTY
50392: LIST
50393: LIST
50394: PPUSH
50395: CALL_OW 447
// end ;
50399: LD_VAR 0 2
50403: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50404: LD_INT 0
50406: PPUSH
50407: PPUSH
50408: PPUSH
// tmp := [ ] ;
50409: LD_ADDR_VAR 0 5
50413: PUSH
50414: EMPTY
50415: ST_TO_ADDR
// for i in units do
50416: LD_ADDR_VAR 0 4
50420: PUSH
50421: LD_VAR 0 1
50425: PUSH
50426: FOR_IN
50427: IFFALSE 50465
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50429: LD_ADDR_VAR 0 5
50433: PUSH
50434: LD_VAR 0 5
50438: PPUSH
50439: LD_VAR 0 5
50443: PUSH
50444: LD_INT 1
50446: PLUS
50447: PPUSH
50448: LD_VAR 0 4
50452: PPUSH
50453: CALL_OW 256
50457: PPUSH
50458: CALL_OW 2
50462: ST_TO_ADDR
50463: GO 50426
50465: POP
50466: POP
// if not tmp then
50467: LD_VAR 0 5
50471: NOT
50472: IFFALSE 50476
// exit ;
50474: GO 50524
// if asc then
50476: LD_VAR 0 2
50480: IFFALSE 50504
// result := SortListByListAsc ( units , tmp ) else
50482: LD_ADDR_VAR 0 3
50486: PUSH
50487: LD_VAR 0 1
50491: PPUSH
50492: LD_VAR 0 5
50496: PPUSH
50497: CALL_OW 76
50501: ST_TO_ADDR
50502: GO 50524
// result := SortListByListDesc ( units , tmp ) ;
50504: LD_ADDR_VAR 0 3
50508: PUSH
50509: LD_VAR 0 1
50513: PPUSH
50514: LD_VAR 0 5
50518: PPUSH
50519: CALL_OW 77
50523: ST_TO_ADDR
// end ;
50524: LD_VAR 0 3
50528: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50529: LD_INT 0
50531: PPUSH
50532: PPUSH
// task := GetTaskList ( mech ) ;
50533: LD_ADDR_VAR 0 4
50537: PUSH
50538: LD_VAR 0 1
50542: PPUSH
50543: CALL_OW 437
50547: ST_TO_ADDR
// if not task then
50548: LD_VAR 0 4
50552: NOT
50553: IFFALSE 50557
// exit ;
50555: GO 50599
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50557: LD_ADDR_VAR 0 3
50561: PUSH
50562: LD_VAR 0 4
50566: PUSH
50567: LD_INT 1
50569: ARRAY
50570: PUSH
50571: LD_INT 1
50573: ARRAY
50574: PUSH
50575: LD_STRING r
50577: EQUAL
50578: PUSH
50579: LD_VAR 0 4
50583: PUSH
50584: LD_INT 1
50586: ARRAY
50587: PUSH
50588: LD_INT 4
50590: ARRAY
50591: PUSH
50592: LD_VAR 0 2
50596: EQUAL
50597: AND
50598: ST_TO_ADDR
// end ;
50599: LD_VAR 0 3
50603: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50604: LD_INT 0
50606: PPUSH
// SetDir ( unit , d ) ;
50607: LD_VAR 0 1
50611: PPUSH
50612: LD_VAR 0 4
50616: PPUSH
50617: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50621: LD_VAR 0 1
50625: PPUSH
50626: LD_VAR 0 2
50630: PPUSH
50631: LD_VAR 0 3
50635: PPUSH
50636: LD_VAR 0 5
50640: PPUSH
50641: CALL_OW 48
// end ;
50645: LD_VAR 0 6
50649: RET
// export function ToNaturalNumber ( number ) ; begin
50650: LD_INT 0
50652: PPUSH
// result := number div 1 ;
50653: LD_ADDR_VAR 0 2
50657: PUSH
50658: LD_VAR 0 1
50662: PUSH
50663: LD_INT 1
50665: DIV
50666: ST_TO_ADDR
// if number < 0 then
50667: LD_VAR 0 1
50671: PUSH
50672: LD_INT 0
50674: LESS
50675: IFFALSE 50685
// result := 0 ;
50677: LD_ADDR_VAR 0 2
50681: PUSH
50682: LD_INT 0
50684: ST_TO_ADDR
// end ;
50685: LD_VAR 0 2
50689: RET
// export function SortByClass ( units , class ) ; var un ; begin
50690: LD_INT 0
50692: PPUSH
50693: PPUSH
// if not units or not class then
50694: LD_VAR 0 1
50698: NOT
50699: PUSH
50700: LD_VAR 0 2
50704: NOT
50705: OR
50706: IFFALSE 50710
// exit ;
50708: GO 50805
// result := [ ] ;
50710: LD_ADDR_VAR 0 3
50714: PUSH
50715: EMPTY
50716: ST_TO_ADDR
// for un in units do
50717: LD_ADDR_VAR 0 4
50721: PUSH
50722: LD_VAR 0 1
50726: PUSH
50727: FOR_IN
50728: IFFALSE 50803
// if GetClass ( un ) = class then
50730: LD_VAR 0 4
50734: PPUSH
50735: CALL_OW 257
50739: PUSH
50740: LD_VAR 0 2
50744: EQUAL
50745: IFFALSE 50772
// result := Insert ( result , 1 , un ) else
50747: LD_ADDR_VAR 0 3
50751: PUSH
50752: LD_VAR 0 3
50756: PPUSH
50757: LD_INT 1
50759: PPUSH
50760: LD_VAR 0 4
50764: PPUSH
50765: CALL_OW 2
50769: ST_TO_ADDR
50770: GO 50801
// result := Replace ( result , result + 1 , un ) ;
50772: LD_ADDR_VAR 0 3
50776: PUSH
50777: LD_VAR 0 3
50781: PPUSH
50782: LD_VAR 0 3
50786: PUSH
50787: LD_INT 1
50789: PLUS
50790: PPUSH
50791: LD_VAR 0 4
50795: PPUSH
50796: CALL_OW 1
50800: ST_TO_ADDR
50801: GO 50727
50803: POP
50804: POP
// end ;
50805: LD_VAR 0 3
50809: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50810: LD_INT 0
50812: PPUSH
50813: PPUSH
50814: PPUSH
50815: PPUSH
50816: PPUSH
50817: PPUSH
50818: PPUSH
// result := [ ] ;
50819: LD_ADDR_VAR 0 4
50823: PUSH
50824: EMPTY
50825: ST_TO_ADDR
// if x - r < 0 then
50826: LD_VAR 0 1
50830: PUSH
50831: LD_VAR 0 3
50835: MINUS
50836: PUSH
50837: LD_INT 0
50839: LESS
50840: IFFALSE 50852
// min_x := 0 else
50842: LD_ADDR_VAR 0 8
50846: PUSH
50847: LD_INT 0
50849: ST_TO_ADDR
50850: GO 50868
// min_x := x - r ;
50852: LD_ADDR_VAR 0 8
50856: PUSH
50857: LD_VAR 0 1
50861: PUSH
50862: LD_VAR 0 3
50866: MINUS
50867: ST_TO_ADDR
// if y - r < 0 then
50868: LD_VAR 0 2
50872: PUSH
50873: LD_VAR 0 3
50877: MINUS
50878: PUSH
50879: LD_INT 0
50881: LESS
50882: IFFALSE 50894
// min_y := 0 else
50884: LD_ADDR_VAR 0 7
50888: PUSH
50889: LD_INT 0
50891: ST_TO_ADDR
50892: GO 50910
// min_y := y - r ;
50894: LD_ADDR_VAR 0 7
50898: PUSH
50899: LD_VAR 0 2
50903: PUSH
50904: LD_VAR 0 3
50908: MINUS
50909: ST_TO_ADDR
// max_x := x + r ;
50910: LD_ADDR_VAR 0 9
50914: PUSH
50915: LD_VAR 0 1
50919: PUSH
50920: LD_VAR 0 3
50924: PLUS
50925: ST_TO_ADDR
// max_y := y + r ;
50926: LD_ADDR_VAR 0 10
50930: PUSH
50931: LD_VAR 0 2
50935: PUSH
50936: LD_VAR 0 3
50940: PLUS
50941: ST_TO_ADDR
// for _x = min_x to max_x do
50942: LD_ADDR_VAR 0 5
50946: PUSH
50947: DOUBLE
50948: LD_VAR 0 8
50952: DEC
50953: ST_TO_ADDR
50954: LD_VAR 0 9
50958: PUSH
50959: FOR_TO
50960: IFFALSE 51061
// for _y = min_y to max_y do
50962: LD_ADDR_VAR 0 6
50966: PUSH
50967: DOUBLE
50968: LD_VAR 0 7
50972: DEC
50973: ST_TO_ADDR
50974: LD_VAR 0 10
50978: PUSH
50979: FOR_TO
50980: IFFALSE 51057
// begin if not ValidHex ( _x , _y ) then
50982: LD_VAR 0 5
50986: PPUSH
50987: LD_VAR 0 6
50991: PPUSH
50992: CALL_OW 488
50996: NOT
50997: IFFALSE 51001
// continue ;
50999: GO 50979
// if GetResourceTypeXY ( _x , _y ) then
51001: LD_VAR 0 5
51005: PPUSH
51006: LD_VAR 0 6
51010: PPUSH
51011: CALL_OW 283
51015: IFFALSE 51055
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
51017: LD_ADDR_VAR 0 4
51021: PUSH
51022: LD_VAR 0 4
51026: PPUSH
51027: LD_VAR 0 4
51031: PUSH
51032: LD_INT 1
51034: PLUS
51035: PPUSH
51036: LD_VAR 0 5
51040: PUSH
51041: LD_VAR 0 6
51045: PUSH
51046: EMPTY
51047: LIST
51048: LIST
51049: PPUSH
51050: CALL_OW 1
51054: ST_TO_ADDR
// end ;
51055: GO 50979
51057: POP
51058: POP
51059: GO 50959
51061: POP
51062: POP
// end ;
51063: LD_VAR 0 4
51067: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51068: LD_INT 0
51070: PPUSH
51071: PPUSH
51072: PPUSH
51073: PPUSH
51074: PPUSH
51075: PPUSH
51076: PPUSH
51077: PPUSH
// if not units then
51078: LD_VAR 0 1
51082: NOT
51083: IFFALSE 51087
// exit ;
51085: GO 51611
// result := UnitFilter ( units , [ f_ok ] ) ;
51087: LD_ADDR_VAR 0 3
51091: PUSH
51092: LD_VAR 0 1
51096: PPUSH
51097: LD_INT 50
51099: PUSH
51100: EMPTY
51101: LIST
51102: PPUSH
51103: CALL_OW 72
51107: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51108: LD_ADDR_VAR 0 8
51112: PUSH
51113: LD_VAR 0 1
51117: PUSH
51118: LD_INT 1
51120: ARRAY
51121: PPUSH
51122: CALL_OW 255
51126: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51127: LD_ADDR_VAR 0 10
51131: PUSH
51132: LD_INT 29
51134: PUSH
51135: LD_INT 91
51137: PUSH
51138: LD_INT 49
51140: PUSH
51141: EMPTY
51142: LIST
51143: LIST
51144: LIST
51145: ST_TO_ADDR
// if not result then
51146: LD_VAR 0 3
51150: NOT
51151: IFFALSE 51155
// exit ;
51153: GO 51611
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51155: LD_ADDR_VAR 0 5
51159: PUSH
51160: LD_INT 81
51162: PUSH
51163: LD_VAR 0 8
51167: PUSH
51168: EMPTY
51169: LIST
51170: LIST
51171: PPUSH
51172: CALL_OW 69
51176: ST_TO_ADDR
// for i in result do
51177: LD_ADDR_VAR 0 4
51181: PUSH
51182: LD_VAR 0 3
51186: PUSH
51187: FOR_IN
51188: IFFALSE 51609
// begin tag := GetTag ( i ) + 1 ;
51190: LD_ADDR_VAR 0 9
51194: PUSH
51195: LD_VAR 0 4
51199: PPUSH
51200: CALL_OW 110
51204: PUSH
51205: LD_INT 1
51207: PLUS
51208: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51209: LD_ADDR_VAR 0 7
51213: PUSH
51214: LD_VAR 0 4
51218: PPUSH
51219: CALL_OW 250
51223: PPUSH
51224: LD_VAR 0 4
51228: PPUSH
51229: CALL_OW 251
51233: PPUSH
51234: LD_INT 6
51236: PPUSH
51237: CALL 50810 0 3
51241: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51242: LD_VAR 0 4
51246: PPUSH
51247: CALL_OW 247
51251: PUSH
51252: LD_INT 2
51254: EQUAL
51255: PUSH
51256: LD_VAR 0 7
51260: AND
51261: PUSH
51262: LD_VAR 0 4
51266: PPUSH
51267: CALL_OW 264
51271: PUSH
51272: LD_VAR 0 10
51276: IN
51277: NOT
51278: AND
51279: IFFALSE 51318
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51281: LD_VAR 0 4
51285: PPUSH
51286: LD_VAR 0 7
51290: PUSH
51291: LD_INT 1
51293: ARRAY
51294: PUSH
51295: LD_INT 1
51297: ARRAY
51298: PPUSH
51299: LD_VAR 0 7
51303: PUSH
51304: LD_INT 1
51306: ARRAY
51307: PUSH
51308: LD_INT 2
51310: ARRAY
51311: PPUSH
51312: CALL_OW 116
51316: GO 51607
// if path > tag then
51318: LD_VAR 0 2
51322: PUSH
51323: LD_VAR 0 9
51327: GREATER
51328: IFFALSE 51536
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51330: LD_ADDR_VAR 0 6
51334: PUSH
51335: LD_VAR 0 5
51339: PPUSH
51340: LD_INT 91
51342: PUSH
51343: LD_VAR 0 4
51347: PUSH
51348: LD_INT 8
51350: PUSH
51351: EMPTY
51352: LIST
51353: LIST
51354: LIST
51355: PPUSH
51356: CALL_OW 72
51360: ST_TO_ADDR
// if nearEnemy then
51361: LD_VAR 0 6
51365: IFFALSE 51434
// begin if GetWeapon ( i ) = ru_time_lapser then
51367: LD_VAR 0 4
51371: PPUSH
51372: CALL_OW 264
51376: PUSH
51377: LD_INT 49
51379: EQUAL
51380: IFFALSE 51408
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51382: LD_VAR 0 4
51386: PPUSH
51387: LD_VAR 0 6
51391: PPUSH
51392: LD_VAR 0 4
51396: PPUSH
51397: CALL_OW 74
51401: PPUSH
51402: CALL_OW 112
51406: GO 51432
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51408: LD_VAR 0 4
51412: PPUSH
51413: LD_VAR 0 6
51417: PPUSH
51418: LD_VAR 0 4
51422: PPUSH
51423: CALL_OW 74
51427: PPUSH
51428: CALL_OW 115
// end else
51432: GO 51534
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51434: LD_VAR 0 4
51438: PPUSH
51439: LD_VAR 0 2
51443: PUSH
51444: LD_VAR 0 9
51448: ARRAY
51449: PUSH
51450: LD_INT 1
51452: ARRAY
51453: PPUSH
51454: LD_VAR 0 2
51458: PUSH
51459: LD_VAR 0 9
51463: ARRAY
51464: PUSH
51465: LD_INT 2
51467: ARRAY
51468: PPUSH
51469: CALL_OW 297
51473: PUSH
51474: LD_INT 6
51476: GREATER
51477: IFFALSE 51520
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51479: LD_VAR 0 4
51483: PPUSH
51484: LD_VAR 0 2
51488: PUSH
51489: LD_VAR 0 9
51493: ARRAY
51494: PUSH
51495: LD_INT 1
51497: ARRAY
51498: PPUSH
51499: LD_VAR 0 2
51503: PUSH
51504: LD_VAR 0 9
51508: ARRAY
51509: PUSH
51510: LD_INT 2
51512: ARRAY
51513: PPUSH
51514: CALL_OW 114
51518: GO 51534
// SetTag ( i , tag ) ;
51520: LD_VAR 0 4
51524: PPUSH
51525: LD_VAR 0 9
51529: PPUSH
51530: CALL_OW 109
// end else
51534: GO 51607
// if enemy then
51536: LD_VAR 0 5
51540: IFFALSE 51607
// begin if GetWeapon ( i ) = ru_time_lapser then
51542: LD_VAR 0 4
51546: PPUSH
51547: CALL_OW 264
51551: PUSH
51552: LD_INT 49
51554: EQUAL
51555: IFFALSE 51583
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51557: LD_VAR 0 4
51561: PPUSH
51562: LD_VAR 0 5
51566: PPUSH
51567: LD_VAR 0 4
51571: PPUSH
51572: CALL_OW 74
51576: PPUSH
51577: CALL_OW 112
51581: GO 51607
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51583: LD_VAR 0 4
51587: PPUSH
51588: LD_VAR 0 5
51592: PPUSH
51593: LD_VAR 0 4
51597: PPUSH
51598: CALL_OW 74
51602: PPUSH
51603: CALL_OW 115
// end ; end ;
51607: GO 51187
51609: POP
51610: POP
// end ;
51611: LD_VAR 0 3
51615: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51616: LD_INT 0
51618: PPUSH
51619: PPUSH
51620: PPUSH
// if not unit or IsInUnit ( unit ) then
51621: LD_VAR 0 1
51625: NOT
51626: PUSH
51627: LD_VAR 0 1
51631: PPUSH
51632: CALL_OW 310
51636: OR
51637: IFFALSE 51641
// exit ;
51639: GO 51732
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51641: LD_ADDR_VAR 0 4
51645: PUSH
51646: LD_VAR 0 1
51650: PPUSH
51651: CALL_OW 250
51655: PPUSH
51656: LD_VAR 0 2
51660: PPUSH
51661: LD_INT 1
51663: PPUSH
51664: CALL_OW 272
51668: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
51669: LD_ADDR_VAR 0 5
51673: PUSH
51674: LD_VAR 0 1
51678: PPUSH
51679: CALL_OW 251
51683: PPUSH
51684: LD_VAR 0 2
51688: PPUSH
51689: LD_INT 1
51691: PPUSH
51692: CALL_OW 273
51696: ST_TO_ADDR
// if ValidHex ( x , y ) then
51697: LD_VAR 0 4
51701: PPUSH
51702: LD_VAR 0 5
51706: PPUSH
51707: CALL_OW 488
51711: IFFALSE 51732
// ComTurnXY ( unit , x , y ) ;
51713: LD_VAR 0 1
51717: PPUSH
51718: LD_VAR 0 4
51722: PPUSH
51723: LD_VAR 0 5
51727: PPUSH
51728: CALL_OW 118
// end ;
51732: LD_VAR 0 3
51736: RET
// export function SeeUnits ( side , units ) ; var i ; begin
51737: LD_INT 0
51739: PPUSH
51740: PPUSH
// result := false ;
51741: LD_ADDR_VAR 0 3
51745: PUSH
51746: LD_INT 0
51748: ST_TO_ADDR
// if not units then
51749: LD_VAR 0 2
51753: NOT
51754: IFFALSE 51758
// exit ;
51756: GO 51803
// for i in units do
51758: LD_ADDR_VAR 0 4
51762: PUSH
51763: LD_VAR 0 2
51767: PUSH
51768: FOR_IN
51769: IFFALSE 51801
// if See ( side , i ) then
51771: LD_VAR 0 1
51775: PPUSH
51776: LD_VAR 0 4
51780: PPUSH
51781: CALL_OW 292
51785: IFFALSE 51799
// begin result := true ;
51787: LD_ADDR_VAR 0 3
51791: PUSH
51792: LD_INT 1
51794: ST_TO_ADDR
// exit ;
51795: POP
51796: POP
51797: GO 51803
// end ;
51799: GO 51768
51801: POP
51802: POP
// end ;
51803: LD_VAR 0 3
51807: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
51808: LD_INT 0
51810: PPUSH
51811: PPUSH
51812: PPUSH
51813: PPUSH
// if not unit or not points then
51814: LD_VAR 0 1
51818: NOT
51819: PUSH
51820: LD_VAR 0 2
51824: NOT
51825: OR
51826: IFFALSE 51830
// exit ;
51828: GO 51920
// dist := 99999 ;
51830: LD_ADDR_VAR 0 5
51834: PUSH
51835: LD_INT 99999
51837: ST_TO_ADDR
// for i in points do
51838: LD_ADDR_VAR 0 4
51842: PUSH
51843: LD_VAR 0 2
51847: PUSH
51848: FOR_IN
51849: IFFALSE 51918
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51851: LD_ADDR_VAR 0 6
51855: PUSH
51856: LD_VAR 0 1
51860: PPUSH
51861: LD_VAR 0 4
51865: PUSH
51866: LD_INT 1
51868: ARRAY
51869: PPUSH
51870: LD_VAR 0 4
51874: PUSH
51875: LD_INT 2
51877: ARRAY
51878: PPUSH
51879: CALL_OW 297
51883: ST_TO_ADDR
// if tmpDist < dist then
51884: LD_VAR 0 6
51888: PUSH
51889: LD_VAR 0 5
51893: LESS
51894: IFFALSE 51916
// begin result := i ;
51896: LD_ADDR_VAR 0 3
51900: PUSH
51901: LD_VAR 0 4
51905: ST_TO_ADDR
// dist := tmpDist ;
51906: LD_ADDR_VAR 0 5
51910: PUSH
51911: LD_VAR 0 6
51915: ST_TO_ADDR
// end ; end ;
51916: GO 51848
51918: POP
51919: POP
// end ;
51920: LD_VAR 0 3
51924: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
51925: LD_INT 0
51927: PPUSH
// uc_side := side ;
51928: LD_ADDR_OWVAR 20
51932: PUSH
51933: LD_VAR 0 1
51937: ST_TO_ADDR
// uc_nation := 3 ;
51938: LD_ADDR_OWVAR 21
51942: PUSH
51943: LD_INT 3
51945: ST_TO_ADDR
// vc_chassis := 25 ;
51946: LD_ADDR_OWVAR 37
51950: PUSH
51951: LD_INT 25
51953: ST_TO_ADDR
// vc_engine := engine_siberite ;
51954: LD_ADDR_OWVAR 39
51958: PUSH
51959: LD_INT 3
51961: ST_TO_ADDR
// vc_control := control_computer ;
51962: LD_ADDR_OWVAR 38
51966: PUSH
51967: LD_INT 3
51969: ST_TO_ADDR
// vc_weapon := 59 ;
51970: LD_ADDR_OWVAR 40
51974: PUSH
51975: LD_INT 59
51977: ST_TO_ADDR
// result := CreateVehicle ;
51978: LD_ADDR_VAR 0 5
51982: PUSH
51983: CALL_OW 45
51987: ST_TO_ADDR
// SetDir ( result , d ) ;
51988: LD_VAR 0 5
51992: PPUSH
51993: LD_VAR 0 4
51997: PPUSH
51998: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
52002: LD_VAR 0 5
52006: PPUSH
52007: LD_VAR 0 2
52011: PPUSH
52012: LD_VAR 0 3
52016: PPUSH
52017: LD_INT 0
52019: PPUSH
52020: CALL_OW 48
// end ;
52024: LD_VAR 0 5
52028: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
52029: LD_INT 0
52031: PPUSH
52032: PPUSH
52033: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
52034: LD_ADDR_VAR 0 2
52038: PUSH
52039: LD_INT 0
52041: PUSH
52042: LD_INT 0
52044: PUSH
52045: LD_INT 0
52047: PUSH
52048: LD_INT 0
52050: PUSH
52051: EMPTY
52052: LIST
52053: LIST
52054: LIST
52055: LIST
52056: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52057: LD_VAR 0 1
52061: NOT
52062: PUSH
52063: LD_VAR 0 1
52067: PPUSH
52068: CALL_OW 264
52072: PUSH
52073: LD_INT 12
52075: PUSH
52076: LD_INT 51
52078: PUSH
52079: LD_INT 32
52081: PUSH
52082: LD_INT 89
52084: PUSH
52085: EMPTY
52086: LIST
52087: LIST
52088: LIST
52089: LIST
52090: IN
52091: NOT
52092: OR
52093: IFFALSE 52097
// exit ;
52095: GO 52195
// for i := 1 to 3 do
52097: LD_ADDR_VAR 0 3
52101: PUSH
52102: DOUBLE
52103: LD_INT 1
52105: DEC
52106: ST_TO_ADDR
52107: LD_INT 3
52109: PUSH
52110: FOR_TO
52111: IFFALSE 52193
// begin tmp := GetCargo ( cargo , i ) ;
52113: LD_ADDR_VAR 0 4
52117: PUSH
52118: LD_VAR 0 1
52122: PPUSH
52123: LD_VAR 0 3
52127: PPUSH
52128: CALL_OW 289
52132: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52133: LD_ADDR_VAR 0 2
52137: PUSH
52138: LD_VAR 0 2
52142: PPUSH
52143: LD_VAR 0 3
52147: PPUSH
52148: LD_VAR 0 4
52152: PPUSH
52153: CALL_OW 1
52157: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52158: LD_ADDR_VAR 0 2
52162: PUSH
52163: LD_VAR 0 2
52167: PPUSH
52168: LD_INT 4
52170: PPUSH
52171: LD_VAR 0 2
52175: PUSH
52176: LD_INT 4
52178: ARRAY
52179: PUSH
52180: LD_VAR 0 4
52184: PLUS
52185: PPUSH
52186: CALL_OW 1
52190: ST_TO_ADDR
// end ;
52191: GO 52110
52193: POP
52194: POP
// end ;
52195: LD_VAR 0 2
52199: RET
// export function Length ( array ) ; begin
52200: LD_INT 0
52202: PPUSH
// result := array + 0 ;
52203: LD_ADDR_VAR 0 2
52207: PUSH
52208: LD_VAR 0 1
52212: PUSH
52213: LD_INT 0
52215: PLUS
52216: ST_TO_ADDR
// end ;
52217: LD_VAR 0 2
52221: RET
// export function PrepareArray ( array ) ; begin
52222: LD_INT 0
52224: PPUSH
// result := array diff 0 ;
52225: LD_ADDR_VAR 0 2
52229: PUSH
52230: LD_VAR 0 1
52234: PUSH
52235: LD_INT 0
52237: DIFF
52238: ST_TO_ADDR
// if not result [ 1 ] then
52239: LD_VAR 0 2
52243: PUSH
52244: LD_INT 1
52246: ARRAY
52247: NOT
52248: IFFALSE 52268
// result := Delete ( result , 1 ) ;
52250: LD_ADDR_VAR 0 2
52254: PUSH
52255: LD_VAR 0 2
52259: PPUSH
52260: LD_INT 1
52262: PPUSH
52263: CALL_OW 3
52267: ST_TO_ADDR
// end ; end_of_file
52268: LD_VAR 0 2
52272: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52273: LD_INT 0
52275: PPUSH
52276: PPUSH
// skirmish := false ;
52277: LD_ADDR_EXP 21
52281: PUSH
52282: LD_INT 0
52284: ST_TO_ADDR
// debug_mc := false ;
52285: LD_ADDR_EXP 22
52289: PUSH
52290: LD_INT 0
52292: ST_TO_ADDR
// mc_bases := [ ] ;
52293: LD_ADDR_EXP 23
52297: PUSH
52298: EMPTY
52299: ST_TO_ADDR
// mc_sides := [ ] ;
52300: LD_ADDR_EXP 49
52304: PUSH
52305: EMPTY
52306: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52307: LD_ADDR_EXP 24
52311: PUSH
52312: EMPTY
52313: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52314: LD_ADDR_EXP 25
52318: PUSH
52319: EMPTY
52320: ST_TO_ADDR
// mc_need_heal := [ ] ;
52321: LD_ADDR_EXP 26
52325: PUSH
52326: EMPTY
52327: ST_TO_ADDR
// mc_healers := [ ] ;
52328: LD_ADDR_EXP 27
52332: PUSH
52333: EMPTY
52334: ST_TO_ADDR
// mc_build_list := [ ] ;
52335: LD_ADDR_EXP 28
52339: PUSH
52340: EMPTY
52341: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52342: LD_ADDR_EXP 55
52346: PUSH
52347: EMPTY
52348: ST_TO_ADDR
// mc_builders := [ ] ;
52349: LD_ADDR_EXP 29
52353: PUSH
52354: EMPTY
52355: ST_TO_ADDR
// mc_construct_list := [ ] ;
52356: LD_ADDR_EXP 30
52360: PUSH
52361: EMPTY
52362: ST_TO_ADDR
// mc_turret_list := [ ] ;
52363: LD_ADDR_EXP 31
52367: PUSH
52368: EMPTY
52369: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52370: LD_ADDR_EXP 32
52374: PUSH
52375: EMPTY
52376: ST_TO_ADDR
// mc_miners := [ ] ;
52377: LD_ADDR_EXP 37
52381: PUSH
52382: EMPTY
52383: ST_TO_ADDR
// mc_mines := [ ] ;
52384: LD_ADDR_EXP 36
52388: PUSH
52389: EMPTY
52390: ST_TO_ADDR
// mc_minefields := [ ] ;
52391: LD_ADDR_EXP 38
52395: PUSH
52396: EMPTY
52397: ST_TO_ADDR
// mc_crates := [ ] ;
52398: LD_ADDR_EXP 39
52402: PUSH
52403: EMPTY
52404: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52405: LD_ADDR_EXP 40
52409: PUSH
52410: EMPTY
52411: ST_TO_ADDR
// mc_crates_area := [ ] ;
52412: LD_ADDR_EXP 41
52416: PUSH
52417: EMPTY
52418: ST_TO_ADDR
// mc_vehicles := [ ] ;
52419: LD_ADDR_EXP 42
52423: PUSH
52424: EMPTY
52425: ST_TO_ADDR
// mc_attack := [ ] ;
52426: LD_ADDR_EXP 43
52430: PUSH
52431: EMPTY
52432: ST_TO_ADDR
// mc_produce := [ ] ;
52433: LD_ADDR_EXP 44
52437: PUSH
52438: EMPTY
52439: ST_TO_ADDR
// mc_defender := [ ] ;
52440: LD_ADDR_EXP 45
52444: PUSH
52445: EMPTY
52446: ST_TO_ADDR
// mc_parking := [ ] ;
52447: LD_ADDR_EXP 47
52451: PUSH
52452: EMPTY
52453: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52454: LD_ADDR_EXP 33
52458: PUSH
52459: EMPTY
52460: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52461: LD_ADDR_EXP 35
52465: PUSH
52466: EMPTY
52467: ST_TO_ADDR
// mc_scan := [ ] ;
52468: LD_ADDR_EXP 46
52472: PUSH
52473: EMPTY
52474: ST_TO_ADDR
// mc_scan_area := [ ] ;
52475: LD_ADDR_EXP 48
52479: PUSH
52480: EMPTY
52481: ST_TO_ADDR
// mc_tech := [ ] ;
52482: LD_ADDR_EXP 50
52486: PUSH
52487: EMPTY
52488: ST_TO_ADDR
// mc_class := [ ] ;
52489: LD_ADDR_EXP 64
52493: PUSH
52494: EMPTY
52495: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52496: LD_ADDR_EXP 65
52500: PUSH
52501: EMPTY
52502: ST_TO_ADDR
// mc_is_defending := [ ] ;
52503: LD_ADDR_EXP 66
52507: PUSH
52508: EMPTY
52509: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
52510: LD_ADDR_EXP 57
52514: PUSH
52515: EMPTY
52516: ST_TO_ADDR
// end ;
52517: LD_VAR 0 1
52521: RET
// export function MC_Kill ( base ) ; begin
52522: LD_INT 0
52524: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52525: LD_ADDR_EXP 23
52529: PUSH
52530: LD_EXP 23
52534: PPUSH
52535: LD_VAR 0 1
52539: PPUSH
52540: EMPTY
52541: PPUSH
52542: CALL_OW 1
52546: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52547: LD_ADDR_EXP 24
52551: PUSH
52552: LD_EXP 24
52556: PPUSH
52557: LD_VAR 0 1
52561: PPUSH
52562: EMPTY
52563: PPUSH
52564: CALL_OW 1
52568: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52569: LD_ADDR_EXP 25
52573: PUSH
52574: LD_EXP 25
52578: PPUSH
52579: LD_VAR 0 1
52583: PPUSH
52584: EMPTY
52585: PPUSH
52586: CALL_OW 1
52590: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52591: LD_ADDR_EXP 26
52595: PUSH
52596: LD_EXP 26
52600: PPUSH
52601: LD_VAR 0 1
52605: PPUSH
52606: EMPTY
52607: PPUSH
52608: CALL_OW 1
52612: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52613: LD_ADDR_EXP 27
52617: PUSH
52618: LD_EXP 27
52622: PPUSH
52623: LD_VAR 0 1
52627: PPUSH
52628: EMPTY
52629: PPUSH
52630: CALL_OW 1
52634: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52635: LD_ADDR_EXP 28
52639: PUSH
52640: LD_EXP 28
52644: PPUSH
52645: LD_VAR 0 1
52649: PPUSH
52650: EMPTY
52651: PPUSH
52652: CALL_OW 1
52656: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52657: LD_ADDR_EXP 29
52661: PUSH
52662: LD_EXP 29
52666: PPUSH
52667: LD_VAR 0 1
52671: PPUSH
52672: EMPTY
52673: PPUSH
52674: CALL_OW 1
52678: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52679: LD_ADDR_EXP 30
52683: PUSH
52684: LD_EXP 30
52688: PPUSH
52689: LD_VAR 0 1
52693: PPUSH
52694: EMPTY
52695: PPUSH
52696: CALL_OW 1
52700: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52701: LD_ADDR_EXP 31
52705: PUSH
52706: LD_EXP 31
52710: PPUSH
52711: LD_VAR 0 1
52715: PPUSH
52716: EMPTY
52717: PPUSH
52718: CALL_OW 1
52722: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52723: LD_ADDR_EXP 32
52727: PUSH
52728: LD_EXP 32
52732: PPUSH
52733: LD_VAR 0 1
52737: PPUSH
52738: EMPTY
52739: PPUSH
52740: CALL_OW 1
52744: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52745: LD_ADDR_EXP 33
52749: PUSH
52750: LD_EXP 33
52754: PPUSH
52755: LD_VAR 0 1
52759: PPUSH
52760: EMPTY
52761: PPUSH
52762: CALL_OW 1
52766: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52767: LD_ADDR_EXP 34
52771: PUSH
52772: LD_EXP 34
52776: PPUSH
52777: LD_VAR 0 1
52781: PPUSH
52782: LD_INT 0
52784: PPUSH
52785: CALL_OW 1
52789: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52790: LD_ADDR_EXP 35
52794: PUSH
52795: LD_EXP 35
52799: PPUSH
52800: LD_VAR 0 1
52804: PPUSH
52805: EMPTY
52806: PPUSH
52807: CALL_OW 1
52811: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52812: LD_ADDR_EXP 36
52816: PUSH
52817: LD_EXP 36
52821: PPUSH
52822: LD_VAR 0 1
52826: PPUSH
52827: EMPTY
52828: PPUSH
52829: CALL_OW 1
52833: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52834: LD_ADDR_EXP 37
52838: PUSH
52839: LD_EXP 37
52843: PPUSH
52844: LD_VAR 0 1
52848: PPUSH
52849: EMPTY
52850: PPUSH
52851: CALL_OW 1
52855: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52856: LD_ADDR_EXP 38
52860: PUSH
52861: LD_EXP 38
52865: PPUSH
52866: LD_VAR 0 1
52870: PPUSH
52871: EMPTY
52872: PPUSH
52873: CALL_OW 1
52877: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52878: LD_ADDR_EXP 39
52882: PUSH
52883: LD_EXP 39
52887: PPUSH
52888: LD_VAR 0 1
52892: PPUSH
52893: EMPTY
52894: PPUSH
52895: CALL_OW 1
52899: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52900: LD_ADDR_EXP 40
52904: PUSH
52905: LD_EXP 40
52909: PPUSH
52910: LD_VAR 0 1
52914: PPUSH
52915: EMPTY
52916: PPUSH
52917: CALL_OW 1
52921: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52922: LD_ADDR_EXP 41
52926: PUSH
52927: LD_EXP 41
52931: PPUSH
52932: LD_VAR 0 1
52936: PPUSH
52937: EMPTY
52938: PPUSH
52939: CALL_OW 1
52943: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52944: LD_ADDR_EXP 42
52948: PUSH
52949: LD_EXP 42
52953: PPUSH
52954: LD_VAR 0 1
52958: PPUSH
52959: EMPTY
52960: PPUSH
52961: CALL_OW 1
52965: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52966: LD_ADDR_EXP 43
52970: PUSH
52971: LD_EXP 43
52975: PPUSH
52976: LD_VAR 0 1
52980: PPUSH
52981: EMPTY
52982: PPUSH
52983: CALL_OW 1
52987: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52988: LD_ADDR_EXP 44
52992: PUSH
52993: LD_EXP 44
52997: PPUSH
52998: LD_VAR 0 1
53002: PPUSH
53003: EMPTY
53004: PPUSH
53005: CALL_OW 1
53009: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53010: LD_ADDR_EXP 45
53014: PUSH
53015: LD_EXP 45
53019: PPUSH
53020: LD_VAR 0 1
53024: PPUSH
53025: EMPTY
53026: PPUSH
53027: CALL_OW 1
53031: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53032: LD_ADDR_EXP 46
53036: PUSH
53037: LD_EXP 46
53041: PPUSH
53042: LD_VAR 0 1
53046: PPUSH
53047: EMPTY
53048: PPUSH
53049: CALL_OW 1
53053: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53054: LD_ADDR_EXP 47
53058: PUSH
53059: LD_EXP 47
53063: PPUSH
53064: LD_VAR 0 1
53068: PPUSH
53069: EMPTY
53070: PPUSH
53071: CALL_OW 1
53075: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53076: LD_ADDR_EXP 48
53080: PUSH
53081: LD_EXP 48
53085: PPUSH
53086: LD_VAR 0 1
53090: PPUSH
53091: EMPTY
53092: PPUSH
53093: CALL_OW 1
53097: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53098: LD_ADDR_EXP 50
53102: PUSH
53103: LD_EXP 50
53107: PPUSH
53108: LD_VAR 0 1
53112: PPUSH
53113: EMPTY
53114: PPUSH
53115: CALL_OW 1
53119: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53120: LD_ADDR_EXP 52
53124: PUSH
53125: LD_EXP 52
53129: PPUSH
53130: LD_VAR 0 1
53134: PPUSH
53135: EMPTY
53136: PPUSH
53137: CALL_OW 1
53141: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53142: LD_ADDR_EXP 53
53146: PUSH
53147: LD_EXP 53
53151: PPUSH
53152: LD_VAR 0 1
53156: PPUSH
53157: EMPTY
53158: PPUSH
53159: CALL_OW 1
53163: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53164: LD_ADDR_EXP 54
53168: PUSH
53169: LD_EXP 54
53173: PPUSH
53174: LD_VAR 0 1
53178: PPUSH
53179: EMPTY
53180: PPUSH
53181: CALL_OW 1
53185: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53186: LD_ADDR_EXP 55
53190: PUSH
53191: LD_EXP 55
53195: PPUSH
53196: LD_VAR 0 1
53200: PPUSH
53201: EMPTY
53202: PPUSH
53203: CALL_OW 1
53207: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53208: LD_ADDR_EXP 56
53212: PUSH
53213: LD_EXP 56
53217: PPUSH
53218: LD_VAR 0 1
53222: PPUSH
53223: EMPTY
53224: PPUSH
53225: CALL_OW 1
53229: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53230: LD_ADDR_EXP 57
53234: PUSH
53235: LD_EXP 57
53239: PPUSH
53240: LD_VAR 0 1
53244: PPUSH
53245: EMPTY
53246: PPUSH
53247: CALL_OW 1
53251: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53252: LD_ADDR_EXP 58
53256: PUSH
53257: LD_EXP 58
53261: PPUSH
53262: LD_VAR 0 1
53266: PPUSH
53267: EMPTY
53268: PPUSH
53269: CALL_OW 1
53273: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53274: LD_ADDR_EXP 59
53278: PUSH
53279: LD_EXP 59
53283: PPUSH
53284: LD_VAR 0 1
53288: PPUSH
53289: EMPTY
53290: PPUSH
53291: CALL_OW 1
53295: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53296: LD_ADDR_EXP 60
53300: PUSH
53301: LD_EXP 60
53305: PPUSH
53306: LD_VAR 0 1
53310: PPUSH
53311: EMPTY
53312: PPUSH
53313: CALL_OW 1
53317: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53318: LD_ADDR_EXP 61
53322: PUSH
53323: LD_EXP 61
53327: PPUSH
53328: LD_VAR 0 1
53332: PPUSH
53333: EMPTY
53334: PPUSH
53335: CALL_OW 1
53339: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53340: LD_ADDR_EXP 62
53344: PUSH
53345: LD_EXP 62
53349: PPUSH
53350: LD_VAR 0 1
53354: PPUSH
53355: EMPTY
53356: PPUSH
53357: CALL_OW 1
53361: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53362: LD_ADDR_EXP 63
53366: PUSH
53367: LD_EXP 63
53371: PPUSH
53372: LD_VAR 0 1
53376: PPUSH
53377: EMPTY
53378: PPUSH
53379: CALL_OW 1
53383: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53384: LD_ADDR_EXP 64
53388: PUSH
53389: LD_EXP 64
53393: PPUSH
53394: LD_VAR 0 1
53398: PPUSH
53399: EMPTY
53400: PPUSH
53401: CALL_OW 1
53405: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53406: LD_ADDR_EXP 65
53410: PUSH
53411: LD_EXP 65
53415: PPUSH
53416: LD_VAR 0 1
53420: PPUSH
53421: LD_INT 0
53423: PPUSH
53424: CALL_OW 1
53428: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53429: LD_ADDR_EXP 66
53433: PUSH
53434: LD_EXP 66
53438: PPUSH
53439: LD_VAR 0 1
53443: PPUSH
53444: LD_INT 0
53446: PPUSH
53447: CALL_OW 1
53451: ST_TO_ADDR
// end ;
53452: LD_VAR 0 2
53456: RET
// export function MC_Add ( side , units ) ; var base ; begin
53457: LD_INT 0
53459: PPUSH
53460: PPUSH
// base := mc_bases + 1 ;
53461: LD_ADDR_VAR 0 4
53465: PUSH
53466: LD_EXP 23
53470: PUSH
53471: LD_INT 1
53473: PLUS
53474: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53475: LD_ADDR_EXP 49
53479: PUSH
53480: LD_EXP 49
53484: PPUSH
53485: LD_VAR 0 4
53489: PPUSH
53490: LD_VAR 0 1
53494: PPUSH
53495: CALL_OW 1
53499: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53500: LD_ADDR_EXP 23
53504: PUSH
53505: LD_EXP 23
53509: PPUSH
53510: LD_VAR 0 4
53514: PPUSH
53515: LD_VAR 0 2
53519: PPUSH
53520: CALL_OW 1
53524: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53525: LD_ADDR_EXP 24
53529: PUSH
53530: LD_EXP 24
53534: PPUSH
53535: LD_VAR 0 4
53539: PPUSH
53540: EMPTY
53541: PPUSH
53542: CALL_OW 1
53546: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53547: LD_ADDR_EXP 25
53551: PUSH
53552: LD_EXP 25
53556: PPUSH
53557: LD_VAR 0 4
53561: PPUSH
53562: EMPTY
53563: PPUSH
53564: CALL_OW 1
53568: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53569: LD_ADDR_EXP 26
53573: PUSH
53574: LD_EXP 26
53578: PPUSH
53579: LD_VAR 0 4
53583: PPUSH
53584: EMPTY
53585: PPUSH
53586: CALL_OW 1
53590: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53591: LD_ADDR_EXP 27
53595: PUSH
53596: LD_EXP 27
53600: PPUSH
53601: LD_VAR 0 4
53605: PPUSH
53606: EMPTY
53607: PPUSH
53608: CALL_OW 1
53612: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53613: LD_ADDR_EXP 28
53617: PUSH
53618: LD_EXP 28
53622: PPUSH
53623: LD_VAR 0 4
53627: PPUSH
53628: EMPTY
53629: PPUSH
53630: CALL_OW 1
53634: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53635: LD_ADDR_EXP 29
53639: PUSH
53640: LD_EXP 29
53644: PPUSH
53645: LD_VAR 0 4
53649: PPUSH
53650: EMPTY
53651: PPUSH
53652: CALL_OW 1
53656: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53657: LD_ADDR_EXP 30
53661: PUSH
53662: LD_EXP 30
53666: PPUSH
53667: LD_VAR 0 4
53671: PPUSH
53672: EMPTY
53673: PPUSH
53674: CALL_OW 1
53678: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53679: LD_ADDR_EXP 31
53683: PUSH
53684: LD_EXP 31
53688: PPUSH
53689: LD_VAR 0 4
53693: PPUSH
53694: EMPTY
53695: PPUSH
53696: CALL_OW 1
53700: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53701: LD_ADDR_EXP 32
53705: PUSH
53706: LD_EXP 32
53710: PPUSH
53711: LD_VAR 0 4
53715: PPUSH
53716: EMPTY
53717: PPUSH
53718: CALL_OW 1
53722: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53723: LD_ADDR_EXP 33
53727: PUSH
53728: LD_EXP 33
53732: PPUSH
53733: LD_VAR 0 4
53737: PPUSH
53738: EMPTY
53739: PPUSH
53740: CALL_OW 1
53744: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53745: LD_ADDR_EXP 34
53749: PUSH
53750: LD_EXP 34
53754: PPUSH
53755: LD_VAR 0 4
53759: PPUSH
53760: LD_INT 0
53762: PPUSH
53763: CALL_OW 1
53767: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53768: LD_ADDR_EXP 35
53772: PUSH
53773: LD_EXP 35
53777: PPUSH
53778: LD_VAR 0 4
53782: PPUSH
53783: EMPTY
53784: PPUSH
53785: CALL_OW 1
53789: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53790: LD_ADDR_EXP 36
53794: PUSH
53795: LD_EXP 36
53799: PPUSH
53800: LD_VAR 0 4
53804: PPUSH
53805: EMPTY
53806: PPUSH
53807: CALL_OW 1
53811: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53812: LD_ADDR_EXP 37
53816: PUSH
53817: LD_EXP 37
53821: PPUSH
53822: LD_VAR 0 4
53826: PPUSH
53827: EMPTY
53828: PPUSH
53829: CALL_OW 1
53833: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53834: LD_ADDR_EXP 38
53838: PUSH
53839: LD_EXP 38
53843: PPUSH
53844: LD_VAR 0 4
53848: PPUSH
53849: EMPTY
53850: PPUSH
53851: CALL_OW 1
53855: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53856: LD_ADDR_EXP 39
53860: PUSH
53861: LD_EXP 39
53865: PPUSH
53866: LD_VAR 0 4
53870: PPUSH
53871: EMPTY
53872: PPUSH
53873: CALL_OW 1
53877: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53878: LD_ADDR_EXP 40
53882: PUSH
53883: LD_EXP 40
53887: PPUSH
53888: LD_VAR 0 4
53892: PPUSH
53893: EMPTY
53894: PPUSH
53895: CALL_OW 1
53899: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53900: LD_ADDR_EXP 41
53904: PUSH
53905: LD_EXP 41
53909: PPUSH
53910: LD_VAR 0 4
53914: PPUSH
53915: EMPTY
53916: PPUSH
53917: CALL_OW 1
53921: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53922: LD_ADDR_EXP 42
53926: PUSH
53927: LD_EXP 42
53931: PPUSH
53932: LD_VAR 0 4
53936: PPUSH
53937: EMPTY
53938: PPUSH
53939: CALL_OW 1
53943: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53944: LD_ADDR_EXP 43
53948: PUSH
53949: LD_EXP 43
53953: PPUSH
53954: LD_VAR 0 4
53958: PPUSH
53959: EMPTY
53960: PPUSH
53961: CALL_OW 1
53965: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53966: LD_ADDR_EXP 44
53970: PUSH
53971: LD_EXP 44
53975: PPUSH
53976: LD_VAR 0 4
53980: PPUSH
53981: EMPTY
53982: PPUSH
53983: CALL_OW 1
53987: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53988: LD_ADDR_EXP 45
53992: PUSH
53993: LD_EXP 45
53997: PPUSH
53998: LD_VAR 0 4
54002: PPUSH
54003: EMPTY
54004: PPUSH
54005: CALL_OW 1
54009: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54010: LD_ADDR_EXP 46
54014: PUSH
54015: LD_EXP 46
54019: PPUSH
54020: LD_VAR 0 4
54024: PPUSH
54025: EMPTY
54026: PPUSH
54027: CALL_OW 1
54031: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54032: LD_ADDR_EXP 47
54036: PUSH
54037: LD_EXP 47
54041: PPUSH
54042: LD_VAR 0 4
54046: PPUSH
54047: EMPTY
54048: PPUSH
54049: CALL_OW 1
54053: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54054: LD_ADDR_EXP 48
54058: PUSH
54059: LD_EXP 48
54063: PPUSH
54064: LD_VAR 0 4
54068: PPUSH
54069: EMPTY
54070: PPUSH
54071: CALL_OW 1
54075: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54076: LD_ADDR_EXP 50
54080: PUSH
54081: LD_EXP 50
54085: PPUSH
54086: LD_VAR 0 4
54090: PPUSH
54091: EMPTY
54092: PPUSH
54093: CALL_OW 1
54097: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54098: LD_ADDR_EXP 52
54102: PUSH
54103: LD_EXP 52
54107: PPUSH
54108: LD_VAR 0 4
54112: PPUSH
54113: EMPTY
54114: PPUSH
54115: CALL_OW 1
54119: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54120: LD_ADDR_EXP 53
54124: PUSH
54125: LD_EXP 53
54129: PPUSH
54130: LD_VAR 0 4
54134: PPUSH
54135: EMPTY
54136: PPUSH
54137: CALL_OW 1
54141: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54142: LD_ADDR_EXP 54
54146: PUSH
54147: LD_EXP 54
54151: PPUSH
54152: LD_VAR 0 4
54156: PPUSH
54157: EMPTY
54158: PPUSH
54159: CALL_OW 1
54163: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54164: LD_ADDR_EXP 55
54168: PUSH
54169: LD_EXP 55
54173: PPUSH
54174: LD_VAR 0 4
54178: PPUSH
54179: EMPTY
54180: PPUSH
54181: CALL_OW 1
54185: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54186: LD_ADDR_EXP 56
54190: PUSH
54191: LD_EXP 56
54195: PPUSH
54196: LD_VAR 0 4
54200: PPUSH
54201: EMPTY
54202: PPUSH
54203: CALL_OW 1
54207: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54208: LD_ADDR_EXP 57
54212: PUSH
54213: LD_EXP 57
54217: PPUSH
54218: LD_VAR 0 4
54222: PPUSH
54223: EMPTY
54224: PPUSH
54225: CALL_OW 1
54229: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54230: LD_ADDR_EXP 58
54234: PUSH
54235: LD_EXP 58
54239: PPUSH
54240: LD_VAR 0 4
54244: PPUSH
54245: EMPTY
54246: PPUSH
54247: CALL_OW 1
54251: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54252: LD_ADDR_EXP 59
54256: PUSH
54257: LD_EXP 59
54261: PPUSH
54262: LD_VAR 0 4
54266: PPUSH
54267: EMPTY
54268: PPUSH
54269: CALL_OW 1
54273: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54274: LD_ADDR_EXP 60
54278: PUSH
54279: LD_EXP 60
54283: PPUSH
54284: LD_VAR 0 4
54288: PPUSH
54289: EMPTY
54290: PPUSH
54291: CALL_OW 1
54295: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54296: LD_ADDR_EXP 61
54300: PUSH
54301: LD_EXP 61
54305: PPUSH
54306: LD_VAR 0 4
54310: PPUSH
54311: EMPTY
54312: PPUSH
54313: CALL_OW 1
54317: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54318: LD_ADDR_EXP 62
54322: PUSH
54323: LD_EXP 62
54327: PPUSH
54328: LD_VAR 0 4
54332: PPUSH
54333: EMPTY
54334: PPUSH
54335: CALL_OW 1
54339: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54340: LD_ADDR_EXP 63
54344: PUSH
54345: LD_EXP 63
54349: PPUSH
54350: LD_VAR 0 4
54354: PPUSH
54355: EMPTY
54356: PPUSH
54357: CALL_OW 1
54361: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54362: LD_ADDR_EXP 64
54366: PUSH
54367: LD_EXP 64
54371: PPUSH
54372: LD_VAR 0 4
54376: PPUSH
54377: EMPTY
54378: PPUSH
54379: CALL_OW 1
54383: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54384: LD_ADDR_EXP 65
54388: PUSH
54389: LD_EXP 65
54393: PPUSH
54394: LD_VAR 0 4
54398: PPUSH
54399: LD_INT 0
54401: PPUSH
54402: CALL_OW 1
54406: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54407: LD_ADDR_EXP 66
54411: PUSH
54412: LD_EXP 66
54416: PPUSH
54417: LD_VAR 0 4
54421: PPUSH
54422: LD_INT 0
54424: PPUSH
54425: CALL_OW 1
54429: ST_TO_ADDR
// result := base ;
54430: LD_ADDR_VAR 0 3
54434: PUSH
54435: LD_VAR 0 4
54439: ST_TO_ADDR
// end ;
54440: LD_VAR 0 3
54444: RET
// export function MC_Start ( ) ; var i ; begin
54445: LD_INT 0
54447: PPUSH
54448: PPUSH
// for i = 1 to mc_bases do
54449: LD_ADDR_VAR 0 2
54453: PUSH
54454: DOUBLE
54455: LD_INT 1
54457: DEC
54458: ST_TO_ADDR
54459: LD_EXP 23
54463: PUSH
54464: FOR_TO
54465: IFFALSE 55565
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54467: LD_ADDR_EXP 23
54471: PUSH
54472: LD_EXP 23
54476: PPUSH
54477: LD_VAR 0 2
54481: PPUSH
54482: LD_EXP 23
54486: PUSH
54487: LD_VAR 0 2
54491: ARRAY
54492: PUSH
54493: LD_INT 0
54495: DIFF
54496: PPUSH
54497: CALL_OW 1
54501: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54502: LD_ADDR_EXP 24
54506: PUSH
54507: LD_EXP 24
54511: PPUSH
54512: LD_VAR 0 2
54516: PPUSH
54517: EMPTY
54518: PPUSH
54519: CALL_OW 1
54523: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54524: LD_ADDR_EXP 25
54528: PUSH
54529: LD_EXP 25
54533: PPUSH
54534: LD_VAR 0 2
54538: PPUSH
54539: EMPTY
54540: PPUSH
54541: CALL_OW 1
54545: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54546: LD_ADDR_EXP 26
54550: PUSH
54551: LD_EXP 26
54555: PPUSH
54556: LD_VAR 0 2
54560: PPUSH
54561: EMPTY
54562: PPUSH
54563: CALL_OW 1
54567: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54568: LD_ADDR_EXP 27
54572: PUSH
54573: LD_EXP 27
54577: PPUSH
54578: LD_VAR 0 2
54582: PPUSH
54583: EMPTY
54584: PUSH
54585: EMPTY
54586: PUSH
54587: EMPTY
54588: LIST
54589: LIST
54590: PPUSH
54591: CALL_OW 1
54595: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54596: LD_ADDR_EXP 28
54600: PUSH
54601: LD_EXP 28
54605: PPUSH
54606: LD_VAR 0 2
54610: PPUSH
54611: EMPTY
54612: PPUSH
54613: CALL_OW 1
54617: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54618: LD_ADDR_EXP 55
54622: PUSH
54623: LD_EXP 55
54627: PPUSH
54628: LD_VAR 0 2
54632: PPUSH
54633: EMPTY
54634: PPUSH
54635: CALL_OW 1
54639: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54640: LD_ADDR_EXP 29
54644: PUSH
54645: LD_EXP 29
54649: PPUSH
54650: LD_VAR 0 2
54654: PPUSH
54655: EMPTY
54656: PPUSH
54657: CALL_OW 1
54661: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54662: LD_ADDR_EXP 30
54666: PUSH
54667: LD_EXP 30
54671: PPUSH
54672: LD_VAR 0 2
54676: PPUSH
54677: EMPTY
54678: PPUSH
54679: CALL_OW 1
54683: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54684: LD_ADDR_EXP 31
54688: PUSH
54689: LD_EXP 31
54693: PPUSH
54694: LD_VAR 0 2
54698: PPUSH
54699: LD_EXP 23
54703: PUSH
54704: LD_VAR 0 2
54708: ARRAY
54709: PPUSH
54710: LD_INT 2
54712: PUSH
54713: LD_INT 30
54715: PUSH
54716: LD_INT 32
54718: PUSH
54719: EMPTY
54720: LIST
54721: LIST
54722: PUSH
54723: LD_INT 30
54725: PUSH
54726: LD_INT 33
54728: PUSH
54729: EMPTY
54730: LIST
54731: LIST
54732: PUSH
54733: EMPTY
54734: LIST
54735: LIST
54736: LIST
54737: PPUSH
54738: CALL_OW 72
54742: PPUSH
54743: CALL_OW 1
54747: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54748: LD_ADDR_EXP 32
54752: PUSH
54753: LD_EXP 32
54757: PPUSH
54758: LD_VAR 0 2
54762: PPUSH
54763: LD_EXP 23
54767: PUSH
54768: LD_VAR 0 2
54772: ARRAY
54773: PPUSH
54774: LD_INT 2
54776: PUSH
54777: LD_INT 30
54779: PUSH
54780: LD_INT 32
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: PUSH
54787: LD_INT 30
54789: PUSH
54790: LD_INT 31
54792: PUSH
54793: EMPTY
54794: LIST
54795: LIST
54796: PUSH
54797: EMPTY
54798: LIST
54799: LIST
54800: LIST
54801: PUSH
54802: LD_INT 58
54804: PUSH
54805: EMPTY
54806: LIST
54807: PUSH
54808: EMPTY
54809: LIST
54810: LIST
54811: PPUSH
54812: CALL_OW 72
54816: PPUSH
54817: CALL_OW 1
54821: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54822: LD_ADDR_EXP 33
54826: PUSH
54827: LD_EXP 33
54831: PPUSH
54832: LD_VAR 0 2
54836: PPUSH
54837: EMPTY
54838: PPUSH
54839: CALL_OW 1
54843: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54844: LD_ADDR_EXP 37
54848: PUSH
54849: LD_EXP 37
54853: PPUSH
54854: LD_VAR 0 2
54858: PPUSH
54859: EMPTY
54860: PPUSH
54861: CALL_OW 1
54865: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54866: LD_ADDR_EXP 36
54870: PUSH
54871: LD_EXP 36
54875: PPUSH
54876: LD_VAR 0 2
54880: PPUSH
54881: EMPTY
54882: PPUSH
54883: CALL_OW 1
54887: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54888: LD_ADDR_EXP 38
54892: PUSH
54893: LD_EXP 38
54897: PPUSH
54898: LD_VAR 0 2
54902: PPUSH
54903: EMPTY
54904: PPUSH
54905: CALL_OW 1
54909: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54910: LD_ADDR_EXP 39
54914: PUSH
54915: LD_EXP 39
54919: PPUSH
54920: LD_VAR 0 2
54924: PPUSH
54925: EMPTY
54926: PPUSH
54927: CALL_OW 1
54931: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54932: LD_ADDR_EXP 40
54936: PUSH
54937: LD_EXP 40
54941: PPUSH
54942: LD_VAR 0 2
54946: PPUSH
54947: EMPTY
54948: PPUSH
54949: CALL_OW 1
54953: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54954: LD_ADDR_EXP 41
54958: PUSH
54959: LD_EXP 41
54963: PPUSH
54964: LD_VAR 0 2
54968: PPUSH
54969: EMPTY
54970: PPUSH
54971: CALL_OW 1
54975: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54976: LD_ADDR_EXP 42
54980: PUSH
54981: LD_EXP 42
54985: PPUSH
54986: LD_VAR 0 2
54990: PPUSH
54991: EMPTY
54992: PPUSH
54993: CALL_OW 1
54997: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54998: LD_ADDR_EXP 43
55002: PUSH
55003: LD_EXP 43
55007: PPUSH
55008: LD_VAR 0 2
55012: PPUSH
55013: EMPTY
55014: PPUSH
55015: CALL_OW 1
55019: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55020: LD_ADDR_EXP 44
55024: PUSH
55025: LD_EXP 44
55029: PPUSH
55030: LD_VAR 0 2
55034: PPUSH
55035: EMPTY
55036: PPUSH
55037: CALL_OW 1
55041: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55042: LD_ADDR_EXP 45
55046: PUSH
55047: LD_EXP 45
55051: PPUSH
55052: LD_VAR 0 2
55056: PPUSH
55057: EMPTY
55058: PPUSH
55059: CALL_OW 1
55063: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55064: LD_ADDR_EXP 34
55068: PUSH
55069: LD_EXP 34
55073: PPUSH
55074: LD_VAR 0 2
55078: PPUSH
55079: LD_INT 0
55081: PPUSH
55082: CALL_OW 1
55086: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55087: LD_ADDR_EXP 47
55091: PUSH
55092: LD_EXP 47
55096: PPUSH
55097: LD_VAR 0 2
55101: PPUSH
55102: LD_INT 0
55104: PPUSH
55105: CALL_OW 1
55109: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55110: LD_ADDR_EXP 35
55114: PUSH
55115: LD_EXP 35
55119: PPUSH
55120: LD_VAR 0 2
55124: PPUSH
55125: EMPTY
55126: PPUSH
55127: CALL_OW 1
55131: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55132: LD_ADDR_EXP 46
55136: PUSH
55137: LD_EXP 46
55141: PPUSH
55142: LD_VAR 0 2
55146: PPUSH
55147: LD_INT 0
55149: PPUSH
55150: CALL_OW 1
55154: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55155: LD_ADDR_EXP 48
55159: PUSH
55160: LD_EXP 48
55164: PPUSH
55165: LD_VAR 0 2
55169: PPUSH
55170: EMPTY
55171: PPUSH
55172: CALL_OW 1
55176: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55177: LD_ADDR_EXP 51
55181: PUSH
55182: LD_EXP 51
55186: PPUSH
55187: LD_VAR 0 2
55191: PPUSH
55192: LD_INT 0
55194: PPUSH
55195: CALL_OW 1
55199: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55200: LD_ADDR_EXP 52
55204: PUSH
55205: LD_EXP 52
55209: PPUSH
55210: LD_VAR 0 2
55214: PPUSH
55215: EMPTY
55216: PPUSH
55217: CALL_OW 1
55221: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55222: LD_ADDR_EXP 53
55226: PUSH
55227: LD_EXP 53
55231: PPUSH
55232: LD_VAR 0 2
55236: PPUSH
55237: EMPTY
55238: PPUSH
55239: CALL_OW 1
55243: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55244: LD_ADDR_EXP 54
55248: PUSH
55249: LD_EXP 54
55253: PPUSH
55254: LD_VAR 0 2
55258: PPUSH
55259: EMPTY
55260: PPUSH
55261: CALL_OW 1
55265: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55266: LD_ADDR_EXP 56
55270: PUSH
55271: LD_EXP 56
55275: PPUSH
55276: LD_VAR 0 2
55280: PPUSH
55281: LD_EXP 23
55285: PUSH
55286: LD_VAR 0 2
55290: ARRAY
55291: PPUSH
55292: LD_INT 2
55294: PUSH
55295: LD_INT 30
55297: PUSH
55298: LD_INT 6
55300: PUSH
55301: EMPTY
55302: LIST
55303: LIST
55304: PUSH
55305: LD_INT 30
55307: PUSH
55308: LD_INT 7
55310: PUSH
55311: EMPTY
55312: LIST
55313: LIST
55314: PUSH
55315: LD_INT 30
55317: PUSH
55318: LD_INT 8
55320: PUSH
55321: EMPTY
55322: LIST
55323: LIST
55324: PUSH
55325: EMPTY
55326: LIST
55327: LIST
55328: LIST
55329: LIST
55330: PPUSH
55331: CALL_OW 72
55335: PPUSH
55336: CALL_OW 1
55340: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55341: LD_ADDR_EXP 57
55345: PUSH
55346: LD_EXP 57
55350: PPUSH
55351: LD_VAR 0 2
55355: PPUSH
55356: EMPTY
55357: PPUSH
55358: CALL_OW 1
55362: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55363: LD_ADDR_EXP 58
55367: PUSH
55368: LD_EXP 58
55372: PPUSH
55373: LD_VAR 0 2
55377: PPUSH
55378: EMPTY
55379: PPUSH
55380: CALL_OW 1
55384: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55385: LD_ADDR_EXP 59
55389: PUSH
55390: LD_EXP 59
55394: PPUSH
55395: LD_VAR 0 2
55399: PPUSH
55400: EMPTY
55401: PPUSH
55402: CALL_OW 1
55406: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55407: LD_ADDR_EXP 60
55411: PUSH
55412: LD_EXP 60
55416: PPUSH
55417: LD_VAR 0 2
55421: PPUSH
55422: EMPTY
55423: PPUSH
55424: CALL_OW 1
55428: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55429: LD_ADDR_EXP 61
55433: PUSH
55434: LD_EXP 61
55438: PPUSH
55439: LD_VAR 0 2
55443: PPUSH
55444: EMPTY
55445: PPUSH
55446: CALL_OW 1
55450: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55451: LD_ADDR_EXP 62
55455: PUSH
55456: LD_EXP 62
55460: PPUSH
55461: LD_VAR 0 2
55465: PPUSH
55466: EMPTY
55467: PPUSH
55468: CALL_OW 1
55472: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55473: LD_ADDR_EXP 63
55477: PUSH
55478: LD_EXP 63
55482: PPUSH
55483: LD_VAR 0 2
55487: PPUSH
55488: EMPTY
55489: PPUSH
55490: CALL_OW 1
55494: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55495: LD_ADDR_EXP 64
55499: PUSH
55500: LD_EXP 64
55504: PPUSH
55505: LD_VAR 0 2
55509: PPUSH
55510: EMPTY
55511: PPUSH
55512: CALL_OW 1
55516: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55517: LD_ADDR_EXP 65
55521: PUSH
55522: LD_EXP 65
55526: PPUSH
55527: LD_VAR 0 2
55531: PPUSH
55532: LD_INT 0
55534: PPUSH
55535: CALL_OW 1
55539: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55540: LD_ADDR_EXP 66
55544: PUSH
55545: LD_EXP 66
55549: PPUSH
55550: LD_VAR 0 2
55554: PPUSH
55555: LD_INT 0
55557: PPUSH
55558: CALL_OW 1
55562: ST_TO_ADDR
// end ;
55563: GO 54464
55565: POP
55566: POP
// MC_InitSides ( ) ;
55567: CALL 55853 0 0
// MC_InitResearch ( ) ;
55571: CALL 55592 0 0
// CustomInitMacro ( ) ;
55575: CALL 269 0 0
// skirmish := true ;
55579: LD_ADDR_EXP 21
55583: PUSH
55584: LD_INT 1
55586: ST_TO_ADDR
// end ;
55587: LD_VAR 0 1
55591: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55592: LD_INT 0
55594: PPUSH
55595: PPUSH
55596: PPUSH
55597: PPUSH
55598: PPUSH
55599: PPUSH
// if not mc_bases then
55600: LD_EXP 23
55604: NOT
55605: IFFALSE 55609
// exit ;
55607: GO 55848
// for i = 1 to 8 do
55609: LD_ADDR_VAR 0 2
55613: PUSH
55614: DOUBLE
55615: LD_INT 1
55617: DEC
55618: ST_TO_ADDR
55619: LD_INT 8
55621: PUSH
55622: FOR_TO
55623: IFFALSE 55649
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55625: LD_ADDR_EXP 50
55629: PUSH
55630: LD_EXP 50
55634: PPUSH
55635: LD_VAR 0 2
55639: PPUSH
55640: EMPTY
55641: PPUSH
55642: CALL_OW 1
55646: ST_TO_ADDR
55647: GO 55622
55649: POP
55650: POP
// tmp := [ ] ;
55651: LD_ADDR_VAR 0 5
55655: PUSH
55656: EMPTY
55657: ST_TO_ADDR
// for i = 1 to mc_sides do
55658: LD_ADDR_VAR 0 2
55662: PUSH
55663: DOUBLE
55664: LD_INT 1
55666: DEC
55667: ST_TO_ADDR
55668: LD_EXP 49
55672: PUSH
55673: FOR_TO
55674: IFFALSE 55732
// if not mc_sides [ i ] in tmp then
55676: LD_EXP 49
55680: PUSH
55681: LD_VAR 0 2
55685: ARRAY
55686: PUSH
55687: LD_VAR 0 5
55691: IN
55692: NOT
55693: IFFALSE 55730
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55695: LD_ADDR_VAR 0 5
55699: PUSH
55700: LD_VAR 0 5
55704: PPUSH
55705: LD_VAR 0 5
55709: PUSH
55710: LD_INT 1
55712: PLUS
55713: PPUSH
55714: LD_EXP 49
55718: PUSH
55719: LD_VAR 0 2
55723: ARRAY
55724: PPUSH
55725: CALL_OW 2
55729: ST_TO_ADDR
55730: GO 55673
55732: POP
55733: POP
// if not tmp then
55734: LD_VAR 0 5
55738: NOT
55739: IFFALSE 55743
// exit ;
55741: GO 55848
// for j in tmp do
55743: LD_ADDR_VAR 0 3
55747: PUSH
55748: LD_VAR 0 5
55752: PUSH
55753: FOR_IN
55754: IFFALSE 55846
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55756: LD_ADDR_VAR 0 6
55760: PUSH
55761: LD_INT 22
55763: PUSH
55764: LD_VAR 0 3
55768: PUSH
55769: EMPTY
55770: LIST
55771: LIST
55772: PPUSH
55773: CALL_OW 69
55777: ST_TO_ADDR
// if not un then
55778: LD_VAR 0 6
55782: NOT
55783: IFFALSE 55787
// continue ;
55785: GO 55753
// nation := GetNation ( un [ 1 ] ) ;
55787: LD_ADDR_VAR 0 4
55791: PUSH
55792: LD_VAR 0 6
55796: PUSH
55797: LD_INT 1
55799: ARRAY
55800: PPUSH
55801: CALL_OW 248
55805: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55806: LD_ADDR_EXP 50
55810: PUSH
55811: LD_EXP 50
55815: PPUSH
55816: LD_VAR 0 3
55820: PPUSH
55821: LD_VAR 0 3
55825: PPUSH
55826: LD_VAR 0 4
55830: PPUSH
55831: LD_INT 1
55833: PPUSH
55834: CALL 11078 0 3
55838: PPUSH
55839: CALL_OW 1
55843: ST_TO_ADDR
// end ;
55844: GO 55753
55846: POP
55847: POP
// end ;
55848: LD_VAR 0 1
55852: RET
// export function MC_InitSides ( ) ; var i ; begin
55853: LD_INT 0
55855: PPUSH
55856: PPUSH
// if not mc_bases then
55857: LD_EXP 23
55861: NOT
55862: IFFALSE 55866
// exit ;
55864: GO 55940
// for i = 1 to mc_bases do
55866: LD_ADDR_VAR 0 2
55870: PUSH
55871: DOUBLE
55872: LD_INT 1
55874: DEC
55875: ST_TO_ADDR
55876: LD_EXP 23
55880: PUSH
55881: FOR_TO
55882: IFFALSE 55938
// if mc_bases [ i ] then
55884: LD_EXP 23
55888: PUSH
55889: LD_VAR 0 2
55893: ARRAY
55894: IFFALSE 55936
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55896: LD_ADDR_EXP 49
55900: PUSH
55901: LD_EXP 49
55905: PPUSH
55906: LD_VAR 0 2
55910: PPUSH
55911: LD_EXP 23
55915: PUSH
55916: LD_VAR 0 2
55920: ARRAY
55921: PUSH
55922: LD_INT 1
55924: ARRAY
55925: PPUSH
55926: CALL_OW 255
55930: PPUSH
55931: CALL_OW 1
55935: ST_TO_ADDR
55936: GO 55881
55938: POP
55939: POP
// end ;
55940: LD_VAR 0 1
55944: RET
// every 0 0$03 trigger skirmish do
55945: LD_EXP 21
55949: IFFALSE 56103
55951: GO 55953
55953: DISABLE
// begin enable ;
55954: ENABLE
// MC_CheckBuildings ( ) ;
55955: CALL 60601 0 0
// MC_CheckPeopleLife ( ) ;
55959: CALL 60762 0 0
// RaiseSailEvent ( 100 ) ;
55963: LD_INT 100
55965: PPUSH
55966: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55970: LD_INT 103
55972: PPUSH
55973: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55977: LD_INT 104
55979: PPUSH
55980: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55984: LD_INT 105
55986: PPUSH
55987: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55991: LD_INT 106
55993: PPUSH
55994: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55998: LD_INT 107
56000: PPUSH
56001: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56005: LD_INT 108
56007: PPUSH
56008: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56012: LD_INT 109
56014: PPUSH
56015: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56019: LD_INT 110
56021: PPUSH
56022: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56026: LD_INT 111
56028: PPUSH
56029: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56033: LD_INT 112
56035: PPUSH
56036: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56040: LD_INT 113
56042: PPUSH
56043: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56047: LD_INT 120
56049: PPUSH
56050: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56054: LD_INT 121
56056: PPUSH
56057: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56061: LD_INT 122
56063: PPUSH
56064: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56068: LD_INT 123
56070: PPUSH
56071: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56075: LD_INT 124
56077: PPUSH
56078: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56082: LD_INT 125
56084: PPUSH
56085: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56089: LD_INT 126
56091: PPUSH
56092: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56096: LD_INT 200
56098: PPUSH
56099: CALL_OW 427
// end ;
56103: END
// on SailEvent ( event ) do begin if event < 100 then
56104: LD_VAR 0 1
56108: PUSH
56109: LD_INT 100
56111: LESS
56112: IFFALSE 56123
// CustomEvent ( event ) ;
56114: LD_VAR 0 1
56118: PPUSH
56119: CALL 10229 0 1
// if event = 100 then
56123: LD_VAR 0 1
56127: PUSH
56128: LD_INT 100
56130: EQUAL
56131: IFFALSE 56137
// MC_ClassManager ( ) ;
56133: CALL 56529 0 0
// if event = 101 then
56137: LD_VAR 0 1
56141: PUSH
56142: LD_INT 101
56144: EQUAL
56145: IFFALSE 56151
// MC_RepairBuildings ( ) ;
56147: CALL 61347 0 0
// if event = 102 then
56151: LD_VAR 0 1
56155: PUSH
56156: LD_INT 102
56158: EQUAL
56159: IFFALSE 56165
// MC_Heal ( ) ;
56161: CALL 62282 0 0
// if event = 103 then
56165: LD_VAR 0 1
56169: PUSH
56170: LD_INT 103
56172: EQUAL
56173: IFFALSE 56179
// MC_Build ( ) ;
56175: CALL 62704 0 0
// if event = 104 then
56179: LD_VAR 0 1
56183: PUSH
56184: LD_INT 104
56186: EQUAL
56187: IFFALSE 56193
// MC_TurretWeapon ( ) ;
56189: CALL 64338 0 0
// if event = 105 then
56193: LD_VAR 0 1
56197: PUSH
56198: LD_INT 105
56200: EQUAL
56201: IFFALSE 56207
// MC_BuildUpgrade ( ) ;
56203: CALL 63889 0 0
// if event = 106 then
56207: LD_VAR 0 1
56211: PUSH
56212: LD_INT 106
56214: EQUAL
56215: IFFALSE 56221
// MC_PlantMines ( ) ;
56217: CALL 64768 0 0
// if event = 107 then
56221: LD_VAR 0 1
56225: PUSH
56226: LD_INT 107
56228: EQUAL
56229: IFFALSE 56235
// MC_CollectCrates ( ) ;
56231: CALL 65559 0 0
// if event = 108 then
56235: LD_VAR 0 1
56239: PUSH
56240: LD_INT 108
56242: EQUAL
56243: IFFALSE 56249
// MC_LinkRemoteControl ( ) ;
56245: CALL 67409 0 0
// if event = 109 then
56249: LD_VAR 0 1
56253: PUSH
56254: LD_INT 109
56256: EQUAL
56257: IFFALSE 56263
// MC_ProduceVehicle ( ) ;
56259: CALL 67590 0 0
// if event = 110 then
56263: LD_VAR 0 1
56267: PUSH
56268: LD_INT 110
56270: EQUAL
56271: IFFALSE 56277
// MC_SendAttack ( ) ;
56273: CALL 68056 0 0
// if event = 111 then
56277: LD_VAR 0 1
56281: PUSH
56282: LD_INT 111
56284: EQUAL
56285: IFFALSE 56291
// MC_Defend ( ) ;
56287: CALL 68164 0 0
// if event = 112 then
56291: LD_VAR 0 1
56295: PUSH
56296: LD_INT 112
56298: EQUAL
56299: IFFALSE 56305
// MC_Research ( ) ;
56301: CALL 69044 0 0
// if event = 113 then
56305: LD_VAR 0 1
56309: PUSH
56310: LD_INT 113
56312: EQUAL
56313: IFFALSE 56319
// MC_MinesTrigger ( ) ;
56315: CALL 70158 0 0
// if event = 120 then
56319: LD_VAR 0 1
56323: PUSH
56324: LD_INT 120
56326: EQUAL
56327: IFFALSE 56333
// MC_RepairVehicle ( ) ;
56329: CALL 70257 0 0
// if event = 121 then
56333: LD_VAR 0 1
56337: PUSH
56338: LD_INT 121
56340: EQUAL
56341: IFFALSE 56347
// MC_TameApe ( ) ;
56343: CALL 71026 0 0
// if event = 122 then
56347: LD_VAR 0 1
56351: PUSH
56352: LD_INT 122
56354: EQUAL
56355: IFFALSE 56361
// MC_ChangeApeClass ( ) ;
56357: CALL 71855 0 0
// if event = 123 then
56361: LD_VAR 0 1
56365: PUSH
56366: LD_INT 123
56368: EQUAL
56369: IFFALSE 56375
// MC_Bazooka ( ) ;
56371: CALL 72505 0 0
// if event = 124 then
56375: LD_VAR 0 1
56379: PUSH
56380: LD_INT 124
56382: EQUAL
56383: IFFALSE 56389
// MC_TeleportExit ( ) ;
56385: CALL 72703 0 0
// if event = 125 then
56389: LD_VAR 0 1
56393: PUSH
56394: LD_INT 125
56396: EQUAL
56397: IFFALSE 56403
// MC_Deposits ( ) ;
56399: CALL 73350 0 0
// if event = 126 then
56403: LD_VAR 0 1
56407: PUSH
56408: LD_INT 126
56410: EQUAL
56411: IFFALSE 56417
// MC_RemoteDriver ( ) ;
56413: CALL 73975 0 0
// if event = 200 then
56417: LD_VAR 0 1
56421: PUSH
56422: LD_INT 200
56424: EQUAL
56425: IFFALSE 56431
// MC_Idle ( ) ;
56427: CALL 75924 0 0
// end ;
56431: PPOPN 1
56433: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56434: LD_INT 0
56436: PPUSH
56437: PPUSH
// if not mc_bases [ base ] or not tag then
56438: LD_EXP 23
56442: PUSH
56443: LD_VAR 0 1
56447: ARRAY
56448: NOT
56449: PUSH
56450: LD_VAR 0 2
56454: NOT
56455: OR
56456: IFFALSE 56460
// exit ;
56458: GO 56524
// for i in mc_bases [ base ] union mc_ape [ base ] do
56460: LD_ADDR_VAR 0 4
56464: PUSH
56465: LD_EXP 23
56469: PUSH
56470: LD_VAR 0 1
56474: ARRAY
56475: PUSH
56476: LD_EXP 52
56480: PUSH
56481: LD_VAR 0 1
56485: ARRAY
56486: UNION
56487: PUSH
56488: FOR_IN
56489: IFFALSE 56522
// if GetTag ( i ) = tag then
56491: LD_VAR 0 4
56495: PPUSH
56496: CALL_OW 110
56500: PUSH
56501: LD_VAR 0 2
56505: EQUAL
56506: IFFALSE 56520
// SetTag ( i , 0 ) ;
56508: LD_VAR 0 4
56512: PPUSH
56513: LD_INT 0
56515: PPUSH
56516: CALL_OW 109
56520: GO 56488
56522: POP
56523: POP
// end ;
56524: LD_VAR 0 3
56528: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56529: LD_INT 0
56531: PPUSH
56532: PPUSH
56533: PPUSH
56534: PPUSH
56535: PPUSH
56536: PPUSH
56537: PPUSH
56538: PPUSH
// if not mc_bases then
56539: LD_EXP 23
56543: NOT
56544: IFFALSE 56548
// exit ;
56546: GO 57006
// for i = 1 to mc_bases do
56548: LD_ADDR_VAR 0 2
56552: PUSH
56553: DOUBLE
56554: LD_INT 1
56556: DEC
56557: ST_TO_ADDR
56558: LD_EXP 23
56562: PUSH
56563: FOR_TO
56564: IFFALSE 57004
// begin tmp := MC_ClassCheckReq ( i ) ;
56566: LD_ADDR_VAR 0 4
56570: PUSH
56571: LD_VAR 0 2
56575: PPUSH
56576: CALL 57011 0 1
56580: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56581: LD_ADDR_EXP 64
56585: PUSH
56586: LD_EXP 64
56590: PPUSH
56591: LD_VAR 0 2
56595: PPUSH
56596: LD_VAR 0 4
56600: PPUSH
56601: CALL_OW 1
56605: ST_TO_ADDR
// if not tmp then
56606: LD_VAR 0 4
56610: NOT
56611: IFFALSE 56615
// continue ;
56613: GO 56563
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56615: LD_ADDR_VAR 0 6
56619: PUSH
56620: LD_EXP 23
56624: PUSH
56625: LD_VAR 0 2
56629: ARRAY
56630: PPUSH
56631: LD_INT 2
56633: PUSH
56634: LD_INT 30
56636: PUSH
56637: LD_INT 4
56639: PUSH
56640: EMPTY
56641: LIST
56642: LIST
56643: PUSH
56644: LD_INT 30
56646: PUSH
56647: LD_INT 5
56649: PUSH
56650: EMPTY
56651: LIST
56652: LIST
56653: PUSH
56654: EMPTY
56655: LIST
56656: LIST
56657: LIST
56658: PPUSH
56659: CALL_OW 72
56663: PUSH
56664: LD_EXP 23
56668: PUSH
56669: LD_VAR 0 2
56673: ARRAY
56674: PPUSH
56675: LD_INT 2
56677: PUSH
56678: LD_INT 30
56680: PUSH
56681: LD_INT 0
56683: PUSH
56684: EMPTY
56685: LIST
56686: LIST
56687: PUSH
56688: LD_INT 30
56690: PUSH
56691: LD_INT 1
56693: PUSH
56694: EMPTY
56695: LIST
56696: LIST
56697: PUSH
56698: EMPTY
56699: LIST
56700: LIST
56701: LIST
56702: PPUSH
56703: CALL_OW 72
56707: PUSH
56708: LD_EXP 23
56712: PUSH
56713: LD_VAR 0 2
56717: ARRAY
56718: PPUSH
56719: LD_INT 30
56721: PUSH
56722: LD_INT 3
56724: PUSH
56725: EMPTY
56726: LIST
56727: LIST
56728: PPUSH
56729: CALL_OW 72
56733: PUSH
56734: LD_EXP 23
56738: PUSH
56739: LD_VAR 0 2
56743: ARRAY
56744: PPUSH
56745: LD_INT 2
56747: PUSH
56748: LD_INT 30
56750: PUSH
56751: LD_INT 6
56753: PUSH
56754: EMPTY
56755: LIST
56756: LIST
56757: PUSH
56758: LD_INT 30
56760: PUSH
56761: LD_INT 7
56763: PUSH
56764: EMPTY
56765: LIST
56766: LIST
56767: PUSH
56768: LD_INT 30
56770: PUSH
56771: LD_INT 8
56773: PUSH
56774: EMPTY
56775: LIST
56776: LIST
56777: PUSH
56778: EMPTY
56779: LIST
56780: LIST
56781: LIST
56782: LIST
56783: PPUSH
56784: CALL_OW 72
56788: PUSH
56789: EMPTY
56790: LIST
56791: LIST
56792: LIST
56793: LIST
56794: ST_TO_ADDR
// for j = 1 to 4 do
56795: LD_ADDR_VAR 0 3
56799: PUSH
56800: DOUBLE
56801: LD_INT 1
56803: DEC
56804: ST_TO_ADDR
56805: LD_INT 4
56807: PUSH
56808: FOR_TO
56809: IFFALSE 57000
// begin if not tmp [ j ] then
56811: LD_VAR 0 4
56815: PUSH
56816: LD_VAR 0 3
56820: ARRAY
56821: NOT
56822: IFFALSE 56826
// continue ;
56824: GO 56808
// for p in tmp [ j ] do
56826: LD_ADDR_VAR 0 5
56830: PUSH
56831: LD_VAR 0 4
56835: PUSH
56836: LD_VAR 0 3
56840: ARRAY
56841: PUSH
56842: FOR_IN
56843: IFFALSE 56996
// begin if not b [ j ] then
56845: LD_VAR 0 6
56849: PUSH
56850: LD_VAR 0 3
56854: ARRAY
56855: NOT
56856: IFFALSE 56860
// break ;
56858: GO 56996
// e := 0 ;
56860: LD_ADDR_VAR 0 7
56864: PUSH
56865: LD_INT 0
56867: ST_TO_ADDR
// for k in b [ j ] do
56868: LD_ADDR_VAR 0 8
56872: PUSH
56873: LD_VAR 0 6
56877: PUSH
56878: LD_VAR 0 3
56882: ARRAY
56883: PUSH
56884: FOR_IN
56885: IFFALSE 56912
// if IsNotFull ( k ) then
56887: LD_VAR 0 8
56891: PPUSH
56892: CALL 13231 0 1
56896: IFFALSE 56910
// begin e := k ;
56898: LD_ADDR_VAR 0 7
56902: PUSH
56903: LD_VAR 0 8
56907: ST_TO_ADDR
// break ;
56908: GO 56912
// end ;
56910: GO 56884
56912: POP
56913: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56914: LD_VAR 0 7
56918: PUSH
56919: LD_VAR 0 5
56923: PPUSH
56924: LD_VAR 0 7
56928: PPUSH
56929: CALL 47110 0 2
56933: NOT
56934: AND
56935: IFFALSE 56994
// begin if IsInUnit ( p ) then
56937: LD_VAR 0 5
56941: PPUSH
56942: CALL_OW 310
56946: IFFALSE 56957
// ComExitBuilding ( p ) ;
56948: LD_VAR 0 5
56952: PPUSH
56953: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56957: LD_VAR 0 5
56961: PPUSH
56962: LD_VAR 0 7
56966: PPUSH
56967: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56971: LD_VAR 0 5
56975: PPUSH
56976: LD_VAR 0 3
56980: PPUSH
56981: CALL_OW 183
// AddComExitBuilding ( p ) ;
56985: LD_VAR 0 5
56989: PPUSH
56990: CALL_OW 182
// end ; end ;
56994: GO 56842
56996: POP
56997: POP
// end ;
56998: GO 56808
57000: POP
57001: POP
// end ;
57002: GO 56563
57004: POP
57005: POP
// end ;
57006: LD_VAR 0 1
57010: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57011: LD_INT 0
57013: PPUSH
57014: PPUSH
57015: PPUSH
57016: PPUSH
57017: PPUSH
57018: PPUSH
57019: PPUSH
57020: PPUSH
57021: PPUSH
57022: PPUSH
57023: PPUSH
57024: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57025: LD_VAR 0 1
57029: NOT
57030: PUSH
57031: LD_EXP 23
57035: PUSH
57036: LD_VAR 0 1
57040: ARRAY
57041: NOT
57042: OR
57043: PUSH
57044: LD_EXP 23
57048: PUSH
57049: LD_VAR 0 1
57053: ARRAY
57054: PPUSH
57055: LD_INT 2
57057: PUSH
57058: LD_INT 30
57060: PUSH
57061: LD_INT 0
57063: PUSH
57064: EMPTY
57065: LIST
57066: LIST
57067: PUSH
57068: LD_INT 30
57070: PUSH
57071: LD_INT 1
57073: PUSH
57074: EMPTY
57075: LIST
57076: LIST
57077: PUSH
57078: EMPTY
57079: LIST
57080: LIST
57081: LIST
57082: PPUSH
57083: CALL_OW 72
57087: NOT
57088: OR
57089: IFFALSE 57093
// exit ;
57091: GO 60596
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57093: LD_ADDR_VAR 0 4
57097: PUSH
57098: LD_EXP 23
57102: PUSH
57103: LD_VAR 0 1
57107: ARRAY
57108: PPUSH
57109: LD_INT 2
57111: PUSH
57112: LD_INT 25
57114: PUSH
57115: LD_INT 1
57117: PUSH
57118: EMPTY
57119: LIST
57120: LIST
57121: PUSH
57122: LD_INT 25
57124: PUSH
57125: LD_INT 2
57127: PUSH
57128: EMPTY
57129: LIST
57130: LIST
57131: PUSH
57132: LD_INT 25
57134: PUSH
57135: LD_INT 3
57137: PUSH
57138: EMPTY
57139: LIST
57140: LIST
57141: PUSH
57142: LD_INT 25
57144: PUSH
57145: LD_INT 4
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: PUSH
57152: LD_INT 25
57154: PUSH
57155: LD_INT 5
57157: PUSH
57158: EMPTY
57159: LIST
57160: LIST
57161: PUSH
57162: LD_INT 25
57164: PUSH
57165: LD_INT 8
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: PUSH
57172: LD_INT 25
57174: PUSH
57175: LD_INT 9
57177: PUSH
57178: EMPTY
57179: LIST
57180: LIST
57181: PUSH
57182: EMPTY
57183: LIST
57184: LIST
57185: LIST
57186: LIST
57187: LIST
57188: LIST
57189: LIST
57190: LIST
57191: PPUSH
57192: CALL_OW 72
57196: ST_TO_ADDR
// if not tmp then
57197: LD_VAR 0 4
57201: NOT
57202: IFFALSE 57206
// exit ;
57204: GO 60596
// for i in tmp do
57206: LD_ADDR_VAR 0 3
57210: PUSH
57211: LD_VAR 0 4
57215: PUSH
57216: FOR_IN
57217: IFFALSE 57248
// if GetTag ( i ) then
57219: LD_VAR 0 3
57223: PPUSH
57224: CALL_OW 110
57228: IFFALSE 57246
// tmp := tmp diff i ;
57230: LD_ADDR_VAR 0 4
57234: PUSH
57235: LD_VAR 0 4
57239: PUSH
57240: LD_VAR 0 3
57244: DIFF
57245: ST_TO_ADDR
57246: GO 57216
57248: POP
57249: POP
// if not tmp then
57250: LD_VAR 0 4
57254: NOT
57255: IFFALSE 57259
// exit ;
57257: GO 60596
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57259: LD_ADDR_VAR 0 5
57263: PUSH
57264: LD_EXP 23
57268: PUSH
57269: LD_VAR 0 1
57273: ARRAY
57274: PPUSH
57275: LD_INT 2
57277: PUSH
57278: LD_INT 25
57280: PUSH
57281: LD_INT 1
57283: PUSH
57284: EMPTY
57285: LIST
57286: LIST
57287: PUSH
57288: LD_INT 25
57290: PUSH
57291: LD_INT 5
57293: PUSH
57294: EMPTY
57295: LIST
57296: LIST
57297: PUSH
57298: LD_INT 25
57300: PUSH
57301: LD_INT 8
57303: PUSH
57304: EMPTY
57305: LIST
57306: LIST
57307: PUSH
57308: LD_INT 25
57310: PUSH
57311: LD_INT 9
57313: PUSH
57314: EMPTY
57315: LIST
57316: LIST
57317: PUSH
57318: EMPTY
57319: LIST
57320: LIST
57321: LIST
57322: LIST
57323: LIST
57324: PPUSH
57325: CALL_OW 72
57329: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57330: LD_ADDR_VAR 0 6
57334: PUSH
57335: LD_EXP 23
57339: PUSH
57340: LD_VAR 0 1
57344: ARRAY
57345: PPUSH
57346: LD_INT 25
57348: PUSH
57349: LD_INT 2
57351: PUSH
57352: EMPTY
57353: LIST
57354: LIST
57355: PPUSH
57356: CALL_OW 72
57360: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57361: LD_ADDR_VAR 0 7
57365: PUSH
57366: LD_EXP 23
57370: PUSH
57371: LD_VAR 0 1
57375: ARRAY
57376: PPUSH
57377: LD_INT 25
57379: PUSH
57380: LD_INT 3
57382: PUSH
57383: EMPTY
57384: LIST
57385: LIST
57386: PPUSH
57387: CALL_OW 72
57391: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57392: LD_ADDR_VAR 0 8
57396: PUSH
57397: LD_EXP 23
57401: PUSH
57402: LD_VAR 0 1
57406: ARRAY
57407: PPUSH
57408: LD_INT 25
57410: PUSH
57411: LD_INT 4
57413: PUSH
57414: EMPTY
57415: LIST
57416: LIST
57417: PUSH
57418: LD_INT 24
57420: PUSH
57421: LD_INT 251
57423: PUSH
57424: EMPTY
57425: LIST
57426: LIST
57427: PUSH
57428: EMPTY
57429: LIST
57430: LIST
57431: PPUSH
57432: CALL_OW 72
57436: ST_TO_ADDR
// if mc_is_defending [ base ] then
57437: LD_EXP 66
57441: PUSH
57442: LD_VAR 0 1
57446: ARRAY
57447: IFFALSE 57908
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57449: LD_ADDR_EXP 65
57453: PUSH
57454: LD_EXP 65
57458: PPUSH
57459: LD_VAR 0 1
57463: PPUSH
57464: LD_INT 4
57466: PPUSH
57467: CALL_OW 1
57471: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57472: LD_ADDR_VAR 0 12
57476: PUSH
57477: LD_EXP 23
57481: PUSH
57482: LD_VAR 0 1
57486: ARRAY
57487: PPUSH
57488: LD_INT 2
57490: PUSH
57491: LD_INT 30
57493: PUSH
57494: LD_INT 4
57496: PUSH
57497: EMPTY
57498: LIST
57499: LIST
57500: PUSH
57501: LD_INT 30
57503: PUSH
57504: LD_INT 5
57506: PUSH
57507: EMPTY
57508: LIST
57509: LIST
57510: PUSH
57511: EMPTY
57512: LIST
57513: LIST
57514: LIST
57515: PPUSH
57516: CALL_OW 72
57520: ST_TO_ADDR
// if not b then
57521: LD_VAR 0 12
57525: NOT
57526: IFFALSE 57530
// exit ;
57528: GO 60596
// p := [ ] ;
57530: LD_ADDR_VAR 0 11
57534: PUSH
57535: EMPTY
57536: ST_TO_ADDR
// if sci >= 2 then
57537: LD_VAR 0 8
57541: PUSH
57542: LD_INT 2
57544: GREATEREQUAL
57545: IFFALSE 57576
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57547: LD_ADDR_VAR 0 8
57551: PUSH
57552: LD_VAR 0 8
57556: PUSH
57557: LD_INT 1
57559: ARRAY
57560: PUSH
57561: LD_VAR 0 8
57565: PUSH
57566: LD_INT 2
57568: ARRAY
57569: PUSH
57570: EMPTY
57571: LIST
57572: LIST
57573: ST_TO_ADDR
57574: GO 57637
// if sci = 1 then
57576: LD_VAR 0 8
57580: PUSH
57581: LD_INT 1
57583: EQUAL
57584: IFFALSE 57605
// sci := [ sci [ 1 ] ] else
57586: LD_ADDR_VAR 0 8
57590: PUSH
57591: LD_VAR 0 8
57595: PUSH
57596: LD_INT 1
57598: ARRAY
57599: PUSH
57600: EMPTY
57601: LIST
57602: ST_TO_ADDR
57603: GO 57637
// if sci = 0 then
57605: LD_VAR 0 8
57609: PUSH
57610: LD_INT 0
57612: EQUAL
57613: IFFALSE 57637
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57615: LD_ADDR_VAR 0 11
57619: PUSH
57620: LD_VAR 0 4
57624: PPUSH
57625: LD_INT 4
57627: PPUSH
57628: CALL 46973 0 2
57632: PUSH
57633: LD_INT 1
57635: ARRAY
57636: ST_TO_ADDR
// if eng > 4 then
57637: LD_VAR 0 6
57641: PUSH
57642: LD_INT 4
57644: GREATER
57645: IFFALSE 57691
// for i = eng downto 4 do
57647: LD_ADDR_VAR 0 3
57651: PUSH
57652: DOUBLE
57653: LD_VAR 0 6
57657: INC
57658: ST_TO_ADDR
57659: LD_INT 4
57661: PUSH
57662: FOR_DOWNTO
57663: IFFALSE 57689
// eng := eng diff eng [ i ] ;
57665: LD_ADDR_VAR 0 6
57669: PUSH
57670: LD_VAR 0 6
57674: PUSH
57675: LD_VAR 0 6
57679: PUSH
57680: LD_VAR 0 3
57684: ARRAY
57685: DIFF
57686: ST_TO_ADDR
57687: GO 57662
57689: POP
57690: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57691: LD_ADDR_VAR 0 4
57695: PUSH
57696: LD_VAR 0 4
57700: PUSH
57701: LD_VAR 0 5
57705: PUSH
57706: LD_VAR 0 6
57710: UNION
57711: PUSH
57712: LD_VAR 0 7
57716: UNION
57717: PUSH
57718: LD_VAR 0 8
57722: UNION
57723: DIFF
57724: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57725: LD_ADDR_VAR 0 13
57729: PUSH
57730: LD_EXP 23
57734: PUSH
57735: LD_VAR 0 1
57739: ARRAY
57740: PPUSH
57741: LD_INT 2
57743: PUSH
57744: LD_INT 30
57746: PUSH
57747: LD_INT 32
57749: PUSH
57750: EMPTY
57751: LIST
57752: LIST
57753: PUSH
57754: LD_INT 30
57756: PUSH
57757: LD_INT 31
57759: PUSH
57760: EMPTY
57761: LIST
57762: LIST
57763: PUSH
57764: EMPTY
57765: LIST
57766: LIST
57767: LIST
57768: PPUSH
57769: CALL_OW 72
57773: PUSH
57774: LD_EXP 23
57778: PUSH
57779: LD_VAR 0 1
57783: ARRAY
57784: PPUSH
57785: LD_INT 2
57787: PUSH
57788: LD_INT 30
57790: PUSH
57791: LD_INT 4
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: PUSH
57798: LD_INT 30
57800: PUSH
57801: LD_INT 5
57803: PUSH
57804: EMPTY
57805: LIST
57806: LIST
57807: PUSH
57808: EMPTY
57809: LIST
57810: LIST
57811: LIST
57812: PPUSH
57813: CALL_OW 72
57817: PUSH
57818: LD_INT 6
57820: MUL
57821: PLUS
57822: ST_TO_ADDR
// if bcount < tmp then
57823: LD_VAR 0 13
57827: PUSH
57828: LD_VAR 0 4
57832: LESS
57833: IFFALSE 57879
// for i = tmp downto bcount do
57835: LD_ADDR_VAR 0 3
57839: PUSH
57840: DOUBLE
57841: LD_VAR 0 4
57845: INC
57846: ST_TO_ADDR
57847: LD_VAR 0 13
57851: PUSH
57852: FOR_DOWNTO
57853: IFFALSE 57877
// tmp := Delete ( tmp , tmp ) ;
57855: LD_ADDR_VAR 0 4
57859: PUSH
57860: LD_VAR 0 4
57864: PPUSH
57865: LD_VAR 0 4
57869: PPUSH
57870: CALL_OW 3
57874: ST_TO_ADDR
57875: GO 57852
57877: POP
57878: POP
// result := [ tmp , 0 , 0 , p ] ;
57879: LD_ADDR_VAR 0 2
57883: PUSH
57884: LD_VAR 0 4
57888: PUSH
57889: LD_INT 0
57891: PUSH
57892: LD_INT 0
57894: PUSH
57895: LD_VAR 0 11
57899: PUSH
57900: EMPTY
57901: LIST
57902: LIST
57903: LIST
57904: LIST
57905: ST_TO_ADDR
// exit ;
57906: GO 60596
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57908: LD_EXP 23
57912: PUSH
57913: LD_VAR 0 1
57917: ARRAY
57918: PPUSH
57919: LD_INT 2
57921: PUSH
57922: LD_INT 30
57924: PUSH
57925: LD_INT 6
57927: PUSH
57928: EMPTY
57929: LIST
57930: LIST
57931: PUSH
57932: LD_INT 30
57934: PUSH
57935: LD_INT 7
57937: PUSH
57938: EMPTY
57939: LIST
57940: LIST
57941: PUSH
57942: LD_INT 30
57944: PUSH
57945: LD_INT 8
57947: PUSH
57948: EMPTY
57949: LIST
57950: LIST
57951: PUSH
57952: EMPTY
57953: LIST
57954: LIST
57955: LIST
57956: LIST
57957: PPUSH
57958: CALL_OW 72
57962: NOT
57963: PUSH
57964: LD_EXP 23
57968: PUSH
57969: LD_VAR 0 1
57973: ARRAY
57974: PPUSH
57975: LD_INT 30
57977: PUSH
57978: LD_INT 3
57980: PUSH
57981: EMPTY
57982: LIST
57983: LIST
57984: PPUSH
57985: CALL_OW 72
57989: NOT
57990: AND
57991: IFFALSE 58063
// begin if eng = tmp then
57993: LD_VAR 0 6
57997: PUSH
57998: LD_VAR 0 4
58002: EQUAL
58003: IFFALSE 58007
// exit ;
58005: GO 60596
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58007: LD_ADDR_EXP 65
58011: PUSH
58012: LD_EXP 65
58016: PPUSH
58017: LD_VAR 0 1
58021: PPUSH
58022: LD_INT 1
58024: PPUSH
58025: CALL_OW 1
58029: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58030: LD_ADDR_VAR 0 2
58034: PUSH
58035: LD_INT 0
58037: PUSH
58038: LD_VAR 0 4
58042: PUSH
58043: LD_VAR 0 6
58047: DIFF
58048: PUSH
58049: LD_INT 0
58051: PUSH
58052: LD_INT 0
58054: PUSH
58055: EMPTY
58056: LIST
58057: LIST
58058: LIST
58059: LIST
58060: ST_TO_ADDR
// exit ;
58061: GO 60596
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58063: LD_EXP 50
58067: PUSH
58068: LD_EXP 49
58072: PUSH
58073: LD_VAR 0 1
58077: ARRAY
58078: ARRAY
58079: PUSH
58080: LD_EXP 23
58084: PUSH
58085: LD_VAR 0 1
58089: ARRAY
58090: PPUSH
58091: LD_INT 2
58093: PUSH
58094: LD_INT 30
58096: PUSH
58097: LD_INT 6
58099: PUSH
58100: EMPTY
58101: LIST
58102: LIST
58103: PUSH
58104: LD_INT 30
58106: PUSH
58107: LD_INT 7
58109: PUSH
58110: EMPTY
58111: LIST
58112: LIST
58113: PUSH
58114: LD_INT 30
58116: PUSH
58117: LD_INT 8
58119: PUSH
58120: EMPTY
58121: LIST
58122: LIST
58123: PUSH
58124: EMPTY
58125: LIST
58126: LIST
58127: LIST
58128: LIST
58129: PPUSH
58130: CALL_OW 72
58134: AND
58135: PUSH
58136: LD_EXP 23
58140: PUSH
58141: LD_VAR 0 1
58145: ARRAY
58146: PPUSH
58147: LD_INT 30
58149: PUSH
58150: LD_INT 3
58152: PUSH
58153: EMPTY
58154: LIST
58155: LIST
58156: PPUSH
58157: CALL_OW 72
58161: NOT
58162: AND
58163: IFFALSE 58377
// begin if sci >= 6 then
58165: LD_VAR 0 8
58169: PUSH
58170: LD_INT 6
58172: GREATEREQUAL
58173: IFFALSE 58177
// exit ;
58175: GO 60596
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58177: LD_ADDR_EXP 65
58181: PUSH
58182: LD_EXP 65
58186: PPUSH
58187: LD_VAR 0 1
58191: PPUSH
58192: LD_INT 2
58194: PPUSH
58195: CALL_OW 1
58199: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58200: LD_ADDR_VAR 0 9
58204: PUSH
58205: LD_VAR 0 4
58209: PUSH
58210: LD_VAR 0 8
58214: DIFF
58215: PPUSH
58216: LD_INT 4
58218: PPUSH
58219: CALL 46973 0 2
58223: ST_TO_ADDR
// p := [ ] ;
58224: LD_ADDR_VAR 0 11
58228: PUSH
58229: EMPTY
58230: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58231: LD_VAR 0 8
58235: PUSH
58236: LD_INT 6
58238: LESS
58239: PUSH
58240: LD_VAR 0 9
58244: PUSH
58245: LD_INT 6
58247: GREATER
58248: AND
58249: IFFALSE 58330
// begin for i = 1 to 6 - sci do
58251: LD_ADDR_VAR 0 3
58255: PUSH
58256: DOUBLE
58257: LD_INT 1
58259: DEC
58260: ST_TO_ADDR
58261: LD_INT 6
58263: PUSH
58264: LD_VAR 0 8
58268: MINUS
58269: PUSH
58270: FOR_TO
58271: IFFALSE 58326
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58273: LD_ADDR_VAR 0 11
58277: PUSH
58278: LD_VAR 0 11
58282: PPUSH
58283: LD_VAR 0 11
58287: PUSH
58288: LD_INT 1
58290: PLUS
58291: PPUSH
58292: LD_VAR 0 9
58296: PUSH
58297: LD_INT 1
58299: ARRAY
58300: PPUSH
58301: CALL_OW 2
58305: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58306: LD_ADDR_VAR 0 9
58310: PUSH
58311: LD_VAR 0 9
58315: PPUSH
58316: LD_INT 1
58318: PPUSH
58319: CALL_OW 3
58323: ST_TO_ADDR
// end ;
58324: GO 58270
58326: POP
58327: POP
// end else
58328: GO 58350
// if sort then
58330: LD_VAR 0 9
58334: IFFALSE 58350
// p := sort [ 1 ] ;
58336: LD_ADDR_VAR 0 11
58340: PUSH
58341: LD_VAR 0 9
58345: PUSH
58346: LD_INT 1
58348: ARRAY
58349: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58350: LD_ADDR_VAR 0 2
58354: PUSH
58355: LD_INT 0
58357: PUSH
58358: LD_INT 0
58360: PUSH
58361: LD_INT 0
58363: PUSH
58364: LD_VAR 0 11
58368: PUSH
58369: EMPTY
58370: LIST
58371: LIST
58372: LIST
58373: LIST
58374: ST_TO_ADDR
// exit ;
58375: GO 60596
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58377: LD_EXP 50
58381: PUSH
58382: LD_EXP 49
58386: PUSH
58387: LD_VAR 0 1
58391: ARRAY
58392: ARRAY
58393: PUSH
58394: LD_EXP 23
58398: PUSH
58399: LD_VAR 0 1
58403: ARRAY
58404: PPUSH
58405: LD_INT 2
58407: PUSH
58408: LD_INT 30
58410: PUSH
58411: LD_INT 6
58413: PUSH
58414: EMPTY
58415: LIST
58416: LIST
58417: PUSH
58418: LD_INT 30
58420: PUSH
58421: LD_INT 7
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: PUSH
58428: LD_INT 30
58430: PUSH
58431: LD_INT 8
58433: PUSH
58434: EMPTY
58435: LIST
58436: LIST
58437: PUSH
58438: EMPTY
58439: LIST
58440: LIST
58441: LIST
58442: LIST
58443: PPUSH
58444: CALL_OW 72
58448: AND
58449: PUSH
58450: LD_EXP 23
58454: PUSH
58455: LD_VAR 0 1
58459: ARRAY
58460: PPUSH
58461: LD_INT 30
58463: PUSH
58464: LD_INT 3
58466: PUSH
58467: EMPTY
58468: LIST
58469: LIST
58470: PPUSH
58471: CALL_OW 72
58475: AND
58476: IFFALSE 59210
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58478: LD_ADDR_EXP 65
58482: PUSH
58483: LD_EXP 65
58487: PPUSH
58488: LD_VAR 0 1
58492: PPUSH
58493: LD_INT 3
58495: PPUSH
58496: CALL_OW 1
58500: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58501: LD_ADDR_VAR 0 2
58505: PUSH
58506: LD_INT 0
58508: PUSH
58509: LD_INT 0
58511: PUSH
58512: LD_INT 0
58514: PUSH
58515: LD_INT 0
58517: PUSH
58518: EMPTY
58519: LIST
58520: LIST
58521: LIST
58522: LIST
58523: ST_TO_ADDR
// if not eng then
58524: LD_VAR 0 6
58528: NOT
58529: IFFALSE 58592
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58531: LD_ADDR_VAR 0 11
58535: PUSH
58536: LD_VAR 0 4
58540: PPUSH
58541: LD_INT 2
58543: PPUSH
58544: CALL 46973 0 2
58548: PUSH
58549: LD_INT 1
58551: ARRAY
58552: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58553: LD_ADDR_VAR 0 2
58557: PUSH
58558: LD_VAR 0 2
58562: PPUSH
58563: LD_INT 2
58565: PPUSH
58566: LD_VAR 0 11
58570: PPUSH
58571: CALL_OW 1
58575: ST_TO_ADDR
// tmp := tmp diff p ;
58576: LD_ADDR_VAR 0 4
58580: PUSH
58581: LD_VAR 0 4
58585: PUSH
58586: LD_VAR 0 11
58590: DIFF
58591: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58592: LD_VAR 0 4
58596: PUSH
58597: LD_VAR 0 8
58601: PUSH
58602: LD_INT 6
58604: LESS
58605: AND
58606: IFFALSE 58794
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58608: LD_ADDR_VAR 0 9
58612: PUSH
58613: LD_VAR 0 4
58617: PUSH
58618: LD_VAR 0 8
58622: PUSH
58623: LD_VAR 0 7
58627: UNION
58628: DIFF
58629: PPUSH
58630: LD_INT 4
58632: PPUSH
58633: CALL 46973 0 2
58637: ST_TO_ADDR
// p := [ ] ;
58638: LD_ADDR_VAR 0 11
58642: PUSH
58643: EMPTY
58644: ST_TO_ADDR
// if sort then
58645: LD_VAR 0 9
58649: IFFALSE 58765
// for i = 1 to 6 - sci do
58651: LD_ADDR_VAR 0 3
58655: PUSH
58656: DOUBLE
58657: LD_INT 1
58659: DEC
58660: ST_TO_ADDR
58661: LD_INT 6
58663: PUSH
58664: LD_VAR 0 8
58668: MINUS
58669: PUSH
58670: FOR_TO
58671: IFFALSE 58763
// begin if i = sort then
58673: LD_VAR 0 3
58677: PUSH
58678: LD_VAR 0 9
58682: EQUAL
58683: IFFALSE 58687
// break ;
58685: GO 58763
// if GetClass ( i ) = 4 then
58687: LD_VAR 0 3
58691: PPUSH
58692: CALL_OW 257
58696: PUSH
58697: LD_INT 4
58699: EQUAL
58700: IFFALSE 58704
// continue ;
58702: GO 58670
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58704: LD_ADDR_VAR 0 11
58708: PUSH
58709: LD_VAR 0 11
58713: PPUSH
58714: LD_VAR 0 11
58718: PUSH
58719: LD_INT 1
58721: PLUS
58722: PPUSH
58723: LD_VAR 0 9
58727: PUSH
58728: LD_VAR 0 3
58732: ARRAY
58733: PPUSH
58734: CALL_OW 2
58738: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58739: LD_ADDR_VAR 0 4
58743: PUSH
58744: LD_VAR 0 4
58748: PUSH
58749: LD_VAR 0 9
58753: PUSH
58754: LD_VAR 0 3
58758: ARRAY
58759: DIFF
58760: ST_TO_ADDR
// end ;
58761: GO 58670
58763: POP
58764: POP
// if p then
58765: LD_VAR 0 11
58769: IFFALSE 58794
// result := Replace ( result , 4 , p ) ;
58771: LD_ADDR_VAR 0 2
58775: PUSH
58776: LD_VAR 0 2
58780: PPUSH
58781: LD_INT 4
58783: PPUSH
58784: LD_VAR 0 11
58788: PPUSH
58789: CALL_OW 1
58793: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58794: LD_VAR 0 4
58798: PUSH
58799: LD_VAR 0 7
58803: PUSH
58804: LD_INT 6
58806: LESS
58807: AND
58808: IFFALSE 58996
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58810: LD_ADDR_VAR 0 9
58814: PUSH
58815: LD_VAR 0 4
58819: PUSH
58820: LD_VAR 0 8
58824: PUSH
58825: LD_VAR 0 7
58829: UNION
58830: DIFF
58831: PPUSH
58832: LD_INT 3
58834: PPUSH
58835: CALL 46973 0 2
58839: ST_TO_ADDR
// p := [ ] ;
58840: LD_ADDR_VAR 0 11
58844: PUSH
58845: EMPTY
58846: ST_TO_ADDR
// if sort then
58847: LD_VAR 0 9
58851: IFFALSE 58967
// for i = 1 to 6 - mech do
58853: LD_ADDR_VAR 0 3
58857: PUSH
58858: DOUBLE
58859: LD_INT 1
58861: DEC
58862: ST_TO_ADDR
58863: LD_INT 6
58865: PUSH
58866: LD_VAR 0 7
58870: MINUS
58871: PUSH
58872: FOR_TO
58873: IFFALSE 58965
// begin if i = sort then
58875: LD_VAR 0 3
58879: PUSH
58880: LD_VAR 0 9
58884: EQUAL
58885: IFFALSE 58889
// break ;
58887: GO 58965
// if GetClass ( i ) = 3 then
58889: LD_VAR 0 3
58893: PPUSH
58894: CALL_OW 257
58898: PUSH
58899: LD_INT 3
58901: EQUAL
58902: IFFALSE 58906
// continue ;
58904: GO 58872
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58906: LD_ADDR_VAR 0 11
58910: PUSH
58911: LD_VAR 0 11
58915: PPUSH
58916: LD_VAR 0 11
58920: PUSH
58921: LD_INT 1
58923: PLUS
58924: PPUSH
58925: LD_VAR 0 9
58929: PUSH
58930: LD_VAR 0 3
58934: ARRAY
58935: PPUSH
58936: CALL_OW 2
58940: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58941: LD_ADDR_VAR 0 4
58945: PUSH
58946: LD_VAR 0 4
58950: PUSH
58951: LD_VAR 0 9
58955: PUSH
58956: LD_VAR 0 3
58960: ARRAY
58961: DIFF
58962: ST_TO_ADDR
// end ;
58963: GO 58872
58965: POP
58966: POP
// if p then
58967: LD_VAR 0 11
58971: IFFALSE 58996
// result := Replace ( result , 3 , p ) ;
58973: LD_ADDR_VAR 0 2
58977: PUSH
58978: LD_VAR 0 2
58982: PPUSH
58983: LD_INT 3
58985: PPUSH
58986: LD_VAR 0 11
58990: PPUSH
58991: CALL_OW 1
58995: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58996: LD_VAR 0 4
59000: PUSH
59001: LD_INT 6
59003: GREATER
59004: PUSH
59005: LD_VAR 0 6
59009: PUSH
59010: LD_INT 6
59012: LESS
59013: AND
59014: IFFALSE 59208
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59016: LD_ADDR_VAR 0 9
59020: PUSH
59021: LD_VAR 0 4
59025: PUSH
59026: LD_VAR 0 8
59030: PUSH
59031: LD_VAR 0 7
59035: UNION
59036: PUSH
59037: LD_VAR 0 6
59041: UNION
59042: DIFF
59043: PPUSH
59044: LD_INT 2
59046: PPUSH
59047: CALL 46973 0 2
59051: ST_TO_ADDR
// p := [ ] ;
59052: LD_ADDR_VAR 0 11
59056: PUSH
59057: EMPTY
59058: ST_TO_ADDR
// if sort then
59059: LD_VAR 0 9
59063: IFFALSE 59179
// for i = 1 to 6 - eng do
59065: LD_ADDR_VAR 0 3
59069: PUSH
59070: DOUBLE
59071: LD_INT 1
59073: DEC
59074: ST_TO_ADDR
59075: LD_INT 6
59077: PUSH
59078: LD_VAR 0 6
59082: MINUS
59083: PUSH
59084: FOR_TO
59085: IFFALSE 59177
// begin if i = sort then
59087: LD_VAR 0 3
59091: PUSH
59092: LD_VAR 0 9
59096: EQUAL
59097: IFFALSE 59101
// break ;
59099: GO 59177
// if GetClass ( i ) = 2 then
59101: LD_VAR 0 3
59105: PPUSH
59106: CALL_OW 257
59110: PUSH
59111: LD_INT 2
59113: EQUAL
59114: IFFALSE 59118
// continue ;
59116: GO 59084
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59118: LD_ADDR_VAR 0 11
59122: PUSH
59123: LD_VAR 0 11
59127: PPUSH
59128: LD_VAR 0 11
59132: PUSH
59133: LD_INT 1
59135: PLUS
59136: PPUSH
59137: LD_VAR 0 9
59141: PUSH
59142: LD_VAR 0 3
59146: ARRAY
59147: PPUSH
59148: CALL_OW 2
59152: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59153: LD_ADDR_VAR 0 4
59157: PUSH
59158: LD_VAR 0 4
59162: PUSH
59163: LD_VAR 0 9
59167: PUSH
59168: LD_VAR 0 3
59172: ARRAY
59173: DIFF
59174: ST_TO_ADDR
// end ;
59175: GO 59084
59177: POP
59178: POP
// if p then
59179: LD_VAR 0 11
59183: IFFALSE 59208
// result := Replace ( result , 2 , p ) ;
59185: LD_ADDR_VAR 0 2
59189: PUSH
59190: LD_VAR 0 2
59194: PPUSH
59195: LD_INT 2
59197: PPUSH
59198: LD_VAR 0 11
59202: PPUSH
59203: CALL_OW 1
59207: ST_TO_ADDR
// end ; exit ;
59208: GO 60596
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59210: LD_EXP 50
59214: PUSH
59215: LD_EXP 49
59219: PUSH
59220: LD_VAR 0 1
59224: ARRAY
59225: ARRAY
59226: NOT
59227: PUSH
59228: LD_EXP 23
59232: PUSH
59233: LD_VAR 0 1
59237: ARRAY
59238: PPUSH
59239: LD_INT 30
59241: PUSH
59242: LD_INT 3
59244: PUSH
59245: EMPTY
59246: LIST
59247: LIST
59248: PPUSH
59249: CALL_OW 72
59253: AND
59254: PUSH
59255: LD_EXP 28
59259: PUSH
59260: LD_VAR 0 1
59264: ARRAY
59265: AND
59266: IFFALSE 59874
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59268: LD_ADDR_EXP 65
59272: PUSH
59273: LD_EXP 65
59277: PPUSH
59278: LD_VAR 0 1
59282: PPUSH
59283: LD_INT 5
59285: PPUSH
59286: CALL_OW 1
59290: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59291: LD_ADDR_VAR 0 2
59295: PUSH
59296: LD_INT 0
59298: PUSH
59299: LD_INT 0
59301: PUSH
59302: LD_INT 0
59304: PUSH
59305: LD_INT 0
59307: PUSH
59308: EMPTY
59309: LIST
59310: LIST
59311: LIST
59312: LIST
59313: ST_TO_ADDR
// if sci > 1 then
59314: LD_VAR 0 8
59318: PUSH
59319: LD_INT 1
59321: GREATER
59322: IFFALSE 59350
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59324: LD_ADDR_VAR 0 4
59328: PUSH
59329: LD_VAR 0 4
59333: PUSH
59334: LD_VAR 0 8
59338: PUSH
59339: LD_VAR 0 8
59343: PUSH
59344: LD_INT 1
59346: ARRAY
59347: DIFF
59348: DIFF
59349: ST_TO_ADDR
// if tmp and not sci then
59350: LD_VAR 0 4
59354: PUSH
59355: LD_VAR 0 8
59359: NOT
59360: AND
59361: IFFALSE 59430
// begin sort := SortBySkill ( tmp , 4 ) ;
59363: LD_ADDR_VAR 0 9
59367: PUSH
59368: LD_VAR 0 4
59372: PPUSH
59373: LD_INT 4
59375: PPUSH
59376: CALL 46973 0 2
59380: ST_TO_ADDR
// if sort then
59381: LD_VAR 0 9
59385: IFFALSE 59401
// p := sort [ 1 ] ;
59387: LD_ADDR_VAR 0 11
59391: PUSH
59392: LD_VAR 0 9
59396: PUSH
59397: LD_INT 1
59399: ARRAY
59400: ST_TO_ADDR
// if p then
59401: LD_VAR 0 11
59405: IFFALSE 59430
// result := Replace ( result , 4 , p ) ;
59407: LD_ADDR_VAR 0 2
59411: PUSH
59412: LD_VAR 0 2
59416: PPUSH
59417: LD_INT 4
59419: PPUSH
59420: LD_VAR 0 11
59424: PPUSH
59425: CALL_OW 1
59429: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59430: LD_ADDR_VAR 0 4
59434: PUSH
59435: LD_VAR 0 4
59439: PUSH
59440: LD_VAR 0 7
59444: DIFF
59445: ST_TO_ADDR
// if tmp and mech < 6 then
59446: LD_VAR 0 4
59450: PUSH
59451: LD_VAR 0 7
59455: PUSH
59456: LD_INT 6
59458: LESS
59459: AND
59460: IFFALSE 59648
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59462: LD_ADDR_VAR 0 9
59466: PUSH
59467: LD_VAR 0 4
59471: PUSH
59472: LD_VAR 0 8
59476: PUSH
59477: LD_VAR 0 7
59481: UNION
59482: DIFF
59483: PPUSH
59484: LD_INT 3
59486: PPUSH
59487: CALL 46973 0 2
59491: ST_TO_ADDR
// p := [ ] ;
59492: LD_ADDR_VAR 0 11
59496: PUSH
59497: EMPTY
59498: ST_TO_ADDR
// if sort then
59499: LD_VAR 0 9
59503: IFFALSE 59619
// for i = 1 to 6 - mech do
59505: LD_ADDR_VAR 0 3
59509: PUSH
59510: DOUBLE
59511: LD_INT 1
59513: DEC
59514: ST_TO_ADDR
59515: LD_INT 6
59517: PUSH
59518: LD_VAR 0 7
59522: MINUS
59523: PUSH
59524: FOR_TO
59525: IFFALSE 59617
// begin if i = sort then
59527: LD_VAR 0 3
59531: PUSH
59532: LD_VAR 0 9
59536: EQUAL
59537: IFFALSE 59541
// break ;
59539: GO 59617
// if GetClass ( i ) = 3 then
59541: LD_VAR 0 3
59545: PPUSH
59546: CALL_OW 257
59550: PUSH
59551: LD_INT 3
59553: EQUAL
59554: IFFALSE 59558
// continue ;
59556: GO 59524
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59558: LD_ADDR_VAR 0 11
59562: PUSH
59563: LD_VAR 0 11
59567: PPUSH
59568: LD_VAR 0 11
59572: PUSH
59573: LD_INT 1
59575: PLUS
59576: PPUSH
59577: LD_VAR 0 9
59581: PUSH
59582: LD_VAR 0 3
59586: ARRAY
59587: PPUSH
59588: CALL_OW 2
59592: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59593: LD_ADDR_VAR 0 4
59597: PUSH
59598: LD_VAR 0 4
59602: PUSH
59603: LD_VAR 0 9
59607: PUSH
59608: LD_VAR 0 3
59612: ARRAY
59613: DIFF
59614: ST_TO_ADDR
// end ;
59615: GO 59524
59617: POP
59618: POP
// if p then
59619: LD_VAR 0 11
59623: IFFALSE 59648
// result := Replace ( result , 3 , p ) ;
59625: LD_ADDR_VAR 0 2
59629: PUSH
59630: LD_VAR 0 2
59634: PPUSH
59635: LD_INT 3
59637: PPUSH
59638: LD_VAR 0 11
59642: PPUSH
59643: CALL_OW 1
59647: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59648: LD_ADDR_VAR 0 4
59652: PUSH
59653: LD_VAR 0 4
59657: PUSH
59658: LD_VAR 0 6
59662: DIFF
59663: ST_TO_ADDR
// if tmp and eng < 6 then
59664: LD_VAR 0 4
59668: PUSH
59669: LD_VAR 0 6
59673: PUSH
59674: LD_INT 6
59676: LESS
59677: AND
59678: IFFALSE 59872
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59680: LD_ADDR_VAR 0 9
59684: PUSH
59685: LD_VAR 0 4
59689: PUSH
59690: LD_VAR 0 8
59694: PUSH
59695: LD_VAR 0 7
59699: UNION
59700: PUSH
59701: LD_VAR 0 6
59705: UNION
59706: DIFF
59707: PPUSH
59708: LD_INT 2
59710: PPUSH
59711: CALL 46973 0 2
59715: ST_TO_ADDR
// p := [ ] ;
59716: LD_ADDR_VAR 0 11
59720: PUSH
59721: EMPTY
59722: ST_TO_ADDR
// if sort then
59723: LD_VAR 0 9
59727: IFFALSE 59843
// for i = 1 to 6 - eng do
59729: LD_ADDR_VAR 0 3
59733: PUSH
59734: DOUBLE
59735: LD_INT 1
59737: DEC
59738: ST_TO_ADDR
59739: LD_INT 6
59741: PUSH
59742: LD_VAR 0 6
59746: MINUS
59747: PUSH
59748: FOR_TO
59749: IFFALSE 59841
// begin if i = sort then
59751: LD_VAR 0 3
59755: PUSH
59756: LD_VAR 0 9
59760: EQUAL
59761: IFFALSE 59765
// break ;
59763: GO 59841
// if GetClass ( i ) = 2 then
59765: LD_VAR 0 3
59769: PPUSH
59770: CALL_OW 257
59774: PUSH
59775: LD_INT 2
59777: EQUAL
59778: IFFALSE 59782
// continue ;
59780: GO 59748
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59782: LD_ADDR_VAR 0 11
59786: PUSH
59787: LD_VAR 0 11
59791: PPUSH
59792: LD_VAR 0 11
59796: PUSH
59797: LD_INT 1
59799: PLUS
59800: PPUSH
59801: LD_VAR 0 9
59805: PUSH
59806: LD_VAR 0 3
59810: ARRAY
59811: PPUSH
59812: CALL_OW 2
59816: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59817: LD_ADDR_VAR 0 4
59821: PUSH
59822: LD_VAR 0 4
59826: PUSH
59827: LD_VAR 0 9
59831: PUSH
59832: LD_VAR 0 3
59836: ARRAY
59837: DIFF
59838: ST_TO_ADDR
// end ;
59839: GO 59748
59841: POP
59842: POP
// if p then
59843: LD_VAR 0 11
59847: IFFALSE 59872
// result := Replace ( result , 2 , p ) ;
59849: LD_ADDR_VAR 0 2
59853: PUSH
59854: LD_VAR 0 2
59858: PPUSH
59859: LD_INT 2
59861: PPUSH
59862: LD_VAR 0 11
59866: PPUSH
59867: CALL_OW 1
59871: ST_TO_ADDR
// end ; exit ;
59872: GO 60596
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59874: LD_EXP 50
59878: PUSH
59879: LD_EXP 49
59883: PUSH
59884: LD_VAR 0 1
59888: ARRAY
59889: ARRAY
59890: NOT
59891: PUSH
59892: LD_EXP 23
59896: PUSH
59897: LD_VAR 0 1
59901: ARRAY
59902: PPUSH
59903: LD_INT 30
59905: PUSH
59906: LD_INT 3
59908: PUSH
59909: EMPTY
59910: LIST
59911: LIST
59912: PPUSH
59913: CALL_OW 72
59917: AND
59918: PUSH
59919: LD_EXP 28
59923: PUSH
59924: LD_VAR 0 1
59928: ARRAY
59929: NOT
59930: AND
59931: IFFALSE 60596
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59933: LD_ADDR_EXP 65
59937: PUSH
59938: LD_EXP 65
59942: PPUSH
59943: LD_VAR 0 1
59947: PPUSH
59948: LD_INT 6
59950: PPUSH
59951: CALL_OW 1
59955: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59956: LD_ADDR_VAR 0 2
59960: PUSH
59961: LD_INT 0
59963: PUSH
59964: LD_INT 0
59966: PUSH
59967: LD_INT 0
59969: PUSH
59970: LD_INT 0
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: LIST
59977: LIST
59978: ST_TO_ADDR
// if sci >= 1 then
59979: LD_VAR 0 8
59983: PUSH
59984: LD_INT 1
59986: GREATEREQUAL
59987: IFFALSE 60009
// tmp := tmp diff sci [ 1 ] ;
59989: LD_ADDR_VAR 0 4
59993: PUSH
59994: LD_VAR 0 4
59998: PUSH
59999: LD_VAR 0 8
60003: PUSH
60004: LD_INT 1
60006: ARRAY
60007: DIFF
60008: ST_TO_ADDR
// if tmp and not sci then
60009: LD_VAR 0 4
60013: PUSH
60014: LD_VAR 0 8
60018: NOT
60019: AND
60020: IFFALSE 60089
// begin sort := SortBySkill ( tmp , 4 ) ;
60022: LD_ADDR_VAR 0 9
60026: PUSH
60027: LD_VAR 0 4
60031: PPUSH
60032: LD_INT 4
60034: PPUSH
60035: CALL 46973 0 2
60039: ST_TO_ADDR
// if sort then
60040: LD_VAR 0 9
60044: IFFALSE 60060
// p := sort [ 1 ] ;
60046: LD_ADDR_VAR 0 11
60050: PUSH
60051: LD_VAR 0 9
60055: PUSH
60056: LD_INT 1
60058: ARRAY
60059: ST_TO_ADDR
// if p then
60060: LD_VAR 0 11
60064: IFFALSE 60089
// result := Replace ( result , 4 , p ) ;
60066: LD_ADDR_VAR 0 2
60070: PUSH
60071: LD_VAR 0 2
60075: PPUSH
60076: LD_INT 4
60078: PPUSH
60079: LD_VAR 0 11
60083: PPUSH
60084: CALL_OW 1
60088: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60089: LD_ADDR_VAR 0 4
60093: PUSH
60094: LD_VAR 0 4
60098: PUSH
60099: LD_VAR 0 7
60103: DIFF
60104: ST_TO_ADDR
// if tmp and mech < 6 then
60105: LD_VAR 0 4
60109: PUSH
60110: LD_VAR 0 7
60114: PUSH
60115: LD_INT 6
60117: LESS
60118: AND
60119: IFFALSE 60301
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60121: LD_ADDR_VAR 0 9
60125: PUSH
60126: LD_VAR 0 4
60130: PUSH
60131: LD_VAR 0 7
60135: DIFF
60136: PPUSH
60137: LD_INT 3
60139: PPUSH
60140: CALL 46973 0 2
60144: ST_TO_ADDR
// p := [ ] ;
60145: LD_ADDR_VAR 0 11
60149: PUSH
60150: EMPTY
60151: ST_TO_ADDR
// if sort then
60152: LD_VAR 0 9
60156: IFFALSE 60272
// for i = 1 to 6 - mech do
60158: LD_ADDR_VAR 0 3
60162: PUSH
60163: DOUBLE
60164: LD_INT 1
60166: DEC
60167: ST_TO_ADDR
60168: LD_INT 6
60170: PUSH
60171: LD_VAR 0 7
60175: MINUS
60176: PUSH
60177: FOR_TO
60178: IFFALSE 60270
// begin if i = sort then
60180: LD_VAR 0 3
60184: PUSH
60185: LD_VAR 0 9
60189: EQUAL
60190: IFFALSE 60194
// break ;
60192: GO 60270
// if GetClass ( i ) = 3 then
60194: LD_VAR 0 3
60198: PPUSH
60199: CALL_OW 257
60203: PUSH
60204: LD_INT 3
60206: EQUAL
60207: IFFALSE 60211
// continue ;
60209: GO 60177
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60211: LD_ADDR_VAR 0 11
60215: PUSH
60216: LD_VAR 0 11
60220: PPUSH
60221: LD_VAR 0 11
60225: PUSH
60226: LD_INT 1
60228: PLUS
60229: PPUSH
60230: LD_VAR 0 9
60234: PUSH
60235: LD_VAR 0 3
60239: ARRAY
60240: PPUSH
60241: CALL_OW 2
60245: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60246: LD_ADDR_VAR 0 4
60250: PUSH
60251: LD_VAR 0 4
60255: PUSH
60256: LD_VAR 0 9
60260: PUSH
60261: LD_VAR 0 3
60265: ARRAY
60266: DIFF
60267: ST_TO_ADDR
// end ;
60268: GO 60177
60270: POP
60271: POP
// if p then
60272: LD_VAR 0 11
60276: IFFALSE 60301
// result := Replace ( result , 3 , p ) ;
60278: LD_ADDR_VAR 0 2
60282: PUSH
60283: LD_VAR 0 2
60287: PPUSH
60288: LD_INT 3
60290: PPUSH
60291: LD_VAR 0 11
60295: PPUSH
60296: CALL_OW 1
60300: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60301: LD_ADDR_VAR 0 4
60305: PUSH
60306: LD_VAR 0 4
60310: PUSH
60311: LD_VAR 0 6
60315: DIFF
60316: ST_TO_ADDR
// if tmp and eng < 4 then
60317: LD_VAR 0 4
60321: PUSH
60322: LD_VAR 0 6
60326: PUSH
60327: LD_INT 4
60329: LESS
60330: AND
60331: IFFALSE 60521
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60333: LD_ADDR_VAR 0 9
60337: PUSH
60338: LD_VAR 0 4
60342: PUSH
60343: LD_VAR 0 7
60347: PUSH
60348: LD_VAR 0 6
60352: UNION
60353: DIFF
60354: PPUSH
60355: LD_INT 2
60357: PPUSH
60358: CALL 46973 0 2
60362: ST_TO_ADDR
// p := [ ] ;
60363: LD_ADDR_VAR 0 11
60367: PUSH
60368: EMPTY
60369: ST_TO_ADDR
// if sort then
60370: LD_VAR 0 9
60374: IFFALSE 60490
// for i = 1 to 4 - eng do
60376: LD_ADDR_VAR 0 3
60380: PUSH
60381: DOUBLE
60382: LD_INT 1
60384: DEC
60385: ST_TO_ADDR
60386: LD_INT 4
60388: PUSH
60389: LD_VAR 0 6
60393: MINUS
60394: PUSH
60395: FOR_TO
60396: IFFALSE 60488
// begin if i = sort then
60398: LD_VAR 0 3
60402: PUSH
60403: LD_VAR 0 9
60407: EQUAL
60408: IFFALSE 60412
// break ;
60410: GO 60488
// if GetClass ( i ) = 2 then
60412: LD_VAR 0 3
60416: PPUSH
60417: CALL_OW 257
60421: PUSH
60422: LD_INT 2
60424: EQUAL
60425: IFFALSE 60429
// continue ;
60427: GO 60395
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60429: LD_ADDR_VAR 0 11
60433: PUSH
60434: LD_VAR 0 11
60438: PPUSH
60439: LD_VAR 0 11
60443: PUSH
60444: LD_INT 1
60446: PLUS
60447: PPUSH
60448: LD_VAR 0 9
60452: PUSH
60453: LD_VAR 0 3
60457: ARRAY
60458: PPUSH
60459: CALL_OW 2
60463: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60464: LD_ADDR_VAR 0 4
60468: PUSH
60469: LD_VAR 0 4
60473: PUSH
60474: LD_VAR 0 9
60478: PUSH
60479: LD_VAR 0 3
60483: ARRAY
60484: DIFF
60485: ST_TO_ADDR
// end ;
60486: GO 60395
60488: POP
60489: POP
// if p then
60490: LD_VAR 0 11
60494: IFFALSE 60519
// result := Replace ( result , 2 , p ) ;
60496: LD_ADDR_VAR 0 2
60500: PUSH
60501: LD_VAR 0 2
60505: PPUSH
60506: LD_INT 2
60508: PPUSH
60509: LD_VAR 0 11
60513: PPUSH
60514: CALL_OW 1
60518: ST_TO_ADDR
// end else
60519: GO 60565
// for i = eng downto 5 do
60521: LD_ADDR_VAR 0 3
60525: PUSH
60526: DOUBLE
60527: LD_VAR 0 6
60531: INC
60532: ST_TO_ADDR
60533: LD_INT 5
60535: PUSH
60536: FOR_DOWNTO
60537: IFFALSE 60563
// tmp := tmp union eng [ i ] ;
60539: LD_ADDR_VAR 0 4
60543: PUSH
60544: LD_VAR 0 4
60548: PUSH
60549: LD_VAR 0 6
60553: PUSH
60554: LD_VAR 0 3
60558: ARRAY
60559: UNION
60560: ST_TO_ADDR
60561: GO 60536
60563: POP
60564: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60565: LD_ADDR_VAR 0 2
60569: PUSH
60570: LD_VAR 0 2
60574: PPUSH
60575: LD_INT 1
60577: PPUSH
60578: LD_VAR 0 4
60582: PUSH
60583: LD_VAR 0 5
60587: DIFF
60588: PPUSH
60589: CALL_OW 1
60593: ST_TO_ADDR
// exit ;
60594: GO 60596
// end ; end ;
60596: LD_VAR 0 2
60600: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60601: LD_INT 0
60603: PPUSH
60604: PPUSH
60605: PPUSH
// if not mc_bases then
60606: LD_EXP 23
60610: NOT
60611: IFFALSE 60615
// exit ;
60613: GO 60757
// for i = 1 to mc_bases do
60615: LD_ADDR_VAR 0 2
60619: PUSH
60620: DOUBLE
60621: LD_INT 1
60623: DEC
60624: ST_TO_ADDR
60625: LD_EXP 23
60629: PUSH
60630: FOR_TO
60631: IFFALSE 60748
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60633: LD_ADDR_VAR 0 3
60637: PUSH
60638: LD_EXP 23
60642: PUSH
60643: LD_VAR 0 2
60647: ARRAY
60648: PPUSH
60649: LD_INT 21
60651: PUSH
60652: LD_INT 3
60654: PUSH
60655: EMPTY
60656: LIST
60657: LIST
60658: PUSH
60659: LD_INT 3
60661: PUSH
60662: LD_INT 2
60664: PUSH
60665: LD_INT 30
60667: PUSH
60668: LD_INT 29
60670: PUSH
60671: EMPTY
60672: LIST
60673: LIST
60674: PUSH
60675: LD_INT 30
60677: PUSH
60678: LD_INT 30
60680: PUSH
60681: EMPTY
60682: LIST
60683: LIST
60684: PUSH
60685: EMPTY
60686: LIST
60687: LIST
60688: LIST
60689: PUSH
60690: EMPTY
60691: LIST
60692: LIST
60693: PUSH
60694: LD_INT 3
60696: PUSH
60697: LD_INT 24
60699: PUSH
60700: LD_INT 1000
60702: PUSH
60703: EMPTY
60704: LIST
60705: LIST
60706: PUSH
60707: EMPTY
60708: LIST
60709: LIST
60710: PUSH
60711: EMPTY
60712: LIST
60713: LIST
60714: LIST
60715: PPUSH
60716: CALL_OW 72
60720: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60721: LD_ADDR_EXP 24
60725: PUSH
60726: LD_EXP 24
60730: PPUSH
60731: LD_VAR 0 2
60735: PPUSH
60736: LD_VAR 0 3
60740: PPUSH
60741: CALL_OW 1
60745: ST_TO_ADDR
// end ;
60746: GO 60630
60748: POP
60749: POP
// RaiseSailEvent ( 101 ) ;
60750: LD_INT 101
60752: PPUSH
60753: CALL_OW 427
// end ;
60757: LD_VAR 0 1
60761: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60762: LD_INT 0
60764: PPUSH
60765: PPUSH
60766: PPUSH
60767: PPUSH
60768: PPUSH
60769: PPUSH
60770: PPUSH
// if not mc_bases then
60771: LD_EXP 23
60775: NOT
60776: IFFALSE 60780
// exit ;
60778: GO 61342
// for i = 1 to mc_bases do
60780: LD_ADDR_VAR 0 2
60784: PUSH
60785: DOUBLE
60786: LD_INT 1
60788: DEC
60789: ST_TO_ADDR
60790: LD_EXP 23
60794: PUSH
60795: FOR_TO
60796: IFFALSE 61333
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60798: LD_ADDR_VAR 0 5
60802: PUSH
60803: LD_EXP 23
60807: PUSH
60808: LD_VAR 0 2
60812: ARRAY
60813: PUSH
60814: LD_EXP 52
60818: PUSH
60819: LD_VAR 0 2
60823: ARRAY
60824: UNION
60825: PPUSH
60826: LD_INT 21
60828: PUSH
60829: LD_INT 1
60831: PUSH
60832: EMPTY
60833: LIST
60834: LIST
60835: PUSH
60836: LD_INT 1
60838: PUSH
60839: LD_INT 3
60841: PUSH
60842: LD_INT 54
60844: PUSH
60845: EMPTY
60846: LIST
60847: PUSH
60848: EMPTY
60849: LIST
60850: LIST
60851: PUSH
60852: LD_INT 3
60854: PUSH
60855: LD_INT 24
60857: PUSH
60858: LD_INT 1000
60860: PUSH
60861: EMPTY
60862: LIST
60863: LIST
60864: PUSH
60865: EMPTY
60866: LIST
60867: LIST
60868: PUSH
60869: EMPTY
60870: LIST
60871: LIST
60872: LIST
60873: PUSH
60874: EMPTY
60875: LIST
60876: LIST
60877: PPUSH
60878: CALL_OW 72
60882: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60883: LD_ADDR_VAR 0 6
60887: PUSH
60888: LD_EXP 23
60892: PUSH
60893: LD_VAR 0 2
60897: ARRAY
60898: PPUSH
60899: LD_INT 21
60901: PUSH
60902: LD_INT 1
60904: PUSH
60905: EMPTY
60906: LIST
60907: LIST
60908: PUSH
60909: LD_INT 1
60911: PUSH
60912: LD_INT 3
60914: PUSH
60915: LD_INT 54
60917: PUSH
60918: EMPTY
60919: LIST
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: PUSH
60925: LD_INT 3
60927: PUSH
60928: LD_INT 24
60930: PUSH
60931: LD_INT 250
60933: PUSH
60934: EMPTY
60935: LIST
60936: LIST
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: EMPTY
60943: LIST
60944: LIST
60945: LIST
60946: PUSH
60947: EMPTY
60948: LIST
60949: LIST
60950: PPUSH
60951: CALL_OW 72
60955: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60956: LD_ADDR_VAR 0 7
60960: PUSH
60961: LD_VAR 0 5
60965: PUSH
60966: LD_VAR 0 6
60970: DIFF
60971: ST_TO_ADDR
// if not need_heal_1 then
60972: LD_VAR 0 6
60976: NOT
60977: IFFALSE 61010
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60979: LD_ADDR_EXP 26
60983: PUSH
60984: LD_EXP 26
60988: PPUSH
60989: LD_VAR 0 2
60993: PUSH
60994: LD_INT 1
60996: PUSH
60997: EMPTY
60998: LIST
60999: LIST
61000: PPUSH
61001: EMPTY
61002: PPUSH
61003: CALL 16152 0 3
61007: ST_TO_ADDR
61008: GO 61080
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61010: LD_ADDR_EXP 26
61014: PUSH
61015: LD_EXP 26
61019: PPUSH
61020: LD_VAR 0 2
61024: PUSH
61025: LD_INT 1
61027: PUSH
61028: EMPTY
61029: LIST
61030: LIST
61031: PPUSH
61032: LD_EXP 26
61036: PUSH
61037: LD_VAR 0 2
61041: ARRAY
61042: PUSH
61043: LD_INT 1
61045: ARRAY
61046: PPUSH
61047: LD_INT 3
61049: PUSH
61050: LD_INT 24
61052: PUSH
61053: LD_INT 1000
61055: PUSH
61056: EMPTY
61057: LIST
61058: LIST
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PPUSH
61064: CALL_OW 72
61068: PUSH
61069: LD_VAR 0 6
61073: UNION
61074: PPUSH
61075: CALL 16152 0 3
61079: ST_TO_ADDR
// if not need_heal_2 then
61080: LD_VAR 0 7
61084: NOT
61085: IFFALSE 61118
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61087: LD_ADDR_EXP 26
61091: PUSH
61092: LD_EXP 26
61096: PPUSH
61097: LD_VAR 0 2
61101: PUSH
61102: LD_INT 2
61104: PUSH
61105: EMPTY
61106: LIST
61107: LIST
61108: PPUSH
61109: EMPTY
61110: PPUSH
61111: CALL 16152 0 3
61115: ST_TO_ADDR
61116: GO 61150
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61118: LD_ADDR_EXP 26
61122: PUSH
61123: LD_EXP 26
61127: PPUSH
61128: LD_VAR 0 2
61132: PUSH
61133: LD_INT 2
61135: PUSH
61136: EMPTY
61137: LIST
61138: LIST
61139: PPUSH
61140: LD_VAR 0 7
61144: PPUSH
61145: CALL 16152 0 3
61149: ST_TO_ADDR
// if need_heal_2 then
61150: LD_VAR 0 7
61154: IFFALSE 61315
// for j in need_heal_2 do
61156: LD_ADDR_VAR 0 3
61160: PUSH
61161: LD_VAR 0 7
61165: PUSH
61166: FOR_IN
61167: IFFALSE 61313
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61169: LD_ADDR_VAR 0 5
61173: PUSH
61174: LD_EXP 23
61178: PUSH
61179: LD_VAR 0 2
61183: ARRAY
61184: PPUSH
61185: LD_INT 2
61187: PUSH
61188: LD_INT 30
61190: PUSH
61191: LD_INT 6
61193: PUSH
61194: EMPTY
61195: LIST
61196: LIST
61197: PUSH
61198: LD_INT 30
61200: PUSH
61201: LD_INT 7
61203: PUSH
61204: EMPTY
61205: LIST
61206: LIST
61207: PUSH
61208: LD_INT 30
61210: PUSH
61211: LD_INT 8
61213: PUSH
61214: EMPTY
61215: LIST
61216: LIST
61217: PUSH
61218: LD_INT 30
61220: PUSH
61221: LD_INT 0
61223: PUSH
61224: EMPTY
61225: LIST
61226: LIST
61227: PUSH
61228: LD_INT 30
61230: PUSH
61231: LD_INT 1
61233: PUSH
61234: EMPTY
61235: LIST
61236: LIST
61237: PUSH
61238: EMPTY
61239: LIST
61240: LIST
61241: LIST
61242: LIST
61243: LIST
61244: LIST
61245: PPUSH
61246: CALL_OW 72
61250: ST_TO_ADDR
// if tmp then
61251: LD_VAR 0 5
61255: IFFALSE 61311
// begin k := NearestUnitToUnit ( tmp , j ) ;
61257: LD_ADDR_VAR 0 4
61261: PUSH
61262: LD_VAR 0 5
61266: PPUSH
61267: LD_VAR 0 3
61271: PPUSH
61272: CALL_OW 74
61276: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61277: LD_VAR 0 3
61281: PPUSH
61282: LD_VAR 0 4
61286: PPUSH
61287: CALL_OW 296
61291: PUSH
61292: LD_INT 5
61294: GREATER
61295: IFFALSE 61311
// ComMoveToNearbyEntrance ( j , k ) ;
61297: LD_VAR 0 3
61301: PPUSH
61302: LD_VAR 0 4
61306: PPUSH
61307: CALL 49341 0 2
// end ; end ;
61311: GO 61166
61313: POP
61314: POP
// if not need_heal_1 and not need_heal_2 then
61315: LD_VAR 0 6
61319: NOT
61320: PUSH
61321: LD_VAR 0 7
61325: NOT
61326: AND
61327: IFFALSE 61331
// continue ;
61329: GO 60795
// end ;
61331: GO 60795
61333: POP
61334: POP
// RaiseSailEvent ( 102 ) ;
61335: LD_INT 102
61337: PPUSH
61338: CALL_OW 427
// end ;
61342: LD_VAR 0 1
61346: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61347: LD_INT 0
61349: PPUSH
61350: PPUSH
61351: PPUSH
61352: PPUSH
61353: PPUSH
61354: PPUSH
61355: PPUSH
61356: PPUSH
// if not mc_bases then
61357: LD_EXP 23
61361: NOT
61362: IFFALSE 61366
// exit ;
61364: GO 62277
// for i = 1 to mc_bases do
61366: LD_ADDR_VAR 0 2
61370: PUSH
61371: DOUBLE
61372: LD_INT 1
61374: DEC
61375: ST_TO_ADDR
61376: LD_EXP 23
61380: PUSH
61381: FOR_TO
61382: IFFALSE 62275
// begin if not mc_building_need_repair [ i ] then
61384: LD_EXP 24
61388: PUSH
61389: LD_VAR 0 2
61393: ARRAY
61394: NOT
61395: IFFALSE 61580
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61397: LD_ADDR_VAR 0 6
61401: PUSH
61402: LD_EXP 42
61406: PUSH
61407: LD_VAR 0 2
61411: ARRAY
61412: PPUSH
61413: LD_INT 3
61415: PUSH
61416: LD_INT 24
61418: PUSH
61419: LD_INT 1000
61421: PUSH
61422: EMPTY
61423: LIST
61424: LIST
61425: PUSH
61426: EMPTY
61427: LIST
61428: LIST
61429: PUSH
61430: LD_INT 2
61432: PUSH
61433: LD_INT 34
61435: PUSH
61436: LD_INT 13
61438: PUSH
61439: EMPTY
61440: LIST
61441: LIST
61442: PUSH
61443: LD_INT 34
61445: PUSH
61446: LD_INT 52
61448: PUSH
61449: EMPTY
61450: LIST
61451: LIST
61452: PUSH
61453: LD_INT 34
61455: PUSH
61456: LD_INT 88
61458: PUSH
61459: EMPTY
61460: LIST
61461: LIST
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: LIST
61467: LIST
61468: PUSH
61469: EMPTY
61470: LIST
61471: LIST
61472: PPUSH
61473: CALL_OW 72
61477: ST_TO_ADDR
// if cranes then
61478: LD_VAR 0 6
61482: IFFALSE 61544
// for j in cranes do
61484: LD_ADDR_VAR 0 3
61488: PUSH
61489: LD_VAR 0 6
61493: PUSH
61494: FOR_IN
61495: IFFALSE 61542
// if not IsInArea ( j , mc_parking [ i ] ) then
61497: LD_VAR 0 3
61501: PPUSH
61502: LD_EXP 47
61506: PUSH
61507: LD_VAR 0 2
61511: ARRAY
61512: PPUSH
61513: CALL_OW 308
61517: NOT
61518: IFFALSE 61540
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61520: LD_VAR 0 3
61524: PPUSH
61525: LD_EXP 47
61529: PUSH
61530: LD_VAR 0 2
61534: ARRAY
61535: PPUSH
61536: CALL_OW 113
61540: GO 61494
61542: POP
61543: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61544: LD_ADDR_EXP 25
61548: PUSH
61549: LD_EXP 25
61553: PPUSH
61554: LD_VAR 0 2
61558: PPUSH
61559: EMPTY
61560: PPUSH
61561: CALL_OW 1
61565: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61566: LD_VAR 0 2
61570: PPUSH
61571: LD_INT 101
61573: PPUSH
61574: CALL 56434 0 2
// continue ;
61578: GO 61381
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61580: LD_ADDR_EXP 29
61584: PUSH
61585: LD_EXP 29
61589: PPUSH
61590: LD_VAR 0 2
61594: PPUSH
61595: EMPTY
61596: PPUSH
61597: CALL_OW 1
61601: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61602: LD_VAR 0 2
61606: PPUSH
61607: LD_INT 103
61609: PPUSH
61610: CALL 56434 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
61614: LD_ADDR_VAR 0 5
61618: PUSH
61619: LD_EXP 23
61623: PUSH
61624: LD_VAR 0 2
61628: ARRAY
61629: PUSH
61630: LD_EXP 52
61634: PUSH
61635: LD_VAR 0 2
61639: ARRAY
61640: UNION
61641: PPUSH
61642: LD_INT 2
61644: PUSH
61645: LD_INT 25
61647: PUSH
61648: LD_INT 2
61650: PUSH
61651: EMPTY
61652: LIST
61653: LIST
61654: PUSH
61655: LD_INT 25
61657: PUSH
61658: LD_INT 16
61660: PUSH
61661: EMPTY
61662: LIST
61663: LIST
61664: PUSH
61665: EMPTY
61666: LIST
61667: LIST
61668: LIST
61669: PUSH
61670: EMPTY
61671: LIST
61672: PPUSH
61673: CALL_OW 72
61677: ST_TO_ADDR
// if mc_need_heal [ i ] then
61678: LD_EXP 26
61682: PUSH
61683: LD_VAR 0 2
61687: ARRAY
61688: IFFALSE 61732
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61690: LD_ADDR_VAR 0 5
61694: PUSH
61695: LD_VAR 0 5
61699: PUSH
61700: LD_EXP 26
61704: PUSH
61705: LD_VAR 0 2
61709: ARRAY
61710: PUSH
61711: LD_INT 1
61713: ARRAY
61714: PUSH
61715: LD_EXP 26
61719: PUSH
61720: LD_VAR 0 2
61724: ARRAY
61725: PUSH
61726: LD_INT 2
61728: ARRAY
61729: UNION
61730: DIFF
61731: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61732: LD_ADDR_VAR 0 6
61736: PUSH
61737: LD_EXP 42
61741: PUSH
61742: LD_VAR 0 2
61746: ARRAY
61747: PPUSH
61748: LD_INT 2
61750: PUSH
61751: LD_INT 34
61753: PUSH
61754: LD_INT 13
61756: PUSH
61757: EMPTY
61758: LIST
61759: LIST
61760: PUSH
61761: LD_INT 34
61763: PUSH
61764: LD_INT 52
61766: PUSH
61767: EMPTY
61768: LIST
61769: LIST
61770: PUSH
61771: LD_INT 34
61773: PUSH
61774: LD_INT 88
61776: PUSH
61777: EMPTY
61778: LIST
61779: LIST
61780: PUSH
61781: EMPTY
61782: LIST
61783: LIST
61784: LIST
61785: LIST
61786: PPUSH
61787: CALL_OW 72
61791: ST_TO_ADDR
// if cranes then
61792: LD_VAR 0 6
61796: IFFALSE 61964
// begin for j in cranes do
61798: LD_ADDR_VAR 0 3
61802: PUSH
61803: LD_VAR 0 6
61807: PUSH
61808: FOR_IN
61809: IFFALSE 61962
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61811: LD_VAR 0 3
61815: PPUSH
61816: CALL_OW 256
61820: PUSH
61821: LD_INT 1000
61823: EQUAL
61824: PUSH
61825: LD_VAR 0 3
61829: PPUSH
61830: CALL_OW 314
61834: NOT
61835: AND
61836: IFFALSE 61902
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
61838: LD_ADDR_VAR 0 8
61842: PUSH
61843: LD_EXP 24
61847: PUSH
61848: LD_VAR 0 2
61852: ARRAY
61853: PPUSH
61854: LD_VAR 0 3
61858: PPUSH
61859: CALL_OW 74
61863: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61864: LD_VAR 0 8
61868: PPUSH
61869: LD_INT 16
61871: PPUSH
61872: CALL 18749 0 2
61876: PUSH
61877: LD_INT 4
61879: ARRAY
61880: PUSH
61881: LD_INT 10
61883: LESS
61884: IFFALSE 61900
// ComRepairBuilding ( j , to_repair ) ;
61886: LD_VAR 0 3
61890: PPUSH
61891: LD_VAR 0 8
61895: PPUSH
61896: CALL_OW 130
// end else
61900: GO 61960
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61902: LD_VAR 0 3
61906: PPUSH
61907: CALL_OW 256
61911: PUSH
61912: LD_INT 500
61914: LESS
61915: PUSH
61916: LD_VAR 0 3
61920: PPUSH
61921: LD_EXP 47
61925: PUSH
61926: LD_VAR 0 2
61930: ARRAY
61931: PPUSH
61932: CALL_OW 308
61936: NOT
61937: AND
61938: IFFALSE 61960
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61940: LD_VAR 0 3
61944: PPUSH
61945: LD_EXP 47
61949: PUSH
61950: LD_VAR 0 2
61954: ARRAY
61955: PPUSH
61956: CALL_OW 113
// end ;
61960: GO 61808
61962: POP
61963: POP
// end ; if tmp > 3 then
61964: LD_VAR 0 5
61968: PUSH
61969: LD_INT 3
61971: GREATER
61972: IFFALSE 61992
// tmp := ShrinkArray ( tmp , 4 ) ;
61974: LD_ADDR_VAR 0 5
61978: PUSH
61979: LD_VAR 0 5
61983: PPUSH
61984: LD_INT 4
61986: PPUSH
61987: CALL 48779 0 2
61991: ST_TO_ADDR
// if not tmp then
61992: LD_VAR 0 5
61996: NOT
61997: IFFALSE 62001
// continue ;
61999: GO 61381
// for j in tmp do
62001: LD_ADDR_VAR 0 3
62005: PUSH
62006: LD_VAR 0 5
62010: PUSH
62011: FOR_IN
62012: IFFALSE 62271
// begin if IsInUnit ( j ) then
62014: LD_VAR 0 3
62018: PPUSH
62019: CALL_OW 310
62023: IFFALSE 62034
// ComExitBuilding ( j ) ;
62025: LD_VAR 0 3
62029: PPUSH
62030: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62034: LD_VAR 0 3
62038: PUSH
62039: LD_EXP 25
62043: PUSH
62044: LD_VAR 0 2
62048: ARRAY
62049: IN
62050: NOT
62051: IFFALSE 62109
// begin SetTag ( j , 101 ) ;
62053: LD_VAR 0 3
62057: PPUSH
62058: LD_INT 101
62060: PPUSH
62061: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62065: LD_ADDR_EXP 25
62069: PUSH
62070: LD_EXP 25
62074: PPUSH
62075: LD_VAR 0 2
62079: PUSH
62080: LD_EXP 25
62084: PUSH
62085: LD_VAR 0 2
62089: ARRAY
62090: PUSH
62091: LD_INT 1
62093: PLUS
62094: PUSH
62095: EMPTY
62096: LIST
62097: LIST
62098: PPUSH
62099: LD_VAR 0 3
62103: PPUSH
62104: CALL 16152 0 3
62108: ST_TO_ADDR
// end ; wait ( 1 ) ;
62109: LD_INT 1
62111: PPUSH
62112: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62116: LD_ADDR_VAR 0 7
62120: PUSH
62121: LD_EXP 24
62125: PUSH
62126: LD_VAR 0 2
62130: ARRAY
62131: ST_TO_ADDR
// if mc_scan [ i ] then
62132: LD_EXP 46
62136: PUSH
62137: LD_VAR 0 2
62141: ARRAY
62142: IFFALSE 62204
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62144: LD_ADDR_VAR 0 7
62148: PUSH
62149: LD_EXP 24
62153: PUSH
62154: LD_VAR 0 2
62158: ARRAY
62159: PPUSH
62160: LD_INT 3
62162: PUSH
62163: LD_INT 30
62165: PUSH
62166: LD_INT 32
62168: PUSH
62169: EMPTY
62170: LIST
62171: LIST
62172: PUSH
62173: LD_INT 30
62175: PUSH
62176: LD_INT 33
62178: PUSH
62179: EMPTY
62180: LIST
62181: LIST
62182: PUSH
62183: LD_INT 30
62185: PUSH
62186: LD_INT 31
62188: PUSH
62189: EMPTY
62190: LIST
62191: LIST
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: LIST
62197: LIST
62198: PPUSH
62199: CALL_OW 72
62203: ST_TO_ADDR
// if not to_repair_tmp then
62204: LD_VAR 0 7
62208: NOT
62209: IFFALSE 62213
// continue ;
62211: GO 62011
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62213: LD_ADDR_VAR 0 8
62217: PUSH
62218: LD_VAR 0 7
62222: PPUSH
62223: LD_VAR 0 3
62227: PPUSH
62228: CALL_OW 74
62232: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
62233: LD_VAR 0 8
62237: PPUSH
62238: LD_INT 16
62240: PPUSH
62241: CALL 18749 0 2
62245: PUSH
62246: LD_INT 4
62248: ARRAY
62249: PUSH
62250: LD_INT 14
62252: LESS
62253: IFFALSE 62269
// ComRepairBuilding ( j , to_repair ) ;
62255: LD_VAR 0 3
62259: PPUSH
62260: LD_VAR 0 8
62264: PPUSH
62265: CALL_OW 130
// end ;
62269: GO 62011
62271: POP
62272: POP
// end ;
62273: GO 61381
62275: POP
62276: POP
// end ;
62277: LD_VAR 0 1
62281: RET
// export function MC_Heal ; var i , j , tmp ; begin
62282: LD_INT 0
62284: PPUSH
62285: PPUSH
62286: PPUSH
62287: PPUSH
// if not mc_bases then
62288: LD_EXP 23
62292: NOT
62293: IFFALSE 62297
// exit ;
62295: GO 62699
// for i = 1 to mc_bases do
62297: LD_ADDR_VAR 0 2
62301: PUSH
62302: DOUBLE
62303: LD_INT 1
62305: DEC
62306: ST_TO_ADDR
62307: LD_EXP 23
62311: PUSH
62312: FOR_TO
62313: IFFALSE 62697
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62315: LD_EXP 26
62319: PUSH
62320: LD_VAR 0 2
62324: ARRAY
62325: PUSH
62326: LD_INT 1
62328: ARRAY
62329: NOT
62330: PUSH
62331: LD_EXP 26
62335: PUSH
62336: LD_VAR 0 2
62340: ARRAY
62341: PUSH
62342: LD_INT 2
62344: ARRAY
62345: NOT
62346: AND
62347: IFFALSE 62385
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62349: LD_ADDR_EXP 27
62353: PUSH
62354: LD_EXP 27
62358: PPUSH
62359: LD_VAR 0 2
62363: PPUSH
62364: EMPTY
62365: PPUSH
62366: CALL_OW 1
62370: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62371: LD_VAR 0 2
62375: PPUSH
62376: LD_INT 102
62378: PPUSH
62379: CALL 56434 0 2
// continue ;
62383: GO 62312
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62385: LD_ADDR_VAR 0 4
62389: PUSH
62390: LD_EXP 23
62394: PUSH
62395: LD_VAR 0 2
62399: ARRAY
62400: PPUSH
62401: LD_INT 25
62403: PUSH
62404: LD_INT 4
62406: PUSH
62407: EMPTY
62408: LIST
62409: LIST
62410: PPUSH
62411: CALL_OW 72
62415: ST_TO_ADDR
// if not tmp then
62416: LD_VAR 0 4
62420: NOT
62421: IFFALSE 62425
// continue ;
62423: GO 62312
// if mc_taming [ i ] then
62425: LD_EXP 54
62429: PUSH
62430: LD_VAR 0 2
62434: ARRAY
62435: IFFALSE 62459
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62437: LD_ADDR_EXP 54
62441: PUSH
62442: LD_EXP 54
62446: PPUSH
62447: LD_VAR 0 2
62451: PPUSH
62452: EMPTY
62453: PPUSH
62454: CALL_OW 1
62458: ST_TO_ADDR
// for j in tmp do
62459: LD_ADDR_VAR 0 3
62463: PUSH
62464: LD_VAR 0 4
62468: PUSH
62469: FOR_IN
62470: IFFALSE 62693
// begin if IsInUnit ( j ) then
62472: LD_VAR 0 3
62476: PPUSH
62477: CALL_OW 310
62481: IFFALSE 62492
// ComExitBuilding ( j ) ;
62483: LD_VAR 0 3
62487: PPUSH
62488: CALL_OW 122
// if not j in mc_healers [ i ] then
62492: LD_VAR 0 3
62496: PUSH
62497: LD_EXP 27
62501: PUSH
62502: LD_VAR 0 2
62506: ARRAY
62507: IN
62508: NOT
62509: IFFALSE 62555
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62511: LD_ADDR_EXP 27
62515: PUSH
62516: LD_EXP 27
62520: PPUSH
62521: LD_VAR 0 2
62525: PUSH
62526: LD_EXP 27
62530: PUSH
62531: LD_VAR 0 2
62535: ARRAY
62536: PUSH
62537: LD_INT 1
62539: PLUS
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: PPUSH
62545: LD_VAR 0 3
62549: PPUSH
62550: CALL 16152 0 3
62554: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62555: LD_VAR 0 3
62559: PPUSH
62560: CALL_OW 110
62564: PUSH
62565: LD_INT 102
62567: NONEQUAL
62568: IFFALSE 62582
// SetTag ( j , 102 ) ;
62570: LD_VAR 0 3
62574: PPUSH
62575: LD_INT 102
62577: PPUSH
62578: CALL_OW 109
// Wait ( 3 ) ;
62582: LD_INT 3
62584: PPUSH
62585: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62589: LD_EXP 26
62593: PUSH
62594: LD_VAR 0 2
62598: ARRAY
62599: PUSH
62600: LD_INT 1
62602: ARRAY
62603: IFFALSE 62635
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62605: LD_VAR 0 3
62609: PPUSH
62610: LD_EXP 26
62614: PUSH
62615: LD_VAR 0 2
62619: ARRAY
62620: PUSH
62621: LD_INT 1
62623: ARRAY
62624: PUSH
62625: LD_INT 1
62627: ARRAY
62628: PPUSH
62629: CALL_OW 128
62633: GO 62691
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62635: LD_VAR 0 3
62639: PPUSH
62640: CALL_OW 314
62644: NOT
62645: PUSH
62646: LD_EXP 26
62650: PUSH
62651: LD_VAR 0 2
62655: ARRAY
62656: PUSH
62657: LD_INT 2
62659: ARRAY
62660: AND
62661: IFFALSE 62691
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62663: LD_VAR 0 3
62667: PPUSH
62668: LD_EXP 26
62672: PUSH
62673: LD_VAR 0 2
62677: ARRAY
62678: PUSH
62679: LD_INT 2
62681: ARRAY
62682: PUSH
62683: LD_INT 1
62685: ARRAY
62686: PPUSH
62687: CALL_OW 128
// end ;
62691: GO 62469
62693: POP
62694: POP
// end ;
62695: GO 62312
62697: POP
62698: POP
// end ;
62699: LD_VAR 0 1
62703: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
62704: LD_INT 0
62706: PPUSH
62707: PPUSH
62708: PPUSH
62709: PPUSH
62710: PPUSH
62711: PPUSH
// if not mc_bases then
62712: LD_EXP 23
62716: NOT
62717: IFFALSE 62721
// exit ;
62719: GO 63884
// for i = 1 to mc_bases do
62721: LD_ADDR_VAR 0 2
62725: PUSH
62726: DOUBLE
62727: LD_INT 1
62729: DEC
62730: ST_TO_ADDR
62731: LD_EXP 23
62735: PUSH
62736: FOR_TO
62737: IFFALSE 63882
// begin if mc_scan [ i ] then
62739: LD_EXP 46
62743: PUSH
62744: LD_VAR 0 2
62748: ARRAY
62749: IFFALSE 62753
// continue ;
62751: GO 62736
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62753: LD_EXP 28
62757: PUSH
62758: LD_VAR 0 2
62762: ARRAY
62763: NOT
62764: PUSH
62765: LD_EXP 30
62769: PUSH
62770: LD_VAR 0 2
62774: ARRAY
62775: NOT
62776: AND
62777: PUSH
62778: LD_EXP 29
62782: PUSH
62783: LD_VAR 0 2
62787: ARRAY
62788: AND
62789: IFFALSE 62827
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62791: LD_ADDR_EXP 29
62795: PUSH
62796: LD_EXP 29
62800: PPUSH
62801: LD_VAR 0 2
62805: PPUSH
62806: EMPTY
62807: PPUSH
62808: CALL_OW 1
62812: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62813: LD_VAR 0 2
62817: PPUSH
62818: LD_INT 103
62820: PPUSH
62821: CALL 56434 0 2
// continue ;
62825: GO 62736
// end ; if mc_construct_list [ i ] then
62827: LD_EXP 30
62831: PUSH
62832: LD_VAR 0 2
62836: ARRAY
62837: IFFALSE 63057
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62839: LD_ADDR_VAR 0 5
62843: PUSH
62844: LD_EXP 23
62848: PUSH
62849: LD_VAR 0 2
62853: ARRAY
62854: PPUSH
62855: LD_INT 25
62857: PUSH
62858: LD_INT 2
62860: PUSH
62861: EMPTY
62862: LIST
62863: LIST
62864: PPUSH
62865: CALL_OW 72
62869: PUSH
62870: LD_EXP 25
62874: PUSH
62875: LD_VAR 0 2
62879: ARRAY
62880: DIFF
62881: ST_TO_ADDR
// if not tmp then
62882: LD_VAR 0 5
62886: NOT
62887: IFFALSE 62891
// continue ;
62889: GO 62736
// for j in tmp do
62891: LD_ADDR_VAR 0 3
62895: PUSH
62896: LD_VAR 0 5
62900: PUSH
62901: FOR_IN
62902: IFFALSE 63053
// begin if not mc_builders [ i ] then
62904: LD_EXP 29
62908: PUSH
62909: LD_VAR 0 2
62913: ARRAY
62914: NOT
62915: IFFALSE 62973
// begin SetTag ( j , 103 ) ;
62917: LD_VAR 0 3
62921: PPUSH
62922: LD_INT 103
62924: PPUSH
62925: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62929: LD_ADDR_EXP 29
62933: PUSH
62934: LD_EXP 29
62938: PPUSH
62939: LD_VAR 0 2
62943: PUSH
62944: LD_EXP 29
62948: PUSH
62949: LD_VAR 0 2
62953: ARRAY
62954: PUSH
62955: LD_INT 1
62957: PLUS
62958: PUSH
62959: EMPTY
62960: LIST
62961: LIST
62962: PPUSH
62963: LD_VAR 0 3
62967: PPUSH
62968: CALL 16152 0 3
62972: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62973: LD_VAR 0 3
62977: PPUSH
62978: CALL_OW 310
62982: IFFALSE 62993
// ComExitBuilding ( j ) ;
62984: LD_VAR 0 3
62988: PPUSH
62989: CALL_OW 122
// wait ( 3 ) ;
62993: LD_INT 3
62995: PPUSH
62996: CALL_OW 67
// if not mc_construct_list [ i ] then
63000: LD_EXP 30
63004: PUSH
63005: LD_VAR 0 2
63009: ARRAY
63010: NOT
63011: IFFALSE 63015
// break ;
63013: GO 63053
// if not HasTask ( j ) then
63015: LD_VAR 0 3
63019: PPUSH
63020: CALL_OW 314
63024: NOT
63025: IFFALSE 63051
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63027: LD_VAR 0 3
63031: PPUSH
63032: LD_EXP 30
63036: PUSH
63037: LD_VAR 0 2
63041: ARRAY
63042: PUSH
63043: LD_INT 1
63045: ARRAY
63046: PPUSH
63047: CALL 19013 0 2
// end ;
63051: GO 62901
63053: POP
63054: POP
// end else
63055: GO 63880
// if mc_build_list [ i ] then
63057: LD_EXP 28
63061: PUSH
63062: LD_VAR 0 2
63066: ARRAY
63067: IFFALSE 63880
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63069: LD_EXP 28
63073: PUSH
63074: LD_VAR 0 2
63078: ARRAY
63079: PUSH
63080: LD_INT 1
63082: ARRAY
63083: PUSH
63084: LD_INT 1
63086: ARRAY
63087: PPUSH
63088: CALL 18837 0 1
63092: PUSH
63093: LD_EXP 23
63097: PUSH
63098: LD_VAR 0 2
63102: ARRAY
63103: PPUSH
63104: LD_INT 2
63106: PUSH
63107: LD_INT 30
63109: PUSH
63110: LD_INT 2
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 30
63119: PUSH
63120: LD_INT 3
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: LIST
63131: PPUSH
63132: CALL_OW 72
63136: NOT
63137: AND
63138: IFFALSE 63243
// begin for j = 1 to mc_build_list [ i ] do
63140: LD_ADDR_VAR 0 3
63144: PUSH
63145: DOUBLE
63146: LD_INT 1
63148: DEC
63149: ST_TO_ADDR
63150: LD_EXP 28
63154: PUSH
63155: LD_VAR 0 2
63159: ARRAY
63160: PUSH
63161: FOR_TO
63162: IFFALSE 63241
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63164: LD_EXP 28
63168: PUSH
63169: LD_VAR 0 2
63173: ARRAY
63174: PUSH
63175: LD_VAR 0 3
63179: ARRAY
63180: PUSH
63181: LD_INT 1
63183: ARRAY
63184: PUSH
63185: LD_INT 2
63187: EQUAL
63188: IFFALSE 63239
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63190: LD_ADDR_EXP 28
63194: PUSH
63195: LD_EXP 28
63199: PPUSH
63200: LD_VAR 0 2
63204: PPUSH
63205: LD_EXP 28
63209: PUSH
63210: LD_VAR 0 2
63214: ARRAY
63215: PPUSH
63216: LD_VAR 0 3
63220: PPUSH
63221: LD_INT 1
63223: PPUSH
63224: LD_INT 0
63226: PPUSH
63227: CALL 15570 0 4
63231: PPUSH
63232: CALL_OW 1
63236: ST_TO_ADDR
// break ;
63237: GO 63241
// end ;
63239: GO 63161
63241: POP
63242: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63243: LD_ADDR_VAR 0 6
63247: PUSH
63248: LD_EXP 23
63252: PUSH
63253: LD_VAR 0 2
63257: ARRAY
63258: PPUSH
63259: LD_INT 2
63261: PUSH
63262: LD_INT 30
63264: PUSH
63265: LD_INT 0
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PUSH
63272: LD_INT 30
63274: PUSH
63275: LD_INT 1
63277: PUSH
63278: EMPTY
63279: LIST
63280: LIST
63281: PUSH
63282: EMPTY
63283: LIST
63284: LIST
63285: LIST
63286: PPUSH
63287: CALL_OW 72
63291: ST_TO_ADDR
// for k := 1 to depot do
63292: LD_ADDR_VAR 0 4
63296: PUSH
63297: DOUBLE
63298: LD_INT 1
63300: DEC
63301: ST_TO_ADDR
63302: LD_VAR 0 6
63306: PUSH
63307: FOR_TO
63308: IFFALSE 63878
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
63310: LD_EXP 28
63314: PUSH
63315: LD_VAR 0 2
63319: ARRAY
63320: PUSH
63321: LD_INT 1
63323: ARRAY
63324: PUSH
63325: LD_INT 1
63327: ARRAY
63328: PUSH
63329: LD_INT 0
63331: EQUAL
63332: PUSH
63333: LD_VAR 0 6
63337: PUSH
63338: LD_VAR 0 4
63342: ARRAY
63343: PPUSH
63344: LD_EXP 28
63348: PUSH
63349: LD_VAR 0 2
63353: ARRAY
63354: PUSH
63355: LD_INT 1
63357: ARRAY
63358: PUSH
63359: LD_INT 1
63361: ARRAY
63362: PPUSH
63363: LD_EXP 28
63367: PUSH
63368: LD_VAR 0 2
63372: ARRAY
63373: PUSH
63374: LD_INT 1
63376: ARRAY
63377: PUSH
63378: LD_INT 2
63380: ARRAY
63381: PPUSH
63382: LD_EXP 28
63386: PUSH
63387: LD_VAR 0 2
63391: ARRAY
63392: PUSH
63393: LD_INT 1
63395: ARRAY
63396: PUSH
63397: LD_INT 3
63399: ARRAY
63400: PPUSH
63401: LD_EXP 28
63405: PUSH
63406: LD_VAR 0 2
63410: ARRAY
63411: PUSH
63412: LD_INT 1
63414: ARRAY
63415: PUSH
63416: LD_INT 4
63418: ARRAY
63419: PPUSH
63420: CALL 24249 0 5
63424: OR
63425: IFFALSE 63706
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63427: LD_ADDR_VAR 0 5
63431: PUSH
63432: LD_EXP 23
63436: PUSH
63437: LD_VAR 0 2
63441: ARRAY
63442: PPUSH
63443: LD_INT 25
63445: PUSH
63446: LD_INT 2
63448: PUSH
63449: EMPTY
63450: LIST
63451: LIST
63452: PPUSH
63453: CALL_OW 72
63457: PUSH
63458: LD_EXP 25
63462: PUSH
63463: LD_VAR 0 2
63467: ARRAY
63468: DIFF
63469: ST_TO_ADDR
// if not tmp then
63470: LD_VAR 0 5
63474: NOT
63475: IFFALSE 63479
// continue ;
63477: GO 63307
// for j in tmp do
63479: LD_ADDR_VAR 0 3
63483: PUSH
63484: LD_VAR 0 5
63488: PUSH
63489: FOR_IN
63490: IFFALSE 63702
// begin if not mc_builders [ i ] then
63492: LD_EXP 29
63496: PUSH
63497: LD_VAR 0 2
63501: ARRAY
63502: NOT
63503: IFFALSE 63561
// begin SetTag ( j , 103 ) ;
63505: LD_VAR 0 3
63509: PPUSH
63510: LD_INT 103
63512: PPUSH
63513: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63517: LD_ADDR_EXP 29
63521: PUSH
63522: LD_EXP 29
63526: PPUSH
63527: LD_VAR 0 2
63531: PUSH
63532: LD_EXP 29
63536: PUSH
63537: LD_VAR 0 2
63541: ARRAY
63542: PUSH
63543: LD_INT 1
63545: PLUS
63546: PUSH
63547: EMPTY
63548: LIST
63549: LIST
63550: PPUSH
63551: LD_VAR 0 3
63555: PPUSH
63556: CALL 16152 0 3
63560: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63561: LD_VAR 0 3
63565: PPUSH
63566: CALL_OW 310
63570: IFFALSE 63581
// ComExitBuilding ( j ) ;
63572: LD_VAR 0 3
63576: PPUSH
63577: CALL_OW 122
// wait ( 3 ) ;
63581: LD_INT 3
63583: PPUSH
63584: CALL_OW 67
// if not mc_build_list [ i ] then
63588: LD_EXP 28
63592: PUSH
63593: LD_VAR 0 2
63597: ARRAY
63598: NOT
63599: IFFALSE 63603
// break ;
63601: GO 63702
// if not HasTask ( j ) then
63603: LD_VAR 0 3
63607: PPUSH
63608: CALL_OW 314
63612: NOT
63613: IFFALSE 63700
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63615: LD_VAR 0 3
63619: PPUSH
63620: LD_EXP 28
63624: PUSH
63625: LD_VAR 0 2
63629: ARRAY
63630: PUSH
63631: LD_INT 1
63633: ARRAY
63634: PUSH
63635: LD_INT 1
63637: ARRAY
63638: PPUSH
63639: LD_EXP 28
63643: PUSH
63644: LD_VAR 0 2
63648: ARRAY
63649: PUSH
63650: LD_INT 1
63652: ARRAY
63653: PUSH
63654: LD_INT 2
63656: ARRAY
63657: PPUSH
63658: LD_EXP 28
63662: PUSH
63663: LD_VAR 0 2
63667: ARRAY
63668: PUSH
63669: LD_INT 1
63671: ARRAY
63672: PUSH
63673: LD_INT 3
63675: ARRAY
63676: PPUSH
63677: LD_EXP 28
63681: PUSH
63682: LD_VAR 0 2
63686: ARRAY
63687: PUSH
63688: LD_INT 1
63690: ARRAY
63691: PUSH
63692: LD_INT 4
63694: ARRAY
63695: PPUSH
63696: CALL_OW 145
// end ;
63700: GO 63489
63702: POP
63703: POP
// end else
63704: GO 63876
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63706: LD_EXP 23
63710: PUSH
63711: LD_VAR 0 2
63715: ARRAY
63716: PPUSH
63717: LD_EXP 28
63721: PUSH
63722: LD_VAR 0 2
63726: ARRAY
63727: PUSH
63728: LD_INT 1
63730: ARRAY
63731: PUSH
63732: LD_INT 1
63734: ARRAY
63735: PPUSH
63736: LD_EXP 28
63740: PUSH
63741: LD_VAR 0 2
63745: ARRAY
63746: PUSH
63747: LD_INT 1
63749: ARRAY
63750: PUSH
63751: LD_INT 2
63753: ARRAY
63754: PPUSH
63755: LD_EXP 28
63759: PUSH
63760: LD_VAR 0 2
63764: ARRAY
63765: PUSH
63766: LD_INT 1
63768: ARRAY
63769: PUSH
63770: LD_INT 3
63772: ARRAY
63773: PPUSH
63774: LD_EXP 28
63778: PUSH
63779: LD_VAR 0 2
63783: ARRAY
63784: PUSH
63785: LD_INT 1
63787: ARRAY
63788: PUSH
63789: LD_INT 4
63791: ARRAY
63792: PPUSH
63793: LD_EXP 23
63797: PUSH
63798: LD_VAR 0 2
63802: ARRAY
63803: PPUSH
63804: LD_INT 21
63806: PUSH
63807: LD_INT 3
63809: PUSH
63810: EMPTY
63811: LIST
63812: LIST
63813: PPUSH
63814: CALL_OW 72
63818: PPUSH
63819: EMPTY
63820: PPUSH
63821: CALL 23003 0 7
63825: NOT
63826: IFFALSE 63876
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63828: LD_ADDR_EXP 28
63832: PUSH
63833: LD_EXP 28
63837: PPUSH
63838: LD_VAR 0 2
63842: PPUSH
63843: LD_EXP 28
63847: PUSH
63848: LD_VAR 0 2
63852: ARRAY
63853: PPUSH
63854: LD_INT 1
63856: PPUSH
63857: LD_INT 1
63859: NEG
63860: PPUSH
63861: LD_INT 0
63863: PPUSH
63864: CALL 15570 0 4
63868: PPUSH
63869: CALL_OW 1
63873: ST_TO_ADDR
// continue ;
63874: GO 63307
// end ; end ;
63876: GO 63307
63878: POP
63879: POP
// end ; end ;
63880: GO 62736
63882: POP
63883: POP
// end ;
63884: LD_VAR 0 1
63888: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63889: LD_INT 0
63891: PPUSH
63892: PPUSH
63893: PPUSH
63894: PPUSH
63895: PPUSH
63896: PPUSH
// if not mc_bases then
63897: LD_EXP 23
63901: NOT
63902: IFFALSE 63906
// exit ;
63904: GO 64333
// for i = 1 to mc_bases do
63906: LD_ADDR_VAR 0 2
63910: PUSH
63911: DOUBLE
63912: LD_INT 1
63914: DEC
63915: ST_TO_ADDR
63916: LD_EXP 23
63920: PUSH
63921: FOR_TO
63922: IFFALSE 64331
// begin tmp := mc_build_upgrade [ i ] ;
63924: LD_ADDR_VAR 0 4
63928: PUSH
63929: LD_EXP 55
63933: PUSH
63934: LD_VAR 0 2
63938: ARRAY
63939: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63940: LD_ADDR_VAR 0 6
63944: PUSH
63945: LD_EXP 56
63949: PUSH
63950: LD_VAR 0 2
63954: ARRAY
63955: PPUSH
63956: LD_INT 2
63958: PUSH
63959: LD_INT 30
63961: PUSH
63962: LD_INT 6
63964: PUSH
63965: EMPTY
63966: LIST
63967: LIST
63968: PUSH
63969: LD_INT 30
63971: PUSH
63972: LD_INT 7
63974: PUSH
63975: EMPTY
63976: LIST
63977: LIST
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: LIST
63983: PPUSH
63984: CALL_OW 72
63988: ST_TO_ADDR
// if not tmp and not lab then
63989: LD_VAR 0 4
63993: NOT
63994: PUSH
63995: LD_VAR 0 6
63999: NOT
64000: AND
64001: IFFALSE 64005
// continue ;
64003: GO 63921
// if tmp then
64005: LD_VAR 0 4
64009: IFFALSE 64129
// for j in tmp do
64011: LD_ADDR_VAR 0 3
64015: PUSH
64016: LD_VAR 0 4
64020: PUSH
64021: FOR_IN
64022: IFFALSE 64127
// begin if UpgradeCost ( j ) then
64024: LD_VAR 0 3
64028: PPUSH
64029: CALL 22663 0 1
64033: IFFALSE 64125
// begin ComUpgrade ( j ) ;
64035: LD_VAR 0 3
64039: PPUSH
64040: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64044: LD_ADDR_EXP 55
64048: PUSH
64049: LD_EXP 55
64053: PPUSH
64054: LD_VAR 0 2
64058: PPUSH
64059: LD_EXP 55
64063: PUSH
64064: LD_VAR 0 2
64068: ARRAY
64069: PUSH
64070: LD_VAR 0 3
64074: DIFF
64075: PPUSH
64076: CALL_OW 1
64080: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64081: LD_ADDR_EXP 30
64085: PUSH
64086: LD_EXP 30
64090: PPUSH
64091: LD_VAR 0 2
64095: PUSH
64096: LD_EXP 30
64100: PUSH
64101: LD_VAR 0 2
64105: ARRAY
64106: PUSH
64107: LD_INT 1
64109: PLUS
64110: PUSH
64111: EMPTY
64112: LIST
64113: LIST
64114: PPUSH
64115: LD_VAR 0 3
64119: PPUSH
64120: CALL 16152 0 3
64124: ST_TO_ADDR
// end ; end ;
64125: GO 64021
64127: POP
64128: POP
// if not lab or not mc_lab_upgrade [ i ] then
64129: LD_VAR 0 6
64133: NOT
64134: PUSH
64135: LD_EXP 57
64139: PUSH
64140: LD_VAR 0 2
64144: ARRAY
64145: NOT
64146: OR
64147: IFFALSE 64151
// continue ;
64149: GO 63921
// for j in lab do
64151: LD_ADDR_VAR 0 3
64155: PUSH
64156: LD_VAR 0 6
64160: PUSH
64161: FOR_IN
64162: IFFALSE 64327
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64164: LD_VAR 0 3
64168: PPUSH
64169: CALL_OW 266
64173: PUSH
64174: LD_INT 6
64176: PUSH
64177: LD_INT 7
64179: PUSH
64180: EMPTY
64181: LIST
64182: LIST
64183: IN
64184: PUSH
64185: LD_VAR 0 3
64189: PPUSH
64190: CALL_OW 461
64194: PUSH
64195: LD_INT 1
64197: NONEQUAL
64198: AND
64199: IFFALSE 64325
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64201: LD_VAR 0 3
64205: PPUSH
64206: LD_EXP 57
64210: PUSH
64211: LD_VAR 0 2
64215: ARRAY
64216: PUSH
64217: LD_INT 1
64219: ARRAY
64220: PPUSH
64221: CALL 22868 0 2
64225: IFFALSE 64325
// begin ComCancel ( j ) ;
64227: LD_VAR 0 3
64231: PPUSH
64232: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64236: LD_VAR 0 3
64240: PPUSH
64241: LD_EXP 57
64245: PUSH
64246: LD_VAR 0 2
64250: ARRAY
64251: PUSH
64252: LD_INT 1
64254: ARRAY
64255: PPUSH
64256: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64260: LD_VAR 0 3
64264: PUSH
64265: LD_EXP 30
64269: PUSH
64270: LD_VAR 0 2
64274: ARRAY
64275: IN
64276: NOT
64277: IFFALSE 64323
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64279: LD_ADDR_EXP 30
64283: PUSH
64284: LD_EXP 30
64288: PPUSH
64289: LD_VAR 0 2
64293: PUSH
64294: LD_EXP 30
64298: PUSH
64299: LD_VAR 0 2
64303: ARRAY
64304: PUSH
64305: LD_INT 1
64307: PLUS
64308: PUSH
64309: EMPTY
64310: LIST
64311: LIST
64312: PPUSH
64313: LD_VAR 0 3
64317: PPUSH
64318: CALL 16152 0 3
64322: ST_TO_ADDR
// break ;
64323: GO 64327
// end ; end ; end ;
64325: GO 64161
64327: POP
64328: POP
// end ;
64329: GO 63921
64331: POP
64332: POP
// end ;
64333: LD_VAR 0 1
64337: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64338: LD_INT 0
64340: PPUSH
64341: PPUSH
64342: PPUSH
64343: PPUSH
64344: PPUSH
64345: PPUSH
64346: PPUSH
64347: PPUSH
64348: PPUSH
// if not mc_bases then
64349: LD_EXP 23
64353: NOT
64354: IFFALSE 64358
// exit ;
64356: GO 64763
// for i = 1 to mc_bases do
64358: LD_ADDR_VAR 0 2
64362: PUSH
64363: DOUBLE
64364: LD_INT 1
64366: DEC
64367: ST_TO_ADDR
64368: LD_EXP 23
64372: PUSH
64373: FOR_TO
64374: IFFALSE 64761
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64376: LD_EXP 31
64380: PUSH
64381: LD_VAR 0 2
64385: ARRAY
64386: NOT
64387: PUSH
64388: LD_EXP 23
64392: PUSH
64393: LD_VAR 0 2
64397: ARRAY
64398: PPUSH
64399: LD_INT 30
64401: PUSH
64402: LD_INT 3
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PPUSH
64409: CALL_OW 72
64413: NOT
64414: OR
64415: IFFALSE 64419
// continue ;
64417: GO 64373
// busy := false ;
64419: LD_ADDR_VAR 0 8
64423: PUSH
64424: LD_INT 0
64426: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64427: LD_ADDR_VAR 0 4
64431: PUSH
64432: LD_EXP 23
64436: PUSH
64437: LD_VAR 0 2
64441: ARRAY
64442: PPUSH
64443: LD_INT 30
64445: PUSH
64446: LD_INT 3
64448: PUSH
64449: EMPTY
64450: LIST
64451: LIST
64452: PPUSH
64453: CALL_OW 72
64457: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64458: LD_ADDR_VAR 0 6
64462: PUSH
64463: LD_EXP 31
64467: PUSH
64468: LD_VAR 0 2
64472: ARRAY
64473: PPUSH
64474: LD_INT 2
64476: PUSH
64477: LD_INT 30
64479: PUSH
64480: LD_INT 32
64482: PUSH
64483: EMPTY
64484: LIST
64485: LIST
64486: PUSH
64487: LD_INT 30
64489: PUSH
64490: LD_INT 33
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: LIST
64501: PPUSH
64502: CALL_OW 72
64506: ST_TO_ADDR
// if not t then
64507: LD_VAR 0 6
64511: NOT
64512: IFFALSE 64516
// continue ;
64514: GO 64373
// for j in tmp do
64516: LD_ADDR_VAR 0 3
64520: PUSH
64521: LD_VAR 0 4
64525: PUSH
64526: FOR_IN
64527: IFFALSE 64557
// if not BuildingStatus ( j ) = bs_idle then
64529: LD_VAR 0 3
64533: PPUSH
64534: CALL_OW 461
64538: PUSH
64539: LD_INT 2
64541: EQUAL
64542: NOT
64543: IFFALSE 64555
// begin busy := true ;
64545: LD_ADDR_VAR 0 8
64549: PUSH
64550: LD_INT 1
64552: ST_TO_ADDR
// break ;
64553: GO 64557
// end ;
64555: GO 64526
64557: POP
64558: POP
// if busy then
64559: LD_VAR 0 8
64563: IFFALSE 64567
// continue ;
64565: GO 64373
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64567: LD_ADDR_VAR 0 7
64571: PUSH
64572: LD_VAR 0 6
64576: PPUSH
64577: LD_INT 35
64579: PUSH
64580: LD_INT 0
64582: PUSH
64583: EMPTY
64584: LIST
64585: LIST
64586: PPUSH
64587: CALL_OW 72
64591: ST_TO_ADDR
// if tw then
64592: LD_VAR 0 7
64596: IFFALSE 64673
// begin tw := tw [ 1 ] ;
64598: LD_ADDR_VAR 0 7
64602: PUSH
64603: LD_VAR 0 7
64607: PUSH
64608: LD_INT 1
64610: ARRAY
64611: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64612: LD_ADDR_VAR 0 9
64616: PUSH
64617: LD_VAR 0 7
64621: PPUSH
64622: LD_EXP 48
64626: PUSH
64627: LD_VAR 0 2
64631: ARRAY
64632: PPUSH
64633: CALL 21160 0 2
64637: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64638: LD_EXP 62
64642: PUSH
64643: LD_VAR 0 2
64647: ARRAY
64648: IFFALSE 64671
// if not weapon in mc_allowed_tower_weapons [ i ] then
64650: LD_VAR 0 9
64654: PUSH
64655: LD_EXP 62
64659: PUSH
64660: LD_VAR 0 2
64664: ARRAY
64665: IN
64666: NOT
64667: IFFALSE 64671
// continue ;
64669: GO 64373
// end else
64671: GO 64736
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64673: LD_ADDR_VAR 0 5
64677: PUSH
64678: LD_EXP 31
64682: PUSH
64683: LD_VAR 0 2
64687: ARRAY
64688: PPUSH
64689: LD_VAR 0 4
64693: PPUSH
64694: CALL 48012 0 2
64698: ST_TO_ADDR
// if not tmp2 then
64699: LD_VAR 0 5
64703: NOT
64704: IFFALSE 64708
// continue ;
64706: GO 64373
// tw := tmp2 [ 1 ] ;
64708: LD_ADDR_VAR 0 7
64712: PUSH
64713: LD_VAR 0 5
64717: PUSH
64718: LD_INT 1
64720: ARRAY
64721: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64722: LD_ADDR_VAR 0 9
64726: PUSH
64727: LD_VAR 0 5
64731: PUSH
64732: LD_INT 2
64734: ARRAY
64735: ST_TO_ADDR
// end ; if not weapon then
64736: LD_VAR 0 9
64740: NOT
64741: IFFALSE 64745
// continue ;
64743: GO 64373
// ComPlaceWeapon ( tw , weapon ) ;
64745: LD_VAR 0 7
64749: PPUSH
64750: LD_VAR 0 9
64754: PPUSH
64755: CALL_OW 148
// end ;
64759: GO 64373
64761: POP
64762: POP
// end ;
64763: LD_VAR 0 1
64767: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64768: LD_INT 0
64770: PPUSH
64771: PPUSH
64772: PPUSH
64773: PPUSH
64774: PPUSH
64775: PPUSH
64776: PPUSH
// if not mc_bases then
64777: LD_EXP 23
64781: NOT
64782: IFFALSE 64786
// exit ;
64784: GO 65554
// for i = 1 to mc_bases do
64786: LD_ADDR_VAR 0 2
64790: PUSH
64791: DOUBLE
64792: LD_INT 1
64794: DEC
64795: ST_TO_ADDR
64796: LD_EXP 23
64800: PUSH
64801: FOR_TO
64802: IFFALSE 65552
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64804: LD_EXP 36
64808: PUSH
64809: LD_VAR 0 2
64813: ARRAY
64814: NOT
64815: PUSH
64816: LD_EXP 36
64820: PUSH
64821: LD_VAR 0 2
64825: ARRAY
64826: PUSH
64827: LD_EXP 37
64831: PUSH
64832: LD_VAR 0 2
64836: ARRAY
64837: EQUAL
64838: OR
64839: PUSH
64840: LD_EXP 46
64844: PUSH
64845: LD_VAR 0 2
64849: ARRAY
64850: OR
64851: IFFALSE 64855
// continue ;
64853: GO 64801
// if mc_miners [ i ] then
64855: LD_EXP 37
64859: PUSH
64860: LD_VAR 0 2
64864: ARRAY
64865: IFFALSE 65239
// begin for j = mc_miners [ i ] downto 1 do
64867: LD_ADDR_VAR 0 3
64871: PUSH
64872: DOUBLE
64873: LD_EXP 37
64877: PUSH
64878: LD_VAR 0 2
64882: ARRAY
64883: INC
64884: ST_TO_ADDR
64885: LD_INT 1
64887: PUSH
64888: FOR_DOWNTO
64889: IFFALSE 65237
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64891: LD_EXP 37
64895: PUSH
64896: LD_VAR 0 2
64900: ARRAY
64901: PUSH
64902: LD_VAR 0 3
64906: ARRAY
64907: PPUSH
64908: CALL_OW 301
64912: PUSH
64913: LD_EXP 37
64917: PUSH
64918: LD_VAR 0 2
64922: ARRAY
64923: PUSH
64924: LD_VAR 0 3
64928: ARRAY
64929: PPUSH
64930: CALL_OW 257
64934: PUSH
64935: LD_INT 1
64937: NONEQUAL
64938: OR
64939: IFFALSE 65002
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64941: LD_ADDR_VAR 0 5
64945: PUSH
64946: LD_EXP 37
64950: PUSH
64951: LD_VAR 0 2
64955: ARRAY
64956: PUSH
64957: LD_EXP 37
64961: PUSH
64962: LD_VAR 0 2
64966: ARRAY
64967: PUSH
64968: LD_VAR 0 3
64972: ARRAY
64973: DIFF
64974: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64975: LD_ADDR_EXP 37
64979: PUSH
64980: LD_EXP 37
64984: PPUSH
64985: LD_VAR 0 2
64989: PPUSH
64990: LD_VAR 0 5
64994: PPUSH
64995: CALL_OW 1
64999: ST_TO_ADDR
// continue ;
65000: GO 64888
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
65002: LD_EXP 37
65006: PUSH
65007: LD_VAR 0 2
65011: ARRAY
65012: PUSH
65013: LD_VAR 0 3
65017: ARRAY
65018: PPUSH
65019: CALL_OW 257
65023: PUSH
65024: LD_INT 1
65026: EQUAL
65027: PUSH
65028: LD_EXP 37
65032: PUSH
65033: LD_VAR 0 2
65037: ARRAY
65038: PUSH
65039: LD_VAR 0 3
65043: ARRAY
65044: PPUSH
65045: CALL_OW 459
65049: NOT
65050: AND
65051: PUSH
65052: LD_EXP 37
65056: PUSH
65057: LD_VAR 0 2
65061: ARRAY
65062: PUSH
65063: LD_VAR 0 3
65067: ARRAY
65068: PPUSH
65069: CALL_OW 314
65073: NOT
65074: AND
65075: IFFALSE 65235
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65077: LD_EXP 37
65081: PUSH
65082: LD_VAR 0 2
65086: ARRAY
65087: PUSH
65088: LD_VAR 0 3
65092: ARRAY
65093: PPUSH
65094: CALL_OW 310
65098: IFFALSE 65121
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65100: LD_EXP 37
65104: PUSH
65105: LD_VAR 0 2
65109: ARRAY
65110: PUSH
65111: LD_VAR 0 3
65115: ARRAY
65116: PPUSH
65117: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65121: LD_EXP 37
65125: PUSH
65126: LD_VAR 0 2
65130: ARRAY
65131: PUSH
65132: LD_VAR 0 3
65136: ARRAY
65137: PPUSH
65138: CALL_OW 314
65142: NOT
65143: IFFALSE 65235
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65145: LD_ADDR_VAR 0 7
65149: PUSH
65150: LD_INT 1
65152: PPUSH
65153: LD_EXP 36
65157: PUSH
65158: LD_VAR 0 2
65162: ARRAY
65163: PPUSH
65164: CALL_OW 12
65168: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65169: LD_EXP 37
65173: PUSH
65174: LD_VAR 0 2
65178: ARRAY
65179: PUSH
65180: LD_VAR 0 3
65184: ARRAY
65185: PPUSH
65186: LD_EXP 36
65190: PUSH
65191: LD_VAR 0 2
65195: ARRAY
65196: PUSH
65197: LD_VAR 0 7
65201: ARRAY
65202: PUSH
65203: LD_INT 1
65205: ARRAY
65206: PPUSH
65207: LD_EXP 36
65211: PUSH
65212: LD_VAR 0 2
65216: ARRAY
65217: PUSH
65218: LD_VAR 0 7
65222: ARRAY
65223: PUSH
65224: LD_INT 2
65226: ARRAY
65227: PPUSH
65228: LD_INT 0
65230: PPUSH
65231: CALL_OW 193
// end ; end ; end ;
65235: GO 64888
65237: POP
65238: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65239: LD_ADDR_VAR 0 5
65243: PUSH
65244: LD_EXP 23
65248: PUSH
65249: LD_VAR 0 2
65253: ARRAY
65254: PPUSH
65255: LD_INT 2
65257: PUSH
65258: LD_INT 30
65260: PUSH
65261: LD_INT 4
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: PUSH
65268: LD_INT 30
65270: PUSH
65271: LD_INT 5
65273: PUSH
65274: EMPTY
65275: LIST
65276: LIST
65277: PUSH
65278: LD_INT 30
65280: PUSH
65281: LD_INT 32
65283: PUSH
65284: EMPTY
65285: LIST
65286: LIST
65287: PUSH
65288: EMPTY
65289: LIST
65290: LIST
65291: LIST
65292: LIST
65293: PPUSH
65294: CALL_OW 72
65298: ST_TO_ADDR
// if not tmp then
65299: LD_VAR 0 5
65303: NOT
65304: IFFALSE 65308
// continue ;
65306: GO 64801
// list := [ ] ;
65308: LD_ADDR_VAR 0 6
65312: PUSH
65313: EMPTY
65314: ST_TO_ADDR
// for j in tmp do
65315: LD_ADDR_VAR 0 3
65319: PUSH
65320: LD_VAR 0 5
65324: PUSH
65325: FOR_IN
65326: IFFALSE 65395
// begin for k in UnitsInside ( j ) do
65328: LD_ADDR_VAR 0 4
65332: PUSH
65333: LD_VAR 0 3
65337: PPUSH
65338: CALL_OW 313
65342: PUSH
65343: FOR_IN
65344: IFFALSE 65391
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65346: LD_VAR 0 4
65350: PPUSH
65351: CALL_OW 257
65355: PUSH
65356: LD_INT 1
65358: EQUAL
65359: PUSH
65360: LD_VAR 0 4
65364: PPUSH
65365: CALL_OW 459
65369: NOT
65370: AND
65371: IFFALSE 65389
// list := list ^ k ;
65373: LD_ADDR_VAR 0 6
65377: PUSH
65378: LD_VAR 0 6
65382: PUSH
65383: LD_VAR 0 4
65387: ADD
65388: ST_TO_ADDR
65389: GO 65343
65391: POP
65392: POP
// end ;
65393: GO 65325
65395: POP
65396: POP
// list := list diff mc_miners [ i ] ;
65397: LD_ADDR_VAR 0 6
65401: PUSH
65402: LD_VAR 0 6
65406: PUSH
65407: LD_EXP 37
65411: PUSH
65412: LD_VAR 0 2
65416: ARRAY
65417: DIFF
65418: ST_TO_ADDR
// if not list then
65419: LD_VAR 0 6
65423: NOT
65424: IFFALSE 65428
// continue ;
65426: GO 64801
// k := mc_mines [ i ] - mc_miners [ i ] ;
65428: LD_ADDR_VAR 0 4
65432: PUSH
65433: LD_EXP 36
65437: PUSH
65438: LD_VAR 0 2
65442: ARRAY
65443: PUSH
65444: LD_EXP 37
65448: PUSH
65449: LD_VAR 0 2
65453: ARRAY
65454: MINUS
65455: ST_TO_ADDR
// if k > list then
65456: LD_VAR 0 4
65460: PUSH
65461: LD_VAR 0 6
65465: GREATER
65466: IFFALSE 65478
// k := list ;
65468: LD_ADDR_VAR 0 4
65472: PUSH
65473: LD_VAR 0 6
65477: ST_TO_ADDR
// for j = 1 to k do
65478: LD_ADDR_VAR 0 3
65482: PUSH
65483: DOUBLE
65484: LD_INT 1
65486: DEC
65487: ST_TO_ADDR
65488: LD_VAR 0 4
65492: PUSH
65493: FOR_TO
65494: IFFALSE 65548
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65496: LD_ADDR_EXP 37
65500: PUSH
65501: LD_EXP 37
65505: PPUSH
65506: LD_VAR 0 2
65510: PUSH
65511: LD_EXP 37
65515: PUSH
65516: LD_VAR 0 2
65520: ARRAY
65521: PUSH
65522: LD_INT 1
65524: PLUS
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: PPUSH
65530: LD_VAR 0 6
65534: PUSH
65535: LD_VAR 0 3
65539: ARRAY
65540: PPUSH
65541: CALL 16152 0 3
65545: ST_TO_ADDR
65546: GO 65493
65548: POP
65549: POP
// end ;
65550: GO 64801
65552: POP
65553: POP
// end ;
65554: LD_VAR 0 1
65558: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65559: LD_INT 0
65561: PPUSH
65562: PPUSH
65563: PPUSH
65564: PPUSH
65565: PPUSH
65566: PPUSH
65567: PPUSH
65568: PPUSH
65569: PPUSH
65570: PPUSH
65571: PPUSH
// if not mc_bases then
65572: LD_EXP 23
65576: NOT
65577: IFFALSE 65581
// exit ;
65579: GO 67404
// for i = 1 to mc_bases do
65581: LD_ADDR_VAR 0 2
65585: PUSH
65586: DOUBLE
65587: LD_INT 1
65589: DEC
65590: ST_TO_ADDR
65591: LD_EXP 23
65595: PUSH
65596: FOR_TO
65597: IFFALSE 67402
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65599: LD_EXP 23
65603: PUSH
65604: LD_VAR 0 2
65608: ARRAY
65609: NOT
65610: PUSH
65611: LD_EXP 30
65615: PUSH
65616: LD_VAR 0 2
65620: ARRAY
65621: OR
65622: IFFALSE 65626
// continue ;
65624: GO 65596
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65626: LD_EXP 39
65630: PUSH
65631: LD_VAR 0 2
65635: ARRAY
65636: NOT
65637: PUSH
65638: LD_EXP 40
65642: PUSH
65643: LD_VAR 0 2
65647: ARRAY
65648: AND
65649: IFFALSE 65687
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65651: LD_ADDR_EXP 40
65655: PUSH
65656: LD_EXP 40
65660: PPUSH
65661: LD_VAR 0 2
65665: PPUSH
65666: EMPTY
65667: PPUSH
65668: CALL_OW 1
65672: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65673: LD_VAR 0 2
65677: PPUSH
65678: LD_INT 107
65680: PPUSH
65681: CALL 56434 0 2
// continue ;
65685: GO 65596
// end ; target := [ ] ;
65687: LD_ADDR_VAR 0 7
65691: PUSH
65692: EMPTY
65693: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65694: LD_ADDR_VAR 0 6
65698: PUSH
65699: LD_EXP 23
65703: PUSH
65704: LD_VAR 0 2
65708: ARRAY
65709: PUSH
65710: LD_INT 1
65712: ARRAY
65713: PPUSH
65714: CALL_OW 255
65718: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65719: LD_ADDR_VAR 0 9
65723: PUSH
65724: LD_EXP 23
65728: PUSH
65729: LD_VAR 0 2
65733: ARRAY
65734: PPUSH
65735: LD_INT 2
65737: PUSH
65738: LD_INT 30
65740: PUSH
65741: LD_INT 0
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: LD_INT 30
65750: PUSH
65751: LD_INT 1
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PUSH
65758: EMPTY
65759: LIST
65760: LIST
65761: LIST
65762: PPUSH
65763: CALL_OW 72
65767: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65768: LD_ADDR_VAR 0 3
65772: PUSH
65773: DOUBLE
65774: LD_EXP 39
65778: PUSH
65779: LD_VAR 0 2
65783: ARRAY
65784: INC
65785: ST_TO_ADDR
65786: LD_INT 1
65788: PUSH
65789: FOR_DOWNTO
65790: IFFALSE 66035
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65792: LD_EXP 39
65796: PUSH
65797: LD_VAR 0 2
65801: ARRAY
65802: PUSH
65803: LD_VAR 0 3
65807: ARRAY
65808: PUSH
65809: LD_INT 2
65811: ARRAY
65812: PPUSH
65813: LD_EXP 39
65817: PUSH
65818: LD_VAR 0 2
65822: ARRAY
65823: PUSH
65824: LD_VAR 0 3
65828: ARRAY
65829: PUSH
65830: LD_INT 3
65832: ARRAY
65833: PPUSH
65834: CALL_OW 488
65838: PUSH
65839: LD_EXP 39
65843: PUSH
65844: LD_VAR 0 2
65848: ARRAY
65849: PUSH
65850: LD_VAR 0 3
65854: ARRAY
65855: PUSH
65856: LD_INT 2
65858: ARRAY
65859: PPUSH
65860: LD_EXP 39
65864: PUSH
65865: LD_VAR 0 2
65869: ARRAY
65870: PUSH
65871: LD_VAR 0 3
65875: ARRAY
65876: PUSH
65877: LD_INT 3
65879: ARRAY
65880: PPUSH
65881: CALL_OW 284
65885: PUSH
65886: LD_INT 0
65888: EQUAL
65889: AND
65890: IFFALSE 65945
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65892: LD_ADDR_VAR 0 5
65896: PUSH
65897: LD_EXP 39
65901: PUSH
65902: LD_VAR 0 2
65906: ARRAY
65907: PPUSH
65908: LD_VAR 0 3
65912: PPUSH
65913: CALL_OW 3
65917: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65918: LD_ADDR_EXP 39
65922: PUSH
65923: LD_EXP 39
65927: PPUSH
65928: LD_VAR 0 2
65932: PPUSH
65933: LD_VAR 0 5
65937: PPUSH
65938: CALL_OW 1
65942: ST_TO_ADDR
// continue ;
65943: GO 65789
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65945: LD_VAR 0 6
65949: PPUSH
65950: LD_EXP 39
65954: PUSH
65955: LD_VAR 0 2
65959: ARRAY
65960: PUSH
65961: LD_VAR 0 3
65965: ARRAY
65966: PUSH
65967: LD_INT 2
65969: ARRAY
65970: PPUSH
65971: LD_EXP 39
65975: PUSH
65976: LD_VAR 0 2
65980: ARRAY
65981: PUSH
65982: LD_VAR 0 3
65986: ARRAY
65987: PUSH
65988: LD_INT 3
65990: ARRAY
65991: PPUSH
65992: LD_INT 30
65994: PPUSH
65995: CALL 17048 0 4
65999: PUSH
66000: LD_INT 4
66002: ARRAY
66003: PUSH
66004: LD_INT 0
66006: EQUAL
66007: IFFALSE 66033
// begin target := mc_crates [ i ] [ j ] ;
66009: LD_ADDR_VAR 0 7
66013: PUSH
66014: LD_EXP 39
66018: PUSH
66019: LD_VAR 0 2
66023: ARRAY
66024: PUSH
66025: LD_VAR 0 3
66029: ARRAY
66030: ST_TO_ADDR
// break ;
66031: GO 66035
// end ; end ;
66033: GO 65789
66035: POP
66036: POP
// if not target then
66037: LD_VAR 0 7
66041: NOT
66042: IFFALSE 66046
// continue ;
66044: GO 65596
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66046: LD_ADDR_VAR 0 8
66050: PUSH
66051: LD_EXP 42
66055: PUSH
66056: LD_VAR 0 2
66060: ARRAY
66061: PPUSH
66062: LD_INT 2
66064: PUSH
66065: LD_INT 3
66067: PUSH
66068: LD_INT 58
66070: PUSH
66071: EMPTY
66072: LIST
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: PUSH
66078: LD_INT 61
66080: PUSH
66081: EMPTY
66082: LIST
66083: PUSH
66084: LD_INT 33
66086: PUSH
66087: LD_INT 5
66089: PUSH
66090: EMPTY
66091: LIST
66092: LIST
66093: PUSH
66094: LD_INT 33
66096: PUSH
66097: LD_INT 3
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PUSH
66104: EMPTY
66105: LIST
66106: LIST
66107: LIST
66108: LIST
66109: LIST
66110: PUSH
66111: LD_INT 2
66113: PUSH
66114: LD_INT 34
66116: PUSH
66117: LD_INT 32
66119: PUSH
66120: EMPTY
66121: LIST
66122: LIST
66123: PUSH
66124: LD_INT 34
66126: PUSH
66127: LD_INT 51
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: PUSH
66134: LD_INT 34
66136: PUSH
66137: LD_INT 12
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PPUSH
66154: CALL_OW 72
66158: ST_TO_ADDR
// if not cargo then
66159: LD_VAR 0 8
66163: NOT
66164: IFFALSE 66870
// begin if mc_crates_collector [ i ] < 5 then
66166: LD_EXP 40
66170: PUSH
66171: LD_VAR 0 2
66175: ARRAY
66176: PUSH
66177: LD_INT 5
66179: LESS
66180: IFFALSE 66546
// begin if mc_ape [ i ] then
66182: LD_EXP 52
66186: PUSH
66187: LD_VAR 0 2
66191: ARRAY
66192: IFFALSE 66239
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66194: LD_ADDR_VAR 0 5
66198: PUSH
66199: LD_EXP 52
66203: PUSH
66204: LD_VAR 0 2
66208: ARRAY
66209: PPUSH
66210: LD_INT 25
66212: PUSH
66213: LD_INT 16
66215: PUSH
66216: EMPTY
66217: LIST
66218: LIST
66219: PUSH
66220: LD_INT 24
66222: PUSH
66223: LD_INT 750
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PPUSH
66234: CALL_OW 72
66238: ST_TO_ADDR
// if not tmp then
66239: LD_VAR 0 5
66243: NOT
66244: IFFALSE 66291
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66246: LD_ADDR_VAR 0 5
66250: PUSH
66251: LD_EXP 23
66255: PUSH
66256: LD_VAR 0 2
66260: ARRAY
66261: PPUSH
66262: LD_INT 25
66264: PUSH
66265: LD_INT 2
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PUSH
66272: LD_INT 24
66274: PUSH
66275: LD_INT 750
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PPUSH
66286: CALL_OW 72
66290: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66291: LD_EXP 52
66295: PUSH
66296: LD_VAR 0 2
66300: ARRAY
66301: PUSH
66302: LD_EXP 23
66306: PUSH
66307: LD_VAR 0 2
66311: ARRAY
66312: PPUSH
66313: LD_INT 25
66315: PUSH
66316: LD_INT 2
66318: PUSH
66319: EMPTY
66320: LIST
66321: LIST
66322: PUSH
66323: LD_INT 24
66325: PUSH
66326: LD_INT 750
66328: PUSH
66329: EMPTY
66330: LIST
66331: LIST
66332: PUSH
66333: EMPTY
66334: LIST
66335: LIST
66336: PPUSH
66337: CALL_OW 72
66341: AND
66342: PUSH
66343: LD_VAR 0 5
66347: PUSH
66348: LD_INT 5
66350: LESS
66351: AND
66352: IFFALSE 66434
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66354: LD_ADDR_VAR 0 3
66358: PUSH
66359: LD_EXP 23
66363: PUSH
66364: LD_VAR 0 2
66368: ARRAY
66369: PPUSH
66370: LD_INT 25
66372: PUSH
66373: LD_INT 2
66375: PUSH
66376: EMPTY
66377: LIST
66378: LIST
66379: PUSH
66380: LD_INT 24
66382: PUSH
66383: LD_INT 750
66385: PUSH
66386: EMPTY
66387: LIST
66388: LIST
66389: PUSH
66390: EMPTY
66391: LIST
66392: LIST
66393: PPUSH
66394: CALL_OW 72
66398: PUSH
66399: FOR_IN
66400: IFFALSE 66432
// begin tmp := tmp union j ;
66402: LD_ADDR_VAR 0 5
66406: PUSH
66407: LD_VAR 0 5
66411: PUSH
66412: LD_VAR 0 3
66416: UNION
66417: ST_TO_ADDR
// if tmp >= 5 then
66418: LD_VAR 0 5
66422: PUSH
66423: LD_INT 5
66425: GREATEREQUAL
66426: IFFALSE 66430
// break ;
66428: GO 66432
// end ;
66430: GO 66399
66432: POP
66433: POP
// end ; if not tmp then
66434: LD_VAR 0 5
66438: NOT
66439: IFFALSE 66443
// continue ;
66441: GO 65596
// for j in tmp do
66443: LD_ADDR_VAR 0 3
66447: PUSH
66448: LD_VAR 0 5
66452: PUSH
66453: FOR_IN
66454: IFFALSE 66544
// if not GetTag ( j ) then
66456: LD_VAR 0 3
66460: PPUSH
66461: CALL_OW 110
66465: NOT
66466: IFFALSE 66542
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66468: LD_ADDR_EXP 40
66472: PUSH
66473: LD_EXP 40
66477: PPUSH
66478: LD_VAR 0 2
66482: PUSH
66483: LD_EXP 40
66487: PUSH
66488: LD_VAR 0 2
66492: ARRAY
66493: PUSH
66494: LD_INT 1
66496: PLUS
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: PPUSH
66502: LD_VAR 0 3
66506: PPUSH
66507: CALL 16152 0 3
66511: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66512: LD_VAR 0 3
66516: PPUSH
66517: LD_INT 107
66519: PPUSH
66520: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66524: LD_EXP 40
66528: PUSH
66529: LD_VAR 0 2
66533: ARRAY
66534: PUSH
66535: LD_INT 5
66537: GREATEREQUAL
66538: IFFALSE 66542
// break ;
66540: GO 66544
// end ;
66542: GO 66453
66544: POP
66545: POP
// end ; if mc_crates_collector [ i ] and target then
66546: LD_EXP 40
66550: PUSH
66551: LD_VAR 0 2
66555: ARRAY
66556: PUSH
66557: LD_VAR 0 7
66561: AND
66562: IFFALSE 66868
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66564: LD_EXP 40
66568: PUSH
66569: LD_VAR 0 2
66573: ARRAY
66574: PUSH
66575: LD_VAR 0 7
66579: PUSH
66580: LD_INT 1
66582: ARRAY
66583: LESS
66584: IFFALSE 66604
// tmp := mc_crates_collector [ i ] else
66586: LD_ADDR_VAR 0 5
66590: PUSH
66591: LD_EXP 40
66595: PUSH
66596: LD_VAR 0 2
66600: ARRAY
66601: ST_TO_ADDR
66602: GO 66618
// tmp := target [ 1 ] ;
66604: LD_ADDR_VAR 0 5
66608: PUSH
66609: LD_VAR 0 7
66613: PUSH
66614: LD_INT 1
66616: ARRAY
66617: ST_TO_ADDR
// k := 0 ;
66618: LD_ADDR_VAR 0 4
66622: PUSH
66623: LD_INT 0
66625: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66626: LD_ADDR_VAR 0 3
66630: PUSH
66631: LD_EXP 40
66635: PUSH
66636: LD_VAR 0 2
66640: ARRAY
66641: PUSH
66642: FOR_IN
66643: IFFALSE 66866
// begin k := k + 1 ;
66645: LD_ADDR_VAR 0 4
66649: PUSH
66650: LD_VAR 0 4
66654: PUSH
66655: LD_INT 1
66657: PLUS
66658: ST_TO_ADDR
// if k > tmp then
66659: LD_VAR 0 4
66663: PUSH
66664: LD_VAR 0 5
66668: GREATER
66669: IFFALSE 66673
// break ;
66671: GO 66866
// if not GetClass ( j ) in [ 2 , 16 ] then
66673: LD_VAR 0 3
66677: PPUSH
66678: CALL_OW 257
66682: PUSH
66683: LD_INT 2
66685: PUSH
66686: LD_INT 16
66688: PUSH
66689: EMPTY
66690: LIST
66691: LIST
66692: IN
66693: NOT
66694: IFFALSE 66747
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66696: LD_ADDR_EXP 40
66700: PUSH
66701: LD_EXP 40
66705: PPUSH
66706: LD_VAR 0 2
66710: PPUSH
66711: LD_EXP 40
66715: PUSH
66716: LD_VAR 0 2
66720: ARRAY
66721: PUSH
66722: LD_VAR 0 3
66726: DIFF
66727: PPUSH
66728: CALL_OW 1
66732: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66733: LD_VAR 0 3
66737: PPUSH
66738: LD_INT 0
66740: PPUSH
66741: CALL_OW 109
// continue ;
66745: GO 66642
// end ; if IsInUnit ( j ) then
66747: LD_VAR 0 3
66751: PPUSH
66752: CALL_OW 310
66756: IFFALSE 66767
// ComExitBuilding ( j ) ;
66758: LD_VAR 0 3
66762: PPUSH
66763: CALL_OW 122
// wait ( 3 ) ;
66767: LD_INT 3
66769: PPUSH
66770: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
66774: LD_VAR 0 3
66778: PPUSH
66779: CALL_OW 314
66783: PUSH
66784: LD_VAR 0 6
66788: PPUSH
66789: LD_VAR 0 7
66793: PUSH
66794: LD_INT 2
66796: ARRAY
66797: PPUSH
66798: LD_VAR 0 7
66802: PUSH
66803: LD_INT 3
66805: ARRAY
66806: PPUSH
66807: LD_INT 30
66809: PPUSH
66810: CALL 17048 0 4
66814: PUSH
66815: LD_INT 4
66817: ARRAY
66818: AND
66819: IFFALSE 66837
// ComStandNearbyBuilding ( j , depot ) else
66821: LD_VAR 0 3
66825: PPUSH
66826: LD_VAR 0 9
66830: PPUSH
66831: CALL 12579 0 2
66835: GO 66864
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66837: LD_VAR 0 3
66841: PPUSH
66842: LD_VAR 0 7
66846: PUSH
66847: LD_INT 2
66849: ARRAY
66850: PPUSH
66851: LD_VAR 0 7
66855: PUSH
66856: LD_INT 3
66858: ARRAY
66859: PPUSH
66860: CALL_OW 117
// end ;
66864: GO 66642
66866: POP
66867: POP
// end ; end else
66868: GO 67400
// begin for j in cargo do
66870: LD_ADDR_VAR 0 3
66874: PUSH
66875: LD_VAR 0 8
66879: PUSH
66880: FOR_IN
66881: IFFALSE 67398
// begin if GetTag ( j ) <> 0 then
66883: LD_VAR 0 3
66887: PPUSH
66888: CALL_OW 110
66892: PUSH
66893: LD_INT 0
66895: NONEQUAL
66896: IFFALSE 66900
// continue ;
66898: GO 66880
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66900: LD_VAR 0 3
66904: PPUSH
66905: CALL_OW 256
66909: PUSH
66910: LD_INT 1000
66912: LESS
66913: PUSH
66914: LD_VAR 0 3
66918: PPUSH
66919: LD_EXP 47
66923: PUSH
66924: LD_VAR 0 2
66928: ARRAY
66929: PPUSH
66930: CALL_OW 308
66934: NOT
66935: AND
66936: IFFALSE 66958
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66938: LD_VAR 0 3
66942: PPUSH
66943: LD_EXP 47
66947: PUSH
66948: LD_VAR 0 2
66952: ARRAY
66953: PPUSH
66954: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66958: LD_VAR 0 3
66962: PPUSH
66963: CALL_OW 256
66967: PUSH
66968: LD_INT 1000
66970: LESS
66971: PUSH
66972: LD_VAR 0 3
66976: PPUSH
66977: LD_EXP 47
66981: PUSH
66982: LD_VAR 0 2
66986: ARRAY
66987: PPUSH
66988: CALL_OW 308
66992: AND
66993: IFFALSE 66997
// continue ;
66995: GO 66880
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66997: LD_VAR 0 3
67001: PPUSH
67002: CALL_OW 262
67006: PUSH
67007: LD_INT 2
67009: EQUAL
67010: PUSH
67011: LD_VAR 0 3
67015: PPUSH
67016: CALL_OW 261
67020: PUSH
67021: LD_INT 15
67023: LESS
67024: AND
67025: IFFALSE 67029
// continue ;
67027: GO 66880
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67029: LD_VAR 0 3
67033: PPUSH
67034: CALL_OW 262
67038: PUSH
67039: LD_INT 1
67041: EQUAL
67042: PUSH
67043: LD_VAR 0 3
67047: PPUSH
67048: CALL_OW 261
67052: PUSH
67053: LD_INT 10
67055: LESS
67056: AND
67057: IFFALSE 67337
// begin if not depot then
67059: LD_VAR 0 9
67063: NOT
67064: IFFALSE 67068
// continue ;
67066: GO 66880
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67068: LD_VAR 0 3
67072: PPUSH
67073: LD_VAR 0 9
67077: PPUSH
67078: LD_VAR 0 3
67082: PPUSH
67083: CALL_OW 74
67087: PPUSH
67088: CALL_OW 296
67092: PUSH
67093: LD_INT 6
67095: LESS
67096: IFFALSE 67112
// SetFuel ( j , 100 ) else
67098: LD_VAR 0 3
67102: PPUSH
67103: LD_INT 100
67105: PPUSH
67106: CALL_OW 240
67110: GO 67337
// if GetFuel ( j ) = 0 then
67112: LD_VAR 0 3
67116: PPUSH
67117: CALL_OW 261
67121: PUSH
67122: LD_INT 0
67124: EQUAL
67125: IFFALSE 67337
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67127: LD_ADDR_EXP 42
67131: PUSH
67132: LD_EXP 42
67136: PPUSH
67137: LD_VAR 0 2
67141: PPUSH
67142: LD_EXP 42
67146: PUSH
67147: LD_VAR 0 2
67151: ARRAY
67152: PUSH
67153: LD_VAR 0 3
67157: DIFF
67158: PPUSH
67159: CALL_OW 1
67163: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67164: LD_VAR 0 3
67168: PPUSH
67169: CALL_OW 263
67173: PUSH
67174: LD_INT 1
67176: EQUAL
67177: IFFALSE 67193
// ComExitVehicle ( IsInUnit ( j ) ) ;
67179: LD_VAR 0 3
67183: PPUSH
67184: CALL_OW 310
67188: PPUSH
67189: CALL_OW 121
// if GetControl ( j ) = control_remote then
67193: LD_VAR 0 3
67197: PPUSH
67198: CALL_OW 263
67202: PUSH
67203: LD_INT 2
67205: EQUAL
67206: IFFALSE 67217
// ComUnlink ( j ) ;
67208: LD_VAR 0 3
67212: PPUSH
67213: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67217: LD_ADDR_VAR 0 10
67221: PUSH
67222: LD_VAR 0 2
67226: PPUSH
67227: LD_INT 3
67229: PPUSH
67230: CALL 77004 0 2
67234: ST_TO_ADDR
// if fac then
67235: LD_VAR 0 10
67239: IFFALSE 67335
// begin for k in fac do
67241: LD_ADDR_VAR 0 4
67245: PUSH
67246: LD_VAR 0 10
67250: PUSH
67251: FOR_IN
67252: IFFALSE 67333
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67254: LD_ADDR_VAR 0 11
67258: PUSH
67259: LD_VAR 0 10
67263: PPUSH
67264: LD_VAR 0 3
67268: PPUSH
67269: CALL_OW 265
67273: PPUSH
67274: LD_VAR 0 3
67278: PPUSH
67279: CALL_OW 262
67283: PPUSH
67284: LD_VAR 0 3
67288: PPUSH
67289: CALL_OW 263
67293: PPUSH
67294: LD_VAR 0 3
67298: PPUSH
67299: CALL_OW 264
67303: PPUSH
67304: CALL 13650 0 5
67308: ST_TO_ADDR
// if components then
67309: LD_VAR 0 11
67313: IFFALSE 67331
// begin MC_InsertProduceList ( i , components ) ;
67315: LD_VAR 0 2
67319: PPUSH
67320: LD_VAR 0 11
67324: PPUSH
67325: CALL 76549 0 2
// break ;
67329: GO 67333
// end ; end ;
67331: GO 67251
67333: POP
67334: POP
// end ; continue ;
67335: GO 66880
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67337: LD_VAR 0 3
67341: PPUSH
67342: LD_INT 1
67344: PPUSH
67345: CALL_OW 289
67349: PUSH
67350: LD_INT 100
67352: LESS
67353: PUSH
67354: LD_VAR 0 3
67358: PPUSH
67359: CALL_OW 314
67363: NOT
67364: AND
67365: IFFALSE 67394
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67367: LD_VAR 0 3
67371: PPUSH
67372: LD_VAR 0 7
67376: PUSH
67377: LD_INT 2
67379: ARRAY
67380: PPUSH
67381: LD_VAR 0 7
67385: PUSH
67386: LD_INT 3
67388: ARRAY
67389: PPUSH
67390: CALL_OW 117
// break ;
67394: GO 67398
// end ;
67396: GO 66880
67398: POP
67399: POP
// end ; end ;
67400: GO 65596
67402: POP
67403: POP
// end ;
67404: LD_VAR 0 1
67408: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67409: LD_INT 0
67411: PPUSH
67412: PPUSH
67413: PPUSH
67414: PPUSH
// if not mc_bases then
67415: LD_EXP 23
67419: NOT
67420: IFFALSE 67424
// exit ;
67422: GO 67585
// for i = 1 to mc_bases do
67424: LD_ADDR_VAR 0 2
67428: PUSH
67429: DOUBLE
67430: LD_INT 1
67432: DEC
67433: ST_TO_ADDR
67434: LD_EXP 23
67438: PUSH
67439: FOR_TO
67440: IFFALSE 67583
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67442: LD_ADDR_VAR 0 4
67446: PUSH
67447: LD_EXP 42
67451: PUSH
67452: LD_VAR 0 2
67456: ARRAY
67457: PUSH
67458: LD_EXP 45
67462: PUSH
67463: LD_VAR 0 2
67467: ARRAY
67468: UNION
67469: PPUSH
67470: LD_INT 33
67472: PUSH
67473: LD_INT 2
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: PPUSH
67480: CALL_OW 72
67484: ST_TO_ADDR
// if tmp then
67485: LD_VAR 0 4
67489: IFFALSE 67581
// for j in tmp do
67491: LD_ADDR_VAR 0 3
67495: PUSH
67496: LD_VAR 0 4
67500: PUSH
67501: FOR_IN
67502: IFFALSE 67579
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67504: LD_VAR 0 3
67508: PPUSH
67509: CALL_OW 312
67513: NOT
67514: PUSH
67515: LD_VAR 0 3
67519: PPUSH
67520: CALL_OW 256
67524: PUSH
67525: LD_INT 250
67527: GREATEREQUAL
67528: AND
67529: IFFALSE 67542
// Connect ( j ) else
67531: LD_VAR 0 3
67535: PPUSH
67536: CALL 19121 0 1
67540: GO 67577
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67542: LD_VAR 0 3
67546: PPUSH
67547: CALL_OW 256
67551: PUSH
67552: LD_INT 250
67554: LESS
67555: PUSH
67556: LD_VAR 0 3
67560: PPUSH
67561: CALL_OW 312
67565: AND
67566: IFFALSE 67577
// ComUnlink ( j ) ;
67568: LD_VAR 0 3
67572: PPUSH
67573: CALL_OW 136
67577: GO 67501
67579: POP
67580: POP
// end ;
67581: GO 67439
67583: POP
67584: POP
// end ;
67585: LD_VAR 0 1
67589: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67590: LD_INT 0
67592: PPUSH
67593: PPUSH
67594: PPUSH
67595: PPUSH
67596: PPUSH
// if not mc_bases then
67597: LD_EXP 23
67601: NOT
67602: IFFALSE 67606
// exit ;
67604: GO 68051
// for i = 1 to mc_bases do
67606: LD_ADDR_VAR 0 2
67610: PUSH
67611: DOUBLE
67612: LD_INT 1
67614: DEC
67615: ST_TO_ADDR
67616: LD_EXP 23
67620: PUSH
67621: FOR_TO
67622: IFFALSE 68049
// begin if not mc_produce [ i ] then
67624: LD_EXP 44
67628: PUSH
67629: LD_VAR 0 2
67633: ARRAY
67634: NOT
67635: IFFALSE 67639
// continue ;
67637: GO 67621
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67639: LD_ADDR_VAR 0 5
67643: PUSH
67644: LD_EXP 23
67648: PUSH
67649: LD_VAR 0 2
67653: ARRAY
67654: PPUSH
67655: LD_INT 30
67657: PUSH
67658: LD_INT 3
67660: PUSH
67661: EMPTY
67662: LIST
67663: LIST
67664: PPUSH
67665: CALL_OW 72
67669: ST_TO_ADDR
// if not fac then
67670: LD_VAR 0 5
67674: NOT
67675: IFFALSE 67679
// continue ;
67677: GO 67621
// for j in fac do
67679: LD_ADDR_VAR 0 3
67683: PUSH
67684: LD_VAR 0 5
67688: PUSH
67689: FOR_IN
67690: IFFALSE 68045
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67692: LD_VAR 0 3
67696: PPUSH
67697: CALL_OW 461
67701: PUSH
67702: LD_INT 2
67704: NONEQUAL
67705: PUSH
67706: LD_VAR 0 3
67710: PPUSH
67711: LD_INT 15
67713: PPUSH
67714: CALL 18749 0 2
67718: PUSH
67719: LD_INT 4
67721: ARRAY
67722: OR
67723: IFFALSE 67727
// continue ;
67725: GO 67689
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67727: LD_VAR 0 3
67731: PPUSH
67732: LD_EXP 44
67736: PUSH
67737: LD_VAR 0 2
67741: ARRAY
67742: PUSH
67743: LD_INT 1
67745: ARRAY
67746: PUSH
67747: LD_INT 1
67749: ARRAY
67750: PPUSH
67751: LD_EXP 44
67755: PUSH
67756: LD_VAR 0 2
67760: ARRAY
67761: PUSH
67762: LD_INT 1
67764: ARRAY
67765: PUSH
67766: LD_INT 2
67768: ARRAY
67769: PPUSH
67770: LD_EXP 44
67774: PUSH
67775: LD_VAR 0 2
67779: ARRAY
67780: PUSH
67781: LD_INT 1
67783: ARRAY
67784: PUSH
67785: LD_INT 3
67787: ARRAY
67788: PPUSH
67789: LD_EXP 44
67793: PUSH
67794: LD_VAR 0 2
67798: ARRAY
67799: PUSH
67800: LD_INT 1
67802: ARRAY
67803: PUSH
67804: LD_INT 4
67806: ARRAY
67807: PPUSH
67808: CALL_OW 448
67812: PUSH
67813: LD_VAR 0 3
67817: PPUSH
67818: LD_EXP 44
67822: PUSH
67823: LD_VAR 0 2
67827: ARRAY
67828: PUSH
67829: LD_INT 1
67831: ARRAY
67832: PUSH
67833: LD_INT 1
67835: ARRAY
67836: PUSH
67837: LD_EXP 44
67841: PUSH
67842: LD_VAR 0 2
67846: ARRAY
67847: PUSH
67848: LD_INT 1
67850: ARRAY
67851: PUSH
67852: LD_INT 2
67854: ARRAY
67855: PUSH
67856: LD_EXP 44
67860: PUSH
67861: LD_VAR 0 2
67865: ARRAY
67866: PUSH
67867: LD_INT 1
67869: ARRAY
67870: PUSH
67871: LD_INT 3
67873: ARRAY
67874: PUSH
67875: LD_EXP 44
67879: PUSH
67880: LD_VAR 0 2
67884: ARRAY
67885: PUSH
67886: LD_INT 1
67888: ARRAY
67889: PUSH
67890: LD_INT 4
67892: ARRAY
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: LIST
67898: LIST
67899: PPUSH
67900: CALL 22516 0 2
67904: AND
67905: IFFALSE 68043
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67907: LD_VAR 0 3
67911: PPUSH
67912: LD_EXP 44
67916: PUSH
67917: LD_VAR 0 2
67921: ARRAY
67922: PUSH
67923: LD_INT 1
67925: ARRAY
67926: PUSH
67927: LD_INT 1
67929: ARRAY
67930: PPUSH
67931: LD_EXP 44
67935: PUSH
67936: LD_VAR 0 2
67940: ARRAY
67941: PUSH
67942: LD_INT 1
67944: ARRAY
67945: PUSH
67946: LD_INT 2
67948: ARRAY
67949: PPUSH
67950: LD_EXP 44
67954: PUSH
67955: LD_VAR 0 2
67959: ARRAY
67960: PUSH
67961: LD_INT 1
67963: ARRAY
67964: PUSH
67965: LD_INT 3
67967: ARRAY
67968: PPUSH
67969: LD_EXP 44
67973: PUSH
67974: LD_VAR 0 2
67978: ARRAY
67979: PUSH
67980: LD_INT 1
67982: ARRAY
67983: PUSH
67984: LD_INT 4
67986: ARRAY
67987: PPUSH
67988: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67992: LD_ADDR_VAR 0 4
67996: PUSH
67997: LD_EXP 44
68001: PUSH
68002: LD_VAR 0 2
68006: ARRAY
68007: PPUSH
68008: LD_INT 1
68010: PPUSH
68011: CALL_OW 3
68015: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68016: LD_ADDR_EXP 44
68020: PUSH
68021: LD_EXP 44
68025: PPUSH
68026: LD_VAR 0 2
68030: PPUSH
68031: LD_VAR 0 4
68035: PPUSH
68036: CALL_OW 1
68040: ST_TO_ADDR
// break ;
68041: GO 68045
// end ; end ;
68043: GO 67689
68045: POP
68046: POP
// end ;
68047: GO 67621
68049: POP
68050: POP
// end ;
68051: LD_VAR 0 1
68055: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68056: LD_INT 0
68058: PPUSH
68059: PPUSH
68060: PPUSH
// if not mc_bases then
68061: LD_EXP 23
68065: NOT
68066: IFFALSE 68070
// exit ;
68068: GO 68159
// for i = 1 to mc_bases do
68070: LD_ADDR_VAR 0 2
68074: PUSH
68075: DOUBLE
68076: LD_INT 1
68078: DEC
68079: ST_TO_ADDR
68080: LD_EXP 23
68084: PUSH
68085: FOR_TO
68086: IFFALSE 68157
// begin if mc_attack [ i ] then
68088: LD_EXP 43
68092: PUSH
68093: LD_VAR 0 2
68097: ARRAY
68098: IFFALSE 68155
// begin tmp := mc_attack [ i ] [ 1 ] ;
68100: LD_ADDR_VAR 0 3
68104: PUSH
68105: LD_EXP 43
68109: PUSH
68110: LD_VAR 0 2
68114: ARRAY
68115: PUSH
68116: LD_INT 1
68118: ARRAY
68119: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68120: LD_ADDR_EXP 43
68124: PUSH
68125: LD_EXP 43
68129: PPUSH
68130: LD_VAR 0 2
68134: PPUSH
68135: EMPTY
68136: PPUSH
68137: CALL_OW 1
68141: ST_TO_ADDR
// Attack ( tmp ) ;
68142: LD_VAR 0 3
68146: PPUSH
68147: CALL 82937 0 1
// exit ;
68151: POP
68152: POP
68153: GO 68159
// end ; end ;
68155: GO 68085
68157: POP
68158: POP
// end ;
68159: LD_VAR 0 1
68163: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68164: LD_INT 0
68166: PPUSH
68167: PPUSH
68168: PPUSH
68169: PPUSH
68170: PPUSH
68171: PPUSH
68172: PPUSH
// if not mc_bases then
68173: LD_EXP 23
68177: NOT
68178: IFFALSE 68182
// exit ;
68180: GO 69039
// for i = 1 to mc_bases do
68182: LD_ADDR_VAR 0 2
68186: PUSH
68187: DOUBLE
68188: LD_INT 1
68190: DEC
68191: ST_TO_ADDR
68192: LD_EXP 23
68196: PUSH
68197: FOR_TO
68198: IFFALSE 69037
// begin if not mc_bases [ i ] then
68200: LD_EXP 23
68204: PUSH
68205: LD_VAR 0 2
68209: ARRAY
68210: NOT
68211: IFFALSE 68215
// continue ;
68213: GO 68197
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68215: LD_ADDR_VAR 0 7
68219: PUSH
68220: LD_EXP 23
68224: PUSH
68225: LD_VAR 0 2
68229: ARRAY
68230: PUSH
68231: LD_INT 1
68233: ARRAY
68234: PPUSH
68235: CALL 12801 0 1
68239: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68240: LD_ADDR_EXP 46
68244: PUSH
68245: LD_EXP 46
68249: PPUSH
68250: LD_VAR 0 2
68254: PPUSH
68255: LD_EXP 23
68259: PUSH
68260: LD_VAR 0 2
68264: ARRAY
68265: PUSH
68266: LD_INT 1
68268: ARRAY
68269: PPUSH
68270: CALL_OW 255
68274: PPUSH
68275: LD_EXP 48
68279: PUSH
68280: LD_VAR 0 2
68284: ARRAY
68285: PPUSH
68286: CALL 12766 0 2
68290: PPUSH
68291: CALL_OW 1
68295: ST_TO_ADDR
// if not mc_scan [ i ] then
68296: LD_EXP 46
68300: PUSH
68301: LD_VAR 0 2
68305: ARRAY
68306: NOT
68307: IFFALSE 68485
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68309: LD_ADDR_EXP 66
68313: PUSH
68314: LD_EXP 66
68318: PPUSH
68319: LD_VAR 0 2
68323: PPUSH
68324: LD_INT 0
68326: PPUSH
68327: CALL_OW 1
68331: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68332: LD_ADDR_VAR 0 4
68336: PUSH
68337: LD_EXP 23
68341: PUSH
68342: LD_VAR 0 2
68346: ARRAY
68347: PPUSH
68348: LD_INT 2
68350: PUSH
68351: LD_INT 25
68353: PUSH
68354: LD_INT 5
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 25
68363: PUSH
68364: LD_INT 8
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 25
68373: PUSH
68374: LD_INT 9
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: EMPTY
68382: LIST
68383: LIST
68384: LIST
68385: LIST
68386: PPUSH
68387: CALL_OW 72
68391: ST_TO_ADDR
// if not tmp then
68392: LD_VAR 0 4
68396: NOT
68397: IFFALSE 68401
// continue ;
68399: GO 68197
// for j in tmp do
68401: LD_ADDR_VAR 0 3
68405: PUSH
68406: LD_VAR 0 4
68410: PUSH
68411: FOR_IN
68412: IFFALSE 68483
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68414: LD_VAR 0 3
68418: PPUSH
68419: CALL_OW 310
68423: PPUSH
68424: CALL_OW 266
68428: PUSH
68429: LD_INT 5
68431: EQUAL
68432: PUSH
68433: LD_VAR 0 3
68437: PPUSH
68438: CALL_OW 257
68442: PUSH
68443: LD_INT 1
68445: EQUAL
68446: AND
68447: PUSH
68448: LD_VAR 0 3
68452: PPUSH
68453: CALL_OW 459
68457: NOT
68458: AND
68459: PUSH
68460: LD_VAR 0 7
68464: AND
68465: IFFALSE 68481
// ComChangeProfession ( j , class ) ;
68467: LD_VAR 0 3
68471: PPUSH
68472: LD_VAR 0 7
68476: PPUSH
68477: CALL_OW 123
68481: GO 68411
68483: POP
68484: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
68485: LD_EXP 46
68489: PUSH
68490: LD_VAR 0 2
68494: ARRAY
68495: PUSH
68496: LD_EXP 66
68500: PUSH
68501: LD_VAR 0 2
68505: ARRAY
68506: NOT
68507: AND
68508: PUSH
68509: LD_EXP 45
68513: PUSH
68514: LD_VAR 0 2
68518: ARRAY
68519: NOT
68520: AND
68521: PUSH
68522: LD_EXP 23
68526: PUSH
68527: LD_VAR 0 2
68531: ARRAY
68532: PPUSH
68533: LD_INT 50
68535: PUSH
68536: EMPTY
68537: LIST
68538: PUSH
68539: LD_INT 2
68541: PUSH
68542: LD_INT 30
68544: PUSH
68545: LD_INT 32
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: PUSH
68552: LD_INT 30
68554: PUSH
68555: LD_INT 33
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: PUSH
68562: LD_INT 30
68564: PUSH
68565: LD_INT 4
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 30
68574: PUSH
68575: LD_INT 5
68577: PUSH
68578: EMPTY
68579: LIST
68580: LIST
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: PPUSH
68593: CALL_OW 72
68597: PUSH
68598: LD_INT 4
68600: LESS
68601: PUSH
68602: LD_EXP 23
68606: PUSH
68607: LD_VAR 0 2
68611: ARRAY
68612: PPUSH
68613: LD_INT 3
68615: PUSH
68616: LD_INT 24
68618: PUSH
68619: LD_INT 1000
68621: PUSH
68622: EMPTY
68623: LIST
68624: LIST
68625: PUSH
68626: EMPTY
68627: LIST
68628: LIST
68629: PUSH
68630: LD_INT 2
68632: PUSH
68633: LD_INT 30
68635: PUSH
68636: LD_INT 0
68638: PUSH
68639: EMPTY
68640: LIST
68641: LIST
68642: PUSH
68643: LD_INT 30
68645: PUSH
68646: LD_INT 1
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: LIST
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PPUSH
68662: CALL_OW 72
68666: OR
68667: AND
68668: IFFALSE 68919
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68670: LD_ADDR_EXP 66
68674: PUSH
68675: LD_EXP 66
68679: PPUSH
68680: LD_VAR 0 2
68684: PPUSH
68685: LD_INT 1
68687: PPUSH
68688: CALL_OW 1
68692: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68693: LD_ADDR_VAR 0 4
68697: PUSH
68698: LD_EXP 23
68702: PUSH
68703: LD_VAR 0 2
68707: ARRAY
68708: PPUSH
68709: LD_INT 2
68711: PUSH
68712: LD_INT 25
68714: PUSH
68715: LD_INT 1
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 25
68724: PUSH
68725: LD_INT 5
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: PUSH
68732: LD_INT 25
68734: PUSH
68735: LD_INT 8
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: LD_INT 25
68744: PUSH
68745: LD_INT 9
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: PPUSH
68759: CALL_OW 72
68763: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68764: LD_ADDR_VAR 0 4
68768: PUSH
68769: LD_VAR 0 4
68773: PUSH
68774: LD_VAR 0 4
68778: PPUSH
68779: LD_INT 18
68781: PPUSH
68782: CALL 46038 0 2
68786: DIFF
68787: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68788: LD_VAR 0 4
68792: NOT
68793: PUSH
68794: LD_EXP 23
68798: PUSH
68799: LD_VAR 0 2
68803: ARRAY
68804: PPUSH
68805: LD_INT 2
68807: PUSH
68808: LD_INT 30
68810: PUSH
68811: LD_INT 4
68813: PUSH
68814: EMPTY
68815: LIST
68816: LIST
68817: PUSH
68818: LD_INT 30
68820: PUSH
68821: LD_INT 5
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: LIST
68832: PPUSH
68833: CALL_OW 72
68837: NOT
68838: AND
68839: IFFALSE 68901
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
68841: LD_ADDR_VAR 0 4
68845: PUSH
68846: LD_EXP 23
68850: PUSH
68851: LD_VAR 0 2
68855: ARRAY
68856: PPUSH
68857: LD_INT 2
68859: PUSH
68860: LD_INT 25
68862: PUSH
68863: LD_INT 2
68865: PUSH
68866: EMPTY
68867: LIST
68868: LIST
68869: PUSH
68870: LD_INT 25
68872: PUSH
68873: LD_INT 3
68875: PUSH
68876: EMPTY
68877: LIST
68878: LIST
68879: PUSH
68880: LD_INT 25
68882: PUSH
68883: LD_INT 4
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: EMPTY
68891: LIST
68892: LIST
68893: LIST
68894: LIST
68895: PPUSH
68896: CALL_OW 72
68900: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
68901: LD_VAR 0 2
68905: PPUSH
68906: LD_VAR 0 4
68910: PPUSH
68911: CALL 87646 0 2
// exit ;
68915: POP
68916: POP
68917: GO 69039
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
68919: LD_EXP 46
68923: PUSH
68924: LD_VAR 0 2
68928: ARRAY
68929: PUSH
68930: LD_EXP 66
68934: PUSH
68935: LD_VAR 0 2
68939: ARRAY
68940: NOT
68941: AND
68942: PUSH
68943: LD_EXP 45
68947: PUSH
68948: LD_VAR 0 2
68952: ARRAY
68953: AND
68954: IFFALSE 69035
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68956: LD_ADDR_EXP 66
68960: PUSH
68961: LD_EXP 66
68965: PPUSH
68966: LD_VAR 0 2
68970: PPUSH
68971: LD_INT 1
68973: PPUSH
68974: CALL_OW 1
68978: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
68979: LD_ADDR_VAR 0 4
68983: PUSH
68984: LD_EXP 45
68988: PUSH
68989: LD_VAR 0 2
68993: ARRAY
68994: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68995: LD_ADDR_EXP 45
68999: PUSH
69000: LD_EXP 45
69004: PPUSH
69005: LD_VAR 0 2
69009: PPUSH
69010: EMPTY
69011: PPUSH
69012: CALL_OW 1
69016: ST_TO_ADDR
// Defend ( i , tmp ) ;
69017: LD_VAR 0 2
69021: PPUSH
69022: LD_VAR 0 4
69026: PPUSH
69027: CALL 88242 0 2
// exit ;
69031: POP
69032: POP
69033: GO 69039
// end ; end ;
69035: GO 68197
69037: POP
69038: POP
// end ;
69039: LD_VAR 0 1
69043: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69044: LD_INT 0
69046: PPUSH
69047: PPUSH
69048: PPUSH
69049: PPUSH
69050: PPUSH
69051: PPUSH
69052: PPUSH
69053: PPUSH
69054: PPUSH
69055: PPUSH
69056: PPUSH
// if not mc_bases then
69057: LD_EXP 23
69061: NOT
69062: IFFALSE 69066
// exit ;
69064: GO 70153
// for i = 1 to mc_bases do
69066: LD_ADDR_VAR 0 2
69070: PUSH
69071: DOUBLE
69072: LD_INT 1
69074: DEC
69075: ST_TO_ADDR
69076: LD_EXP 23
69080: PUSH
69081: FOR_TO
69082: IFFALSE 70151
// begin tmp := mc_lab [ i ] ;
69084: LD_ADDR_VAR 0 6
69088: PUSH
69089: LD_EXP 56
69093: PUSH
69094: LD_VAR 0 2
69098: ARRAY
69099: ST_TO_ADDR
// if not tmp then
69100: LD_VAR 0 6
69104: NOT
69105: IFFALSE 69109
// continue ;
69107: GO 69081
// idle_lab := 0 ;
69109: LD_ADDR_VAR 0 11
69113: PUSH
69114: LD_INT 0
69116: ST_TO_ADDR
// for j in tmp do
69117: LD_ADDR_VAR 0 3
69121: PUSH
69122: LD_VAR 0 6
69126: PUSH
69127: FOR_IN
69128: IFFALSE 70147
// begin researching := false ;
69130: LD_ADDR_VAR 0 10
69134: PUSH
69135: LD_INT 0
69137: ST_TO_ADDR
// side := GetSide ( j ) ;
69138: LD_ADDR_VAR 0 4
69142: PUSH
69143: LD_VAR 0 3
69147: PPUSH
69148: CALL_OW 255
69152: ST_TO_ADDR
// if not mc_tech [ side ] then
69153: LD_EXP 50
69157: PUSH
69158: LD_VAR 0 4
69162: ARRAY
69163: NOT
69164: IFFALSE 69168
// continue ;
69166: GO 69127
// if BuildingStatus ( j ) = bs_idle then
69168: LD_VAR 0 3
69172: PPUSH
69173: CALL_OW 461
69177: PUSH
69178: LD_INT 2
69180: EQUAL
69181: IFFALSE 69369
// begin if idle_lab and UnitsInside ( j ) < 6 then
69183: LD_VAR 0 11
69187: PUSH
69188: LD_VAR 0 3
69192: PPUSH
69193: CALL_OW 313
69197: PUSH
69198: LD_INT 6
69200: LESS
69201: AND
69202: IFFALSE 69273
// begin tmp2 := UnitsInside ( idle_lab ) ;
69204: LD_ADDR_VAR 0 9
69208: PUSH
69209: LD_VAR 0 11
69213: PPUSH
69214: CALL_OW 313
69218: ST_TO_ADDR
// if tmp2 then
69219: LD_VAR 0 9
69223: IFFALSE 69265
// for x in tmp2 do
69225: LD_ADDR_VAR 0 7
69229: PUSH
69230: LD_VAR 0 9
69234: PUSH
69235: FOR_IN
69236: IFFALSE 69263
// begin ComExitBuilding ( x ) ;
69238: LD_VAR 0 7
69242: PPUSH
69243: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69247: LD_VAR 0 7
69251: PPUSH
69252: LD_VAR 0 3
69256: PPUSH
69257: CALL_OW 180
// end ;
69261: GO 69235
69263: POP
69264: POP
// idle_lab := 0 ;
69265: LD_ADDR_VAR 0 11
69269: PUSH
69270: LD_INT 0
69272: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69273: LD_ADDR_VAR 0 5
69277: PUSH
69278: LD_EXP 50
69282: PUSH
69283: LD_VAR 0 4
69287: ARRAY
69288: PUSH
69289: FOR_IN
69290: IFFALSE 69350
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69292: LD_VAR 0 3
69296: PPUSH
69297: LD_VAR 0 5
69301: PPUSH
69302: CALL_OW 430
69306: PUSH
69307: LD_VAR 0 4
69311: PPUSH
69312: LD_VAR 0 5
69316: PPUSH
69317: CALL 11871 0 2
69321: AND
69322: IFFALSE 69348
// begin researching := true ;
69324: LD_ADDR_VAR 0 10
69328: PUSH
69329: LD_INT 1
69331: ST_TO_ADDR
// ComResearch ( j , t ) ;
69332: LD_VAR 0 3
69336: PPUSH
69337: LD_VAR 0 5
69341: PPUSH
69342: CALL_OW 124
// break ;
69346: GO 69350
// end ;
69348: GO 69289
69350: POP
69351: POP
// if not researching then
69352: LD_VAR 0 10
69356: NOT
69357: IFFALSE 69369
// idle_lab := j ;
69359: LD_ADDR_VAR 0 11
69363: PUSH
69364: LD_VAR 0 3
69368: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69369: LD_VAR 0 3
69373: PPUSH
69374: CALL_OW 461
69378: PUSH
69379: LD_INT 10
69381: EQUAL
69382: IFFALSE 69970
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69384: LD_EXP 52
69388: PUSH
69389: LD_VAR 0 2
69393: ARRAY
69394: NOT
69395: PUSH
69396: LD_EXP 53
69400: PUSH
69401: LD_VAR 0 2
69405: ARRAY
69406: NOT
69407: AND
69408: PUSH
69409: LD_EXP 50
69413: PUSH
69414: LD_VAR 0 4
69418: ARRAY
69419: PUSH
69420: LD_INT 1
69422: GREATER
69423: AND
69424: IFFALSE 69555
// begin ComCancel ( j ) ;
69426: LD_VAR 0 3
69430: PPUSH
69431: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69435: LD_ADDR_EXP 50
69439: PUSH
69440: LD_EXP 50
69444: PPUSH
69445: LD_VAR 0 4
69449: PPUSH
69450: LD_EXP 50
69454: PUSH
69455: LD_VAR 0 4
69459: ARRAY
69460: PPUSH
69461: LD_EXP 50
69465: PUSH
69466: LD_VAR 0 4
69470: ARRAY
69471: PUSH
69472: LD_INT 1
69474: MINUS
69475: PPUSH
69476: LD_EXP 50
69480: PUSH
69481: LD_VAR 0 4
69485: ARRAY
69486: PPUSH
69487: LD_INT 0
69489: PPUSH
69490: CALL 15570 0 4
69494: PPUSH
69495: CALL_OW 1
69499: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69500: LD_ADDR_EXP 50
69504: PUSH
69505: LD_EXP 50
69509: PPUSH
69510: LD_VAR 0 4
69514: PPUSH
69515: LD_EXP 50
69519: PUSH
69520: LD_VAR 0 4
69524: ARRAY
69525: PPUSH
69526: LD_EXP 50
69530: PUSH
69531: LD_VAR 0 4
69535: ARRAY
69536: PPUSH
69537: LD_INT 1
69539: PPUSH
69540: LD_INT 0
69542: PPUSH
69543: CALL 15570 0 4
69547: PPUSH
69548: CALL_OW 1
69552: ST_TO_ADDR
// continue ;
69553: GO 69127
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69555: LD_EXP 52
69559: PUSH
69560: LD_VAR 0 2
69564: ARRAY
69565: PUSH
69566: LD_EXP 53
69570: PUSH
69571: LD_VAR 0 2
69575: ARRAY
69576: NOT
69577: AND
69578: IFFALSE 69705
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69580: LD_ADDR_EXP 53
69584: PUSH
69585: LD_EXP 53
69589: PPUSH
69590: LD_VAR 0 2
69594: PUSH
69595: LD_EXP 53
69599: PUSH
69600: LD_VAR 0 2
69604: ARRAY
69605: PUSH
69606: LD_INT 1
69608: PLUS
69609: PUSH
69610: EMPTY
69611: LIST
69612: LIST
69613: PPUSH
69614: LD_EXP 52
69618: PUSH
69619: LD_VAR 0 2
69623: ARRAY
69624: PUSH
69625: LD_INT 1
69627: ARRAY
69628: PPUSH
69629: CALL 16152 0 3
69633: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69634: LD_EXP 52
69638: PUSH
69639: LD_VAR 0 2
69643: ARRAY
69644: PUSH
69645: LD_INT 1
69647: ARRAY
69648: PPUSH
69649: LD_INT 112
69651: PPUSH
69652: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69656: LD_ADDR_VAR 0 9
69660: PUSH
69661: LD_EXP 52
69665: PUSH
69666: LD_VAR 0 2
69670: ARRAY
69671: PPUSH
69672: LD_INT 1
69674: PPUSH
69675: CALL_OW 3
69679: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69680: LD_ADDR_EXP 52
69684: PUSH
69685: LD_EXP 52
69689: PPUSH
69690: LD_VAR 0 2
69694: PPUSH
69695: LD_VAR 0 9
69699: PPUSH
69700: CALL_OW 1
69704: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69705: LD_EXP 52
69709: PUSH
69710: LD_VAR 0 2
69714: ARRAY
69715: PUSH
69716: LD_EXP 53
69720: PUSH
69721: LD_VAR 0 2
69725: ARRAY
69726: AND
69727: PUSH
69728: LD_EXP 53
69732: PUSH
69733: LD_VAR 0 2
69737: ARRAY
69738: PUSH
69739: LD_INT 1
69741: ARRAY
69742: PPUSH
69743: CALL_OW 310
69747: NOT
69748: AND
69749: PUSH
69750: LD_VAR 0 3
69754: PPUSH
69755: CALL_OW 313
69759: PUSH
69760: LD_INT 6
69762: EQUAL
69763: AND
69764: IFFALSE 69820
// begin tmp2 := UnitsInside ( j ) ;
69766: LD_ADDR_VAR 0 9
69770: PUSH
69771: LD_VAR 0 3
69775: PPUSH
69776: CALL_OW 313
69780: ST_TO_ADDR
// if tmp2 = 6 then
69781: LD_VAR 0 9
69785: PUSH
69786: LD_INT 6
69788: EQUAL
69789: IFFALSE 69820
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69791: LD_VAR 0 9
69795: PUSH
69796: LD_INT 1
69798: ARRAY
69799: PPUSH
69800: LD_INT 112
69802: PPUSH
69803: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69807: LD_VAR 0 9
69811: PUSH
69812: LD_INT 1
69814: ARRAY
69815: PPUSH
69816: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69820: LD_EXP 53
69824: PUSH
69825: LD_VAR 0 2
69829: ARRAY
69830: PUSH
69831: LD_EXP 53
69835: PUSH
69836: LD_VAR 0 2
69840: ARRAY
69841: PUSH
69842: LD_INT 1
69844: ARRAY
69845: PPUSH
69846: CALL_OW 314
69850: NOT
69851: AND
69852: PUSH
69853: LD_EXP 53
69857: PUSH
69858: LD_VAR 0 2
69862: ARRAY
69863: PUSH
69864: LD_INT 1
69866: ARRAY
69867: PPUSH
69868: CALL_OW 310
69872: NOT
69873: AND
69874: IFFALSE 69900
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69876: LD_EXP 53
69880: PUSH
69881: LD_VAR 0 2
69885: ARRAY
69886: PUSH
69887: LD_INT 1
69889: ARRAY
69890: PPUSH
69891: LD_VAR 0 3
69895: PPUSH
69896: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69900: LD_EXP 53
69904: PUSH
69905: LD_VAR 0 2
69909: ARRAY
69910: PUSH
69911: LD_INT 1
69913: ARRAY
69914: PPUSH
69915: CALL_OW 310
69919: PUSH
69920: LD_EXP 53
69924: PUSH
69925: LD_VAR 0 2
69929: ARRAY
69930: PUSH
69931: LD_INT 1
69933: ARRAY
69934: PPUSH
69935: CALL_OW 310
69939: PPUSH
69940: CALL_OW 461
69944: PUSH
69945: LD_INT 3
69947: NONEQUAL
69948: AND
69949: IFFALSE 69970
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69951: LD_EXP 53
69955: PUSH
69956: LD_VAR 0 2
69960: ARRAY
69961: PUSH
69962: LD_INT 1
69964: ARRAY
69965: PPUSH
69966: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69970: LD_VAR 0 3
69974: PPUSH
69975: CALL_OW 461
69979: PUSH
69980: LD_INT 6
69982: EQUAL
69983: PUSH
69984: LD_VAR 0 6
69988: PUSH
69989: LD_INT 1
69991: GREATER
69992: AND
69993: IFFALSE 70145
// begin sci := [ ] ;
69995: LD_ADDR_VAR 0 8
69999: PUSH
70000: EMPTY
70001: ST_TO_ADDR
// for x in ( tmp diff j ) do
70002: LD_ADDR_VAR 0 7
70006: PUSH
70007: LD_VAR 0 6
70011: PUSH
70012: LD_VAR 0 3
70016: DIFF
70017: PUSH
70018: FOR_IN
70019: IFFALSE 70071
// begin if sci = 6 then
70021: LD_VAR 0 8
70025: PUSH
70026: LD_INT 6
70028: EQUAL
70029: IFFALSE 70033
// break ;
70031: GO 70071
// if BuildingStatus ( x ) = bs_idle then
70033: LD_VAR 0 7
70037: PPUSH
70038: CALL_OW 461
70042: PUSH
70043: LD_INT 2
70045: EQUAL
70046: IFFALSE 70069
// sci := sci ^ UnitsInside ( x ) ;
70048: LD_ADDR_VAR 0 8
70052: PUSH
70053: LD_VAR 0 8
70057: PUSH
70058: LD_VAR 0 7
70062: PPUSH
70063: CALL_OW 313
70067: ADD
70068: ST_TO_ADDR
// end ;
70069: GO 70018
70071: POP
70072: POP
// if not sci then
70073: LD_VAR 0 8
70077: NOT
70078: IFFALSE 70082
// continue ;
70080: GO 69127
// for x in sci do
70082: LD_ADDR_VAR 0 7
70086: PUSH
70087: LD_VAR 0 8
70091: PUSH
70092: FOR_IN
70093: IFFALSE 70143
// if IsInUnit ( x ) and not HasTask ( x ) then
70095: LD_VAR 0 7
70099: PPUSH
70100: CALL_OW 310
70104: PUSH
70105: LD_VAR 0 7
70109: PPUSH
70110: CALL_OW 314
70114: NOT
70115: AND
70116: IFFALSE 70141
// begin ComExitBuilding ( x ) ;
70118: LD_VAR 0 7
70122: PPUSH
70123: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70127: LD_VAR 0 7
70131: PPUSH
70132: LD_VAR 0 3
70136: PPUSH
70137: CALL_OW 180
// end ;
70141: GO 70092
70143: POP
70144: POP
// end ; end ;
70145: GO 69127
70147: POP
70148: POP
// end ;
70149: GO 69081
70151: POP
70152: POP
// end ;
70153: LD_VAR 0 1
70157: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70158: LD_INT 0
70160: PPUSH
70161: PPUSH
// if not mc_bases then
70162: LD_EXP 23
70166: NOT
70167: IFFALSE 70171
// exit ;
70169: GO 70252
// for i = 1 to mc_bases do
70171: LD_ADDR_VAR 0 2
70175: PUSH
70176: DOUBLE
70177: LD_INT 1
70179: DEC
70180: ST_TO_ADDR
70181: LD_EXP 23
70185: PUSH
70186: FOR_TO
70187: IFFALSE 70250
// if mc_mines [ i ] and mc_miners [ i ] then
70189: LD_EXP 36
70193: PUSH
70194: LD_VAR 0 2
70198: ARRAY
70199: PUSH
70200: LD_EXP 37
70204: PUSH
70205: LD_VAR 0 2
70209: ARRAY
70210: AND
70211: IFFALSE 70248
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70213: LD_EXP 37
70217: PUSH
70218: LD_VAR 0 2
70222: ARRAY
70223: PUSH
70224: LD_INT 1
70226: ARRAY
70227: PPUSH
70228: CALL_OW 255
70232: PPUSH
70233: LD_EXP 36
70237: PUSH
70238: LD_VAR 0 2
70242: ARRAY
70243: PPUSH
70244: CALL 12954 0 2
70248: GO 70186
70250: POP
70251: POP
// end ;
70252: LD_VAR 0 1
70256: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70257: LD_INT 0
70259: PPUSH
70260: PPUSH
70261: PPUSH
70262: PPUSH
70263: PPUSH
70264: PPUSH
70265: PPUSH
70266: PPUSH
// if not mc_bases or not mc_parking then
70267: LD_EXP 23
70271: NOT
70272: PUSH
70273: LD_EXP 47
70277: NOT
70278: OR
70279: IFFALSE 70283
// exit ;
70281: GO 71021
// for i = 1 to mc_bases do
70283: LD_ADDR_VAR 0 2
70287: PUSH
70288: DOUBLE
70289: LD_INT 1
70291: DEC
70292: ST_TO_ADDR
70293: LD_EXP 23
70297: PUSH
70298: FOR_TO
70299: IFFALSE 71019
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70301: LD_EXP 23
70305: PUSH
70306: LD_VAR 0 2
70310: ARRAY
70311: NOT
70312: PUSH
70313: LD_EXP 47
70317: PUSH
70318: LD_VAR 0 2
70322: ARRAY
70323: NOT
70324: OR
70325: IFFALSE 70329
// continue ;
70327: GO 70298
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70329: LD_ADDR_VAR 0 5
70333: PUSH
70334: LD_EXP 23
70338: PUSH
70339: LD_VAR 0 2
70343: ARRAY
70344: PUSH
70345: LD_INT 1
70347: ARRAY
70348: PPUSH
70349: CALL_OW 255
70353: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70354: LD_ADDR_VAR 0 6
70358: PUSH
70359: LD_EXP 23
70363: PUSH
70364: LD_VAR 0 2
70368: ARRAY
70369: PPUSH
70370: LD_INT 30
70372: PUSH
70373: LD_INT 3
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PPUSH
70380: CALL_OW 72
70384: ST_TO_ADDR
// if not fac then
70385: LD_VAR 0 6
70389: NOT
70390: IFFALSE 70441
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70392: LD_ADDR_VAR 0 6
70396: PUSH
70397: LD_EXP 23
70401: PUSH
70402: LD_VAR 0 2
70406: ARRAY
70407: PPUSH
70408: LD_INT 2
70410: PUSH
70411: LD_INT 30
70413: PUSH
70414: LD_INT 0
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: PUSH
70421: LD_INT 30
70423: PUSH
70424: LD_INT 1
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PUSH
70431: EMPTY
70432: LIST
70433: LIST
70434: LIST
70435: PPUSH
70436: CALL_OW 72
70440: ST_TO_ADDR
// if not fac then
70441: LD_VAR 0 6
70445: NOT
70446: IFFALSE 70450
// continue ;
70448: GO 70298
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70450: LD_ADDR_VAR 0 7
70454: PUSH
70455: LD_EXP 47
70459: PUSH
70460: LD_VAR 0 2
70464: ARRAY
70465: PPUSH
70466: LD_INT 22
70468: PUSH
70469: LD_VAR 0 5
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 21
70480: PUSH
70481: LD_INT 2
70483: PUSH
70484: EMPTY
70485: LIST
70486: LIST
70487: PUSH
70488: LD_INT 3
70490: PUSH
70491: LD_INT 60
70493: PUSH
70494: EMPTY
70495: LIST
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PUSH
70501: LD_INT 3
70503: PUSH
70504: LD_INT 24
70506: PUSH
70507: LD_INT 1000
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: EMPTY
70519: LIST
70520: LIST
70521: LIST
70522: LIST
70523: PPUSH
70524: CALL_OW 70
70528: ST_TO_ADDR
// for j in fac do
70529: LD_ADDR_VAR 0 3
70533: PUSH
70534: LD_VAR 0 6
70538: PUSH
70539: FOR_IN
70540: IFFALSE 70635
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70542: LD_ADDR_VAR 0 7
70546: PUSH
70547: LD_VAR 0 7
70551: PUSH
70552: LD_INT 22
70554: PUSH
70555: LD_VAR 0 5
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: LD_INT 91
70566: PUSH
70567: LD_VAR 0 3
70571: PUSH
70572: LD_INT 15
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 21
70582: PUSH
70583: LD_INT 2
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 3
70592: PUSH
70593: LD_INT 60
70595: PUSH
70596: EMPTY
70597: LIST
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: PUSH
70603: LD_INT 3
70605: PUSH
70606: LD_INT 24
70608: PUSH
70609: LD_INT 1000
70611: PUSH
70612: EMPTY
70613: LIST
70614: LIST
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: PPUSH
70627: CALL_OW 69
70631: UNION
70632: ST_TO_ADDR
70633: GO 70539
70635: POP
70636: POP
// if not vehs then
70637: LD_VAR 0 7
70641: NOT
70642: IFFALSE 70668
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70644: LD_ADDR_EXP 35
70648: PUSH
70649: LD_EXP 35
70653: PPUSH
70654: LD_VAR 0 2
70658: PPUSH
70659: EMPTY
70660: PPUSH
70661: CALL_OW 1
70665: ST_TO_ADDR
// continue ;
70666: GO 70298
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70668: LD_ADDR_VAR 0 8
70672: PUSH
70673: LD_EXP 23
70677: PUSH
70678: LD_VAR 0 2
70682: ARRAY
70683: PPUSH
70684: LD_INT 30
70686: PUSH
70687: LD_INT 3
70689: PUSH
70690: EMPTY
70691: LIST
70692: LIST
70693: PPUSH
70694: CALL_OW 72
70698: ST_TO_ADDR
// if tmp then
70699: LD_VAR 0 8
70703: IFFALSE 70806
// begin for j in tmp do
70705: LD_ADDR_VAR 0 3
70709: PUSH
70710: LD_VAR 0 8
70714: PUSH
70715: FOR_IN
70716: IFFALSE 70804
// for k in UnitsInside ( j ) do
70718: LD_ADDR_VAR 0 4
70722: PUSH
70723: LD_VAR 0 3
70727: PPUSH
70728: CALL_OW 313
70732: PUSH
70733: FOR_IN
70734: IFFALSE 70800
// if k then
70736: LD_VAR 0 4
70740: IFFALSE 70798
// if not k in mc_repair_vehicle [ i ] then
70742: LD_VAR 0 4
70746: PUSH
70747: LD_EXP 35
70751: PUSH
70752: LD_VAR 0 2
70756: ARRAY
70757: IN
70758: NOT
70759: IFFALSE 70798
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70761: LD_ADDR_EXP 35
70765: PUSH
70766: LD_EXP 35
70770: PPUSH
70771: LD_VAR 0 2
70775: PPUSH
70776: LD_EXP 35
70780: PUSH
70781: LD_VAR 0 2
70785: ARRAY
70786: PUSH
70787: LD_VAR 0 4
70791: UNION
70792: PPUSH
70793: CALL_OW 1
70797: ST_TO_ADDR
70798: GO 70733
70800: POP
70801: POP
70802: GO 70715
70804: POP
70805: POP
// end ; if not mc_repair_vehicle [ i ] then
70806: LD_EXP 35
70810: PUSH
70811: LD_VAR 0 2
70815: ARRAY
70816: NOT
70817: IFFALSE 70821
// continue ;
70819: GO 70298
// for j in mc_repair_vehicle [ i ] do
70821: LD_ADDR_VAR 0 3
70825: PUSH
70826: LD_EXP 35
70830: PUSH
70831: LD_VAR 0 2
70835: ARRAY
70836: PUSH
70837: FOR_IN
70838: IFFALSE 71015
// begin if GetClass ( j ) <> 3 then
70840: LD_VAR 0 3
70844: PPUSH
70845: CALL_OW 257
70849: PUSH
70850: LD_INT 3
70852: NONEQUAL
70853: IFFALSE 70894
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70855: LD_ADDR_EXP 35
70859: PUSH
70860: LD_EXP 35
70864: PPUSH
70865: LD_VAR 0 2
70869: PPUSH
70870: LD_EXP 35
70874: PUSH
70875: LD_VAR 0 2
70879: ARRAY
70880: PUSH
70881: LD_VAR 0 3
70885: DIFF
70886: PPUSH
70887: CALL_OW 1
70891: ST_TO_ADDR
// continue ;
70892: GO 70837
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70894: LD_VAR 0 3
70898: PPUSH
70899: CALL_OW 311
70903: NOT
70904: PUSH
70905: LD_VAR 0 3
70909: PUSH
70910: LD_EXP 26
70914: PUSH
70915: LD_VAR 0 2
70919: ARRAY
70920: PUSH
70921: LD_INT 1
70923: ARRAY
70924: IN
70925: NOT
70926: AND
70927: PUSH
70928: LD_VAR 0 3
70932: PUSH
70933: LD_EXP 26
70937: PUSH
70938: LD_VAR 0 2
70942: ARRAY
70943: PUSH
70944: LD_INT 2
70946: ARRAY
70947: IN
70948: NOT
70949: AND
70950: IFFALSE 71013
// begin if IsInUnit ( j ) then
70952: LD_VAR 0 3
70956: PPUSH
70957: CALL_OW 310
70961: IFFALSE 70974
// ComExitBuilding ( j ) else
70963: LD_VAR 0 3
70967: PPUSH
70968: CALL_OW 122
70972: GO 71013
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
70974: LD_VAR 0 3
70978: PPUSH
70979: LD_VAR 0 7
70983: PUSH
70984: LD_INT 1
70986: ARRAY
70987: PPUSH
70988: CALL 50529 0 2
70992: NOT
70993: IFFALSE 71013
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
70995: LD_VAR 0 3
70999: PPUSH
71000: LD_VAR 0 7
71004: PUSH
71005: LD_INT 1
71007: ARRAY
71008: PPUSH
71009: CALL_OW 129
// end ; end ;
71013: GO 70837
71015: POP
71016: POP
// end ;
71017: GO 70298
71019: POP
71020: POP
// end ;
71021: LD_VAR 0 1
71025: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71026: LD_INT 0
71028: PPUSH
71029: PPUSH
71030: PPUSH
71031: PPUSH
71032: PPUSH
71033: PPUSH
71034: PPUSH
71035: PPUSH
71036: PPUSH
71037: PPUSH
71038: PPUSH
// if not mc_bases then
71039: LD_EXP 23
71043: NOT
71044: IFFALSE 71048
// exit ;
71046: GO 71850
// for i = 1 to mc_bases do
71048: LD_ADDR_VAR 0 2
71052: PUSH
71053: DOUBLE
71054: LD_INT 1
71056: DEC
71057: ST_TO_ADDR
71058: LD_EXP 23
71062: PUSH
71063: FOR_TO
71064: IFFALSE 71848
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71066: LD_EXP 51
71070: PUSH
71071: LD_VAR 0 2
71075: ARRAY
71076: NOT
71077: PUSH
71078: LD_EXP 26
71082: PUSH
71083: LD_VAR 0 2
71087: ARRAY
71088: PUSH
71089: LD_INT 1
71091: ARRAY
71092: OR
71093: PUSH
71094: LD_EXP 26
71098: PUSH
71099: LD_VAR 0 2
71103: ARRAY
71104: PUSH
71105: LD_INT 2
71107: ARRAY
71108: OR
71109: PUSH
71110: LD_EXP 49
71114: PUSH
71115: LD_VAR 0 2
71119: ARRAY
71120: PPUSH
71121: LD_INT 1
71123: PPUSH
71124: CALL_OW 325
71128: NOT
71129: OR
71130: PUSH
71131: LD_EXP 46
71135: PUSH
71136: LD_VAR 0 2
71140: ARRAY
71141: OR
71142: IFFALSE 71146
// continue ;
71144: GO 71063
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71146: LD_ADDR_VAR 0 8
71150: PUSH
71151: LD_EXP 23
71155: PUSH
71156: LD_VAR 0 2
71160: ARRAY
71161: PPUSH
71162: LD_INT 25
71164: PUSH
71165: LD_INT 4
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 50
71174: PUSH
71175: EMPTY
71176: LIST
71177: PUSH
71178: LD_INT 3
71180: PUSH
71181: LD_INT 60
71183: PUSH
71184: EMPTY
71185: LIST
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: LIST
71195: PPUSH
71196: CALL_OW 72
71200: PUSH
71201: LD_EXP 27
71205: PUSH
71206: LD_VAR 0 2
71210: ARRAY
71211: DIFF
71212: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71213: LD_ADDR_VAR 0 9
71217: PUSH
71218: LD_EXP 23
71222: PUSH
71223: LD_VAR 0 2
71227: ARRAY
71228: PPUSH
71229: LD_INT 2
71231: PUSH
71232: LD_INT 30
71234: PUSH
71235: LD_INT 0
71237: PUSH
71238: EMPTY
71239: LIST
71240: LIST
71241: PUSH
71242: LD_INT 30
71244: PUSH
71245: LD_INT 1
71247: PUSH
71248: EMPTY
71249: LIST
71250: LIST
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: LIST
71256: PPUSH
71257: CALL_OW 72
71261: ST_TO_ADDR
// if not tmp or not dep then
71262: LD_VAR 0 8
71266: NOT
71267: PUSH
71268: LD_VAR 0 9
71272: NOT
71273: OR
71274: IFFALSE 71278
// continue ;
71276: GO 71063
// side := GetSide ( tmp [ 1 ] ) ;
71278: LD_ADDR_VAR 0 11
71282: PUSH
71283: LD_VAR 0 8
71287: PUSH
71288: LD_INT 1
71290: ARRAY
71291: PPUSH
71292: CALL_OW 255
71296: ST_TO_ADDR
// dep := dep [ 1 ] ;
71297: LD_ADDR_VAR 0 9
71301: PUSH
71302: LD_VAR 0 9
71306: PUSH
71307: LD_INT 1
71309: ARRAY
71310: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71311: LD_ADDR_VAR 0 7
71315: PUSH
71316: LD_EXP 51
71320: PUSH
71321: LD_VAR 0 2
71325: ARRAY
71326: PPUSH
71327: LD_INT 22
71329: PUSH
71330: LD_INT 0
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 25
71339: PUSH
71340: LD_INT 12
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: PPUSH
71351: CALL_OW 70
71355: PUSH
71356: LD_INT 22
71358: PUSH
71359: LD_INT 0
71361: PUSH
71362: EMPTY
71363: LIST
71364: LIST
71365: PUSH
71366: LD_INT 25
71368: PUSH
71369: LD_INT 12
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 91
71378: PUSH
71379: LD_VAR 0 9
71383: PUSH
71384: LD_INT 20
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: LIST
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: LIST
71396: PPUSH
71397: CALL_OW 69
71401: UNION
71402: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71403: LD_ADDR_VAR 0 10
71407: PUSH
71408: LD_EXP 51
71412: PUSH
71413: LD_VAR 0 2
71417: ARRAY
71418: PPUSH
71419: LD_INT 81
71421: PUSH
71422: LD_VAR 0 11
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PPUSH
71431: CALL_OW 70
71435: ST_TO_ADDR
// if not apes or danger_at_area then
71436: LD_VAR 0 7
71440: NOT
71441: PUSH
71442: LD_VAR 0 10
71446: OR
71447: IFFALSE 71497
// begin if mc_taming [ i ] then
71449: LD_EXP 54
71453: PUSH
71454: LD_VAR 0 2
71458: ARRAY
71459: IFFALSE 71495
// begin MC_Reset ( i , 121 ) ;
71461: LD_VAR 0 2
71465: PPUSH
71466: LD_INT 121
71468: PPUSH
71469: CALL 56434 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71473: LD_ADDR_EXP 54
71477: PUSH
71478: LD_EXP 54
71482: PPUSH
71483: LD_VAR 0 2
71487: PPUSH
71488: EMPTY
71489: PPUSH
71490: CALL_OW 1
71494: ST_TO_ADDR
// end ; continue ;
71495: GO 71063
// end ; for j in tmp do
71497: LD_ADDR_VAR 0 3
71501: PUSH
71502: LD_VAR 0 8
71506: PUSH
71507: FOR_IN
71508: IFFALSE 71844
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71510: LD_VAR 0 3
71514: PUSH
71515: LD_EXP 54
71519: PUSH
71520: LD_VAR 0 2
71524: ARRAY
71525: IN
71526: NOT
71527: PUSH
71528: LD_EXP 54
71532: PUSH
71533: LD_VAR 0 2
71537: ARRAY
71538: PUSH
71539: LD_INT 3
71541: LESS
71542: AND
71543: IFFALSE 71601
// begin SetTag ( j , 121 ) ;
71545: LD_VAR 0 3
71549: PPUSH
71550: LD_INT 121
71552: PPUSH
71553: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71557: LD_ADDR_EXP 54
71561: PUSH
71562: LD_EXP 54
71566: PPUSH
71567: LD_VAR 0 2
71571: PUSH
71572: LD_EXP 54
71576: PUSH
71577: LD_VAR 0 2
71581: ARRAY
71582: PUSH
71583: LD_INT 1
71585: PLUS
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PPUSH
71591: LD_VAR 0 3
71595: PPUSH
71596: CALL 16152 0 3
71600: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71601: LD_VAR 0 3
71605: PUSH
71606: LD_EXP 54
71610: PUSH
71611: LD_VAR 0 2
71615: ARRAY
71616: IN
71617: IFFALSE 71842
// begin if GetClass ( j ) <> 4 then
71619: LD_VAR 0 3
71623: PPUSH
71624: CALL_OW 257
71628: PUSH
71629: LD_INT 4
71631: NONEQUAL
71632: IFFALSE 71685
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71634: LD_ADDR_EXP 54
71638: PUSH
71639: LD_EXP 54
71643: PPUSH
71644: LD_VAR 0 2
71648: PPUSH
71649: LD_EXP 54
71653: PUSH
71654: LD_VAR 0 2
71658: ARRAY
71659: PUSH
71660: LD_VAR 0 3
71664: DIFF
71665: PPUSH
71666: CALL_OW 1
71670: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71671: LD_VAR 0 3
71675: PPUSH
71676: LD_INT 0
71678: PPUSH
71679: CALL_OW 109
// continue ;
71683: GO 71507
// end ; if IsInUnit ( j ) then
71685: LD_VAR 0 3
71689: PPUSH
71690: CALL_OW 310
71694: IFFALSE 71705
// ComExitBuilding ( j ) ;
71696: LD_VAR 0 3
71700: PPUSH
71701: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71705: LD_ADDR_VAR 0 6
71709: PUSH
71710: LD_VAR 0 7
71714: PPUSH
71715: LD_VAR 0 3
71719: PPUSH
71720: CALL_OW 74
71724: ST_TO_ADDR
// if not ape then
71725: LD_VAR 0 6
71729: NOT
71730: IFFALSE 71734
// break ;
71732: GO 71844
// x := GetX ( ape ) ;
71734: LD_ADDR_VAR 0 4
71738: PUSH
71739: LD_VAR 0 6
71743: PPUSH
71744: CALL_OW 250
71748: ST_TO_ADDR
// y := GetY ( ape ) ;
71749: LD_ADDR_VAR 0 5
71753: PUSH
71754: LD_VAR 0 6
71758: PPUSH
71759: CALL_OW 251
71763: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71764: LD_VAR 0 4
71768: PPUSH
71769: LD_VAR 0 5
71773: PPUSH
71774: CALL_OW 488
71778: NOT
71779: PUSH
71780: LD_VAR 0 11
71784: PPUSH
71785: LD_VAR 0 4
71789: PPUSH
71790: LD_VAR 0 5
71794: PPUSH
71795: LD_INT 20
71797: PPUSH
71798: CALL 17048 0 4
71802: PUSH
71803: LD_INT 4
71805: ARRAY
71806: OR
71807: IFFALSE 71811
// break ;
71809: GO 71844
// if not HasTask ( j ) then
71811: LD_VAR 0 3
71815: PPUSH
71816: CALL_OW 314
71820: NOT
71821: IFFALSE 71842
// ComTameXY ( j , x , y ) ;
71823: LD_VAR 0 3
71827: PPUSH
71828: LD_VAR 0 4
71832: PPUSH
71833: LD_VAR 0 5
71837: PPUSH
71838: CALL_OW 131
// end ; end ;
71842: GO 71507
71844: POP
71845: POP
// end ;
71846: GO 71063
71848: POP
71849: POP
// end ;
71850: LD_VAR 0 1
71854: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71855: LD_INT 0
71857: PPUSH
71858: PPUSH
71859: PPUSH
71860: PPUSH
71861: PPUSH
71862: PPUSH
71863: PPUSH
71864: PPUSH
// if not mc_bases then
71865: LD_EXP 23
71869: NOT
71870: IFFALSE 71874
// exit ;
71872: GO 72500
// for i = 1 to mc_bases do
71874: LD_ADDR_VAR 0 2
71878: PUSH
71879: DOUBLE
71880: LD_INT 1
71882: DEC
71883: ST_TO_ADDR
71884: LD_EXP 23
71888: PUSH
71889: FOR_TO
71890: IFFALSE 72498
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71892: LD_EXP 52
71896: PUSH
71897: LD_VAR 0 2
71901: ARRAY
71902: NOT
71903: PUSH
71904: LD_EXP 52
71908: PUSH
71909: LD_VAR 0 2
71913: ARRAY
71914: PPUSH
71915: LD_INT 25
71917: PUSH
71918: LD_INT 12
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PPUSH
71925: CALL_OW 72
71929: NOT
71930: OR
71931: IFFALSE 71935
// continue ;
71933: GO 71889
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71935: LD_ADDR_VAR 0 5
71939: PUSH
71940: LD_EXP 52
71944: PUSH
71945: LD_VAR 0 2
71949: ARRAY
71950: PUSH
71951: LD_INT 1
71953: ARRAY
71954: PPUSH
71955: CALL_OW 255
71959: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71960: LD_VAR 0 5
71964: PPUSH
71965: LD_INT 2
71967: PPUSH
71968: CALL_OW 325
71972: IFFALSE 72225
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71974: LD_ADDR_VAR 0 4
71978: PUSH
71979: LD_EXP 52
71983: PUSH
71984: LD_VAR 0 2
71988: ARRAY
71989: PPUSH
71990: LD_INT 25
71992: PUSH
71993: LD_INT 16
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PPUSH
72000: CALL_OW 72
72004: ST_TO_ADDR
// if tmp < 6 then
72005: LD_VAR 0 4
72009: PUSH
72010: LD_INT 6
72012: LESS
72013: IFFALSE 72225
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72015: LD_ADDR_VAR 0 6
72019: PUSH
72020: LD_EXP 23
72024: PUSH
72025: LD_VAR 0 2
72029: ARRAY
72030: PPUSH
72031: LD_INT 2
72033: PUSH
72034: LD_INT 30
72036: PUSH
72037: LD_INT 0
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 30
72046: PUSH
72047: LD_INT 1
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: LIST
72058: PPUSH
72059: CALL_OW 72
72063: ST_TO_ADDR
// if depot then
72064: LD_VAR 0 6
72068: IFFALSE 72225
// begin selected := 0 ;
72070: LD_ADDR_VAR 0 7
72074: PUSH
72075: LD_INT 0
72077: ST_TO_ADDR
// for j in depot do
72078: LD_ADDR_VAR 0 3
72082: PUSH
72083: LD_VAR 0 6
72087: PUSH
72088: FOR_IN
72089: IFFALSE 72120
// begin if UnitsInside ( j ) < 6 then
72091: LD_VAR 0 3
72095: PPUSH
72096: CALL_OW 313
72100: PUSH
72101: LD_INT 6
72103: LESS
72104: IFFALSE 72118
// begin selected := j ;
72106: LD_ADDR_VAR 0 7
72110: PUSH
72111: LD_VAR 0 3
72115: ST_TO_ADDR
// break ;
72116: GO 72120
// end ; end ;
72118: GO 72088
72120: POP
72121: POP
// if selected then
72122: LD_VAR 0 7
72126: IFFALSE 72225
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72128: LD_ADDR_VAR 0 3
72132: PUSH
72133: LD_EXP 52
72137: PUSH
72138: LD_VAR 0 2
72142: ARRAY
72143: PPUSH
72144: LD_INT 25
72146: PUSH
72147: LD_INT 12
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PPUSH
72154: CALL_OW 72
72158: PUSH
72159: FOR_IN
72160: IFFALSE 72223
// if not HasTask ( j ) then
72162: LD_VAR 0 3
72166: PPUSH
72167: CALL_OW 314
72171: NOT
72172: IFFALSE 72221
// begin if not IsInUnit ( j ) then
72174: LD_VAR 0 3
72178: PPUSH
72179: CALL_OW 310
72183: NOT
72184: IFFALSE 72200
// ComEnterUnit ( j , selected ) ;
72186: LD_VAR 0 3
72190: PPUSH
72191: LD_VAR 0 7
72195: PPUSH
72196: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72200: LD_VAR 0 3
72204: PPUSH
72205: LD_INT 16
72207: PPUSH
72208: CALL_OW 183
// AddComExitBuilding ( j ) ;
72212: LD_VAR 0 3
72216: PPUSH
72217: CALL_OW 182
// end ;
72221: GO 72159
72223: POP
72224: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72225: LD_VAR 0 5
72229: PPUSH
72230: LD_INT 11
72232: PPUSH
72233: CALL_OW 325
72237: IFFALSE 72496
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72239: LD_ADDR_VAR 0 4
72243: PUSH
72244: LD_EXP 52
72248: PUSH
72249: LD_VAR 0 2
72253: ARRAY
72254: PPUSH
72255: LD_INT 25
72257: PUSH
72258: LD_INT 16
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PPUSH
72265: CALL_OW 72
72269: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72270: LD_VAR 0 4
72274: PUSH
72275: LD_INT 6
72277: GREATEREQUAL
72278: PUSH
72279: LD_VAR 0 5
72283: PPUSH
72284: LD_INT 2
72286: PPUSH
72287: CALL_OW 325
72291: NOT
72292: OR
72293: IFFALSE 72496
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72295: LD_ADDR_VAR 0 8
72299: PUSH
72300: LD_EXP 23
72304: PUSH
72305: LD_VAR 0 2
72309: ARRAY
72310: PPUSH
72311: LD_INT 2
72313: PUSH
72314: LD_INT 30
72316: PUSH
72317: LD_INT 4
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: PUSH
72324: LD_INT 30
72326: PUSH
72327: LD_INT 5
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: LIST
72338: PPUSH
72339: CALL_OW 72
72343: ST_TO_ADDR
// if barracks then
72344: LD_VAR 0 8
72348: IFFALSE 72496
// begin selected := 0 ;
72350: LD_ADDR_VAR 0 7
72354: PUSH
72355: LD_INT 0
72357: ST_TO_ADDR
// for j in barracks do
72358: LD_ADDR_VAR 0 3
72362: PUSH
72363: LD_VAR 0 8
72367: PUSH
72368: FOR_IN
72369: IFFALSE 72400
// begin if UnitsInside ( j ) < 6 then
72371: LD_VAR 0 3
72375: PPUSH
72376: CALL_OW 313
72380: PUSH
72381: LD_INT 6
72383: LESS
72384: IFFALSE 72398
// begin selected := j ;
72386: LD_ADDR_VAR 0 7
72390: PUSH
72391: LD_VAR 0 3
72395: ST_TO_ADDR
// break ;
72396: GO 72400
// end ; end ;
72398: GO 72368
72400: POP
72401: POP
// if selected then
72402: LD_VAR 0 7
72406: IFFALSE 72496
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72408: LD_ADDR_VAR 0 3
72412: PUSH
72413: LD_EXP 52
72417: PUSH
72418: LD_VAR 0 2
72422: ARRAY
72423: PPUSH
72424: LD_INT 25
72426: PUSH
72427: LD_INT 12
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PPUSH
72434: CALL_OW 72
72438: PUSH
72439: FOR_IN
72440: IFFALSE 72494
// if not IsInUnit ( j ) and not HasTask ( j ) then
72442: LD_VAR 0 3
72446: PPUSH
72447: CALL_OW 310
72451: NOT
72452: PUSH
72453: LD_VAR 0 3
72457: PPUSH
72458: CALL_OW 314
72462: NOT
72463: AND
72464: IFFALSE 72492
// begin ComEnterUnit ( j , selected ) ;
72466: LD_VAR 0 3
72470: PPUSH
72471: LD_VAR 0 7
72475: PPUSH
72476: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72480: LD_VAR 0 3
72484: PPUSH
72485: LD_INT 15
72487: PPUSH
72488: CALL_OW 183
// end ;
72492: GO 72439
72494: POP
72495: POP
// end ; end ; end ; end ; end ;
72496: GO 71889
72498: POP
72499: POP
// end ;
72500: LD_VAR 0 1
72504: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72505: LD_INT 0
72507: PPUSH
72508: PPUSH
72509: PPUSH
72510: PPUSH
// if not mc_bases then
72511: LD_EXP 23
72515: NOT
72516: IFFALSE 72520
// exit ;
72518: GO 72698
// for i = 1 to mc_bases do
72520: LD_ADDR_VAR 0 2
72524: PUSH
72525: DOUBLE
72526: LD_INT 1
72528: DEC
72529: ST_TO_ADDR
72530: LD_EXP 23
72534: PUSH
72535: FOR_TO
72536: IFFALSE 72696
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72538: LD_ADDR_VAR 0 4
72542: PUSH
72543: LD_EXP 23
72547: PUSH
72548: LD_VAR 0 2
72552: ARRAY
72553: PPUSH
72554: LD_INT 25
72556: PUSH
72557: LD_INT 9
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PPUSH
72564: CALL_OW 72
72568: ST_TO_ADDR
// if not tmp then
72569: LD_VAR 0 4
72573: NOT
72574: IFFALSE 72578
// continue ;
72576: GO 72535
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72578: LD_EXP 49
72582: PUSH
72583: LD_VAR 0 2
72587: ARRAY
72588: PPUSH
72589: LD_INT 29
72591: PPUSH
72592: CALL_OW 325
72596: NOT
72597: PUSH
72598: LD_EXP 49
72602: PUSH
72603: LD_VAR 0 2
72607: ARRAY
72608: PPUSH
72609: LD_INT 28
72611: PPUSH
72612: CALL_OW 325
72616: NOT
72617: AND
72618: IFFALSE 72622
// continue ;
72620: GO 72535
// for j in tmp do
72622: LD_ADDR_VAR 0 3
72626: PUSH
72627: LD_VAR 0 4
72631: PUSH
72632: FOR_IN
72633: IFFALSE 72692
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72635: LD_VAR 0 3
72639: PUSH
72640: LD_EXP 26
72644: PUSH
72645: LD_VAR 0 2
72649: ARRAY
72650: PUSH
72651: LD_INT 1
72653: ARRAY
72654: IN
72655: NOT
72656: PUSH
72657: LD_VAR 0 3
72661: PUSH
72662: LD_EXP 26
72666: PUSH
72667: LD_VAR 0 2
72671: ARRAY
72672: PUSH
72673: LD_INT 2
72675: ARRAY
72676: IN
72677: NOT
72678: AND
72679: IFFALSE 72690
// ComSpaceTimeShoot ( j ) ;
72681: LD_VAR 0 3
72685: PPUSH
72686: CALL 11962 0 1
72690: GO 72632
72692: POP
72693: POP
// end ;
72694: GO 72535
72696: POP
72697: POP
// end ;
72698: LD_VAR 0 1
72702: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72703: LD_INT 0
72705: PPUSH
72706: PPUSH
72707: PPUSH
72708: PPUSH
72709: PPUSH
72710: PPUSH
72711: PPUSH
72712: PPUSH
72713: PPUSH
// if not mc_bases then
72714: LD_EXP 23
72718: NOT
72719: IFFALSE 72723
// exit ;
72721: GO 73345
// for i = 1 to mc_bases do
72723: LD_ADDR_VAR 0 2
72727: PUSH
72728: DOUBLE
72729: LD_INT 1
72731: DEC
72732: ST_TO_ADDR
72733: LD_EXP 23
72737: PUSH
72738: FOR_TO
72739: IFFALSE 73343
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72741: LD_EXP 58
72745: PUSH
72746: LD_VAR 0 2
72750: ARRAY
72751: NOT
72752: PUSH
72753: LD_INT 38
72755: PPUSH
72756: LD_EXP 49
72760: PUSH
72761: LD_VAR 0 2
72765: ARRAY
72766: PPUSH
72767: CALL_OW 321
72771: PUSH
72772: LD_INT 2
72774: NONEQUAL
72775: OR
72776: IFFALSE 72780
// continue ;
72778: GO 72738
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72780: LD_ADDR_VAR 0 8
72784: PUSH
72785: LD_EXP 23
72789: PUSH
72790: LD_VAR 0 2
72794: ARRAY
72795: PPUSH
72796: LD_INT 30
72798: PUSH
72799: LD_INT 34
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PPUSH
72806: CALL_OW 72
72810: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72811: LD_ADDR_VAR 0 9
72815: PUSH
72816: LD_EXP 23
72820: PUSH
72821: LD_VAR 0 2
72825: ARRAY
72826: PPUSH
72827: LD_INT 25
72829: PUSH
72830: LD_INT 4
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PPUSH
72837: CALL_OW 72
72841: PPUSH
72842: LD_INT 0
72844: PPUSH
72845: CALL 46038 0 2
72849: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72850: LD_VAR 0 9
72854: NOT
72855: PUSH
72856: LD_VAR 0 8
72860: NOT
72861: OR
72862: PUSH
72863: LD_EXP 23
72867: PUSH
72868: LD_VAR 0 2
72872: ARRAY
72873: PPUSH
72874: LD_INT 124
72876: PPUSH
72877: CALL 46038 0 2
72881: OR
72882: IFFALSE 72886
// continue ;
72884: GO 72738
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72886: LD_EXP 59
72890: PUSH
72891: LD_VAR 0 2
72895: ARRAY
72896: PUSH
72897: LD_EXP 58
72901: PUSH
72902: LD_VAR 0 2
72906: ARRAY
72907: LESS
72908: PUSH
72909: LD_EXP 59
72913: PUSH
72914: LD_VAR 0 2
72918: ARRAY
72919: PUSH
72920: LD_VAR 0 8
72924: LESS
72925: AND
72926: IFFALSE 73341
// begin tmp := sci [ 1 ] ;
72928: LD_ADDR_VAR 0 7
72932: PUSH
72933: LD_VAR 0 9
72937: PUSH
72938: LD_INT 1
72940: ARRAY
72941: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72942: LD_VAR 0 7
72946: PPUSH
72947: LD_INT 124
72949: PPUSH
72950: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72954: LD_ADDR_VAR 0 3
72958: PUSH
72959: DOUBLE
72960: LD_EXP 58
72964: PUSH
72965: LD_VAR 0 2
72969: ARRAY
72970: INC
72971: ST_TO_ADDR
72972: LD_EXP 58
72976: PUSH
72977: LD_VAR 0 2
72981: ARRAY
72982: PUSH
72983: FOR_DOWNTO
72984: IFFALSE 73327
// begin if IsInUnit ( tmp ) then
72986: LD_VAR 0 7
72990: PPUSH
72991: CALL_OW 310
72995: IFFALSE 73006
// ComExitBuilding ( tmp ) ;
72997: LD_VAR 0 7
73001: PPUSH
73002: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73006: LD_INT 35
73008: PPUSH
73009: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73013: LD_VAR 0 7
73017: PPUSH
73018: CALL_OW 310
73022: NOT
73023: PUSH
73024: LD_VAR 0 7
73028: PPUSH
73029: CALL_OW 314
73033: NOT
73034: AND
73035: IFFALSE 73006
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73037: LD_ADDR_VAR 0 6
73041: PUSH
73042: LD_VAR 0 7
73046: PPUSH
73047: CALL_OW 250
73051: PUSH
73052: LD_VAR 0 7
73056: PPUSH
73057: CALL_OW 251
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73066: LD_INT 35
73068: PPUSH
73069: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73073: LD_ADDR_VAR 0 4
73077: PUSH
73078: LD_EXP 58
73082: PUSH
73083: LD_VAR 0 2
73087: ARRAY
73088: PUSH
73089: LD_VAR 0 3
73093: ARRAY
73094: PUSH
73095: LD_INT 1
73097: ARRAY
73098: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73099: LD_ADDR_VAR 0 5
73103: PUSH
73104: LD_EXP 58
73108: PUSH
73109: LD_VAR 0 2
73113: ARRAY
73114: PUSH
73115: LD_VAR 0 3
73119: ARRAY
73120: PUSH
73121: LD_INT 2
73123: ARRAY
73124: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73125: LD_VAR 0 7
73129: PPUSH
73130: LD_INT 10
73132: PPUSH
73133: CALL 18749 0 2
73137: PUSH
73138: LD_INT 4
73140: ARRAY
73141: IFFALSE 73179
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73143: LD_VAR 0 7
73147: PPUSH
73148: LD_VAR 0 6
73152: PUSH
73153: LD_INT 1
73155: ARRAY
73156: PPUSH
73157: LD_VAR 0 6
73161: PUSH
73162: LD_INT 2
73164: ARRAY
73165: PPUSH
73166: CALL_OW 111
// wait ( 0 0$10 ) ;
73170: LD_INT 350
73172: PPUSH
73173: CALL_OW 67
// end else
73177: GO 73205
// begin ComMoveXY ( tmp , x , y ) ;
73179: LD_VAR 0 7
73183: PPUSH
73184: LD_VAR 0 4
73188: PPUSH
73189: LD_VAR 0 5
73193: PPUSH
73194: CALL_OW 111
// wait ( 0 0$3 ) ;
73198: LD_INT 105
73200: PPUSH
73201: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73205: LD_VAR 0 7
73209: PPUSH
73210: LD_VAR 0 4
73214: PPUSH
73215: LD_VAR 0 5
73219: PPUSH
73220: CALL_OW 307
73224: IFFALSE 73066
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73226: LD_VAR 0 7
73230: PPUSH
73231: LD_VAR 0 4
73235: PPUSH
73236: LD_VAR 0 5
73240: PPUSH
73241: LD_VAR 0 8
73245: PUSH
73246: LD_VAR 0 3
73250: ARRAY
73251: PPUSH
73252: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73256: LD_INT 35
73258: PPUSH
73259: CALL_OW 67
// until not HasTask ( tmp ) ;
73263: LD_VAR 0 7
73267: PPUSH
73268: CALL_OW 314
73272: NOT
73273: IFFALSE 73256
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73275: LD_ADDR_EXP 59
73279: PUSH
73280: LD_EXP 59
73284: PPUSH
73285: LD_VAR 0 2
73289: PUSH
73290: LD_EXP 59
73294: PUSH
73295: LD_VAR 0 2
73299: ARRAY
73300: PUSH
73301: LD_INT 1
73303: PLUS
73304: PUSH
73305: EMPTY
73306: LIST
73307: LIST
73308: PPUSH
73309: LD_VAR 0 8
73313: PUSH
73314: LD_VAR 0 3
73318: ARRAY
73319: PPUSH
73320: CALL 16152 0 3
73324: ST_TO_ADDR
// end ;
73325: GO 72983
73327: POP
73328: POP
// MC_Reset ( i , 124 ) ;
73329: LD_VAR 0 2
73333: PPUSH
73334: LD_INT 124
73336: PPUSH
73337: CALL 56434 0 2
// end ; end ;
73341: GO 72738
73343: POP
73344: POP
// end ;
73345: LD_VAR 0 1
73349: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73350: LD_INT 0
73352: PPUSH
73353: PPUSH
73354: PPUSH
// if not mc_bases then
73355: LD_EXP 23
73359: NOT
73360: IFFALSE 73364
// exit ;
73362: GO 73970
// for i = 1 to mc_bases do
73364: LD_ADDR_VAR 0 2
73368: PUSH
73369: DOUBLE
73370: LD_INT 1
73372: DEC
73373: ST_TO_ADDR
73374: LD_EXP 23
73378: PUSH
73379: FOR_TO
73380: IFFALSE 73968
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73382: LD_ADDR_VAR 0 3
73386: PUSH
73387: LD_EXP 23
73391: PUSH
73392: LD_VAR 0 2
73396: ARRAY
73397: PPUSH
73398: LD_INT 25
73400: PUSH
73401: LD_INT 4
73403: PUSH
73404: EMPTY
73405: LIST
73406: LIST
73407: PPUSH
73408: CALL_OW 72
73412: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73413: LD_VAR 0 3
73417: NOT
73418: PUSH
73419: LD_EXP 60
73423: PUSH
73424: LD_VAR 0 2
73428: ARRAY
73429: NOT
73430: OR
73431: PUSH
73432: LD_EXP 23
73436: PUSH
73437: LD_VAR 0 2
73441: ARRAY
73442: PPUSH
73443: LD_INT 2
73445: PUSH
73446: LD_INT 30
73448: PUSH
73449: LD_INT 0
73451: PUSH
73452: EMPTY
73453: LIST
73454: LIST
73455: PUSH
73456: LD_INT 30
73458: PUSH
73459: LD_INT 1
73461: PUSH
73462: EMPTY
73463: LIST
73464: LIST
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: LIST
73470: PPUSH
73471: CALL_OW 72
73475: NOT
73476: OR
73477: IFFALSE 73527
// begin if mc_deposits_finder [ i ] then
73479: LD_EXP 61
73483: PUSH
73484: LD_VAR 0 2
73488: ARRAY
73489: IFFALSE 73525
// begin MC_Reset ( i , 125 ) ;
73491: LD_VAR 0 2
73495: PPUSH
73496: LD_INT 125
73498: PPUSH
73499: CALL 56434 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73503: LD_ADDR_EXP 61
73507: PUSH
73508: LD_EXP 61
73512: PPUSH
73513: LD_VAR 0 2
73517: PPUSH
73518: EMPTY
73519: PPUSH
73520: CALL_OW 1
73524: ST_TO_ADDR
// end ; continue ;
73525: GO 73379
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73527: LD_EXP 60
73531: PUSH
73532: LD_VAR 0 2
73536: ARRAY
73537: PUSH
73538: LD_INT 1
73540: ARRAY
73541: PUSH
73542: LD_INT 3
73544: ARRAY
73545: PUSH
73546: LD_INT 1
73548: EQUAL
73549: PUSH
73550: LD_INT 20
73552: PPUSH
73553: LD_EXP 49
73557: PUSH
73558: LD_VAR 0 2
73562: ARRAY
73563: PPUSH
73564: CALL_OW 321
73568: PUSH
73569: LD_INT 2
73571: NONEQUAL
73572: AND
73573: IFFALSE 73623
// begin if mc_deposits_finder [ i ] then
73575: LD_EXP 61
73579: PUSH
73580: LD_VAR 0 2
73584: ARRAY
73585: IFFALSE 73621
// begin MC_Reset ( i , 125 ) ;
73587: LD_VAR 0 2
73591: PPUSH
73592: LD_INT 125
73594: PPUSH
73595: CALL 56434 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73599: LD_ADDR_EXP 61
73603: PUSH
73604: LD_EXP 61
73608: PPUSH
73609: LD_VAR 0 2
73613: PPUSH
73614: EMPTY
73615: PPUSH
73616: CALL_OW 1
73620: ST_TO_ADDR
// end ; continue ;
73621: GO 73379
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73623: LD_EXP 60
73627: PUSH
73628: LD_VAR 0 2
73632: ARRAY
73633: PUSH
73634: LD_INT 1
73636: ARRAY
73637: PUSH
73638: LD_INT 1
73640: ARRAY
73641: PPUSH
73642: LD_EXP 60
73646: PUSH
73647: LD_VAR 0 2
73651: ARRAY
73652: PUSH
73653: LD_INT 1
73655: ARRAY
73656: PUSH
73657: LD_INT 2
73659: ARRAY
73660: PPUSH
73661: LD_EXP 49
73665: PUSH
73666: LD_VAR 0 2
73670: ARRAY
73671: PPUSH
73672: CALL_OW 440
73676: IFFALSE 73719
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73678: LD_ADDR_EXP 60
73682: PUSH
73683: LD_EXP 60
73687: PPUSH
73688: LD_VAR 0 2
73692: PPUSH
73693: LD_EXP 60
73697: PUSH
73698: LD_VAR 0 2
73702: ARRAY
73703: PPUSH
73704: LD_INT 1
73706: PPUSH
73707: CALL_OW 3
73711: PPUSH
73712: CALL_OW 1
73716: ST_TO_ADDR
73717: GO 73966
// begin if not mc_deposits_finder [ i ] then
73719: LD_EXP 61
73723: PUSH
73724: LD_VAR 0 2
73728: ARRAY
73729: NOT
73730: IFFALSE 73782
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73732: LD_ADDR_EXP 61
73736: PUSH
73737: LD_EXP 61
73741: PPUSH
73742: LD_VAR 0 2
73746: PPUSH
73747: LD_VAR 0 3
73751: PUSH
73752: LD_INT 1
73754: ARRAY
73755: PUSH
73756: EMPTY
73757: LIST
73758: PPUSH
73759: CALL_OW 1
73763: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73764: LD_VAR 0 3
73768: PUSH
73769: LD_INT 1
73771: ARRAY
73772: PPUSH
73773: LD_INT 125
73775: PPUSH
73776: CALL_OW 109
// end else
73780: GO 73966
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73782: LD_EXP 61
73786: PUSH
73787: LD_VAR 0 2
73791: ARRAY
73792: PUSH
73793: LD_INT 1
73795: ARRAY
73796: PPUSH
73797: CALL_OW 310
73801: IFFALSE 73824
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73803: LD_EXP 61
73807: PUSH
73808: LD_VAR 0 2
73812: ARRAY
73813: PUSH
73814: LD_INT 1
73816: ARRAY
73817: PPUSH
73818: CALL_OW 122
73822: GO 73966
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73824: LD_EXP 61
73828: PUSH
73829: LD_VAR 0 2
73833: ARRAY
73834: PUSH
73835: LD_INT 1
73837: ARRAY
73838: PPUSH
73839: CALL_OW 314
73843: NOT
73844: PUSH
73845: LD_EXP 61
73849: PUSH
73850: LD_VAR 0 2
73854: ARRAY
73855: PUSH
73856: LD_INT 1
73858: ARRAY
73859: PPUSH
73860: LD_EXP 60
73864: PUSH
73865: LD_VAR 0 2
73869: ARRAY
73870: PUSH
73871: LD_INT 1
73873: ARRAY
73874: PUSH
73875: LD_INT 1
73877: ARRAY
73878: PPUSH
73879: LD_EXP 60
73883: PUSH
73884: LD_VAR 0 2
73888: ARRAY
73889: PUSH
73890: LD_INT 1
73892: ARRAY
73893: PUSH
73894: LD_INT 2
73896: ARRAY
73897: PPUSH
73898: CALL_OW 297
73902: PUSH
73903: LD_INT 6
73905: GREATER
73906: AND
73907: IFFALSE 73966
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73909: LD_EXP 61
73913: PUSH
73914: LD_VAR 0 2
73918: ARRAY
73919: PUSH
73920: LD_INT 1
73922: ARRAY
73923: PPUSH
73924: LD_EXP 60
73928: PUSH
73929: LD_VAR 0 2
73933: ARRAY
73934: PUSH
73935: LD_INT 1
73937: ARRAY
73938: PUSH
73939: LD_INT 1
73941: ARRAY
73942: PPUSH
73943: LD_EXP 60
73947: PUSH
73948: LD_VAR 0 2
73952: ARRAY
73953: PUSH
73954: LD_INT 1
73956: ARRAY
73957: PUSH
73958: LD_INT 2
73960: ARRAY
73961: PPUSH
73962: CALL_OW 111
// end ; end ; end ;
73966: GO 73379
73968: POP
73969: POP
// end ;
73970: LD_VAR 0 1
73974: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73975: LD_INT 0
73977: PPUSH
73978: PPUSH
73979: PPUSH
73980: PPUSH
73981: PPUSH
73982: PPUSH
73983: PPUSH
73984: PPUSH
73985: PPUSH
73986: PPUSH
73987: PPUSH
// if not mc_bases then
73988: LD_EXP 23
73992: NOT
73993: IFFALSE 73997
// exit ;
73995: GO 74937
// for i = 1 to mc_bases do
73997: LD_ADDR_VAR 0 2
74001: PUSH
74002: DOUBLE
74003: LD_INT 1
74005: DEC
74006: ST_TO_ADDR
74007: LD_EXP 23
74011: PUSH
74012: FOR_TO
74013: IFFALSE 74935
// begin if not mc_bases [ i ] or mc_scan [ i ] then
74015: LD_EXP 23
74019: PUSH
74020: LD_VAR 0 2
74024: ARRAY
74025: NOT
74026: PUSH
74027: LD_EXP 46
74031: PUSH
74032: LD_VAR 0 2
74036: ARRAY
74037: OR
74038: IFFALSE 74042
// continue ;
74040: GO 74012
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74042: LD_ADDR_VAR 0 7
74046: PUSH
74047: LD_EXP 23
74051: PUSH
74052: LD_VAR 0 2
74056: ARRAY
74057: PUSH
74058: LD_INT 1
74060: ARRAY
74061: PPUSH
74062: CALL_OW 248
74066: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74067: LD_VAR 0 7
74071: PUSH
74072: LD_INT 3
74074: EQUAL
74075: PUSH
74076: LD_EXP 42
74080: PUSH
74081: LD_VAR 0 2
74085: ARRAY
74086: PUSH
74087: LD_EXP 45
74091: PUSH
74092: LD_VAR 0 2
74096: ARRAY
74097: UNION
74098: PPUSH
74099: LD_INT 33
74101: PUSH
74102: LD_INT 2
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PPUSH
74109: CALL_OW 72
74113: NOT
74114: OR
74115: IFFALSE 74119
// continue ;
74117: GO 74012
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74119: LD_ADDR_VAR 0 9
74123: PUSH
74124: LD_EXP 23
74128: PUSH
74129: LD_VAR 0 2
74133: ARRAY
74134: PPUSH
74135: LD_INT 30
74137: PUSH
74138: LD_INT 36
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: PPUSH
74145: CALL_OW 72
74149: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74150: LD_ADDR_VAR 0 10
74154: PUSH
74155: LD_EXP 42
74159: PUSH
74160: LD_VAR 0 2
74164: ARRAY
74165: PPUSH
74166: LD_INT 34
74168: PUSH
74169: LD_INT 31
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PPUSH
74176: CALL_OW 72
74180: ST_TO_ADDR
// if not cts and not mcts then
74181: LD_VAR 0 9
74185: NOT
74186: PUSH
74187: LD_VAR 0 10
74191: NOT
74192: AND
74193: IFFALSE 74197
// continue ;
74195: GO 74012
// x := cts ;
74197: LD_ADDR_VAR 0 11
74201: PUSH
74202: LD_VAR 0 9
74206: ST_TO_ADDR
// if not x then
74207: LD_VAR 0 11
74211: NOT
74212: IFFALSE 74224
// x := mcts ;
74214: LD_ADDR_VAR 0 11
74218: PUSH
74219: LD_VAR 0 10
74223: ST_TO_ADDR
// if not x then
74224: LD_VAR 0 11
74228: NOT
74229: IFFALSE 74233
// continue ;
74231: GO 74012
// if mc_remote_driver [ i ] then
74233: LD_EXP 63
74237: PUSH
74238: LD_VAR 0 2
74242: ARRAY
74243: IFFALSE 74630
// for j in mc_remote_driver [ i ] do
74245: LD_ADDR_VAR 0 3
74249: PUSH
74250: LD_EXP 63
74254: PUSH
74255: LD_VAR 0 2
74259: ARRAY
74260: PUSH
74261: FOR_IN
74262: IFFALSE 74628
// begin if GetClass ( j ) <> 3 then
74264: LD_VAR 0 3
74268: PPUSH
74269: CALL_OW 257
74273: PUSH
74274: LD_INT 3
74276: NONEQUAL
74277: IFFALSE 74330
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74279: LD_ADDR_EXP 63
74283: PUSH
74284: LD_EXP 63
74288: PPUSH
74289: LD_VAR 0 2
74293: PPUSH
74294: LD_EXP 63
74298: PUSH
74299: LD_VAR 0 2
74303: ARRAY
74304: PUSH
74305: LD_VAR 0 3
74309: DIFF
74310: PPUSH
74311: CALL_OW 1
74315: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74316: LD_VAR 0 3
74320: PPUSH
74321: LD_INT 0
74323: PPUSH
74324: CALL_OW 109
// continue ;
74328: GO 74261
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74330: LD_EXP 42
74334: PUSH
74335: LD_VAR 0 2
74339: ARRAY
74340: PPUSH
74341: LD_INT 34
74343: PUSH
74344: LD_INT 31
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: LD_INT 58
74353: PUSH
74354: EMPTY
74355: LIST
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PPUSH
74361: CALL_OW 72
74365: PUSH
74366: LD_VAR 0 3
74370: PPUSH
74371: CALL 46073 0 1
74375: NOT
74376: AND
74377: IFFALSE 74448
// begin if IsInUnit ( j ) then
74379: LD_VAR 0 3
74383: PPUSH
74384: CALL_OW 310
74388: IFFALSE 74399
// ComExitBuilding ( j ) ;
74390: LD_VAR 0 3
74394: PPUSH
74395: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74399: LD_VAR 0 3
74403: PPUSH
74404: LD_EXP 42
74408: PUSH
74409: LD_VAR 0 2
74413: ARRAY
74414: PPUSH
74415: LD_INT 34
74417: PUSH
74418: LD_INT 31
74420: PUSH
74421: EMPTY
74422: LIST
74423: LIST
74424: PUSH
74425: LD_INT 58
74427: PUSH
74428: EMPTY
74429: LIST
74430: PUSH
74431: EMPTY
74432: LIST
74433: LIST
74434: PPUSH
74435: CALL_OW 72
74439: PUSH
74440: LD_INT 1
74442: ARRAY
74443: PPUSH
74444: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74448: LD_VAR 0 3
74452: PPUSH
74453: CALL_OW 310
74457: NOT
74458: PUSH
74459: LD_VAR 0 3
74463: PPUSH
74464: CALL_OW 310
74468: PPUSH
74469: CALL_OW 266
74473: PUSH
74474: LD_INT 36
74476: NONEQUAL
74477: PUSH
74478: LD_VAR 0 3
74482: PPUSH
74483: CALL 46073 0 1
74487: NOT
74488: AND
74489: OR
74490: IFFALSE 74626
// begin if IsInUnit ( j ) then
74492: LD_VAR 0 3
74496: PPUSH
74497: CALL_OW 310
74501: IFFALSE 74512
// ComExitBuilding ( j ) ;
74503: LD_VAR 0 3
74507: PPUSH
74508: CALL_OW 122
// ct := 0 ;
74512: LD_ADDR_VAR 0 8
74516: PUSH
74517: LD_INT 0
74519: ST_TO_ADDR
// for k in x do
74520: LD_ADDR_VAR 0 4
74524: PUSH
74525: LD_VAR 0 11
74529: PUSH
74530: FOR_IN
74531: IFFALSE 74604
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74533: LD_VAR 0 4
74537: PPUSH
74538: CALL_OW 264
74542: PUSH
74543: LD_INT 31
74545: EQUAL
74546: PUSH
74547: LD_VAR 0 4
74551: PPUSH
74552: CALL_OW 311
74556: NOT
74557: AND
74558: PUSH
74559: LD_VAR 0 4
74563: PPUSH
74564: CALL_OW 266
74568: PUSH
74569: LD_INT 36
74571: EQUAL
74572: PUSH
74573: LD_VAR 0 4
74577: PPUSH
74578: CALL_OW 313
74582: PUSH
74583: LD_INT 3
74585: LESS
74586: AND
74587: OR
74588: IFFALSE 74602
// begin ct := k ;
74590: LD_ADDR_VAR 0 8
74594: PUSH
74595: LD_VAR 0 4
74599: ST_TO_ADDR
// break ;
74600: GO 74604
// end ;
74602: GO 74530
74604: POP
74605: POP
// if ct then
74606: LD_VAR 0 8
74610: IFFALSE 74626
// ComEnterUnit ( j , ct ) ;
74612: LD_VAR 0 3
74616: PPUSH
74617: LD_VAR 0 8
74621: PPUSH
74622: CALL_OW 120
// end ; end ;
74626: GO 74261
74628: POP
74629: POP
// places := 0 ;
74630: LD_ADDR_VAR 0 5
74634: PUSH
74635: LD_INT 0
74637: ST_TO_ADDR
// for j = 1 to x do
74638: LD_ADDR_VAR 0 3
74642: PUSH
74643: DOUBLE
74644: LD_INT 1
74646: DEC
74647: ST_TO_ADDR
74648: LD_VAR 0 11
74652: PUSH
74653: FOR_TO
74654: IFFALSE 74730
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74656: LD_VAR 0 11
74660: PUSH
74661: LD_VAR 0 3
74665: ARRAY
74666: PPUSH
74667: CALL_OW 264
74671: PUSH
74672: LD_INT 31
74674: EQUAL
74675: IFFALSE 74693
// places := places + 1 else
74677: LD_ADDR_VAR 0 5
74681: PUSH
74682: LD_VAR 0 5
74686: PUSH
74687: LD_INT 1
74689: PLUS
74690: ST_TO_ADDR
74691: GO 74728
// if GetBType ( x [ j ] ) = b_control_tower then
74693: LD_VAR 0 11
74697: PUSH
74698: LD_VAR 0 3
74702: ARRAY
74703: PPUSH
74704: CALL_OW 266
74708: PUSH
74709: LD_INT 36
74711: EQUAL
74712: IFFALSE 74728
// places := places + 3 ;
74714: LD_ADDR_VAR 0 5
74718: PUSH
74719: LD_VAR 0 5
74723: PUSH
74724: LD_INT 3
74726: PLUS
74727: ST_TO_ADDR
74728: GO 74653
74730: POP
74731: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74732: LD_VAR 0 5
74736: PUSH
74737: LD_INT 0
74739: EQUAL
74740: PUSH
74741: LD_VAR 0 5
74745: PUSH
74746: LD_EXP 63
74750: PUSH
74751: LD_VAR 0 2
74755: ARRAY
74756: LESSEQUAL
74757: OR
74758: IFFALSE 74762
// continue ;
74760: GO 74012
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74762: LD_ADDR_VAR 0 6
74766: PUSH
74767: LD_EXP 23
74771: PUSH
74772: LD_VAR 0 2
74776: ARRAY
74777: PPUSH
74778: LD_INT 25
74780: PUSH
74781: LD_INT 3
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PPUSH
74788: CALL_OW 72
74792: PUSH
74793: LD_EXP 63
74797: PUSH
74798: LD_VAR 0 2
74802: ARRAY
74803: DIFF
74804: PPUSH
74805: LD_INT 3
74807: PPUSH
74808: CALL 46973 0 2
74812: ST_TO_ADDR
// for j in tmp do
74813: LD_ADDR_VAR 0 3
74817: PUSH
74818: LD_VAR 0 6
74822: PUSH
74823: FOR_IN
74824: IFFALSE 74859
// if GetTag ( j ) > 0 then
74826: LD_VAR 0 3
74830: PPUSH
74831: CALL_OW 110
74835: PUSH
74836: LD_INT 0
74838: GREATER
74839: IFFALSE 74857
// tmp := tmp diff j ;
74841: LD_ADDR_VAR 0 6
74845: PUSH
74846: LD_VAR 0 6
74850: PUSH
74851: LD_VAR 0 3
74855: DIFF
74856: ST_TO_ADDR
74857: GO 74823
74859: POP
74860: POP
// if not tmp then
74861: LD_VAR 0 6
74865: NOT
74866: IFFALSE 74870
// continue ;
74868: GO 74012
// if places then
74870: LD_VAR 0 5
74874: IFFALSE 74933
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74876: LD_ADDR_EXP 63
74880: PUSH
74881: LD_EXP 63
74885: PPUSH
74886: LD_VAR 0 2
74890: PPUSH
74891: LD_EXP 63
74895: PUSH
74896: LD_VAR 0 2
74900: ARRAY
74901: PUSH
74902: LD_VAR 0 6
74906: PUSH
74907: LD_INT 1
74909: ARRAY
74910: UNION
74911: PPUSH
74912: CALL_OW 1
74916: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74917: LD_VAR 0 6
74921: PUSH
74922: LD_INT 1
74924: ARRAY
74925: PPUSH
74926: LD_INT 126
74928: PPUSH
74929: CALL_OW 109
// end ; end ;
74933: GO 74012
74935: POP
74936: POP
// end ;
74937: LD_VAR 0 1
74941: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74942: LD_INT 0
74944: PPUSH
74945: PPUSH
74946: PPUSH
74947: PPUSH
74948: PPUSH
74949: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74950: LD_VAR 0 1
74954: NOT
74955: PUSH
74956: LD_VAR 0 2
74960: NOT
74961: OR
74962: PUSH
74963: LD_VAR 0 3
74967: NOT
74968: OR
74969: PUSH
74970: LD_VAR 0 4
74974: PUSH
74975: LD_INT 1
74977: PUSH
74978: LD_INT 2
74980: PUSH
74981: LD_INT 3
74983: PUSH
74984: LD_INT 4
74986: PUSH
74987: LD_INT 5
74989: PUSH
74990: LD_INT 8
74992: PUSH
74993: LD_INT 9
74995: PUSH
74996: LD_INT 15
74998: PUSH
74999: LD_INT 16
75001: PUSH
75002: EMPTY
75003: LIST
75004: LIST
75005: LIST
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: LIST
75011: LIST
75012: IN
75013: NOT
75014: OR
75015: IFFALSE 75019
// exit ;
75017: GO 75919
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75019: LD_ADDR_VAR 0 2
75023: PUSH
75024: LD_VAR 0 2
75028: PPUSH
75029: LD_INT 21
75031: PUSH
75032: LD_INT 3
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PUSH
75039: LD_INT 24
75041: PUSH
75042: LD_INT 250
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PPUSH
75053: CALL_OW 72
75057: ST_TO_ADDR
// case class of 1 , 15 :
75058: LD_VAR 0 4
75062: PUSH
75063: LD_INT 1
75065: DOUBLE
75066: EQUAL
75067: IFTRUE 75077
75069: LD_INT 15
75071: DOUBLE
75072: EQUAL
75073: IFTRUE 75077
75075: GO 75162
75077: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75078: LD_ADDR_VAR 0 8
75082: PUSH
75083: LD_VAR 0 2
75087: PPUSH
75088: LD_INT 2
75090: PUSH
75091: LD_INT 30
75093: PUSH
75094: LD_INT 32
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: PUSH
75101: LD_INT 30
75103: PUSH
75104: LD_INT 31
75106: PUSH
75107: EMPTY
75108: LIST
75109: LIST
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: LIST
75115: PPUSH
75116: CALL_OW 72
75120: PUSH
75121: LD_VAR 0 2
75125: PPUSH
75126: LD_INT 2
75128: PUSH
75129: LD_INT 30
75131: PUSH
75132: LD_INT 4
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 30
75141: PUSH
75142: LD_INT 5
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: LIST
75153: PPUSH
75154: CALL_OW 72
75158: ADD
75159: ST_TO_ADDR
75160: GO 75408
75162: LD_INT 2
75164: DOUBLE
75165: EQUAL
75166: IFTRUE 75176
75168: LD_INT 16
75170: DOUBLE
75171: EQUAL
75172: IFTRUE 75176
75174: GO 75222
75176: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75177: LD_ADDR_VAR 0 8
75181: PUSH
75182: LD_VAR 0 2
75186: PPUSH
75187: LD_INT 2
75189: PUSH
75190: LD_INT 30
75192: PUSH
75193: LD_INT 0
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 30
75202: PUSH
75203: LD_INT 1
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: LIST
75214: PPUSH
75215: CALL_OW 72
75219: ST_TO_ADDR
75220: GO 75408
75222: LD_INT 3
75224: DOUBLE
75225: EQUAL
75226: IFTRUE 75230
75228: GO 75276
75230: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75231: LD_ADDR_VAR 0 8
75235: PUSH
75236: LD_VAR 0 2
75240: PPUSH
75241: LD_INT 2
75243: PUSH
75244: LD_INT 30
75246: PUSH
75247: LD_INT 2
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 30
75256: PUSH
75257: LD_INT 3
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: EMPTY
75265: LIST
75266: LIST
75267: LIST
75268: PPUSH
75269: CALL_OW 72
75273: ST_TO_ADDR
75274: GO 75408
75276: LD_INT 4
75278: DOUBLE
75279: EQUAL
75280: IFTRUE 75284
75282: GO 75341
75284: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75285: LD_ADDR_VAR 0 8
75289: PUSH
75290: LD_VAR 0 2
75294: PPUSH
75295: LD_INT 2
75297: PUSH
75298: LD_INT 30
75300: PUSH
75301: LD_INT 6
75303: PUSH
75304: EMPTY
75305: LIST
75306: LIST
75307: PUSH
75308: LD_INT 30
75310: PUSH
75311: LD_INT 7
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: LD_INT 30
75320: PUSH
75321: LD_INT 8
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: PUSH
75328: EMPTY
75329: LIST
75330: LIST
75331: LIST
75332: LIST
75333: PPUSH
75334: CALL_OW 72
75338: ST_TO_ADDR
75339: GO 75408
75341: LD_INT 5
75343: DOUBLE
75344: EQUAL
75345: IFTRUE 75361
75347: LD_INT 8
75349: DOUBLE
75350: EQUAL
75351: IFTRUE 75361
75353: LD_INT 9
75355: DOUBLE
75356: EQUAL
75357: IFTRUE 75361
75359: GO 75407
75361: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75362: LD_ADDR_VAR 0 8
75366: PUSH
75367: LD_VAR 0 2
75371: PPUSH
75372: LD_INT 2
75374: PUSH
75375: LD_INT 30
75377: PUSH
75378: LD_INT 4
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: PUSH
75385: LD_INT 30
75387: PUSH
75388: LD_INT 5
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: LIST
75399: PPUSH
75400: CALL_OW 72
75404: ST_TO_ADDR
75405: GO 75408
75407: POP
// if not tmp then
75408: LD_VAR 0 8
75412: NOT
75413: IFFALSE 75417
// exit ;
75415: GO 75919
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75417: LD_VAR 0 4
75421: PUSH
75422: LD_INT 1
75424: PUSH
75425: LD_INT 15
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: IN
75432: PUSH
75433: LD_EXP 32
75437: PUSH
75438: LD_VAR 0 1
75442: ARRAY
75443: AND
75444: IFFALSE 75600
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75446: LD_ADDR_VAR 0 9
75450: PUSH
75451: LD_EXP 32
75455: PUSH
75456: LD_VAR 0 1
75460: ARRAY
75461: PUSH
75462: LD_INT 1
75464: ARRAY
75465: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75466: LD_VAR 0 9
75470: PUSH
75471: LD_EXP 33
75475: PUSH
75476: LD_VAR 0 1
75480: ARRAY
75481: IN
75482: NOT
75483: IFFALSE 75598
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75485: LD_ADDR_EXP 33
75489: PUSH
75490: LD_EXP 33
75494: PPUSH
75495: LD_VAR 0 1
75499: PUSH
75500: LD_EXP 33
75504: PUSH
75505: LD_VAR 0 1
75509: ARRAY
75510: PUSH
75511: LD_INT 1
75513: PLUS
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PPUSH
75519: LD_VAR 0 9
75523: PPUSH
75524: CALL 16152 0 3
75528: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75529: LD_ADDR_EXP 32
75533: PUSH
75534: LD_EXP 32
75538: PPUSH
75539: LD_VAR 0 1
75543: PPUSH
75544: LD_EXP 32
75548: PUSH
75549: LD_VAR 0 1
75553: ARRAY
75554: PUSH
75555: LD_VAR 0 9
75559: DIFF
75560: PPUSH
75561: CALL_OW 1
75565: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75566: LD_VAR 0 3
75570: PPUSH
75571: LD_EXP 33
75575: PUSH
75576: LD_VAR 0 1
75580: ARRAY
75581: PUSH
75582: LD_EXP 33
75586: PUSH
75587: LD_VAR 0 1
75591: ARRAY
75592: ARRAY
75593: PPUSH
75594: CALL_OW 120
// end ; exit ;
75598: GO 75919
// end ; if tmp > 1 then
75600: LD_VAR 0 8
75604: PUSH
75605: LD_INT 1
75607: GREATER
75608: IFFALSE 75712
// for i = 2 to tmp do
75610: LD_ADDR_VAR 0 6
75614: PUSH
75615: DOUBLE
75616: LD_INT 2
75618: DEC
75619: ST_TO_ADDR
75620: LD_VAR 0 8
75624: PUSH
75625: FOR_TO
75626: IFFALSE 75710
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75628: LD_VAR 0 8
75632: PUSH
75633: LD_VAR 0 6
75637: ARRAY
75638: PPUSH
75639: CALL_OW 461
75643: PUSH
75644: LD_INT 6
75646: EQUAL
75647: IFFALSE 75708
// begin x := tmp [ i ] ;
75649: LD_ADDR_VAR 0 9
75653: PUSH
75654: LD_VAR 0 8
75658: PUSH
75659: LD_VAR 0 6
75663: ARRAY
75664: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75665: LD_ADDR_VAR 0 8
75669: PUSH
75670: LD_VAR 0 8
75674: PPUSH
75675: LD_VAR 0 6
75679: PPUSH
75680: CALL_OW 3
75684: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75685: LD_ADDR_VAR 0 8
75689: PUSH
75690: LD_VAR 0 8
75694: PPUSH
75695: LD_INT 1
75697: PPUSH
75698: LD_VAR 0 9
75702: PPUSH
75703: CALL_OW 2
75707: ST_TO_ADDR
// end ;
75708: GO 75625
75710: POP
75711: POP
// for i in tmp do
75712: LD_ADDR_VAR 0 6
75716: PUSH
75717: LD_VAR 0 8
75721: PUSH
75722: FOR_IN
75723: IFFALSE 75792
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75725: LD_VAR 0 6
75729: PPUSH
75730: CALL_OW 313
75734: PUSH
75735: LD_INT 6
75737: LESS
75738: PUSH
75739: LD_VAR 0 6
75743: PPUSH
75744: CALL_OW 266
75748: PUSH
75749: LD_INT 31
75751: PUSH
75752: LD_INT 32
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: IN
75759: NOT
75760: AND
75761: PUSH
75762: LD_VAR 0 6
75766: PPUSH
75767: CALL_OW 313
75771: PUSH
75772: LD_INT 0
75774: EQUAL
75775: OR
75776: IFFALSE 75790
// begin j := i ;
75778: LD_ADDR_VAR 0 7
75782: PUSH
75783: LD_VAR 0 6
75787: ST_TO_ADDR
// break ;
75788: GO 75792
// end ; end ;
75790: GO 75722
75792: POP
75793: POP
// if j then
75794: LD_VAR 0 7
75798: IFFALSE 75816
// ComEnterUnit ( unit , j ) else
75800: LD_VAR 0 3
75804: PPUSH
75805: LD_VAR 0 7
75809: PPUSH
75810: CALL_OW 120
75814: GO 75919
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75816: LD_ADDR_VAR 0 10
75820: PUSH
75821: LD_VAR 0 2
75825: PPUSH
75826: LD_INT 2
75828: PUSH
75829: LD_INT 30
75831: PUSH
75832: LD_INT 0
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PUSH
75839: LD_INT 30
75841: PUSH
75842: LD_INT 1
75844: PUSH
75845: EMPTY
75846: LIST
75847: LIST
75848: PUSH
75849: EMPTY
75850: LIST
75851: LIST
75852: LIST
75853: PPUSH
75854: CALL_OW 72
75858: ST_TO_ADDR
// if depot then
75859: LD_VAR 0 10
75863: IFFALSE 75919
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75865: LD_ADDR_VAR 0 10
75869: PUSH
75870: LD_VAR 0 10
75874: PPUSH
75875: LD_VAR 0 3
75879: PPUSH
75880: CALL_OW 74
75884: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75885: LD_VAR 0 3
75889: PPUSH
75890: LD_VAR 0 10
75894: PPUSH
75895: CALL_OW 296
75899: PUSH
75900: LD_INT 10
75902: GREATER
75903: IFFALSE 75919
// ComStandNearbyBuilding ( unit , depot ) ;
75905: LD_VAR 0 3
75909: PPUSH
75910: LD_VAR 0 10
75914: PPUSH
75915: CALL 12579 0 2
// end ; end ; end ;
75919: LD_VAR 0 5
75923: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
75924: LD_INT 0
75926: PPUSH
75927: PPUSH
75928: PPUSH
75929: PPUSH
// if not mc_bases then
75930: LD_EXP 23
75934: NOT
75935: IFFALSE 75939
// exit ;
75937: GO 76178
// for i = 1 to mc_bases do
75939: LD_ADDR_VAR 0 2
75943: PUSH
75944: DOUBLE
75945: LD_INT 1
75947: DEC
75948: ST_TO_ADDR
75949: LD_EXP 23
75953: PUSH
75954: FOR_TO
75955: IFFALSE 76176
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75957: LD_ADDR_VAR 0 4
75961: PUSH
75962: LD_EXP 23
75966: PUSH
75967: LD_VAR 0 2
75971: ARRAY
75972: PPUSH
75973: LD_INT 21
75975: PUSH
75976: LD_INT 1
75978: PUSH
75979: EMPTY
75980: LIST
75981: LIST
75982: PPUSH
75983: CALL_OW 72
75987: PUSH
75988: LD_EXP 52
75992: PUSH
75993: LD_VAR 0 2
75997: ARRAY
75998: UNION
75999: ST_TO_ADDR
// if not tmp then
76000: LD_VAR 0 4
76004: NOT
76005: IFFALSE 76009
// continue ;
76007: GO 75954
// for j in tmp do
76009: LD_ADDR_VAR 0 3
76013: PUSH
76014: LD_VAR 0 4
76018: PUSH
76019: FOR_IN
76020: IFFALSE 76172
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76022: LD_VAR 0 3
76026: PPUSH
76027: CALL_OW 110
76031: NOT
76032: PUSH
76033: LD_VAR 0 3
76037: PPUSH
76038: CALL_OW 314
76042: NOT
76043: AND
76044: PUSH
76045: LD_VAR 0 3
76049: PPUSH
76050: CALL_OW 311
76054: NOT
76055: AND
76056: PUSH
76057: LD_VAR 0 3
76061: PPUSH
76062: CALL_OW 310
76066: NOT
76067: AND
76068: PUSH
76069: LD_VAR 0 3
76073: PUSH
76074: LD_EXP 26
76078: PUSH
76079: LD_VAR 0 2
76083: ARRAY
76084: PUSH
76085: LD_INT 1
76087: ARRAY
76088: IN
76089: NOT
76090: AND
76091: PUSH
76092: LD_VAR 0 3
76096: PUSH
76097: LD_EXP 26
76101: PUSH
76102: LD_VAR 0 2
76106: ARRAY
76107: PUSH
76108: LD_INT 2
76110: ARRAY
76111: IN
76112: NOT
76113: AND
76114: PUSH
76115: LD_VAR 0 3
76119: PUSH
76120: LD_EXP 35
76124: PUSH
76125: LD_VAR 0 2
76129: ARRAY
76130: IN
76131: NOT
76132: AND
76133: IFFALSE 76170
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76135: LD_VAR 0 2
76139: PPUSH
76140: LD_EXP 23
76144: PUSH
76145: LD_VAR 0 2
76149: ARRAY
76150: PPUSH
76151: LD_VAR 0 3
76155: PPUSH
76156: LD_VAR 0 3
76160: PPUSH
76161: CALL_OW 257
76165: PPUSH
76166: CALL 74942 0 4
// end ;
76170: GO 76019
76172: POP
76173: POP
// end ;
76174: GO 75954
76176: POP
76177: POP
// end ;
76178: LD_VAR 0 1
76182: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76183: LD_INT 0
76185: PPUSH
76186: PPUSH
76187: PPUSH
76188: PPUSH
76189: PPUSH
76190: PPUSH
// if not mc_bases [ base ] then
76191: LD_EXP 23
76195: PUSH
76196: LD_VAR 0 1
76200: ARRAY
76201: NOT
76202: IFFALSE 76206
// exit ;
76204: GO 76388
// tmp := [ ] ;
76206: LD_ADDR_VAR 0 6
76210: PUSH
76211: EMPTY
76212: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76213: LD_ADDR_VAR 0 7
76217: PUSH
76218: LD_VAR 0 3
76222: PPUSH
76223: LD_INT 0
76225: PPUSH
76226: CALL_OW 517
76230: ST_TO_ADDR
// if not list then
76231: LD_VAR 0 7
76235: NOT
76236: IFFALSE 76240
// exit ;
76238: GO 76388
// for i = 1 to amount do
76240: LD_ADDR_VAR 0 5
76244: PUSH
76245: DOUBLE
76246: LD_INT 1
76248: DEC
76249: ST_TO_ADDR
76250: LD_VAR 0 2
76254: PUSH
76255: FOR_TO
76256: IFFALSE 76336
// begin x := rand ( 1 , list [ 1 ] ) ;
76258: LD_ADDR_VAR 0 8
76262: PUSH
76263: LD_INT 1
76265: PPUSH
76266: LD_VAR 0 7
76270: PUSH
76271: LD_INT 1
76273: ARRAY
76274: PPUSH
76275: CALL_OW 12
76279: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76280: LD_ADDR_VAR 0 6
76284: PUSH
76285: LD_VAR 0 6
76289: PPUSH
76290: LD_VAR 0 5
76294: PPUSH
76295: LD_VAR 0 7
76299: PUSH
76300: LD_INT 1
76302: ARRAY
76303: PUSH
76304: LD_VAR 0 8
76308: ARRAY
76309: PUSH
76310: LD_VAR 0 7
76314: PUSH
76315: LD_INT 2
76317: ARRAY
76318: PUSH
76319: LD_VAR 0 8
76323: ARRAY
76324: PUSH
76325: EMPTY
76326: LIST
76327: LIST
76328: PPUSH
76329: CALL_OW 1
76333: ST_TO_ADDR
// end ;
76334: GO 76255
76336: POP
76337: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76338: LD_ADDR_EXP 36
76342: PUSH
76343: LD_EXP 36
76347: PPUSH
76348: LD_VAR 0 1
76352: PPUSH
76353: LD_VAR 0 6
76357: PPUSH
76358: CALL_OW 1
76362: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76363: LD_ADDR_EXP 38
76367: PUSH
76368: LD_EXP 38
76372: PPUSH
76373: LD_VAR 0 1
76377: PPUSH
76378: LD_VAR 0 3
76382: PPUSH
76383: CALL_OW 1
76387: ST_TO_ADDR
// end ;
76388: LD_VAR 0 4
76392: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76393: LD_INT 0
76395: PPUSH
// if not mc_bases [ base ] then
76396: LD_EXP 23
76400: PUSH
76401: LD_VAR 0 1
76405: ARRAY
76406: NOT
76407: IFFALSE 76411
// exit ;
76409: GO 76436
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76411: LD_ADDR_EXP 28
76415: PUSH
76416: LD_EXP 28
76420: PPUSH
76421: LD_VAR 0 1
76425: PPUSH
76426: LD_VAR 0 2
76430: PPUSH
76431: CALL_OW 1
76435: ST_TO_ADDR
// end ;
76436: LD_VAR 0 3
76440: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76441: LD_INT 0
76443: PPUSH
// if not mc_bases [ base ] then
76444: LD_EXP 23
76448: PUSH
76449: LD_VAR 0 1
76453: ARRAY
76454: NOT
76455: IFFALSE 76459
// exit ;
76457: GO 76496
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76459: LD_ADDR_EXP 28
76463: PUSH
76464: LD_EXP 28
76468: PPUSH
76469: LD_VAR 0 1
76473: PPUSH
76474: LD_EXP 28
76478: PUSH
76479: LD_VAR 0 1
76483: ARRAY
76484: PUSH
76485: LD_VAR 0 2
76489: UNION
76490: PPUSH
76491: CALL_OW 1
76495: ST_TO_ADDR
// end ;
76496: LD_VAR 0 3
76500: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76501: LD_INT 0
76503: PPUSH
// if not mc_bases [ base ] then
76504: LD_EXP 23
76508: PUSH
76509: LD_VAR 0 1
76513: ARRAY
76514: NOT
76515: IFFALSE 76519
// exit ;
76517: GO 76544
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76519: LD_ADDR_EXP 44
76523: PUSH
76524: LD_EXP 44
76528: PPUSH
76529: LD_VAR 0 1
76533: PPUSH
76534: LD_VAR 0 2
76538: PPUSH
76539: CALL_OW 1
76543: ST_TO_ADDR
// end ;
76544: LD_VAR 0 3
76548: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76549: LD_INT 0
76551: PPUSH
// if not mc_bases [ base ] then
76552: LD_EXP 23
76556: PUSH
76557: LD_VAR 0 1
76561: ARRAY
76562: NOT
76563: IFFALSE 76567
// exit ;
76565: GO 76604
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76567: LD_ADDR_EXP 44
76571: PUSH
76572: LD_EXP 44
76576: PPUSH
76577: LD_VAR 0 1
76581: PPUSH
76582: LD_EXP 44
76586: PUSH
76587: LD_VAR 0 1
76591: ARRAY
76592: PUSH
76593: LD_VAR 0 2
76597: ADD
76598: PPUSH
76599: CALL_OW 1
76603: ST_TO_ADDR
// end ;
76604: LD_VAR 0 3
76608: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76609: LD_INT 0
76611: PPUSH
// if not mc_bases [ base ] then
76612: LD_EXP 23
76616: PUSH
76617: LD_VAR 0 1
76621: ARRAY
76622: NOT
76623: IFFALSE 76627
// exit ;
76625: GO 76681
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76627: LD_ADDR_EXP 45
76631: PUSH
76632: LD_EXP 45
76636: PPUSH
76637: LD_VAR 0 1
76641: PPUSH
76642: LD_VAR 0 2
76646: PPUSH
76647: CALL_OW 1
76651: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76652: LD_ADDR_EXP 34
76656: PUSH
76657: LD_EXP 34
76661: PPUSH
76662: LD_VAR 0 1
76666: PPUSH
76667: LD_VAR 0 2
76671: PUSH
76672: LD_INT 0
76674: PLUS
76675: PPUSH
76676: CALL_OW 1
76680: ST_TO_ADDR
// end ;
76681: LD_VAR 0 3
76685: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76686: LD_INT 0
76688: PPUSH
// if not mc_bases [ base ] then
76689: LD_EXP 23
76693: PUSH
76694: LD_VAR 0 1
76698: ARRAY
76699: NOT
76700: IFFALSE 76704
// exit ;
76702: GO 76729
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76704: LD_ADDR_EXP 34
76708: PUSH
76709: LD_EXP 34
76713: PPUSH
76714: LD_VAR 0 1
76718: PPUSH
76719: LD_VAR 0 2
76723: PPUSH
76724: CALL_OW 1
76728: ST_TO_ADDR
// end ;
76729: LD_VAR 0 3
76733: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76734: LD_INT 0
76736: PPUSH
76737: PPUSH
76738: PPUSH
76739: PPUSH
// if not mc_bases [ base ] then
76740: LD_EXP 23
76744: PUSH
76745: LD_VAR 0 1
76749: ARRAY
76750: NOT
76751: IFFALSE 76755
// exit ;
76753: GO 76820
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76755: LD_ADDR_EXP 43
76759: PUSH
76760: LD_EXP 43
76764: PPUSH
76765: LD_VAR 0 1
76769: PUSH
76770: LD_EXP 43
76774: PUSH
76775: LD_VAR 0 1
76779: ARRAY
76780: PUSH
76781: LD_INT 1
76783: PLUS
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: PPUSH
76789: LD_VAR 0 1
76793: PUSH
76794: LD_VAR 0 2
76798: PUSH
76799: LD_VAR 0 3
76803: PUSH
76804: LD_VAR 0 4
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: LIST
76813: LIST
76814: PPUSH
76815: CALL 16152 0 3
76819: ST_TO_ADDR
// end ;
76820: LD_VAR 0 5
76824: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76825: LD_INT 0
76827: PPUSH
// if not mc_bases [ base ] then
76828: LD_EXP 23
76832: PUSH
76833: LD_VAR 0 1
76837: ARRAY
76838: NOT
76839: IFFALSE 76843
// exit ;
76841: GO 76868
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76843: LD_ADDR_EXP 60
76847: PUSH
76848: LD_EXP 60
76852: PPUSH
76853: LD_VAR 0 1
76857: PPUSH
76858: LD_VAR 0 2
76862: PPUSH
76863: CALL_OW 1
76867: ST_TO_ADDR
// end ;
76868: LD_VAR 0 3
76872: RET
// export function MC_GetMinesField ( base ) ; begin
76873: LD_INT 0
76875: PPUSH
// result := mc_mines [ base ] ;
76876: LD_ADDR_VAR 0 2
76880: PUSH
76881: LD_EXP 36
76885: PUSH
76886: LD_VAR 0 1
76890: ARRAY
76891: ST_TO_ADDR
// end ;
76892: LD_VAR 0 2
76896: RET
// export function MC_GetProduceList ( base ) ; begin
76897: LD_INT 0
76899: PPUSH
// result := mc_produce [ base ] ;
76900: LD_ADDR_VAR 0 2
76904: PUSH
76905: LD_EXP 44
76909: PUSH
76910: LD_VAR 0 1
76914: ARRAY
76915: ST_TO_ADDR
// end ;
76916: LD_VAR 0 2
76920: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76921: LD_INT 0
76923: PPUSH
76924: PPUSH
// if not mc_bases then
76925: LD_EXP 23
76929: NOT
76930: IFFALSE 76934
// exit ;
76932: GO 76999
// if mc_bases [ base ] then
76934: LD_EXP 23
76938: PUSH
76939: LD_VAR 0 1
76943: ARRAY
76944: IFFALSE 76999
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76946: LD_ADDR_VAR 0 3
76950: PUSH
76951: LD_EXP 23
76955: PUSH
76956: LD_VAR 0 1
76960: ARRAY
76961: PPUSH
76962: LD_INT 30
76964: PUSH
76965: LD_VAR 0 2
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: PPUSH
76974: CALL_OW 72
76978: ST_TO_ADDR
// if result then
76979: LD_VAR 0 3
76983: IFFALSE 76999
// result := result [ 1 ] ;
76985: LD_ADDR_VAR 0 3
76989: PUSH
76990: LD_VAR 0 3
76994: PUSH
76995: LD_INT 1
76997: ARRAY
76998: ST_TO_ADDR
// end ; end ;
76999: LD_VAR 0 3
77003: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
77004: LD_INT 0
77006: PPUSH
77007: PPUSH
// if not mc_bases then
77008: LD_EXP 23
77012: NOT
77013: IFFALSE 77017
// exit ;
77015: GO 77062
// if mc_bases [ base ] then
77017: LD_EXP 23
77021: PUSH
77022: LD_VAR 0 1
77026: ARRAY
77027: IFFALSE 77062
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77029: LD_ADDR_VAR 0 3
77033: PUSH
77034: LD_EXP 23
77038: PUSH
77039: LD_VAR 0 1
77043: ARRAY
77044: PPUSH
77045: LD_INT 30
77047: PUSH
77048: LD_VAR 0 2
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: PPUSH
77057: CALL_OW 72
77061: ST_TO_ADDR
// end ;
77062: LD_VAR 0 3
77066: RET
// export function MC_SetTame ( base , area ) ; begin
77067: LD_INT 0
77069: PPUSH
// if not mc_bases or not base then
77070: LD_EXP 23
77074: NOT
77075: PUSH
77076: LD_VAR 0 1
77080: NOT
77081: OR
77082: IFFALSE 77086
// exit ;
77084: GO 77111
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77086: LD_ADDR_EXP 51
77090: PUSH
77091: LD_EXP 51
77095: PPUSH
77096: LD_VAR 0 1
77100: PPUSH
77101: LD_VAR 0 2
77105: PPUSH
77106: CALL_OW 1
77110: ST_TO_ADDR
// end ;
77111: LD_VAR 0 3
77115: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77116: LD_INT 0
77118: PPUSH
77119: PPUSH
// if not mc_bases or not base then
77120: LD_EXP 23
77124: NOT
77125: PUSH
77126: LD_VAR 0 1
77130: NOT
77131: OR
77132: IFFALSE 77136
// exit ;
77134: GO 77238
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77136: LD_ADDR_VAR 0 4
77140: PUSH
77141: LD_EXP 23
77145: PUSH
77146: LD_VAR 0 1
77150: ARRAY
77151: PPUSH
77152: LD_INT 30
77154: PUSH
77155: LD_VAR 0 2
77159: PUSH
77160: EMPTY
77161: LIST
77162: LIST
77163: PPUSH
77164: CALL_OW 72
77168: ST_TO_ADDR
// if not tmp then
77169: LD_VAR 0 4
77173: NOT
77174: IFFALSE 77178
// exit ;
77176: GO 77238
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77178: LD_ADDR_EXP 55
77182: PUSH
77183: LD_EXP 55
77187: PPUSH
77188: LD_VAR 0 1
77192: PPUSH
77193: LD_EXP 55
77197: PUSH
77198: LD_VAR 0 1
77202: ARRAY
77203: PPUSH
77204: LD_EXP 55
77208: PUSH
77209: LD_VAR 0 1
77213: ARRAY
77214: PUSH
77215: LD_INT 1
77217: PLUS
77218: PPUSH
77219: LD_VAR 0 4
77223: PUSH
77224: LD_INT 1
77226: ARRAY
77227: PPUSH
77228: CALL_OW 2
77232: PPUSH
77233: CALL_OW 1
77237: ST_TO_ADDR
// end ;
77238: LD_VAR 0 3
77242: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77243: LD_INT 0
77245: PPUSH
77246: PPUSH
// if not mc_bases or not base or not kinds then
77247: LD_EXP 23
77251: NOT
77252: PUSH
77253: LD_VAR 0 1
77257: NOT
77258: OR
77259: PUSH
77260: LD_VAR 0 2
77264: NOT
77265: OR
77266: IFFALSE 77270
// exit ;
77268: GO 77331
// for i in kinds do
77270: LD_ADDR_VAR 0 4
77274: PUSH
77275: LD_VAR 0 2
77279: PUSH
77280: FOR_IN
77281: IFFALSE 77329
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77283: LD_ADDR_EXP 57
77287: PUSH
77288: LD_EXP 57
77292: PPUSH
77293: LD_VAR 0 1
77297: PUSH
77298: LD_EXP 57
77302: PUSH
77303: LD_VAR 0 1
77307: ARRAY
77308: PUSH
77309: LD_INT 1
77311: PLUS
77312: PUSH
77313: EMPTY
77314: LIST
77315: LIST
77316: PPUSH
77317: LD_VAR 0 4
77321: PPUSH
77322: CALL 16152 0 3
77326: ST_TO_ADDR
77327: GO 77280
77329: POP
77330: POP
// end ;
77331: LD_VAR 0 3
77335: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77336: LD_INT 0
77338: PPUSH
// if not mc_bases or not base or not areas then
77339: LD_EXP 23
77343: NOT
77344: PUSH
77345: LD_VAR 0 1
77349: NOT
77350: OR
77351: PUSH
77352: LD_VAR 0 2
77356: NOT
77357: OR
77358: IFFALSE 77362
// exit ;
77360: GO 77387
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77362: LD_ADDR_EXP 41
77366: PUSH
77367: LD_EXP 41
77371: PPUSH
77372: LD_VAR 0 1
77376: PPUSH
77377: LD_VAR 0 2
77381: PPUSH
77382: CALL_OW 1
77386: ST_TO_ADDR
// end ;
77387: LD_VAR 0 3
77391: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77392: LD_INT 0
77394: PPUSH
// if not mc_bases or not base or not teleports_exit then
77395: LD_EXP 23
77399: NOT
77400: PUSH
77401: LD_VAR 0 1
77405: NOT
77406: OR
77407: PUSH
77408: LD_VAR 0 2
77412: NOT
77413: OR
77414: IFFALSE 77418
// exit ;
77416: GO 77443
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77418: LD_ADDR_EXP 58
77422: PUSH
77423: LD_EXP 58
77427: PPUSH
77428: LD_VAR 0 1
77432: PPUSH
77433: LD_VAR 0 2
77437: PPUSH
77438: CALL_OW 1
77442: ST_TO_ADDR
// end ;
77443: LD_VAR 0 3
77447: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77448: LD_INT 0
77450: PPUSH
77451: PPUSH
77452: PPUSH
// if not mc_bases or not base or not ext_list then
77453: LD_EXP 23
77457: NOT
77458: PUSH
77459: LD_VAR 0 1
77463: NOT
77464: OR
77465: PUSH
77466: LD_VAR 0 5
77470: NOT
77471: OR
77472: IFFALSE 77476
// exit ;
77474: GO 77649
// tmp := GetFacExtXYD ( x , y , d ) ;
77476: LD_ADDR_VAR 0 8
77480: PUSH
77481: LD_VAR 0 2
77485: PPUSH
77486: LD_VAR 0 3
77490: PPUSH
77491: LD_VAR 0 4
77495: PPUSH
77496: CALL 46103 0 3
77500: ST_TO_ADDR
// if not tmp then
77501: LD_VAR 0 8
77505: NOT
77506: IFFALSE 77510
// exit ;
77508: GO 77649
// for i in tmp do
77510: LD_ADDR_VAR 0 7
77514: PUSH
77515: LD_VAR 0 8
77519: PUSH
77520: FOR_IN
77521: IFFALSE 77647
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77523: LD_ADDR_EXP 28
77527: PUSH
77528: LD_EXP 28
77532: PPUSH
77533: LD_VAR 0 1
77537: PPUSH
77538: LD_EXP 28
77542: PUSH
77543: LD_VAR 0 1
77547: ARRAY
77548: PPUSH
77549: LD_EXP 28
77553: PUSH
77554: LD_VAR 0 1
77558: ARRAY
77559: PUSH
77560: LD_INT 1
77562: PLUS
77563: PPUSH
77564: LD_VAR 0 5
77568: PUSH
77569: LD_INT 1
77571: ARRAY
77572: PUSH
77573: LD_VAR 0 7
77577: PUSH
77578: LD_INT 1
77580: ARRAY
77581: PUSH
77582: LD_VAR 0 7
77586: PUSH
77587: LD_INT 2
77589: ARRAY
77590: PUSH
77591: LD_VAR 0 7
77595: PUSH
77596: LD_INT 3
77598: ARRAY
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: PPUSH
77606: CALL_OW 2
77610: PPUSH
77611: CALL_OW 1
77615: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77616: LD_ADDR_VAR 0 5
77620: PUSH
77621: LD_VAR 0 5
77625: PPUSH
77626: LD_INT 1
77628: PPUSH
77629: CALL_OW 3
77633: ST_TO_ADDR
// if not ext_list then
77634: LD_VAR 0 5
77638: NOT
77639: IFFALSE 77645
// exit ;
77641: POP
77642: POP
77643: GO 77649
// end ;
77645: GO 77520
77647: POP
77648: POP
// end ;
77649: LD_VAR 0 6
77653: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77654: LD_INT 0
77656: PPUSH
// if not mc_bases or not base or not weapon_list then
77657: LD_EXP 23
77661: NOT
77662: PUSH
77663: LD_VAR 0 1
77667: NOT
77668: OR
77669: PUSH
77670: LD_VAR 0 2
77674: NOT
77675: OR
77676: IFFALSE 77680
// exit ;
77678: GO 77705
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77680: LD_ADDR_EXP 62
77684: PUSH
77685: LD_EXP 62
77689: PPUSH
77690: LD_VAR 0 1
77694: PPUSH
77695: LD_VAR 0 2
77699: PPUSH
77700: CALL_OW 1
77704: ST_TO_ADDR
// end ;
77705: LD_VAR 0 3
77709: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77710: LD_INT 0
77712: PPUSH
// if not mc_bases or not base or not tech_list then
77713: LD_EXP 23
77717: NOT
77718: PUSH
77719: LD_VAR 0 1
77723: NOT
77724: OR
77725: PUSH
77726: LD_VAR 0 2
77730: NOT
77731: OR
77732: IFFALSE 77736
// exit ;
77734: GO 77761
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77736: LD_ADDR_EXP 50
77740: PUSH
77741: LD_EXP 50
77745: PPUSH
77746: LD_VAR 0 1
77750: PPUSH
77751: LD_VAR 0 2
77755: PPUSH
77756: CALL_OW 1
77760: ST_TO_ADDR
// end ;
77761: LD_VAR 0 3
77765: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77766: LD_INT 0
77768: PPUSH
// if not mc_bases or not parking_area or not base then
77769: LD_EXP 23
77773: NOT
77774: PUSH
77775: LD_VAR 0 2
77779: NOT
77780: OR
77781: PUSH
77782: LD_VAR 0 1
77786: NOT
77787: OR
77788: IFFALSE 77792
// exit ;
77790: GO 77817
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77792: LD_ADDR_EXP 47
77796: PUSH
77797: LD_EXP 47
77801: PPUSH
77802: LD_VAR 0 1
77806: PPUSH
77807: LD_VAR 0 2
77811: PPUSH
77812: CALL_OW 1
77816: ST_TO_ADDR
// end ;
77817: LD_VAR 0 3
77821: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77822: LD_INT 0
77824: PPUSH
// if not mc_bases or not base or not scan_area then
77825: LD_EXP 23
77829: NOT
77830: PUSH
77831: LD_VAR 0 1
77835: NOT
77836: OR
77837: PUSH
77838: LD_VAR 0 2
77842: NOT
77843: OR
77844: IFFALSE 77848
// exit ;
77846: GO 77873
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77848: LD_ADDR_EXP 48
77852: PUSH
77853: LD_EXP 48
77857: PPUSH
77858: LD_VAR 0 1
77862: PPUSH
77863: LD_VAR 0 2
77867: PPUSH
77868: CALL_OW 1
77872: ST_TO_ADDR
// end ;
77873: LD_VAR 0 3
77877: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77878: LD_INT 0
77880: PPUSH
77881: PPUSH
// if not mc_bases or not base then
77882: LD_EXP 23
77886: NOT
77887: PUSH
77888: LD_VAR 0 1
77892: NOT
77893: OR
77894: IFFALSE 77898
// exit ;
77896: GO 77962
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77898: LD_ADDR_VAR 0 3
77902: PUSH
77903: LD_INT 1
77905: PUSH
77906: LD_INT 2
77908: PUSH
77909: LD_INT 3
77911: PUSH
77912: LD_INT 4
77914: PUSH
77915: LD_INT 11
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: LIST
77922: LIST
77923: LIST
77924: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77925: LD_ADDR_EXP 50
77929: PUSH
77930: LD_EXP 50
77934: PPUSH
77935: LD_VAR 0 1
77939: PPUSH
77940: LD_EXP 50
77944: PUSH
77945: LD_VAR 0 1
77949: ARRAY
77950: PUSH
77951: LD_VAR 0 3
77955: DIFF
77956: PPUSH
77957: CALL_OW 1
77961: ST_TO_ADDR
// end ;
77962: LD_VAR 0 2
77966: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77967: LD_INT 0
77969: PPUSH
// result := mc_vehicles [ base ] ;
77970: LD_ADDR_VAR 0 3
77974: PUSH
77975: LD_EXP 42
77979: PUSH
77980: LD_VAR 0 1
77984: ARRAY
77985: ST_TO_ADDR
// if onlyCombat then
77986: LD_VAR 0 2
77990: IFFALSE 78162
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77992: LD_ADDR_VAR 0 3
77996: PUSH
77997: LD_VAR 0 3
78001: PUSH
78002: LD_VAR 0 3
78006: PPUSH
78007: LD_INT 2
78009: PUSH
78010: LD_INT 34
78012: PUSH
78013: LD_INT 12
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 34
78022: PUSH
78023: LD_INT 51
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 34
78032: PUSH
78033: LD_INT 89
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 34
78042: PUSH
78043: LD_INT 32
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 34
78052: PUSH
78053: LD_INT 13
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 34
78062: PUSH
78063: LD_INT 52
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: PUSH
78070: LD_INT 34
78072: PUSH
78073: LD_INT 88
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 34
78082: PUSH
78083: LD_INT 14
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 34
78092: PUSH
78093: LD_INT 53
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 34
78102: PUSH
78103: LD_INT 98
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 34
78112: PUSH
78113: LD_INT 31
78115: PUSH
78116: EMPTY
78117: LIST
78118: LIST
78119: PUSH
78120: LD_INT 34
78122: PUSH
78123: LD_INT 48
78125: PUSH
78126: EMPTY
78127: LIST
78128: LIST
78129: PUSH
78130: LD_INT 34
78132: PUSH
78133: LD_INT 8
78135: PUSH
78136: EMPTY
78137: LIST
78138: LIST
78139: PUSH
78140: EMPTY
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: PPUSH
78156: CALL_OW 72
78160: DIFF
78161: ST_TO_ADDR
// end ; end_of_file
78162: LD_VAR 0 3
78166: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78167: LD_INT 0
78169: PPUSH
78170: PPUSH
78171: PPUSH
// if not mc_bases or not skirmish then
78172: LD_EXP 23
78176: NOT
78177: PUSH
78178: LD_EXP 21
78182: NOT
78183: OR
78184: IFFALSE 78188
// exit ;
78186: GO 78353
// for i = 1 to mc_bases do
78188: LD_ADDR_VAR 0 4
78192: PUSH
78193: DOUBLE
78194: LD_INT 1
78196: DEC
78197: ST_TO_ADDR
78198: LD_EXP 23
78202: PUSH
78203: FOR_TO
78204: IFFALSE 78351
// begin if sci in mc_bases [ i ] then
78206: LD_VAR 0 2
78210: PUSH
78211: LD_EXP 23
78215: PUSH
78216: LD_VAR 0 4
78220: ARRAY
78221: IN
78222: IFFALSE 78349
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78224: LD_ADDR_EXP 52
78228: PUSH
78229: LD_EXP 52
78233: PPUSH
78234: LD_VAR 0 4
78238: PUSH
78239: LD_EXP 52
78243: PUSH
78244: LD_VAR 0 4
78248: ARRAY
78249: PUSH
78250: LD_INT 1
78252: PLUS
78253: PUSH
78254: EMPTY
78255: LIST
78256: LIST
78257: PPUSH
78258: LD_VAR 0 1
78262: PPUSH
78263: CALL 16152 0 3
78267: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78268: LD_ADDR_VAR 0 5
78272: PUSH
78273: LD_EXP 23
78277: PUSH
78278: LD_VAR 0 4
78282: ARRAY
78283: PPUSH
78284: LD_INT 2
78286: PUSH
78287: LD_INT 30
78289: PUSH
78290: LD_INT 0
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 30
78299: PUSH
78300: LD_INT 1
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: LIST
78311: PPUSH
78312: CALL_OW 72
78316: PPUSH
78317: LD_VAR 0 1
78321: PPUSH
78322: CALL_OW 74
78326: ST_TO_ADDR
// if tmp then
78327: LD_VAR 0 5
78331: IFFALSE 78347
// ComStandNearbyBuilding ( ape , tmp ) ;
78333: LD_VAR 0 1
78337: PPUSH
78338: LD_VAR 0 5
78342: PPUSH
78343: CALL 12579 0 2
// break ;
78347: GO 78351
// end ; end ;
78349: GO 78203
78351: POP
78352: POP
// end ;
78353: LD_VAR 0 3
78357: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78358: LD_INT 0
78360: PPUSH
78361: PPUSH
78362: PPUSH
// if not mc_bases or not skirmish then
78363: LD_EXP 23
78367: NOT
78368: PUSH
78369: LD_EXP 21
78373: NOT
78374: OR
78375: IFFALSE 78379
// exit ;
78377: GO 78468
// for i = 1 to mc_bases do
78379: LD_ADDR_VAR 0 4
78383: PUSH
78384: DOUBLE
78385: LD_INT 1
78387: DEC
78388: ST_TO_ADDR
78389: LD_EXP 23
78393: PUSH
78394: FOR_TO
78395: IFFALSE 78466
// begin if building in mc_busy_turret_list [ i ] then
78397: LD_VAR 0 1
78401: PUSH
78402: LD_EXP 33
78406: PUSH
78407: LD_VAR 0 4
78411: ARRAY
78412: IN
78413: IFFALSE 78464
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78415: LD_ADDR_VAR 0 5
78419: PUSH
78420: LD_EXP 33
78424: PUSH
78425: LD_VAR 0 4
78429: ARRAY
78430: PUSH
78431: LD_VAR 0 1
78435: DIFF
78436: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78437: LD_ADDR_EXP 33
78441: PUSH
78442: LD_EXP 33
78446: PPUSH
78447: LD_VAR 0 4
78451: PPUSH
78452: LD_VAR 0 5
78456: PPUSH
78457: CALL_OW 1
78461: ST_TO_ADDR
// break ;
78462: GO 78466
// end ; end ;
78464: GO 78394
78466: POP
78467: POP
// end ;
78468: LD_VAR 0 3
78472: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78473: LD_INT 0
78475: PPUSH
78476: PPUSH
78477: PPUSH
// if not mc_bases or not skirmish then
78478: LD_EXP 23
78482: NOT
78483: PUSH
78484: LD_EXP 21
78488: NOT
78489: OR
78490: IFFALSE 78494
// exit ;
78492: GO 78693
// for i = 1 to mc_bases do
78494: LD_ADDR_VAR 0 5
78498: PUSH
78499: DOUBLE
78500: LD_INT 1
78502: DEC
78503: ST_TO_ADDR
78504: LD_EXP 23
78508: PUSH
78509: FOR_TO
78510: IFFALSE 78691
// if building in mc_bases [ i ] then
78512: LD_VAR 0 1
78516: PUSH
78517: LD_EXP 23
78521: PUSH
78522: LD_VAR 0 5
78526: ARRAY
78527: IN
78528: IFFALSE 78689
// begin tmp := mc_bases [ i ] diff building ;
78530: LD_ADDR_VAR 0 6
78534: PUSH
78535: LD_EXP 23
78539: PUSH
78540: LD_VAR 0 5
78544: ARRAY
78545: PUSH
78546: LD_VAR 0 1
78550: DIFF
78551: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78552: LD_ADDR_EXP 23
78556: PUSH
78557: LD_EXP 23
78561: PPUSH
78562: LD_VAR 0 5
78566: PPUSH
78567: LD_VAR 0 6
78571: PPUSH
78572: CALL_OW 1
78576: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78577: LD_VAR 0 1
78581: PUSH
78582: LD_EXP 31
78586: PUSH
78587: LD_VAR 0 5
78591: ARRAY
78592: IN
78593: IFFALSE 78632
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78595: LD_ADDR_EXP 31
78599: PUSH
78600: LD_EXP 31
78604: PPUSH
78605: LD_VAR 0 5
78609: PPUSH
78610: LD_EXP 31
78614: PUSH
78615: LD_VAR 0 5
78619: ARRAY
78620: PUSH
78621: LD_VAR 0 1
78625: DIFF
78626: PPUSH
78627: CALL_OW 1
78631: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78632: LD_VAR 0 1
78636: PUSH
78637: LD_EXP 32
78641: PUSH
78642: LD_VAR 0 5
78646: ARRAY
78647: IN
78648: IFFALSE 78687
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78650: LD_ADDR_EXP 32
78654: PUSH
78655: LD_EXP 32
78659: PPUSH
78660: LD_VAR 0 5
78664: PPUSH
78665: LD_EXP 32
78669: PUSH
78670: LD_VAR 0 5
78674: ARRAY
78675: PUSH
78676: LD_VAR 0 1
78680: DIFF
78681: PPUSH
78682: CALL_OW 1
78686: ST_TO_ADDR
// break ;
78687: GO 78691
// end ;
78689: GO 78509
78691: POP
78692: POP
// end ;
78693: LD_VAR 0 4
78697: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78698: LD_INT 0
78700: PPUSH
78701: PPUSH
78702: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78703: LD_EXP 23
78707: NOT
78708: PUSH
78709: LD_EXP 21
78713: NOT
78714: OR
78715: PUSH
78716: LD_VAR 0 3
78720: PUSH
78721: LD_EXP 49
78725: IN
78726: NOT
78727: OR
78728: IFFALSE 78732
// exit ;
78730: GO 78855
// for i = 1 to mc_vehicles do
78732: LD_ADDR_VAR 0 6
78736: PUSH
78737: DOUBLE
78738: LD_INT 1
78740: DEC
78741: ST_TO_ADDR
78742: LD_EXP 42
78746: PUSH
78747: FOR_TO
78748: IFFALSE 78853
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78750: LD_VAR 0 2
78754: PUSH
78755: LD_EXP 42
78759: PUSH
78760: LD_VAR 0 6
78764: ARRAY
78765: IN
78766: PUSH
78767: LD_VAR 0 1
78771: PUSH
78772: LD_EXP 42
78776: PUSH
78777: LD_VAR 0 6
78781: ARRAY
78782: IN
78783: OR
78784: IFFALSE 78851
// begin tmp := mc_vehicles [ i ] diff old ;
78786: LD_ADDR_VAR 0 7
78790: PUSH
78791: LD_EXP 42
78795: PUSH
78796: LD_VAR 0 6
78800: ARRAY
78801: PUSH
78802: LD_VAR 0 2
78806: DIFF
78807: ST_TO_ADDR
// tmp := tmp diff new ;
78808: LD_ADDR_VAR 0 7
78812: PUSH
78813: LD_VAR 0 7
78817: PUSH
78818: LD_VAR 0 1
78822: DIFF
78823: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78824: LD_ADDR_EXP 42
78828: PUSH
78829: LD_EXP 42
78833: PPUSH
78834: LD_VAR 0 6
78838: PPUSH
78839: LD_VAR 0 7
78843: PPUSH
78844: CALL_OW 1
78848: ST_TO_ADDR
// break ;
78849: GO 78853
// end ;
78851: GO 78747
78853: POP
78854: POP
// end ;
78855: LD_VAR 0 5
78859: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78860: LD_INT 0
78862: PPUSH
78863: PPUSH
78864: PPUSH
78865: PPUSH
// if not mc_bases or not skirmish then
78866: LD_EXP 23
78870: NOT
78871: PUSH
78872: LD_EXP 21
78876: NOT
78877: OR
78878: IFFALSE 78882
// exit ;
78880: GO 79264
// side := GetSide ( vehicle ) ;
78882: LD_ADDR_VAR 0 5
78886: PUSH
78887: LD_VAR 0 1
78891: PPUSH
78892: CALL_OW 255
78896: ST_TO_ADDR
// for i = 1 to mc_bases do
78897: LD_ADDR_VAR 0 4
78901: PUSH
78902: DOUBLE
78903: LD_INT 1
78905: DEC
78906: ST_TO_ADDR
78907: LD_EXP 23
78911: PUSH
78912: FOR_TO
78913: IFFALSE 79262
// begin if factory in mc_bases [ i ] then
78915: LD_VAR 0 2
78919: PUSH
78920: LD_EXP 23
78924: PUSH
78925: LD_VAR 0 4
78929: ARRAY
78930: IN
78931: IFFALSE 79260
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78933: LD_EXP 45
78937: PUSH
78938: LD_VAR 0 4
78942: ARRAY
78943: PUSH
78944: LD_EXP 34
78948: PUSH
78949: LD_VAR 0 4
78953: ARRAY
78954: LESS
78955: PUSH
78956: LD_VAR 0 1
78960: PPUSH
78961: CALL_OW 264
78965: PUSH
78966: LD_INT 31
78968: PUSH
78969: LD_INT 32
78971: PUSH
78972: LD_INT 51
78974: PUSH
78975: LD_INT 89
78977: PUSH
78978: LD_INT 12
78980: PUSH
78981: LD_INT 30
78983: PUSH
78984: LD_INT 98
78986: PUSH
78987: LD_INT 11
78989: PUSH
78990: LD_INT 53
78992: PUSH
78993: LD_INT 14
78995: PUSH
78996: LD_INT 91
78998: PUSH
78999: LD_INT 29
79001: PUSH
79002: LD_INT 99
79004: PUSH
79005: LD_INT 13
79007: PUSH
79008: LD_INT 52
79010: PUSH
79011: LD_INT 88
79013: PUSH
79014: LD_INT 48
79016: PUSH
79017: LD_INT 8
79019: PUSH
79020: EMPTY
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: LIST
79026: LIST
79027: LIST
79028: LIST
79029: LIST
79030: LIST
79031: LIST
79032: LIST
79033: LIST
79034: LIST
79035: LIST
79036: LIST
79037: LIST
79038: LIST
79039: IN
79040: NOT
79041: AND
79042: IFFALSE 79090
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79044: LD_ADDR_EXP 45
79048: PUSH
79049: LD_EXP 45
79053: PPUSH
79054: LD_VAR 0 4
79058: PUSH
79059: LD_EXP 45
79063: PUSH
79064: LD_VAR 0 4
79068: ARRAY
79069: PUSH
79070: LD_INT 1
79072: PLUS
79073: PUSH
79074: EMPTY
79075: LIST
79076: LIST
79077: PPUSH
79078: LD_VAR 0 1
79082: PPUSH
79083: CALL 16152 0 3
79087: ST_TO_ADDR
79088: GO 79134
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79090: LD_ADDR_EXP 42
79094: PUSH
79095: LD_EXP 42
79099: PPUSH
79100: LD_VAR 0 4
79104: PUSH
79105: LD_EXP 42
79109: PUSH
79110: LD_VAR 0 4
79114: ARRAY
79115: PUSH
79116: LD_INT 1
79118: PLUS
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PPUSH
79124: LD_VAR 0 1
79128: PPUSH
79129: CALL 16152 0 3
79133: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79134: LD_VAR 0 1
79138: PPUSH
79139: CALL_OW 263
79143: PUSH
79144: LD_INT 2
79146: EQUAL
79147: IFFALSE 79176
// begin repeat wait ( 0 0$3 ) ;
79149: LD_INT 105
79151: PPUSH
79152: CALL_OW 67
// Connect ( vehicle ) ;
79156: LD_VAR 0 1
79160: PPUSH
79161: CALL 19121 0 1
// until IsControledBy ( vehicle ) ;
79165: LD_VAR 0 1
79169: PPUSH
79170: CALL_OW 312
79174: IFFALSE 79149
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79176: LD_VAR 0 1
79180: PPUSH
79181: LD_EXP 47
79185: PUSH
79186: LD_VAR 0 4
79190: ARRAY
79191: PPUSH
79192: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79196: LD_VAR 0 1
79200: PPUSH
79201: CALL_OW 263
79205: PUSH
79206: LD_INT 1
79208: NONEQUAL
79209: IFFALSE 79213
// break ;
79211: GO 79262
// repeat wait ( 0 0$1 ) ;
79213: LD_INT 35
79215: PPUSH
79216: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79220: LD_VAR 0 1
79224: PPUSH
79225: LD_EXP 47
79229: PUSH
79230: LD_VAR 0 4
79234: ARRAY
79235: PPUSH
79236: CALL_OW 308
79240: IFFALSE 79213
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79242: LD_VAR 0 1
79246: PPUSH
79247: CALL_OW 311
79251: PPUSH
79252: CALL_OW 121
// exit ;
79256: POP
79257: POP
79258: GO 79264
// end ; end ;
79260: GO 78912
79262: POP
79263: POP
// end ;
79264: LD_VAR 0 3
79268: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79269: LD_INT 0
79271: PPUSH
79272: PPUSH
79273: PPUSH
79274: PPUSH
// if not mc_bases or not skirmish then
79275: LD_EXP 23
79279: NOT
79280: PUSH
79281: LD_EXP 21
79285: NOT
79286: OR
79287: IFFALSE 79291
// exit ;
79289: GO 79644
// repeat wait ( 0 0$1 ) ;
79291: LD_INT 35
79293: PPUSH
79294: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79298: LD_VAR 0 2
79302: PPUSH
79303: LD_VAR 0 3
79307: PPUSH
79308: CALL_OW 284
79312: IFFALSE 79291
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79314: LD_VAR 0 2
79318: PPUSH
79319: LD_VAR 0 3
79323: PPUSH
79324: CALL_OW 283
79328: PUSH
79329: LD_INT 4
79331: EQUAL
79332: IFFALSE 79336
// exit ;
79334: GO 79644
// for i = 1 to mc_bases do
79336: LD_ADDR_VAR 0 7
79340: PUSH
79341: DOUBLE
79342: LD_INT 1
79344: DEC
79345: ST_TO_ADDR
79346: LD_EXP 23
79350: PUSH
79351: FOR_TO
79352: IFFALSE 79642
// begin if mc_crates_area [ i ] then
79354: LD_EXP 41
79358: PUSH
79359: LD_VAR 0 7
79363: ARRAY
79364: IFFALSE 79475
// for j in mc_crates_area [ i ] do
79366: LD_ADDR_VAR 0 8
79370: PUSH
79371: LD_EXP 41
79375: PUSH
79376: LD_VAR 0 7
79380: ARRAY
79381: PUSH
79382: FOR_IN
79383: IFFALSE 79473
// if InArea ( x , y , j ) then
79385: LD_VAR 0 2
79389: PPUSH
79390: LD_VAR 0 3
79394: PPUSH
79395: LD_VAR 0 8
79399: PPUSH
79400: CALL_OW 309
79404: IFFALSE 79471
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79406: LD_ADDR_EXP 39
79410: PUSH
79411: LD_EXP 39
79415: PPUSH
79416: LD_VAR 0 7
79420: PUSH
79421: LD_EXP 39
79425: PUSH
79426: LD_VAR 0 7
79430: ARRAY
79431: PUSH
79432: LD_INT 1
79434: PLUS
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PPUSH
79440: LD_VAR 0 4
79444: PUSH
79445: LD_VAR 0 2
79449: PUSH
79450: LD_VAR 0 3
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: LIST
79459: PPUSH
79460: CALL 16152 0 3
79464: ST_TO_ADDR
// exit ;
79465: POP
79466: POP
79467: POP
79468: POP
79469: GO 79644
// end ;
79471: GO 79382
79473: POP
79474: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79475: LD_ADDR_VAR 0 9
79479: PUSH
79480: LD_EXP 23
79484: PUSH
79485: LD_VAR 0 7
79489: ARRAY
79490: PPUSH
79491: LD_INT 2
79493: PUSH
79494: LD_INT 30
79496: PUSH
79497: LD_INT 0
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: LD_INT 30
79506: PUSH
79507: LD_INT 1
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: LIST
79518: PPUSH
79519: CALL_OW 72
79523: ST_TO_ADDR
// if not depot then
79524: LD_VAR 0 9
79528: NOT
79529: IFFALSE 79533
// continue ;
79531: GO 79351
// for j in depot do
79533: LD_ADDR_VAR 0 8
79537: PUSH
79538: LD_VAR 0 9
79542: PUSH
79543: FOR_IN
79544: IFFALSE 79638
// if GetDistUnitXY ( j , x , y ) < 30 then
79546: LD_VAR 0 8
79550: PPUSH
79551: LD_VAR 0 2
79555: PPUSH
79556: LD_VAR 0 3
79560: PPUSH
79561: CALL_OW 297
79565: PUSH
79566: LD_INT 30
79568: LESS
79569: IFFALSE 79636
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79571: LD_ADDR_EXP 39
79575: PUSH
79576: LD_EXP 39
79580: PPUSH
79581: LD_VAR 0 7
79585: PUSH
79586: LD_EXP 39
79590: PUSH
79591: LD_VAR 0 7
79595: ARRAY
79596: PUSH
79597: LD_INT 1
79599: PLUS
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: PPUSH
79605: LD_VAR 0 4
79609: PUSH
79610: LD_VAR 0 2
79614: PUSH
79615: LD_VAR 0 3
79619: PUSH
79620: EMPTY
79621: LIST
79622: LIST
79623: LIST
79624: PPUSH
79625: CALL 16152 0 3
79629: ST_TO_ADDR
// exit ;
79630: POP
79631: POP
79632: POP
79633: POP
79634: GO 79644
// end ;
79636: GO 79543
79638: POP
79639: POP
// end ;
79640: GO 79351
79642: POP
79643: POP
// end ;
79644: LD_VAR 0 6
79648: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79649: LD_INT 0
79651: PPUSH
79652: PPUSH
79653: PPUSH
79654: PPUSH
// if not mc_bases or not skirmish then
79655: LD_EXP 23
79659: NOT
79660: PUSH
79661: LD_EXP 21
79665: NOT
79666: OR
79667: IFFALSE 79671
// exit ;
79669: GO 79948
// side := GetSide ( lab ) ;
79671: LD_ADDR_VAR 0 4
79675: PUSH
79676: LD_VAR 0 2
79680: PPUSH
79681: CALL_OW 255
79685: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79686: LD_VAR 0 4
79690: PUSH
79691: LD_EXP 49
79695: IN
79696: NOT
79697: PUSH
79698: LD_EXP 50
79702: NOT
79703: OR
79704: PUSH
79705: LD_EXP 23
79709: NOT
79710: OR
79711: IFFALSE 79715
// exit ;
79713: GO 79948
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79715: LD_ADDR_EXP 50
79719: PUSH
79720: LD_EXP 50
79724: PPUSH
79725: LD_VAR 0 4
79729: PPUSH
79730: LD_EXP 50
79734: PUSH
79735: LD_VAR 0 4
79739: ARRAY
79740: PUSH
79741: LD_VAR 0 1
79745: DIFF
79746: PPUSH
79747: CALL_OW 1
79751: ST_TO_ADDR
// for i = 1 to mc_bases do
79752: LD_ADDR_VAR 0 5
79756: PUSH
79757: DOUBLE
79758: LD_INT 1
79760: DEC
79761: ST_TO_ADDR
79762: LD_EXP 23
79766: PUSH
79767: FOR_TO
79768: IFFALSE 79946
// begin if lab in mc_bases [ i ] then
79770: LD_VAR 0 2
79774: PUSH
79775: LD_EXP 23
79779: PUSH
79780: LD_VAR 0 5
79784: ARRAY
79785: IN
79786: IFFALSE 79944
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79788: LD_VAR 0 1
79792: PUSH
79793: LD_INT 11
79795: PUSH
79796: LD_INT 4
79798: PUSH
79799: LD_INT 3
79801: PUSH
79802: LD_INT 2
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: LIST
79809: LIST
79810: IN
79811: PUSH
79812: LD_EXP 53
79816: PUSH
79817: LD_VAR 0 5
79821: ARRAY
79822: AND
79823: IFFALSE 79944
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79825: LD_ADDR_VAR 0 6
79829: PUSH
79830: LD_EXP 53
79834: PUSH
79835: LD_VAR 0 5
79839: ARRAY
79840: PUSH
79841: LD_INT 1
79843: ARRAY
79844: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79845: LD_ADDR_EXP 53
79849: PUSH
79850: LD_EXP 53
79854: PPUSH
79855: LD_VAR 0 5
79859: PPUSH
79860: EMPTY
79861: PPUSH
79862: CALL_OW 1
79866: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79867: LD_VAR 0 6
79871: PPUSH
79872: LD_INT 0
79874: PPUSH
79875: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79879: LD_VAR 0 6
79883: PPUSH
79884: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79888: LD_ADDR_EXP 52
79892: PUSH
79893: LD_EXP 52
79897: PPUSH
79898: LD_VAR 0 5
79902: PPUSH
79903: LD_EXP 52
79907: PUSH
79908: LD_VAR 0 5
79912: ARRAY
79913: PPUSH
79914: LD_INT 1
79916: PPUSH
79917: LD_VAR 0 6
79921: PPUSH
79922: CALL_OW 2
79926: PPUSH
79927: CALL_OW 1
79931: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79932: LD_VAR 0 5
79936: PPUSH
79937: LD_INT 112
79939: PPUSH
79940: CALL 56434 0 2
// end ; end ; end ;
79944: GO 79767
79946: POP
79947: POP
// end ;
79948: LD_VAR 0 3
79952: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79953: LD_INT 0
79955: PPUSH
79956: PPUSH
79957: PPUSH
79958: PPUSH
79959: PPUSH
79960: PPUSH
79961: PPUSH
79962: PPUSH
// if not mc_bases or not skirmish then
79963: LD_EXP 23
79967: NOT
79968: PUSH
79969: LD_EXP 21
79973: NOT
79974: OR
79975: IFFALSE 79979
// exit ;
79977: GO 81348
// for i = 1 to mc_bases do
79979: LD_ADDR_VAR 0 3
79983: PUSH
79984: DOUBLE
79985: LD_INT 1
79987: DEC
79988: ST_TO_ADDR
79989: LD_EXP 23
79993: PUSH
79994: FOR_TO
79995: IFFALSE 81346
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79997: LD_VAR 0 1
80001: PUSH
80002: LD_EXP 23
80006: PUSH
80007: LD_VAR 0 3
80011: ARRAY
80012: IN
80013: PUSH
80014: LD_VAR 0 1
80018: PUSH
80019: LD_EXP 30
80023: PUSH
80024: LD_VAR 0 3
80028: ARRAY
80029: IN
80030: OR
80031: PUSH
80032: LD_VAR 0 1
80036: PUSH
80037: LD_EXP 45
80041: PUSH
80042: LD_VAR 0 3
80046: ARRAY
80047: IN
80048: OR
80049: PUSH
80050: LD_VAR 0 1
80054: PUSH
80055: LD_EXP 42
80059: PUSH
80060: LD_VAR 0 3
80064: ARRAY
80065: IN
80066: OR
80067: PUSH
80068: LD_VAR 0 1
80072: PUSH
80073: LD_EXP 52
80077: PUSH
80078: LD_VAR 0 3
80082: ARRAY
80083: IN
80084: OR
80085: PUSH
80086: LD_VAR 0 1
80090: PUSH
80091: LD_EXP 53
80095: PUSH
80096: LD_VAR 0 3
80100: ARRAY
80101: IN
80102: OR
80103: IFFALSE 81344
// begin if un in mc_ape [ i ] then
80105: LD_VAR 0 1
80109: PUSH
80110: LD_EXP 52
80114: PUSH
80115: LD_VAR 0 3
80119: ARRAY
80120: IN
80121: IFFALSE 80160
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80123: LD_ADDR_EXP 52
80127: PUSH
80128: LD_EXP 52
80132: PPUSH
80133: LD_VAR 0 3
80137: PPUSH
80138: LD_EXP 52
80142: PUSH
80143: LD_VAR 0 3
80147: ARRAY
80148: PUSH
80149: LD_VAR 0 1
80153: DIFF
80154: PPUSH
80155: CALL_OW 1
80159: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80160: LD_VAR 0 1
80164: PUSH
80165: LD_EXP 53
80169: PUSH
80170: LD_VAR 0 3
80174: ARRAY
80175: IN
80176: IFFALSE 80200
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80178: LD_ADDR_EXP 53
80182: PUSH
80183: LD_EXP 53
80187: PPUSH
80188: LD_VAR 0 3
80192: PPUSH
80193: EMPTY
80194: PPUSH
80195: CALL_OW 1
80199: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80200: LD_VAR 0 1
80204: PPUSH
80205: CALL_OW 247
80209: PUSH
80210: LD_INT 2
80212: EQUAL
80213: PUSH
80214: LD_VAR 0 1
80218: PPUSH
80219: CALL_OW 110
80223: PUSH
80224: LD_INT 20
80226: EQUAL
80227: PUSH
80228: LD_VAR 0 1
80232: PUSH
80233: LD_EXP 45
80237: PUSH
80238: LD_VAR 0 3
80242: ARRAY
80243: IN
80244: OR
80245: PUSH
80246: LD_VAR 0 1
80250: PPUSH
80251: CALL_OW 264
80255: PUSH
80256: LD_INT 12
80258: PUSH
80259: LD_INT 51
80261: PUSH
80262: LD_INT 89
80264: PUSH
80265: LD_INT 32
80267: PUSH
80268: LD_INT 13
80270: PUSH
80271: LD_INT 52
80273: PUSH
80274: LD_INT 31
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: IN
80286: OR
80287: AND
80288: IFFALSE 80596
// begin if un in mc_defender [ i ] then
80290: LD_VAR 0 1
80294: PUSH
80295: LD_EXP 45
80299: PUSH
80300: LD_VAR 0 3
80304: ARRAY
80305: IN
80306: IFFALSE 80345
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80308: LD_ADDR_EXP 45
80312: PUSH
80313: LD_EXP 45
80317: PPUSH
80318: LD_VAR 0 3
80322: PPUSH
80323: LD_EXP 45
80327: PUSH
80328: LD_VAR 0 3
80332: ARRAY
80333: PUSH
80334: LD_VAR 0 1
80338: DIFF
80339: PPUSH
80340: CALL_OW 1
80344: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80345: LD_ADDR_VAR 0 8
80349: PUSH
80350: LD_VAR 0 3
80354: PPUSH
80355: LD_INT 3
80357: PPUSH
80358: CALL 77004 0 2
80362: ST_TO_ADDR
// if fac then
80363: LD_VAR 0 8
80367: IFFALSE 80596
// begin for j in fac do
80369: LD_ADDR_VAR 0 4
80373: PUSH
80374: LD_VAR 0 8
80378: PUSH
80379: FOR_IN
80380: IFFALSE 80594
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80382: LD_ADDR_VAR 0 9
80386: PUSH
80387: LD_VAR 0 8
80391: PPUSH
80392: LD_VAR 0 1
80396: PPUSH
80397: CALL_OW 265
80401: PPUSH
80402: LD_VAR 0 1
80406: PPUSH
80407: CALL_OW 262
80411: PPUSH
80412: LD_VAR 0 1
80416: PPUSH
80417: CALL_OW 263
80421: PPUSH
80422: LD_VAR 0 1
80426: PPUSH
80427: CALL_OW 264
80431: PPUSH
80432: CALL 13650 0 5
80436: ST_TO_ADDR
// if components then
80437: LD_VAR 0 9
80441: IFFALSE 80592
// begin if GetWeapon ( un ) = ar_control_tower then
80443: LD_VAR 0 1
80447: PPUSH
80448: CALL_OW 264
80452: PUSH
80453: LD_INT 31
80455: EQUAL
80456: IFFALSE 80573
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80458: LD_VAR 0 1
80462: PPUSH
80463: CALL_OW 311
80467: PPUSH
80468: LD_INT 0
80470: PPUSH
80471: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80475: LD_ADDR_EXP 63
80479: PUSH
80480: LD_EXP 63
80484: PPUSH
80485: LD_VAR 0 3
80489: PPUSH
80490: LD_EXP 63
80494: PUSH
80495: LD_VAR 0 3
80499: ARRAY
80500: PUSH
80501: LD_VAR 0 1
80505: PPUSH
80506: CALL_OW 311
80510: DIFF
80511: PPUSH
80512: CALL_OW 1
80516: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80517: LD_ADDR_VAR 0 7
80521: PUSH
80522: LD_EXP 44
80526: PUSH
80527: LD_VAR 0 3
80531: ARRAY
80532: PPUSH
80533: LD_INT 1
80535: PPUSH
80536: LD_VAR 0 9
80540: PPUSH
80541: CALL_OW 2
80545: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80546: LD_ADDR_EXP 44
80550: PUSH
80551: LD_EXP 44
80555: PPUSH
80556: LD_VAR 0 3
80560: PPUSH
80561: LD_VAR 0 7
80565: PPUSH
80566: CALL_OW 1
80570: ST_TO_ADDR
// end else
80571: GO 80590
// MC_InsertProduceList ( i , [ components ] ) ;
80573: LD_VAR 0 3
80577: PPUSH
80578: LD_VAR 0 9
80582: PUSH
80583: EMPTY
80584: LIST
80585: PPUSH
80586: CALL 76549 0 2
// break ;
80590: GO 80594
// end ; end ;
80592: GO 80379
80594: POP
80595: POP
// end ; end ; if GetType ( un ) = unit_building then
80596: LD_VAR 0 1
80600: PPUSH
80601: CALL_OW 247
80605: PUSH
80606: LD_INT 3
80608: EQUAL
80609: IFFALSE 81012
// begin btype := GetBType ( un ) ;
80611: LD_ADDR_VAR 0 5
80615: PUSH
80616: LD_VAR 0 1
80620: PPUSH
80621: CALL_OW 266
80625: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80626: LD_VAR 0 5
80630: PUSH
80631: LD_INT 29
80633: PUSH
80634: LD_INT 30
80636: PUSH
80637: EMPTY
80638: LIST
80639: LIST
80640: IN
80641: IFFALSE 80714
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80643: LD_VAR 0 1
80647: PPUSH
80648: CALL_OW 250
80652: PPUSH
80653: LD_VAR 0 1
80657: PPUSH
80658: CALL_OW 251
80662: PPUSH
80663: LD_VAR 0 1
80667: PPUSH
80668: CALL_OW 255
80672: PPUSH
80673: CALL_OW 440
80677: NOT
80678: IFFALSE 80714
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80680: LD_VAR 0 1
80684: PPUSH
80685: CALL_OW 250
80689: PPUSH
80690: LD_VAR 0 1
80694: PPUSH
80695: CALL_OW 251
80699: PPUSH
80700: LD_VAR 0 1
80704: PPUSH
80705: CALL_OW 255
80709: PPUSH
80710: CALL_OW 441
// end ; if btype = b_warehouse then
80714: LD_VAR 0 5
80718: PUSH
80719: LD_INT 1
80721: EQUAL
80722: IFFALSE 80740
// begin btype := b_depot ;
80724: LD_ADDR_VAR 0 5
80728: PUSH
80729: LD_INT 0
80731: ST_TO_ADDR
// pos := 1 ;
80732: LD_ADDR_VAR 0 6
80736: PUSH
80737: LD_INT 1
80739: ST_TO_ADDR
// end ; if btype = b_factory then
80740: LD_VAR 0 5
80744: PUSH
80745: LD_INT 3
80747: EQUAL
80748: IFFALSE 80766
// begin btype := b_workshop ;
80750: LD_ADDR_VAR 0 5
80754: PUSH
80755: LD_INT 2
80757: ST_TO_ADDR
// pos := 1 ;
80758: LD_ADDR_VAR 0 6
80762: PUSH
80763: LD_INT 1
80765: ST_TO_ADDR
// end ; if btype = b_barracks then
80766: LD_VAR 0 5
80770: PUSH
80771: LD_INT 5
80773: EQUAL
80774: IFFALSE 80784
// btype := b_armoury ;
80776: LD_ADDR_VAR 0 5
80780: PUSH
80781: LD_INT 4
80783: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80784: LD_VAR 0 5
80788: PUSH
80789: LD_INT 7
80791: PUSH
80792: LD_INT 8
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: IN
80799: IFFALSE 80809
// btype := b_lab ;
80801: LD_ADDR_VAR 0 5
80805: PUSH
80806: LD_INT 6
80808: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80809: LD_ADDR_EXP 28
80813: PUSH
80814: LD_EXP 28
80818: PPUSH
80819: LD_VAR 0 3
80823: PUSH
80824: LD_EXP 28
80828: PUSH
80829: LD_VAR 0 3
80833: ARRAY
80834: PUSH
80835: LD_INT 1
80837: PLUS
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PPUSH
80843: LD_VAR 0 5
80847: PUSH
80848: LD_VAR 0 1
80852: PPUSH
80853: CALL_OW 250
80857: PUSH
80858: LD_VAR 0 1
80862: PPUSH
80863: CALL_OW 251
80867: PUSH
80868: LD_VAR 0 1
80872: PPUSH
80873: CALL_OW 254
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: PPUSH
80884: CALL 16152 0 3
80888: ST_TO_ADDR
// if pos = 1 then
80889: LD_VAR 0 6
80893: PUSH
80894: LD_INT 1
80896: EQUAL
80897: IFFALSE 81012
// begin tmp := mc_build_list [ i ] ;
80899: LD_ADDR_VAR 0 7
80903: PUSH
80904: LD_EXP 28
80908: PUSH
80909: LD_VAR 0 3
80913: ARRAY
80914: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80915: LD_VAR 0 7
80919: PPUSH
80920: LD_INT 2
80922: PUSH
80923: LD_INT 30
80925: PUSH
80926: LD_INT 0
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PUSH
80933: LD_INT 30
80935: PUSH
80936: LD_INT 1
80938: PUSH
80939: EMPTY
80940: LIST
80941: LIST
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: LIST
80947: PPUSH
80948: CALL_OW 72
80952: IFFALSE 80962
// pos := 2 ;
80954: LD_ADDR_VAR 0 6
80958: PUSH
80959: LD_INT 2
80961: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80962: LD_ADDR_VAR 0 7
80966: PUSH
80967: LD_VAR 0 7
80971: PPUSH
80972: LD_VAR 0 6
80976: PPUSH
80977: LD_VAR 0 7
80981: PPUSH
80982: CALL 16478 0 3
80986: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80987: LD_ADDR_EXP 28
80991: PUSH
80992: LD_EXP 28
80996: PPUSH
80997: LD_VAR 0 3
81001: PPUSH
81002: LD_VAR 0 7
81006: PPUSH
81007: CALL_OW 1
81011: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81012: LD_VAR 0 1
81016: PUSH
81017: LD_EXP 23
81021: PUSH
81022: LD_VAR 0 3
81026: ARRAY
81027: IN
81028: IFFALSE 81067
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81030: LD_ADDR_EXP 23
81034: PUSH
81035: LD_EXP 23
81039: PPUSH
81040: LD_VAR 0 3
81044: PPUSH
81045: LD_EXP 23
81049: PUSH
81050: LD_VAR 0 3
81054: ARRAY
81055: PUSH
81056: LD_VAR 0 1
81060: DIFF
81061: PPUSH
81062: CALL_OW 1
81066: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81067: LD_VAR 0 1
81071: PUSH
81072: LD_EXP 30
81076: PUSH
81077: LD_VAR 0 3
81081: ARRAY
81082: IN
81083: IFFALSE 81122
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81085: LD_ADDR_EXP 30
81089: PUSH
81090: LD_EXP 30
81094: PPUSH
81095: LD_VAR 0 3
81099: PPUSH
81100: LD_EXP 30
81104: PUSH
81105: LD_VAR 0 3
81109: ARRAY
81110: PUSH
81111: LD_VAR 0 1
81115: DIFF
81116: PPUSH
81117: CALL_OW 1
81121: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81122: LD_VAR 0 1
81126: PUSH
81127: LD_EXP 42
81131: PUSH
81132: LD_VAR 0 3
81136: ARRAY
81137: IN
81138: IFFALSE 81177
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81140: LD_ADDR_EXP 42
81144: PUSH
81145: LD_EXP 42
81149: PPUSH
81150: LD_VAR 0 3
81154: PPUSH
81155: LD_EXP 42
81159: PUSH
81160: LD_VAR 0 3
81164: ARRAY
81165: PUSH
81166: LD_VAR 0 1
81170: DIFF
81171: PPUSH
81172: CALL_OW 1
81176: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81177: LD_VAR 0 1
81181: PUSH
81182: LD_EXP 45
81186: PUSH
81187: LD_VAR 0 3
81191: ARRAY
81192: IN
81193: IFFALSE 81232
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81195: LD_ADDR_EXP 45
81199: PUSH
81200: LD_EXP 45
81204: PPUSH
81205: LD_VAR 0 3
81209: PPUSH
81210: LD_EXP 45
81214: PUSH
81215: LD_VAR 0 3
81219: ARRAY
81220: PUSH
81221: LD_VAR 0 1
81225: DIFF
81226: PPUSH
81227: CALL_OW 1
81231: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81232: LD_VAR 0 1
81236: PUSH
81237: LD_EXP 32
81241: PUSH
81242: LD_VAR 0 3
81246: ARRAY
81247: IN
81248: IFFALSE 81287
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81250: LD_ADDR_EXP 32
81254: PUSH
81255: LD_EXP 32
81259: PPUSH
81260: LD_VAR 0 3
81264: PPUSH
81265: LD_EXP 32
81269: PUSH
81270: LD_VAR 0 3
81274: ARRAY
81275: PUSH
81276: LD_VAR 0 1
81280: DIFF
81281: PPUSH
81282: CALL_OW 1
81286: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81287: LD_VAR 0 1
81291: PUSH
81292: LD_EXP 31
81296: PUSH
81297: LD_VAR 0 3
81301: ARRAY
81302: IN
81303: IFFALSE 81342
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81305: LD_ADDR_EXP 31
81309: PUSH
81310: LD_EXP 31
81314: PPUSH
81315: LD_VAR 0 3
81319: PPUSH
81320: LD_EXP 31
81324: PUSH
81325: LD_VAR 0 3
81329: ARRAY
81330: PUSH
81331: LD_VAR 0 1
81335: DIFF
81336: PPUSH
81337: CALL_OW 1
81341: ST_TO_ADDR
// end ; break ;
81342: GO 81346
// end ;
81344: GO 79994
81346: POP
81347: POP
// end ;
81348: LD_VAR 0 2
81352: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81353: LD_INT 0
81355: PPUSH
81356: PPUSH
81357: PPUSH
// if not mc_bases or not skirmish then
81358: LD_EXP 23
81362: NOT
81363: PUSH
81364: LD_EXP 21
81368: NOT
81369: OR
81370: IFFALSE 81374
// exit ;
81372: GO 81589
// for i = 1 to mc_bases do
81374: LD_ADDR_VAR 0 3
81378: PUSH
81379: DOUBLE
81380: LD_INT 1
81382: DEC
81383: ST_TO_ADDR
81384: LD_EXP 23
81388: PUSH
81389: FOR_TO
81390: IFFALSE 81587
// begin if building in mc_construct_list [ i ] then
81392: LD_VAR 0 1
81396: PUSH
81397: LD_EXP 30
81401: PUSH
81402: LD_VAR 0 3
81406: ARRAY
81407: IN
81408: IFFALSE 81585
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81410: LD_ADDR_EXP 30
81414: PUSH
81415: LD_EXP 30
81419: PPUSH
81420: LD_VAR 0 3
81424: PPUSH
81425: LD_EXP 30
81429: PUSH
81430: LD_VAR 0 3
81434: ARRAY
81435: PUSH
81436: LD_VAR 0 1
81440: DIFF
81441: PPUSH
81442: CALL_OW 1
81446: ST_TO_ADDR
// if building in mc_lab [ i ] then
81447: LD_VAR 0 1
81451: PUSH
81452: LD_EXP 56
81456: PUSH
81457: LD_VAR 0 3
81461: ARRAY
81462: IN
81463: IFFALSE 81518
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81465: LD_ADDR_EXP 57
81469: PUSH
81470: LD_EXP 57
81474: PPUSH
81475: LD_VAR 0 3
81479: PPUSH
81480: LD_EXP 57
81484: PUSH
81485: LD_VAR 0 3
81489: ARRAY
81490: PPUSH
81491: LD_INT 1
81493: PPUSH
81494: LD_EXP 57
81498: PUSH
81499: LD_VAR 0 3
81503: ARRAY
81504: PPUSH
81505: LD_INT 0
81507: PPUSH
81508: CALL 15570 0 4
81512: PPUSH
81513: CALL_OW 1
81517: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81518: LD_VAR 0 1
81522: PUSH
81523: LD_EXP 23
81527: PUSH
81528: LD_VAR 0 3
81532: ARRAY
81533: IN
81534: NOT
81535: IFFALSE 81581
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81537: LD_ADDR_EXP 23
81541: PUSH
81542: LD_EXP 23
81546: PPUSH
81547: LD_VAR 0 3
81551: PUSH
81552: LD_EXP 23
81556: PUSH
81557: LD_VAR 0 3
81561: ARRAY
81562: PUSH
81563: LD_INT 1
81565: PLUS
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PPUSH
81571: LD_VAR 0 1
81575: PPUSH
81576: CALL 16152 0 3
81580: ST_TO_ADDR
// exit ;
81581: POP
81582: POP
81583: GO 81589
// end ; end ;
81585: GO 81389
81587: POP
81588: POP
// end ;
81589: LD_VAR 0 2
81593: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81594: LD_INT 0
81596: PPUSH
81597: PPUSH
81598: PPUSH
81599: PPUSH
81600: PPUSH
81601: PPUSH
81602: PPUSH
// if not mc_bases or not skirmish then
81603: LD_EXP 23
81607: NOT
81608: PUSH
81609: LD_EXP 21
81613: NOT
81614: OR
81615: IFFALSE 81619
// exit ;
81617: GO 82280
// for i = 1 to mc_bases do
81619: LD_ADDR_VAR 0 3
81623: PUSH
81624: DOUBLE
81625: LD_INT 1
81627: DEC
81628: ST_TO_ADDR
81629: LD_EXP 23
81633: PUSH
81634: FOR_TO
81635: IFFALSE 82278
// begin if building in mc_construct_list [ i ] then
81637: LD_VAR 0 1
81641: PUSH
81642: LD_EXP 30
81646: PUSH
81647: LD_VAR 0 3
81651: ARRAY
81652: IN
81653: IFFALSE 82276
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81655: LD_ADDR_EXP 30
81659: PUSH
81660: LD_EXP 30
81664: PPUSH
81665: LD_VAR 0 3
81669: PPUSH
81670: LD_EXP 30
81674: PUSH
81675: LD_VAR 0 3
81679: ARRAY
81680: PUSH
81681: LD_VAR 0 1
81685: DIFF
81686: PPUSH
81687: CALL_OW 1
81691: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81692: LD_ADDR_EXP 23
81696: PUSH
81697: LD_EXP 23
81701: PPUSH
81702: LD_VAR 0 3
81706: PUSH
81707: LD_EXP 23
81711: PUSH
81712: LD_VAR 0 3
81716: ARRAY
81717: PUSH
81718: LD_INT 1
81720: PLUS
81721: PUSH
81722: EMPTY
81723: LIST
81724: LIST
81725: PPUSH
81726: LD_VAR 0 1
81730: PPUSH
81731: CALL 16152 0 3
81735: ST_TO_ADDR
// btype := GetBType ( building ) ;
81736: LD_ADDR_VAR 0 5
81740: PUSH
81741: LD_VAR 0 1
81745: PPUSH
81746: CALL_OW 266
81750: ST_TO_ADDR
// side := GetSide ( building ) ;
81751: LD_ADDR_VAR 0 8
81755: PUSH
81756: LD_VAR 0 1
81760: PPUSH
81761: CALL_OW 255
81765: ST_TO_ADDR
// if btype = b_lab then
81766: LD_VAR 0 5
81770: PUSH
81771: LD_INT 6
81773: EQUAL
81774: IFFALSE 81824
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81776: LD_ADDR_EXP 56
81780: PUSH
81781: LD_EXP 56
81785: PPUSH
81786: LD_VAR 0 3
81790: PUSH
81791: LD_EXP 56
81795: PUSH
81796: LD_VAR 0 3
81800: ARRAY
81801: PUSH
81802: LD_INT 1
81804: PLUS
81805: PUSH
81806: EMPTY
81807: LIST
81808: LIST
81809: PPUSH
81810: LD_VAR 0 1
81814: PPUSH
81815: CALL 16152 0 3
81819: ST_TO_ADDR
// exit ;
81820: POP
81821: POP
81822: GO 82280
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81824: LD_VAR 0 5
81828: PUSH
81829: LD_INT 0
81831: PUSH
81832: LD_INT 2
81834: PUSH
81835: LD_INT 4
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: LIST
81842: IN
81843: IFFALSE 81967
// begin if btype = b_armoury then
81845: LD_VAR 0 5
81849: PUSH
81850: LD_INT 4
81852: EQUAL
81853: IFFALSE 81863
// btype := b_barracks ;
81855: LD_ADDR_VAR 0 5
81859: PUSH
81860: LD_INT 5
81862: ST_TO_ADDR
// if btype = b_depot then
81863: LD_VAR 0 5
81867: PUSH
81868: LD_INT 0
81870: EQUAL
81871: IFFALSE 81881
// btype := b_warehouse ;
81873: LD_ADDR_VAR 0 5
81877: PUSH
81878: LD_INT 1
81880: ST_TO_ADDR
// if btype = b_workshop then
81881: LD_VAR 0 5
81885: PUSH
81886: LD_INT 2
81888: EQUAL
81889: IFFALSE 81899
// btype := b_factory ;
81891: LD_ADDR_VAR 0 5
81895: PUSH
81896: LD_INT 3
81898: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81899: LD_VAR 0 5
81903: PPUSH
81904: LD_VAR 0 8
81908: PPUSH
81909: CALL_OW 323
81913: PUSH
81914: LD_INT 1
81916: EQUAL
81917: IFFALSE 81963
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81919: LD_ADDR_EXP 55
81923: PUSH
81924: LD_EXP 55
81928: PPUSH
81929: LD_VAR 0 3
81933: PUSH
81934: LD_EXP 55
81938: PUSH
81939: LD_VAR 0 3
81943: ARRAY
81944: PUSH
81945: LD_INT 1
81947: PLUS
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: PPUSH
81953: LD_VAR 0 1
81957: PPUSH
81958: CALL 16152 0 3
81962: ST_TO_ADDR
// exit ;
81963: POP
81964: POP
81965: GO 82280
// end ; if btype in [ b_bunker , b_turret ] then
81967: LD_VAR 0 5
81971: PUSH
81972: LD_INT 32
81974: PUSH
81975: LD_INT 33
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: IN
81982: IFFALSE 82272
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81984: LD_ADDR_EXP 31
81988: PUSH
81989: LD_EXP 31
81993: PPUSH
81994: LD_VAR 0 3
81998: PUSH
81999: LD_EXP 31
82003: PUSH
82004: LD_VAR 0 3
82008: ARRAY
82009: PUSH
82010: LD_INT 1
82012: PLUS
82013: PUSH
82014: EMPTY
82015: LIST
82016: LIST
82017: PPUSH
82018: LD_VAR 0 1
82022: PPUSH
82023: CALL 16152 0 3
82027: ST_TO_ADDR
// if btype = b_bunker then
82028: LD_VAR 0 5
82032: PUSH
82033: LD_INT 32
82035: EQUAL
82036: IFFALSE 82272
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82038: LD_ADDR_EXP 32
82042: PUSH
82043: LD_EXP 32
82047: PPUSH
82048: LD_VAR 0 3
82052: PUSH
82053: LD_EXP 32
82057: PUSH
82058: LD_VAR 0 3
82062: ARRAY
82063: PUSH
82064: LD_INT 1
82066: PLUS
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PPUSH
82072: LD_VAR 0 1
82076: PPUSH
82077: CALL 16152 0 3
82081: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82082: LD_ADDR_VAR 0 6
82086: PUSH
82087: LD_EXP 23
82091: PUSH
82092: LD_VAR 0 3
82096: ARRAY
82097: PPUSH
82098: LD_INT 25
82100: PUSH
82101: LD_INT 1
82103: PUSH
82104: EMPTY
82105: LIST
82106: LIST
82107: PUSH
82108: LD_INT 3
82110: PUSH
82111: LD_INT 54
82113: PUSH
82114: EMPTY
82115: LIST
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: EMPTY
82122: LIST
82123: LIST
82124: PPUSH
82125: CALL_OW 72
82129: ST_TO_ADDR
// if tmp then
82130: LD_VAR 0 6
82134: IFFALSE 82140
// exit ;
82136: POP
82137: POP
82138: GO 82280
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82140: LD_ADDR_VAR 0 6
82144: PUSH
82145: LD_EXP 23
82149: PUSH
82150: LD_VAR 0 3
82154: ARRAY
82155: PPUSH
82156: LD_INT 2
82158: PUSH
82159: LD_INT 30
82161: PUSH
82162: LD_INT 4
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 30
82171: PUSH
82172: LD_INT 5
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: LIST
82183: PPUSH
82184: CALL_OW 72
82188: ST_TO_ADDR
// if not tmp then
82189: LD_VAR 0 6
82193: NOT
82194: IFFALSE 82200
// exit ;
82196: POP
82197: POP
82198: GO 82280
// for j in tmp do
82200: LD_ADDR_VAR 0 4
82204: PUSH
82205: LD_VAR 0 6
82209: PUSH
82210: FOR_IN
82211: IFFALSE 82270
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82213: LD_ADDR_VAR 0 7
82217: PUSH
82218: LD_VAR 0 4
82222: PPUSH
82223: CALL_OW 313
82227: PPUSH
82228: LD_INT 25
82230: PUSH
82231: LD_INT 1
82233: PUSH
82234: EMPTY
82235: LIST
82236: LIST
82237: PPUSH
82238: CALL_OW 72
82242: ST_TO_ADDR
// if units then
82243: LD_VAR 0 7
82247: IFFALSE 82268
// begin ComExitBuilding ( units [ 1 ] ) ;
82249: LD_VAR 0 7
82253: PUSH
82254: LD_INT 1
82256: ARRAY
82257: PPUSH
82258: CALL_OW 122
// exit ;
82262: POP
82263: POP
82264: POP
82265: POP
82266: GO 82280
// end ; end ;
82268: GO 82210
82270: POP
82271: POP
// end ; end ; exit ;
82272: POP
82273: POP
82274: GO 82280
// end ; end ;
82276: GO 81634
82278: POP
82279: POP
// end ;
82280: LD_VAR 0 2
82284: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82285: LD_INT 0
82287: PPUSH
82288: PPUSH
82289: PPUSH
82290: PPUSH
82291: PPUSH
82292: PPUSH
82293: PPUSH
// if not mc_bases or not skirmish then
82294: LD_EXP 23
82298: NOT
82299: PUSH
82300: LD_EXP 21
82304: NOT
82305: OR
82306: IFFALSE 82310
// exit ;
82308: GO 82575
// btype := GetBType ( building ) ;
82310: LD_ADDR_VAR 0 6
82314: PUSH
82315: LD_VAR 0 1
82319: PPUSH
82320: CALL_OW 266
82324: ST_TO_ADDR
// x := GetX ( building ) ;
82325: LD_ADDR_VAR 0 7
82329: PUSH
82330: LD_VAR 0 1
82334: PPUSH
82335: CALL_OW 250
82339: ST_TO_ADDR
// y := GetY ( building ) ;
82340: LD_ADDR_VAR 0 8
82344: PUSH
82345: LD_VAR 0 1
82349: PPUSH
82350: CALL_OW 251
82354: ST_TO_ADDR
// d := GetDir ( building ) ;
82355: LD_ADDR_VAR 0 9
82359: PUSH
82360: LD_VAR 0 1
82364: PPUSH
82365: CALL_OW 254
82369: ST_TO_ADDR
// for i = 1 to mc_bases do
82370: LD_ADDR_VAR 0 4
82374: PUSH
82375: DOUBLE
82376: LD_INT 1
82378: DEC
82379: ST_TO_ADDR
82380: LD_EXP 23
82384: PUSH
82385: FOR_TO
82386: IFFALSE 82573
// begin if not mc_build_list [ i ] then
82388: LD_EXP 28
82392: PUSH
82393: LD_VAR 0 4
82397: ARRAY
82398: NOT
82399: IFFALSE 82403
// continue ;
82401: GO 82385
// for j := 1 to mc_build_list [ i ] do
82403: LD_ADDR_VAR 0 5
82407: PUSH
82408: DOUBLE
82409: LD_INT 1
82411: DEC
82412: ST_TO_ADDR
82413: LD_EXP 28
82417: PUSH
82418: LD_VAR 0 4
82422: ARRAY
82423: PUSH
82424: FOR_TO
82425: IFFALSE 82569
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82427: LD_VAR 0 6
82431: PUSH
82432: LD_VAR 0 7
82436: PUSH
82437: LD_VAR 0 8
82441: PUSH
82442: LD_VAR 0 9
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: LIST
82451: LIST
82452: PPUSH
82453: LD_EXP 28
82457: PUSH
82458: LD_VAR 0 4
82462: ARRAY
82463: PUSH
82464: LD_VAR 0 5
82468: ARRAY
82469: PPUSH
82470: CALL 22332 0 2
82474: IFFALSE 82567
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82476: LD_ADDR_EXP 28
82480: PUSH
82481: LD_EXP 28
82485: PPUSH
82486: LD_VAR 0 4
82490: PPUSH
82491: LD_EXP 28
82495: PUSH
82496: LD_VAR 0 4
82500: ARRAY
82501: PPUSH
82502: LD_VAR 0 5
82506: PPUSH
82507: CALL_OW 3
82511: PPUSH
82512: CALL_OW 1
82516: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82517: LD_ADDR_EXP 30
82521: PUSH
82522: LD_EXP 30
82526: PPUSH
82527: LD_VAR 0 4
82531: PUSH
82532: LD_EXP 30
82536: PUSH
82537: LD_VAR 0 4
82541: ARRAY
82542: PUSH
82543: LD_INT 1
82545: PLUS
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PPUSH
82551: LD_VAR 0 1
82555: PPUSH
82556: CALL 16152 0 3
82560: ST_TO_ADDR
// exit ;
82561: POP
82562: POP
82563: POP
82564: POP
82565: GO 82575
// end ;
82567: GO 82424
82569: POP
82570: POP
// end ;
82571: GO 82385
82573: POP
82574: POP
// end ;
82575: LD_VAR 0 3
82579: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82580: LD_INT 0
82582: PPUSH
82583: PPUSH
82584: PPUSH
// if not mc_bases or not skirmish then
82585: LD_EXP 23
82589: NOT
82590: PUSH
82591: LD_EXP 21
82595: NOT
82596: OR
82597: IFFALSE 82601
// exit ;
82599: GO 82791
// for i = 1 to mc_bases do
82601: LD_ADDR_VAR 0 4
82605: PUSH
82606: DOUBLE
82607: LD_INT 1
82609: DEC
82610: ST_TO_ADDR
82611: LD_EXP 23
82615: PUSH
82616: FOR_TO
82617: IFFALSE 82704
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82619: LD_VAR 0 1
82623: PUSH
82624: LD_EXP 31
82628: PUSH
82629: LD_VAR 0 4
82633: ARRAY
82634: IN
82635: PUSH
82636: LD_VAR 0 1
82640: PUSH
82641: LD_EXP 32
82645: PUSH
82646: LD_VAR 0 4
82650: ARRAY
82651: IN
82652: NOT
82653: AND
82654: IFFALSE 82702
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82656: LD_ADDR_EXP 32
82660: PUSH
82661: LD_EXP 32
82665: PPUSH
82666: LD_VAR 0 4
82670: PUSH
82671: LD_EXP 32
82675: PUSH
82676: LD_VAR 0 4
82680: ARRAY
82681: PUSH
82682: LD_INT 1
82684: PLUS
82685: PUSH
82686: EMPTY
82687: LIST
82688: LIST
82689: PPUSH
82690: LD_VAR 0 1
82694: PPUSH
82695: CALL 16152 0 3
82699: ST_TO_ADDR
// break ;
82700: GO 82704
// end ; end ;
82702: GO 82616
82704: POP
82705: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82706: LD_VAR 0 1
82710: PPUSH
82711: CALL_OW 257
82715: PUSH
82716: LD_EXP 49
82720: IN
82721: PUSH
82722: LD_VAR 0 1
82726: PPUSH
82727: CALL_OW 266
82731: PUSH
82732: LD_INT 5
82734: EQUAL
82735: AND
82736: PUSH
82737: LD_VAR 0 2
82741: PPUSH
82742: CALL_OW 110
82746: PUSH
82747: LD_INT 18
82749: NONEQUAL
82750: AND
82751: IFFALSE 82791
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82753: LD_VAR 0 2
82757: PPUSH
82758: CALL_OW 257
82762: PUSH
82763: LD_INT 5
82765: PUSH
82766: LD_INT 8
82768: PUSH
82769: LD_INT 9
82771: PUSH
82772: EMPTY
82773: LIST
82774: LIST
82775: LIST
82776: IN
82777: IFFALSE 82791
// SetClass ( unit , 1 ) ;
82779: LD_VAR 0 2
82783: PPUSH
82784: LD_INT 1
82786: PPUSH
82787: CALL_OW 336
// end ;
82791: LD_VAR 0 3
82795: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82796: LD_INT 0
82798: PPUSH
82799: PPUSH
// if not mc_bases or not skirmish then
82800: LD_EXP 23
82804: NOT
82805: PUSH
82806: LD_EXP 21
82810: NOT
82811: OR
82812: IFFALSE 82816
// exit ;
82814: GO 82932
// if GetLives ( abandoned_vehicle ) > 250 then
82816: LD_VAR 0 2
82820: PPUSH
82821: CALL_OW 256
82825: PUSH
82826: LD_INT 250
82828: GREATER
82829: IFFALSE 82833
// exit ;
82831: GO 82932
// for i = 1 to mc_bases do
82833: LD_ADDR_VAR 0 6
82837: PUSH
82838: DOUBLE
82839: LD_INT 1
82841: DEC
82842: ST_TO_ADDR
82843: LD_EXP 23
82847: PUSH
82848: FOR_TO
82849: IFFALSE 82930
// begin if driver in mc_bases [ i ] then
82851: LD_VAR 0 1
82855: PUSH
82856: LD_EXP 23
82860: PUSH
82861: LD_VAR 0 6
82865: ARRAY
82866: IN
82867: IFFALSE 82928
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82869: LD_VAR 0 1
82873: PPUSH
82874: LD_EXP 23
82878: PUSH
82879: LD_VAR 0 6
82883: ARRAY
82884: PPUSH
82885: LD_INT 2
82887: PUSH
82888: LD_INT 30
82890: PUSH
82891: LD_INT 0
82893: PUSH
82894: EMPTY
82895: LIST
82896: LIST
82897: PUSH
82898: LD_INT 30
82900: PUSH
82901: LD_INT 1
82903: PUSH
82904: EMPTY
82905: LIST
82906: LIST
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: LIST
82912: PPUSH
82913: CALL_OW 72
82917: PUSH
82918: LD_INT 1
82920: ARRAY
82921: PPUSH
82922: CALL 49341 0 2
// break ;
82926: GO 82930
// end ; end ;
82928: GO 82848
82930: POP
82931: POP
// end ; end_of_file
82932: LD_VAR 0 5
82936: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
82937: LD_INT 0
82939: PPUSH
82940: PPUSH
82941: PPUSH
82942: PPUSH
82943: PPUSH
82944: PPUSH
82945: PPUSH
82946: PPUSH
82947: PPUSH
82948: PPUSH
82949: PPUSH
82950: PPUSH
82951: PPUSH
82952: PPUSH
82953: PPUSH
82954: PPUSH
82955: PPUSH
82956: PPUSH
82957: PPUSH
82958: PPUSH
82959: PPUSH
82960: PPUSH
82961: PPUSH
82962: PPUSH
82963: PPUSH
82964: PPUSH
82965: PPUSH
82966: PPUSH
82967: PPUSH
82968: PPUSH
82969: PPUSH
82970: PPUSH
82971: PPUSH
82972: PPUSH
// if not list then
82973: LD_VAR 0 1
82977: NOT
82978: IFFALSE 82982
// exit ;
82980: GO 87641
// base := list [ 1 ] ;
82982: LD_ADDR_VAR 0 3
82986: PUSH
82987: LD_VAR 0 1
82991: PUSH
82992: LD_INT 1
82994: ARRAY
82995: ST_TO_ADDR
// group := list [ 2 ] ;
82996: LD_ADDR_VAR 0 4
83000: PUSH
83001: LD_VAR 0 1
83005: PUSH
83006: LD_INT 2
83008: ARRAY
83009: ST_TO_ADDR
// path := list [ 3 ] ;
83010: LD_ADDR_VAR 0 5
83014: PUSH
83015: LD_VAR 0 1
83019: PUSH
83020: LD_INT 3
83022: ARRAY
83023: ST_TO_ADDR
// flags := list [ 4 ] ;
83024: LD_ADDR_VAR 0 6
83028: PUSH
83029: LD_VAR 0 1
83033: PUSH
83034: LD_INT 4
83036: ARRAY
83037: ST_TO_ADDR
// mined := [ ] ;
83038: LD_ADDR_VAR 0 27
83042: PUSH
83043: EMPTY
83044: ST_TO_ADDR
// bombed := [ ] ;
83045: LD_ADDR_VAR 0 28
83049: PUSH
83050: EMPTY
83051: ST_TO_ADDR
// healers := [ ] ;
83052: LD_ADDR_VAR 0 31
83056: PUSH
83057: EMPTY
83058: ST_TO_ADDR
// to_heal := [ ] ;
83059: LD_ADDR_VAR 0 30
83063: PUSH
83064: EMPTY
83065: ST_TO_ADDR
// repairs := [ ] ;
83066: LD_ADDR_VAR 0 33
83070: PUSH
83071: EMPTY
83072: ST_TO_ADDR
// to_repair := [ ] ;
83073: LD_ADDR_VAR 0 32
83077: PUSH
83078: EMPTY
83079: ST_TO_ADDR
// if not group or not path then
83080: LD_VAR 0 4
83084: NOT
83085: PUSH
83086: LD_VAR 0 5
83090: NOT
83091: OR
83092: IFFALSE 83096
// exit ;
83094: GO 87641
// side := GetSide ( group [ 1 ] ) ;
83096: LD_ADDR_VAR 0 35
83100: PUSH
83101: LD_VAR 0 4
83105: PUSH
83106: LD_INT 1
83108: ARRAY
83109: PPUSH
83110: CALL_OW 255
83114: ST_TO_ADDR
// if flags then
83115: LD_VAR 0 6
83119: IFFALSE 83263
// begin f_ignore_area := flags [ 1 ] ;
83121: LD_ADDR_VAR 0 17
83125: PUSH
83126: LD_VAR 0 6
83130: PUSH
83131: LD_INT 1
83133: ARRAY
83134: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83135: LD_ADDR_VAR 0 18
83139: PUSH
83140: LD_VAR 0 6
83144: PUSH
83145: LD_INT 2
83147: ARRAY
83148: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83149: LD_ADDR_VAR 0 19
83153: PUSH
83154: LD_VAR 0 6
83158: PUSH
83159: LD_INT 3
83161: ARRAY
83162: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83163: LD_ADDR_VAR 0 20
83167: PUSH
83168: LD_VAR 0 6
83172: PUSH
83173: LD_INT 4
83175: ARRAY
83176: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83177: LD_ADDR_VAR 0 21
83181: PUSH
83182: LD_VAR 0 6
83186: PUSH
83187: LD_INT 5
83189: ARRAY
83190: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83191: LD_ADDR_VAR 0 22
83195: PUSH
83196: LD_VAR 0 6
83200: PUSH
83201: LD_INT 6
83203: ARRAY
83204: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83205: LD_ADDR_VAR 0 23
83209: PUSH
83210: LD_VAR 0 6
83214: PUSH
83215: LD_INT 7
83217: ARRAY
83218: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83219: LD_ADDR_VAR 0 24
83223: PUSH
83224: LD_VAR 0 6
83228: PUSH
83229: LD_INT 8
83231: ARRAY
83232: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83233: LD_ADDR_VAR 0 25
83237: PUSH
83238: LD_VAR 0 6
83242: PUSH
83243: LD_INT 9
83245: ARRAY
83246: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83247: LD_ADDR_VAR 0 26
83251: PUSH
83252: LD_VAR 0 6
83256: PUSH
83257: LD_INT 10
83259: ARRAY
83260: ST_TO_ADDR
// end else
83261: GO 83343
// begin f_ignore_area := false ;
83263: LD_ADDR_VAR 0 17
83267: PUSH
83268: LD_INT 0
83270: ST_TO_ADDR
// f_capture := false ;
83271: LD_ADDR_VAR 0 18
83275: PUSH
83276: LD_INT 0
83278: ST_TO_ADDR
// f_ignore_civ := false ;
83279: LD_ADDR_VAR 0 19
83283: PUSH
83284: LD_INT 0
83286: ST_TO_ADDR
// f_murder := false ;
83287: LD_ADDR_VAR 0 20
83291: PUSH
83292: LD_INT 0
83294: ST_TO_ADDR
// f_mines := false ;
83295: LD_ADDR_VAR 0 21
83299: PUSH
83300: LD_INT 0
83302: ST_TO_ADDR
// f_repair := false ;
83303: LD_ADDR_VAR 0 22
83307: PUSH
83308: LD_INT 0
83310: ST_TO_ADDR
// f_heal := false ;
83311: LD_ADDR_VAR 0 23
83315: PUSH
83316: LD_INT 0
83318: ST_TO_ADDR
// f_spacetime := false ;
83319: LD_ADDR_VAR 0 24
83323: PUSH
83324: LD_INT 0
83326: ST_TO_ADDR
// f_attack_depot := false ;
83327: LD_ADDR_VAR 0 25
83331: PUSH
83332: LD_INT 0
83334: ST_TO_ADDR
// f_crawl := false ;
83335: LD_ADDR_VAR 0 26
83339: PUSH
83340: LD_INT 0
83342: ST_TO_ADDR
// end ; if f_heal then
83343: LD_VAR 0 23
83347: IFFALSE 83374
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83349: LD_ADDR_VAR 0 31
83353: PUSH
83354: LD_VAR 0 4
83358: PPUSH
83359: LD_INT 25
83361: PUSH
83362: LD_INT 4
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PPUSH
83369: CALL_OW 72
83373: ST_TO_ADDR
// if f_repair then
83374: LD_VAR 0 22
83378: IFFALSE 83405
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83380: LD_ADDR_VAR 0 33
83384: PUSH
83385: LD_VAR 0 4
83389: PPUSH
83390: LD_INT 25
83392: PUSH
83393: LD_INT 3
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PPUSH
83400: CALL_OW 72
83404: ST_TO_ADDR
// units_path := [ ] ;
83405: LD_ADDR_VAR 0 16
83409: PUSH
83410: EMPTY
83411: ST_TO_ADDR
// for i = 1 to group do
83412: LD_ADDR_VAR 0 7
83416: PUSH
83417: DOUBLE
83418: LD_INT 1
83420: DEC
83421: ST_TO_ADDR
83422: LD_VAR 0 4
83426: PUSH
83427: FOR_TO
83428: IFFALSE 83457
// units_path := Replace ( units_path , i , path ) ;
83430: LD_ADDR_VAR 0 16
83434: PUSH
83435: LD_VAR 0 16
83439: PPUSH
83440: LD_VAR 0 7
83444: PPUSH
83445: LD_VAR 0 5
83449: PPUSH
83450: CALL_OW 1
83454: ST_TO_ADDR
83455: GO 83427
83457: POP
83458: POP
// repeat for i = group downto 1 do
83459: LD_ADDR_VAR 0 7
83463: PUSH
83464: DOUBLE
83465: LD_VAR 0 4
83469: INC
83470: ST_TO_ADDR
83471: LD_INT 1
83473: PUSH
83474: FOR_DOWNTO
83475: IFFALSE 87597
// begin wait ( 5 ) ;
83477: LD_INT 5
83479: PPUSH
83480: CALL_OW 67
// tmp := [ ] ;
83484: LD_ADDR_VAR 0 14
83488: PUSH
83489: EMPTY
83490: ST_TO_ADDR
// attacking := false ;
83491: LD_ADDR_VAR 0 29
83495: PUSH
83496: LD_INT 0
83498: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83499: LD_VAR 0 4
83503: PUSH
83504: LD_VAR 0 7
83508: ARRAY
83509: PPUSH
83510: CALL_OW 301
83514: PUSH
83515: LD_VAR 0 4
83519: PUSH
83520: LD_VAR 0 7
83524: ARRAY
83525: NOT
83526: OR
83527: IFFALSE 83636
// begin if GetType ( group [ i ] ) = unit_human then
83529: LD_VAR 0 4
83533: PUSH
83534: LD_VAR 0 7
83538: ARRAY
83539: PPUSH
83540: CALL_OW 247
83544: PUSH
83545: LD_INT 1
83547: EQUAL
83548: IFFALSE 83594
// begin to_heal := to_heal diff group [ i ] ;
83550: LD_ADDR_VAR 0 30
83554: PUSH
83555: LD_VAR 0 30
83559: PUSH
83560: LD_VAR 0 4
83564: PUSH
83565: LD_VAR 0 7
83569: ARRAY
83570: DIFF
83571: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83572: LD_ADDR_VAR 0 31
83576: PUSH
83577: LD_VAR 0 31
83581: PUSH
83582: LD_VAR 0 4
83586: PUSH
83587: LD_VAR 0 7
83591: ARRAY
83592: DIFF
83593: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83594: LD_ADDR_VAR 0 4
83598: PUSH
83599: LD_VAR 0 4
83603: PPUSH
83604: LD_VAR 0 7
83608: PPUSH
83609: CALL_OW 3
83613: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83614: LD_ADDR_VAR 0 16
83618: PUSH
83619: LD_VAR 0 16
83623: PPUSH
83624: LD_VAR 0 7
83628: PPUSH
83629: CALL_OW 3
83633: ST_TO_ADDR
// continue ;
83634: GO 83474
// end ; if f_repair then
83636: LD_VAR 0 22
83640: IFFALSE 84129
// begin if GetType ( group [ i ] ) = unit_vehicle then
83642: LD_VAR 0 4
83646: PUSH
83647: LD_VAR 0 7
83651: ARRAY
83652: PPUSH
83653: CALL_OW 247
83657: PUSH
83658: LD_INT 2
83660: EQUAL
83661: IFFALSE 83851
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83663: LD_VAR 0 4
83667: PUSH
83668: LD_VAR 0 7
83672: ARRAY
83673: PPUSH
83674: CALL_OW 256
83678: PUSH
83679: LD_INT 700
83681: LESS
83682: PUSH
83683: LD_VAR 0 4
83687: PUSH
83688: LD_VAR 0 7
83692: ARRAY
83693: PUSH
83694: LD_VAR 0 32
83698: IN
83699: NOT
83700: AND
83701: IFFALSE 83725
// to_repair := to_repair union group [ i ] ;
83703: LD_ADDR_VAR 0 32
83707: PUSH
83708: LD_VAR 0 32
83712: PUSH
83713: LD_VAR 0 4
83717: PUSH
83718: LD_VAR 0 7
83722: ARRAY
83723: UNION
83724: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83725: LD_VAR 0 4
83729: PUSH
83730: LD_VAR 0 7
83734: ARRAY
83735: PPUSH
83736: CALL_OW 256
83740: PUSH
83741: LD_INT 1000
83743: EQUAL
83744: PUSH
83745: LD_VAR 0 4
83749: PUSH
83750: LD_VAR 0 7
83754: ARRAY
83755: PUSH
83756: LD_VAR 0 32
83760: IN
83761: AND
83762: IFFALSE 83786
// to_repair := to_repair diff group [ i ] ;
83764: LD_ADDR_VAR 0 32
83768: PUSH
83769: LD_VAR 0 32
83773: PUSH
83774: LD_VAR 0 4
83778: PUSH
83779: LD_VAR 0 7
83783: ARRAY
83784: DIFF
83785: ST_TO_ADDR
// if group [ i ] in to_repair then
83786: LD_VAR 0 4
83790: PUSH
83791: LD_VAR 0 7
83795: ARRAY
83796: PUSH
83797: LD_VAR 0 32
83801: IN
83802: IFFALSE 83849
// begin if not IsInArea ( group [ i ] , f_repair ) then
83804: LD_VAR 0 4
83808: PUSH
83809: LD_VAR 0 7
83813: ARRAY
83814: PPUSH
83815: LD_VAR 0 22
83819: PPUSH
83820: CALL_OW 308
83824: NOT
83825: IFFALSE 83847
// ComMoveToArea ( group [ i ] , f_repair ) ;
83827: LD_VAR 0 4
83831: PUSH
83832: LD_VAR 0 7
83836: ARRAY
83837: PPUSH
83838: LD_VAR 0 22
83842: PPUSH
83843: CALL_OW 113
// continue ;
83847: GO 83474
// end ; end else
83849: GO 84129
// if group [ i ] in repairs then
83851: LD_VAR 0 4
83855: PUSH
83856: LD_VAR 0 7
83860: ARRAY
83861: PUSH
83862: LD_VAR 0 33
83866: IN
83867: IFFALSE 84129
// begin if IsInUnit ( group [ i ] ) then
83869: LD_VAR 0 4
83873: PUSH
83874: LD_VAR 0 7
83878: ARRAY
83879: PPUSH
83880: CALL_OW 310
83884: IFFALSE 83952
// begin z := IsInUnit ( group [ i ] ) ;
83886: LD_ADDR_VAR 0 13
83890: PUSH
83891: LD_VAR 0 4
83895: PUSH
83896: LD_VAR 0 7
83900: ARRAY
83901: PPUSH
83902: CALL_OW 310
83906: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83907: LD_VAR 0 13
83911: PUSH
83912: LD_VAR 0 32
83916: IN
83917: PUSH
83918: LD_VAR 0 13
83922: PPUSH
83923: LD_VAR 0 22
83927: PPUSH
83928: CALL_OW 308
83932: AND
83933: IFFALSE 83950
// ComExitVehicle ( group [ i ] ) ;
83935: LD_VAR 0 4
83939: PUSH
83940: LD_VAR 0 7
83944: ARRAY
83945: PPUSH
83946: CALL_OW 121
// end else
83950: GO 84129
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
83952: LD_ADDR_VAR 0 13
83956: PUSH
83957: LD_VAR 0 4
83961: PPUSH
83962: LD_INT 95
83964: PUSH
83965: LD_VAR 0 22
83969: PUSH
83970: EMPTY
83971: LIST
83972: LIST
83973: PUSH
83974: LD_INT 58
83976: PUSH
83977: EMPTY
83978: LIST
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PPUSH
83984: CALL_OW 72
83988: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
83989: LD_VAR 0 4
83993: PUSH
83994: LD_VAR 0 7
83998: ARRAY
83999: PPUSH
84000: CALL_OW 314
84004: NOT
84005: IFFALSE 84127
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84007: LD_ADDR_VAR 0 10
84011: PUSH
84012: LD_VAR 0 13
84016: PPUSH
84017: LD_VAR 0 4
84021: PUSH
84022: LD_VAR 0 7
84026: ARRAY
84027: PPUSH
84028: CALL_OW 74
84032: ST_TO_ADDR
// if not x then
84033: LD_VAR 0 10
84037: NOT
84038: IFFALSE 84042
// continue ;
84040: GO 83474
// if GetLives ( x ) < 1000 then
84042: LD_VAR 0 10
84046: PPUSH
84047: CALL_OW 256
84051: PUSH
84052: LD_INT 1000
84054: LESS
84055: IFFALSE 84079
// ComRepairVehicle ( group [ i ] , x ) else
84057: LD_VAR 0 4
84061: PUSH
84062: LD_VAR 0 7
84066: ARRAY
84067: PPUSH
84068: LD_VAR 0 10
84072: PPUSH
84073: CALL_OW 129
84077: GO 84127
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84079: LD_VAR 0 23
84083: PUSH
84084: LD_VAR 0 4
84088: PUSH
84089: LD_VAR 0 7
84093: ARRAY
84094: PPUSH
84095: CALL_OW 256
84099: PUSH
84100: LD_INT 1000
84102: LESS
84103: AND
84104: NOT
84105: IFFALSE 84127
// ComEnterUnit ( group [ i ] , x ) ;
84107: LD_VAR 0 4
84111: PUSH
84112: LD_VAR 0 7
84116: ARRAY
84117: PPUSH
84118: LD_VAR 0 10
84122: PPUSH
84123: CALL_OW 120
// end ; continue ;
84127: GO 83474
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84129: LD_VAR 0 23
84133: PUSH
84134: LD_VAR 0 4
84138: PUSH
84139: LD_VAR 0 7
84143: ARRAY
84144: PPUSH
84145: CALL_OW 247
84149: PUSH
84150: LD_INT 1
84152: EQUAL
84153: AND
84154: IFFALSE 84632
// begin if group [ i ] in healers then
84156: LD_VAR 0 4
84160: PUSH
84161: LD_VAR 0 7
84165: ARRAY
84166: PUSH
84167: LD_VAR 0 31
84171: IN
84172: IFFALSE 84445
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84174: LD_VAR 0 4
84178: PUSH
84179: LD_VAR 0 7
84183: ARRAY
84184: PPUSH
84185: LD_VAR 0 23
84189: PPUSH
84190: CALL_OW 308
84194: NOT
84195: PUSH
84196: LD_VAR 0 4
84200: PUSH
84201: LD_VAR 0 7
84205: ARRAY
84206: PPUSH
84207: CALL_OW 314
84211: NOT
84212: AND
84213: IFFALSE 84237
// ComMoveToArea ( group [ i ] , f_heal ) else
84215: LD_VAR 0 4
84219: PUSH
84220: LD_VAR 0 7
84224: ARRAY
84225: PPUSH
84226: LD_VAR 0 23
84230: PPUSH
84231: CALL_OW 113
84235: GO 84443
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84237: LD_VAR 0 4
84241: PUSH
84242: LD_VAR 0 7
84246: ARRAY
84247: PPUSH
84248: CALL 45849 0 1
84252: PPUSH
84253: CALL_OW 256
84257: PUSH
84258: LD_INT 1000
84260: EQUAL
84261: IFFALSE 84280
// ComStop ( group [ i ] ) else
84263: LD_VAR 0 4
84267: PUSH
84268: LD_VAR 0 7
84272: ARRAY
84273: PPUSH
84274: CALL_OW 141
84278: GO 84443
// if not HasTask ( group [ i ] ) and to_heal then
84280: LD_VAR 0 4
84284: PUSH
84285: LD_VAR 0 7
84289: ARRAY
84290: PPUSH
84291: CALL_OW 314
84295: NOT
84296: PUSH
84297: LD_VAR 0 30
84301: AND
84302: IFFALSE 84443
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84304: LD_ADDR_VAR 0 13
84308: PUSH
84309: LD_VAR 0 30
84313: PPUSH
84314: LD_INT 3
84316: PUSH
84317: LD_INT 54
84319: PUSH
84320: EMPTY
84321: LIST
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PPUSH
84327: CALL_OW 72
84331: PPUSH
84332: LD_VAR 0 4
84336: PUSH
84337: LD_VAR 0 7
84341: ARRAY
84342: PPUSH
84343: CALL_OW 74
84347: ST_TO_ADDR
// if z then
84348: LD_VAR 0 13
84352: IFFALSE 84443
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84354: LD_INT 91
84356: PUSH
84357: LD_VAR 0 13
84361: PUSH
84362: LD_INT 10
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 81
84372: PUSH
84373: LD_VAR 0 13
84377: PPUSH
84378: CALL_OW 255
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: EMPTY
84388: LIST
84389: LIST
84390: PPUSH
84391: CALL_OW 69
84395: PUSH
84396: LD_INT 0
84398: EQUAL
84399: IFFALSE 84423
// ComHeal ( group [ i ] , z ) else
84401: LD_VAR 0 4
84405: PUSH
84406: LD_VAR 0 7
84410: ARRAY
84411: PPUSH
84412: LD_VAR 0 13
84416: PPUSH
84417: CALL_OW 128
84421: GO 84443
// ComMoveToArea ( group [ i ] , f_heal ) ;
84423: LD_VAR 0 4
84427: PUSH
84428: LD_VAR 0 7
84432: ARRAY
84433: PPUSH
84434: LD_VAR 0 23
84438: PPUSH
84439: CALL_OW 113
// end ; continue ;
84443: GO 83474
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84445: LD_VAR 0 4
84449: PUSH
84450: LD_VAR 0 7
84454: ARRAY
84455: PPUSH
84456: CALL_OW 256
84460: PUSH
84461: LD_INT 700
84463: LESS
84464: PUSH
84465: LD_VAR 0 4
84469: PUSH
84470: LD_VAR 0 7
84474: ARRAY
84475: PUSH
84476: LD_VAR 0 30
84480: IN
84481: NOT
84482: AND
84483: IFFALSE 84507
// to_heal := to_heal union group [ i ] ;
84485: LD_ADDR_VAR 0 30
84489: PUSH
84490: LD_VAR 0 30
84494: PUSH
84495: LD_VAR 0 4
84499: PUSH
84500: LD_VAR 0 7
84504: ARRAY
84505: UNION
84506: ST_TO_ADDR
// if group [ i ] in to_heal then
84507: LD_VAR 0 4
84511: PUSH
84512: LD_VAR 0 7
84516: ARRAY
84517: PUSH
84518: LD_VAR 0 30
84522: IN
84523: IFFALSE 84632
// begin if GetLives ( group [ i ] ) = 1000 then
84525: LD_VAR 0 4
84529: PUSH
84530: LD_VAR 0 7
84534: ARRAY
84535: PPUSH
84536: CALL_OW 256
84540: PUSH
84541: LD_INT 1000
84543: EQUAL
84544: IFFALSE 84570
// to_heal := to_heal diff group [ i ] else
84546: LD_ADDR_VAR 0 30
84550: PUSH
84551: LD_VAR 0 30
84555: PUSH
84556: LD_VAR 0 4
84560: PUSH
84561: LD_VAR 0 7
84565: ARRAY
84566: DIFF
84567: ST_TO_ADDR
84568: GO 84632
// begin if not IsInArea ( group [ i ] , to_heal ) then
84570: LD_VAR 0 4
84574: PUSH
84575: LD_VAR 0 7
84579: ARRAY
84580: PPUSH
84581: LD_VAR 0 30
84585: PPUSH
84586: CALL_OW 308
84590: NOT
84591: IFFALSE 84615
// ComMoveToArea ( group [ i ] , f_heal ) else
84593: LD_VAR 0 4
84597: PUSH
84598: LD_VAR 0 7
84602: ARRAY
84603: PPUSH
84604: LD_VAR 0 23
84608: PPUSH
84609: CALL_OW 113
84613: GO 84630
// ComHold ( group [ i ] ) ;
84615: LD_VAR 0 4
84619: PUSH
84620: LD_VAR 0 7
84624: ARRAY
84625: PPUSH
84626: CALL_OW 140
// continue ;
84630: GO 83474
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84632: LD_VAR 0 4
84636: PUSH
84637: LD_VAR 0 7
84641: ARRAY
84642: PPUSH
84643: LD_INT 10
84645: PPUSH
84646: CALL 43646 0 2
84650: NOT
84651: PUSH
84652: LD_VAR 0 16
84656: PUSH
84657: LD_VAR 0 7
84661: ARRAY
84662: PUSH
84663: EMPTY
84664: EQUAL
84665: NOT
84666: AND
84667: IFFALSE 84933
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84669: LD_VAR 0 4
84673: PUSH
84674: LD_VAR 0 7
84678: ARRAY
84679: PPUSH
84680: CALL_OW 262
84684: PUSH
84685: LD_INT 1
84687: PUSH
84688: LD_INT 2
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: IN
84695: IFFALSE 84736
// if GetFuel ( group [ i ] ) < 10 then
84697: LD_VAR 0 4
84701: PUSH
84702: LD_VAR 0 7
84706: ARRAY
84707: PPUSH
84708: CALL_OW 261
84712: PUSH
84713: LD_INT 10
84715: LESS
84716: IFFALSE 84736
// SetFuel ( group [ i ] , 12 ) ;
84718: LD_VAR 0 4
84722: PUSH
84723: LD_VAR 0 7
84727: ARRAY
84728: PPUSH
84729: LD_INT 12
84731: PPUSH
84732: CALL_OW 240
// if units_path [ i ] then
84736: LD_VAR 0 16
84740: PUSH
84741: LD_VAR 0 7
84745: ARRAY
84746: IFFALSE 84931
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84748: LD_VAR 0 4
84752: PUSH
84753: LD_VAR 0 7
84757: ARRAY
84758: PPUSH
84759: LD_VAR 0 16
84763: PUSH
84764: LD_VAR 0 7
84768: ARRAY
84769: PUSH
84770: LD_INT 1
84772: ARRAY
84773: PUSH
84774: LD_INT 1
84776: ARRAY
84777: PPUSH
84778: LD_VAR 0 16
84782: PUSH
84783: LD_VAR 0 7
84787: ARRAY
84788: PUSH
84789: LD_INT 1
84791: ARRAY
84792: PUSH
84793: LD_INT 2
84795: ARRAY
84796: PPUSH
84797: CALL_OW 297
84801: PUSH
84802: LD_INT 6
84804: GREATER
84805: IFFALSE 84880
// begin if not HasTask ( group [ i ] ) then
84807: LD_VAR 0 4
84811: PUSH
84812: LD_VAR 0 7
84816: ARRAY
84817: PPUSH
84818: CALL_OW 314
84822: NOT
84823: IFFALSE 84878
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84825: LD_VAR 0 4
84829: PUSH
84830: LD_VAR 0 7
84834: ARRAY
84835: PPUSH
84836: LD_VAR 0 16
84840: PUSH
84841: LD_VAR 0 7
84845: ARRAY
84846: PUSH
84847: LD_INT 1
84849: ARRAY
84850: PUSH
84851: LD_INT 1
84853: ARRAY
84854: PPUSH
84855: LD_VAR 0 16
84859: PUSH
84860: LD_VAR 0 7
84864: ARRAY
84865: PUSH
84866: LD_INT 1
84868: ARRAY
84869: PUSH
84870: LD_INT 2
84872: ARRAY
84873: PPUSH
84874: CALL_OW 114
// end else
84878: GO 84931
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84880: LD_ADDR_VAR 0 15
84884: PUSH
84885: LD_VAR 0 16
84889: PUSH
84890: LD_VAR 0 7
84894: ARRAY
84895: PPUSH
84896: LD_INT 1
84898: PPUSH
84899: CALL_OW 3
84903: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84904: LD_ADDR_VAR 0 16
84908: PUSH
84909: LD_VAR 0 16
84913: PPUSH
84914: LD_VAR 0 7
84918: PPUSH
84919: LD_VAR 0 15
84923: PPUSH
84924: CALL_OW 1
84928: ST_TO_ADDR
// continue ;
84929: GO 83474
// end ; end ; end else
84931: GO 87595
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
84933: LD_ADDR_VAR 0 14
84937: PUSH
84938: LD_INT 81
84940: PUSH
84941: LD_VAR 0 4
84945: PUSH
84946: LD_VAR 0 7
84950: ARRAY
84951: PPUSH
84952: CALL_OW 255
84956: PUSH
84957: EMPTY
84958: LIST
84959: LIST
84960: PPUSH
84961: CALL_OW 69
84965: ST_TO_ADDR
// if not tmp then
84966: LD_VAR 0 14
84970: NOT
84971: IFFALSE 84975
// continue ;
84973: GO 83474
// if f_ignore_area then
84975: LD_VAR 0 17
84979: IFFALSE 85067
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
84981: LD_ADDR_VAR 0 15
84985: PUSH
84986: LD_VAR 0 14
84990: PPUSH
84991: LD_INT 3
84993: PUSH
84994: LD_INT 92
84996: PUSH
84997: LD_VAR 0 17
85001: PUSH
85002: LD_INT 1
85004: ARRAY
85005: PUSH
85006: LD_VAR 0 17
85010: PUSH
85011: LD_INT 2
85013: ARRAY
85014: PUSH
85015: LD_VAR 0 17
85019: PUSH
85020: LD_INT 3
85022: ARRAY
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: LIST
85028: LIST
85029: PUSH
85030: EMPTY
85031: LIST
85032: LIST
85033: PPUSH
85034: CALL_OW 72
85038: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85039: LD_VAR 0 14
85043: PUSH
85044: LD_VAR 0 15
85048: DIFF
85049: IFFALSE 85067
// tmp := tmp diff tmp2 ;
85051: LD_ADDR_VAR 0 14
85055: PUSH
85056: LD_VAR 0 14
85060: PUSH
85061: LD_VAR 0 15
85065: DIFF
85066: ST_TO_ADDR
// end ; if not f_murder then
85067: LD_VAR 0 20
85071: NOT
85072: IFFALSE 85130
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85074: LD_ADDR_VAR 0 15
85078: PUSH
85079: LD_VAR 0 14
85083: PPUSH
85084: LD_INT 3
85086: PUSH
85087: LD_INT 50
85089: PUSH
85090: EMPTY
85091: LIST
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: PPUSH
85097: CALL_OW 72
85101: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85102: LD_VAR 0 14
85106: PUSH
85107: LD_VAR 0 15
85111: DIFF
85112: IFFALSE 85130
// tmp := tmp diff tmp2 ;
85114: LD_ADDR_VAR 0 14
85118: PUSH
85119: LD_VAR 0 14
85123: PUSH
85124: LD_VAR 0 15
85128: DIFF
85129: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85130: LD_ADDR_VAR 0 14
85134: PUSH
85135: LD_VAR 0 4
85139: PUSH
85140: LD_VAR 0 7
85144: ARRAY
85145: PPUSH
85146: LD_VAR 0 14
85150: PPUSH
85151: LD_INT 1
85153: PPUSH
85154: LD_INT 1
85156: PPUSH
85157: CALL 16587 0 4
85161: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85162: LD_VAR 0 4
85166: PUSH
85167: LD_VAR 0 7
85171: ARRAY
85172: PPUSH
85173: CALL_OW 257
85177: PUSH
85178: LD_INT 1
85180: EQUAL
85181: IFFALSE 85629
// begin if WantPlant ( group [ i ] ) then
85183: LD_VAR 0 4
85187: PUSH
85188: LD_VAR 0 7
85192: ARRAY
85193: PPUSH
85194: CALL 16088 0 1
85198: IFFALSE 85202
// continue ;
85200: GO 83474
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85202: LD_VAR 0 18
85206: PUSH
85207: LD_VAR 0 4
85211: PUSH
85212: LD_VAR 0 7
85216: ARRAY
85217: PPUSH
85218: CALL_OW 310
85222: NOT
85223: AND
85224: PUSH
85225: LD_VAR 0 14
85229: PUSH
85230: LD_INT 1
85232: ARRAY
85233: PUSH
85234: LD_VAR 0 14
85238: PPUSH
85239: LD_INT 21
85241: PUSH
85242: LD_INT 2
85244: PUSH
85245: EMPTY
85246: LIST
85247: LIST
85248: PUSH
85249: LD_INT 58
85251: PUSH
85252: EMPTY
85253: LIST
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PPUSH
85259: CALL_OW 72
85263: IN
85264: AND
85265: IFFALSE 85301
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85267: LD_VAR 0 4
85271: PUSH
85272: LD_VAR 0 7
85276: ARRAY
85277: PPUSH
85278: LD_VAR 0 14
85282: PUSH
85283: LD_INT 1
85285: ARRAY
85286: PPUSH
85287: CALL_OW 120
// attacking := true ;
85291: LD_ADDR_VAR 0 29
85295: PUSH
85296: LD_INT 1
85298: ST_TO_ADDR
// continue ;
85299: GO 83474
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85301: LD_VAR 0 26
85305: PUSH
85306: LD_VAR 0 4
85310: PUSH
85311: LD_VAR 0 7
85315: ARRAY
85316: PPUSH
85317: CALL_OW 257
85321: PUSH
85322: LD_INT 1
85324: EQUAL
85325: AND
85326: PUSH
85327: LD_VAR 0 4
85331: PUSH
85332: LD_VAR 0 7
85336: ARRAY
85337: PPUSH
85338: CALL_OW 256
85342: PUSH
85343: LD_INT 800
85345: LESS
85346: AND
85347: PUSH
85348: LD_VAR 0 4
85352: PUSH
85353: LD_VAR 0 7
85357: ARRAY
85358: PPUSH
85359: CALL_OW 318
85363: NOT
85364: AND
85365: IFFALSE 85382
// ComCrawl ( group [ i ] ) ;
85367: LD_VAR 0 4
85371: PUSH
85372: LD_VAR 0 7
85376: ARRAY
85377: PPUSH
85378: CALL_OW 137
// if f_mines then
85382: LD_VAR 0 21
85386: IFFALSE 85629
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85388: LD_VAR 0 14
85392: PUSH
85393: LD_INT 1
85395: ARRAY
85396: PPUSH
85397: CALL_OW 247
85401: PUSH
85402: LD_INT 3
85404: EQUAL
85405: PUSH
85406: LD_VAR 0 14
85410: PUSH
85411: LD_INT 1
85413: ARRAY
85414: PUSH
85415: LD_VAR 0 27
85419: IN
85420: NOT
85421: AND
85422: IFFALSE 85629
// begin x := GetX ( tmp [ 1 ] ) ;
85424: LD_ADDR_VAR 0 10
85428: PUSH
85429: LD_VAR 0 14
85433: PUSH
85434: LD_INT 1
85436: ARRAY
85437: PPUSH
85438: CALL_OW 250
85442: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85443: LD_ADDR_VAR 0 11
85447: PUSH
85448: LD_VAR 0 14
85452: PUSH
85453: LD_INT 1
85455: ARRAY
85456: PPUSH
85457: CALL_OW 251
85461: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85462: LD_ADDR_VAR 0 12
85466: PUSH
85467: LD_VAR 0 4
85471: PUSH
85472: LD_VAR 0 7
85476: ARRAY
85477: PPUSH
85478: CALL 43731 0 1
85482: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85483: LD_VAR 0 4
85487: PUSH
85488: LD_VAR 0 7
85492: ARRAY
85493: PPUSH
85494: LD_VAR 0 10
85498: PPUSH
85499: LD_VAR 0 11
85503: PPUSH
85504: LD_VAR 0 14
85508: PUSH
85509: LD_INT 1
85511: ARRAY
85512: PPUSH
85513: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85517: LD_VAR 0 4
85521: PUSH
85522: LD_VAR 0 7
85526: ARRAY
85527: PPUSH
85528: LD_VAR 0 10
85532: PPUSH
85533: LD_VAR 0 12
85537: PPUSH
85538: LD_INT 7
85540: PPUSH
85541: CALL_OW 272
85545: PPUSH
85546: LD_VAR 0 11
85550: PPUSH
85551: LD_VAR 0 12
85555: PPUSH
85556: LD_INT 7
85558: PPUSH
85559: CALL_OW 273
85563: PPUSH
85564: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85568: LD_VAR 0 4
85572: PUSH
85573: LD_VAR 0 7
85577: ARRAY
85578: PPUSH
85579: LD_INT 71
85581: PPUSH
85582: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85586: LD_ADDR_VAR 0 27
85590: PUSH
85591: LD_VAR 0 27
85595: PPUSH
85596: LD_VAR 0 27
85600: PUSH
85601: LD_INT 1
85603: PLUS
85604: PPUSH
85605: LD_VAR 0 14
85609: PUSH
85610: LD_INT 1
85612: ARRAY
85613: PPUSH
85614: CALL_OW 1
85618: ST_TO_ADDR
// attacking := true ;
85619: LD_ADDR_VAR 0 29
85623: PUSH
85624: LD_INT 1
85626: ST_TO_ADDR
// continue ;
85627: GO 83474
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85629: LD_VAR 0 4
85633: PUSH
85634: LD_VAR 0 7
85638: ARRAY
85639: PPUSH
85640: CALL_OW 257
85644: PUSH
85645: LD_INT 17
85647: EQUAL
85648: PUSH
85649: LD_VAR 0 4
85653: PUSH
85654: LD_VAR 0 7
85658: ARRAY
85659: PPUSH
85660: CALL_OW 110
85664: PUSH
85665: LD_INT 71
85667: EQUAL
85668: NOT
85669: AND
85670: IFFALSE 85816
// begin attacking := false ;
85672: LD_ADDR_VAR 0 29
85676: PUSH
85677: LD_INT 0
85679: ST_TO_ADDR
// k := 5 ;
85680: LD_ADDR_VAR 0 9
85684: PUSH
85685: LD_INT 5
85687: ST_TO_ADDR
// if tmp < k then
85688: LD_VAR 0 14
85692: PUSH
85693: LD_VAR 0 9
85697: LESS
85698: IFFALSE 85710
// k := tmp ;
85700: LD_ADDR_VAR 0 9
85704: PUSH
85705: LD_VAR 0 14
85709: ST_TO_ADDR
// for j = 1 to k do
85710: LD_ADDR_VAR 0 8
85714: PUSH
85715: DOUBLE
85716: LD_INT 1
85718: DEC
85719: ST_TO_ADDR
85720: LD_VAR 0 9
85724: PUSH
85725: FOR_TO
85726: IFFALSE 85814
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85728: LD_VAR 0 14
85732: PUSH
85733: LD_VAR 0 8
85737: ARRAY
85738: PUSH
85739: LD_VAR 0 14
85743: PPUSH
85744: LD_INT 58
85746: PUSH
85747: EMPTY
85748: LIST
85749: PPUSH
85750: CALL_OW 72
85754: IN
85755: NOT
85756: IFFALSE 85812
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85758: LD_VAR 0 4
85762: PUSH
85763: LD_VAR 0 7
85767: ARRAY
85768: PPUSH
85769: LD_VAR 0 14
85773: PUSH
85774: LD_VAR 0 8
85778: ARRAY
85779: PPUSH
85780: CALL_OW 115
// attacking := true ;
85784: LD_ADDR_VAR 0 29
85788: PUSH
85789: LD_INT 1
85791: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85792: LD_VAR 0 4
85796: PUSH
85797: LD_VAR 0 7
85801: ARRAY
85802: PPUSH
85803: LD_INT 71
85805: PPUSH
85806: CALL_OW 109
// continue ;
85810: GO 85725
// end ; end ;
85812: GO 85725
85814: POP
85815: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85816: LD_VAR 0 4
85820: PUSH
85821: LD_VAR 0 7
85825: ARRAY
85826: PPUSH
85827: CALL_OW 257
85831: PUSH
85832: LD_INT 8
85834: EQUAL
85835: PUSH
85836: LD_VAR 0 4
85840: PUSH
85841: LD_VAR 0 7
85845: ARRAY
85846: PPUSH
85847: CALL_OW 264
85851: PUSH
85852: LD_INT 28
85854: PUSH
85855: LD_INT 45
85857: PUSH
85858: LD_INT 7
85860: PUSH
85861: LD_INT 47
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: LIST
85868: LIST
85869: IN
85870: OR
85871: IFFALSE 86127
// begin attacking := false ;
85873: LD_ADDR_VAR 0 29
85877: PUSH
85878: LD_INT 0
85880: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85881: LD_VAR 0 14
85885: PUSH
85886: LD_INT 1
85888: ARRAY
85889: PPUSH
85890: CALL_OW 266
85894: PUSH
85895: LD_INT 32
85897: PUSH
85898: LD_INT 31
85900: PUSH
85901: LD_INT 33
85903: PUSH
85904: LD_INT 4
85906: PUSH
85907: LD_INT 5
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: IN
85917: IFFALSE 86103
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
85919: LD_ADDR_VAR 0 9
85923: PUSH
85924: LD_VAR 0 14
85928: PUSH
85929: LD_INT 1
85931: ARRAY
85932: PPUSH
85933: CALL_OW 266
85937: PPUSH
85938: LD_VAR 0 14
85942: PUSH
85943: LD_INT 1
85945: ARRAY
85946: PPUSH
85947: CALL_OW 250
85951: PPUSH
85952: LD_VAR 0 14
85956: PUSH
85957: LD_INT 1
85959: ARRAY
85960: PPUSH
85961: CALL_OW 251
85965: PPUSH
85966: LD_VAR 0 14
85970: PUSH
85971: LD_INT 1
85973: ARRAY
85974: PPUSH
85975: CALL_OW 254
85979: PPUSH
85980: LD_VAR 0 14
85984: PUSH
85985: LD_INT 1
85987: ARRAY
85988: PPUSH
85989: CALL_OW 248
85993: PPUSH
85994: LD_INT 0
85996: PPUSH
85997: CALL 25101 0 6
86001: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86002: LD_ADDR_VAR 0 8
86006: PUSH
86007: LD_VAR 0 4
86011: PUSH
86012: LD_VAR 0 7
86016: ARRAY
86017: PPUSH
86018: LD_VAR 0 9
86022: PPUSH
86023: CALL 43844 0 2
86027: ST_TO_ADDR
// if j then
86028: LD_VAR 0 8
86032: IFFALSE 86101
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86034: LD_VAR 0 8
86038: PUSH
86039: LD_INT 1
86041: ARRAY
86042: PPUSH
86043: LD_VAR 0 8
86047: PUSH
86048: LD_INT 2
86050: ARRAY
86051: PPUSH
86052: CALL_OW 488
86056: IFFALSE 86101
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86058: LD_VAR 0 4
86062: PUSH
86063: LD_VAR 0 7
86067: ARRAY
86068: PPUSH
86069: LD_VAR 0 8
86073: PUSH
86074: LD_INT 1
86076: ARRAY
86077: PPUSH
86078: LD_VAR 0 8
86082: PUSH
86083: LD_INT 2
86085: ARRAY
86086: PPUSH
86087: CALL_OW 116
// attacking := true ;
86091: LD_ADDR_VAR 0 29
86095: PUSH
86096: LD_INT 1
86098: ST_TO_ADDR
// continue ;
86099: GO 83474
// end ; end else
86101: GO 86127
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86103: LD_VAR 0 4
86107: PUSH
86108: LD_VAR 0 7
86112: ARRAY
86113: PPUSH
86114: LD_VAR 0 14
86118: PUSH
86119: LD_INT 1
86121: ARRAY
86122: PPUSH
86123: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86127: LD_VAR 0 4
86131: PUSH
86132: LD_VAR 0 7
86136: ARRAY
86137: PPUSH
86138: CALL_OW 265
86142: PUSH
86143: LD_INT 11
86145: EQUAL
86146: IFFALSE 86424
// begin k := 10 ;
86148: LD_ADDR_VAR 0 9
86152: PUSH
86153: LD_INT 10
86155: ST_TO_ADDR
// x := 0 ;
86156: LD_ADDR_VAR 0 10
86160: PUSH
86161: LD_INT 0
86163: ST_TO_ADDR
// if tmp < k then
86164: LD_VAR 0 14
86168: PUSH
86169: LD_VAR 0 9
86173: LESS
86174: IFFALSE 86186
// k := tmp ;
86176: LD_ADDR_VAR 0 9
86180: PUSH
86181: LD_VAR 0 14
86185: ST_TO_ADDR
// for j = k downto 1 do
86186: LD_ADDR_VAR 0 8
86190: PUSH
86191: DOUBLE
86192: LD_VAR 0 9
86196: INC
86197: ST_TO_ADDR
86198: LD_INT 1
86200: PUSH
86201: FOR_DOWNTO
86202: IFFALSE 86277
// begin if GetType ( tmp [ j ] ) = unit_human then
86204: LD_VAR 0 14
86208: PUSH
86209: LD_VAR 0 8
86213: ARRAY
86214: PPUSH
86215: CALL_OW 247
86219: PUSH
86220: LD_INT 1
86222: EQUAL
86223: IFFALSE 86275
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86225: LD_VAR 0 4
86229: PUSH
86230: LD_VAR 0 7
86234: ARRAY
86235: PPUSH
86236: LD_VAR 0 14
86240: PUSH
86241: LD_VAR 0 8
86245: ARRAY
86246: PPUSH
86247: CALL 44098 0 2
// x := tmp [ j ] ;
86251: LD_ADDR_VAR 0 10
86255: PUSH
86256: LD_VAR 0 14
86260: PUSH
86261: LD_VAR 0 8
86265: ARRAY
86266: ST_TO_ADDR
// attacking := true ;
86267: LD_ADDR_VAR 0 29
86271: PUSH
86272: LD_INT 1
86274: ST_TO_ADDR
// end ; end ;
86275: GO 86201
86277: POP
86278: POP
// if not x then
86279: LD_VAR 0 10
86283: NOT
86284: IFFALSE 86424
// begin attacking := true ;
86286: LD_ADDR_VAR 0 29
86290: PUSH
86291: LD_INT 1
86293: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86294: LD_VAR 0 4
86298: PUSH
86299: LD_VAR 0 7
86303: ARRAY
86304: PPUSH
86305: CALL_OW 250
86309: PPUSH
86310: LD_VAR 0 4
86314: PUSH
86315: LD_VAR 0 7
86319: ARRAY
86320: PPUSH
86321: CALL_OW 251
86325: PPUSH
86326: CALL_OW 546
86330: PUSH
86331: LD_INT 2
86333: ARRAY
86334: PUSH
86335: LD_VAR 0 14
86339: PUSH
86340: LD_INT 1
86342: ARRAY
86343: PPUSH
86344: CALL_OW 250
86348: PPUSH
86349: LD_VAR 0 14
86353: PUSH
86354: LD_INT 1
86356: ARRAY
86357: PPUSH
86358: CALL_OW 251
86362: PPUSH
86363: CALL_OW 546
86367: PUSH
86368: LD_INT 2
86370: ARRAY
86371: EQUAL
86372: IFFALSE 86400
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86374: LD_VAR 0 4
86378: PUSH
86379: LD_VAR 0 7
86383: ARRAY
86384: PPUSH
86385: LD_VAR 0 14
86389: PUSH
86390: LD_INT 1
86392: ARRAY
86393: PPUSH
86394: CALL 44098 0 2
86398: GO 86424
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86400: LD_VAR 0 4
86404: PUSH
86405: LD_VAR 0 7
86409: ARRAY
86410: PPUSH
86411: LD_VAR 0 14
86415: PUSH
86416: LD_INT 1
86418: ARRAY
86419: PPUSH
86420: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86424: LD_VAR 0 4
86428: PUSH
86429: LD_VAR 0 7
86433: ARRAY
86434: PPUSH
86435: CALL_OW 264
86439: PUSH
86440: LD_INT 29
86442: EQUAL
86443: IFFALSE 86809
// begin if WantsToAttack ( group [ i ] ) in bombed then
86445: LD_VAR 0 4
86449: PUSH
86450: LD_VAR 0 7
86454: ARRAY
86455: PPUSH
86456: CALL_OW 319
86460: PUSH
86461: LD_VAR 0 28
86465: IN
86466: IFFALSE 86470
// continue ;
86468: GO 83474
// k := 8 ;
86470: LD_ADDR_VAR 0 9
86474: PUSH
86475: LD_INT 8
86477: ST_TO_ADDR
// x := 0 ;
86478: LD_ADDR_VAR 0 10
86482: PUSH
86483: LD_INT 0
86485: ST_TO_ADDR
// if tmp < k then
86486: LD_VAR 0 14
86490: PUSH
86491: LD_VAR 0 9
86495: LESS
86496: IFFALSE 86508
// k := tmp ;
86498: LD_ADDR_VAR 0 9
86502: PUSH
86503: LD_VAR 0 14
86507: ST_TO_ADDR
// for j = 1 to k do
86508: LD_ADDR_VAR 0 8
86512: PUSH
86513: DOUBLE
86514: LD_INT 1
86516: DEC
86517: ST_TO_ADDR
86518: LD_VAR 0 9
86522: PUSH
86523: FOR_TO
86524: IFFALSE 86656
// begin if GetType ( tmp [ j ] ) = unit_building then
86526: LD_VAR 0 14
86530: PUSH
86531: LD_VAR 0 8
86535: ARRAY
86536: PPUSH
86537: CALL_OW 247
86541: PUSH
86542: LD_INT 3
86544: EQUAL
86545: IFFALSE 86654
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86547: LD_VAR 0 14
86551: PUSH
86552: LD_VAR 0 8
86556: ARRAY
86557: PUSH
86558: LD_VAR 0 28
86562: IN
86563: NOT
86564: PUSH
86565: LD_VAR 0 14
86569: PUSH
86570: LD_VAR 0 8
86574: ARRAY
86575: PPUSH
86576: CALL_OW 313
86580: AND
86581: IFFALSE 86654
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86583: LD_VAR 0 4
86587: PUSH
86588: LD_VAR 0 7
86592: ARRAY
86593: PPUSH
86594: LD_VAR 0 14
86598: PUSH
86599: LD_VAR 0 8
86603: ARRAY
86604: PPUSH
86605: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86609: LD_ADDR_VAR 0 28
86613: PUSH
86614: LD_VAR 0 28
86618: PPUSH
86619: LD_VAR 0 28
86623: PUSH
86624: LD_INT 1
86626: PLUS
86627: PPUSH
86628: LD_VAR 0 14
86632: PUSH
86633: LD_VAR 0 8
86637: ARRAY
86638: PPUSH
86639: CALL_OW 1
86643: ST_TO_ADDR
// attacking := true ;
86644: LD_ADDR_VAR 0 29
86648: PUSH
86649: LD_INT 1
86651: ST_TO_ADDR
// break ;
86652: GO 86656
// end ; end ;
86654: GO 86523
86656: POP
86657: POP
// if not attacking and f_attack_depot then
86658: LD_VAR 0 29
86662: NOT
86663: PUSH
86664: LD_VAR 0 25
86668: AND
86669: IFFALSE 86764
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86671: LD_ADDR_VAR 0 13
86675: PUSH
86676: LD_VAR 0 14
86680: PPUSH
86681: LD_INT 2
86683: PUSH
86684: LD_INT 30
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: EMPTY
86691: LIST
86692: LIST
86693: PUSH
86694: LD_INT 30
86696: PUSH
86697: LD_INT 1
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: LIST
86708: PPUSH
86709: CALL_OW 72
86713: ST_TO_ADDR
// if z then
86714: LD_VAR 0 13
86718: IFFALSE 86764
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86720: LD_VAR 0 4
86724: PUSH
86725: LD_VAR 0 7
86729: ARRAY
86730: PPUSH
86731: LD_VAR 0 13
86735: PPUSH
86736: LD_VAR 0 4
86740: PUSH
86741: LD_VAR 0 7
86745: ARRAY
86746: PPUSH
86747: CALL_OW 74
86751: PPUSH
86752: CALL_OW 115
// attacking := true ;
86756: LD_ADDR_VAR 0 29
86760: PUSH
86761: LD_INT 1
86763: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86764: LD_VAR 0 4
86768: PUSH
86769: LD_VAR 0 7
86773: ARRAY
86774: PPUSH
86775: CALL_OW 256
86779: PUSH
86780: LD_INT 500
86782: LESS
86783: IFFALSE 86809
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86785: LD_VAR 0 4
86789: PUSH
86790: LD_VAR 0 7
86794: ARRAY
86795: PPUSH
86796: LD_VAR 0 14
86800: PUSH
86801: LD_INT 1
86803: ARRAY
86804: PPUSH
86805: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86809: LD_VAR 0 4
86813: PUSH
86814: LD_VAR 0 7
86818: ARRAY
86819: PPUSH
86820: CALL_OW 264
86824: PUSH
86825: LD_INT 49
86827: EQUAL
86828: IFFALSE 86949
// begin if not HasTask ( group [ i ] ) then
86830: LD_VAR 0 4
86834: PUSH
86835: LD_VAR 0 7
86839: ARRAY
86840: PPUSH
86841: CALL_OW 314
86845: NOT
86846: IFFALSE 86949
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86848: LD_ADDR_VAR 0 9
86852: PUSH
86853: LD_INT 81
86855: PUSH
86856: LD_VAR 0 4
86860: PUSH
86861: LD_VAR 0 7
86865: ARRAY
86866: PPUSH
86867: CALL_OW 255
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: PPUSH
86876: CALL_OW 69
86880: PPUSH
86881: LD_VAR 0 4
86885: PUSH
86886: LD_VAR 0 7
86890: ARRAY
86891: PPUSH
86892: CALL_OW 74
86896: ST_TO_ADDR
// if k then
86897: LD_VAR 0 9
86901: IFFALSE 86949
// if GetDistUnits ( group [ i ] , k ) > 10 then
86903: LD_VAR 0 4
86907: PUSH
86908: LD_VAR 0 7
86912: ARRAY
86913: PPUSH
86914: LD_VAR 0 9
86918: PPUSH
86919: CALL_OW 296
86923: PUSH
86924: LD_INT 10
86926: GREATER
86927: IFFALSE 86949
// ComMoveUnit ( group [ i ] , k ) ;
86929: LD_VAR 0 4
86933: PUSH
86934: LD_VAR 0 7
86938: ARRAY
86939: PPUSH
86940: LD_VAR 0 9
86944: PPUSH
86945: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
86949: LD_VAR 0 4
86953: PUSH
86954: LD_VAR 0 7
86958: ARRAY
86959: PPUSH
86960: CALL_OW 256
86964: PUSH
86965: LD_INT 250
86967: LESS
86968: PUSH
86969: LD_VAR 0 4
86973: PUSH
86974: LD_VAR 0 7
86978: ARRAY
86979: PUSH
86980: LD_INT 21
86982: PUSH
86983: LD_INT 2
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 23
86992: PUSH
86993: LD_INT 2
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: PUSH
87000: EMPTY
87001: LIST
87002: LIST
87003: PPUSH
87004: CALL_OW 69
87008: IN
87009: AND
87010: IFFALSE 87135
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87012: LD_ADDR_VAR 0 9
87016: PUSH
87017: LD_OWVAR 3
87021: PUSH
87022: LD_VAR 0 4
87026: PUSH
87027: LD_VAR 0 7
87031: ARRAY
87032: DIFF
87033: PPUSH
87034: LD_VAR 0 4
87038: PUSH
87039: LD_VAR 0 7
87043: ARRAY
87044: PPUSH
87045: CALL_OW 74
87049: ST_TO_ADDR
// if not k then
87050: LD_VAR 0 9
87054: NOT
87055: IFFALSE 87059
// continue ;
87057: GO 83474
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87059: LD_VAR 0 9
87063: PUSH
87064: LD_INT 81
87066: PUSH
87067: LD_VAR 0 4
87071: PUSH
87072: LD_VAR 0 7
87076: ARRAY
87077: PPUSH
87078: CALL_OW 255
87082: PUSH
87083: EMPTY
87084: LIST
87085: LIST
87086: PPUSH
87087: CALL_OW 69
87091: IN
87092: PUSH
87093: LD_VAR 0 9
87097: PPUSH
87098: LD_VAR 0 4
87102: PUSH
87103: LD_VAR 0 7
87107: ARRAY
87108: PPUSH
87109: CALL_OW 296
87113: PUSH
87114: LD_INT 5
87116: LESS
87117: AND
87118: IFFALSE 87135
// ComAutodestruct ( group [ i ] ) ;
87120: LD_VAR 0 4
87124: PUSH
87125: LD_VAR 0 7
87129: ARRAY
87130: PPUSH
87131: CALL 43996 0 1
// end ; if f_attack_depot then
87135: LD_VAR 0 25
87139: IFFALSE 87251
// begin k := 6 ;
87141: LD_ADDR_VAR 0 9
87145: PUSH
87146: LD_INT 6
87148: ST_TO_ADDR
// if tmp < k then
87149: LD_VAR 0 14
87153: PUSH
87154: LD_VAR 0 9
87158: LESS
87159: IFFALSE 87171
// k := tmp ;
87161: LD_ADDR_VAR 0 9
87165: PUSH
87166: LD_VAR 0 14
87170: ST_TO_ADDR
// for j = 1 to k do
87171: LD_ADDR_VAR 0 8
87175: PUSH
87176: DOUBLE
87177: LD_INT 1
87179: DEC
87180: ST_TO_ADDR
87181: LD_VAR 0 9
87185: PUSH
87186: FOR_TO
87187: IFFALSE 87249
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87189: LD_VAR 0 8
87193: PPUSH
87194: CALL_OW 266
87198: PUSH
87199: LD_INT 0
87201: PUSH
87202: LD_INT 1
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: IN
87209: IFFALSE 87247
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87211: LD_VAR 0 4
87215: PUSH
87216: LD_VAR 0 7
87220: ARRAY
87221: PPUSH
87222: LD_VAR 0 14
87226: PUSH
87227: LD_VAR 0 8
87231: ARRAY
87232: PPUSH
87233: CALL_OW 115
// attacking := true ;
87237: LD_ADDR_VAR 0 29
87241: PUSH
87242: LD_INT 1
87244: ST_TO_ADDR
// break ;
87245: GO 87249
// end ;
87247: GO 87186
87249: POP
87250: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87251: LD_VAR 0 4
87255: PUSH
87256: LD_VAR 0 7
87260: ARRAY
87261: PPUSH
87262: CALL_OW 302
87266: PUSH
87267: LD_VAR 0 29
87271: NOT
87272: AND
87273: IFFALSE 87595
// begin if GetTag ( group [ i ] ) = 71 then
87275: LD_VAR 0 4
87279: PUSH
87280: LD_VAR 0 7
87284: ARRAY
87285: PPUSH
87286: CALL_OW 110
87290: PUSH
87291: LD_INT 71
87293: EQUAL
87294: IFFALSE 87335
// begin if HasTask ( group [ i ] ) then
87296: LD_VAR 0 4
87300: PUSH
87301: LD_VAR 0 7
87305: ARRAY
87306: PPUSH
87307: CALL_OW 314
87311: IFFALSE 87317
// continue else
87313: GO 83474
87315: GO 87335
// SetTag ( group [ i ] , 0 ) ;
87317: LD_VAR 0 4
87321: PUSH
87322: LD_VAR 0 7
87326: ARRAY
87327: PPUSH
87328: LD_INT 0
87330: PPUSH
87331: CALL_OW 109
// end ; k := 8 ;
87335: LD_ADDR_VAR 0 9
87339: PUSH
87340: LD_INT 8
87342: ST_TO_ADDR
// x := 0 ;
87343: LD_ADDR_VAR 0 10
87347: PUSH
87348: LD_INT 0
87350: ST_TO_ADDR
// if tmp < k then
87351: LD_VAR 0 14
87355: PUSH
87356: LD_VAR 0 9
87360: LESS
87361: IFFALSE 87373
// k := tmp ;
87363: LD_ADDR_VAR 0 9
87367: PUSH
87368: LD_VAR 0 14
87372: ST_TO_ADDR
// for j = 1 to k do
87373: LD_ADDR_VAR 0 8
87377: PUSH
87378: DOUBLE
87379: LD_INT 1
87381: DEC
87382: ST_TO_ADDR
87383: LD_VAR 0 9
87387: PUSH
87388: FOR_TO
87389: IFFALSE 87487
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87391: LD_VAR 0 14
87395: PUSH
87396: LD_VAR 0 8
87400: ARRAY
87401: PPUSH
87402: CALL_OW 247
87406: PUSH
87407: LD_INT 1
87409: EQUAL
87410: PUSH
87411: LD_VAR 0 14
87415: PUSH
87416: LD_VAR 0 8
87420: ARRAY
87421: PPUSH
87422: CALL_OW 256
87426: PUSH
87427: LD_INT 250
87429: LESS
87430: PUSH
87431: LD_VAR 0 20
87435: AND
87436: PUSH
87437: LD_VAR 0 20
87441: NOT
87442: PUSH
87443: LD_VAR 0 14
87447: PUSH
87448: LD_VAR 0 8
87452: ARRAY
87453: PPUSH
87454: CALL_OW 256
87458: PUSH
87459: LD_INT 250
87461: GREATEREQUAL
87462: AND
87463: OR
87464: AND
87465: IFFALSE 87485
// begin x := tmp [ j ] ;
87467: LD_ADDR_VAR 0 10
87471: PUSH
87472: LD_VAR 0 14
87476: PUSH
87477: LD_VAR 0 8
87481: ARRAY
87482: ST_TO_ADDR
// break ;
87483: GO 87487
// end ;
87485: GO 87388
87487: POP
87488: POP
// if x then
87489: LD_VAR 0 10
87493: IFFALSE 87517
// ComAttackUnit ( group [ i ] , x ) else
87495: LD_VAR 0 4
87499: PUSH
87500: LD_VAR 0 7
87504: ARRAY
87505: PPUSH
87506: LD_VAR 0 10
87510: PPUSH
87511: CALL_OW 115
87515: GO 87541
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87517: LD_VAR 0 4
87521: PUSH
87522: LD_VAR 0 7
87526: ARRAY
87527: PPUSH
87528: LD_VAR 0 14
87532: PUSH
87533: LD_INT 1
87535: ARRAY
87536: PPUSH
87537: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87541: LD_VAR 0 4
87545: PUSH
87546: LD_VAR 0 7
87550: ARRAY
87551: PPUSH
87552: CALL_OW 314
87556: NOT
87557: IFFALSE 87595
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87559: LD_VAR 0 4
87563: PUSH
87564: LD_VAR 0 7
87568: ARRAY
87569: PPUSH
87570: LD_VAR 0 14
87574: PPUSH
87575: LD_VAR 0 4
87579: PUSH
87580: LD_VAR 0 7
87584: ARRAY
87585: PPUSH
87586: CALL_OW 74
87590: PPUSH
87591: CALL_OW 115
// end ; end ; end ;
87595: GO 83474
87597: POP
87598: POP
// wait ( 0 0$2 ) ;
87599: LD_INT 70
87601: PPUSH
87602: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87606: LD_VAR 0 4
87610: NOT
87611: PUSH
87612: LD_VAR 0 4
87616: PUSH
87617: EMPTY
87618: EQUAL
87619: OR
87620: PUSH
87621: LD_INT 81
87623: PUSH
87624: LD_VAR 0 35
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PPUSH
87633: CALL_OW 69
87637: NOT
87638: OR
87639: IFFALSE 83459
// end ;
87641: LD_VAR 0 2
87645: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
87646: LD_INT 0
87648: PPUSH
87649: PPUSH
87650: PPUSH
87651: PPUSH
87652: PPUSH
87653: PPUSH
// if not base or not mc_bases [ base ] or not solds then
87654: LD_VAR 0 1
87658: NOT
87659: PUSH
87660: LD_EXP 23
87664: PUSH
87665: LD_VAR 0 1
87669: ARRAY
87670: NOT
87671: OR
87672: PUSH
87673: LD_VAR 0 2
87677: NOT
87678: OR
87679: IFFALSE 87683
// exit ;
87681: GO 88237
// side := mc_sides [ base ] ;
87683: LD_ADDR_VAR 0 6
87687: PUSH
87688: LD_EXP 49
87692: PUSH
87693: LD_VAR 0 1
87697: ARRAY
87698: ST_TO_ADDR
// if not side then
87699: LD_VAR 0 6
87703: NOT
87704: IFFALSE 87708
// exit ;
87706: GO 88237
// for i in solds do
87708: LD_ADDR_VAR 0 7
87712: PUSH
87713: LD_VAR 0 2
87717: PUSH
87718: FOR_IN
87719: IFFALSE 87780
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
87721: LD_VAR 0 7
87725: PPUSH
87726: CALL_OW 310
87730: PPUSH
87731: CALL_OW 266
87735: PUSH
87736: LD_INT 32
87738: PUSH
87739: LD_INT 31
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: IN
87746: IFFALSE 87766
// solds := solds diff i else
87748: LD_ADDR_VAR 0 2
87752: PUSH
87753: LD_VAR 0 2
87757: PUSH
87758: LD_VAR 0 7
87762: DIFF
87763: ST_TO_ADDR
87764: GO 87778
// SetTag ( i , 18 ) ;
87766: LD_VAR 0 7
87770: PPUSH
87771: LD_INT 18
87773: PPUSH
87774: CALL_OW 109
87778: GO 87718
87780: POP
87781: POP
// if not solds then
87782: LD_VAR 0 2
87786: NOT
87787: IFFALSE 87791
// exit ;
87789: GO 88237
// repeat wait ( 0 0$2 ) ;
87791: LD_INT 70
87793: PPUSH
87794: CALL_OW 67
// enemy := mc_scan [ base ] ;
87798: LD_ADDR_VAR 0 4
87802: PUSH
87803: LD_EXP 46
87807: PUSH
87808: LD_VAR 0 1
87812: ARRAY
87813: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87814: LD_EXP 23
87818: PUSH
87819: LD_VAR 0 1
87823: ARRAY
87824: NOT
87825: PUSH
87826: LD_EXP 23
87830: PUSH
87831: LD_VAR 0 1
87835: ARRAY
87836: PUSH
87837: EMPTY
87838: EQUAL
87839: OR
87840: IFFALSE 87877
// begin for i in solds do
87842: LD_ADDR_VAR 0 7
87846: PUSH
87847: LD_VAR 0 2
87851: PUSH
87852: FOR_IN
87853: IFFALSE 87866
// ComStop ( i ) ;
87855: LD_VAR 0 7
87859: PPUSH
87860: CALL_OW 141
87864: GO 87852
87866: POP
87867: POP
// solds := [ ] ;
87868: LD_ADDR_VAR 0 2
87872: PUSH
87873: EMPTY
87874: ST_TO_ADDR
// exit ;
87875: GO 88237
// end ; for i in solds do
87877: LD_ADDR_VAR 0 7
87881: PUSH
87882: LD_VAR 0 2
87886: PUSH
87887: FOR_IN
87888: IFFALSE 88209
// begin if IsInUnit ( i ) then
87890: LD_VAR 0 7
87894: PPUSH
87895: CALL_OW 310
87899: IFFALSE 87910
// ComExitBuilding ( i ) ;
87901: LD_VAR 0 7
87905: PPUSH
87906: CALL_OW 122
// if GetLives ( i ) > 500 then
87910: LD_VAR 0 7
87914: PPUSH
87915: CALL_OW 256
87919: PUSH
87920: LD_INT 500
87922: GREATER
87923: IFFALSE 87976
// begin e := NearestUnitToUnit ( enemy , i ) ;
87925: LD_ADDR_VAR 0 5
87929: PUSH
87930: LD_VAR 0 4
87934: PPUSH
87935: LD_VAR 0 7
87939: PPUSH
87940: CALL_OW 74
87944: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
87945: LD_VAR 0 7
87949: PPUSH
87950: LD_VAR 0 5
87954: PPUSH
87955: CALL_OW 250
87959: PPUSH
87960: LD_VAR 0 5
87964: PPUSH
87965: CALL_OW 251
87969: PPUSH
87970: CALL_OW 114
// end else
87974: GO 88207
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
87976: LD_VAR 0 7
87980: PPUSH
87981: LD_EXP 23
87985: PUSH
87986: LD_VAR 0 1
87990: ARRAY
87991: PPUSH
87992: LD_INT 2
87994: PUSH
87995: LD_INT 30
87997: PUSH
87998: LD_INT 0
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 30
88007: PUSH
88008: LD_INT 1
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 30
88017: PUSH
88018: LD_INT 6
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: PPUSH
88031: CALL_OW 72
88035: PPUSH
88036: LD_VAR 0 7
88040: PPUSH
88041: CALL_OW 74
88045: PPUSH
88046: CALL_OW 296
88050: PUSH
88051: LD_INT 10
88053: GREATER
88054: IFFALSE 88207
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
88056: LD_ADDR_VAR 0 8
88060: PUSH
88061: LD_EXP 23
88065: PUSH
88066: LD_VAR 0 1
88070: ARRAY
88071: PPUSH
88072: LD_INT 2
88074: PUSH
88075: LD_INT 30
88077: PUSH
88078: LD_INT 0
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 30
88087: PUSH
88088: LD_INT 1
88090: PUSH
88091: EMPTY
88092: LIST
88093: LIST
88094: PUSH
88095: LD_INT 30
88097: PUSH
88098: LD_INT 6
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: EMPTY
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: PPUSH
88111: CALL_OW 72
88115: PPUSH
88116: LD_VAR 0 7
88120: PPUSH
88121: CALL_OW 74
88125: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
88126: LD_VAR 0 7
88130: PPUSH
88131: LD_VAR 0 8
88135: PPUSH
88136: CALL_OW 250
88140: PPUSH
88141: LD_INT 3
88143: PPUSH
88144: LD_INT 5
88146: PPUSH
88147: CALL_OW 272
88151: PPUSH
88152: LD_VAR 0 8
88156: PPUSH
88157: CALL_OW 251
88161: PPUSH
88162: LD_INT 3
88164: PPUSH
88165: LD_INT 5
88167: PPUSH
88168: CALL_OW 273
88172: PPUSH
88173: CALL_OW 111
// SetTag ( i , 0 ) ;
88177: LD_VAR 0 7
88181: PPUSH
88182: LD_INT 0
88184: PPUSH
88185: CALL_OW 109
// solds := solds diff i ;
88189: LD_ADDR_VAR 0 2
88193: PUSH
88194: LD_VAR 0 2
88198: PUSH
88199: LD_VAR 0 7
88203: DIFF
88204: ST_TO_ADDR
// continue ;
88205: GO 87887
// end ; end ;
88207: GO 87887
88209: POP
88210: POP
// until not solds or not enemy ;
88211: LD_VAR 0 2
88215: NOT
88216: PUSH
88217: LD_VAR 0 4
88221: NOT
88222: OR
88223: IFFALSE 87791
// MC_Reset ( base , 18 ) ;
88225: LD_VAR 0 1
88229: PPUSH
88230: LD_INT 18
88232: PPUSH
88233: CALL 56434 0 2
// end ;
88237: LD_VAR 0 3
88241: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
88242: LD_INT 0
88244: PPUSH
88245: PPUSH
88246: PPUSH
88247: PPUSH
88248: PPUSH
88249: PPUSH
88250: PPUSH
88251: PPUSH
88252: PPUSH
88253: PPUSH
88254: PPUSH
88255: PPUSH
88256: PPUSH
88257: PPUSH
88258: PPUSH
88259: PPUSH
88260: PPUSH
88261: PPUSH
88262: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88263: LD_ADDR_VAR 0 12
88267: PUSH
88268: LD_EXP 23
88272: PUSH
88273: LD_VAR 0 1
88277: ARRAY
88278: PPUSH
88279: LD_INT 25
88281: PUSH
88282: LD_INT 3
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: PPUSH
88289: CALL_OW 72
88293: ST_TO_ADDR
// if mc_remote_driver [ base ] then
88294: LD_EXP 63
88298: PUSH
88299: LD_VAR 0 1
88303: ARRAY
88304: IFFALSE 88328
// mechs := mechs diff mc_remote_driver [ base ] ;
88306: LD_ADDR_VAR 0 12
88310: PUSH
88311: LD_VAR 0 12
88315: PUSH
88316: LD_EXP 63
88320: PUSH
88321: LD_VAR 0 1
88325: ARRAY
88326: DIFF
88327: ST_TO_ADDR
// for i in mechs do
88328: LD_ADDR_VAR 0 4
88332: PUSH
88333: LD_VAR 0 12
88337: PUSH
88338: FOR_IN
88339: IFFALSE 88374
// if GetTag ( i ) > 0 then
88341: LD_VAR 0 4
88345: PPUSH
88346: CALL_OW 110
88350: PUSH
88351: LD_INT 0
88353: GREATER
88354: IFFALSE 88372
// mechs := mechs diff i ;
88356: LD_ADDR_VAR 0 12
88360: PUSH
88361: LD_VAR 0 12
88365: PUSH
88366: LD_VAR 0 4
88370: DIFF
88371: ST_TO_ADDR
88372: GO 88338
88374: POP
88375: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88376: LD_ADDR_VAR 0 8
88380: PUSH
88381: LD_EXP 23
88385: PUSH
88386: LD_VAR 0 1
88390: ARRAY
88391: PPUSH
88392: LD_INT 2
88394: PUSH
88395: LD_INT 25
88397: PUSH
88398: LD_INT 1
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 25
88407: PUSH
88408: LD_INT 5
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: LD_INT 25
88417: PUSH
88418: LD_INT 8
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: PUSH
88425: LD_INT 25
88427: PUSH
88428: LD_INT 9
88430: PUSH
88431: EMPTY
88432: LIST
88433: LIST
88434: PUSH
88435: EMPTY
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: PPUSH
88442: CALL_OW 72
88446: ST_TO_ADDR
// if not defenders and not solds then
88447: LD_VAR 0 2
88451: NOT
88452: PUSH
88453: LD_VAR 0 8
88457: NOT
88458: AND
88459: IFFALSE 88463
// exit ;
88461: GO 90233
// depot_under_attack := false ;
88463: LD_ADDR_VAR 0 16
88467: PUSH
88468: LD_INT 0
88470: ST_TO_ADDR
// sold_defenders := [ ] ;
88471: LD_ADDR_VAR 0 17
88475: PUSH
88476: EMPTY
88477: ST_TO_ADDR
// if mechs then
88478: LD_VAR 0 12
88482: IFFALSE 88635
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
88484: LD_ADDR_VAR 0 4
88488: PUSH
88489: LD_VAR 0 2
88493: PPUSH
88494: LD_INT 21
88496: PUSH
88497: LD_INT 2
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PPUSH
88504: CALL_OW 72
88508: PUSH
88509: FOR_IN
88510: IFFALSE 88633
// begin if GetTag ( i ) <> 20 then
88512: LD_VAR 0 4
88516: PPUSH
88517: CALL_OW 110
88521: PUSH
88522: LD_INT 20
88524: NONEQUAL
88525: IFFALSE 88539
// SetTag ( i , 20 ) ;
88527: LD_VAR 0 4
88531: PPUSH
88532: LD_INT 20
88534: PPUSH
88535: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88539: LD_VAR 0 4
88543: PPUSH
88544: CALL_OW 263
88548: PUSH
88549: LD_INT 1
88551: EQUAL
88552: PUSH
88553: LD_VAR 0 4
88557: PPUSH
88558: CALL_OW 311
88562: NOT
88563: AND
88564: IFFALSE 88631
// begin un := mechs [ 1 ] ;
88566: LD_ADDR_VAR 0 10
88570: PUSH
88571: LD_VAR 0 12
88575: PUSH
88576: LD_INT 1
88578: ARRAY
88579: ST_TO_ADDR
// ComExit ( un ) ;
88580: LD_VAR 0 10
88584: PPUSH
88585: CALL 48862 0 1
// AddComEnterUnit ( un , i ) ;
88589: LD_VAR 0 10
88593: PPUSH
88594: LD_VAR 0 4
88598: PPUSH
88599: CALL_OW 180
// SetTag ( un , 19 ) ;
88603: LD_VAR 0 10
88607: PPUSH
88608: LD_INT 19
88610: PPUSH
88611: CALL_OW 109
// mechs := mechs diff un ;
88615: LD_ADDR_VAR 0 12
88619: PUSH
88620: LD_VAR 0 12
88624: PUSH
88625: LD_VAR 0 10
88629: DIFF
88630: ST_TO_ADDR
// end ; end ;
88631: GO 88509
88633: POP
88634: POP
// if solds then
88635: LD_VAR 0 8
88639: IFFALSE 88698
// for i in solds do
88641: LD_ADDR_VAR 0 4
88645: PUSH
88646: LD_VAR 0 8
88650: PUSH
88651: FOR_IN
88652: IFFALSE 88696
// if not GetTag ( i ) then
88654: LD_VAR 0 4
88658: PPUSH
88659: CALL_OW 110
88663: NOT
88664: IFFALSE 88694
// begin defenders := defenders union i ;
88666: LD_ADDR_VAR 0 2
88670: PUSH
88671: LD_VAR 0 2
88675: PUSH
88676: LD_VAR 0 4
88680: UNION
88681: ST_TO_ADDR
// SetTag ( i , 18 ) ;
88682: LD_VAR 0 4
88686: PPUSH
88687: LD_INT 18
88689: PPUSH
88690: CALL_OW 109
// end ;
88694: GO 88651
88696: POP
88697: POP
// repeat wait ( 0 0$2 ) ;
88698: LD_INT 70
88700: PPUSH
88701: CALL_OW 67
// enemy := mc_scan [ base ] ;
88705: LD_ADDR_VAR 0 21
88709: PUSH
88710: LD_EXP 46
88714: PUSH
88715: LD_VAR 0 1
88719: ARRAY
88720: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88721: LD_EXP 23
88725: PUSH
88726: LD_VAR 0 1
88730: ARRAY
88731: NOT
88732: PUSH
88733: LD_EXP 23
88737: PUSH
88738: LD_VAR 0 1
88742: ARRAY
88743: PUSH
88744: EMPTY
88745: EQUAL
88746: OR
88747: IFFALSE 88784
// begin for i in defenders do
88749: LD_ADDR_VAR 0 4
88753: PUSH
88754: LD_VAR 0 2
88758: PUSH
88759: FOR_IN
88760: IFFALSE 88773
// ComStop ( i ) ;
88762: LD_VAR 0 4
88766: PPUSH
88767: CALL_OW 141
88771: GO 88759
88773: POP
88774: POP
// defenders := [ ] ;
88775: LD_ADDR_VAR 0 2
88779: PUSH
88780: EMPTY
88781: ST_TO_ADDR
// exit ;
88782: GO 90233
// end ; for i in defenders do
88784: LD_ADDR_VAR 0 4
88788: PUSH
88789: LD_VAR 0 2
88793: PUSH
88794: FOR_IN
88795: IFFALSE 89693
// begin e := NearestUnitToUnit ( enemy , i ) ;
88797: LD_ADDR_VAR 0 13
88801: PUSH
88802: LD_VAR 0 21
88806: PPUSH
88807: LD_VAR 0 4
88811: PPUSH
88812: CALL_OW 74
88816: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88817: LD_ADDR_VAR 0 7
88821: PUSH
88822: LD_EXP 23
88826: PUSH
88827: LD_VAR 0 1
88831: ARRAY
88832: PPUSH
88833: LD_INT 2
88835: PUSH
88836: LD_INT 30
88838: PUSH
88839: LD_INT 0
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PUSH
88846: LD_INT 30
88848: PUSH
88849: LD_INT 1
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: LIST
88860: PPUSH
88861: CALL_OW 72
88865: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
88866: LD_ADDR_VAR 0 16
88870: PUSH
88871: LD_VAR 0 7
88875: NOT
88876: PUSH
88877: LD_VAR 0 7
88881: PPUSH
88882: LD_INT 3
88884: PUSH
88885: LD_INT 24
88887: PUSH
88888: LD_INT 600
88890: PUSH
88891: EMPTY
88892: LIST
88893: LIST
88894: PUSH
88895: EMPTY
88896: LIST
88897: LIST
88898: PPUSH
88899: CALL_OW 72
88903: OR
88904: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
88905: LD_VAR 0 4
88909: PPUSH
88910: CALL_OW 247
88914: PUSH
88915: LD_INT 2
88917: DOUBLE
88918: EQUAL
88919: IFTRUE 88923
88921: GO 89319
88923: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
88924: LD_VAR 0 4
88928: PPUSH
88929: CALL_OW 256
88933: PUSH
88934: LD_INT 1000
88936: EQUAL
88937: PUSH
88938: LD_VAR 0 4
88942: PPUSH
88943: LD_VAR 0 13
88947: PPUSH
88948: CALL_OW 296
88952: PUSH
88953: LD_INT 40
88955: LESS
88956: PUSH
88957: LD_VAR 0 13
88961: PPUSH
88962: LD_EXP 48
88966: PUSH
88967: LD_VAR 0 1
88971: ARRAY
88972: PPUSH
88973: CALL_OW 308
88977: OR
88978: AND
88979: IFFALSE 89101
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
88981: LD_VAR 0 4
88985: PPUSH
88986: CALL_OW 262
88990: PUSH
88991: LD_INT 1
88993: EQUAL
88994: PUSH
88995: LD_VAR 0 4
88999: PPUSH
89000: CALL_OW 261
89004: PUSH
89005: LD_INT 30
89007: LESS
89008: AND
89009: PUSH
89010: LD_VAR 0 7
89014: AND
89015: IFFALSE 89085
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
89017: LD_VAR 0 4
89021: PPUSH
89022: LD_VAR 0 7
89026: PPUSH
89027: LD_VAR 0 4
89031: PPUSH
89032: CALL_OW 74
89036: PPUSH
89037: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
89041: LD_VAR 0 4
89045: PPUSH
89046: LD_VAR 0 7
89050: PPUSH
89051: LD_VAR 0 4
89055: PPUSH
89056: CALL_OW 74
89060: PPUSH
89061: CALL_OW 296
89065: PUSH
89066: LD_INT 6
89068: LESS
89069: IFFALSE 89083
// SetFuel ( i , 100 ) ;
89071: LD_VAR 0 4
89075: PPUSH
89076: LD_INT 100
89078: PPUSH
89079: CALL_OW 240
// end else
89083: GO 89099
// ComAttackUnit ( i , e ) ;
89085: LD_VAR 0 4
89089: PPUSH
89090: LD_VAR 0 13
89094: PPUSH
89095: CALL_OW 115
// end else
89099: GO 89202
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
89101: LD_VAR 0 13
89105: PPUSH
89106: LD_EXP 48
89110: PUSH
89111: LD_VAR 0 1
89115: ARRAY
89116: PPUSH
89117: CALL_OW 308
89121: NOT
89122: PUSH
89123: LD_VAR 0 4
89127: PPUSH
89128: LD_VAR 0 13
89132: PPUSH
89133: CALL_OW 296
89137: PUSH
89138: LD_INT 40
89140: GREATEREQUAL
89141: AND
89142: PUSH
89143: LD_VAR 0 4
89147: PPUSH
89148: CALL_OW 256
89152: PUSH
89153: LD_INT 650
89155: LESSEQUAL
89156: OR
89157: PUSH
89158: LD_VAR 0 4
89162: PPUSH
89163: LD_EXP 47
89167: PUSH
89168: LD_VAR 0 1
89172: ARRAY
89173: PPUSH
89174: CALL_OW 308
89178: NOT
89179: AND
89180: IFFALSE 89202
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89182: LD_VAR 0 4
89186: PPUSH
89187: LD_EXP 47
89191: PUSH
89192: LD_VAR 0 1
89196: ARRAY
89197: PPUSH
89198: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
89202: LD_VAR 0 4
89206: PPUSH
89207: CALL_OW 256
89211: PUSH
89212: LD_INT 1000
89214: LESS
89215: PUSH
89216: LD_VAR 0 4
89220: PPUSH
89221: CALL_OW 263
89225: PUSH
89226: LD_INT 1
89228: EQUAL
89229: AND
89230: PUSH
89231: LD_VAR 0 4
89235: PPUSH
89236: CALL_OW 311
89240: AND
89241: PUSH
89242: LD_VAR 0 4
89246: PPUSH
89247: LD_EXP 47
89251: PUSH
89252: LD_VAR 0 1
89256: ARRAY
89257: PPUSH
89258: CALL_OW 308
89262: AND
89263: IFFALSE 89317
// begin mech := IsDrivenBy ( i ) ;
89265: LD_ADDR_VAR 0 9
89269: PUSH
89270: LD_VAR 0 4
89274: PPUSH
89275: CALL_OW 311
89279: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
89280: LD_VAR 0 9
89284: PPUSH
89285: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
89289: LD_VAR 0 9
89293: PPUSH
89294: LD_VAR 0 4
89298: PPUSH
89299: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
89303: LD_VAR 0 9
89307: PPUSH
89308: LD_VAR 0 4
89312: PPUSH
89313: CALL_OW 180
// end ; end ; unit_human :
89317: GO 89664
89319: LD_INT 1
89321: DOUBLE
89322: EQUAL
89323: IFTRUE 89327
89325: GO 89663
89327: POP
// begin b := IsInUnit ( i ) ;
89328: LD_ADDR_VAR 0 18
89332: PUSH
89333: LD_VAR 0 4
89337: PPUSH
89338: CALL_OW 310
89342: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
89343: LD_ADDR_VAR 0 19
89347: PUSH
89348: LD_VAR 0 18
89352: NOT
89353: PUSH
89354: LD_VAR 0 18
89358: PPUSH
89359: CALL_OW 266
89363: PUSH
89364: LD_INT 32
89366: PUSH
89367: LD_INT 31
89369: PUSH
89370: EMPTY
89371: LIST
89372: LIST
89373: IN
89374: OR
89375: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
89376: LD_VAR 0 18
89380: PPUSH
89381: CALL_OW 266
89385: PUSH
89386: LD_INT 5
89388: EQUAL
89389: PUSH
89390: LD_VAR 0 4
89394: PPUSH
89395: CALL_OW 257
89399: PUSH
89400: LD_INT 1
89402: PUSH
89403: LD_INT 2
89405: PUSH
89406: LD_INT 3
89408: PUSH
89409: LD_INT 4
89411: PUSH
89412: EMPTY
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: IN
89418: AND
89419: IFFALSE 89456
// begin class := AllowSpecClass ( i ) ;
89421: LD_ADDR_VAR 0 20
89425: PUSH
89426: LD_VAR 0 4
89430: PPUSH
89431: CALL 12801 0 1
89435: ST_TO_ADDR
// if class then
89436: LD_VAR 0 20
89440: IFFALSE 89456
// ComChangeProfession ( i , class ) ;
89442: LD_VAR 0 4
89446: PPUSH
89447: LD_VAR 0 20
89451: PPUSH
89452: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
89456: LD_VAR 0 16
89460: PUSH
89461: LD_VAR 0 2
89465: PPUSH
89466: LD_INT 21
89468: PUSH
89469: LD_INT 2
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: PPUSH
89476: CALL_OW 72
89480: PUSH
89481: LD_INT 1
89483: LESSEQUAL
89484: OR
89485: PUSH
89486: LD_VAR 0 19
89490: AND
89491: PUSH
89492: LD_VAR 0 4
89496: PUSH
89497: LD_VAR 0 17
89501: IN
89502: NOT
89503: AND
89504: IFFALSE 89597
// begin if b then
89506: LD_VAR 0 18
89510: IFFALSE 89559
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89512: LD_VAR 0 18
89516: PPUSH
89517: LD_VAR 0 21
89521: PPUSH
89522: LD_VAR 0 18
89526: PPUSH
89527: CALL_OW 74
89531: PPUSH
89532: CALL_OW 296
89536: PUSH
89537: LD_INT 10
89539: LESS
89540: PUSH
89541: LD_VAR 0 18
89545: PPUSH
89546: CALL_OW 461
89550: PUSH
89551: LD_INT 7
89553: NONEQUAL
89554: AND
89555: IFFALSE 89559
// continue ;
89557: GO 88794
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89559: LD_ADDR_VAR 0 17
89563: PUSH
89564: LD_VAR 0 17
89568: PPUSH
89569: LD_VAR 0 17
89573: PUSH
89574: LD_INT 1
89576: PLUS
89577: PPUSH
89578: LD_VAR 0 4
89582: PPUSH
89583: CALL_OW 1
89587: ST_TO_ADDR
// ComExitBuilding ( i ) ;
89588: LD_VAR 0 4
89592: PPUSH
89593: CALL_OW 122
// end ; if sold_defenders then
89597: LD_VAR 0 17
89601: IFFALSE 89661
// if i in sold_defenders then
89603: LD_VAR 0 4
89607: PUSH
89608: LD_VAR 0 17
89612: IN
89613: IFFALSE 89661
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
89615: LD_VAR 0 4
89619: PPUSH
89620: CALL_OW 314
89624: NOT
89625: PUSH
89626: LD_VAR 0 4
89630: PPUSH
89631: LD_VAR 0 13
89635: PPUSH
89636: CALL_OW 296
89640: PUSH
89641: LD_INT 30
89643: LESS
89644: AND
89645: IFFALSE 89661
// ComAttackUnit ( i , e ) ;
89647: LD_VAR 0 4
89651: PPUSH
89652: LD_VAR 0 13
89656: PPUSH
89657: CALL_OW 115
// end ; end ; end ;
89661: GO 89664
89663: POP
// if IsDead ( i ) then
89664: LD_VAR 0 4
89668: PPUSH
89669: CALL_OW 301
89673: IFFALSE 89691
// defenders := defenders diff i ;
89675: LD_ADDR_VAR 0 2
89679: PUSH
89680: LD_VAR 0 2
89684: PUSH
89685: LD_VAR 0 4
89689: DIFF
89690: ST_TO_ADDR
// end ;
89691: GO 88794
89693: POP
89694: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
89695: LD_VAR 0 21
89699: NOT
89700: PUSH
89701: LD_VAR 0 2
89705: NOT
89706: OR
89707: PUSH
89708: LD_EXP 23
89712: PUSH
89713: LD_VAR 0 1
89717: ARRAY
89718: NOT
89719: OR
89720: IFFALSE 88698
// MC_Reset ( base , 18 ) ;
89722: LD_VAR 0 1
89726: PPUSH
89727: LD_INT 18
89729: PPUSH
89730: CALL 56434 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89734: LD_ADDR_VAR 0 2
89738: PUSH
89739: LD_VAR 0 2
89743: PUSH
89744: LD_VAR 0 2
89748: PPUSH
89749: LD_INT 2
89751: PUSH
89752: LD_INT 25
89754: PUSH
89755: LD_INT 1
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 25
89764: PUSH
89765: LD_INT 5
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: PUSH
89772: LD_INT 25
89774: PUSH
89775: LD_INT 8
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 25
89784: PUSH
89785: LD_INT 9
89787: PUSH
89788: EMPTY
89789: LIST
89790: LIST
89791: PUSH
89792: EMPTY
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: LIST
89798: PPUSH
89799: CALL_OW 72
89803: DIFF
89804: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
89805: LD_VAR 0 21
89809: NOT
89810: PUSH
89811: LD_VAR 0 2
89815: PPUSH
89816: LD_INT 21
89818: PUSH
89819: LD_INT 2
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PPUSH
89826: CALL_OW 72
89830: AND
89831: IFFALSE 90169
// begin tmp := FilterByTag ( defenders , 19 ) ;
89833: LD_ADDR_VAR 0 11
89837: PUSH
89838: LD_VAR 0 2
89842: PPUSH
89843: LD_INT 19
89845: PPUSH
89846: CALL 46038 0 2
89850: ST_TO_ADDR
// if tmp then
89851: LD_VAR 0 11
89855: IFFALSE 89925
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
89857: LD_ADDR_VAR 0 11
89861: PUSH
89862: LD_VAR 0 11
89866: PPUSH
89867: LD_INT 25
89869: PUSH
89870: LD_INT 3
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PPUSH
89877: CALL_OW 72
89881: ST_TO_ADDR
// if tmp then
89882: LD_VAR 0 11
89886: IFFALSE 89925
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
89888: LD_ADDR_EXP 35
89892: PUSH
89893: LD_EXP 35
89897: PPUSH
89898: LD_VAR 0 1
89902: PPUSH
89903: LD_EXP 35
89907: PUSH
89908: LD_VAR 0 1
89912: ARRAY
89913: PUSH
89914: LD_VAR 0 11
89918: UNION
89919: PPUSH
89920: CALL_OW 1
89924: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
89925: LD_VAR 0 1
89929: PPUSH
89930: LD_INT 19
89932: PPUSH
89933: CALL 56434 0 2
// repeat wait ( 0 0$1 ) ;
89937: LD_INT 35
89939: PPUSH
89940: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
89944: LD_EXP 23
89948: PUSH
89949: LD_VAR 0 1
89953: ARRAY
89954: NOT
89955: PUSH
89956: LD_EXP 23
89960: PUSH
89961: LD_VAR 0 1
89965: ARRAY
89966: PUSH
89967: EMPTY
89968: EQUAL
89969: OR
89970: IFFALSE 90007
// begin for i in defenders do
89972: LD_ADDR_VAR 0 4
89976: PUSH
89977: LD_VAR 0 2
89981: PUSH
89982: FOR_IN
89983: IFFALSE 89996
// ComStop ( i ) ;
89985: LD_VAR 0 4
89989: PPUSH
89990: CALL_OW 141
89994: GO 89982
89996: POP
89997: POP
// defenders := [ ] ;
89998: LD_ADDR_VAR 0 2
90002: PUSH
90003: EMPTY
90004: ST_TO_ADDR
// exit ;
90005: GO 90233
// end ; for i in defenders do
90007: LD_ADDR_VAR 0 4
90011: PUSH
90012: LD_VAR 0 2
90016: PUSH
90017: FOR_IN
90018: IFFALSE 90107
// begin if not IsInArea ( i , mc_parking [ base ] ) then
90020: LD_VAR 0 4
90024: PPUSH
90025: LD_EXP 47
90029: PUSH
90030: LD_VAR 0 1
90034: ARRAY
90035: PPUSH
90036: CALL_OW 308
90040: NOT
90041: IFFALSE 90065
// ComMoveToArea ( i , mc_parking [ base ] ) else
90043: LD_VAR 0 4
90047: PPUSH
90048: LD_EXP 47
90052: PUSH
90053: LD_VAR 0 1
90057: ARRAY
90058: PPUSH
90059: CALL_OW 113
90063: GO 90105
// if GetControl ( i ) = control_manual then
90065: LD_VAR 0 4
90069: PPUSH
90070: CALL_OW 263
90074: PUSH
90075: LD_INT 1
90077: EQUAL
90078: IFFALSE 90105
// if IsDrivenBy ( i ) then
90080: LD_VAR 0 4
90084: PPUSH
90085: CALL_OW 311
90089: IFFALSE 90105
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
90091: LD_VAR 0 4
90095: PPUSH
90096: CALL_OW 311
90100: PPUSH
90101: CALL_OW 121
// end ;
90105: GO 90017
90107: POP
90108: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
90109: LD_VAR 0 2
90113: PPUSH
90114: LD_INT 95
90116: PUSH
90117: LD_EXP 47
90121: PUSH
90122: LD_VAR 0 1
90126: ARRAY
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PPUSH
90132: CALL_OW 72
90136: PUSH
90137: LD_VAR 0 2
90141: EQUAL
90142: PUSH
90143: LD_EXP 46
90147: PUSH
90148: LD_VAR 0 1
90152: ARRAY
90153: OR
90154: PUSH
90155: LD_EXP 23
90159: PUSH
90160: LD_VAR 0 1
90164: ARRAY
90165: NOT
90166: OR
90167: IFFALSE 89937
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90169: LD_ADDR_EXP 45
90173: PUSH
90174: LD_EXP 45
90178: PPUSH
90179: LD_VAR 0 1
90183: PPUSH
90184: LD_VAR 0 2
90188: PPUSH
90189: LD_INT 21
90191: PUSH
90192: LD_INT 2
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PPUSH
90199: CALL_OW 72
90203: PPUSH
90204: CALL_OW 1
90208: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
90209: LD_VAR 0 1
90213: PPUSH
90214: LD_INT 19
90216: PPUSH
90217: CALL 56434 0 2
// MC_Reset ( base , 20 ) ;
90221: LD_VAR 0 1
90225: PPUSH
90226: LD_INT 20
90228: PPUSH
90229: CALL 56434 0 2
// end ; end_of_file
90233: LD_VAR 0 3
90237: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
90238: LD_INT 0
90240: PPUSH
90241: PPUSH
90242: PPUSH
90243: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90244: LD_VAR 0 1
90248: PPUSH
90249: CALL_OW 264
90253: PUSH
90254: LD_INT 91
90256: EQUAL
90257: IFFALSE 90329
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90259: LD_INT 68
90261: PPUSH
90262: LD_VAR 0 1
90266: PPUSH
90267: CALL_OW 255
90271: PPUSH
90272: CALL_OW 321
90276: PUSH
90277: LD_INT 2
90279: EQUAL
90280: IFFALSE 90292
// eff := 70 else
90282: LD_ADDR_VAR 0 4
90286: PUSH
90287: LD_INT 70
90289: ST_TO_ADDR
90290: GO 90300
// eff := 30 ;
90292: LD_ADDR_VAR 0 4
90296: PUSH
90297: LD_INT 30
90299: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90300: LD_VAR 0 1
90304: PPUSH
90305: CALL_OW 250
90309: PPUSH
90310: LD_VAR 0 1
90314: PPUSH
90315: CALL_OW 251
90319: PPUSH
90320: LD_VAR 0 4
90324: PPUSH
90325: CALL_OW 495
// end ; end ;
90329: LD_VAR 0 2
90333: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
90334: LD_INT 0
90336: PPUSH
// end ;
90337: LD_VAR 0 4
90341: RET
// export function SOS_Command ( cmd ) ; begin
90342: LD_INT 0
90344: PPUSH
// end ;
90345: LD_VAR 0 2
90349: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
90350: LD_INT 0
90352: PPUSH
// end ;
90353: LD_VAR 0 6
90357: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
90358: LD_INT 0
90360: PPUSH
90361: PPUSH
// if not vehicle or not factory then
90362: LD_VAR 0 1
90366: NOT
90367: PUSH
90368: LD_VAR 0 2
90372: NOT
90373: OR
90374: IFFALSE 90378
// exit ;
90376: GO 90609
// if factoryWaypoints >= factory then
90378: LD_EXP 135
90382: PUSH
90383: LD_VAR 0 2
90387: GREATEREQUAL
90388: IFFALSE 90609
// if factoryWaypoints [ factory ] then
90390: LD_EXP 135
90394: PUSH
90395: LD_VAR 0 2
90399: ARRAY
90400: IFFALSE 90609
// begin if GetControl ( vehicle ) = control_manual then
90402: LD_VAR 0 1
90406: PPUSH
90407: CALL_OW 263
90411: PUSH
90412: LD_INT 1
90414: EQUAL
90415: IFFALSE 90496
// begin driver := IsDrivenBy ( vehicle ) ;
90417: LD_ADDR_VAR 0 4
90421: PUSH
90422: LD_VAR 0 1
90426: PPUSH
90427: CALL_OW 311
90431: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90432: LD_VAR 0 4
90436: PPUSH
90437: LD_EXP 135
90441: PUSH
90442: LD_VAR 0 2
90446: ARRAY
90447: PUSH
90448: LD_INT 3
90450: ARRAY
90451: PPUSH
90452: LD_EXP 135
90456: PUSH
90457: LD_VAR 0 2
90461: ARRAY
90462: PUSH
90463: LD_INT 4
90465: ARRAY
90466: PPUSH
90467: CALL_OW 171
// AddComExitVehicle ( driver ) ;
90471: LD_VAR 0 4
90475: PPUSH
90476: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
90480: LD_VAR 0 4
90484: PPUSH
90485: LD_VAR 0 2
90489: PPUSH
90490: CALL_OW 180
// end else
90494: GO 90609
// if GetControl ( vehicle ) = control_remote then
90496: LD_VAR 0 1
90500: PPUSH
90501: CALL_OW 263
90505: PUSH
90506: LD_INT 2
90508: EQUAL
90509: IFFALSE 90570
// begin wait ( 0 0$2 ) ;
90511: LD_INT 70
90513: PPUSH
90514: CALL_OW 67
// if Connect ( vehicle ) then
90518: LD_VAR 0 1
90522: PPUSH
90523: CALL 19121 0 1
90527: IFFALSE 90568
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90529: LD_VAR 0 1
90533: PPUSH
90534: LD_EXP 135
90538: PUSH
90539: LD_VAR 0 2
90543: ARRAY
90544: PUSH
90545: LD_INT 3
90547: ARRAY
90548: PPUSH
90549: LD_EXP 135
90553: PUSH
90554: LD_VAR 0 2
90558: ARRAY
90559: PUSH
90560: LD_INT 4
90562: ARRAY
90563: PPUSH
90564: CALL_OW 171
// end else
90568: GO 90609
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90570: LD_VAR 0 1
90574: PPUSH
90575: LD_EXP 135
90579: PUSH
90580: LD_VAR 0 2
90584: ARRAY
90585: PUSH
90586: LD_INT 3
90588: ARRAY
90589: PPUSH
90590: LD_EXP 135
90594: PUSH
90595: LD_VAR 0 2
90599: ARRAY
90600: PUSH
90601: LD_INT 4
90603: ARRAY
90604: PPUSH
90605: CALL_OW 171
// end ; end ;
90609: LD_VAR 0 3
90613: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
90614: LD_INT 0
90616: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
90617: LD_VAR 0 1
90621: PUSH
90622: LD_INT 250
90624: EQUAL
90625: PUSH
90626: LD_VAR 0 2
90630: PPUSH
90631: CALL_OW 264
90635: PUSH
90636: LD_INT 81
90638: EQUAL
90639: AND
90640: IFFALSE 90661
// MinerPlaceMine ( unit , x , y ) ;
90642: LD_VAR 0 2
90646: PPUSH
90647: LD_VAR 0 4
90651: PPUSH
90652: LD_VAR 0 5
90656: PPUSH
90657: CALL 93046 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
90661: LD_VAR 0 1
90665: PUSH
90666: LD_INT 251
90668: EQUAL
90669: PUSH
90670: LD_VAR 0 2
90674: PPUSH
90675: CALL_OW 264
90679: PUSH
90680: LD_INT 81
90682: EQUAL
90683: AND
90684: IFFALSE 90705
// MinerDetonateMine ( unit , x , y ) ;
90686: LD_VAR 0 2
90690: PPUSH
90691: LD_VAR 0 4
90695: PPUSH
90696: LD_VAR 0 5
90700: PPUSH
90701: CALL 93321 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
90705: LD_VAR 0 1
90709: PUSH
90710: LD_INT 252
90712: EQUAL
90713: PUSH
90714: LD_VAR 0 2
90718: PPUSH
90719: CALL_OW 264
90723: PUSH
90724: LD_INT 81
90726: EQUAL
90727: AND
90728: IFFALSE 90749
// MinerCreateMinefield ( unit , x , y ) ;
90730: LD_VAR 0 2
90734: PPUSH
90735: LD_VAR 0 4
90739: PPUSH
90740: LD_VAR 0 5
90744: PPUSH
90745: CALL 93738 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
90749: LD_VAR 0 1
90753: PUSH
90754: LD_INT 253
90756: EQUAL
90757: PUSH
90758: LD_VAR 0 2
90762: PPUSH
90763: CALL_OW 257
90767: PUSH
90768: LD_INT 5
90770: EQUAL
90771: AND
90772: IFFALSE 90793
// ComBinocular ( unit , x , y ) ;
90774: LD_VAR 0 2
90778: PPUSH
90779: LD_VAR 0 4
90783: PPUSH
90784: LD_VAR 0 5
90788: PPUSH
90789: CALL 94107 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
90793: LD_VAR 0 1
90797: PUSH
90798: LD_INT 254
90800: EQUAL
90801: PUSH
90802: LD_VAR 0 2
90806: PPUSH
90807: CALL_OW 264
90811: PUSH
90812: LD_INT 99
90814: EQUAL
90815: AND
90816: PUSH
90817: LD_VAR 0 3
90821: PPUSH
90822: CALL_OW 263
90826: PUSH
90827: LD_INT 3
90829: EQUAL
90830: AND
90831: IFFALSE 90847
// HackDestroyVehicle ( unit , selectedUnit ) ;
90833: LD_VAR 0 2
90837: PPUSH
90838: LD_VAR 0 3
90842: PPUSH
90843: CALL 92410 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
90847: LD_VAR 0 1
90851: PUSH
90852: LD_INT 255
90854: EQUAL
90855: PUSH
90856: LD_VAR 0 2
90860: PPUSH
90861: CALL_OW 264
90865: PUSH
90866: LD_INT 14
90868: PUSH
90869: LD_INT 53
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: IN
90876: AND
90877: PUSH
90878: LD_VAR 0 4
90882: PPUSH
90883: LD_VAR 0 5
90887: PPUSH
90888: CALL_OW 488
90892: AND
90893: IFFALSE 90917
// CutTreeXYR ( unit , x , y , 12 ) ;
90895: LD_VAR 0 2
90899: PPUSH
90900: LD_VAR 0 4
90904: PPUSH
90905: LD_VAR 0 5
90909: PPUSH
90910: LD_INT 12
90912: PPUSH
90913: CALL 90980 0 4
// if cmd = 256 then
90917: LD_VAR 0 1
90921: PUSH
90922: LD_INT 256
90924: EQUAL
90925: IFFALSE 90946
// SetFactoryWaypoint ( unit , x , y ) ;
90927: LD_VAR 0 2
90931: PPUSH
90932: LD_VAR 0 4
90936: PPUSH
90937: LD_VAR 0 5
90941: PPUSH
90942: CALL 109028 0 3
// if cmd = 257 then
90946: LD_VAR 0 1
90950: PUSH
90951: LD_INT 257
90953: EQUAL
90954: IFFALSE 90975
// SetWarehouseGatheringPoint ( unit , x , y ) ;
90956: LD_VAR 0 2
90960: PPUSH
90961: LD_VAR 0 4
90965: PPUSH
90966: LD_VAR 0 5
90970: PPUSH
90971: CALL 109390 0 3
// end ;
90975: LD_VAR 0 6
90979: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
90980: LD_INT 0
90982: PPUSH
90983: PPUSH
90984: PPUSH
90985: PPUSH
90986: PPUSH
90987: PPUSH
90988: PPUSH
90989: PPUSH
90990: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
90991: LD_VAR 0 1
90995: NOT
90996: PUSH
90997: LD_VAR 0 2
91001: PPUSH
91002: LD_VAR 0 3
91006: PPUSH
91007: CALL_OW 488
91011: NOT
91012: OR
91013: PUSH
91014: LD_VAR 0 4
91018: NOT
91019: OR
91020: IFFALSE 91024
// exit ;
91022: GO 91364
// list := [ ] ;
91024: LD_ADDR_VAR 0 13
91028: PUSH
91029: EMPTY
91030: ST_TO_ADDR
// if x - r < 0 then
91031: LD_VAR 0 2
91035: PUSH
91036: LD_VAR 0 4
91040: MINUS
91041: PUSH
91042: LD_INT 0
91044: LESS
91045: IFFALSE 91057
// min_x := 0 else
91047: LD_ADDR_VAR 0 7
91051: PUSH
91052: LD_INT 0
91054: ST_TO_ADDR
91055: GO 91073
// min_x := x - r ;
91057: LD_ADDR_VAR 0 7
91061: PUSH
91062: LD_VAR 0 2
91066: PUSH
91067: LD_VAR 0 4
91071: MINUS
91072: ST_TO_ADDR
// if y - r < 0 then
91073: LD_VAR 0 3
91077: PUSH
91078: LD_VAR 0 4
91082: MINUS
91083: PUSH
91084: LD_INT 0
91086: LESS
91087: IFFALSE 91099
// min_y := 0 else
91089: LD_ADDR_VAR 0 8
91093: PUSH
91094: LD_INT 0
91096: ST_TO_ADDR
91097: GO 91115
// min_y := y - r ;
91099: LD_ADDR_VAR 0 8
91103: PUSH
91104: LD_VAR 0 3
91108: PUSH
91109: LD_VAR 0 4
91113: MINUS
91114: ST_TO_ADDR
// max_x := x + r ;
91115: LD_ADDR_VAR 0 9
91119: PUSH
91120: LD_VAR 0 2
91124: PUSH
91125: LD_VAR 0 4
91129: PLUS
91130: ST_TO_ADDR
// max_y := y + r ;
91131: LD_ADDR_VAR 0 10
91135: PUSH
91136: LD_VAR 0 3
91140: PUSH
91141: LD_VAR 0 4
91145: PLUS
91146: ST_TO_ADDR
// for _x = min_x to max_x do
91147: LD_ADDR_VAR 0 11
91151: PUSH
91152: DOUBLE
91153: LD_VAR 0 7
91157: DEC
91158: ST_TO_ADDR
91159: LD_VAR 0 9
91163: PUSH
91164: FOR_TO
91165: IFFALSE 91282
// for _y = min_y to max_y do
91167: LD_ADDR_VAR 0 12
91171: PUSH
91172: DOUBLE
91173: LD_VAR 0 8
91177: DEC
91178: ST_TO_ADDR
91179: LD_VAR 0 10
91183: PUSH
91184: FOR_TO
91185: IFFALSE 91278
// begin if not ValidHex ( _x , _y ) then
91187: LD_VAR 0 11
91191: PPUSH
91192: LD_VAR 0 12
91196: PPUSH
91197: CALL_OW 488
91201: NOT
91202: IFFALSE 91206
// continue ;
91204: GO 91184
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91206: LD_VAR 0 11
91210: PPUSH
91211: LD_VAR 0 12
91215: PPUSH
91216: CALL_OW 351
91220: PUSH
91221: LD_VAR 0 11
91225: PPUSH
91226: LD_VAR 0 12
91230: PPUSH
91231: CALL_OW 554
91235: AND
91236: IFFALSE 91276
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91238: LD_ADDR_VAR 0 13
91242: PUSH
91243: LD_VAR 0 13
91247: PPUSH
91248: LD_VAR 0 13
91252: PUSH
91253: LD_INT 1
91255: PLUS
91256: PPUSH
91257: LD_VAR 0 11
91261: PUSH
91262: LD_VAR 0 12
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PPUSH
91271: CALL_OW 2
91275: ST_TO_ADDR
// end ;
91276: GO 91184
91278: POP
91279: POP
91280: GO 91164
91282: POP
91283: POP
// if not list then
91284: LD_VAR 0 13
91288: NOT
91289: IFFALSE 91293
// exit ;
91291: GO 91364
// for i in list do
91293: LD_ADDR_VAR 0 6
91297: PUSH
91298: LD_VAR 0 13
91302: PUSH
91303: FOR_IN
91304: IFFALSE 91362
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91306: LD_VAR 0 1
91310: PPUSH
91311: LD_STRING M
91313: PUSH
91314: LD_VAR 0 6
91318: PUSH
91319: LD_INT 1
91321: ARRAY
91322: PUSH
91323: LD_VAR 0 6
91327: PUSH
91328: LD_INT 2
91330: ARRAY
91331: PUSH
91332: LD_INT 0
91334: PUSH
91335: LD_INT 0
91337: PUSH
91338: LD_INT 0
91340: PUSH
91341: LD_INT 0
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: PUSH
91353: EMPTY
91354: LIST
91355: PPUSH
91356: CALL_OW 447
91360: GO 91303
91362: POP
91363: POP
// end ;
91364: LD_VAR 0 5
91368: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91369: LD_EXP 67
91373: NOT
91374: IFFALSE 91424
91376: GO 91378
91378: DISABLE
// begin initHack := true ;
91379: LD_ADDR_EXP 67
91383: PUSH
91384: LD_INT 1
91386: ST_TO_ADDR
// hackTanks := [ ] ;
91387: LD_ADDR_EXP 68
91391: PUSH
91392: EMPTY
91393: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91394: LD_ADDR_EXP 69
91398: PUSH
91399: EMPTY
91400: ST_TO_ADDR
// hackLimit := 3 ;
91401: LD_ADDR_EXP 70
91405: PUSH
91406: LD_INT 3
91408: ST_TO_ADDR
// hackDist := 12 ;
91409: LD_ADDR_EXP 71
91413: PUSH
91414: LD_INT 12
91416: ST_TO_ADDR
// hackCounter := [ ] ;
91417: LD_ADDR_EXP 72
91421: PUSH
91422: EMPTY
91423: ST_TO_ADDR
// end ;
91424: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91425: LD_EXP 67
91429: PUSH
91430: LD_INT 34
91432: PUSH
91433: LD_INT 99
91435: PUSH
91436: EMPTY
91437: LIST
91438: LIST
91439: PPUSH
91440: CALL_OW 69
91444: AND
91445: IFFALSE 91698
91447: GO 91449
91449: DISABLE
91450: LD_INT 0
91452: PPUSH
91453: PPUSH
// begin enable ;
91454: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91455: LD_ADDR_VAR 0 1
91459: PUSH
91460: LD_INT 34
91462: PUSH
91463: LD_INT 99
91465: PUSH
91466: EMPTY
91467: LIST
91468: LIST
91469: PPUSH
91470: CALL_OW 69
91474: PUSH
91475: FOR_IN
91476: IFFALSE 91696
// begin if not i in hackTanks then
91478: LD_VAR 0 1
91482: PUSH
91483: LD_EXP 68
91487: IN
91488: NOT
91489: IFFALSE 91572
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91491: LD_ADDR_EXP 68
91495: PUSH
91496: LD_EXP 68
91500: PPUSH
91501: LD_EXP 68
91505: PUSH
91506: LD_INT 1
91508: PLUS
91509: PPUSH
91510: LD_VAR 0 1
91514: PPUSH
91515: CALL_OW 1
91519: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91520: LD_ADDR_EXP 69
91524: PUSH
91525: LD_EXP 69
91529: PPUSH
91530: LD_EXP 69
91534: PUSH
91535: LD_INT 1
91537: PLUS
91538: PPUSH
91539: EMPTY
91540: PPUSH
91541: CALL_OW 1
91545: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91546: LD_ADDR_EXP 72
91550: PUSH
91551: LD_EXP 72
91555: PPUSH
91556: LD_EXP 72
91560: PUSH
91561: LD_INT 1
91563: PLUS
91564: PPUSH
91565: EMPTY
91566: PPUSH
91567: CALL_OW 1
91571: ST_TO_ADDR
// end ; if not IsOk ( i ) then
91572: LD_VAR 0 1
91576: PPUSH
91577: CALL_OW 302
91581: NOT
91582: IFFALSE 91595
// begin HackUnlinkAll ( i ) ;
91584: LD_VAR 0 1
91588: PPUSH
91589: CALL 91701 0 1
// continue ;
91593: GO 91475
// end ; HackCheckCapturedStatus ( i ) ;
91595: LD_VAR 0 1
91599: PPUSH
91600: CALL 92144 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
91604: LD_ADDR_VAR 0 2
91608: PUSH
91609: LD_INT 81
91611: PUSH
91612: LD_VAR 0 1
91616: PPUSH
91617: CALL_OW 255
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 33
91628: PUSH
91629: LD_INT 3
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PUSH
91636: LD_INT 91
91638: PUSH
91639: LD_VAR 0 1
91643: PUSH
91644: LD_EXP 71
91648: PUSH
91649: EMPTY
91650: LIST
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 50
91656: PUSH
91657: EMPTY
91658: LIST
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: LIST
91664: LIST
91665: PPUSH
91666: CALL_OW 69
91670: ST_TO_ADDR
// if not tmp then
91671: LD_VAR 0 2
91675: NOT
91676: IFFALSE 91680
// continue ;
91678: GO 91475
// HackLink ( i , tmp ) ;
91680: LD_VAR 0 1
91684: PPUSH
91685: LD_VAR 0 2
91689: PPUSH
91690: CALL 91837 0 2
// end ;
91694: GO 91475
91696: POP
91697: POP
// end ;
91698: PPOPN 2
91700: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
91701: LD_INT 0
91703: PPUSH
91704: PPUSH
91705: PPUSH
// if not hack in hackTanks then
91706: LD_VAR 0 1
91710: PUSH
91711: LD_EXP 68
91715: IN
91716: NOT
91717: IFFALSE 91721
// exit ;
91719: GO 91832
// index := GetElementIndex ( hackTanks , hack ) ;
91721: LD_ADDR_VAR 0 4
91725: PUSH
91726: LD_EXP 68
91730: PPUSH
91731: LD_VAR 0 1
91735: PPUSH
91736: CALL 15937 0 2
91740: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
91741: LD_EXP 69
91745: PUSH
91746: LD_VAR 0 4
91750: ARRAY
91751: IFFALSE 91832
// begin for i in hackTanksCaptured [ index ] do
91753: LD_ADDR_VAR 0 3
91757: PUSH
91758: LD_EXP 69
91762: PUSH
91763: LD_VAR 0 4
91767: ARRAY
91768: PUSH
91769: FOR_IN
91770: IFFALSE 91796
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
91772: LD_VAR 0 3
91776: PUSH
91777: LD_INT 1
91779: ARRAY
91780: PPUSH
91781: LD_VAR 0 3
91785: PUSH
91786: LD_INT 2
91788: ARRAY
91789: PPUSH
91790: CALL_OW 235
91794: GO 91769
91796: POP
91797: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
91798: LD_ADDR_EXP 69
91802: PUSH
91803: LD_EXP 69
91807: PPUSH
91808: LD_VAR 0 4
91812: PPUSH
91813: EMPTY
91814: PPUSH
91815: CALL_OW 1
91819: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
91820: LD_VAR 0 1
91824: PPUSH
91825: LD_INT 0
91827: PPUSH
91828: CALL_OW 505
// end ; end ;
91832: LD_VAR 0 2
91836: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
91837: LD_INT 0
91839: PPUSH
91840: PPUSH
91841: PPUSH
// if not hack in hackTanks or not vehicles then
91842: LD_VAR 0 1
91846: PUSH
91847: LD_EXP 68
91851: IN
91852: NOT
91853: PUSH
91854: LD_VAR 0 2
91858: NOT
91859: OR
91860: IFFALSE 91864
// exit ;
91862: GO 92139
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
91864: LD_ADDR_VAR 0 2
91868: PUSH
91869: LD_VAR 0 1
91873: PPUSH
91874: LD_VAR 0 2
91878: PPUSH
91879: LD_INT 1
91881: PPUSH
91882: LD_INT 1
91884: PPUSH
91885: CALL 16587 0 4
91889: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
91890: LD_ADDR_VAR 0 5
91894: PUSH
91895: LD_EXP 68
91899: PPUSH
91900: LD_VAR 0 1
91904: PPUSH
91905: CALL 15937 0 2
91909: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
91910: LD_EXP 69
91914: PUSH
91915: LD_VAR 0 5
91919: ARRAY
91920: PUSH
91921: LD_EXP 70
91925: LESS
91926: IFFALSE 92115
// begin for i := 1 to vehicles do
91928: LD_ADDR_VAR 0 4
91932: PUSH
91933: DOUBLE
91934: LD_INT 1
91936: DEC
91937: ST_TO_ADDR
91938: LD_VAR 0 2
91942: PUSH
91943: FOR_TO
91944: IFFALSE 92113
// begin if hackTanksCaptured [ index ] = hackLimit then
91946: LD_EXP 69
91950: PUSH
91951: LD_VAR 0 5
91955: ARRAY
91956: PUSH
91957: LD_EXP 70
91961: EQUAL
91962: IFFALSE 91966
// break ;
91964: GO 92113
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
91966: LD_ADDR_EXP 72
91970: PUSH
91971: LD_EXP 72
91975: PPUSH
91976: LD_VAR 0 5
91980: PPUSH
91981: LD_EXP 72
91985: PUSH
91986: LD_VAR 0 5
91990: ARRAY
91991: PUSH
91992: LD_INT 1
91994: PLUS
91995: PPUSH
91996: CALL_OW 1
92000: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
92001: LD_ADDR_EXP 69
92005: PUSH
92006: LD_EXP 69
92010: PPUSH
92011: LD_VAR 0 5
92015: PUSH
92016: LD_EXP 69
92020: PUSH
92021: LD_VAR 0 5
92025: ARRAY
92026: PUSH
92027: LD_INT 1
92029: PLUS
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PPUSH
92035: LD_VAR 0 2
92039: PUSH
92040: LD_VAR 0 4
92044: ARRAY
92045: PUSH
92046: LD_VAR 0 2
92050: PUSH
92051: LD_VAR 0 4
92055: ARRAY
92056: PPUSH
92057: CALL_OW 255
92061: PUSH
92062: EMPTY
92063: LIST
92064: LIST
92065: PPUSH
92066: CALL 16152 0 3
92070: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
92071: LD_VAR 0 2
92075: PUSH
92076: LD_VAR 0 4
92080: ARRAY
92081: PPUSH
92082: LD_VAR 0 1
92086: PPUSH
92087: CALL_OW 255
92091: PPUSH
92092: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
92096: LD_VAR 0 2
92100: PUSH
92101: LD_VAR 0 4
92105: ARRAY
92106: PPUSH
92107: CALL_OW 141
// end ;
92111: GO 91943
92113: POP
92114: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92115: LD_VAR 0 1
92119: PPUSH
92120: LD_EXP 69
92124: PUSH
92125: LD_VAR 0 5
92129: ARRAY
92130: PUSH
92131: LD_INT 0
92133: PLUS
92134: PPUSH
92135: CALL_OW 505
// end ;
92139: LD_VAR 0 3
92143: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92144: LD_INT 0
92146: PPUSH
92147: PPUSH
92148: PPUSH
92149: PPUSH
// if not hack in hackTanks then
92150: LD_VAR 0 1
92154: PUSH
92155: LD_EXP 68
92159: IN
92160: NOT
92161: IFFALSE 92165
// exit ;
92163: GO 92405
// index := GetElementIndex ( hackTanks , hack ) ;
92165: LD_ADDR_VAR 0 4
92169: PUSH
92170: LD_EXP 68
92174: PPUSH
92175: LD_VAR 0 1
92179: PPUSH
92180: CALL 15937 0 2
92184: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92185: LD_ADDR_VAR 0 3
92189: PUSH
92190: DOUBLE
92191: LD_EXP 69
92195: PUSH
92196: LD_VAR 0 4
92200: ARRAY
92201: INC
92202: ST_TO_ADDR
92203: LD_INT 1
92205: PUSH
92206: FOR_DOWNTO
92207: IFFALSE 92379
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92209: LD_ADDR_VAR 0 5
92213: PUSH
92214: LD_EXP 69
92218: PUSH
92219: LD_VAR 0 4
92223: ARRAY
92224: PUSH
92225: LD_VAR 0 3
92229: ARRAY
92230: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92231: LD_VAR 0 5
92235: PUSH
92236: LD_INT 1
92238: ARRAY
92239: PPUSH
92240: CALL_OW 302
92244: NOT
92245: PUSH
92246: LD_VAR 0 5
92250: PUSH
92251: LD_INT 1
92253: ARRAY
92254: PPUSH
92255: CALL_OW 255
92259: PUSH
92260: LD_VAR 0 1
92264: PPUSH
92265: CALL_OW 255
92269: NONEQUAL
92270: OR
92271: IFFALSE 92377
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92273: LD_VAR 0 5
92277: PUSH
92278: LD_INT 1
92280: ARRAY
92281: PPUSH
92282: CALL_OW 305
92286: PUSH
92287: LD_VAR 0 5
92291: PUSH
92292: LD_INT 1
92294: ARRAY
92295: PPUSH
92296: CALL_OW 255
92300: PUSH
92301: LD_VAR 0 1
92305: PPUSH
92306: CALL_OW 255
92310: EQUAL
92311: AND
92312: IFFALSE 92336
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92314: LD_VAR 0 5
92318: PUSH
92319: LD_INT 1
92321: ARRAY
92322: PPUSH
92323: LD_VAR 0 5
92327: PUSH
92328: LD_INT 2
92330: ARRAY
92331: PPUSH
92332: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92336: LD_ADDR_EXP 69
92340: PUSH
92341: LD_EXP 69
92345: PPUSH
92346: LD_VAR 0 4
92350: PPUSH
92351: LD_EXP 69
92355: PUSH
92356: LD_VAR 0 4
92360: ARRAY
92361: PPUSH
92362: LD_VAR 0 3
92366: PPUSH
92367: CALL_OW 3
92371: PPUSH
92372: CALL_OW 1
92376: ST_TO_ADDR
// end ; end ;
92377: GO 92206
92379: POP
92380: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92381: LD_VAR 0 1
92385: PPUSH
92386: LD_EXP 69
92390: PUSH
92391: LD_VAR 0 4
92395: ARRAY
92396: PUSH
92397: LD_INT 0
92399: PLUS
92400: PPUSH
92401: CALL_OW 505
// end ;
92405: LD_VAR 0 2
92409: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92410: LD_INT 0
92412: PPUSH
92413: PPUSH
92414: PPUSH
92415: PPUSH
// if not hack in hackTanks then
92416: LD_VAR 0 1
92420: PUSH
92421: LD_EXP 68
92425: IN
92426: NOT
92427: IFFALSE 92431
// exit ;
92429: GO 92516
// index := GetElementIndex ( hackTanks , hack ) ;
92431: LD_ADDR_VAR 0 5
92435: PUSH
92436: LD_EXP 68
92440: PPUSH
92441: LD_VAR 0 1
92445: PPUSH
92446: CALL 15937 0 2
92450: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92451: LD_ADDR_VAR 0 4
92455: PUSH
92456: DOUBLE
92457: LD_INT 1
92459: DEC
92460: ST_TO_ADDR
92461: LD_EXP 69
92465: PUSH
92466: LD_VAR 0 5
92470: ARRAY
92471: PUSH
92472: FOR_TO
92473: IFFALSE 92514
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92475: LD_EXP 69
92479: PUSH
92480: LD_VAR 0 5
92484: ARRAY
92485: PUSH
92486: LD_VAR 0 4
92490: ARRAY
92491: PUSH
92492: LD_INT 1
92494: ARRAY
92495: PUSH
92496: LD_VAR 0 2
92500: EQUAL
92501: IFFALSE 92512
// KillUnit ( vehicle ) ;
92503: LD_VAR 0 2
92507: PPUSH
92508: CALL_OW 66
92512: GO 92472
92514: POP
92515: POP
// end ;
92516: LD_VAR 0 3
92520: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92521: LD_EXP 73
92525: NOT
92526: IFFALSE 92561
92528: GO 92530
92530: DISABLE
// begin initMiner := true ;
92531: LD_ADDR_EXP 73
92535: PUSH
92536: LD_INT 1
92538: ST_TO_ADDR
// minersList := [ ] ;
92539: LD_ADDR_EXP 74
92543: PUSH
92544: EMPTY
92545: ST_TO_ADDR
// minerMinesList := [ ] ;
92546: LD_ADDR_EXP 75
92550: PUSH
92551: EMPTY
92552: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92553: LD_ADDR_EXP 76
92557: PUSH
92558: LD_INT 5
92560: ST_TO_ADDR
// end ;
92561: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92562: LD_EXP 73
92566: PUSH
92567: LD_INT 34
92569: PUSH
92570: LD_INT 81
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: PPUSH
92577: CALL_OW 69
92581: AND
92582: IFFALSE 93043
92584: GO 92586
92586: DISABLE
92587: LD_INT 0
92589: PPUSH
92590: PPUSH
92591: PPUSH
92592: PPUSH
// begin enable ;
92593: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
92594: LD_ADDR_VAR 0 1
92598: PUSH
92599: LD_INT 34
92601: PUSH
92602: LD_INT 81
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PPUSH
92609: CALL_OW 69
92613: PUSH
92614: FOR_IN
92615: IFFALSE 92687
// begin if not i in minersList then
92617: LD_VAR 0 1
92621: PUSH
92622: LD_EXP 74
92626: IN
92627: NOT
92628: IFFALSE 92685
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
92630: LD_ADDR_EXP 74
92634: PUSH
92635: LD_EXP 74
92639: PPUSH
92640: LD_EXP 74
92644: PUSH
92645: LD_INT 1
92647: PLUS
92648: PPUSH
92649: LD_VAR 0 1
92653: PPUSH
92654: CALL_OW 1
92658: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
92659: LD_ADDR_EXP 75
92663: PUSH
92664: LD_EXP 75
92668: PPUSH
92669: LD_EXP 75
92673: PUSH
92674: LD_INT 1
92676: PLUS
92677: PPUSH
92678: EMPTY
92679: PPUSH
92680: CALL_OW 1
92684: ST_TO_ADDR
// end end ;
92685: GO 92614
92687: POP
92688: POP
// for i := minerMinesList downto 1 do
92689: LD_ADDR_VAR 0 1
92693: PUSH
92694: DOUBLE
92695: LD_EXP 75
92699: INC
92700: ST_TO_ADDR
92701: LD_INT 1
92703: PUSH
92704: FOR_DOWNTO
92705: IFFALSE 93041
// begin if IsLive ( minersList [ i ] ) then
92707: LD_EXP 74
92711: PUSH
92712: LD_VAR 0 1
92716: ARRAY
92717: PPUSH
92718: CALL_OW 300
92722: IFFALSE 92750
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
92724: LD_EXP 74
92728: PUSH
92729: LD_VAR 0 1
92733: ARRAY
92734: PPUSH
92735: LD_EXP 75
92739: PUSH
92740: LD_VAR 0 1
92744: ARRAY
92745: PPUSH
92746: CALL_OW 505
// if not minerMinesList [ i ] then
92750: LD_EXP 75
92754: PUSH
92755: LD_VAR 0 1
92759: ARRAY
92760: NOT
92761: IFFALSE 92765
// continue ;
92763: GO 92704
// for j := minerMinesList [ i ] downto 1 do
92765: LD_ADDR_VAR 0 2
92769: PUSH
92770: DOUBLE
92771: LD_EXP 75
92775: PUSH
92776: LD_VAR 0 1
92780: ARRAY
92781: INC
92782: ST_TO_ADDR
92783: LD_INT 1
92785: PUSH
92786: FOR_DOWNTO
92787: IFFALSE 93037
// begin side := GetSide ( minersList [ i ] ) ;
92789: LD_ADDR_VAR 0 3
92793: PUSH
92794: LD_EXP 74
92798: PUSH
92799: LD_VAR 0 1
92803: ARRAY
92804: PPUSH
92805: CALL_OW 255
92809: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
92810: LD_ADDR_VAR 0 4
92814: PUSH
92815: LD_EXP 75
92819: PUSH
92820: LD_VAR 0 1
92824: ARRAY
92825: PUSH
92826: LD_VAR 0 2
92830: ARRAY
92831: PUSH
92832: LD_INT 1
92834: ARRAY
92835: PPUSH
92836: LD_EXP 75
92840: PUSH
92841: LD_VAR 0 1
92845: ARRAY
92846: PUSH
92847: LD_VAR 0 2
92851: ARRAY
92852: PUSH
92853: LD_INT 2
92855: ARRAY
92856: PPUSH
92857: CALL_OW 428
92861: ST_TO_ADDR
// if not tmp then
92862: LD_VAR 0 4
92866: NOT
92867: IFFALSE 92871
// continue ;
92869: GO 92786
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
92871: LD_VAR 0 4
92875: PUSH
92876: LD_INT 81
92878: PUSH
92879: LD_VAR 0 3
92883: PUSH
92884: EMPTY
92885: LIST
92886: LIST
92887: PPUSH
92888: CALL_OW 69
92892: IN
92893: PUSH
92894: LD_EXP 75
92898: PUSH
92899: LD_VAR 0 1
92903: ARRAY
92904: PUSH
92905: LD_VAR 0 2
92909: ARRAY
92910: PUSH
92911: LD_INT 1
92913: ARRAY
92914: PPUSH
92915: LD_EXP 75
92919: PUSH
92920: LD_VAR 0 1
92924: ARRAY
92925: PUSH
92926: LD_VAR 0 2
92930: ARRAY
92931: PUSH
92932: LD_INT 2
92934: ARRAY
92935: PPUSH
92936: CALL_OW 458
92940: AND
92941: IFFALSE 93035
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
92943: LD_EXP 75
92947: PUSH
92948: LD_VAR 0 1
92952: ARRAY
92953: PUSH
92954: LD_VAR 0 2
92958: ARRAY
92959: PUSH
92960: LD_INT 1
92962: ARRAY
92963: PPUSH
92964: LD_EXP 75
92968: PUSH
92969: LD_VAR 0 1
92973: ARRAY
92974: PUSH
92975: LD_VAR 0 2
92979: ARRAY
92980: PUSH
92981: LD_INT 2
92983: ARRAY
92984: PPUSH
92985: LD_VAR 0 3
92989: PPUSH
92990: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
92994: LD_ADDR_EXP 75
92998: PUSH
92999: LD_EXP 75
93003: PPUSH
93004: LD_VAR 0 1
93008: PPUSH
93009: LD_EXP 75
93013: PUSH
93014: LD_VAR 0 1
93018: ARRAY
93019: PPUSH
93020: LD_VAR 0 2
93024: PPUSH
93025: CALL_OW 3
93029: PPUSH
93030: CALL_OW 1
93034: ST_TO_ADDR
// end ; end ;
93035: GO 92786
93037: POP
93038: POP
// end ;
93039: GO 92704
93041: POP
93042: POP
// end ;
93043: PPOPN 4
93045: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
93046: LD_INT 0
93048: PPUSH
93049: PPUSH
// result := false ;
93050: LD_ADDR_VAR 0 4
93054: PUSH
93055: LD_INT 0
93057: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
93058: LD_VAR 0 1
93062: PPUSH
93063: CALL_OW 264
93067: PUSH
93068: LD_INT 81
93070: EQUAL
93071: NOT
93072: IFFALSE 93076
// exit ;
93074: GO 93316
// index := GetElementIndex ( minersList , unit ) ;
93076: LD_ADDR_VAR 0 5
93080: PUSH
93081: LD_EXP 74
93085: PPUSH
93086: LD_VAR 0 1
93090: PPUSH
93091: CALL 15937 0 2
93095: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
93096: LD_EXP 75
93100: PUSH
93101: LD_VAR 0 5
93105: ARRAY
93106: PUSH
93107: LD_EXP 76
93111: GREATEREQUAL
93112: IFFALSE 93116
// exit ;
93114: GO 93316
// ComMoveXY ( unit , x , y ) ;
93116: LD_VAR 0 1
93120: PPUSH
93121: LD_VAR 0 2
93125: PPUSH
93126: LD_VAR 0 3
93130: PPUSH
93131: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93135: LD_INT 35
93137: PPUSH
93138: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93142: LD_VAR 0 1
93146: PPUSH
93147: LD_VAR 0 2
93151: PPUSH
93152: LD_VAR 0 3
93156: PPUSH
93157: CALL 47273 0 3
93161: NOT
93162: PUSH
93163: LD_VAR 0 1
93167: PPUSH
93168: CALL_OW 314
93172: AND
93173: IFFALSE 93177
// exit ;
93175: GO 93316
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93177: LD_VAR 0 2
93181: PPUSH
93182: LD_VAR 0 3
93186: PPUSH
93187: CALL_OW 428
93191: PUSH
93192: LD_VAR 0 1
93196: EQUAL
93197: PUSH
93198: LD_VAR 0 1
93202: PPUSH
93203: CALL_OW 314
93207: NOT
93208: AND
93209: IFFALSE 93135
// PlaySoundXY ( x , y , PlantMine ) ;
93211: LD_VAR 0 2
93215: PPUSH
93216: LD_VAR 0 3
93220: PPUSH
93221: LD_STRING PlantMine
93223: PPUSH
93224: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93228: LD_VAR 0 2
93232: PPUSH
93233: LD_VAR 0 3
93237: PPUSH
93238: LD_VAR 0 1
93242: PPUSH
93243: CALL_OW 255
93247: PPUSH
93248: LD_INT 0
93250: PPUSH
93251: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93255: LD_ADDR_EXP 75
93259: PUSH
93260: LD_EXP 75
93264: PPUSH
93265: LD_VAR 0 5
93269: PUSH
93270: LD_EXP 75
93274: PUSH
93275: LD_VAR 0 5
93279: ARRAY
93280: PUSH
93281: LD_INT 1
93283: PLUS
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PPUSH
93289: LD_VAR 0 2
93293: PUSH
93294: LD_VAR 0 3
93298: PUSH
93299: EMPTY
93300: LIST
93301: LIST
93302: PPUSH
93303: CALL 16152 0 3
93307: ST_TO_ADDR
// result := true ;
93308: LD_ADDR_VAR 0 4
93312: PUSH
93313: LD_INT 1
93315: ST_TO_ADDR
// end ;
93316: LD_VAR 0 4
93320: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93321: LD_INT 0
93323: PPUSH
93324: PPUSH
93325: PPUSH
// if not unit in minersList then
93326: LD_VAR 0 1
93330: PUSH
93331: LD_EXP 74
93335: IN
93336: NOT
93337: IFFALSE 93341
// exit ;
93339: GO 93733
// index := GetElementIndex ( minersList , unit ) ;
93341: LD_ADDR_VAR 0 6
93345: PUSH
93346: LD_EXP 74
93350: PPUSH
93351: LD_VAR 0 1
93355: PPUSH
93356: CALL 15937 0 2
93360: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93361: LD_ADDR_VAR 0 5
93365: PUSH
93366: DOUBLE
93367: LD_EXP 75
93371: PUSH
93372: LD_VAR 0 6
93376: ARRAY
93377: INC
93378: ST_TO_ADDR
93379: LD_INT 1
93381: PUSH
93382: FOR_DOWNTO
93383: IFFALSE 93544
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93385: LD_EXP 75
93389: PUSH
93390: LD_VAR 0 6
93394: ARRAY
93395: PUSH
93396: LD_VAR 0 5
93400: ARRAY
93401: PUSH
93402: LD_INT 1
93404: ARRAY
93405: PUSH
93406: LD_VAR 0 2
93410: EQUAL
93411: PUSH
93412: LD_EXP 75
93416: PUSH
93417: LD_VAR 0 6
93421: ARRAY
93422: PUSH
93423: LD_VAR 0 5
93427: ARRAY
93428: PUSH
93429: LD_INT 2
93431: ARRAY
93432: PUSH
93433: LD_VAR 0 3
93437: EQUAL
93438: AND
93439: IFFALSE 93542
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93441: LD_EXP 75
93445: PUSH
93446: LD_VAR 0 6
93450: ARRAY
93451: PUSH
93452: LD_VAR 0 5
93456: ARRAY
93457: PUSH
93458: LD_INT 1
93460: ARRAY
93461: PPUSH
93462: LD_EXP 75
93466: PUSH
93467: LD_VAR 0 6
93471: ARRAY
93472: PUSH
93473: LD_VAR 0 5
93477: ARRAY
93478: PUSH
93479: LD_INT 2
93481: ARRAY
93482: PPUSH
93483: LD_VAR 0 1
93487: PPUSH
93488: CALL_OW 255
93492: PPUSH
93493: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93497: LD_ADDR_EXP 75
93501: PUSH
93502: LD_EXP 75
93506: PPUSH
93507: LD_VAR 0 6
93511: PPUSH
93512: LD_EXP 75
93516: PUSH
93517: LD_VAR 0 6
93521: ARRAY
93522: PPUSH
93523: LD_VAR 0 5
93527: PPUSH
93528: CALL_OW 3
93532: PPUSH
93533: CALL_OW 1
93537: ST_TO_ADDR
// exit ;
93538: POP
93539: POP
93540: GO 93733
// end ; end ;
93542: GO 93382
93544: POP
93545: POP
// for i := minerMinesList [ index ] downto 1 do
93546: LD_ADDR_VAR 0 5
93550: PUSH
93551: DOUBLE
93552: LD_EXP 75
93556: PUSH
93557: LD_VAR 0 6
93561: ARRAY
93562: INC
93563: ST_TO_ADDR
93564: LD_INT 1
93566: PUSH
93567: FOR_DOWNTO
93568: IFFALSE 93731
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93570: LD_EXP 75
93574: PUSH
93575: LD_VAR 0 6
93579: ARRAY
93580: PUSH
93581: LD_VAR 0 5
93585: ARRAY
93586: PUSH
93587: LD_INT 1
93589: ARRAY
93590: PPUSH
93591: LD_EXP 75
93595: PUSH
93596: LD_VAR 0 6
93600: ARRAY
93601: PUSH
93602: LD_VAR 0 5
93606: ARRAY
93607: PUSH
93608: LD_INT 2
93610: ARRAY
93611: PPUSH
93612: LD_VAR 0 2
93616: PPUSH
93617: LD_VAR 0 3
93621: PPUSH
93622: CALL_OW 298
93626: PUSH
93627: LD_INT 6
93629: LESS
93630: IFFALSE 93729
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93632: LD_EXP 75
93636: PUSH
93637: LD_VAR 0 6
93641: ARRAY
93642: PUSH
93643: LD_VAR 0 5
93647: ARRAY
93648: PUSH
93649: LD_INT 1
93651: ARRAY
93652: PPUSH
93653: LD_EXP 75
93657: PUSH
93658: LD_VAR 0 6
93662: ARRAY
93663: PUSH
93664: LD_VAR 0 5
93668: ARRAY
93669: PUSH
93670: LD_INT 2
93672: ARRAY
93673: PPUSH
93674: LD_VAR 0 1
93678: PPUSH
93679: CALL_OW 255
93683: PPUSH
93684: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93688: LD_ADDR_EXP 75
93692: PUSH
93693: LD_EXP 75
93697: PPUSH
93698: LD_VAR 0 6
93702: PPUSH
93703: LD_EXP 75
93707: PUSH
93708: LD_VAR 0 6
93712: ARRAY
93713: PPUSH
93714: LD_VAR 0 5
93718: PPUSH
93719: CALL_OW 3
93723: PPUSH
93724: CALL_OW 1
93728: ST_TO_ADDR
// end ; end ;
93729: GO 93567
93731: POP
93732: POP
// end ;
93733: LD_VAR 0 4
93737: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
93738: LD_INT 0
93740: PPUSH
93741: PPUSH
93742: PPUSH
93743: PPUSH
93744: PPUSH
93745: PPUSH
93746: PPUSH
93747: PPUSH
93748: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
93749: LD_VAR 0 1
93753: PPUSH
93754: CALL_OW 264
93758: PUSH
93759: LD_INT 81
93761: EQUAL
93762: NOT
93763: PUSH
93764: LD_VAR 0 1
93768: PUSH
93769: LD_EXP 74
93773: IN
93774: NOT
93775: OR
93776: IFFALSE 93780
// exit ;
93778: GO 94102
// index := GetElementIndex ( minersList , unit ) ;
93780: LD_ADDR_VAR 0 6
93784: PUSH
93785: LD_EXP 74
93789: PPUSH
93790: LD_VAR 0 1
93794: PPUSH
93795: CALL 15937 0 2
93799: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
93800: LD_ADDR_VAR 0 8
93804: PUSH
93805: LD_EXP 76
93809: PUSH
93810: LD_EXP 75
93814: PUSH
93815: LD_VAR 0 6
93819: ARRAY
93820: MINUS
93821: ST_TO_ADDR
// if not minesFreeAmount then
93822: LD_VAR 0 8
93826: NOT
93827: IFFALSE 93831
// exit ;
93829: GO 94102
// tmp := [ ] ;
93831: LD_ADDR_VAR 0 7
93835: PUSH
93836: EMPTY
93837: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
93838: LD_ADDR_VAR 0 5
93842: PUSH
93843: DOUBLE
93844: LD_INT 1
93846: DEC
93847: ST_TO_ADDR
93848: LD_VAR 0 8
93852: PUSH
93853: FOR_TO
93854: IFFALSE 94049
// begin _d := rand ( 0 , 5 ) ;
93856: LD_ADDR_VAR 0 11
93860: PUSH
93861: LD_INT 0
93863: PPUSH
93864: LD_INT 5
93866: PPUSH
93867: CALL_OW 12
93871: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
93872: LD_ADDR_VAR 0 12
93876: PUSH
93877: LD_INT 2
93879: PPUSH
93880: LD_INT 6
93882: PPUSH
93883: CALL_OW 12
93887: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
93888: LD_ADDR_VAR 0 9
93892: PUSH
93893: LD_VAR 0 2
93897: PPUSH
93898: LD_VAR 0 11
93902: PPUSH
93903: LD_VAR 0 12
93907: PPUSH
93908: CALL_OW 272
93912: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
93913: LD_ADDR_VAR 0 10
93917: PUSH
93918: LD_VAR 0 3
93922: PPUSH
93923: LD_VAR 0 11
93927: PPUSH
93928: LD_VAR 0 12
93932: PPUSH
93933: CALL_OW 273
93937: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
93938: LD_VAR 0 9
93942: PPUSH
93943: LD_VAR 0 10
93947: PPUSH
93948: CALL_OW 488
93952: PUSH
93953: LD_VAR 0 9
93957: PUSH
93958: LD_VAR 0 10
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: PUSH
93967: LD_VAR 0 7
93971: IN
93972: NOT
93973: AND
93974: PUSH
93975: LD_VAR 0 9
93979: PPUSH
93980: LD_VAR 0 10
93984: PPUSH
93985: CALL_OW 458
93989: NOT
93990: AND
93991: IFFALSE 94033
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
93993: LD_ADDR_VAR 0 7
93997: PUSH
93998: LD_VAR 0 7
94002: PPUSH
94003: LD_VAR 0 7
94007: PUSH
94008: LD_INT 1
94010: PLUS
94011: PPUSH
94012: LD_VAR 0 9
94016: PUSH
94017: LD_VAR 0 10
94021: PUSH
94022: EMPTY
94023: LIST
94024: LIST
94025: PPUSH
94026: CALL_OW 1
94030: ST_TO_ADDR
94031: GO 94047
// i := i - 1 ;
94033: LD_ADDR_VAR 0 5
94037: PUSH
94038: LD_VAR 0 5
94042: PUSH
94043: LD_INT 1
94045: MINUS
94046: ST_TO_ADDR
// end ;
94047: GO 93853
94049: POP
94050: POP
// for i in tmp do
94051: LD_ADDR_VAR 0 5
94055: PUSH
94056: LD_VAR 0 7
94060: PUSH
94061: FOR_IN
94062: IFFALSE 94100
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
94064: LD_VAR 0 1
94068: PPUSH
94069: LD_VAR 0 5
94073: PUSH
94074: LD_INT 1
94076: ARRAY
94077: PPUSH
94078: LD_VAR 0 5
94082: PUSH
94083: LD_INT 2
94085: ARRAY
94086: PPUSH
94087: CALL 93046 0 3
94091: NOT
94092: IFFALSE 94098
// exit ;
94094: POP
94095: POP
94096: GO 94102
94098: GO 94061
94100: POP
94101: POP
// end ;
94102: LD_VAR 0 4
94106: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
94107: LD_INT 0
94109: PPUSH
94110: PPUSH
94111: PPUSH
94112: PPUSH
94113: PPUSH
94114: PPUSH
94115: PPUSH
// if not GetClass ( unit ) = class_sniper then
94116: LD_VAR 0 1
94120: PPUSH
94121: CALL_OW 257
94125: PUSH
94126: LD_INT 5
94128: EQUAL
94129: NOT
94130: IFFALSE 94134
// exit ;
94132: GO 94522
// dist := 8 ;
94134: LD_ADDR_VAR 0 5
94138: PUSH
94139: LD_INT 8
94141: ST_TO_ADDR
// viewRange := 12 ;
94142: LD_ADDR_VAR 0 7
94146: PUSH
94147: LD_INT 12
94149: ST_TO_ADDR
// side := GetSide ( unit ) ;
94150: LD_ADDR_VAR 0 6
94154: PUSH
94155: LD_VAR 0 1
94159: PPUSH
94160: CALL_OW 255
94164: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94165: LD_INT 61
94167: PPUSH
94168: LD_VAR 0 6
94172: PPUSH
94173: CALL_OW 321
94177: PUSH
94178: LD_INT 2
94180: EQUAL
94181: IFFALSE 94191
// viewRange := 16 ;
94183: LD_ADDR_VAR 0 7
94187: PUSH
94188: LD_INT 16
94190: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94191: LD_VAR 0 1
94195: PPUSH
94196: LD_VAR 0 2
94200: PPUSH
94201: LD_VAR 0 3
94205: PPUSH
94206: CALL_OW 297
94210: PUSH
94211: LD_VAR 0 5
94215: GREATER
94216: IFFALSE 94295
// begin ComMoveXY ( unit , x , y ) ;
94218: LD_VAR 0 1
94222: PPUSH
94223: LD_VAR 0 2
94227: PPUSH
94228: LD_VAR 0 3
94232: PPUSH
94233: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94237: LD_INT 35
94239: PPUSH
94240: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94244: LD_VAR 0 1
94248: PPUSH
94249: LD_VAR 0 2
94253: PPUSH
94254: LD_VAR 0 3
94258: PPUSH
94259: CALL 47273 0 3
94263: NOT
94264: IFFALSE 94268
// exit ;
94266: GO 94522
// until GetDistUnitXY ( unit , x , y ) < dist ;
94268: LD_VAR 0 1
94272: PPUSH
94273: LD_VAR 0 2
94277: PPUSH
94278: LD_VAR 0 3
94282: PPUSH
94283: CALL_OW 297
94287: PUSH
94288: LD_VAR 0 5
94292: LESS
94293: IFFALSE 94237
// end ; ComTurnXY ( unit , x , y ) ;
94295: LD_VAR 0 1
94299: PPUSH
94300: LD_VAR 0 2
94304: PPUSH
94305: LD_VAR 0 3
94309: PPUSH
94310: CALL_OW 118
// wait ( 5 ) ;
94314: LD_INT 5
94316: PPUSH
94317: CALL_OW 67
// _d := GetDir ( unit ) ;
94321: LD_ADDR_VAR 0 10
94325: PUSH
94326: LD_VAR 0 1
94330: PPUSH
94331: CALL_OW 254
94335: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94336: LD_ADDR_VAR 0 8
94340: PUSH
94341: LD_VAR 0 1
94345: PPUSH
94346: CALL_OW 250
94350: PPUSH
94351: LD_VAR 0 10
94355: PPUSH
94356: LD_VAR 0 5
94360: PPUSH
94361: CALL_OW 272
94365: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94366: LD_ADDR_VAR 0 9
94370: PUSH
94371: LD_VAR 0 1
94375: PPUSH
94376: CALL_OW 251
94380: PPUSH
94381: LD_VAR 0 10
94385: PPUSH
94386: LD_VAR 0 5
94390: PPUSH
94391: CALL_OW 273
94395: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94396: LD_VAR 0 8
94400: PPUSH
94401: LD_VAR 0 9
94405: PPUSH
94406: CALL_OW 488
94410: NOT
94411: IFFALSE 94415
// exit ;
94413: GO 94522
// ComAnimCustom ( unit , 1 ) ;
94415: LD_VAR 0 1
94419: PPUSH
94420: LD_INT 1
94422: PPUSH
94423: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94427: LD_VAR 0 8
94431: PPUSH
94432: LD_VAR 0 9
94436: PPUSH
94437: LD_VAR 0 6
94441: PPUSH
94442: LD_VAR 0 7
94446: PPUSH
94447: CALL_OW 330
// repeat wait ( 1 ) ;
94451: LD_INT 1
94453: PPUSH
94454: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94458: LD_VAR 0 1
94462: PPUSH
94463: CALL_OW 316
94467: PUSH
94468: LD_VAR 0 1
94472: PPUSH
94473: CALL_OW 314
94477: OR
94478: PUSH
94479: LD_VAR 0 1
94483: PPUSH
94484: CALL_OW 302
94488: NOT
94489: OR
94490: PUSH
94491: LD_VAR 0 1
94495: PPUSH
94496: CALL_OW 301
94500: OR
94501: IFFALSE 94451
// RemoveSeeing ( _x , _y , side ) ;
94503: LD_VAR 0 8
94507: PPUSH
94508: LD_VAR 0 9
94512: PPUSH
94513: LD_VAR 0 6
94517: PPUSH
94518: CALL_OW 331
// end ; end_of_file end_of_file
94522: LD_VAR 0 4
94526: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94527: LD_VAR 0 1
94531: PUSH
94532: LD_INT 200
94534: DOUBLE
94535: GREATEREQUAL
94536: IFFALSE 94544
94538: LD_INT 299
94540: DOUBLE
94541: LESSEQUAL
94542: IFTRUE 94546
94544: GO 94578
94546: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94547: LD_VAR 0 1
94551: PPUSH
94552: LD_VAR 0 2
94556: PPUSH
94557: LD_VAR 0 3
94561: PPUSH
94562: LD_VAR 0 4
94566: PPUSH
94567: LD_VAR 0 5
94571: PPUSH
94572: CALL 90614 0 5
94576: GO 94655
94578: LD_INT 300
94580: DOUBLE
94581: GREATEREQUAL
94582: IFFALSE 94590
94584: LD_INT 399
94586: DOUBLE
94587: LESSEQUAL
94588: IFTRUE 94592
94590: GO 94654
94592: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
94593: LD_VAR 0 1
94597: PPUSH
94598: LD_VAR 0 2
94602: PPUSH
94603: LD_VAR 0 3
94607: PPUSH
94608: LD_VAR 0 4
94612: PPUSH
94613: LD_VAR 0 5
94617: PPUSH
94618: LD_VAR 0 6
94622: PPUSH
94623: LD_VAR 0 7
94627: PPUSH
94628: LD_VAR 0 8
94632: PPUSH
94633: LD_VAR 0 9
94637: PPUSH
94638: LD_VAR 0 10
94642: PPUSH
94643: LD_VAR 0 11
94647: PPUSH
94648: CALL 107048 0 11
94652: GO 94655
94654: POP
// end ;
94655: PPOPN 11
94657: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
94658: LD_VAR 0 1
94662: PPUSH
94663: LD_VAR 0 2
94667: PPUSH
94668: LD_VAR 0 3
94672: PPUSH
94673: LD_VAR 0 4
94677: PPUSH
94678: LD_VAR 0 5
94682: PPUSH
94683: CALL 90350 0 5
// end ; end_of_file
94687: PPOPN 5
94689: END
// every 0 0$1 do
94690: GO 94692
94692: DISABLE
// begin enable ;
94693: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94694: LD_STRING updateTimer(
94696: PUSH
94697: LD_OWVAR 1
94701: STR
94702: PUSH
94703: LD_STRING );
94705: STR
94706: PPUSH
94707: CALL_OW 559
// end ;
94711: END
// export function SOS_MapStart ( ) ; begin
94712: LD_INT 0
94714: PPUSH
// if streamModeActive then
94715: LD_EXP 77
94719: IFFALSE 94728
// DefineStreamItems ( true ) ;
94721: LD_INT 1
94723: PPUSH
94724: CALL 96382 0 1
// UpdateFactoryWaypoints ( ) ;
94728: CALL 109243 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94732: CALL 109500 0 0
// end ;
94736: LD_VAR 0 1
94740: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94741: LD_INT 0
94743: PPUSH
// if p2 = 100 then
94744: LD_VAR 0 2
94748: PUSH
94749: LD_INT 100
94751: EQUAL
94752: IFFALSE 95755
// begin if not StreamModeActive then
94754: LD_EXP 77
94758: NOT
94759: IFFALSE 94769
// StreamModeActive := true ;
94761: LD_ADDR_EXP 77
94765: PUSH
94766: LD_INT 1
94768: ST_TO_ADDR
// if p3 = 0 then
94769: LD_VAR 0 3
94773: PUSH
94774: LD_INT 0
94776: EQUAL
94777: IFFALSE 94783
// InitStreamMode ;
94779: CALL 95918 0 0
// if p3 = 1 then
94783: LD_VAR 0 3
94787: PUSH
94788: LD_INT 1
94790: EQUAL
94791: IFFALSE 94801
// sRocket := true ;
94793: LD_ADDR_EXP 82
94797: PUSH
94798: LD_INT 1
94800: ST_TO_ADDR
// if p3 = 2 then
94801: LD_VAR 0 3
94805: PUSH
94806: LD_INT 2
94808: EQUAL
94809: IFFALSE 94819
// sSpeed := true ;
94811: LD_ADDR_EXP 81
94815: PUSH
94816: LD_INT 1
94818: ST_TO_ADDR
// if p3 = 3 then
94819: LD_VAR 0 3
94823: PUSH
94824: LD_INT 3
94826: EQUAL
94827: IFFALSE 94837
// sEngine := true ;
94829: LD_ADDR_EXP 83
94833: PUSH
94834: LD_INT 1
94836: ST_TO_ADDR
// if p3 = 4 then
94837: LD_VAR 0 3
94841: PUSH
94842: LD_INT 4
94844: EQUAL
94845: IFFALSE 94855
// sSpec := true ;
94847: LD_ADDR_EXP 80
94851: PUSH
94852: LD_INT 1
94854: ST_TO_ADDR
// if p3 = 5 then
94855: LD_VAR 0 3
94859: PUSH
94860: LD_INT 5
94862: EQUAL
94863: IFFALSE 94873
// sLevel := true ;
94865: LD_ADDR_EXP 84
94869: PUSH
94870: LD_INT 1
94872: ST_TO_ADDR
// if p3 = 6 then
94873: LD_VAR 0 3
94877: PUSH
94878: LD_INT 6
94880: EQUAL
94881: IFFALSE 94891
// sArmoury := true ;
94883: LD_ADDR_EXP 85
94887: PUSH
94888: LD_INT 1
94890: ST_TO_ADDR
// if p3 = 7 then
94891: LD_VAR 0 3
94895: PUSH
94896: LD_INT 7
94898: EQUAL
94899: IFFALSE 94909
// sRadar := true ;
94901: LD_ADDR_EXP 86
94905: PUSH
94906: LD_INT 1
94908: ST_TO_ADDR
// if p3 = 8 then
94909: LD_VAR 0 3
94913: PUSH
94914: LD_INT 8
94916: EQUAL
94917: IFFALSE 94927
// sBunker := true ;
94919: LD_ADDR_EXP 87
94923: PUSH
94924: LD_INT 1
94926: ST_TO_ADDR
// if p3 = 9 then
94927: LD_VAR 0 3
94931: PUSH
94932: LD_INT 9
94934: EQUAL
94935: IFFALSE 94945
// sHack := true ;
94937: LD_ADDR_EXP 88
94941: PUSH
94942: LD_INT 1
94944: ST_TO_ADDR
// if p3 = 10 then
94945: LD_VAR 0 3
94949: PUSH
94950: LD_INT 10
94952: EQUAL
94953: IFFALSE 94963
// sFire := true ;
94955: LD_ADDR_EXP 89
94959: PUSH
94960: LD_INT 1
94962: ST_TO_ADDR
// if p3 = 11 then
94963: LD_VAR 0 3
94967: PUSH
94968: LD_INT 11
94970: EQUAL
94971: IFFALSE 94981
// sRefresh := true ;
94973: LD_ADDR_EXP 90
94977: PUSH
94978: LD_INT 1
94980: ST_TO_ADDR
// if p3 = 12 then
94981: LD_VAR 0 3
94985: PUSH
94986: LD_INT 12
94988: EQUAL
94989: IFFALSE 94999
// sExp := true ;
94991: LD_ADDR_EXP 91
94995: PUSH
94996: LD_INT 1
94998: ST_TO_ADDR
// if p3 = 13 then
94999: LD_VAR 0 3
95003: PUSH
95004: LD_INT 13
95006: EQUAL
95007: IFFALSE 95017
// sDepot := true ;
95009: LD_ADDR_EXP 92
95013: PUSH
95014: LD_INT 1
95016: ST_TO_ADDR
// if p3 = 14 then
95017: LD_VAR 0 3
95021: PUSH
95022: LD_INT 14
95024: EQUAL
95025: IFFALSE 95035
// sFlag := true ;
95027: LD_ADDR_EXP 93
95031: PUSH
95032: LD_INT 1
95034: ST_TO_ADDR
// if p3 = 15 then
95035: LD_VAR 0 3
95039: PUSH
95040: LD_INT 15
95042: EQUAL
95043: IFFALSE 95053
// sKamikadze := true ;
95045: LD_ADDR_EXP 101
95049: PUSH
95050: LD_INT 1
95052: ST_TO_ADDR
// if p3 = 16 then
95053: LD_VAR 0 3
95057: PUSH
95058: LD_INT 16
95060: EQUAL
95061: IFFALSE 95071
// sTroll := true ;
95063: LD_ADDR_EXP 102
95067: PUSH
95068: LD_INT 1
95070: ST_TO_ADDR
// if p3 = 17 then
95071: LD_VAR 0 3
95075: PUSH
95076: LD_INT 17
95078: EQUAL
95079: IFFALSE 95089
// sSlow := true ;
95081: LD_ADDR_EXP 103
95085: PUSH
95086: LD_INT 1
95088: ST_TO_ADDR
// if p3 = 18 then
95089: LD_VAR 0 3
95093: PUSH
95094: LD_INT 18
95096: EQUAL
95097: IFFALSE 95107
// sLack := true ;
95099: LD_ADDR_EXP 104
95103: PUSH
95104: LD_INT 1
95106: ST_TO_ADDR
// if p3 = 19 then
95107: LD_VAR 0 3
95111: PUSH
95112: LD_INT 19
95114: EQUAL
95115: IFFALSE 95125
// sTank := true ;
95117: LD_ADDR_EXP 106
95121: PUSH
95122: LD_INT 1
95124: ST_TO_ADDR
// if p3 = 20 then
95125: LD_VAR 0 3
95129: PUSH
95130: LD_INT 20
95132: EQUAL
95133: IFFALSE 95143
// sRemote := true ;
95135: LD_ADDR_EXP 107
95139: PUSH
95140: LD_INT 1
95142: ST_TO_ADDR
// if p3 = 21 then
95143: LD_VAR 0 3
95147: PUSH
95148: LD_INT 21
95150: EQUAL
95151: IFFALSE 95161
// sPowell := true ;
95153: LD_ADDR_EXP 108
95157: PUSH
95158: LD_INT 1
95160: ST_TO_ADDR
// if p3 = 22 then
95161: LD_VAR 0 3
95165: PUSH
95166: LD_INT 22
95168: EQUAL
95169: IFFALSE 95179
// sTeleport := true ;
95171: LD_ADDR_EXP 111
95175: PUSH
95176: LD_INT 1
95178: ST_TO_ADDR
// if p3 = 23 then
95179: LD_VAR 0 3
95183: PUSH
95184: LD_INT 23
95186: EQUAL
95187: IFFALSE 95197
// sOilTower := true ;
95189: LD_ADDR_EXP 113
95193: PUSH
95194: LD_INT 1
95196: ST_TO_ADDR
// if p3 = 24 then
95197: LD_VAR 0 3
95201: PUSH
95202: LD_INT 24
95204: EQUAL
95205: IFFALSE 95215
// sShovel := true ;
95207: LD_ADDR_EXP 114
95211: PUSH
95212: LD_INT 1
95214: ST_TO_ADDR
// if p3 = 25 then
95215: LD_VAR 0 3
95219: PUSH
95220: LD_INT 25
95222: EQUAL
95223: IFFALSE 95233
// sSheik := true ;
95225: LD_ADDR_EXP 115
95229: PUSH
95230: LD_INT 1
95232: ST_TO_ADDR
// if p3 = 26 then
95233: LD_VAR 0 3
95237: PUSH
95238: LD_INT 26
95240: EQUAL
95241: IFFALSE 95251
// sEarthquake := true ;
95243: LD_ADDR_EXP 117
95247: PUSH
95248: LD_INT 1
95250: ST_TO_ADDR
// if p3 = 27 then
95251: LD_VAR 0 3
95255: PUSH
95256: LD_INT 27
95258: EQUAL
95259: IFFALSE 95269
// sAI := true ;
95261: LD_ADDR_EXP 118
95265: PUSH
95266: LD_INT 1
95268: ST_TO_ADDR
// if p3 = 28 then
95269: LD_VAR 0 3
95273: PUSH
95274: LD_INT 28
95276: EQUAL
95277: IFFALSE 95287
// sCargo := true ;
95279: LD_ADDR_EXP 121
95283: PUSH
95284: LD_INT 1
95286: ST_TO_ADDR
// if p3 = 29 then
95287: LD_VAR 0 3
95291: PUSH
95292: LD_INT 29
95294: EQUAL
95295: IFFALSE 95305
// sDLaser := true ;
95297: LD_ADDR_EXP 122
95301: PUSH
95302: LD_INT 1
95304: ST_TO_ADDR
// if p3 = 30 then
95305: LD_VAR 0 3
95309: PUSH
95310: LD_INT 30
95312: EQUAL
95313: IFFALSE 95323
// sExchange := true ;
95315: LD_ADDR_EXP 123
95319: PUSH
95320: LD_INT 1
95322: ST_TO_ADDR
// if p3 = 31 then
95323: LD_VAR 0 3
95327: PUSH
95328: LD_INT 31
95330: EQUAL
95331: IFFALSE 95341
// sFac := true ;
95333: LD_ADDR_EXP 124
95337: PUSH
95338: LD_INT 1
95340: ST_TO_ADDR
// if p3 = 32 then
95341: LD_VAR 0 3
95345: PUSH
95346: LD_INT 32
95348: EQUAL
95349: IFFALSE 95359
// sPower := true ;
95351: LD_ADDR_EXP 125
95355: PUSH
95356: LD_INT 1
95358: ST_TO_ADDR
// if p3 = 33 then
95359: LD_VAR 0 3
95363: PUSH
95364: LD_INT 33
95366: EQUAL
95367: IFFALSE 95377
// sRandom := true ;
95369: LD_ADDR_EXP 126
95373: PUSH
95374: LD_INT 1
95376: ST_TO_ADDR
// if p3 = 34 then
95377: LD_VAR 0 3
95381: PUSH
95382: LD_INT 34
95384: EQUAL
95385: IFFALSE 95395
// sShield := true ;
95387: LD_ADDR_EXP 127
95391: PUSH
95392: LD_INT 1
95394: ST_TO_ADDR
// if p3 = 35 then
95395: LD_VAR 0 3
95399: PUSH
95400: LD_INT 35
95402: EQUAL
95403: IFFALSE 95413
// sTime := true ;
95405: LD_ADDR_EXP 128
95409: PUSH
95410: LD_INT 1
95412: ST_TO_ADDR
// if p3 = 36 then
95413: LD_VAR 0 3
95417: PUSH
95418: LD_INT 36
95420: EQUAL
95421: IFFALSE 95431
// sTools := true ;
95423: LD_ADDR_EXP 129
95427: PUSH
95428: LD_INT 1
95430: ST_TO_ADDR
// if p3 = 101 then
95431: LD_VAR 0 3
95435: PUSH
95436: LD_INT 101
95438: EQUAL
95439: IFFALSE 95449
// sSold := true ;
95441: LD_ADDR_EXP 94
95445: PUSH
95446: LD_INT 1
95448: ST_TO_ADDR
// if p3 = 102 then
95449: LD_VAR 0 3
95453: PUSH
95454: LD_INT 102
95456: EQUAL
95457: IFFALSE 95467
// sDiff := true ;
95459: LD_ADDR_EXP 95
95463: PUSH
95464: LD_INT 1
95466: ST_TO_ADDR
// if p3 = 103 then
95467: LD_VAR 0 3
95471: PUSH
95472: LD_INT 103
95474: EQUAL
95475: IFFALSE 95485
// sFog := true ;
95477: LD_ADDR_EXP 98
95481: PUSH
95482: LD_INT 1
95484: ST_TO_ADDR
// if p3 = 104 then
95485: LD_VAR 0 3
95489: PUSH
95490: LD_INT 104
95492: EQUAL
95493: IFFALSE 95503
// sReset := true ;
95495: LD_ADDR_EXP 99
95499: PUSH
95500: LD_INT 1
95502: ST_TO_ADDR
// if p3 = 105 then
95503: LD_VAR 0 3
95507: PUSH
95508: LD_INT 105
95510: EQUAL
95511: IFFALSE 95521
// sSun := true ;
95513: LD_ADDR_EXP 100
95517: PUSH
95518: LD_INT 1
95520: ST_TO_ADDR
// if p3 = 106 then
95521: LD_VAR 0 3
95525: PUSH
95526: LD_INT 106
95528: EQUAL
95529: IFFALSE 95539
// sTiger := true ;
95531: LD_ADDR_EXP 96
95535: PUSH
95536: LD_INT 1
95538: ST_TO_ADDR
// if p3 = 107 then
95539: LD_VAR 0 3
95543: PUSH
95544: LD_INT 107
95546: EQUAL
95547: IFFALSE 95557
// sBomb := true ;
95549: LD_ADDR_EXP 97
95553: PUSH
95554: LD_INT 1
95556: ST_TO_ADDR
// if p3 = 108 then
95557: LD_VAR 0 3
95561: PUSH
95562: LD_INT 108
95564: EQUAL
95565: IFFALSE 95575
// sWound := true ;
95567: LD_ADDR_EXP 105
95571: PUSH
95572: LD_INT 1
95574: ST_TO_ADDR
// if p3 = 109 then
95575: LD_VAR 0 3
95579: PUSH
95580: LD_INT 109
95582: EQUAL
95583: IFFALSE 95593
// sBetray := true ;
95585: LD_ADDR_EXP 109
95589: PUSH
95590: LD_INT 1
95592: ST_TO_ADDR
// if p3 = 110 then
95593: LD_VAR 0 3
95597: PUSH
95598: LD_INT 110
95600: EQUAL
95601: IFFALSE 95611
// sContamin := true ;
95603: LD_ADDR_EXP 110
95607: PUSH
95608: LD_INT 1
95610: ST_TO_ADDR
// if p3 = 111 then
95611: LD_VAR 0 3
95615: PUSH
95616: LD_INT 111
95618: EQUAL
95619: IFFALSE 95629
// sOil := true ;
95621: LD_ADDR_EXP 112
95625: PUSH
95626: LD_INT 1
95628: ST_TO_ADDR
// if p3 = 112 then
95629: LD_VAR 0 3
95633: PUSH
95634: LD_INT 112
95636: EQUAL
95637: IFFALSE 95647
// sStu := true ;
95639: LD_ADDR_EXP 116
95643: PUSH
95644: LD_INT 1
95646: ST_TO_ADDR
// if p3 = 113 then
95647: LD_VAR 0 3
95651: PUSH
95652: LD_INT 113
95654: EQUAL
95655: IFFALSE 95665
// sBazooka := true ;
95657: LD_ADDR_EXP 119
95661: PUSH
95662: LD_INT 1
95664: ST_TO_ADDR
// if p3 = 114 then
95665: LD_VAR 0 3
95669: PUSH
95670: LD_INT 114
95672: EQUAL
95673: IFFALSE 95683
// sMortar := true ;
95675: LD_ADDR_EXP 120
95679: PUSH
95680: LD_INT 1
95682: ST_TO_ADDR
// if p3 = 115 then
95683: LD_VAR 0 3
95687: PUSH
95688: LD_INT 115
95690: EQUAL
95691: IFFALSE 95701
// sRanger := true ;
95693: LD_ADDR_EXP 130
95697: PUSH
95698: LD_INT 1
95700: ST_TO_ADDR
// if p3 = 116 then
95701: LD_VAR 0 3
95705: PUSH
95706: LD_INT 116
95708: EQUAL
95709: IFFALSE 95719
// sComputer := true ;
95711: LD_ADDR_EXP 131
95715: PUSH
95716: LD_INT 1
95718: ST_TO_ADDR
// if p3 = 117 then
95719: LD_VAR 0 3
95723: PUSH
95724: LD_INT 117
95726: EQUAL
95727: IFFALSE 95737
// s30 := true ;
95729: LD_ADDR_EXP 132
95733: PUSH
95734: LD_INT 1
95736: ST_TO_ADDR
// if p3 = 118 then
95737: LD_VAR 0 3
95741: PUSH
95742: LD_INT 118
95744: EQUAL
95745: IFFALSE 95755
// s60 := true ;
95747: LD_ADDR_EXP 133
95751: PUSH
95752: LD_INT 1
95754: ST_TO_ADDR
// end ; if p2 = 101 then
95755: LD_VAR 0 2
95759: PUSH
95760: LD_INT 101
95762: EQUAL
95763: IFFALSE 95891
// begin case p3 of 1 :
95765: LD_VAR 0 3
95769: PUSH
95770: LD_INT 1
95772: DOUBLE
95773: EQUAL
95774: IFTRUE 95778
95776: GO 95785
95778: POP
// hHackUnlimitedResources ; 2 :
95779: CALL 107989 0 0
95783: GO 95891
95785: LD_INT 2
95787: DOUBLE
95788: EQUAL
95789: IFTRUE 95793
95791: GO 95800
95793: POP
// hHackSetLevel10 ; 3 :
95794: CALL 108122 0 0
95798: GO 95891
95800: LD_INT 3
95802: DOUBLE
95803: EQUAL
95804: IFTRUE 95808
95806: GO 95815
95808: POP
// hHackSetLevel10YourUnits ; 4 :
95809: CALL 108207 0 0
95813: GO 95891
95815: LD_INT 4
95817: DOUBLE
95818: EQUAL
95819: IFTRUE 95823
95821: GO 95830
95823: POP
// hHackInvincible ; 5 :
95824: CALL 108655 0 0
95828: GO 95891
95830: LD_INT 5
95832: DOUBLE
95833: EQUAL
95834: IFTRUE 95838
95836: GO 95845
95838: POP
// hHackInvisible ; 6 :
95839: CALL 108766 0 0
95843: GO 95891
95845: LD_INT 6
95847: DOUBLE
95848: EQUAL
95849: IFTRUE 95853
95851: GO 95860
95853: POP
// hHackChangeYourSide ; 7 :
95854: CALL 108823 0 0
95858: GO 95891
95860: LD_INT 7
95862: DOUBLE
95863: EQUAL
95864: IFTRUE 95868
95866: GO 95875
95868: POP
// hHackChangeUnitSide ; 8 :
95869: CALL 108865 0 0
95873: GO 95891
95875: LD_INT 8
95877: DOUBLE
95878: EQUAL
95879: IFTRUE 95883
95881: GO 95890
95883: POP
// hHackFog ; end ;
95884: CALL 108966 0 0
95888: GO 95891
95890: POP
// end ; end ;
95891: LD_VAR 0 7
95895: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
95896: GO 95898
95898: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
95899: LD_STRING initStreamRollete();
95901: PPUSH
95902: CALL_OW 559
// InitStreamMode ;
95906: CALL 95918 0 0
// DefineStreamItems ( false ) ;
95910: LD_INT 0
95912: PPUSH
95913: CALL 96382 0 1
// end ;
95917: END
// function InitStreamMode ; begin
95918: LD_INT 0
95920: PPUSH
// streamModeActive := false ;
95921: LD_ADDR_EXP 77
95925: PUSH
95926: LD_INT 0
95928: ST_TO_ADDR
// normalCounter := 36 ;
95929: LD_ADDR_EXP 78
95933: PUSH
95934: LD_INT 36
95936: ST_TO_ADDR
// hardcoreCounter := 18 ;
95937: LD_ADDR_EXP 79
95941: PUSH
95942: LD_INT 18
95944: ST_TO_ADDR
// sRocket := false ;
95945: LD_ADDR_EXP 82
95949: PUSH
95950: LD_INT 0
95952: ST_TO_ADDR
// sSpeed := false ;
95953: LD_ADDR_EXP 81
95957: PUSH
95958: LD_INT 0
95960: ST_TO_ADDR
// sEngine := false ;
95961: LD_ADDR_EXP 83
95965: PUSH
95966: LD_INT 0
95968: ST_TO_ADDR
// sSpec := false ;
95969: LD_ADDR_EXP 80
95973: PUSH
95974: LD_INT 0
95976: ST_TO_ADDR
// sLevel := false ;
95977: LD_ADDR_EXP 84
95981: PUSH
95982: LD_INT 0
95984: ST_TO_ADDR
// sArmoury := false ;
95985: LD_ADDR_EXP 85
95989: PUSH
95990: LD_INT 0
95992: ST_TO_ADDR
// sRadar := false ;
95993: LD_ADDR_EXP 86
95997: PUSH
95998: LD_INT 0
96000: ST_TO_ADDR
// sBunker := false ;
96001: LD_ADDR_EXP 87
96005: PUSH
96006: LD_INT 0
96008: ST_TO_ADDR
// sHack := false ;
96009: LD_ADDR_EXP 88
96013: PUSH
96014: LD_INT 0
96016: ST_TO_ADDR
// sFire := false ;
96017: LD_ADDR_EXP 89
96021: PUSH
96022: LD_INT 0
96024: ST_TO_ADDR
// sRefresh := false ;
96025: LD_ADDR_EXP 90
96029: PUSH
96030: LD_INT 0
96032: ST_TO_ADDR
// sExp := false ;
96033: LD_ADDR_EXP 91
96037: PUSH
96038: LD_INT 0
96040: ST_TO_ADDR
// sDepot := false ;
96041: LD_ADDR_EXP 92
96045: PUSH
96046: LD_INT 0
96048: ST_TO_ADDR
// sFlag := false ;
96049: LD_ADDR_EXP 93
96053: PUSH
96054: LD_INT 0
96056: ST_TO_ADDR
// sKamikadze := false ;
96057: LD_ADDR_EXP 101
96061: PUSH
96062: LD_INT 0
96064: ST_TO_ADDR
// sTroll := false ;
96065: LD_ADDR_EXP 102
96069: PUSH
96070: LD_INT 0
96072: ST_TO_ADDR
// sSlow := false ;
96073: LD_ADDR_EXP 103
96077: PUSH
96078: LD_INT 0
96080: ST_TO_ADDR
// sLack := false ;
96081: LD_ADDR_EXP 104
96085: PUSH
96086: LD_INT 0
96088: ST_TO_ADDR
// sTank := false ;
96089: LD_ADDR_EXP 106
96093: PUSH
96094: LD_INT 0
96096: ST_TO_ADDR
// sRemote := false ;
96097: LD_ADDR_EXP 107
96101: PUSH
96102: LD_INT 0
96104: ST_TO_ADDR
// sPowell := false ;
96105: LD_ADDR_EXP 108
96109: PUSH
96110: LD_INT 0
96112: ST_TO_ADDR
// sTeleport := false ;
96113: LD_ADDR_EXP 111
96117: PUSH
96118: LD_INT 0
96120: ST_TO_ADDR
// sOilTower := false ;
96121: LD_ADDR_EXP 113
96125: PUSH
96126: LD_INT 0
96128: ST_TO_ADDR
// sShovel := false ;
96129: LD_ADDR_EXP 114
96133: PUSH
96134: LD_INT 0
96136: ST_TO_ADDR
// sSheik := false ;
96137: LD_ADDR_EXP 115
96141: PUSH
96142: LD_INT 0
96144: ST_TO_ADDR
// sEarthquake := false ;
96145: LD_ADDR_EXP 117
96149: PUSH
96150: LD_INT 0
96152: ST_TO_ADDR
// sAI := false ;
96153: LD_ADDR_EXP 118
96157: PUSH
96158: LD_INT 0
96160: ST_TO_ADDR
// sCargo := false ;
96161: LD_ADDR_EXP 121
96165: PUSH
96166: LD_INT 0
96168: ST_TO_ADDR
// sDLaser := false ;
96169: LD_ADDR_EXP 122
96173: PUSH
96174: LD_INT 0
96176: ST_TO_ADDR
// sExchange := false ;
96177: LD_ADDR_EXP 123
96181: PUSH
96182: LD_INT 0
96184: ST_TO_ADDR
// sFac := false ;
96185: LD_ADDR_EXP 124
96189: PUSH
96190: LD_INT 0
96192: ST_TO_ADDR
// sPower := false ;
96193: LD_ADDR_EXP 125
96197: PUSH
96198: LD_INT 0
96200: ST_TO_ADDR
// sRandom := false ;
96201: LD_ADDR_EXP 126
96205: PUSH
96206: LD_INT 0
96208: ST_TO_ADDR
// sShield := false ;
96209: LD_ADDR_EXP 127
96213: PUSH
96214: LD_INT 0
96216: ST_TO_ADDR
// sTime := false ;
96217: LD_ADDR_EXP 128
96221: PUSH
96222: LD_INT 0
96224: ST_TO_ADDR
// sTools := false ;
96225: LD_ADDR_EXP 129
96229: PUSH
96230: LD_INT 0
96232: ST_TO_ADDR
// sSold := false ;
96233: LD_ADDR_EXP 94
96237: PUSH
96238: LD_INT 0
96240: ST_TO_ADDR
// sDiff := false ;
96241: LD_ADDR_EXP 95
96245: PUSH
96246: LD_INT 0
96248: ST_TO_ADDR
// sFog := false ;
96249: LD_ADDR_EXP 98
96253: PUSH
96254: LD_INT 0
96256: ST_TO_ADDR
// sReset := false ;
96257: LD_ADDR_EXP 99
96261: PUSH
96262: LD_INT 0
96264: ST_TO_ADDR
// sSun := false ;
96265: LD_ADDR_EXP 100
96269: PUSH
96270: LD_INT 0
96272: ST_TO_ADDR
// sTiger := false ;
96273: LD_ADDR_EXP 96
96277: PUSH
96278: LD_INT 0
96280: ST_TO_ADDR
// sBomb := false ;
96281: LD_ADDR_EXP 97
96285: PUSH
96286: LD_INT 0
96288: ST_TO_ADDR
// sWound := false ;
96289: LD_ADDR_EXP 105
96293: PUSH
96294: LD_INT 0
96296: ST_TO_ADDR
// sBetray := false ;
96297: LD_ADDR_EXP 109
96301: PUSH
96302: LD_INT 0
96304: ST_TO_ADDR
// sContamin := false ;
96305: LD_ADDR_EXP 110
96309: PUSH
96310: LD_INT 0
96312: ST_TO_ADDR
// sOil := false ;
96313: LD_ADDR_EXP 112
96317: PUSH
96318: LD_INT 0
96320: ST_TO_ADDR
// sStu := false ;
96321: LD_ADDR_EXP 116
96325: PUSH
96326: LD_INT 0
96328: ST_TO_ADDR
// sBazooka := false ;
96329: LD_ADDR_EXP 119
96333: PUSH
96334: LD_INT 0
96336: ST_TO_ADDR
// sMortar := false ;
96337: LD_ADDR_EXP 120
96341: PUSH
96342: LD_INT 0
96344: ST_TO_ADDR
// sRanger := false ;
96345: LD_ADDR_EXP 130
96349: PUSH
96350: LD_INT 0
96352: ST_TO_ADDR
// sComputer := false ;
96353: LD_ADDR_EXP 131
96357: PUSH
96358: LD_INT 0
96360: ST_TO_ADDR
// s30 := false ;
96361: LD_ADDR_EXP 132
96365: PUSH
96366: LD_INT 0
96368: ST_TO_ADDR
// s60 := false ;
96369: LD_ADDR_EXP 133
96373: PUSH
96374: LD_INT 0
96376: ST_TO_ADDR
// end ;
96377: LD_VAR 0 1
96381: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96382: LD_INT 0
96384: PPUSH
96385: PPUSH
96386: PPUSH
96387: PPUSH
96388: PPUSH
96389: PPUSH
96390: PPUSH
// result := [ ] ;
96391: LD_ADDR_VAR 0 2
96395: PUSH
96396: EMPTY
96397: ST_TO_ADDR
// if campaign_id = 1 then
96398: LD_OWVAR 69
96402: PUSH
96403: LD_INT 1
96405: EQUAL
96406: IFFALSE 99572
// begin case mission_number of 1 :
96408: LD_OWVAR 70
96412: PUSH
96413: LD_INT 1
96415: DOUBLE
96416: EQUAL
96417: IFTRUE 96421
96419: GO 96497
96421: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96422: LD_ADDR_VAR 0 2
96426: PUSH
96427: LD_INT 2
96429: PUSH
96430: LD_INT 4
96432: PUSH
96433: LD_INT 11
96435: PUSH
96436: LD_INT 12
96438: PUSH
96439: LD_INT 15
96441: PUSH
96442: LD_INT 16
96444: PUSH
96445: LD_INT 22
96447: PUSH
96448: LD_INT 23
96450: PUSH
96451: LD_INT 26
96453: PUSH
96454: EMPTY
96455: LIST
96456: LIST
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: PUSH
96465: LD_INT 101
96467: PUSH
96468: LD_INT 102
96470: PUSH
96471: LD_INT 106
96473: PUSH
96474: LD_INT 116
96476: PUSH
96477: LD_INT 117
96479: PUSH
96480: LD_INT 118
96482: PUSH
96483: EMPTY
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: ST_TO_ADDR
96495: GO 99570
96497: LD_INT 2
96499: DOUBLE
96500: EQUAL
96501: IFTRUE 96505
96503: GO 96589
96505: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96506: LD_ADDR_VAR 0 2
96510: PUSH
96511: LD_INT 2
96513: PUSH
96514: LD_INT 4
96516: PUSH
96517: LD_INT 11
96519: PUSH
96520: LD_INT 12
96522: PUSH
96523: LD_INT 15
96525: PUSH
96526: LD_INT 16
96528: PUSH
96529: LD_INT 22
96531: PUSH
96532: LD_INT 23
96534: PUSH
96535: LD_INT 26
96537: PUSH
96538: EMPTY
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: PUSH
96549: LD_INT 101
96551: PUSH
96552: LD_INT 102
96554: PUSH
96555: LD_INT 105
96557: PUSH
96558: LD_INT 106
96560: PUSH
96561: LD_INT 108
96563: PUSH
96564: LD_INT 116
96566: PUSH
96567: LD_INT 117
96569: PUSH
96570: LD_INT 118
96572: PUSH
96573: EMPTY
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: ST_TO_ADDR
96587: GO 99570
96589: LD_INT 3
96591: DOUBLE
96592: EQUAL
96593: IFTRUE 96597
96595: GO 96685
96597: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96598: LD_ADDR_VAR 0 2
96602: PUSH
96603: LD_INT 2
96605: PUSH
96606: LD_INT 4
96608: PUSH
96609: LD_INT 5
96611: PUSH
96612: LD_INT 11
96614: PUSH
96615: LD_INT 12
96617: PUSH
96618: LD_INT 15
96620: PUSH
96621: LD_INT 16
96623: PUSH
96624: LD_INT 22
96626: PUSH
96627: LD_INT 26
96629: PUSH
96630: LD_INT 36
96632: PUSH
96633: EMPTY
96634: LIST
96635: LIST
96636: LIST
96637: LIST
96638: LIST
96639: LIST
96640: LIST
96641: LIST
96642: LIST
96643: LIST
96644: PUSH
96645: LD_INT 101
96647: PUSH
96648: LD_INT 102
96650: PUSH
96651: LD_INT 105
96653: PUSH
96654: LD_INT 106
96656: PUSH
96657: LD_INT 108
96659: PUSH
96660: LD_INT 116
96662: PUSH
96663: LD_INT 117
96665: PUSH
96666: LD_INT 118
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: ST_TO_ADDR
96683: GO 99570
96685: LD_INT 4
96687: DOUBLE
96688: EQUAL
96689: IFTRUE 96693
96691: GO 96789
96693: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96694: LD_ADDR_VAR 0 2
96698: PUSH
96699: LD_INT 2
96701: PUSH
96702: LD_INT 4
96704: PUSH
96705: LD_INT 5
96707: PUSH
96708: LD_INT 8
96710: PUSH
96711: LD_INT 11
96713: PUSH
96714: LD_INT 12
96716: PUSH
96717: LD_INT 15
96719: PUSH
96720: LD_INT 16
96722: PUSH
96723: LD_INT 22
96725: PUSH
96726: LD_INT 23
96728: PUSH
96729: LD_INT 26
96731: PUSH
96732: LD_INT 36
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: PUSH
96749: LD_INT 101
96751: PUSH
96752: LD_INT 102
96754: PUSH
96755: LD_INT 105
96757: PUSH
96758: LD_INT 106
96760: PUSH
96761: LD_INT 108
96763: PUSH
96764: LD_INT 116
96766: PUSH
96767: LD_INT 117
96769: PUSH
96770: LD_INT 118
96772: PUSH
96773: EMPTY
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: ST_TO_ADDR
96787: GO 99570
96789: LD_INT 5
96791: DOUBLE
96792: EQUAL
96793: IFTRUE 96797
96795: GO 96909
96797: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96798: LD_ADDR_VAR 0 2
96802: PUSH
96803: LD_INT 2
96805: PUSH
96806: LD_INT 4
96808: PUSH
96809: LD_INT 5
96811: PUSH
96812: LD_INT 6
96814: PUSH
96815: LD_INT 8
96817: PUSH
96818: LD_INT 11
96820: PUSH
96821: LD_INT 12
96823: PUSH
96824: LD_INT 15
96826: PUSH
96827: LD_INT 16
96829: PUSH
96830: LD_INT 22
96832: PUSH
96833: LD_INT 23
96835: PUSH
96836: LD_INT 25
96838: PUSH
96839: LD_INT 26
96841: PUSH
96842: LD_INT 36
96844: PUSH
96845: EMPTY
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: PUSH
96861: LD_INT 101
96863: PUSH
96864: LD_INT 102
96866: PUSH
96867: LD_INT 105
96869: PUSH
96870: LD_INT 106
96872: PUSH
96873: LD_INT 108
96875: PUSH
96876: LD_INT 109
96878: PUSH
96879: LD_INT 112
96881: PUSH
96882: LD_INT 116
96884: PUSH
96885: LD_INT 117
96887: PUSH
96888: LD_INT 118
96890: PUSH
96891: EMPTY
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: PUSH
96903: EMPTY
96904: LIST
96905: LIST
96906: ST_TO_ADDR
96907: GO 99570
96909: LD_INT 6
96911: DOUBLE
96912: EQUAL
96913: IFTRUE 96917
96915: GO 97049
96917: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
96918: LD_ADDR_VAR 0 2
96922: PUSH
96923: LD_INT 2
96925: PUSH
96926: LD_INT 4
96928: PUSH
96929: LD_INT 5
96931: PUSH
96932: LD_INT 6
96934: PUSH
96935: LD_INT 8
96937: PUSH
96938: LD_INT 11
96940: PUSH
96941: LD_INT 12
96943: PUSH
96944: LD_INT 15
96946: PUSH
96947: LD_INT 16
96949: PUSH
96950: LD_INT 20
96952: PUSH
96953: LD_INT 21
96955: PUSH
96956: LD_INT 22
96958: PUSH
96959: LD_INT 23
96961: PUSH
96962: LD_INT 25
96964: PUSH
96965: LD_INT 26
96967: PUSH
96968: LD_INT 30
96970: PUSH
96971: LD_INT 31
96973: PUSH
96974: LD_INT 32
96976: PUSH
96977: LD_INT 36
96979: PUSH
96980: EMPTY
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: LIST
96999: LIST
97000: PUSH
97001: LD_INT 101
97003: PUSH
97004: LD_INT 102
97006: PUSH
97007: LD_INT 105
97009: PUSH
97010: LD_INT 106
97012: PUSH
97013: LD_INT 108
97015: PUSH
97016: LD_INT 109
97018: PUSH
97019: LD_INT 112
97021: PUSH
97022: LD_INT 116
97024: PUSH
97025: LD_INT 117
97027: PUSH
97028: LD_INT 118
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: PUSH
97043: EMPTY
97044: LIST
97045: LIST
97046: ST_TO_ADDR
97047: GO 99570
97049: LD_INT 7
97051: DOUBLE
97052: EQUAL
97053: IFTRUE 97057
97055: GO 97169
97057: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97058: LD_ADDR_VAR 0 2
97062: PUSH
97063: LD_INT 2
97065: PUSH
97066: LD_INT 4
97068: PUSH
97069: LD_INT 5
97071: PUSH
97072: LD_INT 7
97074: PUSH
97075: LD_INT 11
97077: PUSH
97078: LD_INT 12
97080: PUSH
97081: LD_INT 15
97083: PUSH
97084: LD_INT 16
97086: PUSH
97087: LD_INT 20
97089: PUSH
97090: LD_INT 21
97092: PUSH
97093: LD_INT 22
97095: PUSH
97096: LD_INT 23
97098: PUSH
97099: LD_INT 25
97101: PUSH
97102: LD_INT 26
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: PUSH
97121: LD_INT 101
97123: PUSH
97124: LD_INT 102
97126: PUSH
97127: LD_INT 103
97129: PUSH
97130: LD_INT 105
97132: PUSH
97133: LD_INT 106
97135: PUSH
97136: LD_INT 108
97138: PUSH
97139: LD_INT 112
97141: PUSH
97142: LD_INT 116
97144: PUSH
97145: LD_INT 117
97147: PUSH
97148: LD_INT 118
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: PUSH
97163: EMPTY
97164: LIST
97165: LIST
97166: ST_TO_ADDR
97167: GO 99570
97169: LD_INT 8
97171: DOUBLE
97172: EQUAL
97173: IFTRUE 97177
97175: GO 97317
97177: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97178: LD_ADDR_VAR 0 2
97182: PUSH
97183: LD_INT 2
97185: PUSH
97186: LD_INT 4
97188: PUSH
97189: LD_INT 5
97191: PUSH
97192: LD_INT 6
97194: PUSH
97195: LD_INT 7
97197: PUSH
97198: LD_INT 8
97200: PUSH
97201: LD_INT 11
97203: PUSH
97204: LD_INT 12
97206: PUSH
97207: LD_INT 15
97209: PUSH
97210: LD_INT 16
97212: PUSH
97213: LD_INT 20
97215: PUSH
97216: LD_INT 21
97218: PUSH
97219: LD_INT 22
97221: PUSH
97222: LD_INT 23
97224: PUSH
97225: LD_INT 25
97227: PUSH
97228: LD_INT 26
97230: PUSH
97231: LD_INT 30
97233: PUSH
97234: LD_INT 31
97236: PUSH
97237: LD_INT 32
97239: PUSH
97240: LD_INT 36
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: PUSH
97265: LD_INT 101
97267: PUSH
97268: LD_INT 102
97270: PUSH
97271: LD_INT 103
97273: PUSH
97274: LD_INT 105
97276: PUSH
97277: LD_INT 106
97279: PUSH
97280: LD_INT 108
97282: PUSH
97283: LD_INT 109
97285: PUSH
97286: LD_INT 112
97288: PUSH
97289: LD_INT 116
97291: PUSH
97292: LD_INT 117
97294: PUSH
97295: LD_INT 118
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: PUSH
97311: EMPTY
97312: LIST
97313: LIST
97314: ST_TO_ADDR
97315: GO 99570
97317: LD_INT 9
97319: DOUBLE
97320: EQUAL
97321: IFTRUE 97325
97323: GO 97473
97325: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97326: LD_ADDR_VAR 0 2
97330: PUSH
97331: LD_INT 2
97333: PUSH
97334: LD_INT 4
97336: PUSH
97337: LD_INT 5
97339: PUSH
97340: LD_INT 6
97342: PUSH
97343: LD_INT 7
97345: PUSH
97346: LD_INT 8
97348: PUSH
97349: LD_INT 11
97351: PUSH
97352: LD_INT 12
97354: PUSH
97355: LD_INT 15
97357: PUSH
97358: LD_INT 16
97360: PUSH
97361: LD_INT 20
97363: PUSH
97364: LD_INT 21
97366: PUSH
97367: LD_INT 22
97369: PUSH
97370: LD_INT 23
97372: PUSH
97373: LD_INT 25
97375: PUSH
97376: LD_INT 26
97378: PUSH
97379: LD_INT 28
97381: PUSH
97382: LD_INT 30
97384: PUSH
97385: LD_INT 31
97387: PUSH
97388: LD_INT 32
97390: PUSH
97391: LD_INT 36
97393: PUSH
97394: EMPTY
97395: LIST
97396: LIST
97397: LIST
97398: LIST
97399: LIST
97400: LIST
97401: LIST
97402: LIST
97403: LIST
97404: LIST
97405: LIST
97406: LIST
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: LIST
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 101
97419: PUSH
97420: LD_INT 102
97422: PUSH
97423: LD_INT 103
97425: PUSH
97426: LD_INT 105
97428: PUSH
97429: LD_INT 106
97431: PUSH
97432: LD_INT 108
97434: PUSH
97435: LD_INT 109
97437: PUSH
97438: LD_INT 112
97440: PUSH
97441: LD_INT 114
97443: PUSH
97444: LD_INT 116
97446: PUSH
97447: LD_INT 117
97449: PUSH
97450: LD_INT 118
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: PUSH
97467: EMPTY
97468: LIST
97469: LIST
97470: ST_TO_ADDR
97471: GO 99570
97473: LD_INT 10
97475: DOUBLE
97476: EQUAL
97477: IFTRUE 97481
97479: GO 97677
97481: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97482: LD_ADDR_VAR 0 2
97486: PUSH
97487: LD_INT 2
97489: PUSH
97490: LD_INT 4
97492: PUSH
97493: LD_INT 5
97495: PUSH
97496: LD_INT 6
97498: PUSH
97499: LD_INT 7
97501: PUSH
97502: LD_INT 8
97504: PUSH
97505: LD_INT 9
97507: PUSH
97508: LD_INT 10
97510: PUSH
97511: LD_INT 11
97513: PUSH
97514: LD_INT 12
97516: PUSH
97517: LD_INT 13
97519: PUSH
97520: LD_INT 14
97522: PUSH
97523: LD_INT 15
97525: PUSH
97526: LD_INT 16
97528: PUSH
97529: LD_INT 17
97531: PUSH
97532: LD_INT 18
97534: PUSH
97535: LD_INT 19
97537: PUSH
97538: LD_INT 20
97540: PUSH
97541: LD_INT 21
97543: PUSH
97544: LD_INT 22
97546: PUSH
97547: LD_INT 23
97549: PUSH
97550: LD_INT 24
97552: PUSH
97553: LD_INT 25
97555: PUSH
97556: LD_INT 26
97558: PUSH
97559: LD_INT 28
97561: PUSH
97562: LD_INT 30
97564: PUSH
97565: LD_INT 31
97567: PUSH
97568: LD_INT 32
97570: PUSH
97571: LD_INT 36
97573: PUSH
97574: EMPTY
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: LIST
97588: LIST
97589: LIST
97590: LIST
97591: LIST
97592: LIST
97593: LIST
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: LIST
97599: LIST
97600: LIST
97601: LIST
97602: LIST
97603: LIST
97604: PUSH
97605: LD_INT 101
97607: PUSH
97608: LD_INT 102
97610: PUSH
97611: LD_INT 103
97613: PUSH
97614: LD_INT 104
97616: PUSH
97617: LD_INT 105
97619: PUSH
97620: LD_INT 106
97622: PUSH
97623: LD_INT 107
97625: PUSH
97626: LD_INT 108
97628: PUSH
97629: LD_INT 109
97631: PUSH
97632: LD_INT 110
97634: PUSH
97635: LD_INT 111
97637: PUSH
97638: LD_INT 112
97640: PUSH
97641: LD_INT 114
97643: PUSH
97644: LD_INT 116
97646: PUSH
97647: LD_INT 117
97649: PUSH
97650: LD_INT 118
97652: PUSH
97653: EMPTY
97654: LIST
97655: LIST
97656: LIST
97657: LIST
97658: LIST
97659: LIST
97660: LIST
97661: LIST
97662: LIST
97663: LIST
97664: LIST
97665: LIST
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: PUSH
97671: EMPTY
97672: LIST
97673: LIST
97674: ST_TO_ADDR
97675: GO 99570
97677: LD_INT 11
97679: DOUBLE
97680: EQUAL
97681: IFTRUE 97685
97683: GO 97889
97685: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97686: LD_ADDR_VAR 0 2
97690: PUSH
97691: LD_INT 2
97693: PUSH
97694: LD_INT 3
97696: PUSH
97697: LD_INT 4
97699: PUSH
97700: LD_INT 5
97702: PUSH
97703: LD_INT 6
97705: PUSH
97706: LD_INT 7
97708: PUSH
97709: LD_INT 8
97711: PUSH
97712: LD_INT 9
97714: PUSH
97715: LD_INT 10
97717: PUSH
97718: LD_INT 11
97720: PUSH
97721: LD_INT 12
97723: PUSH
97724: LD_INT 13
97726: PUSH
97727: LD_INT 14
97729: PUSH
97730: LD_INT 15
97732: PUSH
97733: LD_INT 16
97735: PUSH
97736: LD_INT 17
97738: PUSH
97739: LD_INT 18
97741: PUSH
97742: LD_INT 19
97744: PUSH
97745: LD_INT 20
97747: PUSH
97748: LD_INT 21
97750: PUSH
97751: LD_INT 22
97753: PUSH
97754: LD_INT 23
97756: PUSH
97757: LD_INT 24
97759: PUSH
97760: LD_INT 25
97762: PUSH
97763: LD_INT 26
97765: PUSH
97766: LD_INT 28
97768: PUSH
97769: LD_INT 30
97771: PUSH
97772: LD_INT 31
97774: PUSH
97775: LD_INT 32
97777: PUSH
97778: LD_INT 34
97780: PUSH
97781: LD_INT 36
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: PUSH
97817: LD_INT 101
97819: PUSH
97820: LD_INT 102
97822: PUSH
97823: LD_INT 103
97825: PUSH
97826: LD_INT 104
97828: PUSH
97829: LD_INT 105
97831: PUSH
97832: LD_INT 106
97834: PUSH
97835: LD_INT 107
97837: PUSH
97838: LD_INT 108
97840: PUSH
97841: LD_INT 109
97843: PUSH
97844: LD_INT 110
97846: PUSH
97847: LD_INT 111
97849: PUSH
97850: LD_INT 112
97852: PUSH
97853: LD_INT 114
97855: PUSH
97856: LD_INT 116
97858: PUSH
97859: LD_INT 117
97861: PUSH
97862: LD_INT 118
97864: PUSH
97865: EMPTY
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: PUSH
97883: EMPTY
97884: LIST
97885: LIST
97886: ST_TO_ADDR
97887: GO 99570
97889: LD_INT 12
97891: DOUBLE
97892: EQUAL
97893: IFTRUE 97897
97895: GO 98117
97897: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
97898: LD_ADDR_VAR 0 2
97902: PUSH
97903: LD_INT 1
97905: PUSH
97906: LD_INT 2
97908: PUSH
97909: LD_INT 3
97911: PUSH
97912: LD_INT 4
97914: PUSH
97915: LD_INT 5
97917: PUSH
97918: LD_INT 6
97920: PUSH
97921: LD_INT 7
97923: PUSH
97924: LD_INT 8
97926: PUSH
97927: LD_INT 9
97929: PUSH
97930: LD_INT 10
97932: PUSH
97933: LD_INT 11
97935: PUSH
97936: LD_INT 12
97938: PUSH
97939: LD_INT 13
97941: PUSH
97942: LD_INT 14
97944: PUSH
97945: LD_INT 15
97947: PUSH
97948: LD_INT 16
97950: PUSH
97951: LD_INT 17
97953: PUSH
97954: LD_INT 18
97956: PUSH
97957: LD_INT 19
97959: PUSH
97960: LD_INT 20
97962: PUSH
97963: LD_INT 21
97965: PUSH
97966: LD_INT 22
97968: PUSH
97969: LD_INT 23
97971: PUSH
97972: LD_INT 24
97974: PUSH
97975: LD_INT 25
97977: PUSH
97978: LD_INT 26
97980: PUSH
97981: LD_INT 27
97983: PUSH
97984: LD_INT 28
97986: PUSH
97987: LD_INT 30
97989: PUSH
97990: LD_INT 31
97992: PUSH
97993: LD_INT 32
97995: PUSH
97996: LD_INT 33
97998: PUSH
97999: LD_INT 34
98001: PUSH
98002: LD_INT 36
98004: PUSH
98005: EMPTY
98006: LIST
98007: LIST
98008: LIST
98009: LIST
98010: LIST
98011: LIST
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: LIST
98019: LIST
98020: LIST
98021: LIST
98022: LIST
98023: LIST
98024: LIST
98025: LIST
98026: LIST
98027: LIST
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: PUSH
98041: LD_INT 101
98043: PUSH
98044: LD_INT 102
98046: PUSH
98047: LD_INT 103
98049: PUSH
98050: LD_INT 104
98052: PUSH
98053: LD_INT 105
98055: PUSH
98056: LD_INT 106
98058: PUSH
98059: LD_INT 107
98061: PUSH
98062: LD_INT 108
98064: PUSH
98065: LD_INT 109
98067: PUSH
98068: LD_INT 110
98070: PUSH
98071: LD_INT 111
98073: PUSH
98074: LD_INT 112
98076: PUSH
98077: LD_INT 113
98079: PUSH
98080: LD_INT 114
98082: PUSH
98083: LD_INT 116
98085: PUSH
98086: LD_INT 117
98088: PUSH
98089: LD_INT 118
98091: PUSH
98092: EMPTY
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: ST_TO_ADDR
98115: GO 99570
98117: LD_INT 13
98119: DOUBLE
98120: EQUAL
98121: IFTRUE 98125
98123: GO 98333
98125: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98126: LD_ADDR_VAR 0 2
98130: PUSH
98131: LD_INT 1
98133: PUSH
98134: LD_INT 2
98136: PUSH
98137: LD_INT 3
98139: PUSH
98140: LD_INT 4
98142: PUSH
98143: LD_INT 5
98145: PUSH
98146: LD_INT 8
98148: PUSH
98149: LD_INT 9
98151: PUSH
98152: LD_INT 10
98154: PUSH
98155: LD_INT 11
98157: PUSH
98158: LD_INT 12
98160: PUSH
98161: LD_INT 14
98163: PUSH
98164: LD_INT 15
98166: PUSH
98167: LD_INT 16
98169: PUSH
98170: LD_INT 17
98172: PUSH
98173: LD_INT 18
98175: PUSH
98176: LD_INT 19
98178: PUSH
98179: LD_INT 20
98181: PUSH
98182: LD_INT 21
98184: PUSH
98185: LD_INT 22
98187: PUSH
98188: LD_INT 23
98190: PUSH
98191: LD_INT 24
98193: PUSH
98194: LD_INT 25
98196: PUSH
98197: LD_INT 26
98199: PUSH
98200: LD_INT 27
98202: PUSH
98203: LD_INT 28
98205: PUSH
98206: LD_INT 30
98208: PUSH
98209: LD_INT 31
98211: PUSH
98212: LD_INT 32
98214: PUSH
98215: LD_INT 33
98217: PUSH
98218: LD_INT 34
98220: PUSH
98221: LD_INT 36
98223: PUSH
98224: EMPTY
98225: LIST
98226: LIST
98227: LIST
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: LIST
98234: LIST
98235: LIST
98236: LIST
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: PUSH
98257: LD_INT 101
98259: PUSH
98260: LD_INT 102
98262: PUSH
98263: LD_INT 103
98265: PUSH
98266: LD_INT 104
98268: PUSH
98269: LD_INT 105
98271: PUSH
98272: LD_INT 106
98274: PUSH
98275: LD_INT 107
98277: PUSH
98278: LD_INT 108
98280: PUSH
98281: LD_INT 109
98283: PUSH
98284: LD_INT 110
98286: PUSH
98287: LD_INT 111
98289: PUSH
98290: LD_INT 112
98292: PUSH
98293: LD_INT 113
98295: PUSH
98296: LD_INT 114
98298: PUSH
98299: LD_INT 116
98301: PUSH
98302: LD_INT 117
98304: PUSH
98305: LD_INT 118
98307: PUSH
98308: EMPTY
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: LIST
98315: LIST
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: PUSH
98327: EMPTY
98328: LIST
98329: LIST
98330: ST_TO_ADDR
98331: GO 99570
98333: LD_INT 14
98335: DOUBLE
98336: EQUAL
98337: IFTRUE 98341
98339: GO 98565
98341: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98342: LD_ADDR_VAR 0 2
98346: PUSH
98347: LD_INT 1
98349: PUSH
98350: LD_INT 2
98352: PUSH
98353: LD_INT 3
98355: PUSH
98356: LD_INT 4
98358: PUSH
98359: LD_INT 5
98361: PUSH
98362: LD_INT 6
98364: PUSH
98365: LD_INT 7
98367: PUSH
98368: LD_INT 8
98370: PUSH
98371: LD_INT 9
98373: PUSH
98374: LD_INT 10
98376: PUSH
98377: LD_INT 11
98379: PUSH
98380: LD_INT 12
98382: PUSH
98383: LD_INT 13
98385: PUSH
98386: LD_INT 14
98388: PUSH
98389: LD_INT 15
98391: PUSH
98392: LD_INT 16
98394: PUSH
98395: LD_INT 17
98397: PUSH
98398: LD_INT 18
98400: PUSH
98401: LD_INT 19
98403: PUSH
98404: LD_INT 20
98406: PUSH
98407: LD_INT 21
98409: PUSH
98410: LD_INT 22
98412: PUSH
98413: LD_INT 23
98415: PUSH
98416: LD_INT 24
98418: PUSH
98419: LD_INT 25
98421: PUSH
98422: LD_INT 26
98424: PUSH
98425: LD_INT 27
98427: PUSH
98428: LD_INT 28
98430: PUSH
98431: LD_INT 29
98433: PUSH
98434: LD_INT 30
98436: PUSH
98437: LD_INT 31
98439: PUSH
98440: LD_INT 32
98442: PUSH
98443: LD_INT 33
98445: PUSH
98446: LD_INT 34
98448: PUSH
98449: LD_INT 36
98451: PUSH
98452: EMPTY
98453: LIST
98454: LIST
98455: LIST
98456: LIST
98457: LIST
98458: LIST
98459: LIST
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: LIST
98474: LIST
98475: LIST
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: PUSH
98489: LD_INT 101
98491: PUSH
98492: LD_INT 102
98494: PUSH
98495: LD_INT 103
98497: PUSH
98498: LD_INT 104
98500: PUSH
98501: LD_INT 105
98503: PUSH
98504: LD_INT 106
98506: PUSH
98507: LD_INT 107
98509: PUSH
98510: LD_INT 108
98512: PUSH
98513: LD_INT 109
98515: PUSH
98516: LD_INT 110
98518: PUSH
98519: LD_INT 111
98521: PUSH
98522: LD_INT 112
98524: PUSH
98525: LD_INT 113
98527: PUSH
98528: LD_INT 114
98530: PUSH
98531: LD_INT 116
98533: PUSH
98534: LD_INT 117
98536: PUSH
98537: LD_INT 118
98539: PUSH
98540: EMPTY
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: PUSH
98559: EMPTY
98560: LIST
98561: LIST
98562: ST_TO_ADDR
98563: GO 99570
98565: LD_INT 15
98567: DOUBLE
98568: EQUAL
98569: IFTRUE 98573
98571: GO 98797
98573: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98574: LD_ADDR_VAR 0 2
98578: PUSH
98579: LD_INT 1
98581: PUSH
98582: LD_INT 2
98584: PUSH
98585: LD_INT 3
98587: PUSH
98588: LD_INT 4
98590: PUSH
98591: LD_INT 5
98593: PUSH
98594: LD_INT 6
98596: PUSH
98597: LD_INT 7
98599: PUSH
98600: LD_INT 8
98602: PUSH
98603: LD_INT 9
98605: PUSH
98606: LD_INT 10
98608: PUSH
98609: LD_INT 11
98611: PUSH
98612: LD_INT 12
98614: PUSH
98615: LD_INT 13
98617: PUSH
98618: LD_INT 14
98620: PUSH
98621: LD_INT 15
98623: PUSH
98624: LD_INT 16
98626: PUSH
98627: LD_INT 17
98629: PUSH
98630: LD_INT 18
98632: PUSH
98633: LD_INT 19
98635: PUSH
98636: LD_INT 20
98638: PUSH
98639: LD_INT 21
98641: PUSH
98642: LD_INT 22
98644: PUSH
98645: LD_INT 23
98647: PUSH
98648: LD_INT 24
98650: PUSH
98651: LD_INT 25
98653: PUSH
98654: LD_INT 26
98656: PUSH
98657: LD_INT 27
98659: PUSH
98660: LD_INT 28
98662: PUSH
98663: LD_INT 29
98665: PUSH
98666: LD_INT 30
98668: PUSH
98669: LD_INT 31
98671: PUSH
98672: LD_INT 32
98674: PUSH
98675: LD_INT 33
98677: PUSH
98678: LD_INT 34
98680: PUSH
98681: LD_INT 36
98683: PUSH
98684: EMPTY
98685: LIST
98686: LIST
98687: LIST
98688: LIST
98689: LIST
98690: LIST
98691: LIST
98692: LIST
98693: LIST
98694: LIST
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: LIST
98711: LIST
98712: LIST
98713: LIST
98714: LIST
98715: LIST
98716: LIST
98717: LIST
98718: LIST
98719: LIST
98720: PUSH
98721: LD_INT 101
98723: PUSH
98724: LD_INT 102
98726: PUSH
98727: LD_INT 103
98729: PUSH
98730: LD_INT 104
98732: PUSH
98733: LD_INT 105
98735: PUSH
98736: LD_INT 106
98738: PUSH
98739: LD_INT 107
98741: PUSH
98742: LD_INT 108
98744: PUSH
98745: LD_INT 109
98747: PUSH
98748: LD_INT 110
98750: PUSH
98751: LD_INT 111
98753: PUSH
98754: LD_INT 112
98756: PUSH
98757: LD_INT 113
98759: PUSH
98760: LD_INT 114
98762: PUSH
98763: LD_INT 116
98765: PUSH
98766: LD_INT 117
98768: PUSH
98769: LD_INT 118
98771: PUSH
98772: EMPTY
98773: LIST
98774: LIST
98775: LIST
98776: LIST
98777: LIST
98778: LIST
98779: LIST
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: ST_TO_ADDR
98795: GO 99570
98797: LD_INT 16
98799: DOUBLE
98800: EQUAL
98801: IFTRUE 98805
98803: GO 98941
98805: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98806: LD_ADDR_VAR 0 2
98810: PUSH
98811: LD_INT 2
98813: PUSH
98814: LD_INT 4
98816: PUSH
98817: LD_INT 5
98819: PUSH
98820: LD_INT 7
98822: PUSH
98823: LD_INT 11
98825: PUSH
98826: LD_INT 12
98828: PUSH
98829: LD_INT 15
98831: PUSH
98832: LD_INT 16
98834: PUSH
98835: LD_INT 20
98837: PUSH
98838: LD_INT 21
98840: PUSH
98841: LD_INT 22
98843: PUSH
98844: LD_INT 23
98846: PUSH
98847: LD_INT 25
98849: PUSH
98850: LD_INT 26
98852: PUSH
98853: LD_INT 30
98855: PUSH
98856: LD_INT 31
98858: PUSH
98859: LD_INT 32
98861: PUSH
98862: LD_INT 33
98864: PUSH
98865: LD_INT 34
98867: PUSH
98868: EMPTY
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: LIST
98874: LIST
98875: LIST
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: LIST
98883: LIST
98884: LIST
98885: LIST
98886: LIST
98887: LIST
98888: PUSH
98889: LD_INT 101
98891: PUSH
98892: LD_INT 102
98894: PUSH
98895: LD_INT 103
98897: PUSH
98898: LD_INT 106
98900: PUSH
98901: LD_INT 108
98903: PUSH
98904: LD_INT 112
98906: PUSH
98907: LD_INT 113
98909: PUSH
98910: LD_INT 114
98912: PUSH
98913: LD_INT 116
98915: PUSH
98916: LD_INT 117
98918: PUSH
98919: LD_INT 118
98921: PUSH
98922: EMPTY
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: PUSH
98935: EMPTY
98936: LIST
98937: LIST
98938: ST_TO_ADDR
98939: GO 99570
98941: LD_INT 17
98943: DOUBLE
98944: EQUAL
98945: IFTRUE 98949
98947: GO 99173
98949: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
98950: LD_ADDR_VAR 0 2
98954: PUSH
98955: LD_INT 1
98957: PUSH
98958: LD_INT 2
98960: PUSH
98961: LD_INT 3
98963: PUSH
98964: LD_INT 4
98966: PUSH
98967: LD_INT 5
98969: PUSH
98970: LD_INT 6
98972: PUSH
98973: LD_INT 7
98975: PUSH
98976: LD_INT 8
98978: PUSH
98979: LD_INT 9
98981: PUSH
98982: LD_INT 10
98984: PUSH
98985: LD_INT 11
98987: PUSH
98988: LD_INT 12
98990: PUSH
98991: LD_INT 13
98993: PUSH
98994: LD_INT 14
98996: PUSH
98997: LD_INT 15
98999: PUSH
99000: LD_INT 16
99002: PUSH
99003: LD_INT 17
99005: PUSH
99006: LD_INT 18
99008: PUSH
99009: LD_INT 19
99011: PUSH
99012: LD_INT 20
99014: PUSH
99015: LD_INT 21
99017: PUSH
99018: LD_INT 22
99020: PUSH
99021: LD_INT 23
99023: PUSH
99024: LD_INT 24
99026: PUSH
99027: LD_INT 25
99029: PUSH
99030: LD_INT 26
99032: PUSH
99033: LD_INT 27
99035: PUSH
99036: LD_INT 28
99038: PUSH
99039: LD_INT 29
99041: PUSH
99042: LD_INT 30
99044: PUSH
99045: LD_INT 31
99047: PUSH
99048: LD_INT 32
99050: PUSH
99051: LD_INT 33
99053: PUSH
99054: LD_INT 34
99056: PUSH
99057: LD_INT 36
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: LIST
99064: LIST
99065: LIST
99066: LIST
99067: LIST
99068: LIST
99069: LIST
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: LIST
99077: LIST
99078: LIST
99079: LIST
99080: LIST
99081: LIST
99082: LIST
99083: LIST
99084: LIST
99085: LIST
99086: LIST
99087: LIST
99088: LIST
99089: LIST
99090: LIST
99091: LIST
99092: LIST
99093: LIST
99094: LIST
99095: LIST
99096: PUSH
99097: LD_INT 101
99099: PUSH
99100: LD_INT 102
99102: PUSH
99103: LD_INT 103
99105: PUSH
99106: LD_INT 104
99108: PUSH
99109: LD_INT 105
99111: PUSH
99112: LD_INT 106
99114: PUSH
99115: LD_INT 107
99117: PUSH
99118: LD_INT 108
99120: PUSH
99121: LD_INT 109
99123: PUSH
99124: LD_INT 110
99126: PUSH
99127: LD_INT 111
99129: PUSH
99130: LD_INT 112
99132: PUSH
99133: LD_INT 113
99135: PUSH
99136: LD_INT 114
99138: PUSH
99139: LD_INT 116
99141: PUSH
99142: LD_INT 117
99144: PUSH
99145: LD_INT 118
99147: PUSH
99148: EMPTY
99149: LIST
99150: LIST
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: PUSH
99167: EMPTY
99168: LIST
99169: LIST
99170: ST_TO_ADDR
99171: GO 99570
99173: LD_INT 18
99175: DOUBLE
99176: EQUAL
99177: IFTRUE 99181
99179: GO 99329
99181: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99182: LD_ADDR_VAR 0 2
99186: PUSH
99187: LD_INT 2
99189: PUSH
99190: LD_INT 4
99192: PUSH
99193: LD_INT 5
99195: PUSH
99196: LD_INT 7
99198: PUSH
99199: LD_INT 11
99201: PUSH
99202: LD_INT 12
99204: PUSH
99205: LD_INT 15
99207: PUSH
99208: LD_INT 16
99210: PUSH
99211: LD_INT 20
99213: PUSH
99214: LD_INT 21
99216: PUSH
99217: LD_INT 22
99219: PUSH
99220: LD_INT 23
99222: PUSH
99223: LD_INT 25
99225: PUSH
99226: LD_INT 26
99228: PUSH
99229: LD_INT 30
99231: PUSH
99232: LD_INT 31
99234: PUSH
99235: LD_INT 32
99237: PUSH
99238: LD_INT 33
99240: PUSH
99241: LD_INT 34
99243: PUSH
99244: LD_INT 35
99246: PUSH
99247: LD_INT 36
99249: PUSH
99250: EMPTY
99251: LIST
99252: LIST
99253: LIST
99254: LIST
99255: LIST
99256: LIST
99257: LIST
99258: LIST
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: PUSH
99273: LD_INT 101
99275: PUSH
99276: LD_INT 102
99278: PUSH
99279: LD_INT 103
99281: PUSH
99282: LD_INT 106
99284: PUSH
99285: LD_INT 108
99287: PUSH
99288: LD_INT 112
99290: PUSH
99291: LD_INT 113
99293: PUSH
99294: LD_INT 114
99296: PUSH
99297: LD_INT 115
99299: PUSH
99300: LD_INT 116
99302: PUSH
99303: LD_INT 117
99305: PUSH
99306: LD_INT 118
99308: PUSH
99309: EMPTY
99310: LIST
99311: LIST
99312: LIST
99313: LIST
99314: LIST
99315: LIST
99316: LIST
99317: LIST
99318: LIST
99319: LIST
99320: LIST
99321: LIST
99322: PUSH
99323: EMPTY
99324: LIST
99325: LIST
99326: ST_TO_ADDR
99327: GO 99570
99329: LD_INT 19
99331: DOUBLE
99332: EQUAL
99333: IFTRUE 99337
99335: GO 99569
99337: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99338: LD_ADDR_VAR 0 2
99342: PUSH
99343: LD_INT 1
99345: PUSH
99346: LD_INT 2
99348: PUSH
99349: LD_INT 3
99351: PUSH
99352: LD_INT 4
99354: PUSH
99355: LD_INT 5
99357: PUSH
99358: LD_INT 6
99360: PUSH
99361: LD_INT 7
99363: PUSH
99364: LD_INT 8
99366: PUSH
99367: LD_INT 9
99369: PUSH
99370: LD_INT 10
99372: PUSH
99373: LD_INT 11
99375: PUSH
99376: LD_INT 12
99378: PUSH
99379: LD_INT 13
99381: PUSH
99382: LD_INT 14
99384: PUSH
99385: LD_INT 15
99387: PUSH
99388: LD_INT 16
99390: PUSH
99391: LD_INT 17
99393: PUSH
99394: LD_INT 18
99396: PUSH
99397: LD_INT 19
99399: PUSH
99400: LD_INT 20
99402: PUSH
99403: LD_INT 21
99405: PUSH
99406: LD_INT 22
99408: PUSH
99409: LD_INT 23
99411: PUSH
99412: LD_INT 24
99414: PUSH
99415: LD_INT 25
99417: PUSH
99418: LD_INT 26
99420: PUSH
99421: LD_INT 27
99423: PUSH
99424: LD_INT 28
99426: PUSH
99427: LD_INT 29
99429: PUSH
99430: LD_INT 30
99432: PUSH
99433: LD_INT 31
99435: PUSH
99436: LD_INT 32
99438: PUSH
99439: LD_INT 33
99441: PUSH
99442: LD_INT 34
99444: PUSH
99445: LD_INT 35
99447: PUSH
99448: LD_INT 36
99450: PUSH
99451: EMPTY
99452: LIST
99453: LIST
99454: LIST
99455: LIST
99456: LIST
99457: LIST
99458: LIST
99459: LIST
99460: LIST
99461: LIST
99462: LIST
99463: LIST
99464: LIST
99465: LIST
99466: LIST
99467: LIST
99468: LIST
99469: LIST
99470: LIST
99471: LIST
99472: LIST
99473: LIST
99474: LIST
99475: LIST
99476: LIST
99477: LIST
99478: LIST
99479: LIST
99480: LIST
99481: LIST
99482: LIST
99483: LIST
99484: LIST
99485: LIST
99486: LIST
99487: LIST
99488: PUSH
99489: LD_INT 101
99491: PUSH
99492: LD_INT 102
99494: PUSH
99495: LD_INT 103
99497: PUSH
99498: LD_INT 104
99500: PUSH
99501: LD_INT 105
99503: PUSH
99504: LD_INT 106
99506: PUSH
99507: LD_INT 107
99509: PUSH
99510: LD_INT 108
99512: PUSH
99513: LD_INT 109
99515: PUSH
99516: LD_INT 110
99518: PUSH
99519: LD_INT 111
99521: PUSH
99522: LD_INT 112
99524: PUSH
99525: LD_INT 113
99527: PUSH
99528: LD_INT 114
99530: PUSH
99531: LD_INT 115
99533: PUSH
99534: LD_INT 116
99536: PUSH
99537: LD_INT 117
99539: PUSH
99540: LD_INT 118
99542: PUSH
99543: EMPTY
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: LIST
99551: LIST
99552: LIST
99553: LIST
99554: LIST
99555: LIST
99556: LIST
99557: LIST
99558: LIST
99559: LIST
99560: LIST
99561: LIST
99562: PUSH
99563: EMPTY
99564: LIST
99565: LIST
99566: ST_TO_ADDR
99567: GO 99570
99569: POP
// end else
99570: GO 99801
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99572: LD_ADDR_VAR 0 2
99576: PUSH
99577: LD_INT 1
99579: PUSH
99580: LD_INT 2
99582: PUSH
99583: LD_INT 3
99585: PUSH
99586: LD_INT 4
99588: PUSH
99589: LD_INT 5
99591: PUSH
99592: LD_INT 6
99594: PUSH
99595: LD_INT 7
99597: PUSH
99598: LD_INT 8
99600: PUSH
99601: LD_INT 9
99603: PUSH
99604: LD_INT 10
99606: PUSH
99607: LD_INT 11
99609: PUSH
99610: LD_INT 12
99612: PUSH
99613: LD_INT 13
99615: PUSH
99616: LD_INT 14
99618: PUSH
99619: LD_INT 15
99621: PUSH
99622: LD_INT 16
99624: PUSH
99625: LD_INT 17
99627: PUSH
99628: LD_INT 18
99630: PUSH
99631: LD_INT 19
99633: PUSH
99634: LD_INT 20
99636: PUSH
99637: LD_INT 21
99639: PUSH
99640: LD_INT 22
99642: PUSH
99643: LD_INT 23
99645: PUSH
99646: LD_INT 24
99648: PUSH
99649: LD_INT 25
99651: PUSH
99652: LD_INT 26
99654: PUSH
99655: LD_INT 27
99657: PUSH
99658: LD_INT 28
99660: PUSH
99661: LD_INT 29
99663: PUSH
99664: LD_INT 30
99666: PUSH
99667: LD_INT 31
99669: PUSH
99670: LD_INT 32
99672: PUSH
99673: LD_INT 33
99675: PUSH
99676: LD_INT 34
99678: PUSH
99679: LD_INT 35
99681: PUSH
99682: LD_INT 36
99684: PUSH
99685: EMPTY
99686: LIST
99687: LIST
99688: LIST
99689: LIST
99690: LIST
99691: LIST
99692: LIST
99693: LIST
99694: LIST
99695: LIST
99696: LIST
99697: LIST
99698: LIST
99699: LIST
99700: LIST
99701: LIST
99702: LIST
99703: LIST
99704: LIST
99705: LIST
99706: LIST
99707: LIST
99708: LIST
99709: LIST
99710: LIST
99711: LIST
99712: LIST
99713: LIST
99714: LIST
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: LIST
99720: LIST
99721: LIST
99722: PUSH
99723: LD_INT 101
99725: PUSH
99726: LD_INT 102
99728: PUSH
99729: LD_INT 103
99731: PUSH
99732: LD_INT 104
99734: PUSH
99735: LD_INT 105
99737: PUSH
99738: LD_INT 106
99740: PUSH
99741: LD_INT 107
99743: PUSH
99744: LD_INT 108
99746: PUSH
99747: LD_INT 109
99749: PUSH
99750: LD_INT 110
99752: PUSH
99753: LD_INT 111
99755: PUSH
99756: LD_INT 112
99758: PUSH
99759: LD_INT 113
99761: PUSH
99762: LD_INT 114
99764: PUSH
99765: LD_INT 115
99767: PUSH
99768: LD_INT 116
99770: PUSH
99771: LD_INT 117
99773: PUSH
99774: LD_INT 118
99776: PUSH
99777: EMPTY
99778: LIST
99779: LIST
99780: LIST
99781: LIST
99782: LIST
99783: LIST
99784: LIST
99785: LIST
99786: LIST
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: LIST
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: PUSH
99797: EMPTY
99798: LIST
99799: LIST
99800: ST_TO_ADDR
// if result then
99801: LD_VAR 0 2
99805: IFFALSE 100591
// begin normal :=  ;
99807: LD_ADDR_VAR 0 5
99811: PUSH
99812: LD_STRING 
99814: ST_TO_ADDR
// hardcore :=  ;
99815: LD_ADDR_VAR 0 6
99819: PUSH
99820: LD_STRING 
99822: ST_TO_ADDR
// active :=  ;
99823: LD_ADDR_VAR 0 7
99827: PUSH
99828: LD_STRING 
99830: ST_TO_ADDR
// for i = 1 to normalCounter do
99831: LD_ADDR_VAR 0 8
99835: PUSH
99836: DOUBLE
99837: LD_INT 1
99839: DEC
99840: ST_TO_ADDR
99841: LD_EXP 78
99845: PUSH
99846: FOR_TO
99847: IFFALSE 99948
// begin tmp := 0 ;
99849: LD_ADDR_VAR 0 3
99853: PUSH
99854: LD_STRING 0
99856: ST_TO_ADDR
// if result [ 1 ] then
99857: LD_VAR 0 2
99861: PUSH
99862: LD_INT 1
99864: ARRAY
99865: IFFALSE 99930
// if result [ 1 ] [ 1 ] = i then
99867: LD_VAR 0 2
99871: PUSH
99872: LD_INT 1
99874: ARRAY
99875: PUSH
99876: LD_INT 1
99878: ARRAY
99879: PUSH
99880: LD_VAR 0 8
99884: EQUAL
99885: IFFALSE 99930
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
99887: LD_ADDR_VAR 0 2
99891: PUSH
99892: LD_VAR 0 2
99896: PPUSH
99897: LD_INT 1
99899: PPUSH
99900: LD_VAR 0 2
99904: PUSH
99905: LD_INT 1
99907: ARRAY
99908: PPUSH
99909: LD_INT 1
99911: PPUSH
99912: CALL_OW 3
99916: PPUSH
99917: CALL_OW 1
99921: ST_TO_ADDR
// tmp := 1 ;
99922: LD_ADDR_VAR 0 3
99926: PUSH
99927: LD_STRING 1
99929: ST_TO_ADDR
// end ; normal := normal & tmp ;
99930: LD_ADDR_VAR 0 5
99934: PUSH
99935: LD_VAR 0 5
99939: PUSH
99940: LD_VAR 0 3
99944: STR
99945: ST_TO_ADDR
// end ;
99946: GO 99846
99948: POP
99949: POP
// for i = 1 to hardcoreCounter do
99950: LD_ADDR_VAR 0 8
99954: PUSH
99955: DOUBLE
99956: LD_INT 1
99958: DEC
99959: ST_TO_ADDR
99960: LD_EXP 79
99964: PUSH
99965: FOR_TO
99966: IFFALSE 100071
// begin tmp := 0 ;
99968: LD_ADDR_VAR 0 3
99972: PUSH
99973: LD_STRING 0
99975: ST_TO_ADDR
// if result [ 2 ] then
99976: LD_VAR 0 2
99980: PUSH
99981: LD_INT 2
99983: ARRAY
99984: IFFALSE 100053
// if result [ 2 ] [ 1 ] = 100 + i then
99986: LD_VAR 0 2
99990: PUSH
99991: LD_INT 2
99993: ARRAY
99994: PUSH
99995: LD_INT 1
99997: ARRAY
99998: PUSH
99999: LD_INT 100
100001: PUSH
100002: LD_VAR 0 8
100006: PLUS
100007: EQUAL
100008: IFFALSE 100053
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100010: LD_ADDR_VAR 0 2
100014: PUSH
100015: LD_VAR 0 2
100019: PPUSH
100020: LD_INT 2
100022: PPUSH
100023: LD_VAR 0 2
100027: PUSH
100028: LD_INT 2
100030: ARRAY
100031: PPUSH
100032: LD_INT 1
100034: PPUSH
100035: CALL_OW 3
100039: PPUSH
100040: CALL_OW 1
100044: ST_TO_ADDR
// tmp := 1 ;
100045: LD_ADDR_VAR 0 3
100049: PUSH
100050: LD_STRING 1
100052: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100053: LD_ADDR_VAR 0 6
100057: PUSH
100058: LD_VAR 0 6
100062: PUSH
100063: LD_VAR 0 3
100067: STR
100068: ST_TO_ADDR
// end ;
100069: GO 99965
100071: POP
100072: POP
// if isGameLoad then
100073: LD_VAR 0 1
100077: IFFALSE 100552
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100079: LD_ADDR_VAR 0 4
100083: PUSH
100084: LD_EXP 82
100088: PUSH
100089: LD_EXP 81
100093: PUSH
100094: LD_EXP 83
100098: PUSH
100099: LD_EXP 80
100103: PUSH
100104: LD_EXP 84
100108: PUSH
100109: LD_EXP 85
100113: PUSH
100114: LD_EXP 86
100118: PUSH
100119: LD_EXP 87
100123: PUSH
100124: LD_EXP 88
100128: PUSH
100129: LD_EXP 89
100133: PUSH
100134: LD_EXP 90
100138: PUSH
100139: LD_EXP 91
100143: PUSH
100144: LD_EXP 92
100148: PUSH
100149: LD_EXP 93
100153: PUSH
100154: LD_EXP 101
100158: PUSH
100159: LD_EXP 102
100163: PUSH
100164: LD_EXP 103
100168: PUSH
100169: LD_EXP 104
100173: PUSH
100174: LD_EXP 106
100178: PUSH
100179: LD_EXP 107
100183: PUSH
100184: LD_EXP 108
100188: PUSH
100189: LD_EXP 111
100193: PUSH
100194: LD_EXP 113
100198: PUSH
100199: LD_EXP 114
100203: PUSH
100204: LD_EXP 115
100208: PUSH
100209: LD_EXP 117
100213: PUSH
100214: LD_EXP 118
100218: PUSH
100219: LD_EXP 121
100223: PUSH
100224: LD_EXP 122
100228: PUSH
100229: LD_EXP 123
100233: PUSH
100234: LD_EXP 124
100238: PUSH
100239: LD_EXP 125
100243: PUSH
100244: LD_EXP 126
100248: PUSH
100249: LD_EXP 127
100253: PUSH
100254: LD_EXP 128
100258: PUSH
100259: LD_EXP 129
100263: PUSH
100264: LD_EXP 94
100268: PUSH
100269: LD_EXP 95
100273: PUSH
100274: LD_EXP 98
100278: PUSH
100279: LD_EXP 99
100283: PUSH
100284: LD_EXP 100
100288: PUSH
100289: LD_EXP 96
100293: PUSH
100294: LD_EXP 97
100298: PUSH
100299: LD_EXP 105
100303: PUSH
100304: LD_EXP 109
100308: PUSH
100309: LD_EXP 110
100313: PUSH
100314: LD_EXP 112
100318: PUSH
100319: LD_EXP 116
100323: PUSH
100324: LD_EXP 119
100328: PUSH
100329: LD_EXP 120
100333: PUSH
100334: LD_EXP 130
100338: PUSH
100339: LD_EXP 131
100343: PUSH
100344: LD_EXP 132
100348: PUSH
100349: LD_EXP 133
100353: PUSH
100354: EMPTY
100355: LIST
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: LIST
100361: LIST
100362: LIST
100363: LIST
100364: LIST
100365: LIST
100366: LIST
100367: LIST
100368: LIST
100369: LIST
100370: LIST
100371: LIST
100372: LIST
100373: LIST
100374: LIST
100375: LIST
100376: LIST
100377: LIST
100378: LIST
100379: LIST
100380: LIST
100381: LIST
100382: LIST
100383: LIST
100384: LIST
100385: LIST
100386: LIST
100387: LIST
100388: LIST
100389: LIST
100390: LIST
100391: LIST
100392: LIST
100393: LIST
100394: LIST
100395: LIST
100396: LIST
100397: LIST
100398: LIST
100399: LIST
100400: LIST
100401: LIST
100402: LIST
100403: LIST
100404: LIST
100405: LIST
100406: LIST
100407: LIST
100408: LIST
100409: ST_TO_ADDR
// tmp :=  ;
100410: LD_ADDR_VAR 0 3
100414: PUSH
100415: LD_STRING 
100417: ST_TO_ADDR
// for i = 1 to normalCounter do
100418: LD_ADDR_VAR 0 8
100422: PUSH
100423: DOUBLE
100424: LD_INT 1
100426: DEC
100427: ST_TO_ADDR
100428: LD_EXP 78
100432: PUSH
100433: FOR_TO
100434: IFFALSE 100470
// begin if flags [ i ] then
100436: LD_VAR 0 4
100440: PUSH
100441: LD_VAR 0 8
100445: ARRAY
100446: IFFALSE 100468
// tmp := tmp & i & ; ;
100448: LD_ADDR_VAR 0 3
100452: PUSH
100453: LD_VAR 0 3
100457: PUSH
100458: LD_VAR 0 8
100462: STR
100463: PUSH
100464: LD_STRING ;
100466: STR
100467: ST_TO_ADDR
// end ;
100468: GO 100433
100470: POP
100471: POP
// for i = 1 to hardcoreCounter do
100472: LD_ADDR_VAR 0 8
100476: PUSH
100477: DOUBLE
100478: LD_INT 1
100480: DEC
100481: ST_TO_ADDR
100482: LD_EXP 79
100486: PUSH
100487: FOR_TO
100488: IFFALSE 100534
// begin if flags [ normalCounter + i ] then
100490: LD_VAR 0 4
100494: PUSH
100495: LD_EXP 78
100499: PUSH
100500: LD_VAR 0 8
100504: PLUS
100505: ARRAY
100506: IFFALSE 100532
// tmp := tmp & ( 100 + i ) & ; ;
100508: LD_ADDR_VAR 0 3
100512: PUSH
100513: LD_VAR 0 3
100517: PUSH
100518: LD_INT 100
100520: PUSH
100521: LD_VAR 0 8
100525: PLUS
100526: STR
100527: PUSH
100528: LD_STRING ;
100530: STR
100531: ST_TO_ADDR
// end ;
100532: GO 100487
100534: POP
100535: POP
// if tmp then
100536: LD_VAR 0 3
100540: IFFALSE 100552
// active := tmp ;
100542: LD_ADDR_VAR 0 7
100546: PUSH
100547: LD_VAR 0 3
100551: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100552: LD_STRING getStreamItemsFromMission("
100554: PUSH
100555: LD_VAR 0 5
100559: STR
100560: PUSH
100561: LD_STRING ","
100563: STR
100564: PUSH
100565: LD_VAR 0 6
100569: STR
100570: PUSH
100571: LD_STRING ","
100573: STR
100574: PUSH
100575: LD_VAR 0 7
100579: STR
100580: PUSH
100581: LD_STRING ")
100583: STR
100584: PPUSH
100585: CALL_OW 559
// end else
100589: GO 100598
// ToLua ( getStreamItemsFromMission("","","") ) ;
100591: LD_STRING getStreamItemsFromMission("","","")
100593: PPUSH
100594: CALL_OW 559
// end ;
100598: LD_VAR 0 2
100602: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100603: LD_EXP 77
100607: PUSH
100608: LD_EXP 82
100612: AND
100613: IFFALSE 100737
100615: GO 100617
100617: DISABLE
100618: LD_INT 0
100620: PPUSH
100621: PPUSH
// begin enable ;
100622: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100623: LD_ADDR_VAR 0 2
100627: PUSH
100628: LD_INT 22
100630: PUSH
100631: LD_OWVAR 2
100635: PUSH
100636: EMPTY
100637: LIST
100638: LIST
100639: PUSH
100640: LD_INT 2
100642: PUSH
100643: LD_INT 34
100645: PUSH
100646: LD_INT 7
100648: PUSH
100649: EMPTY
100650: LIST
100651: LIST
100652: PUSH
100653: LD_INT 34
100655: PUSH
100656: LD_INT 45
100658: PUSH
100659: EMPTY
100660: LIST
100661: LIST
100662: PUSH
100663: LD_INT 34
100665: PUSH
100666: LD_INT 28
100668: PUSH
100669: EMPTY
100670: LIST
100671: LIST
100672: PUSH
100673: LD_INT 34
100675: PUSH
100676: LD_INT 47
100678: PUSH
100679: EMPTY
100680: LIST
100681: LIST
100682: PUSH
100683: EMPTY
100684: LIST
100685: LIST
100686: LIST
100687: LIST
100688: LIST
100689: PUSH
100690: EMPTY
100691: LIST
100692: LIST
100693: PPUSH
100694: CALL_OW 69
100698: ST_TO_ADDR
// if not tmp then
100699: LD_VAR 0 2
100703: NOT
100704: IFFALSE 100708
// exit ;
100706: GO 100737
// for i in tmp do
100708: LD_ADDR_VAR 0 1
100712: PUSH
100713: LD_VAR 0 2
100717: PUSH
100718: FOR_IN
100719: IFFALSE 100735
// begin SetLives ( i , 0 ) ;
100721: LD_VAR 0 1
100725: PPUSH
100726: LD_INT 0
100728: PPUSH
100729: CALL_OW 234
// end ;
100733: GO 100718
100735: POP
100736: POP
// end ;
100737: PPOPN 2
100739: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100740: LD_EXP 77
100744: PUSH
100745: LD_EXP 83
100749: AND
100750: IFFALSE 100834
100752: GO 100754
100754: DISABLE
100755: LD_INT 0
100757: PPUSH
100758: PPUSH
// begin enable ;
100759: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100760: LD_ADDR_VAR 0 2
100764: PUSH
100765: LD_INT 22
100767: PUSH
100768: LD_OWVAR 2
100772: PUSH
100773: EMPTY
100774: LIST
100775: LIST
100776: PUSH
100777: LD_INT 32
100779: PUSH
100780: LD_INT 3
100782: PUSH
100783: EMPTY
100784: LIST
100785: LIST
100786: PUSH
100787: EMPTY
100788: LIST
100789: LIST
100790: PPUSH
100791: CALL_OW 69
100795: ST_TO_ADDR
// if not tmp then
100796: LD_VAR 0 2
100800: NOT
100801: IFFALSE 100805
// exit ;
100803: GO 100834
// for i in tmp do
100805: LD_ADDR_VAR 0 1
100809: PUSH
100810: LD_VAR 0 2
100814: PUSH
100815: FOR_IN
100816: IFFALSE 100832
// begin SetLives ( i , 0 ) ;
100818: LD_VAR 0 1
100822: PPUSH
100823: LD_INT 0
100825: PPUSH
100826: CALL_OW 234
// end ;
100830: GO 100815
100832: POP
100833: POP
// end ;
100834: PPOPN 2
100836: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100837: LD_EXP 77
100841: PUSH
100842: LD_EXP 80
100846: AND
100847: IFFALSE 100940
100849: GO 100851
100851: DISABLE
100852: LD_INT 0
100854: PPUSH
// begin enable ;
100855: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100856: LD_ADDR_VAR 0 1
100860: PUSH
100861: LD_INT 22
100863: PUSH
100864: LD_OWVAR 2
100868: PUSH
100869: EMPTY
100870: LIST
100871: LIST
100872: PUSH
100873: LD_INT 2
100875: PUSH
100876: LD_INT 25
100878: PUSH
100879: LD_INT 5
100881: PUSH
100882: EMPTY
100883: LIST
100884: LIST
100885: PUSH
100886: LD_INT 25
100888: PUSH
100889: LD_INT 9
100891: PUSH
100892: EMPTY
100893: LIST
100894: LIST
100895: PUSH
100896: LD_INT 25
100898: PUSH
100899: LD_INT 8
100901: PUSH
100902: EMPTY
100903: LIST
100904: LIST
100905: PUSH
100906: EMPTY
100907: LIST
100908: LIST
100909: LIST
100910: LIST
100911: PUSH
100912: EMPTY
100913: LIST
100914: LIST
100915: PPUSH
100916: CALL_OW 69
100920: PUSH
100921: FOR_IN
100922: IFFALSE 100938
// begin SetClass ( i , 1 ) ;
100924: LD_VAR 0 1
100928: PPUSH
100929: LD_INT 1
100931: PPUSH
100932: CALL_OW 336
// end ;
100936: GO 100921
100938: POP
100939: POP
// end ;
100940: PPOPN 1
100942: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
100943: LD_EXP 77
100947: PUSH
100948: LD_EXP 81
100952: AND
100953: PUSH
100954: LD_OWVAR 65
100958: PUSH
100959: LD_INT 7
100961: LESS
100962: AND
100963: IFFALSE 100977
100965: GO 100967
100967: DISABLE
// begin enable ;
100968: ENABLE
// game_speed := 7 ;
100969: LD_ADDR_OWVAR 65
100973: PUSH
100974: LD_INT 7
100976: ST_TO_ADDR
// end ;
100977: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
100978: LD_EXP 77
100982: PUSH
100983: LD_EXP 84
100987: AND
100988: IFFALSE 101190
100990: GO 100992
100992: DISABLE
100993: LD_INT 0
100995: PPUSH
100996: PPUSH
100997: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
100998: LD_ADDR_VAR 0 3
101002: PUSH
101003: LD_INT 81
101005: PUSH
101006: LD_OWVAR 2
101010: PUSH
101011: EMPTY
101012: LIST
101013: LIST
101014: PUSH
101015: LD_INT 21
101017: PUSH
101018: LD_INT 1
101020: PUSH
101021: EMPTY
101022: LIST
101023: LIST
101024: PUSH
101025: EMPTY
101026: LIST
101027: LIST
101028: PPUSH
101029: CALL_OW 69
101033: ST_TO_ADDR
// if not tmp then
101034: LD_VAR 0 3
101038: NOT
101039: IFFALSE 101043
// exit ;
101041: GO 101190
// if tmp > 5 then
101043: LD_VAR 0 3
101047: PUSH
101048: LD_INT 5
101050: GREATER
101051: IFFALSE 101063
// k := 5 else
101053: LD_ADDR_VAR 0 2
101057: PUSH
101058: LD_INT 5
101060: ST_TO_ADDR
101061: GO 101073
// k := tmp ;
101063: LD_ADDR_VAR 0 2
101067: PUSH
101068: LD_VAR 0 3
101072: ST_TO_ADDR
// for i := 1 to k do
101073: LD_ADDR_VAR 0 1
101077: PUSH
101078: DOUBLE
101079: LD_INT 1
101081: DEC
101082: ST_TO_ADDR
101083: LD_VAR 0 2
101087: PUSH
101088: FOR_TO
101089: IFFALSE 101188
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101091: LD_VAR 0 3
101095: PUSH
101096: LD_VAR 0 1
101100: ARRAY
101101: PPUSH
101102: LD_VAR 0 1
101106: PUSH
101107: LD_INT 4
101109: MOD
101110: PUSH
101111: LD_INT 1
101113: PLUS
101114: PPUSH
101115: CALL_OW 259
101119: PUSH
101120: LD_INT 10
101122: LESS
101123: IFFALSE 101186
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101125: LD_VAR 0 3
101129: PUSH
101130: LD_VAR 0 1
101134: ARRAY
101135: PPUSH
101136: LD_VAR 0 1
101140: PUSH
101141: LD_INT 4
101143: MOD
101144: PUSH
101145: LD_INT 1
101147: PLUS
101148: PPUSH
101149: LD_VAR 0 3
101153: PUSH
101154: LD_VAR 0 1
101158: ARRAY
101159: PPUSH
101160: LD_VAR 0 1
101164: PUSH
101165: LD_INT 4
101167: MOD
101168: PUSH
101169: LD_INT 1
101171: PLUS
101172: PPUSH
101173: CALL_OW 259
101177: PUSH
101178: LD_INT 1
101180: PLUS
101181: PPUSH
101182: CALL_OW 237
101186: GO 101088
101188: POP
101189: POP
// end ;
101190: PPOPN 3
101192: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101193: LD_EXP 77
101197: PUSH
101198: LD_EXP 85
101202: AND
101203: IFFALSE 101223
101205: GO 101207
101207: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101208: LD_INT 4
101210: PPUSH
101211: LD_OWVAR 2
101215: PPUSH
101216: LD_INT 0
101218: PPUSH
101219: CALL_OW 324
101223: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101224: LD_EXP 77
101228: PUSH
101229: LD_EXP 114
101233: AND
101234: IFFALSE 101254
101236: GO 101238
101238: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101239: LD_INT 19
101241: PPUSH
101242: LD_OWVAR 2
101246: PPUSH
101247: LD_INT 0
101249: PPUSH
101250: CALL_OW 324
101254: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101255: LD_EXP 77
101259: PUSH
101260: LD_EXP 86
101264: AND
101265: IFFALSE 101367
101267: GO 101269
101269: DISABLE
101270: LD_INT 0
101272: PPUSH
101273: PPUSH
// begin enable ;
101274: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101275: LD_ADDR_VAR 0 2
101279: PUSH
101280: LD_INT 22
101282: PUSH
101283: LD_OWVAR 2
101287: PUSH
101288: EMPTY
101289: LIST
101290: LIST
101291: PUSH
101292: LD_INT 2
101294: PUSH
101295: LD_INT 34
101297: PUSH
101298: LD_INT 11
101300: PUSH
101301: EMPTY
101302: LIST
101303: LIST
101304: PUSH
101305: LD_INT 34
101307: PUSH
101308: LD_INT 30
101310: PUSH
101311: EMPTY
101312: LIST
101313: LIST
101314: PUSH
101315: EMPTY
101316: LIST
101317: LIST
101318: LIST
101319: PUSH
101320: EMPTY
101321: LIST
101322: LIST
101323: PPUSH
101324: CALL_OW 69
101328: ST_TO_ADDR
// if not tmp then
101329: LD_VAR 0 2
101333: NOT
101334: IFFALSE 101338
// exit ;
101336: GO 101367
// for i in tmp do
101338: LD_ADDR_VAR 0 1
101342: PUSH
101343: LD_VAR 0 2
101347: PUSH
101348: FOR_IN
101349: IFFALSE 101365
// begin SetLives ( i , 0 ) ;
101351: LD_VAR 0 1
101355: PPUSH
101356: LD_INT 0
101358: PPUSH
101359: CALL_OW 234
// end ;
101363: GO 101348
101365: POP
101366: POP
// end ;
101367: PPOPN 2
101369: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101370: LD_EXP 77
101374: PUSH
101375: LD_EXP 87
101379: AND
101380: IFFALSE 101400
101382: GO 101384
101384: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101385: LD_INT 32
101387: PPUSH
101388: LD_OWVAR 2
101392: PPUSH
101393: LD_INT 0
101395: PPUSH
101396: CALL_OW 324
101400: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101401: LD_EXP 77
101405: PUSH
101406: LD_EXP 88
101410: AND
101411: IFFALSE 101592
101413: GO 101415
101415: DISABLE
101416: LD_INT 0
101418: PPUSH
101419: PPUSH
101420: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101421: LD_ADDR_VAR 0 2
101425: PUSH
101426: LD_INT 22
101428: PUSH
101429: LD_OWVAR 2
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: LD_INT 33
101440: PUSH
101441: LD_INT 3
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: PUSH
101448: EMPTY
101449: LIST
101450: LIST
101451: PPUSH
101452: CALL_OW 69
101456: ST_TO_ADDR
// if not tmp then
101457: LD_VAR 0 2
101461: NOT
101462: IFFALSE 101466
// exit ;
101464: GO 101592
// side := 0 ;
101466: LD_ADDR_VAR 0 3
101470: PUSH
101471: LD_INT 0
101473: ST_TO_ADDR
// for i := 1 to 8 do
101474: LD_ADDR_VAR 0 1
101478: PUSH
101479: DOUBLE
101480: LD_INT 1
101482: DEC
101483: ST_TO_ADDR
101484: LD_INT 8
101486: PUSH
101487: FOR_TO
101488: IFFALSE 101536
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101490: LD_OWVAR 2
101494: PUSH
101495: LD_VAR 0 1
101499: NONEQUAL
101500: PUSH
101501: LD_OWVAR 2
101505: PPUSH
101506: LD_VAR 0 1
101510: PPUSH
101511: CALL_OW 81
101515: PUSH
101516: LD_INT 2
101518: EQUAL
101519: AND
101520: IFFALSE 101534
// begin side := i ;
101522: LD_ADDR_VAR 0 3
101526: PUSH
101527: LD_VAR 0 1
101531: ST_TO_ADDR
// break ;
101532: GO 101536
// end ;
101534: GO 101487
101536: POP
101537: POP
// if not side then
101538: LD_VAR 0 3
101542: NOT
101543: IFFALSE 101547
// exit ;
101545: GO 101592
// for i := 1 to tmp do
101547: LD_ADDR_VAR 0 1
101551: PUSH
101552: DOUBLE
101553: LD_INT 1
101555: DEC
101556: ST_TO_ADDR
101557: LD_VAR 0 2
101561: PUSH
101562: FOR_TO
101563: IFFALSE 101590
// if Prob ( 60 ) then
101565: LD_INT 60
101567: PPUSH
101568: CALL_OW 13
101572: IFFALSE 101588
// SetSide ( i , side ) ;
101574: LD_VAR 0 1
101578: PPUSH
101579: LD_VAR 0 3
101583: PPUSH
101584: CALL_OW 235
101588: GO 101562
101590: POP
101591: POP
// end ;
101592: PPOPN 3
101594: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101595: LD_EXP 77
101599: PUSH
101600: LD_EXP 90
101604: AND
101605: IFFALSE 101724
101607: GO 101609
101609: DISABLE
101610: LD_INT 0
101612: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101613: LD_ADDR_VAR 0 1
101617: PUSH
101618: LD_INT 22
101620: PUSH
101621: LD_OWVAR 2
101625: PUSH
101626: EMPTY
101627: LIST
101628: LIST
101629: PUSH
101630: LD_INT 21
101632: PUSH
101633: LD_INT 1
101635: PUSH
101636: EMPTY
101637: LIST
101638: LIST
101639: PUSH
101640: LD_INT 3
101642: PUSH
101643: LD_INT 23
101645: PUSH
101646: LD_INT 0
101648: PUSH
101649: EMPTY
101650: LIST
101651: LIST
101652: PUSH
101653: EMPTY
101654: LIST
101655: LIST
101656: PUSH
101657: EMPTY
101658: LIST
101659: LIST
101660: LIST
101661: PPUSH
101662: CALL_OW 69
101666: PUSH
101667: FOR_IN
101668: IFFALSE 101722
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101670: LD_VAR 0 1
101674: PPUSH
101675: CALL_OW 257
101679: PUSH
101680: LD_INT 1
101682: PUSH
101683: LD_INT 2
101685: PUSH
101686: LD_INT 3
101688: PUSH
101689: LD_INT 4
101691: PUSH
101692: EMPTY
101693: LIST
101694: LIST
101695: LIST
101696: LIST
101697: IN
101698: IFFALSE 101720
// SetClass ( un , rand ( 1 , 4 ) ) ;
101700: LD_VAR 0 1
101704: PPUSH
101705: LD_INT 1
101707: PPUSH
101708: LD_INT 4
101710: PPUSH
101711: CALL_OW 12
101715: PPUSH
101716: CALL_OW 336
101720: GO 101667
101722: POP
101723: POP
// end ;
101724: PPOPN 1
101726: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101727: LD_EXP 77
101731: PUSH
101732: LD_EXP 89
101736: AND
101737: IFFALSE 101816
101739: GO 101741
101741: DISABLE
101742: LD_INT 0
101744: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101745: LD_ADDR_VAR 0 1
101749: PUSH
101750: LD_INT 22
101752: PUSH
101753: LD_OWVAR 2
101757: PUSH
101758: EMPTY
101759: LIST
101760: LIST
101761: PUSH
101762: LD_INT 21
101764: PUSH
101765: LD_INT 3
101767: PUSH
101768: EMPTY
101769: LIST
101770: LIST
101771: PUSH
101772: EMPTY
101773: LIST
101774: LIST
101775: PPUSH
101776: CALL_OW 69
101780: ST_TO_ADDR
// if not tmp then
101781: LD_VAR 0 1
101785: NOT
101786: IFFALSE 101790
// exit ;
101788: GO 101816
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101790: LD_VAR 0 1
101794: PUSH
101795: LD_INT 1
101797: PPUSH
101798: LD_VAR 0 1
101802: PPUSH
101803: CALL_OW 12
101807: ARRAY
101808: PPUSH
101809: LD_INT 100
101811: PPUSH
101812: CALL_OW 234
// end ;
101816: PPOPN 1
101818: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101819: LD_EXP 77
101823: PUSH
101824: LD_EXP 91
101828: AND
101829: IFFALSE 101927
101831: GO 101833
101833: DISABLE
101834: LD_INT 0
101836: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101837: LD_ADDR_VAR 0 1
101841: PUSH
101842: LD_INT 22
101844: PUSH
101845: LD_OWVAR 2
101849: PUSH
101850: EMPTY
101851: LIST
101852: LIST
101853: PUSH
101854: LD_INT 21
101856: PUSH
101857: LD_INT 1
101859: PUSH
101860: EMPTY
101861: LIST
101862: LIST
101863: PUSH
101864: EMPTY
101865: LIST
101866: LIST
101867: PPUSH
101868: CALL_OW 69
101872: ST_TO_ADDR
// if not tmp then
101873: LD_VAR 0 1
101877: NOT
101878: IFFALSE 101882
// exit ;
101880: GO 101927
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101882: LD_VAR 0 1
101886: PUSH
101887: LD_INT 1
101889: PPUSH
101890: LD_VAR 0 1
101894: PPUSH
101895: CALL_OW 12
101899: ARRAY
101900: PPUSH
101901: LD_INT 1
101903: PPUSH
101904: LD_INT 4
101906: PPUSH
101907: CALL_OW 12
101911: PPUSH
101912: LD_INT 3000
101914: PPUSH
101915: LD_INT 9000
101917: PPUSH
101918: CALL_OW 12
101922: PPUSH
101923: CALL_OW 492
// end ;
101927: PPOPN 1
101929: END
// every 0 0$1 trigger StreamModeActive and sDepot do
101930: LD_EXP 77
101934: PUSH
101935: LD_EXP 92
101939: AND
101940: IFFALSE 101960
101942: GO 101944
101944: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
101945: LD_INT 1
101947: PPUSH
101948: LD_OWVAR 2
101952: PPUSH
101953: LD_INT 0
101955: PPUSH
101956: CALL_OW 324
101960: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
101961: LD_EXP 77
101965: PUSH
101966: LD_EXP 93
101970: AND
101971: IFFALSE 102054
101973: GO 101975
101975: DISABLE
101976: LD_INT 0
101978: PPUSH
101979: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101980: LD_ADDR_VAR 0 2
101984: PUSH
101985: LD_INT 22
101987: PUSH
101988: LD_OWVAR 2
101992: PUSH
101993: EMPTY
101994: LIST
101995: LIST
101996: PUSH
101997: LD_INT 21
101999: PUSH
102000: LD_INT 3
102002: PUSH
102003: EMPTY
102004: LIST
102005: LIST
102006: PUSH
102007: EMPTY
102008: LIST
102009: LIST
102010: PPUSH
102011: CALL_OW 69
102015: ST_TO_ADDR
// if not tmp then
102016: LD_VAR 0 2
102020: NOT
102021: IFFALSE 102025
// exit ;
102023: GO 102054
// for i in tmp do
102025: LD_ADDR_VAR 0 1
102029: PUSH
102030: LD_VAR 0 2
102034: PUSH
102035: FOR_IN
102036: IFFALSE 102052
// SetBLevel ( i , 10 ) ;
102038: LD_VAR 0 1
102042: PPUSH
102043: LD_INT 10
102045: PPUSH
102046: CALL_OW 241
102050: GO 102035
102052: POP
102053: POP
// end ;
102054: PPOPN 2
102056: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102057: LD_EXP 77
102061: PUSH
102062: LD_EXP 94
102066: AND
102067: IFFALSE 102178
102069: GO 102071
102071: DISABLE
102072: LD_INT 0
102074: PPUSH
102075: PPUSH
102076: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102077: LD_ADDR_VAR 0 3
102081: PUSH
102082: LD_INT 22
102084: PUSH
102085: LD_OWVAR 2
102089: PUSH
102090: EMPTY
102091: LIST
102092: LIST
102093: PUSH
102094: LD_INT 25
102096: PUSH
102097: LD_INT 1
102099: PUSH
102100: EMPTY
102101: LIST
102102: LIST
102103: PUSH
102104: EMPTY
102105: LIST
102106: LIST
102107: PPUSH
102108: CALL_OW 69
102112: ST_TO_ADDR
// if not tmp then
102113: LD_VAR 0 3
102117: NOT
102118: IFFALSE 102122
// exit ;
102120: GO 102178
// un := tmp [ rand ( 1 , tmp ) ] ;
102122: LD_ADDR_VAR 0 2
102126: PUSH
102127: LD_VAR 0 3
102131: PUSH
102132: LD_INT 1
102134: PPUSH
102135: LD_VAR 0 3
102139: PPUSH
102140: CALL_OW 12
102144: ARRAY
102145: ST_TO_ADDR
// if Crawls ( un ) then
102146: LD_VAR 0 2
102150: PPUSH
102151: CALL_OW 318
102155: IFFALSE 102166
// ComWalk ( un ) ;
102157: LD_VAR 0 2
102161: PPUSH
102162: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102166: LD_VAR 0 2
102170: PPUSH
102171: LD_INT 5
102173: PPUSH
102174: CALL_OW 336
// end ;
102178: PPOPN 3
102180: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102181: LD_EXP 77
102185: PUSH
102186: LD_EXP 95
102190: AND
102191: PUSH
102192: LD_OWVAR 67
102196: PUSH
102197: LD_INT 4
102199: LESS
102200: AND
102201: IFFALSE 102220
102203: GO 102205
102205: DISABLE
// begin Difficulty := Difficulty + 1 ;
102206: LD_ADDR_OWVAR 67
102210: PUSH
102211: LD_OWVAR 67
102215: PUSH
102216: LD_INT 1
102218: PLUS
102219: ST_TO_ADDR
// end ;
102220: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102221: LD_EXP 77
102225: PUSH
102226: LD_EXP 96
102230: AND
102231: IFFALSE 102334
102233: GO 102235
102235: DISABLE
102236: LD_INT 0
102238: PPUSH
// begin for i := 1 to 5 do
102239: LD_ADDR_VAR 0 1
102243: PUSH
102244: DOUBLE
102245: LD_INT 1
102247: DEC
102248: ST_TO_ADDR
102249: LD_INT 5
102251: PUSH
102252: FOR_TO
102253: IFFALSE 102332
// begin uc_nation := nation_nature ;
102255: LD_ADDR_OWVAR 21
102259: PUSH
102260: LD_INT 0
102262: ST_TO_ADDR
// uc_side := 0 ;
102263: LD_ADDR_OWVAR 20
102267: PUSH
102268: LD_INT 0
102270: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102271: LD_ADDR_OWVAR 29
102275: PUSH
102276: LD_INT 12
102278: PUSH
102279: LD_INT 12
102281: PUSH
102282: EMPTY
102283: LIST
102284: LIST
102285: ST_TO_ADDR
// hc_agressivity := 20 ;
102286: LD_ADDR_OWVAR 35
102290: PUSH
102291: LD_INT 20
102293: ST_TO_ADDR
// hc_class := class_tiger ;
102294: LD_ADDR_OWVAR 28
102298: PUSH
102299: LD_INT 14
102301: ST_TO_ADDR
// hc_gallery :=  ;
102302: LD_ADDR_OWVAR 33
102306: PUSH
102307: LD_STRING 
102309: ST_TO_ADDR
// hc_name :=  ;
102310: LD_ADDR_OWVAR 26
102314: PUSH
102315: LD_STRING 
102317: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102318: CALL_OW 44
102322: PPUSH
102323: LD_INT 0
102325: PPUSH
102326: CALL_OW 51
// end ;
102330: GO 102252
102332: POP
102333: POP
// end ;
102334: PPOPN 1
102336: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102337: LD_EXP 77
102341: PUSH
102342: LD_EXP 97
102346: AND
102347: IFFALSE 102356
102349: GO 102351
102351: DISABLE
// StreamSibBomb ;
102352: CALL 102357 0 0
102356: END
// export function StreamSibBomb ; var i , x , y ; begin
102357: LD_INT 0
102359: PPUSH
102360: PPUSH
102361: PPUSH
102362: PPUSH
// result := false ;
102363: LD_ADDR_VAR 0 1
102367: PUSH
102368: LD_INT 0
102370: ST_TO_ADDR
// for i := 1 to 16 do
102371: LD_ADDR_VAR 0 2
102375: PUSH
102376: DOUBLE
102377: LD_INT 1
102379: DEC
102380: ST_TO_ADDR
102381: LD_INT 16
102383: PUSH
102384: FOR_TO
102385: IFFALSE 102584
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102387: LD_ADDR_VAR 0 3
102391: PUSH
102392: LD_INT 10
102394: PUSH
102395: LD_INT 20
102397: PUSH
102398: LD_INT 30
102400: PUSH
102401: LD_INT 40
102403: PUSH
102404: LD_INT 50
102406: PUSH
102407: LD_INT 60
102409: PUSH
102410: LD_INT 70
102412: PUSH
102413: LD_INT 80
102415: PUSH
102416: LD_INT 90
102418: PUSH
102419: LD_INT 100
102421: PUSH
102422: LD_INT 110
102424: PUSH
102425: LD_INT 120
102427: PUSH
102428: LD_INT 130
102430: PUSH
102431: LD_INT 140
102433: PUSH
102434: LD_INT 150
102436: PUSH
102437: EMPTY
102438: LIST
102439: LIST
102440: LIST
102441: LIST
102442: LIST
102443: LIST
102444: LIST
102445: LIST
102446: LIST
102447: LIST
102448: LIST
102449: LIST
102450: LIST
102451: LIST
102452: LIST
102453: PUSH
102454: LD_INT 1
102456: PPUSH
102457: LD_INT 15
102459: PPUSH
102460: CALL_OW 12
102464: ARRAY
102465: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102466: LD_ADDR_VAR 0 4
102470: PUSH
102471: LD_INT 10
102473: PUSH
102474: LD_INT 20
102476: PUSH
102477: LD_INT 30
102479: PUSH
102480: LD_INT 40
102482: PUSH
102483: LD_INT 50
102485: PUSH
102486: LD_INT 60
102488: PUSH
102489: LD_INT 70
102491: PUSH
102492: LD_INT 80
102494: PUSH
102495: LD_INT 90
102497: PUSH
102498: LD_INT 100
102500: PUSH
102501: LD_INT 110
102503: PUSH
102504: LD_INT 120
102506: PUSH
102507: LD_INT 130
102509: PUSH
102510: LD_INT 140
102512: PUSH
102513: LD_INT 150
102515: PUSH
102516: EMPTY
102517: LIST
102518: LIST
102519: LIST
102520: LIST
102521: LIST
102522: LIST
102523: LIST
102524: LIST
102525: LIST
102526: LIST
102527: LIST
102528: LIST
102529: LIST
102530: LIST
102531: LIST
102532: PUSH
102533: LD_INT 1
102535: PPUSH
102536: LD_INT 15
102538: PPUSH
102539: CALL_OW 12
102543: ARRAY
102544: ST_TO_ADDR
// if ValidHex ( x , y ) then
102545: LD_VAR 0 3
102549: PPUSH
102550: LD_VAR 0 4
102554: PPUSH
102555: CALL_OW 488
102559: IFFALSE 102582
// begin result := [ x , y ] ;
102561: LD_ADDR_VAR 0 1
102565: PUSH
102566: LD_VAR 0 3
102570: PUSH
102571: LD_VAR 0 4
102575: PUSH
102576: EMPTY
102577: LIST
102578: LIST
102579: ST_TO_ADDR
// break ;
102580: GO 102584
// end ; end ;
102582: GO 102384
102584: POP
102585: POP
// if result then
102586: LD_VAR 0 1
102590: IFFALSE 102650
// begin ToLua ( playSibBomb() ) ;
102592: LD_STRING playSibBomb()
102594: PPUSH
102595: CALL_OW 559
// wait ( 0 0$14 ) ;
102599: LD_INT 490
102601: PPUSH
102602: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102606: LD_VAR 0 1
102610: PUSH
102611: LD_INT 1
102613: ARRAY
102614: PPUSH
102615: LD_VAR 0 1
102619: PUSH
102620: LD_INT 2
102622: ARRAY
102623: PPUSH
102624: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102628: LD_VAR 0 1
102632: PUSH
102633: LD_INT 1
102635: ARRAY
102636: PPUSH
102637: LD_VAR 0 1
102641: PUSH
102642: LD_INT 2
102644: ARRAY
102645: PPUSH
102646: CALL_OW 429
// end ; end ;
102650: LD_VAR 0 1
102654: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102655: LD_EXP 77
102659: PUSH
102660: LD_EXP 99
102664: AND
102665: IFFALSE 102677
102667: GO 102669
102669: DISABLE
// YouLost (  ) ;
102670: LD_STRING 
102672: PPUSH
102673: CALL_OW 104
102677: END
// every 0 0$1 trigger StreamModeActive and sFog do
102678: LD_EXP 77
102682: PUSH
102683: LD_EXP 98
102687: AND
102688: IFFALSE 102702
102690: GO 102692
102692: DISABLE
// FogOff ( your_side ) ;
102693: LD_OWVAR 2
102697: PPUSH
102698: CALL_OW 344
102702: END
// every 0 0$1 trigger StreamModeActive and sSun do
102703: LD_EXP 77
102707: PUSH
102708: LD_EXP 100
102712: AND
102713: IFFALSE 102741
102715: GO 102717
102717: DISABLE
// begin solar_recharge_percent := 0 ;
102718: LD_ADDR_OWVAR 79
102722: PUSH
102723: LD_INT 0
102725: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102726: LD_INT 10500
102728: PPUSH
102729: CALL_OW 67
// solar_recharge_percent := 100 ;
102733: LD_ADDR_OWVAR 79
102737: PUSH
102738: LD_INT 100
102740: ST_TO_ADDR
// end ;
102741: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102742: LD_EXP 77
102746: PUSH
102747: LD_EXP 101
102751: AND
102752: IFFALSE 102991
102754: GO 102756
102756: DISABLE
102757: LD_INT 0
102759: PPUSH
102760: PPUSH
102761: PPUSH
// begin tmp := [ ] ;
102762: LD_ADDR_VAR 0 3
102766: PUSH
102767: EMPTY
102768: ST_TO_ADDR
// for i := 1 to 6 do
102769: LD_ADDR_VAR 0 1
102773: PUSH
102774: DOUBLE
102775: LD_INT 1
102777: DEC
102778: ST_TO_ADDR
102779: LD_INT 6
102781: PUSH
102782: FOR_TO
102783: IFFALSE 102888
// begin uc_nation := nation_nature ;
102785: LD_ADDR_OWVAR 21
102789: PUSH
102790: LD_INT 0
102792: ST_TO_ADDR
// uc_side := 0 ;
102793: LD_ADDR_OWVAR 20
102797: PUSH
102798: LD_INT 0
102800: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102801: LD_ADDR_OWVAR 29
102805: PUSH
102806: LD_INT 12
102808: PUSH
102809: LD_INT 12
102811: PUSH
102812: EMPTY
102813: LIST
102814: LIST
102815: ST_TO_ADDR
// hc_agressivity := 20 ;
102816: LD_ADDR_OWVAR 35
102820: PUSH
102821: LD_INT 20
102823: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102824: LD_ADDR_OWVAR 28
102828: PUSH
102829: LD_INT 17
102831: ST_TO_ADDR
// hc_gallery :=  ;
102832: LD_ADDR_OWVAR 33
102836: PUSH
102837: LD_STRING 
102839: ST_TO_ADDR
// hc_name :=  ;
102840: LD_ADDR_OWVAR 26
102844: PUSH
102845: LD_STRING 
102847: ST_TO_ADDR
// un := CreateHuman ;
102848: LD_ADDR_VAR 0 2
102852: PUSH
102853: CALL_OW 44
102857: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102858: LD_VAR 0 2
102862: PPUSH
102863: LD_INT 1
102865: PPUSH
102866: CALL_OW 51
// tmp := tmp ^ un ;
102870: LD_ADDR_VAR 0 3
102874: PUSH
102875: LD_VAR 0 3
102879: PUSH
102880: LD_VAR 0 2
102884: ADD
102885: ST_TO_ADDR
// end ;
102886: GO 102782
102888: POP
102889: POP
// repeat wait ( 0 0$1 ) ;
102890: LD_INT 35
102892: PPUSH
102893: CALL_OW 67
// for un in tmp do
102897: LD_ADDR_VAR 0 2
102901: PUSH
102902: LD_VAR 0 3
102906: PUSH
102907: FOR_IN
102908: IFFALSE 102982
// begin if IsDead ( un ) then
102910: LD_VAR 0 2
102914: PPUSH
102915: CALL_OW 301
102919: IFFALSE 102939
// begin tmp := tmp diff un ;
102921: LD_ADDR_VAR 0 3
102925: PUSH
102926: LD_VAR 0 3
102930: PUSH
102931: LD_VAR 0 2
102935: DIFF
102936: ST_TO_ADDR
// continue ;
102937: GO 102907
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
102939: LD_VAR 0 2
102943: PPUSH
102944: LD_INT 3
102946: PUSH
102947: LD_INT 22
102949: PUSH
102950: LD_INT 0
102952: PUSH
102953: EMPTY
102954: LIST
102955: LIST
102956: PUSH
102957: EMPTY
102958: LIST
102959: LIST
102960: PPUSH
102961: CALL_OW 69
102965: PPUSH
102966: LD_VAR 0 2
102970: PPUSH
102971: CALL_OW 74
102975: PPUSH
102976: CALL_OW 115
// end ;
102980: GO 102907
102982: POP
102983: POP
// until not tmp ;
102984: LD_VAR 0 3
102988: NOT
102989: IFFALSE 102890
// end ;
102991: PPOPN 3
102993: END
// every 0 0$1 trigger StreamModeActive and sTroll do
102994: LD_EXP 77
102998: PUSH
102999: LD_EXP 102
103003: AND
103004: IFFALSE 103058
103006: GO 103008
103008: DISABLE
// begin ToLua ( displayTroll(); ) ;
103009: LD_STRING displayTroll();
103011: PPUSH
103012: CALL_OW 559
// wait ( 3 3$00 ) ;
103016: LD_INT 6300
103018: PPUSH
103019: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103023: LD_STRING hideTroll();
103025: PPUSH
103026: CALL_OW 559
// wait ( 1 1$00 ) ;
103030: LD_INT 2100
103032: PPUSH
103033: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103037: LD_STRING displayTroll();
103039: PPUSH
103040: CALL_OW 559
// wait ( 1 1$00 ) ;
103044: LD_INT 2100
103046: PPUSH
103047: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103051: LD_STRING hideTroll();
103053: PPUSH
103054: CALL_OW 559
// end ;
103058: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103059: LD_EXP 77
103063: PUSH
103064: LD_EXP 103
103068: AND
103069: IFFALSE 103132
103071: GO 103073
103073: DISABLE
103074: LD_INT 0
103076: PPUSH
// begin p := 0 ;
103077: LD_ADDR_VAR 0 1
103081: PUSH
103082: LD_INT 0
103084: ST_TO_ADDR
// repeat game_speed := 1 ;
103085: LD_ADDR_OWVAR 65
103089: PUSH
103090: LD_INT 1
103092: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103093: LD_INT 35
103095: PPUSH
103096: CALL_OW 67
// p := p + 1 ;
103100: LD_ADDR_VAR 0 1
103104: PUSH
103105: LD_VAR 0 1
103109: PUSH
103110: LD_INT 1
103112: PLUS
103113: ST_TO_ADDR
// until p >= 60 ;
103114: LD_VAR 0 1
103118: PUSH
103119: LD_INT 60
103121: GREATEREQUAL
103122: IFFALSE 103085
// game_speed := 4 ;
103124: LD_ADDR_OWVAR 65
103128: PUSH
103129: LD_INT 4
103131: ST_TO_ADDR
// end ;
103132: PPOPN 1
103134: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103135: LD_EXP 77
103139: PUSH
103140: LD_EXP 104
103144: AND
103145: IFFALSE 103291
103147: GO 103149
103149: DISABLE
103150: LD_INT 0
103152: PPUSH
103153: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103154: LD_ADDR_VAR 0 1
103158: PUSH
103159: LD_INT 22
103161: PUSH
103162: LD_OWVAR 2
103166: PUSH
103167: EMPTY
103168: LIST
103169: LIST
103170: PUSH
103171: LD_INT 2
103173: PUSH
103174: LD_INT 30
103176: PUSH
103177: LD_INT 0
103179: PUSH
103180: EMPTY
103181: LIST
103182: LIST
103183: PUSH
103184: LD_INT 30
103186: PUSH
103187: LD_INT 1
103189: PUSH
103190: EMPTY
103191: LIST
103192: LIST
103193: PUSH
103194: EMPTY
103195: LIST
103196: LIST
103197: LIST
103198: PUSH
103199: EMPTY
103200: LIST
103201: LIST
103202: PPUSH
103203: CALL_OW 69
103207: ST_TO_ADDR
// if not depot then
103208: LD_VAR 0 1
103212: NOT
103213: IFFALSE 103217
// exit ;
103215: GO 103291
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103217: LD_ADDR_VAR 0 2
103221: PUSH
103222: LD_VAR 0 1
103226: PUSH
103227: LD_INT 1
103229: PPUSH
103230: LD_VAR 0 1
103234: PPUSH
103235: CALL_OW 12
103239: ARRAY
103240: PPUSH
103241: CALL_OW 274
103245: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103246: LD_VAR 0 2
103250: PPUSH
103251: LD_INT 1
103253: PPUSH
103254: LD_INT 0
103256: PPUSH
103257: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103261: LD_VAR 0 2
103265: PPUSH
103266: LD_INT 2
103268: PPUSH
103269: LD_INT 0
103271: PPUSH
103272: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103276: LD_VAR 0 2
103280: PPUSH
103281: LD_INT 3
103283: PPUSH
103284: LD_INT 0
103286: PPUSH
103287: CALL_OW 277
// end ;
103291: PPOPN 2
103293: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103294: LD_EXP 77
103298: PUSH
103299: LD_EXP 105
103303: AND
103304: IFFALSE 103401
103306: GO 103308
103308: DISABLE
103309: LD_INT 0
103311: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103312: LD_ADDR_VAR 0 1
103316: PUSH
103317: LD_INT 22
103319: PUSH
103320: LD_OWVAR 2
103324: PUSH
103325: EMPTY
103326: LIST
103327: LIST
103328: PUSH
103329: LD_INT 21
103331: PUSH
103332: LD_INT 1
103334: PUSH
103335: EMPTY
103336: LIST
103337: LIST
103338: PUSH
103339: LD_INT 3
103341: PUSH
103342: LD_INT 23
103344: PUSH
103345: LD_INT 0
103347: PUSH
103348: EMPTY
103349: LIST
103350: LIST
103351: PUSH
103352: EMPTY
103353: LIST
103354: LIST
103355: PUSH
103356: EMPTY
103357: LIST
103358: LIST
103359: LIST
103360: PPUSH
103361: CALL_OW 69
103365: ST_TO_ADDR
// if not tmp then
103366: LD_VAR 0 1
103370: NOT
103371: IFFALSE 103375
// exit ;
103373: GO 103401
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103375: LD_VAR 0 1
103379: PUSH
103380: LD_INT 1
103382: PPUSH
103383: LD_VAR 0 1
103387: PPUSH
103388: CALL_OW 12
103392: ARRAY
103393: PPUSH
103394: LD_INT 200
103396: PPUSH
103397: CALL_OW 234
// end ;
103401: PPOPN 1
103403: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103404: LD_EXP 77
103408: PUSH
103409: LD_EXP 106
103413: AND
103414: IFFALSE 103493
103416: GO 103418
103418: DISABLE
103419: LD_INT 0
103421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103422: LD_ADDR_VAR 0 1
103426: PUSH
103427: LD_INT 22
103429: PUSH
103430: LD_OWVAR 2
103434: PUSH
103435: EMPTY
103436: LIST
103437: LIST
103438: PUSH
103439: LD_INT 21
103441: PUSH
103442: LD_INT 2
103444: PUSH
103445: EMPTY
103446: LIST
103447: LIST
103448: PUSH
103449: EMPTY
103450: LIST
103451: LIST
103452: PPUSH
103453: CALL_OW 69
103457: ST_TO_ADDR
// if not tmp then
103458: LD_VAR 0 1
103462: NOT
103463: IFFALSE 103467
// exit ;
103465: GO 103493
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103467: LD_VAR 0 1
103471: PUSH
103472: LD_INT 1
103474: PPUSH
103475: LD_VAR 0 1
103479: PPUSH
103480: CALL_OW 12
103484: ARRAY
103485: PPUSH
103486: LD_INT 60
103488: PPUSH
103489: CALL_OW 234
// end ;
103493: PPOPN 1
103495: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103496: LD_EXP 77
103500: PUSH
103501: LD_EXP 107
103505: AND
103506: IFFALSE 103605
103508: GO 103510
103510: DISABLE
103511: LD_INT 0
103513: PPUSH
103514: PPUSH
// begin enable ;
103515: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103516: LD_ADDR_VAR 0 1
103520: PUSH
103521: LD_INT 22
103523: PUSH
103524: LD_OWVAR 2
103528: PUSH
103529: EMPTY
103530: LIST
103531: LIST
103532: PUSH
103533: LD_INT 61
103535: PUSH
103536: EMPTY
103537: LIST
103538: PUSH
103539: LD_INT 33
103541: PUSH
103542: LD_INT 2
103544: PUSH
103545: EMPTY
103546: LIST
103547: LIST
103548: PUSH
103549: EMPTY
103550: LIST
103551: LIST
103552: LIST
103553: PPUSH
103554: CALL_OW 69
103558: ST_TO_ADDR
// if not tmp then
103559: LD_VAR 0 1
103563: NOT
103564: IFFALSE 103568
// exit ;
103566: GO 103605
// for i in tmp do
103568: LD_ADDR_VAR 0 2
103572: PUSH
103573: LD_VAR 0 1
103577: PUSH
103578: FOR_IN
103579: IFFALSE 103603
// if IsControledBy ( i ) then
103581: LD_VAR 0 2
103585: PPUSH
103586: CALL_OW 312
103590: IFFALSE 103601
// ComUnlink ( i ) ;
103592: LD_VAR 0 2
103596: PPUSH
103597: CALL_OW 136
103601: GO 103578
103603: POP
103604: POP
// end ;
103605: PPOPN 2
103607: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103608: LD_EXP 77
103612: PUSH
103613: LD_EXP 108
103617: AND
103618: IFFALSE 103758
103620: GO 103622
103622: DISABLE
103623: LD_INT 0
103625: PPUSH
103626: PPUSH
// begin ToLua ( displayPowell(); ) ;
103627: LD_STRING displayPowell();
103629: PPUSH
103630: CALL_OW 559
// uc_side := 0 ;
103634: LD_ADDR_OWVAR 20
103638: PUSH
103639: LD_INT 0
103641: ST_TO_ADDR
// uc_nation := 2 ;
103642: LD_ADDR_OWVAR 21
103646: PUSH
103647: LD_INT 2
103649: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103650: LD_ADDR_OWVAR 37
103654: PUSH
103655: LD_INT 14
103657: ST_TO_ADDR
// vc_engine := engine_siberite ;
103658: LD_ADDR_OWVAR 39
103662: PUSH
103663: LD_INT 3
103665: ST_TO_ADDR
// vc_control := control_apeman ;
103666: LD_ADDR_OWVAR 38
103670: PUSH
103671: LD_INT 5
103673: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103674: LD_ADDR_OWVAR 40
103678: PUSH
103679: LD_INT 29
103681: ST_TO_ADDR
// un := CreateVehicle ;
103682: LD_ADDR_VAR 0 2
103686: PUSH
103687: CALL_OW 45
103691: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103692: LD_VAR 0 2
103696: PPUSH
103697: LD_INT 1
103699: PPUSH
103700: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103704: LD_INT 35
103706: PPUSH
103707: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103711: LD_VAR 0 2
103715: PPUSH
103716: LD_INT 22
103718: PUSH
103719: LD_OWVAR 2
103723: PUSH
103724: EMPTY
103725: LIST
103726: LIST
103727: PPUSH
103728: CALL_OW 69
103732: PPUSH
103733: LD_VAR 0 2
103737: PPUSH
103738: CALL_OW 74
103742: PPUSH
103743: CALL_OW 115
// until IsDead ( un ) ;
103747: LD_VAR 0 2
103751: PPUSH
103752: CALL_OW 301
103756: IFFALSE 103704
// end ;
103758: PPOPN 2
103760: END
// every 0 0$1 trigger StreamModeActive and sStu do
103761: LD_EXP 77
103765: PUSH
103766: LD_EXP 116
103770: AND
103771: IFFALSE 103787
103773: GO 103775
103775: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103776: LD_STRING displayStucuk();
103778: PPUSH
103779: CALL_OW 559
// ResetFog ;
103783: CALL_OW 335
// end ;
103787: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103788: LD_EXP 77
103792: PUSH
103793: LD_EXP 109
103797: AND
103798: IFFALSE 103939
103800: GO 103802
103802: DISABLE
103803: LD_INT 0
103805: PPUSH
103806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103807: LD_ADDR_VAR 0 2
103811: PUSH
103812: LD_INT 22
103814: PUSH
103815: LD_OWVAR 2
103819: PUSH
103820: EMPTY
103821: LIST
103822: LIST
103823: PUSH
103824: LD_INT 21
103826: PUSH
103827: LD_INT 1
103829: PUSH
103830: EMPTY
103831: LIST
103832: LIST
103833: PUSH
103834: EMPTY
103835: LIST
103836: LIST
103837: PPUSH
103838: CALL_OW 69
103842: ST_TO_ADDR
// if not tmp then
103843: LD_VAR 0 2
103847: NOT
103848: IFFALSE 103852
// exit ;
103850: GO 103939
// un := tmp [ rand ( 1 , tmp ) ] ;
103852: LD_ADDR_VAR 0 1
103856: PUSH
103857: LD_VAR 0 2
103861: PUSH
103862: LD_INT 1
103864: PPUSH
103865: LD_VAR 0 2
103869: PPUSH
103870: CALL_OW 12
103874: ARRAY
103875: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103876: LD_VAR 0 1
103880: PPUSH
103881: LD_INT 0
103883: PPUSH
103884: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
103888: LD_VAR 0 1
103892: PPUSH
103893: LD_OWVAR 3
103897: PUSH
103898: LD_VAR 0 1
103902: DIFF
103903: PPUSH
103904: LD_VAR 0 1
103908: PPUSH
103909: CALL_OW 74
103913: PPUSH
103914: CALL_OW 115
// wait ( 0 0$20 ) ;
103918: LD_INT 700
103920: PPUSH
103921: CALL_OW 67
// SetSide ( un , your_side ) ;
103925: LD_VAR 0 1
103929: PPUSH
103930: LD_OWVAR 2
103934: PPUSH
103935: CALL_OW 235
// end ;
103939: PPOPN 2
103941: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
103942: LD_EXP 77
103946: PUSH
103947: LD_EXP 110
103951: AND
103952: IFFALSE 104058
103954: GO 103956
103956: DISABLE
103957: LD_INT 0
103959: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103960: LD_ADDR_VAR 0 1
103964: PUSH
103965: LD_INT 22
103967: PUSH
103968: LD_OWVAR 2
103972: PUSH
103973: EMPTY
103974: LIST
103975: LIST
103976: PUSH
103977: LD_INT 2
103979: PUSH
103980: LD_INT 30
103982: PUSH
103983: LD_INT 0
103985: PUSH
103986: EMPTY
103987: LIST
103988: LIST
103989: PUSH
103990: LD_INT 30
103992: PUSH
103993: LD_INT 1
103995: PUSH
103996: EMPTY
103997: LIST
103998: LIST
103999: PUSH
104000: EMPTY
104001: LIST
104002: LIST
104003: LIST
104004: PUSH
104005: EMPTY
104006: LIST
104007: LIST
104008: PPUSH
104009: CALL_OW 69
104013: ST_TO_ADDR
// if not depot then
104014: LD_VAR 0 1
104018: NOT
104019: IFFALSE 104023
// exit ;
104021: GO 104058
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104023: LD_VAR 0 1
104027: PUSH
104028: LD_INT 1
104030: ARRAY
104031: PPUSH
104032: CALL_OW 250
104036: PPUSH
104037: LD_VAR 0 1
104041: PUSH
104042: LD_INT 1
104044: ARRAY
104045: PPUSH
104046: CALL_OW 251
104050: PPUSH
104051: LD_INT 70
104053: PPUSH
104054: CALL_OW 495
// end ;
104058: PPOPN 1
104060: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104061: LD_EXP 77
104065: PUSH
104066: LD_EXP 111
104070: AND
104071: IFFALSE 104282
104073: GO 104075
104075: DISABLE
104076: LD_INT 0
104078: PPUSH
104079: PPUSH
104080: PPUSH
104081: PPUSH
104082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104083: LD_ADDR_VAR 0 5
104087: PUSH
104088: LD_INT 22
104090: PUSH
104091: LD_OWVAR 2
104095: PUSH
104096: EMPTY
104097: LIST
104098: LIST
104099: PUSH
104100: LD_INT 21
104102: PUSH
104103: LD_INT 1
104105: PUSH
104106: EMPTY
104107: LIST
104108: LIST
104109: PUSH
104110: EMPTY
104111: LIST
104112: LIST
104113: PPUSH
104114: CALL_OW 69
104118: ST_TO_ADDR
// if not tmp then
104119: LD_VAR 0 5
104123: NOT
104124: IFFALSE 104128
// exit ;
104126: GO 104282
// for i in tmp do
104128: LD_ADDR_VAR 0 1
104132: PUSH
104133: LD_VAR 0 5
104137: PUSH
104138: FOR_IN
104139: IFFALSE 104280
// begin d := rand ( 0 , 5 ) ;
104141: LD_ADDR_VAR 0 4
104145: PUSH
104146: LD_INT 0
104148: PPUSH
104149: LD_INT 5
104151: PPUSH
104152: CALL_OW 12
104156: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104157: LD_ADDR_VAR 0 2
104161: PUSH
104162: LD_VAR 0 1
104166: PPUSH
104167: CALL_OW 250
104171: PPUSH
104172: LD_VAR 0 4
104176: PPUSH
104177: LD_INT 3
104179: PPUSH
104180: LD_INT 12
104182: PPUSH
104183: CALL_OW 12
104187: PPUSH
104188: CALL_OW 272
104192: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104193: LD_ADDR_VAR 0 3
104197: PUSH
104198: LD_VAR 0 1
104202: PPUSH
104203: CALL_OW 251
104207: PPUSH
104208: LD_VAR 0 4
104212: PPUSH
104213: LD_INT 3
104215: PPUSH
104216: LD_INT 12
104218: PPUSH
104219: CALL_OW 12
104223: PPUSH
104224: CALL_OW 273
104228: ST_TO_ADDR
// if ValidHex ( x , y ) then
104229: LD_VAR 0 2
104233: PPUSH
104234: LD_VAR 0 3
104238: PPUSH
104239: CALL_OW 488
104243: IFFALSE 104278
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104245: LD_VAR 0 1
104249: PPUSH
104250: LD_VAR 0 2
104254: PPUSH
104255: LD_VAR 0 3
104259: PPUSH
104260: LD_INT 3
104262: PPUSH
104263: LD_INT 6
104265: PPUSH
104266: CALL_OW 12
104270: PPUSH
104271: LD_INT 1
104273: PPUSH
104274: CALL_OW 483
// end ;
104278: GO 104138
104280: POP
104281: POP
// end ;
104282: PPOPN 5
104284: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104285: LD_EXP 77
104289: PUSH
104290: LD_EXP 112
104294: AND
104295: IFFALSE 104389
104297: GO 104299
104299: DISABLE
104300: LD_INT 0
104302: PPUSH
104303: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104304: LD_ADDR_VAR 0 2
104308: PUSH
104309: LD_INT 22
104311: PUSH
104312: LD_OWVAR 2
104316: PUSH
104317: EMPTY
104318: LIST
104319: LIST
104320: PUSH
104321: LD_INT 32
104323: PUSH
104324: LD_INT 1
104326: PUSH
104327: EMPTY
104328: LIST
104329: LIST
104330: PUSH
104331: LD_INT 21
104333: PUSH
104334: LD_INT 2
104336: PUSH
104337: EMPTY
104338: LIST
104339: LIST
104340: PUSH
104341: EMPTY
104342: LIST
104343: LIST
104344: LIST
104345: PPUSH
104346: CALL_OW 69
104350: ST_TO_ADDR
// if not tmp then
104351: LD_VAR 0 2
104355: NOT
104356: IFFALSE 104360
// exit ;
104358: GO 104389
// for i in tmp do
104360: LD_ADDR_VAR 0 1
104364: PUSH
104365: LD_VAR 0 2
104369: PUSH
104370: FOR_IN
104371: IFFALSE 104387
// SetFuel ( i , 0 ) ;
104373: LD_VAR 0 1
104377: PPUSH
104378: LD_INT 0
104380: PPUSH
104381: CALL_OW 240
104385: GO 104370
104387: POP
104388: POP
// end ;
104389: PPOPN 2
104391: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104392: LD_EXP 77
104396: PUSH
104397: LD_EXP 113
104401: AND
104402: IFFALSE 104468
104404: GO 104406
104406: DISABLE
104407: LD_INT 0
104409: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104410: LD_ADDR_VAR 0 1
104414: PUSH
104415: LD_INT 22
104417: PUSH
104418: LD_OWVAR 2
104422: PUSH
104423: EMPTY
104424: LIST
104425: LIST
104426: PUSH
104427: LD_INT 30
104429: PUSH
104430: LD_INT 29
104432: PUSH
104433: EMPTY
104434: LIST
104435: LIST
104436: PUSH
104437: EMPTY
104438: LIST
104439: LIST
104440: PPUSH
104441: CALL_OW 69
104445: ST_TO_ADDR
// if not tmp then
104446: LD_VAR 0 1
104450: NOT
104451: IFFALSE 104455
// exit ;
104453: GO 104468
// DestroyUnit ( tmp [ 1 ] ) ;
104455: LD_VAR 0 1
104459: PUSH
104460: LD_INT 1
104462: ARRAY
104463: PPUSH
104464: CALL_OW 65
// end ;
104468: PPOPN 1
104470: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104471: LD_EXP 77
104475: PUSH
104476: LD_EXP 115
104480: AND
104481: IFFALSE 104610
104483: GO 104485
104485: DISABLE
104486: LD_INT 0
104488: PPUSH
// begin uc_side := 0 ;
104489: LD_ADDR_OWVAR 20
104493: PUSH
104494: LD_INT 0
104496: ST_TO_ADDR
// uc_nation := nation_arabian ;
104497: LD_ADDR_OWVAR 21
104501: PUSH
104502: LD_INT 2
104504: ST_TO_ADDR
// hc_gallery :=  ;
104505: LD_ADDR_OWVAR 33
104509: PUSH
104510: LD_STRING 
104512: ST_TO_ADDR
// hc_name :=  ;
104513: LD_ADDR_OWVAR 26
104517: PUSH
104518: LD_STRING 
104520: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104521: LD_INT 1
104523: PPUSH
104524: LD_INT 11
104526: PPUSH
104527: LD_INT 10
104529: PPUSH
104530: CALL_OW 380
// un := CreateHuman ;
104534: LD_ADDR_VAR 0 1
104538: PUSH
104539: CALL_OW 44
104543: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104544: LD_VAR 0 1
104548: PPUSH
104549: LD_INT 1
104551: PPUSH
104552: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104556: LD_INT 35
104558: PPUSH
104559: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104563: LD_VAR 0 1
104567: PPUSH
104568: LD_INT 22
104570: PUSH
104571: LD_OWVAR 2
104575: PUSH
104576: EMPTY
104577: LIST
104578: LIST
104579: PPUSH
104580: CALL_OW 69
104584: PPUSH
104585: LD_VAR 0 1
104589: PPUSH
104590: CALL_OW 74
104594: PPUSH
104595: CALL_OW 115
// until IsDead ( un ) ;
104599: LD_VAR 0 1
104603: PPUSH
104604: CALL_OW 301
104608: IFFALSE 104556
// end ;
104610: PPOPN 1
104612: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104613: LD_EXP 77
104617: PUSH
104618: LD_EXP 117
104622: AND
104623: IFFALSE 104635
104625: GO 104627
104627: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104628: LD_STRING earthquake(getX(game), 0, 32)
104630: PPUSH
104631: CALL_OW 559
104635: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104636: LD_EXP 77
104640: PUSH
104641: LD_EXP 118
104645: AND
104646: IFFALSE 104737
104648: GO 104650
104650: DISABLE
104651: LD_INT 0
104653: PPUSH
// begin enable ;
104654: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104655: LD_ADDR_VAR 0 1
104659: PUSH
104660: LD_INT 22
104662: PUSH
104663: LD_OWVAR 2
104667: PUSH
104668: EMPTY
104669: LIST
104670: LIST
104671: PUSH
104672: LD_INT 21
104674: PUSH
104675: LD_INT 2
104677: PUSH
104678: EMPTY
104679: LIST
104680: LIST
104681: PUSH
104682: LD_INT 33
104684: PUSH
104685: LD_INT 3
104687: PUSH
104688: EMPTY
104689: LIST
104690: LIST
104691: PUSH
104692: EMPTY
104693: LIST
104694: LIST
104695: LIST
104696: PPUSH
104697: CALL_OW 69
104701: ST_TO_ADDR
// if not tmp then
104702: LD_VAR 0 1
104706: NOT
104707: IFFALSE 104711
// exit ;
104709: GO 104737
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104711: LD_VAR 0 1
104715: PUSH
104716: LD_INT 1
104718: PPUSH
104719: LD_VAR 0 1
104723: PPUSH
104724: CALL_OW 12
104728: ARRAY
104729: PPUSH
104730: LD_INT 1
104732: PPUSH
104733: CALL_OW 234
// end ;
104737: PPOPN 1
104739: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104740: LD_EXP 77
104744: PUSH
104745: LD_EXP 119
104749: AND
104750: IFFALSE 104891
104752: GO 104754
104754: DISABLE
104755: LD_INT 0
104757: PPUSH
104758: PPUSH
104759: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104760: LD_ADDR_VAR 0 3
104764: PUSH
104765: LD_INT 22
104767: PUSH
104768: LD_OWVAR 2
104772: PUSH
104773: EMPTY
104774: LIST
104775: LIST
104776: PUSH
104777: LD_INT 25
104779: PUSH
104780: LD_INT 1
104782: PUSH
104783: EMPTY
104784: LIST
104785: LIST
104786: PUSH
104787: EMPTY
104788: LIST
104789: LIST
104790: PPUSH
104791: CALL_OW 69
104795: ST_TO_ADDR
// if not tmp then
104796: LD_VAR 0 3
104800: NOT
104801: IFFALSE 104805
// exit ;
104803: GO 104891
// un := tmp [ rand ( 1 , tmp ) ] ;
104805: LD_ADDR_VAR 0 2
104809: PUSH
104810: LD_VAR 0 3
104814: PUSH
104815: LD_INT 1
104817: PPUSH
104818: LD_VAR 0 3
104822: PPUSH
104823: CALL_OW 12
104827: ARRAY
104828: ST_TO_ADDR
// if Crawls ( un ) then
104829: LD_VAR 0 2
104833: PPUSH
104834: CALL_OW 318
104838: IFFALSE 104849
// ComWalk ( un ) ;
104840: LD_VAR 0 2
104844: PPUSH
104845: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104849: LD_VAR 0 2
104853: PPUSH
104854: LD_INT 9
104856: PPUSH
104857: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104861: LD_INT 28
104863: PPUSH
104864: LD_OWVAR 2
104868: PPUSH
104869: LD_INT 2
104871: PPUSH
104872: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104876: LD_INT 29
104878: PPUSH
104879: LD_OWVAR 2
104883: PPUSH
104884: LD_INT 2
104886: PPUSH
104887: CALL_OW 322
// end ;
104891: PPOPN 3
104893: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
104894: LD_EXP 77
104898: PUSH
104899: LD_EXP 120
104903: AND
104904: IFFALSE 105015
104906: GO 104908
104908: DISABLE
104909: LD_INT 0
104911: PPUSH
104912: PPUSH
104913: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104914: LD_ADDR_VAR 0 3
104918: PUSH
104919: LD_INT 22
104921: PUSH
104922: LD_OWVAR 2
104926: PUSH
104927: EMPTY
104928: LIST
104929: LIST
104930: PUSH
104931: LD_INT 25
104933: PUSH
104934: LD_INT 1
104936: PUSH
104937: EMPTY
104938: LIST
104939: LIST
104940: PUSH
104941: EMPTY
104942: LIST
104943: LIST
104944: PPUSH
104945: CALL_OW 69
104949: ST_TO_ADDR
// if not tmp then
104950: LD_VAR 0 3
104954: NOT
104955: IFFALSE 104959
// exit ;
104957: GO 105015
// un := tmp [ rand ( 1 , tmp ) ] ;
104959: LD_ADDR_VAR 0 2
104963: PUSH
104964: LD_VAR 0 3
104968: PUSH
104969: LD_INT 1
104971: PPUSH
104972: LD_VAR 0 3
104976: PPUSH
104977: CALL_OW 12
104981: ARRAY
104982: ST_TO_ADDR
// if Crawls ( un ) then
104983: LD_VAR 0 2
104987: PPUSH
104988: CALL_OW 318
104992: IFFALSE 105003
// ComWalk ( un ) ;
104994: LD_VAR 0 2
104998: PPUSH
104999: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105003: LD_VAR 0 2
105007: PPUSH
105008: LD_INT 8
105010: PPUSH
105011: CALL_OW 336
// end ;
105015: PPOPN 3
105017: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105018: LD_EXP 77
105022: PUSH
105023: LD_EXP 121
105027: AND
105028: IFFALSE 105172
105030: GO 105032
105032: DISABLE
105033: LD_INT 0
105035: PPUSH
105036: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105037: LD_ADDR_VAR 0 2
105041: PUSH
105042: LD_INT 22
105044: PUSH
105045: LD_OWVAR 2
105049: PUSH
105050: EMPTY
105051: LIST
105052: LIST
105053: PUSH
105054: LD_INT 21
105056: PUSH
105057: LD_INT 2
105059: PUSH
105060: EMPTY
105061: LIST
105062: LIST
105063: PUSH
105064: LD_INT 2
105066: PUSH
105067: LD_INT 34
105069: PUSH
105070: LD_INT 12
105072: PUSH
105073: EMPTY
105074: LIST
105075: LIST
105076: PUSH
105077: LD_INT 34
105079: PUSH
105080: LD_INT 51
105082: PUSH
105083: EMPTY
105084: LIST
105085: LIST
105086: PUSH
105087: LD_INT 34
105089: PUSH
105090: LD_INT 32
105092: PUSH
105093: EMPTY
105094: LIST
105095: LIST
105096: PUSH
105097: EMPTY
105098: LIST
105099: LIST
105100: LIST
105101: LIST
105102: PUSH
105103: EMPTY
105104: LIST
105105: LIST
105106: LIST
105107: PPUSH
105108: CALL_OW 69
105112: ST_TO_ADDR
// if not tmp then
105113: LD_VAR 0 2
105117: NOT
105118: IFFALSE 105122
// exit ;
105120: GO 105172
// for i in tmp do
105122: LD_ADDR_VAR 0 1
105126: PUSH
105127: LD_VAR 0 2
105131: PUSH
105132: FOR_IN
105133: IFFALSE 105170
// if GetCargo ( i , mat_artifact ) = 0 then
105135: LD_VAR 0 1
105139: PPUSH
105140: LD_INT 4
105142: PPUSH
105143: CALL_OW 289
105147: PUSH
105148: LD_INT 0
105150: EQUAL
105151: IFFALSE 105168
// SetCargo ( i , mat_siberit , 100 ) ;
105153: LD_VAR 0 1
105157: PPUSH
105158: LD_INT 3
105160: PPUSH
105161: LD_INT 100
105163: PPUSH
105164: CALL_OW 290
105168: GO 105132
105170: POP
105171: POP
// end ;
105172: PPOPN 2
105174: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105175: LD_EXP 77
105179: PUSH
105180: LD_EXP 122
105184: AND
105185: IFFALSE 105368
105187: GO 105189
105189: DISABLE
105190: LD_INT 0
105192: PPUSH
105193: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105194: LD_ADDR_VAR 0 2
105198: PUSH
105199: LD_INT 22
105201: PUSH
105202: LD_OWVAR 2
105206: PUSH
105207: EMPTY
105208: LIST
105209: LIST
105210: PPUSH
105211: CALL_OW 69
105215: ST_TO_ADDR
// if not tmp then
105216: LD_VAR 0 2
105220: NOT
105221: IFFALSE 105225
// exit ;
105223: GO 105368
// for i := 1 to 2 do
105225: LD_ADDR_VAR 0 1
105229: PUSH
105230: DOUBLE
105231: LD_INT 1
105233: DEC
105234: ST_TO_ADDR
105235: LD_INT 2
105237: PUSH
105238: FOR_TO
105239: IFFALSE 105366
// begin uc_side := your_side ;
105241: LD_ADDR_OWVAR 20
105245: PUSH
105246: LD_OWVAR 2
105250: ST_TO_ADDR
// uc_nation := nation_american ;
105251: LD_ADDR_OWVAR 21
105255: PUSH
105256: LD_INT 1
105258: ST_TO_ADDR
// vc_chassis := us_morphling ;
105259: LD_ADDR_OWVAR 37
105263: PUSH
105264: LD_INT 5
105266: ST_TO_ADDR
// vc_engine := engine_siberite ;
105267: LD_ADDR_OWVAR 39
105271: PUSH
105272: LD_INT 3
105274: ST_TO_ADDR
// vc_control := control_computer ;
105275: LD_ADDR_OWVAR 38
105279: PUSH
105280: LD_INT 3
105282: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105283: LD_ADDR_OWVAR 40
105287: PUSH
105288: LD_INT 10
105290: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105291: LD_VAR 0 2
105295: PUSH
105296: LD_INT 1
105298: ARRAY
105299: PPUSH
105300: CALL_OW 310
105304: NOT
105305: IFFALSE 105352
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105307: CALL_OW 45
105311: PPUSH
105312: LD_VAR 0 2
105316: PUSH
105317: LD_INT 1
105319: ARRAY
105320: PPUSH
105321: CALL_OW 250
105325: PPUSH
105326: LD_VAR 0 2
105330: PUSH
105331: LD_INT 1
105333: ARRAY
105334: PPUSH
105335: CALL_OW 251
105339: PPUSH
105340: LD_INT 12
105342: PPUSH
105343: LD_INT 1
105345: PPUSH
105346: CALL_OW 50
105350: GO 105364
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105352: CALL_OW 45
105356: PPUSH
105357: LD_INT 1
105359: PPUSH
105360: CALL_OW 51
// end ;
105364: GO 105238
105366: POP
105367: POP
// end ;
105368: PPOPN 2
105370: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105371: LD_EXP 77
105375: PUSH
105376: LD_EXP 123
105380: AND
105381: IFFALSE 105603
105383: GO 105385
105385: DISABLE
105386: LD_INT 0
105388: PPUSH
105389: PPUSH
105390: PPUSH
105391: PPUSH
105392: PPUSH
105393: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105394: LD_ADDR_VAR 0 6
105398: PUSH
105399: LD_INT 22
105401: PUSH
105402: LD_OWVAR 2
105406: PUSH
105407: EMPTY
105408: LIST
105409: LIST
105410: PUSH
105411: LD_INT 21
105413: PUSH
105414: LD_INT 1
105416: PUSH
105417: EMPTY
105418: LIST
105419: LIST
105420: PUSH
105421: LD_INT 3
105423: PUSH
105424: LD_INT 23
105426: PUSH
105427: LD_INT 0
105429: PUSH
105430: EMPTY
105431: LIST
105432: LIST
105433: PUSH
105434: EMPTY
105435: LIST
105436: LIST
105437: PUSH
105438: EMPTY
105439: LIST
105440: LIST
105441: LIST
105442: PPUSH
105443: CALL_OW 69
105447: ST_TO_ADDR
// if not tmp then
105448: LD_VAR 0 6
105452: NOT
105453: IFFALSE 105457
// exit ;
105455: GO 105603
// s1 := rand ( 1 , 4 ) ;
105457: LD_ADDR_VAR 0 2
105461: PUSH
105462: LD_INT 1
105464: PPUSH
105465: LD_INT 4
105467: PPUSH
105468: CALL_OW 12
105472: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105473: LD_ADDR_VAR 0 4
105477: PUSH
105478: LD_VAR 0 6
105482: PUSH
105483: LD_INT 1
105485: ARRAY
105486: PPUSH
105487: LD_VAR 0 2
105491: PPUSH
105492: CALL_OW 259
105496: ST_TO_ADDR
// if s1 = 1 then
105497: LD_VAR 0 2
105501: PUSH
105502: LD_INT 1
105504: EQUAL
105505: IFFALSE 105525
// s2 := rand ( 2 , 4 ) else
105507: LD_ADDR_VAR 0 3
105511: PUSH
105512: LD_INT 2
105514: PPUSH
105515: LD_INT 4
105517: PPUSH
105518: CALL_OW 12
105522: ST_TO_ADDR
105523: GO 105533
// s2 := 1 ;
105525: LD_ADDR_VAR 0 3
105529: PUSH
105530: LD_INT 1
105532: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105533: LD_ADDR_VAR 0 5
105537: PUSH
105538: LD_VAR 0 6
105542: PUSH
105543: LD_INT 1
105545: ARRAY
105546: PPUSH
105547: LD_VAR 0 3
105551: PPUSH
105552: CALL_OW 259
105556: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105557: LD_VAR 0 6
105561: PUSH
105562: LD_INT 1
105564: ARRAY
105565: PPUSH
105566: LD_VAR 0 2
105570: PPUSH
105571: LD_VAR 0 5
105575: PPUSH
105576: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105580: LD_VAR 0 6
105584: PUSH
105585: LD_INT 1
105587: ARRAY
105588: PPUSH
105589: LD_VAR 0 3
105593: PPUSH
105594: LD_VAR 0 4
105598: PPUSH
105599: CALL_OW 237
// end ;
105603: PPOPN 6
105605: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105606: LD_EXP 77
105610: PUSH
105611: LD_EXP 124
105615: AND
105616: IFFALSE 105695
105618: GO 105620
105620: DISABLE
105621: LD_INT 0
105623: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105624: LD_ADDR_VAR 0 1
105628: PUSH
105629: LD_INT 22
105631: PUSH
105632: LD_OWVAR 2
105636: PUSH
105637: EMPTY
105638: LIST
105639: LIST
105640: PUSH
105641: LD_INT 30
105643: PUSH
105644: LD_INT 3
105646: PUSH
105647: EMPTY
105648: LIST
105649: LIST
105650: PUSH
105651: EMPTY
105652: LIST
105653: LIST
105654: PPUSH
105655: CALL_OW 69
105659: ST_TO_ADDR
// if not tmp then
105660: LD_VAR 0 1
105664: NOT
105665: IFFALSE 105669
// exit ;
105667: GO 105695
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105669: LD_VAR 0 1
105673: PUSH
105674: LD_INT 1
105676: PPUSH
105677: LD_VAR 0 1
105681: PPUSH
105682: CALL_OW 12
105686: ARRAY
105687: PPUSH
105688: LD_INT 1
105690: PPUSH
105691: CALL_OW 234
// end ;
105695: PPOPN 1
105697: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105698: LD_EXP 77
105702: PUSH
105703: LD_EXP 125
105707: AND
105708: IFFALSE 105820
105710: GO 105712
105712: DISABLE
105713: LD_INT 0
105715: PPUSH
105716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105717: LD_ADDR_VAR 0 2
105721: PUSH
105722: LD_INT 22
105724: PUSH
105725: LD_OWVAR 2
105729: PUSH
105730: EMPTY
105731: LIST
105732: LIST
105733: PUSH
105734: LD_INT 2
105736: PUSH
105737: LD_INT 30
105739: PUSH
105740: LD_INT 27
105742: PUSH
105743: EMPTY
105744: LIST
105745: LIST
105746: PUSH
105747: LD_INT 30
105749: PUSH
105750: LD_INT 26
105752: PUSH
105753: EMPTY
105754: LIST
105755: LIST
105756: PUSH
105757: LD_INT 30
105759: PUSH
105760: LD_INT 28
105762: PUSH
105763: EMPTY
105764: LIST
105765: LIST
105766: PUSH
105767: EMPTY
105768: LIST
105769: LIST
105770: LIST
105771: LIST
105772: PUSH
105773: EMPTY
105774: LIST
105775: LIST
105776: PPUSH
105777: CALL_OW 69
105781: ST_TO_ADDR
// if not tmp then
105782: LD_VAR 0 2
105786: NOT
105787: IFFALSE 105791
// exit ;
105789: GO 105820
// for i in tmp do
105791: LD_ADDR_VAR 0 1
105795: PUSH
105796: LD_VAR 0 2
105800: PUSH
105801: FOR_IN
105802: IFFALSE 105818
// SetLives ( i , 1 ) ;
105804: LD_VAR 0 1
105808: PPUSH
105809: LD_INT 1
105811: PPUSH
105812: CALL_OW 234
105816: GO 105801
105818: POP
105819: POP
// end ;
105820: PPOPN 2
105822: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105823: LD_EXP 77
105827: PUSH
105828: LD_EXP 126
105832: AND
105833: IFFALSE 106120
105835: GO 105837
105837: DISABLE
105838: LD_INT 0
105840: PPUSH
105841: PPUSH
105842: PPUSH
// begin i := rand ( 1 , 7 ) ;
105843: LD_ADDR_VAR 0 1
105847: PUSH
105848: LD_INT 1
105850: PPUSH
105851: LD_INT 7
105853: PPUSH
105854: CALL_OW 12
105858: ST_TO_ADDR
// case i of 1 :
105859: LD_VAR 0 1
105863: PUSH
105864: LD_INT 1
105866: DOUBLE
105867: EQUAL
105868: IFTRUE 105872
105870: GO 105882
105872: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105873: LD_STRING earthquake(getX(game), 0, 32)
105875: PPUSH
105876: CALL_OW 559
105880: GO 106120
105882: LD_INT 2
105884: DOUBLE
105885: EQUAL
105886: IFTRUE 105890
105888: GO 105904
105890: POP
// begin ToLua ( displayStucuk(); ) ;
105891: LD_STRING displayStucuk();
105893: PPUSH
105894: CALL_OW 559
// ResetFog ;
105898: CALL_OW 335
// end ; 3 :
105902: GO 106120
105904: LD_INT 3
105906: DOUBLE
105907: EQUAL
105908: IFTRUE 105912
105910: GO 106016
105912: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105913: LD_ADDR_VAR 0 2
105917: PUSH
105918: LD_INT 22
105920: PUSH
105921: LD_OWVAR 2
105925: PUSH
105926: EMPTY
105927: LIST
105928: LIST
105929: PUSH
105930: LD_INT 25
105932: PUSH
105933: LD_INT 1
105935: PUSH
105936: EMPTY
105937: LIST
105938: LIST
105939: PUSH
105940: EMPTY
105941: LIST
105942: LIST
105943: PPUSH
105944: CALL_OW 69
105948: ST_TO_ADDR
// if not tmp then
105949: LD_VAR 0 2
105953: NOT
105954: IFFALSE 105958
// exit ;
105956: GO 106120
// un := tmp [ rand ( 1 , tmp ) ] ;
105958: LD_ADDR_VAR 0 3
105962: PUSH
105963: LD_VAR 0 2
105967: PUSH
105968: LD_INT 1
105970: PPUSH
105971: LD_VAR 0 2
105975: PPUSH
105976: CALL_OW 12
105980: ARRAY
105981: ST_TO_ADDR
// if Crawls ( un ) then
105982: LD_VAR 0 3
105986: PPUSH
105987: CALL_OW 318
105991: IFFALSE 106002
// ComWalk ( un ) ;
105993: LD_VAR 0 3
105997: PPUSH
105998: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106002: LD_VAR 0 3
106006: PPUSH
106007: LD_INT 8
106009: PPUSH
106010: CALL_OW 336
// end ; 4 :
106014: GO 106120
106016: LD_INT 4
106018: DOUBLE
106019: EQUAL
106020: IFTRUE 106024
106022: GO 106098
106024: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106025: LD_ADDR_VAR 0 2
106029: PUSH
106030: LD_INT 22
106032: PUSH
106033: LD_OWVAR 2
106037: PUSH
106038: EMPTY
106039: LIST
106040: LIST
106041: PUSH
106042: LD_INT 30
106044: PUSH
106045: LD_INT 29
106047: PUSH
106048: EMPTY
106049: LIST
106050: LIST
106051: PUSH
106052: EMPTY
106053: LIST
106054: LIST
106055: PPUSH
106056: CALL_OW 69
106060: ST_TO_ADDR
// if not tmp then
106061: LD_VAR 0 2
106065: NOT
106066: IFFALSE 106070
// exit ;
106068: GO 106120
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106070: LD_VAR 0 2
106074: PUSH
106075: LD_INT 1
106077: ARRAY
106078: PPUSH
106079: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106083: LD_VAR 0 2
106087: PUSH
106088: LD_INT 1
106090: ARRAY
106091: PPUSH
106092: CALL_OW 65
// end ; 5 .. 7 :
106096: GO 106120
106098: LD_INT 5
106100: DOUBLE
106101: GREATEREQUAL
106102: IFFALSE 106110
106104: LD_INT 7
106106: DOUBLE
106107: LESSEQUAL
106108: IFTRUE 106112
106110: GO 106119
106112: POP
// StreamSibBomb ; end ;
106113: CALL 102357 0 0
106117: GO 106120
106119: POP
// end ;
106120: PPOPN 3
106122: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106123: LD_EXP 77
106127: PUSH
106128: LD_EXP 127
106132: AND
106133: IFFALSE 106289
106135: GO 106137
106137: DISABLE
106138: LD_INT 0
106140: PPUSH
106141: PPUSH
106142: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106143: LD_ADDR_VAR 0 2
106147: PUSH
106148: LD_INT 81
106150: PUSH
106151: LD_OWVAR 2
106155: PUSH
106156: EMPTY
106157: LIST
106158: LIST
106159: PUSH
106160: LD_INT 2
106162: PUSH
106163: LD_INT 21
106165: PUSH
106166: LD_INT 1
106168: PUSH
106169: EMPTY
106170: LIST
106171: LIST
106172: PUSH
106173: LD_INT 21
106175: PUSH
106176: LD_INT 2
106178: PUSH
106179: EMPTY
106180: LIST
106181: LIST
106182: PUSH
106183: EMPTY
106184: LIST
106185: LIST
106186: LIST
106187: PUSH
106188: EMPTY
106189: LIST
106190: LIST
106191: PPUSH
106192: CALL_OW 69
106196: ST_TO_ADDR
// if not tmp then
106197: LD_VAR 0 2
106201: NOT
106202: IFFALSE 106206
// exit ;
106204: GO 106289
// p := 0 ;
106206: LD_ADDR_VAR 0 3
106210: PUSH
106211: LD_INT 0
106213: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106214: LD_INT 35
106216: PPUSH
106217: CALL_OW 67
// p := p + 1 ;
106221: LD_ADDR_VAR 0 3
106225: PUSH
106226: LD_VAR 0 3
106230: PUSH
106231: LD_INT 1
106233: PLUS
106234: ST_TO_ADDR
// for i in tmp do
106235: LD_ADDR_VAR 0 1
106239: PUSH
106240: LD_VAR 0 2
106244: PUSH
106245: FOR_IN
106246: IFFALSE 106277
// if GetLives ( i ) < 1000 then
106248: LD_VAR 0 1
106252: PPUSH
106253: CALL_OW 256
106257: PUSH
106258: LD_INT 1000
106260: LESS
106261: IFFALSE 106275
// SetLives ( i , 1000 ) ;
106263: LD_VAR 0 1
106267: PPUSH
106268: LD_INT 1000
106270: PPUSH
106271: CALL_OW 234
106275: GO 106245
106277: POP
106278: POP
// until p > 20 ;
106279: LD_VAR 0 3
106283: PUSH
106284: LD_INT 20
106286: GREATER
106287: IFFALSE 106214
// end ;
106289: PPOPN 3
106291: END
// every 0 0$1 trigger StreamModeActive and sTime do
106292: LD_EXP 77
106296: PUSH
106297: LD_EXP 128
106301: AND
106302: IFFALSE 106337
106304: GO 106306
106306: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106307: LD_INT 28
106309: PPUSH
106310: LD_OWVAR 2
106314: PPUSH
106315: LD_INT 2
106317: PPUSH
106318: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106322: LD_INT 30
106324: PPUSH
106325: LD_OWVAR 2
106329: PPUSH
106330: LD_INT 2
106332: PPUSH
106333: CALL_OW 322
// end ;
106337: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106338: LD_EXP 77
106342: PUSH
106343: LD_EXP 129
106347: AND
106348: IFFALSE 106469
106350: GO 106352
106352: DISABLE
106353: LD_INT 0
106355: PPUSH
106356: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106357: LD_ADDR_VAR 0 2
106361: PUSH
106362: LD_INT 22
106364: PUSH
106365: LD_OWVAR 2
106369: PUSH
106370: EMPTY
106371: LIST
106372: LIST
106373: PUSH
106374: LD_INT 21
106376: PUSH
106377: LD_INT 1
106379: PUSH
106380: EMPTY
106381: LIST
106382: LIST
106383: PUSH
106384: LD_INT 3
106386: PUSH
106387: LD_INT 23
106389: PUSH
106390: LD_INT 0
106392: PUSH
106393: EMPTY
106394: LIST
106395: LIST
106396: PUSH
106397: EMPTY
106398: LIST
106399: LIST
106400: PUSH
106401: EMPTY
106402: LIST
106403: LIST
106404: LIST
106405: PPUSH
106406: CALL_OW 69
106410: ST_TO_ADDR
// if not tmp then
106411: LD_VAR 0 2
106415: NOT
106416: IFFALSE 106420
// exit ;
106418: GO 106469
// for i in tmp do
106420: LD_ADDR_VAR 0 1
106424: PUSH
106425: LD_VAR 0 2
106429: PUSH
106430: FOR_IN
106431: IFFALSE 106467
// begin if Crawls ( i ) then
106433: LD_VAR 0 1
106437: PPUSH
106438: CALL_OW 318
106442: IFFALSE 106453
// ComWalk ( i ) ;
106444: LD_VAR 0 1
106448: PPUSH
106449: CALL_OW 138
// SetClass ( i , 2 ) ;
106453: LD_VAR 0 1
106457: PPUSH
106458: LD_INT 2
106460: PPUSH
106461: CALL_OW 336
// end ;
106465: GO 106430
106467: POP
106468: POP
// end ;
106469: PPOPN 2
106471: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106472: LD_EXP 77
106476: PUSH
106477: LD_EXP 130
106481: AND
106482: IFFALSE 106770
106484: GO 106486
106486: DISABLE
106487: LD_INT 0
106489: PPUSH
106490: PPUSH
106491: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106492: LD_OWVAR 2
106496: PPUSH
106497: LD_INT 9
106499: PPUSH
106500: LD_INT 1
106502: PPUSH
106503: LD_INT 1
106505: PPUSH
106506: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106510: LD_INT 9
106512: PPUSH
106513: LD_OWVAR 2
106517: PPUSH
106518: CALL_OW 343
// uc_side := 9 ;
106522: LD_ADDR_OWVAR 20
106526: PUSH
106527: LD_INT 9
106529: ST_TO_ADDR
// uc_nation := 2 ;
106530: LD_ADDR_OWVAR 21
106534: PUSH
106535: LD_INT 2
106537: ST_TO_ADDR
// hc_name := Dark Warrior ;
106538: LD_ADDR_OWVAR 26
106542: PUSH
106543: LD_STRING Dark Warrior
106545: ST_TO_ADDR
// hc_gallery :=  ;
106546: LD_ADDR_OWVAR 33
106550: PUSH
106551: LD_STRING 
106553: ST_TO_ADDR
// hc_noskilllimit := true ;
106554: LD_ADDR_OWVAR 76
106558: PUSH
106559: LD_INT 1
106561: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106562: LD_ADDR_OWVAR 31
106566: PUSH
106567: LD_INT 30
106569: PUSH
106570: LD_INT 30
106572: PUSH
106573: LD_INT 30
106575: PUSH
106576: LD_INT 30
106578: PUSH
106579: EMPTY
106580: LIST
106581: LIST
106582: LIST
106583: LIST
106584: ST_TO_ADDR
// un := CreateHuman ;
106585: LD_ADDR_VAR 0 3
106589: PUSH
106590: CALL_OW 44
106594: ST_TO_ADDR
// hc_noskilllimit := false ;
106595: LD_ADDR_OWVAR 76
106599: PUSH
106600: LD_INT 0
106602: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106603: LD_VAR 0 3
106607: PPUSH
106608: LD_INT 1
106610: PPUSH
106611: CALL_OW 51
// ToLua ( playRanger() ) ;
106615: LD_STRING playRanger()
106617: PPUSH
106618: CALL_OW 559
// p := 0 ;
106622: LD_ADDR_VAR 0 2
106626: PUSH
106627: LD_INT 0
106629: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106630: LD_INT 35
106632: PPUSH
106633: CALL_OW 67
// p := p + 1 ;
106637: LD_ADDR_VAR 0 2
106641: PUSH
106642: LD_VAR 0 2
106646: PUSH
106647: LD_INT 1
106649: PLUS
106650: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106651: LD_VAR 0 3
106655: PPUSH
106656: CALL_OW 256
106660: PUSH
106661: LD_INT 1000
106663: LESS
106664: IFFALSE 106678
// SetLives ( un , 1000 ) ;
106666: LD_VAR 0 3
106670: PPUSH
106671: LD_INT 1000
106673: PPUSH
106674: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106678: LD_VAR 0 3
106682: PPUSH
106683: LD_INT 81
106685: PUSH
106686: LD_OWVAR 2
106690: PUSH
106691: EMPTY
106692: LIST
106693: LIST
106694: PUSH
106695: LD_INT 91
106697: PUSH
106698: LD_VAR 0 3
106702: PUSH
106703: LD_INT 30
106705: PUSH
106706: EMPTY
106707: LIST
106708: LIST
106709: LIST
106710: PUSH
106711: EMPTY
106712: LIST
106713: LIST
106714: PPUSH
106715: CALL_OW 69
106719: PPUSH
106720: LD_VAR 0 3
106724: PPUSH
106725: CALL_OW 74
106729: PPUSH
106730: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106734: LD_VAR 0 2
106738: PUSH
106739: LD_INT 80
106741: GREATER
106742: PUSH
106743: LD_VAR 0 3
106747: PPUSH
106748: CALL_OW 301
106752: OR
106753: IFFALSE 106630
// if un then
106755: LD_VAR 0 3
106759: IFFALSE 106770
// RemoveUnit ( un ) ;
106761: LD_VAR 0 3
106765: PPUSH
106766: CALL_OW 64
// end ;
106770: PPOPN 3
106772: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106773: LD_EXP 131
106777: IFFALSE 106893
106779: GO 106781
106781: DISABLE
106782: LD_INT 0
106784: PPUSH
106785: PPUSH
106786: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106787: LD_ADDR_VAR 0 2
106791: PUSH
106792: LD_INT 81
106794: PUSH
106795: LD_OWVAR 2
106799: PUSH
106800: EMPTY
106801: LIST
106802: LIST
106803: PUSH
106804: LD_INT 21
106806: PUSH
106807: LD_INT 1
106809: PUSH
106810: EMPTY
106811: LIST
106812: LIST
106813: PUSH
106814: EMPTY
106815: LIST
106816: LIST
106817: PPUSH
106818: CALL_OW 69
106822: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106823: LD_STRING playComputer()
106825: PPUSH
106826: CALL_OW 559
// if not tmp then
106830: LD_VAR 0 2
106834: NOT
106835: IFFALSE 106839
// exit ;
106837: GO 106893
// for i in tmp do
106839: LD_ADDR_VAR 0 1
106843: PUSH
106844: LD_VAR 0 2
106848: PUSH
106849: FOR_IN
106850: IFFALSE 106891
// for j := 1 to 4 do
106852: LD_ADDR_VAR 0 3
106856: PUSH
106857: DOUBLE
106858: LD_INT 1
106860: DEC
106861: ST_TO_ADDR
106862: LD_INT 4
106864: PUSH
106865: FOR_TO
106866: IFFALSE 106887
// SetSkill ( i , j , 10 ) ;
106868: LD_VAR 0 1
106872: PPUSH
106873: LD_VAR 0 3
106877: PPUSH
106878: LD_INT 10
106880: PPUSH
106881: CALL_OW 237
106885: GO 106865
106887: POP
106888: POP
106889: GO 106849
106891: POP
106892: POP
// end ;
106893: PPOPN 3
106895: END
// every 0 0$1 trigger s30 do var i , tmp ;
106896: LD_EXP 132
106900: IFFALSE 106969
106902: GO 106904
106904: DISABLE
106905: LD_INT 0
106907: PPUSH
106908: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106909: LD_ADDR_VAR 0 2
106913: PUSH
106914: LD_INT 22
106916: PUSH
106917: LD_OWVAR 2
106921: PUSH
106922: EMPTY
106923: LIST
106924: LIST
106925: PPUSH
106926: CALL_OW 69
106930: ST_TO_ADDR
// if not tmp then
106931: LD_VAR 0 2
106935: NOT
106936: IFFALSE 106940
// exit ;
106938: GO 106969
// for i in tmp do
106940: LD_ADDR_VAR 0 1
106944: PUSH
106945: LD_VAR 0 2
106949: PUSH
106950: FOR_IN
106951: IFFALSE 106967
// SetLives ( i , 300 ) ;
106953: LD_VAR 0 1
106957: PPUSH
106958: LD_INT 300
106960: PPUSH
106961: CALL_OW 234
106965: GO 106950
106967: POP
106968: POP
// end ;
106969: PPOPN 2
106971: END
// every 0 0$1 trigger s60 do var i , tmp ;
106972: LD_EXP 133
106976: IFFALSE 107045
106978: GO 106980
106980: DISABLE
106981: LD_INT 0
106983: PPUSH
106984: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
106985: LD_ADDR_VAR 0 2
106989: PUSH
106990: LD_INT 22
106992: PUSH
106993: LD_OWVAR 2
106997: PUSH
106998: EMPTY
106999: LIST
107000: LIST
107001: PPUSH
107002: CALL_OW 69
107006: ST_TO_ADDR
// if not tmp then
107007: LD_VAR 0 2
107011: NOT
107012: IFFALSE 107016
// exit ;
107014: GO 107045
// for i in tmp do
107016: LD_ADDR_VAR 0 1
107020: PUSH
107021: LD_VAR 0 2
107025: PUSH
107026: FOR_IN
107027: IFFALSE 107043
// SetLives ( i , 600 ) ;
107029: LD_VAR 0 1
107033: PPUSH
107034: LD_INT 600
107036: PPUSH
107037: CALL_OW 234
107041: GO 107026
107043: POP
107044: POP
// end ;
107045: PPOPN 2
107047: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107048: LD_INT 0
107050: PPUSH
// case cmd of 301 :
107051: LD_VAR 0 1
107055: PUSH
107056: LD_INT 301
107058: DOUBLE
107059: EQUAL
107060: IFTRUE 107064
107062: GO 107096
107064: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107065: LD_VAR 0 6
107069: PPUSH
107070: LD_VAR 0 7
107074: PPUSH
107075: LD_VAR 0 8
107079: PPUSH
107080: LD_VAR 0 4
107084: PPUSH
107085: LD_VAR 0 5
107089: PPUSH
107090: CALL 108297 0 5
107094: GO 107217
107096: LD_INT 302
107098: DOUBLE
107099: EQUAL
107100: IFTRUE 107104
107102: GO 107141
107104: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107105: LD_VAR 0 6
107109: PPUSH
107110: LD_VAR 0 7
107114: PPUSH
107115: LD_VAR 0 8
107119: PPUSH
107120: LD_VAR 0 9
107124: PPUSH
107125: LD_VAR 0 4
107129: PPUSH
107130: LD_VAR 0 5
107134: PPUSH
107135: CALL 108388 0 6
107139: GO 107217
107141: LD_INT 303
107143: DOUBLE
107144: EQUAL
107145: IFTRUE 107149
107147: GO 107186
107149: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107150: LD_VAR 0 6
107154: PPUSH
107155: LD_VAR 0 7
107159: PPUSH
107160: LD_VAR 0 8
107164: PPUSH
107165: LD_VAR 0 9
107169: PPUSH
107170: LD_VAR 0 4
107174: PPUSH
107175: LD_VAR 0 5
107179: PPUSH
107180: CALL 107222 0 6
107184: GO 107217
107186: LD_INT 304
107188: DOUBLE
107189: EQUAL
107190: IFTRUE 107194
107192: GO 107216
107194: POP
// hHackTeleport ( unit , x , y ) ; end ;
107195: LD_VAR 0 2
107199: PPUSH
107200: LD_VAR 0 4
107204: PPUSH
107205: LD_VAR 0 5
107209: PPUSH
107210: CALL 108981 0 3
107214: GO 107217
107216: POP
// end ;
107217: LD_VAR 0 12
107221: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107222: LD_INT 0
107224: PPUSH
107225: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107226: LD_VAR 0 1
107230: PUSH
107231: LD_INT 1
107233: LESS
107234: PUSH
107235: LD_VAR 0 1
107239: PUSH
107240: LD_INT 3
107242: GREATER
107243: OR
107244: PUSH
107245: LD_VAR 0 5
107249: PPUSH
107250: LD_VAR 0 6
107254: PPUSH
107255: CALL_OW 428
107259: OR
107260: IFFALSE 107264
// exit ;
107262: GO 107984
// uc_side := your_side ;
107264: LD_ADDR_OWVAR 20
107268: PUSH
107269: LD_OWVAR 2
107273: ST_TO_ADDR
// uc_nation := nation ;
107274: LD_ADDR_OWVAR 21
107278: PUSH
107279: LD_VAR 0 1
107283: ST_TO_ADDR
// bc_level = 1 ;
107284: LD_ADDR_OWVAR 43
107288: PUSH
107289: LD_INT 1
107291: ST_TO_ADDR
// case btype of 1 :
107292: LD_VAR 0 2
107296: PUSH
107297: LD_INT 1
107299: DOUBLE
107300: EQUAL
107301: IFTRUE 107305
107303: GO 107316
107305: POP
// bc_type := b_depot ; 2 :
107306: LD_ADDR_OWVAR 42
107310: PUSH
107311: LD_INT 0
107313: ST_TO_ADDR
107314: GO 107928
107316: LD_INT 2
107318: DOUBLE
107319: EQUAL
107320: IFTRUE 107324
107322: GO 107335
107324: POP
// bc_type := b_warehouse ; 3 :
107325: LD_ADDR_OWVAR 42
107329: PUSH
107330: LD_INT 1
107332: ST_TO_ADDR
107333: GO 107928
107335: LD_INT 3
107337: DOUBLE
107338: EQUAL
107339: IFTRUE 107343
107341: GO 107354
107343: POP
// bc_type := b_lab ; 4 .. 9 :
107344: LD_ADDR_OWVAR 42
107348: PUSH
107349: LD_INT 6
107351: ST_TO_ADDR
107352: GO 107928
107354: LD_INT 4
107356: DOUBLE
107357: GREATEREQUAL
107358: IFFALSE 107366
107360: LD_INT 9
107362: DOUBLE
107363: LESSEQUAL
107364: IFTRUE 107368
107366: GO 107420
107368: POP
// begin bc_type := b_lab_half ;
107369: LD_ADDR_OWVAR 42
107373: PUSH
107374: LD_INT 7
107376: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107377: LD_ADDR_OWVAR 44
107381: PUSH
107382: LD_INT 10
107384: PUSH
107385: LD_INT 11
107387: PUSH
107388: LD_INT 12
107390: PUSH
107391: LD_INT 15
107393: PUSH
107394: LD_INT 14
107396: PUSH
107397: LD_INT 13
107399: PUSH
107400: EMPTY
107401: LIST
107402: LIST
107403: LIST
107404: LIST
107405: LIST
107406: LIST
107407: PUSH
107408: LD_VAR 0 2
107412: PUSH
107413: LD_INT 3
107415: MINUS
107416: ARRAY
107417: ST_TO_ADDR
// end ; 10 .. 13 :
107418: GO 107928
107420: LD_INT 10
107422: DOUBLE
107423: GREATEREQUAL
107424: IFFALSE 107432
107426: LD_INT 13
107428: DOUBLE
107429: LESSEQUAL
107430: IFTRUE 107434
107432: GO 107511
107434: POP
// begin bc_type := b_lab_full ;
107435: LD_ADDR_OWVAR 42
107439: PUSH
107440: LD_INT 8
107442: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107443: LD_ADDR_OWVAR 44
107447: PUSH
107448: LD_INT 10
107450: PUSH
107451: LD_INT 12
107453: PUSH
107454: LD_INT 14
107456: PUSH
107457: LD_INT 13
107459: PUSH
107460: EMPTY
107461: LIST
107462: LIST
107463: LIST
107464: LIST
107465: PUSH
107466: LD_VAR 0 2
107470: PUSH
107471: LD_INT 9
107473: MINUS
107474: ARRAY
107475: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107476: LD_ADDR_OWVAR 45
107480: PUSH
107481: LD_INT 11
107483: PUSH
107484: LD_INT 15
107486: PUSH
107487: LD_INT 12
107489: PUSH
107490: LD_INT 15
107492: PUSH
107493: EMPTY
107494: LIST
107495: LIST
107496: LIST
107497: LIST
107498: PUSH
107499: LD_VAR 0 2
107503: PUSH
107504: LD_INT 9
107506: MINUS
107507: ARRAY
107508: ST_TO_ADDR
// end ; 14 :
107509: GO 107928
107511: LD_INT 14
107513: DOUBLE
107514: EQUAL
107515: IFTRUE 107519
107517: GO 107530
107519: POP
// bc_type := b_workshop ; 15 :
107520: LD_ADDR_OWVAR 42
107524: PUSH
107525: LD_INT 2
107527: ST_TO_ADDR
107528: GO 107928
107530: LD_INT 15
107532: DOUBLE
107533: EQUAL
107534: IFTRUE 107538
107536: GO 107549
107538: POP
// bc_type := b_factory ; 16 :
107539: LD_ADDR_OWVAR 42
107543: PUSH
107544: LD_INT 3
107546: ST_TO_ADDR
107547: GO 107928
107549: LD_INT 16
107551: DOUBLE
107552: EQUAL
107553: IFTRUE 107557
107555: GO 107568
107557: POP
// bc_type := b_ext_gun ; 17 :
107558: LD_ADDR_OWVAR 42
107562: PUSH
107563: LD_INT 17
107565: ST_TO_ADDR
107566: GO 107928
107568: LD_INT 17
107570: DOUBLE
107571: EQUAL
107572: IFTRUE 107576
107574: GO 107604
107576: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107577: LD_ADDR_OWVAR 42
107581: PUSH
107582: LD_INT 19
107584: PUSH
107585: LD_INT 23
107587: PUSH
107588: LD_INT 19
107590: PUSH
107591: EMPTY
107592: LIST
107593: LIST
107594: LIST
107595: PUSH
107596: LD_VAR 0 1
107600: ARRAY
107601: ST_TO_ADDR
107602: GO 107928
107604: LD_INT 18
107606: DOUBLE
107607: EQUAL
107608: IFTRUE 107612
107610: GO 107623
107612: POP
// bc_type := b_ext_radar ; 19 :
107613: LD_ADDR_OWVAR 42
107617: PUSH
107618: LD_INT 20
107620: ST_TO_ADDR
107621: GO 107928
107623: LD_INT 19
107625: DOUBLE
107626: EQUAL
107627: IFTRUE 107631
107629: GO 107642
107631: POP
// bc_type := b_ext_radio ; 20 :
107632: LD_ADDR_OWVAR 42
107636: PUSH
107637: LD_INT 22
107639: ST_TO_ADDR
107640: GO 107928
107642: LD_INT 20
107644: DOUBLE
107645: EQUAL
107646: IFTRUE 107650
107648: GO 107661
107650: POP
// bc_type := b_ext_siberium ; 21 :
107651: LD_ADDR_OWVAR 42
107655: PUSH
107656: LD_INT 21
107658: ST_TO_ADDR
107659: GO 107928
107661: LD_INT 21
107663: DOUBLE
107664: EQUAL
107665: IFTRUE 107669
107667: GO 107680
107669: POP
// bc_type := b_ext_computer ; 22 :
107670: LD_ADDR_OWVAR 42
107674: PUSH
107675: LD_INT 24
107677: ST_TO_ADDR
107678: GO 107928
107680: LD_INT 22
107682: DOUBLE
107683: EQUAL
107684: IFTRUE 107688
107686: GO 107699
107688: POP
// bc_type := b_ext_track ; 23 :
107689: LD_ADDR_OWVAR 42
107693: PUSH
107694: LD_INT 16
107696: ST_TO_ADDR
107697: GO 107928
107699: LD_INT 23
107701: DOUBLE
107702: EQUAL
107703: IFTRUE 107707
107705: GO 107718
107707: POP
// bc_type := b_ext_laser ; 24 :
107708: LD_ADDR_OWVAR 42
107712: PUSH
107713: LD_INT 25
107715: ST_TO_ADDR
107716: GO 107928
107718: LD_INT 24
107720: DOUBLE
107721: EQUAL
107722: IFTRUE 107726
107724: GO 107737
107726: POP
// bc_type := b_control_tower ; 25 :
107727: LD_ADDR_OWVAR 42
107731: PUSH
107732: LD_INT 36
107734: ST_TO_ADDR
107735: GO 107928
107737: LD_INT 25
107739: DOUBLE
107740: EQUAL
107741: IFTRUE 107745
107743: GO 107756
107745: POP
// bc_type := b_breastwork ; 26 :
107746: LD_ADDR_OWVAR 42
107750: PUSH
107751: LD_INT 31
107753: ST_TO_ADDR
107754: GO 107928
107756: LD_INT 26
107758: DOUBLE
107759: EQUAL
107760: IFTRUE 107764
107762: GO 107775
107764: POP
// bc_type := b_bunker ; 27 :
107765: LD_ADDR_OWVAR 42
107769: PUSH
107770: LD_INT 32
107772: ST_TO_ADDR
107773: GO 107928
107775: LD_INT 27
107777: DOUBLE
107778: EQUAL
107779: IFTRUE 107783
107781: GO 107794
107783: POP
// bc_type := b_turret ; 28 :
107784: LD_ADDR_OWVAR 42
107788: PUSH
107789: LD_INT 33
107791: ST_TO_ADDR
107792: GO 107928
107794: LD_INT 28
107796: DOUBLE
107797: EQUAL
107798: IFTRUE 107802
107800: GO 107813
107802: POP
// bc_type := b_armoury ; 29 :
107803: LD_ADDR_OWVAR 42
107807: PUSH
107808: LD_INT 4
107810: ST_TO_ADDR
107811: GO 107928
107813: LD_INT 29
107815: DOUBLE
107816: EQUAL
107817: IFTRUE 107821
107819: GO 107832
107821: POP
// bc_type := b_barracks ; 30 :
107822: LD_ADDR_OWVAR 42
107826: PUSH
107827: LD_INT 5
107829: ST_TO_ADDR
107830: GO 107928
107832: LD_INT 30
107834: DOUBLE
107835: EQUAL
107836: IFTRUE 107840
107838: GO 107851
107840: POP
// bc_type := b_solar_power ; 31 :
107841: LD_ADDR_OWVAR 42
107845: PUSH
107846: LD_INT 27
107848: ST_TO_ADDR
107849: GO 107928
107851: LD_INT 31
107853: DOUBLE
107854: EQUAL
107855: IFTRUE 107859
107857: GO 107870
107859: POP
// bc_type := b_oil_power ; 32 :
107860: LD_ADDR_OWVAR 42
107864: PUSH
107865: LD_INT 26
107867: ST_TO_ADDR
107868: GO 107928
107870: LD_INT 32
107872: DOUBLE
107873: EQUAL
107874: IFTRUE 107878
107876: GO 107889
107878: POP
// bc_type := b_siberite_power ; 33 :
107879: LD_ADDR_OWVAR 42
107883: PUSH
107884: LD_INT 28
107886: ST_TO_ADDR
107887: GO 107928
107889: LD_INT 33
107891: DOUBLE
107892: EQUAL
107893: IFTRUE 107897
107895: GO 107908
107897: POP
// bc_type := b_oil_mine ; 34 :
107898: LD_ADDR_OWVAR 42
107902: PUSH
107903: LD_INT 29
107905: ST_TO_ADDR
107906: GO 107928
107908: LD_INT 34
107910: DOUBLE
107911: EQUAL
107912: IFTRUE 107916
107914: GO 107927
107916: POP
// bc_type := b_siberite_mine ; end ;
107917: LD_ADDR_OWVAR 42
107921: PUSH
107922: LD_INT 30
107924: ST_TO_ADDR
107925: GO 107928
107927: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
107928: LD_ADDR_VAR 0 8
107932: PUSH
107933: LD_VAR 0 5
107937: PPUSH
107938: LD_VAR 0 6
107942: PPUSH
107943: LD_VAR 0 3
107947: PPUSH
107948: CALL_OW 47
107952: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
107953: LD_OWVAR 42
107957: PUSH
107958: LD_INT 32
107960: PUSH
107961: LD_INT 33
107963: PUSH
107964: EMPTY
107965: LIST
107966: LIST
107967: IN
107968: IFFALSE 107984
// PlaceWeaponTurret ( b , weapon ) ;
107970: LD_VAR 0 8
107974: PPUSH
107975: LD_VAR 0 4
107979: PPUSH
107980: CALL_OW 431
// end ;
107984: LD_VAR 0 7
107988: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
107989: LD_INT 0
107991: PPUSH
107992: PPUSH
107993: PPUSH
107994: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
107995: LD_ADDR_VAR 0 4
107999: PUSH
108000: LD_INT 22
108002: PUSH
108003: LD_OWVAR 2
108007: PUSH
108008: EMPTY
108009: LIST
108010: LIST
108011: PUSH
108012: LD_INT 2
108014: PUSH
108015: LD_INT 30
108017: PUSH
108018: LD_INT 0
108020: PUSH
108021: EMPTY
108022: LIST
108023: LIST
108024: PUSH
108025: LD_INT 30
108027: PUSH
108028: LD_INT 1
108030: PUSH
108031: EMPTY
108032: LIST
108033: LIST
108034: PUSH
108035: EMPTY
108036: LIST
108037: LIST
108038: LIST
108039: PUSH
108040: EMPTY
108041: LIST
108042: LIST
108043: PPUSH
108044: CALL_OW 69
108048: ST_TO_ADDR
// if not tmp then
108049: LD_VAR 0 4
108053: NOT
108054: IFFALSE 108058
// exit ;
108056: GO 108117
// for i in tmp do
108058: LD_ADDR_VAR 0 2
108062: PUSH
108063: LD_VAR 0 4
108067: PUSH
108068: FOR_IN
108069: IFFALSE 108115
// for j = 1 to 3 do
108071: LD_ADDR_VAR 0 3
108075: PUSH
108076: DOUBLE
108077: LD_INT 1
108079: DEC
108080: ST_TO_ADDR
108081: LD_INT 3
108083: PUSH
108084: FOR_TO
108085: IFFALSE 108111
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108087: LD_VAR 0 2
108091: PPUSH
108092: CALL_OW 274
108096: PPUSH
108097: LD_VAR 0 3
108101: PPUSH
108102: LD_INT 99999
108104: PPUSH
108105: CALL_OW 277
108109: GO 108084
108111: POP
108112: POP
108113: GO 108068
108115: POP
108116: POP
// end ;
108117: LD_VAR 0 1
108121: RET
// export function hHackSetLevel10 ; var i , j ; begin
108122: LD_INT 0
108124: PPUSH
108125: PPUSH
108126: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108127: LD_ADDR_VAR 0 2
108131: PUSH
108132: LD_INT 21
108134: PUSH
108135: LD_INT 1
108137: PUSH
108138: EMPTY
108139: LIST
108140: LIST
108141: PPUSH
108142: CALL_OW 69
108146: PUSH
108147: FOR_IN
108148: IFFALSE 108200
// if IsSelected ( i ) then
108150: LD_VAR 0 2
108154: PPUSH
108155: CALL_OW 306
108159: IFFALSE 108198
// begin for j := 1 to 4 do
108161: LD_ADDR_VAR 0 3
108165: PUSH
108166: DOUBLE
108167: LD_INT 1
108169: DEC
108170: ST_TO_ADDR
108171: LD_INT 4
108173: PUSH
108174: FOR_TO
108175: IFFALSE 108196
// SetSkill ( i , j , 10 ) ;
108177: LD_VAR 0 2
108181: PPUSH
108182: LD_VAR 0 3
108186: PPUSH
108187: LD_INT 10
108189: PPUSH
108190: CALL_OW 237
108194: GO 108174
108196: POP
108197: POP
// end ;
108198: GO 108147
108200: POP
108201: POP
// end ;
108202: LD_VAR 0 1
108206: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108207: LD_INT 0
108209: PPUSH
108210: PPUSH
108211: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108212: LD_ADDR_VAR 0 2
108216: PUSH
108217: LD_INT 22
108219: PUSH
108220: LD_OWVAR 2
108224: PUSH
108225: EMPTY
108226: LIST
108227: LIST
108228: PUSH
108229: LD_INT 21
108231: PUSH
108232: LD_INT 1
108234: PUSH
108235: EMPTY
108236: LIST
108237: LIST
108238: PUSH
108239: EMPTY
108240: LIST
108241: LIST
108242: PPUSH
108243: CALL_OW 69
108247: PUSH
108248: FOR_IN
108249: IFFALSE 108290
// begin for j := 1 to 4 do
108251: LD_ADDR_VAR 0 3
108255: PUSH
108256: DOUBLE
108257: LD_INT 1
108259: DEC
108260: ST_TO_ADDR
108261: LD_INT 4
108263: PUSH
108264: FOR_TO
108265: IFFALSE 108286
// SetSkill ( i , j , 10 ) ;
108267: LD_VAR 0 2
108271: PPUSH
108272: LD_VAR 0 3
108276: PPUSH
108277: LD_INT 10
108279: PPUSH
108280: CALL_OW 237
108284: GO 108264
108286: POP
108287: POP
// end ;
108288: GO 108248
108290: POP
108291: POP
// end ;
108292: LD_VAR 0 1
108296: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108297: LD_INT 0
108299: PPUSH
// uc_side := your_side ;
108300: LD_ADDR_OWVAR 20
108304: PUSH
108305: LD_OWVAR 2
108309: ST_TO_ADDR
// uc_nation := nation ;
108310: LD_ADDR_OWVAR 21
108314: PUSH
108315: LD_VAR 0 1
108319: ST_TO_ADDR
// InitHc ;
108320: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108324: LD_INT 0
108326: PPUSH
108327: LD_VAR 0 2
108331: PPUSH
108332: LD_VAR 0 3
108336: PPUSH
108337: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108341: LD_VAR 0 4
108345: PPUSH
108346: LD_VAR 0 5
108350: PPUSH
108351: CALL_OW 428
108355: PUSH
108356: LD_INT 0
108358: EQUAL
108359: IFFALSE 108383
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108361: CALL_OW 44
108365: PPUSH
108366: LD_VAR 0 4
108370: PPUSH
108371: LD_VAR 0 5
108375: PPUSH
108376: LD_INT 1
108378: PPUSH
108379: CALL_OW 48
// end ;
108383: LD_VAR 0 6
108387: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108388: LD_INT 0
108390: PPUSH
108391: PPUSH
// uc_side := your_side ;
108392: LD_ADDR_OWVAR 20
108396: PUSH
108397: LD_OWVAR 2
108401: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108402: LD_VAR 0 1
108406: PUSH
108407: LD_INT 1
108409: PUSH
108410: LD_INT 2
108412: PUSH
108413: LD_INT 3
108415: PUSH
108416: LD_INT 4
108418: PUSH
108419: LD_INT 5
108421: PUSH
108422: EMPTY
108423: LIST
108424: LIST
108425: LIST
108426: LIST
108427: LIST
108428: IN
108429: IFFALSE 108441
// uc_nation := nation_american else
108431: LD_ADDR_OWVAR 21
108435: PUSH
108436: LD_INT 1
108438: ST_TO_ADDR
108439: GO 108484
// if chassis in [ 11 , 12 , 13 , 14 ] then
108441: LD_VAR 0 1
108445: PUSH
108446: LD_INT 11
108448: PUSH
108449: LD_INT 12
108451: PUSH
108452: LD_INT 13
108454: PUSH
108455: LD_INT 14
108457: PUSH
108458: EMPTY
108459: LIST
108460: LIST
108461: LIST
108462: LIST
108463: IN
108464: IFFALSE 108476
// uc_nation := nation_arabian else
108466: LD_ADDR_OWVAR 21
108470: PUSH
108471: LD_INT 2
108473: ST_TO_ADDR
108474: GO 108484
// uc_nation := nation_russian ;
108476: LD_ADDR_OWVAR 21
108480: PUSH
108481: LD_INT 3
108483: ST_TO_ADDR
// vc_chassis := chassis ;
108484: LD_ADDR_OWVAR 37
108488: PUSH
108489: LD_VAR 0 1
108493: ST_TO_ADDR
// vc_engine := engine ;
108494: LD_ADDR_OWVAR 39
108498: PUSH
108499: LD_VAR 0 2
108503: ST_TO_ADDR
// vc_control := control ;
108504: LD_ADDR_OWVAR 38
108508: PUSH
108509: LD_VAR 0 3
108513: ST_TO_ADDR
// vc_weapon := weapon ;
108514: LD_ADDR_OWVAR 40
108518: PUSH
108519: LD_VAR 0 4
108523: ST_TO_ADDR
// un := CreateVehicle ;
108524: LD_ADDR_VAR 0 8
108528: PUSH
108529: CALL_OW 45
108533: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108534: LD_VAR 0 8
108538: PPUSH
108539: LD_INT 0
108541: PPUSH
108542: LD_INT 5
108544: PPUSH
108545: CALL_OW 12
108549: PPUSH
108550: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108554: LD_VAR 0 8
108558: PPUSH
108559: LD_VAR 0 5
108563: PPUSH
108564: LD_VAR 0 6
108568: PPUSH
108569: LD_INT 1
108571: PPUSH
108572: CALL_OW 48
// end ;
108576: LD_VAR 0 7
108580: RET
// export hInvincible ; every 1 do
108581: GO 108583
108583: DISABLE
// hInvincible := [ ] ;
108584: LD_ADDR_EXP 134
108588: PUSH
108589: EMPTY
108590: ST_TO_ADDR
108591: END
// every 10 do var i ;
108592: GO 108594
108594: DISABLE
108595: LD_INT 0
108597: PPUSH
// begin enable ;
108598: ENABLE
// if not hInvincible then
108599: LD_EXP 134
108603: NOT
108604: IFFALSE 108608
// exit ;
108606: GO 108652
// for i in hInvincible do
108608: LD_ADDR_VAR 0 1
108612: PUSH
108613: LD_EXP 134
108617: PUSH
108618: FOR_IN
108619: IFFALSE 108650
// if GetLives ( i ) < 1000 then
108621: LD_VAR 0 1
108625: PPUSH
108626: CALL_OW 256
108630: PUSH
108631: LD_INT 1000
108633: LESS
108634: IFFALSE 108648
// SetLives ( i , 1000 ) ;
108636: LD_VAR 0 1
108640: PPUSH
108641: LD_INT 1000
108643: PPUSH
108644: CALL_OW 234
108648: GO 108618
108650: POP
108651: POP
// end ;
108652: PPOPN 1
108654: END
// export function hHackInvincible ; var i ; begin
108655: LD_INT 0
108657: PPUSH
108658: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108659: LD_ADDR_VAR 0 2
108663: PUSH
108664: LD_INT 2
108666: PUSH
108667: LD_INT 21
108669: PUSH
108670: LD_INT 1
108672: PUSH
108673: EMPTY
108674: LIST
108675: LIST
108676: PUSH
108677: LD_INT 21
108679: PUSH
108680: LD_INT 2
108682: PUSH
108683: EMPTY
108684: LIST
108685: LIST
108686: PUSH
108687: EMPTY
108688: LIST
108689: LIST
108690: LIST
108691: PPUSH
108692: CALL_OW 69
108696: PUSH
108697: FOR_IN
108698: IFFALSE 108759
// if IsSelected ( i ) then
108700: LD_VAR 0 2
108704: PPUSH
108705: CALL_OW 306
108709: IFFALSE 108757
// begin if i in hInvincible then
108711: LD_VAR 0 2
108715: PUSH
108716: LD_EXP 134
108720: IN
108721: IFFALSE 108741
// hInvincible := hInvincible diff i else
108723: LD_ADDR_EXP 134
108727: PUSH
108728: LD_EXP 134
108732: PUSH
108733: LD_VAR 0 2
108737: DIFF
108738: ST_TO_ADDR
108739: GO 108757
// hInvincible := hInvincible union i ;
108741: LD_ADDR_EXP 134
108745: PUSH
108746: LD_EXP 134
108750: PUSH
108751: LD_VAR 0 2
108755: UNION
108756: ST_TO_ADDR
// end ;
108757: GO 108697
108759: POP
108760: POP
// end ;
108761: LD_VAR 0 1
108765: RET
// export function hHackInvisible ; var i , j ; begin
108766: LD_INT 0
108768: PPUSH
108769: PPUSH
108770: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108771: LD_ADDR_VAR 0 2
108775: PUSH
108776: LD_INT 21
108778: PUSH
108779: LD_INT 1
108781: PUSH
108782: EMPTY
108783: LIST
108784: LIST
108785: PPUSH
108786: CALL_OW 69
108790: PUSH
108791: FOR_IN
108792: IFFALSE 108816
// if IsSelected ( i ) then
108794: LD_VAR 0 2
108798: PPUSH
108799: CALL_OW 306
108803: IFFALSE 108814
// ComForceInvisible ( i ) ;
108805: LD_VAR 0 2
108809: PPUSH
108810: CALL_OW 496
108814: GO 108791
108816: POP
108817: POP
// end ;
108818: LD_VAR 0 1
108822: RET
// export function hHackChangeYourSide ; begin
108823: LD_INT 0
108825: PPUSH
// if your_side = 8 then
108826: LD_OWVAR 2
108830: PUSH
108831: LD_INT 8
108833: EQUAL
108834: IFFALSE 108846
// your_side := 0 else
108836: LD_ADDR_OWVAR 2
108840: PUSH
108841: LD_INT 0
108843: ST_TO_ADDR
108844: GO 108860
// your_side := your_side + 1 ;
108846: LD_ADDR_OWVAR 2
108850: PUSH
108851: LD_OWVAR 2
108855: PUSH
108856: LD_INT 1
108858: PLUS
108859: ST_TO_ADDR
// end ;
108860: LD_VAR 0 1
108864: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108865: LD_INT 0
108867: PPUSH
108868: PPUSH
108869: PPUSH
// for i in all_units do
108870: LD_ADDR_VAR 0 2
108874: PUSH
108875: LD_OWVAR 3
108879: PUSH
108880: FOR_IN
108881: IFFALSE 108959
// if IsSelected ( i ) then
108883: LD_VAR 0 2
108887: PPUSH
108888: CALL_OW 306
108892: IFFALSE 108957
// begin j := GetSide ( i ) ;
108894: LD_ADDR_VAR 0 3
108898: PUSH
108899: LD_VAR 0 2
108903: PPUSH
108904: CALL_OW 255
108908: ST_TO_ADDR
// if j = 8 then
108909: LD_VAR 0 3
108913: PUSH
108914: LD_INT 8
108916: EQUAL
108917: IFFALSE 108929
// j := 0 else
108919: LD_ADDR_VAR 0 3
108923: PUSH
108924: LD_INT 0
108926: ST_TO_ADDR
108927: GO 108943
// j := j + 1 ;
108929: LD_ADDR_VAR 0 3
108933: PUSH
108934: LD_VAR 0 3
108938: PUSH
108939: LD_INT 1
108941: PLUS
108942: ST_TO_ADDR
// SetSide ( i , j ) ;
108943: LD_VAR 0 2
108947: PPUSH
108948: LD_VAR 0 3
108952: PPUSH
108953: CALL_OW 235
// end ;
108957: GO 108880
108959: POP
108960: POP
// end ;
108961: LD_VAR 0 1
108965: RET
// export function hHackFog ; begin
108966: LD_INT 0
108968: PPUSH
// FogOff ( true ) ;
108969: LD_INT 1
108971: PPUSH
108972: CALL_OW 344
// end ;
108976: LD_VAR 0 1
108980: RET
// export function hHackTeleport ( unit , x , y ) ; begin
108981: LD_INT 0
108983: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
108984: LD_VAR 0 1
108988: PPUSH
108989: LD_VAR 0 2
108993: PPUSH
108994: LD_VAR 0 3
108998: PPUSH
108999: LD_INT 1
109001: PPUSH
109002: LD_INT 1
109004: PPUSH
109005: CALL_OW 483
// CenterOnXY ( x , y ) ;
109009: LD_VAR 0 2
109013: PPUSH
109014: LD_VAR 0 3
109018: PPUSH
109019: CALL_OW 84
// end ;
109023: LD_VAR 0 4
109027: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109028: LD_INT 0
109030: PPUSH
109031: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109032: LD_VAR 0 1
109036: NOT
109037: PUSH
109038: LD_VAR 0 2
109042: PPUSH
109043: LD_VAR 0 3
109047: PPUSH
109048: CALL_OW 488
109052: NOT
109053: OR
109054: PUSH
109055: LD_VAR 0 1
109059: PPUSH
109060: CALL_OW 266
109064: PUSH
109065: LD_INT 3
109067: NONEQUAL
109068: PUSH
109069: LD_VAR 0 1
109073: PPUSH
109074: CALL_OW 247
109078: PUSH
109079: LD_INT 1
109081: EQUAL
109082: NOT
109083: AND
109084: OR
109085: IFFALSE 109089
// exit ;
109087: GO 109238
// if GetType ( factory ) = unit_human then
109089: LD_VAR 0 1
109093: PPUSH
109094: CALL_OW 247
109098: PUSH
109099: LD_INT 1
109101: EQUAL
109102: IFFALSE 109119
// factory := IsInUnit ( factory ) ;
109104: LD_ADDR_VAR 0 1
109108: PUSH
109109: LD_VAR 0 1
109113: PPUSH
109114: CALL_OW 310
109118: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109119: LD_VAR 0 1
109123: PPUSH
109124: CALL_OW 266
109128: PUSH
109129: LD_INT 3
109131: NONEQUAL
109132: IFFALSE 109136
// exit ;
109134: GO 109238
// if HexInfo ( x , y ) = factory then
109136: LD_VAR 0 2
109140: PPUSH
109141: LD_VAR 0 3
109145: PPUSH
109146: CALL_OW 428
109150: PUSH
109151: LD_VAR 0 1
109155: EQUAL
109156: IFFALSE 109183
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109158: LD_ADDR_EXP 135
109162: PUSH
109163: LD_EXP 135
109167: PPUSH
109168: LD_VAR 0 1
109172: PPUSH
109173: LD_INT 0
109175: PPUSH
109176: CALL_OW 1
109180: ST_TO_ADDR
109181: GO 109234
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109183: LD_ADDR_EXP 135
109187: PUSH
109188: LD_EXP 135
109192: PPUSH
109193: LD_VAR 0 1
109197: PPUSH
109198: LD_VAR 0 1
109202: PPUSH
109203: CALL_OW 255
109207: PUSH
109208: LD_VAR 0 1
109212: PUSH
109213: LD_VAR 0 2
109217: PUSH
109218: LD_VAR 0 3
109222: PUSH
109223: EMPTY
109224: LIST
109225: LIST
109226: LIST
109227: LIST
109228: PPUSH
109229: CALL_OW 1
109233: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109234: CALL 109243 0 0
// end ;
109238: LD_VAR 0 4
109242: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109243: LD_INT 0
109245: PPUSH
109246: PPUSH
109247: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109248: LD_STRING resetFactoryWaypoint();
109250: PPUSH
109251: CALL_OW 559
// if factoryWaypoints then
109255: LD_EXP 135
109259: IFFALSE 109385
// begin list := PrepareArray ( factoryWaypoints ) ;
109261: LD_ADDR_VAR 0 3
109265: PUSH
109266: LD_EXP 135
109270: PPUSH
109271: CALL 52222 0 1
109275: ST_TO_ADDR
// for i := 1 to list do
109276: LD_ADDR_VAR 0 2
109280: PUSH
109281: DOUBLE
109282: LD_INT 1
109284: DEC
109285: ST_TO_ADDR
109286: LD_VAR 0 3
109290: PUSH
109291: FOR_TO
109292: IFFALSE 109383
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109294: LD_STRING setFactoryWaypointXY(
109296: PUSH
109297: LD_VAR 0 3
109301: PUSH
109302: LD_VAR 0 2
109306: ARRAY
109307: PUSH
109308: LD_INT 1
109310: ARRAY
109311: STR
109312: PUSH
109313: LD_STRING ,
109315: STR
109316: PUSH
109317: LD_VAR 0 3
109321: PUSH
109322: LD_VAR 0 2
109326: ARRAY
109327: PUSH
109328: LD_INT 2
109330: ARRAY
109331: STR
109332: PUSH
109333: LD_STRING ,
109335: STR
109336: PUSH
109337: LD_VAR 0 3
109341: PUSH
109342: LD_VAR 0 2
109346: ARRAY
109347: PUSH
109348: LD_INT 3
109350: ARRAY
109351: STR
109352: PUSH
109353: LD_STRING ,
109355: STR
109356: PUSH
109357: LD_VAR 0 3
109361: PUSH
109362: LD_VAR 0 2
109366: ARRAY
109367: PUSH
109368: LD_INT 4
109370: ARRAY
109371: STR
109372: PUSH
109373: LD_STRING )
109375: STR
109376: PPUSH
109377: CALL_OW 559
109381: GO 109291
109383: POP
109384: POP
// end ; end ;
109385: LD_VAR 0 1
109389: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109390: LD_INT 0
109392: PPUSH
// if HexInfo ( x , y ) = warehouse then
109393: LD_VAR 0 2
109397: PPUSH
109398: LD_VAR 0 3
109402: PPUSH
109403: CALL_OW 428
109407: PUSH
109408: LD_VAR 0 1
109412: EQUAL
109413: IFFALSE 109440
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109415: LD_ADDR_EXP 136
109419: PUSH
109420: LD_EXP 136
109424: PPUSH
109425: LD_VAR 0 1
109429: PPUSH
109430: LD_INT 0
109432: PPUSH
109433: CALL_OW 1
109437: ST_TO_ADDR
109438: GO 109491
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109440: LD_ADDR_EXP 136
109444: PUSH
109445: LD_EXP 136
109449: PPUSH
109450: LD_VAR 0 1
109454: PPUSH
109455: LD_VAR 0 1
109459: PPUSH
109460: CALL_OW 255
109464: PUSH
109465: LD_VAR 0 1
109469: PUSH
109470: LD_VAR 0 2
109474: PUSH
109475: LD_VAR 0 3
109479: PUSH
109480: EMPTY
109481: LIST
109482: LIST
109483: LIST
109484: LIST
109485: PPUSH
109486: CALL_OW 1
109490: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109491: CALL 109500 0 0
// end ;
109495: LD_VAR 0 4
109499: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109500: LD_INT 0
109502: PPUSH
109503: PPUSH
109504: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109505: LD_STRING resetWarehouseGatheringPoints();
109507: PPUSH
109508: CALL_OW 559
// if warehouseGatheringPoints then
109512: LD_EXP 136
109516: IFFALSE 109642
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109518: LD_ADDR_VAR 0 3
109522: PUSH
109523: LD_EXP 136
109527: PPUSH
109528: CALL 52222 0 1
109532: ST_TO_ADDR
// for i := 1 to list do
109533: LD_ADDR_VAR 0 2
109537: PUSH
109538: DOUBLE
109539: LD_INT 1
109541: DEC
109542: ST_TO_ADDR
109543: LD_VAR 0 3
109547: PUSH
109548: FOR_TO
109549: IFFALSE 109640
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109551: LD_STRING setWarehouseGatheringPointXY(
109553: PUSH
109554: LD_VAR 0 3
109558: PUSH
109559: LD_VAR 0 2
109563: ARRAY
109564: PUSH
109565: LD_INT 1
109567: ARRAY
109568: STR
109569: PUSH
109570: LD_STRING ,
109572: STR
109573: PUSH
109574: LD_VAR 0 3
109578: PUSH
109579: LD_VAR 0 2
109583: ARRAY
109584: PUSH
109585: LD_INT 2
109587: ARRAY
109588: STR
109589: PUSH
109590: LD_STRING ,
109592: STR
109593: PUSH
109594: LD_VAR 0 3
109598: PUSH
109599: LD_VAR 0 2
109603: ARRAY
109604: PUSH
109605: LD_INT 3
109607: ARRAY
109608: STR
109609: PUSH
109610: LD_STRING ,
109612: STR
109613: PUSH
109614: LD_VAR 0 3
109618: PUSH
109619: LD_VAR 0 2
109623: ARRAY
109624: PUSH
109625: LD_INT 4
109627: ARRAY
109628: STR
109629: PUSH
109630: LD_STRING )
109632: STR
109633: PPUSH
109634: CALL_OW 559
109638: GO 109548
109640: POP
109641: POP
// end ; end ;
109642: LD_VAR 0 1
109646: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109647: LD_EXP 136
109651: IFFALSE 110336
109653: GO 109655
109655: DISABLE
109656: LD_INT 0
109658: PPUSH
109659: PPUSH
109660: PPUSH
109661: PPUSH
109662: PPUSH
109663: PPUSH
109664: PPUSH
109665: PPUSH
109666: PPUSH
// begin enable ;
109667: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109668: LD_ADDR_VAR 0 3
109672: PUSH
109673: LD_EXP 136
109677: PPUSH
109678: CALL 52222 0 1
109682: ST_TO_ADDR
// if not list then
109683: LD_VAR 0 3
109687: NOT
109688: IFFALSE 109692
// exit ;
109690: GO 110336
// for i := 1 to list do
109692: LD_ADDR_VAR 0 1
109696: PUSH
109697: DOUBLE
109698: LD_INT 1
109700: DEC
109701: ST_TO_ADDR
109702: LD_VAR 0 3
109706: PUSH
109707: FOR_TO
109708: IFFALSE 110334
// begin depot := list [ i ] [ 2 ] ;
109710: LD_ADDR_VAR 0 8
109714: PUSH
109715: LD_VAR 0 3
109719: PUSH
109720: LD_VAR 0 1
109724: ARRAY
109725: PUSH
109726: LD_INT 2
109728: ARRAY
109729: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109730: LD_ADDR_VAR 0 5
109734: PUSH
109735: LD_VAR 0 3
109739: PUSH
109740: LD_VAR 0 1
109744: ARRAY
109745: PUSH
109746: LD_INT 1
109748: ARRAY
109749: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109750: LD_VAR 0 8
109754: PPUSH
109755: CALL_OW 301
109759: PUSH
109760: LD_VAR 0 5
109764: PUSH
109765: LD_VAR 0 8
109769: PPUSH
109770: CALL_OW 255
109774: NONEQUAL
109775: OR
109776: IFFALSE 109805
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109778: LD_ADDR_EXP 136
109782: PUSH
109783: LD_EXP 136
109787: PPUSH
109788: LD_VAR 0 8
109792: PPUSH
109793: LD_INT 0
109795: PPUSH
109796: CALL_OW 1
109800: ST_TO_ADDR
// exit ;
109801: POP
109802: POP
109803: GO 110336
// end ; x := list [ i ] [ 3 ] ;
109805: LD_ADDR_VAR 0 6
109809: PUSH
109810: LD_VAR 0 3
109814: PUSH
109815: LD_VAR 0 1
109819: ARRAY
109820: PUSH
109821: LD_INT 3
109823: ARRAY
109824: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109825: LD_ADDR_VAR 0 7
109829: PUSH
109830: LD_VAR 0 3
109834: PUSH
109835: LD_VAR 0 1
109839: ARRAY
109840: PUSH
109841: LD_INT 4
109843: ARRAY
109844: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109845: LD_ADDR_VAR 0 9
109849: PUSH
109850: LD_VAR 0 6
109854: PPUSH
109855: LD_VAR 0 7
109859: PPUSH
109860: LD_INT 16
109862: PPUSH
109863: CALL 50810 0 3
109867: ST_TO_ADDR
// if not cratesNearbyPoint then
109868: LD_VAR 0 9
109872: NOT
109873: IFFALSE 109879
// exit ;
109875: POP
109876: POP
109877: GO 110336
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109879: LD_ADDR_VAR 0 4
109883: PUSH
109884: LD_INT 22
109886: PUSH
109887: LD_VAR 0 5
109891: PUSH
109892: EMPTY
109893: LIST
109894: LIST
109895: PUSH
109896: LD_INT 3
109898: PUSH
109899: LD_INT 60
109901: PUSH
109902: EMPTY
109903: LIST
109904: PUSH
109905: EMPTY
109906: LIST
109907: LIST
109908: PUSH
109909: LD_INT 91
109911: PUSH
109912: LD_VAR 0 8
109916: PUSH
109917: LD_INT 6
109919: PUSH
109920: EMPTY
109921: LIST
109922: LIST
109923: LIST
109924: PUSH
109925: LD_INT 2
109927: PUSH
109928: LD_INT 25
109930: PUSH
109931: LD_INT 2
109933: PUSH
109934: EMPTY
109935: LIST
109936: LIST
109937: PUSH
109938: LD_INT 25
109940: PUSH
109941: LD_INT 16
109943: PUSH
109944: EMPTY
109945: LIST
109946: LIST
109947: PUSH
109948: EMPTY
109949: LIST
109950: LIST
109951: LIST
109952: PUSH
109953: EMPTY
109954: LIST
109955: LIST
109956: LIST
109957: LIST
109958: PPUSH
109959: CALL_OW 69
109963: PUSH
109964: LD_VAR 0 8
109968: PPUSH
109969: CALL_OW 313
109973: PPUSH
109974: LD_INT 3
109976: PUSH
109977: LD_INT 60
109979: PUSH
109980: EMPTY
109981: LIST
109982: PUSH
109983: EMPTY
109984: LIST
109985: LIST
109986: PUSH
109987: LD_INT 2
109989: PUSH
109990: LD_INT 25
109992: PUSH
109993: LD_INT 2
109995: PUSH
109996: EMPTY
109997: LIST
109998: LIST
109999: PUSH
110000: LD_INT 25
110002: PUSH
110003: LD_INT 16
110005: PUSH
110006: EMPTY
110007: LIST
110008: LIST
110009: PUSH
110010: EMPTY
110011: LIST
110012: LIST
110013: LIST
110014: PUSH
110015: EMPTY
110016: LIST
110017: LIST
110018: PPUSH
110019: CALL_OW 72
110023: UNION
110024: ST_TO_ADDR
// if tmp then
110025: LD_VAR 0 4
110029: IFFALSE 110109
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110031: LD_ADDR_VAR 0 4
110035: PUSH
110036: LD_VAR 0 4
110040: PPUSH
110041: LD_INT 3
110043: PPUSH
110044: CALL 48779 0 2
110048: ST_TO_ADDR
// for j in tmp do
110049: LD_ADDR_VAR 0 2
110053: PUSH
110054: LD_VAR 0 4
110058: PUSH
110059: FOR_IN
110060: IFFALSE 110103
// begin if IsInUnit ( j ) then
110062: LD_VAR 0 2
110066: PPUSH
110067: CALL_OW 310
110071: IFFALSE 110082
// ComExit ( j ) ;
110073: LD_VAR 0 2
110077: PPUSH
110078: CALL 48862 0 1
// AddComCollect ( j , x , y ) ;
110082: LD_VAR 0 2
110086: PPUSH
110087: LD_VAR 0 6
110091: PPUSH
110092: LD_VAR 0 7
110096: PPUSH
110097: CALL_OW 177
// end ;
110101: GO 110059
110103: POP
110104: POP
// exit ;
110105: POP
110106: POP
110107: GO 110336
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110109: LD_ADDR_VAR 0 4
110113: PUSH
110114: LD_INT 22
110116: PUSH
110117: LD_VAR 0 5
110121: PUSH
110122: EMPTY
110123: LIST
110124: LIST
110125: PUSH
110126: LD_INT 91
110128: PUSH
110129: LD_VAR 0 8
110133: PUSH
110134: LD_INT 8
110136: PUSH
110137: EMPTY
110138: LIST
110139: LIST
110140: LIST
110141: PUSH
110142: LD_INT 2
110144: PUSH
110145: LD_INT 34
110147: PUSH
110148: LD_INT 12
110150: PUSH
110151: EMPTY
110152: LIST
110153: LIST
110154: PUSH
110155: LD_INT 34
110157: PUSH
110158: LD_INT 51
110160: PUSH
110161: EMPTY
110162: LIST
110163: LIST
110164: PUSH
110165: LD_INT 34
110167: PUSH
110168: LD_INT 32
110170: PUSH
110171: EMPTY
110172: LIST
110173: LIST
110174: PUSH
110175: LD_INT 34
110177: PUSH
110178: LD_INT 89
110180: PUSH
110181: EMPTY
110182: LIST
110183: LIST
110184: PUSH
110185: EMPTY
110186: LIST
110187: LIST
110188: LIST
110189: LIST
110190: LIST
110191: PUSH
110192: EMPTY
110193: LIST
110194: LIST
110195: LIST
110196: PPUSH
110197: CALL_OW 69
110201: ST_TO_ADDR
// if tmp then
110202: LD_VAR 0 4
110206: IFFALSE 110332
// begin for j in tmp do
110208: LD_ADDR_VAR 0 2
110212: PUSH
110213: LD_VAR 0 4
110217: PUSH
110218: FOR_IN
110219: IFFALSE 110330
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110221: LD_VAR 0 2
110225: PPUSH
110226: CALL_OW 262
110230: PUSH
110231: LD_INT 3
110233: EQUAL
110234: PUSH
110235: LD_VAR 0 2
110239: PPUSH
110240: CALL_OW 261
110244: PUSH
110245: LD_INT 20
110247: GREATER
110248: OR
110249: PUSH
110250: LD_VAR 0 2
110254: PPUSH
110255: CALL_OW 314
110259: NOT
110260: AND
110261: PUSH
110262: LD_VAR 0 2
110266: PPUSH
110267: CALL_OW 263
110271: PUSH
110272: LD_INT 1
110274: NONEQUAL
110275: PUSH
110276: LD_VAR 0 2
110280: PPUSH
110281: CALL_OW 311
110285: OR
110286: AND
110287: IFFALSE 110328
// begin ComCollect ( j , x , y ) ;
110289: LD_VAR 0 2
110293: PPUSH
110294: LD_VAR 0 6
110298: PPUSH
110299: LD_VAR 0 7
110303: PPUSH
110304: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110308: LD_VAR 0 2
110312: PPUSH
110313: LD_VAR 0 8
110317: PPUSH
110318: CALL_OW 172
// exit ;
110322: POP
110323: POP
110324: POP
110325: POP
110326: GO 110336
// end ;
110328: GO 110218
110330: POP
110331: POP
// end ; end ;
110332: GO 109707
110334: POP
110335: POP
// end ; end_of_file
110336: PPOPN 9
110338: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110339: LD_VAR 0 1
110343: PPUSH
110344: LD_VAR 0 2
110348: PPUSH
110349: LD_VAR 0 3
110353: PPUSH
110354: LD_VAR 0 4
110358: PPUSH
110359: LD_VAR 0 5
110363: PPUSH
110364: LD_VAR 0 6
110368: PPUSH
110369: CALL 94741 0 6
// end ;
110373: PPOPN 6
110375: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110376: LD_INT 0
110378: PPUSH
// begin if not units then
110379: LD_VAR 0 1
110383: NOT
110384: IFFALSE 110388
// exit ;
110386: GO 110388
// end ;
110388: PPOPN 7
110390: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110391: CALL 94712 0 0
// end ;
110395: PPOPN 1
110397: END
