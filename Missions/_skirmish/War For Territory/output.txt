// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 210 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45126 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45126 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45126 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45126 0 9
// PrepareGensher ;
 185: CALL 3188 0 0
// PreparePopov ;
 189: CALL 6427 0 0
// PreparePowell ;
 193: CALL 589 0 0
// PrepareSikorski ;
 197: CALL 9147 0 0
// MC_Start ( ) ;
 201: CALL 54838 0 0
// Action ;
 205: CALL 9554 0 0
// end ;
 209: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 210: LD_INT 0
 212: PPUSH
// debug := false ;
 213: LD_ADDR_EXP 1
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// game := true ;
 221: LD_ADDR_EXP 2
 225: PUSH
 226: LD_INT 1
 228: ST_TO_ADDR
// staticMines := [ ] ;
 229: LD_ADDR_EXP 3
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// arDestroyed := false ;
 236: LD_ADDR_EXP 4
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// ruDestroyed := false ;
 244: LD_ADDR_EXP 5
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// powellInTrouble := false ;
 252: LD_ADDR_EXP 8
 256: PUSH
 257: LD_INT 0
 259: ST_TO_ADDR
// sikorskiInTrouble := false ;
 260: LD_ADDR_EXP 9
 264: PUSH
 265: LD_INT 0
 267: ST_TO_ADDR
// end ;
 268: LD_VAR 0 1
 272: RET
// export function CustomInitMacro ; begin
 273: LD_INT 0
 275: PPUSH
// InitMC_Gensher ( ) ;
 276: CALL 4354 0 0
// InitMC_Powell ( ) ;
 280: CALL 1543 0 0
// InitMC_Popov ( ) ;
 284: CALL 7617 0 0
// end ;
 288: LD_VAR 0 1
 292: RET
// every 0 0$10 do var cr , time , i ;
 293: GO 295
 295: DISABLE
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
 300: PPUSH
// begin time := 0 0$20 ;
 301: LD_ADDR_VAR 0 2
 305: PUSH
 306: LD_INT 700
 308: ST_TO_ADDR
// repeat wait ( time ) ;
 309: LD_VAR 0 2
 313: PPUSH
 314: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 318: LD_ADDR_VAR 0 1
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 5
 328: PPUSH
 329: CALL_OW 12
 333: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 334: LD_ADDR_VAR 0 3
 338: PUSH
 339: LD_INT 5
 341: PUSH
 342: LD_INT 8
 344: PUSH
 345: LD_INT 12
 347: PUSH
 348: LD_INT 13
 350: PUSH
 351: EMPTY
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: PUSH
 357: FOR_IN
 358: IFFALSE 412
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 360: LD_VAR 0 3
 364: PPUSH
 365: LD_INT 1
 367: PPUSH
 368: CALL_OW 287
 372: PUSH
 373: LD_INT 40
 375: LESS
 376: IFFALSE 395
// CreateCratesArea ( cr , i , true ) ;
 378: LD_VAR 0 1
 382: PPUSH
 383: LD_VAR 0 3
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 395: LD_INT 175
 397: PPUSH
 398: LD_INT 525
 400: PPUSH
 401: CALL_OW 12
 405: PPUSH
 406: CALL_OW 67
// end ;
 410: GO 357
 412: POP
 413: POP
// time := time + 0 0$2 ;
 414: LD_ADDR_VAR 0 2
 418: PUSH
 419: LD_VAR 0 2
 423: PUSH
 424: LD_INT 70
 426: PLUS
 427: ST_TO_ADDR
// if time > 0 0$35 then
 428: LD_VAR 0 2
 432: PUSH
 433: LD_INT 1225
 435: GREATER
 436: IFFALSE 446
// time := 0 0$25 ;
 438: LD_ADDR_VAR 0 2
 442: PUSH
 443: LD_INT 875
 445: ST_TO_ADDR
// until not game ;
 446: LD_EXP 2
 450: NOT
 451: IFFALSE 309
// end ;
 453: PPOPN 3
 455: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 456: LD_INT 3
 458: PUSH
 459: LD_INT 22
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: LD_INT 32
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: IFFALSE 586
 493: GO 495
 495: DISABLE
 496: LD_INT 0
 498: PPUSH
 499: PPUSH
// begin enable ;
 500: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 501: LD_ADDR_VAR 0 2
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: LD_INT 22
 511: PUSH
 512: LD_INT 1
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 32
 525: PUSH
 526: LD_INT 1
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL_OW 69
 541: ST_TO_ADDR
// for i in tmp do
 542: LD_ADDR_VAR 0 1
 546: PUSH
 547: LD_VAR 0 2
 551: PUSH
 552: FOR_IN
 553: IFFALSE 584
// if GetFuel ( i ) < 5 then
 555: LD_VAR 0 1
 559: PPUSH
 560: CALL_OW 261
 564: PUSH
 565: LD_INT 5
 567: LESS
 568: IFFALSE 582
// SetFuel ( i , 5 ) ;
 570: LD_VAR 0 1
 574: PPUSH
 575: LD_INT 5
 577: PPUSH
 578: CALL_OW 240
 582: GO 552
 584: POP
 585: POP
// end ; end_of_file
 586: PPOPN 2
 588: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
 593: PPUSH
 594: PPUSH
 595: PPUSH
// powell_side := 4 ;
 596: LD_ADDR_EXP 11
 600: PUSH
 601: LD_INT 4
 603: ST_TO_ADDR
// uc_side := powell_side ;
 604: LD_ADDR_OWVAR 20
 608: PUSH
 609: LD_EXP 11
 613: ST_TO_ADDR
// uc_nation := 1 ;
 614: LD_ADDR_OWVAR 21
 618: PUSH
 619: LD_INT 1
 621: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 622: LD_ADDR_EXP 10
 626: PUSH
 627: LD_STRING Powell
 629: PPUSH
 630: CALL_OW 25
 634: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 7
 645: PPUSH
 646: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 650: LD_EXP 10
 654: PPUSH
 655: LD_INT 2
 657: PPUSH
 658: LD_INT 5
 660: PPUSH
 661: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 665: LD_EXP 10
 669: PPUSH
 670: LD_INT 3
 672: PPUSH
 673: LD_INT 6
 675: PPUSH
 676: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 680: LD_EXP 10
 684: PPUSH
 685: LD_INT 4
 687: PPUSH
 688: LD_INT 4
 690: PPUSH
 691: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 695: LD_EXP 10
 699: PPUSH
 700: LD_INT 4
 702: PPUSH
 703: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 707: LD_ADDR_VAR 0 3
 711: PUSH
 712: LD_INT 5
 714: PUSH
 715: LD_INT 178
 717: PUSH
 718: LD_INT 117
 720: PUSH
 721: LD_INT 2
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PUSH
 730: LD_INT 29
 732: PUSH
 733: LD_INT 167
 735: PUSH
 736: LD_INT 102
 738: PUSH
 739: LD_INT 0
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 200
 753: PUSH
 754: LD_INT 111
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 10
 762: PUSH
 763: LD_INT 11
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: LIST
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 201
 779: PUSH
 780: LD_INT 140
 782: PUSH
 783: LD_INT 4
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_INT 27
 794: PUSH
 795: LD_INT 206
 797: PUSH
 798: LD_INT 124
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: LIST
 808: LIST
 809: PUSH
 810: LD_INT 27
 812: PUSH
 813: LD_INT 209
 815: PUSH
 816: LD_INT 128
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PUSH
 828: LD_INT 27
 830: PUSH
 831: LD_INT 211
 833: PUSH
 834: LD_INT 132
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 30
 848: PUSH
 849: LD_INT 173
 851: PUSH
 852: LD_INT 83
 854: PUSH
 855: LD_INT 3
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 6
 866: PUSH
 867: LD_INT 186
 869: PUSH
 870: LD_INT 103
 872: PUSH
 873: LD_INT 2
 875: PUSH
 876: LD_INT 12
 878: PUSH
 879: LD_INT 15
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 33
 892: PUSH
 893: LD_INT 173
 895: PUSH
 896: LD_INT 99
 898: PUSH
 899: LD_INT 2
 901: PUSH
 902: LD_INT 6
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: PUSH
 912: LD_INT 32
 914: PUSH
 915: LD_INT 174
 917: PUSH
 918: LD_INT 102
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: LD_INT 178
 939: PUSH
 940: LD_INT 100
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 6
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 33
 958: PUSH
 959: LD_INT 174
 961: PUSH
 962: LD_INT 108
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 7
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 33
 980: PUSH
 981: LD_INT 182
 983: PUSH
 984: LD_INT 122
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 7
 992: PUSH
 993: EMPTY
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 36
1002: PUSH
1003: LD_INT 194
1005: PUSH
1006: LD_INT 124
1008: PUSH
1009: LD_INT 5
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 33
1020: PUSH
1021: LD_INT 184
1023: PUSH
1024: LD_INT 141
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 6
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 33
1042: PUSH
1043: LD_INT 183
1045: PUSH
1046: LD_INT 131
1048: PUSH
1049: LD_INT 2
1051: PUSH
1052: LD_INT 11
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_INT 33
1064: PUSH
1065: LD_INT 194
1067: PUSH
1068: LD_INT 146
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: LD_INT 7
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 33
1086: PUSH
1087: LD_INT 190
1089: PUSH
1090: LD_INT 142
1092: PUSH
1093: LD_INT 4
1095: PUSH
1096: LD_INT 7
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_INT 28
1108: PUSH
1109: LD_INT 204
1111: PUSH
1112: LD_INT 133
1114: PUSH
1115: LD_INT 3
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_INT 27
1126: PUSH
1127: LD_INT 201
1129: PUSH
1130: LD_INT 133
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: PUSH
1142: LD_INT 28
1144: PUSH
1145: LD_INT 199
1147: PUSH
1148: LD_INT 119
1150: PUSH
1151: LD_INT 5
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: LIST
1158: LIST
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// for i in list do
1184: LD_ADDR_VAR 0 2
1188: PUSH
1189: LD_VAR 0 3
1193: PUSH
1194: FOR_IN
1195: IFFALSE 1405
// begin uc_side := 4 ;
1197: LD_ADDR_OWVAR 20
1201: PUSH
1202: LD_INT 4
1204: ST_TO_ADDR
// uc_nation := 1 ;
1205: LD_ADDR_OWVAR 21
1209: PUSH
1210: LD_INT 1
1212: ST_TO_ADDR
// InitBc ;
1213: CALL_OW 21
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
1231: LD_VAR 0 2
1235: PUSH
1236: LD_INT 1
1238: ARRAY
1239: PUSH
1240: LD_INT 29
1242: PUSH
1243: LD_INT 30
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: IN
1250: IFFALSE 1277
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 4 ) ;
1252: LD_VAR 0 2
1256: PUSH
1257: LD_INT 2
1259: ARRAY
1260: PPUSH
1261: LD_VAR 0 2
1265: PUSH
1266: LD_INT 3
1268: ARRAY
1269: PPUSH
1270: LD_INT 4
1272: PPUSH
1273: CALL_OW 441
// if i [ 1 ] = b_lab then
1277: LD_VAR 0 2
1281: PUSH
1282: LD_INT 1
1284: ARRAY
1285: PUSH
1286: LD_INT 6
1288: EQUAL
1289: IFFALSE 1327
// begin bc_type := b_lab_full ;
1291: LD_ADDR_OWVAR 42
1295: PUSH
1296: LD_INT 8
1298: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1299: LD_ADDR_OWVAR 44
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 5
1311: ARRAY
1312: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1313: LD_ADDR_OWVAR 45
1317: PUSH
1318: LD_VAR 0 2
1322: PUSH
1323: LD_INT 6
1325: ARRAY
1326: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1327: LD_ADDR_VAR 0 4
1331: PUSH
1332: LD_VAR 0 2
1336: PUSH
1337: LD_INT 2
1339: ARRAY
1340: PPUSH
1341: LD_VAR 0 2
1345: PUSH
1346: LD_INT 3
1348: ARRAY
1349: PPUSH
1350: LD_VAR 0 2
1354: PUSH
1355: LD_INT 4
1357: ARRAY
1358: PPUSH
1359: CALL_OW 47
1363: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1364: LD_VAR 0 2
1368: PUSH
1369: LD_INT 1
1371: ARRAY
1372: PUSH
1373: LD_INT 33
1375: PUSH
1376: LD_INT 32
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: IN
1383: IFFALSE 1403
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1385: LD_VAR 0 4
1389: PPUSH
1390: LD_VAR 0 2
1394: PUSH
1395: LD_INT 5
1397: ARRAY
1398: PPUSH
1399: CALL_OW 431
// end ;
1403: GO 1194
1405: POP
1406: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1407: LD_ADDR_VAR 0 5
1411: PUSH
1412: LD_INT 4
1414: PPUSH
1415: LD_INT 1
1417: PPUSH
1418: LD_STRING 
1420: PPUSH
1421: LD_INT 8
1423: PUSH
1424: LD_INT 7
1426: PUSH
1427: LD_INT 6
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: PUSH
1435: LD_OWVAR 67
1439: ARRAY
1440: PPUSH
1441: LD_INT 5500
1443: PUSH
1444: LD_INT 500
1446: PUSH
1447: LD_INT 0
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: PPUSH
1455: LD_INT 6
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 6
1463: PUSH
1464: LD_INT 6
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: PPUSH
1473: CALL 19408 0 6
1477: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1478: LD_ADDR_EXP 23
1482: PUSH
1483: LD_EXP 23
1487: PPUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_INT 22
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 21
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: EMPTY
1517: LIST
1518: LIST
1519: PPUSH
1520: CALL_OW 69
1524: UNION
1525: PPUSH
1526: CALL_OW 1
1530: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1531: LD_ADDR_EXP 12
1535: PUSH
1536: EMPTY
1537: ST_TO_ADDR
// end ;
1538: LD_VAR 0 1
1542: RET
// export function InitMC_Powell ( ) ; begin
1543: LD_INT 0
1545: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1546: LD_INT 1
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL 78213 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1556: LD_INT 1
1558: PPUSH
1559: LD_INT 6
1561: PPUSH
1562: CALL 78157 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1566: LD_INT 1
1568: PPUSH
1569: LD_INT 167
1571: PUSH
1572: LD_INT 102
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 173
1585: PUSH
1586: LD_INT 83
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: LD_INT 171
1599: PUSH
1600: LD_INT 141
1602: PUSH
1603: LD_INT 0
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: PUSH
1611: LD_INT 178
1613: PUSH
1614: LD_INT 148
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: LIST
1624: PUSH
1625: EMPTY
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL 77216 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1635: LD_INT 1
1637: PPUSH
1638: LD_INT 11
1640: PUSH
1641: LD_INT 6
1643: PUSH
1644: LD_INT 7
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: PPUSH
1652: CALL 78045 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: CALL 77727 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1666: LD_INT 1
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: CALL 77458 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 4
1681: PPUSH
1682: CALL 77077 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 3
1691: PUSH
1692: LD_INT 1
1694: PUSH
1695: LD_INT 2
1697: PUSH
1698: LD_INT 5
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 1
1712: PUSH
1713: LD_INT 2
1715: PUSH
1716: LD_INT 6
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_INT 4
1727: PUSH
1728: LD_INT 1
1730: PUSH
1731: LD_INT 2
1733: PUSH
1734: LD_INT 7
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: PUSH
1743: LD_INT 4
1745: PUSH
1746: LD_INT 1
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: LD_INT 6
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: LIST
1765: LIST
1766: PPUSH
1767: CALL 76892 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1771: LD_INT 1
1773: PPUSH
1774: LD_INT 201
1776: PPUSH
1777: LD_INT 140
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 19
1785: PUSH
1786: LD_INT 16
1788: PUSH
1789: LD_INT 17
1791: PUSH
1792: LD_INT 18
1794: PUSH
1795: LD_INT 22
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL 77839 0 5
// end ;
1809: LD_VAR 0 1
1813: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1814: LD_INT 4
1816: PPUSH
1817: CALL_OW 302
1821: IFFALSE 2481
1823: GO 1825
1825: DISABLE
1826: LD_INT 0
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// begin enable ;
1833: ENABLE
// base := 1 ;
1834: LD_ADDR_VAR 0 2
1838: PUSH
1839: LD_INT 1
1841: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: LD_INT 4
1849: PUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 6
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 4
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 2
1873: PUSH
1874: LD_INT 6
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: LD_INT 3
1885: PUSH
1886: LD_INT 1
1888: PUSH
1889: LD_INT 2
1891: PUSH
1892: LD_INT 7
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 3
1903: PUSH
1904: LD_INT 1
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 7
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1925: LD_ADDR_VAR 0 5
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_OWVAR 1
1939: PUSH
1940: LD_INT 21000
1942: DIV
1943: PLUS
1944: ST_TO_ADDR
// if amount > 8 then
1945: LD_VAR 0 5
1949: PUSH
1950: LD_INT 8
1952: GREATER
1953: IFFALSE 1963
// amount := 8 ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_INT 8
1962: ST_TO_ADDR
// for i = 1 to amount do
1963: LD_ADDR_VAR 0 1
1967: PUSH
1968: DOUBLE
1969: LD_INT 1
1971: DEC
1972: ST_TO_ADDR
1973: LD_VAR 0 5
1977: PUSH
1978: FOR_TO
1979: IFFALSE 2063
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1981: LD_ADDR_VAR 0 3
1985: PUSH
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 3
1995: PUSH
1996: LD_INT 1
1998: PLUS
1999: PPUSH
2000: LD_INT 3
2002: PUSH
2003: LD_INT 4
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: LD_INT 5
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 1
2040: PPUSH
2041: LD_INT 2
2043: PPUSH
2044: CALL_OW 12
2048: ARRAY
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: PPUSH
2056: CALL_OW 2
2060: ST_TO_ADDR
2061: GO 1978
2063: POP
2064: POP
// MC_InsertProduceList ( base , tmp ) ;
2065: LD_VAR 0 2
2069: PPUSH
2070: LD_VAR 0 3
2074: PPUSH
2075: CALL 76940 0 2
// repeat wait ( 0 0$1 ) ;
2079: LD_INT 35
2081: PPUSH
2082: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2086: LD_VAR 0 2
2090: PPUSH
2091: LD_INT 1
2093: PPUSH
2094: CALL 78358 0 2
2098: PUSH
2099: LD_VAR 0 5
2103: GREATEREQUAL
2104: IFFALSE 2079
// wait ( 0 0$30 ) ;
2106: LD_INT 1050
2108: PPUSH
2109: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2113: LD_ADDR_VAR 0 4
2117: PUSH
2118: LD_EXP 42
2122: PUSH
2123: LD_VAR 0 2
2127: ARRAY
2128: PUSH
2129: LD_EXP 42
2133: PUSH
2134: LD_VAR 0 2
2138: ARRAY
2139: PPUSH
2140: LD_INT 2
2142: PUSH
2143: LD_INT 34
2145: PUSH
2146: LD_INT 12
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 34
2155: PUSH
2156: LD_INT 13
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: LD_INT 34
2165: PUSH
2166: LD_INT 14
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: PPUSH
2179: CALL_OW 72
2183: DIFF
2184: ST_TO_ADDR
// if not attackers then
2185: LD_VAR 0 4
2189: NOT
2190: IFFALSE 2194
// exit ;
2192: GO 2481
// DialogPowellsAttack ;
2194: CALL 9685 0 0
// powellAttackGroup := attackers ;
2198: LD_ADDR_EXP 12
2202: PUSH
2203: LD_VAR 0 4
2207: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2208: LD_ADDR_EXP 42
2212: PUSH
2213: LD_EXP 42
2217: PPUSH
2218: LD_VAR 0 2
2222: PPUSH
2223: LD_EXP 42
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PUSH
2234: LD_VAR 0 4
2238: DIFF
2239: PPUSH
2240: CALL_OW 1
2244: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2245: LD_EXP 9
2249: PUSH
2250: LD_INT 16
2252: PPUSH
2253: LD_INT 81
2255: PUSH
2256: LD_INT 4
2258: PUSH
2259: EMPTY
2260: LIST
2261: LIST
2262: PPUSH
2263: CALL_OW 70
2267: AND
2268: IFFALSE 2287
// ComAgressiveMove ( attackers , 135 , 21 ) else
2270: LD_VAR 0 4
2274: PPUSH
2275: LD_INT 135
2277: PPUSH
2278: LD_INT 21
2280: PPUSH
2281: CALL_OW 114
2285: GO 2302
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2287: LD_VAR 0 4
2291: PPUSH
2292: LD_INT 146
2294: PPUSH
2295: LD_INT 103
2297: PPUSH
2298: CALL_OW 114
// wait ( 0 0$5 ) ;
2302: LD_INT 175
2304: PPUSH
2305: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2309: LD_INT 35
2311: PPUSH
2312: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2316: LD_VAR 0 4
2320: PPUSH
2321: LD_INT 60
2323: PUSH
2324: EMPTY
2325: LIST
2326: PPUSH
2327: CALL_OW 72
2331: NOT
2332: IFFALSE 2309
// if FilterAllUnits ( [ f_side , 3 ] ) then
2334: LD_INT 22
2336: PUSH
2337: LD_INT 3
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PPUSH
2344: CALL_OW 69
2348: IFFALSE 2367
// ComAgressiveMove ( attackers , 102 , 116 ) else
2350: LD_VAR 0 4
2354: PPUSH
2355: LD_INT 102
2357: PPUSH
2358: LD_INT 116
2360: PPUSH
2361: CALL_OW 114
2365: GO 2382
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2367: LD_VAR 0 4
2371: PPUSH
2372: LD_INT 66
2374: PPUSH
2375: LD_INT 41
2377: PPUSH
2378: CALL_OW 114
// wait ( 0 0$10 ) ;
2382: LD_INT 350
2384: PPUSH
2385: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2389: LD_INT 35
2391: PPUSH
2392: CALL_OW 67
// for i in attackers do
2396: LD_ADDR_VAR 0 1
2400: PUSH
2401: LD_VAR 0 4
2405: PUSH
2406: FOR_IN
2407: IFFALSE 2457
// if not HasTask ( i ) then
2409: LD_VAR 0 1
2413: PPUSH
2414: CALL_OW 314
2418: NOT
2419: IFFALSE 2455
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 81
2428: PUSH
2429: LD_INT 4
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PPUSH
2436: CALL_OW 69
2440: PPUSH
2441: LD_VAR 0 1
2445: PPUSH
2446: CALL_OW 74
2450: PPUSH
2451: CALL_OW 115
2455: GO 2406
2457: POP
2458: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2459: LD_VAR 0 4
2463: PPUSH
2464: LD_INT 50
2466: PUSH
2467: EMPTY
2468: LIST
2469: PPUSH
2470: CALL_OW 72
2474: NOT
2475: IFFALSE 2389
// DialogPowellsAttackFailed ;
2477: CALL 9950 0 0
// end ;
2481: PPOPN 5
2483: END
// every 0 0$2 do var vehicles , mechs , i ;
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
2490: PPUSH
2491: PPUSH
// begin enable ;
2492: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2493: LD_ADDR_VAR 0 1
2497: PUSH
2498: LD_INT 22
2500: PUSH
2501: LD_INT 1
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: LD_INT 21
2510: PUSH
2511: LD_INT 2
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: PUSH
2518: LD_INT 3
2520: PUSH
2521: LD_INT 24
2523: PUSH
2524: LD_INT 1000
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PUSH
2535: LD_INT 92
2537: PUSH
2538: LD_INT 191
2540: PUSH
2541: LD_INT 140
2543: PUSH
2544: LD_INT 10
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: LIST
2557: LIST
2558: PPUSH
2559: CALL_OW 69
2563: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2564: LD_ADDR_VAR 0 2
2568: PUSH
2569: LD_INT 22
2571: PUSH
2572: LD_INT 4
2574: PUSH
2575: EMPTY
2576: LIST
2577: LIST
2578: PUSH
2579: LD_INT 25
2581: PUSH
2582: LD_INT 3
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: PPUSH
2593: CALL_OW 69
2597: ST_TO_ADDR
// if not mechs then
2598: LD_VAR 0 2
2602: NOT
2603: IFFALSE 2607
// exit ;
2605: GO 2781
// if mc_remote_driver [ 1 ] then
2607: LD_EXP 63
2611: PUSH
2612: LD_INT 1
2614: ARRAY
2615: IFFALSE 2637
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2617: LD_ADDR_VAR 0 2
2621: PUSH
2622: LD_VAR 0 2
2626: PUSH
2627: LD_EXP 63
2631: PUSH
2632: LD_INT 1
2634: ARRAY
2635: DIFF
2636: ST_TO_ADDR
// if not mechs then
2637: LD_VAR 0 2
2641: NOT
2642: IFFALSE 2646
// exit ;
2644: GO 2781
// if vehicles then
2646: LD_VAR 0 1
2650: IFFALSE 2738
// begin for i in mechs do
2652: LD_ADDR_VAR 0 3
2656: PUSH
2657: LD_VAR 0 2
2661: PUSH
2662: FOR_IN
2663: IFFALSE 2734
// begin if GetTag ( i ) <> 120 then
2665: LD_VAR 0 3
2669: PPUSH
2670: CALL_OW 110
2674: PUSH
2675: LD_INT 120
2677: NONEQUAL
2678: IFFALSE 2692
// SetTag ( i , 120 ) ;
2680: LD_VAR 0 3
2684: PPUSH
2685: LD_INT 120
2687: PPUSH
2688: CALL_OW 109
// if IsInUnit ( i ) then
2692: LD_VAR 0 3
2696: PPUSH
2697: CALL_OW 310
2701: IFFALSE 2714
// ComExitBuilding ( i ) else
2703: LD_VAR 0 3
2707: PPUSH
2708: CALL_OW 122
2712: GO 2732
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2714: LD_VAR 0 3
2718: PPUSH
2719: LD_VAR 0 1
2723: PUSH
2724: LD_INT 1
2726: ARRAY
2727: PPUSH
2728: CALL_OW 129
// end ;
2732: GO 2662
2734: POP
2735: POP
// end else
2736: GO 2781
// if FilterByTag ( mechs , 120 ) then
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 120
2745: PPUSH
2746: CALL 46018 0 2
2750: IFFALSE 2781
// begin for i in mechs do
2752: LD_ADDR_VAR 0 3
2756: PUSH
2757: LD_VAR 0 2
2761: PUSH
2762: FOR_IN
2763: IFFALSE 2779
// begin SetTag ( i , 0 ) ;
2765: LD_VAR 0 3
2769: PPUSH
2770: LD_INT 0
2772: PPUSH
2773: CALL_OW 109
// end ;
2777: GO 2762
2779: POP
2780: POP
// end ; end ;
2781: PPOPN 3
2783: END
// every 0 0$2 do var people , sci , i ;
2784: GO 2786
2786: DISABLE
2787: LD_INT 0
2789: PPUSH
2790: PPUSH
2791: PPUSH
// begin enable ;
2792: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2793: LD_ADDR_VAR 0 1
2797: PUSH
2798: LD_INT 22
2800: PUSH
2801: LD_INT 1
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: PUSH
2808: LD_INT 21
2810: PUSH
2811: LD_INT 1
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PUSH
2818: LD_INT 3
2820: PUSH
2821: LD_INT 24
2823: PUSH
2824: LD_INT 1000
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: PUSH
2835: LD_INT 92
2837: PUSH
2838: LD_INT 188
2840: PUSH
2841: LD_INT 112
2843: PUSH
2844: LD_INT 10
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: LIST
2851: LIST
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: PPUSH
2859: CALL_OW 69
2863: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: LD_INT 22
2871: PUSH
2872: LD_INT 4
2874: PUSH
2875: EMPTY
2876: LIST
2877: LIST
2878: PUSH
2879: LD_INT 25
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PPUSH
2893: CALL_OW 69
2897: ST_TO_ADDR
// if not sci then
2898: LD_VAR 0 2
2902: NOT
2903: IFFALSE 2907
// exit ;
2905: GO 3042
// if people then
2907: LD_VAR 0 1
2911: IFFALSE 2999
// begin for i in sci do
2913: LD_ADDR_VAR 0 3
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: FOR_IN
2924: IFFALSE 2995
// begin if GetTag ( i ) <> 102 then
2926: LD_VAR 0 3
2930: PPUSH
2931: CALL_OW 110
2935: PUSH
2936: LD_INT 102
2938: NONEQUAL
2939: IFFALSE 2953
// SetTag ( i , 102 ) ;
2941: LD_VAR 0 3
2945: PPUSH
2946: LD_INT 102
2948: PPUSH
2949: CALL_OW 109
// if IsInUnit ( i ) then
2953: LD_VAR 0 3
2957: PPUSH
2958: CALL_OW 310
2962: IFFALSE 2975
// ComExitBuilding ( i ) else
2964: LD_VAR 0 3
2968: PPUSH
2969: CALL_OW 122
2973: GO 2993
// ComHeal ( i , people [ 1 ] ) ;
2975: LD_VAR 0 3
2979: PPUSH
2980: LD_VAR 0 1
2984: PUSH
2985: LD_INT 1
2987: ARRAY
2988: PPUSH
2989: CALL_OW 128
// end ;
2993: GO 2923
2995: POP
2996: POP
// end else
2997: GO 3042
// if FilterByTag ( sci , 102 ) then
2999: LD_VAR 0 2
3003: PPUSH
3004: LD_INT 102
3006: PPUSH
3007: CALL 46018 0 2
3011: IFFALSE 3042
// begin for i in sci do
3013: LD_ADDR_VAR 0 3
3017: PUSH
3018: LD_VAR 0 2
3022: PUSH
3023: FOR_IN
3024: IFFALSE 3040
// begin SetTag ( i , 0 ) ;
3026: LD_VAR 0 3
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 109
// end ;
3038: GO 3023
3040: POP
3041: POP
// end ; end ;
3042: PPOPN 3
3044: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3045: LD_INT 22
3047: PUSH
3048: LD_INT 4
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 33
3057: PUSH
3058: LD_INT 2
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: PUSH
3065: LD_INT 50
3067: PUSH
3068: EMPTY
3069: LIST
3070: PUSH
3071: LD_INT 3
3073: PUSH
3074: LD_INT 61
3076: PUSH
3077: EMPTY
3078: LIST
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL_OW 69
3094: IFFALSE 3185
3096: GO 3098
3098: DISABLE
3099: LD_INT 0
3101: PPUSH
3102: PPUSH
// begin enable ;
3103: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3104: LD_ADDR_VAR 0 2
3108: PUSH
3109: LD_INT 22
3111: PUSH
3112: LD_INT 4
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: PUSH
3119: LD_INT 33
3121: PUSH
3122: LD_INT 2
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: PUSH
3129: LD_INT 50
3131: PUSH
3132: EMPTY
3133: LIST
3134: PUSH
3135: LD_INT 3
3137: PUSH
3138: LD_INT 61
3140: PUSH
3141: EMPTY
3142: LIST
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: PPUSH
3154: CALL_OW 69
3158: ST_TO_ADDR
// for i in tmp do
3159: LD_ADDR_VAR 0 1
3163: PUSH
3164: LD_VAR 0 2
3168: PUSH
3169: FOR_IN
3170: IFFALSE 3183
// Connect ( i ) ;
3172: LD_VAR 0 1
3176: PPUSH
3177: CALL 19055 0 1
3181: GO 3169
3183: POP
3184: POP
// end ; end_of_file
3185: PPOPN 2
3187: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3188: LD_INT 0
3190: PPUSH
3191: PPUSH
3192: PPUSH
3193: PPUSH
3194: PPUSH
3195: PPUSH
// gensher_side := 2 ;
3196: LD_ADDR_EXP 14
3200: PUSH
3201: LD_INT 2
3203: ST_TO_ADDR
// uc_side := gensher_side ;
3204: LD_ADDR_OWVAR 20
3208: PUSH
3209: LD_EXP 14
3213: ST_TO_ADDR
// uc_nation := 2 ;
3214: LD_ADDR_OWVAR 21
3218: PUSH
3219: LD_INT 2
3221: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3222: LD_ADDR_VAR 0 6
3226: PUSH
3227: LD_INT 5
3229: PUSH
3230: LD_INT 42
3232: PUSH
3233: LD_INT 29
3235: PUSH
3236: LD_INT 5
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: PUSH
3245: LD_INT 5
3247: PUSH
3248: LD_INT 36
3250: PUSH
3251: LD_INT 40
3253: PUSH
3254: LD_INT 5
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: LIST
3261: LIST
3262: PUSH
3263: LD_INT 6
3265: PUSH
3266: LD_INT 13
3268: PUSH
3269: LD_INT 18
3271: PUSH
3272: LD_INT 1
3274: PUSH
3275: LD_INT 10
3277: PUSH
3278: LD_INT 15
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 27
3291: PUSH
3292: LD_INT 17
3294: PUSH
3295: LD_INT 3
3297: PUSH
3298: LD_INT 0
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 29
3309: PUSH
3310: LD_INT 56
3312: PUSH
3313: LD_INT 23
3315: PUSH
3316: LD_INT 0
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 11
3330: PUSH
3331: LD_INT 7
3333: PUSH
3334: LD_INT 2
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 27
3345: PUSH
3346: LD_INT 20
3348: PUSH
3349: LD_INT 3
3351: PUSH
3352: LD_INT 0
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 27
3363: PUSH
3364: LD_INT 23
3366: PUSH
3367: LD_INT 3
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 27
3381: PUSH
3382: LD_INT 26
3384: PUSH
3385: LD_INT 3
3387: PUSH
3388: LD_INT 0
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 6
3399: PUSH
3400: LD_INT 17
3402: PUSH
3403: LD_INT 27
3405: PUSH
3406: LD_INT 1
3408: PUSH
3409: LD_INT 13
3411: PUSH
3412: LD_INT 11
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: PUSH
3423: LD_INT 32
3425: PUSH
3426: LD_INT 27
3428: PUSH
3429: LD_INT 44
3431: PUSH
3432: LD_INT 5
3434: PUSH
3435: LD_INT 27
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: LIST
3442: LIST
3443: LIST
3444: PUSH
3445: LD_INT 32
3447: PUSH
3448: LD_INT 41
3450: PUSH
3451: LD_INT 41
3453: PUSH
3454: LD_INT 5
3456: PUSH
3457: LD_INT 27
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: LIST
3466: PUSH
3467: LD_INT 32
3469: PUSH
3470: LD_INT 45
3472: PUSH
3473: LD_INT 24
3475: PUSH
3476: LD_INT 5
3478: PUSH
3479: LD_INT 28
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: LIST
3488: PUSH
3489: LD_INT 32
3491: PUSH
3492: LD_INT 48
3494: PUSH
3495: LD_INT 19
3497: PUSH
3498: LD_INT 5
3500: PUSH
3501: LD_INT 28
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: PUSH
3511: LD_INT 32
3513: PUSH
3514: LD_INT 41
3516: PUSH
3517: LD_INT 3
3519: PUSH
3520: LD_INT 4
3522: PUSH
3523: LD_INT 28
3525: PUSH
3526: EMPTY
3527: LIST
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: PUSH
3533: LD_INT 5
3535: PUSH
3536: LD_INT 44
3538: PUSH
3539: LD_INT 9
3541: PUSH
3542: LD_INT 4
3544: PUSH
3545: EMPTY
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: PUSH
3551: LD_INT 30
3553: PUSH
3554: LD_INT 52
3556: PUSH
3557: LD_INT 40
3559: PUSH
3560: LD_INT 3
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: LIST
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: ST_TO_ADDR
// for i in list do
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: LD_VAR 0 6
3597: PUSH
3598: FOR_IN
3599: IFFALSE 3809
// begin uc_side := 2 ;
3601: LD_ADDR_OWVAR 20
3605: PUSH
3606: LD_INT 2
3608: ST_TO_ADDR
// uc_nation := 2 ;
3609: LD_ADDR_OWVAR 21
3613: PUSH
3614: LD_INT 2
3616: ST_TO_ADDR
// InitBc ;
3617: CALL_OW 21
// bc_type := i [ 1 ] ;
3621: LD_ADDR_OWVAR 42
3625: PUSH
3626: LD_VAR 0 2
3630: PUSH
3631: LD_INT 1
3633: ARRAY
3634: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
3635: LD_VAR 0 2
3639: PUSH
3640: LD_INT 1
3642: ARRAY
3643: PUSH
3644: LD_INT 29
3646: PUSH
3647: LD_INT 30
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: IN
3654: IFFALSE 3681
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 2 ) ;
3656: LD_VAR 0 2
3660: PUSH
3661: LD_INT 2
3663: ARRAY
3664: PPUSH
3665: LD_VAR 0 2
3669: PUSH
3670: LD_INT 3
3672: ARRAY
3673: PPUSH
3674: LD_INT 2
3676: PPUSH
3677: CALL_OW 441
// if i [ 1 ] = b_lab then
3681: LD_VAR 0 2
3685: PUSH
3686: LD_INT 1
3688: ARRAY
3689: PUSH
3690: LD_INT 6
3692: EQUAL
3693: IFFALSE 3731
// begin bc_type := b_lab_full ;
3695: LD_ADDR_OWVAR 42
3699: PUSH
3700: LD_INT 8
3702: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3703: LD_ADDR_OWVAR 44
3707: PUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 5
3715: ARRAY
3716: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3717: LD_ADDR_OWVAR 45
3721: PUSH
3722: LD_VAR 0 2
3726: PUSH
3727: LD_INT 6
3729: ARRAY
3730: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3731: LD_ADDR_VAR 0 3
3735: PUSH
3736: LD_VAR 0 2
3740: PUSH
3741: LD_INT 2
3743: ARRAY
3744: PPUSH
3745: LD_VAR 0 2
3749: PUSH
3750: LD_INT 3
3752: ARRAY
3753: PPUSH
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 4
3761: ARRAY
3762: PPUSH
3763: CALL_OW 47
3767: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3768: LD_VAR 0 2
3772: PUSH
3773: LD_INT 1
3775: ARRAY
3776: PUSH
3777: LD_INT 33
3779: PUSH
3780: LD_INT 32
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: IN
3787: IFFALSE 3807
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3789: LD_VAR 0 3
3793: PPUSH
3794: LD_VAR 0 2
3798: PUSH
3799: LD_INT 5
3801: ARRAY
3802: PPUSH
3803: CALL_OW 431
// end ;
3807: GO 3598
3809: POP
3810: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3811: LD_ADDR_VAR 0 4
3815: PUSH
3816: LD_INT 7
3818: PPUSH
3819: LD_INT 2
3821: PPUSH
3822: LD_STRING 
3824: PPUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 7
3830: PUSH
3831: LD_INT 6
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: LIST
3838: PUSH
3839: LD_OWVAR 67
3843: ARRAY
3844: PPUSH
3845: LD_INT 11500
3847: PUSH
3848: LD_INT 1100
3850: PUSH
3851: LD_INT 60
3853: PUSH
3854: EMPTY
3855: LIST
3856: LIST
3857: LIST
3858: PPUSH
3859: LD_INT 6
3861: PUSH
3862: LD_INT 6
3864: PUSH
3865: LD_INT 6
3867: PUSH
3868: LD_INT 6
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PPUSH
3877: CALL 19408 0 6
3881: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3882: LD_ADDR_EXP 23
3886: PUSH
3887: LD_EXP 23
3891: PPUSH
3892: LD_INT 2
3894: PPUSH
3895: LD_VAR 0 4
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 2
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 21
3912: PUSH
3913: LD_INT 3
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: UNION
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3935: LD_ADDR_VAR 0 4
3939: PUSH
3940: LD_INT 22
3942: PUSH
3943: LD_INT 2
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 30
3952: PUSH
3953: LD_INT 31
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PPUSH
3964: CALL_OW 69
3968: ST_TO_ADDR
// for i in tmp do
3969: LD_ADDR_VAR 0 2
3973: PUSH
3974: LD_VAR 0 4
3978: PUSH
3979: FOR_IN
3980: IFFALSE 4050
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3982: LD_INT 0
3984: PPUSH
3985: LD_INT 1
3987: PPUSH
3988: LD_INT 4
3990: PUSH
3991: LD_INT 3
3993: PUSH
3994: LD_INT 3
3996: PUSH
3997: EMPTY
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_OWVAR 67
4006: ARRAY
4007: PPUSH
4008: CALL_OW 380
// un := CreateHuman ;
4012: LD_ADDR_VAR 0 5
4016: PUSH
4017: CALL_OW 44
4021: ST_TO_ADDR
// SetDir ( un , 1 ) ;
4022: LD_VAR 0 5
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4034: LD_VAR 0 5
4038: PPUSH
4039: LD_VAR 0 2
4043: PPUSH
4044: CALL_OW 52
// end ;
4048: GO 3979
4050: POP
4051: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
4052: LD_ADDR_VAR 0 4
4056: PUSH
4057: LD_INT 15
4059: PPUSH
4060: LD_INT 0
4062: PPUSH
4063: CALL_OW 517
4067: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_VAR 0 4
4082: PUSH
4083: LD_INT 1
4085: ARRAY
4086: PUSH
4087: FOR_TO
4088: IFFALSE 4190
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4090: LD_VAR 0 4
4094: PUSH
4095: LD_INT 1
4097: ARRAY
4098: PUSH
4099: LD_VAR 0 2
4103: ARRAY
4104: PPUSH
4105: LD_VAR 0 4
4109: PUSH
4110: LD_INT 2
4112: ARRAY
4113: PUSH
4114: LD_VAR 0 2
4118: ARRAY
4119: PPUSH
4120: LD_INT 2
4122: PPUSH
4123: LD_INT 0
4125: PPUSH
4126: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4130: LD_ADDR_EXP 3
4134: PUSH
4135: LD_EXP 3
4139: PPUSH
4140: LD_EXP 3
4144: PUSH
4145: LD_INT 1
4147: PLUS
4148: PPUSH
4149: LD_VAR 0 4
4153: PUSH
4154: LD_INT 1
4156: ARRAY
4157: PUSH
4158: LD_VAR 0 2
4162: ARRAY
4163: PUSH
4164: LD_VAR 0 4
4168: PUSH
4169: LD_INT 2
4171: ARRAY
4172: PUSH
4173: LD_VAR 0 2
4177: ARRAY
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: PPUSH
4183: CALL_OW 2
4187: ST_TO_ADDR
// end ;
4188: GO 4087
4190: POP
4191: POP
// if Difficulty > 1 then
4192: LD_OWVAR 67
4196: PUSH
4197: LD_INT 1
4199: GREATER
4200: IFFALSE 4342
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4202: LD_ADDR_VAR 0 4
4206: PUSH
4207: LD_INT 19
4209: PPUSH
4210: LD_INT 0
4212: PPUSH
4213: CALL_OW 517
4217: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_VAR 0 4
4232: PUSH
4233: LD_INT 1
4235: ARRAY
4236: PUSH
4237: FOR_TO
4238: IFFALSE 4340
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4240: LD_VAR 0 4
4244: PUSH
4245: LD_INT 1
4247: ARRAY
4248: PUSH
4249: LD_VAR 0 2
4253: ARRAY
4254: PPUSH
4255: LD_VAR 0 4
4259: PUSH
4260: LD_INT 2
4262: ARRAY
4263: PUSH
4264: LD_VAR 0 2
4268: ARRAY
4269: PPUSH
4270: LD_INT 2
4272: PPUSH
4273: LD_INT 0
4275: PPUSH
4276: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4280: LD_ADDR_EXP 3
4284: PUSH
4285: LD_EXP 3
4289: PPUSH
4290: LD_EXP 3
4294: PUSH
4295: LD_INT 1
4297: PLUS
4298: PPUSH
4299: LD_VAR 0 4
4303: PUSH
4304: LD_INT 1
4306: ARRAY
4307: PUSH
4308: LD_VAR 0 2
4312: ARRAY
4313: PUSH
4314: LD_VAR 0 4
4318: PUSH
4319: LD_INT 2
4321: ARRAY
4322: PUSH
4323: LD_VAR 0 2
4327: ARRAY
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: PPUSH
4333: CALL_OW 2
4337: ST_TO_ADDR
// end ;
4338: GO 4237
4340: POP
4341: POP
// end ; gensherAttackGroup := [ ] ;
4342: LD_ADDR_EXP 15
4346: PUSH
4347: EMPTY
4348: ST_TO_ADDR
// end ;
4349: LD_VAR 0 1
4353: RET
// export function InitMC_Gensher ( ) ; begin
4354: LD_INT 0
4356: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4357: LD_INT 2
4359: PPUSH
4360: LD_INT 2
4362: PPUSH
4363: CALL 78213 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4367: LD_INT 2
4369: PPUSH
4370: LD_INT 9
4372: PPUSH
4373: CALL 78157 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4377: LD_INT 2
4379: PPUSH
4380: LD_INT 56
4382: PUSH
4383: LD_INT 23
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 52
4396: PUSH
4397: LD_INT 40
4399: PUSH
4400: LD_INT 1
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: LIST
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PPUSH
4412: CALL 77216 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4416: LD_INT 2
4418: PPUSH
4419: LD_INT 27
4421: PUSH
4422: LD_INT 28
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PPUSH
4429: CALL 78045 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4433: LD_INT 2
4435: PPUSH
4436: LD_INT 8
4438: PPUSH
4439: CALL 77727 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4443: LD_INT 2
4445: PPUSH
4446: LD_INT 7
4448: PPUSH
4449: CALL 77458 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4453: LD_INT 2
4455: PPUSH
4456: LD_INT 4
4458: PPUSH
4459: CALL 77077 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4463: LD_INT 2
4465: PPUSH
4466: LD_INT 13
4468: PUSH
4469: LD_INT 2
4471: PUSH
4472: LD_INT 1
4474: PUSH
4475: LD_INT 31
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: PUSH
4484: LD_INT 13
4486: PUSH
4487: LD_INT 2
4489: PUSH
4490: LD_INT 1
4492: PUSH
4493: LD_INT 31
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: PUSH
4502: LD_INT 14
4504: PUSH
4505: LD_INT 1
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 27
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: PUSH
4520: LD_INT 14
4522: PUSH
4523: LD_INT 1
4525: PUSH
4526: LD_INT 2
4528: PUSH
4529: LD_INT 27
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: PUSH
4538: LD_INT 14
4540: PUSH
4541: LD_INT 1
4543: PUSH
4544: LD_INT 2
4546: PUSH
4547: LD_INT 28
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 14
4558: PUSH
4559: LD_INT 1
4561: PUSH
4562: LD_INT 2
4564: PUSH
4565: LD_INT 26
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: PPUSH
4582: CALL 76892 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4586: LD_INT 2
4588: PPUSH
4589: LD_INT 11
4591: PPUSH
4592: LD_INT 7
4594: PPUSH
4595: LD_INT 2
4597: PPUSH
4598: LD_INT 23
4600: PUSH
4601: LD_INT 16
4603: PUSH
4604: LD_INT 17
4606: PUSH
4607: LD_INT 18
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: LIST
4618: LIST
4619: PPUSH
4620: CALL 77839 0 5
// end ;
4624: LD_VAR 0 1
4628: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4629: LD_EXP 3
4633: PUSH
4634: LD_INT 15
4636: PPUSH
4637: LD_INT 81
4639: PUSH
4640: LD_INT 2
4642: PUSH
4643: EMPTY
4644: LIST
4645: LIST
4646: PPUSH
4647: CALL_OW 70
4651: AND
4652: IFFALSE 4865
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
4660: PPUSH
4661: PPUSH
4662: PPUSH
4663: PPUSH
// begin enable ;
4664: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: LD_INT 15
4672: PPUSH
4673: LD_INT 81
4675: PUSH
4676: LD_INT 2
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: PPUSH
4683: CALL_OW 70
4687: ST_TO_ADDR
// if not tmp then
4688: LD_VAR 0 3
4692: NOT
4693: IFFALSE 4697
// exit ;
4695: GO 4865
// for i in tmp do
4697: LD_ADDR_VAR 0 1
4701: PUSH
4702: LD_VAR 0 3
4706: PUSH
4707: FOR_IN
4708: IFFALSE 4863
// begin x := GetX ( i ) ;
4710: LD_ADDR_VAR 0 4
4714: PUSH
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 250
4724: ST_TO_ADDR
// y := GetY ( i ) ;
4725: LD_ADDR_VAR 0 5
4729: PUSH
4730: LD_VAR 0 1
4734: PPUSH
4735: CALL_OW 251
4739: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4740: LD_VAR 0 4
4744: PPUSH
4745: LD_VAR 0 5
4749: PPUSH
4750: CALL_OW 458
4754: IFFALSE 4861
// begin LaunchMineAtPos ( x , y , 2 ) ;
4756: LD_VAR 0 4
4760: PPUSH
4761: LD_VAR 0 5
4765: PPUSH
4766: LD_INT 2
4768: PPUSH
4769: CALL_OW 456
// for j = 1 to staticMines do
4773: LD_ADDR_VAR 0 2
4777: PUSH
4778: DOUBLE
4779: LD_INT 1
4781: DEC
4782: ST_TO_ADDR
4783: LD_EXP 3
4787: PUSH
4788: FOR_TO
4789: IFFALSE 4859
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4791: LD_EXP 3
4795: PUSH
4796: LD_VAR 0 2
4800: ARRAY
4801: PUSH
4802: LD_INT 1
4804: ARRAY
4805: PUSH
4806: LD_VAR 0 4
4810: EQUAL
4811: PUSH
4812: LD_EXP 3
4816: PUSH
4817: LD_VAR 0 2
4821: ARRAY
4822: PUSH
4823: LD_INT 2
4825: ARRAY
4826: PUSH
4827: LD_VAR 0 5
4831: EQUAL
4832: AND
4833: IFFALSE 4857
// begin staticMines := Delete ( staticMines , j ) ;
4835: LD_ADDR_EXP 3
4839: PUSH
4840: LD_EXP 3
4844: PPUSH
4845: LD_VAR 0 2
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
// break ;
4855: GO 4859
// end ;
4857: GO 4788
4859: POP
4860: POP
// end ; end ;
4861: GO 4707
4863: POP
4864: POP
// end ;
4865: PPOPN 5
4867: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4868: LD_INT 7
4870: PPUSH
4871: CALL_OW 302
4875: PUSH
4876: LD_EXP 4
4880: NOT
4881: AND
4882: IFFALSE 5482
4884: GO 4886
4886: DISABLE
4887: LD_INT 0
4889: PPUSH
4890: PPUSH
4891: PPUSH
4892: PPUSH
4893: PPUSH
// begin enable ;
4894: ENABLE
// base := 2 ;
4895: LD_ADDR_VAR 0 2
4899: PUSH
4900: LD_INT 2
4902: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4903: LD_ADDR_VAR 0 3
4907: PUSH
4908: LD_INT 14
4910: PUSH
4911: LD_INT 1
4913: PUSH
4914: LD_INT 2
4916: PUSH
4917: LD_INT 27
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 14
4928: PUSH
4929: LD_INT 1
4931: PUSH
4932: LD_INT 2
4934: PUSH
4935: LD_INT 27
4937: PUSH
4938: EMPTY
4939: LIST
4940: LIST
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 14
4946: PUSH
4947: LD_INT 1
4949: PUSH
4950: LD_INT 2
4952: PUSH
4953: LD_INT 28
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 14
4964: PUSH
4965: LD_INT 1
4967: PUSH
4968: LD_INT 2
4970: PUSH
4971: LD_INT 26
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: PUSH
4980: EMPTY
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4986: LD_ADDR_VAR 0 5
4990: PUSH
4991: LD_VAR 0 5
4995: PUSH
4996: LD_OWVAR 1
5000: PUSH
5001: LD_INT 21000
5003: DIV
5004: PLUS
5005: ST_TO_ADDR
// if amount > 8 then
5006: LD_VAR 0 5
5010: PUSH
5011: LD_INT 8
5013: GREATER
5014: IFFALSE 5024
// amount := 8 ;
5016: LD_ADDR_VAR 0 5
5020: PUSH
5021: LD_INT 8
5023: ST_TO_ADDR
// for i = 1 to amount do
5024: LD_ADDR_VAR 0 1
5028: PUSH
5029: DOUBLE
5030: LD_INT 1
5032: DEC
5033: ST_TO_ADDR
5034: LD_VAR 0 5
5038: PUSH
5039: FOR_TO
5040: IFFALSE 5128
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
5042: LD_ADDR_VAR 0 3
5046: PUSH
5047: LD_VAR 0 3
5051: PPUSH
5052: LD_VAR 0 3
5056: PUSH
5057: LD_INT 1
5059: PLUS
5060: PPUSH
5061: LD_INT 14
5063: PUSH
5064: LD_INT 13
5066: PUSH
5067: EMPTY
5068: LIST
5069: LIST
5070: PUSH
5071: LD_INT 1
5073: PPUSH
5074: LD_INT 2
5076: PPUSH
5077: CALL_OW 12
5081: ARRAY
5082: PUSH
5083: LD_INT 1
5085: PUSH
5086: LD_INT 2
5088: PUSH
5089: LD_INT 28
5091: PUSH
5092: LD_INT 25
5094: PUSH
5095: LD_INT 27
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 1
5105: PPUSH
5106: LD_INT 3
5108: PPUSH
5109: CALL_OW 12
5113: ARRAY
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: PPUSH
5121: CALL_OW 2
5125: ST_TO_ADDR
5126: GO 5039
5128: POP
5129: POP
// MC_InsertProduceList ( base , tmp ) ;
5130: LD_VAR 0 2
5134: PPUSH
5135: LD_VAR 0 3
5139: PPUSH
5140: CALL 76940 0 2
// repeat wait ( 0 0$1 ) ;
5144: LD_INT 35
5146: PPUSH
5147: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5151: LD_VAR 0 2
5155: PPUSH
5156: LD_INT 1
5158: PPUSH
5159: CALL 78358 0 2
5163: PUSH
5164: LD_VAR 0 5
5168: GREATEREQUAL
5169: IFFALSE 5144
// wait ( 0 0$30 ) ;
5171: LD_INT 1050
5173: PPUSH
5174: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5178: LD_ADDR_VAR 0 4
5182: PUSH
5183: LD_EXP 42
5187: PUSH
5188: LD_VAR 0 2
5192: ARRAY
5193: PUSH
5194: LD_EXP 42
5198: PUSH
5199: LD_VAR 0 2
5203: ARRAY
5204: PPUSH
5205: LD_INT 2
5207: PUSH
5208: LD_INT 34
5210: PUSH
5211: LD_INT 31
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: PUSH
5218: LD_INT 34
5220: PUSH
5221: LD_INT 32
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: PUSH
5228: LD_INT 34
5230: PUSH
5231: LD_INT 88
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: PPUSH
5244: CALL_OW 72
5248: DIFF
5249: ST_TO_ADDR
// if not attackers then
5250: LD_VAR 0 4
5254: NOT
5255: IFFALSE 5259
// exit ;
5257: GO 5482
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5259: LD_ADDR_EXP 42
5263: PUSH
5264: LD_EXP 42
5268: PPUSH
5269: LD_VAR 0 2
5273: PPUSH
5274: LD_EXP 42
5278: PUSH
5279: LD_VAR 0 2
5283: ARRAY
5284: PUSH
5285: LD_VAR 0 4
5289: DIFF
5290: PPUSH
5291: CALL_OW 1
5295: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5296: LD_VAR 0 4
5300: PPUSH
5301: LD_INT 107
5303: PPUSH
5304: LD_INT 74
5306: PPUSH
5307: CALL_OW 114
// wait ( 0 0$5 ) ;
5311: LD_INT 175
5313: PPUSH
5314: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5318: LD_INT 35
5320: PPUSH
5321: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5325: LD_VAR 0 4
5329: PPUSH
5330: LD_INT 60
5332: PUSH
5333: EMPTY
5334: LIST
5335: PPUSH
5336: CALL_OW 72
5340: NOT
5341: IFFALSE 5318
// if rand ( 0 , 1 ) then
5343: LD_INT 0
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 12
5353: IFFALSE 5372
// ComAgressiveMove ( attackers , 155 , 108 ) else
5355: LD_VAR 0 4
5359: PPUSH
5360: LD_INT 155
5362: PPUSH
5363: LD_INT 108
5365: PPUSH
5366: CALL_OW 114
5370: GO 5387
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5372: LD_VAR 0 4
5376: PPUSH
5377: LD_INT 149
5379: PPUSH
5380: LD_INT 55
5382: PPUSH
5383: CALL_OW 114
// wait ( 0 0$10 ) ;
5387: LD_INT 350
5389: PPUSH
5390: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5394: LD_INT 35
5396: PPUSH
5397: CALL_OW 67
// for i in attackers do
5401: LD_ADDR_VAR 0 1
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: FOR_IN
5412: IFFALSE 5462
// if not HasTask ( i ) then
5414: LD_VAR 0 1
5418: PPUSH
5419: CALL_OW 314
5423: NOT
5424: IFFALSE 5460
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5426: LD_VAR 0 1
5430: PPUSH
5431: LD_INT 81
5433: PUSH
5434: LD_INT 2
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: PPUSH
5441: CALL_OW 69
5445: PPUSH
5446: LD_VAR 0 1
5450: PPUSH
5451: CALL_OW 74
5455: PPUSH
5456: CALL_OW 115
5460: GO 5411
5462: POP
5463: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5464: LD_VAR 0 4
5468: PPUSH
5469: LD_INT 50
5471: PUSH
5472: EMPTY
5473: LIST
5474: PPUSH
5475: CALL_OW 72
5479: NOT
5480: IFFALSE 5394
// end ;
5482: PPOPN 5
5484: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5485: LD_EXP 4
5489: NOT
5490: PUSH
5491: LD_OWVAR 1
5495: PUSH
5496: LD_INT 191100
5498: LESS
5499: AND
5500: IFFALSE 6172
5502: GO 5504
5504: DISABLE
5505: LD_INT 0
5507: PPUSH
5508: PPUSH
5509: PPUSH
// begin enable ;
5510: ENABLE
// tmp := [ ] ;
5511: LD_ADDR_VAR 0 3
5515: PUSH
5516: EMPTY
5517: ST_TO_ADDR
// if tick < 35 35$00 then
5518: LD_OWVAR 1
5522: PUSH
5523: LD_INT 73500
5525: LESS
5526: IFFALSE 5724
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5528: LD_ADDR_VAR 0 1
5532: PUSH
5533: DOUBLE
5534: LD_INT 1
5536: DEC
5537: ST_TO_ADDR
5538: LD_INT 4
5540: PUSH
5541: LD_INT 5
5543: PUSH
5544: LD_INT 5
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PUSH
5558: FOR_TO
5559: IFFALSE 5720
// begin uc_side := 2 ;
5561: LD_ADDR_OWVAR 20
5565: PUSH
5566: LD_INT 2
5568: ST_TO_ADDR
// uc_nation := 2 ;
5569: LD_ADDR_OWVAR 21
5573: PUSH
5574: LD_INT 2
5576: ST_TO_ADDR
// InitHC_All ( ) ;
5577: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5581: LD_INT 0
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: LD_INT 5
5589: PUSH
5590: LD_INT 6
5592: PUSH
5593: LD_INT 7
5595: PUSH
5596: EMPTY
5597: LIST
5598: LIST
5599: LIST
5600: PUSH
5601: LD_OWVAR 67
5605: ARRAY
5606: PPUSH
5607: CALL_OW 380
// un := CreateHuman ;
5611: LD_ADDR_VAR 0 2
5615: PUSH
5616: CALL_OW 44
5620: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5621: LD_VAR 0 2
5625: PPUSH
5626: LD_INT 17
5628: PPUSH
5629: LD_INT 0
5631: PPUSH
5632: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5636: LD_VAR 0 2
5640: PPUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 8
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PUSH
5651: LD_INT 1
5653: PPUSH
5654: LD_INT 2
5656: PPUSH
5657: CALL_OW 12
5661: ARRAY
5662: PPUSH
5663: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_INT 111
5674: PPUSH
5675: LD_INT 34
5677: PPUSH
5678: CALL_OW 114
// wait ( 0 0$2 ) ;
5682: LD_INT 70
5684: PPUSH
5685: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5689: LD_ADDR_VAR 0 3
5693: PUSH
5694: LD_VAR 0 3
5698: PPUSH
5699: LD_VAR 0 3
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PPUSH
5708: LD_VAR 0 2
5712: PPUSH
5713: CALL_OW 1
5717: ST_TO_ADDR
// end ;
5718: GO 5558
5720: POP
5721: POP
// end else
5722: GO 5865
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5724: LD_ADDR_VAR 0 1
5728: PUSH
5729: DOUBLE
5730: LD_INT 1
5732: DEC
5733: ST_TO_ADDR
5734: LD_INT 4
5736: PUSH
5737: LD_INT 5
5739: PUSH
5740: LD_INT 5
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_OWVAR 67
5752: ARRAY
5753: PUSH
5754: FOR_TO
5755: IFFALSE 5863
// begin uc_side := 2 ;
5757: LD_ADDR_OWVAR 20
5761: PUSH
5762: LD_INT 2
5764: ST_TO_ADDR
// uc_nation := 0 ;
5765: LD_ADDR_OWVAR 21
5769: PUSH
5770: LD_INT 0
5772: ST_TO_ADDR
// InitHC_All ( ) ;
5773: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5777: LD_ADDR_OWVAR 28
5781: PUSH
5782: LD_INT 17
5784: ST_TO_ADDR
// un := CreateHuman ;
5785: LD_ADDR_VAR 0 2
5789: PUSH
5790: CALL_OW 44
5794: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5795: LD_VAR 0 2
5799: PPUSH
5800: LD_INT 17
5802: PPUSH
5803: LD_INT 0
5805: PPUSH
5806: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5810: LD_VAR 0 2
5814: PPUSH
5815: LD_INT 110
5817: PPUSH
5818: LD_INT 33
5820: PPUSH
5821: CALL_OW 114
// wait ( 0 0$2 ) ;
5825: LD_INT 70
5827: PPUSH
5828: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5832: LD_ADDR_VAR 0 3
5836: PUSH
5837: LD_VAR 0 3
5841: PPUSH
5842: LD_VAR 0 3
5846: PUSH
5847: LD_INT 1
5849: PLUS
5850: PPUSH
5851: LD_VAR 0 2
5855: PPUSH
5856: CALL_OW 1
5860: ST_TO_ADDR
// end ;
5861: GO 5754
5863: POP
5864: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5865: LD_ADDR_VAR 0 1
5869: PUSH
5870: DOUBLE
5871: LD_INT 1
5873: DEC
5874: ST_TO_ADDR
5875: LD_INT 3
5877: PUSH
5878: LD_INT 4
5880: PUSH
5881: LD_INT 5
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PUSH
5889: LD_OWVAR 67
5893: ARRAY
5894: PUSH
5895: FOR_TO
5896: IFFALSE 6061
// begin uc_side := 2 ;
5898: LD_ADDR_OWVAR 20
5902: PUSH
5903: LD_INT 2
5905: ST_TO_ADDR
// uc_nation := 2 ;
5906: LD_ADDR_OWVAR 21
5910: PUSH
5911: LD_INT 2
5913: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5914: LD_INT 14
5916: PPUSH
5917: LD_INT 3
5919: PPUSH
5920: LD_INT 5
5922: PPUSH
5923: LD_INT 29
5925: PUSH
5926: LD_INT 28
5928: PUSH
5929: LD_INT 27
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 1
5939: PPUSH
5940: LD_INT 3
5942: PPUSH
5943: CALL_OW 12
5947: ARRAY
5948: PPUSH
5949: LD_INT 90
5951: PPUSH
5952: CALL 15955 0 5
// un := CreateVehicle ;
5956: LD_ADDR_VAR 0 2
5960: PUSH
5961: CALL_OW 45
5965: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5966: LD_VAR 0 2
5970: PPUSH
5971: LD_INT 2
5973: PPUSH
5974: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_INT 17
5985: PPUSH
5986: LD_INT 0
5988: PPUSH
5989: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5993: LD_VAR 0 2
5997: PPUSH
5998: LD_INT 66
6000: PPUSH
6001: LD_INT 23
6003: PPUSH
6004: CALL_OW 111
// wait ( 0 0$3 ) ;
6008: LD_INT 105
6010: PPUSH
6011: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 147
6022: PPUSH
6023: LD_INT 103
6025: PPUSH
6026: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6030: LD_ADDR_VAR 0 3
6034: PUSH
6035: LD_VAR 0 3
6039: PPUSH
6040: LD_VAR 0 3
6044: PUSH
6045: LD_INT 1
6047: PLUS
6048: PPUSH
6049: LD_VAR 0 2
6053: PPUSH
6054: CALL_OW 1
6058: ST_TO_ADDR
// end ;
6059: GO 5895
6061: POP
6062: POP
// if not tmp then
6063: LD_VAR 0 3
6067: NOT
6068: IFFALSE 6072
// exit ;
6070: GO 6172
// wait ( 0 0$5 ) ;
6072: LD_INT 175
6074: PPUSH
6075: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6079: LD_INT 70
6081: PPUSH
6082: CALL_OW 67
// for i in tmp do
6086: LD_ADDR_VAR 0 1
6090: PUSH
6091: LD_VAR 0 3
6095: PUSH
6096: FOR_IN
6097: IFFALSE 6163
// begin if not IsOk ( i ) then
6099: LD_VAR 0 1
6103: PPUSH
6104: CALL_OW 302
6108: NOT
6109: IFFALSE 6127
// tmp := tmp diff i ;
6111: LD_ADDR_VAR 0 3
6115: PUSH
6116: LD_VAR 0 3
6120: PUSH
6121: LD_VAR 0 1
6125: DIFF
6126: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6127: LD_VAR 0 1
6131: PPUSH
6132: LD_INT 81
6134: PUSH
6135: LD_INT 2
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 69
6146: PPUSH
6147: LD_VAR 0 1
6151: PPUSH
6152: CALL_OW 74
6156: PPUSH
6157: CALL_OW 115
// end ;
6161: GO 6096
6163: POP
6164: POP
// until not tmp ;
6165: LD_VAR 0 3
6169: NOT
6170: IFFALSE 6079
// end ;
6172: PPOPN 3
6174: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6175: LD_OWVAR 67
6179: PUSH
6180: LD_INT 1
6182: GREATER
6183: IFFALSE 6281
6185: GO 6187
6187: DISABLE
6188: LD_INT 0
6190: PPUSH
// begin uc_side := 2 ;
6191: LD_ADDR_OWVAR 20
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// uc_nation := 2 ;
6199: LD_ADDR_OWVAR 21
6203: PUSH
6204: LD_INT 2
6206: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 4
6212: PPUSH
6213: LD_INT 6
6215: PPUSH
6216: CALL_OW 380
// un := CreateHuman ;
6220: LD_ADDR_VAR 0 1
6224: PUSH
6225: CALL_OW 44
6229: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6230: LD_VAR 0 1
6234: PPUSH
6235: LD_INT 88
6237: PPUSH
6238: LD_INT 1
6240: PPUSH
6241: LD_INT 2
6243: PPUSH
6244: LD_INT 0
6246: PPUSH
6247: CALL 50576 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6251: LD_VAR 0 1
6255: PPUSH
6256: LD_INT 130
6258: PPUSH
6259: LD_INT 35
6261: PPUSH
6262: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 132
6273: PPUSH
6274: LD_INT 39
6276: PPUSH
6277: CALL_OW 218
// end ;
6281: PPOPN 1
6283: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6284: LD_INT 22
6286: PUSH
6287: LD_INT 2
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 33
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 50
6306: PUSH
6307: EMPTY
6308: LIST
6309: PUSH
6310: LD_INT 3
6312: PUSH
6313: LD_INT 61
6315: PUSH
6316: EMPTY
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: PPUSH
6329: CALL_OW 69
6333: IFFALSE 6424
6335: GO 6337
6337: DISABLE
6338: LD_INT 0
6340: PPUSH
6341: PPUSH
// begin enable ;
6342: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6343: LD_ADDR_VAR 0 2
6347: PUSH
6348: LD_INT 22
6350: PUSH
6351: LD_INT 2
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PUSH
6358: LD_INT 33
6360: PUSH
6361: LD_INT 2
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 50
6370: PUSH
6371: EMPTY
6372: LIST
6373: PUSH
6374: LD_INT 3
6376: PUSH
6377: LD_INT 61
6379: PUSH
6380: EMPTY
6381: LIST
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: PPUSH
6393: CALL_OW 69
6397: ST_TO_ADDR
// for i in tmp do
6398: LD_ADDR_VAR 0 1
6402: PUSH
6403: LD_VAR 0 2
6407: PUSH
6408: FOR_IN
6409: IFFALSE 6422
// Connect ( i ) ;
6411: LD_VAR 0 1
6415: PPUSH
6416: CALL 19055 0 1
6420: GO 6408
6422: POP
6423: POP
// end ; end_of_file
6424: PPOPN 2
6426: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6427: LD_INT 0
6429: PPUSH
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
6434: PPUSH
// popov_side := 3 ;
6435: LD_ADDR_EXP 17
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// uc_side := popov_side ;
6443: LD_ADDR_OWVAR 20
6447: PUSH
6448: LD_EXP 17
6452: ST_TO_ADDR
// uc_nation := 3 ;
6453: LD_ADDR_OWVAR 21
6457: PUSH
6458: LD_INT 3
6460: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6461: LD_ADDR_VAR 0 6
6465: PUSH
6466: LD_INT 5
6468: PUSH
6469: LD_INT 103
6471: PUSH
6472: LD_INT 147
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 5
6486: PUSH
6487: LD_INT 70
6489: PUSH
6490: LD_INT 117
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: PUSH
6502: LD_INT 6
6504: PUSH
6505: LD_INT 76
6507: PUSH
6508: LD_INT 145
6510: PUSH
6511: LD_INT 1
6513: PUSH
6514: LD_INT 10
6516: PUSH
6517: LD_INT 11
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: LIST
6526: LIST
6527: PUSH
6528: LD_INT 26
6530: PUSH
6531: LD_INT 87
6533: PUSH
6534: LD_INT 144
6536: PUSH
6537: LD_INT 0
6539: PUSH
6540: EMPTY
6541: LIST
6542: LIST
6543: LIST
6544: LIST
6545: PUSH
6546: LD_INT 29
6548: PUSH
6549: LD_INT 86
6551: PUSH
6552: LD_INT 118
6554: PUSH
6555: LD_INT 0
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: PUSH
6564: LD_INT 29
6566: PUSH
6567: LD_INT 98
6569: PUSH
6570: LD_INT 121
6572: PUSH
6573: LD_INT 0
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: LIST
6580: LIST
6581: PUSH
6582: LD_INT 26
6584: PUSH
6585: LD_INT 87
6587: PUSH
6588: LD_INT 147
6590: PUSH
6591: LD_INT 1
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 30
6602: PUSH
6603: LD_INT 123
6605: PUSH
6606: LD_INT 151
6608: PUSH
6609: LD_INT 1
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PUSH
6618: LD_INT 3
6620: PUSH
6621: LD_INT 94
6623: PUSH
6624: LD_INT 161
6626: PUSH
6627: LD_INT 0
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 6
6638: PUSH
6639: LD_INT 81
6641: PUSH
6642: LD_INT 155
6644: PUSH
6645: LD_INT 1
6647: PUSH
6648: LD_INT 12
6650: PUSH
6651: LD_INT 14
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 26
6664: PUSH
6665: LD_INT 96
6667: PUSH
6668: LD_INT 152
6670: PUSH
6671: LD_INT 0
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 96
6685: PUSH
6686: LD_INT 149
6688: PUSH
6689: LD_INT 3
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: PUSH
6698: LD_INT 32
6700: PUSH
6701: LD_INT 109
6703: PUSH
6704: LD_INT 142
6706: PUSH
6707: LD_INT 3
6709: PUSH
6710: LD_INT 46
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: PUSH
6720: LD_INT 32
6722: PUSH
6723: LD_INT 112
6725: PUSH
6726: LD_INT 148
6728: PUSH
6729: LD_INT 3
6731: PUSH
6732: LD_INT 46
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 33
6744: PUSH
6745: LD_INT 120
6747: PUSH
6748: LD_INT 159
6750: PUSH
6751: LD_INT 4
6753: PUSH
6754: LD_INT 45
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: PUSH
6764: LD_INT 33
6766: PUSH
6767: LD_INT 122
6769: PUSH
6770: LD_INT 163
6772: PUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 45
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: PUSH
6786: LD_INT 33
6788: PUSH
6789: LD_INT 123
6791: PUSH
6792: LD_INT 167
6794: PUSH
6795: LD_INT 4
6797: PUSH
6798: LD_INT 45
6800: PUSH
6801: EMPTY
6802: LIST
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 33
6810: PUSH
6811: LD_INT 59
6813: PUSH
6814: LD_INT 111
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 45
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: LIST
6829: PUSH
6830: LD_INT 33
6832: PUSH
6833: LD_INT 65
6835: PUSH
6836: LD_INT 111
6838: PUSH
6839: LD_INT 3
6841: PUSH
6842: LD_INT 46
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: LIST
6850: LIST
6851: PUSH
6852: LD_INT 33
6854: PUSH
6855: LD_INT 76
6857: PUSH
6858: LD_INT 117
6860: PUSH
6861: LD_INT 3
6863: PUSH
6864: LD_INT 45
6866: PUSH
6867: EMPTY
6868: LIST
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 33
6876: PUSH
6877: LD_INT 80
6879: PUSH
6880: LD_INT 119
6882: PUSH
6883: LD_INT 3
6885: PUSH
6886: LD_INT 46
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: LIST
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 33
6898: PUSH
6899: LD_INT 87
6901: PUSH
6902: LD_INT 125
6904: PUSH
6905: LD_INT 3
6907: PUSH
6908: LD_INT 45
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_INT 5
6920: PUSH
6921: LD_INT 92
6923: PUSH
6924: LD_INT 129
6926: PUSH
6927: LD_INT 3
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: LD_INT 28
6938: PUSH
6939: LD_INT 85
6941: PUSH
6942: LD_INT 165
6944: PUSH
6945: LD_INT 0
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: PUSH
6954: LD_INT 28
6956: PUSH
6957: LD_INT 83
6959: PUSH
6960: LD_INT 161
6962: PUSH
6963: LD_INT 4
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: PUSH
6972: LD_INT 28
6974: PUSH
6975: LD_INT 91
6977: PUSH
6978: LD_INT 166
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: LIST
6988: LIST
6989: PUSH
6990: LD_INT 28
6992: PUSH
6993: LD_INT 102
6995: PUSH
6996: LD_INT 166
6998: PUSH
6999: LD_INT 2
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: LIST
7006: LIST
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: LIST
7016: LIST
7017: LIST
7018: LIST
7019: LIST
7020: LIST
7021: LIST
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: ST_TO_ADDR
// for i in list do
7037: LD_ADDR_VAR 0 2
7041: PUSH
7042: LD_VAR 0 6
7046: PUSH
7047: FOR_IN
7048: IFFALSE 7258
// begin uc_side := 3 ;
7050: LD_ADDR_OWVAR 20
7054: PUSH
7055: LD_INT 3
7057: ST_TO_ADDR
// uc_nation := 3 ;
7058: LD_ADDR_OWVAR 21
7062: PUSH
7063: LD_INT 3
7065: ST_TO_ADDR
// InitBc ;
7066: CALL_OW 21
// bc_type := i [ 1 ] ;
7070: LD_ADDR_OWVAR 42
7074: PUSH
7075: LD_VAR 0 2
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
7084: LD_VAR 0 2
7088: PUSH
7089: LD_INT 1
7091: ARRAY
7092: PUSH
7093: LD_INT 29
7095: PUSH
7096: LD_INT 30
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: IN
7103: IFFALSE 7130
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 3 ) ;
7105: LD_VAR 0 2
7109: PUSH
7110: LD_INT 2
7112: ARRAY
7113: PPUSH
7114: LD_VAR 0 2
7118: PUSH
7119: LD_INT 3
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: CALL_OW 441
// if i [ 1 ] = b_lab then
7130: LD_VAR 0 2
7134: PUSH
7135: LD_INT 1
7137: ARRAY
7138: PUSH
7139: LD_INT 6
7141: EQUAL
7142: IFFALSE 7180
// begin bc_type := b_lab_full ;
7144: LD_ADDR_OWVAR 42
7148: PUSH
7149: LD_INT 8
7151: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7152: LD_ADDR_OWVAR 44
7156: PUSH
7157: LD_VAR 0 2
7161: PUSH
7162: LD_INT 5
7164: ARRAY
7165: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7166: LD_ADDR_OWVAR 45
7170: PUSH
7171: LD_VAR 0 2
7175: PUSH
7176: LD_INT 6
7178: ARRAY
7179: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7180: LD_ADDR_VAR 0 5
7184: PUSH
7185: LD_VAR 0 2
7189: PUSH
7190: LD_INT 2
7192: ARRAY
7193: PPUSH
7194: LD_VAR 0 2
7198: PUSH
7199: LD_INT 3
7201: ARRAY
7202: PPUSH
7203: LD_VAR 0 2
7207: PUSH
7208: LD_INT 4
7210: ARRAY
7211: PPUSH
7212: CALL_OW 47
7216: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7217: LD_VAR 0 2
7221: PUSH
7222: LD_INT 1
7224: ARRAY
7225: PUSH
7226: LD_INT 33
7228: PUSH
7229: LD_INT 32
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: IN
7236: IFFALSE 7256
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7238: LD_VAR 0 5
7242: PPUSH
7243: LD_VAR 0 2
7247: PUSH
7248: LD_INT 5
7250: ARRAY
7251: PPUSH
7252: CALL_OW 431
// end ;
7256: GO 7047
7258: POP
7259: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7260: LD_ADDR_VAR 0 4
7264: PUSH
7265: LD_INT 9
7267: PPUSH
7268: LD_INT 3
7270: PPUSH
7271: LD_STRING 
7273: PPUSH
7274: LD_INT 8
7276: PUSH
7277: LD_INT 7
7279: PUSH
7280: LD_INT 6
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: LIST
7287: PUSH
7288: LD_OWVAR 67
7292: ARRAY
7293: PPUSH
7294: LD_INT 11500
7296: PUSH
7297: LD_INT 1100
7299: PUSH
7300: LD_INT 60
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: LIST
7307: PPUSH
7308: LD_INT 6
7310: PUSH
7311: LD_INT 6
7313: PUSH
7314: LD_INT 6
7316: PUSH
7317: LD_INT 6
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PPUSH
7326: CALL 19408 0 6
7330: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7331: LD_ADDR_EXP 23
7335: PUSH
7336: LD_EXP 23
7340: PPUSH
7341: LD_INT 3
7343: PPUSH
7344: LD_VAR 0 4
7348: PUSH
7349: LD_INT 22
7351: PUSH
7352: LD_INT 3
7354: PUSH
7355: EMPTY
7356: LIST
7357: LIST
7358: PUSH
7359: LD_INT 21
7361: PUSH
7362: LD_INT 3
7364: PUSH
7365: EMPTY
7366: LIST
7367: LIST
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: PPUSH
7373: CALL_OW 69
7377: UNION
7378: PPUSH
7379: CALL_OW 1
7383: ST_TO_ADDR
// extraPopovForces := [ ] ;
7384: LD_ADDR_EXP 18
7388: PUSH
7389: EMPTY
7390: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7391: LD_ADDR_VAR 0 2
7395: PUSH
7396: DOUBLE
7397: LD_INT 1
7399: DEC
7400: ST_TO_ADDR
7401: LD_INT 8
7403: PUSH
7404: LD_INT 9
7406: PUSH
7407: LD_INT 10
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: PUSH
7415: LD_OWVAR 67
7419: ARRAY
7420: PUSH
7421: FOR_TO
7422: IFFALSE 7551
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7424: LD_INT 0
7426: PPUSH
7427: LD_INT 1
7429: PPUSH
7430: LD_INT 4
7432: PUSH
7433: LD_INT 5
7435: PUSH
7436: LD_INT 6
7438: PUSH
7439: EMPTY
7440: LIST
7441: LIST
7442: LIST
7443: PUSH
7444: LD_OWVAR 67
7448: ARRAY
7449: PPUSH
7450: CALL_OW 380
// un := CreateHuman ;
7454: LD_ADDR_VAR 0 3
7458: PUSH
7459: CALL_OW 44
7463: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7464: LD_INT 0
7466: PPUSH
7467: LD_INT 1
7469: PPUSH
7470: CALL_OW 12
7474: IFFALSE 7499
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7476: LD_VAR 0 3
7480: PPUSH
7481: LD_INT 131
7483: PPUSH
7484: LD_INT 110
7486: PPUSH
7487: LD_INT 8
7489: PPUSH
7490: LD_INT 0
7492: PPUSH
7493: CALL_OW 50
7497: GO 7520
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7499: LD_VAR 0 3
7503: PPUSH
7504: LD_INT 100
7506: PPUSH
7507: LD_INT 99
7509: PPUSH
7510: LD_INT 8
7512: PPUSH
7513: LD_INT 0
7515: PPUSH
7516: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7520: LD_ADDR_EXP 18
7524: PUSH
7525: LD_EXP 18
7529: PPUSH
7530: LD_EXP 18
7534: PUSH
7535: LD_INT 1
7537: PLUS
7538: PPUSH
7539: LD_VAR 0 3
7543: PPUSH
7544: CALL_OW 1
7548: ST_TO_ADDR
// end ;
7549: GO 7421
7551: POP
7552: POP
// PrepareSoldier ( false , 6 ) ;
7553: LD_INT 0
7555: PPUSH
7556: LD_INT 6
7558: PPUSH
7559: CALL_OW 381
// un := CreateHuman ;
7563: LD_ADDR_VAR 0 3
7567: PUSH
7568: CALL_OW 44
7572: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7573: LD_VAR 0 3
7577: PPUSH
7578: LD_INT 1
7580: PPUSH
7581: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7585: LD_VAR 0 3
7589: PPUSH
7590: LD_INT 150
7592: PPUSH
7593: LD_INT 158
7595: PPUSH
7596: CALL_OW 428
7600: PPUSH
7601: CALL_OW 52
// popovAttackGroup := [ ] ;
7605: LD_ADDR_EXP 19
7609: PUSH
7610: EMPTY
7611: ST_TO_ADDR
// end ;
7612: LD_VAR 0 1
7616: RET
// export function InitMC_Popov ( ) ; begin
7617: LD_INT 0
7619: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7620: LD_INT 3
7622: PPUSH
7623: LD_INT 3
7625: PPUSH
7626: CALL 78213 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7630: LD_INT 3
7632: PPUSH
7633: LD_INT 10
7635: PPUSH
7636: CALL 78157 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7640: LD_INT 3
7642: PPUSH
7643: LD_INT 86
7645: PUSH
7646: LD_INT 118
7648: PUSH
7649: LD_INT 0
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: LIST
7656: PUSH
7657: LD_INT 123
7659: PUSH
7660: LD_INT 151
7662: PUSH
7663: LD_INT 1
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 98
7673: PUSH
7674: LD_INT 121
7676: PUSH
7677: LD_INT 0
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: PPUSH
7690: CALL 77216 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7694: LD_INT 3
7696: PPUSH
7697: LD_INT 46
7699: PUSH
7700: LD_INT 45
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PPUSH
7707: CALL 78045 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7711: LD_INT 3
7713: PPUSH
7714: LD_INT 12
7716: PPUSH
7717: CALL 77727 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7721: LD_INT 3
7723: PPUSH
7724: LD_INT 11
7726: PPUSH
7727: CALL 77458 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7731: LD_INT 3
7733: PPUSH
7734: LD_INT 4
7736: PPUSH
7737: CALL 77077 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7741: LD_INT 3
7743: PPUSH
7744: LD_INT 23
7746: PUSH
7747: LD_INT 1
7749: PUSH
7750: LD_INT 3
7752: PUSH
7753: LD_INT 44
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 23
7764: PUSH
7765: LD_INT 1
7767: PUSH
7768: LD_INT 3
7770: PUSH
7771: LD_INT 45
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 21
7782: PUSH
7783: LD_INT 1
7785: PUSH
7786: LD_INT 3
7788: PUSH
7789: LD_INT 44
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: LIST
7797: PUSH
7798: LD_INT 21
7800: PUSH
7801: LD_INT 1
7803: PUSH
7804: LD_INT 3
7806: PUSH
7807: LD_INT 45
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: LIST
7820: LIST
7821: PPUSH
7822: CALL 76892 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7826: LD_INT 3
7828: PPUSH
7829: LD_INT 94
7831: PPUSH
7832: LD_INT 161
7834: PPUSH
7835: LD_INT 0
7837: PPUSH
7838: LD_INT 19
7840: PUSH
7841: LD_INT 17
7843: PUSH
7844: LD_INT 18
7846: PUSH
7847: LD_INT 24
7849: PUSH
7850: LD_INT 21
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: LIST
7857: LIST
7858: LIST
7859: PPUSH
7860: CALL 77839 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7864: LD_INT 3
7866: PPUSH
7867: LD_INT 21
7869: PUSH
7870: LD_INT 1
7872: PUSH
7873: LD_INT 3
7875: PUSH
7876: LD_INT 51
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: PUSH
7885: EMPTY
7886: LIST
7887: PPUSH
7888: CALL 76940 0 2
// end ;
7892: LD_VAR 0 1
7896: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7897: LD_EXP 18
7901: PUSH
7902: LD_EXP 5
7906: NOT
7907: AND
7908: IFFALSE 7968
7910: GO 7912
7912: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7913: LD_EXP 18
7917: PPUSH
7918: LD_INT 106
7920: PPUSH
7921: LD_INT 137
7923: PPUSH
7924: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7928: LD_ADDR_EXP 23
7932: PUSH
7933: LD_EXP 23
7937: PPUSH
7938: LD_INT 3
7940: PPUSH
7941: LD_EXP 23
7945: PUSH
7946: LD_INT 3
7948: ARRAY
7949: PUSH
7950: LD_EXP 18
7954: UNION
7955: PPUSH
7956: CALL_OW 1
7960: ST_TO_ADDR
// extraPopovForces := [ ] ;
7961: LD_ADDR_EXP 18
7965: PUSH
7966: EMPTY
7967: ST_TO_ADDR
// end ;
7968: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7969: LD_INT 9
7971: PPUSH
7972: CALL_OW 302
7976: PUSH
7977: LD_EXP 5
7981: NOT
7982: AND
7983: IFFALSE 8549
7985: GO 7987
7987: DISABLE
7988: LD_INT 0
7990: PPUSH
7991: PPUSH
7992: PPUSH
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// base := 3 ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 3
8003: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
8004: LD_ADDR_VAR 0 3
8008: PUSH
8009: LD_INT 21
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: LD_INT 3
8017: PUSH
8018: LD_INT 44
8020: PUSH
8021: EMPTY
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: PUSH
8027: LD_INT 23
8029: PUSH
8030: LD_INT 1
8032: PUSH
8033: LD_INT 3
8035: PUSH
8036: LD_INT 46
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 23
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: LD_INT 3
8053: PUSH
8054: LD_INT 46
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: LIST
8061: LIST
8062: PUSH
8063: LD_INT 23
8065: PUSH
8066: LD_INT 1
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: LD_INT 46
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: LIST
8085: LIST
8086: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
8087: LD_ADDR_VAR 0 5
8091: PUSH
8092: LD_VAR 0 5
8096: PUSH
8097: LD_OWVAR 1
8101: PUSH
8102: LD_INT 21000
8104: DIV
8105: PLUS
8106: ST_TO_ADDR
// if amount > 8 then
8107: LD_VAR 0 5
8111: PUSH
8112: LD_INT 8
8114: GREATER
8115: IFFALSE 8125
// amount := 8 ;
8117: LD_ADDR_VAR 0 5
8121: PUSH
8122: LD_INT 8
8124: ST_TO_ADDR
// for i = 1 to amount do
8125: LD_ADDR_VAR 0 1
8129: PUSH
8130: DOUBLE
8131: LD_INT 1
8133: DEC
8134: ST_TO_ADDR
8135: LD_VAR 0 5
8139: PUSH
8140: FOR_TO
8141: IFFALSE 8206
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_wheeled , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8143: LD_ADDR_VAR 0 3
8147: PUSH
8148: LD_VAR 0 3
8152: PPUSH
8153: LD_VAR 0 3
8157: PUSH
8158: LD_INT 1
8160: PLUS
8161: PPUSH
8162: LD_INT 23
8164: PUSH
8165: LD_INT 1
8167: PUSH
8168: LD_INT 3
8170: PUSH
8171: LD_INT 46
8173: PUSH
8174: LD_INT 45
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: LIST
8197: LIST
8198: PPUSH
8199: CALL_OW 2
8203: ST_TO_ADDR
8204: GO 8140
8206: POP
8207: POP
// MC_InsertProduceList ( base , tmp ) ;
8208: LD_VAR 0 2
8212: PPUSH
8213: LD_VAR 0 3
8217: PPUSH
8218: CALL 76940 0 2
// repeat wait ( 0 0$1 ) ;
8222: LD_INT 35
8224: PPUSH
8225: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8229: LD_VAR 0 2
8233: PPUSH
8234: LD_INT 1
8236: PPUSH
8237: CALL 78358 0 2
8241: PUSH
8242: LD_VAR 0 5
8246: GREATEREQUAL
8247: IFFALSE 8222
// wait ( 0 0$30 ) ;
8249: LD_INT 1050
8251: PPUSH
8252: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8256: LD_ADDR_VAR 0 4
8260: PUSH
8261: LD_EXP 42
8265: PUSH
8266: LD_VAR 0 2
8270: ARRAY
8271: PUSH
8272: LD_EXP 42
8276: PUSH
8277: LD_VAR 0 2
8281: ARRAY
8282: PPUSH
8283: LD_INT 2
8285: PUSH
8286: LD_INT 34
8288: PUSH
8289: LD_INT 51
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PUSH
8296: LD_INT 34
8298: PUSH
8299: LD_INT 52
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: LIST
8310: PPUSH
8311: CALL_OW 72
8315: DIFF
8316: ST_TO_ADDR
// if not attackers then
8317: LD_VAR 0 4
8321: NOT
8322: IFFALSE 8326
// exit ;
8324: GO 8549
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8326: LD_ADDR_EXP 42
8330: PUSH
8331: LD_EXP 42
8335: PPUSH
8336: LD_VAR 0 2
8340: PPUSH
8341: LD_EXP 42
8345: PUSH
8346: LD_VAR 0 2
8350: ARRAY
8351: PUSH
8352: LD_VAR 0 4
8356: DIFF
8357: PPUSH
8358: CALL_OW 1
8362: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8363: LD_VAR 0 4
8367: PPUSH
8368: LD_INT 107
8370: PPUSH
8371: LD_INT 74
8373: PPUSH
8374: CALL_OW 114
// wait ( 0 0$5 ) ;
8378: LD_INT 175
8380: PPUSH
8381: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8385: LD_INT 35
8387: PPUSH
8388: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8392: LD_VAR 0 4
8396: PPUSH
8397: LD_INT 60
8399: PUSH
8400: EMPTY
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: NOT
8408: IFFALSE 8385
// if rand ( 0 , 1 ) then
8410: LD_INT 0
8412: PPUSH
8413: LD_INT 1
8415: PPUSH
8416: CALL_OW 12
8420: IFFALSE 8439
// ComAgressiveMove ( attackers , 155 , 108 ) else
8422: LD_VAR 0 4
8426: PPUSH
8427: LD_INT 155
8429: PPUSH
8430: LD_INT 108
8432: PPUSH
8433: CALL_OW 114
8437: GO 8454
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8439: LD_VAR 0 4
8443: PPUSH
8444: LD_INT 149
8446: PPUSH
8447: LD_INT 55
8449: PPUSH
8450: CALL_OW 114
// wait ( 0 0$10 ) ;
8454: LD_INT 350
8456: PPUSH
8457: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// for i in attackers do
8468: LD_ADDR_VAR 0 1
8472: PUSH
8473: LD_VAR 0 4
8477: PUSH
8478: FOR_IN
8479: IFFALSE 8529
// if not HasTask ( i ) then
8481: LD_VAR 0 1
8485: PPUSH
8486: CALL_OW 314
8490: NOT
8491: IFFALSE 8527
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8493: LD_VAR 0 1
8497: PPUSH
8498: LD_INT 81
8500: PUSH
8501: LD_INT 3
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: PPUSH
8508: CALL_OW 69
8512: PPUSH
8513: LD_VAR 0 1
8517: PPUSH
8518: CALL_OW 74
8522: PPUSH
8523: CALL_OW 115
8527: GO 8478
8529: POP
8530: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8531: LD_VAR 0 4
8535: PPUSH
8536: LD_INT 50
8538: PUSH
8539: EMPTY
8540: LIST
8541: PPUSH
8542: CALL_OW 72
8546: NOT
8547: IFFALSE 8461
// end ;
8549: PPOPN 5
8551: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8552: LD_EXP 5
8556: NOT
8557: IFFALSE 9144
8559: GO 8561
8561: DISABLE
8562: LD_INT 0
8564: PPUSH
8565: PPUSH
8566: PPUSH
8567: PPUSH
// begin enable ;
8568: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8569: LD_OWVAR 67
8573: PUSH
8574: LD_INT 1
8576: EQUAL
8577: PUSH
8578: LD_OWVAR 1
8582: PUSH
8583: LD_INT 63000
8585: LESS
8586: AND
8587: IFFALSE 8591
// exit ;
8589: GO 9144
// tmp := [ ] ;
8591: LD_ADDR_VAR 0 3
8595: PUSH
8596: EMPTY
8597: ST_TO_ADDR
// if tick < 45 45$00 then
8598: LD_OWVAR 1
8602: PUSH
8603: LD_INT 94500
8605: LESS
8606: IFFALSE 8783
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8608: LD_ADDR_VAR 0 1
8612: PUSH
8613: DOUBLE
8614: LD_INT 1
8616: DEC
8617: ST_TO_ADDR
8618: LD_INT 2
8620: PUSH
8621: LD_INT 3
8623: PUSH
8624: LD_INT 4
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: LD_OWVAR 67
8636: ARRAY
8637: PUSH
8638: FOR_TO
8639: IFFALSE 8781
// begin uc_side := 3 ;
8641: LD_ADDR_OWVAR 20
8645: PUSH
8646: LD_INT 3
8648: ST_TO_ADDR
// uc_nation := 3 ;
8649: LD_ADDR_OWVAR 21
8653: PUSH
8654: LD_INT 3
8656: ST_TO_ADDR
// InitHC_All ( ) ;
8657: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8661: LD_INT 0
8663: PPUSH
8664: LD_INT 1
8666: PPUSH
8667: LD_INT 5
8669: PUSH
8670: LD_INT 6
8672: PUSH
8673: LD_INT 7
8675: PUSH
8676: EMPTY
8677: LIST
8678: LIST
8679: LIST
8680: PUSH
8681: LD_OWVAR 67
8685: ARRAY
8686: PPUSH
8687: CALL_OW 380
// un := CreateHuman ;
8691: LD_ADDR_VAR 0 2
8695: PUSH
8696: CALL_OW 44
8700: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8701: LD_VAR 0 2
8705: PPUSH
8706: LD_INT 18
8708: PPUSH
8709: LD_INT 0
8711: PPUSH
8712: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8716: LD_VAR 0 2
8720: PPUSH
8721: LD_INT 9
8723: PPUSH
8724: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8728: LD_VAR 0 2
8732: PPUSH
8733: LD_INT 147
8735: PPUSH
8736: LD_INT 161
8738: PPUSH
8739: CALL_OW 111
// wait ( 0 0$2 ) ;
8743: LD_INT 70
8745: PPUSH
8746: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8750: LD_ADDR_VAR 0 3
8754: PUSH
8755: LD_VAR 0 3
8759: PPUSH
8760: LD_VAR 0 3
8764: PUSH
8765: LD_INT 1
8767: PLUS
8768: PPUSH
8769: LD_VAR 0 2
8773: PPUSH
8774: CALL_OW 1
8778: ST_TO_ADDR
// end ;
8779: GO 8638
8781: POP
8782: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8783: LD_ADDR_VAR 0 4
8787: PUSH
8788: LD_INT 3
8790: PUSH
8791: LD_INT 4
8793: PUSH
8794: LD_INT 5
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: LIST
8801: PUSH
8802: LD_OWVAR 67
8806: ARRAY
8807: PUSH
8808: LD_OWVAR 1
8812: PUSH
8813: LD_INT 21000
8815: DIV
8816: PLUS
8817: ST_TO_ADDR
// if amount > 15 then
8818: LD_VAR 0 4
8822: PUSH
8823: LD_INT 15
8825: GREATER
8826: IFFALSE 8836
// amount := 15 ;
8828: LD_ADDR_VAR 0 4
8832: PUSH
8833: LD_INT 15
8835: ST_TO_ADDR
// for i := 1 to amount do
8836: LD_ADDR_VAR 0 1
8840: PUSH
8841: DOUBLE
8842: LD_INT 1
8844: DEC
8845: ST_TO_ADDR
8846: LD_VAR 0 4
8850: PUSH
8851: FOR_TO
8852: IFFALSE 8998
// begin uc_side := 3 ;
8854: LD_ADDR_OWVAR 20
8858: PUSH
8859: LD_INT 3
8861: ST_TO_ADDR
// uc_nation := 3 ;
8862: LD_ADDR_OWVAR 21
8866: PUSH
8867: LD_INT 3
8869: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8870: LD_INT 24
8872: PPUSH
8873: LD_INT 1
8875: PPUSH
8876: LD_INT 3
8878: PPUSH
8879: LD_INT 46
8881: PUSH
8882: LD_INT 45
8884: PUSH
8885: LD_INT 44
8887: PUSH
8888: LD_INT 43
8890: PUSH
8891: LD_INT 42
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_INT 1
8903: PPUSH
8904: LD_INT 5
8906: PPUSH
8907: CALL_OW 12
8911: ARRAY
8912: PPUSH
8913: LD_INT 90
8915: PPUSH
8916: CALL 15955 0 5
// un := CreateVehicle ;
8920: LD_ADDR_VAR 0 2
8924: PUSH
8925: CALL_OW 45
8929: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8930: LD_VAR 0 2
8934: PPUSH
8935: LD_INT 18
8937: PPUSH
8938: LD_INT 0
8940: PPUSH
8941: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8945: LD_VAR 0 2
8949: PPUSH
8950: LD_INT 147
8952: PPUSH
8953: LD_INT 161
8955: PPUSH
8956: CALL_OW 111
// wait ( 0 0$3 ) ;
8960: LD_INT 105
8962: PPUSH
8963: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PPUSH
8977: LD_VAR 0 3
8981: PUSH
8982: LD_INT 1
8984: PLUS
8985: PPUSH
8986: LD_VAR 0 2
8990: PPUSH
8991: CALL_OW 1
8995: ST_TO_ADDR
// end ;
8996: GO 8851
8998: POP
8999: POP
// if not tmp then
9000: LD_VAR 0 3
9004: NOT
9005: IFFALSE 9009
// exit ;
9007: GO 9144
// wait ( 0 0$5 ) ;
9009: LD_INT 175
9011: PPUSH
9012: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
9016: LD_INT 70
9018: PPUSH
9019: CALL_OW 67
// for i in tmp do
9023: LD_ADDR_VAR 0 1
9027: PUSH
9028: LD_VAR 0 3
9032: PUSH
9033: FOR_IN
9034: IFFALSE 9135
// begin if not IsOk ( i ) or IsDead ( i ) then
9036: LD_VAR 0 1
9040: PPUSH
9041: CALL_OW 302
9045: NOT
9046: PUSH
9047: LD_VAR 0 1
9051: PPUSH
9052: CALL_OW 301
9056: OR
9057: IFFALSE 9075
// tmp := tmp diff i ;
9059: LD_ADDR_VAR 0 3
9063: PUSH
9064: LD_VAR 0 3
9068: PUSH
9069: LD_VAR 0 1
9073: DIFF
9074: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
9075: LD_VAR 0 1
9079: PPUSH
9080: CALL_OW 257
9084: PUSH
9085: LD_INT 9
9087: EQUAL
9088: IFFALSE 9099
// ComSpaceTimeShoot ( i ) ;
9090: LD_VAR 0 1
9094: PPUSH
9095: CALL 12062 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9099: LD_VAR 0 1
9103: PPUSH
9104: LD_INT 81
9106: PUSH
9107: LD_INT 3
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: PPUSH
9114: CALL_OW 69
9118: PPUSH
9119: LD_VAR 0 1
9123: PPUSH
9124: CALL_OW 74
9128: PPUSH
9129: CALL_OW 115
// end ;
9133: GO 9033
9135: POP
9136: POP
// until not tmp ;
9137: LD_VAR 0 3
9141: NOT
9142: IFFALSE 9016
// end ; end_of_file
9144: PPOPN 4
9146: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9147: LD_INT 0
9149: PPUSH
9150: PPUSH
9151: PPUSH
9152: PPUSH
// uc_side := 1 ;
9153: LD_ADDR_OWVAR 20
9157: PUSH
9158: LD_INT 1
9160: ST_TO_ADDR
// uc_nation := 1 ;
9161: LD_ADDR_OWVAR 21
9165: PUSH
9166: LD_INT 1
9168: ST_TO_ADDR
// hc_importance := 100 ;
9169: LD_ADDR_OWVAR 32
9173: PUSH
9174: LD_INT 100
9176: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9177: LD_ADDR_OWVAR 26
9181: PUSH
9182: LD_STRING Jeremy Sikorski
9184: ST_TO_ADDR
// hc_gallery := us ;
9185: LD_ADDR_OWVAR 33
9189: PUSH
9190: LD_STRING us
9192: ST_TO_ADDR
// hc_face_number := 19 ;
9193: LD_ADDR_OWVAR 34
9197: PUSH
9198: LD_INT 19
9200: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9201: LD_INT 1
9203: PPUSH
9204: LD_INT 1
9206: PPUSH
9207: LD_INT 4
9209: PUSH
9210: LD_INT 4
9212: PUSH
9213: LD_INT 3
9215: PUSH
9216: EMPTY
9217: LIST
9218: LIST
9219: LIST
9220: PUSH
9221: LD_OWVAR 67
9225: ARRAY
9226: PPUSH
9227: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9231: LD_ADDR_OWVAR 29
9235: PUSH
9236: LD_INT 10
9238: PUSH
9239: LD_INT 12
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: ST_TO_ADDR
// Sikorski := CreateHuman ;
9246: LD_ADDR_EXP 20
9250: PUSH
9251: CALL_OW 44
9255: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9256: LD_EXP 20
9260: PPUSH
9261: LD_INT 133
9263: PPUSH
9264: LD_INT 19
9266: PPUSH
9267: LD_INT 2
9269: PPUSH
9270: LD_INT 0
9272: PPUSH
9273: CALL_OW 50
// InitHc_All ( ) ;
9277: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9281: LD_ADDR_VAR 0 2
9285: PUSH
9286: DOUBLE
9287: LD_INT 1
9289: DEC
9290: ST_TO_ADDR
9291: LD_INT 4
9293: PUSH
9294: LD_INT 3
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: LIST
9304: PUSH
9305: LD_OWVAR 67
9309: ARRAY
9310: PUSH
9311: FOR_TO
9312: IFFALSE 9428
// for j := 1 to 4 do
9314: LD_ADDR_VAR 0 3
9318: PUSH
9319: DOUBLE
9320: LD_INT 1
9322: DEC
9323: ST_TO_ADDR
9324: LD_INT 4
9326: PUSH
9327: FOR_TO
9328: IFFALSE 9424
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9330: LD_INT 0
9332: PPUSH
9333: LD_VAR 0 3
9337: PPUSH
9338: LD_INT 5
9340: PUSH
9341: LD_INT 4
9343: PUSH
9344: LD_INT 3
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PUSH
9352: LD_OWVAR 67
9356: ARRAY
9357: PPUSH
9358: CALL_OW 380
// un := CreateHuman ;
9362: LD_ADDR_VAR 0 4
9366: PUSH
9367: CALL_OW 44
9371: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9372: LD_VAR 0 4
9376: PPUSH
9377: LD_INT 0
9379: PPUSH
9380: LD_INT 5
9382: PPUSH
9383: CALL_OW 12
9387: PPUSH
9388: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 133
9399: PPUSH
9400: LD_INT 19
9402: PPUSH
9403: LD_INT 6
9405: PPUSH
9406: LD_INT 0
9408: PPUSH
9409: CALL_OW 50
// ComHold ( un ) ;
9413: LD_VAR 0 4
9417: PPUSH
9418: CALL_OW 140
// end ;
9422: GO 9327
9424: POP
9425: POP
9426: GO 9311
9428: POP
9429: POP
// vc_chassis := us_heavy_tracked ;
9430: LD_ADDR_OWVAR 37
9434: PUSH
9435: LD_INT 4
9437: ST_TO_ADDR
// vc_engine := engine_combustion ;
9438: LD_ADDR_OWVAR 39
9442: PUSH
9443: LD_INT 1
9445: ST_TO_ADDR
// vc_control := control_manual ;
9446: LD_ADDR_OWVAR 38
9450: PUSH
9451: LD_INT 1
9453: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9454: LD_ADDR_OWVAR 40
9458: PUSH
9459: LD_INT 14
9461: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9462: LD_ADDR_OWVAR 41
9466: PUSH
9467: LD_INT 60
9469: ST_TO_ADDR
// un := CreateVehicle ;
9470: LD_ADDR_VAR 0 4
9474: PUSH
9475: CALL_OW 45
9479: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9480: LD_VAR 0 4
9484: PPUSH
9485: LD_INT 2
9487: PPUSH
9488: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9492: LD_VAR 0 4
9496: PPUSH
9497: LD_INT 128
9499: PPUSH
9500: LD_INT 12
9502: PPUSH
9503: LD_INT 0
9505: PPUSH
9506: CALL_OW 48
// for i := 1 to 3 do
9510: LD_ADDR_VAR 0 2
9514: PUSH
9515: DOUBLE
9516: LD_INT 1
9518: DEC
9519: ST_TO_ADDR
9520: LD_INT 3
9522: PUSH
9523: FOR_TO
9524: IFFALSE 9547
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9526: LD_INT 5
9528: PPUSH
9529: LD_INT 133
9531: PPUSH
9532: LD_INT 19
9534: PPUSH
9535: LD_INT 3
9537: PPUSH
9538: LD_INT 0
9540: PPUSH
9541: CALL_OW 56
9545: GO 9523
9547: POP
9548: POP
// end ; end_of_file
9549: LD_VAR 0 1
9553: RET
// export function Action ; begin
9554: LD_INT 0
9556: PPUSH
// InGameOn ;
9557: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9561: LD_INT 133
9563: PPUSH
9564: LD_INT 19
9566: PPUSH
9567: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9571: LD_EXP 20
9575: PPUSH
9576: LD_STRING WT-DS-1
9578: PPUSH
9579: CALL_OW 88
// InGameOff ;
9583: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9587: LD_STRING DestroyEnemy
9589: PPUSH
9590: CALL_OW 337
// wait ( 0 0$20 ) ;
9594: LD_INT 700
9596: PPUSH
9597: CALL_OW 67
// DialogueOn ;
9601: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9605: LD_INT 100
9607: PPUSH
9608: LD_INT 37
9610: PPUSH
9611: LD_INT 1
9613: PPUSH
9614: LD_INT 30
9616: NEG
9617: PPUSH
9618: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9622: LD_INT 100
9624: PPUSH
9625: LD_INT 37
9627: PPUSH
9628: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9632: LD_EXP 10
9636: PPUSH
9637: LD_STRING WT-PL-1
9639: PPUSH
9640: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9644: LD_EXP 20
9648: PPUSH
9649: LD_STRING WT-DS-2
9651: PPUSH
9652: CALL_OW 88
// DialogueOff ;
9656: CALL_OW 7
// wait ( 0 0$2 ) ;
9660: LD_INT 70
9662: PPUSH
9663: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9667: LD_INT 100
9669: PPUSH
9670: LD_INT 37
9672: PPUSH
9673: LD_INT 1
9675: PPUSH
9676: CALL_OW 331
// end ;
9680: LD_VAR 0 1
9684: RET
// export function DialogPowellsAttack ; begin
9685: LD_INT 0
9687: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9688: LD_EXP 10
9692: PPUSH
9693: LD_STRING WT-PL-8
9695: PPUSH
9696: CALL_OW 94
// end ;
9700: LD_VAR 0 1
9704: RET
// export function DialogContaminateSib ( x , y ) ; begin
9705: LD_INT 0
9707: PPUSH
// DialogueOn ;
9708: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9712: LD_VAR 0 1
9716: PPUSH
9717: LD_VAR 0 2
9721: PPUSH
9722: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9726: LD_EXP 20
9730: PPUSH
9731: LD_STRING WT-DS-3
9733: PPUSH
9734: CALL_OW 88
// DialogueOff ;
9738: CALL_OW 7
// end ;
9742: LD_VAR 0 3
9746: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9747: LD_EXP 8
9751: NOT
9752: PUSH
9753: LD_INT 1
9755: PPUSH
9756: LD_INT 81
9758: PUSH
9759: LD_INT 4
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PPUSH
9766: CALL_OW 70
9770: PUSH
9771: LD_INT 3
9773: GREATER
9774: AND
9775: IFFALSE 9847
9777: GO 9779
9779: DISABLE
// begin powellInTrouble := true ;
9780: LD_ADDR_EXP 8
9784: PUSH
9785: LD_INT 1
9787: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9788: LD_EXP 20
9792: PPUSH
9793: LD_STRING WT-DS-6
9795: PPUSH
9796: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9800: LD_INT 1
9802: PPUSH
9803: LD_INT 22
9805: PUSH
9806: LD_INT 1
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PPUSH
9813: CALL_OW 70
9817: NOT
9818: IFFALSE 9832
// SayRadio ( Powell , WT-PL-6 ) ;
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-6
9827: PPUSH
9828: CALL_OW 94
// wait ( 1 1$30 ) ;
9832: LD_INT 3150
9834: PPUSH
9835: CALL_OW 67
// powellInTrouble := false ;
9839: LD_ADDR_EXP 8
9843: PUSH
9844: LD_INT 0
9846: ST_TO_ADDR
// end ;
9847: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9848: LD_EXP 9
9852: NOT
9853: PUSH
9854: LD_INT 16
9856: PPUSH
9857: LD_INT 81
9859: PUSH
9860: LD_INT 1
9862: PUSH
9863: EMPTY
9864: LIST
9865: LIST
9866: PPUSH
9867: CALL_OW 70
9871: PUSH
9872: LD_INT 6
9874: GREATER
9875: AND
9876: IFFALSE 9949
9878: GO 9880
9880: DISABLE
// begin sikorskiInTrouble := true ;
9881: LD_ADDR_EXP 9
9885: PUSH
9886: LD_INT 1
9888: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9889: LD_EXP 20
9893: PPUSH
9894: LD_STRING WT-DS-7
9896: PPUSH
9897: CALL_OW 88
// if not powellAttackGroup then
9901: LD_EXP 12
9905: NOT
9906: IFFALSE 9922
// SayRadio ( Powell , WT-PL-7n ) else
9908: LD_EXP 10
9912: PPUSH
9913: LD_STRING WT-PL-7n
9915: PPUSH
9916: CALL_OW 94
9920: GO 9934
// SayRadio ( Powell , WT-PL-7y ) ;
9922: LD_EXP 10
9926: PPUSH
9927: LD_STRING WT-PL-7y
9929: PPUSH
9930: CALL_OW 94
// wait ( 1 1$30 ) ;
9934: LD_INT 3150
9936: PPUSH
9937: CALL_OW 67
// sikorskiInTrouble := false ;
9941: LD_ADDR_EXP 9
9945: PUSH
9946: LD_INT 0
9948: ST_TO_ADDR
// end ;
9949: END
// export function DialogPowellsAttackFailed ; begin
9950: LD_INT 0
9952: PPUSH
// if not ruDestroyed then
9953: LD_EXP 5
9957: NOT
9958: IFFALSE 9974
// SayRadio ( Powell , WT-PL-9 ) else
9960: LD_EXP 10
9964: PPUSH
9965: LD_STRING WT-PL-9
9967: PPUSH
9968: CALL_OW 94
9972: GO 9986
// SayRadio ( Powell , WT-PL-10 ) ;
9974: LD_EXP 10
9978: PPUSH
9979: LD_STRING WT-PL-10
9981: PPUSH
9982: CALL_OW 94
// end ;
9986: LD_VAR 0 1
9990: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9991: LD_INT 22
9993: PUSH
9994: LD_INT 2
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: LD_INT 21
10003: PUSH
10004: LD_INT 1
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PPUSH
10015: CALL_OW 69
10019: PUSH
10020: LD_INT 0
10022: EQUAL
10023: IFFALSE 10067
10025: GO 10027
10027: DISABLE
// begin arDestroyed := true ;
10028: LD_ADDR_EXP 4
10032: PUSH
10033: LD_INT 1
10035: ST_TO_ADDR
// MC_Kill ( 2 ) ;
10036: LD_INT 2
10038: PPUSH
10039: CALL 52915 0 1
// Say ( Sikorski , WT-DS-4 ) ;
10043: LD_EXP 20
10047: PPUSH
10048: LD_STRING WT-DS-4
10050: PPUSH
10051: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
10055: LD_EXP 10
10059: PPUSH
10060: LD_STRING WT-PL-4
10062: PPUSH
10063: CALL_OW 94
// end ;
10067: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10068: LD_INT 22
10070: PUSH
10071: LD_INT 3
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 21
10080: PUSH
10081: LD_INT 1
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: PPUSH
10092: CALL_OW 69
10096: PUSH
10097: LD_INT 0
10099: EQUAL
10100: IFFALSE 10144
10102: GO 10104
10104: DISABLE
// begin ruDestroyed := true ;
10105: LD_ADDR_EXP 5
10109: PUSH
10110: LD_INT 1
10112: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10113: LD_INT 3
10115: PPUSH
10116: CALL 52915 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10120: LD_EXP 20
10124: PPUSH
10125: LD_STRING WT-DS-5
10127: PPUSH
10128: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10132: LD_EXP 10
10136: PPUSH
10137: LD_STRING WT-PL-5
10139: PPUSH
10140: CALL_OW 94
// end ;
10144: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10145: LD_EXP 5
10149: PUSH
10150: LD_EXP 4
10154: AND
10155: IFFALSE 10328
10157: GO 10159
10159: DISABLE
// begin wait ( 0 0$3 ) ;
10160: LD_INT 105
10162: PPUSH
10163: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10167: LD_OWVAR 1
10171: PUSH
10172: LD_INT 126000
10174: PUSH
10175: LD_INT 105000
10177: PUSH
10178: LD_INT 94500
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: LD_OWVAR 67
10190: ARRAY
10191: GREATEREQUAL
10192: IFFALSE 10207
// AddMedal ( WoT-med-1 , - 1 ) else
10194: LD_STRING WoT-med-1
10196: PPUSH
10197: LD_INT 1
10199: NEG
10200: PPUSH
10201: CALL_OW 101
10205: GO 10217
// AddMedal ( WoT-med-1 , 1 ) ;
10207: LD_STRING WoT-med-1
10209: PPUSH
10210: LD_INT 1
10212: PPUSH
10213: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10217: LD_EXP 6
10221: PUSH
10222: LD_INT 4
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 2
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: LIST
10235: PUSH
10236: LD_OWVAR 67
10240: ARRAY
10241: GREATEREQUAL
10242: IFFALSE 10257
// AddMedal ( WoT-med-2 , - 1 ) else
10244: LD_STRING WoT-med-2
10246: PPUSH
10247: LD_INT 1
10249: NEG
10250: PPUSH
10251: CALL_OW 101
10255: GO 10267
// AddMedal ( WoT-med-2 , 1 ) ;
10257: LD_STRING WoT-med-2
10259: PPUSH
10260: LD_INT 1
10262: PPUSH
10263: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10267: LD_EXP 7
10271: PUSH
10272: LD_INT 8
10274: PUSH
10275: LD_INT 6
10277: PUSH
10278: LD_INT 5
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: PUSH
10286: LD_OWVAR 67
10290: ARRAY
10291: GREATEREQUAL
10292: IFFALSE 10307
// AddMedal ( WoT-med-3 , - 1 ) else
10294: LD_STRING WoT-med-3
10296: PPUSH
10297: LD_INT 1
10299: NEG
10300: PPUSH
10301: CALL_OW 101
10305: GO 10317
// AddMedal ( WoT-med-3 , 1 ) ;
10307: LD_STRING WoT-med-3
10309: PPUSH
10310: LD_INT 1
10312: PPUSH
10313: CALL_OW 101
// GiveMedals ( MAIN ) ;
10317: LD_STRING MAIN
10319: PPUSH
10320: CALL_OW 102
// YouWin ;
10324: CALL_OW 103
// end ; end_of_file
10328: END
// export function CustomEvent ( event ) ; begin
10329: LD_INT 0
10331: PPUSH
// end ;
10332: LD_VAR 0 2
10336: RET
// on Command ( com ) do var i , j , temp ;
10337: LD_INT 0
10339: PPUSH
10340: PPUSH
10341: PPUSH
// begin if com = 60 then
10342: LD_VAR 0 1
10346: PUSH
10347: LD_INT 60
10349: EQUAL
10350: IFFALSE 10529
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10352: LD_ADDR_VAR 0 2
10356: PUSH
10357: LD_INT 22
10359: PUSH
10360: LD_INT 1
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: PUSH
10367: LD_INT 2
10369: PUSH
10370: LD_INT 21
10372: PUSH
10373: LD_INT 1
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 34
10382: PUSH
10383: LD_INT 12
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: PPUSH
10399: CALL_OW 69
10403: PUSH
10404: FOR_IN
10405: IFFALSE 10527
// begin if GetTaskList ( i ) > 0 then
10407: LD_VAR 0 2
10411: PPUSH
10412: CALL_OW 437
10416: PUSH
10417: LD_INT 0
10419: GREATER
10420: IFFALSE 10525
// for j = 1 to GetTaskList ( i ) do
10422: LD_ADDR_VAR 0 3
10426: PUSH
10427: DOUBLE
10428: LD_INT 1
10430: DEC
10431: ST_TO_ADDR
10432: LD_VAR 0 2
10436: PPUSH
10437: CALL_OW 437
10441: PUSH
10442: FOR_TO
10443: IFFALSE 10523
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10445: LD_ADDR_VAR 0 4
10449: PUSH
10450: LD_VAR 0 2
10454: PPUSH
10455: CALL_OW 437
10459: PUSH
10460: LD_VAR 0 3
10464: ARRAY
10465: PUSH
10466: LD_INT 4
10468: ARRAY
10469: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10470: LD_VAR 0 4
10474: PPUSH
10475: CALL_OW 255
10479: PUSH
10480: LD_INT 4
10482: EQUAL
10483: PUSH
10484: LD_VAR 0 2
10488: PPUSH
10489: CALL_OW 437
10493: PUSH
10494: LD_VAR 0 3
10498: ARRAY
10499: PUSH
10500: LD_INT 1
10502: ARRAY
10503: PUSH
10504: LD_STRING <
10506: EQUAL
10507: AND
10508: IFFALSE 10521
// SetTaskList ( i , [ ] ) ;
10510: LD_VAR 0 2
10514: PPUSH
10515: EMPTY
10516: PPUSH
10517: CALL_OW 446
// end ;
10521: GO 10442
10523: POP
10524: POP
// end ;
10525: GO 10404
10527: POP
10528: POP
// end ; end ;
10529: PPOPN 4
10531: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10532: LD_VAR 0 2
10536: PPUSH
10537: LD_VAR 0 3
10541: PPUSH
10542: CALL_OW 428
10546: PPUSH
10547: CALL_OW 255
10551: PUSH
10552: LD_INT 1
10554: EQUAL
10555: PUSH
10556: LD_VAR 0 2
10560: PUSH
10561: LD_INT 132
10563: EQUAL
10564: PUSH
10565: LD_VAR 0 3
10569: PUSH
10570: LD_INT 39
10572: EQUAL
10573: AND
10574: OR
10575: IFFALSE 10591
// DialogContaminateSib ( x , y ) ;
10577: LD_VAR 0 2
10581: PPUSH
10582: LD_VAR 0 3
10586: PPUSH
10587: CALL 9705 0 2
// end ;
10591: PPOPN 3
10593: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10594: LD_VAR 0 1
10598: PPUSH
10599: CALL 90667 0 1
// MCE_UnitDestroyed ( un ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: CALL 80382 0 1
// if un = Powell then
10612: LD_VAR 0 1
10616: PUSH
10617: LD_EXP 10
10621: EQUAL
10622: IFFALSE 10631
// YouLost ( Powell ) ;
10624: LD_STRING Powell
10626: PPUSH
10627: CALL_OW 104
// if un = Sikorski then
10631: LD_VAR 0 1
10635: PUSH
10636: LD_EXP 20
10640: EQUAL
10641: IFFALSE 10650
// YouLost ( Sikorski ) ;
10643: LD_STRING Sikorski
10645: PPUSH
10646: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10650: LD_VAR 0 1
10654: PUSH
10655: LD_INT 22
10657: PUSH
10658: LD_INT 1
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: PUSH
10665: LD_INT 21
10667: PUSH
10668: LD_INT 1
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: PPUSH
10679: CALL_OW 69
10683: IN
10684: IFFALSE 10700
// loseCounter := loseCounter + 1 ;
10686: LD_ADDR_EXP 6
10690: PUSH
10691: LD_EXP 6
10695: PUSH
10696: LD_INT 1
10698: PLUS
10699: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10700: LD_VAR 0 1
10704: PUSH
10705: LD_INT 22
10707: PUSH
10708: LD_INT 4
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: PUSH
10715: LD_INT 21
10717: PUSH
10718: LD_INT 1
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: PPUSH
10729: CALL_OW 69
10733: IN
10734: IFFALSE 10750
// powellLoseCounter := powellLoseCounter + 1 ;
10736: LD_ADDR_EXP 7
10740: PUSH
10741: LD_EXP 7
10745: PUSH
10746: LD_INT 1
10748: PLUS
10749: ST_TO_ADDR
// if un in powellAttackGroup then
10750: LD_VAR 0 1
10754: PUSH
10755: LD_EXP 12
10759: IN
10760: IFFALSE 10778
// powellAttackGroup := powellAttackGroup diff un ;
10762: LD_ADDR_EXP 12
10766: PUSH
10767: LD_EXP 12
10771: PUSH
10772: LD_VAR 0 1
10776: DIFF
10777: ST_TO_ADDR
// if un in gensherAttackGroup then
10778: LD_VAR 0 1
10782: PUSH
10783: LD_EXP 15
10787: IN
10788: IFFALSE 10806
// gensherAttackGroup := gensherAttackGroup diff un ;
10790: LD_ADDR_EXP 15
10794: PUSH
10795: LD_EXP 15
10799: PUSH
10800: LD_VAR 0 1
10804: DIFF
10805: ST_TO_ADDR
// if un in popovAttackGroup then
10806: LD_VAR 0 1
10810: PUSH
10811: LD_EXP 19
10815: IN
10816: IFFALSE 10834
// popovAttackGroup := popovAttackGroup diff un ;
10818: LD_ADDR_EXP 19
10822: PUSH
10823: LD_EXP 19
10827: PUSH
10828: LD_VAR 0 1
10832: DIFF
10833: ST_TO_ADDR
// end ;
10834: PPOPN 1
10836: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10837: LD_VAR 0 1
10841: PPUSH
10842: LD_VAR 0 2
10846: PPUSH
10847: CALL 82714 0 2
// end ;
10851: PPOPN 2
10853: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10854: LD_VAR 0 1
10858: PPUSH
10859: CALL 81782 0 1
// end ;
10863: PPOPN 1
10865: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10866: LD_VAR 0 1
10870: PPUSH
10871: CALL 82023 0 1
// end ;
10875: PPOPN 1
10877: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_VAR 0 2
10887: PPUSH
10888: CALL 80078 0 2
// end ;
10892: PPOPN 2
10894: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10895: LD_VAR 0 1
10899: PPUSH
10900: LD_VAR 0 2
10904: PPUSH
10905: LD_VAR 0 3
10909: PPUSH
10910: LD_VAR 0 4
10914: PPUSH
10915: LD_VAR 0 5
10919: PPUSH
10920: CALL 79698 0 5
// end ;
10924: PPOPN 5
10926: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10927: LD_VAR 0 1
10931: PPUSH
10932: LD_VAR 0 2
10936: PPUSH
10937: CALL 90787 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_VAR 0 2
10950: PPUSH
10951: CALL 79251 0 2
// end ;
10955: PPOPN 2
10957: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10958: LD_VAR 0 1
10962: PPUSH
10963: LD_VAR 0 2
10967: PPUSH
10968: LD_VAR 0 3
10972: PPUSH
10973: LD_VAR 0 4
10977: PPUSH
10978: CALL 79089 0 4
// end ;
10982: PPOPN 4
10984: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10985: LD_VAR 0 1
10989: PPUSH
10990: LD_VAR 0 2
10994: PPUSH
10995: LD_VAR 0 3
10999: PPUSH
11000: CALL 78864 0 3
// end ;
11004: PPOPN 3
11006: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11007: LD_VAR 0 1
11011: PPUSH
11012: LD_VAR 0 2
11016: PPUSH
11017: CALL 78749 0 2
// end ;
11021: PPOPN 2
11023: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11024: LD_VAR 0 1
11028: PPUSH
11029: LD_VAR 0 2
11033: PPUSH
11034: CALL 83009 0 2
// end ;
11038: PPOPN 2
11040: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11041: LD_VAR 0 1
11045: PPUSH
11046: LD_VAR 0 2
11050: PPUSH
11051: LD_VAR 0 3
11055: PPUSH
11056: LD_VAR 0 4
11060: PPUSH
11061: CALL 83225 0 4
// end ;
11065: PPOPN 4
11067: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11068: LD_VAR 0 1
11072: PPUSH
11073: LD_VAR 0 2
11077: PPUSH
11078: CALL 78558 0 2
// end ;
11082: PPOPN 2
11084: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
11085: LD_VAR 0 1
11089: PUSH
11090: LD_INT 1
11092: EQUAL
11093: PUSH
11094: LD_VAR 0 2
11098: PUSH
11099: LD_INT 4
11101: EQUAL
11102: AND
11103: IFFALSE 11112
// YouLost ( FriendlyFire ) ;
11105: LD_STRING FriendlyFire
11107: PPUSH
11108: CALL_OW 104
// end ; end_of_file
11112: PPOPN 2
11114: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11115: LD_INT 0
11117: PPUSH
11118: PPUSH
// if exist_mode then
11119: LD_VAR 0 2
11123: IFFALSE 11148
// unit := CreateCharacter ( prefix & ident ) else
11125: LD_ADDR_VAR 0 5
11129: PUSH
11130: LD_VAR 0 3
11134: PUSH
11135: LD_VAR 0 1
11139: STR
11140: PPUSH
11141: CALL_OW 34
11145: ST_TO_ADDR
11146: GO 11163
// unit := NewCharacter ( ident ) ;
11148: LD_ADDR_VAR 0 5
11152: PUSH
11153: LD_VAR 0 1
11157: PPUSH
11158: CALL_OW 25
11162: ST_TO_ADDR
// result := unit ;
11163: LD_ADDR_VAR 0 4
11167: PUSH
11168: LD_VAR 0 5
11172: ST_TO_ADDR
// end ;
11173: LD_VAR 0 4
11177: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11178: LD_INT 0
11180: PPUSH
11181: PPUSH
// if not side or not nation then
11182: LD_VAR 0 1
11186: NOT
11187: PUSH
11188: LD_VAR 0 2
11192: NOT
11193: OR
11194: IFFALSE 11198
// exit ;
11196: GO 11966
// case nation of nation_american :
11198: LD_VAR 0 2
11202: PUSH
11203: LD_INT 1
11205: DOUBLE
11206: EQUAL
11207: IFTRUE 11211
11209: GO 11425
11211: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11212: LD_ADDR_VAR 0 4
11216: PUSH
11217: LD_INT 35
11219: PUSH
11220: LD_INT 45
11222: PUSH
11223: LD_INT 46
11225: PUSH
11226: LD_INT 47
11228: PUSH
11229: LD_INT 82
11231: PUSH
11232: LD_INT 83
11234: PUSH
11235: LD_INT 84
11237: PUSH
11238: LD_INT 85
11240: PUSH
11241: LD_INT 86
11243: PUSH
11244: LD_INT 1
11246: PUSH
11247: LD_INT 2
11249: PUSH
11250: LD_INT 6
11252: PUSH
11253: LD_INT 15
11255: PUSH
11256: LD_INT 16
11258: PUSH
11259: LD_INT 7
11261: PUSH
11262: LD_INT 12
11264: PUSH
11265: LD_INT 13
11267: PUSH
11268: LD_INT 10
11270: PUSH
11271: LD_INT 14
11273: PUSH
11274: LD_INT 20
11276: PUSH
11277: LD_INT 21
11279: PUSH
11280: LD_INT 22
11282: PUSH
11283: LD_INT 25
11285: PUSH
11286: LD_INT 32
11288: PUSH
11289: LD_INT 27
11291: PUSH
11292: LD_INT 36
11294: PUSH
11295: LD_INT 69
11297: PUSH
11298: LD_INT 39
11300: PUSH
11301: LD_INT 34
11303: PUSH
11304: LD_INT 40
11306: PUSH
11307: LD_INT 48
11309: PUSH
11310: LD_INT 49
11312: PUSH
11313: LD_INT 50
11315: PUSH
11316: LD_INT 51
11318: PUSH
11319: LD_INT 52
11321: PUSH
11322: LD_INT 53
11324: PUSH
11325: LD_INT 54
11327: PUSH
11328: LD_INT 55
11330: PUSH
11331: LD_INT 56
11333: PUSH
11334: LD_INT 57
11336: PUSH
11337: LD_INT 58
11339: PUSH
11340: LD_INT 59
11342: PUSH
11343: LD_INT 60
11345: PUSH
11346: LD_INT 61
11348: PUSH
11349: LD_INT 62
11351: PUSH
11352: LD_INT 80
11354: PUSH
11355: LD_INT 82
11357: PUSH
11358: LD_INT 83
11360: PUSH
11361: LD_INT 84
11363: PUSH
11364: LD_INT 85
11366: PUSH
11367: LD_INT 86
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: LIST
11374: LIST
11375: LIST
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: LIST
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: ST_TO_ADDR
11423: GO 11890
11425: LD_INT 2
11427: DOUBLE
11428: EQUAL
11429: IFTRUE 11433
11431: GO 11659
11433: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11434: LD_ADDR_VAR 0 4
11438: PUSH
11439: LD_INT 35
11441: PUSH
11442: LD_INT 45
11444: PUSH
11445: LD_INT 46
11447: PUSH
11448: LD_INT 47
11450: PUSH
11451: LD_INT 82
11453: PUSH
11454: LD_INT 83
11456: PUSH
11457: LD_INT 84
11459: PUSH
11460: LD_INT 85
11462: PUSH
11463: LD_INT 87
11465: PUSH
11466: LD_INT 70
11468: PUSH
11469: LD_INT 1
11471: PUSH
11472: LD_INT 11
11474: PUSH
11475: LD_INT 3
11477: PUSH
11478: LD_INT 4
11480: PUSH
11481: LD_INT 5
11483: PUSH
11484: LD_INT 6
11486: PUSH
11487: LD_INT 15
11489: PUSH
11490: LD_INT 18
11492: PUSH
11493: LD_INT 7
11495: PUSH
11496: LD_INT 17
11498: PUSH
11499: LD_INT 8
11501: PUSH
11502: LD_INT 20
11504: PUSH
11505: LD_INT 21
11507: PUSH
11508: LD_INT 22
11510: PUSH
11511: LD_INT 72
11513: PUSH
11514: LD_INT 26
11516: PUSH
11517: LD_INT 69
11519: PUSH
11520: LD_INT 39
11522: PUSH
11523: LD_INT 40
11525: PUSH
11526: LD_INT 41
11528: PUSH
11529: LD_INT 42
11531: PUSH
11532: LD_INT 43
11534: PUSH
11535: LD_INT 48
11537: PUSH
11538: LD_INT 49
11540: PUSH
11541: LD_INT 50
11543: PUSH
11544: LD_INT 51
11546: PUSH
11547: LD_INT 52
11549: PUSH
11550: LD_INT 53
11552: PUSH
11553: LD_INT 54
11555: PUSH
11556: LD_INT 55
11558: PUSH
11559: LD_INT 56
11561: PUSH
11562: LD_INT 60
11564: PUSH
11565: LD_INT 61
11567: PUSH
11568: LD_INT 62
11570: PUSH
11571: LD_INT 66
11573: PUSH
11574: LD_INT 67
11576: PUSH
11577: LD_INT 68
11579: PUSH
11580: LD_INT 81
11582: PUSH
11583: LD_INT 82
11585: PUSH
11586: LD_INT 83
11588: PUSH
11589: LD_INT 84
11591: PUSH
11592: LD_INT 85
11594: PUSH
11595: LD_INT 87
11597: PUSH
11598: LD_INT 88
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: ST_TO_ADDR
11657: GO 11890
11659: LD_INT 3
11661: DOUBLE
11662: EQUAL
11663: IFTRUE 11667
11665: GO 11889
11667: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11668: LD_ADDR_VAR 0 4
11672: PUSH
11673: LD_INT 46
11675: PUSH
11676: LD_INT 47
11678: PUSH
11679: LD_INT 1
11681: PUSH
11682: LD_INT 2
11684: PUSH
11685: LD_INT 82
11687: PUSH
11688: LD_INT 83
11690: PUSH
11691: LD_INT 84
11693: PUSH
11694: LD_INT 85
11696: PUSH
11697: LD_INT 86
11699: PUSH
11700: LD_INT 11
11702: PUSH
11703: LD_INT 9
11705: PUSH
11706: LD_INT 20
11708: PUSH
11709: LD_INT 19
11711: PUSH
11712: LD_INT 21
11714: PUSH
11715: LD_INT 24
11717: PUSH
11718: LD_INT 22
11720: PUSH
11721: LD_INT 25
11723: PUSH
11724: LD_INT 28
11726: PUSH
11727: LD_INT 29
11729: PUSH
11730: LD_INT 30
11732: PUSH
11733: LD_INT 31
11735: PUSH
11736: LD_INT 37
11738: PUSH
11739: LD_INT 38
11741: PUSH
11742: LD_INT 32
11744: PUSH
11745: LD_INT 27
11747: PUSH
11748: LD_INT 33
11750: PUSH
11751: LD_INT 69
11753: PUSH
11754: LD_INT 39
11756: PUSH
11757: LD_INT 34
11759: PUSH
11760: LD_INT 40
11762: PUSH
11763: LD_INT 71
11765: PUSH
11766: LD_INT 23
11768: PUSH
11769: LD_INT 44
11771: PUSH
11772: LD_INT 48
11774: PUSH
11775: LD_INT 49
11777: PUSH
11778: LD_INT 50
11780: PUSH
11781: LD_INT 51
11783: PUSH
11784: LD_INT 52
11786: PUSH
11787: LD_INT 53
11789: PUSH
11790: LD_INT 54
11792: PUSH
11793: LD_INT 55
11795: PUSH
11796: LD_INT 56
11798: PUSH
11799: LD_INT 57
11801: PUSH
11802: LD_INT 58
11804: PUSH
11805: LD_INT 59
11807: PUSH
11808: LD_INT 63
11810: PUSH
11811: LD_INT 64
11813: PUSH
11814: LD_INT 65
11816: PUSH
11817: LD_INT 82
11819: PUSH
11820: LD_INT 83
11822: PUSH
11823: LD_INT 84
11825: PUSH
11826: LD_INT 85
11828: PUSH
11829: LD_INT 86
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: ST_TO_ADDR
11887: GO 11890
11889: POP
// if state > - 1 and state < 3 then
11890: LD_VAR 0 3
11894: PUSH
11895: LD_INT 1
11897: NEG
11898: GREATER
11899: PUSH
11900: LD_VAR 0 3
11904: PUSH
11905: LD_INT 3
11907: LESS
11908: AND
11909: IFFALSE 11966
// for i in result do
11911: LD_ADDR_VAR 0 5
11915: PUSH
11916: LD_VAR 0 4
11920: PUSH
11921: FOR_IN
11922: IFFALSE 11964
// if GetTech ( i , side ) <> state then
11924: LD_VAR 0 5
11928: PPUSH
11929: LD_VAR 0 1
11933: PPUSH
11934: CALL_OW 321
11938: PUSH
11939: LD_VAR 0 3
11943: NONEQUAL
11944: IFFALSE 11962
// result := result diff i ;
11946: LD_ADDR_VAR 0 4
11950: PUSH
11951: LD_VAR 0 4
11955: PUSH
11956: LD_VAR 0 5
11960: DIFF
11961: ST_TO_ADDR
11962: GO 11921
11964: POP
11965: POP
// end ;
11966: LD_VAR 0 4
11970: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11971: LD_INT 0
11973: PPUSH
11974: PPUSH
11975: PPUSH
// result := true ;
11976: LD_ADDR_VAR 0 3
11980: PUSH
11981: LD_INT 1
11983: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11984: LD_ADDR_VAR 0 5
11988: PUSH
11989: LD_VAR 0 2
11993: PPUSH
11994: CALL_OW 480
11998: ST_TO_ADDR
// if not tmp then
11999: LD_VAR 0 5
12003: NOT
12004: IFFALSE 12008
// exit ;
12006: GO 12057
// for i in tmp do
12008: LD_ADDR_VAR 0 4
12012: PUSH
12013: LD_VAR 0 5
12017: PUSH
12018: FOR_IN
12019: IFFALSE 12055
// if GetTech ( i , side ) <> state_researched then
12021: LD_VAR 0 4
12025: PPUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 321
12035: PUSH
12036: LD_INT 2
12038: NONEQUAL
12039: IFFALSE 12053
// begin result := false ;
12041: LD_ADDR_VAR 0 3
12045: PUSH
12046: LD_INT 0
12048: ST_TO_ADDR
// exit ;
12049: POP
12050: POP
12051: GO 12057
// end ;
12053: GO 12018
12055: POP
12056: POP
// end ;
12057: LD_VAR 0 3
12061: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
12062: LD_INT 0
12064: PPUSH
12065: PPUSH
12066: PPUSH
12067: PPUSH
12068: PPUSH
12069: PPUSH
12070: PPUSH
12071: PPUSH
12072: PPUSH
12073: PPUSH
12074: PPUSH
12075: PPUSH
12076: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
12077: LD_VAR 0 1
12081: NOT
12082: PUSH
12083: LD_VAR 0 1
12087: PPUSH
12088: CALL_OW 257
12092: PUSH
12093: LD_INT 9
12095: NONEQUAL
12096: OR
12097: IFFALSE 12101
// exit ;
12099: GO 12674
// side := GetSide ( unit ) ;
12101: LD_ADDR_VAR 0 9
12105: PUSH
12106: LD_VAR 0 1
12110: PPUSH
12111: CALL_OW 255
12115: ST_TO_ADDR
// tech_space := tech_spacanom ;
12116: LD_ADDR_VAR 0 12
12120: PUSH
12121: LD_INT 29
12123: ST_TO_ADDR
// tech_time := tech_taurad ;
12124: LD_ADDR_VAR 0 13
12128: PUSH
12129: LD_INT 28
12131: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12132: LD_ADDR_VAR 0 11
12136: PUSH
12137: LD_VAR 0 1
12141: PPUSH
12142: CALL_OW 310
12146: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12147: LD_VAR 0 11
12151: PPUSH
12152: CALL_OW 247
12156: PUSH
12157: LD_INT 2
12159: EQUAL
12160: IFFALSE 12164
// exit ;
12162: GO 12674
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12164: LD_ADDR_VAR 0 8
12168: PUSH
12169: LD_INT 81
12171: PUSH
12172: LD_VAR 0 9
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: PUSH
12181: LD_INT 3
12183: PUSH
12184: LD_INT 21
12186: PUSH
12187: LD_INT 3
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PPUSH
12202: CALL_OW 69
12206: ST_TO_ADDR
// if not tmp then
12207: LD_VAR 0 8
12211: NOT
12212: IFFALSE 12216
// exit ;
12214: GO 12674
// if in_unit then
12216: LD_VAR 0 11
12220: IFFALSE 12244
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12222: LD_ADDR_VAR 0 10
12226: PUSH
12227: LD_VAR 0 8
12231: PPUSH
12232: LD_VAR 0 11
12236: PPUSH
12237: CALL_OW 74
12241: ST_TO_ADDR
12242: GO 12264
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12244: LD_ADDR_VAR 0 10
12248: PUSH
12249: LD_VAR 0 8
12253: PPUSH
12254: LD_VAR 0 1
12258: PPUSH
12259: CALL_OW 74
12263: ST_TO_ADDR
// if not enemy then
12264: LD_VAR 0 10
12268: NOT
12269: IFFALSE 12273
// exit ;
12271: GO 12674
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12273: LD_VAR 0 11
12277: PUSH
12278: LD_VAR 0 11
12282: PPUSH
12283: LD_VAR 0 10
12287: PPUSH
12288: CALL_OW 296
12292: PUSH
12293: LD_INT 13
12295: GREATER
12296: AND
12297: PUSH
12298: LD_VAR 0 1
12302: PPUSH
12303: LD_VAR 0 10
12307: PPUSH
12308: CALL_OW 296
12312: PUSH
12313: LD_INT 12
12315: GREATER
12316: OR
12317: IFFALSE 12321
// exit ;
12319: GO 12674
// missile := [ 1 ] ;
12321: LD_ADDR_VAR 0 14
12325: PUSH
12326: LD_INT 1
12328: PUSH
12329: EMPTY
12330: LIST
12331: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12332: LD_VAR 0 9
12336: PPUSH
12337: LD_VAR 0 12
12341: PPUSH
12342: CALL_OW 325
12346: IFFALSE 12375
// missile := Replace ( missile , missile + 1 , 2 ) ;
12348: LD_ADDR_VAR 0 14
12352: PUSH
12353: LD_VAR 0 14
12357: PPUSH
12358: LD_VAR 0 14
12362: PUSH
12363: LD_INT 1
12365: PLUS
12366: PPUSH
12367: LD_INT 2
12369: PPUSH
12370: CALL_OW 1
12374: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12375: LD_VAR 0 9
12379: PPUSH
12380: LD_VAR 0 13
12384: PPUSH
12385: CALL_OW 325
12389: PUSH
12390: LD_VAR 0 10
12394: PPUSH
12395: CALL_OW 255
12399: PPUSH
12400: LD_VAR 0 13
12404: PPUSH
12405: CALL_OW 325
12409: NOT
12410: AND
12411: IFFALSE 12440
// missile := Replace ( missile , missile + 1 , 3 ) ;
12413: LD_ADDR_VAR 0 14
12417: PUSH
12418: LD_VAR 0 14
12422: PPUSH
12423: LD_VAR 0 14
12427: PUSH
12428: LD_INT 1
12430: PLUS
12431: PPUSH
12432: LD_INT 3
12434: PPUSH
12435: CALL_OW 1
12439: ST_TO_ADDR
// if missile < 2 then
12440: LD_VAR 0 14
12444: PUSH
12445: LD_INT 2
12447: LESS
12448: IFFALSE 12452
// exit ;
12450: GO 12674
// x := GetX ( enemy ) ;
12452: LD_ADDR_VAR 0 4
12456: PUSH
12457: LD_VAR 0 10
12461: PPUSH
12462: CALL_OW 250
12466: ST_TO_ADDR
// y := GetY ( enemy ) ;
12467: LD_ADDR_VAR 0 5
12471: PUSH
12472: LD_VAR 0 10
12476: PPUSH
12477: CALL_OW 251
12481: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12482: LD_ADDR_VAR 0 6
12486: PUSH
12487: LD_VAR 0 4
12491: PUSH
12492: LD_INT 1
12494: NEG
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 12
12503: PLUS
12504: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12505: LD_ADDR_VAR 0 7
12509: PUSH
12510: LD_VAR 0 5
12514: PUSH
12515: LD_INT 1
12517: NEG
12518: PPUSH
12519: LD_INT 1
12521: PPUSH
12522: CALL_OW 12
12526: PLUS
12527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12528: LD_VAR 0 6
12532: PPUSH
12533: LD_VAR 0 7
12537: PPUSH
12538: CALL_OW 488
12542: NOT
12543: IFFALSE 12565
// begin _x := x ;
12545: LD_ADDR_VAR 0 6
12549: PUSH
12550: LD_VAR 0 4
12554: ST_TO_ADDR
// _y := y ;
12555: LD_ADDR_VAR 0 7
12559: PUSH
12560: LD_VAR 0 5
12564: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12565: LD_ADDR_VAR 0 3
12569: PUSH
12570: LD_INT 1
12572: PPUSH
12573: LD_VAR 0 14
12577: PPUSH
12578: CALL_OW 12
12582: ST_TO_ADDR
// case i of 1 :
12583: LD_VAR 0 3
12587: PUSH
12588: LD_INT 1
12590: DOUBLE
12591: EQUAL
12592: IFTRUE 12596
12594: GO 12613
12596: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12597: LD_VAR 0 1
12601: PPUSH
12602: LD_VAR 0 10
12606: PPUSH
12607: CALL_OW 115
12611: GO 12674
12613: LD_INT 2
12615: DOUBLE
12616: EQUAL
12617: IFTRUE 12621
12619: GO 12643
12621: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12622: LD_VAR 0 1
12626: PPUSH
12627: LD_VAR 0 6
12631: PPUSH
12632: LD_VAR 0 7
12636: PPUSH
12637: CALL_OW 153
12641: GO 12674
12643: LD_INT 3
12645: DOUBLE
12646: EQUAL
12647: IFTRUE 12651
12649: GO 12673
12651: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12652: LD_VAR 0 1
12656: PPUSH
12657: LD_VAR 0 6
12661: PPUSH
12662: LD_VAR 0 7
12666: PPUSH
12667: CALL_OW 154
12671: GO 12674
12673: POP
// end ;
12674: LD_VAR 0 2
12678: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12679: LD_INT 0
12681: PPUSH
12682: PPUSH
12683: PPUSH
12684: PPUSH
12685: PPUSH
12686: PPUSH
// if not unit or not building then
12687: LD_VAR 0 1
12691: NOT
12692: PUSH
12693: LD_VAR 0 2
12697: NOT
12698: OR
12699: IFFALSE 12703
// exit ;
12701: GO 12861
// x := GetX ( building ) ;
12703: LD_ADDR_VAR 0 5
12707: PUSH
12708: LD_VAR 0 2
12712: PPUSH
12713: CALL_OW 250
12717: ST_TO_ADDR
// y := GetY ( building ) ;
12718: LD_ADDR_VAR 0 6
12722: PUSH
12723: LD_VAR 0 2
12727: PPUSH
12728: CALL_OW 251
12732: ST_TO_ADDR
// for i = 0 to 5 do
12733: LD_ADDR_VAR 0 4
12737: PUSH
12738: DOUBLE
12739: LD_INT 0
12741: DEC
12742: ST_TO_ADDR
12743: LD_INT 5
12745: PUSH
12746: FOR_TO
12747: IFFALSE 12859
// begin _x := ShiftX ( x , i , 3 ) ;
12749: LD_ADDR_VAR 0 7
12753: PUSH
12754: LD_VAR 0 5
12758: PPUSH
12759: LD_VAR 0 4
12763: PPUSH
12764: LD_INT 3
12766: PPUSH
12767: CALL_OW 272
12771: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12772: LD_ADDR_VAR 0 8
12776: PUSH
12777: LD_VAR 0 6
12781: PPUSH
12782: LD_VAR 0 4
12786: PPUSH
12787: LD_INT 3
12789: PPUSH
12790: CALL_OW 273
12794: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12795: LD_VAR 0 7
12799: PPUSH
12800: LD_VAR 0 8
12804: PPUSH
12805: CALL_OW 488
12809: NOT
12810: IFFALSE 12814
// continue ;
12812: GO 12746
// if HexInfo ( _x , _y ) = 0 then
12814: LD_VAR 0 7
12818: PPUSH
12819: LD_VAR 0 8
12823: PPUSH
12824: CALL_OW 428
12828: PUSH
12829: LD_INT 0
12831: EQUAL
12832: IFFALSE 12857
// begin ComMoveXY ( unit , _x , _y ) ;
12834: LD_VAR 0 1
12838: PPUSH
12839: LD_VAR 0 7
12843: PPUSH
12844: LD_VAR 0 8
12848: PPUSH
12849: CALL_OW 111
// exit ;
12853: POP
12854: POP
12855: GO 12861
// end ; end ;
12857: GO 12746
12859: POP
12860: POP
// end ;
12861: LD_VAR 0 3
12865: RET
// export function ScanBase ( side , base_area ) ; begin
12866: LD_INT 0
12868: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12869: LD_ADDR_VAR 0 3
12873: PUSH
12874: LD_VAR 0 2
12878: PPUSH
12879: LD_INT 81
12881: PUSH
12882: LD_VAR 0 1
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: PPUSH
12891: CALL_OW 70
12895: ST_TO_ADDR
// end ;
12896: LD_VAR 0 3
12900: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12901: LD_INT 0
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// result := false ;
12907: LD_ADDR_VAR 0 2
12911: PUSH
12912: LD_INT 0
12914: ST_TO_ADDR
// side := GetSide ( unit ) ;
12915: LD_ADDR_VAR 0 3
12919: PUSH
12920: LD_VAR 0 1
12924: PPUSH
12925: CALL_OW 255
12929: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12930: LD_ADDR_VAR 0 4
12934: PUSH
12935: LD_VAR 0 1
12939: PPUSH
12940: CALL_OW 248
12944: ST_TO_ADDR
// case nat of 1 :
12945: LD_VAR 0 4
12949: PUSH
12950: LD_INT 1
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12969
12958: POP
// tech := tech_lassight ; 2 :
12959: LD_ADDR_VAR 0 5
12963: PUSH
12964: LD_INT 12
12966: ST_TO_ADDR
12967: GO 13008
12969: LD_INT 2
12971: DOUBLE
12972: EQUAL
12973: IFTRUE 12977
12975: GO 12988
12977: POP
// tech := tech_mortar ; 3 :
12978: LD_ADDR_VAR 0 5
12982: PUSH
12983: LD_INT 41
12985: ST_TO_ADDR
12986: GO 13008
12988: LD_INT 3
12990: DOUBLE
12991: EQUAL
12992: IFTRUE 12996
12994: GO 13007
12996: POP
// tech := tech_bazooka ; end ;
12997: LD_ADDR_VAR 0 5
13001: PUSH
13002: LD_INT 44
13004: ST_TO_ADDR
13005: GO 13008
13007: POP
// if Researched ( side , tech ) then
13008: LD_VAR 0 3
13012: PPUSH
13013: LD_VAR 0 5
13017: PPUSH
13018: CALL_OW 325
13022: IFFALSE 13049
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
13024: LD_ADDR_VAR 0 2
13028: PUSH
13029: LD_INT 5
13031: PUSH
13032: LD_INT 8
13034: PUSH
13035: LD_INT 9
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: LD_VAR 0 4
13047: ARRAY
13048: ST_TO_ADDR
// end ;
13049: LD_VAR 0 2
13053: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
13054: LD_INT 0
13056: PPUSH
13057: PPUSH
13058: PPUSH
// if not mines then
13059: LD_VAR 0 2
13063: NOT
13064: IFFALSE 13068
// exit ;
13066: GO 13212
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_INT 81
13075: PUSH
13076: LD_VAR 0 1
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: LD_INT 21
13090: PUSH
13091: LD_INT 3
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL_OW 69
13110: ST_TO_ADDR
// for i in mines do
13111: LD_ADDR_VAR 0 4
13115: PUSH
13116: LD_VAR 0 2
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13210
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13124: LD_VAR 0 4
13128: PUSH
13129: LD_INT 1
13131: ARRAY
13132: PPUSH
13133: LD_VAR 0 4
13137: PUSH
13138: LD_INT 2
13140: ARRAY
13141: PPUSH
13142: CALL_OW 458
13146: NOT
13147: IFFALSE 13151
// continue ;
13149: GO 13121
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13151: LD_VAR 0 4
13155: PUSH
13156: LD_INT 1
13158: ARRAY
13159: PPUSH
13160: LD_VAR 0 4
13164: PUSH
13165: LD_INT 2
13167: ARRAY
13168: PPUSH
13169: CALL_OW 428
13173: PUSH
13174: LD_VAR 0 5
13178: IN
13179: IFFALSE 13208
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13181: LD_VAR 0 4
13185: PUSH
13186: LD_INT 1
13188: ARRAY
13189: PPUSH
13190: LD_VAR 0 4
13194: PUSH
13195: LD_INT 2
13197: ARRAY
13198: PPUSH
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 456
// end ;
13208: GO 13121
13210: POP
13211: POP
// end ;
13212: LD_VAR 0 3
13216: RET
// export function Count ( array ) ; begin
13217: LD_INT 0
13219: PPUSH
// result := array + 0 ;
13220: LD_ADDR_VAR 0 2
13224: PUSH
13225: LD_VAR 0 1
13229: PUSH
13230: LD_INT 0
13232: PLUS
13233: ST_TO_ADDR
// end ;
13234: LD_VAR 0 2
13238: RET
// export function IsEmpty ( building ) ; begin
13239: LD_INT 0
13241: PPUSH
// if not building then
13242: LD_VAR 0 1
13246: NOT
13247: IFFALSE 13251
// exit ;
13249: GO 13294
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13251: LD_ADDR_VAR 0 2
13255: PUSH
13256: LD_VAR 0 1
13260: PUSH
13261: LD_INT 22
13263: PUSH
13264: LD_VAR 0 1
13268: PPUSH
13269: CALL_OW 255
13273: PUSH
13274: EMPTY
13275: LIST
13276: LIST
13277: PUSH
13278: LD_INT 58
13280: PUSH
13281: EMPTY
13282: LIST
13283: PUSH
13284: EMPTY
13285: LIST
13286: LIST
13287: PPUSH
13288: CALL_OW 69
13292: IN
13293: ST_TO_ADDR
// end ;
13294: LD_VAR 0 2
13298: RET
// export function IsNotFull ( building ) ; var places ; begin
13299: LD_INT 0
13301: PPUSH
13302: PPUSH
// if not building then
13303: LD_VAR 0 1
13307: NOT
13308: IFFALSE 13312
// exit ;
13310: GO 13340
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
13312: LD_ADDR_VAR 0 2
13316: PUSH
13317: LD_VAR 0 1
13321: PPUSH
13322: LD_INT 3
13324: PUSH
13325: LD_INT 62
13327: PUSH
13328: EMPTY
13329: LIST
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PPUSH
13335: CALL_OW 72
13339: ST_TO_ADDR
// end ;
13340: LD_VAR 0 2
13344: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13345: LD_INT 0
13347: PPUSH
13348: PPUSH
13349: PPUSH
13350: PPUSH
// tmp := [ ] ;
13351: LD_ADDR_VAR 0 3
13355: PUSH
13356: EMPTY
13357: ST_TO_ADDR
// list := [ ] ;
13358: LD_ADDR_VAR 0 5
13362: PUSH
13363: EMPTY
13364: ST_TO_ADDR
// for i = 16 to 25 do
13365: LD_ADDR_VAR 0 4
13369: PUSH
13370: DOUBLE
13371: LD_INT 16
13373: DEC
13374: ST_TO_ADDR
13375: LD_INT 25
13377: PUSH
13378: FOR_TO
13379: IFFALSE 13452
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13381: LD_ADDR_VAR 0 3
13385: PUSH
13386: LD_VAR 0 3
13390: PUSH
13391: LD_INT 22
13393: PUSH
13394: LD_VAR 0 1
13398: PPUSH
13399: CALL_OW 255
13403: PUSH
13404: EMPTY
13405: LIST
13406: LIST
13407: PUSH
13408: LD_INT 91
13410: PUSH
13411: LD_VAR 0 1
13415: PUSH
13416: LD_INT 6
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: PUSH
13424: LD_INT 30
13426: PUSH
13427: LD_VAR 0 4
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PUSH
13436: EMPTY
13437: LIST
13438: LIST
13439: LIST
13440: PUSH
13441: EMPTY
13442: LIST
13443: PPUSH
13444: CALL_OW 69
13448: ADD
13449: ST_TO_ADDR
13450: GO 13378
13452: POP
13453: POP
// for i = 1 to tmp do
13454: LD_ADDR_VAR 0 4
13458: PUSH
13459: DOUBLE
13460: LD_INT 1
13462: DEC
13463: ST_TO_ADDR
13464: LD_VAR 0 3
13468: PUSH
13469: FOR_TO
13470: IFFALSE 13558
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13472: LD_ADDR_VAR 0 5
13476: PUSH
13477: LD_VAR 0 5
13481: PUSH
13482: LD_VAR 0 3
13486: PUSH
13487: LD_VAR 0 4
13491: ARRAY
13492: PPUSH
13493: CALL_OW 266
13497: PUSH
13498: LD_VAR 0 3
13502: PUSH
13503: LD_VAR 0 4
13507: ARRAY
13508: PPUSH
13509: CALL_OW 250
13513: PUSH
13514: LD_VAR 0 3
13518: PUSH
13519: LD_VAR 0 4
13523: ARRAY
13524: PPUSH
13525: CALL_OW 251
13529: PUSH
13530: LD_VAR 0 3
13534: PUSH
13535: LD_VAR 0 4
13539: ARRAY
13540: PPUSH
13541: CALL_OW 254
13545: PUSH
13546: EMPTY
13547: LIST
13548: LIST
13549: LIST
13550: LIST
13551: PUSH
13552: EMPTY
13553: LIST
13554: ADD
13555: ST_TO_ADDR
13556: GO 13469
13558: POP
13559: POP
// result := list ;
13560: LD_ADDR_VAR 0 2
13564: PUSH
13565: LD_VAR 0 5
13569: ST_TO_ADDR
// end ;
13570: LD_VAR 0 2
13574: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13575: LD_INT 0
13577: PPUSH
13578: PPUSH
13579: PPUSH
13580: PPUSH
13581: PPUSH
13582: PPUSH
13583: PPUSH
// if not factory then
13584: LD_VAR 0 1
13588: NOT
13589: IFFALSE 13593
// exit ;
13591: GO 14186
// if control = control_apeman then
13593: LD_VAR 0 4
13597: PUSH
13598: LD_INT 5
13600: EQUAL
13601: IFFALSE 13710
// begin tmp := UnitsInside ( factory ) ;
13603: LD_ADDR_VAR 0 8
13607: PUSH
13608: LD_VAR 0 1
13612: PPUSH
13613: CALL_OW 313
13617: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13618: LD_VAR 0 8
13622: PPUSH
13623: LD_INT 25
13625: PUSH
13626: LD_INT 12
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: PPUSH
13633: CALL_OW 72
13637: NOT
13638: IFFALSE 13648
// control := control_manual ;
13640: LD_ADDR_VAR 0 4
13644: PUSH
13645: LD_INT 1
13647: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13648: LD_ADDR_VAR 0 8
13652: PUSH
13653: LD_VAR 0 1
13657: PPUSH
13658: CALL 13345 0 1
13662: ST_TO_ADDR
// if tmp then
13663: LD_VAR 0 8
13667: IFFALSE 13710
// begin for i in tmp do
13669: LD_ADDR_VAR 0 7
13673: PUSH
13674: LD_VAR 0 8
13678: PUSH
13679: FOR_IN
13680: IFFALSE 13708
// if i [ 1 ] = b_ext_radio then
13682: LD_VAR 0 7
13686: PUSH
13687: LD_INT 1
13689: ARRAY
13690: PUSH
13691: LD_INT 22
13693: EQUAL
13694: IFFALSE 13706
// begin control := control_remote ;
13696: LD_ADDR_VAR 0 4
13700: PUSH
13701: LD_INT 2
13703: ST_TO_ADDR
// break ;
13704: GO 13708
// end ;
13706: GO 13679
13708: POP
13709: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13710: LD_VAR 0 1
13714: PPUSH
13715: LD_VAR 0 2
13719: PPUSH
13720: LD_VAR 0 3
13724: PPUSH
13725: LD_VAR 0 4
13729: PPUSH
13730: LD_VAR 0 5
13734: PPUSH
13735: CALL_OW 448
13739: IFFALSE 13774
// begin result := [ chassis , engine , control , weapon ] ;
13741: LD_ADDR_VAR 0 6
13745: PUSH
13746: LD_VAR 0 2
13750: PUSH
13751: LD_VAR 0 3
13755: PUSH
13756: LD_VAR 0 4
13760: PUSH
13761: LD_VAR 0 5
13765: PUSH
13766: EMPTY
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: ST_TO_ADDR
// exit ;
13772: GO 14186
// end ; _chassis := AvailableChassisList ( factory ) ;
13774: LD_ADDR_VAR 0 9
13778: PUSH
13779: LD_VAR 0 1
13783: PPUSH
13784: CALL_OW 475
13788: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13789: LD_ADDR_VAR 0 11
13793: PUSH
13794: LD_VAR 0 1
13798: PPUSH
13799: CALL_OW 476
13803: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13804: LD_ADDR_VAR 0 12
13808: PUSH
13809: LD_VAR 0 1
13813: PPUSH
13814: CALL_OW 477
13818: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13819: LD_ADDR_VAR 0 10
13823: PUSH
13824: LD_VAR 0 1
13828: PPUSH
13829: CALL_OW 478
13833: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13834: LD_VAR 0 9
13838: NOT
13839: PUSH
13840: LD_VAR 0 11
13844: NOT
13845: OR
13846: PUSH
13847: LD_VAR 0 12
13851: NOT
13852: OR
13853: PUSH
13854: LD_VAR 0 10
13858: NOT
13859: OR
13860: IFFALSE 13895
// begin result := [ chassis , engine , control , weapon ] ;
13862: LD_ADDR_VAR 0 6
13866: PUSH
13867: LD_VAR 0 2
13871: PUSH
13872: LD_VAR 0 3
13876: PUSH
13877: LD_VAR 0 4
13881: PUSH
13882: LD_VAR 0 5
13886: PUSH
13887: EMPTY
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: ST_TO_ADDR
// exit ;
13893: GO 14186
// end ; if not chassis in _chassis then
13895: LD_VAR 0 2
13899: PUSH
13900: LD_VAR 0 9
13904: IN
13905: NOT
13906: IFFALSE 13932
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 9
13917: PUSH
13918: LD_INT 1
13920: PPUSH
13921: LD_VAR 0 9
13925: PPUSH
13926: CALL_OW 12
13930: ARRAY
13931: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13932: LD_VAR 0 2
13936: PPUSH
13937: LD_VAR 0 3
13941: PPUSH
13942: CALL 14191 0 2
13946: NOT
13947: IFFALSE 14006
// repeat engine := _engine [ 1 ] ;
13949: LD_ADDR_VAR 0 3
13953: PUSH
13954: LD_VAR 0 11
13958: PUSH
13959: LD_INT 1
13961: ARRAY
13962: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13963: LD_ADDR_VAR 0 11
13967: PUSH
13968: LD_VAR 0 11
13972: PPUSH
13973: LD_INT 1
13975: PPUSH
13976: CALL_OW 3
13980: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13981: LD_VAR 0 2
13985: PPUSH
13986: LD_VAR 0 3
13990: PPUSH
13991: CALL 14191 0 2
13995: PUSH
13996: LD_VAR 0 11
14000: PUSH
14001: EMPTY
14002: EQUAL
14003: OR
14004: IFFALSE 13949
// if not control in _control then
14006: LD_VAR 0 4
14010: PUSH
14011: LD_VAR 0 12
14015: IN
14016: NOT
14017: IFFALSE 14043
// control := _control [ rand ( 1 , _control ) ] ;
14019: LD_ADDR_VAR 0 4
14023: PUSH
14024: LD_VAR 0 12
14028: PUSH
14029: LD_INT 1
14031: PPUSH
14032: LD_VAR 0 12
14036: PPUSH
14037: CALL_OW 12
14041: ARRAY
14042: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14043: LD_VAR 0 2
14047: PPUSH
14048: LD_VAR 0 5
14052: PPUSH
14053: CALL 14411 0 2
14057: NOT
14058: IFFALSE 14117
// repeat weapon := _weapon [ 1 ] ;
14060: LD_ADDR_VAR 0 5
14064: PUSH
14065: LD_VAR 0 10
14069: PUSH
14070: LD_INT 1
14072: ARRAY
14073: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14074: LD_ADDR_VAR 0 10
14078: PUSH
14079: LD_VAR 0 10
14083: PPUSH
14084: LD_INT 1
14086: PPUSH
14087: CALL_OW 3
14091: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14092: LD_VAR 0 2
14096: PPUSH
14097: LD_VAR 0 5
14101: PPUSH
14102: CALL 14411 0 2
14106: PUSH
14107: LD_VAR 0 10
14111: PUSH
14112: EMPTY
14113: EQUAL
14114: OR
14115: IFFALSE 14060
// result := [ ] ;
14117: LD_ADDR_VAR 0 6
14121: PUSH
14122: EMPTY
14123: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14124: LD_VAR 0 1
14128: PPUSH
14129: LD_VAR 0 2
14133: PPUSH
14134: LD_VAR 0 3
14138: PPUSH
14139: LD_VAR 0 4
14143: PPUSH
14144: LD_VAR 0 5
14148: PPUSH
14149: CALL_OW 448
14153: IFFALSE 14186
// result := [ chassis , engine , control , weapon ] ;
14155: LD_ADDR_VAR 0 6
14159: PUSH
14160: LD_VAR 0 2
14164: PUSH
14165: LD_VAR 0 3
14169: PUSH
14170: LD_VAR 0 4
14174: PUSH
14175: LD_VAR 0 5
14179: PUSH
14180: EMPTY
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: ST_TO_ADDR
// end ;
14186: LD_VAR 0 6
14190: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14191: LD_INT 0
14193: PPUSH
// if not chassis or not engine then
14194: LD_VAR 0 1
14198: NOT
14199: PUSH
14200: LD_VAR 0 2
14204: NOT
14205: OR
14206: IFFALSE 14210
// exit ;
14208: GO 14406
// case engine of engine_solar :
14210: LD_VAR 0 2
14214: PUSH
14215: LD_INT 2
14217: DOUBLE
14218: EQUAL
14219: IFTRUE 14223
14221: GO 14261
14223: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14224: LD_ADDR_VAR 0 3
14228: PUSH
14229: LD_INT 11
14231: PUSH
14232: LD_INT 12
14234: PUSH
14235: LD_INT 13
14237: PUSH
14238: LD_INT 14
14240: PUSH
14241: LD_INT 1
14243: PUSH
14244: LD_INT 2
14246: PUSH
14247: LD_INT 3
14249: PUSH
14250: EMPTY
14251: LIST
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: LIST
14257: LIST
14258: ST_TO_ADDR
14259: GO 14390
14261: LD_INT 1
14263: DOUBLE
14264: EQUAL
14265: IFTRUE 14269
14267: GO 14331
14269: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14270: LD_ADDR_VAR 0 3
14274: PUSH
14275: LD_INT 11
14277: PUSH
14278: LD_INT 12
14280: PUSH
14281: LD_INT 13
14283: PUSH
14284: LD_INT 14
14286: PUSH
14287: LD_INT 1
14289: PUSH
14290: LD_INT 2
14292: PUSH
14293: LD_INT 3
14295: PUSH
14296: LD_INT 4
14298: PUSH
14299: LD_INT 5
14301: PUSH
14302: LD_INT 21
14304: PUSH
14305: LD_INT 23
14307: PUSH
14308: LD_INT 22
14310: PUSH
14311: LD_INT 24
14313: PUSH
14314: EMPTY
14315: LIST
14316: LIST
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: ST_TO_ADDR
14329: GO 14390
14331: LD_INT 3
14333: DOUBLE
14334: EQUAL
14335: IFTRUE 14339
14337: GO 14389
14339: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14340: LD_ADDR_VAR 0 3
14344: PUSH
14345: LD_INT 13
14347: PUSH
14348: LD_INT 14
14350: PUSH
14351: LD_INT 2
14353: PUSH
14354: LD_INT 3
14356: PUSH
14357: LD_INT 4
14359: PUSH
14360: LD_INT 5
14362: PUSH
14363: LD_INT 21
14365: PUSH
14366: LD_INT 22
14368: PUSH
14369: LD_INT 23
14371: PUSH
14372: LD_INT 24
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: ST_TO_ADDR
14387: GO 14390
14389: POP
// result := ( chassis in result ) ;
14390: LD_ADDR_VAR 0 3
14394: PUSH
14395: LD_VAR 0 1
14399: PUSH
14400: LD_VAR 0 3
14404: IN
14405: ST_TO_ADDR
// end ;
14406: LD_VAR 0 3
14410: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14411: LD_INT 0
14413: PPUSH
// if not chassis or not weapon then
14414: LD_VAR 0 1
14418: NOT
14419: PUSH
14420: LD_VAR 0 2
14424: NOT
14425: OR
14426: IFFALSE 14430
// exit ;
14428: GO 15490
// case weapon of us_machine_gun :
14430: LD_VAR 0 2
14434: PUSH
14435: LD_INT 2
14437: DOUBLE
14438: EQUAL
14439: IFTRUE 14443
14441: GO 14473
14443: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14444: LD_ADDR_VAR 0 3
14448: PUSH
14449: LD_INT 1
14451: PUSH
14452: LD_INT 2
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: LD_INT 4
14460: PUSH
14461: LD_INT 5
14463: PUSH
14464: EMPTY
14465: LIST
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: ST_TO_ADDR
14471: GO 15474
14473: LD_INT 3
14475: DOUBLE
14476: EQUAL
14477: IFTRUE 14481
14479: GO 14511
14481: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: LD_INT 1
14489: PUSH
14490: LD_INT 2
14492: PUSH
14493: LD_INT 3
14495: PUSH
14496: LD_INT 4
14498: PUSH
14499: LD_INT 5
14501: PUSH
14502: EMPTY
14503: LIST
14504: LIST
14505: LIST
14506: LIST
14507: LIST
14508: ST_TO_ADDR
14509: GO 15474
14511: LD_INT 11
14513: DOUBLE
14514: EQUAL
14515: IFTRUE 14519
14517: GO 14549
14519: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14520: LD_ADDR_VAR 0 3
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: LD_INT 2
14530: PUSH
14531: LD_INT 3
14533: PUSH
14534: LD_INT 4
14536: PUSH
14537: LD_INT 5
14539: PUSH
14540: EMPTY
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: ST_TO_ADDR
14547: GO 15474
14549: LD_INT 4
14551: DOUBLE
14552: EQUAL
14553: IFTRUE 14557
14555: GO 14583
14557: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14558: LD_ADDR_VAR 0 3
14562: PUSH
14563: LD_INT 2
14565: PUSH
14566: LD_INT 3
14568: PUSH
14569: LD_INT 4
14571: PUSH
14572: LD_INT 5
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: ST_TO_ADDR
14581: GO 15474
14583: LD_INT 5
14585: DOUBLE
14586: EQUAL
14587: IFTRUE 14591
14589: GO 14617
14591: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14592: LD_ADDR_VAR 0 3
14596: PUSH
14597: LD_INT 2
14599: PUSH
14600: LD_INT 3
14602: PUSH
14603: LD_INT 4
14605: PUSH
14606: LD_INT 5
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: ST_TO_ADDR
14615: GO 15474
14617: LD_INT 9
14619: DOUBLE
14620: EQUAL
14621: IFTRUE 14625
14623: GO 14651
14625: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14626: LD_ADDR_VAR 0 3
14630: PUSH
14631: LD_INT 2
14633: PUSH
14634: LD_INT 3
14636: PUSH
14637: LD_INT 4
14639: PUSH
14640: LD_INT 5
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: LIST
14647: LIST
14648: ST_TO_ADDR
14649: GO 15474
14651: LD_INT 7
14653: DOUBLE
14654: EQUAL
14655: IFTRUE 14659
14657: GO 14685
14659: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14660: LD_ADDR_VAR 0 3
14664: PUSH
14665: LD_INT 2
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 4
14673: PUSH
14674: LD_INT 5
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: LIST
14681: LIST
14682: ST_TO_ADDR
14683: GO 15474
14685: LD_INT 12
14687: DOUBLE
14688: EQUAL
14689: IFTRUE 14693
14691: GO 14719
14693: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14694: LD_ADDR_VAR 0 3
14698: PUSH
14699: LD_INT 2
14701: PUSH
14702: LD_INT 3
14704: PUSH
14705: LD_INT 4
14707: PUSH
14708: LD_INT 5
14710: PUSH
14711: EMPTY
14712: LIST
14713: LIST
14714: LIST
14715: LIST
14716: ST_TO_ADDR
14717: GO 15474
14719: LD_INT 13
14721: DOUBLE
14722: EQUAL
14723: IFTRUE 14727
14725: GO 14753
14727: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14728: LD_ADDR_VAR 0 3
14732: PUSH
14733: LD_INT 2
14735: PUSH
14736: LD_INT 3
14738: PUSH
14739: LD_INT 4
14741: PUSH
14742: LD_INT 5
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: ST_TO_ADDR
14751: GO 15474
14753: LD_INT 14
14755: DOUBLE
14756: EQUAL
14757: IFTRUE 14761
14759: GO 14779
14761: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14762: LD_ADDR_VAR 0 3
14766: PUSH
14767: LD_INT 4
14769: PUSH
14770: LD_INT 5
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: ST_TO_ADDR
14777: GO 15474
14779: LD_INT 6
14781: DOUBLE
14782: EQUAL
14783: IFTRUE 14787
14785: GO 14805
14787: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14788: LD_ADDR_VAR 0 3
14792: PUSH
14793: LD_INT 4
14795: PUSH
14796: LD_INT 5
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: ST_TO_ADDR
14803: GO 15474
14805: LD_INT 10
14807: DOUBLE
14808: EQUAL
14809: IFTRUE 14813
14811: GO 14831
14813: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14814: LD_ADDR_VAR 0 3
14818: PUSH
14819: LD_INT 4
14821: PUSH
14822: LD_INT 5
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: ST_TO_ADDR
14829: GO 15474
14831: LD_INT 22
14833: DOUBLE
14834: EQUAL
14835: IFTRUE 14839
14837: GO 14865
14839: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14840: LD_ADDR_VAR 0 3
14844: PUSH
14845: LD_INT 11
14847: PUSH
14848: LD_INT 12
14850: PUSH
14851: LD_INT 13
14853: PUSH
14854: LD_INT 14
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: LIST
14861: LIST
14862: ST_TO_ADDR
14863: GO 15474
14865: LD_INT 23
14867: DOUBLE
14868: EQUAL
14869: IFTRUE 14873
14871: GO 14899
14873: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14874: LD_ADDR_VAR 0 3
14878: PUSH
14879: LD_INT 11
14881: PUSH
14882: LD_INT 12
14884: PUSH
14885: LD_INT 13
14887: PUSH
14888: LD_INT 14
14890: PUSH
14891: EMPTY
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: ST_TO_ADDR
14897: GO 15474
14899: LD_INT 24
14901: DOUBLE
14902: EQUAL
14903: IFTRUE 14907
14905: GO 14933
14907: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14908: LD_ADDR_VAR 0 3
14912: PUSH
14913: LD_INT 11
14915: PUSH
14916: LD_INT 12
14918: PUSH
14919: LD_INT 13
14921: PUSH
14922: LD_INT 14
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: LIST
14929: LIST
14930: ST_TO_ADDR
14931: GO 15474
14933: LD_INT 30
14935: DOUBLE
14936: EQUAL
14937: IFTRUE 14941
14939: GO 14967
14941: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14942: LD_ADDR_VAR 0 3
14946: PUSH
14947: LD_INT 11
14949: PUSH
14950: LD_INT 12
14952: PUSH
14953: LD_INT 13
14955: PUSH
14956: LD_INT 14
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: LIST
14963: LIST
14964: ST_TO_ADDR
14965: GO 15474
14967: LD_INT 25
14969: DOUBLE
14970: EQUAL
14971: IFTRUE 14975
14973: GO 14993
14975: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14976: LD_ADDR_VAR 0 3
14980: PUSH
14981: LD_INT 13
14983: PUSH
14984: LD_INT 14
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: ST_TO_ADDR
14991: GO 15474
14993: LD_INT 27
14995: DOUBLE
14996: EQUAL
14997: IFTRUE 15001
14999: GO 15019
15001: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15002: LD_ADDR_VAR 0 3
15006: PUSH
15007: LD_INT 13
15009: PUSH
15010: LD_INT 14
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: ST_TO_ADDR
15017: GO 15474
15019: LD_INT 92
15021: DOUBLE
15022: EQUAL
15023: IFTRUE 15027
15025: GO 15053
15027: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15028: LD_ADDR_VAR 0 3
15032: PUSH
15033: LD_INT 11
15035: PUSH
15036: LD_INT 12
15038: PUSH
15039: LD_INT 13
15041: PUSH
15042: LD_INT 14
15044: PUSH
15045: EMPTY
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: ST_TO_ADDR
15051: GO 15474
15053: LD_INT 28
15055: DOUBLE
15056: EQUAL
15057: IFTRUE 15061
15059: GO 15079
15061: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15062: LD_ADDR_VAR 0 3
15066: PUSH
15067: LD_INT 13
15069: PUSH
15070: LD_INT 14
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: ST_TO_ADDR
15077: GO 15474
15079: LD_INT 29
15081: DOUBLE
15082: EQUAL
15083: IFTRUE 15087
15085: GO 15105
15087: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15088: LD_ADDR_VAR 0 3
15092: PUSH
15093: LD_INT 13
15095: PUSH
15096: LD_INT 14
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: ST_TO_ADDR
15103: GO 15474
15105: LD_INT 31
15107: DOUBLE
15108: EQUAL
15109: IFTRUE 15113
15111: GO 15131
15113: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15114: LD_ADDR_VAR 0 3
15118: PUSH
15119: LD_INT 13
15121: PUSH
15122: LD_INT 14
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: ST_TO_ADDR
15129: GO 15474
15131: LD_INT 26
15133: DOUBLE
15134: EQUAL
15135: IFTRUE 15139
15137: GO 15157
15139: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15140: LD_ADDR_VAR 0 3
15144: PUSH
15145: LD_INT 13
15147: PUSH
15148: LD_INT 14
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: ST_TO_ADDR
15155: GO 15474
15157: LD_INT 42
15159: DOUBLE
15160: EQUAL
15161: IFTRUE 15165
15163: GO 15191
15165: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15166: LD_ADDR_VAR 0 3
15170: PUSH
15171: LD_INT 21
15173: PUSH
15174: LD_INT 22
15176: PUSH
15177: LD_INT 23
15179: PUSH
15180: LD_INT 24
15182: PUSH
15183: EMPTY
15184: LIST
15185: LIST
15186: LIST
15187: LIST
15188: ST_TO_ADDR
15189: GO 15474
15191: LD_INT 43
15193: DOUBLE
15194: EQUAL
15195: IFTRUE 15199
15197: GO 15225
15199: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15200: LD_ADDR_VAR 0 3
15204: PUSH
15205: LD_INT 21
15207: PUSH
15208: LD_INT 22
15210: PUSH
15211: LD_INT 23
15213: PUSH
15214: LD_INT 24
15216: PUSH
15217: EMPTY
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: ST_TO_ADDR
15223: GO 15474
15225: LD_INT 44
15227: DOUBLE
15228: EQUAL
15229: IFTRUE 15233
15231: GO 15259
15233: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15234: LD_ADDR_VAR 0 3
15238: PUSH
15239: LD_INT 21
15241: PUSH
15242: LD_INT 22
15244: PUSH
15245: LD_INT 23
15247: PUSH
15248: LD_INT 24
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: LIST
15255: LIST
15256: ST_TO_ADDR
15257: GO 15474
15259: LD_INT 45
15261: DOUBLE
15262: EQUAL
15263: IFTRUE 15267
15265: GO 15293
15267: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15268: LD_ADDR_VAR 0 3
15272: PUSH
15273: LD_INT 21
15275: PUSH
15276: LD_INT 22
15278: PUSH
15279: LD_INT 23
15281: PUSH
15282: LD_INT 24
15284: PUSH
15285: EMPTY
15286: LIST
15287: LIST
15288: LIST
15289: LIST
15290: ST_TO_ADDR
15291: GO 15474
15293: LD_INT 49
15295: DOUBLE
15296: EQUAL
15297: IFTRUE 15301
15299: GO 15327
15301: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15302: LD_ADDR_VAR 0 3
15306: PUSH
15307: LD_INT 21
15309: PUSH
15310: LD_INT 22
15312: PUSH
15313: LD_INT 23
15315: PUSH
15316: LD_INT 24
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: LIST
15323: LIST
15324: ST_TO_ADDR
15325: GO 15474
15327: LD_INT 51
15329: DOUBLE
15330: EQUAL
15331: IFTRUE 15335
15333: GO 15361
15335: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15336: LD_ADDR_VAR 0 3
15340: PUSH
15341: LD_INT 21
15343: PUSH
15344: LD_INT 22
15346: PUSH
15347: LD_INT 23
15349: PUSH
15350: LD_INT 24
15352: PUSH
15353: EMPTY
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: ST_TO_ADDR
15359: GO 15474
15361: LD_INT 52
15363: DOUBLE
15364: EQUAL
15365: IFTRUE 15369
15367: GO 15395
15369: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15370: LD_ADDR_VAR 0 3
15374: PUSH
15375: LD_INT 21
15377: PUSH
15378: LD_INT 22
15380: PUSH
15381: LD_INT 23
15383: PUSH
15384: LD_INT 24
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: LIST
15391: LIST
15392: ST_TO_ADDR
15393: GO 15474
15395: LD_INT 53
15397: DOUBLE
15398: EQUAL
15399: IFTRUE 15403
15401: GO 15421
15403: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15404: LD_ADDR_VAR 0 3
15408: PUSH
15409: LD_INT 23
15411: PUSH
15412: LD_INT 24
15414: PUSH
15415: EMPTY
15416: LIST
15417: LIST
15418: ST_TO_ADDR
15419: GO 15474
15421: LD_INT 46
15423: DOUBLE
15424: EQUAL
15425: IFTRUE 15429
15427: GO 15447
15429: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15430: LD_ADDR_VAR 0 3
15434: PUSH
15435: LD_INT 23
15437: PUSH
15438: LD_INT 24
15440: PUSH
15441: EMPTY
15442: LIST
15443: LIST
15444: ST_TO_ADDR
15445: GO 15474
15447: LD_INT 47
15449: DOUBLE
15450: EQUAL
15451: IFTRUE 15455
15453: GO 15473
15455: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15456: LD_ADDR_VAR 0 3
15460: PUSH
15461: LD_INT 23
15463: PUSH
15464: LD_INT 24
15466: PUSH
15467: EMPTY
15468: LIST
15469: LIST
15470: ST_TO_ADDR
15471: GO 15474
15473: POP
// result := ( chassis in result ) ;
15474: LD_ADDR_VAR 0 3
15478: PUSH
15479: LD_VAR 0 1
15483: PUSH
15484: LD_VAR 0 3
15488: IN
15489: ST_TO_ADDR
// end ;
15490: LD_VAR 0 3
15494: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15495: LD_INT 0
15497: PPUSH
15498: PPUSH
15499: PPUSH
15500: PPUSH
15501: PPUSH
15502: PPUSH
15503: PPUSH
// result := array ;
15504: LD_ADDR_VAR 0 5
15508: PUSH
15509: LD_VAR 0 1
15513: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15514: LD_VAR 0 1
15518: NOT
15519: PUSH
15520: LD_VAR 0 2
15524: NOT
15525: OR
15526: PUSH
15527: LD_VAR 0 3
15531: NOT
15532: OR
15533: PUSH
15534: LD_VAR 0 2
15538: PUSH
15539: LD_VAR 0 1
15543: GREATER
15544: OR
15545: PUSH
15546: LD_VAR 0 3
15550: PUSH
15551: LD_VAR 0 1
15555: GREATER
15556: OR
15557: IFFALSE 15561
// exit ;
15559: GO 15857
// if direction then
15561: LD_VAR 0 4
15565: IFFALSE 15629
// begin d := 1 ;
15567: LD_ADDR_VAR 0 9
15571: PUSH
15572: LD_INT 1
15574: ST_TO_ADDR
// if i_from > i_to then
15575: LD_VAR 0 2
15579: PUSH
15580: LD_VAR 0 3
15584: GREATER
15585: IFFALSE 15611
// length := ( array - i_from ) + i_to else
15587: LD_ADDR_VAR 0 11
15591: PUSH
15592: LD_VAR 0 1
15596: PUSH
15597: LD_VAR 0 2
15601: MINUS
15602: PUSH
15603: LD_VAR 0 3
15607: PLUS
15608: ST_TO_ADDR
15609: GO 15627
// length := i_to - i_from ;
15611: LD_ADDR_VAR 0 11
15615: PUSH
15616: LD_VAR 0 3
15620: PUSH
15621: LD_VAR 0 2
15625: MINUS
15626: ST_TO_ADDR
// end else
15627: GO 15690
// begin d := - 1 ;
15629: LD_ADDR_VAR 0 9
15633: PUSH
15634: LD_INT 1
15636: NEG
15637: ST_TO_ADDR
// if i_from > i_to then
15638: LD_VAR 0 2
15642: PUSH
15643: LD_VAR 0 3
15647: GREATER
15648: IFFALSE 15668
// length := i_from - i_to else
15650: LD_ADDR_VAR 0 11
15654: PUSH
15655: LD_VAR 0 2
15659: PUSH
15660: LD_VAR 0 3
15664: MINUS
15665: ST_TO_ADDR
15666: GO 15690
// length := ( array - i_to ) + i_from ;
15668: LD_ADDR_VAR 0 11
15672: PUSH
15673: LD_VAR 0 1
15677: PUSH
15678: LD_VAR 0 3
15682: MINUS
15683: PUSH
15684: LD_VAR 0 2
15688: PLUS
15689: ST_TO_ADDR
// end ; if not length then
15690: LD_VAR 0 11
15694: NOT
15695: IFFALSE 15699
// exit ;
15697: GO 15857
// tmp := array ;
15699: LD_ADDR_VAR 0 10
15703: PUSH
15704: LD_VAR 0 1
15708: ST_TO_ADDR
// for i = 1 to length do
15709: LD_ADDR_VAR 0 6
15713: PUSH
15714: DOUBLE
15715: LD_INT 1
15717: DEC
15718: ST_TO_ADDR
15719: LD_VAR 0 11
15723: PUSH
15724: FOR_TO
15725: IFFALSE 15845
// begin for j = 1 to array do
15727: LD_ADDR_VAR 0 7
15731: PUSH
15732: DOUBLE
15733: LD_INT 1
15735: DEC
15736: ST_TO_ADDR
15737: LD_VAR 0 1
15741: PUSH
15742: FOR_TO
15743: IFFALSE 15831
// begin k := j + d ;
15745: LD_ADDR_VAR 0 8
15749: PUSH
15750: LD_VAR 0 7
15754: PUSH
15755: LD_VAR 0 9
15759: PLUS
15760: ST_TO_ADDR
// if k > array then
15761: LD_VAR 0 8
15765: PUSH
15766: LD_VAR 0 1
15770: GREATER
15771: IFFALSE 15781
// k := 1 ;
15773: LD_ADDR_VAR 0 8
15777: PUSH
15778: LD_INT 1
15780: ST_TO_ADDR
// if not k then
15781: LD_VAR 0 8
15785: NOT
15786: IFFALSE 15798
// k := array ;
15788: LD_ADDR_VAR 0 8
15792: PUSH
15793: LD_VAR 0 1
15797: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15798: LD_ADDR_VAR 0 10
15802: PUSH
15803: LD_VAR 0 10
15807: PPUSH
15808: LD_VAR 0 8
15812: PPUSH
15813: LD_VAR 0 1
15817: PUSH
15818: LD_VAR 0 7
15822: ARRAY
15823: PPUSH
15824: CALL_OW 1
15828: ST_TO_ADDR
// end ;
15829: GO 15742
15831: POP
15832: POP
// array := tmp ;
15833: LD_ADDR_VAR 0 1
15837: PUSH
15838: LD_VAR 0 10
15842: ST_TO_ADDR
// end ;
15843: GO 15724
15845: POP
15846: POP
// result := array ;
15847: LD_ADDR_VAR 0 5
15851: PUSH
15852: LD_VAR 0 1
15856: ST_TO_ADDR
// end ;
15857: LD_VAR 0 5
15861: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15862: LD_INT 0
15864: PPUSH
15865: PPUSH
// result := 0 ;
15866: LD_ADDR_VAR 0 3
15870: PUSH
15871: LD_INT 0
15873: ST_TO_ADDR
// if not array or not value in array then
15874: LD_VAR 0 1
15878: NOT
15879: PUSH
15880: LD_VAR 0 2
15884: PUSH
15885: LD_VAR 0 1
15889: IN
15890: NOT
15891: OR
15892: IFFALSE 15896
// exit ;
15894: GO 15950
// for i = 1 to array do
15896: LD_ADDR_VAR 0 4
15900: PUSH
15901: DOUBLE
15902: LD_INT 1
15904: DEC
15905: ST_TO_ADDR
15906: LD_VAR 0 1
15910: PUSH
15911: FOR_TO
15912: IFFALSE 15948
// if value = array [ i ] then
15914: LD_VAR 0 2
15918: PUSH
15919: LD_VAR 0 1
15923: PUSH
15924: LD_VAR 0 4
15928: ARRAY
15929: EQUAL
15930: IFFALSE 15946
// begin result := i ;
15932: LD_ADDR_VAR 0 3
15936: PUSH
15937: LD_VAR 0 4
15941: ST_TO_ADDR
// exit ;
15942: POP
15943: POP
15944: GO 15950
// end ;
15946: GO 15911
15948: POP
15949: POP
// end ;
15950: LD_VAR 0 3
15954: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15955: LD_INT 0
15957: PPUSH
// vc_chassis := chassis ;
15958: LD_ADDR_OWVAR 37
15962: PUSH
15963: LD_VAR 0 1
15967: ST_TO_ADDR
// vc_engine := engine ;
15968: LD_ADDR_OWVAR 39
15972: PUSH
15973: LD_VAR 0 2
15977: ST_TO_ADDR
// vc_control := control ;
15978: LD_ADDR_OWVAR 38
15982: PUSH
15983: LD_VAR 0 3
15987: ST_TO_ADDR
// vc_weapon := weapon ;
15988: LD_ADDR_OWVAR 40
15992: PUSH
15993: LD_VAR 0 4
15997: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15998: LD_ADDR_OWVAR 41
16002: PUSH
16003: LD_VAR 0 5
16007: ST_TO_ADDR
// end ;
16008: LD_VAR 0 6
16012: RET
// export function WantPlant ( unit ) ; var task ; begin
16013: LD_INT 0
16015: PPUSH
16016: PPUSH
// result := false ;
16017: LD_ADDR_VAR 0 2
16021: PUSH
16022: LD_INT 0
16024: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16025: LD_ADDR_VAR 0 3
16029: PUSH
16030: LD_VAR 0 1
16034: PPUSH
16035: CALL_OW 437
16039: ST_TO_ADDR
// if task then
16040: LD_VAR 0 3
16044: IFFALSE 16072
// if task [ 1 ] [ 1 ] = p then
16046: LD_VAR 0 3
16050: PUSH
16051: LD_INT 1
16053: ARRAY
16054: PUSH
16055: LD_INT 1
16057: ARRAY
16058: PUSH
16059: LD_STRING p
16061: EQUAL
16062: IFFALSE 16072
// result := true ;
16064: LD_ADDR_VAR 0 2
16068: PUSH
16069: LD_INT 1
16071: ST_TO_ADDR
// end ;
16072: LD_VAR 0 2
16076: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16077: LD_INT 0
16079: PPUSH
16080: PPUSH
16081: PPUSH
16082: PPUSH
// if pos < 1 then
16083: LD_VAR 0 2
16087: PUSH
16088: LD_INT 1
16090: LESS
16091: IFFALSE 16095
// exit ;
16093: GO 16398
// if pos = 1 then
16095: LD_VAR 0 2
16099: PUSH
16100: LD_INT 1
16102: EQUAL
16103: IFFALSE 16136
// result := Replace ( arr , pos [ 1 ] , value ) else
16105: LD_ADDR_VAR 0 4
16109: PUSH
16110: LD_VAR 0 1
16114: PPUSH
16115: LD_VAR 0 2
16119: PUSH
16120: LD_INT 1
16122: ARRAY
16123: PPUSH
16124: LD_VAR 0 3
16128: PPUSH
16129: CALL_OW 1
16133: ST_TO_ADDR
16134: GO 16398
// begin tmp := arr ;
16136: LD_ADDR_VAR 0 6
16140: PUSH
16141: LD_VAR 0 1
16145: ST_TO_ADDR
// s_arr := [ tmp ] ;
16146: LD_ADDR_VAR 0 7
16150: PUSH
16151: LD_VAR 0 6
16155: PUSH
16156: EMPTY
16157: LIST
16158: ST_TO_ADDR
// for i = 1 to pos - 1 do
16159: LD_ADDR_VAR 0 5
16163: PUSH
16164: DOUBLE
16165: LD_INT 1
16167: DEC
16168: ST_TO_ADDR
16169: LD_VAR 0 2
16173: PUSH
16174: LD_INT 1
16176: MINUS
16177: PUSH
16178: FOR_TO
16179: IFFALSE 16224
// begin tmp := tmp [ pos [ i ] ] ;
16181: LD_ADDR_VAR 0 6
16185: PUSH
16186: LD_VAR 0 6
16190: PUSH
16191: LD_VAR 0 2
16195: PUSH
16196: LD_VAR 0 5
16200: ARRAY
16201: ARRAY
16202: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16203: LD_ADDR_VAR 0 7
16207: PUSH
16208: LD_VAR 0 7
16212: PUSH
16213: LD_VAR 0 6
16217: PUSH
16218: EMPTY
16219: LIST
16220: ADD
16221: ST_TO_ADDR
// end ;
16222: GO 16178
16224: POP
16225: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16226: LD_ADDR_VAR 0 6
16230: PUSH
16231: LD_VAR 0 6
16235: PPUSH
16236: LD_VAR 0 2
16240: PUSH
16241: LD_VAR 0 2
16245: ARRAY
16246: PPUSH
16247: LD_VAR 0 3
16251: PPUSH
16252: CALL_OW 1
16256: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16257: LD_ADDR_VAR 0 7
16261: PUSH
16262: LD_VAR 0 7
16266: PPUSH
16267: LD_VAR 0 7
16271: PPUSH
16272: LD_VAR 0 6
16276: PPUSH
16277: CALL_OW 1
16281: ST_TO_ADDR
// for i = s_arr downto 2 do
16282: LD_ADDR_VAR 0 5
16286: PUSH
16287: DOUBLE
16288: LD_VAR 0 7
16292: INC
16293: ST_TO_ADDR
16294: LD_INT 2
16296: PUSH
16297: FOR_DOWNTO
16298: IFFALSE 16382
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16300: LD_ADDR_VAR 0 6
16304: PUSH
16305: LD_VAR 0 7
16309: PUSH
16310: LD_VAR 0 5
16314: PUSH
16315: LD_INT 1
16317: MINUS
16318: ARRAY
16319: PPUSH
16320: LD_VAR 0 2
16324: PUSH
16325: LD_VAR 0 5
16329: PUSH
16330: LD_INT 1
16332: MINUS
16333: ARRAY
16334: PPUSH
16335: LD_VAR 0 7
16339: PUSH
16340: LD_VAR 0 5
16344: ARRAY
16345: PPUSH
16346: CALL_OW 1
16350: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16351: LD_ADDR_VAR 0 7
16355: PUSH
16356: LD_VAR 0 7
16360: PPUSH
16361: LD_VAR 0 5
16365: PUSH
16366: LD_INT 1
16368: MINUS
16369: PPUSH
16370: LD_VAR 0 6
16374: PPUSH
16375: CALL_OW 1
16379: ST_TO_ADDR
// end ;
16380: GO 16297
16382: POP
16383: POP
// result := s_arr [ 1 ] ;
16384: LD_ADDR_VAR 0 4
16388: PUSH
16389: LD_VAR 0 7
16393: PUSH
16394: LD_INT 1
16396: ARRAY
16397: ST_TO_ADDR
// end ; end ;
16398: LD_VAR 0 4
16402: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16403: LD_INT 0
16405: PPUSH
16406: PPUSH
// if not list then
16407: LD_VAR 0 1
16411: NOT
16412: IFFALSE 16416
// exit ;
16414: GO 16507
// i := list [ pos1 ] ;
16416: LD_ADDR_VAR 0 5
16420: PUSH
16421: LD_VAR 0 1
16425: PUSH
16426: LD_VAR 0 2
16430: ARRAY
16431: ST_TO_ADDR
// if not i then
16432: LD_VAR 0 5
16436: NOT
16437: IFFALSE 16441
// exit ;
16439: GO 16507
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16441: LD_ADDR_VAR 0 1
16445: PUSH
16446: LD_VAR 0 1
16450: PPUSH
16451: LD_VAR 0 2
16455: PPUSH
16456: LD_VAR 0 1
16460: PUSH
16461: LD_VAR 0 3
16465: ARRAY
16466: PPUSH
16467: CALL_OW 1
16471: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16472: LD_ADDR_VAR 0 1
16476: PUSH
16477: LD_VAR 0 1
16481: PPUSH
16482: LD_VAR 0 3
16486: PPUSH
16487: LD_VAR 0 5
16491: PPUSH
16492: CALL_OW 1
16496: ST_TO_ADDR
// result := list ;
16497: LD_ADDR_VAR 0 4
16501: PUSH
16502: LD_VAR 0 1
16506: ST_TO_ADDR
// end ;
16507: LD_VAR 0 4
16511: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16512: LD_INT 0
16514: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16515: LD_ADDR_VAR 0 5
16519: PUSH
16520: LD_VAR 0 1
16524: PPUSH
16525: CALL_OW 250
16529: PPUSH
16530: LD_VAR 0 1
16534: PPUSH
16535: CALL_OW 251
16539: PPUSH
16540: LD_VAR 0 2
16544: PPUSH
16545: LD_VAR 0 3
16549: PPUSH
16550: LD_VAR 0 4
16554: PPUSH
16555: CALL 16565 0 5
16559: ST_TO_ADDR
// end ;
16560: LD_VAR 0 5
16564: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16565: LD_INT 0
16567: PPUSH
16568: PPUSH
16569: PPUSH
16570: PPUSH
// if not list then
16571: LD_VAR 0 3
16575: NOT
16576: IFFALSE 16580
// exit ;
16578: GO 16968
// result := [ ] ;
16580: LD_ADDR_VAR 0 6
16584: PUSH
16585: EMPTY
16586: ST_TO_ADDR
// for i in list do
16587: LD_ADDR_VAR 0 7
16591: PUSH
16592: LD_VAR 0 3
16596: PUSH
16597: FOR_IN
16598: IFFALSE 16800
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16600: LD_ADDR_VAR 0 9
16604: PUSH
16605: LD_VAR 0 7
16609: PPUSH
16610: LD_VAR 0 1
16614: PPUSH
16615: LD_VAR 0 2
16619: PPUSH
16620: CALL_OW 297
16624: ST_TO_ADDR
// if not result then
16625: LD_VAR 0 6
16629: NOT
16630: IFFALSE 16656
// result := [ [ i , tmp ] ] else
16632: LD_ADDR_VAR 0 6
16636: PUSH
16637: LD_VAR 0 7
16641: PUSH
16642: LD_VAR 0 9
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: PUSH
16651: EMPTY
16652: LIST
16653: ST_TO_ADDR
16654: GO 16798
// begin if result [ result ] [ 2 ] < tmp then
16656: LD_VAR 0 6
16660: PUSH
16661: LD_VAR 0 6
16665: ARRAY
16666: PUSH
16667: LD_INT 2
16669: ARRAY
16670: PUSH
16671: LD_VAR 0 9
16675: LESS
16676: IFFALSE 16718
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16678: LD_ADDR_VAR 0 6
16682: PUSH
16683: LD_VAR 0 6
16687: PPUSH
16688: LD_VAR 0 6
16692: PUSH
16693: LD_INT 1
16695: PLUS
16696: PPUSH
16697: LD_VAR 0 7
16701: PUSH
16702: LD_VAR 0 9
16706: PUSH
16707: EMPTY
16708: LIST
16709: LIST
16710: PPUSH
16711: CALL_OW 2
16715: ST_TO_ADDR
16716: GO 16798
// for j = 1 to result do
16718: LD_ADDR_VAR 0 8
16722: PUSH
16723: DOUBLE
16724: LD_INT 1
16726: DEC
16727: ST_TO_ADDR
16728: LD_VAR 0 6
16732: PUSH
16733: FOR_TO
16734: IFFALSE 16796
// begin if tmp < result [ j ] [ 2 ] then
16736: LD_VAR 0 9
16740: PUSH
16741: LD_VAR 0 6
16745: PUSH
16746: LD_VAR 0 8
16750: ARRAY
16751: PUSH
16752: LD_INT 2
16754: ARRAY
16755: LESS
16756: IFFALSE 16794
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16758: LD_ADDR_VAR 0 6
16762: PUSH
16763: LD_VAR 0 6
16767: PPUSH
16768: LD_VAR 0 8
16772: PPUSH
16773: LD_VAR 0 7
16777: PUSH
16778: LD_VAR 0 9
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PPUSH
16787: CALL_OW 2
16791: ST_TO_ADDR
// break ;
16792: GO 16796
// end ; end ;
16794: GO 16733
16796: POP
16797: POP
// end ; end ;
16798: GO 16597
16800: POP
16801: POP
// if result and not asc then
16802: LD_VAR 0 6
16806: PUSH
16807: LD_VAR 0 4
16811: NOT
16812: AND
16813: IFFALSE 16888
// begin tmp := result ;
16815: LD_ADDR_VAR 0 9
16819: PUSH
16820: LD_VAR 0 6
16824: ST_TO_ADDR
// for i = tmp downto 1 do
16825: LD_ADDR_VAR 0 7
16829: PUSH
16830: DOUBLE
16831: LD_VAR 0 9
16835: INC
16836: ST_TO_ADDR
16837: LD_INT 1
16839: PUSH
16840: FOR_DOWNTO
16841: IFFALSE 16886
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16843: LD_ADDR_VAR 0 6
16847: PUSH
16848: LD_VAR 0 6
16852: PPUSH
16853: LD_VAR 0 9
16857: PUSH
16858: LD_VAR 0 7
16862: MINUS
16863: PUSH
16864: LD_INT 1
16866: PLUS
16867: PPUSH
16868: LD_VAR 0 9
16872: PUSH
16873: LD_VAR 0 7
16877: ARRAY
16878: PPUSH
16879: CALL_OW 1
16883: ST_TO_ADDR
16884: GO 16840
16886: POP
16887: POP
// end ; tmp := [ ] ;
16888: LD_ADDR_VAR 0 9
16892: PUSH
16893: EMPTY
16894: ST_TO_ADDR
// if mode then
16895: LD_VAR 0 5
16899: IFFALSE 16968
// begin for i = 1 to result do
16901: LD_ADDR_VAR 0 7
16905: PUSH
16906: DOUBLE
16907: LD_INT 1
16909: DEC
16910: ST_TO_ADDR
16911: LD_VAR 0 6
16915: PUSH
16916: FOR_TO
16917: IFFALSE 16956
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16919: LD_ADDR_VAR 0 9
16923: PUSH
16924: LD_VAR 0 9
16928: PPUSH
16929: LD_VAR 0 7
16933: PPUSH
16934: LD_VAR 0 6
16938: PUSH
16939: LD_VAR 0 7
16943: ARRAY
16944: PUSH
16945: LD_INT 1
16947: ARRAY
16948: PPUSH
16949: CALL_OW 1
16953: ST_TO_ADDR
16954: GO 16916
16956: POP
16957: POP
// result := tmp ;
16958: LD_ADDR_VAR 0 6
16962: PUSH
16963: LD_VAR 0 9
16967: ST_TO_ADDR
// end ; end ;
16968: LD_VAR 0 6
16972: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
16973: LD_INT 0
16975: PPUSH
16976: PPUSH
16977: PPUSH
16978: PPUSH
16979: PPUSH
16980: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
16981: LD_ADDR_VAR 0 5
16985: PUSH
16986: LD_INT 0
16988: PUSH
16989: LD_INT 0
16991: PUSH
16992: LD_INT 0
16994: PUSH
16995: EMPTY
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: ST_TO_ADDR
// if not x or not y then
17003: LD_VAR 0 2
17007: NOT
17008: PUSH
17009: LD_VAR 0 3
17013: NOT
17014: OR
17015: IFFALSE 17019
// exit ;
17017: GO 18669
// if not range then
17019: LD_VAR 0 4
17023: NOT
17024: IFFALSE 17034
// range := 10 ;
17026: LD_ADDR_VAR 0 4
17030: PUSH
17031: LD_INT 10
17033: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17034: LD_ADDR_VAR 0 8
17038: PUSH
17039: LD_INT 81
17041: PUSH
17042: LD_VAR 0 1
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PUSH
17051: LD_INT 92
17053: PUSH
17054: LD_VAR 0 2
17058: PUSH
17059: LD_VAR 0 3
17063: PUSH
17064: LD_VAR 0 4
17068: PUSH
17069: EMPTY
17070: LIST
17071: LIST
17072: LIST
17073: LIST
17074: PUSH
17075: LD_INT 3
17077: PUSH
17078: LD_INT 21
17080: PUSH
17081: LD_INT 3
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: LIST
17096: PPUSH
17097: CALL_OW 69
17101: ST_TO_ADDR
// if not tmp then
17102: LD_VAR 0 8
17106: NOT
17107: IFFALSE 17111
// exit ;
17109: GO 18669
// for i in tmp do
17111: LD_ADDR_VAR 0 6
17115: PUSH
17116: LD_VAR 0 8
17120: PUSH
17121: FOR_IN
17122: IFFALSE 18644
// begin points := [ 0 , 0 , 0 ] ;
17124: LD_ADDR_VAR 0 9
17128: PUSH
17129: LD_INT 0
17131: PUSH
17132: LD_INT 0
17134: PUSH
17135: LD_INT 0
17137: PUSH
17138: EMPTY
17139: LIST
17140: LIST
17141: LIST
17142: ST_TO_ADDR
// bpoints := 1 ;
17143: LD_ADDR_VAR 0 10
17147: PUSH
17148: LD_INT 1
17150: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17151: LD_VAR 0 6
17155: PPUSH
17156: CALL_OW 247
17160: PUSH
17161: LD_INT 1
17163: DOUBLE
17164: EQUAL
17165: IFTRUE 17169
17167: GO 17747
17169: POP
// begin if GetClass ( i ) = 1 then
17170: LD_VAR 0 6
17174: PPUSH
17175: CALL_OW 257
17179: PUSH
17180: LD_INT 1
17182: EQUAL
17183: IFFALSE 17204
// points := [ 10 , 5 , 3 ] ;
17185: LD_ADDR_VAR 0 9
17189: PUSH
17190: LD_INT 10
17192: PUSH
17193: LD_INT 5
17195: PUSH
17196: LD_INT 3
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: LIST
17203: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17204: LD_VAR 0 6
17208: PPUSH
17209: CALL_OW 257
17213: PUSH
17214: LD_INT 2
17216: PUSH
17217: LD_INT 3
17219: PUSH
17220: LD_INT 4
17222: PUSH
17223: EMPTY
17224: LIST
17225: LIST
17226: LIST
17227: IN
17228: IFFALSE 17249
// points := [ 3 , 2 , 1 ] ;
17230: LD_ADDR_VAR 0 9
17234: PUSH
17235: LD_INT 3
17237: PUSH
17238: LD_INT 2
17240: PUSH
17241: LD_INT 1
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: LIST
17248: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17249: LD_VAR 0 6
17253: PPUSH
17254: CALL_OW 257
17258: PUSH
17259: LD_INT 5
17261: EQUAL
17262: IFFALSE 17283
// points := [ 130 , 5 , 2 ] ;
17264: LD_ADDR_VAR 0 9
17268: PUSH
17269: LD_INT 130
17271: PUSH
17272: LD_INT 5
17274: PUSH
17275: LD_INT 2
17277: PUSH
17278: EMPTY
17279: LIST
17280: LIST
17281: LIST
17282: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17283: LD_VAR 0 6
17287: PPUSH
17288: CALL_OW 257
17292: PUSH
17293: LD_INT 8
17295: EQUAL
17296: IFFALSE 17317
// points := [ 35 , 35 , 30 ] ;
17298: LD_ADDR_VAR 0 9
17302: PUSH
17303: LD_INT 35
17305: PUSH
17306: LD_INT 35
17308: PUSH
17309: LD_INT 30
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: LIST
17316: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17317: LD_VAR 0 6
17321: PPUSH
17322: CALL_OW 257
17326: PUSH
17327: LD_INT 9
17329: EQUAL
17330: IFFALSE 17351
// points := [ 20 , 55 , 40 ] ;
17332: LD_ADDR_VAR 0 9
17336: PUSH
17337: LD_INT 20
17339: PUSH
17340: LD_INT 55
17342: PUSH
17343: LD_INT 40
17345: PUSH
17346: EMPTY
17347: LIST
17348: LIST
17349: LIST
17350: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17351: LD_VAR 0 6
17355: PPUSH
17356: CALL_OW 257
17360: PUSH
17361: LD_INT 12
17363: PUSH
17364: LD_INT 16
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: IN
17371: IFFALSE 17392
// points := [ 5 , 3 , 2 ] ;
17373: LD_ADDR_VAR 0 9
17377: PUSH
17378: LD_INT 5
17380: PUSH
17381: LD_INT 3
17383: PUSH
17384: LD_INT 2
17386: PUSH
17387: EMPTY
17388: LIST
17389: LIST
17390: LIST
17391: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17392: LD_VAR 0 6
17396: PPUSH
17397: CALL_OW 257
17401: PUSH
17402: LD_INT 17
17404: EQUAL
17405: IFFALSE 17426
// points := [ 100 , 50 , 75 ] ;
17407: LD_ADDR_VAR 0 9
17411: PUSH
17412: LD_INT 100
17414: PUSH
17415: LD_INT 50
17417: PUSH
17418: LD_INT 75
17420: PUSH
17421: EMPTY
17422: LIST
17423: LIST
17424: LIST
17425: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17426: LD_VAR 0 6
17430: PPUSH
17431: CALL_OW 257
17435: PUSH
17436: LD_INT 15
17438: EQUAL
17439: IFFALSE 17460
// points := [ 10 , 5 , 3 ] ;
17441: LD_ADDR_VAR 0 9
17445: PUSH
17446: LD_INT 10
17448: PUSH
17449: LD_INT 5
17451: PUSH
17452: LD_INT 3
17454: PUSH
17455: EMPTY
17456: LIST
17457: LIST
17458: LIST
17459: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17460: LD_VAR 0 6
17464: PPUSH
17465: CALL_OW 257
17469: PUSH
17470: LD_INT 14
17472: EQUAL
17473: IFFALSE 17494
// points := [ 10 , 0 , 0 ] ;
17475: LD_ADDR_VAR 0 9
17479: PUSH
17480: LD_INT 10
17482: PUSH
17483: LD_INT 0
17485: PUSH
17486: LD_INT 0
17488: PUSH
17489: EMPTY
17490: LIST
17491: LIST
17492: LIST
17493: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17494: LD_VAR 0 6
17498: PPUSH
17499: CALL_OW 257
17503: PUSH
17504: LD_INT 11
17506: EQUAL
17507: IFFALSE 17528
// points := [ 30 , 10 , 5 ] ;
17509: LD_ADDR_VAR 0 9
17513: PUSH
17514: LD_INT 30
17516: PUSH
17517: LD_INT 10
17519: PUSH
17520: LD_INT 5
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: LIST
17527: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17528: LD_VAR 0 1
17532: PPUSH
17533: LD_INT 5
17535: PPUSH
17536: CALL_OW 321
17540: PUSH
17541: LD_INT 2
17543: EQUAL
17544: IFFALSE 17561
// bpoints := bpoints * 1.8 ;
17546: LD_ADDR_VAR 0 10
17550: PUSH
17551: LD_VAR 0 10
17555: PUSH
17556: LD_REAL  1.80000000000000E+0000
17559: MUL
17560: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17561: LD_VAR 0 6
17565: PPUSH
17566: CALL_OW 257
17570: PUSH
17571: LD_INT 1
17573: PUSH
17574: LD_INT 2
17576: PUSH
17577: LD_INT 3
17579: PUSH
17580: LD_INT 4
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: IN
17589: PUSH
17590: LD_VAR 0 1
17594: PPUSH
17595: LD_INT 51
17597: PPUSH
17598: CALL_OW 321
17602: PUSH
17603: LD_INT 2
17605: EQUAL
17606: AND
17607: IFFALSE 17624
// bpoints := bpoints * 1.2 ;
17609: LD_ADDR_VAR 0 10
17613: PUSH
17614: LD_VAR 0 10
17618: PUSH
17619: LD_REAL  1.20000000000000E+0000
17622: MUL
17623: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17624: LD_VAR 0 6
17628: PPUSH
17629: CALL_OW 257
17633: PUSH
17634: LD_INT 5
17636: PUSH
17637: LD_INT 7
17639: PUSH
17640: LD_INT 9
17642: PUSH
17643: EMPTY
17644: LIST
17645: LIST
17646: LIST
17647: IN
17648: PUSH
17649: LD_VAR 0 1
17653: PPUSH
17654: LD_INT 52
17656: PPUSH
17657: CALL_OW 321
17661: PUSH
17662: LD_INT 2
17664: EQUAL
17665: AND
17666: IFFALSE 17683
// bpoints := bpoints * 1.5 ;
17668: LD_ADDR_VAR 0 10
17672: PUSH
17673: LD_VAR 0 10
17677: PUSH
17678: LD_REAL  1.50000000000000E+0000
17681: MUL
17682: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17683: LD_VAR 0 1
17687: PPUSH
17688: LD_INT 66
17690: PPUSH
17691: CALL_OW 321
17695: PUSH
17696: LD_INT 2
17698: EQUAL
17699: IFFALSE 17716
// bpoints := bpoints * 1.1 ;
17701: LD_ADDR_VAR 0 10
17705: PUSH
17706: LD_VAR 0 10
17710: PUSH
17711: LD_REAL  1.10000000000000E+0000
17714: MUL
17715: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17716: LD_ADDR_VAR 0 10
17720: PUSH
17721: LD_VAR 0 10
17725: PUSH
17726: LD_VAR 0 6
17730: PPUSH
17731: LD_INT 1
17733: PPUSH
17734: CALL_OW 259
17738: PUSH
17739: LD_REAL  1.15000000000000E+0000
17742: MUL
17743: MUL
17744: ST_TO_ADDR
// end ; unit_vehicle :
17745: GO 18573
17747: LD_INT 2
17749: DOUBLE
17750: EQUAL
17751: IFTRUE 17755
17753: GO 18561
17755: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17756: LD_VAR 0 6
17760: PPUSH
17761: CALL_OW 264
17765: PUSH
17766: LD_INT 2
17768: PUSH
17769: LD_INT 42
17771: PUSH
17772: LD_INT 24
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: LIST
17779: IN
17780: IFFALSE 17801
// points := [ 25 , 5 , 3 ] ;
17782: LD_ADDR_VAR 0 9
17786: PUSH
17787: LD_INT 25
17789: PUSH
17790: LD_INT 5
17792: PUSH
17793: LD_INT 3
17795: PUSH
17796: EMPTY
17797: LIST
17798: LIST
17799: LIST
17800: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17801: LD_VAR 0 6
17805: PPUSH
17806: CALL_OW 264
17810: PUSH
17811: LD_INT 4
17813: PUSH
17814: LD_INT 43
17816: PUSH
17817: LD_INT 25
17819: PUSH
17820: EMPTY
17821: LIST
17822: LIST
17823: LIST
17824: IN
17825: IFFALSE 17846
// points := [ 40 , 15 , 5 ] ;
17827: LD_ADDR_VAR 0 9
17831: PUSH
17832: LD_INT 40
17834: PUSH
17835: LD_INT 15
17837: PUSH
17838: LD_INT 5
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: LIST
17845: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17846: LD_VAR 0 6
17850: PPUSH
17851: CALL_OW 264
17855: PUSH
17856: LD_INT 3
17858: PUSH
17859: LD_INT 23
17861: PUSH
17862: EMPTY
17863: LIST
17864: LIST
17865: IN
17866: IFFALSE 17887
// points := [ 7 , 25 , 8 ] ;
17868: LD_ADDR_VAR 0 9
17872: PUSH
17873: LD_INT 7
17875: PUSH
17876: LD_INT 25
17878: PUSH
17879: LD_INT 8
17881: PUSH
17882: EMPTY
17883: LIST
17884: LIST
17885: LIST
17886: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17887: LD_VAR 0 6
17891: PPUSH
17892: CALL_OW 264
17896: PUSH
17897: LD_INT 5
17899: PUSH
17900: LD_INT 27
17902: PUSH
17903: LD_INT 44
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: LIST
17910: IN
17911: IFFALSE 17932
// points := [ 14 , 50 , 16 ] ;
17913: LD_ADDR_VAR 0 9
17917: PUSH
17918: LD_INT 14
17920: PUSH
17921: LD_INT 50
17923: PUSH
17924: LD_INT 16
17926: PUSH
17927: EMPTY
17928: LIST
17929: LIST
17930: LIST
17931: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17932: LD_VAR 0 6
17936: PPUSH
17937: CALL_OW 264
17941: PUSH
17942: LD_INT 6
17944: PUSH
17945: LD_INT 46
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: IN
17952: IFFALSE 17973
// points := [ 32 , 120 , 70 ] ;
17954: LD_ADDR_VAR 0 9
17958: PUSH
17959: LD_INT 32
17961: PUSH
17962: LD_INT 120
17964: PUSH
17965: LD_INT 70
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: LIST
17972: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
17973: LD_VAR 0 6
17977: PPUSH
17978: CALL_OW 264
17982: PUSH
17983: LD_INT 7
17985: PUSH
17986: LD_INT 28
17988: PUSH
17989: LD_INT 45
17991: PUSH
17992: LD_INT 92
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: IN
18001: IFFALSE 18022
// points := [ 35 , 20 , 45 ] ;
18003: LD_ADDR_VAR 0 9
18007: PUSH
18008: LD_INT 35
18010: PUSH
18011: LD_INT 20
18013: PUSH
18014: LD_INT 45
18016: PUSH
18017: EMPTY
18018: LIST
18019: LIST
18020: LIST
18021: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18022: LD_VAR 0 6
18026: PPUSH
18027: CALL_OW 264
18031: PUSH
18032: LD_INT 47
18034: PUSH
18035: EMPTY
18036: LIST
18037: IN
18038: IFFALSE 18059
// points := [ 67 , 45 , 75 ] ;
18040: LD_ADDR_VAR 0 9
18044: PUSH
18045: LD_INT 67
18047: PUSH
18048: LD_INT 45
18050: PUSH
18051: LD_INT 75
18053: PUSH
18054: EMPTY
18055: LIST
18056: LIST
18057: LIST
18058: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18059: LD_VAR 0 6
18063: PPUSH
18064: CALL_OW 264
18068: PUSH
18069: LD_INT 26
18071: PUSH
18072: EMPTY
18073: LIST
18074: IN
18075: IFFALSE 18096
// points := [ 120 , 30 , 80 ] ;
18077: LD_ADDR_VAR 0 9
18081: PUSH
18082: LD_INT 120
18084: PUSH
18085: LD_INT 30
18087: PUSH
18088: LD_INT 80
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: LIST
18095: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18096: LD_VAR 0 6
18100: PPUSH
18101: CALL_OW 264
18105: PUSH
18106: LD_INT 22
18108: PUSH
18109: EMPTY
18110: LIST
18111: IN
18112: IFFALSE 18133
// points := [ 40 , 1 , 1 ] ;
18114: LD_ADDR_VAR 0 9
18118: PUSH
18119: LD_INT 40
18121: PUSH
18122: LD_INT 1
18124: PUSH
18125: LD_INT 1
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: LIST
18132: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18133: LD_VAR 0 6
18137: PPUSH
18138: CALL_OW 264
18142: PUSH
18143: LD_INT 29
18145: PUSH
18146: EMPTY
18147: LIST
18148: IN
18149: IFFALSE 18170
// points := [ 70 , 200 , 400 ] ;
18151: LD_ADDR_VAR 0 9
18155: PUSH
18156: LD_INT 70
18158: PUSH
18159: LD_INT 200
18161: PUSH
18162: LD_INT 400
18164: PUSH
18165: EMPTY
18166: LIST
18167: LIST
18168: LIST
18169: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18170: LD_VAR 0 6
18174: PPUSH
18175: CALL_OW 264
18179: PUSH
18180: LD_INT 14
18182: PUSH
18183: LD_INT 53
18185: PUSH
18186: EMPTY
18187: LIST
18188: LIST
18189: IN
18190: IFFALSE 18211
// points := [ 40 , 10 , 20 ] ;
18192: LD_ADDR_VAR 0 9
18196: PUSH
18197: LD_INT 40
18199: PUSH
18200: LD_INT 10
18202: PUSH
18203: LD_INT 20
18205: PUSH
18206: EMPTY
18207: LIST
18208: LIST
18209: LIST
18210: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18211: LD_VAR 0 6
18215: PPUSH
18216: CALL_OW 264
18220: PUSH
18221: LD_INT 9
18223: PUSH
18224: EMPTY
18225: LIST
18226: IN
18227: IFFALSE 18248
// points := [ 5 , 70 , 20 ] ;
18229: LD_ADDR_VAR 0 9
18233: PUSH
18234: LD_INT 5
18236: PUSH
18237: LD_INT 70
18239: PUSH
18240: LD_INT 20
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: LIST
18247: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18248: LD_VAR 0 6
18252: PPUSH
18253: CALL_OW 264
18257: PUSH
18258: LD_INT 10
18260: PUSH
18261: EMPTY
18262: LIST
18263: IN
18264: IFFALSE 18285
// points := [ 35 , 110 , 70 ] ;
18266: LD_ADDR_VAR 0 9
18270: PUSH
18271: LD_INT 35
18273: PUSH
18274: LD_INT 110
18276: PUSH
18277: LD_INT 70
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: LIST
18284: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18285: LD_VAR 0 6
18289: PPUSH
18290: CALL_OW 265
18294: PUSH
18295: LD_INT 25
18297: EQUAL
18298: IFFALSE 18319
// points := [ 80 , 65 , 100 ] ;
18300: LD_ADDR_VAR 0 9
18304: PUSH
18305: LD_INT 80
18307: PUSH
18308: LD_INT 65
18310: PUSH
18311: LD_INT 100
18313: PUSH
18314: EMPTY
18315: LIST
18316: LIST
18317: LIST
18318: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18319: LD_VAR 0 6
18323: PPUSH
18324: CALL_OW 263
18328: PUSH
18329: LD_INT 1
18331: EQUAL
18332: IFFALSE 18367
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18334: LD_ADDR_VAR 0 10
18338: PUSH
18339: LD_VAR 0 10
18343: PUSH
18344: LD_VAR 0 6
18348: PPUSH
18349: CALL_OW 311
18353: PPUSH
18354: LD_INT 3
18356: PPUSH
18357: CALL_OW 259
18361: PUSH
18362: LD_INT 4
18364: MUL
18365: MUL
18366: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18367: LD_VAR 0 6
18371: PPUSH
18372: CALL_OW 263
18376: PUSH
18377: LD_INT 2
18379: EQUAL
18380: IFFALSE 18431
// begin j := IsControledBy ( i ) ;
18382: LD_ADDR_VAR 0 7
18386: PUSH
18387: LD_VAR 0 6
18391: PPUSH
18392: CALL_OW 312
18396: ST_TO_ADDR
// if j then
18397: LD_VAR 0 7
18401: IFFALSE 18431
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18403: LD_ADDR_VAR 0 10
18407: PUSH
18408: LD_VAR 0 10
18412: PUSH
18413: LD_VAR 0 7
18417: PPUSH
18418: LD_INT 3
18420: PPUSH
18421: CALL_OW 259
18425: PUSH
18426: LD_INT 3
18428: MUL
18429: MUL
18430: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18431: LD_VAR 0 6
18435: PPUSH
18436: CALL_OW 264
18440: PUSH
18441: LD_INT 5
18443: PUSH
18444: LD_INT 6
18446: PUSH
18447: LD_INT 46
18449: PUSH
18450: LD_INT 44
18452: PUSH
18453: LD_INT 47
18455: PUSH
18456: LD_INT 45
18458: PUSH
18459: LD_INT 28
18461: PUSH
18462: LD_INT 7
18464: PUSH
18465: LD_INT 27
18467: PUSH
18468: LD_INT 29
18470: PUSH
18471: EMPTY
18472: LIST
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: LIST
18478: LIST
18479: LIST
18480: LIST
18481: LIST
18482: IN
18483: PUSH
18484: LD_VAR 0 1
18488: PPUSH
18489: LD_INT 52
18491: PPUSH
18492: CALL_OW 321
18496: PUSH
18497: LD_INT 2
18499: EQUAL
18500: AND
18501: IFFALSE 18518
// bpoints := bpoints * 1.2 ;
18503: LD_ADDR_VAR 0 10
18507: PUSH
18508: LD_VAR 0 10
18512: PUSH
18513: LD_REAL  1.20000000000000E+0000
18516: MUL
18517: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18518: LD_VAR 0 6
18522: PPUSH
18523: CALL_OW 264
18527: PUSH
18528: LD_INT 6
18530: PUSH
18531: LD_INT 46
18533: PUSH
18534: LD_INT 47
18536: PUSH
18537: EMPTY
18538: LIST
18539: LIST
18540: LIST
18541: IN
18542: IFFALSE 18559
// bpoints := bpoints * 1.2 ;
18544: LD_ADDR_VAR 0 10
18548: PUSH
18549: LD_VAR 0 10
18553: PUSH
18554: LD_REAL  1.20000000000000E+0000
18557: MUL
18558: ST_TO_ADDR
// end ; unit_building :
18559: GO 18573
18561: LD_INT 3
18563: DOUBLE
18564: EQUAL
18565: IFTRUE 18569
18567: GO 18572
18569: POP
// ; end ;
18570: GO 18573
18572: POP
// for j = 1 to 3 do
18573: LD_ADDR_VAR 0 7
18577: PUSH
18578: DOUBLE
18579: LD_INT 1
18581: DEC
18582: ST_TO_ADDR
18583: LD_INT 3
18585: PUSH
18586: FOR_TO
18587: IFFALSE 18640
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18589: LD_ADDR_VAR 0 5
18593: PUSH
18594: LD_VAR 0 5
18598: PPUSH
18599: LD_VAR 0 7
18603: PPUSH
18604: LD_VAR 0 5
18608: PUSH
18609: LD_VAR 0 7
18613: ARRAY
18614: PUSH
18615: LD_VAR 0 9
18619: PUSH
18620: LD_VAR 0 7
18624: ARRAY
18625: PUSH
18626: LD_VAR 0 10
18630: MUL
18631: PLUS
18632: PPUSH
18633: CALL_OW 1
18637: ST_TO_ADDR
18638: GO 18586
18640: POP
18641: POP
// end ;
18642: GO 17121
18644: POP
18645: POP
// result := Replace ( result , 4 , tmp ) ;
18646: LD_ADDR_VAR 0 5
18650: PUSH
18651: LD_VAR 0 5
18655: PPUSH
18656: LD_INT 4
18658: PPUSH
18659: LD_VAR 0 8
18663: PPUSH
18664: CALL_OW 1
18668: ST_TO_ADDR
// end ;
18669: LD_VAR 0 5
18673: RET
// export function DangerAtRange ( unit , range ) ; begin
18674: LD_INT 0
18676: PPUSH
// if not unit then
18677: LD_VAR 0 1
18681: NOT
18682: IFFALSE 18686
// exit ;
18684: GO 18731
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18686: LD_ADDR_VAR 0 3
18690: PUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: CALL_OW 255
18700: PPUSH
18701: LD_VAR 0 1
18705: PPUSH
18706: CALL_OW 250
18710: PPUSH
18711: LD_VAR 0 1
18715: PPUSH
18716: CALL_OW 251
18720: PPUSH
18721: LD_VAR 0 2
18725: PPUSH
18726: CALL 16973 0 4
18730: ST_TO_ADDR
// end ;
18731: LD_VAR 0 3
18735: RET
// export function DangerInArea ( side , area ) ; begin
18736: LD_INT 0
18738: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18739: LD_ADDR_VAR 0 3
18743: PUSH
18744: LD_VAR 0 2
18748: PPUSH
18749: LD_INT 81
18751: PUSH
18752: LD_VAR 0 1
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: PPUSH
18761: CALL_OW 70
18765: ST_TO_ADDR
// end ;
18766: LD_VAR 0 3
18770: RET
// export function IsExtension ( b ) ; begin
18771: LD_INT 0
18773: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18774: LD_ADDR_VAR 0 2
18778: PUSH
18779: LD_VAR 0 1
18783: PUSH
18784: LD_INT 23
18786: PUSH
18787: LD_INT 20
18789: PUSH
18790: LD_INT 22
18792: PUSH
18793: LD_INT 17
18795: PUSH
18796: LD_INT 24
18798: PUSH
18799: LD_INT 21
18801: PUSH
18802: LD_INT 19
18804: PUSH
18805: LD_INT 16
18807: PUSH
18808: LD_INT 25
18810: PUSH
18811: LD_INT 18
18813: PUSH
18814: EMPTY
18815: LIST
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: IN
18826: ST_TO_ADDR
// end ;
18827: LD_VAR 0 2
18831: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18832: LD_INT 0
18834: PPUSH
18835: PPUSH
18836: PPUSH
// result := [ ] ;
18837: LD_ADDR_VAR 0 4
18841: PUSH
18842: EMPTY
18843: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18844: LD_ADDR_VAR 0 5
18848: PUSH
18849: LD_VAR 0 2
18853: PPUSH
18854: LD_INT 21
18856: PUSH
18857: LD_INT 3
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PPUSH
18864: CALL_OW 70
18868: ST_TO_ADDR
// if not tmp then
18869: LD_VAR 0 5
18873: NOT
18874: IFFALSE 18878
// exit ;
18876: GO 18942
// if checkLink then
18878: LD_VAR 0 3
18882: IFFALSE 18932
// begin for i in tmp do
18884: LD_ADDR_VAR 0 6
18888: PUSH
18889: LD_VAR 0 5
18893: PUSH
18894: FOR_IN
18895: IFFALSE 18930
// if GetBase ( i ) <> base then
18897: LD_VAR 0 6
18901: PPUSH
18902: CALL_OW 274
18906: PUSH
18907: LD_VAR 0 1
18911: NONEQUAL
18912: IFFALSE 18928
// ComLinkToBase ( base , i ) ;
18914: LD_VAR 0 1
18918: PPUSH
18919: LD_VAR 0 6
18923: PPUSH
18924: CALL_OW 169
18928: GO 18894
18930: POP
18931: POP
// end ; result := tmp ;
18932: LD_ADDR_VAR 0 4
18936: PUSH
18937: LD_VAR 0 5
18941: ST_TO_ADDR
// end ;
18942: LD_VAR 0 4
18946: RET
// export function ComComplete ( units , b ) ; var i ; begin
18947: LD_INT 0
18949: PPUSH
18950: PPUSH
// if not units then
18951: LD_VAR 0 1
18955: NOT
18956: IFFALSE 18960
// exit ;
18958: GO 19050
// for i in units do
18960: LD_ADDR_VAR 0 4
18964: PUSH
18965: LD_VAR 0 1
18969: PUSH
18970: FOR_IN
18971: IFFALSE 19048
// if BuildingStatus ( b ) = bs_build then
18973: LD_VAR 0 2
18977: PPUSH
18978: CALL_OW 461
18982: PUSH
18983: LD_INT 1
18985: EQUAL
18986: IFFALSE 19046
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
18988: LD_VAR 0 4
18992: PPUSH
18993: LD_STRING h
18995: PUSH
18996: LD_VAR 0 2
19000: PPUSH
19001: CALL_OW 250
19005: PUSH
19006: LD_VAR 0 2
19010: PPUSH
19011: CALL_OW 251
19015: PUSH
19016: LD_VAR 0 2
19020: PUSH
19021: LD_INT 0
19023: PUSH
19024: LD_INT 0
19026: PUSH
19027: LD_INT 0
19029: PUSH
19030: EMPTY
19031: LIST
19032: LIST
19033: LIST
19034: LIST
19035: LIST
19036: LIST
19037: LIST
19038: PUSH
19039: EMPTY
19040: LIST
19041: PPUSH
19042: CALL_OW 446
19046: GO 18970
19048: POP
19049: POP
// end ;
19050: LD_VAR 0 3
19054: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19055: LD_INT 0
19057: PPUSH
19058: PPUSH
19059: PPUSH
19060: PPUSH
19061: PPUSH
19062: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19063: LD_VAR 0 1
19067: NOT
19068: PUSH
19069: LD_VAR 0 1
19073: PPUSH
19074: CALL_OW 263
19078: PUSH
19079: LD_INT 2
19081: NONEQUAL
19082: OR
19083: IFFALSE 19087
// exit ;
19085: GO 19403
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19087: LD_ADDR_VAR 0 6
19091: PUSH
19092: LD_INT 22
19094: PUSH
19095: LD_VAR 0 1
19099: PPUSH
19100: CALL_OW 255
19104: PUSH
19105: EMPTY
19106: LIST
19107: LIST
19108: PUSH
19109: LD_INT 2
19111: PUSH
19112: LD_INT 30
19114: PUSH
19115: LD_INT 36
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: PUSH
19122: LD_INT 34
19124: PUSH
19125: LD_INT 31
19127: PUSH
19128: EMPTY
19129: LIST
19130: LIST
19131: PUSH
19132: EMPTY
19133: LIST
19134: LIST
19135: LIST
19136: PUSH
19137: EMPTY
19138: LIST
19139: LIST
19140: PPUSH
19141: CALL_OW 69
19145: ST_TO_ADDR
// if not tmp then
19146: LD_VAR 0 6
19150: NOT
19151: IFFALSE 19155
// exit ;
19153: GO 19403
// result := [ ] ;
19155: LD_ADDR_VAR 0 2
19159: PUSH
19160: EMPTY
19161: ST_TO_ADDR
// for i in tmp do
19162: LD_ADDR_VAR 0 3
19166: PUSH
19167: LD_VAR 0 6
19171: PUSH
19172: FOR_IN
19173: IFFALSE 19244
// begin t := UnitsInside ( i ) ;
19175: LD_ADDR_VAR 0 4
19179: PUSH
19180: LD_VAR 0 3
19184: PPUSH
19185: CALL_OW 313
19189: ST_TO_ADDR
// if t then
19190: LD_VAR 0 4
19194: IFFALSE 19242
// for j in t do
19196: LD_ADDR_VAR 0 7
19200: PUSH
19201: LD_VAR 0 4
19205: PUSH
19206: FOR_IN
19207: IFFALSE 19240
// result := Replace ( result , result + 1 , j ) ;
19209: LD_ADDR_VAR 0 2
19213: PUSH
19214: LD_VAR 0 2
19218: PPUSH
19219: LD_VAR 0 2
19223: PUSH
19224: LD_INT 1
19226: PLUS
19227: PPUSH
19228: LD_VAR 0 7
19232: PPUSH
19233: CALL_OW 1
19237: ST_TO_ADDR
19238: GO 19206
19240: POP
19241: POP
// end ;
19242: GO 19172
19244: POP
19245: POP
// if not result then
19246: LD_VAR 0 2
19250: NOT
19251: IFFALSE 19255
// exit ;
19253: GO 19403
// mech := result [ 1 ] ;
19255: LD_ADDR_VAR 0 5
19259: PUSH
19260: LD_VAR 0 2
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: ST_TO_ADDR
// if result > 1 then
19269: LD_VAR 0 2
19273: PUSH
19274: LD_INT 1
19276: GREATER
19277: IFFALSE 19389
// begin for i = 2 to result do
19279: LD_ADDR_VAR 0 3
19283: PUSH
19284: DOUBLE
19285: LD_INT 2
19287: DEC
19288: ST_TO_ADDR
19289: LD_VAR 0 2
19293: PUSH
19294: FOR_TO
19295: IFFALSE 19387
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19297: LD_ADDR_VAR 0 4
19301: PUSH
19302: LD_VAR 0 2
19306: PUSH
19307: LD_VAR 0 3
19311: ARRAY
19312: PPUSH
19313: LD_INT 3
19315: PPUSH
19316: CALL_OW 259
19320: PUSH
19321: LD_VAR 0 2
19325: PUSH
19326: LD_VAR 0 3
19330: ARRAY
19331: PPUSH
19332: CALL_OW 432
19336: MINUS
19337: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19338: LD_VAR 0 4
19342: PUSH
19343: LD_VAR 0 5
19347: PPUSH
19348: LD_INT 3
19350: PPUSH
19351: CALL_OW 259
19355: PUSH
19356: LD_VAR 0 5
19360: PPUSH
19361: CALL_OW 432
19365: MINUS
19366: GREATEREQUAL
19367: IFFALSE 19385
// mech := result [ i ] ;
19369: LD_ADDR_VAR 0 5
19373: PUSH
19374: LD_VAR 0 2
19378: PUSH
19379: LD_VAR 0 3
19383: ARRAY
19384: ST_TO_ADDR
// end ;
19385: GO 19294
19387: POP
19388: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19389: LD_VAR 0 1
19393: PPUSH
19394: LD_VAR 0 5
19398: PPUSH
19399: CALL_OW 135
// end ;
19403: LD_VAR 0 2
19407: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19408: LD_INT 0
19410: PPUSH
19411: PPUSH
19412: PPUSH
19413: PPUSH
19414: PPUSH
19415: PPUSH
19416: PPUSH
19417: PPUSH
19418: PPUSH
19419: PPUSH
19420: PPUSH
19421: PPUSH
19422: PPUSH
// result := [ ] ;
19423: LD_ADDR_VAR 0 7
19427: PUSH
19428: EMPTY
19429: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19430: LD_VAR 0 1
19434: PPUSH
19435: CALL_OW 266
19439: PUSH
19440: LD_INT 0
19442: PUSH
19443: LD_INT 1
19445: PUSH
19446: EMPTY
19447: LIST
19448: LIST
19449: IN
19450: NOT
19451: IFFALSE 19455
// exit ;
19453: GO 21089
// if name then
19455: LD_VAR 0 3
19459: IFFALSE 19475
// SetBName ( base_dep , name ) ;
19461: LD_VAR 0 1
19465: PPUSH
19466: LD_VAR 0 3
19470: PPUSH
19471: CALL_OW 500
// base := GetBase ( base_dep ) ;
19475: LD_ADDR_VAR 0 15
19479: PUSH
19480: LD_VAR 0 1
19484: PPUSH
19485: CALL_OW 274
19489: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19490: LD_ADDR_VAR 0 16
19494: PUSH
19495: LD_VAR 0 1
19499: PPUSH
19500: CALL_OW 255
19504: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19505: LD_ADDR_VAR 0 17
19509: PUSH
19510: LD_VAR 0 1
19514: PPUSH
19515: CALL_OW 248
19519: ST_TO_ADDR
// if sources then
19520: LD_VAR 0 5
19524: IFFALSE 19571
// for i = 1 to 3 do
19526: LD_ADDR_VAR 0 8
19530: PUSH
19531: DOUBLE
19532: LD_INT 1
19534: DEC
19535: ST_TO_ADDR
19536: LD_INT 3
19538: PUSH
19539: FOR_TO
19540: IFFALSE 19569
// AddResourceType ( base , i , sources [ i ] ) ;
19542: LD_VAR 0 15
19546: PPUSH
19547: LD_VAR 0 8
19551: PPUSH
19552: LD_VAR 0 5
19556: PUSH
19557: LD_VAR 0 8
19561: ARRAY
19562: PPUSH
19563: CALL_OW 276
19567: GO 19539
19569: POP
19570: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19571: LD_ADDR_VAR 0 18
19575: PUSH
19576: LD_VAR 0 15
19580: PPUSH
19581: LD_VAR 0 2
19585: PPUSH
19586: LD_INT 1
19588: PPUSH
19589: CALL 18832 0 3
19593: ST_TO_ADDR
// InitHc ;
19594: CALL_OW 19
// InitUc ;
19598: CALL_OW 18
// uc_side := side ;
19602: LD_ADDR_OWVAR 20
19606: PUSH
19607: LD_VAR 0 16
19611: ST_TO_ADDR
// uc_nation := nation ;
19612: LD_ADDR_OWVAR 21
19616: PUSH
19617: LD_VAR 0 17
19621: ST_TO_ADDR
// if buildings then
19622: LD_VAR 0 18
19626: IFFALSE 20948
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19628: LD_ADDR_VAR 0 19
19632: PUSH
19633: LD_VAR 0 18
19637: PPUSH
19638: LD_INT 2
19640: PUSH
19641: LD_INT 30
19643: PUSH
19644: LD_INT 29
19646: PUSH
19647: EMPTY
19648: LIST
19649: LIST
19650: PUSH
19651: LD_INT 30
19653: PUSH
19654: LD_INT 30
19656: PUSH
19657: EMPTY
19658: LIST
19659: LIST
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: LIST
19665: PPUSH
19666: CALL_OW 72
19670: ST_TO_ADDR
// if tmp then
19671: LD_VAR 0 19
19675: IFFALSE 19723
// for i in tmp do
19677: LD_ADDR_VAR 0 8
19681: PUSH
19682: LD_VAR 0 19
19686: PUSH
19687: FOR_IN
19688: IFFALSE 19721
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19690: LD_VAR 0 8
19694: PPUSH
19695: CALL_OW 250
19699: PPUSH
19700: LD_VAR 0 8
19704: PPUSH
19705: CALL_OW 251
19709: PPUSH
19710: LD_VAR 0 16
19714: PPUSH
19715: CALL_OW 441
19719: GO 19687
19721: POP
19722: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19723: LD_VAR 0 18
19727: PPUSH
19728: LD_INT 2
19730: PUSH
19731: LD_INT 30
19733: PUSH
19734: LD_INT 32
19736: PUSH
19737: EMPTY
19738: LIST
19739: LIST
19740: PUSH
19741: LD_INT 30
19743: PUSH
19744: LD_INT 33
19746: PUSH
19747: EMPTY
19748: LIST
19749: LIST
19750: PUSH
19751: EMPTY
19752: LIST
19753: LIST
19754: LIST
19755: PPUSH
19756: CALL_OW 72
19760: IFFALSE 19848
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19762: LD_ADDR_VAR 0 8
19766: PUSH
19767: LD_VAR 0 18
19771: PPUSH
19772: LD_INT 2
19774: PUSH
19775: LD_INT 30
19777: PUSH
19778: LD_INT 32
19780: PUSH
19781: EMPTY
19782: LIST
19783: LIST
19784: PUSH
19785: LD_INT 30
19787: PUSH
19788: LD_INT 33
19790: PUSH
19791: EMPTY
19792: LIST
19793: LIST
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: LIST
19799: PPUSH
19800: CALL_OW 72
19804: PUSH
19805: FOR_IN
19806: IFFALSE 19846
// begin if not GetBWeapon ( i ) then
19808: LD_VAR 0 8
19812: PPUSH
19813: CALL_OW 269
19817: NOT
19818: IFFALSE 19844
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19820: LD_VAR 0 8
19824: PPUSH
19825: LD_VAR 0 8
19829: PPUSH
19830: LD_VAR 0 2
19834: PPUSH
19835: CALL 21094 0 2
19839: PPUSH
19840: CALL_OW 431
// end ;
19844: GO 19805
19846: POP
19847: POP
// end ; for i = 1 to personel do
19848: LD_ADDR_VAR 0 8
19852: PUSH
19853: DOUBLE
19854: LD_INT 1
19856: DEC
19857: ST_TO_ADDR
19858: LD_VAR 0 6
19862: PUSH
19863: FOR_TO
19864: IFFALSE 20928
// begin if i > 4 then
19866: LD_VAR 0 8
19870: PUSH
19871: LD_INT 4
19873: GREATER
19874: IFFALSE 19878
// break ;
19876: GO 20928
// case i of 1 :
19878: LD_VAR 0 8
19882: PUSH
19883: LD_INT 1
19885: DOUBLE
19886: EQUAL
19887: IFTRUE 19891
19889: GO 19971
19891: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19892: LD_ADDR_VAR 0 12
19896: PUSH
19897: LD_VAR 0 18
19901: PPUSH
19902: LD_INT 22
19904: PUSH
19905: LD_VAR 0 16
19909: PUSH
19910: EMPTY
19911: LIST
19912: LIST
19913: PUSH
19914: LD_INT 58
19916: PUSH
19917: EMPTY
19918: LIST
19919: PUSH
19920: LD_INT 2
19922: PUSH
19923: LD_INT 30
19925: PUSH
19926: LD_INT 32
19928: PUSH
19929: EMPTY
19930: LIST
19931: LIST
19932: PUSH
19933: LD_INT 30
19935: PUSH
19936: LD_INT 4
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: PUSH
19943: LD_INT 30
19945: PUSH
19946: LD_INT 5
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: LIST
19957: LIST
19958: PUSH
19959: EMPTY
19960: LIST
19961: LIST
19962: LIST
19963: PPUSH
19964: CALL_OW 72
19968: ST_TO_ADDR
19969: GO 20193
19971: LD_INT 2
19973: DOUBLE
19974: EQUAL
19975: IFTRUE 19979
19977: GO 20041
19979: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
19980: LD_ADDR_VAR 0 12
19984: PUSH
19985: LD_VAR 0 18
19989: PPUSH
19990: LD_INT 22
19992: PUSH
19993: LD_VAR 0 16
19997: PUSH
19998: EMPTY
19999: LIST
20000: LIST
20001: PUSH
20002: LD_INT 2
20004: PUSH
20005: LD_INT 30
20007: PUSH
20008: LD_INT 0
20010: PUSH
20011: EMPTY
20012: LIST
20013: LIST
20014: PUSH
20015: LD_INT 30
20017: PUSH
20018: LD_INT 1
20020: PUSH
20021: EMPTY
20022: LIST
20023: LIST
20024: PUSH
20025: EMPTY
20026: LIST
20027: LIST
20028: LIST
20029: PUSH
20030: EMPTY
20031: LIST
20032: LIST
20033: PPUSH
20034: CALL_OW 72
20038: ST_TO_ADDR
20039: GO 20193
20041: LD_INT 3
20043: DOUBLE
20044: EQUAL
20045: IFTRUE 20049
20047: GO 20111
20049: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20050: LD_ADDR_VAR 0 12
20054: PUSH
20055: LD_VAR 0 18
20059: PPUSH
20060: LD_INT 22
20062: PUSH
20063: LD_VAR 0 16
20067: PUSH
20068: EMPTY
20069: LIST
20070: LIST
20071: PUSH
20072: LD_INT 2
20074: PUSH
20075: LD_INT 30
20077: PUSH
20078: LD_INT 2
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: PUSH
20085: LD_INT 30
20087: PUSH
20088: LD_INT 3
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: LIST
20099: PUSH
20100: EMPTY
20101: LIST
20102: LIST
20103: PPUSH
20104: CALL_OW 72
20108: ST_TO_ADDR
20109: GO 20193
20111: LD_INT 4
20113: DOUBLE
20114: EQUAL
20115: IFTRUE 20119
20117: GO 20192
20119: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20120: LD_ADDR_VAR 0 12
20124: PUSH
20125: LD_VAR 0 18
20129: PPUSH
20130: LD_INT 22
20132: PUSH
20133: LD_VAR 0 16
20137: PUSH
20138: EMPTY
20139: LIST
20140: LIST
20141: PUSH
20142: LD_INT 2
20144: PUSH
20145: LD_INT 30
20147: PUSH
20148: LD_INT 6
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: PUSH
20155: LD_INT 30
20157: PUSH
20158: LD_INT 7
20160: PUSH
20161: EMPTY
20162: LIST
20163: LIST
20164: PUSH
20165: LD_INT 30
20167: PUSH
20168: LD_INT 8
20170: PUSH
20171: EMPTY
20172: LIST
20173: LIST
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: LIST
20179: LIST
20180: PUSH
20181: EMPTY
20182: LIST
20183: LIST
20184: PPUSH
20185: CALL_OW 72
20189: ST_TO_ADDR
20190: GO 20193
20192: POP
// if i = 1 then
20193: LD_VAR 0 8
20197: PUSH
20198: LD_INT 1
20200: EQUAL
20201: IFFALSE 20312
// begin tmp := [ ] ;
20203: LD_ADDR_VAR 0 19
20207: PUSH
20208: EMPTY
20209: ST_TO_ADDR
// for j in f do
20210: LD_ADDR_VAR 0 9
20214: PUSH
20215: LD_VAR 0 12
20219: PUSH
20220: FOR_IN
20221: IFFALSE 20294
// if GetBType ( j ) = b_bunker then
20223: LD_VAR 0 9
20227: PPUSH
20228: CALL_OW 266
20232: PUSH
20233: LD_INT 32
20235: EQUAL
20236: IFFALSE 20263
// tmp := Insert ( tmp , 1 , j ) else
20238: LD_ADDR_VAR 0 19
20242: PUSH
20243: LD_VAR 0 19
20247: PPUSH
20248: LD_INT 1
20250: PPUSH
20251: LD_VAR 0 9
20255: PPUSH
20256: CALL_OW 2
20260: ST_TO_ADDR
20261: GO 20292
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20263: LD_ADDR_VAR 0 19
20267: PUSH
20268: LD_VAR 0 19
20272: PPUSH
20273: LD_VAR 0 19
20277: PUSH
20278: LD_INT 1
20280: PLUS
20281: PPUSH
20282: LD_VAR 0 9
20286: PPUSH
20287: CALL_OW 2
20291: ST_TO_ADDR
20292: GO 20220
20294: POP
20295: POP
// if tmp then
20296: LD_VAR 0 19
20300: IFFALSE 20312
// f := tmp ;
20302: LD_ADDR_VAR 0 12
20306: PUSH
20307: LD_VAR 0 19
20311: ST_TO_ADDR
// end ; x := personel [ i ] ;
20312: LD_ADDR_VAR 0 13
20316: PUSH
20317: LD_VAR 0 6
20321: PUSH
20322: LD_VAR 0 8
20326: ARRAY
20327: ST_TO_ADDR
// if x = - 1 then
20328: LD_VAR 0 13
20332: PUSH
20333: LD_INT 1
20335: NEG
20336: EQUAL
20337: IFFALSE 20546
// begin for j in f do
20339: LD_ADDR_VAR 0 9
20343: PUSH
20344: LD_VAR 0 12
20348: PUSH
20349: FOR_IN
20350: IFFALSE 20542
// repeat InitHc ;
20352: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20356: LD_VAR 0 9
20360: PPUSH
20361: CALL_OW 266
20365: PUSH
20366: LD_INT 5
20368: EQUAL
20369: IFFALSE 20439
// begin if UnitsInside ( j ) < 3 then
20371: LD_VAR 0 9
20375: PPUSH
20376: CALL_OW 313
20380: PUSH
20381: LD_INT 3
20383: LESS
20384: IFFALSE 20420
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20386: LD_INT 0
20388: PPUSH
20389: LD_INT 5
20391: PUSH
20392: LD_INT 8
20394: PUSH
20395: LD_INT 9
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: LIST
20402: PUSH
20403: LD_VAR 0 17
20407: ARRAY
20408: PPUSH
20409: LD_VAR 0 4
20413: PPUSH
20414: CALL_OW 380
20418: GO 20437
// PrepareHuman ( false , i , skill ) ;
20420: LD_INT 0
20422: PPUSH
20423: LD_VAR 0 8
20427: PPUSH
20428: LD_VAR 0 4
20432: PPUSH
20433: CALL_OW 380
// end else
20437: GO 20456
// PrepareHuman ( false , i , skill ) ;
20439: LD_INT 0
20441: PPUSH
20442: LD_VAR 0 8
20446: PPUSH
20447: LD_VAR 0 4
20451: PPUSH
20452: CALL_OW 380
// un := CreateHuman ;
20456: LD_ADDR_VAR 0 14
20460: PUSH
20461: CALL_OW 44
20465: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20466: LD_ADDR_VAR 0 7
20470: PUSH
20471: LD_VAR 0 7
20475: PPUSH
20476: LD_INT 1
20478: PPUSH
20479: LD_VAR 0 14
20483: PPUSH
20484: CALL_OW 2
20488: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20489: LD_VAR 0 14
20493: PPUSH
20494: LD_VAR 0 9
20498: PPUSH
20499: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20503: LD_VAR 0 9
20507: PPUSH
20508: CALL_OW 313
20512: PUSH
20513: LD_INT 6
20515: EQUAL
20516: PUSH
20517: LD_VAR 0 9
20521: PPUSH
20522: CALL_OW 266
20526: PUSH
20527: LD_INT 32
20529: PUSH
20530: LD_INT 31
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: IN
20537: OR
20538: IFFALSE 20352
20540: GO 20349
20542: POP
20543: POP
// end else
20544: GO 20926
// for j = 1 to x do
20546: LD_ADDR_VAR 0 9
20550: PUSH
20551: DOUBLE
20552: LD_INT 1
20554: DEC
20555: ST_TO_ADDR
20556: LD_VAR 0 13
20560: PUSH
20561: FOR_TO
20562: IFFALSE 20924
// begin InitHc ;
20564: CALL_OW 19
// if not f then
20568: LD_VAR 0 12
20572: NOT
20573: IFFALSE 20662
// begin PrepareHuman ( false , i , skill ) ;
20575: LD_INT 0
20577: PPUSH
20578: LD_VAR 0 8
20582: PPUSH
20583: LD_VAR 0 4
20587: PPUSH
20588: CALL_OW 380
// un := CreateHuman ;
20592: LD_ADDR_VAR 0 14
20596: PUSH
20597: CALL_OW 44
20601: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20602: LD_ADDR_VAR 0 7
20606: PUSH
20607: LD_VAR 0 7
20611: PPUSH
20612: LD_INT 1
20614: PPUSH
20615: LD_VAR 0 14
20619: PPUSH
20620: CALL_OW 2
20624: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20625: LD_VAR 0 14
20629: PPUSH
20630: LD_VAR 0 1
20634: PPUSH
20635: CALL_OW 250
20639: PPUSH
20640: LD_VAR 0 1
20644: PPUSH
20645: CALL_OW 251
20649: PPUSH
20650: LD_INT 10
20652: PPUSH
20653: LD_INT 0
20655: PPUSH
20656: CALL_OW 50
// continue ;
20660: GO 20561
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20662: LD_VAR 0 12
20666: PUSH
20667: LD_INT 1
20669: ARRAY
20670: PPUSH
20671: CALL_OW 313
20675: PUSH
20676: LD_VAR 0 12
20680: PUSH
20681: LD_INT 1
20683: ARRAY
20684: PPUSH
20685: CALL_OW 266
20689: PUSH
20690: LD_INT 32
20692: PUSH
20693: LD_INT 31
20695: PUSH
20696: EMPTY
20697: LIST
20698: LIST
20699: IN
20700: AND
20701: PUSH
20702: LD_VAR 0 12
20706: PUSH
20707: LD_INT 1
20709: ARRAY
20710: PPUSH
20711: CALL_OW 313
20715: PUSH
20716: LD_INT 6
20718: EQUAL
20719: OR
20720: IFFALSE 20740
// f := Delete ( f , 1 ) ;
20722: LD_ADDR_VAR 0 12
20726: PUSH
20727: LD_VAR 0 12
20731: PPUSH
20732: LD_INT 1
20734: PPUSH
20735: CALL_OW 3
20739: ST_TO_ADDR
// if not f then
20740: LD_VAR 0 12
20744: NOT
20745: IFFALSE 20763
// begin x := x + 2 ;
20747: LD_ADDR_VAR 0 13
20751: PUSH
20752: LD_VAR 0 13
20756: PUSH
20757: LD_INT 2
20759: PLUS
20760: ST_TO_ADDR
// continue ;
20761: GO 20561
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20763: LD_VAR 0 12
20767: PUSH
20768: LD_INT 1
20770: ARRAY
20771: PPUSH
20772: CALL_OW 266
20776: PUSH
20777: LD_INT 5
20779: EQUAL
20780: IFFALSE 20854
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20782: LD_VAR 0 12
20786: PUSH
20787: LD_INT 1
20789: ARRAY
20790: PPUSH
20791: CALL_OW 313
20795: PUSH
20796: LD_INT 3
20798: LESS
20799: IFFALSE 20835
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20801: LD_INT 0
20803: PPUSH
20804: LD_INT 5
20806: PUSH
20807: LD_INT 8
20809: PUSH
20810: LD_INT 9
20812: PUSH
20813: EMPTY
20814: LIST
20815: LIST
20816: LIST
20817: PUSH
20818: LD_VAR 0 17
20822: ARRAY
20823: PPUSH
20824: LD_VAR 0 4
20828: PPUSH
20829: CALL_OW 380
20833: GO 20852
// PrepareHuman ( false , i , skill ) ;
20835: LD_INT 0
20837: PPUSH
20838: LD_VAR 0 8
20842: PPUSH
20843: LD_VAR 0 4
20847: PPUSH
20848: CALL_OW 380
// end else
20852: GO 20871
// PrepareHuman ( false , i , skill ) ;
20854: LD_INT 0
20856: PPUSH
20857: LD_VAR 0 8
20861: PPUSH
20862: LD_VAR 0 4
20866: PPUSH
20867: CALL_OW 380
// un := CreateHuman ;
20871: LD_ADDR_VAR 0 14
20875: PUSH
20876: CALL_OW 44
20880: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20881: LD_ADDR_VAR 0 7
20885: PUSH
20886: LD_VAR 0 7
20890: PPUSH
20891: LD_INT 1
20893: PPUSH
20894: LD_VAR 0 14
20898: PPUSH
20899: CALL_OW 2
20903: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20904: LD_VAR 0 14
20908: PPUSH
20909: LD_VAR 0 12
20913: PUSH
20914: LD_INT 1
20916: ARRAY
20917: PPUSH
20918: CALL_OW 52
// end ;
20922: GO 20561
20924: POP
20925: POP
// end ;
20926: GO 19863
20928: POP
20929: POP
// result := result ^ buildings ;
20930: LD_ADDR_VAR 0 7
20934: PUSH
20935: LD_VAR 0 7
20939: PUSH
20940: LD_VAR 0 18
20944: ADD
20945: ST_TO_ADDR
// end else
20946: GO 21089
// begin for i = 1 to personel do
20948: LD_ADDR_VAR 0 8
20952: PUSH
20953: DOUBLE
20954: LD_INT 1
20956: DEC
20957: ST_TO_ADDR
20958: LD_VAR 0 6
20962: PUSH
20963: FOR_TO
20964: IFFALSE 21087
// begin if i > 4 then
20966: LD_VAR 0 8
20970: PUSH
20971: LD_INT 4
20973: GREATER
20974: IFFALSE 20978
// break ;
20976: GO 21087
// x := personel [ i ] ;
20978: LD_ADDR_VAR 0 13
20982: PUSH
20983: LD_VAR 0 6
20987: PUSH
20988: LD_VAR 0 8
20992: ARRAY
20993: ST_TO_ADDR
// if x = - 1 then
20994: LD_VAR 0 13
20998: PUSH
20999: LD_INT 1
21001: NEG
21002: EQUAL
21003: IFFALSE 21007
// continue ;
21005: GO 20963
// PrepareHuman ( false , i , skill ) ;
21007: LD_INT 0
21009: PPUSH
21010: LD_VAR 0 8
21014: PPUSH
21015: LD_VAR 0 4
21019: PPUSH
21020: CALL_OW 380
// un := CreateHuman ;
21024: LD_ADDR_VAR 0 14
21028: PUSH
21029: CALL_OW 44
21033: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21034: LD_VAR 0 14
21038: PPUSH
21039: LD_VAR 0 1
21043: PPUSH
21044: CALL_OW 250
21048: PPUSH
21049: LD_VAR 0 1
21053: PPUSH
21054: CALL_OW 251
21058: PPUSH
21059: LD_INT 10
21061: PPUSH
21062: LD_INT 0
21064: PPUSH
21065: CALL_OW 50
// result := result ^ un ;
21069: LD_ADDR_VAR 0 7
21073: PUSH
21074: LD_VAR 0 7
21078: PUSH
21079: LD_VAR 0 14
21083: ADD
21084: ST_TO_ADDR
// end ;
21085: GO 20963
21087: POP
21088: POP
// end ; end ;
21089: LD_VAR 0 7
21093: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21094: LD_INT 0
21096: PPUSH
21097: PPUSH
21098: PPUSH
21099: PPUSH
21100: PPUSH
21101: PPUSH
21102: PPUSH
21103: PPUSH
21104: PPUSH
21105: PPUSH
21106: PPUSH
21107: PPUSH
21108: PPUSH
21109: PPUSH
21110: PPUSH
21111: PPUSH
// result := false ;
21112: LD_ADDR_VAR 0 3
21116: PUSH
21117: LD_INT 0
21119: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21120: LD_VAR 0 1
21124: NOT
21125: PUSH
21126: LD_VAR 0 1
21130: PPUSH
21131: CALL_OW 266
21135: PUSH
21136: LD_INT 32
21138: PUSH
21139: LD_INT 33
21141: PUSH
21142: EMPTY
21143: LIST
21144: LIST
21145: IN
21146: NOT
21147: OR
21148: IFFALSE 21152
// exit ;
21150: GO 22261
// nat := GetNation ( tower ) ;
21152: LD_ADDR_VAR 0 12
21156: PUSH
21157: LD_VAR 0 1
21161: PPUSH
21162: CALL_OW 248
21166: ST_TO_ADDR
// side := GetSide ( tower ) ;
21167: LD_ADDR_VAR 0 16
21171: PUSH
21172: LD_VAR 0 1
21176: PPUSH
21177: CALL_OW 255
21181: ST_TO_ADDR
// x := GetX ( tower ) ;
21182: LD_ADDR_VAR 0 10
21186: PUSH
21187: LD_VAR 0 1
21191: PPUSH
21192: CALL_OW 250
21196: ST_TO_ADDR
// y := GetY ( tower ) ;
21197: LD_ADDR_VAR 0 11
21201: PUSH
21202: LD_VAR 0 1
21206: PPUSH
21207: CALL_OW 251
21211: ST_TO_ADDR
// if not x or not y then
21212: LD_VAR 0 10
21216: NOT
21217: PUSH
21218: LD_VAR 0 11
21222: NOT
21223: OR
21224: IFFALSE 21228
// exit ;
21226: GO 22261
// weapon := 0 ;
21228: LD_ADDR_VAR 0 18
21232: PUSH
21233: LD_INT 0
21235: ST_TO_ADDR
// fac_list := [ ] ;
21236: LD_ADDR_VAR 0 17
21240: PUSH
21241: EMPTY
21242: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21243: LD_ADDR_VAR 0 6
21247: PUSH
21248: LD_VAR 0 1
21252: PPUSH
21253: CALL_OW 274
21257: PPUSH
21258: LD_VAR 0 2
21262: PPUSH
21263: LD_INT 0
21265: PPUSH
21266: CALL 18832 0 3
21270: PPUSH
21271: LD_INT 30
21273: PUSH
21274: LD_INT 3
21276: PUSH
21277: EMPTY
21278: LIST
21279: LIST
21280: PPUSH
21281: CALL_OW 72
21285: ST_TO_ADDR
// if not factories then
21286: LD_VAR 0 6
21290: NOT
21291: IFFALSE 21295
// exit ;
21293: GO 22261
// for i in factories do
21295: LD_ADDR_VAR 0 8
21299: PUSH
21300: LD_VAR 0 6
21304: PUSH
21305: FOR_IN
21306: IFFALSE 21331
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21308: LD_ADDR_VAR 0 17
21312: PUSH
21313: LD_VAR 0 17
21317: PUSH
21318: LD_VAR 0 8
21322: PPUSH
21323: CALL_OW 478
21327: UNION
21328: ST_TO_ADDR
21329: GO 21305
21331: POP
21332: POP
// if not fac_list then
21333: LD_VAR 0 17
21337: NOT
21338: IFFALSE 21342
// exit ;
21340: GO 22261
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21342: LD_ADDR_VAR 0 5
21346: PUSH
21347: LD_INT 4
21349: PUSH
21350: LD_INT 5
21352: PUSH
21353: LD_INT 9
21355: PUSH
21356: LD_INT 10
21358: PUSH
21359: LD_INT 6
21361: PUSH
21362: LD_INT 7
21364: PUSH
21365: LD_INT 11
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: PUSH
21377: LD_INT 27
21379: PUSH
21380: LD_INT 28
21382: PUSH
21383: LD_INT 26
21385: PUSH
21386: LD_INT 30
21388: PUSH
21389: EMPTY
21390: LIST
21391: LIST
21392: LIST
21393: LIST
21394: PUSH
21395: LD_INT 43
21397: PUSH
21398: LD_INT 44
21400: PUSH
21401: LD_INT 46
21403: PUSH
21404: LD_INT 45
21406: PUSH
21407: LD_INT 47
21409: PUSH
21410: LD_INT 49
21412: PUSH
21413: EMPTY
21414: LIST
21415: LIST
21416: LIST
21417: LIST
21418: LIST
21419: LIST
21420: PUSH
21421: EMPTY
21422: LIST
21423: LIST
21424: LIST
21425: PUSH
21426: LD_VAR 0 12
21430: ARRAY
21431: ST_TO_ADDR
// list := list isect fac_list ;
21432: LD_ADDR_VAR 0 5
21436: PUSH
21437: LD_VAR 0 5
21441: PUSH
21442: LD_VAR 0 17
21446: ISECT
21447: ST_TO_ADDR
// if not list then
21448: LD_VAR 0 5
21452: NOT
21453: IFFALSE 21457
// exit ;
21455: GO 22261
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21457: LD_VAR 0 12
21461: PUSH
21462: LD_INT 3
21464: EQUAL
21465: PUSH
21466: LD_INT 49
21468: PUSH
21469: LD_VAR 0 5
21473: IN
21474: AND
21475: PUSH
21476: LD_INT 31
21478: PPUSH
21479: LD_VAR 0 16
21483: PPUSH
21484: CALL_OW 321
21488: PUSH
21489: LD_INT 2
21491: EQUAL
21492: AND
21493: IFFALSE 21553
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21495: LD_INT 22
21497: PUSH
21498: LD_VAR 0 16
21502: PUSH
21503: EMPTY
21504: LIST
21505: LIST
21506: PUSH
21507: LD_INT 35
21509: PUSH
21510: LD_INT 49
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: PUSH
21517: LD_INT 91
21519: PUSH
21520: LD_VAR 0 1
21524: PUSH
21525: LD_INT 10
21527: PUSH
21528: EMPTY
21529: LIST
21530: LIST
21531: LIST
21532: PUSH
21533: EMPTY
21534: LIST
21535: LIST
21536: LIST
21537: PPUSH
21538: CALL_OW 69
21542: NOT
21543: IFFALSE 21553
// weapon := ru_time_lapser ;
21545: LD_ADDR_VAR 0 18
21549: PUSH
21550: LD_INT 49
21552: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21553: LD_VAR 0 12
21557: PUSH
21558: LD_INT 1
21560: PUSH
21561: LD_INT 2
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: IN
21568: PUSH
21569: LD_INT 11
21571: PUSH
21572: LD_VAR 0 5
21576: IN
21577: PUSH
21578: LD_INT 30
21580: PUSH
21581: LD_VAR 0 5
21585: IN
21586: OR
21587: AND
21588: PUSH
21589: LD_INT 6
21591: PPUSH
21592: LD_VAR 0 16
21596: PPUSH
21597: CALL_OW 321
21601: PUSH
21602: LD_INT 2
21604: EQUAL
21605: AND
21606: IFFALSE 21771
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21608: LD_INT 22
21610: PUSH
21611: LD_VAR 0 16
21615: PUSH
21616: EMPTY
21617: LIST
21618: LIST
21619: PUSH
21620: LD_INT 2
21622: PUSH
21623: LD_INT 35
21625: PUSH
21626: LD_INT 11
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: PUSH
21633: LD_INT 35
21635: PUSH
21636: LD_INT 30
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: PUSH
21648: LD_INT 91
21650: PUSH
21651: LD_VAR 0 1
21655: PUSH
21656: LD_INT 18
21658: PUSH
21659: EMPTY
21660: LIST
21661: LIST
21662: LIST
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: LIST
21668: PPUSH
21669: CALL_OW 69
21673: NOT
21674: PUSH
21675: LD_INT 22
21677: PUSH
21678: LD_VAR 0 16
21682: PUSH
21683: EMPTY
21684: LIST
21685: LIST
21686: PUSH
21687: LD_INT 2
21689: PUSH
21690: LD_INT 30
21692: PUSH
21693: LD_INT 32
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: PUSH
21700: LD_INT 30
21702: PUSH
21703: LD_INT 33
21705: PUSH
21706: EMPTY
21707: LIST
21708: LIST
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: LIST
21714: PUSH
21715: LD_INT 91
21717: PUSH
21718: LD_VAR 0 1
21722: PUSH
21723: LD_INT 12
21725: PUSH
21726: EMPTY
21727: LIST
21728: LIST
21729: LIST
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: LIST
21735: PUSH
21736: EMPTY
21737: LIST
21738: PPUSH
21739: CALL_OW 69
21743: PUSH
21744: LD_INT 2
21746: GREATER
21747: AND
21748: IFFALSE 21771
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21750: LD_ADDR_VAR 0 18
21754: PUSH
21755: LD_INT 11
21757: PUSH
21758: LD_INT 30
21760: PUSH
21761: EMPTY
21762: LIST
21763: LIST
21764: PUSH
21765: LD_VAR 0 12
21769: ARRAY
21770: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21771: LD_VAR 0 18
21775: NOT
21776: PUSH
21777: LD_INT 40
21779: PPUSH
21780: LD_VAR 0 16
21784: PPUSH
21785: CALL_OW 321
21789: PUSH
21790: LD_INT 2
21792: EQUAL
21793: AND
21794: PUSH
21795: LD_INT 7
21797: PUSH
21798: LD_VAR 0 5
21802: IN
21803: PUSH
21804: LD_INT 28
21806: PUSH
21807: LD_VAR 0 5
21811: IN
21812: OR
21813: PUSH
21814: LD_INT 45
21816: PUSH
21817: LD_VAR 0 5
21821: IN
21822: OR
21823: AND
21824: IFFALSE 22078
// begin hex := GetHexInfo ( x , y ) ;
21826: LD_ADDR_VAR 0 4
21830: PUSH
21831: LD_VAR 0 10
21835: PPUSH
21836: LD_VAR 0 11
21840: PPUSH
21841: CALL_OW 546
21845: ST_TO_ADDR
// if hex [ 1 ] then
21846: LD_VAR 0 4
21850: PUSH
21851: LD_INT 1
21853: ARRAY
21854: IFFALSE 21858
// exit ;
21856: GO 22261
// height := hex [ 2 ] ;
21858: LD_ADDR_VAR 0 15
21862: PUSH
21863: LD_VAR 0 4
21867: PUSH
21868: LD_INT 2
21870: ARRAY
21871: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21872: LD_ADDR_VAR 0 14
21876: PUSH
21877: LD_INT 0
21879: PUSH
21880: LD_INT 2
21882: PUSH
21883: LD_INT 3
21885: PUSH
21886: LD_INT 5
21888: PUSH
21889: EMPTY
21890: LIST
21891: LIST
21892: LIST
21893: LIST
21894: ST_TO_ADDR
// for i in tmp do
21895: LD_ADDR_VAR 0 8
21899: PUSH
21900: LD_VAR 0 14
21904: PUSH
21905: FOR_IN
21906: IFFALSE 22076
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21908: LD_ADDR_VAR 0 9
21912: PUSH
21913: LD_VAR 0 10
21917: PPUSH
21918: LD_VAR 0 8
21922: PPUSH
21923: LD_INT 5
21925: PPUSH
21926: CALL_OW 272
21930: PUSH
21931: LD_VAR 0 11
21935: PPUSH
21936: LD_VAR 0 8
21940: PPUSH
21941: LD_INT 5
21943: PPUSH
21944: CALL_OW 273
21948: PUSH
21949: EMPTY
21950: LIST
21951: LIST
21952: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21953: LD_VAR 0 9
21957: PUSH
21958: LD_INT 1
21960: ARRAY
21961: PPUSH
21962: LD_VAR 0 9
21966: PUSH
21967: LD_INT 2
21969: ARRAY
21970: PPUSH
21971: CALL_OW 488
21975: IFFALSE 22074
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
21977: LD_ADDR_VAR 0 4
21981: PUSH
21982: LD_VAR 0 9
21986: PUSH
21987: LD_INT 1
21989: ARRAY
21990: PPUSH
21991: LD_VAR 0 9
21995: PUSH
21996: LD_INT 2
21998: ARRAY
21999: PPUSH
22000: CALL_OW 546
22004: ST_TO_ADDR
// if hex [ 1 ] then
22005: LD_VAR 0 4
22009: PUSH
22010: LD_INT 1
22012: ARRAY
22013: IFFALSE 22017
// continue ;
22015: GO 21905
// h := hex [ 2 ] ;
22017: LD_ADDR_VAR 0 13
22021: PUSH
22022: LD_VAR 0 4
22026: PUSH
22027: LD_INT 2
22029: ARRAY
22030: ST_TO_ADDR
// if h + 7 < height then
22031: LD_VAR 0 13
22035: PUSH
22036: LD_INT 7
22038: PLUS
22039: PUSH
22040: LD_VAR 0 15
22044: LESS
22045: IFFALSE 22074
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22047: LD_ADDR_VAR 0 18
22051: PUSH
22052: LD_INT 7
22054: PUSH
22055: LD_INT 28
22057: PUSH
22058: LD_INT 45
22060: PUSH
22061: EMPTY
22062: LIST
22063: LIST
22064: LIST
22065: PUSH
22066: LD_VAR 0 12
22070: ARRAY
22071: ST_TO_ADDR
// break ;
22072: GO 22076
// end ; end ; end ;
22074: GO 21905
22076: POP
22077: POP
// end ; if not weapon then
22078: LD_VAR 0 18
22082: NOT
22083: IFFALSE 22143
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22085: LD_ADDR_VAR 0 5
22089: PUSH
22090: LD_VAR 0 5
22094: PUSH
22095: LD_INT 11
22097: PUSH
22098: LD_INT 30
22100: PUSH
22101: LD_INT 49
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: LIST
22108: DIFF
22109: ST_TO_ADDR
// if not list then
22110: LD_VAR 0 5
22114: NOT
22115: IFFALSE 22119
// exit ;
22117: GO 22261
// weapon := list [ rand ( 1 , list ) ] ;
22119: LD_ADDR_VAR 0 18
22123: PUSH
22124: LD_VAR 0 5
22128: PUSH
22129: LD_INT 1
22131: PPUSH
22132: LD_VAR 0 5
22136: PPUSH
22137: CALL_OW 12
22141: ARRAY
22142: ST_TO_ADDR
// end ; if weapon then
22143: LD_VAR 0 18
22147: IFFALSE 22261
// begin tmp := CostOfWeapon ( weapon ) ;
22149: LD_ADDR_VAR 0 14
22153: PUSH
22154: LD_VAR 0 18
22158: PPUSH
22159: CALL_OW 451
22163: ST_TO_ADDR
// j := GetBase ( tower ) ;
22164: LD_ADDR_VAR 0 9
22168: PUSH
22169: LD_VAR 0 1
22173: PPUSH
22174: CALL_OW 274
22178: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22179: LD_VAR 0 9
22183: PPUSH
22184: LD_INT 1
22186: PPUSH
22187: CALL_OW 275
22191: PUSH
22192: LD_VAR 0 14
22196: PUSH
22197: LD_INT 1
22199: ARRAY
22200: GREATEREQUAL
22201: PUSH
22202: LD_VAR 0 9
22206: PPUSH
22207: LD_INT 2
22209: PPUSH
22210: CALL_OW 275
22214: PUSH
22215: LD_VAR 0 14
22219: PUSH
22220: LD_INT 2
22222: ARRAY
22223: GREATEREQUAL
22224: AND
22225: PUSH
22226: LD_VAR 0 9
22230: PPUSH
22231: LD_INT 3
22233: PPUSH
22234: CALL_OW 275
22238: PUSH
22239: LD_VAR 0 14
22243: PUSH
22244: LD_INT 3
22246: ARRAY
22247: GREATEREQUAL
22248: AND
22249: IFFALSE 22261
// result := weapon ;
22251: LD_ADDR_VAR 0 3
22255: PUSH
22256: LD_VAR 0 18
22260: ST_TO_ADDR
// end ; end ;
22261: LD_VAR 0 3
22265: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22266: LD_INT 0
22268: PPUSH
22269: PPUSH
// result := true ;
22270: LD_ADDR_VAR 0 3
22274: PUSH
22275: LD_INT 1
22277: ST_TO_ADDR
// if array1 = array2 then
22278: LD_VAR 0 1
22282: PUSH
22283: LD_VAR 0 2
22287: EQUAL
22288: IFFALSE 22348
// begin for i = 1 to array1 do
22290: LD_ADDR_VAR 0 4
22294: PUSH
22295: DOUBLE
22296: LD_INT 1
22298: DEC
22299: ST_TO_ADDR
22300: LD_VAR 0 1
22304: PUSH
22305: FOR_TO
22306: IFFALSE 22344
// if array1 [ i ] <> array2 [ i ] then
22308: LD_VAR 0 1
22312: PUSH
22313: LD_VAR 0 4
22317: ARRAY
22318: PUSH
22319: LD_VAR 0 2
22323: PUSH
22324: LD_VAR 0 4
22328: ARRAY
22329: NONEQUAL
22330: IFFALSE 22342
// begin result := false ;
22332: LD_ADDR_VAR 0 3
22336: PUSH
22337: LD_INT 0
22339: ST_TO_ADDR
// break ;
22340: GO 22344
// end ;
22342: GO 22305
22344: POP
22345: POP
// end else
22346: GO 22356
// result := false ;
22348: LD_ADDR_VAR 0 3
22352: PUSH
22353: LD_INT 0
22355: ST_TO_ADDR
// end ;
22356: LD_VAR 0 3
22360: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22361: LD_INT 0
22363: PPUSH
22364: PPUSH
// if not array1 or not array2 then
22365: LD_VAR 0 1
22369: NOT
22370: PUSH
22371: LD_VAR 0 2
22375: NOT
22376: OR
22377: IFFALSE 22381
// exit ;
22379: GO 22445
// result := true ;
22381: LD_ADDR_VAR 0 3
22385: PUSH
22386: LD_INT 1
22388: ST_TO_ADDR
// for i = 1 to array1 do
22389: LD_ADDR_VAR 0 4
22393: PUSH
22394: DOUBLE
22395: LD_INT 1
22397: DEC
22398: ST_TO_ADDR
22399: LD_VAR 0 1
22403: PUSH
22404: FOR_TO
22405: IFFALSE 22443
// if array1 [ i ] <> array2 [ i ] then
22407: LD_VAR 0 1
22411: PUSH
22412: LD_VAR 0 4
22416: ARRAY
22417: PUSH
22418: LD_VAR 0 2
22422: PUSH
22423: LD_VAR 0 4
22427: ARRAY
22428: NONEQUAL
22429: IFFALSE 22441
// begin result := false ;
22431: LD_ADDR_VAR 0 3
22435: PUSH
22436: LD_INT 0
22438: ST_TO_ADDR
// break ;
22439: GO 22443
// end ;
22441: GO 22404
22443: POP
22444: POP
// end ;
22445: LD_VAR 0 3
22449: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22450: LD_INT 0
22452: PPUSH
22453: PPUSH
22454: PPUSH
// pom := GetBase ( fac ) ;
22455: LD_ADDR_VAR 0 5
22459: PUSH
22460: LD_VAR 0 1
22464: PPUSH
22465: CALL_OW 274
22469: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22470: LD_ADDR_VAR 0 4
22474: PUSH
22475: LD_VAR 0 2
22479: PUSH
22480: LD_INT 1
22482: ARRAY
22483: PPUSH
22484: LD_VAR 0 2
22488: PUSH
22489: LD_INT 2
22491: ARRAY
22492: PPUSH
22493: LD_VAR 0 2
22497: PUSH
22498: LD_INT 3
22500: ARRAY
22501: PPUSH
22502: LD_VAR 0 2
22506: PUSH
22507: LD_INT 4
22509: ARRAY
22510: PPUSH
22511: CALL_OW 449
22515: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22516: LD_ADDR_VAR 0 3
22520: PUSH
22521: LD_VAR 0 5
22525: PPUSH
22526: LD_INT 1
22528: PPUSH
22529: CALL_OW 275
22533: PUSH
22534: LD_VAR 0 4
22538: PUSH
22539: LD_INT 1
22541: ARRAY
22542: GREATEREQUAL
22543: PUSH
22544: LD_VAR 0 5
22548: PPUSH
22549: LD_INT 2
22551: PPUSH
22552: CALL_OW 275
22556: PUSH
22557: LD_VAR 0 4
22561: PUSH
22562: LD_INT 2
22564: ARRAY
22565: GREATEREQUAL
22566: AND
22567: PUSH
22568: LD_VAR 0 5
22572: PPUSH
22573: LD_INT 3
22575: PPUSH
22576: CALL_OW 275
22580: PUSH
22581: LD_VAR 0 4
22585: PUSH
22586: LD_INT 3
22588: ARRAY
22589: GREATEREQUAL
22590: AND
22591: ST_TO_ADDR
// end ;
22592: LD_VAR 0 3
22596: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22597: LD_INT 0
22599: PPUSH
22600: PPUSH
22601: PPUSH
22602: PPUSH
// pom := GetBase ( building ) ;
22603: LD_ADDR_VAR 0 3
22607: PUSH
22608: LD_VAR 0 1
22612: PPUSH
22613: CALL_OW 274
22617: ST_TO_ADDR
// if not pom then
22618: LD_VAR 0 3
22622: NOT
22623: IFFALSE 22627
// exit ;
22625: GO 22797
// btype := GetBType ( building ) ;
22627: LD_ADDR_VAR 0 5
22631: PUSH
22632: LD_VAR 0 1
22636: PPUSH
22637: CALL_OW 266
22641: ST_TO_ADDR
// if btype = b_armoury then
22642: LD_VAR 0 5
22646: PUSH
22647: LD_INT 4
22649: EQUAL
22650: IFFALSE 22660
// btype := b_barracks ;
22652: LD_ADDR_VAR 0 5
22656: PUSH
22657: LD_INT 5
22659: ST_TO_ADDR
// if btype = b_depot then
22660: LD_VAR 0 5
22664: PUSH
22665: LD_INT 0
22667: EQUAL
22668: IFFALSE 22678
// btype := b_warehouse ;
22670: LD_ADDR_VAR 0 5
22674: PUSH
22675: LD_INT 1
22677: ST_TO_ADDR
// if btype = b_workshop then
22678: LD_VAR 0 5
22682: PUSH
22683: LD_INT 2
22685: EQUAL
22686: IFFALSE 22696
// btype := b_factory ;
22688: LD_ADDR_VAR 0 5
22692: PUSH
22693: LD_INT 3
22695: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22696: LD_ADDR_VAR 0 4
22700: PUSH
22701: LD_VAR 0 5
22705: PPUSH
22706: LD_VAR 0 1
22710: PPUSH
22711: CALL_OW 248
22715: PPUSH
22716: CALL_OW 450
22720: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22721: LD_ADDR_VAR 0 2
22725: PUSH
22726: LD_VAR 0 3
22730: PPUSH
22731: LD_INT 1
22733: PPUSH
22734: CALL_OW 275
22738: PUSH
22739: LD_VAR 0 4
22743: PUSH
22744: LD_INT 1
22746: ARRAY
22747: GREATEREQUAL
22748: PUSH
22749: LD_VAR 0 3
22753: PPUSH
22754: LD_INT 2
22756: PPUSH
22757: CALL_OW 275
22761: PUSH
22762: LD_VAR 0 4
22766: PUSH
22767: LD_INT 2
22769: ARRAY
22770: GREATEREQUAL
22771: AND
22772: PUSH
22773: LD_VAR 0 3
22777: PPUSH
22778: LD_INT 3
22780: PPUSH
22781: CALL_OW 275
22785: PUSH
22786: LD_VAR 0 4
22790: PUSH
22791: LD_INT 3
22793: ARRAY
22794: GREATEREQUAL
22795: AND
22796: ST_TO_ADDR
// end ;
22797: LD_VAR 0 2
22801: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22802: LD_INT 0
22804: PPUSH
22805: PPUSH
22806: PPUSH
// pom := GetBase ( building ) ;
22807: LD_ADDR_VAR 0 4
22811: PUSH
22812: LD_VAR 0 1
22816: PPUSH
22817: CALL_OW 274
22821: ST_TO_ADDR
// if not pom then
22822: LD_VAR 0 4
22826: NOT
22827: IFFALSE 22831
// exit ;
22829: GO 22932
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22831: LD_ADDR_VAR 0 5
22835: PUSH
22836: LD_VAR 0 2
22840: PPUSH
22841: LD_VAR 0 1
22845: PPUSH
22846: CALL_OW 248
22850: PPUSH
22851: CALL_OW 450
22855: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22856: LD_ADDR_VAR 0 3
22860: PUSH
22861: LD_VAR 0 4
22865: PPUSH
22866: LD_INT 1
22868: PPUSH
22869: CALL_OW 275
22873: PUSH
22874: LD_VAR 0 5
22878: PUSH
22879: LD_INT 1
22881: ARRAY
22882: GREATEREQUAL
22883: PUSH
22884: LD_VAR 0 4
22888: PPUSH
22889: LD_INT 2
22891: PPUSH
22892: CALL_OW 275
22896: PUSH
22897: LD_VAR 0 5
22901: PUSH
22902: LD_INT 2
22904: ARRAY
22905: GREATEREQUAL
22906: AND
22907: PUSH
22908: LD_VAR 0 4
22912: PPUSH
22913: LD_INT 3
22915: PPUSH
22916: CALL_OW 275
22920: PUSH
22921: LD_VAR 0 5
22925: PUSH
22926: LD_INT 3
22928: ARRAY
22929: GREATEREQUAL
22930: AND
22931: ST_TO_ADDR
// end ;
22932: LD_VAR 0 3
22936: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22937: LD_INT 0
22939: PPUSH
22940: PPUSH
22941: PPUSH
22942: PPUSH
22943: PPUSH
22944: PPUSH
22945: PPUSH
22946: PPUSH
22947: PPUSH
22948: PPUSH
22949: PPUSH
// result := false ;
22950: LD_ADDR_VAR 0 8
22954: PUSH
22955: LD_INT 0
22957: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22958: LD_VAR 0 5
22962: NOT
22963: PUSH
22964: LD_VAR 0 1
22968: NOT
22969: OR
22970: PUSH
22971: LD_VAR 0 2
22975: NOT
22976: OR
22977: PUSH
22978: LD_VAR 0 3
22982: NOT
22983: OR
22984: IFFALSE 22988
// exit ;
22986: GO 23802
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
22988: LD_ADDR_VAR 0 14
22992: PUSH
22993: LD_VAR 0 1
22997: PPUSH
22998: LD_VAR 0 2
23002: PPUSH
23003: LD_VAR 0 3
23007: PPUSH
23008: LD_VAR 0 4
23012: PPUSH
23013: LD_VAR 0 5
23017: PUSH
23018: LD_INT 1
23020: ARRAY
23021: PPUSH
23022: CALL_OW 248
23026: PPUSH
23027: LD_INT 0
23029: PPUSH
23030: CALL 25055 0 6
23034: ST_TO_ADDR
// if not hexes then
23035: LD_VAR 0 14
23039: NOT
23040: IFFALSE 23044
// exit ;
23042: GO 23802
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23044: LD_ADDR_VAR 0 17
23048: PUSH
23049: LD_VAR 0 5
23053: PPUSH
23054: LD_INT 22
23056: PUSH
23057: LD_VAR 0 13
23061: PPUSH
23062: CALL_OW 255
23066: PUSH
23067: EMPTY
23068: LIST
23069: LIST
23070: PUSH
23071: LD_INT 2
23073: PUSH
23074: LD_INT 30
23076: PUSH
23077: LD_INT 0
23079: PUSH
23080: EMPTY
23081: LIST
23082: LIST
23083: PUSH
23084: LD_INT 30
23086: PUSH
23087: LD_INT 1
23089: PUSH
23090: EMPTY
23091: LIST
23092: LIST
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: LIST
23098: PUSH
23099: EMPTY
23100: LIST
23101: LIST
23102: PPUSH
23103: CALL_OW 72
23107: ST_TO_ADDR
// for i = 1 to hexes do
23108: LD_ADDR_VAR 0 9
23112: PUSH
23113: DOUBLE
23114: LD_INT 1
23116: DEC
23117: ST_TO_ADDR
23118: LD_VAR 0 14
23122: PUSH
23123: FOR_TO
23124: IFFALSE 23800
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23126: LD_ADDR_VAR 0 13
23130: PUSH
23131: LD_VAR 0 14
23135: PUSH
23136: LD_VAR 0 9
23140: ARRAY
23141: PUSH
23142: LD_INT 1
23144: ARRAY
23145: PPUSH
23146: LD_VAR 0 14
23150: PUSH
23151: LD_VAR 0 9
23155: ARRAY
23156: PUSH
23157: LD_INT 2
23159: ARRAY
23160: PPUSH
23161: CALL_OW 428
23165: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23166: LD_VAR 0 14
23170: PUSH
23171: LD_VAR 0 9
23175: ARRAY
23176: PUSH
23177: LD_INT 1
23179: ARRAY
23180: PPUSH
23181: LD_VAR 0 14
23185: PUSH
23186: LD_VAR 0 9
23190: ARRAY
23191: PUSH
23192: LD_INT 2
23194: ARRAY
23195: PPUSH
23196: CALL_OW 351
23200: PUSH
23201: LD_VAR 0 14
23205: PUSH
23206: LD_VAR 0 9
23210: ARRAY
23211: PUSH
23212: LD_INT 1
23214: ARRAY
23215: PPUSH
23216: LD_VAR 0 14
23220: PUSH
23221: LD_VAR 0 9
23225: ARRAY
23226: PUSH
23227: LD_INT 2
23229: ARRAY
23230: PPUSH
23231: CALL_OW 488
23235: NOT
23236: OR
23237: PUSH
23238: LD_VAR 0 13
23242: PPUSH
23243: CALL_OW 247
23247: PUSH
23248: LD_INT 3
23250: EQUAL
23251: OR
23252: IFFALSE 23258
// exit ;
23254: POP
23255: POP
23256: GO 23802
// if not tmp then
23258: LD_VAR 0 13
23262: NOT
23263: IFFALSE 23267
// continue ;
23265: GO 23123
// result := true ;
23267: LD_ADDR_VAR 0 8
23271: PUSH
23272: LD_INT 1
23274: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23275: LD_VAR 0 6
23279: PUSH
23280: LD_VAR 0 13
23284: PPUSH
23285: CALL_OW 247
23289: PUSH
23290: LD_INT 2
23292: EQUAL
23293: AND
23294: PUSH
23295: LD_VAR 0 13
23299: PPUSH
23300: CALL_OW 263
23304: PUSH
23305: LD_INT 1
23307: EQUAL
23308: AND
23309: IFFALSE 23473
// begin if IsDrivenBy ( tmp ) then
23311: LD_VAR 0 13
23315: PPUSH
23316: CALL_OW 311
23320: IFFALSE 23324
// continue ;
23322: GO 23123
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23324: LD_VAR 0 6
23328: PPUSH
23329: LD_INT 3
23331: PUSH
23332: LD_INT 60
23334: PUSH
23335: EMPTY
23336: LIST
23337: PUSH
23338: EMPTY
23339: LIST
23340: LIST
23341: PUSH
23342: LD_INT 3
23344: PUSH
23345: LD_INT 55
23347: PUSH
23348: EMPTY
23349: LIST
23350: PUSH
23351: EMPTY
23352: LIST
23353: LIST
23354: PUSH
23355: EMPTY
23356: LIST
23357: LIST
23358: PPUSH
23359: CALL_OW 72
23363: IFFALSE 23471
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23365: LD_ADDR_VAR 0 18
23369: PUSH
23370: LD_VAR 0 6
23374: PPUSH
23375: LD_INT 3
23377: PUSH
23378: LD_INT 60
23380: PUSH
23381: EMPTY
23382: LIST
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: PUSH
23388: LD_INT 3
23390: PUSH
23391: LD_INT 55
23393: PUSH
23394: EMPTY
23395: LIST
23396: PUSH
23397: EMPTY
23398: LIST
23399: LIST
23400: PUSH
23401: EMPTY
23402: LIST
23403: LIST
23404: PPUSH
23405: CALL_OW 72
23409: PUSH
23410: LD_INT 1
23412: ARRAY
23413: ST_TO_ADDR
// if IsInUnit ( driver ) then
23414: LD_VAR 0 18
23418: PPUSH
23419: CALL_OW 310
23423: IFFALSE 23434
// ComExit ( driver ) ;
23425: LD_VAR 0 18
23429: PPUSH
23430: CALL 48834 0 1
// AddComEnterUnit ( driver , tmp ) ;
23434: LD_VAR 0 18
23438: PPUSH
23439: LD_VAR 0 13
23443: PPUSH
23444: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23448: LD_VAR 0 18
23452: PPUSH
23453: LD_VAR 0 7
23457: PPUSH
23458: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23462: LD_VAR 0 18
23466: PPUSH
23467: CALL_OW 181
// end ; continue ;
23471: GO 23123
// end ; if not cleaners or not tmp in cleaners then
23473: LD_VAR 0 6
23477: NOT
23478: PUSH
23479: LD_VAR 0 13
23483: PUSH
23484: LD_VAR 0 6
23488: IN
23489: NOT
23490: OR
23491: IFFALSE 23798
// begin if dep then
23493: LD_VAR 0 17
23497: IFFALSE 23633
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23499: LD_ADDR_VAR 0 16
23503: PUSH
23504: LD_VAR 0 17
23508: PUSH
23509: LD_INT 1
23511: ARRAY
23512: PPUSH
23513: CALL_OW 250
23517: PPUSH
23518: LD_VAR 0 17
23522: PUSH
23523: LD_INT 1
23525: ARRAY
23526: PPUSH
23527: CALL_OW 254
23531: PPUSH
23532: LD_INT 5
23534: PPUSH
23535: CALL_OW 272
23539: PUSH
23540: LD_VAR 0 17
23544: PUSH
23545: LD_INT 1
23547: ARRAY
23548: PPUSH
23549: CALL_OW 251
23553: PPUSH
23554: LD_VAR 0 17
23558: PUSH
23559: LD_INT 1
23561: ARRAY
23562: PPUSH
23563: CALL_OW 254
23567: PPUSH
23568: LD_INT 5
23570: PPUSH
23571: CALL_OW 273
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23580: LD_VAR 0 16
23584: PUSH
23585: LD_INT 1
23587: ARRAY
23588: PPUSH
23589: LD_VAR 0 16
23593: PUSH
23594: LD_INT 2
23596: ARRAY
23597: PPUSH
23598: CALL_OW 488
23602: IFFALSE 23633
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23604: LD_VAR 0 13
23608: PPUSH
23609: LD_VAR 0 16
23613: PUSH
23614: LD_INT 1
23616: ARRAY
23617: PPUSH
23618: LD_VAR 0 16
23622: PUSH
23623: LD_INT 2
23625: ARRAY
23626: PPUSH
23627: CALL_OW 111
// continue ;
23631: GO 23123
// end ; end ; r := GetDir ( tmp ) ;
23633: LD_ADDR_VAR 0 15
23637: PUSH
23638: LD_VAR 0 13
23642: PPUSH
23643: CALL_OW 254
23647: ST_TO_ADDR
// if r = 5 then
23648: LD_VAR 0 15
23652: PUSH
23653: LD_INT 5
23655: EQUAL
23656: IFFALSE 23666
// r := 0 ;
23658: LD_ADDR_VAR 0 15
23662: PUSH
23663: LD_INT 0
23665: ST_TO_ADDR
// for j = r to 5 do
23666: LD_ADDR_VAR 0 10
23670: PUSH
23671: DOUBLE
23672: LD_VAR 0 15
23676: DEC
23677: ST_TO_ADDR
23678: LD_INT 5
23680: PUSH
23681: FOR_TO
23682: IFFALSE 23796
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23684: LD_ADDR_VAR 0 11
23688: PUSH
23689: LD_VAR 0 13
23693: PPUSH
23694: CALL_OW 250
23698: PPUSH
23699: LD_VAR 0 10
23703: PPUSH
23704: LD_INT 2
23706: PPUSH
23707: CALL_OW 272
23711: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23712: LD_ADDR_VAR 0 12
23716: PUSH
23717: LD_VAR 0 13
23721: PPUSH
23722: CALL_OW 251
23726: PPUSH
23727: LD_VAR 0 10
23731: PPUSH
23732: LD_INT 2
23734: PPUSH
23735: CALL_OW 273
23739: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23740: LD_VAR 0 11
23744: PPUSH
23745: LD_VAR 0 12
23749: PPUSH
23750: CALL_OW 488
23754: PUSH
23755: LD_VAR 0 11
23759: PPUSH
23760: LD_VAR 0 12
23764: PPUSH
23765: CALL_OW 428
23769: NOT
23770: AND
23771: IFFALSE 23794
// begin ComMoveXY ( tmp , _x , _y ) ;
23773: LD_VAR 0 13
23777: PPUSH
23778: LD_VAR 0 11
23782: PPUSH
23783: LD_VAR 0 12
23787: PPUSH
23788: CALL_OW 111
// break ;
23792: GO 23796
// end ; end ;
23794: GO 23681
23796: POP
23797: POP
// end ; end ;
23798: GO 23123
23800: POP
23801: POP
// end ;
23802: LD_VAR 0 8
23806: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23807: LD_INT 0
23809: PPUSH
// result := true ;
23810: LD_ADDR_VAR 0 3
23814: PUSH
23815: LD_INT 1
23817: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23818: LD_VAR 0 2
23822: PUSH
23823: LD_INT 24
23825: DOUBLE
23826: EQUAL
23827: IFTRUE 23837
23829: LD_INT 33
23831: DOUBLE
23832: EQUAL
23833: IFTRUE 23837
23835: GO 23862
23837: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23838: LD_ADDR_VAR 0 3
23842: PUSH
23843: LD_INT 32
23845: PPUSH
23846: LD_VAR 0 1
23850: PPUSH
23851: CALL_OW 321
23855: PUSH
23856: LD_INT 2
23858: EQUAL
23859: ST_TO_ADDR
23860: GO 24178
23862: LD_INT 20
23864: DOUBLE
23865: EQUAL
23866: IFTRUE 23870
23868: GO 23895
23870: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23871: LD_ADDR_VAR 0 3
23875: PUSH
23876: LD_INT 6
23878: PPUSH
23879: LD_VAR 0 1
23883: PPUSH
23884: CALL_OW 321
23888: PUSH
23889: LD_INT 2
23891: EQUAL
23892: ST_TO_ADDR
23893: GO 24178
23895: LD_INT 22
23897: DOUBLE
23898: EQUAL
23899: IFTRUE 23909
23901: LD_INT 36
23903: DOUBLE
23904: EQUAL
23905: IFTRUE 23909
23907: GO 23934
23909: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23910: LD_ADDR_VAR 0 3
23914: PUSH
23915: LD_INT 15
23917: PPUSH
23918: LD_VAR 0 1
23922: PPUSH
23923: CALL_OW 321
23927: PUSH
23928: LD_INT 2
23930: EQUAL
23931: ST_TO_ADDR
23932: GO 24178
23934: LD_INT 30
23936: DOUBLE
23937: EQUAL
23938: IFTRUE 23942
23940: GO 23967
23942: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23943: LD_ADDR_VAR 0 3
23947: PUSH
23948: LD_INT 20
23950: PPUSH
23951: LD_VAR 0 1
23955: PPUSH
23956: CALL_OW 321
23960: PUSH
23961: LD_INT 2
23963: EQUAL
23964: ST_TO_ADDR
23965: GO 24178
23967: LD_INT 28
23969: DOUBLE
23970: EQUAL
23971: IFTRUE 23981
23973: LD_INT 21
23975: DOUBLE
23976: EQUAL
23977: IFTRUE 23981
23979: GO 24006
23981: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
23982: LD_ADDR_VAR 0 3
23986: PUSH
23987: LD_INT 21
23989: PPUSH
23990: LD_VAR 0 1
23994: PPUSH
23995: CALL_OW 321
23999: PUSH
24000: LD_INT 2
24002: EQUAL
24003: ST_TO_ADDR
24004: GO 24178
24006: LD_INT 16
24008: DOUBLE
24009: EQUAL
24010: IFTRUE 24014
24012: GO 24039
24014: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24015: LD_ADDR_VAR 0 3
24019: PUSH
24020: LD_INT 84
24022: PPUSH
24023: LD_VAR 0 1
24027: PPUSH
24028: CALL_OW 321
24032: PUSH
24033: LD_INT 2
24035: EQUAL
24036: ST_TO_ADDR
24037: GO 24178
24039: LD_INT 19
24041: DOUBLE
24042: EQUAL
24043: IFTRUE 24053
24045: LD_INT 23
24047: DOUBLE
24048: EQUAL
24049: IFTRUE 24053
24051: GO 24078
24053: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24054: LD_ADDR_VAR 0 3
24058: PUSH
24059: LD_INT 83
24061: PPUSH
24062: LD_VAR 0 1
24066: PPUSH
24067: CALL_OW 321
24071: PUSH
24072: LD_INT 2
24074: EQUAL
24075: ST_TO_ADDR
24076: GO 24178
24078: LD_INT 17
24080: DOUBLE
24081: EQUAL
24082: IFTRUE 24086
24084: GO 24111
24086: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24087: LD_ADDR_VAR 0 3
24091: PUSH
24092: LD_INT 39
24094: PPUSH
24095: LD_VAR 0 1
24099: PPUSH
24100: CALL_OW 321
24104: PUSH
24105: LD_INT 2
24107: EQUAL
24108: ST_TO_ADDR
24109: GO 24178
24111: LD_INT 18
24113: DOUBLE
24114: EQUAL
24115: IFTRUE 24119
24117: GO 24144
24119: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24120: LD_ADDR_VAR 0 3
24124: PUSH
24125: LD_INT 40
24127: PPUSH
24128: LD_VAR 0 1
24132: PPUSH
24133: CALL_OW 321
24137: PUSH
24138: LD_INT 2
24140: EQUAL
24141: ST_TO_ADDR
24142: GO 24178
24144: LD_INT 27
24146: DOUBLE
24147: EQUAL
24148: IFTRUE 24152
24150: GO 24177
24152: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24153: LD_ADDR_VAR 0 3
24157: PUSH
24158: LD_INT 35
24160: PPUSH
24161: LD_VAR 0 1
24165: PPUSH
24166: CALL_OW 321
24170: PUSH
24171: LD_INT 2
24173: EQUAL
24174: ST_TO_ADDR
24175: GO 24178
24177: POP
// end ;
24178: LD_VAR 0 3
24182: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24183: LD_INT 0
24185: PPUSH
24186: PPUSH
24187: PPUSH
24188: PPUSH
24189: PPUSH
24190: PPUSH
24191: PPUSH
24192: PPUSH
24193: PPUSH
24194: PPUSH
24195: PPUSH
// result := false ;
24196: LD_ADDR_VAR 0 6
24200: PUSH
24201: LD_INT 0
24203: ST_TO_ADDR
// if btype = b_depot then
24204: LD_VAR 0 2
24208: PUSH
24209: LD_INT 0
24211: EQUAL
24212: IFFALSE 24224
// begin result := true ;
24214: LD_ADDR_VAR 0 6
24218: PUSH
24219: LD_INT 1
24221: ST_TO_ADDR
// exit ;
24222: GO 25050
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24224: LD_VAR 0 1
24228: NOT
24229: PUSH
24230: LD_VAR 0 1
24234: PPUSH
24235: CALL_OW 266
24239: PUSH
24240: LD_INT 0
24242: PUSH
24243: LD_INT 1
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: IN
24250: NOT
24251: OR
24252: PUSH
24253: LD_VAR 0 2
24257: NOT
24258: OR
24259: PUSH
24260: LD_VAR 0 5
24264: PUSH
24265: LD_INT 0
24267: PUSH
24268: LD_INT 1
24270: PUSH
24271: LD_INT 2
24273: PUSH
24274: LD_INT 3
24276: PUSH
24277: LD_INT 4
24279: PUSH
24280: LD_INT 5
24282: PUSH
24283: EMPTY
24284: LIST
24285: LIST
24286: LIST
24287: LIST
24288: LIST
24289: LIST
24290: IN
24291: NOT
24292: OR
24293: PUSH
24294: LD_VAR 0 3
24298: PPUSH
24299: LD_VAR 0 4
24303: PPUSH
24304: CALL_OW 488
24308: NOT
24309: OR
24310: IFFALSE 24314
// exit ;
24312: GO 25050
// side := GetSide ( depot ) ;
24314: LD_ADDR_VAR 0 9
24318: PUSH
24319: LD_VAR 0 1
24323: PPUSH
24324: CALL_OW 255
24328: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24329: LD_VAR 0 9
24333: PPUSH
24334: LD_VAR 0 2
24338: PPUSH
24339: CALL 23807 0 2
24343: NOT
24344: IFFALSE 24348
// exit ;
24346: GO 25050
// pom := GetBase ( depot ) ;
24348: LD_ADDR_VAR 0 10
24352: PUSH
24353: LD_VAR 0 1
24357: PPUSH
24358: CALL_OW 274
24362: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24363: LD_ADDR_VAR 0 11
24367: PUSH
24368: LD_VAR 0 2
24372: PPUSH
24373: LD_VAR 0 1
24377: PPUSH
24378: CALL_OW 248
24382: PPUSH
24383: CALL_OW 450
24387: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24388: LD_VAR 0 10
24392: PPUSH
24393: LD_INT 1
24395: PPUSH
24396: CALL_OW 275
24400: PUSH
24401: LD_VAR 0 11
24405: PUSH
24406: LD_INT 1
24408: ARRAY
24409: GREATEREQUAL
24410: PUSH
24411: LD_VAR 0 10
24415: PPUSH
24416: LD_INT 2
24418: PPUSH
24419: CALL_OW 275
24423: PUSH
24424: LD_VAR 0 11
24428: PUSH
24429: LD_INT 2
24431: ARRAY
24432: GREATEREQUAL
24433: AND
24434: PUSH
24435: LD_VAR 0 10
24439: PPUSH
24440: LD_INT 3
24442: PPUSH
24443: CALL_OW 275
24447: PUSH
24448: LD_VAR 0 11
24452: PUSH
24453: LD_INT 3
24455: ARRAY
24456: GREATEREQUAL
24457: AND
24458: NOT
24459: IFFALSE 24463
// exit ;
24461: GO 25050
// if GetBType ( depot ) = b_depot then
24463: LD_VAR 0 1
24467: PPUSH
24468: CALL_OW 266
24472: PUSH
24473: LD_INT 0
24475: EQUAL
24476: IFFALSE 24488
// dist := 28 else
24478: LD_ADDR_VAR 0 14
24482: PUSH
24483: LD_INT 28
24485: ST_TO_ADDR
24486: GO 24496
// dist := 36 ;
24488: LD_ADDR_VAR 0 14
24492: PUSH
24493: LD_INT 36
24495: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24496: LD_VAR 0 1
24500: PPUSH
24501: LD_VAR 0 3
24505: PPUSH
24506: LD_VAR 0 4
24510: PPUSH
24511: CALL_OW 297
24515: PUSH
24516: LD_VAR 0 14
24520: GREATER
24521: IFFALSE 24525
// exit ;
24523: GO 25050
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24525: LD_ADDR_VAR 0 12
24529: PUSH
24530: LD_VAR 0 2
24534: PPUSH
24535: LD_VAR 0 3
24539: PPUSH
24540: LD_VAR 0 4
24544: PPUSH
24545: LD_VAR 0 5
24549: PPUSH
24550: LD_VAR 0 1
24554: PPUSH
24555: CALL_OW 248
24559: PPUSH
24560: LD_INT 0
24562: PPUSH
24563: CALL 25055 0 6
24567: ST_TO_ADDR
// if not hexes then
24568: LD_VAR 0 12
24572: NOT
24573: IFFALSE 24577
// exit ;
24575: GO 25050
// hex := GetHexInfo ( x , y ) ;
24577: LD_ADDR_VAR 0 15
24581: PUSH
24582: LD_VAR 0 3
24586: PPUSH
24587: LD_VAR 0 4
24591: PPUSH
24592: CALL_OW 546
24596: ST_TO_ADDR
// if hex [ 1 ] then
24597: LD_VAR 0 15
24601: PUSH
24602: LD_INT 1
24604: ARRAY
24605: IFFALSE 24609
// exit ;
24607: GO 25050
// height := hex [ 2 ] ;
24609: LD_ADDR_VAR 0 13
24613: PUSH
24614: LD_VAR 0 15
24618: PUSH
24619: LD_INT 2
24621: ARRAY
24622: ST_TO_ADDR
// for i = 1 to hexes do
24623: LD_ADDR_VAR 0 7
24627: PUSH
24628: DOUBLE
24629: LD_INT 1
24631: DEC
24632: ST_TO_ADDR
24633: LD_VAR 0 12
24637: PUSH
24638: FOR_TO
24639: IFFALSE 24969
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24641: LD_VAR 0 12
24645: PUSH
24646: LD_VAR 0 7
24650: ARRAY
24651: PUSH
24652: LD_INT 1
24654: ARRAY
24655: PPUSH
24656: LD_VAR 0 12
24660: PUSH
24661: LD_VAR 0 7
24665: ARRAY
24666: PUSH
24667: LD_INT 2
24669: ARRAY
24670: PPUSH
24671: CALL_OW 488
24675: NOT
24676: PUSH
24677: LD_VAR 0 12
24681: PUSH
24682: LD_VAR 0 7
24686: ARRAY
24687: PUSH
24688: LD_INT 1
24690: ARRAY
24691: PPUSH
24692: LD_VAR 0 12
24696: PUSH
24697: LD_VAR 0 7
24701: ARRAY
24702: PUSH
24703: LD_INT 2
24705: ARRAY
24706: PPUSH
24707: CALL_OW 428
24711: PUSH
24712: LD_INT 0
24714: GREATER
24715: OR
24716: PUSH
24717: LD_VAR 0 12
24721: PUSH
24722: LD_VAR 0 7
24726: ARRAY
24727: PUSH
24728: LD_INT 1
24730: ARRAY
24731: PPUSH
24732: LD_VAR 0 12
24736: PUSH
24737: LD_VAR 0 7
24741: ARRAY
24742: PUSH
24743: LD_INT 2
24745: ARRAY
24746: PPUSH
24747: CALL_OW 351
24751: OR
24752: IFFALSE 24758
// exit ;
24754: POP
24755: POP
24756: GO 25050
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24758: LD_ADDR_VAR 0 8
24762: PUSH
24763: LD_VAR 0 12
24767: PUSH
24768: LD_VAR 0 7
24772: ARRAY
24773: PUSH
24774: LD_INT 1
24776: ARRAY
24777: PPUSH
24778: LD_VAR 0 12
24782: PUSH
24783: LD_VAR 0 7
24787: ARRAY
24788: PUSH
24789: LD_INT 2
24791: ARRAY
24792: PPUSH
24793: CALL_OW 546
24797: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24798: LD_VAR 0 8
24802: PUSH
24803: LD_INT 1
24805: ARRAY
24806: PUSH
24807: LD_VAR 0 8
24811: PUSH
24812: LD_INT 2
24814: ARRAY
24815: PUSH
24816: LD_VAR 0 13
24820: PUSH
24821: LD_INT 2
24823: PLUS
24824: GREATER
24825: OR
24826: PUSH
24827: LD_VAR 0 8
24831: PUSH
24832: LD_INT 2
24834: ARRAY
24835: PUSH
24836: LD_VAR 0 13
24840: PUSH
24841: LD_INT 2
24843: MINUS
24844: LESS
24845: OR
24846: PUSH
24847: LD_VAR 0 8
24851: PUSH
24852: LD_INT 3
24854: ARRAY
24855: PUSH
24856: LD_INT 0
24858: PUSH
24859: LD_INT 8
24861: PUSH
24862: LD_INT 9
24864: PUSH
24865: LD_INT 10
24867: PUSH
24868: LD_INT 11
24870: PUSH
24871: LD_INT 12
24873: PUSH
24874: LD_INT 13
24876: PUSH
24877: LD_INT 16
24879: PUSH
24880: LD_INT 17
24882: PUSH
24883: LD_INT 18
24885: PUSH
24886: LD_INT 19
24888: PUSH
24889: LD_INT 20
24891: PUSH
24892: LD_INT 21
24894: PUSH
24895: EMPTY
24896: LIST
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: LIST
24908: LIST
24909: IN
24910: NOT
24911: OR
24912: PUSH
24913: LD_VAR 0 8
24917: PUSH
24918: LD_INT 5
24920: ARRAY
24921: NOT
24922: OR
24923: PUSH
24924: LD_VAR 0 8
24928: PUSH
24929: LD_INT 6
24931: ARRAY
24932: PUSH
24933: LD_INT 1
24935: PUSH
24936: LD_INT 2
24938: PUSH
24939: LD_INT 7
24941: PUSH
24942: LD_INT 9
24944: PUSH
24945: LD_INT 10
24947: PUSH
24948: LD_INT 11
24950: PUSH
24951: EMPTY
24952: LIST
24953: LIST
24954: LIST
24955: LIST
24956: LIST
24957: LIST
24958: IN
24959: NOT
24960: OR
24961: IFFALSE 24967
// exit ;
24963: POP
24964: POP
24965: GO 25050
// end ;
24967: GO 24638
24969: POP
24970: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24971: LD_VAR 0 9
24975: PPUSH
24976: LD_VAR 0 3
24980: PPUSH
24981: LD_VAR 0 4
24985: PPUSH
24986: LD_INT 20
24988: PPUSH
24989: CALL 16973 0 4
24993: PUSH
24994: LD_INT 4
24996: ARRAY
24997: IFFALSE 25001
// exit ;
24999: GO 25050
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25001: LD_VAR 0 2
25005: PUSH
25006: LD_INT 29
25008: PUSH
25009: LD_INT 30
25011: PUSH
25012: EMPTY
25013: LIST
25014: LIST
25015: IN
25016: PUSH
25017: LD_VAR 0 3
25021: PPUSH
25022: LD_VAR 0 4
25026: PPUSH
25027: LD_VAR 0 9
25031: PPUSH
25032: CALL_OW 440
25036: NOT
25037: AND
25038: IFFALSE 25042
// exit ;
25040: GO 25050
// result := true ;
25042: LD_ADDR_VAR 0 6
25046: PUSH
25047: LD_INT 1
25049: ST_TO_ADDR
// end ;
25050: LD_VAR 0 6
25054: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25055: LD_INT 0
25057: PPUSH
25058: PPUSH
25059: PPUSH
25060: PPUSH
25061: PPUSH
25062: PPUSH
25063: PPUSH
25064: PPUSH
25065: PPUSH
25066: PPUSH
25067: PPUSH
25068: PPUSH
25069: PPUSH
25070: PPUSH
25071: PPUSH
25072: PPUSH
25073: PPUSH
25074: PPUSH
25075: PPUSH
25076: PPUSH
25077: PPUSH
25078: PPUSH
25079: PPUSH
25080: PPUSH
25081: PPUSH
25082: PPUSH
25083: PPUSH
25084: PPUSH
25085: PPUSH
25086: PPUSH
25087: PPUSH
25088: PPUSH
25089: PPUSH
25090: PPUSH
25091: PPUSH
25092: PPUSH
25093: PPUSH
25094: PPUSH
25095: PPUSH
25096: PPUSH
25097: PPUSH
25098: PPUSH
25099: PPUSH
25100: PPUSH
25101: PPUSH
25102: PPUSH
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
25114: PPUSH
// result = [ ] ;
25115: LD_ADDR_VAR 0 7
25119: PUSH
25120: EMPTY
25121: ST_TO_ADDR
// temp_list = [ ] ;
25122: LD_ADDR_VAR 0 9
25126: PUSH
25127: EMPTY
25128: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25129: LD_VAR 0 4
25133: PUSH
25134: LD_INT 0
25136: PUSH
25137: LD_INT 1
25139: PUSH
25140: LD_INT 2
25142: PUSH
25143: LD_INT 3
25145: PUSH
25146: LD_INT 4
25148: PUSH
25149: LD_INT 5
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: LIST
25156: LIST
25157: LIST
25158: LIST
25159: IN
25160: NOT
25161: PUSH
25162: LD_VAR 0 1
25166: PUSH
25167: LD_INT 0
25169: PUSH
25170: LD_INT 1
25172: PUSH
25173: EMPTY
25174: LIST
25175: LIST
25176: IN
25177: PUSH
25178: LD_VAR 0 5
25182: PUSH
25183: LD_INT 1
25185: PUSH
25186: LD_INT 2
25188: PUSH
25189: LD_INT 3
25191: PUSH
25192: EMPTY
25193: LIST
25194: LIST
25195: LIST
25196: IN
25197: NOT
25198: AND
25199: OR
25200: IFFALSE 25204
// exit ;
25202: GO 43595
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25204: LD_VAR 0 1
25208: PUSH
25209: LD_INT 6
25211: PUSH
25212: LD_INT 7
25214: PUSH
25215: LD_INT 8
25217: PUSH
25218: LD_INT 13
25220: PUSH
25221: LD_INT 12
25223: PUSH
25224: LD_INT 15
25226: PUSH
25227: LD_INT 11
25229: PUSH
25230: LD_INT 14
25232: PUSH
25233: LD_INT 10
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: IN
25247: IFFALSE 25257
// btype = b_lab ;
25249: LD_ADDR_VAR 0 1
25253: PUSH
25254: LD_INT 6
25256: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25257: LD_VAR 0 6
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: LD_INT 1
25267: PUSH
25268: LD_INT 2
25270: PUSH
25271: EMPTY
25272: LIST
25273: LIST
25274: LIST
25275: IN
25276: NOT
25277: PUSH
25278: LD_VAR 0 1
25282: PUSH
25283: LD_INT 0
25285: PUSH
25286: LD_INT 1
25288: PUSH
25289: LD_INT 2
25291: PUSH
25292: LD_INT 3
25294: PUSH
25295: LD_INT 6
25297: PUSH
25298: LD_INT 36
25300: PUSH
25301: LD_INT 4
25303: PUSH
25304: LD_INT 5
25306: PUSH
25307: LD_INT 31
25309: PUSH
25310: LD_INT 32
25312: PUSH
25313: LD_INT 33
25315: PUSH
25316: EMPTY
25317: LIST
25318: LIST
25319: LIST
25320: LIST
25321: LIST
25322: LIST
25323: LIST
25324: LIST
25325: LIST
25326: LIST
25327: LIST
25328: IN
25329: NOT
25330: PUSH
25331: LD_VAR 0 6
25335: PUSH
25336: LD_INT 1
25338: EQUAL
25339: AND
25340: OR
25341: PUSH
25342: LD_VAR 0 1
25346: PUSH
25347: LD_INT 2
25349: PUSH
25350: LD_INT 3
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: IN
25357: NOT
25358: PUSH
25359: LD_VAR 0 6
25363: PUSH
25364: LD_INT 2
25366: EQUAL
25367: AND
25368: OR
25369: IFFALSE 25379
// mode = 0 ;
25371: LD_ADDR_VAR 0 6
25375: PUSH
25376: LD_INT 0
25378: ST_TO_ADDR
// case mode of 0 :
25379: LD_VAR 0 6
25383: PUSH
25384: LD_INT 0
25386: DOUBLE
25387: EQUAL
25388: IFTRUE 25392
25390: GO 36845
25392: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25393: LD_ADDR_VAR 0 11
25397: PUSH
25398: LD_INT 0
25400: PUSH
25401: LD_INT 0
25403: PUSH
25404: EMPTY
25405: LIST
25406: LIST
25407: PUSH
25408: LD_INT 0
25410: PUSH
25411: LD_INT 1
25413: NEG
25414: PUSH
25415: EMPTY
25416: LIST
25417: LIST
25418: PUSH
25419: LD_INT 1
25421: PUSH
25422: LD_INT 0
25424: PUSH
25425: EMPTY
25426: LIST
25427: LIST
25428: PUSH
25429: LD_INT 1
25431: PUSH
25432: LD_INT 1
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: PUSH
25439: LD_INT 0
25441: PUSH
25442: LD_INT 1
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: PUSH
25449: LD_INT 1
25451: NEG
25452: PUSH
25453: LD_INT 0
25455: PUSH
25456: EMPTY
25457: LIST
25458: LIST
25459: PUSH
25460: LD_INT 1
25462: NEG
25463: PUSH
25464: LD_INT 1
25466: NEG
25467: PUSH
25468: EMPTY
25469: LIST
25470: LIST
25471: PUSH
25472: LD_INT 1
25474: NEG
25475: PUSH
25476: LD_INT 2
25478: NEG
25479: PUSH
25480: EMPTY
25481: LIST
25482: LIST
25483: PUSH
25484: LD_INT 0
25486: PUSH
25487: LD_INT 2
25489: NEG
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: LD_INT 1
25497: PUSH
25498: LD_INT 1
25500: NEG
25501: PUSH
25502: EMPTY
25503: LIST
25504: LIST
25505: PUSH
25506: LD_INT 1
25508: PUSH
25509: LD_INT 2
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: PUSH
25516: LD_INT 0
25518: PUSH
25519: LD_INT 2
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 1
25528: NEG
25529: PUSH
25530: LD_INT 1
25532: PUSH
25533: EMPTY
25534: LIST
25535: LIST
25536: PUSH
25537: LD_INT 1
25539: PUSH
25540: LD_INT 3
25542: PUSH
25543: EMPTY
25544: LIST
25545: LIST
25546: PUSH
25547: LD_INT 0
25549: PUSH
25550: LD_INT 3
25552: PUSH
25553: EMPTY
25554: LIST
25555: LIST
25556: PUSH
25557: LD_INT 1
25559: NEG
25560: PUSH
25561: LD_INT 2
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: LIST
25572: LIST
25573: LIST
25574: LIST
25575: LIST
25576: LIST
25577: LIST
25578: LIST
25579: LIST
25580: LIST
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25586: LD_ADDR_VAR 0 12
25590: PUSH
25591: LD_INT 0
25593: PUSH
25594: LD_INT 0
25596: PUSH
25597: EMPTY
25598: LIST
25599: LIST
25600: PUSH
25601: LD_INT 0
25603: PUSH
25604: LD_INT 1
25606: NEG
25607: PUSH
25608: EMPTY
25609: LIST
25610: LIST
25611: PUSH
25612: LD_INT 1
25614: PUSH
25615: LD_INT 0
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PUSH
25622: LD_INT 1
25624: PUSH
25625: LD_INT 1
25627: PUSH
25628: EMPTY
25629: LIST
25630: LIST
25631: PUSH
25632: LD_INT 0
25634: PUSH
25635: LD_INT 1
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 1
25644: NEG
25645: PUSH
25646: LD_INT 0
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 1
25655: NEG
25656: PUSH
25657: LD_INT 1
25659: NEG
25660: PUSH
25661: EMPTY
25662: LIST
25663: LIST
25664: PUSH
25665: LD_INT 1
25667: PUSH
25668: LD_INT 1
25670: NEG
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 2
25678: PUSH
25679: LD_INT 0
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 2
25688: PUSH
25689: LD_INT 1
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: PUSH
25696: LD_INT 1
25698: NEG
25699: PUSH
25700: LD_INT 1
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: PUSH
25707: LD_INT 2
25709: NEG
25710: PUSH
25711: LD_INT 0
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: LD_INT 2
25720: NEG
25721: PUSH
25722: LD_INT 1
25724: NEG
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PUSH
25730: LD_INT 2
25732: NEG
25733: PUSH
25734: LD_INT 1
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: LD_INT 3
25743: NEG
25744: PUSH
25745: LD_INT 0
25747: PUSH
25748: EMPTY
25749: LIST
25750: LIST
25751: PUSH
25752: LD_INT 3
25754: NEG
25755: PUSH
25756: LD_INT 1
25758: NEG
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: LIST
25772: LIST
25773: LIST
25774: LIST
25775: LIST
25776: LIST
25777: LIST
25778: LIST
25779: LIST
25780: LIST
25781: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25782: LD_ADDR_VAR 0 13
25786: PUSH
25787: LD_INT 0
25789: PUSH
25790: LD_INT 0
25792: PUSH
25793: EMPTY
25794: LIST
25795: LIST
25796: PUSH
25797: LD_INT 0
25799: PUSH
25800: LD_INT 1
25802: NEG
25803: PUSH
25804: EMPTY
25805: LIST
25806: LIST
25807: PUSH
25808: LD_INT 1
25810: PUSH
25811: LD_INT 0
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PUSH
25818: LD_INT 1
25820: PUSH
25821: LD_INT 1
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 0
25830: PUSH
25831: LD_INT 1
25833: PUSH
25834: EMPTY
25835: LIST
25836: LIST
25837: PUSH
25838: LD_INT 1
25840: NEG
25841: PUSH
25842: LD_INT 0
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PUSH
25849: LD_INT 1
25851: NEG
25852: PUSH
25853: LD_INT 1
25855: NEG
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PUSH
25861: LD_INT 1
25863: NEG
25864: PUSH
25865: LD_INT 2
25867: NEG
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 2
25875: PUSH
25876: LD_INT 1
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: LD_INT 2
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 1
25895: PUSH
25896: LD_INT 2
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: LD_INT 2
25905: NEG
25906: PUSH
25907: LD_INT 1
25909: NEG
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 2
25917: NEG
25918: PUSH
25919: LD_INT 2
25921: NEG
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: PUSH
25927: LD_INT 2
25929: NEG
25930: PUSH
25931: LD_INT 3
25933: NEG
25934: PUSH
25935: EMPTY
25936: LIST
25937: LIST
25938: PUSH
25939: LD_INT 3
25941: NEG
25942: PUSH
25943: LD_INT 2
25945: NEG
25946: PUSH
25947: EMPTY
25948: LIST
25949: LIST
25950: PUSH
25951: LD_INT 3
25953: NEG
25954: PUSH
25955: LD_INT 3
25957: NEG
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PUSH
25963: EMPTY
25964: LIST
25965: LIST
25966: LIST
25967: LIST
25968: LIST
25969: LIST
25970: LIST
25971: LIST
25972: LIST
25973: LIST
25974: LIST
25975: LIST
25976: LIST
25977: LIST
25978: LIST
25979: LIST
25980: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25981: LD_ADDR_VAR 0 14
25985: PUSH
25986: LD_INT 0
25988: PUSH
25989: LD_INT 0
25991: PUSH
25992: EMPTY
25993: LIST
25994: LIST
25995: PUSH
25996: LD_INT 0
25998: PUSH
25999: LD_INT 1
26001: NEG
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PUSH
26007: LD_INT 1
26009: PUSH
26010: LD_INT 0
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: LD_INT 1
26019: PUSH
26020: LD_INT 1
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PUSH
26027: LD_INT 0
26029: PUSH
26030: LD_INT 1
26032: PUSH
26033: EMPTY
26034: LIST
26035: LIST
26036: PUSH
26037: LD_INT 1
26039: NEG
26040: PUSH
26041: LD_INT 0
26043: PUSH
26044: EMPTY
26045: LIST
26046: LIST
26047: PUSH
26048: LD_INT 1
26050: NEG
26051: PUSH
26052: LD_INT 1
26054: NEG
26055: PUSH
26056: EMPTY
26057: LIST
26058: LIST
26059: PUSH
26060: LD_INT 1
26062: NEG
26063: PUSH
26064: LD_INT 2
26066: NEG
26067: PUSH
26068: EMPTY
26069: LIST
26070: LIST
26071: PUSH
26072: LD_INT 0
26074: PUSH
26075: LD_INT 2
26077: NEG
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 1
26085: PUSH
26086: LD_INT 1
26088: NEG
26089: PUSH
26090: EMPTY
26091: LIST
26092: LIST
26093: PUSH
26094: LD_INT 1
26096: PUSH
26097: LD_INT 2
26099: PUSH
26100: EMPTY
26101: LIST
26102: LIST
26103: PUSH
26104: LD_INT 0
26106: PUSH
26107: LD_INT 2
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: LD_INT 1
26116: NEG
26117: PUSH
26118: LD_INT 1
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: PUSH
26125: LD_INT 1
26127: NEG
26128: PUSH
26129: LD_INT 3
26131: NEG
26132: PUSH
26133: EMPTY
26134: LIST
26135: LIST
26136: PUSH
26137: LD_INT 0
26139: PUSH
26140: LD_INT 3
26142: NEG
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: LD_INT 1
26150: PUSH
26151: LD_INT 2
26153: NEG
26154: PUSH
26155: EMPTY
26156: LIST
26157: LIST
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: LIST
26163: LIST
26164: LIST
26165: LIST
26166: LIST
26167: LIST
26168: LIST
26169: LIST
26170: LIST
26171: LIST
26172: LIST
26173: LIST
26174: LIST
26175: LIST
26176: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26177: LD_ADDR_VAR 0 15
26181: PUSH
26182: LD_INT 0
26184: PUSH
26185: LD_INT 0
26187: PUSH
26188: EMPTY
26189: LIST
26190: LIST
26191: PUSH
26192: LD_INT 0
26194: PUSH
26195: LD_INT 1
26197: NEG
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: PUSH
26203: LD_INT 1
26205: PUSH
26206: LD_INT 0
26208: PUSH
26209: EMPTY
26210: LIST
26211: LIST
26212: PUSH
26213: LD_INT 1
26215: PUSH
26216: LD_INT 1
26218: PUSH
26219: EMPTY
26220: LIST
26221: LIST
26222: PUSH
26223: LD_INT 0
26225: PUSH
26226: LD_INT 1
26228: PUSH
26229: EMPTY
26230: LIST
26231: LIST
26232: PUSH
26233: LD_INT 1
26235: NEG
26236: PUSH
26237: LD_INT 0
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: LD_INT 1
26246: NEG
26247: PUSH
26248: LD_INT 1
26250: NEG
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 1
26258: PUSH
26259: LD_INT 1
26261: NEG
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: PUSH
26267: LD_INT 2
26269: PUSH
26270: LD_INT 0
26272: PUSH
26273: EMPTY
26274: LIST
26275: LIST
26276: PUSH
26277: LD_INT 2
26279: PUSH
26280: LD_INT 1
26282: PUSH
26283: EMPTY
26284: LIST
26285: LIST
26286: PUSH
26287: LD_INT 1
26289: NEG
26290: PUSH
26291: LD_INT 1
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: PUSH
26298: LD_INT 2
26300: NEG
26301: PUSH
26302: LD_INT 0
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: PUSH
26309: LD_INT 2
26311: NEG
26312: PUSH
26313: LD_INT 1
26315: NEG
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: PUSH
26321: LD_INT 2
26323: PUSH
26324: LD_INT 1
26326: NEG
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 3
26334: PUSH
26335: LD_INT 0
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: LD_INT 3
26344: PUSH
26345: LD_INT 1
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: LIST
26356: LIST
26357: LIST
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: LIST
26365: LIST
26366: LIST
26367: LIST
26368: LIST
26369: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26370: LD_ADDR_VAR 0 16
26374: PUSH
26375: LD_INT 0
26377: PUSH
26378: LD_INT 0
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 0
26387: PUSH
26388: LD_INT 1
26390: NEG
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: LD_INT 1
26398: PUSH
26399: LD_INT 0
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: PUSH
26406: LD_INT 1
26408: PUSH
26409: LD_INT 1
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: LD_INT 0
26418: PUSH
26419: LD_INT 1
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: PUSH
26426: LD_INT 1
26428: NEG
26429: PUSH
26430: LD_INT 0
26432: PUSH
26433: EMPTY
26434: LIST
26435: LIST
26436: PUSH
26437: LD_INT 1
26439: NEG
26440: PUSH
26441: LD_INT 1
26443: NEG
26444: PUSH
26445: EMPTY
26446: LIST
26447: LIST
26448: PUSH
26449: LD_INT 1
26451: NEG
26452: PUSH
26453: LD_INT 2
26455: NEG
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PUSH
26461: LD_INT 2
26463: PUSH
26464: LD_INT 1
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PUSH
26471: LD_INT 2
26473: PUSH
26474: LD_INT 2
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: PUSH
26481: LD_INT 1
26483: PUSH
26484: LD_INT 2
26486: PUSH
26487: EMPTY
26488: LIST
26489: LIST
26490: PUSH
26491: LD_INT 2
26493: NEG
26494: PUSH
26495: LD_INT 1
26497: NEG
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: LD_INT 2
26505: NEG
26506: PUSH
26507: LD_INT 2
26509: NEG
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 3
26517: PUSH
26518: LD_INT 2
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: PUSH
26525: LD_INT 3
26527: PUSH
26528: LD_INT 3
26530: PUSH
26531: EMPTY
26532: LIST
26533: LIST
26534: PUSH
26535: LD_INT 2
26537: PUSH
26538: LD_INT 3
26540: PUSH
26541: EMPTY
26542: LIST
26543: LIST
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: LIST
26549: LIST
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26563: LD_ADDR_VAR 0 17
26567: PUSH
26568: LD_INT 0
26570: PUSH
26571: LD_INT 0
26573: PUSH
26574: EMPTY
26575: LIST
26576: LIST
26577: PUSH
26578: LD_INT 0
26580: PUSH
26581: LD_INT 1
26583: NEG
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: PUSH
26589: LD_INT 1
26591: PUSH
26592: LD_INT 0
26594: PUSH
26595: EMPTY
26596: LIST
26597: LIST
26598: PUSH
26599: LD_INT 1
26601: PUSH
26602: LD_INT 1
26604: PUSH
26605: EMPTY
26606: LIST
26607: LIST
26608: PUSH
26609: LD_INT 0
26611: PUSH
26612: LD_INT 1
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PUSH
26619: LD_INT 1
26621: NEG
26622: PUSH
26623: LD_INT 0
26625: PUSH
26626: EMPTY
26627: LIST
26628: LIST
26629: PUSH
26630: LD_INT 1
26632: NEG
26633: PUSH
26634: LD_INT 1
26636: NEG
26637: PUSH
26638: EMPTY
26639: LIST
26640: LIST
26641: PUSH
26642: LD_INT 1
26644: NEG
26645: PUSH
26646: LD_INT 2
26648: NEG
26649: PUSH
26650: EMPTY
26651: LIST
26652: LIST
26653: PUSH
26654: LD_INT 0
26656: PUSH
26657: LD_INT 2
26659: NEG
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: PUSH
26665: LD_INT 1
26667: PUSH
26668: LD_INT 1
26670: NEG
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: PUSH
26676: LD_INT 2
26678: PUSH
26679: LD_INT 0
26681: PUSH
26682: EMPTY
26683: LIST
26684: LIST
26685: PUSH
26686: LD_INT 2
26688: PUSH
26689: LD_INT 1
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 2
26698: PUSH
26699: LD_INT 2
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 1
26708: PUSH
26709: LD_INT 2
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 0
26718: PUSH
26719: LD_INT 2
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 1
26728: NEG
26729: PUSH
26730: LD_INT 1
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PUSH
26737: LD_INT 2
26739: NEG
26740: PUSH
26741: LD_INT 0
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: PUSH
26748: LD_INT 2
26750: NEG
26751: PUSH
26752: LD_INT 1
26754: NEG
26755: PUSH
26756: EMPTY
26757: LIST
26758: LIST
26759: PUSH
26760: LD_INT 2
26762: NEG
26763: PUSH
26764: LD_INT 2
26766: NEG
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: LIST
26779: LIST
26780: LIST
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: LIST
26786: LIST
26787: LIST
26788: LIST
26789: LIST
26790: LIST
26791: LIST
26792: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26793: LD_ADDR_VAR 0 18
26797: PUSH
26798: LD_INT 0
26800: PUSH
26801: LD_INT 0
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: PUSH
26808: LD_INT 0
26810: PUSH
26811: LD_INT 1
26813: NEG
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: PUSH
26819: LD_INT 1
26821: PUSH
26822: LD_INT 0
26824: PUSH
26825: EMPTY
26826: LIST
26827: LIST
26828: PUSH
26829: LD_INT 1
26831: PUSH
26832: LD_INT 1
26834: PUSH
26835: EMPTY
26836: LIST
26837: LIST
26838: PUSH
26839: LD_INT 0
26841: PUSH
26842: LD_INT 1
26844: PUSH
26845: EMPTY
26846: LIST
26847: LIST
26848: PUSH
26849: LD_INT 1
26851: NEG
26852: PUSH
26853: LD_INT 0
26855: PUSH
26856: EMPTY
26857: LIST
26858: LIST
26859: PUSH
26860: LD_INT 1
26862: NEG
26863: PUSH
26864: LD_INT 1
26866: NEG
26867: PUSH
26868: EMPTY
26869: LIST
26870: LIST
26871: PUSH
26872: LD_INT 1
26874: NEG
26875: PUSH
26876: LD_INT 2
26878: NEG
26879: PUSH
26880: EMPTY
26881: LIST
26882: LIST
26883: PUSH
26884: LD_INT 0
26886: PUSH
26887: LD_INT 2
26889: NEG
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 1
26897: PUSH
26898: LD_INT 1
26900: NEG
26901: PUSH
26902: EMPTY
26903: LIST
26904: LIST
26905: PUSH
26906: LD_INT 2
26908: PUSH
26909: LD_INT 0
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: PUSH
26916: LD_INT 2
26918: PUSH
26919: LD_INT 1
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: PUSH
26926: LD_INT 2
26928: PUSH
26929: LD_INT 2
26931: PUSH
26932: EMPTY
26933: LIST
26934: LIST
26935: PUSH
26936: LD_INT 1
26938: PUSH
26939: LD_INT 2
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 0
26948: PUSH
26949: LD_INT 2
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: LD_INT 1
26958: NEG
26959: PUSH
26960: LD_INT 1
26962: PUSH
26963: EMPTY
26964: LIST
26965: LIST
26966: PUSH
26967: LD_INT 2
26969: NEG
26970: PUSH
26971: LD_INT 0
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PUSH
26978: LD_INT 2
26980: NEG
26981: PUSH
26982: LD_INT 1
26984: NEG
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PUSH
26990: LD_INT 2
26992: NEG
26993: PUSH
26994: LD_INT 2
26996: NEG
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: LIST
27006: LIST
27007: LIST
27008: LIST
27009: LIST
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: LIST
27022: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27023: LD_ADDR_VAR 0 19
27027: PUSH
27028: LD_INT 0
27030: PUSH
27031: LD_INT 0
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: PUSH
27038: LD_INT 0
27040: PUSH
27041: LD_INT 1
27043: NEG
27044: PUSH
27045: EMPTY
27046: LIST
27047: LIST
27048: PUSH
27049: LD_INT 1
27051: PUSH
27052: LD_INT 0
27054: PUSH
27055: EMPTY
27056: LIST
27057: LIST
27058: PUSH
27059: LD_INT 1
27061: PUSH
27062: LD_INT 1
27064: PUSH
27065: EMPTY
27066: LIST
27067: LIST
27068: PUSH
27069: LD_INT 0
27071: PUSH
27072: LD_INT 1
27074: PUSH
27075: EMPTY
27076: LIST
27077: LIST
27078: PUSH
27079: LD_INT 1
27081: NEG
27082: PUSH
27083: LD_INT 0
27085: PUSH
27086: EMPTY
27087: LIST
27088: LIST
27089: PUSH
27090: LD_INT 1
27092: NEG
27093: PUSH
27094: LD_INT 1
27096: NEG
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 1
27104: NEG
27105: PUSH
27106: LD_INT 2
27108: NEG
27109: PUSH
27110: EMPTY
27111: LIST
27112: LIST
27113: PUSH
27114: LD_INT 0
27116: PUSH
27117: LD_INT 2
27119: NEG
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: LD_INT 1
27127: PUSH
27128: LD_INT 1
27130: NEG
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: PUSH
27136: LD_INT 2
27138: PUSH
27139: LD_INT 0
27141: PUSH
27142: EMPTY
27143: LIST
27144: LIST
27145: PUSH
27146: LD_INT 2
27148: PUSH
27149: LD_INT 1
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: PUSH
27156: LD_INT 2
27158: PUSH
27159: LD_INT 2
27161: PUSH
27162: EMPTY
27163: LIST
27164: LIST
27165: PUSH
27166: LD_INT 1
27168: PUSH
27169: LD_INT 2
27171: PUSH
27172: EMPTY
27173: LIST
27174: LIST
27175: PUSH
27176: LD_INT 0
27178: PUSH
27179: LD_INT 2
27181: PUSH
27182: EMPTY
27183: LIST
27184: LIST
27185: PUSH
27186: LD_INT 1
27188: NEG
27189: PUSH
27190: LD_INT 1
27192: PUSH
27193: EMPTY
27194: LIST
27195: LIST
27196: PUSH
27197: LD_INT 2
27199: NEG
27200: PUSH
27201: LD_INT 0
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PUSH
27208: LD_INT 2
27210: NEG
27211: PUSH
27212: LD_INT 1
27214: NEG
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: PUSH
27220: LD_INT 2
27222: NEG
27223: PUSH
27224: LD_INT 2
27226: NEG
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: LIST
27236: LIST
27237: LIST
27238: LIST
27239: LIST
27240: LIST
27241: LIST
27242: LIST
27243: LIST
27244: LIST
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: LIST
27252: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27253: LD_ADDR_VAR 0 20
27257: PUSH
27258: LD_INT 0
27260: PUSH
27261: LD_INT 0
27263: PUSH
27264: EMPTY
27265: LIST
27266: LIST
27267: PUSH
27268: LD_INT 0
27270: PUSH
27271: LD_INT 1
27273: NEG
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: PUSH
27279: LD_INT 1
27281: PUSH
27282: LD_INT 0
27284: PUSH
27285: EMPTY
27286: LIST
27287: LIST
27288: PUSH
27289: LD_INT 1
27291: PUSH
27292: LD_INT 1
27294: PUSH
27295: EMPTY
27296: LIST
27297: LIST
27298: PUSH
27299: LD_INT 0
27301: PUSH
27302: LD_INT 1
27304: PUSH
27305: EMPTY
27306: LIST
27307: LIST
27308: PUSH
27309: LD_INT 1
27311: NEG
27312: PUSH
27313: LD_INT 0
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: PUSH
27320: LD_INT 1
27322: NEG
27323: PUSH
27324: LD_INT 1
27326: NEG
27327: PUSH
27328: EMPTY
27329: LIST
27330: LIST
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: PUSH
27336: LD_INT 2
27338: NEG
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 0
27346: PUSH
27347: LD_INT 2
27349: NEG
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 1
27357: PUSH
27358: LD_INT 1
27360: NEG
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 2
27368: PUSH
27369: LD_INT 0
27371: PUSH
27372: EMPTY
27373: LIST
27374: LIST
27375: PUSH
27376: LD_INT 2
27378: PUSH
27379: LD_INT 1
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: PUSH
27386: LD_INT 2
27388: PUSH
27389: LD_INT 2
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PUSH
27396: LD_INT 1
27398: PUSH
27399: LD_INT 2
27401: PUSH
27402: EMPTY
27403: LIST
27404: LIST
27405: PUSH
27406: LD_INT 0
27408: PUSH
27409: LD_INT 2
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: PUSH
27416: LD_INT 1
27418: NEG
27419: PUSH
27420: LD_INT 1
27422: PUSH
27423: EMPTY
27424: LIST
27425: LIST
27426: PUSH
27427: LD_INT 2
27429: NEG
27430: PUSH
27431: LD_INT 0
27433: PUSH
27434: EMPTY
27435: LIST
27436: LIST
27437: PUSH
27438: LD_INT 2
27440: NEG
27441: PUSH
27442: LD_INT 1
27444: NEG
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: PUSH
27450: LD_INT 2
27452: NEG
27453: PUSH
27454: LD_INT 2
27456: NEG
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: EMPTY
27463: LIST
27464: LIST
27465: LIST
27466: LIST
27467: LIST
27468: LIST
27469: LIST
27470: LIST
27471: LIST
27472: LIST
27473: LIST
27474: LIST
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: LIST
27481: LIST
27482: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27483: LD_ADDR_VAR 0 21
27487: PUSH
27488: LD_INT 0
27490: PUSH
27491: LD_INT 0
27493: PUSH
27494: EMPTY
27495: LIST
27496: LIST
27497: PUSH
27498: LD_INT 0
27500: PUSH
27501: LD_INT 1
27503: NEG
27504: PUSH
27505: EMPTY
27506: LIST
27507: LIST
27508: PUSH
27509: LD_INT 1
27511: PUSH
27512: LD_INT 0
27514: PUSH
27515: EMPTY
27516: LIST
27517: LIST
27518: PUSH
27519: LD_INT 1
27521: PUSH
27522: LD_INT 1
27524: PUSH
27525: EMPTY
27526: LIST
27527: LIST
27528: PUSH
27529: LD_INT 0
27531: PUSH
27532: LD_INT 1
27534: PUSH
27535: EMPTY
27536: LIST
27537: LIST
27538: PUSH
27539: LD_INT 1
27541: NEG
27542: PUSH
27543: LD_INT 0
27545: PUSH
27546: EMPTY
27547: LIST
27548: LIST
27549: PUSH
27550: LD_INT 1
27552: NEG
27553: PUSH
27554: LD_INT 1
27556: NEG
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: PUSH
27562: LD_INT 1
27564: NEG
27565: PUSH
27566: LD_INT 2
27568: NEG
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: PUSH
27574: LD_INT 0
27576: PUSH
27577: LD_INT 2
27579: NEG
27580: PUSH
27581: EMPTY
27582: LIST
27583: LIST
27584: PUSH
27585: LD_INT 1
27587: PUSH
27588: LD_INT 1
27590: NEG
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: PUSH
27596: LD_INT 2
27598: PUSH
27599: LD_INT 0
27601: PUSH
27602: EMPTY
27603: LIST
27604: LIST
27605: PUSH
27606: LD_INT 2
27608: PUSH
27609: LD_INT 1
27611: PUSH
27612: EMPTY
27613: LIST
27614: LIST
27615: PUSH
27616: LD_INT 2
27618: PUSH
27619: LD_INT 2
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: PUSH
27626: LD_INT 1
27628: PUSH
27629: LD_INT 2
27631: PUSH
27632: EMPTY
27633: LIST
27634: LIST
27635: PUSH
27636: LD_INT 0
27638: PUSH
27639: LD_INT 2
27641: PUSH
27642: EMPTY
27643: LIST
27644: LIST
27645: PUSH
27646: LD_INT 1
27648: NEG
27649: PUSH
27650: LD_INT 1
27652: PUSH
27653: EMPTY
27654: LIST
27655: LIST
27656: PUSH
27657: LD_INT 2
27659: NEG
27660: PUSH
27661: LD_INT 0
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: PUSH
27668: LD_INT 2
27670: NEG
27671: PUSH
27672: LD_INT 1
27674: NEG
27675: PUSH
27676: EMPTY
27677: LIST
27678: LIST
27679: PUSH
27680: LD_INT 2
27682: NEG
27683: PUSH
27684: LD_INT 2
27686: NEG
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: LIST
27696: LIST
27697: LIST
27698: LIST
27699: LIST
27700: LIST
27701: LIST
27702: LIST
27703: LIST
27704: LIST
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: LIST
27711: LIST
27712: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27713: LD_ADDR_VAR 0 22
27717: PUSH
27718: LD_INT 0
27720: PUSH
27721: LD_INT 0
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: PUSH
27728: LD_INT 0
27730: PUSH
27731: LD_INT 1
27733: NEG
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 1
27741: PUSH
27742: LD_INT 0
27744: PUSH
27745: EMPTY
27746: LIST
27747: LIST
27748: PUSH
27749: LD_INT 1
27751: PUSH
27752: LD_INT 1
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: PUSH
27759: LD_INT 0
27761: PUSH
27762: LD_INT 1
27764: PUSH
27765: EMPTY
27766: LIST
27767: LIST
27768: PUSH
27769: LD_INT 1
27771: NEG
27772: PUSH
27773: LD_INT 0
27775: PUSH
27776: EMPTY
27777: LIST
27778: LIST
27779: PUSH
27780: LD_INT 1
27782: NEG
27783: PUSH
27784: LD_INT 1
27786: NEG
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: LD_INT 2
27798: NEG
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 0
27806: PUSH
27807: LD_INT 2
27809: NEG
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 1
27817: PUSH
27818: LD_INT 1
27820: NEG
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 2
27828: PUSH
27829: LD_INT 0
27831: PUSH
27832: EMPTY
27833: LIST
27834: LIST
27835: PUSH
27836: LD_INT 2
27838: PUSH
27839: LD_INT 1
27841: PUSH
27842: EMPTY
27843: LIST
27844: LIST
27845: PUSH
27846: LD_INT 2
27848: PUSH
27849: LD_INT 2
27851: PUSH
27852: EMPTY
27853: LIST
27854: LIST
27855: PUSH
27856: LD_INT 1
27858: PUSH
27859: LD_INT 2
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: LD_INT 0
27868: PUSH
27869: LD_INT 2
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: PUSH
27876: LD_INT 1
27878: NEG
27879: PUSH
27880: LD_INT 1
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PUSH
27887: LD_INT 2
27889: NEG
27890: PUSH
27891: LD_INT 0
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: LD_INT 2
27900: NEG
27901: PUSH
27902: LD_INT 1
27904: NEG
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: PUSH
27910: LD_INT 2
27912: NEG
27913: PUSH
27914: LD_INT 2
27916: NEG
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: LIST
27926: LIST
27927: LIST
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: LIST
27933: LIST
27934: LIST
27935: LIST
27936: LIST
27937: LIST
27938: LIST
27939: LIST
27940: LIST
27941: LIST
27942: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27943: LD_ADDR_VAR 0 23
27947: PUSH
27948: LD_INT 0
27950: PUSH
27951: LD_INT 0
27953: PUSH
27954: EMPTY
27955: LIST
27956: LIST
27957: PUSH
27958: LD_INT 0
27960: PUSH
27961: LD_INT 1
27963: NEG
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: LD_INT 0
27974: PUSH
27975: EMPTY
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 1
27981: PUSH
27982: LD_INT 1
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 0
27991: PUSH
27992: LD_INT 1
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PUSH
27999: LD_INT 1
28001: NEG
28002: PUSH
28003: LD_INT 0
28005: PUSH
28006: EMPTY
28007: LIST
28008: LIST
28009: PUSH
28010: LD_INT 1
28012: NEG
28013: PUSH
28014: LD_INT 1
28016: NEG
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: LD_INT 2
28028: NEG
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: PUSH
28034: LD_INT 0
28036: PUSH
28037: LD_INT 2
28039: NEG
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 1
28047: PUSH
28048: LD_INT 1
28050: NEG
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 2
28058: PUSH
28059: LD_INT 0
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 2
28068: PUSH
28069: LD_INT 1
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: LD_INT 2
28078: PUSH
28079: LD_INT 2
28081: PUSH
28082: EMPTY
28083: LIST
28084: LIST
28085: PUSH
28086: LD_INT 1
28088: PUSH
28089: LD_INT 2
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: LD_INT 0
28098: PUSH
28099: LD_INT 2
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 1
28108: NEG
28109: PUSH
28110: LD_INT 1
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 2
28119: NEG
28120: PUSH
28121: LD_INT 0
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 2
28130: NEG
28131: PUSH
28132: LD_INT 1
28134: NEG
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PUSH
28140: LD_INT 2
28142: NEG
28143: PUSH
28144: LD_INT 2
28146: NEG
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: PUSH
28152: LD_INT 2
28154: NEG
28155: PUSH
28156: LD_INT 3
28158: NEG
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: LD_INT 1
28166: NEG
28167: PUSH
28168: LD_INT 3
28170: NEG
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 1
28178: PUSH
28179: LD_INT 2
28181: NEG
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 2
28189: PUSH
28190: LD_INT 1
28192: NEG
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: PUSH
28198: EMPTY
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: LIST
28212: LIST
28213: LIST
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: LIST
28219: LIST
28220: LIST
28221: LIST
28222: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28223: LD_ADDR_VAR 0 24
28227: PUSH
28228: LD_INT 0
28230: PUSH
28231: LD_INT 0
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 0
28240: PUSH
28241: LD_INT 1
28243: NEG
28244: PUSH
28245: EMPTY
28246: LIST
28247: LIST
28248: PUSH
28249: LD_INT 1
28251: PUSH
28252: LD_INT 0
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 1
28261: PUSH
28262: LD_INT 1
28264: PUSH
28265: EMPTY
28266: LIST
28267: LIST
28268: PUSH
28269: LD_INT 0
28271: PUSH
28272: LD_INT 1
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: LD_INT 0
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 1
28292: NEG
28293: PUSH
28294: LD_INT 1
28296: NEG
28297: PUSH
28298: EMPTY
28299: LIST
28300: LIST
28301: PUSH
28302: LD_INT 1
28304: NEG
28305: PUSH
28306: LD_INT 2
28308: NEG
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 0
28316: PUSH
28317: LD_INT 2
28319: NEG
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 1
28327: PUSH
28328: LD_INT 1
28330: NEG
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: LD_INT 2
28338: PUSH
28339: LD_INT 0
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 2
28348: PUSH
28349: LD_INT 1
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PUSH
28356: LD_INT 2
28358: PUSH
28359: LD_INT 2
28361: PUSH
28362: EMPTY
28363: LIST
28364: LIST
28365: PUSH
28366: LD_INT 1
28368: PUSH
28369: LD_INT 2
28371: PUSH
28372: EMPTY
28373: LIST
28374: LIST
28375: PUSH
28376: LD_INT 0
28378: PUSH
28379: LD_INT 2
28381: PUSH
28382: EMPTY
28383: LIST
28384: LIST
28385: PUSH
28386: LD_INT 1
28388: NEG
28389: PUSH
28390: LD_INT 1
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: PUSH
28397: LD_INT 2
28399: NEG
28400: PUSH
28401: LD_INT 0
28403: PUSH
28404: EMPTY
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 2
28410: NEG
28411: PUSH
28412: LD_INT 1
28414: NEG
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PUSH
28420: LD_INT 2
28422: NEG
28423: PUSH
28424: LD_INT 2
28426: NEG
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 1
28434: PUSH
28435: LD_INT 2
28437: NEG
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 2
28445: PUSH
28446: LD_INT 1
28448: NEG
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: LD_INT 3
28456: PUSH
28457: LD_INT 1
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PUSH
28464: LD_INT 3
28466: PUSH
28467: LD_INT 2
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: LIST
28478: LIST
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: LIST
28495: LIST
28496: LIST
28497: LIST
28498: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28499: LD_ADDR_VAR 0 25
28503: PUSH
28504: LD_INT 0
28506: PUSH
28507: LD_INT 0
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: LD_INT 0
28516: PUSH
28517: LD_INT 1
28519: NEG
28520: PUSH
28521: EMPTY
28522: LIST
28523: LIST
28524: PUSH
28525: LD_INT 1
28527: PUSH
28528: LD_INT 0
28530: PUSH
28531: EMPTY
28532: LIST
28533: LIST
28534: PUSH
28535: LD_INT 1
28537: PUSH
28538: LD_INT 1
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: LD_INT 0
28547: PUSH
28548: LD_INT 1
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 1
28557: NEG
28558: PUSH
28559: LD_INT 0
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PUSH
28566: LD_INT 1
28568: NEG
28569: PUSH
28570: LD_INT 1
28572: NEG
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 1
28580: NEG
28581: PUSH
28582: LD_INT 2
28584: NEG
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 0
28592: PUSH
28593: LD_INT 2
28595: NEG
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: LD_INT 1
28606: NEG
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 2
28614: PUSH
28615: LD_INT 0
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 2
28624: PUSH
28625: LD_INT 1
28627: PUSH
28628: EMPTY
28629: LIST
28630: LIST
28631: PUSH
28632: LD_INT 2
28634: PUSH
28635: LD_INT 2
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: PUSH
28642: LD_INT 1
28644: PUSH
28645: LD_INT 2
28647: PUSH
28648: EMPTY
28649: LIST
28650: LIST
28651: PUSH
28652: LD_INT 0
28654: PUSH
28655: LD_INT 2
28657: PUSH
28658: EMPTY
28659: LIST
28660: LIST
28661: PUSH
28662: LD_INT 1
28664: NEG
28665: PUSH
28666: LD_INT 1
28668: PUSH
28669: EMPTY
28670: LIST
28671: LIST
28672: PUSH
28673: LD_INT 2
28675: NEG
28676: PUSH
28677: LD_INT 0
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: PUSH
28684: LD_INT 2
28686: NEG
28687: PUSH
28688: LD_INT 1
28690: NEG
28691: PUSH
28692: EMPTY
28693: LIST
28694: LIST
28695: PUSH
28696: LD_INT 2
28698: NEG
28699: PUSH
28700: LD_INT 2
28702: NEG
28703: PUSH
28704: EMPTY
28705: LIST
28706: LIST
28707: PUSH
28708: LD_INT 3
28710: PUSH
28711: LD_INT 1
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 3
28720: PUSH
28721: LD_INT 2
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 2
28730: PUSH
28731: LD_INT 3
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: PUSH
28738: LD_INT 1
28740: PUSH
28741: LD_INT 3
28743: PUSH
28744: EMPTY
28745: LIST
28746: LIST
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: LIST
28752: LIST
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28773: LD_ADDR_VAR 0 26
28777: PUSH
28778: LD_INT 0
28780: PUSH
28781: LD_INT 0
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 0
28790: PUSH
28791: LD_INT 1
28793: NEG
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 1
28801: PUSH
28802: LD_INT 0
28804: PUSH
28805: EMPTY
28806: LIST
28807: LIST
28808: PUSH
28809: LD_INT 1
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 0
28821: PUSH
28822: LD_INT 1
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PUSH
28829: LD_INT 1
28831: NEG
28832: PUSH
28833: LD_INT 0
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: LD_INT 1
28842: NEG
28843: PUSH
28844: LD_INT 1
28846: NEG
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: PUSH
28852: LD_INT 1
28854: NEG
28855: PUSH
28856: LD_INT 2
28858: NEG
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: PUSH
28864: LD_INT 0
28866: PUSH
28867: LD_INT 2
28869: NEG
28870: PUSH
28871: EMPTY
28872: LIST
28873: LIST
28874: PUSH
28875: LD_INT 1
28877: PUSH
28878: LD_INT 1
28880: NEG
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 2
28888: PUSH
28889: LD_INT 0
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 2
28898: PUSH
28899: LD_INT 1
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 2
28908: PUSH
28909: LD_INT 2
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 1
28918: PUSH
28919: LD_INT 2
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PUSH
28926: LD_INT 0
28928: PUSH
28929: LD_INT 2
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 1
28938: NEG
28939: PUSH
28940: LD_INT 1
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: LD_INT 2
28949: NEG
28950: PUSH
28951: LD_INT 0
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 2
28960: NEG
28961: PUSH
28962: LD_INT 1
28964: NEG
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 2
28972: NEG
28973: PUSH
28974: LD_INT 2
28976: NEG
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 2
28984: PUSH
28985: LD_INT 3
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 1
28994: PUSH
28995: LD_INT 3
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 1
29004: NEG
29005: PUSH
29006: LD_INT 2
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 2
29015: NEG
29016: PUSH
29017: LD_INT 1
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29049: LD_ADDR_VAR 0 27
29053: PUSH
29054: LD_INT 0
29056: PUSH
29057: LD_INT 0
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 0
29066: PUSH
29067: LD_INT 1
29069: NEG
29070: PUSH
29071: EMPTY
29072: LIST
29073: LIST
29074: PUSH
29075: LD_INT 1
29077: PUSH
29078: LD_INT 0
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 1
29087: PUSH
29088: LD_INT 1
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 0
29097: PUSH
29098: LD_INT 1
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: PUSH
29105: LD_INT 1
29107: NEG
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 1
29118: NEG
29119: PUSH
29120: LD_INT 1
29122: NEG
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: LD_INT 1
29130: NEG
29131: PUSH
29132: LD_INT 2
29134: NEG
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: LD_INT 0
29142: PUSH
29143: LD_INT 2
29145: NEG
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 1
29153: PUSH
29154: LD_INT 1
29156: NEG
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 2
29164: PUSH
29165: LD_INT 0
29167: PUSH
29168: EMPTY
29169: LIST
29170: LIST
29171: PUSH
29172: LD_INT 2
29174: PUSH
29175: LD_INT 1
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 2
29184: PUSH
29185: LD_INT 2
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 1
29194: PUSH
29195: LD_INT 2
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: LD_INT 0
29204: PUSH
29205: LD_INT 2
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: PUSH
29212: LD_INT 1
29214: NEG
29215: PUSH
29216: LD_INT 1
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: PUSH
29223: LD_INT 2
29225: NEG
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 2
29236: NEG
29237: PUSH
29238: LD_INT 1
29240: NEG
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: LD_INT 2
29248: NEG
29249: PUSH
29250: LD_INT 2
29252: NEG
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: NEG
29261: PUSH
29262: LD_INT 2
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 2
29271: NEG
29272: PUSH
29273: LD_INT 1
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 3
29282: NEG
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 3
29294: NEG
29295: PUSH
29296: LD_INT 2
29298: NEG
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29329: LD_ADDR_VAR 0 28
29333: PUSH
29334: LD_INT 0
29336: PUSH
29337: LD_INT 0
29339: PUSH
29340: EMPTY
29341: LIST
29342: LIST
29343: PUSH
29344: LD_INT 0
29346: PUSH
29347: LD_INT 1
29349: NEG
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: LD_INT 1
29357: PUSH
29358: LD_INT 0
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: LD_INT 1
29367: PUSH
29368: LD_INT 1
29370: PUSH
29371: EMPTY
29372: LIST
29373: LIST
29374: PUSH
29375: LD_INT 0
29377: PUSH
29378: LD_INT 1
29380: PUSH
29381: EMPTY
29382: LIST
29383: LIST
29384: PUSH
29385: LD_INT 1
29387: NEG
29388: PUSH
29389: LD_INT 0
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 1
29398: NEG
29399: PUSH
29400: LD_INT 1
29402: NEG
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 1
29410: NEG
29411: PUSH
29412: LD_INT 2
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 0
29422: PUSH
29423: LD_INT 2
29425: NEG
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 1
29433: PUSH
29434: LD_INT 1
29436: NEG
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 2
29444: PUSH
29445: LD_INT 0
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: LD_INT 2
29454: PUSH
29455: LD_INT 1
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: PUSH
29462: LD_INT 2
29464: PUSH
29465: LD_INT 2
29467: PUSH
29468: EMPTY
29469: LIST
29470: LIST
29471: PUSH
29472: LD_INT 1
29474: PUSH
29475: LD_INT 2
29477: PUSH
29478: EMPTY
29479: LIST
29480: LIST
29481: PUSH
29482: LD_INT 0
29484: PUSH
29485: LD_INT 2
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 1
29494: NEG
29495: PUSH
29496: LD_INT 1
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 2
29505: NEG
29506: PUSH
29507: LD_INT 0
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 2
29516: NEG
29517: PUSH
29518: LD_INT 1
29520: NEG
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 2
29528: NEG
29529: PUSH
29530: LD_INT 2
29532: NEG
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 2
29540: NEG
29541: PUSH
29542: LD_INT 3
29544: NEG
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 1
29552: NEG
29553: PUSH
29554: LD_INT 3
29556: NEG
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: LD_INT 3
29564: NEG
29565: PUSH
29566: LD_INT 1
29568: NEG
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: LD_INT 3
29576: NEG
29577: PUSH
29578: LD_INT 2
29580: NEG
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: LIST
29590: LIST
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29611: LD_ADDR_VAR 0 29
29615: PUSH
29616: LD_INT 0
29618: PUSH
29619: LD_INT 0
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 1
29631: NEG
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: LD_INT 0
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: LD_INT 1
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 0
29659: PUSH
29660: LD_INT 1
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 1
29669: NEG
29670: PUSH
29671: LD_INT 0
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: LD_INT 1
29680: NEG
29681: PUSH
29682: LD_INT 1
29684: NEG
29685: PUSH
29686: EMPTY
29687: LIST
29688: LIST
29689: PUSH
29690: LD_INT 1
29692: NEG
29693: PUSH
29694: LD_INT 2
29696: NEG
29697: PUSH
29698: EMPTY
29699: LIST
29700: LIST
29701: PUSH
29702: LD_INT 0
29704: PUSH
29705: LD_INT 2
29707: NEG
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: PUSH
29713: LD_INT 1
29715: PUSH
29716: LD_INT 1
29718: NEG
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: LD_INT 2
29726: PUSH
29727: LD_INT 0
29729: PUSH
29730: EMPTY
29731: LIST
29732: LIST
29733: PUSH
29734: LD_INT 2
29736: PUSH
29737: LD_INT 1
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: PUSH
29744: LD_INT 1
29746: PUSH
29747: LD_INT 2
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 0
29756: PUSH
29757: LD_INT 2
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 1
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 2
29777: NEG
29778: PUSH
29779: LD_INT 1
29781: NEG
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 2
29789: NEG
29790: PUSH
29791: LD_INT 2
29793: NEG
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 2
29801: NEG
29802: PUSH
29803: LD_INT 3
29805: NEG
29806: PUSH
29807: EMPTY
29808: LIST
29809: LIST
29810: PUSH
29811: LD_INT 2
29813: PUSH
29814: LD_INT 1
29816: NEG
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: PUSH
29822: LD_INT 3
29824: PUSH
29825: LD_INT 1
29827: PUSH
29828: EMPTY
29829: LIST
29830: LIST
29831: PUSH
29832: LD_INT 1
29834: PUSH
29835: LD_INT 3
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 1
29844: NEG
29845: PUSH
29846: LD_INT 2
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 3
29855: NEG
29856: PUSH
29857: LD_INT 2
29859: NEG
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29890: LD_ADDR_VAR 0 30
29894: PUSH
29895: LD_INT 0
29897: PUSH
29898: LD_INT 0
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 0
29907: PUSH
29908: LD_INT 1
29910: NEG
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: LD_INT 0
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: LD_INT 1
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 0
29938: PUSH
29939: LD_INT 1
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: LD_INT 1
29948: NEG
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 1
29959: NEG
29960: PUSH
29961: LD_INT 1
29963: NEG
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 1
29971: NEG
29972: PUSH
29973: LD_INT 2
29975: NEG
29976: PUSH
29977: EMPTY
29978: LIST
29979: LIST
29980: PUSH
29981: LD_INT 0
29983: PUSH
29984: LD_INT 2
29986: NEG
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: PUSH
29995: LD_INT 1
29997: NEG
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PUSH
30003: LD_INT 2
30005: PUSH
30006: LD_INT 0
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: LD_INT 2
30015: PUSH
30016: LD_INT 1
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: LD_INT 2
30025: PUSH
30026: LD_INT 2
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 1
30045: NEG
30046: PUSH
30047: LD_INT 1
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PUSH
30054: LD_INT 2
30056: NEG
30057: PUSH
30058: LD_INT 0
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: LD_INT 2
30067: NEG
30068: PUSH
30069: LD_INT 1
30071: NEG
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: PUSH
30077: LD_INT 1
30079: NEG
30080: PUSH
30081: LD_INT 3
30083: NEG
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: PUSH
30092: LD_INT 2
30094: NEG
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: LD_INT 3
30102: PUSH
30103: LD_INT 2
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 2
30112: PUSH
30113: LD_INT 3
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 2
30122: NEG
30123: PUSH
30124: LD_INT 1
30126: PUSH
30127: EMPTY
30128: LIST
30129: LIST
30130: PUSH
30131: LD_INT 3
30133: NEG
30134: PUSH
30135: LD_INT 1
30137: NEG
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: LIST
30147: LIST
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30168: LD_ADDR_VAR 0 31
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: LD_INT 0
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 0
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 1
30196: PUSH
30197: LD_INT 0
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: LD_INT 1
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 1
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 1
30226: NEG
30227: PUSH
30228: LD_INT 0
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: NEG
30238: PUSH
30239: LD_INT 1
30241: NEG
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: LD_INT 2
30253: NEG
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 1
30261: PUSH
30262: LD_INT 1
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 2
30272: PUSH
30273: LD_INT 0
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 2
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 2
30292: PUSH
30293: LD_INT 2
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: LD_INT 2
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 0
30312: PUSH
30313: LD_INT 2
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 1
30322: NEG
30323: PUSH
30324: LD_INT 1
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 2
30333: NEG
30334: PUSH
30335: LD_INT 1
30337: NEG
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 2
30345: NEG
30346: PUSH
30347: LD_INT 2
30349: NEG
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 2
30357: NEG
30358: PUSH
30359: LD_INT 3
30361: NEG
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: LD_INT 2
30369: PUSH
30370: LD_INT 1
30372: NEG
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 3
30380: PUSH
30381: LD_INT 1
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 1
30390: PUSH
30391: LD_INT 3
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 1
30400: NEG
30401: PUSH
30402: LD_INT 2
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 3
30411: NEG
30412: PUSH
30413: LD_INT 2
30415: NEG
30416: PUSH
30417: EMPTY
30418: LIST
30419: LIST
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: LIST
30425: LIST
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: LIST
30432: LIST
30433: LIST
30434: LIST
30435: LIST
30436: LIST
30437: LIST
30438: LIST
30439: LIST
30440: LIST
30441: LIST
30442: LIST
30443: LIST
30444: LIST
30445: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30446: LD_ADDR_VAR 0 32
30450: PUSH
30451: LD_INT 0
30453: PUSH
30454: LD_INT 0
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 0
30463: PUSH
30464: LD_INT 1
30466: NEG
30467: PUSH
30468: EMPTY
30469: LIST
30470: LIST
30471: PUSH
30472: LD_INT 1
30474: PUSH
30475: LD_INT 0
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: PUSH
30482: LD_INT 1
30484: PUSH
30485: LD_INT 1
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: LD_INT 0
30494: PUSH
30495: LD_INT 1
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 1
30504: NEG
30505: PUSH
30506: LD_INT 0
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 1
30515: NEG
30516: PUSH
30517: LD_INT 1
30519: NEG
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_INT 1
30527: NEG
30528: PUSH
30529: LD_INT 2
30531: NEG
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: PUSH
30537: LD_INT 0
30539: PUSH
30540: LD_INT 2
30542: NEG
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 1
30550: PUSH
30551: LD_INT 1
30553: NEG
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 2
30561: PUSH
30562: LD_INT 1
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 2
30571: PUSH
30572: LD_INT 2
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 1
30581: PUSH
30582: LD_INT 2
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 0
30591: PUSH
30592: LD_INT 2
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 1
30601: NEG
30602: PUSH
30603: LD_INT 1
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: LD_INT 2
30612: NEG
30613: PUSH
30614: LD_INT 0
30616: PUSH
30617: EMPTY
30618: LIST
30619: LIST
30620: PUSH
30621: LD_INT 2
30623: NEG
30624: PUSH
30625: LD_INT 1
30627: NEG
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 1
30635: NEG
30636: PUSH
30637: LD_INT 3
30639: NEG
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: LD_INT 1
30647: PUSH
30648: LD_INT 2
30650: NEG
30651: PUSH
30652: EMPTY
30653: LIST
30654: LIST
30655: PUSH
30656: LD_INT 3
30658: PUSH
30659: LD_INT 2
30661: PUSH
30662: EMPTY
30663: LIST
30664: LIST
30665: PUSH
30666: LD_INT 2
30668: PUSH
30669: LD_INT 3
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 2
30678: NEG
30679: PUSH
30680: LD_INT 1
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 3
30689: NEG
30690: PUSH
30691: LD_INT 1
30693: NEG
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: LIST
30714: LIST
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30724: LD_ADDR_VAR 0 33
30728: PUSH
30729: LD_INT 0
30731: PUSH
30732: LD_INT 0
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 0
30741: PUSH
30742: LD_INT 1
30744: NEG
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 1
30752: PUSH
30753: LD_INT 0
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: LD_INT 1
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 0
30772: PUSH
30773: LD_INT 1
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: NEG
30783: PUSH
30784: LD_INT 0
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 1
30793: NEG
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 1
30805: NEG
30806: PUSH
30807: LD_INT 2
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: PUSH
30818: LD_INT 1
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 2
30828: PUSH
30829: LD_INT 0
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: LD_INT 2
30838: PUSH
30839: LD_INT 1
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 1
30848: PUSH
30849: LD_INT 2
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 0
30858: PUSH
30859: LD_INT 2
30861: PUSH
30862: EMPTY
30863: LIST
30864: LIST
30865: PUSH
30866: LD_INT 1
30868: NEG
30869: PUSH
30870: LD_INT 1
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 2
30879: NEG
30880: PUSH
30881: LD_INT 0
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 2
30890: NEG
30891: PUSH
30892: LD_INT 1
30894: NEG
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 2
30902: NEG
30903: PUSH
30904: LD_INT 2
30906: NEG
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 2
30914: NEG
30915: PUSH
30916: LD_INT 3
30918: NEG
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 2
30926: PUSH
30927: LD_INT 1
30929: NEG
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PUSH
30935: LD_INT 3
30937: PUSH
30938: LD_INT 1
30940: PUSH
30941: EMPTY
30942: LIST
30943: LIST
30944: PUSH
30945: LD_INT 1
30947: PUSH
30948: LD_INT 3
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: LD_INT 1
30957: NEG
30958: PUSH
30959: LD_INT 2
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: PUSH
30966: LD_INT 3
30968: NEG
30969: PUSH
30970: LD_INT 2
30972: NEG
30973: PUSH
30974: EMPTY
30975: LIST
30976: LIST
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: LIST
30999: LIST
31000: LIST
31001: LIST
31002: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31003: LD_ADDR_VAR 0 34
31007: PUSH
31008: LD_INT 0
31010: PUSH
31011: LD_INT 0
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: PUSH
31018: LD_INT 0
31020: PUSH
31021: LD_INT 1
31023: NEG
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: LD_INT 0
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 1
31041: PUSH
31042: LD_INT 1
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 0
31051: PUSH
31052: LD_INT 1
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: LD_INT 0
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 1
31072: NEG
31073: PUSH
31074: LD_INT 1
31076: NEG
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 1
31084: NEG
31085: PUSH
31086: LD_INT 2
31088: NEG
31089: PUSH
31090: EMPTY
31091: LIST
31092: LIST
31093: PUSH
31094: LD_INT 0
31096: PUSH
31097: LD_INT 2
31099: NEG
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 1
31107: PUSH
31108: LD_INT 1
31110: NEG
31111: PUSH
31112: EMPTY
31113: LIST
31114: LIST
31115: PUSH
31116: LD_INT 2
31118: PUSH
31119: LD_INT 1
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 2
31128: PUSH
31129: LD_INT 2
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 1
31138: PUSH
31139: LD_INT 2
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PUSH
31146: LD_INT 1
31148: NEG
31149: PUSH
31150: LD_INT 1
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_INT 2
31159: NEG
31160: PUSH
31161: LD_INT 0
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 2
31170: NEG
31171: PUSH
31172: LD_INT 1
31174: NEG
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 2
31182: NEG
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 1
31194: NEG
31195: PUSH
31196: LD_INT 3
31198: NEG
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 1
31206: PUSH
31207: LD_INT 2
31209: NEG
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 3
31217: PUSH
31218: LD_INT 2
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 2
31227: PUSH
31228: LD_INT 3
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 2
31237: NEG
31238: PUSH
31239: LD_INT 1
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 3
31248: NEG
31249: PUSH
31250: LD_INT 1
31252: NEG
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31283: LD_ADDR_VAR 0 35
31287: PUSH
31288: LD_INT 0
31290: PUSH
31291: LD_INT 0
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PUSH
31298: LD_INT 0
31300: PUSH
31301: LD_INT 1
31303: NEG
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 1
31311: PUSH
31312: LD_INT 0
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 1
31321: PUSH
31322: LD_INT 1
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: LD_INT 0
31331: PUSH
31332: LD_INT 1
31334: PUSH
31335: EMPTY
31336: LIST
31337: LIST
31338: PUSH
31339: LD_INT 1
31341: NEG
31342: PUSH
31343: LD_INT 0
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 1
31352: NEG
31353: PUSH
31354: LD_INT 1
31356: NEG
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PUSH
31362: LD_INT 2
31364: PUSH
31365: LD_INT 1
31367: PUSH
31368: EMPTY
31369: LIST
31370: LIST
31371: PUSH
31372: LD_INT 2
31374: NEG
31375: PUSH
31376: LD_INT 1
31378: NEG
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31395: LD_ADDR_VAR 0 36
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: LD_INT 0
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 0
31412: PUSH
31413: LD_INT 1
31415: NEG
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 1
31423: PUSH
31424: LD_INT 0
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: LD_INT 1
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: LD_INT 0
31443: PUSH
31444: LD_INT 1
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 1
31453: NEG
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 1
31464: NEG
31465: PUSH
31466: LD_INT 1
31468: NEG
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PUSH
31474: LD_INT 1
31476: NEG
31477: PUSH
31478: LD_INT 2
31480: NEG
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: LD_INT 1
31488: PUSH
31489: LD_INT 2
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31507: LD_ADDR_VAR 0 37
31511: PUSH
31512: LD_INT 0
31514: PUSH
31515: LD_INT 0
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PUSH
31522: LD_INT 0
31524: PUSH
31525: LD_INT 1
31527: NEG
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 1
31535: PUSH
31536: LD_INT 0
31538: PUSH
31539: EMPTY
31540: LIST
31541: LIST
31542: PUSH
31543: LD_INT 1
31545: PUSH
31546: LD_INT 1
31548: PUSH
31549: EMPTY
31550: LIST
31551: LIST
31552: PUSH
31553: LD_INT 0
31555: PUSH
31556: LD_INT 1
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 1
31565: NEG
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PUSH
31574: LD_INT 1
31576: NEG
31577: PUSH
31578: LD_INT 1
31580: NEG
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 1
31588: PUSH
31589: LD_INT 1
31591: NEG
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 1
31599: NEG
31600: PUSH
31601: LD_INT 1
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31619: LD_ADDR_VAR 0 38
31623: PUSH
31624: LD_INT 0
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 0
31636: PUSH
31637: LD_INT 1
31639: NEG
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: LD_INT 1
31647: PUSH
31648: LD_INT 0
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: PUSH
31655: LD_INT 1
31657: PUSH
31658: LD_INT 1
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 0
31667: PUSH
31668: LD_INT 1
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 1
31677: NEG
31678: PUSH
31679: LD_INT 0
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 1
31688: NEG
31689: PUSH
31690: LD_INT 1
31692: NEG
31693: PUSH
31694: EMPTY
31695: LIST
31696: LIST
31697: PUSH
31698: LD_INT 2
31700: PUSH
31701: LD_INT 1
31703: PUSH
31704: EMPTY
31705: LIST
31706: LIST
31707: PUSH
31708: LD_INT 2
31710: NEG
31711: PUSH
31712: LD_INT 1
31714: NEG
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31731: LD_ADDR_VAR 0 39
31735: PUSH
31736: LD_INT 0
31738: PUSH
31739: LD_INT 0
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 0
31748: PUSH
31749: LD_INT 1
31751: NEG
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: LD_INT 1
31759: PUSH
31760: LD_INT 0
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PUSH
31767: LD_INT 1
31769: PUSH
31770: LD_INT 1
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 0
31779: PUSH
31780: LD_INT 1
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 1
31789: NEG
31790: PUSH
31791: LD_INT 0
31793: PUSH
31794: EMPTY
31795: LIST
31796: LIST
31797: PUSH
31798: LD_INT 1
31800: NEG
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 1
31812: NEG
31813: PUSH
31814: LD_INT 2
31816: NEG
31817: PUSH
31818: EMPTY
31819: LIST
31820: LIST
31821: PUSH
31822: LD_INT 1
31824: PUSH
31825: LD_INT 2
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31843: LD_ADDR_VAR 0 40
31847: PUSH
31848: LD_INT 0
31850: PUSH
31851: LD_INT 0
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: LD_INT 0
31860: PUSH
31861: LD_INT 1
31863: NEG
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PUSH
31869: LD_INT 1
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 1
31881: PUSH
31882: LD_INT 1
31884: PUSH
31885: EMPTY
31886: LIST
31887: LIST
31888: PUSH
31889: LD_INT 0
31891: PUSH
31892: LD_INT 1
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: PUSH
31899: LD_INT 1
31901: NEG
31902: PUSH
31903: LD_INT 0
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: LD_INT 1
31912: NEG
31913: PUSH
31914: LD_INT 1
31916: NEG
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 1
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 1
31935: NEG
31936: PUSH
31937: LD_INT 1
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31955: LD_ADDR_VAR 0 41
31959: PUSH
31960: LD_INT 0
31962: PUSH
31963: LD_INT 0
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 0
31972: PUSH
31973: LD_INT 1
31975: NEG
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 1
31983: PUSH
31984: LD_INT 0
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: LD_INT 1
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PUSH
32001: LD_INT 0
32003: PUSH
32004: LD_INT 1
32006: PUSH
32007: EMPTY
32008: LIST
32009: LIST
32010: PUSH
32011: LD_INT 1
32013: NEG
32014: PUSH
32015: LD_INT 0
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: LD_INT 1
32028: NEG
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 1
32036: NEG
32037: PUSH
32038: LD_INT 2
32040: NEG
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 1
32048: PUSH
32049: LD_INT 1
32051: NEG
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 2
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 2
32069: PUSH
32070: LD_INT 1
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 2
32079: PUSH
32080: LD_INT 2
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 1
32089: PUSH
32090: LD_INT 2
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 1
32099: NEG
32100: PUSH
32101: LD_INT 1
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 2
32110: NEG
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 2
32121: NEG
32122: PUSH
32123: LD_INT 1
32125: NEG
32126: PUSH
32127: EMPTY
32128: LIST
32129: LIST
32130: PUSH
32131: LD_INT 2
32133: NEG
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 2
32145: NEG
32146: PUSH
32147: LD_INT 3
32149: NEG
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 2
32157: PUSH
32158: LD_INT 1
32160: NEG
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 3
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 3
32178: PUSH
32179: LD_INT 1
32181: PUSH
32182: EMPTY
32183: LIST
32184: LIST
32185: PUSH
32186: LD_INT 3
32188: PUSH
32189: LD_INT 2
32191: PUSH
32192: EMPTY
32193: LIST
32194: LIST
32195: PUSH
32196: LD_INT 3
32198: PUSH
32199: LD_INT 3
32201: PUSH
32202: EMPTY
32203: LIST
32204: LIST
32205: PUSH
32206: LD_INT 2
32208: PUSH
32209: LD_INT 3
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: LD_INT 2
32218: NEG
32219: PUSH
32220: LD_INT 1
32222: PUSH
32223: EMPTY
32224: LIST
32225: LIST
32226: PUSH
32227: LD_INT 3
32229: NEG
32230: PUSH
32231: LD_INT 0
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PUSH
32238: LD_INT 3
32240: NEG
32241: PUSH
32242: LD_INT 1
32244: NEG
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: LD_INT 3
32252: NEG
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 3
32264: NEG
32265: PUSH
32266: LD_INT 3
32268: NEG
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32305: LD_ADDR_VAR 0 42
32309: PUSH
32310: LD_INT 0
32312: PUSH
32313: LD_INT 0
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: LD_INT 1
32325: NEG
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: LD_INT 1
32333: PUSH
32334: LD_INT 0
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: PUSH
32341: LD_INT 1
32343: PUSH
32344: LD_INT 1
32346: PUSH
32347: EMPTY
32348: LIST
32349: LIST
32350: PUSH
32351: LD_INT 0
32353: PUSH
32354: LD_INT 1
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 1
32363: NEG
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 1
32374: NEG
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 1
32386: NEG
32387: PUSH
32388: LD_INT 2
32390: NEG
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 0
32398: PUSH
32399: LD_INT 2
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 1
32409: PUSH
32410: LD_INT 1
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: LD_INT 1
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 2
32430: PUSH
32431: LD_INT 2
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: LD_INT 2
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: LD_INT 2
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 1
32460: NEG
32461: PUSH
32462: LD_INT 1
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 2
32471: NEG
32472: PUSH
32473: LD_INT 1
32475: NEG
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 2
32483: NEG
32484: PUSH
32485: LD_INT 2
32487: NEG
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 2
32495: NEG
32496: PUSH
32497: LD_INT 3
32499: NEG
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 1
32507: NEG
32508: PUSH
32509: LD_INT 3
32511: NEG
32512: PUSH
32513: EMPTY
32514: LIST
32515: LIST
32516: PUSH
32517: LD_INT 0
32519: PUSH
32520: LD_INT 3
32522: NEG
32523: PUSH
32524: EMPTY
32525: LIST
32526: LIST
32527: PUSH
32528: LD_INT 1
32530: PUSH
32531: LD_INT 2
32533: NEG
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 3
32541: PUSH
32542: LD_INT 2
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 3
32551: PUSH
32552: LD_INT 3
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 2
32561: PUSH
32562: LD_INT 3
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: LD_INT 1
32571: PUSH
32572: LD_INT 3
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: LD_INT 3
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 1
32591: NEG
32592: PUSH
32593: LD_INT 2
32595: PUSH
32596: EMPTY
32597: LIST
32598: LIST
32599: PUSH
32600: LD_INT 3
32602: NEG
32603: PUSH
32604: LD_INT 2
32606: NEG
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 3
32614: NEG
32615: PUSH
32616: LD_INT 3
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: LIST
32628: LIST
32629: LIST
32630: LIST
32631: LIST
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32655: LD_ADDR_VAR 0 43
32659: PUSH
32660: LD_INT 0
32662: PUSH
32663: LD_INT 0
32665: PUSH
32666: EMPTY
32667: LIST
32668: LIST
32669: PUSH
32670: LD_INT 0
32672: PUSH
32673: LD_INT 1
32675: NEG
32676: PUSH
32677: EMPTY
32678: LIST
32679: LIST
32680: PUSH
32681: LD_INT 1
32683: PUSH
32684: LD_INT 0
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 1
32693: PUSH
32694: LD_INT 1
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: PUSH
32701: LD_INT 0
32703: PUSH
32704: LD_INT 1
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: LD_INT 1
32713: NEG
32714: PUSH
32715: LD_INT 0
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 1
32724: NEG
32725: PUSH
32726: LD_INT 1
32728: NEG
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: LD_INT 1
32736: NEG
32737: PUSH
32738: LD_INT 2
32740: NEG
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PUSH
32746: LD_INT 0
32748: PUSH
32749: LD_INT 2
32751: NEG
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: PUSH
32760: LD_INT 1
32762: NEG
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: LD_INT 0
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 2
32780: PUSH
32781: LD_INT 1
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: LD_INT 2
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 0
32800: PUSH
32801: LD_INT 2
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 2
32821: NEG
32822: PUSH
32823: LD_INT 0
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 2
32832: NEG
32833: PUSH
32834: LD_INT 1
32836: NEG
32837: PUSH
32838: EMPTY
32839: LIST
32840: LIST
32841: PUSH
32842: LD_INT 1
32844: NEG
32845: PUSH
32846: LD_INT 3
32848: NEG
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 0
32856: PUSH
32857: LD_INT 3
32859: NEG
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 1
32867: PUSH
32868: LD_INT 2
32870: NEG
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: LD_INT 2
32878: PUSH
32879: LD_INT 1
32881: NEG
32882: PUSH
32883: EMPTY
32884: LIST
32885: LIST
32886: PUSH
32887: LD_INT 3
32889: PUSH
32890: LD_INT 0
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 3
32899: PUSH
32900: LD_INT 1
32902: PUSH
32903: EMPTY
32904: LIST
32905: LIST
32906: PUSH
32907: LD_INT 1
32909: PUSH
32910: LD_INT 3
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 0
32919: PUSH
32920: LD_INT 3
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: LD_INT 1
32929: NEG
32930: PUSH
32931: LD_INT 2
32933: PUSH
32934: EMPTY
32935: LIST
32936: LIST
32937: PUSH
32938: LD_INT 2
32940: NEG
32941: PUSH
32942: LD_INT 1
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 3
32951: NEG
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 3
32962: NEG
32963: PUSH
32964: LD_INT 1
32966: NEG
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: LIST
32976: LIST
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33003: LD_ADDR_VAR 0 44
33007: PUSH
33008: LD_INT 0
33010: PUSH
33011: LD_INT 0
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 0
33020: PUSH
33021: LD_INT 1
33023: NEG
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 1
33031: PUSH
33032: LD_INT 0
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: LD_INT 1
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 0
33051: PUSH
33052: LD_INT 1
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 1
33061: NEG
33062: PUSH
33063: LD_INT 0
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 1
33072: NEG
33073: PUSH
33074: LD_INT 1
33076: NEG
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: PUSH
33082: LD_INT 1
33084: NEG
33085: PUSH
33086: LD_INT 2
33088: NEG
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 1
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 2
33107: PUSH
33108: LD_INT 0
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 2
33117: PUSH
33118: LD_INT 1
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 2
33127: PUSH
33128: LD_INT 2
33130: PUSH
33131: EMPTY
33132: LIST
33133: LIST
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: LD_INT 2
33140: PUSH
33141: EMPTY
33142: LIST
33143: LIST
33144: PUSH
33145: LD_INT 1
33147: NEG
33148: PUSH
33149: LD_INT 1
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 2
33158: NEG
33159: PUSH
33160: LD_INT 0
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: PUSH
33167: LD_INT 2
33169: NEG
33170: PUSH
33171: LD_INT 1
33173: NEG
33174: PUSH
33175: EMPTY
33176: LIST
33177: LIST
33178: PUSH
33179: LD_INT 2
33181: NEG
33182: PUSH
33183: LD_INT 2
33185: NEG
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 2
33193: NEG
33194: PUSH
33195: LD_INT 3
33197: NEG
33198: PUSH
33199: EMPTY
33200: LIST
33201: LIST
33202: PUSH
33203: LD_INT 2
33205: PUSH
33206: LD_INT 1
33208: NEG
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 3
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 3
33226: PUSH
33227: LD_INT 1
33229: PUSH
33230: EMPTY
33231: LIST
33232: LIST
33233: PUSH
33234: LD_INT 3
33236: PUSH
33237: LD_INT 2
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 3
33246: PUSH
33247: LD_INT 3
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 2
33256: PUSH
33257: LD_INT 3
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PUSH
33264: LD_INT 2
33266: NEG
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 3
33277: NEG
33278: PUSH
33279: LD_INT 0
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 3
33288: NEG
33289: PUSH
33290: LD_INT 1
33292: NEG
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 3
33300: NEG
33301: PUSH
33302: LD_INT 2
33304: NEG
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 3
33312: NEG
33313: PUSH
33314: LD_INT 3
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33353: LD_ADDR_VAR 0 45
33357: PUSH
33358: LD_INT 0
33360: PUSH
33361: LD_INT 0
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 0
33370: PUSH
33371: LD_INT 1
33373: NEG
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 1
33381: PUSH
33382: LD_INT 0
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 1
33391: PUSH
33392: LD_INT 1
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 0
33401: PUSH
33402: LD_INT 1
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 1
33411: NEG
33412: PUSH
33413: LD_INT 0
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 1
33422: NEG
33423: PUSH
33424: LD_INT 1
33426: NEG
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: LD_INT 1
33434: NEG
33435: PUSH
33436: LD_INT 2
33438: NEG
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 0
33446: PUSH
33447: LD_INT 2
33449: NEG
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 1
33457: PUSH
33458: LD_INT 1
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 2
33468: PUSH
33469: LD_INT 1
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 2
33478: PUSH
33479: LD_INT 2
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: LD_INT 2
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 2
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: LD_INT 1
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 2
33519: NEG
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 2
33531: NEG
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 2
33543: NEG
33544: PUSH
33545: LD_INT 3
33547: NEG
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 1
33555: NEG
33556: PUSH
33557: LD_INT 3
33559: NEG
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 0
33567: PUSH
33568: LD_INT 3
33570: NEG
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: LD_INT 2
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 3
33589: PUSH
33590: LD_INT 2
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 3
33599: PUSH
33600: LD_INT 3
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 2
33609: PUSH
33610: LD_INT 3
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 1
33619: PUSH
33620: LD_INT 3
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: LD_INT 3
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 1
33639: NEG
33640: PUSH
33641: LD_INT 2
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 3
33650: NEG
33651: PUSH
33652: LD_INT 2
33654: NEG
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 3
33662: NEG
33663: PUSH
33664: LD_INT 3
33666: NEG
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: LIST
33676: LIST
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33703: LD_ADDR_VAR 0 46
33707: PUSH
33708: LD_INT 0
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 1
33723: NEG
33724: PUSH
33725: EMPTY
33726: LIST
33727: LIST
33728: PUSH
33729: LD_INT 1
33731: PUSH
33732: LD_INT 0
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: PUSH
33742: LD_INT 1
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 0
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: LD_INT 0
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 1
33772: NEG
33773: PUSH
33774: LD_INT 1
33776: NEG
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 1
33784: NEG
33785: PUSH
33786: LD_INT 2
33788: NEG
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 0
33796: PUSH
33797: LD_INT 2
33799: NEG
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: PUSH
33808: LD_INT 1
33810: NEG
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 2
33818: PUSH
33819: LD_INT 0
33821: PUSH
33822: EMPTY
33823: LIST
33824: LIST
33825: PUSH
33826: LD_INT 2
33828: PUSH
33829: LD_INT 1
33831: PUSH
33832: EMPTY
33833: LIST
33834: LIST
33835: PUSH
33836: LD_INT 1
33838: PUSH
33839: LD_INT 2
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 0
33848: PUSH
33849: LD_INT 2
33851: PUSH
33852: EMPTY
33853: LIST
33854: LIST
33855: PUSH
33856: LD_INT 1
33858: NEG
33859: PUSH
33860: LD_INT 1
33862: PUSH
33863: EMPTY
33864: LIST
33865: LIST
33866: PUSH
33867: LD_INT 2
33869: NEG
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: PUSH
33878: LD_INT 2
33880: NEG
33881: PUSH
33882: LD_INT 1
33884: NEG
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: PUSH
33890: LD_INT 1
33892: NEG
33893: PUSH
33894: LD_INT 3
33896: NEG
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 0
33904: PUSH
33905: LD_INT 3
33907: NEG
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 1
33915: PUSH
33916: LD_INT 2
33918: NEG
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 2
33926: PUSH
33927: LD_INT 1
33929: NEG
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: PUSH
33935: LD_INT 3
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 3
33947: PUSH
33948: LD_INT 1
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: PUSH
33955: LD_INT 1
33957: PUSH
33958: LD_INT 3
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 0
33967: PUSH
33968: LD_INT 3
33970: PUSH
33971: EMPTY
33972: LIST
33973: LIST
33974: PUSH
33975: LD_INT 1
33977: NEG
33978: PUSH
33979: LD_INT 2
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PUSH
33986: LD_INT 2
33988: NEG
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 3
33999: NEG
34000: PUSH
34001: LD_INT 0
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 3
34010: NEG
34011: PUSH
34012: LD_INT 1
34014: NEG
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: LIST
34024: LIST
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34051: LD_ADDR_VAR 0 47
34055: PUSH
34056: LD_INT 0
34058: PUSH
34059: LD_INT 0
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 0
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 1
34079: PUSH
34080: LD_INT 0
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 1
34089: PUSH
34090: LD_INT 1
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: LD_INT 1
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: NEG
34110: PUSH
34111: LD_INT 0
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 1
34120: NEG
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 1
34132: NEG
34133: PUSH
34134: LD_INT 2
34136: NEG
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 0
34144: PUSH
34145: LD_INT 2
34147: NEG
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: PUSH
34156: LD_INT 1
34158: NEG
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 2
34166: NEG
34167: PUSH
34168: LD_INT 1
34170: NEG
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 2
34178: NEG
34179: PUSH
34180: LD_INT 2
34182: NEG
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: LIST
34192: LIST
34193: LIST
34194: LIST
34195: LIST
34196: LIST
34197: LIST
34198: LIST
34199: LIST
34200: LIST
34201: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34202: LD_ADDR_VAR 0 48
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: LD_INT 0
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 0
34219: PUSH
34220: LD_INT 1
34222: NEG
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: PUSH
34231: LD_INT 0
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: PUSH
34238: LD_INT 1
34240: PUSH
34241: LD_INT 1
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 0
34250: PUSH
34251: LD_INT 1
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 1
34260: NEG
34261: PUSH
34262: LD_INT 0
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: LD_INT 1
34271: NEG
34272: PUSH
34273: LD_INT 1
34275: NEG
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 1
34283: NEG
34284: PUSH
34285: LD_INT 2
34287: NEG
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: LD_INT 2
34298: NEG
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: LD_INT 1
34306: PUSH
34307: LD_INT 1
34309: NEG
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 2
34317: PUSH
34318: LD_INT 0
34320: PUSH
34321: EMPTY
34322: LIST
34323: LIST
34324: PUSH
34325: LD_INT 2
34327: PUSH
34328: LD_INT 1
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34349: LD_ADDR_VAR 0 49
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 0
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: LD_INT 1
34369: NEG
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: PUSH
34378: LD_INT 0
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 1
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 0
34397: PUSH
34398: LD_INT 1
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 1
34407: NEG
34408: PUSH
34409: LD_INT 0
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 1
34418: NEG
34419: PUSH
34420: LD_INT 1
34422: NEG
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: PUSH
34431: LD_INT 1
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 2
34441: PUSH
34442: LD_INT 0
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: PUSH
34449: LD_INT 2
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: PUSH
34459: LD_INT 2
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 1
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: LIST
34483: LIST
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34493: LD_ADDR_VAR 0 50
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: LD_INT 1
34513: NEG
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: LD_INT 0
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: LD_INT 1
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: PUSH
34539: LD_INT 0
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 1
34551: NEG
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 1
34562: NEG
34563: PUSH
34564: LD_INT 1
34566: NEG
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: LD_INT 2
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 2
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 1
34594: PUSH
34595: LD_INT 2
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 0
34604: PUSH
34605: LD_INT 2
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 1
34614: NEG
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34637: LD_ADDR_VAR 0 51
34641: PUSH
34642: LD_INT 0
34644: PUSH
34645: LD_INT 0
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: PUSH
34666: LD_INT 0
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 1
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 1
34718: PUSH
34719: LD_INT 2
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: LD_INT 2
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 1
34738: NEG
34739: PUSH
34740: LD_INT 1
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: PUSH
34747: LD_INT 2
34749: NEG
34750: PUSH
34751: LD_INT 0
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: NEG
34761: PUSH
34762: LD_INT 1
34764: NEG
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34784: LD_ADDR_VAR 0 52
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: LD_INT 0
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 0
34801: PUSH
34802: LD_INT 1
34804: NEG
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: PUSH
34813: LD_INT 0
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: LD_INT 1
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: LD_INT 1
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 1
34853: NEG
34854: PUSH
34855: LD_INT 1
34857: NEG
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 1
34865: NEG
34866: PUSH
34867: LD_INT 2
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: NEG
34878: PUSH
34879: LD_INT 1
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 2
34888: NEG
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 2
34899: NEG
34900: PUSH
34901: LD_INT 1
34903: NEG
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 2
34911: NEG
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: LIST
34925: LIST
34926: LIST
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34935: LD_ADDR_VAR 0 53
34939: PUSH
34940: LD_INT 0
34942: PUSH
34943: LD_INT 0
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 0
34952: PUSH
34953: LD_INT 1
34955: NEG
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 1
34963: PUSH
34964: LD_INT 0
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 1
34973: PUSH
34974: LD_INT 1
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: LD_INT 0
34983: PUSH
34984: LD_INT 1
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: PUSH
34991: LD_INT 1
34993: NEG
34994: PUSH
34995: LD_INT 0
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: LD_INT 1
35008: NEG
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 1
35016: NEG
35017: PUSH
35018: LD_INT 2
35020: NEG
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 0
35028: PUSH
35029: LD_INT 2
35031: NEG
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 2
35050: PUSH
35051: LD_INT 0
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 2
35060: PUSH
35061: LD_INT 1
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 2
35070: PUSH
35071: LD_INT 2
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 1
35080: PUSH
35081: LD_INT 2
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 0
35090: PUSH
35091: LD_INT 2
35093: PUSH
35094: EMPTY
35095: LIST
35096: LIST
35097: PUSH
35098: LD_INT 1
35100: NEG
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 2
35111: NEG
35112: PUSH
35113: LD_INT 0
35115: PUSH
35116: EMPTY
35117: LIST
35118: LIST
35119: PUSH
35120: LD_INT 2
35122: NEG
35123: PUSH
35124: LD_INT 1
35126: NEG
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 2
35134: NEG
35135: PUSH
35136: LD_INT 2
35138: NEG
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35165: LD_ADDR_VAR 0 54
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: LD_INT 0
35175: PUSH
35176: EMPTY
35177: LIST
35178: LIST
35179: PUSH
35180: LD_INT 0
35182: PUSH
35183: LD_INT 1
35185: NEG
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: LD_INT 0
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 0
35213: PUSH
35214: LD_INT 1
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 1
35223: NEG
35224: PUSH
35225: LD_INT 0
35227: PUSH
35228: EMPTY
35229: LIST
35230: LIST
35231: PUSH
35232: LD_INT 1
35234: NEG
35235: PUSH
35236: LD_INT 1
35238: NEG
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: LD_INT 2
35250: NEG
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 0
35258: PUSH
35259: LD_INT 2
35261: NEG
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: LD_INT 1
35272: NEG
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 2
35280: PUSH
35281: LD_INT 0
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: PUSH
35288: LD_INT 2
35290: PUSH
35291: LD_INT 1
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 2
35300: PUSH
35301: LD_INT 2
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 1
35310: PUSH
35311: LD_INT 2
35313: PUSH
35314: EMPTY
35315: LIST
35316: LIST
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: LD_INT 2
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 1
35330: NEG
35331: PUSH
35332: LD_INT 1
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 2
35341: NEG
35342: PUSH
35343: LD_INT 0
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 2
35352: NEG
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 2
35364: NEG
35365: PUSH
35366: LD_INT 2
35368: NEG
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: LIST
35378: LIST
35379: LIST
35380: LIST
35381: LIST
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35395: LD_ADDR_VAR 0 55
35399: PUSH
35400: LD_INT 0
35402: PUSH
35403: LD_INT 0
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 0
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 1
35423: PUSH
35424: LD_INT 0
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 1
35433: PUSH
35434: LD_INT 1
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: LD_INT 1
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: PUSH
35451: LD_INT 1
35453: NEG
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 1
35464: NEG
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: LD_INT 2
35480: NEG
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: LD_INT 2
35491: NEG
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 2
35510: PUSH
35511: LD_INT 0
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 2
35520: PUSH
35521: LD_INT 1
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 2
35530: PUSH
35531: LD_INT 2
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: PUSH
35538: LD_INT 1
35540: PUSH
35541: LD_INT 2
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 0
35550: PUSH
35551: LD_INT 2
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: LD_INT 1
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 2
35571: NEG
35572: PUSH
35573: LD_INT 0
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 2
35582: NEG
35583: PUSH
35584: LD_INT 1
35586: NEG
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 2
35594: NEG
35595: PUSH
35596: LD_INT 2
35598: NEG
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: LIST
35608: LIST
35609: LIST
35610: LIST
35611: LIST
35612: LIST
35613: LIST
35614: LIST
35615: LIST
35616: LIST
35617: LIST
35618: LIST
35619: LIST
35620: LIST
35621: LIST
35622: LIST
35623: LIST
35624: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35625: LD_ADDR_VAR 0 56
35629: PUSH
35630: LD_INT 0
35632: PUSH
35633: LD_INT 0
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 0
35642: PUSH
35643: LD_INT 1
35645: NEG
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 1
35653: PUSH
35654: LD_INT 0
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 0
35673: PUSH
35674: LD_INT 1
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: NEG
35684: PUSH
35685: LD_INT 0
35687: PUSH
35688: EMPTY
35689: LIST
35690: LIST
35691: PUSH
35692: LD_INT 1
35694: NEG
35695: PUSH
35696: LD_INT 1
35698: NEG
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: LD_INT 2
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: LD_INT 2
35721: NEG
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: LD_INT 1
35729: PUSH
35730: LD_INT 1
35732: NEG
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 2
35740: PUSH
35741: LD_INT 0
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 2
35750: PUSH
35751: LD_INT 1
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 2
35760: PUSH
35761: LD_INT 2
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 1
35770: PUSH
35771: LD_INT 2
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: LD_INT 2
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 1
35790: NEG
35791: PUSH
35792: LD_INT 1
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 2
35801: NEG
35802: PUSH
35803: LD_INT 0
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 2
35812: NEG
35813: PUSH
35814: LD_INT 1
35816: NEG
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 2
35824: NEG
35825: PUSH
35826: LD_INT 2
35828: NEG
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: LIST
35838: LIST
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35855: LD_ADDR_VAR 0 57
35859: PUSH
35860: LD_INT 0
35862: PUSH
35863: LD_INT 0
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: LD_INT 1
35875: NEG
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 1
35883: PUSH
35884: LD_INT 0
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: PUSH
35891: LD_INT 1
35893: PUSH
35894: LD_INT 1
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 0
35903: PUSH
35904: LD_INT 1
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 1
35913: NEG
35914: PUSH
35915: LD_INT 0
35917: PUSH
35918: EMPTY
35919: LIST
35920: LIST
35921: PUSH
35922: LD_INT 1
35924: NEG
35925: PUSH
35926: LD_INT 1
35928: NEG
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: LD_INT 2
35940: NEG
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 0
35948: PUSH
35949: LD_INT 2
35951: NEG
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: LD_INT 1
35962: NEG
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 2
35970: PUSH
35971: LD_INT 0
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 2
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 2
35990: PUSH
35991: LD_INT 2
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: LD_INT 2
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 1
36020: NEG
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: EMPTY
36026: LIST
36027: LIST
36028: PUSH
36029: LD_INT 2
36031: NEG
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 2
36042: NEG
36043: PUSH
36044: LD_INT 1
36046: NEG
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 2
36054: NEG
36055: PUSH
36056: LD_INT 2
36058: NEG
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: LIST
36068: LIST
36069: LIST
36070: LIST
36071: LIST
36072: LIST
36073: LIST
36074: LIST
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36085: LD_ADDR_VAR 0 58
36089: PUSH
36090: LD_INT 0
36092: PUSH
36093: LD_INT 0
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: PUSH
36100: LD_INT 0
36102: PUSH
36103: LD_INT 1
36105: NEG
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 1
36113: PUSH
36114: LD_INT 0
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 1
36123: PUSH
36124: LD_INT 1
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 0
36133: PUSH
36134: LD_INT 1
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 1
36143: NEG
36144: PUSH
36145: LD_INT 0
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: LD_INT 1
36154: NEG
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: LD_INT 2
36170: NEG
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 0
36178: PUSH
36179: LD_INT 2
36181: NEG
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: PUSH
36190: LD_INT 1
36192: NEG
36193: PUSH
36194: EMPTY
36195: LIST
36196: LIST
36197: PUSH
36198: LD_INT 2
36200: PUSH
36201: LD_INT 0
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 2
36210: PUSH
36211: LD_INT 1
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 2
36220: PUSH
36221: LD_INT 2
36223: PUSH
36224: EMPTY
36225: LIST
36226: LIST
36227: PUSH
36228: LD_INT 1
36230: PUSH
36231: LD_INT 2
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: LD_INT 2
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 1
36250: NEG
36251: PUSH
36252: LD_INT 1
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 2
36261: NEG
36262: PUSH
36263: LD_INT 0
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 2
36272: NEG
36273: PUSH
36274: LD_INT 1
36276: NEG
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 2
36284: NEG
36285: PUSH
36286: LD_INT 2
36288: NEG
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: LIST
36298: LIST
36299: LIST
36300: LIST
36301: LIST
36302: LIST
36303: LIST
36304: LIST
36305: LIST
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36315: LD_ADDR_VAR 0 59
36319: PUSH
36320: LD_INT 0
36322: PUSH
36323: LD_INT 0
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: LD_INT 0
36332: PUSH
36333: LD_INT 1
36335: NEG
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 1
36343: PUSH
36344: LD_INT 0
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 1
36353: PUSH
36354: LD_INT 1
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: LD_INT 1
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: NEG
36374: PUSH
36375: LD_INT 0
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 1
36384: NEG
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: LIST
36398: LIST
36399: LIST
36400: LIST
36401: LIST
36402: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36403: LD_ADDR_VAR 0 60
36407: PUSH
36408: LD_INT 0
36410: PUSH
36411: LD_INT 0
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 0
36420: PUSH
36421: LD_INT 1
36423: NEG
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 1
36431: PUSH
36432: LD_INT 0
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: LD_INT 1
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: LD_INT 1
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 1
36461: NEG
36462: PUSH
36463: LD_INT 0
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 1
36472: NEG
36473: PUSH
36474: LD_INT 1
36476: NEG
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36491: LD_ADDR_VAR 0 61
36495: PUSH
36496: LD_INT 0
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 0
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 1
36519: PUSH
36520: LD_INT 0
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: LD_INT 1
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 0
36539: PUSH
36540: LD_INT 1
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: LD_INT 1
36549: NEG
36550: PUSH
36551: LD_INT 0
36553: PUSH
36554: EMPTY
36555: LIST
36556: LIST
36557: PUSH
36558: LD_INT 1
36560: NEG
36561: PUSH
36562: LD_INT 1
36564: NEG
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: LIST
36574: LIST
36575: LIST
36576: LIST
36577: LIST
36578: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36579: LD_ADDR_VAR 0 62
36583: PUSH
36584: LD_INT 0
36586: PUSH
36587: LD_INT 0
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 0
36596: PUSH
36597: LD_INT 1
36599: NEG
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: LD_INT 0
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 1
36617: PUSH
36618: LD_INT 1
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 0
36627: PUSH
36628: LD_INT 1
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 1
36637: NEG
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 1
36648: NEG
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36667: LD_ADDR_VAR 0 63
36671: PUSH
36672: LD_INT 0
36674: PUSH
36675: LD_INT 0
36677: PUSH
36678: EMPTY
36679: LIST
36680: LIST
36681: PUSH
36682: LD_INT 0
36684: PUSH
36685: LD_INT 1
36687: NEG
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 1
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 1
36705: PUSH
36706: LD_INT 1
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 0
36715: PUSH
36716: LD_INT 1
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 1
36725: NEG
36726: PUSH
36727: LD_INT 0
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: NEG
36737: PUSH
36738: LD_INT 1
36740: NEG
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36755: LD_ADDR_VAR 0 64
36759: PUSH
36760: LD_INT 0
36762: PUSH
36763: LD_INT 0
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 0
36772: PUSH
36773: LD_INT 1
36775: NEG
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: EMPTY
36788: LIST
36789: LIST
36790: PUSH
36791: LD_INT 1
36793: PUSH
36794: LD_INT 1
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: PUSH
36801: LD_INT 0
36803: PUSH
36804: LD_INT 1
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 1
36813: NEG
36814: PUSH
36815: LD_INT 0
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: PUSH
36822: LD_INT 1
36824: NEG
36825: PUSH
36826: LD_INT 1
36828: NEG
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: ST_TO_ADDR
// end ; 1 :
36843: GO 42740
36845: LD_INT 1
36847: DOUBLE
36848: EQUAL
36849: IFTRUE 36853
36851: GO 39476
36853: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36854: LD_ADDR_VAR 0 11
36858: PUSH
36859: LD_INT 1
36861: NEG
36862: PUSH
36863: LD_INT 3
36865: NEG
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 0
36873: PUSH
36874: LD_INT 3
36876: NEG
36877: PUSH
36878: EMPTY
36879: LIST
36880: LIST
36881: PUSH
36882: LD_INT 1
36884: PUSH
36885: LD_INT 2
36887: NEG
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: LIST
36897: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36898: LD_ADDR_VAR 0 12
36902: PUSH
36903: LD_INT 2
36905: PUSH
36906: LD_INT 1
36908: NEG
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 3
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 3
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: LIST
36938: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36939: LD_ADDR_VAR 0 13
36943: PUSH
36944: LD_INT 3
36946: PUSH
36947: LD_INT 2
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 3
36956: PUSH
36957: LD_INT 3
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 2
36966: PUSH
36967: LD_INT 3
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: LIST
36978: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36979: LD_ADDR_VAR 0 14
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: LD_INT 3
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 0
36996: PUSH
36997: LD_INT 3
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 1
37006: NEG
37007: PUSH
37008: LD_INT 2
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: LIST
37019: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37020: LD_ADDR_VAR 0 15
37024: PUSH
37025: LD_INT 2
37027: NEG
37028: PUSH
37029: LD_INT 1
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 3
37038: NEG
37039: PUSH
37040: LD_INT 0
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 3
37049: NEG
37050: PUSH
37051: LD_INT 1
37053: NEG
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: LIST
37063: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37064: LD_ADDR_VAR 0 16
37068: PUSH
37069: LD_INT 2
37071: NEG
37072: PUSH
37073: LD_INT 3
37075: NEG
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 3
37083: NEG
37084: PUSH
37085: LD_INT 2
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 3
37095: NEG
37096: PUSH
37097: LD_INT 3
37099: NEG
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: LIST
37109: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37110: LD_ADDR_VAR 0 17
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: LD_INT 3
37121: NEG
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 0
37129: PUSH
37130: LD_INT 3
37132: NEG
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 1
37140: PUSH
37141: LD_INT 2
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: LIST
37153: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37154: LD_ADDR_VAR 0 18
37158: PUSH
37159: LD_INT 2
37161: PUSH
37162: LD_INT 1
37164: NEG
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: PUSH
37170: LD_INT 3
37172: PUSH
37173: LD_INT 0
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: PUSH
37180: LD_INT 3
37182: PUSH
37183: LD_INT 1
37185: PUSH
37186: EMPTY
37187: LIST
37188: LIST
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: LIST
37194: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37195: LD_ADDR_VAR 0 19
37199: PUSH
37200: LD_INT 3
37202: PUSH
37203: LD_INT 2
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 3
37212: PUSH
37213: LD_INT 3
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 2
37222: PUSH
37223: LD_INT 3
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: LIST
37234: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37235: LD_ADDR_VAR 0 20
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 3
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 0
37252: PUSH
37253: LD_INT 3
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 1
37262: NEG
37263: PUSH
37264: LD_INT 2
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: LIST
37275: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37276: LD_ADDR_VAR 0 21
37280: PUSH
37281: LD_INT 2
37283: NEG
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 3
37294: NEG
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 3
37305: NEG
37306: PUSH
37307: LD_INT 1
37309: NEG
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: LIST
37319: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37320: LD_ADDR_VAR 0 22
37324: PUSH
37325: LD_INT 2
37327: NEG
37328: PUSH
37329: LD_INT 3
37331: NEG
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: LD_INT 3
37339: NEG
37340: PUSH
37341: LD_INT 2
37343: NEG
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 3
37351: NEG
37352: PUSH
37353: LD_INT 3
37355: NEG
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: LIST
37365: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37366: LD_ADDR_VAR 0 23
37370: PUSH
37371: LD_INT 0
37373: PUSH
37374: LD_INT 3
37376: NEG
37377: PUSH
37378: EMPTY
37379: LIST
37380: LIST
37381: PUSH
37382: LD_INT 1
37384: NEG
37385: PUSH
37386: LD_INT 4
37388: NEG
37389: PUSH
37390: EMPTY
37391: LIST
37392: LIST
37393: PUSH
37394: LD_INT 1
37396: PUSH
37397: LD_INT 3
37399: NEG
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37410: LD_ADDR_VAR 0 24
37414: PUSH
37415: LD_INT 3
37417: PUSH
37418: LD_INT 0
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 3
37427: PUSH
37428: LD_INT 1
37430: NEG
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 4
37438: PUSH
37439: LD_INT 1
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: LIST
37450: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37451: LD_ADDR_VAR 0 25
37455: PUSH
37456: LD_INT 3
37458: PUSH
37459: LD_INT 3
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 4
37468: PUSH
37469: LD_INT 3
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 3
37478: PUSH
37479: LD_INT 4
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: LIST
37490: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37491: LD_ADDR_VAR 0 26
37495: PUSH
37496: LD_INT 0
37498: PUSH
37499: LD_INT 3
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: PUSH
37509: LD_INT 4
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 1
37518: NEG
37519: PUSH
37520: LD_INT 3
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: EMPTY
37528: LIST
37529: LIST
37530: LIST
37531: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37532: LD_ADDR_VAR 0 27
37536: PUSH
37537: LD_INT 3
37539: NEG
37540: PUSH
37541: LD_INT 0
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 3
37550: NEG
37551: PUSH
37552: LD_INT 1
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 4
37561: NEG
37562: PUSH
37563: LD_INT 1
37565: NEG
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: LIST
37575: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37576: LD_ADDR_VAR 0 28
37580: PUSH
37581: LD_INT 3
37583: NEG
37584: PUSH
37585: LD_INT 3
37587: NEG
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PUSH
37593: LD_INT 3
37595: NEG
37596: PUSH
37597: LD_INT 4
37599: NEG
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 4
37607: NEG
37608: PUSH
37609: LD_INT 3
37611: NEG
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: LIST
37621: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37622: LD_ADDR_VAR 0 29
37626: PUSH
37627: LD_INT 1
37629: NEG
37630: PUSH
37631: LD_INT 3
37633: NEG
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 0
37641: PUSH
37642: LD_INT 3
37644: NEG
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 1
37652: PUSH
37653: LD_INT 2
37655: NEG
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 1
37663: NEG
37664: PUSH
37665: LD_INT 4
37667: NEG
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 0
37675: PUSH
37676: LD_INT 4
37678: NEG
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 1
37686: PUSH
37687: LD_INT 3
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: LD_INT 5
37701: NEG
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 0
37709: PUSH
37710: LD_INT 5
37712: NEG
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 1
37720: PUSH
37721: LD_INT 4
37723: NEG
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 1
37731: NEG
37732: PUSH
37733: LD_INT 6
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 0
37743: PUSH
37744: LD_INT 6
37746: NEG
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: LD_INT 5
37757: NEG
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: LIST
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37777: LD_ADDR_VAR 0 30
37781: PUSH
37782: LD_INT 2
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 3
37795: PUSH
37796: LD_INT 0
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 3
37805: PUSH
37806: LD_INT 1
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 3
37815: PUSH
37816: LD_INT 1
37818: NEG
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 4
37826: PUSH
37827: LD_INT 0
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 4
37836: PUSH
37837: LD_INT 1
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 4
37846: PUSH
37847: LD_INT 1
37849: NEG
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 5
37857: PUSH
37858: LD_INT 0
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 5
37867: PUSH
37868: LD_INT 1
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 5
37877: PUSH
37878: LD_INT 1
37880: NEG
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 6
37888: PUSH
37889: LD_INT 0
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 6
37898: PUSH
37899: LD_INT 1
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: LIST
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37920: LD_ADDR_VAR 0 31
37924: PUSH
37925: LD_INT 3
37927: PUSH
37928: LD_INT 2
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 3
37937: PUSH
37938: LD_INT 3
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 2
37947: PUSH
37948: LD_INT 3
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 4
37957: PUSH
37958: LD_INT 3
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 4
37967: PUSH
37968: LD_INT 4
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 3
37977: PUSH
37978: LD_INT 4
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 5
37987: PUSH
37988: LD_INT 4
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 5
37997: PUSH
37998: LD_INT 5
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 4
38007: PUSH
38008: LD_INT 5
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 6
38017: PUSH
38018: LD_INT 5
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: LD_INT 6
38027: PUSH
38028: LD_INT 6
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 5
38037: PUSH
38038: LD_INT 6
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38059: LD_ADDR_VAR 0 32
38063: PUSH
38064: LD_INT 1
38066: PUSH
38067: LD_INT 3
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: LD_INT 3
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 1
38086: NEG
38087: PUSH
38088: LD_INT 2
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 4
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 0
38107: PUSH
38108: LD_INT 4
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 1
38117: NEG
38118: PUSH
38119: LD_INT 3
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 1
38128: PUSH
38129: LD_INT 5
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: LD_INT 5
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: LD_INT 4
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 6
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: LD_INT 0
38169: PUSH
38170: LD_INT 6
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 1
38179: NEG
38180: PUSH
38181: LD_INT 5
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: LIST
38194: LIST
38195: LIST
38196: LIST
38197: LIST
38198: LIST
38199: LIST
38200: LIST
38201: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38202: LD_ADDR_VAR 0 33
38206: PUSH
38207: LD_INT 2
38209: NEG
38210: PUSH
38211: LD_INT 1
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 3
38220: NEG
38221: PUSH
38222: LD_INT 0
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 3
38231: NEG
38232: PUSH
38233: LD_INT 1
38235: NEG
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 3
38243: NEG
38244: PUSH
38245: LD_INT 1
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 4
38254: NEG
38255: PUSH
38256: LD_INT 0
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: LD_INT 4
38265: NEG
38266: PUSH
38267: LD_INT 1
38269: NEG
38270: PUSH
38271: EMPTY
38272: LIST
38273: LIST
38274: PUSH
38275: LD_INT 4
38277: NEG
38278: PUSH
38279: LD_INT 1
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 5
38288: NEG
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: EMPTY
38294: LIST
38295: LIST
38296: PUSH
38297: LD_INT 5
38299: NEG
38300: PUSH
38301: LD_INT 1
38303: NEG
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 5
38311: NEG
38312: PUSH
38313: LD_INT 1
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 6
38322: NEG
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 6
38333: NEG
38334: PUSH
38335: LD_INT 1
38337: NEG
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: LIST
38347: LIST
38348: LIST
38349: LIST
38350: LIST
38351: LIST
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38357: LD_ADDR_VAR 0 34
38361: PUSH
38362: LD_INT 2
38364: NEG
38365: PUSH
38366: LD_INT 3
38368: NEG
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 3
38376: NEG
38377: PUSH
38378: LD_INT 2
38380: NEG
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 3
38388: NEG
38389: PUSH
38390: LD_INT 3
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 3
38400: NEG
38401: PUSH
38402: LD_INT 4
38404: NEG
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 4
38412: NEG
38413: PUSH
38414: LD_INT 3
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 4
38424: NEG
38425: PUSH
38426: LD_INT 4
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 4
38436: NEG
38437: PUSH
38438: LD_INT 5
38440: NEG
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 5
38448: NEG
38449: PUSH
38450: LD_INT 4
38452: NEG
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 5
38460: NEG
38461: PUSH
38462: LD_INT 5
38464: NEG
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 5
38472: NEG
38473: PUSH
38474: LD_INT 6
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 6
38484: NEG
38485: PUSH
38486: LD_INT 5
38488: NEG
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 6
38496: NEG
38497: PUSH
38498: LD_INT 6
38500: NEG
38501: PUSH
38502: EMPTY
38503: LIST
38504: LIST
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38520: LD_ADDR_VAR 0 41
38524: PUSH
38525: LD_INT 0
38527: PUSH
38528: LD_INT 2
38530: NEG
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 1
38538: NEG
38539: PUSH
38540: LD_INT 3
38542: NEG
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 1
38550: PUSH
38551: LD_INT 2
38553: NEG
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: LIST
38563: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38564: LD_ADDR_VAR 0 42
38568: PUSH
38569: LD_INT 2
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: PUSH
38579: LD_INT 2
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 3
38592: PUSH
38593: LD_INT 1
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: LIST
38604: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38605: LD_ADDR_VAR 0 43
38609: PUSH
38610: LD_INT 2
38612: PUSH
38613: LD_INT 2
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 3
38622: PUSH
38623: LD_INT 2
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: LD_INT 2
38632: PUSH
38633: LD_INT 3
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: LIST
38644: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38645: LD_ADDR_VAR 0 44
38649: PUSH
38650: LD_INT 0
38652: PUSH
38653: LD_INT 2
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: PUSH
38660: LD_INT 1
38662: PUSH
38663: LD_INT 3
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: LD_INT 1
38672: NEG
38673: PUSH
38674: LD_INT 2
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: LIST
38685: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38686: LD_ADDR_VAR 0 45
38690: PUSH
38691: LD_INT 2
38693: NEG
38694: PUSH
38695: LD_INT 0
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 2
38704: NEG
38705: PUSH
38706: LD_INT 1
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: LD_INT 3
38715: NEG
38716: PUSH
38717: LD_INT 1
38719: NEG
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: LIST
38729: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38730: LD_ADDR_VAR 0 46
38734: PUSH
38735: LD_INT 2
38737: NEG
38738: PUSH
38739: LD_INT 2
38741: NEG
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 2
38749: NEG
38750: PUSH
38751: LD_INT 3
38753: NEG
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 3
38761: NEG
38762: PUSH
38763: LD_INT 2
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: LIST
38775: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38776: LD_ADDR_VAR 0 47
38780: PUSH
38781: LD_INT 2
38783: NEG
38784: PUSH
38785: LD_INT 3
38787: NEG
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: LD_INT 3
38799: NEG
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38809: LD_ADDR_VAR 0 48
38813: PUSH
38814: LD_INT 1
38816: PUSH
38817: LD_INT 2
38819: NEG
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 2
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38840: LD_ADDR_VAR 0 49
38844: PUSH
38845: LD_INT 3
38847: PUSH
38848: LD_INT 1
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 3
38857: PUSH
38858: LD_INT 2
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38869: LD_ADDR_VAR 0 50
38873: PUSH
38874: LD_INT 2
38876: PUSH
38877: LD_INT 3
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: PUSH
38887: LD_INT 3
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38898: LD_ADDR_VAR 0 51
38902: PUSH
38903: LD_INT 1
38905: NEG
38906: PUSH
38907: LD_INT 2
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 2
38916: NEG
38917: PUSH
38918: LD_INT 1
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38929: LD_ADDR_VAR 0 52
38933: PUSH
38934: LD_INT 3
38936: NEG
38937: PUSH
38938: LD_INT 1
38940: NEG
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 3
38948: NEG
38949: PUSH
38950: LD_INT 2
38952: NEG
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38962: LD_ADDR_VAR 0 53
38966: PUSH
38967: LD_INT 1
38969: NEG
38970: PUSH
38971: LD_INT 3
38973: NEG
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 0
38981: PUSH
38982: LD_INT 3
38984: NEG
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 1
38992: PUSH
38993: LD_INT 2
38995: NEG
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: LIST
39005: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39006: LD_ADDR_VAR 0 54
39010: PUSH
39011: LD_INT 2
39013: PUSH
39014: LD_INT 1
39016: NEG
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 3
39024: PUSH
39025: LD_INT 0
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 3
39034: PUSH
39035: LD_INT 1
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: LIST
39046: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39047: LD_ADDR_VAR 0 55
39051: PUSH
39052: LD_INT 3
39054: PUSH
39055: LD_INT 2
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 3
39064: PUSH
39065: LD_INT 3
39067: PUSH
39068: EMPTY
39069: LIST
39070: LIST
39071: PUSH
39072: LD_INT 2
39074: PUSH
39075: LD_INT 3
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: LIST
39086: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39087: LD_ADDR_VAR 0 56
39091: PUSH
39092: LD_INT 1
39094: PUSH
39095: LD_INT 3
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 3
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 1
39114: NEG
39115: PUSH
39116: LD_INT 2
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: LIST
39127: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39128: LD_ADDR_VAR 0 57
39132: PUSH
39133: LD_INT 2
39135: NEG
39136: PUSH
39137: LD_INT 1
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 3
39146: NEG
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 3
39157: NEG
39158: PUSH
39159: LD_INT 1
39161: NEG
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: LIST
39171: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39172: LD_ADDR_VAR 0 58
39176: PUSH
39177: LD_INT 2
39179: NEG
39180: PUSH
39181: LD_INT 3
39183: NEG
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 3
39191: NEG
39192: PUSH
39193: LD_INT 2
39195: NEG
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 3
39203: NEG
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: LIST
39217: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39218: LD_ADDR_VAR 0 59
39222: PUSH
39223: LD_INT 1
39225: NEG
39226: PUSH
39227: LD_INT 2
39229: NEG
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 0
39237: PUSH
39238: LD_INT 2
39240: NEG
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 1
39251: NEG
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: LIST
39261: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39262: LD_ADDR_VAR 0 60
39266: PUSH
39267: LD_INT 1
39269: PUSH
39270: LD_INT 1
39272: NEG
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 2
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 2
39290: PUSH
39291: LD_INT 1
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: LIST
39302: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39303: LD_ADDR_VAR 0 61
39307: PUSH
39308: LD_INT 2
39310: PUSH
39311: LD_INT 1
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 2
39320: PUSH
39321: LD_INT 2
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 1
39330: PUSH
39331: LD_INT 2
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: LIST
39342: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39343: LD_ADDR_VAR 0 62
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: LD_INT 2
39353: PUSH
39354: EMPTY
39355: LIST
39356: LIST
39357: PUSH
39358: LD_INT 0
39360: PUSH
39361: LD_INT 2
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 1
39370: NEG
39371: PUSH
39372: LD_INT 1
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: LIST
39383: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39384: LD_ADDR_VAR 0 63
39388: PUSH
39389: LD_INT 1
39391: NEG
39392: PUSH
39393: LD_INT 1
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 2
39402: NEG
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 2
39413: NEG
39414: PUSH
39415: LD_INT 1
39417: NEG
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: LIST
39427: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39428: LD_ADDR_VAR 0 64
39432: PUSH
39433: LD_INT 1
39435: NEG
39436: PUSH
39437: LD_INT 2
39439: NEG
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: LD_INT 2
39447: NEG
39448: PUSH
39449: LD_INT 1
39451: NEG
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 2
39459: NEG
39460: PUSH
39461: LD_INT 2
39463: NEG
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: LIST
39473: ST_TO_ADDR
// end ; 2 :
39474: GO 42740
39476: LD_INT 2
39478: DOUBLE
39479: EQUAL
39480: IFTRUE 39484
39482: GO 42739
39484: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39485: LD_ADDR_VAR 0 29
39489: PUSH
39490: LD_INT 4
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 4
39502: PUSH
39503: LD_INT 1
39505: NEG
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 5
39513: PUSH
39514: LD_INT 0
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: LD_INT 5
39523: PUSH
39524: LD_INT 1
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 4
39533: PUSH
39534: LD_INT 1
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 3
39543: PUSH
39544: LD_INT 0
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 3
39553: PUSH
39554: LD_INT 1
39556: NEG
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: LD_INT 3
39564: PUSH
39565: LD_INT 2
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 5
39575: PUSH
39576: LD_INT 2
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 3
39585: PUSH
39586: LD_INT 3
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 3
39595: PUSH
39596: LD_INT 2
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 4
39605: PUSH
39606: LD_INT 3
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 4
39615: PUSH
39616: LD_INT 4
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 3
39625: PUSH
39626: LD_INT 4
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 2
39635: PUSH
39636: LD_INT 3
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 2
39645: PUSH
39646: LD_INT 2
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 4
39655: PUSH
39656: LD_INT 2
39658: PUSH
39659: EMPTY
39660: LIST
39661: LIST
39662: PUSH
39663: LD_INT 2
39665: PUSH
39666: LD_INT 4
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 0
39675: PUSH
39676: LD_INT 4
39678: PUSH
39679: EMPTY
39680: LIST
39681: LIST
39682: PUSH
39683: LD_INT 0
39685: PUSH
39686: LD_INT 3
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 1
39695: PUSH
39696: LD_INT 4
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 1
39705: PUSH
39706: LD_INT 5
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 0
39715: PUSH
39716: LD_INT 5
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 1
39725: NEG
39726: PUSH
39727: LD_INT 4
39729: PUSH
39730: EMPTY
39731: LIST
39732: LIST
39733: PUSH
39734: LD_INT 1
39736: NEG
39737: PUSH
39738: LD_INT 3
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 2
39747: PUSH
39748: LD_INT 5
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 2
39757: NEG
39758: PUSH
39759: LD_INT 3
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: LD_INT 3
39768: NEG
39769: PUSH
39770: LD_INT 0
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PUSH
39777: LD_INT 3
39779: NEG
39780: PUSH
39781: LD_INT 1
39783: NEG
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 2
39791: NEG
39792: PUSH
39793: LD_INT 0
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 2
39802: NEG
39803: PUSH
39804: LD_INT 1
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 3
39813: NEG
39814: PUSH
39815: LD_INT 1
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 4
39824: NEG
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: EMPTY
39830: LIST
39831: LIST
39832: PUSH
39833: LD_INT 4
39835: NEG
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 4
39847: NEG
39848: PUSH
39849: LD_INT 2
39851: NEG
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 2
39859: NEG
39860: PUSH
39861: LD_INT 2
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 4
39870: NEG
39871: PUSH
39872: LD_INT 4
39874: NEG
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 4
39882: NEG
39883: PUSH
39884: LD_INT 5
39886: NEG
39887: PUSH
39888: EMPTY
39889: LIST
39890: LIST
39891: PUSH
39892: LD_INT 3
39894: NEG
39895: PUSH
39896: LD_INT 4
39898: NEG
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 3
39906: NEG
39907: PUSH
39908: LD_INT 3
39910: NEG
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: LD_INT 4
39918: NEG
39919: PUSH
39920: LD_INT 3
39922: NEG
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 5
39930: NEG
39931: PUSH
39932: LD_INT 4
39934: NEG
39935: PUSH
39936: EMPTY
39937: LIST
39938: LIST
39939: PUSH
39940: LD_INT 5
39942: NEG
39943: PUSH
39944: LD_INT 5
39946: NEG
39947: PUSH
39948: EMPTY
39949: LIST
39950: LIST
39951: PUSH
39952: LD_INT 3
39954: NEG
39955: PUSH
39956: LD_INT 5
39958: NEG
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 5
39966: NEG
39967: PUSH
39968: LD_INT 3
39970: NEG
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40023: LD_ADDR_VAR 0 30
40027: PUSH
40028: LD_INT 4
40030: PUSH
40031: LD_INT 4
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 4
40040: PUSH
40041: LD_INT 3
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 5
40050: PUSH
40051: LD_INT 4
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 5
40060: PUSH
40061: LD_INT 5
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 4
40070: PUSH
40071: LD_INT 5
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 3
40080: PUSH
40081: LD_INT 4
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 3
40090: PUSH
40091: LD_INT 3
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 5
40100: PUSH
40101: LD_INT 3
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 3
40110: PUSH
40111: LD_INT 5
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 0
40120: PUSH
40121: LD_INT 3
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: LD_INT 2
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: LD_INT 1
40140: PUSH
40141: LD_INT 3
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: LD_INT 4
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 0
40160: PUSH
40161: LD_INT 4
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: NEG
40171: PUSH
40172: LD_INT 3
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 1
40181: NEG
40182: PUSH
40183: LD_INT 2
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 2
40192: PUSH
40193: LD_INT 4
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 2
40202: NEG
40203: PUSH
40204: LD_INT 2
40206: PUSH
40207: EMPTY
40208: LIST
40209: LIST
40210: PUSH
40211: LD_INT 4
40213: NEG
40214: PUSH
40215: LD_INT 0
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: PUSH
40222: LD_INT 4
40224: NEG
40225: PUSH
40226: LD_INT 1
40228: NEG
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 3
40236: NEG
40237: PUSH
40238: LD_INT 0
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 3
40247: NEG
40248: PUSH
40249: LD_INT 1
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: LD_INT 4
40258: NEG
40259: PUSH
40260: LD_INT 1
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 5
40269: NEG
40270: PUSH
40271: LD_INT 0
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 5
40280: NEG
40281: PUSH
40282: LD_INT 1
40284: NEG
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 5
40292: NEG
40293: PUSH
40294: LD_INT 2
40296: NEG
40297: PUSH
40298: EMPTY
40299: LIST
40300: LIST
40301: PUSH
40302: LD_INT 3
40304: NEG
40305: PUSH
40306: LD_INT 2
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 3
40315: NEG
40316: PUSH
40317: LD_INT 3
40319: NEG
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 3
40327: NEG
40328: PUSH
40329: LD_INT 4
40331: NEG
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: LD_INT 2
40339: NEG
40340: PUSH
40341: LD_INT 3
40343: NEG
40344: PUSH
40345: EMPTY
40346: LIST
40347: LIST
40348: PUSH
40349: LD_INT 2
40351: NEG
40352: PUSH
40353: LD_INT 2
40355: NEG
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 3
40363: NEG
40364: PUSH
40365: LD_INT 2
40367: NEG
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 4
40375: NEG
40376: PUSH
40377: LD_INT 3
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 4
40387: NEG
40388: PUSH
40389: LD_INT 4
40391: NEG
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 2
40399: NEG
40400: PUSH
40401: LD_INT 4
40403: NEG
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 4
40411: NEG
40412: PUSH
40413: LD_INT 2
40415: NEG
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: PUSH
40421: LD_INT 0
40423: PUSH
40424: LD_INT 4
40426: NEG
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: LD_INT 0
40434: PUSH
40435: LD_INT 5
40437: NEG
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 1
40445: PUSH
40446: LD_INT 4
40448: NEG
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: LD_INT 3
40459: NEG
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 0
40467: PUSH
40468: LD_INT 3
40470: NEG
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 1
40478: NEG
40479: PUSH
40480: LD_INT 4
40482: NEG
40483: PUSH
40484: EMPTY
40485: LIST
40486: LIST
40487: PUSH
40488: LD_INT 1
40490: NEG
40491: PUSH
40492: LD_INT 5
40494: NEG
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: LD_INT 2
40502: PUSH
40503: LD_INT 3
40505: NEG
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 2
40513: NEG
40514: PUSH
40515: LD_INT 5
40517: NEG
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40570: LD_ADDR_VAR 0 31
40574: PUSH
40575: LD_INT 0
40577: PUSH
40578: LD_INT 4
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: LD_INT 3
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 1
40597: PUSH
40598: LD_INT 4
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: LD_INT 1
40607: PUSH
40608: LD_INT 5
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 0
40617: PUSH
40618: LD_INT 5
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 1
40627: NEG
40628: PUSH
40629: LD_INT 4
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PUSH
40636: LD_INT 1
40638: NEG
40639: PUSH
40640: LD_INT 3
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 2
40649: PUSH
40650: LD_INT 5
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 2
40659: NEG
40660: PUSH
40661: LD_INT 3
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 3
40670: NEG
40671: PUSH
40672: LD_INT 0
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 3
40681: NEG
40682: PUSH
40683: LD_INT 1
40685: NEG
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 2
40693: NEG
40694: PUSH
40695: LD_INT 0
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 2
40704: NEG
40705: PUSH
40706: LD_INT 1
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 3
40715: NEG
40716: PUSH
40717: LD_INT 1
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 4
40726: NEG
40727: PUSH
40728: LD_INT 0
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: LD_INT 4
40737: NEG
40738: PUSH
40739: LD_INT 1
40741: NEG
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 4
40749: NEG
40750: PUSH
40751: LD_INT 2
40753: NEG
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: LD_INT 2
40761: NEG
40762: PUSH
40763: LD_INT 2
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 4
40772: NEG
40773: PUSH
40774: LD_INT 4
40776: NEG
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 4
40784: NEG
40785: PUSH
40786: LD_INT 5
40788: NEG
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 3
40796: NEG
40797: PUSH
40798: LD_INT 4
40800: NEG
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 3
40808: NEG
40809: PUSH
40810: LD_INT 3
40812: NEG
40813: PUSH
40814: EMPTY
40815: LIST
40816: LIST
40817: PUSH
40818: LD_INT 4
40820: NEG
40821: PUSH
40822: LD_INT 3
40824: NEG
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 5
40832: NEG
40833: PUSH
40834: LD_INT 4
40836: NEG
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 5
40844: NEG
40845: PUSH
40846: LD_INT 5
40848: NEG
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 3
40856: NEG
40857: PUSH
40858: LD_INT 5
40860: NEG
40861: PUSH
40862: EMPTY
40863: LIST
40864: LIST
40865: PUSH
40866: LD_INT 5
40868: NEG
40869: PUSH
40870: LD_INT 3
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 0
40880: PUSH
40881: LD_INT 3
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 0
40891: PUSH
40892: LD_INT 4
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 1
40902: PUSH
40903: LD_INT 3
40905: NEG
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 1
40913: PUSH
40914: LD_INT 2
40916: NEG
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: LD_INT 0
40924: PUSH
40925: LD_INT 2
40927: NEG
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 1
40935: NEG
40936: PUSH
40937: LD_INT 3
40939: NEG
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 1
40947: NEG
40948: PUSH
40949: LD_INT 4
40951: NEG
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: LD_INT 2
40959: PUSH
40960: LD_INT 2
40962: NEG
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 2
40970: NEG
40971: PUSH
40972: LD_INT 4
40974: NEG
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 4
40982: PUSH
40983: LD_INT 0
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: PUSH
40990: LD_INT 4
40992: PUSH
40993: LD_INT 1
40995: NEG
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: LD_INT 5
41003: PUSH
41004: LD_INT 0
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 5
41013: PUSH
41014: LD_INT 1
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: PUSH
41021: LD_INT 4
41023: PUSH
41024: LD_INT 1
41026: PUSH
41027: EMPTY
41028: LIST
41029: LIST
41030: PUSH
41031: LD_INT 3
41033: PUSH
41034: LD_INT 0
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 3
41043: PUSH
41044: LD_INT 1
41046: NEG
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: LD_INT 3
41054: PUSH
41055: LD_INT 2
41057: NEG
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 5
41065: PUSH
41066: LD_INT 2
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: LIST
41077: LIST
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: LIST
41113: LIST
41114: LIST
41115: LIST
41116: LIST
41117: LIST
41118: LIST
41119: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41120: LD_ADDR_VAR 0 32
41124: PUSH
41125: LD_INT 4
41127: NEG
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 4
41138: NEG
41139: PUSH
41140: LD_INT 1
41142: NEG
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: LD_INT 3
41150: NEG
41151: PUSH
41152: LD_INT 0
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: PUSH
41159: LD_INT 3
41161: NEG
41162: PUSH
41163: LD_INT 1
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: LD_INT 4
41172: NEG
41173: PUSH
41174: LD_INT 1
41176: PUSH
41177: EMPTY
41178: LIST
41179: LIST
41180: PUSH
41181: LD_INT 5
41183: NEG
41184: PUSH
41185: LD_INT 0
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 5
41194: NEG
41195: PUSH
41196: LD_INT 1
41198: NEG
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 5
41206: NEG
41207: PUSH
41208: LD_INT 2
41210: NEG
41211: PUSH
41212: EMPTY
41213: LIST
41214: LIST
41215: PUSH
41216: LD_INT 3
41218: NEG
41219: PUSH
41220: LD_INT 2
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 3
41229: NEG
41230: PUSH
41231: LD_INT 3
41233: NEG
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: PUSH
41239: LD_INT 3
41241: NEG
41242: PUSH
41243: LD_INT 4
41245: NEG
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 2
41253: NEG
41254: PUSH
41255: LD_INT 3
41257: NEG
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 2
41265: NEG
41266: PUSH
41267: LD_INT 2
41269: NEG
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PUSH
41275: LD_INT 3
41277: NEG
41278: PUSH
41279: LD_INT 2
41281: NEG
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 4
41289: NEG
41290: PUSH
41291: LD_INT 3
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 4
41301: NEG
41302: PUSH
41303: LD_INT 4
41305: NEG
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: PUSH
41311: LD_INT 2
41313: NEG
41314: PUSH
41315: LD_INT 4
41317: NEG
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: LD_INT 4
41325: NEG
41326: PUSH
41327: LD_INT 2
41329: NEG
41330: PUSH
41331: EMPTY
41332: LIST
41333: LIST
41334: PUSH
41335: LD_INT 0
41337: PUSH
41338: LD_INT 4
41340: NEG
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: PUSH
41346: LD_INT 0
41348: PUSH
41349: LD_INT 5
41351: NEG
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 1
41359: PUSH
41360: LD_INT 4
41362: NEG
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 1
41370: PUSH
41371: LD_INT 3
41373: NEG
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 0
41381: PUSH
41382: LD_INT 3
41384: NEG
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 1
41392: NEG
41393: PUSH
41394: LD_INT 4
41396: NEG
41397: PUSH
41398: EMPTY
41399: LIST
41400: LIST
41401: PUSH
41402: LD_INT 1
41404: NEG
41405: PUSH
41406: LD_INT 5
41408: NEG
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: PUSH
41414: LD_INT 2
41416: PUSH
41417: LD_INT 3
41419: NEG
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 2
41427: NEG
41428: PUSH
41429: LD_INT 5
41431: NEG
41432: PUSH
41433: EMPTY
41434: LIST
41435: LIST
41436: PUSH
41437: LD_INT 3
41439: PUSH
41440: LD_INT 0
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 3
41449: PUSH
41450: LD_INT 1
41452: NEG
41453: PUSH
41454: EMPTY
41455: LIST
41456: LIST
41457: PUSH
41458: LD_INT 4
41460: PUSH
41461: LD_INT 0
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 4
41470: PUSH
41471: LD_INT 1
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 3
41480: PUSH
41481: LD_INT 1
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: PUSH
41488: LD_INT 2
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 2
41500: PUSH
41501: LD_INT 1
41503: NEG
41504: PUSH
41505: EMPTY
41506: LIST
41507: LIST
41508: PUSH
41509: LD_INT 2
41511: PUSH
41512: LD_INT 2
41514: NEG
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 4
41522: PUSH
41523: LD_INT 2
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 4
41532: PUSH
41533: LD_INT 4
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 4
41542: PUSH
41543: LD_INT 3
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 5
41552: PUSH
41553: LD_INT 4
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 5
41562: PUSH
41563: LD_INT 5
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 4
41572: PUSH
41573: LD_INT 5
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 3
41582: PUSH
41583: LD_INT 4
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 3
41592: PUSH
41593: LD_INT 3
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: PUSH
41600: LD_INT 5
41602: PUSH
41603: LD_INT 3
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 3
41612: PUSH
41613: LD_INT 5
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: LIST
41624: LIST
41625: LIST
41626: LIST
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: LIST
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: LIST
41644: LIST
41645: LIST
41646: LIST
41647: LIST
41648: LIST
41649: LIST
41650: LIST
41651: LIST
41652: LIST
41653: LIST
41654: LIST
41655: LIST
41656: LIST
41657: LIST
41658: LIST
41659: LIST
41660: LIST
41661: LIST
41662: LIST
41663: LIST
41664: LIST
41665: LIST
41666: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41667: LD_ADDR_VAR 0 33
41671: PUSH
41672: LD_INT 4
41674: NEG
41675: PUSH
41676: LD_INT 4
41678: NEG
41679: PUSH
41680: EMPTY
41681: LIST
41682: LIST
41683: PUSH
41684: LD_INT 4
41686: NEG
41687: PUSH
41688: LD_INT 5
41690: NEG
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 3
41698: NEG
41699: PUSH
41700: LD_INT 4
41702: NEG
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 3
41710: NEG
41711: PUSH
41712: LD_INT 3
41714: NEG
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: PUSH
41720: LD_INT 4
41722: NEG
41723: PUSH
41724: LD_INT 3
41726: NEG
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: LD_INT 5
41734: NEG
41735: PUSH
41736: LD_INT 4
41738: NEG
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: PUSH
41744: LD_INT 5
41746: NEG
41747: PUSH
41748: LD_INT 5
41750: NEG
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: PUSH
41756: LD_INT 3
41758: NEG
41759: PUSH
41760: LD_INT 5
41762: NEG
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 5
41770: NEG
41771: PUSH
41772: LD_INT 3
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 0
41782: PUSH
41783: LD_INT 3
41785: NEG
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 0
41793: PUSH
41794: LD_INT 4
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 1
41804: PUSH
41805: LD_INT 3
41807: NEG
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 1
41815: PUSH
41816: LD_INT 2
41818: NEG
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 0
41826: PUSH
41827: LD_INT 2
41829: NEG
41830: PUSH
41831: EMPTY
41832: LIST
41833: LIST
41834: PUSH
41835: LD_INT 1
41837: NEG
41838: PUSH
41839: LD_INT 3
41841: NEG
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 1
41849: NEG
41850: PUSH
41851: LD_INT 4
41853: NEG
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: LD_INT 2
41861: PUSH
41862: LD_INT 2
41864: NEG
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: LD_INT 2
41872: NEG
41873: PUSH
41874: LD_INT 4
41876: NEG
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: PUSH
41882: LD_INT 4
41884: PUSH
41885: LD_INT 0
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 4
41894: PUSH
41895: LD_INT 1
41897: NEG
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: PUSH
41903: LD_INT 5
41905: PUSH
41906: LD_INT 0
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 5
41915: PUSH
41916: LD_INT 1
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 4
41925: PUSH
41926: LD_INT 1
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 3
41935: PUSH
41936: LD_INT 0
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: LD_INT 3
41945: PUSH
41946: LD_INT 1
41948: NEG
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 3
41956: PUSH
41957: LD_INT 2
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 5
41967: PUSH
41968: LD_INT 2
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 3
41977: PUSH
41978: LD_INT 3
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 3
41987: PUSH
41988: LD_INT 2
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 4
41997: PUSH
41998: LD_INT 3
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 4
42007: PUSH
42008: LD_INT 4
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: PUSH
42015: LD_INT 3
42017: PUSH
42018: LD_INT 4
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 2
42027: PUSH
42028: LD_INT 3
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 2
42037: PUSH
42038: LD_INT 2
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 4
42047: PUSH
42048: LD_INT 2
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 2
42057: PUSH
42058: LD_INT 4
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 0
42067: PUSH
42068: LD_INT 4
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 0
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: EMPTY
42082: LIST
42083: LIST
42084: PUSH
42085: LD_INT 1
42087: PUSH
42088: LD_INT 4
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 1
42097: PUSH
42098: LD_INT 5
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PUSH
42105: LD_INT 0
42107: PUSH
42108: LD_INT 5
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_INT 1
42117: NEG
42118: PUSH
42119: LD_INT 4
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: LD_INT 1
42128: NEG
42129: PUSH
42130: LD_INT 3
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 2
42139: PUSH
42140: LD_INT 5
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 2
42149: NEG
42150: PUSH
42151: LD_INT 3
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: LIST
42162: LIST
42163: LIST
42164: LIST
42165: LIST
42166: LIST
42167: LIST
42168: LIST
42169: LIST
42170: LIST
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: LIST
42179: LIST
42180: LIST
42181: LIST
42182: LIST
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: LIST
42196: LIST
42197: LIST
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: LIST
42203: LIST
42204: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42205: LD_ADDR_VAR 0 34
42209: PUSH
42210: LD_INT 0
42212: PUSH
42213: LD_INT 4
42215: NEG
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 0
42223: PUSH
42224: LD_INT 5
42226: NEG
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 1
42234: PUSH
42235: LD_INT 4
42237: NEG
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 1
42245: PUSH
42246: LD_INT 3
42248: NEG
42249: PUSH
42250: EMPTY
42251: LIST
42252: LIST
42253: PUSH
42254: LD_INT 0
42256: PUSH
42257: LD_INT 3
42259: NEG
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 1
42267: NEG
42268: PUSH
42269: LD_INT 4
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 1
42279: NEG
42280: PUSH
42281: LD_INT 5
42283: NEG
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 2
42291: PUSH
42292: LD_INT 3
42294: NEG
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 2
42302: NEG
42303: PUSH
42304: LD_INT 5
42306: NEG
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: PUSH
42312: LD_INT 3
42314: PUSH
42315: LD_INT 0
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 3
42324: PUSH
42325: LD_INT 1
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 4
42335: PUSH
42336: LD_INT 0
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 4
42345: PUSH
42346: LD_INT 1
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 3
42355: PUSH
42356: LD_INT 1
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 2
42365: PUSH
42366: LD_INT 0
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 2
42375: PUSH
42376: LD_INT 1
42378: NEG
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PUSH
42384: LD_INT 2
42386: PUSH
42387: LD_INT 2
42389: NEG
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 4
42397: PUSH
42398: LD_INT 2
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 4
42407: PUSH
42408: LD_INT 4
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 4
42417: PUSH
42418: LD_INT 3
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 5
42427: PUSH
42428: LD_INT 4
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 5
42437: PUSH
42438: LD_INT 5
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: LD_INT 4
42447: PUSH
42448: LD_INT 5
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: LD_INT 3
42457: PUSH
42458: LD_INT 4
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 3
42467: PUSH
42468: LD_INT 3
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 5
42477: PUSH
42478: LD_INT 3
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: LD_INT 3
42487: PUSH
42488: LD_INT 5
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 0
42497: PUSH
42498: LD_INT 3
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 2
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 1
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 1
42527: PUSH
42528: LD_INT 4
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: PUSH
42535: LD_INT 0
42537: PUSH
42538: LD_INT 4
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 1
42547: NEG
42548: PUSH
42549: LD_INT 3
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 1
42558: NEG
42559: PUSH
42560: LD_INT 2
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: LD_INT 2
42569: PUSH
42570: LD_INT 4
42572: PUSH
42573: EMPTY
42574: LIST
42575: LIST
42576: PUSH
42577: LD_INT 2
42579: NEG
42580: PUSH
42581: LD_INT 2
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 4
42590: NEG
42591: PUSH
42592: LD_INT 0
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 4
42601: NEG
42602: PUSH
42603: LD_INT 1
42605: NEG
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 3
42613: NEG
42614: PUSH
42615: LD_INT 0
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 3
42624: NEG
42625: PUSH
42626: LD_INT 1
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 4
42635: NEG
42636: PUSH
42637: LD_INT 1
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 5
42646: NEG
42647: PUSH
42648: LD_INT 0
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: LD_INT 5
42657: NEG
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 5
42669: NEG
42670: PUSH
42671: LD_INT 2
42673: NEG
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 3
42681: NEG
42682: PUSH
42683: LD_INT 2
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: LIST
42694: LIST
42695: LIST
42696: LIST
42697: LIST
42698: LIST
42699: LIST
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: LIST
42707: LIST
42708: LIST
42709: LIST
42710: LIST
42711: LIST
42712: LIST
42713: LIST
42714: LIST
42715: LIST
42716: LIST
42717: LIST
42718: LIST
42719: LIST
42720: LIST
42721: LIST
42722: LIST
42723: LIST
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: LIST
42729: LIST
42730: LIST
42731: LIST
42732: LIST
42733: LIST
42734: LIST
42735: LIST
42736: ST_TO_ADDR
// end ; end ;
42737: GO 42740
42739: POP
// case btype of b_depot , b_warehouse :
42740: LD_VAR 0 1
42744: PUSH
42745: LD_INT 0
42747: DOUBLE
42748: EQUAL
42749: IFTRUE 42759
42751: LD_INT 1
42753: DOUBLE
42754: EQUAL
42755: IFTRUE 42759
42757: GO 42960
42759: POP
// case nation of nation_american :
42760: LD_VAR 0 5
42764: PUSH
42765: LD_INT 1
42767: DOUBLE
42768: EQUAL
42769: IFTRUE 42773
42771: GO 42829
42773: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42774: LD_ADDR_VAR 0 9
42778: PUSH
42779: LD_VAR 0 11
42783: PUSH
42784: LD_VAR 0 12
42788: PUSH
42789: LD_VAR 0 13
42793: PUSH
42794: LD_VAR 0 14
42798: PUSH
42799: LD_VAR 0 15
42803: PUSH
42804: LD_VAR 0 16
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: LIST
42816: PUSH
42817: LD_VAR 0 4
42821: PUSH
42822: LD_INT 1
42824: PLUS
42825: ARRAY
42826: ST_TO_ADDR
42827: GO 42958
42829: LD_INT 2
42831: DOUBLE
42832: EQUAL
42833: IFTRUE 42837
42835: GO 42893
42837: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42838: LD_ADDR_VAR 0 9
42842: PUSH
42843: LD_VAR 0 17
42847: PUSH
42848: LD_VAR 0 18
42852: PUSH
42853: LD_VAR 0 19
42857: PUSH
42858: LD_VAR 0 20
42862: PUSH
42863: LD_VAR 0 21
42867: PUSH
42868: LD_VAR 0 22
42872: PUSH
42873: EMPTY
42874: LIST
42875: LIST
42876: LIST
42877: LIST
42878: LIST
42879: LIST
42880: PUSH
42881: LD_VAR 0 4
42885: PUSH
42886: LD_INT 1
42888: PLUS
42889: ARRAY
42890: ST_TO_ADDR
42891: GO 42958
42893: LD_INT 3
42895: DOUBLE
42896: EQUAL
42897: IFTRUE 42901
42899: GO 42957
42901: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42902: LD_ADDR_VAR 0 9
42906: PUSH
42907: LD_VAR 0 23
42911: PUSH
42912: LD_VAR 0 24
42916: PUSH
42917: LD_VAR 0 25
42921: PUSH
42922: LD_VAR 0 26
42926: PUSH
42927: LD_VAR 0 27
42931: PUSH
42932: LD_VAR 0 28
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: PUSH
42945: LD_VAR 0 4
42949: PUSH
42950: LD_INT 1
42952: PLUS
42953: ARRAY
42954: ST_TO_ADDR
42955: GO 42958
42957: POP
42958: GO 43513
42960: LD_INT 2
42962: DOUBLE
42963: EQUAL
42964: IFTRUE 42974
42966: LD_INT 3
42968: DOUBLE
42969: EQUAL
42970: IFTRUE 42974
42972: GO 43030
42974: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42975: LD_ADDR_VAR 0 9
42979: PUSH
42980: LD_VAR 0 29
42984: PUSH
42985: LD_VAR 0 30
42989: PUSH
42990: LD_VAR 0 31
42994: PUSH
42995: LD_VAR 0 32
42999: PUSH
43000: LD_VAR 0 33
43004: PUSH
43005: LD_VAR 0 34
43009: PUSH
43010: EMPTY
43011: LIST
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: LIST
43017: PUSH
43018: LD_VAR 0 4
43022: PUSH
43023: LD_INT 1
43025: PLUS
43026: ARRAY
43027: ST_TO_ADDR
43028: GO 43513
43030: LD_INT 16
43032: DOUBLE
43033: EQUAL
43034: IFTRUE 43092
43036: LD_INT 17
43038: DOUBLE
43039: EQUAL
43040: IFTRUE 43092
43042: LD_INT 18
43044: DOUBLE
43045: EQUAL
43046: IFTRUE 43092
43048: LD_INT 19
43050: DOUBLE
43051: EQUAL
43052: IFTRUE 43092
43054: LD_INT 22
43056: DOUBLE
43057: EQUAL
43058: IFTRUE 43092
43060: LD_INT 20
43062: DOUBLE
43063: EQUAL
43064: IFTRUE 43092
43066: LD_INT 21
43068: DOUBLE
43069: EQUAL
43070: IFTRUE 43092
43072: LD_INT 23
43074: DOUBLE
43075: EQUAL
43076: IFTRUE 43092
43078: LD_INT 24
43080: DOUBLE
43081: EQUAL
43082: IFTRUE 43092
43084: LD_INT 25
43086: DOUBLE
43087: EQUAL
43088: IFTRUE 43092
43090: GO 43148
43092: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43093: LD_ADDR_VAR 0 9
43097: PUSH
43098: LD_VAR 0 35
43102: PUSH
43103: LD_VAR 0 36
43107: PUSH
43108: LD_VAR 0 37
43112: PUSH
43113: LD_VAR 0 38
43117: PUSH
43118: LD_VAR 0 39
43122: PUSH
43123: LD_VAR 0 40
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: LIST
43132: LIST
43133: LIST
43134: LIST
43135: PUSH
43136: LD_VAR 0 4
43140: PUSH
43141: LD_INT 1
43143: PLUS
43144: ARRAY
43145: ST_TO_ADDR
43146: GO 43513
43148: LD_INT 6
43150: DOUBLE
43151: EQUAL
43152: IFTRUE 43204
43154: LD_INT 7
43156: DOUBLE
43157: EQUAL
43158: IFTRUE 43204
43160: LD_INT 8
43162: DOUBLE
43163: EQUAL
43164: IFTRUE 43204
43166: LD_INT 13
43168: DOUBLE
43169: EQUAL
43170: IFTRUE 43204
43172: LD_INT 12
43174: DOUBLE
43175: EQUAL
43176: IFTRUE 43204
43178: LD_INT 15
43180: DOUBLE
43181: EQUAL
43182: IFTRUE 43204
43184: LD_INT 11
43186: DOUBLE
43187: EQUAL
43188: IFTRUE 43204
43190: LD_INT 14
43192: DOUBLE
43193: EQUAL
43194: IFTRUE 43204
43196: LD_INT 10
43198: DOUBLE
43199: EQUAL
43200: IFTRUE 43204
43202: GO 43260
43204: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43205: LD_ADDR_VAR 0 9
43209: PUSH
43210: LD_VAR 0 41
43214: PUSH
43215: LD_VAR 0 42
43219: PUSH
43220: LD_VAR 0 43
43224: PUSH
43225: LD_VAR 0 44
43229: PUSH
43230: LD_VAR 0 45
43234: PUSH
43235: LD_VAR 0 46
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: LIST
43244: LIST
43245: LIST
43246: LIST
43247: PUSH
43248: LD_VAR 0 4
43252: PUSH
43253: LD_INT 1
43255: PLUS
43256: ARRAY
43257: ST_TO_ADDR
43258: GO 43513
43260: LD_INT 36
43262: DOUBLE
43263: EQUAL
43264: IFTRUE 43268
43266: GO 43324
43268: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43269: LD_ADDR_VAR 0 9
43273: PUSH
43274: LD_VAR 0 47
43278: PUSH
43279: LD_VAR 0 48
43283: PUSH
43284: LD_VAR 0 49
43288: PUSH
43289: LD_VAR 0 50
43293: PUSH
43294: LD_VAR 0 51
43298: PUSH
43299: LD_VAR 0 52
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: LIST
43308: LIST
43309: LIST
43310: LIST
43311: PUSH
43312: LD_VAR 0 4
43316: PUSH
43317: LD_INT 1
43319: PLUS
43320: ARRAY
43321: ST_TO_ADDR
43322: GO 43513
43324: LD_INT 4
43326: DOUBLE
43327: EQUAL
43328: IFTRUE 43350
43330: LD_INT 5
43332: DOUBLE
43333: EQUAL
43334: IFTRUE 43350
43336: LD_INT 34
43338: DOUBLE
43339: EQUAL
43340: IFTRUE 43350
43342: LD_INT 37
43344: DOUBLE
43345: EQUAL
43346: IFTRUE 43350
43348: GO 43406
43350: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43351: LD_ADDR_VAR 0 9
43355: PUSH
43356: LD_VAR 0 53
43360: PUSH
43361: LD_VAR 0 54
43365: PUSH
43366: LD_VAR 0 55
43370: PUSH
43371: LD_VAR 0 56
43375: PUSH
43376: LD_VAR 0 57
43380: PUSH
43381: LD_VAR 0 58
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: PUSH
43394: LD_VAR 0 4
43398: PUSH
43399: LD_INT 1
43401: PLUS
43402: ARRAY
43403: ST_TO_ADDR
43404: GO 43513
43406: LD_INT 31
43408: DOUBLE
43409: EQUAL
43410: IFTRUE 43456
43412: LD_INT 32
43414: DOUBLE
43415: EQUAL
43416: IFTRUE 43456
43418: LD_INT 33
43420: DOUBLE
43421: EQUAL
43422: IFTRUE 43456
43424: LD_INT 27
43426: DOUBLE
43427: EQUAL
43428: IFTRUE 43456
43430: LD_INT 26
43432: DOUBLE
43433: EQUAL
43434: IFTRUE 43456
43436: LD_INT 28
43438: DOUBLE
43439: EQUAL
43440: IFTRUE 43456
43442: LD_INT 29
43444: DOUBLE
43445: EQUAL
43446: IFTRUE 43456
43448: LD_INT 30
43450: DOUBLE
43451: EQUAL
43452: IFTRUE 43456
43454: GO 43512
43456: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43457: LD_ADDR_VAR 0 9
43461: PUSH
43462: LD_VAR 0 59
43466: PUSH
43467: LD_VAR 0 60
43471: PUSH
43472: LD_VAR 0 61
43476: PUSH
43477: LD_VAR 0 62
43481: PUSH
43482: LD_VAR 0 63
43486: PUSH
43487: LD_VAR 0 64
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: LIST
43496: LIST
43497: LIST
43498: LIST
43499: PUSH
43500: LD_VAR 0 4
43504: PUSH
43505: LD_INT 1
43507: PLUS
43508: ARRAY
43509: ST_TO_ADDR
43510: GO 43513
43512: POP
// temp_list2 = [ ] ;
43513: LD_ADDR_VAR 0 10
43517: PUSH
43518: EMPTY
43519: ST_TO_ADDR
// for i in temp_list do
43520: LD_ADDR_VAR 0 8
43524: PUSH
43525: LD_VAR 0 9
43529: PUSH
43530: FOR_IN
43531: IFFALSE 43583
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43533: LD_ADDR_VAR 0 10
43537: PUSH
43538: LD_VAR 0 10
43542: PUSH
43543: LD_VAR 0 8
43547: PUSH
43548: LD_INT 1
43550: ARRAY
43551: PUSH
43552: LD_VAR 0 2
43556: PLUS
43557: PUSH
43558: LD_VAR 0 8
43562: PUSH
43563: LD_INT 2
43565: ARRAY
43566: PUSH
43567: LD_VAR 0 3
43571: PLUS
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: EMPTY
43578: LIST
43579: ADD
43580: ST_TO_ADDR
43581: GO 43530
43583: POP
43584: POP
// result = temp_list2 ;
43585: LD_ADDR_VAR 0 7
43589: PUSH
43590: LD_VAR 0 10
43594: ST_TO_ADDR
// end ;
43595: LD_VAR 0 7
43599: RET
// export function EnemyInRange ( unit , dist ) ; begin
43600: LD_INT 0
43602: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43603: LD_ADDR_VAR 0 3
43607: PUSH
43608: LD_VAR 0 1
43612: PPUSH
43613: CALL_OW 255
43617: PPUSH
43618: LD_VAR 0 1
43622: PPUSH
43623: CALL_OW 250
43627: PPUSH
43628: LD_VAR 0 1
43632: PPUSH
43633: CALL_OW 251
43637: PPUSH
43638: LD_VAR 0 2
43642: PPUSH
43643: CALL 16973 0 4
43647: PUSH
43648: LD_INT 4
43650: ARRAY
43651: ST_TO_ADDR
// end ;
43652: LD_VAR 0 3
43656: RET
// export function PlayerSeeMe ( unit ) ; begin
43657: LD_INT 0
43659: PPUSH
// result := See ( your_side , unit ) ;
43660: LD_ADDR_VAR 0 2
43664: PUSH
43665: LD_OWVAR 2
43669: PPUSH
43670: LD_VAR 0 1
43674: PPUSH
43675: CALL_OW 292
43679: ST_TO_ADDR
// end ;
43680: LD_VAR 0 2
43684: RET
// export function ReverseDir ( unit ) ; begin
43685: LD_INT 0
43687: PPUSH
// if not unit then
43688: LD_VAR 0 1
43692: NOT
43693: IFFALSE 43697
// exit ;
43695: GO 43720
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43697: LD_ADDR_VAR 0 2
43701: PUSH
43702: LD_VAR 0 1
43706: PPUSH
43707: CALL_OW 254
43711: PUSH
43712: LD_INT 3
43714: PLUS
43715: PUSH
43716: LD_INT 6
43718: MOD
43719: ST_TO_ADDR
// end ;
43720: LD_VAR 0 2
43724: RET
// export function ReverseArray ( array ) ; var i ; begin
43725: LD_INT 0
43727: PPUSH
43728: PPUSH
// if not array then
43729: LD_VAR 0 1
43733: NOT
43734: IFFALSE 43738
// exit ;
43736: GO 43793
// result := [ ] ;
43738: LD_ADDR_VAR 0 2
43742: PUSH
43743: EMPTY
43744: ST_TO_ADDR
// for i := array downto 1 do
43745: LD_ADDR_VAR 0 3
43749: PUSH
43750: DOUBLE
43751: LD_VAR 0 1
43755: INC
43756: ST_TO_ADDR
43757: LD_INT 1
43759: PUSH
43760: FOR_DOWNTO
43761: IFFALSE 43791
// result := Join ( result , array [ i ] ) ;
43763: LD_ADDR_VAR 0 2
43767: PUSH
43768: LD_VAR 0 2
43772: PPUSH
43773: LD_VAR 0 1
43777: PUSH
43778: LD_VAR 0 3
43782: ARRAY
43783: PPUSH
43784: CALL 48436 0 2
43788: ST_TO_ADDR
43789: GO 43760
43791: POP
43792: POP
// end ;
43793: LD_VAR 0 2
43797: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
43798: LD_INT 0
43800: PPUSH
43801: PPUSH
43802: PPUSH
43803: PPUSH
43804: PPUSH
43805: PPUSH
// if not unit or not hexes then
43806: LD_VAR 0 1
43810: NOT
43811: PUSH
43812: LD_VAR 0 2
43816: NOT
43817: OR
43818: IFFALSE 43822
// exit ;
43820: GO 43945
// dist := 9999 ;
43822: LD_ADDR_VAR 0 5
43826: PUSH
43827: LD_INT 9999
43829: ST_TO_ADDR
// for i = 1 to hexes do
43830: LD_ADDR_VAR 0 4
43834: PUSH
43835: DOUBLE
43836: LD_INT 1
43838: DEC
43839: ST_TO_ADDR
43840: LD_VAR 0 2
43844: PUSH
43845: FOR_TO
43846: IFFALSE 43933
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43848: LD_ADDR_VAR 0 6
43852: PUSH
43853: LD_VAR 0 1
43857: PPUSH
43858: LD_VAR 0 2
43862: PUSH
43863: LD_VAR 0 4
43867: ARRAY
43868: PUSH
43869: LD_INT 1
43871: ARRAY
43872: PPUSH
43873: LD_VAR 0 2
43877: PUSH
43878: LD_VAR 0 4
43882: ARRAY
43883: PUSH
43884: LD_INT 2
43886: ARRAY
43887: PPUSH
43888: CALL_OW 297
43892: ST_TO_ADDR
// if tdist < dist then
43893: LD_VAR 0 6
43897: PUSH
43898: LD_VAR 0 5
43902: LESS
43903: IFFALSE 43931
// begin hex := hexes [ i ] ;
43905: LD_ADDR_VAR 0 8
43909: PUSH
43910: LD_VAR 0 2
43914: PUSH
43915: LD_VAR 0 4
43919: ARRAY
43920: ST_TO_ADDR
// dist := tdist ;
43921: LD_ADDR_VAR 0 5
43925: PUSH
43926: LD_VAR 0 6
43930: ST_TO_ADDR
// end ; end ;
43931: GO 43845
43933: POP
43934: POP
// result := hex ;
43935: LD_ADDR_VAR 0 3
43939: PUSH
43940: LD_VAR 0 8
43944: ST_TO_ADDR
// end ;
43945: LD_VAR 0 3
43949: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43950: LD_INT 0
43952: PPUSH
43953: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43954: LD_VAR 0 1
43958: NOT
43959: PUSH
43960: LD_VAR 0 1
43964: PUSH
43965: LD_INT 21
43967: PUSH
43968: LD_INT 2
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: LD_INT 23
43977: PUSH
43978: LD_INT 2
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PPUSH
43989: CALL_OW 69
43993: IN
43994: NOT
43995: OR
43996: IFFALSE 44000
// exit ;
43998: GO 44047
// for i = 1 to 3 do
44000: LD_ADDR_VAR 0 3
44004: PUSH
44005: DOUBLE
44006: LD_INT 1
44008: DEC
44009: ST_TO_ADDR
44010: LD_INT 3
44012: PUSH
44013: FOR_TO
44014: IFFALSE 44045
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44016: LD_VAR 0 1
44020: PPUSH
44021: CALL_OW 250
44025: PPUSH
44026: LD_VAR 0 1
44030: PPUSH
44031: CALL_OW 251
44035: PPUSH
44036: LD_INT 1
44038: PPUSH
44039: CALL_OW 453
44043: GO 44013
44045: POP
44046: POP
// end ;
44047: LD_VAR 0 2
44051: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44052: LD_INT 0
44054: PPUSH
44055: PPUSH
44056: PPUSH
44057: PPUSH
44058: PPUSH
44059: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44060: LD_VAR 0 1
44064: NOT
44065: PUSH
44066: LD_VAR 0 2
44070: NOT
44071: OR
44072: PUSH
44073: LD_VAR 0 1
44077: PPUSH
44078: CALL_OW 314
44082: OR
44083: IFFALSE 44087
// exit ;
44085: GO 44554
// if GetLives ( i ) < 250 then
44087: LD_VAR 0 4
44091: PPUSH
44092: CALL_OW 256
44096: PUSH
44097: LD_INT 250
44099: LESS
44100: IFFALSE 44113
// begin ComAutodestruct ( i ) ;
44102: LD_VAR 0 4
44106: PPUSH
44107: CALL 43950 0 1
// exit ;
44111: GO 44554
// end ; x := GetX ( enemy_unit ) ;
44113: LD_ADDR_VAR 0 7
44117: PUSH
44118: LD_VAR 0 2
44122: PPUSH
44123: CALL_OW 250
44127: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44128: LD_ADDR_VAR 0 8
44132: PUSH
44133: LD_VAR 0 2
44137: PPUSH
44138: CALL_OW 251
44142: ST_TO_ADDR
// if not x or not y then
44143: LD_VAR 0 7
44147: NOT
44148: PUSH
44149: LD_VAR 0 8
44153: NOT
44154: OR
44155: IFFALSE 44159
// exit ;
44157: GO 44554
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44159: LD_ADDR_VAR 0 6
44163: PUSH
44164: LD_VAR 0 7
44168: PPUSH
44169: LD_INT 0
44171: PPUSH
44172: LD_INT 4
44174: PPUSH
44175: CALL_OW 272
44179: PUSH
44180: LD_VAR 0 8
44184: PPUSH
44185: LD_INT 0
44187: PPUSH
44188: LD_INT 4
44190: PPUSH
44191: CALL_OW 273
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_VAR 0 7
44204: PPUSH
44205: LD_INT 1
44207: PPUSH
44208: LD_INT 4
44210: PPUSH
44211: CALL_OW 272
44215: PUSH
44216: LD_VAR 0 8
44220: PPUSH
44221: LD_INT 1
44223: PPUSH
44224: LD_INT 4
44226: PPUSH
44227: CALL_OW 273
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_VAR 0 7
44240: PPUSH
44241: LD_INT 2
44243: PPUSH
44244: LD_INT 4
44246: PPUSH
44247: CALL_OW 272
44251: PUSH
44252: LD_VAR 0 8
44256: PPUSH
44257: LD_INT 2
44259: PPUSH
44260: LD_INT 4
44262: PPUSH
44263: CALL_OW 273
44267: PUSH
44268: EMPTY
44269: LIST
44270: LIST
44271: PUSH
44272: LD_VAR 0 7
44276: PPUSH
44277: LD_INT 3
44279: PPUSH
44280: LD_INT 4
44282: PPUSH
44283: CALL_OW 272
44287: PUSH
44288: LD_VAR 0 8
44292: PPUSH
44293: LD_INT 3
44295: PPUSH
44296: LD_INT 4
44298: PPUSH
44299: CALL_OW 273
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_VAR 0 7
44312: PPUSH
44313: LD_INT 4
44315: PPUSH
44316: LD_INT 4
44318: PPUSH
44319: CALL_OW 272
44323: PUSH
44324: LD_VAR 0 8
44328: PPUSH
44329: LD_INT 4
44331: PPUSH
44332: LD_INT 4
44334: PPUSH
44335: CALL_OW 273
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_VAR 0 7
44348: PPUSH
44349: LD_INT 5
44351: PPUSH
44352: LD_INT 4
44354: PPUSH
44355: CALL_OW 272
44359: PUSH
44360: LD_VAR 0 8
44364: PPUSH
44365: LD_INT 5
44367: PPUSH
44368: LD_INT 4
44370: PPUSH
44371: CALL_OW 273
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: ST_TO_ADDR
// for i = tmp downto 1 do
44388: LD_ADDR_VAR 0 4
44392: PUSH
44393: DOUBLE
44394: LD_VAR 0 6
44398: INC
44399: ST_TO_ADDR
44400: LD_INT 1
44402: PUSH
44403: FOR_DOWNTO
44404: IFFALSE 44505
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44406: LD_VAR 0 6
44410: PUSH
44411: LD_VAR 0 4
44415: ARRAY
44416: PUSH
44417: LD_INT 1
44419: ARRAY
44420: PPUSH
44421: LD_VAR 0 6
44425: PUSH
44426: LD_VAR 0 4
44430: ARRAY
44431: PUSH
44432: LD_INT 2
44434: ARRAY
44435: PPUSH
44436: CALL_OW 488
44440: NOT
44441: PUSH
44442: LD_VAR 0 6
44446: PUSH
44447: LD_VAR 0 4
44451: ARRAY
44452: PUSH
44453: LD_INT 1
44455: ARRAY
44456: PPUSH
44457: LD_VAR 0 6
44461: PUSH
44462: LD_VAR 0 4
44466: ARRAY
44467: PUSH
44468: LD_INT 2
44470: ARRAY
44471: PPUSH
44472: CALL_OW 428
44476: PUSH
44477: LD_INT 0
44479: NONEQUAL
44480: OR
44481: IFFALSE 44503
// tmp := Delete ( tmp , i ) ;
44483: LD_ADDR_VAR 0 6
44487: PUSH
44488: LD_VAR 0 6
44492: PPUSH
44493: LD_VAR 0 4
44497: PPUSH
44498: CALL_OW 3
44502: ST_TO_ADDR
44503: GO 44403
44505: POP
44506: POP
// j := GetClosestHex ( unit , tmp ) ;
44507: LD_ADDR_VAR 0 5
44511: PUSH
44512: LD_VAR 0 1
44516: PPUSH
44517: LD_VAR 0 6
44521: PPUSH
44522: CALL 43798 0 2
44526: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44527: LD_VAR 0 1
44531: PPUSH
44532: LD_VAR 0 5
44536: PUSH
44537: LD_INT 1
44539: ARRAY
44540: PPUSH
44541: LD_VAR 0 5
44545: PUSH
44546: LD_INT 2
44548: ARRAY
44549: PPUSH
44550: CALL_OW 111
// end ;
44554: LD_VAR 0 3
44558: RET
// export function PrepareApemanSoldier ( ) ; begin
44559: LD_INT 0
44561: PPUSH
// uc_nation := 0 ;
44562: LD_ADDR_OWVAR 21
44566: PUSH
44567: LD_INT 0
44569: ST_TO_ADDR
// hc_sex := sex_male ;
44570: LD_ADDR_OWVAR 27
44574: PUSH
44575: LD_INT 1
44577: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44578: LD_ADDR_OWVAR 28
44582: PUSH
44583: LD_INT 15
44585: ST_TO_ADDR
// hc_gallery :=  ;
44586: LD_ADDR_OWVAR 33
44590: PUSH
44591: LD_STRING 
44593: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44594: LD_ADDR_OWVAR 31
44598: PUSH
44599: LD_INT 0
44601: PPUSH
44602: LD_INT 3
44604: PPUSH
44605: CALL_OW 12
44609: PUSH
44610: LD_INT 0
44612: PPUSH
44613: LD_INT 3
44615: PPUSH
44616: CALL_OW 12
44620: PUSH
44621: LD_INT 0
44623: PUSH
44624: LD_INT 0
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: ST_TO_ADDR
// end ;
44633: LD_VAR 0 1
44637: RET
// export function PrepareApemanEngineer ( ) ; begin
44638: LD_INT 0
44640: PPUSH
// uc_nation := 0 ;
44641: LD_ADDR_OWVAR 21
44645: PUSH
44646: LD_INT 0
44648: ST_TO_ADDR
// hc_sex := sex_male ;
44649: LD_ADDR_OWVAR 27
44653: PUSH
44654: LD_INT 1
44656: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
44657: LD_ADDR_OWVAR 28
44661: PUSH
44662: LD_INT 16
44664: ST_TO_ADDR
// hc_gallery :=  ;
44665: LD_ADDR_OWVAR 33
44669: PUSH
44670: LD_STRING 
44672: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44673: LD_ADDR_OWVAR 31
44677: PUSH
44678: LD_INT 0
44680: PPUSH
44681: LD_INT 3
44683: PPUSH
44684: CALL_OW 12
44688: PUSH
44689: LD_INT 0
44691: PPUSH
44692: LD_INT 3
44694: PPUSH
44695: CALL_OW 12
44699: PUSH
44700: LD_INT 0
44702: PUSH
44703: LD_INT 0
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: LIST
44710: LIST
44711: ST_TO_ADDR
// end ;
44712: LD_VAR 0 1
44716: RET
// export function PrepareApeman ( agressivity ) ; begin
44717: LD_INT 0
44719: PPUSH
// uc_side := 0 ;
44720: LD_ADDR_OWVAR 20
44724: PUSH
44725: LD_INT 0
44727: ST_TO_ADDR
// uc_nation := 0 ;
44728: LD_ADDR_OWVAR 21
44732: PUSH
44733: LD_INT 0
44735: ST_TO_ADDR
// hc_sex := sex_male ;
44736: LD_ADDR_OWVAR 27
44740: PUSH
44741: LD_INT 1
44743: ST_TO_ADDR
// hc_class := class_apeman ;
44744: LD_ADDR_OWVAR 28
44748: PUSH
44749: LD_INT 12
44751: ST_TO_ADDR
// hc_gallery :=  ;
44752: LD_ADDR_OWVAR 33
44756: PUSH
44757: LD_STRING 
44759: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44760: LD_ADDR_OWVAR 35
44764: PUSH
44765: LD_VAR 0 1
44769: NEG
44770: PPUSH
44771: LD_VAR 0 1
44775: PPUSH
44776: CALL_OW 12
44780: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44781: LD_ADDR_OWVAR 31
44785: PUSH
44786: LD_INT 0
44788: PPUSH
44789: LD_INT 3
44791: PPUSH
44792: CALL_OW 12
44796: PUSH
44797: LD_INT 0
44799: PPUSH
44800: LD_INT 3
44802: PPUSH
44803: CALL_OW 12
44807: PUSH
44808: LD_INT 0
44810: PUSH
44811: LD_INT 0
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: ST_TO_ADDR
// end ;
44820: LD_VAR 0 2
44824: RET
// export function PrepareTiger ( agressivity ) ; begin
44825: LD_INT 0
44827: PPUSH
// uc_side := 0 ;
44828: LD_ADDR_OWVAR 20
44832: PUSH
44833: LD_INT 0
44835: ST_TO_ADDR
// uc_nation := 0 ;
44836: LD_ADDR_OWVAR 21
44840: PUSH
44841: LD_INT 0
44843: ST_TO_ADDR
// hc_class := class_tiger ;
44844: LD_ADDR_OWVAR 28
44848: PUSH
44849: LD_INT 14
44851: ST_TO_ADDR
// hc_gallery :=  ;
44852: LD_ADDR_OWVAR 33
44856: PUSH
44857: LD_STRING 
44859: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44860: LD_ADDR_OWVAR 35
44864: PUSH
44865: LD_VAR 0 1
44869: NEG
44870: PPUSH
44871: LD_VAR 0 1
44875: PPUSH
44876: CALL_OW 12
44880: ST_TO_ADDR
// end ;
44881: LD_VAR 0 2
44885: RET
// export function PrepareEnchidna ( ) ; begin
44886: LD_INT 0
44888: PPUSH
// uc_side := 0 ;
44889: LD_ADDR_OWVAR 20
44893: PUSH
44894: LD_INT 0
44896: ST_TO_ADDR
// uc_nation := 0 ;
44897: LD_ADDR_OWVAR 21
44901: PUSH
44902: LD_INT 0
44904: ST_TO_ADDR
// hc_class := class_baggie ;
44905: LD_ADDR_OWVAR 28
44909: PUSH
44910: LD_INT 13
44912: ST_TO_ADDR
// hc_gallery :=  ;
44913: LD_ADDR_OWVAR 33
44917: PUSH
44918: LD_STRING 
44920: ST_TO_ADDR
// end ;
44921: LD_VAR 0 1
44925: RET
// export function PrepareFrog ( ) ; begin
44926: LD_INT 0
44928: PPUSH
// uc_side := 0 ;
44929: LD_ADDR_OWVAR 20
44933: PUSH
44934: LD_INT 0
44936: ST_TO_ADDR
// uc_nation := 0 ;
44937: LD_ADDR_OWVAR 21
44941: PUSH
44942: LD_INT 0
44944: ST_TO_ADDR
// hc_class := class_frog ;
44945: LD_ADDR_OWVAR 28
44949: PUSH
44950: LD_INT 19
44952: ST_TO_ADDR
// hc_gallery :=  ;
44953: LD_ADDR_OWVAR 33
44957: PUSH
44958: LD_STRING 
44960: ST_TO_ADDR
// end ;
44961: LD_VAR 0 1
44965: RET
// export function PrepareFish ( ) ; begin
44966: LD_INT 0
44968: PPUSH
// uc_side := 0 ;
44969: LD_ADDR_OWVAR 20
44973: PUSH
44974: LD_INT 0
44976: ST_TO_ADDR
// uc_nation := 0 ;
44977: LD_ADDR_OWVAR 21
44981: PUSH
44982: LD_INT 0
44984: ST_TO_ADDR
// hc_class := class_fish ;
44985: LD_ADDR_OWVAR 28
44989: PUSH
44990: LD_INT 20
44992: ST_TO_ADDR
// hc_gallery :=  ;
44993: LD_ADDR_OWVAR 33
44997: PUSH
44998: LD_STRING 
45000: ST_TO_ADDR
// end ;
45001: LD_VAR 0 1
45005: RET
// export function PrepareBird ( ) ; begin
45006: LD_INT 0
45008: PPUSH
// uc_side := 0 ;
45009: LD_ADDR_OWVAR 20
45013: PUSH
45014: LD_INT 0
45016: ST_TO_ADDR
// uc_nation := 0 ;
45017: LD_ADDR_OWVAR 21
45021: PUSH
45022: LD_INT 0
45024: ST_TO_ADDR
// hc_class := class_phororhacos ;
45025: LD_ADDR_OWVAR 28
45029: PUSH
45030: LD_INT 18
45032: ST_TO_ADDR
// hc_gallery :=  ;
45033: LD_ADDR_OWVAR 33
45037: PUSH
45038: LD_STRING 
45040: ST_TO_ADDR
// end ;
45041: LD_VAR 0 1
45045: RET
// export function PrepareHorse ( ) ; begin
45046: LD_INT 0
45048: PPUSH
// uc_side := 0 ;
45049: LD_ADDR_OWVAR 20
45053: PUSH
45054: LD_INT 0
45056: ST_TO_ADDR
// uc_nation := 0 ;
45057: LD_ADDR_OWVAR 21
45061: PUSH
45062: LD_INT 0
45064: ST_TO_ADDR
// hc_class := class_horse ;
45065: LD_ADDR_OWVAR 28
45069: PUSH
45070: LD_INT 21
45072: ST_TO_ADDR
// hc_gallery :=  ;
45073: LD_ADDR_OWVAR 33
45077: PUSH
45078: LD_STRING 
45080: ST_TO_ADDR
// end ;
45081: LD_VAR 0 1
45085: RET
// export function PrepareMastodont ( ) ; begin
45086: LD_INT 0
45088: PPUSH
// uc_side := 0 ;
45089: LD_ADDR_OWVAR 20
45093: PUSH
45094: LD_INT 0
45096: ST_TO_ADDR
// uc_nation := 0 ;
45097: LD_ADDR_OWVAR 21
45101: PUSH
45102: LD_INT 0
45104: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45105: LD_ADDR_OWVAR 37
45109: PUSH
45110: LD_INT 31
45112: ST_TO_ADDR
// vc_control := control_rider ;
45113: LD_ADDR_OWVAR 38
45117: PUSH
45118: LD_INT 4
45120: ST_TO_ADDR
// end ;
45121: LD_VAR 0 1
45125: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45126: LD_INT 0
45128: PPUSH
45129: PPUSH
45130: PPUSH
// uc_side = 0 ;
45131: LD_ADDR_OWVAR 20
45135: PUSH
45136: LD_INT 0
45138: ST_TO_ADDR
// uc_nation = 0 ;
45139: LD_ADDR_OWVAR 21
45143: PUSH
45144: LD_INT 0
45146: ST_TO_ADDR
// InitHc_All ( ) ;
45147: CALL_OW 584
// InitVc ;
45151: CALL_OW 20
// if mastodonts then
45155: LD_VAR 0 6
45159: IFFALSE 45226
// for i = 1 to mastodonts do
45161: LD_ADDR_VAR 0 11
45165: PUSH
45166: DOUBLE
45167: LD_INT 1
45169: DEC
45170: ST_TO_ADDR
45171: LD_VAR 0 6
45175: PUSH
45176: FOR_TO
45177: IFFALSE 45224
// begin vc_chassis := 31 ;
45179: LD_ADDR_OWVAR 37
45183: PUSH
45184: LD_INT 31
45186: ST_TO_ADDR
// vc_control := control_rider ;
45187: LD_ADDR_OWVAR 38
45191: PUSH
45192: LD_INT 4
45194: ST_TO_ADDR
// animal := CreateVehicle ;
45195: LD_ADDR_VAR 0 12
45199: PUSH
45200: CALL_OW 45
45204: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45205: LD_VAR 0 12
45209: PPUSH
45210: LD_VAR 0 8
45214: PPUSH
45215: LD_INT 0
45217: PPUSH
45218: CALL 47354 0 3
// end ;
45222: GO 45176
45224: POP
45225: POP
// if horses then
45226: LD_VAR 0 5
45230: IFFALSE 45297
// for i = 1 to horses do
45232: LD_ADDR_VAR 0 11
45236: PUSH
45237: DOUBLE
45238: LD_INT 1
45240: DEC
45241: ST_TO_ADDR
45242: LD_VAR 0 5
45246: PUSH
45247: FOR_TO
45248: IFFALSE 45295
// begin hc_class := 21 ;
45250: LD_ADDR_OWVAR 28
45254: PUSH
45255: LD_INT 21
45257: ST_TO_ADDR
// hc_gallery :=  ;
45258: LD_ADDR_OWVAR 33
45262: PUSH
45263: LD_STRING 
45265: ST_TO_ADDR
// animal := CreateHuman ;
45266: LD_ADDR_VAR 0 12
45270: PUSH
45271: CALL_OW 44
45275: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45276: LD_VAR 0 12
45280: PPUSH
45281: LD_VAR 0 8
45285: PPUSH
45286: LD_INT 0
45288: PPUSH
45289: CALL 47354 0 3
// end ;
45293: GO 45247
45295: POP
45296: POP
// if birds then
45297: LD_VAR 0 1
45301: IFFALSE 45368
// for i = 1 to birds do
45303: LD_ADDR_VAR 0 11
45307: PUSH
45308: DOUBLE
45309: LD_INT 1
45311: DEC
45312: ST_TO_ADDR
45313: LD_VAR 0 1
45317: PUSH
45318: FOR_TO
45319: IFFALSE 45366
// begin hc_class := 18 ;
45321: LD_ADDR_OWVAR 28
45325: PUSH
45326: LD_INT 18
45328: ST_TO_ADDR
// hc_gallery =  ;
45329: LD_ADDR_OWVAR 33
45333: PUSH
45334: LD_STRING 
45336: ST_TO_ADDR
// animal := CreateHuman ;
45337: LD_ADDR_VAR 0 12
45341: PUSH
45342: CALL_OW 44
45346: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45347: LD_VAR 0 12
45351: PPUSH
45352: LD_VAR 0 8
45356: PPUSH
45357: LD_INT 0
45359: PPUSH
45360: CALL 47354 0 3
// end ;
45364: GO 45318
45366: POP
45367: POP
// if tigers then
45368: LD_VAR 0 2
45372: IFFALSE 45456
// for i = 1 to tigers do
45374: LD_ADDR_VAR 0 11
45378: PUSH
45379: DOUBLE
45380: LD_INT 1
45382: DEC
45383: ST_TO_ADDR
45384: LD_VAR 0 2
45388: PUSH
45389: FOR_TO
45390: IFFALSE 45454
// begin hc_class = class_tiger ;
45392: LD_ADDR_OWVAR 28
45396: PUSH
45397: LD_INT 14
45399: ST_TO_ADDR
// hc_gallery =  ;
45400: LD_ADDR_OWVAR 33
45404: PUSH
45405: LD_STRING 
45407: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45408: LD_ADDR_OWVAR 35
45412: PUSH
45413: LD_INT 7
45415: NEG
45416: PPUSH
45417: LD_INT 7
45419: PPUSH
45420: CALL_OW 12
45424: ST_TO_ADDR
// animal := CreateHuman ;
45425: LD_ADDR_VAR 0 12
45429: PUSH
45430: CALL_OW 44
45434: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45435: LD_VAR 0 12
45439: PPUSH
45440: LD_VAR 0 8
45444: PPUSH
45445: LD_INT 0
45447: PPUSH
45448: CALL 47354 0 3
// end ;
45452: GO 45389
45454: POP
45455: POP
// if apemans then
45456: LD_VAR 0 3
45460: IFFALSE 45583
// for i = 1 to apemans do
45462: LD_ADDR_VAR 0 11
45466: PUSH
45467: DOUBLE
45468: LD_INT 1
45470: DEC
45471: ST_TO_ADDR
45472: LD_VAR 0 3
45476: PUSH
45477: FOR_TO
45478: IFFALSE 45581
// begin hc_class = class_apeman ;
45480: LD_ADDR_OWVAR 28
45484: PUSH
45485: LD_INT 12
45487: ST_TO_ADDR
// hc_gallery =  ;
45488: LD_ADDR_OWVAR 33
45492: PUSH
45493: LD_STRING 
45495: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45496: LD_ADDR_OWVAR 35
45500: PUSH
45501: LD_INT 2
45503: NEG
45504: PPUSH
45505: LD_INT 2
45507: PPUSH
45508: CALL_OW 12
45512: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45513: LD_ADDR_OWVAR 31
45517: PUSH
45518: LD_INT 1
45520: PPUSH
45521: LD_INT 3
45523: PPUSH
45524: CALL_OW 12
45528: PUSH
45529: LD_INT 1
45531: PPUSH
45532: LD_INT 3
45534: PPUSH
45535: CALL_OW 12
45539: PUSH
45540: LD_INT 0
45542: PUSH
45543: LD_INT 0
45545: PUSH
45546: EMPTY
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: ST_TO_ADDR
// animal := CreateHuman ;
45552: LD_ADDR_VAR 0 12
45556: PUSH
45557: CALL_OW 44
45561: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45562: LD_VAR 0 12
45566: PPUSH
45567: LD_VAR 0 8
45571: PPUSH
45572: LD_INT 0
45574: PPUSH
45575: CALL 47354 0 3
// end ;
45579: GO 45477
45581: POP
45582: POP
// if enchidnas then
45583: LD_VAR 0 4
45587: IFFALSE 45654
// for i = 1 to enchidnas do
45589: LD_ADDR_VAR 0 11
45593: PUSH
45594: DOUBLE
45595: LD_INT 1
45597: DEC
45598: ST_TO_ADDR
45599: LD_VAR 0 4
45603: PUSH
45604: FOR_TO
45605: IFFALSE 45652
// begin hc_class = 13 ;
45607: LD_ADDR_OWVAR 28
45611: PUSH
45612: LD_INT 13
45614: ST_TO_ADDR
// hc_gallery =  ;
45615: LD_ADDR_OWVAR 33
45619: PUSH
45620: LD_STRING 
45622: ST_TO_ADDR
// animal := CreateHuman ;
45623: LD_ADDR_VAR 0 12
45627: PUSH
45628: CALL_OW 44
45632: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45633: LD_VAR 0 12
45637: PPUSH
45638: LD_VAR 0 8
45642: PPUSH
45643: LD_INT 0
45645: PPUSH
45646: CALL 47354 0 3
// end ;
45650: GO 45604
45652: POP
45653: POP
// if fishes then
45654: LD_VAR 0 7
45658: IFFALSE 45725
// for i = 1 to fishes do
45660: LD_ADDR_VAR 0 11
45664: PUSH
45665: DOUBLE
45666: LD_INT 1
45668: DEC
45669: ST_TO_ADDR
45670: LD_VAR 0 7
45674: PUSH
45675: FOR_TO
45676: IFFALSE 45723
// begin hc_class = 20 ;
45678: LD_ADDR_OWVAR 28
45682: PUSH
45683: LD_INT 20
45685: ST_TO_ADDR
// hc_gallery =  ;
45686: LD_ADDR_OWVAR 33
45690: PUSH
45691: LD_STRING 
45693: ST_TO_ADDR
// animal := CreateHuman ;
45694: LD_ADDR_VAR 0 12
45698: PUSH
45699: CALL_OW 44
45703: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
45704: LD_VAR 0 12
45708: PPUSH
45709: LD_VAR 0 9
45713: PPUSH
45714: LD_INT 0
45716: PPUSH
45717: CALL 47354 0 3
// end ;
45721: GO 45675
45723: POP
45724: POP
// end ;
45725: LD_VAR 0 10
45729: RET
// export function WantHeal ( sci , unit ) ; begin
45730: LD_INT 0
45732: PPUSH
// if GetTaskList ( sci ) > 0 then
45733: LD_VAR 0 1
45737: PPUSH
45738: CALL_OW 437
45742: PUSH
45743: LD_INT 0
45745: GREATER
45746: IFFALSE 45816
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45748: LD_VAR 0 1
45752: PPUSH
45753: CALL_OW 437
45757: PUSH
45758: LD_INT 1
45760: ARRAY
45761: PUSH
45762: LD_INT 1
45764: ARRAY
45765: PUSH
45766: LD_STRING l
45768: EQUAL
45769: PUSH
45770: LD_VAR 0 1
45774: PPUSH
45775: CALL_OW 437
45779: PUSH
45780: LD_INT 1
45782: ARRAY
45783: PUSH
45784: LD_INT 4
45786: ARRAY
45787: PUSH
45788: LD_VAR 0 2
45792: EQUAL
45793: AND
45794: IFFALSE 45806
// result := true else
45796: LD_ADDR_VAR 0 3
45800: PUSH
45801: LD_INT 1
45803: ST_TO_ADDR
45804: GO 45814
// result := false ;
45806: LD_ADDR_VAR 0 3
45810: PUSH
45811: LD_INT 0
45813: ST_TO_ADDR
// end else
45814: GO 45824
// result := false ;
45816: LD_ADDR_VAR 0 3
45820: PUSH
45821: LD_INT 0
45823: ST_TO_ADDR
// end ;
45824: LD_VAR 0 3
45828: RET
// export function HealTarget ( sci ) ; begin
45829: LD_INT 0
45831: PPUSH
// if not sci then
45832: LD_VAR 0 1
45836: NOT
45837: IFFALSE 45841
// exit ;
45839: GO 45906
// result := 0 ;
45841: LD_ADDR_VAR 0 2
45845: PUSH
45846: LD_INT 0
45848: ST_TO_ADDR
// if GetTaskList ( sci ) then
45849: LD_VAR 0 1
45853: PPUSH
45854: CALL_OW 437
45858: IFFALSE 45906
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45860: LD_VAR 0 1
45864: PPUSH
45865: CALL_OW 437
45869: PUSH
45870: LD_INT 1
45872: ARRAY
45873: PUSH
45874: LD_INT 1
45876: ARRAY
45877: PUSH
45878: LD_STRING l
45880: EQUAL
45881: IFFALSE 45906
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45883: LD_ADDR_VAR 0 2
45887: PUSH
45888: LD_VAR 0 1
45892: PPUSH
45893: CALL_OW 437
45897: PUSH
45898: LD_INT 1
45900: ARRAY
45901: PUSH
45902: LD_INT 4
45904: ARRAY
45905: ST_TO_ADDR
// end ;
45906: LD_VAR 0 2
45910: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45911: LD_INT 0
45913: PPUSH
45914: PPUSH
45915: PPUSH
45916: PPUSH
// if not base_units then
45917: LD_VAR 0 1
45921: NOT
45922: IFFALSE 45926
// exit ;
45924: GO 46013
// result := false ;
45926: LD_ADDR_VAR 0 2
45930: PUSH
45931: LD_INT 0
45933: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45934: LD_ADDR_VAR 0 5
45938: PUSH
45939: LD_VAR 0 1
45943: PPUSH
45944: LD_INT 21
45946: PUSH
45947: LD_INT 3
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PPUSH
45954: CALL_OW 72
45958: ST_TO_ADDR
// if not tmp then
45959: LD_VAR 0 5
45963: NOT
45964: IFFALSE 45968
// exit ;
45966: GO 46013
// for i in tmp do
45968: LD_ADDR_VAR 0 3
45972: PUSH
45973: LD_VAR 0 5
45977: PUSH
45978: FOR_IN
45979: IFFALSE 46011
// begin result := EnemyInRange ( i , 22 ) ;
45981: LD_ADDR_VAR 0 2
45985: PUSH
45986: LD_VAR 0 3
45990: PPUSH
45991: LD_INT 22
45993: PPUSH
45994: CALL 43600 0 2
45998: ST_TO_ADDR
// if result then
45999: LD_VAR 0 2
46003: IFFALSE 46009
// exit ;
46005: POP
46006: POP
46007: GO 46013
// end ;
46009: GO 45978
46011: POP
46012: POP
// end ;
46013: LD_VAR 0 2
46017: RET
// export function FilterByTag ( units , tag ) ; begin
46018: LD_INT 0
46020: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46021: LD_ADDR_VAR 0 3
46025: PUSH
46026: LD_VAR 0 1
46030: PPUSH
46031: LD_INT 120
46033: PUSH
46034: LD_VAR 0 2
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PPUSH
46043: CALL_OW 72
46047: ST_TO_ADDR
// end ;
46048: LD_VAR 0 3
46052: RET
// export function IsDriver ( un ) ; begin
46053: LD_INT 0
46055: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46056: LD_ADDR_VAR 0 2
46060: PUSH
46061: LD_VAR 0 1
46065: PUSH
46066: LD_INT 55
46068: PUSH
46069: EMPTY
46070: LIST
46071: PPUSH
46072: CALL_OW 69
46076: IN
46077: ST_TO_ADDR
// end ;
46078: LD_VAR 0 2
46082: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46083: LD_INT 0
46085: PPUSH
46086: PPUSH
// list := [ ] ;
46087: LD_ADDR_VAR 0 5
46091: PUSH
46092: EMPTY
46093: ST_TO_ADDR
// case d of 0 :
46094: LD_VAR 0 3
46098: PUSH
46099: LD_INT 0
46101: DOUBLE
46102: EQUAL
46103: IFTRUE 46107
46105: GO 46240
46107: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46108: LD_ADDR_VAR 0 5
46112: PUSH
46113: LD_VAR 0 1
46117: PUSH
46118: LD_INT 4
46120: MINUS
46121: PUSH
46122: LD_VAR 0 2
46126: PUSH
46127: LD_INT 4
46129: MINUS
46130: PUSH
46131: LD_INT 2
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: LIST
46138: PUSH
46139: LD_VAR 0 1
46143: PUSH
46144: LD_INT 3
46146: MINUS
46147: PUSH
46148: LD_VAR 0 2
46152: PUSH
46153: LD_INT 1
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: LIST
46160: PUSH
46161: LD_VAR 0 1
46165: PUSH
46166: LD_INT 4
46168: PLUS
46169: PUSH
46170: LD_VAR 0 2
46174: PUSH
46175: LD_INT 4
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: LIST
46182: PUSH
46183: LD_VAR 0 1
46187: PUSH
46188: LD_INT 3
46190: PLUS
46191: PUSH
46192: LD_VAR 0 2
46196: PUSH
46197: LD_INT 3
46199: PLUS
46200: PUSH
46201: LD_INT 5
46203: PUSH
46204: EMPTY
46205: LIST
46206: LIST
46207: LIST
46208: PUSH
46209: LD_VAR 0 1
46213: PUSH
46214: LD_VAR 0 2
46218: PUSH
46219: LD_INT 4
46221: PLUS
46222: PUSH
46223: LD_INT 0
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: LIST
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: LIST
46235: LIST
46236: LIST
46237: ST_TO_ADDR
// end ; 1 :
46238: GO 46938
46240: LD_INT 1
46242: DOUBLE
46243: EQUAL
46244: IFTRUE 46248
46246: GO 46381
46248: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46249: LD_ADDR_VAR 0 5
46253: PUSH
46254: LD_VAR 0 1
46258: PUSH
46259: LD_VAR 0 2
46263: PUSH
46264: LD_INT 4
46266: MINUS
46267: PUSH
46268: LD_INT 3
46270: PUSH
46271: EMPTY
46272: LIST
46273: LIST
46274: LIST
46275: PUSH
46276: LD_VAR 0 1
46280: PUSH
46281: LD_INT 3
46283: MINUS
46284: PUSH
46285: LD_VAR 0 2
46289: PUSH
46290: LD_INT 3
46292: MINUS
46293: PUSH
46294: LD_INT 2
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: LIST
46301: PUSH
46302: LD_VAR 0 1
46306: PUSH
46307: LD_INT 4
46309: MINUS
46310: PUSH
46311: LD_VAR 0 2
46315: PUSH
46316: LD_INT 1
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: LIST
46323: PUSH
46324: LD_VAR 0 1
46328: PUSH
46329: LD_VAR 0 2
46333: PUSH
46334: LD_INT 3
46336: PLUS
46337: PUSH
46338: LD_INT 0
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: LIST
46345: PUSH
46346: LD_VAR 0 1
46350: PUSH
46351: LD_INT 4
46353: PLUS
46354: PUSH
46355: LD_VAR 0 2
46359: PUSH
46360: LD_INT 4
46362: PLUS
46363: PUSH
46364: LD_INT 5
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: LIST
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: ST_TO_ADDR
// end ; 2 :
46379: GO 46938
46381: LD_INT 2
46383: DOUBLE
46384: EQUAL
46385: IFTRUE 46389
46387: GO 46518
46389: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46390: LD_ADDR_VAR 0 5
46394: PUSH
46395: LD_VAR 0 1
46399: PUSH
46400: LD_VAR 0 2
46404: PUSH
46405: LD_INT 3
46407: MINUS
46408: PUSH
46409: LD_INT 3
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: LIST
46416: PUSH
46417: LD_VAR 0 1
46421: PUSH
46422: LD_INT 4
46424: PLUS
46425: PUSH
46426: LD_VAR 0 2
46430: PUSH
46431: LD_INT 4
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: LIST
46438: PUSH
46439: LD_VAR 0 1
46443: PUSH
46444: LD_VAR 0 2
46448: PUSH
46449: LD_INT 4
46451: PLUS
46452: PUSH
46453: LD_INT 0
46455: PUSH
46456: EMPTY
46457: LIST
46458: LIST
46459: LIST
46460: PUSH
46461: LD_VAR 0 1
46465: PUSH
46466: LD_INT 3
46468: MINUS
46469: PUSH
46470: LD_VAR 0 2
46474: PUSH
46475: LD_INT 1
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: LIST
46482: PUSH
46483: LD_VAR 0 1
46487: PUSH
46488: LD_INT 4
46490: MINUS
46491: PUSH
46492: LD_VAR 0 2
46496: PUSH
46497: LD_INT 4
46499: MINUS
46500: PUSH
46501: LD_INT 2
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: LIST
46508: PUSH
46509: EMPTY
46510: LIST
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: ST_TO_ADDR
// end ; 3 :
46516: GO 46938
46518: LD_INT 3
46520: DOUBLE
46521: EQUAL
46522: IFTRUE 46526
46524: GO 46659
46526: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46527: LD_ADDR_VAR 0 5
46531: PUSH
46532: LD_VAR 0 1
46536: PUSH
46537: LD_INT 3
46539: PLUS
46540: PUSH
46541: LD_VAR 0 2
46545: PUSH
46546: LD_INT 4
46548: PUSH
46549: EMPTY
46550: LIST
46551: LIST
46552: LIST
46553: PUSH
46554: LD_VAR 0 1
46558: PUSH
46559: LD_INT 4
46561: PLUS
46562: PUSH
46563: LD_VAR 0 2
46567: PUSH
46568: LD_INT 4
46570: PLUS
46571: PUSH
46572: LD_INT 5
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: LIST
46579: PUSH
46580: LD_VAR 0 1
46584: PUSH
46585: LD_INT 4
46587: MINUS
46588: PUSH
46589: LD_VAR 0 2
46593: PUSH
46594: LD_INT 1
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: LIST
46601: PUSH
46602: LD_VAR 0 1
46606: PUSH
46607: LD_VAR 0 2
46611: PUSH
46612: LD_INT 4
46614: MINUS
46615: PUSH
46616: LD_INT 3
46618: PUSH
46619: EMPTY
46620: LIST
46621: LIST
46622: LIST
46623: PUSH
46624: LD_VAR 0 1
46628: PUSH
46629: LD_INT 3
46631: MINUS
46632: PUSH
46633: LD_VAR 0 2
46637: PUSH
46638: LD_INT 3
46640: MINUS
46641: PUSH
46642: LD_INT 2
46644: PUSH
46645: EMPTY
46646: LIST
46647: LIST
46648: LIST
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: LIST
46656: ST_TO_ADDR
// end ; 4 :
46657: GO 46938
46659: LD_INT 4
46661: DOUBLE
46662: EQUAL
46663: IFTRUE 46667
46665: GO 46800
46667: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
46668: LD_ADDR_VAR 0 5
46672: PUSH
46673: LD_VAR 0 1
46677: PUSH
46678: LD_VAR 0 2
46682: PUSH
46683: LD_INT 4
46685: PLUS
46686: PUSH
46687: LD_INT 0
46689: PUSH
46690: EMPTY
46691: LIST
46692: LIST
46693: LIST
46694: PUSH
46695: LD_VAR 0 1
46699: PUSH
46700: LD_INT 3
46702: PLUS
46703: PUSH
46704: LD_VAR 0 2
46708: PUSH
46709: LD_INT 3
46711: PLUS
46712: PUSH
46713: LD_INT 5
46715: PUSH
46716: EMPTY
46717: LIST
46718: LIST
46719: LIST
46720: PUSH
46721: LD_VAR 0 1
46725: PUSH
46726: LD_INT 4
46728: PLUS
46729: PUSH
46730: LD_VAR 0 2
46734: PUSH
46735: LD_INT 4
46737: PUSH
46738: EMPTY
46739: LIST
46740: LIST
46741: LIST
46742: PUSH
46743: LD_VAR 0 1
46747: PUSH
46748: LD_VAR 0 2
46752: PUSH
46753: LD_INT 3
46755: MINUS
46756: PUSH
46757: LD_INT 3
46759: PUSH
46760: EMPTY
46761: LIST
46762: LIST
46763: LIST
46764: PUSH
46765: LD_VAR 0 1
46769: PUSH
46770: LD_INT 4
46772: MINUS
46773: PUSH
46774: LD_VAR 0 2
46778: PUSH
46779: LD_INT 4
46781: MINUS
46782: PUSH
46783: LD_INT 2
46785: PUSH
46786: EMPTY
46787: LIST
46788: LIST
46789: LIST
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: LIST
46795: LIST
46796: LIST
46797: ST_TO_ADDR
// end ; 5 :
46798: GO 46938
46800: LD_INT 5
46802: DOUBLE
46803: EQUAL
46804: IFTRUE 46808
46806: GO 46937
46808: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46809: LD_ADDR_VAR 0 5
46813: PUSH
46814: LD_VAR 0 1
46818: PUSH
46819: LD_INT 4
46821: MINUS
46822: PUSH
46823: LD_VAR 0 2
46827: PUSH
46828: LD_INT 1
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: LIST
46835: PUSH
46836: LD_VAR 0 1
46840: PUSH
46841: LD_VAR 0 2
46845: PUSH
46846: LD_INT 4
46848: MINUS
46849: PUSH
46850: LD_INT 3
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: LIST
46857: PUSH
46858: LD_VAR 0 1
46862: PUSH
46863: LD_INT 4
46865: PLUS
46866: PUSH
46867: LD_VAR 0 2
46871: PUSH
46872: LD_INT 4
46874: PLUS
46875: PUSH
46876: LD_INT 5
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: LIST
46883: PUSH
46884: LD_VAR 0 1
46888: PUSH
46889: LD_INT 3
46891: PLUS
46892: PUSH
46893: LD_VAR 0 2
46897: PUSH
46898: LD_INT 4
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: LIST
46905: PUSH
46906: LD_VAR 0 1
46910: PUSH
46911: LD_VAR 0 2
46915: PUSH
46916: LD_INT 3
46918: PLUS
46919: PUSH
46920: LD_INT 0
46922: PUSH
46923: EMPTY
46924: LIST
46925: LIST
46926: LIST
46927: PUSH
46928: EMPTY
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: ST_TO_ADDR
// end ; end ;
46935: GO 46938
46937: POP
// result := list ;
46938: LD_ADDR_VAR 0 4
46942: PUSH
46943: LD_VAR 0 5
46947: ST_TO_ADDR
// end ;
46948: LD_VAR 0 4
46952: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46953: LD_INT 0
46955: PPUSH
46956: PPUSH
46957: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46958: LD_VAR 0 1
46962: NOT
46963: PUSH
46964: LD_VAR 0 2
46968: PUSH
46969: LD_INT 1
46971: PUSH
46972: LD_INT 2
46974: PUSH
46975: LD_INT 3
46977: PUSH
46978: LD_INT 4
46980: PUSH
46981: EMPTY
46982: LIST
46983: LIST
46984: LIST
46985: LIST
46986: IN
46987: NOT
46988: OR
46989: IFFALSE 46993
// exit ;
46991: GO 47076
// tmp := [ ] ;
46993: LD_ADDR_VAR 0 5
46997: PUSH
46998: EMPTY
46999: ST_TO_ADDR
// for i in units do
47000: LD_ADDR_VAR 0 4
47004: PUSH
47005: LD_VAR 0 1
47009: PUSH
47010: FOR_IN
47011: IFFALSE 47045
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
47013: LD_ADDR_VAR 0 5
47017: PUSH
47018: LD_VAR 0 5
47022: PPUSH
47023: LD_VAR 0 4
47027: PPUSH
47028: LD_VAR 0 2
47032: PPUSH
47033: CALL_OW 259
47037: PPUSH
47038: CALL 48436 0 2
47042: ST_TO_ADDR
47043: GO 47010
47045: POP
47046: POP
// if not tmp then
47047: LD_VAR 0 5
47051: NOT
47052: IFFALSE 47056
// exit ;
47054: GO 47076
// result := SortListByListDesc ( units , tmp ) ;
47056: LD_ADDR_VAR 0 3
47060: PUSH
47061: LD_VAR 0 1
47065: PPUSH
47066: LD_VAR 0 5
47070: PPUSH
47071: CALL_OW 77
47075: ST_TO_ADDR
// end ;
47076: LD_VAR 0 3
47080: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47081: LD_INT 0
47083: PPUSH
47084: PPUSH
47085: PPUSH
// result := false ;
47086: LD_ADDR_VAR 0 3
47090: PUSH
47091: LD_INT 0
47093: ST_TO_ADDR
// if not building then
47094: LD_VAR 0 2
47098: NOT
47099: IFFALSE 47103
// exit ;
47101: GO 47241
// x := GetX ( building ) ;
47103: LD_ADDR_VAR 0 4
47107: PUSH
47108: LD_VAR 0 2
47112: PPUSH
47113: CALL_OW 250
47117: ST_TO_ADDR
// y := GetY ( building ) ;
47118: LD_ADDR_VAR 0 5
47122: PUSH
47123: LD_VAR 0 2
47127: PPUSH
47128: CALL_OW 251
47132: ST_TO_ADDR
// if not x or not y then
47133: LD_VAR 0 4
47137: NOT
47138: PUSH
47139: LD_VAR 0 5
47143: NOT
47144: OR
47145: IFFALSE 47149
// exit ;
47147: GO 47241
// if GetTaskList ( unit ) then
47149: LD_VAR 0 1
47153: PPUSH
47154: CALL_OW 437
47158: IFFALSE 47241
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47160: LD_STRING e
47162: PUSH
47163: LD_VAR 0 1
47167: PPUSH
47168: CALL_OW 437
47172: PUSH
47173: LD_INT 1
47175: ARRAY
47176: PUSH
47177: LD_INT 1
47179: ARRAY
47180: EQUAL
47181: PUSH
47182: LD_VAR 0 4
47186: PUSH
47187: LD_VAR 0 1
47191: PPUSH
47192: CALL_OW 437
47196: PUSH
47197: LD_INT 1
47199: ARRAY
47200: PUSH
47201: LD_INT 2
47203: ARRAY
47204: EQUAL
47205: AND
47206: PUSH
47207: LD_VAR 0 5
47211: PUSH
47212: LD_VAR 0 1
47216: PPUSH
47217: CALL_OW 437
47221: PUSH
47222: LD_INT 1
47224: ARRAY
47225: PUSH
47226: LD_INT 3
47228: ARRAY
47229: EQUAL
47230: AND
47231: IFFALSE 47241
// result := true end ;
47233: LD_ADDR_VAR 0 3
47237: PUSH
47238: LD_INT 1
47240: ST_TO_ADDR
// end ;
47241: LD_VAR 0 3
47245: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47246: LD_INT 0
47248: PPUSH
// result := false ;
47249: LD_ADDR_VAR 0 4
47253: PUSH
47254: LD_INT 0
47256: ST_TO_ADDR
// if GetTaskList ( unit ) then
47257: LD_VAR 0 1
47261: PPUSH
47262: CALL_OW 437
47266: IFFALSE 47349
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47268: LD_STRING M
47270: PUSH
47271: LD_VAR 0 1
47275: PPUSH
47276: CALL_OW 437
47280: PUSH
47281: LD_INT 1
47283: ARRAY
47284: PUSH
47285: LD_INT 1
47287: ARRAY
47288: EQUAL
47289: PUSH
47290: LD_VAR 0 2
47294: PUSH
47295: LD_VAR 0 1
47299: PPUSH
47300: CALL_OW 437
47304: PUSH
47305: LD_INT 1
47307: ARRAY
47308: PUSH
47309: LD_INT 2
47311: ARRAY
47312: EQUAL
47313: AND
47314: PUSH
47315: LD_VAR 0 3
47319: PUSH
47320: LD_VAR 0 1
47324: PPUSH
47325: CALL_OW 437
47329: PUSH
47330: LD_INT 1
47332: ARRAY
47333: PUSH
47334: LD_INT 3
47336: ARRAY
47337: EQUAL
47338: AND
47339: IFFALSE 47349
// result := true ;
47341: LD_ADDR_VAR 0 4
47345: PUSH
47346: LD_INT 1
47348: ST_TO_ADDR
// end ; end ;
47349: LD_VAR 0 4
47353: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47354: LD_INT 0
47356: PPUSH
47357: PPUSH
47358: PPUSH
47359: PPUSH
// if not unit or not area then
47360: LD_VAR 0 1
47364: NOT
47365: PUSH
47366: LD_VAR 0 2
47370: NOT
47371: OR
47372: IFFALSE 47376
// exit ;
47374: GO 47539
// tmp := AreaToList ( area , i ) ;
47376: LD_ADDR_VAR 0 6
47380: PUSH
47381: LD_VAR 0 2
47385: PPUSH
47386: LD_VAR 0 5
47390: PPUSH
47391: CALL_OW 517
47395: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47396: LD_ADDR_VAR 0 5
47400: PUSH
47401: DOUBLE
47402: LD_INT 1
47404: DEC
47405: ST_TO_ADDR
47406: LD_VAR 0 6
47410: PUSH
47411: LD_INT 1
47413: ARRAY
47414: PUSH
47415: FOR_TO
47416: IFFALSE 47537
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47418: LD_ADDR_VAR 0 7
47422: PUSH
47423: LD_VAR 0 6
47427: PUSH
47428: LD_INT 1
47430: ARRAY
47431: PUSH
47432: LD_VAR 0 5
47436: ARRAY
47437: PUSH
47438: LD_VAR 0 6
47442: PUSH
47443: LD_INT 2
47445: ARRAY
47446: PUSH
47447: LD_VAR 0 5
47451: ARRAY
47452: PUSH
47453: EMPTY
47454: LIST
47455: LIST
47456: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
47457: LD_INT 92
47459: PUSH
47460: LD_VAR 0 7
47464: PUSH
47465: LD_INT 1
47467: ARRAY
47468: PUSH
47469: LD_VAR 0 7
47473: PUSH
47474: LD_INT 2
47476: ARRAY
47477: PUSH
47478: LD_INT 3
47480: PUSH
47481: EMPTY
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: PPUSH
47487: CALL_OW 69
47491: PUSH
47492: LD_INT 0
47494: EQUAL
47495: IFFALSE 47535
// begin PlaceUnitArea ( unit , area , mode ) ;
47497: LD_VAR 0 1
47501: PPUSH
47502: LD_VAR 0 2
47506: PPUSH
47507: LD_VAR 0 3
47511: PPUSH
47512: CALL_OW 49
// result := IsPlaced ( unit ) ;
47516: LD_ADDR_VAR 0 4
47520: PUSH
47521: LD_VAR 0 1
47525: PPUSH
47526: CALL_OW 305
47530: ST_TO_ADDR
// exit ;
47531: POP
47532: POP
47533: GO 47539
// end ; end ;
47535: GO 47415
47537: POP
47538: POP
// end ;
47539: LD_VAR 0 4
47543: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47544: LD_INT 0
47546: PPUSH
47547: PPUSH
47548: PPUSH
// if not side or side > 8 then
47549: LD_VAR 0 1
47553: NOT
47554: PUSH
47555: LD_VAR 0 1
47559: PUSH
47560: LD_INT 8
47562: GREATER
47563: OR
47564: IFFALSE 47568
// exit ;
47566: GO 47755
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47568: LD_ADDR_VAR 0 4
47572: PUSH
47573: LD_INT 22
47575: PUSH
47576: LD_VAR 0 1
47580: PUSH
47581: EMPTY
47582: LIST
47583: LIST
47584: PUSH
47585: LD_INT 21
47587: PUSH
47588: LD_INT 3
47590: PUSH
47591: EMPTY
47592: LIST
47593: LIST
47594: PUSH
47595: EMPTY
47596: LIST
47597: LIST
47598: PPUSH
47599: CALL_OW 69
47603: ST_TO_ADDR
// if not tmp then
47604: LD_VAR 0 4
47608: NOT
47609: IFFALSE 47613
// exit ;
47611: GO 47755
// enable_addtolog := true ;
47613: LD_ADDR_OWVAR 81
47617: PUSH
47618: LD_INT 1
47620: ST_TO_ADDR
// AddToLog ( [ ) ;
47621: LD_STRING [
47623: PPUSH
47624: CALL_OW 561
// for i in tmp do
47628: LD_ADDR_VAR 0 3
47632: PUSH
47633: LD_VAR 0 4
47637: PUSH
47638: FOR_IN
47639: IFFALSE 47746
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
47641: LD_STRING [
47643: PUSH
47644: LD_VAR 0 3
47648: PPUSH
47649: CALL_OW 266
47653: STR
47654: PUSH
47655: LD_STRING , 
47657: STR
47658: PUSH
47659: LD_VAR 0 3
47663: PPUSH
47664: CALL_OW 250
47668: STR
47669: PUSH
47670: LD_STRING , 
47672: STR
47673: PUSH
47674: LD_VAR 0 3
47678: PPUSH
47679: CALL_OW 251
47683: STR
47684: PUSH
47685: LD_STRING , 
47687: STR
47688: PUSH
47689: LD_VAR 0 3
47693: PPUSH
47694: CALL_OW 254
47698: STR
47699: PUSH
47700: LD_STRING , 
47702: STR
47703: PUSH
47704: LD_VAR 0 3
47708: PPUSH
47709: LD_INT 1
47711: PPUSH
47712: CALL_OW 268
47716: STR
47717: PUSH
47718: LD_STRING , 
47720: STR
47721: PUSH
47722: LD_VAR 0 3
47726: PPUSH
47727: LD_INT 2
47729: PPUSH
47730: CALL_OW 268
47734: STR
47735: PUSH
47736: LD_STRING ],
47738: STR
47739: PPUSH
47740: CALL_OW 561
// end ;
47744: GO 47638
47746: POP
47747: POP
// AddToLog ( ]; ) ;
47748: LD_STRING ];
47750: PPUSH
47751: CALL_OW 561
// end ;
47755: LD_VAR 0 2
47759: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47760: LD_INT 0
47762: PPUSH
47763: PPUSH
47764: PPUSH
47765: PPUSH
47766: PPUSH
// if not area or not rate or not max then
47767: LD_VAR 0 1
47771: NOT
47772: PUSH
47773: LD_VAR 0 2
47777: NOT
47778: OR
47779: PUSH
47780: LD_VAR 0 4
47784: NOT
47785: OR
47786: IFFALSE 47790
// exit ;
47788: GO 47979
// while 1 do
47790: LD_INT 1
47792: IFFALSE 47979
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47794: LD_ADDR_VAR 0 9
47798: PUSH
47799: LD_VAR 0 1
47803: PPUSH
47804: LD_INT 1
47806: PPUSH
47807: CALL_OW 287
47811: PUSH
47812: LD_INT 10
47814: MUL
47815: ST_TO_ADDR
// r := rate / 10 ;
47816: LD_ADDR_VAR 0 7
47820: PUSH
47821: LD_VAR 0 2
47825: PUSH
47826: LD_INT 10
47828: DIVREAL
47829: ST_TO_ADDR
// time := 1 1$00 ;
47830: LD_ADDR_VAR 0 8
47834: PUSH
47835: LD_INT 2100
47837: ST_TO_ADDR
// if amount < min then
47838: LD_VAR 0 9
47842: PUSH
47843: LD_VAR 0 3
47847: LESS
47848: IFFALSE 47866
// r := r * 2 else
47850: LD_ADDR_VAR 0 7
47854: PUSH
47855: LD_VAR 0 7
47859: PUSH
47860: LD_INT 2
47862: MUL
47863: ST_TO_ADDR
47864: GO 47892
// if amount > max then
47866: LD_VAR 0 9
47870: PUSH
47871: LD_VAR 0 4
47875: GREATER
47876: IFFALSE 47892
// r := r / 2 ;
47878: LD_ADDR_VAR 0 7
47882: PUSH
47883: LD_VAR 0 7
47887: PUSH
47888: LD_INT 2
47890: DIVREAL
47891: ST_TO_ADDR
// time := time / r ;
47892: LD_ADDR_VAR 0 8
47896: PUSH
47897: LD_VAR 0 8
47901: PUSH
47902: LD_VAR 0 7
47906: DIVREAL
47907: ST_TO_ADDR
// if time < 0 then
47908: LD_VAR 0 8
47912: PUSH
47913: LD_INT 0
47915: LESS
47916: IFFALSE 47933
// time := time * - 1 ;
47918: LD_ADDR_VAR 0 8
47922: PUSH
47923: LD_VAR 0 8
47927: PUSH
47928: LD_INT 1
47930: NEG
47931: MUL
47932: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47933: LD_VAR 0 8
47937: PUSH
47938: LD_INT 35
47940: PPUSH
47941: LD_INT 875
47943: PPUSH
47944: CALL_OW 12
47948: PLUS
47949: PPUSH
47950: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47954: LD_INT 1
47956: PPUSH
47957: LD_INT 5
47959: PPUSH
47960: CALL_OW 12
47964: PPUSH
47965: LD_VAR 0 1
47969: PPUSH
47970: LD_INT 1
47972: PPUSH
47973: CALL_OW 55
// end ;
47977: GO 47790
// end ;
47979: LD_VAR 0 5
47983: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47984: LD_INT 0
47986: PPUSH
47987: PPUSH
47988: PPUSH
47989: PPUSH
47990: PPUSH
47991: PPUSH
47992: PPUSH
47993: PPUSH
// if not turrets or not factories then
47994: LD_VAR 0 1
47998: NOT
47999: PUSH
48000: LD_VAR 0 2
48004: NOT
48005: OR
48006: IFFALSE 48010
// exit ;
48008: GO 48317
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48010: LD_ADDR_VAR 0 10
48014: PUSH
48015: LD_INT 5
48017: PUSH
48018: LD_INT 6
48020: PUSH
48021: EMPTY
48022: LIST
48023: LIST
48024: PUSH
48025: LD_INT 2
48027: PUSH
48028: LD_INT 4
48030: PUSH
48031: EMPTY
48032: LIST
48033: LIST
48034: PUSH
48035: LD_INT 3
48037: PUSH
48038: LD_INT 5
48040: PUSH
48041: EMPTY
48042: LIST
48043: LIST
48044: PUSH
48045: EMPTY
48046: LIST
48047: LIST
48048: LIST
48049: PUSH
48050: LD_INT 24
48052: PUSH
48053: LD_INT 25
48055: PUSH
48056: EMPTY
48057: LIST
48058: LIST
48059: PUSH
48060: LD_INT 23
48062: PUSH
48063: LD_INT 27
48065: PUSH
48066: EMPTY
48067: LIST
48068: LIST
48069: PUSH
48070: EMPTY
48071: LIST
48072: LIST
48073: PUSH
48074: LD_INT 42
48076: PUSH
48077: LD_INT 43
48079: PUSH
48080: EMPTY
48081: LIST
48082: LIST
48083: PUSH
48084: LD_INT 44
48086: PUSH
48087: LD_INT 46
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: PUSH
48094: LD_INT 45
48096: PUSH
48097: LD_INT 47
48099: PUSH
48100: EMPTY
48101: LIST
48102: LIST
48103: PUSH
48104: EMPTY
48105: LIST
48106: LIST
48107: LIST
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: LIST
48113: ST_TO_ADDR
// result := [ ] ;
48114: LD_ADDR_VAR 0 3
48118: PUSH
48119: EMPTY
48120: ST_TO_ADDR
// for i in turrets do
48121: LD_ADDR_VAR 0 4
48125: PUSH
48126: LD_VAR 0 1
48130: PUSH
48131: FOR_IN
48132: IFFALSE 48315
// begin nat := GetNation ( i ) ;
48134: LD_ADDR_VAR 0 7
48138: PUSH
48139: LD_VAR 0 4
48143: PPUSH
48144: CALL_OW 248
48148: ST_TO_ADDR
// weapon := 0 ;
48149: LD_ADDR_VAR 0 8
48153: PUSH
48154: LD_INT 0
48156: ST_TO_ADDR
// if not nat then
48157: LD_VAR 0 7
48161: NOT
48162: IFFALSE 48166
// continue ;
48164: GO 48131
// for j in list [ nat ] do
48166: LD_ADDR_VAR 0 5
48170: PUSH
48171: LD_VAR 0 10
48175: PUSH
48176: LD_VAR 0 7
48180: ARRAY
48181: PUSH
48182: FOR_IN
48183: IFFALSE 48224
// if GetBWeapon ( i ) = j [ 1 ] then
48185: LD_VAR 0 4
48189: PPUSH
48190: CALL_OW 269
48194: PUSH
48195: LD_VAR 0 5
48199: PUSH
48200: LD_INT 1
48202: ARRAY
48203: EQUAL
48204: IFFALSE 48222
// begin weapon := j [ 2 ] ;
48206: LD_ADDR_VAR 0 8
48210: PUSH
48211: LD_VAR 0 5
48215: PUSH
48216: LD_INT 2
48218: ARRAY
48219: ST_TO_ADDR
// break ;
48220: GO 48224
// end ;
48222: GO 48182
48224: POP
48225: POP
// if not weapon then
48226: LD_VAR 0 8
48230: NOT
48231: IFFALSE 48235
// continue ;
48233: GO 48131
// for k in factories do
48235: LD_ADDR_VAR 0 6
48239: PUSH
48240: LD_VAR 0 2
48244: PUSH
48245: FOR_IN
48246: IFFALSE 48311
// begin weapons := AvailableWeaponList ( k ) ;
48248: LD_ADDR_VAR 0 9
48252: PUSH
48253: LD_VAR 0 6
48257: PPUSH
48258: CALL_OW 478
48262: ST_TO_ADDR
// if not weapons then
48263: LD_VAR 0 9
48267: NOT
48268: IFFALSE 48272
// continue ;
48270: GO 48245
// if weapon in weapons then
48272: LD_VAR 0 8
48276: PUSH
48277: LD_VAR 0 9
48281: IN
48282: IFFALSE 48309
// begin result := [ i , weapon ] ;
48284: LD_ADDR_VAR 0 3
48288: PUSH
48289: LD_VAR 0 4
48293: PUSH
48294: LD_VAR 0 8
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: ST_TO_ADDR
// exit ;
48303: POP
48304: POP
48305: POP
48306: POP
48307: GO 48317
// end ; end ;
48309: GO 48245
48311: POP
48312: POP
// end ;
48313: GO 48131
48315: POP
48316: POP
// end ;
48317: LD_VAR 0 3
48321: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48322: LD_INT 0
48324: PPUSH
// if not side or side > 8 then
48325: LD_VAR 0 3
48329: NOT
48330: PUSH
48331: LD_VAR 0 3
48335: PUSH
48336: LD_INT 8
48338: GREATER
48339: OR
48340: IFFALSE 48344
// exit ;
48342: GO 48403
// if not range then
48344: LD_VAR 0 4
48348: NOT
48349: IFFALSE 48360
// range := - 12 ;
48351: LD_ADDR_VAR 0 4
48355: PUSH
48356: LD_INT 12
48358: NEG
48359: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48360: LD_VAR 0 1
48364: PPUSH
48365: LD_VAR 0 2
48369: PPUSH
48370: LD_VAR 0 3
48374: PPUSH
48375: LD_VAR 0 4
48379: PPUSH
48380: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48384: LD_VAR 0 1
48388: PPUSH
48389: LD_VAR 0 2
48393: PPUSH
48394: LD_VAR 0 3
48398: PPUSH
48399: CALL_OW 331
// end ;
48403: LD_VAR 0 5
48407: RET
// export function Video ( mode ) ; begin
48408: LD_INT 0
48410: PPUSH
// ingame_video = mode ;
48411: LD_ADDR_OWVAR 52
48415: PUSH
48416: LD_VAR 0 1
48420: ST_TO_ADDR
// interface_hidden = mode ;
48421: LD_ADDR_OWVAR 54
48425: PUSH
48426: LD_VAR 0 1
48430: ST_TO_ADDR
// end ;
48431: LD_VAR 0 2
48435: RET
// export function Join ( array , element ) ; begin
48436: LD_INT 0
48438: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48439: LD_ADDR_VAR 0 3
48443: PUSH
48444: LD_VAR 0 1
48448: PPUSH
48449: LD_VAR 0 1
48453: PUSH
48454: LD_INT 1
48456: PLUS
48457: PPUSH
48458: LD_VAR 0 2
48462: PPUSH
48463: CALL_OW 1
48467: ST_TO_ADDR
// end ;
48468: LD_VAR 0 3
48472: RET
// export function JoinUnion ( array , element ) ; begin
48473: LD_INT 0
48475: PPUSH
// result := array union element ;
48476: LD_ADDR_VAR 0 3
48480: PUSH
48481: LD_VAR 0 1
48485: PUSH
48486: LD_VAR 0 2
48490: UNION
48491: ST_TO_ADDR
// end ;
48492: LD_VAR 0 3
48496: RET
// export function GetBehemoths ( side ) ; begin
48497: LD_INT 0
48499: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48500: LD_ADDR_VAR 0 2
48504: PUSH
48505: LD_INT 22
48507: PUSH
48508: LD_VAR 0 1
48512: PUSH
48513: EMPTY
48514: LIST
48515: LIST
48516: PUSH
48517: LD_INT 31
48519: PUSH
48520: LD_INT 25
48522: PUSH
48523: EMPTY
48524: LIST
48525: LIST
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PPUSH
48531: CALL_OW 69
48535: ST_TO_ADDR
// end ;
48536: LD_VAR 0 2
48540: RET
// export function Shuffle ( array ) ; var i , index ; begin
48541: LD_INT 0
48543: PPUSH
48544: PPUSH
48545: PPUSH
// result := [ ] ;
48546: LD_ADDR_VAR 0 2
48550: PUSH
48551: EMPTY
48552: ST_TO_ADDR
// if not array then
48553: LD_VAR 0 1
48557: NOT
48558: IFFALSE 48562
// exit ;
48560: GO 48661
// Randomize ;
48562: CALL_OW 10
// for i = array downto 1 do
48566: LD_ADDR_VAR 0 3
48570: PUSH
48571: DOUBLE
48572: LD_VAR 0 1
48576: INC
48577: ST_TO_ADDR
48578: LD_INT 1
48580: PUSH
48581: FOR_DOWNTO
48582: IFFALSE 48659
// begin index := rand ( 1 , array ) ;
48584: LD_ADDR_VAR 0 4
48588: PUSH
48589: LD_INT 1
48591: PPUSH
48592: LD_VAR 0 1
48596: PPUSH
48597: CALL_OW 12
48601: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48602: LD_ADDR_VAR 0 2
48606: PUSH
48607: LD_VAR 0 2
48611: PPUSH
48612: LD_VAR 0 2
48616: PUSH
48617: LD_INT 1
48619: PLUS
48620: PPUSH
48621: LD_VAR 0 1
48625: PUSH
48626: LD_VAR 0 4
48630: ARRAY
48631: PPUSH
48632: CALL_OW 2
48636: ST_TO_ADDR
// array := Delete ( array , index ) ;
48637: LD_ADDR_VAR 0 1
48641: PUSH
48642: LD_VAR 0 1
48646: PPUSH
48647: LD_VAR 0 4
48651: PPUSH
48652: CALL_OW 3
48656: ST_TO_ADDR
// end ;
48657: GO 48581
48659: POP
48660: POP
// end ;
48661: LD_VAR 0 2
48665: RET
// export function GetBaseMaterials ( base ) ; begin
48666: LD_INT 0
48668: PPUSH
// result := [ 0 , 0 , 0 ] ;
48669: LD_ADDR_VAR 0 2
48673: PUSH
48674: LD_INT 0
48676: PUSH
48677: LD_INT 0
48679: PUSH
48680: LD_INT 0
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: LIST
48687: ST_TO_ADDR
// if not base then
48688: LD_VAR 0 1
48692: NOT
48693: IFFALSE 48697
// exit ;
48695: GO 48746
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48697: LD_ADDR_VAR 0 2
48701: PUSH
48702: LD_VAR 0 1
48706: PPUSH
48707: LD_INT 1
48709: PPUSH
48710: CALL_OW 275
48714: PUSH
48715: LD_VAR 0 1
48719: PPUSH
48720: LD_INT 2
48722: PPUSH
48723: CALL_OW 275
48727: PUSH
48728: LD_VAR 0 1
48732: PPUSH
48733: LD_INT 3
48735: PPUSH
48736: CALL_OW 275
48740: PUSH
48741: EMPTY
48742: LIST
48743: LIST
48744: LIST
48745: ST_TO_ADDR
// end ;
48746: LD_VAR 0 2
48750: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48751: LD_INT 0
48753: PPUSH
48754: PPUSH
// result := array ;
48755: LD_ADDR_VAR 0 3
48759: PUSH
48760: LD_VAR 0 1
48764: ST_TO_ADDR
// if size >= result then
48765: LD_VAR 0 2
48769: PUSH
48770: LD_VAR 0 3
48774: GREATEREQUAL
48775: IFFALSE 48779
// exit ;
48777: GO 48829
// if size then
48779: LD_VAR 0 2
48783: IFFALSE 48829
// for i := array downto size do
48785: LD_ADDR_VAR 0 4
48789: PUSH
48790: DOUBLE
48791: LD_VAR 0 1
48795: INC
48796: ST_TO_ADDR
48797: LD_VAR 0 2
48801: PUSH
48802: FOR_DOWNTO
48803: IFFALSE 48827
// result := Delete ( result , result ) ;
48805: LD_ADDR_VAR 0 3
48809: PUSH
48810: LD_VAR 0 3
48814: PPUSH
48815: LD_VAR 0 3
48819: PPUSH
48820: CALL_OW 3
48824: ST_TO_ADDR
48825: GO 48802
48827: POP
48828: POP
// end ;
48829: LD_VAR 0 3
48833: RET
// export function ComExit ( unit ) ; var tmp ; begin
48834: LD_INT 0
48836: PPUSH
48837: PPUSH
// if not IsInUnit ( unit ) then
48838: LD_VAR 0 1
48842: PPUSH
48843: CALL_OW 310
48847: NOT
48848: IFFALSE 48852
// exit ;
48850: GO 48912
// tmp := IsInUnit ( unit ) ;
48852: LD_ADDR_VAR 0 3
48856: PUSH
48857: LD_VAR 0 1
48861: PPUSH
48862: CALL_OW 310
48866: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48867: LD_VAR 0 3
48871: PPUSH
48872: CALL_OW 247
48876: PUSH
48877: LD_INT 2
48879: EQUAL
48880: IFFALSE 48893
// ComExitVehicle ( unit ) else
48882: LD_VAR 0 1
48886: PPUSH
48887: CALL_OW 121
48891: GO 48902
// ComExitBuilding ( unit ) ;
48893: LD_VAR 0 1
48897: PPUSH
48898: CALL_OW 122
// result := tmp ;
48902: LD_ADDR_VAR 0 2
48906: PUSH
48907: LD_VAR 0 3
48911: ST_TO_ADDR
// end ;
48912: LD_VAR 0 2
48916: RET
// export function ComExitAll ( units ) ; var i ; begin
48917: LD_INT 0
48919: PPUSH
48920: PPUSH
// if not units then
48921: LD_VAR 0 1
48925: NOT
48926: IFFALSE 48930
// exit ;
48928: GO 48956
// for i in units do
48930: LD_ADDR_VAR 0 3
48934: PUSH
48935: LD_VAR 0 1
48939: PUSH
48940: FOR_IN
48941: IFFALSE 48954
// ComExit ( i ) ;
48943: LD_VAR 0 3
48947: PPUSH
48948: CALL 48834 0 1
48952: GO 48940
48954: POP
48955: POP
// end ;
48956: LD_VAR 0 2
48960: RET
// export function ResetHc ; begin
48961: LD_INT 0
48963: PPUSH
// InitHc ;
48964: CALL_OW 19
// hc_importance := 0 ;
48968: LD_ADDR_OWVAR 32
48972: PUSH
48973: LD_INT 0
48975: ST_TO_ADDR
// end ;
48976: LD_VAR 0 1
48980: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48981: LD_INT 0
48983: PPUSH
48984: PPUSH
48985: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48986: LD_ADDR_VAR 0 6
48990: PUSH
48991: LD_VAR 0 1
48995: PUSH
48996: LD_VAR 0 3
49000: PLUS
49001: PUSH
49002: LD_INT 2
49004: DIV
49005: ST_TO_ADDR
// if _x < 0 then
49006: LD_VAR 0 6
49010: PUSH
49011: LD_INT 0
49013: LESS
49014: IFFALSE 49031
// _x := _x * - 1 ;
49016: LD_ADDR_VAR 0 6
49020: PUSH
49021: LD_VAR 0 6
49025: PUSH
49026: LD_INT 1
49028: NEG
49029: MUL
49030: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49031: LD_ADDR_VAR 0 7
49035: PUSH
49036: LD_VAR 0 2
49040: PUSH
49041: LD_VAR 0 4
49045: PLUS
49046: PUSH
49047: LD_INT 2
49049: DIV
49050: ST_TO_ADDR
// if _y < 0 then
49051: LD_VAR 0 7
49055: PUSH
49056: LD_INT 0
49058: LESS
49059: IFFALSE 49076
// _y := _y * - 1 ;
49061: LD_ADDR_VAR 0 7
49065: PUSH
49066: LD_VAR 0 7
49070: PUSH
49071: LD_INT 1
49073: NEG
49074: MUL
49075: ST_TO_ADDR
// result := [ _x , _y ] ;
49076: LD_ADDR_VAR 0 5
49080: PUSH
49081: LD_VAR 0 6
49085: PUSH
49086: LD_VAR 0 7
49090: PUSH
49091: EMPTY
49092: LIST
49093: LIST
49094: ST_TO_ADDR
// end ;
49095: LD_VAR 0 5
49099: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49100: LD_INT 0
49102: PPUSH
49103: PPUSH
49104: PPUSH
49105: PPUSH
// task := GetTaskList ( unit ) ;
49106: LD_ADDR_VAR 0 7
49110: PUSH
49111: LD_VAR 0 1
49115: PPUSH
49116: CALL_OW 437
49120: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49121: LD_VAR 0 7
49125: NOT
49126: PUSH
49127: LD_VAR 0 1
49131: PPUSH
49132: LD_VAR 0 2
49136: PPUSH
49137: CALL_OW 308
49141: NOT
49142: AND
49143: IFFALSE 49147
// exit ;
49145: GO 49265
// if IsInArea ( unit , area ) then
49147: LD_VAR 0 1
49151: PPUSH
49152: LD_VAR 0 2
49156: PPUSH
49157: CALL_OW 308
49161: IFFALSE 49179
// begin ComMoveToArea ( unit , goAway ) ;
49163: LD_VAR 0 1
49167: PPUSH
49168: LD_VAR 0 3
49172: PPUSH
49173: CALL_OW 113
// exit ;
49177: GO 49265
// end ; if task [ 1 ] [ 1 ] <> M then
49179: LD_VAR 0 7
49183: PUSH
49184: LD_INT 1
49186: ARRAY
49187: PUSH
49188: LD_INT 1
49190: ARRAY
49191: PUSH
49192: LD_STRING M
49194: NONEQUAL
49195: IFFALSE 49199
// exit ;
49197: GO 49265
// x := task [ 1 ] [ 2 ] ;
49199: LD_ADDR_VAR 0 5
49203: PUSH
49204: LD_VAR 0 7
49208: PUSH
49209: LD_INT 1
49211: ARRAY
49212: PUSH
49213: LD_INT 2
49215: ARRAY
49216: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49217: LD_ADDR_VAR 0 6
49221: PUSH
49222: LD_VAR 0 7
49226: PUSH
49227: LD_INT 1
49229: ARRAY
49230: PUSH
49231: LD_INT 3
49233: ARRAY
49234: ST_TO_ADDR
// if InArea ( x , y , area ) then
49235: LD_VAR 0 5
49239: PPUSH
49240: LD_VAR 0 6
49244: PPUSH
49245: LD_VAR 0 2
49249: PPUSH
49250: CALL_OW 309
49254: IFFALSE 49265
// ComStop ( unit ) ;
49256: LD_VAR 0 1
49260: PPUSH
49261: CALL_OW 141
// end ;
49265: LD_VAR 0 4
49269: RET
// export function Abs ( value ) ; begin
49270: LD_INT 0
49272: PPUSH
// result := value ;
49273: LD_ADDR_VAR 0 2
49277: PUSH
49278: LD_VAR 0 1
49282: ST_TO_ADDR
// if value < 0 then
49283: LD_VAR 0 1
49287: PUSH
49288: LD_INT 0
49290: LESS
49291: IFFALSE 49308
// result := value * - 1 ;
49293: LD_ADDR_VAR 0 2
49297: PUSH
49298: LD_VAR 0 1
49302: PUSH
49303: LD_INT 1
49305: NEG
49306: MUL
49307: ST_TO_ADDR
// end ;
49308: LD_VAR 0 2
49312: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49313: LD_INT 0
49315: PPUSH
49316: PPUSH
49317: PPUSH
49318: PPUSH
49319: PPUSH
49320: PPUSH
49321: PPUSH
49322: PPUSH
// if not unit or not building then
49323: LD_VAR 0 1
49327: NOT
49328: PUSH
49329: LD_VAR 0 2
49333: NOT
49334: OR
49335: IFFALSE 49339
// exit ;
49337: GO 49565
// x := GetX ( building ) ;
49339: LD_ADDR_VAR 0 4
49343: PUSH
49344: LD_VAR 0 2
49348: PPUSH
49349: CALL_OW 250
49353: ST_TO_ADDR
// y := GetY ( building ) ;
49354: LD_ADDR_VAR 0 6
49358: PUSH
49359: LD_VAR 0 2
49363: PPUSH
49364: CALL_OW 251
49368: ST_TO_ADDR
// d := GetDir ( building ) ;
49369: LD_ADDR_VAR 0 8
49373: PUSH
49374: LD_VAR 0 2
49378: PPUSH
49379: CALL_OW 254
49383: ST_TO_ADDR
// r := 4 ;
49384: LD_ADDR_VAR 0 9
49388: PUSH
49389: LD_INT 4
49391: ST_TO_ADDR
// for i := 1 to 5 do
49392: LD_ADDR_VAR 0 10
49396: PUSH
49397: DOUBLE
49398: LD_INT 1
49400: DEC
49401: ST_TO_ADDR
49402: LD_INT 5
49404: PUSH
49405: FOR_TO
49406: IFFALSE 49563
// begin _x := ShiftX ( x , d , r + i ) ;
49408: LD_ADDR_VAR 0 5
49412: PUSH
49413: LD_VAR 0 4
49417: PPUSH
49418: LD_VAR 0 8
49422: PPUSH
49423: LD_VAR 0 9
49427: PUSH
49428: LD_VAR 0 10
49432: PLUS
49433: PPUSH
49434: CALL_OW 272
49438: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49439: LD_ADDR_VAR 0 7
49443: PUSH
49444: LD_VAR 0 6
49448: PPUSH
49449: LD_VAR 0 8
49453: PPUSH
49454: LD_VAR 0 9
49458: PUSH
49459: LD_VAR 0 10
49463: PLUS
49464: PPUSH
49465: CALL_OW 273
49469: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49470: LD_VAR 0 5
49474: PPUSH
49475: LD_VAR 0 7
49479: PPUSH
49480: CALL_OW 488
49484: PUSH
49485: LD_VAR 0 5
49489: PPUSH
49490: LD_VAR 0 7
49494: PPUSH
49495: CALL_OW 428
49499: PPUSH
49500: CALL_OW 247
49504: PUSH
49505: LD_INT 3
49507: PUSH
49508: LD_INT 2
49510: PUSH
49511: EMPTY
49512: LIST
49513: LIST
49514: IN
49515: NOT
49516: AND
49517: IFFALSE 49561
// begin ComMoveXY ( unit , _x , _y ) ;
49519: LD_VAR 0 1
49523: PPUSH
49524: LD_VAR 0 5
49528: PPUSH
49529: LD_VAR 0 7
49533: PPUSH
49534: CALL_OW 111
// result := [ _x , _y ] ;
49538: LD_ADDR_VAR 0 3
49542: PUSH
49543: LD_VAR 0 5
49547: PUSH
49548: LD_VAR 0 7
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: ST_TO_ADDR
// exit ;
49557: POP
49558: POP
49559: GO 49565
// end ; end ;
49561: GO 49405
49563: POP
49564: POP
// end ;
49565: LD_VAR 0 3
49569: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49570: LD_INT 0
49572: PPUSH
49573: PPUSH
49574: PPUSH
// result := 0 ;
49575: LD_ADDR_VAR 0 3
49579: PUSH
49580: LD_INT 0
49582: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49583: LD_VAR 0 1
49587: PUSH
49588: LD_INT 0
49590: LESS
49591: PUSH
49592: LD_VAR 0 1
49596: PUSH
49597: LD_INT 8
49599: GREATER
49600: OR
49601: PUSH
49602: LD_VAR 0 2
49606: PUSH
49607: LD_INT 0
49609: LESS
49610: OR
49611: PUSH
49612: LD_VAR 0 2
49616: PUSH
49617: LD_INT 8
49619: GREATER
49620: OR
49621: IFFALSE 49625
// exit ;
49623: GO 49700
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49625: LD_ADDR_VAR 0 4
49629: PUSH
49630: LD_INT 22
49632: PUSH
49633: LD_VAR 0 2
49637: PUSH
49638: EMPTY
49639: LIST
49640: LIST
49641: PPUSH
49642: CALL_OW 69
49646: PUSH
49647: FOR_IN
49648: IFFALSE 49698
// begin un := UnitShoot ( i ) ;
49650: LD_ADDR_VAR 0 5
49654: PUSH
49655: LD_VAR 0 4
49659: PPUSH
49660: CALL_OW 504
49664: ST_TO_ADDR
// if GetSide ( un ) = side1 then
49665: LD_VAR 0 5
49669: PPUSH
49670: CALL_OW 255
49674: PUSH
49675: LD_VAR 0 1
49679: EQUAL
49680: IFFALSE 49696
// begin result := un ;
49682: LD_ADDR_VAR 0 3
49686: PUSH
49687: LD_VAR 0 5
49691: ST_TO_ADDR
// exit ;
49692: POP
49693: POP
49694: GO 49700
// end ; end ;
49696: GO 49647
49698: POP
49699: POP
// end ;
49700: LD_VAR 0 3
49704: RET
// export function GetCargoBay ( units ) ; begin
49705: LD_INT 0
49707: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49708: LD_ADDR_VAR 0 2
49712: PUSH
49713: LD_VAR 0 1
49717: PPUSH
49718: LD_INT 2
49720: PUSH
49721: LD_INT 34
49723: PUSH
49724: LD_INT 12
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: PUSH
49731: LD_INT 34
49733: PUSH
49734: LD_INT 51
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: PUSH
49741: LD_INT 34
49743: PUSH
49744: LD_INT 32
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 34
49753: PUSH
49754: LD_INT 89
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: EMPTY
49762: LIST
49763: LIST
49764: LIST
49765: LIST
49766: LIST
49767: PPUSH
49768: CALL_OW 72
49772: ST_TO_ADDR
// end ;
49773: LD_VAR 0 2
49777: RET
// export function Negate ( value ) ; begin
49778: LD_INT 0
49780: PPUSH
// result := not value ;
49781: LD_ADDR_VAR 0 2
49785: PUSH
49786: LD_VAR 0 1
49790: NOT
49791: ST_TO_ADDR
// end ;
49792: LD_VAR 0 2
49796: RET
// export function Inc ( value ) ; begin
49797: LD_INT 0
49799: PPUSH
// result := value + 1 ;
49800: LD_ADDR_VAR 0 2
49804: PUSH
49805: LD_VAR 0 1
49809: PUSH
49810: LD_INT 1
49812: PLUS
49813: ST_TO_ADDR
// end ;
49814: LD_VAR 0 2
49818: RET
// export function Dec ( value ) ; begin
49819: LD_INT 0
49821: PPUSH
// result := value - 1 ;
49822: LD_ADDR_VAR 0 2
49826: PUSH
49827: LD_VAR 0 1
49831: PUSH
49832: LD_INT 1
49834: MINUS
49835: ST_TO_ADDR
// end ;
49836: LD_VAR 0 2
49840: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49841: LD_INT 0
49843: PPUSH
49844: PPUSH
49845: PPUSH
49846: PPUSH
49847: PPUSH
49848: PPUSH
49849: PPUSH
49850: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49851: LD_VAR 0 1
49855: PPUSH
49856: LD_VAR 0 2
49860: PPUSH
49861: CALL_OW 488
49865: NOT
49866: PUSH
49867: LD_VAR 0 3
49871: PPUSH
49872: LD_VAR 0 4
49876: PPUSH
49877: CALL_OW 488
49881: NOT
49882: OR
49883: IFFALSE 49896
// begin result := - 1 ;
49885: LD_ADDR_VAR 0 5
49889: PUSH
49890: LD_INT 1
49892: NEG
49893: ST_TO_ADDR
// exit ;
49894: GO 50131
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49896: LD_ADDR_VAR 0 12
49900: PUSH
49901: LD_VAR 0 1
49905: PPUSH
49906: LD_VAR 0 2
49910: PPUSH
49911: LD_VAR 0 3
49915: PPUSH
49916: LD_VAR 0 4
49920: PPUSH
49921: CALL 48981 0 4
49925: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49926: LD_ADDR_VAR 0 11
49930: PUSH
49931: LD_VAR 0 1
49935: PPUSH
49936: LD_VAR 0 2
49940: PPUSH
49941: LD_VAR 0 12
49945: PUSH
49946: LD_INT 1
49948: ARRAY
49949: PPUSH
49950: LD_VAR 0 12
49954: PUSH
49955: LD_INT 2
49957: ARRAY
49958: PPUSH
49959: CALL_OW 298
49963: ST_TO_ADDR
// distance := 9999 ;
49964: LD_ADDR_VAR 0 10
49968: PUSH
49969: LD_INT 9999
49971: ST_TO_ADDR
// for i := 0 to 5 do
49972: LD_ADDR_VAR 0 6
49976: PUSH
49977: DOUBLE
49978: LD_INT 0
49980: DEC
49981: ST_TO_ADDR
49982: LD_INT 5
49984: PUSH
49985: FOR_TO
49986: IFFALSE 50129
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49988: LD_ADDR_VAR 0 7
49992: PUSH
49993: LD_VAR 0 1
49997: PPUSH
49998: LD_VAR 0 6
50002: PPUSH
50003: LD_VAR 0 11
50007: PPUSH
50008: CALL_OW 272
50012: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50013: LD_ADDR_VAR 0 8
50017: PUSH
50018: LD_VAR 0 2
50022: PPUSH
50023: LD_VAR 0 6
50027: PPUSH
50028: LD_VAR 0 11
50032: PPUSH
50033: CALL_OW 273
50037: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50038: LD_VAR 0 7
50042: PPUSH
50043: LD_VAR 0 8
50047: PPUSH
50048: CALL_OW 488
50052: NOT
50053: IFFALSE 50057
// continue ;
50055: GO 49985
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50057: LD_ADDR_VAR 0 9
50061: PUSH
50062: LD_VAR 0 12
50066: PUSH
50067: LD_INT 1
50069: ARRAY
50070: PPUSH
50071: LD_VAR 0 12
50075: PUSH
50076: LD_INT 2
50078: ARRAY
50079: PPUSH
50080: LD_VAR 0 7
50084: PPUSH
50085: LD_VAR 0 8
50089: PPUSH
50090: CALL_OW 298
50094: ST_TO_ADDR
// if tmp < distance then
50095: LD_VAR 0 9
50099: PUSH
50100: LD_VAR 0 10
50104: LESS
50105: IFFALSE 50127
// begin result := i ;
50107: LD_ADDR_VAR 0 5
50111: PUSH
50112: LD_VAR 0 6
50116: ST_TO_ADDR
// distance := tmp ;
50117: LD_ADDR_VAR 0 10
50121: PUSH
50122: LD_VAR 0 9
50126: ST_TO_ADDR
// end ; end ;
50127: GO 49985
50129: POP
50130: POP
// end ;
50131: LD_VAR 0 5
50135: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50136: LD_INT 0
50138: PPUSH
50139: PPUSH
// if not driver or not IsInUnit ( driver ) then
50140: LD_VAR 0 1
50144: NOT
50145: PUSH
50146: LD_VAR 0 1
50150: PPUSH
50151: CALL_OW 310
50155: NOT
50156: OR
50157: IFFALSE 50161
// exit ;
50159: GO 50251
// vehicle := IsInUnit ( driver ) ;
50161: LD_ADDR_VAR 0 3
50165: PUSH
50166: LD_VAR 0 1
50170: PPUSH
50171: CALL_OW 310
50175: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50176: LD_VAR 0 1
50180: PPUSH
50181: LD_STRING \
50183: PUSH
50184: LD_INT 0
50186: PUSH
50187: LD_INT 0
50189: PUSH
50190: LD_INT 0
50192: PUSH
50193: LD_INT 0
50195: PUSH
50196: LD_INT 0
50198: PUSH
50199: LD_INT 0
50201: PUSH
50202: EMPTY
50203: LIST
50204: LIST
50205: LIST
50206: LIST
50207: LIST
50208: LIST
50209: LIST
50210: PUSH
50211: LD_STRING E
50213: PUSH
50214: LD_INT 0
50216: PUSH
50217: LD_INT 0
50219: PUSH
50220: LD_VAR 0 3
50224: PUSH
50225: LD_INT 0
50227: PUSH
50228: LD_INT 0
50230: PUSH
50231: LD_INT 0
50233: PUSH
50234: EMPTY
50235: LIST
50236: LIST
50237: LIST
50238: LIST
50239: LIST
50240: LIST
50241: LIST
50242: PUSH
50243: EMPTY
50244: LIST
50245: LIST
50246: PPUSH
50247: CALL_OW 446
// end ;
50251: LD_VAR 0 2
50255: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50256: LD_INT 0
50258: PPUSH
50259: PPUSH
// if not driver or not IsInUnit ( driver ) then
50260: LD_VAR 0 1
50264: NOT
50265: PUSH
50266: LD_VAR 0 1
50270: PPUSH
50271: CALL_OW 310
50275: NOT
50276: OR
50277: IFFALSE 50281
// exit ;
50279: GO 50371
// vehicle := IsInUnit ( driver ) ;
50281: LD_ADDR_VAR 0 3
50285: PUSH
50286: LD_VAR 0 1
50290: PPUSH
50291: CALL_OW 310
50295: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50296: LD_VAR 0 1
50300: PPUSH
50301: LD_STRING \
50303: PUSH
50304: LD_INT 0
50306: PUSH
50307: LD_INT 0
50309: PUSH
50310: LD_INT 0
50312: PUSH
50313: LD_INT 0
50315: PUSH
50316: LD_INT 0
50318: PUSH
50319: LD_INT 0
50321: PUSH
50322: EMPTY
50323: LIST
50324: LIST
50325: LIST
50326: LIST
50327: LIST
50328: LIST
50329: LIST
50330: PUSH
50331: LD_STRING E
50333: PUSH
50334: LD_INT 0
50336: PUSH
50337: LD_INT 0
50339: PUSH
50340: LD_VAR 0 3
50344: PUSH
50345: LD_INT 0
50347: PUSH
50348: LD_INT 0
50350: PUSH
50351: LD_INT 0
50353: PUSH
50354: EMPTY
50355: LIST
50356: LIST
50357: LIST
50358: LIST
50359: LIST
50360: LIST
50361: LIST
50362: PUSH
50363: EMPTY
50364: LIST
50365: LIST
50366: PPUSH
50367: CALL_OW 447
// end ;
50371: LD_VAR 0 2
50375: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50376: LD_INT 0
50378: PPUSH
50379: PPUSH
50380: PPUSH
// tmp := [ ] ;
50381: LD_ADDR_VAR 0 5
50385: PUSH
50386: EMPTY
50387: ST_TO_ADDR
// for i in units do
50388: LD_ADDR_VAR 0 4
50392: PUSH
50393: LD_VAR 0 1
50397: PUSH
50398: FOR_IN
50399: IFFALSE 50437
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50401: LD_ADDR_VAR 0 5
50405: PUSH
50406: LD_VAR 0 5
50410: PPUSH
50411: LD_VAR 0 5
50415: PUSH
50416: LD_INT 1
50418: PLUS
50419: PPUSH
50420: LD_VAR 0 4
50424: PPUSH
50425: CALL_OW 256
50429: PPUSH
50430: CALL_OW 2
50434: ST_TO_ADDR
50435: GO 50398
50437: POP
50438: POP
// if not tmp then
50439: LD_VAR 0 5
50443: NOT
50444: IFFALSE 50448
// exit ;
50446: GO 50496
// if asc then
50448: LD_VAR 0 2
50452: IFFALSE 50476
// result := SortListByListAsc ( units , tmp ) else
50454: LD_ADDR_VAR 0 3
50458: PUSH
50459: LD_VAR 0 1
50463: PPUSH
50464: LD_VAR 0 5
50468: PPUSH
50469: CALL_OW 76
50473: ST_TO_ADDR
50474: GO 50496
// result := SortListByListDesc ( units , tmp ) ;
50476: LD_ADDR_VAR 0 3
50480: PUSH
50481: LD_VAR 0 1
50485: PPUSH
50486: LD_VAR 0 5
50490: PPUSH
50491: CALL_OW 77
50495: ST_TO_ADDR
// end ;
50496: LD_VAR 0 3
50500: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50501: LD_INT 0
50503: PPUSH
50504: PPUSH
// task := GetTaskList ( mech ) ;
50505: LD_ADDR_VAR 0 4
50509: PUSH
50510: LD_VAR 0 1
50514: PPUSH
50515: CALL_OW 437
50519: ST_TO_ADDR
// if not task then
50520: LD_VAR 0 4
50524: NOT
50525: IFFALSE 50529
// exit ;
50527: GO 50571
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50529: LD_ADDR_VAR 0 3
50533: PUSH
50534: LD_VAR 0 4
50538: PUSH
50539: LD_INT 1
50541: ARRAY
50542: PUSH
50543: LD_INT 1
50545: ARRAY
50546: PUSH
50547: LD_STRING r
50549: EQUAL
50550: PUSH
50551: LD_VAR 0 4
50555: PUSH
50556: LD_INT 1
50558: ARRAY
50559: PUSH
50560: LD_INT 4
50562: ARRAY
50563: PUSH
50564: LD_VAR 0 2
50568: EQUAL
50569: AND
50570: ST_TO_ADDR
// end ;
50571: LD_VAR 0 3
50575: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50576: LD_INT 0
50578: PPUSH
// SetDir ( unit , d ) ;
50579: LD_VAR 0 1
50583: PPUSH
50584: LD_VAR 0 4
50588: PPUSH
50589: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50593: LD_VAR 0 1
50597: PPUSH
50598: LD_VAR 0 2
50602: PPUSH
50603: LD_VAR 0 3
50607: PPUSH
50608: LD_VAR 0 5
50612: PPUSH
50613: CALL_OW 48
// end ;
50617: LD_VAR 0 6
50621: RET
// export function ToNaturalNumber ( number ) ; begin
50622: LD_INT 0
50624: PPUSH
// result := number div 1 ;
50625: LD_ADDR_VAR 0 2
50629: PUSH
50630: LD_VAR 0 1
50634: PUSH
50635: LD_INT 1
50637: DIV
50638: ST_TO_ADDR
// if number < 0 then
50639: LD_VAR 0 1
50643: PUSH
50644: LD_INT 0
50646: LESS
50647: IFFALSE 50657
// result := 0 ;
50649: LD_ADDR_VAR 0 2
50653: PUSH
50654: LD_INT 0
50656: ST_TO_ADDR
// end ;
50657: LD_VAR 0 2
50661: RET
// export function SortByClass ( units , class ) ; var un ; begin
50662: LD_INT 0
50664: PPUSH
50665: PPUSH
// if not units or not class then
50666: LD_VAR 0 1
50670: NOT
50671: PUSH
50672: LD_VAR 0 2
50676: NOT
50677: OR
50678: IFFALSE 50682
// exit ;
50680: GO 50777
// result := [ ] ;
50682: LD_ADDR_VAR 0 3
50686: PUSH
50687: EMPTY
50688: ST_TO_ADDR
// for un in units do
50689: LD_ADDR_VAR 0 4
50693: PUSH
50694: LD_VAR 0 1
50698: PUSH
50699: FOR_IN
50700: IFFALSE 50775
// if GetClass ( un ) = class then
50702: LD_VAR 0 4
50706: PPUSH
50707: CALL_OW 257
50711: PUSH
50712: LD_VAR 0 2
50716: EQUAL
50717: IFFALSE 50744
// result := Insert ( result , 1 , un ) else
50719: LD_ADDR_VAR 0 3
50723: PUSH
50724: LD_VAR 0 3
50728: PPUSH
50729: LD_INT 1
50731: PPUSH
50732: LD_VAR 0 4
50736: PPUSH
50737: CALL_OW 2
50741: ST_TO_ADDR
50742: GO 50773
// result := Replace ( result , result + 1 , un ) ;
50744: LD_ADDR_VAR 0 3
50748: PUSH
50749: LD_VAR 0 3
50753: PPUSH
50754: LD_VAR 0 3
50758: PUSH
50759: LD_INT 1
50761: PLUS
50762: PPUSH
50763: LD_VAR 0 4
50767: PPUSH
50768: CALL_OW 1
50772: ST_TO_ADDR
50773: GO 50699
50775: POP
50776: POP
// end ;
50777: LD_VAR 0 3
50781: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50782: LD_INT 0
50784: PPUSH
50785: PPUSH
50786: PPUSH
50787: PPUSH
50788: PPUSH
50789: PPUSH
50790: PPUSH
// result := [ ] ;
50791: LD_ADDR_VAR 0 4
50795: PUSH
50796: EMPTY
50797: ST_TO_ADDR
// if x - r < 0 then
50798: LD_VAR 0 1
50802: PUSH
50803: LD_VAR 0 3
50807: MINUS
50808: PUSH
50809: LD_INT 0
50811: LESS
50812: IFFALSE 50824
// min_x := 0 else
50814: LD_ADDR_VAR 0 8
50818: PUSH
50819: LD_INT 0
50821: ST_TO_ADDR
50822: GO 50840
// min_x := x - r ;
50824: LD_ADDR_VAR 0 8
50828: PUSH
50829: LD_VAR 0 1
50833: PUSH
50834: LD_VAR 0 3
50838: MINUS
50839: ST_TO_ADDR
// if y - r < 0 then
50840: LD_VAR 0 2
50844: PUSH
50845: LD_VAR 0 3
50849: MINUS
50850: PUSH
50851: LD_INT 0
50853: LESS
50854: IFFALSE 50866
// min_y := 0 else
50856: LD_ADDR_VAR 0 7
50860: PUSH
50861: LD_INT 0
50863: ST_TO_ADDR
50864: GO 50882
// min_y := y - r ;
50866: LD_ADDR_VAR 0 7
50870: PUSH
50871: LD_VAR 0 2
50875: PUSH
50876: LD_VAR 0 3
50880: MINUS
50881: ST_TO_ADDR
// max_x := x + r ;
50882: LD_ADDR_VAR 0 9
50886: PUSH
50887: LD_VAR 0 1
50891: PUSH
50892: LD_VAR 0 3
50896: PLUS
50897: ST_TO_ADDR
// max_y := y + r ;
50898: LD_ADDR_VAR 0 10
50902: PUSH
50903: LD_VAR 0 2
50907: PUSH
50908: LD_VAR 0 3
50912: PLUS
50913: ST_TO_ADDR
// for _x = min_x to max_x do
50914: LD_ADDR_VAR 0 5
50918: PUSH
50919: DOUBLE
50920: LD_VAR 0 8
50924: DEC
50925: ST_TO_ADDR
50926: LD_VAR 0 9
50930: PUSH
50931: FOR_TO
50932: IFFALSE 51033
// for _y = min_y to max_y do
50934: LD_ADDR_VAR 0 6
50938: PUSH
50939: DOUBLE
50940: LD_VAR 0 7
50944: DEC
50945: ST_TO_ADDR
50946: LD_VAR 0 10
50950: PUSH
50951: FOR_TO
50952: IFFALSE 51029
// begin if not ValidHex ( _x , _y ) then
50954: LD_VAR 0 5
50958: PPUSH
50959: LD_VAR 0 6
50963: PPUSH
50964: CALL_OW 488
50968: NOT
50969: IFFALSE 50973
// continue ;
50971: GO 50951
// if GetResourceTypeXY ( _x , _y ) then
50973: LD_VAR 0 5
50977: PPUSH
50978: LD_VAR 0 6
50982: PPUSH
50983: CALL_OW 283
50987: IFFALSE 51027
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50989: LD_ADDR_VAR 0 4
50993: PUSH
50994: LD_VAR 0 4
50998: PPUSH
50999: LD_VAR 0 4
51003: PUSH
51004: LD_INT 1
51006: PLUS
51007: PPUSH
51008: LD_VAR 0 5
51012: PUSH
51013: LD_VAR 0 6
51017: PUSH
51018: EMPTY
51019: LIST
51020: LIST
51021: PPUSH
51022: CALL_OW 1
51026: ST_TO_ADDR
// end ;
51027: GO 50951
51029: POP
51030: POP
51031: GO 50931
51033: POP
51034: POP
// end ;
51035: LD_VAR 0 4
51039: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51040: LD_INT 0
51042: PPUSH
51043: PPUSH
51044: PPUSH
51045: PPUSH
51046: PPUSH
51047: PPUSH
51048: PPUSH
51049: PPUSH
// if not units then
51050: LD_VAR 0 1
51054: NOT
51055: IFFALSE 51059
// exit ;
51057: GO 51583
// result := UnitFilter ( units , [ f_ok ] ) ;
51059: LD_ADDR_VAR 0 3
51063: PUSH
51064: LD_VAR 0 1
51068: PPUSH
51069: LD_INT 50
51071: PUSH
51072: EMPTY
51073: LIST
51074: PPUSH
51075: CALL_OW 72
51079: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51080: LD_ADDR_VAR 0 8
51084: PUSH
51085: LD_VAR 0 1
51089: PUSH
51090: LD_INT 1
51092: ARRAY
51093: PPUSH
51094: CALL_OW 255
51098: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51099: LD_ADDR_VAR 0 10
51103: PUSH
51104: LD_INT 29
51106: PUSH
51107: LD_INT 91
51109: PUSH
51110: LD_INT 49
51112: PUSH
51113: EMPTY
51114: LIST
51115: LIST
51116: LIST
51117: ST_TO_ADDR
// if not result then
51118: LD_VAR 0 3
51122: NOT
51123: IFFALSE 51127
// exit ;
51125: GO 51583
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51127: LD_ADDR_VAR 0 5
51131: PUSH
51132: LD_INT 81
51134: PUSH
51135: LD_VAR 0 8
51139: PUSH
51140: EMPTY
51141: LIST
51142: LIST
51143: PPUSH
51144: CALL_OW 69
51148: ST_TO_ADDR
// for i in result do
51149: LD_ADDR_VAR 0 4
51153: PUSH
51154: LD_VAR 0 3
51158: PUSH
51159: FOR_IN
51160: IFFALSE 51581
// begin tag := GetTag ( i ) + 1 ;
51162: LD_ADDR_VAR 0 9
51166: PUSH
51167: LD_VAR 0 4
51171: PPUSH
51172: CALL_OW 110
51176: PUSH
51177: LD_INT 1
51179: PLUS
51180: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51181: LD_ADDR_VAR 0 7
51185: PUSH
51186: LD_VAR 0 4
51190: PPUSH
51191: CALL_OW 250
51195: PPUSH
51196: LD_VAR 0 4
51200: PPUSH
51201: CALL_OW 251
51205: PPUSH
51206: LD_INT 6
51208: PPUSH
51209: CALL 50782 0 3
51213: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51214: LD_VAR 0 4
51218: PPUSH
51219: CALL_OW 247
51223: PUSH
51224: LD_INT 2
51226: EQUAL
51227: PUSH
51228: LD_VAR 0 7
51232: AND
51233: PUSH
51234: LD_VAR 0 4
51238: PPUSH
51239: CALL_OW 264
51243: PUSH
51244: LD_VAR 0 10
51248: IN
51249: NOT
51250: AND
51251: IFFALSE 51290
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51253: LD_VAR 0 4
51257: PPUSH
51258: LD_VAR 0 7
51262: PUSH
51263: LD_INT 1
51265: ARRAY
51266: PUSH
51267: LD_INT 1
51269: ARRAY
51270: PPUSH
51271: LD_VAR 0 7
51275: PUSH
51276: LD_INT 1
51278: ARRAY
51279: PUSH
51280: LD_INT 2
51282: ARRAY
51283: PPUSH
51284: CALL_OW 116
51288: GO 51579
// if path > tag then
51290: LD_VAR 0 2
51294: PUSH
51295: LD_VAR 0 9
51299: GREATER
51300: IFFALSE 51508
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51302: LD_ADDR_VAR 0 6
51306: PUSH
51307: LD_VAR 0 5
51311: PPUSH
51312: LD_INT 91
51314: PUSH
51315: LD_VAR 0 4
51319: PUSH
51320: LD_INT 8
51322: PUSH
51323: EMPTY
51324: LIST
51325: LIST
51326: LIST
51327: PPUSH
51328: CALL_OW 72
51332: ST_TO_ADDR
// if nearEnemy then
51333: LD_VAR 0 6
51337: IFFALSE 51406
// begin if GetWeapon ( i ) = ru_time_lapser then
51339: LD_VAR 0 4
51343: PPUSH
51344: CALL_OW 264
51348: PUSH
51349: LD_INT 49
51351: EQUAL
51352: IFFALSE 51380
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51354: LD_VAR 0 4
51358: PPUSH
51359: LD_VAR 0 6
51363: PPUSH
51364: LD_VAR 0 4
51368: PPUSH
51369: CALL_OW 74
51373: PPUSH
51374: CALL_OW 112
51378: GO 51404
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51380: LD_VAR 0 4
51384: PPUSH
51385: LD_VAR 0 6
51389: PPUSH
51390: LD_VAR 0 4
51394: PPUSH
51395: CALL_OW 74
51399: PPUSH
51400: CALL 52508 0 2
// end else
51404: GO 51506
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51406: LD_VAR 0 4
51410: PPUSH
51411: LD_VAR 0 2
51415: PUSH
51416: LD_VAR 0 9
51420: ARRAY
51421: PUSH
51422: LD_INT 1
51424: ARRAY
51425: PPUSH
51426: LD_VAR 0 2
51430: PUSH
51431: LD_VAR 0 9
51435: ARRAY
51436: PUSH
51437: LD_INT 2
51439: ARRAY
51440: PPUSH
51441: CALL_OW 297
51445: PUSH
51446: LD_INT 6
51448: GREATER
51449: IFFALSE 51492
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51451: LD_VAR 0 4
51455: PPUSH
51456: LD_VAR 0 2
51460: PUSH
51461: LD_VAR 0 9
51465: ARRAY
51466: PUSH
51467: LD_INT 1
51469: ARRAY
51470: PPUSH
51471: LD_VAR 0 2
51475: PUSH
51476: LD_VAR 0 9
51480: ARRAY
51481: PUSH
51482: LD_INT 2
51484: ARRAY
51485: PPUSH
51486: CALL_OW 114
51490: GO 51506
// SetTag ( i , tag ) ;
51492: LD_VAR 0 4
51496: PPUSH
51497: LD_VAR 0 9
51501: PPUSH
51502: CALL_OW 109
// end else
51506: GO 51579
// if enemy then
51508: LD_VAR 0 5
51512: IFFALSE 51579
// begin if GetWeapon ( i ) = ru_time_lapser then
51514: LD_VAR 0 4
51518: PPUSH
51519: CALL_OW 264
51523: PUSH
51524: LD_INT 49
51526: EQUAL
51527: IFFALSE 51555
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51529: LD_VAR 0 4
51533: PPUSH
51534: LD_VAR 0 5
51538: PPUSH
51539: LD_VAR 0 4
51543: PPUSH
51544: CALL_OW 74
51548: PPUSH
51549: CALL_OW 112
51553: GO 51579
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51555: LD_VAR 0 4
51559: PPUSH
51560: LD_VAR 0 5
51564: PPUSH
51565: LD_VAR 0 4
51569: PPUSH
51570: CALL_OW 74
51574: PPUSH
51575: CALL 52508 0 2
// end ; end ;
51579: GO 51159
51581: POP
51582: POP
// end ;
51583: LD_VAR 0 3
51587: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51588: LD_INT 0
51590: PPUSH
51591: PPUSH
51592: PPUSH
// if not unit or IsInUnit ( unit ) then
51593: LD_VAR 0 1
51597: NOT
51598: PUSH
51599: LD_VAR 0 1
51603: PPUSH
51604: CALL_OW 310
51608: OR
51609: IFFALSE 51613
// exit ;
51611: GO 51704
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51613: LD_ADDR_VAR 0 4
51617: PUSH
51618: LD_VAR 0 1
51622: PPUSH
51623: CALL_OW 250
51627: PPUSH
51628: LD_VAR 0 2
51632: PPUSH
51633: LD_INT 1
51635: PPUSH
51636: CALL_OW 272
51640: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
51641: LD_ADDR_VAR 0 5
51645: PUSH
51646: LD_VAR 0 1
51650: PPUSH
51651: CALL_OW 251
51655: PPUSH
51656: LD_VAR 0 2
51660: PPUSH
51661: LD_INT 1
51663: PPUSH
51664: CALL_OW 273
51668: ST_TO_ADDR
// if ValidHex ( x , y ) then
51669: LD_VAR 0 4
51673: PPUSH
51674: LD_VAR 0 5
51678: PPUSH
51679: CALL_OW 488
51683: IFFALSE 51704
// ComTurnXY ( unit , x , y ) ;
51685: LD_VAR 0 1
51689: PPUSH
51690: LD_VAR 0 4
51694: PPUSH
51695: LD_VAR 0 5
51699: PPUSH
51700: CALL_OW 118
// end ;
51704: LD_VAR 0 3
51708: RET
// export function SeeUnits ( side , units ) ; var i ; begin
51709: LD_INT 0
51711: PPUSH
51712: PPUSH
// result := false ;
51713: LD_ADDR_VAR 0 3
51717: PUSH
51718: LD_INT 0
51720: ST_TO_ADDR
// if not units then
51721: LD_VAR 0 2
51725: NOT
51726: IFFALSE 51730
// exit ;
51728: GO 51775
// for i in units do
51730: LD_ADDR_VAR 0 4
51734: PUSH
51735: LD_VAR 0 2
51739: PUSH
51740: FOR_IN
51741: IFFALSE 51773
// if See ( side , i ) then
51743: LD_VAR 0 1
51747: PPUSH
51748: LD_VAR 0 4
51752: PPUSH
51753: CALL_OW 292
51757: IFFALSE 51771
// begin result := true ;
51759: LD_ADDR_VAR 0 3
51763: PUSH
51764: LD_INT 1
51766: ST_TO_ADDR
// exit ;
51767: POP
51768: POP
51769: GO 51775
// end ;
51771: GO 51740
51773: POP
51774: POP
// end ;
51775: LD_VAR 0 3
51779: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
51780: LD_INT 0
51782: PPUSH
51783: PPUSH
51784: PPUSH
51785: PPUSH
// if not unit or not points then
51786: LD_VAR 0 1
51790: NOT
51791: PUSH
51792: LD_VAR 0 2
51796: NOT
51797: OR
51798: IFFALSE 51802
// exit ;
51800: GO 51892
// dist := 99999 ;
51802: LD_ADDR_VAR 0 5
51806: PUSH
51807: LD_INT 99999
51809: ST_TO_ADDR
// for i in points do
51810: LD_ADDR_VAR 0 4
51814: PUSH
51815: LD_VAR 0 2
51819: PUSH
51820: FOR_IN
51821: IFFALSE 51890
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51823: LD_ADDR_VAR 0 6
51827: PUSH
51828: LD_VAR 0 1
51832: PPUSH
51833: LD_VAR 0 4
51837: PUSH
51838: LD_INT 1
51840: ARRAY
51841: PPUSH
51842: LD_VAR 0 4
51846: PUSH
51847: LD_INT 2
51849: ARRAY
51850: PPUSH
51851: CALL_OW 297
51855: ST_TO_ADDR
// if tmpDist < dist then
51856: LD_VAR 0 6
51860: PUSH
51861: LD_VAR 0 5
51865: LESS
51866: IFFALSE 51888
// begin result := i ;
51868: LD_ADDR_VAR 0 3
51872: PUSH
51873: LD_VAR 0 4
51877: ST_TO_ADDR
// dist := tmpDist ;
51878: LD_ADDR_VAR 0 5
51882: PUSH
51883: LD_VAR 0 6
51887: ST_TO_ADDR
// end ; end ;
51888: GO 51820
51890: POP
51891: POP
// end ;
51892: LD_VAR 0 3
51896: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
51897: LD_INT 0
51899: PPUSH
// uc_side := side ;
51900: LD_ADDR_OWVAR 20
51904: PUSH
51905: LD_VAR 0 1
51909: ST_TO_ADDR
// uc_nation := 3 ;
51910: LD_ADDR_OWVAR 21
51914: PUSH
51915: LD_INT 3
51917: ST_TO_ADDR
// vc_chassis := 25 ;
51918: LD_ADDR_OWVAR 37
51922: PUSH
51923: LD_INT 25
51925: ST_TO_ADDR
// vc_engine := engine_siberite ;
51926: LD_ADDR_OWVAR 39
51930: PUSH
51931: LD_INT 3
51933: ST_TO_ADDR
// vc_control := control_computer ;
51934: LD_ADDR_OWVAR 38
51938: PUSH
51939: LD_INT 3
51941: ST_TO_ADDR
// vc_weapon := 59 ;
51942: LD_ADDR_OWVAR 40
51946: PUSH
51947: LD_INT 59
51949: ST_TO_ADDR
// result := CreateVehicle ;
51950: LD_ADDR_VAR 0 5
51954: PUSH
51955: CALL_OW 45
51959: ST_TO_ADDR
// SetDir ( result , d ) ;
51960: LD_VAR 0 5
51964: PPUSH
51965: LD_VAR 0 4
51969: PPUSH
51970: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
51974: LD_VAR 0 5
51978: PPUSH
51979: LD_VAR 0 2
51983: PPUSH
51984: LD_VAR 0 3
51988: PPUSH
51989: LD_INT 0
51991: PPUSH
51992: CALL_OW 48
// end ;
51996: LD_VAR 0 5
52000: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
52001: LD_INT 0
52003: PPUSH
52004: PPUSH
52005: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
52006: LD_ADDR_VAR 0 2
52010: PUSH
52011: LD_INT 0
52013: PUSH
52014: LD_INT 0
52016: PUSH
52017: LD_INT 0
52019: PUSH
52020: LD_INT 0
52022: PUSH
52023: EMPTY
52024: LIST
52025: LIST
52026: LIST
52027: LIST
52028: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52029: LD_VAR 0 1
52033: NOT
52034: PUSH
52035: LD_VAR 0 1
52039: PPUSH
52040: CALL_OW 264
52044: PUSH
52045: LD_INT 12
52047: PUSH
52048: LD_INT 51
52050: PUSH
52051: LD_INT 32
52053: PUSH
52054: LD_INT 89
52056: PUSH
52057: EMPTY
52058: LIST
52059: LIST
52060: LIST
52061: LIST
52062: IN
52063: NOT
52064: OR
52065: IFFALSE 52069
// exit ;
52067: GO 52167
// for i := 1 to 3 do
52069: LD_ADDR_VAR 0 3
52073: PUSH
52074: DOUBLE
52075: LD_INT 1
52077: DEC
52078: ST_TO_ADDR
52079: LD_INT 3
52081: PUSH
52082: FOR_TO
52083: IFFALSE 52165
// begin tmp := GetCargo ( cargo , i ) ;
52085: LD_ADDR_VAR 0 4
52089: PUSH
52090: LD_VAR 0 1
52094: PPUSH
52095: LD_VAR 0 3
52099: PPUSH
52100: CALL_OW 289
52104: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52105: LD_ADDR_VAR 0 2
52109: PUSH
52110: LD_VAR 0 2
52114: PPUSH
52115: LD_VAR 0 3
52119: PPUSH
52120: LD_VAR 0 4
52124: PPUSH
52125: CALL_OW 1
52129: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52130: LD_ADDR_VAR 0 2
52134: PUSH
52135: LD_VAR 0 2
52139: PPUSH
52140: LD_INT 4
52142: PPUSH
52143: LD_VAR 0 2
52147: PUSH
52148: LD_INT 4
52150: ARRAY
52151: PUSH
52152: LD_VAR 0 4
52156: PLUS
52157: PPUSH
52158: CALL_OW 1
52162: ST_TO_ADDR
// end ;
52163: GO 52082
52165: POP
52166: POP
// end ;
52167: LD_VAR 0 2
52171: RET
// export function Length ( array ) ; begin
52172: LD_INT 0
52174: PPUSH
// result := array + 0 ;
52175: LD_ADDR_VAR 0 2
52179: PUSH
52180: LD_VAR 0 1
52184: PUSH
52185: LD_INT 0
52187: PLUS
52188: ST_TO_ADDR
// end ;
52189: LD_VAR 0 2
52193: RET
// export function PrepareArray ( array ) ; begin
52194: LD_INT 0
52196: PPUSH
// result := array diff 0 ;
52197: LD_ADDR_VAR 0 2
52201: PUSH
52202: LD_VAR 0 1
52206: PUSH
52207: LD_INT 0
52209: DIFF
52210: ST_TO_ADDR
// if not result [ 1 ] then
52211: LD_VAR 0 2
52215: PUSH
52216: LD_INT 1
52218: ARRAY
52219: NOT
52220: IFFALSE 52240
// result := Delete ( result , 1 ) ;
52222: LD_ADDR_VAR 0 2
52226: PUSH
52227: LD_VAR 0 2
52231: PPUSH
52232: LD_INT 1
52234: PPUSH
52235: CALL_OW 3
52239: ST_TO_ADDR
// end ;
52240: LD_VAR 0 2
52244: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
52245: LD_INT 0
52247: PPUSH
52248: PPUSH
52249: PPUSH
52250: PPUSH
// sibRocketRange := 25 ;
52251: LD_ADDR_VAR 0 6
52255: PUSH
52256: LD_INT 25
52258: ST_TO_ADDR
// result := false ;
52259: LD_ADDR_VAR 0 4
52263: PUSH
52264: LD_INT 0
52266: ST_TO_ADDR
// for i := 0 to 5 do
52267: LD_ADDR_VAR 0 5
52271: PUSH
52272: DOUBLE
52273: LD_INT 0
52275: DEC
52276: ST_TO_ADDR
52277: LD_INT 5
52279: PUSH
52280: FOR_TO
52281: IFFALSE 52348
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
52283: LD_VAR 0 1
52287: PPUSH
52288: LD_VAR 0 5
52292: PPUSH
52293: LD_VAR 0 6
52297: PPUSH
52298: CALL_OW 272
52302: PPUSH
52303: LD_VAR 0 2
52307: PPUSH
52308: LD_VAR 0 5
52312: PPUSH
52313: LD_VAR 0 6
52317: PPUSH
52318: CALL_OW 273
52322: PPUSH
52323: LD_VAR 0 3
52327: PPUSH
52328: CALL_OW 309
52332: IFFALSE 52346
// begin result := true ;
52334: LD_ADDR_VAR 0 4
52338: PUSH
52339: LD_INT 1
52341: ST_TO_ADDR
// exit ;
52342: POP
52343: POP
52344: GO 52350
// end ;
52346: GO 52280
52348: POP
52349: POP
// end ;
52350: LD_VAR 0 4
52354: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
52355: LD_INT 0
52357: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
52358: LD_VAR 0 1
52362: PPUSH
52363: LD_VAR 0 2
52367: PPUSH
52368: LD_INT 0
52370: PPUSH
52371: LD_INT 0
52373: PPUSH
52374: LD_INT 1
52376: PPUSH
52377: LD_INT 0
52379: PPUSH
52380: CALL_OW 587
// end ;
52384: LD_VAR 0 3
52388: RET
// export function CenterOnNow ( unit ) ; begin
52389: LD_INT 0
52391: PPUSH
// result := IsInUnit ( unit ) ;
52392: LD_ADDR_VAR 0 2
52396: PUSH
52397: LD_VAR 0 1
52401: PPUSH
52402: CALL_OW 310
52406: ST_TO_ADDR
// if not result then
52407: LD_VAR 0 2
52411: NOT
52412: IFFALSE 52424
// result := unit ;
52414: LD_ADDR_VAR 0 2
52418: PUSH
52419: LD_VAR 0 1
52423: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
52424: LD_VAR 0 1
52428: PPUSH
52429: CALL_OW 87
// end ;
52433: LD_VAR 0 2
52437: RET
// export function ComMoveHex ( unit , hex ) ; begin
52438: LD_INT 0
52440: PPUSH
// if not hex then
52441: LD_VAR 0 2
52445: NOT
52446: IFFALSE 52450
// exit ;
52448: GO 52503
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
52450: LD_VAR 0 2
52454: PUSH
52455: LD_INT 1
52457: ARRAY
52458: PPUSH
52459: LD_VAR 0 2
52463: PUSH
52464: LD_INT 2
52466: ARRAY
52467: PPUSH
52468: CALL_OW 428
52472: IFFALSE 52476
// exit ;
52474: GO 52503
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
52476: LD_VAR 0 1
52480: PPUSH
52481: LD_VAR 0 2
52485: PUSH
52486: LD_INT 1
52488: ARRAY
52489: PPUSH
52490: LD_VAR 0 2
52494: PUSH
52495: LD_INT 2
52497: ARRAY
52498: PPUSH
52499: CALL_OW 111
// end ;
52503: LD_VAR 0 3
52507: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
52508: LD_INT 0
52510: PPUSH
52511: PPUSH
52512: PPUSH
// if not unit or not enemy then
52513: LD_VAR 0 1
52517: NOT
52518: PUSH
52519: LD_VAR 0 2
52523: NOT
52524: OR
52525: IFFALSE 52529
// exit ;
52527: GO 52653
// x := GetX ( enemy ) ;
52529: LD_ADDR_VAR 0 4
52533: PUSH
52534: LD_VAR 0 2
52538: PPUSH
52539: CALL_OW 250
52543: ST_TO_ADDR
// y := GetY ( enemy ) ;
52544: LD_ADDR_VAR 0 5
52548: PUSH
52549: LD_VAR 0 2
52553: PPUSH
52554: CALL_OW 251
52558: ST_TO_ADDR
// if ValidHex ( x , y ) then
52559: LD_VAR 0 4
52563: PPUSH
52564: LD_VAR 0 5
52568: PPUSH
52569: CALL_OW 488
52573: IFFALSE 52653
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
52575: LD_VAR 0 2
52579: PPUSH
52580: CALL_OW 247
52584: PUSH
52585: LD_INT 3
52587: PUSH
52588: LD_INT 2
52590: PUSH
52591: EMPTY
52592: LIST
52593: LIST
52594: IN
52595: PUSH
52596: LD_VAR 0 1
52600: PPUSH
52601: CALL_OW 255
52605: PPUSH
52606: LD_VAR 0 2
52610: PPUSH
52611: CALL_OW 292
52615: AND
52616: IFFALSE 52634
// ComAttackUnit ( unit , enemy ) else
52618: LD_VAR 0 1
52622: PPUSH
52623: LD_VAR 0 2
52627: PPUSH
52628: CALL_OW 115
52632: GO 52653
// ComAgressiveMove ( unit , x , y ) ;
52634: LD_VAR 0 1
52638: PPUSH
52639: LD_VAR 0 4
52643: PPUSH
52644: LD_VAR 0 5
52648: PPUSH
52649: CALL_OW 114
// end ; end_of_file
52653: LD_VAR 0 3
52657: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
52658: LD_INT 0
52660: PPUSH
52661: PPUSH
// skirmish := false ;
52662: LD_ADDR_EXP 21
52666: PUSH
52667: LD_INT 0
52669: ST_TO_ADDR
// debug_mc := false ;
52670: LD_ADDR_EXP 22
52674: PUSH
52675: LD_INT 0
52677: ST_TO_ADDR
// mc_bases := [ ] ;
52678: LD_ADDR_EXP 23
52682: PUSH
52683: EMPTY
52684: ST_TO_ADDR
// mc_sides := [ ] ;
52685: LD_ADDR_EXP 49
52689: PUSH
52690: EMPTY
52691: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52692: LD_ADDR_EXP 24
52696: PUSH
52697: EMPTY
52698: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52699: LD_ADDR_EXP 25
52703: PUSH
52704: EMPTY
52705: ST_TO_ADDR
// mc_need_heal := [ ] ;
52706: LD_ADDR_EXP 26
52710: PUSH
52711: EMPTY
52712: ST_TO_ADDR
// mc_healers := [ ] ;
52713: LD_ADDR_EXP 27
52717: PUSH
52718: EMPTY
52719: ST_TO_ADDR
// mc_build_list := [ ] ;
52720: LD_ADDR_EXP 28
52724: PUSH
52725: EMPTY
52726: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52727: LD_ADDR_EXP 55
52731: PUSH
52732: EMPTY
52733: ST_TO_ADDR
// mc_builders := [ ] ;
52734: LD_ADDR_EXP 29
52738: PUSH
52739: EMPTY
52740: ST_TO_ADDR
// mc_construct_list := [ ] ;
52741: LD_ADDR_EXP 30
52745: PUSH
52746: EMPTY
52747: ST_TO_ADDR
// mc_turret_list := [ ] ;
52748: LD_ADDR_EXP 31
52752: PUSH
52753: EMPTY
52754: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52755: LD_ADDR_EXP 32
52759: PUSH
52760: EMPTY
52761: ST_TO_ADDR
// mc_miners := [ ] ;
52762: LD_ADDR_EXP 37
52766: PUSH
52767: EMPTY
52768: ST_TO_ADDR
// mc_mines := [ ] ;
52769: LD_ADDR_EXP 36
52773: PUSH
52774: EMPTY
52775: ST_TO_ADDR
// mc_minefields := [ ] ;
52776: LD_ADDR_EXP 38
52780: PUSH
52781: EMPTY
52782: ST_TO_ADDR
// mc_crates := [ ] ;
52783: LD_ADDR_EXP 39
52787: PUSH
52788: EMPTY
52789: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52790: LD_ADDR_EXP 40
52794: PUSH
52795: EMPTY
52796: ST_TO_ADDR
// mc_crates_area := [ ] ;
52797: LD_ADDR_EXP 41
52801: PUSH
52802: EMPTY
52803: ST_TO_ADDR
// mc_vehicles := [ ] ;
52804: LD_ADDR_EXP 42
52808: PUSH
52809: EMPTY
52810: ST_TO_ADDR
// mc_attack := [ ] ;
52811: LD_ADDR_EXP 43
52815: PUSH
52816: EMPTY
52817: ST_TO_ADDR
// mc_produce := [ ] ;
52818: LD_ADDR_EXP 44
52822: PUSH
52823: EMPTY
52824: ST_TO_ADDR
// mc_defender := [ ] ;
52825: LD_ADDR_EXP 45
52829: PUSH
52830: EMPTY
52831: ST_TO_ADDR
// mc_parking := [ ] ;
52832: LD_ADDR_EXP 47
52836: PUSH
52837: EMPTY
52838: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52839: LD_ADDR_EXP 33
52843: PUSH
52844: EMPTY
52845: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52846: LD_ADDR_EXP 35
52850: PUSH
52851: EMPTY
52852: ST_TO_ADDR
// mc_scan := [ ] ;
52853: LD_ADDR_EXP 46
52857: PUSH
52858: EMPTY
52859: ST_TO_ADDR
// mc_scan_area := [ ] ;
52860: LD_ADDR_EXP 48
52864: PUSH
52865: EMPTY
52866: ST_TO_ADDR
// mc_tech := [ ] ;
52867: LD_ADDR_EXP 50
52871: PUSH
52872: EMPTY
52873: ST_TO_ADDR
// mc_class := [ ] ;
52874: LD_ADDR_EXP 64
52878: PUSH
52879: EMPTY
52880: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52881: LD_ADDR_EXP 65
52885: PUSH
52886: EMPTY
52887: ST_TO_ADDR
// mc_is_defending := [ ] ;
52888: LD_ADDR_EXP 66
52892: PUSH
52893: EMPTY
52894: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
52895: LD_ADDR_EXP 57
52899: PUSH
52900: EMPTY
52901: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
52902: LD_ADDR_EXP 67
52906: PUSH
52907: LD_INT 0
52909: ST_TO_ADDR
// end ;
52910: LD_VAR 0 1
52914: RET
// export function MC_Kill ( base ) ; begin
52915: LD_INT 0
52917: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52918: LD_ADDR_EXP 23
52922: PUSH
52923: LD_EXP 23
52927: PPUSH
52928: LD_VAR 0 1
52932: PPUSH
52933: EMPTY
52934: PPUSH
52935: CALL_OW 1
52939: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52940: LD_ADDR_EXP 24
52944: PUSH
52945: LD_EXP 24
52949: PPUSH
52950: LD_VAR 0 1
52954: PPUSH
52955: EMPTY
52956: PPUSH
52957: CALL_OW 1
52961: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52962: LD_ADDR_EXP 25
52966: PUSH
52967: LD_EXP 25
52971: PPUSH
52972: LD_VAR 0 1
52976: PPUSH
52977: EMPTY
52978: PPUSH
52979: CALL_OW 1
52983: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52984: LD_ADDR_EXP 26
52988: PUSH
52989: LD_EXP 26
52993: PPUSH
52994: LD_VAR 0 1
52998: PPUSH
52999: EMPTY
53000: PPUSH
53001: CALL_OW 1
53005: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53006: LD_ADDR_EXP 27
53010: PUSH
53011: LD_EXP 27
53015: PPUSH
53016: LD_VAR 0 1
53020: PPUSH
53021: EMPTY
53022: PPUSH
53023: CALL_OW 1
53027: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53028: LD_ADDR_EXP 28
53032: PUSH
53033: LD_EXP 28
53037: PPUSH
53038: LD_VAR 0 1
53042: PPUSH
53043: EMPTY
53044: PPUSH
53045: CALL_OW 1
53049: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53050: LD_ADDR_EXP 29
53054: PUSH
53055: LD_EXP 29
53059: PPUSH
53060: LD_VAR 0 1
53064: PPUSH
53065: EMPTY
53066: PPUSH
53067: CALL_OW 1
53071: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53072: LD_ADDR_EXP 30
53076: PUSH
53077: LD_EXP 30
53081: PPUSH
53082: LD_VAR 0 1
53086: PPUSH
53087: EMPTY
53088: PPUSH
53089: CALL_OW 1
53093: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53094: LD_ADDR_EXP 31
53098: PUSH
53099: LD_EXP 31
53103: PPUSH
53104: LD_VAR 0 1
53108: PPUSH
53109: EMPTY
53110: PPUSH
53111: CALL_OW 1
53115: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53116: LD_ADDR_EXP 32
53120: PUSH
53121: LD_EXP 32
53125: PPUSH
53126: LD_VAR 0 1
53130: PPUSH
53131: EMPTY
53132: PPUSH
53133: CALL_OW 1
53137: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53138: LD_ADDR_EXP 33
53142: PUSH
53143: LD_EXP 33
53147: PPUSH
53148: LD_VAR 0 1
53152: PPUSH
53153: EMPTY
53154: PPUSH
53155: CALL_OW 1
53159: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53160: LD_ADDR_EXP 34
53164: PUSH
53165: LD_EXP 34
53169: PPUSH
53170: LD_VAR 0 1
53174: PPUSH
53175: LD_INT 0
53177: PPUSH
53178: CALL_OW 1
53182: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53183: LD_ADDR_EXP 35
53187: PUSH
53188: LD_EXP 35
53192: PPUSH
53193: LD_VAR 0 1
53197: PPUSH
53198: EMPTY
53199: PPUSH
53200: CALL_OW 1
53204: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53205: LD_ADDR_EXP 36
53209: PUSH
53210: LD_EXP 36
53214: PPUSH
53215: LD_VAR 0 1
53219: PPUSH
53220: EMPTY
53221: PPUSH
53222: CALL_OW 1
53226: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53227: LD_ADDR_EXP 37
53231: PUSH
53232: LD_EXP 37
53236: PPUSH
53237: LD_VAR 0 1
53241: PPUSH
53242: EMPTY
53243: PPUSH
53244: CALL_OW 1
53248: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53249: LD_ADDR_EXP 38
53253: PUSH
53254: LD_EXP 38
53258: PPUSH
53259: LD_VAR 0 1
53263: PPUSH
53264: EMPTY
53265: PPUSH
53266: CALL_OW 1
53270: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53271: LD_ADDR_EXP 39
53275: PUSH
53276: LD_EXP 39
53280: PPUSH
53281: LD_VAR 0 1
53285: PPUSH
53286: EMPTY
53287: PPUSH
53288: CALL_OW 1
53292: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53293: LD_ADDR_EXP 40
53297: PUSH
53298: LD_EXP 40
53302: PPUSH
53303: LD_VAR 0 1
53307: PPUSH
53308: EMPTY
53309: PPUSH
53310: CALL_OW 1
53314: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53315: LD_ADDR_EXP 41
53319: PUSH
53320: LD_EXP 41
53324: PPUSH
53325: LD_VAR 0 1
53329: PPUSH
53330: EMPTY
53331: PPUSH
53332: CALL_OW 1
53336: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53337: LD_ADDR_EXP 42
53341: PUSH
53342: LD_EXP 42
53346: PPUSH
53347: LD_VAR 0 1
53351: PPUSH
53352: EMPTY
53353: PPUSH
53354: CALL_OW 1
53358: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53359: LD_ADDR_EXP 43
53363: PUSH
53364: LD_EXP 43
53368: PPUSH
53369: LD_VAR 0 1
53373: PPUSH
53374: EMPTY
53375: PPUSH
53376: CALL_OW 1
53380: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53381: LD_ADDR_EXP 44
53385: PUSH
53386: LD_EXP 44
53390: PPUSH
53391: LD_VAR 0 1
53395: PPUSH
53396: EMPTY
53397: PPUSH
53398: CALL_OW 1
53402: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53403: LD_ADDR_EXP 45
53407: PUSH
53408: LD_EXP 45
53412: PPUSH
53413: LD_VAR 0 1
53417: PPUSH
53418: EMPTY
53419: PPUSH
53420: CALL_OW 1
53424: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53425: LD_ADDR_EXP 46
53429: PUSH
53430: LD_EXP 46
53434: PPUSH
53435: LD_VAR 0 1
53439: PPUSH
53440: EMPTY
53441: PPUSH
53442: CALL_OW 1
53446: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53447: LD_ADDR_EXP 47
53451: PUSH
53452: LD_EXP 47
53456: PPUSH
53457: LD_VAR 0 1
53461: PPUSH
53462: EMPTY
53463: PPUSH
53464: CALL_OW 1
53468: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53469: LD_ADDR_EXP 48
53473: PUSH
53474: LD_EXP 48
53478: PPUSH
53479: LD_VAR 0 1
53483: PPUSH
53484: EMPTY
53485: PPUSH
53486: CALL_OW 1
53490: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53491: LD_ADDR_EXP 50
53495: PUSH
53496: LD_EXP 50
53500: PPUSH
53501: LD_VAR 0 1
53505: PPUSH
53506: EMPTY
53507: PPUSH
53508: CALL_OW 1
53512: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53513: LD_ADDR_EXP 52
53517: PUSH
53518: LD_EXP 52
53522: PPUSH
53523: LD_VAR 0 1
53527: PPUSH
53528: EMPTY
53529: PPUSH
53530: CALL_OW 1
53534: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53535: LD_ADDR_EXP 53
53539: PUSH
53540: LD_EXP 53
53544: PPUSH
53545: LD_VAR 0 1
53549: PPUSH
53550: EMPTY
53551: PPUSH
53552: CALL_OW 1
53556: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53557: LD_ADDR_EXP 54
53561: PUSH
53562: LD_EXP 54
53566: PPUSH
53567: LD_VAR 0 1
53571: PPUSH
53572: EMPTY
53573: PPUSH
53574: CALL_OW 1
53578: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53579: LD_ADDR_EXP 55
53583: PUSH
53584: LD_EXP 55
53588: PPUSH
53589: LD_VAR 0 1
53593: PPUSH
53594: EMPTY
53595: PPUSH
53596: CALL_OW 1
53600: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53601: LD_ADDR_EXP 56
53605: PUSH
53606: LD_EXP 56
53610: PPUSH
53611: LD_VAR 0 1
53615: PPUSH
53616: EMPTY
53617: PPUSH
53618: CALL_OW 1
53622: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53623: LD_ADDR_EXP 57
53627: PUSH
53628: LD_EXP 57
53632: PPUSH
53633: LD_VAR 0 1
53637: PPUSH
53638: EMPTY
53639: PPUSH
53640: CALL_OW 1
53644: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53645: LD_ADDR_EXP 58
53649: PUSH
53650: LD_EXP 58
53654: PPUSH
53655: LD_VAR 0 1
53659: PPUSH
53660: EMPTY
53661: PPUSH
53662: CALL_OW 1
53666: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53667: LD_ADDR_EXP 59
53671: PUSH
53672: LD_EXP 59
53676: PPUSH
53677: LD_VAR 0 1
53681: PPUSH
53682: EMPTY
53683: PPUSH
53684: CALL_OW 1
53688: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53689: LD_ADDR_EXP 60
53693: PUSH
53694: LD_EXP 60
53698: PPUSH
53699: LD_VAR 0 1
53703: PPUSH
53704: EMPTY
53705: PPUSH
53706: CALL_OW 1
53710: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53711: LD_ADDR_EXP 61
53715: PUSH
53716: LD_EXP 61
53720: PPUSH
53721: LD_VAR 0 1
53725: PPUSH
53726: EMPTY
53727: PPUSH
53728: CALL_OW 1
53732: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53733: LD_ADDR_EXP 62
53737: PUSH
53738: LD_EXP 62
53742: PPUSH
53743: LD_VAR 0 1
53747: PPUSH
53748: EMPTY
53749: PPUSH
53750: CALL_OW 1
53754: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53755: LD_ADDR_EXP 63
53759: PUSH
53760: LD_EXP 63
53764: PPUSH
53765: LD_VAR 0 1
53769: PPUSH
53770: EMPTY
53771: PPUSH
53772: CALL_OW 1
53776: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53777: LD_ADDR_EXP 64
53781: PUSH
53782: LD_EXP 64
53786: PPUSH
53787: LD_VAR 0 1
53791: PPUSH
53792: EMPTY
53793: PPUSH
53794: CALL_OW 1
53798: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53799: LD_ADDR_EXP 65
53803: PUSH
53804: LD_EXP 65
53808: PPUSH
53809: LD_VAR 0 1
53813: PPUSH
53814: LD_INT 0
53816: PPUSH
53817: CALL_OW 1
53821: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53822: LD_ADDR_EXP 66
53826: PUSH
53827: LD_EXP 66
53831: PPUSH
53832: LD_VAR 0 1
53836: PPUSH
53837: LD_INT 0
53839: PPUSH
53840: CALL_OW 1
53844: ST_TO_ADDR
// end ;
53845: LD_VAR 0 2
53849: RET
// export function MC_Add ( side , units ) ; var base ; begin
53850: LD_INT 0
53852: PPUSH
53853: PPUSH
// base := mc_bases + 1 ;
53854: LD_ADDR_VAR 0 4
53858: PUSH
53859: LD_EXP 23
53863: PUSH
53864: LD_INT 1
53866: PLUS
53867: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53868: LD_ADDR_EXP 49
53872: PUSH
53873: LD_EXP 49
53877: PPUSH
53878: LD_VAR 0 4
53882: PPUSH
53883: LD_VAR 0 1
53887: PPUSH
53888: CALL_OW 1
53892: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53893: LD_ADDR_EXP 23
53897: PUSH
53898: LD_EXP 23
53902: PPUSH
53903: LD_VAR 0 4
53907: PPUSH
53908: LD_VAR 0 2
53912: PPUSH
53913: CALL_OW 1
53917: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53918: LD_ADDR_EXP 24
53922: PUSH
53923: LD_EXP 24
53927: PPUSH
53928: LD_VAR 0 4
53932: PPUSH
53933: EMPTY
53934: PPUSH
53935: CALL_OW 1
53939: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53940: LD_ADDR_EXP 25
53944: PUSH
53945: LD_EXP 25
53949: PPUSH
53950: LD_VAR 0 4
53954: PPUSH
53955: EMPTY
53956: PPUSH
53957: CALL_OW 1
53961: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53962: LD_ADDR_EXP 26
53966: PUSH
53967: LD_EXP 26
53971: PPUSH
53972: LD_VAR 0 4
53976: PPUSH
53977: EMPTY
53978: PPUSH
53979: CALL_OW 1
53983: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53984: LD_ADDR_EXP 27
53988: PUSH
53989: LD_EXP 27
53993: PPUSH
53994: LD_VAR 0 4
53998: PPUSH
53999: EMPTY
54000: PPUSH
54001: CALL_OW 1
54005: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54006: LD_ADDR_EXP 28
54010: PUSH
54011: LD_EXP 28
54015: PPUSH
54016: LD_VAR 0 4
54020: PPUSH
54021: EMPTY
54022: PPUSH
54023: CALL_OW 1
54027: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54028: LD_ADDR_EXP 29
54032: PUSH
54033: LD_EXP 29
54037: PPUSH
54038: LD_VAR 0 4
54042: PPUSH
54043: EMPTY
54044: PPUSH
54045: CALL_OW 1
54049: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54050: LD_ADDR_EXP 30
54054: PUSH
54055: LD_EXP 30
54059: PPUSH
54060: LD_VAR 0 4
54064: PPUSH
54065: EMPTY
54066: PPUSH
54067: CALL_OW 1
54071: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54072: LD_ADDR_EXP 31
54076: PUSH
54077: LD_EXP 31
54081: PPUSH
54082: LD_VAR 0 4
54086: PPUSH
54087: EMPTY
54088: PPUSH
54089: CALL_OW 1
54093: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54094: LD_ADDR_EXP 32
54098: PUSH
54099: LD_EXP 32
54103: PPUSH
54104: LD_VAR 0 4
54108: PPUSH
54109: EMPTY
54110: PPUSH
54111: CALL_OW 1
54115: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54116: LD_ADDR_EXP 33
54120: PUSH
54121: LD_EXP 33
54125: PPUSH
54126: LD_VAR 0 4
54130: PPUSH
54131: EMPTY
54132: PPUSH
54133: CALL_OW 1
54137: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54138: LD_ADDR_EXP 34
54142: PUSH
54143: LD_EXP 34
54147: PPUSH
54148: LD_VAR 0 4
54152: PPUSH
54153: LD_INT 0
54155: PPUSH
54156: CALL_OW 1
54160: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54161: LD_ADDR_EXP 35
54165: PUSH
54166: LD_EXP 35
54170: PPUSH
54171: LD_VAR 0 4
54175: PPUSH
54176: EMPTY
54177: PPUSH
54178: CALL_OW 1
54182: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54183: LD_ADDR_EXP 36
54187: PUSH
54188: LD_EXP 36
54192: PPUSH
54193: LD_VAR 0 4
54197: PPUSH
54198: EMPTY
54199: PPUSH
54200: CALL_OW 1
54204: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54205: LD_ADDR_EXP 37
54209: PUSH
54210: LD_EXP 37
54214: PPUSH
54215: LD_VAR 0 4
54219: PPUSH
54220: EMPTY
54221: PPUSH
54222: CALL_OW 1
54226: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54227: LD_ADDR_EXP 38
54231: PUSH
54232: LD_EXP 38
54236: PPUSH
54237: LD_VAR 0 4
54241: PPUSH
54242: EMPTY
54243: PPUSH
54244: CALL_OW 1
54248: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54249: LD_ADDR_EXP 39
54253: PUSH
54254: LD_EXP 39
54258: PPUSH
54259: LD_VAR 0 4
54263: PPUSH
54264: EMPTY
54265: PPUSH
54266: CALL_OW 1
54270: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54271: LD_ADDR_EXP 40
54275: PUSH
54276: LD_EXP 40
54280: PPUSH
54281: LD_VAR 0 4
54285: PPUSH
54286: EMPTY
54287: PPUSH
54288: CALL_OW 1
54292: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54293: LD_ADDR_EXP 41
54297: PUSH
54298: LD_EXP 41
54302: PPUSH
54303: LD_VAR 0 4
54307: PPUSH
54308: EMPTY
54309: PPUSH
54310: CALL_OW 1
54314: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54315: LD_ADDR_EXP 42
54319: PUSH
54320: LD_EXP 42
54324: PPUSH
54325: LD_VAR 0 4
54329: PPUSH
54330: EMPTY
54331: PPUSH
54332: CALL_OW 1
54336: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54337: LD_ADDR_EXP 43
54341: PUSH
54342: LD_EXP 43
54346: PPUSH
54347: LD_VAR 0 4
54351: PPUSH
54352: EMPTY
54353: PPUSH
54354: CALL_OW 1
54358: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54359: LD_ADDR_EXP 44
54363: PUSH
54364: LD_EXP 44
54368: PPUSH
54369: LD_VAR 0 4
54373: PPUSH
54374: EMPTY
54375: PPUSH
54376: CALL_OW 1
54380: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54381: LD_ADDR_EXP 45
54385: PUSH
54386: LD_EXP 45
54390: PPUSH
54391: LD_VAR 0 4
54395: PPUSH
54396: EMPTY
54397: PPUSH
54398: CALL_OW 1
54402: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54403: LD_ADDR_EXP 46
54407: PUSH
54408: LD_EXP 46
54412: PPUSH
54413: LD_VAR 0 4
54417: PPUSH
54418: EMPTY
54419: PPUSH
54420: CALL_OW 1
54424: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54425: LD_ADDR_EXP 47
54429: PUSH
54430: LD_EXP 47
54434: PPUSH
54435: LD_VAR 0 4
54439: PPUSH
54440: EMPTY
54441: PPUSH
54442: CALL_OW 1
54446: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54447: LD_ADDR_EXP 48
54451: PUSH
54452: LD_EXP 48
54456: PPUSH
54457: LD_VAR 0 4
54461: PPUSH
54462: EMPTY
54463: PPUSH
54464: CALL_OW 1
54468: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54469: LD_ADDR_EXP 50
54473: PUSH
54474: LD_EXP 50
54478: PPUSH
54479: LD_VAR 0 4
54483: PPUSH
54484: EMPTY
54485: PPUSH
54486: CALL_OW 1
54490: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54491: LD_ADDR_EXP 52
54495: PUSH
54496: LD_EXP 52
54500: PPUSH
54501: LD_VAR 0 4
54505: PPUSH
54506: EMPTY
54507: PPUSH
54508: CALL_OW 1
54512: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54513: LD_ADDR_EXP 53
54517: PUSH
54518: LD_EXP 53
54522: PPUSH
54523: LD_VAR 0 4
54527: PPUSH
54528: EMPTY
54529: PPUSH
54530: CALL_OW 1
54534: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54535: LD_ADDR_EXP 54
54539: PUSH
54540: LD_EXP 54
54544: PPUSH
54545: LD_VAR 0 4
54549: PPUSH
54550: EMPTY
54551: PPUSH
54552: CALL_OW 1
54556: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54557: LD_ADDR_EXP 55
54561: PUSH
54562: LD_EXP 55
54566: PPUSH
54567: LD_VAR 0 4
54571: PPUSH
54572: EMPTY
54573: PPUSH
54574: CALL_OW 1
54578: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54579: LD_ADDR_EXP 56
54583: PUSH
54584: LD_EXP 56
54588: PPUSH
54589: LD_VAR 0 4
54593: PPUSH
54594: EMPTY
54595: PPUSH
54596: CALL_OW 1
54600: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54601: LD_ADDR_EXP 57
54605: PUSH
54606: LD_EXP 57
54610: PPUSH
54611: LD_VAR 0 4
54615: PPUSH
54616: EMPTY
54617: PPUSH
54618: CALL_OW 1
54622: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54623: LD_ADDR_EXP 58
54627: PUSH
54628: LD_EXP 58
54632: PPUSH
54633: LD_VAR 0 4
54637: PPUSH
54638: EMPTY
54639: PPUSH
54640: CALL_OW 1
54644: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54645: LD_ADDR_EXP 59
54649: PUSH
54650: LD_EXP 59
54654: PPUSH
54655: LD_VAR 0 4
54659: PPUSH
54660: EMPTY
54661: PPUSH
54662: CALL_OW 1
54666: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54667: LD_ADDR_EXP 60
54671: PUSH
54672: LD_EXP 60
54676: PPUSH
54677: LD_VAR 0 4
54681: PPUSH
54682: EMPTY
54683: PPUSH
54684: CALL_OW 1
54688: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54689: LD_ADDR_EXP 61
54693: PUSH
54694: LD_EXP 61
54698: PPUSH
54699: LD_VAR 0 4
54703: PPUSH
54704: EMPTY
54705: PPUSH
54706: CALL_OW 1
54710: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54711: LD_ADDR_EXP 62
54715: PUSH
54716: LD_EXP 62
54720: PPUSH
54721: LD_VAR 0 4
54725: PPUSH
54726: EMPTY
54727: PPUSH
54728: CALL_OW 1
54732: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54733: LD_ADDR_EXP 63
54737: PUSH
54738: LD_EXP 63
54742: PPUSH
54743: LD_VAR 0 4
54747: PPUSH
54748: EMPTY
54749: PPUSH
54750: CALL_OW 1
54754: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54755: LD_ADDR_EXP 64
54759: PUSH
54760: LD_EXP 64
54764: PPUSH
54765: LD_VAR 0 4
54769: PPUSH
54770: EMPTY
54771: PPUSH
54772: CALL_OW 1
54776: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54777: LD_ADDR_EXP 65
54781: PUSH
54782: LD_EXP 65
54786: PPUSH
54787: LD_VAR 0 4
54791: PPUSH
54792: LD_INT 0
54794: PPUSH
54795: CALL_OW 1
54799: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54800: LD_ADDR_EXP 66
54804: PUSH
54805: LD_EXP 66
54809: PPUSH
54810: LD_VAR 0 4
54814: PPUSH
54815: LD_INT 0
54817: PPUSH
54818: CALL_OW 1
54822: ST_TO_ADDR
// result := base ;
54823: LD_ADDR_VAR 0 3
54827: PUSH
54828: LD_VAR 0 4
54832: ST_TO_ADDR
// end ;
54833: LD_VAR 0 3
54837: RET
// export function MC_Start ( ) ; var i ; begin
54838: LD_INT 0
54840: PPUSH
54841: PPUSH
// for i = 1 to mc_bases do
54842: LD_ADDR_VAR 0 2
54846: PUSH
54847: DOUBLE
54848: LD_INT 1
54850: DEC
54851: ST_TO_ADDR
54852: LD_EXP 23
54856: PUSH
54857: FOR_TO
54858: IFFALSE 55958
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54860: LD_ADDR_EXP 23
54864: PUSH
54865: LD_EXP 23
54869: PPUSH
54870: LD_VAR 0 2
54874: PPUSH
54875: LD_EXP 23
54879: PUSH
54880: LD_VAR 0 2
54884: ARRAY
54885: PUSH
54886: LD_INT 0
54888: DIFF
54889: PPUSH
54890: CALL_OW 1
54894: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54895: LD_ADDR_EXP 24
54899: PUSH
54900: LD_EXP 24
54904: PPUSH
54905: LD_VAR 0 2
54909: PPUSH
54910: EMPTY
54911: PPUSH
54912: CALL_OW 1
54916: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54917: LD_ADDR_EXP 25
54921: PUSH
54922: LD_EXP 25
54926: PPUSH
54927: LD_VAR 0 2
54931: PPUSH
54932: EMPTY
54933: PPUSH
54934: CALL_OW 1
54938: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54939: LD_ADDR_EXP 26
54943: PUSH
54944: LD_EXP 26
54948: PPUSH
54949: LD_VAR 0 2
54953: PPUSH
54954: EMPTY
54955: PPUSH
54956: CALL_OW 1
54960: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54961: LD_ADDR_EXP 27
54965: PUSH
54966: LD_EXP 27
54970: PPUSH
54971: LD_VAR 0 2
54975: PPUSH
54976: EMPTY
54977: PUSH
54978: EMPTY
54979: PUSH
54980: EMPTY
54981: LIST
54982: LIST
54983: PPUSH
54984: CALL_OW 1
54988: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54989: LD_ADDR_EXP 28
54993: PUSH
54994: LD_EXP 28
54998: PPUSH
54999: LD_VAR 0 2
55003: PPUSH
55004: EMPTY
55005: PPUSH
55006: CALL_OW 1
55010: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
55011: LD_ADDR_EXP 55
55015: PUSH
55016: LD_EXP 55
55020: PPUSH
55021: LD_VAR 0 2
55025: PPUSH
55026: EMPTY
55027: PPUSH
55028: CALL_OW 1
55032: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
55033: LD_ADDR_EXP 29
55037: PUSH
55038: LD_EXP 29
55042: PPUSH
55043: LD_VAR 0 2
55047: PPUSH
55048: EMPTY
55049: PPUSH
55050: CALL_OW 1
55054: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
55055: LD_ADDR_EXP 30
55059: PUSH
55060: LD_EXP 30
55064: PPUSH
55065: LD_VAR 0 2
55069: PPUSH
55070: EMPTY
55071: PPUSH
55072: CALL_OW 1
55076: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
55077: LD_ADDR_EXP 31
55081: PUSH
55082: LD_EXP 31
55086: PPUSH
55087: LD_VAR 0 2
55091: PPUSH
55092: LD_EXP 23
55096: PUSH
55097: LD_VAR 0 2
55101: ARRAY
55102: PPUSH
55103: LD_INT 2
55105: PUSH
55106: LD_INT 30
55108: PUSH
55109: LD_INT 32
55111: PUSH
55112: EMPTY
55113: LIST
55114: LIST
55115: PUSH
55116: LD_INT 30
55118: PUSH
55119: LD_INT 33
55121: PUSH
55122: EMPTY
55123: LIST
55124: LIST
55125: PUSH
55126: EMPTY
55127: LIST
55128: LIST
55129: LIST
55130: PPUSH
55131: CALL_OW 72
55135: PPUSH
55136: CALL_OW 1
55140: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
55141: LD_ADDR_EXP 32
55145: PUSH
55146: LD_EXP 32
55150: PPUSH
55151: LD_VAR 0 2
55155: PPUSH
55156: LD_EXP 23
55160: PUSH
55161: LD_VAR 0 2
55165: ARRAY
55166: PPUSH
55167: LD_INT 2
55169: PUSH
55170: LD_INT 30
55172: PUSH
55173: LD_INT 32
55175: PUSH
55176: EMPTY
55177: LIST
55178: LIST
55179: PUSH
55180: LD_INT 30
55182: PUSH
55183: LD_INT 31
55185: PUSH
55186: EMPTY
55187: LIST
55188: LIST
55189: PUSH
55190: EMPTY
55191: LIST
55192: LIST
55193: LIST
55194: PUSH
55195: LD_INT 58
55197: PUSH
55198: EMPTY
55199: LIST
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: PPUSH
55205: CALL_OW 72
55209: PPUSH
55210: CALL_OW 1
55214: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
55215: LD_ADDR_EXP 33
55219: PUSH
55220: LD_EXP 33
55224: PPUSH
55225: LD_VAR 0 2
55229: PPUSH
55230: EMPTY
55231: PPUSH
55232: CALL_OW 1
55236: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
55237: LD_ADDR_EXP 37
55241: PUSH
55242: LD_EXP 37
55246: PPUSH
55247: LD_VAR 0 2
55251: PPUSH
55252: EMPTY
55253: PPUSH
55254: CALL_OW 1
55258: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
55259: LD_ADDR_EXP 36
55263: PUSH
55264: LD_EXP 36
55268: PPUSH
55269: LD_VAR 0 2
55273: PPUSH
55274: EMPTY
55275: PPUSH
55276: CALL_OW 1
55280: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
55281: LD_ADDR_EXP 38
55285: PUSH
55286: LD_EXP 38
55290: PPUSH
55291: LD_VAR 0 2
55295: PPUSH
55296: EMPTY
55297: PPUSH
55298: CALL_OW 1
55302: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
55303: LD_ADDR_EXP 39
55307: PUSH
55308: LD_EXP 39
55312: PPUSH
55313: LD_VAR 0 2
55317: PPUSH
55318: EMPTY
55319: PPUSH
55320: CALL_OW 1
55324: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55325: LD_ADDR_EXP 40
55329: PUSH
55330: LD_EXP 40
55334: PPUSH
55335: LD_VAR 0 2
55339: PPUSH
55340: EMPTY
55341: PPUSH
55342: CALL_OW 1
55346: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55347: LD_ADDR_EXP 41
55351: PUSH
55352: LD_EXP 41
55356: PPUSH
55357: LD_VAR 0 2
55361: PPUSH
55362: EMPTY
55363: PPUSH
55364: CALL_OW 1
55368: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55369: LD_ADDR_EXP 42
55373: PUSH
55374: LD_EXP 42
55378: PPUSH
55379: LD_VAR 0 2
55383: PPUSH
55384: EMPTY
55385: PPUSH
55386: CALL_OW 1
55390: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55391: LD_ADDR_EXP 43
55395: PUSH
55396: LD_EXP 43
55400: PPUSH
55401: LD_VAR 0 2
55405: PPUSH
55406: EMPTY
55407: PPUSH
55408: CALL_OW 1
55412: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55413: LD_ADDR_EXP 44
55417: PUSH
55418: LD_EXP 44
55422: PPUSH
55423: LD_VAR 0 2
55427: PPUSH
55428: EMPTY
55429: PPUSH
55430: CALL_OW 1
55434: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55435: LD_ADDR_EXP 45
55439: PUSH
55440: LD_EXP 45
55444: PPUSH
55445: LD_VAR 0 2
55449: PPUSH
55450: EMPTY
55451: PPUSH
55452: CALL_OW 1
55456: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55457: LD_ADDR_EXP 34
55461: PUSH
55462: LD_EXP 34
55466: PPUSH
55467: LD_VAR 0 2
55471: PPUSH
55472: LD_INT 0
55474: PPUSH
55475: CALL_OW 1
55479: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55480: LD_ADDR_EXP 47
55484: PUSH
55485: LD_EXP 47
55489: PPUSH
55490: LD_VAR 0 2
55494: PPUSH
55495: LD_INT 0
55497: PPUSH
55498: CALL_OW 1
55502: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55503: LD_ADDR_EXP 35
55507: PUSH
55508: LD_EXP 35
55512: PPUSH
55513: LD_VAR 0 2
55517: PPUSH
55518: EMPTY
55519: PPUSH
55520: CALL_OW 1
55524: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55525: LD_ADDR_EXP 46
55529: PUSH
55530: LD_EXP 46
55534: PPUSH
55535: LD_VAR 0 2
55539: PPUSH
55540: LD_INT 0
55542: PPUSH
55543: CALL_OW 1
55547: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55548: LD_ADDR_EXP 48
55552: PUSH
55553: LD_EXP 48
55557: PPUSH
55558: LD_VAR 0 2
55562: PPUSH
55563: EMPTY
55564: PPUSH
55565: CALL_OW 1
55569: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55570: LD_ADDR_EXP 51
55574: PUSH
55575: LD_EXP 51
55579: PPUSH
55580: LD_VAR 0 2
55584: PPUSH
55585: LD_INT 0
55587: PPUSH
55588: CALL_OW 1
55592: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55593: LD_ADDR_EXP 52
55597: PUSH
55598: LD_EXP 52
55602: PPUSH
55603: LD_VAR 0 2
55607: PPUSH
55608: EMPTY
55609: PPUSH
55610: CALL_OW 1
55614: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55615: LD_ADDR_EXP 53
55619: PUSH
55620: LD_EXP 53
55624: PPUSH
55625: LD_VAR 0 2
55629: PPUSH
55630: EMPTY
55631: PPUSH
55632: CALL_OW 1
55636: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55637: LD_ADDR_EXP 54
55641: PUSH
55642: LD_EXP 54
55646: PPUSH
55647: LD_VAR 0 2
55651: PPUSH
55652: EMPTY
55653: PPUSH
55654: CALL_OW 1
55658: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55659: LD_ADDR_EXP 56
55663: PUSH
55664: LD_EXP 56
55668: PPUSH
55669: LD_VAR 0 2
55673: PPUSH
55674: LD_EXP 23
55678: PUSH
55679: LD_VAR 0 2
55683: ARRAY
55684: PPUSH
55685: LD_INT 2
55687: PUSH
55688: LD_INT 30
55690: PUSH
55691: LD_INT 6
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: PUSH
55698: LD_INT 30
55700: PUSH
55701: LD_INT 7
55703: PUSH
55704: EMPTY
55705: LIST
55706: LIST
55707: PUSH
55708: LD_INT 30
55710: PUSH
55711: LD_INT 8
55713: PUSH
55714: EMPTY
55715: LIST
55716: LIST
55717: PUSH
55718: EMPTY
55719: LIST
55720: LIST
55721: LIST
55722: LIST
55723: PPUSH
55724: CALL_OW 72
55728: PPUSH
55729: CALL_OW 1
55733: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55734: LD_ADDR_EXP 57
55738: PUSH
55739: LD_EXP 57
55743: PPUSH
55744: LD_VAR 0 2
55748: PPUSH
55749: EMPTY
55750: PPUSH
55751: CALL_OW 1
55755: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55756: LD_ADDR_EXP 58
55760: PUSH
55761: LD_EXP 58
55765: PPUSH
55766: LD_VAR 0 2
55770: PPUSH
55771: EMPTY
55772: PPUSH
55773: CALL_OW 1
55777: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55778: LD_ADDR_EXP 59
55782: PUSH
55783: LD_EXP 59
55787: PPUSH
55788: LD_VAR 0 2
55792: PPUSH
55793: EMPTY
55794: PPUSH
55795: CALL_OW 1
55799: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55800: LD_ADDR_EXP 60
55804: PUSH
55805: LD_EXP 60
55809: PPUSH
55810: LD_VAR 0 2
55814: PPUSH
55815: EMPTY
55816: PPUSH
55817: CALL_OW 1
55821: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55822: LD_ADDR_EXP 61
55826: PUSH
55827: LD_EXP 61
55831: PPUSH
55832: LD_VAR 0 2
55836: PPUSH
55837: EMPTY
55838: PPUSH
55839: CALL_OW 1
55843: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55844: LD_ADDR_EXP 62
55848: PUSH
55849: LD_EXP 62
55853: PPUSH
55854: LD_VAR 0 2
55858: PPUSH
55859: EMPTY
55860: PPUSH
55861: CALL_OW 1
55865: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55866: LD_ADDR_EXP 63
55870: PUSH
55871: LD_EXP 63
55875: PPUSH
55876: LD_VAR 0 2
55880: PPUSH
55881: EMPTY
55882: PPUSH
55883: CALL_OW 1
55887: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55888: LD_ADDR_EXP 64
55892: PUSH
55893: LD_EXP 64
55897: PPUSH
55898: LD_VAR 0 2
55902: PPUSH
55903: EMPTY
55904: PPUSH
55905: CALL_OW 1
55909: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55910: LD_ADDR_EXP 65
55914: PUSH
55915: LD_EXP 65
55919: PPUSH
55920: LD_VAR 0 2
55924: PPUSH
55925: LD_INT 0
55927: PPUSH
55928: CALL_OW 1
55932: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55933: LD_ADDR_EXP 66
55937: PUSH
55938: LD_EXP 66
55942: PPUSH
55943: LD_VAR 0 2
55947: PPUSH
55948: LD_INT 0
55950: PPUSH
55951: CALL_OW 1
55955: ST_TO_ADDR
// end ;
55956: GO 54857
55958: POP
55959: POP
// MC_InitSides ( ) ;
55960: CALL 56246 0 0
// MC_InitResearch ( ) ;
55964: CALL 55985 0 0
// CustomInitMacro ( ) ;
55968: CALL 273 0 0
// skirmish := true ;
55972: LD_ADDR_EXP 21
55976: PUSH
55977: LD_INT 1
55979: ST_TO_ADDR
// end ;
55980: LD_VAR 0 1
55984: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55985: LD_INT 0
55987: PPUSH
55988: PPUSH
55989: PPUSH
55990: PPUSH
55991: PPUSH
55992: PPUSH
// if not mc_bases then
55993: LD_EXP 23
55997: NOT
55998: IFFALSE 56002
// exit ;
56000: GO 56241
// for i = 1 to 8 do
56002: LD_ADDR_VAR 0 2
56006: PUSH
56007: DOUBLE
56008: LD_INT 1
56010: DEC
56011: ST_TO_ADDR
56012: LD_INT 8
56014: PUSH
56015: FOR_TO
56016: IFFALSE 56042
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
56018: LD_ADDR_EXP 50
56022: PUSH
56023: LD_EXP 50
56027: PPUSH
56028: LD_VAR 0 2
56032: PPUSH
56033: EMPTY
56034: PPUSH
56035: CALL_OW 1
56039: ST_TO_ADDR
56040: GO 56015
56042: POP
56043: POP
// tmp := [ ] ;
56044: LD_ADDR_VAR 0 5
56048: PUSH
56049: EMPTY
56050: ST_TO_ADDR
// for i = 1 to mc_sides do
56051: LD_ADDR_VAR 0 2
56055: PUSH
56056: DOUBLE
56057: LD_INT 1
56059: DEC
56060: ST_TO_ADDR
56061: LD_EXP 49
56065: PUSH
56066: FOR_TO
56067: IFFALSE 56125
// if not mc_sides [ i ] in tmp then
56069: LD_EXP 49
56073: PUSH
56074: LD_VAR 0 2
56078: ARRAY
56079: PUSH
56080: LD_VAR 0 5
56084: IN
56085: NOT
56086: IFFALSE 56123
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
56088: LD_ADDR_VAR 0 5
56092: PUSH
56093: LD_VAR 0 5
56097: PPUSH
56098: LD_VAR 0 5
56102: PUSH
56103: LD_INT 1
56105: PLUS
56106: PPUSH
56107: LD_EXP 49
56111: PUSH
56112: LD_VAR 0 2
56116: ARRAY
56117: PPUSH
56118: CALL_OW 2
56122: ST_TO_ADDR
56123: GO 56066
56125: POP
56126: POP
// if not tmp then
56127: LD_VAR 0 5
56131: NOT
56132: IFFALSE 56136
// exit ;
56134: GO 56241
// for j in tmp do
56136: LD_ADDR_VAR 0 3
56140: PUSH
56141: LD_VAR 0 5
56145: PUSH
56146: FOR_IN
56147: IFFALSE 56239
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
56149: LD_ADDR_VAR 0 6
56153: PUSH
56154: LD_INT 22
56156: PUSH
56157: LD_VAR 0 3
56161: PUSH
56162: EMPTY
56163: LIST
56164: LIST
56165: PPUSH
56166: CALL_OW 69
56170: ST_TO_ADDR
// if not un then
56171: LD_VAR 0 6
56175: NOT
56176: IFFALSE 56180
// continue ;
56178: GO 56146
// nation := GetNation ( un [ 1 ] ) ;
56180: LD_ADDR_VAR 0 4
56184: PUSH
56185: LD_VAR 0 6
56189: PUSH
56190: LD_INT 1
56192: ARRAY
56193: PPUSH
56194: CALL_OW 248
56198: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
56199: LD_ADDR_EXP 50
56203: PUSH
56204: LD_EXP 50
56208: PPUSH
56209: LD_VAR 0 3
56213: PPUSH
56214: LD_VAR 0 3
56218: PPUSH
56219: LD_VAR 0 4
56223: PPUSH
56224: LD_INT 1
56226: PPUSH
56227: CALL 11178 0 3
56231: PPUSH
56232: CALL_OW 1
56236: ST_TO_ADDR
// end ;
56237: GO 56146
56239: POP
56240: POP
// end ;
56241: LD_VAR 0 1
56245: RET
// export function MC_InitSides ( ) ; var i ; begin
56246: LD_INT 0
56248: PPUSH
56249: PPUSH
// if not mc_bases then
56250: LD_EXP 23
56254: NOT
56255: IFFALSE 56259
// exit ;
56257: GO 56333
// for i = 1 to mc_bases do
56259: LD_ADDR_VAR 0 2
56263: PUSH
56264: DOUBLE
56265: LD_INT 1
56267: DEC
56268: ST_TO_ADDR
56269: LD_EXP 23
56273: PUSH
56274: FOR_TO
56275: IFFALSE 56331
// if mc_bases [ i ] then
56277: LD_EXP 23
56281: PUSH
56282: LD_VAR 0 2
56286: ARRAY
56287: IFFALSE 56329
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
56289: LD_ADDR_EXP 49
56293: PUSH
56294: LD_EXP 49
56298: PPUSH
56299: LD_VAR 0 2
56303: PPUSH
56304: LD_EXP 23
56308: PUSH
56309: LD_VAR 0 2
56313: ARRAY
56314: PUSH
56315: LD_INT 1
56317: ARRAY
56318: PPUSH
56319: CALL_OW 255
56323: PPUSH
56324: CALL_OW 1
56328: ST_TO_ADDR
56329: GO 56274
56331: POP
56332: POP
// end ;
56333: LD_VAR 0 1
56337: RET
// every 0 0$03 trigger skirmish do
56338: LD_EXP 21
56342: IFFALSE 56496
56344: GO 56346
56346: DISABLE
// begin enable ;
56347: ENABLE
// MC_CheckBuildings ( ) ;
56348: CALL 61008 0 0
// MC_CheckPeopleLife ( ) ;
56352: CALL 61169 0 0
// RaiseSailEvent ( 100 ) ;
56356: LD_INT 100
56358: PPUSH
56359: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56363: LD_INT 103
56365: PPUSH
56366: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56370: LD_INT 104
56372: PPUSH
56373: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56377: LD_INT 105
56379: PPUSH
56380: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56384: LD_INT 106
56386: PPUSH
56387: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56391: LD_INT 107
56393: PPUSH
56394: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56398: LD_INT 108
56400: PPUSH
56401: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56405: LD_INT 109
56407: PPUSH
56408: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56412: LD_INT 110
56414: PPUSH
56415: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56419: LD_INT 111
56421: PPUSH
56422: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56426: LD_INT 112
56428: PPUSH
56429: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56433: LD_INT 113
56435: PPUSH
56436: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56440: LD_INT 120
56442: PPUSH
56443: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56447: LD_INT 121
56449: PPUSH
56450: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56454: LD_INT 122
56456: PPUSH
56457: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56461: LD_INT 123
56463: PPUSH
56464: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56468: LD_INT 124
56470: PPUSH
56471: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56475: LD_INT 125
56477: PPUSH
56478: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56482: LD_INT 126
56484: PPUSH
56485: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56489: LD_INT 200
56491: PPUSH
56492: CALL_OW 427
// end ;
56496: END
// on SailEvent ( event ) do begin if event < 100 then
56497: LD_VAR 0 1
56501: PUSH
56502: LD_INT 100
56504: LESS
56505: IFFALSE 56516
// CustomEvent ( event ) ;
56507: LD_VAR 0 1
56511: PPUSH
56512: CALL 10329 0 1
// if event = 100 then
56516: LD_VAR 0 1
56520: PUSH
56521: LD_INT 100
56523: EQUAL
56524: IFFALSE 56530
// MC_ClassManager ( ) ;
56526: CALL 56922 0 0
// if event = 101 then
56530: LD_VAR 0 1
56534: PUSH
56535: LD_INT 101
56537: EQUAL
56538: IFFALSE 56544
// MC_RepairBuildings ( ) ;
56540: CALL 61754 0 0
// if event = 102 then
56544: LD_VAR 0 1
56548: PUSH
56549: LD_INT 102
56551: EQUAL
56552: IFFALSE 56558
// MC_Heal ( ) ;
56554: CALL 62689 0 0
// if event = 103 then
56558: LD_VAR 0 1
56562: PUSH
56563: LD_INT 103
56565: EQUAL
56566: IFFALSE 56572
// MC_Build ( ) ;
56568: CALL 63111 0 0
// if event = 104 then
56572: LD_VAR 0 1
56576: PUSH
56577: LD_INT 104
56579: EQUAL
56580: IFFALSE 56586
// MC_TurretWeapon ( ) ;
56582: CALL 64745 0 0
// if event = 105 then
56586: LD_VAR 0 1
56590: PUSH
56591: LD_INT 105
56593: EQUAL
56594: IFFALSE 56600
// MC_BuildUpgrade ( ) ;
56596: CALL 64296 0 0
// if event = 106 then
56600: LD_VAR 0 1
56604: PUSH
56605: LD_INT 106
56607: EQUAL
56608: IFFALSE 56614
// MC_PlantMines ( ) ;
56610: CALL 65175 0 0
// if event = 107 then
56614: LD_VAR 0 1
56618: PUSH
56619: LD_INT 107
56621: EQUAL
56622: IFFALSE 56628
// MC_CollectCrates ( ) ;
56624: CALL 65973 0 0
// if event = 108 then
56628: LD_VAR 0 1
56632: PUSH
56633: LD_INT 108
56635: EQUAL
56636: IFFALSE 56642
// MC_LinkRemoteControl ( ) ;
56638: CALL 67823 0 0
// if event = 109 then
56642: LD_VAR 0 1
56646: PUSH
56647: LD_INT 109
56649: EQUAL
56650: IFFALSE 56656
// MC_ProduceVehicle ( ) ;
56652: CALL 68004 0 0
// if event = 110 then
56656: LD_VAR 0 1
56660: PUSH
56661: LD_INT 110
56663: EQUAL
56664: IFFALSE 56670
// MC_SendAttack ( ) ;
56666: CALL 68470 0 0
// if event = 111 then
56670: LD_VAR 0 1
56674: PUSH
56675: LD_INT 111
56677: EQUAL
56678: IFFALSE 56684
// MC_Defend ( ) ;
56680: CALL 68578 0 0
// if event = 112 then
56684: LD_VAR 0 1
56688: PUSH
56689: LD_INT 112
56691: EQUAL
56692: IFFALSE 56698
// MC_Research ( ) ;
56694: CALL 69458 0 0
// if event = 113 then
56698: LD_VAR 0 1
56702: PUSH
56703: LD_INT 113
56705: EQUAL
56706: IFFALSE 56712
// MC_MinesTrigger ( ) ;
56708: CALL 70572 0 0
// if event = 120 then
56712: LD_VAR 0 1
56716: PUSH
56717: LD_INT 120
56719: EQUAL
56720: IFFALSE 56726
// MC_RepairVehicle ( ) ;
56722: CALL 70671 0 0
// if event = 121 then
56726: LD_VAR 0 1
56730: PUSH
56731: LD_INT 121
56733: EQUAL
56734: IFFALSE 56740
// MC_TameApe ( ) ;
56736: CALL 71440 0 0
// if event = 122 then
56740: LD_VAR 0 1
56744: PUSH
56745: LD_INT 122
56747: EQUAL
56748: IFFALSE 56754
// MC_ChangeApeClass ( ) ;
56750: CALL 72269 0 0
// if event = 123 then
56754: LD_VAR 0 1
56758: PUSH
56759: LD_INT 123
56761: EQUAL
56762: IFFALSE 56768
// MC_Bazooka ( ) ;
56764: CALL 72919 0 0
// if event = 124 then
56768: LD_VAR 0 1
56772: PUSH
56773: LD_INT 124
56775: EQUAL
56776: IFFALSE 56782
// MC_TeleportExit ( ) ;
56778: CALL 73117 0 0
// if event = 125 then
56782: LD_VAR 0 1
56786: PUSH
56787: LD_INT 125
56789: EQUAL
56790: IFFALSE 56796
// MC_Deposits ( ) ;
56792: CALL 73764 0 0
// if event = 126 then
56796: LD_VAR 0 1
56800: PUSH
56801: LD_INT 126
56803: EQUAL
56804: IFFALSE 56810
// MC_RemoteDriver ( ) ;
56806: CALL 74389 0 0
// if event = 200 then
56810: LD_VAR 0 1
56814: PUSH
56815: LD_INT 200
56817: EQUAL
56818: IFFALSE 56824
// MC_Idle ( ) ;
56820: CALL 76296 0 0
// end ;
56824: PPOPN 1
56826: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56827: LD_INT 0
56829: PPUSH
56830: PPUSH
// if not mc_bases [ base ] or not tag then
56831: LD_EXP 23
56835: PUSH
56836: LD_VAR 0 1
56840: ARRAY
56841: NOT
56842: PUSH
56843: LD_VAR 0 2
56847: NOT
56848: OR
56849: IFFALSE 56853
// exit ;
56851: GO 56917
// for i in mc_bases [ base ] union mc_ape [ base ] do
56853: LD_ADDR_VAR 0 4
56857: PUSH
56858: LD_EXP 23
56862: PUSH
56863: LD_VAR 0 1
56867: ARRAY
56868: PUSH
56869: LD_EXP 52
56873: PUSH
56874: LD_VAR 0 1
56878: ARRAY
56879: UNION
56880: PUSH
56881: FOR_IN
56882: IFFALSE 56915
// if GetTag ( i ) = tag then
56884: LD_VAR 0 4
56888: PPUSH
56889: CALL_OW 110
56893: PUSH
56894: LD_VAR 0 2
56898: EQUAL
56899: IFFALSE 56913
// SetTag ( i , 0 ) ;
56901: LD_VAR 0 4
56905: PPUSH
56906: LD_INT 0
56908: PPUSH
56909: CALL_OW 109
56913: GO 56881
56915: POP
56916: POP
// end ;
56917: LD_VAR 0 3
56921: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56922: LD_INT 0
56924: PPUSH
56925: PPUSH
56926: PPUSH
56927: PPUSH
56928: PPUSH
56929: PPUSH
56930: PPUSH
56931: PPUSH
// if not mc_bases then
56932: LD_EXP 23
56936: NOT
56937: IFFALSE 56941
// exit ;
56939: GO 57390
// for i = 1 to mc_bases do
56941: LD_ADDR_VAR 0 2
56945: PUSH
56946: DOUBLE
56947: LD_INT 1
56949: DEC
56950: ST_TO_ADDR
56951: LD_EXP 23
56955: PUSH
56956: FOR_TO
56957: IFFALSE 57388
// begin tmp := MC_ClassCheckReq ( i ) ;
56959: LD_ADDR_VAR 0 4
56963: PUSH
56964: LD_VAR 0 2
56968: PPUSH
56969: CALL 57395 0 1
56973: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56974: LD_ADDR_EXP 64
56978: PUSH
56979: LD_EXP 64
56983: PPUSH
56984: LD_VAR 0 2
56988: PPUSH
56989: LD_VAR 0 4
56993: PPUSH
56994: CALL_OW 1
56998: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56999: LD_ADDR_VAR 0 6
57003: PUSH
57004: LD_EXP 23
57008: PUSH
57009: LD_VAR 0 2
57013: ARRAY
57014: PPUSH
57015: LD_INT 2
57017: PUSH
57018: LD_INT 30
57020: PUSH
57021: LD_INT 4
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: PUSH
57028: LD_INT 30
57030: PUSH
57031: LD_INT 5
57033: PUSH
57034: EMPTY
57035: LIST
57036: LIST
57037: PUSH
57038: EMPTY
57039: LIST
57040: LIST
57041: LIST
57042: PPUSH
57043: CALL_OW 72
57047: PUSH
57048: LD_EXP 23
57052: PUSH
57053: LD_VAR 0 2
57057: ARRAY
57058: PPUSH
57059: LD_INT 2
57061: PUSH
57062: LD_INT 30
57064: PUSH
57065: LD_INT 0
57067: PUSH
57068: EMPTY
57069: LIST
57070: LIST
57071: PUSH
57072: LD_INT 30
57074: PUSH
57075: LD_INT 1
57077: PUSH
57078: EMPTY
57079: LIST
57080: LIST
57081: PUSH
57082: EMPTY
57083: LIST
57084: LIST
57085: LIST
57086: PPUSH
57087: CALL_OW 72
57091: PUSH
57092: LD_EXP 23
57096: PUSH
57097: LD_VAR 0 2
57101: ARRAY
57102: PPUSH
57103: LD_INT 30
57105: PUSH
57106: LD_INT 3
57108: PUSH
57109: EMPTY
57110: LIST
57111: LIST
57112: PPUSH
57113: CALL_OW 72
57117: PUSH
57118: LD_EXP 23
57122: PUSH
57123: LD_VAR 0 2
57127: ARRAY
57128: PPUSH
57129: LD_INT 2
57131: PUSH
57132: LD_INT 30
57134: PUSH
57135: LD_INT 6
57137: PUSH
57138: EMPTY
57139: LIST
57140: LIST
57141: PUSH
57142: LD_INT 30
57144: PUSH
57145: LD_INT 7
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: PUSH
57152: LD_INT 30
57154: PUSH
57155: LD_INT 8
57157: PUSH
57158: EMPTY
57159: LIST
57160: LIST
57161: PUSH
57162: EMPTY
57163: LIST
57164: LIST
57165: LIST
57166: LIST
57167: PPUSH
57168: CALL_OW 72
57172: PUSH
57173: EMPTY
57174: LIST
57175: LIST
57176: LIST
57177: LIST
57178: ST_TO_ADDR
// for j := 1 to 4 do
57179: LD_ADDR_VAR 0 3
57183: PUSH
57184: DOUBLE
57185: LD_INT 1
57187: DEC
57188: ST_TO_ADDR
57189: LD_INT 4
57191: PUSH
57192: FOR_TO
57193: IFFALSE 57384
// begin if not tmp [ j ] then
57195: LD_VAR 0 4
57199: PUSH
57200: LD_VAR 0 3
57204: ARRAY
57205: NOT
57206: IFFALSE 57210
// continue ;
57208: GO 57192
// for p in tmp [ j ] do
57210: LD_ADDR_VAR 0 5
57214: PUSH
57215: LD_VAR 0 4
57219: PUSH
57220: LD_VAR 0 3
57224: ARRAY
57225: PUSH
57226: FOR_IN
57227: IFFALSE 57380
// begin if not b [ j ] then
57229: LD_VAR 0 6
57233: PUSH
57234: LD_VAR 0 3
57238: ARRAY
57239: NOT
57240: IFFALSE 57244
// break ;
57242: GO 57380
// e := 0 ;
57244: LD_ADDR_VAR 0 7
57248: PUSH
57249: LD_INT 0
57251: ST_TO_ADDR
// for k in b [ j ] do
57252: LD_ADDR_VAR 0 8
57256: PUSH
57257: LD_VAR 0 6
57261: PUSH
57262: LD_VAR 0 3
57266: ARRAY
57267: PUSH
57268: FOR_IN
57269: IFFALSE 57296
// if IsNotFull ( k ) then
57271: LD_VAR 0 8
57275: PPUSH
57276: CALL 13299 0 1
57280: IFFALSE 57294
// begin e := k ;
57282: LD_ADDR_VAR 0 7
57286: PUSH
57287: LD_VAR 0 8
57291: ST_TO_ADDR
// break ;
57292: GO 57296
// end ;
57294: GO 57268
57296: POP
57297: POP
// if e and not UnitGoingToBuilding ( p , e ) then
57298: LD_VAR 0 7
57302: PUSH
57303: LD_VAR 0 5
57307: PPUSH
57308: LD_VAR 0 7
57312: PPUSH
57313: CALL 47081 0 2
57317: NOT
57318: AND
57319: IFFALSE 57378
// begin if IsInUnit ( p ) then
57321: LD_VAR 0 5
57325: PPUSH
57326: CALL_OW 310
57330: IFFALSE 57341
// ComExitBuilding ( p ) ;
57332: LD_VAR 0 5
57336: PPUSH
57337: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57341: LD_VAR 0 5
57345: PPUSH
57346: LD_VAR 0 7
57350: PPUSH
57351: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57355: LD_VAR 0 5
57359: PPUSH
57360: LD_VAR 0 3
57364: PPUSH
57365: CALL_OW 183
// AddComExitBuilding ( p ) ;
57369: LD_VAR 0 5
57373: PPUSH
57374: CALL_OW 182
// end ; end ;
57378: GO 57226
57380: POP
57381: POP
// end ;
57382: GO 57192
57384: POP
57385: POP
// end ;
57386: GO 56956
57388: POP
57389: POP
// end ;
57390: LD_VAR 0 1
57394: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57395: LD_INT 0
57397: PPUSH
57398: PPUSH
57399: PPUSH
57400: PPUSH
57401: PPUSH
57402: PPUSH
57403: PPUSH
57404: PPUSH
57405: PPUSH
57406: PPUSH
57407: PPUSH
57408: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
57409: LD_ADDR_VAR 0 2
57413: PUSH
57414: LD_INT 0
57416: PUSH
57417: LD_INT 0
57419: PUSH
57420: LD_INT 0
57422: PUSH
57423: LD_INT 0
57425: PUSH
57426: EMPTY
57427: LIST
57428: LIST
57429: LIST
57430: LIST
57431: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57432: LD_VAR 0 1
57436: NOT
57437: PUSH
57438: LD_EXP 23
57442: PUSH
57443: LD_VAR 0 1
57447: ARRAY
57448: NOT
57449: OR
57450: PUSH
57451: LD_EXP 23
57455: PUSH
57456: LD_VAR 0 1
57460: ARRAY
57461: PPUSH
57462: LD_INT 2
57464: PUSH
57465: LD_INT 30
57467: PUSH
57468: LD_INT 0
57470: PUSH
57471: EMPTY
57472: LIST
57473: LIST
57474: PUSH
57475: LD_INT 30
57477: PUSH
57478: LD_INT 1
57480: PUSH
57481: EMPTY
57482: LIST
57483: LIST
57484: PUSH
57485: EMPTY
57486: LIST
57487: LIST
57488: LIST
57489: PPUSH
57490: CALL_OW 72
57494: NOT
57495: OR
57496: IFFALSE 57500
// exit ;
57498: GO 61003
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57500: LD_ADDR_VAR 0 4
57504: PUSH
57505: LD_EXP 23
57509: PUSH
57510: LD_VAR 0 1
57514: ARRAY
57515: PPUSH
57516: LD_INT 2
57518: PUSH
57519: LD_INT 25
57521: PUSH
57522: LD_INT 1
57524: PUSH
57525: EMPTY
57526: LIST
57527: LIST
57528: PUSH
57529: LD_INT 25
57531: PUSH
57532: LD_INT 2
57534: PUSH
57535: EMPTY
57536: LIST
57537: LIST
57538: PUSH
57539: LD_INT 25
57541: PUSH
57542: LD_INT 3
57544: PUSH
57545: EMPTY
57546: LIST
57547: LIST
57548: PUSH
57549: LD_INT 25
57551: PUSH
57552: LD_INT 4
57554: PUSH
57555: EMPTY
57556: LIST
57557: LIST
57558: PUSH
57559: LD_INT 25
57561: PUSH
57562: LD_INT 5
57564: PUSH
57565: EMPTY
57566: LIST
57567: LIST
57568: PUSH
57569: LD_INT 25
57571: PUSH
57572: LD_INT 8
57574: PUSH
57575: EMPTY
57576: LIST
57577: LIST
57578: PUSH
57579: LD_INT 25
57581: PUSH
57582: LD_INT 9
57584: PUSH
57585: EMPTY
57586: LIST
57587: LIST
57588: PUSH
57589: EMPTY
57590: LIST
57591: LIST
57592: LIST
57593: LIST
57594: LIST
57595: LIST
57596: LIST
57597: LIST
57598: PPUSH
57599: CALL_OW 72
57603: ST_TO_ADDR
// if not tmp then
57604: LD_VAR 0 4
57608: NOT
57609: IFFALSE 57613
// exit ;
57611: GO 61003
// for i in tmp do
57613: LD_ADDR_VAR 0 3
57617: PUSH
57618: LD_VAR 0 4
57622: PUSH
57623: FOR_IN
57624: IFFALSE 57655
// if GetTag ( i ) then
57626: LD_VAR 0 3
57630: PPUSH
57631: CALL_OW 110
57635: IFFALSE 57653
// tmp := tmp diff i ;
57637: LD_ADDR_VAR 0 4
57641: PUSH
57642: LD_VAR 0 4
57646: PUSH
57647: LD_VAR 0 3
57651: DIFF
57652: ST_TO_ADDR
57653: GO 57623
57655: POP
57656: POP
// if not tmp then
57657: LD_VAR 0 4
57661: NOT
57662: IFFALSE 57666
// exit ;
57664: GO 61003
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57666: LD_ADDR_VAR 0 5
57670: PUSH
57671: LD_EXP 23
57675: PUSH
57676: LD_VAR 0 1
57680: ARRAY
57681: PPUSH
57682: LD_INT 2
57684: PUSH
57685: LD_INT 25
57687: PUSH
57688: LD_INT 1
57690: PUSH
57691: EMPTY
57692: LIST
57693: LIST
57694: PUSH
57695: LD_INT 25
57697: PUSH
57698: LD_INT 5
57700: PUSH
57701: EMPTY
57702: LIST
57703: LIST
57704: PUSH
57705: LD_INT 25
57707: PUSH
57708: LD_INT 8
57710: PUSH
57711: EMPTY
57712: LIST
57713: LIST
57714: PUSH
57715: LD_INT 25
57717: PUSH
57718: LD_INT 9
57720: PUSH
57721: EMPTY
57722: LIST
57723: LIST
57724: PUSH
57725: EMPTY
57726: LIST
57727: LIST
57728: LIST
57729: LIST
57730: LIST
57731: PPUSH
57732: CALL_OW 72
57736: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57737: LD_ADDR_VAR 0 6
57741: PUSH
57742: LD_EXP 23
57746: PUSH
57747: LD_VAR 0 1
57751: ARRAY
57752: PPUSH
57753: LD_INT 25
57755: PUSH
57756: LD_INT 2
57758: PUSH
57759: EMPTY
57760: LIST
57761: LIST
57762: PPUSH
57763: CALL_OW 72
57767: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57768: LD_ADDR_VAR 0 7
57772: PUSH
57773: LD_EXP 23
57777: PUSH
57778: LD_VAR 0 1
57782: ARRAY
57783: PPUSH
57784: LD_INT 25
57786: PUSH
57787: LD_INT 3
57789: PUSH
57790: EMPTY
57791: LIST
57792: LIST
57793: PPUSH
57794: CALL_OW 72
57798: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57799: LD_ADDR_VAR 0 8
57803: PUSH
57804: LD_EXP 23
57808: PUSH
57809: LD_VAR 0 1
57813: ARRAY
57814: PPUSH
57815: LD_INT 25
57817: PUSH
57818: LD_INT 4
57820: PUSH
57821: EMPTY
57822: LIST
57823: LIST
57824: PUSH
57825: LD_INT 24
57827: PUSH
57828: LD_INT 251
57830: PUSH
57831: EMPTY
57832: LIST
57833: LIST
57834: PUSH
57835: EMPTY
57836: LIST
57837: LIST
57838: PPUSH
57839: CALL_OW 72
57843: ST_TO_ADDR
// if mc_is_defending [ base ] then
57844: LD_EXP 66
57848: PUSH
57849: LD_VAR 0 1
57853: ARRAY
57854: IFFALSE 58315
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57856: LD_ADDR_EXP 65
57860: PUSH
57861: LD_EXP 65
57865: PPUSH
57866: LD_VAR 0 1
57870: PPUSH
57871: LD_INT 4
57873: PPUSH
57874: CALL_OW 1
57878: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57879: LD_ADDR_VAR 0 12
57883: PUSH
57884: LD_EXP 23
57888: PUSH
57889: LD_VAR 0 1
57893: ARRAY
57894: PPUSH
57895: LD_INT 2
57897: PUSH
57898: LD_INT 30
57900: PUSH
57901: LD_INT 4
57903: PUSH
57904: EMPTY
57905: LIST
57906: LIST
57907: PUSH
57908: LD_INT 30
57910: PUSH
57911: LD_INT 5
57913: PUSH
57914: EMPTY
57915: LIST
57916: LIST
57917: PUSH
57918: EMPTY
57919: LIST
57920: LIST
57921: LIST
57922: PPUSH
57923: CALL_OW 72
57927: ST_TO_ADDR
// if not b then
57928: LD_VAR 0 12
57932: NOT
57933: IFFALSE 57937
// exit ;
57935: GO 61003
// p := [ ] ;
57937: LD_ADDR_VAR 0 11
57941: PUSH
57942: EMPTY
57943: ST_TO_ADDR
// if sci >= 2 then
57944: LD_VAR 0 8
57948: PUSH
57949: LD_INT 2
57951: GREATEREQUAL
57952: IFFALSE 57983
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57954: LD_ADDR_VAR 0 8
57958: PUSH
57959: LD_VAR 0 8
57963: PUSH
57964: LD_INT 1
57966: ARRAY
57967: PUSH
57968: LD_VAR 0 8
57972: PUSH
57973: LD_INT 2
57975: ARRAY
57976: PUSH
57977: EMPTY
57978: LIST
57979: LIST
57980: ST_TO_ADDR
57981: GO 58044
// if sci = 1 then
57983: LD_VAR 0 8
57987: PUSH
57988: LD_INT 1
57990: EQUAL
57991: IFFALSE 58012
// sci := [ sci [ 1 ] ] else
57993: LD_ADDR_VAR 0 8
57997: PUSH
57998: LD_VAR 0 8
58002: PUSH
58003: LD_INT 1
58005: ARRAY
58006: PUSH
58007: EMPTY
58008: LIST
58009: ST_TO_ADDR
58010: GO 58044
// if sci = 0 then
58012: LD_VAR 0 8
58016: PUSH
58017: LD_INT 0
58019: EQUAL
58020: IFFALSE 58044
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
58022: LD_ADDR_VAR 0 11
58026: PUSH
58027: LD_VAR 0 4
58031: PPUSH
58032: LD_INT 4
58034: PPUSH
58035: CALL 46953 0 2
58039: PUSH
58040: LD_INT 1
58042: ARRAY
58043: ST_TO_ADDR
// if eng > 4 then
58044: LD_VAR 0 6
58048: PUSH
58049: LD_INT 4
58051: GREATER
58052: IFFALSE 58098
// for i = eng downto 4 do
58054: LD_ADDR_VAR 0 3
58058: PUSH
58059: DOUBLE
58060: LD_VAR 0 6
58064: INC
58065: ST_TO_ADDR
58066: LD_INT 4
58068: PUSH
58069: FOR_DOWNTO
58070: IFFALSE 58096
// eng := eng diff eng [ i ] ;
58072: LD_ADDR_VAR 0 6
58076: PUSH
58077: LD_VAR 0 6
58081: PUSH
58082: LD_VAR 0 6
58086: PUSH
58087: LD_VAR 0 3
58091: ARRAY
58092: DIFF
58093: ST_TO_ADDR
58094: GO 58069
58096: POP
58097: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
58098: LD_ADDR_VAR 0 4
58102: PUSH
58103: LD_VAR 0 4
58107: PUSH
58108: LD_VAR 0 5
58112: PUSH
58113: LD_VAR 0 6
58117: UNION
58118: PUSH
58119: LD_VAR 0 7
58123: UNION
58124: PUSH
58125: LD_VAR 0 8
58129: UNION
58130: DIFF
58131: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
58132: LD_ADDR_VAR 0 13
58136: PUSH
58137: LD_EXP 23
58141: PUSH
58142: LD_VAR 0 1
58146: ARRAY
58147: PPUSH
58148: LD_INT 2
58150: PUSH
58151: LD_INT 30
58153: PUSH
58154: LD_INT 32
58156: PUSH
58157: EMPTY
58158: LIST
58159: LIST
58160: PUSH
58161: LD_INT 30
58163: PUSH
58164: LD_INT 31
58166: PUSH
58167: EMPTY
58168: LIST
58169: LIST
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: LIST
58175: PPUSH
58176: CALL_OW 72
58180: PUSH
58181: LD_EXP 23
58185: PUSH
58186: LD_VAR 0 1
58190: ARRAY
58191: PPUSH
58192: LD_INT 2
58194: PUSH
58195: LD_INT 30
58197: PUSH
58198: LD_INT 4
58200: PUSH
58201: EMPTY
58202: LIST
58203: LIST
58204: PUSH
58205: LD_INT 30
58207: PUSH
58208: LD_INT 5
58210: PUSH
58211: EMPTY
58212: LIST
58213: LIST
58214: PUSH
58215: EMPTY
58216: LIST
58217: LIST
58218: LIST
58219: PPUSH
58220: CALL_OW 72
58224: PUSH
58225: LD_INT 6
58227: MUL
58228: PLUS
58229: ST_TO_ADDR
// if bcount < tmp then
58230: LD_VAR 0 13
58234: PUSH
58235: LD_VAR 0 4
58239: LESS
58240: IFFALSE 58286
// for i = tmp downto bcount do
58242: LD_ADDR_VAR 0 3
58246: PUSH
58247: DOUBLE
58248: LD_VAR 0 4
58252: INC
58253: ST_TO_ADDR
58254: LD_VAR 0 13
58258: PUSH
58259: FOR_DOWNTO
58260: IFFALSE 58284
// tmp := Delete ( tmp , tmp ) ;
58262: LD_ADDR_VAR 0 4
58266: PUSH
58267: LD_VAR 0 4
58271: PPUSH
58272: LD_VAR 0 4
58276: PPUSH
58277: CALL_OW 3
58281: ST_TO_ADDR
58282: GO 58259
58284: POP
58285: POP
// result := [ tmp , 0 , 0 , p ] ;
58286: LD_ADDR_VAR 0 2
58290: PUSH
58291: LD_VAR 0 4
58295: PUSH
58296: LD_INT 0
58298: PUSH
58299: LD_INT 0
58301: PUSH
58302: LD_VAR 0 11
58306: PUSH
58307: EMPTY
58308: LIST
58309: LIST
58310: LIST
58311: LIST
58312: ST_TO_ADDR
// exit ;
58313: GO 61003
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58315: LD_EXP 23
58319: PUSH
58320: LD_VAR 0 1
58324: ARRAY
58325: PPUSH
58326: LD_INT 2
58328: PUSH
58329: LD_INT 30
58331: PUSH
58332: LD_INT 6
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: PUSH
58339: LD_INT 30
58341: PUSH
58342: LD_INT 7
58344: PUSH
58345: EMPTY
58346: LIST
58347: LIST
58348: PUSH
58349: LD_INT 30
58351: PUSH
58352: LD_INT 8
58354: PUSH
58355: EMPTY
58356: LIST
58357: LIST
58358: PUSH
58359: EMPTY
58360: LIST
58361: LIST
58362: LIST
58363: LIST
58364: PPUSH
58365: CALL_OW 72
58369: NOT
58370: PUSH
58371: LD_EXP 23
58375: PUSH
58376: LD_VAR 0 1
58380: ARRAY
58381: PPUSH
58382: LD_INT 30
58384: PUSH
58385: LD_INT 3
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: PPUSH
58392: CALL_OW 72
58396: NOT
58397: AND
58398: IFFALSE 58470
// begin if eng = tmp then
58400: LD_VAR 0 6
58404: PUSH
58405: LD_VAR 0 4
58409: EQUAL
58410: IFFALSE 58414
// exit ;
58412: GO 61003
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58414: LD_ADDR_EXP 65
58418: PUSH
58419: LD_EXP 65
58423: PPUSH
58424: LD_VAR 0 1
58428: PPUSH
58429: LD_INT 1
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58437: LD_ADDR_VAR 0 2
58441: PUSH
58442: LD_INT 0
58444: PUSH
58445: LD_VAR 0 4
58449: PUSH
58450: LD_VAR 0 6
58454: DIFF
58455: PUSH
58456: LD_INT 0
58458: PUSH
58459: LD_INT 0
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: LIST
58466: LIST
58467: ST_TO_ADDR
// exit ;
58468: GO 61003
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58470: LD_EXP 50
58474: PUSH
58475: LD_EXP 49
58479: PUSH
58480: LD_VAR 0 1
58484: ARRAY
58485: ARRAY
58486: PUSH
58487: LD_EXP 23
58491: PUSH
58492: LD_VAR 0 1
58496: ARRAY
58497: PPUSH
58498: LD_INT 2
58500: PUSH
58501: LD_INT 30
58503: PUSH
58504: LD_INT 6
58506: PUSH
58507: EMPTY
58508: LIST
58509: LIST
58510: PUSH
58511: LD_INT 30
58513: PUSH
58514: LD_INT 7
58516: PUSH
58517: EMPTY
58518: LIST
58519: LIST
58520: PUSH
58521: LD_INT 30
58523: PUSH
58524: LD_INT 8
58526: PUSH
58527: EMPTY
58528: LIST
58529: LIST
58530: PUSH
58531: EMPTY
58532: LIST
58533: LIST
58534: LIST
58535: LIST
58536: PPUSH
58537: CALL_OW 72
58541: AND
58542: PUSH
58543: LD_EXP 23
58547: PUSH
58548: LD_VAR 0 1
58552: ARRAY
58553: PPUSH
58554: LD_INT 30
58556: PUSH
58557: LD_INT 3
58559: PUSH
58560: EMPTY
58561: LIST
58562: LIST
58563: PPUSH
58564: CALL_OW 72
58568: NOT
58569: AND
58570: IFFALSE 58784
// begin if sci >= 6 then
58572: LD_VAR 0 8
58576: PUSH
58577: LD_INT 6
58579: GREATEREQUAL
58580: IFFALSE 58584
// exit ;
58582: GO 61003
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58584: LD_ADDR_EXP 65
58588: PUSH
58589: LD_EXP 65
58593: PPUSH
58594: LD_VAR 0 1
58598: PPUSH
58599: LD_INT 2
58601: PPUSH
58602: CALL_OW 1
58606: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58607: LD_ADDR_VAR 0 9
58611: PUSH
58612: LD_VAR 0 4
58616: PUSH
58617: LD_VAR 0 8
58621: DIFF
58622: PPUSH
58623: LD_INT 4
58625: PPUSH
58626: CALL 46953 0 2
58630: ST_TO_ADDR
// p := [ ] ;
58631: LD_ADDR_VAR 0 11
58635: PUSH
58636: EMPTY
58637: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58638: LD_VAR 0 8
58642: PUSH
58643: LD_INT 6
58645: LESS
58646: PUSH
58647: LD_VAR 0 9
58651: PUSH
58652: LD_INT 6
58654: GREATER
58655: AND
58656: IFFALSE 58737
// begin for i = 1 to 6 - sci do
58658: LD_ADDR_VAR 0 3
58662: PUSH
58663: DOUBLE
58664: LD_INT 1
58666: DEC
58667: ST_TO_ADDR
58668: LD_INT 6
58670: PUSH
58671: LD_VAR 0 8
58675: MINUS
58676: PUSH
58677: FOR_TO
58678: IFFALSE 58733
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58680: LD_ADDR_VAR 0 11
58684: PUSH
58685: LD_VAR 0 11
58689: PPUSH
58690: LD_VAR 0 11
58694: PUSH
58695: LD_INT 1
58697: PLUS
58698: PPUSH
58699: LD_VAR 0 9
58703: PUSH
58704: LD_INT 1
58706: ARRAY
58707: PPUSH
58708: CALL_OW 2
58712: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58713: LD_ADDR_VAR 0 9
58717: PUSH
58718: LD_VAR 0 9
58722: PPUSH
58723: LD_INT 1
58725: PPUSH
58726: CALL_OW 3
58730: ST_TO_ADDR
// end ;
58731: GO 58677
58733: POP
58734: POP
// end else
58735: GO 58757
// if sort then
58737: LD_VAR 0 9
58741: IFFALSE 58757
// p := sort [ 1 ] ;
58743: LD_ADDR_VAR 0 11
58747: PUSH
58748: LD_VAR 0 9
58752: PUSH
58753: LD_INT 1
58755: ARRAY
58756: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58757: LD_ADDR_VAR 0 2
58761: PUSH
58762: LD_INT 0
58764: PUSH
58765: LD_INT 0
58767: PUSH
58768: LD_INT 0
58770: PUSH
58771: LD_VAR 0 11
58775: PUSH
58776: EMPTY
58777: LIST
58778: LIST
58779: LIST
58780: LIST
58781: ST_TO_ADDR
// exit ;
58782: GO 61003
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58784: LD_EXP 50
58788: PUSH
58789: LD_EXP 49
58793: PUSH
58794: LD_VAR 0 1
58798: ARRAY
58799: ARRAY
58800: PUSH
58801: LD_EXP 23
58805: PUSH
58806: LD_VAR 0 1
58810: ARRAY
58811: PPUSH
58812: LD_INT 2
58814: PUSH
58815: LD_INT 30
58817: PUSH
58818: LD_INT 6
58820: PUSH
58821: EMPTY
58822: LIST
58823: LIST
58824: PUSH
58825: LD_INT 30
58827: PUSH
58828: LD_INT 7
58830: PUSH
58831: EMPTY
58832: LIST
58833: LIST
58834: PUSH
58835: LD_INT 30
58837: PUSH
58838: LD_INT 8
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: LIST
58849: LIST
58850: PPUSH
58851: CALL_OW 72
58855: AND
58856: PUSH
58857: LD_EXP 23
58861: PUSH
58862: LD_VAR 0 1
58866: ARRAY
58867: PPUSH
58868: LD_INT 30
58870: PUSH
58871: LD_INT 3
58873: PUSH
58874: EMPTY
58875: LIST
58876: LIST
58877: PPUSH
58878: CALL_OW 72
58882: AND
58883: IFFALSE 59617
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58885: LD_ADDR_EXP 65
58889: PUSH
58890: LD_EXP 65
58894: PPUSH
58895: LD_VAR 0 1
58899: PPUSH
58900: LD_INT 3
58902: PPUSH
58903: CALL_OW 1
58907: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58908: LD_ADDR_VAR 0 2
58912: PUSH
58913: LD_INT 0
58915: PUSH
58916: LD_INT 0
58918: PUSH
58919: LD_INT 0
58921: PUSH
58922: LD_INT 0
58924: PUSH
58925: EMPTY
58926: LIST
58927: LIST
58928: LIST
58929: LIST
58930: ST_TO_ADDR
// if not eng then
58931: LD_VAR 0 6
58935: NOT
58936: IFFALSE 58999
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58938: LD_ADDR_VAR 0 11
58942: PUSH
58943: LD_VAR 0 4
58947: PPUSH
58948: LD_INT 2
58950: PPUSH
58951: CALL 46953 0 2
58955: PUSH
58956: LD_INT 1
58958: ARRAY
58959: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58960: LD_ADDR_VAR 0 2
58964: PUSH
58965: LD_VAR 0 2
58969: PPUSH
58970: LD_INT 2
58972: PPUSH
58973: LD_VAR 0 11
58977: PPUSH
58978: CALL_OW 1
58982: ST_TO_ADDR
// tmp := tmp diff p ;
58983: LD_ADDR_VAR 0 4
58987: PUSH
58988: LD_VAR 0 4
58992: PUSH
58993: LD_VAR 0 11
58997: DIFF
58998: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58999: LD_VAR 0 4
59003: PUSH
59004: LD_VAR 0 8
59008: PUSH
59009: LD_INT 6
59011: LESS
59012: AND
59013: IFFALSE 59201
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
59015: LD_ADDR_VAR 0 9
59019: PUSH
59020: LD_VAR 0 4
59024: PUSH
59025: LD_VAR 0 8
59029: PUSH
59030: LD_VAR 0 7
59034: UNION
59035: DIFF
59036: PPUSH
59037: LD_INT 4
59039: PPUSH
59040: CALL 46953 0 2
59044: ST_TO_ADDR
// p := [ ] ;
59045: LD_ADDR_VAR 0 11
59049: PUSH
59050: EMPTY
59051: ST_TO_ADDR
// if sort then
59052: LD_VAR 0 9
59056: IFFALSE 59172
// for i = 1 to 6 - sci do
59058: LD_ADDR_VAR 0 3
59062: PUSH
59063: DOUBLE
59064: LD_INT 1
59066: DEC
59067: ST_TO_ADDR
59068: LD_INT 6
59070: PUSH
59071: LD_VAR 0 8
59075: MINUS
59076: PUSH
59077: FOR_TO
59078: IFFALSE 59170
// begin if i = sort then
59080: LD_VAR 0 3
59084: PUSH
59085: LD_VAR 0 9
59089: EQUAL
59090: IFFALSE 59094
// break ;
59092: GO 59170
// if GetClass ( i ) = 4 then
59094: LD_VAR 0 3
59098: PPUSH
59099: CALL_OW 257
59103: PUSH
59104: LD_INT 4
59106: EQUAL
59107: IFFALSE 59111
// continue ;
59109: GO 59077
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59111: LD_ADDR_VAR 0 11
59115: PUSH
59116: LD_VAR 0 11
59120: PPUSH
59121: LD_VAR 0 11
59125: PUSH
59126: LD_INT 1
59128: PLUS
59129: PPUSH
59130: LD_VAR 0 9
59134: PUSH
59135: LD_VAR 0 3
59139: ARRAY
59140: PPUSH
59141: CALL_OW 2
59145: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59146: LD_ADDR_VAR 0 4
59150: PUSH
59151: LD_VAR 0 4
59155: PUSH
59156: LD_VAR 0 9
59160: PUSH
59161: LD_VAR 0 3
59165: ARRAY
59166: DIFF
59167: ST_TO_ADDR
// end ;
59168: GO 59077
59170: POP
59171: POP
// if p then
59172: LD_VAR 0 11
59176: IFFALSE 59201
// result := Replace ( result , 4 , p ) ;
59178: LD_ADDR_VAR 0 2
59182: PUSH
59183: LD_VAR 0 2
59187: PPUSH
59188: LD_INT 4
59190: PPUSH
59191: LD_VAR 0 11
59195: PPUSH
59196: CALL_OW 1
59200: ST_TO_ADDR
// end ; if tmp and mech < 6 then
59201: LD_VAR 0 4
59205: PUSH
59206: LD_VAR 0 7
59210: PUSH
59211: LD_INT 6
59213: LESS
59214: AND
59215: IFFALSE 59403
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59217: LD_ADDR_VAR 0 9
59221: PUSH
59222: LD_VAR 0 4
59226: PUSH
59227: LD_VAR 0 8
59231: PUSH
59232: LD_VAR 0 7
59236: UNION
59237: DIFF
59238: PPUSH
59239: LD_INT 3
59241: PPUSH
59242: CALL 46953 0 2
59246: ST_TO_ADDR
// p := [ ] ;
59247: LD_ADDR_VAR 0 11
59251: PUSH
59252: EMPTY
59253: ST_TO_ADDR
// if sort then
59254: LD_VAR 0 9
59258: IFFALSE 59374
// for i = 1 to 6 - mech do
59260: LD_ADDR_VAR 0 3
59264: PUSH
59265: DOUBLE
59266: LD_INT 1
59268: DEC
59269: ST_TO_ADDR
59270: LD_INT 6
59272: PUSH
59273: LD_VAR 0 7
59277: MINUS
59278: PUSH
59279: FOR_TO
59280: IFFALSE 59372
// begin if i = sort then
59282: LD_VAR 0 3
59286: PUSH
59287: LD_VAR 0 9
59291: EQUAL
59292: IFFALSE 59296
// break ;
59294: GO 59372
// if GetClass ( i ) = 3 then
59296: LD_VAR 0 3
59300: PPUSH
59301: CALL_OW 257
59305: PUSH
59306: LD_INT 3
59308: EQUAL
59309: IFFALSE 59313
// continue ;
59311: GO 59279
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59313: LD_ADDR_VAR 0 11
59317: PUSH
59318: LD_VAR 0 11
59322: PPUSH
59323: LD_VAR 0 11
59327: PUSH
59328: LD_INT 1
59330: PLUS
59331: PPUSH
59332: LD_VAR 0 9
59336: PUSH
59337: LD_VAR 0 3
59341: ARRAY
59342: PPUSH
59343: CALL_OW 2
59347: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59348: LD_ADDR_VAR 0 4
59352: PUSH
59353: LD_VAR 0 4
59357: PUSH
59358: LD_VAR 0 9
59362: PUSH
59363: LD_VAR 0 3
59367: ARRAY
59368: DIFF
59369: ST_TO_ADDR
// end ;
59370: GO 59279
59372: POP
59373: POP
// if p then
59374: LD_VAR 0 11
59378: IFFALSE 59403
// result := Replace ( result , 3 , p ) ;
59380: LD_ADDR_VAR 0 2
59384: PUSH
59385: LD_VAR 0 2
59389: PPUSH
59390: LD_INT 3
59392: PPUSH
59393: LD_VAR 0 11
59397: PPUSH
59398: CALL_OW 1
59402: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59403: LD_VAR 0 4
59407: PUSH
59408: LD_INT 6
59410: GREATER
59411: PUSH
59412: LD_VAR 0 6
59416: PUSH
59417: LD_INT 6
59419: LESS
59420: AND
59421: IFFALSE 59615
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59423: LD_ADDR_VAR 0 9
59427: PUSH
59428: LD_VAR 0 4
59432: PUSH
59433: LD_VAR 0 8
59437: PUSH
59438: LD_VAR 0 7
59442: UNION
59443: PUSH
59444: LD_VAR 0 6
59448: UNION
59449: DIFF
59450: PPUSH
59451: LD_INT 2
59453: PPUSH
59454: CALL 46953 0 2
59458: ST_TO_ADDR
// p := [ ] ;
59459: LD_ADDR_VAR 0 11
59463: PUSH
59464: EMPTY
59465: ST_TO_ADDR
// if sort then
59466: LD_VAR 0 9
59470: IFFALSE 59586
// for i = 1 to 6 - eng do
59472: LD_ADDR_VAR 0 3
59476: PUSH
59477: DOUBLE
59478: LD_INT 1
59480: DEC
59481: ST_TO_ADDR
59482: LD_INT 6
59484: PUSH
59485: LD_VAR 0 6
59489: MINUS
59490: PUSH
59491: FOR_TO
59492: IFFALSE 59584
// begin if i = sort then
59494: LD_VAR 0 3
59498: PUSH
59499: LD_VAR 0 9
59503: EQUAL
59504: IFFALSE 59508
// break ;
59506: GO 59584
// if GetClass ( i ) = 2 then
59508: LD_VAR 0 3
59512: PPUSH
59513: CALL_OW 257
59517: PUSH
59518: LD_INT 2
59520: EQUAL
59521: IFFALSE 59525
// continue ;
59523: GO 59491
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59525: LD_ADDR_VAR 0 11
59529: PUSH
59530: LD_VAR 0 11
59534: PPUSH
59535: LD_VAR 0 11
59539: PUSH
59540: LD_INT 1
59542: PLUS
59543: PPUSH
59544: LD_VAR 0 9
59548: PUSH
59549: LD_VAR 0 3
59553: ARRAY
59554: PPUSH
59555: CALL_OW 2
59559: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59560: LD_ADDR_VAR 0 4
59564: PUSH
59565: LD_VAR 0 4
59569: PUSH
59570: LD_VAR 0 9
59574: PUSH
59575: LD_VAR 0 3
59579: ARRAY
59580: DIFF
59581: ST_TO_ADDR
// end ;
59582: GO 59491
59584: POP
59585: POP
// if p then
59586: LD_VAR 0 11
59590: IFFALSE 59615
// result := Replace ( result , 2 , p ) ;
59592: LD_ADDR_VAR 0 2
59596: PUSH
59597: LD_VAR 0 2
59601: PPUSH
59602: LD_INT 2
59604: PPUSH
59605: LD_VAR 0 11
59609: PPUSH
59610: CALL_OW 1
59614: ST_TO_ADDR
// end ; exit ;
59615: GO 61003
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59617: LD_EXP 50
59621: PUSH
59622: LD_EXP 49
59626: PUSH
59627: LD_VAR 0 1
59631: ARRAY
59632: ARRAY
59633: NOT
59634: PUSH
59635: LD_EXP 23
59639: PUSH
59640: LD_VAR 0 1
59644: ARRAY
59645: PPUSH
59646: LD_INT 30
59648: PUSH
59649: LD_INT 3
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: PPUSH
59656: CALL_OW 72
59660: AND
59661: PUSH
59662: LD_EXP 28
59666: PUSH
59667: LD_VAR 0 1
59671: ARRAY
59672: AND
59673: IFFALSE 60281
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59675: LD_ADDR_EXP 65
59679: PUSH
59680: LD_EXP 65
59684: PPUSH
59685: LD_VAR 0 1
59689: PPUSH
59690: LD_INT 5
59692: PPUSH
59693: CALL_OW 1
59697: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59698: LD_ADDR_VAR 0 2
59702: PUSH
59703: LD_INT 0
59705: PUSH
59706: LD_INT 0
59708: PUSH
59709: LD_INT 0
59711: PUSH
59712: LD_INT 0
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: LIST
59719: LIST
59720: ST_TO_ADDR
// if sci > 1 then
59721: LD_VAR 0 8
59725: PUSH
59726: LD_INT 1
59728: GREATER
59729: IFFALSE 59757
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59731: LD_ADDR_VAR 0 4
59735: PUSH
59736: LD_VAR 0 4
59740: PUSH
59741: LD_VAR 0 8
59745: PUSH
59746: LD_VAR 0 8
59750: PUSH
59751: LD_INT 1
59753: ARRAY
59754: DIFF
59755: DIFF
59756: ST_TO_ADDR
// if tmp and not sci then
59757: LD_VAR 0 4
59761: PUSH
59762: LD_VAR 0 8
59766: NOT
59767: AND
59768: IFFALSE 59837
// begin sort := SortBySkill ( tmp , 4 ) ;
59770: LD_ADDR_VAR 0 9
59774: PUSH
59775: LD_VAR 0 4
59779: PPUSH
59780: LD_INT 4
59782: PPUSH
59783: CALL 46953 0 2
59787: ST_TO_ADDR
// if sort then
59788: LD_VAR 0 9
59792: IFFALSE 59808
// p := sort [ 1 ] ;
59794: LD_ADDR_VAR 0 11
59798: PUSH
59799: LD_VAR 0 9
59803: PUSH
59804: LD_INT 1
59806: ARRAY
59807: ST_TO_ADDR
// if p then
59808: LD_VAR 0 11
59812: IFFALSE 59837
// result := Replace ( result , 4 , p ) ;
59814: LD_ADDR_VAR 0 2
59818: PUSH
59819: LD_VAR 0 2
59823: PPUSH
59824: LD_INT 4
59826: PPUSH
59827: LD_VAR 0 11
59831: PPUSH
59832: CALL_OW 1
59836: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59837: LD_ADDR_VAR 0 4
59841: PUSH
59842: LD_VAR 0 4
59846: PUSH
59847: LD_VAR 0 7
59851: DIFF
59852: ST_TO_ADDR
// if tmp and mech < 6 then
59853: LD_VAR 0 4
59857: PUSH
59858: LD_VAR 0 7
59862: PUSH
59863: LD_INT 6
59865: LESS
59866: AND
59867: IFFALSE 60055
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59869: LD_ADDR_VAR 0 9
59873: PUSH
59874: LD_VAR 0 4
59878: PUSH
59879: LD_VAR 0 8
59883: PUSH
59884: LD_VAR 0 7
59888: UNION
59889: DIFF
59890: PPUSH
59891: LD_INT 3
59893: PPUSH
59894: CALL 46953 0 2
59898: ST_TO_ADDR
// p := [ ] ;
59899: LD_ADDR_VAR 0 11
59903: PUSH
59904: EMPTY
59905: ST_TO_ADDR
// if sort then
59906: LD_VAR 0 9
59910: IFFALSE 60026
// for i = 1 to 6 - mech do
59912: LD_ADDR_VAR 0 3
59916: PUSH
59917: DOUBLE
59918: LD_INT 1
59920: DEC
59921: ST_TO_ADDR
59922: LD_INT 6
59924: PUSH
59925: LD_VAR 0 7
59929: MINUS
59930: PUSH
59931: FOR_TO
59932: IFFALSE 60024
// begin if i = sort then
59934: LD_VAR 0 3
59938: PUSH
59939: LD_VAR 0 9
59943: EQUAL
59944: IFFALSE 59948
// break ;
59946: GO 60024
// if GetClass ( i ) = 3 then
59948: LD_VAR 0 3
59952: PPUSH
59953: CALL_OW 257
59957: PUSH
59958: LD_INT 3
59960: EQUAL
59961: IFFALSE 59965
// continue ;
59963: GO 59931
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59965: LD_ADDR_VAR 0 11
59969: PUSH
59970: LD_VAR 0 11
59974: PPUSH
59975: LD_VAR 0 11
59979: PUSH
59980: LD_INT 1
59982: PLUS
59983: PPUSH
59984: LD_VAR 0 9
59988: PUSH
59989: LD_VAR 0 3
59993: ARRAY
59994: PPUSH
59995: CALL_OW 2
59999: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60000: LD_ADDR_VAR 0 4
60004: PUSH
60005: LD_VAR 0 4
60009: PUSH
60010: LD_VAR 0 9
60014: PUSH
60015: LD_VAR 0 3
60019: ARRAY
60020: DIFF
60021: ST_TO_ADDR
// end ;
60022: GO 59931
60024: POP
60025: POP
// if p then
60026: LD_VAR 0 11
60030: IFFALSE 60055
// result := Replace ( result , 3 , p ) ;
60032: LD_ADDR_VAR 0 2
60036: PUSH
60037: LD_VAR 0 2
60041: PPUSH
60042: LD_INT 3
60044: PPUSH
60045: LD_VAR 0 11
60049: PPUSH
60050: CALL_OW 1
60054: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60055: LD_ADDR_VAR 0 4
60059: PUSH
60060: LD_VAR 0 4
60064: PUSH
60065: LD_VAR 0 6
60069: DIFF
60070: ST_TO_ADDR
// if tmp and eng < 6 then
60071: LD_VAR 0 4
60075: PUSH
60076: LD_VAR 0 6
60080: PUSH
60081: LD_INT 6
60083: LESS
60084: AND
60085: IFFALSE 60279
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
60087: LD_ADDR_VAR 0 9
60091: PUSH
60092: LD_VAR 0 4
60096: PUSH
60097: LD_VAR 0 8
60101: PUSH
60102: LD_VAR 0 7
60106: UNION
60107: PUSH
60108: LD_VAR 0 6
60112: UNION
60113: DIFF
60114: PPUSH
60115: LD_INT 2
60117: PPUSH
60118: CALL 46953 0 2
60122: ST_TO_ADDR
// p := [ ] ;
60123: LD_ADDR_VAR 0 11
60127: PUSH
60128: EMPTY
60129: ST_TO_ADDR
// if sort then
60130: LD_VAR 0 9
60134: IFFALSE 60250
// for i = 1 to 6 - eng do
60136: LD_ADDR_VAR 0 3
60140: PUSH
60141: DOUBLE
60142: LD_INT 1
60144: DEC
60145: ST_TO_ADDR
60146: LD_INT 6
60148: PUSH
60149: LD_VAR 0 6
60153: MINUS
60154: PUSH
60155: FOR_TO
60156: IFFALSE 60248
// begin if i = sort then
60158: LD_VAR 0 3
60162: PUSH
60163: LD_VAR 0 9
60167: EQUAL
60168: IFFALSE 60172
// break ;
60170: GO 60248
// if GetClass ( i ) = 2 then
60172: LD_VAR 0 3
60176: PPUSH
60177: CALL_OW 257
60181: PUSH
60182: LD_INT 2
60184: EQUAL
60185: IFFALSE 60189
// continue ;
60187: GO 60155
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60189: LD_ADDR_VAR 0 11
60193: PUSH
60194: LD_VAR 0 11
60198: PPUSH
60199: LD_VAR 0 11
60203: PUSH
60204: LD_INT 1
60206: PLUS
60207: PPUSH
60208: LD_VAR 0 9
60212: PUSH
60213: LD_VAR 0 3
60217: ARRAY
60218: PPUSH
60219: CALL_OW 2
60223: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60224: LD_ADDR_VAR 0 4
60228: PUSH
60229: LD_VAR 0 4
60233: PUSH
60234: LD_VAR 0 9
60238: PUSH
60239: LD_VAR 0 3
60243: ARRAY
60244: DIFF
60245: ST_TO_ADDR
// end ;
60246: GO 60155
60248: POP
60249: POP
// if p then
60250: LD_VAR 0 11
60254: IFFALSE 60279
// result := Replace ( result , 2 , p ) ;
60256: LD_ADDR_VAR 0 2
60260: PUSH
60261: LD_VAR 0 2
60265: PPUSH
60266: LD_INT 2
60268: PPUSH
60269: LD_VAR 0 11
60273: PPUSH
60274: CALL_OW 1
60278: ST_TO_ADDR
// end ; exit ;
60279: GO 61003
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
60281: LD_EXP 50
60285: PUSH
60286: LD_EXP 49
60290: PUSH
60291: LD_VAR 0 1
60295: ARRAY
60296: ARRAY
60297: NOT
60298: PUSH
60299: LD_EXP 23
60303: PUSH
60304: LD_VAR 0 1
60308: ARRAY
60309: PPUSH
60310: LD_INT 30
60312: PUSH
60313: LD_INT 3
60315: PUSH
60316: EMPTY
60317: LIST
60318: LIST
60319: PPUSH
60320: CALL_OW 72
60324: AND
60325: PUSH
60326: LD_EXP 28
60330: PUSH
60331: LD_VAR 0 1
60335: ARRAY
60336: NOT
60337: AND
60338: IFFALSE 61003
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
60340: LD_ADDR_EXP 65
60344: PUSH
60345: LD_EXP 65
60349: PPUSH
60350: LD_VAR 0 1
60354: PPUSH
60355: LD_INT 6
60357: PPUSH
60358: CALL_OW 1
60362: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60363: LD_ADDR_VAR 0 2
60367: PUSH
60368: LD_INT 0
60370: PUSH
60371: LD_INT 0
60373: PUSH
60374: LD_INT 0
60376: PUSH
60377: LD_INT 0
60379: PUSH
60380: EMPTY
60381: LIST
60382: LIST
60383: LIST
60384: LIST
60385: ST_TO_ADDR
// if sci >= 1 then
60386: LD_VAR 0 8
60390: PUSH
60391: LD_INT 1
60393: GREATEREQUAL
60394: IFFALSE 60416
// tmp := tmp diff sci [ 1 ] ;
60396: LD_ADDR_VAR 0 4
60400: PUSH
60401: LD_VAR 0 4
60405: PUSH
60406: LD_VAR 0 8
60410: PUSH
60411: LD_INT 1
60413: ARRAY
60414: DIFF
60415: ST_TO_ADDR
// if tmp and not sci then
60416: LD_VAR 0 4
60420: PUSH
60421: LD_VAR 0 8
60425: NOT
60426: AND
60427: IFFALSE 60496
// begin sort := SortBySkill ( tmp , 4 ) ;
60429: LD_ADDR_VAR 0 9
60433: PUSH
60434: LD_VAR 0 4
60438: PPUSH
60439: LD_INT 4
60441: PPUSH
60442: CALL 46953 0 2
60446: ST_TO_ADDR
// if sort then
60447: LD_VAR 0 9
60451: IFFALSE 60467
// p := sort [ 1 ] ;
60453: LD_ADDR_VAR 0 11
60457: PUSH
60458: LD_VAR 0 9
60462: PUSH
60463: LD_INT 1
60465: ARRAY
60466: ST_TO_ADDR
// if p then
60467: LD_VAR 0 11
60471: IFFALSE 60496
// result := Replace ( result , 4 , p ) ;
60473: LD_ADDR_VAR 0 2
60477: PUSH
60478: LD_VAR 0 2
60482: PPUSH
60483: LD_INT 4
60485: PPUSH
60486: LD_VAR 0 11
60490: PPUSH
60491: CALL_OW 1
60495: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60496: LD_ADDR_VAR 0 4
60500: PUSH
60501: LD_VAR 0 4
60505: PUSH
60506: LD_VAR 0 7
60510: DIFF
60511: ST_TO_ADDR
// if tmp and mech < 6 then
60512: LD_VAR 0 4
60516: PUSH
60517: LD_VAR 0 7
60521: PUSH
60522: LD_INT 6
60524: LESS
60525: AND
60526: IFFALSE 60708
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60528: LD_ADDR_VAR 0 9
60532: PUSH
60533: LD_VAR 0 4
60537: PUSH
60538: LD_VAR 0 7
60542: DIFF
60543: PPUSH
60544: LD_INT 3
60546: PPUSH
60547: CALL 46953 0 2
60551: ST_TO_ADDR
// p := [ ] ;
60552: LD_ADDR_VAR 0 11
60556: PUSH
60557: EMPTY
60558: ST_TO_ADDR
// if sort then
60559: LD_VAR 0 9
60563: IFFALSE 60679
// for i = 1 to 6 - mech do
60565: LD_ADDR_VAR 0 3
60569: PUSH
60570: DOUBLE
60571: LD_INT 1
60573: DEC
60574: ST_TO_ADDR
60575: LD_INT 6
60577: PUSH
60578: LD_VAR 0 7
60582: MINUS
60583: PUSH
60584: FOR_TO
60585: IFFALSE 60677
// begin if i = sort then
60587: LD_VAR 0 3
60591: PUSH
60592: LD_VAR 0 9
60596: EQUAL
60597: IFFALSE 60601
// break ;
60599: GO 60677
// if GetClass ( i ) = 3 then
60601: LD_VAR 0 3
60605: PPUSH
60606: CALL_OW 257
60610: PUSH
60611: LD_INT 3
60613: EQUAL
60614: IFFALSE 60618
// continue ;
60616: GO 60584
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60618: LD_ADDR_VAR 0 11
60622: PUSH
60623: LD_VAR 0 11
60627: PPUSH
60628: LD_VAR 0 11
60632: PUSH
60633: LD_INT 1
60635: PLUS
60636: PPUSH
60637: LD_VAR 0 9
60641: PUSH
60642: LD_VAR 0 3
60646: ARRAY
60647: PPUSH
60648: CALL_OW 2
60652: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60653: LD_ADDR_VAR 0 4
60657: PUSH
60658: LD_VAR 0 4
60662: PUSH
60663: LD_VAR 0 9
60667: PUSH
60668: LD_VAR 0 3
60672: ARRAY
60673: DIFF
60674: ST_TO_ADDR
// end ;
60675: GO 60584
60677: POP
60678: POP
// if p then
60679: LD_VAR 0 11
60683: IFFALSE 60708
// result := Replace ( result , 3 , p ) ;
60685: LD_ADDR_VAR 0 2
60689: PUSH
60690: LD_VAR 0 2
60694: PPUSH
60695: LD_INT 3
60697: PPUSH
60698: LD_VAR 0 11
60702: PPUSH
60703: CALL_OW 1
60707: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60708: LD_ADDR_VAR 0 4
60712: PUSH
60713: LD_VAR 0 4
60717: PUSH
60718: LD_VAR 0 6
60722: DIFF
60723: ST_TO_ADDR
// if tmp and eng < 4 then
60724: LD_VAR 0 4
60728: PUSH
60729: LD_VAR 0 6
60733: PUSH
60734: LD_INT 4
60736: LESS
60737: AND
60738: IFFALSE 60928
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60740: LD_ADDR_VAR 0 9
60744: PUSH
60745: LD_VAR 0 4
60749: PUSH
60750: LD_VAR 0 7
60754: PUSH
60755: LD_VAR 0 6
60759: UNION
60760: DIFF
60761: PPUSH
60762: LD_INT 2
60764: PPUSH
60765: CALL 46953 0 2
60769: ST_TO_ADDR
// p := [ ] ;
60770: LD_ADDR_VAR 0 11
60774: PUSH
60775: EMPTY
60776: ST_TO_ADDR
// if sort then
60777: LD_VAR 0 9
60781: IFFALSE 60897
// for i = 1 to 4 - eng do
60783: LD_ADDR_VAR 0 3
60787: PUSH
60788: DOUBLE
60789: LD_INT 1
60791: DEC
60792: ST_TO_ADDR
60793: LD_INT 4
60795: PUSH
60796: LD_VAR 0 6
60800: MINUS
60801: PUSH
60802: FOR_TO
60803: IFFALSE 60895
// begin if i = sort then
60805: LD_VAR 0 3
60809: PUSH
60810: LD_VAR 0 9
60814: EQUAL
60815: IFFALSE 60819
// break ;
60817: GO 60895
// if GetClass ( i ) = 2 then
60819: LD_VAR 0 3
60823: PPUSH
60824: CALL_OW 257
60828: PUSH
60829: LD_INT 2
60831: EQUAL
60832: IFFALSE 60836
// continue ;
60834: GO 60802
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60836: LD_ADDR_VAR 0 11
60840: PUSH
60841: LD_VAR 0 11
60845: PPUSH
60846: LD_VAR 0 11
60850: PUSH
60851: LD_INT 1
60853: PLUS
60854: PPUSH
60855: LD_VAR 0 9
60859: PUSH
60860: LD_VAR 0 3
60864: ARRAY
60865: PPUSH
60866: CALL_OW 2
60870: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60871: LD_ADDR_VAR 0 4
60875: PUSH
60876: LD_VAR 0 4
60880: PUSH
60881: LD_VAR 0 9
60885: PUSH
60886: LD_VAR 0 3
60890: ARRAY
60891: DIFF
60892: ST_TO_ADDR
// end ;
60893: GO 60802
60895: POP
60896: POP
// if p then
60897: LD_VAR 0 11
60901: IFFALSE 60926
// result := Replace ( result , 2 , p ) ;
60903: LD_ADDR_VAR 0 2
60907: PUSH
60908: LD_VAR 0 2
60912: PPUSH
60913: LD_INT 2
60915: PPUSH
60916: LD_VAR 0 11
60920: PPUSH
60921: CALL_OW 1
60925: ST_TO_ADDR
// end else
60926: GO 60972
// for i = eng downto 5 do
60928: LD_ADDR_VAR 0 3
60932: PUSH
60933: DOUBLE
60934: LD_VAR 0 6
60938: INC
60939: ST_TO_ADDR
60940: LD_INT 5
60942: PUSH
60943: FOR_DOWNTO
60944: IFFALSE 60970
// tmp := tmp union eng [ i ] ;
60946: LD_ADDR_VAR 0 4
60950: PUSH
60951: LD_VAR 0 4
60955: PUSH
60956: LD_VAR 0 6
60960: PUSH
60961: LD_VAR 0 3
60965: ARRAY
60966: UNION
60967: ST_TO_ADDR
60968: GO 60943
60970: POP
60971: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60972: LD_ADDR_VAR 0 2
60976: PUSH
60977: LD_VAR 0 2
60981: PPUSH
60982: LD_INT 1
60984: PPUSH
60985: LD_VAR 0 4
60989: PUSH
60990: LD_VAR 0 5
60994: DIFF
60995: PPUSH
60996: CALL_OW 1
61000: ST_TO_ADDR
// exit ;
61001: GO 61003
// end ; end ;
61003: LD_VAR 0 2
61007: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
61008: LD_INT 0
61010: PPUSH
61011: PPUSH
61012: PPUSH
// if not mc_bases then
61013: LD_EXP 23
61017: NOT
61018: IFFALSE 61022
// exit ;
61020: GO 61164
// for i = 1 to mc_bases do
61022: LD_ADDR_VAR 0 2
61026: PUSH
61027: DOUBLE
61028: LD_INT 1
61030: DEC
61031: ST_TO_ADDR
61032: LD_EXP 23
61036: PUSH
61037: FOR_TO
61038: IFFALSE 61155
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
61040: LD_ADDR_VAR 0 3
61044: PUSH
61045: LD_EXP 23
61049: PUSH
61050: LD_VAR 0 2
61054: ARRAY
61055: PPUSH
61056: LD_INT 21
61058: PUSH
61059: LD_INT 3
61061: PUSH
61062: EMPTY
61063: LIST
61064: LIST
61065: PUSH
61066: LD_INT 3
61068: PUSH
61069: LD_INT 2
61071: PUSH
61072: LD_INT 30
61074: PUSH
61075: LD_INT 29
61077: PUSH
61078: EMPTY
61079: LIST
61080: LIST
61081: PUSH
61082: LD_INT 30
61084: PUSH
61085: LD_INT 30
61087: PUSH
61088: EMPTY
61089: LIST
61090: LIST
61091: PUSH
61092: EMPTY
61093: LIST
61094: LIST
61095: LIST
61096: PUSH
61097: EMPTY
61098: LIST
61099: LIST
61100: PUSH
61101: LD_INT 3
61103: PUSH
61104: LD_INT 24
61106: PUSH
61107: LD_INT 1000
61109: PUSH
61110: EMPTY
61111: LIST
61112: LIST
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: LIST
61122: PPUSH
61123: CALL_OW 72
61127: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
61128: LD_ADDR_EXP 24
61132: PUSH
61133: LD_EXP 24
61137: PPUSH
61138: LD_VAR 0 2
61142: PPUSH
61143: LD_VAR 0 3
61147: PPUSH
61148: CALL_OW 1
61152: ST_TO_ADDR
// end ;
61153: GO 61037
61155: POP
61156: POP
// RaiseSailEvent ( 101 ) ;
61157: LD_INT 101
61159: PPUSH
61160: CALL_OW 427
// end ;
61164: LD_VAR 0 1
61168: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
61169: LD_INT 0
61171: PPUSH
61172: PPUSH
61173: PPUSH
61174: PPUSH
61175: PPUSH
61176: PPUSH
61177: PPUSH
// if not mc_bases then
61178: LD_EXP 23
61182: NOT
61183: IFFALSE 61187
// exit ;
61185: GO 61749
// for i = 1 to mc_bases do
61187: LD_ADDR_VAR 0 2
61191: PUSH
61192: DOUBLE
61193: LD_INT 1
61195: DEC
61196: ST_TO_ADDR
61197: LD_EXP 23
61201: PUSH
61202: FOR_TO
61203: IFFALSE 61740
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
61205: LD_ADDR_VAR 0 5
61209: PUSH
61210: LD_EXP 23
61214: PUSH
61215: LD_VAR 0 2
61219: ARRAY
61220: PUSH
61221: LD_EXP 52
61225: PUSH
61226: LD_VAR 0 2
61230: ARRAY
61231: UNION
61232: PPUSH
61233: LD_INT 21
61235: PUSH
61236: LD_INT 1
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: PUSH
61243: LD_INT 1
61245: PUSH
61246: LD_INT 3
61248: PUSH
61249: LD_INT 54
61251: PUSH
61252: EMPTY
61253: LIST
61254: PUSH
61255: EMPTY
61256: LIST
61257: LIST
61258: PUSH
61259: LD_INT 3
61261: PUSH
61262: LD_INT 24
61264: PUSH
61265: LD_INT 1000
61267: PUSH
61268: EMPTY
61269: LIST
61270: LIST
61271: PUSH
61272: EMPTY
61273: LIST
61274: LIST
61275: PUSH
61276: EMPTY
61277: LIST
61278: LIST
61279: LIST
61280: PUSH
61281: EMPTY
61282: LIST
61283: LIST
61284: PPUSH
61285: CALL_OW 72
61289: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
61290: LD_ADDR_VAR 0 6
61294: PUSH
61295: LD_EXP 23
61299: PUSH
61300: LD_VAR 0 2
61304: ARRAY
61305: PPUSH
61306: LD_INT 21
61308: PUSH
61309: LD_INT 1
61311: PUSH
61312: EMPTY
61313: LIST
61314: LIST
61315: PUSH
61316: LD_INT 1
61318: PUSH
61319: LD_INT 3
61321: PUSH
61322: LD_INT 54
61324: PUSH
61325: EMPTY
61326: LIST
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: PUSH
61332: LD_INT 3
61334: PUSH
61335: LD_INT 24
61337: PUSH
61338: LD_INT 250
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: PUSH
61349: EMPTY
61350: LIST
61351: LIST
61352: LIST
61353: PUSH
61354: EMPTY
61355: LIST
61356: LIST
61357: PPUSH
61358: CALL_OW 72
61362: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
61363: LD_ADDR_VAR 0 7
61367: PUSH
61368: LD_VAR 0 5
61372: PUSH
61373: LD_VAR 0 6
61377: DIFF
61378: ST_TO_ADDR
// if not need_heal_1 then
61379: LD_VAR 0 6
61383: NOT
61384: IFFALSE 61417
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
61386: LD_ADDR_EXP 26
61390: PUSH
61391: LD_EXP 26
61395: PPUSH
61396: LD_VAR 0 2
61400: PUSH
61401: LD_INT 1
61403: PUSH
61404: EMPTY
61405: LIST
61406: LIST
61407: PPUSH
61408: EMPTY
61409: PPUSH
61410: CALL 16077 0 3
61414: ST_TO_ADDR
61415: GO 61487
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61417: LD_ADDR_EXP 26
61421: PUSH
61422: LD_EXP 26
61426: PPUSH
61427: LD_VAR 0 2
61431: PUSH
61432: LD_INT 1
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: PPUSH
61439: LD_EXP 26
61443: PUSH
61444: LD_VAR 0 2
61448: ARRAY
61449: PUSH
61450: LD_INT 1
61452: ARRAY
61453: PPUSH
61454: LD_INT 3
61456: PUSH
61457: LD_INT 24
61459: PUSH
61460: LD_INT 1000
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: PUSH
61467: EMPTY
61468: LIST
61469: LIST
61470: PPUSH
61471: CALL_OW 72
61475: PUSH
61476: LD_VAR 0 6
61480: UNION
61481: PPUSH
61482: CALL 16077 0 3
61486: ST_TO_ADDR
// if not need_heal_2 then
61487: LD_VAR 0 7
61491: NOT
61492: IFFALSE 61525
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61494: LD_ADDR_EXP 26
61498: PUSH
61499: LD_EXP 26
61503: PPUSH
61504: LD_VAR 0 2
61508: PUSH
61509: LD_INT 2
61511: PUSH
61512: EMPTY
61513: LIST
61514: LIST
61515: PPUSH
61516: EMPTY
61517: PPUSH
61518: CALL 16077 0 3
61522: ST_TO_ADDR
61523: GO 61557
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61525: LD_ADDR_EXP 26
61529: PUSH
61530: LD_EXP 26
61534: PPUSH
61535: LD_VAR 0 2
61539: PUSH
61540: LD_INT 2
61542: PUSH
61543: EMPTY
61544: LIST
61545: LIST
61546: PPUSH
61547: LD_VAR 0 7
61551: PPUSH
61552: CALL 16077 0 3
61556: ST_TO_ADDR
// if need_heal_2 then
61557: LD_VAR 0 7
61561: IFFALSE 61722
// for j in need_heal_2 do
61563: LD_ADDR_VAR 0 3
61567: PUSH
61568: LD_VAR 0 7
61572: PUSH
61573: FOR_IN
61574: IFFALSE 61720
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61576: LD_ADDR_VAR 0 5
61580: PUSH
61581: LD_EXP 23
61585: PUSH
61586: LD_VAR 0 2
61590: ARRAY
61591: PPUSH
61592: LD_INT 2
61594: PUSH
61595: LD_INT 30
61597: PUSH
61598: LD_INT 6
61600: PUSH
61601: EMPTY
61602: LIST
61603: LIST
61604: PUSH
61605: LD_INT 30
61607: PUSH
61608: LD_INT 7
61610: PUSH
61611: EMPTY
61612: LIST
61613: LIST
61614: PUSH
61615: LD_INT 30
61617: PUSH
61618: LD_INT 8
61620: PUSH
61621: EMPTY
61622: LIST
61623: LIST
61624: PUSH
61625: LD_INT 30
61627: PUSH
61628: LD_INT 0
61630: PUSH
61631: EMPTY
61632: LIST
61633: LIST
61634: PUSH
61635: LD_INT 30
61637: PUSH
61638: LD_INT 1
61640: PUSH
61641: EMPTY
61642: LIST
61643: LIST
61644: PUSH
61645: EMPTY
61646: LIST
61647: LIST
61648: LIST
61649: LIST
61650: LIST
61651: LIST
61652: PPUSH
61653: CALL_OW 72
61657: ST_TO_ADDR
// if tmp then
61658: LD_VAR 0 5
61662: IFFALSE 61718
// begin k := NearestUnitToUnit ( tmp , j ) ;
61664: LD_ADDR_VAR 0 4
61668: PUSH
61669: LD_VAR 0 5
61673: PPUSH
61674: LD_VAR 0 3
61678: PPUSH
61679: CALL_OW 74
61683: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61684: LD_VAR 0 3
61688: PPUSH
61689: LD_VAR 0 4
61693: PPUSH
61694: CALL_OW 296
61698: PUSH
61699: LD_INT 5
61701: GREATER
61702: IFFALSE 61718
// ComMoveToNearbyEntrance ( j , k ) ;
61704: LD_VAR 0 3
61708: PPUSH
61709: LD_VAR 0 4
61713: PPUSH
61714: CALL 49313 0 2
// end ; end ;
61718: GO 61573
61720: POP
61721: POP
// if not need_heal_1 and not need_heal_2 then
61722: LD_VAR 0 6
61726: NOT
61727: PUSH
61728: LD_VAR 0 7
61732: NOT
61733: AND
61734: IFFALSE 61738
// continue ;
61736: GO 61202
// end ;
61738: GO 61202
61740: POP
61741: POP
// RaiseSailEvent ( 102 ) ;
61742: LD_INT 102
61744: PPUSH
61745: CALL_OW 427
// end ;
61749: LD_VAR 0 1
61753: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61754: LD_INT 0
61756: PPUSH
61757: PPUSH
61758: PPUSH
61759: PPUSH
61760: PPUSH
61761: PPUSH
61762: PPUSH
61763: PPUSH
// if not mc_bases then
61764: LD_EXP 23
61768: NOT
61769: IFFALSE 61773
// exit ;
61771: GO 62684
// for i = 1 to mc_bases do
61773: LD_ADDR_VAR 0 2
61777: PUSH
61778: DOUBLE
61779: LD_INT 1
61781: DEC
61782: ST_TO_ADDR
61783: LD_EXP 23
61787: PUSH
61788: FOR_TO
61789: IFFALSE 62682
// begin if not mc_building_need_repair [ i ] then
61791: LD_EXP 24
61795: PUSH
61796: LD_VAR 0 2
61800: ARRAY
61801: NOT
61802: IFFALSE 61987
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61804: LD_ADDR_VAR 0 6
61808: PUSH
61809: LD_EXP 42
61813: PUSH
61814: LD_VAR 0 2
61818: ARRAY
61819: PPUSH
61820: LD_INT 3
61822: PUSH
61823: LD_INT 24
61825: PUSH
61826: LD_INT 1000
61828: PUSH
61829: EMPTY
61830: LIST
61831: LIST
61832: PUSH
61833: EMPTY
61834: LIST
61835: LIST
61836: PUSH
61837: LD_INT 2
61839: PUSH
61840: LD_INT 34
61842: PUSH
61843: LD_INT 13
61845: PUSH
61846: EMPTY
61847: LIST
61848: LIST
61849: PUSH
61850: LD_INT 34
61852: PUSH
61853: LD_INT 52
61855: PUSH
61856: EMPTY
61857: LIST
61858: LIST
61859: PUSH
61860: LD_INT 34
61862: PUSH
61863: LD_INT 88
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: PUSH
61870: EMPTY
61871: LIST
61872: LIST
61873: LIST
61874: LIST
61875: PUSH
61876: EMPTY
61877: LIST
61878: LIST
61879: PPUSH
61880: CALL_OW 72
61884: ST_TO_ADDR
// if cranes then
61885: LD_VAR 0 6
61889: IFFALSE 61951
// for j in cranes do
61891: LD_ADDR_VAR 0 3
61895: PUSH
61896: LD_VAR 0 6
61900: PUSH
61901: FOR_IN
61902: IFFALSE 61949
// if not IsInArea ( j , mc_parking [ i ] ) then
61904: LD_VAR 0 3
61908: PPUSH
61909: LD_EXP 47
61913: PUSH
61914: LD_VAR 0 2
61918: ARRAY
61919: PPUSH
61920: CALL_OW 308
61924: NOT
61925: IFFALSE 61947
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61927: LD_VAR 0 3
61931: PPUSH
61932: LD_EXP 47
61936: PUSH
61937: LD_VAR 0 2
61941: ARRAY
61942: PPUSH
61943: CALL_OW 113
61947: GO 61901
61949: POP
61950: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61951: LD_ADDR_EXP 25
61955: PUSH
61956: LD_EXP 25
61960: PPUSH
61961: LD_VAR 0 2
61965: PPUSH
61966: EMPTY
61967: PPUSH
61968: CALL_OW 1
61972: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61973: LD_VAR 0 2
61977: PPUSH
61978: LD_INT 101
61980: PPUSH
61981: CALL 56827 0 2
// continue ;
61985: GO 61788
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61987: LD_ADDR_EXP 29
61991: PUSH
61992: LD_EXP 29
61996: PPUSH
61997: LD_VAR 0 2
62001: PPUSH
62002: EMPTY
62003: PPUSH
62004: CALL_OW 1
62008: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62009: LD_VAR 0 2
62013: PPUSH
62014: LD_INT 103
62016: PPUSH
62017: CALL 56827 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
62021: LD_ADDR_VAR 0 5
62025: PUSH
62026: LD_EXP 23
62030: PUSH
62031: LD_VAR 0 2
62035: ARRAY
62036: PUSH
62037: LD_EXP 52
62041: PUSH
62042: LD_VAR 0 2
62046: ARRAY
62047: UNION
62048: PPUSH
62049: LD_INT 2
62051: PUSH
62052: LD_INT 25
62054: PUSH
62055: LD_INT 2
62057: PUSH
62058: EMPTY
62059: LIST
62060: LIST
62061: PUSH
62062: LD_INT 25
62064: PUSH
62065: LD_INT 16
62067: PUSH
62068: EMPTY
62069: LIST
62070: LIST
62071: PUSH
62072: EMPTY
62073: LIST
62074: LIST
62075: LIST
62076: PUSH
62077: EMPTY
62078: LIST
62079: PPUSH
62080: CALL_OW 72
62084: ST_TO_ADDR
// if mc_need_heal [ i ] then
62085: LD_EXP 26
62089: PUSH
62090: LD_VAR 0 2
62094: ARRAY
62095: IFFALSE 62139
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
62097: LD_ADDR_VAR 0 5
62101: PUSH
62102: LD_VAR 0 5
62106: PUSH
62107: LD_EXP 26
62111: PUSH
62112: LD_VAR 0 2
62116: ARRAY
62117: PUSH
62118: LD_INT 1
62120: ARRAY
62121: PUSH
62122: LD_EXP 26
62126: PUSH
62127: LD_VAR 0 2
62131: ARRAY
62132: PUSH
62133: LD_INT 2
62135: ARRAY
62136: UNION
62137: DIFF
62138: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
62139: LD_ADDR_VAR 0 6
62143: PUSH
62144: LD_EXP 42
62148: PUSH
62149: LD_VAR 0 2
62153: ARRAY
62154: PPUSH
62155: LD_INT 2
62157: PUSH
62158: LD_INT 34
62160: PUSH
62161: LD_INT 13
62163: PUSH
62164: EMPTY
62165: LIST
62166: LIST
62167: PUSH
62168: LD_INT 34
62170: PUSH
62171: LD_INT 52
62173: PUSH
62174: EMPTY
62175: LIST
62176: LIST
62177: PUSH
62178: LD_INT 34
62180: PUSH
62181: LD_INT 88
62183: PUSH
62184: EMPTY
62185: LIST
62186: LIST
62187: PUSH
62188: EMPTY
62189: LIST
62190: LIST
62191: LIST
62192: LIST
62193: PPUSH
62194: CALL_OW 72
62198: ST_TO_ADDR
// if cranes then
62199: LD_VAR 0 6
62203: IFFALSE 62371
// begin for j in cranes do
62205: LD_ADDR_VAR 0 3
62209: PUSH
62210: LD_VAR 0 6
62214: PUSH
62215: FOR_IN
62216: IFFALSE 62369
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
62218: LD_VAR 0 3
62222: PPUSH
62223: CALL_OW 256
62227: PUSH
62228: LD_INT 1000
62230: EQUAL
62231: PUSH
62232: LD_VAR 0 3
62236: PPUSH
62237: CALL_OW 314
62241: NOT
62242: AND
62243: IFFALSE 62309
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
62245: LD_ADDR_VAR 0 8
62249: PUSH
62250: LD_EXP 24
62254: PUSH
62255: LD_VAR 0 2
62259: ARRAY
62260: PPUSH
62261: LD_VAR 0 3
62265: PPUSH
62266: CALL_OW 74
62270: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
62271: LD_VAR 0 8
62275: PPUSH
62276: LD_INT 16
62278: PPUSH
62279: CALL 18674 0 2
62283: PUSH
62284: LD_INT 4
62286: ARRAY
62287: PUSH
62288: LD_INT 10
62290: LESS
62291: IFFALSE 62307
// ComRepairBuilding ( j , to_repair ) ;
62293: LD_VAR 0 3
62297: PPUSH
62298: LD_VAR 0 8
62302: PPUSH
62303: CALL_OW 130
// end else
62307: GO 62367
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
62309: LD_VAR 0 3
62313: PPUSH
62314: CALL_OW 256
62318: PUSH
62319: LD_INT 500
62321: LESS
62322: PUSH
62323: LD_VAR 0 3
62327: PPUSH
62328: LD_EXP 47
62332: PUSH
62333: LD_VAR 0 2
62337: ARRAY
62338: PPUSH
62339: CALL_OW 308
62343: NOT
62344: AND
62345: IFFALSE 62367
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62347: LD_VAR 0 3
62351: PPUSH
62352: LD_EXP 47
62356: PUSH
62357: LD_VAR 0 2
62361: ARRAY
62362: PPUSH
62363: CALL_OW 113
// end ;
62367: GO 62215
62369: POP
62370: POP
// end ; if tmp > 3 then
62371: LD_VAR 0 5
62375: PUSH
62376: LD_INT 3
62378: GREATER
62379: IFFALSE 62399
// tmp := ShrinkArray ( tmp , 4 ) ;
62381: LD_ADDR_VAR 0 5
62385: PUSH
62386: LD_VAR 0 5
62390: PPUSH
62391: LD_INT 4
62393: PPUSH
62394: CALL 48751 0 2
62398: ST_TO_ADDR
// if not tmp then
62399: LD_VAR 0 5
62403: NOT
62404: IFFALSE 62408
// continue ;
62406: GO 61788
// for j in tmp do
62408: LD_ADDR_VAR 0 3
62412: PUSH
62413: LD_VAR 0 5
62417: PUSH
62418: FOR_IN
62419: IFFALSE 62678
// begin if IsInUnit ( j ) then
62421: LD_VAR 0 3
62425: PPUSH
62426: CALL_OW 310
62430: IFFALSE 62441
// ComExitBuilding ( j ) ;
62432: LD_VAR 0 3
62436: PPUSH
62437: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62441: LD_VAR 0 3
62445: PUSH
62446: LD_EXP 25
62450: PUSH
62451: LD_VAR 0 2
62455: ARRAY
62456: IN
62457: NOT
62458: IFFALSE 62516
// begin SetTag ( j , 101 ) ;
62460: LD_VAR 0 3
62464: PPUSH
62465: LD_INT 101
62467: PPUSH
62468: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62472: LD_ADDR_EXP 25
62476: PUSH
62477: LD_EXP 25
62481: PPUSH
62482: LD_VAR 0 2
62486: PUSH
62487: LD_EXP 25
62491: PUSH
62492: LD_VAR 0 2
62496: ARRAY
62497: PUSH
62498: LD_INT 1
62500: PLUS
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: PPUSH
62506: LD_VAR 0 3
62510: PPUSH
62511: CALL 16077 0 3
62515: ST_TO_ADDR
// end ; wait ( 1 ) ;
62516: LD_INT 1
62518: PPUSH
62519: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62523: LD_ADDR_VAR 0 7
62527: PUSH
62528: LD_EXP 24
62532: PUSH
62533: LD_VAR 0 2
62537: ARRAY
62538: ST_TO_ADDR
// if mc_scan [ i ] then
62539: LD_EXP 46
62543: PUSH
62544: LD_VAR 0 2
62548: ARRAY
62549: IFFALSE 62611
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62551: LD_ADDR_VAR 0 7
62555: PUSH
62556: LD_EXP 24
62560: PUSH
62561: LD_VAR 0 2
62565: ARRAY
62566: PPUSH
62567: LD_INT 3
62569: PUSH
62570: LD_INT 30
62572: PUSH
62573: LD_INT 32
62575: PUSH
62576: EMPTY
62577: LIST
62578: LIST
62579: PUSH
62580: LD_INT 30
62582: PUSH
62583: LD_INT 33
62585: PUSH
62586: EMPTY
62587: LIST
62588: LIST
62589: PUSH
62590: LD_INT 30
62592: PUSH
62593: LD_INT 31
62595: PUSH
62596: EMPTY
62597: LIST
62598: LIST
62599: PUSH
62600: EMPTY
62601: LIST
62602: LIST
62603: LIST
62604: LIST
62605: PPUSH
62606: CALL_OW 72
62610: ST_TO_ADDR
// if not to_repair_tmp then
62611: LD_VAR 0 7
62615: NOT
62616: IFFALSE 62620
// continue ;
62618: GO 62418
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62620: LD_ADDR_VAR 0 8
62624: PUSH
62625: LD_VAR 0 7
62629: PPUSH
62630: LD_VAR 0 3
62634: PPUSH
62635: CALL_OW 74
62639: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
62640: LD_VAR 0 8
62644: PPUSH
62645: LD_INT 16
62647: PPUSH
62648: CALL 18674 0 2
62652: PUSH
62653: LD_INT 4
62655: ARRAY
62656: PUSH
62657: LD_INT 14
62659: LESS
62660: IFFALSE 62676
// ComRepairBuilding ( j , to_repair ) ;
62662: LD_VAR 0 3
62666: PPUSH
62667: LD_VAR 0 8
62671: PPUSH
62672: CALL_OW 130
// end ;
62676: GO 62418
62678: POP
62679: POP
// end ;
62680: GO 61788
62682: POP
62683: POP
// end ;
62684: LD_VAR 0 1
62688: RET
// export function MC_Heal ; var i , j , tmp ; begin
62689: LD_INT 0
62691: PPUSH
62692: PPUSH
62693: PPUSH
62694: PPUSH
// if not mc_bases then
62695: LD_EXP 23
62699: NOT
62700: IFFALSE 62704
// exit ;
62702: GO 63106
// for i = 1 to mc_bases do
62704: LD_ADDR_VAR 0 2
62708: PUSH
62709: DOUBLE
62710: LD_INT 1
62712: DEC
62713: ST_TO_ADDR
62714: LD_EXP 23
62718: PUSH
62719: FOR_TO
62720: IFFALSE 63104
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62722: LD_EXP 26
62726: PUSH
62727: LD_VAR 0 2
62731: ARRAY
62732: PUSH
62733: LD_INT 1
62735: ARRAY
62736: NOT
62737: PUSH
62738: LD_EXP 26
62742: PUSH
62743: LD_VAR 0 2
62747: ARRAY
62748: PUSH
62749: LD_INT 2
62751: ARRAY
62752: NOT
62753: AND
62754: IFFALSE 62792
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62756: LD_ADDR_EXP 27
62760: PUSH
62761: LD_EXP 27
62765: PPUSH
62766: LD_VAR 0 2
62770: PPUSH
62771: EMPTY
62772: PPUSH
62773: CALL_OW 1
62777: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62778: LD_VAR 0 2
62782: PPUSH
62783: LD_INT 102
62785: PPUSH
62786: CALL 56827 0 2
// continue ;
62790: GO 62719
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62792: LD_ADDR_VAR 0 4
62796: PUSH
62797: LD_EXP 23
62801: PUSH
62802: LD_VAR 0 2
62806: ARRAY
62807: PPUSH
62808: LD_INT 25
62810: PUSH
62811: LD_INT 4
62813: PUSH
62814: EMPTY
62815: LIST
62816: LIST
62817: PPUSH
62818: CALL_OW 72
62822: ST_TO_ADDR
// if not tmp then
62823: LD_VAR 0 4
62827: NOT
62828: IFFALSE 62832
// continue ;
62830: GO 62719
// if mc_taming [ i ] then
62832: LD_EXP 54
62836: PUSH
62837: LD_VAR 0 2
62841: ARRAY
62842: IFFALSE 62866
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62844: LD_ADDR_EXP 54
62848: PUSH
62849: LD_EXP 54
62853: PPUSH
62854: LD_VAR 0 2
62858: PPUSH
62859: EMPTY
62860: PPUSH
62861: CALL_OW 1
62865: ST_TO_ADDR
// for j in tmp do
62866: LD_ADDR_VAR 0 3
62870: PUSH
62871: LD_VAR 0 4
62875: PUSH
62876: FOR_IN
62877: IFFALSE 63100
// begin if IsInUnit ( j ) then
62879: LD_VAR 0 3
62883: PPUSH
62884: CALL_OW 310
62888: IFFALSE 62899
// ComExitBuilding ( j ) ;
62890: LD_VAR 0 3
62894: PPUSH
62895: CALL_OW 122
// if not j in mc_healers [ i ] then
62899: LD_VAR 0 3
62903: PUSH
62904: LD_EXP 27
62908: PUSH
62909: LD_VAR 0 2
62913: ARRAY
62914: IN
62915: NOT
62916: IFFALSE 62962
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62918: LD_ADDR_EXP 27
62922: PUSH
62923: LD_EXP 27
62927: PPUSH
62928: LD_VAR 0 2
62932: PUSH
62933: LD_EXP 27
62937: PUSH
62938: LD_VAR 0 2
62942: ARRAY
62943: PUSH
62944: LD_INT 1
62946: PLUS
62947: PUSH
62948: EMPTY
62949: LIST
62950: LIST
62951: PPUSH
62952: LD_VAR 0 3
62956: PPUSH
62957: CALL 16077 0 3
62961: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62962: LD_VAR 0 3
62966: PPUSH
62967: CALL_OW 110
62971: PUSH
62972: LD_INT 102
62974: NONEQUAL
62975: IFFALSE 62989
// SetTag ( j , 102 ) ;
62977: LD_VAR 0 3
62981: PPUSH
62982: LD_INT 102
62984: PPUSH
62985: CALL_OW 109
// Wait ( 3 ) ;
62989: LD_INT 3
62991: PPUSH
62992: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62996: LD_EXP 26
63000: PUSH
63001: LD_VAR 0 2
63005: ARRAY
63006: PUSH
63007: LD_INT 1
63009: ARRAY
63010: IFFALSE 63042
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
63012: LD_VAR 0 3
63016: PPUSH
63017: LD_EXP 26
63021: PUSH
63022: LD_VAR 0 2
63026: ARRAY
63027: PUSH
63028: LD_INT 1
63030: ARRAY
63031: PUSH
63032: LD_INT 1
63034: ARRAY
63035: PPUSH
63036: CALL_OW 128
63040: GO 63098
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
63042: LD_VAR 0 3
63046: PPUSH
63047: CALL_OW 314
63051: NOT
63052: PUSH
63053: LD_EXP 26
63057: PUSH
63058: LD_VAR 0 2
63062: ARRAY
63063: PUSH
63064: LD_INT 2
63066: ARRAY
63067: AND
63068: IFFALSE 63098
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
63070: LD_VAR 0 3
63074: PPUSH
63075: LD_EXP 26
63079: PUSH
63080: LD_VAR 0 2
63084: ARRAY
63085: PUSH
63086: LD_INT 2
63088: ARRAY
63089: PUSH
63090: LD_INT 1
63092: ARRAY
63093: PPUSH
63094: CALL_OW 128
// end ;
63098: GO 62876
63100: POP
63101: POP
// end ;
63102: GO 62719
63104: POP
63105: POP
// end ;
63106: LD_VAR 0 1
63110: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
63111: LD_INT 0
63113: PPUSH
63114: PPUSH
63115: PPUSH
63116: PPUSH
63117: PPUSH
63118: PPUSH
// if not mc_bases then
63119: LD_EXP 23
63123: NOT
63124: IFFALSE 63128
// exit ;
63126: GO 64291
// for i = 1 to mc_bases do
63128: LD_ADDR_VAR 0 2
63132: PUSH
63133: DOUBLE
63134: LD_INT 1
63136: DEC
63137: ST_TO_ADDR
63138: LD_EXP 23
63142: PUSH
63143: FOR_TO
63144: IFFALSE 64289
// begin if mc_scan [ i ] then
63146: LD_EXP 46
63150: PUSH
63151: LD_VAR 0 2
63155: ARRAY
63156: IFFALSE 63160
// continue ;
63158: GO 63143
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
63160: LD_EXP 28
63164: PUSH
63165: LD_VAR 0 2
63169: ARRAY
63170: NOT
63171: PUSH
63172: LD_EXP 30
63176: PUSH
63177: LD_VAR 0 2
63181: ARRAY
63182: NOT
63183: AND
63184: PUSH
63185: LD_EXP 29
63189: PUSH
63190: LD_VAR 0 2
63194: ARRAY
63195: AND
63196: IFFALSE 63234
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
63198: LD_ADDR_EXP 29
63202: PUSH
63203: LD_EXP 29
63207: PPUSH
63208: LD_VAR 0 2
63212: PPUSH
63213: EMPTY
63214: PPUSH
63215: CALL_OW 1
63219: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63220: LD_VAR 0 2
63224: PPUSH
63225: LD_INT 103
63227: PPUSH
63228: CALL 56827 0 2
// continue ;
63232: GO 63143
// end ; if mc_construct_list [ i ] then
63234: LD_EXP 30
63238: PUSH
63239: LD_VAR 0 2
63243: ARRAY
63244: IFFALSE 63464
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63246: LD_ADDR_VAR 0 5
63250: PUSH
63251: LD_EXP 23
63255: PUSH
63256: LD_VAR 0 2
63260: ARRAY
63261: PPUSH
63262: LD_INT 25
63264: PUSH
63265: LD_INT 2
63267: PUSH
63268: EMPTY
63269: LIST
63270: LIST
63271: PPUSH
63272: CALL_OW 72
63276: PUSH
63277: LD_EXP 25
63281: PUSH
63282: LD_VAR 0 2
63286: ARRAY
63287: DIFF
63288: ST_TO_ADDR
// if not tmp then
63289: LD_VAR 0 5
63293: NOT
63294: IFFALSE 63298
// continue ;
63296: GO 63143
// for j in tmp do
63298: LD_ADDR_VAR 0 3
63302: PUSH
63303: LD_VAR 0 5
63307: PUSH
63308: FOR_IN
63309: IFFALSE 63460
// begin if not mc_builders [ i ] then
63311: LD_EXP 29
63315: PUSH
63316: LD_VAR 0 2
63320: ARRAY
63321: NOT
63322: IFFALSE 63380
// begin SetTag ( j , 103 ) ;
63324: LD_VAR 0 3
63328: PPUSH
63329: LD_INT 103
63331: PPUSH
63332: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63336: LD_ADDR_EXP 29
63340: PUSH
63341: LD_EXP 29
63345: PPUSH
63346: LD_VAR 0 2
63350: PUSH
63351: LD_EXP 29
63355: PUSH
63356: LD_VAR 0 2
63360: ARRAY
63361: PUSH
63362: LD_INT 1
63364: PLUS
63365: PUSH
63366: EMPTY
63367: LIST
63368: LIST
63369: PPUSH
63370: LD_VAR 0 3
63374: PPUSH
63375: CALL 16077 0 3
63379: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63380: LD_VAR 0 3
63384: PPUSH
63385: CALL_OW 310
63389: IFFALSE 63400
// ComExitBuilding ( j ) ;
63391: LD_VAR 0 3
63395: PPUSH
63396: CALL_OW 122
// wait ( 3 ) ;
63400: LD_INT 3
63402: PPUSH
63403: CALL_OW 67
// if not mc_construct_list [ i ] then
63407: LD_EXP 30
63411: PUSH
63412: LD_VAR 0 2
63416: ARRAY
63417: NOT
63418: IFFALSE 63422
// break ;
63420: GO 63460
// if not HasTask ( j ) then
63422: LD_VAR 0 3
63426: PPUSH
63427: CALL_OW 314
63431: NOT
63432: IFFALSE 63458
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63434: LD_VAR 0 3
63438: PPUSH
63439: LD_EXP 30
63443: PUSH
63444: LD_VAR 0 2
63448: ARRAY
63449: PUSH
63450: LD_INT 1
63452: ARRAY
63453: PPUSH
63454: CALL 18947 0 2
// end ;
63458: GO 63308
63460: POP
63461: POP
// end else
63462: GO 64287
// if mc_build_list [ i ] then
63464: LD_EXP 28
63468: PUSH
63469: LD_VAR 0 2
63473: ARRAY
63474: IFFALSE 64287
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63476: LD_EXP 28
63480: PUSH
63481: LD_VAR 0 2
63485: ARRAY
63486: PUSH
63487: LD_INT 1
63489: ARRAY
63490: PUSH
63491: LD_INT 1
63493: ARRAY
63494: PPUSH
63495: CALL 18771 0 1
63499: PUSH
63500: LD_EXP 23
63504: PUSH
63505: LD_VAR 0 2
63509: ARRAY
63510: PPUSH
63511: LD_INT 2
63513: PUSH
63514: LD_INT 30
63516: PUSH
63517: LD_INT 2
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 30
63526: PUSH
63527: LD_INT 3
63529: PUSH
63530: EMPTY
63531: LIST
63532: LIST
63533: PUSH
63534: EMPTY
63535: LIST
63536: LIST
63537: LIST
63538: PPUSH
63539: CALL_OW 72
63543: NOT
63544: AND
63545: IFFALSE 63650
// begin for j = 1 to mc_build_list [ i ] do
63547: LD_ADDR_VAR 0 3
63551: PUSH
63552: DOUBLE
63553: LD_INT 1
63555: DEC
63556: ST_TO_ADDR
63557: LD_EXP 28
63561: PUSH
63562: LD_VAR 0 2
63566: ARRAY
63567: PUSH
63568: FOR_TO
63569: IFFALSE 63648
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63571: LD_EXP 28
63575: PUSH
63576: LD_VAR 0 2
63580: ARRAY
63581: PUSH
63582: LD_VAR 0 3
63586: ARRAY
63587: PUSH
63588: LD_INT 1
63590: ARRAY
63591: PUSH
63592: LD_INT 2
63594: EQUAL
63595: IFFALSE 63646
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63597: LD_ADDR_EXP 28
63601: PUSH
63602: LD_EXP 28
63606: PPUSH
63607: LD_VAR 0 2
63611: PPUSH
63612: LD_EXP 28
63616: PUSH
63617: LD_VAR 0 2
63621: ARRAY
63622: PPUSH
63623: LD_VAR 0 3
63627: PPUSH
63628: LD_INT 1
63630: PPUSH
63631: LD_INT 0
63633: PPUSH
63634: CALL 15495 0 4
63638: PPUSH
63639: CALL_OW 1
63643: ST_TO_ADDR
// break ;
63644: GO 63648
// end ;
63646: GO 63568
63648: POP
63649: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63650: LD_ADDR_VAR 0 6
63654: PUSH
63655: LD_EXP 23
63659: PUSH
63660: LD_VAR 0 2
63664: ARRAY
63665: PPUSH
63666: LD_INT 2
63668: PUSH
63669: LD_INT 30
63671: PUSH
63672: LD_INT 0
63674: PUSH
63675: EMPTY
63676: LIST
63677: LIST
63678: PUSH
63679: LD_INT 30
63681: PUSH
63682: LD_INT 1
63684: PUSH
63685: EMPTY
63686: LIST
63687: LIST
63688: PUSH
63689: EMPTY
63690: LIST
63691: LIST
63692: LIST
63693: PPUSH
63694: CALL_OW 72
63698: ST_TO_ADDR
// for k := 1 to depot do
63699: LD_ADDR_VAR 0 4
63703: PUSH
63704: DOUBLE
63705: LD_INT 1
63707: DEC
63708: ST_TO_ADDR
63709: LD_VAR 0 6
63713: PUSH
63714: FOR_TO
63715: IFFALSE 64285
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
63717: LD_EXP 28
63721: PUSH
63722: LD_VAR 0 2
63726: ARRAY
63727: PUSH
63728: LD_INT 1
63730: ARRAY
63731: PUSH
63732: LD_INT 1
63734: ARRAY
63735: PUSH
63736: LD_INT 0
63738: EQUAL
63739: PUSH
63740: LD_VAR 0 6
63744: PUSH
63745: LD_VAR 0 4
63749: ARRAY
63750: PPUSH
63751: LD_EXP 28
63755: PUSH
63756: LD_VAR 0 2
63760: ARRAY
63761: PUSH
63762: LD_INT 1
63764: ARRAY
63765: PUSH
63766: LD_INT 1
63768: ARRAY
63769: PPUSH
63770: LD_EXP 28
63774: PUSH
63775: LD_VAR 0 2
63779: ARRAY
63780: PUSH
63781: LD_INT 1
63783: ARRAY
63784: PUSH
63785: LD_INT 2
63787: ARRAY
63788: PPUSH
63789: LD_EXP 28
63793: PUSH
63794: LD_VAR 0 2
63798: ARRAY
63799: PUSH
63800: LD_INT 1
63802: ARRAY
63803: PUSH
63804: LD_INT 3
63806: ARRAY
63807: PPUSH
63808: LD_EXP 28
63812: PUSH
63813: LD_VAR 0 2
63817: ARRAY
63818: PUSH
63819: LD_INT 1
63821: ARRAY
63822: PUSH
63823: LD_INT 4
63825: ARRAY
63826: PPUSH
63827: CALL 24183 0 5
63831: OR
63832: IFFALSE 64113
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63834: LD_ADDR_VAR 0 5
63838: PUSH
63839: LD_EXP 23
63843: PUSH
63844: LD_VAR 0 2
63848: ARRAY
63849: PPUSH
63850: LD_INT 25
63852: PUSH
63853: LD_INT 2
63855: PUSH
63856: EMPTY
63857: LIST
63858: LIST
63859: PPUSH
63860: CALL_OW 72
63864: PUSH
63865: LD_EXP 25
63869: PUSH
63870: LD_VAR 0 2
63874: ARRAY
63875: DIFF
63876: ST_TO_ADDR
// if not tmp then
63877: LD_VAR 0 5
63881: NOT
63882: IFFALSE 63886
// continue ;
63884: GO 63714
// for j in tmp do
63886: LD_ADDR_VAR 0 3
63890: PUSH
63891: LD_VAR 0 5
63895: PUSH
63896: FOR_IN
63897: IFFALSE 64109
// begin if not mc_builders [ i ] then
63899: LD_EXP 29
63903: PUSH
63904: LD_VAR 0 2
63908: ARRAY
63909: NOT
63910: IFFALSE 63968
// begin SetTag ( j , 103 ) ;
63912: LD_VAR 0 3
63916: PPUSH
63917: LD_INT 103
63919: PPUSH
63920: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63924: LD_ADDR_EXP 29
63928: PUSH
63929: LD_EXP 29
63933: PPUSH
63934: LD_VAR 0 2
63938: PUSH
63939: LD_EXP 29
63943: PUSH
63944: LD_VAR 0 2
63948: ARRAY
63949: PUSH
63950: LD_INT 1
63952: PLUS
63953: PUSH
63954: EMPTY
63955: LIST
63956: LIST
63957: PPUSH
63958: LD_VAR 0 3
63962: PPUSH
63963: CALL 16077 0 3
63967: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63968: LD_VAR 0 3
63972: PPUSH
63973: CALL_OW 310
63977: IFFALSE 63988
// ComExitBuilding ( j ) ;
63979: LD_VAR 0 3
63983: PPUSH
63984: CALL_OW 122
// wait ( 3 ) ;
63988: LD_INT 3
63990: PPUSH
63991: CALL_OW 67
// if not mc_build_list [ i ] then
63995: LD_EXP 28
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: NOT
64006: IFFALSE 64010
// break ;
64008: GO 64109
// if not HasTask ( j ) then
64010: LD_VAR 0 3
64014: PPUSH
64015: CALL_OW 314
64019: NOT
64020: IFFALSE 64107
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
64022: LD_VAR 0 3
64026: PPUSH
64027: LD_EXP 28
64031: PUSH
64032: LD_VAR 0 2
64036: ARRAY
64037: PUSH
64038: LD_INT 1
64040: ARRAY
64041: PUSH
64042: LD_INT 1
64044: ARRAY
64045: PPUSH
64046: LD_EXP 28
64050: PUSH
64051: LD_VAR 0 2
64055: ARRAY
64056: PUSH
64057: LD_INT 1
64059: ARRAY
64060: PUSH
64061: LD_INT 2
64063: ARRAY
64064: PPUSH
64065: LD_EXP 28
64069: PUSH
64070: LD_VAR 0 2
64074: ARRAY
64075: PUSH
64076: LD_INT 1
64078: ARRAY
64079: PUSH
64080: LD_INT 3
64082: ARRAY
64083: PPUSH
64084: LD_EXP 28
64088: PUSH
64089: LD_VAR 0 2
64093: ARRAY
64094: PUSH
64095: LD_INT 1
64097: ARRAY
64098: PUSH
64099: LD_INT 4
64101: ARRAY
64102: PPUSH
64103: CALL_OW 145
// end ;
64107: GO 63896
64109: POP
64110: POP
// end else
64111: GO 64283
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
64113: LD_EXP 23
64117: PUSH
64118: LD_VAR 0 2
64122: ARRAY
64123: PPUSH
64124: LD_EXP 28
64128: PUSH
64129: LD_VAR 0 2
64133: ARRAY
64134: PUSH
64135: LD_INT 1
64137: ARRAY
64138: PUSH
64139: LD_INT 1
64141: ARRAY
64142: PPUSH
64143: LD_EXP 28
64147: PUSH
64148: LD_VAR 0 2
64152: ARRAY
64153: PUSH
64154: LD_INT 1
64156: ARRAY
64157: PUSH
64158: LD_INT 2
64160: ARRAY
64161: PPUSH
64162: LD_EXP 28
64166: PUSH
64167: LD_VAR 0 2
64171: ARRAY
64172: PUSH
64173: LD_INT 1
64175: ARRAY
64176: PUSH
64177: LD_INT 3
64179: ARRAY
64180: PPUSH
64181: LD_EXP 28
64185: PUSH
64186: LD_VAR 0 2
64190: ARRAY
64191: PUSH
64192: LD_INT 1
64194: ARRAY
64195: PUSH
64196: LD_INT 4
64198: ARRAY
64199: PPUSH
64200: LD_EXP 23
64204: PUSH
64205: LD_VAR 0 2
64209: ARRAY
64210: PPUSH
64211: LD_INT 21
64213: PUSH
64214: LD_INT 3
64216: PUSH
64217: EMPTY
64218: LIST
64219: LIST
64220: PPUSH
64221: CALL_OW 72
64225: PPUSH
64226: EMPTY
64227: PPUSH
64228: CALL 22937 0 7
64232: NOT
64233: IFFALSE 64283
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
64235: LD_ADDR_EXP 28
64239: PUSH
64240: LD_EXP 28
64244: PPUSH
64245: LD_VAR 0 2
64249: PPUSH
64250: LD_EXP 28
64254: PUSH
64255: LD_VAR 0 2
64259: ARRAY
64260: PPUSH
64261: LD_INT 1
64263: PPUSH
64264: LD_INT 1
64266: NEG
64267: PPUSH
64268: LD_INT 0
64270: PPUSH
64271: CALL 15495 0 4
64275: PPUSH
64276: CALL_OW 1
64280: ST_TO_ADDR
// continue ;
64281: GO 63714
// end ; end ;
64283: GO 63714
64285: POP
64286: POP
// end ; end ;
64287: GO 63143
64289: POP
64290: POP
// end ;
64291: LD_VAR 0 1
64295: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
64296: LD_INT 0
64298: PPUSH
64299: PPUSH
64300: PPUSH
64301: PPUSH
64302: PPUSH
64303: PPUSH
// if not mc_bases then
64304: LD_EXP 23
64308: NOT
64309: IFFALSE 64313
// exit ;
64311: GO 64740
// for i = 1 to mc_bases do
64313: LD_ADDR_VAR 0 2
64317: PUSH
64318: DOUBLE
64319: LD_INT 1
64321: DEC
64322: ST_TO_ADDR
64323: LD_EXP 23
64327: PUSH
64328: FOR_TO
64329: IFFALSE 64738
// begin tmp := mc_build_upgrade [ i ] ;
64331: LD_ADDR_VAR 0 4
64335: PUSH
64336: LD_EXP 55
64340: PUSH
64341: LD_VAR 0 2
64345: ARRAY
64346: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64347: LD_ADDR_VAR 0 6
64351: PUSH
64352: LD_EXP 56
64356: PUSH
64357: LD_VAR 0 2
64361: ARRAY
64362: PPUSH
64363: LD_INT 2
64365: PUSH
64366: LD_INT 30
64368: PUSH
64369: LD_INT 6
64371: PUSH
64372: EMPTY
64373: LIST
64374: LIST
64375: PUSH
64376: LD_INT 30
64378: PUSH
64379: LD_INT 7
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: LIST
64390: PPUSH
64391: CALL_OW 72
64395: ST_TO_ADDR
// if not tmp and not lab then
64396: LD_VAR 0 4
64400: NOT
64401: PUSH
64402: LD_VAR 0 6
64406: NOT
64407: AND
64408: IFFALSE 64412
// continue ;
64410: GO 64328
// if tmp then
64412: LD_VAR 0 4
64416: IFFALSE 64536
// for j in tmp do
64418: LD_ADDR_VAR 0 3
64422: PUSH
64423: LD_VAR 0 4
64427: PUSH
64428: FOR_IN
64429: IFFALSE 64534
// begin if UpgradeCost ( j ) then
64431: LD_VAR 0 3
64435: PPUSH
64436: CALL 22597 0 1
64440: IFFALSE 64532
// begin ComUpgrade ( j ) ;
64442: LD_VAR 0 3
64446: PPUSH
64447: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64451: LD_ADDR_EXP 55
64455: PUSH
64456: LD_EXP 55
64460: PPUSH
64461: LD_VAR 0 2
64465: PPUSH
64466: LD_EXP 55
64470: PUSH
64471: LD_VAR 0 2
64475: ARRAY
64476: PUSH
64477: LD_VAR 0 3
64481: DIFF
64482: PPUSH
64483: CALL_OW 1
64487: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64488: LD_ADDR_EXP 30
64492: PUSH
64493: LD_EXP 30
64497: PPUSH
64498: LD_VAR 0 2
64502: PUSH
64503: LD_EXP 30
64507: PUSH
64508: LD_VAR 0 2
64512: ARRAY
64513: PUSH
64514: LD_INT 1
64516: PLUS
64517: PUSH
64518: EMPTY
64519: LIST
64520: LIST
64521: PPUSH
64522: LD_VAR 0 3
64526: PPUSH
64527: CALL 16077 0 3
64531: ST_TO_ADDR
// end ; end ;
64532: GO 64428
64534: POP
64535: POP
// if not lab or not mc_lab_upgrade [ i ] then
64536: LD_VAR 0 6
64540: NOT
64541: PUSH
64542: LD_EXP 57
64546: PUSH
64547: LD_VAR 0 2
64551: ARRAY
64552: NOT
64553: OR
64554: IFFALSE 64558
// continue ;
64556: GO 64328
// for j in lab do
64558: LD_ADDR_VAR 0 3
64562: PUSH
64563: LD_VAR 0 6
64567: PUSH
64568: FOR_IN
64569: IFFALSE 64734
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64571: LD_VAR 0 3
64575: PPUSH
64576: CALL_OW 266
64580: PUSH
64581: LD_INT 6
64583: PUSH
64584: LD_INT 7
64586: PUSH
64587: EMPTY
64588: LIST
64589: LIST
64590: IN
64591: PUSH
64592: LD_VAR 0 3
64596: PPUSH
64597: CALL_OW 461
64601: PUSH
64602: LD_INT 1
64604: NONEQUAL
64605: AND
64606: IFFALSE 64732
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64608: LD_VAR 0 3
64612: PPUSH
64613: LD_EXP 57
64617: PUSH
64618: LD_VAR 0 2
64622: ARRAY
64623: PUSH
64624: LD_INT 1
64626: ARRAY
64627: PPUSH
64628: CALL 22802 0 2
64632: IFFALSE 64732
// begin ComCancel ( j ) ;
64634: LD_VAR 0 3
64638: PPUSH
64639: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64643: LD_VAR 0 3
64647: PPUSH
64648: LD_EXP 57
64652: PUSH
64653: LD_VAR 0 2
64657: ARRAY
64658: PUSH
64659: LD_INT 1
64661: ARRAY
64662: PPUSH
64663: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64667: LD_VAR 0 3
64671: PUSH
64672: LD_EXP 30
64676: PUSH
64677: LD_VAR 0 2
64681: ARRAY
64682: IN
64683: NOT
64684: IFFALSE 64730
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64686: LD_ADDR_EXP 30
64690: PUSH
64691: LD_EXP 30
64695: PPUSH
64696: LD_VAR 0 2
64700: PUSH
64701: LD_EXP 30
64705: PUSH
64706: LD_VAR 0 2
64710: ARRAY
64711: PUSH
64712: LD_INT 1
64714: PLUS
64715: PUSH
64716: EMPTY
64717: LIST
64718: LIST
64719: PPUSH
64720: LD_VAR 0 3
64724: PPUSH
64725: CALL 16077 0 3
64729: ST_TO_ADDR
// break ;
64730: GO 64734
// end ; end ; end ;
64732: GO 64568
64734: POP
64735: POP
// end ;
64736: GO 64328
64738: POP
64739: POP
// end ;
64740: LD_VAR 0 1
64744: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64745: LD_INT 0
64747: PPUSH
64748: PPUSH
64749: PPUSH
64750: PPUSH
64751: PPUSH
64752: PPUSH
64753: PPUSH
64754: PPUSH
64755: PPUSH
// if not mc_bases then
64756: LD_EXP 23
64760: NOT
64761: IFFALSE 64765
// exit ;
64763: GO 65170
// for i = 1 to mc_bases do
64765: LD_ADDR_VAR 0 2
64769: PUSH
64770: DOUBLE
64771: LD_INT 1
64773: DEC
64774: ST_TO_ADDR
64775: LD_EXP 23
64779: PUSH
64780: FOR_TO
64781: IFFALSE 65168
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64783: LD_EXP 31
64787: PUSH
64788: LD_VAR 0 2
64792: ARRAY
64793: NOT
64794: PUSH
64795: LD_EXP 23
64799: PUSH
64800: LD_VAR 0 2
64804: ARRAY
64805: PPUSH
64806: LD_INT 30
64808: PUSH
64809: LD_INT 3
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: PPUSH
64816: CALL_OW 72
64820: NOT
64821: OR
64822: IFFALSE 64826
// continue ;
64824: GO 64780
// busy := false ;
64826: LD_ADDR_VAR 0 8
64830: PUSH
64831: LD_INT 0
64833: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64834: LD_ADDR_VAR 0 4
64838: PUSH
64839: LD_EXP 23
64843: PUSH
64844: LD_VAR 0 2
64848: ARRAY
64849: PPUSH
64850: LD_INT 30
64852: PUSH
64853: LD_INT 3
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PPUSH
64860: CALL_OW 72
64864: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64865: LD_ADDR_VAR 0 6
64869: PUSH
64870: LD_EXP 31
64874: PUSH
64875: LD_VAR 0 2
64879: ARRAY
64880: PPUSH
64881: LD_INT 2
64883: PUSH
64884: LD_INT 30
64886: PUSH
64887: LD_INT 32
64889: PUSH
64890: EMPTY
64891: LIST
64892: LIST
64893: PUSH
64894: LD_INT 30
64896: PUSH
64897: LD_INT 33
64899: PUSH
64900: EMPTY
64901: LIST
64902: LIST
64903: PUSH
64904: EMPTY
64905: LIST
64906: LIST
64907: LIST
64908: PPUSH
64909: CALL_OW 72
64913: ST_TO_ADDR
// if not t then
64914: LD_VAR 0 6
64918: NOT
64919: IFFALSE 64923
// continue ;
64921: GO 64780
// for j in tmp do
64923: LD_ADDR_VAR 0 3
64927: PUSH
64928: LD_VAR 0 4
64932: PUSH
64933: FOR_IN
64934: IFFALSE 64964
// if not BuildingStatus ( j ) = bs_idle then
64936: LD_VAR 0 3
64940: PPUSH
64941: CALL_OW 461
64945: PUSH
64946: LD_INT 2
64948: EQUAL
64949: NOT
64950: IFFALSE 64962
// begin busy := true ;
64952: LD_ADDR_VAR 0 8
64956: PUSH
64957: LD_INT 1
64959: ST_TO_ADDR
// break ;
64960: GO 64964
// end ;
64962: GO 64933
64964: POP
64965: POP
// if busy then
64966: LD_VAR 0 8
64970: IFFALSE 64974
// continue ;
64972: GO 64780
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64974: LD_ADDR_VAR 0 7
64978: PUSH
64979: LD_VAR 0 6
64983: PPUSH
64984: LD_INT 35
64986: PUSH
64987: LD_INT 0
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PPUSH
64994: CALL_OW 72
64998: ST_TO_ADDR
// if tw then
64999: LD_VAR 0 7
65003: IFFALSE 65080
// begin tw := tw [ 1 ] ;
65005: LD_ADDR_VAR 0 7
65009: PUSH
65010: LD_VAR 0 7
65014: PUSH
65015: LD_INT 1
65017: ARRAY
65018: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
65019: LD_ADDR_VAR 0 9
65023: PUSH
65024: LD_VAR 0 7
65028: PPUSH
65029: LD_EXP 48
65033: PUSH
65034: LD_VAR 0 2
65038: ARRAY
65039: PPUSH
65040: CALL 21094 0 2
65044: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
65045: LD_EXP 62
65049: PUSH
65050: LD_VAR 0 2
65054: ARRAY
65055: IFFALSE 65078
// if not weapon in mc_allowed_tower_weapons [ i ] then
65057: LD_VAR 0 9
65061: PUSH
65062: LD_EXP 62
65066: PUSH
65067: LD_VAR 0 2
65071: ARRAY
65072: IN
65073: NOT
65074: IFFALSE 65078
// continue ;
65076: GO 64780
// end else
65078: GO 65143
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
65080: LD_ADDR_VAR 0 5
65084: PUSH
65085: LD_EXP 31
65089: PUSH
65090: LD_VAR 0 2
65094: ARRAY
65095: PPUSH
65096: LD_VAR 0 4
65100: PPUSH
65101: CALL 47984 0 2
65105: ST_TO_ADDR
// if not tmp2 then
65106: LD_VAR 0 5
65110: NOT
65111: IFFALSE 65115
// continue ;
65113: GO 64780
// tw := tmp2 [ 1 ] ;
65115: LD_ADDR_VAR 0 7
65119: PUSH
65120: LD_VAR 0 5
65124: PUSH
65125: LD_INT 1
65127: ARRAY
65128: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
65129: LD_ADDR_VAR 0 9
65133: PUSH
65134: LD_VAR 0 5
65138: PUSH
65139: LD_INT 2
65141: ARRAY
65142: ST_TO_ADDR
// end ; if not weapon then
65143: LD_VAR 0 9
65147: NOT
65148: IFFALSE 65152
// continue ;
65150: GO 64780
// ComPlaceWeapon ( tw , weapon ) ;
65152: LD_VAR 0 7
65156: PPUSH
65157: LD_VAR 0 9
65161: PPUSH
65162: CALL_OW 148
// end ;
65166: GO 64780
65168: POP
65169: POP
// end ;
65170: LD_VAR 0 1
65174: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
65175: LD_INT 0
65177: PPUSH
65178: PPUSH
65179: PPUSH
65180: PPUSH
65181: PPUSH
65182: PPUSH
65183: PPUSH
// if not mc_bases then
65184: LD_EXP 23
65188: NOT
65189: IFFALSE 65193
// exit ;
65191: GO 65968
// for i = 1 to mc_bases do
65193: LD_ADDR_VAR 0 2
65197: PUSH
65198: DOUBLE
65199: LD_INT 1
65201: DEC
65202: ST_TO_ADDR
65203: LD_EXP 23
65207: PUSH
65208: FOR_TO
65209: IFFALSE 65966
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
65211: LD_EXP 36
65215: PUSH
65216: LD_VAR 0 2
65220: ARRAY
65221: NOT
65222: PUSH
65223: LD_EXP 36
65227: PUSH
65228: LD_VAR 0 2
65232: ARRAY
65233: PUSH
65234: LD_EXP 37
65238: PUSH
65239: LD_VAR 0 2
65243: ARRAY
65244: EQUAL
65245: OR
65246: PUSH
65247: LD_EXP 46
65251: PUSH
65252: LD_VAR 0 2
65256: ARRAY
65257: OR
65258: IFFALSE 65262
// continue ;
65260: GO 65208
// if mc_miners [ i ] then
65262: LD_EXP 37
65266: PUSH
65267: LD_VAR 0 2
65271: ARRAY
65272: IFFALSE 65653
// begin for j = mc_miners [ i ] downto 1 do
65274: LD_ADDR_VAR 0 3
65278: PUSH
65279: DOUBLE
65280: LD_EXP 37
65284: PUSH
65285: LD_VAR 0 2
65289: ARRAY
65290: INC
65291: ST_TO_ADDR
65292: LD_INT 1
65294: PUSH
65295: FOR_DOWNTO
65296: IFFALSE 65651
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
65298: LD_EXP 37
65302: PUSH
65303: LD_VAR 0 2
65307: ARRAY
65308: PUSH
65309: LD_VAR 0 3
65313: ARRAY
65314: PPUSH
65315: CALL_OW 301
65319: PUSH
65320: LD_EXP 37
65324: PUSH
65325: LD_VAR 0 2
65329: ARRAY
65330: PUSH
65331: LD_VAR 0 3
65335: ARRAY
65336: PPUSH
65337: CALL_OW 257
65341: PUSH
65342: LD_INT 1
65344: NONEQUAL
65345: OR
65346: IFFALSE 65409
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65348: LD_ADDR_VAR 0 5
65352: PUSH
65353: LD_EXP 37
65357: PUSH
65358: LD_VAR 0 2
65362: ARRAY
65363: PUSH
65364: LD_EXP 37
65368: PUSH
65369: LD_VAR 0 2
65373: ARRAY
65374: PUSH
65375: LD_VAR 0 3
65379: ARRAY
65380: DIFF
65381: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65382: LD_ADDR_EXP 37
65386: PUSH
65387: LD_EXP 37
65391: PPUSH
65392: LD_VAR 0 2
65396: PPUSH
65397: LD_VAR 0 5
65401: PPUSH
65402: CALL_OW 1
65406: ST_TO_ADDR
// continue ;
65407: GO 65295
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
65409: LD_EXP 37
65413: PUSH
65414: LD_VAR 0 2
65418: ARRAY
65419: PUSH
65420: LD_VAR 0 3
65424: ARRAY
65425: PPUSH
65426: CALL_OW 257
65430: PUSH
65431: LD_INT 1
65433: EQUAL
65434: PUSH
65435: LD_EXP 37
65439: PUSH
65440: LD_VAR 0 2
65444: ARRAY
65445: PUSH
65446: LD_VAR 0 3
65450: ARRAY
65451: PPUSH
65452: CALL_OW 459
65456: NOT
65457: AND
65458: PUSH
65459: LD_EXP 37
65463: PUSH
65464: LD_VAR 0 2
65468: ARRAY
65469: PUSH
65470: LD_VAR 0 3
65474: ARRAY
65475: PPUSH
65476: CALL_OW 314
65480: NOT
65481: AND
65482: IFFALSE 65649
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65484: LD_EXP 37
65488: PUSH
65489: LD_VAR 0 2
65493: ARRAY
65494: PUSH
65495: LD_VAR 0 3
65499: ARRAY
65500: PPUSH
65501: CALL_OW 310
65505: IFFALSE 65528
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65507: LD_EXP 37
65511: PUSH
65512: LD_VAR 0 2
65516: ARRAY
65517: PUSH
65518: LD_VAR 0 3
65522: ARRAY
65523: PPUSH
65524: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65528: LD_EXP 37
65532: PUSH
65533: LD_VAR 0 2
65537: ARRAY
65538: PUSH
65539: LD_VAR 0 3
65543: ARRAY
65544: PPUSH
65545: CALL_OW 314
65549: NOT
65550: IFFALSE 65649
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
65552: LD_ADDR_VAR 0 7
65556: PUSH
65557: LD_VAR 0 3
65561: PUSH
65562: LD_EXP 36
65566: PUSH
65567: LD_VAR 0 2
65571: ARRAY
65572: PPUSH
65573: CALL 13217 0 1
65577: MOD
65578: PUSH
65579: LD_INT 1
65581: PLUS
65582: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65583: LD_EXP 37
65587: PUSH
65588: LD_VAR 0 2
65592: ARRAY
65593: PUSH
65594: LD_VAR 0 3
65598: ARRAY
65599: PPUSH
65600: LD_EXP 36
65604: PUSH
65605: LD_VAR 0 2
65609: ARRAY
65610: PUSH
65611: LD_VAR 0 7
65615: ARRAY
65616: PUSH
65617: LD_INT 1
65619: ARRAY
65620: PPUSH
65621: LD_EXP 36
65625: PUSH
65626: LD_VAR 0 2
65630: ARRAY
65631: PUSH
65632: LD_VAR 0 7
65636: ARRAY
65637: PUSH
65638: LD_INT 2
65640: ARRAY
65641: PPUSH
65642: LD_INT 0
65644: PPUSH
65645: CALL_OW 193
// end ; end ; end ;
65649: GO 65295
65651: POP
65652: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65653: LD_ADDR_VAR 0 5
65657: PUSH
65658: LD_EXP 23
65662: PUSH
65663: LD_VAR 0 2
65667: ARRAY
65668: PPUSH
65669: LD_INT 2
65671: PUSH
65672: LD_INT 30
65674: PUSH
65675: LD_INT 4
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: LD_INT 30
65684: PUSH
65685: LD_INT 5
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: PUSH
65692: LD_INT 30
65694: PUSH
65695: LD_INT 32
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: EMPTY
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: PPUSH
65708: CALL_OW 72
65712: ST_TO_ADDR
// if not tmp then
65713: LD_VAR 0 5
65717: NOT
65718: IFFALSE 65722
// continue ;
65720: GO 65208
// list := [ ] ;
65722: LD_ADDR_VAR 0 6
65726: PUSH
65727: EMPTY
65728: ST_TO_ADDR
// for j in tmp do
65729: LD_ADDR_VAR 0 3
65733: PUSH
65734: LD_VAR 0 5
65738: PUSH
65739: FOR_IN
65740: IFFALSE 65809
// begin for k in UnitsInside ( j ) do
65742: LD_ADDR_VAR 0 4
65746: PUSH
65747: LD_VAR 0 3
65751: PPUSH
65752: CALL_OW 313
65756: PUSH
65757: FOR_IN
65758: IFFALSE 65805
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65760: LD_VAR 0 4
65764: PPUSH
65765: CALL_OW 257
65769: PUSH
65770: LD_INT 1
65772: EQUAL
65773: PUSH
65774: LD_VAR 0 4
65778: PPUSH
65779: CALL_OW 459
65783: NOT
65784: AND
65785: IFFALSE 65803
// list := list ^ k ;
65787: LD_ADDR_VAR 0 6
65791: PUSH
65792: LD_VAR 0 6
65796: PUSH
65797: LD_VAR 0 4
65801: ADD
65802: ST_TO_ADDR
65803: GO 65757
65805: POP
65806: POP
// end ;
65807: GO 65739
65809: POP
65810: POP
// list := list diff mc_miners [ i ] ;
65811: LD_ADDR_VAR 0 6
65815: PUSH
65816: LD_VAR 0 6
65820: PUSH
65821: LD_EXP 37
65825: PUSH
65826: LD_VAR 0 2
65830: ARRAY
65831: DIFF
65832: ST_TO_ADDR
// if not list then
65833: LD_VAR 0 6
65837: NOT
65838: IFFALSE 65842
// continue ;
65840: GO 65208
// k := mc_mines [ i ] - mc_miners [ i ] ;
65842: LD_ADDR_VAR 0 4
65846: PUSH
65847: LD_EXP 36
65851: PUSH
65852: LD_VAR 0 2
65856: ARRAY
65857: PUSH
65858: LD_EXP 37
65862: PUSH
65863: LD_VAR 0 2
65867: ARRAY
65868: MINUS
65869: ST_TO_ADDR
// if k > list then
65870: LD_VAR 0 4
65874: PUSH
65875: LD_VAR 0 6
65879: GREATER
65880: IFFALSE 65892
// k := list ;
65882: LD_ADDR_VAR 0 4
65886: PUSH
65887: LD_VAR 0 6
65891: ST_TO_ADDR
// for j = 1 to k do
65892: LD_ADDR_VAR 0 3
65896: PUSH
65897: DOUBLE
65898: LD_INT 1
65900: DEC
65901: ST_TO_ADDR
65902: LD_VAR 0 4
65906: PUSH
65907: FOR_TO
65908: IFFALSE 65962
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65910: LD_ADDR_EXP 37
65914: PUSH
65915: LD_EXP 37
65919: PPUSH
65920: LD_VAR 0 2
65924: PUSH
65925: LD_EXP 37
65929: PUSH
65930: LD_VAR 0 2
65934: ARRAY
65935: PUSH
65936: LD_INT 1
65938: PLUS
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PPUSH
65944: LD_VAR 0 6
65948: PUSH
65949: LD_VAR 0 3
65953: ARRAY
65954: PPUSH
65955: CALL 16077 0 3
65959: ST_TO_ADDR
65960: GO 65907
65962: POP
65963: POP
// end ;
65964: GO 65208
65966: POP
65967: POP
// end ;
65968: LD_VAR 0 1
65972: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65973: LD_INT 0
65975: PPUSH
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
65980: PPUSH
65981: PPUSH
65982: PPUSH
65983: PPUSH
65984: PPUSH
65985: PPUSH
// if not mc_bases then
65986: LD_EXP 23
65990: NOT
65991: IFFALSE 65995
// exit ;
65993: GO 67818
// for i = 1 to mc_bases do
65995: LD_ADDR_VAR 0 2
65999: PUSH
66000: DOUBLE
66001: LD_INT 1
66003: DEC
66004: ST_TO_ADDR
66005: LD_EXP 23
66009: PUSH
66010: FOR_TO
66011: IFFALSE 67816
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
66013: LD_EXP 23
66017: PUSH
66018: LD_VAR 0 2
66022: ARRAY
66023: NOT
66024: PUSH
66025: LD_EXP 30
66029: PUSH
66030: LD_VAR 0 2
66034: ARRAY
66035: OR
66036: IFFALSE 66040
// continue ;
66038: GO 66010
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
66040: LD_EXP 39
66044: PUSH
66045: LD_VAR 0 2
66049: ARRAY
66050: NOT
66051: PUSH
66052: LD_EXP 40
66056: PUSH
66057: LD_VAR 0 2
66061: ARRAY
66062: AND
66063: IFFALSE 66101
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
66065: LD_ADDR_EXP 40
66069: PUSH
66070: LD_EXP 40
66074: PPUSH
66075: LD_VAR 0 2
66079: PPUSH
66080: EMPTY
66081: PPUSH
66082: CALL_OW 1
66086: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
66087: LD_VAR 0 2
66091: PPUSH
66092: LD_INT 107
66094: PPUSH
66095: CALL 56827 0 2
// continue ;
66099: GO 66010
// end ; target := [ ] ;
66101: LD_ADDR_VAR 0 7
66105: PUSH
66106: EMPTY
66107: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
66108: LD_ADDR_VAR 0 6
66112: PUSH
66113: LD_EXP 23
66117: PUSH
66118: LD_VAR 0 2
66122: ARRAY
66123: PUSH
66124: LD_INT 1
66126: ARRAY
66127: PPUSH
66128: CALL_OW 255
66132: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66133: LD_ADDR_VAR 0 9
66137: PUSH
66138: LD_EXP 23
66142: PUSH
66143: LD_VAR 0 2
66147: ARRAY
66148: PPUSH
66149: LD_INT 2
66151: PUSH
66152: LD_INT 30
66154: PUSH
66155: LD_INT 0
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 30
66164: PUSH
66165: LD_INT 1
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: EMPTY
66173: LIST
66174: LIST
66175: LIST
66176: PPUSH
66177: CALL_OW 72
66181: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
66182: LD_ADDR_VAR 0 3
66186: PUSH
66187: DOUBLE
66188: LD_EXP 39
66192: PUSH
66193: LD_VAR 0 2
66197: ARRAY
66198: INC
66199: ST_TO_ADDR
66200: LD_INT 1
66202: PUSH
66203: FOR_DOWNTO
66204: IFFALSE 66449
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
66206: LD_EXP 39
66210: PUSH
66211: LD_VAR 0 2
66215: ARRAY
66216: PUSH
66217: LD_VAR 0 3
66221: ARRAY
66222: PUSH
66223: LD_INT 2
66225: ARRAY
66226: PPUSH
66227: LD_EXP 39
66231: PUSH
66232: LD_VAR 0 2
66236: ARRAY
66237: PUSH
66238: LD_VAR 0 3
66242: ARRAY
66243: PUSH
66244: LD_INT 3
66246: ARRAY
66247: PPUSH
66248: CALL_OW 488
66252: PUSH
66253: LD_EXP 39
66257: PUSH
66258: LD_VAR 0 2
66262: ARRAY
66263: PUSH
66264: LD_VAR 0 3
66268: ARRAY
66269: PUSH
66270: LD_INT 2
66272: ARRAY
66273: PPUSH
66274: LD_EXP 39
66278: PUSH
66279: LD_VAR 0 2
66283: ARRAY
66284: PUSH
66285: LD_VAR 0 3
66289: ARRAY
66290: PUSH
66291: LD_INT 3
66293: ARRAY
66294: PPUSH
66295: CALL_OW 284
66299: PUSH
66300: LD_INT 0
66302: EQUAL
66303: AND
66304: IFFALSE 66359
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
66306: LD_ADDR_VAR 0 5
66310: PUSH
66311: LD_EXP 39
66315: PUSH
66316: LD_VAR 0 2
66320: ARRAY
66321: PPUSH
66322: LD_VAR 0 3
66326: PPUSH
66327: CALL_OW 3
66331: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66332: LD_ADDR_EXP 39
66336: PUSH
66337: LD_EXP 39
66341: PPUSH
66342: LD_VAR 0 2
66346: PPUSH
66347: LD_VAR 0 5
66351: PPUSH
66352: CALL_OW 1
66356: ST_TO_ADDR
// continue ;
66357: GO 66203
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66359: LD_VAR 0 6
66363: PPUSH
66364: LD_EXP 39
66368: PUSH
66369: LD_VAR 0 2
66373: ARRAY
66374: PUSH
66375: LD_VAR 0 3
66379: ARRAY
66380: PUSH
66381: LD_INT 2
66383: ARRAY
66384: PPUSH
66385: LD_EXP 39
66389: PUSH
66390: LD_VAR 0 2
66394: ARRAY
66395: PUSH
66396: LD_VAR 0 3
66400: ARRAY
66401: PUSH
66402: LD_INT 3
66404: ARRAY
66405: PPUSH
66406: LD_INT 30
66408: PPUSH
66409: CALL 16973 0 4
66413: PUSH
66414: LD_INT 4
66416: ARRAY
66417: PUSH
66418: LD_INT 0
66420: EQUAL
66421: IFFALSE 66447
// begin target := mc_crates [ i ] [ j ] ;
66423: LD_ADDR_VAR 0 7
66427: PUSH
66428: LD_EXP 39
66432: PUSH
66433: LD_VAR 0 2
66437: ARRAY
66438: PUSH
66439: LD_VAR 0 3
66443: ARRAY
66444: ST_TO_ADDR
// break ;
66445: GO 66449
// end ; end ;
66447: GO 66203
66449: POP
66450: POP
// if not target then
66451: LD_VAR 0 7
66455: NOT
66456: IFFALSE 66460
// continue ;
66458: GO 66010
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66460: LD_ADDR_VAR 0 8
66464: PUSH
66465: LD_EXP 42
66469: PUSH
66470: LD_VAR 0 2
66474: ARRAY
66475: PPUSH
66476: LD_INT 2
66478: PUSH
66479: LD_INT 3
66481: PUSH
66482: LD_INT 58
66484: PUSH
66485: EMPTY
66486: LIST
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PUSH
66492: LD_INT 61
66494: PUSH
66495: EMPTY
66496: LIST
66497: PUSH
66498: LD_INT 33
66500: PUSH
66501: LD_INT 5
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 33
66510: PUSH
66511: LD_INT 3
66513: PUSH
66514: EMPTY
66515: LIST
66516: LIST
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 2
66527: PUSH
66528: LD_INT 34
66530: PUSH
66531: LD_INT 32
66533: PUSH
66534: EMPTY
66535: LIST
66536: LIST
66537: PUSH
66538: LD_INT 34
66540: PUSH
66541: LD_INT 51
66543: PUSH
66544: EMPTY
66545: LIST
66546: LIST
66547: PUSH
66548: LD_INT 34
66550: PUSH
66551: LD_INT 12
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: EMPTY
66559: LIST
66560: LIST
66561: LIST
66562: LIST
66563: PUSH
66564: EMPTY
66565: LIST
66566: LIST
66567: PPUSH
66568: CALL_OW 72
66572: ST_TO_ADDR
// if not cargo then
66573: LD_VAR 0 8
66577: NOT
66578: IFFALSE 67284
// begin if mc_crates_collector [ i ] < 5 then
66580: LD_EXP 40
66584: PUSH
66585: LD_VAR 0 2
66589: ARRAY
66590: PUSH
66591: LD_INT 5
66593: LESS
66594: IFFALSE 66960
// begin if mc_ape [ i ] then
66596: LD_EXP 52
66600: PUSH
66601: LD_VAR 0 2
66605: ARRAY
66606: IFFALSE 66653
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66608: LD_ADDR_VAR 0 5
66612: PUSH
66613: LD_EXP 52
66617: PUSH
66618: LD_VAR 0 2
66622: ARRAY
66623: PPUSH
66624: LD_INT 25
66626: PUSH
66627: LD_INT 16
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 24
66636: PUSH
66637: LD_INT 750
66639: PUSH
66640: EMPTY
66641: LIST
66642: LIST
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PPUSH
66648: CALL_OW 72
66652: ST_TO_ADDR
// if not tmp then
66653: LD_VAR 0 5
66657: NOT
66658: IFFALSE 66705
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66660: LD_ADDR_VAR 0 5
66664: PUSH
66665: LD_EXP 23
66669: PUSH
66670: LD_VAR 0 2
66674: ARRAY
66675: PPUSH
66676: LD_INT 25
66678: PUSH
66679: LD_INT 2
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 24
66688: PUSH
66689: LD_INT 750
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: EMPTY
66697: LIST
66698: LIST
66699: PPUSH
66700: CALL_OW 72
66704: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66705: LD_EXP 52
66709: PUSH
66710: LD_VAR 0 2
66714: ARRAY
66715: PUSH
66716: LD_EXP 23
66720: PUSH
66721: LD_VAR 0 2
66725: ARRAY
66726: PPUSH
66727: LD_INT 25
66729: PUSH
66730: LD_INT 2
66732: PUSH
66733: EMPTY
66734: LIST
66735: LIST
66736: PUSH
66737: LD_INT 24
66739: PUSH
66740: LD_INT 750
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PPUSH
66751: CALL_OW 72
66755: AND
66756: PUSH
66757: LD_VAR 0 5
66761: PUSH
66762: LD_INT 5
66764: LESS
66765: AND
66766: IFFALSE 66848
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66768: LD_ADDR_VAR 0 3
66772: PUSH
66773: LD_EXP 23
66777: PUSH
66778: LD_VAR 0 2
66782: ARRAY
66783: PPUSH
66784: LD_INT 25
66786: PUSH
66787: LD_INT 2
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: LD_INT 24
66796: PUSH
66797: LD_INT 750
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PUSH
66804: EMPTY
66805: LIST
66806: LIST
66807: PPUSH
66808: CALL_OW 72
66812: PUSH
66813: FOR_IN
66814: IFFALSE 66846
// begin tmp := tmp union j ;
66816: LD_ADDR_VAR 0 5
66820: PUSH
66821: LD_VAR 0 5
66825: PUSH
66826: LD_VAR 0 3
66830: UNION
66831: ST_TO_ADDR
// if tmp >= 5 then
66832: LD_VAR 0 5
66836: PUSH
66837: LD_INT 5
66839: GREATEREQUAL
66840: IFFALSE 66844
// break ;
66842: GO 66846
// end ;
66844: GO 66813
66846: POP
66847: POP
// end ; if not tmp then
66848: LD_VAR 0 5
66852: NOT
66853: IFFALSE 66857
// continue ;
66855: GO 66010
// for j in tmp do
66857: LD_ADDR_VAR 0 3
66861: PUSH
66862: LD_VAR 0 5
66866: PUSH
66867: FOR_IN
66868: IFFALSE 66958
// if not GetTag ( j ) then
66870: LD_VAR 0 3
66874: PPUSH
66875: CALL_OW 110
66879: NOT
66880: IFFALSE 66956
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66882: LD_ADDR_EXP 40
66886: PUSH
66887: LD_EXP 40
66891: PPUSH
66892: LD_VAR 0 2
66896: PUSH
66897: LD_EXP 40
66901: PUSH
66902: LD_VAR 0 2
66906: ARRAY
66907: PUSH
66908: LD_INT 1
66910: PLUS
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PPUSH
66916: LD_VAR 0 3
66920: PPUSH
66921: CALL 16077 0 3
66925: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66926: LD_VAR 0 3
66930: PPUSH
66931: LD_INT 107
66933: PPUSH
66934: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66938: LD_EXP 40
66942: PUSH
66943: LD_VAR 0 2
66947: ARRAY
66948: PUSH
66949: LD_INT 5
66951: GREATEREQUAL
66952: IFFALSE 66956
// break ;
66954: GO 66958
// end ;
66956: GO 66867
66958: POP
66959: POP
// end ; if mc_crates_collector [ i ] and target then
66960: LD_EXP 40
66964: PUSH
66965: LD_VAR 0 2
66969: ARRAY
66970: PUSH
66971: LD_VAR 0 7
66975: AND
66976: IFFALSE 67282
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66978: LD_EXP 40
66982: PUSH
66983: LD_VAR 0 2
66987: ARRAY
66988: PUSH
66989: LD_VAR 0 7
66993: PUSH
66994: LD_INT 1
66996: ARRAY
66997: LESS
66998: IFFALSE 67018
// tmp := mc_crates_collector [ i ] else
67000: LD_ADDR_VAR 0 5
67004: PUSH
67005: LD_EXP 40
67009: PUSH
67010: LD_VAR 0 2
67014: ARRAY
67015: ST_TO_ADDR
67016: GO 67032
// tmp := target [ 1 ] ;
67018: LD_ADDR_VAR 0 5
67022: PUSH
67023: LD_VAR 0 7
67027: PUSH
67028: LD_INT 1
67030: ARRAY
67031: ST_TO_ADDR
// k := 0 ;
67032: LD_ADDR_VAR 0 4
67036: PUSH
67037: LD_INT 0
67039: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
67040: LD_ADDR_VAR 0 3
67044: PUSH
67045: LD_EXP 40
67049: PUSH
67050: LD_VAR 0 2
67054: ARRAY
67055: PUSH
67056: FOR_IN
67057: IFFALSE 67280
// begin k := k + 1 ;
67059: LD_ADDR_VAR 0 4
67063: PUSH
67064: LD_VAR 0 4
67068: PUSH
67069: LD_INT 1
67071: PLUS
67072: ST_TO_ADDR
// if k > tmp then
67073: LD_VAR 0 4
67077: PUSH
67078: LD_VAR 0 5
67082: GREATER
67083: IFFALSE 67087
// break ;
67085: GO 67280
// if not GetClass ( j ) in [ 2 , 16 ] then
67087: LD_VAR 0 3
67091: PPUSH
67092: CALL_OW 257
67096: PUSH
67097: LD_INT 2
67099: PUSH
67100: LD_INT 16
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: IN
67107: NOT
67108: IFFALSE 67161
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
67110: LD_ADDR_EXP 40
67114: PUSH
67115: LD_EXP 40
67119: PPUSH
67120: LD_VAR 0 2
67124: PPUSH
67125: LD_EXP 40
67129: PUSH
67130: LD_VAR 0 2
67134: ARRAY
67135: PUSH
67136: LD_VAR 0 3
67140: DIFF
67141: PPUSH
67142: CALL_OW 1
67146: ST_TO_ADDR
// SetTag ( j , 0 ) ;
67147: LD_VAR 0 3
67151: PPUSH
67152: LD_INT 0
67154: PPUSH
67155: CALL_OW 109
// continue ;
67159: GO 67056
// end ; if IsInUnit ( j ) then
67161: LD_VAR 0 3
67165: PPUSH
67166: CALL_OW 310
67170: IFFALSE 67181
// ComExitBuilding ( j ) ;
67172: LD_VAR 0 3
67176: PPUSH
67177: CALL_OW 122
// wait ( 3 ) ;
67181: LD_INT 3
67183: PPUSH
67184: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
67188: LD_VAR 0 3
67192: PPUSH
67193: CALL_OW 314
67197: PUSH
67198: LD_VAR 0 6
67202: PPUSH
67203: LD_VAR 0 7
67207: PUSH
67208: LD_INT 2
67210: ARRAY
67211: PPUSH
67212: LD_VAR 0 7
67216: PUSH
67217: LD_INT 3
67219: ARRAY
67220: PPUSH
67221: LD_INT 30
67223: PPUSH
67224: CALL 16973 0 4
67228: PUSH
67229: LD_INT 4
67231: ARRAY
67232: AND
67233: IFFALSE 67251
// ComStandNearbyBuilding ( j , depot ) else
67235: LD_VAR 0 3
67239: PPUSH
67240: LD_VAR 0 9
67244: PPUSH
67245: CALL 12679 0 2
67249: GO 67278
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67251: LD_VAR 0 3
67255: PPUSH
67256: LD_VAR 0 7
67260: PUSH
67261: LD_INT 2
67263: ARRAY
67264: PPUSH
67265: LD_VAR 0 7
67269: PUSH
67270: LD_INT 3
67272: ARRAY
67273: PPUSH
67274: CALL_OW 117
// end ;
67278: GO 67056
67280: POP
67281: POP
// end ; end else
67282: GO 67814
// begin for j in cargo do
67284: LD_ADDR_VAR 0 3
67288: PUSH
67289: LD_VAR 0 8
67293: PUSH
67294: FOR_IN
67295: IFFALSE 67812
// begin if GetTag ( j ) <> 0 then
67297: LD_VAR 0 3
67301: PPUSH
67302: CALL_OW 110
67306: PUSH
67307: LD_INT 0
67309: NONEQUAL
67310: IFFALSE 67314
// continue ;
67312: GO 67294
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
67314: LD_VAR 0 3
67318: PPUSH
67319: CALL_OW 256
67323: PUSH
67324: LD_INT 1000
67326: LESS
67327: PUSH
67328: LD_VAR 0 3
67332: PPUSH
67333: LD_EXP 47
67337: PUSH
67338: LD_VAR 0 2
67342: ARRAY
67343: PPUSH
67344: CALL_OW 308
67348: NOT
67349: AND
67350: IFFALSE 67372
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67352: LD_VAR 0 3
67356: PPUSH
67357: LD_EXP 47
67361: PUSH
67362: LD_VAR 0 2
67366: ARRAY
67367: PPUSH
67368: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67372: LD_VAR 0 3
67376: PPUSH
67377: CALL_OW 256
67381: PUSH
67382: LD_INT 1000
67384: LESS
67385: PUSH
67386: LD_VAR 0 3
67390: PPUSH
67391: LD_EXP 47
67395: PUSH
67396: LD_VAR 0 2
67400: ARRAY
67401: PPUSH
67402: CALL_OW 308
67406: AND
67407: IFFALSE 67411
// continue ;
67409: GO 67294
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
67411: LD_VAR 0 3
67415: PPUSH
67416: CALL_OW 262
67420: PUSH
67421: LD_INT 2
67423: EQUAL
67424: PUSH
67425: LD_VAR 0 3
67429: PPUSH
67430: CALL_OW 261
67434: PUSH
67435: LD_INT 15
67437: LESS
67438: AND
67439: IFFALSE 67443
// continue ;
67441: GO 67294
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67443: LD_VAR 0 3
67447: PPUSH
67448: CALL_OW 262
67452: PUSH
67453: LD_INT 1
67455: EQUAL
67456: PUSH
67457: LD_VAR 0 3
67461: PPUSH
67462: CALL_OW 261
67466: PUSH
67467: LD_INT 10
67469: LESS
67470: AND
67471: IFFALSE 67751
// begin if not depot then
67473: LD_VAR 0 9
67477: NOT
67478: IFFALSE 67482
// continue ;
67480: GO 67294
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67482: LD_VAR 0 3
67486: PPUSH
67487: LD_VAR 0 9
67491: PPUSH
67492: LD_VAR 0 3
67496: PPUSH
67497: CALL_OW 74
67501: PPUSH
67502: CALL_OW 296
67506: PUSH
67507: LD_INT 6
67509: LESS
67510: IFFALSE 67526
// SetFuel ( j , 100 ) else
67512: LD_VAR 0 3
67516: PPUSH
67517: LD_INT 100
67519: PPUSH
67520: CALL_OW 240
67524: GO 67751
// if GetFuel ( j ) = 0 then
67526: LD_VAR 0 3
67530: PPUSH
67531: CALL_OW 261
67535: PUSH
67536: LD_INT 0
67538: EQUAL
67539: IFFALSE 67751
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67541: LD_ADDR_EXP 42
67545: PUSH
67546: LD_EXP 42
67550: PPUSH
67551: LD_VAR 0 2
67555: PPUSH
67556: LD_EXP 42
67560: PUSH
67561: LD_VAR 0 2
67565: ARRAY
67566: PUSH
67567: LD_VAR 0 3
67571: DIFF
67572: PPUSH
67573: CALL_OW 1
67577: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67578: LD_VAR 0 3
67582: PPUSH
67583: CALL_OW 263
67587: PUSH
67588: LD_INT 1
67590: EQUAL
67591: IFFALSE 67607
// ComExitVehicle ( IsInUnit ( j ) ) ;
67593: LD_VAR 0 3
67597: PPUSH
67598: CALL_OW 310
67602: PPUSH
67603: CALL_OW 121
// if GetControl ( j ) = control_remote then
67607: LD_VAR 0 3
67611: PPUSH
67612: CALL_OW 263
67616: PUSH
67617: LD_INT 2
67619: EQUAL
67620: IFFALSE 67631
// ComUnlink ( j ) ;
67622: LD_VAR 0 3
67626: PPUSH
67627: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67631: LD_ADDR_VAR 0 10
67635: PUSH
67636: LD_VAR 0 2
67640: PPUSH
67641: LD_INT 3
67643: PPUSH
67644: CALL 77395 0 2
67648: ST_TO_ADDR
// if fac then
67649: LD_VAR 0 10
67653: IFFALSE 67749
// begin for k in fac do
67655: LD_ADDR_VAR 0 4
67659: PUSH
67660: LD_VAR 0 10
67664: PUSH
67665: FOR_IN
67666: IFFALSE 67747
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67668: LD_ADDR_VAR 0 11
67672: PUSH
67673: LD_VAR 0 10
67677: PPUSH
67678: LD_VAR 0 3
67682: PPUSH
67683: CALL_OW 265
67687: PPUSH
67688: LD_VAR 0 3
67692: PPUSH
67693: CALL_OW 262
67697: PPUSH
67698: LD_VAR 0 3
67702: PPUSH
67703: CALL_OW 263
67707: PPUSH
67708: LD_VAR 0 3
67712: PPUSH
67713: CALL_OW 264
67717: PPUSH
67718: CALL 13575 0 5
67722: ST_TO_ADDR
// if components then
67723: LD_VAR 0 11
67727: IFFALSE 67745
// begin MC_InsertProduceList ( i , components ) ;
67729: LD_VAR 0 2
67733: PPUSH
67734: LD_VAR 0 11
67738: PPUSH
67739: CALL 76940 0 2
// break ;
67743: GO 67747
// end ; end ;
67745: GO 67665
67747: POP
67748: POP
// end ; continue ;
67749: GO 67294
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67751: LD_VAR 0 3
67755: PPUSH
67756: LD_INT 1
67758: PPUSH
67759: CALL_OW 289
67763: PUSH
67764: LD_INT 100
67766: LESS
67767: PUSH
67768: LD_VAR 0 3
67772: PPUSH
67773: CALL_OW 314
67777: NOT
67778: AND
67779: IFFALSE 67808
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67781: LD_VAR 0 3
67785: PPUSH
67786: LD_VAR 0 7
67790: PUSH
67791: LD_INT 2
67793: ARRAY
67794: PPUSH
67795: LD_VAR 0 7
67799: PUSH
67800: LD_INT 3
67802: ARRAY
67803: PPUSH
67804: CALL_OW 117
// break ;
67808: GO 67812
// end ;
67810: GO 67294
67812: POP
67813: POP
// end ; end ;
67814: GO 66010
67816: POP
67817: POP
// end ;
67818: LD_VAR 0 1
67822: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67823: LD_INT 0
67825: PPUSH
67826: PPUSH
67827: PPUSH
67828: PPUSH
// if not mc_bases then
67829: LD_EXP 23
67833: NOT
67834: IFFALSE 67838
// exit ;
67836: GO 67999
// for i = 1 to mc_bases do
67838: LD_ADDR_VAR 0 2
67842: PUSH
67843: DOUBLE
67844: LD_INT 1
67846: DEC
67847: ST_TO_ADDR
67848: LD_EXP 23
67852: PUSH
67853: FOR_TO
67854: IFFALSE 67997
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67856: LD_ADDR_VAR 0 4
67860: PUSH
67861: LD_EXP 42
67865: PUSH
67866: LD_VAR 0 2
67870: ARRAY
67871: PUSH
67872: LD_EXP 45
67876: PUSH
67877: LD_VAR 0 2
67881: ARRAY
67882: UNION
67883: PPUSH
67884: LD_INT 33
67886: PUSH
67887: LD_INT 2
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: PPUSH
67894: CALL_OW 72
67898: ST_TO_ADDR
// if tmp then
67899: LD_VAR 0 4
67903: IFFALSE 67995
// for j in tmp do
67905: LD_ADDR_VAR 0 3
67909: PUSH
67910: LD_VAR 0 4
67914: PUSH
67915: FOR_IN
67916: IFFALSE 67993
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67918: LD_VAR 0 3
67922: PPUSH
67923: CALL_OW 312
67927: NOT
67928: PUSH
67929: LD_VAR 0 3
67933: PPUSH
67934: CALL_OW 256
67938: PUSH
67939: LD_INT 250
67941: GREATEREQUAL
67942: AND
67943: IFFALSE 67956
// Connect ( j ) else
67945: LD_VAR 0 3
67949: PPUSH
67950: CALL 19055 0 1
67954: GO 67991
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67956: LD_VAR 0 3
67960: PPUSH
67961: CALL_OW 256
67965: PUSH
67966: LD_INT 250
67968: LESS
67969: PUSH
67970: LD_VAR 0 3
67974: PPUSH
67975: CALL_OW 312
67979: AND
67980: IFFALSE 67991
// ComUnlink ( j ) ;
67982: LD_VAR 0 3
67986: PPUSH
67987: CALL_OW 136
67991: GO 67915
67993: POP
67994: POP
// end ;
67995: GO 67853
67997: POP
67998: POP
// end ;
67999: LD_VAR 0 1
68003: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
68004: LD_INT 0
68006: PPUSH
68007: PPUSH
68008: PPUSH
68009: PPUSH
68010: PPUSH
// if not mc_bases then
68011: LD_EXP 23
68015: NOT
68016: IFFALSE 68020
// exit ;
68018: GO 68465
// for i = 1 to mc_bases do
68020: LD_ADDR_VAR 0 2
68024: PUSH
68025: DOUBLE
68026: LD_INT 1
68028: DEC
68029: ST_TO_ADDR
68030: LD_EXP 23
68034: PUSH
68035: FOR_TO
68036: IFFALSE 68463
// begin if not mc_produce [ i ] then
68038: LD_EXP 44
68042: PUSH
68043: LD_VAR 0 2
68047: ARRAY
68048: NOT
68049: IFFALSE 68053
// continue ;
68051: GO 68035
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68053: LD_ADDR_VAR 0 5
68057: PUSH
68058: LD_EXP 23
68062: PUSH
68063: LD_VAR 0 2
68067: ARRAY
68068: PPUSH
68069: LD_INT 30
68071: PUSH
68072: LD_INT 3
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PPUSH
68079: CALL_OW 72
68083: ST_TO_ADDR
// if not fac then
68084: LD_VAR 0 5
68088: NOT
68089: IFFALSE 68093
// continue ;
68091: GO 68035
// for j in fac do
68093: LD_ADDR_VAR 0 3
68097: PUSH
68098: LD_VAR 0 5
68102: PUSH
68103: FOR_IN
68104: IFFALSE 68459
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
68106: LD_VAR 0 3
68110: PPUSH
68111: CALL_OW 461
68115: PUSH
68116: LD_INT 2
68118: NONEQUAL
68119: PUSH
68120: LD_VAR 0 3
68124: PPUSH
68125: LD_INT 15
68127: PPUSH
68128: CALL 18674 0 2
68132: PUSH
68133: LD_INT 4
68135: ARRAY
68136: OR
68137: IFFALSE 68141
// continue ;
68139: GO 68103
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
68141: LD_VAR 0 3
68145: PPUSH
68146: LD_EXP 44
68150: PUSH
68151: LD_VAR 0 2
68155: ARRAY
68156: PUSH
68157: LD_INT 1
68159: ARRAY
68160: PUSH
68161: LD_INT 1
68163: ARRAY
68164: PPUSH
68165: LD_EXP 44
68169: PUSH
68170: LD_VAR 0 2
68174: ARRAY
68175: PUSH
68176: LD_INT 1
68178: ARRAY
68179: PUSH
68180: LD_INT 2
68182: ARRAY
68183: PPUSH
68184: LD_EXP 44
68188: PUSH
68189: LD_VAR 0 2
68193: ARRAY
68194: PUSH
68195: LD_INT 1
68197: ARRAY
68198: PUSH
68199: LD_INT 3
68201: ARRAY
68202: PPUSH
68203: LD_EXP 44
68207: PUSH
68208: LD_VAR 0 2
68212: ARRAY
68213: PUSH
68214: LD_INT 1
68216: ARRAY
68217: PUSH
68218: LD_INT 4
68220: ARRAY
68221: PPUSH
68222: CALL_OW 448
68226: PUSH
68227: LD_VAR 0 3
68231: PPUSH
68232: LD_EXP 44
68236: PUSH
68237: LD_VAR 0 2
68241: ARRAY
68242: PUSH
68243: LD_INT 1
68245: ARRAY
68246: PUSH
68247: LD_INT 1
68249: ARRAY
68250: PUSH
68251: LD_EXP 44
68255: PUSH
68256: LD_VAR 0 2
68260: ARRAY
68261: PUSH
68262: LD_INT 1
68264: ARRAY
68265: PUSH
68266: LD_INT 2
68268: ARRAY
68269: PUSH
68270: LD_EXP 44
68274: PUSH
68275: LD_VAR 0 2
68279: ARRAY
68280: PUSH
68281: LD_INT 1
68283: ARRAY
68284: PUSH
68285: LD_INT 3
68287: ARRAY
68288: PUSH
68289: LD_EXP 44
68293: PUSH
68294: LD_VAR 0 2
68298: ARRAY
68299: PUSH
68300: LD_INT 1
68302: ARRAY
68303: PUSH
68304: LD_INT 4
68306: ARRAY
68307: PUSH
68308: EMPTY
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: PPUSH
68314: CALL 22450 0 2
68318: AND
68319: IFFALSE 68457
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68321: LD_VAR 0 3
68325: PPUSH
68326: LD_EXP 44
68330: PUSH
68331: LD_VAR 0 2
68335: ARRAY
68336: PUSH
68337: LD_INT 1
68339: ARRAY
68340: PUSH
68341: LD_INT 1
68343: ARRAY
68344: PPUSH
68345: LD_EXP 44
68349: PUSH
68350: LD_VAR 0 2
68354: ARRAY
68355: PUSH
68356: LD_INT 1
68358: ARRAY
68359: PUSH
68360: LD_INT 2
68362: ARRAY
68363: PPUSH
68364: LD_EXP 44
68368: PUSH
68369: LD_VAR 0 2
68373: ARRAY
68374: PUSH
68375: LD_INT 1
68377: ARRAY
68378: PUSH
68379: LD_INT 3
68381: ARRAY
68382: PPUSH
68383: LD_EXP 44
68387: PUSH
68388: LD_VAR 0 2
68392: ARRAY
68393: PUSH
68394: LD_INT 1
68396: ARRAY
68397: PUSH
68398: LD_INT 4
68400: ARRAY
68401: PPUSH
68402: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
68406: LD_ADDR_VAR 0 4
68410: PUSH
68411: LD_EXP 44
68415: PUSH
68416: LD_VAR 0 2
68420: ARRAY
68421: PPUSH
68422: LD_INT 1
68424: PPUSH
68425: CALL_OW 3
68429: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68430: LD_ADDR_EXP 44
68434: PUSH
68435: LD_EXP 44
68439: PPUSH
68440: LD_VAR 0 2
68444: PPUSH
68445: LD_VAR 0 4
68449: PPUSH
68450: CALL_OW 1
68454: ST_TO_ADDR
// break ;
68455: GO 68459
// end ; end ;
68457: GO 68103
68459: POP
68460: POP
// end ;
68461: GO 68035
68463: POP
68464: POP
// end ;
68465: LD_VAR 0 1
68469: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68470: LD_INT 0
68472: PPUSH
68473: PPUSH
68474: PPUSH
// if not mc_bases then
68475: LD_EXP 23
68479: NOT
68480: IFFALSE 68484
// exit ;
68482: GO 68573
// for i = 1 to mc_bases do
68484: LD_ADDR_VAR 0 2
68488: PUSH
68489: DOUBLE
68490: LD_INT 1
68492: DEC
68493: ST_TO_ADDR
68494: LD_EXP 23
68498: PUSH
68499: FOR_TO
68500: IFFALSE 68571
// begin if mc_attack [ i ] then
68502: LD_EXP 43
68506: PUSH
68507: LD_VAR 0 2
68511: ARRAY
68512: IFFALSE 68569
// begin tmp := mc_attack [ i ] [ 1 ] ;
68514: LD_ADDR_VAR 0 3
68518: PUSH
68519: LD_EXP 43
68523: PUSH
68524: LD_VAR 0 2
68528: ARRAY
68529: PUSH
68530: LD_INT 1
68532: ARRAY
68533: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68534: LD_ADDR_EXP 43
68538: PUSH
68539: LD_EXP 43
68543: PPUSH
68544: LD_VAR 0 2
68548: PPUSH
68549: EMPTY
68550: PPUSH
68551: CALL_OW 1
68555: ST_TO_ADDR
// Attack ( tmp ) ;
68556: LD_VAR 0 3
68560: PPUSH
68561: CALL 83366 0 1
// exit ;
68565: POP
68566: POP
68567: GO 68573
// end ; end ;
68569: GO 68499
68571: POP
68572: POP
// end ;
68573: LD_VAR 0 1
68577: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68578: LD_INT 0
68580: PPUSH
68581: PPUSH
68582: PPUSH
68583: PPUSH
68584: PPUSH
68585: PPUSH
68586: PPUSH
// if not mc_bases then
68587: LD_EXP 23
68591: NOT
68592: IFFALSE 68596
// exit ;
68594: GO 69453
// for i = 1 to mc_bases do
68596: LD_ADDR_VAR 0 2
68600: PUSH
68601: DOUBLE
68602: LD_INT 1
68604: DEC
68605: ST_TO_ADDR
68606: LD_EXP 23
68610: PUSH
68611: FOR_TO
68612: IFFALSE 69451
// begin if not mc_bases [ i ] then
68614: LD_EXP 23
68618: PUSH
68619: LD_VAR 0 2
68623: ARRAY
68624: NOT
68625: IFFALSE 68629
// continue ;
68627: GO 68611
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68629: LD_ADDR_VAR 0 7
68633: PUSH
68634: LD_EXP 23
68638: PUSH
68639: LD_VAR 0 2
68643: ARRAY
68644: PUSH
68645: LD_INT 1
68647: ARRAY
68648: PPUSH
68649: CALL 12901 0 1
68653: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68654: LD_ADDR_EXP 46
68658: PUSH
68659: LD_EXP 46
68663: PPUSH
68664: LD_VAR 0 2
68668: PPUSH
68669: LD_EXP 23
68673: PUSH
68674: LD_VAR 0 2
68678: ARRAY
68679: PUSH
68680: LD_INT 1
68682: ARRAY
68683: PPUSH
68684: CALL_OW 255
68688: PPUSH
68689: LD_EXP 48
68693: PUSH
68694: LD_VAR 0 2
68698: ARRAY
68699: PPUSH
68700: CALL 12866 0 2
68704: PPUSH
68705: CALL_OW 1
68709: ST_TO_ADDR
// if not mc_scan [ i ] then
68710: LD_EXP 46
68714: PUSH
68715: LD_VAR 0 2
68719: ARRAY
68720: NOT
68721: IFFALSE 68899
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68723: LD_ADDR_EXP 66
68727: PUSH
68728: LD_EXP 66
68732: PPUSH
68733: LD_VAR 0 2
68737: PPUSH
68738: LD_INT 0
68740: PPUSH
68741: CALL_OW 1
68745: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68746: LD_ADDR_VAR 0 4
68750: PUSH
68751: LD_EXP 23
68755: PUSH
68756: LD_VAR 0 2
68760: ARRAY
68761: PPUSH
68762: LD_INT 2
68764: PUSH
68765: LD_INT 25
68767: PUSH
68768: LD_INT 5
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 25
68777: PUSH
68778: LD_INT 8
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: LD_INT 25
68787: PUSH
68788: LD_INT 9
68790: PUSH
68791: EMPTY
68792: LIST
68793: LIST
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: LIST
68799: LIST
68800: PPUSH
68801: CALL_OW 72
68805: ST_TO_ADDR
// if not tmp then
68806: LD_VAR 0 4
68810: NOT
68811: IFFALSE 68815
// continue ;
68813: GO 68611
// for j in tmp do
68815: LD_ADDR_VAR 0 3
68819: PUSH
68820: LD_VAR 0 4
68824: PUSH
68825: FOR_IN
68826: IFFALSE 68897
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68828: LD_VAR 0 3
68832: PPUSH
68833: CALL_OW 310
68837: PPUSH
68838: CALL_OW 266
68842: PUSH
68843: LD_INT 5
68845: EQUAL
68846: PUSH
68847: LD_VAR 0 3
68851: PPUSH
68852: CALL_OW 257
68856: PUSH
68857: LD_INT 1
68859: EQUAL
68860: AND
68861: PUSH
68862: LD_VAR 0 3
68866: PPUSH
68867: CALL_OW 459
68871: NOT
68872: AND
68873: PUSH
68874: LD_VAR 0 7
68878: AND
68879: IFFALSE 68895
// ComChangeProfession ( j , class ) ;
68881: LD_VAR 0 3
68885: PPUSH
68886: LD_VAR 0 7
68890: PPUSH
68891: CALL_OW 123
68895: GO 68825
68897: POP
68898: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
68899: LD_EXP 46
68903: PUSH
68904: LD_VAR 0 2
68908: ARRAY
68909: PUSH
68910: LD_EXP 66
68914: PUSH
68915: LD_VAR 0 2
68919: ARRAY
68920: NOT
68921: AND
68922: PUSH
68923: LD_EXP 45
68927: PUSH
68928: LD_VAR 0 2
68932: ARRAY
68933: NOT
68934: AND
68935: PUSH
68936: LD_EXP 23
68940: PUSH
68941: LD_VAR 0 2
68945: ARRAY
68946: PPUSH
68947: LD_INT 50
68949: PUSH
68950: EMPTY
68951: LIST
68952: PUSH
68953: LD_INT 2
68955: PUSH
68956: LD_INT 30
68958: PUSH
68959: LD_INT 32
68961: PUSH
68962: EMPTY
68963: LIST
68964: LIST
68965: PUSH
68966: LD_INT 30
68968: PUSH
68969: LD_INT 33
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: PUSH
68976: LD_INT 30
68978: PUSH
68979: LD_INT 4
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 30
68988: PUSH
68989: LD_INT 5
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PPUSH
69007: CALL_OW 72
69011: PUSH
69012: LD_INT 4
69014: LESS
69015: PUSH
69016: LD_EXP 23
69020: PUSH
69021: LD_VAR 0 2
69025: ARRAY
69026: PPUSH
69027: LD_INT 3
69029: PUSH
69030: LD_INT 24
69032: PUSH
69033: LD_INT 1000
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 2
69046: PUSH
69047: LD_INT 30
69049: PUSH
69050: LD_INT 0
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 30
69059: PUSH
69060: LD_INT 1
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: LIST
69071: PUSH
69072: EMPTY
69073: LIST
69074: LIST
69075: PPUSH
69076: CALL_OW 72
69080: OR
69081: AND
69082: IFFALSE 69333
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69084: LD_ADDR_EXP 66
69088: PUSH
69089: LD_EXP 66
69093: PPUSH
69094: LD_VAR 0 2
69098: PPUSH
69099: LD_INT 1
69101: PPUSH
69102: CALL_OW 1
69106: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69107: LD_ADDR_VAR 0 4
69111: PUSH
69112: LD_EXP 23
69116: PUSH
69117: LD_VAR 0 2
69121: ARRAY
69122: PPUSH
69123: LD_INT 2
69125: PUSH
69126: LD_INT 25
69128: PUSH
69129: LD_INT 1
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: PUSH
69136: LD_INT 25
69138: PUSH
69139: LD_INT 5
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: PUSH
69146: LD_INT 25
69148: PUSH
69149: LD_INT 8
69151: PUSH
69152: EMPTY
69153: LIST
69154: LIST
69155: PUSH
69156: LD_INT 25
69158: PUSH
69159: LD_INT 9
69161: PUSH
69162: EMPTY
69163: LIST
69164: LIST
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: PPUSH
69173: CALL_OW 72
69177: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
69178: LD_ADDR_VAR 0 4
69182: PUSH
69183: LD_VAR 0 4
69187: PUSH
69188: LD_VAR 0 4
69192: PPUSH
69193: LD_INT 18
69195: PPUSH
69196: CALL 46018 0 2
69200: DIFF
69201: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69202: LD_VAR 0 4
69206: NOT
69207: PUSH
69208: LD_EXP 23
69212: PUSH
69213: LD_VAR 0 2
69217: ARRAY
69218: PPUSH
69219: LD_INT 2
69221: PUSH
69222: LD_INT 30
69224: PUSH
69225: LD_INT 4
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PUSH
69232: LD_INT 30
69234: PUSH
69235: LD_INT 5
69237: PUSH
69238: EMPTY
69239: LIST
69240: LIST
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: LIST
69246: PPUSH
69247: CALL_OW 72
69251: NOT
69252: AND
69253: IFFALSE 69315
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
69255: LD_ADDR_VAR 0 4
69259: PUSH
69260: LD_EXP 23
69264: PUSH
69265: LD_VAR 0 2
69269: ARRAY
69270: PPUSH
69271: LD_INT 2
69273: PUSH
69274: LD_INT 25
69276: PUSH
69277: LD_INT 2
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PUSH
69284: LD_INT 25
69286: PUSH
69287: LD_INT 3
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: LD_INT 25
69296: PUSH
69297: LD_INT 4
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PUSH
69304: EMPTY
69305: LIST
69306: LIST
69307: LIST
69308: LIST
69309: PPUSH
69310: CALL_OW 72
69314: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
69315: LD_VAR 0 2
69319: PPUSH
69320: LD_VAR 0 4
69324: PPUSH
69325: CALL 88075 0 2
// exit ;
69329: POP
69330: POP
69331: GO 69453
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
69333: LD_EXP 46
69337: PUSH
69338: LD_VAR 0 2
69342: ARRAY
69343: PUSH
69344: LD_EXP 66
69348: PUSH
69349: LD_VAR 0 2
69353: ARRAY
69354: NOT
69355: AND
69356: PUSH
69357: LD_EXP 45
69361: PUSH
69362: LD_VAR 0 2
69366: ARRAY
69367: AND
69368: IFFALSE 69449
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69370: LD_ADDR_EXP 66
69374: PUSH
69375: LD_EXP 66
69379: PPUSH
69380: LD_VAR 0 2
69384: PPUSH
69385: LD_INT 1
69387: PPUSH
69388: CALL_OW 1
69392: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
69393: LD_ADDR_VAR 0 4
69397: PUSH
69398: LD_EXP 45
69402: PUSH
69403: LD_VAR 0 2
69407: ARRAY
69408: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
69409: LD_ADDR_EXP 45
69413: PUSH
69414: LD_EXP 45
69418: PPUSH
69419: LD_VAR 0 2
69423: PPUSH
69424: EMPTY
69425: PPUSH
69426: CALL_OW 1
69430: ST_TO_ADDR
// Defend ( i , tmp ) ;
69431: LD_VAR 0 2
69435: PPUSH
69436: LD_VAR 0 4
69440: PPUSH
69441: CALL 88671 0 2
// exit ;
69445: POP
69446: POP
69447: GO 69453
// end ; end ;
69449: GO 68611
69451: POP
69452: POP
// end ;
69453: LD_VAR 0 1
69457: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69458: LD_INT 0
69460: PPUSH
69461: PPUSH
69462: PPUSH
69463: PPUSH
69464: PPUSH
69465: PPUSH
69466: PPUSH
69467: PPUSH
69468: PPUSH
69469: PPUSH
69470: PPUSH
// if not mc_bases then
69471: LD_EXP 23
69475: NOT
69476: IFFALSE 69480
// exit ;
69478: GO 70567
// for i = 1 to mc_bases do
69480: LD_ADDR_VAR 0 2
69484: PUSH
69485: DOUBLE
69486: LD_INT 1
69488: DEC
69489: ST_TO_ADDR
69490: LD_EXP 23
69494: PUSH
69495: FOR_TO
69496: IFFALSE 70565
// begin tmp := mc_lab [ i ] ;
69498: LD_ADDR_VAR 0 6
69502: PUSH
69503: LD_EXP 56
69507: PUSH
69508: LD_VAR 0 2
69512: ARRAY
69513: ST_TO_ADDR
// if not tmp then
69514: LD_VAR 0 6
69518: NOT
69519: IFFALSE 69523
// continue ;
69521: GO 69495
// idle_lab := 0 ;
69523: LD_ADDR_VAR 0 11
69527: PUSH
69528: LD_INT 0
69530: ST_TO_ADDR
// for j in tmp do
69531: LD_ADDR_VAR 0 3
69535: PUSH
69536: LD_VAR 0 6
69540: PUSH
69541: FOR_IN
69542: IFFALSE 70561
// begin researching := false ;
69544: LD_ADDR_VAR 0 10
69548: PUSH
69549: LD_INT 0
69551: ST_TO_ADDR
// side := GetSide ( j ) ;
69552: LD_ADDR_VAR 0 4
69556: PUSH
69557: LD_VAR 0 3
69561: PPUSH
69562: CALL_OW 255
69566: ST_TO_ADDR
// if not mc_tech [ side ] then
69567: LD_EXP 50
69571: PUSH
69572: LD_VAR 0 4
69576: ARRAY
69577: NOT
69578: IFFALSE 69582
// continue ;
69580: GO 69541
// if BuildingStatus ( j ) = bs_idle then
69582: LD_VAR 0 3
69586: PPUSH
69587: CALL_OW 461
69591: PUSH
69592: LD_INT 2
69594: EQUAL
69595: IFFALSE 69783
// begin if idle_lab and UnitsInside ( j ) < 6 then
69597: LD_VAR 0 11
69601: PUSH
69602: LD_VAR 0 3
69606: PPUSH
69607: CALL_OW 313
69611: PUSH
69612: LD_INT 6
69614: LESS
69615: AND
69616: IFFALSE 69687
// begin tmp2 := UnitsInside ( idle_lab ) ;
69618: LD_ADDR_VAR 0 9
69622: PUSH
69623: LD_VAR 0 11
69627: PPUSH
69628: CALL_OW 313
69632: ST_TO_ADDR
// if tmp2 then
69633: LD_VAR 0 9
69637: IFFALSE 69679
// for x in tmp2 do
69639: LD_ADDR_VAR 0 7
69643: PUSH
69644: LD_VAR 0 9
69648: PUSH
69649: FOR_IN
69650: IFFALSE 69677
// begin ComExitBuilding ( x ) ;
69652: LD_VAR 0 7
69656: PPUSH
69657: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69661: LD_VAR 0 7
69665: PPUSH
69666: LD_VAR 0 3
69670: PPUSH
69671: CALL_OW 180
// end ;
69675: GO 69649
69677: POP
69678: POP
// idle_lab := 0 ;
69679: LD_ADDR_VAR 0 11
69683: PUSH
69684: LD_INT 0
69686: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69687: LD_ADDR_VAR 0 5
69691: PUSH
69692: LD_EXP 50
69696: PUSH
69697: LD_VAR 0 4
69701: ARRAY
69702: PUSH
69703: FOR_IN
69704: IFFALSE 69764
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69706: LD_VAR 0 3
69710: PPUSH
69711: LD_VAR 0 5
69715: PPUSH
69716: CALL_OW 430
69720: PUSH
69721: LD_VAR 0 4
69725: PPUSH
69726: LD_VAR 0 5
69730: PPUSH
69731: CALL 11971 0 2
69735: AND
69736: IFFALSE 69762
// begin researching := true ;
69738: LD_ADDR_VAR 0 10
69742: PUSH
69743: LD_INT 1
69745: ST_TO_ADDR
// ComResearch ( j , t ) ;
69746: LD_VAR 0 3
69750: PPUSH
69751: LD_VAR 0 5
69755: PPUSH
69756: CALL_OW 124
// break ;
69760: GO 69764
// end ;
69762: GO 69703
69764: POP
69765: POP
// if not researching then
69766: LD_VAR 0 10
69770: NOT
69771: IFFALSE 69783
// idle_lab := j ;
69773: LD_ADDR_VAR 0 11
69777: PUSH
69778: LD_VAR 0 3
69782: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69783: LD_VAR 0 3
69787: PPUSH
69788: CALL_OW 461
69792: PUSH
69793: LD_INT 10
69795: EQUAL
69796: IFFALSE 70384
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69798: LD_EXP 52
69802: PUSH
69803: LD_VAR 0 2
69807: ARRAY
69808: NOT
69809: PUSH
69810: LD_EXP 53
69814: PUSH
69815: LD_VAR 0 2
69819: ARRAY
69820: NOT
69821: AND
69822: PUSH
69823: LD_EXP 50
69827: PUSH
69828: LD_VAR 0 4
69832: ARRAY
69833: PUSH
69834: LD_INT 1
69836: GREATER
69837: AND
69838: IFFALSE 69969
// begin ComCancel ( j ) ;
69840: LD_VAR 0 3
69844: PPUSH
69845: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69849: LD_ADDR_EXP 50
69853: PUSH
69854: LD_EXP 50
69858: PPUSH
69859: LD_VAR 0 4
69863: PPUSH
69864: LD_EXP 50
69868: PUSH
69869: LD_VAR 0 4
69873: ARRAY
69874: PPUSH
69875: LD_EXP 50
69879: PUSH
69880: LD_VAR 0 4
69884: ARRAY
69885: PUSH
69886: LD_INT 1
69888: MINUS
69889: PPUSH
69890: LD_EXP 50
69894: PUSH
69895: LD_VAR 0 4
69899: ARRAY
69900: PPUSH
69901: LD_INT 0
69903: PPUSH
69904: CALL 15495 0 4
69908: PPUSH
69909: CALL_OW 1
69913: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69914: LD_ADDR_EXP 50
69918: PUSH
69919: LD_EXP 50
69923: PPUSH
69924: LD_VAR 0 4
69928: PPUSH
69929: LD_EXP 50
69933: PUSH
69934: LD_VAR 0 4
69938: ARRAY
69939: PPUSH
69940: LD_EXP 50
69944: PUSH
69945: LD_VAR 0 4
69949: ARRAY
69950: PPUSH
69951: LD_INT 1
69953: PPUSH
69954: LD_INT 0
69956: PPUSH
69957: CALL 15495 0 4
69961: PPUSH
69962: CALL_OW 1
69966: ST_TO_ADDR
// continue ;
69967: GO 69541
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69969: LD_EXP 52
69973: PUSH
69974: LD_VAR 0 2
69978: ARRAY
69979: PUSH
69980: LD_EXP 53
69984: PUSH
69985: LD_VAR 0 2
69989: ARRAY
69990: NOT
69991: AND
69992: IFFALSE 70119
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69994: LD_ADDR_EXP 53
69998: PUSH
69999: LD_EXP 53
70003: PPUSH
70004: LD_VAR 0 2
70008: PUSH
70009: LD_EXP 53
70013: PUSH
70014: LD_VAR 0 2
70018: ARRAY
70019: PUSH
70020: LD_INT 1
70022: PLUS
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: PPUSH
70028: LD_EXP 52
70032: PUSH
70033: LD_VAR 0 2
70037: ARRAY
70038: PUSH
70039: LD_INT 1
70041: ARRAY
70042: PPUSH
70043: CALL 16077 0 3
70047: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
70048: LD_EXP 52
70052: PUSH
70053: LD_VAR 0 2
70057: ARRAY
70058: PUSH
70059: LD_INT 1
70061: ARRAY
70062: PPUSH
70063: LD_INT 112
70065: PPUSH
70066: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
70070: LD_ADDR_VAR 0 9
70074: PUSH
70075: LD_EXP 52
70079: PUSH
70080: LD_VAR 0 2
70084: ARRAY
70085: PPUSH
70086: LD_INT 1
70088: PPUSH
70089: CALL_OW 3
70093: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
70094: LD_ADDR_EXP 52
70098: PUSH
70099: LD_EXP 52
70103: PPUSH
70104: LD_VAR 0 2
70108: PPUSH
70109: LD_VAR 0 9
70113: PPUSH
70114: CALL_OW 1
70118: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
70119: LD_EXP 52
70123: PUSH
70124: LD_VAR 0 2
70128: ARRAY
70129: PUSH
70130: LD_EXP 53
70134: PUSH
70135: LD_VAR 0 2
70139: ARRAY
70140: AND
70141: PUSH
70142: LD_EXP 53
70146: PUSH
70147: LD_VAR 0 2
70151: ARRAY
70152: PUSH
70153: LD_INT 1
70155: ARRAY
70156: PPUSH
70157: CALL_OW 310
70161: NOT
70162: AND
70163: PUSH
70164: LD_VAR 0 3
70168: PPUSH
70169: CALL_OW 313
70173: PUSH
70174: LD_INT 6
70176: EQUAL
70177: AND
70178: IFFALSE 70234
// begin tmp2 := UnitsInside ( j ) ;
70180: LD_ADDR_VAR 0 9
70184: PUSH
70185: LD_VAR 0 3
70189: PPUSH
70190: CALL_OW 313
70194: ST_TO_ADDR
// if tmp2 = 6 then
70195: LD_VAR 0 9
70199: PUSH
70200: LD_INT 6
70202: EQUAL
70203: IFFALSE 70234
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70205: LD_VAR 0 9
70209: PUSH
70210: LD_INT 1
70212: ARRAY
70213: PPUSH
70214: LD_INT 112
70216: PPUSH
70217: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70221: LD_VAR 0 9
70225: PUSH
70226: LD_INT 1
70228: ARRAY
70229: PPUSH
70230: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70234: LD_EXP 53
70238: PUSH
70239: LD_VAR 0 2
70243: ARRAY
70244: PUSH
70245: LD_EXP 53
70249: PUSH
70250: LD_VAR 0 2
70254: ARRAY
70255: PUSH
70256: LD_INT 1
70258: ARRAY
70259: PPUSH
70260: CALL_OW 314
70264: NOT
70265: AND
70266: PUSH
70267: LD_EXP 53
70271: PUSH
70272: LD_VAR 0 2
70276: ARRAY
70277: PUSH
70278: LD_INT 1
70280: ARRAY
70281: PPUSH
70282: CALL_OW 310
70286: NOT
70287: AND
70288: IFFALSE 70314
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
70290: LD_EXP 53
70294: PUSH
70295: LD_VAR 0 2
70299: ARRAY
70300: PUSH
70301: LD_INT 1
70303: ARRAY
70304: PPUSH
70305: LD_VAR 0 3
70309: PPUSH
70310: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
70314: LD_EXP 53
70318: PUSH
70319: LD_VAR 0 2
70323: ARRAY
70324: PUSH
70325: LD_INT 1
70327: ARRAY
70328: PPUSH
70329: CALL_OW 310
70333: PUSH
70334: LD_EXP 53
70338: PUSH
70339: LD_VAR 0 2
70343: ARRAY
70344: PUSH
70345: LD_INT 1
70347: ARRAY
70348: PPUSH
70349: CALL_OW 310
70353: PPUSH
70354: CALL_OW 461
70358: PUSH
70359: LD_INT 3
70361: NONEQUAL
70362: AND
70363: IFFALSE 70384
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70365: LD_EXP 53
70369: PUSH
70370: LD_VAR 0 2
70374: ARRAY
70375: PUSH
70376: LD_INT 1
70378: ARRAY
70379: PPUSH
70380: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70384: LD_VAR 0 3
70388: PPUSH
70389: CALL_OW 461
70393: PUSH
70394: LD_INT 6
70396: EQUAL
70397: PUSH
70398: LD_VAR 0 6
70402: PUSH
70403: LD_INT 1
70405: GREATER
70406: AND
70407: IFFALSE 70559
// begin sci := [ ] ;
70409: LD_ADDR_VAR 0 8
70413: PUSH
70414: EMPTY
70415: ST_TO_ADDR
// for x in ( tmp diff j ) do
70416: LD_ADDR_VAR 0 7
70420: PUSH
70421: LD_VAR 0 6
70425: PUSH
70426: LD_VAR 0 3
70430: DIFF
70431: PUSH
70432: FOR_IN
70433: IFFALSE 70485
// begin if sci = 6 then
70435: LD_VAR 0 8
70439: PUSH
70440: LD_INT 6
70442: EQUAL
70443: IFFALSE 70447
// break ;
70445: GO 70485
// if BuildingStatus ( x ) = bs_idle then
70447: LD_VAR 0 7
70451: PPUSH
70452: CALL_OW 461
70456: PUSH
70457: LD_INT 2
70459: EQUAL
70460: IFFALSE 70483
// sci := sci ^ UnitsInside ( x ) ;
70462: LD_ADDR_VAR 0 8
70466: PUSH
70467: LD_VAR 0 8
70471: PUSH
70472: LD_VAR 0 7
70476: PPUSH
70477: CALL_OW 313
70481: ADD
70482: ST_TO_ADDR
// end ;
70483: GO 70432
70485: POP
70486: POP
// if not sci then
70487: LD_VAR 0 8
70491: NOT
70492: IFFALSE 70496
// continue ;
70494: GO 69541
// for x in sci do
70496: LD_ADDR_VAR 0 7
70500: PUSH
70501: LD_VAR 0 8
70505: PUSH
70506: FOR_IN
70507: IFFALSE 70557
// if IsInUnit ( x ) and not HasTask ( x ) then
70509: LD_VAR 0 7
70513: PPUSH
70514: CALL_OW 310
70518: PUSH
70519: LD_VAR 0 7
70523: PPUSH
70524: CALL_OW 314
70528: NOT
70529: AND
70530: IFFALSE 70555
// begin ComExitBuilding ( x ) ;
70532: LD_VAR 0 7
70536: PPUSH
70537: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70541: LD_VAR 0 7
70545: PPUSH
70546: LD_VAR 0 3
70550: PPUSH
70551: CALL_OW 180
// end ;
70555: GO 70506
70557: POP
70558: POP
// end ; end ;
70559: GO 69541
70561: POP
70562: POP
// end ;
70563: GO 69495
70565: POP
70566: POP
// end ;
70567: LD_VAR 0 1
70571: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70572: LD_INT 0
70574: PPUSH
70575: PPUSH
// if not mc_bases then
70576: LD_EXP 23
70580: NOT
70581: IFFALSE 70585
// exit ;
70583: GO 70666
// for i = 1 to mc_bases do
70585: LD_ADDR_VAR 0 2
70589: PUSH
70590: DOUBLE
70591: LD_INT 1
70593: DEC
70594: ST_TO_ADDR
70595: LD_EXP 23
70599: PUSH
70600: FOR_TO
70601: IFFALSE 70664
// if mc_mines [ i ] and mc_miners [ i ] then
70603: LD_EXP 36
70607: PUSH
70608: LD_VAR 0 2
70612: ARRAY
70613: PUSH
70614: LD_EXP 37
70618: PUSH
70619: LD_VAR 0 2
70623: ARRAY
70624: AND
70625: IFFALSE 70662
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70627: LD_EXP 37
70631: PUSH
70632: LD_VAR 0 2
70636: ARRAY
70637: PUSH
70638: LD_INT 1
70640: ARRAY
70641: PPUSH
70642: CALL_OW 255
70646: PPUSH
70647: LD_EXP 36
70651: PUSH
70652: LD_VAR 0 2
70656: ARRAY
70657: PPUSH
70658: CALL 13054 0 2
70662: GO 70600
70664: POP
70665: POP
// end ;
70666: LD_VAR 0 1
70670: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70671: LD_INT 0
70673: PPUSH
70674: PPUSH
70675: PPUSH
70676: PPUSH
70677: PPUSH
70678: PPUSH
70679: PPUSH
70680: PPUSH
// if not mc_bases or not mc_parking then
70681: LD_EXP 23
70685: NOT
70686: PUSH
70687: LD_EXP 47
70691: NOT
70692: OR
70693: IFFALSE 70697
// exit ;
70695: GO 71435
// for i = 1 to mc_bases do
70697: LD_ADDR_VAR 0 2
70701: PUSH
70702: DOUBLE
70703: LD_INT 1
70705: DEC
70706: ST_TO_ADDR
70707: LD_EXP 23
70711: PUSH
70712: FOR_TO
70713: IFFALSE 71433
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70715: LD_EXP 23
70719: PUSH
70720: LD_VAR 0 2
70724: ARRAY
70725: NOT
70726: PUSH
70727: LD_EXP 47
70731: PUSH
70732: LD_VAR 0 2
70736: ARRAY
70737: NOT
70738: OR
70739: IFFALSE 70743
// continue ;
70741: GO 70712
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70743: LD_ADDR_VAR 0 5
70747: PUSH
70748: LD_EXP 23
70752: PUSH
70753: LD_VAR 0 2
70757: ARRAY
70758: PUSH
70759: LD_INT 1
70761: ARRAY
70762: PPUSH
70763: CALL_OW 255
70767: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70768: LD_ADDR_VAR 0 6
70772: PUSH
70773: LD_EXP 23
70777: PUSH
70778: LD_VAR 0 2
70782: ARRAY
70783: PPUSH
70784: LD_INT 30
70786: PUSH
70787: LD_INT 3
70789: PUSH
70790: EMPTY
70791: LIST
70792: LIST
70793: PPUSH
70794: CALL_OW 72
70798: ST_TO_ADDR
// if not fac then
70799: LD_VAR 0 6
70803: NOT
70804: IFFALSE 70855
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70806: LD_ADDR_VAR 0 6
70810: PUSH
70811: LD_EXP 23
70815: PUSH
70816: LD_VAR 0 2
70820: ARRAY
70821: PPUSH
70822: LD_INT 2
70824: PUSH
70825: LD_INT 30
70827: PUSH
70828: LD_INT 0
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 30
70837: PUSH
70838: LD_INT 1
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: PUSH
70845: EMPTY
70846: LIST
70847: LIST
70848: LIST
70849: PPUSH
70850: CALL_OW 72
70854: ST_TO_ADDR
// if not fac then
70855: LD_VAR 0 6
70859: NOT
70860: IFFALSE 70864
// continue ;
70862: GO 70712
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70864: LD_ADDR_VAR 0 7
70868: PUSH
70869: LD_EXP 47
70873: PUSH
70874: LD_VAR 0 2
70878: ARRAY
70879: PPUSH
70880: LD_INT 22
70882: PUSH
70883: LD_VAR 0 5
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 21
70894: PUSH
70895: LD_INT 2
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: LD_INT 3
70904: PUSH
70905: LD_INT 60
70907: PUSH
70908: EMPTY
70909: LIST
70910: PUSH
70911: EMPTY
70912: LIST
70913: LIST
70914: PUSH
70915: LD_INT 3
70917: PUSH
70918: LD_INT 24
70920: PUSH
70921: LD_INT 1000
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: PUSH
70932: EMPTY
70933: LIST
70934: LIST
70935: LIST
70936: LIST
70937: PPUSH
70938: CALL_OW 70
70942: ST_TO_ADDR
// for j in fac do
70943: LD_ADDR_VAR 0 3
70947: PUSH
70948: LD_VAR 0 6
70952: PUSH
70953: FOR_IN
70954: IFFALSE 71049
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70956: LD_ADDR_VAR 0 7
70960: PUSH
70961: LD_VAR 0 7
70965: PUSH
70966: LD_INT 22
70968: PUSH
70969: LD_VAR 0 5
70973: PUSH
70974: EMPTY
70975: LIST
70976: LIST
70977: PUSH
70978: LD_INT 91
70980: PUSH
70981: LD_VAR 0 3
70985: PUSH
70986: LD_INT 15
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: LIST
70993: PUSH
70994: LD_INT 21
70996: PUSH
70997: LD_INT 2
70999: PUSH
71000: EMPTY
71001: LIST
71002: LIST
71003: PUSH
71004: LD_INT 3
71006: PUSH
71007: LD_INT 60
71009: PUSH
71010: EMPTY
71011: LIST
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 3
71019: PUSH
71020: LD_INT 24
71022: PUSH
71023: LD_INT 1000
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: LIST
71038: LIST
71039: LIST
71040: PPUSH
71041: CALL_OW 69
71045: UNION
71046: ST_TO_ADDR
71047: GO 70953
71049: POP
71050: POP
// if not vehs then
71051: LD_VAR 0 7
71055: NOT
71056: IFFALSE 71082
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71058: LD_ADDR_EXP 35
71062: PUSH
71063: LD_EXP 35
71067: PPUSH
71068: LD_VAR 0 2
71072: PPUSH
71073: EMPTY
71074: PPUSH
71075: CALL_OW 1
71079: ST_TO_ADDR
// continue ;
71080: GO 70712
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71082: LD_ADDR_VAR 0 8
71086: PUSH
71087: LD_EXP 23
71091: PUSH
71092: LD_VAR 0 2
71096: ARRAY
71097: PPUSH
71098: LD_INT 30
71100: PUSH
71101: LD_INT 3
71103: PUSH
71104: EMPTY
71105: LIST
71106: LIST
71107: PPUSH
71108: CALL_OW 72
71112: ST_TO_ADDR
// if tmp then
71113: LD_VAR 0 8
71117: IFFALSE 71220
// begin for j in tmp do
71119: LD_ADDR_VAR 0 3
71123: PUSH
71124: LD_VAR 0 8
71128: PUSH
71129: FOR_IN
71130: IFFALSE 71218
// for k in UnitsInside ( j ) do
71132: LD_ADDR_VAR 0 4
71136: PUSH
71137: LD_VAR 0 3
71141: PPUSH
71142: CALL_OW 313
71146: PUSH
71147: FOR_IN
71148: IFFALSE 71214
// if k then
71150: LD_VAR 0 4
71154: IFFALSE 71212
// if not k in mc_repair_vehicle [ i ] then
71156: LD_VAR 0 4
71160: PUSH
71161: LD_EXP 35
71165: PUSH
71166: LD_VAR 0 2
71170: ARRAY
71171: IN
71172: NOT
71173: IFFALSE 71212
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71175: LD_ADDR_EXP 35
71179: PUSH
71180: LD_EXP 35
71184: PPUSH
71185: LD_VAR 0 2
71189: PPUSH
71190: LD_EXP 35
71194: PUSH
71195: LD_VAR 0 2
71199: ARRAY
71200: PUSH
71201: LD_VAR 0 4
71205: UNION
71206: PPUSH
71207: CALL_OW 1
71211: ST_TO_ADDR
71212: GO 71147
71214: POP
71215: POP
71216: GO 71129
71218: POP
71219: POP
// end ; if not mc_repair_vehicle [ i ] then
71220: LD_EXP 35
71224: PUSH
71225: LD_VAR 0 2
71229: ARRAY
71230: NOT
71231: IFFALSE 71235
// continue ;
71233: GO 70712
// for j in mc_repair_vehicle [ i ] do
71235: LD_ADDR_VAR 0 3
71239: PUSH
71240: LD_EXP 35
71244: PUSH
71245: LD_VAR 0 2
71249: ARRAY
71250: PUSH
71251: FOR_IN
71252: IFFALSE 71429
// begin if GetClass ( j ) <> 3 then
71254: LD_VAR 0 3
71258: PPUSH
71259: CALL_OW 257
71263: PUSH
71264: LD_INT 3
71266: NONEQUAL
71267: IFFALSE 71308
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71269: LD_ADDR_EXP 35
71273: PUSH
71274: LD_EXP 35
71278: PPUSH
71279: LD_VAR 0 2
71283: PPUSH
71284: LD_EXP 35
71288: PUSH
71289: LD_VAR 0 2
71293: ARRAY
71294: PUSH
71295: LD_VAR 0 3
71299: DIFF
71300: PPUSH
71301: CALL_OW 1
71305: ST_TO_ADDR
// continue ;
71306: GO 71251
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71308: LD_VAR 0 3
71312: PPUSH
71313: CALL_OW 311
71317: NOT
71318: PUSH
71319: LD_VAR 0 3
71323: PUSH
71324: LD_EXP 26
71328: PUSH
71329: LD_VAR 0 2
71333: ARRAY
71334: PUSH
71335: LD_INT 1
71337: ARRAY
71338: IN
71339: NOT
71340: AND
71341: PUSH
71342: LD_VAR 0 3
71346: PUSH
71347: LD_EXP 26
71351: PUSH
71352: LD_VAR 0 2
71356: ARRAY
71357: PUSH
71358: LD_INT 2
71360: ARRAY
71361: IN
71362: NOT
71363: AND
71364: IFFALSE 71427
// begin if IsInUnit ( j ) then
71366: LD_VAR 0 3
71370: PPUSH
71371: CALL_OW 310
71375: IFFALSE 71388
// ComExitBuilding ( j ) else
71377: LD_VAR 0 3
71381: PPUSH
71382: CALL_OW 122
71386: GO 71427
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
71388: LD_VAR 0 3
71392: PPUSH
71393: LD_VAR 0 7
71397: PUSH
71398: LD_INT 1
71400: ARRAY
71401: PPUSH
71402: CALL 50501 0 2
71406: NOT
71407: IFFALSE 71427
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
71409: LD_VAR 0 3
71413: PPUSH
71414: LD_VAR 0 7
71418: PUSH
71419: LD_INT 1
71421: ARRAY
71422: PPUSH
71423: CALL_OW 129
// end ; end ;
71427: GO 71251
71429: POP
71430: POP
// end ;
71431: GO 70712
71433: POP
71434: POP
// end ;
71435: LD_VAR 0 1
71439: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71440: LD_INT 0
71442: PPUSH
71443: PPUSH
71444: PPUSH
71445: PPUSH
71446: PPUSH
71447: PPUSH
71448: PPUSH
71449: PPUSH
71450: PPUSH
71451: PPUSH
71452: PPUSH
// if not mc_bases then
71453: LD_EXP 23
71457: NOT
71458: IFFALSE 71462
// exit ;
71460: GO 72264
// for i = 1 to mc_bases do
71462: LD_ADDR_VAR 0 2
71466: PUSH
71467: DOUBLE
71468: LD_INT 1
71470: DEC
71471: ST_TO_ADDR
71472: LD_EXP 23
71476: PUSH
71477: FOR_TO
71478: IFFALSE 72262
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71480: LD_EXP 51
71484: PUSH
71485: LD_VAR 0 2
71489: ARRAY
71490: NOT
71491: PUSH
71492: LD_EXP 26
71496: PUSH
71497: LD_VAR 0 2
71501: ARRAY
71502: PUSH
71503: LD_INT 1
71505: ARRAY
71506: OR
71507: PUSH
71508: LD_EXP 26
71512: PUSH
71513: LD_VAR 0 2
71517: ARRAY
71518: PUSH
71519: LD_INT 2
71521: ARRAY
71522: OR
71523: PUSH
71524: LD_EXP 49
71528: PUSH
71529: LD_VAR 0 2
71533: ARRAY
71534: PPUSH
71535: LD_INT 1
71537: PPUSH
71538: CALL_OW 325
71542: NOT
71543: OR
71544: PUSH
71545: LD_EXP 46
71549: PUSH
71550: LD_VAR 0 2
71554: ARRAY
71555: OR
71556: IFFALSE 71560
// continue ;
71558: GO 71477
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71560: LD_ADDR_VAR 0 8
71564: PUSH
71565: LD_EXP 23
71569: PUSH
71570: LD_VAR 0 2
71574: ARRAY
71575: PPUSH
71576: LD_INT 25
71578: PUSH
71579: LD_INT 4
71581: PUSH
71582: EMPTY
71583: LIST
71584: LIST
71585: PUSH
71586: LD_INT 50
71588: PUSH
71589: EMPTY
71590: LIST
71591: PUSH
71592: LD_INT 3
71594: PUSH
71595: LD_INT 60
71597: PUSH
71598: EMPTY
71599: LIST
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: LIST
71609: PPUSH
71610: CALL_OW 72
71614: PUSH
71615: LD_EXP 27
71619: PUSH
71620: LD_VAR 0 2
71624: ARRAY
71625: DIFF
71626: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71627: LD_ADDR_VAR 0 9
71631: PUSH
71632: LD_EXP 23
71636: PUSH
71637: LD_VAR 0 2
71641: ARRAY
71642: PPUSH
71643: LD_INT 2
71645: PUSH
71646: LD_INT 30
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 30
71658: PUSH
71659: LD_INT 1
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: EMPTY
71667: LIST
71668: LIST
71669: LIST
71670: PPUSH
71671: CALL_OW 72
71675: ST_TO_ADDR
// if not tmp or not dep then
71676: LD_VAR 0 8
71680: NOT
71681: PUSH
71682: LD_VAR 0 9
71686: NOT
71687: OR
71688: IFFALSE 71692
// continue ;
71690: GO 71477
// side := GetSide ( tmp [ 1 ] ) ;
71692: LD_ADDR_VAR 0 11
71696: PUSH
71697: LD_VAR 0 8
71701: PUSH
71702: LD_INT 1
71704: ARRAY
71705: PPUSH
71706: CALL_OW 255
71710: ST_TO_ADDR
// dep := dep [ 1 ] ;
71711: LD_ADDR_VAR 0 9
71715: PUSH
71716: LD_VAR 0 9
71720: PUSH
71721: LD_INT 1
71723: ARRAY
71724: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71725: LD_ADDR_VAR 0 7
71729: PUSH
71730: LD_EXP 51
71734: PUSH
71735: LD_VAR 0 2
71739: ARRAY
71740: PPUSH
71741: LD_INT 22
71743: PUSH
71744: LD_INT 0
71746: PUSH
71747: EMPTY
71748: LIST
71749: LIST
71750: PUSH
71751: LD_INT 25
71753: PUSH
71754: LD_INT 12
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: PPUSH
71765: CALL_OW 70
71769: PUSH
71770: LD_INT 22
71772: PUSH
71773: LD_INT 0
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 25
71782: PUSH
71783: LD_INT 12
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 91
71792: PUSH
71793: LD_VAR 0 9
71797: PUSH
71798: LD_INT 20
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: LIST
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: LIST
71810: PPUSH
71811: CALL_OW 69
71815: UNION
71816: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71817: LD_ADDR_VAR 0 10
71821: PUSH
71822: LD_EXP 51
71826: PUSH
71827: LD_VAR 0 2
71831: ARRAY
71832: PPUSH
71833: LD_INT 81
71835: PUSH
71836: LD_VAR 0 11
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: PPUSH
71845: CALL_OW 70
71849: ST_TO_ADDR
// if not apes or danger_at_area then
71850: LD_VAR 0 7
71854: NOT
71855: PUSH
71856: LD_VAR 0 10
71860: OR
71861: IFFALSE 71911
// begin if mc_taming [ i ] then
71863: LD_EXP 54
71867: PUSH
71868: LD_VAR 0 2
71872: ARRAY
71873: IFFALSE 71909
// begin MC_Reset ( i , 121 ) ;
71875: LD_VAR 0 2
71879: PPUSH
71880: LD_INT 121
71882: PPUSH
71883: CALL 56827 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71887: LD_ADDR_EXP 54
71891: PUSH
71892: LD_EXP 54
71896: PPUSH
71897: LD_VAR 0 2
71901: PPUSH
71902: EMPTY
71903: PPUSH
71904: CALL_OW 1
71908: ST_TO_ADDR
// end ; continue ;
71909: GO 71477
// end ; for j in tmp do
71911: LD_ADDR_VAR 0 3
71915: PUSH
71916: LD_VAR 0 8
71920: PUSH
71921: FOR_IN
71922: IFFALSE 72258
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71924: LD_VAR 0 3
71928: PUSH
71929: LD_EXP 54
71933: PUSH
71934: LD_VAR 0 2
71938: ARRAY
71939: IN
71940: NOT
71941: PUSH
71942: LD_EXP 54
71946: PUSH
71947: LD_VAR 0 2
71951: ARRAY
71952: PUSH
71953: LD_INT 3
71955: LESS
71956: AND
71957: IFFALSE 72015
// begin SetTag ( j , 121 ) ;
71959: LD_VAR 0 3
71963: PPUSH
71964: LD_INT 121
71966: PPUSH
71967: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71971: LD_ADDR_EXP 54
71975: PUSH
71976: LD_EXP 54
71980: PPUSH
71981: LD_VAR 0 2
71985: PUSH
71986: LD_EXP 54
71990: PUSH
71991: LD_VAR 0 2
71995: ARRAY
71996: PUSH
71997: LD_INT 1
71999: PLUS
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: PPUSH
72005: LD_VAR 0 3
72009: PPUSH
72010: CALL 16077 0 3
72014: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72015: LD_VAR 0 3
72019: PUSH
72020: LD_EXP 54
72024: PUSH
72025: LD_VAR 0 2
72029: ARRAY
72030: IN
72031: IFFALSE 72256
// begin if GetClass ( j ) <> 4 then
72033: LD_VAR 0 3
72037: PPUSH
72038: CALL_OW 257
72042: PUSH
72043: LD_INT 4
72045: NONEQUAL
72046: IFFALSE 72099
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
72048: LD_ADDR_EXP 54
72052: PUSH
72053: LD_EXP 54
72057: PPUSH
72058: LD_VAR 0 2
72062: PPUSH
72063: LD_EXP 54
72067: PUSH
72068: LD_VAR 0 2
72072: ARRAY
72073: PUSH
72074: LD_VAR 0 3
72078: DIFF
72079: PPUSH
72080: CALL_OW 1
72084: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72085: LD_VAR 0 3
72089: PPUSH
72090: LD_INT 0
72092: PPUSH
72093: CALL_OW 109
// continue ;
72097: GO 71921
// end ; if IsInUnit ( j ) then
72099: LD_VAR 0 3
72103: PPUSH
72104: CALL_OW 310
72108: IFFALSE 72119
// ComExitBuilding ( j ) ;
72110: LD_VAR 0 3
72114: PPUSH
72115: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
72119: LD_ADDR_VAR 0 6
72123: PUSH
72124: LD_VAR 0 7
72128: PPUSH
72129: LD_VAR 0 3
72133: PPUSH
72134: CALL_OW 74
72138: ST_TO_ADDR
// if not ape then
72139: LD_VAR 0 6
72143: NOT
72144: IFFALSE 72148
// break ;
72146: GO 72258
// x := GetX ( ape ) ;
72148: LD_ADDR_VAR 0 4
72152: PUSH
72153: LD_VAR 0 6
72157: PPUSH
72158: CALL_OW 250
72162: ST_TO_ADDR
// y := GetY ( ape ) ;
72163: LD_ADDR_VAR 0 5
72167: PUSH
72168: LD_VAR 0 6
72172: PPUSH
72173: CALL_OW 251
72177: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72178: LD_VAR 0 4
72182: PPUSH
72183: LD_VAR 0 5
72187: PPUSH
72188: CALL_OW 488
72192: NOT
72193: PUSH
72194: LD_VAR 0 11
72198: PPUSH
72199: LD_VAR 0 4
72203: PPUSH
72204: LD_VAR 0 5
72208: PPUSH
72209: LD_INT 20
72211: PPUSH
72212: CALL 16973 0 4
72216: PUSH
72217: LD_INT 4
72219: ARRAY
72220: OR
72221: IFFALSE 72225
// break ;
72223: GO 72258
// if not HasTask ( j ) then
72225: LD_VAR 0 3
72229: PPUSH
72230: CALL_OW 314
72234: NOT
72235: IFFALSE 72256
// ComTameXY ( j , x , y ) ;
72237: LD_VAR 0 3
72241: PPUSH
72242: LD_VAR 0 4
72246: PPUSH
72247: LD_VAR 0 5
72251: PPUSH
72252: CALL_OW 131
// end ; end ;
72256: GO 71921
72258: POP
72259: POP
// end ;
72260: GO 71477
72262: POP
72263: POP
// end ;
72264: LD_VAR 0 1
72268: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72269: LD_INT 0
72271: PPUSH
72272: PPUSH
72273: PPUSH
72274: PPUSH
72275: PPUSH
72276: PPUSH
72277: PPUSH
72278: PPUSH
// if not mc_bases then
72279: LD_EXP 23
72283: NOT
72284: IFFALSE 72288
// exit ;
72286: GO 72914
// for i = 1 to mc_bases do
72288: LD_ADDR_VAR 0 2
72292: PUSH
72293: DOUBLE
72294: LD_INT 1
72296: DEC
72297: ST_TO_ADDR
72298: LD_EXP 23
72302: PUSH
72303: FOR_TO
72304: IFFALSE 72912
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72306: LD_EXP 52
72310: PUSH
72311: LD_VAR 0 2
72315: ARRAY
72316: NOT
72317: PUSH
72318: LD_EXP 52
72322: PUSH
72323: LD_VAR 0 2
72327: ARRAY
72328: PPUSH
72329: LD_INT 25
72331: PUSH
72332: LD_INT 12
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PPUSH
72339: CALL_OW 72
72343: NOT
72344: OR
72345: IFFALSE 72349
// continue ;
72347: GO 72303
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72349: LD_ADDR_VAR 0 5
72353: PUSH
72354: LD_EXP 52
72358: PUSH
72359: LD_VAR 0 2
72363: ARRAY
72364: PUSH
72365: LD_INT 1
72367: ARRAY
72368: PPUSH
72369: CALL_OW 255
72373: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72374: LD_VAR 0 5
72378: PPUSH
72379: LD_INT 2
72381: PPUSH
72382: CALL_OW 325
72386: IFFALSE 72639
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72388: LD_ADDR_VAR 0 4
72392: PUSH
72393: LD_EXP 52
72397: PUSH
72398: LD_VAR 0 2
72402: ARRAY
72403: PPUSH
72404: LD_INT 25
72406: PUSH
72407: LD_INT 16
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PPUSH
72414: CALL_OW 72
72418: ST_TO_ADDR
// if tmp < 6 then
72419: LD_VAR 0 4
72423: PUSH
72424: LD_INT 6
72426: LESS
72427: IFFALSE 72639
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72429: LD_ADDR_VAR 0 6
72433: PUSH
72434: LD_EXP 23
72438: PUSH
72439: LD_VAR 0 2
72443: ARRAY
72444: PPUSH
72445: LD_INT 2
72447: PUSH
72448: LD_INT 30
72450: PUSH
72451: LD_INT 0
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: LD_INT 30
72460: PUSH
72461: LD_INT 1
72463: PUSH
72464: EMPTY
72465: LIST
72466: LIST
72467: PUSH
72468: EMPTY
72469: LIST
72470: LIST
72471: LIST
72472: PPUSH
72473: CALL_OW 72
72477: ST_TO_ADDR
// if depot then
72478: LD_VAR 0 6
72482: IFFALSE 72639
// begin selected := 0 ;
72484: LD_ADDR_VAR 0 7
72488: PUSH
72489: LD_INT 0
72491: ST_TO_ADDR
// for j in depot do
72492: LD_ADDR_VAR 0 3
72496: PUSH
72497: LD_VAR 0 6
72501: PUSH
72502: FOR_IN
72503: IFFALSE 72534
// begin if UnitsInside ( j ) < 6 then
72505: LD_VAR 0 3
72509: PPUSH
72510: CALL_OW 313
72514: PUSH
72515: LD_INT 6
72517: LESS
72518: IFFALSE 72532
// begin selected := j ;
72520: LD_ADDR_VAR 0 7
72524: PUSH
72525: LD_VAR 0 3
72529: ST_TO_ADDR
// break ;
72530: GO 72534
// end ; end ;
72532: GO 72502
72534: POP
72535: POP
// if selected then
72536: LD_VAR 0 7
72540: IFFALSE 72639
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72542: LD_ADDR_VAR 0 3
72546: PUSH
72547: LD_EXP 52
72551: PUSH
72552: LD_VAR 0 2
72556: ARRAY
72557: PPUSH
72558: LD_INT 25
72560: PUSH
72561: LD_INT 12
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PPUSH
72568: CALL_OW 72
72572: PUSH
72573: FOR_IN
72574: IFFALSE 72637
// if not HasTask ( j ) then
72576: LD_VAR 0 3
72580: PPUSH
72581: CALL_OW 314
72585: NOT
72586: IFFALSE 72635
// begin if not IsInUnit ( j ) then
72588: LD_VAR 0 3
72592: PPUSH
72593: CALL_OW 310
72597: NOT
72598: IFFALSE 72614
// ComEnterUnit ( j , selected ) ;
72600: LD_VAR 0 3
72604: PPUSH
72605: LD_VAR 0 7
72609: PPUSH
72610: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72614: LD_VAR 0 3
72618: PPUSH
72619: LD_INT 16
72621: PPUSH
72622: CALL_OW 183
// AddComExitBuilding ( j ) ;
72626: LD_VAR 0 3
72630: PPUSH
72631: CALL_OW 182
// end ;
72635: GO 72573
72637: POP
72638: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72639: LD_VAR 0 5
72643: PPUSH
72644: LD_INT 11
72646: PPUSH
72647: CALL_OW 325
72651: IFFALSE 72910
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72653: LD_ADDR_VAR 0 4
72657: PUSH
72658: LD_EXP 52
72662: PUSH
72663: LD_VAR 0 2
72667: ARRAY
72668: PPUSH
72669: LD_INT 25
72671: PUSH
72672: LD_INT 16
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PPUSH
72679: CALL_OW 72
72683: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72684: LD_VAR 0 4
72688: PUSH
72689: LD_INT 6
72691: GREATEREQUAL
72692: PUSH
72693: LD_VAR 0 5
72697: PPUSH
72698: LD_INT 2
72700: PPUSH
72701: CALL_OW 325
72705: NOT
72706: OR
72707: IFFALSE 72910
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72709: LD_ADDR_VAR 0 8
72713: PUSH
72714: LD_EXP 23
72718: PUSH
72719: LD_VAR 0 2
72723: ARRAY
72724: PPUSH
72725: LD_INT 2
72727: PUSH
72728: LD_INT 30
72730: PUSH
72731: LD_INT 4
72733: PUSH
72734: EMPTY
72735: LIST
72736: LIST
72737: PUSH
72738: LD_INT 30
72740: PUSH
72741: LD_INT 5
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: LIST
72752: PPUSH
72753: CALL_OW 72
72757: ST_TO_ADDR
// if barracks then
72758: LD_VAR 0 8
72762: IFFALSE 72910
// begin selected := 0 ;
72764: LD_ADDR_VAR 0 7
72768: PUSH
72769: LD_INT 0
72771: ST_TO_ADDR
// for j in barracks do
72772: LD_ADDR_VAR 0 3
72776: PUSH
72777: LD_VAR 0 8
72781: PUSH
72782: FOR_IN
72783: IFFALSE 72814
// begin if UnitsInside ( j ) < 6 then
72785: LD_VAR 0 3
72789: PPUSH
72790: CALL_OW 313
72794: PUSH
72795: LD_INT 6
72797: LESS
72798: IFFALSE 72812
// begin selected := j ;
72800: LD_ADDR_VAR 0 7
72804: PUSH
72805: LD_VAR 0 3
72809: ST_TO_ADDR
// break ;
72810: GO 72814
// end ; end ;
72812: GO 72782
72814: POP
72815: POP
// if selected then
72816: LD_VAR 0 7
72820: IFFALSE 72910
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72822: LD_ADDR_VAR 0 3
72826: PUSH
72827: LD_EXP 52
72831: PUSH
72832: LD_VAR 0 2
72836: ARRAY
72837: PPUSH
72838: LD_INT 25
72840: PUSH
72841: LD_INT 12
72843: PUSH
72844: EMPTY
72845: LIST
72846: LIST
72847: PPUSH
72848: CALL_OW 72
72852: PUSH
72853: FOR_IN
72854: IFFALSE 72908
// if not IsInUnit ( j ) and not HasTask ( j ) then
72856: LD_VAR 0 3
72860: PPUSH
72861: CALL_OW 310
72865: NOT
72866: PUSH
72867: LD_VAR 0 3
72871: PPUSH
72872: CALL_OW 314
72876: NOT
72877: AND
72878: IFFALSE 72906
// begin ComEnterUnit ( j , selected ) ;
72880: LD_VAR 0 3
72884: PPUSH
72885: LD_VAR 0 7
72889: PPUSH
72890: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72894: LD_VAR 0 3
72898: PPUSH
72899: LD_INT 15
72901: PPUSH
72902: CALL_OW 183
// end ;
72906: GO 72853
72908: POP
72909: POP
// end ; end ; end ; end ; end ;
72910: GO 72303
72912: POP
72913: POP
// end ;
72914: LD_VAR 0 1
72918: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72919: LD_INT 0
72921: PPUSH
72922: PPUSH
72923: PPUSH
72924: PPUSH
// if not mc_bases then
72925: LD_EXP 23
72929: NOT
72930: IFFALSE 72934
// exit ;
72932: GO 73112
// for i = 1 to mc_bases do
72934: LD_ADDR_VAR 0 2
72938: PUSH
72939: DOUBLE
72940: LD_INT 1
72942: DEC
72943: ST_TO_ADDR
72944: LD_EXP 23
72948: PUSH
72949: FOR_TO
72950: IFFALSE 73110
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72952: LD_ADDR_VAR 0 4
72956: PUSH
72957: LD_EXP 23
72961: PUSH
72962: LD_VAR 0 2
72966: ARRAY
72967: PPUSH
72968: LD_INT 25
72970: PUSH
72971: LD_INT 9
72973: PUSH
72974: EMPTY
72975: LIST
72976: LIST
72977: PPUSH
72978: CALL_OW 72
72982: ST_TO_ADDR
// if not tmp then
72983: LD_VAR 0 4
72987: NOT
72988: IFFALSE 72992
// continue ;
72990: GO 72949
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72992: LD_EXP 49
72996: PUSH
72997: LD_VAR 0 2
73001: ARRAY
73002: PPUSH
73003: LD_INT 29
73005: PPUSH
73006: CALL_OW 325
73010: NOT
73011: PUSH
73012: LD_EXP 49
73016: PUSH
73017: LD_VAR 0 2
73021: ARRAY
73022: PPUSH
73023: LD_INT 28
73025: PPUSH
73026: CALL_OW 325
73030: NOT
73031: AND
73032: IFFALSE 73036
// continue ;
73034: GO 72949
// for j in tmp do
73036: LD_ADDR_VAR 0 3
73040: PUSH
73041: LD_VAR 0 4
73045: PUSH
73046: FOR_IN
73047: IFFALSE 73106
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73049: LD_VAR 0 3
73053: PUSH
73054: LD_EXP 26
73058: PUSH
73059: LD_VAR 0 2
73063: ARRAY
73064: PUSH
73065: LD_INT 1
73067: ARRAY
73068: IN
73069: NOT
73070: PUSH
73071: LD_VAR 0 3
73075: PUSH
73076: LD_EXP 26
73080: PUSH
73081: LD_VAR 0 2
73085: ARRAY
73086: PUSH
73087: LD_INT 2
73089: ARRAY
73090: IN
73091: NOT
73092: AND
73093: IFFALSE 73104
// ComSpaceTimeShoot ( j ) ;
73095: LD_VAR 0 3
73099: PPUSH
73100: CALL 12062 0 1
73104: GO 73046
73106: POP
73107: POP
// end ;
73108: GO 72949
73110: POP
73111: POP
// end ;
73112: LD_VAR 0 1
73116: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
73117: LD_INT 0
73119: PPUSH
73120: PPUSH
73121: PPUSH
73122: PPUSH
73123: PPUSH
73124: PPUSH
73125: PPUSH
73126: PPUSH
73127: PPUSH
// if not mc_bases then
73128: LD_EXP 23
73132: NOT
73133: IFFALSE 73137
// exit ;
73135: GO 73759
// for i = 1 to mc_bases do
73137: LD_ADDR_VAR 0 2
73141: PUSH
73142: DOUBLE
73143: LD_INT 1
73145: DEC
73146: ST_TO_ADDR
73147: LD_EXP 23
73151: PUSH
73152: FOR_TO
73153: IFFALSE 73757
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73155: LD_EXP 58
73159: PUSH
73160: LD_VAR 0 2
73164: ARRAY
73165: NOT
73166: PUSH
73167: LD_INT 38
73169: PPUSH
73170: LD_EXP 49
73174: PUSH
73175: LD_VAR 0 2
73179: ARRAY
73180: PPUSH
73181: CALL_OW 321
73185: PUSH
73186: LD_INT 2
73188: NONEQUAL
73189: OR
73190: IFFALSE 73194
// continue ;
73192: GO 73152
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73194: LD_ADDR_VAR 0 8
73198: PUSH
73199: LD_EXP 23
73203: PUSH
73204: LD_VAR 0 2
73208: ARRAY
73209: PPUSH
73210: LD_INT 30
73212: PUSH
73213: LD_INT 34
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PPUSH
73220: CALL_OW 72
73224: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73225: LD_ADDR_VAR 0 9
73229: PUSH
73230: LD_EXP 23
73234: PUSH
73235: LD_VAR 0 2
73239: ARRAY
73240: PPUSH
73241: LD_INT 25
73243: PUSH
73244: LD_INT 4
73246: PUSH
73247: EMPTY
73248: LIST
73249: LIST
73250: PPUSH
73251: CALL_OW 72
73255: PPUSH
73256: LD_INT 0
73258: PPUSH
73259: CALL 46018 0 2
73263: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73264: LD_VAR 0 9
73268: NOT
73269: PUSH
73270: LD_VAR 0 8
73274: NOT
73275: OR
73276: PUSH
73277: LD_EXP 23
73281: PUSH
73282: LD_VAR 0 2
73286: ARRAY
73287: PPUSH
73288: LD_INT 124
73290: PPUSH
73291: CALL 46018 0 2
73295: OR
73296: IFFALSE 73300
// continue ;
73298: GO 73152
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
73300: LD_EXP 59
73304: PUSH
73305: LD_VAR 0 2
73309: ARRAY
73310: PUSH
73311: LD_EXP 58
73315: PUSH
73316: LD_VAR 0 2
73320: ARRAY
73321: LESS
73322: PUSH
73323: LD_EXP 59
73327: PUSH
73328: LD_VAR 0 2
73332: ARRAY
73333: PUSH
73334: LD_VAR 0 8
73338: LESS
73339: AND
73340: IFFALSE 73755
// begin tmp := sci [ 1 ] ;
73342: LD_ADDR_VAR 0 7
73346: PUSH
73347: LD_VAR 0 9
73351: PUSH
73352: LD_INT 1
73354: ARRAY
73355: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73356: LD_VAR 0 7
73360: PPUSH
73361: LD_INT 124
73363: PPUSH
73364: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73368: LD_ADDR_VAR 0 3
73372: PUSH
73373: DOUBLE
73374: LD_EXP 58
73378: PUSH
73379: LD_VAR 0 2
73383: ARRAY
73384: INC
73385: ST_TO_ADDR
73386: LD_EXP 58
73390: PUSH
73391: LD_VAR 0 2
73395: ARRAY
73396: PUSH
73397: FOR_DOWNTO
73398: IFFALSE 73741
// begin if IsInUnit ( tmp ) then
73400: LD_VAR 0 7
73404: PPUSH
73405: CALL_OW 310
73409: IFFALSE 73420
// ComExitBuilding ( tmp ) ;
73411: LD_VAR 0 7
73415: PPUSH
73416: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73420: LD_INT 35
73422: PPUSH
73423: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73427: LD_VAR 0 7
73431: PPUSH
73432: CALL_OW 310
73436: NOT
73437: PUSH
73438: LD_VAR 0 7
73442: PPUSH
73443: CALL_OW 314
73447: NOT
73448: AND
73449: IFFALSE 73420
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73451: LD_ADDR_VAR 0 6
73455: PUSH
73456: LD_VAR 0 7
73460: PPUSH
73461: CALL_OW 250
73465: PUSH
73466: LD_VAR 0 7
73470: PPUSH
73471: CALL_OW 251
73475: PUSH
73476: EMPTY
73477: LIST
73478: LIST
73479: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73480: LD_INT 35
73482: PPUSH
73483: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73487: LD_ADDR_VAR 0 4
73491: PUSH
73492: LD_EXP 58
73496: PUSH
73497: LD_VAR 0 2
73501: ARRAY
73502: PUSH
73503: LD_VAR 0 3
73507: ARRAY
73508: PUSH
73509: LD_INT 1
73511: ARRAY
73512: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73513: LD_ADDR_VAR 0 5
73517: PUSH
73518: LD_EXP 58
73522: PUSH
73523: LD_VAR 0 2
73527: ARRAY
73528: PUSH
73529: LD_VAR 0 3
73533: ARRAY
73534: PUSH
73535: LD_INT 2
73537: ARRAY
73538: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73539: LD_VAR 0 7
73543: PPUSH
73544: LD_INT 10
73546: PPUSH
73547: CALL 18674 0 2
73551: PUSH
73552: LD_INT 4
73554: ARRAY
73555: IFFALSE 73593
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73557: LD_VAR 0 7
73561: PPUSH
73562: LD_VAR 0 6
73566: PUSH
73567: LD_INT 1
73569: ARRAY
73570: PPUSH
73571: LD_VAR 0 6
73575: PUSH
73576: LD_INT 2
73578: ARRAY
73579: PPUSH
73580: CALL_OW 111
// wait ( 0 0$10 ) ;
73584: LD_INT 350
73586: PPUSH
73587: CALL_OW 67
// end else
73591: GO 73619
// begin ComMoveXY ( tmp , x , y ) ;
73593: LD_VAR 0 7
73597: PPUSH
73598: LD_VAR 0 4
73602: PPUSH
73603: LD_VAR 0 5
73607: PPUSH
73608: CALL_OW 111
// wait ( 0 0$3 ) ;
73612: LD_INT 105
73614: PPUSH
73615: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73619: LD_VAR 0 7
73623: PPUSH
73624: LD_VAR 0 4
73628: PPUSH
73629: LD_VAR 0 5
73633: PPUSH
73634: CALL_OW 307
73638: IFFALSE 73480
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73640: LD_VAR 0 7
73644: PPUSH
73645: LD_VAR 0 4
73649: PPUSH
73650: LD_VAR 0 5
73654: PPUSH
73655: LD_VAR 0 8
73659: PUSH
73660: LD_VAR 0 3
73664: ARRAY
73665: PPUSH
73666: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73670: LD_INT 35
73672: PPUSH
73673: CALL_OW 67
// until not HasTask ( tmp ) ;
73677: LD_VAR 0 7
73681: PPUSH
73682: CALL_OW 314
73686: NOT
73687: IFFALSE 73670
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73689: LD_ADDR_EXP 59
73693: PUSH
73694: LD_EXP 59
73698: PPUSH
73699: LD_VAR 0 2
73703: PUSH
73704: LD_EXP 59
73708: PUSH
73709: LD_VAR 0 2
73713: ARRAY
73714: PUSH
73715: LD_INT 1
73717: PLUS
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PPUSH
73723: LD_VAR 0 8
73727: PUSH
73728: LD_VAR 0 3
73732: ARRAY
73733: PPUSH
73734: CALL 16077 0 3
73738: ST_TO_ADDR
// end ;
73739: GO 73397
73741: POP
73742: POP
// MC_Reset ( i , 124 ) ;
73743: LD_VAR 0 2
73747: PPUSH
73748: LD_INT 124
73750: PPUSH
73751: CALL 56827 0 2
// end ; end ;
73755: GO 73152
73757: POP
73758: POP
// end ;
73759: LD_VAR 0 1
73763: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73764: LD_INT 0
73766: PPUSH
73767: PPUSH
73768: PPUSH
// if not mc_bases then
73769: LD_EXP 23
73773: NOT
73774: IFFALSE 73778
// exit ;
73776: GO 74384
// for i = 1 to mc_bases do
73778: LD_ADDR_VAR 0 2
73782: PUSH
73783: DOUBLE
73784: LD_INT 1
73786: DEC
73787: ST_TO_ADDR
73788: LD_EXP 23
73792: PUSH
73793: FOR_TO
73794: IFFALSE 74382
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73796: LD_ADDR_VAR 0 3
73800: PUSH
73801: LD_EXP 23
73805: PUSH
73806: LD_VAR 0 2
73810: ARRAY
73811: PPUSH
73812: LD_INT 25
73814: PUSH
73815: LD_INT 4
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PPUSH
73822: CALL_OW 72
73826: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73827: LD_VAR 0 3
73831: NOT
73832: PUSH
73833: LD_EXP 60
73837: PUSH
73838: LD_VAR 0 2
73842: ARRAY
73843: NOT
73844: OR
73845: PUSH
73846: LD_EXP 23
73850: PUSH
73851: LD_VAR 0 2
73855: ARRAY
73856: PPUSH
73857: LD_INT 2
73859: PUSH
73860: LD_INT 30
73862: PUSH
73863: LD_INT 0
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 30
73872: PUSH
73873: LD_INT 1
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PUSH
73880: EMPTY
73881: LIST
73882: LIST
73883: LIST
73884: PPUSH
73885: CALL_OW 72
73889: NOT
73890: OR
73891: IFFALSE 73941
// begin if mc_deposits_finder [ i ] then
73893: LD_EXP 61
73897: PUSH
73898: LD_VAR 0 2
73902: ARRAY
73903: IFFALSE 73939
// begin MC_Reset ( i , 125 ) ;
73905: LD_VAR 0 2
73909: PPUSH
73910: LD_INT 125
73912: PPUSH
73913: CALL 56827 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73917: LD_ADDR_EXP 61
73921: PUSH
73922: LD_EXP 61
73926: PPUSH
73927: LD_VAR 0 2
73931: PPUSH
73932: EMPTY
73933: PPUSH
73934: CALL_OW 1
73938: ST_TO_ADDR
// end ; continue ;
73939: GO 73793
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73941: LD_EXP 60
73945: PUSH
73946: LD_VAR 0 2
73950: ARRAY
73951: PUSH
73952: LD_INT 1
73954: ARRAY
73955: PUSH
73956: LD_INT 3
73958: ARRAY
73959: PUSH
73960: LD_INT 1
73962: EQUAL
73963: PUSH
73964: LD_INT 20
73966: PPUSH
73967: LD_EXP 49
73971: PUSH
73972: LD_VAR 0 2
73976: ARRAY
73977: PPUSH
73978: CALL_OW 321
73982: PUSH
73983: LD_INT 2
73985: NONEQUAL
73986: AND
73987: IFFALSE 74037
// begin if mc_deposits_finder [ i ] then
73989: LD_EXP 61
73993: PUSH
73994: LD_VAR 0 2
73998: ARRAY
73999: IFFALSE 74035
// begin MC_Reset ( i , 125 ) ;
74001: LD_VAR 0 2
74005: PPUSH
74006: LD_INT 125
74008: PPUSH
74009: CALL 56827 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74013: LD_ADDR_EXP 61
74017: PUSH
74018: LD_EXP 61
74022: PPUSH
74023: LD_VAR 0 2
74027: PPUSH
74028: EMPTY
74029: PPUSH
74030: CALL_OW 1
74034: ST_TO_ADDR
// end ; continue ;
74035: GO 73793
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
74037: LD_EXP 60
74041: PUSH
74042: LD_VAR 0 2
74046: ARRAY
74047: PUSH
74048: LD_INT 1
74050: ARRAY
74051: PUSH
74052: LD_INT 1
74054: ARRAY
74055: PPUSH
74056: LD_EXP 60
74060: PUSH
74061: LD_VAR 0 2
74065: ARRAY
74066: PUSH
74067: LD_INT 1
74069: ARRAY
74070: PUSH
74071: LD_INT 2
74073: ARRAY
74074: PPUSH
74075: LD_EXP 49
74079: PUSH
74080: LD_VAR 0 2
74084: ARRAY
74085: PPUSH
74086: CALL_OW 440
74090: IFFALSE 74133
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
74092: LD_ADDR_EXP 60
74096: PUSH
74097: LD_EXP 60
74101: PPUSH
74102: LD_VAR 0 2
74106: PPUSH
74107: LD_EXP 60
74111: PUSH
74112: LD_VAR 0 2
74116: ARRAY
74117: PPUSH
74118: LD_INT 1
74120: PPUSH
74121: CALL_OW 3
74125: PPUSH
74126: CALL_OW 1
74130: ST_TO_ADDR
74131: GO 74380
// begin if not mc_deposits_finder [ i ] then
74133: LD_EXP 61
74137: PUSH
74138: LD_VAR 0 2
74142: ARRAY
74143: NOT
74144: IFFALSE 74196
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74146: LD_ADDR_EXP 61
74150: PUSH
74151: LD_EXP 61
74155: PPUSH
74156: LD_VAR 0 2
74160: PPUSH
74161: LD_VAR 0 3
74165: PUSH
74166: LD_INT 1
74168: ARRAY
74169: PUSH
74170: EMPTY
74171: LIST
74172: PPUSH
74173: CALL_OW 1
74177: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74178: LD_VAR 0 3
74182: PUSH
74183: LD_INT 1
74185: ARRAY
74186: PPUSH
74187: LD_INT 125
74189: PPUSH
74190: CALL_OW 109
// end else
74194: GO 74380
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74196: LD_EXP 61
74200: PUSH
74201: LD_VAR 0 2
74205: ARRAY
74206: PUSH
74207: LD_INT 1
74209: ARRAY
74210: PPUSH
74211: CALL_OW 310
74215: IFFALSE 74238
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74217: LD_EXP 61
74221: PUSH
74222: LD_VAR 0 2
74226: ARRAY
74227: PUSH
74228: LD_INT 1
74230: ARRAY
74231: PPUSH
74232: CALL_OW 122
74236: GO 74380
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74238: LD_EXP 61
74242: PUSH
74243: LD_VAR 0 2
74247: ARRAY
74248: PUSH
74249: LD_INT 1
74251: ARRAY
74252: PPUSH
74253: CALL_OW 314
74257: NOT
74258: PUSH
74259: LD_EXP 61
74263: PUSH
74264: LD_VAR 0 2
74268: ARRAY
74269: PUSH
74270: LD_INT 1
74272: ARRAY
74273: PPUSH
74274: LD_EXP 60
74278: PUSH
74279: LD_VAR 0 2
74283: ARRAY
74284: PUSH
74285: LD_INT 1
74287: ARRAY
74288: PUSH
74289: LD_INT 1
74291: ARRAY
74292: PPUSH
74293: LD_EXP 60
74297: PUSH
74298: LD_VAR 0 2
74302: ARRAY
74303: PUSH
74304: LD_INT 1
74306: ARRAY
74307: PUSH
74308: LD_INT 2
74310: ARRAY
74311: PPUSH
74312: CALL_OW 297
74316: PUSH
74317: LD_INT 6
74319: GREATER
74320: AND
74321: IFFALSE 74380
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74323: LD_EXP 61
74327: PUSH
74328: LD_VAR 0 2
74332: ARRAY
74333: PUSH
74334: LD_INT 1
74336: ARRAY
74337: PPUSH
74338: LD_EXP 60
74342: PUSH
74343: LD_VAR 0 2
74347: ARRAY
74348: PUSH
74349: LD_INT 1
74351: ARRAY
74352: PUSH
74353: LD_INT 1
74355: ARRAY
74356: PPUSH
74357: LD_EXP 60
74361: PUSH
74362: LD_VAR 0 2
74366: ARRAY
74367: PUSH
74368: LD_INT 1
74370: ARRAY
74371: PUSH
74372: LD_INT 2
74374: ARRAY
74375: PPUSH
74376: CALL_OW 111
// end ; end ; end ;
74380: GO 73793
74382: POP
74383: POP
// end ;
74384: LD_VAR 0 1
74388: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74389: LD_INT 0
74391: PPUSH
74392: PPUSH
74393: PPUSH
74394: PPUSH
74395: PPUSH
74396: PPUSH
74397: PPUSH
74398: PPUSH
74399: PPUSH
74400: PPUSH
74401: PPUSH
// if not mc_bases then
74402: LD_EXP 23
74406: NOT
74407: IFFALSE 74411
// exit ;
74409: GO 75351
// for i = 1 to mc_bases do
74411: LD_ADDR_VAR 0 2
74415: PUSH
74416: DOUBLE
74417: LD_INT 1
74419: DEC
74420: ST_TO_ADDR
74421: LD_EXP 23
74425: PUSH
74426: FOR_TO
74427: IFFALSE 75349
// begin if not mc_bases [ i ] or mc_scan [ i ] then
74429: LD_EXP 23
74433: PUSH
74434: LD_VAR 0 2
74438: ARRAY
74439: NOT
74440: PUSH
74441: LD_EXP 46
74445: PUSH
74446: LD_VAR 0 2
74450: ARRAY
74451: OR
74452: IFFALSE 74456
// continue ;
74454: GO 74426
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74456: LD_ADDR_VAR 0 7
74460: PUSH
74461: LD_EXP 23
74465: PUSH
74466: LD_VAR 0 2
74470: ARRAY
74471: PUSH
74472: LD_INT 1
74474: ARRAY
74475: PPUSH
74476: CALL_OW 248
74480: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74481: LD_VAR 0 7
74485: PUSH
74486: LD_INT 3
74488: EQUAL
74489: PUSH
74490: LD_EXP 42
74494: PUSH
74495: LD_VAR 0 2
74499: ARRAY
74500: PUSH
74501: LD_EXP 45
74505: PUSH
74506: LD_VAR 0 2
74510: ARRAY
74511: UNION
74512: PPUSH
74513: LD_INT 33
74515: PUSH
74516: LD_INT 2
74518: PUSH
74519: EMPTY
74520: LIST
74521: LIST
74522: PPUSH
74523: CALL_OW 72
74527: NOT
74528: OR
74529: IFFALSE 74533
// continue ;
74531: GO 74426
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74533: LD_ADDR_VAR 0 9
74537: PUSH
74538: LD_EXP 23
74542: PUSH
74543: LD_VAR 0 2
74547: ARRAY
74548: PPUSH
74549: LD_INT 30
74551: PUSH
74552: LD_INT 36
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PPUSH
74559: CALL_OW 72
74563: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74564: LD_ADDR_VAR 0 10
74568: PUSH
74569: LD_EXP 42
74573: PUSH
74574: LD_VAR 0 2
74578: ARRAY
74579: PPUSH
74580: LD_INT 34
74582: PUSH
74583: LD_INT 31
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PPUSH
74590: CALL_OW 72
74594: ST_TO_ADDR
// if not cts and not mcts then
74595: LD_VAR 0 9
74599: NOT
74600: PUSH
74601: LD_VAR 0 10
74605: NOT
74606: AND
74607: IFFALSE 74611
// continue ;
74609: GO 74426
// x := cts ;
74611: LD_ADDR_VAR 0 11
74615: PUSH
74616: LD_VAR 0 9
74620: ST_TO_ADDR
// if not x then
74621: LD_VAR 0 11
74625: NOT
74626: IFFALSE 74638
// x := mcts ;
74628: LD_ADDR_VAR 0 11
74632: PUSH
74633: LD_VAR 0 10
74637: ST_TO_ADDR
// if not x then
74638: LD_VAR 0 11
74642: NOT
74643: IFFALSE 74647
// continue ;
74645: GO 74426
// if mc_remote_driver [ i ] then
74647: LD_EXP 63
74651: PUSH
74652: LD_VAR 0 2
74656: ARRAY
74657: IFFALSE 75044
// for j in mc_remote_driver [ i ] do
74659: LD_ADDR_VAR 0 3
74663: PUSH
74664: LD_EXP 63
74668: PUSH
74669: LD_VAR 0 2
74673: ARRAY
74674: PUSH
74675: FOR_IN
74676: IFFALSE 75042
// begin if GetClass ( j ) <> 3 then
74678: LD_VAR 0 3
74682: PPUSH
74683: CALL_OW 257
74687: PUSH
74688: LD_INT 3
74690: NONEQUAL
74691: IFFALSE 74744
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74693: LD_ADDR_EXP 63
74697: PUSH
74698: LD_EXP 63
74702: PPUSH
74703: LD_VAR 0 2
74707: PPUSH
74708: LD_EXP 63
74712: PUSH
74713: LD_VAR 0 2
74717: ARRAY
74718: PUSH
74719: LD_VAR 0 3
74723: DIFF
74724: PPUSH
74725: CALL_OW 1
74729: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74730: LD_VAR 0 3
74734: PPUSH
74735: LD_INT 0
74737: PPUSH
74738: CALL_OW 109
// continue ;
74742: GO 74675
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74744: LD_EXP 42
74748: PUSH
74749: LD_VAR 0 2
74753: ARRAY
74754: PPUSH
74755: LD_INT 34
74757: PUSH
74758: LD_INT 31
74760: PUSH
74761: EMPTY
74762: LIST
74763: LIST
74764: PUSH
74765: LD_INT 58
74767: PUSH
74768: EMPTY
74769: LIST
74770: PUSH
74771: EMPTY
74772: LIST
74773: LIST
74774: PPUSH
74775: CALL_OW 72
74779: PUSH
74780: LD_VAR 0 3
74784: PPUSH
74785: CALL 46053 0 1
74789: NOT
74790: AND
74791: IFFALSE 74862
// begin if IsInUnit ( j ) then
74793: LD_VAR 0 3
74797: PPUSH
74798: CALL_OW 310
74802: IFFALSE 74813
// ComExitBuilding ( j ) ;
74804: LD_VAR 0 3
74808: PPUSH
74809: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74813: LD_VAR 0 3
74817: PPUSH
74818: LD_EXP 42
74822: PUSH
74823: LD_VAR 0 2
74827: ARRAY
74828: PPUSH
74829: LD_INT 34
74831: PUSH
74832: LD_INT 31
74834: PUSH
74835: EMPTY
74836: LIST
74837: LIST
74838: PUSH
74839: LD_INT 58
74841: PUSH
74842: EMPTY
74843: LIST
74844: PUSH
74845: EMPTY
74846: LIST
74847: LIST
74848: PPUSH
74849: CALL_OW 72
74853: PUSH
74854: LD_INT 1
74856: ARRAY
74857: PPUSH
74858: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74862: LD_VAR 0 3
74866: PPUSH
74867: CALL_OW 310
74871: NOT
74872: PUSH
74873: LD_VAR 0 3
74877: PPUSH
74878: CALL_OW 310
74882: PPUSH
74883: CALL_OW 266
74887: PUSH
74888: LD_INT 36
74890: NONEQUAL
74891: PUSH
74892: LD_VAR 0 3
74896: PPUSH
74897: CALL 46053 0 1
74901: NOT
74902: AND
74903: OR
74904: IFFALSE 75040
// begin if IsInUnit ( j ) then
74906: LD_VAR 0 3
74910: PPUSH
74911: CALL_OW 310
74915: IFFALSE 74926
// ComExitBuilding ( j ) ;
74917: LD_VAR 0 3
74921: PPUSH
74922: CALL_OW 122
// ct := 0 ;
74926: LD_ADDR_VAR 0 8
74930: PUSH
74931: LD_INT 0
74933: ST_TO_ADDR
// for k in x do
74934: LD_ADDR_VAR 0 4
74938: PUSH
74939: LD_VAR 0 11
74943: PUSH
74944: FOR_IN
74945: IFFALSE 75018
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74947: LD_VAR 0 4
74951: PPUSH
74952: CALL_OW 264
74956: PUSH
74957: LD_INT 31
74959: EQUAL
74960: PUSH
74961: LD_VAR 0 4
74965: PPUSH
74966: CALL_OW 311
74970: NOT
74971: AND
74972: PUSH
74973: LD_VAR 0 4
74977: PPUSH
74978: CALL_OW 266
74982: PUSH
74983: LD_INT 36
74985: EQUAL
74986: PUSH
74987: LD_VAR 0 4
74991: PPUSH
74992: CALL_OW 313
74996: PUSH
74997: LD_INT 3
74999: LESS
75000: AND
75001: OR
75002: IFFALSE 75016
// begin ct := k ;
75004: LD_ADDR_VAR 0 8
75008: PUSH
75009: LD_VAR 0 4
75013: ST_TO_ADDR
// break ;
75014: GO 75018
// end ;
75016: GO 74944
75018: POP
75019: POP
// if ct then
75020: LD_VAR 0 8
75024: IFFALSE 75040
// ComEnterUnit ( j , ct ) ;
75026: LD_VAR 0 3
75030: PPUSH
75031: LD_VAR 0 8
75035: PPUSH
75036: CALL_OW 120
// end ; end ;
75040: GO 74675
75042: POP
75043: POP
// places := 0 ;
75044: LD_ADDR_VAR 0 5
75048: PUSH
75049: LD_INT 0
75051: ST_TO_ADDR
// for j = 1 to x do
75052: LD_ADDR_VAR 0 3
75056: PUSH
75057: DOUBLE
75058: LD_INT 1
75060: DEC
75061: ST_TO_ADDR
75062: LD_VAR 0 11
75066: PUSH
75067: FOR_TO
75068: IFFALSE 75144
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75070: LD_VAR 0 11
75074: PUSH
75075: LD_VAR 0 3
75079: ARRAY
75080: PPUSH
75081: CALL_OW 264
75085: PUSH
75086: LD_INT 31
75088: EQUAL
75089: IFFALSE 75107
// places := places + 1 else
75091: LD_ADDR_VAR 0 5
75095: PUSH
75096: LD_VAR 0 5
75100: PUSH
75101: LD_INT 1
75103: PLUS
75104: ST_TO_ADDR
75105: GO 75142
// if GetBType ( x [ j ] ) = b_control_tower then
75107: LD_VAR 0 11
75111: PUSH
75112: LD_VAR 0 3
75116: ARRAY
75117: PPUSH
75118: CALL_OW 266
75122: PUSH
75123: LD_INT 36
75125: EQUAL
75126: IFFALSE 75142
// places := places + 3 ;
75128: LD_ADDR_VAR 0 5
75132: PUSH
75133: LD_VAR 0 5
75137: PUSH
75138: LD_INT 3
75140: PLUS
75141: ST_TO_ADDR
75142: GO 75067
75144: POP
75145: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
75146: LD_VAR 0 5
75150: PUSH
75151: LD_INT 0
75153: EQUAL
75154: PUSH
75155: LD_VAR 0 5
75159: PUSH
75160: LD_EXP 63
75164: PUSH
75165: LD_VAR 0 2
75169: ARRAY
75170: LESSEQUAL
75171: OR
75172: IFFALSE 75176
// continue ;
75174: GO 74426
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75176: LD_ADDR_VAR 0 6
75180: PUSH
75181: LD_EXP 23
75185: PUSH
75186: LD_VAR 0 2
75190: ARRAY
75191: PPUSH
75192: LD_INT 25
75194: PUSH
75195: LD_INT 3
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PPUSH
75202: CALL_OW 72
75206: PUSH
75207: LD_EXP 63
75211: PUSH
75212: LD_VAR 0 2
75216: ARRAY
75217: DIFF
75218: PPUSH
75219: LD_INT 3
75221: PPUSH
75222: CALL 46953 0 2
75226: ST_TO_ADDR
// for j in tmp do
75227: LD_ADDR_VAR 0 3
75231: PUSH
75232: LD_VAR 0 6
75236: PUSH
75237: FOR_IN
75238: IFFALSE 75273
// if GetTag ( j ) > 0 then
75240: LD_VAR 0 3
75244: PPUSH
75245: CALL_OW 110
75249: PUSH
75250: LD_INT 0
75252: GREATER
75253: IFFALSE 75271
// tmp := tmp diff j ;
75255: LD_ADDR_VAR 0 6
75259: PUSH
75260: LD_VAR 0 6
75264: PUSH
75265: LD_VAR 0 3
75269: DIFF
75270: ST_TO_ADDR
75271: GO 75237
75273: POP
75274: POP
// if not tmp then
75275: LD_VAR 0 6
75279: NOT
75280: IFFALSE 75284
// continue ;
75282: GO 74426
// if places then
75284: LD_VAR 0 5
75288: IFFALSE 75347
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
75290: LD_ADDR_EXP 63
75294: PUSH
75295: LD_EXP 63
75299: PPUSH
75300: LD_VAR 0 2
75304: PPUSH
75305: LD_EXP 63
75309: PUSH
75310: LD_VAR 0 2
75314: ARRAY
75315: PUSH
75316: LD_VAR 0 6
75320: PUSH
75321: LD_INT 1
75323: ARRAY
75324: UNION
75325: PPUSH
75326: CALL_OW 1
75330: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75331: LD_VAR 0 6
75335: PUSH
75336: LD_INT 1
75338: ARRAY
75339: PPUSH
75340: LD_INT 126
75342: PPUSH
75343: CALL_OW 109
// end ; end ;
75347: GO 74426
75349: POP
75350: POP
// end ;
75351: LD_VAR 0 1
75355: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75356: LD_INT 0
75358: PPUSH
75359: PPUSH
75360: PPUSH
75361: PPUSH
75362: PPUSH
75363: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75364: LD_VAR 0 1
75368: NOT
75369: PUSH
75370: LD_VAR 0 2
75374: NOT
75375: OR
75376: PUSH
75377: LD_VAR 0 3
75381: NOT
75382: OR
75383: PUSH
75384: LD_VAR 0 4
75388: PUSH
75389: LD_INT 1
75391: PUSH
75392: LD_INT 2
75394: PUSH
75395: LD_INT 3
75397: PUSH
75398: LD_INT 4
75400: PUSH
75401: LD_INT 5
75403: PUSH
75404: LD_INT 8
75406: PUSH
75407: LD_INT 9
75409: PUSH
75410: LD_INT 15
75412: PUSH
75413: LD_INT 16
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: LIST
75420: LIST
75421: LIST
75422: LIST
75423: LIST
75424: LIST
75425: LIST
75426: IN
75427: NOT
75428: OR
75429: IFFALSE 75433
// exit ;
75431: GO 76291
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75433: LD_ADDR_VAR 0 2
75437: PUSH
75438: LD_VAR 0 2
75442: PPUSH
75443: LD_INT 21
75445: PUSH
75446: LD_INT 3
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: LD_INT 24
75455: PUSH
75456: LD_INT 250
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: PPUSH
75467: CALL_OW 72
75471: ST_TO_ADDR
// case class of 1 , 15 :
75472: LD_VAR 0 4
75476: PUSH
75477: LD_INT 1
75479: DOUBLE
75480: EQUAL
75481: IFTRUE 75491
75483: LD_INT 15
75485: DOUBLE
75486: EQUAL
75487: IFTRUE 75491
75489: GO 75576
75491: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75492: LD_ADDR_VAR 0 8
75496: PUSH
75497: LD_VAR 0 2
75501: PPUSH
75502: LD_INT 2
75504: PUSH
75505: LD_INT 30
75507: PUSH
75508: LD_INT 32
75510: PUSH
75511: EMPTY
75512: LIST
75513: LIST
75514: PUSH
75515: LD_INT 30
75517: PUSH
75518: LD_INT 31
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: EMPTY
75526: LIST
75527: LIST
75528: LIST
75529: PPUSH
75530: CALL_OW 72
75534: PUSH
75535: LD_VAR 0 2
75539: PPUSH
75540: LD_INT 2
75542: PUSH
75543: LD_INT 30
75545: PUSH
75546: LD_INT 4
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 30
75555: PUSH
75556: LD_INT 5
75558: PUSH
75559: EMPTY
75560: LIST
75561: LIST
75562: PUSH
75563: EMPTY
75564: LIST
75565: LIST
75566: LIST
75567: PPUSH
75568: CALL_OW 72
75572: ADD
75573: ST_TO_ADDR
75574: GO 75822
75576: LD_INT 2
75578: DOUBLE
75579: EQUAL
75580: IFTRUE 75590
75582: LD_INT 16
75584: DOUBLE
75585: EQUAL
75586: IFTRUE 75590
75588: GO 75636
75590: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75591: LD_ADDR_VAR 0 8
75595: PUSH
75596: LD_VAR 0 2
75600: PPUSH
75601: LD_INT 2
75603: PUSH
75604: LD_INT 30
75606: PUSH
75607: LD_INT 0
75609: PUSH
75610: EMPTY
75611: LIST
75612: LIST
75613: PUSH
75614: LD_INT 30
75616: PUSH
75617: LD_INT 1
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: LIST
75628: PPUSH
75629: CALL_OW 72
75633: ST_TO_ADDR
75634: GO 75822
75636: LD_INT 3
75638: DOUBLE
75639: EQUAL
75640: IFTRUE 75644
75642: GO 75690
75644: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75645: LD_ADDR_VAR 0 8
75649: PUSH
75650: LD_VAR 0 2
75654: PPUSH
75655: LD_INT 2
75657: PUSH
75658: LD_INT 30
75660: PUSH
75661: LD_INT 2
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 30
75670: PUSH
75671: LD_INT 3
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: LIST
75682: PPUSH
75683: CALL_OW 72
75687: ST_TO_ADDR
75688: GO 75822
75690: LD_INT 4
75692: DOUBLE
75693: EQUAL
75694: IFTRUE 75698
75696: GO 75755
75698: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75699: LD_ADDR_VAR 0 8
75703: PUSH
75704: LD_VAR 0 2
75708: PPUSH
75709: LD_INT 2
75711: PUSH
75712: LD_INT 30
75714: PUSH
75715: LD_INT 6
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 30
75724: PUSH
75725: LD_INT 7
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PUSH
75732: LD_INT 30
75734: PUSH
75735: LD_INT 8
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: LIST
75746: LIST
75747: PPUSH
75748: CALL_OW 72
75752: ST_TO_ADDR
75753: GO 75822
75755: LD_INT 5
75757: DOUBLE
75758: EQUAL
75759: IFTRUE 75775
75761: LD_INT 8
75763: DOUBLE
75764: EQUAL
75765: IFTRUE 75775
75767: LD_INT 9
75769: DOUBLE
75770: EQUAL
75771: IFTRUE 75775
75773: GO 75821
75775: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75776: LD_ADDR_VAR 0 8
75780: PUSH
75781: LD_VAR 0 2
75785: PPUSH
75786: LD_INT 2
75788: PUSH
75789: LD_INT 30
75791: PUSH
75792: LD_INT 4
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 30
75801: PUSH
75802: LD_INT 5
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: LIST
75813: PPUSH
75814: CALL_OW 72
75818: ST_TO_ADDR
75819: GO 75822
75821: POP
// if not tmp then
75822: LD_VAR 0 8
75826: NOT
75827: IFFALSE 75831
// exit ;
75829: GO 76291
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75831: LD_VAR 0 4
75835: PUSH
75836: LD_INT 1
75838: PUSH
75839: LD_INT 15
75841: PUSH
75842: EMPTY
75843: LIST
75844: LIST
75845: IN
75846: PUSH
75847: LD_EXP 32
75851: PUSH
75852: LD_VAR 0 1
75856: ARRAY
75857: AND
75858: IFFALSE 76014
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75860: LD_ADDR_VAR 0 9
75864: PUSH
75865: LD_EXP 32
75869: PUSH
75870: LD_VAR 0 1
75874: ARRAY
75875: PUSH
75876: LD_INT 1
75878: ARRAY
75879: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75880: LD_VAR 0 9
75884: PUSH
75885: LD_EXP 33
75889: PUSH
75890: LD_VAR 0 1
75894: ARRAY
75895: IN
75896: NOT
75897: IFFALSE 76012
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75899: LD_ADDR_EXP 33
75903: PUSH
75904: LD_EXP 33
75908: PPUSH
75909: LD_VAR 0 1
75913: PUSH
75914: LD_EXP 33
75918: PUSH
75919: LD_VAR 0 1
75923: ARRAY
75924: PUSH
75925: LD_INT 1
75927: PLUS
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: PPUSH
75933: LD_VAR 0 9
75937: PPUSH
75938: CALL 16077 0 3
75942: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75943: LD_ADDR_EXP 32
75947: PUSH
75948: LD_EXP 32
75952: PPUSH
75953: LD_VAR 0 1
75957: PPUSH
75958: LD_EXP 32
75962: PUSH
75963: LD_VAR 0 1
75967: ARRAY
75968: PUSH
75969: LD_VAR 0 9
75973: DIFF
75974: PPUSH
75975: CALL_OW 1
75979: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75980: LD_VAR 0 3
75984: PPUSH
75985: LD_EXP 33
75989: PUSH
75990: LD_VAR 0 1
75994: ARRAY
75995: PUSH
75996: LD_EXP 33
76000: PUSH
76001: LD_VAR 0 1
76005: ARRAY
76006: ARRAY
76007: PPUSH
76008: CALL_OW 120
// end ; exit ;
76012: GO 76291
// end ; if tmp > 1 then
76014: LD_VAR 0 8
76018: PUSH
76019: LD_INT 1
76021: GREATER
76022: IFFALSE 76126
// for i = 2 to tmp do
76024: LD_ADDR_VAR 0 6
76028: PUSH
76029: DOUBLE
76030: LD_INT 2
76032: DEC
76033: ST_TO_ADDR
76034: LD_VAR 0 8
76038: PUSH
76039: FOR_TO
76040: IFFALSE 76124
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76042: LD_VAR 0 8
76046: PUSH
76047: LD_VAR 0 6
76051: ARRAY
76052: PPUSH
76053: CALL_OW 461
76057: PUSH
76058: LD_INT 6
76060: EQUAL
76061: IFFALSE 76122
// begin x := tmp [ i ] ;
76063: LD_ADDR_VAR 0 9
76067: PUSH
76068: LD_VAR 0 8
76072: PUSH
76073: LD_VAR 0 6
76077: ARRAY
76078: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76079: LD_ADDR_VAR 0 8
76083: PUSH
76084: LD_VAR 0 8
76088: PPUSH
76089: LD_VAR 0 6
76093: PPUSH
76094: CALL_OW 3
76098: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76099: LD_ADDR_VAR 0 8
76103: PUSH
76104: LD_VAR 0 8
76108: PPUSH
76109: LD_INT 1
76111: PPUSH
76112: LD_VAR 0 9
76116: PPUSH
76117: CALL_OW 2
76121: ST_TO_ADDR
// end ;
76122: GO 76039
76124: POP
76125: POP
// for i in tmp do
76126: LD_ADDR_VAR 0 6
76130: PUSH
76131: LD_VAR 0 8
76135: PUSH
76136: FOR_IN
76137: IFFALSE 76164
// begin if IsNotFull ( i ) then
76139: LD_VAR 0 6
76143: PPUSH
76144: CALL 13299 0 1
76148: IFFALSE 76162
// begin j := i ;
76150: LD_ADDR_VAR 0 7
76154: PUSH
76155: LD_VAR 0 6
76159: ST_TO_ADDR
// break ;
76160: GO 76164
// end ; end ;
76162: GO 76136
76164: POP
76165: POP
// if j then
76166: LD_VAR 0 7
76170: IFFALSE 76188
// ComEnterUnit ( unit , j ) else
76172: LD_VAR 0 3
76176: PPUSH
76177: LD_VAR 0 7
76181: PPUSH
76182: CALL_OW 120
76186: GO 76291
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76188: LD_ADDR_VAR 0 10
76192: PUSH
76193: LD_VAR 0 2
76197: PPUSH
76198: LD_INT 2
76200: PUSH
76201: LD_INT 30
76203: PUSH
76204: LD_INT 0
76206: PUSH
76207: EMPTY
76208: LIST
76209: LIST
76210: PUSH
76211: LD_INT 30
76213: PUSH
76214: LD_INT 1
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: EMPTY
76222: LIST
76223: LIST
76224: LIST
76225: PPUSH
76226: CALL_OW 72
76230: ST_TO_ADDR
// if depot then
76231: LD_VAR 0 10
76235: IFFALSE 76291
// begin depot := NearestUnitToUnit ( depot , unit ) ;
76237: LD_ADDR_VAR 0 10
76241: PUSH
76242: LD_VAR 0 10
76246: PPUSH
76247: LD_VAR 0 3
76251: PPUSH
76252: CALL_OW 74
76256: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76257: LD_VAR 0 3
76261: PPUSH
76262: LD_VAR 0 10
76266: PPUSH
76267: CALL_OW 296
76271: PUSH
76272: LD_INT 10
76274: GREATER
76275: IFFALSE 76291
// ComStandNearbyBuilding ( unit , depot ) ;
76277: LD_VAR 0 3
76281: PPUSH
76282: LD_VAR 0 10
76286: PPUSH
76287: CALL 12679 0 2
// end ; end ; end ;
76291: LD_VAR 0 5
76295: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76296: LD_INT 0
76298: PPUSH
76299: PPUSH
76300: PPUSH
76301: PPUSH
// if not mc_bases then
76302: LD_EXP 23
76306: NOT
76307: IFFALSE 76311
// exit ;
76309: GO 76550
// for i = 1 to mc_bases do
76311: LD_ADDR_VAR 0 2
76315: PUSH
76316: DOUBLE
76317: LD_INT 1
76319: DEC
76320: ST_TO_ADDR
76321: LD_EXP 23
76325: PUSH
76326: FOR_TO
76327: IFFALSE 76548
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76329: LD_ADDR_VAR 0 4
76333: PUSH
76334: LD_EXP 23
76338: PUSH
76339: LD_VAR 0 2
76343: ARRAY
76344: PPUSH
76345: LD_INT 21
76347: PUSH
76348: LD_INT 1
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: PPUSH
76355: CALL_OW 72
76359: PUSH
76360: LD_EXP 52
76364: PUSH
76365: LD_VAR 0 2
76369: ARRAY
76370: UNION
76371: ST_TO_ADDR
// if not tmp then
76372: LD_VAR 0 4
76376: NOT
76377: IFFALSE 76381
// continue ;
76379: GO 76326
// for j in tmp do
76381: LD_ADDR_VAR 0 3
76385: PUSH
76386: LD_VAR 0 4
76390: PUSH
76391: FOR_IN
76392: IFFALSE 76544
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76394: LD_VAR 0 3
76398: PPUSH
76399: CALL_OW 110
76403: NOT
76404: PUSH
76405: LD_VAR 0 3
76409: PPUSH
76410: CALL_OW 314
76414: NOT
76415: AND
76416: PUSH
76417: LD_VAR 0 3
76421: PPUSH
76422: CALL_OW 311
76426: NOT
76427: AND
76428: PUSH
76429: LD_VAR 0 3
76433: PPUSH
76434: CALL_OW 310
76438: NOT
76439: AND
76440: PUSH
76441: LD_VAR 0 3
76445: PUSH
76446: LD_EXP 26
76450: PUSH
76451: LD_VAR 0 2
76455: ARRAY
76456: PUSH
76457: LD_INT 1
76459: ARRAY
76460: IN
76461: NOT
76462: AND
76463: PUSH
76464: LD_VAR 0 3
76468: PUSH
76469: LD_EXP 26
76473: PUSH
76474: LD_VAR 0 2
76478: ARRAY
76479: PUSH
76480: LD_INT 2
76482: ARRAY
76483: IN
76484: NOT
76485: AND
76486: PUSH
76487: LD_VAR 0 3
76491: PUSH
76492: LD_EXP 35
76496: PUSH
76497: LD_VAR 0 2
76501: ARRAY
76502: IN
76503: NOT
76504: AND
76505: IFFALSE 76542
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76507: LD_VAR 0 2
76511: PPUSH
76512: LD_EXP 23
76516: PUSH
76517: LD_VAR 0 2
76521: ARRAY
76522: PPUSH
76523: LD_VAR 0 3
76527: PPUSH
76528: LD_VAR 0 3
76532: PPUSH
76533: CALL_OW 257
76537: PPUSH
76538: CALL 75356 0 4
// end ;
76542: GO 76391
76544: POP
76545: POP
// end ;
76546: GO 76326
76548: POP
76549: POP
// end ;
76550: LD_VAR 0 1
76554: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
76555: LD_INT 0
76557: PPUSH
76558: PPUSH
76559: PPUSH
76560: PPUSH
76561: PPUSH
76562: PPUSH
// if not mc_bases [ base ] then
76563: LD_EXP 23
76567: PUSH
76568: LD_VAR 0 1
76572: ARRAY
76573: NOT
76574: IFFALSE 76578
// exit ;
76576: GO 76779
// tmp := [ ] ;
76578: LD_ADDR_VAR 0 6
76582: PUSH
76583: EMPTY
76584: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76585: LD_ADDR_VAR 0 7
76589: PUSH
76590: LD_VAR 0 3
76594: PPUSH
76595: LD_INT 0
76597: PPUSH
76598: CALL_OW 517
76602: ST_TO_ADDR
// if not list then
76603: LD_VAR 0 7
76607: NOT
76608: IFFALSE 76612
// exit ;
76610: GO 76779
// c := Count ( list [ 1 ] ) ;
76612: LD_ADDR_VAR 0 9
76616: PUSH
76617: LD_VAR 0 7
76621: PUSH
76622: LD_INT 1
76624: ARRAY
76625: PPUSH
76626: CALL 13217 0 1
76630: ST_TO_ADDR
// if amount > c then
76631: LD_VAR 0 2
76635: PUSH
76636: LD_VAR 0 9
76640: GREATER
76641: IFFALSE 76653
// amount := c ;
76643: LD_ADDR_VAR 0 2
76647: PUSH
76648: LD_VAR 0 9
76652: ST_TO_ADDR
// for i := 1 to amount do
76653: LD_ADDR_VAR 0 5
76657: PUSH
76658: DOUBLE
76659: LD_INT 1
76661: DEC
76662: ST_TO_ADDR
76663: LD_VAR 0 2
76667: PUSH
76668: FOR_TO
76669: IFFALSE 76727
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
76671: LD_ADDR_VAR 0 6
76675: PUSH
76676: LD_VAR 0 6
76680: PPUSH
76681: LD_VAR 0 5
76685: PPUSH
76686: LD_VAR 0 7
76690: PUSH
76691: LD_INT 1
76693: ARRAY
76694: PUSH
76695: LD_VAR 0 5
76699: ARRAY
76700: PUSH
76701: LD_VAR 0 7
76705: PUSH
76706: LD_INT 2
76708: ARRAY
76709: PUSH
76710: LD_VAR 0 5
76714: ARRAY
76715: PUSH
76716: EMPTY
76717: LIST
76718: LIST
76719: PPUSH
76720: CALL_OW 1
76724: ST_TO_ADDR
76725: GO 76668
76727: POP
76728: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76729: LD_ADDR_EXP 36
76733: PUSH
76734: LD_EXP 36
76738: PPUSH
76739: LD_VAR 0 1
76743: PPUSH
76744: LD_VAR 0 6
76748: PPUSH
76749: CALL_OW 1
76753: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76754: LD_ADDR_EXP 38
76758: PUSH
76759: LD_EXP 38
76763: PPUSH
76764: LD_VAR 0 1
76768: PPUSH
76769: LD_VAR 0 3
76773: PPUSH
76774: CALL_OW 1
76778: ST_TO_ADDR
// end ;
76779: LD_VAR 0 4
76783: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76784: LD_INT 0
76786: PPUSH
// if not mc_bases [ base ] then
76787: LD_EXP 23
76791: PUSH
76792: LD_VAR 0 1
76796: ARRAY
76797: NOT
76798: IFFALSE 76802
// exit ;
76800: GO 76827
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76802: LD_ADDR_EXP 28
76806: PUSH
76807: LD_EXP 28
76811: PPUSH
76812: LD_VAR 0 1
76816: PPUSH
76817: LD_VAR 0 2
76821: PPUSH
76822: CALL_OW 1
76826: ST_TO_ADDR
// end ;
76827: LD_VAR 0 3
76831: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76832: LD_INT 0
76834: PPUSH
// if not mc_bases [ base ] then
76835: LD_EXP 23
76839: PUSH
76840: LD_VAR 0 1
76844: ARRAY
76845: NOT
76846: IFFALSE 76850
// exit ;
76848: GO 76887
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76850: LD_ADDR_EXP 28
76854: PUSH
76855: LD_EXP 28
76859: PPUSH
76860: LD_VAR 0 1
76864: PPUSH
76865: LD_EXP 28
76869: PUSH
76870: LD_VAR 0 1
76874: ARRAY
76875: PUSH
76876: LD_VAR 0 2
76880: UNION
76881: PPUSH
76882: CALL_OW 1
76886: ST_TO_ADDR
// end ;
76887: LD_VAR 0 3
76891: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76892: LD_INT 0
76894: PPUSH
// if not mc_bases [ base ] then
76895: LD_EXP 23
76899: PUSH
76900: LD_VAR 0 1
76904: ARRAY
76905: NOT
76906: IFFALSE 76910
// exit ;
76908: GO 76935
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76910: LD_ADDR_EXP 44
76914: PUSH
76915: LD_EXP 44
76919: PPUSH
76920: LD_VAR 0 1
76924: PPUSH
76925: LD_VAR 0 2
76929: PPUSH
76930: CALL_OW 1
76934: ST_TO_ADDR
// end ;
76935: LD_VAR 0 3
76939: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76940: LD_INT 0
76942: PPUSH
// if not mc_bases [ base ] then
76943: LD_EXP 23
76947: PUSH
76948: LD_VAR 0 1
76952: ARRAY
76953: NOT
76954: IFFALSE 76958
// exit ;
76956: GO 76995
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76958: LD_ADDR_EXP 44
76962: PUSH
76963: LD_EXP 44
76967: PPUSH
76968: LD_VAR 0 1
76972: PPUSH
76973: LD_EXP 44
76977: PUSH
76978: LD_VAR 0 1
76982: ARRAY
76983: PUSH
76984: LD_VAR 0 2
76988: ADD
76989: PPUSH
76990: CALL_OW 1
76994: ST_TO_ADDR
// end ;
76995: LD_VAR 0 3
76999: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77000: LD_INT 0
77002: PPUSH
// if not mc_bases [ base ] then
77003: LD_EXP 23
77007: PUSH
77008: LD_VAR 0 1
77012: ARRAY
77013: NOT
77014: IFFALSE 77018
// exit ;
77016: GO 77072
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77018: LD_ADDR_EXP 45
77022: PUSH
77023: LD_EXP 45
77027: PPUSH
77028: LD_VAR 0 1
77032: PPUSH
77033: LD_VAR 0 2
77037: PPUSH
77038: CALL_OW 1
77042: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77043: LD_ADDR_EXP 34
77047: PUSH
77048: LD_EXP 34
77052: PPUSH
77053: LD_VAR 0 1
77057: PPUSH
77058: LD_VAR 0 2
77062: PUSH
77063: LD_INT 0
77065: PLUS
77066: PPUSH
77067: CALL_OW 1
77071: ST_TO_ADDR
// end ;
77072: LD_VAR 0 3
77076: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77077: LD_INT 0
77079: PPUSH
// if not mc_bases [ base ] then
77080: LD_EXP 23
77084: PUSH
77085: LD_VAR 0 1
77089: ARRAY
77090: NOT
77091: IFFALSE 77095
// exit ;
77093: GO 77120
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77095: LD_ADDR_EXP 34
77099: PUSH
77100: LD_EXP 34
77104: PPUSH
77105: LD_VAR 0 1
77109: PPUSH
77110: LD_VAR 0 2
77114: PPUSH
77115: CALL_OW 1
77119: ST_TO_ADDR
// end ;
77120: LD_VAR 0 3
77124: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77125: LD_INT 0
77127: PPUSH
77128: PPUSH
77129: PPUSH
77130: PPUSH
// if not mc_bases [ base ] then
77131: LD_EXP 23
77135: PUSH
77136: LD_VAR 0 1
77140: ARRAY
77141: NOT
77142: IFFALSE 77146
// exit ;
77144: GO 77211
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77146: LD_ADDR_EXP 43
77150: PUSH
77151: LD_EXP 43
77155: PPUSH
77156: LD_VAR 0 1
77160: PUSH
77161: LD_EXP 43
77165: PUSH
77166: LD_VAR 0 1
77170: ARRAY
77171: PUSH
77172: LD_INT 1
77174: PLUS
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PPUSH
77180: LD_VAR 0 1
77184: PUSH
77185: LD_VAR 0 2
77189: PUSH
77190: LD_VAR 0 3
77194: PUSH
77195: LD_VAR 0 4
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: PPUSH
77206: CALL 16077 0 3
77210: ST_TO_ADDR
// end ;
77211: LD_VAR 0 5
77215: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77216: LD_INT 0
77218: PPUSH
// if not mc_bases [ base ] then
77219: LD_EXP 23
77223: PUSH
77224: LD_VAR 0 1
77228: ARRAY
77229: NOT
77230: IFFALSE 77234
// exit ;
77232: GO 77259
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77234: LD_ADDR_EXP 60
77238: PUSH
77239: LD_EXP 60
77243: PPUSH
77244: LD_VAR 0 1
77248: PPUSH
77249: LD_VAR 0 2
77253: PPUSH
77254: CALL_OW 1
77258: ST_TO_ADDR
// end ;
77259: LD_VAR 0 3
77263: RET
// export function MC_GetMinesField ( base ) ; begin
77264: LD_INT 0
77266: PPUSH
// result := mc_mines [ base ] ;
77267: LD_ADDR_VAR 0 2
77271: PUSH
77272: LD_EXP 36
77276: PUSH
77277: LD_VAR 0 1
77281: ARRAY
77282: ST_TO_ADDR
// end ;
77283: LD_VAR 0 2
77287: RET
// export function MC_GetProduceList ( base ) ; begin
77288: LD_INT 0
77290: PPUSH
// result := mc_produce [ base ] ;
77291: LD_ADDR_VAR 0 2
77295: PUSH
77296: LD_EXP 44
77300: PUSH
77301: LD_VAR 0 1
77305: ARRAY
77306: ST_TO_ADDR
// end ;
77307: LD_VAR 0 2
77311: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77312: LD_INT 0
77314: PPUSH
77315: PPUSH
// if not mc_bases then
77316: LD_EXP 23
77320: NOT
77321: IFFALSE 77325
// exit ;
77323: GO 77390
// if mc_bases [ base ] then
77325: LD_EXP 23
77329: PUSH
77330: LD_VAR 0 1
77334: ARRAY
77335: IFFALSE 77390
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77337: LD_ADDR_VAR 0 3
77341: PUSH
77342: LD_EXP 23
77346: PUSH
77347: LD_VAR 0 1
77351: ARRAY
77352: PPUSH
77353: LD_INT 30
77355: PUSH
77356: LD_VAR 0 2
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PPUSH
77365: CALL_OW 72
77369: ST_TO_ADDR
// if result then
77370: LD_VAR 0 3
77374: IFFALSE 77390
// result := result [ 1 ] ;
77376: LD_ADDR_VAR 0 3
77380: PUSH
77381: LD_VAR 0 3
77385: PUSH
77386: LD_INT 1
77388: ARRAY
77389: ST_TO_ADDR
// end ; end ;
77390: LD_VAR 0 3
77394: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
77395: LD_INT 0
77397: PPUSH
77398: PPUSH
// if not mc_bases then
77399: LD_EXP 23
77403: NOT
77404: IFFALSE 77408
// exit ;
77406: GO 77453
// if mc_bases [ base ] then
77408: LD_EXP 23
77412: PUSH
77413: LD_VAR 0 1
77417: ARRAY
77418: IFFALSE 77453
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77420: LD_ADDR_VAR 0 3
77424: PUSH
77425: LD_EXP 23
77429: PUSH
77430: LD_VAR 0 1
77434: ARRAY
77435: PPUSH
77436: LD_INT 30
77438: PUSH
77439: LD_VAR 0 2
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PPUSH
77448: CALL_OW 72
77452: ST_TO_ADDR
// end ;
77453: LD_VAR 0 3
77457: RET
// export function MC_SetTame ( base , area ) ; begin
77458: LD_INT 0
77460: PPUSH
// if not mc_bases or not base then
77461: LD_EXP 23
77465: NOT
77466: PUSH
77467: LD_VAR 0 1
77471: NOT
77472: OR
77473: IFFALSE 77477
// exit ;
77475: GO 77502
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77477: LD_ADDR_EXP 51
77481: PUSH
77482: LD_EXP 51
77486: PPUSH
77487: LD_VAR 0 1
77491: PPUSH
77492: LD_VAR 0 2
77496: PPUSH
77497: CALL_OW 1
77501: ST_TO_ADDR
// end ;
77502: LD_VAR 0 3
77506: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77507: LD_INT 0
77509: PPUSH
77510: PPUSH
// if not mc_bases or not base then
77511: LD_EXP 23
77515: NOT
77516: PUSH
77517: LD_VAR 0 1
77521: NOT
77522: OR
77523: IFFALSE 77527
// exit ;
77525: GO 77629
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77527: LD_ADDR_VAR 0 4
77531: PUSH
77532: LD_EXP 23
77536: PUSH
77537: LD_VAR 0 1
77541: ARRAY
77542: PPUSH
77543: LD_INT 30
77545: PUSH
77546: LD_VAR 0 2
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PPUSH
77555: CALL_OW 72
77559: ST_TO_ADDR
// if not tmp then
77560: LD_VAR 0 4
77564: NOT
77565: IFFALSE 77569
// exit ;
77567: GO 77629
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77569: LD_ADDR_EXP 55
77573: PUSH
77574: LD_EXP 55
77578: PPUSH
77579: LD_VAR 0 1
77583: PPUSH
77584: LD_EXP 55
77588: PUSH
77589: LD_VAR 0 1
77593: ARRAY
77594: PPUSH
77595: LD_EXP 55
77599: PUSH
77600: LD_VAR 0 1
77604: ARRAY
77605: PUSH
77606: LD_INT 1
77608: PLUS
77609: PPUSH
77610: LD_VAR 0 4
77614: PUSH
77615: LD_INT 1
77617: ARRAY
77618: PPUSH
77619: CALL_OW 2
77623: PPUSH
77624: CALL_OW 1
77628: ST_TO_ADDR
// end ;
77629: LD_VAR 0 3
77633: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77634: LD_INT 0
77636: PPUSH
77637: PPUSH
// if not mc_bases or not base or not kinds then
77638: LD_EXP 23
77642: NOT
77643: PUSH
77644: LD_VAR 0 1
77648: NOT
77649: OR
77650: PUSH
77651: LD_VAR 0 2
77655: NOT
77656: OR
77657: IFFALSE 77661
// exit ;
77659: GO 77722
// for i in kinds do
77661: LD_ADDR_VAR 0 4
77665: PUSH
77666: LD_VAR 0 2
77670: PUSH
77671: FOR_IN
77672: IFFALSE 77720
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77674: LD_ADDR_EXP 57
77678: PUSH
77679: LD_EXP 57
77683: PPUSH
77684: LD_VAR 0 1
77688: PUSH
77689: LD_EXP 57
77693: PUSH
77694: LD_VAR 0 1
77698: ARRAY
77699: PUSH
77700: LD_INT 1
77702: PLUS
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PPUSH
77708: LD_VAR 0 4
77712: PPUSH
77713: CALL 16077 0 3
77717: ST_TO_ADDR
77718: GO 77671
77720: POP
77721: POP
// end ;
77722: LD_VAR 0 3
77726: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77727: LD_INT 0
77729: PPUSH
// if not mc_bases or not base or not areas then
77730: LD_EXP 23
77734: NOT
77735: PUSH
77736: LD_VAR 0 1
77740: NOT
77741: OR
77742: PUSH
77743: LD_VAR 0 2
77747: NOT
77748: OR
77749: IFFALSE 77753
// exit ;
77751: GO 77778
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77753: LD_ADDR_EXP 41
77757: PUSH
77758: LD_EXP 41
77762: PPUSH
77763: LD_VAR 0 1
77767: PPUSH
77768: LD_VAR 0 2
77772: PPUSH
77773: CALL_OW 1
77777: ST_TO_ADDR
// end ;
77778: LD_VAR 0 3
77782: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77783: LD_INT 0
77785: PPUSH
// if not mc_bases or not base or not teleports_exit then
77786: LD_EXP 23
77790: NOT
77791: PUSH
77792: LD_VAR 0 1
77796: NOT
77797: OR
77798: PUSH
77799: LD_VAR 0 2
77803: NOT
77804: OR
77805: IFFALSE 77809
// exit ;
77807: GO 77834
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77809: LD_ADDR_EXP 58
77813: PUSH
77814: LD_EXP 58
77818: PPUSH
77819: LD_VAR 0 1
77823: PPUSH
77824: LD_VAR 0 2
77828: PPUSH
77829: CALL_OW 1
77833: ST_TO_ADDR
// end ;
77834: LD_VAR 0 3
77838: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77839: LD_INT 0
77841: PPUSH
77842: PPUSH
77843: PPUSH
// if not mc_bases or not base or not ext_list then
77844: LD_EXP 23
77848: NOT
77849: PUSH
77850: LD_VAR 0 1
77854: NOT
77855: OR
77856: PUSH
77857: LD_VAR 0 5
77861: NOT
77862: OR
77863: IFFALSE 77867
// exit ;
77865: GO 78040
// tmp := GetFacExtXYD ( x , y , d ) ;
77867: LD_ADDR_VAR 0 8
77871: PUSH
77872: LD_VAR 0 2
77876: PPUSH
77877: LD_VAR 0 3
77881: PPUSH
77882: LD_VAR 0 4
77886: PPUSH
77887: CALL 46083 0 3
77891: ST_TO_ADDR
// if not tmp then
77892: LD_VAR 0 8
77896: NOT
77897: IFFALSE 77901
// exit ;
77899: GO 78040
// for i in tmp do
77901: LD_ADDR_VAR 0 7
77905: PUSH
77906: LD_VAR 0 8
77910: PUSH
77911: FOR_IN
77912: IFFALSE 78038
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77914: LD_ADDR_EXP 28
77918: PUSH
77919: LD_EXP 28
77923: PPUSH
77924: LD_VAR 0 1
77928: PPUSH
77929: LD_EXP 28
77933: PUSH
77934: LD_VAR 0 1
77938: ARRAY
77939: PPUSH
77940: LD_EXP 28
77944: PUSH
77945: LD_VAR 0 1
77949: ARRAY
77950: PUSH
77951: LD_INT 1
77953: PLUS
77954: PPUSH
77955: LD_VAR 0 5
77959: PUSH
77960: LD_INT 1
77962: ARRAY
77963: PUSH
77964: LD_VAR 0 7
77968: PUSH
77969: LD_INT 1
77971: ARRAY
77972: PUSH
77973: LD_VAR 0 7
77977: PUSH
77978: LD_INT 2
77980: ARRAY
77981: PUSH
77982: LD_VAR 0 7
77986: PUSH
77987: LD_INT 3
77989: ARRAY
77990: PUSH
77991: EMPTY
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: PPUSH
77997: CALL_OW 2
78001: PPUSH
78002: CALL_OW 1
78006: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78007: LD_ADDR_VAR 0 5
78011: PUSH
78012: LD_VAR 0 5
78016: PPUSH
78017: LD_INT 1
78019: PPUSH
78020: CALL_OW 3
78024: ST_TO_ADDR
// if not ext_list then
78025: LD_VAR 0 5
78029: NOT
78030: IFFALSE 78036
// exit ;
78032: POP
78033: POP
78034: GO 78040
// end ;
78036: GO 77911
78038: POP
78039: POP
// end ;
78040: LD_VAR 0 6
78044: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78045: LD_INT 0
78047: PPUSH
// if not mc_bases or not base or not weapon_list then
78048: LD_EXP 23
78052: NOT
78053: PUSH
78054: LD_VAR 0 1
78058: NOT
78059: OR
78060: PUSH
78061: LD_VAR 0 2
78065: NOT
78066: OR
78067: IFFALSE 78071
// exit ;
78069: GO 78096
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78071: LD_ADDR_EXP 62
78075: PUSH
78076: LD_EXP 62
78080: PPUSH
78081: LD_VAR 0 1
78085: PPUSH
78086: LD_VAR 0 2
78090: PPUSH
78091: CALL_OW 1
78095: ST_TO_ADDR
// end ;
78096: LD_VAR 0 3
78100: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78101: LD_INT 0
78103: PPUSH
// if not mc_bases or not base or not tech_list then
78104: LD_EXP 23
78108: NOT
78109: PUSH
78110: LD_VAR 0 1
78114: NOT
78115: OR
78116: PUSH
78117: LD_VAR 0 2
78121: NOT
78122: OR
78123: IFFALSE 78127
// exit ;
78125: GO 78152
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78127: LD_ADDR_EXP 50
78131: PUSH
78132: LD_EXP 50
78136: PPUSH
78137: LD_VAR 0 1
78141: PPUSH
78142: LD_VAR 0 2
78146: PPUSH
78147: CALL_OW 1
78151: ST_TO_ADDR
// end ;
78152: LD_VAR 0 3
78156: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78157: LD_INT 0
78159: PPUSH
// if not mc_bases or not parking_area or not base then
78160: LD_EXP 23
78164: NOT
78165: PUSH
78166: LD_VAR 0 2
78170: NOT
78171: OR
78172: PUSH
78173: LD_VAR 0 1
78177: NOT
78178: OR
78179: IFFALSE 78183
// exit ;
78181: GO 78208
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78183: LD_ADDR_EXP 47
78187: PUSH
78188: LD_EXP 47
78192: PPUSH
78193: LD_VAR 0 1
78197: PPUSH
78198: LD_VAR 0 2
78202: PPUSH
78203: CALL_OW 1
78207: ST_TO_ADDR
// end ;
78208: LD_VAR 0 3
78212: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78213: LD_INT 0
78215: PPUSH
// if not mc_bases or not base or not scan_area then
78216: LD_EXP 23
78220: NOT
78221: PUSH
78222: LD_VAR 0 1
78226: NOT
78227: OR
78228: PUSH
78229: LD_VAR 0 2
78233: NOT
78234: OR
78235: IFFALSE 78239
// exit ;
78237: GO 78264
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78239: LD_ADDR_EXP 48
78243: PUSH
78244: LD_EXP 48
78248: PPUSH
78249: LD_VAR 0 1
78253: PPUSH
78254: LD_VAR 0 2
78258: PPUSH
78259: CALL_OW 1
78263: ST_TO_ADDR
// end ;
78264: LD_VAR 0 3
78268: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
78269: LD_INT 0
78271: PPUSH
78272: PPUSH
// if not mc_bases or not base then
78273: LD_EXP 23
78277: NOT
78278: PUSH
78279: LD_VAR 0 1
78283: NOT
78284: OR
78285: IFFALSE 78289
// exit ;
78287: GO 78353
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78289: LD_ADDR_VAR 0 3
78293: PUSH
78294: LD_INT 1
78296: PUSH
78297: LD_INT 2
78299: PUSH
78300: LD_INT 3
78302: PUSH
78303: LD_INT 4
78305: PUSH
78306: LD_INT 11
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: LIST
78313: LIST
78314: LIST
78315: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78316: LD_ADDR_EXP 50
78320: PUSH
78321: LD_EXP 50
78325: PPUSH
78326: LD_VAR 0 1
78330: PPUSH
78331: LD_EXP 50
78335: PUSH
78336: LD_VAR 0 1
78340: ARRAY
78341: PUSH
78342: LD_VAR 0 3
78346: DIFF
78347: PPUSH
78348: CALL_OW 1
78352: ST_TO_ADDR
// end ;
78353: LD_VAR 0 2
78357: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78358: LD_INT 0
78360: PPUSH
// result := mc_vehicles [ base ] ;
78361: LD_ADDR_VAR 0 3
78365: PUSH
78366: LD_EXP 42
78370: PUSH
78371: LD_VAR 0 1
78375: ARRAY
78376: ST_TO_ADDR
// if onlyCombat then
78377: LD_VAR 0 2
78381: IFFALSE 78553
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78383: LD_ADDR_VAR 0 3
78387: PUSH
78388: LD_VAR 0 3
78392: PUSH
78393: LD_VAR 0 3
78397: PPUSH
78398: LD_INT 2
78400: PUSH
78401: LD_INT 34
78403: PUSH
78404: LD_INT 12
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 34
78413: PUSH
78414: LD_INT 51
78416: PUSH
78417: EMPTY
78418: LIST
78419: LIST
78420: PUSH
78421: LD_INT 34
78423: PUSH
78424: LD_INT 89
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 34
78433: PUSH
78434: LD_INT 32
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 34
78443: PUSH
78444: LD_INT 13
78446: PUSH
78447: EMPTY
78448: LIST
78449: LIST
78450: PUSH
78451: LD_INT 34
78453: PUSH
78454: LD_INT 52
78456: PUSH
78457: EMPTY
78458: LIST
78459: LIST
78460: PUSH
78461: LD_INT 34
78463: PUSH
78464: LD_INT 88
78466: PUSH
78467: EMPTY
78468: LIST
78469: LIST
78470: PUSH
78471: LD_INT 34
78473: PUSH
78474: LD_INT 14
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 34
78483: PUSH
78484: LD_INT 53
78486: PUSH
78487: EMPTY
78488: LIST
78489: LIST
78490: PUSH
78491: LD_INT 34
78493: PUSH
78494: LD_INT 98
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 34
78503: PUSH
78504: LD_INT 31
78506: PUSH
78507: EMPTY
78508: LIST
78509: LIST
78510: PUSH
78511: LD_INT 34
78513: PUSH
78514: LD_INT 48
78516: PUSH
78517: EMPTY
78518: LIST
78519: LIST
78520: PUSH
78521: LD_INT 34
78523: PUSH
78524: LD_INT 8
78526: PUSH
78527: EMPTY
78528: LIST
78529: LIST
78530: PUSH
78531: EMPTY
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: PPUSH
78547: CALL_OW 72
78551: DIFF
78552: ST_TO_ADDR
// end ; end_of_file
78553: LD_VAR 0 3
78557: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78558: LD_INT 0
78560: PPUSH
78561: PPUSH
78562: PPUSH
// if not mc_bases or not skirmish then
78563: LD_EXP 23
78567: NOT
78568: PUSH
78569: LD_EXP 21
78573: NOT
78574: OR
78575: IFFALSE 78579
// exit ;
78577: GO 78744
// for i = 1 to mc_bases do
78579: LD_ADDR_VAR 0 4
78583: PUSH
78584: DOUBLE
78585: LD_INT 1
78587: DEC
78588: ST_TO_ADDR
78589: LD_EXP 23
78593: PUSH
78594: FOR_TO
78595: IFFALSE 78742
// begin if sci in mc_bases [ i ] then
78597: LD_VAR 0 2
78601: PUSH
78602: LD_EXP 23
78606: PUSH
78607: LD_VAR 0 4
78611: ARRAY
78612: IN
78613: IFFALSE 78740
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78615: LD_ADDR_EXP 52
78619: PUSH
78620: LD_EXP 52
78624: PPUSH
78625: LD_VAR 0 4
78629: PUSH
78630: LD_EXP 52
78634: PUSH
78635: LD_VAR 0 4
78639: ARRAY
78640: PUSH
78641: LD_INT 1
78643: PLUS
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PPUSH
78649: LD_VAR 0 1
78653: PPUSH
78654: CALL 16077 0 3
78658: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78659: LD_ADDR_VAR 0 5
78663: PUSH
78664: LD_EXP 23
78668: PUSH
78669: LD_VAR 0 4
78673: ARRAY
78674: PPUSH
78675: LD_INT 2
78677: PUSH
78678: LD_INT 30
78680: PUSH
78681: LD_INT 0
78683: PUSH
78684: EMPTY
78685: LIST
78686: LIST
78687: PUSH
78688: LD_INT 30
78690: PUSH
78691: LD_INT 1
78693: PUSH
78694: EMPTY
78695: LIST
78696: LIST
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: LIST
78702: PPUSH
78703: CALL_OW 72
78707: PPUSH
78708: LD_VAR 0 1
78712: PPUSH
78713: CALL_OW 74
78717: ST_TO_ADDR
// if tmp then
78718: LD_VAR 0 5
78722: IFFALSE 78738
// ComStandNearbyBuilding ( ape , tmp ) ;
78724: LD_VAR 0 1
78728: PPUSH
78729: LD_VAR 0 5
78733: PPUSH
78734: CALL 12679 0 2
// break ;
78738: GO 78742
// end ; end ;
78740: GO 78594
78742: POP
78743: POP
// end ;
78744: LD_VAR 0 3
78748: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78749: LD_INT 0
78751: PPUSH
78752: PPUSH
78753: PPUSH
// if not mc_bases or not skirmish then
78754: LD_EXP 23
78758: NOT
78759: PUSH
78760: LD_EXP 21
78764: NOT
78765: OR
78766: IFFALSE 78770
// exit ;
78768: GO 78859
// for i = 1 to mc_bases do
78770: LD_ADDR_VAR 0 4
78774: PUSH
78775: DOUBLE
78776: LD_INT 1
78778: DEC
78779: ST_TO_ADDR
78780: LD_EXP 23
78784: PUSH
78785: FOR_TO
78786: IFFALSE 78857
// begin if building in mc_busy_turret_list [ i ] then
78788: LD_VAR 0 1
78792: PUSH
78793: LD_EXP 33
78797: PUSH
78798: LD_VAR 0 4
78802: ARRAY
78803: IN
78804: IFFALSE 78855
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78806: LD_ADDR_VAR 0 5
78810: PUSH
78811: LD_EXP 33
78815: PUSH
78816: LD_VAR 0 4
78820: ARRAY
78821: PUSH
78822: LD_VAR 0 1
78826: DIFF
78827: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78828: LD_ADDR_EXP 33
78832: PUSH
78833: LD_EXP 33
78837: PPUSH
78838: LD_VAR 0 4
78842: PPUSH
78843: LD_VAR 0 5
78847: PPUSH
78848: CALL_OW 1
78852: ST_TO_ADDR
// break ;
78853: GO 78857
// end ; end ;
78855: GO 78785
78857: POP
78858: POP
// end ;
78859: LD_VAR 0 3
78863: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78864: LD_INT 0
78866: PPUSH
78867: PPUSH
78868: PPUSH
// if not mc_bases or not skirmish then
78869: LD_EXP 23
78873: NOT
78874: PUSH
78875: LD_EXP 21
78879: NOT
78880: OR
78881: IFFALSE 78885
// exit ;
78883: GO 79084
// for i = 1 to mc_bases do
78885: LD_ADDR_VAR 0 5
78889: PUSH
78890: DOUBLE
78891: LD_INT 1
78893: DEC
78894: ST_TO_ADDR
78895: LD_EXP 23
78899: PUSH
78900: FOR_TO
78901: IFFALSE 79082
// if building in mc_bases [ i ] then
78903: LD_VAR 0 1
78907: PUSH
78908: LD_EXP 23
78912: PUSH
78913: LD_VAR 0 5
78917: ARRAY
78918: IN
78919: IFFALSE 79080
// begin tmp := mc_bases [ i ] diff building ;
78921: LD_ADDR_VAR 0 6
78925: PUSH
78926: LD_EXP 23
78930: PUSH
78931: LD_VAR 0 5
78935: ARRAY
78936: PUSH
78937: LD_VAR 0 1
78941: DIFF
78942: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78943: LD_ADDR_EXP 23
78947: PUSH
78948: LD_EXP 23
78952: PPUSH
78953: LD_VAR 0 5
78957: PPUSH
78958: LD_VAR 0 6
78962: PPUSH
78963: CALL_OW 1
78967: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78968: LD_VAR 0 1
78972: PUSH
78973: LD_EXP 31
78977: PUSH
78978: LD_VAR 0 5
78982: ARRAY
78983: IN
78984: IFFALSE 79023
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78986: LD_ADDR_EXP 31
78990: PUSH
78991: LD_EXP 31
78995: PPUSH
78996: LD_VAR 0 5
79000: PPUSH
79001: LD_EXP 31
79005: PUSH
79006: LD_VAR 0 5
79010: ARRAY
79011: PUSH
79012: LD_VAR 0 1
79016: DIFF
79017: PPUSH
79018: CALL_OW 1
79022: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79023: LD_VAR 0 1
79027: PUSH
79028: LD_EXP 32
79032: PUSH
79033: LD_VAR 0 5
79037: ARRAY
79038: IN
79039: IFFALSE 79078
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79041: LD_ADDR_EXP 32
79045: PUSH
79046: LD_EXP 32
79050: PPUSH
79051: LD_VAR 0 5
79055: PPUSH
79056: LD_EXP 32
79060: PUSH
79061: LD_VAR 0 5
79065: ARRAY
79066: PUSH
79067: LD_VAR 0 1
79071: DIFF
79072: PPUSH
79073: CALL_OW 1
79077: ST_TO_ADDR
// break ;
79078: GO 79082
// end ;
79080: GO 78900
79082: POP
79083: POP
// end ;
79084: LD_VAR 0 4
79088: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79089: LD_INT 0
79091: PPUSH
79092: PPUSH
79093: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
79094: LD_EXP 23
79098: NOT
79099: PUSH
79100: LD_EXP 21
79104: NOT
79105: OR
79106: PUSH
79107: LD_VAR 0 3
79111: PUSH
79112: LD_EXP 49
79116: IN
79117: NOT
79118: OR
79119: IFFALSE 79123
// exit ;
79121: GO 79246
// for i = 1 to mc_vehicles do
79123: LD_ADDR_VAR 0 6
79127: PUSH
79128: DOUBLE
79129: LD_INT 1
79131: DEC
79132: ST_TO_ADDR
79133: LD_EXP 42
79137: PUSH
79138: FOR_TO
79139: IFFALSE 79244
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79141: LD_VAR 0 2
79145: PUSH
79146: LD_EXP 42
79150: PUSH
79151: LD_VAR 0 6
79155: ARRAY
79156: IN
79157: PUSH
79158: LD_VAR 0 1
79162: PUSH
79163: LD_EXP 42
79167: PUSH
79168: LD_VAR 0 6
79172: ARRAY
79173: IN
79174: OR
79175: IFFALSE 79242
// begin tmp := mc_vehicles [ i ] diff old ;
79177: LD_ADDR_VAR 0 7
79181: PUSH
79182: LD_EXP 42
79186: PUSH
79187: LD_VAR 0 6
79191: ARRAY
79192: PUSH
79193: LD_VAR 0 2
79197: DIFF
79198: ST_TO_ADDR
// tmp := tmp diff new ;
79199: LD_ADDR_VAR 0 7
79203: PUSH
79204: LD_VAR 0 7
79208: PUSH
79209: LD_VAR 0 1
79213: DIFF
79214: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79215: LD_ADDR_EXP 42
79219: PUSH
79220: LD_EXP 42
79224: PPUSH
79225: LD_VAR 0 6
79229: PPUSH
79230: LD_VAR 0 7
79234: PPUSH
79235: CALL_OW 1
79239: ST_TO_ADDR
// break ;
79240: GO 79244
// end ;
79242: GO 79138
79244: POP
79245: POP
// end ;
79246: LD_VAR 0 5
79250: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79251: LD_INT 0
79253: PPUSH
79254: PPUSH
79255: PPUSH
79256: PPUSH
// if not mc_bases or not skirmish then
79257: LD_EXP 23
79261: NOT
79262: PUSH
79263: LD_EXP 21
79267: NOT
79268: OR
79269: IFFALSE 79273
// exit ;
79271: GO 79693
// repeat wait ( 0 0$1 ) ;
79273: LD_INT 35
79275: PPUSH
79276: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
79280: LD_EXP 67
79284: NOT
79285: IFFALSE 79273
// mc_block_vehicle_constructed_thread := true ;
79287: LD_ADDR_EXP 67
79291: PUSH
79292: LD_INT 1
79294: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
79295: LD_ADDR_VAR 0 5
79299: PUSH
79300: LD_VAR 0 1
79304: PPUSH
79305: CALL_OW 255
79309: ST_TO_ADDR
// for i = 1 to mc_bases do
79310: LD_ADDR_VAR 0 4
79314: PUSH
79315: DOUBLE
79316: LD_INT 1
79318: DEC
79319: ST_TO_ADDR
79320: LD_EXP 23
79324: PUSH
79325: FOR_TO
79326: IFFALSE 79683
// begin if factory in mc_bases [ i ] then
79328: LD_VAR 0 2
79332: PUSH
79333: LD_EXP 23
79337: PUSH
79338: LD_VAR 0 4
79342: ARRAY
79343: IN
79344: IFFALSE 79681
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
79346: LD_EXP 45
79350: PUSH
79351: LD_VAR 0 4
79355: ARRAY
79356: PUSH
79357: LD_EXP 34
79361: PUSH
79362: LD_VAR 0 4
79366: ARRAY
79367: LESS
79368: PUSH
79369: LD_VAR 0 1
79373: PPUSH
79374: CALL_OW 264
79378: PUSH
79379: LD_INT 31
79381: PUSH
79382: LD_INT 32
79384: PUSH
79385: LD_INT 51
79387: PUSH
79388: LD_INT 89
79390: PUSH
79391: LD_INT 12
79393: PUSH
79394: LD_INT 30
79396: PUSH
79397: LD_INT 98
79399: PUSH
79400: LD_INT 11
79402: PUSH
79403: LD_INT 53
79405: PUSH
79406: LD_INT 14
79408: PUSH
79409: LD_INT 91
79411: PUSH
79412: LD_INT 29
79414: PUSH
79415: LD_INT 99
79417: PUSH
79418: LD_INT 13
79420: PUSH
79421: LD_INT 52
79423: PUSH
79424: LD_INT 88
79426: PUSH
79427: LD_INT 48
79429: PUSH
79430: LD_INT 8
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: LIST
79437: LIST
79438: LIST
79439: LIST
79440: LIST
79441: LIST
79442: LIST
79443: LIST
79444: LIST
79445: LIST
79446: LIST
79447: LIST
79448: LIST
79449: LIST
79450: LIST
79451: LIST
79452: IN
79453: NOT
79454: AND
79455: IFFALSE 79503
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79457: LD_ADDR_EXP 45
79461: PUSH
79462: LD_EXP 45
79466: PPUSH
79467: LD_VAR 0 4
79471: PUSH
79472: LD_EXP 45
79476: PUSH
79477: LD_VAR 0 4
79481: ARRAY
79482: PUSH
79483: LD_INT 1
79485: PLUS
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PPUSH
79491: LD_VAR 0 1
79495: PPUSH
79496: CALL 16077 0 3
79500: ST_TO_ADDR
79501: GO 79547
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79503: LD_ADDR_EXP 42
79507: PUSH
79508: LD_EXP 42
79512: PPUSH
79513: LD_VAR 0 4
79517: PUSH
79518: LD_EXP 42
79522: PUSH
79523: LD_VAR 0 4
79527: ARRAY
79528: PUSH
79529: LD_INT 1
79531: PLUS
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PPUSH
79537: LD_VAR 0 1
79541: PPUSH
79542: CALL 16077 0 3
79546: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
79547: LD_ADDR_EXP 67
79551: PUSH
79552: LD_INT 0
79554: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79555: LD_VAR 0 1
79559: PPUSH
79560: CALL_OW 263
79564: PUSH
79565: LD_INT 2
79567: EQUAL
79568: IFFALSE 79597
// begin repeat wait ( 0 0$3 ) ;
79570: LD_INT 105
79572: PPUSH
79573: CALL_OW 67
// Connect ( vehicle ) ;
79577: LD_VAR 0 1
79581: PPUSH
79582: CALL 19055 0 1
// until IsControledBy ( vehicle ) ;
79586: LD_VAR 0 1
79590: PPUSH
79591: CALL_OW 312
79595: IFFALSE 79570
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79597: LD_VAR 0 1
79601: PPUSH
79602: LD_EXP 47
79606: PUSH
79607: LD_VAR 0 4
79611: ARRAY
79612: PPUSH
79613: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79617: LD_VAR 0 1
79621: PPUSH
79622: CALL_OW 263
79626: PUSH
79627: LD_INT 1
79629: NONEQUAL
79630: IFFALSE 79634
// break ;
79632: GO 79683
// repeat wait ( 0 0$1 ) ;
79634: LD_INT 35
79636: PPUSH
79637: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79641: LD_VAR 0 1
79645: PPUSH
79646: LD_EXP 47
79650: PUSH
79651: LD_VAR 0 4
79655: ARRAY
79656: PPUSH
79657: CALL_OW 308
79661: IFFALSE 79634
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79663: LD_VAR 0 1
79667: PPUSH
79668: CALL_OW 311
79672: PPUSH
79673: CALL_OW 121
// exit ;
79677: POP
79678: POP
79679: GO 79693
// end ; end ;
79681: GO 79325
79683: POP
79684: POP
// mc_block_vehicle_constructed_thread := false ;
79685: LD_ADDR_EXP 67
79689: PUSH
79690: LD_INT 0
79692: ST_TO_ADDR
// end ;
79693: LD_VAR 0 3
79697: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79698: LD_INT 0
79700: PPUSH
79701: PPUSH
79702: PPUSH
79703: PPUSH
// if not mc_bases or not skirmish then
79704: LD_EXP 23
79708: NOT
79709: PUSH
79710: LD_EXP 21
79714: NOT
79715: OR
79716: IFFALSE 79720
// exit ;
79718: GO 80073
// repeat wait ( 0 0$1 ) ;
79720: LD_INT 35
79722: PPUSH
79723: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79727: LD_VAR 0 2
79731: PPUSH
79732: LD_VAR 0 3
79736: PPUSH
79737: CALL_OW 284
79741: IFFALSE 79720
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79743: LD_VAR 0 2
79747: PPUSH
79748: LD_VAR 0 3
79752: PPUSH
79753: CALL_OW 283
79757: PUSH
79758: LD_INT 4
79760: EQUAL
79761: IFFALSE 79765
// exit ;
79763: GO 80073
// for i = 1 to mc_bases do
79765: LD_ADDR_VAR 0 7
79769: PUSH
79770: DOUBLE
79771: LD_INT 1
79773: DEC
79774: ST_TO_ADDR
79775: LD_EXP 23
79779: PUSH
79780: FOR_TO
79781: IFFALSE 80071
// begin if mc_crates_area [ i ] then
79783: LD_EXP 41
79787: PUSH
79788: LD_VAR 0 7
79792: ARRAY
79793: IFFALSE 79904
// for j in mc_crates_area [ i ] do
79795: LD_ADDR_VAR 0 8
79799: PUSH
79800: LD_EXP 41
79804: PUSH
79805: LD_VAR 0 7
79809: ARRAY
79810: PUSH
79811: FOR_IN
79812: IFFALSE 79902
// if InArea ( x , y , j ) then
79814: LD_VAR 0 2
79818: PPUSH
79819: LD_VAR 0 3
79823: PPUSH
79824: LD_VAR 0 8
79828: PPUSH
79829: CALL_OW 309
79833: IFFALSE 79900
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79835: LD_ADDR_EXP 39
79839: PUSH
79840: LD_EXP 39
79844: PPUSH
79845: LD_VAR 0 7
79849: PUSH
79850: LD_EXP 39
79854: PUSH
79855: LD_VAR 0 7
79859: ARRAY
79860: PUSH
79861: LD_INT 1
79863: PLUS
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PPUSH
79869: LD_VAR 0 4
79873: PUSH
79874: LD_VAR 0 2
79878: PUSH
79879: LD_VAR 0 3
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: LIST
79888: PPUSH
79889: CALL 16077 0 3
79893: ST_TO_ADDR
// exit ;
79894: POP
79895: POP
79896: POP
79897: POP
79898: GO 80073
// end ;
79900: GO 79811
79902: POP
79903: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79904: LD_ADDR_VAR 0 9
79908: PUSH
79909: LD_EXP 23
79913: PUSH
79914: LD_VAR 0 7
79918: ARRAY
79919: PPUSH
79920: LD_INT 2
79922: PUSH
79923: LD_INT 30
79925: PUSH
79926: LD_INT 0
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 30
79935: PUSH
79936: LD_INT 1
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: LIST
79947: PPUSH
79948: CALL_OW 72
79952: ST_TO_ADDR
// if not depot then
79953: LD_VAR 0 9
79957: NOT
79958: IFFALSE 79962
// continue ;
79960: GO 79780
// for j in depot do
79962: LD_ADDR_VAR 0 8
79966: PUSH
79967: LD_VAR 0 9
79971: PUSH
79972: FOR_IN
79973: IFFALSE 80067
// if GetDistUnitXY ( j , x , y ) < 30 then
79975: LD_VAR 0 8
79979: PPUSH
79980: LD_VAR 0 2
79984: PPUSH
79985: LD_VAR 0 3
79989: PPUSH
79990: CALL_OW 297
79994: PUSH
79995: LD_INT 30
79997: LESS
79998: IFFALSE 80065
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80000: LD_ADDR_EXP 39
80004: PUSH
80005: LD_EXP 39
80009: PPUSH
80010: LD_VAR 0 7
80014: PUSH
80015: LD_EXP 39
80019: PUSH
80020: LD_VAR 0 7
80024: ARRAY
80025: PUSH
80026: LD_INT 1
80028: PLUS
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: PPUSH
80034: LD_VAR 0 4
80038: PUSH
80039: LD_VAR 0 2
80043: PUSH
80044: LD_VAR 0 3
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: LIST
80053: PPUSH
80054: CALL 16077 0 3
80058: ST_TO_ADDR
// exit ;
80059: POP
80060: POP
80061: POP
80062: POP
80063: GO 80073
// end ;
80065: GO 79972
80067: POP
80068: POP
// end ;
80069: GO 79780
80071: POP
80072: POP
// end ;
80073: LD_VAR 0 6
80077: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80078: LD_INT 0
80080: PPUSH
80081: PPUSH
80082: PPUSH
80083: PPUSH
// if not mc_bases or not skirmish then
80084: LD_EXP 23
80088: NOT
80089: PUSH
80090: LD_EXP 21
80094: NOT
80095: OR
80096: IFFALSE 80100
// exit ;
80098: GO 80377
// side := GetSide ( lab ) ;
80100: LD_ADDR_VAR 0 4
80104: PUSH
80105: LD_VAR 0 2
80109: PPUSH
80110: CALL_OW 255
80114: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80115: LD_VAR 0 4
80119: PUSH
80120: LD_EXP 49
80124: IN
80125: NOT
80126: PUSH
80127: LD_EXP 50
80131: NOT
80132: OR
80133: PUSH
80134: LD_EXP 23
80138: NOT
80139: OR
80140: IFFALSE 80144
// exit ;
80142: GO 80377
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80144: LD_ADDR_EXP 50
80148: PUSH
80149: LD_EXP 50
80153: PPUSH
80154: LD_VAR 0 4
80158: PPUSH
80159: LD_EXP 50
80163: PUSH
80164: LD_VAR 0 4
80168: ARRAY
80169: PUSH
80170: LD_VAR 0 1
80174: DIFF
80175: PPUSH
80176: CALL_OW 1
80180: ST_TO_ADDR
// for i = 1 to mc_bases do
80181: LD_ADDR_VAR 0 5
80185: PUSH
80186: DOUBLE
80187: LD_INT 1
80189: DEC
80190: ST_TO_ADDR
80191: LD_EXP 23
80195: PUSH
80196: FOR_TO
80197: IFFALSE 80375
// begin if lab in mc_bases [ i ] then
80199: LD_VAR 0 2
80203: PUSH
80204: LD_EXP 23
80208: PUSH
80209: LD_VAR 0 5
80213: ARRAY
80214: IN
80215: IFFALSE 80373
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80217: LD_VAR 0 1
80221: PUSH
80222: LD_INT 11
80224: PUSH
80225: LD_INT 4
80227: PUSH
80228: LD_INT 3
80230: PUSH
80231: LD_INT 2
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: LIST
80238: LIST
80239: IN
80240: PUSH
80241: LD_EXP 53
80245: PUSH
80246: LD_VAR 0 5
80250: ARRAY
80251: AND
80252: IFFALSE 80373
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80254: LD_ADDR_VAR 0 6
80258: PUSH
80259: LD_EXP 53
80263: PUSH
80264: LD_VAR 0 5
80268: ARRAY
80269: PUSH
80270: LD_INT 1
80272: ARRAY
80273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80274: LD_ADDR_EXP 53
80278: PUSH
80279: LD_EXP 53
80283: PPUSH
80284: LD_VAR 0 5
80288: PPUSH
80289: EMPTY
80290: PPUSH
80291: CALL_OW 1
80295: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80296: LD_VAR 0 6
80300: PPUSH
80301: LD_INT 0
80303: PPUSH
80304: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80308: LD_VAR 0 6
80312: PPUSH
80313: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80317: LD_ADDR_EXP 52
80321: PUSH
80322: LD_EXP 52
80326: PPUSH
80327: LD_VAR 0 5
80331: PPUSH
80332: LD_EXP 52
80336: PUSH
80337: LD_VAR 0 5
80341: ARRAY
80342: PPUSH
80343: LD_INT 1
80345: PPUSH
80346: LD_VAR 0 6
80350: PPUSH
80351: CALL_OW 2
80355: PPUSH
80356: CALL_OW 1
80360: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80361: LD_VAR 0 5
80365: PPUSH
80366: LD_INT 112
80368: PPUSH
80369: CALL 56827 0 2
// end ; end ; end ;
80373: GO 80196
80375: POP
80376: POP
// end ;
80377: LD_VAR 0 3
80381: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80382: LD_INT 0
80384: PPUSH
80385: PPUSH
80386: PPUSH
80387: PPUSH
80388: PPUSH
80389: PPUSH
80390: PPUSH
80391: PPUSH
// if not mc_bases or not skirmish then
80392: LD_EXP 23
80396: NOT
80397: PUSH
80398: LD_EXP 21
80402: NOT
80403: OR
80404: IFFALSE 80408
// exit ;
80406: GO 81777
// for i = 1 to mc_bases do
80408: LD_ADDR_VAR 0 3
80412: PUSH
80413: DOUBLE
80414: LD_INT 1
80416: DEC
80417: ST_TO_ADDR
80418: LD_EXP 23
80422: PUSH
80423: FOR_TO
80424: IFFALSE 81775
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80426: LD_VAR 0 1
80430: PUSH
80431: LD_EXP 23
80435: PUSH
80436: LD_VAR 0 3
80440: ARRAY
80441: IN
80442: PUSH
80443: LD_VAR 0 1
80447: PUSH
80448: LD_EXP 30
80452: PUSH
80453: LD_VAR 0 3
80457: ARRAY
80458: IN
80459: OR
80460: PUSH
80461: LD_VAR 0 1
80465: PUSH
80466: LD_EXP 45
80470: PUSH
80471: LD_VAR 0 3
80475: ARRAY
80476: IN
80477: OR
80478: PUSH
80479: LD_VAR 0 1
80483: PUSH
80484: LD_EXP 42
80488: PUSH
80489: LD_VAR 0 3
80493: ARRAY
80494: IN
80495: OR
80496: PUSH
80497: LD_VAR 0 1
80501: PUSH
80502: LD_EXP 52
80506: PUSH
80507: LD_VAR 0 3
80511: ARRAY
80512: IN
80513: OR
80514: PUSH
80515: LD_VAR 0 1
80519: PUSH
80520: LD_EXP 53
80524: PUSH
80525: LD_VAR 0 3
80529: ARRAY
80530: IN
80531: OR
80532: IFFALSE 81773
// begin if un in mc_ape [ i ] then
80534: LD_VAR 0 1
80538: PUSH
80539: LD_EXP 52
80543: PUSH
80544: LD_VAR 0 3
80548: ARRAY
80549: IN
80550: IFFALSE 80589
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80552: LD_ADDR_EXP 52
80556: PUSH
80557: LD_EXP 52
80561: PPUSH
80562: LD_VAR 0 3
80566: PPUSH
80567: LD_EXP 52
80571: PUSH
80572: LD_VAR 0 3
80576: ARRAY
80577: PUSH
80578: LD_VAR 0 1
80582: DIFF
80583: PPUSH
80584: CALL_OW 1
80588: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80589: LD_VAR 0 1
80593: PUSH
80594: LD_EXP 53
80598: PUSH
80599: LD_VAR 0 3
80603: ARRAY
80604: IN
80605: IFFALSE 80629
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80607: LD_ADDR_EXP 53
80611: PUSH
80612: LD_EXP 53
80616: PPUSH
80617: LD_VAR 0 3
80621: PPUSH
80622: EMPTY
80623: PPUSH
80624: CALL_OW 1
80628: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80629: LD_VAR 0 1
80633: PPUSH
80634: CALL_OW 247
80638: PUSH
80639: LD_INT 2
80641: EQUAL
80642: PUSH
80643: LD_VAR 0 1
80647: PPUSH
80648: CALL_OW 110
80652: PUSH
80653: LD_INT 20
80655: EQUAL
80656: PUSH
80657: LD_VAR 0 1
80661: PUSH
80662: LD_EXP 45
80666: PUSH
80667: LD_VAR 0 3
80671: ARRAY
80672: IN
80673: OR
80674: PUSH
80675: LD_VAR 0 1
80679: PPUSH
80680: CALL_OW 264
80684: PUSH
80685: LD_INT 12
80687: PUSH
80688: LD_INT 51
80690: PUSH
80691: LD_INT 89
80693: PUSH
80694: LD_INT 32
80696: PUSH
80697: LD_INT 13
80699: PUSH
80700: LD_INT 52
80702: PUSH
80703: LD_INT 31
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: IN
80715: OR
80716: AND
80717: IFFALSE 81025
// begin if un in mc_defender [ i ] then
80719: LD_VAR 0 1
80723: PUSH
80724: LD_EXP 45
80728: PUSH
80729: LD_VAR 0 3
80733: ARRAY
80734: IN
80735: IFFALSE 80774
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80737: LD_ADDR_EXP 45
80741: PUSH
80742: LD_EXP 45
80746: PPUSH
80747: LD_VAR 0 3
80751: PPUSH
80752: LD_EXP 45
80756: PUSH
80757: LD_VAR 0 3
80761: ARRAY
80762: PUSH
80763: LD_VAR 0 1
80767: DIFF
80768: PPUSH
80769: CALL_OW 1
80773: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80774: LD_ADDR_VAR 0 8
80778: PUSH
80779: LD_VAR 0 3
80783: PPUSH
80784: LD_INT 3
80786: PPUSH
80787: CALL 77395 0 2
80791: ST_TO_ADDR
// if fac then
80792: LD_VAR 0 8
80796: IFFALSE 81025
// begin for j in fac do
80798: LD_ADDR_VAR 0 4
80802: PUSH
80803: LD_VAR 0 8
80807: PUSH
80808: FOR_IN
80809: IFFALSE 81023
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80811: LD_ADDR_VAR 0 9
80815: PUSH
80816: LD_VAR 0 8
80820: PPUSH
80821: LD_VAR 0 1
80825: PPUSH
80826: CALL_OW 265
80830: PPUSH
80831: LD_VAR 0 1
80835: PPUSH
80836: CALL_OW 262
80840: PPUSH
80841: LD_VAR 0 1
80845: PPUSH
80846: CALL_OW 263
80850: PPUSH
80851: LD_VAR 0 1
80855: PPUSH
80856: CALL_OW 264
80860: PPUSH
80861: CALL 13575 0 5
80865: ST_TO_ADDR
// if components then
80866: LD_VAR 0 9
80870: IFFALSE 81021
// begin if GetWeapon ( un ) = ar_control_tower then
80872: LD_VAR 0 1
80876: PPUSH
80877: CALL_OW 264
80881: PUSH
80882: LD_INT 31
80884: EQUAL
80885: IFFALSE 81002
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80887: LD_VAR 0 1
80891: PPUSH
80892: CALL_OW 311
80896: PPUSH
80897: LD_INT 0
80899: PPUSH
80900: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80904: LD_ADDR_EXP 63
80908: PUSH
80909: LD_EXP 63
80913: PPUSH
80914: LD_VAR 0 3
80918: PPUSH
80919: LD_EXP 63
80923: PUSH
80924: LD_VAR 0 3
80928: ARRAY
80929: PUSH
80930: LD_VAR 0 1
80934: PPUSH
80935: CALL_OW 311
80939: DIFF
80940: PPUSH
80941: CALL_OW 1
80945: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80946: LD_ADDR_VAR 0 7
80950: PUSH
80951: LD_EXP 44
80955: PUSH
80956: LD_VAR 0 3
80960: ARRAY
80961: PPUSH
80962: LD_INT 1
80964: PPUSH
80965: LD_VAR 0 9
80969: PPUSH
80970: CALL_OW 2
80974: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80975: LD_ADDR_EXP 44
80979: PUSH
80980: LD_EXP 44
80984: PPUSH
80985: LD_VAR 0 3
80989: PPUSH
80990: LD_VAR 0 7
80994: PPUSH
80995: CALL_OW 1
80999: ST_TO_ADDR
// end else
81000: GO 81019
// MC_InsertProduceList ( i , [ components ] ) ;
81002: LD_VAR 0 3
81006: PPUSH
81007: LD_VAR 0 9
81011: PUSH
81012: EMPTY
81013: LIST
81014: PPUSH
81015: CALL 76940 0 2
// break ;
81019: GO 81023
// end ; end ;
81021: GO 80808
81023: POP
81024: POP
// end ; end ; if GetType ( un ) = unit_building then
81025: LD_VAR 0 1
81029: PPUSH
81030: CALL_OW 247
81034: PUSH
81035: LD_INT 3
81037: EQUAL
81038: IFFALSE 81441
// begin btype := GetBType ( un ) ;
81040: LD_ADDR_VAR 0 5
81044: PUSH
81045: LD_VAR 0 1
81049: PPUSH
81050: CALL_OW 266
81054: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
81055: LD_VAR 0 5
81059: PUSH
81060: LD_INT 29
81062: PUSH
81063: LD_INT 30
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: IN
81070: IFFALSE 81143
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
81072: LD_VAR 0 1
81076: PPUSH
81077: CALL_OW 250
81081: PPUSH
81082: LD_VAR 0 1
81086: PPUSH
81087: CALL_OW 251
81091: PPUSH
81092: LD_VAR 0 1
81096: PPUSH
81097: CALL_OW 255
81101: PPUSH
81102: CALL_OW 440
81106: NOT
81107: IFFALSE 81143
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
81109: LD_VAR 0 1
81113: PPUSH
81114: CALL_OW 250
81118: PPUSH
81119: LD_VAR 0 1
81123: PPUSH
81124: CALL_OW 251
81128: PPUSH
81129: LD_VAR 0 1
81133: PPUSH
81134: CALL_OW 255
81138: PPUSH
81139: CALL_OW 441
// end ; if btype = b_warehouse then
81143: LD_VAR 0 5
81147: PUSH
81148: LD_INT 1
81150: EQUAL
81151: IFFALSE 81169
// begin btype := b_depot ;
81153: LD_ADDR_VAR 0 5
81157: PUSH
81158: LD_INT 0
81160: ST_TO_ADDR
// pos := 1 ;
81161: LD_ADDR_VAR 0 6
81165: PUSH
81166: LD_INT 1
81168: ST_TO_ADDR
// end ; if btype = b_factory then
81169: LD_VAR 0 5
81173: PUSH
81174: LD_INT 3
81176: EQUAL
81177: IFFALSE 81195
// begin btype := b_workshop ;
81179: LD_ADDR_VAR 0 5
81183: PUSH
81184: LD_INT 2
81186: ST_TO_ADDR
// pos := 1 ;
81187: LD_ADDR_VAR 0 6
81191: PUSH
81192: LD_INT 1
81194: ST_TO_ADDR
// end ; if btype = b_barracks then
81195: LD_VAR 0 5
81199: PUSH
81200: LD_INT 5
81202: EQUAL
81203: IFFALSE 81213
// btype := b_armoury ;
81205: LD_ADDR_VAR 0 5
81209: PUSH
81210: LD_INT 4
81212: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81213: LD_VAR 0 5
81217: PUSH
81218: LD_INT 7
81220: PUSH
81221: LD_INT 8
81223: PUSH
81224: EMPTY
81225: LIST
81226: LIST
81227: IN
81228: IFFALSE 81238
// btype := b_lab ;
81230: LD_ADDR_VAR 0 5
81234: PUSH
81235: LD_INT 6
81237: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81238: LD_ADDR_EXP 28
81242: PUSH
81243: LD_EXP 28
81247: PPUSH
81248: LD_VAR 0 3
81252: PUSH
81253: LD_EXP 28
81257: PUSH
81258: LD_VAR 0 3
81262: ARRAY
81263: PUSH
81264: LD_INT 1
81266: PLUS
81267: PUSH
81268: EMPTY
81269: LIST
81270: LIST
81271: PPUSH
81272: LD_VAR 0 5
81276: PUSH
81277: LD_VAR 0 1
81281: PPUSH
81282: CALL_OW 250
81286: PUSH
81287: LD_VAR 0 1
81291: PPUSH
81292: CALL_OW 251
81296: PUSH
81297: LD_VAR 0 1
81301: PPUSH
81302: CALL_OW 254
81306: PUSH
81307: EMPTY
81308: LIST
81309: LIST
81310: LIST
81311: LIST
81312: PPUSH
81313: CALL 16077 0 3
81317: ST_TO_ADDR
// if pos = 1 then
81318: LD_VAR 0 6
81322: PUSH
81323: LD_INT 1
81325: EQUAL
81326: IFFALSE 81441
// begin tmp := mc_build_list [ i ] ;
81328: LD_ADDR_VAR 0 7
81332: PUSH
81333: LD_EXP 28
81337: PUSH
81338: LD_VAR 0 3
81342: ARRAY
81343: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81344: LD_VAR 0 7
81348: PPUSH
81349: LD_INT 2
81351: PUSH
81352: LD_INT 30
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 30
81364: PUSH
81365: LD_INT 1
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: LIST
81376: PPUSH
81377: CALL_OW 72
81381: IFFALSE 81391
// pos := 2 ;
81383: LD_ADDR_VAR 0 6
81387: PUSH
81388: LD_INT 2
81390: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81391: LD_ADDR_VAR 0 7
81395: PUSH
81396: LD_VAR 0 7
81400: PPUSH
81401: LD_VAR 0 6
81405: PPUSH
81406: LD_VAR 0 7
81410: PPUSH
81411: CALL 16403 0 3
81415: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81416: LD_ADDR_EXP 28
81420: PUSH
81421: LD_EXP 28
81425: PPUSH
81426: LD_VAR 0 3
81430: PPUSH
81431: LD_VAR 0 7
81435: PPUSH
81436: CALL_OW 1
81440: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81441: LD_VAR 0 1
81445: PUSH
81446: LD_EXP 23
81450: PUSH
81451: LD_VAR 0 3
81455: ARRAY
81456: IN
81457: IFFALSE 81496
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81459: LD_ADDR_EXP 23
81463: PUSH
81464: LD_EXP 23
81468: PPUSH
81469: LD_VAR 0 3
81473: PPUSH
81474: LD_EXP 23
81478: PUSH
81479: LD_VAR 0 3
81483: ARRAY
81484: PUSH
81485: LD_VAR 0 1
81489: DIFF
81490: PPUSH
81491: CALL_OW 1
81495: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81496: LD_VAR 0 1
81500: PUSH
81501: LD_EXP 30
81505: PUSH
81506: LD_VAR 0 3
81510: ARRAY
81511: IN
81512: IFFALSE 81551
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81514: LD_ADDR_EXP 30
81518: PUSH
81519: LD_EXP 30
81523: PPUSH
81524: LD_VAR 0 3
81528: PPUSH
81529: LD_EXP 30
81533: PUSH
81534: LD_VAR 0 3
81538: ARRAY
81539: PUSH
81540: LD_VAR 0 1
81544: DIFF
81545: PPUSH
81546: CALL_OW 1
81550: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81551: LD_VAR 0 1
81555: PUSH
81556: LD_EXP 42
81560: PUSH
81561: LD_VAR 0 3
81565: ARRAY
81566: IN
81567: IFFALSE 81606
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81569: LD_ADDR_EXP 42
81573: PUSH
81574: LD_EXP 42
81578: PPUSH
81579: LD_VAR 0 3
81583: PPUSH
81584: LD_EXP 42
81588: PUSH
81589: LD_VAR 0 3
81593: ARRAY
81594: PUSH
81595: LD_VAR 0 1
81599: DIFF
81600: PPUSH
81601: CALL_OW 1
81605: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81606: LD_VAR 0 1
81610: PUSH
81611: LD_EXP 45
81615: PUSH
81616: LD_VAR 0 3
81620: ARRAY
81621: IN
81622: IFFALSE 81661
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81624: LD_ADDR_EXP 45
81628: PUSH
81629: LD_EXP 45
81633: PPUSH
81634: LD_VAR 0 3
81638: PPUSH
81639: LD_EXP 45
81643: PUSH
81644: LD_VAR 0 3
81648: ARRAY
81649: PUSH
81650: LD_VAR 0 1
81654: DIFF
81655: PPUSH
81656: CALL_OW 1
81660: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81661: LD_VAR 0 1
81665: PUSH
81666: LD_EXP 32
81670: PUSH
81671: LD_VAR 0 3
81675: ARRAY
81676: IN
81677: IFFALSE 81716
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81679: LD_ADDR_EXP 32
81683: PUSH
81684: LD_EXP 32
81688: PPUSH
81689: LD_VAR 0 3
81693: PPUSH
81694: LD_EXP 32
81698: PUSH
81699: LD_VAR 0 3
81703: ARRAY
81704: PUSH
81705: LD_VAR 0 1
81709: DIFF
81710: PPUSH
81711: CALL_OW 1
81715: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81716: LD_VAR 0 1
81720: PUSH
81721: LD_EXP 31
81725: PUSH
81726: LD_VAR 0 3
81730: ARRAY
81731: IN
81732: IFFALSE 81771
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81734: LD_ADDR_EXP 31
81738: PUSH
81739: LD_EXP 31
81743: PPUSH
81744: LD_VAR 0 3
81748: PPUSH
81749: LD_EXP 31
81753: PUSH
81754: LD_VAR 0 3
81758: ARRAY
81759: PUSH
81760: LD_VAR 0 1
81764: DIFF
81765: PPUSH
81766: CALL_OW 1
81770: ST_TO_ADDR
// end ; break ;
81771: GO 81775
// end ;
81773: GO 80423
81775: POP
81776: POP
// end ;
81777: LD_VAR 0 2
81781: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81782: LD_INT 0
81784: PPUSH
81785: PPUSH
81786: PPUSH
// if not mc_bases or not skirmish then
81787: LD_EXP 23
81791: NOT
81792: PUSH
81793: LD_EXP 21
81797: NOT
81798: OR
81799: IFFALSE 81803
// exit ;
81801: GO 82018
// for i = 1 to mc_bases do
81803: LD_ADDR_VAR 0 3
81807: PUSH
81808: DOUBLE
81809: LD_INT 1
81811: DEC
81812: ST_TO_ADDR
81813: LD_EXP 23
81817: PUSH
81818: FOR_TO
81819: IFFALSE 82016
// begin if building in mc_construct_list [ i ] then
81821: LD_VAR 0 1
81825: PUSH
81826: LD_EXP 30
81830: PUSH
81831: LD_VAR 0 3
81835: ARRAY
81836: IN
81837: IFFALSE 82014
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81839: LD_ADDR_EXP 30
81843: PUSH
81844: LD_EXP 30
81848: PPUSH
81849: LD_VAR 0 3
81853: PPUSH
81854: LD_EXP 30
81858: PUSH
81859: LD_VAR 0 3
81863: ARRAY
81864: PUSH
81865: LD_VAR 0 1
81869: DIFF
81870: PPUSH
81871: CALL_OW 1
81875: ST_TO_ADDR
// if building in mc_lab [ i ] then
81876: LD_VAR 0 1
81880: PUSH
81881: LD_EXP 56
81885: PUSH
81886: LD_VAR 0 3
81890: ARRAY
81891: IN
81892: IFFALSE 81947
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81894: LD_ADDR_EXP 57
81898: PUSH
81899: LD_EXP 57
81903: PPUSH
81904: LD_VAR 0 3
81908: PPUSH
81909: LD_EXP 57
81913: PUSH
81914: LD_VAR 0 3
81918: ARRAY
81919: PPUSH
81920: LD_INT 1
81922: PPUSH
81923: LD_EXP 57
81927: PUSH
81928: LD_VAR 0 3
81932: ARRAY
81933: PPUSH
81934: LD_INT 0
81936: PPUSH
81937: CALL 15495 0 4
81941: PPUSH
81942: CALL_OW 1
81946: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81947: LD_VAR 0 1
81951: PUSH
81952: LD_EXP 23
81956: PUSH
81957: LD_VAR 0 3
81961: ARRAY
81962: IN
81963: NOT
81964: IFFALSE 82010
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81966: LD_ADDR_EXP 23
81970: PUSH
81971: LD_EXP 23
81975: PPUSH
81976: LD_VAR 0 3
81980: PUSH
81981: LD_EXP 23
81985: PUSH
81986: LD_VAR 0 3
81990: ARRAY
81991: PUSH
81992: LD_INT 1
81994: PLUS
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: PPUSH
82000: LD_VAR 0 1
82004: PPUSH
82005: CALL 16077 0 3
82009: ST_TO_ADDR
// exit ;
82010: POP
82011: POP
82012: GO 82018
// end ; end ;
82014: GO 81818
82016: POP
82017: POP
// end ;
82018: LD_VAR 0 2
82022: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82023: LD_INT 0
82025: PPUSH
82026: PPUSH
82027: PPUSH
82028: PPUSH
82029: PPUSH
82030: PPUSH
82031: PPUSH
// if not mc_bases or not skirmish then
82032: LD_EXP 23
82036: NOT
82037: PUSH
82038: LD_EXP 21
82042: NOT
82043: OR
82044: IFFALSE 82048
// exit ;
82046: GO 82709
// for i = 1 to mc_bases do
82048: LD_ADDR_VAR 0 3
82052: PUSH
82053: DOUBLE
82054: LD_INT 1
82056: DEC
82057: ST_TO_ADDR
82058: LD_EXP 23
82062: PUSH
82063: FOR_TO
82064: IFFALSE 82707
// begin if building in mc_construct_list [ i ] then
82066: LD_VAR 0 1
82070: PUSH
82071: LD_EXP 30
82075: PUSH
82076: LD_VAR 0 3
82080: ARRAY
82081: IN
82082: IFFALSE 82705
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82084: LD_ADDR_EXP 30
82088: PUSH
82089: LD_EXP 30
82093: PPUSH
82094: LD_VAR 0 3
82098: PPUSH
82099: LD_EXP 30
82103: PUSH
82104: LD_VAR 0 3
82108: ARRAY
82109: PUSH
82110: LD_VAR 0 1
82114: DIFF
82115: PPUSH
82116: CALL_OW 1
82120: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82121: LD_ADDR_EXP 23
82125: PUSH
82126: LD_EXP 23
82130: PPUSH
82131: LD_VAR 0 3
82135: PUSH
82136: LD_EXP 23
82140: PUSH
82141: LD_VAR 0 3
82145: ARRAY
82146: PUSH
82147: LD_INT 1
82149: PLUS
82150: PUSH
82151: EMPTY
82152: LIST
82153: LIST
82154: PPUSH
82155: LD_VAR 0 1
82159: PPUSH
82160: CALL 16077 0 3
82164: ST_TO_ADDR
// btype := GetBType ( building ) ;
82165: LD_ADDR_VAR 0 5
82169: PUSH
82170: LD_VAR 0 1
82174: PPUSH
82175: CALL_OW 266
82179: ST_TO_ADDR
// side := GetSide ( building ) ;
82180: LD_ADDR_VAR 0 8
82184: PUSH
82185: LD_VAR 0 1
82189: PPUSH
82190: CALL_OW 255
82194: ST_TO_ADDR
// if btype = b_lab then
82195: LD_VAR 0 5
82199: PUSH
82200: LD_INT 6
82202: EQUAL
82203: IFFALSE 82253
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82205: LD_ADDR_EXP 56
82209: PUSH
82210: LD_EXP 56
82214: PPUSH
82215: LD_VAR 0 3
82219: PUSH
82220: LD_EXP 56
82224: PUSH
82225: LD_VAR 0 3
82229: ARRAY
82230: PUSH
82231: LD_INT 1
82233: PLUS
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PPUSH
82239: LD_VAR 0 1
82243: PPUSH
82244: CALL 16077 0 3
82248: ST_TO_ADDR
// exit ;
82249: POP
82250: POP
82251: GO 82709
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82253: LD_VAR 0 5
82257: PUSH
82258: LD_INT 0
82260: PUSH
82261: LD_INT 2
82263: PUSH
82264: LD_INT 4
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: LIST
82271: IN
82272: IFFALSE 82396
// begin if btype = b_armoury then
82274: LD_VAR 0 5
82278: PUSH
82279: LD_INT 4
82281: EQUAL
82282: IFFALSE 82292
// btype := b_barracks ;
82284: LD_ADDR_VAR 0 5
82288: PUSH
82289: LD_INT 5
82291: ST_TO_ADDR
// if btype = b_depot then
82292: LD_VAR 0 5
82296: PUSH
82297: LD_INT 0
82299: EQUAL
82300: IFFALSE 82310
// btype := b_warehouse ;
82302: LD_ADDR_VAR 0 5
82306: PUSH
82307: LD_INT 1
82309: ST_TO_ADDR
// if btype = b_workshop then
82310: LD_VAR 0 5
82314: PUSH
82315: LD_INT 2
82317: EQUAL
82318: IFFALSE 82328
// btype := b_factory ;
82320: LD_ADDR_VAR 0 5
82324: PUSH
82325: LD_INT 3
82327: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82328: LD_VAR 0 5
82332: PPUSH
82333: LD_VAR 0 8
82337: PPUSH
82338: CALL_OW 323
82342: PUSH
82343: LD_INT 1
82345: EQUAL
82346: IFFALSE 82392
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82348: LD_ADDR_EXP 55
82352: PUSH
82353: LD_EXP 55
82357: PPUSH
82358: LD_VAR 0 3
82362: PUSH
82363: LD_EXP 55
82367: PUSH
82368: LD_VAR 0 3
82372: ARRAY
82373: PUSH
82374: LD_INT 1
82376: PLUS
82377: PUSH
82378: EMPTY
82379: LIST
82380: LIST
82381: PPUSH
82382: LD_VAR 0 1
82386: PPUSH
82387: CALL 16077 0 3
82391: ST_TO_ADDR
// exit ;
82392: POP
82393: POP
82394: GO 82709
// end ; if btype in [ b_bunker , b_turret ] then
82396: LD_VAR 0 5
82400: PUSH
82401: LD_INT 32
82403: PUSH
82404: LD_INT 33
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: IN
82411: IFFALSE 82701
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82413: LD_ADDR_EXP 31
82417: PUSH
82418: LD_EXP 31
82422: PPUSH
82423: LD_VAR 0 3
82427: PUSH
82428: LD_EXP 31
82432: PUSH
82433: LD_VAR 0 3
82437: ARRAY
82438: PUSH
82439: LD_INT 1
82441: PLUS
82442: PUSH
82443: EMPTY
82444: LIST
82445: LIST
82446: PPUSH
82447: LD_VAR 0 1
82451: PPUSH
82452: CALL 16077 0 3
82456: ST_TO_ADDR
// if btype = b_bunker then
82457: LD_VAR 0 5
82461: PUSH
82462: LD_INT 32
82464: EQUAL
82465: IFFALSE 82701
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82467: LD_ADDR_EXP 32
82471: PUSH
82472: LD_EXP 32
82476: PPUSH
82477: LD_VAR 0 3
82481: PUSH
82482: LD_EXP 32
82486: PUSH
82487: LD_VAR 0 3
82491: ARRAY
82492: PUSH
82493: LD_INT 1
82495: PLUS
82496: PUSH
82497: EMPTY
82498: LIST
82499: LIST
82500: PPUSH
82501: LD_VAR 0 1
82505: PPUSH
82506: CALL 16077 0 3
82510: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82511: LD_ADDR_VAR 0 6
82515: PUSH
82516: LD_EXP 23
82520: PUSH
82521: LD_VAR 0 3
82525: ARRAY
82526: PPUSH
82527: LD_INT 25
82529: PUSH
82530: LD_INT 1
82532: PUSH
82533: EMPTY
82534: LIST
82535: LIST
82536: PUSH
82537: LD_INT 3
82539: PUSH
82540: LD_INT 54
82542: PUSH
82543: EMPTY
82544: LIST
82545: PUSH
82546: EMPTY
82547: LIST
82548: LIST
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PPUSH
82554: CALL_OW 72
82558: ST_TO_ADDR
// if tmp then
82559: LD_VAR 0 6
82563: IFFALSE 82569
// exit ;
82565: POP
82566: POP
82567: GO 82709
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82569: LD_ADDR_VAR 0 6
82573: PUSH
82574: LD_EXP 23
82578: PUSH
82579: LD_VAR 0 3
82583: ARRAY
82584: PPUSH
82585: LD_INT 2
82587: PUSH
82588: LD_INT 30
82590: PUSH
82591: LD_INT 4
82593: PUSH
82594: EMPTY
82595: LIST
82596: LIST
82597: PUSH
82598: LD_INT 30
82600: PUSH
82601: LD_INT 5
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PUSH
82608: EMPTY
82609: LIST
82610: LIST
82611: LIST
82612: PPUSH
82613: CALL_OW 72
82617: ST_TO_ADDR
// if not tmp then
82618: LD_VAR 0 6
82622: NOT
82623: IFFALSE 82629
// exit ;
82625: POP
82626: POP
82627: GO 82709
// for j in tmp do
82629: LD_ADDR_VAR 0 4
82633: PUSH
82634: LD_VAR 0 6
82638: PUSH
82639: FOR_IN
82640: IFFALSE 82699
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82642: LD_ADDR_VAR 0 7
82646: PUSH
82647: LD_VAR 0 4
82651: PPUSH
82652: CALL_OW 313
82656: PPUSH
82657: LD_INT 25
82659: PUSH
82660: LD_INT 1
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: PPUSH
82667: CALL_OW 72
82671: ST_TO_ADDR
// if units then
82672: LD_VAR 0 7
82676: IFFALSE 82697
// begin ComExitBuilding ( units [ 1 ] ) ;
82678: LD_VAR 0 7
82682: PUSH
82683: LD_INT 1
82685: ARRAY
82686: PPUSH
82687: CALL_OW 122
// exit ;
82691: POP
82692: POP
82693: POP
82694: POP
82695: GO 82709
// end ; end ;
82697: GO 82639
82699: POP
82700: POP
// end ; end ; exit ;
82701: POP
82702: POP
82703: GO 82709
// end ; end ;
82705: GO 82063
82707: POP
82708: POP
// end ;
82709: LD_VAR 0 2
82713: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82714: LD_INT 0
82716: PPUSH
82717: PPUSH
82718: PPUSH
82719: PPUSH
82720: PPUSH
82721: PPUSH
82722: PPUSH
// if not mc_bases or not skirmish then
82723: LD_EXP 23
82727: NOT
82728: PUSH
82729: LD_EXP 21
82733: NOT
82734: OR
82735: IFFALSE 82739
// exit ;
82737: GO 83004
// btype := GetBType ( building ) ;
82739: LD_ADDR_VAR 0 6
82743: PUSH
82744: LD_VAR 0 1
82748: PPUSH
82749: CALL_OW 266
82753: ST_TO_ADDR
// x := GetX ( building ) ;
82754: LD_ADDR_VAR 0 7
82758: PUSH
82759: LD_VAR 0 1
82763: PPUSH
82764: CALL_OW 250
82768: ST_TO_ADDR
// y := GetY ( building ) ;
82769: LD_ADDR_VAR 0 8
82773: PUSH
82774: LD_VAR 0 1
82778: PPUSH
82779: CALL_OW 251
82783: ST_TO_ADDR
// d := GetDir ( building ) ;
82784: LD_ADDR_VAR 0 9
82788: PUSH
82789: LD_VAR 0 1
82793: PPUSH
82794: CALL_OW 254
82798: ST_TO_ADDR
// for i = 1 to mc_bases do
82799: LD_ADDR_VAR 0 4
82803: PUSH
82804: DOUBLE
82805: LD_INT 1
82807: DEC
82808: ST_TO_ADDR
82809: LD_EXP 23
82813: PUSH
82814: FOR_TO
82815: IFFALSE 83002
// begin if not mc_build_list [ i ] then
82817: LD_EXP 28
82821: PUSH
82822: LD_VAR 0 4
82826: ARRAY
82827: NOT
82828: IFFALSE 82832
// continue ;
82830: GO 82814
// for j := 1 to mc_build_list [ i ] do
82832: LD_ADDR_VAR 0 5
82836: PUSH
82837: DOUBLE
82838: LD_INT 1
82840: DEC
82841: ST_TO_ADDR
82842: LD_EXP 28
82846: PUSH
82847: LD_VAR 0 4
82851: ARRAY
82852: PUSH
82853: FOR_TO
82854: IFFALSE 82998
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82856: LD_VAR 0 6
82860: PUSH
82861: LD_VAR 0 7
82865: PUSH
82866: LD_VAR 0 8
82870: PUSH
82871: LD_VAR 0 9
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: PPUSH
82882: LD_EXP 28
82886: PUSH
82887: LD_VAR 0 4
82891: ARRAY
82892: PUSH
82893: LD_VAR 0 5
82897: ARRAY
82898: PPUSH
82899: CALL 22266 0 2
82903: IFFALSE 82996
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82905: LD_ADDR_EXP 28
82909: PUSH
82910: LD_EXP 28
82914: PPUSH
82915: LD_VAR 0 4
82919: PPUSH
82920: LD_EXP 28
82924: PUSH
82925: LD_VAR 0 4
82929: ARRAY
82930: PPUSH
82931: LD_VAR 0 5
82935: PPUSH
82936: CALL_OW 3
82940: PPUSH
82941: CALL_OW 1
82945: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82946: LD_ADDR_EXP 30
82950: PUSH
82951: LD_EXP 30
82955: PPUSH
82956: LD_VAR 0 4
82960: PUSH
82961: LD_EXP 30
82965: PUSH
82966: LD_VAR 0 4
82970: ARRAY
82971: PUSH
82972: LD_INT 1
82974: PLUS
82975: PUSH
82976: EMPTY
82977: LIST
82978: LIST
82979: PPUSH
82980: LD_VAR 0 1
82984: PPUSH
82985: CALL 16077 0 3
82989: ST_TO_ADDR
// exit ;
82990: POP
82991: POP
82992: POP
82993: POP
82994: GO 83004
// end ;
82996: GO 82853
82998: POP
82999: POP
// end ;
83000: GO 82814
83002: POP
83003: POP
// end ;
83004: LD_VAR 0 3
83008: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83009: LD_INT 0
83011: PPUSH
83012: PPUSH
83013: PPUSH
// if not mc_bases or not skirmish then
83014: LD_EXP 23
83018: NOT
83019: PUSH
83020: LD_EXP 21
83024: NOT
83025: OR
83026: IFFALSE 83030
// exit ;
83028: GO 83220
// for i = 1 to mc_bases do
83030: LD_ADDR_VAR 0 4
83034: PUSH
83035: DOUBLE
83036: LD_INT 1
83038: DEC
83039: ST_TO_ADDR
83040: LD_EXP 23
83044: PUSH
83045: FOR_TO
83046: IFFALSE 83133
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83048: LD_VAR 0 1
83052: PUSH
83053: LD_EXP 31
83057: PUSH
83058: LD_VAR 0 4
83062: ARRAY
83063: IN
83064: PUSH
83065: LD_VAR 0 1
83069: PUSH
83070: LD_EXP 32
83074: PUSH
83075: LD_VAR 0 4
83079: ARRAY
83080: IN
83081: NOT
83082: AND
83083: IFFALSE 83131
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83085: LD_ADDR_EXP 32
83089: PUSH
83090: LD_EXP 32
83094: PPUSH
83095: LD_VAR 0 4
83099: PUSH
83100: LD_EXP 32
83104: PUSH
83105: LD_VAR 0 4
83109: ARRAY
83110: PUSH
83111: LD_INT 1
83113: PLUS
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PPUSH
83119: LD_VAR 0 1
83123: PPUSH
83124: CALL 16077 0 3
83128: ST_TO_ADDR
// break ;
83129: GO 83133
// end ; end ;
83131: GO 83045
83133: POP
83134: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83135: LD_VAR 0 1
83139: PPUSH
83140: CALL_OW 257
83144: PUSH
83145: LD_EXP 49
83149: IN
83150: PUSH
83151: LD_VAR 0 1
83155: PPUSH
83156: CALL_OW 266
83160: PUSH
83161: LD_INT 5
83163: EQUAL
83164: AND
83165: PUSH
83166: LD_VAR 0 2
83170: PPUSH
83171: CALL_OW 110
83175: PUSH
83176: LD_INT 18
83178: NONEQUAL
83179: AND
83180: IFFALSE 83220
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83182: LD_VAR 0 2
83186: PPUSH
83187: CALL_OW 257
83191: PUSH
83192: LD_INT 5
83194: PUSH
83195: LD_INT 8
83197: PUSH
83198: LD_INT 9
83200: PUSH
83201: EMPTY
83202: LIST
83203: LIST
83204: LIST
83205: IN
83206: IFFALSE 83220
// SetClass ( unit , 1 ) ;
83208: LD_VAR 0 2
83212: PPUSH
83213: LD_INT 1
83215: PPUSH
83216: CALL_OW 336
// end ;
83220: LD_VAR 0 3
83224: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83225: LD_INT 0
83227: PPUSH
83228: PPUSH
// if not mc_bases or not skirmish then
83229: LD_EXP 23
83233: NOT
83234: PUSH
83235: LD_EXP 21
83239: NOT
83240: OR
83241: IFFALSE 83245
// exit ;
83243: GO 83361
// if GetLives ( abandoned_vehicle ) > 250 then
83245: LD_VAR 0 2
83249: PPUSH
83250: CALL_OW 256
83254: PUSH
83255: LD_INT 250
83257: GREATER
83258: IFFALSE 83262
// exit ;
83260: GO 83361
// for i = 1 to mc_bases do
83262: LD_ADDR_VAR 0 6
83266: PUSH
83267: DOUBLE
83268: LD_INT 1
83270: DEC
83271: ST_TO_ADDR
83272: LD_EXP 23
83276: PUSH
83277: FOR_TO
83278: IFFALSE 83359
// begin if driver in mc_bases [ i ] then
83280: LD_VAR 0 1
83284: PUSH
83285: LD_EXP 23
83289: PUSH
83290: LD_VAR 0 6
83294: ARRAY
83295: IN
83296: IFFALSE 83357
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83298: LD_VAR 0 1
83302: PPUSH
83303: LD_EXP 23
83307: PUSH
83308: LD_VAR 0 6
83312: ARRAY
83313: PPUSH
83314: LD_INT 2
83316: PUSH
83317: LD_INT 30
83319: PUSH
83320: LD_INT 0
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 30
83329: PUSH
83330: LD_INT 1
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: LIST
83341: PPUSH
83342: CALL_OW 72
83346: PUSH
83347: LD_INT 1
83349: ARRAY
83350: PPUSH
83351: CALL 49313 0 2
// break ;
83355: GO 83359
// end ; end ;
83357: GO 83277
83359: POP
83360: POP
// end ; end_of_file
83361: LD_VAR 0 5
83365: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83366: LD_INT 0
83368: PPUSH
83369: PPUSH
83370: PPUSH
83371: PPUSH
83372: PPUSH
83373: PPUSH
83374: PPUSH
83375: PPUSH
83376: PPUSH
83377: PPUSH
83378: PPUSH
83379: PPUSH
83380: PPUSH
83381: PPUSH
83382: PPUSH
83383: PPUSH
83384: PPUSH
83385: PPUSH
83386: PPUSH
83387: PPUSH
83388: PPUSH
83389: PPUSH
83390: PPUSH
83391: PPUSH
83392: PPUSH
83393: PPUSH
83394: PPUSH
83395: PPUSH
83396: PPUSH
83397: PPUSH
83398: PPUSH
83399: PPUSH
83400: PPUSH
83401: PPUSH
// if not list then
83402: LD_VAR 0 1
83406: NOT
83407: IFFALSE 83411
// exit ;
83409: GO 88070
// base := list [ 1 ] ;
83411: LD_ADDR_VAR 0 3
83415: PUSH
83416: LD_VAR 0 1
83420: PUSH
83421: LD_INT 1
83423: ARRAY
83424: ST_TO_ADDR
// group := list [ 2 ] ;
83425: LD_ADDR_VAR 0 4
83429: PUSH
83430: LD_VAR 0 1
83434: PUSH
83435: LD_INT 2
83437: ARRAY
83438: ST_TO_ADDR
// path := list [ 3 ] ;
83439: LD_ADDR_VAR 0 5
83443: PUSH
83444: LD_VAR 0 1
83448: PUSH
83449: LD_INT 3
83451: ARRAY
83452: ST_TO_ADDR
// flags := list [ 4 ] ;
83453: LD_ADDR_VAR 0 6
83457: PUSH
83458: LD_VAR 0 1
83462: PUSH
83463: LD_INT 4
83465: ARRAY
83466: ST_TO_ADDR
// mined := [ ] ;
83467: LD_ADDR_VAR 0 27
83471: PUSH
83472: EMPTY
83473: ST_TO_ADDR
// bombed := [ ] ;
83474: LD_ADDR_VAR 0 28
83478: PUSH
83479: EMPTY
83480: ST_TO_ADDR
// healers := [ ] ;
83481: LD_ADDR_VAR 0 31
83485: PUSH
83486: EMPTY
83487: ST_TO_ADDR
// to_heal := [ ] ;
83488: LD_ADDR_VAR 0 30
83492: PUSH
83493: EMPTY
83494: ST_TO_ADDR
// repairs := [ ] ;
83495: LD_ADDR_VAR 0 33
83499: PUSH
83500: EMPTY
83501: ST_TO_ADDR
// to_repair := [ ] ;
83502: LD_ADDR_VAR 0 32
83506: PUSH
83507: EMPTY
83508: ST_TO_ADDR
// if not group or not path then
83509: LD_VAR 0 4
83513: NOT
83514: PUSH
83515: LD_VAR 0 5
83519: NOT
83520: OR
83521: IFFALSE 83525
// exit ;
83523: GO 88070
// side := GetSide ( group [ 1 ] ) ;
83525: LD_ADDR_VAR 0 35
83529: PUSH
83530: LD_VAR 0 4
83534: PUSH
83535: LD_INT 1
83537: ARRAY
83538: PPUSH
83539: CALL_OW 255
83543: ST_TO_ADDR
// if flags then
83544: LD_VAR 0 6
83548: IFFALSE 83692
// begin f_ignore_area := flags [ 1 ] ;
83550: LD_ADDR_VAR 0 17
83554: PUSH
83555: LD_VAR 0 6
83559: PUSH
83560: LD_INT 1
83562: ARRAY
83563: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83564: LD_ADDR_VAR 0 18
83568: PUSH
83569: LD_VAR 0 6
83573: PUSH
83574: LD_INT 2
83576: ARRAY
83577: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83578: LD_ADDR_VAR 0 19
83582: PUSH
83583: LD_VAR 0 6
83587: PUSH
83588: LD_INT 3
83590: ARRAY
83591: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83592: LD_ADDR_VAR 0 20
83596: PUSH
83597: LD_VAR 0 6
83601: PUSH
83602: LD_INT 4
83604: ARRAY
83605: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83606: LD_ADDR_VAR 0 21
83610: PUSH
83611: LD_VAR 0 6
83615: PUSH
83616: LD_INT 5
83618: ARRAY
83619: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83620: LD_ADDR_VAR 0 22
83624: PUSH
83625: LD_VAR 0 6
83629: PUSH
83630: LD_INT 6
83632: ARRAY
83633: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83634: LD_ADDR_VAR 0 23
83638: PUSH
83639: LD_VAR 0 6
83643: PUSH
83644: LD_INT 7
83646: ARRAY
83647: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83648: LD_ADDR_VAR 0 24
83652: PUSH
83653: LD_VAR 0 6
83657: PUSH
83658: LD_INT 8
83660: ARRAY
83661: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83662: LD_ADDR_VAR 0 25
83666: PUSH
83667: LD_VAR 0 6
83671: PUSH
83672: LD_INT 9
83674: ARRAY
83675: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83676: LD_ADDR_VAR 0 26
83680: PUSH
83681: LD_VAR 0 6
83685: PUSH
83686: LD_INT 10
83688: ARRAY
83689: ST_TO_ADDR
// end else
83690: GO 83772
// begin f_ignore_area := false ;
83692: LD_ADDR_VAR 0 17
83696: PUSH
83697: LD_INT 0
83699: ST_TO_ADDR
// f_capture := false ;
83700: LD_ADDR_VAR 0 18
83704: PUSH
83705: LD_INT 0
83707: ST_TO_ADDR
// f_ignore_civ := false ;
83708: LD_ADDR_VAR 0 19
83712: PUSH
83713: LD_INT 0
83715: ST_TO_ADDR
// f_murder := false ;
83716: LD_ADDR_VAR 0 20
83720: PUSH
83721: LD_INT 0
83723: ST_TO_ADDR
// f_mines := false ;
83724: LD_ADDR_VAR 0 21
83728: PUSH
83729: LD_INT 0
83731: ST_TO_ADDR
// f_repair := false ;
83732: LD_ADDR_VAR 0 22
83736: PUSH
83737: LD_INT 0
83739: ST_TO_ADDR
// f_heal := false ;
83740: LD_ADDR_VAR 0 23
83744: PUSH
83745: LD_INT 0
83747: ST_TO_ADDR
// f_spacetime := false ;
83748: LD_ADDR_VAR 0 24
83752: PUSH
83753: LD_INT 0
83755: ST_TO_ADDR
// f_attack_depot := false ;
83756: LD_ADDR_VAR 0 25
83760: PUSH
83761: LD_INT 0
83763: ST_TO_ADDR
// f_crawl := false ;
83764: LD_ADDR_VAR 0 26
83768: PUSH
83769: LD_INT 0
83771: ST_TO_ADDR
// end ; if f_heal then
83772: LD_VAR 0 23
83776: IFFALSE 83803
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83778: LD_ADDR_VAR 0 31
83782: PUSH
83783: LD_VAR 0 4
83787: PPUSH
83788: LD_INT 25
83790: PUSH
83791: LD_INT 4
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: PPUSH
83798: CALL_OW 72
83802: ST_TO_ADDR
// if f_repair then
83803: LD_VAR 0 22
83807: IFFALSE 83834
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83809: LD_ADDR_VAR 0 33
83813: PUSH
83814: LD_VAR 0 4
83818: PPUSH
83819: LD_INT 25
83821: PUSH
83822: LD_INT 3
83824: PUSH
83825: EMPTY
83826: LIST
83827: LIST
83828: PPUSH
83829: CALL_OW 72
83833: ST_TO_ADDR
// units_path := [ ] ;
83834: LD_ADDR_VAR 0 16
83838: PUSH
83839: EMPTY
83840: ST_TO_ADDR
// for i = 1 to group do
83841: LD_ADDR_VAR 0 7
83845: PUSH
83846: DOUBLE
83847: LD_INT 1
83849: DEC
83850: ST_TO_ADDR
83851: LD_VAR 0 4
83855: PUSH
83856: FOR_TO
83857: IFFALSE 83886
// units_path := Replace ( units_path , i , path ) ;
83859: LD_ADDR_VAR 0 16
83863: PUSH
83864: LD_VAR 0 16
83868: PPUSH
83869: LD_VAR 0 7
83873: PPUSH
83874: LD_VAR 0 5
83878: PPUSH
83879: CALL_OW 1
83883: ST_TO_ADDR
83884: GO 83856
83886: POP
83887: POP
// repeat for i = group downto 1 do
83888: LD_ADDR_VAR 0 7
83892: PUSH
83893: DOUBLE
83894: LD_VAR 0 4
83898: INC
83899: ST_TO_ADDR
83900: LD_INT 1
83902: PUSH
83903: FOR_DOWNTO
83904: IFFALSE 88026
// begin wait ( 5 ) ;
83906: LD_INT 5
83908: PPUSH
83909: CALL_OW 67
// tmp := [ ] ;
83913: LD_ADDR_VAR 0 14
83917: PUSH
83918: EMPTY
83919: ST_TO_ADDR
// attacking := false ;
83920: LD_ADDR_VAR 0 29
83924: PUSH
83925: LD_INT 0
83927: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83928: LD_VAR 0 4
83932: PUSH
83933: LD_VAR 0 7
83937: ARRAY
83938: PPUSH
83939: CALL_OW 301
83943: PUSH
83944: LD_VAR 0 4
83948: PUSH
83949: LD_VAR 0 7
83953: ARRAY
83954: NOT
83955: OR
83956: IFFALSE 84065
// begin if GetType ( group [ i ] ) = unit_human then
83958: LD_VAR 0 4
83962: PUSH
83963: LD_VAR 0 7
83967: ARRAY
83968: PPUSH
83969: CALL_OW 247
83973: PUSH
83974: LD_INT 1
83976: EQUAL
83977: IFFALSE 84023
// begin to_heal := to_heal diff group [ i ] ;
83979: LD_ADDR_VAR 0 30
83983: PUSH
83984: LD_VAR 0 30
83988: PUSH
83989: LD_VAR 0 4
83993: PUSH
83994: LD_VAR 0 7
83998: ARRAY
83999: DIFF
84000: ST_TO_ADDR
// healers := healers diff group [ i ] ;
84001: LD_ADDR_VAR 0 31
84005: PUSH
84006: LD_VAR 0 31
84010: PUSH
84011: LD_VAR 0 4
84015: PUSH
84016: LD_VAR 0 7
84020: ARRAY
84021: DIFF
84022: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
84023: LD_ADDR_VAR 0 4
84027: PUSH
84028: LD_VAR 0 4
84032: PPUSH
84033: LD_VAR 0 7
84037: PPUSH
84038: CALL_OW 3
84042: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
84043: LD_ADDR_VAR 0 16
84047: PUSH
84048: LD_VAR 0 16
84052: PPUSH
84053: LD_VAR 0 7
84057: PPUSH
84058: CALL_OW 3
84062: ST_TO_ADDR
// continue ;
84063: GO 83903
// end ; if f_repair then
84065: LD_VAR 0 22
84069: IFFALSE 84558
// begin if GetType ( group [ i ] ) = unit_vehicle then
84071: LD_VAR 0 4
84075: PUSH
84076: LD_VAR 0 7
84080: ARRAY
84081: PPUSH
84082: CALL_OW 247
84086: PUSH
84087: LD_INT 2
84089: EQUAL
84090: IFFALSE 84280
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
84092: LD_VAR 0 4
84096: PUSH
84097: LD_VAR 0 7
84101: ARRAY
84102: PPUSH
84103: CALL_OW 256
84107: PUSH
84108: LD_INT 700
84110: LESS
84111: PUSH
84112: LD_VAR 0 4
84116: PUSH
84117: LD_VAR 0 7
84121: ARRAY
84122: PUSH
84123: LD_VAR 0 32
84127: IN
84128: NOT
84129: AND
84130: IFFALSE 84154
// to_repair := to_repair union group [ i ] ;
84132: LD_ADDR_VAR 0 32
84136: PUSH
84137: LD_VAR 0 32
84141: PUSH
84142: LD_VAR 0 4
84146: PUSH
84147: LD_VAR 0 7
84151: ARRAY
84152: UNION
84153: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
84154: LD_VAR 0 4
84158: PUSH
84159: LD_VAR 0 7
84163: ARRAY
84164: PPUSH
84165: CALL_OW 256
84169: PUSH
84170: LD_INT 1000
84172: EQUAL
84173: PUSH
84174: LD_VAR 0 4
84178: PUSH
84179: LD_VAR 0 7
84183: ARRAY
84184: PUSH
84185: LD_VAR 0 32
84189: IN
84190: AND
84191: IFFALSE 84215
// to_repair := to_repair diff group [ i ] ;
84193: LD_ADDR_VAR 0 32
84197: PUSH
84198: LD_VAR 0 32
84202: PUSH
84203: LD_VAR 0 4
84207: PUSH
84208: LD_VAR 0 7
84212: ARRAY
84213: DIFF
84214: ST_TO_ADDR
// if group [ i ] in to_repair then
84215: LD_VAR 0 4
84219: PUSH
84220: LD_VAR 0 7
84224: ARRAY
84225: PUSH
84226: LD_VAR 0 32
84230: IN
84231: IFFALSE 84278
// begin if not IsInArea ( group [ i ] , f_repair ) then
84233: LD_VAR 0 4
84237: PUSH
84238: LD_VAR 0 7
84242: ARRAY
84243: PPUSH
84244: LD_VAR 0 22
84248: PPUSH
84249: CALL_OW 308
84253: NOT
84254: IFFALSE 84276
// ComMoveToArea ( group [ i ] , f_repair ) ;
84256: LD_VAR 0 4
84260: PUSH
84261: LD_VAR 0 7
84265: ARRAY
84266: PPUSH
84267: LD_VAR 0 22
84271: PPUSH
84272: CALL_OW 113
// continue ;
84276: GO 83903
// end ; end else
84278: GO 84558
// if group [ i ] in repairs then
84280: LD_VAR 0 4
84284: PUSH
84285: LD_VAR 0 7
84289: ARRAY
84290: PUSH
84291: LD_VAR 0 33
84295: IN
84296: IFFALSE 84558
// begin if IsInUnit ( group [ i ] ) then
84298: LD_VAR 0 4
84302: PUSH
84303: LD_VAR 0 7
84307: ARRAY
84308: PPUSH
84309: CALL_OW 310
84313: IFFALSE 84381
// begin z := IsInUnit ( group [ i ] ) ;
84315: LD_ADDR_VAR 0 13
84319: PUSH
84320: LD_VAR 0 4
84324: PUSH
84325: LD_VAR 0 7
84329: ARRAY
84330: PPUSH
84331: CALL_OW 310
84335: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
84336: LD_VAR 0 13
84340: PUSH
84341: LD_VAR 0 32
84345: IN
84346: PUSH
84347: LD_VAR 0 13
84351: PPUSH
84352: LD_VAR 0 22
84356: PPUSH
84357: CALL_OW 308
84361: AND
84362: IFFALSE 84379
// ComExitVehicle ( group [ i ] ) ;
84364: LD_VAR 0 4
84368: PUSH
84369: LD_VAR 0 7
84373: ARRAY
84374: PPUSH
84375: CALL_OW 121
// end else
84379: GO 84558
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84381: LD_ADDR_VAR 0 13
84385: PUSH
84386: LD_VAR 0 4
84390: PPUSH
84391: LD_INT 95
84393: PUSH
84394: LD_VAR 0 22
84398: PUSH
84399: EMPTY
84400: LIST
84401: LIST
84402: PUSH
84403: LD_INT 58
84405: PUSH
84406: EMPTY
84407: LIST
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: PPUSH
84413: CALL_OW 72
84417: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84418: LD_VAR 0 4
84422: PUSH
84423: LD_VAR 0 7
84427: ARRAY
84428: PPUSH
84429: CALL_OW 314
84433: NOT
84434: IFFALSE 84556
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84436: LD_ADDR_VAR 0 10
84440: PUSH
84441: LD_VAR 0 13
84445: PPUSH
84446: LD_VAR 0 4
84450: PUSH
84451: LD_VAR 0 7
84455: ARRAY
84456: PPUSH
84457: CALL_OW 74
84461: ST_TO_ADDR
// if not x then
84462: LD_VAR 0 10
84466: NOT
84467: IFFALSE 84471
// continue ;
84469: GO 83903
// if GetLives ( x ) < 1000 then
84471: LD_VAR 0 10
84475: PPUSH
84476: CALL_OW 256
84480: PUSH
84481: LD_INT 1000
84483: LESS
84484: IFFALSE 84508
// ComRepairVehicle ( group [ i ] , x ) else
84486: LD_VAR 0 4
84490: PUSH
84491: LD_VAR 0 7
84495: ARRAY
84496: PPUSH
84497: LD_VAR 0 10
84501: PPUSH
84502: CALL_OW 129
84506: GO 84556
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84508: LD_VAR 0 23
84512: PUSH
84513: LD_VAR 0 4
84517: PUSH
84518: LD_VAR 0 7
84522: ARRAY
84523: PPUSH
84524: CALL_OW 256
84528: PUSH
84529: LD_INT 1000
84531: LESS
84532: AND
84533: NOT
84534: IFFALSE 84556
// ComEnterUnit ( group [ i ] , x ) ;
84536: LD_VAR 0 4
84540: PUSH
84541: LD_VAR 0 7
84545: ARRAY
84546: PPUSH
84547: LD_VAR 0 10
84551: PPUSH
84552: CALL_OW 120
// end ; continue ;
84556: GO 83903
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84558: LD_VAR 0 23
84562: PUSH
84563: LD_VAR 0 4
84567: PUSH
84568: LD_VAR 0 7
84572: ARRAY
84573: PPUSH
84574: CALL_OW 247
84578: PUSH
84579: LD_INT 1
84581: EQUAL
84582: AND
84583: IFFALSE 85061
// begin if group [ i ] in healers then
84585: LD_VAR 0 4
84589: PUSH
84590: LD_VAR 0 7
84594: ARRAY
84595: PUSH
84596: LD_VAR 0 31
84600: IN
84601: IFFALSE 84874
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84603: LD_VAR 0 4
84607: PUSH
84608: LD_VAR 0 7
84612: ARRAY
84613: PPUSH
84614: LD_VAR 0 23
84618: PPUSH
84619: CALL_OW 308
84623: NOT
84624: PUSH
84625: LD_VAR 0 4
84629: PUSH
84630: LD_VAR 0 7
84634: ARRAY
84635: PPUSH
84636: CALL_OW 314
84640: NOT
84641: AND
84642: IFFALSE 84666
// ComMoveToArea ( group [ i ] , f_heal ) else
84644: LD_VAR 0 4
84648: PUSH
84649: LD_VAR 0 7
84653: ARRAY
84654: PPUSH
84655: LD_VAR 0 23
84659: PPUSH
84660: CALL_OW 113
84664: GO 84872
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84666: LD_VAR 0 4
84670: PUSH
84671: LD_VAR 0 7
84675: ARRAY
84676: PPUSH
84677: CALL 45829 0 1
84681: PPUSH
84682: CALL_OW 256
84686: PUSH
84687: LD_INT 1000
84689: EQUAL
84690: IFFALSE 84709
// ComStop ( group [ i ] ) else
84692: LD_VAR 0 4
84696: PUSH
84697: LD_VAR 0 7
84701: ARRAY
84702: PPUSH
84703: CALL_OW 141
84707: GO 84872
// if not HasTask ( group [ i ] ) and to_heal then
84709: LD_VAR 0 4
84713: PUSH
84714: LD_VAR 0 7
84718: ARRAY
84719: PPUSH
84720: CALL_OW 314
84724: NOT
84725: PUSH
84726: LD_VAR 0 30
84730: AND
84731: IFFALSE 84872
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84733: LD_ADDR_VAR 0 13
84737: PUSH
84738: LD_VAR 0 30
84742: PPUSH
84743: LD_INT 3
84745: PUSH
84746: LD_INT 54
84748: PUSH
84749: EMPTY
84750: LIST
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PPUSH
84756: CALL_OW 72
84760: PPUSH
84761: LD_VAR 0 4
84765: PUSH
84766: LD_VAR 0 7
84770: ARRAY
84771: PPUSH
84772: CALL_OW 74
84776: ST_TO_ADDR
// if z then
84777: LD_VAR 0 13
84781: IFFALSE 84872
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84783: LD_INT 91
84785: PUSH
84786: LD_VAR 0 13
84790: PUSH
84791: LD_INT 10
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 81
84801: PUSH
84802: LD_VAR 0 13
84806: PPUSH
84807: CALL_OW 255
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: PUSH
84816: EMPTY
84817: LIST
84818: LIST
84819: PPUSH
84820: CALL_OW 69
84824: PUSH
84825: LD_INT 0
84827: EQUAL
84828: IFFALSE 84852
// ComHeal ( group [ i ] , z ) else
84830: LD_VAR 0 4
84834: PUSH
84835: LD_VAR 0 7
84839: ARRAY
84840: PPUSH
84841: LD_VAR 0 13
84845: PPUSH
84846: CALL_OW 128
84850: GO 84872
// ComMoveToArea ( group [ i ] , f_heal ) ;
84852: LD_VAR 0 4
84856: PUSH
84857: LD_VAR 0 7
84861: ARRAY
84862: PPUSH
84863: LD_VAR 0 23
84867: PPUSH
84868: CALL_OW 113
// end ; continue ;
84872: GO 83903
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84874: LD_VAR 0 4
84878: PUSH
84879: LD_VAR 0 7
84883: ARRAY
84884: PPUSH
84885: CALL_OW 256
84889: PUSH
84890: LD_INT 700
84892: LESS
84893: PUSH
84894: LD_VAR 0 4
84898: PUSH
84899: LD_VAR 0 7
84903: ARRAY
84904: PUSH
84905: LD_VAR 0 30
84909: IN
84910: NOT
84911: AND
84912: IFFALSE 84936
// to_heal := to_heal union group [ i ] ;
84914: LD_ADDR_VAR 0 30
84918: PUSH
84919: LD_VAR 0 30
84923: PUSH
84924: LD_VAR 0 4
84928: PUSH
84929: LD_VAR 0 7
84933: ARRAY
84934: UNION
84935: ST_TO_ADDR
// if group [ i ] in to_heal then
84936: LD_VAR 0 4
84940: PUSH
84941: LD_VAR 0 7
84945: ARRAY
84946: PUSH
84947: LD_VAR 0 30
84951: IN
84952: IFFALSE 85061
// begin if GetLives ( group [ i ] ) = 1000 then
84954: LD_VAR 0 4
84958: PUSH
84959: LD_VAR 0 7
84963: ARRAY
84964: PPUSH
84965: CALL_OW 256
84969: PUSH
84970: LD_INT 1000
84972: EQUAL
84973: IFFALSE 84999
// to_heal := to_heal diff group [ i ] else
84975: LD_ADDR_VAR 0 30
84979: PUSH
84980: LD_VAR 0 30
84984: PUSH
84985: LD_VAR 0 4
84989: PUSH
84990: LD_VAR 0 7
84994: ARRAY
84995: DIFF
84996: ST_TO_ADDR
84997: GO 85061
// begin if not IsInArea ( group [ i ] , to_heal ) then
84999: LD_VAR 0 4
85003: PUSH
85004: LD_VAR 0 7
85008: ARRAY
85009: PPUSH
85010: LD_VAR 0 30
85014: PPUSH
85015: CALL_OW 308
85019: NOT
85020: IFFALSE 85044
// ComMoveToArea ( group [ i ] , f_heal ) else
85022: LD_VAR 0 4
85026: PUSH
85027: LD_VAR 0 7
85031: ARRAY
85032: PPUSH
85033: LD_VAR 0 23
85037: PPUSH
85038: CALL_OW 113
85042: GO 85059
// ComHold ( group [ i ] ) ;
85044: LD_VAR 0 4
85048: PUSH
85049: LD_VAR 0 7
85053: ARRAY
85054: PPUSH
85055: CALL_OW 140
// continue ;
85059: GO 83903
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
85061: LD_VAR 0 4
85065: PUSH
85066: LD_VAR 0 7
85070: ARRAY
85071: PPUSH
85072: LD_INT 10
85074: PPUSH
85075: CALL 43600 0 2
85079: NOT
85080: PUSH
85081: LD_VAR 0 16
85085: PUSH
85086: LD_VAR 0 7
85090: ARRAY
85091: PUSH
85092: EMPTY
85093: EQUAL
85094: NOT
85095: AND
85096: IFFALSE 85362
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
85098: LD_VAR 0 4
85102: PUSH
85103: LD_VAR 0 7
85107: ARRAY
85108: PPUSH
85109: CALL_OW 262
85113: PUSH
85114: LD_INT 1
85116: PUSH
85117: LD_INT 2
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: IN
85124: IFFALSE 85165
// if GetFuel ( group [ i ] ) < 10 then
85126: LD_VAR 0 4
85130: PUSH
85131: LD_VAR 0 7
85135: ARRAY
85136: PPUSH
85137: CALL_OW 261
85141: PUSH
85142: LD_INT 10
85144: LESS
85145: IFFALSE 85165
// SetFuel ( group [ i ] , 12 ) ;
85147: LD_VAR 0 4
85151: PUSH
85152: LD_VAR 0 7
85156: ARRAY
85157: PPUSH
85158: LD_INT 12
85160: PPUSH
85161: CALL_OW 240
// if units_path [ i ] then
85165: LD_VAR 0 16
85169: PUSH
85170: LD_VAR 0 7
85174: ARRAY
85175: IFFALSE 85360
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
85177: LD_VAR 0 4
85181: PUSH
85182: LD_VAR 0 7
85186: ARRAY
85187: PPUSH
85188: LD_VAR 0 16
85192: PUSH
85193: LD_VAR 0 7
85197: ARRAY
85198: PUSH
85199: LD_INT 1
85201: ARRAY
85202: PUSH
85203: LD_INT 1
85205: ARRAY
85206: PPUSH
85207: LD_VAR 0 16
85211: PUSH
85212: LD_VAR 0 7
85216: ARRAY
85217: PUSH
85218: LD_INT 1
85220: ARRAY
85221: PUSH
85222: LD_INT 2
85224: ARRAY
85225: PPUSH
85226: CALL_OW 297
85230: PUSH
85231: LD_INT 6
85233: GREATER
85234: IFFALSE 85309
// begin if not HasTask ( group [ i ] ) then
85236: LD_VAR 0 4
85240: PUSH
85241: LD_VAR 0 7
85245: ARRAY
85246: PPUSH
85247: CALL_OW 314
85251: NOT
85252: IFFALSE 85307
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
85254: LD_VAR 0 4
85258: PUSH
85259: LD_VAR 0 7
85263: ARRAY
85264: PPUSH
85265: LD_VAR 0 16
85269: PUSH
85270: LD_VAR 0 7
85274: ARRAY
85275: PUSH
85276: LD_INT 1
85278: ARRAY
85279: PUSH
85280: LD_INT 1
85282: ARRAY
85283: PPUSH
85284: LD_VAR 0 16
85288: PUSH
85289: LD_VAR 0 7
85293: ARRAY
85294: PUSH
85295: LD_INT 1
85297: ARRAY
85298: PUSH
85299: LD_INT 2
85301: ARRAY
85302: PPUSH
85303: CALL_OW 114
// end else
85307: GO 85360
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
85309: LD_ADDR_VAR 0 15
85313: PUSH
85314: LD_VAR 0 16
85318: PUSH
85319: LD_VAR 0 7
85323: ARRAY
85324: PPUSH
85325: LD_INT 1
85327: PPUSH
85328: CALL_OW 3
85332: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
85333: LD_ADDR_VAR 0 16
85337: PUSH
85338: LD_VAR 0 16
85342: PPUSH
85343: LD_VAR 0 7
85347: PPUSH
85348: LD_VAR 0 15
85352: PPUSH
85353: CALL_OW 1
85357: ST_TO_ADDR
// continue ;
85358: GO 83903
// end ; end ; end else
85360: GO 88024
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85362: LD_ADDR_VAR 0 14
85366: PUSH
85367: LD_INT 81
85369: PUSH
85370: LD_VAR 0 4
85374: PUSH
85375: LD_VAR 0 7
85379: ARRAY
85380: PPUSH
85381: CALL_OW 255
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PPUSH
85390: CALL_OW 69
85394: ST_TO_ADDR
// if not tmp then
85395: LD_VAR 0 14
85399: NOT
85400: IFFALSE 85404
// continue ;
85402: GO 83903
// if f_ignore_area then
85404: LD_VAR 0 17
85408: IFFALSE 85496
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85410: LD_ADDR_VAR 0 15
85414: PUSH
85415: LD_VAR 0 14
85419: PPUSH
85420: LD_INT 3
85422: PUSH
85423: LD_INT 92
85425: PUSH
85426: LD_VAR 0 17
85430: PUSH
85431: LD_INT 1
85433: ARRAY
85434: PUSH
85435: LD_VAR 0 17
85439: PUSH
85440: LD_INT 2
85442: ARRAY
85443: PUSH
85444: LD_VAR 0 17
85448: PUSH
85449: LD_INT 3
85451: ARRAY
85452: PUSH
85453: EMPTY
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: PUSH
85459: EMPTY
85460: LIST
85461: LIST
85462: PPUSH
85463: CALL_OW 72
85467: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85468: LD_VAR 0 14
85472: PUSH
85473: LD_VAR 0 15
85477: DIFF
85478: IFFALSE 85496
// tmp := tmp diff tmp2 ;
85480: LD_ADDR_VAR 0 14
85484: PUSH
85485: LD_VAR 0 14
85489: PUSH
85490: LD_VAR 0 15
85494: DIFF
85495: ST_TO_ADDR
// end ; if not f_murder then
85496: LD_VAR 0 20
85500: NOT
85501: IFFALSE 85559
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85503: LD_ADDR_VAR 0 15
85507: PUSH
85508: LD_VAR 0 14
85512: PPUSH
85513: LD_INT 3
85515: PUSH
85516: LD_INT 50
85518: PUSH
85519: EMPTY
85520: LIST
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PPUSH
85526: CALL_OW 72
85530: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85531: LD_VAR 0 14
85535: PUSH
85536: LD_VAR 0 15
85540: DIFF
85541: IFFALSE 85559
// tmp := tmp diff tmp2 ;
85543: LD_ADDR_VAR 0 14
85547: PUSH
85548: LD_VAR 0 14
85552: PUSH
85553: LD_VAR 0 15
85557: DIFF
85558: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85559: LD_ADDR_VAR 0 14
85563: PUSH
85564: LD_VAR 0 4
85568: PUSH
85569: LD_VAR 0 7
85573: ARRAY
85574: PPUSH
85575: LD_VAR 0 14
85579: PPUSH
85580: LD_INT 1
85582: PPUSH
85583: LD_INT 1
85585: PPUSH
85586: CALL 16512 0 4
85590: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85591: LD_VAR 0 4
85595: PUSH
85596: LD_VAR 0 7
85600: ARRAY
85601: PPUSH
85602: CALL_OW 257
85606: PUSH
85607: LD_INT 1
85609: EQUAL
85610: IFFALSE 86058
// begin if WantPlant ( group [ i ] ) then
85612: LD_VAR 0 4
85616: PUSH
85617: LD_VAR 0 7
85621: ARRAY
85622: PPUSH
85623: CALL 16013 0 1
85627: IFFALSE 85631
// continue ;
85629: GO 83903
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85631: LD_VAR 0 18
85635: PUSH
85636: LD_VAR 0 4
85640: PUSH
85641: LD_VAR 0 7
85645: ARRAY
85646: PPUSH
85647: CALL_OW 310
85651: NOT
85652: AND
85653: PUSH
85654: LD_VAR 0 14
85658: PUSH
85659: LD_INT 1
85661: ARRAY
85662: PUSH
85663: LD_VAR 0 14
85667: PPUSH
85668: LD_INT 21
85670: PUSH
85671: LD_INT 2
85673: PUSH
85674: EMPTY
85675: LIST
85676: LIST
85677: PUSH
85678: LD_INT 58
85680: PUSH
85681: EMPTY
85682: LIST
85683: PUSH
85684: EMPTY
85685: LIST
85686: LIST
85687: PPUSH
85688: CALL_OW 72
85692: IN
85693: AND
85694: IFFALSE 85730
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85696: LD_VAR 0 4
85700: PUSH
85701: LD_VAR 0 7
85705: ARRAY
85706: PPUSH
85707: LD_VAR 0 14
85711: PUSH
85712: LD_INT 1
85714: ARRAY
85715: PPUSH
85716: CALL_OW 120
// attacking := true ;
85720: LD_ADDR_VAR 0 29
85724: PUSH
85725: LD_INT 1
85727: ST_TO_ADDR
// continue ;
85728: GO 83903
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85730: LD_VAR 0 26
85734: PUSH
85735: LD_VAR 0 4
85739: PUSH
85740: LD_VAR 0 7
85744: ARRAY
85745: PPUSH
85746: CALL_OW 257
85750: PUSH
85751: LD_INT 1
85753: EQUAL
85754: AND
85755: PUSH
85756: LD_VAR 0 4
85760: PUSH
85761: LD_VAR 0 7
85765: ARRAY
85766: PPUSH
85767: CALL_OW 256
85771: PUSH
85772: LD_INT 800
85774: LESS
85775: AND
85776: PUSH
85777: LD_VAR 0 4
85781: PUSH
85782: LD_VAR 0 7
85786: ARRAY
85787: PPUSH
85788: CALL_OW 318
85792: NOT
85793: AND
85794: IFFALSE 85811
// ComCrawl ( group [ i ] ) ;
85796: LD_VAR 0 4
85800: PUSH
85801: LD_VAR 0 7
85805: ARRAY
85806: PPUSH
85807: CALL_OW 137
// if f_mines then
85811: LD_VAR 0 21
85815: IFFALSE 86058
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85817: LD_VAR 0 14
85821: PUSH
85822: LD_INT 1
85824: ARRAY
85825: PPUSH
85826: CALL_OW 247
85830: PUSH
85831: LD_INT 3
85833: EQUAL
85834: PUSH
85835: LD_VAR 0 14
85839: PUSH
85840: LD_INT 1
85842: ARRAY
85843: PUSH
85844: LD_VAR 0 27
85848: IN
85849: NOT
85850: AND
85851: IFFALSE 86058
// begin x := GetX ( tmp [ 1 ] ) ;
85853: LD_ADDR_VAR 0 10
85857: PUSH
85858: LD_VAR 0 14
85862: PUSH
85863: LD_INT 1
85865: ARRAY
85866: PPUSH
85867: CALL_OW 250
85871: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85872: LD_ADDR_VAR 0 11
85876: PUSH
85877: LD_VAR 0 14
85881: PUSH
85882: LD_INT 1
85884: ARRAY
85885: PPUSH
85886: CALL_OW 251
85890: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85891: LD_ADDR_VAR 0 12
85895: PUSH
85896: LD_VAR 0 4
85900: PUSH
85901: LD_VAR 0 7
85905: ARRAY
85906: PPUSH
85907: CALL 43685 0 1
85911: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85912: LD_VAR 0 4
85916: PUSH
85917: LD_VAR 0 7
85921: ARRAY
85922: PPUSH
85923: LD_VAR 0 10
85927: PPUSH
85928: LD_VAR 0 11
85932: PPUSH
85933: LD_VAR 0 14
85937: PUSH
85938: LD_INT 1
85940: ARRAY
85941: PPUSH
85942: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85946: LD_VAR 0 4
85950: PUSH
85951: LD_VAR 0 7
85955: ARRAY
85956: PPUSH
85957: LD_VAR 0 10
85961: PPUSH
85962: LD_VAR 0 12
85966: PPUSH
85967: LD_INT 7
85969: PPUSH
85970: CALL_OW 272
85974: PPUSH
85975: LD_VAR 0 11
85979: PPUSH
85980: LD_VAR 0 12
85984: PPUSH
85985: LD_INT 7
85987: PPUSH
85988: CALL_OW 273
85992: PPUSH
85993: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85997: LD_VAR 0 4
86001: PUSH
86002: LD_VAR 0 7
86006: ARRAY
86007: PPUSH
86008: LD_INT 71
86010: PPUSH
86011: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
86015: LD_ADDR_VAR 0 27
86019: PUSH
86020: LD_VAR 0 27
86024: PPUSH
86025: LD_VAR 0 27
86029: PUSH
86030: LD_INT 1
86032: PLUS
86033: PPUSH
86034: LD_VAR 0 14
86038: PUSH
86039: LD_INT 1
86041: ARRAY
86042: PPUSH
86043: CALL_OW 1
86047: ST_TO_ADDR
// attacking := true ;
86048: LD_ADDR_VAR 0 29
86052: PUSH
86053: LD_INT 1
86055: ST_TO_ADDR
// continue ;
86056: GO 83903
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
86058: LD_VAR 0 4
86062: PUSH
86063: LD_VAR 0 7
86067: ARRAY
86068: PPUSH
86069: CALL_OW 257
86073: PUSH
86074: LD_INT 17
86076: EQUAL
86077: PUSH
86078: LD_VAR 0 4
86082: PUSH
86083: LD_VAR 0 7
86087: ARRAY
86088: PPUSH
86089: CALL_OW 110
86093: PUSH
86094: LD_INT 71
86096: EQUAL
86097: NOT
86098: AND
86099: IFFALSE 86245
// begin attacking := false ;
86101: LD_ADDR_VAR 0 29
86105: PUSH
86106: LD_INT 0
86108: ST_TO_ADDR
// k := 5 ;
86109: LD_ADDR_VAR 0 9
86113: PUSH
86114: LD_INT 5
86116: ST_TO_ADDR
// if tmp < k then
86117: LD_VAR 0 14
86121: PUSH
86122: LD_VAR 0 9
86126: LESS
86127: IFFALSE 86139
// k := tmp ;
86129: LD_ADDR_VAR 0 9
86133: PUSH
86134: LD_VAR 0 14
86138: ST_TO_ADDR
// for j = 1 to k do
86139: LD_ADDR_VAR 0 8
86143: PUSH
86144: DOUBLE
86145: LD_INT 1
86147: DEC
86148: ST_TO_ADDR
86149: LD_VAR 0 9
86153: PUSH
86154: FOR_TO
86155: IFFALSE 86243
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
86157: LD_VAR 0 14
86161: PUSH
86162: LD_VAR 0 8
86166: ARRAY
86167: PUSH
86168: LD_VAR 0 14
86172: PPUSH
86173: LD_INT 58
86175: PUSH
86176: EMPTY
86177: LIST
86178: PPUSH
86179: CALL_OW 72
86183: IN
86184: NOT
86185: IFFALSE 86241
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86187: LD_VAR 0 4
86191: PUSH
86192: LD_VAR 0 7
86196: ARRAY
86197: PPUSH
86198: LD_VAR 0 14
86202: PUSH
86203: LD_VAR 0 8
86207: ARRAY
86208: PPUSH
86209: CALL_OW 115
// attacking := true ;
86213: LD_ADDR_VAR 0 29
86217: PUSH
86218: LD_INT 1
86220: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
86221: LD_VAR 0 4
86225: PUSH
86226: LD_VAR 0 7
86230: ARRAY
86231: PPUSH
86232: LD_INT 71
86234: PPUSH
86235: CALL_OW 109
// continue ;
86239: GO 86154
// end ; end ;
86241: GO 86154
86243: POP
86244: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
86245: LD_VAR 0 4
86249: PUSH
86250: LD_VAR 0 7
86254: ARRAY
86255: PPUSH
86256: CALL_OW 257
86260: PUSH
86261: LD_INT 8
86263: EQUAL
86264: PUSH
86265: LD_VAR 0 4
86269: PUSH
86270: LD_VAR 0 7
86274: ARRAY
86275: PPUSH
86276: CALL_OW 264
86280: PUSH
86281: LD_INT 28
86283: PUSH
86284: LD_INT 45
86286: PUSH
86287: LD_INT 7
86289: PUSH
86290: LD_INT 47
86292: PUSH
86293: EMPTY
86294: LIST
86295: LIST
86296: LIST
86297: LIST
86298: IN
86299: OR
86300: IFFALSE 86556
// begin attacking := false ;
86302: LD_ADDR_VAR 0 29
86306: PUSH
86307: LD_INT 0
86309: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
86310: LD_VAR 0 14
86314: PUSH
86315: LD_INT 1
86317: ARRAY
86318: PPUSH
86319: CALL_OW 266
86323: PUSH
86324: LD_INT 32
86326: PUSH
86327: LD_INT 31
86329: PUSH
86330: LD_INT 33
86332: PUSH
86333: LD_INT 4
86335: PUSH
86336: LD_INT 5
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: IN
86346: IFFALSE 86532
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
86348: LD_ADDR_VAR 0 9
86352: PUSH
86353: LD_VAR 0 14
86357: PUSH
86358: LD_INT 1
86360: ARRAY
86361: PPUSH
86362: CALL_OW 266
86366: PPUSH
86367: LD_VAR 0 14
86371: PUSH
86372: LD_INT 1
86374: ARRAY
86375: PPUSH
86376: CALL_OW 250
86380: PPUSH
86381: LD_VAR 0 14
86385: PUSH
86386: LD_INT 1
86388: ARRAY
86389: PPUSH
86390: CALL_OW 251
86394: PPUSH
86395: LD_VAR 0 14
86399: PUSH
86400: LD_INT 1
86402: ARRAY
86403: PPUSH
86404: CALL_OW 254
86408: PPUSH
86409: LD_VAR 0 14
86413: PUSH
86414: LD_INT 1
86416: ARRAY
86417: PPUSH
86418: CALL_OW 248
86422: PPUSH
86423: LD_INT 0
86425: PPUSH
86426: CALL 25055 0 6
86430: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86431: LD_ADDR_VAR 0 8
86435: PUSH
86436: LD_VAR 0 4
86440: PUSH
86441: LD_VAR 0 7
86445: ARRAY
86446: PPUSH
86447: LD_VAR 0 9
86451: PPUSH
86452: CALL 43798 0 2
86456: ST_TO_ADDR
// if j then
86457: LD_VAR 0 8
86461: IFFALSE 86530
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86463: LD_VAR 0 8
86467: PUSH
86468: LD_INT 1
86470: ARRAY
86471: PPUSH
86472: LD_VAR 0 8
86476: PUSH
86477: LD_INT 2
86479: ARRAY
86480: PPUSH
86481: CALL_OW 488
86485: IFFALSE 86530
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86487: LD_VAR 0 4
86491: PUSH
86492: LD_VAR 0 7
86496: ARRAY
86497: PPUSH
86498: LD_VAR 0 8
86502: PUSH
86503: LD_INT 1
86505: ARRAY
86506: PPUSH
86507: LD_VAR 0 8
86511: PUSH
86512: LD_INT 2
86514: ARRAY
86515: PPUSH
86516: CALL_OW 116
// attacking := true ;
86520: LD_ADDR_VAR 0 29
86524: PUSH
86525: LD_INT 1
86527: ST_TO_ADDR
// continue ;
86528: GO 83903
// end ; end else
86530: GO 86556
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86532: LD_VAR 0 4
86536: PUSH
86537: LD_VAR 0 7
86541: ARRAY
86542: PPUSH
86543: LD_VAR 0 14
86547: PUSH
86548: LD_INT 1
86550: ARRAY
86551: PPUSH
86552: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86556: LD_VAR 0 4
86560: PUSH
86561: LD_VAR 0 7
86565: ARRAY
86566: PPUSH
86567: CALL_OW 265
86571: PUSH
86572: LD_INT 11
86574: EQUAL
86575: IFFALSE 86853
// begin k := 10 ;
86577: LD_ADDR_VAR 0 9
86581: PUSH
86582: LD_INT 10
86584: ST_TO_ADDR
// x := 0 ;
86585: LD_ADDR_VAR 0 10
86589: PUSH
86590: LD_INT 0
86592: ST_TO_ADDR
// if tmp < k then
86593: LD_VAR 0 14
86597: PUSH
86598: LD_VAR 0 9
86602: LESS
86603: IFFALSE 86615
// k := tmp ;
86605: LD_ADDR_VAR 0 9
86609: PUSH
86610: LD_VAR 0 14
86614: ST_TO_ADDR
// for j = k downto 1 do
86615: LD_ADDR_VAR 0 8
86619: PUSH
86620: DOUBLE
86621: LD_VAR 0 9
86625: INC
86626: ST_TO_ADDR
86627: LD_INT 1
86629: PUSH
86630: FOR_DOWNTO
86631: IFFALSE 86706
// begin if GetType ( tmp [ j ] ) = unit_human then
86633: LD_VAR 0 14
86637: PUSH
86638: LD_VAR 0 8
86642: ARRAY
86643: PPUSH
86644: CALL_OW 247
86648: PUSH
86649: LD_INT 1
86651: EQUAL
86652: IFFALSE 86704
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86654: LD_VAR 0 4
86658: PUSH
86659: LD_VAR 0 7
86663: ARRAY
86664: PPUSH
86665: LD_VAR 0 14
86669: PUSH
86670: LD_VAR 0 8
86674: ARRAY
86675: PPUSH
86676: CALL 44052 0 2
// x := tmp [ j ] ;
86680: LD_ADDR_VAR 0 10
86684: PUSH
86685: LD_VAR 0 14
86689: PUSH
86690: LD_VAR 0 8
86694: ARRAY
86695: ST_TO_ADDR
// attacking := true ;
86696: LD_ADDR_VAR 0 29
86700: PUSH
86701: LD_INT 1
86703: ST_TO_ADDR
// end ; end ;
86704: GO 86630
86706: POP
86707: POP
// if not x then
86708: LD_VAR 0 10
86712: NOT
86713: IFFALSE 86853
// begin attacking := true ;
86715: LD_ADDR_VAR 0 29
86719: PUSH
86720: LD_INT 1
86722: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86723: LD_VAR 0 4
86727: PUSH
86728: LD_VAR 0 7
86732: ARRAY
86733: PPUSH
86734: CALL_OW 250
86738: PPUSH
86739: LD_VAR 0 4
86743: PUSH
86744: LD_VAR 0 7
86748: ARRAY
86749: PPUSH
86750: CALL_OW 251
86754: PPUSH
86755: CALL_OW 546
86759: PUSH
86760: LD_INT 2
86762: ARRAY
86763: PUSH
86764: LD_VAR 0 14
86768: PUSH
86769: LD_INT 1
86771: ARRAY
86772: PPUSH
86773: CALL_OW 250
86777: PPUSH
86778: LD_VAR 0 14
86782: PUSH
86783: LD_INT 1
86785: ARRAY
86786: PPUSH
86787: CALL_OW 251
86791: PPUSH
86792: CALL_OW 546
86796: PUSH
86797: LD_INT 2
86799: ARRAY
86800: EQUAL
86801: IFFALSE 86829
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86803: LD_VAR 0 4
86807: PUSH
86808: LD_VAR 0 7
86812: ARRAY
86813: PPUSH
86814: LD_VAR 0 14
86818: PUSH
86819: LD_INT 1
86821: ARRAY
86822: PPUSH
86823: CALL 44052 0 2
86827: GO 86853
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86829: LD_VAR 0 4
86833: PUSH
86834: LD_VAR 0 7
86838: ARRAY
86839: PPUSH
86840: LD_VAR 0 14
86844: PUSH
86845: LD_INT 1
86847: ARRAY
86848: PPUSH
86849: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86853: LD_VAR 0 4
86857: PUSH
86858: LD_VAR 0 7
86862: ARRAY
86863: PPUSH
86864: CALL_OW 264
86868: PUSH
86869: LD_INT 29
86871: EQUAL
86872: IFFALSE 87238
// begin if WantsToAttack ( group [ i ] ) in bombed then
86874: LD_VAR 0 4
86878: PUSH
86879: LD_VAR 0 7
86883: ARRAY
86884: PPUSH
86885: CALL_OW 319
86889: PUSH
86890: LD_VAR 0 28
86894: IN
86895: IFFALSE 86899
// continue ;
86897: GO 83903
// k := 8 ;
86899: LD_ADDR_VAR 0 9
86903: PUSH
86904: LD_INT 8
86906: ST_TO_ADDR
// x := 0 ;
86907: LD_ADDR_VAR 0 10
86911: PUSH
86912: LD_INT 0
86914: ST_TO_ADDR
// if tmp < k then
86915: LD_VAR 0 14
86919: PUSH
86920: LD_VAR 0 9
86924: LESS
86925: IFFALSE 86937
// k := tmp ;
86927: LD_ADDR_VAR 0 9
86931: PUSH
86932: LD_VAR 0 14
86936: ST_TO_ADDR
// for j = 1 to k do
86937: LD_ADDR_VAR 0 8
86941: PUSH
86942: DOUBLE
86943: LD_INT 1
86945: DEC
86946: ST_TO_ADDR
86947: LD_VAR 0 9
86951: PUSH
86952: FOR_TO
86953: IFFALSE 87085
// begin if GetType ( tmp [ j ] ) = unit_building then
86955: LD_VAR 0 14
86959: PUSH
86960: LD_VAR 0 8
86964: ARRAY
86965: PPUSH
86966: CALL_OW 247
86970: PUSH
86971: LD_INT 3
86973: EQUAL
86974: IFFALSE 87083
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86976: LD_VAR 0 14
86980: PUSH
86981: LD_VAR 0 8
86985: ARRAY
86986: PUSH
86987: LD_VAR 0 28
86991: IN
86992: NOT
86993: PUSH
86994: LD_VAR 0 14
86998: PUSH
86999: LD_VAR 0 8
87003: ARRAY
87004: PPUSH
87005: CALL_OW 313
87009: AND
87010: IFFALSE 87083
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87012: LD_VAR 0 4
87016: PUSH
87017: LD_VAR 0 7
87021: ARRAY
87022: PPUSH
87023: LD_VAR 0 14
87027: PUSH
87028: LD_VAR 0 8
87032: ARRAY
87033: PPUSH
87034: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
87038: LD_ADDR_VAR 0 28
87042: PUSH
87043: LD_VAR 0 28
87047: PPUSH
87048: LD_VAR 0 28
87052: PUSH
87053: LD_INT 1
87055: PLUS
87056: PPUSH
87057: LD_VAR 0 14
87061: PUSH
87062: LD_VAR 0 8
87066: ARRAY
87067: PPUSH
87068: CALL_OW 1
87072: ST_TO_ADDR
// attacking := true ;
87073: LD_ADDR_VAR 0 29
87077: PUSH
87078: LD_INT 1
87080: ST_TO_ADDR
// break ;
87081: GO 87085
// end ; end ;
87083: GO 86952
87085: POP
87086: POP
// if not attacking and f_attack_depot then
87087: LD_VAR 0 29
87091: NOT
87092: PUSH
87093: LD_VAR 0 25
87097: AND
87098: IFFALSE 87193
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87100: LD_ADDR_VAR 0 13
87104: PUSH
87105: LD_VAR 0 14
87109: PPUSH
87110: LD_INT 2
87112: PUSH
87113: LD_INT 30
87115: PUSH
87116: LD_INT 0
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 30
87125: PUSH
87126: LD_INT 1
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: LIST
87137: PPUSH
87138: CALL_OW 72
87142: ST_TO_ADDR
// if z then
87143: LD_VAR 0 13
87147: IFFALSE 87193
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
87149: LD_VAR 0 4
87153: PUSH
87154: LD_VAR 0 7
87158: ARRAY
87159: PPUSH
87160: LD_VAR 0 13
87164: PPUSH
87165: LD_VAR 0 4
87169: PUSH
87170: LD_VAR 0 7
87174: ARRAY
87175: PPUSH
87176: CALL_OW 74
87180: PPUSH
87181: CALL_OW 115
// attacking := true ;
87185: LD_ADDR_VAR 0 29
87189: PUSH
87190: LD_INT 1
87192: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
87193: LD_VAR 0 4
87197: PUSH
87198: LD_VAR 0 7
87202: ARRAY
87203: PPUSH
87204: CALL_OW 256
87208: PUSH
87209: LD_INT 500
87211: LESS
87212: IFFALSE 87238
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87214: LD_VAR 0 4
87218: PUSH
87219: LD_VAR 0 7
87223: ARRAY
87224: PPUSH
87225: LD_VAR 0 14
87229: PUSH
87230: LD_INT 1
87232: ARRAY
87233: PPUSH
87234: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
87238: LD_VAR 0 4
87242: PUSH
87243: LD_VAR 0 7
87247: ARRAY
87248: PPUSH
87249: CALL_OW 264
87253: PUSH
87254: LD_INT 49
87256: EQUAL
87257: IFFALSE 87378
// begin if not HasTask ( group [ i ] ) then
87259: LD_VAR 0 4
87263: PUSH
87264: LD_VAR 0 7
87268: ARRAY
87269: PPUSH
87270: CALL_OW 314
87274: NOT
87275: IFFALSE 87378
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
87277: LD_ADDR_VAR 0 9
87281: PUSH
87282: LD_INT 81
87284: PUSH
87285: LD_VAR 0 4
87289: PUSH
87290: LD_VAR 0 7
87294: ARRAY
87295: PPUSH
87296: CALL_OW 255
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PPUSH
87305: CALL_OW 69
87309: PPUSH
87310: LD_VAR 0 4
87314: PUSH
87315: LD_VAR 0 7
87319: ARRAY
87320: PPUSH
87321: CALL_OW 74
87325: ST_TO_ADDR
// if k then
87326: LD_VAR 0 9
87330: IFFALSE 87378
// if GetDistUnits ( group [ i ] , k ) > 10 then
87332: LD_VAR 0 4
87336: PUSH
87337: LD_VAR 0 7
87341: ARRAY
87342: PPUSH
87343: LD_VAR 0 9
87347: PPUSH
87348: CALL_OW 296
87352: PUSH
87353: LD_INT 10
87355: GREATER
87356: IFFALSE 87378
// ComMoveUnit ( group [ i ] , k ) ;
87358: LD_VAR 0 4
87362: PUSH
87363: LD_VAR 0 7
87367: ARRAY
87368: PPUSH
87369: LD_VAR 0 9
87373: PPUSH
87374: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87378: LD_VAR 0 4
87382: PUSH
87383: LD_VAR 0 7
87387: ARRAY
87388: PPUSH
87389: CALL_OW 256
87393: PUSH
87394: LD_INT 250
87396: LESS
87397: PUSH
87398: LD_VAR 0 4
87402: PUSH
87403: LD_VAR 0 7
87407: ARRAY
87408: PUSH
87409: LD_INT 21
87411: PUSH
87412: LD_INT 2
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 23
87421: PUSH
87422: LD_INT 2
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PPUSH
87433: CALL_OW 69
87437: IN
87438: AND
87439: IFFALSE 87564
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87441: LD_ADDR_VAR 0 9
87445: PUSH
87446: LD_OWVAR 3
87450: PUSH
87451: LD_VAR 0 4
87455: PUSH
87456: LD_VAR 0 7
87460: ARRAY
87461: DIFF
87462: PPUSH
87463: LD_VAR 0 4
87467: PUSH
87468: LD_VAR 0 7
87472: ARRAY
87473: PPUSH
87474: CALL_OW 74
87478: ST_TO_ADDR
// if not k then
87479: LD_VAR 0 9
87483: NOT
87484: IFFALSE 87488
// continue ;
87486: GO 83903
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87488: LD_VAR 0 9
87492: PUSH
87493: LD_INT 81
87495: PUSH
87496: LD_VAR 0 4
87500: PUSH
87501: LD_VAR 0 7
87505: ARRAY
87506: PPUSH
87507: CALL_OW 255
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PPUSH
87516: CALL_OW 69
87520: IN
87521: PUSH
87522: LD_VAR 0 9
87526: PPUSH
87527: LD_VAR 0 4
87531: PUSH
87532: LD_VAR 0 7
87536: ARRAY
87537: PPUSH
87538: CALL_OW 296
87542: PUSH
87543: LD_INT 5
87545: LESS
87546: AND
87547: IFFALSE 87564
// ComAutodestruct ( group [ i ] ) ;
87549: LD_VAR 0 4
87553: PUSH
87554: LD_VAR 0 7
87558: ARRAY
87559: PPUSH
87560: CALL 43950 0 1
// end ; if f_attack_depot then
87564: LD_VAR 0 25
87568: IFFALSE 87680
// begin k := 6 ;
87570: LD_ADDR_VAR 0 9
87574: PUSH
87575: LD_INT 6
87577: ST_TO_ADDR
// if tmp < k then
87578: LD_VAR 0 14
87582: PUSH
87583: LD_VAR 0 9
87587: LESS
87588: IFFALSE 87600
// k := tmp ;
87590: LD_ADDR_VAR 0 9
87594: PUSH
87595: LD_VAR 0 14
87599: ST_TO_ADDR
// for j = 1 to k do
87600: LD_ADDR_VAR 0 8
87604: PUSH
87605: DOUBLE
87606: LD_INT 1
87608: DEC
87609: ST_TO_ADDR
87610: LD_VAR 0 9
87614: PUSH
87615: FOR_TO
87616: IFFALSE 87678
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87618: LD_VAR 0 8
87622: PPUSH
87623: CALL_OW 266
87627: PUSH
87628: LD_INT 0
87630: PUSH
87631: LD_INT 1
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: IN
87638: IFFALSE 87676
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87640: LD_VAR 0 4
87644: PUSH
87645: LD_VAR 0 7
87649: ARRAY
87650: PPUSH
87651: LD_VAR 0 14
87655: PUSH
87656: LD_VAR 0 8
87660: ARRAY
87661: PPUSH
87662: CALL_OW 115
// attacking := true ;
87666: LD_ADDR_VAR 0 29
87670: PUSH
87671: LD_INT 1
87673: ST_TO_ADDR
// break ;
87674: GO 87678
// end ;
87676: GO 87615
87678: POP
87679: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87680: LD_VAR 0 4
87684: PUSH
87685: LD_VAR 0 7
87689: ARRAY
87690: PPUSH
87691: CALL_OW 302
87695: PUSH
87696: LD_VAR 0 29
87700: NOT
87701: AND
87702: IFFALSE 88024
// begin if GetTag ( group [ i ] ) = 71 then
87704: LD_VAR 0 4
87708: PUSH
87709: LD_VAR 0 7
87713: ARRAY
87714: PPUSH
87715: CALL_OW 110
87719: PUSH
87720: LD_INT 71
87722: EQUAL
87723: IFFALSE 87764
// begin if HasTask ( group [ i ] ) then
87725: LD_VAR 0 4
87729: PUSH
87730: LD_VAR 0 7
87734: ARRAY
87735: PPUSH
87736: CALL_OW 314
87740: IFFALSE 87746
// continue else
87742: GO 83903
87744: GO 87764
// SetTag ( group [ i ] , 0 ) ;
87746: LD_VAR 0 4
87750: PUSH
87751: LD_VAR 0 7
87755: ARRAY
87756: PPUSH
87757: LD_INT 0
87759: PPUSH
87760: CALL_OW 109
// end ; k := 8 ;
87764: LD_ADDR_VAR 0 9
87768: PUSH
87769: LD_INT 8
87771: ST_TO_ADDR
// x := 0 ;
87772: LD_ADDR_VAR 0 10
87776: PUSH
87777: LD_INT 0
87779: ST_TO_ADDR
// if tmp < k then
87780: LD_VAR 0 14
87784: PUSH
87785: LD_VAR 0 9
87789: LESS
87790: IFFALSE 87802
// k := tmp ;
87792: LD_ADDR_VAR 0 9
87796: PUSH
87797: LD_VAR 0 14
87801: ST_TO_ADDR
// for j = 1 to k do
87802: LD_ADDR_VAR 0 8
87806: PUSH
87807: DOUBLE
87808: LD_INT 1
87810: DEC
87811: ST_TO_ADDR
87812: LD_VAR 0 9
87816: PUSH
87817: FOR_TO
87818: IFFALSE 87916
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87820: LD_VAR 0 14
87824: PUSH
87825: LD_VAR 0 8
87829: ARRAY
87830: PPUSH
87831: CALL_OW 247
87835: PUSH
87836: LD_INT 1
87838: EQUAL
87839: PUSH
87840: LD_VAR 0 14
87844: PUSH
87845: LD_VAR 0 8
87849: ARRAY
87850: PPUSH
87851: CALL_OW 256
87855: PUSH
87856: LD_INT 250
87858: LESS
87859: PUSH
87860: LD_VAR 0 20
87864: AND
87865: PUSH
87866: LD_VAR 0 20
87870: NOT
87871: PUSH
87872: LD_VAR 0 14
87876: PUSH
87877: LD_VAR 0 8
87881: ARRAY
87882: PPUSH
87883: CALL_OW 256
87887: PUSH
87888: LD_INT 250
87890: GREATEREQUAL
87891: AND
87892: OR
87893: AND
87894: IFFALSE 87914
// begin x := tmp [ j ] ;
87896: LD_ADDR_VAR 0 10
87900: PUSH
87901: LD_VAR 0 14
87905: PUSH
87906: LD_VAR 0 8
87910: ARRAY
87911: ST_TO_ADDR
// break ;
87912: GO 87916
// end ;
87914: GO 87817
87916: POP
87917: POP
// if x then
87918: LD_VAR 0 10
87922: IFFALSE 87946
// ComAttackUnit ( group [ i ] , x ) else
87924: LD_VAR 0 4
87928: PUSH
87929: LD_VAR 0 7
87933: ARRAY
87934: PPUSH
87935: LD_VAR 0 10
87939: PPUSH
87940: CALL_OW 115
87944: GO 87970
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87946: LD_VAR 0 4
87950: PUSH
87951: LD_VAR 0 7
87955: ARRAY
87956: PPUSH
87957: LD_VAR 0 14
87961: PUSH
87962: LD_INT 1
87964: ARRAY
87965: PPUSH
87966: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87970: LD_VAR 0 4
87974: PUSH
87975: LD_VAR 0 7
87979: ARRAY
87980: PPUSH
87981: CALL_OW 314
87985: NOT
87986: IFFALSE 88024
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87988: LD_VAR 0 4
87992: PUSH
87993: LD_VAR 0 7
87997: ARRAY
87998: PPUSH
87999: LD_VAR 0 14
88003: PPUSH
88004: LD_VAR 0 4
88008: PUSH
88009: LD_VAR 0 7
88013: ARRAY
88014: PPUSH
88015: CALL_OW 74
88019: PPUSH
88020: CALL_OW 115
// end ; end ; end ;
88024: GO 83903
88026: POP
88027: POP
// wait ( 0 0$2 ) ;
88028: LD_INT 70
88030: PPUSH
88031: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
88035: LD_VAR 0 4
88039: NOT
88040: PUSH
88041: LD_VAR 0 4
88045: PUSH
88046: EMPTY
88047: EQUAL
88048: OR
88049: PUSH
88050: LD_INT 81
88052: PUSH
88053: LD_VAR 0 35
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: PPUSH
88062: CALL_OW 69
88066: NOT
88067: OR
88068: IFFALSE 83888
// end ;
88070: LD_VAR 0 2
88074: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
88075: LD_INT 0
88077: PPUSH
88078: PPUSH
88079: PPUSH
88080: PPUSH
88081: PPUSH
88082: PPUSH
// if not base or not mc_bases [ base ] or not solds then
88083: LD_VAR 0 1
88087: NOT
88088: PUSH
88089: LD_EXP 23
88093: PUSH
88094: LD_VAR 0 1
88098: ARRAY
88099: NOT
88100: OR
88101: PUSH
88102: LD_VAR 0 2
88106: NOT
88107: OR
88108: IFFALSE 88112
// exit ;
88110: GO 88666
// side := mc_sides [ base ] ;
88112: LD_ADDR_VAR 0 6
88116: PUSH
88117: LD_EXP 49
88121: PUSH
88122: LD_VAR 0 1
88126: ARRAY
88127: ST_TO_ADDR
// if not side then
88128: LD_VAR 0 6
88132: NOT
88133: IFFALSE 88137
// exit ;
88135: GO 88666
// for i in solds do
88137: LD_ADDR_VAR 0 7
88141: PUSH
88142: LD_VAR 0 2
88146: PUSH
88147: FOR_IN
88148: IFFALSE 88209
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
88150: LD_VAR 0 7
88154: PPUSH
88155: CALL_OW 310
88159: PPUSH
88160: CALL_OW 266
88164: PUSH
88165: LD_INT 32
88167: PUSH
88168: LD_INT 31
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: IN
88175: IFFALSE 88195
// solds := solds diff i else
88177: LD_ADDR_VAR 0 2
88181: PUSH
88182: LD_VAR 0 2
88186: PUSH
88187: LD_VAR 0 7
88191: DIFF
88192: ST_TO_ADDR
88193: GO 88207
// SetTag ( i , 18 ) ;
88195: LD_VAR 0 7
88199: PPUSH
88200: LD_INT 18
88202: PPUSH
88203: CALL_OW 109
88207: GO 88147
88209: POP
88210: POP
// if not solds then
88211: LD_VAR 0 2
88215: NOT
88216: IFFALSE 88220
// exit ;
88218: GO 88666
// repeat wait ( 0 0$2 ) ;
88220: LD_INT 70
88222: PPUSH
88223: CALL_OW 67
// enemy := mc_scan [ base ] ;
88227: LD_ADDR_VAR 0 4
88231: PUSH
88232: LD_EXP 46
88236: PUSH
88237: LD_VAR 0 1
88241: ARRAY
88242: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88243: LD_EXP 23
88247: PUSH
88248: LD_VAR 0 1
88252: ARRAY
88253: NOT
88254: PUSH
88255: LD_EXP 23
88259: PUSH
88260: LD_VAR 0 1
88264: ARRAY
88265: PUSH
88266: EMPTY
88267: EQUAL
88268: OR
88269: IFFALSE 88306
// begin for i in solds do
88271: LD_ADDR_VAR 0 7
88275: PUSH
88276: LD_VAR 0 2
88280: PUSH
88281: FOR_IN
88282: IFFALSE 88295
// ComStop ( i ) ;
88284: LD_VAR 0 7
88288: PPUSH
88289: CALL_OW 141
88293: GO 88281
88295: POP
88296: POP
// solds := [ ] ;
88297: LD_ADDR_VAR 0 2
88301: PUSH
88302: EMPTY
88303: ST_TO_ADDR
// exit ;
88304: GO 88666
// end ; for i in solds do
88306: LD_ADDR_VAR 0 7
88310: PUSH
88311: LD_VAR 0 2
88315: PUSH
88316: FOR_IN
88317: IFFALSE 88638
// begin if IsInUnit ( i ) then
88319: LD_VAR 0 7
88323: PPUSH
88324: CALL_OW 310
88328: IFFALSE 88339
// ComExitBuilding ( i ) ;
88330: LD_VAR 0 7
88334: PPUSH
88335: CALL_OW 122
// if GetLives ( i ) > 500 then
88339: LD_VAR 0 7
88343: PPUSH
88344: CALL_OW 256
88348: PUSH
88349: LD_INT 500
88351: GREATER
88352: IFFALSE 88405
// begin e := NearestUnitToUnit ( enemy , i ) ;
88354: LD_ADDR_VAR 0 5
88358: PUSH
88359: LD_VAR 0 4
88363: PPUSH
88364: LD_VAR 0 7
88368: PPUSH
88369: CALL_OW 74
88373: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
88374: LD_VAR 0 7
88378: PPUSH
88379: LD_VAR 0 5
88383: PPUSH
88384: CALL_OW 250
88388: PPUSH
88389: LD_VAR 0 5
88393: PPUSH
88394: CALL_OW 251
88398: PPUSH
88399: CALL_OW 114
// end else
88403: GO 88636
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
88405: LD_VAR 0 7
88409: PPUSH
88410: LD_EXP 23
88414: PUSH
88415: LD_VAR 0 1
88419: ARRAY
88420: PPUSH
88421: LD_INT 2
88423: PUSH
88424: LD_INT 30
88426: PUSH
88427: LD_INT 0
88429: PUSH
88430: EMPTY
88431: LIST
88432: LIST
88433: PUSH
88434: LD_INT 30
88436: PUSH
88437: LD_INT 1
88439: PUSH
88440: EMPTY
88441: LIST
88442: LIST
88443: PUSH
88444: LD_INT 30
88446: PUSH
88447: LD_INT 6
88449: PUSH
88450: EMPTY
88451: LIST
88452: LIST
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: PPUSH
88460: CALL_OW 72
88464: PPUSH
88465: LD_VAR 0 7
88469: PPUSH
88470: CALL_OW 74
88474: PPUSH
88475: CALL_OW 296
88479: PUSH
88480: LD_INT 10
88482: GREATER
88483: IFFALSE 88636
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
88485: LD_ADDR_VAR 0 8
88489: PUSH
88490: LD_EXP 23
88494: PUSH
88495: LD_VAR 0 1
88499: ARRAY
88500: PPUSH
88501: LD_INT 2
88503: PUSH
88504: LD_INT 30
88506: PUSH
88507: LD_INT 0
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: PUSH
88514: LD_INT 30
88516: PUSH
88517: LD_INT 1
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PUSH
88524: LD_INT 30
88526: PUSH
88527: LD_INT 6
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: PUSH
88534: EMPTY
88535: LIST
88536: LIST
88537: LIST
88538: LIST
88539: PPUSH
88540: CALL_OW 72
88544: PPUSH
88545: LD_VAR 0 7
88549: PPUSH
88550: CALL_OW 74
88554: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
88555: LD_VAR 0 7
88559: PPUSH
88560: LD_VAR 0 8
88564: PPUSH
88565: CALL_OW 250
88569: PPUSH
88570: LD_INT 3
88572: PPUSH
88573: LD_INT 5
88575: PPUSH
88576: CALL_OW 272
88580: PPUSH
88581: LD_VAR 0 8
88585: PPUSH
88586: CALL_OW 251
88590: PPUSH
88591: LD_INT 3
88593: PPUSH
88594: LD_INT 5
88596: PPUSH
88597: CALL_OW 273
88601: PPUSH
88602: CALL_OW 111
// SetTag ( i , 0 ) ;
88606: LD_VAR 0 7
88610: PPUSH
88611: LD_INT 0
88613: PPUSH
88614: CALL_OW 109
// solds := solds diff i ;
88618: LD_ADDR_VAR 0 2
88622: PUSH
88623: LD_VAR 0 2
88627: PUSH
88628: LD_VAR 0 7
88632: DIFF
88633: ST_TO_ADDR
// continue ;
88634: GO 88316
// end ; end ;
88636: GO 88316
88638: POP
88639: POP
// until not solds or not enemy ;
88640: LD_VAR 0 2
88644: NOT
88645: PUSH
88646: LD_VAR 0 4
88650: NOT
88651: OR
88652: IFFALSE 88220
// MC_Reset ( base , 18 ) ;
88654: LD_VAR 0 1
88658: PPUSH
88659: LD_INT 18
88661: PPUSH
88662: CALL 56827 0 2
// end ;
88666: LD_VAR 0 3
88670: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
88671: LD_INT 0
88673: PPUSH
88674: PPUSH
88675: PPUSH
88676: PPUSH
88677: PPUSH
88678: PPUSH
88679: PPUSH
88680: PPUSH
88681: PPUSH
88682: PPUSH
88683: PPUSH
88684: PPUSH
88685: PPUSH
88686: PPUSH
88687: PPUSH
88688: PPUSH
88689: PPUSH
88690: PPUSH
88691: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88692: LD_ADDR_VAR 0 12
88696: PUSH
88697: LD_EXP 23
88701: PUSH
88702: LD_VAR 0 1
88706: ARRAY
88707: PPUSH
88708: LD_INT 25
88710: PUSH
88711: LD_INT 3
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: PPUSH
88718: CALL_OW 72
88722: ST_TO_ADDR
// if mc_remote_driver [ base ] then
88723: LD_EXP 63
88727: PUSH
88728: LD_VAR 0 1
88732: ARRAY
88733: IFFALSE 88757
// mechs := mechs diff mc_remote_driver [ base ] ;
88735: LD_ADDR_VAR 0 12
88739: PUSH
88740: LD_VAR 0 12
88744: PUSH
88745: LD_EXP 63
88749: PUSH
88750: LD_VAR 0 1
88754: ARRAY
88755: DIFF
88756: ST_TO_ADDR
// for i in mechs do
88757: LD_ADDR_VAR 0 4
88761: PUSH
88762: LD_VAR 0 12
88766: PUSH
88767: FOR_IN
88768: IFFALSE 88803
// if GetTag ( i ) > 0 then
88770: LD_VAR 0 4
88774: PPUSH
88775: CALL_OW 110
88779: PUSH
88780: LD_INT 0
88782: GREATER
88783: IFFALSE 88801
// mechs := mechs diff i ;
88785: LD_ADDR_VAR 0 12
88789: PUSH
88790: LD_VAR 0 12
88794: PUSH
88795: LD_VAR 0 4
88799: DIFF
88800: ST_TO_ADDR
88801: GO 88767
88803: POP
88804: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88805: LD_ADDR_VAR 0 8
88809: PUSH
88810: LD_EXP 23
88814: PUSH
88815: LD_VAR 0 1
88819: ARRAY
88820: PPUSH
88821: LD_INT 2
88823: PUSH
88824: LD_INT 25
88826: PUSH
88827: LD_INT 1
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: PUSH
88834: LD_INT 25
88836: PUSH
88837: LD_INT 5
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 25
88846: PUSH
88847: LD_INT 8
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 25
88856: PUSH
88857: LD_INT 9
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: LIST
88868: LIST
88869: LIST
88870: PPUSH
88871: CALL_OW 72
88875: ST_TO_ADDR
// if not defenders and not solds then
88876: LD_VAR 0 2
88880: NOT
88881: PUSH
88882: LD_VAR 0 8
88886: NOT
88887: AND
88888: IFFALSE 88892
// exit ;
88890: GO 90662
// depot_under_attack := false ;
88892: LD_ADDR_VAR 0 16
88896: PUSH
88897: LD_INT 0
88899: ST_TO_ADDR
// sold_defenders := [ ] ;
88900: LD_ADDR_VAR 0 17
88904: PUSH
88905: EMPTY
88906: ST_TO_ADDR
// if mechs then
88907: LD_VAR 0 12
88911: IFFALSE 89064
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
88913: LD_ADDR_VAR 0 4
88917: PUSH
88918: LD_VAR 0 2
88922: PPUSH
88923: LD_INT 21
88925: PUSH
88926: LD_INT 2
88928: PUSH
88929: EMPTY
88930: LIST
88931: LIST
88932: PPUSH
88933: CALL_OW 72
88937: PUSH
88938: FOR_IN
88939: IFFALSE 89062
// begin if GetTag ( i ) <> 20 then
88941: LD_VAR 0 4
88945: PPUSH
88946: CALL_OW 110
88950: PUSH
88951: LD_INT 20
88953: NONEQUAL
88954: IFFALSE 88968
// SetTag ( i , 20 ) ;
88956: LD_VAR 0 4
88960: PPUSH
88961: LD_INT 20
88963: PPUSH
88964: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88968: LD_VAR 0 4
88972: PPUSH
88973: CALL_OW 263
88977: PUSH
88978: LD_INT 1
88980: EQUAL
88981: PUSH
88982: LD_VAR 0 4
88986: PPUSH
88987: CALL_OW 311
88991: NOT
88992: AND
88993: IFFALSE 89060
// begin un := mechs [ 1 ] ;
88995: LD_ADDR_VAR 0 10
88999: PUSH
89000: LD_VAR 0 12
89004: PUSH
89005: LD_INT 1
89007: ARRAY
89008: ST_TO_ADDR
// ComExit ( un ) ;
89009: LD_VAR 0 10
89013: PPUSH
89014: CALL 48834 0 1
// AddComEnterUnit ( un , i ) ;
89018: LD_VAR 0 10
89022: PPUSH
89023: LD_VAR 0 4
89027: PPUSH
89028: CALL_OW 180
// SetTag ( un , 19 ) ;
89032: LD_VAR 0 10
89036: PPUSH
89037: LD_INT 19
89039: PPUSH
89040: CALL_OW 109
// mechs := mechs diff un ;
89044: LD_ADDR_VAR 0 12
89048: PUSH
89049: LD_VAR 0 12
89053: PUSH
89054: LD_VAR 0 10
89058: DIFF
89059: ST_TO_ADDR
// end ; end ;
89060: GO 88938
89062: POP
89063: POP
// if solds then
89064: LD_VAR 0 8
89068: IFFALSE 89127
// for i in solds do
89070: LD_ADDR_VAR 0 4
89074: PUSH
89075: LD_VAR 0 8
89079: PUSH
89080: FOR_IN
89081: IFFALSE 89125
// if not GetTag ( i ) then
89083: LD_VAR 0 4
89087: PPUSH
89088: CALL_OW 110
89092: NOT
89093: IFFALSE 89123
// begin defenders := defenders union i ;
89095: LD_ADDR_VAR 0 2
89099: PUSH
89100: LD_VAR 0 2
89104: PUSH
89105: LD_VAR 0 4
89109: UNION
89110: ST_TO_ADDR
// SetTag ( i , 18 ) ;
89111: LD_VAR 0 4
89115: PPUSH
89116: LD_INT 18
89118: PPUSH
89119: CALL_OW 109
// end ;
89123: GO 89080
89125: POP
89126: POP
// repeat wait ( 0 0$2 ) ;
89127: LD_INT 70
89129: PPUSH
89130: CALL_OW 67
// enemy := mc_scan [ base ] ;
89134: LD_ADDR_VAR 0 21
89138: PUSH
89139: LD_EXP 46
89143: PUSH
89144: LD_VAR 0 1
89148: ARRAY
89149: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
89150: LD_EXP 23
89154: PUSH
89155: LD_VAR 0 1
89159: ARRAY
89160: NOT
89161: PUSH
89162: LD_EXP 23
89166: PUSH
89167: LD_VAR 0 1
89171: ARRAY
89172: PUSH
89173: EMPTY
89174: EQUAL
89175: OR
89176: IFFALSE 89213
// begin for i in defenders do
89178: LD_ADDR_VAR 0 4
89182: PUSH
89183: LD_VAR 0 2
89187: PUSH
89188: FOR_IN
89189: IFFALSE 89202
// ComStop ( i ) ;
89191: LD_VAR 0 4
89195: PPUSH
89196: CALL_OW 141
89200: GO 89188
89202: POP
89203: POP
// defenders := [ ] ;
89204: LD_ADDR_VAR 0 2
89208: PUSH
89209: EMPTY
89210: ST_TO_ADDR
// exit ;
89211: GO 90662
// end ; for i in defenders do
89213: LD_ADDR_VAR 0 4
89217: PUSH
89218: LD_VAR 0 2
89222: PUSH
89223: FOR_IN
89224: IFFALSE 90122
// begin e := NearestUnitToUnit ( enemy , i ) ;
89226: LD_ADDR_VAR 0 13
89230: PUSH
89231: LD_VAR 0 21
89235: PPUSH
89236: LD_VAR 0 4
89240: PPUSH
89241: CALL_OW 74
89245: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89246: LD_ADDR_VAR 0 7
89250: PUSH
89251: LD_EXP 23
89255: PUSH
89256: LD_VAR 0 1
89260: ARRAY
89261: PPUSH
89262: LD_INT 2
89264: PUSH
89265: LD_INT 30
89267: PUSH
89268: LD_INT 0
89270: PUSH
89271: EMPTY
89272: LIST
89273: LIST
89274: PUSH
89275: LD_INT 30
89277: PUSH
89278: LD_INT 1
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: LIST
89289: PPUSH
89290: CALL_OW 72
89294: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
89295: LD_ADDR_VAR 0 16
89299: PUSH
89300: LD_VAR 0 7
89304: NOT
89305: PUSH
89306: LD_VAR 0 7
89310: PPUSH
89311: LD_INT 3
89313: PUSH
89314: LD_INT 24
89316: PUSH
89317: LD_INT 600
89319: PUSH
89320: EMPTY
89321: LIST
89322: LIST
89323: PUSH
89324: EMPTY
89325: LIST
89326: LIST
89327: PPUSH
89328: CALL_OW 72
89332: OR
89333: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
89334: LD_VAR 0 4
89338: PPUSH
89339: CALL_OW 247
89343: PUSH
89344: LD_INT 2
89346: DOUBLE
89347: EQUAL
89348: IFTRUE 89352
89350: GO 89748
89352: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
89353: LD_VAR 0 4
89357: PPUSH
89358: CALL_OW 256
89362: PUSH
89363: LD_INT 1000
89365: EQUAL
89366: PUSH
89367: LD_VAR 0 4
89371: PPUSH
89372: LD_VAR 0 13
89376: PPUSH
89377: CALL_OW 296
89381: PUSH
89382: LD_INT 40
89384: LESS
89385: PUSH
89386: LD_VAR 0 13
89390: PPUSH
89391: LD_EXP 48
89395: PUSH
89396: LD_VAR 0 1
89400: ARRAY
89401: PPUSH
89402: CALL_OW 308
89406: OR
89407: AND
89408: IFFALSE 89530
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
89410: LD_VAR 0 4
89414: PPUSH
89415: CALL_OW 262
89419: PUSH
89420: LD_INT 1
89422: EQUAL
89423: PUSH
89424: LD_VAR 0 4
89428: PPUSH
89429: CALL_OW 261
89433: PUSH
89434: LD_INT 30
89436: LESS
89437: AND
89438: PUSH
89439: LD_VAR 0 7
89443: AND
89444: IFFALSE 89514
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
89446: LD_VAR 0 4
89450: PPUSH
89451: LD_VAR 0 7
89455: PPUSH
89456: LD_VAR 0 4
89460: PPUSH
89461: CALL_OW 74
89465: PPUSH
89466: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
89470: LD_VAR 0 4
89474: PPUSH
89475: LD_VAR 0 7
89479: PPUSH
89480: LD_VAR 0 4
89484: PPUSH
89485: CALL_OW 74
89489: PPUSH
89490: CALL_OW 296
89494: PUSH
89495: LD_INT 6
89497: LESS
89498: IFFALSE 89512
// SetFuel ( i , 100 ) ;
89500: LD_VAR 0 4
89504: PPUSH
89505: LD_INT 100
89507: PPUSH
89508: CALL_OW 240
// end else
89512: GO 89528
// ComAttackUnit ( i , e ) ;
89514: LD_VAR 0 4
89518: PPUSH
89519: LD_VAR 0 13
89523: PPUSH
89524: CALL_OW 115
// end else
89528: GO 89631
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
89530: LD_VAR 0 13
89534: PPUSH
89535: LD_EXP 48
89539: PUSH
89540: LD_VAR 0 1
89544: ARRAY
89545: PPUSH
89546: CALL_OW 308
89550: NOT
89551: PUSH
89552: LD_VAR 0 4
89556: PPUSH
89557: LD_VAR 0 13
89561: PPUSH
89562: CALL_OW 296
89566: PUSH
89567: LD_INT 40
89569: GREATEREQUAL
89570: AND
89571: PUSH
89572: LD_VAR 0 4
89576: PPUSH
89577: CALL_OW 256
89581: PUSH
89582: LD_INT 650
89584: LESSEQUAL
89585: OR
89586: PUSH
89587: LD_VAR 0 4
89591: PPUSH
89592: LD_EXP 47
89596: PUSH
89597: LD_VAR 0 1
89601: ARRAY
89602: PPUSH
89603: CALL_OW 308
89607: NOT
89608: AND
89609: IFFALSE 89631
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89611: LD_VAR 0 4
89615: PPUSH
89616: LD_EXP 47
89620: PUSH
89621: LD_VAR 0 1
89625: ARRAY
89626: PPUSH
89627: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
89631: LD_VAR 0 4
89635: PPUSH
89636: CALL_OW 256
89640: PUSH
89641: LD_INT 1000
89643: LESS
89644: PUSH
89645: LD_VAR 0 4
89649: PPUSH
89650: CALL_OW 263
89654: PUSH
89655: LD_INT 1
89657: EQUAL
89658: AND
89659: PUSH
89660: LD_VAR 0 4
89664: PPUSH
89665: CALL_OW 311
89669: AND
89670: PUSH
89671: LD_VAR 0 4
89675: PPUSH
89676: LD_EXP 47
89680: PUSH
89681: LD_VAR 0 1
89685: ARRAY
89686: PPUSH
89687: CALL_OW 308
89691: AND
89692: IFFALSE 89746
// begin mech := IsDrivenBy ( i ) ;
89694: LD_ADDR_VAR 0 9
89698: PUSH
89699: LD_VAR 0 4
89703: PPUSH
89704: CALL_OW 311
89708: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
89709: LD_VAR 0 9
89713: PPUSH
89714: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
89718: LD_VAR 0 9
89722: PPUSH
89723: LD_VAR 0 4
89727: PPUSH
89728: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
89732: LD_VAR 0 9
89736: PPUSH
89737: LD_VAR 0 4
89741: PPUSH
89742: CALL_OW 180
// end ; end ; unit_human :
89746: GO 90093
89748: LD_INT 1
89750: DOUBLE
89751: EQUAL
89752: IFTRUE 89756
89754: GO 90092
89756: POP
// begin b := IsInUnit ( i ) ;
89757: LD_ADDR_VAR 0 18
89761: PUSH
89762: LD_VAR 0 4
89766: PPUSH
89767: CALL_OW 310
89771: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
89772: LD_ADDR_VAR 0 19
89776: PUSH
89777: LD_VAR 0 18
89781: NOT
89782: PUSH
89783: LD_VAR 0 18
89787: PPUSH
89788: CALL_OW 266
89792: PUSH
89793: LD_INT 32
89795: PUSH
89796: LD_INT 31
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: IN
89803: OR
89804: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
89805: LD_VAR 0 18
89809: PPUSH
89810: CALL_OW 266
89814: PUSH
89815: LD_INT 5
89817: EQUAL
89818: PUSH
89819: LD_VAR 0 4
89823: PPUSH
89824: CALL_OW 257
89828: PUSH
89829: LD_INT 1
89831: PUSH
89832: LD_INT 2
89834: PUSH
89835: LD_INT 3
89837: PUSH
89838: LD_INT 4
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: IN
89847: AND
89848: IFFALSE 89885
// begin class := AllowSpecClass ( i ) ;
89850: LD_ADDR_VAR 0 20
89854: PUSH
89855: LD_VAR 0 4
89859: PPUSH
89860: CALL 12901 0 1
89864: ST_TO_ADDR
// if class then
89865: LD_VAR 0 20
89869: IFFALSE 89885
// ComChangeProfession ( i , class ) ;
89871: LD_VAR 0 4
89875: PPUSH
89876: LD_VAR 0 20
89880: PPUSH
89881: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
89885: LD_VAR 0 16
89889: PUSH
89890: LD_VAR 0 2
89894: PPUSH
89895: LD_INT 21
89897: PUSH
89898: LD_INT 2
89900: PUSH
89901: EMPTY
89902: LIST
89903: LIST
89904: PPUSH
89905: CALL_OW 72
89909: PUSH
89910: LD_INT 1
89912: LESSEQUAL
89913: OR
89914: PUSH
89915: LD_VAR 0 19
89919: AND
89920: PUSH
89921: LD_VAR 0 4
89925: PUSH
89926: LD_VAR 0 17
89930: IN
89931: NOT
89932: AND
89933: IFFALSE 90026
// begin if b then
89935: LD_VAR 0 18
89939: IFFALSE 89988
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89941: LD_VAR 0 18
89945: PPUSH
89946: LD_VAR 0 21
89950: PPUSH
89951: LD_VAR 0 18
89955: PPUSH
89956: CALL_OW 74
89960: PPUSH
89961: CALL_OW 296
89965: PUSH
89966: LD_INT 10
89968: LESS
89969: PUSH
89970: LD_VAR 0 18
89974: PPUSH
89975: CALL_OW 461
89979: PUSH
89980: LD_INT 7
89982: NONEQUAL
89983: AND
89984: IFFALSE 89988
// continue ;
89986: GO 89223
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89988: LD_ADDR_VAR 0 17
89992: PUSH
89993: LD_VAR 0 17
89997: PPUSH
89998: LD_VAR 0 17
90002: PUSH
90003: LD_INT 1
90005: PLUS
90006: PPUSH
90007: LD_VAR 0 4
90011: PPUSH
90012: CALL_OW 1
90016: ST_TO_ADDR
// ComExitBuilding ( i ) ;
90017: LD_VAR 0 4
90021: PPUSH
90022: CALL_OW 122
// end ; if sold_defenders then
90026: LD_VAR 0 17
90030: IFFALSE 90090
// if i in sold_defenders then
90032: LD_VAR 0 4
90036: PUSH
90037: LD_VAR 0 17
90041: IN
90042: IFFALSE 90090
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
90044: LD_VAR 0 4
90048: PPUSH
90049: CALL_OW 314
90053: NOT
90054: PUSH
90055: LD_VAR 0 4
90059: PPUSH
90060: LD_VAR 0 13
90064: PPUSH
90065: CALL_OW 296
90069: PUSH
90070: LD_INT 30
90072: LESS
90073: AND
90074: IFFALSE 90090
// ComAttackUnit ( i , e ) ;
90076: LD_VAR 0 4
90080: PPUSH
90081: LD_VAR 0 13
90085: PPUSH
90086: CALL_OW 115
// end ; end ; end ;
90090: GO 90093
90092: POP
// if IsDead ( i ) then
90093: LD_VAR 0 4
90097: PPUSH
90098: CALL_OW 301
90102: IFFALSE 90120
// defenders := defenders diff i ;
90104: LD_ADDR_VAR 0 2
90108: PUSH
90109: LD_VAR 0 2
90113: PUSH
90114: LD_VAR 0 4
90118: DIFF
90119: ST_TO_ADDR
// end ;
90120: GO 89223
90122: POP
90123: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
90124: LD_VAR 0 21
90128: NOT
90129: PUSH
90130: LD_VAR 0 2
90134: NOT
90135: OR
90136: PUSH
90137: LD_EXP 23
90141: PUSH
90142: LD_VAR 0 1
90146: ARRAY
90147: NOT
90148: OR
90149: IFFALSE 89127
// MC_Reset ( base , 18 ) ;
90151: LD_VAR 0 1
90155: PPUSH
90156: LD_INT 18
90158: PPUSH
90159: CALL 56827 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
90163: LD_ADDR_VAR 0 2
90167: PUSH
90168: LD_VAR 0 2
90172: PUSH
90173: LD_VAR 0 2
90177: PPUSH
90178: LD_INT 2
90180: PUSH
90181: LD_INT 25
90183: PUSH
90184: LD_INT 1
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 25
90193: PUSH
90194: LD_INT 5
90196: PUSH
90197: EMPTY
90198: LIST
90199: LIST
90200: PUSH
90201: LD_INT 25
90203: PUSH
90204: LD_INT 8
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 25
90213: PUSH
90214: LD_INT 9
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: PPUSH
90228: CALL_OW 72
90232: DIFF
90233: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
90234: LD_VAR 0 21
90238: NOT
90239: PUSH
90240: LD_VAR 0 2
90244: PPUSH
90245: LD_INT 21
90247: PUSH
90248: LD_INT 2
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: PPUSH
90255: CALL_OW 72
90259: AND
90260: IFFALSE 90598
// begin tmp := FilterByTag ( defenders , 19 ) ;
90262: LD_ADDR_VAR 0 11
90266: PUSH
90267: LD_VAR 0 2
90271: PPUSH
90272: LD_INT 19
90274: PPUSH
90275: CALL 46018 0 2
90279: ST_TO_ADDR
// if tmp then
90280: LD_VAR 0 11
90284: IFFALSE 90354
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
90286: LD_ADDR_VAR 0 11
90290: PUSH
90291: LD_VAR 0 11
90295: PPUSH
90296: LD_INT 25
90298: PUSH
90299: LD_INT 3
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PPUSH
90306: CALL_OW 72
90310: ST_TO_ADDR
// if tmp then
90311: LD_VAR 0 11
90315: IFFALSE 90354
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
90317: LD_ADDR_EXP 35
90321: PUSH
90322: LD_EXP 35
90326: PPUSH
90327: LD_VAR 0 1
90331: PPUSH
90332: LD_EXP 35
90336: PUSH
90337: LD_VAR 0 1
90341: ARRAY
90342: PUSH
90343: LD_VAR 0 11
90347: UNION
90348: PPUSH
90349: CALL_OW 1
90353: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
90354: LD_VAR 0 1
90358: PPUSH
90359: LD_INT 19
90361: PPUSH
90362: CALL 56827 0 2
// repeat wait ( 0 0$1 ) ;
90366: LD_INT 35
90368: PPUSH
90369: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90373: LD_EXP 23
90377: PUSH
90378: LD_VAR 0 1
90382: ARRAY
90383: NOT
90384: PUSH
90385: LD_EXP 23
90389: PUSH
90390: LD_VAR 0 1
90394: ARRAY
90395: PUSH
90396: EMPTY
90397: EQUAL
90398: OR
90399: IFFALSE 90436
// begin for i in defenders do
90401: LD_ADDR_VAR 0 4
90405: PUSH
90406: LD_VAR 0 2
90410: PUSH
90411: FOR_IN
90412: IFFALSE 90425
// ComStop ( i ) ;
90414: LD_VAR 0 4
90418: PPUSH
90419: CALL_OW 141
90423: GO 90411
90425: POP
90426: POP
// defenders := [ ] ;
90427: LD_ADDR_VAR 0 2
90431: PUSH
90432: EMPTY
90433: ST_TO_ADDR
// exit ;
90434: GO 90662
// end ; for i in defenders do
90436: LD_ADDR_VAR 0 4
90440: PUSH
90441: LD_VAR 0 2
90445: PUSH
90446: FOR_IN
90447: IFFALSE 90536
// begin if not IsInArea ( i , mc_parking [ base ] ) then
90449: LD_VAR 0 4
90453: PPUSH
90454: LD_EXP 47
90458: PUSH
90459: LD_VAR 0 1
90463: ARRAY
90464: PPUSH
90465: CALL_OW 308
90469: NOT
90470: IFFALSE 90494
// ComMoveToArea ( i , mc_parking [ base ] ) else
90472: LD_VAR 0 4
90476: PPUSH
90477: LD_EXP 47
90481: PUSH
90482: LD_VAR 0 1
90486: ARRAY
90487: PPUSH
90488: CALL_OW 113
90492: GO 90534
// if GetControl ( i ) = control_manual then
90494: LD_VAR 0 4
90498: PPUSH
90499: CALL_OW 263
90503: PUSH
90504: LD_INT 1
90506: EQUAL
90507: IFFALSE 90534
// if IsDrivenBy ( i ) then
90509: LD_VAR 0 4
90513: PPUSH
90514: CALL_OW 311
90518: IFFALSE 90534
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
90520: LD_VAR 0 4
90524: PPUSH
90525: CALL_OW 311
90529: PPUSH
90530: CALL_OW 121
// end ;
90534: GO 90446
90536: POP
90537: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
90538: LD_VAR 0 2
90542: PPUSH
90543: LD_INT 95
90545: PUSH
90546: LD_EXP 47
90550: PUSH
90551: LD_VAR 0 1
90555: ARRAY
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: PPUSH
90561: CALL_OW 72
90565: PUSH
90566: LD_VAR 0 2
90570: EQUAL
90571: PUSH
90572: LD_EXP 46
90576: PUSH
90577: LD_VAR 0 1
90581: ARRAY
90582: OR
90583: PUSH
90584: LD_EXP 23
90588: PUSH
90589: LD_VAR 0 1
90593: ARRAY
90594: NOT
90595: OR
90596: IFFALSE 90366
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90598: LD_ADDR_EXP 45
90602: PUSH
90603: LD_EXP 45
90607: PPUSH
90608: LD_VAR 0 1
90612: PPUSH
90613: LD_VAR 0 2
90617: PPUSH
90618: LD_INT 21
90620: PUSH
90621: LD_INT 2
90623: PUSH
90624: EMPTY
90625: LIST
90626: LIST
90627: PPUSH
90628: CALL_OW 72
90632: PPUSH
90633: CALL_OW 1
90637: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
90638: LD_VAR 0 1
90642: PPUSH
90643: LD_INT 19
90645: PPUSH
90646: CALL 56827 0 2
// MC_Reset ( base , 20 ) ;
90650: LD_VAR 0 1
90654: PPUSH
90655: LD_INT 20
90657: PPUSH
90658: CALL 56827 0 2
// end ; end_of_file
90662: LD_VAR 0 3
90666: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
90667: LD_INT 0
90669: PPUSH
90670: PPUSH
90671: PPUSH
90672: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90673: LD_VAR 0 1
90677: PPUSH
90678: CALL_OW 264
90682: PUSH
90683: LD_INT 91
90685: EQUAL
90686: IFFALSE 90758
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90688: LD_INT 68
90690: PPUSH
90691: LD_VAR 0 1
90695: PPUSH
90696: CALL_OW 255
90700: PPUSH
90701: CALL_OW 321
90705: PUSH
90706: LD_INT 2
90708: EQUAL
90709: IFFALSE 90721
// eff := 70 else
90711: LD_ADDR_VAR 0 4
90715: PUSH
90716: LD_INT 70
90718: ST_TO_ADDR
90719: GO 90729
// eff := 30 ;
90721: LD_ADDR_VAR 0 4
90725: PUSH
90726: LD_INT 30
90728: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90729: LD_VAR 0 1
90733: PPUSH
90734: CALL_OW 250
90738: PPUSH
90739: LD_VAR 0 1
90743: PPUSH
90744: CALL_OW 251
90748: PPUSH
90749: LD_VAR 0 4
90753: PPUSH
90754: CALL_OW 495
// end ; end ;
90758: LD_VAR 0 2
90762: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
90763: LD_INT 0
90765: PPUSH
// end ;
90766: LD_VAR 0 4
90770: RET
// export function SOS_Command ( cmd ) ; begin
90771: LD_INT 0
90773: PPUSH
// end ;
90774: LD_VAR 0 2
90778: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
90779: LD_INT 0
90781: PPUSH
// end ;
90782: LD_VAR 0 6
90786: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
90787: LD_INT 0
90789: PPUSH
90790: PPUSH
// if not vehicle or not factory then
90791: LD_VAR 0 1
90795: NOT
90796: PUSH
90797: LD_VAR 0 2
90801: NOT
90802: OR
90803: IFFALSE 90807
// exit ;
90805: GO 91038
// if factoryWaypoints >= factory then
90807: LD_EXP 137
90811: PUSH
90812: LD_VAR 0 2
90816: GREATEREQUAL
90817: IFFALSE 91038
// if factoryWaypoints [ factory ] then
90819: LD_EXP 137
90823: PUSH
90824: LD_VAR 0 2
90828: ARRAY
90829: IFFALSE 91038
// begin if GetControl ( vehicle ) = control_manual then
90831: LD_VAR 0 1
90835: PPUSH
90836: CALL_OW 263
90840: PUSH
90841: LD_INT 1
90843: EQUAL
90844: IFFALSE 90925
// begin driver := IsDrivenBy ( vehicle ) ;
90846: LD_ADDR_VAR 0 4
90850: PUSH
90851: LD_VAR 0 1
90855: PPUSH
90856: CALL_OW 311
90860: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90861: LD_VAR 0 4
90865: PPUSH
90866: LD_EXP 137
90870: PUSH
90871: LD_VAR 0 2
90875: ARRAY
90876: PUSH
90877: LD_INT 3
90879: ARRAY
90880: PPUSH
90881: LD_EXP 137
90885: PUSH
90886: LD_VAR 0 2
90890: ARRAY
90891: PUSH
90892: LD_INT 4
90894: ARRAY
90895: PPUSH
90896: CALL_OW 171
// AddComExitVehicle ( driver ) ;
90900: LD_VAR 0 4
90904: PPUSH
90905: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
90909: LD_VAR 0 4
90913: PPUSH
90914: LD_VAR 0 2
90918: PPUSH
90919: CALL_OW 180
// end else
90923: GO 91038
// if GetControl ( vehicle ) = control_remote then
90925: LD_VAR 0 1
90929: PPUSH
90930: CALL_OW 263
90934: PUSH
90935: LD_INT 2
90937: EQUAL
90938: IFFALSE 90999
// begin wait ( 0 0$2 ) ;
90940: LD_INT 70
90942: PPUSH
90943: CALL_OW 67
// if Connect ( vehicle ) then
90947: LD_VAR 0 1
90951: PPUSH
90952: CALL 19055 0 1
90956: IFFALSE 90997
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90958: LD_VAR 0 1
90962: PPUSH
90963: LD_EXP 137
90967: PUSH
90968: LD_VAR 0 2
90972: ARRAY
90973: PUSH
90974: LD_INT 3
90976: ARRAY
90977: PPUSH
90978: LD_EXP 137
90982: PUSH
90983: LD_VAR 0 2
90987: ARRAY
90988: PUSH
90989: LD_INT 4
90991: ARRAY
90992: PPUSH
90993: CALL_OW 171
// end else
90997: GO 91038
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90999: LD_VAR 0 1
91003: PPUSH
91004: LD_EXP 137
91008: PUSH
91009: LD_VAR 0 2
91013: ARRAY
91014: PUSH
91015: LD_INT 3
91017: ARRAY
91018: PPUSH
91019: LD_EXP 137
91023: PUSH
91024: LD_VAR 0 2
91028: ARRAY
91029: PUSH
91030: LD_INT 4
91032: ARRAY
91033: PPUSH
91034: CALL_OW 171
// end ; end ;
91038: LD_VAR 0 3
91042: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
91043: LD_INT 0
91045: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
91046: LD_VAR 0 1
91050: PUSH
91051: LD_INT 250
91053: EQUAL
91054: PUSH
91055: LD_VAR 0 2
91059: PPUSH
91060: CALL_OW 264
91064: PUSH
91065: LD_INT 81
91067: EQUAL
91068: AND
91069: IFFALSE 91090
// MinerPlaceMine ( unit , x , y ) ;
91071: LD_VAR 0 2
91075: PPUSH
91076: LD_VAR 0 4
91080: PPUSH
91081: LD_VAR 0 5
91085: PPUSH
91086: CALL 93475 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
91090: LD_VAR 0 1
91094: PUSH
91095: LD_INT 251
91097: EQUAL
91098: PUSH
91099: LD_VAR 0 2
91103: PPUSH
91104: CALL_OW 264
91108: PUSH
91109: LD_INT 81
91111: EQUAL
91112: AND
91113: IFFALSE 91134
// MinerDetonateMine ( unit , x , y ) ;
91115: LD_VAR 0 2
91119: PPUSH
91120: LD_VAR 0 4
91124: PPUSH
91125: LD_VAR 0 5
91129: PPUSH
91130: CALL 93750 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
91134: LD_VAR 0 1
91138: PUSH
91139: LD_INT 252
91141: EQUAL
91142: PUSH
91143: LD_VAR 0 2
91147: PPUSH
91148: CALL_OW 264
91152: PUSH
91153: LD_INT 81
91155: EQUAL
91156: AND
91157: IFFALSE 91178
// MinerCreateMinefield ( unit , x , y ) ;
91159: LD_VAR 0 2
91163: PPUSH
91164: LD_VAR 0 4
91168: PPUSH
91169: LD_VAR 0 5
91173: PPUSH
91174: CALL 94167 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
91178: LD_VAR 0 1
91182: PUSH
91183: LD_INT 253
91185: EQUAL
91186: PUSH
91187: LD_VAR 0 2
91191: PPUSH
91192: CALL_OW 257
91196: PUSH
91197: LD_INT 5
91199: EQUAL
91200: AND
91201: IFFALSE 91222
// ComBinocular ( unit , x , y ) ;
91203: LD_VAR 0 2
91207: PPUSH
91208: LD_VAR 0 4
91212: PPUSH
91213: LD_VAR 0 5
91217: PPUSH
91218: CALL 94536 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
91222: LD_VAR 0 1
91226: PUSH
91227: LD_INT 254
91229: EQUAL
91230: PUSH
91231: LD_VAR 0 2
91235: PPUSH
91236: CALL_OW 264
91240: PUSH
91241: LD_INT 99
91243: EQUAL
91244: AND
91245: PUSH
91246: LD_VAR 0 3
91250: PPUSH
91251: CALL_OW 263
91255: PUSH
91256: LD_INT 3
91258: EQUAL
91259: AND
91260: IFFALSE 91276
// HackDestroyVehicle ( unit , selectedUnit ) ;
91262: LD_VAR 0 2
91266: PPUSH
91267: LD_VAR 0 3
91271: PPUSH
91272: CALL 92839 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
91276: LD_VAR 0 1
91280: PUSH
91281: LD_INT 255
91283: EQUAL
91284: PUSH
91285: LD_VAR 0 2
91289: PPUSH
91290: CALL_OW 264
91294: PUSH
91295: LD_INT 14
91297: PUSH
91298: LD_INT 53
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: IN
91305: AND
91306: PUSH
91307: LD_VAR 0 4
91311: PPUSH
91312: LD_VAR 0 5
91316: PPUSH
91317: CALL_OW 488
91321: AND
91322: IFFALSE 91346
// CutTreeXYR ( unit , x , y , 12 ) ;
91324: LD_VAR 0 2
91328: PPUSH
91329: LD_VAR 0 4
91333: PPUSH
91334: LD_VAR 0 5
91338: PPUSH
91339: LD_INT 12
91341: PPUSH
91342: CALL 91409 0 4
// if cmd = 256 then
91346: LD_VAR 0 1
91350: PUSH
91351: LD_INT 256
91353: EQUAL
91354: IFFALSE 91375
// SetFactoryWaypoint ( unit , x , y ) ;
91356: LD_VAR 0 2
91360: PPUSH
91361: LD_VAR 0 4
91365: PPUSH
91366: LD_VAR 0 5
91370: PPUSH
91371: CALL 109610 0 3
// if cmd = 257 then
91375: LD_VAR 0 1
91379: PUSH
91380: LD_INT 257
91382: EQUAL
91383: IFFALSE 91404
// SetWarehouseGatheringPoint ( unit , x , y ) ;
91385: LD_VAR 0 2
91389: PPUSH
91390: LD_VAR 0 4
91394: PPUSH
91395: LD_VAR 0 5
91399: PPUSH
91400: CALL 109972 0 3
// end ;
91404: LD_VAR 0 6
91408: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91409: LD_INT 0
91411: PPUSH
91412: PPUSH
91413: PPUSH
91414: PPUSH
91415: PPUSH
91416: PPUSH
91417: PPUSH
91418: PPUSH
91419: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
91420: LD_VAR 0 1
91424: NOT
91425: PUSH
91426: LD_VAR 0 2
91430: PPUSH
91431: LD_VAR 0 3
91435: PPUSH
91436: CALL_OW 488
91440: NOT
91441: OR
91442: PUSH
91443: LD_VAR 0 4
91447: NOT
91448: OR
91449: IFFALSE 91453
// exit ;
91451: GO 91793
// list := [ ] ;
91453: LD_ADDR_VAR 0 13
91457: PUSH
91458: EMPTY
91459: ST_TO_ADDR
// if x - r < 0 then
91460: LD_VAR 0 2
91464: PUSH
91465: LD_VAR 0 4
91469: MINUS
91470: PUSH
91471: LD_INT 0
91473: LESS
91474: IFFALSE 91486
// min_x := 0 else
91476: LD_ADDR_VAR 0 7
91480: PUSH
91481: LD_INT 0
91483: ST_TO_ADDR
91484: GO 91502
// min_x := x - r ;
91486: LD_ADDR_VAR 0 7
91490: PUSH
91491: LD_VAR 0 2
91495: PUSH
91496: LD_VAR 0 4
91500: MINUS
91501: ST_TO_ADDR
// if y - r < 0 then
91502: LD_VAR 0 3
91506: PUSH
91507: LD_VAR 0 4
91511: MINUS
91512: PUSH
91513: LD_INT 0
91515: LESS
91516: IFFALSE 91528
// min_y := 0 else
91518: LD_ADDR_VAR 0 8
91522: PUSH
91523: LD_INT 0
91525: ST_TO_ADDR
91526: GO 91544
// min_y := y - r ;
91528: LD_ADDR_VAR 0 8
91532: PUSH
91533: LD_VAR 0 3
91537: PUSH
91538: LD_VAR 0 4
91542: MINUS
91543: ST_TO_ADDR
// max_x := x + r ;
91544: LD_ADDR_VAR 0 9
91548: PUSH
91549: LD_VAR 0 2
91553: PUSH
91554: LD_VAR 0 4
91558: PLUS
91559: ST_TO_ADDR
// max_y := y + r ;
91560: LD_ADDR_VAR 0 10
91564: PUSH
91565: LD_VAR 0 3
91569: PUSH
91570: LD_VAR 0 4
91574: PLUS
91575: ST_TO_ADDR
// for _x = min_x to max_x do
91576: LD_ADDR_VAR 0 11
91580: PUSH
91581: DOUBLE
91582: LD_VAR 0 7
91586: DEC
91587: ST_TO_ADDR
91588: LD_VAR 0 9
91592: PUSH
91593: FOR_TO
91594: IFFALSE 91711
// for _y = min_y to max_y do
91596: LD_ADDR_VAR 0 12
91600: PUSH
91601: DOUBLE
91602: LD_VAR 0 8
91606: DEC
91607: ST_TO_ADDR
91608: LD_VAR 0 10
91612: PUSH
91613: FOR_TO
91614: IFFALSE 91707
// begin if not ValidHex ( _x , _y ) then
91616: LD_VAR 0 11
91620: PPUSH
91621: LD_VAR 0 12
91625: PPUSH
91626: CALL_OW 488
91630: NOT
91631: IFFALSE 91635
// continue ;
91633: GO 91613
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91635: LD_VAR 0 11
91639: PPUSH
91640: LD_VAR 0 12
91644: PPUSH
91645: CALL_OW 351
91649: PUSH
91650: LD_VAR 0 11
91654: PPUSH
91655: LD_VAR 0 12
91659: PPUSH
91660: CALL_OW 554
91664: AND
91665: IFFALSE 91705
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91667: LD_ADDR_VAR 0 13
91671: PUSH
91672: LD_VAR 0 13
91676: PPUSH
91677: LD_VAR 0 13
91681: PUSH
91682: LD_INT 1
91684: PLUS
91685: PPUSH
91686: LD_VAR 0 11
91690: PUSH
91691: LD_VAR 0 12
91695: PUSH
91696: EMPTY
91697: LIST
91698: LIST
91699: PPUSH
91700: CALL_OW 2
91704: ST_TO_ADDR
// end ;
91705: GO 91613
91707: POP
91708: POP
91709: GO 91593
91711: POP
91712: POP
// if not list then
91713: LD_VAR 0 13
91717: NOT
91718: IFFALSE 91722
// exit ;
91720: GO 91793
// for i in list do
91722: LD_ADDR_VAR 0 6
91726: PUSH
91727: LD_VAR 0 13
91731: PUSH
91732: FOR_IN
91733: IFFALSE 91791
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91735: LD_VAR 0 1
91739: PPUSH
91740: LD_STRING M
91742: PUSH
91743: LD_VAR 0 6
91747: PUSH
91748: LD_INT 1
91750: ARRAY
91751: PUSH
91752: LD_VAR 0 6
91756: PUSH
91757: LD_INT 2
91759: ARRAY
91760: PUSH
91761: LD_INT 0
91763: PUSH
91764: LD_INT 0
91766: PUSH
91767: LD_INT 0
91769: PUSH
91770: LD_INT 0
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: PUSH
91782: EMPTY
91783: LIST
91784: PPUSH
91785: CALL_OW 447
91789: GO 91732
91791: POP
91792: POP
// end ;
91793: LD_VAR 0 5
91797: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91798: LD_EXP 68
91802: NOT
91803: IFFALSE 91853
91805: GO 91807
91807: DISABLE
// begin initHack := true ;
91808: LD_ADDR_EXP 68
91812: PUSH
91813: LD_INT 1
91815: ST_TO_ADDR
// hackTanks := [ ] ;
91816: LD_ADDR_EXP 69
91820: PUSH
91821: EMPTY
91822: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91823: LD_ADDR_EXP 70
91827: PUSH
91828: EMPTY
91829: ST_TO_ADDR
// hackLimit := 3 ;
91830: LD_ADDR_EXP 71
91834: PUSH
91835: LD_INT 3
91837: ST_TO_ADDR
// hackDist := 12 ;
91838: LD_ADDR_EXP 72
91842: PUSH
91843: LD_INT 12
91845: ST_TO_ADDR
// hackCounter := [ ] ;
91846: LD_ADDR_EXP 73
91850: PUSH
91851: EMPTY
91852: ST_TO_ADDR
// end ;
91853: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91854: LD_EXP 68
91858: PUSH
91859: LD_INT 34
91861: PUSH
91862: LD_INT 99
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: PPUSH
91869: CALL_OW 69
91873: AND
91874: IFFALSE 92127
91876: GO 91878
91878: DISABLE
91879: LD_INT 0
91881: PPUSH
91882: PPUSH
// begin enable ;
91883: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91884: LD_ADDR_VAR 0 1
91888: PUSH
91889: LD_INT 34
91891: PUSH
91892: LD_INT 99
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: PPUSH
91899: CALL_OW 69
91903: PUSH
91904: FOR_IN
91905: IFFALSE 92125
// begin if not i in hackTanks then
91907: LD_VAR 0 1
91911: PUSH
91912: LD_EXP 69
91916: IN
91917: NOT
91918: IFFALSE 92001
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91920: LD_ADDR_EXP 69
91924: PUSH
91925: LD_EXP 69
91929: PPUSH
91930: LD_EXP 69
91934: PUSH
91935: LD_INT 1
91937: PLUS
91938: PPUSH
91939: LD_VAR 0 1
91943: PPUSH
91944: CALL_OW 1
91948: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91949: LD_ADDR_EXP 70
91953: PUSH
91954: LD_EXP 70
91958: PPUSH
91959: LD_EXP 70
91963: PUSH
91964: LD_INT 1
91966: PLUS
91967: PPUSH
91968: EMPTY
91969: PPUSH
91970: CALL_OW 1
91974: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91975: LD_ADDR_EXP 73
91979: PUSH
91980: LD_EXP 73
91984: PPUSH
91985: LD_EXP 73
91989: PUSH
91990: LD_INT 1
91992: PLUS
91993: PPUSH
91994: EMPTY
91995: PPUSH
91996: CALL_OW 1
92000: ST_TO_ADDR
// end ; if not IsOk ( i ) then
92001: LD_VAR 0 1
92005: PPUSH
92006: CALL_OW 302
92010: NOT
92011: IFFALSE 92024
// begin HackUnlinkAll ( i ) ;
92013: LD_VAR 0 1
92017: PPUSH
92018: CALL 92130 0 1
// continue ;
92022: GO 91904
// end ; HackCheckCapturedStatus ( i ) ;
92024: LD_VAR 0 1
92028: PPUSH
92029: CALL 92573 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
92033: LD_ADDR_VAR 0 2
92037: PUSH
92038: LD_INT 81
92040: PUSH
92041: LD_VAR 0 1
92045: PPUSH
92046: CALL_OW 255
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 33
92057: PUSH
92058: LD_INT 3
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: LD_INT 91
92067: PUSH
92068: LD_VAR 0 1
92072: PUSH
92073: LD_EXP 72
92077: PUSH
92078: EMPTY
92079: LIST
92080: LIST
92081: LIST
92082: PUSH
92083: LD_INT 50
92085: PUSH
92086: EMPTY
92087: LIST
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: PPUSH
92095: CALL_OW 69
92099: ST_TO_ADDR
// if not tmp then
92100: LD_VAR 0 2
92104: NOT
92105: IFFALSE 92109
// continue ;
92107: GO 91904
// HackLink ( i , tmp ) ;
92109: LD_VAR 0 1
92113: PPUSH
92114: LD_VAR 0 2
92118: PPUSH
92119: CALL 92266 0 2
// end ;
92123: GO 91904
92125: POP
92126: POP
// end ;
92127: PPOPN 2
92129: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
92130: LD_INT 0
92132: PPUSH
92133: PPUSH
92134: PPUSH
// if not hack in hackTanks then
92135: LD_VAR 0 1
92139: PUSH
92140: LD_EXP 69
92144: IN
92145: NOT
92146: IFFALSE 92150
// exit ;
92148: GO 92261
// index := GetElementIndex ( hackTanks , hack ) ;
92150: LD_ADDR_VAR 0 4
92154: PUSH
92155: LD_EXP 69
92159: PPUSH
92160: LD_VAR 0 1
92164: PPUSH
92165: CALL 15862 0 2
92169: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
92170: LD_EXP 70
92174: PUSH
92175: LD_VAR 0 4
92179: ARRAY
92180: IFFALSE 92261
// begin for i in hackTanksCaptured [ index ] do
92182: LD_ADDR_VAR 0 3
92186: PUSH
92187: LD_EXP 70
92191: PUSH
92192: LD_VAR 0 4
92196: ARRAY
92197: PUSH
92198: FOR_IN
92199: IFFALSE 92225
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
92201: LD_VAR 0 3
92205: PUSH
92206: LD_INT 1
92208: ARRAY
92209: PPUSH
92210: LD_VAR 0 3
92214: PUSH
92215: LD_INT 2
92217: ARRAY
92218: PPUSH
92219: CALL_OW 235
92223: GO 92198
92225: POP
92226: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
92227: LD_ADDR_EXP 70
92231: PUSH
92232: LD_EXP 70
92236: PPUSH
92237: LD_VAR 0 4
92241: PPUSH
92242: EMPTY
92243: PPUSH
92244: CALL_OW 1
92248: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
92249: LD_VAR 0 1
92253: PPUSH
92254: LD_INT 0
92256: PPUSH
92257: CALL_OW 505
// end ; end ;
92261: LD_VAR 0 2
92265: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
92266: LD_INT 0
92268: PPUSH
92269: PPUSH
92270: PPUSH
// if not hack in hackTanks or not vehicles then
92271: LD_VAR 0 1
92275: PUSH
92276: LD_EXP 69
92280: IN
92281: NOT
92282: PUSH
92283: LD_VAR 0 2
92287: NOT
92288: OR
92289: IFFALSE 92293
// exit ;
92291: GO 92568
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
92293: LD_ADDR_VAR 0 2
92297: PUSH
92298: LD_VAR 0 1
92302: PPUSH
92303: LD_VAR 0 2
92307: PPUSH
92308: LD_INT 1
92310: PPUSH
92311: LD_INT 1
92313: PPUSH
92314: CALL 16512 0 4
92318: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
92319: LD_ADDR_VAR 0 5
92323: PUSH
92324: LD_EXP 69
92328: PPUSH
92329: LD_VAR 0 1
92333: PPUSH
92334: CALL 15862 0 2
92338: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
92339: LD_EXP 70
92343: PUSH
92344: LD_VAR 0 5
92348: ARRAY
92349: PUSH
92350: LD_EXP 71
92354: LESS
92355: IFFALSE 92544
// begin for i := 1 to vehicles do
92357: LD_ADDR_VAR 0 4
92361: PUSH
92362: DOUBLE
92363: LD_INT 1
92365: DEC
92366: ST_TO_ADDR
92367: LD_VAR 0 2
92371: PUSH
92372: FOR_TO
92373: IFFALSE 92542
// begin if hackTanksCaptured [ index ] = hackLimit then
92375: LD_EXP 70
92379: PUSH
92380: LD_VAR 0 5
92384: ARRAY
92385: PUSH
92386: LD_EXP 71
92390: EQUAL
92391: IFFALSE 92395
// break ;
92393: GO 92542
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
92395: LD_ADDR_EXP 73
92399: PUSH
92400: LD_EXP 73
92404: PPUSH
92405: LD_VAR 0 5
92409: PPUSH
92410: LD_EXP 73
92414: PUSH
92415: LD_VAR 0 5
92419: ARRAY
92420: PUSH
92421: LD_INT 1
92423: PLUS
92424: PPUSH
92425: CALL_OW 1
92429: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
92430: LD_ADDR_EXP 70
92434: PUSH
92435: LD_EXP 70
92439: PPUSH
92440: LD_VAR 0 5
92444: PUSH
92445: LD_EXP 70
92449: PUSH
92450: LD_VAR 0 5
92454: ARRAY
92455: PUSH
92456: LD_INT 1
92458: PLUS
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PPUSH
92464: LD_VAR 0 2
92468: PUSH
92469: LD_VAR 0 4
92473: ARRAY
92474: PUSH
92475: LD_VAR 0 2
92479: PUSH
92480: LD_VAR 0 4
92484: ARRAY
92485: PPUSH
92486: CALL_OW 255
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: PPUSH
92495: CALL 16077 0 3
92499: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
92500: LD_VAR 0 2
92504: PUSH
92505: LD_VAR 0 4
92509: ARRAY
92510: PPUSH
92511: LD_VAR 0 1
92515: PPUSH
92516: CALL_OW 255
92520: PPUSH
92521: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
92525: LD_VAR 0 2
92529: PUSH
92530: LD_VAR 0 4
92534: ARRAY
92535: PPUSH
92536: CALL_OW 141
// end ;
92540: GO 92372
92542: POP
92543: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92544: LD_VAR 0 1
92548: PPUSH
92549: LD_EXP 70
92553: PUSH
92554: LD_VAR 0 5
92558: ARRAY
92559: PUSH
92560: LD_INT 0
92562: PLUS
92563: PPUSH
92564: CALL_OW 505
// end ;
92568: LD_VAR 0 3
92572: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92573: LD_INT 0
92575: PPUSH
92576: PPUSH
92577: PPUSH
92578: PPUSH
// if not hack in hackTanks then
92579: LD_VAR 0 1
92583: PUSH
92584: LD_EXP 69
92588: IN
92589: NOT
92590: IFFALSE 92594
// exit ;
92592: GO 92834
// index := GetElementIndex ( hackTanks , hack ) ;
92594: LD_ADDR_VAR 0 4
92598: PUSH
92599: LD_EXP 69
92603: PPUSH
92604: LD_VAR 0 1
92608: PPUSH
92609: CALL 15862 0 2
92613: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92614: LD_ADDR_VAR 0 3
92618: PUSH
92619: DOUBLE
92620: LD_EXP 70
92624: PUSH
92625: LD_VAR 0 4
92629: ARRAY
92630: INC
92631: ST_TO_ADDR
92632: LD_INT 1
92634: PUSH
92635: FOR_DOWNTO
92636: IFFALSE 92808
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92638: LD_ADDR_VAR 0 5
92642: PUSH
92643: LD_EXP 70
92647: PUSH
92648: LD_VAR 0 4
92652: ARRAY
92653: PUSH
92654: LD_VAR 0 3
92658: ARRAY
92659: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92660: LD_VAR 0 5
92664: PUSH
92665: LD_INT 1
92667: ARRAY
92668: PPUSH
92669: CALL_OW 302
92673: NOT
92674: PUSH
92675: LD_VAR 0 5
92679: PUSH
92680: LD_INT 1
92682: ARRAY
92683: PPUSH
92684: CALL_OW 255
92688: PUSH
92689: LD_VAR 0 1
92693: PPUSH
92694: CALL_OW 255
92698: NONEQUAL
92699: OR
92700: IFFALSE 92806
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92702: LD_VAR 0 5
92706: PUSH
92707: LD_INT 1
92709: ARRAY
92710: PPUSH
92711: CALL_OW 305
92715: PUSH
92716: LD_VAR 0 5
92720: PUSH
92721: LD_INT 1
92723: ARRAY
92724: PPUSH
92725: CALL_OW 255
92729: PUSH
92730: LD_VAR 0 1
92734: PPUSH
92735: CALL_OW 255
92739: EQUAL
92740: AND
92741: IFFALSE 92765
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92743: LD_VAR 0 5
92747: PUSH
92748: LD_INT 1
92750: ARRAY
92751: PPUSH
92752: LD_VAR 0 5
92756: PUSH
92757: LD_INT 2
92759: ARRAY
92760: PPUSH
92761: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92765: LD_ADDR_EXP 70
92769: PUSH
92770: LD_EXP 70
92774: PPUSH
92775: LD_VAR 0 4
92779: PPUSH
92780: LD_EXP 70
92784: PUSH
92785: LD_VAR 0 4
92789: ARRAY
92790: PPUSH
92791: LD_VAR 0 3
92795: PPUSH
92796: CALL_OW 3
92800: PPUSH
92801: CALL_OW 1
92805: ST_TO_ADDR
// end ; end ;
92806: GO 92635
92808: POP
92809: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92810: LD_VAR 0 1
92814: PPUSH
92815: LD_EXP 70
92819: PUSH
92820: LD_VAR 0 4
92824: ARRAY
92825: PUSH
92826: LD_INT 0
92828: PLUS
92829: PPUSH
92830: CALL_OW 505
// end ;
92834: LD_VAR 0 2
92838: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92839: LD_INT 0
92841: PPUSH
92842: PPUSH
92843: PPUSH
92844: PPUSH
// if not hack in hackTanks then
92845: LD_VAR 0 1
92849: PUSH
92850: LD_EXP 69
92854: IN
92855: NOT
92856: IFFALSE 92860
// exit ;
92858: GO 92945
// index := GetElementIndex ( hackTanks , hack ) ;
92860: LD_ADDR_VAR 0 5
92864: PUSH
92865: LD_EXP 69
92869: PPUSH
92870: LD_VAR 0 1
92874: PPUSH
92875: CALL 15862 0 2
92879: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92880: LD_ADDR_VAR 0 4
92884: PUSH
92885: DOUBLE
92886: LD_INT 1
92888: DEC
92889: ST_TO_ADDR
92890: LD_EXP 70
92894: PUSH
92895: LD_VAR 0 5
92899: ARRAY
92900: PUSH
92901: FOR_TO
92902: IFFALSE 92943
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92904: LD_EXP 70
92908: PUSH
92909: LD_VAR 0 5
92913: ARRAY
92914: PUSH
92915: LD_VAR 0 4
92919: ARRAY
92920: PUSH
92921: LD_INT 1
92923: ARRAY
92924: PUSH
92925: LD_VAR 0 2
92929: EQUAL
92930: IFFALSE 92941
// KillUnit ( vehicle ) ;
92932: LD_VAR 0 2
92936: PPUSH
92937: CALL_OW 66
92941: GO 92901
92943: POP
92944: POP
// end ;
92945: LD_VAR 0 3
92949: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92950: LD_EXP 74
92954: NOT
92955: IFFALSE 92990
92957: GO 92959
92959: DISABLE
// begin initMiner := true ;
92960: LD_ADDR_EXP 74
92964: PUSH
92965: LD_INT 1
92967: ST_TO_ADDR
// minersList := [ ] ;
92968: LD_ADDR_EXP 75
92972: PUSH
92973: EMPTY
92974: ST_TO_ADDR
// minerMinesList := [ ] ;
92975: LD_ADDR_EXP 76
92979: PUSH
92980: EMPTY
92981: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92982: LD_ADDR_EXP 77
92986: PUSH
92987: LD_INT 5
92989: ST_TO_ADDR
// end ;
92990: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92991: LD_EXP 74
92995: PUSH
92996: LD_INT 34
92998: PUSH
92999: LD_INT 81
93001: PUSH
93002: EMPTY
93003: LIST
93004: LIST
93005: PPUSH
93006: CALL_OW 69
93010: AND
93011: IFFALSE 93472
93013: GO 93015
93015: DISABLE
93016: LD_INT 0
93018: PPUSH
93019: PPUSH
93020: PPUSH
93021: PPUSH
// begin enable ;
93022: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
93023: LD_ADDR_VAR 0 1
93027: PUSH
93028: LD_INT 34
93030: PUSH
93031: LD_INT 81
93033: PUSH
93034: EMPTY
93035: LIST
93036: LIST
93037: PPUSH
93038: CALL_OW 69
93042: PUSH
93043: FOR_IN
93044: IFFALSE 93116
// begin if not i in minersList then
93046: LD_VAR 0 1
93050: PUSH
93051: LD_EXP 75
93055: IN
93056: NOT
93057: IFFALSE 93114
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
93059: LD_ADDR_EXP 75
93063: PUSH
93064: LD_EXP 75
93068: PPUSH
93069: LD_EXP 75
93073: PUSH
93074: LD_INT 1
93076: PLUS
93077: PPUSH
93078: LD_VAR 0 1
93082: PPUSH
93083: CALL_OW 1
93087: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
93088: LD_ADDR_EXP 76
93092: PUSH
93093: LD_EXP 76
93097: PPUSH
93098: LD_EXP 76
93102: PUSH
93103: LD_INT 1
93105: PLUS
93106: PPUSH
93107: EMPTY
93108: PPUSH
93109: CALL_OW 1
93113: ST_TO_ADDR
// end end ;
93114: GO 93043
93116: POP
93117: POP
// for i := minerMinesList downto 1 do
93118: LD_ADDR_VAR 0 1
93122: PUSH
93123: DOUBLE
93124: LD_EXP 76
93128: INC
93129: ST_TO_ADDR
93130: LD_INT 1
93132: PUSH
93133: FOR_DOWNTO
93134: IFFALSE 93470
// begin if IsLive ( minersList [ i ] ) then
93136: LD_EXP 75
93140: PUSH
93141: LD_VAR 0 1
93145: ARRAY
93146: PPUSH
93147: CALL_OW 300
93151: IFFALSE 93179
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
93153: LD_EXP 75
93157: PUSH
93158: LD_VAR 0 1
93162: ARRAY
93163: PPUSH
93164: LD_EXP 76
93168: PUSH
93169: LD_VAR 0 1
93173: ARRAY
93174: PPUSH
93175: CALL_OW 505
// if not minerMinesList [ i ] then
93179: LD_EXP 76
93183: PUSH
93184: LD_VAR 0 1
93188: ARRAY
93189: NOT
93190: IFFALSE 93194
// continue ;
93192: GO 93133
// for j := minerMinesList [ i ] downto 1 do
93194: LD_ADDR_VAR 0 2
93198: PUSH
93199: DOUBLE
93200: LD_EXP 76
93204: PUSH
93205: LD_VAR 0 1
93209: ARRAY
93210: INC
93211: ST_TO_ADDR
93212: LD_INT 1
93214: PUSH
93215: FOR_DOWNTO
93216: IFFALSE 93466
// begin side := GetSide ( minersList [ i ] ) ;
93218: LD_ADDR_VAR 0 3
93222: PUSH
93223: LD_EXP 75
93227: PUSH
93228: LD_VAR 0 1
93232: ARRAY
93233: PPUSH
93234: CALL_OW 255
93238: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
93239: LD_ADDR_VAR 0 4
93243: PUSH
93244: LD_EXP 76
93248: PUSH
93249: LD_VAR 0 1
93253: ARRAY
93254: PUSH
93255: LD_VAR 0 2
93259: ARRAY
93260: PUSH
93261: LD_INT 1
93263: ARRAY
93264: PPUSH
93265: LD_EXP 76
93269: PUSH
93270: LD_VAR 0 1
93274: ARRAY
93275: PUSH
93276: LD_VAR 0 2
93280: ARRAY
93281: PUSH
93282: LD_INT 2
93284: ARRAY
93285: PPUSH
93286: CALL_OW 428
93290: ST_TO_ADDR
// if not tmp then
93291: LD_VAR 0 4
93295: NOT
93296: IFFALSE 93300
// continue ;
93298: GO 93215
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
93300: LD_VAR 0 4
93304: PUSH
93305: LD_INT 81
93307: PUSH
93308: LD_VAR 0 3
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PPUSH
93317: CALL_OW 69
93321: IN
93322: PUSH
93323: LD_EXP 76
93327: PUSH
93328: LD_VAR 0 1
93332: ARRAY
93333: PUSH
93334: LD_VAR 0 2
93338: ARRAY
93339: PUSH
93340: LD_INT 1
93342: ARRAY
93343: PPUSH
93344: LD_EXP 76
93348: PUSH
93349: LD_VAR 0 1
93353: ARRAY
93354: PUSH
93355: LD_VAR 0 2
93359: ARRAY
93360: PUSH
93361: LD_INT 2
93363: ARRAY
93364: PPUSH
93365: CALL_OW 458
93369: AND
93370: IFFALSE 93464
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
93372: LD_EXP 76
93376: PUSH
93377: LD_VAR 0 1
93381: ARRAY
93382: PUSH
93383: LD_VAR 0 2
93387: ARRAY
93388: PUSH
93389: LD_INT 1
93391: ARRAY
93392: PPUSH
93393: LD_EXP 76
93397: PUSH
93398: LD_VAR 0 1
93402: ARRAY
93403: PUSH
93404: LD_VAR 0 2
93408: ARRAY
93409: PUSH
93410: LD_INT 2
93412: ARRAY
93413: PPUSH
93414: LD_VAR 0 3
93418: PPUSH
93419: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
93423: LD_ADDR_EXP 76
93427: PUSH
93428: LD_EXP 76
93432: PPUSH
93433: LD_VAR 0 1
93437: PPUSH
93438: LD_EXP 76
93442: PUSH
93443: LD_VAR 0 1
93447: ARRAY
93448: PPUSH
93449: LD_VAR 0 2
93453: PPUSH
93454: CALL_OW 3
93458: PPUSH
93459: CALL_OW 1
93463: ST_TO_ADDR
// end ; end ;
93464: GO 93215
93466: POP
93467: POP
// end ;
93468: GO 93133
93470: POP
93471: POP
// end ;
93472: PPOPN 4
93474: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
93475: LD_INT 0
93477: PPUSH
93478: PPUSH
// result := false ;
93479: LD_ADDR_VAR 0 4
93483: PUSH
93484: LD_INT 0
93486: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
93487: LD_VAR 0 1
93491: PPUSH
93492: CALL_OW 264
93496: PUSH
93497: LD_INT 81
93499: EQUAL
93500: NOT
93501: IFFALSE 93505
// exit ;
93503: GO 93745
// index := GetElementIndex ( minersList , unit ) ;
93505: LD_ADDR_VAR 0 5
93509: PUSH
93510: LD_EXP 75
93514: PPUSH
93515: LD_VAR 0 1
93519: PPUSH
93520: CALL 15862 0 2
93524: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
93525: LD_EXP 76
93529: PUSH
93530: LD_VAR 0 5
93534: ARRAY
93535: PUSH
93536: LD_EXP 77
93540: GREATEREQUAL
93541: IFFALSE 93545
// exit ;
93543: GO 93745
// ComMoveXY ( unit , x , y ) ;
93545: LD_VAR 0 1
93549: PPUSH
93550: LD_VAR 0 2
93554: PPUSH
93555: LD_VAR 0 3
93559: PPUSH
93560: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93564: LD_INT 35
93566: PPUSH
93567: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93571: LD_VAR 0 1
93575: PPUSH
93576: LD_VAR 0 2
93580: PPUSH
93581: LD_VAR 0 3
93585: PPUSH
93586: CALL 47246 0 3
93590: NOT
93591: PUSH
93592: LD_VAR 0 1
93596: PPUSH
93597: CALL_OW 314
93601: AND
93602: IFFALSE 93606
// exit ;
93604: GO 93745
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93606: LD_VAR 0 2
93610: PPUSH
93611: LD_VAR 0 3
93615: PPUSH
93616: CALL_OW 428
93620: PUSH
93621: LD_VAR 0 1
93625: EQUAL
93626: PUSH
93627: LD_VAR 0 1
93631: PPUSH
93632: CALL_OW 314
93636: NOT
93637: AND
93638: IFFALSE 93564
// PlaySoundXY ( x , y , PlantMine ) ;
93640: LD_VAR 0 2
93644: PPUSH
93645: LD_VAR 0 3
93649: PPUSH
93650: LD_STRING PlantMine
93652: PPUSH
93653: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93657: LD_VAR 0 2
93661: PPUSH
93662: LD_VAR 0 3
93666: PPUSH
93667: LD_VAR 0 1
93671: PPUSH
93672: CALL_OW 255
93676: PPUSH
93677: LD_INT 0
93679: PPUSH
93680: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93684: LD_ADDR_EXP 76
93688: PUSH
93689: LD_EXP 76
93693: PPUSH
93694: LD_VAR 0 5
93698: PUSH
93699: LD_EXP 76
93703: PUSH
93704: LD_VAR 0 5
93708: ARRAY
93709: PUSH
93710: LD_INT 1
93712: PLUS
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PPUSH
93718: LD_VAR 0 2
93722: PUSH
93723: LD_VAR 0 3
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PPUSH
93732: CALL 16077 0 3
93736: ST_TO_ADDR
// result := true ;
93737: LD_ADDR_VAR 0 4
93741: PUSH
93742: LD_INT 1
93744: ST_TO_ADDR
// end ;
93745: LD_VAR 0 4
93749: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93750: LD_INT 0
93752: PPUSH
93753: PPUSH
93754: PPUSH
// if not unit in minersList then
93755: LD_VAR 0 1
93759: PUSH
93760: LD_EXP 75
93764: IN
93765: NOT
93766: IFFALSE 93770
// exit ;
93768: GO 94162
// index := GetElementIndex ( minersList , unit ) ;
93770: LD_ADDR_VAR 0 6
93774: PUSH
93775: LD_EXP 75
93779: PPUSH
93780: LD_VAR 0 1
93784: PPUSH
93785: CALL 15862 0 2
93789: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93790: LD_ADDR_VAR 0 5
93794: PUSH
93795: DOUBLE
93796: LD_EXP 76
93800: PUSH
93801: LD_VAR 0 6
93805: ARRAY
93806: INC
93807: ST_TO_ADDR
93808: LD_INT 1
93810: PUSH
93811: FOR_DOWNTO
93812: IFFALSE 93973
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93814: LD_EXP 76
93818: PUSH
93819: LD_VAR 0 6
93823: ARRAY
93824: PUSH
93825: LD_VAR 0 5
93829: ARRAY
93830: PUSH
93831: LD_INT 1
93833: ARRAY
93834: PUSH
93835: LD_VAR 0 2
93839: EQUAL
93840: PUSH
93841: LD_EXP 76
93845: PUSH
93846: LD_VAR 0 6
93850: ARRAY
93851: PUSH
93852: LD_VAR 0 5
93856: ARRAY
93857: PUSH
93858: LD_INT 2
93860: ARRAY
93861: PUSH
93862: LD_VAR 0 3
93866: EQUAL
93867: AND
93868: IFFALSE 93971
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93870: LD_EXP 76
93874: PUSH
93875: LD_VAR 0 6
93879: ARRAY
93880: PUSH
93881: LD_VAR 0 5
93885: ARRAY
93886: PUSH
93887: LD_INT 1
93889: ARRAY
93890: PPUSH
93891: LD_EXP 76
93895: PUSH
93896: LD_VAR 0 6
93900: ARRAY
93901: PUSH
93902: LD_VAR 0 5
93906: ARRAY
93907: PUSH
93908: LD_INT 2
93910: ARRAY
93911: PPUSH
93912: LD_VAR 0 1
93916: PPUSH
93917: CALL_OW 255
93921: PPUSH
93922: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93926: LD_ADDR_EXP 76
93930: PUSH
93931: LD_EXP 76
93935: PPUSH
93936: LD_VAR 0 6
93940: PPUSH
93941: LD_EXP 76
93945: PUSH
93946: LD_VAR 0 6
93950: ARRAY
93951: PPUSH
93952: LD_VAR 0 5
93956: PPUSH
93957: CALL_OW 3
93961: PPUSH
93962: CALL_OW 1
93966: ST_TO_ADDR
// exit ;
93967: POP
93968: POP
93969: GO 94162
// end ; end ;
93971: GO 93811
93973: POP
93974: POP
// for i := minerMinesList [ index ] downto 1 do
93975: LD_ADDR_VAR 0 5
93979: PUSH
93980: DOUBLE
93981: LD_EXP 76
93985: PUSH
93986: LD_VAR 0 6
93990: ARRAY
93991: INC
93992: ST_TO_ADDR
93993: LD_INT 1
93995: PUSH
93996: FOR_DOWNTO
93997: IFFALSE 94160
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93999: LD_EXP 76
94003: PUSH
94004: LD_VAR 0 6
94008: ARRAY
94009: PUSH
94010: LD_VAR 0 5
94014: ARRAY
94015: PUSH
94016: LD_INT 1
94018: ARRAY
94019: PPUSH
94020: LD_EXP 76
94024: PUSH
94025: LD_VAR 0 6
94029: ARRAY
94030: PUSH
94031: LD_VAR 0 5
94035: ARRAY
94036: PUSH
94037: LD_INT 2
94039: ARRAY
94040: PPUSH
94041: LD_VAR 0 2
94045: PPUSH
94046: LD_VAR 0 3
94050: PPUSH
94051: CALL_OW 298
94055: PUSH
94056: LD_INT 6
94058: LESS
94059: IFFALSE 94158
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
94061: LD_EXP 76
94065: PUSH
94066: LD_VAR 0 6
94070: ARRAY
94071: PUSH
94072: LD_VAR 0 5
94076: ARRAY
94077: PUSH
94078: LD_INT 1
94080: ARRAY
94081: PPUSH
94082: LD_EXP 76
94086: PUSH
94087: LD_VAR 0 6
94091: ARRAY
94092: PUSH
94093: LD_VAR 0 5
94097: ARRAY
94098: PUSH
94099: LD_INT 2
94101: ARRAY
94102: PPUSH
94103: LD_VAR 0 1
94107: PPUSH
94108: CALL_OW 255
94112: PPUSH
94113: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
94117: LD_ADDR_EXP 76
94121: PUSH
94122: LD_EXP 76
94126: PPUSH
94127: LD_VAR 0 6
94131: PPUSH
94132: LD_EXP 76
94136: PUSH
94137: LD_VAR 0 6
94141: ARRAY
94142: PPUSH
94143: LD_VAR 0 5
94147: PPUSH
94148: CALL_OW 3
94152: PPUSH
94153: CALL_OW 1
94157: ST_TO_ADDR
// end ; end ;
94158: GO 93996
94160: POP
94161: POP
// end ;
94162: LD_VAR 0 4
94166: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
94167: LD_INT 0
94169: PPUSH
94170: PPUSH
94171: PPUSH
94172: PPUSH
94173: PPUSH
94174: PPUSH
94175: PPUSH
94176: PPUSH
94177: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
94178: LD_VAR 0 1
94182: PPUSH
94183: CALL_OW 264
94187: PUSH
94188: LD_INT 81
94190: EQUAL
94191: NOT
94192: PUSH
94193: LD_VAR 0 1
94197: PUSH
94198: LD_EXP 75
94202: IN
94203: NOT
94204: OR
94205: IFFALSE 94209
// exit ;
94207: GO 94531
// index := GetElementIndex ( minersList , unit ) ;
94209: LD_ADDR_VAR 0 6
94213: PUSH
94214: LD_EXP 75
94218: PPUSH
94219: LD_VAR 0 1
94223: PPUSH
94224: CALL 15862 0 2
94228: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
94229: LD_ADDR_VAR 0 8
94233: PUSH
94234: LD_EXP 77
94238: PUSH
94239: LD_EXP 76
94243: PUSH
94244: LD_VAR 0 6
94248: ARRAY
94249: MINUS
94250: ST_TO_ADDR
// if not minesFreeAmount then
94251: LD_VAR 0 8
94255: NOT
94256: IFFALSE 94260
// exit ;
94258: GO 94531
// tmp := [ ] ;
94260: LD_ADDR_VAR 0 7
94264: PUSH
94265: EMPTY
94266: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
94267: LD_ADDR_VAR 0 5
94271: PUSH
94272: DOUBLE
94273: LD_INT 1
94275: DEC
94276: ST_TO_ADDR
94277: LD_VAR 0 8
94281: PUSH
94282: FOR_TO
94283: IFFALSE 94478
// begin _d := rand ( 0 , 5 ) ;
94285: LD_ADDR_VAR 0 11
94289: PUSH
94290: LD_INT 0
94292: PPUSH
94293: LD_INT 5
94295: PPUSH
94296: CALL_OW 12
94300: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
94301: LD_ADDR_VAR 0 12
94305: PUSH
94306: LD_INT 2
94308: PPUSH
94309: LD_INT 6
94311: PPUSH
94312: CALL_OW 12
94316: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
94317: LD_ADDR_VAR 0 9
94321: PUSH
94322: LD_VAR 0 2
94326: PPUSH
94327: LD_VAR 0 11
94331: PPUSH
94332: LD_VAR 0 12
94336: PPUSH
94337: CALL_OW 272
94341: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
94342: LD_ADDR_VAR 0 10
94346: PUSH
94347: LD_VAR 0 3
94351: PPUSH
94352: LD_VAR 0 11
94356: PPUSH
94357: LD_VAR 0 12
94361: PPUSH
94362: CALL_OW 273
94366: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
94367: LD_VAR 0 9
94371: PPUSH
94372: LD_VAR 0 10
94376: PPUSH
94377: CALL_OW 488
94381: PUSH
94382: LD_VAR 0 9
94386: PUSH
94387: LD_VAR 0 10
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: PUSH
94396: LD_VAR 0 7
94400: IN
94401: NOT
94402: AND
94403: PUSH
94404: LD_VAR 0 9
94408: PPUSH
94409: LD_VAR 0 10
94413: PPUSH
94414: CALL_OW 458
94418: NOT
94419: AND
94420: IFFALSE 94462
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
94422: LD_ADDR_VAR 0 7
94426: PUSH
94427: LD_VAR 0 7
94431: PPUSH
94432: LD_VAR 0 7
94436: PUSH
94437: LD_INT 1
94439: PLUS
94440: PPUSH
94441: LD_VAR 0 9
94445: PUSH
94446: LD_VAR 0 10
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PPUSH
94455: CALL_OW 1
94459: ST_TO_ADDR
94460: GO 94476
// i := i - 1 ;
94462: LD_ADDR_VAR 0 5
94466: PUSH
94467: LD_VAR 0 5
94471: PUSH
94472: LD_INT 1
94474: MINUS
94475: ST_TO_ADDR
// end ;
94476: GO 94282
94478: POP
94479: POP
// for i in tmp do
94480: LD_ADDR_VAR 0 5
94484: PUSH
94485: LD_VAR 0 7
94489: PUSH
94490: FOR_IN
94491: IFFALSE 94529
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
94493: LD_VAR 0 1
94497: PPUSH
94498: LD_VAR 0 5
94502: PUSH
94503: LD_INT 1
94505: ARRAY
94506: PPUSH
94507: LD_VAR 0 5
94511: PUSH
94512: LD_INT 2
94514: ARRAY
94515: PPUSH
94516: CALL 93475 0 3
94520: NOT
94521: IFFALSE 94527
// exit ;
94523: POP
94524: POP
94525: GO 94531
94527: GO 94490
94529: POP
94530: POP
// end ;
94531: LD_VAR 0 4
94535: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
94536: LD_INT 0
94538: PPUSH
94539: PPUSH
94540: PPUSH
94541: PPUSH
94542: PPUSH
94543: PPUSH
94544: PPUSH
// if not GetClass ( unit ) = class_sniper then
94545: LD_VAR 0 1
94549: PPUSH
94550: CALL_OW 257
94554: PUSH
94555: LD_INT 5
94557: EQUAL
94558: NOT
94559: IFFALSE 94563
// exit ;
94561: GO 94951
// dist := 8 ;
94563: LD_ADDR_VAR 0 5
94567: PUSH
94568: LD_INT 8
94570: ST_TO_ADDR
// viewRange := 12 ;
94571: LD_ADDR_VAR 0 7
94575: PUSH
94576: LD_INT 12
94578: ST_TO_ADDR
// side := GetSide ( unit ) ;
94579: LD_ADDR_VAR 0 6
94583: PUSH
94584: LD_VAR 0 1
94588: PPUSH
94589: CALL_OW 255
94593: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94594: LD_INT 61
94596: PPUSH
94597: LD_VAR 0 6
94601: PPUSH
94602: CALL_OW 321
94606: PUSH
94607: LD_INT 2
94609: EQUAL
94610: IFFALSE 94620
// viewRange := 16 ;
94612: LD_ADDR_VAR 0 7
94616: PUSH
94617: LD_INT 16
94619: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94620: LD_VAR 0 1
94624: PPUSH
94625: LD_VAR 0 2
94629: PPUSH
94630: LD_VAR 0 3
94634: PPUSH
94635: CALL_OW 297
94639: PUSH
94640: LD_VAR 0 5
94644: GREATER
94645: IFFALSE 94724
// begin ComMoveXY ( unit , x , y ) ;
94647: LD_VAR 0 1
94651: PPUSH
94652: LD_VAR 0 2
94656: PPUSH
94657: LD_VAR 0 3
94661: PPUSH
94662: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94666: LD_INT 35
94668: PPUSH
94669: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94673: LD_VAR 0 1
94677: PPUSH
94678: LD_VAR 0 2
94682: PPUSH
94683: LD_VAR 0 3
94687: PPUSH
94688: CALL 47246 0 3
94692: NOT
94693: IFFALSE 94697
// exit ;
94695: GO 94951
// until GetDistUnitXY ( unit , x , y ) < dist ;
94697: LD_VAR 0 1
94701: PPUSH
94702: LD_VAR 0 2
94706: PPUSH
94707: LD_VAR 0 3
94711: PPUSH
94712: CALL_OW 297
94716: PUSH
94717: LD_VAR 0 5
94721: LESS
94722: IFFALSE 94666
// end ; ComTurnXY ( unit , x , y ) ;
94724: LD_VAR 0 1
94728: PPUSH
94729: LD_VAR 0 2
94733: PPUSH
94734: LD_VAR 0 3
94738: PPUSH
94739: CALL_OW 118
// wait ( 5 ) ;
94743: LD_INT 5
94745: PPUSH
94746: CALL_OW 67
// _d := GetDir ( unit ) ;
94750: LD_ADDR_VAR 0 10
94754: PUSH
94755: LD_VAR 0 1
94759: PPUSH
94760: CALL_OW 254
94764: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94765: LD_ADDR_VAR 0 8
94769: PUSH
94770: LD_VAR 0 1
94774: PPUSH
94775: CALL_OW 250
94779: PPUSH
94780: LD_VAR 0 10
94784: PPUSH
94785: LD_VAR 0 5
94789: PPUSH
94790: CALL_OW 272
94794: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94795: LD_ADDR_VAR 0 9
94799: PUSH
94800: LD_VAR 0 1
94804: PPUSH
94805: CALL_OW 251
94809: PPUSH
94810: LD_VAR 0 10
94814: PPUSH
94815: LD_VAR 0 5
94819: PPUSH
94820: CALL_OW 273
94824: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94825: LD_VAR 0 8
94829: PPUSH
94830: LD_VAR 0 9
94834: PPUSH
94835: CALL_OW 488
94839: NOT
94840: IFFALSE 94844
// exit ;
94842: GO 94951
// ComAnimCustom ( unit , 1 ) ;
94844: LD_VAR 0 1
94848: PPUSH
94849: LD_INT 1
94851: PPUSH
94852: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94856: LD_VAR 0 8
94860: PPUSH
94861: LD_VAR 0 9
94865: PPUSH
94866: LD_VAR 0 6
94870: PPUSH
94871: LD_VAR 0 7
94875: PPUSH
94876: CALL_OW 330
// repeat wait ( 1 ) ;
94880: LD_INT 1
94882: PPUSH
94883: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94887: LD_VAR 0 1
94891: PPUSH
94892: CALL_OW 316
94896: PUSH
94897: LD_VAR 0 1
94901: PPUSH
94902: CALL_OW 314
94906: OR
94907: PUSH
94908: LD_VAR 0 1
94912: PPUSH
94913: CALL_OW 302
94917: NOT
94918: OR
94919: PUSH
94920: LD_VAR 0 1
94924: PPUSH
94925: CALL_OW 301
94929: OR
94930: IFFALSE 94880
// RemoveSeeing ( _x , _y , side ) ;
94932: LD_VAR 0 8
94936: PPUSH
94937: LD_VAR 0 9
94941: PPUSH
94942: LD_VAR 0 6
94946: PPUSH
94947: CALL_OW 331
// end ; end_of_file end_of_file
94951: LD_VAR 0 4
94955: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94956: LD_VAR 0 1
94960: PUSH
94961: LD_INT 200
94963: DOUBLE
94964: GREATEREQUAL
94965: IFFALSE 94973
94967: LD_INT 299
94969: DOUBLE
94970: LESSEQUAL
94971: IFTRUE 94975
94973: GO 95007
94975: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94976: LD_VAR 0 1
94980: PPUSH
94981: LD_VAR 0 2
94985: PPUSH
94986: LD_VAR 0 3
94990: PPUSH
94991: LD_VAR 0 4
94995: PPUSH
94996: LD_VAR 0 5
95000: PPUSH
95001: CALL 91043 0 5
95005: GO 95084
95007: LD_INT 300
95009: DOUBLE
95010: GREATEREQUAL
95011: IFFALSE 95019
95013: LD_INT 399
95015: DOUBLE
95016: LESSEQUAL
95017: IFTRUE 95021
95019: GO 95083
95021: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
95022: LD_VAR 0 1
95026: PPUSH
95027: LD_VAR 0 2
95031: PPUSH
95032: LD_VAR 0 3
95036: PPUSH
95037: LD_VAR 0 4
95041: PPUSH
95042: LD_VAR 0 5
95046: PPUSH
95047: LD_VAR 0 6
95051: PPUSH
95052: LD_VAR 0 7
95056: PPUSH
95057: LD_VAR 0 8
95061: PPUSH
95062: LD_VAR 0 9
95066: PPUSH
95067: LD_VAR 0 10
95071: PPUSH
95072: LD_VAR 0 11
95076: PPUSH
95077: CALL 107622 0 11
95081: GO 95084
95083: POP
// end ;
95084: PPOPN 11
95086: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
95087: LD_VAR 0 1
95091: PPUSH
95092: LD_VAR 0 2
95096: PPUSH
95097: LD_VAR 0 3
95101: PPUSH
95102: LD_VAR 0 4
95106: PPUSH
95107: LD_VAR 0 5
95111: PPUSH
95112: CALL 90779 0 5
// end ; end_of_file
95116: PPOPN 5
95118: END
// export globalGameSaveCounter ; every 0 0$1 do
95119: GO 95121
95121: DISABLE
// begin enable ;
95122: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
95123: LD_STRING updateTimer(
95125: PUSH
95126: LD_OWVAR 1
95130: STR
95131: PUSH
95132: LD_STRING );
95134: STR
95135: PPUSH
95136: CALL_OW 559
// end ;
95140: END
// every 0 0$1 do
95141: GO 95143
95143: DISABLE
// begin globalGameSaveCounter := 0 ;
95144: LD_ADDR_EXP 78
95148: PUSH
95149: LD_INT 0
95151: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
95152: LD_STRING setGameSaveCounter(0)
95154: PPUSH
95155: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
95159: LD_STRING initStreamRollete();
95161: PPUSH
95162: CALL_OW 559
// InitStreamMode ;
95166: CALL 96492 0 0
// DefineStreamItems ( false ) ;
95170: LD_INT 0
95172: PPUSH
95173: CALL 96956 0 1
// end ;
95177: END
// export function SOS_MapStart ( ) ; begin
95178: LD_INT 0
95180: PPUSH
// if streamModeActive then
95181: LD_EXP 79
95185: IFFALSE 95194
// DefineStreamItems ( true ) ;
95187: LD_INT 1
95189: PPUSH
95190: CALL 96956 0 1
// UpdateLuaVariables ( ) ;
95194: CALL 95211 0 0
// UpdateFactoryWaypoints ( ) ;
95198: CALL 109825 0 0
// UpdateWarehouseGatheringPoints ( ) ;
95202: CALL 110082 0 0
// end ;
95206: LD_VAR 0 1
95210: RET
// function UpdateLuaVariables ( ) ; begin
95211: LD_INT 0
95213: PPUSH
// if globalGameSaveCounter then
95214: LD_EXP 78
95218: IFFALSE 95252
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
95220: LD_ADDR_EXP 78
95224: PUSH
95225: LD_EXP 78
95229: PPUSH
95230: CALL 49797 0 1
95234: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95235: LD_STRING setGameSaveCounter(
95237: PUSH
95238: LD_EXP 78
95242: STR
95243: PUSH
95244: LD_STRING )
95246: STR
95247: PPUSH
95248: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
95252: LD_STRING setGameDifficulty(
95254: PUSH
95255: LD_OWVAR 67
95259: STR
95260: PUSH
95261: LD_STRING )
95263: STR
95264: PPUSH
95265: CALL_OW 559
// end ;
95269: LD_VAR 0 1
95273: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95274: LD_INT 0
95276: PPUSH
// if p2 = stream_mode then
95277: LD_VAR 0 2
95281: PUSH
95282: LD_INT 100
95284: EQUAL
95285: IFFALSE 96288
// begin if not StreamModeActive then
95287: LD_EXP 79
95291: NOT
95292: IFFALSE 95302
// StreamModeActive := true ;
95294: LD_ADDR_EXP 79
95298: PUSH
95299: LD_INT 1
95301: ST_TO_ADDR
// if p3 = 0 then
95302: LD_VAR 0 3
95306: PUSH
95307: LD_INT 0
95309: EQUAL
95310: IFFALSE 95316
// InitStreamMode ;
95312: CALL 96492 0 0
// if p3 = 1 then
95316: LD_VAR 0 3
95320: PUSH
95321: LD_INT 1
95323: EQUAL
95324: IFFALSE 95334
// sRocket := true ;
95326: LD_ADDR_EXP 84
95330: PUSH
95331: LD_INT 1
95333: ST_TO_ADDR
// if p3 = 2 then
95334: LD_VAR 0 3
95338: PUSH
95339: LD_INT 2
95341: EQUAL
95342: IFFALSE 95352
// sSpeed := true ;
95344: LD_ADDR_EXP 83
95348: PUSH
95349: LD_INT 1
95351: ST_TO_ADDR
// if p3 = 3 then
95352: LD_VAR 0 3
95356: PUSH
95357: LD_INT 3
95359: EQUAL
95360: IFFALSE 95370
// sEngine := true ;
95362: LD_ADDR_EXP 85
95366: PUSH
95367: LD_INT 1
95369: ST_TO_ADDR
// if p3 = 4 then
95370: LD_VAR 0 3
95374: PUSH
95375: LD_INT 4
95377: EQUAL
95378: IFFALSE 95388
// sSpec := true ;
95380: LD_ADDR_EXP 82
95384: PUSH
95385: LD_INT 1
95387: ST_TO_ADDR
// if p3 = 5 then
95388: LD_VAR 0 3
95392: PUSH
95393: LD_INT 5
95395: EQUAL
95396: IFFALSE 95406
// sLevel := true ;
95398: LD_ADDR_EXP 86
95402: PUSH
95403: LD_INT 1
95405: ST_TO_ADDR
// if p3 = 6 then
95406: LD_VAR 0 3
95410: PUSH
95411: LD_INT 6
95413: EQUAL
95414: IFFALSE 95424
// sArmoury := true ;
95416: LD_ADDR_EXP 87
95420: PUSH
95421: LD_INT 1
95423: ST_TO_ADDR
// if p3 = 7 then
95424: LD_VAR 0 3
95428: PUSH
95429: LD_INT 7
95431: EQUAL
95432: IFFALSE 95442
// sRadar := true ;
95434: LD_ADDR_EXP 88
95438: PUSH
95439: LD_INT 1
95441: ST_TO_ADDR
// if p3 = 8 then
95442: LD_VAR 0 3
95446: PUSH
95447: LD_INT 8
95449: EQUAL
95450: IFFALSE 95460
// sBunker := true ;
95452: LD_ADDR_EXP 89
95456: PUSH
95457: LD_INT 1
95459: ST_TO_ADDR
// if p3 = 9 then
95460: LD_VAR 0 3
95464: PUSH
95465: LD_INT 9
95467: EQUAL
95468: IFFALSE 95478
// sHack := true ;
95470: LD_ADDR_EXP 90
95474: PUSH
95475: LD_INT 1
95477: ST_TO_ADDR
// if p3 = 10 then
95478: LD_VAR 0 3
95482: PUSH
95483: LD_INT 10
95485: EQUAL
95486: IFFALSE 95496
// sFire := true ;
95488: LD_ADDR_EXP 91
95492: PUSH
95493: LD_INT 1
95495: ST_TO_ADDR
// if p3 = 11 then
95496: LD_VAR 0 3
95500: PUSH
95501: LD_INT 11
95503: EQUAL
95504: IFFALSE 95514
// sRefresh := true ;
95506: LD_ADDR_EXP 92
95510: PUSH
95511: LD_INT 1
95513: ST_TO_ADDR
// if p3 = 12 then
95514: LD_VAR 0 3
95518: PUSH
95519: LD_INT 12
95521: EQUAL
95522: IFFALSE 95532
// sExp := true ;
95524: LD_ADDR_EXP 93
95528: PUSH
95529: LD_INT 1
95531: ST_TO_ADDR
// if p3 = 13 then
95532: LD_VAR 0 3
95536: PUSH
95537: LD_INT 13
95539: EQUAL
95540: IFFALSE 95550
// sDepot := true ;
95542: LD_ADDR_EXP 94
95546: PUSH
95547: LD_INT 1
95549: ST_TO_ADDR
// if p3 = 14 then
95550: LD_VAR 0 3
95554: PUSH
95555: LD_INT 14
95557: EQUAL
95558: IFFALSE 95568
// sFlag := true ;
95560: LD_ADDR_EXP 95
95564: PUSH
95565: LD_INT 1
95567: ST_TO_ADDR
// if p3 = 15 then
95568: LD_VAR 0 3
95572: PUSH
95573: LD_INT 15
95575: EQUAL
95576: IFFALSE 95586
// sKamikadze := true ;
95578: LD_ADDR_EXP 103
95582: PUSH
95583: LD_INT 1
95585: ST_TO_ADDR
// if p3 = 16 then
95586: LD_VAR 0 3
95590: PUSH
95591: LD_INT 16
95593: EQUAL
95594: IFFALSE 95604
// sTroll := true ;
95596: LD_ADDR_EXP 104
95600: PUSH
95601: LD_INT 1
95603: ST_TO_ADDR
// if p3 = 17 then
95604: LD_VAR 0 3
95608: PUSH
95609: LD_INT 17
95611: EQUAL
95612: IFFALSE 95622
// sSlow := true ;
95614: LD_ADDR_EXP 105
95618: PUSH
95619: LD_INT 1
95621: ST_TO_ADDR
// if p3 = 18 then
95622: LD_VAR 0 3
95626: PUSH
95627: LD_INT 18
95629: EQUAL
95630: IFFALSE 95640
// sLack := true ;
95632: LD_ADDR_EXP 106
95636: PUSH
95637: LD_INT 1
95639: ST_TO_ADDR
// if p3 = 19 then
95640: LD_VAR 0 3
95644: PUSH
95645: LD_INT 19
95647: EQUAL
95648: IFFALSE 95658
// sTank := true ;
95650: LD_ADDR_EXP 108
95654: PUSH
95655: LD_INT 1
95657: ST_TO_ADDR
// if p3 = 20 then
95658: LD_VAR 0 3
95662: PUSH
95663: LD_INT 20
95665: EQUAL
95666: IFFALSE 95676
// sRemote := true ;
95668: LD_ADDR_EXP 109
95672: PUSH
95673: LD_INT 1
95675: ST_TO_ADDR
// if p3 = 21 then
95676: LD_VAR 0 3
95680: PUSH
95681: LD_INT 21
95683: EQUAL
95684: IFFALSE 95694
// sPowell := true ;
95686: LD_ADDR_EXP 110
95690: PUSH
95691: LD_INT 1
95693: ST_TO_ADDR
// if p3 = 22 then
95694: LD_VAR 0 3
95698: PUSH
95699: LD_INT 22
95701: EQUAL
95702: IFFALSE 95712
// sTeleport := true ;
95704: LD_ADDR_EXP 113
95708: PUSH
95709: LD_INT 1
95711: ST_TO_ADDR
// if p3 = 23 then
95712: LD_VAR 0 3
95716: PUSH
95717: LD_INT 23
95719: EQUAL
95720: IFFALSE 95730
// sOilTower := true ;
95722: LD_ADDR_EXP 115
95726: PUSH
95727: LD_INT 1
95729: ST_TO_ADDR
// if p3 = 24 then
95730: LD_VAR 0 3
95734: PUSH
95735: LD_INT 24
95737: EQUAL
95738: IFFALSE 95748
// sShovel := true ;
95740: LD_ADDR_EXP 116
95744: PUSH
95745: LD_INT 1
95747: ST_TO_ADDR
// if p3 = 25 then
95748: LD_VAR 0 3
95752: PUSH
95753: LD_INT 25
95755: EQUAL
95756: IFFALSE 95766
// sSheik := true ;
95758: LD_ADDR_EXP 117
95762: PUSH
95763: LD_INT 1
95765: ST_TO_ADDR
// if p3 = 26 then
95766: LD_VAR 0 3
95770: PUSH
95771: LD_INT 26
95773: EQUAL
95774: IFFALSE 95784
// sEarthquake := true ;
95776: LD_ADDR_EXP 119
95780: PUSH
95781: LD_INT 1
95783: ST_TO_ADDR
// if p3 = 27 then
95784: LD_VAR 0 3
95788: PUSH
95789: LD_INT 27
95791: EQUAL
95792: IFFALSE 95802
// sAI := true ;
95794: LD_ADDR_EXP 120
95798: PUSH
95799: LD_INT 1
95801: ST_TO_ADDR
// if p3 = 28 then
95802: LD_VAR 0 3
95806: PUSH
95807: LD_INT 28
95809: EQUAL
95810: IFFALSE 95820
// sCargo := true ;
95812: LD_ADDR_EXP 123
95816: PUSH
95817: LD_INT 1
95819: ST_TO_ADDR
// if p3 = 29 then
95820: LD_VAR 0 3
95824: PUSH
95825: LD_INT 29
95827: EQUAL
95828: IFFALSE 95838
// sDLaser := true ;
95830: LD_ADDR_EXP 124
95834: PUSH
95835: LD_INT 1
95837: ST_TO_ADDR
// if p3 = 30 then
95838: LD_VAR 0 3
95842: PUSH
95843: LD_INT 30
95845: EQUAL
95846: IFFALSE 95856
// sExchange := true ;
95848: LD_ADDR_EXP 125
95852: PUSH
95853: LD_INT 1
95855: ST_TO_ADDR
// if p3 = 31 then
95856: LD_VAR 0 3
95860: PUSH
95861: LD_INT 31
95863: EQUAL
95864: IFFALSE 95874
// sFac := true ;
95866: LD_ADDR_EXP 126
95870: PUSH
95871: LD_INT 1
95873: ST_TO_ADDR
// if p3 = 32 then
95874: LD_VAR 0 3
95878: PUSH
95879: LD_INT 32
95881: EQUAL
95882: IFFALSE 95892
// sPower := true ;
95884: LD_ADDR_EXP 127
95888: PUSH
95889: LD_INT 1
95891: ST_TO_ADDR
// if p3 = 33 then
95892: LD_VAR 0 3
95896: PUSH
95897: LD_INT 33
95899: EQUAL
95900: IFFALSE 95910
// sRandom := true ;
95902: LD_ADDR_EXP 128
95906: PUSH
95907: LD_INT 1
95909: ST_TO_ADDR
// if p3 = 34 then
95910: LD_VAR 0 3
95914: PUSH
95915: LD_INT 34
95917: EQUAL
95918: IFFALSE 95928
// sShield := true ;
95920: LD_ADDR_EXP 129
95924: PUSH
95925: LD_INT 1
95927: ST_TO_ADDR
// if p3 = 35 then
95928: LD_VAR 0 3
95932: PUSH
95933: LD_INT 35
95935: EQUAL
95936: IFFALSE 95946
// sTime := true ;
95938: LD_ADDR_EXP 130
95942: PUSH
95943: LD_INT 1
95945: ST_TO_ADDR
// if p3 = 36 then
95946: LD_VAR 0 3
95950: PUSH
95951: LD_INT 36
95953: EQUAL
95954: IFFALSE 95964
// sTools := true ;
95956: LD_ADDR_EXP 131
95960: PUSH
95961: LD_INT 1
95963: ST_TO_ADDR
// if p3 = 101 then
95964: LD_VAR 0 3
95968: PUSH
95969: LD_INT 101
95971: EQUAL
95972: IFFALSE 95982
// sSold := true ;
95974: LD_ADDR_EXP 96
95978: PUSH
95979: LD_INT 1
95981: ST_TO_ADDR
// if p3 = 102 then
95982: LD_VAR 0 3
95986: PUSH
95987: LD_INT 102
95989: EQUAL
95990: IFFALSE 96000
// sDiff := true ;
95992: LD_ADDR_EXP 97
95996: PUSH
95997: LD_INT 1
95999: ST_TO_ADDR
// if p3 = 103 then
96000: LD_VAR 0 3
96004: PUSH
96005: LD_INT 103
96007: EQUAL
96008: IFFALSE 96018
// sFog := true ;
96010: LD_ADDR_EXP 100
96014: PUSH
96015: LD_INT 1
96017: ST_TO_ADDR
// if p3 = 104 then
96018: LD_VAR 0 3
96022: PUSH
96023: LD_INT 104
96025: EQUAL
96026: IFFALSE 96036
// sReset := true ;
96028: LD_ADDR_EXP 101
96032: PUSH
96033: LD_INT 1
96035: ST_TO_ADDR
// if p3 = 105 then
96036: LD_VAR 0 3
96040: PUSH
96041: LD_INT 105
96043: EQUAL
96044: IFFALSE 96054
// sSun := true ;
96046: LD_ADDR_EXP 102
96050: PUSH
96051: LD_INT 1
96053: ST_TO_ADDR
// if p3 = 106 then
96054: LD_VAR 0 3
96058: PUSH
96059: LD_INT 106
96061: EQUAL
96062: IFFALSE 96072
// sTiger := true ;
96064: LD_ADDR_EXP 98
96068: PUSH
96069: LD_INT 1
96071: ST_TO_ADDR
// if p3 = 107 then
96072: LD_VAR 0 3
96076: PUSH
96077: LD_INT 107
96079: EQUAL
96080: IFFALSE 96090
// sBomb := true ;
96082: LD_ADDR_EXP 99
96086: PUSH
96087: LD_INT 1
96089: ST_TO_ADDR
// if p3 = 108 then
96090: LD_VAR 0 3
96094: PUSH
96095: LD_INT 108
96097: EQUAL
96098: IFFALSE 96108
// sWound := true ;
96100: LD_ADDR_EXP 107
96104: PUSH
96105: LD_INT 1
96107: ST_TO_ADDR
// if p3 = 109 then
96108: LD_VAR 0 3
96112: PUSH
96113: LD_INT 109
96115: EQUAL
96116: IFFALSE 96126
// sBetray := true ;
96118: LD_ADDR_EXP 111
96122: PUSH
96123: LD_INT 1
96125: ST_TO_ADDR
// if p3 = 110 then
96126: LD_VAR 0 3
96130: PUSH
96131: LD_INT 110
96133: EQUAL
96134: IFFALSE 96144
// sContamin := true ;
96136: LD_ADDR_EXP 112
96140: PUSH
96141: LD_INT 1
96143: ST_TO_ADDR
// if p3 = 111 then
96144: LD_VAR 0 3
96148: PUSH
96149: LD_INT 111
96151: EQUAL
96152: IFFALSE 96162
// sOil := true ;
96154: LD_ADDR_EXP 114
96158: PUSH
96159: LD_INT 1
96161: ST_TO_ADDR
// if p3 = 112 then
96162: LD_VAR 0 3
96166: PUSH
96167: LD_INT 112
96169: EQUAL
96170: IFFALSE 96180
// sStu := true ;
96172: LD_ADDR_EXP 118
96176: PUSH
96177: LD_INT 1
96179: ST_TO_ADDR
// if p3 = 113 then
96180: LD_VAR 0 3
96184: PUSH
96185: LD_INT 113
96187: EQUAL
96188: IFFALSE 96198
// sBazooka := true ;
96190: LD_ADDR_EXP 121
96194: PUSH
96195: LD_INT 1
96197: ST_TO_ADDR
// if p3 = 114 then
96198: LD_VAR 0 3
96202: PUSH
96203: LD_INT 114
96205: EQUAL
96206: IFFALSE 96216
// sMortar := true ;
96208: LD_ADDR_EXP 122
96212: PUSH
96213: LD_INT 1
96215: ST_TO_ADDR
// if p3 = 115 then
96216: LD_VAR 0 3
96220: PUSH
96221: LD_INT 115
96223: EQUAL
96224: IFFALSE 96234
// sRanger := true ;
96226: LD_ADDR_EXP 132
96230: PUSH
96231: LD_INT 1
96233: ST_TO_ADDR
// if p3 = 116 then
96234: LD_VAR 0 3
96238: PUSH
96239: LD_INT 116
96241: EQUAL
96242: IFFALSE 96252
// sComputer := true ;
96244: LD_ADDR_EXP 133
96248: PUSH
96249: LD_INT 1
96251: ST_TO_ADDR
// if p3 = 117 then
96252: LD_VAR 0 3
96256: PUSH
96257: LD_INT 117
96259: EQUAL
96260: IFFALSE 96270
// s30 := true ;
96262: LD_ADDR_EXP 134
96266: PUSH
96267: LD_INT 1
96269: ST_TO_ADDR
// if p3 = 118 then
96270: LD_VAR 0 3
96274: PUSH
96275: LD_INT 118
96277: EQUAL
96278: IFFALSE 96288
// s60 := true ;
96280: LD_ADDR_EXP 135
96284: PUSH
96285: LD_INT 1
96287: ST_TO_ADDR
// end ; if p2 = hack_mode then
96288: LD_VAR 0 2
96292: PUSH
96293: LD_INT 101
96295: EQUAL
96296: IFFALSE 96424
// begin case p3 of 1 :
96298: LD_VAR 0 3
96302: PUSH
96303: LD_INT 1
96305: DOUBLE
96306: EQUAL
96307: IFTRUE 96311
96309: GO 96318
96311: POP
// hHackUnlimitedResources ; 2 :
96312: CALL 108571 0 0
96316: GO 96424
96318: LD_INT 2
96320: DOUBLE
96321: EQUAL
96322: IFTRUE 96326
96324: GO 96333
96326: POP
// hHackSetLevel10 ; 3 :
96327: CALL 108704 0 0
96331: GO 96424
96333: LD_INT 3
96335: DOUBLE
96336: EQUAL
96337: IFTRUE 96341
96339: GO 96348
96341: POP
// hHackSetLevel10YourUnits ; 4 :
96342: CALL 108789 0 0
96346: GO 96424
96348: LD_INT 4
96350: DOUBLE
96351: EQUAL
96352: IFTRUE 96356
96354: GO 96363
96356: POP
// hHackInvincible ; 5 :
96357: CALL 109237 0 0
96361: GO 96424
96363: LD_INT 5
96365: DOUBLE
96366: EQUAL
96367: IFTRUE 96371
96369: GO 96378
96371: POP
// hHackInvisible ; 6 :
96372: CALL 109348 0 0
96376: GO 96424
96378: LD_INT 6
96380: DOUBLE
96381: EQUAL
96382: IFTRUE 96386
96384: GO 96393
96386: POP
// hHackChangeYourSide ; 7 :
96387: CALL 109405 0 0
96391: GO 96424
96393: LD_INT 7
96395: DOUBLE
96396: EQUAL
96397: IFTRUE 96401
96399: GO 96408
96401: POP
// hHackChangeUnitSide ; 8 :
96402: CALL 109447 0 0
96406: GO 96424
96408: LD_INT 8
96410: DOUBLE
96411: EQUAL
96412: IFTRUE 96416
96414: GO 96423
96416: POP
// hHackFog ; end ;
96417: CALL 109548 0 0
96421: GO 96424
96423: POP
// end ; if p2 = game_save_mode then
96424: LD_VAR 0 2
96428: PUSH
96429: LD_INT 102
96431: EQUAL
96432: IFFALSE 96487
// begin if p3 = 1 then
96434: LD_VAR 0 3
96438: PUSH
96439: LD_INT 1
96441: EQUAL
96442: IFFALSE 96454
// globalGameSaveCounter := p4 ;
96444: LD_ADDR_EXP 78
96448: PUSH
96449: LD_VAR 0 4
96453: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
96454: LD_VAR 0 3
96458: PUSH
96459: LD_INT 2
96461: EQUAL
96462: PUSH
96463: LD_EXP 78
96467: AND
96468: IFFALSE 96487
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96470: LD_STRING setGameSaveCounter(
96472: PUSH
96473: LD_EXP 78
96477: STR
96478: PUSH
96479: LD_STRING )
96481: STR
96482: PPUSH
96483: CALL_OW 559
// end ; end ;
96487: LD_VAR 0 7
96491: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
96492: LD_INT 0
96494: PPUSH
// streamModeActive := false ;
96495: LD_ADDR_EXP 79
96499: PUSH
96500: LD_INT 0
96502: ST_TO_ADDR
// normalCounter := 36 ;
96503: LD_ADDR_EXP 80
96507: PUSH
96508: LD_INT 36
96510: ST_TO_ADDR
// hardcoreCounter := 18 ;
96511: LD_ADDR_EXP 81
96515: PUSH
96516: LD_INT 18
96518: ST_TO_ADDR
// sRocket := false ;
96519: LD_ADDR_EXP 84
96523: PUSH
96524: LD_INT 0
96526: ST_TO_ADDR
// sSpeed := false ;
96527: LD_ADDR_EXP 83
96531: PUSH
96532: LD_INT 0
96534: ST_TO_ADDR
// sEngine := false ;
96535: LD_ADDR_EXP 85
96539: PUSH
96540: LD_INT 0
96542: ST_TO_ADDR
// sSpec := false ;
96543: LD_ADDR_EXP 82
96547: PUSH
96548: LD_INT 0
96550: ST_TO_ADDR
// sLevel := false ;
96551: LD_ADDR_EXP 86
96555: PUSH
96556: LD_INT 0
96558: ST_TO_ADDR
// sArmoury := false ;
96559: LD_ADDR_EXP 87
96563: PUSH
96564: LD_INT 0
96566: ST_TO_ADDR
// sRadar := false ;
96567: LD_ADDR_EXP 88
96571: PUSH
96572: LD_INT 0
96574: ST_TO_ADDR
// sBunker := false ;
96575: LD_ADDR_EXP 89
96579: PUSH
96580: LD_INT 0
96582: ST_TO_ADDR
// sHack := false ;
96583: LD_ADDR_EXP 90
96587: PUSH
96588: LD_INT 0
96590: ST_TO_ADDR
// sFire := false ;
96591: LD_ADDR_EXP 91
96595: PUSH
96596: LD_INT 0
96598: ST_TO_ADDR
// sRefresh := false ;
96599: LD_ADDR_EXP 92
96603: PUSH
96604: LD_INT 0
96606: ST_TO_ADDR
// sExp := false ;
96607: LD_ADDR_EXP 93
96611: PUSH
96612: LD_INT 0
96614: ST_TO_ADDR
// sDepot := false ;
96615: LD_ADDR_EXP 94
96619: PUSH
96620: LD_INT 0
96622: ST_TO_ADDR
// sFlag := false ;
96623: LD_ADDR_EXP 95
96627: PUSH
96628: LD_INT 0
96630: ST_TO_ADDR
// sKamikadze := false ;
96631: LD_ADDR_EXP 103
96635: PUSH
96636: LD_INT 0
96638: ST_TO_ADDR
// sTroll := false ;
96639: LD_ADDR_EXP 104
96643: PUSH
96644: LD_INT 0
96646: ST_TO_ADDR
// sSlow := false ;
96647: LD_ADDR_EXP 105
96651: PUSH
96652: LD_INT 0
96654: ST_TO_ADDR
// sLack := false ;
96655: LD_ADDR_EXP 106
96659: PUSH
96660: LD_INT 0
96662: ST_TO_ADDR
// sTank := false ;
96663: LD_ADDR_EXP 108
96667: PUSH
96668: LD_INT 0
96670: ST_TO_ADDR
// sRemote := false ;
96671: LD_ADDR_EXP 109
96675: PUSH
96676: LD_INT 0
96678: ST_TO_ADDR
// sPowell := false ;
96679: LD_ADDR_EXP 110
96683: PUSH
96684: LD_INT 0
96686: ST_TO_ADDR
// sTeleport := false ;
96687: LD_ADDR_EXP 113
96691: PUSH
96692: LD_INT 0
96694: ST_TO_ADDR
// sOilTower := false ;
96695: LD_ADDR_EXP 115
96699: PUSH
96700: LD_INT 0
96702: ST_TO_ADDR
// sShovel := false ;
96703: LD_ADDR_EXP 116
96707: PUSH
96708: LD_INT 0
96710: ST_TO_ADDR
// sSheik := false ;
96711: LD_ADDR_EXP 117
96715: PUSH
96716: LD_INT 0
96718: ST_TO_ADDR
// sEarthquake := false ;
96719: LD_ADDR_EXP 119
96723: PUSH
96724: LD_INT 0
96726: ST_TO_ADDR
// sAI := false ;
96727: LD_ADDR_EXP 120
96731: PUSH
96732: LD_INT 0
96734: ST_TO_ADDR
// sCargo := false ;
96735: LD_ADDR_EXP 123
96739: PUSH
96740: LD_INT 0
96742: ST_TO_ADDR
// sDLaser := false ;
96743: LD_ADDR_EXP 124
96747: PUSH
96748: LD_INT 0
96750: ST_TO_ADDR
// sExchange := false ;
96751: LD_ADDR_EXP 125
96755: PUSH
96756: LD_INT 0
96758: ST_TO_ADDR
// sFac := false ;
96759: LD_ADDR_EXP 126
96763: PUSH
96764: LD_INT 0
96766: ST_TO_ADDR
// sPower := false ;
96767: LD_ADDR_EXP 127
96771: PUSH
96772: LD_INT 0
96774: ST_TO_ADDR
// sRandom := false ;
96775: LD_ADDR_EXP 128
96779: PUSH
96780: LD_INT 0
96782: ST_TO_ADDR
// sShield := false ;
96783: LD_ADDR_EXP 129
96787: PUSH
96788: LD_INT 0
96790: ST_TO_ADDR
// sTime := false ;
96791: LD_ADDR_EXP 130
96795: PUSH
96796: LD_INT 0
96798: ST_TO_ADDR
// sTools := false ;
96799: LD_ADDR_EXP 131
96803: PUSH
96804: LD_INT 0
96806: ST_TO_ADDR
// sSold := false ;
96807: LD_ADDR_EXP 96
96811: PUSH
96812: LD_INT 0
96814: ST_TO_ADDR
// sDiff := false ;
96815: LD_ADDR_EXP 97
96819: PUSH
96820: LD_INT 0
96822: ST_TO_ADDR
// sFog := false ;
96823: LD_ADDR_EXP 100
96827: PUSH
96828: LD_INT 0
96830: ST_TO_ADDR
// sReset := false ;
96831: LD_ADDR_EXP 101
96835: PUSH
96836: LD_INT 0
96838: ST_TO_ADDR
// sSun := false ;
96839: LD_ADDR_EXP 102
96843: PUSH
96844: LD_INT 0
96846: ST_TO_ADDR
// sTiger := false ;
96847: LD_ADDR_EXP 98
96851: PUSH
96852: LD_INT 0
96854: ST_TO_ADDR
// sBomb := false ;
96855: LD_ADDR_EXP 99
96859: PUSH
96860: LD_INT 0
96862: ST_TO_ADDR
// sWound := false ;
96863: LD_ADDR_EXP 107
96867: PUSH
96868: LD_INT 0
96870: ST_TO_ADDR
// sBetray := false ;
96871: LD_ADDR_EXP 111
96875: PUSH
96876: LD_INT 0
96878: ST_TO_ADDR
// sContamin := false ;
96879: LD_ADDR_EXP 112
96883: PUSH
96884: LD_INT 0
96886: ST_TO_ADDR
// sOil := false ;
96887: LD_ADDR_EXP 114
96891: PUSH
96892: LD_INT 0
96894: ST_TO_ADDR
// sStu := false ;
96895: LD_ADDR_EXP 118
96899: PUSH
96900: LD_INT 0
96902: ST_TO_ADDR
// sBazooka := false ;
96903: LD_ADDR_EXP 121
96907: PUSH
96908: LD_INT 0
96910: ST_TO_ADDR
// sMortar := false ;
96911: LD_ADDR_EXP 122
96915: PUSH
96916: LD_INT 0
96918: ST_TO_ADDR
// sRanger := false ;
96919: LD_ADDR_EXP 132
96923: PUSH
96924: LD_INT 0
96926: ST_TO_ADDR
// sComputer := false ;
96927: LD_ADDR_EXP 133
96931: PUSH
96932: LD_INT 0
96934: ST_TO_ADDR
// s30 := false ;
96935: LD_ADDR_EXP 134
96939: PUSH
96940: LD_INT 0
96942: ST_TO_ADDR
// s60 := false ;
96943: LD_ADDR_EXP 135
96947: PUSH
96948: LD_INT 0
96950: ST_TO_ADDR
// end ;
96951: LD_VAR 0 1
96955: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96956: LD_INT 0
96958: PPUSH
96959: PPUSH
96960: PPUSH
96961: PPUSH
96962: PPUSH
96963: PPUSH
96964: PPUSH
// result := [ ] ;
96965: LD_ADDR_VAR 0 2
96969: PUSH
96970: EMPTY
96971: ST_TO_ADDR
// if campaign_id = 1 then
96972: LD_OWVAR 69
96976: PUSH
96977: LD_INT 1
96979: EQUAL
96980: IFFALSE 100146
// begin case mission_number of 1 :
96982: LD_OWVAR 70
96986: PUSH
96987: LD_INT 1
96989: DOUBLE
96990: EQUAL
96991: IFTRUE 96995
96993: GO 97071
96995: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96996: LD_ADDR_VAR 0 2
97000: PUSH
97001: LD_INT 2
97003: PUSH
97004: LD_INT 4
97006: PUSH
97007: LD_INT 11
97009: PUSH
97010: LD_INT 12
97012: PUSH
97013: LD_INT 15
97015: PUSH
97016: LD_INT 16
97018: PUSH
97019: LD_INT 22
97021: PUSH
97022: LD_INT 23
97024: PUSH
97025: LD_INT 26
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: PUSH
97039: LD_INT 101
97041: PUSH
97042: LD_INT 102
97044: PUSH
97045: LD_INT 106
97047: PUSH
97048: LD_INT 116
97050: PUSH
97051: LD_INT 117
97053: PUSH
97054: LD_INT 118
97056: PUSH
97057: EMPTY
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: PUSH
97065: EMPTY
97066: LIST
97067: LIST
97068: ST_TO_ADDR
97069: GO 100144
97071: LD_INT 2
97073: DOUBLE
97074: EQUAL
97075: IFTRUE 97079
97077: GO 97163
97079: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
97080: LD_ADDR_VAR 0 2
97084: PUSH
97085: LD_INT 2
97087: PUSH
97088: LD_INT 4
97090: PUSH
97091: LD_INT 11
97093: PUSH
97094: LD_INT 12
97096: PUSH
97097: LD_INT 15
97099: PUSH
97100: LD_INT 16
97102: PUSH
97103: LD_INT 22
97105: PUSH
97106: LD_INT 23
97108: PUSH
97109: LD_INT 26
97111: PUSH
97112: EMPTY
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: PUSH
97123: LD_INT 101
97125: PUSH
97126: LD_INT 102
97128: PUSH
97129: LD_INT 105
97131: PUSH
97132: LD_INT 106
97134: PUSH
97135: LD_INT 108
97137: PUSH
97138: LD_INT 116
97140: PUSH
97141: LD_INT 117
97143: PUSH
97144: LD_INT 118
97146: PUSH
97147: EMPTY
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: ST_TO_ADDR
97161: GO 100144
97163: LD_INT 3
97165: DOUBLE
97166: EQUAL
97167: IFTRUE 97171
97169: GO 97259
97171: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
97172: LD_ADDR_VAR 0 2
97176: PUSH
97177: LD_INT 2
97179: PUSH
97180: LD_INT 4
97182: PUSH
97183: LD_INT 5
97185: PUSH
97186: LD_INT 11
97188: PUSH
97189: LD_INT 12
97191: PUSH
97192: LD_INT 15
97194: PUSH
97195: LD_INT 16
97197: PUSH
97198: LD_INT 22
97200: PUSH
97201: LD_INT 26
97203: PUSH
97204: LD_INT 36
97206: PUSH
97207: EMPTY
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: PUSH
97219: LD_INT 101
97221: PUSH
97222: LD_INT 102
97224: PUSH
97225: LD_INT 105
97227: PUSH
97228: LD_INT 106
97230: PUSH
97231: LD_INT 108
97233: PUSH
97234: LD_INT 116
97236: PUSH
97237: LD_INT 117
97239: PUSH
97240: LD_INT 118
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: PUSH
97253: EMPTY
97254: LIST
97255: LIST
97256: ST_TO_ADDR
97257: GO 100144
97259: LD_INT 4
97261: DOUBLE
97262: EQUAL
97263: IFTRUE 97267
97265: GO 97363
97267: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
97268: LD_ADDR_VAR 0 2
97272: PUSH
97273: LD_INT 2
97275: PUSH
97276: LD_INT 4
97278: PUSH
97279: LD_INT 5
97281: PUSH
97282: LD_INT 8
97284: PUSH
97285: LD_INT 11
97287: PUSH
97288: LD_INT 12
97290: PUSH
97291: LD_INT 15
97293: PUSH
97294: LD_INT 16
97296: PUSH
97297: LD_INT 22
97299: PUSH
97300: LD_INT 23
97302: PUSH
97303: LD_INT 26
97305: PUSH
97306: LD_INT 36
97308: PUSH
97309: EMPTY
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: LIST
97315: LIST
97316: LIST
97317: LIST
97318: LIST
97319: LIST
97320: LIST
97321: LIST
97322: PUSH
97323: LD_INT 101
97325: PUSH
97326: LD_INT 102
97328: PUSH
97329: LD_INT 105
97331: PUSH
97332: LD_INT 106
97334: PUSH
97335: LD_INT 108
97337: PUSH
97338: LD_INT 116
97340: PUSH
97341: LD_INT 117
97343: PUSH
97344: LD_INT 118
97346: PUSH
97347: EMPTY
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: ST_TO_ADDR
97361: GO 100144
97363: LD_INT 5
97365: DOUBLE
97366: EQUAL
97367: IFTRUE 97371
97369: GO 97483
97371: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
97372: LD_ADDR_VAR 0 2
97376: PUSH
97377: LD_INT 2
97379: PUSH
97380: LD_INT 4
97382: PUSH
97383: LD_INT 5
97385: PUSH
97386: LD_INT 6
97388: PUSH
97389: LD_INT 8
97391: PUSH
97392: LD_INT 11
97394: PUSH
97395: LD_INT 12
97397: PUSH
97398: LD_INT 15
97400: PUSH
97401: LD_INT 16
97403: PUSH
97404: LD_INT 22
97406: PUSH
97407: LD_INT 23
97409: PUSH
97410: LD_INT 25
97412: PUSH
97413: LD_INT 26
97415: PUSH
97416: LD_INT 36
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: LIST
97434: PUSH
97435: LD_INT 101
97437: PUSH
97438: LD_INT 102
97440: PUSH
97441: LD_INT 105
97443: PUSH
97444: LD_INT 106
97446: PUSH
97447: LD_INT 108
97449: PUSH
97450: LD_INT 109
97452: PUSH
97453: LD_INT 112
97455: PUSH
97456: LD_INT 116
97458: PUSH
97459: LD_INT 117
97461: PUSH
97462: LD_INT 118
97464: PUSH
97465: EMPTY
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: PUSH
97477: EMPTY
97478: LIST
97479: LIST
97480: ST_TO_ADDR
97481: GO 100144
97483: LD_INT 6
97485: DOUBLE
97486: EQUAL
97487: IFTRUE 97491
97489: GO 97623
97491: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97492: LD_ADDR_VAR 0 2
97496: PUSH
97497: LD_INT 2
97499: PUSH
97500: LD_INT 4
97502: PUSH
97503: LD_INT 5
97505: PUSH
97506: LD_INT 6
97508: PUSH
97509: LD_INT 8
97511: PUSH
97512: LD_INT 11
97514: PUSH
97515: LD_INT 12
97517: PUSH
97518: LD_INT 15
97520: PUSH
97521: LD_INT 16
97523: PUSH
97524: LD_INT 20
97526: PUSH
97527: LD_INT 21
97529: PUSH
97530: LD_INT 22
97532: PUSH
97533: LD_INT 23
97535: PUSH
97536: LD_INT 25
97538: PUSH
97539: LD_INT 26
97541: PUSH
97542: LD_INT 30
97544: PUSH
97545: LD_INT 31
97547: PUSH
97548: LD_INT 32
97550: PUSH
97551: LD_INT 36
97553: PUSH
97554: EMPTY
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: PUSH
97575: LD_INT 101
97577: PUSH
97578: LD_INT 102
97580: PUSH
97581: LD_INT 105
97583: PUSH
97584: LD_INT 106
97586: PUSH
97587: LD_INT 108
97589: PUSH
97590: LD_INT 109
97592: PUSH
97593: LD_INT 112
97595: PUSH
97596: LD_INT 116
97598: PUSH
97599: LD_INT 117
97601: PUSH
97602: LD_INT 118
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: LIST
97609: LIST
97610: LIST
97611: LIST
97612: LIST
97613: LIST
97614: LIST
97615: LIST
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: ST_TO_ADDR
97621: GO 100144
97623: LD_INT 7
97625: DOUBLE
97626: EQUAL
97627: IFTRUE 97631
97629: GO 97743
97631: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97632: LD_ADDR_VAR 0 2
97636: PUSH
97637: LD_INT 2
97639: PUSH
97640: LD_INT 4
97642: PUSH
97643: LD_INT 5
97645: PUSH
97646: LD_INT 7
97648: PUSH
97649: LD_INT 11
97651: PUSH
97652: LD_INT 12
97654: PUSH
97655: LD_INT 15
97657: PUSH
97658: LD_INT 16
97660: PUSH
97661: LD_INT 20
97663: PUSH
97664: LD_INT 21
97666: PUSH
97667: LD_INT 22
97669: PUSH
97670: LD_INT 23
97672: PUSH
97673: LD_INT 25
97675: PUSH
97676: LD_INT 26
97678: PUSH
97679: EMPTY
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: LIST
97688: LIST
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: PUSH
97695: LD_INT 101
97697: PUSH
97698: LD_INT 102
97700: PUSH
97701: LD_INT 103
97703: PUSH
97704: LD_INT 105
97706: PUSH
97707: LD_INT 106
97709: PUSH
97710: LD_INT 108
97712: PUSH
97713: LD_INT 112
97715: PUSH
97716: LD_INT 116
97718: PUSH
97719: LD_INT 117
97721: PUSH
97722: LD_INT 118
97724: PUSH
97725: EMPTY
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: PUSH
97737: EMPTY
97738: LIST
97739: LIST
97740: ST_TO_ADDR
97741: GO 100144
97743: LD_INT 8
97745: DOUBLE
97746: EQUAL
97747: IFTRUE 97751
97749: GO 97891
97751: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97752: LD_ADDR_VAR 0 2
97756: PUSH
97757: LD_INT 2
97759: PUSH
97760: LD_INT 4
97762: PUSH
97763: LD_INT 5
97765: PUSH
97766: LD_INT 6
97768: PUSH
97769: LD_INT 7
97771: PUSH
97772: LD_INT 8
97774: PUSH
97775: LD_INT 11
97777: PUSH
97778: LD_INT 12
97780: PUSH
97781: LD_INT 15
97783: PUSH
97784: LD_INT 16
97786: PUSH
97787: LD_INT 20
97789: PUSH
97790: LD_INT 21
97792: PUSH
97793: LD_INT 22
97795: PUSH
97796: LD_INT 23
97798: PUSH
97799: LD_INT 25
97801: PUSH
97802: LD_INT 26
97804: PUSH
97805: LD_INT 30
97807: PUSH
97808: LD_INT 31
97810: PUSH
97811: LD_INT 32
97813: PUSH
97814: LD_INT 36
97816: PUSH
97817: EMPTY
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: PUSH
97839: LD_INT 101
97841: PUSH
97842: LD_INT 102
97844: PUSH
97845: LD_INT 103
97847: PUSH
97848: LD_INT 105
97850: PUSH
97851: LD_INT 106
97853: PUSH
97854: LD_INT 108
97856: PUSH
97857: LD_INT 109
97859: PUSH
97860: LD_INT 112
97862: PUSH
97863: LD_INT 116
97865: PUSH
97866: LD_INT 117
97868: PUSH
97869: LD_INT 118
97871: PUSH
97872: EMPTY
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: ST_TO_ADDR
97889: GO 100144
97891: LD_INT 9
97893: DOUBLE
97894: EQUAL
97895: IFTRUE 97899
97897: GO 98047
97899: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97900: LD_ADDR_VAR 0 2
97904: PUSH
97905: LD_INT 2
97907: PUSH
97908: LD_INT 4
97910: PUSH
97911: LD_INT 5
97913: PUSH
97914: LD_INT 6
97916: PUSH
97917: LD_INT 7
97919: PUSH
97920: LD_INT 8
97922: PUSH
97923: LD_INT 11
97925: PUSH
97926: LD_INT 12
97928: PUSH
97929: LD_INT 15
97931: PUSH
97932: LD_INT 16
97934: PUSH
97935: LD_INT 20
97937: PUSH
97938: LD_INT 21
97940: PUSH
97941: LD_INT 22
97943: PUSH
97944: LD_INT 23
97946: PUSH
97947: LD_INT 25
97949: PUSH
97950: LD_INT 26
97952: PUSH
97953: LD_INT 28
97955: PUSH
97956: LD_INT 30
97958: PUSH
97959: LD_INT 31
97961: PUSH
97962: LD_INT 32
97964: PUSH
97965: LD_INT 36
97967: PUSH
97968: EMPTY
97969: LIST
97970: LIST
97971: LIST
97972: LIST
97973: LIST
97974: LIST
97975: LIST
97976: LIST
97977: LIST
97978: LIST
97979: LIST
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: LIST
97990: PUSH
97991: LD_INT 101
97993: PUSH
97994: LD_INT 102
97996: PUSH
97997: LD_INT 103
97999: PUSH
98000: LD_INT 105
98002: PUSH
98003: LD_INT 106
98005: PUSH
98006: LD_INT 108
98008: PUSH
98009: LD_INT 109
98011: PUSH
98012: LD_INT 112
98014: PUSH
98015: LD_INT 114
98017: PUSH
98018: LD_INT 116
98020: PUSH
98021: LD_INT 117
98023: PUSH
98024: LD_INT 118
98026: PUSH
98027: EMPTY
98028: LIST
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: PUSH
98041: EMPTY
98042: LIST
98043: LIST
98044: ST_TO_ADDR
98045: GO 100144
98047: LD_INT 10
98049: DOUBLE
98050: EQUAL
98051: IFTRUE 98055
98053: GO 98251
98055: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
98056: LD_ADDR_VAR 0 2
98060: PUSH
98061: LD_INT 2
98063: PUSH
98064: LD_INT 4
98066: PUSH
98067: LD_INT 5
98069: PUSH
98070: LD_INT 6
98072: PUSH
98073: LD_INT 7
98075: PUSH
98076: LD_INT 8
98078: PUSH
98079: LD_INT 9
98081: PUSH
98082: LD_INT 10
98084: PUSH
98085: LD_INT 11
98087: PUSH
98088: LD_INT 12
98090: PUSH
98091: LD_INT 13
98093: PUSH
98094: LD_INT 14
98096: PUSH
98097: LD_INT 15
98099: PUSH
98100: LD_INT 16
98102: PUSH
98103: LD_INT 17
98105: PUSH
98106: LD_INT 18
98108: PUSH
98109: LD_INT 19
98111: PUSH
98112: LD_INT 20
98114: PUSH
98115: LD_INT 21
98117: PUSH
98118: LD_INT 22
98120: PUSH
98121: LD_INT 23
98123: PUSH
98124: LD_INT 24
98126: PUSH
98127: LD_INT 25
98129: PUSH
98130: LD_INT 26
98132: PUSH
98133: LD_INT 28
98135: PUSH
98136: LD_INT 30
98138: PUSH
98139: LD_INT 31
98141: PUSH
98142: LD_INT 32
98144: PUSH
98145: LD_INT 36
98147: PUSH
98148: EMPTY
98149: LIST
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: LIST
98155: LIST
98156: LIST
98157: LIST
98158: LIST
98159: LIST
98160: LIST
98161: LIST
98162: LIST
98163: LIST
98164: LIST
98165: LIST
98166: LIST
98167: LIST
98168: LIST
98169: LIST
98170: LIST
98171: LIST
98172: LIST
98173: LIST
98174: LIST
98175: LIST
98176: LIST
98177: LIST
98178: PUSH
98179: LD_INT 101
98181: PUSH
98182: LD_INT 102
98184: PUSH
98185: LD_INT 103
98187: PUSH
98188: LD_INT 104
98190: PUSH
98191: LD_INT 105
98193: PUSH
98194: LD_INT 106
98196: PUSH
98197: LD_INT 107
98199: PUSH
98200: LD_INT 108
98202: PUSH
98203: LD_INT 109
98205: PUSH
98206: LD_INT 110
98208: PUSH
98209: LD_INT 111
98211: PUSH
98212: LD_INT 112
98214: PUSH
98215: LD_INT 114
98217: PUSH
98218: LD_INT 116
98220: PUSH
98221: LD_INT 117
98223: PUSH
98224: LD_INT 118
98226: PUSH
98227: EMPTY
98228: LIST
98229: LIST
98230: LIST
98231: LIST
98232: LIST
98233: LIST
98234: LIST
98235: LIST
98236: LIST
98237: LIST
98238: LIST
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: PUSH
98245: EMPTY
98246: LIST
98247: LIST
98248: ST_TO_ADDR
98249: GO 100144
98251: LD_INT 11
98253: DOUBLE
98254: EQUAL
98255: IFTRUE 98259
98257: GO 98463
98259: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
98260: LD_ADDR_VAR 0 2
98264: PUSH
98265: LD_INT 2
98267: PUSH
98268: LD_INT 3
98270: PUSH
98271: LD_INT 4
98273: PUSH
98274: LD_INT 5
98276: PUSH
98277: LD_INT 6
98279: PUSH
98280: LD_INT 7
98282: PUSH
98283: LD_INT 8
98285: PUSH
98286: LD_INT 9
98288: PUSH
98289: LD_INT 10
98291: PUSH
98292: LD_INT 11
98294: PUSH
98295: LD_INT 12
98297: PUSH
98298: LD_INT 13
98300: PUSH
98301: LD_INT 14
98303: PUSH
98304: LD_INT 15
98306: PUSH
98307: LD_INT 16
98309: PUSH
98310: LD_INT 17
98312: PUSH
98313: LD_INT 18
98315: PUSH
98316: LD_INT 19
98318: PUSH
98319: LD_INT 20
98321: PUSH
98322: LD_INT 21
98324: PUSH
98325: LD_INT 22
98327: PUSH
98328: LD_INT 23
98330: PUSH
98331: LD_INT 24
98333: PUSH
98334: LD_INT 25
98336: PUSH
98337: LD_INT 26
98339: PUSH
98340: LD_INT 28
98342: PUSH
98343: LD_INT 30
98345: PUSH
98346: LD_INT 31
98348: PUSH
98349: LD_INT 32
98351: PUSH
98352: LD_INT 34
98354: PUSH
98355: LD_INT 36
98357: PUSH
98358: EMPTY
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: LIST
98366: LIST
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: LIST
98372: LIST
98373: LIST
98374: LIST
98375: LIST
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: LIST
98381: LIST
98382: LIST
98383: LIST
98384: LIST
98385: LIST
98386: LIST
98387: LIST
98388: LIST
98389: LIST
98390: PUSH
98391: LD_INT 101
98393: PUSH
98394: LD_INT 102
98396: PUSH
98397: LD_INT 103
98399: PUSH
98400: LD_INT 104
98402: PUSH
98403: LD_INT 105
98405: PUSH
98406: LD_INT 106
98408: PUSH
98409: LD_INT 107
98411: PUSH
98412: LD_INT 108
98414: PUSH
98415: LD_INT 109
98417: PUSH
98418: LD_INT 110
98420: PUSH
98421: LD_INT 111
98423: PUSH
98424: LD_INT 112
98426: PUSH
98427: LD_INT 114
98429: PUSH
98430: LD_INT 116
98432: PUSH
98433: LD_INT 117
98435: PUSH
98436: LD_INT 118
98438: PUSH
98439: EMPTY
98440: LIST
98441: LIST
98442: LIST
98443: LIST
98444: LIST
98445: LIST
98446: LIST
98447: LIST
98448: LIST
98449: LIST
98450: LIST
98451: LIST
98452: LIST
98453: LIST
98454: LIST
98455: LIST
98456: PUSH
98457: EMPTY
98458: LIST
98459: LIST
98460: ST_TO_ADDR
98461: GO 100144
98463: LD_INT 12
98465: DOUBLE
98466: EQUAL
98467: IFTRUE 98471
98469: GO 98691
98471: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
98472: LD_ADDR_VAR 0 2
98476: PUSH
98477: LD_INT 1
98479: PUSH
98480: LD_INT 2
98482: PUSH
98483: LD_INT 3
98485: PUSH
98486: LD_INT 4
98488: PUSH
98489: LD_INT 5
98491: PUSH
98492: LD_INT 6
98494: PUSH
98495: LD_INT 7
98497: PUSH
98498: LD_INT 8
98500: PUSH
98501: LD_INT 9
98503: PUSH
98504: LD_INT 10
98506: PUSH
98507: LD_INT 11
98509: PUSH
98510: LD_INT 12
98512: PUSH
98513: LD_INT 13
98515: PUSH
98516: LD_INT 14
98518: PUSH
98519: LD_INT 15
98521: PUSH
98522: LD_INT 16
98524: PUSH
98525: LD_INT 17
98527: PUSH
98528: LD_INT 18
98530: PUSH
98531: LD_INT 19
98533: PUSH
98534: LD_INT 20
98536: PUSH
98537: LD_INT 21
98539: PUSH
98540: LD_INT 22
98542: PUSH
98543: LD_INT 23
98545: PUSH
98546: LD_INT 24
98548: PUSH
98549: LD_INT 25
98551: PUSH
98552: LD_INT 26
98554: PUSH
98555: LD_INT 27
98557: PUSH
98558: LD_INT 28
98560: PUSH
98561: LD_INT 30
98563: PUSH
98564: LD_INT 31
98566: PUSH
98567: LD_INT 32
98569: PUSH
98570: LD_INT 33
98572: PUSH
98573: LD_INT 34
98575: PUSH
98576: LD_INT 36
98578: PUSH
98579: EMPTY
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: LIST
98589: LIST
98590: LIST
98591: LIST
98592: LIST
98593: LIST
98594: LIST
98595: LIST
98596: LIST
98597: LIST
98598: LIST
98599: LIST
98600: LIST
98601: LIST
98602: LIST
98603: LIST
98604: LIST
98605: LIST
98606: LIST
98607: LIST
98608: LIST
98609: LIST
98610: LIST
98611: LIST
98612: LIST
98613: LIST
98614: PUSH
98615: LD_INT 101
98617: PUSH
98618: LD_INT 102
98620: PUSH
98621: LD_INT 103
98623: PUSH
98624: LD_INT 104
98626: PUSH
98627: LD_INT 105
98629: PUSH
98630: LD_INT 106
98632: PUSH
98633: LD_INT 107
98635: PUSH
98636: LD_INT 108
98638: PUSH
98639: LD_INT 109
98641: PUSH
98642: LD_INT 110
98644: PUSH
98645: LD_INT 111
98647: PUSH
98648: LD_INT 112
98650: PUSH
98651: LD_INT 113
98653: PUSH
98654: LD_INT 114
98656: PUSH
98657: LD_INT 116
98659: PUSH
98660: LD_INT 117
98662: PUSH
98663: LD_INT 118
98665: PUSH
98666: EMPTY
98667: LIST
98668: LIST
98669: LIST
98670: LIST
98671: LIST
98672: LIST
98673: LIST
98674: LIST
98675: LIST
98676: LIST
98677: LIST
98678: LIST
98679: LIST
98680: LIST
98681: LIST
98682: LIST
98683: LIST
98684: PUSH
98685: EMPTY
98686: LIST
98687: LIST
98688: ST_TO_ADDR
98689: GO 100144
98691: LD_INT 13
98693: DOUBLE
98694: EQUAL
98695: IFTRUE 98699
98697: GO 98907
98699: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98700: LD_ADDR_VAR 0 2
98704: PUSH
98705: LD_INT 1
98707: PUSH
98708: LD_INT 2
98710: PUSH
98711: LD_INT 3
98713: PUSH
98714: LD_INT 4
98716: PUSH
98717: LD_INT 5
98719: PUSH
98720: LD_INT 8
98722: PUSH
98723: LD_INT 9
98725: PUSH
98726: LD_INT 10
98728: PUSH
98729: LD_INT 11
98731: PUSH
98732: LD_INT 12
98734: PUSH
98735: LD_INT 14
98737: PUSH
98738: LD_INT 15
98740: PUSH
98741: LD_INT 16
98743: PUSH
98744: LD_INT 17
98746: PUSH
98747: LD_INT 18
98749: PUSH
98750: LD_INT 19
98752: PUSH
98753: LD_INT 20
98755: PUSH
98756: LD_INT 21
98758: PUSH
98759: LD_INT 22
98761: PUSH
98762: LD_INT 23
98764: PUSH
98765: LD_INT 24
98767: PUSH
98768: LD_INT 25
98770: PUSH
98771: LD_INT 26
98773: PUSH
98774: LD_INT 27
98776: PUSH
98777: LD_INT 28
98779: PUSH
98780: LD_INT 30
98782: PUSH
98783: LD_INT 31
98785: PUSH
98786: LD_INT 32
98788: PUSH
98789: LD_INT 33
98791: PUSH
98792: LD_INT 34
98794: PUSH
98795: LD_INT 36
98797: PUSH
98798: EMPTY
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: PUSH
98831: LD_INT 101
98833: PUSH
98834: LD_INT 102
98836: PUSH
98837: LD_INT 103
98839: PUSH
98840: LD_INT 104
98842: PUSH
98843: LD_INT 105
98845: PUSH
98846: LD_INT 106
98848: PUSH
98849: LD_INT 107
98851: PUSH
98852: LD_INT 108
98854: PUSH
98855: LD_INT 109
98857: PUSH
98858: LD_INT 110
98860: PUSH
98861: LD_INT 111
98863: PUSH
98864: LD_INT 112
98866: PUSH
98867: LD_INT 113
98869: PUSH
98870: LD_INT 114
98872: PUSH
98873: LD_INT 116
98875: PUSH
98876: LD_INT 117
98878: PUSH
98879: LD_INT 118
98881: PUSH
98882: EMPTY
98883: LIST
98884: LIST
98885: LIST
98886: LIST
98887: LIST
98888: LIST
98889: LIST
98890: LIST
98891: LIST
98892: LIST
98893: LIST
98894: LIST
98895: LIST
98896: LIST
98897: LIST
98898: LIST
98899: LIST
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: ST_TO_ADDR
98905: GO 100144
98907: LD_INT 14
98909: DOUBLE
98910: EQUAL
98911: IFTRUE 98915
98913: GO 99139
98915: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98916: LD_ADDR_VAR 0 2
98920: PUSH
98921: LD_INT 1
98923: PUSH
98924: LD_INT 2
98926: PUSH
98927: LD_INT 3
98929: PUSH
98930: LD_INT 4
98932: PUSH
98933: LD_INT 5
98935: PUSH
98936: LD_INT 6
98938: PUSH
98939: LD_INT 7
98941: PUSH
98942: LD_INT 8
98944: PUSH
98945: LD_INT 9
98947: PUSH
98948: LD_INT 10
98950: PUSH
98951: LD_INT 11
98953: PUSH
98954: LD_INT 12
98956: PUSH
98957: LD_INT 13
98959: PUSH
98960: LD_INT 14
98962: PUSH
98963: LD_INT 15
98965: PUSH
98966: LD_INT 16
98968: PUSH
98969: LD_INT 17
98971: PUSH
98972: LD_INT 18
98974: PUSH
98975: LD_INT 19
98977: PUSH
98978: LD_INT 20
98980: PUSH
98981: LD_INT 21
98983: PUSH
98984: LD_INT 22
98986: PUSH
98987: LD_INT 23
98989: PUSH
98990: LD_INT 24
98992: PUSH
98993: LD_INT 25
98995: PUSH
98996: LD_INT 26
98998: PUSH
98999: LD_INT 27
99001: PUSH
99002: LD_INT 28
99004: PUSH
99005: LD_INT 29
99007: PUSH
99008: LD_INT 30
99010: PUSH
99011: LD_INT 31
99013: PUSH
99014: LD_INT 32
99016: PUSH
99017: LD_INT 33
99019: PUSH
99020: LD_INT 34
99022: PUSH
99023: LD_INT 36
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: LIST
99030: LIST
99031: LIST
99032: LIST
99033: LIST
99034: LIST
99035: LIST
99036: LIST
99037: LIST
99038: LIST
99039: LIST
99040: LIST
99041: LIST
99042: LIST
99043: LIST
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: LIST
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: LIST
99062: PUSH
99063: LD_INT 101
99065: PUSH
99066: LD_INT 102
99068: PUSH
99069: LD_INT 103
99071: PUSH
99072: LD_INT 104
99074: PUSH
99075: LD_INT 105
99077: PUSH
99078: LD_INT 106
99080: PUSH
99081: LD_INT 107
99083: PUSH
99084: LD_INT 108
99086: PUSH
99087: LD_INT 109
99089: PUSH
99090: LD_INT 110
99092: PUSH
99093: LD_INT 111
99095: PUSH
99096: LD_INT 112
99098: PUSH
99099: LD_INT 113
99101: PUSH
99102: LD_INT 114
99104: PUSH
99105: LD_INT 116
99107: PUSH
99108: LD_INT 117
99110: PUSH
99111: LD_INT 118
99113: PUSH
99114: EMPTY
99115: LIST
99116: LIST
99117: LIST
99118: LIST
99119: LIST
99120: LIST
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: LIST
99126: LIST
99127: LIST
99128: LIST
99129: LIST
99130: LIST
99131: LIST
99132: PUSH
99133: EMPTY
99134: LIST
99135: LIST
99136: ST_TO_ADDR
99137: GO 100144
99139: LD_INT 15
99141: DOUBLE
99142: EQUAL
99143: IFTRUE 99147
99145: GO 99371
99147: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
99148: LD_ADDR_VAR 0 2
99152: PUSH
99153: LD_INT 1
99155: PUSH
99156: LD_INT 2
99158: PUSH
99159: LD_INT 3
99161: PUSH
99162: LD_INT 4
99164: PUSH
99165: LD_INT 5
99167: PUSH
99168: LD_INT 6
99170: PUSH
99171: LD_INT 7
99173: PUSH
99174: LD_INT 8
99176: PUSH
99177: LD_INT 9
99179: PUSH
99180: LD_INT 10
99182: PUSH
99183: LD_INT 11
99185: PUSH
99186: LD_INT 12
99188: PUSH
99189: LD_INT 13
99191: PUSH
99192: LD_INT 14
99194: PUSH
99195: LD_INT 15
99197: PUSH
99198: LD_INT 16
99200: PUSH
99201: LD_INT 17
99203: PUSH
99204: LD_INT 18
99206: PUSH
99207: LD_INT 19
99209: PUSH
99210: LD_INT 20
99212: PUSH
99213: LD_INT 21
99215: PUSH
99216: LD_INT 22
99218: PUSH
99219: LD_INT 23
99221: PUSH
99222: LD_INT 24
99224: PUSH
99225: LD_INT 25
99227: PUSH
99228: LD_INT 26
99230: PUSH
99231: LD_INT 27
99233: PUSH
99234: LD_INT 28
99236: PUSH
99237: LD_INT 29
99239: PUSH
99240: LD_INT 30
99242: PUSH
99243: LD_INT 31
99245: PUSH
99246: LD_INT 32
99248: PUSH
99249: LD_INT 33
99251: PUSH
99252: LD_INT 34
99254: PUSH
99255: LD_INT 36
99257: PUSH
99258: EMPTY
99259: LIST
99260: LIST
99261: LIST
99262: LIST
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: LIST
99277: LIST
99278: LIST
99279: LIST
99280: LIST
99281: LIST
99282: LIST
99283: LIST
99284: LIST
99285: LIST
99286: LIST
99287: LIST
99288: LIST
99289: LIST
99290: LIST
99291: LIST
99292: LIST
99293: LIST
99294: PUSH
99295: LD_INT 101
99297: PUSH
99298: LD_INT 102
99300: PUSH
99301: LD_INT 103
99303: PUSH
99304: LD_INT 104
99306: PUSH
99307: LD_INT 105
99309: PUSH
99310: LD_INT 106
99312: PUSH
99313: LD_INT 107
99315: PUSH
99316: LD_INT 108
99318: PUSH
99319: LD_INT 109
99321: PUSH
99322: LD_INT 110
99324: PUSH
99325: LD_INT 111
99327: PUSH
99328: LD_INT 112
99330: PUSH
99331: LD_INT 113
99333: PUSH
99334: LD_INT 114
99336: PUSH
99337: LD_INT 116
99339: PUSH
99340: LD_INT 117
99342: PUSH
99343: LD_INT 118
99345: PUSH
99346: EMPTY
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: LIST
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: LIST
99361: LIST
99362: LIST
99363: LIST
99364: PUSH
99365: EMPTY
99366: LIST
99367: LIST
99368: ST_TO_ADDR
99369: GO 100144
99371: LD_INT 16
99373: DOUBLE
99374: EQUAL
99375: IFTRUE 99379
99377: GO 99515
99379: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
99380: LD_ADDR_VAR 0 2
99384: PUSH
99385: LD_INT 2
99387: PUSH
99388: LD_INT 4
99390: PUSH
99391: LD_INT 5
99393: PUSH
99394: LD_INT 7
99396: PUSH
99397: LD_INT 11
99399: PUSH
99400: LD_INT 12
99402: PUSH
99403: LD_INT 15
99405: PUSH
99406: LD_INT 16
99408: PUSH
99409: LD_INT 20
99411: PUSH
99412: LD_INT 21
99414: PUSH
99415: LD_INT 22
99417: PUSH
99418: LD_INT 23
99420: PUSH
99421: LD_INT 25
99423: PUSH
99424: LD_INT 26
99426: PUSH
99427: LD_INT 30
99429: PUSH
99430: LD_INT 31
99432: PUSH
99433: LD_INT 32
99435: PUSH
99436: LD_INT 33
99438: PUSH
99439: LD_INT 34
99441: PUSH
99442: EMPTY
99443: LIST
99444: LIST
99445: LIST
99446: LIST
99447: LIST
99448: LIST
99449: LIST
99450: LIST
99451: LIST
99452: LIST
99453: LIST
99454: LIST
99455: LIST
99456: LIST
99457: LIST
99458: LIST
99459: LIST
99460: LIST
99461: LIST
99462: PUSH
99463: LD_INT 101
99465: PUSH
99466: LD_INT 102
99468: PUSH
99469: LD_INT 103
99471: PUSH
99472: LD_INT 106
99474: PUSH
99475: LD_INT 108
99477: PUSH
99478: LD_INT 112
99480: PUSH
99481: LD_INT 113
99483: PUSH
99484: LD_INT 114
99486: PUSH
99487: LD_INT 116
99489: PUSH
99490: LD_INT 117
99492: PUSH
99493: LD_INT 118
99495: PUSH
99496: EMPTY
99497: LIST
99498: LIST
99499: LIST
99500: LIST
99501: LIST
99502: LIST
99503: LIST
99504: LIST
99505: LIST
99506: LIST
99507: LIST
99508: PUSH
99509: EMPTY
99510: LIST
99511: LIST
99512: ST_TO_ADDR
99513: GO 100144
99515: LD_INT 17
99517: DOUBLE
99518: EQUAL
99519: IFTRUE 99523
99521: GO 99747
99523: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99524: LD_ADDR_VAR 0 2
99528: PUSH
99529: LD_INT 1
99531: PUSH
99532: LD_INT 2
99534: PUSH
99535: LD_INT 3
99537: PUSH
99538: LD_INT 4
99540: PUSH
99541: LD_INT 5
99543: PUSH
99544: LD_INT 6
99546: PUSH
99547: LD_INT 7
99549: PUSH
99550: LD_INT 8
99552: PUSH
99553: LD_INT 9
99555: PUSH
99556: LD_INT 10
99558: PUSH
99559: LD_INT 11
99561: PUSH
99562: LD_INT 12
99564: PUSH
99565: LD_INT 13
99567: PUSH
99568: LD_INT 14
99570: PUSH
99571: LD_INT 15
99573: PUSH
99574: LD_INT 16
99576: PUSH
99577: LD_INT 17
99579: PUSH
99580: LD_INT 18
99582: PUSH
99583: LD_INT 19
99585: PUSH
99586: LD_INT 20
99588: PUSH
99589: LD_INT 21
99591: PUSH
99592: LD_INT 22
99594: PUSH
99595: LD_INT 23
99597: PUSH
99598: LD_INT 24
99600: PUSH
99601: LD_INT 25
99603: PUSH
99604: LD_INT 26
99606: PUSH
99607: LD_INT 27
99609: PUSH
99610: LD_INT 28
99612: PUSH
99613: LD_INT 29
99615: PUSH
99616: LD_INT 30
99618: PUSH
99619: LD_INT 31
99621: PUSH
99622: LD_INT 32
99624: PUSH
99625: LD_INT 33
99627: PUSH
99628: LD_INT 34
99630: PUSH
99631: LD_INT 36
99633: PUSH
99634: EMPTY
99635: LIST
99636: LIST
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: LIST
99642: LIST
99643: LIST
99644: LIST
99645: LIST
99646: LIST
99647: LIST
99648: LIST
99649: LIST
99650: LIST
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: LIST
99657: LIST
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: PUSH
99671: LD_INT 101
99673: PUSH
99674: LD_INT 102
99676: PUSH
99677: LD_INT 103
99679: PUSH
99680: LD_INT 104
99682: PUSH
99683: LD_INT 105
99685: PUSH
99686: LD_INT 106
99688: PUSH
99689: LD_INT 107
99691: PUSH
99692: LD_INT 108
99694: PUSH
99695: LD_INT 109
99697: PUSH
99698: LD_INT 110
99700: PUSH
99701: LD_INT 111
99703: PUSH
99704: LD_INT 112
99706: PUSH
99707: LD_INT 113
99709: PUSH
99710: LD_INT 114
99712: PUSH
99713: LD_INT 116
99715: PUSH
99716: LD_INT 117
99718: PUSH
99719: LD_INT 118
99721: PUSH
99722: EMPTY
99723: LIST
99724: LIST
99725: LIST
99726: LIST
99727: LIST
99728: LIST
99729: LIST
99730: LIST
99731: LIST
99732: LIST
99733: LIST
99734: LIST
99735: LIST
99736: LIST
99737: LIST
99738: LIST
99739: LIST
99740: PUSH
99741: EMPTY
99742: LIST
99743: LIST
99744: ST_TO_ADDR
99745: GO 100144
99747: LD_INT 18
99749: DOUBLE
99750: EQUAL
99751: IFTRUE 99755
99753: GO 99903
99755: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99756: LD_ADDR_VAR 0 2
99760: PUSH
99761: LD_INT 2
99763: PUSH
99764: LD_INT 4
99766: PUSH
99767: LD_INT 5
99769: PUSH
99770: LD_INT 7
99772: PUSH
99773: LD_INT 11
99775: PUSH
99776: LD_INT 12
99778: PUSH
99779: LD_INT 15
99781: PUSH
99782: LD_INT 16
99784: PUSH
99785: LD_INT 20
99787: PUSH
99788: LD_INT 21
99790: PUSH
99791: LD_INT 22
99793: PUSH
99794: LD_INT 23
99796: PUSH
99797: LD_INT 25
99799: PUSH
99800: LD_INT 26
99802: PUSH
99803: LD_INT 30
99805: PUSH
99806: LD_INT 31
99808: PUSH
99809: LD_INT 32
99811: PUSH
99812: LD_INT 33
99814: PUSH
99815: LD_INT 34
99817: PUSH
99818: LD_INT 35
99820: PUSH
99821: LD_INT 36
99823: PUSH
99824: EMPTY
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: LIST
99833: LIST
99834: LIST
99835: LIST
99836: LIST
99837: LIST
99838: LIST
99839: LIST
99840: LIST
99841: LIST
99842: LIST
99843: LIST
99844: LIST
99845: LIST
99846: PUSH
99847: LD_INT 101
99849: PUSH
99850: LD_INT 102
99852: PUSH
99853: LD_INT 103
99855: PUSH
99856: LD_INT 106
99858: PUSH
99859: LD_INT 108
99861: PUSH
99862: LD_INT 112
99864: PUSH
99865: LD_INT 113
99867: PUSH
99868: LD_INT 114
99870: PUSH
99871: LD_INT 115
99873: PUSH
99874: LD_INT 116
99876: PUSH
99877: LD_INT 117
99879: PUSH
99880: LD_INT 118
99882: PUSH
99883: EMPTY
99884: LIST
99885: LIST
99886: LIST
99887: LIST
99888: LIST
99889: LIST
99890: LIST
99891: LIST
99892: LIST
99893: LIST
99894: LIST
99895: LIST
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: ST_TO_ADDR
99901: GO 100144
99903: LD_INT 19
99905: DOUBLE
99906: EQUAL
99907: IFTRUE 99911
99909: GO 100143
99911: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99912: LD_ADDR_VAR 0 2
99916: PUSH
99917: LD_INT 1
99919: PUSH
99920: LD_INT 2
99922: PUSH
99923: LD_INT 3
99925: PUSH
99926: LD_INT 4
99928: PUSH
99929: LD_INT 5
99931: PUSH
99932: LD_INT 6
99934: PUSH
99935: LD_INT 7
99937: PUSH
99938: LD_INT 8
99940: PUSH
99941: LD_INT 9
99943: PUSH
99944: LD_INT 10
99946: PUSH
99947: LD_INT 11
99949: PUSH
99950: LD_INT 12
99952: PUSH
99953: LD_INT 13
99955: PUSH
99956: LD_INT 14
99958: PUSH
99959: LD_INT 15
99961: PUSH
99962: LD_INT 16
99964: PUSH
99965: LD_INT 17
99967: PUSH
99968: LD_INT 18
99970: PUSH
99971: LD_INT 19
99973: PUSH
99974: LD_INT 20
99976: PUSH
99977: LD_INT 21
99979: PUSH
99980: LD_INT 22
99982: PUSH
99983: LD_INT 23
99985: PUSH
99986: LD_INT 24
99988: PUSH
99989: LD_INT 25
99991: PUSH
99992: LD_INT 26
99994: PUSH
99995: LD_INT 27
99997: PUSH
99998: LD_INT 28
100000: PUSH
100001: LD_INT 29
100003: PUSH
100004: LD_INT 30
100006: PUSH
100007: LD_INT 31
100009: PUSH
100010: LD_INT 32
100012: PUSH
100013: LD_INT 33
100015: PUSH
100016: LD_INT 34
100018: PUSH
100019: LD_INT 35
100021: PUSH
100022: LD_INT 36
100024: PUSH
100025: EMPTY
100026: LIST
100027: LIST
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: LIST
100033: LIST
100034: LIST
100035: LIST
100036: LIST
100037: LIST
100038: LIST
100039: LIST
100040: LIST
100041: LIST
100042: LIST
100043: LIST
100044: LIST
100045: LIST
100046: LIST
100047: LIST
100048: LIST
100049: LIST
100050: LIST
100051: LIST
100052: LIST
100053: LIST
100054: LIST
100055: LIST
100056: LIST
100057: LIST
100058: LIST
100059: LIST
100060: LIST
100061: LIST
100062: PUSH
100063: LD_INT 101
100065: PUSH
100066: LD_INT 102
100068: PUSH
100069: LD_INT 103
100071: PUSH
100072: LD_INT 104
100074: PUSH
100075: LD_INT 105
100077: PUSH
100078: LD_INT 106
100080: PUSH
100081: LD_INT 107
100083: PUSH
100084: LD_INT 108
100086: PUSH
100087: LD_INT 109
100089: PUSH
100090: LD_INT 110
100092: PUSH
100093: LD_INT 111
100095: PUSH
100096: LD_INT 112
100098: PUSH
100099: LD_INT 113
100101: PUSH
100102: LD_INT 114
100104: PUSH
100105: LD_INT 115
100107: PUSH
100108: LD_INT 116
100110: PUSH
100111: LD_INT 117
100113: PUSH
100114: LD_INT 118
100116: PUSH
100117: EMPTY
100118: LIST
100119: LIST
100120: LIST
100121: LIST
100122: LIST
100123: LIST
100124: LIST
100125: LIST
100126: LIST
100127: LIST
100128: LIST
100129: LIST
100130: LIST
100131: LIST
100132: LIST
100133: LIST
100134: LIST
100135: LIST
100136: PUSH
100137: EMPTY
100138: LIST
100139: LIST
100140: ST_TO_ADDR
100141: GO 100144
100143: POP
// end else
100144: GO 100375
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
100146: LD_ADDR_VAR 0 2
100150: PUSH
100151: LD_INT 1
100153: PUSH
100154: LD_INT 2
100156: PUSH
100157: LD_INT 3
100159: PUSH
100160: LD_INT 4
100162: PUSH
100163: LD_INT 5
100165: PUSH
100166: LD_INT 6
100168: PUSH
100169: LD_INT 7
100171: PUSH
100172: LD_INT 8
100174: PUSH
100175: LD_INT 9
100177: PUSH
100178: LD_INT 10
100180: PUSH
100181: LD_INT 11
100183: PUSH
100184: LD_INT 12
100186: PUSH
100187: LD_INT 13
100189: PUSH
100190: LD_INT 14
100192: PUSH
100193: LD_INT 15
100195: PUSH
100196: LD_INT 16
100198: PUSH
100199: LD_INT 17
100201: PUSH
100202: LD_INT 18
100204: PUSH
100205: LD_INT 19
100207: PUSH
100208: LD_INT 20
100210: PUSH
100211: LD_INT 21
100213: PUSH
100214: LD_INT 22
100216: PUSH
100217: LD_INT 23
100219: PUSH
100220: LD_INT 24
100222: PUSH
100223: LD_INT 25
100225: PUSH
100226: LD_INT 26
100228: PUSH
100229: LD_INT 27
100231: PUSH
100232: LD_INT 28
100234: PUSH
100235: LD_INT 29
100237: PUSH
100238: LD_INT 30
100240: PUSH
100241: LD_INT 31
100243: PUSH
100244: LD_INT 32
100246: PUSH
100247: LD_INT 33
100249: PUSH
100250: LD_INT 34
100252: PUSH
100253: LD_INT 35
100255: PUSH
100256: LD_INT 36
100258: PUSH
100259: EMPTY
100260: LIST
100261: LIST
100262: LIST
100263: LIST
100264: LIST
100265: LIST
100266: LIST
100267: LIST
100268: LIST
100269: LIST
100270: LIST
100271: LIST
100272: LIST
100273: LIST
100274: LIST
100275: LIST
100276: LIST
100277: LIST
100278: LIST
100279: LIST
100280: LIST
100281: LIST
100282: LIST
100283: LIST
100284: LIST
100285: LIST
100286: LIST
100287: LIST
100288: LIST
100289: LIST
100290: LIST
100291: LIST
100292: LIST
100293: LIST
100294: LIST
100295: LIST
100296: PUSH
100297: LD_INT 101
100299: PUSH
100300: LD_INT 102
100302: PUSH
100303: LD_INT 103
100305: PUSH
100306: LD_INT 104
100308: PUSH
100309: LD_INT 105
100311: PUSH
100312: LD_INT 106
100314: PUSH
100315: LD_INT 107
100317: PUSH
100318: LD_INT 108
100320: PUSH
100321: LD_INT 109
100323: PUSH
100324: LD_INT 110
100326: PUSH
100327: LD_INT 111
100329: PUSH
100330: LD_INT 112
100332: PUSH
100333: LD_INT 113
100335: PUSH
100336: LD_INT 114
100338: PUSH
100339: LD_INT 115
100341: PUSH
100342: LD_INT 116
100344: PUSH
100345: LD_INT 117
100347: PUSH
100348: LD_INT 118
100350: PUSH
100351: EMPTY
100352: LIST
100353: LIST
100354: LIST
100355: LIST
100356: LIST
100357: LIST
100358: LIST
100359: LIST
100360: LIST
100361: LIST
100362: LIST
100363: LIST
100364: LIST
100365: LIST
100366: LIST
100367: LIST
100368: LIST
100369: LIST
100370: PUSH
100371: EMPTY
100372: LIST
100373: LIST
100374: ST_TO_ADDR
// if result then
100375: LD_VAR 0 2
100379: IFFALSE 101165
// begin normal :=  ;
100381: LD_ADDR_VAR 0 5
100385: PUSH
100386: LD_STRING 
100388: ST_TO_ADDR
// hardcore :=  ;
100389: LD_ADDR_VAR 0 6
100393: PUSH
100394: LD_STRING 
100396: ST_TO_ADDR
// active :=  ;
100397: LD_ADDR_VAR 0 7
100401: PUSH
100402: LD_STRING 
100404: ST_TO_ADDR
// for i = 1 to normalCounter do
100405: LD_ADDR_VAR 0 8
100409: PUSH
100410: DOUBLE
100411: LD_INT 1
100413: DEC
100414: ST_TO_ADDR
100415: LD_EXP 80
100419: PUSH
100420: FOR_TO
100421: IFFALSE 100522
// begin tmp := 0 ;
100423: LD_ADDR_VAR 0 3
100427: PUSH
100428: LD_STRING 0
100430: ST_TO_ADDR
// if result [ 1 ] then
100431: LD_VAR 0 2
100435: PUSH
100436: LD_INT 1
100438: ARRAY
100439: IFFALSE 100504
// if result [ 1 ] [ 1 ] = i then
100441: LD_VAR 0 2
100445: PUSH
100446: LD_INT 1
100448: ARRAY
100449: PUSH
100450: LD_INT 1
100452: ARRAY
100453: PUSH
100454: LD_VAR 0 8
100458: EQUAL
100459: IFFALSE 100504
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
100461: LD_ADDR_VAR 0 2
100465: PUSH
100466: LD_VAR 0 2
100470: PPUSH
100471: LD_INT 1
100473: PPUSH
100474: LD_VAR 0 2
100478: PUSH
100479: LD_INT 1
100481: ARRAY
100482: PPUSH
100483: LD_INT 1
100485: PPUSH
100486: CALL_OW 3
100490: PPUSH
100491: CALL_OW 1
100495: ST_TO_ADDR
// tmp := 1 ;
100496: LD_ADDR_VAR 0 3
100500: PUSH
100501: LD_STRING 1
100503: ST_TO_ADDR
// end ; normal := normal & tmp ;
100504: LD_ADDR_VAR 0 5
100508: PUSH
100509: LD_VAR 0 5
100513: PUSH
100514: LD_VAR 0 3
100518: STR
100519: ST_TO_ADDR
// end ;
100520: GO 100420
100522: POP
100523: POP
// for i = 1 to hardcoreCounter do
100524: LD_ADDR_VAR 0 8
100528: PUSH
100529: DOUBLE
100530: LD_INT 1
100532: DEC
100533: ST_TO_ADDR
100534: LD_EXP 81
100538: PUSH
100539: FOR_TO
100540: IFFALSE 100645
// begin tmp := 0 ;
100542: LD_ADDR_VAR 0 3
100546: PUSH
100547: LD_STRING 0
100549: ST_TO_ADDR
// if result [ 2 ] then
100550: LD_VAR 0 2
100554: PUSH
100555: LD_INT 2
100557: ARRAY
100558: IFFALSE 100627
// if result [ 2 ] [ 1 ] = 100 + i then
100560: LD_VAR 0 2
100564: PUSH
100565: LD_INT 2
100567: ARRAY
100568: PUSH
100569: LD_INT 1
100571: ARRAY
100572: PUSH
100573: LD_INT 100
100575: PUSH
100576: LD_VAR 0 8
100580: PLUS
100581: EQUAL
100582: IFFALSE 100627
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100584: LD_ADDR_VAR 0 2
100588: PUSH
100589: LD_VAR 0 2
100593: PPUSH
100594: LD_INT 2
100596: PPUSH
100597: LD_VAR 0 2
100601: PUSH
100602: LD_INT 2
100604: ARRAY
100605: PPUSH
100606: LD_INT 1
100608: PPUSH
100609: CALL_OW 3
100613: PPUSH
100614: CALL_OW 1
100618: ST_TO_ADDR
// tmp := 1 ;
100619: LD_ADDR_VAR 0 3
100623: PUSH
100624: LD_STRING 1
100626: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100627: LD_ADDR_VAR 0 6
100631: PUSH
100632: LD_VAR 0 6
100636: PUSH
100637: LD_VAR 0 3
100641: STR
100642: ST_TO_ADDR
// end ;
100643: GO 100539
100645: POP
100646: POP
// if isGameLoad then
100647: LD_VAR 0 1
100651: IFFALSE 101126
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100653: LD_ADDR_VAR 0 4
100657: PUSH
100658: LD_EXP 84
100662: PUSH
100663: LD_EXP 83
100667: PUSH
100668: LD_EXP 85
100672: PUSH
100673: LD_EXP 82
100677: PUSH
100678: LD_EXP 86
100682: PUSH
100683: LD_EXP 87
100687: PUSH
100688: LD_EXP 88
100692: PUSH
100693: LD_EXP 89
100697: PUSH
100698: LD_EXP 90
100702: PUSH
100703: LD_EXP 91
100707: PUSH
100708: LD_EXP 92
100712: PUSH
100713: LD_EXP 93
100717: PUSH
100718: LD_EXP 94
100722: PUSH
100723: LD_EXP 95
100727: PUSH
100728: LD_EXP 103
100732: PUSH
100733: LD_EXP 104
100737: PUSH
100738: LD_EXP 105
100742: PUSH
100743: LD_EXP 106
100747: PUSH
100748: LD_EXP 108
100752: PUSH
100753: LD_EXP 109
100757: PUSH
100758: LD_EXP 110
100762: PUSH
100763: LD_EXP 113
100767: PUSH
100768: LD_EXP 115
100772: PUSH
100773: LD_EXP 116
100777: PUSH
100778: LD_EXP 117
100782: PUSH
100783: LD_EXP 119
100787: PUSH
100788: LD_EXP 120
100792: PUSH
100793: LD_EXP 123
100797: PUSH
100798: LD_EXP 124
100802: PUSH
100803: LD_EXP 125
100807: PUSH
100808: LD_EXP 126
100812: PUSH
100813: LD_EXP 127
100817: PUSH
100818: LD_EXP 128
100822: PUSH
100823: LD_EXP 129
100827: PUSH
100828: LD_EXP 130
100832: PUSH
100833: LD_EXP 131
100837: PUSH
100838: LD_EXP 96
100842: PUSH
100843: LD_EXP 97
100847: PUSH
100848: LD_EXP 100
100852: PUSH
100853: LD_EXP 101
100857: PUSH
100858: LD_EXP 102
100862: PUSH
100863: LD_EXP 98
100867: PUSH
100868: LD_EXP 99
100872: PUSH
100873: LD_EXP 107
100877: PUSH
100878: LD_EXP 111
100882: PUSH
100883: LD_EXP 112
100887: PUSH
100888: LD_EXP 114
100892: PUSH
100893: LD_EXP 118
100897: PUSH
100898: LD_EXP 121
100902: PUSH
100903: LD_EXP 122
100907: PUSH
100908: LD_EXP 132
100912: PUSH
100913: LD_EXP 133
100917: PUSH
100918: LD_EXP 134
100922: PUSH
100923: LD_EXP 135
100927: PUSH
100928: EMPTY
100929: LIST
100930: LIST
100931: LIST
100932: LIST
100933: LIST
100934: LIST
100935: LIST
100936: LIST
100937: LIST
100938: LIST
100939: LIST
100940: LIST
100941: LIST
100942: LIST
100943: LIST
100944: LIST
100945: LIST
100946: LIST
100947: LIST
100948: LIST
100949: LIST
100950: LIST
100951: LIST
100952: LIST
100953: LIST
100954: LIST
100955: LIST
100956: LIST
100957: LIST
100958: LIST
100959: LIST
100960: LIST
100961: LIST
100962: LIST
100963: LIST
100964: LIST
100965: LIST
100966: LIST
100967: LIST
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: LIST
100973: LIST
100974: LIST
100975: LIST
100976: LIST
100977: LIST
100978: LIST
100979: LIST
100980: LIST
100981: LIST
100982: LIST
100983: ST_TO_ADDR
// tmp :=  ;
100984: LD_ADDR_VAR 0 3
100988: PUSH
100989: LD_STRING 
100991: ST_TO_ADDR
// for i = 1 to normalCounter do
100992: LD_ADDR_VAR 0 8
100996: PUSH
100997: DOUBLE
100998: LD_INT 1
101000: DEC
101001: ST_TO_ADDR
101002: LD_EXP 80
101006: PUSH
101007: FOR_TO
101008: IFFALSE 101044
// begin if flags [ i ] then
101010: LD_VAR 0 4
101014: PUSH
101015: LD_VAR 0 8
101019: ARRAY
101020: IFFALSE 101042
// tmp := tmp & i & ; ;
101022: LD_ADDR_VAR 0 3
101026: PUSH
101027: LD_VAR 0 3
101031: PUSH
101032: LD_VAR 0 8
101036: STR
101037: PUSH
101038: LD_STRING ;
101040: STR
101041: ST_TO_ADDR
// end ;
101042: GO 101007
101044: POP
101045: POP
// for i = 1 to hardcoreCounter do
101046: LD_ADDR_VAR 0 8
101050: PUSH
101051: DOUBLE
101052: LD_INT 1
101054: DEC
101055: ST_TO_ADDR
101056: LD_EXP 81
101060: PUSH
101061: FOR_TO
101062: IFFALSE 101108
// begin if flags [ normalCounter + i ] then
101064: LD_VAR 0 4
101068: PUSH
101069: LD_EXP 80
101073: PUSH
101074: LD_VAR 0 8
101078: PLUS
101079: ARRAY
101080: IFFALSE 101106
// tmp := tmp & ( 100 + i ) & ; ;
101082: LD_ADDR_VAR 0 3
101086: PUSH
101087: LD_VAR 0 3
101091: PUSH
101092: LD_INT 100
101094: PUSH
101095: LD_VAR 0 8
101099: PLUS
101100: STR
101101: PUSH
101102: LD_STRING ;
101104: STR
101105: ST_TO_ADDR
// end ;
101106: GO 101061
101108: POP
101109: POP
// if tmp then
101110: LD_VAR 0 3
101114: IFFALSE 101126
// active := tmp ;
101116: LD_ADDR_VAR 0 7
101120: PUSH
101121: LD_VAR 0 3
101125: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
101126: LD_STRING getStreamItemsFromMission("
101128: PUSH
101129: LD_VAR 0 5
101133: STR
101134: PUSH
101135: LD_STRING ","
101137: STR
101138: PUSH
101139: LD_VAR 0 6
101143: STR
101144: PUSH
101145: LD_STRING ","
101147: STR
101148: PUSH
101149: LD_VAR 0 7
101153: STR
101154: PUSH
101155: LD_STRING ")
101157: STR
101158: PPUSH
101159: CALL_OW 559
// end else
101163: GO 101172
// ToLua ( getStreamItemsFromMission("","","") ) ;
101165: LD_STRING getStreamItemsFromMission("","","")
101167: PPUSH
101168: CALL_OW 559
// end ;
101172: LD_VAR 0 2
101176: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
101177: LD_EXP 79
101181: PUSH
101182: LD_EXP 84
101186: AND
101187: IFFALSE 101311
101189: GO 101191
101191: DISABLE
101192: LD_INT 0
101194: PPUSH
101195: PPUSH
// begin enable ;
101196: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
101197: LD_ADDR_VAR 0 2
101201: PUSH
101202: LD_INT 22
101204: PUSH
101205: LD_OWVAR 2
101209: PUSH
101210: EMPTY
101211: LIST
101212: LIST
101213: PUSH
101214: LD_INT 2
101216: PUSH
101217: LD_INT 34
101219: PUSH
101220: LD_INT 7
101222: PUSH
101223: EMPTY
101224: LIST
101225: LIST
101226: PUSH
101227: LD_INT 34
101229: PUSH
101230: LD_INT 45
101232: PUSH
101233: EMPTY
101234: LIST
101235: LIST
101236: PUSH
101237: LD_INT 34
101239: PUSH
101240: LD_INT 28
101242: PUSH
101243: EMPTY
101244: LIST
101245: LIST
101246: PUSH
101247: LD_INT 34
101249: PUSH
101250: LD_INT 47
101252: PUSH
101253: EMPTY
101254: LIST
101255: LIST
101256: PUSH
101257: EMPTY
101258: LIST
101259: LIST
101260: LIST
101261: LIST
101262: LIST
101263: PUSH
101264: EMPTY
101265: LIST
101266: LIST
101267: PPUSH
101268: CALL_OW 69
101272: ST_TO_ADDR
// if not tmp then
101273: LD_VAR 0 2
101277: NOT
101278: IFFALSE 101282
// exit ;
101280: GO 101311
// for i in tmp do
101282: LD_ADDR_VAR 0 1
101286: PUSH
101287: LD_VAR 0 2
101291: PUSH
101292: FOR_IN
101293: IFFALSE 101309
// begin SetLives ( i , 0 ) ;
101295: LD_VAR 0 1
101299: PPUSH
101300: LD_INT 0
101302: PPUSH
101303: CALL_OW 234
// end ;
101307: GO 101292
101309: POP
101310: POP
// end ;
101311: PPOPN 2
101313: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
101314: LD_EXP 79
101318: PUSH
101319: LD_EXP 85
101323: AND
101324: IFFALSE 101408
101326: GO 101328
101328: DISABLE
101329: LD_INT 0
101331: PPUSH
101332: PPUSH
// begin enable ;
101333: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
101334: LD_ADDR_VAR 0 2
101338: PUSH
101339: LD_INT 22
101341: PUSH
101342: LD_OWVAR 2
101346: PUSH
101347: EMPTY
101348: LIST
101349: LIST
101350: PUSH
101351: LD_INT 32
101353: PUSH
101354: LD_INT 3
101356: PUSH
101357: EMPTY
101358: LIST
101359: LIST
101360: PUSH
101361: EMPTY
101362: LIST
101363: LIST
101364: PPUSH
101365: CALL_OW 69
101369: ST_TO_ADDR
// if not tmp then
101370: LD_VAR 0 2
101374: NOT
101375: IFFALSE 101379
// exit ;
101377: GO 101408
// for i in tmp do
101379: LD_ADDR_VAR 0 1
101383: PUSH
101384: LD_VAR 0 2
101388: PUSH
101389: FOR_IN
101390: IFFALSE 101406
// begin SetLives ( i , 0 ) ;
101392: LD_VAR 0 1
101396: PPUSH
101397: LD_INT 0
101399: PPUSH
101400: CALL_OW 234
// end ;
101404: GO 101389
101406: POP
101407: POP
// end ;
101408: PPOPN 2
101410: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
101411: LD_EXP 79
101415: PUSH
101416: LD_EXP 82
101420: AND
101421: IFFALSE 101514
101423: GO 101425
101425: DISABLE
101426: LD_INT 0
101428: PPUSH
// begin enable ;
101429: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
101430: LD_ADDR_VAR 0 1
101434: PUSH
101435: LD_INT 22
101437: PUSH
101438: LD_OWVAR 2
101442: PUSH
101443: EMPTY
101444: LIST
101445: LIST
101446: PUSH
101447: LD_INT 2
101449: PUSH
101450: LD_INT 25
101452: PUSH
101453: LD_INT 5
101455: PUSH
101456: EMPTY
101457: LIST
101458: LIST
101459: PUSH
101460: LD_INT 25
101462: PUSH
101463: LD_INT 9
101465: PUSH
101466: EMPTY
101467: LIST
101468: LIST
101469: PUSH
101470: LD_INT 25
101472: PUSH
101473: LD_INT 8
101475: PUSH
101476: EMPTY
101477: LIST
101478: LIST
101479: PUSH
101480: EMPTY
101481: LIST
101482: LIST
101483: LIST
101484: LIST
101485: PUSH
101486: EMPTY
101487: LIST
101488: LIST
101489: PPUSH
101490: CALL_OW 69
101494: PUSH
101495: FOR_IN
101496: IFFALSE 101512
// begin SetClass ( i , 1 ) ;
101498: LD_VAR 0 1
101502: PPUSH
101503: LD_INT 1
101505: PPUSH
101506: CALL_OW 336
// end ;
101510: GO 101495
101512: POP
101513: POP
// end ;
101514: PPOPN 1
101516: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101517: LD_EXP 79
101521: PUSH
101522: LD_EXP 83
101526: AND
101527: PUSH
101528: LD_OWVAR 65
101532: PUSH
101533: LD_INT 7
101535: LESS
101536: AND
101537: IFFALSE 101551
101539: GO 101541
101541: DISABLE
// begin enable ;
101542: ENABLE
// game_speed := 7 ;
101543: LD_ADDR_OWVAR 65
101547: PUSH
101548: LD_INT 7
101550: ST_TO_ADDR
// end ;
101551: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101552: LD_EXP 79
101556: PUSH
101557: LD_EXP 86
101561: AND
101562: IFFALSE 101764
101564: GO 101566
101566: DISABLE
101567: LD_INT 0
101569: PPUSH
101570: PPUSH
101571: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101572: LD_ADDR_VAR 0 3
101576: PUSH
101577: LD_INT 81
101579: PUSH
101580: LD_OWVAR 2
101584: PUSH
101585: EMPTY
101586: LIST
101587: LIST
101588: PUSH
101589: LD_INT 21
101591: PUSH
101592: LD_INT 1
101594: PUSH
101595: EMPTY
101596: LIST
101597: LIST
101598: PUSH
101599: EMPTY
101600: LIST
101601: LIST
101602: PPUSH
101603: CALL_OW 69
101607: ST_TO_ADDR
// if not tmp then
101608: LD_VAR 0 3
101612: NOT
101613: IFFALSE 101617
// exit ;
101615: GO 101764
// if tmp > 5 then
101617: LD_VAR 0 3
101621: PUSH
101622: LD_INT 5
101624: GREATER
101625: IFFALSE 101637
// k := 5 else
101627: LD_ADDR_VAR 0 2
101631: PUSH
101632: LD_INT 5
101634: ST_TO_ADDR
101635: GO 101647
// k := tmp ;
101637: LD_ADDR_VAR 0 2
101641: PUSH
101642: LD_VAR 0 3
101646: ST_TO_ADDR
// for i := 1 to k do
101647: LD_ADDR_VAR 0 1
101651: PUSH
101652: DOUBLE
101653: LD_INT 1
101655: DEC
101656: ST_TO_ADDR
101657: LD_VAR 0 2
101661: PUSH
101662: FOR_TO
101663: IFFALSE 101762
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101665: LD_VAR 0 3
101669: PUSH
101670: LD_VAR 0 1
101674: ARRAY
101675: PPUSH
101676: LD_VAR 0 1
101680: PUSH
101681: LD_INT 4
101683: MOD
101684: PUSH
101685: LD_INT 1
101687: PLUS
101688: PPUSH
101689: CALL_OW 259
101693: PUSH
101694: LD_INT 10
101696: LESS
101697: IFFALSE 101760
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101699: LD_VAR 0 3
101703: PUSH
101704: LD_VAR 0 1
101708: ARRAY
101709: PPUSH
101710: LD_VAR 0 1
101714: PUSH
101715: LD_INT 4
101717: MOD
101718: PUSH
101719: LD_INT 1
101721: PLUS
101722: PPUSH
101723: LD_VAR 0 3
101727: PUSH
101728: LD_VAR 0 1
101732: ARRAY
101733: PPUSH
101734: LD_VAR 0 1
101738: PUSH
101739: LD_INT 4
101741: MOD
101742: PUSH
101743: LD_INT 1
101745: PLUS
101746: PPUSH
101747: CALL_OW 259
101751: PUSH
101752: LD_INT 1
101754: PLUS
101755: PPUSH
101756: CALL_OW 237
101760: GO 101662
101762: POP
101763: POP
// end ;
101764: PPOPN 3
101766: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101767: LD_EXP 79
101771: PUSH
101772: LD_EXP 87
101776: AND
101777: IFFALSE 101797
101779: GO 101781
101781: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101782: LD_INT 4
101784: PPUSH
101785: LD_OWVAR 2
101789: PPUSH
101790: LD_INT 0
101792: PPUSH
101793: CALL_OW 324
101797: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101798: LD_EXP 79
101802: PUSH
101803: LD_EXP 116
101807: AND
101808: IFFALSE 101828
101810: GO 101812
101812: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101813: LD_INT 19
101815: PPUSH
101816: LD_OWVAR 2
101820: PPUSH
101821: LD_INT 0
101823: PPUSH
101824: CALL_OW 324
101828: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101829: LD_EXP 79
101833: PUSH
101834: LD_EXP 88
101838: AND
101839: IFFALSE 101941
101841: GO 101843
101843: DISABLE
101844: LD_INT 0
101846: PPUSH
101847: PPUSH
// begin enable ;
101848: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101849: LD_ADDR_VAR 0 2
101853: PUSH
101854: LD_INT 22
101856: PUSH
101857: LD_OWVAR 2
101861: PUSH
101862: EMPTY
101863: LIST
101864: LIST
101865: PUSH
101866: LD_INT 2
101868: PUSH
101869: LD_INT 34
101871: PUSH
101872: LD_INT 11
101874: PUSH
101875: EMPTY
101876: LIST
101877: LIST
101878: PUSH
101879: LD_INT 34
101881: PUSH
101882: LD_INT 30
101884: PUSH
101885: EMPTY
101886: LIST
101887: LIST
101888: PUSH
101889: EMPTY
101890: LIST
101891: LIST
101892: LIST
101893: PUSH
101894: EMPTY
101895: LIST
101896: LIST
101897: PPUSH
101898: CALL_OW 69
101902: ST_TO_ADDR
// if not tmp then
101903: LD_VAR 0 2
101907: NOT
101908: IFFALSE 101912
// exit ;
101910: GO 101941
// for i in tmp do
101912: LD_ADDR_VAR 0 1
101916: PUSH
101917: LD_VAR 0 2
101921: PUSH
101922: FOR_IN
101923: IFFALSE 101939
// begin SetLives ( i , 0 ) ;
101925: LD_VAR 0 1
101929: PPUSH
101930: LD_INT 0
101932: PPUSH
101933: CALL_OW 234
// end ;
101937: GO 101922
101939: POP
101940: POP
// end ;
101941: PPOPN 2
101943: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101944: LD_EXP 79
101948: PUSH
101949: LD_EXP 89
101953: AND
101954: IFFALSE 101974
101956: GO 101958
101958: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101959: LD_INT 32
101961: PPUSH
101962: LD_OWVAR 2
101966: PPUSH
101967: LD_INT 0
101969: PPUSH
101970: CALL_OW 324
101974: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101975: LD_EXP 79
101979: PUSH
101980: LD_EXP 90
101984: AND
101985: IFFALSE 102166
101987: GO 101989
101989: DISABLE
101990: LD_INT 0
101992: PPUSH
101993: PPUSH
101994: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101995: LD_ADDR_VAR 0 2
101999: PUSH
102000: LD_INT 22
102002: PUSH
102003: LD_OWVAR 2
102007: PUSH
102008: EMPTY
102009: LIST
102010: LIST
102011: PUSH
102012: LD_INT 33
102014: PUSH
102015: LD_INT 3
102017: PUSH
102018: EMPTY
102019: LIST
102020: LIST
102021: PUSH
102022: EMPTY
102023: LIST
102024: LIST
102025: PPUSH
102026: CALL_OW 69
102030: ST_TO_ADDR
// if not tmp then
102031: LD_VAR 0 2
102035: NOT
102036: IFFALSE 102040
// exit ;
102038: GO 102166
// side := 0 ;
102040: LD_ADDR_VAR 0 3
102044: PUSH
102045: LD_INT 0
102047: ST_TO_ADDR
// for i := 1 to 8 do
102048: LD_ADDR_VAR 0 1
102052: PUSH
102053: DOUBLE
102054: LD_INT 1
102056: DEC
102057: ST_TO_ADDR
102058: LD_INT 8
102060: PUSH
102061: FOR_TO
102062: IFFALSE 102110
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
102064: LD_OWVAR 2
102068: PUSH
102069: LD_VAR 0 1
102073: NONEQUAL
102074: PUSH
102075: LD_OWVAR 2
102079: PPUSH
102080: LD_VAR 0 1
102084: PPUSH
102085: CALL_OW 81
102089: PUSH
102090: LD_INT 2
102092: EQUAL
102093: AND
102094: IFFALSE 102108
// begin side := i ;
102096: LD_ADDR_VAR 0 3
102100: PUSH
102101: LD_VAR 0 1
102105: ST_TO_ADDR
// break ;
102106: GO 102110
// end ;
102108: GO 102061
102110: POP
102111: POP
// if not side then
102112: LD_VAR 0 3
102116: NOT
102117: IFFALSE 102121
// exit ;
102119: GO 102166
// for i := 1 to tmp do
102121: LD_ADDR_VAR 0 1
102125: PUSH
102126: DOUBLE
102127: LD_INT 1
102129: DEC
102130: ST_TO_ADDR
102131: LD_VAR 0 2
102135: PUSH
102136: FOR_TO
102137: IFFALSE 102164
// if Prob ( 60 ) then
102139: LD_INT 60
102141: PPUSH
102142: CALL_OW 13
102146: IFFALSE 102162
// SetSide ( i , side ) ;
102148: LD_VAR 0 1
102152: PPUSH
102153: LD_VAR 0 3
102157: PPUSH
102158: CALL_OW 235
102162: GO 102136
102164: POP
102165: POP
// end ;
102166: PPOPN 3
102168: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
102169: LD_EXP 79
102173: PUSH
102174: LD_EXP 92
102178: AND
102179: IFFALSE 102298
102181: GO 102183
102183: DISABLE
102184: LD_INT 0
102186: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
102187: LD_ADDR_VAR 0 1
102191: PUSH
102192: LD_INT 22
102194: PUSH
102195: LD_OWVAR 2
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PUSH
102204: LD_INT 21
102206: PUSH
102207: LD_INT 1
102209: PUSH
102210: EMPTY
102211: LIST
102212: LIST
102213: PUSH
102214: LD_INT 3
102216: PUSH
102217: LD_INT 23
102219: PUSH
102220: LD_INT 0
102222: PUSH
102223: EMPTY
102224: LIST
102225: LIST
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: PUSH
102231: EMPTY
102232: LIST
102233: LIST
102234: LIST
102235: PPUSH
102236: CALL_OW 69
102240: PUSH
102241: FOR_IN
102242: IFFALSE 102296
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
102244: LD_VAR 0 1
102248: PPUSH
102249: CALL_OW 257
102253: PUSH
102254: LD_INT 1
102256: PUSH
102257: LD_INT 2
102259: PUSH
102260: LD_INT 3
102262: PUSH
102263: LD_INT 4
102265: PUSH
102266: EMPTY
102267: LIST
102268: LIST
102269: LIST
102270: LIST
102271: IN
102272: IFFALSE 102294
// SetClass ( un , rand ( 1 , 4 ) ) ;
102274: LD_VAR 0 1
102278: PPUSH
102279: LD_INT 1
102281: PPUSH
102282: LD_INT 4
102284: PPUSH
102285: CALL_OW 12
102289: PPUSH
102290: CALL_OW 336
102294: GO 102241
102296: POP
102297: POP
// end ;
102298: PPOPN 1
102300: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
102301: LD_EXP 79
102305: PUSH
102306: LD_EXP 91
102310: AND
102311: IFFALSE 102390
102313: GO 102315
102315: DISABLE
102316: LD_INT 0
102318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102319: LD_ADDR_VAR 0 1
102323: PUSH
102324: LD_INT 22
102326: PUSH
102327: LD_OWVAR 2
102331: PUSH
102332: EMPTY
102333: LIST
102334: LIST
102335: PUSH
102336: LD_INT 21
102338: PUSH
102339: LD_INT 3
102341: PUSH
102342: EMPTY
102343: LIST
102344: LIST
102345: PUSH
102346: EMPTY
102347: LIST
102348: LIST
102349: PPUSH
102350: CALL_OW 69
102354: ST_TO_ADDR
// if not tmp then
102355: LD_VAR 0 1
102359: NOT
102360: IFFALSE 102364
// exit ;
102362: GO 102390
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
102364: LD_VAR 0 1
102368: PUSH
102369: LD_INT 1
102371: PPUSH
102372: LD_VAR 0 1
102376: PPUSH
102377: CALL_OW 12
102381: ARRAY
102382: PPUSH
102383: LD_INT 100
102385: PPUSH
102386: CALL_OW 234
// end ;
102390: PPOPN 1
102392: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
102393: LD_EXP 79
102397: PUSH
102398: LD_EXP 93
102402: AND
102403: IFFALSE 102501
102405: GO 102407
102407: DISABLE
102408: LD_INT 0
102410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102411: LD_ADDR_VAR 0 1
102415: PUSH
102416: LD_INT 22
102418: PUSH
102419: LD_OWVAR 2
102423: PUSH
102424: EMPTY
102425: LIST
102426: LIST
102427: PUSH
102428: LD_INT 21
102430: PUSH
102431: LD_INT 1
102433: PUSH
102434: EMPTY
102435: LIST
102436: LIST
102437: PUSH
102438: EMPTY
102439: LIST
102440: LIST
102441: PPUSH
102442: CALL_OW 69
102446: ST_TO_ADDR
// if not tmp then
102447: LD_VAR 0 1
102451: NOT
102452: IFFALSE 102456
// exit ;
102454: GO 102501
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
102456: LD_VAR 0 1
102460: PUSH
102461: LD_INT 1
102463: PPUSH
102464: LD_VAR 0 1
102468: PPUSH
102469: CALL_OW 12
102473: ARRAY
102474: PPUSH
102475: LD_INT 1
102477: PPUSH
102478: LD_INT 4
102480: PPUSH
102481: CALL_OW 12
102485: PPUSH
102486: LD_INT 3000
102488: PPUSH
102489: LD_INT 9000
102491: PPUSH
102492: CALL_OW 12
102496: PPUSH
102497: CALL_OW 492
// end ;
102501: PPOPN 1
102503: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102504: LD_EXP 79
102508: PUSH
102509: LD_EXP 94
102513: AND
102514: IFFALSE 102534
102516: GO 102518
102518: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102519: LD_INT 1
102521: PPUSH
102522: LD_OWVAR 2
102526: PPUSH
102527: LD_INT 0
102529: PPUSH
102530: CALL_OW 324
102534: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102535: LD_EXP 79
102539: PUSH
102540: LD_EXP 95
102544: AND
102545: IFFALSE 102628
102547: GO 102549
102549: DISABLE
102550: LD_INT 0
102552: PPUSH
102553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102554: LD_ADDR_VAR 0 2
102558: PUSH
102559: LD_INT 22
102561: PUSH
102562: LD_OWVAR 2
102566: PUSH
102567: EMPTY
102568: LIST
102569: LIST
102570: PUSH
102571: LD_INT 21
102573: PUSH
102574: LD_INT 3
102576: PUSH
102577: EMPTY
102578: LIST
102579: LIST
102580: PUSH
102581: EMPTY
102582: LIST
102583: LIST
102584: PPUSH
102585: CALL_OW 69
102589: ST_TO_ADDR
// if not tmp then
102590: LD_VAR 0 2
102594: NOT
102595: IFFALSE 102599
// exit ;
102597: GO 102628
// for i in tmp do
102599: LD_ADDR_VAR 0 1
102603: PUSH
102604: LD_VAR 0 2
102608: PUSH
102609: FOR_IN
102610: IFFALSE 102626
// SetBLevel ( i , 10 ) ;
102612: LD_VAR 0 1
102616: PPUSH
102617: LD_INT 10
102619: PPUSH
102620: CALL_OW 241
102624: GO 102609
102626: POP
102627: POP
// end ;
102628: PPOPN 2
102630: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102631: LD_EXP 79
102635: PUSH
102636: LD_EXP 96
102640: AND
102641: IFFALSE 102752
102643: GO 102645
102645: DISABLE
102646: LD_INT 0
102648: PPUSH
102649: PPUSH
102650: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102651: LD_ADDR_VAR 0 3
102655: PUSH
102656: LD_INT 22
102658: PUSH
102659: LD_OWVAR 2
102663: PUSH
102664: EMPTY
102665: LIST
102666: LIST
102667: PUSH
102668: LD_INT 25
102670: PUSH
102671: LD_INT 1
102673: PUSH
102674: EMPTY
102675: LIST
102676: LIST
102677: PUSH
102678: EMPTY
102679: LIST
102680: LIST
102681: PPUSH
102682: CALL_OW 69
102686: ST_TO_ADDR
// if not tmp then
102687: LD_VAR 0 3
102691: NOT
102692: IFFALSE 102696
// exit ;
102694: GO 102752
// un := tmp [ rand ( 1 , tmp ) ] ;
102696: LD_ADDR_VAR 0 2
102700: PUSH
102701: LD_VAR 0 3
102705: PUSH
102706: LD_INT 1
102708: PPUSH
102709: LD_VAR 0 3
102713: PPUSH
102714: CALL_OW 12
102718: ARRAY
102719: ST_TO_ADDR
// if Crawls ( un ) then
102720: LD_VAR 0 2
102724: PPUSH
102725: CALL_OW 318
102729: IFFALSE 102740
// ComWalk ( un ) ;
102731: LD_VAR 0 2
102735: PPUSH
102736: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102740: LD_VAR 0 2
102744: PPUSH
102745: LD_INT 5
102747: PPUSH
102748: CALL_OW 336
// end ;
102752: PPOPN 3
102754: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102755: LD_EXP 79
102759: PUSH
102760: LD_EXP 97
102764: AND
102765: PUSH
102766: LD_OWVAR 67
102770: PUSH
102771: LD_INT 4
102773: LESS
102774: AND
102775: IFFALSE 102794
102777: GO 102779
102779: DISABLE
// begin Difficulty := Difficulty + 1 ;
102780: LD_ADDR_OWVAR 67
102784: PUSH
102785: LD_OWVAR 67
102789: PUSH
102790: LD_INT 1
102792: PLUS
102793: ST_TO_ADDR
// end ;
102794: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102795: LD_EXP 79
102799: PUSH
102800: LD_EXP 98
102804: AND
102805: IFFALSE 102908
102807: GO 102809
102809: DISABLE
102810: LD_INT 0
102812: PPUSH
// begin for i := 1 to 5 do
102813: LD_ADDR_VAR 0 1
102817: PUSH
102818: DOUBLE
102819: LD_INT 1
102821: DEC
102822: ST_TO_ADDR
102823: LD_INT 5
102825: PUSH
102826: FOR_TO
102827: IFFALSE 102906
// begin uc_nation := nation_nature ;
102829: LD_ADDR_OWVAR 21
102833: PUSH
102834: LD_INT 0
102836: ST_TO_ADDR
// uc_side := 0 ;
102837: LD_ADDR_OWVAR 20
102841: PUSH
102842: LD_INT 0
102844: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102845: LD_ADDR_OWVAR 29
102849: PUSH
102850: LD_INT 12
102852: PUSH
102853: LD_INT 12
102855: PUSH
102856: EMPTY
102857: LIST
102858: LIST
102859: ST_TO_ADDR
// hc_agressivity := 20 ;
102860: LD_ADDR_OWVAR 35
102864: PUSH
102865: LD_INT 20
102867: ST_TO_ADDR
// hc_class := class_tiger ;
102868: LD_ADDR_OWVAR 28
102872: PUSH
102873: LD_INT 14
102875: ST_TO_ADDR
// hc_gallery :=  ;
102876: LD_ADDR_OWVAR 33
102880: PUSH
102881: LD_STRING 
102883: ST_TO_ADDR
// hc_name :=  ;
102884: LD_ADDR_OWVAR 26
102888: PUSH
102889: LD_STRING 
102891: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102892: CALL_OW 44
102896: PPUSH
102897: LD_INT 0
102899: PPUSH
102900: CALL_OW 51
// end ;
102904: GO 102826
102906: POP
102907: POP
// end ;
102908: PPOPN 1
102910: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102911: LD_EXP 79
102915: PUSH
102916: LD_EXP 99
102920: AND
102921: IFFALSE 102930
102923: GO 102925
102925: DISABLE
// StreamSibBomb ;
102926: CALL 102931 0 0
102930: END
// export function StreamSibBomb ; var i , x , y ; begin
102931: LD_INT 0
102933: PPUSH
102934: PPUSH
102935: PPUSH
102936: PPUSH
// result := false ;
102937: LD_ADDR_VAR 0 1
102941: PUSH
102942: LD_INT 0
102944: ST_TO_ADDR
// for i := 1 to 16 do
102945: LD_ADDR_VAR 0 2
102949: PUSH
102950: DOUBLE
102951: LD_INT 1
102953: DEC
102954: ST_TO_ADDR
102955: LD_INT 16
102957: PUSH
102958: FOR_TO
102959: IFFALSE 103158
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102961: LD_ADDR_VAR 0 3
102965: PUSH
102966: LD_INT 10
102968: PUSH
102969: LD_INT 20
102971: PUSH
102972: LD_INT 30
102974: PUSH
102975: LD_INT 40
102977: PUSH
102978: LD_INT 50
102980: PUSH
102981: LD_INT 60
102983: PUSH
102984: LD_INT 70
102986: PUSH
102987: LD_INT 80
102989: PUSH
102990: LD_INT 90
102992: PUSH
102993: LD_INT 100
102995: PUSH
102996: LD_INT 110
102998: PUSH
102999: LD_INT 120
103001: PUSH
103002: LD_INT 130
103004: PUSH
103005: LD_INT 140
103007: PUSH
103008: LD_INT 150
103010: PUSH
103011: EMPTY
103012: LIST
103013: LIST
103014: LIST
103015: LIST
103016: LIST
103017: LIST
103018: LIST
103019: LIST
103020: LIST
103021: LIST
103022: LIST
103023: LIST
103024: LIST
103025: LIST
103026: LIST
103027: PUSH
103028: LD_INT 1
103030: PPUSH
103031: LD_INT 15
103033: PPUSH
103034: CALL_OW 12
103038: ARRAY
103039: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
103040: LD_ADDR_VAR 0 4
103044: PUSH
103045: LD_INT 10
103047: PUSH
103048: LD_INT 20
103050: PUSH
103051: LD_INT 30
103053: PUSH
103054: LD_INT 40
103056: PUSH
103057: LD_INT 50
103059: PUSH
103060: LD_INT 60
103062: PUSH
103063: LD_INT 70
103065: PUSH
103066: LD_INT 80
103068: PUSH
103069: LD_INT 90
103071: PUSH
103072: LD_INT 100
103074: PUSH
103075: LD_INT 110
103077: PUSH
103078: LD_INT 120
103080: PUSH
103081: LD_INT 130
103083: PUSH
103084: LD_INT 140
103086: PUSH
103087: LD_INT 150
103089: PUSH
103090: EMPTY
103091: LIST
103092: LIST
103093: LIST
103094: LIST
103095: LIST
103096: LIST
103097: LIST
103098: LIST
103099: LIST
103100: LIST
103101: LIST
103102: LIST
103103: LIST
103104: LIST
103105: LIST
103106: PUSH
103107: LD_INT 1
103109: PPUSH
103110: LD_INT 15
103112: PPUSH
103113: CALL_OW 12
103117: ARRAY
103118: ST_TO_ADDR
// if ValidHex ( x , y ) then
103119: LD_VAR 0 3
103123: PPUSH
103124: LD_VAR 0 4
103128: PPUSH
103129: CALL_OW 488
103133: IFFALSE 103156
// begin result := [ x , y ] ;
103135: LD_ADDR_VAR 0 1
103139: PUSH
103140: LD_VAR 0 3
103144: PUSH
103145: LD_VAR 0 4
103149: PUSH
103150: EMPTY
103151: LIST
103152: LIST
103153: ST_TO_ADDR
// break ;
103154: GO 103158
// end ; end ;
103156: GO 102958
103158: POP
103159: POP
// if result then
103160: LD_VAR 0 1
103164: IFFALSE 103224
// begin ToLua ( playSibBomb() ) ;
103166: LD_STRING playSibBomb()
103168: PPUSH
103169: CALL_OW 559
// wait ( 0 0$14 ) ;
103173: LD_INT 490
103175: PPUSH
103176: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
103180: LD_VAR 0 1
103184: PUSH
103185: LD_INT 1
103187: ARRAY
103188: PPUSH
103189: LD_VAR 0 1
103193: PUSH
103194: LD_INT 2
103196: ARRAY
103197: PPUSH
103198: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
103202: LD_VAR 0 1
103206: PUSH
103207: LD_INT 1
103209: ARRAY
103210: PPUSH
103211: LD_VAR 0 1
103215: PUSH
103216: LD_INT 2
103218: ARRAY
103219: PPUSH
103220: CALL_OW 429
// end ; end ;
103224: LD_VAR 0 1
103228: RET
// every 0 0$1 trigger StreamModeActive and sReset do
103229: LD_EXP 79
103233: PUSH
103234: LD_EXP 101
103238: AND
103239: IFFALSE 103251
103241: GO 103243
103243: DISABLE
// YouLost (  ) ;
103244: LD_STRING 
103246: PPUSH
103247: CALL_OW 104
103251: END
// every 0 0$1 trigger StreamModeActive and sFog do
103252: LD_EXP 79
103256: PUSH
103257: LD_EXP 100
103261: AND
103262: IFFALSE 103276
103264: GO 103266
103266: DISABLE
// FogOff ( your_side ) ;
103267: LD_OWVAR 2
103271: PPUSH
103272: CALL_OW 344
103276: END
// every 0 0$1 trigger StreamModeActive and sSun do
103277: LD_EXP 79
103281: PUSH
103282: LD_EXP 102
103286: AND
103287: IFFALSE 103315
103289: GO 103291
103291: DISABLE
// begin solar_recharge_percent := 0 ;
103292: LD_ADDR_OWVAR 79
103296: PUSH
103297: LD_INT 0
103299: ST_TO_ADDR
// wait ( 5 5$00 ) ;
103300: LD_INT 10500
103302: PPUSH
103303: CALL_OW 67
// solar_recharge_percent := 100 ;
103307: LD_ADDR_OWVAR 79
103311: PUSH
103312: LD_INT 100
103314: ST_TO_ADDR
// end ;
103315: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
103316: LD_EXP 79
103320: PUSH
103321: LD_EXP 103
103325: AND
103326: IFFALSE 103565
103328: GO 103330
103330: DISABLE
103331: LD_INT 0
103333: PPUSH
103334: PPUSH
103335: PPUSH
// begin tmp := [ ] ;
103336: LD_ADDR_VAR 0 3
103340: PUSH
103341: EMPTY
103342: ST_TO_ADDR
// for i := 1 to 6 do
103343: LD_ADDR_VAR 0 1
103347: PUSH
103348: DOUBLE
103349: LD_INT 1
103351: DEC
103352: ST_TO_ADDR
103353: LD_INT 6
103355: PUSH
103356: FOR_TO
103357: IFFALSE 103462
// begin uc_nation := nation_nature ;
103359: LD_ADDR_OWVAR 21
103363: PUSH
103364: LD_INT 0
103366: ST_TO_ADDR
// uc_side := 0 ;
103367: LD_ADDR_OWVAR 20
103371: PUSH
103372: LD_INT 0
103374: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103375: LD_ADDR_OWVAR 29
103379: PUSH
103380: LD_INT 12
103382: PUSH
103383: LD_INT 12
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: ST_TO_ADDR
// hc_agressivity := 20 ;
103390: LD_ADDR_OWVAR 35
103394: PUSH
103395: LD_INT 20
103397: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
103398: LD_ADDR_OWVAR 28
103402: PUSH
103403: LD_INT 17
103405: ST_TO_ADDR
// hc_gallery :=  ;
103406: LD_ADDR_OWVAR 33
103410: PUSH
103411: LD_STRING 
103413: ST_TO_ADDR
// hc_name :=  ;
103414: LD_ADDR_OWVAR 26
103418: PUSH
103419: LD_STRING 
103421: ST_TO_ADDR
// un := CreateHuman ;
103422: LD_ADDR_VAR 0 2
103426: PUSH
103427: CALL_OW 44
103431: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
103432: LD_VAR 0 2
103436: PPUSH
103437: LD_INT 1
103439: PPUSH
103440: CALL_OW 51
// tmp := tmp ^ un ;
103444: LD_ADDR_VAR 0 3
103448: PUSH
103449: LD_VAR 0 3
103453: PUSH
103454: LD_VAR 0 2
103458: ADD
103459: ST_TO_ADDR
// end ;
103460: GO 103356
103462: POP
103463: POP
// repeat wait ( 0 0$1 ) ;
103464: LD_INT 35
103466: PPUSH
103467: CALL_OW 67
// for un in tmp do
103471: LD_ADDR_VAR 0 2
103475: PUSH
103476: LD_VAR 0 3
103480: PUSH
103481: FOR_IN
103482: IFFALSE 103556
// begin if IsDead ( un ) then
103484: LD_VAR 0 2
103488: PPUSH
103489: CALL_OW 301
103493: IFFALSE 103513
// begin tmp := tmp diff un ;
103495: LD_ADDR_VAR 0 3
103499: PUSH
103500: LD_VAR 0 3
103504: PUSH
103505: LD_VAR 0 2
103509: DIFF
103510: ST_TO_ADDR
// continue ;
103511: GO 103481
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103513: LD_VAR 0 2
103517: PPUSH
103518: LD_INT 3
103520: PUSH
103521: LD_INT 22
103523: PUSH
103524: LD_INT 0
103526: PUSH
103527: EMPTY
103528: LIST
103529: LIST
103530: PUSH
103531: EMPTY
103532: LIST
103533: LIST
103534: PPUSH
103535: CALL_OW 69
103539: PPUSH
103540: LD_VAR 0 2
103544: PPUSH
103545: CALL_OW 74
103549: PPUSH
103550: CALL_OW 115
// end ;
103554: GO 103481
103556: POP
103557: POP
// until not tmp ;
103558: LD_VAR 0 3
103562: NOT
103563: IFFALSE 103464
// end ;
103565: PPOPN 3
103567: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103568: LD_EXP 79
103572: PUSH
103573: LD_EXP 104
103577: AND
103578: IFFALSE 103632
103580: GO 103582
103582: DISABLE
// begin ToLua ( displayTroll(); ) ;
103583: LD_STRING displayTroll();
103585: PPUSH
103586: CALL_OW 559
// wait ( 3 3$00 ) ;
103590: LD_INT 6300
103592: PPUSH
103593: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103597: LD_STRING hideTroll();
103599: PPUSH
103600: CALL_OW 559
// wait ( 1 1$00 ) ;
103604: LD_INT 2100
103606: PPUSH
103607: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103611: LD_STRING displayTroll();
103613: PPUSH
103614: CALL_OW 559
// wait ( 1 1$00 ) ;
103618: LD_INT 2100
103620: PPUSH
103621: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103625: LD_STRING hideTroll();
103627: PPUSH
103628: CALL_OW 559
// end ;
103632: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103633: LD_EXP 79
103637: PUSH
103638: LD_EXP 105
103642: AND
103643: IFFALSE 103706
103645: GO 103647
103647: DISABLE
103648: LD_INT 0
103650: PPUSH
// begin p := 0 ;
103651: LD_ADDR_VAR 0 1
103655: PUSH
103656: LD_INT 0
103658: ST_TO_ADDR
// repeat game_speed := 1 ;
103659: LD_ADDR_OWVAR 65
103663: PUSH
103664: LD_INT 1
103666: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103667: LD_INT 35
103669: PPUSH
103670: CALL_OW 67
// p := p + 1 ;
103674: LD_ADDR_VAR 0 1
103678: PUSH
103679: LD_VAR 0 1
103683: PUSH
103684: LD_INT 1
103686: PLUS
103687: ST_TO_ADDR
// until p >= 60 ;
103688: LD_VAR 0 1
103692: PUSH
103693: LD_INT 60
103695: GREATEREQUAL
103696: IFFALSE 103659
// game_speed := 4 ;
103698: LD_ADDR_OWVAR 65
103702: PUSH
103703: LD_INT 4
103705: ST_TO_ADDR
// end ;
103706: PPOPN 1
103708: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103709: LD_EXP 79
103713: PUSH
103714: LD_EXP 106
103718: AND
103719: IFFALSE 103865
103721: GO 103723
103723: DISABLE
103724: LD_INT 0
103726: PPUSH
103727: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103728: LD_ADDR_VAR 0 1
103732: PUSH
103733: LD_INT 22
103735: PUSH
103736: LD_OWVAR 2
103740: PUSH
103741: EMPTY
103742: LIST
103743: LIST
103744: PUSH
103745: LD_INT 2
103747: PUSH
103748: LD_INT 30
103750: PUSH
103751: LD_INT 0
103753: PUSH
103754: EMPTY
103755: LIST
103756: LIST
103757: PUSH
103758: LD_INT 30
103760: PUSH
103761: LD_INT 1
103763: PUSH
103764: EMPTY
103765: LIST
103766: LIST
103767: PUSH
103768: EMPTY
103769: LIST
103770: LIST
103771: LIST
103772: PUSH
103773: EMPTY
103774: LIST
103775: LIST
103776: PPUSH
103777: CALL_OW 69
103781: ST_TO_ADDR
// if not depot then
103782: LD_VAR 0 1
103786: NOT
103787: IFFALSE 103791
// exit ;
103789: GO 103865
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103791: LD_ADDR_VAR 0 2
103795: PUSH
103796: LD_VAR 0 1
103800: PUSH
103801: LD_INT 1
103803: PPUSH
103804: LD_VAR 0 1
103808: PPUSH
103809: CALL_OW 12
103813: ARRAY
103814: PPUSH
103815: CALL_OW 274
103819: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103820: LD_VAR 0 2
103824: PPUSH
103825: LD_INT 1
103827: PPUSH
103828: LD_INT 0
103830: PPUSH
103831: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103835: LD_VAR 0 2
103839: PPUSH
103840: LD_INT 2
103842: PPUSH
103843: LD_INT 0
103845: PPUSH
103846: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103850: LD_VAR 0 2
103854: PPUSH
103855: LD_INT 3
103857: PPUSH
103858: LD_INT 0
103860: PPUSH
103861: CALL_OW 277
// end ;
103865: PPOPN 2
103867: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103868: LD_EXP 79
103872: PUSH
103873: LD_EXP 107
103877: AND
103878: IFFALSE 103975
103880: GO 103882
103882: DISABLE
103883: LD_INT 0
103885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103886: LD_ADDR_VAR 0 1
103890: PUSH
103891: LD_INT 22
103893: PUSH
103894: LD_OWVAR 2
103898: PUSH
103899: EMPTY
103900: LIST
103901: LIST
103902: PUSH
103903: LD_INT 21
103905: PUSH
103906: LD_INT 1
103908: PUSH
103909: EMPTY
103910: LIST
103911: LIST
103912: PUSH
103913: LD_INT 3
103915: PUSH
103916: LD_INT 23
103918: PUSH
103919: LD_INT 0
103921: PUSH
103922: EMPTY
103923: LIST
103924: LIST
103925: PUSH
103926: EMPTY
103927: LIST
103928: LIST
103929: PUSH
103930: EMPTY
103931: LIST
103932: LIST
103933: LIST
103934: PPUSH
103935: CALL_OW 69
103939: ST_TO_ADDR
// if not tmp then
103940: LD_VAR 0 1
103944: NOT
103945: IFFALSE 103949
// exit ;
103947: GO 103975
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103949: LD_VAR 0 1
103953: PUSH
103954: LD_INT 1
103956: PPUSH
103957: LD_VAR 0 1
103961: PPUSH
103962: CALL_OW 12
103966: ARRAY
103967: PPUSH
103968: LD_INT 200
103970: PPUSH
103971: CALL_OW 234
// end ;
103975: PPOPN 1
103977: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103978: LD_EXP 79
103982: PUSH
103983: LD_EXP 108
103987: AND
103988: IFFALSE 104067
103990: GO 103992
103992: DISABLE
103993: LD_INT 0
103995: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103996: LD_ADDR_VAR 0 1
104000: PUSH
104001: LD_INT 22
104003: PUSH
104004: LD_OWVAR 2
104008: PUSH
104009: EMPTY
104010: LIST
104011: LIST
104012: PUSH
104013: LD_INT 21
104015: PUSH
104016: LD_INT 2
104018: PUSH
104019: EMPTY
104020: LIST
104021: LIST
104022: PUSH
104023: EMPTY
104024: LIST
104025: LIST
104026: PPUSH
104027: CALL_OW 69
104031: ST_TO_ADDR
// if not tmp then
104032: LD_VAR 0 1
104036: NOT
104037: IFFALSE 104041
// exit ;
104039: GO 104067
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
104041: LD_VAR 0 1
104045: PUSH
104046: LD_INT 1
104048: PPUSH
104049: LD_VAR 0 1
104053: PPUSH
104054: CALL_OW 12
104058: ARRAY
104059: PPUSH
104060: LD_INT 60
104062: PPUSH
104063: CALL_OW 234
// end ;
104067: PPOPN 1
104069: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
104070: LD_EXP 79
104074: PUSH
104075: LD_EXP 109
104079: AND
104080: IFFALSE 104179
104082: GO 104084
104084: DISABLE
104085: LD_INT 0
104087: PPUSH
104088: PPUSH
// begin enable ;
104089: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
104090: LD_ADDR_VAR 0 1
104094: PUSH
104095: LD_INT 22
104097: PUSH
104098: LD_OWVAR 2
104102: PUSH
104103: EMPTY
104104: LIST
104105: LIST
104106: PUSH
104107: LD_INT 61
104109: PUSH
104110: EMPTY
104111: LIST
104112: PUSH
104113: LD_INT 33
104115: PUSH
104116: LD_INT 2
104118: PUSH
104119: EMPTY
104120: LIST
104121: LIST
104122: PUSH
104123: EMPTY
104124: LIST
104125: LIST
104126: LIST
104127: PPUSH
104128: CALL_OW 69
104132: ST_TO_ADDR
// if not tmp then
104133: LD_VAR 0 1
104137: NOT
104138: IFFALSE 104142
// exit ;
104140: GO 104179
// for i in tmp do
104142: LD_ADDR_VAR 0 2
104146: PUSH
104147: LD_VAR 0 1
104151: PUSH
104152: FOR_IN
104153: IFFALSE 104177
// if IsControledBy ( i ) then
104155: LD_VAR 0 2
104159: PPUSH
104160: CALL_OW 312
104164: IFFALSE 104175
// ComUnlink ( i ) ;
104166: LD_VAR 0 2
104170: PPUSH
104171: CALL_OW 136
104175: GO 104152
104177: POP
104178: POP
// end ;
104179: PPOPN 2
104181: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
104182: LD_EXP 79
104186: PUSH
104187: LD_EXP 110
104191: AND
104192: IFFALSE 104332
104194: GO 104196
104196: DISABLE
104197: LD_INT 0
104199: PPUSH
104200: PPUSH
// begin ToLua ( displayPowell(); ) ;
104201: LD_STRING displayPowell();
104203: PPUSH
104204: CALL_OW 559
// uc_side := 0 ;
104208: LD_ADDR_OWVAR 20
104212: PUSH
104213: LD_INT 0
104215: ST_TO_ADDR
// uc_nation := 2 ;
104216: LD_ADDR_OWVAR 21
104220: PUSH
104221: LD_INT 2
104223: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
104224: LD_ADDR_OWVAR 37
104228: PUSH
104229: LD_INT 14
104231: ST_TO_ADDR
// vc_engine := engine_siberite ;
104232: LD_ADDR_OWVAR 39
104236: PUSH
104237: LD_INT 3
104239: ST_TO_ADDR
// vc_control := control_apeman ;
104240: LD_ADDR_OWVAR 38
104244: PUSH
104245: LD_INT 5
104247: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
104248: LD_ADDR_OWVAR 40
104252: PUSH
104253: LD_INT 29
104255: ST_TO_ADDR
// un := CreateVehicle ;
104256: LD_ADDR_VAR 0 2
104260: PUSH
104261: CALL_OW 45
104265: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104266: LD_VAR 0 2
104270: PPUSH
104271: LD_INT 1
104273: PPUSH
104274: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104278: LD_INT 35
104280: PPUSH
104281: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104285: LD_VAR 0 2
104289: PPUSH
104290: LD_INT 22
104292: PUSH
104293: LD_OWVAR 2
104297: PUSH
104298: EMPTY
104299: LIST
104300: LIST
104301: PPUSH
104302: CALL_OW 69
104306: PPUSH
104307: LD_VAR 0 2
104311: PPUSH
104312: CALL_OW 74
104316: PPUSH
104317: CALL_OW 115
// until IsDead ( un ) ;
104321: LD_VAR 0 2
104325: PPUSH
104326: CALL_OW 301
104330: IFFALSE 104278
// end ;
104332: PPOPN 2
104334: END
// every 0 0$1 trigger StreamModeActive and sStu do
104335: LD_EXP 79
104339: PUSH
104340: LD_EXP 118
104344: AND
104345: IFFALSE 104361
104347: GO 104349
104349: DISABLE
// begin ToLua ( displayStucuk(); ) ;
104350: LD_STRING displayStucuk();
104352: PPUSH
104353: CALL_OW 559
// ResetFog ;
104357: CALL_OW 335
// end ;
104361: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
104362: LD_EXP 79
104366: PUSH
104367: LD_EXP 111
104371: AND
104372: IFFALSE 104513
104374: GO 104376
104376: DISABLE
104377: LD_INT 0
104379: PPUSH
104380: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104381: LD_ADDR_VAR 0 2
104385: PUSH
104386: LD_INT 22
104388: PUSH
104389: LD_OWVAR 2
104393: PUSH
104394: EMPTY
104395: LIST
104396: LIST
104397: PUSH
104398: LD_INT 21
104400: PUSH
104401: LD_INT 1
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: PUSH
104408: EMPTY
104409: LIST
104410: LIST
104411: PPUSH
104412: CALL_OW 69
104416: ST_TO_ADDR
// if not tmp then
104417: LD_VAR 0 2
104421: NOT
104422: IFFALSE 104426
// exit ;
104424: GO 104513
// un := tmp [ rand ( 1 , tmp ) ] ;
104426: LD_ADDR_VAR 0 1
104430: PUSH
104431: LD_VAR 0 2
104435: PUSH
104436: LD_INT 1
104438: PPUSH
104439: LD_VAR 0 2
104443: PPUSH
104444: CALL_OW 12
104448: ARRAY
104449: ST_TO_ADDR
// SetSide ( un , 0 ) ;
104450: LD_VAR 0 1
104454: PPUSH
104455: LD_INT 0
104457: PPUSH
104458: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
104462: LD_VAR 0 1
104466: PPUSH
104467: LD_OWVAR 3
104471: PUSH
104472: LD_VAR 0 1
104476: DIFF
104477: PPUSH
104478: LD_VAR 0 1
104482: PPUSH
104483: CALL_OW 74
104487: PPUSH
104488: CALL_OW 115
// wait ( 0 0$20 ) ;
104492: LD_INT 700
104494: PPUSH
104495: CALL_OW 67
// SetSide ( un , your_side ) ;
104499: LD_VAR 0 1
104503: PPUSH
104504: LD_OWVAR 2
104508: PPUSH
104509: CALL_OW 235
// end ;
104513: PPOPN 2
104515: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104516: LD_EXP 79
104520: PUSH
104521: LD_EXP 112
104525: AND
104526: IFFALSE 104632
104528: GO 104530
104530: DISABLE
104531: LD_INT 0
104533: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104534: LD_ADDR_VAR 0 1
104538: PUSH
104539: LD_INT 22
104541: PUSH
104542: LD_OWVAR 2
104546: PUSH
104547: EMPTY
104548: LIST
104549: LIST
104550: PUSH
104551: LD_INT 2
104553: PUSH
104554: LD_INT 30
104556: PUSH
104557: LD_INT 0
104559: PUSH
104560: EMPTY
104561: LIST
104562: LIST
104563: PUSH
104564: LD_INT 30
104566: PUSH
104567: LD_INT 1
104569: PUSH
104570: EMPTY
104571: LIST
104572: LIST
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: LIST
104578: PUSH
104579: EMPTY
104580: LIST
104581: LIST
104582: PPUSH
104583: CALL_OW 69
104587: ST_TO_ADDR
// if not depot then
104588: LD_VAR 0 1
104592: NOT
104593: IFFALSE 104597
// exit ;
104595: GO 104632
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104597: LD_VAR 0 1
104601: PUSH
104602: LD_INT 1
104604: ARRAY
104605: PPUSH
104606: CALL_OW 250
104610: PPUSH
104611: LD_VAR 0 1
104615: PUSH
104616: LD_INT 1
104618: ARRAY
104619: PPUSH
104620: CALL_OW 251
104624: PPUSH
104625: LD_INT 70
104627: PPUSH
104628: CALL_OW 495
// end ;
104632: PPOPN 1
104634: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104635: LD_EXP 79
104639: PUSH
104640: LD_EXP 113
104644: AND
104645: IFFALSE 104856
104647: GO 104649
104649: DISABLE
104650: LD_INT 0
104652: PPUSH
104653: PPUSH
104654: PPUSH
104655: PPUSH
104656: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104657: LD_ADDR_VAR 0 5
104661: PUSH
104662: LD_INT 22
104664: PUSH
104665: LD_OWVAR 2
104669: PUSH
104670: EMPTY
104671: LIST
104672: LIST
104673: PUSH
104674: LD_INT 21
104676: PUSH
104677: LD_INT 1
104679: PUSH
104680: EMPTY
104681: LIST
104682: LIST
104683: PUSH
104684: EMPTY
104685: LIST
104686: LIST
104687: PPUSH
104688: CALL_OW 69
104692: ST_TO_ADDR
// if not tmp then
104693: LD_VAR 0 5
104697: NOT
104698: IFFALSE 104702
// exit ;
104700: GO 104856
// for i in tmp do
104702: LD_ADDR_VAR 0 1
104706: PUSH
104707: LD_VAR 0 5
104711: PUSH
104712: FOR_IN
104713: IFFALSE 104854
// begin d := rand ( 0 , 5 ) ;
104715: LD_ADDR_VAR 0 4
104719: PUSH
104720: LD_INT 0
104722: PPUSH
104723: LD_INT 5
104725: PPUSH
104726: CALL_OW 12
104730: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104731: LD_ADDR_VAR 0 2
104735: PUSH
104736: LD_VAR 0 1
104740: PPUSH
104741: CALL_OW 250
104745: PPUSH
104746: LD_VAR 0 4
104750: PPUSH
104751: LD_INT 3
104753: PPUSH
104754: LD_INT 12
104756: PPUSH
104757: CALL_OW 12
104761: PPUSH
104762: CALL_OW 272
104766: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104767: LD_ADDR_VAR 0 3
104771: PUSH
104772: LD_VAR 0 1
104776: PPUSH
104777: CALL_OW 251
104781: PPUSH
104782: LD_VAR 0 4
104786: PPUSH
104787: LD_INT 3
104789: PPUSH
104790: LD_INT 12
104792: PPUSH
104793: CALL_OW 12
104797: PPUSH
104798: CALL_OW 273
104802: ST_TO_ADDR
// if ValidHex ( x , y ) then
104803: LD_VAR 0 2
104807: PPUSH
104808: LD_VAR 0 3
104812: PPUSH
104813: CALL_OW 488
104817: IFFALSE 104852
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104819: LD_VAR 0 1
104823: PPUSH
104824: LD_VAR 0 2
104828: PPUSH
104829: LD_VAR 0 3
104833: PPUSH
104834: LD_INT 3
104836: PPUSH
104837: LD_INT 6
104839: PPUSH
104840: CALL_OW 12
104844: PPUSH
104845: LD_INT 1
104847: PPUSH
104848: CALL_OW 483
// end ;
104852: GO 104712
104854: POP
104855: POP
// end ;
104856: PPOPN 5
104858: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104859: LD_EXP 79
104863: PUSH
104864: LD_EXP 114
104868: AND
104869: IFFALSE 104963
104871: GO 104873
104873: DISABLE
104874: LD_INT 0
104876: PPUSH
104877: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104878: LD_ADDR_VAR 0 2
104882: PUSH
104883: LD_INT 22
104885: PUSH
104886: LD_OWVAR 2
104890: PUSH
104891: EMPTY
104892: LIST
104893: LIST
104894: PUSH
104895: LD_INT 32
104897: PUSH
104898: LD_INT 1
104900: PUSH
104901: EMPTY
104902: LIST
104903: LIST
104904: PUSH
104905: LD_INT 21
104907: PUSH
104908: LD_INT 2
104910: PUSH
104911: EMPTY
104912: LIST
104913: LIST
104914: PUSH
104915: EMPTY
104916: LIST
104917: LIST
104918: LIST
104919: PPUSH
104920: CALL_OW 69
104924: ST_TO_ADDR
// if not tmp then
104925: LD_VAR 0 2
104929: NOT
104930: IFFALSE 104934
// exit ;
104932: GO 104963
// for i in tmp do
104934: LD_ADDR_VAR 0 1
104938: PUSH
104939: LD_VAR 0 2
104943: PUSH
104944: FOR_IN
104945: IFFALSE 104961
// SetFuel ( i , 0 ) ;
104947: LD_VAR 0 1
104951: PPUSH
104952: LD_INT 0
104954: PPUSH
104955: CALL_OW 240
104959: GO 104944
104961: POP
104962: POP
// end ;
104963: PPOPN 2
104965: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104966: LD_EXP 79
104970: PUSH
104971: LD_EXP 115
104975: AND
104976: IFFALSE 105042
104978: GO 104980
104980: DISABLE
104981: LD_INT 0
104983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104984: LD_ADDR_VAR 0 1
104988: PUSH
104989: LD_INT 22
104991: PUSH
104992: LD_OWVAR 2
104996: PUSH
104997: EMPTY
104998: LIST
104999: LIST
105000: PUSH
105001: LD_INT 30
105003: PUSH
105004: LD_INT 29
105006: PUSH
105007: EMPTY
105008: LIST
105009: LIST
105010: PUSH
105011: EMPTY
105012: LIST
105013: LIST
105014: PPUSH
105015: CALL_OW 69
105019: ST_TO_ADDR
// if not tmp then
105020: LD_VAR 0 1
105024: NOT
105025: IFFALSE 105029
// exit ;
105027: GO 105042
// DestroyUnit ( tmp [ 1 ] ) ;
105029: LD_VAR 0 1
105033: PUSH
105034: LD_INT 1
105036: ARRAY
105037: PPUSH
105038: CALL_OW 65
// end ;
105042: PPOPN 1
105044: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
105045: LD_EXP 79
105049: PUSH
105050: LD_EXP 117
105054: AND
105055: IFFALSE 105184
105057: GO 105059
105059: DISABLE
105060: LD_INT 0
105062: PPUSH
// begin uc_side := 0 ;
105063: LD_ADDR_OWVAR 20
105067: PUSH
105068: LD_INT 0
105070: ST_TO_ADDR
// uc_nation := nation_arabian ;
105071: LD_ADDR_OWVAR 21
105075: PUSH
105076: LD_INT 2
105078: ST_TO_ADDR
// hc_gallery :=  ;
105079: LD_ADDR_OWVAR 33
105083: PUSH
105084: LD_STRING 
105086: ST_TO_ADDR
// hc_name :=  ;
105087: LD_ADDR_OWVAR 26
105091: PUSH
105092: LD_STRING 
105094: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
105095: LD_INT 1
105097: PPUSH
105098: LD_INT 11
105100: PPUSH
105101: LD_INT 10
105103: PPUSH
105104: CALL_OW 380
// un := CreateHuman ;
105108: LD_ADDR_VAR 0 1
105112: PUSH
105113: CALL_OW 44
105117: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
105118: LD_VAR 0 1
105122: PPUSH
105123: LD_INT 1
105125: PPUSH
105126: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105130: LD_INT 35
105132: PPUSH
105133: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105137: LD_VAR 0 1
105141: PPUSH
105142: LD_INT 22
105144: PUSH
105145: LD_OWVAR 2
105149: PUSH
105150: EMPTY
105151: LIST
105152: LIST
105153: PPUSH
105154: CALL_OW 69
105158: PPUSH
105159: LD_VAR 0 1
105163: PPUSH
105164: CALL_OW 74
105168: PPUSH
105169: CALL_OW 115
// until IsDead ( un ) ;
105173: LD_VAR 0 1
105177: PPUSH
105178: CALL_OW 301
105182: IFFALSE 105130
// end ;
105184: PPOPN 1
105186: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
105187: LD_EXP 79
105191: PUSH
105192: LD_EXP 119
105196: AND
105197: IFFALSE 105209
105199: GO 105201
105201: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
105202: LD_STRING earthquake(getX(game), 0, 32)
105204: PPUSH
105205: CALL_OW 559
105209: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
105210: LD_EXP 79
105214: PUSH
105215: LD_EXP 120
105219: AND
105220: IFFALSE 105311
105222: GO 105224
105224: DISABLE
105225: LD_INT 0
105227: PPUSH
// begin enable ;
105228: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
105229: LD_ADDR_VAR 0 1
105233: PUSH
105234: LD_INT 22
105236: PUSH
105237: LD_OWVAR 2
105241: PUSH
105242: EMPTY
105243: LIST
105244: LIST
105245: PUSH
105246: LD_INT 21
105248: PUSH
105249: LD_INT 2
105251: PUSH
105252: EMPTY
105253: LIST
105254: LIST
105255: PUSH
105256: LD_INT 33
105258: PUSH
105259: LD_INT 3
105261: PUSH
105262: EMPTY
105263: LIST
105264: LIST
105265: PUSH
105266: EMPTY
105267: LIST
105268: LIST
105269: LIST
105270: PPUSH
105271: CALL_OW 69
105275: ST_TO_ADDR
// if not tmp then
105276: LD_VAR 0 1
105280: NOT
105281: IFFALSE 105285
// exit ;
105283: GO 105311
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105285: LD_VAR 0 1
105289: PUSH
105290: LD_INT 1
105292: PPUSH
105293: LD_VAR 0 1
105297: PPUSH
105298: CALL_OW 12
105302: ARRAY
105303: PPUSH
105304: LD_INT 1
105306: PPUSH
105307: CALL_OW 234
// end ;
105311: PPOPN 1
105313: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
105314: LD_EXP 79
105318: PUSH
105319: LD_EXP 121
105323: AND
105324: IFFALSE 105465
105326: GO 105328
105328: DISABLE
105329: LD_INT 0
105331: PPUSH
105332: PPUSH
105333: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105334: LD_ADDR_VAR 0 3
105338: PUSH
105339: LD_INT 22
105341: PUSH
105342: LD_OWVAR 2
105346: PUSH
105347: EMPTY
105348: LIST
105349: LIST
105350: PUSH
105351: LD_INT 25
105353: PUSH
105354: LD_INT 1
105356: PUSH
105357: EMPTY
105358: LIST
105359: LIST
105360: PUSH
105361: EMPTY
105362: LIST
105363: LIST
105364: PPUSH
105365: CALL_OW 69
105369: ST_TO_ADDR
// if not tmp then
105370: LD_VAR 0 3
105374: NOT
105375: IFFALSE 105379
// exit ;
105377: GO 105465
// un := tmp [ rand ( 1 , tmp ) ] ;
105379: LD_ADDR_VAR 0 2
105383: PUSH
105384: LD_VAR 0 3
105388: PUSH
105389: LD_INT 1
105391: PPUSH
105392: LD_VAR 0 3
105396: PPUSH
105397: CALL_OW 12
105401: ARRAY
105402: ST_TO_ADDR
// if Crawls ( un ) then
105403: LD_VAR 0 2
105407: PPUSH
105408: CALL_OW 318
105412: IFFALSE 105423
// ComWalk ( un ) ;
105414: LD_VAR 0 2
105418: PPUSH
105419: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
105423: LD_VAR 0 2
105427: PPUSH
105428: LD_INT 9
105430: PPUSH
105431: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
105435: LD_INT 28
105437: PPUSH
105438: LD_OWVAR 2
105442: PPUSH
105443: LD_INT 2
105445: PPUSH
105446: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
105450: LD_INT 29
105452: PPUSH
105453: LD_OWVAR 2
105457: PPUSH
105458: LD_INT 2
105460: PPUSH
105461: CALL_OW 322
// end ;
105465: PPOPN 3
105467: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105468: LD_EXP 79
105472: PUSH
105473: LD_EXP 122
105477: AND
105478: IFFALSE 105589
105480: GO 105482
105482: DISABLE
105483: LD_INT 0
105485: PPUSH
105486: PPUSH
105487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105488: LD_ADDR_VAR 0 3
105492: PUSH
105493: LD_INT 22
105495: PUSH
105496: LD_OWVAR 2
105500: PUSH
105501: EMPTY
105502: LIST
105503: LIST
105504: PUSH
105505: LD_INT 25
105507: PUSH
105508: LD_INT 1
105510: PUSH
105511: EMPTY
105512: LIST
105513: LIST
105514: PUSH
105515: EMPTY
105516: LIST
105517: LIST
105518: PPUSH
105519: CALL_OW 69
105523: ST_TO_ADDR
// if not tmp then
105524: LD_VAR 0 3
105528: NOT
105529: IFFALSE 105533
// exit ;
105531: GO 105589
// un := tmp [ rand ( 1 , tmp ) ] ;
105533: LD_ADDR_VAR 0 2
105537: PUSH
105538: LD_VAR 0 3
105542: PUSH
105543: LD_INT 1
105545: PPUSH
105546: LD_VAR 0 3
105550: PPUSH
105551: CALL_OW 12
105555: ARRAY
105556: ST_TO_ADDR
// if Crawls ( un ) then
105557: LD_VAR 0 2
105561: PPUSH
105562: CALL_OW 318
105566: IFFALSE 105577
// ComWalk ( un ) ;
105568: LD_VAR 0 2
105572: PPUSH
105573: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105577: LD_VAR 0 2
105581: PPUSH
105582: LD_INT 8
105584: PPUSH
105585: CALL_OW 336
// end ;
105589: PPOPN 3
105591: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105592: LD_EXP 79
105596: PUSH
105597: LD_EXP 123
105601: AND
105602: IFFALSE 105746
105604: GO 105606
105606: DISABLE
105607: LD_INT 0
105609: PPUSH
105610: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105611: LD_ADDR_VAR 0 2
105615: PUSH
105616: LD_INT 22
105618: PUSH
105619: LD_OWVAR 2
105623: PUSH
105624: EMPTY
105625: LIST
105626: LIST
105627: PUSH
105628: LD_INT 21
105630: PUSH
105631: LD_INT 2
105633: PUSH
105634: EMPTY
105635: LIST
105636: LIST
105637: PUSH
105638: LD_INT 2
105640: PUSH
105641: LD_INT 34
105643: PUSH
105644: LD_INT 12
105646: PUSH
105647: EMPTY
105648: LIST
105649: LIST
105650: PUSH
105651: LD_INT 34
105653: PUSH
105654: LD_INT 51
105656: PUSH
105657: EMPTY
105658: LIST
105659: LIST
105660: PUSH
105661: LD_INT 34
105663: PUSH
105664: LD_INT 32
105666: PUSH
105667: EMPTY
105668: LIST
105669: LIST
105670: PUSH
105671: EMPTY
105672: LIST
105673: LIST
105674: LIST
105675: LIST
105676: PUSH
105677: EMPTY
105678: LIST
105679: LIST
105680: LIST
105681: PPUSH
105682: CALL_OW 69
105686: ST_TO_ADDR
// if not tmp then
105687: LD_VAR 0 2
105691: NOT
105692: IFFALSE 105696
// exit ;
105694: GO 105746
// for i in tmp do
105696: LD_ADDR_VAR 0 1
105700: PUSH
105701: LD_VAR 0 2
105705: PUSH
105706: FOR_IN
105707: IFFALSE 105744
// if GetCargo ( i , mat_artifact ) = 0 then
105709: LD_VAR 0 1
105713: PPUSH
105714: LD_INT 4
105716: PPUSH
105717: CALL_OW 289
105721: PUSH
105722: LD_INT 0
105724: EQUAL
105725: IFFALSE 105742
// SetCargo ( i , mat_siberit , 100 ) ;
105727: LD_VAR 0 1
105731: PPUSH
105732: LD_INT 3
105734: PPUSH
105735: LD_INT 100
105737: PPUSH
105738: CALL_OW 290
105742: GO 105706
105744: POP
105745: POP
// end ;
105746: PPOPN 2
105748: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105749: LD_EXP 79
105753: PUSH
105754: LD_EXP 124
105758: AND
105759: IFFALSE 105942
105761: GO 105763
105763: DISABLE
105764: LD_INT 0
105766: PPUSH
105767: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105768: LD_ADDR_VAR 0 2
105772: PUSH
105773: LD_INT 22
105775: PUSH
105776: LD_OWVAR 2
105780: PUSH
105781: EMPTY
105782: LIST
105783: LIST
105784: PPUSH
105785: CALL_OW 69
105789: ST_TO_ADDR
// if not tmp then
105790: LD_VAR 0 2
105794: NOT
105795: IFFALSE 105799
// exit ;
105797: GO 105942
// for i := 1 to 2 do
105799: LD_ADDR_VAR 0 1
105803: PUSH
105804: DOUBLE
105805: LD_INT 1
105807: DEC
105808: ST_TO_ADDR
105809: LD_INT 2
105811: PUSH
105812: FOR_TO
105813: IFFALSE 105940
// begin uc_side := your_side ;
105815: LD_ADDR_OWVAR 20
105819: PUSH
105820: LD_OWVAR 2
105824: ST_TO_ADDR
// uc_nation := nation_american ;
105825: LD_ADDR_OWVAR 21
105829: PUSH
105830: LD_INT 1
105832: ST_TO_ADDR
// vc_chassis := us_morphling ;
105833: LD_ADDR_OWVAR 37
105837: PUSH
105838: LD_INT 5
105840: ST_TO_ADDR
// vc_engine := engine_siberite ;
105841: LD_ADDR_OWVAR 39
105845: PUSH
105846: LD_INT 3
105848: ST_TO_ADDR
// vc_control := control_computer ;
105849: LD_ADDR_OWVAR 38
105853: PUSH
105854: LD_INT 3
105856: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105857: LD_ADDR_OWVAR 40
105861: PUSH
105862: LD_INT 10
105864: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105865: LD_VAR 0 2
105869: PUSH
105870: LD_INT 1
105872: ARRAY
105873: PPUSH
105874: CALL_OW 310
105878: NOT
105879: IFFALSE 105926
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105881: CALL_OW 45
105885: PPUSH
105886: LD_VAR 0 2
105890: PUSH
105891: LD_INT 1
105893: ARRAY
105894: PPUSH
105895: CALL_OW 250
105899: PPUSH
105900: LD_VAR 0 2
105904: PUSH
105905: LD_INT 1
105907: ARRAY
105908: PPUSH
105909: CALL_OW 251
105913: PPUSH
105914: LD_INT 12
105916: PPUSH
105917: LD_INT 1
105919: PPUSH
105920: CALL_OW 50
105924: GO 105938
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105926: CALL_OW 45
105930: PPUSH
105931: LD_INT 1
105933: PPUSH
105934: CALL_OW 51
// end ;
105938: GO 105812
105940: POP
105941: POP
// end ;
105942: PPOPN 2
105944: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105945: LD_EXP 79
105949: PUSH
105950: LD_EXP 125
105954: AND
105955: IFFALSE 106177
105957: GO 105959
105959: DISABLE
105960: LD_INT 0
105962: PPUSH
105963: PPUSH
105964: PPUSH
105965: PPUSH
105966: PPUSH
105967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105968: LD_ADDR_VAR 0 6
105972: PUSH
105973: LD_INT 22
105975: PUSH
105976: LD_OWVAR 2
105980: PUSH
105981: EMPTY
105982: LIST
105983: LIST
105984: PUSH
105985: LD_INT 21
105987: PUSH
105988: LD_INT 1
105990: PUSH
105991: EMPTY
105992: LIST
105993: LIST
105994: PUSH
105995: LD_INT 3
105997: PUSH
105998: LD_INT 23
106000: PUSH
106001: LD_INT 0
106003: PUSH
106004: EMPTY
106005: LIST
106006: LIST
106007: PUSH
106008: EMPTY
106009: LIST
106010: LIST
106011: PUSH
106012: EMPTY
106013: LIST
106014: LIST
106015: LIST
106016: PPUSH
106017: CALL_OW 69
106021: ST_TO_ADDR
// if not tmp then
106022: LD_VAR 0 6
106026: NOT
106027: IFFALSE 106031
// exit ;
106029: GO 106177
// s1 := rand ( 1 , 4 ) ;
106031: LD_ADDR_VAR 0 2
106035: PUSH
106036: LD_INT 1
106038: PPUSH
106039: LD_INT 4
106041: PPUSH
106042: CALL_OW 12
106046: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
106047: LD_ADDR_VAR 0 4
106051: PUSH
106052: LD_VAR 0 6
106056: PUSH
106057: LD_INT 1
106059: ARRAY
106060: PPUSH
106061: LD_VAR 0 2
106065: PPUSH
106066: CALL_OW 259
106070: ST_TO_ADDR
// if s1 = 1 then
106071: LD_VAR 0 2
106075: PUSH
106076: LD_INT 1
106078: EQUAL
106079: IFFALSE 106099
// s2 := rand ( 2 , 4 ) else
106081: LD_ADDR_VAR 0 3
106085: PUSH
106086: LD_INT 2
106088: PPUSH
106089: LD_INT 4
106091: PPUSH
106092: CALL_OW 12
106096: ST_TO_ADDR
106097: GO 106107
// s2 := 1 ;
106099: LD_ADDR_VAR 0 3
106103: PUSH
106104: LD_INT 1
106106: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
106107: LD_ADDR_VAR 0 5
106111: PUSH
106112: LD_VAR 0 6
106116: PUSH
106117: LD_INT 1
106119: ARRAY
106120: PPUSH
106121: LD_VAR 0 3
106125: PPUSH
106126: CALL_OW 259
106130: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
106131: LD_VAR 0 6
106135: PUSH
106136: LD_INT 1
106138: ARRAY
106139: PPUSH
106140: LD_VAR 0 2
106144: PPUSH
106145: LD_VAR 0 5
106149: PPUSH
106150: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
106154: LD_VAR 0 6
106158: PUSH
106159: LD_INT 1
106161: ARRAY
106162: PPUSH
106163: LD_VAR 0 3
106167: PPUSH
106168: LD_VAR 0 4
106172: PPUSH
106173: CALL_OW 237
// end ;
106177: PPOPN 6
106179: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
106180: LD_EXP 79
106184: PUSH
106185: LD_EXP 126
106189: AND
106190: IFFALSE 106269
106192: GO 106194
106194: DISABLE
106195: LD_INT 0
106197: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
106198: LD_ADDR_VAR 0 1
106202: PUSH
106203: LD_INT 22
106205: PUSH
106206: LD_OWVAR 2
106210: PUSH
106211: EMPTY
106212: LIST
106213: LIST
106214: PUSH
106215: LD_INT 30
106217: PUSH
106218: LD_INT 3
106220: PUSH
106221: EMPTY
106222: LIST
106223: LIST
106224: PUSH
106225: EMPTY
106226: LIST
106227: LIST
106228: PPUSH
106229: CALL_OW 69
106233: ST_TO_ADDR
// if not tmp then
106234: LD_VAR 0 1
106238: NOT
106239: IFFALSE 106243
// exit ;
106241: GO 106269
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106243: LD_VAR 0 1
106247: PUSH
106248: LD_INT 1
106250: PPUSH
106251: LD_VAR 0 1
106255: PPUSH
106256: CALL_OW 12
106260: ARRAY
106261: PPUSH
106262: LD_INT 1
106264: PPUSH
106265: CALL_OW 234
// end ;
106269: PPOPN 1
106271: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
106272: LD_EXP 79
106276: PUSH
106277: LD_EXP 127
106281: AND
106282: IFFALSE 106394
106284: GO 106286
106286: DISABLE
106287: LD_INT 0
106289: PPUSH
106290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
106291: LD_ADDR_VAR 0 2
106295: PUSH
106296: LD_INT 22
106298: PUSH
106299: LD_OWVAR 2
106303: PUSH
106304: EMPTY
106305: LIST
106306: LIST
106307: PUSH
106308: LD_INT 2
106310: PUSH
106311: LD_INT 30
106313: PUSH
106314: LD_INT 27
106316: PUSH
106317: EMPTY
106318: LIST
106319: LIST
106320: PUSH
106321: LD_INT 30
106323: PUSH
106324: LD_INT 26
106326: PUSH
106327: EMPTY
106328: LIST
106329: LIST
106330: PUSH
106331: LD_INT 30
106333: PUSH
106334: LD_INT 28
106336: PUSH
106337: EMPTY
106338: LIST
106339: LIST
106340: PUSH
106341: EMPTY
106342: LIST
106343: LIST
106344: LIST
106345: LIST
106346: PUSH
106347: EMPTY
106348: LIST
106349: LIST
106350: PPUSH
106351: CALL_OW 69
106355: ST_TO_ADDR
// if not tmp then
106356: LD_VAR 0 2
106360: NOT
106361: IFFALSE 106365
// exit ;
106363: GO 106394
// for i in tmp do
106365: LD_ADDR_VAR 0 1
106369: PUSH
106370: LD_VAR 0 2
106374: PUSH
106375: FOR_IN
106376: IFFALSE 106392
// SetLives ( i , 1 ) ;
106378: LD_VAR 0 1
106382: PPUSH
106383: LD_INT 1
106385: PPUSH
106386: CALL_OW 234
106390: GO 106375
106392: POP
106393: POP
// end ;
106394: PPOPN 2
106396: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
106397: LD_EXP 79
106401: PUSH
106402: LD_EXP 128
106406: AND
106407: IFFALSE 106694
106409: GO 106411
106411: DISABLE
106412: LD_INT 0
106414: PPUSH
106415: PPUSH
106416: PPUSH
// begin i := rand ( 1 , 7 ) ;
106417: LD_ADDR_VAR 0 1
106421: PUSH
106422: LD_INT 1
106424: PPUSH
106425: LD_INT 7
106427: PPUSH
106428: CALL_OW 12
106432: ST_TO_ADDR
// case i of 1 :
106433: LD_VAR 0 1
106437: PUSH
106438: LD_INT 1
106440: DOUBLE
106441: EQUAL
106442: IFTRUE 106446
106444: GO 106456
106446: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
106447: LD_STRING earthquake(getX(game), 0, 32)
106449: PPUSH
106450: CALL_OW 559
106454: GO 106694
106456: LD_INT 2
106458: DOUBLE
106459: EQUAL
106460: IFTRUE 106464
106462: GO 106478
106464: POP
// begin ToLua ( displayStucuk(); ) ;
106465: LD_STRING displayStucuk();
106467: PPUSH
106468: CALL_OW 559
// ResetFog ;
106472: CALL_OW 335
// end ; 3 :
106476: GO 106694
106478: LD_INT 3
106480: DOUBLE
106481: EQUAL
106482: IFTRUE 106486
106484: GO 106590
106486: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106487: LD_ADDR_VAR 0 2
106491: PUSH
106492: LD_INT 22
106494: PUSH
106495: LD_OWVAR 2
106499: PUSH
106500: EMPTY
106501: LIST
106502: LIST
106503: PUSH
106504: LD_INT 25
106506: PUSH
106507: LD_INT 1
106509: PUSH
106510: EMPTY
106511: LIST
106512: LIST
106513: PUSH
106514: EMPTY
106515: LIST
106516: LIST
106517: PPUSH
106518: CALL_OW 69
106522: ST_TO_ADDR
// if not tmp then
106523: LD_VAR 0 2
106527: NOT
106528: IFFALSE 106532
// exit ;
106530: GO 106694
// un := tmp [ rand ( 1 , tmp ) ] ;
106532: LD_ADDR_VAR 0 3
106536: PUSH
106537: LD_VAR 0 2
106541: PUSH
106542: LD_INT 1
106544: PPUSH
106545: LD_VAR 0 2
106549: PPUSH
106550: CALL_OW 12
106554: ARRAY
106555: ST_TO_ADDR
// if Crawls ( un ) then
106556: LD_VAR 0 3
106560: PPUSH
106561: CALL_OW 318
106565: IFFALSE 106576
// ComWalk ( un ) ;
106567: LD_VAR 0 3
106571: PPUSH
106572: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106576: LD_VAR 0 3
106580: PPUSH
106581: LD_INT 8
106583: PPUSH
106584: CALL_OW 336
// end ; 4 :
106588: GO 106694
106590: LD_INT 4
106592: DOUBLE
106593: EQUAL
106594: IFTRUE 106598
106596: GO 106672
106598: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106599: LD_ADDR_VAR 0 2
106603: PUSH
106604: LD_INT 22
106606: PUSH
106607: LD_OWVAR 2
106611: PUSH
106612: EMPTY
106613: LIST
106614: LIST
106615: PUSH
106616: LD_INT 30
106618: PUSH
106619: LD_INT 29
106621: PUSH
106622: EMPTY
106623: LIST
106624: LIST
106625: PUSH
106626: EMPTY
106627: LIST
106628: LIST
106629: PPUSH
106630: CALL_OW 69
106634: ST_TO_ADDR
// if not tmp then
106635: LD_VAR 0 2
106639: NOT
106640: IFFALSE 106644
// exit ;
106642: GO 106694
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106644: LD_VAR 0 2
106648: PUSH
106649: LD_INT 1
106651: ARRAY
106652: PPUSH
106653: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106657: LD_VAR 0 2
106661: PUSH
106662: LD_INT 1
106664: ARRAY
106665: PPUSH
106666: CALL_OW 65
// end ; 5 .. 7 :
106670: GO 106694
106672: LD_INT 5
106674: DOUBLE
106675: GREATEREQUAL
106676: IFFALSE 106684
106678: LD_INT 7
106680: DOUBLE
106681: LESSEQUAL
106682: IFTRUE 106686
106684: GO 106693
106686: POP
// StreamSibBomb ; end ;
106687: CALL 102931 0 0
106691: GO 106694
106693: POP
// end ;
106694: PPOPN 3
106696: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106697: LD_EXP 79
106701: PUSH
106702: LD_EXP 129
106706: AND
106707: IFFALSE 106863
106709: GO 106711
106711: DISABLE
106712: LD_INT 0
106714: PPUSH
106715: PPUSH
106716: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106717: LD_ADDR_VAR 0 2
106721: PUSH
106722: LD_INT 81
106724: PUSH
106725: LD_OWVAR 2
106729: PUSH
106730: EMPTY
106731: LIST
106732: LIST
106733: PUSH
106734: LD_INT 2
106736: PUSH
106737: LD_INT 21
106739: PUSH
106740: LD_INT 1
106742: PUSH
106743: EMPTY
106744: LIST
106745: LIST
106746: PUSH
106747: LD_INT 21
106749: PUSH
106750: LD_INT 2
106752: PUSH
106753: EMPTY
106754: LIST
106755: LIST
106756: PUSH
106757: EMPTY
106758: LIST
106759: LIST
106760: LIST
106761: PUSH
106762: EMPTY
106763: LIST
106764: LIST
106765: PPUSH
106766: CALL_OW 69
106770: ST_TO_ADDR
// if not tmp then
106771: LD_VAR 0 2
106775: NOT
106776: IFFALSE 106780
// exit ;
106778: GO 106863
// p := 0 ;
106780: LD_ADDR_VAR 0 3
106784: PUSH
106785: LD_INT 0
106787: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106788: LD_INT 35
106790: PPUSH
106791: CALL_OW 67
// p := p + 1 ;
106795: LD_ADDR_VAR 0 3
106799: PUSH
106800: LD_VAR 0 3
106804: PUSH
106805: LD_INT 1
106807: PLUS
106808: ST_TO_ADDR
// for i in tmp do
106809: LD_ADDR_VAR 0 1
106813: PUSH
106814: LD_VAR 0 2
106818: PUSH
106819: FOR_IN
106820: IFFALSE 106851
// if GetLives ( i ) < 1000 then
106822: LD_VAR 0 1
106826: PPUSH
106827: CALL_OW 256
106831: PUSH
106832: LD_INT 1000
106834: LESS
106835: IFFALSE 106849
// SetLives ( i , 1000 ) ;
106837: LD_VAR 0 1
106841: PPUSH
106842: LD_INT 1000
106844: PPUSH
106845: CALL_OW 234
106849: GO 106819
106851: POP
106852: POP
// until p > 20 ;
106853: LD_VAR 0 3
106857: PUSH
106858: LD_INT 20
106860: GREATER
106861: IFFALSE 106788
// end ;
106863: PPOPN 3
106865: END
// every 0 0$1 trigger StreamModeActive and sTime do
106866: LD_EXP 79
106870: PUSH
106871: LD_EXP 130
106875: AND
106876: IFFALSE 106911
106878: GO 106880
106880: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106881: LD_INT 28
106883: PPUSH
106884: LD_OWVAR 2
106888: PPUSH
106889: LD_INT 2
106891: PPUSH
106892: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106896: LD_INT 30
106898: PPUSH
106899: LD_OWVAR 2
106903: PPUSH
106904: LD_INT 2
106906: PPUSH
106907: CALL_OW 322
// end ;
106911: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106912: LD_EXP 79
106916: PUSH
106917: LD_EXP 131
106921: AND
106922: IFFALSE 107043
106924: GO 106926
106926: DISABLE
106927: LD_INT 0
106929: PPUSH
106930: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106931: LD_ADDR_VAR 0 2
106935: PUSH
106936: LD_INT 22
106938: PUSH
106939: LD_OWVAR 2
106943: PUSH
106944: EMPTY
106945: LIST
106946: LIST
106947: PUSH
106948: LD_INT 21
106950: PUSH
106951: LD_INT 1
106953: PUSH
106954: EMPTY
106955: LIST
106956: LIST
106957: PUSH
106958: LD_INT 3
106960: PUSH
106961: LD_INT 23
106963: PUSH
106964: LD_INT 0
106966: PUSH
106967: EMPTY
106968: LIST
106969: LIST
106970: PUSH
106971: EMPTY
106972: LIST
106973: LIST
106974: PUSH
106975: EMPTY
106976: LIST
106977: LIST
106978: LIST
106979: PPUSH
106980: CALL_OW 69
106984: ST_TO_ADDR
// if not tmp then
106985: LD_VAR 0 2
106989: NOT
106990: IFFALSE 106994
// exit ;
106992: GO 107043
// for i in tmp do
106994: LD_ADDR_VAR 0 1
106998: PUSH
106999: LD_VAR 0 2
107003: PUSH
107004: FOR_IN
107005: IFFALSE 107041
// begin if Crawls ( i ) then
107007: LD_VAR 0 1
107011: PPUSH
107012: CALL_OW 318
107016: IFFALSE 107027
// ComWalk ( i ) ;
107018: LD_VAR 0 1
107022: PPUSH
107023: CALL_OW 138
// SetClass ( i , 2 ) ;
107027: LD_VAR 0 1
107031: PPUSH
107032: LD_INT 2
107034: PPUSH
107035: CALL_OW 336
// end ;
107039: GO 107004
107041: POP
107042: POP
// end ;
107043: PPOPN 2
107045: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
107046: LD_EXP 79
107050: PUSH
107051: LD_EXP 132
107055: AND
107056: IFFALSE 107344
107058: GO 107060
107060: DISABLE
107061: LD_INT 0
107063: PPUSH
107064: PPUSH
107065: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
107066: LD_OWVAR 2
107070: PPUSH
107071: LD_INT 9
107073: PPUSH
107074: LD_INT 1
107076: PPUSH
107077: LD_INT 1
107079: PPUSH
107080: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
107084: LD_INT 9
107086: PPUSH
107087: LD_OWVAR 2
107091: PPUSH
107092: CALL_OW 343
// uc_side := 9 ;
107096: LD_ADDR_OWVAR 20
107100: PUSH
107101: LD_INT 9
107103: ST_TO_ADDR
// uc_nation := 2 ;
107104: LD_ADDR_OWVAR 21
107108: PUSH
107109: LD_INT 2
107111: ST_TO_ADDR
// hc_name := Dark Warrior ;
107112: LD_ADDR_OWVAR 26
107116: PUSH
107117: LD_STRING Dark Warrior
107119: ST_TO_ADDR
// hc_gallery :=  ;
107120: LD_ADDR_OWVAR 33
107124: PUSH
107125: LD_STRING 
107127: ST_TO_ADDR
// hc_noskilllimit := true ;
107128: LD_ADDR_OWVAR 76
107132: PUSH
107133: LD_INT 1
107135: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
107136: LD_ADDR_OWVAR 31
107140: PUSH
107141: LD_INT 30
107143: PUSH
107144: LD_INT 30
107146: PUSH
107147: LD_INT 30
107149: PUSH
107150: LD_INT 30
107152: PUSH
107153: EMPTY
107154: LIST
107155: LIST
107156: LIST
107157: LIST
107158: ST_TO_ADDR
// un := CreateHuman ;
107159: LD_ADDR_VAR 0 3
107163: PUSH
107164: CALL_OW 44
107168: ST_TO_ADDR
// hc_noskilllimit := false ;
107169: LD_ADDR_OWVAR 76
107173: PUSH
107174: LD_INT 0
107176: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
107177: LD_VAR 0 3
107181: PPUSH
107182: LD_INT 1
107184: PPUSH
107185: CALL_OW 51
// ToLua ( playRanger() ) ;
107189: LD_STRING playRanger()
107191: PPUSH
107192: CALL_OW 559
// p := 0 ;
107196: LD_ADDR_VAR 0 2
107200: PUSH
107201: LD_INT 0
107203: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
107204: LD_INT 35
107206: PPUSH
107207: CALL_OW 67
// p := p + 1 ;
107211: LD_ADDR_VAR 0 2
107215: PUSH
107216: LD_VAR 0 2
107220: PUSH
107221: LD_INT 1
107223: PLUS
107224: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
107225: LD_VAR 0 3
107229: PPUSH
107230: CALL_OW 256
107234: PUSH
107235: LD_INT 1000
107237: LESS
107238: IFFALSE 107252
// SetLives ( un , 1000 ) ;
107240: LD_VAR 0 3
107244: PPUSH
107245: LD_INT 1000
107247: PPUSH
107248: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
107252: LD_VAR 0 3
107256: PPUSH
107257: LD_INT 81
107259: PUSH
107260: LD_OWVAR 2
107264: PUSH
107265: EMPTY
107266: LIST
107267: LIST
107268: PUSH
107269: LD_INT 91
107271: PUSH
107272: LD_VAR 0 3
107276: PUSH
107277: LD_INT 30
107279: PUSH
107280: EMPTY
107281: LIST
107282: LIST
107283: LIST
107284: PUSH
107285: EMPTY
107286: LIST
107287: LIST
107288: PPUSH
107289: CALL_OW 69
107293: PPUSH
107294: LD_VAR 0 3
107298: PPUSH
107299: CALL_OW 74
107303: PPUSH
107304: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
107308: LD_VAR 0 2
107312: PUSH
107313: LD_INT 80
107315: GREATER
107316: PUSH
107317: LD_VAR 0 3
107321: PPUSH
107322: CALL_OW 301
107326: OR
107327: IFFALSE 107204
// if un then
107329: LD_VAR 0 3
107333: IFFALSE 107344
// RemoveUnit ( un ) ;
107335: LD_VAR 0 3
107339: PPUSH
107340: CALL_OW 64
// end ;
107344: PPOPN 3
107346: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
107347: LD_EXP 133
107351: IFFALSE 107467
107353: GO 107355
107355: DISABLE
107356: LD_INT 0
107358: PPUSH
107359: PPUSH
107360: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107361: LD_ADDR_VAR 0 2
107365: PUSH
107366: LD_INT 81
107368: PUSH
107369: LD_OWVAR 2
107373: PUSH
107374: EMPTY
107375: LIST
107376: LIST
107377: PUSH
107378: LD_INT 21
107380: PUSH
107381: LD_INT 1
107383: PUSH
107384: EMPTY
107385: LIST
107386: LIST
107387: PUSH
107388: EMPTY
107389: LIST
107390: LIST
107391: PPUSH
107392: CALL_OW 69
107396: ST_TO_ADDR
// ToLua ( playComputer() ) ;
107397: LD_STRING playComputer()
107399: PPUSH
107400: CALL_OW 559
// if not tmp then
107404: LD_VAR 0 2
107408: NOT
107409: IFFALSE 107413
// exit ;
107411: GO 107467
// for i in tmp do
107413: LD_ADDR_VAR 0 1
107417: PUSH
107418: LD_VAR 0 2
107422: PUSH
107423: FOR_IN
107424: IFFALSE 107465
// for j := 1 to 4 do
107426: LD_ADDR_VAR 0 3
107430: PUSH
107431: DOUBLE
107432: LD_INT 1
107434: DEC
107435: ST_TO_ADDR
107436: LD_INT 4
107438: PUSH
107439: FOR_TO
107440: IFFALSE 107461
// SetSkill ( i , j , 10 ) ;
107442: LD_VAR 0 1
107446: PPUSH
107447: LD_VAR 0 3
107451: PPUSH
107452: LD_INT 10
107454: PPUSH
107455: CALL_OW 237
107459: GO 107439
107461: POP
107462: POP
107463: GO 107423
107465: POP
107466: POP
// end ;
107467: PPOPN 3
107469: END
// every 0 0$1 trigger s30 do var i , tmp ;
107470: LD_EXP 134
107474: IFFALSE 107543
107476: GO 107478
107478: DISABLE
107479: LD_INT 0
107481: PPUSH
107482: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107483: LD_ADDR_VAR 0 2
107487: PUSH
107488: LD_INT 22
107490: PUSH
107491: LD_OWVAR 2
107495: PUSH
107496: EMPTY
107497: LIST
107498: LIST
107499: PPUSH
107500: CALL_OW 69
107504: ST_TO_ADDR
// if not tmp then
107505: LD_VAR 0 2
107509: NOT
107510: IFFALSE 107514
// exit ;
107512: GO 107543
// for i in tmp do
107514: LD_ADDR_VAR 0 1
107518: PUSH
107519: LD_VAR 0 2
107523: PUSH
107524: FOR_IN
107525: IFFALSE 107541
// SetLives ( i , 300 ) ;
107527: LD_VAR 0 1
107531: PPUSH
107532: LD_INT 300
107534: PPUSH
107535: CALL_OW 234
107539: GO 107524
107541: POP
107542: POP
// end ;
107543: PPOPN 2
107545: END
// every 0 0$1 trigger s60 do var i , tmp ;
107546: LD_EXP 135
107550: IFFALSE 107619
107552: GO 107554
107554: DISABLE
107555: LD_INT 0
107557: PPUSH
107558: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107559: LD_ADDR_VAR 0 2
107563: PUSH
107564: LD_INT 22
107566: PUSH
107567: LD_OWVAR 2
107571: PUSH
107572: EMPTY
107573: LIST
107574: LIST
107575: PPUSH
107576: CALL_OW 69
107580: ST_TO_ADDR
// if not tmp then
107581: LD_VAR 0 2
107585: NOT
107586: IFFALSE 107590
// exit ;
107588: GO 107619
// for i in tmp do
107590: LD_ADDR_VAR 0 1
107594: PUSH
107595: LD_VAR 0 2
107599: PUSH
107600: FOR_IN
107601: IFFALSE 107617
// SetLives ( i , 600 ) ;
107603: LD_VAR 0 1
107607: PPUSH
107608: LD_INT 600
107610: PPUSH
107611: CALL_OW 234
107615: GO 107600
107617: POP
107618: POP
// end ;
107619: PPOPN 2
107621: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107622: LD_INT 0
107624: PPUSH
// case cmd of 301 :
107625: LD_VAR 0 1
107629: PUSH
107630: LD_INT 301
107632: DOUBLE
107633: EQUAL
107634: IFTRUE 107638
107636: GO 107670
107638: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107639: LD_VAR 0 6
107643: PPUSH
107644: LD_VAR 0 7
107648: PPUSH
107649: LD_VAR 0 8
107653: PPUSH
107654: LD_VAR 0 4
107658: PPUSH
107659: LD_VAR 0 5
107663: PPUSH
107664: CALL 108879 0 5
107668: GO 107791
107670: LD_INT 302
107672: DOUBLE
107673: EQUAL
107674: IFTRUE 107678
107676: GO 107715
107678: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107679: LD_VAR 0 6
107683: PPUSH
107684: LD_VAR 0 7
107688: PPUSH
107689: LD_VAR 0 8
107693: PPUSH
107694: LD_VAR 0 9
107698: PPUSH
107699: LD_VAR 0 4
107703: PPUSH
107704: LD_VAR 0 5
107708: PPUSH
107709: CALL 108970 0 6
107713: GO 107791
107715: LD_INT 303
107717: DOUBLE
107718: EQUAL
107719: IFTRUE 107723
107721: GO 107760
107723: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107724: LD_VAR 0 6
107728: PPUSH
107729: LD_VAR 0 7
107733: PPUSH
107734: LD_VAR 0 8
107738: PPUSH
107739: LD_VAR 0 9
107743: PPUSH
107744: LD_VAR 0 4
107748: PPUSH
107749: LD_VAR 0 5
107753: PPUSH
107754: CALL 107796 0 6
107758: GO 107791
107760: LD_INT 304
107762: DOUBLE
107763: EQUAL
107764: IFTRUE 107768
107766: GO 107790
107768: POP
// hHackTeleport ( unit , x , y ) ; end ;
107769: LD_VAR 0 2
107773: PPUSH
107774: LD_VAR 0 4
107778: PPUSH
107779: LD_VAR 0 5
107783: PPUSH
107784: CALL 109563 0 3
107788: GO 107791
107790: POP
// end ;
107791: LD_VAR 0 12
107795: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107796: LD_INT 0
107798: PPUSH
107799: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107800: LD_VAR 0 1
107804: PUSH
107805: LD_INT 1
107807: LESS
107808: PUSH
107809: LD_VAR 0 1
107813: PUSH
107814: LD_INT 3
107816: GREATER
107817: OR
107818: PUSH
107819: LD_VAR 0 5
107823: PPUSH
107824: LD_VAR 0 6
107828: PPUSH
107829: CALL_OW 428
107833: OR
107834: IFFALSE 107838
// exit ;
107836: GO 108566
// uc_side := your_side ;
107838: LD_ADDR_OWVAR 20
107842: PUSH
107843: LD_OWVAR 2
107847: ST_TO_ADDR
// uc_nation := nation ;
107848: LD_ADDR_OWVAR 21
107852: PUSH
107853: LD_VAR 0 1
107857: ST_TO_ADDR
// bc_level = 1 ;
107858: LD_ADDR_OWVAR 43
107862: PUSH
107863: LD_INT 1
107865: ST_TO_ADDR
// case btype of 1 :
107866: LD_VAR 0 2
107870: PUSH
107871: LD_INT 1
107873: DOUBLE
107874: EQUAL
107875: IFTRUE 107879
107877: GO 107890
107879: POP
// bc_type := b_depot ; 2 :
107880: LD_ADDR_OWVAR 42
107884: PUSH
107885: LD_INT 0
107887: ST_TO_ADDR
107888: GO 108510
107890: LD_INT 2
107892: DOUBLE
107893: EQUAL
107894: IFTRUE 107898
107896: GO 107909
107898: POP
// bc_type := b_warehouse ; 3 :
107899: LD_ADDR_OWVAR 42
107903: PUSH
107904: LD_INT 1
107906: ST_TO_ADDR
107907: GO 108510
107909: LD_INT 3
107911: DOUBLE
107912: EQUAL
107913: IFTRUE 107917
107915: GO 107928
107917: POP
// bc_type := b_lab ; 4 .. 9 :
107918: LD_ADDR_OWVAR 42
107922: PUSH
107923: LD_INT 6
107925: ST_TO_ADDR
107926: GO 108510
107928: LD_INT 4
107930: DOUBLE
107931: GREATEREQUAL
107932: IFFALSE 107940
107934: LD_INT 9
107936: DOUBLE
107937: LESSEQUAL
107938: IFTRUE 107942
107940: GO 108002
107942: POP
// begin bc_type := b_lab_half ;
107943: LD_ADDR_OWVAR 42
107947: PUSH
107948: LD_INT 7
107950: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107951: LD_ADDR_OWVAR 44
107955: PUSH
107956: LD_INT 10
107958: PUSH
107959: LD_INT 11
107961: PUSH
107962: LD_INT 12
107964: PUSH
107965: LD_INT 15
107967: PUSH
107968: LD_INT 14
107970: PUSH
107971: LD_INT 13
107973: PUSH
107974: EMPTY
107975: LIST
107976: LIST
107977: LIST
107978: LIST
107979: LIST
107980: LIST
107981: PUSH
107982: LD_VAR 0 2
107986: PUSH
107987: LD_INT 3
107989: MINUS
107990: ARRAY
107991: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
107992: LD_ADDR_OWVAR 45
107996: PUSH
107997: LD_INT 9
107999: ST_TO_ADDR
// end ; 10 .. 13 :
108000: GO 108510
108002: LD_INT 10
108004: DOUBLE
108005: GREATEREQUAL
108006: IFFALSE 108014
108008: LD_INT 13
108010: DOUBLE
108011: LESSEQUAL
108012: IFTRUE 108016
108014: GO 108093
108016: POP
// begin bc_type := b_lab_full ;
108017: LD_ADDR_OWVAR 42
108021: PUSH
108022: LD_INT 8
108024: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
108025: LD_ADDR_OWVAR 44
108029: PUSH
108030: LD_INT 10
108032: PUSH
108033: LD_INT 12
108035: PUSH
108036: LD_INT 14
108038: PUSH
108039: LD_INT 13
108041: PUSH
108042: EMPTY
108043: LIST
108044: LIST
108045: LIST
108046: LIST
108047: PUSH
108048: LD_VAR 0 2
108052: PUSH
108053: LD_INT 9
108055: MINUS
108056: ARRAY
108057: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
108058: LD_ADDR_OWVAR 45
108062: PUSH
108063: LD_INT 11
108065: PUSH
108066: LD_INT 15
108068: PUSH
108069: LD_INT 12
108071: PUSH
108072: LD_INT 15
108074: PUSH
108075: EMPTY
108076: LIST
108077: LIST
108078: LIST
108079: LIST
108080: PUSH
108081: LD_VAR 0 2
108085: PUSH
108086: LD_INT 9
108088: MINUS
108089: ARRAY
108090: ST_TO_ADDR
// end ; 14 :
108091: GO 108510
108093: LD_INT 14
108095: DOUBLE
108096: EQUAL
108097: IFTRUE 108101
108099: GO 108112
108101: POP
// bc_type := b_workshop ; 15 :
108102: LD_ADDR_OWVAR 42
108106: PUSH
108107: LD_INT 2
108109: ST_TO_ADDR
108110: GO 108510
108112: LD_INT 15
108114: DOUBLE
108115: EQUAL
108116: IFTRUE 108120
108118: GO 108131
108120: POP
// bc_type := b_factory ; 16 :
108121: LD_ADDR_OWVAR 42
108125: PUSH
108126: LD_INT 3
108128: ST_TO_ADDR
108129: GO 108510
108131: LD_INT 16
108133: DOUBLE
108134: EQUAL
108135: IFTRUE 108139
108137: GO 108150
108139: POP
// bc_type := b_ext_gun ; 17 :
108140: LD_ADDR_OWVAR 42
108144: PUSH
108145: LD_INT 17
108147: ST_TO_ADDR
108148: GO 108510
108150: LD_INT 17
108152: DOUBLE
108153: EQUAL
108154: IFTRUE 108158
108156: GO 108186
108158: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
108159: LD_ADDR_OWVAR 42
108163: PUSH
108164: LD_INT 19
108166: PUSH
108167: LD_INT 23
108169: PUSH
108170: LD_INT 19
108172: PUSH
108173: EMPTY
108174: LIST
108175: LIST
108176: LIST
108177: PUSH
108178: LD_VAR 0 1
108182: ARRAY
108183: ST_TO_ADDR
108184: GO 108510
108186: LD_INT 18
108188: DOUBLE
108189: EQUAL
108190: IFTRUE 108194
108192: GO 108205
108194: POP
// bc_type := b_ext_radar ; 19 :
108195: LD_ADDR_OWVAR 42
108199: PUSH
108200: LD_INT 20
108202: ST_TO_ADDR
108203: GO 108510
108205: LD_INT 19
108207: DOUBLE
108208: EQUAL
108209: IFTRUE 108213
108211: GO 108224
108213: POP
// bc_type := b_ext_radio ; 20 :
108214: LD_ADDR_OWVAR 42
108218: PUSH
108219: LD_INT 22
108221: ST_TO_ADDR
108222: GO 108510
108224: LD_INT 20
108226: DOUBLE
108227: EQUAL
108228: IFTRUE 108232
108230: GO 108243
108232: POP
// bc_type := b_ext_siberium ; 21 :
108233: LD_ADDR_OWVAR 42
108237: PUSH
108238: LD_INT 21
108240: ST_TO_ADDR
108241: GO 108510
108243: LD_INT 21
108245: DOUBLE
108246: EQUAL
108247: IFTRUE 108251
108249: GO 108262
108251: POP
// bc_type := b_ext_computer ; 22 :
108252: LD_ADDR_OWVAR 42
108256: PUSH
108257: LD_INT 24
108259: ST_TO_ADDR
108260: GO 108510
108262: LD_INT 22
108264: DOUBLE
108265: EQUAL
108266: IFTRUE 108270
108268: GO 108281
108270: POP
// bc_type := b_ext_track ; 23 :
108271: LD_ADDR_OWVAR 42
108275: PUSH
108276: LD_INT 16
108278: ST_TO_ADDR
108279: GO 108510
108281: LD_INT 23
108283: DOUBLE
108284: EQUAL
108285: IFTRUE 108289
108287: GO 108300
108289: POP
// bc_type := b_ext_laser ; 24 :
108290: LD_ADDR_OWVAR 42
108294: PUSH
108295: LD_INT 25
108297: ST_TO_ADDR
108298: GO 108510
108300: LD_INT 24
108302: DOUBLE
108303: EQUAL
108304: IFTRUE 108308
108306: GO 108319
108308: POP
// bc_type := b_control_tower ; 25 :
108309: LD_ADDR_OWVAR 42
108313: PUSH
108314: LD_INT 36
108316: ST_TO_ADDR
108317: GO 108510
108319: LD_INT 25
108321: DOUBLE
108322: EQUAL
108323: IFTRUE 108327
108325: GO 108338
108327: POP
// bc_type := b_breastwork ; 26 :
108328: LD_ADDR_OWVAR 42
108332: PUSH
108333: LD_INT 31
108335: ST_TO_ADDR
108336: GO 108510
108338: LD_INT 26
108340: DOUBLE
108341: EQUAL
108342: IFTRUE 108346
108344: GO 108357
108346: POP
// bc_type := b_bunker ; 27 :
108347: LD_ADDR_OWVAR 42
108351: PUSH
108352: LD_INT 32
108354: ST_TO_ADDR
108355: GO 108510
108357: LD_INT 27
108359: DOUBLE
108360: EQUAL
108361: IFTRUE 108365
108363: GO 108376
108365: POP
// bc_type := b_turret ; 28 :
108366: LD_ADDR_OWVAR 42
108370: PUSH
108371: LD_INT 33
108373: ST_TO_ADDR
108374: GO 108510
108376: LD_INT 28
108378: DOUBLE
108379: EQUAL
108380: IFTRUE 108384
108382: GO 108395
108384: POP
// bc_type := b_armoury ; 29 :
108385: LD_ADDR_OWVAR 42
108389: PUSH
108390: LD_INT 4
108392: ST_TO_ADDR
108393: GO 108510
108395: LD_INT 29
108397: DOUBLE
108398: EQUAL
108399: IFTRUE 108403
108401: GO 108414
108403: POP
// bc_type := b_barracks ; 30 :
108404: LD_ADDR_OWVAR 42
108408: PUSH
108409: LD_INT 5
108411: ST_TO_ADDR
108412: GO 108510
108414: LD_INT 30
108416: DOUBLE
108417: EQUAL
108418: IFTRUE 108422
108420: GO 108433
108422: POP
// bc_type := b_solar_power ; 31 :
108423: LD_ADDR_OWVAR 42
108427: PUSH
108428: LD_INT 27
108430: ST_TO_ADDR
108431: GO 108510
108433: LD_INT 31
108435: DOUBLE
108436: EQUAL
108437: IFTRUE 108441
108439: GO 108452
108441: POP
// bc_type := b_oil_power ; 32 :
108442: LD_ADDR_OWVAR 42
108446: PUSH
108447: LD_INT 26
108449: ST_TO_ADDR
108450: GO 108510
108452: LD_INT 32
108454: DOUBLE
108455: EQUAL
108456: IFTRUE 108460
108458: GO 108471
108460: POP
// bc_type := b_siberite_power ; 33 :
108461: LD_ADDR_OWVAR 42
108465: PUSH
108466: LD_INT 28
108468: ST_TO_ADDR
108469: GO 108510
108471: LD_INT 33
108473: DOUBLE
108474: EQUAL
108475: IFTRUE 108479
108477: GO 108490
108479: POP
// bc_type := b_oil_mine ; 34 :
108480: LD_ADDR_OWVAR 42
108484: PUSH
108485: LD_INT 29
108487: ST_TO_ADDR
108488: GO 108510
108490: LD_INT 34
108492: DOUBLE
108493: EQUAL
108494: IFTRUE 108498
108496: GO 108509
108498: POP
// bc_type := b_siberite_mine ; end ;
108499: LD_ADDR_OWVAR 42
108503: PUSH
108504: LD_INT 30
108506: ST_TO_ADDR
108507: GO 108510
108509: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108510: LD_ADDR_VAR 0 8
108514: PUSH
108515: LD_VAR 0 5
108519: PPUSH
108520: LD_VAR 0 6
108524: PPUSH
108525: LD_VAR 0 3
108529: PPUSH
108530: CALL_OW 47
108534: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108535: LD_OWVAR 42
108539: PUSH
108540: LD_INT 32
108542: PUSH
108543: LD_INT 33
108545: PUSH
108546: EMPTY
108547: LIST
108548: LIST
108549: IN
108550: IFFALSE 108566
// PlaceWeaponTurret ( b , weapon ) ;
108552: LD_VAR 0 8
108556: PPUSH
108557: LD_VAR 0 4
108561: PPUSH
108562: CALL_OW 431
// end ;
108566: LD_VAR 0 7
108570: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108571: LD_INT 0
108573: PPUSH
108574: PPUSH
108575: PPUSH
108576: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108577: LD_ADDR_VAR 0 4
108581: PUSH
108582: LD_INT 22
108584: PUSH
108585: LD_OWVAR 2
108589: PUSH
108590: EMPTY
108591: LIST
108592: LIST
108593: PUSH
108594: LD_INT 2
108596: PUSH
108597: LD_INT 30
108599: PUSH
108600: LD_INT 0
108602: PUSH
108603: EMPTY
108604: LIST
108605: LIST
108606: PUSH
108607: LD_INT 30
108609: PUSH
108610: LD_INT 1
108612: PUSH
108613: EMPTY
108614: LIST
108615: LIST
108616: PUSH
108617: EMPTY
108618: LIST
108619: LIST
108620: LIST
108621: PUSH
108622: EMPTY
108623: LIST
108624: LIST
108625: PPUSH
108626: CALL_OW 69
108630: ST_TO_ADDR
// if not tmp then
108631: LD_VAR 0 4
108635: NOT
108636: IFFALSE 108640
// exit ;
108638: GO 108699
// for i in tmp do
108640: LD_ADDR_VAR 0 2
108644: PUSH
108645: LD_VAR 0 4
108649: PUSH
108650: FOR_IN
108651: IFFALSE 108697
// for j = 1 to 3 do
108653: LD_ADDR_VAR 0 3
108657: PUSH
108658: DOUBLE
108659: LD_INT 1
108661: DEC
108662: ST_TO_ADDR
108663: LD_INT 3
108665: PUSH
108666: FOR_TO
108667: IFFALSE 108693
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108669: LD_VAR 0 2
108673: PPUSH
108674: CALL_OW 274
108678: PPUSH
108679: LD_VAR 0 3
108683: PPUSH
108684: LD_INT 99999
108686: PPUSH
108687: CALL_OW 277
108691: GO 108666
108693: POP
108694: POP
108695: GO 108650
108697: POP
108698: POP
// end ;
108699: LD_VAR 0 1
108703: RET
// export function hHackSetLevel10 ; var i , j ; begin
108704: LD_INT 0
108706: PPUSH
108707: PPUSH
108708: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108709: LD_ADDR_VAR 0 2
108713: PUSH
108714: LD_INT 21
108716: PUSH
108717: LD_INT 1
108719: PUSH
108720: EMPTY
108721: LIST
108722: LIST
108723: PPUSH
108724: CALL_OW 69
108728: PUSH
108729: FOR_IN
108730: IFFALSE 108782
// if IsSelected ( i ) then
108732: LD_VAR 0 2
108736: PPUSH
108737: CALL_OW 306
108741: IFFALSE 108780
// begin for j := 1 to 4 do
108743: LD_ADDR_VAR 0 3
108747: PUSH
108748: DOUBLE
108749: LD_INT 1
108751: DEC
108752: ST_TO_ADDR
108753: LD_INT 4
108755: PUSH
108756: FOR_TO
108757: IFFALSE 108778
// SetSkill ( i , j , 10 ) ;
108759: LD_VAR 0 2
108763: PPUSH
108764: LD_VAR 0 3
108768: PPUSH
108769: LD_INT 10
108771: PPUSH
108772: CALL_OW 237
108776: GO 108756
108778: POP
108779: POP
// end ;
108780: GO 108729
108782: POP
108783: POP
// end ;
108784: LD_VAR 0 1
108788: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108789: LD_INT 0
108791: PPUSH
108792: PPUSH
108793: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108794: LD_ADDR_VAR 0 2
108798: PUSH
108799: LD_INT 22
108801: PUSH
108802: LD_OWVAR 2
108806: PUSH
108807: EMPTY
108808: LIST
108809: LIST
108810: PUSH
108811: LD_INT 21
108813: PUSH
108814: LD_INT 1
108816: PUSH
108817: EMPTY
108818: LIST
108819: LIST
108820: PUSH
108821: EMPTY
108822: LIST
108823: LIST
108824: PPUSH
108825: CALL_OW 69
108829: PUSH
108830: FOR_IN
108831: IFFALSE 108872
// begin for j := 1 to 4 do
108833: LD_ADDR_VAR 0 3
108837: PUSH
108838: DOUBLE
108839: LD_INT 1
108841: DEC
108842: ST_TO_ADDR
108843: LD_INT 4
108845: PUSH
108846: FOR_TO
108847: IFFALSE 108868
// SetSkill ( i , j , 10 ) ;
108849: LD_VAR 0 2
108853: PPUSH
108854: LD_VAR 0 3
108858: PPUSH
108859: LD_INT 10
108861: PPUSH
108862: CALL_OW 237
108866: GO 108846
108868: POP
108869: POP
// end ;
108870: GO 108830
108872: POP
108873: POP
// end ;
108874: LD_VAR 0 1
108878: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108879: LD_INT 0
108881: PPUSH
// uc_side := your_side ;
108882: LD_ADDR_OWVAR 20
108886: PUSH
108887: LD_OWVAR 2
108891: ST_TO_ADDR
// uc_nation := nation ;
108892: LD_ADDR_OWVAR 21
108896: PUSH
108897: LD_VAR 0 1
108901: ST_TO_ADDR
// InitHc ;
108902: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108906: LD_INT 0
108908: PPUSH
108909: LD_VAR 0 2
108913: PPUSH
108914: LD_VAR 0 3
108918: PPUSH
108919: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108923: LD_VAR 0 4
108927: PPUSH
108928: LD_VAR 0 5
108932: PPUSH
108933: CALL_OW 428
108937: PUSH
108938: LD_INT 0
108940: EQUAL
108941: IFFALSE 108965
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108943: CALL_OW 44
108947: PPUSH
108948: LD_VAR 0 4
108952: PPUSH
108953: LD_VAR 0 5
108957: PPUSH
108958: LD_INT 1
108960: PPUSH
108961: CALL_OW 48
// end ;
108965: LD_VAR 0 6
108969: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108970: LD_INT 0
108972: PPUSH
108973: PPUSH
// uc_side := your_side ;
108974: LD_ADDR_OWVAR 20
108978: PUSH
108979: LD_OWVAR 2
108983: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108984: LD_VAR 0 1
108988: PUSH
108989: LD_INT 1
108991: PUSH
108992: LD_INT 2
108994: PUSH
108995: LD_INT 3
108997: PUSH
108998: LD_INT 4
109000: PUSH
109001: LD_INT 5
109003: PUSH
109004: EMPTY
109005: LIST
109006: LIST
109007: LIST
109008: LIST
109009: LIST
109010: IN
109011: IFFALSE 109023
// uc_nation := nation_american else
109013: LD_ADDR_OWVAR 21
109017: PUSH
109018: LD_INT 1
109020: ST_TO_ADDR
109021: GO 109066
// if chassis in [ 11 , 12 , 13 , 14 ] then
109023: LD_VAR 0 1
109027: PUSH
109028: LD_INT 11
109030: PUSH
109031: LD_INT 12
109033: PUSH
109034: LD_INT 13
109036: PUSH
109037: LD_INT 14
109039: PUSH
109040: EMPTY
109041: LIST
109042: LIST
109043: LIST
109044: LIST
109045: IN
109046: IFFALSE 109058
// uc_nation := nation_arabian else
109048: LD_ADDR_OWVAR 21
109052: PUSH
109053: LD_INT 2
109055: ST_TO_ADDR
109056: GO 109066
// uc_nation := nation_russian ;
109058: LD_ADDR_OWVAR 21
109062: PUSH
109063: LD_INT 3
109065: ST_TO_ADDR
// vc_chassis := chassis ;
109066: LD_ADDR_OWVAR 37
109070: PUSH
109071: LD_VAR 0 1
109075: ST_TO_ADDR
// vc_engine := engine ;
109076: LD_ADDR_OWVAR 39
109080: PUSH
109081: LD_VAR 0 2
109085: ST_TO_ADDR
// vc_control := control ;
109086: LD_ADDR_OWVAR 38
109090: PUSH
109091: LD_VAR 0 3
109095: ST_TO_ADDR
// vc_weapon := weapon ;
109096: LD_ADDR_OWVAR 40
109100: PUSH
109101: LD_VAR 0 4
109105: ST_TO_ADDR
// un := CreateVehicle ;
109106: LD_ADDR_VAR 0 8
109110: PUSH
109111: CALL_OW 45
109115: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
109116: LD_VAR 0 8
109120: PPUSH
109121: LD_INT 0
109123: PPUSH
109124: LD_INT 5
109126: PPUSH
109127: CALL_OW 12
109131: PPUSH
109132: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
109136: LD_VAR 0 8
109140: PPUSH
109141: LD_VAR 0 5
109145: PPUSH
109146: LD_VAR 0 6
109150: PPUSH
109151: LD_INT 1
109153: PPUSH
109154: CALL_OW 48
// end ;
109158: LD_VAR 0 7
109162: RET
// export hInvincible ; every 1 do
109163: GO 109165
109165: DISABLE
// hInvincible := [ ] ;
109166: LD_ADDR_EXP 136
109170: PUSH
109171: EMPTY
109172: ST_TO_ADDR
109173: END
// every 10 do var i ;
109174: GO 109176
109176: DISABLE
109177: LD_INT 0
109179: PPUSH
// begin enable ;
109180: ENABLE
// if not hInvincible then
109181: LD_EXP 136
109185: NOT
109186: IFFALSE 109190
// exit ;
109188: GO 109234
// for i in hInvincible do
109190: LD_ADDR_VAR 0 1
109194: PUSH
109195: LD_EXP 136
109199: PUSH
109200: FOR_IN
109201: IFFALSE 109232
// if GetLives ( i ) < 1000 then
109203: LD_VAR 0 1
109207: PPUSH
109208: CALL_OW 256
109212: PUSH
109213: LD_INT 1000
109215: LESS
109216: IFFALSE 109230
// SetLives ( i , 1000 ) ;
109218: LD_VAR 0 1
109222: PPUSH
109223: LD_INT 1000
109225: PPUSH
109226: CALL_OW 234
109230: GO 109200
109232: POP
109233: POP
// end ;
109234: PPOPN 1
109236: END
// export function hHackInvincible ; var i ; begin
109237: LD_INT 0
109239: PPUSH
109240: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
109241: LD_ADDR_VAR 0 2
109245: PUSH
109246: LD_INT 2
109248: PUSH
109249: LD_INT 21
109251: PUSH
109252: LD_INT 1
109254: PUSH
109255: EMPTY
109256: LIST
109257: LIST
109258: PUSH
109259: LD_INT 21
109261: PUSH
109262: LD_INT 2
109264: PUSH
109265: EMPTY
109266: LIST
109267: LIST
109268: PUSH
109269: EMPTY
109270: LIST
109271: LIST
109272: LIST
109273: PPUSH
109274: CALL_OW 69
109278: PUSH
109279: FOR_IN
109280: IFFALSE 109341
// if IsSelected ( i ) then
109282: LD_VAR 0 2
109286: PPUSH
109287: CALL_OW 306
109291: IFFALSE 109339
// begin if i in hInvincible then
109293: LD_VAR 0 2
109297: PUSH
109298: LD_EXP 136
109302: IN
109303: IFFALSE 109323
// hInvincible := hInvincible diff i else
109305: LD_ADDR_EXP 136
109309: PUSH
109310: LD_EXP 136
109314: PUSH
109315: LD_VAR 0 2
109319: DIFF
109320: ST_TO_ADDR
109321: GO 109339
// hInvincible := hInvincible union i ;
109323: LD_ADDR_EXP 136
109327: PUSH
109328: LD_EXP 136
109332: PUSH
109333: LD_VAR 0 2
109337: UNION
109338: ST_TO_ADDR
// end ;
109339: GO 109279
109341: POP
109342: POP
// end ;
109343: LD_VAR 0 1
109347: RET
// export function hHackInvisible ; var i , j ; begin
109348: LD_INT 0
109350: PPUSH
109351: PPUSH
109352: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109353: LD_ADDR_VAR 0 2
109357: PUSH
109358: LD_INT 21
109360: PUSH
109361: LD_INT 1
109363: PUSH
109364: EMPTY
109365: LIST
109366: LIST
109367: PPUSH
109368: CALL_OW 69
109372: PUSH
109373: FOR_IN
109374: IFFALSE 109398
// if IsSelected ( i ) then
109376: LD_VAR 0 2
109380: PPUSH
109381: CALL_OW 306
109385: IFFALSE 109396
// ComForceInvisible ( i ) ;
109387: LD_VAR 0 2
109391: PPUSH
109392: CALL_OW 496
109396: GO 109373
109398: POP
109399: POP
// end ;
109400: LD_VAR 0 1
109404: RET
// export function hHackChangeYourSide ; begin
109405: LD_INT 0
109407: PPUSH
// if your_side = 8 then
109408: LD_OWVAR 2
109412: PUSH
109413: LD_INT 8
109415: EQUAL
109416: IFFALSE 109428
// your_side := 0 else
109418: LD_ADDR_OWVAR 2
109422: PUSH
109423: LD_INT 0
109425: ST_TO_ADDR
109426: GO 109442
// your_side := your_side + 1 ;
109428: LD_ADDR_OWVAR 2
109432: PUSH
109433: LD_OWVAR 2
109437: PUSH
109438: LD_INT 1
109440: PLUS
109441: ST_TO_ADDR
// end ;
109442: LD_VAR 0 1
109446: RET
// export function hHackChangeUnitSide ; var i , j ; begin
109447: LD_INT 0
109449: PPUSH
109450: PPUSH
109451: PPUSH
// for i in all_units do
109452: LD_ADDR_VAR 0 2
109456: PUSH
109457: LD_OWVAR 3
109461: PUSH
109462: FOR_IN
109463: IFFALSE 109541
// if IsSelected ( i ) then
109465: LD_VAR 0 2
109469: PPUSH
109470: CALL_OW 306
109474: IFFALSE 109539
// begin j := GetSide ( i ) ;
109476: LD_ADDR_VAR 0 3
109480: PUSH
109481: LD_VAR 0 2
109485: PPUSH
109486: CALL_OW 255
109490: ST_TO_ADDR
// if j = 8 then
109491: LD_VAR 0 3
109495: PUSH
109496: LD_INT 8
109498: EQUAL
109499: IFFALSE 109511
// j := 0 else
109501: LD_ADDR_VAR 0 3
109505: PUSH
109506: LD_INT 0
109508: ST_TO_ADDR
109509: GO 109525
// j := j + 1 ;
109511: LD_ADDR_VAR 0 3
109515: PUSH
109516: LD_VAR 0 3
109520: PUSH
109521: LD_INT 1
109523: PLUS
109524: ST_TO_ADDR
// SetSide ( i , j ) ;
109525: LD_VAR 0 2
109529: PPUSH
109530: LD_VAR 0 3
109534: PPUSH
109535: CALL_OW 235
// end ;
109539: GO 109462
109541: POP
109542: POP
// end ;
109543: LD_VAR 0 1
109547: RET
// export function hHackFog ; begin
109548: LD_INT 0
109550: PPUSH
// FogOff ( true ) ;
109551: LD_INT 1
109553: PPUSH
109554: CALL_OW 344
// end ;
109558: LD_VAR 0 1
109562: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109563: LD_INT 0
109565: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109566: LD_VAR 0 1
109570: PPUSH
109571: LD_VAR 0 2
109575: PPUSH
109576: LD_VAR 0 3
109580: PPUSH
109581: LD_INT 1
109583: PPUSH
109584: LD_INT 1
109586: PPUSH
109587: CALL_OW 483
// CenterOnXY ( x , y ) ;
109591: LD_VAR 0 2
109595: PPUSH
109596: LD_VAR 0 3
109600: PPUSH
109601: CALL_OW 84
// end ;
109605: LD_VAR 0 4
109609: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109610: LD_INT 0
109612: PPUSH
109613: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109614: LD_VAR 0 1
109618: NOT
109619: PUSH
109620: LD_VAR 0 2
109624: PPUSH
109625: LD_VAR 0 3
109629: PPUSH
109630: CALL_OW 488
109634: NOT
109635: OR
109636: PUSH
109637: LD_VAR 0 1
109641: PPUSH
109642: CALL_OW 266
109646: PUSH
109647: LD_INT 3
109649: NONEQUAL
109650: PUSH
109651: LD_VAR 0 1
109655: PPUSH
109656: CALL_OW 247
109660: PUSH
109661: LD_INT 1
109663: EQUAL
109664: NOT
109665: AND
109666: OR
109667: IFFALSE 109671
// exit ;
109669: GO 109820
// if GetType ( factory ) = unit_human then
109671: LD_VAR 0 1
109675: PPUSH
109676: CALL_OW 247
109680: PUSH
109681: LD_INT 1
109683: EQUAL
109684: IFFALSE 109701
// factory := IsInUnit ( factory ) ;
109686: LD_ADDR_VAR 0 1
109690: PUSH
109691: LD_VAR 0 1
109695: PPUSH
109696: CALL_OW 310
109700: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109701: LD_VAR 0 1
109705: PPUSH
109706: CALL_OW 266
109710: PUSH
109711: LD_INT 3
109713: NONEQUAL
109714: IFFALSE 109718
// exit ;
109716: GO 109820
// if HexInfo ( x , y ) = factory then
109718: LD_VAR 0 2
109722: PPUSH
109723: LD_VAR 0 3
109727: PPUSH
109728: CALL_OW 428
109732: PUSH
109733: LD_VAR 0 1
109737: EQUAL
109738: IFFALSE 109765
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109740: LD_ADDR_EXP 137
109744: PUSH
109745: LD_EXP 137
109749: PPUSH
109750: LD_VAR 0 1
109754: PPUSH
109755: LD_INT 0
109757: PPUSH
109758: CALL_OW 1
109762: ST_TO_ADDR
109763: GO 109816
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109765: LD_ADDR_EXP 137
109769: PUSH
109770: LD_EXP 137
109774: PPUSH
109775: LD_VAR 0 1
109779: PPUSH
109780: LD_VAR 0 1
109784: PPUSH
109785: CALL_OW 255
109789: PUSH
109790: LD_VAR 0 1
109794: PUSH
109795: LD_VAR 0 2
109799: PUSH
109800: LD_VAR 0 3
109804: PUSH
109805: EMPTY
109806: LIST
109807: LIST
109808: LIST
109809: LIST
109810: PPUSH
109811: CALL_OW 1
109815: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109816: CALL 109825 0 0
// end ;
109820: LD_VAR 0 4
109824: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109825: LD_INT 0
109827: PPUSH
109828: PPUSH
109829: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109830: LD_STRING resetFactoryWaypoint();
109832: PPUSH
109833: CALL_OW 559
// if factoryWaypoints then
109837: LD_EXP 137
109841: IFFALSE 109967
// begin list := PrepareArray ( factoryWaypoints ) ;
109843: LD_ADDR_VAR 0 3
109847: PUSH
109848: LD_EXP 137
109852: PPUSH
109853: CALL 52194 0 1
109857: ST_TO_ADDR
// for i := 1 to list do
109858: LD_ADDR_VAR 0 2
109862: PUSH
109863: DOUBLE
109864: LD_INT 1
109866: DEC
109867: ST_TO_ADDR
109868: LD_VAR 0 3
109872: PUSH
109873: FOR_TO
109874: IFFALSE 109965
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109876: LD_STRING setFactoryWaypointXY(
109878: PUSH
109879: LD_VAR 0 3
109883: PUSH
109884: LD_VAR 0 2
109888: ARRAY
109889: PUSH
109890: LD_INT 1
109892: ARRAY
109893: STR
109894: PUSH
109895: LD_STRING ,
109897: STR
109898: PUSH
109899: LD_VAR 0 3
109903: PUSH
109904: LD_VAR 0 2
109908: ARRAY
109909: PUSH
109910: LD_INT 2
109912: ARRAY
109913: STR
109914: PUSH
109915: LD_STRING ,
109917: STR
109918: PUSH
109919: LD_VAR 0 3
109923: PUSH
109924: LD_VAR 0 2
109928: ARRAY
109929: PUSH
109930: LD_INT 3
109932: ARRAY
109933: STR
109934: PUSH
109935: LD_STRING ,
109937: STR
109938: PUSH
109939: LD_VAR 0 3
109943: PUSH
109944: LD_VAR 0 2
109948: ARRAY
109949: PUSH
109950: LD_INT 4
109952: ARRAY
109953: STR
109954: PUSH
109955: LD_STRING )
109957: STR
109958: PPUSH
109959: CALL_OW 559
109963: GO 109873
109965: POP
109966: POP
// end ; end ;
109967: LD_VAR 0 1
109971: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109972: LD_INT 0
109974: PPUSH
// if HexInfo ( x , y ) = warehouse then
109975: LD_VAR 0 2
109979: PPUSH
109980: LD_VAR 0 3
109984: PPUSH
109985: CALL_OW 428
109989: PUSH
109990: LD_VAR 0 1
109994: EQUAL
109995: IFFALSE 110022
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109997: LD_ADDR_EXP 138
110001: PUSH
110002: LD_EXP 138
110006: PPUSH
110007: LD_VAR 0 1
110011: PPUSH
110012: LD_INT 0
110014: PPUSH
110015: CALL_OW 1
110019: ST_TO_ADDR
110020: GO 110073
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
110022: LD_ADDR_EXP 138
110026: PUSH
110027: LD_EXP 138
110031: PPUSH
110032: LD_VAR 0 1
110036: PPUSH
110037: LD_VAR 0 1
110041: PPUSH
110042: CALL_OW 255
110046: PUSH
110047: LD_VAR 0 1
110051: PUSH
110052: LD_VAR 0 2
110056: PUSH
110057: LD_VAR 0 3
110061: PUSH
110062: EMPTY
110063: LIST
110064: LIST
110065: LIST
110066: LIST
110067: PPUSH
110068: CALL_OW 1
110072: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
110073: CALL 110082 0 0
// end ;
110077: LD_VAR 0 4
110081: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
110082: LD_INT 0
110084: PPUSH
110085: PPUSH
110086: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
110087: LD_STRING resetWarehouseGatheringPoints();
110089: PPUSH
110090: CALL_OW 559
// if warehouseGatheringPoints then
110094: LD_EXP 138
110098: IFFALSE 110224
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
110100: LD_ADDR_VAR 0 3
110104: PUSH
110105: LD_EXP 138
110109: PPUSH
110110: CALL 52194 0 1
110114: ST_TO_ADDR
// for i := 1 to list do
110115: LD_ADDR_VAR 0 2
110119: PUSH
110120: DOUBLE
110121: LD_INT 1
110123: DEC
110124: ST_TO_ADDR
110125: LD_VAR 0 3
110129: PUSH
110130: FOR_TO
110131: IFFALSE 110222
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
110133: LD_STRING setWarehouseGatheringPointXY(
110135: PUSH
110136: LD_VAR 0 3
110140: PUSH
110141: LD_VAR 0 2
110145: ARRAY
110146: PUSH
110147: LD_INT 1
110149: ARRAY
110150: STR
110151: PUSH
110152: LD_STRING ,
110154: STR
110155: PUSH
110156: LD_VAR 0 3
110160: PUSH
110161: LD_VAR 0 2
110165: ARRAY
110166: PUSH
110167: LD_INT 2
110169: ARRAY
110170: STR
110171: PUSH
110172: LD_STRING ,
110174: STR
110175: PUSH
110176: LD_VAR 0 3
110180: PUSH
110181: LD_VAR 0 2
110185: ARRAY
110186: PUSH
110187: LD_INT 3
110189: ARRAY
110190: STR
110191: PUSH
110192: LD_STRING ,
110194: STR
110195: PUSH
110196: LD_VAR 0 3
110200: PUSH
110201: LD_VAR 0 2
110205: ARRAY
110206: PUSH
110207: LD_INT 4
110209: ARRAY
110210: STR
110211: PUSH
110212: LD_STRING )
110214: STR
110215: PPUSH
110216: CALL_OW 559
110220: GO 110130
110222: POP
110223: POP
// end ; end ;
110224: LD_VAR 0 1
110228: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
110229: LD_EXP 138
110233: IFFALSE 110918
110235: GO 110237
110237: DISABLE
110238: LD_INT 0
110240: PPUSH
110241: PPUSH
110242: PPUSH
110243: PPUSH
110244: PPUSH
110245: PPUSH
110246: PPUSH
110247: PPUSH
110248: PPUSH
// begin enable ;
110249: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
110250: LD_ADDR_VAR 0 3
110254: PUSH
110255: LD_EXP 138
110259: PPUSH
110260: CALL 52194 0 1
110264: ST_TO_ADDR
// if not list then
110265: LD_VAR 0 3
110269: NOT
110270: IFFALSE 110274
// exit ;
110272: GO 110918
// for i := 1 to list do
110274: LD_ADDR_VAR 0 1
110278: PUSH
110279: DOUBLE
110280: LD_INT 1
110282: DEC
110283: ST_TO_ADDR
110284: LD_VAR 0 3
110288: PUSH
110289: FOR_TO
110290: IFFALSE 110916
// begin depot := list [ i ] [ 2 ] ;
110292: LD_ADDR_VAR 0 8
110296: PUSH
110297: LD_VAR 0 3
110301: PUSH
110302: LD_VAR 0 1
110306: ARRAY
110307: PUSH
110308: LD_INT 2
110310: ARRAY
110311: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
110312: LD_ADDR_VAR 0 5
110316: PUSH
110317: LD_VAR 0 3
110321: PUSH
110322: LD_VAR 0 1
110326: ARRAY
110327: PUSH
110328: LD_INT 1
110330: ARRAY
110331: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
110332: LD_VAR 0 8
110336: PPUSH
110337: CALL_OW 301
110341: PUSH
110342: LD_VAR 0 5
110346: PUSH
110347: LD_VAR 0 8
110351: PPUSH
110352: CALL_OW 255
110356: NONEQUAL
110357: OR
110358: IFFALSE 110387
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
110360: LD_ADDR_EXP 138
110364: PUSH
110365: LD_EXP 138
110369: PPUSH
110370: LD_VAR 0 8
110374: PPUSH
110375: LD_INT 0
110377: PPUSH
110378: CALL_OW 1
110382: ST_TO_ADDR
// exit ;
110383: POP
110384: POP
110385: GO 110918
// end ; x := list [ i ] [ 3 ] ;
110387: LD_ADDR_VAR 0 6
110391: PUSH
110392: LD_VAR 0 3
110396: PUSH
110397: LD_VAR 0 1
110401: ARRAY
110402: PUSH
110403: LD_INT 3
110405: ARRAY
110406: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
110407: LD_ADDR_VAR 0 7
110411: PUSH
110412: LD_VAR 0 3
110416: PUSH
110417: LD_VAR 0 1
110421: ARRAY
110422: PUSH
110423: LD_INT 4
110425: ARRAY
110426: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
110427: LD_ADDR_VAR 0 9
110431: PUSH
110432: LD_VAR 0 6
110436: PPUSH
110437: LD_VAR 0 7
110441: PPUSH
110442: LD_INT 16
110444: PPUSH
110445: CALL 50782 0 3
110449: ST_TO_ADDR
// if not cratesNearbyPoint then
110450: LD_VAR 0 9
110454: NOT
110455: IFFALSE 110461
// exit ;
110457: POP
110458: POP
110459: GO 110918
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
110461: LD_ADDR_VAR 0 4
110465: PUSH
110466: LD_INT 22
110468: PUSH
110469: LD_VAR 0 5
110473: PUSH
110474: EMPTY
110475: LIST
110476: LIST
110477: PUSH
110478: LD_INT 3
110480: PUSH
110481: LD_INT 60
110483: PUSH
110484: EMPTY
110485: LIST
110486: PUSH
110487: EMPTY
110488: LIST
110489: LIST
110490: PUSH
110491: LD_INT 91
110493: PUSH
110494: LD_VAR 0 8
110498: PUSH
110499: LD_INT 6
110501: PUSH
110502: EMPTY
110503: LIST
110504: LIST
110505: LIST
110506: PUSH
110507: LD_INT 2
110509: PUSH
110510: LD_INT 25
110512: PUSH
110513: LD_INT 2
110515: PUSH
110516: EMPTY
110517: LIST
110518: LIST
110519: PUSH
110520: LD_INT 25
110522: PUSH
110523: LD_INT 16
110525: PUSH
110526: EMPTY
110527: LIST
110528: LIST
110529: PUSH
110530: EMPTY
110531: LIST
110532: LIST
110533: LIST
110534: PUSH
110535: EMPTY
110536: LIST
110537: LIST
110538: LIST
110539: LIST
110540: PPUSH
110541: CALL_OW 69
110545: PUSH
110546: LD_VAR 0 8
110550: PPUSH
110551: CALL_OW 313
110555: PPUSH
110556: LD_INT 3
110558: PUSH
110559: LD_INT 60
110561: PUSH
110562: EMPTY
110563: LIST
110564: PUSH
110565: EMPTY
110566: LIST
110567: LIST
110568: PUSH
110569: LD_INT 2
110571: PUSH
110572: LD_INT 25
110574: PUSH
110575: LD_INT 2
110577: PUSH
110578: EMPTY
110579: LIST
110580: LIST
110581: PUSH
110582: LD_INT 25
110584: PUSH
110585: LD_INT 16
110587: PUSH
110588: EMPTY
110589: LIST
110590: LIST
110591: PUSH
110592: EMPTY
110593: LIST
110594: LIST
110595: LIST
110596: PUSH
110597: EMPTY
110598: LIST
110599: LIST
110600: PPUSH
110601: CALL_OW 72
110605: UNION
110606: ST_TO_ADDR
// if tmp then
110607: LD_VAR 0 4
110611: IFFALSE 110691
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110613: LD_ADDR_VAR 0 4
110617: PUSH
110618: LD_VAR 0 4
110622: PPUSH
110623: LD_INT 3
110625: PPUSH
110626: CALL 48751 0 2
110630: ST_TO_ADDR
// for j in tmp do
110631: LD_ADDR_VAR 0 2
110635: PUSH
110636: LD_VAR 0 4
110640: PUSH
110641: FOR_IN
110642: IFFALSE 110685
// begin if IsInUnit ( j ) then
110644: LD_VAR 0 2
110648: PPUSH
110649: CALL_OW 310
110653: IFFALSE 110664
// ComExit ( j ) ;
110655: LD_VAR 0 2
110659: PPUSH
110660: CALL 48834 0 1
// AddComCollect ( j , x , y ) ;
110664: LD_VAR 0 2
110668: PPUSH
110669: LD_VAR 0 6
110673: PPUSH
110674: LD_VAR 0 7
110678: PPUSH
110679: CALL_OW 177
// end ;
110683: GO 110641
110685: POP
110686: POP
// exit ;
110687: POP
110688: POP
110689: GO 110918
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110691: LD_ADDR_VAR 0 4
110695: PUSH
110696: LD_INT 22
110698: PUSH
110699: LD_VAR 0 5
110703: PUSH
110704: EMPTY
110705: LIST
110706: LIST
110707: PUSH
110708: LD_INT 91
110710: PUSH
110711: LD_VAR 0 8
110715: PUSH
110716: LD_INT 8
110718: PUSH
110719: EMPTY
110720: LIST
110721: LIST
110722: LIST
110723: PUSH
110724: LD_INT 2
110726: PUSH
110727: LD_INT 34
110729: PUSH
110730: LD_INT 12
110732: PUSH
110733: EMPTY
110734: LIST
110735: LIST
110736: PUSH
110737: LD_INT 34
110739: PUSH
110740: LD_INT 51
110742: PUSH
110743: EMPTY
110744: LIST
110745: LIST
110746: PUSH
110747: LD_INT 34
110749: PUSH
110750: LD_INT 32
110752: PUSH
110753: EMPTY
110754: LIST
110755: LIST
110756: PUSH
110757: LD_INT 34
110759: PUSH
110760: LD_INT 89
110762: PUSH
110763: EMPTY
110764: LIST
110765: LIST
110766: PUSH
110767: EMPTY
110768: LIST
110769: LIST
110770: LIST
110771: LIST
110772: LIST
110773: PUSH
110774: EMPTY
110775: LIST
110776: LIST
110777: LIST
110778: PPUSH
110779: CALL_OW 69
110783: ST_TO_ADDR
// if tmp then
110784: LD_VAR 0 4
110788: IFFALSE 110914
// begin for j in tmp do
110790: LD_ADDR_VAR 0 2
110794: PUSH
110795: LD_VAR 0 4
110799: PUSH
110800: FOR_IN
110801: IFFALSE 110912
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110803: LD_VAR 0 2
110807: PPUSH
110808: CALL_OW 262
110812: PUSH
110813: LD_INT 3
110815: EQUAL
110816: PUSH
110817: LD_VAR 0 2
110821: PPUSH
110822: CALL_OW 261
110826: PUSH
110827: LD_INT 20
110829: GREATER
110830: OR
110831: PUSH
110832: LD_VAR 0 2
110836: PPUSH
110837: CALL_OW 314
110841: NOT
110842: AND
110843: PUSH
110844: LD_VAR 0 2
110848: PPUSH
110849: CALL_OW 263
110853: PUSH
110854: LD_INT 1
110856: NONEQUAL
110857: PUSH
110858: LD_VAR 0 2
110862: PPUSH
110863: CALL_OW 311
110867: OR
110868: AND
110869: IFFALSE 110910
// begin ComCollect ( j , x , y ) ;
110871: LD_VAR 0 2
110875: PPUSH
110876: LD_VAR 0 6
110880: PPUSH
110881: LD_VAR 0 7
110885: PPUSH
110886: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110890: LD_VAR 0 2
110894: PPUSH
110895: LD_VAR 0 8
110899: PPUSH
110900: CALL_OW 172
// exit ;
110904: POP
110905: POP
110906: POP
110907: POP
110908: GO 110918
// end ;
110910: GO 110800
110912: POP
110913: POP
// end ; end ;
110914: GO 110289
110916: POP
110917: POP
// end ; end_of_file
110918: PPOPN 9
110920: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110921: LD_VAR 0 1
110925: PPUSH
110926: LD_VAR 0 2
110930: PPUSH
110931: LD_VAR 0 3
110935: PPUSH
110936: LD_VAR 0 4
110940: PPUSH
110941: LD_VAR 0 5
110945: PPUSH
110946: LD_VAR 0 6
110950: PPUSH
110951: CALL 95274 0 6
// end ;
110955: PPOPN 6
110957: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110958: LD_INT 0
110960: PPUSH
// begin if not units then
110961: LD_VAR 0 1
110965: NOT
110966: IFFALSE 110970
// exit ;
110968: GO 110970
// end ;
110970: PPOPN 7
110972: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110973: CALL 95178 0 0
// end ;
110977: PPOPN 1
110979: END
