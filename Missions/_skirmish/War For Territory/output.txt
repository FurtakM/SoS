// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 82869 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 45110 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 45110 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 45110 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 45110 0 9
// PrepareGensher ;
 189: CALL 3160 0 0
// PreparePopov ;
 193: CALL 6371 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 9059 0 0
// MC_Start ( ) ;
 205: CALL 54408 0 0
// Action ;
 209: CALL 9466 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 4294 0 0
// InitMC_Powell ( ) ;
 284: CALL 1515 0 0
// InitMC_Popov ( ) ;
 288: CALL 7529 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
 599: PPUSH
// powell_side := 4 ;
 600: LD_ADDR_EXP 11
 604: PUSH
 605: LD_INT 4
 607: ST_TO_ADDR
// uc_side := powell_side ;
 608: LD_ADDR_OWVAR 20
 612: PUSH
 613: LD_EXP 11
 617: ST_TO_ADDR
// uc_nation := 1 ;
 618: LD_ADDR_OWVAR 21
 622: PUSH
 623: LD_INT 1
 625: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 626: LD_ADDR_EXP 10
 630: PUSH
 631: LD_STRING Powell
 633: PPUSH
 634: CALL_OW 25
 638: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 639: LD_EXP 10
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 7
 649: PPUSH
 650: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 654: LD_EXP 10
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 5
 664: PPUSH
 665: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 669: LD_EXP 10
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: LD_INT 6
 679: PPUSH
 680: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 684: LD_EXP 10
 688: PPUSH
 689: LD_INT 4
 691: PPUSH
 692: LD_INT 4
 694: PPUSH
 695: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 699: LD_EXP 10
 703: PPUSH
 704: LD_INT 4
 706: PPUSH
 707: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 711: LD_ADDR_VAR 0 3
 715: PUSH
 716: LD_INT 5
 718: PUSH
 719: LD_INT 178
 721: PUSH
 722: LD_INT 117
 724: PUSH
 725: LD_INT 2
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 29
 736: PUSH
 737: LD_INT 167
 739: PUSH
 740: LD_INT 102
 742: PUSH
 743: LD_INT 0
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 6
 754: PUSH
 755: LD_INT 200
 757: PUSH
 758: LD_INT 111
 760: PUSH
 761: LD_INT 4
 763: PUSH
 764: LD_INT 10
 766: PUSH
 767: LD_INT 11
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 201
 783: PUSH
 784: LD_INT 140
 786: PUSH
 787: LD_INT 4
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 27
 798: PUSH
 799: LD_INT 206
 801: PUSH
 802: LD_INT 124
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 27
 816: PUSH
 817: LD_INT 209
 819: PUSH
 820: LD_INT 128
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_INT 27
 834: PUSH
 835: LD_INT 211
 837: PUSH
 838: LD_INT 132
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 173
 855: PUSH
 856: LD_INT 83
 858: PUSH
 859: LD_INT 3
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 6
 870: PUSH
 871: LD_INT 186
 873: PUSH
 874: LD_INT 103
 876: PUSH
 877: LD_INT 2
 879: PUSH
 880: LD_INT 12
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: PUSH
 894: LD_INT 33
 896: PUSH
 897: LD_INT 173
 899: PUSH
 900: LD_INT 99
 902: PUSH
 903: LD_INT 2
 905: PUSH
 906: LD_INT 6
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 32
 918: PUSH
 919: LD_INT 174
 921: PUSH
 922: LD_INT 102
 924: PUSH
 925: LD_INT 2
 927: PUSH
 928: LD_INT 6
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PUSH
 938: LD_INT 32
 940: PUSH
 941: LD_INT 178
 943: PUSH
 944: LD_INT 100
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 6
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 33
 962: PUSH
 963: LD_INT 174
 965: PUSH
 966: LD_INT 108
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: LD_INT 7
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 33
 984: PUSH
 985: LD_INT 182
 987: PUSH
 988: LD_INT 122
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 7
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 36
1006: PUSH
1007: LD_INT 194
1009: PUSH
1010: LD_INT 124
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: LD_INT 184
1027: PUSH
1028: LD_INT 141
1030: PUSH
1031: LD_INT 1
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: PUSH
1044: LD_INT 33
1046: PUSH
1047: LD_INT 183
1049: PUSH
1050: LD_INT 131
1052: PUSH
1053: LD_INT 2
1055: PUSH
1056: LD_INT 11
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_INT 33
1068: PUSH
1069: LD_INT 194
1071: PUSH
1072: LD_INT 146
1074: PUSH
1075: LD_INT 4
1077: PUSH
1078: LD_INT 7
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: LD_INT 33
1090: PUSH
1091: LD_INT 190
1093: PUSH
1094: LD_INT 142
1096: PUSH
1097: LD_INT 4
1099: PUSH
1100: LD_INT 7
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 28
1112: PUSH
1113: LD_INT 204
1115: PUSH
1116: LD_INT 133
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 201
1133: PUSH
1134: LD_INT 133
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 28
1148: PUSH
1149: LD_INT 199
1151: PUSH
1152: LD_INT 119
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: ST_TO_ADDR
// for i in list do
1188: LD_ADDR_VAR 0 2
1192: PUSH
1193: LD_VAR 0 3
1197: PUSH
1198: FOR_IN
1199: IFFALSE 1377
// begin uc_side := 4 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 4
1208: ST_TO_ADDR
// uc_nation := 1 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// bc_kind1 := - 1 ;
1231: LD_ADDR_OWVAR 44
1235: PUSH
1236: LD_INT 1
1238: NEG
1239: ST_TO_ADDR
// bc_kind2 := - 1 ;
1240: LD_ADDR_OWVAR 45
1244: PUSH
1245: LD_INT 1
1247: NEG
1248: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1249: LD_VAR 0 2
1253: PUSH
1254: LD_INT 1
1256: ARRAY
1257: PUSH
1258: LD_INT 6
1260: EQUAL
1261: IFFALSE 1299
// begin bc_type := b_lab_full ;
1263: LD_ADDR_OWVAR 42
1267: PUSH
1268: LD_INT 8
1270: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1271: LD_ADDR_OWVAR 44
1275: PUSH
1276: LD_VAR 0 2
1280: PUSH
1281: LD_INT 5
1283: ARRAY
1284: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1285: LD_ADDR_OWVAR 45
1289: PUSH
1290: LD_VAR 0 2
1294: PUSH
1295: LD_INT 6
1297: ARRAY
1298: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1299: LD_ADDR_VAR 0 4
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 2
1311: ARRAY
1312: PPUSH
1313: LD_VAR 0 2
1317: PUSH
1318: LD_INT 3
1320: ARRAY
1321: PPUSH
1322: LD_VAR 0 2
1326: PUSH
1327: LD_INT 4
1329: ARRAY
1330: PPUSH
1331: CALL_OW 47
1335: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1336: LD_VAR 0 2
1340: PUSH
1341: LD_INT 1
1343: ARRAY
1344: PUSH
1345: LD_INT 33
1347: PUSH
1348: LD_INT 32
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: IN
1355: IFFALSE 1375
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1357: LD_VAR 0 4
1361: PPUSH
1362: LD_VAR 0 2
1366: PUSH
1367: LD_INT 5
1369: ARRAY
1370: PPUSH
1371: CALL_OW 431
// end ;
1375: GO 1198
1377: POP
1378: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1379: LD_ADDR_VAR 0 5
1383: PUSH
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_STRING 
1392: PPUSH
1393: LD_INT 8
1395: PUSH
1396: LD_INT 7
1398: PUSH
1399: LD_INT 6
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: PUSH
1407: LD_OWVAR 67
1411: ARRAY
1412: PPUSH
1413: LD_INT 5500
1415: PUSH
1416: LD_INT 500
1418: PUSH
1419: LD_INT 0
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: LIST
1426: PPUSH
1427: LD_INT 6
1429: PUSH
1430: LD_INT 6
1432: PUSH
1433: LD_INT 6
1435: PUSH
1436: LD_INT 6
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 19490 0 6
1449: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1450: LD_ADDR_EXP 23
1454: PUSH
1455: LD_EXP 23
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: LD_VAR 0 5
1467: PUSH
1468: LD_INT 22
1470: PUSH
1471: LD_INT 4
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: PUSH
1478: LD_INT 21
1480: PUSH
1481: LD_INT 3
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PPUSH
1492: CALL_OW 69
1496: UNION
1497: PPUSH
1498: CALL_OW 1
1502: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1503: LD_ADDR_EXP 12
1507: PUSH
1508: EMPTY
1509: ST_TO_ADDR
// end ;
1510: LD_VAR 0 1
1514: RET
// export function InitMC_Powell ( ) ; begin
1515: LD_INT 0
1517: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1518: LD_INT 1
1520: PPUSH
1521: LD_INT 1
1523: PPUSH
1524: CALL 77736 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1528: LD_INT 1
1530: PPUSH
1531: LD_INT 6
1533: PPUSH
1534: CALL 77680 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1538: LD_INT 1
1540: PPUSH
1541: LD_INT 167
1543: PUSH
1544: LD_INT 102
1546: PUSH
1547: LD_INT 0
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 173
1557: PUSH
1558: LD_INT 83
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 171
1571: PUSH
1572: LD_INT 141
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 178
1585: PUSH
1586: LD_INT 148
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: PPUSH
1603: CALL 76739 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1607: LD_INT 1
1609: PPUSH
1610: LD_INT 11
1612: PUSH
1613: LD_INT 6
1615: PUSH
1616: LD_INT 7
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PPUSH
1624: CALL 77568 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 5
1633: PPUSH
1634: CALL 77250 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 4
1643: PPUSH
1644: CALL 76981 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1648: LD_INT 1
1650: PPUSH
1651: LD_INT 4
1653: PPUSH
1654: CALL 76600 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 3
1663: PUSH
1664: LD_INT 1
1666: PUSH
1667: LD_INT 2
1669: PUSH
1670: LD_INT 5
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: PUSH
1679: LD_INT 4
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 6
1690: PUSH
1691: EMPTY
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_INT 4
1699: PUSH
1700: LD_INT 1
1702: PUSH
1703: LD_INT 2
1705: PUSH
1706: LD_INT 7
1708: PUSH
1709: EMPTY
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 6
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: PUSH
1733: EMPTY
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PPUSH
1739: CALL 76415 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1743: LD_INT 1
1745: PPUSH
1746: LD_INT 201
1748: PPUSH
1749: LD_INT 140
1751: PPUSH
1752: LD_INT 4
1754: PPUSH
1755: LD_INT 19
1757: PUSH
1758: LD_INT 16
1760: PUSH
1761: LD_INT 17
1763: PUSH
1764: LD_INT 18
1766: PUSH
1767: LD_INT 22
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 77362 0 5
// end ;
1781: LD_VAR 0 1
1785: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1786: LD_INT 4
1788: PPUSH
1789: CALL_OW 302
1793: IFFALSE 2453
1795: GO 1797
1797: DISABLE
1798: LD_INT 0
1800: PPUSH
1801: PPUSH
1802: PPUSH
1803: PPUSH
1804: PPUSH
// begin enable ;
1805: ENABLE
// base := 1 ;
1806: LD_ADDR_VAR 0 2
1810: PUSH
1811: LD_INT 1
1813: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: LD_INT 4
1821: PUSH
1822: LD_INT 1
1824: PUSH
1825: LD_INT 2
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 4
1839: PUSH
1840: LD_INT 1
1842: PUSH
1843: LD_INT 2
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: LD_INT 1
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: LD_INT 7
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PUSH
1873: LD_INT 3
1875: PUSH
1876: LD_INT 1
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 7
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_OWVAR 1
1911: PUSH
1912: LD_INT 21000
1914: DIV
1915: PLUS
1916: ST_TO_ADDR
// if amount > 8 then
1917: LD_VAR 0 5
1921: PUSH
1922: LD_INT 8
1924: GREATER
1925: IFFALSE 1935
// amount := 8 ;
1927: LD_ADDR_VAR 0 5
1931: PUSH
1932: LD_INT 8
1934: ST_TO_ADDR
// for i = 1 to amount do
1935: LD_ADDR_VAR 0 1
1939: PUSH
1940: DOUBLE
1941: LD_INT 1
1943: DEC
1944: ST_TO_ADDR
1945: LD_VAR 0 5
1949: PUSH
1950: FOR_TO
1951: IFFALSE 2035
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1953: LD_ADDR_VAR 0 3
1957: PUSH
1958: LD_VAR 0 3
1962: PPUSH
1963: LD_VAR 0 3
1967: PUSH
1968: LD_INT 1
1970: PLUS
1971: PPUSH
1972: LD_INT 3
1974: PUSH
1975: LD_INT 4
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 2
1987: PPUSH
1988: CALL_OW 12
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 2
1999: PUSH
2000: LD_INT 7
2002: PUSH
2003: LD_INT 5
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
2033: GO 1950
2035: POP
2036: POP
// MC_InsertProduceList ( base , tmp ) ;
2037: LD_VAR 0 2
2041: PPUSH
2042: LD_VAR 0 3
2046: PPUSH
2047: CALL 76463 0 2
// repeat wait ( 0 0$1 ) ;
2051: LD_INT 35
2053: PPUSH
2054: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_INT 1
2065: PPUSH
2066: CALL 77881 0 2
2070: PUSH
2071: LD_VAR 0 5
2075: GREATEREQUAL
2076: IFFALSE 2051
// wait ( 0 0$30 ) ;
2078: LD_INT 1050
2080: PPUSH
2081: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2085: LD_ADDR_VAR 0 4
2089: PUSH
2090: LD_EXP 42
2094: PUSH
2095: LD_VAR 0 2
2099: ARRAY
2100: PUSH
2101: LD_EXP 42
2105: PUSH
2106: LD_VAR 0 2
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PUSH
2115: LD_INT 34
2117: PUSH
2118: LD_INT 12
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 34
2127: PUSH
2128: LD_INT 13
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 34
2137: PUSH
2138: LD_INT 14
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: PPUSH
2151: CALL_OW 72
2155: DIFF
2156: ST_TO_ADDR
// if not attackers then
2157: LD_VAR 0 4
2161: NOT
2162: IFFALSE 2166
// exit ;
2164: GO 2453
// DialogPowellsAttack ;
2166: CALL 9597 0 0
// powellAttackGroup := attackers ;
2170: LD_ADDR_EXP 12
2174: PUSH
2175: LD_VAR 0 4
2179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2180: LD_ADDR_EXP 42
2184: PUSH
2185: LD_EXP 42
2189: PPUSH
2190: LD_VAR 0 2
2194: PPUSH
2195: LD_EXP 42
2199: PUSH
2200: LD_VAR 0 2
2204: ARRAY
2205: PUSH
2206: LD_VAR 0 4
2210: DIFF
2211: PPUSH
2212: CALL_OW 1
2216: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2217: LD_EXP 9
2221: PUSH
2222: LD_INT 16
2224: PPUSH
2225: LD_INT 81
2227: PUSH
2228: LD_INT 4
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PPUSH
2235: CALL_OW 70
2239: AND
2240: IFFALSE 2259
// ComAgressiveMove ( attackers , 135 , 21 ) else
2242: LD_VAR 0 4
2246: PPUSH
2247: LD_INT 135
2249: PPUSH
2250: LD_INT 21
2252: PPUSH
2253: CALL_OW 114
2257: GO 2274
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2259: LD_VAR 0 4
2263: PPUSH
2264: LD_INT 146
2266: PPUSH
2267: LD_INT 103
2269: PPUSH
2270: CALL_OW 114
// wait ( 0 0$5 ) ;
2274: LD_INT 175
2276: PPUSH
2277: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2281: LD_INT 35
2283: PPUSH
2284: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2288: LD_VAR 0 4
2292: PPUSH
2293: LD_INT 60
2295: PUSH
2296: EMPTY
2297: LIST
2298: PPUSH
2299: CALL_OW 72
2303: NOT
2304: IFFALSE 2281
// if FilterAllUnits ( [ f_side , 3 ] ) then
2306: LD_INT 22
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: IFFALSE 2339
// ComAgressiveMove ( attackers , 102 , 116 ) else
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 102
2329: PPUSH
2330: LD_INT 116
2332: PPUSH
2333: CALL_OW 114
2337: GO 2354
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 66
2346: PPUSH
2347: LD_INT 41
2349: PPUSH
2350: CALL_OW 114
// wait ( 0 0$10 ) ;
2354: LD_INT 350
2356: PPUSH
2357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2361: LD_INT 35
2363: PPUSH
2364: CALL_OW 67
// for i in attackers do
2368: LD_ADDR_VAR 0 1
2372: PUSH
2373: LD_VAR 0 4
2377: PUSH
2378: FOR_IN
2379: IFFALSE 2429
// if not HasTask ( i ) then
2381: LD_VAR 0 1
2385: PPUSH
2386: CALL_OW 314
2390: NOT
2391: IFFALSE 2427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 81
2400: PUSH
2401: LD_INT 4
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PPUSH
2408: CALL_OW 69
2412: PPUSH
2413: LD_VAR 0 1
2417: PPUSH
2418: CALL_OW 74
2422: PPUSH
2423: CALL_OW 115
2427: GO 2378
2429: POP
2430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2431: LD_VAR 0 4
2435: PPUSH
2436: LD_INT 50
2438: PUSH
2439: EMPTY
2440: LIST
2441: PPUSH
2442: CALL_OW 72
2446: NOT
2447: IFFALSE 2361
// DialogPowellsAttackFailed ;
2449: CALL 9862 0 0
// end ;
2453: PPOPN 5
2455: END
// every 0 0$2 do var vehicles , mechs , i ;
2456: GO 2458
2458: DISABLE
2459: LD_INT 0
2461: PPUSH
2462: PPUSH
2463: PPUSH
// begin enable ;
2464: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2465: LD_ADDR_VAR 0 1
2469: PUSH
2470: LD_INT 22
2472: PUSH
2473: LD_INT 1
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 21
2482: PUSH
2483: LD_INT 2
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 3
2492: PUSH
2493: LD_INT 24
2495: PUSH
2496: LD_INT 1000
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: PUSH
2507: LD_INT 92
2509: PUSH
2510: LD_INT 191
2512: PUSH
2513: LD_INT 140
2515: PUSH
2516: LD_INT 10
2518: PUSH
2519: EMPTY
2520: LIST
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 69
2535: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_INT 22
2543: PUSH
2544: LD_INT 4
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: PUSH
2551: LD_INT 25
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PPUSH
2565: CALL_OW 69
2569: ST_TO_ADDR
// if not mechs then
2570: LD_VAR 0 2
2574: NOT
2575: IFFALSE 2579
// exit ;
2577: GO 2753
// if mc_remote_driver [ 1 ] then
2579: LD_EXP 63
2583: PUSH
2584: LD_INT 1
2586: ARRAY
2587: IFFALSE 2609
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_VAR 0 2
2598: PUSH
2599: LD_EXP 63
2603: PUSH
2604: LD_INT 1
2606: ARRAY
2607: DIFF
2608: ST_TO_ADDR
// if not mechs then
2609: LD_VAR 0 2
2613: NOT
2614: IFFALSE 2618
// exit ;
2616: GO 2753
// if vehicles then
2618: LD_VAR 0 1
2622: IFFALSE 2710
// begin for i in mechs do
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: LD_VAR 0 2
2633: PUSH
2634: FOR_IN
2635: IFFALSE 2706
// begin if GetTag ( i ) <> 120 then
2637: LD_VAR 0 3
2641: PPUSH
2642: CALL_OW 110
2646: PUSH
2647: LD_INT 120
2649: NONEQUAL
2650: IFFALSE 2664
// SetTag ( i , 120 ) ;
2652: LD_VAR 0 3
2656: PPUSH
2657: LD_INT 120
2659: PPUSH
2660: CALL_OW 109
// if IsInUnit ( i ) then
2664: LD_VAR 0 3
2668: PPUSH
2669: CALL_OW 310
2673: IFFALSE 2686
// ComExitBuilding ( i ) else
2675: LD_VAR 0 3
2679: PPUSH
2680: CALL_OW 122
2684: GO 2704
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2686: LD_VAR 0 3
2690: PPUSH
2691: LD_VAR 0 1
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 129
// end ;
2704: GO 2634
2706: POP
2707: POP
// end else
2708: GO 2753
// if FilterByTag ( mechs , 120 ) then
2710: LD_VAR 0 2
2714: PPUSH
2715: LD_INT 120
2717: PPUSH
2718: CALL 46002 0 2
2722: IFFALSE 2753
// begin for i in mechs do
2724: LD_ADDR_VAR 0 3
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: FOR_IN
2735: IFFALSE 2751
// begin SetTag ( i , 0 ) ;
2737: LD_VAR 0 3
2741: PPUSH
2742: LD_INT 0
2744: PPUSH
2745: CALL_OW 109
// end ;
2749: GO 2734
2751: POP
2752: POP
// end ; end ;
2753: PPOPN 3
2755: END
// every 0 0$2 do var people , sci , i ;
2756: GO 2758
2758: DISABLE
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 1
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 21
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 3
2792: PUSH
2793: LD_INT 24
2795: PUSH
2796: LD_INT 1000
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: LD_INT 92
2809: PUSH
2810: LD_INT 188
2812: PUSH
2813: LD_INT 112
2815: PUSH
2816: LD_INT 10
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: LIST
2829: LIST
2830: PPUSH
2831: CALL_OW 69
2835: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2836: LD_ADDR_VAR 0 2
2840: PUSH
2841: LD_INT 22
2843: PUSH
2844: LD_INT 4
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: LD_INT 25
2853: PUSH
2854: LD_INT 4
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 69
2869: ST_TO_ADDR
// if not sci then
2870: LD_VAR 0 2
2874: NOT
2875: IFFALSE 2879
// exit ;
2877: GO 3014
// if people then
2879: LD_VAR 0 1
2883: IFFALSE 2971
// begin for i in sci do
2885: LD_ADDR_VAR 0 3
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2967
// begin if GetTag ( i ) <> 102 then
2898: LD_VAR 0 3
2902: PPUSH
2903: CALL_OW 110
2907: PUSH
2908: LD_INT 102
2910: NONEQUAL
2911: IFFALSE 2925
// SetTag ( i , 102 ) ;
2913: LD_VAR 0 3
2917: PPUSH
2918: LD_INT 102
2920: PPUSH
2921: CALL_OW 109
// if IsInUnit ( i ) then
2925: LD_VAR 0 3
2929: PPUSH
2930: CALL_OW 310
2934: IFFALSE 2947
// ComExitBuilding ( i ) else
2936: LD_VAR 0 3
2940: PPUSH
2941: CALL_OW 122
2945: GO 2965
// ComHeal ( i , people [ 1 ] ) ;
2947: LD_VAR 0 3
2951: PPUSH
2952: LD_VAR 0 1
2956: PUSH
2957: LD_INT 1
2959: ARRAY
2960: PPUSH
2961: CALL_OW 128
// end ;
2965: GO 2895
2967: POP
2968: POP
// end else
2969: GO 3014
// if FilterByTag ( sci , 102 ) then
2971: LD_VAR 0 2
2975: PPUSH
2976: LD_INT 102
2978: PPUSH
2979: CALL 46002 0 2
2983: IFFALSE 3014
// begin for i in sci do
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_VAR 0 2
2994: PUSH
2995: FOR_IN
2996: IFFALSE 3012
// begin SetTag ( i , 0 ) ;
2998: LD_VAR 0 3
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 109
// end ;
3010: GO 2995
3012: POP
3013: POP
// end ; end ;
3014: PPOPN 3
3016: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3017: LD_INT 22
3019: PUSH
3020: LD_INT 4
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 33
3029: PUSH
3030: LD_INT 2
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 50
3039: PUSH
3040: EMPTY
3041: LIST
3042: PUSH
3043: LD_INT 3
3045: PUSH
3046: LD_INT 61
3048: PUSH
3049: EMPTY
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PPUSH
3062: CALL_OW 69
3066: IFFALSE 3157
3068: GO 3070
3070: DISABLE
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
// begin enable ;
3075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3076: LD_ADDR_VAR 0 2
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 4
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 33
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: EMPTY
3105: LIST
3106: PUSH
3107: LD_INT 3
3109: PUSH
3110: LD_INT 61
3112: PUSH
3113: EMPTY
3114: LIST
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: CALL_OW 69
3130: ST_TO_ADDR
// for i in tmp do
3131: LD_ADDR_VAR 0 1
3135: PUSH
3136: LD_VAR 0 2
3140: PUSH
3141: FOR_IN
3142: IFFALSE 3155
// Connect ( i ) ;
3144: LD_VAR 0 1
3148: PPUSH
3149: CALL 19137 0 1
3153: GO 3141
3155: POP
3156: POP
// end ; end_of_file
3157: PPOPN 2
3159: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3160: LD_INT 0
3162: PPUSH
3163: PPUSH
3164: PPUSH
3165: PPUSH
3166: PPUSH
3167: PPUSH
// gensher_side := 2 ;
3168: LD_ADDR_EXP 14
3172: PUSH
3173: LD_INT 2
3175: ST_TO_ADDR
// uc_side := gensher_side ;
3176: LD_ADDR_OWVAR 20
3180: PUSH
3181: LD_EXP 14
3185: ST_TO_ADDR
// uc_nation := 2 ;
3186: LD_ADDR_OWVAR 21
3190: PUSH
3191: LD_INT 2
3193: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3194: LD_ADDR_VAR 0 6
3198: PUSH
3199: LD_INT 5
3201: PUSH
3202: LD_INT 42
3204: PUSH
3205: LD_INT 29
3207: PUSH
3208: LD_INT 5
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 5
3219: PUSH
3220: LD_INT 36
3222: PUSH
3223: LD_INT 40
3225: PUSH
3226: LD_INT 5
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 13
3240: PUSH
3241: LD_INT 18
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: LD_INT 10
3249: PUSH
3250: LD_INT 15
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 27
3263: PUSH
3264: LD_INT 17
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 29
3281: PUSH
3282: LD_INT 56
3284: PUSH
3285: LD_INT 23
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: PUSH
3297: LD_INT 3
3299: PUSH
3300: LD_INT 11
3302: PUSH
3303: LD_INT 7
3305: PUSH
3306: LD_INT 2
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 27
3317: PUSH
3318: LD_INT 20
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: LD_INT 0
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 27
3335: PUSH
3336: LD_INT 23
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: LD_INT 0
3344: PUSH
3345: EMPTY
3346: LIST
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 27
3353: PUSH
3354: LD_INT 26
3356: PUSH
3357: LD_INT 3
3359: PUSH
3360: LD_INT 0
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 6
3371: PUSH
3372: LD_INT 17
3374: PUSH
3375: LD_INT 27
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 13
3383: PUSH
3384: LD_INT 11
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 27
3400: PUSH
3401: LD_INT 44
3403: PUSH
3404: LD_INT 5
3406: PUSH
3407: LD_INT 27
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: PUSH
3417: LD_INT 32
3419: PUSH
3420: LD_INT 41
3422: PUSH
3423: LD_INT 41
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: LD_INT 27
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 32
3441: PUSH
3442: LD_INT 45
3444: PUSH
3445: LD_INT 24
3447: PUSH
3448: LD_INT 5
3450: PUSH
3451: LD_INT 28
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 32
3463: PUSH
3464: LD_INT 48
3466: PUSH
3467: LD_INT 19
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 28
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: PUSH
3483: LD_INT 32
3485: PUSH
3486: LD_INT 41
3488: PUSH
3489: LD_INT 3
3491: PUSH
3492: LD_INT 4
3494: PUSH
3495: LD_INT 28
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 5
3507: PUSH
3508: LD_INT 44
3510: PUSH
3511: LD_INT 9
3513: PUSH
3514: LD_INT 4
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 30
3525: PUSH
3526: LD_INT 52
3528: PUSH
3529: LD_INT 40
3531: PUSH
3532: LD_INT 3
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: ST_TO_ADDR
// for i in list do
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: FOR_IN
3571: IFFALSE 3749
// begin uc_side := 2 ;
3573: LD_ADDR_OWVAR 20
3577: PUSH
3578: LD_INT 2
3580: ST_TO_ADDR
// uc_nation := 2 ;
3581: LD_ADDR_OWVAR 21
3585: PUSH
3586: LD_INT 2
3588: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3589: LD_ADDR_OWVAR 42
3593: PUSH
3594: LD_VAR 0 2
3598: PUSH
3599: LD_INT 1
3601: ARRAY
3602: ST_TO_ADDR
// bc_kind1 := - 1 ;
3603: LD_ADDR_OWVAR 44
3607: PUSH
3608: LD_INT 1
3610: NEG
3611: ST_TO_ADDR
// bc_kind2 := - 1 ;
3612: LD_ADDR_OWVAR 45
3616: PUSH
3617: LD_INT 1
3619: NEG
3620: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3621: LD_VAR 0 2
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: PUSH
3630: LD_INT 6
3632: EQUAL
3633: IFFALSE 3671
// begin bc_type := b_lab_full ;
3635: LD_ADDR_OWVAR 42
3639: PUSH
3640: LD_INT 8
3642: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3643: LD_ADDR_OWVAR 44
3647: PUSH
3648: LD_VAR 0 2
3652: PUSH
3653: LD_INT 5
3655: ARRAY
3656: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3657: LD_ADDR_OWVAR 45
3661: PUSH
3662: LD_VAR 0 2
3666: PUSH
3667: LD_INT 6
3669: ARRAY
3670: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3671: LD_ADDR_VAR 0 3
3675: PUSH
3676: LD_VAR 0 2
3680: PUSH
3681: LD_INT 2
3683: ARRAY
3684: PPUSH
3685: LD_VAR 0 2
3689: PUSH
3690: LD_INT 3
3692: ARRAY
3693: PPUSH
3694: LD_VAR 0 2
3698: PUSH
3699: LD_INT 4
3701: ARRAY
3702: PPUSH
3703: CALL_OW 47
3707: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 1
3715: ARRAY
3716: PUSH
3717: LD_INT 33
3719: PUSH
3720: LD_INT 32
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: IN
3727: IFFALSE 3747
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3729: LD_VAR 0 3
3733: PPUSH
3734: LD_VAR 0 2
3738: PUSH
3739: LD_INT 5
3741: ARRAY
3742: PPUSH
3743: CALL_OW 431
// end ;
3747: GO 3570
3749: POP
3750: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3751: LD_ADDR_VAR 0 4
3755: PUSH
3756: LD_INT 7
3758: PPUSH
3759: LD_INT 2
3761: PPUSH
3762: LD_STRING 
3764: PPUSH
3765: LD_INT 8
3767: PUSH
3768: LD_INT 7
3770: PUSH
3771: LD_INT 6
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: LD_INT 11500
3787: PUSH
3788: LD_INT 1100
3790: PUSH
3791: LD_INT 60
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: LIST
3798: PPUSH
3799: LD_INT 6
3801: PUSH
3802: LD_INT 6
3804: PUSH
3805: LD_INT 6
3807: PUSH
3808: LD_INT 6
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL 19490 0 6
3821: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3822: LD_ADDR_EXP 23
3826: PUSH
3827: LD_EXP 23
3831: PPUSH
3832: LD_INT 2
3834: PPUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_INT 2
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 3
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PPUSH
3864: CALL_OW 69
3868: UNION
3869: PPUSH
3870: CALL_OW 1
3874: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3875: LD_ADDR_VAR 0 4
3879: PUSH
3880: LD_INT 22
3882: PUSH
3883: LD_INT 2
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_INT 30
3892: PUSH
3893: LD_INT 31
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PPUSH
3904: CALL_OW 69
3908: ST_TO_ADDR
// for i in tmp do
3909: LD_ADDR_VAR 0 2
3913: PUSH
3914: LD_VAR 0 4
3918: PUSH
3919: FOR_IN
3920: IFFALSE 3990
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 4
3930: PUSH
3931: LD_INT 3
3933: PUSH
3934: LD_INT 3
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: LD_OWVAR 67
3946: ARRAY
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 1
3969: PPUSH
3970: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3974: LD_VAR 0 5
3978: PPUSH
3979: LD_VAR 0 2
3983: PPUSH
3984: CALL_OW 52
// end ;
3988: GO 3919
3990: POP
3991: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3992: LD_ADDR_VAR 0 4
3996: PUSH
3997: LD_INT 15
3999: PPUSH
4000: LD_INT 0
4002: PPUSH
4003: CALL_OW 517
4007: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4008: LD_ADDR_VAR 0 2
4012: PUSH
4013: DOUBLE
4014: LD_INT 1
4016: DEC
4017: ST_TO_ADDR
4018: LD_VAR 0 4
4022: PUSH
4023: LD_INT 1
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4130
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4030: LD_VAR 0 4
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PUSH
4039: LD_VAR 0 2
4043: ARRAY
4044: PPUSH
4045: LD_VAR 0 4
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PUSH
4054: LD_VAR 0 2
4058: ARRAY
4059: PPUSH
4060: LD_INT 2
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4070: LD_ADDR_EXP 3
4074: PUSH
4075: LD_EXP 3
4079: PPUSH
4080: LD_EXP 3
4084: PUSH
4085: LD_INT 1
4087: PLUS
4088: PPUSH
4089: LD_VAR 0 4
4093: PUSH
4094: LD_INT 1
4096: ARRAY
4097: PUSH
4098: LD_VAR 0 2
4102: ARRAY
4103: PUSH
4104: LD_VAR 0 4
4108: PUSH
4109: LD_INT 2
4111: ARRAY
4112: PUSH
4113: LD_VAR 0 2
4117: ARRAY
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: PPUSH
4123: CALL_OW 2
4127: ST_TO_ADDR
// end ;
4128: GO 4027
4130: POP
4131: POP
// if Difficulty > 1 then
4132: LD_OWVAR 67
4136: PUSH
4137: LD_INT 1
4139: GREATER
4140: IFFALSE 4282
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4142: LD_ADDR_VAR 0 4
4146: PUSH
4147: LD_INT 19
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL_OW 517
4157: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4158: LD_ADDR_VAR 0 2
4162: PUSH
4163: DOUBLE
4164: LD_INT 1
4166: DEC
4167: ST_TO_ADDR
4168: LD_VAR 0 4
4172: PUSH
4173: LD_INT 1
4175: ARRAY
4176: PUSH
4177: FOR_TO
4178: IFFALSE 4280
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4180: LD_VAR 0 4
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: PUSH
4189: LD_VAR 0 2
4193: ARRAY
4194: PPUSH
4195: LD_VAR 0 4
4199: PUSH
4200: LD_INT 2
4202: ARRAY
4203: PUSH
4204: LD_VAR 0 2
4208: ARRAY
4209: PPUSH
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4220: LD_ADDR_EXP 3
4224: PUSH
4225: LD_EXP 3
4229: PPUSH
4230: LD_EXP 3
4234: PUSH
4235: LD_INT 1
4237: PLUS
4238: PPUSH
4239: LD_VAR 0 4
4243: PUSH
4244: LD_INT 1
4246: ARRAY
4247: PUSH
4248: LD_VAR 0 2
4252: ARRAY
4253: PUSH
4254: LD_VAR 0 4
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PUSH
4263: LD_VAR 0 2
4267: ARRAY
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PPUSH
4273: CALL_OW 2
4277: ST_TO_ADDR
// end ;
4278: GO 4177
4280: POP
4281: POP
// end ; gensherAttackGroup := [ ] ;
4282: LD_ADDR_EXP 15
4286: PUSH
4287: EMPTY
4288: ST_TO_ADDR
// end ;
4289: LD_VAR 0 1
4293: RET
// export function InitMC_Gensher ( ) ; begin
4294: LD_INT 0
4296: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4297: LD_INT 2
4299: PPUSH
4300: LD_INT 2
4302: PPUSH
4303: CALL 77736 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4307: LD_INT 2
4309: PPUSH
4310: LD_INT 9
4312: PPUSH
4313: CALL 77680 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4317: LD_INT 2
4319: PPUSH
4320: LD_INT 56
4322: PUSH
4323: LD_INT 23
4325: PUSH
4326: LD_INT 0
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: LD_INT 52
4336: PUSH
4337: LD_INT 40
4339: PUSH
4340: LD_INT 1
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PPUSH
4352: CALL 76739 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4356: LD_INT 2
4358: PPUSH
4359: LD_INT 27
4361: PUSH
4362: LD_INT 28
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PPUSH
4369: CALL 77568 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4373: LD_INT 2
4375: PPUSH
4376: LD_INT 8
4378: PPUSH
4379: CALL 77250 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4383: LD_INT 2
4385: PPUSH
4386: LD_INT 7
4388: PPUSH
4389: CALL 76981 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4393: LD_INT 2
4395: PPUSH
4396: LD_INT 4
4398: PPUSH
4399: CALL 76600 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4403: LD_INT 2
4405: PPUSH
4406: LD_INT 13
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: LD_INT 31
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: LD_INT 13
4426: PUSH
4427: LD_INT 2
4429: PUSH
4430: LD_INT 1
4432: PUSH
4433: LD_INT 31
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 14
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 27
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 14
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: LD_INT 2
4468: PUSH
4469: LD_INT 27
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 14
4480: PUSH
4481: LD_INT 1
4483: PUSH
4484: LD_INT 2
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 14
4498: PUSH
4499: LD_INT 1
4501: PUSH
4502: LD_INT 2
4504: PUSH
4505: LD_INT 26
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL 76415 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4526: LD_INT 2
4528: PPUSH
4529: LD_INT 11
4531: PPUSH
4532: LD_INT 7
4534: PPUSH
4535: LD_INT 2
4537: PPUSH
4538: LD_INT 23
4540: PUSH
4541: LD_INT 16
4543: PUSH
4544: LD_INT 17
4546: PUSH
4547: LD_INT 18
4549: PUSH
4550: LD_INT 22
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PPUSH
4560: CALL 77362 0 5
// end ;
4564: LD_VAR 0 1
4568: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4569: LD_EXP 3
4573: PUSH
4574: LD_INT 15
4576: PPUSH
4577: LD_INT 81
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 70
4591: AND
4592: IFFALSE 4805
4594: GO 4596
4596: DISABLE
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
// begin enable ;
4604: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4605: LD_ADDR_VAR 0 3
4609: PUSH
4610: LD_INT 15
4612: PPUSH
4613: LD_INT 81
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 70
4627: ST_TO_ADDR
// if not tmp then
4628: LD_VAR 0 3
4632: NOT
4633: IFFALSE 4637
// exit ;
4635: GO 4805
// for i in tmp do
4637: LD_ADDR_VAR 0 1
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: FOR_IN
4648: IFFALSE 4803
// begin x := GetX ( i ) ;
4650: LD_ADDR_VAR 0 4
4654: PUSH
4655: LD_VAR 0 1
4659: PPUSH
4660: CALL_OW 250
4664: ST_TO_ADDR
// y := GetY ( i ) ;
4665: LD_ADDR_VAR 0 5
4669: PUSH
4670: LD_VAR 0 1
4674: PPUSH
4675: CALL_OW 251
4679: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4680: LD_VAR 0 4
4684: PPUSH
4685: LD_VAR 0 5
4689: PPUSH
4690: CALL_OW 458
4694: IFFALSE 4801
// begin LaunchMineAtPos ( x , y , 2 ) ;
4696: LD_VAR 0 4
4700: PPUSH
4701: LD_VAR 0 5
4705: PPUSH
4706: LD_INT 2
4708: PPUSH
4709: CALL_OW 456
// for j = 1 to staticMines do
4713: LD_ADDR_VAR 0 2
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_EXP 3
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4799
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4731: LD_EXP 3
4735: PUSH
4736: LD_VAR 0 2
4740: ARRAY
4741: PUSH
4742: LD_INT 1
4744: ARRAY
4745: PUSH
4746: LD_VAR 0 4
4750: EQUAL
4751: PUSH
4752: LD_EXP 3
4756: PUSH
4757: LD_VAR 0 2
4761: ARRAY
4762: PUSH
4763: LD_INT 2
4765: ARRAY
4766: PUSH
4767: LD_VAR 0 5
4771: EQUAL
4772: AND
4773: IFFALSE 4797
// begin staticMines := Delete ( staticMines , j ) ;
4775: LD_ADDR_EXP 3
4779: PUSH
4780: LD_EXP 3
4784: PPUSH
4785: LD_VAR 0 2
4789: PPUSH
4790: CALL_OW 3
4794: ST_TO_ADDR
// break ;
4795: GO 4799
// end ;
4797: GO 4728
4799: POP
4800: POP
// end ; end ;
4801: GO 4647
4803: POP
4804: POP
// end ;
4805: PPOPN 5
4807: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4808: LD_INT 7
4810: PPUSH
4811: CALL_OW 302
4815: PUSH
4816: LD_EXP 4
4820: NOT
4821: AND
4822: IFFALSE 5426
4824: GO 4826
4826: DISABLE
4827: LD_INT 0
4829: PPUSH
4830: PPUSH
4831: PPUSH
4832: PPUSH
4833: PPUSH
// begin enable ;
4834: ENABLE
// base := 2 ;
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_INT 2
4842: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4843: LD_ADDR_VAR 0 3
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 27
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 27
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 14
4886: PUSH
4887: LD_INT 1
4889: PUSH
4890: LD_INT 2
4892: PUSH
4893: LD_EXP 72
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 14
4906: PUSH
4907: LD_INT 1
4909: PUSH
4910: LD_INT 2
4912: PUSH
4913: LD_INT 26
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: LIST
4926: LIST
4927: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4928: LD_ADDR_VAR 0 5
4932: PUSH
4933: LD_VAR 0 5
4937: PUSH
4938: LD_OWVAR 1
4942: PUSH
4943: LD_INT 21000
4945: DIV
4946: PLUS
4947: ST_TO_ADDR
// if amount > 8 then
4948: LD_VAR 0 5
4952: PUSH
4953: LD_INT 8
4955: GREATER
4956: IFFALSE 4966
// amount := 8 ;
4958: LD_ADDR_VAR 0 5
4962: PUSH
4963: LD_INT 8
4965: ST_TO_ADDR
// for i = 1 to amount do
4966: LD_ADDR_VAR 0 1
4970: PUSH
4971: DOUBLE
4972: LD_INT 1
4974: DEC
4975: ST_TO_ADDR
4976: LD_VAR 0 5
4980: PUSH
4981: FOR_TO
4982: IFFALSE 5070
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4984: LD_ADDR_VAR 0 3
4988: PUSH
4989: LD_VAR 0 3
4993: PPUSH
4994: LD_VAR 0 3
4998: PUSH
4999: LD_INT 1
5001: PLUS
5002: PPUSH
5003: LD_INT 14
5005: PUSH
5006: LD_INT 13
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 1
5015: PPUSH
5016: LD_INT 2
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: PUSH
5025: LD_INT 1
5027: PUSH
5028: LD_INT 2
5030: PUSH
5031: LD_INT 28
5033: PUSH
5034: LD_INT 25
5036: PUSH
5037: LD_INT 27
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: PUSH
5045: LD_INT 1
5047: PPUSH
5048: LD_INT 3
5050: PPUSH
5051: CALL_OW 12
5055: ARRAY
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 2
5067: ST_TO_ADDR
5068: GO 4981
5070: POP
5071: POP
// MC_InsertProduceList ( base , tmp ) ;
5072: LD_VAR 0 2
5076: PPUSH
5077: LD_VAR 0 3
5081: PPUSH
5082: CALL 76463 0 2
// repeat wait ( 0 0$1 ) ;
5086: LD_INT 35
5088: PPUSH
5089: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5093: LD_VAR 0 2
5097: PPUSH
5098: LD_INT 1
5100: PPUSH
5101: CALL 77881 0 2
5105: PUSH
5106: LD_VAR 0 5
5110: GREATEREQUAL
5111: IFFALSE 5086
// wait ( 0 0$30 ) ;
5113: LD_INT 1050
5115: PPUSH
5116: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5120: LD_ADDR_VAR 0 4
5124: PUSH
5125: LD_EXP 42
5129: PUSH
5130: LD_VAR 0 2
5134: ARRAY
5135: PUSH
5136: LD_EXP 42
5140: PUSH
5141: LD_VAR 0 2
5145: ARRAY
5146: PPUSH
5147: LD_INT 2
5149: PUSH
5150: LD_INT 34
5152: PUSH
5153: LD_INT 31
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 34
5162: PUSH
5163: LD_INT 32
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 34
5172: PUSH
5173: LD_EXP 73
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: LIST
5186: LIST
5187: PPUSH
5188: CALL_OW 72
5192: DIFF
5193: ST_TO_ADDR
// if not attackers then
5194: LD_VAR 0 4
5198: NOT
5199: IFFALSE 5203
// exit ;
5201: GO 5426
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5203: LD_ADDR_EXP 42
5207: PUSH
5208: LD_EXP 42
5212: PPUSH
5213: LD_VAR 0 2
5217: PPUSH
5218: LD_EXP 42
5222: PUSH
5223: LD_VAR 0 2
5227: ARRAY
5228: PUSH
5229: LD_VAR 0 4
5233: DIFF
5234: PPUSH
5235: CALL_OW 1
5239: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5240: LD_VAR 0 4
5244: PPUSH
5245: LD_INT 107
5247: PPUSH
5248: LD_INT 74
5250: PPUSH
5251: CALL_OW 114
// wait ( 0 0$5 ) ;
5255: LD_INT 175
5257: PPUSH
5258: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5262: LD_INT 35
5264: PPUSH
5265: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5269: LD_VAR 0 4
5273: PPUSH
5274: LD_INT 60
5276: PUSH
5277: EMPTY
5278: LIST
5279: PPUSH
5280: CALL_OW 72
5284: NOT
5285: IFFALSE 5262
// if rand ( 0 , 1 ) then
5287: LD_INT 0
5289: PPUSH
5290: LD_INT 1
5292: PPUSH
5293: CALL_OW 12
5297: IFFALSE 5316
// ComAgressiveMove ( attackers , 155 , 108 ) else
5299: LD_VAR 0 4
5303: PPUSH
5304: LD_INT 155
5306: PPUSH
5307: LD_INT 108
5309: PPUSH
5310: CALL_OW 114
5314: GO 5331
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5316: LD_VAR 0 4
5320: PPUSH
5321: LD_INT 149
5323: PPUSH
5324: LD_INT 55
5326: PPUSH
5327: CALL_OW 114
// wait ( 0 0$10 ) ;
5331: LD_INT 350
5333: PPUSH
5334: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5338: LD_INT 35
5340: PPUSH
5341: CALL_OW 67
// for i in attackers do
5345: LD_ADDR_VAR 0 1
5349: PUSH
5350: LD_VAR 0 4
5354: PUSH
5355: FOR_IN
5356: IFFALSE 5406
// if not HasTask ( i ) then
5358: LD_VAR 0 1
5362: PPUSH
5363: CALL_OW 314
5367: NOT
5368: IFFALSE 5404
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5370: LD_VAR 0 1
5374: PPUSH
5375: LD_INT 81
5377: PUSH
5378: LD_INT 2
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: PPUSH
5390: LD_VAR 0 1
5394: PPUSH
5395: CALL_OW 74
5399: PPUSH
5400: CALL_OW 115
5404: GO 5355
5406: POP
5407: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5408: LD_VAR 0 4
5412: PPUSH
5413: LD_INT 50
5415: PUSH
5416: EMPTY
5417: LIST
5418: PPUSH
5419: CALL_OW 72
5423: NOT
5424: IFFALSE 5338
// end ;
5426: PPOPN 5
5428: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5429: LD_EXP 4
5433: NOT
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 191100
5442: LESS
5443: AND
5444: IFFALSE 6116
5446: GO 5448
5448: DISABLE
5449: LD_INT 0
5451: PPUSH
5452: PPUSH
5453: PPUSH
// begin enable ;
5454: ENABLE
// tmp := [ ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: EMPTY
5461: ST_TO_ADDR
// if tick < 35 35$00 then
5462: LD_OWVAR 1
5466: PUSH
5467: LD_INT 73500
5469: LESS
5470: IFFALSE 5668
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5472: LD_ADDR_VAR 0 1
5476: PUSH
5477: DOUBLE
5478: LD_INT 1
5480: DEC
5481: ST_TO_ADDR
5482: LD_INT 4
5484: PUSH
5485: LD_INT 5
5487: PUSH
5488: LD_INT 5
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5664
// begin uc_side := 2 ;
5505: LD_ADDR_OWVAR 20
5509: PUSH
5510: LD_INT 2
5512: ST_TO_ADDR
// uc_nation := 2 ;
5513: LD_ADDR_OWVAR 21
5517: PUSH
5518: LD_INT 2
5520: ST_TO_ADDR
// InitHC_All ( ) ;
5521: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: LD_INT 5
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 7
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: PUSH
5545: LD_OWVAR 67
5549: ARRAY
5550: PPUSH
5551: CALL_OW 380
// un := CreateHuman ;
5555: LD_ADDR_VAR 0 2
5559: PUSH
5560: CALL_OW 44
5564: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5565: LD_VAR 0 2
5569: PPUSH
5570: LD_INT 17
5572: PPUSH
5573: LD_INT 0
5575: PPUSH
5576: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5580: LD_VAR 0 2
5584: PPUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 1
5597: PPUSH
5598: LD_INT 2
5600: PPUSH
5601: CALL_OW 12
5605: ARRAY
5606: PPUSH
5607: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5611: LD_VAR 0 2
5615: PPUSH
5616: LD_INT 111
5618: PPUSH
5619: LD_INT 34
5621: PPUSH
5622: CALL_OW 114
// wait ( 0 0$2 ) ;
5626: LD_INT 70
5628: PPUSH
5629: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5633: LD_ADDR_VAR 0 3
5637: PUSH
5638: LD_VAR 0 3
5642: PPUSH
5643: LD_VAR 0 3
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: PPUSH
5652: LD_VAR 0 2
5656: PPUSH
5657: CALL_OW 1
5661: ST_TO_ADDR
// end ;
5662: GO 5502
5664: POP
5665: POP
// end else
5666: GO 5809
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5668: LD_ADDR_VAR 0 1
5672: PUSH
5673: DOUBLE
5674: LD_INT 1
5676: DEC
5677: ST_TO_ADDR
5678: LD_INT 4
5680: PUSH
5681: LD_INT 5
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_OWVAR 67
5696: ARRAY
5697: PUSH
5698: FOR_TO
5699: IFFALSE 5807
// begin uc_side := 2 ;
5701: LD_ADDR_OWVAR 20
5705: PUSH
5706: LD_INT 2
5708: ST_TO_ADDR
// uc_nation := 0 ;
5709: LD_ADDR_OWVAR 21
5713: PUSH
5714: LD_INT 0
5716: ST_TO_ADDR
// InitHC_All ( ) ;
5717: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5721: LD_ADDR_OWVAR 28
5725: PUSH
5726: LD_INT 17
5728: ST_TO_ADDR
// un := CreateHuman ;
5729: LD_ADDR_VAR 0 2
5733: PUSH
5734: CALL_OW 44
5738: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5739: LD_VAR 0 2
5743: PPUSH
5744: LD_INT 17
5746: PPUSH
5747: LD_INT 0
5749: PPUSH
5750: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5754: LD_VAR 0 2
5758: PPUSH
5759: LD_INT 110
5761: PPUSH
5762: LD_INT 33
5764: PPUSH
5765: CALL_OW 114
// wait ( 0 0$2 ) ;
5769: LD_INT 70
5771: PPUSH
5772: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5776: LD_ADDR_VAR 0 3
5780: PUSH
5781: LD_VAR 0 3
5785: PPUSH
5786: LD_VAR 0 3
5790: PUSH
5791: LD_INT 1
5793: PLUS
5794: PPUSH
5795: LD_VAR 0 2
5799: PPUSH
5800: CALL_OW 1
5804: ST_TO_ADDR
// end ;
5805: GO 5698
5807: POP
5808: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5809: LD_ADDR_VAR 0 1
5813: PUSH
5814: DOUBLE
5815: LD_INT 1
5817: DEC
5818: ST_TO_ADDR
5819: LD_INT 3
5821: PUSH
5822: LD_INT 4
5824: PUSH
5825: LD_INT 5
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_OWVAR 67
5837: ARRAY
5838: PUSH
5839: FOR_TO
5840: IFFALSE 6005
// begin uc_side := 2 ;
5842: LD_ADDR_OWVAR 20
5846: PUSH
5847: LD_INT 2
5849: ST_TO_ADDR
// uc_nation := 2 ;
5850: LD_ADDR_OWVAR 21
5854: PUSH
5855: LD_INT 2
5857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5858: LD_INT 14
5860: PPUSH
5861: LD_INT 3
5863: PPUSH
5864: LD_INT 5
5866: PPUSH
5867: LD_INT 29
5869: PUSH
5870: LD_INT 28
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: CALL_OW 12
5891: ARRAY
5892: PPUSH
5893: LD_INT 90
5895: PPUSH
5896: CALL 16044 0 5
// un := CreateVehicle ;
5900: LD_ADDR_VAR 0 2
5904: PUSH
5905: CALL_OW 45
5909: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5910: LD_VAR 0 2
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5922: LD_VAR 0 2
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_INT 0
5932: PPUSH
5933: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5937: LD_VAR 0 2
5941: PPUSH
5942: LD_INT 66
5944: PPUSH
5945: LD_INT 23
5947: PPUSH
5948: CALL_OW 111
// wait ( 0 0$3 ) ;
5952: LD_INT 105
5954: PPUSH
5955: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_INT 147
5966: PPUSH
5967: LD_INT 103
5969: PPUSH
5970: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5974: LD_ADDR_VAR 0 3
5978: PUSH
5979: LD_VAR 0 3
5983: PPUSH
5984: LD_VAR 0 3
5988: PUSH
5989: LD_INT 1
5991: PLUS
5992: PPUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: CALL_OW 1
6002: ST_TO_ADDR
// end ;
6003: GO 5839
6005: POP
6006: POP
// if not tmp then
6007: LD_VAR 0 3
6011: NOT
6012: IFFALSE 6016
// exit ;
6014: GO 6116
// wait ( 0 0$5 ) ;
6016: LD_INT 175
6018: PPUSH
6019: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6023: LD_INT 70
6025: PPUSH
6026: CALL_OW 67
// for i in tmp do
6030: LD_ADDR_VAR 0 1
6034: PUSH
6035: LD_VAR 0 3
6039: PUSH
6040: FOR_IN
6041: IFFALSE 6107
// begin if not IsOk ( i ) then
6043: LD_VAR 0 1
6047: PPUSH
6048: CALL_OW 302
6052: NOT
6053: IFFALSE 6071
// tmp := tmp diff i ;
6055: LD_ADDR_VAR 0 3
6059: PUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_VAR 0 1
6069: DIFF
6070: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6071: LD_VAR 0 1
6075: PPUSH
6076: LD_INT 81
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 69
6090: PPUSH
6091: LD_VAR 0 1
6095: PPUSH
6096: CALL_OW 74
6100: PPUSH
6101: CALL_OW 115
// end ;
6105: GO 6040
6107: POP
6108: POP
// until not tmp ;
6109: LD_VAR 0 3
6113: NOT
6114: IFFALSE 6023
// end ;
6116: PPOPN 3
6118: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6119: LD_OWVAR 67
6123: PUSH
6124: LD_INT 1
6126: GREATER
6127: IFFALSE 6225
6129: GO 6131
6131: DISABLE
6132: LD_INT 0
6134: PPUSH
// begin uc_side := 2 ;
6135: LD_ADDR_OWVAR 20
6139: PUSH
6140: LD_INT 2
6142: ST_TO_ADDR
// uc_nation := 2 ;
6143: LD_ADDR_OWVAR 21
6147: PUSH
6148: LD_INT 2
6150: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6151: LD_INT 0
6153: PPUSH
6154: LD_INT 4
6156: PPUSH
6157: LD_INT 6
6159: PPUSH
6160: CALL_OW 380
// un := CreateHuman ;
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: CALL_OW 44
6173: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 88
6181: PPUSH
6182: LD_INT 1
6184: PPUSH
6185: LD_INT 2
6187: PPUSH
6188: LD_INT 0
6190: PPUSH
6191: CALL 50570 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 130
6202: PPUSH
6203: LD_INT 35
6205: PPUSH
6206: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6210: LD_VAR 0 1
6214: PPUSH
6215: LD_INT 132
6217: PPUSH
6218: LD_INT 39
6220: PPUSH
6221: CALL_OW 218
// end ;
6225: PPOPN 1
6227: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6228: LD_INT 22
6230: PUSH
6231: LD_INT 2
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 33
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 50
6250: PUSH
6251: EMPTY
6252: LIST
6253: PUSH
6254: LD_INT 3
6256: PUSH
6257: LD_INT 61
6259: PUSH
6260: EMPTY
6261: LIST
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: PPUSH
6273: CALL_OW 69
6277: IFFALSE 6368
6279: GO 6281
6281: DISABLE
6282: LD_INT 0
6284: PPUSH
6285: PPUSH
// begin enable ;
6286: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6287: LD_ADDR_VAR 0 2
6291: PUSH
6292: LD_INT 22
6294: PUSH
6295: LD_INT 2
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 33
6304: PUSH
6305: LD_INT 2
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: LD_INT 50
6314: PUSH
6315: EMPTY
6316: LIST
6317: PUSH
6318: LD_INT 3
6320: PUSH
6321: LD_INT 61
6323: PUSH
6324: EMPTY
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PPUSH
6337: CALL_OW 69
6341: ST_TO_ADDR
// for i in tmp do
6342: LD_ADDR_VAR 0 1
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: FOR_IN
6353: IFFALSE 6366
// Connect ( i ) ;
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL 19137 0 1
6364: GO 6352
6366: POP
6367: POP
// end ; end_of_file
6368: PPOPN 2
6370: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6371: LD_INT 0
6373: PPUSH
6374: PPUSH
6375: PPUSH
6376: PPUSH
6377: PPUSH
6378: PPUSH
// popov_side := 3 ;
6379: LD_ADDR_EXP 17
6383: PUSH
6384: LD_INT 3
6386: ST_TO_ADDR
// uc_side := popov_side ;
6387: LD_ADDR_OWVAR 20
6391: PUSH
6392: LD_EXP 17
6396: ST_TO_ADDR
// uc_nation := 3 ;
6397: LD_ADDR_OWVAR 21
6401: PUSH
6402: LD_INT 3
6404: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6405: LD_ADDR_VAR 0 6
6409: PUSH
6410: LD_INT 5
6412: PUSH
6413: LD_INT 103
6415: PUSH
6416: LD_INT 147
6418: PUSH
6419: LD_INT 3
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 5
6430: PUSH
6431: LD_INT 70
6433: PUSH
6434: LD_INT 117
6436: PUSH
6437: LD_INT 3
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: LD_INT 76
6451: PUSH
6452: LD_INT 145
6454: PUSH
6455: LD_INT 1
6457: PUSH
6458: LD_INT 10
6460: PUSH
6461: LD_INT 11
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 26
6474: PUSH
6475: LD_INT 87
6477: PUSH
6478: LD_INT 144
6480: PUSH
6481: LD_INT 0
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 29
6492: PUSH
6493: LD_INT 86
6495: PUSH
6496: LD_INT 118
6498: PUSH
6499: LD_INT 0
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 29
6510: PUSH
6511: LD_INT 98
6513: PUSH
6514: LD_INT 121
6516: PUSH
6517: LD_INT 0
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 26
6528: PUSH
6529: LD_INT 87
6531: PUSH
6532: LD_INT 147
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 30
6546: PUSH
6547: LD_INT 123
6549: PUSH
6550: LD_INT 151
6552: PUSH
6553: LD_INT 1
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 3
6564: PUSH
6565: LD_INT 94
6567: PUSH
6568: LD_INT 161
6570: PUSH
6571: LD_INT 0
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: LD_INT 6
6582: PUSH
6583: LD_INT 81
6585: PUSH
6586: LD_INT 155
6588: PUSH
6589: LD_INT 1
6591: PUSH
6592: LD_INT 12
6594: PUSH
6595: LD_INT 14
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 26
6608: PUSH
6609: LD_INT 96
6611: PUSH
6612: LD_INT 152
6614: PUSH
6615: LD_INT 0
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 26
6626: PUSH
6627: LD_INT 96
6629: PUSH
6630: LD_INT 149
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 32
6644: PUSH
6645: LD_INT 109
6647: PUSH
6648: LD_INT 142
6650: PUSH
6651: LD_INT 3
6653: PUSH
6654: LD_INT 46
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 32
6666: PUSH
6667: LD_INT 112
6669: PUSH
6670: LD_INT 148
6672: PUSH
6673: LD_INT 3
6675: PUSH
6676: LD_INT 46
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 33
6688: PUSH
6689: LD_INT 120
6691: PUSH
6692: LD_INT 159
6694: PUSH
6695: LD_INT 4
6697: PUSH
6698: LD_INT 45
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 33
6710: PUSH
6711: LD_INT 122
6713: PUSH
6714: LD_INT 163
6716: PUSH
6717: LD_INT 4
6719: PUSH
6720: LD_INT 45
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 33
6732: PUSH
6733: LD_INT 123
6735: PUSH
6736: LD_INT 167
6738: PUSH
6739: LD_INT 4
6741: PUSH
6742: LD_INT 45
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 33
6754: PUSH
6755: LD_INT 59
6757: PUSH
6758: LD_INT 111
6760: PUSH
6761: LD_INT 3
6763: PUSH
6764: LD_INT 45
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 33
6776: PUSH
6777: LD_INT 65
6779: PUSH
6780: LD_INT 111
6782: PUSH
6783: LD_INT 3
6785: PUSH
6786: LD_INT 46
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 33
6798: PUSH
6799: LD_INT 76
6801: PUSH
6802: LD_INT 117
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: LD_INT 45
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 33
6820: PUSH
6821: LD_INT 80
6823: PUSH
6824: LD_INT 119
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: LD_INT 46
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 33
6842: PUSH
6843: LD_INT 87
6845: PUSH
6846: LD_INT 125
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 45
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 92
6867: PUSH
6868: LD_INT 129
6870: PUSH
6871: LD_INT 3
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 28
6882: PUSH
6883: LD_INT 85
6885: PUSH
6886: LD_INT 165
6888: PUSH
6889: LD_INT 0
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 28
6900: PUSH
6901: LD_INT 83
6903: PUSH
6904: LD_INT 161
6906: PUSH
6907: LD_INT 4
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: LIST
6915: PUSH
6916: LD_INT 28
6918: PUSH
6919: LD_INT 91
6921: PUSH
6922: LD_INT 166
6924: PUSH
6925: LD_INT 3
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_INT 28
6936: PUSH
6937: LD_INT 102
6939: PUSH
6940: LD_INT 166
6942: PUSH
6943: LD_INT 2
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: LIST
6974: LIST
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: ST_TO_ADDR
// for i in list do
6981: LD_ADDR_VAR 0 2
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7170
// begin uc_side := 3 ;
6994: LD_ADDR_OWVAR 20
6998: PUSH
6999: LD_INT 3
7001: ST_TO_ADDR
// uc_nation := 3 ;
7002: LD_ADDR_OWVAR 21
7006: PUSH
7007: LD_INT 3
7009: ST_TO_ADDR
// bc_type := i [ 1 ] ;
7010: LD_ADDR_OWVAR 42
7014: PUSH
7015: LD_VAR 0 2
7019: PUSH
7020: LD_INT 1
7022: ARRAY
7023: ST_TO_ADDR
// bc_kind1 := - 1 ;
7024: LD_ADDR_OWVAR 44
7028: PUSH
7029: LD_INT 1
7031: NEG
7032: ST_TO_ADDR
// bc_kind2 := - 1 ;
7033: LD_ADDR_OWVAR 45
7037: PUSH
7038: LD_INT 1
7040: NEG
7041: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7042: LD_VAR 0 2
7046: PUSH
7047: LD_INT 1
7049: ARRAY
7050: PUSH
7051: LD_INT 6
7053: EQUAL
7054: IFFALSE 7092
// begin bc_type := b_lab_full ;
7056: LD_ADDR_OWVAR 42
7060: PUSH
7061: LD_INT 8
7063: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7064: LD_ADDR_OWVAR 44
7068: PUSH
7069: LD_VAR 0 2
7073: PUSH
7074: LD_INT 5
7076: ARRAY
7077: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7078: LD_ADDR_OWVAR 45
7082: PUSH
7083: LD_VAR 0 2
7087: PUSH
7088: LD_INT 6
7090: ARRAY
7091: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7092: LD_ADDR_VAR 0 5
7096: PUSH
7097: LD_VAR 0 2
7101: PUSH
7102: LD_INT 2
7104: ARRAY
7105: PPUSH
7106: LD_VAR 0 2
7110: PUSH
7111: LD_INT 3
7113: ARRAY
7114: PPUSH
7115: LD_VAR 0 2
7119: PUSH
7120: LD_INT 4
7122: ARRAY
7123: PPUSH
7124: CALL_OW 47
7128: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7129: LD_VAR 0 2
7133: PUSH
7134: LD_INT 1
7136: ARRAY
7137: PUSH
7138: LD_INT 33
7140: PUSH
7141: LD_INT 32
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: IN
7148: IFFALSE 7168
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7150: LD_VAR 0 5
7154: PPUSH
7155: LD_VAR 0 2
7159: PUSH
7160: LD_INT 5
7162: ARRAY
7163: PPUSH
7164: CALL_OW 431
// end ;
7168: GO 6991
7170: POP
7171: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7172: LD_ADDR_VAR 0 4
7176: PUSH
7177: LD_INT 9
7179: PPUSH
7180: LD_INT 3
7182: PPUSH
7183: LD_STRING 
7185: PPUSH
7186: LD_INT 8
7188: PUSH
7189: LD_INT 7
7191: PUSH
7192: LD_INT 6
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: PPUSH
7206: LD_INT 11500
7208: PUSH
7209: LD_INT 1100
7211: PUSH
7212: LD_INT 60
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: LD_INT 6
7222: PUSH
7223: LD_INT 6
7225: PUSH
7226: LD_INT 6
7228: PUSH
7229: LD_INT 6
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PPUSH
7238: CALL 19490 0 6
7242: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7243: LD_ADDR_EXP 23
7247: PUSH
7248: LD_EXP 23
7252: PPUSH
7253: LD_INT 3
7255: PPUSH
7256: LD_VAR 0 4
7260: PUSH
7261: LD_INT 22
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 3
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: UNION
7290: PPUSH
7291: CALL_OW 1
7295: ST_TO_ADDR
// extraPopovForces := [ ] ;
7296: LD_ADDR_EXP 18
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7303: LD_ADDR_VAR 0 2
7307: PUSH
7308: DOUBLE
7309: LD_INT 1
7311: DEC
7312: ST_TO_ADDR
7313: LD_INT 8
7315: PUSH
7316: LD_INT 9
7318: PUSH
7319: LD_INT 10
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: LIST
7326: PUSH
7327: LD_OWVAR 67
7331: ARRAY
7332: PUSH
7333: FOR_TO
7334: IFFALSE 7463
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7336: LD_INT 0
7338: PPUSH
7339: LD_INT 1
7341: PPUSH
7342: LD_INT 4
7344: PUSH
7345: LD_INT 5
7347: PUSH
7348: LD_INT 6
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_OWVAR 67
7360: ARRAY
7361: PPUSH
7362: CALL_OW 380
// un := CreateHuman ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: CALL_OW 44
7375: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7376: LD_INT 0
7378: PPUSH
7379: LD_INT 1
7381: PPUSH
7382: CALL_OW 12
7386: IFFALSE 7411
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_INT 131
7395: PPUSH
7396: LD_INT 110
7398: PPUSH
7399: LD_INT 8
7401: PPUSH
7402: LD_INT 0
7404: PPUSH
7405: CALL_OW 50
7409: GO 7432
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7411: LD_VAR 0 3
7415: PPUSH
7416: LD_INT 100
7418: PPUSH
7419: LD_INT 99
7421: PPUSH
7422: LD_INT 8
7424: PPUSH
7425: LD_INT 0
7427: PPUSH
7428: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7432: LD_ADDR_EXP 18
7436: PUSH
7437: LD_EXP 18
7441: PPUSH
7442: LD_EXP 18
7446: PUSH
7447: LD_INT 1
7449: PLUS
7450: PPUSH
7451: LD_VAR 0 3
7455: PPUSH
7456: CALL_OW 1
7460: ST_TO_ADDR
// end ;
7461: GO 7333
7463: POP
7464: POP
// PrepareSoldier ( false , 6 ) ;
7465: LD_INT 0
7467: PPUSH
7468: LD_INT 6
7470: PPUSH
7471: CALL_OW 381
// un := CreateHuman ;
7475: LD_ADDR_VAR 0 3
7479: PUSH
7480: CALL_OW 44
7484: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7485: LD_VAR 0 3
7489: PPUSH
7490: LD_INT 1
7492: PPUSH
7493: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7497: LD_VAR 0 3
7501: PPUSH
7502: LD_INT 150
7504: PPUSH
7505: LD_INT 158
7507: PPUSH
7508: CALL_OW 428
7512: PPUSH
7513: CALL_OW 52
// popovAttackGroup := [ ] ;
7517: LD_ADDR_EXP 19
7521: PUSH
7522: EMPTY
7523: ST_TO_ADDR
// end ;
7524: LD_VAR 0 1
7528: RET
// export function InitMC_Popov ( ) ; begin
7529: LD_INT 0
7531: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7532: LD_INT 3
7534: PPUSH
7535: LD_INT 3
7537: PPUSH
7538: CALL 77736 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7542: LD_INT 3
7544: PPUSH
7545: LD_INT 10
7547: PPUSH
7548: CALL 77680 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7552: LD_INT 3
7554: PPUSH
7555: LD_INT 86
7557: PUSH
7558: LD_INT 118
7560: PUSH
7561: LD_INT 0
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 123
7571: PUSH
7572: LD_INT 151
7574: PUSH
7575: LD_INT 1
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 98
7585: PUSH
7586: LD_INT 121
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: LIST
7601: PPUSH
7602: CALL 76739 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7606: LD_INT 3
7608: PPUSH
7609: LD_INT 46
7611: PUSH
7612: LD_INT 45
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PPUSH
7619: CALL 77568 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7623: LD_INT 3
7625: PPUSH
7626: LD_INT 12
7628: PPUSH
7629: CALL 77250 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7633: LD_INT 3
7635: PPUSH
7636: LD_INT 11
7638: PPUSH
7639: CALL 76981 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7643: LD_INT 3
7645: PPUSH
7646: LD_INT 4
7648: PPUSH
7649: CALL 76600 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7653: LD_INT 3
7655: PPUSH
7656: LD_INT 23
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 44
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 23
7676: PUSH
7677: LD_INT 1
7679: PUSH
7680: LD_INT 3
7682: PUSH
7683: LD_INT 45
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 21
7694: PUSH
7695: LD_INT 1
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 44
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 21
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 45
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL 76415 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7738: LD_INT 3
7740: PPUSH
7741: LD_INT 94
7743: PPUSH
7744: LD_INT 161
7746: PPUSH
7747: LD_INT 0
7749: PPUSH
7750: LD_INT 19
7752: PUSH
7753: LD_INT 17
7755: PUSH
7756: LD_INT 18
7758: PUSH
7759: LD_INT 24
7761: PUSH
7762: LD_INT 21
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: PPUSH
7772: CALL 77362 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7776: LD_INT 3
7778: PPUSH
7779: LD_INT 21
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: LD_INT 3
7787: PUSH
7788: LD_INT 51
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: PPUSH
7800: CALL 76463 0 2
// end ;
7804: LD_VAR 0 1
7808: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7809: LD_EXP 18
7813: PUSH
7814: LD_EXP 5
7818: NOT
7819: AND
7820: IFFALSE 7880
7822: GO 7824
7824: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7825: LD_EXP 18
7829: PPUSH
7830: LD_INT 106
7832: PPUSH
7833: LD_INT 137
7835: PPUSH
7836: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7840: LD_ADDR_EXP 23
7844: PUSH
7845: LD_EXP 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_EXP 23
7857: PUSH
7858: LD_INT 3
7860: ARRAY
7861: PUSH
7862: LD_EXP 18
7866: UNION
7867: PPUSH
7868: CALL_OW 1
7872: ST_TO_ADDR
// extraPopovForces := [ ] ;
7873: LD_ADDR_EXP 18
7877: PUSH
7878: EMPTY
7879: ST_TO_ADDR
// end ;
7880: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7881: LD_INT 9
7883: PPUSH
7884: CALL_OW 302
7888: PUSH
7889: LD_EXP 5
7893: NOT
7894: AND
7895: IFFALSE 8461
7897: GO 7899
7899: DISABLE
7900: LD_INT 0
7902: PPUSH
7903: PPUSH
7904: PPUSH
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// base := 3 ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7916: LD_ADDR_VAR 0 3
7920: PUSH
7921: LD_INT 22
7923: PUSH
7924: LD_INT 1
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 44
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 24
7941: PUSH
7942: LD_INT 1
7944: PUSH
7945: LD_INT 3
7947: PUSH
7948: LD_INT 46
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 24
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: LD_INT 3
7965: PUSH
7966: LD_INT 46
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: LD_INT 24
7977: PUSH
7978: LD_INT 1
7980: PUSH
7981: LD_INT 3
7983: PUSH
7984: LD_INT 46
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7999: LD_ADDR_VAR 0 5
8003: PUSH
8004: LD_VAR 0 5
8008: PUSH
8009: LD_OWVAR 1
8013: PUSH
8014: LD_INT 21000
8016: DIV
8017: PLUS
8018: ST_TO_ADDR
// if amount > 8 then
8019: LD_VAR 0 5
8023: PUSH
8024: LD_INT 8
8026: GREATER
8027: IFFALSE 8037
// amount := 8 ;
8029: LD_ADDR_VAR 0 5
8033: PUSH
8034: LD_INT 8
8036: ST_TO_ADDR
// for i = 1 to amount do
8037: LD_ADDR_VAR 0 1
8041: PUSH
8042: DOUBLE
8043: LD_INT 1
8045: DEC
8046: ST_TO_ADDR
8047: LD_VAR 0 5
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8118
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8055: LD_ADDR_VAR 0 3
8059: PUSH
8060: LD_VAR 0 3
8064: PPUSH
8065: LD_VAR 0 3
8069: PUSH
8070: LD_INT 1
8072: PLUS
8073: PPUSH
8074: LD_INT 24
8076: PUSH
8077: LD_INT 1
8079: PUSH
8080: LD_INT 3
8082: PUSH
8083: LD_INT 46
8085: PUSH
8086: LD_INT 45
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: PUSH
8093: LD_INT 1
8095: PPUSH
8096: LD_INT 2
8098: PPUSH
8099: CALL_OW 12
8103: ARRAY
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: LIST
8109: LIST
8110: PPUSH
8111: CALL_OW 2
8115: ST_TO_ADDR
8116: GO 8052
8118: POP
8119: POP
// MC_InsertProduceList ( base , tmp ) ;
8120: LD_VAR 0 2
8124: PPUSH
8125: LD_VAR 0 3
8129: PPUSH
8130: CALL 76463 0 2
// repeat wait ( 0 0$1 ) ;
8134: LD_INT 35
8136: PPUSH
8137: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8141: LD_VAR 0 2
8145: PPUSH
8146: LD_INT 1
8148: PPUSH
8149: CALL 77881 0 2
8153: PUSH
8154: LD_VAR 0 5
8158: GREATEREQUAL
8159: IFFALSE 8134
// wait ( 0 0$30 ) ;
8161: LD_INT 1050
8163: PPUSH
8164: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8168: LD_ADDR_VAR 0 4
8172: PUSH
8173: LD_EXP 42
8177: PUSH
8178: LD_VAR 0 2
8182: ARRAY
8183: PUSH
8184: LD_EXP 42
8188: PUSH
8189: LD_VAR 0 2
8193: ARRAY
8194: PPUSH
8195: LD_INT 2
8197: PUSH
8198: LD_INT 34
8200: PUSH
8201: LD_INT 51
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PUSH
8208: LD_INT 34
8210: PUSH
8211: LD_INT 52
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 72
8227: DIFF
8228: ST_TO_ADDR
// if not attackers then
8229: LD_VAR 0 4
8233: NOT
8234: IFFALSE 8238
// exit ;
8236: GO 8461
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8238: LD_ADDR_EXP 42
8242: PUSH
8243: LD_EXP 42
8247: PPUSH
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_EXP 42
8257: PUSH
8258: LD_VAR 0 2
8262: ARRAY
8263: PUSH
8264: LD_VAR 0 4
8268: DIFF
8269: PPUSH
8270: CALL_OW 1
8274: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8275: LD_VAR 0 4
8279: PPUSH
8280: LD_INT 107
8282: PPUSH
8283: LD_INT 74
8285: PPUSH
8286: CALL_OW 114
// wait ( 0 0$5 ) ;
8290: LD_INT 175
8292: PPUSH
8293: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8304: LD_VAR 0 4
8308: PPUSH
8309: LD_INT 60
8311: PUSH
8312: EMPTY
8313: LIST
8314: PPUSH
8315: CALL_OW 72
8319: NOT
8320: IFFALSE 8297
// if rand ( 0 , 1 ) then
8322: LD_INT 0
8324: PPUSH
8325: LD_INT 1
8327: PPUSH
8328: CALL_OW 12
8332: IFFALSE 8351
// ComAgressiveMove ( attackers , 155 , 108 ) else
8334: LD_VAR 0 4
8338: PPUSH
8339: LD_INT 155
8341: PPUSH
8342: LD_INT 108
8344: PPUSH
8345: CALL_OW 114
8349: GO 8366
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8351: LD_VAR 0 4
8355: PPUSH
8356: LD_INT 149
8358: PPUSH
8359: LD_INT 55
8361: PPUSH
8362: CALL_OW 114
// wait ( 0 0$10 ) ;
8366: LD_INT 350
8368: PPUSH
8369: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8373: LD_INT 35
8375: PPUSH
8376: CALL_OW 67
// for i in attackers do
8380: LD_ADDR_VAR 0 1
8384: PUSH
8385: LD_VAR 0 4
8389: PUSH
8390: FOR_IN
8391: IFFALSE 8441
// if not HasTask ( i ) then
8393: LD_VAR 0 1
8397: PPUSH
8398: CALL_OW 314
8402: NOT
8403: IFFALSE 8439
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8405: LD_VAR 0 1
8409: PPUSH
8410: LD_INT 81
8412: PUSH
8413: LD_INT 3
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: PPUSH
8425: LD_VAR 0 1
8429: PPUSH
8430: CALL_OW 74
8434: PPUSH
8435: CALL_OW 115
8439: GO 8390
8441: POP
8442: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8443: LD_VAR 0 4
8447: PPUSH
8448: LD_INT 50
8450: PUSH
8451: EMPTY
8452: LIST
8453: PPUSH
8454: CALL_OW 72
8458: NOT
8459: IFFALSE 8373
// end ;
8461: PPOPN 5
8463: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8464: LD_EXP 5
8468: NOT
8469: IFFALSE 9056
8471: GO 8473
8473: DISABLE
8474: LD_INT 0
8476: PPUSH
8477: PPUSH
8478: PPUSH
8479: PPUSH
// begin enable ;
8480: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8481: LD_OWVAR 67
8485: PUSH
8486: LD_INT 1
8488: EQUAL
8489: PUSH
8490: LD_OWVAR 1
8494: PUSH
8495: LD_INT 63000
8497: LESS
8498: AND
8499: IFFALSE 8503
// exit ;
8501: GO 9056
// tmp := [ ] ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// if tick < 45 45$00 then
8510: LD_OWVAR 1
8514: PUSH
8515: LD_INT 94500
8517: LESS
8518: IFFALSE 8695
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8520: LD_ADDR_VAR 0 1
8524: PUSH
8525: DOUBLE
8526: LD_INT 1
8528: DEC
8529: ST_TO_ADDR
8530: LD_INT 2
8532: PUSH
8533: LD_INT 3
8535: PUSH
8536: LD_INT 4
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PUSH
8544: LD_OWVAR 67
8548: ARRAY
8549: PUSH
8550: FOR_TO
8551: IFFALSE 8693
// begin uc_side := 3 ;
8553: LD_ADDR_OWVAR 20
8557: PUSH
8558: LD_INT 3
8560: ST_TO_ADDR
// uc_nation := 3 ;
8561: LD_ADDR_OWVAR 21
8565: PUSH
8566: LD_INT 3
8568: ST_TO_ADDR
// InitHC_All ( ) ;
8569: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_INT 1
8578: PPUSH
8579: LD_INT 5
8581: PUSH
8582: LD_INT 6
8584: PUSH
8585: LD_INT 7
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PPUSH
8599: CALL_OW 380
// un := CreateHuman ;
8603: LD_ADDR_VAR 0 2
8607: PUSH
8608: CALL_OW 44
8612: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8613: LD_VAR 0 2
8617: PPUSH
8618: LD_INT 18
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_INT 9
8635: PPUSH
8636: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8640: LD_VAR 0 2
8644: PPUSH
8645: LD_INT 147
8647: PPUSH
8648: LD_INT 161
8650: PPUSH
8651: CALL_OW 111
// wait ( 0 0$2 ) ;
8655: LD_INT 70
8657: PPUSH
8658: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8662: LD_ADDR_VAR 0 3
8666: PUSH
8667: LD_VAR 0 3
8671: PPUSH
8672: LD_VAR 0 3
8676: PUSH
8677: LD_INT 1
8679: PLUS
8680: PPUSH
8681: LD_VAR 0 2
8685: PPUSH
8686: CALL_OW 1
8690: ST_TO_ADDR
// end ;
8691: GO 8550
8693: POP
8694: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8695: LD_ADDR_VAR 0 4
8699: PUSH
8700: LD_INT 3
8702: PUSH
8703: LD_INT 4
8705: PUSH
8706: LD_INT 5
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_OWVAR 67
8718: ARRAY
8719: PUSH
8720: LD_OWVAR 1
8724: PUSH
8725: LD_INT 21000
8727: DIV
8728: PLUS
8729: ST_TO_ADDR
// if amount > 15 then
8730: LD_VAR 0 4
8734: PUSH
8735: LD_INT 15
8737: GREATER
8738: IFFALSE 8748
// amount := 15 ;
8740: LD_ADDR_VAR 0 4
8744: PUSH
8745: LD_INT 15
8747: ST_TO_ADDR
// for i := 1 to amount do
8748: LD_ADDR_VAR 0 1
8752: PUSH
8753: DOUBLE
8754: LD_INT 1
8756: DEC
8757: ST_TO_ADDR
8758: LD_VAR 0 4
8762: PUSH
8763: FOR_TO
8764: IFFALSE 8910
// begin uc_side := 3 ;
8766: LD_ADDR_OWVAR 20
8770: PUSH
8771: LD_INT 3
8773: ST_TO_ADDR
// uc_nation := 3 ;
8774: LD_ADDR_OWVAR 21
8778: PUSH
8779: LD_INT 3
8781: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8782: LD_INT 24
8784: PPUSH
8785: LD_INT 1
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: LD_INT 46
8793: PUSH
8794: LD_INT 45
8796: PUSH
8797: LD_INT 44
8799: PUSH
8800: LD_INT 43
8802: PUSH
8803: LD_INT 42
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 5
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: PPUSH
8825: LD_INT 90
8827: PPUSH
8828: CALL 16044 0 5
// un := CreateVehicle ;
8832: LD_ADDR_VAR 0 2
8836: PUSH
8837: CALL_OW 45
8841: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8842: LD_VAR 0 2
8846: PPUSH
8847: LD_INT 18
8849: PPUSH
8850: LD_INT 0
8852: PPUSH
8853: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8857: LD_VAR 0 2
8861: PPUSH
8862: LD_INT 147
8864: PPUSH
8865: LD_INT 161
8867: PPUSH
8868: CALL_OW 111
// wait ( 0 0$3 ) ;
8872: LD_INT 105
8874: PPUSH
8875: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8879: LD_ADDR_VAR 0 3
8883: PUSH
8884: LD_VAR 0 3
8888: PPUSH
8889: LD_VAR 0 3
8893: PUSH
8894: LD_INT 1
8896: PLUS
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// end ;
8908: GO 8763
8910: POP
8911: POP
// if not tmp then
8912: LD_VAR 0 3
8916: NOT
8917: IFFALSE 8921
// exit ;
8919: GO 9056
// wait ( 0 0$5 ) ;
8921: LD_INT 175
8923: PPUSH
8924: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8928: LD_INT 70
8930: PPUSH
8931: CALL_OW 67
// for i in tmp do
8935: LD_ADDR_VAR 0 1
8939: PUSH
8940: LD_VAR 0 3
8944: PUSH
8945: FOR_IN
8946: IFFALSE 9047
// begin if not IsOk ( i ) or IsDead ( i ) then
8948: LD_VAR 0 1
8952: PPUSH
8953: CALL_OW 302
8957: NOT
8958: PUSH
8959: LD_VAR 0 1
8963: PPUSH
8964: CALL_OW 301
8968: OR
8969: IFFALSE 8987
// tmp := tmp diff i ;
8971: LD_ADDR_VAR 0 3
8975: PUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 1
8985: DIFF
8986: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8987: LD_VAR 0 1
8991: PPUSH
8992: CALL_OW 257
8996: PUSH
8997: LD_INT 9
8999: EQUAL
9000: IFFALSE 9011
// ComSpaceTimeShoot ( i ) ;
9002: LD_VAR 0 1
9006: PPUSH
9007: CALL 11974 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9011: LD_VAR 0 1
9015: PPUSH
9016: LD_INT 81
9018: PUSH
9019: LD_INT 3
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: PPUSH
9031: LD_VAR 0 1
9035: PPUSH
9036: CALL_OW 74
9040: PPUSH
9041: CALL_OW 115
// end ;
9045: GO 8945
9047: POP
9048: POP
// until not tmp ;
9049: LD_VAR 0 3
9053: NOT
9054: IFFALSE 8928
// end ; end_of_file
9056: PPOPN 4
9058: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
// uc_side := 1 ;
9065: LD_ADDR_OWVAR 20
9069: PUSH
9070: LD_INT 1
9072: ST_TO_ADDR
// uc_nation := 1 ;
9073: LD_ADDR_OWVAR 21
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// hc_importance := 100 ;
9081: LD_ADDR_OWVAR 32
9085: PUSH
9086: LD_INT 100
9088: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9089: LD_ADDR_OWVAR 26
9093: PUSH
9094: LD_STRING Jeremy Sikorski
9096: ST_TO_ADDR
// hc_gallery := us ;
9097: LD_ADDR_OWVAR 33
9101: PUSH
9102: LD_STRING us
9104: ST_TO_ADDR
// hc_face_number := 19 ;
9105: LD_ADDR_OWVAR 34
9109: PUSH
9110: LD_INT 19
9112: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 4
9121: PUSH
9122: LD_INT 4
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: PUSH
9133: LD_OWVAR 67
9137: ARRAY
9138: PPUSH
9139: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9143: LD_ADDR_OWVAR 29
9147: PUSH
9148: LD_INT 10
9150: PUSH
9151: LD_INT 12
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: ST_TO_ADDR
// Sikorski := CreateHuman ;
9158: LD_ADDR_EXP 20
9162: PUSH
9163: CALL_OW 44
9167: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9168: LD_EXP 20
9172: PPUSH
9173: LD_INT 133
9175: PPUSH
9176: LD_INT 19
9178: PPUSH
9179: LD_INT 2
9181: PPUSH
9182: LD_INT 0
9184: PPUSH
9185: CALL_OW 50
// InitHc_All ( ) ;
9189: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_INT 4
9205: PUSH
9206: LD_INT 3
9208: PUSH
9209: LD_INT 3
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: LIST
9216: PUSH
9217: LD_OWVAR 67
9221: ARRAY
9222: PUSH
9223: FOR_TO
9224: IFFALSE 9340
// for j := 1 to 4 do
9226: LD_ADDR_VAR 0 3
9230: PUSH
9231: DOUBLE
9232: LD_INT 1
9234: DEC
9235: ST_TO_ADDR
9236: LD_INT 4
9238: PUSH
9239: FOR_TO
9240: IFFALSE 9336
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9242: LD_INT 0
9244: PPUSH
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 5
9252: PUSH
9253: LD_INT 4
9255: PUSH
9256: LD_INT 3
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: LIST
9263: PUSH
9264: LD_OWVAR 67
9268: ARRAY
9269: PPUSH
9270: CALL_OW 380
// un := CreateHuman ;
9274: LD_ADDR_VAR 0 4
9278: PUSH
9279: CALL_OW 44
9283: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9284: LD_VAR 0 4
9288: PPUSH
9289: LD_INT 0
9291: PPUSH
9292: LD_INT 5
9294: PPUSH
9295: CALL_OW 12
9299: PPUSH
9300: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9304: LD_VAR 0 4
9308: PPUSH
9309: LD_INT 133
9311: PPUSH
9312: LD_INT 19
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 0
9320: PPUSH
9321: CALL_OW 50
// ComHold ( un ) ;
9325: LD_VAR 0 4
9329: PPUSH
9330: CALL_OW 140
// end ;
9334: GO 9239
9336: POP
9337: POP
9338: GO 9223
9340: POP
9341: POP
// vc_chassis := us_heavy_tracked ;
9342: LD_ADDR_OWVAR 37
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// vc_engine := engine_combustion ;
9350: LD_ADDR_OWVAR 39
9354: PUSH
9355: LD_INT 1
9357: ST_TO_ADDR
// vc_control := control_manual ;
9358: LD_ADDR_OWVAR 38
9362: PUSH
9363: LD_INT 1
9365: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9366: LD_ADDR_OWVAR 40
9370: PUSH
9371: LD_INT 14
9373: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9374: LD_ADDR_OWVAR 41
9378: PUSH
9379: LD_INT 60
9381: ST_TO_ADDR
// un := CreateVehicle ;
9382: LD_ADDR_VAR 0 4
9386: PUSH
9387: CALL_OW 45
9391: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 2
9399: PPUSH
9400: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9404: LD_VAR 0 4
9408: PPUSH
9409: LD_INT 128
9411: PPUSH
9412: LD_INT 12
9414: PPUSH
9415: LD_INT 0
9417: PPUSH
9418: CALL_OW 48
// for i := 1 to 3 do
9422: LD_ADDR_VAR 0 2
9426: PUSH
9427: DOUBLE
9428: LD_INT 1
9430: DEC
9431: ST_TO_ADDR
9432: LD_INT 3
9434: PUSH
9435: FOR_TO
9436: IFFALSE 9459
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9438: LD_INT 5
9440: PPUSH
9441: LD_INT 133
9443: PPUSH
9444: LD_INT 19
9446: PPUSH
9447: LD_INT 3
9449: PPUSH
9450: LD_INT 0
9452: PPUSH
9453: CALL_OW 56
9457: GO 9435
9459: POP
9460: POP
// end ; end_of_file
9461: LD_VAR 0 1
9465: RET
// export function Action ; begin
9466: LD_INT 0
9468: PPUSH
// InGameOn ;
9469: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9473: LD_INT 133
9475: PPUSH
9476: LD_INT 19
9478: PPUSH
9479: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9483: LD_EXP 20
9487: PPUSH
9488: LD_STRING WT-DS-1
9490: PPUSH
9491: CALL_OW 88
// InGameOff ;
9495: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9499: LD_STRING DestroyEnemy
9501: PPUSH
9502: CALL_OW 337
// wait ( 0 0$20 ) ;
9506: LD_INT 700
9508: PPUSH
9509: CALL_OW 67
// DialogueOn ;
9513: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9517: LD_INT 100
9519: PPUSH
9520: LD_INT 37
9522: PPUSH
9523: LD_INT 1
9525: PPUSH
9526: LD_INT 30
9528: NEG
9529: PPUSH
9530: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9534: LD_INT 100
9536: PPUSH
9537: LD_INT 37
9539: PPUSH
9540: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9544: LD_EXP 10
9548: PPUSH
9549: LD_STRING WT-PL-1
9551: PPUSH
9552: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9556: LD_EXP 20
9560: PPUSH
9561: LD_STRING WT-DS-2
9563: PPUSH
9564: CALL_OW 88
// DialogueOff ;
9568: CALL_OW 7
// wait ( 0 0$2 ) ;
9572: LD_INT 70
9574: PPUSH
9575: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9579: LD_INT 100
9581: PPUSH
9582: LD_INT 37
9584: PPUSH
9585: LD_INT 1
9587: PPUSH
9588: CALL_OW 331
// end ;
9592: LD_VAR 0 1
9596: RET
// export function DialogPowellsAttack ; begin
9597: LD_INT 0
9599: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9600: LD_EXP 10
9604: PPUSH
9605: LD_STRING WT-PL-8
9607: PPUSH
9608: CALL_OW 94
// end ;
9612: LD_VAR 0 1
9616: RET
// export function DialogContaminateSib ( x , y ) ; begin
9617: LD_INT 0
9619: PPUSH
// DialogueOn ;
9620: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9624: LD_VAR 0 1
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9638: LD_EXP 20
9642: PPUSH
9643: LD_STRING WT-DS-3
9645: PPUSH
9646: CALL_OW 88
// DialogueOff ;
9650: CALL_OW 7
// end ;
9654: LD_VAR 0 3
9658: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9659: LD_EXP 8
9663: NOT
9664: PUSH
9665: LD_INT 1
9667: PPUSH
9668: LD_INT 81
9670: PUSH
9671: LD_INT 4
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL_OW 70
9682: PUSH
9683: LD_INT 3
9685: GREATER
9686: AND
9687: IFFALSE 9759
9689: GO 9691
9691: DISABLE
// begin powellInTrouble := true ;
9692: LD_ADDR_EXP 8
9696: PUSH
9697: LD_INT 1
9699: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9700: LD_EXP 20
9704: PPUSH
9705: LD_STRING WT-DS-6
9707: PPUSH
9708: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9712: LD_INT 1
9714: PPUSH
9715: LD_INT 22
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 70
9729: NOT
9730: IFFALSE 9744
// SayRadio ( Powell , WT-PL-6 ) ;
9732: LD_EXP 10
9736: PPUSH
9737: LD_STRING WT-PL-6
9739: PPUSH
9740: CALL_OW 94
// wait ( 1 1$30 ) ;
9744: LD_INT 3150
9746: PPUSH
9747: CALL_OW 67
// powellInTrouble := false ;
9751: LD_ADDR_EXP 8
9755: PUSH
9756: LD_INT 0
9758: ST_TO_ADDR
// end ;
9759: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9760: LD_EXP 9
9764: NOT
9765: PUSH
9766: LD_INT 16
9768: PPUSH
9769: LD_INT 81
9771: PUSH
9772: LD_INT 1
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 70
9783: PUSH
9784: LD_INT 6
9786: GREATER
9787: AND
9788: IFFALSE 9861
9790: GO 9792
9792: DISABLE
// begin sikorskiInTrouble := true ;
9793: LD_ADDR_EXP 9
9797: PUSH
9798: LD_INT 1
9800: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9801: LD_EXP 20
9805: PPUSH
9806: LD_STRING WT-DS-7
9808: PPUSH
9809: CALL_OW 88
// if not powellAttackGroup then
9813: LD_EXP 12
9817: NOT
9818: IFFALSE 9834
// SayRadio ( Powell , WT-PL-7n ) else
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-7n
9827: PPUSH
9828: CALL_OW 94
9832: GO 9846
// SayRadio ( Powell , WT-PL-7y ) ;
9834: LD_EXP 10
9838: PPUSH
9839: LD_STRING WT-PL-7y
9841: PPUSH
9842: CALL_OW 94
// wait ( 1 1$30 ) ;
9846: LD_INT 3150
9848: PPUSH
9849: CALL_OW 67
// sikorskiInTrouble := false ;
9853: LD_ADDR_EXP 9
9857: PUSH
9858: LD_INT 0
9860: ST_TO_ADDR
// end ;
9861: END
// export function DialogPowellsAttackFailed ; begin
9862: LD_INT 0
9864: PPUSH
// if not ruDestroyed then
9865: LD_EXP 5
9869: NOT
9870: IFFALSE 9886
// SayRadio ( Powell , WT-PL-9 ) else
9872: LD_EXP 10
9876: PPUSH
9877: LD_STRING WT-PL-9
9879: PPUSH
9880: CALL_OW 94
9884: GO 9898
// SayRadio ( Powell , WT-PL-10 ) ;
9886: LD_EXP 10
9890: PPUSH
9891: LD_STRING WT-PL-10
9893: PPUSH
9894: CALL_OW 94
// end ;
9898: LD_VAR 0 1
9902: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9903: LD_INT 22
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 1
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: PPUSH
9927: CALL_OW 69
9931: PUSH
9932: LD_INT 0
9934: EQUAL
9935: IFFALSE 9979
9937: GO 9939
9939: DISABLE
// begin arDestroyed := true ;
9940: LD_ADDR_EXP 4
9944: PUSH
9945: LD_INT 1
9947: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9948: LD_INT 2
9950: PPUSH
9951: CALL 52485 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9955: LD_EXP 20
9959: PPUSH
9960: LD_STRING WT-DS-4
9962: PPUSH
9963: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9967: LD_EXP 10
9971: PPUSH
9972: LD_STRING WT-PL-4
9974: PPUSH
9975: CALL_OW 94
// end ;
9979: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9980: LD_INT 22
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 21
9992: PUSH
9993: LD_INT 1
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PPUSH
10004: CALL_OW 69
10008: PUSH
10009: LD_INT 0
10011: EQUAL
10012: IFFALSE 10056
10014: GO 10016
10016: DISABLE
// begin ruDestroyed := true ;
10017: LD_ADDR_EXP 5
10021: PUSH
10022: LD_INT 1
10024: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10025: LD_INT 3
10027: PPUSH
10028: CALL 52485 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10032: LD_EXP 20
10036: PPUSH
10037: LD_STRING WT-DS-5
10039: PPUSH
10040: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10044: LD_EXP 10
10048: PPUSH
10049: LD_STRING WT-PL-5
10051: PPUSH
10052: CALL_OW 94
// end ;
10056: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10057: LD_EXP 5
10061: PUSH
10062: LD_EXP 4
10066: AND
10067: IFFALSE 10240
10069: GO 10071
10071: DISABLE
// begin wait ( 0 0$3 ) ;
10072: LD_INT 105
10074: PPUSH
10075: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10079: LD_OWVAR 1
10083: PUSH
10084: LD_INT 126000
10086: PUSH
10087: LD_INT 105000
10089: PUSH
10090: LD_INT 94500
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: PUSH
10098: LD_OWVAR 67
10102: ARRAY
10103: GREATEREQUAL
10104: IFFALSE 10119
// AddMedal ( WoT-med-1 , - 1 ) else
10106: LD_STRING WoT-med-1
10108: PPUSH
10109: LD_INT 1
10111: NEG
10112: PPUSH
10113: CALL_OW 101
10117: GO 10129
// AddMedal ( WoT-med-1 , 1 ) ;
10119: LD_STRING WoT-med-1
10121: PPUSH
10122: LD_INT 1
10124: PPUSH
10125: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10129: LD_EXP 6
10133: PUSH
10134: LD_INT 4
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 2
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_OWVAR 67
10152: ARRAY
10153: GREATEREQUAL
10154: IFFALSE 10169
// AddMedal ( WoT-med-2 , - 1 ) else
10156: LD_STRING WoT-med-2
10158: PPUSH
10159: LD_INT 1
10161: NEG
10162: PPUSH
10163: CALL_OW 101
10167: GO 10179
// AddMedal ( WoT-med-2 , 1 ) ;
10169: LD_STRING WoT-med-2
10171: PPUSH
10172: LD_INT 1
10174: PPUSH
10175: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10179: LD_EXP 7
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 5
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: LIST
10197: PUSH
10198: LD_OWVAR 67
10202: ARRAY
10203: GREATEREQUAL
10204: IFFALSE 10219
// AddMedal ( WoT-med-3 , - 1 ) else
10206: LD_STRING WoT-med-3
10208: PPUSH
10209: LD_INT 1
10211: NEG
10212: PPUSH
10213: CALL_OW 101
10217: GO 10229
// AddMedal ( WoT-med-3 , 1 ) ;
10219: LD_STRING WoT-med-3
10221: PPUSH
10222: LD_INT 1
10224: PPUSH
10225: CALL_OW 101
// GiveMedals ( MAIN ) ;
10229: LD_STRING MAIN
10231: PPUSH
10232: CALL_OW 102
// YouWin ;
10236: CALL_OW 103
// end ; end_of_file
10240: END
// export function CustomEvent ( event ) ; begin
10241: LD_INT 0
10243: PPUSH
// end ;
10244: LD_VAR 0 2
10248: RET
// on Command ( com ) do var i , j , temp ;
10249: LD_INT 0
10251: PPUSH
10252: PPUSH
10253: PPUSH
// begin if com = 60 then
10254: LD_VAR 0 1
10258: PUSH
10259: LD_INT 60
10261: EQUAL
10262: IFFALSE 10441
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10264: LD_ADDR_VAR 0 2
10268: PUSH
10269: LD_INT 22
10271: PUSH
10272: LD_INT 1
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 2
10281: PUSH
10282: LD_INT 21
10284: PUSH
10285: LD_INT 1
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 34
10294: PUSH
10295: LD_INT 12
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: EMPTY
10308: LIST
10309: LIST
10310: PPUSH
10311: CALL_OW 69
10315: PUSH
10316: FOR_IN
10317: IFFALSE 10439
// begin if GetTaskList ( i ) > 0 then
10319: LD_VAR 0 2
10323: PPUSH
10324: CALL_OW 437
10328: PUSH
10329: LD_INT 0
10331: GREATER
10332: IFFALSE 10437
// for j = 1 to GetTaskList ( i ) do
10334: LD_ADDR_VAR 0 3
10338: PUSH
10339: DOUBLE
10340: LD_INT 1
10342: DEC
10343: ST_TO_ADDR
10344: LD_VAR 0 2
10348: PPUSH
10349: CALL_OW 437
10353: PUSH
10354: FOR_TO
10355: IFFALSE 10435
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10357: LD_ADDR_VAR 0 4
10361: PUSH
10362: LD_VAR 0 2
10366: PPUSH
10367: CALL_OW 437
10371: PUSH
10372: LD_VAR 0 3
10376: ARRAY
10377: PUSH
10378: LD_INT 4
10380: ARRAY
10381: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10382: LD_VAR 0 4
10386: PPUSH
10387: CALL_OW 255
10391: PUSH
10392: LD_INT 4
10394: EQUAL
10395: PUSH
10396: LD_VAR 0 2
10400: PPUSH
10401: CALL_OW 437
10405: PUSH
10406: LD_VAR 0 3
10410: ARRAY
10411: PUSH
10412: LD_INT 1
10414: ARRAY
10415: PUSH
10416: LD_STRING <
10418: EQUAL
10419: AND
10420: IFFALSE 10433
// SetTaskList ( i , [ ] ) ;
10422: LD_VAR 0 2
10426: PPUSH
10427: EMPTY
10428: PPUSH
10429: CALL_OW 446
// end ;
10433: GO 10354
10435: POP
10436: POP
// end ;
10437: GO 10316
10439: POP
10440: POP
// end ; end ;
10441: PPOPN 4
10443: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10444: LD_VAR 0 2
10448: PPUSH
10449: LD_VAR 0 3
10453: PPUSH
10454: CALL_OW 428
10458: PPUSH
10459: CALL_OW 255
10463: PUSH
10464: LD_INT 1
10466: EQUAL
10467: PUSH
10468: LD_VAR 0 2
10472: PUSH
10473: LD_INT 132
10475: EQUAL
10476: PUSH
10477: LD_VAR 0 3
10481: PUSH
10482: LD_INT 39
10484: EQUAL
10485: AND
10486: OR
10487: IFFALSE 10503
// DialogContaminateSib ( x , y ) ;
10489: LD_VAR 0 2
10493: PPUSH
10494: LD_VAR 0 3
10498: PPUSH
10499: CALL 9617 0 2
// end ;
10503: PPOPN 3
10505: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10506: LD_VAR 0 1
10510: PPUSH
10511: CALL 90330 0 1
// MCE_UnitDestroyed ( un ) ;
10515: LD_VAR 0 1
10519: PPUSH
10520: CALL 79883 0 1
// if un = Powell then
10524: LD_VAR 0 1
10528: PUSH
10529: LD_EXP 10
10533: EQUAL
10534: IFFALSE 10543
// YouLost ( Powell ) ;
10536: LD_STRING Powell
10538: PPUSH
10539: CALL_OW 104
// if un = Sikorski then
10543: LD_VAR 0 1
10547: PUSH
10548: LD_EXP 20
10552: EQUAL
10553: IFFALSE 10562
// YouLost ( Sikorski ) ;
10555: LD_STRING Sikorski
10557: PPUSH
10558: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 22
10569: PUSH
10570: LD_INT 1
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PUSH
10577: LD_INT 21
10579: PUSH
10580: LD_INT 1
10582: PUSH
10583: EMPTY
10584: LIST
10585: LIST
10586: PUSH
10587: EMPTY
10588: LIST
10589: LIST
10590: PPUSH
10591: CALL_OW 69
10595: IN
10596: IFFALSE 10612
// loseCounter := loseCounter + 1 ;
10598: LD_ADDR_EXP 6
10602: PUSH
10603: LD_EXP 6
10607: PUSH
10608: LD_INT 1
10610: PLUS
10611: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10612: LD_VAR 0 1
10616: PUSH
10617: LD_INT 22
10619: PUSH
10620: LD_INT 4
10622: PUSH
10623: EMPTY
10624: LIST
10625: LIST
10626: PUSH
10627: LD_INT 21
10629: PUSH
10630: LD_INT 1
10632: PUSH
10633: EMPTY
10634: LIST
10635: LIST
10636: PUSH
10637: EMPTY
10638: LIST
10639: LIST
10640: PPUSH
10641: CALL_OW 69
10645: IN
10646: IFFALSE 10662
// powellLoseCounter := powellLoseCounter + 1 ;
10648: LD_ADDR_EXP 7
10652: PUSH
10653: LD_EXP 7
10657: PUSH
10658: LD_INT 1
10660: PLUS
10661: ST_TO_ADDR
// if un in powellAttackGroup then
10662: LD_VAR 0 1
10666: PUSH
10667: LD_EXP 12
10671: IN
10672: IFFALSE 10690
// powellAttackGroup := powellAttackGroup diff un ;
10674: LD_ADDR_EXP 12
10678: PUSH
10679: LD_EXP 12
10683: PUSH
10684: LD_VAR 0 1
10688: DIFF
10689: ST_TO_ADDR
// if un in gensherAttackGroup then
10690: LD_VAR 0 1
10694: PUSH
10695: LD_EXP 15
10699: IN
10700: IFFALSE 10718
// gensherAttackGroup := gensherAttackGroup diff un ;
10702: LD_ADDR_EXP 15
10706: PUSH
10707: LD_EXP 15
10711: PUSH
10712: LD_VAR 0 1
10716: DIFF
10717: ST_TO_ADDR
// if un in popovAttackGroup then
10718: LD_VAR 0 1
10722: PUSH
10723: LD_EXP 19
10727: IN
10728: IFFALSE 10746
// popovAttackGroup := popovAttackGroup diff un ;
10730: LD_ADDR_EXP 19
10734: PUSH
10735: LD_EXP 19
10739: PUSH
10740: LD_VAR 0 1
10744: DIFF
10745: ST_TO_ADDR
// end ;
10746: PPOPN 1
10748: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10749: LD_VAR 0 1
10753: PPUSH
10754: LD_VAR 0 2
10758: PPUSH
10759: CALL 82217 0 2
// end ;
10763: PPOPN 2
10765: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10766: LD_VAR 0 1
10770: PPUSH
10771: CALL 81285 0 1
// end ;
10775: PPOPN 1
10777: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10778: LD_VAR 0 1
10782: PPUSH
10783: CALL 81526 0 1
// end ;
10787: PPOPN 1
10789: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10790: LD_VAR 0 1
10794: PPUSH
10795: LD_VAR 0 2
10799: PPUSH
10800: CALL 79579 0 2
// end ;
10804: PPOPN 2
10806: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10807: LD_VAR 0 1
10811: PPUSH
10812: LD_VAR 0 2
10816: PPUSH
10817: LD_VAR 0 3
10821: PPUSH
10822: LD_VAR 0 4
10826: PPUSH
10827: LD_VAR 0 5
10831: PPUSH
10832: CALL 79199 0 5
// end ;
10836: PPOPN 5
10838: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10839: LD_VAR 0 1
10843: PPUSH
10844: LD_VAR 0 2
10848: PPUSH
10849: CALL 90452 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10853: LD_VAR 0 1
10857: PPUSH
10858: LD_VAR 0 2
10862: PPUSH
10863: CALL 78780 0 2
// end ;
10867: PPOPN 2
10869: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10870: LD_VAR 0 1
10874: PPUSH
10875: LD_VAR 0 2
10879: PPUSH
10880: LD_VAR 0 3
10884: PPUSH
10885: LD_VAR 0 4
10889: PPUSH
10890: CALL 78618 0 4
// end ;
10894: PPOPN 4
10896: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10897: LD_VAR 0 1
10901: PPUSH
10902: LD_VAR 0 2
10906: PPUSH
10907: LD_VAR 0 3
10911: PPUSH
10912: CALL 78393 0 3
// end ;
10916: PPOPN 3
10918: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10919: LD_VAR 0 1
10923: PPUSH
10924: LD_VAR 0 2
10928: PPUSH
10929: CALL 78278 0 2
// end ;
10933: PPOPN 2
10935: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10936: LD_VAR 0 1
10940: PPUSH
10941: LD_VAR 0 2
10945: PPUSH
10946: CALL 82512 0 2
// end ;
10950: PPOPN 2
10952: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10953: LD_VAR 0 1
10957: PPUSH
10958: LD_VAR 0 2
10962: PPUSH
10963: LD_VAR 0 3
10967: PPUSH
10968: LD_VAR 0 4
10972: PPUSH
10973: CALL 82728 0 4
// end ;
10977: PPOPN 4
10979: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10980: LD_VAR 0 1
10984: PPUSH
10985: LD_VAR 0 2
10989: PPUSH
10990: CALL 78087 0 2
// end ;
10994: PPOPN 2
10996: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10997: LD_VAR 0 1
11001: PUSH
11002: LD_INT 1
11004: EQUAL
11005: PUSH
11006: LD_VAR 0 2
11010: PUSH
11011: LD_INT 4
11013: EQUAL
11014: AND
11015: IFFALSE 11024
// YouLost ( FriendlyFire ) ;
11017: LD_STRING FriendlyFire
11019: PPUSH
11020: CALL_OW 104
// end ; end_of_file
11024: PPOPN 2
11026: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11027: LD_INT 0
11029: PPUSH
11030: PPUSH
// if exist_mode then
11031: LD_VAR 0 2
11035: IFFALSE 11060
// unit := CreateCharacter ( prefix & ident ) else
11037: LD_ADDR_VAR 0 5
11041: PUSH
11042: LD_VAR 0 3
11046: PUSH
11047: LD_VAR 0 1
11051: STR
11052: PPUSH
11053: CALL_OW 34
11057: ST_TO_ADDR
11058: GO 11075
// unit := NewCharacter ( ident ) ;
11060: LD_ADDR_VAR 0 5
11064: PUSH
11065: LD_VAR 0 1
11069: PPUSH
11070: CALL_OW 25
11074: ST_TO_ADDR
// result := unit ;
11075: LD_ADDR_VAR 0 4
11079: PUSH
11080: LD_VAR 0 5
11084: ST_TO_ADDR
// end ;
11085: LD_VAR 0 4
11089: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11090: LD_INT 0
11092: PPUSH
11093: PPUSH
// if not side or not nation then
11094: LD_VAR 0 1
11098: NOT
11099: PUSH
11100: LD_VAR 0 2
11104: NOT
11105: OR
11106: IFFALSE 11110
// exit ;
11108: GO 11878
// case nation of nation_american :
11110: LD_VAR 0 2
11114: PUSH
11115: LD_INT 1
11117: DOUBLE
11118: EQUAL
11119: IFTRUE 11123
11121: GO 11337
11123: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11124: LD_ADDR_VAR 0 4
11128: PUSH
11129: LD_INT 35
11131: PUSH
11132: LD_INT 45
11134: PUSH
11135: LD_INT 46
11137: PUSH
11138: LD_INT 47
11140: PUSH
11141: LD_INT 82
11143: PUSH
11144: LD_INT 83
11146: PUSH
11147: LD_INT 84
11149: PUSH
11150: LD_INT 85
11152: PUSH
11153: LD_INT 86
11155: PUSH
11156: LD_INT 1
11158: PUSH
11159: LD_INT 2
11161: PUSH
11162: LD_INT 6
11164: PUSH
11165: LD_INT 15
11167: PUSH
11168: LD_INT 16
11170: PUSH
11171: LD_INT 7
11173: PUSH
11174: LD_INT 12
11176: PUSH
11177: LD_INT 13
11179: PUSH
11180: LD_INT 10
11182: PUSH
11183: LD_INT 14
11185: PUSH
11186: LD_INT 20
11188: PUSH
11189: LD_INT 21
11191: PUSH
11192: LD_INT 22
11194: PUSH
11195: LD_INT 25
11197: PUSH
11198: LD_INT 32
11200: PUSH
11201: LD_INT 27
11203: PUSH
11204: LD_INT 36
11206: PUSH
11207: LD_INT 69
11209: PUSH
11210: LD_INT 39
11212: PUSH
11213: LD_INT 34
11215: PUSH
11216: LD_INT 40
11218: PUSH
11219: LD_INT 48
11221: PUSH
11222: LD_INT 49
11224: PUSH
11225: LD_INT 50
11227: PUSH
11228: LD_INT 51
11230: PUSH
11231: LD_INT 52
11233: PUSH
11234: LD_INT 53
11236: PUSH
11237: LD_INT 54
11239: PUSH
11240: LD_INT 55
11242: PUSH
11243: LD_INT 56
11245: PUSH
11246: LD_INT 57
11248: PUSH
11249: LD_INT 58
11251: PUSH
11252: LD_INT 59
11254: PUSH
11255: LD_INT 60
11257: PUSH
11258: LD_INT 61
11260: PUSH
11261: LD_INT 62
11263: PUSH
11264: LD_INT 80
11266: PUSH
11267: LD_INT 82
11269: PUSH
11270: LD_INT 83
11272: PUSH
11273: LD_INT 84
11275: PUSH
11276: LD_INT 85
11278: PUSH
11279: LD_INT 86
11281: PUSH
11282: EMPTY
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: LIST
11312: LIST
11313: LIST
11314: LIST
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: LIST
11320: LIST
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: LIST
11330: LIST
11331: LIST
11332: LIST
11333: LIST
11334: ST_TO_ADDR
11335: GO 11802
11337: LD_INT 2
11339: DOUBLE
11340: EQUAL
11341: IFTRUE 11345
11343: GO 11571
11345: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11346: LD_ADDR_VAR 0 4
11350: PUSH
11351: LD_INT 35
11353: PUSH
11354: LD_INT 45
11356: PUSH
11357: LD_INT 46
11359: PUSH
11360: LD_INT 47
11362: PUSH
11363: LD_INT 82
11365: PUSH
11366: LD_INT 83
11368: PUSH
11369: LD_INT 84
11371: PUSH
11372: LD_INT 85
11374: PUSH
11375: LD_INT 87
11377: PUSH
11378: LD_INT 70
11380: PUSH
11381: LD_INT 1
11383: PUSH
11384: LD_INT 11
11386: PUSH
11387: LD_INT 3
11389: PUSH
11390: LD_INT 4
11392: PUSH
11393: LD_INT 5
11395: PUSH
11396: LD_INT 6
11398: PUSH
11399: LD_INT 15
11401: PUSH
11402: LD_INT 18
11404: PUSH
11405: LD_INT 7
11407: PUSH
11408: LD_INT 17
11410: PUSH
11411: LD_INT 8
11413: PUSH
11414: LD_INT 20
11416: PUSH
11417: LD_INT 21
11419: PUSH
11420: LD_INT 22
11422: PUSH
11423: LD_INT 72
11425: PUSH
11426: LD_INT 26
11428: PUSH
11429: LD_INT 69
11431: PUSH
11432: LD_INT 39
11434: PUSH
11435: LD_INT 40
11437: PUSH
11438: LD_INT 41
11440: PUSH
11441: LD_INT 42
11443: PUSH
11444: LD_INT 43
11446: PUSH
11447: LD_INT 48
11449: PUSH
11450: LD_INT 49
11452: PUSH
11453: LD_INT 50
11455: PUSH
11456: LD_INT 51
11458: PUSH
11459: LD_INT 52
11461: PUSH
11462: LD_INT 53
11464: PUSH
11465: LD_INT 54
11467: PUSH
11468: LD_INT 55
11470: PUSH
11471: LD_INT 56
11473: PUSH
11474: LD_INT 60
11476: PUSH
11477: LD_INT 61
11479: PUSH
11480: LD_INT 62
11482: PUSH
11483: LD_INT 66
11485: PUSH
11486: LD_INT 67
11488: PUSH
11489: LD_INT 68
11491: PUSH
11492: LD_INT 81
11494: PUSH
11495: LD_INT 82
11497: PUSH
11498: LD_INT 83
11500: PUSH
11501: LD_INT 84
11503: PUSH
11504: LD_INT 85
11506: PUSH
11507: LD_INT 87
11509: PUSH
11510: LD_INT 88
11512: PUSH
11513: EMPTY
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: LIST
11553: LIST
11554: LIST
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: LIST
11560: LIST
11561: LIST
11562: LIST
11563: LIST
11564: LIST
11565: LIST
11566: LIST
11567: LIST
11568: ST_TO_ADDR
11569: GO 11802
11571: LD_INT 3
11573: DOUBLE
11574: EQUAL
11575: IFTRUE 11579
11577: GO 11801
11579: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11580: LD_ADDR_VAR 0 4
11584: PUSH
11585: LD_INT 46
11587: PUSH
11588: LD_INT 47
11590: PUSH
11591: LD_INT 1
11593: PUSH
11594: LD_INT 2
11596: PUSH
11597: LD_INT 82
11599: PUSH
11600: LD_INT 83
11602: PUSH
11603: LD_INT 84
11605: PUSH
11606: LD_INT 85
11608: PUSH
11609: LD_INT 86
11611: PUSH
11612: LD_INT 11
11614: PUSH
11615: LD_INT 9
11617: PUSH
11618: LD_INT 20
11620: PUSH
11621: LD_INT 19
11623: PUSH
11624: LD_INT 21
11626: PUSH
11627: LD_INT 24
11629: PUSH
11630: LD_INT 22
11632: PUSH
11633: LD_INT 25
11635: PUSH
11636: LD_INT 28
11638: PUSH
11639: LD_INT 29
11641: PUSH
11642: LD_INT 30
11644: PUSH
11645: LD_INT 31
11647: PUSH
11648: LD_INT 37
11650: PUSH
11651: LD_INT 38
11653: PUSH
11654: LD_INT 32
11656: PUSH
11657: LD_INT 27
11659: PUSH
11660: LD_INT 33
11662: PUSH
11663: LD_INT 69
11665: PUSH
11666: LD_INT 39
11668: PUSH
11669: LD_INT 34
11671: PUSH
11672: LD_INT 40
11674: PUSH
11675: LD_INT 71
11677: PUSH
11678: LD_INT 23
11680: PUSH
11681: LD_INT 44
11683: PUSH
11684: LD_INT 48
11686: PUSH
11687: LD_INT 49
11689: PUSH
11690: LD_INT 50
11692: PUSH
11693: LD_INT 51
11695: PUSH
11696: LD_INT 52
11698: PUSH
11699: LD_INT 53
11701: PUSH
11702: LD_INT 54
11704: PUSH
11705: LD_INT 55
11707: PUSH
11708: LD_INT 56
11710: PUSH
11711: LD_INT 57
11713: PUSH
11714: LD_INT 58
11716: PUSH
11717: LD_INT 59
11719: PUSH
11720: LD_INT 63
11722: PUSH
11723: LD_INT 64
11725: PUSH
11726: LD_INT 65
11728: PUSH
11729: LD_INT 82
11731: PUSH
11732: LD_INT 83
11734: PUSH
11735: LD_INT 84
11737: PUSH
11738: LD_INT 85
11740: PUSH
11741: LD_INT 86
11743: PUSH
11744: EMPTY
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: LIST
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: ST_TO_ADDR
11799: GO 11802
11801: POP
// if state > - 1 and state < 3 then
11802: LD_VAR 0 3
11806: PUSH
11807: LD_INT 1
11809: NEG
11810: GREATER
11811: PUSH
11812: LD_VAR 0 3
11816: PUSH
11817: LD_INT 3
11819: LESS
11820: AND
11821: IFFALSE 11878
// for i in result do
11823: LD_ADDR_VAR 0 5
11827: PUSH
11828: LD_VAR 0 4
11832: PUSH
11833: FOR_IN
11834: IFFALSE 11876
// if GetTech ( i , side ) <> state then
11836: LD_VAR 0 5
11840: PPUSH
11841: LD_VAR 0 1
11845: PPUSH
11846: CALL_OW 321
11850: PUSH
11851: LD_VAR 0 3
11855: NONEQUAL
11856: IFFALSE 11874
// result := result diff i ;
11858: LD_ADDR_VAR 0 4
11862: PUSH
11863: LD_VAR 0 4
11867: PUSH
11868: LD_VAR 0 5
11872: DIFF
11873: ST_TO_ADDR
11874: GO 11833
11876: POP
11877: POP
// end ;
11878: LD_VAR 0 4
11882: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11883: LD_INT 0
11885: PPUSH
11886: PPUSH
11887: PPUSH
// result := true ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_INT 1
11895: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11896: LD_ADDR_VAR 0 5
11900: PUSH
11901: LD_VAR 0 2
11905: PPUSH
11906: CALL_OW 480
11910: ST_TO_ADDR
// if not tmp then
11911: LD_VAR 0 5
11915: NOT
11916: IFFALSE 11920
// exit ;
11918: GO 11969
// for i in tmp do
11920: LD_ADDR_VAR 0 4
11924: PUSH
11925: LD_VAR 0 5
11929: PUSH
11930: FOR_IN
11931: IFFALSE 11967
// if GetTech ( i , side ) <> state_researched then
11933: LD_VAR 0 4
11937: PPUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 321
11947: PUSH
11948: LD_INT 2
11950: NONEQUAL
11951: IFFALSE 11965
// begin result := false ;
11953: LD_ADDR_VAR 0 3
11957: PUSH
11958: LD_INT 0
11960: ST_TO_ADDR
// exit ;
11961: POP
11962: POP
11963: GO 11969
// end ;
11965: GO 11930
11967: POP
11968: POP
// end ;
11969: LD_VAR 0 3
11973: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11974: LD_INT 0
11976: PPUSH
11977: PPUSH
11978: PPUSH
11979: PPUSH
11980: PPUSH
11981: PPUSH
11982: PPUSH
11983: PPUSH
11984: PPUSH
11985: PPUSH
11986: PPUSH
11987: PPUSH
11988: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11989: LD_VAR 0 1
11993: NOT
11994: PUSH
11995: LD_VAR 0 1
11999: PPUSH
12000: CALL_OW 257
12004: PUSH
12005: LD_INT 9
12007: NONEQUAL
12008: OR
12009: IFFALSE 12013
// exit ;
12011: GO 12586
// side := GetSide ( unit ) ;
12013: LD_ADDR_VAR 0 9
12017: PUSH
12018: LD_VAR 0 1
12022: PPUSH
12023: CALL_OW 255
12027: ST_TO_ADDR
// tech_space := tech_spacanom ;
12028: LD_ADDR_VAR 0 12
12032: PUSH
12033: LD_INT 29
12035: ST_TO_ADDR
// tech_time := tech_taurad ;
12036: LD_ADDR_VAR 0 13
12040: PUSH
12041: LD_INT 28
12043: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12044: LD_ADDR_VAR 0 11
12048: PUSH
12049: LD_VAR 0 1
12053: PPUSH
12054: CALL_OW 310
12058: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12059: LD_VAR 0 11
12063: PPUSH
12064: CALL_OW 247
12068: PUSH
12069: LD_INT 2
12071: EQUAL
12072: IFFALSE 12076
// exit ;
12074: GO 12586
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12076: LD_ADDR_VAR 0 8
12080: PUSH
12081: LD_INT 81
12083: PUSH
12084: LD_VAR 0 9
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PUSH
12093: LD_INT 3
12095: PUSH
12096: LD_INT 21
12098: PUSH
12099: LD_INT 3
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: EMPTY
12111: LIST
12112: LIST
12113: PPUSH
12114: CALL_OW 69
12118: ST_TO_ADDR
// if not tmp then
12119: LD_VAR 0 8
12123: NOT
12124: IFFALSE 12128
// exit ;
12126: GO 12586
// if in_unit then
12128: LD_VAR 0 11
12132: IFFALSE 12156
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12134: LD_ADDR_VAR 0 10
12138: PUSH
12139: LD_VAR 0 8
12143: PPUSH
12144: LD_VAR 0 11
12148: PPUSH
12149: CALL_OW 74
12153: ST_TO_ADDR
12154: GO 12176
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12156: LD_ADDR_VAR 0 10
12160: PUSH
12161: LD_VAR 0 8
12165: PPUSH
12166: LD_VAR 0 1
12170: PPUSH
12171: CALL_OW 74
12175: ST_TO_ADDR
// if not enemy then
12176: LD_VAR 0 10
12180: NOT
12181: IFFALSE 12185
// exit ;
12183: GO 12586
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12185: LD_VAR 0 11
12189: PUSH
12190: LD_VAR 0 11
12194: PPUSH
12195: LD_VAR 0 10
12199: PPUSH
12200: CALL_OW 296
12204: PUSH
12205: LD_INT 13
12207: GREATER
12208: AND
12209: PUSH
12210: LD_VAR 0 1
12214: PPUSH
12215: LD_VAR 0 10
12219: PPUSH
12220: CALL_OW 296
12224: PUSH
12225: LD_INT 12
12227: GREATER
12228: OR
12229: IFFALSE 12233
// exit ;
12231: GO 12586
// missile := [ 1 ] ;
12233: LD_ADDR_VAR 0 14
12237: PUSH
12238: LD_INT 1
12240: PUSH
12241: EMPTY
12242: LIST
12243: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12244: LD_VAR 0 9
12248: PPUSH
12249: LD_VAR 0 12
12253: PPUSH
12254: CALL_OW 325
12258: IFFALSE 12287
// missile := Replace ( missile , missile + 1 , 2 ) ;
12260: LD_ADDR_VAR 0 14
12264: PUSH
12265: LD_VAR 0 14
12269: PPUSH
12270: LD_VAR 0 14
12274: PUSH
12275: LD_INT 1
12277: PLUS
12278: PPUSH
12279: LD_INT 2
12281: PPUSH
12282: CALL_OW 1
12286: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12287: LD_VAR 0 9
12291: PPUSH
12292: LD_VAR 0 13
12296: PPUSH
12297: CALL_OW 325
12301: PUSH
12302: LD_VAR 0 10
12306: PPUSH
12307: CALL_OW 255
12311: PPUSH
12312: LD_VAR 0 13
12316: PPUSH
12317: CALL_OW 325
12321: NOT
12322: AND
12323: IFFALSE 12352
// missile := Replace ( missile , missile + 1 , 3 ) ;
12325: LD_ADDR_VAR 0 14
12329: PUSH
12330: LD_VAR 0 14
12334: PPUSH
12335: LD_VAR 0 14
12339: PUSH
12340: LD_INT 1
12342: PLUS
12343: PPUSH
12344: LD_INT 3
12346: PPUSH
12347: CALL_OW 1
12351: ST_TO_ADDR
// if missile < 2 then
12352: LD_VAR 0 14
12356: PUSH
12357: LD_INT 2
12359: LESS
12360: IFFALSE 12364
// exit ;
12362: GO 12586
// x := GetX ( enemy ) ;
12364: LD_ADDR_VAR 0 4
12368: PUSH
12369: LD_VAR 0 10
12373: PPUSH
12374: CALL_OW 250
12378: ST_TO_ADDR
// y := GetY ( enemy ) ;
12379: LD_ADDR_VAR 0 5
12383: PUSH
12384: LD_VAR 0 10
12388: PPUSH
12389: CALL_OW 251
12393: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12394: LD_ADDR_VAR 0 6
12398: PUSH
12399: LD_VAR 0 4
12403: PUSH
12404: LD_INT 1
12406: NEG
12407: PPUSH
12408: LD_INT 1
12410: PPUSH
12411: CALL_OW 12
12415: PLUS
12416: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12417: LD_ADDR_VAR 0 7
12421: PUSH
12422: LD_VAR 0 5
12426: PUSH
12427: LD_INT 1
12429: NEG
12430: PPUSH
12431: LD_INT 1
12433: PPUSH
12434: CALL_OW 12
12438: PLUS
12439: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12440: LD_VAR 0 6
12444: PPUSH
12445: LD_VAR 0 7
12449: PPUSH
12450: CALL_OW 488
12454: NOT
12455: IFFALSE 12477
// begin _x := x ;
12457: LD_ADDR_VAR 0 6
12461: PUSH
12462: LD_VAR 0 4
12466: ST_TO_ADDR
// _y := y ;
12467: LD_ADDR_VAR 0 7
12471: PUSH
12472: LD_VAR 0 5
12476: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12477: LD_ADDR_VAR 0 3
12481: PUSH
12482: LD_INT 1
12484: PPUSH
12485: LD_VAR 0 14
12489: PPUSH
12490: CALL_OW 12
12494: ST_TO_ADDR
// case i of 1 :
12495: LD_VAR 0 3
12499: PUSH
12500: LD_INT 1
12502: DOUBLE
12503: EQUAL
12504: IFTRUE 12508
12506: GO 12525
12508: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12509: LD_VAR 0 1
12513: PPUSH
12514: LD_VAR 0 10
12518: PPUSH
12519: CALL_OW 115
12523: GO 12586
12525: LD_INT 2
12527: DOUBLE
12528: EQUAL
12529: IFTRUE 12533
12531: GO 12555
12533: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12534: LD_VAR 0 1
12538: PPUSH
12539: LD_VAR 0 6
12543: PPUSH
12544: LD_VAR 0 7
12548: PPUSH
12549: CALL_OW 153
12553: GO 12586
12555: LD_INT 3
12557: DOUBLE
12558: EQUAL
12559: IFTRUE 12563
12561: GO 12585
12563: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12564: LD_VAR 0 1
12568: PPUSH
12569: LD_VAR 0 6
12573: PPUSH
12574: LD_VAR 0 7
12578: PPUSH
12579: CALL_OW 154
12583: GO 12586
12585: POP
// end ;
12586: LD_VAR 0 2
12590: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12591: LD_INT 0
12593: PPUSH
12594: PPUSH
12595: PPUSH
12596: PPUSH
12597: PPUSH
12598: PPUSH
// if not unit or not building then
12599: LD_VAR 0 1
12603: NOT
12604: PUSH
12605: LD_VAR 0 2
12609: NOT
12610: OR
12611: IFFALSE 12615
// exit ;
12613: GO 12773
// x := GetX ( building ) ;
12615: LD_ADDR_VAR 0 5
12619: PUSH
12620: LD_VAR 0 2
12624: PPUSH
12625: CALL_OW 250
12629: ST_TO_ADDR
// y := GetY ( building ) ;
12630: LD_ADDR_VAR 0 6
12634: PUSH
12635: LD_VAR 0 2
12639: PPUSH
12640: CALL_OW 251
12644: ST_TO_ADDR
// for i = 0 to 5 do
12645: LD_ADDR_VAR 0 4
12649: PUSH
12650: DOUBLE
12651: LD_INT 0
12653: DEC
12654: ST_TO_ADDR
12655: LD_INT 5
12657: PUSH
12658: FOR_TO
12659: IFFALSE 12771
// begin _x := ShiftX ( x , i , 3 ) ;
12661: LD_ADDR_VAR 0 7
12665: PUSH
12666: LD_VAR 0 5
12670: PPUSH
12671: LD_VAR 0 4
12675: PPUSH
12676: LD_INT 3
12678: PPUSH
12679: CALL_OW 272
12683: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12684: LD_ADDR_VAR 0 8
12688: PUSH
12689: LD_VAR 0 6
12693: PPUSH
12694: LD_VAR 0 4
12698: PPUSH
12699: LD_INT 3
12701: PPUSH
12702: CALL_OW 273
12706: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12707: LD_VAR 0 7
12711: PPUSH
12712: LD_VAR 0 8
12716: PPUSH
12717: CALL_OW 488
12721: NOT
12722: IFFALSE 12726
// continue ;
12724: GO 12658
// if HexInfo ( _x , _y ) = 0 then
12726: LD_VAR 0 7
12730: PPUSH
12731: LD_VAR 0 8
12735: PPUSH
12736: CALL_OW 428
12740: PUSH
12741: LD_INT 0
12743: EQUAL
12744: IFFALSE 12769
// begin ComMoveXY ( unit , _x , _y ) ;
12746: LD_VAR 0 1
12750: PPUSH
12751: LD_VAR 0 7
12755: PPUSH
12756: LD_VAR 0 8
12760: PPUSH
12761: CALL_OW 111
// exit ;
12765: POP
12766: POP
12767: GO 12773
// end ; end ;
12769: GO 12658
12771: POP
12772: POP
// end ;
12773: LD_VAR 0 3
12777: RET
// export function ScanBase ( side , base_area ) ; begin
12778: LD_INT 0
12780: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12781: LD_ADDR_VAR 0 3
12785: PUSH
12786: LD_VAR 0 2
12790: PPUSH
12791: LD_INT 81
12793: PUSH
12794: LD_VAR 0 1
12798: PUSH
12799: EMPTY
12800: LIST
12801: LIST
12802: PPUSH
12803: CALL_OW 70
12807: ST_TO_ADDR
// end ;
12808: LD_VAR 0 3
12812: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12813: LD_INT 0
12815: PPUSH
12816: PPUSH
12817: PPUSH
12818: PPUSH
// result := false ;
12819: LD_ADDR_VAR 0 2
12823: PUSH
12824: LD_INT 0
12826: ST_TO_ADDR
// side := GetSide ( unit ) ;
12827: LD_ADDR_VAR 0 3
12831: PUSH
12832: LD_VAR 0 1
12836: PPUSH
12837: CALL_OW 255
12841: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12842: LD_ADDR_VAR 0 4
12846: PUSH
12847: LD_VAR 0 1
12851: PPUSH
12852: CALL_OW 248
12856: ST_TO_ADDR
// case nat of 1 :
12857: LD_VAR 0 4
12861: PUSH
12862: LD_INT 1
12864: DOUBLE
12865: EQUAL
12866: IFTRUE 12870
12868: GO 12881
12870: POP
// tech := tech_lassight ; 2 :
12871: LD_ADDR_VAR 0 5
12875: PUSH
12876: LD_INT 12
12878: ST_TO_ADDR
12879: GO 12920
12881: LD_INT 2
12883: DOUBLE
12884: EQUAL
12885: IFTRUE 12889
12887: GO 12900
12889: POP
// tech := tech_mortar ; 3 :
12890: LD_ADDR_VAR 0 5
12894: PUSH
12895: LD_INT 41
12897: ST_TO_ADDR
12898: GO 12920
12900: LD_INT 3
12902: DOUBLE
12903: EQUAL
12904: IFTRUE 12908
12906: GO 12919
12908: POP
// tech := tech_bazooka ; end ;
12909: LD_ADDR_VAR 0 5
12913: PUSH
12914: LD_INT 44
12916: ST_TO_ADDR
12917: GO 12920
12919: POP
// if Researched ( side , tech ) then
12920: LD_VAR 0 3
12924: PPUSH
12925: LD_VAR 0 5
12929: PPUSH
12930: CALL_OW 325
12934: IFFALSE 12961
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12936: LD_ADDR_VAR 0 2
12940: PUSH
12941: LD_INT 5
12943: PUSH
12944: LD_INT 8
12946: PUSH
12947: LD_INT 9
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: LIST
12954: PUSH
12955: LD_VAR 0 4
12959: ARRAY
12960: ST_TO_ADDR
// end ;
12961: LD_VAR 0 2
12965: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12966: LD_INT 0
12968: PPUSH
12969: PPUSH
12970: PPUSH
// if not mines then
12971: LD_VAR 0 2
12975: NOT
12976: IFFALSE 12980
// exit ;
12978: GO 13124
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12980: LD_ADDR_VAR 0 5
12984: PUSH
12985: LD_INT 81
12987: PUSH
12988: LD_VAR 0 1
12992: PUSH
12993: EMPTY
12994: LIST
12995: LIST
12996: PUSH
12997: LD_INT 3
12999: PUSH
13000: LD_INT 21
13002: PUSH
13003: LD_INT 3
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PUSH
13010: EMPTY
13011: LIST
13012: LIST
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: PPUSH
13018: CALL_OW 69
13022: ST_TO_ADDR
// for i in mines do
13023: LD_ADDR_VAR 0 4
13027: PUSH
13028: LD_VAR 0 2
13032: PUSH
13033: FOR_IN
13034: IFFALSE 13122
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13036: LD_VAR 0 4
13040: PUSH
13041: LD_INT 1
13043: ARRAY
13044: PPUSH
13045: LD_VAR 0 4
13049: PUSH
13050: LD_INT 2
13052: ARRAY
13053: PPUSH
13054: CALL_OW 458
13058: NOT
13059: IFFALSE 13063
// continue ;
13061: GO 13033
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13063: LD_VAR 0 4
13067: PUSH
13068: LD_INT 1
13070: ARRAY
13071: PPUSH
13072: LD_VAR 0 4
13076: PUSH
13077: LD_INT 2
13079: ARRAY
13080: PPUSH
13081: CALL_OW 428
13085: PUSH
13086: LD_VAR 0 5
13090: IN
13091: IFFALSE 13120
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13093: LD_VAR 0 4
13097: PUSH
13098: LD_INT 1
13100: ARRAY
13101: PPUSH
13102: LD_VAR 0 4
13106: PUSH
13107: LD_INT 2
13109: ARRAY
13110: PPUSH
13111: LD_VAR 0 1
13115: PPUSH
13116: CALL_OW 456
// end ;
13120: GO 13033
13122: POP
13123: POP
// end ;
13124: LD_VAR 0 3
13128: RET
// export function Count ( array ) ; var i ; begin
13129: LD_INT 0
13131: PPUSH
13132: PPUSH
// result := 0 ;
13133: LD_ADDR_VAR 0 2
13137: PUSH
13138: LD_INT 0
13140: ST_TO_ADDR
// for i in array do
13141: LD_ADDR_VAR 0 3
13145: PUSH
13146: LD_VAR 0 1
13150: PUSH
13151: FOR_IN
13152: IFFALSE 13176
// if i then
13154: LD_VAR 0 3
13158: IFFALSE 13174
// result := result + 1 ;
13160: LD_ADDR_VAR 0 2
13164: PUSH
13165: LD_VAR 0 2
13169: PUSH
13170: LD_INT 1
13172: PLUS
13173: ST_TO_ADDR
13174: GO 13151
13176: POP
13177: POP
// end ;
13178: LD_VAR 0 2
13182: RET
// export function IsEmpty ( building ) ; begin
13183: LD_INT 0
13185: PPUSH
// if not building then
13186: LD_VAR 0 1
13190: NOT
13191: IFFALSE 13195
// exit ;
13193: GO 13238
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13195: LD_ADDR_VAR 0 2
13199: PUSH
13200: LD_VAR 0 1
13204: PUSH
13205: LD_INT 22
13207: PUSH
13208: LD_VAR 0 1
13212: PPUSH
13213: CALL_OW 255
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: LD_INT 58
13224: PUSH
13225: EMPTY
13226: LIST
13227: PUSH
13228: EMPTY
13229: LIST
13230: LIST
13231: PPUSH
13232: CALL_OW 69
13236: IN
13237: ST_TO_ADDR
// end ;
13238: LD_VAR 0 2
13242: RET
// export function IsNotFull ( building ) ; var places ; begin
13243: LD_INT 0
13245: PPUSH
13246: PPUSH
// if not building then
13247: LD_VAR 0 1
13251: NOT
13252: IFFALSE 13256
// exit ;
13254: GO 13427
// result := false ;
13256: LD_ADDR_VAR 0 2
13260: PUSH
13261: LD_INT 0
13263: ST_TO_ADDR
// places := 0 ;
13264: LD_ADDR_VAR 0 3
13268: PUSH
13269: LD_INT 0
13271: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
13272: LD_VAR 0 1
13276: PPUSH
13277: CALL_OW 266
13281: PUSH
13282: LD_INT 0
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13344
13288: LD_INT 1
13290: DOUBLE
13291: EQUAL
13292: IFTRUE 13344
13294: LD_INT 6
13296: DOUBLE
13297: EQUAL
13298: IFTRUE 13344
13300: LD_INT 7
13302: DOUBLE
13303: EQUAL
13304: IFTRUE 13344
13306: LD_INT 8
13308: DOUBLE
13309: EQUAL
13310: IFTRUE 13344
13312: LD_INT 4
13314: DOUBLE
13315: EQUAL
13316: IFTRUE 13344
13318: LD_INT 5
13320: DOUBLE
13321: EQUAL
13322: IFTRUE 13344
13324: LD_INT 2
13326: DOUBLE
13327: EQUAL
13328: IFTRUE 13344
13330: LD_INT 3
13332: DOUBLE
13333: EQUAL
13334: IFTRUE 13344
13336: LD_INT 35
13338: DOUBLE
13339: EQUAL
13340: IFTRUE 13344
13342: GO 13355
13344: POP
// places := 6 ; b_bunker , b_breastwork :
13345: LD_ADDR_VAR 0 3
13349: PUSH
13350: LD_INT 6
13352: ST_TO_ADDR
13353: GO 13400
13355: LD_INT 32
13357: DOUBLE
13358: EQUAL
13359: IFTRUE 13369
13361: LD_INT 31
13363: DOUBLE
13364: EQUAL
13365: IFTRUE 13369
13367: GO 13380
13369: POP
// places := 1 ; b_control_tower :
13370: LD_ADDR_VAR 0 3
13374: PUSH
13375: LD_INT 1
13377: ST_TO_ADDR
13378: GO 13400
13380: LD_INT 36
13382: DOUBLE
13383: EQUAL
13384: IFTRUE 13388
13386: GO 13399
13388: POP
// places := 3 ; end ;
13389: LD_ADDR_VAR 0 3
13393: PUSH
13394: LD_INT 3
13396: ST_TO_ADDR
13397: GO 13400
13399: POP
// if places then
13400: LD_VAR 0 3
13404: IFFALSE 13427
// result := UnitsInside ( building ) < places ;
13406: LD_ADDR_VAR 0 2
13410: PUSH
13411: LD_VAR 0 1
13415: PPUSH
13416: CALL_OW 313
13420: PUSH
13421: LD_VAR 0 3
13425: LESS
13426: ST_TO_ADDR
// end ;
13427: LD_VAR 0 2
13431: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13432: LD_INT 0
13434: PPUSH
13435: PPUSH
13436: PPUSH
13437: PPUSH
// tmp := [ ] ;
13438: LD_ADDR_VAR 0 3
13442: PUSH
13443: EMPTY
13444: ST_TO_ADDR
// list := [ ] ;
13445: LD_ADDR_VAR 0 5
13449: PUSH
13450: EMPTY
13451: ST_TO_ADDR
// for i = 16 to 25 do
13452: LD_ADDR_VAR 0 4
13456: PUSH
13457: DOUBLE
13458: LD_INT 16
13460: DEC
13461: ST_TO_ADDR
13462: LD_INT 25
13464: PUSH
13465: FOR_TO
13466: IFFALSE 13539
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13468: LD_ADDR_VAR 0 3
13472: PUSH
13473: LD_VAR 0 3
13477: PUSH
13478: LD_INT 22
13480: PUSH
13481: LD_VAR 0 1
13485: PPUSH
13486: CALL_OW 255
13490: PUSH
13491: EMPTY
13492: LIST
13493: LIST
13494: PUSH
13495: LD_INT 91
13497: PUSH
13498: LD_VAR 0 1
13502: PUSH
13503: LD_INT 6
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: LIST
13510: PUSH
13511: LD_INT 30
13513: PUSH
13514: LD_VAR 0 4
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: EMPTY
13524: LIST
13525: LIST
13526: LIST
13527: PUSH
13528: EMPTY
13529: LIST
13530: PPUSH
13531: CALL_OW 69
13535: ADD
13536: ST_TO_ADDR
13537: GO 13465
13539: POP
13540: POP
// for i = 1 to tmp do
13541: LD_ADDR_VAR 0 4
13545: PUSH
13546: DOUBLE
13547: LD_INT 1
13549: DEC
13550: ST_TO_ADDR
13551: LD_VAR 0 3
13555: PUSH
13556: FOR_TO
13557: IFFALSE 13645
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13559: LD_ADDR_VAR 0 5
13563: PUSH
13564: LD_VAR 0 5
13568: PUSH
13569: LD_VAR 0 3
13573: PUSH
13574: LD_VAR 0 4
13578: ARRAY
13579: PPUSH
13580: CALL_OW 266
13584: PUSH
13585: LD_VAR 0 3
13589: PUSH
13590: LD_VAR 0 4
13594: ARRAY
13595: PPUSH
13596: CALL_OW 250
13600: PUSH
13601: LD_VAR 0 3
13605: PUSH
13606: LD_VAR 0 4
13610: ARRAY
13611: PPUSH
13612: CALL_OW 251
13616: PUSH
13617: LD_VAR 0 3
13621: PUSH
13622: LD_VAR 0 4
13626: ARRAY
13627: PPUSH
13628: CALL_OW 254
13632: PUSH
13633: EMPTY
13634: LIST
13635: LIST
13636: LIST
13637: LIST
13638: PUSH
13639: EMPTY
13640: LIST
13641: ADD
13642: ST_TO_ADDR
13643: GO 13556
13645: POP
13646: POP
// result := list ;
13647: LD_ADDR_VAR 0 2
13651: PUSH
13652: LD_VAR 0 5
13656: ST_TO_ADDR
// end ;
13657: LD_VAR 0 2
13661: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13662: LD_INT 0
13664: PPUSH
13665: PPUSH
13666: PPUSH
13667: PPUSH
13668: PPUSH
13669: PPUSH
13670: PPUSH
// if not factory then
13671: LD_VAR 0 1
13675: NOT
13676: IFFALSE 13680
// exit ;
13678: GO 14273
// if control = control_apeman then
13680: LD_VAR 0 4
13684: PUSH
13685: LD_INT 5
13687: EQUAL
13688: IFFALSE 13797
// begin tmp := UnitsInside ( factory ) ;
13690: LD_ADDR_VAR 0 8
13694: PUSH
13695: LD_VAR 0 1
13699: PPUSH
13700: CALL_OW 313
13704: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13705: LD_VAR 0 8
13709: PPUSH
13710: LD_INT 25
13712: PUSH
13713: LD_INT 12
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PPUSH
13720: CALL_OW 72
13724: NOT
13725: IFFALSE 13735
// control := control_manual ;
13727: LD_ADDR_VAR 0 4
13731: PUSH
13732: LD_INT 1
13734: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13735: LD_ADDR_VAR 0 8
13739: PUSH
13740: LD_VAR 0 1
13744: PPUSH
13745: CALL 13432 0 1
13749: ST_TO_ADDR
// if tmp then
13750: LD_VAR 0 8
13754: IFFALSE 13797
// begin for i in tmp do
13756: LD_ADDR_VAR 0 7
13760: PUSH
13761: LD_VAR 0 8
13765: PUSH
13766: FOR_IN
13767: IFFALSE 13795
// if i [ 1 ] = b_ext_radio then
13769: LD_VAR 0 7
13773: PUSH
13774: LD_INT 1
13776: ARRAY
13777: PUSH
13778: LD_INT 22
13780: EQUAL
13781: IFFALSE 13793
// begin control := control_remote ;
13783: LD_ADDR_VAR 0 4
13787: PUSH
13788: LD_INT 2
13790: ST_TO_ADDR
// break ;
13791: GO 13795
// end ;
13793: GO 13766
13795: POP
13796: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13797: LD_VAR 0 1
13801: PPUSH
13802: LD_VAR 0 2
13806: PPUSH
13807: LD_VAR 0 3
13811: PPUSH
13812: LD_VAR 0 4
13816: PPUSH
13817: LD_VAR 0 5
13821: PPUSH
13822: CALL_OW 448
13826: IFFALSE 13861
// begin result := [ chassis , engine , control , weapon ] ;
13828: LD_ADDR_VAR 0 6
13832: PUSH
13833: LD_VAR 0 2
13837: PUSH
13838: LD_VAR 0 3
13842: PUSH
13843: LD_VAR 0 4
13847: PUSH
13848: LD_VAR 0 5
13852: PUSH
13853: EMPTY
13854: LIST
13855: LIST
13856: LIST
13857: LIST
13858: ST_TO_ADDR
// exit ;
13859: GO 14273
// end ; _chassis := AvailableChassisList ( factory ) ;
13861: LD_ADDR_VAR 0 9
13865: PUSH
13866: LD_VAR 0 1
13870: PPUSH
13871: CALL_OW 475
13875: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13876: LD_ADDR_VAR 0 11
13880: PUSH
13881: LD_VAR 0 1
13885: PPUSH
13886: CALL_OW 476
13890: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13891: LD_ADDR_VAR 0 12
13895: PUSH
13896: LD_VAR 0 1
13900: PPUSH
13901: CALL_OW 477
13905: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13906: LD_ADDR_VAR 0 10
13910: PUSH
13911: LD_VAR 0 1
13915: PPUSH
13916: CALL_OW 478
13920: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13921: LD_VAR 0 9
13925: NOT
13926: PUSH
13927: LD_VAR 0 11
13931: NOT
13932: OR
13933: PUSH
13934: LD_VAR 0 12
13938: NOT
13939: OR
13940: PUSH
13941: LD_VAR 0 10
13945: NOT
13946: OR
13947: IFFALSE 13982
// begin result := [ chassis , engine , control , weapon ] ;
13949: LD_ADDR_VAR 0 6
13953: PUSH
13954: LD_VAR 0 2
13958: PUSH
13959: LD_VAR 0 3
13963: PUSH
13964: LD_VAR 0 4
13968: PUSH
13969: LD_VAR 0 5
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: ST_TO_ADDR
// exit ;
13980: GO 14273
// end ; if not chassis in _chassis then
13982: LD_VAR 0 2
13986: PUSH
13987: LD_VAR 0 9
13991: IN
13992: NOT
13993: IFFALSE 14019
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13995: LD_ADDR_VAR 0 2
13999: PUSH
14000: LD_VAR 0 9
14004: PUSH
14005: LD_INT 1
14007: PPUSH
14008: LD_VAR 0 9
14012: PPUSH
14013: CALL_OW 12
14017: ARRAY
14018: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
14019: LD_VAR 0 2
14023: PPUSH
14024: LD_VAR 0 3
14028: PPUSH
14029: CALL 14278 0 2
14033: NOT
14034: IFFALSE 14093
// repeat engine := _engine [ 1 ] ;
14036: LD_ADDR_VAR 0 3
14040: PUSH
14041: LD_VAR 0 11
14045: PUSH
14046: LD_INT 1
14048: ARRAY
14049: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
14050: LD_ADDR_VAR 0 11
14054: PUSH
14055: LD_VAR 0 11
14059: PPUSH
14060: LD_INT 1
14062: PPUSH
14063: CALL_OW 3
14067: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14068: LD_VAR 0 2
14072: PPUSH
14073: LD_VAR 0 3
14077: PPUSH
14078: CALL 14278 0 2
14082: PUSH
14083: LD_VAR 0 11
14087: PUSH
14088: EMPTY
14089: EQUAL
14090: OR
14091: IFFALSE 14036
// if not control in _control then
14093: LD_VAR 0 4
14097: PUSH
14098: LD_VAR 0 12
14102: IN
14103: NOT
14104: IFFALSE 14130
// control := _control [ rand ( 1 , _control ) ] ;
14106: LD_ADDR_VAR 0 4
14110: PUSH
14111: LD_VAR 0 12
14115: PUSH
14116: LD_INT 1
14118: PPUSH
14119: LD_VAR 0 12
14123: PPUSH
14124: CALL_OW 12
14128: ARRAY
14129: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14130: LD_VAR 0 2
14134: PPUSH
14135: LD_VAR 0 5
14139: PPUSH
14140: CALL 14498 0 2
14144: NOT
14145: IFFALSE 14204
// repeat weapon := _weapon [ 1 ] ;
14147: LD_ADDR_VAR 0 5
14151: PUSH
14152: LD_VAR 0 10
14156: PUSH
14157: LD_INT 1
14159: ARRAY
14160: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14161: LD_ADDR_VAR 0 10
14165: PUSH
14166: LD_VAR 0 10
14170: PPUSH
14171: LD_INT 1
14173: PPUSH
14174: CALL_OW 3
14178: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14179: LD_VAR 0 2
14183: PPUSH
14184: LD_VAR 0 5
14188: PPUSH
14189: CALL 14498 0 2
14193: PUSH
14194: LD_VAR 0 10
14198: PUSH
14199: EMPTY
14200: EQUAL
14201: OR
14202: IFFALSE 14147
// result := [ ] ;
14204: LD_ADDR_VAR 0 6
14208: PUSH
14209: EMPTY
14210: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14211: LD_VAR 0 1
14215: PPUSH
14216: LD_VAR 0 2
14220: PPUSH
14221: LD_VAR 0 3
14225: PPUSH
14226: LD_VAR 0 4
14230: PPUSH
14231: LD_VAR 0 5
14235: PPUSH
14236: CALL_OW 448
14240: IFFALSE 14273
// result := [ chassis , engine , control , weapon ] ;
14242: LD_ADDR_VAR 0 6
14246: PUSH
14247: LD_VAR 0 2
14251: PUSH
14252: LD_VAR 0 3
14256: PUSH
14257: LD_VAR 0 4
14261: PUSH
14262: LD_VAR 0 5
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: LIST
14271: LIST
14272: ST_TO_ADDR
// end ;
14273: LD_VAR 0 6
14277: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14278: LD_INT 0
14280: PPUSH
// if not chassis or not engine then
14281: LD_VAR 0 1
14285: NOT
14286: PUSH
14287: LD_VAR 0 2
14291: NOT
14292: OR
14293: IFFALSE 14297
// exit ;
14295: GO 14493
// case engine of engine_solar :
14297: LD_VAR 0 2
14301: PUSH
14302: LD_INT 2
14304: DOUBLE
14305: EQUAL
14306: IFTRUE 14310
14308: GO 14348
14310: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14311: LD_ADDR_VAR 0 3
14315: PUSH
14316: LD_INT 11
14318: PUSH
14319: LD_INT 12
14321: PUSH
14322: LD_INT 13
14324: PUSH
14325: LD_INT 14
14327: PUSH
14328: LD_INT 1
14330: PUSH
14331: LD_INT 2
14333: PUSH
14334: LD_INT 3
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: ST_TO_ADDR
14346: GO 14477
14348: LD_INT 1
14350: DOUBLE
14351: EQUAL
14352: IFTRUE 14356
14354: GO 14418
14356: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14357: LD_ADDR_VAR 0 3
14361: PUSH
14362: LD_INT 11
14364: PUSH
14365: LD_INT 12
14367: PUSH
14368: LD_INT 13
14370: PUSH
14371: LD_INT 14
14373: PUSH
14374: LD_INT 1
14376: PUSH
14377: LD_INT 2
14379: PUSH
14380: LD_INT 3
14382: PUSH
14383: LD_INT 4
14385: PUSH
14386: LD_INT 5
14388: PUSH
14389: LD_INT 21
14391: PUSH
14392: LD_INT 23
14394: PUSH
14395: LD_INT 22
14397: PUSH
14398: LD_INT 24
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: ST_TO_ADDR
14416: GO 14477
14418: LD_INT 3
14420: DOUBLE
14421: EQUAL
14422: IFTRUE 14426
14424: GO 14476
14426: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14427: LD_ADDR_VAR 0 3
14431: PUSH
14432: LD_INT 13
14434: PUSH
14435: LD_INT 14
14437: PUSH
14438: LD_INT 2
14440: PUSH
14441: LD_INT 3
14443: PUSH
14444: LD_INT 4
14446: PUSH
14447: LD_INT 5
14449: PUSH
14450: LD_INT 21
14452: PUSH
14453: LD_INT 22
14455: PUSH
14456: LD_INT 23
14458: PUSH
14459: LD_INT 24
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: LIST
14466: LIST
14467: LIST
14468: LIST
14469: LIST
14470: LIST
14471: LIST
14472: LIST
14473: ST_TO_ADDR
14474: GO 14477
14476: POP
// result := ( chassis in result ) ;
14477: LD_ADDR_VAR 0 3
14481: PUSH
14482: LD_VAR 0 1
14486: PUSH
14487: LD_VAR 0 3
14491: IN
14492: ST_TO_ADDR
// end ;
14493: LD_VAR 0 3
14497: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14498: LD_INT 0
14500: PPUSH
// if not chassis or not weapon then
14501: LD_VAR 0 1
14505: NOT
14506: PUSH
14507: LD_VAR 0 2
14511: NOT
14512: OR
14513: IFFALSE 14517
// exit ;
14515: GO 15579
// case weapon of us_machine_gun :
14517: LD_VAR 0 2
14521: PUSH
14522: LD_INT 2
14524: DOUBLE
14525: EQUAL
14526: IFTRUE 14530
14528: GO 14560
14530: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14531: LD_ADDR_VAR 0 3
14535: PUSH
14536: LD_INT 1
14538: PUSH
14539: LD_INT 2
14541: PUSH
14542: LD_INT 3
14544: PUSH
14545: LD_INT 4
14547: PUSH
14548: LD_INT 5
14550: PUSH
14551: EMPTY
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: ST_TO_ADDR
14558: GO 15563
14560: LD_INT 3
14562: DOUBLE
14563: EQUAL
14564: IFTRUE 14568
14566: GO 14598
14568: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14569: LD_ADDR_VAR 0 3
14573: PUSH
14574: LD_INT 1
14576: PUSH
14577: LD_INT 2
14579: PUSH
14580: LD_INT 3
14582: PUSH
14583: LD_INT 4
14585: PUSH
14586: LD_INT 5
14588: PUSH
14589: EMPTY
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: ST_TO_ADDR
14596: GO 15563
14598: LD_INT 11
14600: DOUBLE
14601: EQUAL
14602: IFTRUE 14606
14604: GO 14636
14606: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14607: LD_ADDR_VAR 0 3
14611: PUSH
14612: LD_INT 1
14614: PUSH
14615: LD_INT 2
14617: PUSH
14618: LD_INT 3
14620: PUSH
14621: LD_INT 4
14623: PUSH
14624: LD_INT 5
14626: PUSH
14627: EMPTY
14628: LIST
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: ST_TO_ADDR
14634: GO 15563
14636: LD_INT 4
14638: DOUBLE
14639: EQUAL
14640: IFTRUE 14644
14642: GO 14670
14644: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14645: LD_ADDR_VAR 0 3
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: LD_INT 3
14655: PUSH
14656: LD_INT 4
14658: PUSH
14659: LD_INT 5
14661: PUSH
14662: EMPTY
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: ST_TO_ADDR
14668: GO 15563
14670: LD_INT 5
14672: DOUBLE
14673: EQUAL
14674: IFTRUE 14678
14676: GO 14704
14678: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14679: LD_ADDR_VAR 0 3
14683: PUSH
14684: LD_INT 2
14686: PUSH
14687: LD_INT 3
14689: PUSH
14690: LD_INT 4
14692: PUSH
14693: LD_INT 5
14695: PUSH
14696: EMPTY
14697: LIST
14698: LIST
14699: LIST
14700: LIST
14701: ST_TO_ADDR
14702: GO 15563
14704: LD_INT 9
14706: DOUBLE
14707: EQUAL
14708: IFTRUE 14712
14710: GO 14738
14712: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14713: LD_ADDR_VAR 0 3
14717: PUSH
14718: LD_INT 2
14720: PUSH
14721: LD_INT 3
14723: PUSH
14724: LD_INT 4
14726: PUSH
14727: LD_INT 5
14729: PUSH
14730: EMPTY
14731: LIST
14732: LIST
14733: LIST
14734: LIST
14735: ST_TO_ADDR
14736: GO 15563
14738: LD_INT 7
14740: DOUBLE
14741: EQUAL
14742: IFTRUE 14746
14744: GO 14772
14746: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14747: LD_ADDR_VAR 0 3
14751: PUSH
14752: LD_INT 2
14754: PUSH
14755: LD_INT 3
14757: PUSH
14758: LD_INT 4
14760: PUSH
14761: LD_INT 5
14763: PUSH
14764: EMPTY
14765: LIST
14766: LIST
14767: LIST
14768: LIST
14769: ST_TO_ADDR
14770: GO 15563
14772: LD_INT 12
14774: DOUBLE
14775: EQUAL
14776: IFTRUE 14780
14778: GO 14806
14780: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14781: LD_ADDR_VAR 0 3
14785: PUSH
14786: LD_INT 2
14788: PUSH
14789: LD_INT 3
14791: PUSH
14792: LD_INT 4
14794: PUSH
14795: LD_INT 5
14797: PUSH
14798: EMPTY
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: ST_TO_ADDR
14804: GO 15563
14806: LD_INT 13
14808: DOUBLE
14809: EQUAL
14810: IFTRUE 14814
14812: GO 14840
14814: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14815: LD_ADDR_VAR 0 3
14819: PUSH
14820: LD_INT 2
14822: PUSH
14823: LD_INT 3
14825: PUSH
14826: LD_INT 4
14828: PUSH
14829: LD_INT 5
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: ST_TO_ADDR
14838: GO 15563
14840: LD_INT 14
14842: DOUBLE
14843: EQUAL
14844: IFTRUE 14848
14846: GO 14866
14848: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14849: LD_ADDR_VAR 0 3
14853: PUSH
14854: LD_INT 4
14856: PUSH
14857: LD_INT 5
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: ST_TO_ADDR
14864: GO 15563
14866: LD_INT 6
14868: DOUBLE
14869: EQUAL
14870: IFTRUE 14874
14872: GO 14892
14874: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14875: LD_ADDR_VAR 0 3
14879: PUSH
14880: LD_INT 4
14882: PUSH
14883: LD_INT 5
14885: PUSH
14886: EMPTY
14887: LIST
14888: LIST
14889: ST_TO_ADDR
14890: GO 15563
14892: LD_INT 10
14894: DOUBLE
14895: EQUAL
14896: IFTRUE 14900
14898: GO 14918
14900: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14901: LD_ADDR_VAR 0 3
14905: PUSH
14906: LD_INT 4
14908: PUSH
14909: LD_INT 5
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: ST_TO_ADDR
14916: GO 15563
14918: LD_INT 22
14920: DOUBLE
14921: EQUAL
14922: IFTRUE 14926
14924: GO 14952
14926: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14927: LD_ADDR_VAR 0 3
14931: PUSH
14932: LD_INT 11
14934: PUSH
14935: LD_INT 12
14937: PUSH
14938: LD_INT 13
14940: PUSH
14941: LD_INT 14
14943: PUSH
14944: EMPTY
14945: LIST
14946: LIST
14947: LIST
14948: LIST
14949: ST_TO_ADDR
14950: GO 15563
14952: LD_INT 23
14954: DOUBLE
14955: EQUAL
14956: IFTRUE 14960
14958: GO 14986
14960: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14961: LD_ADDR_VAR 0 3
14965: PUSH
14966: LD_INT 11
14968: PUSH
14969: LD_INT 12
14971: PUSH
14972: LD_INT 13
14974: PUSH
14975: LD_INT 14
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: LIST
14982: LIST
14983: ST_TO_ADDR
14984: GO 15563
14986: LD_INT 24
14988: DOUBLE
14989: EQUAL
14990: IFTRUE 14994
14992: GO 15020
14994: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14995: LD_ADDR_VAR 0 3
14999: PUSH
15000: LD_INT 11
15002: PUSH
15003: LD_INT 12
15005: PUSH
15006: LD_INT 13
15008: PUSH
15009: LD_INT 14
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: ST_TO_ADDR
15018: GO 15563
15020: LD_INT 30
15022: DOUBLE
15023: EQUAL
15024: IFTRUE 15028
15026: GO 15054
15028: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
15029: LD_ADDR_VAR 0 3
15033: PUSH
15034: LD_INT 11
15036: PUSH
15037: LD_INT 12
15039: PUSH
15040: LD_INT 13
15042: PUSH
15043: LD_INT 14
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: ST_TO_ADDR
15052: GO 15563
15054: LD_INT 25
15056: DOUBLE
15057: EQUAL
15058: IFTRUE 15062
15060: GO 15080
15062: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15063: LD_ADDR_VAR 0 3
15067: PUSH
15068: LD_INT 13
15070: PUSH
15071: LD_INT 14
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: ST_TO_ADDR
15078: GO 15563
15080: LD_INT 27
15082: DOUBLE
15083: EQUAL
15084: IFTRUE 15088
15086: GO 15106
15088: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15089: LD_ADDR_VAR 0 3
15093: PUSH
15094: LD_INT 13
15096: PUSH
15097: LD_INT 14
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: ST_TO_ADDR
15104: GO 15563
15106: LD_EXP 72
15110: DOUBLE
15111: EQUAL
15112: IFTRUE 15116
15114: GO 15142
15116: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15117: LD_ADDR_VAR 0 3
15121: PUSH
15122: LD_INT 11
15124: PUSH
15125: LD_INT 12
15127: PUSH
15128: LD_INT 13
15130: PUSH
15131: LD_INT 14
15133: PUSH
15134: EMPTY
15135: LIST
15136: LIST
15137: LIST
15138: LIST
15139: ST_TO_ADDR
15140: GO 15563
15142: LD_INT 28
15144: DOUBLE
15145: EQUAL
15146: IFTRUE 15150
15148: GO 15168
15150: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15151: LD_ADDR_VAR 0 3
15155: PUSH
15156: LD_INT 13
15158: PUSH
15159: LD_INT 14
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: ST_TO_ADDR
15166: GO 15563
15168: LD_INT 29
15170: DOUBLE
15171: EQUAL
15172: IFTRUE 15176
15174: GO 15194
15176: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15177: LD_ADDR_VAR 0 3
15181: PUSH
15182: LD_INT 13
15184: PUSH
15185: LD_INT 14
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: ST_TO_ADDR
15192: GO 15563
15194: LD_INT 31
15196: DOUBLE
15197: EQUAL
15198: IFTRUE 15202
15200: GO 15220
15202: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15203: LD_ADDR_VAR 0 3
15207: PUSH
15208: LD_INT 13
15210: PUSH
15211: LD_INT 14
15213: PUSH
15214: EMPTY
15215: LIST
15216: LIST
15217: ST_TO_ADDR
15218: GO 15563
15220: LD_INT 26
15222: DOUBLE
15223: EQUAL
15224: IFTRUE 15228
15226: GO 15246
15228: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15229: LD_ADDR_VAR 0 3
15233: PUSH
15234: LD_INT 13
15236: PUSH
15237: LD_INT 14
15239: PUSH
15240: EMPTY
15241: LIST
15242: LIST
15243: ST_TO_ADDR
15244: GO 15563
15246: LD_INT 42
15248: DOUBLE
15249: EQUAL
15250: IFTRUE 15254
15252: GO 15280
15254: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15255: LD_ADDR_VAR 0 3
15259: PUSH
15260: LD_INT 21
15262: PUSH
15263: LD_INT 22
15265: PUSH
15266: LD_INT 23
15268: PUSH
15269: LD_INT 24
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: LIST
15276: LIST
15277: ST_TO_ADDR
15278: GO 15563
15280: LD_INT 43
15282: DOUBLE
15283: EQUAL
15284: IFTRUE 15288
15286: GO 15314
15288: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15289: LD_ADDR_VAR 0 3
15293: PUSH
15294: LD_INT 21
15296: PUSH
15297: LD_INT 22
15299: PUSH
15300: LD_INT 23
15302: PUSH
15303: LD_INT 24
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: LIST
15310: LIST
15311: ST_TO_ADDR
15312: GO 15563
15314: LD_INT 44
15316: DOUBLE
15317: EQUAL
15318: IFTRUE 15322
15320: GO 15348
15322: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15323: LD_ADDR_VAR 0 3
15327: PUSH
15328: LD_INT 21
15330: PUSH
15331: LD_INT 22
15333: PUSH
15334: LD_INT 23
15336: PUSH
15337: LD_INT 24
15339: PUSH
15340: EMPTY
15341: LIST
15342: LIST
15343: LIST
15344: LIST
15345: ST_TO_ADDR
15346: GO 15563
15348: LD_INT 45
15350: DOUBLE
15351: EQUAL
15352: IFTRUE 15356
15354: GO 15382
15356: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15357: LD_ADDR_VAR 0 3
15361: PUSH
15362: LD_INT 21
15364: PUSH
15365: LD_INT 22
15367: PUSH
15368: LD_INT 23
15370: PUSH
15371: LD_INT 24
15373: PUSH
15374: EMPTY
15375: LIST
15376: LIST
15377: LIST
15378: LIST
15379: ST_TO_ADDR
15380: GO 15563
15382: LD_INT 49
15384: DOUBLE
15385: EQUAL
15386: IFTRUE 15390
15388: GO 15416
15390: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15391: LD_ADDR_VAR 0 3
15395: PUSH
15396: LD_INT 21
15398: PUSH
15399: LD_INT 22
15401: PUSH
15402: LD_INT 23
15404: PUSH
15405: LD_INT 24
15407: PUSH
15408: EMPTY
15409: LIST
15410: LIST
15411: LIST
15412: LIST
15413: ST_TO_ADDR
15414: GO 15563
15416: LD_INT 51
15418: DOUBLE
15419: EQUAL
15420: IFTRUE 15424
15422: GO 15450
15424: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15425: LD_ADDR_VAR 0 3
15429: PUSH
15430: LD_INT 21
15432: PUSH
15433: LD_INT 22
15435: PUSH
15436: LD_INT 23
15438: PUSH
15439: LD_INT 24
15441: PUSH
15442: EMPTY
15443: LIST
15444: LIST
15445: LIST
15446: LIST
15447: ST_TO_ADDR
15448: GO 15563
15450: LD_INT 52
15452: DOUBLE
15453: EQUAL
15454: IFTRUE 15458
15456: GO 15484
15458: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15459: LD_ADDR_VAR 0 3
15463: PUSH
15464: LD_INT 21
15466: PUSH
15467: LD_INT 22
15469: PUSH
15470: LD_INT 23
15472: PUSH
15473: LD_INT 24
15475: PUSH
15476: EMPTY
15477: LIST
15478: LIST
15479: LIST
15480: LIST
15481: ST_TO_ADDR
15482: GO 15563
15484: LD_INT 53
15486: DOUBLE
15487: EQUAL
15488: IFTRUE 15492
15490: GO 15510
15492: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15493: LD_ADDR_VAR 0 3
15497: PUSH
15498: LD_INT 23
15500: PUSH
15501: LD_INT 24
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: ST_TO_ADDR
15508: GO 15563
15510: LD_INT 46
15512: DOUBLE
15513: EQUAL
15514: IFTRUE 15518
15516: GO 15536
15518: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15519: LD_ADDR_VAR 0 3
15523: PUSH
15524: LD_INT 23
15526: PUSH
15527: LD_INT 24
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: ST_TO_ADDR
15534: GO 15563
15536: LD_INT 47
15538: DOUBLE
15539: EQUAL
15540: IFTRUE 15544
15542: GO 15562
15544: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15545: LD_ADDR_VAR 0 3
15549: PUSH
15550: LD_INT 23
15552: PUSH
15553: LD_INT 24
15555: PUSH
15556: EMPTY
15557: LIST
15558: LIST
15559: ST_TO_ADDR
15560: GO 15563
15562: POP
// result := ( chassis in result ) ;
15563: LD_ADDR_VAR 0 3
15567: PUSH
15568: LD_VAR 0 1
15572: PUSH
15573: LD_VAR 0 3
15577: IN
15578: ST_TO_ADDR
// end ;
15579: LD_VAR 0 3
15583: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15584: LD_INT 0
15586: PPUSH
15587: PPUSH
15588: PPUSH
15589: PPUSH
15590: PPUSH
15591: PPUSH
15592: PPUSH
// result := array ;
15593: LD_ADDR_VAR 0 5
15597: PUSH
15598: LD_VAR 0 1
15602: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15603: LD_VAR 0 1
15607: NOT
15608: PUSH
15609: LD_VAR 0 2
15613: NOT
15614: OR
15615: PUSH
15616: LD_VAR 0 3
15620: NOT
15621: OR
15622: PUSH
15623: LD_VAR 0 2
15627: PUSH
15628: LD_VAR 0 1
15632: GREATER
15633: OR
15634: PUSH
15635: LD_VAR 0 3
15639: PUSH
15640: LD_VAR 0 1
15644: GREATER
15645: OR
15646: IFFALSE 15650
// exit ;
15648: GO 15946
// if direction then
15650: LD_VAR 0 4
15654: IFFALSE 15718
// begin d := 1 ;
15656: LD_ADDR_VAR 0 9
15660: PUSH
15661: LD_INT 1
15663: ST_TO_ADDR
// if i_from > i_to then
15664: LD_VAR 0 2
15668: PUSH
15669: LD_VAR 0 3
15673: GREATER
15674: IFFALSE 15700
// length := ( array - i_from ) + i_to else
15676: LD_ADDR_VAR 0 11
15680: PUSH
15681: LD_VAR 0 1
15685: PUSH
15686: LD_VAR 0 2
15690: MINUS
15691: PUSH
15692: LD_VAR 0 3
15696: PLUS
15697: ST_TO_ADDR
15698: GO 15716
// length := i_to - i_from ;
15700: LD_ADDR_VAR 0 11
15704: PUSH
15705: LD_VAR 0 3
15709: PUSH
15710: LD_VAR 0 2
15714: MINUS
15715: ST_TO_ADDR
// end else
15716: GO 15779
// begin d := - 1 ;
15718: LD_ADDR_VAR 0 9
15722: PUSH
15723: LD_INT 1
15725: NEG
15726: ST_TO_ADDR
// if i_from > i_to then
15727: LD_VAR 0 2
15731: PUSH
15732: LD_VAR 0 3
15736: GREATER
15737: IFFALSE 15757
// length := i_from - i_to else
15739: LD_ADDR_VAR 0 11
15743: PUSH
15744: LD_VAR 0 2
15748: PUSH
15749: LD_VAR 0 3
15753: MINUS
15754: ST_TO_ADDR
15755: GO 15779
// length := ( array - i_to ) + i_from ;
15757: LD_ADDR_VAR 0 11
15761: PUSH
15762: LD_VAR 0 1
15766: PUSH
15767: LD_VAR 0 3
15771: MINUS
15772: PUSH
15773: LD_VAR 0 2
15777: PLUS
15778: ST_TO_ADDR
// end ; if not length then
15779: LD_VAR 0 11
15783: NOT
15784: IFFALSE 15788
// exit ;
15786: GO 15946
// tmp := array ;
15788: LD_ADDR_VAR 0 10
15792: PUSH
15793: LD_VAR 0 1
15797: ST_TO_ADDR
// for i = 1 to length do
15798: LD_ADDR_VAR 0 6
15802: PUSH
15803: DOUBLE
15804: LD_INT 1
15806: DEC
15807: ST_TO_ADDR
15808: LD_VAR 0 11
15812: PUSH
15813: FOR_TO
15814: IFFALSE 15934
// begin for j = 1 to array do
15816: LD_ADDR_VAR 0 7
15820: PUSH
15821: DOUBLE
15822: LD_INT 1
15824: DEC
15825: ST_TO_ADDR
15826: LD_VAR 0 1
15830: PUSH
15831: FOR_TO
15832: IFFALSE 15920
// begin k := j + d ;
15834: LD_ADDR_VAR 0 8
15838: PUSH
15839: LD_VAR 0 7
15843: PUSH
15844: LD_VAR 0 9
15848: PLUS
15849: ST_TO_ADDR
// if k > array then
15850: LD_VAR 0 8
15854: PUSH
15855: LD_VAR 0 1
15859: GREATER
15860: IFFALSE 15870
// k := 1 ;
15862: LD_ADDR_VAR 0 8
15866: PUSH
15867: LD_INT 1
15869: ST_TO_ADDR
// if not k then
15870: LD_VAR 0 8
15874: NOT
15875: IFFALSE 15887
// k := array ;
15877: LD_ADDR_VAR 0 8
15881: PUSH
15882: LD_VAR 0 1
15886: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15887: LD_ADDR_VAR 0 10
15891: PUSH
15892: LD_VAR 0 10
15896: PPUSH
15897: LD_VAR 0 8
15901: PPUSH
15902: LD_VAR 0 1
15906: PUSH
15907: LD_VAR 0 7
15911: ARRAY
15912: PPUSH
15913: CALL_OW 1
15917: ST_TO_ADDR
// end ;
15918: GO 15831
15920: POP
15921: POP
// array := tmp ;
15922: LD_ADDR_VAR 0 1
15926: PUSH
15927: LD_VAR 0 10
15931: ST_TO_ADDR
// end ;
15932: GO 15813
15934: POP
15935: POP
// result := array ;
15936: LD_ADDR_VAR 0 5
15940: PUSH
15941: LD_VAR 0 1
15945: ST_TO_ADDR
// end ;
15946: LD_VAR 0 5
15950: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15951: LD_INT 0
15953: PPUSH
15954: PPUSH
// result := 0 ;
15955: LD_ADDR_VAR 0 3
15959: PUSH
15960: LD_INT 0
15962: ST_TO_ADDR
// if not array or not value in array then
15963: LD_VAR 0 1
15967: NOT
15968: PUSH
15969: LD_VAR 0 2
15973: PUSH
15974: LD_VAR 0 1
15978: IN
15979: NOT
15980: OR
15981: IFFALSE 15985
// exit ;
15983: GO 16039
// for i = 1 to array do
15985: LD_ADDR_VAR 0 4
15989: PUSH
15990: DOUBLE
15991: LD_INT 1
15993: DEC
15994: ST_TO_ADDR
15995: LD_VAR 0 1
15999: PUSH
16000: FOR_TO
16001: IFFALSE 16037
// if value = array [ i ] then
16003: LD_VAR 0 2
16007: PUSH
16008: LD_VAR 0 1
16012: PUSH
16013: LD_VAR 0 4
16017: ARRAY
16018: EQUAL
16019: IFFALSE 16035
// begin result := i ;
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: LD_VAR 0 4
16030: ST_TO_ADDR
// exit ;
16031: POP
16032: POP
16033: GO 16039
// end ;
16035: GO 16000
16037: POP
16038: POP
// end ;
16039: LD_VAR 0 3
16043: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
16044: LD_INT 0
16046: PPUSH
// vc_chassis := chassis ;
16047: LD_ADDR_OWVAR 37
16051: PUSH
16052: LD_VAR 0 1
16056: ST_TO_ADDR
// vc_engine := engine ;
16057: LD_ADDR_OWVAR 39
16061: PUSH
16062: LD_VAR 0 2
16066: ST_TO_ADDR
// vc_control := control ;
16067: LD_ADDR_OWVAR 38
16071: PUSH
16072: LD_VAR 0 3
16076: ST_TO_ADDR
// vc_weapon := weapon ;
16077: LD_ADDR_OWVAR 40
16081: PUSH
16082: LD_VAR 0 4
16086: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16087: LD_ADDR_OWVAR 41
16091: PUSH
16092: LD_VAR 0 5
16096: ST_TO_ADDR
// end ;
16097: LD_VAR 0 6
16101: RET
// export function WantPlant ( unit ) ; var task ; begin
16102: LD_INT 0
16104: PPUSH
16105: PPUSH
// result := false ;
16106: LD_ADDR_VAR 0 2
16110: PUSH
16111: LD_INT 0
16113: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16114: LD_ADDR_VAR 0 3
16118: PUSH
16119: LD_VAR 0 1
16123: PPUSH
16124: CALL_OW 437
16128: ST_TO_ADDR
// if task then
16129: LD_VAR 0 3
16133: IFFALSE 16161
// if task [ 1 ] [ 1 ] = p then
16135: LD_VAR 0 3
16139: PUSH
16140: LD_INT 1
16142: ARRAY
16143: PUSH
16144: LD_INT 1
16146: ARRAY
16147: PUSH
16148: LD_STRING p
16150: EQUAL
16151: IFFALSE 16161
// result := true ;
16153: LD_ADDR_VAR 0 2
16157: PUSH
16158: LD_INT 1
16160: ST_TO_ADDR
// end ;
16161: LD_VAR 0 2
16165: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16166: LD_INT 0
16168: PPUSH
16169: PPUSH
16170: PPUSH
16171: PPUSH
// if pos < 1 then
16172: LD_VAR 0 2
16176: PUSH
16177: LD_INT 1
16179: LESS
16180: IFFALSE 16184
// exit ;
16182: GO 16487
// if pos = 1 then
16184: LD_VAR 0 2
16188: PUSH
16189: LD_INT 1
16191: EQUAL
16192: IFFALSE 16225
// result := Replace ( arr , pos [ 1 ] , value ) else
16194: LD_ADDR_VAR 0 4
16198: PUSH
16199: LD_VAR 0 1
16203: PPUSH
16204: LD_VAR 0 2
16208: PUSH
16209: LD_INT 1
16211: ARRAY
16212: PPUSH
16213: LD_VAR 0 3
16217: PPUSH
16218: CALL_OW 1
16222: ST_TO_ADDR
16223: GO 16487
// begin tmp := arr ;
16225: LD_ADDR_VAR 0 6
16229: PUSH
16230: LD_VAR 0 1
16234: ST_TO_ADDR
// s_arr := [ tmp ] ;
16235: LD_ADDR_VAR 0 7
16239: PUSH
16240: LD_VAR 0 6
16244: PUSH
16245: EMPTY
16246: LIST
16247: ST_TO_ADDR
// for i = 1 to pos - 1 do
16248: LD_ADDR_VAR 0 5
16252: PUSH
16253: DOUBLE
16254: LD_INT 1
16256: DEC
16257: ST_TO_ADDR
16258: LD_VAR 0 2
16262: PUSH
16263: LD_INT 1
16265: MINUS
16266: PUSH
16267: FOR_TO
16268: IFFALSE 16313
// begin tmp := tmp [ pos [ i ] ] ;
16270: LD_ADDR_VAR 0 6
16274: PUSH
16275: LD_VAR 0 6
16279: PUSH
16280: LD_VAR 0 2
16284: PUSH
16285: LD_VAR 0 5
16289: ARRAY
16290: ARRAY
16291: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16292: LD_ADDR_VAR 0 7
16296: PUSH
16297: LD_VAR 0 7
16301: PUSH
16302: LD_VAR 0 6
16306: PUSH
16307: EMPTY
16308: LIST
16309: ADD
16310: ST_TO_ADDR
// end ;
16311: GO 16267
16313: POP
16314: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16315: LD_ADDR_VAR 0 6
16319: PUSH
16320: LD_VAR 0 6
16324: PPUSH
16325: LD_VAR 0 2
16329: PUSH
16330: LD_VAR 0 2
16334: ARRAY
16335: PPUSH
16336: LD_VAR 0 3
16340: PPUSH
16341: CALL_OW 1
16345: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16346: LD_ADDR_VAR 0 7
16350: PUSH
16351: LD_VAR 0 7
16355: PPUSH
16356: LD_VAR 0 7
16360: PPUSH
16361: LD_VAR 0 6
16365: PPUSH
16366: CALL_OW 1
16370: ST_TO_ADDR
// for i = s_arr downto 2 do
16371: LD_ADDR_VAR 0 5
16375: PUSH
16376: DOUBLE
16377: LD_VAR 0 7
16381: INC
16382: ST_TO_ADDR
16383: LD_INT 2
16385: PUSH
16386: FOR_DOWNTO
16387: IFFALSE 16471
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16389: LD_ADDR_VAR 0 6
16393: PUSH
16394: LD_VAR 0 7
16398: PUSH
16399: LD_VAR 0 5
16403: PUSH
16404: LD_INT 1
16406: MINUS
16407: ARRAY
16408: PPUSH
16409: LD_VAR 0 2
16413: PUSH
16414: LD_VAR 0 5
16418: PUSH
16419: LD_INT 1
16421: MINUS
16422: ARRAY
16423: PPUSH
16424: LD_VAR 0 7
16428: PUSH
16429: LD_VAR 0 5
16433: ARRAY
16434: PPUSH
16435: CALL_OW 1
16439: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16440: LD_ADDR_VAR 0 7
16444: PUSH
16445: LD_VAR 0 7
16449: PPUSH
16450: LD_VAR 0 5
16454: PUSH
16455: LD_INT 1
16457: MINUS
16458: PPUSH
16459: LD_VAR 0 6
16463: PPUSH
16464: CALL_OW 1
16468: ST_TO_ADDR
// end ;
16469: GO 16386
16471: POP
16472: POP
// result := s_arr [ 1 ] ;
16473: LD_ADDR_VAR 0 4
16477: PUSH
16478: LD_VAR 0 7
16482: PUSH
16483: LD_INT 1
16485: ARRAY
16486: ST_TO_ADDR
// end ; end ;
16487: LD_VAR 0 4
16491: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16492: LD_INT 0
16494: PPUSH
16495: PPUSH
// if not list then
16496: LD_VAR 0 1
16500: NOT
16501: IFFALSE 16505
// exit ;
16503: GO 16596
// i := list [ pos1 ] ;
16505: LD_ADDR_VAR 0 5
16509: PUSH
16510: LD_VAR 0 1
16514: PUSH
16515: LD_VAR 0 2
16519: ARRAY
16520: ST_TO_ADDR
// if not i then
16521: LD_VAR 0 5
16525: NOT
16526: IFFALSE 16530
// exit ;
16528: GO 16596
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16530: LD_ADDR_VAR 0 1
16534: PUSH
16535: LD_VAR 0 1
16539: PPUSH
16540: LD_VAR 0 2
16544: PPUSH
16545: LD_VAR 0 1
16549: PUSH
16550: LD_VAR 0 3
16554: ARRAY
16555: PPUSH
16556: CALL_OW 1
16560: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16561: LD_ADDR_VAR 0 1
16565: PUSH
16566: LD_VAR 0 1
16570: PPUSH
16571: LD_VAR 0 3
16575: PPUSH
16576: LD_VAR 0 5
16580: PPUSH
16581: CALL_OW 1
16585: ST_TO_ADDR
// result := list ;
16586: LD_ADDR_VAR 0 4
16590: PUSH
16591: LD_VAR 0 1
16595: ST_TO_ADDR
// end ;
16596: LD_VAR 0 4
16600: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16601: LD_INT 0
16603: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16604: LD_ADDR_VAR 0 5
16608: PUSH
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL_OW 250
16618: PPUSH
16619: LD_VAR 0 1
16623: PPUSH
16624: CALL_OW 251
16628: PPUSH
16629: LD_VAR 0 2
16633: PPUSH
16634: LD_VAR 0 3
16638: PPUSH
16639: LD_VAR 0 4
16643: PPUSH
16644: CALL 16654 0 5
16648: ST_TO_ADDR
// end ;
16649: LD_VAR 0 5
16653: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16654: LD_INT 0
16656: PPUSH
16657: PPUSH
16658: PPUSH
16659: PPUSH
// if not list then
16660: LD_VAR 0 3
16664: NOT
16665: IFFALSE 16669
// exit ;
16667: GO 17057
// result := [ ] ;
16669: LD_ADDR_VAR 0 6
16673: PUSH
16674: EMPTY
16675: ST_TO_ADDR
// for i in list do
16676: LD_ADDR_VAR 0 7
16680: PUSH
16681: LD_VAR 0 3
16685: PUSH
16686: FOR_IN
16687: IFFALSE 16889
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16689: LD_ADDR_VAR 0 9
16693: PUSH
16694: LD_VAR 0 7
16698: PPUSH
16699: LD_VAR 0 1
16703: PPUSH
16704: LD_VAR 0 2
16708: PPUSH
16709: CALL_OW 297
16713: ST_TO_ADDR
// if not result then
16714: LD_VAR 0 6
16718: NOT
16719: IFFALSE 16745
// result := [ [ i , tmp ] ] else
16721: LD_ADDR_VAR 0 6
16725: PUSH
16726: LD_VAR 0 7
16730: PUSH
16731: LD_VAR 0 9
16735: PUSH
16736: EMPTY
16737: LIST
16738: LIST
16739: PUSH
16740: EMPTY
16741: LIST
16742: ST_TO_ADDR
16743: GO 16887
// begin if result [ result ] [ 2 ] < tmp then
16745: LD_VAR 0 6
16749: PUSH
16750: LD_VAR 0 6
16754: ARRAY
16755: PUSH
16756: LD_INT 2
16758: ARRAY
16759: PUSH
16760: LD_VAR 0 9
16764: LESS
16765: IFFALSE 16807
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16767: LD_ADDR_VAR 0 6
16771: PUSH
16772: LD_VAR 0 6
16776: PPUSH
16777: LD_VAR 0 6
16781: PUSH
16782: LD_INT 1
16784: PLUS
16785: PPUSH
16786: LD_VAR 0 7
16790: PUSH
16791: LD_VAR 0 9
16795: PUSH
16796: EMPTY
16797: LIST
16798: LIST
16799: PPUSH
16800: CALL_OW 2
16804: ST_TO_ADDR
16805: GO 16887
// for j = 1 to result do
16807: LD_ADDR_VAR 0 8
16811: PUSH
16812: DOUBLE
16813: LD_INT 1
16815: DEC
16816: ST_TO_ADDR
16817: LD_VAR 0 6
16821: PUSH
16822: FOR_TO
16823: IFFALSE 16885
// begin if tmp < result [ j ] [ 2 ] then
16825: LD_VAR 0 9
16829: PUSH
16830: LD_VAR 0 6
16834: PUSH
16835: LD_VAR 0 8
16839: ARRAY
16840: PUSH
16841: LD_INT 2
16843: ARRAY
16844: LESS
16845: IFFALSE 16883
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16847: LD_ADDR_VAR 0 6
16851: PUSH
16852: LD_VAR 0 6
16856: PPUSH
16857: LD_VAR 0 8
16861: PPUSH
16862: LD_VAR 0 7
16866: PUSH
16867: LD_VAR 0 9
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: PPUSH
16876: CALL_OW 2
16880: ST_TO_ADDR
// break ;
16881: GO 16885
// end ; end ;
16883: GO 16822
16885: POP
16886: POP
// end ; end ;
16887: GO 16686
16889: POP
16890: POP
// if result and not asc then
16891: LD_VAR 0 6
16895: PUSH
16896: LD_VAR 0 4
16900: NOT
16901: AND
16902: IFFALSE 16977
// begin tmp := result ;
16904: LD_ADDR_VAR 0 9
16908: PUSH
16909: LD_VAR 0 6
16913: ST_TO_ADDR
// for i = tmp downto 1 do
16914: LD_ADDR_VAR 0 7
16918: PUSH
16919: DOUBLE
16920: LD_VAR 0 9
16924: INC
16925: ST_TO_ADDR
16926: LD_INT 1
16928: PUSH
16929: FOR_DOWNTO
16930: IFFALSE 16975
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16932: LD_ADDR_VAR 0 6
16936: PUSH
16937: LD_VAR 0 6
16941: PPUSH
16942: LD_VAR 0 9
16946: PUSH
16947: LD_VAR 0 7
16951: MINUS
16952: PUSH
16953: LD_INT 1
16955: PLUS
16956: PPUSH
16957: LD_VAR 0 9
16961: PUSH
16962: LD_VAR 0 7
16966: ARRAY
16967: PPUSH
16968: CALL_OW 1
16972: ST_TO_ADDR
16973: GO 16929
16975: POP
16976: POP
// end ; tmp := [ ] ;
16977: LD_ADDR_VAR 0 9
16981: PUSH
16982: EMPTY
16983: ST_TO_ADDR
// if mode then
16984: LD_VAR 0 5
16988: IFFALSE 17057
// begin for i = 1 to result do
16990: LD_ADDR_VAR 0 7
16994: PUSH
16995: DOUBLE
16996: LD_INT 1
16998: DEC
16999: ST_TO_ADDR
17000: LD_VAR 0 6
17004: PUSH
17005: FOR_TO
17006: IFFALSE 17045
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
17008: LD_ADDR_VAR 0 9
17012: PUSH
17013: LD_VAR 0 9
17017: PPUSH
17018: LD_VAR 0 7
17022: PPUSH
17023: LD_VAR 0 6
17027: PUSH
17028: LD_VAR 0 7
17032: ARRAY
17033: PUSH
17034: LD_INT 1
17036: ARRAY
17037: PPUSH
17038: CALL_OW 1
17042: ST_TO_ADDR
17043: GO 17005
17045: POP
17046: POP
// result := tmp ;
17047: LD_ADDR_VAR 0 6
17051: PUSH
17052: LD_VAR 0 9
17056: ST_TO_ADDR
// end ; end ;
17057: LD_VAR 0 6
17061: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17062: LD_INT 0
17064: PPUSH
17065: PPUSH
17066: PPUSH
17067: PPUSH
17068: PPUSH
17069: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17070: LD_ADDR_VAR 0 5
17074: PUSH
17075: LD_INT 0
17077: PUSH
17078: LD_INT 0
17080: PUSH
17081: LD_INT 0
17083: PUSH
17084: EMPTY
17085: PUSH
17086: EMPTY
17087: LIST
17088: LIST
17089: LIST
17090: LIST
17091: ST_TO_ADDR
// if not x or not y then
17092: LD_VAR 0 2
17096: NOT
17097: PUSH
17098: LD_VAR 0 3
17102: NOT
17103: OR
17104: IFFALSE 17108
// exit ;
17106: GO 18760
// if not range then
17108: LD_VAR 0 4
17112: NOT
17113: IFFALSE 17123
// range := 10 ;
17115: LD_ADDR_VAR 0 4
17119: PUSH
17120: LD_INT 10
17122: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17123: LD_ADDR_VAR 0 8
17127: PUSH
17128: LD_INT 81
17130: PUSH
17131: LD_VAR 0 1
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: PUSH
17140: LD_INT 92
17142: PUSH
17143: LD_VAR 0 2
17147: PUSH
17148: LD_VAR 0 3
17152: PUSH
17153: LD_VAR 0 4
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: LIST
17162: LIST
17163: PUSH
17164: LD_INT 3
17166: PUSH
17167: LD_INT 21
17169: PUSH
17170: LD_INT 3
17172: PUSH
17173: EMPTY
17174: LIST
17175: LIST
17176: PUSH
17177: EMPTY
17178: LIST
17179: LIST
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: LIST
17185: PPUSH
17186: CALL_OW 69
17190: ST_TO_ADDR
// if not tmp then
17191: LD_VAR 0 8
17195: NOT
17196: IFFALSE 17200
// exit ;
17198: GO 18760
// for i in tmp do
17200: LD_ADDR_VAR 0 6
17204: PUSH
17205: LD_VAR 0 8
17209: PUSH
17210: FOR_IN
17211: IFFALSE 18735
// begin points := [ 0 , 0 , 0 ] ;
17213: LD_ADDR_VAR 0 9
17217: PUSH
17218: LD_INT 0
17220: PUSH
17221: LD_INT 0
17223: PUSH
17224: LD_INT 0
17226: PUSH
17227: EMPTY
17228: LIST
17229: LIST
17230: LIST
17231: ST_TO_ADDR
// bpoints := 1 ;
17232: LD_ADDR_VAR 0 10
17236: PUSH
17237: LD_INT 1
17239: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17240: LD_VAR 0 6
17244: PPUSH
17245: CALL_OW 247
17249: PUSH
17250: LD_INT 1
17252: DOUBLE
17253: EQUAL
17254: IFTRUE 17258
17256: GO 17836
17258: POP
// begin if GetClass ( i ) = 1 then
17259: LD_VAR 0 6
17263: PPUSH
17264: CALL_OW 257
17268: PUSH
17269: LD_INT 1
17271: EQUAL
17272: IFFALSE 17293
// points := [ 10 , 5 , 3 ] ;
17274: LD_ADDR_VAR 0 9
17278: PUSH
17279: LD_INT 10
17281: PUSH
17282: LD_INT 5
17284: PUSH
17285: LD_INT 3
17287: PUSH
17288: EMPTY
17289: LIST
17290: LIST
17291: LIST
17292: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17293: LD_VAR 0 6
17297: PPUSH
17298: CALL_OW 257
17302: PUSH
17303: LD_INT 2
17305: PUSH
17306: LD_INT 3
17308: PUSH
17309: LD_INT 4
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: LIST
17316: IN
17317: IFFALSE 17338
// points := [ 3 , 2 , 1 ] ;
17319: LD_ADDR_VAR 0 9
17323: PUSH
17324: LD_INT 3
17326: PUSH
17327: LD_INT 2
17329: PUSH
17330: LD_INT 1
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: LIST
17337: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17338: LD_VAR 0 6
17342: PPUSH
17343: CALL_OW 257
17347: PUSH
17348: LD_INT 5
17350: EQUAL
17351: IFFALSE 17372
// points := [ 130 , 5 , 2 ] ;
17353: LD_ADDR_VAR 0 9
17357: PUSH
17358: LD_INT 130
17360: PUSH
17361: LD_INT 5
17363: PUSH
17364: LD_INT 2
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: LIST
17371: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17372: LD_VAR 0 6
17376: PPUSH
17377: CALL_OW 257
17381: PUSH
17382: LD_INT 8
17384: EQUAL
17385: IFFALSE 17406
// points := [ 35 , 35 , 30 ] ;
17387: LD_ADDR_VAR 0 9
17391: PUSH
17392: LD_INT 35
17394: PUSH
17395: LD_INT 35
17397: PUSH
17398: LD_INT 30
17400: PUSH
17401: EMPTY
17402: LIST
17403: LIST
17404: LIST
17405: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17406: LD_VAR 0 6
17410: PPUSH
17411: CALL_OW 257
17415: PUSH
17416: LD_INT 9
17418: EQUAL
17419: IFFALSE 17440
// points := [ 20 , 55 , 40 ] ;
17421: LD_ADDR_VAR 0 9
17425: PUSH
17426: LD_INT 20
17428: PUSH
17429: LD_INT 55
17431: PUSH
17432: LD_INT 40
17434: PUSH
17435: EMPTY
17436: LIST
17437: LIST
17438: LIST
17439: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17440: LD_VAR 0 6
17444: PPUSH
17445: CALL_OW 257
17449: PUSH
17450: LD_INT 12
17452: PUSH
17453: LD_INT 16
17455: PUSH
17456: EMPTY
17457: LIST
17458: LIST
17459: IN
17460: IFFALSE 17481
// points := [ 5 , 3 , 2 ] ;
17462: LD_ADDR_VAR 0 9
17466: PUSH
17467: LD_INT 5
17469: PUSH
17470: LD_INT 3
17472: PUSH
17473: LD_INT 2
17475: PUSH
17476: EMPTY
17477: LIST
17478: LIST
17479: LIST
17480: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17481: LD_VAR 0 6
17485: PPUSH
17486: CALL_OW 257
17490: PUSH
17491: LD_INT 17
17493: EQUAL
17494: IFFALSE 17515
// points := [ 100 , 50 , 75 ] ;
17496: LD_ADDR_VAR 0 9
17500: PUSH
17501: LD_INT 100
17503: PUSH
17504: LD_INT 50
17506: PUSH
17507: LD_INT 75
17509: PUSH
17510: EMPTY
17511: LIST
17512: LIST
17513: LIST
17514: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17515: LD_VAR 0 6
17519: PPUSH
17520: CALL_OW 257
17524: PUSH
17525: LD_INT 15
17527: EQUAL
17528: IFFALSE 17549
// points := [ 10 , 5 , 3 ] ;
17530: LD_ADDR_VAR 0 9
17534: PUSH
17535: LD_INT 10
17537: PUSH
17538: LD_INT 5
17540: PUSH
17541: LD_INT 3
17543: PUSH
17544: EMPTY
17545: LIST
17546: LIST
17547: LIST
17548: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17549: LD_VAR 0 6
17553: PPUSH
17554: CALL_OW 257
17558: PUSH
17559: LD_INT 14
17561: EQUAL
17562: IFFALSE 17583
// points := [ 10 , 0 , 0 ] ;
17564: LD_ADDR_VAR 0 9
17568: PUSH
17569: LD_INT 10
17571: PUSH
17572: LD_INT 0
17574: PUSH
17575: LD_INT 0
17577: PUSH
17578: EMPTY
17579: LIST
17580: LIST
17581: LIST
17582: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17583: LD_VAR 0 6
17587: PPUSH
17588: CALL_OW 257
17592: PUSH
17593: LD_INT 11
17595: EQUAL
17596: IFFALSE 17617
// points := [ 30 , 10 , 5 ] ;
17598: LD_ADDR_VAR 0 9
17602: PUSH
17603: LD_INT 30
17605: PUSH
17606: LD_INT 10
17608: PUSH
17609: LD_INT 5
17611: PUSH
17612: EMPTY
17613: LIST
17614: LIST
17615: LIST
17616: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17617: LD_VAR 0 1
17621: PPUSH
17622: LD_INT 5
17624: PPUSH
17625: CALL_OW 321
17629: PUSH
17630: LD_INT 2
17632: EQUAL
17633: IFFALSE 17650
// bpoints := bpoints * 1.8 ;
17635: LD_ADDR_VAR 0 10
17639: PUSH
17640: LD_VAR 0 10
17644: PUSH
17645: LD_REAL  1.80000000000000E+0000
17648: MUL
17649: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17650: LD_VAR 0 6
17654: PPUSH
17655: CALL_OW 257
17659: PUSH
17660: LD_INT 1
17662: PUSH
17663: LD_INT 2
17665: PUSH
17666: LD_INT 3
17668: PUSH
17669: LD_INT 4
17671: PUSH
17672: EMPTY
17673: LIST
17674: LIST
17675: LIST
17676: LIST
17677: IN
17678: PUSH
17679: LD_VAR 0 1
17683: PPUSH
17684: LD_INT 51
17686: PPUSH
17687: CALL_OW 321
17691: PUSH
17692: LD_INT 2
17694: EQUAL
17695: AND
17696: IFFALSE 17713
// bpoints := bpoints * 1.2 ;
17698: LD_ADDR_VAR 0 10
17702: PUSH
17703: LD_VAR 0 10
17707: PUSH
17708: LD_REAL  1.20000000000000E+0000
17711: MUL
17712: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17713: LD_VAR 0 6
17717: PPUSH
17718: CALL_OW 257
17722: PUSH
17723: LD_INT 5
17725: PUSH
17726: LD_INT 7
17728: PUSH
17729: LD_INT 9
17731: PUSH
17732: EMPTY
17733: LIST
17734: LIST
17735: LIST
17736: IN
17737: PUSH
17738: LD_VAR 0 1
17742: PPUSH
17743: LD_INT 52
17745: PPUSH
17746: CALL_OW 321
17750: PUSH
17751: LD_INT 2
17753: EQUAL
17754: AND
17755: IFFALSE 17772
// bpoints := bpoints * 1.5 ;
17757: LD_ADDR_VAR 0 10
17761: PUSH
17762: LD_VAR 0 10
17766: PUSH
17767: LD_REAL  1.50000000000000E+0000
17770: MUL
17771: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17772: LD_VAR 0 1
17776: PPUSH
17777: LD_INT 66
17779: PPUSH
17780: CALL_OW 321
17784: PUSH
17785: LD_INT 2
17787: EQUAL
17788: IFFALSE 17805
// bpoints := bpoints * 1.1 ;
17790: LD_ADDR_VAR 0 10
17794: PUSH
17795: LD_VAR 0 10
17799: PUSH
17800: LD_REAL  1.10000000000000E+0000
17803: MUL
17804: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17805: LD_ADDR_VAR 0 10
17809: PUSH
17810: LD_VAR 0 10
17814: PUSH
17815: LD_VAR 0 6
17819: PPUSH
17820: LD_INT 1
17822: PPUSH
17823: CALL_OW 259
17827: PUSH
17828: LD_REAL  1.15000000000000E+0000
17831: MUL
17832: MUL
17833: ST_TO_ADDR
// end ; unit_vehicle :
17834: GO 18664
17836: LD_INT 2
17838: DOUBLE
17839: EQUAL
17840: IFTRUE 17844
17842: GO 18652
17844: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17845: LD_VAR 0 6
17849: PPUSH
17850: CALL_OW 264
17854: PUSH
17855: LD_INT 2
17857: PUSH
17858: LD_INT 42
17860: PUSH
17861: LD_INT 24
17863: PUSH
17864: EMPTY
17865: LIST
17866: LIST
17867: LIST
17868: IN
17869: IFFALSE 17890
// points := [ 25 , 5 , 3 ] ;
17871: LD_ADDR_VAR 0 9
17875: PUSH
17876: LD_INT 25
17878: PUSH
17879: LD_INT 5
17881: PUSH
17882: LD_INT 3
17884: PUSH
17885: EMPTY
17886: LIST
17887: LIST
17888: LIST
17889: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17890: LD_VAR 0 6
17894: PPUSH
17895: CALL_OW 264
17899: PUSH
17900: LD_INT 4
17902: PUSH
17903: LD_INT 43
17905: PUSH
17906: LD_INT 25
17908: PUSH
17909: EMPTY
17910: LIST
17911: LIST
17912: LIST
17913: IN
17914: IFFALSE 17935
// points := [ 40 , 15 , 5 ] ;
17916: LD_ADDR_VAR 0 9
17920: PUSH
17921: LD_INT 40
17923: PUSH
17924: LD_INT 15
17926: PUSH
17927: LD_INT 5
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17935: LD_VAR 0 6
17939: PPUSH
17940: CALL_OW 264
17944: PUSH
17945: LD_INT 3
17947: PUSH
17948: LD_INT 23
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: IN
17955: IFFALSE 17976
// points := [ 7 , 25 , 8 ] ;
17957: LD_ADDR_VAR 0 9
17961: PUSH
17962: LD_INT 7
17964: PUSH
17965: LD_INT 25
17967: PUSH
17968: LD_INT 8
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: LIST
17975: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17976: LD_VAR 0 6
17980: PPUSH
17981: CALL_OW 264
17985: PUSH
17986: LD_INT 5
17988: PUSH
17989: LD_INT 27
17991: PUSH
17992: LD_INT 44
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: LIST
17999: IN
18000: IFFALSE 18021
// points := [ 14 , 50 , 16 ] ;
18002: LD_ADDR_VAR 0 9
18006: PUSH
18007: LD_INT 14
18009: PUSH
18010: LD_INT 50
18012: PUSH
18013: LD_INT 16
18015: PUSH
18016: EMPTY
18017: LIST
18018: LIST
18019: LIST
18020: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18021: LD_VAR 0 6
18025: PPUSH
18026: CALL_OW 264
18030: PUSH
18031: LD_INT 6
18033: PUSH
18034: LD_INT 46
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: IN
18041: IFFALSE 18062
// points := [ 32 , 120 , 70 ] ;
18043: LD_ADDR_VAR 0 9
18047: PUSH
18048: LD_INT 32
18050: PUSH
18051: LD_INT 120
18053: PUSH
18054: LD_INT 70
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18062: LD_VAR 0 6
18066: PPUSH
18067: CALL_OW 264
18071: PUSH
18072: LD_INT 7
18074: PUSH
18075: LD_INT 28
18077: PUSH
18078: LD_INT 45
18080: PUSH
18081: LD_EXP 72
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: IN
18092: IFFALSE 18113
// points := [ 35 , 20 , 45 ] ;
18094: LD_ADDR_VAR 0 9
18098: PUSH
18099: LD_INT 35
18101: PUSH
18102: LD_INT 20
18104: PUSH
18105: LD_INT 45
18107: PUSH
18108: EMPTY
18109: LIST
18110: LIST
18111: LIST
18112: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18113: LD_VAR 0 6
18117: PPUSH
18118: CALL_OW 264
18122: PUSH
18123: LD_INT 47
18125: PUSH
18126: EMPTY
18127: LIST
18128: IN
18129: IFFALSE 18150
// points := [ 67 , 45 , 75 ] ;
18131: LD_ADDR_VAR 0 9
18135: PUSH
18136: LD_INT 67
18138: PUSH
18139: LD_INT 45
18141: PUSH
18142: LD_INT 75
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: LIST
18149: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18150: LD_VAR 0 6
18154: PPUSH
18155: CALL_OW 264
18159: PUSH
18160: LD_INT 26
18162: PUSH
18163: EMPTY
18164: LIST
18165: IN
18166: IFFALSE 18187
// points := [ 120 , 30 , 80 ] ;
18168: LD_ADDR_VAR 0 9
18172: PUSH
18173: LD_INT 120
18175: PUSH
18176: LD_INT 30
18178: PUSH
18179: LD_INT 80
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: LIST
18186: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18187: LD_VAR 0 6
18191: PPUSH
18192: CALL_OW 264
18196: PUSH
18197: LD_INT 22
18199: PUSH
18200: EMPTY
18201: LIST
18202: IN
18203: IFFALSE 18224
// points := [ 40 , 1 , 1 ] ;
18205: LD_ADDR_VAR 0 9
18209: PUSH
18210: LD_INT 40
18212: PUSH
18213: LD_INT 1
18215: PUSH
18216: LD_INT 1
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: LIST
18223: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18224: LD_VAR 0 6
18228: PPUSH
18229: CALL_OW 264
18233: PUSH
18234: LD_INT 29
18236: PUSH
18237: EMPTY
18238: LIST
18239: IN
18240: IFFALSE 18261
// points := [ 70 , 200 , 400 ] ;
18242: LD_ADDR_VAR 0 9
18246: PUSH
18247: LD_INT 70
18249: PUSH
18250: LD_INT 200
18252: PUSH
18253: LD_INT 400
18255: PUSH
18256: EMPTY
18257: LIST
18258: LIST
18259: LIST
18260: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18261: LD_VAR 0 6
18265: PPUSH
18266: CALL_OW 264
18270: PUSH
18271: LD_INT 14
18273: PUSH
18274: LD_INT 53
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: IN
18281: IFFALSE 18302
// points := [ 40 , 10 , 20 ] ;
18283: LD_ADDR_VAR 0 9
18287: PUSH
18288: LD_INT 40
18290: PUSH
18291: LD_INT 10
18293: PUSH
18294: LD_INT 20
18296: PUSH
18297: EMPTY
18298: LIST
18299: LIST
18300: LIST
18301: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18302: LD_VAR 0 6
18306: PPUSH
18307: CALL_OW 264
18311: PUSH
18312: LD_INT 9
18314: PUSH
18315: EMPTY
18316: LIST
18317: IN
18318: IFFALSE 18339
// points := [ 5 , 70 , 20 ] ;
18320: LD_ADDR_VAR 0 9
18324: PUSH
18325: LD_INT 5
18327: PUSH
18328: LD_INT 70
18330: PUSH
18331: LD_INT 20
18333: PUSH
18334: EMPTY
18335: LIST
18336: LIST
18337: LIST
18338: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18339: LD_VAR 0 6
18343: PPUSH
18344: CALL_OW 264
18348: PUSH
18349: LD_INT 10
18351: PUSH
18352: EMPTY
18353: LIST
18354: IN
18355: IFFALSE 18376
// points := [ 35 , 110 , 70 ] ;
18357: LD_ADDR_VAR 0 9
18361: PUSH
18362: LD_INT 35
18364: PUSH
18365: LD_INT 110
18367: PUSH
18368: LD_INT 70
18370: PUSH
18371: EMPTY
18372: LIST
18373: LIST
18374: LIST
18375: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18376: LD_VAR 0 6
18380: PPUSH
18381: CALL_OW 265
18385: PUSH
18386: LD_INT 25
18388: EQUAL
18389: IFFALSE 18410
// points := [ 80 , 65 , 100 ] ;
18391: LD_ADDR_VAR 0 9
18395: PUSH
18396: LD_INT 80
18398: PUSH
18399: LD_INT 65
18401: PUSH
18402: LD_INT 100
18404: PUSH
18405: EMPTY
18406: LIST
18407: LIST
18408: LIST
18409: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18410: LD_VAR 0 6
18414: PPUSH
18415: CALL_OW 263
18419: PUSH
18420: LD_INT 1
18422: EQUAL
18423: IFFALSE 18458
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18425: LD_ADDR_VAR 0 10
18429: PUSH
18430: LD_VAR 0 10
18434: PUSH
18435: LD_VAR 0 6
18439: PPUSH
18440: CALL_OW 311
18444: PPUSH
18445: LD_INT 3
18447: PPUSH
18448: CALL_OW 259
18452: PUSH
18453: LD_INT 4
18455: MUL
18456: MUL
18457: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18458: LD_VAR 0 6
18462: PPUSH
18463: CALL_OW 263
18467: PUSH
18468: LD_INT 2
18470: EQUAL
18471: IFFALSE 18522
// begin j := IsControledBy ( i ) ;
18473: LD_ADDR_VAR 0 7
18477: PUSH
18478: LD_VAR 0 6
18482: PPUSH
18483: CALL_OW 312
18487: ST_TO_ADDR
// if j then
18488: LD_VAR 0 7
18492: IFFALSE 18522
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18494: LD_ADDR_VAR 0 10
18498: PUSH
18499: LD_VAR 0 10
18503: PUSH
18504: LD_VAR 0 7
18508: PPUSH
18509: LD_INT 3
18511: PPUSH
18512: CALL_OW 259
18516: PUSH
18517: LD_INT 3
18519: MUL
18520: MUL
18521: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18522: LD_VAR 0 6
18526: PPUSH
18527: CALL_OW 264
18531: PUSH
18532: LD_INT 5
18534: PUSH
18535: LD_INT 6
18537: PUSH
18538: LD_INT 46
18540: PUSH
18541: LD_INT 44
18543: PUSH
18544: LD_INT 47
18546: PUSH
18547: LD_INT 45
18549: PUSH
18550: LD_INT 28
18552: PUSH
18553: LD_INT 7
18555: PUSH
18556: LD_INT 27
18558: PUSH
18559: LD_INT 29
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: LIST
18566: LIST
18567: LIST
18568: LIST
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: IN
18574: PUSH
18575: LD_VAR 0 1
18579: PPUSH
18580: LD_INT 52
18582: PPUSH
18583: CALL_OW 321
18587: PUSH
18588: LD_INT 2
18590: EQUAL
18591: AND
18592: IFFALSE 18609
// bpoints := bpoints * 1.2 ;
18594: LD_ADDR_VAR 0 10
18598: PUSH
18599: LD_VAR 0 10
18603: PUSH
18604: LD_REAL  1.20000000000000E+0000
18607: MUL
18608: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18609: LD_VAR 0 6
18613: PPUSH
18614: CALL_OW 264
18618: PUSH
18619: LD_INT 6
18621: PUSH
18622: LD_INT 46
18624: PUSH
18625: LD_INT 47
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: LIST
18632: IN
18633: IFFALSE 18650
// bpoints := bpoints * 1.2 ;
18635: LD_ADDR_VAR 0 10
18639: PUSH
18640: LD_VAR 0 10
18644: PUSH
18645: LD_REAL  1.20000000000000E+0000
18648: MUL
18649: ST_TO_ADDR
// end ; unit_building :
18650: GO 18664
18652: LD_INT 3
18654: DOUBLE
18655: EQUAL
18656: IFTRUE 18660
18658: GO 18663
18660: POP
// ; end ;
18661: GO 18664
18663: POP
// for j = 1 to 3 do
18664: LD_ADDR_VAR 0 7
18668: PUSH
18669: DOUBLE
18670: LD_INT 1
18672: DEC
18673: ST_TO_ADDR
18674: LD_INT 3
18676: PUSH
18677: FOR_TO
18678: IFFALSE 18731
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18680: LD_ADDR_VAR 0 5
18684: PUSH
18685: LD_VAR 0 5
18689: PPUSH
18690: LD_VAR 0 7
18694: PPUSH
18695: LD_VAR 0 5
18699: PUSH
18700: LD_VAR 0 7
18704: ARRAY
18705: PUSH
18706: LD_VAR 0 9
18710: PUSH
18711: LD_VAR 0 7
18715: ARRAY
18716: PUSH
18717: LD_VAR 0 10
18721: MUL
18722: PLUS
18723: PPUSH
18724: CALL_OW 1
18728: ST_TO_ADDR
18729: GO 18677
18731: POP
18732: POP
// end ;
18733: GO 17210
18735: POP
18736: POP
// result := Replace ( result , 4 , tmp ) ;
18737: LD_ADDR_VAR 0 5
18741: PUSH
18742: LD_VAR 0 5
18746: PPUSH
18747: LD_INT 4
18749: PPUSH
18750: LD_VAR 0 8
18754: PPUSH
18755: CALL_OW 1
18759: ST_TO_ADDR
// end ;
18760: LD_VAR 0 5
18764: RET
// export function DangerAtRange ( unit , range ) ; begin
18765: LD_INT 0
18767: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18768: LD_ADDR_VAR 0 3
18772: PUSH
18773: LD_VAR 0 1
18777: PPUSH
18778: CALL_OW 255
18782: PPUSH
18783: LD_VAR 0 1
18787: PPUSH
18788: CALL_OW 250
18792: PPUSH
18793: LD_VAR 0 1
18797: PPUSH
18798: CALL_OW 251
18802: PPUSH
18803: LD_VAR 0 2
18807: PPUSH
18808: CALL 17062 0 4
18812: ST_TO_ADDR
// end ;
18813: LD_VAR 0 3
18817: RET
// export function DangerInArea ( side , area ) ; begin
18818: LD_INT 0
18820: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18821: LD_ADDR_VAR 0 3
18825: PUSH
18826: LD_VAR 0 2
18830: PPUSH
18831: LD_INT 81
18833: PUSH
18834: LD_VAR 0 1
18838: PUSH
18839: EMPTY
18840: LIST
18841: LIST
18842: PPUSH
18843: CALL_OW 70
18847: ST_TO_ADDR
// end ;
18848: LD_VAR 0 3
18852: RET
// export function IsExtension ( b ) ; begin
18853: LD_INT 0
18855: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18856: LD_ADDR_VAR 0 2
18860: PUSH
18861: LD_VAR 0 1
18865: PUSH
18866: LD_INT 23
18868: PUSH
18869: LD_INT 20
18871: PUSH
18872: LD_INT 22
18874: PUSH
18875: LD_INT 17
18877: PUSH
18878: LD_INT 24
18880: PUSH
18881: LD_INT 21
18883: PUSH
18884: LD_INT 19
18886: PUSH
18887: LD_INT 16
18889: PUSH
18890: LD_INT 25
18892: PUSH
18893: LD_INT 18
18895: PUSH
18896: EMPTY
18897: LIST
18898: LIST
18899: LIST
18900: LIST
18901: LIST
18902: LIST
18903: LIST
18904: LIST
18905: LIST
18906: LIST
18907: IN
18908: ST_TO_ADDR
// end ;
18909: LD_VAR 0 2
18913: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18914: LD_INT 0
18916: PPUSH
18917: PPUSH
18918: PPUSH
// result := [ ] ;
18919: LD_ADDR_VAR 0 4
18923: PUSH
18924: EMPTY
18925: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18926: LD_ADDR_VAR 0 5
18930: PUSH
18931: LD_VAR 0 2
18935: PPUSH
18936: LD_INT 21
18938: PUSH
18939: LD_INT 3
18941: PUSH
18942: EMPTY
18943: LIST
18944: LIST
18945: PPUSH
18946: CALL_OW 70
18950: ST_TO_ADDR
// if not tmp then
18951: LD_VAR 0 5
18955: NOT
18956: IFFALSE 18960
// exit ;
18958: GO 19024
// if checkLink then
18960: LD_VAR 0 3
18964: IFFALSE 19014
// begin for i in tmp do
18966: LD_ADDR_VAR 0 6
18970: PUSH
18971: LD_VAR 0 5
18975: PUSH
18976: FOR_IN
18977: IFFALSE 19012
// if GetBase ( i ) <> base then
18979: LD_VAR 0 6
18983: PPUSH
18984: CALL_OW 274
18988: PUSH
18989: LD_VAR 0 1
18993: NONEQUAL
18994: IFFALSE 19010
// ComLinkToBase ( base , i ) ;
18996: LD_VAR 0 1
19000: PPUSH
19001: LD_VAR 0 6
19005: PPUSH
19006: CALL_OW 169
19010: GO 18976
19012: POP
19013: POP
// end ; result := tmp ;
19014: LD_ADDR_VAR 0 4
19018: PUSH
19019: LD_VAR 0 5
19023: ST_TO_ADDR
// end ;
19024: LD_VAR 0 4
19028: RET
// export function ComComplete ( units , b ) ; var i ; begin
19029: LD_INT 0
19031: PPUSH
19032: PPUSH
// if not units then
19033: LD_VAR 0 1
19037: NOT
19038: IFFALSE 19042
// exit ;
19040: GO 19132
// for i in units do
19042: LD_ADDR_VAR 0 4
19046: PUSH
19047: LD_VAR 0 1
19051: PUSH
19052: FOR_IN
19053: IFFALSE 19130
// if BuildingStatus ( b ) = bs_build then
19055: LD_VAR 0 2
19059: PPUSH
19060: CALL_OW 461
19064: PUSH
19065: LD_INT 1
19067: EQUAL
19068: IFFALSE 19128
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19070: LD_VAR 0 4
19074: PPUSH
19075: LD_STRING h
19077: PUSH
19078: LD_VAR 0 2
19082: PPUSH
19083: CALL_OW 250
19087: PUSH
19088: LD_VAR 0 2
19092: PPUSH
19093: CALL_OW 251
19097: PUSH
19098: LD_VAR 0 2
19102: PUSH
19103: LD_INT 0
19105: PUSH
19106: LD_INT 0
19108: PUSH
19109: LD_INT 0
19111: PUSH
19112: EMPTY
19113: LIST
19114: LIST
19115: LIST
19116: LIST
19117: LIST
19118: LIST
19119: LIST
19120: PUSH
19121: EMPTY
19122: LIST
19123: PPUSH
19124: CALL_OW 446
19128: GO 19052
19130: POP
19131: POP
// end ;
19132: LD_VAR 0 3
19136: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19137: LD_INT 0
19139: PPUSH
19140: PPUSH
19141: PPUSH
19142: PPUSH
19143: PPUSH
19144: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19145: LD_VAR 0 1
19149: NOT
19150: PUSH
19151: LD_VAR 0 1
19155: PPUSH
19156: CALL_OW 263
19160: PUSH
19161: LD_INT 2
19163: NONEQUAL
19164: OR
19165: IFFALSE 19169
// exit ;
19167: GO 19485
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19169: LD_ADDR_VAR 0 6
19173: PUSH
19174: LD_INT 22
19176: PUSH
19177: LD_VAR 0 1
19181: PPUSH
19182: CALL_OW 255
19186: PUSH
19187: EMPTY
19188: LIST
19189: LIST
19190: PUSH
19191: LD_INT 2
19193: PUSH
19194: LD_INT 30
19196: PUSH
19197: LD_INT 36
19199: PUSH
19200: EMPTY
19201: LIST
19202: LIST
19203: PUSH
19204: LD_INT 34
19206: PUSH
19207: LD_INT 31
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: LIST
19218: PUSH
19219: EMPTY
19220: LIST
19221: LIST
19222: PPUSH
19223: CALL_OW 69
19227: ST_TO_ADDR
// if not tmp then
19228: LD_VAR 0 6
19232: NOT
19233: IFFALSE 19237
// exit ;
19235: GO 19485
// result := [ ] ;
19237: LD_ADDR_VAR 0 2
19241: PUSH
19242: EMPTY
19243: ST_TO_ADDR
// for i in tmp do
19244: LD_ADDR_VAR 0 3
19248: PUSH
19249: LD_VAR 0 6
19253: PUSH
19254: FOR_IN
19255: IFFALSE 19326
// begin t := UnitsInside ( i ) ;
19257: LD_ADDR_VAR 0 4
19261: PUSH
19262: LD_VAR 0 3
19266: PPUSH
19267: CALL_OW 313
19271: ST_TO_ADDR
// if t then
19272: LD_VAR 0 4
19276: IFFALSE 19324
// for j in t do
19278: LD_ADDR_VAR 0 7
19282: PUSH
19283: LD_VAR 0 4
19287: PUSH
19288: FOR_IN
19289: IFFALSE 19322
// result := Replace ( result , result + 1 , j ) ;
19291: LD_ADDR_VAR 0 2
19295: PUSH
19296: LD_VAR 0 2
19300: PPUSH
19301: LD_VAR 0 2
19305: PUSH
19306: LD_INT 1
19308: PLUS
19309: PPUSH
19310: LD_VAR 0 7
19314: PPUSH
19315: CALL_OW 1
19319: ST_TO_ADDR
19320: GO 19288
19322: POP
19323: POP
// end ;
19324: GO 19254
19326: POP
19327: POP
// if not result then
19328: LD_VAR 0 2
19332: NOT
19333: IFFALSE 19337
// exit ;
19335: GO 19485
// mech := result [ 1 ] ;
19337: LD_ADDR_VAR 0 5
19341: PUSH
19342: LD_VAR 0 2
19346: PUSH
19347: LD_INT 1
19349: ARRAY
19350: ST_TO_ADDR
// if result > 1 then
19351: LD_VAR 0 2
19355: PUSH
19356: LD_INT 1
19358: GREATER
19359: IFFALSE 19471
// begin for i = 2 to result do
19361: LD_ADDR_VAR 0 3
19365: PUSH
19366: DOUBLE
19367: LD_INT 2
19369: DEC
19370: ST_TO_ADDR
19371: LD_VAR 0 2
19375: PUSH
19376: FOR_TO
19377: IFFALSE 19469
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19379: LD_ADDR_VAR 0 4
19383: PUSH
19384: LD_VAR 0 2
19388: PUSH
19389: LD_VAR 0 3
19393: ARRAY
19394: PPUSH
19395: LD_INT 3
19397: PPUSH
19398: CALL_OW 259
19402: PUSH
19403: LD_VAR 0 2
19407: PUSH
19408: LD_VAR 0 3
19412: ARRAY
19413: PPUSH
19414: CALL_OW 432
19418: MINUS
19419: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19420: LD_VAR 0 4
19424: PUSH
19425: LD_VAR 0 5
19429: PPUSH
19430: LD_INT 3
19432: PPUSH
19433: CALL_OW 259
19437: PUSH
19438: LD_VAR 0 5
19442: PPUSH
19443: CALL_OW 432
19447: MINUS
19448: GREATEREQUAL
19449: IFFALSE 19467
// mech := result [ i ] ;
19451: LD_ADDR_VAR 0 5
19455: PUSH
19456: LD_VAR 0 2
19460: PUSH
19461: LD_VAR 0 3
19465: ARRAY
19466: ST_TO_ADDR
// end ;
19467: GO 19376
19469: POP
19470: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19471: LD_VAR 0 1
19475: PPUSH
19476: LD_VAR 0 5
19480: PPUSH
19481: CALL_OW 135
// end ;
19485: LD_VAR 0 2
19489: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19490: LD_INT 0
19492: PPUSH
19493: PPUSH
19494: PPUSH
19495: PPUSH
19496: PPUSH
19497: PPUSH
19498: PPUSH
19499: PPUSH
19500: PPUSH
19501: PPUSH
19502: PPUSH
19503: PPUSH
19504: PPUSH
// result := [ ] ;
19505: LD_ADDR_VAR 0 7
19509: PUSH
19510: EMPTY
19511: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19512: LD_VAR 0 1
19516: PPUSH
19517: CALL_OW 266
19521: PUSH
19522: LD_INT 0
19524: PUSH
19525: LD_INT 1
19527: PUSH
19528: EMPTY
19529: LIST
19530: LIST
19531: IN
19532: NOT
19533: IFFALSE 19537
// exit ;
19535: GO 21171
// if name then
19537: LD_VAR 0 3
19541: IFFALSE 19557
// SetBName ( base_dep , name ) ;
19543: LD_VAR 0 1
19547: PPUSH
19548: LD_VAR 0 3
19552: PPUSH
19553: CALL_OW 500
// base := GetBase ( base_dep ) ;
19557: LD_ADDR_VAR 0 15
19561: PUSH
19562: LD_VAR 0 1
19566: PPUSH
19567: CALL_OW 274
19571: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19572: LD_ADDR_VAR 0 16
19576: PUSH
19577: LD_VAR 0 1
19581: PPUSH
19582: CALL_OW 255
19586: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19587: LD_ADDR_VAR 0 17
19591: PUSH
19592: LD_VAR 0 1
19596: PPUSH
19597: CALL_OW 248
19601: ST_TO_ADDR
// if sources then
19602: LD_VAR 0 5
19606: IFFALSE 19653
// for i = 1 to 3 do
19608: LD_ADDR_VAR 0 8
19612: PUSH
19613: DOUBLE
19614: LD_INT 1
19616: DEC
19617: ST_TO_ADDR
19618: LD_INT 3
19620: PUSH
19621: FOR_TO
19622: IFFALSE 19651
// AddResourceType ( base , i , sources [ i ] ) ;
19624: LD_VAR 0 15
19628: PPUSH
19629: LD_VAR 0 8
19633: PPUSH
19634: LD_VAR 0 5
19638: PUSH
19639: LD_VAR 0 8
19643: ARRAY
19644: PPUSH
19645: CALL_OW 276
19649: GO 19621
19651: POP
19652: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19653: LD_ADDR_VAR 0 18
19657: PUSH
19658: LD_VAR 0 15
19662: PPUSH
19663: LD_VAR 0 2
19667: PPUSH
19668: LD_INT 1
19670: PPUSH
19671: CALL 18914 0 3
19675: ST_TO_ADDR
// InitHc ;
19676: CALL_OW 19
// InitUc ;
19680: CALL_OW 18
// uc_side := side ;
19684: LD_ADDR_OWVAR 20
19688: PUSH
19689: LD_VAR 0 16
19693: ST_TO_ADDR
// uc_nation := nation ;
19694: LD_ADDR_OWVAR 21
19698: PUSH
19699: LD_VAR 0 17
19703: ST_TO_ADDR
// if buildings then
19704: LD_VAR 0 18
19708: IFFALSE 21030
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19710: LD_ADDR_VAR 0 19
19714: PUSH
19715: LD_VAR 0 18
19719: PPUSH
19720: LD_INT 2
19722: PUSH
19723: LD_INT 30
19725: PUSH
19726: LD_INT 29
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: PUSH
19733: LD_INT 30
19735: PUSH
19736: LD_INT 30
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: PUSH
19743: EMPTY
19744: LIST
19745: LIST
19746: LIST
19747: PPUSH
19748: CALL_OW 72
19752: ST_TO_ADDR
// if tmp then
19753: LD_VAR 0 19
19757: IFFALSE 19805
// for i in tmp do
19759: LD_ADDR_VAR 0 8
19763: PUSH
19764: LD_VAR 0 19
19768: PUSH
19769: FOR_IN
19770: IFFALSE 19803
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19772: LD_VAR 0 8
19776: PPUSH
19777: CALL_OW 250
19781: PPUSH
19782: LD_VAR 0 8
19786: PPUSH
19787: CALL_OW 251
19791: PPUSH
19792: LD_VAR 0 16
19796: PPUSH
19797: CALL_OW 441
19801: GO 19769
19803: POP
19804: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19805: LD_VAR 0 18
19809: PPUSH
19810: LD_INT 2
19812: PUSH
19813: LD_INT 30
19815: PUSH
19816: LD_INT 32
19818: PUSH
19819: EMPTY
19820: LIST
19821: LIST
19822: PUSH
19823: LD_INT 30
19825: PUSH
19826: LD_INT 33
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: PUSH
19833: EMPTY
19834: LIST
19835: LIST
19836: LIST
19837: PPUSH
19838: CALL_OW 72
19842: IFFALSE 19930
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19844: LD_ADDR_VAR 0 8
19848: PUSH
19849: LD_VAR 0 18
19853: PPUSH
19854: LD_INT 2
19856: PUSH
19857: LD_INT 30
19859: PUSH
19860: LD_INT 32
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: PUSH
19867: LD_INT 30
19869: PUSH
19870: LD_INT 33
19872: PUSH
19873: EMPTY
19874: LIST
19875: LIST
19876: PUSH
19877: EMPTY
19878: LIST
19879: LIST
19880: LIST
19881: PPUSH
19882: CALL_OW 72
19886: PUSH
19887: FOR_IN
19888: IFFALSE 19928
// begin if not GetBWeapon ( i ) then
19890: LD_VAR 0 8
19894: PPUSH
19895: CALL_OW 269
19899: NOT
19900: IFFALSE 19926
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19902: LD_VAR 0 8
19906: PPUSH
19907: LD_VAR 0 8
19911: PPUSH
19912: LD_VAR 0 2
19916: PPUSH
19917: CALL 21176 0 2
19921: PPUSH
19922: CALL_OW 431
// end ;
19926: GO 19887
19928: POP
19929: POP
// end ; for i = 1 to personel do
19930: LD_ADDR_VAR 0 8
19934: PUSH
19935: DOUBLE
19936: LD_INT 1
19938: DEC
19939: ST_TO_ADDR
19940: LD_VAR 0 6
19944: PUSH
19945: FOR_TO
19946: IFFALSE 21010
// begin if i > 4 then
19948: LD_VAR 0 8
19952: PUSH
19953: LD_INT 4
19955: GREATER
19956: IFFALSE 19960
// break ;
19958: GO 21010
// case i of 1 :
19960: LD_VAR 0 8
19964: PUSH
19965: LD_INT 1
19967: DOUBLE
19968: EQUAL
19969: IFTRUE 19973
19971: GO 20053
19973: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19974: LD_ADDR_VAR 0 12
19978: PUSH
19979: LD_VAR 0 18
19983: PPUSH
19984: LD_INT 22
19986: PUSH
19987: LD_VAR 0 16
19991: PUSH
19992: EMPTY
19993: LIST
19994: LIST
19995: PUSH
19996: LD_INT 58
19998: PUSH
19999: EMPTY
20000: LIST
20001: PUSH
20002: LD_INT 2
20004: PUSH
20005: LD_INT 30
20007: PUSH
20008: LD_INT 32
20010: PUSH
20011: EMPTY
20012: LIST
20013: LIST
20014: PUSH
20015: LD_INT 30
20017: PUSH
20018: LD_INT 4
20020: PUSH
20021: EMPTY
20022: LIST
20023: LIST
20024: PUSH
20025: LD_INT 30
20027: PUSH
20028: LD_INT 5
20030: PUSH
20031: EMPTY
20032: LIST
20033: LIST
20034: PUSH
20035: EMPTY
20036: LIST
20037: LIST
20038: LIST
20039: LIST
20040: PUSH
20041: EMPTY
20042: LIST
20043: LIST
20044: LIST
20045: PPUSH
20046: CALL_OW 72
20050: ST_TO_ADDR
20051: GO 20275
20053: LD_INT 2
20055: DOUBLE
20056: EQUAL
20057: IFTRUE 20061
20059: GO 20123
20061: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20062: LD_ADDR_VAR 0 12
20066: PUSH
20067: LD_VAR 0 18
20071: PPUSH
20072: LD_INT 22
20074: PUSH
20075: LD_VAR 0 16
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: PUSH
20084: LD_INT 2
20086: PUSH
20087: LD_INT 30
20089: PUSH
20090: LD_INT 0
20092: PUSH
20093: EMPTY
20094: LIST
20095: LIST
20096: PUSH
20097: LD_INT 30
20099: PUSH
20100: LD_INT 1
20102: PUSH
20103: EMPTY
20104: LIST
20105: LIST
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: LIST
20111: PUSH
20112: EMPTY
20113: LIST
20114: LIST
20115: PPUSH
20116: CALL_OW 72
20120: ST_TO_ADDR
20121: GO 20275
20123: LD_INT 3
20125: DOUBLE
20126: EQUAL
20127: IFTRUE 20131
20129: GO 20193
20131: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20132: LD_ADDR_VAR 0 12
20136: PUSH
20137: LD_VAR 0 18
20141: PPUSH
20142: LD_INT 22
20144: PUSH
20145: LD_VAR 0 16
20149: PUSH
20150: EMPTY
20151: LIST
20152: LIST
20153: PUSH
20154: LD_INT 2
20156: PUSH
20157: LD_INT 30
20159: PUSH
20160: LD_INT 2
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: PUSH
20167: LD_INT 30
20169: PUSH
20170: LD_INT 3
20172: PUSH
20173: EMPTY
20174: LIST
20175: LIST
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: LIST
20181: PUSH
20182: EMPTY
20183: LIST
20184: LIST
20185: PPUSH
20186: CALL_OW 72
20190: ST_TO_ADDR
20191: GO 20275
20193: LD_INT 4
20195: DOUBLE
20196: EQUAL
20197: IFTRUE 20201
20199: GO 20274
20201: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20202: LD_ADDR_VAR 0 12
20206: PUSH
20207: LD_VAR 0 18
20211: PPUSH
20212: LD_INT 22
20214: PUSH
20215: LD_VAR 0 16
20219: PUSH
20220: EMPTY
20221: LIST
20222: LIST
20223: PUSH
20224: LD_INT 2
20226: PUSH
20227: LD_INT 30
20229: PUSH
20230: LD_INT 6
20232: PUSH
20233: EMPTY
20234: LIST
20235: LIST
20236: PUSH
20237: LD_INT 30
20239: PUSH
20240: LD_INT 7
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: PUSH
20247: LD_INT 30
20249: PUSH
20250: LD_INT 8
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: LIST
20261: LIST
20262: PUSH
20263: EMPTY
20264: LIST
20265: LIST
20266: PPUSH
20267: CALL_OW 72
20271: ST_TO_ADDR
20272: GO 20275
20274: POP
// if i = 1 then
20275: LD_VAR 0 8
20279: PUSH
20280: LD_INT 1
20282: EQUAL
20283: IFFALSE 20394
// begin tmp := [ ] ;
20285: LD_ADDR_VAR 0 19
20289: PUSH
20290: EMPTY
20291: ST_TO_ADDR
// for j in f do
20292: LD_ADDR_VAR 0 9
20296: PUSH
20297: LD_VAR 0 12
20301: PUSH
20302: FOR_IN
20303: IFFALSE 20376
// if GetBType ( j ) = b_bunker then
20305: LD_VAR 0 9
20309: PPUSH
20310: CALL_OW 266
20314: PUSH
20315: LD_INT 32
20317: EQUAL
20318: IFFALSE 20345
// tmp := Insert ( tmp , 1 , j ) else
20320: LD_ADDR_VAR 0 19
20324: PUSH
20325: LD_VAR 0 19
20329: PPUSH
20330: LD_INT 1
20332: PPUSH
20333: LD_VAR 0 9
20337: PPUSH
20338: CALL_OW 2
20342: ST_TO_ADDR
20343: GO 20374
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20345: LD_ADDR_VAR 0 19
20349: PUSH
20350: LD_VAR 0 19
20354: PPUSH
20355: LD_VAR 0 19
20359: PUSH
20360: LD_INT 1
20362: PLUS
20363: PPUSH
20364: LD_VAR 0 9
20368: PPUSH
20369: CALL_OW 2
20373: ST_TO_ADDR
20374: GO 20302
20376: POP
20377: POP
// if tmp then
20378: LD_VAR 0 19
20382: IFFALSE 20394
// f := tmp ;
20384: LD_ADDR_VAR 0 12
20388: PUSH
20389: LD_VAR 0 19
20393: ST_TO_ADDR
// end ; x := personel [ i ] ;
20394: LD_ADDR_VAR 0 13
20398: PUSH
20399: LD_VAR 0 6
20403: PUSH
20404: LD_VAR 0 8
20408: ARRAY
20409: ST_TO_ADDR
// if x = - 1 then
20410: LD_VAR 0 13
20414: PUSH
20415: LD_INT 1
20417: NEG
20418: EQUAL
20419: IFFALSE 20628
// begin for j in f do
20421: LD_ADDR_VAR 0 9
20425: PUSH
20426: LD_VAR 0 12
20430: PUSH
20431: FOR_IN
20432: IFFALSE 20624
// repeat InitHc ;
20434: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20438: LD_VAR 0 9
20442: PPUSH
20443: CALL_OW 266
20447: PUSH
20448: LD_INT 5
20450: EQUAL
20451: IFFALSE 20521
// begin if UnitsInside ( j ) < 3 then
20453: LD_VAR 0 9
20457: PPUSH
20458: CALL_OW 313
20462: PUSH
20463: LD_INT 3
20465: LESS
20466: IFFALSE 20502
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20468: LD_INT 0
20470: PPUSH
20471: LD_INT 5
20473: PUSH
20474: LD_INT 8
20476: PUSH
20477: LD_INT 9
20479: PUSH
20480: EMPTY
20481: LIST
20482: LIST
20483: LIST
20484: PUSH
20485: LD_VAR 0 17
20489: ARRAY
20490: PPUSH
20491: LD_VAR 0 4
20495: PPUSH
20496: CALL_OW 380
20500: GO 20519
// PrepareHuman ( false , i , skill ) ;
20502: LD_INT 0
20504: PPUSH
20505: LD_VAR 0 8
20509: PPUSH
20510: LD_VAR 0 4
20514: PPUSH
20515: CALL_OW 380
// end else
20519: GO 20538
// PrepareHuman ( false , i , skill ) ;
20521: LD_INT 0
20523: PPUSH
20524: LD_VAR 0 8
20528: PPUSH
20529: LD_VAR 0 4
20533: PPUSH
20534: CALL_OW 380
// un := CreateHuman ;
20538: LD_ADDR_VAR 0 14
20542: PUSH
20543: CALL_OW 44
20547: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20548: LD_ADDR_VAR 0 7
20552: PUSH
20553: LD_VAR 0 7
20557: PPUSH
20558: LD_INT 1
20560: PPUSH
20561: LD_VAR 0 14
20565: PPUSH
20566: CALL_OW 2
20570: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20571: LD_VAR 0 14
20575: PPUSH
20576: LD_VAR 0 9
20580: PPUSH
20581: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20585: LD_VAR 0 9
20589: PPUSH
20590: CALL_OW 313
20594: PUSH
20595: LD_INT 6
20597: EQUAL
20598: PUSH
20599: LD_VAR 0 9
20603: PPUSH
20604: CALL_OW 266
20608: PUSH
20609: LD_INT 32
20611: PUSH
20612: LD_INT 31
20614: PUSH
20615: EMPTY
20616: LIST
20617: LIST
20618: IN
20619: OR
20620: IFFALSE 20434
20622: GO 20431
20624: POP
20625: POP
// end else
20626: GO 21008
// for j = 1 to x do
20628: LD_ADDR_VAR 0 9
20632: PUSH
20633: DOUBLE
20634: LD_INT 1
20636: DEC
20637: ST_TO_ADDR
20638: LD_VAR 0 13
20642: PUSH
20643: FOR_TO
20644: IFFALSE 21006
// begin InitHc ;
20646: CALL_OW 19
// if not f then
20650: LD_VAR 0 12
20654: NOT
20655: IFFALSE 20744
// begin PrepareHuman ( false , i , skill ) ;
20657: LD_INT 0
20659: PPUSH
20660: LD_VAR 0 8
20664: PPUSH
20665: LD_VAR 0 4
20669: PPUSH
20670: CALL_OW 380
// un := CreateHuman ;
20674: LD_ADDR_VAR 0 14
20678: PUSH
20679: CALL_OW 44
20683: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20684: LD_ADDR_VAR 0 7
20688: PUSH
20689: LD_VAR 0 7
20693: PPUSH
20694: LD_INT 1
20696: PPUSH
20697: LD_VAR 0 14
20701: PPUSH
20702: CALL_OW 2
20706: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20707: LD_VAR 0 14
20711: PPUSH
20712: LD_VAR 0 1
20716: PPUSH
20717: CALL_OW 250
20721: PPUSH
20722: LD_VAR 0 1
20726: PPUSH
20727: CALL_OW 251
20731: PPUSH
20732: LD_INT 10
20734: PPUSH
20735: LD_INT 0
20737: PPUSH
20738: CALL_OW 50
// continue ;
20742: GO 20643
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20744: LD_VAR 0 12
20748: PUSH
20749: LD_INT 1
20751: ARRAY
20752: PPUSH
20753: CALL_OW 313
20757: PUSH
20758: LD_VAR 0 12
20762: PUSH
20763: LD_INT 1
20765: ARRAY
20766: PPUSH
20767: CALL_OW 266
20771: PUSH
20772: LD_INT 32
20774: PUSH
20775: LD_INT 31
20777: PUSH
20778: EMPTY
20779: LIST
20780: LIST
20781: IN
20782: AND
20783: PUSH
20784: LD_VAR 0 12
20788: PUSH
20789: LD_INT 1
20791: ARRAY
20792: PPUSH
20793: CALL_OW 313
20797: PUSH
20798: LD_INT 6
20800: EQUAL
20801: OR
20802: IFFALSE 20822
// f := Delete ( f , 1 ) ;
20804: LD_ADDR_VAR 0 12
20808: PUSH
20809: LD_VAR 0 12
20813: PPUSH
20814: LD_INT 1
20816: PPUSH
20817: CALL_OW 3
20821: ST_TO_ADDR
// if not f then
20822: LD_VAR 0 12
20826: NOT
20827: IFFALSE 20845
// begin x := x + 2 ;
20829: LD_ADDR_VAR 0 13
20833: PUSH
20834: LD_VAR 0 13
20838: PUSH
20839: LD_INT 2
20841: PLUS
20842: ST_TO_ADDR
// continue ;
20843: GO 20643
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20845: LD_VAR 0 12
20849: PUSH
20850: LD_INT 1
20852: ARRAY
20853: PPUSH
20854: CALL_OW 266
20858: PUSH
20859: LD_INT 5
20861: EQUAL
20862: IFFALSE 20936
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20864: LD_VAR 0 12
20868: PUSH
20869: LD_INT 1
20871: ARRAY
20872: PPUSH
20873: CALL_OW 313
20877: PUSH
20878: LD_INT 3
20880: LESS
20881: IFFALSE 20917
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20883: LD_INT 0
20885: PPUSH
20886: LD_INT 5
20888: PUSH
20889: LD_INT 8
20891: PUSH
20892: LD_INT 9
20894: PUSH
20895: EMPTY
20896: LIST
20897: LIST
20898: LIST
20899: PUSH
20900: LD_VAR 0 17
20904: ARRAY
20905: PPUSH
20906: LD_VAR 0 4
20910: PPUSH
20911: CALL_OW 380
20915: GO 20934
// PrepareHuman ( false , i , skill ) ;
20917: LD_INT 0
20919: PPUSH
20920: LD_VAR 0 8
20924: PPUSH
20925: LD_VAR 0 4
20929: PPUSH
20930: CALL_OW 380
// end else
20934: GO 20953
// PrepareHuman ( false , i , skill ) ;
20936: LD_INT 0
20938: PPUSH
20939: LD_VAR 0 8
20943: PPUSH
20944: LD_VAR 0 4
20948: PPUSH
20949: CALL_OW 380
// un := CreateHuman ;
20953: LD_ADDR_VAR 0 14
20957: PUSH
20958: CALL_OW 44
20962: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20963: LD_ADDR_VAR 0 7
20967: PUSH
20968: LD_VAR 0 7
20972: PPUSH
20973: LD_INT 1
20975: PPUSH
20976: LD_VAR 0 14
20980: PPUSH
20981: CALL_OW 2
20985: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20986: LD_VAR 0 14
20990: PPUSH
20991: LD_VAR 0 12
20995: PUSH
20996: LD_INT 1
20998: ARRAY
20999: PPUSH
21000: CALL_OW 52
// end ;
21004: GO 20643
21006: POP
21007: POP
// end ;
21008: GO 19945
21010: POP
21011: POP
// result := result ^ buildings ;
21012: LD_ADDR_VAR 0 7
21016: PUSH
21017: LD_VAR 0 7
21021: PUSH
21022: LD_VAR 0 18
21026: ADD
21027: ST_TO_ADDR
// end else
21028: GO 21171
// begin for i = 1 to personel do
21030: LD_ADDR_VAR 0 8
21034: PUSH
21035: DOUBLE
21036: LD_INT 1
21038: DEC
21039: ST_TO_ADDR
21040: LD_VAR 0 6
21044: PUSH
21045: FOR_TO
21046: IFFALSE 21169
// begin if i > 4 then
21048: LD_VAR 0 8
21052: PUSH
21053: LD_INT 4
21055: GREATER
21056: IFFALSE 21060
// break ;
21058: GO 21169
// x := personel [ i ] ;
21060: LD_ADDR_VAR 0 13
21064: PUSH
21065: LD_VAR 0 6
21069: PUSH
21070: LD_VAR 0 8
21074: ARRAY
21075: ST_TO_ADDR
// if x = - 1 then
21076: LD_VAR 0 13
21080: PUSH
21081: LD_INT 1
21083: NEG
21084: EQUAL
21085: IFFALSE 21089
// continue ;
21087: GO 21045
// PrepareHuman ( false , i , skill ) ;
21089: LD_INT 0
21091: PPUSH
21092: LD_VAR 0 8
21096: PPUSH
21097: LD_VAR 0 4
21101: PPUSH
21102: CALL_OW 380
// un := CreateHuman ;
21106: LD_ADDR_VAR 0 14
21110: PUSH
21111: CALL_OW 44
21115: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21116: LD_VAR 0 14
21120: PPUSH
21121: LD_VAR 0 1
21125: PPUSH
21126: CALL_OW 250
21130: PPUSH
21131: LD_VAR 0 1
21135: PPUSH
21136: CALL_OW 251
21140: PPUSH
21141: LD_INT 10
21143: PPUSH
21144: LD_INT 0
21146: PPUSH
21147: CALL_OW 50
// result := result ^ un ;
21151: LD_ADDR_VAR 0 7
21155: PUSH
21156: LD_VAR 0 7
21160: PUSH
21161: LD_VAR 0 14
21165: ADD
21166: ST_TO_ADDR
// end ;
21167: GO 21045
21169: POP
21170: POP
// end ; end ;
21171: LD_VAR 0 7
21175: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21176: LD_INT 0
21178: PPUSH
21179: PPUSH
21180: PPUSH
21181: PPUSH
21182: PPUSH
21183: PPUSH
21184: PPUSH
21185: PPUSH
21186: PPUSH
21187: PPUSH
21188: PPUSH
21189: PPUSH
21190: PPUSH
21191: PPUSH
21192: PPUSH
21193: PPUSH
// result := false ;
21194: LD_ADDR_VAR 0 3
21198: PUSH
21199: LD_INT 0
21201: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21202: LD_VAR 0 1
21206: NOT
21207: PUSH
21208: LD_VAR 0 1
21212: PPUSH
21213: CALL_OW 266
21217: PUSH
21218: LD_INT 32
21220: PUSH
21221: LD_INT 33
21223: PUSH
21224: EMPTY
21225: LIST
21226: LIST
21227: IN
21228: NOT
21229: OR
21230: IFFALSE 21234
// exit ;
21232: GO 22343
// nat := GetNation ( tower ) ;
21234: LD_ADDR_VAR 0 12
21238: PUSH
21239: LD_VAR 0 1
21243: PPUSH
21244: CALL_OW 248
21248: ST_TO_ADDR
// side := GetSide ( tower ) ;
21249: LD_ADDR_VAR 0 16
21253: PUSH
21254: LD_VAR 0 1
21258: PPUSH
21259: CALL_OW 255
21263: ST_TO_ADDR
// x := GetX ( tower ) ;
21264: LD_ADDR_VAR 0 10
21268: PUSH
21269: LD_VAR 0 1
21273: PPUSH
21274: CALL_OW 250
21278: ST_TO_ADDR
// y := GetY ( tower ) ;
21279: LD_ADDR_VAR 0 11
21283: PUSH
21284: LD_VAR 0 1
21288: PPUSH
21289: CALL_OW 251
21293: ST_TO_ADDR
// if not x or not y then
21294: LD_VAR 0 10
21298: NOT
21299: PUSH
21300: LD_VAR 0 11
21304: NOT
21305: OR
21306: IFFALSE 21310
// exit ;
21308: GO 22343
// weapon := 0 ;
21310: LD_ADDR_VAR 0 18
21314: PUSH
21315: LD_INT 0
21317: ST_TO_ADDR
// fac_list := [ ] ;
21318: LD_ADDR_VAR 0 17
21322: PUSH
21323: EMPTY
21324: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21325: LD_ADDR_VAR 0 6
21329: PUSH
21330: LD_VAR 0 1
21334: PPUSH
21335: CALL_OW 274
21339: PPUSH
21340: LD_VAR 0 2
21344: PPUSH
21345: LD_INT 0
21347: PPUSH
21348: CALL 18914 0 3
21352: PPUSH
21353: LD_INT 30
21355: PUSH
21356: LD_INT 3
21358: PUSH
21359: EMPTY
21360: LIST
21361: LIST
21362: PPUSH
21363: CALL_OW 72
21367: ST_TO_ADDR
// if not factories then
21368: LD_VAR 0 6
21372: NOT
21373: IFFALSE 21377
// exit ;
21375: GO 22343
// for i in factories do
21377: LD_ADDR_VAR 0 8
21381: PUSH
21382: LD_VAR 0 6
21386: PUSH
21387: FOR_IN
21388: IFFALSE 21413
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21390: LD_ADDR_VAR 0 17
21394: PUSH
21395: LD_VAR 0 17
21399: PUSH
21400: LD_VAR 0 8
21404: PPUSH
21405: CALL_OW 478
21409: UNION
21410: ST_TO_ADDR
21411: GO 21387
21413: POP
21414: POP
// if not fac_list then
21415: LD_VAR 0 17
21419: NOT
21420: IFFALSE 21424
// exit ;
21422: GO 22343
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21424: LD_ADDR_VAR 0 5
21428: PUSH
21429: LD_INT 4
21431: PUSH
21432: LD_INT 5
21434: PUSH
21435: LD_INT 9
21437: PUSH
21438: LD_INT 10
21440: PUSH
21441: LD_INT 6
21443: PUSH
21444: LD_INT 7
21446: PUSH
21447: LD_INT 11
21449: PUSH
21450: EMPTY
21451: LIST
21452: LIST
21453: LIST
21454: LIST
21455: LIST
21456: LIST
21457: LIST
21458: PUSH
21459: LD_INT 27
21461: PUSH
21462: LD_INT 28
21464: PUSH
21465: LD_INT 26
21467: PUSH
21468: LD_INT 30
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 43
21479: PUSH
21480: LD_INT 44
21482: PUSH
21483: LD_INT 46
21485: PUSH
21486: LD_INT 45
21488: PUSH
21489: LD_INT 47
21491: PUSH
21492: LD_INT 49
21494: PUSH
21495: EMPTY
21496: LIST
21497: LIST
21498: LIST
21499: LIST
21500: LIST
21501: LIST
21502: PUSH
21503: EMPTY
21504: LIST
21505: LIST
21506: LIST
21507: PUSH
21508: LD_VAR 0 12
21512: ARRAY
21513: ST_TO_ADDR
// list := list isect fac_list ;
21514: LD_ADDR_VAR 0 5
21518: PUSH
21519: LD_VAR 0 5
21523: PUSH
21524: LD_VAR 0 17
21528: ISECT
21529: ST_TO_ADDR
// if not list then
21530: LD_VAR 0 5
21534: NOT
21535: IFFALSE 21539
// exit ;
21537: GO 22343
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21539: LD_VAR 0 12
21543: PUSH
21544: LD_INT 3
21546: EQUAL
21547: PUSH
21548: LD_INT 49
21550: PUSH
21551: LD_VAR 0 5
21555: IN
21556: AND
21557: PUSH
21558: LD_INT 31
21560: PPUSH
21561: LD_VAR 0 16
21565: PPUSH
21566: CALL_OW 321
21570: PUSH
21571: LD_INT 2
21573: EQUAL
21574: AND
21575: IFFALSE 21635
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21577: LD_INT 22
21579: PUSH
21580: LD_VAR 0 16
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 35
21591: PUSH
21592: LD_INT 49
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: PUSH
21599: LD_INT 91
21601: PUSH
21602: LD_VAR 0 1
21606: PUSH
21607: LD_INT 10
21609: PUSH
21610: EMPTY
21611: LIST
21612: LIST
21613: LIST
21614: PUSH
21615: EMPTY
21616: LIST
21617: LIST
21618: LIST
21619: PPUSH
21620: CALL_OW 69
21624: NOT
21625: IFFALSE 21635
// weapon := ru_time_lapser ;
21627: LD_ADDR_VAR 0 18
21631: PUSH
21632: LD_INT 49
21634: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21635: LD_VAR 0 12
21639: PUSH
21640: LD_INT 1
21642: PUSH
21643: LD_INT 2
21645: PUSH
21646: EMPTY
21647: LIST
21648: LIST
21649: IN
21650: PUSH
21651: LD_INT 11
21653: PUSH
21654: LD_VAR 0 5
21658: IN
21659: PUSH
21660: LD_INT 30
21662: PUSH
21663: LD_VAR 0 5
21667: IN
21668: OR
21669: AND
21670: PUSH
21671: LD_INT 6
21673: PPUSH
21674: LD_VAR 0 16
21678: PPUSH
21679: CALL_OW 321
21683: PUSH
21684: LD_INT 2
21686: EQUAL
21687: AND
21688: IFFALSE 21853
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21690: LD_INT 22
21692: PUSH
21693: LD_VAR 0 16
21697: PUSH
21698: EMPTY
21699: LIST
21700: LIST
21701: PUSH
21702: LD_INT 2
21704: PUSH
21705: LD_INT 35
21707: PUSH
21708: LD_INT 11
21710: PUSH
21711: EMPTY
21712: LIST
21713: LIST
21714: PUSH
21715: LD_INT 35
21717: PUSH
21718: LD_INT 30
21720: PUSH
21721: EMPTY
21722: LIST
21723: LIST
21724: PUSH
21725: EMPTY
21726: LIST
21727: LIST
21728: LIST
21729: PUSH
21730: LD_INT 91
21732: PUSH
21733: LD_VAR 0 1
21737: PUSH
21738: LD_INT 18
21740: PUSH
21741: EMPTY
21742: LIST
21743: LIST
21744: LIST
21745: PUSH
21746: EMPTY
21747: LIST
21748: LIST
21749: LIST
21750: PPUSH
21751: CALL_OW 69
21755: NOT
21756: PUSH
21757: LD_INT 22
21759: PUSH
21760: LD_VAR 0 16
21764: PUSH
21765: EMPTY
21766: LIST
21767: LIST
21768: PUSH
21769: LD_INT 2
21771: PUSH
21772: LD_INT 30
21774: PUSH
21775: LD_INT 32
21777: PUSH
21778: EMPTY
21779: LIST
21780: LIST
21781: PUSH
21782: LD_INT 30
21784: PUSH
21785: LD_INT 33
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: LIST
21796: PUSH
21797: LD_INT 91
21799: PUSH
21800: LD_VAR 0 1
21804: PUSH
21805: LD_INT 12
21807: PUSH
21808: EMPTY
21809: LIST
21810: LIST
21811: LIST
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: LIST
21817: PUSH
21818: EMPTY
21819: LIST
21820: PPUSH
21821: CALL_OW 69
21825: PUSH
21826: LD_INT 2
21828: GREATER
21829: AND
21830: IFFALSE 21853
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21832: LD_ADDR_VAR 0 18
21836: PUSH
21837: LD_INT 11
21839: PUSH
21840: LD_INT 30
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: PUSH
21847: LD_VAR 0 12
21851: ARRAY
21852: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21853: LD_VAR 0 18
21857: NOT
21858: PUSH
21859: LD_INT 40
21861: PPUSH
21862: LD_VAR 0 16
21866: PPUSH
21867: CALL_OW 321
21871: PUSH
21872: LD_INT 2
21874: EQUAL
21875: AND
21876: PUSH
21877: LD_INT 7
21879: PUSH
21880: LD_VAR 0 5
21884: IN
21885: PUSH
21886: LD_INT 28
21888: PUSH
21889: LD_VAR 0 5
21893: IN
21894: OR
21895: PUSH
21896: LD_INT 45
21898: PUSH
21899: LD_VAR 0 5
21903: IN
21904: OR
21905: AND
21906: IFFALSE 22160
// begin hex := GetHexInfo ( x , y ) ;
21908: LD_ADDR_VAR 0 4
21912: PUSH
21913: LD_VAR 0 10
21917: PPUSH
21918: LD_VAR 0 11
21922: PPUSH
21923: CALL_OW 546
21927: ST_TO_ADDR
// if hex [ 1 ] then
21928: LD_VAR 0 4
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: IFFALSE 21940
// exit ;
21938: GO 22343
// height := hex [ 2 ] ;
21940: LD_ADDR_VAR 0 15
21944: PUSH
21945: LD_VAR 0 4
21949: PUSH
21950: LD_INT 2
21952: ARRAY
21953: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21954: LD_ADDR_VAR 0 14
21958: PUSH
21959: LD_INT 0
21961: PUSH
21962: LD_INT 2
21964: PUSH
21965: LD_INT 3
21967: PUSH
21968: LD_INT 5
21970: PUSH
21971: EMPTY
21972: LIST
21973: LIST
21974: LIST
21975: LIST
21976: ST_TO_ADDR
// for i in tmp do
21977: LD_ADDR_VAR 0 8
21981: PUSH
21982: LD_VAR 0 14
21986: PUSH
21987: FOR_IN
21988: IFFALSE 22158
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21990: LD_ADDR_VAR 0 9
21994: PUSH
21995: LD_VAR 0 10
21999: PPUSH
22000: LD_VAR 0 8
22004: PPUSH
22005: LD_INT 5
22007: PPUSH
22008: CALL_OW 272
22012: PUSH
22013: LD_VAR 0 11
22017: PPUSH
22018: LD_VAR 0 8
22022: PPUSH
22023: LD_INT 5
22025: PPUSH
22026: CALL_OW 273
22030: PUSH
22031: EMPTY
22032: LIST
22033: LIST
22034: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22035: LD_VAR 0 9
22039: PUSH
22040: LD_INT 1
22042: ARRAY
22043: PPUSH
22044: LD_VAR 0 9
22048: PUSH
22049: LD_INT 2
22051: ARRAY
22052: PPUSH
22053: CALL_OW 488
22057: IFFALSE 22156
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22059: LD_ADDR_VAR 0 4
22063: PUSH
22064: LD_VAR 0 9
22068: PUSH
22069: LD_INT 1
22071: ARRAY
22072: PPUSH
22073: LD_VAR 0 9
22077: PUSH
22078: LD_INT 2
22080: ARRAY
22081: PPUSH
22082: CALL_OW 546
22086: ST_TO_ADDR
// if hex [ 1 ] then
22087: LD_VAR 0 4
22091: PUSH
22092: LD_INT 1
22094: ARRAY
22095: IFFALSE 22099
// continue ;
22097: GO 21987
// h := hex [ 2 ] ;
22099: LD_ADDR_VAR 0 13
22103: PUSH
22104: LD_VAR 0 4
22108: PUSH
22109: LD_INT 2
22111: ARRAY
22112: ST_TO_ADDR
// if h + 7 < height then
22113: LD_VAR 0 13
22117: PUSH
22118: LD_INT 7
22120: PLUS
22121: PUSH
22122: LD_VAR 0 15
22126: LESS
22127: IFFALSE 22156
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22129: LD_ADDR_VAR 0 18
22133: PUSH
22134: LD_INT 7
22136: PUSH
22137: LD_INT 28
22139: PUSH
22140: LD_INT 45
22142: PUSH
22143: EMPTY
22144: LIST
22145: LIST
22146: LIST
22147: PUSH
22148: LD_VAR 0 12
22152: ARRAY
22153: ST_TO_ADDR
// break ;
22154: GO 22158
// end ; end ; end ;
22156: GO 21987
22158: POP
22159: POP
// end ; if not weapon then
22160: LD_VAR 0 18
22164: NOT
22165: IFFALSE 22225
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22167: LD_ADDR_VAR 0 5
22171: PUSH
22172: LD_VAR 0 5
22176: PUSH
22177: LD_INT 11
22179: PUSH
22180: LD_INT 30
22182: PUSH
22183: LD_INT 49
22185: PUSH
22186: EMPTY
22187: LIST
22188: LIST
22189: LIST
22190: DIFF
22191: ST_TO_ADDR
// if not list then
22192: LD_VAR 0 5
22196: NOT
22197: IFFALSE 22201
// exit ;
22199: GO 22343
// weapon := list [ rand ( 1 , list ) ] ;
22201: LD_ADDR_VAR 0 18
22205: PUSH
22206: LD_VAR 0 5
22210: PUSH
22211: LD_INT 1
22213: PPUSH
22214: LD_VAR 0 5
22218: PPUSH
22219: CALL_OW 12
22223: ARRAY
22224: ST_TO_ADDR
// end ; if weapon then
22225: LD_VAR 0 18
22229: IFFALSE 22343
// begin tmp := CostOfWeapon ( weapon ) ;
22231: LD_ADDR_VAR 0 14
22235: PUSH
22236: LD_VAR 0 18
22240: PPUSH
22241: CALL_OW 451
22245: ST_TO_ADDR
// j := GetBase ( tower ) ;
22246: LD_ADDR_VAR 0 9
22250: PUSH
22251: LD_VAR 0 1
22255: PPUSH
22256: CALL_OW 274
22260: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22261: LD_VAR 0 9
22265: PPUSH
22266: LD_INT 1
22268: PPUSH
22269: CALL_OW 275
22273: PUSH
22274: LD_VAR 0 14
22278: PUSH
22279: LD_INT 1
22281: ARRAY
22282: GREATEREQUAL
22283: PUSH
22284: LD_VAR 0 9
22288: PPUSH
22289: LD_INT 2
22291: PPUSH
22292: CALL_OW 275
22296: PUSH
22297: LD_VAR 0 14
22301: PUSH
22302: LD_INT 2
22304: ARRAY
22305: GREATEREQUAL
22306: AND
22307: PUSH
22308: LD_VAR 0 9
22312: PPUSH
22313: LD_INT 3
22315: PPUSH
22316: CALL_OW 275
22320: PUSH
22321: LD_VAR 0 14
22325: PUSH
22326: LD_INT 3
22328: ARRAY
22329: GREATEREQUAL
22330: AND
22331: IFFALSE 22343
// result := weapon ;
22333: LD_ADDR_VAR 0 3
22337: PUSH
22338: LD_VAR 0 18
22342: ST_TO_ADDR
// end ; end ;
22343: LD_VAR 0 3
22347: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22348: LD_INT 0
22350: PPUSH
22351: PPUSH
// result := true ;
22352: LD_ADDR_VAR 0 3
22356: PUSH
22357: LD_INT 1
22359: ST_TO_ADDR
// if array1 = array2 then
22360: LD_VAR 0 1
22364: PUSH
22365: LD_VAR 0 2
22369: EQUAL
22370: IFFALSE 22430
// begin for i = 1 to array1 do
22372: LD_ADDR_VAR 0 4
22376: PUSH
22377: DOUBLE
22378: LD_INT 1
22380: DEC
22381: ST_TO_ADDR
22382: LD_VAR 0 1
22386: PUSH
22387: FOR_TO
22388: IFFALSE 22426
// if array1 [ i ] <> array2 [ i ] then
22390: LD_VAR 0 1
22394: PUSH
22395: LD_VAR 0 4
22399: ARRAY
22400: PUSH
22401: LD_VAR 0 2
22405: PUSH
22406: LD_VAR 0 4
22410: ARRAY
22411: NONEQUAL
22412: IFFALSE 22424
// begin result := false ;
22414: LD_ADDR_VAR 0 3
22418: PUSH
22419: LD_INT 0
22421: ST_TO_ADDR
// break ;
22422: GO 22426
// end ;
22424: GO 22387
22426: POP
22427: POP
// end else
22428: GO 22438
// result := false ;
22430: LD_ADDR_VAR 0 3
22434: PUSH
22435: LD_INT 0
22437: ST_TO_ADDR
// end ;
22438: LD_VAR 0 3
22442: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22443: LD_INT 0
22445: PPUSH
22446: PPUSH
// if not array1 or not array2 then
22447: LD_VAR 0 1
22451: NOT
22452: PUSH
22453: LD_VAR 0 2
22457: NOT
22458: OR
22459: IFFALSE 22463
// exit ;
22461: GO 22527
// result := true ;
22463: LD_ADDR_VAR 0 3
22467: PUSH
22468: LD_INT 1
22470: ST_TO_ADDR
// for i = 1 to array1 do
22471: LD_ADDR_VAR 0 4
22475: PUSH
22476: DOUBLE
22477: LD_INT 1
22479: DEC
22480: ST_TO_ADDR
22481: LD_VAR 0 1
22485: PUSH
22486: FOR_TO
22487: IFFALSE 22525
// if array1 [ i ] <> array2 [ i ] then
22489: LD_VAR 0 1
22493: PUSH
22494: LD_VAR 0 4
22498: ARRAY
22499: PUSH
22500: LD_VAR 0 2
22504: PUSH
22505: LD_VAR 0 4
22509: ARRAY
22510: NONEQUAL
22511: IFFALSE 22523
// begin result := false ;
22513: LD_ADDR_VAR 0 3
22517: PUSH
22518: LD_INT 0
22520: ST_TO_ADDR
// break ;
22521: GO 22525
// end ;
22523: GO 22486
22525: POP
22526: POP
// end ;
22527: LD_VAR 0 3
22531: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22532: LD_INT 0
22534: PPUSH
22535: PPUSH
22536: PPUSH
// pom := GetBase ( fac ) ;
22537: LD_ADDR_VAR 0 5
22541: PUSH
22542: LD_VAR 0 1
22546: PPUSH
22547: CALL_OW 274
22551: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22552: LD_ADDR_VAR 0 4
22556: PUSH
22557: LD_VAR 0 2
22561: PUSH
22562: LD_INT 1
22564: ARRAY
22565: PPUSH
22566: LD_VAR 0 2
22570: PUSH
22571: LD_INT 2
22573: ARRAY
22574: PPUSH
22575: LD_VAR 0 2
22579: PUSH
22580: LD_INT 3
22582: ARRAY
22583: PPUSH
22584: LD_VAR 0 2
22588: PUSH
22589: LD_INT 4
22591: ARRAY
22592: PPUSH
22593: CALL_OW 449
22597: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22598: LD_ADDR_VAR 0 3
22602: PUSH
22603: LD_VAR 0 5
22607: PPUSH
22608: LD_INT 1
22610: PPUSH
22611: CALL_OW 275
22615: PUSH
22616: LD_VAR 0 4
22620: PUSH
22621: LD_INT 1
22623: ARRAY
22624: GREATEREQUAL
22625: PUSH
22626: LD_VAR 0 5
22630: PPUSH
22631: LD_INT 2
22633: PPUSH
22634: CALL_OW 275
22638: PUSH
22639: LD_VAR 0 4
22643: PUSH
22644: LD_INT 2
22646: ARRAY
22647: GREATEREQUAL
22648: AND
22649: PUSH
22650: LD_VAR 0 5
22654: PPUSH
22655: LD_INT 3
22657: PPUSH
22658: CALL_OW 275
22662: PUSH
22663: LD_VAR 0 4
22667: PUSH
22668: LD_INT 3
22670: ARRAY
22671: GREATEREQUAL
22672: AND
22673: ST_TO_ADDR
// end ;
22674: LD_VAR 0 3
22678: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22679: LD_INT 0
22681: PPUSH
22682: PPUSH
22683: PPUSH
22684: PPUSH
// pom := GetBase ( building ) ;
22685: LD_ADDR_VAR 0 3
22689: PUSH
22690: LD_VAR 0 1
22694: PPUSH
22695: CALL_OW 274
22699: ST_TO_ADDR
// if not pom then
22700: LD_VAR 0 3
22704: NOT
22705: IFFALSE 22709
// exit ;
22707: GO 22879
// btype := GetBType ( building ) ;
22709: LD_ADDR_VAR 0 5
22713: PUSH
22714: LD_VAR 0 1
22718: PPUSH
22719: CALL_OW 266
22723: ST_TO_ADDR
// if btype = b_armoury then
22724: LD_VAR 0 5
22728: PUSH
22729: LD_INT 4
22731: EQUAL
22732: IFFALSE 22742
// btype := b_barracks ;
22734: LD_ADDR_VAR 0 5
22738: PUSH
22739: LD_INT 5
22741: ST_TO_ADDR
// if btype = b_depot then
22742: LD_VAR 0 5
22746: PUSH
22747: LD_INT 0
22749: EQUAL
22750: IFFALSE 22760
// btype := b_warehouse ;
22752: LD_ADDR_VAR 0 5
22756: PUSH
22757: LD_INT 1
22759: ST_TO_ADDR
// if btype = b_workshop then
22760: LD_VAR 0 5
22764: PUSH
22765: LD_INT 2
22767: EQUAL
22768: IFFALSE 22778
// btype := b_factory ;
22770: LD_ADDR_VAR 0 5
22774: PUSH
22775: LD_INT 3
22777: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22778: LD_ADDR_VAR 0 4
22782: PUSH
22783: LD_VAR 0 5
22787: PPUSH
22788: LD_VAR 0 1
22792: PPUSH
22793: CALL_OW 248
22797: PPUSH
22798: CALL_OW 450
22802: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22803: LD_ADDR_VAR 0 2
22807: PUSH
22808: LD_VAR 0 3
22812: PPUSH
22813: LD_INT 1
22815: PPUSH
22816: CALL_OW 275
22820: PUSH
22821: LD_VAR 0 4
22825: PUSH
22826: LD_INT 1
22828: ARRAY
22829: GREATEREQUAL
22830: PUSH
22831: LD_VAR 0 3
22835: PPUSH
22836: LD_INT 2
22838: PPUSH
22839: CALL_OW 275
22843: PUSH
22844: LD_VAR 0 4
22848: PUSH
22849: LD_INT 2
22851: ARRAY
22852: GREATEREQUAL
22853: AND
22854: PUSH
22855: LD_VAR 0 3
22859: PPUSH
22860: LD_INT 3
22862: PPUSH
22863: CALL_OW 275
22867: PUSH
22868: LD_VAR 0 4
22872: PUSH
22873: LD_INT 3
22875: ARRAY
22876: GREATEREQUAL
22877: AND
22878: ST_TO_ADDR
// end ;
22879: LD_VAR 0 2
22883: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22884: LD_INT 0
22886: PPUSH
22887: PPUSH
22888: PPUSH
// pom := GetBase ( building ) ;
22889: LD_ADDR_VAR 0 4
22893: PUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 274
22903: ST_TO_ADDR
// if not pom then
22904: LD_VAR 0 4
22908: NOT
22909: IFFALSE 22913
// exit ;
22911: GO 23014
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22913: LD_ADDR_VAR 0 5
22917: PUSH
22918: LD_VAR 0 2
22922: PPUSH
22923: LD_VAR 0 1
22927: PPUSH
22928: CALL_OW 248
22932: PPUSH
22933: CALL_OW 450
22937: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22938: LD_ADDR_VAR 0 3
22942: PUSH
22943: LD_VAR 0 4
22947: PPUSH
22948: LD_INT 1
22950: PPUSH
22951: CALL_OW 275
22955: PUSH
22956: LD_VAR 0 5
22960: PUSH
22961: LD_INT 1
22963: ARRAY
22964: GREATEREQUAL
22965: PUSH
22966: LD_VAR 0 4
22970: PPUSH
22971: LD_INT 2
22973: PPUSH
22974: CALL_OW 275
22978: PUSH
22979: LD_VAR 0 5
22983: PUSH
22984: LD_INT 2
22986: ARRAY
22987: GREATEREQUAL
22988: AND
22989: PUSH
22990: LD_VAR 0 4
22994: PPUSH
22995: LD_INT 3
22997: PPUSH
22998: CALL_OW 275
23002: PUSH
23003: LD_VAR 0 5
23007: PUSH
23008: LD_INT 3
23010: ARRAY
23011: GREATEREQUAL
23012: AND
23013: ST_TO_ADDR
// end ;
23014: LD_VAR 0 3
23018: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23019: LD_INT 0
23021: PPUSH
23022: PPUSH
23023: PPUSH
23024: PPUSH
23025: PPUSH
23026: PPUSH
23027: PPUSH
23028: PPUSH
23029: PPUSH
23030: PPUSH
23031: PPUSH
// result := false ;
23032: LD_ADDR_VAR 0 8
23036: PUSH
23037: LD_INT 0
23039: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23040: LD_VAR 0 5
23044: NOT
23045: PUSH
23046: LD_VAR 0 1
23050: NOT
23051: OR
23052: PUSH
23053: LD_VAR 0 2
23057: NOT
23058: OR
23059: PUSH
23060: LD_VAR 0 3
23064: NOT
23065: OR
23066: IFFALSE 23070
// exit ;
23068: GO 23884
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23070: LD_ADDR_VAR 0 14
23074: PUSH
23075: LD_VAR 0 1
23079: PPUSH
23080: LD_VAR 0 2
23084: PPUSH
23085: LD_VAR 0 3
23089: PPUSH
23090: LD_VAR 0 4
23094: PPUSH
23095: LD_VAR 0 5
23099: PUSH
23100: LD_INT 1
23102: ARRAY
23103: PPUSH
23104: CALL_OW 248
23108: PPUSH
23109: LD_INT 0
23111: PPUSH
23112: CALL 25121 0 6
23116: ST_TO_ADDR
// if not hexes then
23117: LD_VAR 0 14
23121: NOT
23122: IFFALSE 23126
// exit ;
23124: GO 23884
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23126: LD_ADDR_VAR 0 17
23130: PUSH
23131: LD_VAR 0 5
23135: PPUSH
23136: LD_INT 22
23138: PUSH
23139: LD_VAR 0 13
23143: PPUSH
23144: CALL_OW 255
23148: PUSH
23149: EMPTY
23150: LIST
23151: LIST
23152: PUSH
23153: LD_INT 2
23155: PUSH
23156: LD_INT 30
23158: PUSH
23159: LD_INT 0
23161: PUSH
23162: EMPTY
23163: LIST
23164: LIST
23165: PUSH
23166: LD_INT 30
23168: PUSH
23169: LD_INT 1
23171: PUSH
23172: EMPTY
23173: LIST
23174: LIST
23175: PUSH
23176: EMPTY
23177: LIST
23178: LIST
23179: LIST
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: PPUSH
23185: CALL_OW 72
23189: ST_TO_ADDR
// for i = 1 to hexes do
23190: LD_ADDR_VAR 0 9
23194: PUSH
23195: DOUBLE
23196: LD_INT 1
23198: DEC
23199: ST_TO_ADDR
23200: LD_VAR 0 14
23204: PUSH
23205: FOR_TO
23206: IFFALSE 23882
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23208: LD_ADDR_VAR 0 13
23212: PUSH
23213: LD_VAR 0 14
23217: PUSH
23218: LD_VAR 0 9
23222: ARRAY
23223: PUSH
23224: LD_INT 1
23226: ARRAY
23227: PPUSH
23228: LD_VAR 0 14
23232: PUSH
23233: LD_VAR 0 9
23237: ARRAY
23238: PUSH
23239: LD_INT 2
23241: ARRAY
23242: PPUSH
23243: CALL_OW 428
23247: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23248: LD_VAR 0 14
23252: PUSH
23253: LD_VAR 0 9
23257: ARRAY
23258: PUSH
23259: LD_INT 1
23261: ARRAY
23262: PPUSH
23263: LD_VAR 0 14
23267: PUSH
23268: LD_VAR 0 9
23272: ARRAY
23273: PUSH
23274: LD_INT 2
23276: ARRAY
23277: PPUSH
23278: CALL_OW 351
23282: PUSH
23283: LD_VAR 0 14
23287: PUSH
23288: LD_VAR 0 9
23292: ARRAY
23293: PUSH
23294: LD_INT 1
23296: ARRAY
23297: PPUSH
23298: LD_VAR 0 14
23302: PUSH
23303: LD_VAR 0 9
23307: ARRAY
23308: PUSH
23309: LD_INT 2
23311: ARRAY
23312: PPUSH
23313: CALL_OW 488
23317: NOT
23318: OR
23319: PUSH
23320: LD_VAR 0 13
23324: PPUSH
23325: CALL_OW 247
23329: PUSH
23330: LD_INT 3
23332: EQUAL
23333: OR
23334: IFFALSE 23340
// exit ;
23336: POP
23337: POP
23338: GO 23884
// if not tmp then
23340: LD_VAR 0 13
23344: NOT
23345: IFFALSE 23349
// continue ;
23347: GO 23205
// result := true ;
23349: LD_ADDR_VAR 0 8
23353: PUSH
23354: LD_INT 1
23356: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23357: LD_VAR 0 6
23361: PUSH
23362: LD_VAR 0 13
23366: PPUSH
23367: CALL_OW 247
23371: PUSH
23372: LD_INT 2
23374: EQUAL
23375: AND
23376: PUSH
23377: LD_VAR 0 13
23381: PPUSH
23382: CALL_OW 263
23386: PUSH
23387: LD_INT 1
23389: EQUAL
23390: AND
23391: IFFALSE 23555
// begin if IsDrivenBy ( tmp ) then
23393: LD_VAR 0 13
23397: PPUSH
23398: CALL_OW 311
23402: IFFALSE 23406
// continue ;
23404: GO 23205
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23406: LD_VAR 0 6
23410: PPUSH
23411: LD_INT 3
23413: PUSH
23414: LD_INT 60
23416: PUSH
23417: EMPTY
23418: LIST
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: PUSH
23424: LD_INT 3
23426: PUSH
23427: LD_INT 55
23429: PUSH
23430: EMPTY
23431: LIST
23432: PUSH
23433: EMPTY
23434: LIST
23435: LIST
23436: PUSH
23437: EMPTY
23438: LIST
23439: LIST
23440: PPUSH
23441: CALL_OW 72
23445: IFFALSE 23553
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23447: LD_ADDR_VAR 0 18
23451: PUSH
23452: LD_VAR 0 6
23456: PPUSH
23457: LD_INT 3
23459: PUSH
23460: LD_INT 60
23462: PUSH
23463: EMPTY
23464: LIST
23465: PUSH
23466: EMPTY
23467: LIST
23468: LIST
23469: PUSH
23470: LD_INT 3
23472: PUSH
23473: LD_INT 55
23475: PUSH
23476: EMPTY
23477: LIST
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: PPUSH
23487: CALL_OW 72
23491: PUSH
23492: LD_INT 1
23494: ARRAY
23495: ST_TO_ADDR
// if IsInUnit ( driver ) then
23496: LD_VAR 0 18
23500: PPUSH
23501: CALL_OW 310
23505: IFFALSE 23516
// ComExit ( driver ) ;
23507: LD_VAR 0 18
23511: PPUSH
23512: CALL 48826 0 1
// AddComEnterUnit ( driver , tmp ) ;
23516: LD_VAR 0 18
23520: PPUSH
23521: LD_VAR 0 13
23525: PPUSH
23526: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23530: LD_VAR 0 18
23534: PPUSH
23535: LD_VAR 0 7
23539: PPUSH
23540: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23544: LD_VAR 0 18
23548: PPUSH
23549: CALL_OW 181
// end ; continue ;
23553: GO 23205
// end ; if not cleaners or not tmp in cleaners then
23555: LD_VAR 0 6
23559: NOT
23560: PUSH
23561: LD_VAR 0 13
23565: PUSH
23566: LD_VAR 0 6
23570: IN
23571: NOT
23572: OR
23573: IFFALSE 23880
// begin if dep then
23575: LD_VAR 0 17
23579: IFFALSE 23715
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23581: LD_ADDR_VAR 0 16
23585: PUSH
23586: LD_VAR 0 17
23590: PUSH
23591: LD_INT 1
23593: ARRAY
23594: PPUSH
23595: CALL_OW 250
23599: PPUSH
23600: LD_VAR 0 17
23604: PUSH
23605: LD_INT 1
23607: ARRAY
23608: PPUSH
23609: CALL_OW 254
23613: PPUSH
23614: LD_INT 5
23616: PPUSH
23617: CALL_OW 272
23621: PUSH
23622: LD_VAR 0 17
23626: PUSH
23627: LD_INT 1
23629: ARRAY
23630: PPUSH
23631: CALL_OW 251
23635: PPUSH
23636: LD_VAR 0 17
23640: PUSH
23641: LD_INT 1
23643: ARRAY
23644: PPUSH
23645: CALL_OW 254
23649: PPUSH
23650: LD_INT 5
23652: PPUSH
23653: CALL_OW 273
23657: PUSH
23658: EMPTY
23659: LIST
23660: LIST
23661: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23662: LD_VAR 0 16
23666: PUSH
23667: LD_INT 1
23669: ARRAY
23670: PPUSH
23671: LD_VAR 0 16
23675: PUSH
23676: LD_INT 2
23678: ARRAY
23679: PPUSH
23680: CALL_OW 488
23684: IFFALSE 23715
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23686: LD_VAR 0 13
23690: PPUSH
23691: LD_VAR 0 16
23695: PUSH
23696: LD_INT 1
23698: ARRAY
23699: PPUSH
23700: LD_VAR 0 16
23704: PUSH
23705: LD_INT 2
23707: ARRAY
23708: PPUSH
23709: CALL_OW 111
// continue ;
23713: GO 23205
// end ; end ; r := GetDir ( tmp ) ;
23715: LD_ADDR_VAR 0 15
23719: PUSH
23720: LD_VAR 0 13
23724: PPUSH
23725: CALL_OW 254
23729: ST_TO_ADDR
// if r = 5 then
23730: LD_VAR 0 15
23734: PUSH
23735: LD_INT 5
23737: EQUAL
23738: IFFALSE 23748
// r := 0 ;
23740: LD_ADDR_VAR 0 15
23744: PUSH
23745: LD_INT 0
23747: ST_TO_ADDR
// for j = r to 5 do
23748: LD_ADDR_VAR 0 10
23752: PUSH
23753: DOUBLE
23754: LD_VAR 0 15
23758: DEC
23759: ST_TO_ADDR
23760: LD_INT 5
23762: PUSH
23763: FOR_TO
23764: IFFALSE 23878
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23766: LD_ADDR_VAR 0 11
23770: PUSH
23771: LD_VAR 0 13
23775: PPUSH
23776: CALL_OW 250
23780: PPUSH
23781: LD_VAR 0 10
23785: PPUSH
23786: LD_INT 2
23788: PPUSH
23789: CALL_OW 272
23793: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23794: LD_ADDR_VAR 0 12
23798: PUSH
23799: LD_VAR 0 13
23803: PPUSH
23804: CALL_OW 251
23808: PPUSH
23809: LD_VAR 0 10
23813: PPUSH
23814: LD_INT 2
23816: PPUSH
23817: CALL_OW 273
23821: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23822: LD_VAR 0 11
23826: PPUSH
23827: LD_VAR 0 12
23831: PPUSH
23832: CALL_OW 488
23836: PUSH
23837: LD_VAR 0 11
23841: PPUSH
23842: LD_VAR 0 12
23846: PPUSH
23847: CALL_OW 428
23851: NOT
23852: AND
23853: IFFALSE 23876
// begin ComMoveXY ( tmp , _x , _y ) ;
23855: LD_VAR 0 13
23859: PPUSH
23860: LD_VAR 0 11
23864: PPUSH
23865: LD_VAR 0 12
23869: PPUSH
23870: CALL_OW 111
// break ;
23874: GO 23878
// end ; end ;
23876: GO 23763
23878: POP
23879: POP
// end ; end ;
23880: GO 23205
23882: POP
23883: POP
// end ;
23884: LD_VAR 0 8
23888: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23889: LD_INT 0
23891: PPUSH
// result := true ;
23892: LD_ADDR_VAR 0 3
23896: PUSH
23897: LD_INT 1
23899: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23900: LD_VAR 0 2
23904: PUSH
23905: LD_INT 24
23907: DOUBLE
23908: EQUAL
23909: IFTRUE 23919
23911: LD_INT 33
23913: DOUBLE
23914: EQUAL
23915: IFTRUE 23919
23917: GO 23944
23919: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23920: LD_ADDR_VAR 0 3
23924: PUSH
23925: LD_INT 32
23927: PPUSH
23928: LD_VAR 0 1
23932: PPUSH
23933: CALL_OW 321
23937: PUSH
23938: LD_INT 2
23940: EQUAL
23941: ST_TO_ADDR
23942: GO 24264
23944: LD_INT 20
23946: DOUBLE
23947: EQUAL
23948: IFTRUE 23952
23950: GO 23977
23952: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23953: LD_ADDR_VAR 0 3
23957: PUSH
23958: LD_INT 6
23960: PPUSH
23961: LD_VAR 0 1
23965: PPUSH
23966: CALL_OW 321
23970: PUSH
23971: LD_INT 2
23973: EQUAL
23974: ST_TO_ADDR
23975: GO 24264
23977: LD_INT 22
23979: DOUBLE
23980: EQUAL
23981: IFTRUE 23991
23983: LD_INT 36
23985: DOUBLE
23986: EQUAL
23987: IFTRUE 23991
23989: GO 24016
23991: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23992: LD_ADDR_VAR 0 3
23996: PUSH
23997: LD_INT 15
23999: PPUSH
24000: LD_VAR 0 1
24004: PPUSH
24005: CALL_OW 321
24009: PUSH
24010: LD_INT 2
24012: EQUAL
24013: ST_TO_ADDR
24014: GO 24264
24016: LD_INT 30
24018: DOUBLE
24019: EQUAL
24020: IFTRUE 24024
24022: GO 24049
24024: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24025: LD_ADDR_VAR 0 3
24029: PUSH
24030: LD_INT 20
24032: PPUSH
24033: LD_VAR 0 1
24037: PPUSH
24038: CALL_OW 321
24042: PUSH
24043: LD_INT 2
24045: EQUAL
24046: ST_TO_ADDR
24047: GO 24264
24049: LD_INT 28
24051: DOUBLE
24052: EQUAL
24053: IFTRUE 24063
24055: LD_INT 21
24057: DOUBLE
24058: EQUAL
24059: IFTRUE 24063
24061: GO 24088
24063: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24064: LD_ADDR_VAR 0 3
24068: PUSH
24069: LD_INT 21
24071: PPUSH
24072: LD_VAR 0 1
24076: PPUSH
24077: CALL_OW 321
24081: PUSH
24082: LD_INT 2
24084: EQUAL
24085: ST_TO_ADDR
24086: GO 24264
24088: LD_INT 16
24090: DOUBLE
24091: EQUAL
24092: IFTRUE 24096
24094: GO 24123
24096: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24097: LD_ADDR_VAR 0 3
24101: PUSH
24102: LD_EXP 80
24106: PPUSH
24107: LD_VAR 0 1
24111: PPUSH
24112: CALL_OW 321
24116: PUSH
24117: LD_INT 2
24119: EQUAL
24120: ST_TO_ADDR
24121: GO 24264
24123: LD_INT 19
24125: DOUBLE
24126: EQUAL
24127: IFTRUE 24137
24129: LD_INT 23
24131: DOUBLE
24132: EQUAL
24133: IFTRUE 24137
24135: GO 24164
24137: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24138: LD_ADDR_VAR 0 3
24142: PUSH
24143: LD_EXP 79
24147: PPUSH
24148: LD_VAR 0 1
24152: PPUSH
24153: CALL_OW 321
24157: PUSH
24158: LD_INT 2
24160: EQUAL
24161: ST_TO_ADDR
24162: GO 24264
24164: LD_INT 17
24166: DOUBLE
24167: EQUAL
24168: IFTRUE 24172
24170: GO 24197
24172: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24173: LD_ADDR_VAR 0 3
24177: PUSH
24178: LD_INT 39
24180: PPUSH
24181: LD_VAR 0 1
24185: PPUSH
24186: CALL_OW 321
24190: PUSH
24191: LD_INT 2
24193: EQUAL
24194: ST_TO_ADDR
24195: GO 24264
24197: LD_INT 18
24199: DOUBLE
24200: EQUAL
24201: IFTRUE 24205
24203: GO 24230
24205: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24206: LD_ADDR_VAR 0 3
24210: PUSH
24211: LD_INT 40
24213: PPUSH
24214: LD_VAR 0 1
24218: PPUSH
24219: CALL_OW 321
24223: PUSH
24224: LD_INT 2
24226: EQUAL
24227: ST_TO_ADDR
24228: GO 24264
24230: LD_INT 27
24232: DOUBLE
24233: EQUAL
24234: IFTRUE 24238
24236: GO 24263
24238: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24239: LD_ADDR_VAR 0 3
24243: PUSH
24244: LD_INT 35
24246: PPUSH
24247: LD_VAR 0 1
24251: PPUSH
24252: CALL_OW 321
24256: PUSH
24257: LD_INT 2
24259: EQUAL
24260: ST_TO_ADDR
24261: GO 24264
24263: POP
// end ;
24264: LD_VAR 0 3
24268: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24269: LD_INT 0
24271: PPUSH
24272: PPUSH
24273: PPUSH
24274: PPUSH
24275: PPUSH
24276: PPUSH
24277: PPUSH
24278: PPUSH
24279: PPUSH
24280: PPUSH
24281: PPUSH
// result := false ;
24282: LD_ADDR_VAR 0 6
24286: PUSH
24287: LD_INT 0
24289: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24290: LD_VAR 0 1
24294: NOT
24295: PUSH
24296: LD_VAR 0 1
24300: PPUSH
24301: CALL_OW 266
24305: PUSH
24306: LD_INT 0
24308: PUSH
24309: LD_INT 1
24311: PUSH
24312: EMPTY
24313: LIST
24314: LIST
24315: IN
24316: NOT
24317: OR
24318: PUSH
24319: LD_VAR 0 2
24323: NOT
24324: OR
24325: PUSH
24326: LD_VAR 0 5
24330: PUSH
24331: LD_INT 0
24333: PUSH
24334: LD_INT 1
24336: PUSH
24337: LD_INT 2
24339: PUSH
24340: LD_INT 3
24342: PUSH
24343: LD_INT 4
24345: PUSH
24346: LD_INT 5
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: LIST
24356: IN
24357: NOT
24358: OR
24359: PUSH
24360: LD_VAR 0 3
24364: PPUSH
24365: LD_VAR 0 4
24369: PPUSH
24370: CALL_OW 488
24374: NOT
24375: OR
24376: IFFALSE 24380
// exit ;
24378: GO 25116
// side := GetSide ( depot ) ;
24380: LD_ADDR_VAR 0 9
24384: PUSH
24385: LD_VAR 0 1
24389: PPUSH
24390: CALL_OW 255
24394: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24395: LD_VAR 0 9
24399: PPUSH
24400: LD_VAR 0 2
24404: PPUSH
24405: CALL 23889 0 2
24409: NOT
24410: IFFALSE 24414
// exit ;
24412: GO 25116
// pom := GetBase ( depot ) ;
24414: LD_ADDR_VAR 0 10
24418: PUSH
24419: LD_VAR 0 1
24423: PPUSH
24424: CALL_OW 274
24428: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24429: LD_ADDR_VAR 0 11
24433: PUSH
24434: LD_VAR 0 2
24438: PPUSH
24439: LD_VAR 0 1
24443: PPUSH
24444: CALL_OW 248
24448: PPUSH
24449: CALL_OW 450
24453: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24454: LD_VAR 0 10
24458: PPUSH
24459: LD_INT 1
24461: PPUSH
24462: CALL_OW 275
24466: PUSH
24467: LD_VAR 0 11
24471: PUSH
24472: LD_INT 1
24474: ARRAY
24475: GREATEREQUAL
24476: PUSH
24477: LD_VAR 0 10
24481: PPUSH
24482: LD_INT 2
24484: PPUSH
24485: CALL_OW 275
24489: PUSH
24490: LD_VAR 0 11
24494: PUSH
24495: LD_INT 2
24497: ARRAY
24498: GREATEREQUAL
24499: AND
24500: PUSH
24501: LD_VAR 0 10
24505: PPUSH
24506: LD_INT 3
24508: PPUSH
24509: CALL_OW 275
24513: PUSH
24514: LD_VAR 0 11
24518: PUSH
24519: LD_INT 3
24521: ARRAY
24522: GREATEREQUAL
24523: AND
24524: NOT
24525: IFFALSE 24529
// exit ;
24527: GO 25116
// if GetBType ( depot ) = b_depot then
24529: LD_VAR 0 1
24533: PPUSH
24534: CALL_OW 266
24538: PUSH
24539: LD_INT 0
24541: EQUAL
24542: IFFALSE 24554
// dist := 28 else
24544: LD_ADDR_VAR 0 14
24548: PUSH
24549: LD_INT 28
24551: ST_TO_ADDR
24552: GO 24562
// dist := 36 ;
24554: LD_ADDR_VAR 0 14
24558: PUSH
24559: LD_INT 36
24561: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24562: LD_VAR 0 1
24566: PPUSH
24567: LD_VAR 0 3
24571: PPUSH
24572: LD_VAR 0 4
24576: PPUSH
24577: CALL_OW 297
24581: PUSH
24582: LD_VAR 0 14
24586: GREATER
24587: IFFALSE 24591
// exit ;
24589: GO 25116
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24591: LD_ADDR_VAR 0 12
24595: PUSH
24596: LD_VAR 0 2
24600: PPUSH
24601: LD_VAR 0 3
24605: PPUSH
24606: LD_VAR 0 4
24610: PPUSH
24611: LD_VAR 0 5
24615: PPUSH
24616: LD_VAR 0 1
24620: PPUSH
24621: CALL_OW 248
24625: PPUSH
24626: LD_INT 0
24628: PPUSH
24629: CALL 25121 0 6
24633: ST_TO_ADDR
// if not hexes then
24634: LD_VAR 0 12
24638: NOT
24639: IFFALSE 24643
// exit ;
24641: GO 25116
// hex := GetHexInfo ( x , y ) ;
24643: LD_ADDR_VAR 0 15
24647: PUSH
24648: LD_VAR 0 3
24652: PPUSH
24653: LD_VAR 0 4
24657: PPUSH
24658: CALL_OW 546
24662: ST_TO_ADDR
// if hex [ 1 ] then
24663: LD_VAR 0 15
24667: PUSH
24668: LD_INT 1
24670: ARRAY
24671: IFFALSE 24675
// exit ;
24673: GO 25116
// height := hex [ 2 ] ;
24675: LD_ADDR_VAR 0 13
24679: PUSH
24680: LD_VAR 0 15
24684: PUSH
24685: LD_INT 2
24687: ARRAY
24688: ST_TO_ADDR
// for i = 1 to hexes do
24689: LD_ADDR_VAR 0 7
24693: PUSH
24694: DOUBLE
24695: LD_INT 1
24697: DEC
24698: ST_TO_ADDR
24699: LD_VAR 0 12
24703: PUSH
24704: FOR_TO
24705: IFFALSE 25035
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24707: LD_VAR 0 12
24711: PUSH
24712: LD_VAR 0 7
24716: ARRAY
24717: PUSH
24718: LD_INT 1
24720: ARRAY
24721: PPUSH
24722: LD_VAR 0 12
24726: PUSH
24727: LD_VAR 0 7
24731: ARRAY
24732: PUSH
24733: LD_INT 2
24735: ARRAY
24736: PPUSH
24737: CALL_OW 488
24741: NOT
24742: PUSH
24743: LD_VAR 0 12
24747: PUSH
24748: LD_VAR 0 7
24752: ARRAY
24753: PUSH
24754: LD_INT 1
24756: ARRAY
24757: PPUSH
24758: LD_VAR 0 12
24762: PUSH
24763: LD_VAR 0 7
24767: ARRAY
24768: PUSH
24769: LD_INT 2
24771: ARRAY
24772: PPUSH
24773: CALL_OW 428
24777: PUSH
24778: LD_INT 0
24780: GREATER
24781: OR
24782: PUSH
24783: LD_VAR 0 12
24787: PUSH
24788: LD_VAR 0 7
24792: ARRAY
24793: PUSH
24794: LD_INT 1
24796: ARRAY
24797: PPUSH
24798: LD_VAR 0 12
24802: PUSH
24803: LD_VAR 0 7
24807: ARRAY
24808: PUSH
24809: LD_INT 2
24811: ARRAY
24812: PPUSH
24813: CALL_OW 351
24817: OR
24818: IFFALSE 24824
// exit ;
24820: POP
24821: POP
24822: GO 25116
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24824: LD_ADDR_VAR 0 8
24828: PUSH
24829: LD_VAR 0 12
24833: PUSH
24834: LD_VAR 0 7
24838: ARRAY
24839: PUSH
24840: LD_INT 1
24842: ARRAY
24843: PPUSH
24844: LD_VAR 0 12
24848: PUSH
24849: LD_VAR 0 7
24853: ARRAY
24854: PUSH
24855: LD_INT 2
24857: ARRAY
24858: PPUSH
24859: CALL_OW 546
24863: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24864: LD_VAR 0 8
24868: PUSH
24869: LD_INT 1
24871: ARRAY
24872: PUSH
24873: LD_VAR 0 8
24877: PUSH
24878: LD_INT 2
24880: ARRAY
24881: PUSH
24882: LD_VAR 0 13
24886: PUSH
24887: LD_INT 2
24889: PLUS
24890: GREATER
24891: OR
24892: PUSH
24893: LD_VAR 0 8
24897: PUSH
24898: LD_INT 2
24900: ARRAY
24901: PUSH
24902: LD_VAR 0 13
24906: PUSH
24907: LD_INT 2
24909: MINUS
24910: LESS
24911: OR
24912: PUSH
24913: LD_VAR 0 8
24917: PUSH
24918: LD_INT 3
24920: ARRAY
24921: PUSH
24922: LD_INT 0
24924: PUSH
24925: LD_INT 8
24927: PUSH
24928: LD_INT 9
24930: PUSH
24931: LD_INT 10
24933: PUSH
24934: LD_INT 11
24936: PUSH
24937: LD_INT 12
24939: PUSH
24940: LD_INT 13
24942: PUSH
24943: LD_INT 16
24945: PUSH
24946: LD_INT 17
24948: PUSH
24949: LD_INT 18
24951: PUSH
24952: LD_INT 19
24954: PUSH
24955: LD_INT 20
24957: PUSH
24958: LD_INT 21
24960: PUSH
24961: EMPTY
24962: LIST
24963: LIST
24964: LIST
24965: LIST
24966: LIST
24967: LIST
24968: LIST
24969: LIST
24970: LIST
24971: LIST
24972: LIST
24973: LIST
24974: LIST
24975: IN
24976: NOT
24977: OR
24978: PUSH
24979: LD_VAR 0 8
24983: PUSH
24984: LD_INT 5
24986: ARRAY
24987: NOT
24988: OR
24989: PUSH
24990: LD_VAR 0 8
24994: PUSH
24995: LD_INT 6
24997: ARRAY
24998: PUSH
24999: LD_INT 1
25001: PUSH
25002: LD_INT 2
25004: PUSH
25005: LD_INT 7
25007: PUSH
25008: LD_INT 9
25010: PUSH
25011: LD_INT 10
25013: PUSH
25014: LD_INT 11
25016: PUSH
25017: EMPTY
25018: LIST
25019: LIST
25020: LIST
25021: LIST
25022: LIST
25023: LIST
25024: IN
25025: NOT
25026: OR
25027: IFFALSE 25033
// exit ;
25029: POP
25030: POP
25031: GO 25116
// end ;
25033: GO 24704
25035: POP
25036: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25037: LD_VAR 0 9
25041: PPUSH
25042: LD_VAR 0 3
25046: PPUSH
25047: LD_VAR 0 4
25051: PPUSH
25052: LD_INT 20
25054: PPUSH
25055: CALL 17062 0 4
25059: PUSH
25060: LD_INT 4
25062: ARRAY
25063: IFFALSE 25067
// exit ;
25065: GO 25116
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25067: LD_VAR 0 2
25071: PUSH
25072: LD_INT 29
25074: PUSH
25075: LD_INT 30
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: IN
25082: PUSH
25083: LD_VAR 0 3
25087: PPUSH
25088: LD_VAR 0 4
25092: PPUSH
25093: LD_VAR 0 9
25097: PPUSH
25098: CALL_OW 440
25102: NOT
25103: AND
25104: IFFALSE 25108
// exit ;
25106: GO 25116
// result := true ;
25108: LD_ADDR_VAR 0 6
25112: PUSH
25113: LD_INT 1
25115: ST_TO_ADDR
// end ;
25116: LD_VAR 0 6
25120: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25121: LD_INT 0
25123: PPUSH
25124: PPUSH
25125: PPUSH
25126: PPUSH
25127: PPUSH
25128: PPUSH
25129: PPUSH
25130: PPUSH
25131: PPUSH
25132: PPUSH
25133: PPUSH
25134: PPUSH
25135: PPUSH
25136: PPUSH
25137: PPUSH
25138: PPUSH
25139: PPUSH
25140: PPUSH
25141: PPUSH
25142: PPUSH
25143: PPUSH
25144: PPUSH
25145: PPUSH
25146: PPUSH
25147: PPUSH
25148: PPUSH
25149: PPUSH
25150: PPUSH
25151: PPUSH
25152: PPUSH
25153: PPUSH
25154: PPUSH
25155: PPUSH
25156: PPUSH
25157: PPUSH
25158: PPUSH
25159: PPUSH
25160: PPUSH
25161: PPUSH
25162: PPUSH
25163: PPUSH
25164: PPUSH
25165: PPUSH
25166: PPUSH
25167: PPUSH
25168: PPUSH
25169: PPUSH
25170: PPUSH
25171: PPUSH
25172: PPUSH
25173: PPUSH
25174: PPUSH
25175: PPUSH
25176: PPUSH
25177: PPUSH
25178: PPUSH
25179: PPUSH
25180: PPUSH
// result = [ ] ;
25181: LD_ADDR_VAR 0 7
25185: PUSH
25186: EMPTY
25187: ST_TO_ADDR
// temp_list = [ ] ;
25188: LD_ADDR_VAR 0 9
25192: PUSH
25193: EMPTY
25194: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25195: LD_VAR 0 4
25199: PUSH
25200: LD_INT 0
25202: PUSH
25203: LD_INT 1
25205: PUSH
25206: LD_INT 2
25208: PUSH
25209: LD_INT 3
25211: PUSH
25212: LD_INT 4
25214: PUSH
25215: LD_INT 5
25217: PUSH
25218: EMPTY
25219: LIST
25220: LIST
25221: LIST
25222: LIST
25223: LIST
25224: LIST
25225: IN
25226: NOT
25227: PUSH
25228: LD_VAR 0 1
25232: PUSH
25233: LD_INT 0
25235: PUSH
25236: LD_INT 1
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: IN
25243: PUSH
25244: LD_VAR 0 5
25248: PUSH
25249: LD_INT 1
25251: PUSH
25252: LD_INT 2
25254: PUSH
25255: LD_INT 3
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: LIST
25262: IN
25263: NOT
25264: AND
25265: OR
25266: IFFALSE 25270
// exit ;
25268: GO 43661
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25270: LD_VAR 0 1
25274: PUSH
25275: LD_INT 6
25277: PUSH
25278: LD_INT 7
25280: PUSH
25281: LD_INT 8
25283: PUSH
25284: LD_INT 13
25286: PUSH
25287: LD_INT 12
25289: PUSH
25290: LD_INT 15
25292: PUSH
25293: LD_INT 11
25295: PUSH
25296: LD_INT 14
25298: PUSH
25299: LD_INT 10
25301: PUSH
25302: EMPTY
25303: LIST
25304: LIST
25305: LIST
25306: LIST
25307: LIST
25308: LIST
25309: LIST
25310: LIST
25311: LIST
25312: IN
25313: IFFALSE 25323
// btype = b_lab ;
25315: LD_ADDR_VAR 0 1
25319: PUSH
25320: LD_INT 6
25322: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25323: LD_VAR 0 6
25327: PUSH
25328: LD_INT 0
25330: PUSH
25331: LD_INT 1
25333: PUSH
25334: LD_INT 2
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: LIST
25341: IN
25342: NOT
25343: PUSH
25344: LD_VAR 0 1
25348: PUSH
25349: LD_INT 0
25351: PUSH
25352: LD_INT 1
25354: PUSH
25355: LD_INT 2
25357: PUSH
25358: LD_INT 3
25360: PUSH
25361: LD_INT 6
25363: PUSH
25364: LD_INT 36
25366: PUSH
25367: LD_INT 4
25369: PUSH
25370: LD_INT 5
25372: PUSH
25373: LD_INT 31
25375: PUSH
25376: LD_INT 32
25378: PUSH
25379: LD_INT 33
25381: PUSH
25382: EMPTY
25383: LIST
25384: LIST
25385: LIST
25386: LIST
25387: LIST
25388: LIST
25389: LIST
25390: LIST
25391: LIST
25392: LIST
25393: LIST
25394: IN
25395: NOT
25396: PUSH
25397: LD_VAR 0 6
25401: PUSH
25402: LD_INT 1
25404: EQUAL
25405: AND
25406: OR
25407: PUSH
25408: LD_VAR 0 1
25412: PUSH
25413: LD_INT 2
25415: PUSH
25416: LD_INT 3
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: IN
25423: NOT
25424: PUSH
25425: LD_VAR 0 6
25429: PUSH
25430: LD_INT 2
25432: EQUAL
25433: AND
25434: OR
25435: IFFALSE 25445
// mode = 0 ;
25437: LD_ADDR_VAR 0 6
25441: PUSH
25442: LD_INT 0
25444: ST_TO_ADDR
// case mode of 0 :
25445: LD_VAR 0 6
25449: PUSH
25450: LD_INT 0
25452: DOUBLE
25453: EQUAL
25454: IFTRUE 25458
25456: GO 36911
25458: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25459: LD_ADDR_VAR 0 11
25463: PUSH
25464: LD_INT 0
25466: PUSH
25467: LD_INT 0
25469: PUSH
25470: EMPTY
25471: LIST
25472: LIST
25473: PUSH
25474: LD_INT 0
25476: PUSH
25477: LD_INT 1
25479: NEG
25480: PUSH
25481: EMPTY
25482: LIST
25483: LIST
25484: PUSH
25485: LD_INT 1
25487: PUSH
25488: LD_INT 0
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: LD_INT 1
25497: PUSH
25498: LD_INT 1
25500: PUSH
25501: EMPTY
25502: LIST
25503: LIST
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: LD_INT 1
25510: PUSH
25511: EMPTY
25512: LIST
25513: LIST
25514: PUSH
25515: LD_INT 1
25517: NEG
25518: PUSH
25519: LD_INT 0
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 1
25528: NEG
25529: PUSH
25530: LD_INT 1
25532: NEG
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 1
25540: NEG
25541: PUSH
25542: LD_INT 2
25544: NEG
25545: PUSH
25546: EMPTY
25547: LIST
25548: LIST
25549: PUSH
25550: LD_INT 0
25552: PUSH
25553: LD_INT 2
25555: NEG
25556: PUSH
25557: EMPTY
25558: LIST
25559: LIST
25560: PUSH
25561: LD_INT 1
25563: PUSH
25564: LD_INT 1
25566: NEG
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: LD_INT 1
25574: PUSH
25575: LD_INT 2
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: PUSH
25582: LD_INT 0
25584: PUSH
25585: LD_INT 2
25587: PUSH
25588: EMPTY
25589: LIST
25590: LIST
25591: PUSH
25592: LD_INT 1
25594: NEG
25595: PUSH
25596: LD_INT 1
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 1
25605: PUSH
25606: LD_INT 3
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: PUSH
25613: LD_INT 0
25615: PUSH
25616: LD_INT 3
25618: PUSH
25619: EMPTY
25620: LIST
25621: LIST
25622: PUSH
25623: LD_INT 1
25625: NEG
25626: PUSH
25627: LD_INT 2
25629: PUSH
25630: EMPTY
25631: LIST
25632: LIST
25633: PUSH
25634: EMPTY
25635: LIST
25636: LIST
25637: LIST
25638: LIST
25639: LIST
25640: LIST
25641: LIST
25642: LIST
25643: LIST
25644: LIST
25645: LIST
25646: LIST
25647: LIST
25648: LIST
25649: LIST
25650: LIST
25651: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25652: LD_ADDR_VAR 0 12
25656: PUSH
25657: LD_INT 0
25659: PUSH
25660: LD_INT 0
25662: PUSH
25663: EMPTY
25664: LIST
25665: LIST
25666: PUSH
25667: LD_INT 0
25669: PUSH
25670: LD_INT 1
25672: NEG
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PUSH
25678: LD_INT 1
25680: PUSH
25681: LD_INT 0
25683: PUSH
25684: EMPTY
25685: LIST
25686: LIST
25687: PUSH
25688: LD_INT 1
25690: PUSH
25691: LD_INT 1
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 0
25700: PUSH
25701: LD_INT 1
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 1
25710: NEG
25711: PUSH
25712: LD_INT 0
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: PUSH
25719: LD_INT 1
25721: NEG
25722: PUSH
25723: LD_INT 1
25725: NEG
25726: PUSH
25727: EMPTY
25728: LIST
25729: LIST
25730: PUSH
25731: LD_INT 1
25733: PUSH
25734: LD_INT 1
25736: NEG
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: PUSH
25742: LD_INT 2
25744: PUSH
25745: LD_INT 0
25747: PUSH
25748: EMPTY
25749: LIST
25750: LIST
25751: PUSH
25752: LD_INT 2
25754: PUSH
25755: LD_INT 1
25757: PUSH
25758: EMPTY
25759: LIST
25760: LIST
25761: PUSH
25762: LD_INT 1
25764: NEG
25765: PUSH
25766: LD_INT 1
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 2
25775: NEG
25776: PUSH
25777: LD_INT 0
25779: PUSH
25780: EMPTY
25781: LIST
25782: LIST
25783: PUSH
25784: LD_INT 2
25786: NEG
25787: PUSH
25788: LD_INT 1
25790: NEG
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 2
25798: NEG
25799: PUSH
25800: LD_INT 1
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: PUSH
25807: LD_INT 3
25809: NEG
25810: PUSH
25811: LD_INT 0
25813: PUSH
25814: EMPTY
25815: LIST
25816: LIST
25817: PUSH
25818: LD_INT 3
25820: NEG
25821: PUSH
25822: LD_INT 1
25824: NEG
25825: PUSH
25826: EMPTY
25827: LIST
25828: LIST
25829: PUSH
25830: EMPTY
25831: LIST
25832: LIST
25833: LIST
25834: LIST
25835: LIST
25836: LIST
25837: LIST
25838: LIST
25839: LIST
25840: LIST
25841: LIST
25842: LIST
25843: LIST
25844: LIST
25845: LIST
25846: LIST
25847: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25848: LD_ADDR_VAR 0 13
25852: PUSH
25853: LD_INT 0
25855: PUSH
25856: LD_INT 0
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: LD_INT 0
25865: PUSH
25866: LD_INT 1
25868: NEG
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: LD_INT 1
25876: PUSH
25877: LD_INT 0
25879: PUSH
25880: EMPTY
25881: LIST
25882: LIST
25883: PUSH
25884: LD_INT 1
25886: PUSH
25887: LD_INT 1
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 0
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: EMPTY
25901: LIST
25902: LIST
25903: PUSH
25904: LD_INT 1
25906: NEG
25907: PUSH
25908: LD_INT 0
25910: PUSH
25911: EMPTY
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 1
25917: NEG
25918: PUSH
25919: LD_INT 1
25921: NEG
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: PUSH
25927: LD_INT 1
25929: NEG
25930: PUSH
25931: LD_INT 2
25933: NEG
25934: PUSH
25935: EMPTY
25936: LIST
25937: LIST
25938: PUSH
25939: LD_INT 2
25941: PUSH
25942: LD_INT 1
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: PUSH
25949: LD_INT 2
25951: PUSH
25952: LD_INT 2
25954: PUSH
25955: EMPTY
25956: LIST
25957: LIST
25958: PUSH
25959: LD_INT 1
25961: PUSH
25962: LD_INT 2
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: PUSH
25969: LD_INT 2
25971: NEG
25972: PUSH
25973: LD_INT 1
25975: NEG
25976: PUSH
25977: EMPTY
25978: LIST
25979: LIST
25980: PUSH
25981: LD_INT 2
25983: NEG
25984: PUSH
25985: LD_INT 2
25987: NEG
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PUSH
25993: LD_INT 2
25995: NEG
25996: PUSH
25997: LD_INT 3
25999: NEG
26000: PUSH
26001: EMPTY
26002: LIST
26003: LIST
26004: PUSH
26005: LD_INT 3
26007: NEG
26008: PUSH
26009: LD_INT 2
26011: NEG
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: LD_INT 3
26019: NEG
26020: PUSH
26021: LD_INT 3
26023: NEG
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: LIST
26033: LIST
26034: LIST
26035: LIST
26036: LIST
26037: LIST
26038: LIST
26039: LIST
26040: LIST
26041: LIST
26042: LIST
26043: LIST
26044: LIST
26045: LIST
26046: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26047: LD_ADDR_VAR 0 14
26051: PUSH
26052: LD_INT 0
26054: PUSH
26055: LD_INT 0
26057: PUSH
26058: EMPTY
26059: LIST
26060: LIST
26061: PUSH
26062: LD_INT 0
26064: PUSH
26065: LD_INT 1
26067: NEG
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: LD_INT 1
26075: PUSH
26076: LD_INT 0
26078: PUSH
26079: EMPTY
26080: LIST
26081: LIST
26082: PUSH
26083: LD_INT 1
26085: PUSH
26086: LD_INT 1
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 0
26095: PUSH
26096: LD_INT 1
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 1
26105: NEG
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: PUSH
26114: LD_INT 1
26116: NEG
26117: PUSH
26118: LD_INT 1
26120: NEG
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: PUSH
26126: LD_INT 1
26128: NEG
26129: PUSH
26130: LD_INT 2
26132: NEG
26133: PUSH
26134: EMPTY
26135: LIST
26136: LIST
26137: PUSH
26138: LD_INT 0
26140: PUSH
26141: LD_INT 2
26143: NEG
26144: PUSH
26145: EMPTY
26146: LIST
26147: LIST
26148: PUSH
26149: LD_INT 1
26151: PUSH
26152: LD_INT 1
26154: NEG
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: LD_INT 1
26162: PUSH
26163: LD_INT 2
26165: PUSH
26166: EMPTY
26167: LIST
26168: LIST
26169: PUSH
26170: LD_INT 0
26172: PUSH
26173: LD_INT 2
26175: PUSH
26176: EMPTY
26177: LIST
26178: LIST
26179: PUSH
26180: LD_INT 1
26182: NEG
26183: PUSH
26184: LD_INT 1
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: PUSH
26191: LD_INT 1
26193: NEG
26194: PUSH
26195: LD_INT 3
26197: NEG
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: PUSH
26203: LD_INT 0
26205: PUSH
26206: LD_INT 3
26208: NEG
26209: PUSH
26210: EMPTY
26211: LIST
26212: LIST
26213: PUSH
26214: LD_INT 1
26216: PUSH
26217: LD_INT 2
26219: NEG
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: LIST
26229: LIST
26230: LIST
26231: LIST
26232: LIST
26233: LIST
26234: LIST
26235: LIST
26236: LIST
26237: LIST
26238: LIST
26239: LIST
26240: LIST
26241: LIST
26242: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26243: LD_ADDR_VAR 0 15
26247: PUSH
26248: LD_INT 0
26250: PUSH
26251: LD_INT 0
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: LD_INT 0
26260: PUSH
26261: LD_INT 1
26263: NEG
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PUSH
26269: LD_INT 1
26271: PUSH
26272: LD_INT 0
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 1
26281: PUSH
26282: LD_INT 1
26284: PUSH
26285: EMPTY
26286: LIST
26287: LIST
26288: PUSH
26289: LD_INT 0
26291: PUSH
26292: LD_INT 1
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: PUSH
26299: LD_INT 1
26301: NEG
26302: PUSH
26303: LD_INT 0
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PUSH
26310: LD_INT 1
26312: NEG
26313: PUSH
26314: LD_INT 1
26316: NEG
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 1
26324: PUSH
26325: LD_INT 1
26327: NEG
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 2
26335: PUSH
26336: LD_INT 0
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: PUSH
26343: LD_INT 2
26345: PUSH
26346: LD_INT 1
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: PUSH
26353: LD_INT 1
26355: NEG
26356: PUSH
26357: LD_INT 1
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 2
26366: NEG
26367: PUSH
26368: LD_INT 0
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: LD_INT 2
26377: NEG
26378: PUSH
26379: LD_INT 1
26381: NEG
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: PUSH
26387: LD_INT 2
26389: PUSH
26390: LD_INT 1
26392: NEG
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 3
26400: PUSH
26401: LD_INT 0
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PUSH
26408: LD_INT 3
26410: PUSH
26411: LD_INT 1
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: LIST
26422: LIST
26423: LIST
26424: LIST
26425: LIST
26426: LIST
26427: LIST
26428: LIST
26429: LIST
26430: LIST
26431: LIST
26432: LIST
26433: LIST
26434: LIST
26435: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26436: LD_ADDR_VAR 0 16
26440: PUSH
26441: LD_INT 0
26443: PUSH
26444: LD_INT 0
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 0
26453: PUSH
26454: LD_INT 1
26456: NEG
26457: PUSH
26458: EMPTY
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 1
26464: PUSH
26465: LD_INT 0
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: PUSH
26472: LD_INT 1
26474: PUSH
26475: LD_INT 1
26477: PUSH
26478: EMPTY
26479: LIST
26480: LIST
26481: PUSH
26482: LD_INT 0
26484: PUSH
26485: LD_INT 1
26487: PUSH
26488: EMPTY
26489: LIST
26490: LIST
26491: PUSH
26492: LD_INT 1
26494: NEG
26495: PUSH
26496: LD_INT 0
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: LD_INT 1
26505: NEG
26506: PUSH
26507: LD_INT 1
26509: NEG
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 1
26517: NEG
26518: PUSH
26519: LD_INT 2
26521: NEG
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 2
26529: PUSH
26530: LD_INT 1
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PUSH
26537: LD_INT 2
26539: PUSH
26540: LD_INT 2
26542: PUSH
26543: EMPTY
26544: LIST
26545: LIST
26546: PUSH
26547: LD_INT 1
26549: PUSH
26550: LD_INT 2
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: PUSH
26557: LD_INT 2
26559: NEG
26560: PUSH
26561: LD_INT 1
26563: NEG
26564: PUSH
26565: EMPTY
26566: LIST
26567: LIST
26568: PUSH
26569: LD_INT 2
26571: NEG
26572: PUSH
26573: LD_INT 2
26575: NEG
26576: PUSH
26577: EMPTY
26578: LIST
26579: LIST
26580: PUSH
26581: LD_INT 3
26583: PUSH
26584: LD_INT 2
26586: PUSH
26587: EMPTY
26588: LIST
26589: LIST
26590: PUSH
26591: LD_INT 3
26593: PUSH
26594: LD_INT 3
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PUSH
26601: LD_INT 2
26603: PUSH
26604: LD_INT 3
26606: PUSH
26607: EMPTY
26608: LIST
26609: LIST
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: LIST
26615: LIST
26616: LIST
26617: LIST
26618: LIST
26619: LIST
26620: LIST
26621: LIST
26622: LIST
26623: LIST
26624: LIST
26625: LIST
26626: LIST
26627: LIST
26628: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26629: LD_ADDR_VAR 0 17
26633: PUSH
26634: LD_INT 0
26636: PUSH
26637: LD_INT 0
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: PUSH
26644: LD_INT 0
26646: PUSH
26647: LD_INT 1
26649: NEG
26650: PUSH
26651: EMPTY
26652: LIST
26653: LIST
26654: PUSH
26655: LD_INT 1
26657: PUSH
26658: LD_INT 0
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: PUSH
26665: LD_INT 1
26667: PUSH
26668: LD_INT 1
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PUSH
26675: LD_INT 0
26677: PUSH
26678: LD_INT 1
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: LD_INT 1
26687: NEG
26688: PUSH
26689: LD_INT 0
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 1
26698: NEG
26699: PUSH
26700: LD_INT 1
26702: NEG
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: PUSH
26708: LD_INT 1
26710: NEG
26711: PUSH
26712: LD_INT 2
26714: NEG
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PUSH
26720: LD_INT 0
26722: PUSH
26723: LD_INT 2
26725: NEG
26726: PUSH
26727: EMPTY
26728: LIST
26729: LIST
26730: PUSH
26731: LD_INT 1
26733: PUSH
26734: LD_INT 1
26736: NEG
26737: PUSH
26738: EMPTY
26739: LIST
26740: LIST
26741: PUSH
26742: LD_INT 2
26744: PUSH
26745: LD_INT 0
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: PUSH
26752: LD_INT 2
26754: PUSH
26755: LD_INT 1
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 2
26764: PUSH
26765: LD_INT 2
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: LD_INT 1
26774: PUSH
26775: LD_INT 2
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 0
26784: PUSH
26785: LD_INT 2
26787: PUSH
26788: EMPTY
26789: LIST
26790: LIST
26791: PUSH
26792: LD_INT 1
26794: NEG
26795: PUSH
26796: LD_INT 1
26798: PUSH
26799: EMPTY
26800: LIST
26801: LIST
26802: PUSH
26803: LD_INT 2
26805: NEG
26806: PUSH
26807: LD_INT 0
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: PUSH
26814: LD_INT 2
26816: NEG
26817: PUSH
26818: LD_INT 1
26820: NEG
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 2
26828: NEG
26829: PUSH
26830: LD_INT 2
26832: NEG
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: LIST
26842: LIST
26843: LIST
26844: LIST
26845: LIST
26846: LIST
26847: LIST
26848: LIST
26849: LIST
26850: LIST
26851: LIST
26852: LIST
26853: LIST
26854: LIST
26855: LIST
26856: LIST
26857: LIST
26858: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26859: LD_ADDR_VAR 0 18
26863: PUSH
26864: LD_INT 0
26866: PUSH
26867: LD_INT 0
26869: PUSH
26870: EMPTY
26871: LIST
26872: LIST
26873: PUSH
26874: LD_INT 0
26876: PUSH
26877: LD_INT 1
26879: NEG
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 1
26887: PUSH
26888: LD_INT 0
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 1
26897: PUSH
26898: LD_INT 1
26900: PUSH
26901: EMPTY
26902: LIST
26903: LIST
26904: PUSH
26905: LD_INT 0
26907: PUSH
26908: LD_INT 1
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PUSH
26915: LD_INT 1
26917: NEG
26918: PUSH
26919: LD_INT 0
26921: PUSH
26922: EMPTY
26923: LIST
26924: LIST
26925: PUSH
26926: LD_INT 1
26928: NEG
26929: PUSH
26930: LD_INT 1
26932: NEG
26933: PUSH
26934: EMPTY
26935: LIST
26936: LIST
26937: PUSH
26938: LD_INT 1
26940: NEG
26941: PUSH
26942: LD_INT 2
26944: NEG
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 0
26952: PUSH
26953: LD_INT 2
26955: NEG
26956: PUSH
26957: EMPTY
26958: LIST
26959: LIST
26960: PUSH
26961: LD_INT 1
26963: PUSH
26964: LD_INT 1
26966: NEG
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: LD_INT 2
26974: PUSH
26975: LD_INT 0
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 2
26984: PUSH
26985: LD_INT 1
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 2
26994: PUSH
26995: LD_INT 2
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PUSH
27002: LD_INT 1
27004: PUSH
27005: LD_INT 2
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: LD_INT 0
27014: PUSH
27015: LD_INT 2
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 1
27024: NEG
27025: PUSH
27026: LD_INT 1
27028: PUSH
27029: EMPTY
27030: LIST
27031: LIST
27032: PUSH
27033: LD_INT 2
27035: NEG
27036: PUSH
27037: LD_INT 0
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 2
27046: NEG
27047: PUSH
27048: LD_INT 1
27050: NEG
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: PUSH
27056: LD_INT 2
27058: NEG
27059: PUSH
27060: LD_INT 2
27062: NEG
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: LIST
27072: LIST
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: LIST
27078: LIST
27079: LIST
27080: LIST
27081: LIST
27082: LIST
27083: LIST
27084: LIST
27085: LIST
27086: LIST
27087: LIST
27088: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27089: LD_ADDR_VAR 0 19
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: LD_INT 0
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: PUSH
27104: LD_INT 0
27106: PUSH
27107: LD_INT 1
27109: NEG
27110: PUSH
27111: EMPTY
27112: LIST
27113: LIST
27114: PUSH
27115: LD_INT 1
27117: PUSH
27118: LD_INT 0
27120: PUSH
27121: EMPTY
27122: LIST
27123: LIST
27124: PUSH
27125: LD_INT 1
27127: PUSH
27128: LD_INT 1
27130: PUSH
27131: EMPTY
27132: LIST
27133: LIST
27134: PUSH
27135: LD_INT 0
27137: PUSH
27138: LD_INT 1
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 1
27147: NEG
27148: PUSH
27149: LD_INT 0
27151: PUSH
27152: EMPTY
27153: LIST
27154: LIST
27155: PUSH
27156: LD_INT 1
27158: NEG
27159: PUSH
27160: LD_INT 1
27162: NEG
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 1
27170: NEG
27171: PUSH
27172: LD_INT 2
27174: NEG
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 0
27182: PUSH
27183: LD_INT 2
27185: NEG
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 1
27193: PUSH
27194: LD_INT 1
27196: NEG
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 2
27204: PUSH
27205: LD_INT 0
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 2
27214: PUSH
27215: LD_INT 1
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 2
27224: PUSH
27225: LD_INT 2
27227: PUSH
27228: EMPTY
27229: LIST
27230: LIST
27231: PUSH
27232: LD_INT 1
27234: PUSH
27235: LD_INT 2
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: LD_INT 0
27244: PUSH
27245: LD_INT 2
27247: PUSH
27248: EMPTY
27249: LIST
27250: LIST
27251: PUSH
27252: LD_INT 1
27254: NEG
27255: PUSH
27256: LD_INT 1
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: PUSH
27263: LD_INT 2
27265: NEG
27266: PUSH
27267: LD_INT 0
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: LD_INT 2
27276: NEG
27277: PUSH
27278: LD_INT 1
27280: NEG
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 2
27288: NEG
27289: PUSH
27290: LD_INT 2
27292: NEG
27293: PUSH
27294: EMPTY
27295: LIST
27296: LIST
27297: PUSH
27298: EMPTY
27299: LIST
27300: LIST
27301: LIST
27302: LIST
27303: LIST
27304: LIST
27305: LIST
27306: LIST
27307: LIST
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27319: LD_ADDR_VAR 0 20
27323: PUSH
27324: LD_INT 0
27326: PUSH
27327: LD_INT 0
27329: PUSH
27330: EMPTY
27331: LIST
27332: LIST
27333: PUSH
27334: LD_INT 0
27336: PUSH
27337: LD_INT 1
27339: NEG
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 1
27347: PUSH
27348: LD_INT 0
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 1
27357: PUSH
27358: LD_INT 1
27360: PUSH
27361: EMPTY
27362: LIST
27363: LIST
27364: PUSH
27365: LD_INT 0
27367: PUSH
27368: LD_INT 1
27370: PUSH
27371: EMPTY
27372: LIST
27373: LIST
27374: PUSH
27375: LD_INT 1
27377: NEG
27378: PUSH
27379: LD_INT 0
27381: PUSH
27382: EMPTY
27383: LIST
27384: LIST
27385: PUSH
27386: LD_INT 1
27388: NEG
27389: PUSH
27390: LD_INT 1
27392: NEG
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: LD_INT 1
27400: NEG
27401: PUSH
27402: LD_INT 2
27404: NEG
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PUSH
27410: LD_INT 0
27412: PUSH
27413: LD_INT 2
27415: NEG
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 1
27423: PUSH
27424: LD_INT 1
27426: NEG
27427: PUSH
27428: EMPTY
27429: LIST
27430: LIST
27431: PUSH
27432: LD_INT 2
27434: PUSH
27435: LD_INT 0
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 2
27444: PUSH
27445: LD_INT 1
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 2
27454: PUSH
27455: LD_INT 2
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 1
27464: PUSH
27465: LD_INT 2
27467: PUSH
27468: EMPTY
27469: LIST
27470: LIST
27471: PUSH
27472: LD_INT 0
27474: PUSH
27475: LD_INT 2
27477: PUSH
27478: EMPTY
27479: LIST
27480: LIST
27481: PUSH
27482: LD_INT 1
27484: NEG
27485: PUSH
27486: LD_INT 1
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PUSH
27493: LD_INT 2
27495: NEG
27496: PUSH
27497: LD_INT 0
27499: PUSH
27500: EMPTY
27501: LIST
27502: LIST
27503: PUSH
27504: LD_INT 2
27506: NEG
27507: PUSH
27508: LD_INT 1
27510: NEG
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 2
27518: NEG
27519: PUSH
27520: LD_INT 2
27522: NEG
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: PUSH
27528: EMPTY
27529: LIST
27530: LIST
27531: LIST
27532: LIST
27533: LIST
27534: LIST
27535: LIST
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27549: LD_ADDR_VAR 0 21
27553: PUSH
27554: LD_INT 0
27556: PUSH
27557: LD_INT 0
27559: PUSH
27560: EMPTY
27561: LIST
27562: LIST
27563: PUSH
27564: LD_INT 0
27566: PUSH
27567: LD_INT 1
27569: NEG
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PUSH
27575: LD_INT 1
27577: PUSH
27578: LD_INT 0
27580: PUSH
27581: EMPTY
27582: LIST
27583: LIST
27584: PUSH
27585: LD_INT 1
27587: PUSH
27588: LD_INT 1
27590: PUSH
27591: EMPTY
27592: LIST
27593: LIST
27594: PUSH
27595: LD_INT 0
27597: PUSH
27598: LD_INT 1
27600: PUSH
27601: EMPTY
27602: LIST
27603: LIST
27604: PUSH
27605: LD_INT 1
27607: NEG
27608: PUSH
27609: LD_INT 0
27611: PUSH
27612: EMPTY
27613: LIST
27614: LIST
27615: PUSH
27616: LD_INT 1
27618: NEG
27619: PUSH
27620: LD_INT 1
27622: NEG
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 1
27630: NEG
27631: PUSH
27632: LD_INT 2
27634: NEG
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: LD_INT 0
27642: PUSH
27643: LD_INT 2
27645: NEG
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PUSH
27651: LD_INT 1
27653: PUSH
27654: LD_INT 1
27656: NEG
27657: PUSH
27658: EMPTY
27659: LIST
27660: LIST
27661: PUSH
27662: LD_INT 2
27664: PUSH
27665: LD_INT 0
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: PUSH
27672: LD_INT 2
27674: PUSH
27675: LD_INT 1
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PUSH
27682: LD_INT 2
27684: PUSH
27685: LD_INT 2
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: PUSH
27692: LD_INT 1
27694: PUSH
27695: LD_INT 2
27697: PUSH
27698: EMPTY
27699: LIST
27700: LIST
27701: PUSH
27702: LD_INT 0
27704: PUSH
27705: LD_INT 2
27707: PUSH
27708: EMPTY
27709: LIST
27710: LIST
27711: PUSH
27712: LD_INT 1
27714: NEG
27715: PUSH
27716: LD_INT 1
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: PUSH
27723: LD_INT 2
27725: NEG
27726: PUSH
27727: LD_INT 0
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: LD_INT 2
27736: NEG
27737: PUSH
27738: LD_INT 1
27740: NEG
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 2
27748: NEG
27749: PUSH
27750: LD_INT 2
27752: NEG
27753: PUSH
27754: EMPTY
27755: LIST
27756: LIST
27757: PUSH
27758: EMPTY
27759: LIST
27760: LIST
27761: LIST
27762: LIST
27763: LIST
27764: LIST
27765: LIST
27766: LIST
27767: LIST
27768: LIST
27769: LIST
27770: LIST
27771: LIST
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27779: LD_ADDR_VAR 0 22
27783: PUSH
27784: LD_INT 0
27786: PUSH
27787: LD_INT 0
27789: PUSH
27790: EMPTY
27791: LIST
27792: LIST
27793: PUSH
27794: LD_INT 0
27796: PUSH
27797: LD_INT 1
27799: NEG
27800: PUSH
27801: EMPTY
27802: LIST
27803: LIST
27804: PUSH
27805: LD_INT 1
27807: PUSH
27808: LD_INT 0
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 1
27817: PUSH
27818: LD_INT 1
27820: PUSH
27821: EMPTY
27822: LIST
27823: LIST
27824: PUSH
27825: LD_INT 0
27827: PUSH
27828: LD_INT 1
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: PUSH
27835: LD_INT 1
27837: NEG
27838: PUSH
27839: LD_INT 0
27841: PUSH
27842: EMPTY
27843: LIST
27844: LIST
27845: PUSH
27846: LD_INT 1
27848: NEG
27849: PUSH
27850: LD_INT 1
27852: NEG
27853: PUSH
27854: EMPTY
27855: LIST
27856: LIST
27857: PUSH
27858: LD_INT 1
27860: NEG
27861: PUSH
27862: LD_INT 2
27864: NEG
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PUSH
27870: LD_INT 0
27872: PUSH
27873: LD_INT 2
27875: NEG
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 1
27883: PUSH
27884: LD_INT 1
27886: NEG
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PUSH
27892: LD_INT 2
27894: PUSH
27895: LD_INT 0
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 2
27904: PUSH
27905: LD_INT 1
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 2
27914: PUSH
27915: LD_INT 2
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 1
27924: PUSH
27925: LD_INT 2
27927: PUSH
27928: EMPTY
27929: LIST
27930: LIST
27931: PUSH
27932: LD_INT 0
27934: PUSH
27935: LD_INT 2
27937: PUSH
27938: EMPTY
27939: LIST
27940: LIST
27941: PUSH
27942: LD_INT 1
27944: NEG
27945: PUSH
27946: LD_INT 1
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: LD_INT 2
27955: NEG
27956: PUSH
27957: LD_INT 0
27959: PUSH
27960: EMPTY
27961: LIST
27962: LIST
27963: PUSH
27964: LD_INT 2
27966: NEG
27967: PUSH
27968: LD_INT 1
27970: NEG
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 2
27978: NEG
27979: PUSH
27980: LD_INT 2
27982: NEG
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: LIST
27992: LIST
27993: LIST
27994: LIST
27995: LIST
27996: LIST
27997: LIST
27998: LIST
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
28009: LD_ADDR_VAR 0 23
28013: PUSH
28014: LD_INT 0
28016: PUSH
28017: LD_INT 0
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 0
28026: PUSH
28027: LD_INT 1
28029: NEG
28030: PUSH
28031: EMPTY
28032: LIST
28033: LIST
28034: PUSH
28035: LD_INT 1
28037: PUSH
28038: LD_INT 0
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 1
28047: PUSH
28048: LD_INT 1
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: PUSH
28055: LD_INT 0
28057: PUSH
28058: LD_INT 1
28060: PUSH
28061: EMPTY
28062: LIST
28063: LIST
28064: PUSH
28065: LD_INT 1
28067: NEG
28068: PUSH
28069: LD_INT 0
28071: PUSH
28072: EMPTY
28073: LIST
28074: LIST
28075: PUSH
28076: LD_INT 1
28078: NEG
28079: PUSH
28080: LD_INT 1
28082: NEG
28083: PUSH
28084: EMPTY
28085: LIST
28086: LIST
28087: PUSH
28088: LD_INT 1
28090: NEG
28091: PUSH
28092: LD_INT 2
28094: NEG
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 0
28102: PUSH
28103: LD_INT 2
28105: NEG
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: PUSH
28111: LD_INT 1
28113: PUSH
28114: LD_INT 1
28116: NEG
28117: PUSH
28118: EMPTY
28119: LIST
28120: LIST
28121: PUSH
28122: LD_INT 2
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 2
28134: PUSH
28135: LD_INT 1
28137: PUSH
28138: EMPTY
28139: LIST
28140: LIST
28141: PUSH
28142: LD_INT 2
28144: PUSH
28145: LD_INT 2
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: PUSH
28152: LD_INT 1
28154: PUSH
28155: LD_INT 2
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 0
28164: PUSH
28165: LD_INT 2
28167: PUSH
28168: EMPTY
28169: LIST
28170: LIST
28171: PUSH
28172: LD_INT 1
28174: NEG
28175: PUSH
28176: LD_INT 1
28178: PUSH
28179: EMPTY
28180: LIST
28181: LIST
28182: PUSH
28183: LD_INT 2
28185: NEG
28186: PUSH
28187: LD_INT 0
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: LD_INT 2
28196: NEG
28197: PUSH
28198: LD_INT 1
28200: NEG
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: PUSH
28206: LD_INT 2
28208: NEG
28209: PUSH
28210: LD_INT 2
28212: NEG
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 2
28220: NEG
28221: PUSH
28222: LD_INT 3
28224: NEG
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: LD_INT 3
28236: NEG
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 1
28244: PUSH
28245: LD_INT 2
28247: NEG
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: PUSH
28253: LD_INT 2
28255: PUSH
28256: LD_INT 1
28258: NEG
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: LIST
28270: LIST
28271: LIST
28272: LIST
28273: LIST
28274: LIST
28275: LIST
28276: LIST
28277: LIST
28278: LIST
28279: LIST
28280: LIST
28281: LIST
28282: LIST
28283: LIST
28284: LIST
28285: LIST
28286: LIST
28287: LIST
28288: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28289: LD_ADDR_VAR 0 24
28293: PUSH
28294: LD_INT 0
28296: PUSH
28297: LD_INT 0
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 0
28306: PUSH
28307: LD_INT 1
28309: NEG
28310: PUSH
28311: EMPTY
28312: LIST
28313: LIST
28314: PUSH
28315: LD_INT 1
28317: PUSH
28318: LD_INT 0
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 1
28327: PUSH
28328: LD_INT 1
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 0
28337: PUSH
28338: LD_INT 1
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 1
28347: NEG
28348: PUSH
28349: LD_INT 0
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PUSH
28356: LD_INT 1
28358: NEG
28359: PUSH
28360: LD_INT 1
28362: NEG
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: PUSH
28368: LD_INT 1
28370: NEG
28371: PUSH
28372: LD_INT 2
28374: NEG
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: PUSH
28380: LD_INT 0
28382: PUSH
28383: LD_INT 2
28385: NEG
28386: PUSH
28387: EMPTY
28388: LIST
28389: LIST
28390: PUSH
28391: LD_INT 1
28393: PUSH
28394: LD_INT 1
28396: NEG
28397: PUSH
28398: EMPTY
28399: LIST
28400: LIST
28401: PUSH
28402: LD_INT 2
28404: PUSH
28405: LD_INT 0
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: PUSH
28412: LD_INT 2
28414: PUSH
28415: LD_INT 1
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: LD_INT 2
28424: PUSH
28425: LD_INT 2
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 1
28434: PUSH
28435: LD_INT 2
28437: PUSH
28438: EMPTY
28439: LIST
28440: LIST
28441: PUSH
28442: LD_INT 0
28444: PUSH
28445: LD_INT 2
28447: PUSH
28448: EMPTY
28449: LIST
28450: LIST
28451: PUSH
28452: LD_INT 1
28454: NEG
28455: PUSH
28456: LD_INT 1
28458: PUSH
28459: EMPTY
28460: LIST
28461: LIST
28462: PUSH
28463: LD_INT 2
28465: NEG
28466: PUSH
28467: LD_INT 0
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: PUSH
28474: LD_INT 2
28476: NEG
28477: PUSH
28478: LD_INT 1
28480: NEG
28481: PUSH
28482: EMPTY
28483: LIST
28484: LIST
28485: PUSH
28486: LD_INT 2
28488: NEG
28489: PUSH
28490: LD_INT 2
28492: NEG
28493: PUSH
28494: EMPTY
28495: LIST
28496: LIST
28497: PUSH
28498: LD_INT 1
28500: PUSH
28501: LD_INT 2
28503: NEG
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: PUSH
28509: LD_INT 2
28511: PUSH
28512: LD_INT 1
28514: NEG
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: LD_INT 3
28522: PUSH
28523: LD_INT 1
28525: PUSH
28526: EMPTY
28527: LIST
28528: LIST
28529: PUSH
28530: LD_INT 3
28532: PUSH
28533: LD_INT 2
28535: PUSH
28536: EMPTY
28537: LIST
28538: LIST
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: LIST
28544: LIST
28545: LIST
28546: LIST
28547: LIST
28548: LIST
28549: LIST
28550: LIST
28551: LIST
28552: LIST
28553: LIST
28554: LIST
28555: LIST
28556: LIST
28557: LIST
28558: LIST
28559: LIST
28560: LIST
28561: LIST
28562: LIST
28563: LIST
28564: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28565: LD_ADDR_VAR 0 25
28569: PUSH
28570: LD_INT 0
28572: PUSH
28573: LD_INT 0
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 0
28582: PUSH
28583: LD_INT 1
28585: NEG
28586: PUSH
28587: EMPTY
28588: LIST
28589: LIST
28590: PUSH
28591: LD_INT 1
28593: PUSH
28594: LD_INT 0
28596: PUSH
28597: EMPTY
28598: LIST
28599: LIST
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: LD_INT 1
28606: PUSH
28607: EMPTY
28608: LIST
28609: LIST
28610: PUSH
28611: LD_INT 0
28613: PUSH
28614: LD_INT 1
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: PUSH
28621: LD_INT 1
28623: NEG
28624: PUSH
28625: LD_INT 0
28627: PUSH
28628: EMPTY
28629: LIST
28630: LIST
28631: PUSH
28632: LD_INT 1
28634: NEG
28635: PUSH
28636: LD_INT 1
28638: NEG
28639: PUSH
28640: EMPTY
28641: LIST
28642: LIST
28643: PUSH
28644: LD_INT 1
28646: NEG
28647: PUSH
28648: LD_INT 2
28650: NEG
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 0
28658: PUSH
28659: LD_INT 2
28661: NEG
28662: PUSH
28663: EMPTY
28664: LIST
28665: LIST
28666: PUSH
28667: LD_INT 1
28669: PUSH
28670: LD_INT 1
28672: NEG
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 2
28680: PUSH
28681: LD_INT 0
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 2
28690: PUSH
28691: LD_INT 1
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: LD_INT 2
28700: PUSH
28701: LD_INT 2
28703: PUSH
28704: EMPTY
28705: LIST
28706: LIST
28707: PUSH
28708: LD_INT 1
28710: PUSH
28711: LD_INT 2
28713: PUSH
28714: EMPTY
28715: LIST
28716: LIST
28717: PUSH
28718: LD_INT 0
28720: PUSH
28721: LD_INT 2
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 1
28730: NEG
28731: PUSH
28732: LD_INT 1
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: LD_INT 0
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 2
28752: NEG
28753: PUSH
28754: LD_INT 1
28756: NEG
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 2
28764: NEG
28765: PUSH
28766: LD_INT 2
28768: NEG
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: LD_INT 3
28776: PUSH
28777: LD_INT 1
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: PUSH
28784: LD_INT 3
28786: PUSH
28787: LD_INT 2
28789: PUSH
28790: EMPTY
28791: LIST
28792: LIST
28793: PUSH
28794: LD_INT 2
28796: PUSH
28797: LD_INT 3
28799: PUSH
28800: EMPTY
28801: LIST
28802: LIST
28803: PUSH
28804: LD_INT 1
28806: PUSH
28807: LD_INT 3
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: LIST
28818: LIST
28819: LIST
28820: LIST
28821: LIST
28822: LIST
28823: LIST
28824: LIST
28825: LIST
28826: LIST
28827: LIST
28828: LIST
28829: LIST
28830: LIST
28831: LIST
28832: LIST
28833: LIST
28834: LIST
28835: LIST
28836: LIST
28837: LIST
28838: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28839: LD_ADDR_VAR 0 26
28843: PUSH
28844: LD_INT 0
28846: PUSH
28847: LD_INT 0
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 0
28856: PUSH
28857: LD_INT 1
28859: NEG
28860: PUSH
28861: EMPTY
28862: LIST
28863: LIST
28864: PUSH
28865: LD_INT 1
28867: PUSH
28868: LD_INT 0
28870: PUSH
28871: EMPTY
28872: LIST
28873: LIST
28874: PUSH
28875: LD_INT 1
28877: PUSH
28878: LD_INT 1
28880: PUSH
28881: EMPTY
28882: LIST
28883: LIST
28884: PUSH
28885: LD_INT 0
28887: PUSH
28888: LD_INT 1
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PUSH
28895: LD_INT 1
28897: NEG
28898: PUSH
28899: LD_INT 0
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 1
28908: NEG
28909: PUSH
28910: LD_INT 1
28912: NEG
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 1
28920: NEG
28921: PUSH
28922: LD_INT 2
28924: NEG
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: LD_INT 0
28932: PUSH
28933: LD_INT 2
28935: NEG
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: LD_INT 1
28946: NEG
28947: PUSH
28948: EMPTY
28949: LIST
28950: LIST
28951: PUSH
28952: LD_INT 2
28954: PUSH
28955: LD_INT 0
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 2
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 2
28974: PUSH
28975: LD_INT 2
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 1
28984: PUSH
28985: LD_INT 2
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 0
28994: PUSH
28995: LD_INT 2
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 1
29004: NEG
29005: PUSH
29006: LD_INT 1
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: LD_INT 2
29015: NEG
29016: PUSH
29017: LD_INT 0
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: LD_INT 2
29026: NEG
29027: PUSH
29028: LD_INT 1
29030: NEG
29031: PUSH
29032: EMPTY
29033: LIST
29034: LIST
29035: PUSH
29036: LD_INT 2
29038: NEG
29039: PUSH
29040: LD_INT 2
29042: NEG
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 2
29050: PUSH
29051: LD_INT 3
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: LD_INT 3
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 1
29070: NEG
29071: PUSH
29072: LD_INT 2
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: LD_INT 2
29081: NEG
29082: PUSH
29083: LD_INT 1
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: LIST
29094: LIST
29095: LIST
29096: LIST
29097: LIST
29098: LIST
29099: LIST
29100: LIST
29101: LIST
29102: LIST
29103: LIST
29104: LIST
29105: LIST
29106: LIST
29107: LIST
29108: LIST
29109: LIST
29110: LIST
29111: LIST
29112: LIST
29113: LIST
29114: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29115: LD_ADDR_VAR 0 27
29119: PUSH
29120: LD_INT 0
29122: PUSH
29123: LD_INT 0
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 0
29132: PUSH
29133: LD_INT 1
29135: NEG
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 1
29143: PUSH
29144: LD_INT 0
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 1
29153: PUSH
29154: LD_INT 1
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 0
29163: PUSH
29164: LD_INT 1
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PUSH
29171: LD_INT 1
29173: NEG
29174: PUSH
29175: LD_INT 0
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 1
29184: NEG
29185: PUSH
29186: LD_INT 1
29188: NEG
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: LD_INT 1
29196: NEG
29197: PUSH
29198: LD_INT 2
29200: NEG
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PUSH
29206: LD_INT 0
29208: PUSH
29209: LD_INT 2
29211: NEG
29212: PUSH
29213: EMPTY
29214: LIST
29215: LIST
29216: PUSH
29217: LD_INT 1
29219: PUSH
29220: LD_INT 1
29222: NEG
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 2
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 2
29240: PUSH
29241: LD_INT 1
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 2
29250: PUSH
29251: LD_INT 2
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: LD_INT 2
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 0
29270: PUSH
29271: LD_INT 2
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 1
29280: NEG
29281: PUSH
29282: LD_INT 1
29284: PUSH
29285: EMPTY
29286: LIST
29287: LIST
29288: PUSH
29289: LD_INT 2
29291: NEG
29292: PUSH
29293: LD_INT 0
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: PUSH
29300: LD_INT 2
29302: NEG
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 2
29314: NEG
29315: PUSH
29316: LD_INT 2
29318: NEG
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: LD_INT 1
29326: NEG
29327: PUSH
29328: LD_INT 2
29330: PUSH
29331: EMPTY
29332: LIST
29333: LIST
29334: PUSH
29335: LD_INT 2
29337: NEG
29338: PUSH
29339: LD_INT 1
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 3
29348: NEG
29349: PUSH
29350: LD_INT 1
29352: NEG
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 3
29360: NEG
29361: PUSH
29362: LD_INT 2
29364: NEG
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: EMPTY
29371: LIST
29372: LIST
29373: LIST
29374: LIST
29375: LIST
29376: LIST
29377: LIST
29378: LIST
29379: LIST
29380: LIST
29381: LIST
29382: LIST
29383: LIST
29384: LIST
29385: LIST
29386: LIST
29387: LIST
29388: LIST
29389: LIST
29390: LIST
29391: LIST
29392: LIST
29393: LIST
29394: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29395: LD_ADDR_VAR 0 28
29399: PUSH
29400: LD_INT 0
29402: PUSH
29403: LD_INT 0
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 0
29412: PUSH
29413: LD_INT 1
29415: NEG
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: LD_INT 0
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 1
29433: PUSH
29434: LD_INT 1
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 0
29443: PUSH
29444: LD_INT 1
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: NEG
29454: PUSH
29455: LD_INT 0
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: PUSH
29462: LD_INT 1
29464: NEG
29465: PUSH
29466: LD_INT 1
29468: NEG
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: PUSH
29474: LD_INT 1
29476: NEG
29477: PUSH
29478: LD_INT 2
29480: NEG
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: LD_INT 0
29488: PUSH
29489: LD_INT 2
29491: NEG
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 1
29499: PUSH
29500: LD_INT 1
29502: NEG
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 2
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 2
29520: PUSH
29521: LD_INT 1
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 2
29530: PUSH
29531: LD_INT 2
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: LD_INT 2
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 0
29550: PUSH
29551: LD_INT 2
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 2
29571: NEG
29572: PUSH
29573: LD_INT 0
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 2
29582: NEG
29583: PUSH
29584: LD_INT 1
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 2
29594: NEG
29595: PUSH
29596: LD_INT 2
29598: NEG
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: LD_INT 2
29606: NEG
29607: PUSH
29608: LD_INT 3
29610: NEG
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: LD_INT 3
29622: NEG
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 3
29630: NEG
29631: PUSH
29632: LD_INT 1
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 3
29642: NEG
29643: PUSH
29644: LD_INT 2
29646: NEG
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: EMPTY
29653: LIST
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29677: LD_ADDR_VAR 0 29
29681: PUSH
29682: LD_INT 0
29684: PUSH
29685: LD_INT 0
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 0
29694: PUSH
29695: LD_INT 1
29697: NEG
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 1
29705: PUSH
29706: LD_INT 0
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: PUSH
29713: LD_INT 1
29715: PUSH
29716: LD_INT 1
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 0
29725: PUSH
29726: LD_INT 1
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 1
29735: NEG
29736: PUSH
29737: LD_INT 0
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: PUSH
29744: LD_INT 1
29746: NEG
29747: PUSH
29748: LD_INT 1
29750: NEG
29751: PUSH
29752: EMPTY
29753: LIST
29754: LIST
29755: PUSH
29756: LD_INT 1
29758: NEG
29759: PUSH
29760: LD_INT 2
29762: NEG
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: LD_INT 0
29770: PUSH
29771: LD_INT 2
29773: NEG
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: LD_INT 1
29781: PUSH
29782: LD_INT 1
29784: NEG
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 2
29792: PUSH
29793: LD_INT 0
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: PUSH
29800: LD_INT 2
29802: PUSH
29803: LD_INT 1
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 1
29812: PUSH
29813: LD_INT 2
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: LD_INT 0
29822: PUSH
29823: LD_INT 2
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 1
29832: NEG
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 2
29843: NEG
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 2
29855: NEG
29856: PUSH
29857: LD_INT 2
29859: NEG
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PUSH
29865: LD_INT 2
29867: NEG
29868: PUSH
29869: LD_INT 3
29871: NEG
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: PUSH
29877: LD_INT 2
29879: PUSH
29880: LD_INT 1
29882: NEG
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 3
29890: PUSH
29891: LD_INT 1
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: PUSH
29898: LD_INT 1
29900: PUSH
29901: LD_INT 3
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 1
29910: NEG
29911: PUSH
29912: LD_INT 2
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 3
29921: NEG
29922: PUSH
29923: LD_INT 2
29925: NEG
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: LIST
29940: LIST
29941: LIST
29942: LIST
29943: LIST
29944: LIST
29945: LIST
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: LIST
29951: LIST
29952: LIST
29953: LIST
29954: LIST
29955: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29956: LD_ADDR_VAR 0 30
29960: PUSH
29961: LD_INT 0
29963: PUSH
29964: LD_INT 0
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: LD_INT 1
29976: NEG
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: LD_INT 0
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: PUSH
29995: LD_INT 1
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: PUSH
30002: LD_INT 0
30004: PUSH
30005: LD_INT 1
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 1
30014: NEG
30015: PUSH
30016: LD_INT 0
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: LD_INT 1
30025: NEG
30026: PUSH
30027: LD_INT 1
30029: NEG
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 1
30037: NEG
30038: PUSH
30039: LD_INT 2
30041: NEG
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 0
30049: PUSH
30050: LD_INT 2
30052: NEG
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 1
30060: PUSH
30061: LD_INT 1
30063: NEG
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 2
30071: PUSH
30072: LD_INT 0
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 2
30081: PUSH
30082: LD_INT 1
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 2
30091: PUSH
30092: LD_INT 2
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 1
30101: PUSH
30102: LD_INT 2
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 1
30111: NEG
30112: PUSH
30113: LD_INT 1
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 2
30122: NEG
30123: PUSH
30124: LD_INT 0
30126: PUSH
30127: EMPTY
30128: LIST
30129: LIST
30130: PUSH
30131: LD_INT 2
30133: NEG
30134: PUSH
30135: LD_INT 1
30137: NEG
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 1
30145: NEG
30146: PUSH
30147: LD_INT 3
30149: NEG
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 1
30157: PUSH
30158: LD_INT 2
30160: NEG
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 3
30168: PUSH
30169: LD_INT 2
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: PUSH
30176: LD_INT 2
30178: PUSH
30179: LD_INT 3
30181: PUSH
30182: EMPTY
30183: LIST
30184: LIST
30185: PUSH
30186: LD_INT 2
30188: NEG
30189: PUSH
30190: LD_INT 1
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: PUSH
30197: LD_INT 3
30199: NEG
30200: PUSH
30201: LD_INT 1
30203: NEG
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: LIST
30216: LIST
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30234: LD_ADDR_VAR 0 31
30238: PUSH
30239: LD_INT 0
30241: PUSH
30242: LD_INT 0
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: LD_INT 1
30254: NEG
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 1
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: LD_INT 1
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 0
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 1
30292: NEG
30293: PUSH
30294: LD_INT 0
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 1
30303: NEG
30304: PUSH
30305: LD_INT 1
30307: NEG
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 1
30315: NEG
30316: PUSH
30317: LD_INT 2
30319: NEG
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 1
30327: PUSH
30328: LD_INT 1
30330: NEG
30331: PUSH
30332: EMPTY
30333: LIST
30334: LIST
30335: PUSH
30336: LD_INT 2
30338: PUSH
30339: LD_INT 0
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 2
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 2
30358: PUSH
30359: LD_INT 2
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: PUSH
30369: LD_INT 2
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 0
30378: PUSH
30379: LD_INT 2
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 1
30388: NEG
30389: PUSH
30390: LD_INT 1
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 2
30399: NEG
30400: PUSH
30401: LD_INT 1
30403: NEG
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 2
30411: NEG
30412: PUSH
30413: LD_INT 2
30415: NEG
30416: PUSH
30417: EMPTY
30418: LIST
30419: LIST
30420: PUSH
30421: LD_INT 2
30423: NEG
30424: PUSH
30425: LD_INT 3
30427: NEG
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: LD_INT 2
30435: PUSH
30436: LD_INT 1
30438: NEG
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 3
30446: PUSH
30447: LD_INT 1
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 1
30456: PUSH
30457: LD_INT 3
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 1
30466: NEG
30467: PUSH
30468: LD_INT 2
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 3
30477: NEG
30478: PUSH
30479: LD_INT 2
30481: NEG
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: EMPTY
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30512: LD_ADDR_VAR 0 32
30516: PUSH
30517: LD_INT 0
30519: PUSH
30520: LD_INT 0
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: PUSH
30527: LD_INT 0
30529: PUSH
30530: LD_INT 1
30532: NEG
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 1
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 1
30550: PUSH
30551: LD_INT 1
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 0
30560: PUSH
30561: LD_INT 1
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 1
30570: NEG
30571: PUSH
30572: LD_INT 0
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 1
30581: NEG
30582: PUSH
30583: LD_INT 1
30585: NEG
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 1
30593: NEG
30594: PUSH
30595: LD_INT 2
30597: NEG
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 0
30605: PUSH
30606: LD_INT 2
30608: NEG
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 1
30616: PUSH
30617: LD_INT 1
30619: NEG
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 2
30627: PUSH
30628: LD_INT 1
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 2
30637: PUSH
30638: LD_INT 2
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: LD_INT 1
30647: PUSH
30648: LD_INT 2
30650: PUSH
30651: EMPTY
30652: LIST
30653: LIST
30654: PUSH
30655: LD_INT 0
30657: PUSH
30658: LD_INT 2
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 1
30667: NEG
30668: PUSH
30669: LD_INT 1
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 2
30678: NEG
30679: PUSH
30680: LD_INT 0
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 2
30689: NEG
30690: PUSH
30691: LD_INT 1
30693: NEG
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 1
30701: NEG
30702: PUSH
30703: LD_INT 3
30705: NEG
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 1
30713: PUSH
30714: LD_INT 2
30716: NEG
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 3
30724: PUSH
30725: LD_INT 2
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 2
30734: PUSH
30735: LD_INT 3
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 2
30744: NEG
30745: PUSH
30746: LD_INT 1
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 3
30755: NEG
30756: PUSH
30757: LD_INT 1
30759: NEG
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: LIST
30769: LIST
30770: LIST
30771: LIST
30772: LIST
30773: LIST
30774: LIST
30775: LIST
30776: LIST
30777: LIST
30778: LIST
30779: LIST
30780: LIST
30781: LIST
30782: LIST
30783: LIST
30784: LIST
30785: LIST
30786: LIST
30787: LIST
30788: LIST
30789: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30790: LD_ADDR_VAR 0 33
30794: PUSH
30795: LD_INT 0
30797: PUSH
30798: LD_INT 0
30800: PUSH
30801: EMPTY
30802: LIST
30803: LIST
30804: PUSH
30805: LD_INT 0
30807: PUSH
30808: LD_INT 1
30810: NEG
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 1
30818: PUSH
30819: LD_INT 0
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: LD_INT 1
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: LD_INT 0
30838: PUSH
30839: LD_INT 1
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 1
30848: NEG
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_INT 1
30859: NEG
30860: PUSH
30861: LD_INT 1
30863: NEG
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 1
30871: NEG
30872: PUSH
30873: LD_INT 2
30875: NEG
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 1
30883: PUSH
30884: LD_INT 1
30886: NEG
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 2
30894: PUSH
30895: LD_INT 0
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 2
30904: PUSH
30905: LD_INT 1
30907: PUSH
30908: EMPTY
30909: LIST
30910: LIST
30911: PUSH
30912: LD_INT 1
30914: PUSH
30915: LD_INT 2
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: LD_INT 2
30927: PUSH
30928: EMPTY
30929: LIST
30930: LIST
30931: PUSH
30932: LD_INT 1
30934: NEG
30935: PUSH
30936: LD_INT 1
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: PUSH
30943: LD_INT 2
30945: NEG
30946: PUSH
30947: LD_INT 0
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 2
30956: NEG
30957: PUSH
30958: LD_INT 1
30960: NEG
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: PUSH
30966: LD_INT 2
30968: NEG
30969: PUSH
30970: LD_INT 2
30972: NEG
30973: PUSH
30974: EMPTY
30975: LIST
30976: LIST
30977: PUSH
30978: LD_INT 2
30980: NEG
30981: PUSH
30982: LD_INT 3
30984: NEG
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 2
30992: PUSH
30993: LD_INT 1
30995: NEG
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 3
31003: PUSH
31004: LD_INT 1
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 1
31013: PUSH
31014: LD_INT 3
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 1
31023: NEG
31024: PUSH
31025: LD_INT 2
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 3
31034: NEG
31035: PUSH
31036: LD_INT 2
31038: NEG
31039: PUSH
31040: EMPTY
31041: LIST
31042: LIST
31043: PUSH
31044: EMPTY
31045: LIST
31046: LIST
31047: LIST
31048: LIST
31049: LIST
31050: LIST
31051: LIST
31052: LIST
31053: LIST
31054: LIST
31055: LIST
31056: LIST
31057: LIST
31058: LIST
31059: LIST
31060: LIST
31061: LIST
31062: LIST
31063: LIST
31064: LIST
31065: LIST
31066: LIST
31067: LIST
31068: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31069: LD_ADDR_VAR 0 34
31073: PUSH
31074: LD_INT 0
31076: PUSH
31077: LD_INT 0
31079: PUSH
31080: EMPTY
31081: LIST
31082: LIST
31083: PUSH
31084: LD_INT 0
31086: PUSH
31087: LD_INT 1
31089: NEG
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 1
31097: PUSH
31098: LD_INT 0
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 1
31107: PUSH
31108: LD_INT 1
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 0
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 1
31127: NEG
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 1
31138: NEG
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 2
31154: NEG
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 0
31162: PUSH
31163: LD_INT 2
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 1
31173: PUSH
31174: LD_INT 1
31176: NEG
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 2
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: PUSH
31195: LD_INT 2
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 1
31214: NEG
31215: PUSH
31216: LD_INT 1
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 2
31225: NEG
31226: PUSH
31227: LD_INT 0
31229: PUSH
31230: EMPTY
31231: LIST
31232: LIST
31233: PUSH
31234: LD_INT 2
31236: NEG
31237: PUSH
31238: LD_INT 1
31240: NEG
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 2
31248: NEG
31249: PUSH
31250: LD_INT 2
31252: NEG
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: LD_INT 1
31260: NEG
31261: PUSH
31262: LD_INT 3
31264: NEG
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 1
31272: PUSH
31273: LD_INT 2
31275: NEG
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 3
31283: PUSH
31284: LD_INT 2
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 2
31293: PUSH
31294: LD_INT 3
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 2
31303: NEG
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 3
31314: NEG
31315: PUSH
31316: LD_INT 1
31318: NEG
31319: PUSH
31320: EMPTY
31321: LIST
31322: LIST
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: LIST
31335: LIST
31336: LIST
31337: LIST
31338: LIST
31339: LIST
31340: LIST
31341: LIST
31342: LIST
31343: LIST
31344: LIST
31345: LIST
31346: LIST
31347: LIST
31348: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31349: LD_ADDR_VAR 0 35
31353: PUSH
31354: LD_INT 0
31356: PUSH
31357: LD_INT 0
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 0
31366: PUSH
31367: LD_INT 1
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 1
31377: PUSH
31378: LD_INT 0
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 1
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: LD_INT 1
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: PUSH
31405: LD_INT 1
31407: NEG
31408: PUSH
31409: LD_INT 0
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: LD_INT 1
31418: NEG
31419: PUSH
31420: LD_INT 1
31422: NEG
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 2
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 2
31440: NEG
31441: PUSH
31442: LD_INT 1
31444: NEG
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31461: LD_ADDR_VAR 0 36
31465: PUSH
31466: LD_INT 0
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 0
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: PUSH
31490: LD_INT 0
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 1
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: LD_INT 1
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 1
31519: NEG
31520: PUSH
31521: LD_INT 0
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 1
31530: NEG
31531: PUSH
31532: LD_INT 1
31534: NEG
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 1
31542: NEG
31543: PUSH
31544: LD_INT 2
31546: NEG
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 1
31554: PUSH
31555: LD_INT 2
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: LIST
31572: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31573: LD_ADDR_VAR 0 37
31577: PUSH
31578: LD_INT 0
31580: PUSH
31581: LD_INT 0
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 0
31590: PUSH
31591: LD_INT 1
31593: NEG
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 1
31601: PUSH
31602: LD_INT 0
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: LD_INT 1
31611: PUSH
31612: LD_INT 1
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PUSH
31619: LD_INT 0
31621: PUSH
31622: LD_INT 1
31624: PUSH
31625: EMPTY
31626: LIST
31627: LIST
31628: PUSH
31629: LD_INT 1
31631: NEG
31632: PUSH
31633: LD_INT 0
31635: PUSH
31636: EMPTY
31637: LIST
31638: LIST
31639: PUSH
31640: LD_INT 1
31642: NEG
31643: PUSH
31644: LD_INT 1
31646: NEG
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 1
31654: PUSH
31655: LD_INT 1
31657: NEG
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: LD_INT 1
31665: NEG
31666: PUSH
31667: LD_INT 1
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: LIST
31678: LIST
31679: LIST
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31685: LD_ADDR_VAR 0 38
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 0
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 0
31702: PUSH
31703: LD_INT 1
31705: NEG
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 1
31713: PUSH
31714: LD_INT 0
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 1
31723: PUSH
31724: LD_INT 1
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 0
31733: PUSH
31734: LD_INT 1
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 1
31743: NEG
31744: PUSH
31745: LD_INT 0
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 1
31754: NEG
31755: PUSH
31756: LD_INT 1
31758: NEG
31759: PUSH
31760: EMPTY
31761: LIST
31762: LIST
31763: PUSH
31764: LD_INT 2
31766: PUSH
31767: LD_INT 1
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 2
31776: NEG
31777: PUSH
31778: LD_INT 1
31780: NEG
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: LIST
31790: LIST
31791: LIST
31792: LIST
31793: LIST
31794: LIST
31795: LIST
31796: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31797: LD_ADDR_VAR 0 39
31801: PUSH
31802: LD_INT 0
31804: PUSH
31805: LD_INT 0
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 0
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: PUSH
31826: LD_INT 0
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 1
31835: PUSH
31836: LD_INT 1
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 0
31845: PUSH
31846: LD_INT 1
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 1
31855: NEG
31856: PUSH
31857: LD_INT 0
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: LD_INT 1
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: LD_INT 1
31878: NEG
31879: PUSH
31880: LD_INT 2
31882: NEG
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: PUSH
31888: LD_INT 1
31890: PUSH
31891: LD_INT 2
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: LIST
31907: LIST
31908: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31909: LD_ADDR_VAR 0 40
31913: PUSH
31914: LD_INT 0
31916: PUSH
31917: LD_INT 0
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 0
31926: PUSH
31927: LD_INT 1
31929: NEG
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 1
31937: PUSH
31938: LD_INT 0
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: LD_INT 1
31947: PUSH
31948: LD_INT 1
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 0
31957: PUSH
31958: LD_INT 1
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 1
31967: NEG
31968: PUSH
31969: LD_INT 0
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 1
31978: NEG
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PUSH
31988: LD_INT 1
31990: PUSH
31991: LD_INT 1
31993: NEG
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: NEG
32002: PUSH
32003: LD_INT 1
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: LIST
32014: LIST
32015: LIST
32016: LIST
32017: LIST
32018: LIST
32019: LIST
32020: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32021: LD_ADDR_VAR 0 41
32025: PUSH
32026: LD_INT 0
32028: PUSH
32029: LD_INT 0
32031: PUSH
32032: EMPTY
32033: LIST
32034: LIST
32035: PUSH
32036: LD_INT 0
32038: PUSH
32039: LD_INT 1
32041: NEG
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 1
32049: PUSH
32050: LD_INT 0
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 1
32059: PUSH
32060: LD_INT 1
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 0
32069: PUSH
32070: LD_INT 1
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 1
32079: NEG
32080: PUSH
32081: LD_INT 0
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: LD_INT 1
32090: NEG
32091: PUSH
32092: LD_INT 1
32094: NEG
32095: PUSH
32096: EMPTY
32097: LIST
32098: LIST
32099: PUSH
32100: LD_INT 1
32102: NEG
32103: PUSH
32104: LD_INT 2
32106: NEG
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 1
32114: PUSH
32115: LD_INT 1
32117: NEG
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 2
32125: PUSH
32126: LD_INT 0
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 2
32135: PUSH
32136: LD_INT 1
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 2
32145: PUSH
32146: LD_INT 2
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 1
32155: PUSH
32156: LD_INT 2
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 1
32165: NEG
32166: PUSH
32167: LD_INT 1
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 2
32176: NEG
32177: PUSH
32178: LD_INT 0
32180: PUSH
32181: EMPTY
32182: LIST
32183: LIST
32184: PUSH
32185: LD_INT 2
32187: NEG
32188: PUSH
32189: LD_INT 1
32191: NEG
32192: PUSH
32193: EMPTY
32194: LIST
32195: LIST
32196: PUSH
32197: LD_INT 2
32199: NEG
32200: PUSH
32201: LD_INT 2
32203: NEG
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: LD_INT 2
32211: NEG
32212: PUSH
32213: LD_INT 3
32215: NEG
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 2
32223: PUSH
32224: LD_INT 1
32226: NEG
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 3
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 3
32244: PUSH
32245: LD_INT 1
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 3
32254: PUSH
32255: LD_INT 2
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 3
32264: PUSH
32265: LD_INT 3
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 2
32274: PUSH
32275: LD_INT 3
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: NEG
32285: PUSH
32286: LD_INT 1
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 3
32295: NEG
32296: PUSH
32297: LD_INT 0
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: LD_INT 3
32306: NEG
32307: PUSH
32308: LD_INT 1
32310: NEG
32311: PUSH
32312: EMPTY
32313: LIST
32314: LIST
32315: PUSH
32316: LD_INT 3
32318: NEG
32319: PUSH
32320: LD_INT 2
32322: NEG
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 3
32330: NEG
32331: PUSH
32332: LD_INT 3
32334: NEG
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: LIST
32344: LIST
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: LIST
32350: LIST
32351: LIST
32352: LIST
32353: LIST
32354: LIST
32355: LIST
32356: LIST
32357: LIST
32358: LIST
32359: LIST
32360: LIST
32361: LIST
32362: LIST
32363: LIST
32364: LIST
32365: LIST
32366: LIST
32367: LIST
32368: LIST
32369: LIST
32370: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32371: LD_ADDR_VAR 0 42
32375: PUSH
32376: LD_INT 0
32378: PUSH
32379: LD_INT 0
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 0
32388: PUSH
32389: LD_INT 1
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 1
32399: PUSH
32400: LD_INT 0
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 1
32409: PUSH
32410: LD_INT 1
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 0
32419: PUSH
32420: LD_INT 1
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 1
32429: NEG
32430: PUSH
32431: LD_INT 0
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 1
32440: NEG
32441: PUSH
32442: LD_INT 1
32444: NEG
32445: PUSH
32446: EMPTY
32447: LIST
32448: LIST
32449: PUSH
32450: LD_INT 1
32452: NEG
32453: PUSH
32454: LD_INT 2
32456: NEG
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 0
32464: PUSH
32465: LD_INT 2
32467: NEG
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 1
32475: PUSH
32476: LD_INT 1
32478: NEG
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 2
32486: PUSH
32487: LD_INT 1
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: LD_INT 2
32496: PUSH
32497: LD_INT 2
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: LD_INT 2
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 0
32516: PUSH
32517: LD_INT 2
32519: PUSH
32520: EMPTY
32521: LIST
32522: LIST
32523: PUSH
32524: LD_INT 1
32526: NEG
32527: PUSH
32528: LD_INT 1
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 2
32537: NEG
32538: PUSH
32539: LD_INT 1
32541: NEG
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 2
32549: NEG
32550: PUSH
32551: LD_INT 2
32553: NEG
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 2
32561: NEG
32562: PUSH
32563: LD_INT 3
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: NEG
32574: PUSH
32575: LD_INT 3
32577: NEG
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: LD_INT 3
32588: NEG
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: LD_INT 2
32599: NEG
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 3
32607: PUSH
32608: LD_INT 2
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 3
32617: PUSH
32618: LD_INT 3
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 2
32627: PUSH
32628: LD_INT 3
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 1
32637: PUSH
32638: LD_INT 3
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 0
32647: PUSH
32648: LD_INT 3
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 1
32657: NEG
32658: PUSH
32659: LD_INT 2
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PUSH
32666: LD_INT 3
32668: NEG
32669: PUSH
32670: LD_INT 2
32672: NEG
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 3
32680: NEG
32681: PUSH
32682: LD_INT 3
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: LIST
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: LIST
32709: LIST
32710: LIST
32711: LIST
32712: LIST
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32721: LD_ADDR_VAR 0 43
32725: PUSH
32726: LD_INT 0
32728: PUSH
32729: LD_INT 0
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: LD_INT 1
32741: NEG
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 1
32749: PUSH
32750: LD_INT 0
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: PUSH
32760: LD_INT 1
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 0
32769: PUSH
32770: LD_INT 1
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 1
32779: NEG
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 1
32790: NEG
32791: PUSH
32792: LD_INT 1
32794: NEG
32795: PUSH
32796: EMPTY
32797: LIST
32798: LIST
32799: PUSH
32800: LD_INT 1
32802: NEG
32803: PUSH
32804: LD_INT 2
32806: NEG
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 0
32814: PUSH
32815: LD_INT 2
32817: NEG
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: LD_INT 1
32828: NEG
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: PUSH
32837: LD_INT 0
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 2
32846: PUSH
32847: LD_INT 1
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 1
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 2
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: LD_INT 1
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 2
32887: NEG
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: NEG
32899: PUSH
32900: LD_INT 1
32902: NEG
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 1
32910: NEG
32911: PUSH
32912: LD_INT 3
32914: NEG
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 0
32922: PUSH
32923: LD_INT 3
32925: NEG
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 1
32933: PUSH
32934: LD_INT 2
32936: NEG
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 2
32944: PUSH
32945: LD_INT 1
32947: NEG
32948: PUSH
32949: EMPTY
32950: LIST
32951: LIST
32952: PUSH
32953: LD_INT 3
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 3
32965: PUSH
32966: LD_INT 1
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 1
32975: PUSH
32976: LD_INT 3
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 0
32985: PUSH
32986: LD_INT 3
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 1
32995: NEG
32996: PUSH
32997: LD_INT 2
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: LD_INT 2
33006: NEG
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 3
33017: NEG
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 3
33028: NEG
33029: PUSH
33030: LD_INT 1
33032: NEG
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: EMPTY
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33069: LD_ADDR_VAR 0 44
33073: PUSH
33074: LD_INT 0
33076: PUSH
33077: LD_INT 0
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: LD_INT 1
33089: NEG
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 1
33097: PUSH
33098: LD_INT 0
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 1
33107: PUSH
33108: LD_INT 1
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: LD_INT 1
33120: PUSH
33121: EMPTY
33122: LIST
33123: LIST
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: LD_INT 0
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 1
33138: NEG
33139: PUSH
33140: LD_INT 1
33142: NEG
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 1
33150: NEG
33151: PUSH
33152: LD_INT 2
33154: NEG
33155: PUSH
33156: EMPTY
33157: LIST
33158: LIST
33159: PUSH
33160: LD_INT 1
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 2
33173: PUSH
33174: LD_INT 0
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 2
33183: PUSH
33184: LD_INT 1
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 2
33193: PUSH
33194: LD_INT 2
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: LD_INT 2
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 1
33213: NEG
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 2
33224: NEG
33225: PUSH
33226: LD_INT 0
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 2
33235: NEG
33236: PUSH
33237: LD_INT 1
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 2
33247: NEG
33248: PUSH
33249: LD_INT 2
33251: NEG
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 2
33259: NEG
33260: PUSH
33261: LD_INT 3
33263: NEG
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 2
33271: PUSH
33272: LD_INT 1
33274: NEG
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 3
33282: PUSH
33283: LD_INT 0
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 3
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 3
33302: PUSH
33303: LD_INT 2
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 3
33312: PUSH
33313: LD_INT 3
33315: PUSH
33316: EMPTY
33317: LIST
33318: LIST
33319: PUSH
33320: LD_INT 2
33322: PUSH
33323: LD_INT 3
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 2
33332: NEG
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: EMPTY
33338: LIST
33339: LIST
33340: PUSH
33341: LD_INT 3
33343: NEG
33344: PUSH
33345: LD_INT 0
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: PUSH
33352: LD_INT 3
33354: NEG
33355: PUSH
33356: LD_INT 1
33358: NEG
33359: PUSH
33360: EMPTY
33361: LIST
33362: LIST
33363: PUSH
33364: LD_INT 3
33366: NEG
33367: PUSH
33368: LD_INT 2
33370: NEG
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 3
33378: NEG
33379: PUSH
33380: LD_INT 3
33382: NEG
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: LIST
33401: LIST
33402: LIST
33403: LIST
33404: LIST
33405: LIST
33406: LIST
33407: LIST
33408: LIST
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: LIST
33415: LIST
33416: LIST
33417: LIST
33418: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33419: LD_ADDR_VAR 0 45
33423: PUSH
33424: LD_INT 0
33426: PUSH
33427: LD_INT 0
33429: PUSH
33430: EMPTY
33431: LIST
33432: LIST
33433: PUSH
33434: LD_INT 0
33436: PUSH
33437: LD_INT 1
33439: NEG
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 1
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 1
33457: PUSH
33458: LD_INT 1
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 0
33467: PUSH
33468: LD_INT 1
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: LD_INT 1
33477: NEG
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: NEG
33489: PUSH
33490: LD_INT 1
33492: NEG
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 1
33500: NEG
33501: PUSH
33502: LD_INT 2
33504: NEG
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: LD_INT 2
33515: NEG
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 1
33523: PUSH
33524: LD_INT 1
33526: NEG
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 2
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 2
33544: PUSH
33545: LD_INT 2
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: LD_INT 2
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 0
33564: PUSH
33565: LD_INT 2
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: LD_INT 1
33574: NEG
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 2
33585: NEG
33586: PUSH
33587: LD_INT 1
33589: NEG
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 2
33597: NEG
33598: PUSH
33599: LD_INT 2
33601: NEG
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 2
33609: NEG
33610: PUSH
33611: LD_INT 3
33613: NEG
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: NEG
33622: PUSH
33623: LD_INT 3
33625: NEG
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 0
33633: PUSH
33634: LD_INT 3
33636: NEG
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 1
33644: PUSH
33645: LD_INT 2
33647: NEG
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 3
33655: PUSH
33656: LD_INT 2
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 3
33665: PUSH
33666: LD_INT 3
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 2
33675: PUSH
33676: LD_INT 3
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 1
33685: PUSH
33686: LD_INT 3
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 0
33695: PUSH
33696: LD_INT 3
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 1
33705: NEG
33706: PUSH
33707: LD_INT 2
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 3
33716: NEG
33717: PUSH
33718: LD_INT 2
33720: NEG
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 3
33728: NEG
33729: PUSH
33730: LD_INT 3
33732: NEG
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: EMPTY
33739: LIST
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: LIST
33760: LIST
33761: LIST
33762: LIST
33763: LIST
33764: LIST
33765: LIST
33766: LIST
33767: LIST
33768: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33769: LD_ADDR_VAR 0 46
33773: PUSH
33774: LD_INT 0
33776: PUSH
33777: LD_INT 0
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: LD_INT 1
33789: NEG
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 1
33797: PUSH
33798: LD_INT 0
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: PUSH
33808: LD_INT 1
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 0
33817: PUSH
33818: LD_INT 1
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 1
33827: NEG
33828: PUSH
33829: LD_INT 0
33831: PUSH
33832: EMPTY
33833: LIST
33834: LIST
33835: PUSH
33836: LD_INT 1
33838: NEG
33839: PUSH
33840: LD_INT 1
33842: NEG
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 1
33850: NEG
33851: PUSH
33852: LD_INT 2
33854: NEG
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 0
33862: PUSH
33863: LD_INT 2
33865: NEG
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 1
33873: PUSH
33874: LD_INT 1
33876: NEG
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 2
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 2
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 1
33904: PUSH
33905: LD_INT 2
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 0
33914: PUSH
33915: LD_INT 2
33917: PUSH
33918: EMPTY
33919: LIST
33920: LIST
33921: PUSH
33922: LD_INT 1
33924: NEG
33925: PUSH
33926: LD_INT 1
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 2
33935: NEG
33936: PUSH
33937: LD_INT 0
33939: PUSH
33940: EMPTY
33941: LIST
33942: LIST
33943: PUSH
33944: LD_INT 2
33946: NEG
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 1
33958: NEG
33959: PUSH
33960: LD_INT 3
33962: NEG
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 0
33970: PUSH
33971: LD_INT 3
33973: NEG
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: PUSH
33982: LD_INT 2
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 2
33992: PUSH
33993: LD_INT 1
33995: NEG
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 3
34003: PUSH
34004: LD_INT 0
34006: PUSH
34007: EMPTY
34008: LIST
34009: LIST
34010: PUSH
34011: LD_INT 3
34013: PUSH
34014: LD_INT 1
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: PUSH
34024: LD_INT 3
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PUSH
34031: LD_INT 0
34033: PUSH
34034: LD_INT 3
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 1
34043: NEG
34044: PUSH
34045: LD_INT 2
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 2
34054: NEG
34055: PUSH
34056: LD_INT 1
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 3
34065: NEG
34066: PUSH
34067: LD_INT 0
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 3
34076: NEG
34077: PUSH
34078: LD_INT 1
34080: NEG
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: LIST
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: LIST
34102: LIST
34103: LIST
34104: LIST
34105: LIST
34106: LIST
34107: LIST
34108: LIST
34109: LIST
34110: LIST
34111: LIST
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34117: LD_ADDR_VAR 0 47
34121: PUSH
34122: LD_INT 0
34124: PUSH
34125: LD_INT 0
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 0
34134: PUSH
34135: LD_INT 1
34137: NEG
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: LD_INT 0
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: LD_INT 1
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 1
34175: NEG
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 1
34186: NEG
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: LD_INT 2
34202: NEG
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: LD_INT 2
34213: NEG
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 1
34221: PUSH
34222: LD_INT 1
34224: NEG
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 2
34232: NEG
34233: PUSH
34234: LD_INT 1
34236: NEG
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 2
34244: NEG
34245: PUSH
34246: LD_INT 2
34248: NEG
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34268: LD_ADDR_VAR 0 48
34272: PUSH
34273: LD_INT 0
34275: PUSH
34276: LD_INT 0
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 0
34285: PUSH
34286: LD_INT 1
34288: NEG
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 1
34296: PUSH
34297: LD_INT 0
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: LD_INT 1
34306: PUSH
34307: LD_INT 1
34309: PUSH
34310: EMPTY
34311: LIST
34312: LIST
34313: PUSH
34314: LD_INT 0
34316: PUSH
34317: LD_INT 1
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 1
34326: NEG
34327: PUSH
34328: LD_INT 0
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 1
34337: NEG
34338: PUSH
34339: LD_INT 1
34341: NEG
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 1
34349: NEG
34350: PUSH
34351: LD_INT 2
34353: NEG
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 0
34361: PUSH
34362: LD_INT 2
34364: NEG
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: LD_INT 1
34375: NEG
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: LD_INT 2
34383: PUSH
34384: LD_INT 0
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 2
34393: PUSH
34394: LD_INT 1
34396: PUSH
34397: EMPTY
34398: LIST
34399: LIST
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34415: LD_ADDR_VAR 0 49
34419: PUSH
34420: LD_INT 0
34422: PUSH
34423: LD_INT 0
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 0
34432: PUSH
34433: LD_INT 1
34435: NEG
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: PUSH
34444: LD_INT 0
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: LD_INT 1
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 0
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: LD_INT 1
34473: NEG
34474: PUSH
34475: LD_INT 0
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: NEG
34485: PUSH
34486: LD_INT 1
34488: NEG
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 1
34496: PUSH
34497: LD_INT 1
34499: NEG
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: LD_INT 0
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: LD_INT 1
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 2
34527: PUSH
34528: LD_INT 2
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 1
34537: PUSH
34538: LD_INT 2
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34559: LD_ADDR_VAR 0 50
34563: PUSH
34564: LD_INT 0
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 0
34576: PUSH
34577: LD_INT 1
34579: NEG
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 1
34587: PUSH
34588: LD_INT 0
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 1
34597: PUSH
34598: LD_INT 1
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 0
34607: PUSH
34608: LD_INT 1
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 1
34617: NEG
34618: PUSH
34619: LD_INT 0
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: EMPTY
34635: LIST
34636: LIST
34637: PUSH
34638: LD_INT 2
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 2
34650: PUSH
34651: LD_INT 2
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: LD_INT 2
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: LD_INT 2
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 1
34680: NEG
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34703: LD_ADDR_VAR 0 51
34707: PUSH
34708: LD_INT 0
34710: PUSH
34711: LD_INT 0
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 0
34720: PUSH
34721: LD_INT 1
34723: NEG
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 1
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 1
34741: PUSH
34742: LD_INT 1
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PUSH
34749: LD_INT 0
34751: PUSH
34752: LD_INT 1
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 1
34761: NEG
34762: PUSH
34763: LD_INT 0
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 1
34772: NEG
34773: PUSH
34774: LD_INT 1
34776: NEG
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 1
34784: PUSH
34785: LD_INT 2
34787: PUSH
34788: EMPTY
34789: LIST
34790: LIST
34791: PUSH
34792: LD_INT 0
34794: PUSH
34795: LD_INT 2
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 1
34804: NEG
34805: PUSH
34806: LD_INT 1
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 2
34815: NEG
34816: PUSH
34817: LD_INT 0
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 2
34826: NEG
34827: PUSH
34828: LD_INT 1
34830: NEG
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: LIST
34842: LIST
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: LIST
34848: LIST
34849: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34850: LD_ADDR_VAR 0 52
34854: PUSH
34855: LD_INT 0
34857: PUSH
34858: LD_INT 0
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 0
34867: PUSH
34868: LD_INT 1
34870: NEG
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 1
34878: PUSH
34879: LD_INT 0
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 1
34888: PUSH
34889: LD_INT 1
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 0
34898: PUSH
34899: LD_INT 1
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 1
34908: NEG
34909: PUSH
34910: LD_INT 0
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 1
34919: NEG
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 1
34931: NEG
34932: PUSH
34933: LD_INT 2
34935: NEG
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 1
34943: NEG
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 2
34954: NEG
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 2
34965: NEG
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 2
34977: NEG
34978: PUSH
34979: LD_INT 2
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: EMPTY
34988: LIST
34989: LIST
34990: LIST
34991: LIST
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35001: LD_ADDR_VAR 0 53
35005: PUSH
35006: LD_INT 0
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 0
35018: PUSH
35019: LD_INT 1
35021: NEG
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 1
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: LD_INT 1
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 0
35049: PUSH
35050: LD_INT 1
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 1
35059: NEG
35060: PUSH
35061: LD_INT 0
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 1
35070: NEG
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 1
35082: NEG
35083: PUSH
35084: LD_INT 2
35086: NEG
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: LD_INT 2
35097: NEG
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: PUSH
35103: LD_INT 1
35105: PUSH
35106: LD_INT 1
35108: NEG
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 2
35116: PUSH
35117: LD_INT 0
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 2
35126: PUSH
35127: LD_INT 1
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 2
35136: PUSH
35137: LD_INT 2
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: PUSH
35147: LD_INT 2
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 0
35156: PUSH
35157: LD_INT 2
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 2
35177: NEG
35178: PUSH
35179: LD_INT 0
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 2
35188: NEG
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: NEG
35201: PUSH
35202: LD_INT 2
35204: NEG
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: LIST
35214: LIST
35215: LIST
35216: LIST
35217: LIST
35218: LIST
35219: LIST
35220: LIST
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35231: LD_ADDR_VAR 0 54
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 1
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 0
35279: PUSH
35280: LD_INT 1
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 1
35289: NEG
35290: PUSH
35291: LD_INT 0
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: LD_INT 1
35304: NEG
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 1
35312: NEG
35313: PUSH
35314: LD_INT 2
35316: NEG
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: LD_INT 2
35327: NEG
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 1
35335: PUSH
35336: LD_INT 1
35338: NEG
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 2
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 2
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 2
35366: PUSH
35367: LD_INT 2
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 1
35376: PUSH
35377: LD_INT 2
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 0
35386: PUSH
35387: LD_INT 2
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: LD_INT 1
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 2
35407: NEG
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 2
35418: NEG
35419: PUSH
35420: LD_INT 1
35422: NEG
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 2
35430: NEG
35431: PUSH
35432: LD_INT 2
35434: NEG
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35461: LD_ADDR_VAR 0 55
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: LD_INT 0
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: PUSH
35476: LD_INT 0
35478: PUSH
35479: LD_INT 1
35481: NEG
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 1
35489: PUSH
35490: LD_INT 0
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: LD_INT 1
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 0
35509: PUSH
35510: LD_INT 1
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: NEG
35520: PUSH
35521: LD_INT 0
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: NEG
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: LD_INT 1
35542: NEG
35543: PUSH
35544: LD_INT 2
35546: NEG
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: LD_INT 2
35557: NEG
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 1
35565: PUSH
35566: LD_INT 1
35568: NEG
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 2
35576: PUSH
35577: LD_INT 0
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 2
35586: PUSH
35587: LD_INT 1
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 2
35596: PUSH
35597: LD_INT 2
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: LD_INT 2
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 0
35616: PUSH
35617: LD_INT 2
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: LD_INT 1
35626: NEG
35627: PUSH
35628: LD_INT 1
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: LD_INT 2
35637: NEG
35638: PUSH
35639: LD_INT 0
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 2
35648: NEG
35649: PUSH
35650: LD_INT 1
35652: NEG
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 2
35660: NEG
35661: PUSH
35662: LD_INT 2
35664: NEG
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: LIST
35686: LIST
35687: LIST
35688: LIST
35689: LIST
35690: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35691: LD_ADDR_VAR 0 56
35695: PUSH
35696: LD_INT 0
35698: PUSH
35699: LD_INT 0
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 0
35708: PUSH
35709: LD_INT 1
35711: NEG
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: LD_INT 1
35719: PUSH
35720: LD_INT 0
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: LD_INT 1
35729: PUSH
35730: LD_INT 1
35732: PUSH
35733: EMPTY
35734: LIST
35735: LIST
35736: PUSH
35737: LD_INT 0
35739: PUSH
35740: LD_INT 1
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 1
35749: NEG
35750: PUSH
35751: LD_INT 0
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 1
35760: NEG
35761: PUSH
35762: LD_INT 1
35764: NEG
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 1
35772: NEG
35773: PUSH
35774: LD_INT 2
35776: NEG
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 0
35784: PUSH
35785: LD_INT 2
35787: NEG
35788: PUSH
35789: EMPTY
35790: LIST
35791: LIST
35792: PUSH
35793: LD_INT 1
35795: PUSH
35796: LD_INT 1
35798: NEG
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 2
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 2
35816: PUSH
35817: LD_INT 1
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 2
35826: PUSH
35827: LD_INT 2
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: LD_INT 2
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 0
35846: PUSH
35847: LD_INT 2
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: LD_INT 1
35860: PUSH
35861: EMPTY
35862: LIST
35863: LIST
35864: PUSH
35865: LD_INT 2
35867: NEG
35868: PUSH
35869: LD_INT 0
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 2
35878: NEG
35879: PUSH
35880: LD_INT 1
35882: NEG
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 2
35890: NEG
35891: PUSH
35892: LD_INT 2
35894: NEG
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: LIST
35919: LIST
35920: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35921: LD_ADDR_VAR 0 57
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: LD_INT 0
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 0
35938: PUSH
35939: LD_INT 1
35941: NEG
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: LD_INT 0
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 1
35959: PUSH
35960: LD_INT 1
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 0
35969: PUSH
35970: LD_INT 1
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 1
35979: NEG
35980: PUSH
35981: LD_INT 0
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 1
35990: NEG
35991: PUSH
35992: LD_INT 1
35994: NEG
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 1
36002: NEG
36003: PUSH
36004: LD_INT 2
36006: NEG
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 0
36014: PUSH
36015: LD_INT 2
36017: NEG
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 1
36025: PUSH
36026: LD_INT 1
36028: NEG
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 2
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 2
36046: PUSH
36047: LD_INT 1
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 2
36056: PUSH
36057: LD_INT 2
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 1
36066: PUSH
36067: LD_INT 2
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 0
36076: PUSH
36077: LD_INT 2
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 1
36086: NEG
36087: PUSH
36088: LD_INT 1
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 2
36097: NEG
36098: PUSH
36099: LD_INT 0
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: LD_INT 2
36108: NEG
36109: PUSH
36110: LD_INT 1
36112: NEG
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 2
36120: NEG
36121: PUSH
36122: LD_INT 2
36124: NEG
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36151: LD_ADDR_VAR 0 58
36155: PUSH
36156: LD_INT 0
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: LD_INT 1
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 1
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: PUSH
36190: LD_INT 1
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 0
36199: PUSH
36200: LD_INT 1
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 1
36209: NEG
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 1
36220: NEG
36221: PUSH
36222: LD_INT 1
36224: NEG
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 1
36232: NEG
36233: PUSH
36234: LD_INT 2
36236: NEG
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 0
36244: PUSH
36245: LD_INT 2
36247: NEG
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 1
36255: PUSH
36256: LD_INT 1
36258: NEG
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 2
36266: PUSH
36267: LD_INT 0
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 2
36286: PUSH
36287: LD_INT 2
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: LD_INT 2
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: LD_INT 1
36316: NEG
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 2
36327: NEG
36328: PUSH
36329: LD_INT 0
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 2
36338: NEG
36339: PUSH
36340: LD_INT 1
36342: NEG
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 2
36350: NEG
36351: PUSH
36352: LD_INT 2
36354: NEG
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: LIST
36364: LIST
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36381: LD_ADDR_VAR 0 59
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 0
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: LD_INT 1
36401: NEG
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 1
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 1
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: NEG
36451: PUSH
36452: LD_INT 1
36454: NEG
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36469: LD_ADDR_VAR 0 60
36473: PUSH
36474: LD_INT 0
36476: PUSH
36477: LD_INT 0
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 0
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 1
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 1
36507: PUSH
36508: LD_INT 1
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: LD_INT 1
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 1
36527: NEG
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 1
36538: NEG
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36557: LD_ADDR_VAR 0 61
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 1
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 0
36605: PUSH
36606: LD_INT 1
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 1
36626: NEG
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: LIST
36644: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36645: LD_ADDR_VAR 0 62
36649: PUSH
36650: LD_INT 0
36652: PUSH
36653: LD_INT 0
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: LD_INT 1
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: NEG
36715: PUSH
36716: LD_INT 1
36718: NEG
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: LIST
36730: LIST
36731: LIST
36732: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36733: LD_ADDR_VAR 0 63
36737: PUSH
36738: LD_INT 0
36740: PUSH
36741: LD_INT 0
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: LD_INT 1
36753: NEG
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: LD_INT 1
36771: PUSH
36772: LD_INT 1
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: LD_INT 1
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 1
36791: NEG
36792: PUSH
36793: LD_INT 0
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 1
36802: NEG
36803: PUSH
36804: LD_INT 1
36806: NEG
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: LIST
36816: LIST
36817: LIST
36818: LIST
36819: LIST
36820: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36821: LD_ADDR_VAR 0 64
36825: PUSH
36826: LD_INT 0
36828: PUSH
36829: LD_INT 0
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 0
36838: PUSH
36839: LD_INT 1
36841: NEG
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 1
36849: PUSH
36850: LD_INT 0
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 1
36859: PUSH
36860: LD_INT 1
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 0
36869: PUSH
36870: LD_INT 1
36872: PUSH
36873: EMPTY
36874: LIST
36875: LIST
36876: PUSH
36877: LD_INT 1
36879: NEG
36880: PUSH
36881: LD_INT 0
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 1
36890: NEG
36891: PUSH
36892: LD_INT 1
36894: NEG
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: LIST
36904: LIST
36905: LIST
36906: LIST
36907: LIST
36908: ST_TO_ADDR
// end ; 1 :
36909: GO 42806
36911: LD_INT 1
36913: DOUBLE
36914: EQUAL
36915: IFTRUE 36919
36917: GO 39542
36919: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36920: LD_ADDR_VAR 0 11
36924: PUSH
36925: LD_INT 1
36927: NEG
36928: PUSH
36929: LD_INT 3
36931: NEG
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 0
36939: PUSH
36940: LD_INT 3
36942: NEG
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 1
36950: PUSH
36951: LD_INT 2
36953: NEG
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: LIST
36963: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36964: LD_ADDR_VAR 0 12
36968: PUSH
36969: LD_INT 2
36971: PUSH
36972: LD_INT 1
36974: NEG
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 3
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 3
36992: PUSH
36993: LD_INT 1
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: LIST
37004: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37005: LD_ADDR_VAR 0 13
37009: PUSH
37010: LD_INT 3
37012: PUSH
37013: LD_INT 2
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 3
37022: PUSH
37023: LD_INT 3
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 2
37032: PUSH
37033: LD_INT 3
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: LIST
37044: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37045: LD_ADDR_VAR 0 14
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: LD_INT 3
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 0
37062: PUSH
37063: LD_INT 3
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 1
37072: NEG
37073: PUSH
37074: LD_INT 2
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: LIST
37085: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37086: LD_ADDR_VAR 0 15
37090: PUSH
37091: LD_INT 2
37093: NEG
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 3
37104: NEG
37105: PUSH
37106: LD_INT 0
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 3
37115: NEG
37116: PUSH
37117: LD_INT 1
37119: NEG
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: EMPTY
37126: LIST
37127: LIST
37128: LIST
37129: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37130: LD_ADDR_VAR 0 16
37134: PUSH
37135: LD_INT 2
37137: NEG
37138: PUSH
37139: LD_INT 3
37141: NEG
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 3
37149: NEG
37150: PUSH
37151: LD_INT 2
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 3
37161: NEG
37162: PUSH
37163: LD_INT 3
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: EMPTY
37172: LIST
37173: LIST
37174: LIST
37175: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37176: LD_ADDR_VAR 0 17
37180: PUSH
37181: LD_INT 1
37183: NEG
37184: PUSH
37185: LD_INT 3
37187: NEG
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 0
37195: PUSH
37196: LD_INT 3
37198: NEG
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: PUSH
37204: LD_INT 1
37206: PUSH
37207: LD_INT 2
37209: NEG
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: LIST
37219: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37220: LD_ADDR_VAR 0 18
37224: PUSH
37225: LD_INT 2
37227: PUSH
37228: LD_INT 1
37230: NEG
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: LD_INT 3
37238: PUSH
37239: LD_INT 0
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: PUSH
37246: LD_INT 3
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: LIST
37260: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37261: LD_ADDR_VAR 0 19
37265: PUSH
37266: LD_INT 3
37268: PUSH
37269: LD_INT 2
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: PUSH
37276: LD_INT 3
37278: PUSH
37279: LD_INT 3
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 2
37288: PUSH
37289: LD_INT 3
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: LIST
37300: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37301: LD_ADDR_VAR 0 20
37305: PUSH
37306: LD_INT 1
37308: PUSH
37309: LD_INT 3
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: LD_INT 3
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 1
37328: NEG
37329: PUSH
37330: LD_INT 2
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: LIST
37341: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37342: LD_ADDR_VAR 0 21
37346: PUSH
37347: LD_INT 2
37349: NEG
37350: PUSH
37351: LD_INT 1
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 3
37360: NEG
37361: PUSH
37362: LD_INT 0
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 3
37371: NEG
37372: PUSH
37373: LD_INT 1
37375: NEG
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: EMPTY
37382: LIST
37383: LIST
37384: LIST
37385: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37386: LD_ADDR_VAR 0 22
37390: PUSH
37391: LD_INT 2
37393: NEG
37394: PUSH
37395: LD_INT 3
37397: NEG
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: PUSH
37403: LD_INT 3
37405: NEG
37406: PUSH
37407: LD_INT 2
37409: NEG
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 3
37417: NEG
37418: PUSH
37419: LD_INT 3
37421: NEG
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: LIST
37431: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37432: LD_ADDR_VAR 0 23
37436: PUSH
37437: LD_INT 0
37439: PUSH
37440: LD_INT 3
37442: NEG
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 1
37450: NEG
37451: PUSH
37452: LD_INT 4
37454: NEG
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 1
37462: PUSH
37463: LD_INT 3
37465: NEG
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: LIST
37475: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37476: LD_ADDR_VAR 0 24
37480: PUSH
37481: LD_INT 3
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 3
37493: PUSH
37494: LD_INT 1
37496: NEG
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 4
37504: PUSH
37505: LD_INT 1
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: LIST
37516: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37517: LD_ADDR_VAR 0 25
37521: PUSH
37522: LD_INT 3
37524: PUSH
37525: LD_INT 3
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 4
37534: PUSH
37535: LD_INT 3
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 3
37544: PUSH
37545: LD_INT 4
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: LIST
37556: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37557: LD_ADDR_VAR 0 26
37561: PUSH
37562: LD_INT 0
37564: PUSH
37565: LD_INT 3
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 1
37574: PUSH
37575: LD_INT 4
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 1
37584: NEG
37585: PUSH
37586: LD_INT 3
37588: PUSH
37589: EMPTY
37590: LIST
37591: LIST
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: LIST
37597: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37598: LD_ADDR_VAR 0 27
37602: PUSH
37603: LD_INT 3
37605: NEG
37606: PUSH
37607: LD_INT 0
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 3
37616: NEG
37617: PUSH
37618: LD_INT 1
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: PUSH
37625: LD_INT 4
37627: NEG
37628: PUSH
37629: LD_INT 1
37631: NEG
37632: PUSH
37633: EMPTY
37634: LIST
37635: LIST
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: LIST
37641: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37642: LD_ADDR_VAR 0 28
37646: PUSH
37647: LD_INT 3
37649: NEG
37650: PUSH
37651: LD_INT 3
37653: NEG
37654: PUSH
37655: EMPTY
37656: LIST
37657: LIST
37658: PUSH
37659: LD_INT 3
37661: NEG
37662: PUSH
37663: LD_INT 4
37665: NEG
37666: PUSH
37667: EMPTY
37668: LIST
37669: LIST
37670: PUSH
37671: LD_INT 4
37673: NEG
37674: PUSH
37675: LD_INT 3
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37688: LD_ADDR_VAR 0 29
37692: PUSH
37693: LD_INT 1
37695: NEG
37696: PUSH
37697: LD_INT 3
37699: NEG
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 0
37707: PUSH
37708: LD_INT 3
37710: NEG
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 1
37718: PUSH
37719: LD_INT 2
37721: NEG
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 1
37729: NEG
37730: PUSH
37731: LD_INT 4
37733: NEG
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 0
37741: PUSH
37742: LD_INT 4
37744: NEG
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 1
37752: PUSH
37753: LD_INT 3
37755: NEG
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 1
37763: NEG
37764: PUSH
37765: LD_INT 5
37767: NEG
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: LD_INT 5
37778: NEG
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PUSH
37784: LD_INT 1
37786: PUSH
37787: LD_INT 4
37789: NEG
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: LD_INT 6
37801: NEG
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 0
37809: PUSH
37810: LD_INT 6
37812: NEG
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: PUSH
37818: LD_INT 1
37820: PUSH
37821: LD_INT 5
37823: NEG
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: LIST
37833: LIST
37834: LIST
37835: LIST
37836: LIST
37837: LIST
37838: LIST
37839: LIST
37840: LIST
37841: LIST
37842: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37843: LD_ADDR_VAR 0 30
37847: PUSH
37848: LD_INT 2
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 3
37861: PUSH
37862: LD_INT 0
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 3
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 3
37881: PUSH
37882: LD_INT 1
37884: NEG
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 4
37892: PUSH
37893: LD_INT 0
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 4
37902: PUSH
37903: LD_INT 1
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: PUSH
37910: LD_INT 4
37912: PUSH
37913: LD_INT 1
37915: NEG
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 5
37923: PUSH
37924: LD_INT 0
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 5
37933: PUSH
37934: LD_INT 1
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 5
37943: PUSH
37944: LD_INT 1
37946: NEG
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 6
37954: PUSH
37955: LD_INT 0
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 6
37964: PUSH
37965: LD_INT 1
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37986: LD_ADDR_VAR 0 31
37990: PUSH
37991: LD_INT 3
37993: PUSH
37994: LD_INT 2
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 3
38003: PUSH
38004: LD_INT 3
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 2
38013: PUSH
38014: LD_INT 3
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 4
38023: PUSH
38024: LD_INT 3
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 4
38033: PUSH
38034: LD_INT 4
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 3
38043: PUSH
38044: LD_INT 4
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 5
38053: PUSH
38054: LD_INT 4
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 5
38063: PUSH
38064: LD_INT 5
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 4
38073: PUSH
38074: LD_INT 5
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 6
38083: PUSH
38084: LD_INT 5
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 6
38093: PUSH
38094: LD_INT 6
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 5
38103: PUSH
38104: LD_INT 6
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: LIST
38119: LIST
38120: LIST
38121: LIST
38122: LIST
38123: LIST
38124: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38125: LD_ADDR_VAR 0 32
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: LD_INT 3
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 0
38142: PUSH
38143: LD_INT 3
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 1
38152: NEG
38153: PUSH
38154: LD_INT 2
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 1
38163: PUSH
38164: LD_INT 4
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: LD_INT 4
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 1
38183: NEG
38184: PUSH
38185: LD_INT 3
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 1
38194: PUSH
38195: LD_INT 5
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 0
38204: PUSH
38205: LD_INT 5
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 1
38214: NEG
38215: PUSH
38216: LD_INT 4
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: LD_INT 6
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: LD_INT 6
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 1
38245: NEG
38246: PUSH
38247: LD_INT 5
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: LIST
38261: LIST
38262: LIST
38263: LIST
38264: LIST
38265: LIST
38266: LIST
38267: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38268: LD_ADDR_VAR 0 33
38272: PUSH
38273: LD_INT 2
38275: NEG
38276: PUSH
38277: LD_INT 1
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 3
38286: NEG
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 3
38297: NEG
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 3
38309: NEG
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 4
38320: NEG
38321: PUSH
38322: LD_INT 0
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 4
38331: NEG
38332: PUSH
38333: LD_INT 1
38335: NEG
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 4
38343: NEG
38344: PUSH
38345: LD_INT 1
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 5
38354: NEG
38355: PUSH
38356: LD_INT 0
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 5
38365: NEG
38366: PUSH
38367: LD_INT 1
38369: NEG
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 5
38377: NEG
38378: PUSH
38379: LD_INT 1
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 6
38388: NEG
38389: PUSH
38390: LD_INT 0
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 6
38399: NEG
38400: PUSH
38401: LD_INT 1
38403: NEG
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38423: LD_ADDR_VAR 0 34
38427: PUSH
38428: LD_INT 2
38430: NEG
38431: PUSH
38432: LD_INT 3
38434: NEG
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: LD_INT 3
38442: NEG
38443: PUSH
38444: LD_INT 2
38446: NEG
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 3
38454: NEG
38455: PUSH
38456: LD_INT 3
38458: NEG
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: PUSH
38464: LD_INT 3
38466: NEG
38467: PUSH
38468: LD_INT 4
38470: NEG
38471: PUSH
38472: EMPTY
38473: LIST
38474: LIST
38475: PUSH
38476: LD_INT 4
38478: NEG
38479: PUSH
38480: LD_INT 3
38482: NEG
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 4
38490: NEG
38491: PUSH
38492: LD_INT 4
38494: NEG
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 4
38502: NEG
38503: PUSH
38504: LD_INT 5
38506: NEG
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 5
38514: NEG
38515: PUSH
38516: LD_INT 4
38518: NEG
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 5
38526: NEG
38527: PUSH
38528: LD_INT 5
38530: NEG
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 5
38538: NEG
38539: PUSH
38540: LD_INT 6
38542: NEG
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 6
38550: NEG
38551: PUSH
38552: LD_INT 5
38554: NEG
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 6
38562: NEG
38563: PUSH
38564: LD_INT 6
38566: NEG
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: LIST
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: LIST
38581: LIST
38582: LIST
38583: LIST
38584: LIST
38585: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38586: LD_ADDR_VAR 0 41
38590: PUSH
38591: LD_INT 0
38593: PUSH
38594: LD_INT 2
38596: NEG
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PUSH
38602: LD_INT 1
38604: NEG
38605: PUSH
38606: LD_INT 3
38608: NEG
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PUSH
38614: LD_INT 1
38616: PUSH
38617: LD_INT 2
38619: NEG
38620: PUSH
38621: EMPTY
38622: LIST
38623: LIST
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: LIST
38629: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38630: LD_ADDR_VAR 0 42
38634: PUSH
38635: LD_INT 2
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 2
38647: PUSH
38648: LD_INT 1
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 3
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: LIST
38670: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38671: LD_ADDR_VAR 0 43
38675: PUSH
38676: LD_INT 2
38678: PUSH
38679: LD_INT 2
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 3
38688: PUSH
38689: LD_INT 2
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 2
38698: PUSH
38699: LD_INT 3
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: LIST
38710: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38711: LD_ADDR_VAR 0 44
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: LD_INT 2
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: LD_INT 3
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 1
38738: NEG
38739: PUSH
38740: LD_INT 2
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: LIST
38751: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38752: LD_ADDR_VAR 0 45
38756: PUSH
38757: LD_INT 2
38759: NEG
38760: PUSH
38761: LD_INT 0
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 2
38770: NEG
38771: PUSH
38772: LD_INT 1
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 3
38781: NEG
38782: PUSH
38783: LD_INT 1
38785: NEG
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: LIST
38795: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38796: LD_ADDR_VAR 0 46
38800: PUSH
38801: LD_INT 2
38803: NEG
38804: PUSH
38805: LD_INT 2
38807: NEG
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: PUSH
38813: LD_INT 2
38815: NEG
38816: PUSH
38817: LD_INT 3
38819: NEG
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 3
38827: NEG
38828: PUSH
38829: LD_INT 2
38831: NEG
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: LIST
38841: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38842: LD_ADDR_VAR 0 47
38846: PUSH
38847: LD_INT 2
38849: NEG
38850: PUSH
38851: LD_INT 3
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: NEG
38862: PUSH
38863: LD_INT 3
38865: NEG
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38875: LD_ADDR_VAR 0 48
38879: PUSH
38880: LD_INT 1
38882: PUSH
38883: LD_INT 2
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 2
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38906: LD_ADDR_VAR 0 49
38910: PUSH
38911: LD_INT 3
38913: PUSH
38914: LD_INT 1
38916: PUSH
38917: EMPTY
38918: LIST
38919: LIST
38920: PUSH
38921: LD_INT 3
38923: PUSH
38924: LD_INT 2
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38935: LD_ADDR_VAR 0 50
38939: PUSH
38940: LD_INT 2
38942: PUSH
38943: LD_INT 3
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 1
38952: PUSH
38953: LD_INT 3
38955: PUSH
38956: EMPTY
38957: LIST
38958: LIST
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38964: LD_ADDR_VAR 0 51
38968: PUSH
38969: LD_INT 1
38971: NEG
38972: PUSH
38973: LD_INT 2
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 2
38982: NEG
38983: PUSH
38984: LD_INT 1
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: EMPTY
38992: LIST
38993: LIST
38994: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38995: LD_ADDR_VAR 0 52
38999: PUSH
39000: LD_INT 3
39002: NEG
39003: PUSH
39004: LD_INT 1
39006: NEG
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 3
39014: NEG
39015: PUSH
39016: LD_INT 2
39018: NEG
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: EMPTY
39025: LIST
39026: LIST
39027: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39028: LD_ADDR_VAR 0 53
39032: PUSH
39033: LD_INT 1
39035: NEG
39036: PUSH
39037: LD_INT 3
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 0
39047: PUSH
39048: LD_INT 3
39050: NEG
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 1
39058: PUSH
39059: LD_INT 2
39061: NEG
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: LIST
39071: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39072: LD_ADDR_VAR 0 54
39076: PUSH
39077: LD_INT 2
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 3
39090: PUSH
39091: LD_INT 0
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 3
39100: PUSH
39101: LD_INT 1
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: LIST
39112: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39113: LD_ADDR_VAR 0 55
39117: PUSH
39118: LD_INT 3
39120: PUSH
39121: LD_INT 2
39123: PUSH
39124: EMPTY
39125: LIST
39126: LIST
39127: PUSH
39128: LD_INT 3
39130: PUSH
39131: LD_INT 3
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: LD_INT 2
39140: PUSH
39141: LD_INT 3
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: LIST
39152: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39153: LD_ADDR_VAR 0 56
39157: PUSH
39158: LD_INT 1
39160: PUSH
39161: LD_INT 3
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 0
39170: PUSH
39171: LD_INT 3
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 1
39180: NEG
39181: PUSH
39182: LD_INT 2
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: LIST
39193: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39194: LD_ADDR_VAR 0 57
39198: PUSH
39199: LD_INT 2
39201: NEG
39202: PUSH
39203: LD_INT 1
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 3
39212: NEG
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 3
39223: NEG
39224: PUSH
39225: LD_INT 1
39227: NEG
39228: PUSH
39229: EMPTY
39230: LIST
39231: LIST
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: LIST
39237: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39238: LD_ADDR_VAR 0 58
39242: PUSH
39243: LD_INT 2
39245: NEG
39246: PUSH
39247: LD_INT 3
39249: NEG
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 3
39257: NEG
39258: PUSH
39259: LD_INT 2
39261: NEG
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 3
39269: NEG
39270: PUSH
39271: LD_INT 3
39273: NEG
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: LIST
39283: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39284: LD_ADDR_VAR 0 59
39288: PUSH
39289: LD_INT 1
39291: NEG
39292: PUSH
39293: LD_INT 2
39295: NEG
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: LD_INT 2
39306: NEG
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 1
39314: PUSH
39315: LD_INT 1
39317: NEG
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: LIST
39327: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39328: LD_ADDR_VAR 0 60
39332: PUSH
39333: LD_INT 1
39335: PUSH
39336: LD_INT 1
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 2
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 2
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: LIST
39368: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39369: LD_ADDR_VAR 0 61
39373: PUSH
39374: LD_INT 2
39376: PUSH
39377: LD_INT 1
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 2
39386: PUSH
39387: LD_INT 2
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 1
39396: PUSH
39397: LD_INT 2
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: LIST
39408: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39409: LD_ADDR_VAR 0 62
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: LD_INT 2
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 0
39426: PUSH
39427: LD_INT 2
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 1
39436: NEG
39437: PUSH
39438: LD_INT 1
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: LIST
39449: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39450: LD_ADDR_VAR 0 63
39454: PUSH
39455: LD_INT 1
39457: NEG
39458: PUSH
39459: LD_INT 1
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: LD_INT 2
39468: NEG
39469: PUSH
39470: LD_INT 0
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 2
39479: NEG
39480: PUSH
39481: LD_INT 1
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: LIST
39493: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39494: LD_ADDR_VAR 0 64
39498: PUSH
39499: LD_INT 1
39501: NEG
39502: PUSH
39503: LD_INT 2
39505: NEG
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 2
39513: NEG
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: NEG
39526: PUSH
39527: LD_INT 2
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: ST_TO_ADDR
// end ; 2 :
39540: GO 42806
39542: LD_INT 2
39544: DOUBLE
39545: EQUAL
39546: IFTRUE 39550
39548: GO 42805
39550: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39551: LD_ADDR_VAR 0 29
39555: PUSH
39556: LD_INT 4
39558: PUSH
39559: LD_INT 0
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 4
39568: PUSH
39569: LD_INT 1
39571: NEG
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 5
39579: PUSH
39580: LD_INT 0
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 5
39589: PUSH
39590: LD_INT 1
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 4
39599: PUSH
39600: LD_INT 1
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 3
39609: PUSH
39610: LD_INT 0
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 3
39619: PUSH
39620: LD_INT 1
39622: NEG
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: LD_INT 3
39630: PUSH
39631: LD_INT 2
39633: NEG
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: LD_INT 5
39641: PUSH
39642: LD_INT 2
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 3
39651: PUSH
39652: LD_INT 3
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 3
39661: PUSH
39662: LD_INT 2
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: LD_INT 4
39671: PUSH
39672: LD_INT 3
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 4
39681: PUSH
39682: LD_INT 4
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 3
39691: PUSH
39692: LD_INT 4
39694: PUSH
39695: EMPTY
39696: LIST
39697: LIST
39698: PUSH
39699: LD_INT 2
39701: PUSH
39702: LD_INT 3
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 2
39711: PUSH
39712: LD_INT 2
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 4
39721: PUSH
39722: LD_INT 2
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 2
39731: PUSH
39732: LD_INT 4
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 0
39741: PUSH
39742: LD_INT 4
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 0
39751: PUSH
39752: LD_INT 3
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 1
39761: PUSH
39762: LD_INT 4
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 1
39771: PUSH
39772: LD_INT 5
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 0
39781: PUSH
39782: LD_INT 5
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 1
39791: NEG
39792: PUSH
39793: LD_INT 4
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 1
39802: NEG
39803: PUSH
39804: LD_INT 3
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 2
39813: PUSH
39814: LD_INT 5
39816: PUSH
39817: EMPTY
39818: LIST
39819: LIST
39820: PUSH
39821: LD_INT 2
39823: NEG
39824: PUSH
39825: LD_INT 3
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 3
39834: NEG
39835: PUSH
39836: LD_INT 0
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: LD_INT 3
39845: NEG
39846: PUSH
39847: LD_INT 1
39849: NEG
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 2
39857: NEG
39858: PUSH
39859: LD_INT 0
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 2
39868: NEG
39869: PUSH
39870: LD_INT 1
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 3
39879: NEG
39880: PUSH
39881: LD_INT 1
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 4
39890: NEG
39891: PUSH
39892: LD_INT 0
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 4
39901: NEG
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 4
39913: NEG
39914: PUSH
39915: LD_INT 2
39917: NEG
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: LD_INT 2
39925: NEG
39926: PUSH
39927: LD_INT 2
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 4
39936: NEG
39937: PUSH
39938: LD_INT 4
39940: NEG
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 4
39948: NEG
39949: PUSH
39950: LD_INT 5
39952: NEG
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 3
39960: NEG
39961: PUSH
39962: LD_INT 4
39964: NEG
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 3
39972: NEG
39973: PUSH
39974: LD_INT 3
39976: NEG
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 4
39984: NEG
39985: PUSH
39986: LD_INT 3
39988: NEG
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 5
39996: NEG
39997: PUSH
39998: LD_INT 4
40000: NEG
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 5
40008: NEG
40009: PUSH
40010: LD_INT 5
40012: NEG
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 3
40020: NEG
40021: PUSH
40022: LD_INT 5
40024: NEG
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 5
40032: NEG
40033: PUSH
40034: LD_INT 3
40036: NEG
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: LIST
40049: LIST
40050: LIST
40051: LIST
40052: LIST
40053: LIST
40054: LIST
40055: LIST
40056: LIST
40057: LIST
40058: LIST
40059: LIST
40060: LIST
40061: LIST
40062: LIST
40063: LIST
40064: LIST
40065: LIST
40066: LIST
40067: LIST
40068: LIST
40069: LIST
40070: LIST
40071: LIST
40072: LIST
40073: LIST
40074: LIST
40075: LIST
40076: LIST
40077: LIST
40078: LIST
40079: LIST
40080: LIST
40081: LIST
40082: LIST
40083: LIST
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40089: LD_ADDR_VAR 0 30
40093: PUSH
40094: LD_INT 4
40096: PUSH
40097: LD_INT 4
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 4
40106: PUSH
40107: LD_INT 3
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 5
40116: PUSH
40117: LD_INT 4
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 5
40126: PUSH
40127: LD_INT 5
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 4
40136: PUSH
40137: LD_INT 5
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 3
40146: PUSH
40147: LD_INT 4
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 3
40156: PUSH
40157: LD_INT 3
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 5
40166: PUSH
40167: LD_INT 3
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 3
40176: PUSH
40177: LD_INT 5
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 0
40186: PUSH
40187: LD_INT 3
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: LD_INT 0
40196: PUSH
40197: LD_INT 2
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 1
40206: PUSH
40207: LD_INT 3
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 1
40216: PUSH
40217: LD_INT 4
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 0
40226: PUSH
40227: LD_INT 4
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 1
40236: NEG
40237: PUSH
40238: LD_INT 3
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 1
40247: NEG
40248: PUSH
40249: LD_INT 2
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: LD_INT 2
40258: PUSH
40259: LD_INT 4
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 2
40268: NEG
40269: PUSH
40270: LD_INT 2
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 4
40279: NEG
40280: PUSH
40281: LD_INT 0
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 4
40290: NEG
40291: PUSH
40292: LD_INT 1
40294: NEG
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 3
40302: NEG
40303: PUSH
40304: LD_INT 0
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 3
40313: NEG
40314: PUSH
40315: LD_INT 1
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 4
40324: NEG
40325: PUSH
40326: LD_INT 1
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: PUSH
40333: LD_INT 5
40335: NEG
40336: PUSH
40337: LD_INT 0
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 5
40346: NEG
40347: PUSH
40348: LD_INT 1
40350: NEG
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 5
40358: NEG
40359: PUSH
40360: LD_INT 2
40362: NEG
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 3
40370: NEG
40371: PUSH
40372: LD_INT 2
40374: PUSH
40375: EMPTY
40376: LIST
40377: LIST
40378: PUSH
40379: LD_INT 3
40381: NEG
40382: PUSH
40383: LD_INT 3
40385: NEG
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 3
40393: NEG
40394: PUSH
40395: LD_INT 4
40397: NEG
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 2
40405: NEG
40406: PUSH
40407: LD_INT 3
40409: NEG
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 2
40417: NEG
40418: PUSH
40419: LD_INT 2
40421: NEG
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 3
40429: NEG
40430: PUSH
40431: LD_INT 2
40433: NEG
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: LD_INT 4
40441: NEG
40442: PUSH
40443: LD_INT 3
40445: NEG
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 4
40453: NEG
40454: PUSH
40455: LD_INT 4
40457: NEG
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 2
40465: NEG
40466: PUSH
40467: LD_INT 4
40469: NEG
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 4
40477: NEG
40478: PUSH
40479: LD_INT 2
40481: NEG
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 4
40492: NEG
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 0
40500: PUSH
40501: LD_INT 5
40503: NEG
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 1
40511: PUSH
40512: LD_INT 4
40514: NEG
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PUSH
40520: LD_INT 1
40522: PUSH
40523: LD_INT 3
40525: NEG
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 0
40533: PUSH
40534: LD_INT 3
40536: NEG
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 1
40544: NEG
40545: PUSH
40546: LD_INT 4
40548: NEG
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PUSH
40554: LD_INT 1
40556: NEG
40557: PUSH
40558: LD_INT 5
40560: NEG
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 2
40568: PUSH
40569: LD_INT 3
40571: NEG
40572: PUSH
40573: EMPTY
40574: LIST
40575: LIST
40576: PUSH
40577: LD_INT 2
40579: NEG
40580: PUSH
40581: LD_INT 5
40583: NEG
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: LIST
40618: LIST
40619: LIST
40620: LIST
40621: LIST
40622: LIST
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: LIST
40632: LIST
40633: LIST
40634: LIST
40635: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40636: LD_ADDR_VAR 0 31
40640: PUSH
40641: LD_INT 0
40643: PUSH
40644: LD_INT 4
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: LD_INT 3
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 1
40663: PUSH
40664: LD_INT 4
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 1
40673: PUSH
40674: LD_INT 5
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 0
40683: PUSH
40684: LD_INT 5
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 1
40693: NEG
40694: PUSH
40695: LD_INT 4
40697: PUSH
40698: EMPTY
40699: LIST
40700: LIST
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: LD_INT 3
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 2
40715: PUSH
40716: LD_INT 5
40718: PUSH
40719: EMPTY
40720: LIST
40721: LIST
40722: PUSH
40723: LD_INT 2
40725: NEG
40726: PUSH
40727: LD_INT 3
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 3
40736: NEG
40737: PUSH
40738: LD_INT 0
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: LD_INT 3
40747: NEG
40748: PUSH
40749: LD_INT 1
40751: NEG
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 2
40759: NEG
40760: PUSH
40761: LD_INT 0
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 2
40770: NEG
40771: PUSH
40772: LD_INT 1
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 3
40781: NEG
40782: PUSH
40783: LD_INT 1
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 4
40792: NEG
40793: PUSH
40794: LD_INT 0
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 4
40803: NEG
40804: PUSH
40805: LD_INT 1
40807: NEG
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 4
40815: NEG
40816: PUSH
40817: LD_INT 2
40819: NEG
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 2
40827: NEG
40828: PUSH
40829: LD_INT 2
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PUSH
40836: LD_INT 4
40838: NEG
40839: PUSH
40840: LD_INT 4
40842: NEG
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 4
40850: NEG
40851: PUSH
40852: LD_INT 5
40854: NEG
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 3
40862: NEG
40863: PUSH
40864: LD_INT 4
40866: NEG
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: PUSH
40872: LD_INT 3
40874: NEG
40875: PUSH
40876: LD_INT 3
40878: NEG
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 4
40886: NEG
40887: PUSH
40888: LD_INT 3
40890: NEG
40891: PUSH
40892: EMPTY
40893: LIST
40894: LIST
40895: PUSH
40896: LD_INT 5
40898: NEG
40899: PUSH
40900: LD_INT 4
40902: NEG
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 5
40910: NEG
40911: PUSH
40912: LD_INT 5
40914: NEG
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 3
40922: NEG
40923: PUSH
40924: LD_INT 5
40926: NEG
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 5
40934: NEG
40935: PUSH
40936: LD_INT 3
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 0
40946: PUSH
40947: LD_INT 3
40949: NEG
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 4
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: PUSH
40969: LD_INT 3
40971: NEG
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: PUSH
40980: LD_INT 2
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: LD_INT 0
40990: PUSH
40991: LD_INT 2
40993: NEG
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: LD_INT 1
41001: NEG
41002: PUSH
41003: LD_INT 3
41005: NEG
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 1
41013: NEG
41014: PUSH
41015: LD_INT 4
41017: NEG
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 2
41025: PUSH
41026: LD_INT 2
41028: NEG
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 2
41036: NEG
41037: PUSH
41038: LD_INT 4
41040: NEG
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 4
41048: PUSH
41049: LD_INT 0
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 4
41058: PUSH
41059: LD_INT 1
41061: NEG
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 5
41069: PUSH
41070: LD_INT 0
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: LD_INT 5
41079: PUSH
41080: LD_INT 1
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: LD_INT 4
41089: PUSH
41090: LD_INT 1
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: LD_INT 3
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: LD_INT 3
41109: PUSH
41110: LD_INT 1
41112: NEG
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: LD_INT 3
41120: PUSH
41121: LD_INT 2
41123: NEG
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 5
41131: PUSH
41132: LD_INT 2
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: LIST
41143: LIST
41144: LIST
41145: LIST
41146: LIST
41147: LIST
41148: LIST
41149: LIST
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: LIST
41166: LIST
41167: LIST
41168: LIST
41169: LIST
41170: LIST
41171: LIST
41172: LIST
41173: LIST
41174: LIST
41175: LIST
41176: LIST
41177: LIST
41178: LIST
41179: LIST
41180: LIST
41181: LIST
41182: LIST
41183: LIST
41184: LIST
41185: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41186: LD_ADDR_VAR 0 32
41190: PUSH
41191: LD_INT 4
41193: NEG
41194: PUSH
41195: LD_INT 0
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 4
41204: NEG
41205: PUSH
41206: LD_INT 1
41208: NEG
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 3
41216: NEG
41217: PUSH
41218: LD_INT 0
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 3
41227: NEG
41228: PUSH
41229: LD_INT 1
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 4
41238: NEG
41239: PUSH
41240: LD_INT 1
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 5
41249: NEG
41250: PUSH
41251: LD_INT 0
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 5
41260: NEG
41261: PUSH
41262: LD_INT 1
41264: NEG
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 5
41272: NEG
41273: PUSH
41274: LD_INT 2
41276: NEG
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 3
41284: NEG
41285: PUSH
41286: LD_INT 2
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: LD_INT 3
41295: NEG
41296: PUSH
41297: LD_INT 3
41299: NEG
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: LD_INT 4
41311: NEG
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 2
41319: NEG
41320: PUSH
41321: LD_INT 3
41323: NEG
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: PUSH
41329: LD_INT 2
41331: NEG
41332: PUSH
41333: LD_INT 2
41335: NEG
41336: PUSH
41337: EMPTY
41338: LIST
41339: LIST
41340: PUSH
41341: LD_INT 3
41343: NEG
41344: PUSH
41345: LD_INT 2
41347: NEG
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 4
41355: NEG
41356: PUSH
41357: LD_INT 3
41359: NEG
41360: PUSH
41361: EMPTY
41362: LIST
41363: LIST
41364: PUSH
41365: LD_INT 4
41367: NEG
41368: PUSH
41369: LD_INT 4
41371: NEG
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: LD_INT 2
41379: NEG
41380: PUSH
41381: LD_INT 4
41383: NEG
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 4
41391: NEG
41392: PUSH
41393: LD_INT 2
41395: NEG
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 0
41403: PUSH
41404: LD_INT 4
41406: NEG
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: PUSH
41412: LD_INT 0
41414: PUSH
41415: LD_INT 5
41417: NEG
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: LD_INT 1
41425: PUSH
41426: LD_INT 4
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 1
41436: PUSH
41437: LD_INT 3
41439: NEG
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 0
41447: PUSH
41448: LD_INT 3
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 1
41458: NEG
41459: PUSH
41460: LD_INT 4
41462: NEG
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 1
41470: NEG
41471: PUSH
41472: LD_INT 5
41474: NEG
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 2
41482: PUSH
41483: LD_INT 3
41485: NEG
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 2
41493: NEG
41494: PUSH
41495: LD_INT 5
41497: NEG
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: PUSH
41503: LD_INT 3
41505: PUSH
41506: LD_INT 0
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 3
41515: PUSH
41516: LD_INT 1
41518: NEG
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 4
41526: PUSH
41527: LD_INT 0
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 4
41536: PUSH
41537: LD_INT 1
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 3
41546: PUSH
41547: LD_INT 1
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 2
41556: PUSH
41557: LD_INT 0
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 2
41566: PUSH
41567: LD_INT 1
41569: NEG
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 2
41577: PUSH
41578: LD_INT 2
41580: NEG
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 4
41588: PUSH
41589: LD_INT 2
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 4
41598: PUSH
41599: LD_INT 4
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 4
41608: PUSH
41609: LD_INT 3
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 5
41618: PUSH
41619: LD_INT 4
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 5
41628: PUSH
41629: LD_INT 5
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 4
41638: PUSH
41639: LD_INT 5
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 3
41648: PUSH
41649: LD_INT 4
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: PUSH
41659: LD_INT 3
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 5
41668: PUSH
41669: LD_INT 3
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 3
41678: PUSH
41679: LD_INT 5
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: LIST
41690: LIST
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: LIST
41703: LIST
41704: LIST
41705: LIST
41706: LIST
41707: LIST
41708: LIST
41709: LIST
41710: LIST
41711: LIST
41712: LIST
41713: LIST
41714: LIST
41715: LIST
41716: LIST
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: LIST
41724: LIST
41725: LIST
41726: LIST
41727: LIST
41728: LIST
41729: LIST
41730: LIST
41731: LIST
41732: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41733: LD_ADDR_VAR 0 33
41737: PUSH
41738: LD_INT 4
41740: NEG
41741: PUSH
41742: LD_INT 4
41744: NEG
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: PUSH
41750: LD_INT 4
41752: NEG
41753: PUSH
41754: LD_INT 5
41756: NEG
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: LD_INT 3
41764: NEG
41765: PUSH
41766: LD_INT 4
41768: NEG
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 3
41776: NEG
41777: PUSH
41778: LD_INT 3
41780: NEG
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: LD_INT 4
41788: NEG
41789: PUSH
41790: LD_INT 3
41792: NEG
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 5
41800: NEG
41801: PUSH
41802: LD_INT 4
41804: NEG
41805: PUSH
41806: EMPTY
41807: LIST
41808: LIST
41809: PUSH
41810: LD_INT 5
41812: NEG
41813: PUSH
41814: LD_INT 5
41816: NEG
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 3
41824: NEG
41825: PUSH
41826: LD_INT 5
41828: NEG
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 5
41836: NEG
41837: PUSH
41838: LD_INT 3
41840: NEG
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: PUSH
41846: LD_INT 0
41848: PUSH
41849: LD_INT 3
41851: NEG
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 0
41859: PUSH
41860: LD_INT 4
41862: NEG
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 1
41870: PUSH
41871: LD_INT 3
41873: NEG
41874: PUSH
41875: EMPTY
41876: LIST
41877: LIST
41878: PUSH
41879: LD_INT 1
41881: PUSH
41882: LD_INT 2
41884: NEG
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 0
41892: PUSH
41893: LD_INT 2
41895: NEG
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: LD_INT 1
41903: NEG
41904: PUSH
41905: LD_INT 3
41907: NEG
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 1
41915: NEG
41916: PUSH
41917: LD_INT 4
41919: NEG
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 2
41927: PUSH
41928: LD_INT 2
41930: NEG
41931: PUSH
41932: EMPTY
41933: LIST
41934: LIST
41935: PUSH
41936: LD_INT 2
41938: NEG
41939: PUSH
41940: LD_INT 4
41942: NEG
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 4
41950: PUSH
41951: LD_INT 0
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 4
41960: PUSH
41961: LD_INT 1
41963: NEG
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 5
41971: PUSH
41972: LD_INT 0
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 5
41981: PUSH
41982: LD_INT 1
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 4
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 3
42001: PUSH
42002: LD_INT 0
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 3
42011: PUSH
42012: LD_INT 1
42014: NEG
42015: PUSH
42016: EMPTY
42017: LIST
42018: LIST
42019: PUSH
42020: LD_INT 3
42022: PUSH
42023: LD_INT 2
42025: NEG
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: PUSH
42031: LD_INT 5
42033: PUSH
42034: LD_INT 2
42036: PUSH
42037: EMPTY
42038: LIST
42039: LIST
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: LD_INT 3
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: PUSH
42051: LD_INT 3
42053: PUSH
42054: LD_INT 2
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 4
42063: PUSH
42064: LD_INT 3
42066: PUSH
42067: EMPTY
42068: LIST
42069: LIST
42070: PUSH
42071: LD_INT 4
42073: PUSH
42074: LD_INT 4
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 3
42083: PUSH
42084: LD_INT 4
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 2
42093: PUSH
42094: LD_INT 3
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 2
42103: PUSH
42104: LD_INT 2
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 4
42113: PUSH
42114: LD_INT 2
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 2
42123: PUSH
42124: LD_INT 4
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 0
42133: PUSH
42134: LD_INT 4
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 0
42143: PUSH
42144: LD_INT 3
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 1
42153: PUSH
42154: LD_INT 4
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 1
42163: PUSH
42164: LD_INT 5
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 0
42173: PUSH
42174: LD_INT 5
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 1
42183: NEG
42184: PUSH
42185: LD_INT 4
42187: PUSH
42188: EMPTY
42189: LIST
42190: LIST
42191: PUSH
42192: LD_INT 1
42194: NEG
42195: PUSH
42196: LD_INT 3
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 2
42205: PUSH
42206: LD_INT 5
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 2
42215: NEG
42216: PUSH
42217: LD_INT 3
42219: PUSH
42220: EMPTY
42221: LIST
42222: LIST
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: LIST
42228: LIST
42229: LIST
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: LIST
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: LIST
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: LIST
42267: LIST
42268: LIST
42269: LIST
42270: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42271: LD_ADDR_VAR 0 34
42275: PUSH
42276: LD_INT 0
42278: PUSH
42279: LD_INT 4
42281: NEG
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 0
42289: PUSH
42290: LD_INT 5
42292: NEG
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 1
42300: PUSH
42301: LD_INT 4
42303: NEG
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: LD_INT 1
42311: PUSH
42312: LD_INT 3
42314: NEG
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PUSH
42320: LD_INT 0
42322: PUSH
42323: LD_INT 3
42325: NEG
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 1
42333: NEG
42334: PUSH
42335: LD_INT 4
42337: NEG
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 1
42345: NEG
42346: PUSH
42347: LD_INT 5
42349: NEG
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 2
42357: PUSH
42358: LD_INT 3
42360: NEG
42361: PUSH
42362: EMPTY
42363: LIST
42364: LIST
42365: PUSH
42366: LD_INT 2
42368: NEG
42369: PUSH
42370: LD_INT 5
42372: NEG
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 3
42380: PUSH
42381: LD_INT 0
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: LD_INT 1
42393: NEG
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 4
42401: PUSH
42402: LD_INT 0
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: LD_INT 4
42411: PUSH
42412: LD_INT 1
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 3
42421: PUSH
42422: LD_INT 1
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 2
42431: PUSH
42432: LD_INT 0
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 2
42441: PUSH
42442: LD_INT 1
42444: NEG
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 2
42452: PUSH
42453: LD_INT 2
42455: NEG
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 4
42463: PUSH
42464: LD_INT 2
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 4
42473: PUSH
42474: LD_INT 4
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 4
42483: PUSH
42484: LD_INT 3
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 5
42493: PUSH
42494: LD_INT 4
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 5
42503: PUSH
42504: LD_INT 5
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 4
42513: PUSH
42514: LD_INT 5
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: PUSH
42521: LD_INT 3
42523: PUSH
42524: LD_INT 4
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: PUSH
42531: LD_INT 3
42533: PUSH
42534: LD_INT 3
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 5
42543: PUSH
42544: LD_INT 3
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: LD_INT 3
42553: PUSH
42554: LD_INT 5
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 0
42563: PUSH
42564: LD_INT 3
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 0
42573: PUSH
42574: LD_INT 2
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 1
42583: PUSH
42584: LD_INT 3
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 1
42593: PUSH
42594: LD_INT 4
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 0
42603: PUSH
42604: LD_INT 4
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 1
42613: NEG
42614: PUSH
42615: LD_INT 3
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 1
42624: NEG
42625: PUSH
42626: LD_INT 2
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 2
42635: PUSH
42636: LD_INT 4
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 2
42645: NEG
42646: PUSH
42647: LD_INT 2
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 4
42656: NEG
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: LD_INT 4
42667: NEG
42668: PUSH
42669: LD_INT 1
42671: NEG
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 3
42679: NEG
42680: PUSH
42681: LD_INT 0
42683: PUSH
42684: EMPTY
42685: LIST
42686: LIST
42687: PUSH
42688: LD_INT 3
42690: NEG
42691: PUSH
42692: LD_INT 1
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 4
42701: NEG
42702: PUSH
42703: LD_INT 1
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 5
42712: NEG
42713: PUSH
42714: LD_INT 0
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: LD_INT 5
42723: NEG
42724: PUSH
42725: LD_INT 1
42727: NEG
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 5
42735: NEG
42736: PUSH
42737: LD_INT 2
42739: NEG
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: PUSH
42745: LD_INT 3
42747: NEG
42748: PUSH
42749: LD_INT 2
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: LIST
42774: LIST
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: LIST
42783: LIST
42784: LIST
42785: LIST
42786: LIST
42787: LIST
42788: LIST
42789: LIST
42790: LIST
42791: LIST
42792: LIST
42793: LIST
42794: LIST
42795: LIST
42796: LIST
42797: LIST
42798: LIST
42799: LIST
42800: LIST
42801: LIST
42802: ST_TO_ADDR
// end ; end ;
42803: GO 42806
42805: POP
// case btype of b_depot , b_warehouse :
42806: LD_VAR 0 1
42810: PUSH
42811: LD_INT 0
42813: DOUBLE
42814: EQUAL
42815: IFTRUE 42825
42817: LD_INT 1
42819: DOUBLE
42820: EQUAL
42821: IFTRUE 42825
42823: GO 43026
42825: POP
// case nation of nation_american :
42826: LD_VAR 0 5
42830: PUSH
42831: LD_INT 1
42833: DOUBLE
42834: EQUAL
42835: IFTRUE 42839
42837: GO 42895
42839: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42840: LD_ADDR_VAR 0 9
42844: PUSH
42845: LD_VAR 0 11
42849: PUSH
42850: LD_VAR 0 12
42854: PUSH
42855: LD_VAR 0 13
42859: PUSH
42860: LD_VAR 0 14
42864: PUSH
42865: LD_VAR 0 15
42869: PUSH
42870: LD_VAR 0 16
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: PUSH
42883: LD_VAR 0 4
42887: PUSH
42888: LD_INT 1
42890: PLUS
42891: ARRAY
42892: ST_TO_ADDR
42893: GO 43024
42895: LD_INT 2
42897: DOUBLE
42898: EQUAL
42899: IFTRUE 42903
42901: GO 42959
42903: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42904: LD_ADDR_VAR 0 9
42908: PUSH
42909: LD_VAR 0 17
42913: PUSH
42914: LD_VAR 0 18
42918: PUSH
42919: LD_VAR 0 19
42923: PUSH
42924: LD_VAR 0 20
42928: PUSH
42929: LD_VAR 0 21
42933: PUSH
42934: LD_VAR 0 22
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: PUSH
42947: LD_VAR 0 4
42951: PUSH
42952: LD_INT 1
42954: PLUS
42955: ARRAY
42956: ST_TO_ADDR
42957: GO 43024
42959: LD_INT 3
42961: DOUBLE
42962: EQUAL
42963: IFTRUE 42967
42965: GO 43023
42967: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42968: LD_ADDR_VAR 0 9
42972: PUSH
42973: LD_VAR 0 23
42977: PUSH
42978: LD_VAR 0 24
42982: PUSH
42983: LD_VAR 0 25
42987: PUSH
42988: LD_VAR 0 26
42992: PUSH
42993: LD_VAR 0 27
42997: PUSH
42998: LD_VAR 0 28
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: LIST
43007: LIST
43008: LIST
43009: LIST
43010: PUSH
43011: LD_VAR 0 4
43015: PUSH
43016: LD_INT 1
43018: PLUS
43019: ARRAY
43020: ST_TO_ADDR
43021: GO 43024
43023: POP
43024: GO 43579
43026: LD_INT 2
43028: DOUBLE
43029: EQUAL
43030: IFTRUE 43040
43032: LD_INT 3
43034: DOUBLE
43035: EQUAL
43036: IFTRUE 43040
43038: GO 43096
43040: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43041: LD_ADDR_VAR 0 9
43045: PUSH
43046: LD_VAR 0 29
43050: PUSH
43051: LD_VAR 0 30
43055: PUSH
43056: LD_VAR 0 31
43060: PUSH
43061: LD_VAR 0 32
43065: PUSH
43066: LD_VAR 0 33
43070: PUSH
43071: LD_VAR 0 34
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: LIST
43080: LIST
43081: LIST
43082: LIST
43083: PUSH
43084: LD_VAR 0 4
43088: PUSH
43089: LD_INT 1
43091: PLUS
43092: ARRAY
43093: ST_TO_ADDR
43094: GO 43579
43096: LD_INT 16
43098: DOUBLE
43099: EQUAL
43100: IFTRUE 43158
43102: LD_INT 17
43104: DOUBLE
43105: EQUAL
43106: IFTRUE 43158
43108: LD_INT 18
43110: DOUBLE
43111: EQUAL
43112: IFTRUE 43158
43114: LD_INT 19
43116: DOUBLE
43117: EQUAL
43118: IFTRUE 43158
43120: LD_INT 22
43122: DOUBLE
43123: EQUAL
43124: IFTRUE 43158
43126: LD_INT 20
43128: DOUBLE
43129: EQUAL
43130: IFTRUE 43158
43132: LD_INT 21
43134: DOUBLE
43135: EQUAL
43136: IFTRUE 43158
43138: LD_INT 23
43140: DOUBLE
43141: EQUAL
43142: IFTRUE 43158
43144: LD_INT 24
43146: DOUBLE
43147: EQUAL
43148: IFTRUE 43158
43150: LD_INT 25
43152: DOUBLE
43153: EQUAL
43154: IFTRUE 43158
43156: GO 43214
43158: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43159: LD_ADDR_VAR 0 9
43163: PUSH
43164: LD_VAR 0 35
43168: PUSH
43169: LD_VAR 0 36
43173: PUSH
43174: LD_VAR 0 37
43178: PUSH
43179: LD_VAR 0 38
43183: PUSH
43184: LD_VAR 0 39
43188: PUSH
43189: LD_VAR 0 40
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: PUSH
43202: LD_VAR 0 4
43206: PUSH
43207: LD_INT 1
43209: PLUS
43210: ARRAY
43211: ST_TO_ADDR
43212: GO 43579
43214: LD_INT 6
43216: DOUBLE
43217: EQUAL
43218: IFTRUE 43270
43220: LD_INT 7
43222: DOUBLE
43223: EQUAL
43224: IFTRUE 43270
43226: LD_INT 8
43228: DOUBLE
43229: EQUAL
43230: IFTRUE 43270
43232: LD_INT 13
43234: DOUBLE
43235: EQUAL
43236: IFTRUE 43270
43238: LD_INT 12
43240: DOUBLE
43241: EQUAL
43242: IFTRUE 43270
43244: LD_INT 15
43246: DOUBLE
43247: EQUAL
43248: IFTRUE 43270
43250: LD_INT 11
43252: DOUBLE
43253: EQUAL
43254: IFTRUE 43270
43256: LD_INT 14
43258: DOUBLE
43259: EQUAL
43260: IFTRUE 43270
43262: LD_INT 10
43264: DOUBLE
43265: EQUAL
43266: IFTRUE 43270
43268: GO 43326
43270: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43271: LD_ADDR_VAR 0 9
43275: PUSH
43276: LD_VAR 0 41
43280: PUSH
43281: LD_VAR 0 42
43285: PUSH
43286: LD_VAR 0 43
43290: PUSH
43291: LD_VAR 0 44
43295: PUSH
43296: LD_VAR 0 45
43300: PUSH
43301: LD_VAR 0 46
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: LIST
43310: LIST
43311: LIST
43312: LIST
43313: PUSH
43314: LD_VAR 0 4
43318: PUSH
43319: LD_INT 1
43321: PLUS
43322: ARRAY
43323: ST_TO_ADDR
43324: GO 43579
43326: LD_INT 36
43328: DOUBLE
43329: EQUAL
43330: IFTRUE 43334
43332: GO 43390
43334: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43335: LD_ADDR_VAR 0 9
43339: PUSH
43340: LD_VAR 0 47
43344: PUSH
43345: LD_VAR 0 48
43349: PUSH
43350: LD_VAR 0 49
43354: PUSH
43355: LD_VAR 0 50
43359: PUSH
43360: LD_VAR 0 51
43364: PUSH
43365: LD_VAR 0 52
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: PUSH
43378: LD_VAR 0 4
43382: PUSH
43383: LD_INT 1
43385: PLUS
43386: ARRAY
43387: ST_TO_ADDR
43388: GO 43579
43390: LD_INT 4
43392: DOUBLE
43393: EQUAL
43394: IFTRUE 43416
43396: LD_INT 5
43398: DOUBLE
43399: EQUAL
43400: IFTRUE 43416
43402: LD_INT 34
43404: DOUBLE
43405: EQUAL
43406: IFTRUE 43416
43408: LD_INT 37
43410: DOUBLE
43411: EQUAL
43412: IFTRUE 43416
43414: GO 43472
43416: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43417: LD_ADDR_VAR 0 9
43421: PUSH
43422: LD_VAR 0 53
43426: PUSH
43427: LD_VAR 0 54
43431: PUSH
43432: LD_VAR 0 55
43436: PUSH
43437: LD_VAR 0 56
43441: PUSH
43442: LD_VAR 0 57
43446: PUSH
43447: LD_VAR 0 58
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: PUSH
43460: LD_VAR 0 4
43464: PUSH
43465: LD_INT 1
43467: PLUS
43468: ARRAY
43469: ST_TO_ADDR
43470: GO 43579
43472: LD_INT 31
43474: DOUBLE
43475: EQUAL
43476: IFTRUE 43522
43478: LD_INT 32
43480: DOUBLE
43481: EQUAL
43482: IFTRUE 43522
43484: LD_INT 33
43486: DOUBLE
43487: EQUAL
43488: IFTRUE 43522
43490: LD_INT 27
43492: DOUBLE
43493: EQUAL
43494: IFTRUE 43522
43496: LD_INT 26
43498: DOUBLE
43499: EQUAL
43500: IFTRUE 43522
43502: LD_INT 28
43504: DOUBLE
43505: EQUAL
43506: IFTRUE 43522
43508: LD_INT 29
43510: DOUBLE
43511: EQUAL
43512: IFTRUE 43522
43514: LD_INT 30
43516: DOUBLE
43517: EQUAL
43518: IFTRUE 43522
43520: GO 43578
43522: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43523: LD_ADDR_VAR 0 9
43527: PUSH
43528: LD_VAR 0 59
43532: PUSH
43533: LD_VAR 0 60
43537: PUSH
43538: LD_VAR 0 61
43542: PUSH
43543: LD_VAR 0 62
43547: PUSH
43548: LD_VAR 0 63
43552: PUSH
43553: LD_VAR 0 64
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: LIST
43562: LIST
43563: LIST
43564: LIST
43565: PUSH
43566: LD_VAR 0 4
43570: PUSH
43571: LD_INT 1
43573: PLUS
43574: ARRAY
43575: ST_TO_ADDR
43576: GO 43579
43578: POP
// temp_list2 = [ ] ;
43579: LD_ADDR_VAR 0 10
43583: PUSH
43584: EMPTY
43585: ST_TO_ADDR
// for i in temp_list do
43586: LD_ADDR_VAR 0 8
43590: PUSH
43591: LD_VAR 0 9
43595: PUSH
43596: FOR_IN
43597: IFFALSE 43649
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43599: LD_ADDR_VAR 0 10
43603: PUSH
43604: LD_VAR 0 10
43608: PUSH
43609: LD_VAR 0 8
43613: PUSH
43614: LD_INT 1
43616: ARRAY
43617: PUSH
43618: LD_VAR 0 2
43622: PLUS
43623: PUSH
43624: LD_VAR 0 8
43628: PUSH
43629: LD_INT 2
43631: ARRAY
43632: PUSH
43633: LD_VAR 0 3
43637: PLUS
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: EMPTY
43644: LIST
43645: ADD
43646: ST_TO_ADDR
43647: GO 43596
43649: POP
43650: POP
// result = temp_list2 ;
43651: LD_ADDR_VAR 0 7
43655: PUSH
43656: LD_VAR 0 10
43660: ST_TO_ADDR
// end ;
43661: LD_VAR 0 7
43665: RET
// export function EnemyInRange ( unit , dist ) ; begin
43666: LD_INT 0
43668: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43669: LD_ADDR_VAR 0 3
43673: PUSH
43674: LD_VAR 0 1
43678: PPUSH
43679: CALL_OW 255
43683: PPUSH
43684: LD_VAR 0 1
43688: PPUSH
43689: CALL_OW 250
43693: PPUSH
43694: LD_VAR 0 1
43698: PPUSH
43699: CALL_OW 251
43703: PPUSH
43704: LD_VAR 0 2
43708: PPUSH
43709: CALL 17062 0 4
43713: PUSH
43714: LD_INT 4
43716: ARRAY
43717: ST_TO_ADDR
// end ;
43718: LD_VAR 0 3
43722: RET
// export function PlayerSeeMe ( unit ) ; begin
43723: LD_INT 0
43725: PPUSH
// result := See ( your_side , unit ) ;
43726: LD_ADDR_VAR 0 2
43730: PUSH
43731: LD_OWVAR 2
43735: PPUSH
43736: LD_VAR 0 1
43740: PPUSH
43741: CALL_OW 292
43745: ST_TO_ADDR
// end ;
43746: LD_VAR 0 2
43750: RET
// export function ReverseDir ( unit ) ; begin
43751: LD_INT 0
43753: PPUSH
// if not unit then
43754: LD_VAR 0 1
43758: NOT
43759: IFFALSE 43763
// exit ;
43761: GO 43786
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43763: LD_ADDR_VAR 0 2
43767: PUSH
43768: LD_VAR 0 1
43772: PPUSH
43773: CALL_OW 254
43777: PUSH
43778: LD_INT 3
43780: PLUS
43781: PUSH
43782: LD_INT 6
43784: MOD
43785: ST_TO_ADDR
// end ;
43786: LD_VAR 0 2
43790: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
43791: LD_INT 0
43793: PPUSH
43794: PPUSH
43795: PPUSH
43796: PPUSH
43797: PPUSH
// if not hexes then
43798: LD_VAR 0 2
43802: NOT
43803: IFFALSE 43807
// exit ;
43805: GO 43955
// dist := 9999 ;
43807: LD_ADDR_VAR 0 5
43811: PUSH
43812: LD_INT 9999
43814: ST_TO_ADDR
// for i = 1 to hexes do
43815: LD_ADDR_VAR 0 4
43819: PUSH
43820: DOUBLE
43821: LD_INT 1
43823: DEC
43824: ST_TO_ADDR
43825: LD_VAR 0 2
43829: PUSH
43830: FOR_TO
43831: IFFALSE 43943
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
43833: LD_VAR 0 1
43837: PPUSH
43838: LD_VAR 0 2
43842: PUSH
43843: LD_VAR 0 4
43847: ARRAY
43848: PUSH
43849: LD_INT 1
43851: ARRAY
43852: PPUSH
43853: LD_VAR 0 2
43857: PUSH
43858: LD_VAR 0 4
43862: ARRAY
43863: PUSH
43864: LD_INT 2
43866: ARRAY
43867: PPUSH
43868: CALL_OW 297
43872: PUSH
43873: LD_VAR 0 5
43877: LESS
43878: IFFALSE 43941
// begin hex := hexes [ i ] ;
43880: LD_ADDR_VAR 0 7
43884: PUSH
43885: LD_VAR 0 2
43889: PUSH
43890: LD_VAR 0 4
43894: ARRAY
43895: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43896: LD_ADDR_VAR 0 5
43900: PUSH
43901: LD_VAR 0 1
43905: PPUSH
43906: LD_VAR 0 2
43910: PUSH
43911: LD_VAR 0 4
43915: ARRAY
43916: PUSH
43917: LD_INT 1
43919: ARRAY
43920: PPUSH
43921: LD_VAR 0 2
43925: PUSH
43926: LD_VAR 0 4
43930: ARRAY
43931: PUSH
43932: LD_INT 2
43934: ARRAY
43935: PPUSH
43936: CALL_OW 297
43940: ST_TO_ADDR
// end ; end ;
43941: GO 43830
43943: POP
43944: POP
// result := hex ;
43945: LD_ADDR_VAR 0 3
43949: PUSH
43950: LD_VAR 0 7
43954: ST_TO_ADDR
// end ;
43955: LD_VAR 0 3
43959: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43960: LD_INT 0
43962: PPUSH
43963: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43964: LD_VAR 0 1
43968: NOT
43969: PUSH
43970: LD_VAR 0 1
43974: PUSH
43975: LD_INT 21
43977: PUSH
43978: LD_INT 2
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 23
43987: PUSH
43988: LD_INT 2
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PPUSH
43999: CALL_OW 69
44003: IN
44004: NOT
44005: OR
44006: IFFALSE 44010
// exit ;
44008: GO 44057
// for i = 1 to 3 do
44010: LD_ADDR_VAR 0 3
44014: PUSH
44015: DOUBLE
44016: LD_INT 1
44018: DEC
44019: ST_TO_ADDR
44020: LD_INT 3
44022: PUSH
44023: FOR_TO
44024: IFFALSE 44055
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44026: LD_VAR 0 1
44030: PPUSH
44031: CALL_OW 250
44035: PPUSH
44036: LD_VAR 0 1
44040: PPUSH
44041: CALL_OW 251
44045: PPUSH
44046: LD_INT 1
44048: PPUSH
44049: CALL_OW 453
44053: GO 44023
44055: POP
44056: POP
// end ;
44057: LD_VAR 0 2
44061: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44062: LD_INT 0
44064: PPUSH
44065: PPUSH
44066: PPUSH
44067: PPUSH
44068: PPUSH
44069: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44070: LD_VAR 0 1
44074: NOT
44075: PUSH
44076: LD_VAR 0 2
44080: NOT
44081: OR
44082: PUSH
44083: LD_VAR 0 1
44087: PPUSH
44088: CALL_OW 314
44092: OR
44093: IFFALSE 44097
// exit ;
44095: GO 44538
// x := GetX ( enemy_unit ) ;
44097: LD_ADDR_VAR 0 7
44101: PUSH
44102: LD_VAR 0 2
44106: PPUSH
44107: CALL_OW 250
44111: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44112: LD_ADDR_VAR 0 8
44116: PUSH
44117: LD_VAR 0 2
44121: PPUSH
44122: CALL_OW 251
44126: ST_TO_ADDR
// if not x or not y then
44127: LD_VAR 0 7
44131: NOT
44132: PUSH
44133: LD_VAR 0 8
44137: NOT
44138: OR
44139: IFFALSE 44143
// exit ;
44141: GO 44538
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44143: LD_ADDR_VAR 0 6
44147: PUSH
44148: LD_VAR 0 7
44152: PPUSH
44153: LD_INT 0
44155: PPUSH
44156: LD_INT 4
44158: PPUSH
44159: CALL_OW 272
44163: PUSH
44164: LD_VAR 0 8
44168: PPUSH
44169: LD_INT 0
44171: PPUSH
44172: LD_INT 4
44174: PPUSH
44175: CALL_OW 273
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: PUSH
44184: LD_VAR 0 7
44188: PPUSH
44189: LD_INT 1
44191: PPUSH
44192: LD_INT 4
44194: PPUSH
44195: CALL_OW 272
44199: PUSH
44200: LD_VAR 0 8
44204: PPUSH
44205: LD_INT 1
44207: PPUSH
44208: LD_INT 4
44210: PPUSH
44211: CALL_OW 273
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_VAR 0 7
44224: PPUSH
44225: LD_INT 2
44227: PPUSH
44228: LD_INT 4
44230: PPUSH
44231: CALL_OW 272
44235: PUSH
44236: LD_VAR 0 8
44240: PPUSH
44241: LD_INT 2
44243: PPUSH
44244: LD_INT 4
44246: PPUSH
44247: CALL_OW 273
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_VAR 0 7
44260: PPUSH
44261: LD_INT 3
44263: PPUSH
44264: LD_INT 4
44266: PPUSH
44267: CALL_OW 272
44271: PUSH
44272: LD_VAR 0 8
44276: PPUSH
44277: LD_INT 3
44279: PPUSH
44280: LD_INT 4
44282: PPUSH
44283: CALL_OW 273
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: PUSH
44292: LD_VAR 0 7
44296: PPUSH
44297: LD_INT 4
44299: PPUSH
44300: LD_INT 4
44302: PPUSH
44303: CALL_OW 272
44307: PUSH
44308: LD_VAR 0 8
44312: PPUSH
44313: LD_INT 4
44315: PPUSH
44316: LD_INT 4
44318: PPUSH
44319: CALL_OW 273
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_VAR 0 7
44332: PPUSH
44333: LD_INT 5
44335: PPUSH
44336: LD_INT 4
44338: PPUSH
44339: CALL_OW 272
44343: PUSH
44344: LD_VAR 0 8
44348: PPUSH
44349: LD_INT 5
44351: PPUSH
44352: LD_INT 4
44354: PPUSH
44355: CALL_OW 273
44359: PUSH
44360: EMPTY
44361: LIST
44362: LIST
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: ST_TO_ADDR
// for i = tmp downto 1 do
44372: LD_ADDR_VAR 0 4
44376: PUSH
44377: DOUBLE
44378: LD_VAR 0 6
44382: INC
44383: ST_TO_ADDR
44384: LD_INT 1
44386: PUSH
44387: FOR_DOWNTO
44388: IFFALSE 44489
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44390: LD_VAR 0 6
44394: PUSH
44395: LD_VAR 0 4
44399: ARRAY
44400: PUSH
44401: LD_INT 1
44403: ARRAY
44404: PPUSH
44405: LD_VAR 0 6
44409: PUSH
44410: LD_VAR 0 4
44414: ARRAY
44415: PUSH
44416: LD_INT 2
44418: ARRAY
44419: PPUSH
44420: CALL_OW 488
44424: NOT
44425: PUSH
44426: LD_VAR 0 6
44430: PUSH
44431: LD_VAR 0 4
44435: ARRAY
44436: PUSH
44437: LD_INT 1
44439: ARRAY
44440: PPUSH
44441: LD_VAR 0 6
44445: PUSH
44446: LD_VAR 0 4
44450: ARRAY
44451: PUSH
44452: LD_INT 2
44454: ARRAY
44455: PPUSH
44456: CALL_OW 428
44460: PUSH
44461: LD_INT 0
44463: NONEQUAL
44464: OR
44465: IFFALSE 44487
// tmp := Delete ( tmp , i ) ;
44467: LD_ADDR_VAR 0 6
44471: PUSH
44472: LD_VAR 0 6
44476: PPUSH
44477: LD_VAR 0 4
44481: PPUSH
44482: CALL_OW 3
44486: ST_TO_ADDR
44487: GO 44387
44489: POP
44490: POP
// j := GetClosestHex ( unit , tmp ) ;
44491: LD_ADDR_VAR 0 5
44495: PUSH
44496: LD_VAR 0 1
44500: PPUSH
44501: LD_VAR 0 6
44505: PPUSH
44506: CALL 43791 0 2
44510: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44511: LD_VAR 0 1
44515: PPUSH
44516: LD_VAR 0 5
44520: PUSH
44521: LD_INT 1
44523: ARRAY
44524: PPUSH
44525: LD_VAR 0 5
44529: PUSH
44530: LD_INT 2
44532: ARRAY
44533: PPUSH
44534: CALL_OW 111
// end ;
44538: LD_VAR 0 3
44542: RET
// export function PrepareApemanSoldier ( ) ; begin
44543: LD_INT 0
44545: PPUSH
// uc_nation := 0 ;
44546: LD_ADDR_OWVAR 21
44550: PUSH
44551: LD_INT 0
44553: ST_TO_ADDR
// hc_sex := sex_male ;
44554: LD_ADDR_OWVAR 27
44558: PUSH
44559: LD_INT 1
44561: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44562: LD_ADDR_OWVAR 28
44566: PUSH
44567: LD_INT 15
44569: ST_TO_ADDR
// hc_gallery :=  ;
44570: LD_ADDR_OWVAR 33
44574: PUSH
44575: LD_STRING 
44577: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44578: LD_ADDR_OWVAR 31
44582: PUSH
44583: LD_INT 0
44585: PPUSH
44586: LD_INT 3
44588: PPUSH
44589: CALL_OW 12
44593: PUSH
44594: LD_INT 0
44596: PPUSH
44597: LD_INT 3
44599: PPUSH
44600: CALL_OW 12
44604: PUSH
44605: LD_INT 0
44607: PUSH
44608: LD_INT 0
44610: PUSH
44611: EMPTY
44612: LIST
44613: LIST
44614: LIST
44615: LIST
44616: ST_TO_ADDR
// end ;
44617: LD_VAR 0 1
44621: RET
// export function PrepareApemanEngineer ( ) ; begin
44622: LD_INT 0
44624: PPUSH
// uc_nation := 0 ;
44625: LD_ADDR_OWVAR 21
44629: PUSH
44630: LD_INT 0
44632: ST_TO_ADDR
// hc_sex := sex_male ;
44633: LD_ADDR_OWVAR 27
44637: PUSH
44638: LD_INT 1
44640: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
44641: LD_ADDR_OWVAR 28
44645: PUSH
44646: LD_INT 16
44648: ST_TO_ADDR
// hc_gallery :=  ;
44649: LD_ADDR_OWVAR 33
44653: PUSH
44654: LD_STRING 
44656: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44657: LD_ADDR_OWVAR 31
44661: PUSH
44662: LD_INT 0
44664: PPUSH
44665: LD_INT 3
44667: PPUSH
44668: CALL_OW 12
44672: PUSH
44673: LD_INT 0
44675: PPUSH
44676: LD_INT 3
44678: PPUSH
44679: CALL_OW 12
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: LD_INT 0
44689: PUSH
44690: EMPTY
44691: LIST
44692: LIST
44693: LIST
44694: LIST
44695: ST_TO_ADDR
// end ;
44696: LD_VAR 0 1
44700: RET
// export function PrepareApeman ( agressivity ) ; begin
44701: LD_INT 0
44703: PPUSH
// uc_side := 0 ;
44704: LD_ADDR_OWVAR 20
44708: PUSH
44709: LD_INT 0
44711: ST_TO_ADDR
// uc_nation := 0 ;
44712: LD_ADDR_OWVAR 21
44716: PUSH
44717: LD_INT 0
44719: ST_TO_ADDR
// hc_sex := sex_male ;
44720: LD_ADDR_OWVAR 27
44724: PUSH
44725: LD_INT 1
44727: ST_TO_ADDR
// hc_class := class_apeman ;
44728: LD_ADDR_OWVAR 28
44732: PUSH
44733: LD_INT 12
44735: ST_TO_ADDR
// hc_gallery :=  ;
44736: LD_ADDR_OWVAR 33
44740: PUSH
44741: LD_STRING 
44743: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44744: LD_ADDR_OWVAR 35
44748: PUSH
44749: LD_VAR 0 1
44753: NEG
44754: PPUSH
44755: LD_VAR 0 1
44759: PPUSH
44760: CALL_OW 12
44764: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44765: LD_ADDR_OWVAR 31
44769: PUSH
44770: LD_INT 0
44772: PPUSH
44773: LD_INT 3
44775: PPUSH
44776: CALL_OW 12
44780: PUSH
44781: LD_INT 0
44783: PPUSH
44784: LD_INT 3
44786: PPUSH
44787: CALL_OW 12
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 0
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: ST_TO_ADDR
// end ;
44804: LD_VAR 0 2
44808: RET
// export function PrepareTiger ( agressivity ) ; begin
44809: LD_INT 0
44811: PPUSH
// uc_side := 0 ;
44812: LD_ADDR_OWVAR 20
44816: PUSH
44817: LD_INT 0
44819: ST_TO_ADDR
// uc_nation := 0 ;
44820: LD_ADDR_OWVAR 21
44824: PUSH
44825: LD_INT 0
44827: ST_TO_ADDR
// hc_class := class_tiger ;
44828: LD_ADDR_OWVAR 28
44832: PUSH
44833: LD_INT 14
44835: ST_TO_ADDR
// hc_gallery :=  ;
44836: LD_ADDR_OWVAR 33
44840: PUSH
44841: LD_STRING 
44843: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44844: LD_ADDR_OWVAR 35
44848: PUSH
44849: LD_VAR 0 1
44853: NEG
44854: PPUSH
44855: LD_VAR 0 1
44859: PPUSH
44860: CALL_OW 12
44864: ST_TO_ADDR
// end ;
44865: LD_VAR 0 2
44869: RET
// export function PrepareEnchidna ( ) ; begin
44870: LD_INT 0
44872: PPUSH
// uc_side := 0 ;
44873: LD_ADDR_OWVAR 20
44877: PUSH
44878: LD_INT 0
44880: ST_TO_ADDR
// uc_nation := 0 ;
44881: LD_ADDR_OWVAR 21
44885: PUSH
44886: LD_INT 0
44888: ST_TO_ADDR
// hc_class := class_baggie ;
44889: LD_ADDR_OWVAR 28
44893: PUSH
44894: LD_INT 13
44896: ST_TO_ADDR
// hc_gallery :=  ;
44897: LD_ADDR_OWVAR 33
44901: PUSH
44902: LD_STRING 
44904: ST_TO_ADDR
// end ;
44905: LD_VAR 0 1
44909: RET
// export function PrepareFrog ( ) ; begin
44910: LD_INT 0
44912: PPUSH
// uc_side := 0 ;
44913: LD_ADDR_OWVAR 20
44917: PUSH
44918: LD_INT 0
44920: ST_TO_ADDR
// uc_nation := 0 ;
44921: LD_ADDR_OWVAR 21
44925: PUSH
44926: LD_INT 0
44928: ST_TO_ADDR
// hc_class := class_frog ;
44929: LD_ADDR_OWVAR 28
44933: PUSH
44934: LD_INT 19
44936: ST_TO_ADDR
// hc_gallery :=  ;
44937: LD_ADDR_OWVAR 33
44941: PUSH
44942: LD_STRING 
44944: ST_TO_ADDR
// end ;
44945: LD_VAR 0 1
44949: RET
// export function PrepareFish ( ) ; begin
44950: LD_INT 0
44952: PPUSH
// uc_side := 0 ;
44953: LD_ADDR_OWVAR 20
44957: PUSH
44958: LD_INT 0
44960: ST_TO_ADDR
// uc_nation := 0 ;
44961: LD_ADDR_OWVAR 21
44965: PUSH
44966: LD_INT 0
44968: ST_TO_ADDR
// hc_class := class_fish ;
44969: LD_ADDR_OWVAR 28
44973: PUSH
44974: LD_INT 20
44976: ST_TO_ADDR
// hc_gallery :=  ;
44977: LD_ADDR_OWVAR 33
44981: PUSH
44982: LD_STRING 
44984: ST_TO_ADDR
// end ;
44985: LD_VAR 0 1
44989: RET
// export function PrepareBird ( ) ; begin
44990: LD_INT 0
44992: PPUSH
// uc_side := 0 ;
44993: LD_ADDR_OWVAR 20
44997: PUSH
44998: LD_INT 0
45000: ST_TO_ADDR
// uc_nation := 0 ;
45001: LD_ADDR_OWVAR 21
45005: PUSH
45006: LD_INT 0
45008: ST_TO_ADDR
// hc_class := class_phororhacos ;
45009: LD_ADDR_OWVAR 28
45013: PUSH
45014: LD_INT 18
45016: ST_TO_ADDR
// hc_gallery :=  ;
45017: LD_ADDR_OWVAR 33
45021: PUSH
45022: LD_STRING 
45024: ST_TO_ADDR
// end ;
45025: LD_VAR 0 1
45029: RET
// export function PrepareHorse ( ) ; begin
45030: LD_INT 0
45032: PPUSH
// uc_side := 0 ;
45033: LD_ADDR_OWVAR 20
45037: PUSH
45038: LD_INT 0
45040: ST_TO_ADDR
// uc_nation := 0 ;
45041: LD_ADDR_OWVAR 21
45045: PUSH
45046: LD_INT 0
45048: ST_TO_ADDR
// hc_class := class_horse ;
45049: LD_ADDR_OWVAR 28
45053: PUSH
45054: LD_INT 21
45056: ST_TO_ADDR
// hc_gallery :=  ;
45057: LD_ADDR_OWVAR 33
45061: PUSH
45062: LD_STRING 
45064: ST_TO_ADDR
// end ;
45065: LD_VAR 0 1
45069: RET
// export function PrepareMastodont ( ) ; begin
45070: LD_INT 0
45072: PPUSH
// uc_side := 0 ;
45073: LD_ADDR_OWVAR 20
45077: PUSH
45078: LD_INT 0
45080: ST_TO_ADDR
// uc_nation := 0 ;
45081: LD_ADDR_OWVAR 21
45085: PUSH
45086: LD_INT 0
45088: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45089: LD_ADDR_OWVAR 37
45093: PUSH
45094: LD_INT 31
45096: ST_TO_ADDR
// vc_control := control_rider ;
45097: LD_ADDR_OWVAR 38
45101: PUSH
45102: LD_INT 4
45104: ST_TO_ADDR
// end ;
45105: LD_VAR 0 1
45109: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45110: LD_INT 0
45112: PPUSH
45113: PPUSH
45114: PPUSH
// uc_side = 0 ;
45115: LD_ADDR_OWVAR 20
45119: PUSH
45120: LD_INT 0
45122: ST_TO_ADDR
// uc_nation = 0 ;
45123: LD_ADDR_OWVAR 21
45127: PUSH
45128: LD_INT 0
45130: ST_TO_ADDR
// InitHc_All ( ) ;
45131: CALL_OW 584
// InitVc ;
45135: CALL_OW 20
// if mastodonts then
45139: LD_VAR 0 6
45143: IFFALSE 45210
// for i = 1 to mastodonts do
45145: LD_ADDR_VAR 0 11
45149: PUSH
45150: DOUBLE
45151: LD_INT 1
45153: DEC
45154: ST_TO_ADDR
45155: LD_VAR 0 6
45159: PUSH
45160: FOR_TO
45161: IFFALSE 45208
// begin vc_chassis := 31 ;
45163: LD_ADDR_OWVAR 37
45167: PUSH
45168: LD_INT 31
45170: ST_TO_ADDR
// vc_control := control_rider ;
45171: LD_ADDR_OWVAR 38
45175: PUSH
45176: LD_INT 4
45178: ST_TO_ADDR
// animal := CreateVehicle ;
45179: LD_ADDR_VAR 0 12
45183: PUSH
45184: CALL_OW 45
45188: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45189: LD_VAR 0 12
45193: PPUSH
45194: LD_VAR 0 8
45198: PPUSH
45199: LD_INT 0
45201: PPUSH
45202: CALL 47345 0 3
// end ;
45206: GO 45160
45208: POP
45209: POP
// if horses then
45210: LD_VAR 0 5
45214: IFFALSE 45281
// for i = 1 to horses do
45216: LD_ADDR_VAR 0 11
45220: PUSH
45221: DOUBLE
45222: LD_INT 1
45224: DEC
45225: ST_TO_ADDR
45226: LD_VAR 0 5
45230: PUSH
45231: FOR_TO
45232: IFFALSE 45279
// begin hc_class := 21 ;
45234: LD_ADDR_OWVAR 28
45238: PUSH
45239: LD_INT 21
45241: ST_TO_ADDR
// hc_gallery :=  ;
45242: LD_ADDR_OWVAR 33
45246: PUSH
45247: LD_STRING 
45249: ST_TO_ADDR
// animal := CreateHuman ;
45250: LD_ADDR_VAR 0 12
45254: PUSH
45255: CALL_OW 44
45259: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45260: LD_VAR 0 12
45264: PPUSH
45265: LD_VAR 0 8
45269: PPUSH
45270: LD_INT 0
45272: PPUSH
45273: CALL 47345 0 3
// end ;
45277: GO 45231
45279: POP
45280: POP
// if birds then
45281: LD_VAR 0 1
45285: IFFALSE 45352
// for i = 1 to birds do
45287: LD_ADDR_VAR 0 11
45291: PUSH
45292: DOUBLE
45293: LD_INT 1
45295: DEC
45296: ST_TO_ADDR
45297: LD_VAR 0 1
45301: PUSH
45302: FOR_TO
45303: IFFALSE 45350
// begin hc_class = 18 ;
45305: LD_ADDR_OWVAR 28
45309: PUSH
45310: LD_INT 18
45312: ST_TO_ADDR
// hc_gallery =  ;
45313: LD_ADDR_OWVAR 33
45317: PUSH
45318: LD_STRING 
45320: ST_TO_ADDR
// animal := CreateHuman ;
45321: LD_ADDR_VAR 0 12
45325: PUSH
45326: CALL_OW 44
45330: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45331: LD_VAR 0 12
45335: PPUSH
45336: LD_VAR 0 8
45340: PPUSH
45341: LD_INT 0
45343: PPUSH
45344: CALL 47345 0 3
// end ;
45348: GO 45302
45350: POP
45351: POP
// if tigers then
45352: LD_VAR 0 2
45356: IFFALSE 45440
// for i = 1 to tigers do
45358: LD_ADDR_VAR 0 11
45362: PUSH
45363: DOUBLE
45364: LD_INT 1
45366: DEC
45367: ST_TO_ADDR
45368: LD_VAR 0 2
45372: PUSH
45373: FOR_TO
45374: IFFALSE 45438
// begin hc_class = class_tiger ;
45376: LD_ADDR_OWVAR 28
45380: PUSH
45381: LD_INT 14
45383: ST_TO_ADDR
// hc_gallery =  ;
45384: LD_ADDR_OWVAR 33
45388: PUSH
45389: LD_STRING 
45391: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45392: LD_ADDR_OWVAR 35
45396: PUSH
45397: LD_INT 7
45399: NEG
45400: PPUSH
45401: LD_INT 7
45403: PPUSH
45404: CALL_OW 12
45408: ST_TO_ADDR
// animal := CreateHuman ;
45409: LD_ADDR_VAR 0 12
45413: PUSH
45414: CALL_OW 44
45418: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45419: LD_VAR 0 12
45423: PPUSH
45424: LD_VAR 0 8
45428: PPUSH
45429: LD_INT 0
45431: PPUSH
45432: CALL 47345 0 3
// end ;
45436: GO 45373
45438: POP
45439: POP
// if apemans then
45440: LD_VAR 0 3
45444: IFFALSE 45567
// for i = 1 to apemans do
45446: LD_ADDR_VAR 0 11
45450: PUSH
45451: DOUBLE
45452: LD_INT 1
45454: DEC
45455: ST_TO_ADDR
45456: LD_VAR 0 3
45460: PUSH
45461: FOR_TO
45462: IFFALSE 45565
// begin hc_class = class_apeman ;
45464: LD_ADDR_OWVAR 28
45468: PUSH
45469: LD_INT 12
45471: ST_TO_ADDR
// hc_gallery =  ;
45472: LD_ADDR_OWVAR 33
45476: PUSH
45477: LD_STRING 
45479: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45480: LD_ADDR_OWVAR 35
45484: PUSH
45485: LD_INT 2
45487: NEG
45488: PPUSH
45489: LD_INT 2
45491: PPUSH
45492: CALL_OW 12
45496: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45497: LD_ADDR_OWVAR 31
45501: PUSH
45502: LD_INT 1
45504: PPUSH
45505: LD_INT 3
45507: PPUSH
45508: CALL_OW 12
45512: PUSH
45513: LD_INT 1
45515: PPUSH
45516: LD_INT 3
45518: PPUSH
45519: CALL_OW 12
45523: PUSH
45524: LD_INT 0
45526: PUSH
45527: LD_INT 0
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: ST_TO_ADDR
// animal := CreateHuman ;
45536: LD_ADDR_VAR 0 12
45540: PUSH
45541: CALL_OW 44
45545: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45546: LD_VAR 0 12
45550: PPUSH
45551: LD_VAR 0 8
45555: PPUSH
45556: LD_INT 0
45558: PPUSH
45559: CALL 47345 0 3
// end ;
45563: GO 45461
45565: POP
45566: POP
// if enchidnas then
45567: LD_VAR 0 4
45571: IFFALSE 45638
// for i = 1 to enchidnas do
45573: LD_ADDR_VAR 0 11
45577: PUSH
45578: DOUBLE
45579: LD_INT 1
45581: DEC
45582: ST_TO_ADDR
45583: LD_VAR 0 4
45587: PUSH
45588: FOR_TO
45589: IFFALSE 45636
// begin hc_class = 13 ;
45591: LD_ADDR_OWVAR 28
45595: PUSH
45596: LD_INT 13
45598: ST_TO_ADDR
// hc_gallery =  ;
45599: LD_ADDR_OWVAR 33
45603: PUSH
45604: LD_STRING 
45606: ST_TO_ADDR
// animal := CreateHuman ;
45607: LD_ADDR_VAR 0 12
45611: PUSH
45612: CALL_OW 44
45616: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45617: LD_VAR 0 12
45621: PPUSH
45622: LD_VAR 0 8
45626: PPUSH
45627: LD_INT 0
45629: PPUSH
45630: CALL 47345 0 3
// end ;
45634: GO 45588
45636: POP
45637: POP
// if fishes then
45638: LD_VAR 0 7
45642: IFFALSE 45709
// for i = 1 to fishes do
45644: LD_ADDR_VAR 0 11
45648: PUSH
45649: DOUBLE
45650: LD_INT 1
45652: DEC
45653: ST_TO_ADDR
45654: LD_VAR 0 7
45658: PUSH
45659: FOR_TO
45660: IFFALSE 45707
// begin hc_class = 20 ;
45662: LD_ADDR_OWVAR 28
45666: PUSH
45667: LD_INT 20
45669: ST_TO_ADDR
// hc_gallery =  ;
45670: LD_ADDR_OWVAR 33
45674: PUSH
45675: LD_STRING 
45677: ST_TO_ADDR
// animal := CreateHuman ;
45678: LD_ADDR_VAR 0 12
45682: PUSH
45683: CALL_OW 44
45687: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
45688: LD_VAR 0 12
45692: PPUSH
45693: LD_VAR 0 9
45697: PPUSH
45698: LD_INT 0
45700: PPUSH
45701: CALL 47345 0 3
// end ;
45705: GO 45659
45707: POP
45708: POP
// end ;
45709: LD_VAR 0 10
45713: RET
// export function WantHeal ( sci , unit ) ; begin
45714: LD_INT 0
45716: PPUSH
// if GetTaskList ( sci ) > 0 then
45717: LD_VAR 0 1
45721: PPUSH
45722: CALL_OW 437
45726: PUSH
45727: LD_INT 0
45729: GREATER
45730: IFFALSE 45800
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45732: LD_VAR 0 1
45736: PPUSH
45737: CALL_OW 437
45741: PUSH
45742: LD_INT 1
45744: ARRAY
45745: PUSH
45746: LD_INT 1
45748: ARRAY
45749: PUSH
45750: LD_STRING l
45752: EQUAL
45753: PUSH
45754: LD_VAR 0 1
45758: PPUSH
45759: CALL_OW 437
45763: PUSH
45764: LD_INT 1
45766: ARRAY
45767: PUSH
45768: LD_INT 4
45770: ARRAY
45771: PUSH
45772: LD_VAR 0 2
45776: EQUAL
45777: AND
45778: IFFALSE 45790
// result := true else
45780: LD_ADDR_VAR 0 3
45784: PUSH
45785: LD_INT 1
45787: ST_TO_ADDR
45788: GO 45798
// result := false ;
45790: LD_ADDR_VAR 0 3
45794: PUSH
45795: LD_INT 0
45797: ST_TO_ADDR
// end else
45798: GO 45808
// result := false ;
45800: LD_ADDR_VAR 0 3
45804: PUSH
45805: LD_INT 0
45807: ST_TO_ADDR
// end ;
45808: LD_VAR 0 3
45812: RET
// export function HealTarget ( sci ) ; begin
45813: LD_INT 0
45815: PPUSH
// if not sci then
45816: LD_VAR 0 1
45820: NOT
45821: IFFALSE 45825
// exit ;
45823: GO 45890
// result := 0 ;
45825: LD_ADDR_VAR 0 2
45829: PUSH
45830: LD_INT 0
45832: ST_TO_ADDR
// if GetTaskList ( sci ) then
45833: LD_VAR 0 1
45837: PPUSH
45838: CALL_OW 437
45842: IFFALSE 45890
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45844: LD_VAR 0 1
45848: PPUSH
45849: CALL_OW 437
45853: PUSH
45854: LD_INT 1
45856: ARRAY
45857: PUSH
45858: LD_INT 1
45860: ARRAY
45861: PUSH
45862: LD_STRING l
45864: EQUAL
45865: IFFALSE 45890
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45867: LD_ADDR_VAR 0 2
45871: PUSH
45872: LD_VAR 0 1
45876: PPUSH
45877: CALL_OW 437
45881: PUSH
45882: LD_INT 1
45884: ARRAY
45885: PUSH
45886: LD_INT 4
45888: ARRAY
45889: ST_TO_ADDR
// end ;
45890: LD_VAR 0 2
45894: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45895: LD_INT 0
45897: PPUSH
45898: PPUSH
45899: PPUSH
45900: PPUSH
// if not base_units then
45901: LD_VAR 0 1
45905: NOT
45906: IFFALSE 45910
// exit ;
45908: GO 45997
// result := false ;
45910: LD_ADDR_VAR 0 2
45914: PUSH
45915: LD_INT 0
45917: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45918: LD_ADDR_VAR 0 5
45922: PUSH
45923: LD_VAR 0 1
45927: PPUSH
45928: LD_INT 21
45930: PUSH
45931: LD_INT 3
45933: PUSH
45934: EMPTY
45935: LIST
45936: LIST
45937: PPUSH
45938: CALL_OW 72
45942: ST_TO_ADDR
// if not tmp then
45943: LD_VAR 0 5
45947: NOT
45948: IFFALSE 45952
// exit ;
45950: GO 45997
// for i in tmp do
45952: LD_ADDR_VAR 0 3
45956: PUSH
45957: LD_VAR 0 5
45961: PUSH
45962: FOR_IN
45963: IFFALSE 45995
// begin result := EnemyInRange ( i , 22 ) ;
45965: LD_ADDR_VAR 0 2
45969: PUSH
45970: LD_VAR 0 3
45974: PPUSH
45975: LD_INT 22
45977: PPUSH
45978: CALL 43666 0 2
45982: ST_TO_ADDR
// if result then
45983: LD_VAR 0 2
45987: IFFALSE 45993
// exit ;
45989: POP
45990: POP
45991: GO 45997
// end ;
45993: GO 45962
45995: POP
45996: POP
// end ;
45997: LD_VAR 0 2
46001: RET
// export function FilterByTag ( units , tag ) ; begin
46002: LD_INT 0
46004: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46005: LD_ADDR_VAR 0 3
46009: PUSH
46010: LD_VAR 0 1
46014: PPUSH
46015: LD_INT 120
46017: PUSH
46018: LD_VAR 0 2
46022: PUSH
46023: EMPTY
46024: LIST
46025: LIST
46026: PPUSH
46027: CALL_OW 72
46031: ST_TO_ADDR
// end ;
46032: LD_VAR 0 3
46036: RET
// export function IsDriver ( un ) ; begin
46037: LD_INT 0
46039: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46040: LD_ADDR_VAR 0 2
46044: PUSH
46045: LD_VAR 0 1
46049: PUSH
46050: LD_INT 55
46052: PUSH
46053: EMPTY
46054: LIST
46055: PPUSH
46056: CALL_OW 69
46060: IN
46061: ST_TO_ADDR
// end ;
46062: LD_VAR 0 2
46066: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46067: LD_INT 0
46069: PPUSH
46070: PPUSH
// list := [ ] ;
46071: LD_ADDR_VAR 0 5
46075: PUSH
46076: EMPTY
46077: ST_TO_ADDR
// case d of 0 :
46078: LD_VAR 0 3
46082: PUSH
46083: LD_INT 0
46085: DOUBLE
46086: EQUAL
46087: IFTRUE 46091
46089: GO 46224
46091: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46092: LD_ADDR_VAR 0 5
46096: PUSH
46097: LD_VAR 0 1
46101: PUSH
46102: LD_INT 4
46104: MINUS
46105: PUSH
46106: LD_VAR 0 2
46110: PUSH
46111: LD_INT 4
46113: MINUS
46114: PUSH
46115: LD_INT 2
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: LIST
46122: PUSH
46123: LD_VAR 0 1
46127: PUSH
46128: LD_INT 3
46130: MINUS
46131: PUSH
46132: LD_VAR 0 2
46136: PUSH
46137: LD_INT 1
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: LIST
46144: PUSH
46145: LD_VAR 0 1
46149: PUSH
46150: LD_INT 4
46152: PLUS
46153: PUSH
46154: LD_VAR 0 2
46158: PUSH
46159: LD_INT 4
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: LIST
46166: PUSH
46167: LD_VAR 0 1
46171: PUSH
46172: LD_INT 3
46174: PLUS
46175: PUSH
46176: LD_VAR 0 2
46180: PUSH
46181: LD_INT 3
46183: PLUS
46184: PUSH
46185: LD_INT 5
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: LIST
46192: PUSH
46193: LD_VAR 0 1
46197: PUSH
46198: LD_VAR 0 2
46202: PUSH
46203: LD_INT 4
46205: PLUS
46206: PUSH
46207: LD_INT 0
46209: PUSH
46210: EMPTY
46211: LIST
46212: LIST
46213: LIST
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: LIST
46221: ST_TO_ADDR
// end ; 1 :
46222: GO 46922
46224: LD_INT 1
46226: DOUBLE
46227: EQUAL
46228: IFTRUE 46232
46230: GO 46365
46232: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46233: LD_ADDR_VAR 0 5
46237: PUSH
46238: LD_VAR 0 1
46242: PUSH
46243: LD_VAR 0 2
46247: PUSH
46248: LD_INT 4
46250: MINUS
46251: PUSH
46252: LD_INT 3
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: LIST
46259: PUSH
46260: LD_VAR 0 1
46264: PUSH
46265: LD_INT 3
46267: MINUS
46268: PUSH
46269: LD_VAR 0 2
46273: PUSH
46274: LD_INT 3
46276: MINUS
46277: PUSH
46278: LD_INT 2
46280: PUSH
46281: EMPTY
46282: LIST
46283: LIST
46284: LIST
46285: PUSH
46286: LD_VAR 0 1
46290: PUSH
46291: LD_INT 4
46293: MINUS
46294: PUSH
46295: LD_VAR 0 2
46299: PUSH
46300: LD_INT 1
46302: PUSH
46303: EMPTY
46304: LIST
46305: LIST
46306: LIST
46307: PUSH
46308: LD_VAR 0 1
46312: PUSH
46313: LD_VAR 0 2
46317: PUSH
46318: LD_INT 3
46320: PLUS
46321: PUSH
46322: LD_INT 0
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: LIST
46329: PUSH
46330: LD_VAR 0 1
46334: PUSH
46335: LD_INT 4
46337: PLUS
46338: PUSH
46339: LD_VAR 0 2
46343: PUSH
46344: LD_INT 4
46346: PLUS
46347: PUSH
46348: LD_INT 5
46350: PUSH
46351: EMPTY
46352: LIST
46353: LIST
46354: LIST
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: LIST
46360: LIST
46361: LIST
46362: ST_TO_ADDR
// end ; 2 :
46363: GO 46922
46365: LD_INT 2
46367: DOUBLE
46368: EQUAL
46369: IFTRUE 46373
46371: GO 46502
46373: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46374: LD_ADDR_VAR 0 5
46378: PUSH
46379: LD_VAR 0 1
46383: PUSH
46384: LD_VAR 0 2
46388: PUSH
46389: LD_INT 3
46391: MINUS
46392: PUSH
46393: LD_INT 3
46395: PUSH
46396: EMPTY
46397: LIST
46398: LIST
46399: LIST
46400: PUSH
46401: LD_VAR 0 1
46405: PUSH
46406: LD_INT 4
46408: PLUS
46409: PUSH
46410: LD_VAR 0 2
46414: PUSH
46415: LD_INT 4
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: LIST
46422: PUSH
46423: LD_VAR 0 1
46427: PUSH
46428: LD_VAR 0 2
46432: PUSH
46433: LD_INT 4
46435: PLUS
46436: PUSH
46437: LD_INT 0
46439: PUSH
46440: EMPTY
46441: LIST
46442: LIST
46443: LIST
46444: PUSH
46445: LD_VAR 0 1
46449: PUSH
46450: LD_INT 3
46452: MINUS
46453: PUSH
46454: LD_VAR 0 2
46458: PUSH
46459: LD_INT 1
46461: PUSH
46462: EMPTY
46463: LIST
46464: LIST
46465: LIST
46466: PUSH
46467: LD_VAR 0 1
46471: PUSH
46472: LD_INT 4
46474: MINUS
46475: PUSH
46476: LD_VAR 0 2
46480: PUSH
46481: LD_INT 4
46483: MINUS
46484: PUSH
46485: LD_INT 2
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: LIST
46492: PUSH
46493: EMPTY
46494: LIST
46495: LIST
46496: LIST
46497: LIST
46498: LIST
46499: ST_TO_ADDR
// end ; 3 :
46500: GO 46922
46502: LD_INT 3
46504: DOUBLE
46505: EQUAL
46506: IFTRUE 46510
46508: GO 46643
46510: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46511: LD_ADDR_VAR 0 5
46515: PUSH
46516: LD_VAR 0 1
46520: PUSH
46521: LD_INT 3
46523: PLUS
46524: PUSH
46525: LD_VAR 0 2
46529: PUSH
46530: LD_INT 4
46532: PUSH
46533: EMPTY
46534: LIST
46535: LIST
46536: LIST
46537: PUSH
46538: LD_VAR 0 1
46542: PUSH
46543: LD_INT 4
46545: PLUS
46546: PUSH
46547: LD_VAR 0 2
46551: PUSH
46552: LD_INT 4
46554: PLUS
46555: PUSH
46556: LD_INT 5
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: LIST
46563: PUSH
46564: LD_VAR 0 1
46568: PUSH
46569: LD_INT 4
46571: MINUS
46572: PUSH
46573: LD_VAR 0 2
46577: PUSH
46578: LD_INT 1
46580: PUSH
46581: EMPTY
46582: LIST
46583: LIST
46584: LIST
46585: PUSH
46586: LD_VAR 0 1
46590: PUSH
46591: LD_VAR 0 2
46595: PUSH
46596: LD_INT 4
46598: MINUS
46599: PUSH
46600: LD_INT 3
46602: PUSH
46603: EMPTY
46604: LIST
46605: LIST
46606: LIST
46607: PUSH
46608: LD_VAR 0 1
46612: PUSH
46613: LD_INT 3
46615: MINUS
46616: PUSH
46617: LD_VAR 0 2
46621: PUSH
46622: LD_INT 3
46624: MINUS
46625: PUSH
46626: LD_INT 2
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: LIST
46633: PUSH
46634: EMPTY
46635: LIST
46636: LIST
46637: LIST
46638: LIST
46639: LIST
46640: ST_TO_ADDR
// end ; 4 :
46641: GO 46922
46643: LD_INT 4
46645: DOUBLE
46646: EQUAL
46647: IFTRUE 46651
46649: GO 46784
46651: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
46652: LD_ADDR_VAR 0 5
46656: PUSH
46657: LD_VAR 0 1
46661: PUSH
46662: LD_VAR 0 2
46666: PUSH
46667: LD_INT 4
46669: PLUS
46670: PUSH
46671: LD_INT 0
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: LIST
46678: PUSH
46679: LD_VAR 0 1
46683: PUSH
46684: LD_INT 3
46686: PLUS
46687: PUSH
46688: LD_VAR 0 2
46692: PUSH
46693: LD_INT 3
46695: PLUS
46696: PUSH
46697: LD_INT 5
46699: PUSH
46700: EMPTY
46701: LIST
46702: LIST
46703: LIST
46704: PUSH
46705: LD_VAR 0 1
46709: PUSH
46710: LD_INT 4
46712: PLUS
46713: PUSH
46714: LD_VAR 0 2
46718: PUSH
46719: LD_INT 4
46721: PUSH
46722: EMPTY
46723: LIST
46724: LIST
46725: LIST
46726: PUSH
46727: LD_VAR 0 1
46731: PUSH
46732: LD_VAR 0 2
46736: PUSH
46737: LD_INT 3
46739: MINUS
46740: PUSH
46741: LD_INT 3
46743: PUSH
46744: EMPTY
46745: LIST
46746: LIST
46747: LIST
46748: PUSH
46749: LD_VAR 0 1
46753: PUSH
46754: LD_INT 4
46756: MINUS
46757: PUSH
46758: LD_VAR 0 2
46762: PUSH
46763: LD_INT 4
46765: MINUS
46766: PUSH
46767: LD_INT 2
46769: PUSH
46770: EMPTY
46771: LIST
46772: LIST
46773: LIST
46774: PUSH
46775: EMPTY
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: ST_TO_ADDR
// end ; 5 :
46782: GO 46922
46784: LD_INT 5
46786: DOUBLE
46787: EQUAL
46788: IFTRUE 46792
46790: GO 46921
46792: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46793: LD_ADDR_VAR 0 5
46797: PUSH
46798: LD_VAR 0 1
46802: PUSH
46803: LD_INT 4
46805: MINUS
46806: PUSH
46807: LD_VAR 0 2
46811: PUSH
46812: LD_INT 1
46814: PUSH
46815: EMPTY
46816: LIST
46817: LIST
46818: LIST
46819: PUSH
46820: LD_VAR 0 1
46824: PUSH
46825: LD_VAR 0 2
46829: PUSH
46830: LD_INT 4
46832: MINUS
46833: PUSH
46834: LD_INT 3
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: LIST
46841: PUSH
46842: LD_VAR 0 1
46846: PUSH
46847: LD_INT 4
46849: PLUS
46850: PUSH
46851: LD_VAR 0 2
46855: PUSH
46856: LD_INT 4
46858: PLUS
46859: PUSH
46860: LD_INT 5
46862: PUSH
46863: EMPTY
46864: LIST
46865: LIST
46866: LIST
46867: PUSH
46868: LD_VAR 0 1
46872: PUSH
46873: LD_INT 3
46875: PLUS
46876: PUSH
46877: LD_VAR 0 2
46881: PUSH
46882: LD_INT 4
46884: PUSH
46885: EMPTY
46886: LIST
46887: LIST
46888: LIST
46889: PUSH
46890: LD_VAR 0 1
46894: PUSH
46895: LD_VAR 0 2
46899: PUSH
46900: LD_INT 3
46902: PLUS
46903: PUSH
46904: LD_INT 0
46906: PUSH
46907: EMPTY
46908: LIST
46909: LIST
46910: LIST
46911: PUSH
46912: EMPTY
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: ST_TO_ADDR
// end ; end ;
46919: GO 46922
46921: POP
// result := list ;
46922: LD_ADDR_VAR 0 4
46926: PUSH
46927: LD_VAR 0 5
46931: ST_TO_ADDR
// end ;
46932: LD_VAR 0 4
46936: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46937: LD_INT 0
46939: PPUSH
46940: PPUSH
46941: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46942: LD_VAR 0 1
46946: NOT
46947: PUSH
46948: LD_VAR 0 2
46952: PUSH
46953: LD_INT 1
46955: PUSH
46956: LD_INT 2
46958: PUSH
46959: LD_INT 3
46961: PUSH
46962: LD_INT 4
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: IN
46971: NOT
46972: OR
46973: IFFALSE 46977
// exit ;
46975: GO 47069
// tmp := [ ] ;
46977: LD_ADDR_VAR 0 5
46981: PUSH
46982: EMPTY
46983: ST_TO_ADDR
// for i in units do
46984: LD_ADDR_VAR 0 4
46988: PUSH
46989: LD_VAR 0 1
46993: PUSH
46994: FOR_IN
46995: IFFALSE 47038
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
46997: LD_ADDR_VAR 0 5
47001: PUSH
47002: LD_VAR 0 5
47006: PPUSH
47007: LD_VAR 0 5
47011: PUSH
47012: LD_INT 1
47014: PLUS
47015: PPUSH
47016: LD_VAR 0 4
47020: PPUSH
47021: LD_VAR 0 2
47025: PPUSH
47026: CALL_OW 259
47030: PPUSH
47031: CALL_OW 2
47035: ST_TO_ADDR
47036: GO 46994
47038: POP
47039: POP
// if not tmp then
47040: LD_VAR 0 5
47044: NOT
47045: IFFALSE 47049
// exit ;
47047: GO 47069
// result := SortListByListDesc ( units , tmp ) ;
47049: LD_ADDR_VAR 0 3
47053: PUSH
47054: LD_VAR 0 1
47058: PPUSH
47059: LD_VAR 0 5
47063: PPUSH
47064: CALL_OW 77
47068: ST_TO_ADDR
// end ;
47069: LD_VAR 0 3
47073: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47074: LD_INT 0
47076: PPUSH
47077: PPUSH
47078: PPUSH
// result := false ;
47079: LD_ADDR_VAR 0 3
47083: PUSH
47084: LD_INT 0
47086: ST_TO_ADDR
// x := GetX ( building ) ;
47087: LD_ADDR_VAR 0 4
47091: PUSH
47092: LD_VAR 0 2
47096: PPUSH
47097: CALL_OW 250
47101: ST_TO_ADDR
// y := GetY ( building ) ;
47102: LD_ADDR_VAR 0 5
47106: PUSH
47107: LD_VAR 0 2
47111: PPUSH
47112: CALL_OW 251
47116: ST_TO_ADDR
// if not building or not x or not y then
47117: LD_VAR 0 2
47121: NOT
47122: PUSH
47123: LD_VAR 0 4
47127: NOT
47128: OR
47129: PUSH
47130: LD_VAR 0 5
47134: NOT
47135: OR
47136: IFFALSE 47140
// exit ;
47138: GO 47232
// if GetTaskList ( unit ) then
47140: LD_VAR 0 1
47144: PPUSH
47145: CALL_OW 437
47149: IFFALSE 47232
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47151: LD_STRING e
47153: PUSH
47154: LD_VAR 0 1
47158: PPUSH
47159: CALL_OW 437
47163: PUSH
47164: LD_INT 1
47166: ARRAY
47167: PUSH
47168: LD_INT 1
47170: ARRAY
47171: EQUAL
47172: PUSH
47173: LD_VAR 0 4
47177: PUSH
47178: LD_VAR 0 1
47182: PPUSH
47183: CALL_OW 437
47187: PUSH
47188: LD_INT 1
47190: ARRAY
47191: PUSH
47192: LD_INT 2
47194: ARRAY
47195: EQUAL
47196: AND
47197: PUSH
47198: LD_VAR 0 5
47202: PUSH
47203: LD_VAR 0 1
47207: PPUSH
47208: CALL_OW 437
47212: PUSH
47213: LD_INT 1
47215: ARRAY
47216: PUSH
47217: LD_INT 3
47219: ARRAY
47220: EQUAL
47221: AND
47222: IFFALSE 47232
// result := true end ;
47224: LD_ADDR_VAR 0 3
47228: PUSH
47229: LD_INT 1
47231: ST_TO_ADDR
// end ;
47232: LD_VAR 0 3
47236: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47237: LD_INT 0
47239: PPUSH
// result := false ;
47240: LD_ADDR_VAR 0 4
47244: PUSH
47245: LD_INT 0
47247: ST_TO_ADDR
// if GetTaskList ( unit ) then
47248: LD_VAR 0 1
47252: PPUSH
47253: CALL_OW 437
47257: IFFALSE 47340
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47259: LD_STRING M
47261: PUSH
47262: LD_VAR 0 1
47266: PPUSH
47267: CALL_OW 437
47271: PUSH
47272: LD_INT 1
47274: ARRAY
47275: PUSH
47276: LD_INT 1
47278: ARRAY
47279: EQUAL
47280: PUSH
47281: LD_VAR 0 2
47285: PUSH
47286: LD_VAR 0 1
47290: PPUSH
47291: CALL_OW 437
47295: PUSH
47296: LD_INT 1
47298: ARRAY
47299: PUSH
47300: LD_INT 2
47302: ARRAY
47303: EQUAL
47304: AND
47305: PUSH
47306: LD_VAR 0 3
47310: PUSH
47311: LD_VAR 0 1
47315: PPUSH
47316: CALL_OW 437
47320: PUSH
47321: LD_INT 1
47323: ARRAY
47324: PUSH
47325: LD_INT 3
47327: ARRAY
47328: EQUAL
47329: AND
47330: IFFALSE 47340
// result := true ;
47332: LD_ADDR_VAR 0 4
47336: PUSH
47337: LD_INT 1
47339: ST_TO_ADDR
// end ; end ;
47340: LD_VAR 0 4
47344: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47345: LD_INT 0
47347: PPUSH
47348: PPUSH
47349: PPUSH
47350: PPUSH
// if not unit or not area then
47351: LD_VAR 0 1
47355: NOT
47356: PUSH
47357: LD_VAR 0 2
47361: NOT
47362: OR
47363: IFFALSE 47367
// exit ;
47365: GO 47531
// tmp := AreaToList ( area , i ) ;
47367: LD_ADDR_VAR 0 6
47371: PUSH
47372: LD_VAR 0 2
47376: PPUSH
47377: LD_VAR 0 5
47381: PPUSH
47382: CALL_OW 517
47386: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47387: LD_ADDR_VAR 0 5
47391: PUSH
47392: DOUBLE
47393: LD_INT 1
47395: DEC
47396: ST_TO_ADDR
47397: LD_VAR 0 6
47401: PUSH
47402: LD_INT 1
47404: ARRAY
47405: PUSH
47406: FOR_TO
47407: IFFALSE 47529
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47409: LD_ADDR_VAR 0 7
47413: PUSH
47414: LD_VAR 0 6
47418: PUSH
47419: LD_INT 1
47421: ARRAY
47422: PUSH
47423: LD_VAR 0 5
47427: ARRAY
47428: PUSH
47429: LD_VAR 0 6
47433: PUSH
47434: LD_INT 2
47436: ARRAY
47437: PUSH
47438: LD_VAR 0 5
47442: ARRAY
47443: PUSH
47444: EMPTY
47445: LIST
47446: LIST
47447: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
47448: LD_VAR 0 7
47452: PUSH
47453: LD_INT 1
47455: ARRAY
47456: PPUSH
47457: LD_VAR 0 7
47461: PUSH
47462: LD_INT 2
47464: ARRAY
47465: PPUSH
47466: CALL_OW 428
47470: PUSH
47471: LD_INT 0
47473: EQUAL
47474: IFFALSE 47527
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47476: LD_VAR 0 1
47480: PPUSH
47481: LD_VAR 0 7
47485: PUSH
47486: LD_INT 1
47488: ARRAY
47489: PPUSH
47490: LD_VAR 0 7
47494: PUSH
47495: LD_INT 2
47497: ARRAY
47498: PPUSH
47499: LD_VAR 0 3
47503: PPUSH
47504: CALL_OW 48
// result := IsPlaced ( unit ) ;
47508: LD_ADDR_VAR 0 4
47512: PUSH
47513: LD_VAR 0 1
47517: PPUSH
47518: CALL_OW 305
47522: ST_TO_ADDR
// exit ;
47523: POP
47524: POP
47525: GO 47531
// end ; end ;
47527: GO 47406
47529: POP
47530: POP
// end ;
47531: LD_VAR 0 4
47535: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47536: LD_INT 0
47538: PPUSH
47539: PPUSH
47540: PPUSH
// if not side or side > 8 then
47541: LD_VAR 0 1
47545: NOT
47546: PUSH
47547: LD_VAR 0 1
47551: PUSH
47552: LD_INT 8
47554: GREATER
47555: OR
47556: IFFALSE 47560
// exit ;
47558: GO 47747
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47560: LD_ADDR_VAR 0 4
47564: PUSH
47565: LD_INT 22
47567: PUSH
47568: LD_VAR 0 1
47572: PUSH
47573: EMPTY
47574: LIST
47575: LIST
47576: PUSH
47577: LD_INT 21
47579: PUSH
47580: LD_INT 3
47582: PUSH
47583: EMPTY
47584: LIST
47585: LIST
47586: PUSH
47587: EMPTY
47588: LIST
47589: LIST
47590: PPUSH
47591: CALL_OW 69
47595: ST_TO_ADDR
// if not tmp then
47596: LD_VAR 0 4
47600: NOT
47601: IFFALSE 47605
// exit ;
47603: GO 47747
// enable_addtolog := true ;
47605: LD_ADDR_OWVAR 81
47609: PUSH
47610: LD_INT 1
47612: ST_TO_ADDR
// AddToLog ( [ ) ;
47613: LD_STRING [
47615: PPUSH
47616: CALL_OW 561
// for i in tmp do
47620: LD_ADDR_VAR 0 3
47624: PUSH
47625: LD_VAR 0 4
47629: PUSH
47630: FOR_IN
47631: IFFALSE 47738
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
47633: LD_STRING [
47635: PUSH
47636: LD_VAR 0 3
47640: PPUSH
47641: CALL_OW 266
47645: STR
47646: PUSH
47647: LD_STRING , 
47649: STR
47650: PUSH
47651: LD_VAR 0 3
47655: PPUSH
47656: CALL_OW 250
47660: STR
47661: PUSH
47662: LD_STRING , 
47664: STR
47665: PUSH
47666: LD_VAR 0 3
47670: PPUSH
47671: CALL_OW 251
47675: STR
47676: PUSH
47677: LD_STRING , 
47679: STR
47680: PUSH
47681: LD_VAR 0 3
47685: PPUSH
47686: CALL_OW 254
47690: STR
47691: PUSH
47692: LD_STRING , 
47694: STR
47695: PUSH
47696: LD_VAR 0 3
47700: PPUSH
47701: LD_INT 1
47703: PPUSH
47704: CALL_OW 268
47708: STR
47709: PUSH
47710: LD_STRING , 
47712: STR
47713: PUSH
47714: LD_VAR 0 3
47718: PPUSH
47719: LD_INT 2
47721: PPUSH
47722: CALL_OW 268
47726: STR
47727: PUSH
47728: LD_STRING ],
47730: STR
47731: PPUSH
47732: CALL_OW 561
// end ;
47736: GO 47630
47738: POP
47739: POP
// AddToLog ( ]; ) ;
47740: LD_STRING ];
47742: PPUSH
47743: CALL_OW 561
// end ;
47747: LD_VAR 0 2
47751: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47752: LD_INT 0
47754: PPUSH
47755: PPUSH
47756: PPUSH
47757: PPUSH
47758: PPUSH
// if not area or not rate or not max then
47759: LD_VAR 0 1
47763: NOT
47764: PUSH
47765: LD_VAR 0 2
47769: NOT
47770: OR
47771: PUSH
47772: LD_VAR 0 4
47776: NOT
47777: OR
47778: IFFALSE 47782
// exit ;
47780: GO 47971
// while 1 do
47782: LD_INT 1
47784: IFFALSE 47971
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47786: LD_ADDR_VAR 0 9
47790: PUSH
47791: LD_VAR 0 1
47795: PPUSH
47796: LD_INT 1
47798: PPUSH
47799: CALL_OW 287
47803: PUSH
47804: LD_INT 10
47806: MUL
47807: ST_TO_ADDR
// r := rate / 10 ;
47808: LD_ADDR_VAR 0 7
47812: PUSH
47813: LD_VAR 0 2
47817: PUSH
47818: LD_INT 10
47820: DIVREAL
47821: ST_TO_ADDR
// time := 1 1$00 ;
47822: LD_ADDR_VAR 0 8
47826: PUSH
47827: LD_INT 2100
47829: ST_TO_ADDR
// if amount < min then
47830: LD_VAR 0 9
47834: PUSH
47835: LD_VAR 0 3
47839: LESS
47840: IFFALSE 47858
// r := r * 2 else
47842: LD_ADDR_VAR 0 7
47846: PUSH
47847: LD_VAR 0 7
47851: PUSH
47852: LD_INT 2
47854: MUL
47855: ST_TO_ADDR
47856: GO 47884
// if amount > max then
47858: LD_VAR 0 9
47862: PUSH
47863: LD_VAR 0 4
47867: GREATER
47868: IFFALSE 47884
// r := r / 2 ;
47870: LD_ADDR_VAR 0 7
47874: PUSH
47875: LD_VAR 0 7
47879: PUSH
47880: LD_INT 2
47882: DIVREAL
47883: ST_TO_ADDR
// time := time / r ;
47884: LD_ADDR_VAR 0 8
47888: PUSH
47889: LD_VAR 0 8
47893: PUSH
47894: LD_VAR 0 7
47898: DIVREAL
47899: ST_TO_ADDR
// if time < 0 then
47900: LD_VAR 0 8
47904: PUSH
47905: LD_INT 0
47907: LESS
47908: IFFALSE 47925
// time := time * - 1 ;
47910: LD_ADDR_VAR 0 8
47914: PUSH
47915: LD_VAR 0 8
47919: PUSH
47920: LD_INT 1
47922: NEG
47923: MUL
47924: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47925: LD_VAR 0 8
47929: PUSH
47930: LD_INT 35
47932: PPUSH
47933: LD_INT 875
47935: PPUSH
47936: CALL_OW 12
47940: PLUS
47941: PPUSH
47942: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47946: LD_INT 1
47948: PPUSH
47949: LD_INT 5
47951: PPUSH
47952: CALL_OW 12
47956: PPUSH
47957: LD_VAR 0 1
47961: PPUSH
47962: LD_INT 1
47964: PPUSH
47965: CALL_OW 55
// end ;
47969: GO 47782
// end ;
47971: LD_VAR 0 5
47975: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47976: LD_INT 0
47978: PPUSH
47979: PPUSH
47980: PPUSH
47981: PPUSH
47982: PPUSH
47983: PPUSH
47984: PPUSH
47985: PPUSH
// if not turrets or not factories then
47986: LD_VAR 0 1
47990: NOT
47991: PUSH
47992: LD_VAR 0 2
47996: NOT
47997: OR
47998: IFFALSE 48002
// exit ;
48000: GO 48309
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48002: LD_ADDR_VAR 0 10
48006: PUSH
48007: LD_INT 5
48009: PUSH
48010: LD_INT 6
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 2
48019: PUSH
48020: LD_INT 4
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 3
48029: PUSH
48030: LD_INT 5
48032: PUSH
48033: EMPTY
48034: LIST
48035: LIST
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: LIST
48041: PUSH
48042: LD_INT 24
48044: PUSH
48045: LD_INT 25
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: PUSH
48052: LD_INT 23
48054: PUSH
48055: LD_INT 27
48057: PUSH
48058: EMPTY
48059: LIST
48060: LIST
48061: PUSH
48062: EMPTY
48063: LIST
48064: LIST
48065: PUSH
48066: LD_INT 42
48068: PUSH
48069: LD_INT 43
48071: PUSH
48072: EMPTY
48073: LIST
48074: LIST
48075: PUSH
48076: LD_INT 44
48078: PUSH
48079: LD_INT 46
48081: PUSH
48082: EMPTY
48083: LIST
48084: LIST
48085: PUSH
48086: LD_INT 45
48088: PUSH
48089: LD_INT 47
48091: PUSH
48092: EMPTY
48093: LIST
48094: LIST
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: LIST
48100: PUSH
48101: EMPTY
48102: LIST
48103: LIST
48104: LIST
48105: ST_TO_ADDR
// result := [ ] ;
48106: LD_ADDR_VAR 0 3
48110: PUSH
48111: EMPTY
48112: ST_TO_ADDR
// for i in turrets do
48113: LD_ADDR_VAR 0 4
48117: PUSH
48118: LD_VAR 0 1
48122: PUSH
48123: FOR_IN
48124: IFFALSE 48307
// begin nat := GetNation ( i ) ;
48126: LD_ADDR_VAR 0 7
48130: PUSH
48131: LD_VAR 0 4
48135: PPUSH
48136: CALL_OW 248
48140: ST_TO_ADDR
// weapon := 0 ;
48141: LD_ADDR_VAR 0 8
48145: PUSH
48146: LD_INT 0
48148: ST_TO_ADDR
// if not nat then
48149: LD_VAR 0 7
48153: NOT
48154: IFFALSE 48158
// continue ;
48156: GO 48123
// for j in list [ nat ] do
48158: LD_ADDR_VAR 0 5
48162: PUSH
48163: LD_VAR 0 10
48167: PUSH
48168: LD_VAR 0 7
48172: ARRAY
48173: PUSH
48174: FOR_IN
48175: IFFALSE 48216
// if GetBWeapon ( i ) = j [ 1 ] then
48177: LD_VAR 0 4
48181: PPUSH
48182: CALL_OW 269
48186: PUSH
48187: LD_VAR 0 5
48191: PUSH
48192: LD_INT 1
48194: ARRAY
48195: EQUAL
48196: IFFALSE 48214
// begin weapon := j [ 2 ] ;
48198: LD_ADDR_VAR 0 8
48202: PUSH
48203: LD_VAR 0 5
48207: PUSH
48208: LD_INT 2
48210: ARRAY
48211: ST_TO_ADDR
// break ;
48212: GO 48216
// end ;
48214: GO 48174
48216: POP
48217: POP
// if not weapon then
48218: LD_VAR 0 8
48222: NOT
48223: IFFALSE 48227
// continue ;
48225: GO 48123
// for k in factories do
48227: LD_ADDR_VAR 0 6
48231: PUSH
48232: LD_VAR 0 2
48236: PUSH
48237: FOR_IN
48238: IFFALSE 48303
// begin weapons := AvailableWeaponList ( k ) ;
48240: LD_ADDR_VAR 0 9
48244: PUSH
48245: LD_VAR 0 6
48249: PPUSH
48250: CALL_OW 478
48254: ST_TO_ADDR
// if not weapons then
48255: LD_VAR 0 9
48259: NOT
48260: IFFALSE 48264
// continue ;
48262: GO 48237
// if weapon in weapons then
48264: LD_VAR 0 8
48268: PUSH
48269: LD_VAR 0 9
48273: IN
48274: IFFALSE 48301
// begin result := [ i , weapon ] ;
48276: LD_ADDR_VAR 0 3
48280: PUSH
48281: LD_VAR 0 4
48285: PUSH
48286: LD_VAR 0 8
48290: PUSH
48291: EMPTY
48292: LIST
48293: LIST
48294: ST_TO_ADDR
// exit ;
48295: POP
48296: POP
48297: POP
48298: POP
48299: GO 48309
// end ; end ;
48301: GO 48237
48303: POP
48304: POP
// end ;
48305: GO 48123
48307: POP
48308: POP
// end ;
48309: LD_VAR 0 3
48313: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48314: LD_INT 0
48316: PPUSH
// if not side or side > 8 then
48317: LD_VAR 0 3
48321: NOT
48322: PUSH
48323: LD_VAR 0 3
48327: PUSH
48328: LD_INT 8
48330: GREATER
48331: OR
48332: IFFALSE 48336
// exit ;
48334: GO 48395
// if not range then
48336: LD_VAR 0 4
48340: NOT
48341: IFFALSE 48352
// range := - 12 ;
48343: LD_ADDR_VAR 0 4
48347: PUSH
48348: LD_INT 12
48350: NEG
48351: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48352: LD_VAR 0 1
48356: PPUSH
48357: LD_VAR 0 2
48361: PPUSH
48362: LD_VAR 0 3
48366: PPUSH
48367: LD_VAR 0 4
48371: PPUSH
48372: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48376: LD_VAR 0 1
48380: PPUSH
48381: LD_VAR 0 2
48385: PPUSH
48386: LD_VAR 0 3
48390: PPUSH
48391: CALL_OW 331
// end ;
48395: LD_VAR 0 5
48399: RET
// export function Video ( mode ) ; begin
48400: LD_INT 0
48402: PPUSH
// ingame_video = mode ;
48403: LD_ADDR_OWVAR 52
48407: PUSH
48408: LD_VAR 0 1
48412: ST_TO_ADDR
// interface_hidden = mode ;
48413: LD_ADDR_OWVAR 54
48417: PUSH
48418: LD_VAR 0 1
48422: ST_TO_ADDR
// end ;
48423: LD_VAR 0 2
48427: RET
// export function Join ( array , element ) ; begin
48428: LD_INT 0
48430: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48431: LD_ADDR_VAR 0 3
48435: PUSH
48436: LD_VAR 0 1
48440: PPUSH
48441: LD_VAR 0 1
48445: PUSH
48446: LD_INT 1
48448: PLUS
48449: PPUSH
48450: LD_VAR 0 2
48454: PPUSH
48455: CALL_OW 1
48459: ST_TO_ADDR
// end ;
48460: LD_VAR 0 3
48464: RET
// export function JoinUnion ( array , element ) ; begin
48465: LD_INT 0
48467: PPUSH
// result := array union element ;
48468: LD_ADDR_VAR 0 3
48472: PUSH
48473: LD_VAR 0 1
48477: PUSH
48478: LD_VAR 0 2
48482: UNION
48483: ST_TO_ADDR
// end ;
48484: LD_VAR 0 3
48488: RET
// export function GetBehemoths ( side ) ; begin
48489: LD_INT 0
48491: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48492: LD_ADDR_VAR 0 2
48496: PUSH
48497: LD_INT 22
48499: PUSH
48500: LD_VAR 0 1
48504: PUSH
48505: EMPTY
48506: LIST
48507: LIST
48508: PUSH
48509: LD_INT 31
48511: PUSH
48512: LD_INT 25
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: EMPTY
48520: LIST
48521: LIST
48522: PPUSH
48523: CALL_OW 69
48527: ST_TO_ADDR
// end ;
48528: LD_VAR 0 2
48532: RET
// export function Shuffle ( array ) ; var i , index ; begin
48533: LD_INT 0
48535: PPUSH
48536: PPUSH
48537: PPUSH
// result := [ ] ;
48538: LD_ADDR_VAR 0 2
48542: PUSH
48543: EMPTY
48544: ST_TO_ADDR
// if not array then
48545: LD_VAR 0 1
48549: NOT
48550: IFFALSE 48554
// exit ;
48552: GO 48653
// Randomize ;
48554: CALL_OW 10
// for i = array downto 1 do
48558: LD_ADDR_VAR 0 3
48562: PUSH
48563: DOUBLE
48564: LD_VAR 0 1
48568: INC
48569: ST_TO_ADDR
48570: LD_INT 1
48572: PUSH
48573: FOR_DOWNTO
48574: IFFALSE 48651
// begin index := rand ( 1 , array ) ;
48576: LD_ADDR_VAR 0 4
48580: PUSH
48581: LD_INT 1
48583: PPUSH
48584: LD_VAR 0 1
48588: PPUSH
48589: CALL_OW 12
48593: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48594: LD_ADDR_VAR 0 2
48598: PUSH
48599: LD_VAR 0 2
48603: PPUSH
48604: LD_VAR 0 2
48608: PUSH
48609: LD_INT 1
48611: PLUS
48612: PPUSH
48613: LD_VAR 0 1
48617: PUSH
48618: LD_VAR 0 4
48622: ARRAY
48623: PPUSH
48624: CALL_OW 2
48628: ST_TO_ADDR
// array := Delete ( array , index ) ;
48629: LD_ADDR_VAR 0 1
48633: PUSH
48634: LD_VAR 0 1
48638: PPUSH
48639: LD_VAR 0 4
48643: PPUSH
48644: CALL_OW 3
48648: ST_TO_ADDR
// end ;
48649: GO 48573
48651: POP
48652: POP
// end ;
48653: LD_VAR 0 2
48657: RET
// export function GetBaseMaterials ( base ) ; begin
48658: LD_INT 0
48660: PPUSH
// result := [ 0 , 0 , 0 ] ;
48661: LD_ADDR_VAR 0 2
48665: PUSH
48666: LD_INT 0
48668: PUSH
48669: LD_INT 0
48671: PUSH
48672: LD_INT 0
48674: PUSH
48675: EMPTY
48676: LIST
48677: LIST
48678: LIST
48679: ST_TO_ADDR
// if not base then
48680: LD_VAR 0 1
48684: NOT
48685: IFFALSE 48689
// exit ;
48687: GO 48738
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48689: LD_ADDR_VAR 0 2
48693: PUSH
48694: LD_VAR 0 1
48698: PPUSH
48699: LD_INT 1
48701: PPUSH
48702: CALL_OW 275
48706: PUSH
48707: LD_VAR 0 1
48711: PPUSH
48712: LD_INT 2
48714: PPUSH
48715: CALL_OW 275
48719: PUSH
48720: LD_VAR 0 1
48724: PPUSH
48725: LD_INT 3
48727: PPUSH
48728: CALL_OW 275
48732: PUSH
48733: EMPTY
48734: LIST
48735: LIST
48736: LIST
48737: ST_TO_ADDR
// end ;
48738: LD_VAR 0 2
48742: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48743: LD_INT 0
48745: PPUSH
48746: PPUSH
// result := array ;
48747: LD_ADDR_VAR 0 3
48751: PUSH
48752: LD_VAR 0 1
48756: ST_TO_ADDR
// if size >= result then
48757: LD_VAR 0 2
48761: PUSH
48762: LD_VAR 0 3
48766: GREATEREQUAL
48767: IFFALSE 48771
// exit ;
48769: GO 48821
// if size then
48771: LD_VAR 0 2
48775: IFFALSE 48821
// for i := array downto size do
48777: LD_ADDR_VAR 0 4
48781: PUSH
48782: DOUBLE
48783: LD_VAR 0 1
48787: INC
48788: ST_TO_ADDR
48789: LD_VAR 0 2
48793: PUSH
48794: FOR_DOWNTO
48795: IFFALSE 48819
// result := Delete ( result , result ) ;
48797: LD_ADDR_VAR 0 3
48801: PUSH
48802: LD_VAR 0 3
48806: PPUSH
48807: LD_VAR 0 3
48811: PPUSH
48812: CALL_OW 3
48816: ST_TO_ADDR
48817: GO 48794
48819: POP
48820: POP
// end ;
48821: LD_VAR 0 3
48825: RET
// export function ComExit ( unit ) ; var tmp ; begin
48826: LD_INT 0
48828: PPUSH
48829: PPUSH
// if not IsInUnit ( unit ) then
48830: LD_VAR 0 1
48834: PPUSH
48835: CALL_OW 310
48839: NOT
48840: IFFALSE 48844
// exit ;
48842: GO 48904
// tmp := IsInUnit ( unit ) ;
48844: LD_ADDR_VAR 0 3
48848: PUSH
48849: LD_VAR 0 1
48853: PPUSH
48854: CALL_OW 310
48858: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48859: LD_VAR 0 3
48863: PPUSH
48864: CALL_OW 247
48868: PUSH
48869: LD_INT 2
48871: EQUAL
48872: IFFALSE 48885
// ComExitVehicle ( unit ) else
48874: LD_VAR 0 1
48878: PPUSH
48879: CALL_OW 121
48883: GO 48894
// ComExitBuilding ( unit ) ;
48885: LD_VAR 0 1
48889: PPUSH
48890: CALL_OW 122
// result := tmp ;
48894: LD_ADDR_VAR 0 2
48898: PUSH
48899: LD_VAR 0 3
48903: ST_TO_ADDR
// end ;
48904: LD_VAR 0 2
48908: RET
// export function ComExitAll ( units ) ; var i ; begin
48909: LD_INT 0
48911: PPUSH
48912: PPUSH
// if not units then
48913: LD_VAR 0 1
48917: NOT
48918: IFFALSE 48922
// exit ;
48920: GO 48948
// for i in units do
48922: LD_ADDR_VAR 0 3
48926: PUSH
48927: LD_VAR 0 1
48931: PUSH
48932: FOR_IN
48933: IFFALSE 48946
// ComExit ( i ) ;
48935: LD_VAR 0 3
48939: PPUSH
48940: CALL 48826 0 1
48944: GO 48932
48946: POP
48947: POP
// end ;
48948: LD_VAR 0 2
48952: RET
// export function ResetHc ; begin
48953: LD_INT 0
48955: PPUSH
// InitHc ;
48956: CALL_OW 19
// hc_importance := 0 ;
48960: LD_ADDR_OWVAR 32
48964: PUSH
48965: LD_INT 0
48967: ST_TO_ADDR
// end ;
48968: LD_VAR 0 1
48972: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48973: LD_INT 0
48975: PPUSH
48976: PPUSH
48977: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48978: LD_ADDR_VAR 0 6
48982: PUSH
48983: LD_VAR 0 1
48987: PUSH
48988: LD_VAR 0 3
48992: PLUS
48993: PUSH
48994: LD_INT 2
48996: DIV
48997: ST_TO_ADDR
// if _x < 0 then
48998: LD_VAR 0 6
49002: PUSH
49003: LD_INT 0
49005: LESS
49006: IFFALSE 49023
// _x := _x * - 1 ;
49008: LD_ADDR_VAR 0 6
49012: PUSH
49013: LD_VAR 0 6
49017: PUSH
49018: LD_INT 1
49020: NEG
49021: MUL
49022: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49023: LD_ADDR_VAR 0 7
49027: PUSH
49028: LD_VAR 0 2
49032: PUSH
49033: LD_VAR 0 4
49037: PLUS
49038: PUSH
49039: LD_INT 2
49041: DIV
49042: ST_TO_ADDR
// if _y < 0 then
49043: LD_VAR 0 7
49047: PUSH
49048: LD_INT 0
49050: LESS
49051: IFFALSE 49068
// _y := _y * - 1 ;
49053: LD_ADDR_VAR 0 7
49057: PUSH
49058: LD_VAR 0 7
49062: PUSH
49063: LD_INT 1
49065: NEG
49066: MUL
49067: ST_TO_ADDR
// result := [ _x , _y ] ;
49068: LD_ADDR_VAR 0 5
49072: PUSH
49073: LD_VAR 0 6
49077: PUSH
49078: LD_VAR 0 7
49082: PUSH
49083: EMPTY
49084: LIST
49085: LIST
49086: ST_TO_ADDR
// end ;
49087: LD_VAR 0 5
49091: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49092: LD_INT 0
49094: PPUSH
49095: PPUSH
49096: PPUSH
49097: PPUSH
// task := GetTaskList ( unit ) ;
49098: LD_ADDR_VAR 0 7
49102: PUSH
49103: LD_VAR 0 1
49107: PPUSH
49108: CALL_OW 437
49112: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49113: LD_VAR 0 7
49117: NOT
49118: PUSH
49119: LD_VAR 0 1
49123: PPUSH
49124: LD_VAR 0 2
49128: PPUSH
49129: CALL_OW 308
49133: NOT
49134: AND
49135: IFFALSE 49139
// exit ;
49137: GO 49257
// if IsInArea ( unit , area ) then
49139: LD_VAR 0 1
49143: PPUSH
49144: LD_VAR 0 2
49148: PPUSH
49149: CALL_OW 308
49153: IFFALSE 49171
// begin ComMoveToArea ( unit , goAway ) ;
49155: LD_VAR 0 1
49159: PPUSH
49160: LD_VAR 0 3
49164: PPUSH
49165: CALL_OW 113
// exit ;
49169: GO 49257
// end ; if task [ 1 ] [ 1 ] <> M then
49171: LD_VAR 0 7
49175: PUSH
49176: LD_INT 1
49178: ARRAY
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: PUSH
49184: LD_STRING M
49186: NONEQUAL
49187: IFFALSE 49191
// exit ;
49189: GO 49257
// x := task [ 1 ] [ 2 ] ;
49191: LD_ADDR_VAR 0 5
49195: PUSH
49196: LD_VAR 0 7
49200: PUSH
49201: LD_INT 1
49203: ARRAY
49204: PUSH
49205: LD_INT 2
49207: ARRAY
49208: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49209: LD_ADDR_VAR 0 6
49213: PUSH
49214: LD_VAR 0 7
49218: PUSH
49219: LD_INT 1
49221: ARRAY
49222: PUSH
49223: LD_INT 3
49225: ARRAY
49226: ST_TO_ADDR
// if InArea ( x , y , area ) then
49227: LD_VAR 0 5
49231: PPUSH
49232: LD_VAR 0 6
49236: PPUSH
49237: LD_VAR 0 2
49241: PPUSH
49242: CALL_OW 309
49246: IFFALSE 49257
// ComStop ( unit ) ;
49248: LD_VAR 0 1
49252: PPUSH
49253: CALL_OW 141
// end ;
49257: LD_VAR 0 4
49261: RET
// export function Abs ( value ) ; begin
49262: LD_INT 0
49264: PPUSH
// result := value ;
49265: LD_ADDR_VAR 0 2
49269: PUSH
49270: LD_VAR 0 1
49274: ST_TO_ADDR
// if value < 0 then
49275: LD_VAR 0 1
49279: PUSH
49280: LD_INT 0
49282: LESS
49283: IFFALSE 49300
// result := value * - 1 ;
49285: LD_ADDR_VAR 0 2
49289: PUSH
49290: LD_VAR 0 1
49294: PUSH
49295: LD_INT 1
49297: NEG
49298: MUL
49299: ST_TO_ADDR
// end ;
49300: LD_VAR 0 2
49304: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49305: LD_INT 0
49307: PPUSH
49308: PPUSH
49309: PPUSH
49310: PPUSH
49311: PPUSH
49312: PPUSH
49313: PPUSH
49314: PPUSH
// if not unit or not building then
49315: LD_VAR 0 1
49319: NOT
49320: PUSH
49321: LD_VAR 0 2
49325: NOT
49326: OR
49327: IFFALSE 49331
// exit ;
49329: GO 49557
// x := GetX ( building ) ;
49331: LD_ADDR_VAR 0 4
49335: PUSH
49336: LD_VAR 0 2
49340: PPUSH
49341: CALL_OW 250
49345: ST_TO_ADDR
// y := GetY ( building ) ;
49346: LD_ADDR_VAR 0 6
49350: PUSH
49351: LD_VAR 0 2
49355: PPUSH
49356: CALL_OW 251
49360: ST_TO_ADDR
// d := GetDir ( building ) ;
49361: LD_ADDR_VAR 0 8
49365: PUSH
49366: LD_VAR 0 2
49370: PPUSH
49371: CALL_OW 254
49375: ST_TO_ADDR
// r := 4 ;
49376: LD_ADDR_VAR 0 9
49380: PUSH
49381: LD_INT 4
49383: ST_TO_ADDR
// for i := 1 to 5 do
49384: LD_ADDR_VAR 0 10
49388: PUSH
49389: DOUBLE
49390: LD_INT 1
49392: DEC
49393: ST_TO_ADDR
49394: LD_INT 5
49396: PUSH
49397: FOR_TO
49398: IFFALSE 49555
// begin _x := ShiftX ( x , d , r + i ) ;
49400: LD_ADDR_VAR 0 5
49404: PUSH
49405: LD_VAR 0 4
49409: PPUSH
49410: LD_VAR 0 8
49414: PPUSH
49415: LD_VAR 0 9
49419: PUSH
49420: LD_VAR 0 10
49424: PLUS
49425: PPUSH
49426: CALL_OW 272
49430: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49431: LD_ADDR_VAR 0 7
49435: PUSH
49436: LD_VAR 0 6
49440: PPUSH
49441: LD_VAR 0 8
49445: PPUSH
49446: LD_VAR 0 9
49450: PUSH
49451: LD_VAR 0 10
49455: PLUS
49456: PPUSH
49457: CALL_OW 273
49461: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49462: LD_VAR 0 5
49466: PPUSH
49467: LD_VAR 0 7
49471: PPUSH
49472: CALL_OW 488
49476: PUSH
49477: LD_VAR 0 5
49481: PPUSH
49482: LD_VAR 0 7
49486: PPUSH
49487: CALL_OW 428
49491: PPUSH
49492: CALL_OW 247
49496: PUSH
49497: LD_INT 3
49499: PUSH
49500: LD_INT 2
49502: PUSH
49503: EMPTY
49504: LIST
49505: LIST
49506: IN
49507: NOT
49508: AND
49509: IFFALSE 49553
// begin ComMoveXY ( unit , _x , _y ) ;
49511: LD_VAR 0 1
49515: PPUSH
49516: LD_VAR 0 5
49520: PPUSH
49521: LD_VAR 0 7
49525: PPUSH
49526: CALL_OW 111
// result := [ _x , _y ] ;
49530: LD_ADDR_VAR 0 3
49534: PUSH
49535: LD_VAR 0 5
49539: PUSH
49540: LD_VAR 0 7
49544: PUSH
49545: EMPTY
49546: LIST
49547: LIST
49548: ST_TO_ADDR
// exit ;
49549: POP
49550: POP
49551: GO 49557
// end ; end ;
49553: GO 49397
49555: POP
49556: POP
// end ;
49557: LD_VAR 0 3
49561: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49562: LD_INT 0
49564: PPUSH
49565: PPUSH
49566: PPUSH
// result := 0 ;
49567: LD_ADDR_VAR 0 3
49571: PUSH
49572: LD_INT 0
49574: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49575: LD_VAR 0 1
49579: PUSH
49580: LD_INT 0
49582: LESS
49583: PUSH
49584: LD_VAR 0 1
49588: PUSH
49589: LD_INT 8
49591: GREATER
49592: OR
49593: PUSH
49594: LD_VAR 0 2
49598: PUSH
49599: LD_INT 0
49601: LESS
49602: OR
49603: PUSH
49604: LD_VAR 0 2
49608: PUSH
49609: LD_INT 8
49611: GREATER
49612: OR
49613: IFFALSE 49617
// exit ;
49615: GO 49692
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49617: LD_ADDR_VAR 0 4
49621: PUSH
49622: LD_INT 22
49624: PUSH
49625: LD_VAR 0 2
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: PPUSH
49634: CALL_OW 69
49638: PUSH
49639: FOR_IN
49640: IFFALSE 49690
// begin un := UnitShoot ( i ) ;
49642: LD_ADDR_VAR 0 5
49646: PUSH
49647: LD_VAR 0 4
49651: PPUSH
49652: CALL_OW 504
49656: ST_TO_ADDR
// if GetSide ( un ) = side1 then
49657: LD_VAR 0 5
49661: PPUSH
49662: CALL_OW 255
49666: PUSH
49667: LD_VAR 0 1
49671: EQUAL
49672: IFFALSE 49688
// begin result := un ;
49674: LD_ADDR_VAR 0 3
49678: PUSH
49679: LD_VAR 0 5
49683: ST_TO_ADDR
// exit ;
49684: POP
49685: POP
49686: GO 49692
// end ; end ;
49688: GO 49639
49690: POP
49691: POP
// end ;
49692: LD_VAR 0 3
49696: RET
// export function GetCargoBay ( units ) ; begin
49697: LD_INT 0
49699: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49700: LD_ADDR_VAR 0 2
49704: PUSH
49705: LD_VAR 0 1
49709: PPUSH
49710: LD_INT 2
49712: PUSH
49713: LD_INT 34
49715: PUSH
49716: LD_INT 12
49718: PUSH
49719: EMPTY
49720: LIST
49721: LIST
49722: PUSH
49723: LD_INT 34
49725: PUSH
49726: LD_INT 51
49728: PUSH
49729: EMPTY
49730: LIST
49731: LIST
49732: PUSH
49733: LD_INT 34
49735: PUSH
49736: LD_INT 32
49738: PUSH
49739: EMPTY
49740: LIST
49741: LIST
49742: PUSH
49743: LD_INT 34
49745: PUSH
49746: LD_EXP 68
49750: PUSH
49751: EMPTY
49752: LIST
49753: LIST
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: PPUSH
49762: CALL_OW 72
49766: ST_TO_ADDR
// end ;
49767: LD_VAR 0 2
49771: RET
// export function Negate ( value ) ; begin
49772: LD_INT 0
49774: PPUSH
// result := not value ;
49775: LD_ADDR_VAR 0 2
49779: PUSH
49780: LD_VAR 0 1
49784: NOT
49785: ST_TO_ADDR
// end ;
49786: LD_VAR 0 2
49790: RET
// export function Inc ( value ) ; begin
49791: LD_INT 0
49793: PPUSH
// result := value + 1 ;
49794: LD_ADDR_VAR 0 2
49798: PUSH
49799: LD_VAR 0 1
49803: PUSH
49804: LD_INT 1
49806: PLUS
49807: ST_TO_ADDR
// end ;
49808: LD_VAR 0 2
49812: RET
// export function Dec ( value ) ; begin
49813: LD_INT 0
49815: PPUSH
// result := value - 1 ;
49816: LD_ADDR_VAR 0 2
49820: PUSH
49821: LD_VAR 0 1
49825: PUSH
49826: LD_INT 1
49828: MINUS
49829: ST_TO_ADDR
// end ;
49830: LD_VAR 0 2
49834: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49835: LD_INT 0
49837: PPUSH
49838: PPUSH
49839: PPUSH
49840: PPUSH
49841: PPUSH
49842: PPUSH
49843: PPUSH
49844: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49845: LD_VAR 0 1
49849: PPUSH
49850: LD_VAR 0 2
49854: PPUSH
49855: CALL_OW 488
49859: NOT
49860: PUSH
49861: LD_VAR 0 3
49865: PPUSH
49866: LD_VAR 0 4
49870: PPUSH
49871: CALL_OW 488
49875: NOT
49876: OR
49877: IFFALSE 49890
// begin result := - 1 ;
49879: LD_ADDR_VAR 0 5
49883: PUSH
49884: LD_INT 1
49886: NEG
49887: ST_TO_ADDR
// exit ;
49888: GO 50125
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49890: LD_ADDR_VAR 0 12
49894: PUSH
49895: LD_VAR 0 1
49899: PPUSH
49900: LD_VAR 0 2
49904: PPUSH
49905: LD_VAR 0 3
49909: PPUSH
49910: LD_VAR 0 4
49914: PPUSH
49915: CALL 48973 0 4
49919: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49920: LD_ADDR_VAR 0 11
49924: PUSH
49925: LD_VAR 0 1
49929: PPUSH
49930: LD_VAR 0 2
49934: PPUSH
49935: LD_VAR 0 12
49939: PUSH
49940: LD_INT 1
49942: ARRAY
49943: PPUSH
49944: LD_VAR 0 12
49948: PUSH
49949: LD_INT 2
49951: ARRAY
49952: PPUSH
49953: CALL_OW 298
49957: ST_TO_ADDR
// distance := 9999 ;
49958: LD_ADDR_VAR 0 10
49962: PUSH
49963: LD_INT 9999
49965: ST_TO_ADDR
// for i := 0 to 5 do
49966: LD_ADDR_VAR 0 6
49970: PUSH
49971: DOUBLE
49972: LD_INT 0
49974: DEC
49975: ST_TO_ADDR
49976: LD_INT 5
49978: PUSH
49979: FOR_TO
49980: IFFALSE 50123
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49982: LD_ADDR_VAR 0 7
49986: PUSH
49987: LD_VAR 0 1
49991: PPUSH
49992: LD_VAR 0 6
49996: PPUSH
49997: LD_VAR 0 11
50001: PPUSH
50002: CALL_OW 272
50006: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50007: LD_ADDR_VAR 0 8
50011: PUSH
50012: LD_VAR 0 2
50016: PPUSH
50017: LD_VAR 0 6
50021: PPUSH
50022: LD_VAR 0 11
50026: PPUSH
50027: CALL_OW 273
50031: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50032: LD_VAR 0 7
50036: PPUSH
50037: LD_VAR 0 8
50041: PPUSH
50042: CALL_OW 488
50046: NOT
50047: IFFALSE 50051
// continue ;
50049: GO 49979
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50051: LD_ADDR_VAR 0 9
50055: PUSH
50056: LD_VAR 0 12
50060: PUSH
50061: LD_INT 1
50063: ARRAY
50064: PPUSH
50065: LD_VAR 0 12
50069: PUSH
50070: LD_INT 2
50072: ARRAY
50073: PPUSH
50074: LD_VAR 0 7
50078: PPUSH
50079: LD_VAR 0 8
50083: PPUSH
50084: CALL_OW 298
50088: ST_TO_ADDR
// if tmp < distance then
50089: LD_VAR 0 9
50093: PUSH
50094: LD_VAR 0 10
50098: LESS
50099: IFFALSE 50121
// begin result := i ;
50101: LD_ADDR_VAR 0 5
50105: PUSH
50106: LD_VAR 0 6
50110: ST_TO_ADDR
// distance := tmp ;
50111: LD_ADDR_VAR 0 10
50115: PUSH
50116: LD_VAR 0 9
50120: ST_TO_ADDR
// end ; end ;
50121: GO 49979
50123: POP
50124: POP
// end ;
50125: LD_VAR 0 5
50129: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50130: LD_INT 0
50132: PPUSH
50133: PPUSH
// if not driver or not IsInUnit ( driver ) then
50134: LD_VAR 0 1
50138: NOT
50139: PUSH
50140: LD_VAR 0 1
50144: PPUSH
50145: CALL_OW 310
50149: NOT
50150: OR
50151: IFFALSE 50155
// exit ;
50153: GO 50245
// vehicle := IsInUnit ( driver ) ;
50155: LD_ADDR_VAR 0 3
50159: PUSH
50160: LD_VAR 0 1
50164: PPUSH
50165: CALL_OW 310
50169: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50170: LD_VAR 0 1
50174: PPUSH
50175: LD_STRING \
50177: PUSH
50178: LD_INT 0
50180: PUSH
50181: LD_INT 0
50183: PUSH
50184: LD_INT 0
50186: PUSH
50187: LD_INT 0
50189: PUSH
50190: LD_INT 0
50192: PUSH
50193: LD_INT 0
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: LIST
50200: LIST
50201: LIST
50202: LIST
50203: LIST
50204: PUSH
50205: LD_STRING E
50207: PUSH
50208: LD_INT 0
50210: PUSH
50211: LD_INT 0
50213: PUSH
50214: LD_VAR 0 3
50218: PUSH
50219: LD_INT 0
50221: PUSH
50222: LD_INT 0
50224: PUSH
50225: LD_INT 0
50227: PUSH
50228: EMPTY
50229: LIST
50230: LIST
50231: LIST
50232: LIST
50233: LIST
50234: LIST
50235: LIST
50236: PUSH
50237: EMPTY
50238: LIST
50239: LIST
50240: PPUSH
50241: CALL_OW 446
// end ;
50245: LD_VAR 0 2
50249: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50250: LD_INT 0
50252: PPUSH
50253: PPUSH
// if not driver or not IsInUnit ( driver ) then
50254: LD_VAR 0 1
50258: NOT
50259: PUSH
50260: LD_VAR 0 1
50264: PPUSH
50265: CALL_OW 310
50269: NOT
50270: OR
50271: IFFALSE 50275
// exit ;
50273: GO 50365
// vehicle := IsInUnit ( driver ) ;
50275: LD_ADDR_VAR 0 3
50279: PUSH
50280: LD_VAR 0 1
50284: PPUSH
50285: CALL_OW 310
50289: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50290: LD_VAR 0 1
50294: PPUSH
50295: LD_STRING \
50297: PUSH
50298: LD_INT 0
50300: PUSH
50301: LD_INT 0
50303: PUSH
50304: LD_INT 0
50306: PUSH
50307: LD_INT 0
50309: PUSH
50310: LD_INT 0
50312: PUSH
50313: LD_INT 0
50315: PUSH
50316: EMPTY
50317: LIST
50318: LIST
50319: LIST
50320: LIST
50321: LIST
50322: LIST
50323: LIST
50324: PUSH
50325: LD_STRING E
50327: PUSH
50328: LD_INT 0
50330: PUSH
50331: LD_INT 0
50333: PUSH
50334: LD_VAR 0 3
50338: PUSH
50339: LD_INT 0
50341: PUSH
50342: LD_INT 0
50344: PUSH
50345: LD_INT 0
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: LIST
50352: LIST
50353: LIST
50354: LIST
50355: LIST
50356: PUSH
50357: EMPTY
50358: LIST
50359: LIST
50360: PPUSH
50361: CALL_OW 447
// end ;
50365: LD_VAR 0 2
50369: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50370: LD_INT 0
50372: PPUSH
50373: PPUSH
50374: PPUSH
// tmp := [ ] ;
50375: LD_ADDR_VAR 0 5
50379: PUSH
50380: EMPTY
50381: ST_TO_ADDR
// for i in units do
50382: LD_ADDR_VAR 0 4
50386: PUSH
50387: LD_VAR 0 1
50391: PUSH
50392: FOR_IN
50393: IFFALSE 50431
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50395: LD_ADDR_VAR 0 5
50399: PUSH
50400: LD_VAR 0 5
50404: PPUSH
50405: LD_VAR 0 5
50409: PUSH
50410: LD_INT 1
50412: PLUS
50413: PPUSH
50414: LD_VAR 0 4
50418: PPUSH
50419: CALL_OW 256
50423: PPUSH
50424: CALL_OW 2
50428: ST_TO_ADDR
50429: GO 50392
50431: POP
50432: POP
// if not tmp then
50433: LD_VAR 0 5
50437: NOT
50438: IFFALSE 50442
// exit ;
50440: GO 50490
// if asc then
50442: LD_VAR 0 2
50446: IFFALSE 50470
// result := SortListByListAsc ( units , tmp ) else
50448: LD_ADDR_VAR 0 3
50452: PUSH
50453: LD_VAR 0 1
50457: PPUSH
50458: LD_VAR 0 5
50462: PPUSH
50463: CALL_OW 76
50467: ST_TO_ADDR
50468: GO 50490
// result := SortListByListDesc ( units , tmp ) ;
50470: LD_ADDR_VAR 0 3
50474: PUSH
50475: LD_VAR 0 1
50479: PPUSH
50480: LD_VAR 0 5
50484: PPUSH
50485: CALL_OW 77
50489: ST_TO_ADDR
// end ;
50490: LD_VAR 0 3
50494: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50495: LD_INT 0
50497: PPUSH
50498: PPUSH
// task := GetTaskList ( mech ) ;
50499: LD_ADDR_VAR 0 4
50503: PUSH
50504: LD_VAR 0 1
50508: PPUSH
50509: CALL_OW 437
50513: ST_TO_ADDR
// if not task then
50514: LD_VAR 0 4
50518: NOT
50519: IFFALSE 50523
// exit ;
50521: GO 50565
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50523: LD_ADDR_VAR 0 3
50527: PUSH
50528: LD_VAR 0 4
50532: PUSH
50533: LD_INT 1
50535: ARRAY
50536: PUSH
50537: LD_INT 1
50539: ARRAY
50540: PUSH
50541: LD_STRING r
50543: EQUAL
50544: PUSH
50545: LD_VAR 0 4
50549: PUSH
50550: LD_INT 1
50552: ARRAY
50553: PUSH
50554: LD_INT 4
50556: ARRAY
50557: PUSH
50558: LD_VAR 0 2
50562: EQUAL
50563: AND
50564: ST_TO_ADDR
// end ;
50565: LD_VAR 0 3
50569: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50570: LD_INT 0
50572: PPUSH
// SetDir ( unit , d ) ;
50573: LD_VAR 0 1
50577: PPUSH
50578: LD_VAR 0 4
50582: PPUSH
50583: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50587: LD_VAR 0 1
50591: PPUSH
50592: LD_VAR 0 2
50596: PPUSH
50597: LD_VAR 0 3
50601: PPUSH
50602: LD_VAR 0 5
50606: PPUSH
50607: CALL_OW 48
// end ;
50611: LD_VAR 0 6
50615: RET
// export function ToNaturalNumber ( number ) ; begin
50616: LD_INT 0
50618: PPUSH
// result := number div 1 ;
50619: LD_ADDR_VAR 0 2
50623: PUSH
50624: LD_VAR 0 1
50628: PUSH
50629: LD_INT 1
50631: DIV
50632: ST_TO_ADDR
// if number < 0 then
50633: LD_VAR 0 1
50637: PUSH
50638: LD_INT 0
50640: LESS
50641: IFFALSE 50651
// result := 0 ;
50643: LD_ADDR_VAR 0 2
50647: PUSH
50648: LD_INT 0
50650: ST_TO_ADDR
// end ;
50651: LD_VAR 0 2
50655: RET
// export function SortByClass ( units , class ) ; var un ; begin
50656: LD_INT 0
50658: PPUSH
50659: PPUSH
// if not units or not class then
50660: LD_VAR 0 1
50664: NOT
50665: PUSH
50666: LD_VAR 0 2
50670: NOT
50671: OR
50672: IFFALSE 50676
// exit ;
50674: GO 50771
// result := [ ] ;
50676: LD_ADDR_VAR 0 3
50680: PUSH
50681: EMPTY
50682: ST_TO_ADDR
// for un in units do
50683: LD_ADDR_VAR 0 4
50687: PUSH
50688: LD_VAR 0 1
50692: PUSH
50693: FOR_IN
50694: IFFALSE 50769
// if GetClass ( un ) = class then
50696: LD_VAR 0 4
50700: PPUSH
50701: CALL_OW 257
50705: PUSH
50706: LD_VAR 0 2
50710: EQUAL
50711: IFFALSE 50738
// result := Insert ( result , 1 , un ) else
50713: LD_ADDR_VAR 0 3
50717: PUSH
50718: LD_VAR 0 3
50722: PPUSH
50723: LD_INT 1
50725: PPUSH
50726: LD_VAR 0 4
50730: PPUSH
50731: CALL_OW 2
50735: ST_TO_ADDR
50736: GO 50767
// result := Replace ( result , result + 1 , un ) ;
50738: LD_ADDR_VAR 0 3
50742: PUSH
50743: LD_VAR 0 3
50747: PPUSH
50748: LD_VAR 0 3
50752: PUSH
50753: LD_INT 1
50755: PLUS
50756: PPUSH
50757: LD_VAR 0 4
50761: PPUSH
50762: CALL_OW 1
50766: ST_TO_ADDR
50767: GO 50693
50769: POP
50770: POP
// end ;
50771: LD_VAR 0 3
50775: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50776: LD_INT 0
50778: PPUSH
50779: PPUSH
50780: PPUSH
50781: PPUSH
50782: PPUSH
50783: PPUSH
50784: PPUSH
// result := [ ] ;
50785: LD_ADDR_VAR 0 4
50789: PUSH
50790: EMPTY
50791: ST_TO_ADDR
// if x - r < 0 then
50792: LD_VAR 0 1
50796: PUSH
50797: LD_VAR 0 3
50801: MINUS
50802: PUSH
50803: LD_INT 0
50805: LESS
50806: IFFALSE 50818
// min_x := 0 else
50808: LD_ADDR_VAR 0 8
50812: PUSH
50813: LD_INT 0
50815: ST_TO_ADDR
50816: GO 50834
// min_x := x - r ;
50818: LD_ADDR_VAR 0 8
50822: PUSH
50823: LD_VAR 0 1
50827: PUSH
50828: LD_VAR 0 3
50832: MINUS
50833: ST_TO_ADDR
// if y - r < 0 then
50834: LD_VAR 0 2
50838: PUSH
50839: LD_VAR 0 3
50843: MINUS
50844: PUSH
50845: LD_INT 0
50847: LESS
50848: IFFALSE 50860
// min_y := 0 else
50850: LD_ADDR_VAR 0 7
50854: PUSH
50855: LD_INT 0
50857: ST_TO_ADDR
50858: GO 50876
// min_y := y - r ;
50860: LD_ADDR_VAR 0 7
50864: PUSH
50865: LD_VAR 0 2
50869: PUSH
50870: LD_VAR 0 3
50874: MINUS
50875: ST_TO_ADDR
// max_x := x + r ;
50876: LD_ADDR_VAR 0 9
50880: PUSH
50881: LD_VAR 0 1
50885: PUSH
50886: LD_VAR 0 3
50890: PLUS
50891: ST_TO_ADDR
// max_y := y + r ;
50892: LD_ADDR_VAR 0 10
50896: PUSH
50897: LD_VAR 0 2
50901: PUSH
50902: LD_VAR 0 3
50906: PLUS
50907: ST_TO_ADDR
// for _x = min_x to max_x do
50908: LD_ADDR_VAR 0 5
50912: PUSH
50913: DOUBLE
50914: LD_VAR 0 8
50918: DEC
50919: ST_TO_ADDR
50920: LD_VAR 0 9
50924: PUSH
50925: FOR_TO
50926: IFFALSE 51027
// for _y = min_y to max_y do
50928: LD_ADDR_VAR 0 6
50932: PUSH
50933: DOUBLE
50934: LD_VAR 0 7
50938: DEC
50939: ST_TO_ADDR
50940: LD_VAR 0 10
50944: PUSH
50945: FOR_TO
50946: IFFALSE 51023
// begin if not ValidHex ( _x , _y ) then
50948: LD_VAR 0 5
50952: PPUSH
50953: LD_VAR 0 6
50957: PPUSH
50958: CALL_OW 488
50962: NOT
50963: IFFALSE 50967
// continue ;
50965: GO 50945
// if GetResourceTypeXY ( _x , _y ) then
50967: LD_VAR 0 5
50971: PPUSH
50972: LD_VAR 0 6
50976: PPUSH
50977: CALL_OW 283
50981: IFFALSE 51021
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50983: LD_ADDR_VAR 0 4
50987: PUSH
50988: LD_VAR 0 4
50992: PPUSH
50993: LD_VAR 0 4
50997: PUSH
50998: LD_INT 1
51000: PLUS
51001: PPUSH
51002: LD_VAR 0 5
51006: PUSH
51007: LD_VAR 0 6
51011: PUSH
51012: EMPTY
51013: LIST
51014: LIST
51015: PPUSH
51016: CALL_OW 1
51020: ST_TO_ADDR
// end ;
51021: GO 50945
51023: POP
51024: POP
51025: GO 50925
51027: POP
51028: POP
// end ;
51029: LD_VAR 0 4
51033: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51034: LD_INT 0
51036: PPUSH
51037: PPUSH
51038: PPUSH
51039: PPUSH
51040: PPUSH
51041: PPUSH
51042: PPUSH
51043: PPUSH
// if not units then
51044: LD_VAR 0 1
51048: NOT
51049: IFFALSE 51053
// exit ;
51051: GO 51579
// result := UnitFilter ( units , [ f_ok ] ) ;
51053: LD_ADDR_VAR 0 3
51057: PUSH
51058: LD_VAR 0 1
51062: PPUSH
51063: LD_INT 50
51065: PUSH
51066: EMPTY
51067: LIST
51068: PPUSH
51069: CALL_OW 72
51073: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51074: LD_ADDR_VAR 0 8
51078: PUSH
51079: LD_VAR 0 1
51083: PUSH
51084: LD_INT 1
51086: ARRAY
51087: PPUSH
51088: CALL_OW 255
51092: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51093: LD_ADDR_VAR 0 10
51097: PUSH
51098: LD_INT 29
51100: PUSH
51101: LD_EXP 71
51105: PUSH
51106: LD_INT 49
51108: PUSH
51109: EMPTY
51110: LIST
51111: LIST
51112: LIST
51113: ST_TO_ADDR
// if not result then
51114: LD_VAR 0 3
51118: NOT
51119: IFFALSE 51123
// exit ;
51121: GO 51579
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51123: LD_ADDR_VAR 0 5
51127: PUSH
51128: LD_INT 81
51130: PUSH
51131: LD_VAR 0 8
51135: PUSH
51136: EMPTY
51137: LIST
51138: LIST
51139: PPUSH
51140: CALL_OW 69
51144: ST_TO_ADDR
// for i in result do
51145: LD_ADDR_VAR 0 4
51149: PUSH
51150: LD_VAR 0 3
51154: PUSH
51155: FOR_IN
51156: IFFALSE 51577
// begin tag := GetTag ( i ) + 1 ;
51158: LD_ADDR_VAR 0 9
51162: PUSH
51163: LD_VAR 0 4
51167: PPUSH
51168: CALL_OW 110
51172: PUSH
51173: LD_INT 1
51175: PLUS
51176: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51177: LD_ADDR_VAR 0 7
51181: PUSH
51182: LD_VAR 0 4
51186: PPUSH
51187: CALL_OW 250
51191: PPUSH
51192: LD_VAR 0 4
51196: PPUSH
51197: CALL_OW 251
51201: PPUSH
51202: LD_INT 6
51204: PPUSH
51205: CALL 50776 0 3
51209: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51210: LD_VAR 0 4
51214: PPUSH
51215: CALL_OW 247
51219: PUSH
51220: LD_INT 2
51222: EQUAL
51223: PUSH
51224: LD_VAR 0 7
51228: AND
51229: PUSH
51230: LD_VAR 0 4
51234: PPUSH
51235: CALL_OW 264
51239: PUSH
51240: LD_VAR 0 10
51244: IN
51245: NOT
51246: AND
51247: IFFALSE 51286
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51249: LD_VAR 0 4
51253: PPUSH
51254: LD_VAR 0 7
51258: PUSH
51259: LD_INT 1
51261: ARRAY
51262: PUSH
51263: LD_INT 1
51265: ARRAY
51266: PPUSH
51267: LD_VAR 0 7
51271: PUSH
51272: LD_INT 1
51274: ARRAY
51275: PUSH
51276: LD_INT 2
51278: ARRAY
51279: PPUSH
51280: CALL_OW 116
51284: GO 51575
// if path > tag then
51286: LD_VAR 0 2
51290: PUSH
51291: LD_VAR 0 9
51295: GREATER
51296: IFFALSE 51504
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51298: LD_ADDR_VAR 0 6
51302: PUSH
51303: LD_VAR 0 5
51307: PPUSH
51308: LD_INT 91
51310: PUSH
51311: LD_VAR 0 4
51315: PUSH
51316: LD_INT 8
51318: PUSH
51319: EMPTY
51320: LIST
51321: LIST
51322: LIST
51323: PPUSH
51324: CALL_OW 72
51328: ST_TO_ADDR
// if nearEnemy then
51329: LD_VAR 0 6
51333: IFFALSE 51402
// begin if GetWeapon ( i ) = ru_time_lapser then
51335: LD_VAR 0 4
51339: PPUSH
51340: CALL_OW 264
51344: PUSH
51345: LD_INT 49
51347: EQUAL
51348: IFFALSE 51376
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51350: LD_VAR 0 4
51354: PPUSH
51355: LD_VAR 0 6
51359: PPUSH
51360: LD_VAR 0 4
51364: PPUSH
51365: CALL_OW 74
51369: PPUSH
51370: CALL_OW 112
51374: GO 51400
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51376: LD_VAR 0 4
51380: PPUSH
51381: LD_VAR 0 6
51385: PPUSH
51386: LD_VAR 0 4
51390: PPUSH
51391: CALL_OW 74
51395: PPUSH
51396: CALL_OW 115
// end else
51400: GO 51502
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51402: LD_VAR 0 4
51406: PPUSH
51407: LD_VAR 0 2
51411: PUSH
51412: LD_VAR 0 9
51416: ARRAY
51417: PUSH
51418: LD_INT 1
51420: ARRAY
51421: PPUSH
51422: LD_VAR 0 2
51426: PUSH
51427: LD_VAR 0 9
51431: ARRAY
51432: PUSH
51433: LD_INT 2
51435: ARRAY
51436: PPUSH
51437: CALL_OW 297
51441: PUSH
51442: LD_INT 6
51444: GREATER
51445: IFFALSE 51488
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51447: LD_VAR 0 4
51451: PPUSH
51452: LD_VAR 0 2
51456: PUSH
51457: LD_VAR 0 9
51461: ARRAY
51462: PUSH
51463: LD_INT 1
51465: ARRAY
51466: PPUSH
51467: LD_VAR 0 2
51471: PUSH
51472: LD_VAR 0 9
51476: ARRAY
51477: PUSH
51478: LD_INT 2
51480: ARRAY
51481: PPUSH
51482: CALL_OW 114
51486: GO 51502
// SetTag ( i , tag ) ;
51488: LD_VAR 0 4
51492: PPUSH
51493: LD_VAR 0 9
51497: PPUSH
51498: CALL_OW 109
// end else
51502: GO 51575
// if enemy then
51504: LD_VAR 0 5
51508: IFFALSE 51575
// begin if GetWeapon ( i ) = ru_time_lapser then
51510: LD_VAR 0 4
51514: PPUSH
51515: CALL_OW 264
51519: PUSH
51520: LD_INT 49
51522: EQUAL
51523: IFFALSE 51551
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51525: LD_VAR 0 4
51529: PPUSH
51530: LD_VAR 0 5
51534: PPUSH
51535: LD_VAR 0 4
51539: PPUSH
51540: CALL_OW 74
51544: PPUSH
51545: CALL_OW 112
51549: GO 51575
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51551: LD_VAR 0 4
51555: PPUSH
51556: LD_VAR 0 5
51560: PPUSH
51561: LD_VAR 0 4
51565: PPUSH
51566: CALL_OW 74
51570: PPUSH
51571: CALL_OW 115
// end ; end ;
51575: GO 51155
51577: POP
51578: POP
// end ;
51579: LD_VAR 0 3
51583: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51584: LD_INT 0
51586: PPUSH
51587: PPUSH
51588: PPUSH
// if not unit or IsInUnit ( unit ) then
51589: LD_VAR 0 1
51593: NOT
51594: PUSH
51595: LD_VAR 0 1
51599: PPUSH
51600: CALL_OW 310
51604: OR
51605: IFFALSE 51609
// exit ;
51607: GO 51700
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51609: LD_ADDR_VAR 0 4
51613: PUSH
51614: LD_VAR 0 1
51618: PPUSH
51619: CALL_OW 250
51623: PPUSH
51624: LD_VAR 0 2
51628: PPUSH
51629: LD_INT 1
51631: PPUSH
51632: CALL_OW 272
51636: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
51637: LD_ADDR_VAR 0 5
51641: PUSH
51642: LD_VAR 0 1
51646: PPUSH
51647: CALL_OW 251
51651: PPUSH
51652: LD_VAR 0 2
51656: PPUSH
51657: LD_INT 1
51659: PPUSH
51660: CALL_OW 273
51664: ST_TO_ADDR
// if ValidHex ( x , y ) then
51665: LD_VAR 0 4
51669: PPUSH
51670: LD_VAR 0 5
51674: PPUSH
51675: CALL_OW 488
51679: IFFALSE 51700
// ComTurnXY ( unit , x , y ) ;
51681: LD_VAR 0 1
51685: PPUSH
51686: LD_VAR 0 4
51690: PPUSH
51691: LD_VAR 0 5
51695: PPUSH
51696: CALL_OW 118
// end ;
51700: LD_VAR 0 3
51704: RET
// export function SeeUnits ( side , units ) ; var i ; begin
51705: LD_INT 0
51707: PPUSH
51708: PPUSH
// result := false ;
51709: LD_ADDR_VAR 0 3
51713: PUSH
51714: LD_INT 0
51716: ST_TO_ADDR
// if not units then
51717: LD_VAR 0 2
51721: NOT
51722: IFFALSE 51726
// exit ;
51724: GO 51771
// for i in units do
51726: LD_ADDR_VAR 0 4
51730: PUSH
51731: LD_VAR 0 2
51735: PUSH
51736: FOR_IN
51737: IFFALSE 51769
// if See ( side , i ) then
51739: LD_VAR 0 1
51743: PPUSH
51744: LD_VAR 0 4
51748: PPUSH
51749: CALL_OW 292
51753: IFFALSE 51767
// begin result := true ;
51755: LD_ADDR_VAR 0 3
51759: PUSH
51760: LD_INT 1
51762: ST_TO_ADDR
// exit ;
51763: POP
51764: POP
51765: GO 51771
// end ;
51767: GO 51736
51769: POP
51770: POP
// end ;
51771: LD_VAR 0 3
51775: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
51776: LD_INT 0
51778: PPUSH
51779: PPUSH
51780: PPUSH
51781: PPUSH
// if not unit or not points then
51782: LD_VAR 0 1
51786: NOT
51787: PUSH
51788: LD_VAR 0 2
51792: NOT
51793: OR
51794: IFFALSE 51798
// exit ;
51796: GO 51888
// dist := 99999 ;
51798: LD_ADDR_VAR 0 5
51802: PUSH
51803: LD_INT 99999
51805: ST_TO_ADDR
// for i in points do
51806: LD_ADDR_VAR 0 4
51810: PUSH
51811: LD_VAR 0 2
51815: PUSH
51816: FOR_IN
51817: IFFALSE 51886
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51819: LD_ADDR_VAR 0 6
51823: PUSH
51824: LD_VAR 0 1
51828: PPUSH
51829: LD_VAR 0 4
51833: PUSH
51834: LD_INT 1
51836: ARRAY
51837: PPUSH
51838: LD_VAR 0 4
51842: PUSH
51843: LD_INT 2
51845: ARRAY
51846: PPUSH
51847: CALL_OW 297
51851: ST_TO_ADDR
// if tmpDist < dist then
51852: LD_VAR 0 6
51856: PUSH
51857: LD_VAR 0 5
51861: LESS
51862: IFFALSE 51884
// begin result := i ;
51864: LD_ADDR_VAR 0 3
51868: PUSH
51869: LD_VAR 0 4
51873: ST_TO_ADDR
// dist := tmpDist ;
51874: LD_ADDR_VAR 0 5
51878: PUSH
51879: LD_VAR 0 6
51883: ST_TO_ADDR
// end ; end ;
51884: GO 51816
51886: POP
51887: POP
// end ;
51888: LD_VAR 0 3
51892: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
51893: LD_INT 0
51895: PPUSH
// uc_side := side ;
51896: LD_ADDR_OWVAR 20
51900: PUSH
51901: LD_VAR 0 1
51905: ST_TO_ADDR
// uc_nation := 3 ;
51906: LD_ADDR_OWVAR 21
51910: PUSH
51911: LD_INT 3
51913: ST_TO_ADDR
// vc_chassis := 25 ;
51914: LD_ADDR_OWVAR 37
51918: PUSH
51919: LD_INT 25
51921: ST_TO_ADDR
// vc_engine := engine_siberite ;
51922: LD_ADDR_OWVAR 39
51926: PUSH
51927: LD_INT 3
51929: ST_TO_ADDR
// vc_control := control_computer ;
51930: LD_ADDR_OWVAR 38
51934: PUSH
51935: LD_INT 3
51937: ST_TO_ADDR
// vc_weapon := 59 ;
51938: LD_ADDR_OWVAR 40
51942: PUSH
51943: LD_INT 59
51945: ST_TO_ADDR
// result := CreateVehicle ;
51946: LD_ADDR_VAR 0 5
51950: PUSH
51951: CALL_OW 45
51955: ST_TO_ADDR
// SetDir ( result , d ) ;
51956: LD_VAR 0 5
51960: PPUSH
51961: LD_VAR 0 4
51965: PPUSH
51966: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
51970: LD_VAR 0 5
51974: PPUSH
51975: LD_VAR 0 2
51979: PPUSH
51980: LD_VAR 0 3
51984: PPUSH
51985: LD_INT 0
51987: PPUSH
51988: CALL_OW 48
// end ;
51992: LD_VAR 0 5
51996: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
51997: LD_INT 0
51999: PPUSH
52000: PPUSH
52001: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
52002: LD_ADDR_VAR 0 2
52006: PUSH
52007: LD_INT 0
52009: PUSH
52010: LD_INT 0
52012: PUSH
52013: LD_INT 0
52015: PUSH
52016: LD_INT 0
52018: PUSH
52019: EMPTY
52020: LIST
52021: LIST
52022: LIST
52023: LIST
52024: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52025: LD_VAR 0 1
52029: NOT
52030: PUSH
52031: LD_VAR 0 1
52035: PPUSH
52036: CALL_OW 264
52040: PUSH
52041: LD_INT 12
52043: PUSH
52044: LD_INT 51
52046: PUSH
52047: LD_INT 32
52049: PUSH
52050: LD_EXP 68
52054: PUSH
52055: EMPTY
52056: LIST
52057: LIST
52058: LIST
52059: LIST
52060: IN
52061: NOT
52062: OR
52063: IFFALSE 52067
// exit ;
52065: GO 52165
// for i := 1 to 3 do
52067: LD_ADDR_VAR 0 3
52071: PUSH
52072: DOUBLE
52073: LD_INT 1
52075: DEC
52076: ST_TO_ADDR
52077: LD_INT 3
52079: PUSH
52080: FOR_TO
52081: IFFALSE 52163
// begin tmp := GetCargo ( cargo , i ) ;
52083: LD_ADDR_VAR 0 4
52087: PUSH
52088: LD_VAR 0 1
52092: PPUSH
52093: LD_VAR 0 3
52097: PPUSH
52098: CALL_OW 289
52102: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52103: LD_ADDR_VAR 0 2
52107: PUSH
52108: LD_VAR 0 2
52112: PPUSH
52113: LD_VAR 0 3
52117: PPUSH
52118: LD_VAR 0 4
52122: PPUSH
52123: CALL_OW 1
52127: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52128: LD_ADDR_VAR 0 2
52132: PUSH
52133: LD_VAR 0 2
52137: PPUSH
52138: LD_INT 4
52140: PPUSH
52141: LD_VAR 0 2
52145: PUSH
52146: LD_INT 4
52148: ARRAY
52149: PUSH
52150: LD_VAR 0 4
52154: PLUS
52155: PPUSH
52156: CALL_OW 1
52160: ST_TO_ADDR
// end ;
52161: GO 52080
52163: POP
52164: POP
// end ;
52165: LD_VAR 0 2
52169: RET
// export function Length ( array ) ; begin
52170: LD_INT 0
52172: PPUSH
// result := array + 0 ;
52173: LD_ADDR_VAR 0 2
52177: PUSH
52178: LD_VAR 0 1
52182: PUSH
52183: LD_INT 0
52185: PLUS
52186: ST_TO_ADDR
// end ;
52187: LD_VAR 0 2
52191: RET
// export function PrepareArray ( array ) ; begin
52192: LD_INT 0
52194: PPUSH
// result := array diff 0 ;
52195: LD_ADDR_VAR 0 2
52199: PUSH
52200: LD_VAR 0 1
52204: PUSH
52205: LD_INT 0
52207: DIFF
52208: ST_TO_ADDR
// if not result [ 1 ] then
52209: LD_VAR 0 2
52213: PUSH
52214: LD_INT 1
52216: ARRAY
52217: NOT
52218: IFFALSE 52238
// result := Delete ( result , 1 ) ;
52220: LD_ADDR_VAR 0 2
52224: PUSH
52225: LD_VAR 0 2
52229: PPUSH
52230: LD_INT 1
52232: PPUSH
52233: CALL_OW 3
52237: ST_TO_ADDR
// end ; end_of_file
52238: LD_VAR 0 2
52242: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52243: LD_INT 0
52245: PPUSH
52246: PPUSH
// skirmish := false ;
52247: LD_ADDR_EXP 21
52251: PUSH
52252: LD_INT 0
52254: ST_TO_ADDR
// debug_mc := false ;
52255: LD_ADDR_EXP 22
52259: PUSH
52260: LD_INT 0
52262: ST_TO_ADDR
// mc_bases := [ ] ;
52263: LD_ADDR_EXP 23
52267: PUSH
52268: EMPTY
52269: ST_TO_ADDR
// mc_sides := [ ] ;
52270: LD_ADDR_EXP 49
52274: PUSH
52275: EMPTY
52276: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52277: LD_ADDR_EXP 24
52281: PUSH
52282: EMPTY
52283: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52284: LD_ADDR_EXP 25
52288: PUSH
52289: EMPTY
52290: ST_TO_ADDR
// mc_need_heal := [ ] ;
52291: LD_ADDR_EXP 26
52295: PUSH
52296: EMPTY
52297: ST_TO_ADDR
// mc_healers := [ ] ;
52298: LD_ADDR_EXP 27
52302: PUSH
52303: EMPTY
52304: ST_TO_ADDR
// mc_build_list := [ ] ;
52305: LD_ADDR_EXP 28
52309: PUSH
52310: EMPTY
52311: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52312: LD_ADDR_EXP 55
52316: PUSH
52317: EMPTY
52318: ST_TO_ADDR
// mc_builders := [ ] ;
52319: LD_ADDR_EXP 29
52323: PUSH
52324: EMPTY
52325: ST_TO_ADDR
// mc_construct_list := [ ] ;
52326: LD_ADDR_EXP 30
52330: PUSH
52331: EMPTY
52332: ST_TO_ADDR
// mc_turret_list := [ ] ;
52333: LD_ADDR_EXP 31
52337: PUSH
52338: EMPTY
52339: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52340: LD_ADDR_EXP 32
52344: PUSH
52345: EMPTY
52346: ST_TO_ADDR
// mc_miners := [ ] ;
52347: LD_ADDR_EXP 37
52351: PUSH
52352: EMPTY
52353: ST_TO_ADDR
// mc_mines := [ ] ;
52354: LD_ADDR_EXP 36
52358: PUSH
52359: EMPTY
52360: ST_TO_ADDR
// mc_minefields := [ ] ;
52361: LD_ADDR_EXP 38
52365: PUSH
52366: EMPTY
52367: ST_TO_ADDR
// mc_crates := [ ] ;
52368: LD_ADDR_EXP 39
52372: PUSH
52373: EMPTY
52374: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52375: LD_ADDR_EXP 40
52379: PUSH
52380: EMPTY
52381: ST_TO_ADDR
// mc_crates_area := [ ] ;
52382: LD_ADDR_EXP 41
52386: PUSH
52387: EMPTY
52388: ST_TO_ADDR
// mc_vehicles := [ ] ;
52389: LD_ADDR_EXP 42
52393: PUSH
52394: EMPTY
52395: ST_TO_ADDR
// mc_attack := [ ] ;
52396: LD_ADDR_EXP 43
52400: PUSH
52401: EMPTY
52402: ST_TO_ADDR
// mc_produce := [ ] ;
52403: LD_ADDR_EXP 44
52407: PUSH
52408: EMPTY
52409: ST_TO_ADDR
// mc_defender := [ ] ;
52410: LD_ADDR_EXP 45
52414: PUSH
52415: EMPTY
52416: ST_TO_ADDR
// mc_parking := [ ] ;
52417: LD_ADDR_EXP 47
52421: PUSH
52422: EMPTY
52423: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52424: LD_ADDR_EXP 33
52428: PUSH
52429: EMPTY
52430: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52431: LD_ADDR_EXP 35
52435: PUSH
52436: EMPTY
52437: ST_TO_ADDR
// mc_scan := [ ] ;
52438: LD_ADDR_EXP 46
52442: PUSH
52443: EMPTY
52444: ST_TO_ADDR
// mc_scan_area := [ ] ;
52445: LD_ADDR_EXP 48
52449: PUSH
52450: EMPTY
52451: ST_TO_ADDR
// mc_tech := [ ] ;
52452: LD_ADDR_EXP 50
52456: PUSH
52457: EMPTY
52458: ST_TO_ADDR
// mc_class := [ ] ;
52459: LD_ADDR_EXP 64
52463: PUSH
52464: EMPTY
52465: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52466: LD_ADDR_EXP 65
52470: PUSH
52471: EMPTY
52472: ST_TO_ADDR
// mc_is_defending := [ ] ;
52473: LD_ADDR_EXP 66
52477: PUSH
52478: EMPTY
52479: ST_TO_ADDR
// end ;
52480: LD_VAR 0 1
52484: RET
// export function MC_Kill ( base ) ; begin
52485: LD_INT 0
52487: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52488: LD_ADDR_EXP 23
52492: PUSH
52493: LD_EXP 23
52497: PPUSH
52498: LD_VAR 0 1
52502: PPUSH
52503: EMPTY
52504: PPUSH
52505: CALL_OW 1
52509: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52510: LD_ADDR_EXP 24
52514: PUSH
52515: LD_EXP 24
52519: PPUSH
52520: LD_VAR 0 1
52524: PPUSH
52525: EMPTY
52526: PPUSH
52527: CALL_OW 1
52531: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52532: LD_ADDR_EXP 25
52536: PUSH
52537: LD_EXP 25
52541: PPUSH
52542: LD_VAR 0 1
52546: PPUSH
52547: EMPTY
52548: PPUSH
52549: CALL_OW 1
52553: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52554: LD_ADDR_EXP 26
52558: PUSH
52559: LD_EXP 26
52563: PPUSH
52564: LD_VAR 0 1
52568: PPUSH
52569: EMPTY
52570: PPUSH
52571: CALL_OW 1
52575: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52576: LD_ADDR_EXP 27
52580: PUSH
52581: LD_EXP 27
52585: PPUSH
52586: LD_VAR 0 1
52590: PPUSH
52591: EMPTY
52592: PPUSH
52593: CALL_OW 1
52597: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52598: LD_ADDR_EXP 28
52602: PUSH
52603: LD_EXP 28
52607: PPUSH
52608: LD_VAR 0 1
52612: PPUSH
52613: EMPTY
52614: PPUSH
52615: CALL_OW 1
52619: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52620: LD_ADDR_EXP 29
52624: PUSH
52625: LD_EXP 29
52629: PPUSH
52630: LD_VAR 0 1
52634: PPUSH
52635: EMPTY
52636: PPUSH
52637: CALL_OW 1
52641: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52642: LD_ADDR_EXP 30
52646: PUSH
52647: LD_EXP 30
52651: PPUSH
52652: LD_VAR 0 1
52656: PPUSH
52657: EMPTY
52658: PPUSH
52659: CALL_OW 1
52663: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52664: LD_ADDR_EXP 31
52668: PUSH
52669: LD_EXP 31
52673: PPUSH
52674: LD_VAR 0 1
52678: PPUSH
52679: EMPTY
52680: PPUSH
52681: CALL_OW 1
52685: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52686: LD_ADDR_EXP 32
52690: PUSH
52691: LD_EXP 32
52695: PPUSH
52696: LD_VAR 0 1
52700: PPUSH
52701: EMPTY
52702: PPUSH
52703: CALL_OW 1
52707: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52708: LD_ADDR_EXP 33
52712: PUSH
52713: LD_EXP 33
52717: PPUSH
52718: LD_VAR 0 1
52722: PPUSH
52723: EMPTY
52724: PPUSH
52725: CALL_OW 1
52729: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52730: LD_ADDR_EXP 34
52734: PUSH
52735: LD_EXP 34
52739: PPUSH
52740: LD_VAR 0 1
52744: PPUSH
52745: LD_INT 0
52747: PPUSH
52748: CALL_OW 1
52752: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52753: LD_ADDR_EXP 35
52757: PUSH
52758: LD_EXP 35
52762: PPUSH
52763: LD_VAR 0 1
52767: PPUSH
52768: EMPTY
52769: PPUSH
52770: CALL_OW 1
52774: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52775: LD_ADDR_EXP 36
52779: PUSH
52780: LD_EXP 36
52784: PPUSH
52785: LD_VAR 0 1
52789: PPUSH
52790: EMPTY
52791: PPUSH
52792: CALL_OW 1
52796: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52797: LD_ADDR_EXP 37
52801: PUSH
52802: LD_EXP 37
52806: PPUSH
52807: LD_VAR 0 1
52811: PPUSH
52812: EMPTY
52813: PPUSH
52814: CALL_OW 1
52818: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52819: LD_ADDR_EXP 38
52823: PUSH
52824: LD_EXP 38
52828: PPUSH
52829: LD_VAR 0 1
52833: PPUSH
52834: EMPTY
52835: PPUSH
52836: CALL_OW 1
52840: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52841: LD_ADDR_EXP 39
52845: PUSH
52846: LD_EXP 39
52850: PPUSH
52851: LD_VAR 0 1
52855: PPUSH
52856: EMPTY
52857: PPUSH
52858: CALL_OW 1
52862: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52863: LD_ADDR_EXP 40
52867: PUSH
52868: LD_EXP 40
52872: PPUSH
52873: LD_VAR 0 1
52877: PPUSH
52878: EMPTY
52879: PPUSH
52880: CALL_OW 1
52884: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52885: LD_ADDR_EXP 41
52889: PUSH
52890: LD_EXP 41
52894: PPUSH
52895: LD_VAR 0 1
52899: PPUSH
52900: EMPTY
52901: PPUSH
52902: CALL_OW 1
52906: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52907: LD_ADDR_EXP 42
52911: PUSH
52912: LD_EXP 42
52916: PPUSH
52917: LD_VAR 0 1
52921: PPUSH
52922: EMPTY
52923: PPUSH
52924: CALL_OW 1
52928: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52929: LD_ADDR_EXP 43
52933: PUSH
52934: LD_EXP 43
52938: PPUSH
52939: LD_VAR 0 1
52943: PPUSH
52944: EMPTY
52945: PPUSH
52946: CALL_OW 1
52950: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52951: LD_ADDR_EXP 44
52955: PUSH
52956: LD_EXP 44
52960: PPUSH
52961: LD_VAR 0 1
52965: PPUSH
52966: EMPTY
52967: PPUSH
52968: CALL_OW 1
52972: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52973: LD_ADDR_EXP 45
52977: PUSH
52978: LD_EXP 45
52982: PPUSH
52983: LD_VAR 0 1
52987: PPUSH
52988: EMPTY
52989: PPUSH
52990: CALL_OW 1
52994: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52995: LD_ADDR_EXP 46
52999: PUSH
53000: LD_EXP 46
53004: PPUSH
53005: LD_VAR 0 1
53009: PPUSH
53010: EMPTY
53011: PPUSH
53012: CALL_OW 1
53016: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53017: LD_ADDR_EXP 47
53021: PUSH
53022: LD_EXP 47
53026: PPUSH
53027: LD_VAR 0 1
53031: PPUSH
53032: EMPTY
53033: PPUSH
53034: CALL_OW 1
53038: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53039: LD_ADDR_EXP 48
53043: PUSH
53044: LD_EXP 48
53048: PPUSH
53049: LD_VAR 0 1
53053: PPUSH
53054: EMPTY
53055: PPUSH
53056: CALL_OW 1
53060: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53061: LD_ADDR_EXP 50
53065: PUSH
53066: LD_EXP 50
53070: PPUSH
53071: LD_VAR 0 1
53075: PPUSH
53076: EMPTY
53077: PPUSH
53078: CALL_OW 1
53082: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53083: LD_ADDR_EXP 52
53087: PUSH
53088: LD_EXP 52
53092: PPUSH
53093: LD_VAR 0 1
53097: PPUSH
53098: EMPTY
53099: PPUSH
53100: CALL_OW 1
53104: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53105: LD_ADDR_EXP 53
53109: PUSH
53110: LD_EXP 53
53114: PPUSH
53115: LD_VAR 0 1
53119: PPUSH
53120: EMPTY
53121: PPUSH
53122: CALL_OW 1
53126: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53127: LD_ADDR_EXP 54
53131: PUSH
53132: LD_EXP 54
53136: PPUSH
53137: LD_VAR 0 1
53141: PPUSH
53142: EMPTY
53143: PPUSH
53144: CALL_OW 1
53148: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53149: LD_ADDR_EXP 55
53153: PUSH
53154: LD_EXP 55
53158: PPUSH
53159: LD_VAR 0 1
53163: PPUSH
53164: EMPTY
53165: PPUSH
53166: CALL_OW 1
53170: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53171: LD_ADDR_EXP 56
53175: PUSH
53176: LD_EXP 56
53180: PPUSH
53181: LD_VAR 0 1
53185: PPUSH
53186: EMPTY
53187: PPUSH
53188: CALL_OW 1
53192: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53193: LD_ADDR_EXP 57
53197: PUSH
53198: LD_EXP 57
53202: PPUSH
53203: LD_VAR 0 1
53207: PPUSH
53208: EMPTY
53209: PPUSH
53210: CALL_OW 1
53214: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53215: LD_ADDR_EXP 58
53219: PUSH
53220: LD_EXP 58
53224: PPUSH
53225: LD_VAR 0 1
53229: PPUSH
53230: EMPTY
53231: PPUSH
53232: CALL_OW 1
53236: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53237: LD_ADDR_EXP 59
53241: PUSH
53242: LD_EXP 59
53246: PPUSH
53247: LD_VAR 0 1
53251: PPUSH
53252: EMPTY
53253: PPUSH
53254: CALL_OW 1
53258: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53259: LD_ADDR_EXP 60
53263: PUSH
53264: LD_EXP 60
53268: PPUSH
53269: LD_VAR 0 1
53273: PPUSH
53274: EMPTY
53275: PPUSH
53276: CALL_OW 1
53280: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53281: LD_ADDR_EXP 61
53285: PUSH
53286: LD_EXP 61
53290: PPUSH
53291: LD_VAR 0 1
53295: PPUSH
53296: EMPTY
53297: PPUSH
53298: CALL_OW 1
53302: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53303: LD_ADDR_EXP 62
53307: PUSH
53308: LD_EXP 62
53312: PPUSH
53313: LD_VAR 0 1
53317: PPUSH
53318: EMPTY
53319: PPUSH
53320: CALL_OW 1
53324: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53325: LD_ADDR_EXP 63
53329: PUSH
53330: LD_EXP 63
53334: PPUSH
53335: LD_VAR 0 1
53339: PPUSH
53340: EMPTY
53341: PPUSH
53342: CALL_OW 1
53346: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53347: LD_ADDR_EXP 64
53351: PUSH
53352: LD_EXP 64
53356: PPUSH
53357: LD_VAR 0 1
53361: PPUSH
53362: EMPTY
53363: PPUSH
53364: CALL_OW 1
53368: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53369: LD_ADDR_EXP 65
53373: PUSH
53374: LD_EXP 65
53378: PPUSH
53379: LD_VAR 0 1
53383: PPUSH
53384: LD_INT 0
53386: PPUSH
53387: CALL_OW 1
53391: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53392: LD_ADDR_EXP 66
53396: PUSH
53397: LD_EXP 66
53401: PPUSH
53402: LD_VAR 0 1
53406: PPUSH
53407: LD_INT 0
53409: PPUSH
53410: CALL_OW 1
53414: ST_TO_ADDR
// end ;
53415: LD_VAR 0 2
53419: RET
// export function MC_Add ( side , units ) ; var base ; begin
53420: LD_INT 0
53422: PPUSH
53423: PPUSH
// base := mc_bases + 1 ;
53424: LD_ADDR_VAR 0 4
53428: PUSH
53429: LD_EXP 23
53433: PUSH
53434: LD_INT 1
53436: PLUS
53437: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53438: LD_ADDR_EXP 49
53442: PUSH
53443: LD_EXP 49
53447: PPUSH
53448: LD_VAR 0 4
53452: PPUSH
53453: LD_VAR 0 1
53457: PPUSH
53458: CALL_OW 1
53462: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53463: LD_ADDR_EXP 23
53467: PUSH
53468: LD_EXP 23
53472: PPUSH
53473: LD_VAR 0 4
53477: PPUSH
53478: LD_VAR 0 2
53482: PPUSH
53483: CALL_OW 1
53487: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53488: LD_ADDR_EXP 24
53492: PUSH
53493: LD_EXP 24
53497: PPUSH
53498: LD_VAR 0 4
53502: PPUSH
53503: EMPTY
53504: PPUSH
53505: CALL_OW 1
53509: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53510: LD_ADDR_EXP 25
53514: PUSH
53515: LD_EXP 25
53519: PPUSH
53520: LD_VAR 0 4
53524: PPUSH
53525: EMPTY
53526: PPUSH
53527: CALL_OW 1
53531: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53532: LD_ADDR_EXP 26
53536: PUSH
53537: LD_EXP 26
53541: PPUSH
53542: LD_VAR 0 4
53546: PPUSH
53547: EMPTY
53548: PPUSH
53549: CALL_OW 1
53553: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53554: LD_ADDR_EXP 27
53558: PUSH
53559: LD_EXP 27
53563: PPUSH
53564: LD_VAR 0 4
53568: PPUSH
53569: EMPTY
53570: PPUSH
53571: CALL_OW 1
53575: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53576: LD_ADDR_EXP 28
53580: PUSH
53581: LD_EXP 28
53585: PPUSH
53586: LD_VAR 0 4
53590: PPUSH
53591: EMPTY
53592: PPUSH
53593: CALL_OW 1
53597: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53598: LD_ADDR_EXP 29
53602: PUSH
53603: LD_EXP 29
53607: PPUSH
53608: LD_VAR 0 4
53612: PPUSH
53613: EMPTY
53614: PPUSH
53615: CALL_OW 1
53619: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53620: LD_ADDR_EXP 30
53624: PUSH
53625: LD_EXP 30
53629: PPUSH
53630: LD_VAR 0 4
53634: PPUSH
53635: EMPTY
53636: PPUSH
53637: CALL_OW 1
53641: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53642: LD_ADDR_EXP 31
53646: PUSH
53647: LD_EXP 31
53651: PPUSH
53652: LD_VAR 0 4
53656: PPUSH
53657: EMPTY
53658: PPUSH
53659: CALL_OW 1
53663: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53664: LD_ADDR_EXP 32
53668: PUSH
53669: LD_EXP 32
53673: PPUSH
53674: LD_VAR 0 4
53678: PPUSH
53679: EMPTY
53680: PPUSH
53681: CALL_OW 1
53685: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53686: LD_ADDR_EXP 33
53690: PUSH
53691: LD_EXP 33
53695: PPUSH
53696: LD_VAR 0 4
53700: PPUSH
53701: EMPTY
53702: PPUSH
53703: CALL_OW 1
53707: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53708: LD_ADDR_EXP 34
53712: PUSH
53713: LD_EXP 34
53717: PPUSH
53718: LD_VAR 0 4
53722: PPUSH
53723: LD_INT 0
53725: PPUSH
53726: CALL_OW 1
53730: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53731: LD_ADDR_EXP 35
53735: PUSH
53736: LD_EXP 35
53740: PPUSH
53741: LD_VAR 0 4
53745: PPUSH
53746: EMPTY
53747: PPUSH
53748: CALL_OW 1
53752: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53753: LD_ADDR_EXP 36
53757: PUSH
53758: LD_EXP 36
53762: PPUSH
53763: LD_VAR 0 4
53767: PPUSH
53768: EMPTY
53769: PPUSH
53770: CALL_OW 1
53774: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53775: LD_ADDR_EXP 37
53779: PUSH
53780: LD_EXP 37
53784: PPUSH
53785: LD_VAR 0 4
53789: PPUSH
53790: EMPTY
53791: PPUSH
53792: CALL_OW 1
53796: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53797: LD_ADDR_EXP 38
53801: PUSH
53802: LD_EXP 38
53806: PPUSH
53807: LD_VAR 0 4
53811: PPUSH
53812: EMPTY
53813: PPUSH
53814: CALL_OW 1
53818: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53819: LD_ADDR_EXP 39
53823: PUSH
53824: LD_EXP 39
53828: PPUSH
53829: LD_VAR 0 4
53833: PPUSH
53834: EMPTY
53835: PPUSH
53836: CALL_OW 1
53840: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53841: LD_ADDR_EXP 40
53845: PUSH
53846: LD_EXP 40
53850: PPUSH
53851: LD_VAR 0 4
53855: PPUSH
53856: EMPTY
53857: PPUSH
53858: CALL_OW 1
53862: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53863: LD_ADDR_EXP 41
53867: PUSH
53868: LD_EXP 41
53872: PPUSH
53873: LD_VAR 0 4
53877: PPUSH
53878: EMPTY
53879: PPUSH
53880: CALL_OW 1
53884: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53885: LD_ADDR_EXP 42
53889: PUSH
53890: LD_EXP 42
53894: PPUSH
53895: LD_VAR 0 4
53899: PPUSH
53900: EMPTY
53901: PPUSH
53902: CALL_OW 1
53906: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53907: LD_ADDR_EXP 43
53911: PUSH
53912: LD_EXP 43
53916: PPUSH
53917: LD_VAR 0 4
53921: PPUSH
53922: EMPTY
53923: PPUSH
53924: CALL_OW 1
53928: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53929: LD_ADDR_EXP 44
53933: PUSH
53934: LD_EXP 44
53938: PPUSH
53939: LD_VAR 0 4
53943: PPUSH
53944: EMPTY
53945: PPUSH
53946: CALL_OW 1
53950: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53951: LD_ADDR_EXP 45
53955: PUSH
53956: LD_EXP 45
53960: PPUSH
53961: LD_VAR 0 4
53965: PPUSH
53966: EMPTY
53967: PPUSH
53968: CALL_OW 1
53972: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53973: LD_ADDR_EXP 46
53977: PUSH
53978: LD_EXP 46
53982: PPUSH
53983: LD_VAR 0 4
53987: PPUSH
53988: EMPTY
53989: PPUSH
53990: CALL_OW 1
53994: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53995: LD_ADDR_EXP 47
53999: PUSH
54000: LD_EXP 47
54004: PPUSH
54005: LD_VAR 0 4
54009: PPUSH
54010: EMPTY
54011: PPUSH
54012: CALL_OW 1
54016: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54017: LD_ADDR_EXP 48
54021: PUSH
54022: LD_EXP 48
54026: PPUSH
54027: LD_VAR 0 4
54031: PPUSH
54032: EMPTY
54033: PPUSH
54034: CALL_OW 1
54038: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54039: LD_ADDR_EXP 50
54043: PUSH
54044: LD_EXP 50
54048: PPUSH
54049: LD_VAR 0 4
54053: PPUSH
54054: EMPTY
54055: PPUSH
54056: CALL_OW 1
54060: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54061: LD_ADDR_EXP 52
54065: PUSH
54066: LD_EXP 52
54070: PPUSH
54071: LD_VAR 0 4
54075: PPUSH
54076: EMPTY
54077: PPUSH
54078: CALL_OW 1
54082: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54083: LD_ADDR_EXP 53
54087: PUSH
54088: LD_EXP 53
54092: PPUSH
54093: LD_VAR 0 4
54097: PPUSH
54098: EMPTY
54099: PPUSH
54100: CALL_OW 1
54104: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54105: LD_ADDR_EXP 54
54109: PUSH
54110: LD_EXP 54
54114: PPUSH
54115: LD_VAR 0 4
54119: PPUSH
54120: EMPTY
54121: PPUSH
54122: CALL_OW 1
54126: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54127: LD_ADDR_EXP 55
54131: PUSH
54132: LD_EXP 55
54136: PPUSH
54137: LD_VAR 0 4
54141: PPUSH
54142: EMPTY
54143: PPUSH
54144: CALL_OW 1
54148: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54149: LD_ADDR_EXP 56
54153: PUSH
54154: LD_EXP 56
54158: PPUSH
54159: LD_VAR 0 4
54163: PPUSH
54164: EMPTY
54165: PPUSH
54166: CALL_OW 1
54170: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54171: LD_ADDR_EXP 57
54175: PUSH
54176: LD_EXP 57
54180: PPUSH
54181: LD_VAR 0 4
54185: PPUSH
54186: EMPTY
54187: PPUSH
54188: CALL_OW 1
54192: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54193: LD_ADDR_EXP 58
54197: PUSH
54198: LD_EXP 58
54202: PPUSH
54203: LD_VAR 0 4
54207: PPUSH
54208: EMPTY
54209: PPUSH
54210: CALL_OW 1
54214: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54215: LD_ADDR_EXP 59
54219: PUSH
54220: LD_EXP 59
54224: PPUSH
54225: LD_VAR 0 4
54229: PPUSH
54230: EMPTY
54231: PPUSH
54232: CALL_OW 1
54236: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54237: LD_ADDR_EXP 60
54241: PUSH
54242: LD_EXP 60
54246: PPUSH
54247: LD_VAR 0 4
54251: PPUSH
54252: EMPTY
54253: PPUSH
54254: CALL_OW 1
54258: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54259: LD_ADDR_EXP 61
54263: PUSH
54264: LD_EXP 61
54268: PPUSH
54269: LD_VAR 0 4
54273: PPUSH
54274: EMPTY
54275: PPUSH
54276: CALL_OW 1
54280: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54281: LD_ADDR_EXP 62
54285: PUSH
54286: LD_EXP 62
54290: PPUSH
54291: LD_VAR 0 4
54295: PPUSH
54296: EMPTY
54297: PPUSH
54298: CALL_OW 1
54302: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54303: LD_ADDR_EXP 63
54307: PUSH
54308: LD_EXP 63
54312: PPUSH
54313: LD_VAR 0 4
54317: PPUSH
54318: EMPTY
54319: PPUSH
54320: CALL_OW 1
54324: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54325: LD_ADDR_EXP 64
54329: PUSH
54330: LD_EXP 64
54334: PPUSH
54335: LD_VAR 0 4
54339: PPUSH
54340: EMPTY
54341: PPUSH
54342: CALL_OW 1
54346: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54347: LD_ADDR_EXP 65
54351: PUSH
54352: LD_EXP 65
54356: PPUSH
54357: LD_VAR 0 4
54361: PPUSH
54362: LD_INT 0
54364: PPUSH
54365: CALL_OW 1
54369: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54370: LD_ADDR_EXP 66
54374: PUSH
54375: LD_EXP 66
54379: PPUSH
54380: LD_VAR 0 4
54384: PPUSH
54385: LD_INT 0
54387: PPUSH
54388: CALL_OW 1
54392: ST_TO_ADDR
// result := base ;
54393: LD_ADDR_VAR 0 3
54397: PUSH
54398: LD_VAR 0 4
54402: ST_TO_ADDR
// end ;
54403: LD_VAR 0 3
54407: RET
// export function MC_Start ( ) ; var i ; begin
54408: LD_INT 0
54410: PPUSH
54411: PPUSH
// for i = 1 to mc_bases do
54412: LD_ADDR_VAR 0 2
54416: PUSH
54417: DOUBLE
54418: LD_INT 1
54420: DEC
54421: ST_TO_ADDR
54422: LD_EXP 23
54426: PUSH
54427: FOR_TO
54428: IFFALSE 55528
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54430: LD_ADDR_EXP 23
54434: PUSH
54435: LD_EXP 23
54439: PPUSH
54440: LD_VAR 0 2
54444: PPUSH
54445: LD_EXP 23
54449: PUSH
54450: LD_VAR 0 2
54454: ARRAY
54455: PUSH
54456: LD_INT 0
54458: DIFF
54459: PPUSH
54460: CALL_OW 1
54464: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54465: LD_ADDR_EXP 24
54469: PUSH
54470: LD_EXP 24
54474: PPUSH
54475: LD_VAR 0 2
54479: PPUSH
54480: EMPTY
54481: PPUSH
54482: CALL_OW 1
54486: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54487: LD_ADDR_EXP 25
54491: PUSH
54492: LD_EXP 25
54496: PPUSH
54497: LD_VAR 0 2
54501: PPUSH
54502: EMPTY
54503: PPUSH
54504: CALL_OW 1
54508: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54509: LD_ADDR_EXP 26
54513: PUSH
54514: LD_EXP 26
54518: PPUSH
54519: LD_VAR 0 2
54523: PPUSH
54524: EMPTY
54525: PPUSH
54526: CALL_OW 1
54530: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54531: LD_ADDR_EXP 27
54535: PUSH
54536: LD_EXP 27
54540: PPUSH
54541: LD_VAR 0 2
54545: PPUSH
54546: EMPTY
54547: PUSH
54548: EMPTY
54549: PUSH
54550: EMPTY
54551: LIST
54552: LIST
54553: PPUSH
54554: CALL_OW 1
54558: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54559: LD_ADDR_EXP 28
54563: PUSH
54564: LD_EXP 28
54568: PPUSH
54569: LD_VAR 0 2
54573: PPUSH
54574: EMPTY
54575: PPUSH
54576: CALL_OW 1
54580: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54581: LD_ADDR_EXP 55
54585: PUSH
54586: LD_EXP 55
54590: PPUSH
54591: LD_VAR 0 2
54595: PPUSH
54596: EMPTY
54597: PPUSH
54598: CALL_OW 1
54602: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54603: LD_ADDR_EXP 29
54607: PUSH
54608: LD_EXP 29
54612: PPUSH
54613: LD_VAR 0 2
54617: PPUSH
54618: EMPTY
54619: PPUSH
54620: CALL_OW 1
54624: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54625: LD_ADDR_EXP 30
54629: PUSH
54630: LD_EXP 30
54634: PPUSH
54635: LD_VAR 0 2
54639: PPUSH
54640: EMPTY
54641: PPUSH
54642: CALL_OW 1
54646: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54647: LD_ADDR_EXP 31
54651: PUSH
54652: LD_EXP 31
54656: PPUSH
54657: LD_VAR 0 2
54661: PPUSH
54662: LD_EXP 23
54666: PUSH
54667: LD_VAR 0 2
54671: ARRAY
54672: PPUSH
54673: LD_INT 2
54675: PUSH
54676: LD_INT 30
54678: PUSH
54679: LD_INT 32
54681: PUSH
54682: EMPTY
54683: LIST
54684: LIST
54685: PUSH
54686: LD_INT 30
54688: PUSH
54689: LD_INT 33
54691: PUSH
54692: EMPTY
54693: LIST
54694: LIST
54695: PUSH
54696: EMPTY
54697: LIST
54698: LIST
54699: LIST
54700: PPUSH
54701: CALL_OW 72
54705: PPUSH
54706: CALL_OW 1
54710: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54711: LD_ADDR_EXP 32
54715: PUSH
54716: LD_EXP 32
54720: PPUSH
54721: LD_VAR 0 2
54725: PPUSH
54726: LD_EXP 23
54730: PUSH
54731: LD_VAR 0 2
54735: ARRAY
54736: PPUSH
54737: LD_INT 2
54739: PUSH
54740: LD_INT 30
54742: PUSH
54743: LD_INT 32
54745: PUSH
54746: EMPTY
54747: LIST
54748: LIST
54749: PUSH
54750: LD_INT 30
54752: PUSH
54753: LD_INT 31
54755: PUSH
54756: EMPTY
54757: LIST
54758: LIST
54759: PUSH
54760: EMPTY
54761: LIST
54762: LIST
54763: LIST
54764: PUSH
54765: LD_INT 58
54767: PUSH
54768: EMPTY
54769: LIST
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PPUSH
54775: CALL_OW 72
54779: PPUSH
54780: CALL_OW 1
54784: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54785: LD_ADDR_EXP 33
54789: PUSH
54790: LD_EXP 33
54794: PPUSH
54795: LD_VAR 0 2
54799: PPUSH
54800: EMPTY
54801: PPUSH
54802: CALL_OW 1
54806: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54807: LD_ADDR_EXP 37
54811: PUSH
54812: LD_EXP 37
54816: PPUSH
54817: LD_VAR 0 2
54821: PPUSH
54822: EMPTY
54823: PPUSH
54824: CALL_OW 1
54828: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54829: LD_ADDR_EXP 36
54833: PUSH
54834: LD_EXP 36
54838: PPUSH
54839: LD_VAR 0 2
54843: PPUSH
54844: EMPTY
54845: PPUSH
54846: CALL_OW 1
54850: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54851: LD_ADDR_EXP 38
54855: PUSH
54856: LD_EXP 38
54860: PPUSH
54861: LD_VAR 0 2
54865: PPUSH
54866: EMPTY
54867: PPUSH
54868: CALL_OW 1
54872: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54873: LD_ADDR_EXP 39
54877: PUSH
54878: LD_EXP 39
54882: PPUSH
54883: LD_VAR 0 2
54887: PPUSH
54888: EMPTY
54889: PPUSH
54890: CALL_OW 1
54894: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54895: LD_ADDR_EXP 40
54899: PUSH
54900: LD_EXP 40
54904: PPUSH
54905: LD_VAR 0 2
54909: PPUSH
54910: EMPTY
54911: PPUSH
54912: CALL_OW 1
54916: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54917: LD_ADDR_EXP 41
54921: PUSH
54922: LD_EXP 41
54926: PPUSH
54927: LD_VAR 0 2
54931: PPUSH
54932: EMPTY
54933: PPUSH
54934: CALL_OW 1
54938: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54939: LD_ADDR_EXP 42
54943: PUSH
54944: LD_EXP 42
54948: PPUSH
54949: LD_VAR 0 2
54953: PPUSH
54954: EMPTY
54955: PPUSH
54956: CALL_OW 1
54960: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54961: LD_ADDR_EXP 43
54965: PUSH
54966: LD_EXP 43
54970: PPUSH
54971: LD_VAR 0 2
54975: PPUSH
54976: EMPTY
54977: PPUSH
54978: CALL_OW 1
54982: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54983: LD_ADDR_EXP 44
54987: PUSH
54988: LD_EXP 44
54992: PPUSH
54993: LD_VAR 0 2
54997: PPUSH
54998: EMPTY
54999: PPUSH
55000: CALL_OW 1
55004: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55005: LD_ADDR_EXP 45
55009: PUSH
55010: LD_EXP 45
55014: PPUSH
55015: LD_VAR 0 2
55019: PPUSH
55020: EMPTY
55021: PPUSH
55022: CALL_OW 1
55026: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55027: LD_ADDR_EXP 34
55031: PUSH
55032: LD_EXP 34
55036: PPUSH
55037: LD_VAR 0 2
55041: PPUSH
55042: LD_INT 0
55044: PPUSH
55045: CALL_OW 1
55049: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55050: LD_ADDR_EXP 47
55054: PUSH
55055: LD_EXP 47
55059: PPUSH
55060: LD_VAR 0 2
55064: PPUSH
55065: LD_INT 0
55067: PPUSH
55068: CALL_OW 1
55072: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55073: LD_ADDR_EXP 35
55077: PUSH
55078: LD_EXP 35
55082: PPUSH
55083: LD_VAR 0 2
55087: PPUSH
55088: EMPTY
55089: PPUSH
55090: CALL_OW 1
55094: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55095: LD_ADDR_EXP 46
55099: PUSH
55100: LD_EXP 46
55104: PPUSH
55105: LD_VAR 0 2
55109: PPUSH
55110: LD_INT 0
55112: PPUSH
55113: CALL_OW 1
55117: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55118: LD_ADDR_EXP 48
55122: PUSH
55123: LD_EXP 48
55127: PPUSH
55128: LD_VAR 0 2
55132: PPUSH
55133: EMPTY
55134: PPUSH
55135: CALL_OW 1
55139: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55140: LD_ADDR_EXP 51
55144: PUSH
55145: LD_EXP 51
55149: PPUSH
55150: LD_VAR 0 2
55154: PPUSH
55155: LD_INT 0
55157: PPUSH
55158: CALL_OW 1
55162: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55163: LD_ADDR_EXP 52
55167: PUSH
55168: LD_EXP 52
55172: PPUSH
55173: LD_VAR 0 2
55177: PPUSH
55178: EMPTY
55179: PPUSH
55180: CALL_OW 1
55184: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55185: LD_ADDR_EXP 53
55189: PUSH
55190: LD_EXP 53
55194: PPUSH
55195: LD_VAR 0 2
55199: PPUSH
55200: EMPTY
55201: PPUSH
55202: CALL_OW 1
55206: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55207: LD_ADDR_EXP 54
55211: PUSH
55212: LD_EXP 54
55216: PPUSH
55217: LD_VAR 0 2
55221: PPUSH
55222: EMPTY
55223: PPUSH
55224: CALL_OW 1
55228: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55229: LD_ADDR_EXP 56
55233: PUSH
55234: LD_EXP 56
55238: PPUSH
55239: LD_VAR 0 2
55243: PPUSH
55244: LD_EXP 23
55248: PUSH
55249: LD_VAR 0 2
55253: ARRAY
55254: PPUSH
55255: LD_INT 2
55257: PUSH
55258: LD_INT 30
55260: PUSH
55261: LD_INT 6
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: PUSH
55268: LD_INT 30
55270: PUSH
55271: LD_INT 7
55273: PUSH
55274: EMPTY
55275: LIST
55276: LIST
55277: PUSH
55278: LD_INT 30
55280: PUSH
55281: LD_INT 8
55283: PUSH
55284: EMPTY
55285: LIST
55286: LIST
55287: PUSH
55288: EMPTY
55289: LIST
55290: LIST
55291: LIST
55292: LIST
55293: PPUSH
55294: CALL_OW 72
55298: PPUSH
55299: CALL_OW 1
55303: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55304: LD_ADDR_EXP 57
55308: PUSH
55309: LD_EXP 57
55313: PPUSH
55314: LD_VAR 0 2
55318: PPUSH
55319: EMPTY
55320: PPUSH
55321: CALL_OW 1
55325: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55326: LD_ADDR_EXP 58
55330: PUSH
55331: LD_EXP 58
55335: PPUSH
55336: LD_VAR 0 2
55340: PPUSH
55341: EMPTY
55342: PPUSH
55343: CALL_OW 1
55347: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55348: LD_ADDR_EXP 59
55352: PUSH
55353: LD_EXP 59
55357: PPUSH
55358: LD_VAR 0 2
55362: PPUSH
55363: EMPTY
55364: PPUSH
55365: CALL_OW 1
55369: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55370: LD_ADDR_EXP 60
55374: PUSH
55375: LD_EXP 60
55379: PPUSH
55380: LD_VAR 0 2
55384: PPUSH
55385: EMPTY
55386: PPUSH
55387: CALL_OW 1
55391: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55392: LD_ADDR_EXP 61
55396: PUSH
55397: LD_EXP 61
55401: PPUSH
55402: LD_VAR 0 2
55406: PPUSH
55407: EMPTY
55408: PPUSH
55409: CALL_OW 1
55413: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55414: LD_ADDR_EXP 62
55418: PUSH
55419: LD_EXP 62
55423: PPUSH
55424: LD_VAR 0 2
55428: PPUSH
55429: EMPTY
55430: PPUSH
55431: CALL_OW 1
55435: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55436: LD_ADDR_EXP 63
55440: PUSH
55441: LD_EXP 63
55445: PPUSH
55446: LD_VAR 0 2
55450: PPUSH
55451: EMPTY
55452: PPUSH
55453: CALL_OW 1
55457: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55458: LD_ADDR_EXP 64
55462: PUSH
55463: LD_EXP 64
55467: PPUSH
55468: LD_VAR 0 2
55472: PPUSH
55473: EMPTY
55474: PPUSH
55475: CALL_OW 1
55479: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55480: LD_ADDR_EXP 65
55484: PUSH
55485: LD_EXP 65
55489: PPUSH
55490: LD_VAR 0 2
55494: PPUSH
55495: LD_INT 0
55497: PPUSH
55498: CALL_OW 1
55502: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55503: LD_ADDR_EXP 66
55507: PUSH
55508: LD_EXP 66
55512: PPUSH
55513: LD_VAR 0 2
55517: PPUSH
55518: LD_INT 0
55520: PPUSH
55521: CALL_OW 1
55525: ST_TO_ADDR
// end ;
55526: GO 54427
55528: POP
55529: POP
// MC_InitSides ( ) ;
55530: CALL 55816 0 0
// MC_InitResearch ( ) ;
55534: CALL 55555 0 0
// CustomInitMacro ( ) ;
55538: CALL 277 0 0
// skirmish := true ;
55542: LD_ADDR_EXP 21
55546: PUSH
55547: LD_INT 1
55549: ST_TO_ADDR
// end ;
55550: LD_VAR 0 1
55554: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55555: LD_INT 0
55557: PPUSH
55558: PPUSH
55559: PPUSH
55560: PPUSH
55561: PPUSH
55562: PPUSH
// if not mc_bases then
55563: LD_EXP 23
55567: NOT
55568: IFFALSE 55572
// exit ;
55570: GO 55811
// for i = 1 to 8 do
55572: LD_ADDR_VAR 0 2
55576: PUSH
55577: DOUBLE
55578: LD_INT 1
55580: DEC
55581: ST_TO_ADDR
55582: LD_INT 8
55584: PUSH
55585: FOR_TO
55586: IFFALSE 55612
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55588: LD_ADDR_EXP 50
55592: PUSH
55593: LD_EXP 50
55597: PPUSH
55598: LD_VAR 0 2
55602: PPUSH
55603: EMPTY
55604: PPUSH
55605: CALL_OW 1
55609: ST_TO_ADDR
55610: GO 55585
55612: POP
55613: POP
// tmp := [ ] ;
55614: LD_ADDR_VAR 0 5
55618: PUSH
55619: EMPTY
55620: ST_TO_ADDR
// for i = 1 to mc_sides do
55621: LD_ADDR_VAR 0 2
55625: PUSH
55626: DOUBLE
55627: LD_INT 1
55629: DEC
55630: ST_TO_ADDR
55631: LD_EXP 49
55635: PUSH
55636: FOR_TO
55637: IFFALSE 55695
// if not mc_sides [ i ] in tmp then
55639: LD_EXP 49
55643: PUSH
55644: LD_VAR 0 2
55648: ARRAY
55649: PUSH
55650: LD_VAR 0 5
55654: IN
55655: NOT
55656: IFFALSE 55693
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55658: LD_ADDR_VAR 0 5
55662: PUSH
55663: LD_VAR 0 5
55667: PPUSH
55668: LD_VAR 0 5
55672: PUSH
55673: LD_INT 1
55675: PLUS
55676: PPUSH
55677: LD_EXP 49
55681: PUSH
55682: LD_VAR 0 2
55686: ARRAY
55687: PPUSH
55688: CALL_OW 2
55692: ST_TO_ADDR
55693: GO 55636
55695: POP
55696: POP
// if not tmp then
55697: LD_VAR 0 5
55701: NOT
55702: IFFALSE 55706
// exit ;
55704: GO 55811
// for j in tmp do
55706: LD_ADDR_VAR 0 3
55710: PUSH
55711: LD_VAR 0 5
55715: PUSH
55716: FOR_IN
55717: IFFALSE 55809
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55719: LD_ADDR_VAR 0 6
55723: PUSH
55724: LD_INT 22
55726: PUSH
55727: LD_VAR 0 3
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: PPUSH
55736: CALL_OW 69
55740: ST_TO_ADDR
// if not un then
55741: LD_VAR 0 6
55745: NOT
55746: IFFALSE 55750
// continue ;
55748: GO 55716
// nation := GetNation ( un [ 1 ] ) ;
55750: LD_ADDR_VAR 0 4
55754: PUSH
55755: LD_VAR 0 6
55759: PUSH
55760: LD_INT 1
55762: ARRAY
55763: PPUSH
55764: CALL_OW 248
55768: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55769: LD_ADDR_EXP 50
55773: PUSH
55774: LD_EXP 50
55778: PPUSH
55779: LD_VAR 0 3
55783: PPUSH
55784: LD_VAR 0 3
55788: PPUSH
55789: LD_VAR 0 4
55793: PPUSH
55794: LD_INT 1
55796: PPUSH
55797: CALL 11090 0 3
55801: PPUSH
55802: CALL_OW 1
55806: ST_TO_ADDR
// end ;
55807: GO 55716
55809: POP
55810: POP
// end ;
55811: LD_VAR 0 1
55815: RET
// export function MC_InitSides ( ) ; var i ; begin
55816: LD_INT 0
55818: PPUSH
55819: PPUSH
// if not mc_bases then
55820: LD_EXP 23
55824: NOT
55825: IFFALSE 55829
// exit ;
55827: GO 55903
// for i = 1 to mc_bases do
55829: LD_ADDR_VAR 0 2
55833: PUSH
55834: DOUBLE
55835: LD_INT 1
55837: DEC
55838: ST_TO_ADDR
55839: LD_EXP 23
55843: PUSH
55844: FOR_TO
55845: IFFALSE 55901
// if mc_bases [ i ] then
55847: LD_EXP 23
55851: PUSH
55852: LD_VAR 0 2
55856: ARRAY
55857: IFFALSE 55899
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55859: LD_ADDR_EXP 49
55863: PUSH
55864: LD_EXP 49
55868: PPUSH
55869: LD_VAR 0 2
55873: PPUSH
55874: LD_EXP 23
55878: PUSH
55879: LD_VAR 0 2
55883: ARRAY
55884: PUSH
55885: LD_INT 1
55887: ARRAY
55888: PPUSH
55889: CALL_OW 255
55893: PPUSH
55894: CALL_OW 1
55898: ST_TO_ADDR
55899: GO 55844
55901: POP
55902: POP
// end ;
55903: LD_VAR 0 1
55907: RET
// every 0 0$03 trigger skirmish do
55908: LD_EXP 21
55912: IFFALSE 56066
55914: GO 55916
55916: DISABLE
// begin enable ;
55917: ENABLE
// MC_CheckBuildings ( ) ;
55918: CALL 60564 0 0
// MC_CheckPeopleLife ( ) ;
55922: CALL 60725 0 0
// RaiseSailEvent ( 100 ) ;
55926: LD_INT 100
55928: PPUSH
55929: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55933: LD_INT 103
55935: PPUSH
55936: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55940: LD_INT 104
55942: PPUSH
55943: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55947: LD_INT 105
55949: PPUSH
55950: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55954: LD_INT 106
55956: PPUSH
55957: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55961: LD_INT 107
55963: PPUSH
55964: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55968: LD_INT 108
55970: PPUSH
55971: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55975: LD_INT 109
55977: PPUSH
55978: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55982: LD_INT 110
55984: PPUSH
55985: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55989: LD_INT 111
55991: PPUSH
55992: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55996: LD_INT 112
55998: PPUSH
55999: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56003: LD_INT 113
56005: PPUSH
56006: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56010: LD_INT 120
56012: PPUSH
56013: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56017: LD_INT 121
56019: PPUSH
56020: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56024: LD_INT 122
56026: PPUSH
56027: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56031: LD_INT 123
56033: PPUSH
56034: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56038: LD_INT 124
56040: PPUSH
56041: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56045: LD_INT 125
56047: PPUSH
56048: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56052: LD_INT 126
56054: PPUSH
56055: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56059: LD_INT 200
56061: PPUSH
56062: CALL_OW 427
// end ;
56066: END
// on SailEvent ( event ) do begin if event < 100 then
56067: LD_VAR 0 1
56071: PUSH
56072: LD_INT 100
56074: LESS
56075: IFFALSE 56086
// CustomEvent ( event ) ;
56077: LD_VAR 0 1
56081: PPUSH
56082: CALL 10241 0 1
// if event = 100 then
56086: LD_VAR 0 1
56090: PUSH
56091: LD_INT 100
56093: EQUAL
56094: IFFALSE 56100
// MC_ClassManager ( ) ;
56096: CALL 56492 0 0
// if event = 101 then
56100: LD_VAR 0 1
56104: PUSH
56105: LD_INT 101
56107: EQUAL
56108: IFFALSE 56114
// MC_RepairBuildings ( ) ;
56110: CALL 61310 0 0
// if event = 102 then
56114: LD_VAR 0 1
56118: PUSH
56119: LD_INT 102
56121: EQUAL
56122: IFFALSE 56128
// MC_Heal ( ) ;
56124: CALL 62217 0 0
// if event = 103 then
56128: LD_VAR 0 1
56132: PUSH
56133: LD_INT 103
56135: EQUAL
56136: IFFALSE 56142
// MC_Build ( ) ;
56138: CALL 62639 0 0
// if event = 104 then
56142: LD_VAR 0 1
56146: PUSH
56147: LD_INT 104
56149: EQUAL
56150: IFFALSE 56156
// MC_TurretWeapon ( ) ;
56152: CALL 64280 0 0
// if event = 105 then
56156: LD_VAR 0 1
56160: PUSH
56161: LD_INT 105
56163: EQUAL
56164: IFFALSE 56170
// MC_BuildUpgrade ( ) ;
56166: CALL 63831 0 0
// if event = 106 then
56170: LD_VAR 0 1
56174: PUSH
56175: LD_INT 106
56177: EQUAL
56178: IFFALSE 56184
// MC_PlantMines ( ) ;
56180: CALL 64710 0 0
// if event = 107 then
56184: LD_VAR 0 1
56188: PUSH
56189: LD_INT 107
56191: EQUAL
56192: IFFALSE 56198
// MC_CollectCrates ( ) ;
56194: CALL 65501 0 0
// if event = 108 then
56198: LD_VAR 0 1
56202: PUSH
56203: LD_INT 108
56205: EQUAL
56206: IFFALSE 56212
// MC_LinkRemoteControl ( ) ;
56208: CALL 67351 0 0
// if event = 109 then
56212: LD_VAR 0 1
56216: PUSH
56217: LD_INT 109
56219: EQUAL
56220: IFFALSE 56226
// MC_ProduceVehicle ( ) ;
56222: CALL 67532 0 0
// if event = 110 then
56226: LD_VAR 0 1
56230: PUSH
56231: LD_INT 110
56233: EQUAL
56234: IFFALSE 56240
// MC_SendAttack ( ) ;
56236: CALL 67998 0 0
// if event = 111 then
56240: LD_VAR 0 1
56244: PUSH
56245: LD_INT 111
56247: EQUAL
56248: IFFALSE 56254
// MC_Defend ( ) ;
56250: CALL 68106 0 0
// if event = 112 then
56254: LD_VAR 0 1
56258: PUSH
56259: LD_INT 112
56261: EQUAL
56262: IFFALSE 56268
// MC_Research ( ) ;
56264: CALL 68986 0 0
// if event = 113 then
56268: LD_VAR 0 1
56272: PUSH
56273: LD_INT 113
56275: EQUAL
56276: IFFALSE 56282
// MC_MinesTrigger ( ) ;
56278: CALL 70100 0 0
// if event = 120 then
56282: LD_VAR 0 1
56286: PUSH
56287: LD_INT 120
56289: EQUAL
56290: IFFALSE 56296
// MC_RepairVehicle ( ) ;
56292: CALL 70199 0 0
// if event = 121 then
56296: LD_VAR 0 1
56300: PUSH
56301: LD_INT 121
56303: EQUAL
56304: IFFALSE 56310
// MC_TameApe ( ) ;
56306: CALL 70940 0 0
// if event = 122 then
56310: LD_VAR 0 1
56314: PUSH
56315: LD_INT 122
56317: EQUAL
56318: IFFALSE 56324
// MC_ChangeApeClass ( ) ;
56320: CALL 71769 0 0
// if event = 123 then
56324: LD_VAR 0 1
56328: PUSH
56329: LD_INT 123
56331: EQUAL
56332: IFFALSE 56338
// MC_Bazooka ( ) ;
56334: CALL 72419 0 0
// if event = 124 then
56338: LD_VAR 0 1
56342: PUSH
56343: LD_INT 124
56345: EQUAL
56346: IFFALSE 56352
// MC_TeleportExit ( ) ;
56348: CALL 72617 0 0
// if event = 125 then
56352: LD_VAR 0 1
56356: PUSH
56357: LD_INT 125
56359: EQUAL
56360: IFFALSE 56366
// MC_Deposits ( ) ;
56362: CALL 73264 0 0
// if event = 126 then
56366: LD_VAR 0 1
56370: PUSH
56371: LD_INT 126
56373: EQUAL
56374: IFFALSE 56380
// MC_RemoteDriver ( ) ;
56376: CALL 73889 0 0
// if event = 200 then
56380: LD_VAR 0 1
56384: PUSH
56385: LD_INT 200
56387: EQUAL
56388: IFFALSE 56394
// MC_Idle ( ) ;
56390: CALL 75838 0 0
// end ;
56394: PPOPN 1
56396: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56397: LD_INT 0
56399: PPUSH
56400: PPUSH
// if not mc_bases [ base ] or not tag then
56401: LD_EXP 23
56405: PUSH
56406: LD_VAR 0 1
56410: ARRAY
56411: NOT
56412: PUSH
56413: LD_VAR 0 2
56417: NOT
56418: OR
56419: IFFALSE 56423
// exit ;
56421: GO 56487
// for i in mc_bases [ base ] union mc_ape [ base ] do
56423: LD_ADDR_VAR 0 4
56427: PUSH
56428: LD_EXP 23
56432: PUSH
56433: LD_VAR 0 1
56437: ARRAY
56438: PUSH
56439: LD_EXP 52
56443: PUSH
56444: LD_VAR 0 1
56448: ARRAY
56449: UNION
56450: PUSH
56451: FOR_IN
56452: IFFALSE 56485
// if GetTag ( i ) = tag then
56454: LD_VAR 0 4
56458: PPUSH
56459: CALL_OW 110
56463: PUSH
56464: LD_VAR 0 2
56468: EQUAL
56469: IFFALSE 56483
// SetTag ( i , 0 ) ;
56471: LD_VAR 0 4
56475: PPUSH
56476: LD_INT 0
56478: PPUSH
56479: CALL_OW 109
56483: GO 56451
56485: POP
56486: POP
// end ;
56487: LD_VAR 0 3
56491: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56492: LD_INT 0
56494: PPUSH
56495: PPUSH
56496: PPUSH
56497: PPUSH
56498: PPUSH
56499: PPUSH
56500: PPUSH
56501: PPUSH
// if not mc_bases then
56502: LD_EXP 23
56506: NOT
56507: IFFALSE 56511
// exit ;
56509: GO 56969
// for i = 1 to mc_bases do
56511: LD_ADDR_VAR 0 2
56515: PUSH
56516: DOUBLE
56517: LD_INT 1
56519: DEC
56520: ST_TO_ADDR
56521: LD_EXP 23
56525: PUSH
56526: FOR_TO
56527: IFFALSE 56967
// begin tmp := MC_ClassCheckReq ( i ) ;
56529: LD_ADDR_VAR 0 4
56533: PUSH
56534: LD_VAR 0 2
56538: PPUSH
56539: CALL 56974 0 1
56543: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56544: LD_ADDR_EXP 64
56548: PUSH
56549: LD_EXP 64
56553: PPUSH
56554: LD_VAR 0 2
56558: PPUSH
56559: LD_VAR 0 4
56563: PPUSH
56564: CALL_OW 1
56568: ST_TO_ADDR
// if not tmp then
56569: LD_VAR 0 4
56573: NOT
56574: IFFALSE 56578
// continue ;
56576: GO 56526
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56578: LD_ADDR_VAR 0 6
56582: PUSH
56583: LD_EXP 23
56587: PUSH
56588: LD_VAR 0 2
56592: ARRAY
56593: PPUSH
56594: LD_INT 2
56596: PUSH
56597: LD_INT 30
56599: PUSH
56600: LD_INT 4
56602: PUSH
56603: EMPTY
56604: LIST
56605: LIST
56606: PUSH
56607: LD_INT 30
56609: PUSH
56610: LD_INT 5
56612: PUSH
56613: EMPTY
56614: LIST
56615: LIST
56616: PUSH
56617: EMPTY
56618: LIST
56619: LIST
56620: LIST
56621: PPUSH
56622: CALL_OW 72
56626: PUSH
56627: LD_EXP 23
56631: PUSH
56632: LD_VAR 0 2
56636: ARRAY
56637: PPUSH
56638: LD_INT 2
56640: PUSH
56641: LD_INT 30
56643: PUSH
56644: LD_INT 0
56646: PUSH
56647: EMPTY
56648: LIST
56649: LIST
56650: PUSH
56651: LD_INT 30
56653: PUSH
56654: LD_INT 1
56656: PUSH
56657: EMPTY
56658: LIST
56659: LIST
56660: PUSH
56661: EMPTY
56662: LIST
56663: LIST
56664: LIST
56665: PPUSH
56666: CALL_OW 72
56670: PUSH
56671: LD_EXP 23
56675: PUSH
56676: LD_VAR 0 2
56680: ARRAY
56681: PPUSH
56682: LD_INT 30
56684: PUSH
56685: LD_INT 3
56687: PUSH
56688: EMPTY
56689: LIST
56690: LIST
56691: PPUSH
56692: CALL_OW 72
56696: PUSH
56697: LD_EXP 23
56701: PUSH
56702: LD_VAR 0 2
56706: ARRAY
56707: PPUSH
56708: LD_INT 2
56710: PUSH
56711: LD_INT 30
56713: PUSH
56714: LD_INT 6
56716: PUSH
56717: EMPTY
56718: LIST
56719: LIST
56720: PUSH
56721: LD_INT 30
56723: PUSH
56724: LD_INT 7
56726: PUSH
56727: EMPTY
56728: LIST
56729: LIST
56730: PUSH
56731: LD_INT 30
56733: PUSH
56734: LD_INT 8
56736: PUSH
56737: EMPTY
56738: LIST
56739: LIST
56740: PUSH
56741: EMPTY
56742: LIST
56743: LIST
56744: LIST
56745: LIST
56746: PPUSH
56747: CALL_OW 72
56751: PUSH
56752: EMPTY
56753: LIST
56754: LIST
56755: LIST
56756: LIST
56757: ST_TO_ADDR
// for j = 1 to 4 do
56758: LD_ADDR_VAR 0 3
56762: PUSH
56763: DOUBLE
56764: LD_INT 1
56766: DEC
56767: ST_TO_ADDR
56768: LD_INT 4
56770: PUSH
56771: FOR_TO
56772: IFFALSE 56963
// begin if not tmp [ j ] then
56774: LD_VAR 0 4
56778: PUSH
56779: LD_VAR 0 3
56783: ARRAY
56784: NOT
56785: IFFALSE 56789
// continue ;
56787: GO 56771
// for p in tmp [ j ] do
56789: LD_ADDR_VAR 0 5
56793: PUSH
56794: LD_VAR 0 4
56798: PUSH
56799: LD_VAR 0 3
56803: ARRAY
56804: PUSH
56805: FOR_IN
56806: IFFALSE 56959
// begin if not b [ j ] then
56808: LD_VAR 0 6
56812: PUSH
56813: LD_VAR 0 3
56817: ARRAY
56818: NOT
56819: IFFALSE 56823
// break ;
56821: GO 56959
// e := 0 ;
56823: LD_ADDR_VAR 0 7
56827: PUSH
56828: LD_INT 0
56830: ST_TO_ADDR
// for k in b [ j ] do
56831: LD_ADDR_VAR 0 8
56835: PUSH
56836: LD_VAR 0 6
56840: PUSH
56841: LD_VAR 0 3
56845: ARRAY
56846: PUSH
56847: FOR_IN
56848: IFFALSE 56875
// if IsNotFull ( k ) then
56850: LD_VAR 0 8
56854: PPUSH
56855: CALL 13243 0 1
56859: IFFALSE 56873
// begin e := k ;
56861: LD_ADDR_VAR 0 7
56865: PUSH
56866: LD_VAR 0 8
56870: ST_TO_ADDR
// break ;
56871: GO 56875
// end ;
56873: GO 56847
56875: POP
56876: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56877: LD_VAR 0 7
56881: PUSH
56882: LD_VAR 0 5
56886: PPUSH
56887: LD_VAR 0 7
56891: PPUSH
56892: CALL 47074 0 2
56896: NOT
56897: AND
56898: IFFALSE 56957
// begin if IsInUnit ( p ) then
56900: LD_VAR 0 5
56904: PPUSH
56905: CALL_OW 310
56909: IFFALSE 56920
// ComExitBuilding ( p ) ;
56911: LD_VAR 0 5
56915: PPUSH
56916: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56920: LD_VAR 0 5
56924: PPUSH
56925: LD_VAR 0 7
56929: PPUSH
56930: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56934: LD_VAR 0 5
56938: PPUSH
56939: LD_VAR 0 3
56943: PPUSH
56944: CALL_OW 183
// AddComExitBuilding ( p ) ;
56948: LD_VAR 0 5
56952: PPUSH
56953: CALL_OW 182
// end ; end ;
56957: GO 56805
56959: POP
56960: POP
// end ;
56961: GO 56771
56963: POP
56964: POP
// end ;
56965: GO 56526
56967: POP
56968: POP
// end ;
56969: LD_VAR 0 1
56973: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56974: LD_INT 0
56976: PPUSH
56977: PPUSH
56978: PPUSH
56979: PPUSH
56980: PPUSH
56981: PPUSH
56982: PPUSH
56983: PPUSH
56984: PPUSH
56985: PPUSH
56986: PPUSH
56987: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56988: LD_VAR 0 1
56992: NOT
56993: PUSH
56994: LD_EXP 23
56998: PUSH
56999: LD_VAR 0 1
57003: ARRAY
57004: NOT
57005: OR
57006: PUSH
57007: LD_EXP 23
57011: PUSH
57012: LD_VAR 0 1
57016: ARRAY
57017: PPUSH
57018: LD_INT 2
57020: PUSH
57021: LD_INT 30
57023: PUSH
57024: LD_INT 0
57026: PUSH
57027: EMPTY
57028: LIST
57029: LIST
57030: PUSH
57031: LD_INT 30
57033: PUSH
57034: LD_INT 1
57036: PUSH
57037: EMPTY
57038: LIST
57039: LIST
57040: PUSH
57041: EMPTY
57042: LIST
57043: LIST
57044: LIST
57045: PPUSH
57046: CALL_OW 72
57050: NOT
57051: OR
57052: IFFALSE 57056
// exit ;
57054: GO 60559
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57056: LD_ADDR_VAR 0 4
57060: PUSH
57061: LD_EXP 23
57065: PUSH
57066: LD_VAR 0 1
57070: ARRAY
57071: PPUSH
57072: LD_INT 2
57074: PUSH
57075: LD_INT 25
57077: PUSH
57078: LD_INT 1
57080: PUSH
57081: EMPTY
57082: LIST
57083: LIST
57084: PUSH
57085: LD_INT 25
57087: PUSH
57088: LD_INT 2
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: PUSH
57095: LD_INT 25
57097: PUSH
57098: LD_INT 3
57100: PUSH
57101: EMPTY
57102: LIST
57103: LIST
57104: PUSH
57105: LD_INT 25
57107: PUSH
57108: LD_INT 4
57110: PUSH
57111: EMPTY
57112: LIST
57113: LIST
57114: PUSH
57115: LD_INT 25
57117: PUSH
57118: LD_INT 5
57120: PUSH
57121: EMPTY
57122: LIST
57123: LIST
57124: PUSH
57125: LD_INT 25
57127: PUSH
57128: LD_INT 8
57130: PUSH
57131: EMPTY
57132: LIST
57133: LIST
57134: PUSH
57135: LD_INT 25
57137: PUSH
57138: LD_INT 9
57140: PUSH
57141: EMPTY
57142: LIST
57143: LIST
57144: PUSH
57145: EMPTY
57146: LIST
57147: LIST
57148: LIST
57149: LIST
57150: LIST
57151: LIST
57152: LIST
57153: LIST
57154: PPUSH
57155: CALL_OW 72
57159: ST_TO_ADDR
// if not tmp then
57160: LD_VAR 0 4
57164: NOT
57165: IFFALSE 57169
// exit ;
57167: GO 60559
// for i in tmp do
57169: LD_ADDR_VAR 0 3
57173: PUSH
57174: LD_VAR 0 4
57178: PUSH
57179: FOR_IN
57180: IFFALSE 57211
// if GetTag ( i ) then
57182: LD_VAR 0 3
57186: PPUSH
57187: CALL_OW 110
57191: IFFALSE 57209
// tmp := tmp diff i ;
57193: LD_ADDR_VAR 0 4
57197: PUSH
57198: LD_VAR 0 4
57202: PUSH
57203: LD_VAR 0 3
57207: DIFF
57208: ST_TO_ADDR
57209: GO 57179
57211: POP
57212: POP
// if not tmp then
57213: LD_VAR 0 4
57217: NOT
57218: IFFALSE 57222
// exit ;
57220: GO 60559
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57222: LD_ADDR_VAR 0 5
57226: PUSH
57227: LD_EXP 23
57231: PUSH
57232: LD_VAR 0 1
57236: ARRAY
57237: PPUSH
57238: LD_INT 2
57240: PUSH
57241: LD_INT 25
57243: PUSH
57244: LD_INT 1
57246: PUSH
57247: EMPTY
57248: LIST
57249: LIST
57250: PUSH
57251: LD_INT 25
57253: PUSH
57254: LD_INT 5
57256: PUSH
57257: EMPTY
57258: LIST
57259: LIST
57260: PUSH
57261: LD_INT 25
57263: PUSH
57264: LD_INT 8
57266: PUSH
57267: EMPTY
57268: LIST
57269: LIST
57270: PUSH
57271: LD_INT 25
57273: PUSH
57274: LD_INT 9
57276: PUSH
57277: EMPTY
57278: LIST
57279: LIST
57280: PUSH
57281: EMPTY
57282: LIST
57283: LIST
57284: LIST
57285: LIST
57286: LIST
57287: PPUSH
57288: CALL_OW 72
57292: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57293: LD_ADDR_VAR 0 6
57297: PUSH
57298: LD_EXP 23
57302: PUSH
57303: LD_VAR 0 1
57307: ARRAY
57308: PPUSH
57309: LD_INT 25
57311: PUSH
57312: LD_INT 2
57314: PUSH
57315: EMPTY
57316: LIST
57317: LIST
57318: PPUSH
57319: CALL_OW 72
57323: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57324: LD_ADDR_VAR 0 7
57328: PUSH
57329: LD_EXP 23
57333: PUSH
57334: LD_VAR 0 1
57338: ARRAY
57339: PPUSH
57340: LD_INT 25
57342: PUSH
57343: LD_INT 3
57345: PUSH
57346: EMPTY
57347: LIST
57348: LIST
57349: PPUSH
57350: CALL_OW 72
57354: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57355: LD_ADDR_VAR 0 8
57359: PUSH
57360: LD_EXP 23
57364: PUSH
57365: LD_VAR 0 1
57369: ARRAY
57370: PPUSH
57371: LD_INT 25
57373: PUSH
57374: LD_INT 4
57376: PUSH
57377: EMPTY
57378: LIST
57379: LIST
57380: PUSH
57381: LD_INT 24
57383: PUSH
57384: LD_INT 251
57386: PUSH
57387: EMPTY
57388: LIST
57389: LIST
57390: PUSH
57391: EMPTY
57392: LIST
57393: LIST
57394: PPUSH
57395: CALL_OW 72
57399: ST_TO_ADDR
// if mc_is_defending [ base ] then
57400: LD_EXP 66
57404: PUSH
57405: LD_VAR 0 1
57409: ARRAY
57410: IFFALSE 57871
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57412: LD_ADDR_EXP 65
57416: PUSH
57417: LD_EXP 65
57421: PPUSH
57422: LD_VAR 0 1
57426: PPUSH
57427: LD_INT 4
57429: PPUSH
57430: CALL_OW 1
57434: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57435: LD_ADDR_VAR 0 12
57439: PUSH
57440: LD_EXP 23
57444: PUSH
57445: LD_VAR 0 1
57449: ARRAY
57450: PPUSH
57451: LD_INT 2
57453: PUSH
57454: LD_INT 30
57456: PUSH
57457: LD_INT 4
57459: PUSH
57460: EMPTY
57461: LIST
57462: LIST
57463: PUSH
57464: LD_INT 30
57466: PUSH
57467: LD_INT 5
57469: PUSH
57470: EMPTY
57471: LIST
57472: LIST
57473: PUSH
57474: EMPTY
57475: LIST
57476: LIST
57477: LIST
57478: PPUSH
57479: CALL_OW 72
57483: ST_TO_ADDR
// if not b then
57484: LD_VAR 0 12
57488: NOT
57489: IFFALSE 57493
// exit ;
57491: GO 60559
// p := [ ] ;
57493: LD_ADDR_VAR 0 11
57497: PUSH
57498: EMPTY
57499: ST_TO_ADDR
// if sci >= 2 then
57500: LD_VAR 0 8
57504: PUSH
57505: LD_INT 2
57507: GREATEREQUAL
57508: IFFALSE 57539
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57510: LD_ADDR_VAR 0 8
57514: PUSH
57515: LD_VAR 0 8
57519: PUSH
57520: LD_INT 1
57522: ARRAY
57523: PUSH
57524: LD_VAR 0 8
57528: PUSH
57529: LD_INT 2
57531: ARRAY
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: ST_TO_ADDR
57537: GO 57600
// if sci = 1 then
57539: LD_VAR 0 8
57543: PUSH
57544: LD_INT 1
57546: EQUAL
57547: IFFALSE 57568
// sci := [ sci [ 1 ] ] else
57549: LD_ADDR_VAR 0 8
57553: PUSH
57554: LD_VAR 0 8
57558: PUSH
57559: LD_INT 1
57561: ARRAY
57562: PUSH
57563: EMPTY
57564: LIST
57565: ST_TO_ADDR
57566: GO 57600
// if sci = 0 then
57568: LD_VAR 0 8
57572: PUSH
57573: LD_INT 0
57575: EQUAL
57576: IFFALSE 57600
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57578: LD_ADDR_VAR 0 11
57582: PUSH
57583: LD_VAR 0 4
57587: PPUSH
57588: LD_INT 4
57590: PPUSH
57591: CALL 46937 0 2
57595: PUSH
57596: LD_INT 1
57598: ARRAY
57599: ST_TO_ADDR
// if eng > 4 then
57600: LD_VAR 0 6
57604: PUSH
57605: LD_INT 4
57607: GREATER
57608: IFFALSE 57654
// for i = eng downto 4 do
57610: LD_ADDR_VAR 0 3
57614: PUSH
57615: DOUBLE
57616: LD_VAR 0 6
57620: INC
57621: ST_TO_ADDR
57622: LD_INT 4
57624: PUSH
57625: FOR_DOWNTO
57626: IFFALSE 57652
// eng := eng diff eng [ i ] ;
57628: LD_ADDR_VAR 0 6
57632: PUSH
57633: LD_VAR 0 6
57637: PUSH
57638: LD_VAR 0 6
57642: PUSH
57643: LD_VAR 0 3
57647: ARRAY
57648: DIFF
57649: ST_TO_ADDR
57650: GO 57625
57652: POP
57653: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57654: LD_ADDR_VAR 0 4
57658: PUSH
57659: LD_VAR 0 4
57663: PUSH
57664: LD_VAR 0 5
57668: PUSH
57669: LD_VAR 0 6
57673: UNION
57674: PUSH
57675: LD_VAR 0 7
57679: UNION
57680: PUSH
57681: LD_VAR 0 8
57685: UNION
57686: DIFF
57687: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57688: LD_ADDR_VAR 0 13
57692: PUSH
57693: LD_EXP 23
57697: PUSH
57698: LD_VAR 0 1
57702: ARRAY
57703: PPUSH
57704: LD_INT 2
57706: PUSH
57707: LD_INT 30
57709: PUSH
57710: LD_INT 32
57712: PUSH
57713: EMPTY
57714: LIST
57715: LIST
57716: PUSH
57717: LD_INT 30
57719: PUSH
57720: LD_INT 31
57722: PUSH
57723: EMPTY
57724: LIST
57725: LIST
57726: PUSH
57727: EMPTY
57728: LIST
57729: LIST
57730: LIST
57731: PPUSH
57732: CALL_OW 72
57736: PUSH
57737: LD_EXP 23
57741: PUSH
57742: LD_VAR 0 1
57746: ARRAY
57747: PPUSH
57748: LD_INT 2
57750: PUSH
57751: LD_INT 30
57753: PUSH
57754: LD_INT 4
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: PUSH
57761: LD_INT 30
57763: PUSH
57764: LD_INT 5
57766: PUSH
57767: EMPTY
57768: LIST
57769: LIST
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: LIST
57775: PPUSH
57776: CALL_OW 72
57780: PUSH
57781: LD_INT 6
57783: MUL
57784: PLUS
57785: ST_TO_ADDR
// if bcount < tmp then
57786: LD_VAR 0 13
57790: PUSH
57791: LD_VAR 0 4
57795: LESS
57796: IFFALSE 57842
// for i = tmp downto bcount do
57798: LD_ADDR_VAR 0 3
57802: PUSH
57803: DOUBLE
57804: LD_VAR 0 4
57808: INC
57809: ST_TO_ADDR
57810: LD_VAR 0 13
57814: PUSH
57815: FOR_DOWNTO
57816: IFFALSE 57840
// tmp := Delete ( tmp , tmp ) ;
57818: LD_ADDR_VAR 0 4
57822: PUSH
57823: LD_VAR 0 4
57827: PPUSH
57828: LD_VAR 0 4
57832: PPUSH
57833: CALL_OW 3
57837: ST_TO_ADDR
57838: GO 57815
57840: POP
57841: POP
// result := [ tmp , 0 , 0 , p ] ;
57842: LD_ADDR_VAR 0 2
57846: PUSH
57847: LD_VAR 0 4
57851: PUSH
57852: LD_INT 0
57854: PUSH
57855: LD_INT 0
57857: PUSH
57858: LD_VAR 0 11
57862: PUSH
57863: EMPTY
57864: LIST
57865: LIST
57866: LIST
57867: LIST
57868: ST_TO_ADDR
// exit ;
57869: GO 60559
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57871: LD_EXP 23
57875: PUSH
57876: LD_VAR 0 1
57880: ARRAY
57881: PPUSH
57882: LD_INT 2
57884: PUSH
57885: LD_INT 30
57887: PUSH
57888: LD_INT 6
57890: PUSH
57891: EMPTY
57892: LIST
57893: LIST
57894: PUSH
57895: LD_INT 30
57897: PUSH
57898: LD_INT 7
57900: PUSH
57901: EMPTY
57902: LIST
57903: LIST
57904: PUSH
57905: LD_INT 30
57907: PUSH
57908: LD_INT 8
57910: PUSH
57911: EMPTY
57912: LIST
57913: LIST
57914: PUSH
57915: EMPTY
57916: LIST
57917: LIST
57918: LIST
57919: LIST
57920: PPUSH
57921: CALL_OW 72
57925: NOT
57926: PUSH
57927: LD_EXP 23
57931: PUSH
57932: LD_VAR 0 1
57936: ARRAY
57937: PPUSH
57938: LD_INT 30
57940: PUSH
57941: LD_INT 3
57943: PUSH
57944: EMPTY
57945: LIST
57946: LIST
57947: PPUSH
57948: CALL_OW 72
57952: NOT
57953: AND
57954: IFFALSE 58026
// begin if eng = tmp then
57956: LD_VAR 0 6
57960: PUSH
57961: LD_VAR 0 4
57965: EQUAL
57966: IFFALSE 57970
// exit ;
57968: GO 60559
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57970: LD_ADDR_EXP 65
57974: PUSH
57975: LD_EXP 65
57979: PPUSH
57980: LD_VAR 0 1
57984: PPUSH
57985: LD_INT 1
57987: PPUSH
57988: CALL_OW 1
57992: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57993: LD_ADDR_VAR 0 2
57997: PUSH
57998: LD_INT 0
58000: PUSH
58001: LD_VAR 0 4
58005: PUSH
58006: LD_VAR 0 6
58010: DIFF
58011: PUSH
58012: LD_INT 0
58014: PUSH
58015: LD_INT 0
58017: PUSH
58018: EMPTY
58019: LIST
58020: LIST
58021: LIST
58022: LIST
58023: ST_TO_ADDR
// exit ;
58024: GO 60559
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58026: LD_EXP 50
58030: PUSH
58031: LD_EXP 49
58035: PUSH
58036: LD_VAR 0 1
58040: ARRAY
58041: ARRAY
58042: PUSH
58043: LD_EXP 23
58047: PUSH
58048: LD_VAR 0 1
58052: ARRAY
58053: PPUSH
58054: LD_INT 2
58056: PUSH
58057: LD_INT 30
58059: PUSH
58060: LD_INT 6
58062: PUSH
58063: EMPTY
58064: LIST
58065: LIST
58066: PUSH
58067: LD_INT 30
58069: PUSH
58070: LD_INT 7
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: PUSH
58077: LD_INT 30
58079: PUSH
58080: LD_INT 8
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: PUSH
58087: EMPTY
58088: LIST
58089: LIST
58090: LIST
58091: LIST
58092: PPUSH
58093: CALL_OW 72
58097: AND
58098: PUSH
58099: LD_EXP 23
58103: PUSH
58104: LD_VAR 0 1
58108: ARRAY
58109: PPUSH
58110: LD_INT 30
58112: PUSH
58113: LD_INT 3
58115: PUSH
58116: EMPTY
58117: LIST
58118: LIST
58119: PPUSH
58120: CALL_OW 72
58124: NOT
58125: AND
58126: IFFALSE 58340
// begin if sci >= 6 then
58128: LD_VAR 0 8
58132: PUSH
58133: LD_INT 6
58135: GREATEREQUAL
58136: IFFALSE 58140
// exit ;
58138: GO 60559
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58140: LD_ADDR_EXP 65
58144: PUSH
58145: LD_EXP 65
58149: PPUSH
58150: LD_VAR 0 1
58154: PPUSH
58155: LD_INT 2
58157: PPUSH
58158: CALL_OW 1
58162: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58163: LD_ADDR_VAR 0 9
58167: PUSH
58168: LD_VAR 0 4
58172: PUSH
58173: LD_VAR 0 8
58177: DIFF
58178: PPUSH
58179: LD_INT 4
58181: PPUSH
58182: CALL 46937 0 2
58186: ST_TO_ADDR
// p := [ ] ;
58187: LD_ADDR_VAR 0 11
58191: PUSH
58192: EMPTY
58193: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58194: LD_VAR 0 8
58198: PUSH
58199: LD_INT 6
58201: LESS
58202: PUSH
58203: LD_VAR 0 9
58207: PUSH
58208: LD_INT 6
58210: GREATER
58211: AND
58212: IFFALSE 58293
// begin for i = 1 to 6 - sci do
58214: LD_ADDR_VAR 0 3
58218: PUSH
58219: DOUBLE
58220: LD_INT 1
58222: DEC
58223: ST_TO_ADDR
58224: LD_INT 6
58226: PUSH
58227: LD_VAR 0 8
58231: MINUS
58232: PUSH
58233: FOR_TO
58234: IFFALSE 58289
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58236: LD_ADDR_VAR 0 11
58240: PUSH
58241: LD_VAR 0 11
58245: PPUSH
58246: LD_VAR 0 11
58250: PUSH
58251: LD_INT 1
58253: PLUS
58254: PPUSH
58255: LD_VAR 0 9
58259: PUSH
58260: LD_INT 1
58262: ARRAY
58263: PPUSH
58264: CALL_OW 2
58268: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58269: LD_ADDR_VAR 0 9
58273: PUSH
58274: LD_VAR 0 9
58278: PPUSH
58279: LD_INT 1
58281: PPUSH
58282: CALL_OW 3
58286: ST_TO_ADDR
// end ;
58287: GO 58233
58289: POP
58290: POP
// end else
58291: GO 58313
// if sort then
58293: LD_VAR 0 9
58297: IFFALSE 58313
// p := sort [ 1 ] ;
58299: LD_ADDR_VAR 0 11
58303: PUSH
58304: LD_VAR 0 9
58308: PUSH
58309: LD_INT 1
58311: ARRAY
58312: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58313: LD_ADDR_VAR 0 2
58317: PUSH
58318: LD_INT 0
58320: PUSH
58321: LD_INT 0
58323: PUSH
58324: LD_INT 0
58326: PUSH
58327: LD_VAR 0 11
58331: PUSH
58332: EMPTY
58333: LIST
58334: LIST
58335: LIST
58336: LIST
58337: ST_TO_ADDR
// exit ;
58338: GO 60559
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58340: LD_EXP 50
58344: PUSH
58345: LD_EXP 49
58349: PUSH
58350: LD_VAR 0 1
58354: ARRAY
58355: ARRAY
58356: PUSH
58357: LD_EXP 23
58361: PUSH
58362: LD_VAR 0 1
58366: ARRAY
58367: PPUSH
58368: LD_INT 2
58370: PUSH
58371: LD_INT 30
58373: PUSH
58374: LD_INT 6
58376: PUSH
58377: EMPTY
58378: LIST
58379: LIST
58380: PUSH
58381: LD_INT 30
58383: PUSH
58384: LD_INT 7
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: PUSH
58391: LD_INT 30
58393: PUSH
58394: LD_INT 8
58396: PUSH
58397: EMPTY
58398: LIST
58399: LIST
58400: PUSH
58401: EMPTY
58402: LIST
58403: LIST
58404: LIST
58405: LIST
58406: PPUSH
58407: CALL_OW 72
58411: AND
58412: PUSH
58413: LD_EXP 23
58417: PUSH
58418: LD_VAR 0 1
58422: ARRAY
58423: PPUSH
58424: LD_INT 30
58426: PUSH
58427: LD_INT 3
58429: PUSH
58430: EMPTY
58431: LIST
58432: LIST
58433: PPUSH
58434: CALL_OW 72
58438: AND
58439: IFFALSE 59173
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58441: LD_ADDR_EXP 65
58445: PUSH
58446: LD_EXP 65
58450: PPUSH
58451: LD_VAR 0 1
58455: PPUSH
58456: LD_INT 3
58458: PPUSH
58459: CALL_OW 1
58463: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58464: LD_ADDR_VAR 0 2
58468: PUSH
58469: LD_INT 0
58471: PUSH
58472: LD_INT 0
58474: PUSH
58475: LD_INT 0
58477: PUSH
58478: LD_INT 0
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: LIST
58485: LIST
58486: ST_TO_ADDR
// if not eng then
58487: LD_VAR 0 6
58491: NOT
58492: IFFALSE 58555
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58494: LD_ADDR_VAR 0 11
58498: PUSH
58499: LD_VAR 0 4
58503: PPUSH
58504: LD_INT 2
58506: PPUSH
58507: CALL 46937 0 2
58511: PUSH
58512: LD_INT 1
58514: ARRAY
58515: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58516: LD_ADDR_VAR 0 2
58520: PUSH
58521: LD_VAR 0 2
58525: PPUSH
58526: LD_INT 2
58528: PPUSH
58529: LD_VAR 0 11
58533: PPUSH
58534: CALL_OW 1
58538: ST_TO_ADDR
// tmp := tmp diff p ;
58539: LD_ADDR_VAR 0 4
58543: PUSH
58544: LD_VAR 0 4
58548: PUSH
58549: LD_VAR 0 11
58553: DIFF
58554: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58555: LD_VAR 0 4
58559: PUSH
58560: LD_VAR 0 8
58564: PUSH
58565: LD_INT 6
58567: LESS
58568: AND
58569: IFFALSE 58757
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58571: LD_ADDR_VAR 0 9
58575: PUSH
58576: LD_VAR 0 4
58580: PUSH
58581: LD_VAR 0 8
58585: PUSH
58586: LD_VAR 0 7
58590: UNION
58591: DIFF
58592: PPUSH
58593: LD_INT 4
58595: PPUSH
58596: CALL 46937 0 2
58600: ST_TO_ADDR
// p := [ ] ;
58601: LD_ADDR_VAR 0 11
58605: PUSH
58606: EMPTY
58607: ST_TO_ADDR
// if sort then
58608: LD_VAR 0 9
58612: IFFALSE 58728
// for i = 1 to 6 - sci do
58614: LD_ADDR_VAR 0 3
58618: PUSH
58619: DOUBLE
58620: LD_INT 1
58622: DEC
58623: ST_TO_ADDR
58624: LD_INT 6
58626: PUSH
58627: LD_VAR 0 8
58631: MINUS
58632: PUSH
58633: FOR_TO
58634: IFFALSE 58726
// begin if i = sort then
58636: LD_VAR 0 3
58640: PUSH
58641: LD_VAR 0 9
58645: EQUAL
58646: IFFALSE 58650
// break ;
58648: GO 58726
// if GetClass ( i ) = 4 then
58650: LD_VAR 0 3
58654: PPUSH
58655: CALL_OW 257
58659: PUSH
58660: LD_INT 4
58662: EQUAL
58663: IFFALSE 58667
// continue ;
58665: GO 58633
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58667: LD_ADDR_VAR 0 11
58671: PUSH
58672: LD_VAR 0 11
58676: PPUSH
58677: LD_VAR 0 11
58681: PUSH
58682: LD_INT 1
58684: PLUS
58685: PPUSH
58686: LD_VAR 0 9
58690: PUSH
58691: LD_VAR 0 3
58695: ARRAY
58696: PPUSH
58697: CALL_OW 2
58701: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58702: LD_ADDR_VAR 0 4
58706: PUSH
58707: LD_VAR 0 4
58711: PUSH
58712: LD_VAR 0 9
58716: PUSH
58717: LD_VAR 0 3
58721: ARRAY
58722: DIFF
58723: ST_TO_ADDR
// end ;
58724: GO 58633
58726: POP
58727: POP
// if p then
58728: LD_VAR 0 11
58732: IFFALSE 58757
// result := Replace ( result , 4 , p ) ;
58734: LD_ADDR_VAR 0 2
58738: PUSH
58739: LD_VAR 0 2
58743: PPUSH
58744: LD_INT 4
58746: PPUSH
58747: LD_VAR 0 11
58751: PPUSH
58752: CALL_OW 1
58756: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58757: LD_VAR 0 4
58761: PUSH
58762: LD_VAR 0 7
58766: PUSH
58767: LD_INT 6
58769: LESS
58770: AND
58771: IFFALSE 58959
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58773: LD_ADDR_VAR 0 9
58777: PUSH
58778: LD_VAR 0 4
58782: PUSH
58783: LD_VAR 0 8
58787: PUSH
58788: LD_VAR 0 7
58792: UNION
58793: DIFF
58794: PPUSH
58795: LD_INT 3
58797: PPUSH
58798: CALL 46937 0 2
58802: ST_TO_ADDR
// p := [ ] ;
58803: LD_ADDR_VAR 0 11
58807: PUSH
58808: EMPTY
58809: ST_TO_ADDR
// if sort then
58810: LD_VAR 0 9
58814: IFFALSE 58930
// for i = 1 to 6 - mech do
58816: LD_ADDR_VAR 0 3
58820: PUSH
58821: DOUBLE
58822: LD_INT 1
58824: DEC
58825: ST_TO_ADDR
58826: LD_INT 6
58828: PUSH
58829: LD_VAR 0 7
58833: MINUS
58834: PUSH
58835: FOR_TO
58836: IFFALSE 58928
// begin if i = sort then
58838: LD_VAR 0 3
58842: PUSH
58843: LD_VAR 0 9
58847: EQUAL
58848: IFFALSE 58852
// break ;
58850: GO 58928
// if GetClass ( i ) = 3 then
58852: LD_VAR 0 3
58856: PPUSH
58857: CALL_OW 257
58861: PUSH
58862: LD_INT 3
58864: EQUAL
58865: IFFALSE 58869
// continue ;
58867: GO 58835
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58869: LD_ADDR_VAR 0 11
58873: PUSH
58874: LD_VAR 0 11
58878: PPUSH
58879: LD_VAR 0 11
58883: PUSH
58884: LD_INT 1
58886: PLUS
58887: PPUSH
58888: LD_VAR 0 9
58892: PUSH
58893: LD_VAR 0 3
58897: ARRAY
58898: PPUSH
58899: CALL_OW 2
58903: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58904: LD_ADDR_VAR 0 4
58908: PUSH
58909: LD_VAR 0 4
58913: PUSH
58914: LD_VAR 0 9
58918: PUSH
58919: LD_VAR 0 3
58923: ARRAY
58924: DIFF
58925: ST_TO_ADDR
// end ;
58926: GO 58835
58928: POP
58929: POP
// if p then
58930: LD_VAR 0 11
58934: IFFALSE 58959
// result := Replace ( result , 3 , p ) ;
58936: LD_ADDR_VAR 0 2
58940: PUSH
58941: LD_VAR 0 2
58945: PPUSH
58946: LD_INT 3
58948: PPUSH
58949: LD_VAR 0 11
58953: PPUSH
58954: CALL_OW 1
58958: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58959: LD_VAR 0 4
58963: PUSH
58964: LD_INT 6
58966: GREATER
58967: PUSH
58968: LD_VAR 0 6
58972: PUSH
58973: LD_INT 6
58975: LESS
58976: AND
58977: IFFALSE 59171
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58979: LD_ADDR_VAR 0 9
58983: PUSH
58984: LD_VAR 0 4
58988: PUSH
58989: LD_VAR 0 8
58993: PUSH
58994: LD_VAR 0 7
58998: UNION
58999: PUSH
59000: LD_VAR 0 6
59004: UNION
59005: DIFF
59006: PPUSH
59007: LD_INT 2
59009: PPUSH
59010: CALL 46937 0 2
59014: ST_TO_ADDR
// p := [ ] ;
59015: LD_ADDR_VAR 0 11
59019: PUSH
59020: EMPTY
59021: ST_TO_ADDR
// if sort then
59022: LD_VAR 0 9
59026: IFFALSE 59142
// for i = 1 to 6 - eng do
59028: LD_ADDR_VAR 0 3
59032: PUSH
59033: DOUBLE
59034: LD_INT 1
59036: DEC
59037: ST_TO_ADDR
59038: LD_INT 6
59040: PUSH
59041: LD_VAR 0 6
59045: MINUS
59046: PUSH
59047: FOR_TO
59048: IFFALSE 59140
// begin if i = sort then
59050: LD_VAR 0 3
59054: PUSH
59055: LD_VAR 0 9
59059: EQUAL
59060: IFFALSE 59064
// break ;
59062: GO 59140
// if GetClass ( i ) = 2 then
59064: LD_VAR 0 3
59068: PPUSH
59069: CALL_OW 257
59073: PUSH
59074: LD_INT 2
59076: EQUAL
59077: IFFALSE 59081
// continue ;
59079: GO 59047
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59081: LD_ADDR_VAR 0 11
59085: PUSH
59086: LD_VAR 0 11
59090: PPUSH
59091: LD_VAR 0 11
59095: PUSH
59096: LD_INT 1
59098: PLUS
59099: PPUSH
59100: LD_VAR 0 9
59104: PUSH
59105: LD_VAR 0 3
59109: ARRAY
59110: PPUSH
59111: CALL_OW 2
59115: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59116: LD_ADDR_VAR 0 4
59120: PUSH
59121: LD_VAR 0 4
59125: PUSH
59126: LD_VAR 0 9
59130: PUSH
59131: LD_VAR 0 3
59135: ARRAY
59136: DIFF
59137: ST_TO_ADDR
// end ;
59138: GO 59047
59140: POP
59141: POP
// if p then
59142: LD_VAR 0 11
59146: IFFALSE 59171
// result := Replace ( result , 2 , p ) ;
59148: LD_ADDR_VAR 0 2
59152: PUSH
59153: LD_VAR 0 2
59157: PPUSH
59158: LD_INT 2
59160: PPUSH
59161: LD_VAR 0 11
59165: PPUSH
59166: CALL_OW 1
59170: ST_TO_ADDR
// end ; exit ;
59171: GO 60559
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59173: LD_EXP 50
59177: PUSH
59178: LD_EXP 49
59182: PUSH
59183: LD_VAR 0 1
59187: ARRAY
59188: ARRAY
59189: NOT
59190: PUSH
59191: LD_EXP 23
59195: PUSH
59196: LD_VAR 0 1
59200: ARRAY
59201: PPUSH
59202: LD_INT 30
59204: PUSH
59205: LD_INT 3
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: PPUSH
59212: CALL_OW 72
59216: AND
59217: PUSH
59218: LD_EXP 28
59222: PUSH
59223: LD_VAR 0 1
59227: ARRAY
59228: AND
59229: IFFALSE 59837
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59231: LD_ADDR_EXP 65
59235: PUSH
59236: LD_EXP 65
59240: PPUSH
59241: LD_VAR 0 1
59245: PPUSH
59246: LD_INT 5
59248: PPUSH
59249: CALL_OW 1
59253: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59254: LD_ADDR_VAR 0 2
59258: PUSH
59259: LD_INT 0
59261: PUSH
59262: LD_INT 0
59264: PUSH
59265: LD_INT 0
59267: PUSH
59268: LD_INT 0
59270: PUSH
59271: EMPTY
59272: LIST
59273: LIST
59274: LIST
59275: LIST
59276: ST_TO_ADDR
// if sci > 1 then
59277: LD_VAR 0 8
59281: PUSH
59282: LD_INT 1
59284: GREATER
59285: IFFALSE 59313
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59287: LD_ADDR_VAR 0 4
59291: PUSH
59292: LD_VAR 0 4
59296: PUSH
59297: LD_VAR 0 8
59301: PUSH
59302: LD_VAR 0 8
59306: PUSH
59307: LD_INT 1
59309: ARRAY
59310: DIFF
59311: DIFF
59312: ST_TO_ADDR
// if tmp and not sci then
59313: LD_VAR 0 4
59317: PUSH
59318: LD_VAR 0 8
59322: NOT
59323: AND
59324: IFFALSE 59393
// begin sort := SortBySkill ( tmp , 4 ) ;
59326: LD_ADDR_VAR 0 9
59330: PUSH
59331: LD_VAR 0 4
59335: PPUSH
59336: LD_INT 4
59338: PPUSH
59339: CALL 46937 0 2
59343: ST_TO_ADDR
// if sort then
59344: LD_VAR 0 9
59348: IFFALSE 59364
// p := sort [ 1 ] ;
59350: LD_ADDR_VAR 0 11
59354: PUSH
59355: LD_VAR 0 9
59359: PUSH
59360: LD_INT 1
59362: ARRAY
59363: ST_TO_ADDR
// if p then
59364: LD_VAR 0 11
59368: IFFALSE 59393
// result := Replace ( result , 4 , p ) ;
59370: LD_ADDR_VAR 0 2
59374: PUSH
59375: LD_VAR 0 2
59379: PPUSH
59380: LD_INT 4
59382: PPUSH
59383: LD_VAR 0 11
59387: PPUSH
59388: CALL_OW 1
59392: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59393: LD_ADDR_VAR 0 4
59397: PUSH
59398: LD_VAR 0 4
59402: PUSH
59403: LD_VAR 0 7
59407: DIFF
59408: ST_TO_ADDR
// if tmp and mech < 6 then
59409: LD_VAR 0 4
59413: PUSH
59414: LD_VAR 0 7
59418: PUSH
59419: LD_INT 6
59421: LESS
59422: AND
59423: IFFALSE 59611
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59425: LD_ADDR_VAR 0 9
59429: PUSH
59430: LD_VAR 0 4
59434: PUSH
59435: LD_VAR 0 8
59439: PUSH
59440: LD_VAR 0 7
59444: UNION
59445: DIFF
59446: PPUSH
59447: LD_INT 3
59449: PPUSH
59450: CALL 46937 0 2
59454: ST_TO_ADDR
// p := [ ] ;
59455: LD_ADDR_VAR 0 11
59459: PUSH
59460: EMPTY
59461: ST_TO_ADDR
// if sort then
59462: LD_VAR 0 9
59466: IFFALSE 59582
// for i = 1 to 6 - mech do
59468: LD_ADDR_VAR 0 3
59472: PUSH
59473: DOUBLE
59474: LD_INT 1
59476: DEC
59477: ST_TO_ADDR
59478: LD_INT 6
59480: PUSH
59481: LD_VAR 0 7
59485: MINUS
59486: PUSH
59487: FOR_TO
59488: IFFALSE 59580
// begin if i = sort then
59490: LD_VAR 0 3
59494: PUSH
59495: LD_VAR 0 9
59499: EQUAL
59500: IFFALSE 59504
// break ;
59502: GO 59580
// if GetClass ( i ) = 3 then
59504: LD_VAR 0 3
59508: PPUSH
59509: CALL_OW 257
59513: PUSH
59514: LD_INT 3
59516: EQUAL
59517: IFFALSE 59521
// continue ;
59519: GO 59487
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59521: LD_ADDR_VAR 0 11
59525: PUSH
59526: LD_VAR 0 11
59530: PPUSH
59531: LD_VAR 0 11
59535: PUSH
59536: LD_INT 1
59538: PLUS
59539: PPUSH
59540: LD_VAR 0 9
59544: PUSH
59545: LD_VAR 0 3
59549: ARRAY
59550: PPUSH
59551: CALL_OW 2
59555: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59556: LD_ADDR_VAR 0 4
59560: PUSH
59561: LD_VAR 0 4
59565: PUSH
59566: LD_VAR 0 9
59570: PUSH
59571: LD_VAR 0 3
59575: ARRAY
59576: DIFF
59577: ST_TO_ADDR
// end ;
59578: GO 59487
59580: POP
59581: POP
// if p then
59582: LD_VAR 0 11
59586: IFFALSE 59611
// result := Replace ( result , 3 , p ) ;
59588: LD_ADDR_VAR 0 2
59592: PUSH
59593: LD_VAR 0 2
59597: PPUSH
59598: LD_INT 3
59600: PPUSH
59601: LD_VAR 0 11
59605: PPUSH
59606: CALL_OW 1
59610: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59611: LD_ADDR_VAR 0 4
59615: PUSH
59616: LD_VAR 0 4
59620: PUSH
59621: LD_VAR 0 6
59625: DIFF
59626: ST_TO_ADDR
// if tmp and eng < 6 then
59627: LD_VAR 0 4
59631: PUSH
59632: LD_VAR 0 6
59636: PUSH
59637: LD_INT 6
59639: LESS
59640: AND
59641: IFFALSE 59835
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59643: LD_ADDR_VAR 0 9
59647: PUSH
59648: LD_VAR 0 4
59652: PUSH
59653: LD_VAR 0 8
59657: PUSH
59658: LD_VAR 0 7
59662: UNION
59663: PUSH
59664: LD_VAR 0 6
59668: UNION
59669: DIFF
59670: PPUSH
59671: LD_INT 2
59673: PPUSH
59674: CALL 46937 0 2
59678: ST_TO_ADDR
// p := [ ] ;
59679: LD_ADDR_VAR 0 11
59683: PUSH
59684: EMPTY
59685: ST_TO_ADDR
// if sort then
59686: LD_VAR 0 9
59690: IFFALSE 59806
// for i = 1 to 6 - eng do
59692: LD_ADDR_VAR 0 3
59696: PUSH
59697: DOUBLE
59698: LD_INT 1
59700: DEC
59701: ST_TO_ADDR
59702: LD_INT 6
59704: PUSH
59705: LD_VAR 0 6
59709: MINUS
59710: PUSH
59711: FOR_TO
59712: IFFALSE 59804
// begin if i = sort then
59714: LD_VAR 0 3
59718: PUSH
59719: LD_VAR 0 9
59723: EQUAL
59724: IFFALSE 59728
// break ;
59726: GO 59804
// if GetClass ( i ) = 2 then
59728: LD_VAR 0 3
59732: PPUSH
59733: CALL_OW 257
59737: PUSH
59738: LD_INT 2
59740: EQUAL
59741: IFFALSE 59745
// continue ;
59743: GO 59711
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59745: LD_ADDR_VAR 0 11
59749: PUSH
59750: LD_VAR 0 11
59754: PPUSH
59755: LD_VAR 0 11
59759: PUSH
59760: LD_INT 1
59762: PLUS
59763: PPUSH
59764: LD_VAR 0 9
59768: PUSH
59769: LD_VAR 0 3
59773: ARRAY
59774: PPUSH
59775: CALL_OW 2
59779: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59780: LD_ADDR_VAR 0 4
59784: PUSH
59785: LD_VAR 0 4
59789: PUSH
59790: LD_VAR 0 9
59794: PUSH
59795: LD_VAR 0 3
59799: ARRAY
59800: DIFF
59801: ST_TO_ADDR
// end ;
59802: GO 59711
59804: POP
59805: POP
// if p then
59806: LD_VAR 0 11
59810: IFFALSE 59835
// result := Replace ( result , 2 , p ) ;
59812: LD_ADDR_VAR 0 2
59816: PUSH
59817: LD_VAR 0 2
59821: PPUSH
59822: LD_INT 2
59824: PPUSH
59825: LD_VAR 0 11
59829: PPUSH
59830: CALL_OW 1
59834: ST_TO_ADDR
// end ; exit ;
59835: GO 60559
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59837: LD_EXP 50
59841: PUSH
59842: LD_EXP 49
59846: PUSH
59847: LD_VAR 0 1
59851: ARRAY
59852: ARRAY
59853: NOT
59854: PUSH
59855: LD_EXP 23
59859: PUSH
59860: LD_VAR 0 1
59864: ARRAY
59865: PPUSH
59866: LD_INT 30
59868: PUSH
59869: LD_INT 3
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: PPUSH
59876: CALL_OW 72
59880: AND
59881: PUSH
59882: LD_EXP 28
59886: PUSH
59887: LD_VAR 0 1
59891: ARRAY
59892: NOT
59893: AND
59894: IFFALSE 60559
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59896: LD_ADDR_EXP 65
59900: PUSH
59901: LD_EXP 65
59905: PPUSH
59906: LD_VAR 0 1
59910: PPUSH
59911: LD_INT 6
59913: PPUSH
59914: CALL_OW 1
59918: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59919: LD_ADDR_VAR 0 2
59923: PUSH
59924: LD_INT 0
59926: PUSH
59927: LD_INT 0
59929: PUSH
59930: LD_INT 0
59932: PUSH
59933: LD_INT 0
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: LIST
59940: LIST
59941: ST_TO_ADDR
// if sci >= 1 then
59942: LD_VAR 0 8
59946: PUSH
59947: LD_INT 1
59949: GREATEREQUAL
59950: IFFALSE 59972
// tmp := tmp diff sci [ 1 ] ;
59952: LD_ADDR_VAR 0 4
59956: PUSH
59957: LD_VAR 0 4
59961: PUSH
59962: LD_VAR 0 8
59966: PUSH
59967: LD_INT 1
59969: ARRAY
59970: DIFF
59971: ST_TO_ADDR
// if tmp and not sci then
59972: LD_VAR 0 4
59976: PUSH
59977: LD_VAR 0 8
59981: NOT
59982: AND
59983: IFFALSE 60052
// begin sort := SortBySkill ( tmp , 4 ) ;
59985: LD_ADDR_VAR 0 9
59989: PUSH
59990: LD_VAR 0 4
59994: PPUSH
59995: LD_INT 4
59997: PPUSH
59998: CALL 46937 0 2
60002: ST_TO_ADDR
// if sort then
60003: LD_VAR 0 9
60007: IFFALSE 60023
// p := sort [ 1 ] ;
60009: LD_ADDR_VAR 0 11
60013: PUSH
60014: LD_VAR 0 9
60018: PUSH
60019: LD_INT 1
60021: ARRAY
60022: ST_TO_ADDR
// if p then
60023: LD_VAR 0 11
60027: IFFALSE 60052
// result := Replace ( result , 4 , p ) ;
60029: LD_ADDR_VAR 0 2
60033: PUSH
60034: LD_VAR 0 2
60038: PPUSH
60039: LD_INT 4
60041: PPUSH
60042: LD_VAR 0 11
60046: PPUSH
60047: CALL_OW 1
60051: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60052: LD_ADDR_VAR 0 4
60056: PUSH
60057: LD_VAR 0 4
60061: PUSH
60062: LD_VAR 0 7
60066: DIFF
60067: ST_TO_ADDR
// if tmp and mech < 6 then
60068: LD_VAR 0 4
60072: PUSH
60073: LD_VAR 0 7
60077: PUSH
60078: LD_INT 6
60080: LESS
60081: AND
60082: IFFALSE 60264
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60084: LD_ADDR_VAR 0 9
60088: PUSH
60089: LD_VAR 0 4
60093: PUSH
60094: LD_VAR 0 7
60098: DIFF
60099: PPUSH
60100: LD_INT 3
60102: PPUSH
60103: CALL 46937 0 2
60107: ST_TO_ADDR
// p := [ ] ;
60108: LD_ADDR_VAR 0 11
60112: PUSH
60113: EMPTY
60114: ST_TO_ADDR
// if sort then
60115: LD_VAR 0 9
60119: IFFALSE 60235
// for i = 1 to 6 - mech do
60121: LD_ADDR_VAR 0 3
60125: PUSH
60126: DOUBLE
60127: LD_INT 1
60129: DEC
60130: ST_TO_ADDR
60131: LD_INT 6
60133: PUSH
60134: LD_VAR 0 7
60138: MINUS
60139: PUSH
60140: FOR_TO
60141: IFFALSE 60233
// begin if i = sort then
60143: LD_VAR 0 3
60147: PUSH
60148: LD_VAR 0 9
60152: EQUAL
60153: IFFALSE 60157
// break ;
60155: GO 60233
// if GetClass ( i ) = 3 then
60157: LD_VAR 0 3
60161: PPUSH
60162: CALL_OW 257
60166: PUSH
60167: LD_INT 3
60169: EQUAL
60170: IFFALSE 60174
// continue ;
60172: GO 60140
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60174: LD_ADDR_VAR 0 11
60178: PUSH
60179: LD_VAR 0 11
60183: PPUSH
60184: LD_VAR 0 11
60188: PUSH
60189: LD_INT 1
60191: PLUS
60192: PPUSH
60193: LD_VAR 0 9
60197: PUSH
60198: LD_VAR 0 3
60202: ARRAY
60203: PPUSH
60204: CALL_OW 2
60208: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60209: LD_ADDR_VAR 0 4
60213: PUSH
60214: LD_VAR 0 4
60218: PUSH
60219: LD_VAR 0 9
60223: PUSH
60224: LD_VAR 0 3
60228: ARRAY
60229: DIFF
60230: ST_TO_ADDR
// end ;
60231: GO 60140
60233: POP
60234: POP
// if p then
60235: LD_VAR 0 11
60239: IFFALSE 60264
// result := Replace ( result , 3 , p ) ;
60241: LD_ADDR_VAR 0 2
60245: PUSH
60246: LD_VAR 0 2
60250: PPUSH
60251: LD_INT 3
60253: PPUSH
60254: LD_VAR 0 11
60258: PPUSH
60259: CALL_OW 1
60263: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60264: LD_ADDR_VAR 0 4
60268: PUSH
60269: LD_VAR 0 4
60273: PUSH
60274: LD_VAR 0 6
60278: DIFF
60279: ST_TO_ADDR
// if tmp and eng < 4 then
60280: LD_VAR 0 4
60284: PUSH
60285: LD_VAR 0 6
60289: PUSH
60290: LD_INT 4
60292: LESS
60293: AND
60294: IFFALSE 60484
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60296: LD_ADDR_VAR 0 9
60300: PUSH
60301: LD_VAR 0 4
60305: PUSH
60306: LD_VAR 0 7
60310: PUSH
60311: LD_VAR 0 6
60315: UNION
60316: DIFF
60317: PPUSH
60318: LD_INT 2
60320: PPUSH
60321: CALL 46937 0 2
60325: ST_TO_ADDR
// p := [ ] ;
60326: LD_ADDR_VAR 0 11
60330: PUSH
60331: EMPTY
60332: ST_TO_ADDR
// if sort then
60333: LD_VAR 0 9
60337: IFFALSE 60453
// for i = 1 to 4 - eng do
60339: LD_ADDR_VAR 0 3
60343: PUSH
60344: DOUBLE
60345: LD_INT 1
60347: DEC
60348: ST_TO_ADDR
60349: LD_INT 4
60351: PUSH
60352: LD_VAR 0 6
60356: MINUS
60357: PUSH
60358: FOR_TO
60359: IFFALSE 60451
// begin if i = sort then
60361: LD_VAR 0 3
60365: PUSH
60366: LD_VAR 0 9
60370: EQUAL
60371: IFFALSE 60375
// break ;
60373: GO 60451
// if GetClass ( i ) = 2 then
60375: LD_VAR 0 3
60379: PPUSH
60380: CALL_OW 257
60384: PUSH
60385: LD_INT 2
60387: EQUAL
60388: IFFALSE 60392
// continue ;
60390: GO 60358
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60392: LD_ADDR_VAR 0 11
60396: PUSH
60397: LD_VAR 0 11
60401: PPUSH
60402: LD_VAR 0 11
60406: PUSH
60407: LD_INT 1
60409: PLUS
60410: PPUSH
60411: LD_VAR 0 9
60415: PUSH
60416: LD_VAR 0 3
60420: ARRAY
60421: PPUSH
60422: CALL_OW 2
60426: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60427: LD_ADDR_VAR 0 4
60431: PUSH
60432: LD_VAR 0 4
60436: PUSH
60437: LD_VAR 0 9
60441: PUSH
60442: LD_VAR 0 3
60446: ARRAY
60447: DIFF
60448: ST_TO_ADDR
// end ;
60449: GO 60358
60451: POP
60452: POP
// if p then
60453: LD_VAR 0 11
60457: IFFALSE 60482
// result := Replace ( result , 2 , p ) ;
60459: LD_ADDR_VAR 0 2
60463: PUSH
60464: LD_VAR 0 2
60468: PPUSH
60469: LD_INT 2
60471: PPUSH
60472: LD_VAR 0 11
60476: PPUSH
60477: CALL_OW 1
60481: ST_TO_ADDR
// end else
60482: GO 60528
// for i = eng downto 5 do
60484: LD_ADDR_VAR 0 3
60488: PUSH
60489: DOUBLE
60490: LD_VAR 0 6
60494: INC
60495: ST_TO_ADDR
60496: LD_INT 5
60498: PUSH
60499: FOR_DOWNTO
60500: IFFALSE 60526
// tmp := tmp union eng [ i ] ;
60502: LD_ADDR_VAR 0 4
60506: PUSH
60507: LD_VAR 0 4
60511: PUSH
60512: LD_VAR 0 6
60516: PUSH
60517: LD_VAR 0 3
60521: ARRAY
60522: UNION
60523: ST_TO_ADDR
60524: GO 60499
60526: POP
60527: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60528: LD_ADDR_VAR 0 2
60532: PUSH
60533: LD_VAR 0 2
60537: PPUSH
60538: LD_INT 1
60540: PPUSH
60541: LD_VAR 0 4
60545: PUSH
60546: LD_VAR 0 5
60550: DIFF
60551: PPUSH
60552: CALL_OW 1
60556: ST_TO_ADDR
// exit ;
60557: GO 60559
// end ; end ;
60559: LD_VAR 0 2
60563: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60564: LD_INT 0
60566: PPUSH
60567: PPUSH
60568: PPUSH
// if not mc_bases then
60569: LD_EXP 23
60573: NOT
60574: IFFALSE 60578
// exit ;
60576: GO 60720
// for i = 1 to mc_bases do
60578: LD_ADDR_VAR 0 2
60582: PUSH
60583: DOUBLE
60584: LD_INT 1
60586: DEC
60587: ST_TO_ADDR
60588: LD_EXP 23
60592: PUSH
60593: FOR_TO
60594: IFFALSE 60711
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60596: LD_ADDR_VAR 0 3
60600: PUSH
60601: LD_EXP 23
60605: PUSH
60606: LD_VAR 0 2
60610: ARRAY
60611: PPUSH
60612: LD_INT 21
60614: PUSH
60615: LD_INT 3
60617: PUSH
60618: EMPTY
60619: LIST
60620: LIST
60621: PUSH
60622: LD_INT 3
60624: PUSH
60625: LD_INT 2
60627: PUSH
60628: LD_INT 30
60630: PUSH
60631: LD_INT 29
60633: PUSH
60634: EMPTY
60635: LIST
60636: LIST
60637: PUSH
60638: LD_INT 30
60640: PUSH
60641: LD_INT 30
60643: PUSH
60644: EMPTY
60645: LIST
60646: LIST
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: LIST
60652: PUSH
60653: EMPTY
60654: LIST
60655: LIST
60656: PUSH
60657: LD_INT 3
60659: PUSH
60660: LD_INT 24
60662: PUSH
60663: LD_INT 1000
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: PUSH
60670: EMPTY
60671: LIST
60672: LIST
60673: PUSH
60674: EMPTY
60675: LIST
60676: LIST
60677: LIST
60678: PPUSH
60679: CALL_OW 72
60683: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60684: LD_ADDR_EXP 24
60688: PUSH
60689: LD_EXP 24
60693: PPUSH
60694: LD_VAR 0 2
60698: PPUSH
60699: LD_VAR 0 3
60703: PPUSH
60704: CALL_OW 1
60708: ST_TO_ADDR
// end ;
60709: GO 60593
60711: POP
60712: POP
// RaiseSailEvent ( 101 ) ;
60713: LD_INT 101
60715: PPUSH
60716: CALL_OW 427
// end ;
60720: LD_VAR 0 1
60724: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60725: LD_INT 0
60727: PPUSH
60728: PPUSH
60729: PPUSH
60730: PPUSH
60731: PPUSH
60732: PPUSH
60733: PPUSH
// if not mc_bases then
60734: LD_EXP 23
60738: NOT
60739: IFFALSE 60743
// exit ;
60741: GO 61305
// for i = 1 to mc_bases do
60743: LD_ADDR_VAR 0 2
60747: PUSH
60748: DOUBLE
60749: LD_INT 1
60751: DEC
60752: ST_TO_ADDR
60753: LD_EXP 23
60757: PUSH
60758: FOR_TO
60759: IFFALSE 61296
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60761: LD_ADDR_VAR 0 5
60765: PUSH
60766: LD_EXP 23
60770: PUSH
60771: LD_VAR 0 2
60775: ARRAY
60776: PUSH
60777: LD_EXP 52
60781: PUSH
60782: LD_VAR 0 2
60786: ARRAY
60787: UNION
60788: PPUSH
60789: LD_INT 21
60791: PUSH
60792: LD_INT 1
60794: PUSH
60795: EMPTY
60796: LIST
60797: LIST
60798: PUSH
60799: LD_INT 1
60801: PUSH
60802: LD_INT 3
60804: PUSH
60805: LD_INT 54
60807: PUSH
60808: EMPTY
60809: LIST
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: PUSH
60815: LD_INT 3
60817: PUSH
60818: LD_INT 24
60820: PUSH
60821: LD_INT 1000
60823: PUSH
60824: EMPTY
60825: LIST
60826: LIST
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PUSH
60832: EMPTY
60833: LIST
60834: LIST
60835: LIST
60836: PUSH
60837: EMPTY
60838: LIST
60839: LIST
60840: PPUSH
60841: CALL_OW 72
60845: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60846: LD_ADDR_VAR 0 6
60850: PUSH
60851: LD_EXP 23
60855: PUSH
60856: LD_VAR 0 2
60860: ARRAY
60861: PPUSH
60862: LD_INT 21
60864: PUSH
60865: LD_INT 1
60867: PUSH
60868: EMPTY
60869: LIST
60870: LIST
60871: PUSH
60872: LD_INT 1
60874: PUSH
60875: LD_INT 3
60877: PUSH
60878: LD_INT 54
60880: PUSH
60881: EMPTY
60882: LIST
60883: PUSH
60884: EMPTY
60885: LIST
60886: LIST
60887: PUSH
60888: LD_INT 3
60890: PUSH
60891: LD_INT 24
60893: PUSH
60894: LD_INT 250
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: EMPTY
60902: LIST
60903: LIST
60904: PUSH
60905: EMPTY
60906: LIST
60907: LIST
60908: LIST
60909: PUSH
60910: EMPTY
60911: LIST
60912: LIST
60913: PPUSH
60914: CALL_OW 72
60918: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60919: LD_ADDR_VAR 0 7
60923: PUSH
60924: LD_VAR 0 5
60928: PUSH
60929: LD_VAR 0 6
60933: DIFF
60934: ST_TO_ADDR
// if not need_heal_1 then
60935: LD_VAR 0 6
60939: NOT
60940: IFFALSE 60973
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60942: LD_ADDR_EXP 26
60946: PUSH
60947: LD_EXP 26
60951: PPUSH
60952: LD_VAR 0 2
60956: PUSH
60957: LD_INT 1
60959: PUSH
60960: EMPTY
60961: LIST
60962: LIST
60963: PPUSH
60964: EMPTY
60965: PPUSH
60966: CALL 16166 0 3
60970: ST_TO_ADDR
60971: GO 61043
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60973: LD_ADDR_EXP 26
60977: PUSH
60978: LD_EXP 26
60982: PPUSH
60983: LD_VAR 0 2
60987: PUSH
60988: LD_INT 1
60990: PUSH
60991: EMPTY
60992: LIST
60993: LIST
60994: PPUSH
60995: LD_EXP 26
60999: PUSH
61000: LD_VAR 0 2
61004: ARRAY
61005: PUSH
61006: LD_INT 1
61008: ARRAY
61009: PPUSH
61010: LD_INT 3
61012: PUSH
61013: LD_INT 24
61015: PUSH
61016: LD_INT 1000
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: PUSH
61023: EMPTY
61024: LIST
61025: LIST
61026: PPUSH
61027: CALL_OW 72
61031: PUSH
61032: LD_VAR 0 6
61036: UNION
61037: PPUSH
61038: CALL 16166 0 3
61042: ST_TO_ADDR
// if not need_heal_2 then
61043: LD_VAR 0 7
61047: NOT
61048: IFFALSE 61081
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61050: LD_ADDR_EXP 26
61054: PUSH
61055: LD_EXP 26
61059: PPUSH
61060: LD_VAR 0 2
61064: PUSH
61065: LD_INT 2
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: PPUSH
61072: EMPTY
61073: PPUSH
61074: CALL 16166 0 3
61078: ST_TO_ADDR
61079: GO 61113
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61081: LD_ADDR_EXP 26
61085: PUSH
61086: LD_EXP 26
61090: PPUSH
61091: LD_VAR 0 2
61095: PUSH
61096: LD_INT 2
61098: PUSH
61099: EMPTY
61100: LIST
61101: LIST
61102: PPUSH
61103: LD_VAR 0 7
61107: PPUSH
61108: CALL 16166 0 3
61112: ST_TO_ADDR
// if need_heal_2 then
61113: LD_VAR 0 7
61117: IFFALSE 61278
// for j in need_heal_2 do
61119: LD_ADDR_VAR 0 3
61123: PUSH
61124: LD_VAR 0 7
61128: PUSH
61129: FOR_IN
61130: IFFALSE 61276
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61132: LD_ADDR_VAR 0 5
61136: PUSH
61137: LD_EXP 23
61141: PUSH
61142: LD_VAR 0 2
61146: ARRAY
61147: PPUSH
61148: LD_INT 2
61150: PUSH
61151: LD_INT 30
61153: PUSH
61154: LD_INT 6
61156: PUSH
61157: EMPTY
61158: LIST
61159: LIST
61160: PUSH
61161: LD_INT 30
61163: PUSH
61164: LD_INT 7
61166: PUSH
61167: EMPTY
61168: LIST
61169: LIST
61170: PUSH
61171: LD_INT 30
61173: PUSH
61174: LD_INT 8
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: PUSH
61181: LD_INT 30
61183: PUSH
61184: LD_INT 0
61186: PUSH
61187: EMPTY
61188: LIST
61189: LIST
61190: PUSH
61191: LD_INT 30
61193: PUSH
61194: LD_INT 1
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: PUSH
61201: EMPTY
61202: LIST
61203: LIST
61204: LIST
61205: LIST
61206: LIST
61207: LIST
61208: PPUSH
61209: CALL_OW 72
61213: ST_TO_ADDR
// if tmp then
61214: LD_VAR 0 5
61218: IFFALSE 61274
// begin k := NearestUnitToUnit ( tmp , j ) ;
61220: LD_ADDR_VAR 0 4
61224: PUSH
61225: LD_VAR 0 5
61229: PPUSH
61230: LD_VAR 0 3
61234: PPUSH
61235: CALL_OW 74
61239: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61240: LD_VAR 0 3
61244: PPUSH
61245: LD_VAR 0 4
61249: PPUSH
61250: CALL_OW 296
61254: PUSH
61255: LD_INT 5
61257: GREATER
61258: IFFALSE 61274
// ComMoveToNearbyEntrance ( j , k ) ;
61260: LD_VAR 0 3
61264: PPUSH
61265: LD_VAR 0 4
61269: PPUSH
61270: CALL 49305 0 2
// end ; end ;
61274: GO 61129
61276: POP
61277: POP
// if not need_heal_1 and not need_heal_2 then
61278: LD_VAR 0 6
61282: NOT
61283: PUSH
61284: LD_VAR 0 7
61288: NOT
61289: AND
61290: IFFALSE 61294
// continue ;
61292: GO 60758
// end ;
61294: GO 60758
61296: POP
61297: POP
// RaiseSailEvent ( 102 ) ;
61298: LD_INT 102
61300: PPUSH
61301: CALL_OW 427
// end ;
61305: LD_VAR 0 1
61309: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61310: LD_INT 0
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
61318: PPUSH
61319: PPUSH
// if not mc_bases then
61320: LD_EXP 23
61324: NOT
61325: IFFALSE 61329
// exit ;
61327: GO 62212
// for i = 1 to mc_bases do
61329: LD_ADDR_VAR 0 2
61333: PUSH
61334: DOUBLE
61335: LD_INT 1
61337: DEC
61338: ST_TO_ADDR
61339: LD_EXP 23
61343: PUSH
61344: FOR_TO
61345: IFFALSE 62210
// begin if not mc_building_need_repair [ i ] then
61347: LD_EXP 24
61351: PUSH
61352: LD_VAR 0 2
61356: ARRAY
61357: NOT
61358: IFFALSE 61545
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61360: LD_ADDR_VAR 0 6
61364: PUSH
61365: LD_EXP 42
61369: PUSH
61370: LD_VAR 0 2
61374: ARRAY
61375: PPUSH
61376: LD_INT 3
61378: PUSH
61379: LD_INT 24
61381: PUSH
61382: LD_INT 1000
61384: PUSH
61385: EMPTY
61386: LIST
61387: LIST
61388: PUSH
61389: EMPTY
61390: LIST
61391: LIST
61392: PUSH
61393: LD_INT 2
61395: PUSH
61396: LD_INT 34
61398: PUSH
61399: LD_INT 13
61401: PUSH
61402: EMPTY
61403: LIST
61404: LIST
61405: PUSH
61406: LD_INT 34
61408: PUSH
61409: LD_INT 52
61411: PUSH
61412: EMPTY
61413: LIST
61414: LIST
61415: PUSH
61416: LD_INT 34
61418: PUSH
61419: LD_EXP 73
61423: PUSH
61424: EMPTY
61425: LIST
61426: LIST
61427: PUSH
61428: EMPTY
61429: LIST
61430: LIST
61431: LIST
61432: LIST
61433: PUSH
61434: EMPTY
61435: LIST
61436: LIST
61437: PPUSH
61438: CALL_OW 72
61442: ST_TO_ADDR
// if cranes then
61443: LD_VAR 0 6
61447: IFFALSE 61509
// for j in cranes do
61449: LD_ADDR_VAR 0 3
61453: PUSH
61454: LD_VAR 0 6
61458: PUSH
61459: FOR_IN
61460: IFFALSE 61507
// if not IsInArea ( j , mc_parking [ i ] ) then
61462: LD_VAR 0 3
61466: PPUSH
61467: LD_EXP 47
61471: PUSH
61472: LD_VAR 0 2
61476: ARRAY
61477: PPUSH
61478: CALL_OW 308
61482: NOT
61483: IFFALSE 61505
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61485: LD_VAR 0 3
61489: PPUSH
61490: LD_EXP 47
61494: PUSH
61495: LD_VAR 0 2
61499: ARRAY
61500: PPUSH
61501: CALL_OW 113
61505: GO 61459
61507: POP
61508: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61509: LD_ADDR_EXP 25
61513: PUSH
61514: LD_EXP 25
61518: PPUSH
61519: LD_VAR 0 2
61523: PPUSH
61524: EMPTY
61525: PPUSH
61526: CALL_OW 1
61530: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61531: LD_VAR 0 2
61535: PPUSH
61536: LD_INT 101
61538: PPUSH
61539: CALL 56397 0 2
// continue ;
61543: GO 61344
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61545: LD_ADDR_EXP 29
61549: PUSH
61550: LD_EXP 29
61554: PPUSH
61555: LD_VAR 0 2
61559: PPUSH
61560: EMPTY
61561: PPUSH
61562: CALL_OW 1
61566: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61567: LD_VAR 0 2
61571: PPUSH
61572: LD_INT 103
61574: PPUSH
61575: CALL 56397 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
61579: LD_ADDR_VAR 0 5
61583: PUSH
61584: LD_EXP 23
61588: PUSH
61589: LD_VAR 0 2
61593: ARRAY
61594: PUSH
61595: LD_EXP 52
61599: PUSH
61600: LD_VAR 0 2
61604: ARRAY
61605: UNION
61606: PPUSH
61607: LD_INT 2
61609: PUSH
61610: LD_INT 25
61612: PUSH
61613: LD_INT 2
61615: PUSH
61616: EMPTY
61617: LIST
61618: LIST
61619: PUSH
61620: LD_INT 25
61622: PUSH
61623: LD_INT 16
61625: PUSH
61626: EMPTY
61627: LIST
61628: LIST
61629: PUSH
61630: EMPTY
61631: LIST
61632: LIST
61633: LIST
61634: PUSH
61635: EMPTY
61636: LIST
61637: PPUSH
61638: CALL_OW 72
61642: ST_TO_ADDR
// if mc_need_heal [ i ] then
61643: LD_EXP 26
61647: PUSH
61648: LD_VAR 0 2
61652: ARRAY
61653: IFFALSE 61697
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61655: LD_ADDR_VAR 0 5
61659: PUSH
61660: LD_VAR 0 5
61664: PUSH
61665: LD_EXP 26
61669: PUSH
61670: LD_VAR 0 2
61674: ARRAY
61675: PUSH
61676: LD_INT 1
61678: ARRAY
61679: PUSH
61680: LD_EXP 26
61684: PUSH
61685: LD_VAR 0 2
61689: ARRAY
61690: PUSH
61691: LD_INT 2
61693: ARRAY
61694: UNION
61695: DIFF
61696: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61697: LD_ADDR_VAR 0 6
61701: PUSH
61702: LD_EXP 42
61706: PUSH
61707: LD_VAR 0 2
61711: ARRAY
61712: PPUSH
61713: LD_INT 2
61715: PUSH
61716: LD_INT 34
61718: PUSH
61719: LD_INT 13
61721: PUSH
61722: EMPTY
61723: LIST
61724: LIST
61725: PUSH
61726: LD_INT 34
61728: PUSH
61729: LD_INT 52
61731: PUSH
61732: EMPTY
61733: LIST
61734: LIST
61735: PUSH
61736: LD_INT 34
61738: PUSH
61739: LD_EXP 73
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: PUSH
61748: EMPTY
61749: LIST
61750: LIST
61751: LIST
61752: LIST
61753: PPUSH
61754: CALL_OW 72
61758: ST_TO_ADDR
// if cranes then
61759: LD_VAR 0 6
61763: IFFALSE 61899
// begin for j in cranes do
61765: LD_ADDR_VAR 0 3
61769: PUSH
61770: LD_VAR 0 6
61774: PUSH
61775: FOR_IN
61776: IFFALSE 61897
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61778: LD_VAR 0 3
61782: PPUSH
61783: CALL_OW 256
61787: PUSH
61788: LD_INT 1000
61790: EQUAL
61791: PUSH
61792: LD_VAR 0 3
61796: PPUSH
61797: CALL_OW 314
61801: NOT
61802: AND
61803: IFFALSE 61837
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
61805: LD_VAR 0 3
61809: PPUSH
61810: LD_EXP 24
61814: PUSH
61815: LD_VAR 0 2
61819: ARRAY
61820: PPUSH
61821: LD_VAR 0 3
61825: PPUSH
61826: CALL_OW 74
61830: PPUSH
61831: CALL_OW 130
61835: GO 61895
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61837: LD_VAR 0 3
61841: PPUSH
61842: CALL_OW 256
61846: PUSH
61847: LD_INT 500
61849: LESS
61850: PUSH
61851: LD_VAR 0 3
61855: PPUSH
61856: LD_EXP 47
61860: PUSH
61861: LD_VAR 0 2
61865: ARRAY
61866: PPUSH
61867: CALL_OW 308
61871: NOT
61872: AND
61873: IFFALSE 61895
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61875: LD_VAR 0 3
61879: PPUSH
61880: LD_EXP 47
61884: PUSH
61885: LD_VAR 0 2
61889: ARRAY
61890: PPUSH
61891: CALL_OW 113
// end ;
61895: GO 61775
61897: POP
61898: POP
// end ; if tmp > 3 then
61899: LD_VAR 0 5
61903: PUSH
61904: LD_INT 3
61906: GREATER
61907: IFFALSE 61927
// tmp := ShrinkArray ( tmp , 4 ) ;
61909: LD_ADDR_VAR 0 5
61913: PUSH
61914: LD_VAR 0 5
61918: PPUSH
61919: LD_INT 4
61921: PPUSH
61922: CALL 48743 0 2
61926: ST_TO_ADDR
// if not tmp then
61927: LD_VAR 0 5
61931: NOT
61932: IFFALSE 61936
// continue ;
61934: GO 61344
// for j in tmp do
61936: LD_ADDR_VAR 0 3
61940: PUSH
61941: LD_VAR 0 5
61945: PUSH
61946: FOR_IN
61947: IFFALSE 62206
// begin if IsInUnit ( j ) then
61949: LD_VAR 0 3
61953: PPUSH
61954: CALL_OW 310
61958: IFFALSE 61969
// ComExitBuilding ( j ) ;
61960: LD_VAR 0 3
61964: PPUSH
61965: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61969: LD_VAR 0 3
61973: PUSH
61974: LD_EXP 25
61978: PUSH
61979: LD_VAR 0 2
61983: ARRAY
61984: IN
61985: NOT
61986: IFFALSE 62044
// begin SetTag ( j , 101 ) ;
61988: LD_VAR 0 3
61992: PPUSH
61993: LD_INT 101
61995: PPUSH
61996: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62000: LD_ADDR_EXP 25
62004: PUSH
62005: LD_EXP 25
62009: PPUSH
62010: LD_VAR 0 2
62014: PUSH
62015: LD_EXP 25
62019: PUSH
62020: LD_VAR 0 2
62024: ARRAY
62025: PUSH
62026: LD_INT 1
62028: PLUS
62029: PUSH
62030: EMPTY
62031: LIST
62032: LIST
62033: PPUSH
62034: LD_VAR 0 3
62038: PPUSH
62039: CALL 16166 0 3
62043: ST_TO_ADDR
// end ; wait ( 1 ) ;
62044: LD_INT 1
62046: PPUSH
62047: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62051: LD_ADDR_VAR 0 7
62055: PUSH
62056: LD_EXP 24
62060: PUSH
62061: LD_VAR 0 2
62065: ARRAY
62066: ST_TO_ADDR
// if mc_scan [ i ] then
62067: LD_EXP 46
62071: PUSH
62072: LD_VAR 0 2
62076: ARRAY
62077: IFFALSE 62139
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62079: LD_ADDR_VAR 0 7
62083: PUSH
62084: LD_EXP 24
62088: PUSH
62089: LD_VAR 0 2
62093: ARRAY
62094: PPUSH
62095: LD_INT 3
62097: PUSH
62098: LD_INT 30
62100: PUSH
62101: LD_INT 32
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: PUSH
62108: LD_INT 30
62110: PUSH
62111: LD_INT 33
62113: PUSH
62114: EMPTY
62115: LIST
62116: LIST
62117: PUSH
62118: LD_INT 30
62120: PUSH
62121: LD_INT 31
62123: PUSH
62124: EMPTY
62125: LIST
62126: LIST
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: LIST
62132: LIST
62133: PPUSH
62134: CALL_OW 72
62138: ST_TO_ADDR
// if not to_repair_tmp then
62139: LD_VAR 0 7
62143: NOT
62144: IFFALSE 62148
// continue ;
62146: GO 61946
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62148: LD_ADDR_VAR 0 8
62152: PUSH
62153: LD_VAR 0 7
62157: PPUSH
62158: LD_VAR 0 3
62162: PPUSH
62163: CALL_OW 74
62167: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
62168: LD_VAR 0 8
62172: PPUSH
62173: LD_INT 16
62175: PPUSH
62176: CALL 18765 0 2
62180: PUSH
62181: LD_INT 4
62183: ARRAY
62184: PUSH
62185: LD_INT 10
62187: LESS
62188: IFFALSE 62204
// ComRepairBuilding ( j , to_repair ) ;
62190: LD_VAR 0 3
62194: PPUSH
62195: LD_VAR 0 8
62199: PPUSH
62200: CALL_OW 130
// end ;
62204: GO 61946
62206: POP
62207: POP
// end ;
62208: GO 61344
62210: POP
62211: POP
// end ;
62212: LD_VAR 0 1
62216: RET
// export function MC_Heal ; var i , j , tmp ; begin
62217: LD_INT 0
62219: PPUSH
62220: PPUSH
62221: PPUSH
62222: PPUSH
// if not mc_bases then
62223: LD_EXP 23
62227: NOT
62228: IFFALSE 62232
// exit ;
62230: GO 62634
// for i = 1 to mc_bases do
62232: LD_ADDR_VAR 0 2
62236: PUSH
62237: DOUBLE
62238: LD_INT 1
62240: DEC
62241: ST_TO_ADDR
62242: LD_EXP 23
62246: PUSH
62247: FOR_TO
62248: IFFALSE 62632
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62250: LD_EXP 26
62254: PUSH
62255: LD_VAR 0 2
62259: ARRAY
62260: PUSH
62261: LD_INT 1
62263: ARRAY
62264: NOT
62265: PUSH
62266: LD_EXP 26
62270: PUSH
62271: LD_VAR 0 2
62275: ARRAY
62276: PUSH
62277: LD_INT 2
62279: ARRAY
62280: NOT
62281: AND
62282: IFFALSE 62320
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62284: LD_ADDR_EXP 27
62288: PUSH
62289: LD_EXP 27
62293: PPUSH
62294: LD_VAR 0 2
62298: PPUSH
62299: EMPTY
62300: PPUSH
62301: CALL_OW 1
62305: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62306: LD_VAR 0 2
62310: PPUSH
62311: LD_INT 102
62313: PPUSH
62314: CALL 56397 0 2
// continue ;
62318: GO 62247
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62320: LD_ADDR_VAR 0 4
62324: PUSH
62325: LD_EXP 23
62329: PUSH
62330: LD_VAR 0 2
62334: ARRAY
62335: PPUSH
62336: LD_INT 25
62338: PUSH
62339: LD_INT 4
62341: PUSH
62342: EMPTY
62343: LIST
62344: LIST
62345: PPUSH
62346: CALL_OW 72
62350: ST_TO_ADDR
// if not tmp then
62351: LD_VAR 0 4
62355: NOT
62356: IFFALSE 62360
// continue ;
62358: GO 62247
// if mc_taming [ i ] then
62360: LD_EXP 54
62364: PUSH
62365: LD_VAR 0 2
62369: ARRAY
62370: IFFALSE 62394
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62372: LD_ADDR_EXP 54
62376: PUSH
62377: LD_EXP 54
62381: PPUSH
62382: LD_VAR 0 2
62386: PPUSH
62387: EMPTY
62388: PPUSH
62389: CALL_OW 1
62393: ST_TO_ADDR
// for j in tmp do
62394: LD_ADDR_VAR 0 3
62398: PUSH
62399: LD_VAR 0 4
62403: PUSH
62404: FOR_IN
62405: IFFALSE 62628
// begin if IsInUnit ( j ) then
62407: LD_VAR 0 3
62411: PPUSH
62412: CALL_OW 310
62416: IFFALSE 62427
// ComExitBuilding ( j ) ;
62418: LD_VAR 0 3
62422: PPUSH
62423: CALL_OW 122
// if not j in mc_healers [ i ] then
62427: LD_VAR 0 3
62431: PUSH
62432: LD_EXP 27
62436: PUSH
62437: LD_VAR 0 2
62441: ARRAY
62442: IN
62443: NOT
62444: IFFALSE 62490
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62446: LD_ADDR_EXP 27
62450: PUSH
62451: LD_EXP 27
62455: PPUSH
62456: LD_VAR 0 2
62460: PUSH
62461: LD_EXP 27
62465: PUSH
62466: LD_VAR 0 2
62470: ARRAY
62471: PUSH
62472: LD_INT 1
62474: PLUS
62475: PUSH
62476: EMPTY
62477: LIST
62478: LIST
62479: PPUSH
62480: LD_VAR 0 3
62484: PPUSH
62485: CALL 16166 0 3
62489: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62490: LD_VAR 0 3
62494: PPUSH
62495: CALL_OW 110
62499: PUSH
62500: LD_INT 102
62502: NONEQUAL
62503: IFFALSE 62517
// SetTag ( j , 102 ) ;
62505: LD_VAR 0 3
62509: PPUSH
62510: LD_INT 102
62512: PPUSH
62513: CALL_OW 109
// Wait ( 3 ) ;
62517: LD_INT 3
62519: PPUSH
62520: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62524: LD_EXP 26
62528: PUSH
62529: LD_VAR 0 2
62533: ARRAY
62534: PUSH
62535: LD_INT 1
62537: ARRAY
62538: IFFALSE 62570
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62540: LD_VAR 0 3
62544: PPUSH
62545: LD_EXP 26
62549: PUSH
62550: LD_VAR 0 2
62554: ARRAY
62555: PUSH
62556: LD_INT 1
62558: ARRAY
62559: PUSH
62560: LD_INT 1
62562: ARRAY
62563: PPUSH
62564: CALL_OW 128
62568: GO 62626
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62570: LD_VAR 0 3
62574: PPUSH
62575: CALL_OW 314
62579: NOT
62580: PUSH
62581: LD_EXP 26
62585: PUSH
62586: LD_VAR 0 2
62590: ARRAY
62591: PUSH
62592: LD_INT 2
62594: ARRAY
62595: AND
62596: IFFALSE 62626
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62598: LD_VAR 0 3
62602: PPUSH
62603: LD_EXP 26
62607: PUSH
62608: LD_VAR 0 2
62612: ARRAY
62613: PUSH
62614: LD_INT 2
62616: ARRAY
62617: PUSH
62618: LD_INT 1
62620: ARRAY
62621: PPUSH
62622: CALL_OW 128
// end ;
62626: GO 62404
62628: POP
62629: POP
// end ;
62630: GO 62247
62632: POP
62633: POP
// end ;
62634: LD_VAR 0 1
62638: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
62639: LD_INT 0
62641: PPUSH
62642: PPUSH
62643: PPUSH
62644: PPUSH
62645: PPUSH
// if not mc_bases then
62646: LD_EXP 23
62650: NOT
62651: IFFALSE 62655
// exit ;
62653: GO 63826
// for i = 1 to mc_bases do
62655: LD_ADDR_VAR 0 2
62659: PUSH
62660: DOUBLE
62661: LD_INT 1
62663: DEC
62664: ST_TO_ADDR
62665: LD_EXP 23
62669: PUSH
62670: FOR_TO
62671: IFFALSE 63824
// begin if mc_scan [ i ] then
62673: LD_EXP 46
62677: PUSH
62678: LD_VAR 0 2
62682: ARRAY
62683: IFFALSE 62687
// continue ;
62685: GO 62670
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62687: LD_EXP 28
62691: PUSH
62692: LD_VAR 0 2
62696: ARRAY
62697: NOT
62698: PUSH
62699: LD_EXP 30
62703: PUSH
62704: LD_VAR 0 2
62708: ARRAY
62709: NOT
62710: AND
62711: PUSH
62712: LD_EXP 29
62716: PUSH
62717: LD_VAR 0 2
62721: ARRAY
62722: AND
62723: IFFALSE 62761
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62725: LD_ADDR_EXP 29
62729: PUSH
62730: LD_EXP 29
62734: PPUSH
62735: LD_VAR 0 2
62739: PPUSH
62740: EMPTY
62741: PPUSH
62742: CALL_OW 1
62746: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62747: LD_VAR 0 2
62751: PPUSH
62752: LD_INT 103
62754: PPUSH
62755: CALL 56397 0 2
// continue ;
62759: GO 62670
// end ; if mc_construct_list [ i ] then
62761: LD_EXP 30
62765: PUSH
62766: LD_VAR 0 2
62770: ARRAY
62771: IFFALSE 62991
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62773: LD_ADDR_VAR 0 4
62777: PUSH
62778: LD_EXP 23
62782: PUSH
62783: LD_VAR 0 2
62787: ARRAY
62788: PPUSH
62789: LD_INT 25
62791: PUSH
62792: LD_INT 2
62794: PUSH
62795: EMPTY
62796: LIST
62797: LIST
62798: PPUSH
62799: CALL_OW 72
62803: PUSH
62804: LD_EXP 25
62808: PUSH
62809: LD_VAR 0 2
62813: ARRAY
62814: DIFF
62815: ST_TO_ADDR
// if not tmp then
62816: LD_VAR 0 4
62820: NOT
62821: IFFALSE 62825
// continue ;
62823: GO 62670
// for j in tmp do
62825: LD_ADDR_VAR 0 3
62829: PUSH
62830: LD_VAR 0 4
62834: PUSH
62835: FOR_IN
62836: IFFALSE 62987
// begin if not mc_builders [ i ] then
62838: LD_EXP 29
62842: PUSH
62843: LD_VAR 0 2
62847: ARRAY
62848: NOT
62849: IFFALSE 62907
// begin SetTag ( j , 103 ) ;
62851: LD_VAR 0 3
62855: PPUSH
62856: LD_INT 103
62858: PPUSH
62859: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62863: LD_ADDR_EXP 29
62867: PUSH
62868: LD_EXP 29
62872: PPUSH
62873: LD_VAR 0 2
62877: PUSH
62878: LD_EXP 29
62882: PUSH
62883: LD_VAR 0 2
62887: ARRAY
62888: PUSH
62889: LD_INT 1
62891: PLUS
62892: PUSH
62893: EMPTY
62894: LIST
62895: LIST
62896: PPUSH
62897: LD_VAR 0 3
62901: PPUSH
62902: CALL 16166 0 3
62906: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62907: LD_VAR 0 3
62911: PPUSH
62912: CALL_OW 310
62916: IFFALSE 62927
// ComExitBuilding ( j ) ;
62918: LD_VAR 0 3
62922: PPUSH
62923: CALL_OW 122
// wait ( 3 ) ;
62927: LD_INT 3
62929: PPUSH
62930: CALL_OW 67
// if not mc_construct_list [ i ] then
62934: LD_EXP 30
62938: PUSH
62939: LD_VAR 0 2
62943: ARRAY
62944: NOT
62945: IFFALSE 62949
// break ;
62947: GO 62987
// if not HasTask ( j ) then
62949: LD_VAR 0 3
62953: PPUSH
62954: CALL_OW 314
62958: NOT
62959: IFFALSE 62985
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62961: LD_VAR 0 3
62965: PPUSH
62966: LD_EXP 30
62970: PUSH
62971: LD_VAR 0 2
62975: ARRAY
62976: PUSH
62977: LD_INT 1
62979: ARRAY
62980: PPUSH
62981: CALL 19029 0 2
// end ;
62985: GO 62835
62987: POP
62988: POP
// end else
62989: GO 63822
// if mc_build_list [ i ] then
62991: LD_EXP 28
62995: PUSH
62996: LD_VAR 0 2
63000: ARRAY
63001: IFFALSE 63822
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63003: LD_ADDR_VAR 0 5
63007: PUSH
63008: LD_EXP 23
63012: PUSH
63013: LD_VAR 0 2
63017: ARRAY
63018: PPUSH
63019: LD_INT 2
63021: PUSH
63022: LD_INT 30
63024: PUSH
63025: LD_INT 0
63027: PUSH
63028: EMPTY
63029: LIST
63030: LIST
63031: PUSH
63032: LD_INT 30
63034: PUSH
63035: LD_INT 1
63037: PUSH
63038: EMPTY
63039: LIST
63040: LIST
63041: PUSH
63042: EMPTY
63043: LIST
63044: LIST
63045: LIST
63046: PPUSH
63047: CALL_OW 72
63051: ST_TO_ADDR
// if depot then
63052: LD_VAR 0 5
63056: IFFALSE 63074
// depot := depot [ 1 ] else
63058: LD_ADDR_VAR 0 5
63062: PUSH
63063: LD_VAR 0 5
63067: PUSH
63068: LD_INT 1
63070: ARRAY
63071: ST_TO_ADDR
63072: GO 63082
// depot := 0 ;
63074: LD_ADDR_VAR 0 5
63078: PUSH
63079: LD_INT 0
63081: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63082: LD_EXP 28
63086: PUSH
63087: LD_VAR 0 2
63091: ARRAY
63092: PUSH
63093: LD_INT 1
63095: ARRAY
63096: PUSH
63097: LD_INT 1
63099: ARRAY
63100: PPUSH
63101: CALL 18853 0 1
63105: PUSH
63106: LD_EXP 23
63110: PUSH
63111: LD_VAR 0 2
63115: ARRAY
63116: PPUSH
63117: LD_INT 2
63119: PUSH
63120: LD_INT 30
63122: PUSH
63123: LD_INT 2
63125: PUSH
63126: EMPTY
63127: LIST
63128: LIST
63129: PUSH
63130: LD_INT 30
63132: PUSH
63133: LD_INT 3
63135: PUSH
63136: EMPTY
63137: LIST
63138: LIST
63139: PUSH
63140: EMPTY
63141: LIST
63142: LIST
63143: LIST
63144: PPUSH
63145: CALL_OW 72
63149: NOT
63150: AND
63151: IFFALSE 63256
// begin for j = 1 to mc_build_list [ i ] do
63153: LD_ADDR_VAR 0 3
63157: PUSH
63158: DOUBLE
63159: LD_INT 1
63161: DEC
63162: ST_TO_ADDR
63163: LD_EXP 28
63167: PUSH
63168: LD_VAR 0 2
63172: ARRAY
63173: PUSH
63174: FOR_TO
63175: IFFALSE 63254
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63177: LD_EXP 28
63181: PUSH
63182: LD_VAR 0 2
63186: ARRAY
63187: PUSH
63188: LD_VAR 0 3
63192: ARRAY
63193: PUSH
63194: LD_INT 1
63196: ARRAY
63197: PUSH
63198: LD_INT 2
63200: EQUAL
63201: IFFALSE 63252
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63203: LD_ADDR_EXP 28
63207: PUSH
63208: LD_EXP 28
63212: PPUSH
63213: LD_VAR 0 2
63217: PPUSH
63218: LD_EXP 28
63222: PUSH
63223: LD_VAR 0 2
63227: ARRAY
63228: PPUSH
63229: LD_VAR 0 3
63233: PPUSH
63234: LD_INT 1
63236: PPUSH
63237: LD_INT 0
63239: PPUSH
63240: CALL 15584 0 4
63244: PPUSH
63245: CALL_OW 1
63249: ST_TO_ADDR
// break ;
63250: GO 63254
// end ;
63252: GO 63174
63254: POP
63255: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
63256: LD_EXP 28
63260: PUSH
63261: LD_VAR 0 2
63265: ARRAY
63266: PUSH
63267: LD_INT 1
63269: ARRAY
63270: PUSH
63271: LD_INT 1
63273: ARRAY
63274: PUSH
63275: LD_INT 0
63277: EQUAL
63278: PUSH
63279: LD_VAR 0 5
63283: PUSH
63284: LD_VAR 0 5
63288: PPUSH
63289: LD_EXP 28
63293: PUSH
63294: LD_VAR 0 2
63298: ARRAY
63299: PUSH
63300: LD_INT 1
63302: ARRAY
63303: PUSH
63304: LD_INT 1
63306: ARRAY
63307: PPUSH
63308: LD_EXP 28
63312: PUSH
63313: LD_VAR 0 2
63317: ARRAY
63318: PUSH
63319: LD_INT 1
63321: ARRAY
63322: PUSH
63323: LD_INT 2
63325: ARRAY
63326: PPUSH
63327: LD_EXP 28
63331: PUSH
63332: LD_VAR 0 2
63336: ARRAY
63337: PUSH
63338: LD_INT 1
63340: ARRAY
63341: PUSH
63342: LD_INT 3
63344: ARRAY
63345: PPUSH
63346: LD_EXP 28
63350: PUSH
63351: LD_VAR 0 2
63355: ARRAY
63356: PUSH
63357: LD_INT 1
63359: ARRAY
63360: PUSH
63361: LD_INT 4
63363: ARRAY
63364: PPUSH
63365: CALL 24269 0 5
63369: AND
63370: OR
63371: IFFALSE 63652
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63373: LD_ADDR_VAR 0 4
63377: PUSH
63378: LD_EXP 23
63382: PUSH
63383: LD_VAR 0 2
63387: ARRAY
63388: PPUSH
63389: LD_INT 25
63391: PUSH
63392: LD_INT 2
63394: PUSH
63395: EMPTY
63396: LIST
63397: LIST
63398: PPUSH
63399: CALL_OW 72
63403: PUSH
63404: LD_EXP 25
63408: PUSH
63409: LD_VAR 0 2
63413: ARRAY
63414: DIFF
63415: ST_TO_ADDR
// if not tmp then
63416: LD_VAR 0 4
63420: NOT
63421: IFFALSE 63425
// continue ;
63423: GO 62670
// for j in tmp do
63425: LD_ADDR_VAR 0 3
63429: PUSH
63430: LD_VAR 0 4
63434: PUSH
63435: FOR_IN
63436: IFFALSE 63648
// begin if not mc_builders [ i ] then
63438: LD_EXP 29
63442: PUSH
63443: LD_VAR 0 2
63447: ARRAY
63448: NOT
63449: IFFALSE 63507
// begin SetTag ( j , 103 ) ;
63451: LD_VAR 0 3
63455: PPUSH
63456: LD_INT 103
63458: PPUSH
63459: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63463: LD_ADDR_EXP 29
63467: PUSH
63468: LD_EXP 29
63472: PPUSH
63473: LD_VAR 0 2
63477: PUSH
63478: LD_EXP 29
63482: PUSH
63483: LD_VAR 0 2
63487: ARRAY
63488: PUSH
63489: LD_INT 1
63491: PLUS
63492: PUSH
63493: EMPTY
63494: LIST
63495: LIST
63496: PPUSH
63497: LD_VAR 0 3
63501: PPUSH
63502: CALL 16166 0 3
63506: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63507: LD_VAR 0 3
63511: PPUSH
63512: CALL_OW 310
63516: IFFALSE 63527
// ComExitBuilding ( j ) ;
63518: LD_VAR 0 3
63522: PPUSH
63523: CALL_OW 122
// wait ( 3 ) ;
63527: LD_INT 3
63529: PPUSH
63530: CALL_OW 67
// if not mc_build_list [ i ] then
63534: LD_EXP 28
63538: PUSH
63539: LD_VAR 0 2
63543: ARRAY
63544: NOT
63545: IFFALSE 63549
// break ;
63547: GO 63648
// if not HasTask ( j ) then
63549: LD_VAR 0 3
63553: PPUSH
63554: CALL_OW 314
63558: NOT
63559: IFFALSE 63646
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63561: LD_VAR 0 3
63565: PPUSH
63566: LD_EXP 28
63570: PUSH
63571: LD_VAR 0 2
63575: ARRAY
63576: PUSH
63577: LD_INT 1
63579: ARRAY
63580: PUSH
63581: LD_INT 1
63583: ARRAY
63584: PPUSH
63585: LD_EXP 28
63589: PUSH
63590: LD_VAR 0 2
63594: ARRAY
63595: PUSH
63596: LD_INT 1
63598: ARRAY
63599: PUSH
63600: LD_INT 2
63602: ARRAY
63603: PPUSH
63604: LD_EXP 28
63608: PUSH
63609: LD_VAR 0 2
63613: ARRAY
63614: PUSH
63615: LD_INT 1
63617: ARRAY
63618: PUSH
63619: LD_INT 3
63621: ARRAY
63622: PPUSH
63623: LD_EXP 28
63627: PUSH
63628: LD_VAR 0 2
63632: ARRAY
63633: PUSH
63634: LD_INT 1
63636: ARRAY
63637: PUSH
63638: LD_INT 4
63640: ARRAY
63641: PPUSH
63642: CALL_OW 145
// end ;
63646: GO 63435
63648: POP
63649: POP
// end else
63650: GO 63822
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63652: LD_EXP 23
63656: PUSH
63657: LD_VAR 0 2
63661: ARRAY
63662: PPUSH
63663: LD_EXP 28
63667: PUSH
63668: LD_VAR 0 2
63672: ARRAY
63673: PUSH
63674: LD_INT 1
63676: ARRAY
63677: PUSH
63678: LD_INT 1
63680: ARRAY
63681: PPUSH
63682: LD_EXP 28
63686: PUSH
63687: LD_VAR 0 2
63691: ARRAY
63692: PUSH
63693: LD_INT 1
63695: ARRAY
63696: PUSH
63697: LD_INT 2
63699: ARRAY
63700: PPUSH
63701: LD_EXP 28
63705: PUSH
63706: LD_VAR 0 2
63710: ARRAY
63711: PUSH
63712: LD_INT 1
63714: ARRAY
63715: PUSH
63716: LD_INT 3
63718: ARRAY
63719: PPUSH
63720: LD_EXP 28
63724: PUSH
63725: LD_VAR 0 2
63729: ARRAY
63730: PUSH
63731: LD_INT 1
63733: ARRAY
63734: PUSH
63735: LD_INT 4
63737: ARRAY
63738: PPUSH
63739: LD_EXP 23
63743: PUSH
63744: LD_VAR 0 2
63748: ARRAY
63749: PPUSH
63750: LD_INT 21
63752: PUSH
63753: LD_INT 3
63755: PUSH
63756: EMPTY
63757: LIST
63758: LIST
63759: PPUSH
63760: CALL_OW 72
63764: PPUSH
63765: EMPTY
63766: PPUSH
63767: CALL 23019 0 7
63771: NOT
63772: IFFALSE 63822
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63774: LD_ADDR_EXP 28
63778: PUSH
63779: LD_EXP 28
63783: PPUSH
63784: LD_VAR 0 2
63788: PPUSH
63789: LD_EXP 28
63793: PUSH
63794: LD_VAR 0 2
63798: ARRAY
63799: PPUSH
63800: LD_INT 1
63802: PPUSH
63803: LD_INT 1
63805: NEG
63806: PPUSH
63807: LD_INT 0
63809: PPUSH
63810: CALL 15584 0 4
63814: PPUSH
63815: CALL_OW 1
63819: ST_TO_ADDR
// continue ;
63820: GO 62670
// end ; end ; end ;
63822: GO 62670
63824: POP
63825: POP
// end ;
63826: LD_VAR 0 1
63830: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63831: LD_INT 0
63833: PPUSH
63834: PPUSH
63835: PPUSH
63836: PPUSH
63837: PPUSH
63838: PPUSH
// if not mc_bases then
63839: LD_EXP 23
63843: NOT
63844: IFFALSE 63848
// exit ;
63846: GO 64275
// for i = 1 to mc_bases do
63848: LD_ADDR_VAR 0 2
63852: PUSH
63853: DOUBLE
63854: LD_INT 1
63856: DEC
63857: ST_TO_ADDR
63858: LD_EXP 23
63862: PUSH
63863: FOR_TO
63864: IFFALSE 64273
// begin tmp := mc_build_upgrade [ i ] ;
63866: LD_ADDR_VAR 0 4
63870: PUSH
63871: LD_EXP 55
63875: PUSH
63876: LD_VAR 0 2
63880: ARRAY
63881: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63882: LD_ADDR_VAR 0 6
63886: PUSH
63887: LD_EXP 56
63891: PUSH
63892: LD_VAR 0 2
63896: ARRAY
63897: PPUSH
63898: LD_INT 2
63900: PUSH
63901: LD_INT 30
63903: PUSH
63904: LD_INT 6
63906: PUSH
63907: EMPTY
63908: LIST
63909: LIST
63910: PUSH
63911: LD_INT 30
63913: PUSH
63914: LD_INT 7
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: PUSH
63921: EMPTY
63922: LIST
63923: LIST
63924: LIST
63925: PPUSH
63926: CALL_OW 72
63930: ST_TO_ADDR
// if not tmp and not lab then
63931: LD_VAR 0 4
63935: NOT
63936: PUSH
63937: LD_VAR 0 6
63941: NOT
63942: AND
63943: IFFALSE 63947
// continue ;
63945: GO 63863
// if tmp then
63947: LD_VAR 0 4
63951: IFFALSE 64071
// for j in tmp do
63953: LD_ADDR_VAR 0 3
63957: PUSH
63958: LD_VAR 0 4
63962: PUSH
63963: FOR_IN
63964: IFFALSE 64069
// begin if UpgradeCost ( j ) then
63966: LD_VAR 0 3
63970: PPUSH
63971: CALL 22679 0 1
63975: IFFALSE 64067
// begin ComUpgrade ( j ) ;
63977: LD_VAR 0 3
63981: PPUSH
63982: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63986: LD_ADDR_EXP 55
63990: PUSH
63991: LD_EXP 55
63995: PPUSH
63996: LD_VAR 0 2
64000: PPUSH
64001: LD_EXP 55
64005: PUSH
64006: LD_VAR 0 2
64010: ARRAY
64011: PUSH
64012: LD_VAR 0 3
64016: DIFF
64017: PPUSH
64018: CALL_OW 1
64022: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64023: LD_ADDR_EXP 30
64027: PUSH
64028: LD_EXP 30
64032: PPUSH
64033: LD_VAR 0 2
64037: PUSH
64038: LD_EXP 30
64042: PUSH
64043: LD_VAR 0 2
64047: ARRAY
64048: PUSH
64049: LD_INT 1
64051: PLUS
64052: PUSH
64053: EMPTY
64054: LIST
64055: LIST
64056: PPUSH
64057: LD_VAR 0 3
64061: PPUSH
64062: CALL 16166 0 3
64066: ST_TO_ADDR
// end ; end ;
64067: GO 63963
64069: POP
64070: POP
// if not lab or not mc_lab_upgrade [ i ] then
64071: LD_VAR 0 6
64075: NOT
64076: PUSH
64077: LD_EXP 57
64081: PUSH
64082: LD_VAR 0 2
64086: ARRAY
64087: NOT
64088: OR
64089: IFFALSE 64093
// continue ;
64091: GO 63863
// for j in lab do
64093: LD_ADDR_VAR 0 3
64097: PUSH
64098: LD_VAR 0 6
64102: PUSH
64103: FOR_IN
64104: IFFALSE 64269
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64106: LD_VAR 0 3
64110: PPUSH
64111: CALL_OW 266
64115: PUSH
64116: LD_INT 6
64118: PUSH
64119: LD_INT 7
64121: PUSH
64122: EMPTY
64123: LIST
64124: LIST
64125: IN
64126: PUSH
64127: LD_VAR 0 3
64131: PPUSH
64132: CALL_OW 461
64136: PUSH
64137: LD_INT 1
64139: NONEQUAL
64140: AND
64141: IFFALSE 64267
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64143: LD_VAR 0 3
64147: PPUSH
64148: LD_EXP 57
64152: PUSH
64153: LD_VAR 0 2
64157: ARRAY
64158: PUSH
64159: LD_INT 1
64161: ARRAY
64162: PPUSH
64163: CALL 22884 0 2
64167: IFFALSE 64267
// begin ComCancel ( j ) ;
64169: LD_VAR 0 3
64173: PPUSH
64174: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64178: LD_VAR 0 3
64182: PPUSH
64183: LD_EXP 57
64187: PUSH
64188: LD_VAR 0 2
64192: ARRAY
64193: PUSH
64194: LD_INT 1
64196: ARRAY
64197: PPUSH
64198: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64202: LD_VAR 0 3
64206: PUSH
64207: LD_EXP 30
64211: PUSH
64212: LD_VAR 0 2
64216: ARRAY
64217: IN
64218: NOT
64219: IFFALSE 64265
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64221: LD_ADDR_EXP 30
64225: PUSH
64226: LD_EXP 30
64230: PPUSH
64231: LD_VAR 0 2
64235: PUSH
64236: LD_EXP 30
64240: PUSH
64241: LD_VAR 0 2
64245: ARRAY
64246: PUSH
64247: LD_INT 1
64249: PLUS
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PPUSH
64255: LD_VAR 0 3
64259: PPUSH
64260: CALL 16166 0 3
64264: ST_TO_ADDR
// break ;
64265: GO 64269
// end ; end ; end ;
64267: GO 64103
64269: POP
64270: POP
// end ;
64271: GO 63863
64273: POP
64274: POP
// end ;
64275: LD_VAR 0 1
64279: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64280: LD_INT 0
64282: PPUSH
64283: PPUSH
64284: PPUSH
64285: PPUSH
64286: PPUSH
64287: PPUSH
64288: PPUSH
64289: PPUSH
64290: PPUSH
// if not mc_bases then
64291: LD_EXP 23
64295: NOT
64296: IFFALSE 64300
// exit ;
64298: GO 64705
// for i = 1 to mc_bases do
64300: LD_ADDR_VAR 0 2
64304: PUSH
64305: DOUBLE
64306: LD_INT 1
64308: DEC
64309: ST_TO_ADDR
64310: LD_EXP 23
64314: PUSH
64315: FOR_TO
64316: IFFALSE 64703
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64318: LD_EXP 31
64322: PUSH
64323: LD_VAR 0 2
64327: ARRAY
64328: NOT
64329: PUSH
64330: LD_EXP 23
64334: PUSH
64335: LD_VAR 0 2
64339: ARRAY
64340: PPUSH
64341: LD_INT 30
64343: PUSH
64344: LD_INT 3
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PPUSH
64351: CALL_OW 72
64355: NOT
64356: OR
64357: IFFALSE 64361
// continue ;
64359: GO 64315
// busy := false ;
64361: LD_ADDR_VAR 0 8
64365: PUSH
64366: LD_INT 0
64368: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64369: LD_ADDR_VAR 0 4
64373: PUSH
64374: LD_EXP 23
64378: PUSH
64379: LD_VAR 0 2
64383: ARRAY
64384: PPUSH
64385: LD_INT 30
64387: PUSH
64388: LD_INT 3
64390: PUSH
64391: EMPTY
64392: LIST
64393: LIST
64394: PPUSH
64395: CALL_OW 72
64399: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64400: LD_ADDR_VAR 0 6
64404: PUSH
64405: LD_EXP 31
64409: PUSH
64410: LD_VAR 0 2
64414: ARRAY
64415: PPUSH
64416: LD_INT 2
64418: PUSH
64419: LD_INT 30
64421: PUSH
64422: LD_INT 32
64424: PUSH
64425: EMPTY
64426: LIST
64427: LIST
64428: PUSH
64429: LD_INT 30
64431: PUSH
64432: LD_INT 33
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: LIST
64443: PPUSH
64444: CALL_OW 72
64448: ST_TO_ADDR
// if not t then
64449: LD_VAR 0 6
64453: NOT
64454: IFFALSE 64458
// continue ;
64456: GO 64315
// for j in tmp do
64458: LD_ADDR_VAR 0 3
64462: PUSH
64463: LD_VAR 0 4
64467: PUSH
64468: FOR_IN
64469: IFFALSE 64499
// if not BuildingStatus ( j ) = bs_idle then
64471: LD_VAR 0 3
64475: PPUSH
64476: CALL_OW 461
64480: PUSH
64481: LD_INT 2
64483: EQUAL
64484: NOT
64485: IFFALSE 64497
// begin busy := true ;
64487: LD_ADDR_VAR 0 8
64491: PUSH
64492: LD_INT 1
64494: ST_TO_ADDR
// break ;
64495: GO 64499
// end ;
64497: GO 64468
64499: POP
64500: POP
// if busy then
64501: LD_VAR 0 8
64505: IFFALSE 64509
// continue ;
64507: GO 64315
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64509: LD_ADDR_VAR 0 7
64513: PUSH
64514: LD_VAR 0 6
64518: PPUSH
64519: LD_INT 35
64521: PUSH
64522: LD_INT 0
64524: PUSH
64525: EMPTY
64526: LIST
64527: LIST
64528: PPUSH
64529: CALL_OW 72
64533: ST_TO_ADDR
// if tw then
64534: LD_VAR 0 7
64538: IFFALSE 64615
// begin tw := tw [ 1 ] ;
64540: LD_ADDR_VAR 0 7
64544: PUSH
64545: LD_VAR 0 7
64549: PUSH
64550: LD_INT 1
64552: ARRAY
64553: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64554: LD_ADDR_VAR 0 9
64558: PUSH
64559: LD_VAR 0 7
64563: PPUSH
64564: LD_EXP 48
64568: PUSH
64569: LD_VAR 0 2
64573: ARRAY
64574: PPUSH
64575: CALL 21176 0 2
64579: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64580: LD_EXP 62
64584: PUSH
64585: LD_VAR 0 2
64589: ARRAY
64590: IFFALSE 64613
// if not weapon in mc_allowed_tower_weapons [ i ] then
64592: LD_VAR 0 9
64596: PUSH
64597: LD_EXP 62
64601: PUSH
64602: LD_VAR 0 2
64606: ARRAY
64607: IN
64608: NOT
64609: IFFALSE 64613
// continue ;
64611: GO 64315
// end else
64613: GO 64678
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64615: LD_ADDR_VAR 0 5
64619: PUSH
64620: LD_EXP 31
64624: PUSH
64625: LD_VAR 0 2
64629: ARRAY
64630: PPUSH
64631: LD_VAR 0 4
64635: PPUSH
64636: CALL 47976 0 2
64640: ST_TO_ADDR
// if not tmp2 then
64641: LD_VAR 0 5
64645: NOT
64646: IFFALSE 64650
// continue ;
64648: GO 64315
// tw := tmp2 [ 1 ] ;
64650: LD_ADDR_VAR 0 7
64654: PUSH
64655: LD_VAR 0 5
64659: PUSH
64660: LD_INT 1
64662: ARRAY
64663: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64664: LD_ADDR_VAR 0 9
64668: PUSH
64669: LD_VAR 0 5
64673: PUSH
64674: LD_INT 2
64676: ARRAY
64677: ST_TO_ADDR
// end ; if not weapon then
64678: LD_VAR 0 9
64682: NOT
64683: IFFALSE 64687
// continue ;
64685: GO 64315
// ComPlaceWeapon ( tw , weapon ) ;
64687: LD_VAR 0 7
64691: PPUSH
64692: LD_VAR 0 9
64696: PPUSH
64697: CALL_OW 148
// end ;
64701: GO 64315
64703: POP
64704: POP
// end ;
64705: LD_VAR 0 1
64709: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64710: LD_INT 0
64712: PPUSH
64713: PPUSH
64714: PPUSH
64715: PPUSH
64716: PPUSH
64717: PPUSH
64718: PPUSH
// if not mc_bases then
64719: LD_EXP 23
64723: NOT
64724: IFFALSE 64728
// exit ;
64726: GO 65496
// for i = 1 to mc_bases do
64728: LD_ADDR_VAR 0 2
64732: PUSH
64733: DOUBLE
64734: LD_INT 1
64736: DEC
64737: ST_TO_ADDR
64738: LD_EXP 23
64742: PUSH
64743: FOR_TO
64744: IFFALSE 65494
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64746: LD_EXP 36
64750: PUSH
64751: LD_VAR 0 2
64755: ARRAY
64756: NOT
64757: PUSH
64758: LD_EXP 36
64762: PUSH
64763: LD_VAR 0 2
64767: ARRAY
64768: PUSH
64769: LD_EXP 37
64773: PUSH
64774: LD_VAR 0 2
64778: ARRAY
64779: EQUAL
64780: OR
64781: PUSH
64782: LD_EXP 46
64786: PUSH
64787: LD_VAR 0 2
64791: ARRAY
64792: OR
64793: IFFALSE 64797
// continue ;
64795: GO 64743
// if mc_miners [ i ] then
64797: LD_EXP 37
64801: PUSH
64802: LD_VAR 0 2
64806: ARRAY
64807: IFFALSE 65181
// begin for j = mc_miners [ i ] downto 1 do
64809: LD_ADDR_VAR 0 3
64813: PUSH
64814: DOUBLE
64815: LD_EXP 37
64819: PUSH
64820: LD_VAR 0 2
64824: ARRAY
64825: INC
64826: ST_TO_ADDR
64827: LD_INT 1
64829: PUSH
64830: FOR_DOWNTO
64831: IFFALSE 65179
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64833: LD_EXP 37
64837: PUSH
64838: LD_VAR 0 2
64842: ARRAY
64843: PUSH
64844: LD_VAR 0 3
64848: ARRAY
64849: PPUSH
64850: CALL_OW 301
64854: PUSH
64855: LD_EXP 37
64859: PUSH
64860: LD_VAR 0 2
64864: ARRAY
64865: PUSH
64866: LD_VAR 0 3
64870: ARRAY
64871: PPUSH
64872: CALL_OW 257
64876: PUSH
64877: LD_INT 1
64879: NONEQUAL
64880: OR
64881: IFFALSE 64944
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64883: LD_ADDR_VAR 0 5
64887: PUSH
64888: LD_EXP 37
64892: PUSH
64893: LD_VAR 0 2
64897: ARRAY
64898: PUSH
64899: LD_EXP 37
64903: PUSH
64904: LD_VAR 0 2
64908: ARRAY
64909: PUSH
64910: LD_VAR 0 3
64914: ARRAY
64915: DIFF
64916: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64917: LD_ADDR_EXP 37
64921: PUSH
64922: LD_EXP 37
64926: PPUSH
64927: LD_VAR 0 2
64931: PPUSH
64932: LD_VAR 0 5
64936: PPUSH
64937: CALL_OW 1
64941: ST_TO_ADDR
// continue ;
64942: GO 64830
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64944: LD_EXP 37
64948: PUSH
64949: LD_VAR 0 2
64953: ARRAY
64954: PUSH
64955: LD_VAR 0 3
64959: ARRAY
64960: PPUSH
64961: CALL_OW 257
64965: PUSH
64966: LD_INT 1
64968: EQUAL
64969: PUSH
64970: LD_EXP 37
64974: PUSH
64975: LD_VAR 0 2
64979: ARRAY
64980: PUSH
64981: LD_VAR 0 3
64985: ARRAY
64986: PPUSH
64987: CALL_OW 459
64991: NOT
64992: AND
64993: PUSH
64994: LD_EXP 37
64998: PUSH
64999: LD_VAR 0 2
65003: ARRAY
65004: PUSH
65005: LD_VAR 0 3
65009: ARRAY
65010: PPUSH
65011: CALL_OW 314
65015: NOT
65016: AND
65017: IFFALSE 65177
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65019: LD_EXP 37
65023: PUSH
65024: LD_VAR 0 2
65028: ARRAY
65029: PUSH
65030: LD_VAR 0 3
65034: ARRAY
65035: PPUSH
65036: CALL_OW 310
65040: IFFALSE 65063
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65042: LD_EXP 37
65046: PUSH
65047: LD_VAR 0 2
65051: ARRAY
65052: PUSH
65053: LD_VAR 0 3
65057: ARRAY
65058: PPUSH
65059: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65063: LD_EXP 37
65067: PUSH
65068: LD_VAR 0 2
65072: ARRAY
65073: PUSH
65074: LD_VAR 0 3
65078: ARRAY
65079: PPUSH
65080: CALL_OW 314
65084: NOT
65085: IFFALSE 65177
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65087: LD_ADDR_VAR 0 7
65091: PUSH
65092: LD_INT 1
65094: PPUSH
65095: LD_EXP 36
65099: PUSH
65100: LD_VAR 0 2
65104: ARRAY
65105: PPUSH
65106: CALL_OW 12
65110: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65111: LD_EXP 37
65115: PUSH
65116: LD_VAR 0 2
65120: ARRAY
65121: PUSH
65122: LD_VAR 0 3
65126: ARRAY
65127: PPUSH
65128: LD_EXP 36
65132: PUSH
65133: LD_VAR 0 2
65137: ARRAY
65138: PUSH
65139: LD_VAR 0 7
65143: ARRAY
65144: PUSH
65145: LD_INT 1
65147: ARRAY
65148: PPUSH
65149: LD_EXP 36
65153: PUSH
65154: LD_VAR 0 2
65158: ARRAY
65159: PUSH
65160: LD_VAR 0 7
65164: ARRAY
65165: PUSH
65166: LD_INT 2
65168: ARRAY
65169: PPUSH
65170: LD_INT 0
65172: PPUSH
65173: CALL_OW 193
// end ; end ; end ;
65177: GO 64830
65179: POP
65180: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65181: LD_ADDR_VAR 0 5
65185: PUSH
65186: LD_EXP 23
65190: PUSH
65191: LD_VAR 0 2
65195: ARRAY
65196: PPUSH
65197: LD_INT 2
65199: PUSH
65200: LD_INT 30
65202: PUSH
65203: LD_INT 4
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 30
65212: PUSH
65213: LD_INT 5
65215: PUSH
65216: EMPTY
65217: LIST
65218: LIST
65219: PUSH
65220: LD_INT 30
65222: PUSH
65223: LD_INT 32
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: EMPTY
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: PPUSH
65236: CALL_OW 72
65240: ST_TO_ADDR
// if not tmp then
65241: LD_VAR 0 5
65245: NOT
65246: IFFALSE 65250
// continue ;
65248: GO 64743
// list := [ ] ;
65250: LD_ADDR_VAR 0 6
65254: PUSH
65255: EMPTY
65256: ST_TO_ADDR
// for j in tmp do
65257: LD_ADDR_VAR 0 3
65261: PUSH
65262: LD_VAR 0 5
65266: PUSH
65267: FOR_IN
65268: IFFALSE 65337
// begin for k in UnitsInside ( j ) do
65270: LD_ADDR_VAR 0 4
65274: PUSH
65275: LD_VAR 0 3
65279: PPUSH
65280: CALL_OW 313
65284: PUSH
65285: FOR_IN
65286: IFFALSE 65333
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65288: LD_VAR 0 4
65292: PPUSH
65293: CALL_OW 257
65297: PUSH
65298: LD_INT 1
65300: EQUAL
65301: PUSH
65302: LD_VAR 0 4
65306: PPUSH
65307: CALL_OW 459
65311: NOT
65312: AND
65313: IFFALSE 65331
// list := list ^ k ;
65315: LD_ADDR_VAR 0 6
65319: PUSH
65320: LD_VAR 0 6
65324: PUSH
65325: LD_VAR 0 4
65329: ADD
65330: ST_TO_ADDR
65331: GO 65285
65333: POP
65334: POP
// end ;
65335: GO 65267
65337: POP
65338: POP
// list := list diff mc_miners [ i ] ;
65339: LD_ADDR_VAR 0 6
65343: PUSH
65344: LD_VAR 0 6
65348: PUSH
65349: LD_EXP 37
65353: PUSH
65354: LD_VAR 0 2
65358: ARRAY
65359: DIFF
65360: ST_TO_ADDR
// if not list then
65361: LD_VAR 0 6
65365: NOT
65366: IFFALSE 65370
// continue ;
65368: GO 64743
// k := mc_mines [ i ] - mc_miners [ i ] ;
65370: LD_ADDR_VAR 0 4
65374: PUSH
65375: LD_EXP 36
65379: PUSH
65380: LD_VAR 0 2
65384: ARRAY
65385: PUSH
65386: LD_EXP 37
65390: PUSH
65391: LD_VAR 0 2
65395: ARRAY
65396: MINUS
65397: ST_TO_ADDR
// if k > list then
65398: LD_VAR 0 4
65402: PUSH
65403: LD_VAR 0 6
65407: GREATER
65408: IFFALSE 65420
// k := list ;
65410: LD_ADDR_VAR 0 4
65414: PUSH
65415: LD_VAR 0 6
65419: ST_TO_ADDR
// for j = 1 to k do
65420: LD_ADDR_VAR 0 3
65424: PUSH
65425: DOUBLE
65426: LD_INT 1
65428: DEC
65429: ST_TO_ADDR
65430: LD_VAR 0 4
65434: PUSH
65435: FOR_TO
65436: IFFALSE 65490
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65438: LD_ADDR_EXP 37
65442: PUSH
65443: LD_EXP 37
65447: PPUSH
65448: LD_VAR 0 2
65452: PUSH
65453: LD_EXP 37
65457: PUSH
65458: LD_VAR 0 2
65462: ARRAY
65463: PUSH
65464: LD_INT 1
65466: PLUS
65467: PUSH
65468: EMPTY
65469: LIST
65470: LIST
65471: PPUSH
65472: LD_VAR 0 6
65476: PUSH
65477: LD_VAR 0 3
65481: ARRAY
65482: PPUSH
65483: CALL 16166 0 3
65487: ST_TO_ADDR
65488: GO 65435
65490: POP
65491: POP
// end ;
65492: GO 64743
65494: POP
65495: POP
// end ;
65496: LD_VAR 0 1
65500: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65501: LD_INT 0
65503: PPUSH
65504: PPUSH
65505: PPUSH
65506: PPUSH
65507: PPUSH
65508: PPUSH
65509: PPUSH
65510: PPUSH
65511: PPUSH
65512: PPUSH
65513: PPUSH
// if not mc_bases then
65514: LD_EXP 23
65518: NOT
65519: IFFALSE 65523
// exit ;
65521: GO 67346
// for i = 1 to mc_bases do
65523: LD_ADDR_VAR 0 2
65527: PUSH
65528: DOUBLE
65529: LD_INT 1
65531: DEC
65532: ST_TO_ADDR
65533: LD_EXP 23
65537: PUSH
65538: FOR_TO
65539: IFFALSE 67344
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65541: LD_EXP 23
65545: PUSH
65546: LD_VAR 0 2
65550: ARRAY
65551: NOT
65552: PUSH
65553: LD_EXP 30
65557: PUSH
65558: LD_VAR 0 2
65562: ARRAY
65563: OR
65564: IFFALSE 65568
// continue ;
65566: GO 65538
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65568: LD_EXP 39
65572: PUSH
65573: LD_VAR 0 2
65577: ARRAY
65578: NOT
65579: PUSH
65580: LD_EXP 40
65584: PUSH
65585: LD_VAR 0 2
65589: ARRAY
65590: AND
65591: IFFALSE 65629
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65593: LD_ADDR_EXP 40
65597: PUSH
65598: LD_EXP 40
65602: PPUSH
65603: LD_VAR 0 2
65607: PPUSH
65608: EMPTY
65609: PPUSH
65610: CALL_OW 1
65614: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65615: LD_VAR 0 2
65619: PPUSH
65620: LD_INT 107
65622: PPUSH
65623: CALL 56397 0 2
// continue ;
65627: GO 65538
// end ; target := [ ] ;
65629: LD_ADDR_VAR 0 7
65633: PUSH
65634: EMPTY
65635: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65636: LD_ADDR_VAR 0 6
65640: PUSH
65641: LD_EXP 23
65645: PUSH
65646: LD_VAR 0 2
65650: ARRAY
65651: PUSH
65652: LD_INT 1
65654: ARRAY
65655: PPUSH
65656: CALL_OW 255
65660: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65661: LD_ADDR_VAR 0 9
65665: PUSH
65666: LD_EXP 23
65670: PUSH
65671: LD_VAR 0 2
65675: ARRAY
65676: PPUSH
65677: LD_INT 2
65679: PUSH
65680: LD_INT 30
65682: PUSH
65683: LD_INT 0
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PUSH
65690: LD_INT 30
65692: PUSH
65693: LD_INT 1
65695: PUSH
65696: EMPTY
65697: LIST
65698: LIST
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: LIST
65704: PPUSH
65705: CALL_OW 72
65709: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65710: LD_ADDR_VAR 0 3
65714: PUSH
65715: DOUBLE
65716: LD_EXP 39
65720: PUSH
65721: LD_VAR 0 2
65725: ARRAY
65726: INC
65727: ST_TO_ADDR
65728: LD_INT 1
65730: PUSH
65731: FOR_DOWNTO
65732: IFFALSE 65977
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65734: LD_EXP 39
65738: PUSH
65739: LD_VAR 0 2
65743: ARRAY
65744: PUSH
65745: LD_VAR 0 3
65749: ARRAY
65750: PUSH
65751: LD_INT 2
65753: ARRAY
65754: PPUSH
65755: LD_EXP 39
65759: PUSH
65760: LD_VAR 0 2
65764: ARRAY
65765: PUSH
65766: LD_VAR 0 3
65770: ARRAY
65771: PUSH
65772: LD_INT 3
65774: ARRAY
65775: PPUSH
65776: CALL_OW 488
65780: PUSH
65781: LD_EXP 39
65785: PUSH
65786: LD_VAR 0 2
65790: ARRAY
65791: PUSH
65792: LD_VAR 0 3
65796: ARRAY
65797: PUSH
65798: LD_INT 2
65800: ARRAY
65801: PPUSH
65802: LD_EXP 39
65806: PUSH
65807: LD_VAR 0 2
65811: ARRAY
65812: PUSH
65813: LD_VAR 0 3
65817: ARRAY
65818: PUSH
65819: LD_INT 3
65821: ARRAY
65822: PPUSH
65823: CALL_OW 284
65827: PUSH
65828: LD_INT 0
65830: EQUAL
65831: AND
65832: IFFALSE 65887
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65834: LD_ADDR_VAR 0 5
65838: PUSH
65839: LD_EXP 39
65843: PUSH
65844: LD_VAR 0 2
65848: ARRAY
65849: PPUSH
65850: LD_VAR 0 3
65854: PPUSH
65855: CALL_OW 3
65859: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65860: LD_ADDR_EXP 39
65864: PUSH
65865: LD_EXP 39
65869: PPUSH
65870: LD_VAR 0 2
65874: PPUSH
65875: LD_VAR 0 5
65879: PPUSH
65880: CALL_OW 1
65884: ST_TO_ADDR
// continue ;
65885: GO 65731
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65887: LD_VAR 0 6
65891: PPUSH
65892: LD_EXP 39
65896: PUSH
65897: LD_VAR 0 2
65901: ARRAY
65902: PUSH
65903: LD_VAR 0 3
65907: ARRAY
65908: PUSH
65909: LD_INT 2
65911: ARRAY
65912: PPUSH
65913: LD_EXP 39
65917: PUSH
65918: LD_VAR 0 2
65922: ARRAY
65923: PUSH
65924: LD_VAR 0 3
65928: ARRAY
65929: PUSH
65930: LD_INT 3
65932: ARRAY
65933: PPUSH
65934: LD_INT 30
65936: PPUSH
65937: CALL 17062 0 4
65941: PUSH
65942: LD_INT 4
65944: ARRAY
65945: PUSH
65946: LD_INT 0
65948: EQUAL
65949: IFFALSE 65975
// begin target := mc_crates [ i ] [ j ] ;
65951: LD_ADDR_VAR 0 7
65955: PUSH
65956: LD_EXP 39
65960: PUSH
65961: LD_VAR 0 2
65965: ARRAY
65966: PUSH
65967: LD_VAR 0 3
65971: ARRAY
65972: ST_TO_ADDR
// break ;
65973: GO 65977
// end ; end ;
65975: GO 65731
65977: POP
65978: POP
// if not target then
65979: LD_VAR 0 7
65983: NOT
65984: IFFALSE 65988
// continue ;
65986: GO 65538
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65988: LD_ADDR_VAR 0 8
65992: PUSH
65993: LD_EXP 42
65997: PUSH
65998: LD_VAR 0 2
66002: ARRAY
66003: PPUSH
66004: LD_INT 2
66006: PUSH
66007: LD_INT 3
66009: PUSH
66010: LD_INT 58
66012: PUSH
66013: EMPTY
66014: LIST
66015: PUSH
66016: EMPTY
66017: LIST
66018: LIST
66019: PUSH
66020: LD_INT 61
66022: PUSH
66023: EMPTY
66024: LIST
66025: PUSH
66026: LD_INT 33
66028: PUSH
66029: LD_INT 5
66031: PUSH
66032: EMPTY
66033: LIST
66034: LIST
66035: PUSH
66036: LD_INT 33
66038: PUSH
66039: LD_INT 3
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: PUSH
66046: EMPTY
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: PUSH
66053: LD_INT 2
66055: PUSH
66056: LD_INT 34
66058: PUSH
66059: LD_INT 32
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PUSH
66066: LD_INT 34
66068: PUSH
66069: LD_INT 51
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: PUSH
66076: LD_INT 34
66078: PUSH
66079: LD_INT 12
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: EMPTY
66087: LIST
66088: LIST
66089: LIST
66090: LIST
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PPUSH
66096: CALL_OW 72
66100: ST_TO_ADDR
// if not cargo then
66101: LD_VAR 0 8
66105: NOT
66106: IFFALSE 66812
// begin if mc_crates_collector [ i ] < 5 then
66108: LD_EXP 40
66112: PUSH
66113: LD_VAR 0 2
66117: ARRAY
66118: PUSH
66119: LD_INT 5
66121: LESS
66122: IFFALSE 66488
// begin if mc_ape [ i ] then
66124: LD_EXP 52
66128: PUSH
66129: LD_VAR 0 2
66133: ARRAY
66134: IFFALSE 66181
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66136: LD_ADDR_VAR 0 5
66140: PUSH
66141: LD_EXP 52
66145: PUSH
66146: LD_VAR 0 2
66150: ARRAY
66151: PPUSH
66152: LD_INT 25
66154: PUSH
66155: LD_INT 16
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PUSH
66162: LD_INT 24
66164: PUSH
66165: LD_INT 750
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: EMPTY
66173: LIST
66174: LIST
66175: PPUSH
66176: CALL_OW 72
66180: ST_TO_ADDR
// if not tmp then
66181: LD_VAR 0 5
66185: NOT
66186: IFFALSE 66233
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66188: LD_ADDR_VAR 0 5
66192: PUSH
66193: LD_EXP 23
66197: PUSH
66198: LD_VAR 0 2
66202: ARRAY
66203: PPUSH
66204: LD_INT 25
66206: PUSH
66207: LD_INT 2
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: LD_INT 24
66216: PUSH
66217: LD_INT 750
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PPUSH
66228: CALL_OW 72
66232: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66233: LD_EXP 52
66237: PUSH
66238: LD_VAR 0 2
66242: ARRAY
66243: PUSH
66244: LD_EXP 23
66248: PUSH
66249: LD_VAR 0 2
66253: ARRAY
66254: PPUSH
66255: LD_INT 25
66257: PUSH
66258: LD_INT 2
66260: PUSH
66261: EMPTY
66262: LIST
66263: LIST
66264: PUSH
66265: LD_INT 24
66267: PUSH
66268: LD_INT 750
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: EMPTY
66276: LIST
66277: LIST
66278: PPUSH
66279: CALL_OW 72
66283: AND
66284: PUSH
66285: LD_VAR 0 5
66289: PUSH
66290: LD_INT 5
66292: LESS
66293: AND
66294: IFFALSE 66376
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66296: LD_ADDR_VAR 0 3
66300: PUSH
66301: LD_EXP 23
66305: PUSH
66306: LD_VAR 0 2
66310: ARRAY
66311: PPUSH
66312: LD_INT 25
66314: PUSH
66315: LD_INT 2
66317: PUSH
66318: EMPTY
66319: LIST
66320: LIST
66321: PUSH
66322: LD_INT 24
66324: PUSH
66325: LD_INT 750
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PPUSH
66336: CALL_OW 72
66340: PUSH
66341: FOR_IN
66342: IFFALSE 66374
// begin tmp := tmp union j ;
66344: LD_ADDR_VAR 0 5
66348: PUSH
66349: LD_VAR 0 5
66353: PUSH
66354: LD_VAR 0 3
66358: UNION
66359: ST_TO_ADDR
// if tmp >= 5 then
66360: LD_VAR 0 5
66364: PUSH
66365: LD_INT 5
66367: GREATEREQUAL
66368: IFFALSE 66372
// break ;
66370: GO 66374
// end ;
66372: GO 66341
66374: POP
66375: POP
// end ; if not tmp then
66376: LD_VAR 0 5
66380: NOT
66381: IFFALSE 66385
// continue ;
66383: GO 65538
// for j in tmp do
66385: LD_ADDR_VAR 0 3
66389: PUSH
66390: LD_VAR 0 5
66394: PUSH
66395: FOR_IN
66396: IFFALSE 66486
// if not GetTag ( j ) then
66398: LD_VAR 0 3
66402: PPUSH
66403: CALL_OW 110
66407: NOT
66408: IFFALSE 66484
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66410: LD_ADDR_EXP 40
66414: PUSH
66415: LD_EXP 40
66419: PPUSH
66420: LD_VAR 0 2
66424: PUSH
66425: LD_EXP 40
66429: PUSH
66430: LD_VAR 0 2
66434: ARRAY
66435: PUSH
66436: LD_INT 1
66438: PLUS
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PPUSH
66444: LD_VAR 0 3
66448: PPUSH
66449: CALL 16166 0 3
66453: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66454: LD_VAR 0 3
66458: PPUSH
66459: LD_INT 107
66461: PPUSH
66462: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66466: LD_EXP 40
66470: PUSH
66471: LD_VAR 0 2
66475: ARRAY
66476: PUSH
66477: LD_INT 5
66479: GREATEREQUAL
66480: IFFALSE 66484
// break ;
66482: GO 66486
// end ;
66484: GO 66395
66486: POP
66487: POP
// end ; if mc_crates_collector [ i ] and target then
66488: LD_EXP 40
66492: PUSH
66493: LD_VAR 0 2
66497: ARRAY
66498: PUSH
66499: LD_VAR 0 7
66503: AND
66504: IFFALSE 66810
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66506: LD_EXP 40
66510: PUSH
66511: LD_VAR 0 2
66515: ARRAY
66516: PUSH
66517: LD_VAR 0 7
66521: PUSH
66522: LD_INT 1
66524: ARRAY
66525: LESS
66526: IFFALSE 66546
// tmp := mc_crates_collector [ i ] else
66528: LD_ADDR_VAR 0 5
66532: PUSH
66533: LD_EXP 40
66537: PUSH
66538: LD_VAR 0 2
66542: ARRAY
66543: ST_TO_ADDR
66544: GO 66560
// tmp := target [ 1 ] ;
66546: LD_ADDR_VAR 0 5
66550: PUSH
66551: LD_VAR 0 7
66555: PUSH
66556: LD_INT 1
66558: ARRAY
66559: ST_TO_ADDR
// k := 0 ;
66560: LD_ADDR_VAR 0 4
66564: PUSH
66565: LD_INT 0
66567: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66568: LD_ADDR_VAR 0 3
66572: PUSH
66573: LD_EXP 40
66577: PUSH
66578: LD_VAR 0 2
66582: ARRAY
66583: PUSH
66584: FOR_IN
66585: IFFALSE 66808
// begin k := k + 1 ;
66587: LD_ADDR_VAR 0 4
66591: PUSH
66592: LD_VAR 0 4
66596: PUSH
66597: LD_INT 1
66599: PLUS
66600: ST_TO_ADDR
// if k > tmp then
66601: LD_VAR 0 4
66605: PUSH
66606: LD_VAR 0 5
66610: GREATER
66611: IFFALSE 66615
// break ;
66613: GO 66808
// if not GetClass ( j ) in [ 2 , 16 ] then
66615: LD_VAR 0 3
66619: PPUSH
66620: CALL_OW 257
66624: PUSH
66625: LD_INT 2
66627: PUSH
66628: LD_INT 16
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: IN
66635: NOT
66636: IFFALSE 66689
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66638: LD_ADDR_EXP 40
66642: PUSH
66643: LD_EXP 40
66647: PPUSH
66648: LD_VAR 0 2
66652: PPUSH
66653: LD_EXP 40
66657: PUSH
66658: LD_VAR 0 2
66662: ARRAY
66663: PUSH
66664: LD_VAR 0 3
66668: DIFF
66669: PPUSH
66670: CALL_OW 1
66674: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66675: LD_VAR 0 3
66679: PPUSH
66680: LD_INT 0
66682: PPUSH
66683: CALL_OW 109
// continue ;
66687: GO 66584
// end ; if IsInUnit ( j ) then
66689: LD_VAR 0 3
66693: PPUSH
66694: CALL_OW 310
66698: IFFALSE 66709
// ComExitBuilding ( j ) ;
66700: LD_VAR 0 3
66704: PPUSH
66705: CALL_OW 122
// wait ( 3 ) ;
66709: LD_INT 3
66711: PPUSH
66712: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
66716: LD_VAR 0 3
66720: PPUSH
66721: CALL_OW 314
66725: PUSH
66726: LD_VAR 0 6
66730: PPUSH
66731: LD_VAR 0 7
66735: PUSH
66736: LD_INT 2
66738: ARRAY
66739: PPUSH
66740: LD_VAR 0 7
66744: PUSH
66745: LD_INT 3
66747: ARRAY
66748: PPUSH
66749: LD_INT 30
66751: PPUSH
66752: CALL 17062 0 4
66756: PUSH
66757: LD_INT 4
66759: ARRAY
66760: AND
66761: IFFALSE 66779
// ComStandNearbyBuilding ( j , depot ) else
66763: LD_VAR 0 3
66767: PPUSH
66768: LD_VAR 0 9
66772: PPUSH
66773: CALL 12591 0 2
66777: GO 66806
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66779: LD_VAR 0 3
66783: PPUSH
66784: LD_VAR 0 7
66788: PUSH
66789: LD_INT 2
66791: ARRAY
66792: PPUSH
66793: LD_VAR 0 7
66797: PUSH
66798: LD_INT 3
66800: ARRAY
66801: PPUSH
66802: CALL_OW 117
// end ;
66806: GO 66584
66808: POP
66809: POP
// end ; end else
66810: GO 67342
// begin for j in cargo do
66812: LD_ADDR_VAR 0 3
66816: PUSH
66817: LD_VAR 0 8
66821: PUSH
66822: FOR_IN
66823: IFFALSE 67340
// begin if GetTag ( j ) <> 0 then
66825: LD_VAR 0 3
66829: PPUSH
66830: CALL_OW 110
66834: PUSH
66835: LD_INT 0
66837: NONEQUAL
66838: IFFALSE 66842
// continue ;
66840: GO 66822
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66842: LD_VAR 0 3
66846: PPUSH
66847: CALL_OW 256
66851: PUSH
66852: LD_INT 1000
66854: LESS
66855: PUSH
66856: LD_VAR 0 3
66860: PPUSH
66861: LD_EXP 47
66865: PUSH
66866: LD_VAR 0 2
66870: ARRAY
66871: PPUSH
66872: CALL_OW 308
66876: NOT
66877: AND
66878: IFFALSE 66900
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66880: LD_VAR 0 3
66884: PPUSH
66885: LD_EXP 47
66889: PUSH
66890: LD_VAR 0 2
66894: ARRAY
66895: PPUSH
66896: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66900: LD_VAR 0 3
66904: PPUSH
66905: CALL_OW 256
66909: PUSH
66910: LD_INT 1000
66912: LESS
66913: PUSH
66914: LD_VAR 0 3
66918: PPUSH
66919: LD_EXP 47
66923: PUSH
66924: LD_VAR 0 2
66928: ARRAY
66929: PPUSH
66930: CALL_OW 308
66934: AND
66935: IFFALSE 66939
// continue ;
66937: GO 66822
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66939: LD_VAR 0 3
66943: PPUSH
66944: CALL_OW 262
66948: PUSH
66949: LD_INT 2
66951: EQUAL
66952: PUSH
66953: LD_VAR 0 3
66957: PPUSH
66958: CALL_OW 261
66962: PUSH
66963: LD_INT 15
66965: LESS
66966: AND
66967: IFFALSE 66971
// continue ;
66969: GO 66822
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66971: LD_VAR 0 3
66975: PPUSH
66976: CALL_OW 262
66980: PUSH
66981: LD_INT 1
66983: EQUAL
66984: PUSH
66985: LD_VAR 0 3
66989: PPUSH
66990: CALL_OW 261
66994: PUSH
66995: LD_INT 10
66997: LESS
66998: AND
66999: IFFALSE 67279
// begin if not depot then
67001: LD_VAR 0 9
67005: NOT
67006: IFFALSE 67010
// continue ;
67008: GO 66822
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67010: LD_VAR 0 3
67014: PPUSH
67015: LD_VAR 0 9
67019: PPUSH
67020: LD_VAR 0 3
67024: PPUSH
67025: CALL_OW 74
67029: PPUSH
67030: CALL_OW 296
67034: PUSH
67035: LD_INT 6
67037: LESS
67038: IFFALSE 67054
// SetFuel ( j , 100 ) else
67040: LD_VAR 0 3
67044: PPUSH
67045: LD_INT 100
67047: PPUSH
67048: CALL_OW 240
67052: GO 67279
// if GetFuel ( j ) = 0 then
67054: LD_VAR 0 3
67058: PPUSH
67059: CALL_OW 261
67063: PUSH
67064: LD_INT 0
67066: EQUAL
67067: IFFALSE 67279
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67069: LD_ADDR_EXP 42
67073: PUSH
67074: LD_EXP 42
67078: PPUSH
67079: LD_VAR 0 2
67083: PPUSH
67084: LD_EXP 42
67088: PUSH
67089: LD_VAR 0 2
67093: ARRAY
67094: PUSH
67095: LD_VAR 0 3
67099: DIFF
67100: PPUSH
67101: CALL_OW 1
67105: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67106: LD_VAR 0 3
67110: PPUSH
67111: CALL_OW 263
67115: PUSH
67116: LD_INT 1
67118: EQUAL
67119: IFFALSE 67135
// ComExitVehicle ( IsInUnit ( j ) ) ;
67121: LD_VAR 0 3
67125: PPUSH
67126: CALL_OW 310
67130: PPUSH
67131: CALL_OW 121
// if GetControl ( j ) = control_remote then
67135: LD_VAR 0 3
67139: PPUSH
67140: CALL_OW 263
67144: PUSH
67145: LD_INT 2
67147: EQUAL
67148: IFFALSE 67159
// ComUnlink ( j ) ;
67150: LD_VAR 0 3
67154: PPUSH
67155: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67159: LD_ADDR_VAR 0 10
67163: PUSH
67164: LD_VAR 0 2
67168: PPUSH
67169: LD_INT 3
67171: PPUSH
67172: CALL 76918 0 2
67176: ST_TO_ADDR
// if fac then
67177: LD_VAR 0 10
67181: IFFALSE 67277
// begin for k in fac do
67183: LD_ADDR_VAR 0 4
67187: PUSH
67188: LD_VAR 0 10
67192: PUSH
67193: FOR_IN
67194: IFFALSE 67275
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67196: LD_ADDR_VAR 0 11
67200: PUSH
67201: LD_VAR 0 10
67205: PPUSH
67206: LD_VAR 0 3
67210: PPUSH
67211: CALL_OW 265
67215: PPUSH
67216: LD_VAR 0 3
67220: PPUSH
67221: CALL_OW 262
67225: PPUSH
67226: LD_VAR 0 3
67230: PPUSH
67231: CALL_OW 263
67235: PPUSH
67236: LD_VAR 0 3
67240: PPUSH
67241: CALL_OW 264
67245: PPUSH
67246: CALL 13662 0 5
67250: ST_TO_ADDR
// if components then
67251: LD_VAR 0 11
67255: IFFALSE 67273
// begin MC_InsertProduceList ( i , components ) ;
67257: LD_VAR 0 2
67261: PPUSH
67262: LD_VAR 0 11
67266: PPUSH
67267: CALL 76463 0 2
// break ;
67271: GO 67275
// end ; end ;
67273: GO 67193
67275: POP
67276: POP
// end ; continue ;
67277: GO 66822
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67279: LD_VAR 0 3
67283: PPUSH
67284: LD_INT 1
67286: PPUSH
67287: CALL_OW 289
67291: PUSH
67292: LD_INT 100
67294: LESS
67295: PUSH
67296: LD_VAR 0 3
67300: PPUSH
67301: CALL_OW 314
67305: NOT
67306: AND
67307: IFFALSE 67336
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67309: LD_VAR 0 3
67313: PPUSH
67314: LD_VAR 0 7
67318: PUSH
67319: LD_INT 2
67321: ARRAY
67322: PPUSH
67323: LD_VAR 0 7
67327: PUSH
67328: LD_INT 3
67330: ARRAY
67331: PPUSH
67332: CALL_OW 117
// break ;
67336: GO 67340
// end ;
67338: GO 66822
67340: POP
67341: POP
// end ; end ;
67342: GO 65538
67344: POP
67345: POP
// end ;
67346: LD_VAR 0 1
67350: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67351: LD_INT 0
67353: PPUSH
67354: PPUSH
67355: PPUSH
67356: PPUSH
// if not mc_bases then
67357: LD_EXP 23
67361: NOT
67362: IFFALSE 67366
// exit ;
67364: GO 67527
// for i = 1 to mc_bases do
67366: LD_ADDR_VAR 0 2
67370: PUSH
67371: DOUBLE
67372: LD_INT 1
67374: DEC
67375: ST_TO_ADDR
67376: LD_EXP 23
67380: PUSH
67381: FOR_TO
67382: IFFALSE 67525
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67384: LD_ADDR_VAR 0 4
67388: PUSH
67389: LD_EXP 42
67393: PUSH
67394: LD_VAR 0 2
67398: ARRAY
67399: PUSH
67400: LD_EXP 45
67404: PUSH
67405: LD_VAR 0 2
67409: ARRAY
67410: UNION
67411: PPUSH
67412: LD_INT 33
67414: PUSH
67415: LD_INT 2
67417: PUSH
67418: EMPTY
67419: LIST
67420: LIST
67421: PPUSH
67422: CALL_OW 72
67426: ST_TO_ADDR
// if tmp then
67427: LD_VAR 0 4
67431: IFFALSE 67523
// for j in tmp do
67433: LD_ADDR_VAR 0 3
67437: PUSH
67438: LD_VAR 0 4
67442: PUSH
67443: FOR_IN
67444: IFFALSE 67521
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67446: LD_VAR 0 3
67450: PPUSH
67451: CALL_OW 312
67455: NOT
67456: PUSH
67457: LD_VAR 0 3
67461: PPUSH
67462: CALL_OW 256
67466: PUSH
67467: LD_INT 250
67469: GREATEREQUAL
67470: AND
67471: IFFALSE 67484
// Connect ( j ) else
67473: LD_VAR 0 3
67477: PPUSH
67478: CALL 19137 0 1
67482: GO 67519
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67484: LD_VAR 0 3
67488: PPUSH
67489: CALL_OW 256
67493: PUSH
67494: LD_INT 250
67496: LESS
67497: PUSH
67498: LD_VAR 0 3
67502: PPUSH
67503: CALL_OW 312
67507: AND
67508: IFFALSE 67519
// ComUnlink ( j ) ;
67510: LD_VAR 0 3
67514: PPUSH
67515: CALL_OW 136
67519: GO 67443
67521: POP
67522: POP
// end ;
67523: GO 67381
67525: POP
67526: POP
// end ;
67527: LD_VAR 0 1
67531: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67532: LD_INT 0
67534: PPUSH
67535: PPUSH
67536: PPUSH
67537: PPUSH
67538: PPUSH
// if not mc_bases then
67539: LD_EXP 23
67543: NOT
67544: IFFALSE 67548
// exit ;
67546: GO 67993
// for i = 1 to mc_bases do
67548: LD_ADDR_VAR 0 2
67552: PUSH
67553: DOUBLE
67554: LD_INT 1
67556: DEC
67557: ST_TO_ADDR
67558: LD_EXP 23
67562: PUSH
67563: FOR_TO
67564: IFFALSE 67991
// begin if not mc_produce [ i ] then
67566: LD_EXP 44
67570: PUSH
67571: LD_VAR 0 2
67575: ARRAY
67576: NOT
67577: IFFALSE 67581
// continue ;
67579: GO 67563
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67581: LD_ADDR_VAR 0 5
67585: PUSH
67586: LD_EXP 23
67590: PUSH
67591: LD_VAR 0 2
67595: ARRAY
67596: PPUSH
67597: LD_INT 30
67599: PUSH
67600: LD_INT 3
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PPUSH
67607: CALL_OW 72
67611: ST_TO_ADDR
// if not fac then
67612: LD_VAR 0 5
67616: NOT
67617: IFFALSE 67621
// continue ;
67619: GO 67563
// for j in fac do
67621: LD_ADDR_VAR 0 3
67625: PUSH
67626: LD_VAR 0 5
67630: PUSH
67631: FOR_IN
67632: IFFALSE 67987
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67634: LD_VAR 0 3
67638: PPUSH
67639: CALL_OW 461
67643: PUSH
67644: LD_INT 2
67646: NONEQUAL
67647: PUSH
67648: LD_VAR 0 3
67652: PPUSH
67653: LD_INT 15
67655: PPUSH
67656: CALL 18765 0 2
67660: PUSH
67661: LD_INT 4
67663: ARRAY
67664: OR
67665: IFFALSE 67669
// continue ;
67667: GO 67631
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67669: LD_VAR 0 3
67673: PPUSH
67674: LD_EXP 44
67678: PUSH
67679: LD_VAR 0 2
67683: ARRAY
67684: PUSH
67685: LD_INT 1
67687: ARRAY
67688: PUSH
67689: LD_INT 1
67691: ARRAY
67692: PPUSH
67693: LD_EXP 44
67697: PUSH
67698: LD_VAR 0 2
67702: ARRAY
67703: PUSH
67704: LD_INT 1
67706: ARRAY
67707: PUSH
67708: LD_INT 2
67710: ARRAY
67711: PPUSH
67712: LD_EXP 44
67716: PUSH
67717: LD_VAR 0 2
67721: ARRAY
67722: PUSH
67723: LD_INT 1
67725: ARRAY
67726: PUSH
67727: LD_INT 3
67729: ARRAY
67730: PPUSH
67731: LD_EXP 44
67735: PUSH
67736: LD_VAR 0 2
67740: ARRAY
67741: PUSH
67742: LD_INT 1
67744: ARRAY
67745: PUSH
67746: LD_INT 4
67748: ARRAY
67749: PPUSH
67750: CALL_OW 448
67754: PUSH
67755: LD_VAR 0 3
67759: PPUSH
67760: LD_EXP 44
67764: PUSH
67765: LD_VAR 0 2
67769: ARRAY
67770: PUSH
67771: LD_INT 1
67773: ARRAY
67774: PUSH
67775: LD_INT 1
67777: ARRAY
67778: PUSH
67779: LD_EXP 44
67783: PUSH
67784: LD_VAR 0 2
67788: ARRAY
67789: PUSH
67790: LD_INT 1
67792: ARRAY
67793: PUSH
67794: LD_INT 2
67796: ARRAY
67797: PUSH
67798: LD_EXP 44
67802: PUSH
67803: LD_VAR 0 2
67807: ARRAY
67808: PUSH
67809: LD_INT 1
67811: ARRAY
67812: PUSH
67813: LD_INT 3
67815: ARRAY
67816: PUSH
67817: LD_EXP 44
67821: PUSH
67822: LD_VAR 0 2
67826: ARRAY
67827: PUSH
67828: LD_INT 1
67830: ARRAY
67831: PUSH
67832: LD_INT 4
67834: ARRAY
67835: PUSH
67836: EMPTY
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: PPUSH
67842: CALL 22532 0 2
67846: AND
67847: IFFALSE 67985
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67849: LD_VAR 0 3
67853: PPUSH
67854: LD_EXP 44
67858: PUSH
67859: LD_VAR 0 2
67863: ARRAY
67864: PUSH
67865: LD_INT 1
67867: ARRAY
67868: PUSH
67869: LD_INT 1
67871: ARRAY
67872: PPUSH
67873: LD_EXP 44
67877: PUSH
67878: LD_VAR 0 2
67882: ARRAY
67883: PUSH
67884: LD_INT 1
67886: ARRAY
67887: PUSH
67888: LD_INT 2
67890: ARRAY
67891: PPUSH
67892: LD_EXP 44
67896: PUSH
67897: LD_VAR 0 2
67901: ARRAY
67902: PUSH
67903: LD_INT 1
67905: ARRAY
67906: PUSH
67907: LD_INT 3
67909: ARRAY
67910: PPUSH
67911: LD_EXP 44
67915: PUSH
67916: LD_VAR 0 2
67920: ARRAY
67921: PUSH
67922: LD_INT 1
67924: ARRAY
67925: PUSH
67926: LD_INT 4
67928: ARRAY
67929: PPUSH
67930: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67934: LD_ADDR_VAR 0 4
67938: PUSH
67939: LD_EXP 44
67943: PUSH
67944: LD_VAR 0 2
67948: ARRAY
67949: PPUSH
67950: LD_INT 1
67952: PPUSH
67953: CALL_OW 3
67957: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67958: LD_ADDR_EXP 44
67962: PUSH
67963: LD_EXP 44
67967: PPUSH
67968: LD_VAR 0 2
67972: PPUSH
67973: LD_VAR 0 4
67977: PPUSH
67978: CALL_OW 1
67982: ST_TO_ADDR
// break ;
67983: GO 67987
// end ; end ;
67985: GO 67631
67987: POP
67988: POP
// end ;
67989: GO 67563
67991: POP
67992: POP
// end ;
67993: LD_VAR 0 1
67997: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67998: LD_INT 0
68000: PPUSH
68001: PPUSH
68002: PPUSH
// if not mc_bases then
68003: LD_EXP 23
68007: NOT
68008: IFFALSE 68012
// exit ;
68010: GO 68101
// for i = 1 to mc_bases do
68012: LD_ADDR_VAR 0 2
68016: PUSH
68017: DOUBLE
68018: LD_INT 1
68020: DEC
68021: ST_TO_ADDR
68022: LD_EXP 23
68026: PUSH
68027: FOR_TO
68028: IFFALSE 68099
// begin if mc_attack [ i ] then
68030: LD_EXP 43
68034: PUSH
68035: LD_VAR 0 2
68039: ARRAY
68040: IFFALSE 68097
// begin tmp := mc_attack [ i ] [ 1 ] ;
68042: LD_ADDR_VAR 0 3
68046: PUSH
68047: LD_EXP 43
68051: PUSH
68052: LD_VAR 0 2
68056: ARRAY
68057: PUSH
68058: LD_INT 1
68060: ARRAY
68061: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68062: LD_ADDR_EXP 43
68066: PUSH
68067: LD_EXP 43
68071: PPUSH
68072: LD_VAR 0 2
68076: PPUSH
68077: EMPTY
68078: PPUSH
68079: CALL_OW 1
68083: ST_TO_ADDR
// Attack ( tmp ) ;
68084: LD_VAR 0 3
68088: PPUSH
68089: CALL 83029 0 1
// exit ;
68093: POP
68094: POP
68095: GO 68101
// end ; end ;
68097: GO 68027
68099: POP
68100: POP
// end ;
68101: LD_VAR 0 1
68105: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68106: LD_INT 0
68108: PPUSH
68109: PPUSH
68110: PPUSH
68111: PPUSH
68112: PPUSH
68113: PPUSH
68114: PPUSH
// if not mc_bases then
68115: LD_EXP 23
68119: NOT
68120: IFFALSE 68124
// exit ;
68122: GO 68981
// for i = 1 to mc_bases do
68124: LD_ADDR_VAR 0 2
68128: PUSH
68129: DOUBLE
68130: LD_INT 1
68132: DEC
68133: ST_TO_ADDR
68134: LD_EXP 23
68138: PUSH
68139: FOR_TO
68140: IFFALSE 68979
// begin if not mc_bases [ i ] then
68142: LD_EXP 23
68146: PUSH
68147: LD_VAR 0 2
68151: ARRAY
68152: NOT
68153: IFFALSE 68157
// continue ;
68155: GO 68139
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68157: LD_ADDR_VAR 0 7
68161: PUSH
68162: LD_EXP 23
68166: PUSH
68167: LD_VAR 0 2
68171: ARRAY
68172: PUSH
68173: LD_INT 1
68175: ARRAY
68176: PPUSH
68177: CALL 12813 0 1
68181: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68182: LD_ADDR_EXP 46
68186: PUSH
68187: LD_EXP 46
68191: PPUSH
68192: LD_VAR 0 2
68196: PPUSH
68197: LD_EXP 23
68201: PUSH
68202: LD_VAR 0 2
68206: ARRAY
68207: PUSH
68208: LD_INT 1
68210: ARRAY
68211: PPUSH
68212: CALL_OW 255
68216: PPUSH
68217: LD_EXP 48
68221: PUSH
68222: LD_VAR 0 2
68226: ARRAY
68227: PPUSH
68228: CALL 12778 0 2
68232: PPUSH
68233: CALL_OW 1
68237: ST_TO_ADDR
// if not mc_scan [ i ] then
68238: LD_EXP 46
68242: PUSH
68243: LD_VAR 0 2
68247: ARRAY
68248: NOT
68249: IFFALSE 68427
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68251: LD_ADDR_EXP 66
68255: PUSH
68256: LD_EXP 66
68260: PPUSH
68261: LD_VAR 0 2
68265: PPUSH
68266: LD_INT 0
68268: PPUSH
68269: CALL_OW 1
68273: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68274: LD_ADDR_VAR 0 4
68278: PUSH
68279: LD_EXP 23
68283: PUSH
68284: LD_VAR 0 2
68288: ARRAY
68289: PPUSH
68290: LD_INT 2
68292: PUSH
68293: LD_INT 25
68295: PUSH
68296: LD_INT 5
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: LD_INT 25
68305: PUSH
68306: LD_INT 8
68308: PUSH
68309: EMPTY
68310: LIST
68311: LIST
68312: PUSH
68313: LD_INT 25
68315: PUSH
68316: LD_INT 9
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: PPUSH
68329: CALL_OW 72
68333: ST_TO_ADDR
// if not tmp then
68334: LD_VAR 0 4
68338: NOT
68339: IFFALSE 68343
// continue ;
68341: GO 68139
// for j in tmp do
68343: LD_ADDR_VAR 0 3
68347: PUSH
68348: LD_VAR 0 4
68352: PUSH
68353: FOR_IN
68354: IFFALSE 68425
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68356: LD_VAR 0 3
68360: PPUSH
68361: CALL_OW 310
68365: PPUSH
68366: CALL_OW 266
68370: PUSH
68371: LD_INT 5
68373: EQUAL
68374: PUSH
68375: LD_VAR 0 3
68379: PPUSH
68380: CALL_OW 257
68384: PUSH
68385: LD_INT 1
68387: EQUAL
68388: AND
68389: PUSH
68390: LD_VAR 0 3
68394: PPUSH
68395: CALL_OW 459
68399: NOT
68400: AND
68401: PUSH
68402: LD_VAR 0 7
68406: AND
68407: IFFALSE 68423
// ComChangeProfession ( j , class ) ;
68409: LD_VAR 0 3
68413: PPUSH
68414: LD_VAR 0 7
68418: PPUSH
68419: CALL_OW 123
68423: GO 68353
68425: POP
68426: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
68427: LD_EXP 46
68431: PUSH
68432: LD_VAR 0 2
68436: ARRAY
68437: PUSH
68438: LD_EXP 66
68442: PUSH
68443: LD_VAR 0 2
68447: ARRAY
68448: NOT
68449: AND
68450: PUSH
68451: LD_EXP 45
68455: PUSH
68456: LD_VAR 0 2
68460: ARRAY
68461: NOT
68462: AND
68463: PUSH
68464: LD_EXP 23
68468: PUSH
68469: LD_VAR 0 2
68473: ARRAY
68474: PPUSH
68475: LD_INT 50
68477: PUSH
68478: EMPTY
68479: LIST
68480: PUSH
68481: LD_INT 2
68483: PUSH
68484: LD_INT 30
68486: PUSH
68487: LD_INT 32
68489: PUSH
68490: EMPTY
68491: LIST
68492: LIST
68493: PUSH
68494: LD_INT 30
68496: PUSH
68497: LD_INT 33
68499: PUSH
68500: EMPTY
68501: LIST
68502: LIST
68503: PUSH
68504: LD_INT 30
68506: PUSH
68507: LD_INT 4
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 30
68516: PUSH
68517: LD_INT 5
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: PUSH
68524: EMPTY
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: PPUSH
68535: CALL_OW 72
68539: PUSH
68540: LD_INT 4
68542: LESS
68543: PUSH
68544: LD_EXP 23
68548: PUSH
68549: LD_VAR 0 2
68553: ARRAY
68554: PPUSH
68555: LD_INT 3
68557: PUSH
68558: LD_INT 24
68560: PUSH
68561: LD_INT 1000
68563: PUSH
68564: EMPTY
68565: LIST
68566: LIST
68567: PUSH
68568: EMPTY
68569: LIST
68570: LIST
68571: PUSH
68572: LD_INT 2
68574: PUSH
68575: LD_INT 30
68577: PUSH
68578: LD_INT 0
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: PUSH
68585: LD_INT 30
68587: PUSH
68588: LD_INT 1
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: EMPTY
68596: LIST
68597: LIST
68598: LIST
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PPUSH
68604: CALL_OW 72
68608: OR
68609: AND
68610: IFFALSE 68861
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68612: LD_ADDR_EXP 66
68616: PUSH
68617: LD_EXP 66
68621: PPUSH
68622: LD_VAR 0 2
68626: PPUSH
68627: LD_INT 1
68629: PPUSH
68630: CALL_OW 1
68634: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68635: LD_ADDR_VAR 0 4
68639: PUSH
68640: LD_EXP 23
68644: PUSH
68645: LD_VAR 0 2
68649: ARRAY
68650: PPUSH
68651: LD_INT 2
68653: PUSH
68654: LD_INT 25
68656: PUSH
68657: LD_INT 1
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 25
68666: PUSH
68667: LD_INT 5
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: PUSH
68674: LD_INT 25
68676: PUSH
68677: LD_INT 8
68679: PUSH
68680: EMPTY
68681: LIST
68682: LIST
68683: PUSH
68684: LD_INT 25
68686: PUSH
68687: LD_INT 9
68689: PUSH
68690: EMPTY
68691: LIST
68692: LIST
68693: PUSH
68694: EMPTY
68695: LIST
68696: LIST
68697: LIST
68698: LIST
68699: LIST
68700: PPUSH
68701: CALL_OW 72
68705: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68706: LD_ADDR_VAR 0 4
68710: PUSH
68711: LD_VAR 0 4
68715: PUSH
68716: LD_VAR 0 4
68720: PPUSH
68721: LD_INT 18
68723: PPUSH
68724: CALL 46002 0 2
68728: DIFF
68729: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68730: LD_VAR 0 4
68734: NOT
68735: PUSH
68736: LD_EXP 23
68740: PUSH
68741: LD_VAR 0 2
68745: ARRAY
68746: PPUSH
68747: LD_INT 2
68749: PUSH
68750: LD_INT 30
68752: PUSH
68753: LD_INT 4
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 30
68762: PUSH
68763: LD_INT 5
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: LIST
68774: PPUSH
68775: CALL_OW 72
68779: NOT
68780: AND
68781: IFFALSE 68843
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
68783: LD_ADDR_VAR 0 4
68787: PUSH
68788: LD_EXP 23
68792: PUSH
68793: LD_VAR 0 2
68797: ARRAY
68798: PPUSH
68799: LD_INT 2
68801: PUSH
68802: LD_INT 25
68804: PUSH
68805: LD_INT 2
68807: PUSH
68808: EMPTY
68809: LIST
68810: LIST
68811: PUSH
68812: LD_INT 25
68814: PUSH
68815: LD_INT 3
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: LD_INT 25
68824: PUSH
68825: LD_INT 4
68827: PUSH
68828: EMPTY
68829: LIST
68830: LIST
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: LIST
68836: LIST
68837: PPUSH
68838: CALL_OW 72
68842: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
68843: LD_VAR 0 2
68847: PPUSH
68848: LD_VAR 0 4
68852: PPUSH
68853: CALL 87738 0 2
// exit ;
68857: POP
68858: POP
68859: GO 68981
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
68861: LD_EXP 46
68865: PUSH
68866: LD_VAR 0 2
68870: ARRAY
68871: PUSH
68872: LD_EXP 66
68876: PUSH
68877: LD_VAR 0 2
68881: ARRAY
68882: NOT
68883: AND
68884: PUSH
68885: LD_EXP 45
68889: PUSH
68890: LD_VAR 0 2
68894: ARRAY
68895: AND
68896: IFFALSE 68977
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68898: LD_ADDR_EXP 66
68902: PUSH
68903: LD_EXP 66
68907: PPUSH
68908: LD_VAR 0 2
68912: PPUSH
68913: LD_INT 1
68915: PPUSH
68916: CALL_OW 1
68920: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
68921: LD_ADDR_VAR 0 4
68925: PUSH
68926: LD_EXP 45
68930: PUSH
68931: LD_VAR 0 2
68935: ARRAY
68936: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68937: LD_ADDR_EXP 45
68941: PUSH
68942: LD_EXP 45
68946: PPUSH
68947: LD_VAR 0 2
68951: PPUSH
68952: EMPTY
68953: PPUSH
68954: CALL_OW 1
68958: ST_TO_ADDR
// Defend ( i , tmp ) ;
68959: LD_VAR 0 2
68963: PPUSH
68964: LD_VAR 0 4
68968: PPUSH
68969: CALL 88334 0 2
// exit ;
68973: POP
68974: POP
68975: GO 68981
// end ; end ;
68977: GO 68139
68979: POP
68980: POP
// end ;
68981: LD_VAR 0 1
68985: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68986: LD_INT 0
68988: PPUSH
68989: PPUSH
68990: PPUSH
68991: PPUSH
68992: PPUSH
68993: PPUSH
68994: PPUSH
68995: PPUSH
68996: PPUSH
68997: PPUSH
68998: PPUSH
// if not mc_bases then
68999: LD_EXP 23
69003: NOT
69004: IFFALSE 69008
// exit ;
69006: GO 70095
// for i = 1 to mc_bases do
69008: LD_ADDR_VAR 0 2
69012: PUSH
69013: DOUBLE
69014: LD_INT 1
69016: DEC
69017: ST_TO_ADDR
69018: LD_EXP 23
69022: PUSH
69023: FOR_TO
69024: IFFALSE 70093
// begin tmp := mc_lab [ i ] ;
69026: LD_ADDR_VAR 0 6
69030: PUSH
69031: LD_EXP 56
69035: PUSH
69036: LD_VAR 0 2
69040: ARRAY
69041: ST_TO_ADDR
// if not tmp then
69042: LD_VAR 0 6
69046: NOT
69047: IFFALSE 69051
// continue ;
69049: GO 69023
// idle_lab := 0 ;
69051: LD_ADDR_VAR 0 11
69055: PUSH
69056: LD_INT 0
69058: ST_TO_ADDR
// for j in tmp do
69059: LD_ADDR_VAR 0 3
69063: PUSH
69064: LD_VAR 0 6
69068: PUSH
69069: FOR_IN
69070: IFFALSE 70089
// begin researching := false ;
69072: LD_ADDR_VAR 0 10
69076: PUSH
69077: LD_INT 0
69079: ST_TO_ADDR
// side := GetSide ( j ) ;
69080: LD_ADDR_VAR 0 4
69084: PUSH
69085: LD_VAR 0 3
69089: PPUSH
69090: CALL_OW 255
69094: ST_TO_ADDR
// if not mc_tech [ side ] then
69095: LD_EXP 50
69099: PUSH
69100: LD_VAR 0 4
69104: ARRAY
69105: NOT
69106: IFFALSE 69110
// continue ;
69108: GO 69069
// if BuildingStatus ( j ) = bs_idle then
69110: LD_VAR 0 3
69114: PPUSH
69115: CALL_OW 461
69119: PUSH
69120: LD_INT 2
69122: EQUAL
69123: IFFALSE 69311
// begin if idle_lab and UnitsInside ( j ) < 6 then
69125: LD_VAR 0 11
69129: PUSH
69130: LD_VAR 0 3
69134: PPUSH
69135: CALL_OW 313
69139: PUSH
69140: LD_INT 6
69142: LESS
69143: AND
69144: IFFALSE 69215
// begin tmp2 := UnitsInside ( idle_lab ) ;
69146: LD_ADDR_VAR 0 9
69150: PUSH
69151: LD_VAR 0 11
69155: PPUSH
69156: CALL_OW 313
69160: ST_TO_ADDR
// if tmp2 then
69161: LD_VAR 0 9
69165: IFFALSE 69207
// for x in tmp2 do
69167: LD_ADDR_VAR 0 7
69171: PUSH
69172: LD_VAR 0 9
69176: PUSH
69177: FOR_IN
69178: IFFALSE 69205
// begin ComExitBuilding ( x ) ;
69180: LD_VAR 0 7
69184: PPUSH
69185: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69189: LD_VAR 0 7
69193: PPUSH
69194: LD_VAR 0 3
69198: PPUSH
69199: CALL_OW 180
// end ;
69203: GO 69177
69205: POP
69206: POP
// idle_lab := 0 ;
69207: LD_ADDR_VAR 0 11
69211: PUSH
69212: LD_INT 0
69214: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69215: LD_ADDR_VAR 0 5
69219: PUSH
69220: LD_EXP 50
69224: PUSH
69225: LD_VAR 0 4
69229: ARRAY
69230: PUSH
69231: FOR_IN
69232: IFFALSE 69292
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69234: LD_VAR 0 3
69238: PPUSH
69239: LD_VAR 0 5
69243: PPUSH
69244: CALL_OW 430
69248: PUSH
69249: LD_VAR 0 4
69253: PPUSH
69254: LD_VAR 0 5
69258: PPUSH
69259: CALL 11883 0 2
69263: AND
69264: IFFALSE 69290
// begin researching := true ;
69266: LD_ADDR_VAR 0 10
69270: PUSH
69271: LD_INT 1
69273: ST_TO_ADDR
// ComResearch ( j , t ) ;
69274: LD_VAR 0 3
69278: PPUSH
69279: LD_VAR 0 5
69283: PPUSH
69284: CALL_OW 124
// break ;
69288: GO 69292
// end ;
69290: GO 69231
69292: POP
69293: POP
// if not researching then
69294: LD_VAR 0 10
69298: NOT
69299: IFFALSE 69311
// idle_lab := j ;
69301: LD_ADDR_VAR 0 11
69305: PUSH
69306: LD_VAR 0 3
69310: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69311: LD_VAR 0 3
69315: PPUSH
69316: CALL_OW 461
69320: PUSH
69321: LD_INT 10
69323: EQUAL
69324: IFFALSE 69912
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69326: LD_EXP 52
69330: PUSH
69331: LD_VAR 0 2
69335: ARRAY
69336: NOT
69337: PUSH
69338: LD_EXP 53
69342: PUSH
69343: LD_VAR 0 2
69347: ARRAY
69348: NOT
69349: AND
69350: PUSH
69351: LD_EXP 50
69355: PUSH
69356: LD_VAR 0 4
69360: ARRAY
69361: PUSH
69362: LD_INT 1
69364: GREATER
69365: AND
69366: IFFALSE 69497
// begin ComCancel ( j ) ;
69368: LD_VAR 0 3
69372: PPUSH
69373: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69377: LD_ADDR_EXP 50
69381: PUSH
69382: LD_EXP 50
69386: PPUSH
69387: LD_VAR 0 4
69391: PPUSH
69392: LD_EXP 50
69396: PUSH
69397: LD_VAR 0 4
69401: ARRAY
69402: PPUSH
69403: LD_EXP 50
69407: PUSH
69408: LD_VAR 0 4
69412: ARRAY
69413: PUSH
69414: LD_INT 1
69416: MINUS
69417: PPUSH
69418: LD_EXP 50
69422: PUSH
69423: LD_VAR 0 4
69427: ARRAY
69428: PPUSH
69429: LD_INT 0
69431: PPUSH
69432: CALL 15584 0 4
69436: PPUSH
69437: CALL_OW 1
69441: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69442: LD_ADDR_EXP 50
69446: PUSH
69447: LD_EXP 50
69451: PPUSH
69452: LD_VAR 0 4
69456: PPUSH
69457: LD_EXP 50
69461: PUSH
69462: LD_VAR 0 4
69466: ARRAY
69467: PPUSH
69468: LD_EXP 50
69472: PUSH
69473: LD_VAR 0 4
69477: ARRAY
69478: PPUSH
69479: LD_INT 1
69481: PPUSH
69482: LD_INT 0
69484: PPUSH
69485: CALL 15584 0 4
69489: PPUSH
69490: CALL_OW 1
69494: ST_TO_ADDR
// continue ;
69495: GO 69069
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69497: LD_EXP 52
69501: PUSH
69502: LD_VAR 0 2
69506: ARRAY
69507: PUSH
69508: LD_EXP 53
69512: PUSH
69513: LD_VAR 0 2
69517: ARRAY
69518: NOT
69519: AND
69520: IFFALSE 69647
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69522: LD_ADDR_EXP 53
69526: PUSH
69527: LD_EXP 53
69531: PPUSH
69532: LD_VAR 0 2
69536: PUSH
69537: LD_EXP 53
69541: PUSH
69542: LD_VAR 0 2
69546: ARRAY
69547: PUSH
69548: LD_INT 1
69550: PLUS
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PPUSH
69556: LD_EXP 52
69560: PUSH
69561: LD_VAR 0 2
69565: ARRAY
69566: PUSH
69567: LD_INT 1
69569: ARRAY
69570: PPUSH
69571: CALL 16166 0 3
69575: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69576: LD_EXP 52
69580: PUSH
69581: LD_VAR 0 2
69585: ARRAY
69586: PUSH
69587: LD_INT 1
69589: ARRAY
69590: PPUSH
69591: LD_INT 112
69593: PPUSH
69594: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69598: LD_ADDR_VAR 0 9
69602: PUSH
69603: LD_EXP 52
69607: PUSH
69608: LD_VAR 0 2
69612: ARRAY
69613: PPUSH
69614: LD_INT 1
69616: PPUSH
69617: CALL_OW 3
69621: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69622: LD_ADDR_EXP 52
69626: PUSH
69627: LD_EXP 52
69631: PPUSH
69632: LD_VAR 0 2
69636: PPUSH
69637: LD_VAR 0 9
69641: PPUSH
69642: CALL_OW 1
69646: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69647: LD_EXP 52
69651: PUSH
69652: LD_VAR 0 2
69656: ARRAY
69657: PUSH
69658: LD_EXP 53
69662: PUSH
69663: LD_VAR 0 2
69667: ARRAY
69668: AND
69669: PUSH
69670: LD_EXP 53
69674: PUSH
69675: LD_VAR 0 2
69679: ARRAY
69680: PUSH
69681: LD_INT 1
69683: ARRAY
69684: PPUSH
69685: CALL_OW 310
69689: NOT
69690: AND
69691: PUSH
69692: LD_VAR 0 3
69696: PPUSH
69697: CALL_OW 313
69701: PUSH
69702: LD_INT 6
69704: EQUAL
69705: AND
69706: IFFALSE 69762
// begin tmp2 := UnitsInside ( j ) ;
69708: LD_ADDR_VAR 0 9
69712: PUSH
69713: LD_VAR 0 3
69717: PPUSH
69718: CALL_OW 313
69722: ST_TO_ADDR
// if tmp2 = 6 then
69723: LD_VAR 0 9
69727: PUSH
69728: LD_INT 6
69730: EQUAL
69731: IFFALSE 69762
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69733: LD_VAR 0 9
69737: PUSH
69738: LD_INT 1
69740: ARRAY
69741: PPUSH
69742: LD_INT 112
69744: PPUSH
69745: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69749: LD_VAR 0 9
69753: PUSH
69754: LD_INT 1
69756: ARRAY
69757: PPUSH
69758: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69762: LD_EXP 53
69766: PUSH
69767: LD_VAR 0 2
69771: ARRAY
69772: PUSH
69773: LD_EXP 53
69777: PUSH
69778: LD_VAR 0 2
69782: ARRAY
69783: PUSH
69784: LD_INT 1
69786: ARRAY
69787: PPUSH
69788: CALL_OW 314
69792: NOT
69793: AND
69794: PUSH
69795: LD_EXP 53
69799: PUSH
69800: LD_VAR 0 2
69804: ARRAY
69805: PUSH
69806: LD_INT 1
69808: ARRAY
69809: PPUSH
69810: CALL_OW 310
69814: NOT
69815: AND
69816: IFFALSE 69842
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69818: LD_EXP 53
69822: PUSH
69823: LD_VAR 0 2
69827: ARRAY
69828: PUSH
69829: LD_INT 1
69831: ARRAY
69832: PPUSH
69833: LD_VAR 0 3
69837: PPUSH
69838: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69842: LD_EXP 53
69846: PUSH
69847: LD_VAR 0 2
69851: ARRAY
69852: PUSH
69853: LD_INT 1
69855: ARRAY
69856: PPUSH
69857: CALL_OW 310
69861: PUSH
69862: LD_EXP 53
69866: PUSH
69867: LD_VAR 0 2
69871: ARRAY
69872: PUSH
69873: LD_INT 1
69875: ARRAY
69876: PPUSH
69877: CALL_OW 310
69881: PPUSH
69882: CALL_OW 461
69886: PUSH
69887: LD_INT 3
69889: NONEQUAL
69890: AND
69891: IFFALSE 69912
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69893: LD_EXP 53
69897: PUSH
69898: LD_VAR 0 2
69902: ARRAY
69903: PUSH
69904: LD_INT 1
69906: ARRAY
69907: PPUSH
69908: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69912: LD_VAR 0 3
69916: PPUSH
69917: CALL_OW 461
69921: PUSH
69922: LD_INT 6
69924: EQUAL
69925: PUSH
69926: LD_VAR 0 6
69930: PUSH
69931: LD_INT 1
69933: GREATER
69934: AND
69935: IFFALSE 70087
// begin sci := [ ] ;
69937: LD_ADDR_VAR 0 8
69941: PUSH
69942: EMPTY
69943: ST_TO_ADDR
// for x in ( tmp diff j ) do
69944: LD_ADDR_VAR 0 7
69948: PUSH
69949: LD_VAR 0 6
69953: PUSH
69954: LD_VAR 0 3
69958: DIFF
69959: PUSH
69960: FOR_IN
69961: IFFALSE 70013
// begin if sci = 6 then
69963: LD_VAR 0 8
69967: PUSH
69968: LD_INT 6
69970: EQUAL
69971: IFFALSE 69975
// break ;
69973: GO 70013
// if BuildingStatus ( x ) = bs_idle then
69975: LD_VAR 0 7
69979: PPUSH
69980: CALL_OW 461
69984: PUSH
69985: LD_INT 2
69987: EQUAL
69988: IFFALSE 70011
// sci := sci ^ UnitsInside ( x ) ;
69990: LD_ADDR_VAR 0 8
69994: PUSH
69995: LD_VAR 0 8
69999: PUSH
70000: LD_VAR 0 7
70004: PPUSH
70005: CALL_OW 313
70009: ADD
70010: ST_TO_ADDR
// end ;
70011: GO 69960
70013: POP
70014: POP
// if not sci then
70015: LD_VAR 0 8
70019: NOT
70020: IFFALSE 70024
// continue ;
70022: GO 69069
// for x in sci do
70024: LD_ADDR_VAR 0 7
70028: PUSH
70029: LD_VAR 0 8
70033: PUSH
70034: FOR_IN
70035: IFFALSE 70085
// if IsInUnit ( x ) and not HasTask ( x ) then
70037: LD_VAR 0 7
70041: PPUSH
70042: CALL_OW 310
70046: PUSH
70047: LD_VAR 0 7
70051: PPUSH
70052: CALL_OW 314
70056: NOT
70057: AND
70058: IFFALSE 70083
// begin ComExitBuilding ( x ) ;
70060: LD_VAR 0 7
70064: PPUSH
70065: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70069: LD_VAR 0 7
70073: PPUSH
70074: LD_VAR 0 3
70078: PPUSH
70079: CALL_OW 180
// end ;
70083: GO 70034
70085: POP
70086: POP
// end ; end ;
70087: GO 69069
70089: POP
70090: POP
// end ;
70091: GO 69023
70093: POP
70094: POP
// end ;
70095: LD_VAR 0 1
70099: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70100: LD_INT 0
70102: PPUSH
70103: PPUSH
// if not mc_bases then
70104: LD_EXP 23
70108: NOT
70109: IFFALSE 70113
// exit ;
70111: GO 70194
// for i = 1 to mc_bases do
70113: LD_ADDR_VAR 0 2
70117: PUSH
70118: DOUBLE
70119: LD_INT 1
70121: DEC
70122: ST_TO_ADDR
70123: LD_EXP 23
70127: PUSH
70128: FOR_TO
70129: IFFALSE 70192
// if mc_mines [ i ] and mc_miners [ i ] then
70131: LD_EXP 36
70135: PUSH
70136: LD_VAR 0 2
70140: ARRAY
70141: PUSH
70142: LD_EXP 37
70146: PUSH
70147: LD_VAR 0 2
70151: ARRAY
70152: AND
70153: IFFALSE 70190
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70155: LD_EXP 37
70159: PUSH
70160: LD_VAR 0 2
70164: ARRAY
70165: PUSH
70166: LD_INT 1
70168: ARRAY
70169: PPUSH
70170: CALL_OW 255
70174: PPUSH
70175: LD_EXP 36
70179: PUSH
70180: LD_VAR 0 2
70184: ARRAY
70185: PPUSH
70186: CALL 12966 0 2
70190: GO 70128
70192: POP
70193: POP
// end ;
70194: LD_VAR 0 1
70198: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70199: LD_INT 0
70201: PPUSH
70202: PPUSH
70203: PPUSH
70204: PPUSH
70205: PPUSH
70206: PPUSH
70207: PPUSH
70208: PPUSH
// if not mc_bases or not mc_parking then
70209: LD_EXP 23
70213: NOT
70214: PUSH
70215: LD_EXP 47
70219: NOT
70220: OR
70221: IFFALSE 70225
// exit ;
70223: GO 70935
// for i = 1 to mc_bases do
70225: LD_ADDR_VAR 0 2
70229: PUSH
70230: DOUBLE
70231: LD_INT 1
70233: DEC
70234: ST_TO_ADDR
70235: LD_EXP 23
70239: PUSH
70240: FOR_TO
70241: IFFALSE 70933
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70243: LD_EXP 23
70247: PUSH
70248: LD_VAR 0 2
70252: ARRAY
70253: NOT
70254: PUSH
70255: LD_EXP 47
70259: PUSH
70260: LD_VAR 0 2
70264: ARRAY
70265: NOT
70266: OR
70267: IFFALSE 70271
// continue ;
70269: GO 70240
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70271: LD_ADDR_VAR 0 5
70275: PUSH
70276: LD_EXP 23
70280: PUSH
70281: LD_VAR 0 2
70285: ARRAY
70286: PUSH
70287: LD_INT 1
70289: ARRAY
70290: PPUSH
70291: CALL_OW 255
70295: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70296: LD_ADDR_VAR 0 6
70300: PUSH
70301: LD_EXP 23
70305: PUSH
70306: LD_VAR 0 2
70310: ARRAY
70311: PPUSH
70312: LD_INT 30
70314: PUSH
70315: LD_INT 3
70317: PUSH
70318: EMPTY
70319: LIST
70320: LIST
70321: PPUSH
70322: CALL_OW 72
70326: ST_TO_ADDR
// if not fac then
70327: LD_VAR 0 6
70331: NOT
70332: IFFALSE 70383
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70334: LD_ADDR_VAR 0 6
70338: PUSH
70339: LD_EXP 23
70343: PUSH
70344: LD_VAR 0 2
70348: ARRAY
70349: PPUSH
70350: LD_INT 2
70352: PUSH
70353: LD_INT 30
70355: PUSH
70356: LD_INT 0
70358: PUSH
70359: EMPTY
70360: LIST
70361: LIST
70362: PUSH
70363: LD_INT 30
70365: PUSH
70366: LD_INT 1
70368: PUSH
70369: EMPTY
70370: LIST
70371: LIST
70372: PUSH
70373: EMPTY
70374: LIST
70375: LIST
70376: LIST
70377: PPUSH
70378: CALL_OW 72
70382: ST_TO_ADDR
// if not fac then
70383: LD_VAR 0 6
70387: NOT
70388: IFFALSE 70392
// continue ;
70390: GO 70240
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70392: LD_ADDR_VAR 0 7
70396: PUSH
70397: LD_EXP 47
70401: PUSH
70402: LD_VAR 0 2
70406: ARRAY
70407: PPUSH
70408: LD_INT 22
70410: PUSH
70411: LD_VAR 0 5
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 21
70422: PUSH
70423: LD_INT 2
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: LD_INT 3
70432: PUSH
70433: LD_INT 24
70435: PUSH
70436: LD_INT 1000
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: PUSH
70443: EMPTY
70444: LIST
70445: LIST
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: LIST
70451: PPUSH
70452: CALL_OW 70
70456: ST_TO_ADDR
// for j in fac do
70457: LD_ADDR_VAR 0 3
70461: PUSH
70462: LD_VAR 0 6
70466: PUSH
70467: FOR_IN
70468: IFFALSE 70549
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70470: LD_ADDR_VAR 0 7
70474: PUSH
70475: LD_VAR 0 7
70479: PUSH
70480: LD_INT 22
70482: PUSH
70483: LD_VAR 0 5
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PUSH
70492: LD_INT 91
70494: PUSH
70495: LD_VAR 0 3
70499: PUSH
70500: LD_INT 15
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: LIST
70507: PUSH
70508: LD_INT 21
70510: PUSH
70511: LD_INT 2
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 3
70520: PUSH
70521: LD_INT 24
70523: PUSH
70524: LD_INT 1000
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: LIST
70539: LIST
70540: PPUSH
70541: CALL_OW 69
70545: UNION
70546: ST_TO_ADDR
70547: GO 70467
70549: POP
70550: POP
// if not vehs then
70551: LD_VAR 0 7
70555: NOT
70556: IFFALSE 70582
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70558: LD_ADDR_EXP 35
70562: PUSH
70563: LD_EXP 35
70567: PPUSH
70568: LD_VAR 0 2
70572: PPUSH
70573: EMPTY
70574: PPUSH
70575: CALL_OW 1
70579: ST_TO_ADDR
// continue ;
70580: GO 70240
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70582: LD_ADDR_VAR 0 8
70586: PUSH
70587: LD_EXP 23
70591: PUSH
70592: LD_VAR 0 2
70596: ARRAY
70597: PPUSH
70598: LD_INT 30
70600: PUSH
70601: LD_INT 3
70603: PUSH
70604: EMPTY
70605: LIST
70606: LIST
70607: PPUSH
70608: CALL_OW 72
70612: ST_TO_ADDR
// if tmp then
70613: LD_VAR 0 8
70617: IFFALSE 70720
// begin for j in tmp do
70619: LD_ADDR_VAR 0 3
70623: PUSH
70624: LD_VAR 0 8
70628: PUSH
70629: FOR_IN
70630: IFFALSE 70718
// for k in UnitsInside ( j ) do
70632: LD_ADDR_VAR 0 4
70636: PUSH
70637: LD_VAR 0 3
70641: PPUSH
70642: CALL_OW 313
70646: PUSH
70647: FOR_IN
70648: IFFALSE 70714
// if k then
70650: LD_VAR 0 4
70654: IFFALSE 70712
// if not k in mc_repair_vehicle [ i ] then
70656: LD_VAR 0 4
70660: PUSH
70661: LD_EXP 35
70665: PUSH
70666: LD_VAR 0 2
70670: ARRAY
70671: IN
70672: NOT
70673: IFFALSE 70712
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70675: LD_ADDR_EXP 35
70679: PUSH
70680: LD_EXP 35
70684: PPUSH
70685: LD_VAR 0 2
70689: PPUSH
70690: LD_EXP 35
70694: PUSH
70695: LD_VAR 0 2
70699: ARRAY
70700: PUSH
70701: LD_VAR 0 4
70705: UNION
70706: PPUSH
70707: CALL_OW 1
70711: ST_TO_ADDR
70712: GO 70647
70714: POP
70715: POP
70716: GO 70629
70718: POP
70719: POP
// end ; if not mc_repair_vehicle [ i ] then
70720: LD_EXP 35
70724: PUSH
70725: LD_VAR 0 2
70729: ARRAY
70730: NOT
70731: IFFALSE 70735
// continue ;
70733: GO 70240
// for j in mc_repair_vehicle [ i ] do
70735: LD_ADDR_VAR 0 3
70739: PUSH
70740: LD_EXP 35
70744: PUSH
70745: LD_VAR 0 2
70749: ARRAY
70750: PUSH
70751: FOR_IN
70752: IFFALSE 70929
// begin if GetClass ( j ) <> 3 then
70754: LD_VAR 0 3
70758: PPUSH
70759: CALL_OW 257
70763: PUSH
70764: LD_INT 3
70766: NONEQUAL
70767: IFFALSE 70808
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70769: LD_ADDR_EXP 35
70773: PUSH
70774: LD_EXP 35
70778: PPUSH
70779: LD_VAR 0 2
70783: PPUSH
70784: LD_EXP 35
70788: PUSH
70789: LD_VAR 0 2
70793: ARRAY
70794: PUSH
70795: LD_VAR 0 3
70799: DIFF
70800: PPUSH
70801: CALL_OW 1
70805: ST_TO_ADDR
// continue ;
70806: GO 70751
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70808: LD_VAR 0 3
70812: PPUSH
70813: CALL_OW 311
70817: NOT
70818: PUSH
70819: LD_VAR 0 3
70823: PUSH
70824: LD_EXP 26
70828: PUSH
70829: LD_VAR 0 2
70833: ARRAY
70834: PUSH
70835: LD_INT 1
70837: ARRAY
70838: IN
70839: NOT
70840: AND
70841: PUSH
70842: LD_VAR 0 3
70846: PUSH
70847: LD_EXP 26
70851: PUSH
70852: LD_VAR 0 2
70856: ARRAY
70857: PUSH
70858: LD_INT 2
70860: ARRAY
70861: IN
70862: NOT
70863: AND
70864: IFFALSE 70927
// begin if IsInUnit ( j ) then
70866: LD_VAR 0 3
70870: PPUSH
70871: CALL_OW 310
70875: IFFALSE 70888
// ComExitBuilding ( j ) else
70877: LD_VAR 0 3
70881: PPUSH
70882: CALL_OW 122
70886: GO 70927
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
70888: LD_VAR 0 3
70892: PPUSH
70893: LD_VAR 0 7
70897: PUSH
70898: LD_INT 1
70900: ARRAY
70901: PPUSH
70902: CALL 50495 0 2
70906: NOT
70907: IFFALSE 70927
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
70909: LD_VAR 0 3
70913: PPUSH
70914: LD_VAR 0 7
70918: PUSH
70919: LD_INT 1
70921: ARRAY
70922: PPUSH
70923: CALL_OW 129
// end ; end ;
70927: GO 70751
70929: POP
70930: POP
// end ;
70931: GO 70240
70933: POP
70934: POP
// end ;
70935: LD_VAR 0 1
70939: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70940: LD_INT 0
70942: PPUSH
70943: PPUSH
70944: PPUSH
70945: PPUSH
70946: PPUSH
70947: PPUSH
70948: PPUSH
70949: PPUSH
70950: PPUSH
70951: PPUSH
70952: PPUSH
// if not mc_bases then
70953: LD_EXP 23
70957: NOT
70958: IFFALSE 70962
// exit ;
70960: GO 71764
// for i = 1 to mc_bases do
70962: LD_ADDR_VAR 0 2
70966: PUSH
70967: DOUBLE
70968: LD_INT 1
70970: DEC
70971: ST_TO_ADDR
70972: LD_EXP 23
70976: PUSH
70977: FOR_TO
70978: IFFALSE 71762
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70980: LD_EXP 51
70984: PUSH
70985: LD_VAR 0 2
70989: ARRAY
70990: NOT
70991: PUSH
70992: LD_EXP 26
70996: PUSH
70997: LD_VAR 0 2
71001: ARRAY
71002: PUSH
71003: LD_INT 1
71005: ARRAY
71006: OR
71007: PUSH
71008: LD_EXP 26
71012: PUSH
71013: LD_VAR 0 2
71017: ARRAY
71018: PUSH
71019: LD_INT 2
71021: ARRAY
71022: OR
71023: PUSH
71024: LD_EXP 49
71028: PUSH
71029: LD_VAR 0 2
71033: ARRAY
71034: PPUSH
71035: LD_INT 1
71037: PPUSH
71038: CALL_OW 325
71042: NOT
71043: OR
71044: PUSH
71045: LD_EXP 46
71049: PUSH
71050: LD_VAR 0 2
71054: ARRAY
71055: OR
71056: IFFALSE 71060
// continue ;
71058: GO 70977
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71060: LD_ADDR_VAR 0 8
71064: PUSH
71065: LD_EXP 23
71069: PUSH
71070: LD_VAR 0 2
71074: ARRAY
71075: PPUSH
71076: LD_INT 25
71078: PUSH
71079: LD_INT 4
71081: PUSH
71082: EMPTY
71083: LIST
71084: LIST
71085: PUSH
71086: LD_INT 50
71088: PUSH
71089: EMPTY
71090: LIST
71091: PUSH
71092: LD_INT 3
71094: PUSH
71095: LD_INT 60
71097: PUSH
71098: EMPTY
71099: LIST
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: EMPTY
71106: LIST
71107: LIST
71108: LIST
71109: PPUSH
71110: CALL_OW 72
71114: PUSH
71115: LD_EXP 27
71119: PUSH
71120: LD_VAR 0 2
71124: ARRAY
71125: DIFF
71126: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71127: LD_ADDR_VAR 0 9
71131: PUSH
71132: LD_EXP 23
71136: PUSH
71137: LD_VAR 0 2
71141: ARRAY
71142: PPUSH
71143: LD_INT 2
71145: PUSH
71146: LD_INT 30
71148: PUSH
71149: LD_INT 0
71151: PUSH
71152: EMPTY
71153: LIST
71154: LIST
71155: PUSH
71156: LD_INT 30
71158: PUSH
71159: LD_INT 1
71161: PUSH
71162: EMPTY
71163: LIST
71164: LIST
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: LIST
71170: PPUSH
71171: CALL_OW 72
71175: ST_TO_ADDR
// if not tmp or not dep then
71176: LD_VAR 0 8
71180: NOT
71181: PUSH
71182: LD_VAR 0 9
71186: NOT
71187: OR
71188: IFFALSE 71192
// continue ;
71190: GO 70977
// side := GetSide ( tmp [ 1 ] ) ;
71192: LD_ADDR_VAR 0 11
71196: PUSH
71197: LD_VAR 0 8
71201: PUSH
71202: LD_INT 1
71204: ARRAY
71205: PPUSH
71206: CALL_OW 255
71210: ST_TO_ADDR
// dep := dep [ 1 ] ;
71211: LD_ADDR_VAR 0 9
71215: PUSH
71216: LD_VAR 0 9
71220: PUSH
71221: LD_INT 1
71223: ARRAY
71224: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71225: LD_ADDR_VAR 0 7
71229: PUSH
71230: LD_EXP 51
71234: PUSH
71235: LD_VAR 0 2
71239: ARRAY
71240: PPUSH
71241: LD_INT 22
71243: PUSH
71244: LD_INT 0
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 25
71253: PUSH
71254: LD_INT 12
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PPUSH
71265: CALL_OW 70
71269: PUSH
71270: LD_INT 22
71272: PUSH
71273: LD_INT 0
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 25
71282: PUSH
71283: LD_INT 12
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 91
71292: PUSH
71293: LD_VAR 0 9
71297: PUSH
71298: LD_INT 20
71300: PUSH
71301: EMPTY
71302: LIST
71303: LIST
71304: LIST
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: LIST
71310: PPUSH
71311: CALL_OW 69
71315: UNION
71316: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71317: LD_ADDR_VAR 0 10
71321: PUSH
71322: LD_EXP 51
71326: PUSH
71327: LD_VAR 0 2
71331: ARRAY
71332: PPUSH
71333: LD_INT 81
71335: PUSH
71336: LD_VAR 0 11
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PPUSH
71345: CALL_OW 70
71349: ST_TO_ADDR
// if not apes or danger_at_area then
71350: LD_VAR 0 7
71354: NOT
71355: PUSH
71356: LD_VAR 0 10
71360: OR
71361: IFFALSE 71411
// begin if mc_taming [ i ] then
71363: LD_EXP 54
71367: PUSH
71368: LD_VAR 0 2
71372: ARRAY
71373: IFFALSE 71409
// begin MC_Reset ( i , 121 ) ;
71375: LD_VAR 0 2
71379: PPUSH
71380: LD_INT 121
71382: PPUSH
71383: CALL 56397 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71387: LD_ADDR_EXP 54
71391: PUSH
71392: LD_EXP 54
71396: PPUSH
71397: LD_VAR 0 2
71401: PPUSH
71402: EMPTY
71403: PPUSH
71404: CALL_OW 1
71408: ST_TO_ADDR
// end ; continue ;
71409: GO 70977
// end ; for j in tmp do
71411: LD_ADDR_VAR 0 3
71415: PUSH
71416: LD_VAR 0 8
71420: PUSH
71421: FOR_IN
71422: IFFALSE 71758
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71424: LD_VAR 0 3
71428: PUSH
71429: LD_EXP 54
71433: PUSH
71434: LD_VAR 0 2
71438: ARRAY
71439: IN
71440: NOT
71441: PUSH
71442: LD_EXP 54
71446: PUSH
71447: LD_VAR 0 2
71451: ARRAY
71452: PUSH
71453: LD_INT 3
71455: LESS
71456: AND
71457: IFFALSE 71515
// begin SetTag ( j , 121 ) ;
71459: LD_VAR 0 3
71463: PPUSH
71464: LD_INT 121
71466: PPUSH
71467: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71471: LD_ADDR_EXP 54
71475: PUSH
71476: LD_EXP 54
71480: PPUSH
71481: LD_VAR 0 2
71485: PUSH
71486: LD_EXP 54
71490: PUSH
71491: LD_VAR 0 2
71495: ARRAY
71496: PUSH
71497: LD_INT 1
71499: PLUS
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PPUSH
71505: LD_VAR 0 3
71509: PPUSH
71510: CALL 16166 0 3
71514: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71515: LD_VAR 0 3
71519: PUSH
71520: LD_EXP 54
71524: PUSH
71525: LD_VAR 0 2
71529: ARRAY
71530: IN
71531: IFFALSE 71756
// begin if GetClass ( j ) <> 4 then
71533: LD_VAR 0 3
71537: PPUSH
71538: CALL_OW 257
71542: PUSH
71543: LD_INT 4
71545: NONEQUAL
71546: IFFALSE 71599
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71548: LD_ADDR_EXP 54
71552: PUSH
71553: LD_EXP 54
71557: PPUSH
71558: LD_VAR 0 2
71562: PPUSH
71563: LD_EXP 54
71567: PUSH
71568: LD_VAR 0 2
71572: ARRAY
71573: PUSH
71574: LD_VAR 0 3
71578: DIFF
71579: PPUSH
71580: CALL_OW 1
71584: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71585: LD_VAR 0 3
71589: PPUSH
71590: LD_INT 0
71592: PPUSH
71593: CALL_OW 109
// continue ;
71597: GO 71421
// end ; if IsInUnit ( j ) then
71599: LD_VAR 0 3
71603: PPUSH
71604: CALL_OW 310
71608: IFFALSE 71619
// ComExitBuilding ( j ) ;
71610: LD_VAR 0 3
71614: PPUSH
71615: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71619: LD_ADDR_VAR 0 6
71623: PUSH
71624: LD_VAR 0 7
71628: PPUSH
71629: LD_VAR 0 3
71633: PPUSH
71634: CALL_OW 74
71638: ST_TO_ADDR
// if not ape then
71639: LD_VAR 0 6
71643: NOT
71644: IFFALSE 71648
// break ;
71646: GO 71758
// x := GetX ( ape ) ;
71648: LD_ADDR_VAR 0 4
71652: PUSH
71653: LD_VAR 0 6
71657: PPUSH
71658: CALL_OW 250
71662: ST_TO_ADDR
// y := GetY ( ape ) ;
71663: LD_ADDR_VAR 0 5
71667: PUSH
71668: LD_VAR 0 6
71672: PPUSH
71673: CALL_OW 251
71677: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71678: LD_VAR 0 4
71682: PPUSH
71683: LD_VAR 0 5
71687: PPUSH
71688: CALL_OW 488
71692: NOT
71693: PUSH
71694: LD_VAR 0 11
71698: PPUSH
71699: LD_VAR 0 4
71703: PPUSH
71704: LD_VAR 0 5
71708: PPUSH
71709: LD_INT 20
71711: PPUSH
71712: CALL 17062 0 4
71716: PUSH
71717: LD_INT 4
71719: ARRAY
71720: OR
71721: IFFALSE 71725
// break ;
71723: GO 71758
// if not HasTask ( j ) then
71725: LD_VAR 0 3
71729: PPUSH
71730: CALL_OW 314
71734: NOT
71735: IFFALSE 71756
// ComTameXY ( j , x , y ) ;
71737: LD_VAR 0 3
71741: PPUSH
71742: LD_VAR 0 4
71746: PPUSH
71747: LD_VAR 0 5
71751: PPUSH
71752: CALL_OW 131
// end ; end ;
71756: GO 71421
71758: POP
71759: POP
// end ;
71760: GO 70977
71762: POP
71763: POP
// end ;
71764: LD_VAR 0 1
71768: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71769: LD_INT 0
71771: PPUSH
71772: PPUSH
71773: PPUSH
71774: PPUSH
71775: PPUSH
71776: PPUSH
71777: PPUSH
71778: PPUSH
// if not mc_bases then
71779: LD_EXP 23
71783: NOT
71784: IFFALSE 71788
// exit ;
71786: GO 72414
// for i = 1 to mc_bases do
71788: LD_ADDR_VAR 0 2
71792: PUSH
71793: DOUBLE
71794: LD_INT 1
71796: DEC
71797: ST_TO_ADDR
71798: LD_EXP 23
71802: PUSH
71803: FOR_TO
71804: IFFALSE 72412
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71806: LD_EXP 52
71810: PUSH
71811: LD_VAR 0 2
71815: ARRAY
71816: NOT
71817: PUSH
71818: LD_EXP 52
71822: PUSH
71823: LD_VAR 0 2
71827: ARRAY
71828: PPUSH
71829: LD_INT 25
71831: PUSH
71832: LD_INT 12
71834: PUSH
71835: EMPTY
71836: LIST
71837: LIST
71838: PPUSH
71839: CALL_OW 72
71843: NOT
71844: OR
71845: IFFALSE 71849
// continue ;
71847: GO 71803
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71849: LD_ADDR_VAR 0 5
71853: PUSH
71854: LD_EXP 52
71858: PUSH
71859: LD_VAR 0 2
71863: ARRAY
71864: PUSH
71865: LD_INT 1
71867: ARRAY
71868: PPUSH
71869: CALL_OW 255
71873: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71874: LD_VAR 0 5
71878: PPUSH
71879: LD_INT 2
71881: PPUSH
71882: CALL_OW 325
71886: IFFALSE 72139
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71888: LD_ADDR_VAR 0 4
71892: PUSH
71893: LD_EXP 52
71897: PUSH
71898: LD_VAR 0 2
71902: ARRAY
71903: PPUSH
71904: LD_INT 25
71906: PUSH
71907: LD_INT 16
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PPUSH
71914: CALL_OW 72
71918: ST_TO_ADDR
// if tmp < 6 then
71919: LD_VAR 0 4
71923: PUSH
71924: LD_INT 6
71926: LESS
71927: IFFALSE 72139
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71929: LD_ADDR_VAR 0 6
71933: PUSH
71934: LD_EXP 23
71938: PUSH
71939: LD_VAR 0 2
71943: ARRAY
71944: PPUSH
71945: LD_INT 2
71947: PUSH
71948: LD_INT 30
71950: PUSH
71951: LD_INT 0
71953: PUSH
71954: EMPTY
71955: LIST
71956: LIST
71957: PUSH
71958: LD_INT 30
71960: PUSH
71961: LD_INT 1
71963: PUSH
71964: EMPTY
71965: LIST
71966: LIST
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: LIST
71972: PPUSH
71973: CALL_OW 72
71977: ST_TO_ADDR
// if depot then
71978: LD_VAR 0 6
71982: IFFALSE 72139
// begin selected := 0 ;
71984: LD_ADDR_VAR 0 7
71988: PUSH
71989: LD_INT 0
71991: ST_TO_ADDR
// for j in depot do
71992: LD_ADDR_VAR 0 3
71996: PUSH
71997: LD_VAR 0 6
72001: PUSH
72002: FOR_IN
72003: IFFALSE 72034
// begin if UnitsInside ( j ) < 6 then
72005: LD_VAR 0 3
72009: PPUSH
72010: CALL_OW 313
72014: PUSH
72015: LD_INT 6
72017: LESS
72018: IFFALSE 72032
// begin selected := j ;
72020: LD_ADDR_VAR 0 7
72024: PUSH
72025: LD_VAR 0 3
72029: ST_TO_ADDR
// break ;
72030: GO 72034
// end ; end ;
72032: GO 72002
72034: POP
72035: POP
// if selected then
72036: LD_VAR 0 7
72040: IFFALSE 72139
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72042: LD_ADDR_VAR 0 3
72046: PUSH
72047: LD_EXP 52
72051: PUSH
72052: LD_VAR 0 2
72056: ARRAY
72057: PPUSH
72058: LD_INT 25
72060: PUSH
72061: LD_INT 12
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: PPUSH
72068: CALL_OW 72
72072: PUSH
72073: FOR_IN
72074: IFFALSE 72137
// if not HasTask ( j ) then
72076: LD_VAR 0 3
72080: PPUSH
72081: CALL_OW 314
72085: NOT
72086: IFFALSE 72135
// begin if not IsInUnit ( j ) then
72088: LD_VAR 0 3
72092: PPUSH
72093: CALL_OW 310
72097: NOT
72098: IFFALSE 72114
// ComEnterUnit ( j , selected ) ;
72100: LD_VAR 0 3
72104: PPUSH
72105: LD_VAR 0 7
72109: PPUSH
72110: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72114: LD_VAR 0 3
72118: PPUSH
72119: LD_INT 16
72121: PPUSH
72122: CALL_OW 183
// AddComExitBuilding ( j ) ;
72126: LD_VAR 0 3
72130: PPUSH
72131: CALL_OW 182
// end ;
72135: GO 72073
72137: POP
72138: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72139: LD_VAR 0 5
72143: PPUSH
72144: LD_INT 11
72146: PPUSH
72147: CALL_OW 325
72151: IFFALSE 72410
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72153: LD_ADDR_VAR 0 4
72157: PUSH
72158: LD_EXP 52
72162: PUSH
72163: LD_VAR 0 2
72167: ARRAY
72168: PPUSH
72169: LD_INT 25
72171: PUSH
72172: LD_INT 16
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: PPUSH
72179: CALL_OW 72
72183: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72184: LD_VAR 0 4
72188: PUSH
72189: LD_INT 6
72191: GREATEREQUAL
72192: PUSH
72193: LD_VAR 0 5
72197: PPUSH
72198: LD_INT 2
72200: PPUSH
72201: CALL_OW 325
72205: NOT
72206: OR
72207: IFFALSE 72410
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72209: LD_ADDR_VAR 0 8
72213: PUSH
72214: LD_EXP 23
72218: PUSH
72219: LD_VAR 0 2
72223: ARRAY
72224: PPUSH
72225: LD_INT 2
72227: PUSH
72228: LD_INT 30
72230: PUSH
72231: LD_INT 4
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 30
72240: PUSH
72241: LD_INT 5
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: EMPTY
72249: LIST
72250: LIST
72251: LIST
72252: PPUSH
72253: CALL_OW 72
72257: ST_TO_ADDR
// if barracks then
72258: LD_VAR 0 8
72262: IFFALSE 72410
// begin selected := 0 ;
72264: LD_ADDR_VAR 0 7
72268: PUSH
72269: LD_INT 0
72271: ST_TO_ADDR
// for j in barracks do
72272: LD_ADDR_VAR 0 3
72276: PUSH
72277: LD_VAR 0 8
72281: PUSH
72282: FOR_IN
72283: IFFALSE 72314
// begin if UnitsInside ( j ) < 6 then
72285: LD_VAR 0 3
72289: PPUSH
72290: CALL_OW 313
72294: PUSH
72295: LD_INT 6
72297: LESS
72298: IFFALSE 72312
// begin selected := j ;
72300: LD_ADDR_VAR 0 7
72304: PUSH
72305: LD_VAR 0 3
72309: ST_TO_ADDR
// break ;
72310: GO 72314
// end ; end ;
72312: GO 72282
72314: POP
72315: POP
// if selected then
72316: LD_VAR 0 7
72320: IFFALSE 72410
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72322: LD_ADDR_VAR 0 3
72326: PUSH
72327: LD_EXP 52
72331: PUSH
72332: LD_VAR 0 2
72336: ARRAY
72337: PPUSH
72338: LD_INT 25
72340: PUSH
72341: LD_INT 12
72343: PUSH
72344: EMPTY
72345: LIST
72346: LIST
72347: PPUSH
72348: CALL_OW 72
72352: PUSH
72353: FOR_IN
72354: IFFALSE 72408
// if not IsInUnit ( j ) and not HasTask ( j ) then
72356: LD_VAR 0 3
72360: PPUSH
72361: CALL_OW 310
72365: NOT
72366: PUSH
72367: LD_VAR 0 3
72371: PPUSH
72372: CALL_OW 314
72376: NOT
72377: AND
72378: IFFALSE 72406
// begin ComEnterUnit ( j , selected ) ;
72380: LD_VAR 0 3
72384: PPUSH
72385: LD_VAR 0 7
72389: PPUSH
72390: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72394: LD_VAR 0 3
72398: PPUSH
72399: LD_INT 15
72401: PPUSH
72402: CALL_OW 183
// end ;
72406: GO 72353
72408: POP
72409: POP
// end ; end ; end ; end ; end ;
72410: GO 71803
72412: POP
72413: POP
// end ;
72414: LD_VAR 0 1
72418: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72419: LD_INT 0
72421: PPUSH
72422: PPUSH
72423: PPUSH
72424: PPUSH
// if not mc_bases then
72425: LD_EXP 23
72429: NOT
72430: IFFALSE 72434
// exit ;
72432: GO 72612
// for i = 1 to mc_bases do
72434: LD_ADDR_VAR 0 2
72438: PUSH
72439: DOUBLE
72440: LD_INT 1
72442: DEC
72443: ST_TO_ADDR
72444: LD_EXP 23
72448: PUSH
72449: FOR_TO
72450: IFFALSE 72610
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72452: LD_ADDR_VAR 0 4
72456: PUSH
72457: LD_EXP 23
72461: PUSH
72462: LD_VAR 0 2
72466: ARRAY
72467: PPUSH
72468: LD_INT 25
72470: PUSH
72471: LD_INT 9
72473: PUSH
72474: EMPTY
72475: LIST
72476: LIST
72477: PPUSH
72478: CALL_OW 72
72482: ST_TO_ADDR
// if not tmp then
72483: LD_VAR 0 4
72487: NOT
72488: IFFALSE 72492
// continue ;
72490: GO 72449
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72492: LD_EXP 49
72496: PUSH
72497: LD_VAR 0 2
72501: ARRAY
72502: PPUSH
72503: LD_INT 29
72505: PPUSH
72506: CALL_OW 325
72510: NOT
72511: PUSH
72512: LD_EXP 49
72516: PUSH
72517: LD_VAR 0 2
72521: ARRAY
72522: PPUSH
72523: LD_INT 28
72525: PPUSH
72526: CALL_OW 325
72530: NOT
72531: AND
72532: IFFALSE 72536
// continue ;
72534: GO 72449
// for j in tmp do
72536: LD_ADDR_VAR 0 3
72540: PUSH
72541: LD_VAR 0 4
72545: PUSH
72546: FOR_IN
72547: IFFALSE 72606
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72549: LD_VAR 0 3
72553: PUSH
72554: LD_EXP 26
72558: PUSH
72559: LD_VAR 0 2
72563: ARRAY
72564: PUSH
72565: LD_INT 1
72567: ARRAY
72568: IN
72569: NOT
72570: PUSH
72571: LD_VAR 0 3
72575: PUSH
72576: LD_EXP 26
72580: PUSH
72581: LD_VAR 0 2
72585: ARRAY
72586: PUSH
72587: LD_INT 2
72589: ARRAY
72590: IN
72591: NOT
72592: AND
72593: IFFALSE 72604
// ComSpaceTimeShoot ( j ) ;
72595: LD_VAR 0 3
72599: PPUSH
72600: CALL 11974 0 1
72604: GO 72546
72606: POP
72607: POP
// end ;
72608: GO 72449
72610: POP
72611: POP
// end ;
72612: LD_VAR 0 1
72616: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72617: LD_INT 0
72619: PPUSH
72620: PPUSH
72621: PPUSH
72622: PPUSH
72623: PPUSH
72624: PPUSH
72625: PPUSH
72626: PPUSH
72627: PPUSH
// if not mc_bases then
72628: LD_EXP 23
72632: NOT
72633: IFFALSE 72637
// exit ;
72635: GO 73259
// for i = 1 to mc_bases do
72637: LD_ADDR_VAR 0 2
72641: PUSH
72642: DOUBLE
72643: LD_INT 1
72645: DEC
72646: ST_TO_ADDR
72647: LD_EXP 23
72651: PUSH
72652: FOR_TO
72653: IFFALSE 73257
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72655: LD_EXP 58
72659: PUSH
72660: LD_VAR 0 2
72664: ARRAY
72665: NOT
72666: PUSH
72667: LD_INT 38
72669: PPUSH
72670: LD_EXP 49
72674: PUSH
72675: LD_VAR 0 2
72679: ARRAY
72680: PPUSH
72681: CALL_OW 321
72685: PUSH
72686: LD_INT 2
72688: NONEQUAL
72689: OR
72690: IFFALSE 72694
// continue ;
72692: GO 72652
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72694: LD_ADDR_VAR 0 8
72698: PUSH
72699: LD_EXP 23
72703: PUSH
72704: LD_VAR 0 2
72708: ARRAY
72709: PPUSH
72710: LD_INT 30
72712: PUSH
72713: LD_INT 34
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PPUSH
72720: CALL_OW 72
72724: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72725: LD_ADDR_VAR 0 9
72729: PUSH
72730: LD_EXP 23
72734: PUSH
72735: LD_VAR 0 2
72739: ARRAY
72740: PPUSH
72741: LD_INT 25
72743: PUSH
72744: LD_INT 4
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PPUSH
72751: CALL_OW 72
72755: PPUSH
72756: LD_INT 0
72758: PPUSH
72759: CALL 46002 0 2
72763: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72764: LD_VAR 0 9
72768: NOT
72769: PUSH
72770: LD_VAR 0 8
72774: NOT
72775: OR
72776: PUSH
72777: LD_EXP 23
72781: PUSH
72782: LD_VAR 0 2
72786: ARRAY
72787: PPUSH
72788: LD_INT 124
72790: PPUSH
72791: CALL 46002 0 2
72795: OR
72796: IFFALSE 72800
// continue ;
72798: GO 72652
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72800: LD_EXP 59
72804: PUSH
72805: LD_VAR 0 2
72809: ARRAY
72810: PUSH
72811: LD_EXP 58
72815: PUSH
72816: LD_VAR 0 2
72820: ARRAY
72821: LESS
72822: PUSH
72823: LD_EXP 59
72827: PUSH
72828: LD_VAR 0 2
72832: ARRAY
72833: PUSH
72834: LD_VAR 0 8
72838: LESS
72839: AND
72840: IFFALSE 73255
// begin tmp := sci [ 1 ] ;
72842: LD_ADDR_VAR 0 7
72846: PUSH
72847: LD_VAR 0 9
72851: PUSH
72852: LD_INT 1
72854: ARRAY
72855: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72856: LD_VAR 0 7
72860: PPUSH
72861: LD_INT 124
72863: PPUSH
72864: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72868: LD_ADDR_VAR 0 3
72872: PUSH
72873: DOUBLE
72874: LD_EXP 58
72878: PUSH
72879: LD_VAR 0 2
72883: ARRAY
72884: INC
72885: ST_TO_ADDR
72886: LD_EXP 58
72890: PUSH
72891: LD_VAR 0 2
72895: ARRAY
72896: PUSH
72897: FOR_DOWNTO
72898: IFFALSE 73241
// begin if IsInUnit ( tmp ) then
72900: LD_VAR 0 7
72904: PPUSH
72905: CALL_OW 310
72909: IFFALSE 72920
// ComExitBuilding ( tmp ) ;
72911: LD_VAR 0 7
72915: PPUSH
72916: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72920: LD_INT 35
72922: PPUSH
72923: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72927: LD_VAR 0 7
72931: PPUSH
72932: CALL_OW 310
72936: NOT
72937: PUSH
72938: LD_VAR 0 7
72942: PPUSH
72943: CALL_OW 314
72947: NOT
72948: AND
72949: IFFALSE 72920
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72951: LD_ADDR_VAR 0 6
72955: PUSH
72956: LD_VAR 0 7
72960: PPUSH
72961: CALL_OW 250
72965: PUSH
72966: LD_VAR 0 7
72970: PPUSH
72971: CALL_OW 251
72975: PUSH
72976: EMPTY
72977: LIST
72978: LIST
72979: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72980: LD_INT 35
72982: PPUSH
72983: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72987: LD_ADDR_VAR 0 4
72991: PUSH
72992: LD_EXP 58
72996: PUSH
72997: LD_VAR 0 2
73001: ARRAY
73002: PUSH
73003: LD_VAR 0 3
73007: ARRAY
73008: PUSH
73009: LD_INT 1
73011: ARRAY
73012: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73013: LD_ADDR_VAR 0 5
73017: PUSH
73018: LD_EXP 58
73022: PUSH
73023: LD_VAR 0 2
73027: ARRAY
73028: PUSH
73029: LD_VAR 0 3
73033: ARRAY
73034: PUSH
73035: LD_INT 2
73037: ARRAY
73038: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73039: LD_VAR 0 7
73043: PPUSH
73044: LD_INT 10
73046: PPUSH
73047: CALL 18765 0 2
73051: PUSH
73052: LD_INT 4
73054: ARRAY
73055: IFFALSE 73093
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73057: LD_VAR 0 7
73061: PPUSH
73062: LD_VAR 0 6
73066: PUSH
73067: LD_INT 1
73069: ARRAY
73070: PPUSH
73071: LD_VAR 0 6
73075: PUSH
73076: LD_INT 2
73078: ARRAY
73079: PPUSH
73080: CALL_OW 111
// wait ( 0 0$10 ) ;
73084: LD_INT 350
73086: PPUSH
73087: CALL_OW 67
// end else
73091: GO 73119
// begin ComMoveXY ( tmp , x , y ) ;
73093: LD_VAR 0 7
73097: PPUSH
73098: LD_VAR 0 4
73102: PPUSH
73103: LD_VAR 0 5
73107: PPUSH
73108: CALL_OW 111
// wait ( 0 0$3 ) ;
73112: LD_INT 105
73114: PPUSH
73115: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73119: LD_VAR 0 7
73123: PPUSH
73124: LD_VAR 0 4
73128: PPUSH
73129: LD_VAR 0 5
73133: PPUSH
73134: CALL_OW 307
73138: IFFALSE 72980
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73140: LD_VAR 0 7
73144: PPUSH
73145: LD_VAR 0 4
73149: PPUSH
73150: LD_VAR 0 5
73154: PPUSH
73155: LD_VAR 0 8
73159: PUSH
73160: LD_VAR 0 3
73164: ARRAY
73165: PPUSH
73166: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73170: LD_INT 35
73172: PPUSH
73173: CALL_OW 67
// until not HasTask ( tmp ) ;
73177: LD_VAR 0 7
73181: PPUSH
73182: CALL_OW 314
73186: NOT
73187: IFFALSE 73170
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73189: LD_ADDR_EXP 59
73193: PUSH
73194: LD_EXP 59
73198: PPUSH
73199: LD_VAR 0 2
73203: PUSH
73204: LD_EXP 59
73208: PUSH
73209: LD_VAR 0 2
73213: ARRAY
73214: PUSH
73215: LD_INT 1
73217: PLUS
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: PPUSH
73223: LD_VAR 0 8
73227: PUSH
73228: LD_VAR 0 3
73232: ARRAY
73233: PPUSH
73234: CALL 16166 0 3
73238: ST_TO_ADDR
// end ;
73239: GO 72897
73241: POP
73242: POP
// MC_Reset ( i , 124 ) ;
73243: LD_VAR 0 2
73247: PPUSH
73248: LD_INT 124
73250: PPUSH
73251: CALL 56397 0 2
// end ; end ;
73255: GO 72652
73257: POP
73258: POP
// end ;
73259: LD_VAR 0 1
73263: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73264: LD_INT 0
73266: PPUSH
73267: PPUSH
73268: PPUSH
// if not mc_bases then
73269: LD_EXP 23
73273: NOT
73274: IFFALSE 73278
// exit ;
73276: GO 73884
// for i = 1 to mc_bases do
73278: LD_ADDR_VAR 0 2
73282: PUSH
73283: DOUBLE
73284: LD_INT 1
73286: DEC
73287: ST_TO_ADDR
73288: LD_EXP 23
73292: PUSH
73293: FOR_TO
73294: IFFALSE 73882
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73296: LD_ADDR_VAR 0 3
73300: PUSH
73301: LD_EXP 23
73305: PUSH
73306: LD_VAR 0 2
73310: ARRAY
73311: PPUSH
73312: LD_INT 25
73314: PUSH
73315: LD_INT 4
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PPUSH
73322: CALL_OW 72
73326: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73327: LD_VAR 0 3
73331: NOT
73332: PUSH
73333: LD_EXP 60
73337: PUSH
73338: LD_VAR 0 2
73342: ARRAY
73343: NOT
73344: OR
73345: PUSH
73346: LD_EXP 23
73350: PUSH
73351: LD_VAR 0 2
73355: ARRAY
73356: PPUSH
73357: LD_INT 2
73359: PUSH
73360: LD_INT 30
73362: PUSH
73363: LD_INT 0
73365: PUSH
73366: EMPTY
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 30
73372: PUSH
73373: LD_INT 1
73375: PUSH
73376: EMPTY
73377: LIST
73378: LIST
73379: PUSH
73380: EMPTY
73381: LIST
73382: LIST
73383: LIST
73384: PPUSH
73385: CALL_OW 72
73389: NOT
73390: OR
73391: IFFALSE 73441
// begin if mc_deposits_finder [ i ] then
73393: LD_EXP 61
73397: PUSH
73398: LD_VAR 0 2
73402: ARRAY
73403: IFFALSE 73439
// begin MC_Reset ( i , 125 ) ;
73405: LD_VAR 0 2
73409: PPUSH
73410: LD_INT 125
73412: PPUSH
73413: CALL 56397 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73417: LD_ADDR_EXP 61
73421: PUSH
73422: LD_EXP 61
73426: PPUSH
73427: LD_VAR 0 2
73431: PPUSH
73432: EMPTY
73433: PPUSH
73434: CALL_OW 1
73438: ST_TO_ADDR
// end ; continue ;
73439: GO 73293
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73441: LD_EXP 60
73445: PUSH
73446: LD_VAR 0 2
73450: ARRAY
73451: PUSH
73452: LD_INT 1
73454: ARRAY
73455: PUSH
73456: LD_INT 3
73458: ARRAY
73459: PUSH
73460: LD_INT 1
73462: EQUAL
73463: PUSH
73464: LD_INT 20
73466: PPUSH
73467: LD_EXP 49
73471: PUSH
73472: LD_VAR 0 2
73476: ARRAY
73477: PPUSH
73478: CALL_OW 321
73482: PUSH
73483: LD_INT 2
73485: NONEQUAL
73486: AND
73487: IFFALSE 73537
// begin if mc_deposits_finder [ i ] then
73489: LD_EXP 61
73493: PUSH
73494: LD_VAR 0 2
73498: ARRAY
73499: IFFALSE 73535
// begin MC_Reset ( i , 125 ) ;
73501: LD_VAR 0 2
73505: PPUSH
73506: LD_INT 125
73508: PPUSH
73509: CALL 56397 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73513: LD_ADDR_EXP 61
73517: PUSH
73518: LD_EXP 61
73522: PPUSH
73523: LD_VAR 0 2
73527: PPUSH
73528: EMPTY
73529: PPUSH
73530: CALL_OW 1
73534: ST_TO_ADDR
// end ; continue ;
73535: GO 73293
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73537: LD_EXP 60
73541: PUSH
73542: LD_VAR 0 2
73546: ARRAY
73547: PUSH
73548: LD_INT 1
73550: ARRAY
73551: PUSH
73552: LD_INT 1
73554: ARRAY
73555: PPUSH
73556: LD_EXP 60
73560: PUSH
73561: LD_VAR 0 2
73565: ARRAY
73566: PUSH
73567: LD_INT 1
73569: ARRAY
73570: PUSH
73571: LD_INT 2
73573: ARRAY
73574: PPUSH
73575: LD_EXP 49
73579: PUSH
73580: LD_VAR 0 2
73584: ARRAY
73585: PPUSH
73586: CALL_OW 440
73590: IFFALSE 73633
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73592: LD_ADDR_EXP 60
73596: PUSH
73597: LD_EXP 60
73601: PPUSH
73602: LD_VAR 0 2
73606: PPUSH
73607: LD_EXP 60
73611: PUSH
73612: LD_VAR 0 2
73616: ARRAY
73617: PPUSH
73618: LD_INT 1
73620: PPUSH
73621: CALL_OW 3
73625: PPUSH
73626: CALL_OW 1
73630: ST_TO_ADDR
73631: GO 73880
// begin if not mc_deposits_finder [ i ] then
73633: LD_EXP 61
73637: PUSH
73638: LD_VAR 0 2
73642: ARRAY
73643: NOT
73644: IFFALSE 73696
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73646: LD_ADDR_EXP 61
73650: PUSH
73651: LD_EXP 61
73655: PPUSH
73656: LD_VAR 0 2
73660: PPUSH
73661: LD_VAR 0 3
73665: PUSH
73666: LD_INT 1
73668: ARRAY
73669: PUSH
73670: EMPTY
73671: LIST
73672: PPUSH
73673: CALL_OW 1
73677: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73678: LD_VAR 0 3
73682: PUSH
73683: LD_INT 1
73685: ARRAY
73686: PPUSH
73687: LD_INT 125
73689: PPUSH
73690: CALL_OW 109
// end else
73694: GO 73880
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73696: LD_EXP 61
73700: PUSH
73701: LD_VAR 0 2
73705: ARRAY
73706: PUSH
73707: LD_INT 1
73709: ARRAY
73710: PPUSH
73711: CALL_OW 310
73715: IFFALSE 73738
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73717: LD_EXP 61
73721: PUSH
73722: LD_VAR 0 2
73726: ARRAY
73727: PUSH
73728: LD_INT 1
73730: ARRAY
73731: PPUSH
73732: CALL_OW 122
73736: GO 73880
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73738: LD_EXP 61
73742: PUSH
73743: LD_VAR 0 2
73747: ARRAY
73748: PUSH
73749: LD_INT 1
73751: ARRAY
73752: PPUSH
73753: CALL_OW 314
73757: NOT
73758: PUSH
73759: LD_EXP 61
73763: PUSH
73764: LD_VAR 0 2
73768: ARRAY
73769: PUSH
73770: LD_INT 1
73772: ARRAY
73773: PPUSH
73774: LD_EXP 60
73778: PUSH
73779: LD_VAR 0 2
73783: ARRAY
73784: PUSH
73785: LD_INT 1
73787: ARRAY
73788: PUSH
73789: LD_INT 1
73791: ARRAY
73792: PPUSH
73793: LD_EXP 60
73797: PUSH
73798: LD_VAR 0 2
73802: ARRAY
73803: PUSH
73804: LD_INT 1
73806: ARRAY
73807: PUSH
73808: LD_INT 2
73810: ARRAY
73811: PPUSH
73812: CALL_OW 297
73816: PUSH
73817: LD_INT 6
73819: GREATER
73820: AND
73821: IFFALSE 73880
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73823: LD_EXP 61
73827: PUSH
73828: LD_VAR 0 2
73832: ARRAY
73833: PUSH
73834: LD_INT 1
73836: ARRAY
73837: PPUSH
73838: LD_EXP 60
73842: PUSH
73843: LD_VAR 0 2
73847: ARRAY
73848: PUSH
73849: LD_INT 1
73851: ARRAY
73852: PUSH
73853: LD_INT 1
73855: ARRAY
73856: PPUSH
73857: LD_EXP 60
73861: PUSH
73862: LD_VAR 0 2
73866: ARRAY
73867: PUSH
73868: LD_INT 1
73870: ARRAY
73871: PUSH
73872: LD_INT 2
73874: ARRAY
73875: PPUSH
73876: CALL_OW 111
// end ; end ; end ;
73880: GO 73293
73882: POP
73883: POP
// end ;
73884: LD_VAR 0 1
73888: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73889: LD_INT 0
73891: PPUSH
73892: PPUSH
73893: PPUSH
73894: PPUSH
73895: PPUSH
73896: PPUSH
73897: PPUSH
73898: PPUSH
73899: PPUSH
73900: PPUSH
73901: PPUSH
// if not mc_bases then
73902: LD_EXP 23
73906: NOT
73907: IFFALSE 73911
// exit ;
73909: GO 74851
// for i = 1 to mc_bases do
73911: LD_ADDR_VAR 0 2
73915: PUSH
73916: DOUBLE
73917: LD_INT 1
73919: DEC
73920: ST_TO_ADDR
73921: LD_EXP 23
73925: PUSH
73926: FOR_TO
73927: IFFALSE 74849
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73929: LD_EXP 23
73933: PUSH
73934: LD_VAR 0 2
73938: ARRAY
73939: NOT
73940: PUSH
73941: LD_EXP 46
73945: PUSH
73946: LD_VAR 0 2
73950: ARRAY
73951: OR
73952: IFFALSE 73956
// continue ;
73954: GO 73926
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73956: LD_ADDR_VAR 0 7
73960: PUSH
73961: LD_EXP 23
73965: PUSH
73966: LD_VAR 0 2
73970: ARRAY
73971: PUSH
73972: LD_INT 1
73974: ARRAY
73975: PPUSH
73976: CALL_OW 248
73980: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73981: LD_VAR 0 7
73985: PUSH
73986: LD_INT 3
73988: EQUAL
73989: PUSH
73990: LD_EXP 42
73994: PUSH
73995: LD_VAR 0 2
73999: ARRAY
74000: PUSH
74001: LD_EXP 45
74005: PUSH
74006: LD_VAR 0 2
74010: ARRAY
74011: UNION
74012: PPUSH
74013: LD_INT 33
74015: PUSH
74016: LD_INT 2
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PPUSH
74023: CALL_OW 72
74027: NOT
74028: OR
74029: IFFALSE 74033
// continue ;
74031: GO 73926
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74033: LD_ADDR_VAR 0 9
74037: PUSH
74038: LD_EXP 23
74042: PUSH
74043: LD_VAR 0 2
74047: ARRAY
74048: PPUSH
74049: LD_INT 30
74051: PUSH
74052: LD_INT 36
74054: PUSH
74055: EMPTY
74056: LIST
74057: LIST
74058: PPUSH
74059: CALL_OW 72
74063: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74064: LD_ADDR_VAR 0 10
74068: PUSH
74069: LD_EXP 42
74073: PUSH
74074: LD_VAR 0 2
74078: ARRAY
74079: PPUSH
74080: LD_INT 34
74082: PUSH
74083: LD_INT 31
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PPUSH
74090: CALL_OW 72
74094: ST_TO_ADDR
// if not cts and not mcts then
74095: LD_VAR 0 9
74099: NOT
74100: PUSH
74101: LD_VAR 0 10
74105: NOT
74106: AND
74107: IFFALSE 74111
// continue ;
74109: GO 73926
// x := cts ;
74111: LD_ADDR_VAR 0 11
74115: PUSH
74116: LD_VAR 0 9
74120: ST_TO_ADDR
// if not x then
74121: LD_VAR 0 11
74125: NOT
74126: IFFALSE 74138
// x := mcts ;
74128: LD_ADDR_VAR 0 11
74132: PUSH
74133: LD_VAR 0 10
74137: ST_TO_ADDR
// if not x then
74138: LD_VAR 0 11
74142: NOT
74143: IFFALSE 74147
// continue ;
74145: GO 73926
// if mc_remote_driver [ i ] then
74147: LD_EXP 63
74151: PUSH
74152: LD_VAR 0 2
74156: ARRAY
74157: IFFALSE 74544
// for j in mc_remote_driver [ i ] do
74159: LD_ADDR_VAR 0 3
74163: PUSH
74164: LD_EXP 63
74168: PUSH
74169: LD_VAR 0 2
74173: ARRAY
74174: PUSH
74175: FOR_IN
74176: IFFALSE 74542
// begin if GetClass ( j ) <> 3 then
74178: LD_VAR 0 3
74182: PPUSH
74183: CALL_OW 257
74187: PUSH
74188: LD_INT 3
74190: NONEQUAL
74191: IFFALSE 74244
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74193: LD_ADDR_EXP 63
74197: PUSH
74198: LD_EXP 63
74202: PPUSH
74203: LD_VAR 0 2
74207: PPUSH
74208: LD_EXP 63
74212: PUSH
74213: LD_VAR 0 2
74217: ARRAY
74218: PUSH
74219: LD_VAR 0 3
74223: DIFF
74224: PPUSH
74225: CALL_OW 1
74229: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74230: LD_VAR 0 3
74234: PPUSH
74235: LD_INT 0
74237: PPUSH
74238: CALL_OW 109
// continue ;
74242: GO 74175
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74244: LD_EXP 42
74248: PUSH
74249: LD_VAR 0 2
74253: ARRAY
74254: PPUSH
74255: LD_INT 34
74257: PUSH
74258: LD_INT 31
74260: PUSH
74261: EMPTY
74262: LIST
74263: LIST
74264: PUSH
74265: LD_INT 58
74267: PUSH
74268: EMPTY
74269: LIST
74270: PUSH
74271: EMPTY
74272: LIST
74273: LIST
74274: PPUSH
74275: CALL_OW 72
74279: PUSH
74280: LD_VAR 0 3
74284: PPUSH
74285: CALL 46037 0 1
74289: NOT
74290: AND
74291: IFFALSE 74362
// begin if IsInUnit ( j ) then
74293: LD_VAR 0 3
74297: PPUSH
74298: CALL_OW 310
74302: IFFALSE 74313
// ComExitBuilding ( j ) ;
74304: LD_VAR 0 3
74308: PPUSH
74309: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74313: LD_VAR 0 3
74317: PPUSH
74318: LD_EXP 42
74322: PUSH
74323: LD_VAR 0 2
74327: ARRAY
74328: PPUSH
74329: LD_INT 34
74331: PUSH
74332: LD_INT 31
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: LD_INT 58
74341: PUSH
74342: EMPTY
74343: LIST
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PPUSH
74349: CALL_OW 72
74353: PUSH
74354: LD_INT 1
74356: ARRAY
74357: PPUSH
74358: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74362: LD_VAR 0 3
74366: PPUSH
74367: CALL_OW 310
74371: NOT
74372: PUSH
74373: LD_VAR 0 3
74377: PPUSH
74378: CALL_OW 310
74382: PPUSH
74383: CALL_OW 266
74387: PUSH
74388: LD_INT 36
74390: NONEQUAL
74391: PUSH
74392: LD_VAR 0 3
74396: PPUSH
74397: CALL 46037 0 1
74401: NOT
74402: AND
74403: OR
74404: IFFALSE 74540
// begin if IsInUnit ( j ) then
74406: LD_VAR 0 3
74410: PPUSH
74411: CALL_OW 310
74415: IFFALSE 74426
// ComExitBuilding ( j ) ;
74417: LD_VAR 0 3
74421: PPUSH
74422: CALL_OW 122
// ct := 0 ;
74426: LD_ADDR_VAR 0 8
74430: PUSH
74431: LD_INT 0
74433: ST_TO_ADDR
// for k in x do
74434: LD_ADDR_VAR 0 4
74438: PUSH
74439: LD_VAR 0 11
74443: PUSH
74444: FOR_IN
74445: IFFALSE 74518
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74447: LD_VAR 0 4
74451: PPUSH
74452: CALL_OW 264
74456: PUSH
74457: LD_INT 31
74459: EQUAL
74460: PUSH
74461: LD_VAR 0 4
74465: PPUSH
74466: CALL_OW 311
74470: NOT
74471: AND
74472: PUSH
74473: LD_VAR 0 4
74477: PPUSH
74478: CALL_OW 266
74482: PUSH
74483: LD_INT 36
74485: EQUAL
74486: PUSH
74487: LD_VAR 0 4
74491: PPUSH
74492: CALL_OW 313
74496: PUSH
74497: LD_INT 3
74499: LESS
74500: AND
74501: OR
74502: IFFALSE 74516
// begin ct := k ;
74504: LD_ADDR_VAR 0 8
74508: PUSH
74509: LD_VAR 0 4
74513: ST_TO_ADDR
// break ;
74514: GO 74518
// end ;
74516: GO 74444
74518: POP
74519: POP
// if ct then
74520: LD_VAR 0 8
74524: IFFALSE 74540
// ComEnterUnit ( j , ct ) ;
74526: LD_VAR 0 3
74530: PPUSH
74531: LD_VAR 0 8
74535: PPUSH
74536: CALL_OW 120
// end ; end ;
74540: GO 74175
74542: POP
74543: POP
// places := 0 ;
74544: LD_ADDR_VAR 0 5
74548: PUSH
74549: LD_INT 0
74551: ST_TO_ADDR
// for j = 1 to x do
74552: LD_ADDR_VAR 0 3
74556: PUSH
74557: DOUBLE
74558: LD_INT 1
74560: DEC
74561: ST_TO_ADDR
74562: LD_VAR 0 11
74566: PUSH
74567: FOR_TO
74568: IFFALSE 74644
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74570: LD_VAR 0 11
74574: PUSH
74575: LD_VAR 0 3
74579: ARRAY
74580: PPUSH
74581: CALL_OW 264
74585: PUSH
74586: LD_INT 31
74588: EQUAL
74589: IFFALSE 74607
// places := places + 1 else
74591: LD_ADDR_VAR 0 5
74595: PUSH
74596: LD_VAR 0 5
74600: PUSH
74601: LD_INT 1
74603: PLUS
74604: ST_TO_ADDR
74605: GO 74642
// if GetBType ( x [ j ] ) = b_control_tower then
74607: LD_VAR 0 11
74611: PUSH
74612: LD_VAR 0 3
74616: ARRAY
74617: PPUSH
74618: CALL_OW 266
74622: PUSH
74623: LD_INT 36
74625: EQUAL
74626: IFFALSE 74642
// places := places + 3 ;
74628: LD_ADDR_VAR 0 5
74632: PUSH
74633: LD_VAR 0 5
74637: PUSH
74638: LD_INT 3
74640: PLUS
74641: ST_TO_ADDR
74642: GO 74567
74644: POP
74645: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74646: LD_VAR 0 5
74650: PUSH
74651: LD_INT 0
74653: EQUAL
74654: PUSH
74655: LD_VAR 0 5
74659: PUSH
74660: LD_EXP 63
74664: PUSH
74665: LD_VAR 0 2
74669: ARRAY
74670: LESSEQUAL
74671: OR
74672: IFFALSE 74676
// continue ;
74674: GO 73926
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74676: LD_ADDR_VAR 0 6
74680: PUSH
74681: LD_EXP 23
74685: PUSH
74686: LD_VAR 0 2
74690: ARRAY
74691: PPUSH
74692: LD_INT 25
74694: PUSH
74695: LD_INT 3
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: PPUSH
74702: CALL_OW 72
74706: PUSH
74707: LD_EXP 63
74711: PUSH
74712: LD_VAR 0 2
74716: ARRAY
74717: DIFF
74718: PPUSH
74719: LD_INT 3
74721: PPUSH
74722: CALL 46937 0 2
74726: ST_TO_ADDR
// for j in tmp do
74727: LD_ADDR_VAR 0 3
74731: PUSH
74732: LD_VAR 0 6
74736: PUSH
74737: FOR_IN
74738: IFFALSE 74773
// if GetTag ( j ) > 0 then
74740: LD_VAR 0 3
74744: PPUSH
74745: CALL_OW 110
74749: PUSH
74750: LD_INT 0
74752: GREATER
74753: IFFALSE 74771
// tmp := tmp diff j ;
74755: LD_ADDR_VAR 0 6
74759: PUSH
74760: LD_VAR 0 6
74764: PUSH
74765: LD_VAR 0 3
74769: DIFF
74770: ST_TO_ADDR
74771: GO 74737
74773: POP
74774: POP
// if not tmp then
74775: LD_VAR 0 6
74779: NOT
74780: IFFALSE 74784
// continue ;
74782: GO 73926
// if places then
74784: LD_VAR 0 5
74788: IFFALSE 74847
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74790: LD_ADDR_EXP 63
74794: PUSH
74795: LD_EXP 63
74799: PPUSH
74800: LD_VAR 0 2
74804: PPUSH
74805: LD_EXP 63
74809: PUSH
74810: LD_VAR 0 2
74814: ARRAY
74815: PUSH
74816: LD_VAR 0 6
74820: PUSH
74821: LD_INT 1
74823: ARRAY
74824: UNION
74825: PPUSH
74826: CALL_OW 1
74830: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74831: LD_VAR 0 6
74835: PUSH
74836: LD_INT 1
74838: ARRAY
74839: PPUSH
74840: LD_INT 126
74842: PPUSH
74843: CALL_OW 109
// end ; end ;
74847: GO 73926
74849: POP
74850: POP
// end ;
74851: LD_VAR 0 1
74855: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74856: LD_INT 0
74858: PPUSH
74859: PPUSH
74860: PPUSH
74861: PPUSH
74862: PPUSH
74863: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74864: LD_VAR 0 1
74868: NOT
74869: PUSH
74870: LD_VAR 0 2
74874: NOT
74875: OR
74876: PUSH
74877: LD_VAR 0 3
74881: NOT
74882: OR
74883: PUSH
74884: LD_VAR 0 4
74888: PUSH
74889: LD_INT 1
74891: PUSH
74892: LD_INT 2
74894: PUSH
74895: LD_INT 3
74897: PUSH
74898: LD_INT 4
74900: PUSH
74901: LD_INT 5
74903: PUSH
74904: LD_INT 8
74906: PUSH
74907: LD_INT 9
74909: PUSH
74910: LD_INT 15
74912: PUSH
74913: LD_INT 16
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: LIST
74925: LIST
74926: IN
74927: NOT
74928: OR
74929: IFFALSE 74933
// exit ;
74931: GO 75833
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74933: LD_ADDR_VAR 0 2
74937: PUSH
74938: LD_VAR 0 2
74942: PPUSH
74943: LD_INT 21
74945: PUSH
74946: LD_INT 3
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: PUSH
74953: LD_INT 24
74955: PUSH
74956: LD_INT 250
74958: PUSH
74959: EMPTY
74960: LIST
74961: LIST
74962: PUSH
74963: EMPTY
74964: LIST
74965: LIST
74966: PPUSH
74967: CALL_OW 72
74971: ST_TO_ADDR
// case class of 1 , 15 :
74972: LD_VAR 0 4
74976: PUSH
74977: LD_INT 1
74979: DOUBLE
74980: EQUAL
74981: IFTRUE 74991
74983: LD_INT 15
74985: DOUBLE
74986: EQUAL
74987: IFTRUE 74991
74989: GO 75076
74991: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74992: LD_ADDR_VAR 0 8
74996: PUSH
74997: LD_VAR 0 2
75001: PPUSH
75002: LD_INT 2
75004: PUSH
75005: LD_INT 30
75007: PUSH
75008: LD_INT 32
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PUSH
75015: LD_INT 30
75017: PUSH
75018: LD_INT 31
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PUSH
75025: EMPTY
75026: LIST
75027: LIST
75028: LIST
75029: PPUSH
75030: CALL_OW 72
75034: PUSH
75035: LD_VAR 0 2
75039: PPUSH
75040: LD_INT 2
75042: PUSH
75043: LD_INT 30
75045: PUSH
75046: LD_INT 4
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 30
75055: PUSH
75056: LD_INT 5
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: LIST
75067: PPUSH
75068: CALL_OW 72
75072: ADD
75073: ST_TO_ADDR
75074: GO 75322
75076: LD_INT 2
75078: DOUBLE
75079: EQUAL
75080: IFTRUE 75090
75082: LD_INT 16
75084: DOUBLE
75085: EQUAL
75086: IFTRUE 75090
75088: GO 75136
75090: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75091: LD_ADDR_VAR 0 8
75095: PUSH
75096: LD_VAR 0 2
75100: PPUSH
75101: LD_INT 2
75103: PUSH
75104: LD_INT 30
75106: PUSH
75107: LD_INT 0
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PUSH
75114: LD_INT 30
75116: PUSH
75117: LD_INT 1
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: LIST
75128: PPUSH
75129: CALL_OW 72
75133: ST_TO_ADDR
75134: GO 75322
75136: LD_INT 3
75138: DOUBLE
75139: EQUAL
75140: IFTRUE 75144
75142: GO 75190
75144: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75145: LD_ADDR_VAR 0 8
75149: PUSH
75150: LD_VAR 0 2
75154: PPUSH
75155: LD_INT 2
75157: PUSH
75158: LD_INT 30
75160: PUSH
75161: LD_INT 2
75163: PUSH
75164: EMPTY
75165: LIST
75166: LIST
75167: PUSH
75168: LD_INT 30
75170: PUSH
75171: LD_INT 3
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: LIST
75182: PPUSH
75183: CALL_OW 72
75187: ST_TO_ADDR
75188: GO 75322
75190: LD_INT 4
75192: DOUBLE
75193: EQUAL
75194: IFTRUE 75198
75196: GO 75255
75198: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75199: LD_ADDR_VAR 0 8
75203: PUSH
75204: LD_VAR 0 2
75208: PPUSH
75209: LD_INT 2
75211: PUSH
75212: LD_INT 30
75214: PUSH
75215: LD_INT 6
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: LD_INT 30
75224: PUSH
75225: LD_INT 7
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 30
75234: PUSH
75235: LD_INT 8
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: EMPTY
75243: LIST
75244: LIST
75245: LIST
75246: LIST
75247: PPUSH
75248: CALL_OW 72
75252: ST_TO_ADDR
75253: GO 75322
75255: LD_INT 5
75257: DOUBLE
75258: EQUAL
75259: IFTRUE 75275
75261: LD_INT 8
75263: DOUBLE
75264: EQUAL
75265: IFTRUE 75275
75267: LD_INT 9
75269: DOUBLE
75270: EQUAL
75271: IFTRUE 75275
75273: GO 75321
75275: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75276: LD_ADDR_VAR 0 8
75280: PUSH
75281: LD_VAR 0 2
75285: PPUSH
75286: LD_INT 2
75288: PUSH
75289: LD_INT 30
75291: PUSH
75292: LD_INT 4
75294: PUSH
75295: EMPTY
75296: LIST
75297: LIST
75298: PUSH
75299: LD_INT 30
75301: PUSH
75302: LD_INT 5
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: LIST
75313: PPUSH
75314: CALL_OW 72
75318: ST_TO_ADDR
75319: GO 75322
75321: POP
// if not tmp then
75322: LD_VAR 0 8
75326: NOT
75327: IFFALSE 75331
// exit ;
75329: GO 75833
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75331: LD_VAR 0 4
75335: PUSH
75336: LD_INT 1
75338: PUSH
75339: LD_INT 15
75341: PUSH
75342: EMPTY
75343: LIST
75344: LIST
75345: IN
75346: PUSH
75347: LD_EXP 32
75351: PUSH
75352: LD_VAR 0 1
75356: ARRAY
75357: AND
75358: IFFALSE 75514
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75360: LD_ADDR_VAR 0 9
75364: PUSH
75365: LD_EXP 32
75369: PUSH
75370: LD_VAR 0 1
75374: ARRAY
75375: PUSH
75376: LD_INT 1
75378: ARRAY
75379: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75380: LD_VAR 0 9
75384: PUSH
75385: LD_EXP 33
75389: PUSH
75390: LD_VAR 0 1
75394: ARRAY
75395: IN
75396: NOT
75397: IFFALSE 75512
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75399: LD_ADDR_EXP 33
75403: PUSH
75404: LD_EXP 33
75408: PPUSH
75409: LD_VAR 0 1
75413: PUSH
75414: LD_EXP 33
75418: PUSH
75419: LD_VAR 0 1
75423: ARRAY
75424: PUSH
75425: LD_INT 1
75427: PLUS
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PPUSH
75433: LD_VAR 0 9
75437: PPUSH
75438: CALL 16166 0 3
75442: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75443: LD_ADDR_EXP 32
75447: PUSH
75448: LD_EXP 32
75452: PPUSH
75453: LD_VAR 0 1
75457: PPUSH
75458: LD_EXP 32
75462: PUSH
75463: LD_VAR 0 1
75467: ARRAY
75468: PUSH
75469: LD_VAR 0 9
75473: DIFF
75474: PPUSH
75475: CALL_OW 1
75479: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75480: LD_VAR 0 3
75484: PPUSH
75485: LD_EXP 33
75489: PUSH
75490: LD_VAR 0 1
75494: ARRAY
75495: PUSH
75496: LD_EXP 33
75500: PUSH
75501: LD_VAR 0 1
75505: ARRAY
75506: ARRAY
75507: PPUSH
75508: CALL_OW 120
// end ; exit ;
75512: GO 75833
// end ; if tmp > 1 then
75514: LD_VAR 0 8
75518: PUSH
75519: LD_INT 1
75521: GREATER
75522: IFFALSE 75626
// for i = 2 to tmp do
75524: LD_ADDR_VAR 0 6
75528: PUSH
75529: DOUBLE
75530: LD_INT 2
75532: DEC
75533: ST_TO_ADDR
75534: LD_VAR 0 8
75538: PUSH
75539: FOR_TO
75540: IFFALSE 75624
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75542: LD_VAR 0 8
75546: PUSH
75547: LD_VAR 0 6
75551: ARRAY
75552: PPUSH
75553: CALL_OW 461
75557: PUSH
75558: LD_INT 6
75560: EQUAL
75561: IFFALSE 75622
// begin x := tmp [ i ] ;
75563: LD_ADDR_VAR 0 9
75567: PUSH
75568: LD_VAR 0 8
75572: PUSH
75573: LD_VAR 0 6
75577: ARRAY
75578: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75579: LD_ADDR_VAR 0 8
75583: PUSH
75584: LD_VAR 0 8
75588: PPUSH
75589: LD_VAR 0 6
75593: PPUSH
75594: CALL_OW 3
75598: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75599: LD_ADDR_VAR 0 8
75603: PUSH
75604: LD_VAR 0 8
75608: PPUSH
75609: LD_INT 1
75611: PPUSH
75612: LD_VAR 0 9
75616: PPUSH
75617: CALL_OW 2
75621: ST_TO_ADDR
// end ;
75622: GO 75539
75624: POP
75625: POP
// for i in tmp do
75626: LD_ADDR_VAR 0 6
75630: PUSH
75631: LD_VAR 0 8
75635: PUSH
75636: FOR_IN
75637: IFFALSE 75706
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75639: LD_VAR 0 6
75643: PPUSH
75644: CALL_OW 313
75648: PUSH
75649: LD_INT 6
75651: LESS
75652: PUSH
75653: LD_VAR 0 6
75657: PPUSH
75658: CALL_OW 266
75662: PUSH
75663: LD_INT 31
75665: PUSH
75666: LD_INT 32
75668: PUSH
75669: EMPTY
75670: LIST
75671: LIST
75672: IN
75673: NOT
75674: AND
75675: PUSH
75676: LD_VAR 0 6
75680: PPUSH
75681: CALL_OW 313
75685: PUSH
75686: LD_INT 0
75688: EQUAL
75689: OR
75690: IFFALSE 75704
// begin j := i ;
75692: LD_ADDR_VAR 0 7
75696: PUSH
75697: LD_VAR 0 6
75701: ST_TO_ADDR
// break ;
75702: GO 75706
// end ; end ;
75704: GO 75636
75706: POP
75707: POP
// if j then
75708: LD_VAR 0 7
75712: IFFALSE 75730
// ComEnterUnit ( unit , j ) else
75714: LD_VAR 0 3
75718: PPUSH
75719: LD_VAR 0 7
75723: PPUSH
75724: CALL_OW 120
75728: GO 75833
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75730: LD_ADDR_VAR 0 10
75734: PUSH
75735: LD_VAR 0 2
75739: PPUSH
75740: LD_INT 2
75742: PUSH
75743: LD_INT 30
75745: PUSH
75746: LD_INT 0
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: LD_INT 30
75755: PUSH
75756: LD_INT 1
75758: PUSH
75759: EMPTY
75760: LIST
75761: LIST
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: LIST
75767: PPUSH
75768: CALL_OW 72
75772: ST_TO_ADDR
// if depot then
75773: LD_VAR 0 10
75777: IFFALSE 75833
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75779: LD_ADDR_VAR 0 10
75783: PUSH
75784: LD_VAR 0 10
75788: PPUSH
75789: LD_VAR 0 3
75793: PPUSH
75794: CALL_OW 74
75798: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75799: LD_VAR 0 3
75803: PPUSH
75804: LD_VAR 0 10
75808: PPUSH
75809: CALL_OW 296
75813: PUSH
75814: LD_INT 10
75816: GREATER
75817: IFFALSE 75833
// ComStandNearbyBuilding ( unit , depot ) ;
75819: LD_VAR 0 3
75823: PPUSH
75824: LD_VAR 0 10
75828: PPUSH
75829: CALL 12591 0 2
// end ; end ; end ;
75833: LD_VAR 0 5
75837: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
75838: LD_INT 0
75840: PPUSH
75841: PPUSH
75842: PPUSH
75843: PPUSH
// if not mc_bases then
75844: LD_EXP 23
75848: NOT
75849: IFFALSE 75853
// exit ;
75851: GO 76092
// for i = 1 to mc_bases do
75853: LD_ADDR_VAR 0 2
75857: PUSH
75858: DOUBLE
75859: LD_INT 1
75861: DEC
75862: ST_TO_ADDR
75863: LD_EXP 23
75867: PUSH
75868: FOR_TO
75869: IFFALSE 76090
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75871: LD_ADDR_VAR 0 4
75875: PUSH
75876: LD_EXP 23
75880: PUSH
75881: LD_VAR 0 2
75885: ARRAY
75886: PPUSH
75887: LD_INT 21
75889: PUSH
75890: LD_INT 1
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PPUSH
75897: CALL_OW 72
75901: PUSH
75902: LD_EXP 52
75906: PUSH
75907: LD_VAR 0 2
75911: ARRAY
75912: UNION
75913: ST_TO_ADDR
// if not tmp then
75914: LD_VAR 0 4
75918: NOT
75919: IFFALSE 75923
// continue ;
75921: GO 75868
// for j in tmp do
75923: LD_ADDR_VAR 0 3
75927: PUSH
75928: LD_VAR 0 4
75932: PUSH
75933: FOR_IN
75934: IFFALSE 76086
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75936: LD_VAR 0 3
75940: PPUSH
75941: CALL_OW 110
75945: NOT
75946: PUSH
75947: LD_VAR 0 3
75951: PPUSH
75952: CALL_OW 314
75956: NOT
75957: AND
75958: PUSH
75959: LD_VAR 0 3
75963: PPUSH
75964: CALL_OW 311
75968: NOT
75969: AND
75970: PUSH
75971: LD_VAR 0 3
75975: PPUSH
75976: CALL_OW 310
75980: NOT
75981: AND
75982: PUSH
75983: LD_VAR 0 3
75987: PUSH
75988: LD_EXP 26
75992: PUSH
75993: LD_VAR 0 2
75997: ARRAY
75998: PUSH
75999: LD_INT 1
76001: ARRAY
76002: IN
76003: NOT
76004: AND
76005: PUSH
76006: LD_VAR 0 3
76010: PUSH
76011: LD_EXP 26
76015: PUSH
76016: LD_VAR 0 2
76020: ARRAY
76021: PUSH
76022: LD_INT 2
76024: ARRAY
76025: IN
76026: NOT
76027: AND
76028: PUSH
76029: LD_VAR 0 3
76033: PUSH
76034: LD_EXP 35
76038: PUSH
76039: LD_VAR 0 2
76043: ARRAY
76044: IN
76045: NOT
76046: AND
76047: IFFALSE 76084
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76049: LD_VAR 0 2
76053: PPUSH
76054: LD_EXP 23
76058: PUSH
76059: LD_VAR 0 2
76063: ARRAY
76064: PPUSH
76065: LD_VAR 0 3
76069: PPUSH
76070: LD_VAR 0 3
76074: PPUSH
76075: CALL_OW 257
76079: PPUSH
76080: CALL 74856 0 4
// end ;
76084: GO 75933
76086: POP
76087: POP
// end ;
76088: GO 75868
76090: POP
76091: POP
// end ;
76092: LD_VAR 0 1
76096: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76097: LD_INT 0
76099: PPUSH
76100: PPUSH
76101: PPUSH
76102: PPUSH
76103: PPUSH
76104: PPUSH
// if not mc_bases [ base ] then
76105: LD_EXP 23
76109: PUSH
76110: LD_VAR 0 1
76114: ARRAY
76115: NOT
76116: IFFALSE 76120
// exit ;
76118: GO 76302
// tmp := [ ] ;
76120: LD_ADDR_VAR 0 6
76124: PUSH
76125: EMPTY
76126: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76127: LD_ADDR_VAR 0 7
76131: PUSH
76132: LD_VAR 0 3
76136: PPUSH
76137: LD_INT 0
76139: PPUSH
76140: CALL_OW 517
76144: ST_TO_ADDR
// if not list then
76145: LD_VAR 0 7
76149: NOT
76150: IFFALSE 76154
// exit ;
76152: GO 76302
// for i = 1 to amount do
76154: LD_ADDR_VAR 0 5
76158: PUSH
76159: DOUBLE
76160: LD_INT 1
76162: DEC
76163: ST_TO_ADDR
76164: LD_VAR 0 2
76168: PUSH
76169: FOR_TO
76170: IFFALSE 76250
// begin x := rand ( 1 , list [ 1 ] ) ;
76172: LD_ADDR_VAR 0 8
76176: PUSH
76177: LD_INT 1
76179: PPUSH
76180: LD_VAR 0 7
76184: PUSH
76185: LD_INT 1
76187: ARRAY
76188: PPUSH
76189: CALL_OW 12
76193: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76194: LD_ADDR_VAR 0 6
76198: PUSH
76199: LD_VAR 0 6
76203: PPUSH
76204: LD_VAR 0 5
76208: PPUSH
76209: LD_VAR 0 7
76213: PUSH
76214: LD_INT 1
76216: ARRAY
76217: PUSH
76218: LD_VAR 0 8
76222: ARRAY
76223: PUSH
76224: LD_VAR 0 7
76228: PUSH
76229: LD_INT 2
76231: ARRAY
76232: PUSH
76233: LD_VAR 0 8
76237: ARRAY
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: PPUSH
76243: CALL_OW 1
76247: ST_TO_ADDR
// end ;
76248: GO 76169
76250: POP
76251: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76252: LD_ADDR_EXP 36
76256: PUSH
76257: LD_EXP 36
76261: PPUSH
76262: LD_VAR 0 1
76266: PPUSH
76267: LD_VAR 0 6
76271: PPUSH
76272: CALL_OW 1
76276: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76277: LD_ADDR_EXP 38
76281: PUSH
76282: LD_EXP 38
76286: PPUSH
76287: LD_VAR 0 1
76291: PPUSH
76292: LD_VAR 0 3
76296: PPUSH
76297: CALL_OW 1
76301: ST_TO_ADDR
// end ;
76302: LD_VAR 0 4
76306: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76307: LD_INT 0
76309: PPUSH
// if not mc_bases [ base ] then
76310: LD_EXP 23
76314: PUSH
76315: LD_VAR 0 1
76319: ARRAY
76320: NOT
76321: IFFALSE 76325
// exit ;
76323: GO 76350
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76325: LD_ADDR_EXP 28
76329: PUSH
76330: LD_EXP 28
76334: PPUSH
76335: LD_VAR 0 1
76339: PPUSH
76340: LD_VAR 0 2
76344: PPUSH
76345: CALL_OW 1
76349: ST_TO_ADDR
// end ;
76350: LD_VAR 0 3
76354: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76355: LD_INT 0
76357: PPUSH
// if not mc_bases [ base ] then
76358: LD_EXP 23
76362: PUSH
76363: LD_VAR 0 1
76367: ARRAY
76368: NOT
76369: IFFALSE 76373
// exit ;
76371: GO 76410
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76373: LD_ADDR_EXP 28
76377: PUSH
76378: LD_EXP 28
76382: PPUSH
76383: LD_VAR 0 1
76387: PPUSH
76388: LD_EXP 28
76392: PUSH
76393: LD_VAR 0 1
76397: ARRAY
76398: PUSH
76399: LD_VAR 0 2
76403: UNION
76404: PPUSH
76405: CALL_OW 1
76409: ST_TO_ADDR
// end ;
76410: LD_VAR 0 3
76414: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76415: LD_INT 0
76417: PPUSH
// if not mc_bases [ base ] then
76418: LD_EXP 23
76422: PUSH
76423: LD_VAR 0 1
76427: ARRAY
76428: NOT
76429: IFFALSE 76433
// exit ;
76431: GO 76458
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76433: LD_ADDR_EXP 44
76437: PUSH
76438: LD_EXP 44
76442: PPUSH
76443: LD_VAR 0 1
76447: PPUSH
76448: LD_VAR 0 2
76452: PPUSH
76453: CALL_OW 1
76457: ST_TO_ADDR
// end ;
76458: LD_VAR 0 3
76462: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76463: LD_INT 0
76465: PPUSH
// if not mc_bases [ base ] then
76466: LD_EXP 23
76470: PUSH
76471: LD_VAR 0 1
76475: ARRAY
76476: NOT
76477: IFFALSE 76481
// exit ;
76479: GO 76518
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76481: LD_ADDR_EXP 44
76485: PUSH
76486: LD_EXP 44
76490: PPUSH
76491: LD_VAR 0 1
76495: PPUSH
76496: LD_EXP 44
76500: PUSH
76501: LD_VAR 0 1
76505: ARRAY
76506: PUSH
76507: LD_VAR 0 2
76511: ADD
76512: PPUSH
76513: CALL_OW 1
76517: ST_TO_ADDR
// end ;
76518: LD_VAR 0 3
76522: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76523: LD_INT 0
76525: PPUSH
// if not mc_bases [ base ] then
76526: LD_EXP 23
76530: PUSH
76531: LD_VAR 0 1
76535: ARRAY
76536: NOT
76537: IFFALSE 76541
// exit ;
76539: GO 76595
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76541: LD_ADDR_EXP 45
76545: PUSH
76546: LD_EXP 45
76550: PPUSH
76551: LD_VAR 0 1
76555: PPUSH
76556: LD_VAR 0 2
76560: PPUSH
76561: CALL_OW 1
76565: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76566: LD_ADDR_EXP 34
76570: PUSH
76571: LD_EXP 34
76575: PPUSH
76576: LD_VAR 0 1
76580: PPUSH
76581: LD_VAR 0 2
76585: PUSH
76586: LD_INT 0
76588: PLUS
76589: PPUSH
76590: CALL_OW 1
76594: ST_TO_ADDR
// end ;
76595: LD_VAR 0 3
76599: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76600: LD_INT 0
76602: PPUSH
// if not mc_bases [ base ] then
76603: LD_EXP 23
76607: PUSH
76608: LD_VAR 0 1
76612: ARRAY
76613: NOT
76614: IFFALSE 76618
// exit ;
76616: GO 76643
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76618: LD_ADDR_EXP 34
76622: PUSH
76623: LD_EXP 34
76627: PPUSH
76628: LD_VAR 0 1
76632: PPUSH
76633: LD_VAR 0 2
76637: PPUSH
76638: CALL_OW 1
76642: ST_TO_ADDR
// end ;
76643: LD_VAR 0 3
76647: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76648: LD_INT 0
76650: PPUSH
76651: PPUSH
76652: PPUSH
76653: PPUSH
// if not mc_bases [ base ] then
76654: LD_EXP 23
76658: PUSH
76659: LD_VAR 0 1
76663: ARRAY
76664: NOT
76665: IFFALSE 76669
// exit ;
76667: GO 76734
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76669: LD_ADDR_EXP 43
76673: PUSH
76674: LD_EXP 43
76678: PPUSH
76679: LD_VAR 0 1
76683: PUSH
76684: LD_EXP 43
76688: PUSH
76689: LD_VAR 0 1
76693: ARRAY
76694: PUSH
76695: LD_INT 1
76697: PLUS
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PPUSH
76703: LD_VAR 0 1
76707: PUSH
76708: LD_VAR 0 2
76712: PUSH
76713: LD_VAR 0 3
76717: PUSH
76718: LD_VAR 0 4
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: LIST
76727: LIST
76728: PPUSH
76729: CALL 16166 0 3
76733: ST_TO_ADDR
// end ;
76734: LD_VAR 0 5
76738: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76739: LD_INT 0
76741: PPUSH
// if not mc_bases [ base ] then
76742: LD_EXP 23
76746: PUSH
76747: LD_VAR 0 1
76751: ARRAY
76752: NOT
76753: IFFALSE 76757
// exit ;
76755: GO 76782
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76757: LD_ADDR_EXP 60
76761: PUSH
76762: LD_EXP 60
76766: PPUSH
76767: LD_VAR 0 1
76771: PPUSH
76772: LD_VAR 0 2
76776: PPUSH
76777: CALL_OW 1
76781: ST_TO_ADDR
// end ;
76782: LD_VAR 0 3
76786: RET
// export function MC_GetMinesField ( base ) ; begin
76787: LD_INT 0
76789: PPUSH
// result := mc_mines [ base ] ;
76790: LD_ADDR_VAR 0 2
76794: PUSH
76795: LD_EXP 36
76799: PUSH
76800: LD_VAR 0 1
76804: ARRAY
76805: ST_TO_ADDR
// end ;
76806: LD_VAR 0 2
76810: RET
// export function MC_GetProduceList ( base ) ; begin
76811: LD_INT 0
76813: PPUSH
// result := mc_produce [ base ] ;
76814: LD_ADDR_VAR 0 2
76818: PUSH
76819: LD_EXP 44
76823: PUSH
76824: LD_VAR 0 1
76828: ARRAY
76829: ST_TO_ADDR
// end ;
76830: LD_VAR 0 2
76834: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76835: LD_INT 0
76837: PPUSH
76838: PPUSH
// if not mc_bases then
76839: LD_EXP 23
76843: NOT
76844: IFFALSE 76848
// exit ;
76846: GO 76913
// if mc_bases [ base ] then
76848: LD_EXP 23
76852: PUSH
76853: LD_VAR 0 1
76857: ARRAY
76858: IFFALSE 76913
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76860: LD_ADDR_VAR 0 3
76864: PUSH
76865: LD_EXP 23
76869: PUSH
76870: LD_VAR 0 1
76874: ARRAY
76875: PPUSH
76876: LD_INT 30
76878: PUSH
76879: LD_VAR 0 2
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: PPUSH
76888: CALL_OW 72
76892: ST_TO_ADDR
// if result then
76893: LD_VAR 0 3
76897: IFFALSE 76913
// result := result [ 1 ] ;
76899: LD_ADDR_VAR 0 3
76903: PUSH
76904: LD_VAR 0 3
76908: PUSH
76909: LD_INT 1
76911: ARRAY
76912: ST_TO_ADDR
// end ; end ;
76913: LD_VAR 0 3
76917: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76918: LD_INT 0
76920: PPUSH
76921: PPUSH
// if not mc_bases then
76922: LD_EXP 23
76926: NOT
76927: IFFALSE 76931
// exit ;
76929: GO 76976
// if mc_bases [ base ] then
76931: LD_EXP 23
76935: PUSH
76936: LD_VAR 0 1
76940: ARRAY
76941: IFFALSE 76976
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76943: LD_ADDR_VAR 0 3
76947: PUSH
76948: LD_EXP 23
76952: PUSH
76953: LD_VAR 0 1
76957: ARRAY
76958: PPUSH
76959: LD_INT 30
76961: PUSH
76962: LD_VAR 0 2
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PPUSH
76971: CALL_OW 72
76975: ST_TO_ADDR
// end ;
76976: LD_VAR 0 3
76980: RET
// export function MC_SetTame ( base , area ) ; begin
76981: LD_INT 0
76983: PPUSH
// if not mc_bases or not base then
76984: LD_EXP 23
76988: NOT
76989: PUSH
76990: LD_VAR 0 1
76994: NOT
76995: OR
76996: IFFALSE 77000
// exit ;
76998: GO 77025
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77000: LD_ADDR_EXP 51
77004: PUSH
77005: LD_EXP 51
77009: PPUSH
77010: LD_VAR 0 1
77014: PPUSH
77015: LD_VAR 0 2
77019: PPUSH
77020: CALL_OW 1
77024: ST_TO_ADDR
// end ;
77025: LD_VAR 0 3
77029: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77030: LD_INT 0
77032: PPUSH
77033: PPUSH
// if not mc_bases or not base then
77034: LD_EXP 23
77038: NOT
77039: PUSH
77040: LD_VAR 0 1
77044: NOT
77045: OR
77046: IFFALSE 77050
// exit ;
77048: GO 77152
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77050: LD_ADDR_VAR 0 4
77054: PUSH
77055: LD_EXP 23
77059: PUSH
77060: LD_VAR 0 1
77064: ARRAY
77065: PPUSH
77066: LD_INT 30
77068: PUSH
77069: LD_VAR 0 2
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PPUSH
77078: CALL_OW 72
77082: ST_TO_ADDR
// if not tmp then
77083: LD_VAR 0 4
77087: NOT
77088: IFFALSE 77092
// exit ;
77090: GO 77152
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77092: LD_ADDR_EXP 55
77096: PUSH
77097: LD_EXP 55
77101: PPUSH
77102: LD_VAR 0 1
77106: PPUSH
77107: LD_EXP 55
77111: PUSH
77112: LD_VAR 0 1
77116: ARRAY
77117: PPUSH
77118: LD_EXP 55
77122: PUSH
77123: LD_VAR 0 1
77127: ARRAY
77128: PUSH
77129: LD_INT 1
77131: PLUS
77132: PPUSH
77133: LD_VAR 0 4
77137: PUSH
77138: LD_INT 1
77140: ARRAY
77141: PPUSH
77142: CALL_OW 2
77146: PPUSH
77147: CALL_OW 1
77151: ST_TO_ADDR
// end ;
77152: LD_VAR 0 3
77156: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77157: LD_INT 0
77159: PPUSH
77160: PPUSH
// if not mc_bases or not base or not kinds then
77161: LD_EXP 23
77165: NOT
77166: PUSH
77167: LD_VAR 0 1
77171: NOT
77172: OR
77173: PUSH
77174: LD_VAR 0 2
77178: NOT
77179: OR
77180: IFFALSE 77184
// exit ;
77182: GO 77245
// for i in kinds do
77184: LD_ADDR_VAR 0 4
77188: PUSH
77189: LD_VAR 0 2
77193: PUSH
77194: FOR_IN
77195: IFFALSE 77243
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77197: LD_ADDR_EXP 57
77201: PUSH
77202: LD_EXP 57
77206: PPUSH
77207: LD_VAR 0 1
77211: PUSH
77212: LD_EXP 57
77216: PUSH
77217: LD_VAR 0 1
77221: ARRAY
77222: PUSH
77223: LD_INT 1
77225: PLUS
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PPUSH
77231: LD_VAR 0 4
77235: PPUSH
77236: CALL 16166 0 3
77240: ST_TO_ADDR
77241: GO 77194
77243: POP
77244: POP
// end ;
77245: LD_VAR 0 3
77249: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77250: LD_INT 0
77252: PPUSH
// if not mc_bases or not base or not areas then
77253: LD_EXP 23
77257: NOT
77258: PUSH
77259: LD_VAR 0 1
77263: NOT
77264: OR
77265: PUSH
77266: LD_VAR 0 2
77270: NOT
77271: OR
77272: IFFALSE 77276
// exit ;
77274: GO 77301
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77276: LD_ADDR_EXP 41
77280: PUSH
77281: LD_EXP 41
77285: PPUSH
77286: LD_VAR 0 1
77290: PPUSH
77291: LD_VAR 0 2
77295: PPUSH
77296: CALL_OW 1
77300: ST_TO_ADDR
// end ;
77301: LD_VAR 0 3
77305: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77306: LD_INT 0
77308: PPUSH
// if not mc_bases or not base or not teleports_exit then
77309: LD_EXP 23
77313: NOT
77314: PUSH
77315: LD_VAR 0 1
77319: NOT
77320: OR
77321: PUSH
77322: LD_VAR 0 2
77326: NOT
77327: OR
77328: IFFALSE 77332
// exit ;
77330: GO 77357
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77332: LD_ADDR_EXP 58
77336: PUSH
77337: LD_EXP 58
77341: PPUSH
77342: LD_VAR 0 1
77346: PPUSH
77347: LD_VAR 0 2
77351: PPUSH
77352: CALL_OW 1
77356: ST_TO_ADDR
// end ;
77357: LD_VAR 0 3
77361: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77362: LD_INT 0
77364: PPUSH
77365: PPUSH
77366: PPUSH
// if not mc_bases or not base or not ext_list then
77367: LD_EXP 23
77371: NOT
77372: PUSH
77373: LD_VAR 0 1
77377: NOT
77378: OR
77379: PUSH
77380: LD_VAR 0 5
77384: NOT
77385: OR
77386: IFFALSE 77390
// exit ;
77388: GO 77563
// tmp := GetFacExtXYD ( x , y , d ) ;
77390: LD_ADDR_VAR 0 8
77394: PUSH
77395: LD_VAR 0 2
77399: PPUSH
77400: LD_VAR 0 3
77404: PPUSH
77405: LD_VAR 0 4
77409: PPUSH
77410: CALL 46067 0 3
77414: ST_TO_ADDR
// if not tmp then
77415: LD_VAR 0 8
77419: NOT
77420: IFFALSE 77424
// exit ;
77422: GO 77563
// for i in tmp do
77424: LD_ADDR_VAR 0 7
77428: PUSH
77429: LD_VAR 0 8
77433: PUSH
77434: FOR_IN
77435: IFFALSE 77561
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77437: LD_ADDR_EXP 28
77441: PUSH
77442: LD_EXP 28
77446: PPUSH
77447: LD_VAR 0 1
77451: PPUSH
77452: LD_EXP 28
77456: PUSH
77457: LD_VAR 0 1
77461: ARRAY
77462: PPUSH
77463: LD_EXP 28
77467: PUSH
77468: LD_VAR 0 1
77472: ARRAY
77473: PUSH
77474: LD_INT 1
77476: PLUS
77477: PPUSH
77478: LD_VAR 0 5
77482: PUSH
77483: LD_INT 1
77485: ARRAY
77486: PUSH
77487: LD_VAR 0 7
77491: PUSH
77492: LD_INT 1
77494: ARRAY
77495: PUSH
77496: LD_VAR 0 7
77500: PUSH
77501: LD_INT 2
77503: ARRAY
77504: PUSH
77505: LD_VAR 0 7
77509: PUSH
77510: LD_INT 3
77512: ARRAY
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: PPUSH
77520: CALL_OW 2
77524: PPUSH
77525: CALL_OW 1
77529: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77530: LD_ADDR_VAR 0 5
77534: PUSH
77535: LD_VAR 0 5
77539: PPUSH
77540: LD_INT 1
77542: PPUSH
77543: CALL_OW 3
77547: ST_TO_ADDR
// if not ext_list then
77548: LD_VAR 0 5
77552: NOT
77553: IFFALSE 77559
// exit ;
77555: POP
77556: POP
77557: GO 77563
// end ;
77559: GO 77434
77561: POP
77562: POP
// end ;
77563: LD_VAR 0 6
77567: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77568: LD_INT 0
77570: PPUSH
// if not mc_bases or not base or not weapon_list then
77571: LD_EXP 23
77575: NOT
77576: PUSH
77577: LD_VAR 0 1
77581: NOT
77582: OR
77583: PUSH
77584: LD_VAR 0 2
77588: NOT
77589: OR
77590: IFFALSE 77594
// exit ;
77592: GO 77619
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77594: LD_ADDR_EXP 62
77598: PUSH
77599: LD_EXP 62
77603: PPUSH
77604: LD_VAR 0 1
77608: PPUSH
77609: LD_VAR 0 2
77613: PPUSH
77614: CALL_OW 1
77618: ST_TO_ADDR
// end ;
77619: LD_VAR 0 3
77623: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77624: LD_INT 0
77626: PPUSH
// if not mc_bases or not base or not tech_list then
77627: LD_EXP 23
77631: NOT
77632: PUSH
77633: LD_VAR 0 1
77637: NOT
77638: OR
77639: PUSH
77640: LD_VAR 0 2
77644: NOT
77645: OR
77646: IFFALSE 77650
// exit ;
77648: GO 77675
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77650: LD_ADDR_EXP 50
77654: PUSH
77655: LD_EXP 50
77659: PPUSH
77660: LD_VAR 0 1
77664: PPUSH
77665: LD_VAR 0 2
77669: PPUSH
77670: CALL_OW 1
77674: ST_TO_ADDR
// end ;
77675: LD_VAR 0 3
77679: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77680: LD_INT 0
77682: PPUSH
// if not mc_bases or not parking_area or not base then
77683: LD_EXP 23
77687: NOT
77688: PUSH
77689: LD_VAR 0 2
77693: NOT
77694: OR
77695: PUSH
77696: LD_VAR 0 1
77700: NOT
77701: OR
77702: IFFALSE 77706
// exit ;
77704: GO 77731
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77706: LD_ADDR_EXP 47
77710: PUSH
77711: LD_EXP 47
77715: PPUSH
77716: LD_VAR 0 1
77720: PPUSH
77721: LD_VAR 0 2
77725: PPUSH
77726: CALL_OW 1
77730: ST_TO_ADDR
// end ;
77731: LD_VAR 0 3
77735: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77736: LD_INT 0
77738: PPUSH
// if not mc_bases or not base or not scan_area then
77739: LD_EXP 23
77743: NOT
77744: PUSH
77745: LD_VAR 0 1
77749: NOT
77750: OR
77751: PUSH
77752: LD_VAR 0 2
77756: NOT
77757: OR
77758: IFFALSE 77762
// exit ;
77760: GO 77787
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77762: LD_ADDR_EXP 48
77766: PUSH
77767: LD_EXP 48
77771: PPUSH
77772: LD_VAR 0 1
77776: PPUSH
77777: LD_VAR 0 2
77781: PPUSH
77782: CALL_OW 1
77786: ST_TO_ADDR
// end ;
77787: LD_VAR 0 3
77791: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77792: LD_INT 0
77794: PPUSH
77795: PPUSH
// if not mc_bases or not base then
77796: LD_EXP 23
77800: NOT
77801: PUSH
77802: LD_VAR 0 1
77806: NOT
77807: OR
77808: IFFALSE 77812
// exit ;
77810: GO 77876
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77812: LD_ADDR_VAR 0 3
77816: PUSH
77817: LD_INT 1
77819: PUSH
77820: LD_INT 2
77822: PUSH
77823: LD_INT 3
77825: PUSH
77826: LD_INT 4
77828: PUSH
77829: LD_INT 11
77831: PUSH
77832: EMPTY
77833: LIST
77834: LIST
77835: LIST
77836: LIST
77837: LIST
77838: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77839: LD_ADDR_EXP 50
77843: PUSH
77844: LD_EXP 50
77848: PPUSH
77849: LD_VAR 0 1
77853: PPUSH
77854: LD_EXP 50
77858: PUSH
77859: LD_VAR 0 1
77863: ARRAY
77864: PUSH
77865: LD_VAR 0 3
77869: DIFF
77870: PPUSH
77871: CALL_OW 1
77875: ST_TO_ADDR
// end ;
77876: LD_VAR 0 2
77880: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77881: LD_INT 0
77883: PPUSH
// result := mc_vehicles [ base ] ;
77884: LD_ADDR_VAR 0 3
77888: PUSH
77889: LD_EXP 42
77893: PUSH
77894: LD_VAR 0 1
77898: ARRAY
77899: ST_TO_ADDR
// if onlyCombat then
77900: LD_VAR 0 2
77904: IFFALSE 78082
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77906: LD_ADDR_VAR 0 3
77910: PUSH
77911: LD_VAR 0 3
77915: PUSH
77916: LD_VAR 0 3
77920: PPUSH
77921: LD_INT 2
77923: PUSH
77924: LD_INT 34
77926: PUSH
77927: LD_INT 12
77929: PUSH
77930: EMPTY
77931: LIST
77932: LIST
77933: PUSH
77934: LD_INT 34
77936: PUSH
77937: LD_INT 51
77939: PUSH
77940: EMPTY
77941: LIST
77942: LIST
77943: PUSH
77944: LD_INT 34
77946: PUSH
77947: LD_EXP 68
77951: PUSH
77952: EMPTY
77953: LIST
77954: LIST
77955: PUSH
77956: LD_INT 34
77958: PUSH
77959: LD_INT 32
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: LD_INT 34
77968: PUSH
77969: LD_INT 13
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: PUSH
77976: LD_INT 34
77978: PUSH
77979: LD_INT 52
77981: PUSH
77982: EMPTY
77983: LIST
77984: LIST
77985: PUSH
77986: LD_INT 34
77988: PUSH
77989: LD_EXP 73
77993: PUSH
77994: EMPTY
77995: LIST
77996: LIST
77997: PUSH
77998: LD_INT 34
78000: PUSH
78001: LD_INT 14
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 34
78010: PUSH
78011: LD_INT 53
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: PUSH
78018: LD_INT 34
78020: PUSH
78021: LD_EXP 67
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 34
78032: PUSH
78033: LD_INT 31
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 34
78042: PUSH
78043: LD_INT 48
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 34
78052: PUSH
78053: LD_INT 8
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: LIST
78064: LIST
78065: LIST
78066: LIST
78067: LIST
78068: LIST
78069: LIST
78070: LIST
78071: LIST
78072: LIST
78073: LIST
78074: LIST
78075: PPUSH
78076: CALL_OW 72
78080: DIFF
78081: ST_TO_ADDR
// end ; end_of_file
78082: LD_VAR 0 3
78086: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78087: LD_INT 0
78089: PPUSH
78090: PPUSH
78091: PPUSH
// if not mc_bases or not skirmish then
78092: LD_EXP 23
78096: NOT
78097: PUSH
78098: LD_EXP 21
78102: NOT
78103: OR
78104: IFFALSE 78108
// exit ;
78106: GO 78273
// for i = 1 to mc_bases do
78108: LD_ADDR_VAR 0 4
78112: PUSH
78113: DOUBLE
78114: LD_INT 1
78116: DEC
78117: ST_TO_ADDR
78118: LD_EXP 23
78122: PUSH
78123: FOR_TO
78124: IFFALSE 78271
// begin if sci in mc_bases [ i ] then
78126: LD_VAR 0 2
78130: PUSH
78131: LD_EXP 23
78135: PUSH
78136: LD_VAR 0 4
78140: ARRAY
78141: IN
78142: IFFALSE 78269
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78144: LD_ADDR_EXP 52
78148: PUSH
78149: LD_EXP 52
78153: PPUSH
78154: LD_VAR 0 4
78158: PUSH
78159: LD_EXP 52
78163: PUSH
78164: LD_VAR 0 4
78168: ARRAY
78169: PUSH
78170: LD_INT 1
78172: PLUS
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: PPUSH
78178: LD_VAR 0 1
78182: PPUSH
78183: CALL 16166 0 3
78187: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78188: LD_ADDR_VAR 0 5
78192: PUSH
78193: LD_EXP 23
78197: PUSH
78198: LD_VAR 0 4
78202: ARRAY
78203: PPUSH
78204: LD_INT 2
78206: PUSH
78207: LD_INT 30
78209: PUSH
78210: LD_INT 0
78212: PUSH
78213: EMPTY
78214: LIST
78215: LIST
78216: PUSH
78217: LD_INT 30
78219: PUSH
78220: LD_INT 1
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: LIST
78231: PPUSH
78232: CALL_OW 72
78236: PPUSH
78237: LD_VAR 0 1
78241: PPUSH
78242: CALL_OW 74
78246: ST_TO_ADDR
// if tmp then
78247: LD_VAR 0 5
78251: IFFALSE 78267
// ComStandNearbyBuilding ( ape , tmp ) ;
78253: LD_VAR 0 1
78257: PPUSH
78258: LD_VAR 0 5
78262: PPUSH
78263: CALL 12591 0 2
// break ;
78267: GO 78271
// end ; end ;
78269: GO 78123
78271: POP
78272: POP
// end ;
78273: LD_VAR 0 3
78277: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78278: LD_INT 0
78280: PPUSH
78281: PPUSH
78282: PPUSH
// if not mc_bases or not skirmish then
78283: LD_EXP 23
78287: NOT
78288: PUSH
78289: LD_EXP 21
78293: NOT
78294: OR
78295: IFFALSE 78299
// exit ;
78297: GO 78388
// for i = 1 to mc_bases do
78299: LD_ADDR_VAR 0 4
78303: PUSH
78304: DOUBLE
78305: LD_INT 1
78307: DEC
78308: ST_TO_ADDR
78309: LD_EXP 23
78313: PUSH
78314: FOR_TO
78315: IFFALSE 78386
// begin if building in mc_busy_turret_list [ i ] then
78317: LD_VAR 0 1
78321: PUSH
78322: LD_EXP 33
78326: PUSH
78327: LD_VAR 0 4
78331: ARRAY
78332: IN
78333: IFFALSE 78384
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78335: LD_ADDR_VAR 0 5
78339: PUSH
78340: LD_EXP 33
78344: PUSH
78345: LD_VAR 0 4
78349: ARRAY
78350: PUSH
78351: LD_VAR 0 1
78355: DIFF
78356: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78357: LD_ADDR_EXP 33
78361: PUSH
78362: LD_EXP 33
78366: PPUSH
78367: LD_VAR 0 4
78371: PPUSH
78372: LD_VAR 0 5
78376: PPUSH
78377: CALL_OW 1
78381: ST_TO_ADDR
// break ;
78382: GO 78386
// end ; end ;
78384: GO 78314
78386: POP
78387: POP
// end ;
78388: LD_VAR 0 3
78392: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78393: LD_INT 0
78395: PPUSH
78396: PPUSH
78397: PPUSH
// if not mc_bases or not skirmish then
78398: LD_EXP 23
78402: NOT
78403: PUSH
78404: LD_EXP 21
78408: NOT
78409: OR
78410: IFFALSE 78414
// exit ;
78412: GO 78613
// for i = 1 to mc_bases do
78414: LD_ADDR_VAR 0 5
78418: PUSH
78419: DOUBLE
78420: LD_INT 1
78422: DEC
78423: ST_TO_ADDR
78424: LD_EXP 23
78428: PUSH
78429: FOR_TO
78430: IFFALSE 78611
// if building in mc_bases [ i ] then
78432: LD_VAR 0 1
78436: PUSH
78437: LD_EXP 23
78441: PUSH
78442: LD_VAR 0 5
78446: ARRAY
78447: IN
78448: IFFALSE 78609
// begin tmp := mc_bases [ i ] diff building ;
78450: LD_ADDR_VAR 0 6
78454: PUSH
78455: LD_EXP 23
78459: PUSH
78460: LD_VAR 0 5
78464: ARRAY
78465: PUSH
78466: LD_VAR 0 1
78470: DIFF
78471: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78472: LD_ADDR_EXP 23
78476: PUSH
78477: LD_EXP 23
78481: PPUSH
78482: LD_VAR 0 5
78486: PPUSH
78487: LD_VAR 0 6
78491: PPUSH
78492: CALL_OW 1
78496: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78497: LD_VAR 0 1
78501: PUSH
78502: LD_EXP 31
78506: PUSH
78507: LD_VAR 0 5
78511: ARRAY
78512: IN
78513: IFFALSE 78552
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78515: LD_ADDR_EXP 31
78519: PUSH
78520: LD_EXP 31
78524: PPUSH
78525: LD_VAR 0 5
78529: PPUSH
78530: LD_EXP 31
78534: PUSH
78535: LD_VAR 0 5
78539: ARRAY
78540: PUSH
78541: LD_VAR 0 1
78545: DIFF
78546: PPUSH
78547: CALL_OW 1
78551: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78552: LD_VAR 0 1
78556: PUSH
78557: LD_EXP 32
78561: PUSH
78562: LD_VAR 0 5
78566: ARRAY
78567: IN
78568: IFFALSE 78607
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78570: LD_ADDR_EXP 32
78574: PUSH
78575: LD_EXP 32
78579: PPUSH
78580: LD_VAR 0 5
78584: PPUSH
78585: LD_EXP 32
78589: PUSH
78590: LD_VAR 0 5
78594: ARRAY
78595: PUSH
78596: LD_VAR 0 1
78600: DIFF
78601: PPUSH
78602: CALL_OW 1
78606: ST_TO_ADDR
// break ;
78607: GO 78611
// end ;
78609: GO 78429
78611: POP
78612: POP
// end ;
78613: LD_VAR 0 4
78617: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78618: LD_INT 0
78620: PPUSH
78621: PPUSH
78622: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78623: LD_EXP 23
78627: NOT
78628: PUSH
78629: LD_EXP 21
78633: NOT
78634: OR
78635: PUSH
78636: LD_VAR 0 3
78640: PUSH
78641: LD_EXP 49
78645: IN
78646: NOT
78647: OR
78648: IFFALSE 78652
// exit ;
78650: GO 78775
// for i = 1 to mc_vehicles do
78652: LD_ADDR_VAR 0 6
78656: PUSH
78657: DOUBLE
78658: LD_INT 1
78660: DEC
78661: ST_TO_ADDR
78662: LD_EXP 42
78666: PUSH
78667: FOR_TO
78668: IFFALSE 78773
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78670: LD_VAR 0 2
78674: PUSH
78675: LD_EXP 42
78679: PUSH
78680: LD_VAR 0 6
78684: ARRAY
78685: IN
78686: PUSH
78687: LD_VAR 0 1
78691: PUSH
78692: LD_EXP 42
78696: PUSH
78697: LD_VAR 0 6
78701: ARRAY
78702: IN
78703: OR
78704: IFFALSE 78771
// begin tmp := mc_vehicles [ i ] diff old ;
78706: LD_ADDR_VAR 0 7
78710: PUSH
78711: LD_EXP 42
78715: PUSH
78716: LD_VAR 0 6
78720: ARRAY
78721: PUSH
78722: LD_VAR 0 2
78726: DIFF
78727: ST_TO_ADDR
// tmp := tmp diff new ;
78728: LD_ADDR_VAR 0 7
78732: PUSH
78733: LD_VAR 0 7
78737: PUSH
78738: LD_VAR 0 1
78742: DIFF
78743: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78744: LD_ADDR_EXP 42
78748: PUSH
78749: LD_EXP 42
78753: PPUSH
78754: LD_VAR 0 6
78758: PPUSH
78759: LD_VAR 0 7
78763: PPUSH
78764: CALL_OW 1
78768: ST_TO_ADDR
// break ;
78769: GO 78773
// end ;
78771: GO 78667
78773: POP
78774: POP
// end ;
78775: LD_VAR 0 5
78779: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78780: LD_INT 0
78782: PPUSH
78783: PPUSH
78784: PPUSH
78785: PPUSH
// if not mc_bases or not skirmish then
78786: LD_EXP 23
78790: NOT
78791: PUSH
78792: LD_EXP 21
78796: NOT
78797: OR
78798: IFFALSE 78802
// exit ;
78800: GO 79194
// side := GetSide ( vehicle ) ;
78802: LD_ADDR_VAR 0 5
78806: PUSH
78807: LD_VAR 0 1
78811: PPUSH
78812: CALL_OW 255
78816: ST_TO_ADDR
// for i = 1 to mc_bases do
78817: LD_ADDR_VAR 0 4
78821: PUSH
78822: DOUBLE
78823: LD_INT 1
78825: DEC
78826: ST_TO_ADDR
78827: LD_EXP 23
78831: PUSH
78832: FOR_TO
78833: IFFALSE 79192
// begin if factory in mc_bases [ i ] then
78835: LD_VAR 0 2
78839: PUSH
78840: LD_EXP 23
78844: PUSH
78845: LD_VAR 0 4
78849: ARRAY
78850: IN
78851: IFFALSE 79190
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78853: LD_EXP 45
78857: PUSH
78858: LD_VAR 0 4
78862: ARRAY
78863: PUSH
78864: LD_EXP 34
78868: PUSH
78869: LD_VAR 0 4
78873: ARRAY
78874: LESS
78875: PUSH
78876: LD_VAR 0 1
78880: PPUSH
78881: CALL_OW 264
78885: PUSH
78886: LD_INT 31
78888: PUSH
78889: LD_INT 32
78891: PUSH
78892: LD_INT 51
78894: PUSH
78895: LD_EXP 68
78899: PUSH
78900: LD_INT 12
78902: PUSH
78903: LD_INT 30
78905: PUSH
78906: LD_EXP 67
78910: PUSH
78911: LD_INT 11
78913: PUSH
78914: LD_INT 53
78916: PUSH
78917: LD_INT 14
78919: PUSH
78920: LD_EXP 71
78924: PUSH
78925: LD_INT 29
78927: PUSH
78928: LD_EXP 69
78932: PUSH
78933: LD_INT 13
78935: PUSH
78936: LD_INT 52
78938: PUSH
78939: LD_EXP 73
78943: PUSH
78944: LD_INT 48
78946: PUSH
78947: LD_INT 8
78949: PUSH
78950: EMPTY
78951: LIST
78952: LIST
78953: LIST
78954: LIST
78955: LIST
78956: LIST
78957: LIST
78958: LIST
78959: LIST
78960: LIST
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: IN
78970: NOT
78971: AND
78972: IFFALSE 79020
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78974: LD_ADDR_EXP 45
78978: PUSH
78979: LD_EXP 45
78983: PPUSH
78984: LD_VAR 0 4
78988: PUSH
78989: LD_EXP 45
78993: PUSH
78994: LD_VAR 0 4
78998: ARRAY
78999: PUSH
79000: LD_INT 1
79002: PLUS
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PPUSH
79008: LD_VAR 0 1
79012: PPUSH
79013: CALL 16166 0 3
79017: ST_TO_ADDR
79018: GO 79064
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79020: LD_ADDR_EXP 42
79024: PUSH
79025: LD_EXP 42
79029: PPUSH
79030: LD_VAR 0 4
79034: PUSH
79035: LD_EXP 42
79039: PUSH
79040: LD_VAR 0 4
79044: ARRAY
79045: PUSH
79046: LD_INT 1
79048: PLUS
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PPUSH
79054: LD_VAR 0 1
79058: PPUSH
79059: CALL 16166 0 3
79063: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79064: LD_VAR 0 1
79068: PPUSH
79069: CALL_OW 263
79073: PUSH
79074: LD_INT 2
79076: EQUAL
79077: IFFALSE 79106
// begin repeat wait ( 0 0$3 ) ;
79079: LD_INT 105
79081: PPUSH
79082: CALL_OW 67
// Connect ( vehicle ) ;
79086: LD_VAR 0 1
79090: PPUSH
79091: CALL 19137 0 1
// until IsControledBy ( vehicle ) ;
79095: LD_VAR 0 1
79099: PPUSH
79100: CALL_OW 312
79104: IFFALSE 79079
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79106: LD_VAR 0 1
79110: PPUSH
79111: LD_EXP 47
79115: PUSH
79116: LD_VAR 0 4
79120: ARRAY
79121: PPUSH
79122: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79126: LD_VAR 0 1
79130: PPUSH
79131: CALL_OW 263
79135: PUSH
79136: LD_INT 1
79138: NONEQUAL
79139: IFFALSE 79143
// break ;
79141: GO 79192
// repeat wait ( 0 0$1 ) ;
79143: LD_INT 35
79145: PPUSH
79146: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79150: LD_VAR 0 1
79154: PPUSH
79155: LD_EXP 47
79159: PUSH
79160: LD_VAR 0 4
79164: ARRAY
79165: PPUSH
79166: CALL_OW 308
79170: IFFALSE 79143
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79172: LD_VAR 0 1
79176: PPUSH
79177: CALL_OW 311
79181: PPUSH
79182: CALL_OW 121
// exit ;
79186: POP
79187: POP
79188: GO 79194
// end ; end ;
79190: GO 78832
79192: POP
79193: POP
// end ;
79194: LD_VAR 0 3
79198: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79199: LD_INT 0
79201: PPUSH
79202: PPUSH
79203: PPUSH
79204: PPUSH
// if not mc_bases or not skirmish then
79205: LD_EXP 23
79209: NOT
79210: PUSH
79211: LD_EXP 21
79215: NOT
79216: OR
79217: IFFALSE 79221
// exit ;
79219: GO 79574
// repeat wait ( 0 0$1 ) ;
79221: LD_INT 35
79223: PPUSH
79224: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79228: LD_VAR 0 2
79232: PPUSH
79233: LD_VAR 0 3
79237: PPUSH
79238: CALL_OW 284
79242: IFFALSE 79221
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79244: LD_VAR 0 2
79248: PPUSH
79249: LD_VAR 0 3
79253: PPUSH
79254: CALL_OW 283
79258: PUSH
79259: LD_INT 4
79261: EQUAL
79262: IFFALSE 79266
// exit ;
79264: GO 79574
// for i = 1 to mc_bases do
79266: LD_ADDR_VAR 0 7
79270: PUSH
79271: DOUBLE
79272: LD_INT 1
79274: DEC
79275: ST_TO_ADDR
79276: LD_EXP 23
79280: PUSH
79281: FOR_TO
79282: IFFALSE 79572
// begin if mc_crates_area [ i ] then
79284: LD_EXP 41
79288: PUSH
79289: LD_VAR 0 7
79293: ARRAY
79294: IFFALSE 79405
// for j in mc_crates_area [ i ] do
79296: LD_ADDR_VAR 0 8
79300: PUSH
79301: LD_EXP 41
79305: PUSH
79306: LD_VAR 0 7
79310: ARRAY
79311: PUSH
79312: FOR_IN
79313: IFFALSE 79403
// if InArea ( x , y , j ) then
79315: LD_VAR 0 2
79319: PPUSH
79320: LD_VAR 0 3
79324: PPUSH
79325: LD_VAR 0 8
79329: PPUSH
79330: CALL_OW 309
79334: IFFALSE 79401
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79336: LD_ADDR_EXP 39
79340: PUSH
79341: LD_EXP 39
79345: PPUSH
79346: LD_VAR 0 7
79350: PUSH
79351: LD_EXP 39
79355: PUSH
79356: LD_VAR 0 7
79360: ARRAY
79361: PUSH
79362: LD_INT 1
79364: PLUS
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PPUSH
79370: LD_VAR 0 4
79374: PUSH
79375: LD_VAR 0 2
79379: PUSH
79380: LD_VAR 0 3
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: LIST
79389: PPUSH
79390: CALL 16166 0 3
79394: ST_TO_ADDR
// exit ;
79395: POP
79396: POP
79397: POP
79398: POP
79399: GO 79574
// end ;
79401: GO 79312
79403: POP
79404: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79405: LD_ADDR_VAR 0 9
79409: PUSH
79410: LD_EXP 23
79414: PUSH
79415: LD_VAR 0 7
79419: ARRAY
79420: PPUSH
79421: LD_INT 2
79423: PUSH
79424: LD_INT 30
79426: PUSH
79427: LD_INT 0
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: PUSH
79434: LD_INT 30
79436: PUSH
79437: LD_INT 1
79439: PUSH
79440: EMPTY
79441: LIST
79442: LIST
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: LIST
79448: PPUSH
79449: CALL_OW 72
79453: ST_TO_ADDR
// if not depot then
79454: LD_VAR 0 9
79458: NOT
79459: IFFALSE 79463
// continue ;
79461: GO 79281
// for j in depot do
79463: LD_ADDR_VAR 0 8
79467: PUSH
79468: LD_VAR 0 9
79472: PUSH
79473: FOR_IN
79474: IFFALSE 79568
// if GetDistUnitXY ( j , x , y ) < 30 then
79476: LD_VAR 0 8
79480: PPUSH
79481: LD_VAR 0 2
79485: PPUSH
79486: LD_VAR 0 3
79490: PPUSH
79491: CALL_OW 297
79495: PUSH
79496: LD_INT 30
79498: LESS
79499: IFFALSE 79566
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79501: LD_ADDR_EXP 39
79505: PUSH
79506: LD_EXP 39
79510: PPUSH
79511: LD_VAR 0 7
79515: PUSH
79516: LD_EXP 39
79520: PUSH
79521: LD_VAR 0 7
79525: ARRAY
79526: PUSH
79527: LD_INT 1
79529: PLUS
79530: PUSH
79531: EMPTY
79532: LIST
79533: LIST
79534: PPUSH
79535: LD_VAR 0 4
79539: PUSH
79540: LD_VAR 0 2
79544: PUSH
79545: LD_VAR 0 3
79549: PUSH
79550: EMPTY
79551: LIST
79552: LIST
79553: LIST
79554: PPUSH
79555: CALL 16166 0 3
79559: ST_TO_ADDR
// exit ;
79560: POP
79561: POP
79562: POP
79563: POP
79564: GO 79574
// end ;
79566: GO 79473
79568: POP
79569: POP
// end ;
79570: GO 79281
79572: POP
79573: POP
// end ;
79574: LD_VAR 0 6
79578: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79579: LD_INT 0
79581: PPUSH
79582: PPUSH
79583: PPUSH
79584: PPUSH
// if not mc_bases or not skirmish then
79585: LD_EXP 23
79589: NOT
79590: PUSH
79591: LD_EXP 21
79595: NOT
79596: OR
79597: IFFALSE 79601
// exit ;
79599: GO 79878
// side := GetSide ( lab ) ;
79601: LD_ADDR_VAR 0 4
79605: PUSH
79606: LD_VAR 0 2
79610: PPUSH
79611: CALL_OW 255
79615: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79616: LD_VAR 0 4
79620: PUSH
79621: LD_EXP 49
79625: IN
79626: NOT
79627: PUSH
79628: LD_EXP 50
79632: NOT
79633: OR
79634: PUSH
79635: LD_EXP 23
79639: NOT
79640: OR
79641: IFFALSE 79645
// exit ;
79643: GO 79878
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79645: LD_ADDR_EXP 50
79649: PUSH
79650: LD_EXP 50
79654: PPUSH
79655: LD_VAR 0 4
79659: PPUSH
79660: LD_EXP 50
79664: PUSH
79665: LD_VAR 0 4
79669: ARRAY
79670: PUSH
79671: LD_VAR 0 1
79675: DIFF
79676: PPUSH
79677: CALL_OW 1
79681: ST_TO_ADDR
// for i = 1 to mc_bases do
79682: LD_ADDR_VAR 0 5
79686: PUSH
79687: DOUBLE
79688: LD_INT 1
79690: DEC
79691: ST_TO_ADDR
79692: LD_EXP 23
79696: PUSH
79697: FOR_TO
79698: IFFALSE 79876
// begin if lab in mc_bases [ i ] then
79700: LD_VAR 0 2
79704: PUSH
79705: LD_EXP 23
79709: PUSH
79710: LD_VAR 0 5
79714: ARRAY
79715: IN
79716: IFFALSE 79874
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79718: LD_VAR 0 1
79722: PUSH
79723: LD_INT 11
79725: PUSH
79726: LD_INT 4
79728: PUSH
79729: LD_INT 3
79731: PUSH
79732: LD_INT 2
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: LIST
79739: LIST
79740: IN
79741: PUSH
79742: LD_EXP 53
79746: PUSH
79747: LD_VAR 0 5
79751: ARRAY
79752: AND
79753: IFFALSE 79874
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79755: LD_ADDR_VAR 0 6
79759: PUSH
79760: LD_EXP 53
79764: PUSH
79765: LD_VAR 0 5
79769: ARRAY
79770: PUSH
79771: LD_INT 1
79773: ARRAY
79774: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79775: LD_ADDR_EXP 53
79779: PUSH
79780: LD_EXP 53
79784: PPUSH
79785: LD_VAR 0 5
79789: PPUSH
79790: EMPTY
79791: PPUSH
79792: CALL_OW 1
79796: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79797: LD_VAR 0 6
79801: PPUSH
79802: LD_INT 0
79804: PPUSH
79805: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79809: LD_VAR 0 6
79813: PPUSH
79814: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79818: LD_ADDR_EXP 52
79822: PUSH
79823: LD_EXP 52
79827: PPUSH
79828: LD_VAR 0 5
79832: PPUSH
79833: LD_EXP 52
79837: PUSH
79838: LD_VAR 0 5
79842: ARRAY
79843: PPUSH
79844: LD_INT 1
79846: PPUSH
79847: LD_VAR 0 6
79851: PPUSH
79852: CALL_OW 2
79856: PPUSH
79857: CALL_OW 1
79861: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79862: LD_VAR 0 5
79866: PPUSH
79867: LD_INT 112
79869: PPUSH
79870: CALL 56397 0 2
// end ; end ; end ;
79874: GO 79697
79876: POP
79877: POP
// end ;
79878: LD_VAR 0 3
79882: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79883: LD_INT 0
79885: PPUSH
79886: PPUSH
79887: PPUSH
79888: PPUSH
79889: PPUSH
79890: PPUSH
79891: PPUSH
79892: PPUSH
// if not mc_bases or not skirmish then
79893: LD_EXP 23
79897: NOT
79898: PUSH
79899: LD_EXP 21
79903: NOT
79904: OR
79905: IFFALSE 79909
// exit ;
79907: GO 81280
// for i = 1 to mc_bases do
79909: LD_ADDR_VAR 0 3
79913: PUSH
79914: DOUBLE
79915: LD_INT 1
79917: DEC
79918: ST_TO_ADDR
79919: LD_EXP 23
79923: PUSH
79924: FOR_TO
79925: IFFALSE 81278
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79927: LD_VAR 0 1
79931: PUSH
79932: LD_EXP 23
79936: PUSH
79937: LD_VAR 0 3
79941: ARRAY
79942: IN
79943: PUSH
79944: LD_VAR 0 1
79948: PUSH
79949: LD_EXP 30
79953: PUSH
79954: LD_VAR 0 3
79958: ARRAY
79959: IN
79960: OR
79961: PUSH
79962: LD_VAR 0 1
79966: PUSH
79967: LD_EXP 45
79971: PUSH
79972: LD_VAR 0 3
79976: ARRAY
79977: IN
79978: OR
79979: PUSH
79980: LD_VAR 0 1
79984: PUSH
79985: LD_EXP 42
79989: PUSH
79990: LD_VAR 0 3
79994: ARRAY
79995: IN
79996: OR
79997: PUSH
79998: LD_VAR 0 1
80002: PUSH
80003: LD_EXP 52
80007: PUSH
80008: LD_VAR 0 3
80012: ARRAY
80013: IN
80014: OR
80015: PUSH
80016: LD_VAR 0 1
80020: PUSH
80021: LD_EXP 53
80025: PUSH
80026: LD_VAR 0 3
80030: ARRAY
80031: IN
80032: OR
80033: IFFALSE 81276
// begin if un in mc_ape [ i ] then
80035: LD_VAR 0 1
80039: PUSH
80040: LD_EXP 52
80044: PUSH
80045: LD_VAR 0 3
80049: ARRAY
80050: IN
80051: IFFALSE 80090
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80053: LD_ADDR_EXP 52
80057: PUSH
80058: LD_EXP 52
80062: PPUSH
80063: LD_VAR 0 3
80067: PPUSH
80068: LD_EXP 52
80072: PUSH
80073: LD_VAR 0 3
80077: ARRAY
80078: PUSH
80079: LD_VAR 0 1
80083: DIFF
80084: PPUSH
80085: CALL_OW 1
80089: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80090: LD_VAR 0 1
80094: PUSH
80095: LD_EXP 53
80099: PUSH
80100: LD_VAR 0 3
80104: ARRAY
80105: IN
80106: IFFALSE 80130
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80108: LD_ADDR_EXP 53
80112: PUSH
80113: LD_EXP 53
80117: PPUSH
80118: LD_VAR 0 3
80122: PPUSH
80123: EMPTY
80124: PPUSH
80125: CALL_OW 1
80129: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80130: LD_VAR 0 1
80134: PPUSH
80135: CALL_OW 247
80139: PUSH
80140: LD_INT 2
80142: EQUAL
80143: PUSH
80144: LD_VAR 0 1
80148: PPUSH
80149: CALL_OW 110
80153: PUSH
80154: LD_INT 20
80156: EQUAL
80157: PUSH
80158: LD_VAR 0 1
80162: PUSH
80163: LD_EXP 45
80167: PUSH
80168: LD_VAR 0 3
80172: ARRAY
80173: IN
80174: OR
80175: PUSH
80176: LD_VAR 0 1
80180: PPUSH
80181: CALL_OW 264
80185: PUSH
80186: LD_INT 12
80188: PUSH
80189: LD_INT 51
80191: PUSH
80192: LD_EXP 68
80196: PUSH
80197: LD_INT 32
80199: PUSH
80200: LD_INT 13
80202: PUSH
80203: LD_INT 52
80205: PUSH
80206: LD_INT 31
80208: PUSH
80209: EMPTY
80210: LIST
80211: LIST
80212: LIST
80213: LIST
80214: LIST
80215: LIST
80216: LIST
80217: IN
80218: OR
80219: AND
80220: IFFALSE 80528
// begin if un in mc_defender [ i ] then
80222: LD_VAR 0 1
80226: PUSH
80227: LD_EXP 45
80231: PUSH
80232: LD_VAR 0 3
80236: ARRAY
80237: IN
80238: IFFALSE 80277
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80240: LD_ADDR_EXP 45
80244: PUSH
80245: LD_EXP 45
80249: PPUSH
80250: LD_VAR 0 3
80254: PPUSH
80255: LD_EXP 45
80259: PUSH
80260: LD_VAR 0 3
80264: ARRAY
80265: PUSH
80266: LD_VAR 0 1
80270: DIFF
80271: PPUSH
80272: CALL_OW 1
80276: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80277: LD_ADDR_VAR 0 8
80281: PUSH
80282: LD_VAR 0 3
80286: PPUSH
80287: LD_INT 3
80289: PPUSH
80290: CALL 76918 0 2
80294: ST_TO_ADDR
// if fac then
80295: LD_VAR 0 8
80299: IFFALSE 80528
// begin for j in fac do
80301: LD_ADDR_VAR 0 4
80305: PUSH
80306: LD_VAR 0 8
80310: PUSH
80311: FOR_IN
80312: IFFALSE 80526
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80314: LD_ADDR_VAR 0 9
80318: PUSH
80319: LD_VAR 0 8
80323: PPUSH
80324: LD_VAR 0 1
80328: PPUSH
80329: CALL_OW 265
80333: PPUSH
80334: LD_VAR 0 1
80338: PPUSH
80339: CALL_OW 262
80343: PPUSH
80344: LD_VAR 0 1
80348: PPUSH
80349: CALL_OW 263
80353: PPUSH
80354: LD_VAR 0 1
80358: PPUSH
80359: CALL_OW 264
80363: PPUSH
80364: CALL 13662 0 5
80368: ST_TO_ADDR
// if components then
80369: LD_VAR 0 9
80373: IFFALSE 80524
// begin if GetWeapon ( un ) = ar_control_tower then
80375: LD_VAR 0 1
80379: PPUSH
80380: CALL_OW 264
80384: PUSH
80385: LD_INT 31
80387: EQUAL
80388: IFFALSE 80505
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80390: LD_VAR 0 1
80394: PPUSH
80395: CALL_OW 311
80399: PPUSH
80400: LD_INT 0
80402: PPUSH
80403: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80407: LD_ADDR_EXP 63
80411: PUSH
80412: LD_EXP 63
80416: PPUSH
80417: LD_VAR 0 3
80421: PPUSH
80422: LD_EXP 63
80426: PUSH
80427: LD_VAR 0 3
80431: ARRAY
80432: PUSH
80433: LD_VAR 0 1
80437: PPUSH
80438: CALL_OW 311
80442: DIFF
80443: PPUSH
80444: CALL_OW 1
80448: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80449: LD_ADDR_VAR 0 7
80453: PUSH
80454: LD_EXP 44
80458: PUSH
80459: LD_VAR 0 3
80463: ARRAY
80464: PPUSH
80465: LD_INT 1
80467: PPUSH
80468: LD_VAR 0 9
80472: PPUSH
80473: CALL_OW 2
80477: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80478: LD_ADDR_EXP 44
80482: PUSH
80483: LD_EXP 44
80487: PPUSH
80488: LD_VAR 0 3
80492: PPUSH
80493: LD_VAR 0 7
80497: PPUSH
80498: CALL_OW 1
80502: ST_TO_ADDR
// end else
80503: GO 80522
// MC_InsertProduceList ( i , [ components ] ) ;
80505: LD_VAR 0 3
80509: PPUSH
80510: LD_VAR 0 9
80514: PUSH
80515: EMPTY
80516: LIST
80517: PPUSH
80518: CALL 76463 0 2
// break ;
80522: GO 80526
// end ; end ;
80524: GO 80311
80526: POP
80527: POP
// end ; end ; if GetType ( un ) = unit_building then
80528: LD_VAR 0 1
80532: PPUSH
80533: CALL_OW 247
80537: PUSH
80538: LD_INT 3
80540: EQUAL
80541: IFFALSE 80944
// begin btype := GetBType ( un ) ;
80543: LD_ADDR_VAR 0 5
80547: PUSH
80548: LD_VAR 0 1
80552: PPUSH
80553: CALL_OW 266
80557: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80558: LD_VAR 0 5
80562: PUSH
80563: LD_INT 29
80565: PUSH
80566: LD_INT 30
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: IN
80573: IFFALSE 80646
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80575: LD_VAR 0 1
80579: PPUSH
80580: CALL_OW 250
80584: PPUSH
80585: LD_VAR 0 1
80589: PPUSH
80590: CALL_OW 251
80594: PPUSH
80595: LD_VAR 0 1
80599: PPUSH
80600: CALL_OW 255
80604: PPUSH
80605: CALL_OW 440
80609: NOT
80610: IFFALSE 80646
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80612: LD_VAR 0 1
80616: PPUSH
80617: CALL_OW 250
80621: PPUSH
80622: LD_VAR 0 1
80626: PPUSH
80627: CALL_OW 251
80631: PPUSH
80632: LD_VAR 0 1
80636: PPUSH
80637: CALL_OW 255
80641: PPUSH
80642: CALL_OW 441
// end ; if btype = b_warehouse then
80646: LD_VAR 0 5
80650: PUSH
80651: LD_INT 1
80653: EQUAL
80654: IFFALSE 80672
// begin btype := b_depot ;
80656: LD_ADDR_VAR 0 5
80660: PUSH
80661: LD_INT 0
80663: ST_TO_ADDR
// pos := 1 ;
80664: LD_ADDR_VAR 0 6
80668: PUSH
80669: LD_INT 1
80671: ST_TO_ADDR
// end ; if btype = b_factory then
80672: LD_VAR 0 5
80676: PUSH
80677: LD_INT 3
80679: EQUAL
80680: IFFALSE 80698
// begin btype := b_workshop ;
80682: LD_ADDR_VAR 0 5
80686: PUSH
80687: LD_INT 2
80689: ST_TO_ADDR
// pos := 1 ;
80690: LD_ADDR_VAR 0 6
80694: PUSH
80695: LD_INT 1
80697: ST_TO_ADDR
// end ; if btype = b_barracks then
80698: LD_VAR 0 5
80702: PUSH
80703: LD_INT 5
80705: EQUAL
80706: IFFALSE 80716
// btype := b_armoury ;
80708: LD_ADDR_VAR 0 5
80712: PUSH
80713: LD_INT 4
80715: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80716: LD_VAR 0 5
80720: PUSH
80721: LD_INT 7
80723: PUSH
80724: LD_INT 8
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: IN
80731: IFFALSE 80741
// btype := b_lab ;
80733: LD_ADDR_VAR 0 5
80737: PUSH
80738: LD_INT 6
80740: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80741: LD_ADDR_EXP 28
80745: PUSH
80746: LD_EXP 28
80750: PPUSH
80751: LD_VAR 0 3
80755: PUSH
80756: LD_EXP 28
80760: PUSH
80761: LD_VAR 0 3
80765: ARRAY
80766: PUSH
80767: LD_INT 1
80769: PLUS
80770: PUSH
80771: EMPTY
80772: LIST
80773: LIST
80774: PPUSH
80775: LD_VAR 0 5
80779: PUSH
80780: LD_VAR 0 1
80784: PPUSH
80785: CALL_OW 250
80789: PUSH
80790: LD_VAR 0 1
80794: PPUSH
80795: CALL_OW 251
80799: PUSH
80800: LD_VAR 0 1
80804: PPUSH
80805: CALL_OW 254
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: LIST
80814: LIST
80815: PPUSH
80816: CALL 16166 0 3
80820: ST_TO_ADDR
// if pos = 1 then
80821: LD_VAR 0 6
80825: PUSH
80826: LD_INT 1
80828: EQUAL
80829: IFFALSE 80944
// begin tmp := mc_build_list [ i ] ;
80831: LD_ADDR_VAR 0 7
80835: PUSH
80836: LD_EXP 28
80840: PUSH
80841: LD_VAR 0 3
80845: ARRAY
80846: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80847: LD_VAR 0 7
80851: PPUSH
80852: LD_INT 2
80854: PUSH
80855: LD_INT 30
80857: PUSH
80858: LD_INT 0
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 30
80867: PUSH
80868: LD_INT 1
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: EMPTY
80876: LIST
80877: LIST
80878: LIST
80879: PPUSH
80880: CALL_OW 72
80884: IFFALSE 80894
// pos := 2 ;
80886: LD_ADDR_VAR 0 6
80890: PUSH
80891: LD_INT 2
80893: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80894: LD_ADDR_VAR 0 7
80898: PUSH
80899: LD_VAR 0 7
80903: PPUSH
80904: LD_VAR 0 6
80908: PPUSH
80909: LD_VAR 0 7
80913: PPUSH
80914: CALL 16492 0 3
80918: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80919: LD_ADDR_EXP 28
80923: PUSH
80924: LD_EXP 28
80928: PPUSH
80929: LD_VAR 0 3
80933: PPUSH
80934: LD_VAR 0 7
80938: PPUSH
80939: CALL_OW 1
80943: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80944: LD_VAR 0 1
80948: PUSH
80949: LD_EXP 23
80953: PUSH
80954: LD_VAR 0 3
80958: ARRAY
80959: IN
80960: IFFALSE 80999
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80962: LD_ADDR_EXP 23
80966: PUSH
80967: LD_EXP 23
80971: PPUSH
80972: LD_VAR 0 3
80976: PPUSH
80977: LD_EXP 23
80981: PUSH
80982: LD_VAR 0 3
80986: ARRAY
80987: PUSH
80988: LD_VAR 0 1
80992: DIFF
80993: PPUSH
80994: CALL_OW 1
80998: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80999: LD_VAR 0 1
81003: PUSH
81004: LD_EXP 30
81008: PUSH
81009: LD_VAR 0 3
81013: ARRAY
81014: IN
81015: IFFALSE 81054
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81017: LD_ADDR_EXP 30
81021: PUSH
81022: LD_EXP 30
81026: PPUSH
81027: LD_VAR 0 3
81031: PPUSH
81032: LD_EXP 30
81036: PUSH
81037: LD_VAR 0 3
81041: ARRAY
81042: PUSH
81043: LD_VAR 0 1
81047: DIFF
81048: PPUSH
81049: CALL_OW 1
81053: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81054: LD_VAR 0 1
81058: PUSH
81059: LD_EXP 42
81063: PUSH
81064: LD_VAR 0 3
81068: ARRAY
81069: IN
81070: IFFALSE 81109
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81072: LD_ADDR_EXP 42
81076: PUSH
81077: LD_EXP 42
81081: PPUSH
81082: LD_VAR 0 3
81086: PPUSH
81087: LD_EXP 42
81091: PUSH
81092: LD_VAR 0 3
81096: ARRAY
81097: PUSH
81098: LD_VAR 0 1
81102: DIFF
81103: PPUSH
81104: CALL_OW 1
81108: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81109: LD_VAR 0 1
81113: PUSH
81114: LD_EXP 45
81118: PUSH
81119: LD_VAR 0 3
81123: ARRAY
81124: IN
81125: IFFALSE 81164
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81127: LD_ADDR_EXP 45
81131: PUSH
81132: LD_EXP 45
81136: PPUSH
81137: LD_VAR 0 3
81141: PPUSH
81142: LD_EXP 45
81146: PUSH
81147: LD_VAR 0 3
81151: ARRAY
81152: PUSH
81153: LD_VAR 0 1
81157: DIFF
81158: PPUSH
81159: CALL_OW 1
81163: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81164: LD_VAR 0 1
81168: PUSH
81169: LD_EXP 32
81173: PUSH
81174: LD_VAR 0 3
81178: ARRAY
81179: IN
81180: IFFALSE 81219
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81182: LD_ADDR_EXP 32
81186: PUSH
81187: LD_EXP 32
81191: PPUSH
81192: LD_VAR 0 3
81196: PPUSH
81197: LD_EXP 32
81201: PUSH
81202: LD_VAR 0 3
81206: ARRAY
81207: PUSH
81208: LD_VAR 0 1
81212: DIFF
81213: PPUSH
81214: CALL_OW 1
81218: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81219: LD_VAR 0 1
81223: PUSH
81224: LD_EXP 31
81228: PUSH
81229: LD_VAR 0 3
81233: ARRAY
81234: IN
81235: IFFALSE 81274
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81237: LD_ADDR_EXP 31
81241: PUSH
81242: LD_EXP 31
81246: PPUSH
81247: LD_VAR 0 3
81251: PPUSH
81252: LD_EXP 31
81256: PUSH
81257: LD_VAR 0 3
81261: ARRAY
81262: PUSH
81263: LD_VAR 0 1
81267: DIFF
81268: PPUSH
81269: CALL_OW 1
81273: ST_TO_ADDR
// end ; break ;
81274: GO 81278
// end ;
81276: GO 79924
81278: POP
81279: POP
// end ;
81280: LD_VAR 0 2
81284: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81285: LD_INT 0
81287: PPUSH
81288: PPUSH
81289: PPUSH
// if not mc_bases or not skirmish then
81290: LD_EXP 23
81294: NOT
81295: PUSH
81296: LD_EXP 21
81300: NOT
81301: OR
81302: IFFALSE 81306
// exit ;
81304: GO 81521
// for i = 1 to mc_bases do
81306: LD_ADDR_VAR 0 3
81310: PUSH
81311: DOUBLE
81312: LD_INT 1
81314: DEC
81315: ST_TO_ADDR
81316: LD_EXP 23
81320: PUSH
81321: FOR_TO
81322: IFFALSE 81519
// begin if building in mc_construct_list [ i ] then
81324: LD_VAR 0 1
81328: PUSH
81329: LD_EXP 30
81333: PUSH
81334: LD_VAR 0 3
81338: ARRAY
81339: IN
81340: IFFALSE 81517
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81342: LD_ADDR_EXP 30
81346: PUSH
81347: LD_EXP 30
81351: PPUSH
81352: LD_VAR 0 3
81356: PPUSH
81357: LD_EXP 30
81361: PUSH
81362: LD_VAR 0 3
81366: ARRAY
81367: PUSH
81368: LD_VAR 0 1
81372: DIFF
81373: PPUSH
81374: CALL_OW 1
81378: ST_TO_ADDR
// if building in mc_lab [ i ] then
81379: LD_VAR 0 1
81383: PUSH
81384: LD_EXP 56
81388: PUSH
81389: LD_VAR 0 3
81393: ARRAY
81394: IN
81395: IFFALSE 81450
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81397: LD_ADDR_EXP 57
81401: PUSH
81402: LD_EXP 57
81406: PPUSH
81407: LD_VAR 0 3
81411: PPUSH
81412: LD_EXP 57
81416: PUSH
81417: LD_VAR 0 3
81421: ARRAY
81422: PPUSH
81423: LD_INT 1
81425: PPUSH
81426: LD_EXP 57
81430: PUSH
81431: LD_VAR 0 3
81435: ARRAY
81436: PPUSH
81437: LD_INT 0
81439: PPUSH
81440: CALL 15584 0 4
81444: PPUSH
81445: CALL_OW 1
81449: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81450: LD_VAR 0 1
81454: PUSH
81455: LD_EXP 23
81459: PUSH
81460: LD_VAR 0 3
81464: ARRAY
81465: IN
81466: NOT
81467: IFFALSE 81513
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81469: LD_ADDR_EXP 23
81473: PUSH
81474: LD_EXP 23
81478: PPUSH
81479: LD_VAR 0 3
81483: PUSH
81484: LD_EXP 23
81488: PUSH
81489: LD_VAR 0 3
81493: ARRAY
81494: PUSH
81495: LD_INT 1
81497: PLUS
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: PPUSH
81503: LD_VAR 0 1
81507: PPUSH
81508: CALL 16166 0 3
81512: ST_TO_ADDR
// exit ;
81513: POP
81514: POP
81515: GO 81521
// end ; end ;
81517: GO 81321
81519: POP
81520: POP
// end ;
81521: LD_VAR 0 2
81525: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81526: LD_INT 0
81528: PPUSH
81529: PPUSH
81530: PPUSH
81531: PPUSH
81532: PPUSH
81533: PPUSH
81534: PPUSH
// if not mc_bases or not skirmish then
81535: LD_EXP 23
81539: NOT
81540: PUSH
81541: LD_EXP 21
81545: NOT
81546: OR
81547: IFFALSE 81551
// exit ;
81549: GO 82212
// for i = 1 to mc_bases do
81551: LD_ADDR_VAR 0 3
81555: PUSH
81556: DOUBLE
81557: LD_INT 1
81559: DEC
81560: ST_TO_ADDR
81561: LD_EXP 23
81565: PUSH
81566: FOR_TO
81567: IFFALSE 82210
// begin if building in mc_construct_list [ i ] then
81569: LD_VAR 0 1
81573: PUSH
81574: LD_EXP 30
81578: PUSH
81579: LD_VAR 0 3
81583: ARRAY
81584: IN
81585: IFFALSE 82208
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81587: LD_ADDR_EXP 30
81591: PUSH
81592: LD_EXP 30
81596: PPUSH
81597: LD_VAR 0 3
81601: PPUSH
81602: LD_EXP 30
81606: PUSH
81607: LD_VAR 0 3
81611: ARRAY
81612: PUSH
81613: LD_VAR 0 1
81617: DIFF
81618: PPUSH
81619: CALL_OW 1
81623: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81624: LD_ADDR_EXP 23
81628: PUSH
81629: LD_EXP 23
81633: PPUSH
81634: LD_VAR 0 3
81638: PUSH
81639: LD_EXP 23
81643: PUSH
81644: LD_VAR 0 3
81648: ARRAY
81649: PUSH
81650: LD_INT 1
81652: PLUS
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PPUSH
81658: LD_VAR 0 1
81662: PPUSH
81663: CALL 16166 0 3
81667: ST_TO_ADDR
// btype := GetBType ( building ) ;
81668: LD_ADDR_VAR 0 5
81672: PUSH
81673: LD_VAR 0 1
81677: PPUSH
81678: CALL_OW 266
81682: ST_TO_ADDR
// side := GetSide ( building ) ;
81683: LD_ADDR_VAR 0 8
81687: PUSH
81688: LD_VAR 0 1
81692: PPUSH
81693: CALL_OW 255
81697: ST_TO_ADDR
// if btype = b_lab then
81698: LD_VAR 0 5
81702: PUSH
81703: LD_INT 6
81705: EQUAL
81706: IFFALSE 81756
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81708: LD_ADDR_EXP 56
81712: PUSH
81713: LD_EXP 56
81717: PPUSH
81718: LD_VAR 0 3
81722: PUSH
81723: LD_EXP 56
81727: PUSH
81728: LD_VAR 0 3
81732: ARRAY
81733: PUSH
81734: LD_INT 1
81736: PLUS
81737: PUSH
81738: EMPTY
81739: LIST
81740: LIST
81741: PPUSH
81742: LD_VAR 0 1
81746: PPUSH
81747: CALL 16166 0 3
81751: ST_TO_ADDR
// exit ;
81752: POP
81753: POP
81754: GO 82212
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81756: LD_VAR 0 5
81760: PUSH
81761: LD_INT 0
81763: PUSH
81764: LD_INT 2
81766: PUSH
81767: LD_INT 4
81769: PUSH
81770: EMPTY
81771: LIST
81772: LIST
81773: LIST
81774: IN
81775: IFFALSE 81899
// begin if btype = b_armoury then
81777: LD_VAR 0 5
81781: PUSH
81782: LD_INT 4
81784: EQUAL
81785: IFFALSE 81795
// btype := b_barracks ;
81787: LD_ADDR_VAR 0 5
81791: PUSH
81792: LD_INT 5
81794: ST_TO_ADDR
// if btype = b_depot then
81795: LD_VAR 0 5
81799: PUSH
81800: LD_INT 0
81802: EQUAL
81803: IFFALSE 81813
// btype := b_warehouse ;
81805: LD_ADDR_VAR 0 5
81809: PUSH
81810: LD_INT 1
81812: ST_TO_ADDR
// if btype = b_workshop then
81813: LD_VAR 0 5
81817: PUSH
81818: LD_INT 2
81820: EQUAL
81821: IFFALSE 81831
// btype := b_factory ;
81823: LD_ADDR_VAR 0 5
81827: PUSH
81828: LD_INT 3
81830: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81831: LD_VAR 0 5
81835: PPUSH
81836: LD_VAR 0 8
81840: PPUSH
81841: CALL_OW 323
81845: PUSH
81846: LD_INT 1
81848: EQUAL
81849: IFFALSE 81895
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81851: LD_ADDR_EXP 55
81855: PUSH
81856: LD_EXP 55
81860: PPUSH
81861: LD_VAR 0 3
81865: PUSH
81866: LD_EXP 55
81870: PUSH
81871: LD_VAR 0 3
81875: ARRAY
81876: PUSH
81877: LD_INT 1
81879: PLUS
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PPUSH
81885: LD_VAR 0 1
81889: PPUSH
81890: CALL 16166 0 3
81894: ST_TO_ADDR
// exit ;
81895: POP
81896: POP
81897: GO 82212
// end ; if btype in [ b_bunker , b_turret ] then
81899: LD_VAR 0 5
81903: PUSH
81904: LD_INT 32
81906: PUSH
81907: LD_INT 33
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: IN
81914: IFFALSE 82204
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81916: LD_ADDR_EXP 31
81920: PUSH
81921: LD_EXP 31
81925: PPUSH
81926: LD_VAR 0 3
81930: PUSH
81931: LD_EXP 31
81935: PUSH
81936: LD_VAR 0 3
81940: ARRAY
81941: PUSH
81942: LD_INT 1
81944: PLUS
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PPUSH
81950: LD_VAR 0 1
81954: PPUSH
81955: CALL 16166 0 3
81959: ST_TO_ADDR
// if btype = b_bunker then
81960: LD_VAR 0 5
81964: PUSH
81965: LD_INT 32
81967: EQUAL
81968: IFFALSE 82204
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81970: LD_ADDR_EXP 32
81974: PUSH
81975: LD_EXP 32
81979: PPUSH
81980: LD_VAR 0 3
81984: PUSH
81985: LD_EXP 32
81989: PUSH
81990: LD_VAR 0 3
81994: ARRAY
81995: PUSH
81996: LD_INT 1
81998: PLUS
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: PPUSH
82004: LD_VAR 0 1
82008: PPUSH
82009: CALL 16166 0 3
82013: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82014: LD_ADDR_VAR 0 6
82018: PUSH
82019: LD_EXP 23
82023: PUSH
82024: LD_VAR 0 3
82028: ARRAY
82029: PPUSH
82030: LD_INT 25
82032: PUSH
82033: LD_INT 1
82035: PUSH
82036: EMPTY
82037: LIST
82038: LIST
82039: PUSH
82040: LD_INT 3
82042: PUSH
82043: LD_INT 54
82045: PUSH
82046: EMPTY
82047: LIST
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PPUSH
82057: CALL_OW 72
82061: ST_TO_ADDR
// if tmp then
82062: LD_VAR 0 6
82066: IFFALSE 82072
// exit ;
82068: POP
82069: POP
82070: GO 82212
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82072: LD_ADDR_VAR 0 6
82076: PUSH
82077: LD_EXP 23
82081: PUSH
82082: LD_VAR 0 3
82086: ARRAY
82087: PPUSH
82088: LD_INT 2
82090: PUSH
82091: LD_INT 30
82093: PUSH
82094: LD_INT 4
82096: PUSH
82097: EMPTY
82098: LIST
82099: LIST
82100: PUSH
82101: LD_INT 30
82103: PUSH
82104: LD_INT 5
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: LIST
82115: PPUSH
82116: CALL_OW 72
82120: ST_TO_ADDR
// if not tmp then
82121: LD_VAR 0 6
82125: NOT
82126: IFFALSE 82132
// exit ;
82128: POP
82129: POP
82130: GO 82212
// for j in tmp do
82132: LD_ADDR_VAR 0 4
82136: PUSH
82137: LD_VAR 0 6
82141: PUSH
82142: FOR_IN
82143: IFFALSE 82202
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82145: LD_ADDR_VAR 0 7
82149: PUSH
82150: LD_VAR 0 4
82154: PPUSH
82155: CALL_OW 313
82159: PPUSH
82160: LD_INT 25
82162: PUSH
82163: LD_INT 1
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PPUSH
82170: CALL_OW 72
82174: ST_TO_ADDR
// if units then
82175: LD_VAR 0 7
82179: IFFALSE 82200
// begin ComExitBuilding ( units [ 1 ] ) ;
82181: LD_VAR 0 7
82185: PUSH
82186: LD_INT 1
82188: ARRAY
82189: PPUSH
82190: CALL_OW 122
// exit ;
82194: POP
82195: POP
82196: POP
82197: POP
82198: GO 82212
// end ; end ;
82200: GO 82142
82202: POP
82203: POP
// end ; end ; exit ;
82204: POP
82205: POP
82206: GO 82212
// end ; end ;
82208: GO 81566
82210: POP
82211: POP
// end ;
82212: LD_VAR 0 2
82216: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82217: LD_INT 0
82219: PPUSH
82220: PPUSH
82221: PPUSH
82222: PPUSH
82223: PPUSH
82224: PPUSH
82225: PPUSH
// if not mc_bases or not skirmish then
82226: LD_EXP 23
82230: NOT
82231: PUSH
82232: LD_EXP 21
82236: NOT
82237: OR
82238: IFFALSE 82242
// exit ;
82240: GO 82507
// btype := GetBType ( building ) ;
82242: LD_ADDR_VAR 0 6
82246: PUSH
82247: LD_VAR 0 1
82251: PPUSH
82252: CALL_OW 266
82256: ST_TO_ADDR
// x := GetX ( building ) ;
82257: LD_ADDR_VAR 0 7
82261: PUSH
82262: LD_VAR 0 1
82266: PPUSH
82267: CALL_OW 250
82271: ST_TO_ADDR
// y := GetY ( building ) ;
82272: LD_ADDR_VAR 0 8
82276: PUSH
82277: LD_VAR 0 1
82281: PPUSH
82282: CALL_OW 251
82286: ST_TO_ADDR
// d := GetDir ( building ) ;
82287: LD_ADDR_VAR 0 9
82291: PUSH
82292: LD_VAR 0 1
82296: PPUSH
82297: CALL_OW 254
82301: ST_TO_ADDR
// for i = 1 to mc_bases do
82302: LD_ADDR_VAR 0 4
82306: PUSH
82307: DOUBLE
82308: LD_INT 1
82310: DEC
82311: ST_TO_ADDR
82312: LD_EXP 23
82316: PUSH
82317: FOR_TO
82318: IFFALSE 82505
// begin if not mc_build_list [ i ] then
82320: LD_EXP 28
82324: PUSH
82325: LD_VAR 0 4
82329: ARRAY
82330: NOT
82331: IFFALSE 82335
// continue ;
82333: GO 82317
// for j := 1 to mc_build_list [ i ] do
82335: LD_ADDR_VAR 0 5
82339: PUSH
82340: DOUBLE
82341: LD_INT 1
82343: DEC
82344: ST_TO_ADDR
82345: LD_EXP 28
82349: PUSH
82350: LD_VAR 0 4
82354: ARRAY
82355: PUSH
82356: FOR_TO
82357: IFFALSE 82501
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82359: LD_VAR 0 6
82363: PUSH
82364: LD_VAR 0 7
82368: PUSH
82369: LD_VAR 0 8
82373: PUSH
82374: LD_VAR 0 9
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: LIST
82383: LIST
82384: PPUSH
82385: LD_EXP 28
82389: PUSH
82390: LD_VAR 0 4
82394: ARRAY
82395: PUSH
82396: LD_VAR 0 5
82400: ARRAY
82401: PPUSH
82402: CALL 22348 0 2
82406: IFFALSE 82499
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82408: LD_ADDR_EXP 28
82412: PUSH
82413: LD_EXP 28
82417: PPUSH
82418: LD_VAR 0 4
82422: PPUSH
82423: LD_EXP 28
82427: PUSH
82428: LD_VAR 0 4
82432: ARRAY
82433: PPUSH
82434: LD_VAR 0 5
82438: PPUSH
82439: CALL_OW 3
82443: PPUSH
82444: CALL_OW 1
82448: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82449: LD_ADDR_EXP 30
82453: PUSH
82454: LD_EXP 30
82458: PPUSH
82459: LD_VAR 0 4
82463: PUSH
82464: LD_EXP 30
82468: PUSH
82469: LD_VAR 0 4
82473: ARRAY
82474: PUSH
82475: LD_INT 1
82477: PLUS
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: PPUSH
82483: LD_VAR 0 1
82487: PPUSH
82488: CALL 16166 0 3
82492: ST_TO_ADDR
// exit ;
82493: POP
82494: POP
82495: POP
82496: POP
82497: GO 82507
// end ;
82499: GO 82356
82501: POP
82502: POP
// end ;
82503: GO 82317
82505: POP
82506: POP
// end ;
82507: LD_VAR 0 3
82511: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82512: LD_INT 0
82514: PPUSH
82515: PPUSH
82516: PPUSH
// if not mc_bases or not skirmish then
82517: LD_EXP 23
82521: NOT
82522: PUSH
82523: LD_EXP 21
82527: NOT
82528: OR
82529: IFFALSE 82533
// exit ;
82531: GO 82723
// for i = 1 to mc_bases do
82533: LD_ADDR_VAR 0 4
82537: PUSH
82538: DOUBLE
82539: LD_INT 1
82541: DEC
82542: ST_TO_ADDR
82543: LD_EXP 23
82547: PUSH
82548: FOR_TO
82549: IFFALSE 82636
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82551: LD_VAR 0 1
82555: PUSH
82556: LD_EXP 31
82560: PUSH
82561: LD_VAR 0 4
82565: ARRAY
82566: IN
82567: PUSH
82568: LD_VAR 0 1
82572: PUSH
82573: LD_EXP 32
82577: PUSH
82578: LD_VAR 0 4
82582: ARRAY
82583: IN
82584: NOT
82585: AND
82586: IFFALSE 82634
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82588: LD_ADDR_EXP 32
82592: PUSH
82593: LD_EXP 32
82597: PPUSH
82598: LD_VAR 0 4
82602: PUSH
82603: LD_EXP 32
82607: PUSH
82608: LD_VAR 0 4
82612: ARRAY
82613: PUSH
82614: LD_INT 1
82616: PLUS
82617: PUSH
82618: EMPTY
82619: LIST
82620: LIST
82621: PPUSH
82622: LD_VAR 0 1
82626: PPUSH
82627: CALL 16166 0 3
82631: ST_TO_ADDR
// break ;
82632: GO 82636
// end ; end ;
82634: GO 82548
82636: POP
82637: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82638: LD_VAR 0 1
82642: PPUSH
82643: CALL_OW 257
82647: PUSH
82648: LD_EXP 49
82652: IN
82653: PUSH
82654: LD_VAR 0 1
82658: PPUSH
82659: CALL_OW 266
82663: PUSH
82664: LD_INT 5
82666: EQUAL
82667: AND
82668: PUSH
82669: LD_VAR 0 2
82673: PPUSH
82674: CALL_OW 110
82678: PUSH
82679: LD_INT 18
82681: NONEQUAL
82682: AND
82683: IFFALSE 82723
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82685: LD_VAR 0 2
82689: PPUSH
82690: CALL_OW 257
82694: PUSH
82695: LD_INT 5
82697: PUSH
82698: LD_INT 8
82700: PUSH
82701: LD_INT 9
82703: PUSH
82704: EMPTY
82705: LIST
82706: LIST
82707: LIST
82708: IN
82709: IFFALSE 82723
// SetClass ( unit , 1 ) ;
82711: LD_VAR 0 2
82715: PPUSH
82716: LD_INT 1
82718: PPUSH
82719: CALL_OW 336
// end ;
82723: LD_VAR 0 3
82727: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82728: LD_INT 0
82730: PPUSH
82731: PPUSH
// if not mc_bases or not skirmish then
82732: LD_EXP 23
82736: NOT
82737: PUSH
82738: LD_EXP 21
82742: NOT
82743: OR
82744: IFFALSE 82748
// exit ;
82746: GO 82864
// if GetLives ( abandoned_vehicle ) > 250 then
82748: LD_VAR 0 2
82752: PPUSH
82753: CALL_OW 256
82757: PUSH
82758: LD_INT 250
82760: GREATER
82761: IFFALSE 82765
// exit ;
82763: GO 82864
// for i = 1 to mc_bases do
82765: LD_ADDR_VAR 0 6
82769: PUSH
82770: DOUBLE
82771: LD_INT 1
82773: DEC
82774: ST_TO_ADDR
82775: LD_EXP 23
82779: PUSH
82780: FOR_TO
82781: IFFALSE 82862
// begin if driver in mc_bases [ i ] then
82783: LD_VAR 0 1
82787: PUSH
82788: LD_EXP 23
82792: PUSH
82793: LD_VAR 0 6
82797: ARRAY
82798: IN
82799: IFFALSE 82860
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82801: LD_VAR 0 1
82805: PPUSH
82806: LD_EXP 23
82810: PUSH
82811: LD_VAR 0 6
82815: ARRAY
82816: PPUSH
82817: LD_INT 2
82819: PUSH
82820: LD_INT 30
82822: PUSH
82823: LD_INT 0
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: LD_INT 30
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: LIST
82844: PPUSH
82845: CALL_OW 72
82849: PUSH
82850: LD_INT 1
82852: ARRAY
82853: PPUSH
82854: CALL 49305 0 2
// break ;
82858: GO 82862
// end ; end ;
82860: GO 82780
82862: POP
82863: POP
// end ; end_of_file
82864: LD_VAR 0 5
82868: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
82869: LD_INT 0
82871: PPUSH
// ar_miner := 81 ;
82872: LD_ADDR_EXP 74
82876: PUSH
82877: LD_INT 81
82879: ST_TO_ADDR
// ar_crane := 88 ;
82880: LD_ADDR_EXP 73
82884: PUSH
82885: LD_INT 88
82887: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
82888: LD_ADDR_EXP 68
82892: PUSH
82893: LD_INT 89
82895: ST_TO_ADDR
// us_hack := 99 ;
82896: LD_ADDR_EXP 69
82900: PUSH
82901: LD_INT 99
82903: ST_TO_ADDR
// us_artillery := 97 ;
82904: LD_ADDR_EXP 70
82908: PUSH
82909: LD_INT 97
82911: ST_TO_ADDR
// ar_bio_bomb := 91 ;
82912: LD_ADDR_EXP 71
82916: PUSH
82917: LD_INT 91
82919: ST_TO_ADDR
// ar_mortar := 92 ;
82920: LD_ADDR_EXP 72
82924: PUSH
82925: LD_INT 92
82927: ST_TO_ADDR
// ru_flamethrower := 93 ;
82928: LD_ADDR_EXP 75
82932: PUSH
82933: LD_INT 93
82935: ST_TO_ADDR
// ru_radar := 98 ;
82936: LD_ADDR_EXP 67
82940: PUSH
82941: LD_INT 98
82943: ST_TO_ADDR
// tech_Artillery := 80 ;
82944: LD_ADDR_EXP 76
82948: PUSH
82949: LD_INT 80
82951: ST_TO_ADDR
// tech_RadMat := 81 ;
82952: LD_ADDR_EXP 77
82956: PUSH
82957: LD_INT 81
82959: ST_TO_ADDR
// tech_BasicTools := 82 ;
82960: LD_ADDR_EXP 78
82964: PUSH
82965: LD_INT 82
82967: ST_TO_ADDR
// tech_Cargo := 83 ;
82968: LD_ADDR_EXP 79
82972: PUSH
82973: LD_INT 83
82975: ST_TO_ADDR
// tech_Track := 84 ;
82976: LD_ADDR_EXP 80
82980: PUSH
82981: LD_INT 84
82983: ST_TO_ADDR
// tech_Crane := 85 ;
82984: LD_ADDR_EXP 81
82988: PUSH
82989: LD_INT 85
82991: ST_TO_ADDR
// tech_Bulldozer := 86 ;
82992: LD_ADDR_EXP 82
82996: PUSH
82997: LD_INT 86
82999: ST_TO_ADDR
// tech_Hovercraft := 87 ;
83000: LD_ADDR_EXP 83
83004: PUSH
83005: LD_INT 87
83007: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
83008: LD_ADDR_EXP 84
83012: PUSH
83013: LD_INT 88
83015: ST_TO_ADDR
// end ;
83016: LD_VAR 0 1
83020: RET
// every 1 do
83021: GO 83023
83023: DISABLE
// InitGlobalVariables ; end_of_file
83024: CALL 82869 0 0
83028: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83029: LD_INT 0
83031: PPUSH
83032: PPUSH
83033: PPUSH
83034: PPUSH
83035: PPUSH
83036: PPUSH
83037: PPUSH
83038: PPUSH
83039: PPUSH
83040: PPUSH
83041: PPUSH
83042: PPUSH
83043: PPUSH
83044: PPUSH
83045: PPUSH
83046: PPUSH
83047: PPUSH
83048: PPUSH
83049: PPUSH
83050: PPUSH
83051: PPUSH
83052: PPUSH
83053: PPUSH
83054: PPUSH
83055: PPUSH
83056: PPUSH
83057: PPUSH
83058: PPUSH
83059: PPUSH
83060: PPUSH
83061: PPUSH
83062: PPUSH
83063: PPUSH
83064: PPUSH
// if not list then
83065: LD_VAR 0 1
83069: NOT
83070: IFFALSE 83074
// exit ;
83072: GO 87733
// base := list [ 1 ] ;
83074: LD_ADDR_VAR 0 3
83078: PUSH
83079: LD_VAR 0 1
83083: PUSH
83084: LD_INT 1
83086: ARRAY
83087: ST_TO_ADDR
// group := list [ 2 ] ;
83088: LD_ADDR_VAR 0 4
83092: PUSH
83093: LD_VAR 0 1
83097: PUSH
83098: LD_INT 2
83100: ARRAY
83101: ST_TO_ADDR
// path := list [ 3 ] ;
83102: LD_ADDR_VAR 0 5
83106: PUSH
83107: LD_VAR 0 1
83111: PUSH
83112: LD_INT 3
83114: ARRAY
83115: ST_TO_ADDR
// flags := list [ 4 ] ;
83116: LD_ADDR_VAR 0 6
83120: PUSH
83121: LD_VAR 0 1
83125: PUSH
83126: LD_INT 4
83128: ARRAY
83129: ST_TO_ADDR
// mined := [ ] ;
83130: LD_ADDR_VAR 0 27
83134: PUSH
83135: EMPTY
83136: ST_TO_ADDR
// bombed := [ ] ;
83137: LD_ADDR_VAR 0 28
83141: PUSH
83142: EMPTY
83143: ST_TO_ADDR
// healers := [ ] ;
83144: LD_ADDR_VAR 0 31
83148: PUSH
83149: EMPTY
83150: ST_TO_ADDR
// to_heal := [ ] ;
83151: LD_ADDR_VAR 0 30
83155: PUSH
83156: EMPTY
83157: ST_TO_ADDR
// repairs := [ ] ;
83158: LD_ADDR_VAR 0 33
83162: PUSH
83163: EMPTY
83164: ST_TO_ADDR
// to_repair := [ ] ;
83165: LD_ADDR_VAR 0 32
83169: PUSH
83170: EMPTY
83171: ST_TO_ADDR
// if not group or not path then
83172: LD_VAR 0 4
83176: NOT
83177: PUSH
83178: LD_VAR 0 5
83182: NOT
83183: OR
83184: IFFALSE 83188
// exit ;
83186: GO 87733
// side := GetSide ( group [ 1 ] ) ;
83188: LD_ADDR_VAR 0 35
83192: PUSH
83193: LD_VAR 0 4
83197: PUSH
83198: LD_INT 1
83200: ARRAY
83201: PPUSH
83202: CALL_OW 255
83206: ST_TO_ADDR
// if flags then
83207: LD_VAR 0 6
83211: IFFALSE 83355
// begin f_ignore_area := flags [ 1 ] ;
83213: LD_ADDR_VAR 0 17
83217: PUSH
83218: LD_VAR 0 6
83222: PUSH
83223: LD_INT 1
83225: ARRAY
83226: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83227: LD_ADDR_VAR 0 18
83231: PUSH
83232: LD_VAR 0 6
83236: PUSH
83237: LD_INT 2
83239: ARRAY
83240: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83241: LD_ADDR_VAR 0 19
83245: PUSH
83246: LD_VAR 0 6
83250: PUSH
83251: LD_INT 3
83253: ARRAY
83254: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83255: LD_ADDR_VAR 0 20
83259: PUSH
83260: LD_VAR 0 6
83264: PUSH
83265: LD_INT 4
83267: ARRAY
83268: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83269: LD_ADDR_VAR 0 21
83273: PUSH
83274: LD_VAR 0 6
83278: PUSH
83279: LD_INT 5
83281: ARRAY
83282: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83283: LD_ADDR_VAR 0 22
83287: PUSH
83288: LD_VAR 0 6
83292: PUSH
83293: LD_INT 6
83295: ARRAY
83296: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83297: LD_ADDR_VAR 0 23
83301: PUSH
83302: LD_VAR 0 6
83306: PUSH
83307: LD_INT 7
83309: ARRAY
83310: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83311: LD_ADDR_VAR 0 24
83315: PUSH
83316: LD_VAR 0 6
83320: PUSH
83321: LD_INT 8
83323: ARRAY
83324: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83325: LD_ADDR_VAR 0 25
83329: PUSH
83330: LD_VAR 0 6
83334: PUSH
83335: LD_INT 9
83337: ARRAY
83338: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83339: LD_ADDR_VAR 0 26
83343: PUSH
83344: LD_VAR 0 6
83348: PUSH
83349: LD_INT 10
83351: ARRAY
83352: ST_TO_ADDR
// end else
83353: GO 83435
// begin f_ignore_area := false ;
83355: LD_ADDR_VAR 0 17
83359: PUSH
83360: LD_INT 0
83362: ST_TO_ADDR
// f_capture := false ;
83363: LD_ADDR_VAR 0 18
83367: PUSH
83368: LD_INT 0
83370: ST_TO_ADDR
// f_ignore_civ := false ;
83371: LD_ADDR_VAR 0 19
83375: PUSH
83376: LD_INT 0
83378: ST_TO_ADDR
// f_murder := false ;
83379: LD_ADDR_VAR 0 20
83383: PUSH
83384: LD_INT 0
83386: ST_TO_ADDR
// f_mines := false ;
83387: LD_ADDR_VAR 0 21
83391: PUSH
83392: LD_INT 0
83394: ST_TO_ADDR
// f_repair := false ;
83395: LD_ADDR_VAR 0 22
83399: PUSH
83400: LD_INT 0
83402: ST_TO_ADDR
// f_heal := false ;
83403: LD_ADDR_VAR 0 23
83407: PUSH
83408: LD_INT 0
83410: ST_TO_ADDR
// f_spacetime := false ;
83411: LD_ADDR_VAR 0 24
83415: PUSH
83416: LD_INT 0
83418: ST_TO_ADDR
// f_attack_depot := false ;
83419: LD_ADDR_VAR 0 25
83423: PUSH
83424: LD_INT 0
83426: ST_TO_ADDR
// f_crawl := false ;
83427: LD_ADDR_VAR 0 26
83431: PUSH
83432: LD_INT 0
83434: ST_TO_ADDR
// end ; if f_heal then
83435: LD_VAR 0 23
83439: IFFALSE 83466
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83441: LD_ADDR_VAR 0 31
83445: PUSH
83446: LD_VAR 0 4
83450: PPUSH
83451: LD_INT 25
83453: PUSH
83454: LD_INT 4
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PPUSH
83461: CALL_OW 72
83465: ST_TO_ADDR
// if f_repair then
83466: LD_VAR 0 22
83470: IFFALSE 83497
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83472: LD_ADDR_VAR 0 33
83476: PUSH
83477: LD_VAR 0 4
83481: PPUSH
83482: LD_INT 25
83484: PUSH
83485: LD_INT 3
83487: PUSH
83488: EMPTY
83489: LIST
83490: LIST
83491: PPUSH
83492: CALL_OW 72
83496: ST_TO_ADDR
// units_path := [ ] ;
83497: LD_ADDR_VAR 0 16
83501: PUSH
83502: EMPTY
83503: ST_TO_ADDR
// for i = 1 to group do
83504: LD_ADDR_VAR 0 7
83508: PUSH
83509: DOUBLE
83510: LD_INT 1
83512: DEC
83513: ST_TO_ADDR
83514: LD_VAR 0 4
83518: PUSH
83519: FOR_TO
83520: IFFALSE 83549
// units_path := Replace ( units_path , i , path ) ;
83522: LD_ADDR_VAR 0 16
83526: PUSH
83527: LD_VAR 0 16
83531: PPUSH
83532: LD_VAR 0 7
83536: PPUSH
83537: LD_VAR 0 5
83541: PPUSH
83542: CALL_OW 1
83546: ST_TO_ADDR
83547: GO 83519
83549: POP
83550: POP
// repeat for i = group downto 1 do
83551: LD_ADDR_VAR 0 7
83555: PUSH
83556: DOUBLE
83557: LD_VAR 0 4
83561: INC
83562: ST_TO_ADDR
83563: LD_INT 1
83565: PUSH
83566: FOR_DOWNTO
83567: IFFALSE 87689
// begin wait ( 5 ) ;
83569: LD_INT 5
83571: PPUSH
83572: CALL_OW 67
// tmp := [ ] ;
83576: LD_ADDR_VAR 0 14
83580: PUSH
83581: EMPTY
83582: ST_TO_ADDR
// attacking := false ;
83583: LD_ADDR_VAR 0 29
83587: PUSH
83588: LD_INT 0
83590: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83591: LD_VAR 0 4
83595: PUSH
83596: LD_VAR 0 7
83600: ARRAY
83601: PPUSH
83602: CALL_OW 301
83606: PUSH
83607: LD_VAR 0 4
83611: PUSH
83612: LD_VAR 0 7
83616: ARRAY
83617: NOT
83618: OR
83619: IFFALSE 83728
// begin if GetType ( group [ i ] ) = unit_human then
83621: LD_VAR 0 4
83625: PUSH
83626: LD_VAR 0 7
83630: ARRAY
83631: PPUSH
83632: CALL_OW 247
83636: PUSH
83637: LD_INT 1
83639: EQUAL
83640: IFFALSE 83686
// begin to_heal := to_heal diff group [ i ] ;
83642: LD_ADDR_VAR 0 30
83646: PUSH
83647: LD_VAR 0 30
83651: PUSH
83652: LD_VAR 0 4
83656: PUSH
83657: LD_VAR 0 7
83661: ARRAY
83662: DIFF
83663: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83664: LD_ADDR_VAR 0 31
83668: PUSH
83669: LD_VAR 0 31
83673: PUSH
83674: LD_VAR 0 4
83678: PUSH
83679: LD_VAR 0 7
83683: ARRAY
83684: DIFF
83685: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83686: LD_ADDR_VAR 0 4
83690: PUSH
83691: LD_VAR 0 4
83695: PPUSH
83696: LD_VAR 0 7
83700: PPUSH
83701: CALL_OW 3
83705: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83706: LD_ADDR_VAR 0 16
83710: PUSH
83711: LD_VAR 0 16
83715: PPUSH
83716: LD_VAR 0 7
83720: PPUSH
83721: CALL_OW 3
83725: ST_TO_ADDR
// continue ;
83726: GO 83566
// end ; if f_repair then
83728: LD_VAR 0 22
83732: IFFALSE 84221
// begin if GetType ( group [ i ] ) = unit_vehicle then
83734: LD_VAR 0 4
83738: PUSH
83739: LD_VAR 0 7
83743: ARRAY
83744: PPUSH
83745: CALL_OW 247
83749: PUSH
83750: LD_INT 2
83752: EQUAL
83753: IFFALSE 83943
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83755: LD_VAR 0 4
83759: PUSH
83760: LD_VAR 0 7
83764: ARRAY
83765: PPUSH
83766: CALL_OW 256
83770: PUSH
83771: LD_INT 700
83773: LESS
83774: PUSH
83775: LD_VAR 0 4
83779: PUSH
83780: LD_VAR 0 7
83784: ARRAY
83785: PUSH
83786: LD_VAR 0 32
83790: IN
83791: NOT
83792: AND
83793: IFFALSE 83817
// to_repair := to_repair union group [ i ] ;
83795: LD_ADDR_VAR 0 32
83799: PUSH
83800: LD_VAR 0 32
83804: PUSH
83805: LD_VAR 0 4
83809: PUSH
83810: LD_VAR 0 7
83814: ARRAY
83815: UNION
83816: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83817: LD_VAR 0 4
83821: PUSH
83822: LD_VAR 0 7
83826: ARRAY
83827: PPUSH
83828: CALL_OW 256
83832: PUSH
83833: LD_INT 1000
83835: EQUAL
83836: PUSH
83837: LD_VAR 0 4
83841: PUSH
83842: LD_VAR 0 7
83846: ARRAY
83847: PUSH
83848: LD_VAR 0 32
83852: IN
83853: AND
83854: IFFALSE 83878
// to_repair := to_repair diff group [ i ] ;
83856: LD_ADDR_VAR 0 32
83860: PUSH
83861: LD_VAR 0 32
83865: PUSH
83866: LD_VAR 0 4
83870: PUSH
83871: LD_VAR 0 7
83875: ARRAY
83876: DIFF
83877: ST_TO_ADDR
// if group [ i ] in to_repair then
83878: LD_VAR 0 4
83882: PUSH
83883: LD_VAR 0 7
83887: ARRAY
83888: PUSH
83889: LD_VAR 0 32
83893: IN
83894: IFFALSE 83941
// begin if not IsInArea ( group [ i ] , f_repair ) then
83896: LD_VAR 0 4
83900: PUSH
83901: LD_VAR 0 7
83905: ARRAY
83906: PPUSH
83907: LD_VAR 0 22
83911: PPUSH
83912: CALL_OW 308
83916: NOT
83917: IFFALSE 83939
// ComMoveToArea ( group [ i ] , f_repair ) ;
83919: LD_VAR 0 4
83923: PUSH
83924: LD_VAR 0 7
83928: ARRAY
83929: PPUSH
83930: LD_VAR 0 22
83934: PPUSH
83935: CALL_OW 113
// continue ;
83939: GO 83566
// end ; end else
83941: GO 84221
// if group [ i ] in repairs then
83943: LD_VAR 0 4
83947: PUSH
83948: LD_VAR 0 7
83952: ARRAY
83953: PUSH
83954: LD_VAR 0 33
83958: IN
83959: IFFALSE 84221
// begin if IsInUnit ( group [ i ] ) then
83961: LD_VAR 0 4
83965: PUSH
83966: LD_VAR 0 7
83970: ARRAY
83971: PPUSH
83972: CALL_OW 310
83976: IFFALSE 84044
// begin z := IsInUnit ( group [ i ] ) ;
83978: LD_ADDR_VAR 0 13
83982: PUSH
83983: LD_VAR 0 4
83987: PUSH
83988: LD_VAR 0 7
83992: ARRAY
83993: PPUSH
83994: CALL_OW 310
83998: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
83999: LD_VAR 0 13
84003: PUSH
84004: LD_VAR 0 32
84008: IN
84009: PUSH
84010: LD_VAR 0 13
84014: PPUSH
84015: LD_VAR 0 22
84019: PPUSH
84020: CALL_OW 308
84024: AND
84025: IFFALSE 84042
// ComExitVehicle ( group [ i ] ) ;
84027: LD_VAR 0 4
84031: PUSH
84032: LD_VAR 0 7
84036: ARRAY
84037: PPUSH
84038: CALL_OW 121
// end else
84042: GO 84221
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84044: LD_ADDR_VAR 0 13
84048: PUSH
84049: LD_VAR 0 4
84053: PPUSH
84054: LD_INT 95
84056: PUSH
84057: LD_VAR 0 22
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 58
84068: PUSH
84069: EMPTY
84070: LIST
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PPUSH
84076: CALL_OW 72
84080: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84081: LD_VAR 0 4
84085: PUSH
84086: LD_VAR 0 7
84090: ARRAY
84091: PPUSH
84092: CALL_OW 314
84096: NOT
84097: IFFALSE 84219
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84099: LD_ADDR_VAR 0 10
84103: PUSH
84104: LD_VAR 0 13
84108: PPUSH
84109: LD_VAR 0 4
84113: PUSH
84114: LD_VAR 0 7
84118: ARRAY
84119: PPUSH
84120: CALL_OW 74
84124: ST_TO_ADDR
// if not x then
84125: LD_VAR 0 10
84129: NOT
84130: IFFALSE 84134
// continue ;
84132: GO 83566
// if GetLives ( x ) < 1000 then
84134: LD_VAR 0 10
84138: PPUSH
84139: CALL_OW 256
84143: PUSH
84144: LD_INT 1000
84146: LESS
84147: IFFALSE 84171
// ComRepairVehicle ( group [ i ] , x ) else
84149: LD_VAR 0 4
84153: PUSH
84154: LD_VAR 0 7
84158: ARRAY
84159: PPUSH
84160: LD_VAR 0 10
84164: PPUSH
84165: CALL_OW 129
84169: GO 84219
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84171: LD_VAR 0 23
84175: PUSH
84176: LD_VAR 0 4
84180: PUSH
84181: LD_VAR 0 7
84185: ARRAY
84186: PPUSH
84187: CALL_OW 256
84191: PUSH
84192: LD_INT 1000
84194: LESS
84195: AND
84196: NOT
84197: IFFALSE 84219
// ComEnterUnit ( group [ i ] , x ) ;
84199: LD_VAR 0 4
84203: PUSH
84204: LD_VAR 0 7
84208: ARRAY
84209: PPUSH
84210: LD_VAR 0 10
84214: PPUSH
84215: CALL_OW 120
// end ; continue ;
84219: GO 83566
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84221: LD_VAR 0 23
84225: PUSH
84226: LD_VAR 0 4
84230: PUSH
84231: LD_VAR 0 7
84235: ARRAY
84236: PPUSH
84237: CALL_OW 247
84241: PUSH
84242: LD_INT 1
84244: EQUAL
84245: AND
84246: IFFALSE 84724
// begin if group [ i ] in healers then
84248: LD_VAR 0 4
84252: PUSH
84253: LD_VAR 0 7
84257: ARRAY
84258: PUSH
84259: LD_VAR 0 31
84263: IN
84264: IFFALSE 84537
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84266: LD_VAR 0 4
84270: PUSH
84271: LD_VAR 0 7
84275: ARRAY
84276: PPUSH
84277: LD_VAR 0 23
84281: PPUSH
84282: CALL_OW 308
84286: NOT
84287: PUSH
84288: LD_VAR 0 4
84292: PUSH
84293: LD_VAR 0 7
84297: ARRAY
84298: PPUSH
84299: CALL_OW 314
84303: NOT
84304: AND
84305: IFFALSE 84329
// ComMoveToArea ( group [ i ] , f_heal ) else
84307: LD_VAR 0 4
84311: PUSH
84312: LD_VAR 0 7
84316: ARRAY
84317: PPUSH
84318: LD_VAR 0 23
84322: PPUSH
84323: CALL_OW 113
84327: GO 84535
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84329: LD_VAR 0 4
84333: PUSH
84334: LD_VAR 0 7
84338: ARRAY
84339: PPUSH
84340: CALL 45813 0 1
84344: PPUSH
84345: CALL_OW 256
84349: PUSH
84350: LD_INT 1000
84352: EQUAL
84353: IFFALSE 84372
// ComStop ( group [ i ] ) else
84355: LD_VAR 0 4
84359: PUSH
84360: LD_VAR 0 7
84364: ARRAY
84365: PPUSH
84366: CALL_OW 141
84370: GO 84535
// if not HasTask ( group [ i ] ) and to_heal then
84372: LD_VAR 0 4
84376: PUSH
84377: LD_VAR 0 7
84381: ARRAY
84382: PPUSH
84383: CALL_OW 314
84387: NOT
84388: PUSH
84389: LD_VAR 0 30
84393: AND
84394: IFFALSE 84535
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84396: LD_ADDR_VAR 0 13
84400: PUSH
84401: LD_VAR 0 30
84405: PPUSH
84406: LD_INT 3
84408: PUSH
84409: LD_INT 54
84411: PUSH
84412: EMPTY
84413: LIST
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PPUSH
84419: CALL_OW 72
84423: PPUSH
84424: LD_VAR 0 4
84428: PUSH
84429: LD_VAR 0 7
84433: ARRAY
84434: PPUSH
84435: CALL_OW 74
84439: ST_TO_ADDR
// if z then
84440: LD_VAR 0 13
84444: IFFALSE 84535
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84446: LD_INT 91
84448: PUSH
84449: LD_VAR 0 13
84453: PUSH
84454: LD_INT 10
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: LIST
84461: PUSH
84462: LD_INT 81
84464: PUSH
84465: LD_VAR 0 13
84469: PPUSH
84470: CALL_OW 255
84474: PUSH
84475: EMPTY
84476: LIST
84477: LIST
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: PPUSH
84483: CALL_OW 69
84487: PUSH
84488: LD_INT 0
84490: EQUAL
84491: IFFALSE 84515
// ComHeal ( group [ i ] , z ) else
84493: LD_VAR 0 4
84497: PUSH
84498: LD_VAR 0 7
84502: ARRAY
84503: PPUSH
84504: LD_VAR 0 13
84508: PPUSH
84509: CALL_OW 128
84513: GO 84535
// ComMoveToArea ( group [ i ] , f_heal ) ;
84515: LD_VAR 0 4
84519: PUSH
84520: LD_VAR 0 7
84524: ARRAY
84525: PPUSH
84526: LD_VAR 0 23
84530: PPUSH
84531: CALL_OW 113
// end ; continue ;
84535: GO 83566
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84537: LD_VAR 0 4
84541: PUSH
84542: LD_VAR 0 7
84546: ARRAY
84547: PPUSH
84548: CALL_OW 256
84552: PUSH
84553: LD_INT 700
84555: LESS
84556: PUSH
84557: LD_VAR 0 4
84561: PUSH
84562: LD_VAR 0 7
84566: ARRAY
84567: PUSH
84568: LD_VAR 0 30
84572: IN
84573: NOT
84574: AND
84575: IFFALSE 84599
// to_heal := to_heal union group [ i ] ;
84577: LD_ADDR_VAR 0 30
84581: PUSH
84582: LD_VAR 0 30
84586: PUSH
84587: LD_VAR 0 4
84591: PUSH
84592: LD_VAR 0 7
84596: ARRAY
84597: UNION
84598: ST_TO_ADDR
// if group [ i ] in to_heal then
84599: LD_VAR 0 4
84603: PUSH
84604: LD_VAR 0 7
84608: ARRAY
84609: PUSH
84610: LD_VAR 0 30
84614: IN
84615: IFFALSE 84724
// begin if GetLives ( group [ i ] ) = 1000 then
84617: LD_VAR 0 4
84621: PUSH
84622: LD_VAR 0 7
84626: ARRAY
84627: PPUSH
84628: CALL_OW 256
84632: PUSH
84633: LD_INT 1000
84635: EQUAL
84636: IFFALSE 84662
// to_heal := to_heal diff group [ i ] else
84638: LD_ADDR_VAR 0 30
84642: PUSH
84643: LD_VAR 0 30
84647: PUSH
84648: LD_VAR 0 4
84652: PUSH
84653: LD_VAR 0 7
84657: ARRAY
84658: DIFF
84659: ST_TO_ADDR
84660: GO 84724
// begin if not IsInArea ( group [ i ] , to_heal ) then
84662: LD_VAR 0 4
84666: PUSH
84667: LD_VAR 0 7
84671: ARRAY
84672: PPUSH
84673: LD_VAR 0 30
84677: PPUSH
84678: CALL_OW 308
84682: NOT
84683: IFFALSE 84707
// ComMoveToArea ( group [ i ] , f_heal ) else
84685: LD_VAR 0 4
84689: PUSH
84690: LD_VAR 0 7
84694: ARRAY
84695: PPUSH
84696: LD_VAR 0 23
84700: PPUSH
84701: CALL_OW 113
84705: GO 84722
// ComHold ( group [ i ] ) ;
84707: LD_VAR 0 4
84711: PUSH
84712: LD_VAR 0 7
84716: ARRAY
84717: PPUSH
84718: CALL_OW 140
// continue ;
84722: GO 83566
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84724: LD_VAR 0 4
84728: PUSH
84729: LD_VAR 0 7
84733: ARRAY
84734: PPUSH
84735: LD_INT 10
84737: PPUSH
84738: CALL 43666 0 2
84742: NOT
84743: PUSH
84744: LD_VAR 0 16
84748: PUSH
84749: LD_VAR 0 7
84753: ARRAY
84754: PUSH
84755: EMPTY
84756: EQUAL
84757: NOT
84758: AND
84759: IFFALSE 85025
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84761: LD_VAR 0 4
84765: PUSH
84766: LD_VAR 0 7
84770: ARRAY
84771: PPUSH
84772: CALL_OW 262
84776: PUSH
84777: LD_INT 1
84779: PUSH
84780: LD_INT 2
84782: PUSH
84783: EMPTY
84784: LIST
84785: LIST
84786: IN
84787: IFFALSE 84828
// if GetFuel ( group [ i ] ) < 10 then
84789: LD_VAR 0 4
84793: PUSH
84794: LD_VAR 0 7
84798: ARRAY
84799: PPUSH
84800: CALL_OW 261
84804: PUSH
84805: LD_INT 10
84807: LESS
84808: IFFALSE 84828
// SetFuel ( group [ i ] , 12 ) ;
84810: LD_VAR 0 4
84814: PUSH
84815: LD_VAR 0 7
84819: ARRAY
84820: PPUSH
84821: LD_INT 12
84823: PPUSH
84824: CALL_OW 240
// if units_path [ i ] then
84828: LD_VAR 0 16
84832: PUSH
84833: LD_VAR 0 7
84837: ARRAY
84838: IFFALSE 85023
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84840: LD_VAR 0 4
84844: PUSH
84845: LD_VAR 0 7
84849: ARRAY
84850: PPUSH
84851: LD_VAR 0 16
84855: PUSH
84856: LD_VAR 0 7
84860: ARRAY
84861: PUSH
84862: LD_INT 1
84864: ARRAY
84865: PUSH
84866: LD_INT 1
84868: ARRAY
84869: PPUSH
84870: LD_VAR 0 16
84874: PUSH
84875: LD_VAR 0 7
84879: ARRAY
84880: PUSH
84881: LD_INT 1
84883: ARRAY
84884: PUSH
84885: LD_INT 2
84887: ARRAY
84888: PPUSH
84889: CALL_OW 297
84893: PUSH
84894: LD_INT 6
84896: GREATER
84897: IFFALSE 84972
// begin if not HasTask ( group [ i ] ) then
84899: LD_VAR 0 4
84903: PUSH
84904: LD_VAR 0 7
84908: ARRAY
84909: PPUSH
84910: CALL_OW 314
84914: NOT
84915: IFFALSE 84970
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84917: LD_VAR 0 4
84921: PUSH
84922: LD_VAR 0 7
84926: ARRAY
84927: PPUSH
84928: LD_VAR 0 16
84932: PUSH
84933: LD_VAR 0 7
84937: ARRAY
84938: PUSH
84939: LD_INT 1
84941: ARRAY
84942: PUSH
84943: LD_INT 1
84945: ARRAY
84946: PPUSH
84947: LD_VAR 0 16
84951: PUSH
84952: LD_VAR 0 7
84956: ARRAY
84957: PUSH
84958: LD_INT 1
84960: ARRAY
84961: PUSH
84962: LD_INT 2
84964: ARRAY
84965: PPUSH
84966: CALL_OW 114
// end else
84970: GO 85023
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
84972: LD_ADDR_VAR 0 15
84976: PUSH
84977: LD_VAR 0 16
84981: PUSH
84982: LD_VAR 0 7
84986: ARRAY
84987: PPUSH
84988: LD_INT 1
84990: PPUSH
84991: CALL_OW 3
84995: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
84996: LD_ADDR_VAR 0 16
85000: PUSH
85001: LD_VAR 0 16
85005: PPUSH
85006: LD_VAR 0 7
85010: PPUSH
85011: LD_VAR 0 15
85015: PPUSH
85016: CALL_OW 1
85020: ST_TO_ADDR
// continue ;
85021: GO 83566
// end ; end ; end else
85023: GO 87687
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85025: LD_ADDR_VAR 0 14
85029: PUSH
85030: LD_INT 81
85032: PUSH
85033: LD_VAR 0 4
85037: PUSH
85038: LD_VAR 0 7
85042: ARRAY
85043: PPUSH
85044: CALL_OW 255
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PPUSH
85053: CALL_OW 69
85057: ST_TO_ADDR
// if not tmp then
85058: LD_VAR 0 14
85062: NOT
85063: IFFALSE 85067
// continue ;
85065: GO 83566
// if f_ignore_area then
85067: LD_VAR 0 17
85071: IFFALSE 85159
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85073: LD_ADDR_VAR 0 15
85077: PUSH
85078: LD_VAR 0 14
85082: PPUSH
85083: LD_INT 3
85085: PUSH
85086: LD_INT 92
85088: PUSH
85089: LD_VAR 0 17
85093: PUSH
85094: LD_INT 1
85096: ARRAY
85097: PUSH
85098: LD_VAR 0 17
85102: PUSH
85103: LD_INT 2
85105: ARRAY
85106: PUSH
85107: LD_VAR 0 17
85111: PUSH
85112: LD_INT 3
85114: ARRAY
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: PPUSH
85126: CALL_OW 72
85130: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85131: LD_VAR 0 14
85135: PUSH
85136: LD_VAR 0 15
85140: DIFF
85141: IFFALSE 85159
// tmp := tmp diff tmp2 ;
85143: LD_ADDR_VAR 0 14
85147: PUSH
85148: LD_VAR 0 14
85152: PUSH
85153: LD_VAR 0 15
85157: DIFF
85158: ST_TO_ADDR
// end ; if not f_murder then
85159: LD_VAR 0 20
85163: NOT
85164: IFFALSE 85222
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85166: LD_ADDR_VAR 0 15
85170: PUSH
85171: LD_VAR 0 14
85175: PPUSH
85176: LD_INT 3
85178: PUSH
85179: LD_INT 50
85181: PUSH
85182: EMPTY
85183: LIST
85184: PUSH
85185: EMPTY
85186: LIST
85187: LIST
85188: PPUSH
85189: CALL_OW 72
85193: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85194: LD_VAR 0 14
85198: PUSH
85199: LD_VAR 0 15
85203: DIFF
85204: IFFALSE 85222
// tmp := tmp diff tmp2 ;
85206: LD_ADDR_VAR 0 14
85210: PUSH
85211: LD_VAR 0 14
85215: PUSH
85216: LD_VAR 0 15
85220: DIFF
85221: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85222: LD_ADDR_VAR 0 14
85226: PUSH
85227: LD_VAR 0 4
85231: PUSH
85232: LD_VAR 0 7
85236: ARRAY
85237: PPUSH
85238: LD_VAR 0 14
85242: PPUSH
85243: LD_INT 1
85245: PPUSH
85246: LD_INT 1
85248: PPUSH
85249: CALL 16601 0 4
85253: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85254: LD_VAR 0 4
85258: PUSH
85259: LD_VAR 0 7
85263: ARRAY
85264: PPUSH
85265: CALL_OW 257
85269: PUSH
85270: LD_INT 1
85272: EQUAL
85273: IFFALSE 85721
// begin if WantPlant ( group [ i ] ) then
85275: LD_VAR 0 4
85279: PUSH
85280: LD_VAR 0 7
85284: ARRAY
85285: PPUSH
85286: CALL 16102 0 1
85290: IFFALSE 85294
// continue ;
85292: GO 83566
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85294: LD_VAR 0 18
85298: PUSH
85299: LD_VAR 0 4
85303: PUSH
85304: LD_VAR 0 7
85308: ARRAY
85309: PPUSH
85310: CALL_OW 310
85314: NOT
85315: AND
85316: PUSH
85317: LD_VAR 0 14
85321: PUSH
85322: LD_INT 1
85324: ARRAY
85325: PUSH
85326: LD_VAR 0 14
85330: PPUSH
85331: LD_INT 21
85333: PUSH
85334: LD_INT 2
85336: PUSH
85337: EMPTY
85338: LIST
85339: LIST
85340: PUSH
85341: LD_INT 58
85343: PUSH
85344: EMPTY
85345: LIST
85346: PUSH
85347: EMPTY
85348: LIST
85349: LIST
85350: PPUSH
85351: CALL_OW 72
85355: IN
85356: AND
85357: IFFALSE 85393
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85359: LD_VAR 0 4
85363: PUSH
85364: LD_VAR 0 7
85368: ARRAY
85369: PPUSH
85370: LD_VAR 0 14
85374: PUSH
85375: LD_INT 1
85377: ARRAY
85378: PPUSH
85379: CALL_OW 120
// attacking := true ;
85383: LD_ADDR_VAR 0 29
85387: PUSH
85388: LD_INT 1
85390: ST_TO_ADDR
// continue ;
85391: GO 83566
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85393: LD_VAR 0 26
85397: PUSH
85398: LD_VAR 0 4
85402: PUSH
85403: LD_VAR 0 7
85407: ARRAY
85408: PPUSH
85409: CALL_OW 257
85413: PUSH
85414: LD_INT 1
85416: EQUAL
85417: AND
85418: PUSH
85419: LD_VAR 0 4
85423: PUSH
85424: LD_VAR 0 7
85428: ARRAY
85429: PPUSH
85430: CALL_OW 256
85434: PUSH
85435: LD_INT 800
85437: LESS
85438: AND
85439: PUSH
85440: LD_VAR 0 4
85444: PUSH
85445: LD_VAR 0 7
85449: ARRAY
85450: PPUSH
85451: CALL_OW 318
85455: NOT
85456: AND
85457: IFFALSE 85474
// ComCrawl ( group [ i ] ) ;
85459: LD_VAR 0 4
85463: PUSH
85464: LD_VAR 0 7
85468: ARRAY
85469: PPUSH
85470: CALL_OW 137
// if f_mines then
85474: LD_VAR 0 21
85478: IFFALSE 85721
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85480: LD_VAR 0 14
85484: PUSH
85485: LD_INT 1
85487: ARRAY
85488: PPUSH
85489: CALL_OW 247
85493: PUSH
85494: LD_INT 3
85496: EQUAL
85497: PUSH
85498: LD_VAR 0 14
85502: PUSH
85503: LD_INT 1
85505: ARRAY
85506: PUSH
85507: LD_VAR 0 27
85511: IN
85512: NOT
85513: AND
85514: IFFALSE 85721
// begin x := GetX ( tmp [ 1 ] ) ;
85516: LD_ADDR_VAR 0 10
85520: PUSH
85521: LD_VAR 0 14
85525: PUSH
85526: LD_INT 1
85528: ARRAY
85529: PPUSH
85530: CALL_OW 250
85534: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85535: LD_ADDR_VAR 0 11
85539: PUSH
85540: LD_VAR 0 14
85544: PUSH
85545: LD_INT 1
85547: ARRAY
85548: PPUSH
85549: CALL_OW 251
85553: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85554: LD_ADDR_VAR 0 12
85558: PUSH
85559: LD_VAR 0 4
85563: PUSH
85564: LD_VAR 0 7
85568: ARRAY
85569: PPUSH
85570: CALL 43751 0 1
85574: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85575: LD_VAR 0 4
85579: PUSH
85580: LD_VAR 0 7
85584: ARRAY
85585: PPUSH
85586: LD_VAR 0 10
85590: PPUSH
85591: LD_VAR 0 11
85595: PPUSH
85596: LD_VAR 0 14
85600: PUSH
85601: LD_INT 1
85603: ARRAY
85604: PPUSH
85605: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85609: LD_VAR 0 4
85613: PUSH
85614: LD_VAR 0 7
85618: ARRAY
85619: PPUSH
85620: LD_VAR 0 10
85624: PPUSH
85625: LD_VAR 0 12
85629: PPUSH
85630: LD_INT 7
85632: PPUSH
85633: CALL_OW 272
85637: PPUSH
85638: LD_VAR 0 11
85642: PPUSH
85643: LD_VAR 0 12
85647: PPUSH
85648: LD_INT 7
85650: PPUSH
85651: CALL_OW 273
85655: PPUSH
85656: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85660: LD_VAR 0 4
85664: PUSH
85665: LD_VAR 0 7
85669: ARRAY
85670: PPUSH
85671: LD_INT 71
85673: PPUSH
85674: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85678: LD_ADDR_VAR 0 27
85682: PUSH
85683: LD_VAR 0 27
85687: PPUSH
85688: LD_VAR 0 27
85692: PUSH
85693: LD_INT 1
85695: PLUS
85696: PPUSH
85697: LD_VAR 0 14
85701: PUSH
85702: LD_INT 1
85704: ARRAY
85705: PPUSH
85706: CALL_OW 1
85710: ST_TO_ADDR
// attacking := true ;
85711: LD_ADDR_VAR 0 29
85715: PUSH
85716: LD_INT 1
85718: ST_TO_ADDR
// continue ;
85719: GO 83566
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85721: LD_VAR 0 4
85725: PUSH
85726: LD_VAR 0 7
85730: ARRAY
85731: PPUSH
85732: CALL_OW 257
85736: PUSH
85737: LD_INT 17
85739: EQUAL
85740: PUSH
85741: LD_VAR 0 4
85745: PUSH
85746: LD_VAR 0 7
85750: ARRAY
85751: PPUSH
85752: CALL_OW 110
85756: PUSH
85757: LD_INT 71
85759: EQUAL
85760: NOT
85761: AND
85762: IFFALSE 85908
// begin attacking := false ;
85764: LD_ADDR_VAR 0 29
85768: PUSH
85769: LD_INT 0
85771: ST_TO_ADDR
// k := 5 ;
85772: LD_ADDR_VAR 0 9
85776: PUSH
85777: LD_INT 5
85779: ST_TO_ADDR
// if tmp < k then
85780: LD_VAR 0 14
85784: PUSH
85785: LD_VAR 0 9
85789: LESS
85790: IFFALSE 85802
// k := tmp ;
85792: LD_ADDR_VAR 0 9
85796: PUSH
85797: LD_VAR 0 14
85801: ST_TO_ADDR
// for j = 1 to k do
85802: LD_ADDR_VAR 0 8
85806: PUSH
85807: DOUBLE
85808: LD_INT 1
85810: DEC
85811: ST_TO_ADDR
85812: LD_VAR 0 9
85816: PUSH
85817: FOR_TO
85818: IFFALSE 85906
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85820: LD_VAR 0 14
85824: PUSH
85825: LD_VAR 0 8
85829: ARRAY
85830: PUSH
85831: LD_VAR 0 14
85835: PPUSH
85836: LD_INT 58
85838: PUSH
85839: EMPTY
85840: LIST
85841: PPUSH
85842: CALL_OW 72
85846: IN
85847: NOT
85848: IFFALSE 85904
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85850: LD_VAR 0 4
85854: PUSH
85855: LD_VAR 0 7
85859: ARRAY
85860: PPUSH
85861: LD_VAR 0 14
85865: PUSH
85866: LD_VAR 0 8
85870: ARRAY
85871: PPUSH
85872: CALL_OW 115
// attacking := true ;
85876: LD_ADDR_VAR 0 29
85880: PUSH
85881: LD_INT 1
85883: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85884: LD_VAR 0 4
85888: PUSH
85889: LD_VAR 0 7
85893: ARRAY
85894: PPUSH
85895: LD_INT 71
85897: PPUSH
85898: CALL_OW 109
// continue ;
85902: GO 85817
// end ; end ;
85904: GO 85817
85906: POP
85907: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85908: LD_VAR 0 4
85912: PUSH
85913: LD_VAR 0 7
85917: ARRAY
85918: PPUSH
85919: CALL_OW 257
85923: PUSH
85924: LD_INT 8
85926: EQUAL
85927: PUSH
85928: LD_VAR 0 4
85932: PUSH
85933: LD_VAR 0 7
85937: ARRAY
85938: PPUSH
85939: CALL_OW 264
85943: PUSH
85944: LD_INT 28
85946: PUSH
85947: LD_INT 45
85949: PUSH
85950: LD_INT 7
85952: PUSH
85953: LD_INT 47
85955: PUSH
85956: EMPTY
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: IN
85962: OR
85963: IFFALSE 86219
// begin attacking := false ;
85965: LD_ADDR_VAR 0 29
85969: PUSH
85970: LD_INT 0
85972: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
85973: LD_VAR 0 14
85977: PUSH
85978: LD_INT 1
85980: ARRAY
85981: PPUSH
85982: CALL_OW 266
85986: PUSH
85987: LD_INT 32
85989: PUSH
85990: LD_INT 31
85992: PUSH
85993: LD_INT 33
85995: PUSH
85996: LD_INT 4
85998: PUSH
85999: LD_INT 5
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: IN
86009: IFFALSE 86195
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
86011: LD_ADDR_VAR 0 9
86015: PUSH
86016: LD_VAR 0 14
86020: PUSH
86021: LD_INT 1
86023: ARRAY
86024: PPUSH
86025: CALL_OW 266
86029: PPUSH
86030: LD_VAR 0 14
86034: PUSH
86035: LD_INT 1
86037: ARRAY
86038: PPUSH
86039: CALL_OW 250
86043: PPUSH
86044: LD_VAR 0 14
86048: PUSH
86049: LD_INT 1
86051: ARRAY
86052: PPUSH
86053: CALL_OW 251
86057: PPUSH
86058: LD_VAR 0 14
86062: PUSH
86063: LD_INT 1
86065: ARRAY
86066: PPUSH
86067: CALL_OW 254
86071: PPUSH
86072: LD_VAR 0 14
86076: PUSH
86077: LD_INT 1
86079: ARRAY
86080: PPUSH
86081: CALL_OW 248
86085: PPUSH
86086: LD_INT 0
86088: PPUSH
86089: CALL 25121 0 6
86093: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86094: LD_ADDR_VAR 0 8
86098: PUSH
86099: LD_VAR 0 4
86103: PUSH
86104: LD_VAR 0 7
86108: ARRAY
86109: PPUSH
86110: LD_VAR 0 9
86114: PPUSH
86115: CALL 43791 0 2
86119: ST_TO_ADDR
// if j then
86120: LD_VAR 0 8
86124: IFFALSE 86193
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86126: LD_VAR 0 8
86130: PUSH
86131: LD_INT 1
86133: ARRAY
86134: PPUSH
86135: LD_VAR 0 8
86139: PUSH
86140: LD_INT 2
86142: ARRAY
86143: PPUSH
86144: CALL_OW 488
86148: IFFALSE 86193
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86150: LD_VAR 0 4
86154: PUSH
86155: LD_VAR 0 7
86159: ARRAY
86160: PPUSH
86161: LD_VAR 0 8
86165: PUSH
86166: LD_INT 1
86168: ARRAY
86169: PPUSH
86170: LD_VAR 0 8
86174: PUSH
86175: LD_INT 2
86177: ARRAY
86178: PPUSH
86179: CALL_OW 116
// attacking := true ;
86183: LD_ADDR_VAR 0 29
86187: PUSH
86188: LD_INT 1
86190: ST_TO_ADDR
// continue ;
86191: GO 83566
// end ; end else
86193: GO 86219
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86195: LD_VAR 0 4
86199: PUSH
86200: LD_VAR 0 7
86204: ARRAY
86205: PPUSH
86206: LD_VAR 0 14
86210: PUSH
86211: LD_INT 1
86213: ARRAY
86214: PPUSH
86215: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86219: LD_VAR 0 4
86223: PUSH
86224: LD_VAR 0 7
86228: ARRAY
86229: PPUSH
86230: CALL_OW 265
86234: PUSH
86235: LD_INT 11
86237: EQUAL
86238: IFFALSE 86516
// begin k := 10 ;
86240: LD_ADDR_VAR 0 9
86244: PUSH
86245: LD_INT 10
86247: ST_TO_ADDR
// x := 0 ;
86248: LD_ADDR_VAR 0 10
86252: PUSH
86253: LD_INT 0
86255: ST_TO_ADDR
// if tmp < k then
86256: LD_VAR 0 14
86260: PUSH
86261: LD_VAR 0 9
86265: LESS
86266: IFFALSE 86278
// k := tmp ;
86268: LD_ADDR_VAR 0 9
86272: PUSH
86273: LD_VAR 0 14
86277: ST_TO_ADDR
// for j = k downto 1 do
86278: LD_ADDR_VAR 0 8
86282: PUSH
86283: DOUBLE
86284: LD_VAR 0 9
86288: INC
86289: ST_TO_ADDR
86290: LD_INT 1
86292: PUSH
86293: FOR_DOWNTO
86294: IFFALSE 86369
// begin if GetType ( tmp [ j ] ) = unit_human then
86296: LD_VAR 0 14
86300: PUSH
86301: LD_VAR 0 8
86305: ARRAY
86306: PPUSH
86307: CALL_OW 247
86311: PUSH
86312: LD_INT 1
86314: EQUAL
86315: IFFALSE 86367
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86317: LD_VAR 0 4
86321: PUSH
86322: LD_VAR 0 7
86326: ARRAY
86327: PPUSH
86328: LD_VAR 0 14
86332: PUSH
86333: LD_VAR 0 8
86337: ARRAY
86338: PPUSH
86339: CALL 44062 0 2
// x := tmp [ j ] ;
86343: LD_ADDR_VAR 0 10
86347: PUSH
86348: LD_VAR 0 14
86352: PUSH
86353: LD_VAR 0 8
86357: ARRAY
86358: ST_TO_ADDR
// attacking := true ;
86359: LD_ADDR_VAR 0 29
86363: PUSH
86364: LD_INT 1
86366: ST_TO_ADDR
// end ; end ;
86367: GO 86293
86369: POP
86370: POP
// if not x then
86371: LD_VAR 0 10
86375: NOT
86376: IFFALSE 86516
// begin attacking := true ;
86378: LD_ADDR_VAR 0 29
86382: PUSH
86383: LD_INT 1
86385: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86386: LD_VAR 0 4
86390: PUSH
86391: LD_VAR 0 7
86395: ARRAY
86396: PPUSH
86397: CALL_OW 250
86401: PPUSH
86402: LD_VAR 0 4
86406: PUSH
86407: LD_VAR 0 7
86411: ARRAY
86412: PPUSH
86413: CALL_OW 251
86417: PPUSH
86418: CALL_OW 546
86422: PUSH
86423: LD_INT 2
86425: ARRAY
86426: PUSH
86427: LD_VAR 0 14
86431: PUSH
86432: LD_INT 1
86434: ARRAY
86435: PPUSH
86436: CALL_OW 250
86440: PPUSH
86441: LD_VAR 0 14
86445: PUSH
86446: LD_INT 1
86448: ARRAY
86449: PPUSH
86450: CALL_OW 251
86454: PPUSH
86455: CALL_OW 546
86459: PUSH
86460: LD_INT 2
86462: ARRAY
86463: EQUAL
86464: IFFALSE 86492
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86466: LD_VAR 0 4
86470: PUSH
86471: LD_VAR 0 7
86475: ARRAY
86476: PPUSH
86477: LD_VAR 0 14
86481: PUSH
86482: LD_INT 1
86484: ARRAY
86485: PPUSH
86486: CALL 44062 0 2
86490: GO 86516
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86492: LD_VAR 0 4
86496: PUSH
86497: LD_VAR 0 7
86501: ARRAY
86502: PPUSH
86503: LD_VAR 0 14
86507: PUSH
86508: LD_INT 1
86510: ARRAY
86511: PPUSH
86512: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86516: LD_VAR 0 4
86520: PUSH
86521: LD_VAR 0 7
86525: ARRAY
86526: PPUSH
86527: CALL_OW 264
86531: PUSH
86532: LD_INT 29
86534: EQUAL
86535: IFFALSE 86901
// begin if WantsToAttack ( group [ i ] ) in bombed then
86537: LD_VAR 0 4
86541: PUSH
86542: LD_VAR 0 7
86546: ARRAY
86547: PPUSH
86548: CALL_OW 319
86552: PUSH
86553: LD_VAR 0 28
86557: IN
86558: IFFALSE 86562
// continue ;
86560: GO 83566
// k := 8 ;
86562: LD_ADDR_VAR 0 9
86566: PUSH
86567: LD_INT 8
86569: ST_TO_ADDR
// x := 0 ;
86570: LD_ADDR_VAR 0 10
86574: PUSH
86575: LD_INT 0
86577: ST_TO_ADDR
// if tmp < k then
86578: LD_VAR 0 14
86582: PUSH
86583: LD_VAR 0 9
86587: LESS
86588: IFFALSE 86600
// k := tmp ;
86590: LD_ADDR_VAR 0 9
86594: PUSH
86595: LD_VAR 0 14
86599: ST_TO_ADDR
// for j = 1 to k do
86600: LD_ADDR_VAR 0 8
86604: PUSH
86605: DOUBLE
86606: LD_INT 1
86608: DEC
86609: ST_TO_ADDR
86610: LD_VAR 0 9
86614: PUSH
86615: FOR_TO
86616: IFFALSE 86748
// begin if GetType ( tmp [ j ] ) = unit_building then
86618: LD_VAR 0 14
86622: PUSH
86623: LD_VAR 0 8
86627: ARRAY
86628: PPUSH
86629: CALL_OW 247
86633: PUSH
86634: LD_INT 3
86636: EQUAL
86637: IFFALSE 86746
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86639: LD_VAR 0 14
86643: PUSH
86644: LD_VAR 0 8
86648: ARRAY
86649: PUSH
86650: LD_VAR 0 28
86654: IN
86655: NOT
86656: PUSH
86657: LD_VAR 0 14
86661: PUSH
86662: LD_VAR 0 8
86666: ARRAY
86667: PPUSH
86668: CALL_OW 313
86672: AND
86673: IFFALSE 86746
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86675: LD_VAR 0 4
86679: PUSH
86680: LD_VAR 0 7
86684: ARRAY
86685: PPUSH
86686: LD_VAR 0 14
86690: PUSH
86691: LD_VAR 0 8
86695: ARRAY
86696: PPUSH
86697: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86701: LD_ADDR_VAR 0 28
86705: PUSH
86706: LD_VAR 0 28
86710: PPUSH
86711: LD_VAR 0 28
86715: PUSH
86716: LD_INT 1
86718: PLUS
86719: PPUSH
86720: LD_VAR 0 14
86724: PUSH
86725: LD_VAR 0 8
86729: ARRAY
86730: PPUSH
86731: CALL_OW 1
86735: ST_TO_ADDR
// attacking := true ;
86736: LD_ADDR_VAR 0 29
86740: PUSH
86741: LD_INT 1
86743: ST_TO_ADDR
// break ;
86744: GO 86748
// end ; end ;
86746: GO 86615
86748: POP
86749: POP
// if not attacking and f_attack_depot then
86750: LD_VAR 0 29
86754: NOT
86755: PUSH
86756: LD_VAR 0 25
86760: AND
86761: IFFALSE 86856
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86763: LD_ADDR_VAR 0 13
86767: PUSH
86768: LD_VAR 0 14
86772: PPUSH
86773: LD_INT 2
86775: PUSH
86776: LD_INT 30
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 30
86788: PUSH
86789: LD_INT 1
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: LIST
86800: PPUSH
86801: CALL_OW 72
86805: ST_TO_ADDR
// if z then
86806: LD_VAR 0 13
86810: IFFALSE 86856
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86812: LD_VAR 0 4
86816: PUSH
86817: LD_VAR 0 7
86821: ARRAY
86822: PPUSH
86823: LD_VAR 0 13
86827: PPUSH
86828: LD_VAR 0 4
86832: PUSH
86833: LD_VAR 0 7
86837: ARRAY
86838: PPUSH
86839: CALL_OW 74
86843: PPUSH
86844: CALL_OW 115
// attacking := true ;
86848: LD_ADDR_VAR 0 29
86852: PUSH
86853: LD_INT 1
86855: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86856: LD_VAR 0 4
86860: PUSH
86861: LD_VAR 0 7
86865: ARRAY
86866: PPUSH
86867: CALL_OW 256
86871: PUSH
86872: LD_INT 500
86874: LESS
86875: IFFALSE 86901
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86877: LD_VAR 0 4
86881: PUSH
86882: LD_VAR 0 7
86886: ARRAY
86887: PPUSH
86888: LD_VAR 0 14
86892: PUSH
86893: LD_INT 1
86895: ARRAY
86896: PPUSH
86897: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86901: LD_VAR 0 4
86905: PUSH
86906: LD_VAR 0 7
86910: ARRAY
86911: PPUSH
86912: CALL_OW 264
86916: PUSH
86917: LD_INT 49
86919: EQUAL
86920: IFFALSE 87041
// begin if not HasTask ( group [ i ] ) then
86922: LD_VAR 0 4
86926: PUSH
86927: LD_VAR 0 7
86931: ARRAY
86932: PPUSH
86933: CALL_OW 314
86937: NOT
86938: IFFALSE 87041
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86940: LD_ADDR_VAR 0 9
86944: PUSH
86945: LD_INT 81
86947: PUSH
86948: LD_VAR 0 4
86952: PUSH
86953: LD_VAR 0 7
86957: ARRAY
86958: PPUSH
86959: CALL_OW 255
86963: PUSH
86964: EMPTY
86965: LIST
86966: LIST
86967: PPUSH
86968: CALL_OW 69
86972: PPUSH
86973: LD_VAR 0 4
86977: PUSH
86978: LD_VAR 0 7
86982: ARRAY
86983: PPUSH
86984: CALL_OW 74
86988: ST_TO_ADDR
// if k then
86989: LD_VAR 0 9
86993: IFFALSE 87041
// if GetDistUnits ( group [ i ] , k ) > 10 then
86995: LD_VAR 0 4
86999: PUSH
87000: LD_VAR 0 7
87004: ARRAY
87005: PPUSH
87006: LD_VAR 0 9
87010: PPUSH
87011: CALL_OW 296
87015: PUSH
87016: LD_INT 10
87018: GREATER
87019: IFFALSE 87041
// ComMoveUnit ( group [ i ] , k ) ;
87021: LD_VAR 0 4
87025: PUSH
87026: LD_VAR 0 7
87030: ARRAY
87031: PPUSH
87032: LD_VAR 0 9
87036: PPUSH
87037: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87041: LD_VAR 0 4
87045: PUSH
87046: LD_VAR 0 7
87050: ARRAY
87051: PPUSH
87052: CALL_OW 256
87056: PUSH
87057: LD_INT 250
87059: LESS
87060: PUSH
87061: LD_VAR 0 4
87065: PUSH
87066: LD_VAR 0 7
87070: ARRAY
87071: PUSH
87072: LD_INT 21
87074: PUSH
87075: LD_INT 2
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 23
87084: PUSH
87085: LD_INT 2
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PPUSH
87096: CALL_OW 69
87100: IN
87101: AND
87102: IFFALSE 87227
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87104: LD_ADDR_VAR 0 9
87108: PUSH
87109: LD_OWVAR 3
87113: PUSH
87114: LD_VAR 0 4
87118: PUSH
87119: LD_VAR 0 7
87123: ARRAY
87124: DIFF
87125: PPUSH
87126: LD_VAR 0 4
87130: PUSH
87131: LD_VAR 0 7
87135: ARRAY
87136: PPUSH
87137: CALL_OW 74
87141: ST_TO_ADDR
// if not k then
87142: LD_VAR 0 9
87146: NOT
87147: IFFALSE 87151
// continue ;
87149: GO 83566
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87151: LD_VAR 0 9
87155: PUSH
87156: LD_INT 81
87158: PUSH
87159: LD_VAR 0 4
87163: PUSH
87164: LD_VAR 0 7
87168: ARRAY
87169: PPUSH
87170: CALL_OW 255
87174: PUSH
87175: EMPTY
87176: LIST
87177: LIST
87178: PPUSH
87179: CALL_OW 69
87183: IN
87184: PUSH
87185: LD_VAR 0 9
87189: PPUSH
87190: LD_VAR 0 4
87194: PUSH
87195: LD_VAR 0 7
87199: ARRAY
87200: PPUSH
87201: CALL_OW 296
87205: PUSH
87206: LD_INT 5
87208: LESS
87209: AND
87210: IFFALSE 87227
// ComAutodestruct ( group [ i ] ) ;
87212: LD_VAR 0 4
87216: PUSH
87217: LD_VAR 0 7
87221: ARRAY
87222: PPUSH
87223: CALL 43960 0 1
// end ; if f_attack_depot then
87227: LD_VAR 0 25
87231: IFFALSE 87343
// begin k := 6 ;
87233: LD_ADDR_VAR 0 9
87237: PUSH
87238: LD_INT 6
87240: ST_TO_ADDR
// if tmp < k then
87241: LD_VAR 0 14
87245: PUSH
87246: LD_VAR 0 9
87250: LESS
87251: IFFALSE 87263
// k := tmp ;
87253: LD_ADDR_VAR 0 9
87257: PUSH
87258: LD_VAR 0 14
87262: ST_TO_ADDR
// for j = 1 to k do
87263: LD_ADDR_VAR 0 8
87267: PUSH
87268: DOUBLE
87269: LD_INT 1
87271: DEC
87272: ST_TO_ADDR
87273: LD_VAR 0 9
87277: PUSH
87278: FOR_TO
87279: IFFALSE 87341
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87281: LD_VAR 0 8
87285: PPUSH
87286: CALL_OW 266
87290: PUSH
87291: LD_INT 0
87293: PUSH
87294: LD_INT 1
87296: PUSH
87297: EMPTY
87298: LIST
87299: LIST
87300: IN
87301: IFFALSE 87339
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87303: LD_VAR 0 4
87307: PUSH
87308: LD_VAR 0 7
87312: ARRAY
87313: PPUSH
87314: LD_VAR 0 14
87318: PUSH
87319: LD_VAR 0 8
87323: ARRAY
87324: PPUSH
87325: CALL_OW 115
// attacking := true ;
87329: LD_ADDR_VAR 0 29
87333: PUSH
87334: LD_INT 1
87336: ST_TO_ADDR
// break ;
87337: GO 87341
// end ;
87339: GO 87278
87341: POP
87342: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87343: LD_VAR 0 4
87347: PUSH
87348: LD_VAR 0 7
87352: ARRAY
87353: PPUSH
87354: CALL_OW 302
87358: PUSH
87359: LD_VAR 0 29
87363: NOT
87364: AND
87365: IFFALSE 87687
// begin if GetTag ( group [ i ] ) = 71 then
87367: LD_VAR 0 4
87371: PUSH
87372: LD_VAR 0 7
87376: ARRAY
87377: PPUSH
87378: CALL_OW 110
87382: PUSH
87383: LD_INT 71
87385: EQUAL
87386: IFFALSE 87427
// begin if HasTask ( group [ i ] ) then
87388: LD_VAR 0 4
87392: PUSH
87393: LD_VAR 0 7
87397: ARRAY
87398: PPUSH
87399: CALL_OW 314
87403: IFFALSE 87409
// continue else
87405: GO 83566
87407: GO 87427
// SetTag ( group [ i ] , 0 ) ;
87409: LD_VAR 0 4
87413: PUSH
87414: LD_VAR 0 7
87418: ARRAY
87419: PPUSH
87420: LD_INT 0
87422: PPUSH
87423: CALL_OW 109
// end ; k := 8 ;
87427: LD_ADDR_VAR 0 9
87431: PUSH
87432: LD_INT 8
87434: ST_TO_ADDR
// x := 0 ;
87435: LD_ADDR_VAR 0 10
87439: PUSH
87440: LD_INT 0
87442: ST_TO_ADDR
// if tmp < k then
87443: LD_VAR 0 14
87447: PUSH
87448: LD_VAR 0 9
87452: LESS
87453: IFFALSE 87465
// k := tmp ;
87455: LD_ADDR_VAR 0 9
87459: PUSH
87460: LD_VAR 0 14
87464: ST_TO_ADDR
// for j = 1 to k do
87465: LD_ADDR_VAR 0 8
87469: PUSH
87470: DOUBLE
87471: LD_INT 1
87473: DEC
87474: ST_TO_ADDR
87475: LD_VAR 0 9
87479: PUSH
87480: FOR_TO
87481: IFFALSE 87579
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87483: LD_VAR 0 14
87487: PUSH
87488: LD_VAR 0 8
87492: ARRAY
87493: PPUSH
87494: CALL_OW 247
87498: PUSH
87499: LD_INT 1
87501: EQUAL
87502: PUSH
87503: LD_VAR 0 14
87507: PUSH
87508: LD_VAR 0 8
87512: ARRAY
87513: PPUSH
87514: CALL_OW 256
87518: PUSH
87519: LD_INT 250
87521: LESS
87522: PUSH
87523: LD_VAR 0 20
87527: AND
87528: PUSH
87529: LD_VAR 0 20
87533: NOT
87534: PUSH
87535: LD_VAR 0 14
87539: PUSH
87540: LD_VAR 0 8
87544: ARRAY
87545: PPUSH
87546: CALL_OW 256
87550: PUSH
87551: LD_INT 250
87553: GREATEREQUAL
87554: AND
87555: OR
87556: AND
87557: IFFALSE 87577
// begin x := tmp [ j ] ;
87559: LD_ADDR_VAR 0 10
87563: PUSH
87564: LD_VAR 0 14
87568: PUSH
87569: LD_VAR 0 8
87573: ARRAY
87574: ST_TO_ADDR
// break ;
87575: GO 87579
// end ;
87577: GO 87480
87579: POP
87580: POP
// if x then
87581: LD_VAR 0 10
87585: IFFALSE 87609
// ComAttackUnit ( group [ i ] , x ) else
87587: LD_VAR 0 4
87591: PUSH
87592: LD_VAR 0 7
87596: ARRAY
87597: PPUSH
87598: LD_VAR 0 10
87602: PPUSH
87603: CALL_OW 115
87607: GO 87633
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87609: LD_VAR 0 4
87613: PUSH
87614: LD_VAR 0 7
87618: ARRAY
87619: PPUSH
87620: LD_VAR 0 14
87624: PUSH
87625: LD_INT 1
87627: ARRAY
87628: PPUSH
87629: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87633: LD_VAR 0 4
87637: PUSH
87638: LD_VAR 0 7
87642: ARRAY
87643: PPUSH
87644: CALL_OW 314
87648: NOT
87649: IFFALSE 87687
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87651: LD_VAR 0 4
87655: PUSH
87656: LD_VAR 0 7
87660: ARRAY
87661: PPUSH
87662: LD_VAR 0 14
87666: PPUSH
87667: LD_VAR 0 4
87671: PUSH
87672: LD_VAR 0 7
87676: ARRAY
87677: PPUSH
87678: CALL_OW 74
87682: PPUSH
87683: CALL_OW 115
// end ; end ; end ;
87687: GO 83566
87689: POP
87690: POP
// wait ( 0 0$2 ) ;
87691: LD_INT 70
87693: PPUSH
87694: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87698: LD_VAR 0 4
87702: NOT
87703: PUSH
87704: LD_VAR 0 4
87708: PUSH
87709: EMPTY
87710: EQUAL
87711: OR
87712: PUSH
87713: LD_INT 81
87715: PUSH
87716: LD_VAR 0 35
87720: PUSH
87721: EMPTY
87722: LIST
87723: LIST
87724: PPUSH
87725: CALL_OW 69
87729: NOT
87730: OR
87731: IFFALSE 83551
// end ;
87733: LD_VAR 0 2
87737: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
87738: LD_INT 0
87740: PPUSH
87741: PPUSH
87742: PPUSH
87743: PPUSH
87744: PPUSH
87745: PPUSH
// if not base or not mc_bases [ base ] or not solds then
87746: LD_VAR 0 1
87750: NOT
87751: PUSH
87752: LD_EXP 23
87756: PUSH
87757: LD_VAR 0 1
87761: ARRAY
87762: NOT
87763: OR
87764: PUSH
87765: LD_VAR 0 2
87769: NOT
87770: OR
87771: IFFALSE 87775
// exit ;
87773: GO 88329
// side := mc_sides [ base ] ;
87775: LD_ADDR_VAR 0 6
87779: PUSH
87780: LD_EXP 49
87784: PUSH
87785: LD_VAR 0 1
87789: ARRAY
87790: ST_TO_ADDR
// if not side then
87791: LD_VAR 0 6
87795: NOT
87796: IFFALSE 87800
// exit ;
87798: GO 88329
// for i in solds do
87800: LD_ADDR_VAR 0 7
87804: PUSH
87805: LD_VAR 0 2
87809: PUSH
87810: FOR_IN
87811: IFFALSE 87872
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
87813: LD_VAR 0 7
87817: PPUSH
87818: CALL_OW 310
87822: PPUSH
87823: CALL_OW 266
87827: PUSH
87828: LD_INT 32
87830: PUSH
87831: LD_INT 31
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: IN
87838: IFFALSE 87858
// solds := solds diff i else
87840: LD_ADDR_VAR 0 2
87844: PUSH
87845: LD_VAR 0 2
87849: PUSH
87850: LD_VAR 0 7
87854: DIFF
87855: ST_TO_ADDR
87856: GO 87870
// SetTag ( i , 18 ) ;
87858: LD_VAR 0 7
87862: PPUSH
87863: LD_INT 18
87865: PPUSH
87866: CALL_OW 109
87870: GO 87810
87872: POP
87873: POP
// if not solds then
87874: LD_VAR 0 2
87878: NOT
87879: IFFALSE 87883
// exit ;
87881: GO 88329
// repeat wait ( 0 0$2 ) ;
87883: LD_INT 70
87885: PPUSH
87886: CALL_OW 67
// enemy := mc_scan [ base ] ;
87890: LD_ADDR_VAR 0 4
87894: PUSH
87895: LD_EXP 46
87899: PUSH
87900: LD_VAR 0 1
87904: ARRAY
87905: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87906: LD_EXP 23
87910: PUSH
87911: LD_VAR 0 1
87915: ARRAY
87916: NOT
87917: PUSH
87918: LD_EXP 23
87922: PUSH
87923: LD_VAR 0 1
87927: ARRAY
87928: PUSH
87929: EMPTY
87930: EQUAL
87931: OR
87932: IFFALSE 87969
// begin for i in solds do
87934: LD_ADDR_VAR 0 7
87938: PUSH
87939: LD_VAR 0 2
87943: PUSH
87944: FOR_IN
87945: IFFALSE 87958
// ComStop ( i ) ;
87947: LD_VAR 0 7
87951: PPUSH
87952: CALL_OW 141
87956: GO 87944
87958: POP
87959: POP
// solds := [ ] ;
87960: LD_ADDR_VAR 0 2
87964: PUSH
87965: EMPTY
87966: ST_TO_ADDR
// exit ;
87967: GO 88329
// end ; for i in solds do
87969: LD_ADDR_VAR 0 7
87973: PUSH
87974: LD_VAR 0 2
87978: PUSH
87979: FOR_IN
87980: IFFALSE 88301
// begin if IsInUnit ( i ) then
87982: LD_VAR 0 7
87986: PPUSH
87987: CALL_OW 310
87991: IFFALSE 88002
// ComExitBuilding ( i ) ;
87993: LD_VAR 0 7
87997: PPUSH
87998: CALL_OW 122
// if GetLives ( i ) > 500 then
88002: LD_VAR 0 7
88006: PPUSH
88007: CALL_OW 256
88011: PUSH
88012: LD_INT 500
88014: GREATER
88015: IFFALSE 88068
// begin e := NearestUnitToUnit ( enemy , i ) ;
88017: LD_ADDR_VAR 0 5
88021: PUSH
88022: LD_VAR 0 4
88026: PPUSH
88027: LD_VAR 0 7
88031: PPUSH
88032: CALL_OW 74
88036: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
88037: LD_VAR 0 7
88041: PPUSH
88042: LD_VAR 0 5
88046: PPUSH
88047: CALL_OW 250
88051: PPUSH
88052: LD_VAR 0 5
88056: PPUSH
88057: CALL_OW 251
88061: PPUSH
88062: CALL_OW 114
// end else
88066: GO 88299
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
88068: LD_VAR 0 7
88072: PPUSH
88073: LD_EXP 23
88077: PUSH
88078: LD_VAR 0 1
88082: ARRAY
88083: PPUSH
88084: LD_INT 2
88086: PUSH
88087: LD_INT 30
88089: PUSH
88090: LD_INT 0
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PUSH
88097: LD_INT 30
88099: PUSH
88100: LD_INT 1
88102: PUSH
88103: EMPTY
88104: LIST
88105: LIST
88106: PUSH
88107: LD_INT 30
88109: PUSH
88110: LD_INT 6
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: EMPTY
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: PPUSH
88123: CALL_OW 72
88127: PPUSH
88128: LD_VAR 0 7
88132: PPUSH
88133: CALL_OW 74
88137: PPUSH
88138: CALL_OW 296
88142: PUSH
88143: LD_INT 10
88145: GREATER
88146: IFFALSE 88299
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
88148: LD_ADDR_VAR 0 8
88152: PUSH
88153: LD_EXP 23
88157: PUSH
88158: LD_VAR 0 1
88162: ARRAY
88163: PPUSH
88164: LD_INT 2
88166: PUSH
88167: LD_INT 30
88169: PUSH
88170: LD_INT 0
88172: PUSH
88173: EMPTY
88174: LIST
88175: LIST
88176: PUSH
88177: LD_INT 30
88179: PUSH
88180: LD_INT 1
88182: PUSH
88183: EMPTY
88184: LIST
88185: LIST
88186: PUSH
88187: LD_INT 30
88189: PUSH
88190: LD_INT 6
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: PPUSH
88203: CALL_OW 72
88207: PPUSH
88208: LD_VAR 0 7
88212: PPUSH
88213: CALL_OW 74
88217: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
88218: LD_VAR 0 7
88222: PPUSH
88223: LD_VAR 0 8
88227: PPUSH
88228: CALL_OW 250
88232: PPUSH
88233: LD_INT 3
88235: PPUSH
88236: LD_INT 5
88238: PPUSH
88239: CALL_OW 272
88243: PPUSH
88244: LD_VAR 0 8
88248: PPUSH
88249: CALL_OW 251
88253: PPUSH
88254: LD_INT 3
88256: PPUSH
88257: LD_INT 5
88259: PPUSH
88260: CALL_OW 273
88264: PPUSH
88265: CALL_OW 111
// SetTag ( i , 0 ) ;
88269: LD_VAR 0 7
88273: PPUSH
88274: LD_INT 0
88276: PPUSH
88277: CALL_OW 109
// solds := solds diff i ;
88281: LD_ADDR_VAR 0 2
88285: PUSH
88286: LD_VAR 0 2
88290: PUSH
88291: LD_VAR 0 7
88295: DIFF
88296: ST_TO_ADDR
// continue ;
88297: GO 87979
// end ; end ;
88299: GO 87979
88301: POP
88302: POP
// until not solds or not enemy ;
88303: LD_VAR 0 2
88307: NOT
88308: PUSH
88309: LD_VAR 0 4
88313: NOT
88314: OR
88315: IFFALSE 87883
// MC_Reset ( base , 18 ) ;
88317: LD_VAR 0 1
88321: PPUSH
88322: LD_INT 18
88324: PPUSH
88325: CALL 56397 0 2
// end ;
88329: LD_VAR 0 3
88333: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
88334: LD_INT 0
88336: PPUSH
88337: PPUSH
88338: PPUSH
88339: PPUSH
88340: PPUSH
88341: PPUSH
88342: PPUSH
88343: PPUSH
88344: PPUSH
88345: PPUSH
88346: PPUSH
88347: PPUSH
88348: PPUSH
88349: PPUSH
88350: PPUSH
88351: PPUSH
88352: PPUSH
88353: PPUSH
88354: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88355: LD_ADDR_VAR 0 12
88359: PUSH
88360: LD_EXP 23
88364: PUSH
88365: LD_VAR 0 1
88369: ARRAY
88370: PPUSH
88371: LD_INT 25
88373: PUSH
88374: LD_INT 3
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: PPUSH
88381: CALL_OW 72
88385: ST_TO_ADDR
// if mc_remote_driver [ base ] then
88386: LD_EXP 63
88390: PUSH
88391: LD_VAR 0 1
88395: ARRAY
88396: IFFALSE 88420
// mechs := mechs diff mc_remote_driver [ base ] ;
88398: LD_ADDR_VAR 0 12
88402: PUSH
88403: LD_VAR 0 12
88407: PUSH
88408: LD_EXP 63
88412: PUSH
88413: LD_VAR 0 1
88417: ARRAY
88418: DIFF
88419: ST_TO_ADDR
// for i in mechs do
88420: LD_ADDR_VAR 0 4
88424: PUSH
88425: LD_VAR 0 12
88429: PUSH
88430: FOR_IN
88431: IFFALSE 88466
// if GetTag ( i ) > 0 then
88433: LD_VAR 0 4
88437: PPUSH
88438: CALL_OW 110
88442: PUSH
88443: LD_INT 0
88445: GREATER
88446: IFFALSE 88464
// mechs := mechs diff i ;
88448: LD_ADDR_VAR 0 12
88452: PUSH
88453: LD_VAR 0 12
88457: PUSH
88458: LD_VAR 0 4
88462: DIFF
88463: ST_TO_ADDR
88464: GO 88430
88466: POP
88467: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88468: LD_ADDR_VAR 0 8
88472: PUSH
88473: LD_EXP 23
88477: PUSH
88478: LD_VAR 0 1
88482: ARRAY
88483: PPUSH
88484: LD_INT 2
88486: PUSH
88487: LD_INT 25
88489: PUSH
88490: LD_INT 1
88492: PUSH
88493: EMPTY
88494: LIST
88495: LIST
88496: PUSH
88497: LD_INT 25
88499: PUSH
88500: LD_INT 5
88502: PUSH
88503: EMPTY
88504: LIST
88505: LIST
88506: PUSH
88507: LD_INT 25
88509: PUSH
88510: LD_INT 8
88512: PUSH
88513: EMPTY
88514: LIST
88515: LIST
88516: PUSH
88517: LD_INT 25
88519: PUSH
88520: LD_INT 9
88522: PUSH
88523: EMPTY
88524: LIST
88525: LIST
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: LIST
88531: LIST
88532: LIST
88533: PPUSH
88534: CALL_OW 72
88538: ST_TO_ADDR
// if not defenders and not solds then
88539: LD_VAR 0 2
88543: NOT
88544: PUSH
88545: LD_VAR 0 8
88549: NOT
88550: AND
88551: IFFALSE 88555
// exit ;
88553: GO 90325
// depot_under_attack := false ;
88555: LD_ADDR_VAR 0 16
88559: PUSH
88560: LD_INT 0
88562: ST_TO_ADDR
// sold_defenders := [ ] ;
88563: LD_ADDR_VAR 0 17
88567: PUSH
88568: EMPTY
88569: ST_TO_ADDR
// if mechs then
88570: LD_VAR 0 12
88574: IFFALSE 88727
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
88576: LD_ADDR_VAR 0 4
88580: PUSH
88581: LD_VAR 0 2
88585: PPUSH
88586: LD_INT 21
88588: PUSH
88589: LD_INT 2
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PPUSH
88596: CALL_OW 72
88600: PUSH
88601: FOR_IN
88602: IFFALSE 88725
// begin if GetTag ( i ) <> 20 then
88604: LD_VAR 0 4
88608: PPUSH
88609: CALL_OW 110
88613: PUSH
88614: LD_INT 20
88616: NONEQUAL
88617: IFFALSE 88631
// SetTag ( i , 20 ) ;
88619: LD_VAR 0 4
88623: PPUSH
88624: LD_INT 20
88626: PPUSH
88627: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88631: LD_VAR 0 4
88635: PPUSH
88636: CALL_OW 263
88640: PUSH
88641: LD_INT 1
88643: EQUAL
88644: PUSH
88645: LD_VAR 0 4
88649: PPUSH
88650: CALL_OW 311
88654: NOT
88655: AND
88656: IFFALSE 88723
// begin un := mechs [ 1 ] ;
88658: LD_ADDR_VAR 0 10
88662: PUSH
88663: LD_VAR 0 12
88667: PUSH
88668: LD_INT 1
88670: ARRAY
88671: ST_TO_ADDR
// ComExit ( un ) ;
88672: LD_VAR 0 10
88676: PPUSH
88677: CALL 48826 0 1
// AddComEnterUnit ( un , i ) ;
88681: LD_VAR 0 10
88685: PPUSH
88686: LD_VAR 0 4
88690: PPUSH
88691: CALL_OW 180
// SetTag ( un , 19 ) ;
88695: LD_VAR 0 10
88699: PPUSH
88700: LD_INT 19
88702: PPUSH
88703: CALL_OW 109
// mechs := mechs diff un ;
88707: LD_ADDR_VAR 0 12
88711: PUSH
88712: LD_VAR 0 12
88716: PUSH
88717: LD_VAR 0 10
88721: DIFF
88722: ST_TO_ADDR
// end ; end ;
88723: GO 88601
88725: POP
88726: POP
// if solds then
88727: LD_VAR 0 8
88731: IFFALSE 88790
// for i in solds do
88733: LD_ADDR_VAR 0 4
88737: PUSH
88738: LD_VAR 0 8
88742: PUSH
88743: FOR_IN
88744: IFFALSE 88788
// if not GetTag ( i ) then
88746: LD_VAR 0 4
88750: PPUSH
88751: CALL_OW 110
88755: NOT
88756: IFFALSE 88786
// begin defenders := defenders union i ;
88758: LD_ADDR_VAR 0 2
88762: PUSH
88763: LD_VAR 0 2
88767: PUSH
88768: LD_VAR 0 4
88772: UNION
88773: ST_TO_ADDR
// SetTag ( i , 18 ) ;
88774: LD_VAR 0 4
88778: PPUSH
88779: LD_INT 18
88781: PPUSH
88782: CALL_OW 109
// end ;
88786: GO 88743
88788: POP
88789: POP
// repeat wait ( 0 0$2 ) ;
88790: LD_INT 70
88792: PPUSH
88793: CALL_OW 67
// enemy := mc_scan [ base ] ;
88797: LD_ADDR_VAR 0 21
88801: PUSH
88802: LD_EXP 46
88806: PUSH
88807: LD_VAR 0 1
88811: ARRAY
88812: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88813: LD_EXP 23
88817: PUSH
88818: LD_VAR 0 1
88822: ARRAY
88823: NOT
88824: PUSH
88825: LD_EXP 23
88829: PUSH
88830: LD_VAR 0 1
88834: ARRAY
88835: PUSH
88836: EMPTY
88837: EQUAL
88838: OR
88839: IFFALSE 88876
// begin for i in defenders do
88841: LD_ADDR_VAR 0 4
88845: PUSH
88846: LD_VAR 0 2
88850: PUSH
88851: FOR_IN
88852: IFFALSE 88865
// ComStop ( i ) ;
88854: LD_VAR 0 4
88858: PPUSH
88859: CALL_OW 141
88863: GO 88851
88865: POP
88866: POP
// defenders := [ ] ;
88867: LD_ADDR_VAR 0 2
88871: PUSH
88872: EMPTY
88873: ST_TO_ADDR
// exit ;
88874: GO 90325
// end ; for i in defenders do
88876: LD_ADDR_VAR 0 4
88880: PUSH
88881: LD_VAR 0 2
88885: PUSH
88886: FOR_IN
88887: IFFALSE 89785
// begin e := NearestUnitToUnit ( enemy , i ) ;
88889: LD_ADDR_VAR 0 13
88893: PUSH
88894: LD_VAR 0 21
88898: PPUSH
88899: LD_VAR 0 4
88903: PPUSH
88904: CALL_OW 74
88908: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88909: LD_ADDR_VAR 0 7
88913: PUSH
88914: LD_EXP 23
88918: PUSH
88919: LD_VAR 0 1
88923: ARRAY
88924: PPUSH
88925: LD_INT 2
88927: PUSH
88928: LD_INT 30
88930: PUSH
88931: LD_INT 0
88933: PUSH
88934: EMPTY
88935: LIST
88936: LIST
88937: PUSH
88938: LD_INT 30
88940: PUSH
88941: LD_INT 1
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: LIST
88952: PPUSH
88953: CALL_OW 72
88957: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
88958: LD_ADDR_VAR 0 16
88962: PUSH
88963: LD_VAR 0 7
88967: NOT
88968: PUSH
88969: LD_VAR 0 7
88973: PPUSH
88974: LD_INT 3
88976: PUSH
88977: LD_INT 24
88979: PUSH
88980: LD_INT 600
88982: PUSH
88983: EMPTY
88984: LIST
88985: LIST
88986: PUSH
88987: EMPTY
88988: LIST
88989: LIST
88990: PPUSH
88991: CALL_OW 72
88995: OR
88996: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
88997: LD_VAR 0 4
89001: PPUSH
89002: CALL_OW 247
89006: PUSH
89007: LD_INT 2
89009: DOUBLE
89010: EQUAL
89011: IFTRUE 89015
89013: GO 89411
89015: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
89016: LD_VAR 0 4
89020: PPUSH
89021: CALL_OW 256
89025: PUSH
89026: LD_INT 1000
89028: EQUAL
89029: PUSH
89030: LD_VAR 0 4
89034: PPUSH
89035: LD_VAR 0 13
89039: PPUSH
89040: CALL_OW 296
89044: PUSH
89045: LD_INT 40
89047: LESS
89048: PUSH
89049: LD_VAR 0 13
89053: PPUSH
89054: LD_EXP 48
89058: PUSH
89059: LD_VAR 0 1
89063: ARRAY
89064: PPUSH
89065: CALL_OW 308
89069: OR
89070: AND
89071: IFFALSE 89193
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
89073: LD_VAR 0 4
89077: PPUSH
89078: CALL_OW 262
89082: PUSH
89083: LD_INT 1
89085: EQUAL
89086: PUSH
89087: LD_VAR 0 4
89091: PPUSH
89092: CALL_OW 261
89096: PUSH
89097: LD_INT 30
89099: LESS
89100: AND
89101: PUSH
89102: LD_VAR 0 7
89106: AND
89107: IFFALSE 89177
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
89109: LD_VAR 0 4
89113: PPUSH
89114: LD_VAR 0 7
89118: PPUSH
89119: LD_VAR 0 4
89123: PPUSH
89124: CALL_OW 74
89128: PPUSH
89129: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
89133: LD_VAR 0 4
89137: PPUSH
89138: LD_VAR 0 7
89142: PPUSH
89143: LD_VAR 0 4
89147: PPUSH
89148: CALL_OW 74
89152: PPUSH
89153: CALL_OW 296
89157: PUSH
89158: LD_INT 6
89160: LESS
89161: IFFALSE 89175
// SetFuel ( i , 100 ) ;
89163: LD_VAR 0 4
89167: PPUSH
89168: LD_INT 100
89170: PPUSH
89171: CALL_OW 240
// end else
89175: GO 89191
// ComAttackUnit ( i , e ) ;
89177: LD_VAR 0 4
89181: PPUSH
89182: LD_VAR 0 13
89186: PPUSH
89187: CALL_OW 115
// end else
89191: GO 89294
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
89193: LD_VAR 0 13
89197: PPUSH
89198: LD_EXP 48
89202: PUSH
89203: LD_VAR 0 1
89207: ARRAY
89208: PPUSH
89209: CALL_OW 308
89213: NOT
89214: PUSH
89215: LD_VAR 0 4
89219: PPUSH
89220: LD_VAR 0 13
89224: PPUSH
89225: CALL_OW 296
89229: PUSH
89230: LD_INT 40
89232: GREATEREQUAL
89233: AND
89234: PUSH
89235: LD_VAR 0 4
89239: PPUSH
89240: CALL_OW 256
89244: PUSH
89245: LD_INT 650
89247: LESSEQUAL
89248: OR
89249: PUSH
89250: LD_VAR 0 4
89254: PPUSH
89255: LD_EXP 47
89259: PUSH
89260: LD_VAR 0 1
89264: ARRAY
89265: PPUSH
89266: CALL_OW 308
89270: NOT
89271: AND
89272: IFFALSE 89294
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89274: LD_VAR 0 4
89278: PPUSH
89279: LD_EXP 47
89283: PUSH
89284: LD_VAR 0 1
89288: ARRAY
89289: PPUSH
89290: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
89294: LD_VAR 0 4
89298: PPUSH
89299: CALL_OW 256
89303: PUSH
89304: LD_INT 1000
89306: LESS
89307: PUSH
89308: LD_VAR 0 4
89312: PPUSH
89313: CALL_OW 263
89317: PUSH
89318: LD_INT 1
89320: EQUAL
89321: AND
89322: PUSH
89323: LD_VAR 0 4
89327: PPUSH
89328: CALL_OW 311
89332: AND
89333: PUSH
89334: LD_VAR 0 4
89338: PPUSH
89339: LD_EXP 47
89343: PUSH
89344: LD_VAR 0 1
89348: ARRAY
89349: PPUSH
89350: CALL_OW 308
89354: AND
89355: IFFALSE 89409
// begin mech := IsDrivenBy ( i ) ;
89357: LD_ADDR_VAR 0 9
89361: PUSH
89362: LD_VAR 0 4
89366: PPUSH
89367: CALL_OW 311
89371: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
89372: LD_VAR 0 9
89376: PPUSH
89377: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
89381: LD_VAR 0 9
89385: PPUSH
89386: LD_VAR 0 4
89390: PPUSH
89391: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
89395: LD_VAR 0 9
89399: PPUSH
89400: LD_VAR 0 4
89404: PPUSH
89405: CALL_OW 180
// end ; end ; unit_human :
89409: GO 89756
89411: LD_INT 1
89413: DOUBLE
89414: EQUAL
89415: IFTRUE 89419
89417: GO 89755
89419: POP
// begin b := IsInUnit ( i ) ;
89420: LD_ADDR_VAR 0 18
89424: PUSH
89425: LD_VAR 0 4
89429: PPUSH
89430: CALL_OW 310
89434: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
89435: LD_ADDR_VAR 0 19
89439: PUSH
89440: LD_VAR 0 18
89444: NOT
89445: PUSH
89446: LD_VAR 0 18
89450: PPUSH
89451: CALL_OW 266
89455: PUSH
89456: LD_INT 32
89458: PUSH
89459: LD_INT 31
89461: PUSH
89462: EMPTY
89463: LIST
89464: LIST
89465: IN
89466: OR
89467: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
89468: LD_VAR 0 18
89472: PPUSH
89473: CALL_OW 266
89477: PUSH
89478: LD_INT 5
89480: EQUAL
89481: PUSH
89482: LD_VAR 0 4
89486: PPUSH
89487: CALL_OW 257
89491: PUSH
89492: LD_INT 1
89494: PUSH
89495: LD_INT 2
89497: PUSH
89498: LD_INT 3
89500: PUSH
89501: LD_INT 4
89503: PUSH
89504: EMPTY
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: IN
89510: AND
89511: IFFALSE 89548
// begin class := AllowSpecClass ( i ) ;
89513: LD_ADDR_VAR 0 20
89517: PUSH
89518: LD_VAR 0 4
89522: PPUSH
89523: CALL 12813 0 1
89527: ST_TO_ADDR
// if class then
89528: LD_VAR 0 20
89532: IFFALSE 89548
// ComChangeProfession ( i , class ) ;
89534: LD_VAR 0 4
89538: PPUSH
89539: LD_VAR 0 20
89543: PPUSH
89544: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
89548: LD_VAR 0 16
89552: PUSH
89553: LD_VAR 0 2
89557: PPUSH
89558: LD_INT 21
89560: PUSH
89561: LD_INT 2
89563: PUSH
89564: EMPTY
89565: LIST
89566: LIST
89567: PPUSH
89568: CALL_OW 72
89572: PUSH
89573: LD_INT 1
89575: LESSEQUAL
89576: OR
89577: PUSH
89578: LD_VAR 0 19
89582: AND
89583: PUSH
89584: LD_VAR 0 4
89588: PUSH
89589: LD_VAR 0 17
89593: IN
89594: NOT
89595: AND
89596: IFFALSE 89689
// begin if b then
89598: LD_VAR 0 18
89602: IFFALSE 89651
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89604: LD_VAR 0 18
89608: PPUSH
89609: LD_VAR 0 21
89613: PPUSH
89614: LD_VAR 0 18
89618: PPUSH
89619: CALL_OW 74
89623: PPUSH
89624: CALL_OW 296
89628: PUSH
89629: LD_INT 10
89631: LESS
89632: PUSH
89633: LD_VAR 0 18
89637: PPUSH
89638: CALL_OW 461
89642: PUSH
89643: LD_INT 7
89645: NONEQUAL
89646: AND
89647: IFFALSE 89651
// continue ;
89649: GO 88886
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89651: LD_ADDR_VAR 0 17
89655: PUSH
89656: LD_VAR 0 17
89660: PPUSH
89661: LD_VAR 0 17
89665: PUSH
89666: LD_INT 1
89668: PLUS
89669: PPUSH
89670: LD_VAR 0 4
89674: PPUSH
89675: CALL_OW 1
89679: ST_TO_ADDR
// ComExitBuilding ( i ) ;
89680: LD_VAR 0 4
89684: PPUSH
89685: CALL_OW 122
// end ; if sold_defenders then
89689: LD_VAR 0 17
89693: IFFALSE 89753
// if i in sold_defenders then
89695: LD_VAR 0 4
89699: PUSH
89700: LD_VAR 0 17
89704: IN
89705: IFFALSE 89753
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
89707: LD_VAR 0 4
89711: PPUSH
89712: CALL_OW 314
89716: NOT
89717: PUSH
89718: LD_VAR 0 4
89722: PPUSH
89723: LD_VAR 0 13
89727: PPUSH
89728: CALL_OW 296
89732: PUSH
89733: LD_INT 30
89735: LESS
89736: AND
89737: IFFALSE 89753
// ComAttackUnit ( i , e ) ;
89739: LD_VAR 0 4
89743: PPUSH
89744: LD_VAR 0 13
89748: PPUSH
89749: CALL_OW 115
// end ; end ; end ;
89753: GO 89756
89755: POP
// if IsDead ( i ) then
89756: LD_VAR 0 4
89760: PPUSH
89761: CALL_OW 301
89765: IFFALSE 89783
// defenders := defenders diff i ;
89767: LD_ADDR_VAR 0 2
89771: PUSH
89772: LD_VAR 0 2
89776: PUSH
89777: LD_VAR 0 4
89781: DIFF
89782: ST_TO_ADDR
// end ;
89783: GO 88886
89785: POP
89786: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
89787: LD_VAR 0 21
89791: NOT
89792: PUSH
89793: LD_VAR 0 2
89797: NOT
89798: OR
89799: PUSH
89800: LD_EXP 23
89804: PUSH
89805: LD_VAR 0 1
89809: ARRAY
89810: NOT
89811: OR
89812: IFFALSE 88790
// MC_Reset ( base , 18 ) ;
89814: LD_VAR 0 1
89818: PPUSH
89819: LD_INT 18
89821: PPUSH
89822: CALL 56397 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89826: LD_ADDR_VAR 0 2
89830: PUSH
89831: LD_VAR 0 2
89835: PUSH
89836: LD_VAR 0 2
89840: PPUSH
89841: LD_INT 2
89843: PUSH
89844: LD_INT 25
89846: PUSH
89847: LD_INT 1
89849: PUSH
89850: EMPTY
89851: LIST
89852: LIST
89853: PUSH
89854: LD_INT 25
89856: PUSH
89857: LD_INT 5
89859: PUSH
89860: EMPTY
89861: LIST
89862: LIST
89863: PUSH
89864: LD_INT 25
89866: PUSH
89867: LD_INT 8
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PUSH
89874: LD_INT 25
89876: PUSH
89877: LD_INT 9
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: PPUSH
89891: CALL_OW 72
89895: DIFF
89896: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
89897: LD_VAR 0 21
89901: NOT
89902: PUSH
89903: LD_VAR 0 2
89907: PPUSH
89908: LD_INT 21
89910: PUSH
89911: LD_INT 2
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PPUSH
89918: CALL_OW 72
89922: AND
89923: IFFALSE 90261
// begin tmp := FilterByTag ( defenders , 19 ) ;
89925: LD_ADDR_VAR 0 11
89929: PUSH
89930: LD_VAR 0 2
89934: PPUSH
89935: LD_INT 19
89937: PPUSH
89938: CALL 46002 0 2
89942: ST_TO_ADDR
// if tmp then
89943: LD_VAR 0 11
89947: IFFALSE 90017
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
89949: LD_ADDR_VAR 0 11
89953: PUSH
89954: LD_VAR 0 11
89958: PPUSH
89959: LD_INT 25
89961: PUSH
89962: LD_INT 3
89964: PUSH
89965: EMPTY
89966: LIST
89967: LIST
89968: PPUSH
89969: CALL_OW 72
89973: ST_TO_ADDR
// if tmp then
89974: LD_VAR 0 11
89978: IFFALSE 90017
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
89980: LD_ADDR_EXP 35
89984: PUSH
89985: LD_EXP 35
89989: PPUSH
89990: LD_VAR 0 1
89994: PPUSH
89995: LD_EXP 35
89999: PUSH
90000: LD_VAR 0 1
90004: ARRAY
90005: PUSH
90006: LD_VAR 0 11
90010: UNION
90011: PPUSH
90012: CALL_OW 1
90016: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
90017: LD_VAR 0 1
90021: PPUSH
90022: LD_INT 19
90024: PPUSH
90025: CALL 56397 0 2
// repeat wait ( 0 0$1 ) ;
90029: LD_INT 35
90031: PPUSH
90032: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90036: LD_EXP 23
90040: PUSH
90041: LD_VAR 0 1
90045: ARRAY
90046: NOT
90047: PUSH
90048: LD_EXP 23
90052: PUSH
90053: LD_VAR 0 1
90057: ARRAY
90058: PUSH
90059: EMPTY
90060: EQUAL
90061: OR
90062: IFFALSE 90099
// begin for i in defenders do
90064: LD_ADDR_VAR 0 4
90068: PUSH
90069: LD_VAR 0 2
90073: PUSH
90074: FOR_IN
90075: IFFALSE 90088
// ComStop ( i ) ;
90077: LD_VAR 0 4
90081: PPUSH
90082: CALL_OW 141
90086: GO 90074
90088: POP
90089: POP
// defenders := [ ] ;
90090: LD_ADDR_VAR 0 2
90094: PUSH
90095: EMPTY
90096: ST_TO_ADDR
// exit ;
90097: GO 90325
// end ; for i in defenders do
90099: LD_ADDR_VAR 0 4
90103: PUSH
90104: LD_VAR 0 2
90108: PUSH
90109: FOR_IN
90110: IFFALSE 90199
// begin if not IsInArea ( i , mc_parking [ base ] ) then
90112: LD_VAR 0 4
90116: PPUSH
90117: LD_EXP 47
90121: PUSH
90122: LD_VAR 0 1
90126: ARRAY
90127: PPUSH
90128: CALL_OW 308
90132: NOT
90133: IFFALSE 90157
// ComMoveToArea ( i , mc_parking [ base ] ) else
90135: LD_VAR 0 4
90139: PPUSH
90140: LD_EXP 47
90144: PUSH
90145: LD_VAR 0 1
90149: ARRAY
90150: PPUSH
90151: CALL_OW 113
90155: GO 90197
// if GetControl ( i ) = control_manual then
90157: LD_VAR 0 4
90161: PPUSH
90162: CALL_OW 263
90166: PUSH
90167: LD_INT 1
90169: EQUAL
90170: IFFALSE 90197
// if IsDrivenBy ( i ) then
90172: LD_VAR 0 4
90176: PPUSH
90177: CALL_OW 311
90181: IFFALSE 90197
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
90183: LD_VAR 0 4
90187: PPUSH
90188: CALL_OW 311
90192: PPUSH
90193: CALL_OW 121
// end ;
90197: GO 90109
90199: POP
90200: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
90201: LD_VAR 0 2
90205: PPUSH
90206: LD_INT 95
90208: PUSH
90209: LD_EXP 47
90213: PUSH
90214: LD_VAR 0 1
90218: ARRAY
90219: PUSH
90220: EMPTY
90221: LIST
90222: LIST
90223: PPUSH
90224: CALL_OW 72
90228: PUSH
90229: LD_VAR 0 2
90233: EQUAL
90234: PUSH
90235: LD_EXP 46
90239: PUSH
90240: LD_VAR 0 1
90244: ARRAY
90245: OR
90246: PUSH
90247: LD_EXP 23
90251: PUSH
90252: LD_VAR 0 1
90256: ARRAY
90257: NOT
90258: OR
90259: IFFALSE 90029
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90261: LD_ADDR_EXP 45
90265: PUSH
90266: LD_EXP 45
90270: PPUSH
90271: LD_VAR 0 1
90275: PPUSH
90276: LD_VAR 0 2
90280: PPUSH
90281: LD_INT 21
90283: PUSH
90284: LD_INT 2
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PPUSH
90291: CALL_OW 72
90295: PPUSH
90296: CALL_OW 1
90300: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
90301: LD_VAR 0 1
90305: PPUSH
90306: LD_INT 19
90308: PPUSH
90309: CALL 56397 0 2
// MC_Reset ( base , 20 ) ;
90313: LD_VAR 0 1
90317: PPUSH
90318: LD_INT 20
90320: PPUSH
90321: CALL 56397 0 2
// end ; end_of_file
90325: LD_VAR 0 3
90329: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
90330: LD_INT 0
90332: PPUSH
90333: PPUSH
90334: PPUSH
90335: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90336: LD_VAR 0 1
90340: PPUSH
90341: CALL_OW 264
90345: PUSH
90346: LD_EXP 71
90350: EQUAL
90351: IFFALSE 90423
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90353: LD_INT 68
90355: PPUSH
90356: LD_VAR 0 1
90360: PPUSH
90361: CALL_OW 255
90365: PPUSH
90366: CALL_OW 321
90370: PUSH
90371: LD_INT 2
90373: EQUAL
90374: IFFALSE 90386
// eff := 70 else
90376: LD_ADDR_VAR 0 4
90380: PUSH
90381: LD_INT 70
90383: ST_TO_ADDR
90384: GO 90394
// eff := 30 ;
90386: LD_ADDR_VAR 0 4
90390: PUSH
90391: LD_INT 30
90393: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90394: LD_VAR 0 1
90398: PPUSH
90399: CALL_OW 250
90403: PPUSH
90404: LD_VAR 0 1
90408: PPUSH
90409: CALL_OW 251
90413: PPUSH
90414: LD_VAR 0 4
90418: PPUSH
90419: CALL_OW 495
// end ; end ;
90423: LD_VAR 0 2
90427: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
90428: LD_INT 0
90430: PPUSH
// end ;
90431: LD_VAR 0 4
90435: RET
// export function SOS_Command ( cmd ) ; begin
90436: LD_INT 0
90438: PPUSH
// end ;
90439: LD_VAR 0 2
90443: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
90444: LD_INT 0
90446: PPUSH
// end ;
90447: LD_VAR 0 6
90451: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
90452: LD_INT 0
90454: PPUSH
90455: PPUSH
// if not vehicle or not factory then
90456: LD_VAR 0 1
90460: NOT
90461: PUSH
90462: LD_VAR 0 2
90466: NOT
90467: OR
90468: IFFALSE 90472
// exit ;
90470: GO 90703
// if factoryWaypoints >= factory then
90472: LD_EXP 153
90476: PUSH
90477: LD_VAR 0 2
90481: GREATEREQUAL
90482: IFFALSE 90703
// if factoryWaypoints [ factory ] then
90484: LD_EXP 153
90488: PUSH
90489: LD_VAR 0 2
90493: ARRAY
90494: IFFALSE 90703
// begin if GetControl ( vehicle ) = control_manual then
90496: LD_VAR 0 1
90500: PPUSH
90501: CALL_OW 263
90505: PUSH
90506: LD_INT 1
90508: EQUAL
90509: IFFALSE 90590
// begin driver := IsDrivenBy ( vehicle ) ;
90511: LD_ADDR_VAR 0 4
90515: PUSH
90516: LD_VAR 0 1
90520: PPUSH
90521: CALL_OW 311
90525: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90526: LD_VAR 0 4
90530: PPUSH
90531: LD_EXP 153
90535: PUSH
90536: LD_VAR 0 2
90540: ARRAY
90541: PUSH
90542: LD_INT 3
90544: ARRAY
90545: PPUSH
90546: LD_EXP 153
90550: PUSH
90551: LD_VAR 0 2
90555: ARRAY
90556: PUSH
90557: LD_INT 4
90559: ARRAY
90560: PPUSH
90561: CALL_OW 171
// AddComExitVehicle ( driver ) ;
90565: LD_VAR 0 4
90569: PPUSH
90570: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
90574: LD_VAR 0 4
90578: PPUSH
90579: LD_VAR 0 2
90583: PPUSH
90584: CALL_OW 180
// end else
90588: GO 90703
// if GetControl ( vehicle ) = control_remote then
90590: LD_VAR 0 1
90594: PPUSH
90595: CALL_OW 263
90599: PUSH
90600: LD_INT 2
90602: EQUAL
90603: IFFALSE 90664
// begin wait ( 0 0$2 ) ;
90605: LD_INT 70
90607: PPUSH
90608: CALL_OW 67
// if Connect ( vehicle ) then
90612: LD_VAR 0 1
90616: PPUSH
90617: CALL 19137 0 1
90621: IFFALSE 90662
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90623: LD_VAR 0 1
90627: PPUSH
90628: LD_EXP 153
90632: PUSH
90633: LD_VAR 0 2
90637: ARRAY
90638: PUSH
90639: LD_INT 3
90641: ARRAY
90642: PPUSH
90643: LD_EXP 153
90647: PUSH
90648: LD_VAR 0 2
90652: ARRAY
90653: PUSH
90654: LD_INT 4
90656: ARRAY
90657: PPUSH
90658: CALL_OW 171
// end else
90662: GO 90703
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90664: LD_VAR 0 1
90668: PPUSH
90669: LD_EXP 153
90673: PUSH
90674: LD_VAR 0 2
90678: ARRAY
90679: PUSH
90680: LD_INT 3
90682: ARRAY
90683: PPUSH
90684: LD_EXP 153
90688: PUSH
90689: LD_VAR 0 2
90693: ARRAY
90694: PUSH
90695: LD_INT 4
90697: ARRAY
90698: PPUSH
90699: CALL_OW 171
// end ; end ;
90703: LD_VAR 0 3
90707: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
90708: LD_INT 0
90710: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
90711: LD_VAR 0 1
90715: PUSH
90716: LD_INT 250
90718: EQUAL
90719: PUSH
90720: LD_VAR 0 2
90724: PPUSH
90725: CALL_OW 264
90729: PUSH
90730: LD_EXP 74
90734: EQUAL
90735: AND
90736: IFFALSE 90757
// MinerPlaceMine ( unit , x , y ) ;
90738: LD_VAR 0 2
90742: PPUSH
90743: LD_VAR 0 4
90747: PPUSH
90748: LD_VAR 0 5
90752: PPUSH
90753: CALL 93156 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
90757: LD_VAR 0 1
90761: PUSH
90762: LD_INT 251
90764: EQUAL
90765: PUSH
90766: LD_VAR 0 2
90770: PPUSH
90771: CALL_OW 264
90775: PUSH
90776: LD_EXP 74
90780: EQUAL
90781: AND
90782: IFFALSE 90803
// MinerDetonateMine ( unit , x , y ) ;
90784: LD_VAR 0 2
90788: PPUSH
90789: LD_VAR 0 4
90793: PPUSH
90794: LD_VAR 0 5
90798: PPUSH
90799: CALL 93433 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
90803: LD_VAR 0 1
90807: PUSH
90808: LD_INT 252
90810: EQUAL
90811: PUSH
90812: LD_VAR 0 2
90816: PPUSH
90817: CALL_OW 264
90821: PUSH
90822: LD_EXP 74
90826: EQUAL
90827: AND
90828: IFFALSE 90849
// MinerCreateMinefield ( unit , x , y ) ;
90830: LD_VAR 0 2
90834: PPUSH
90835: LD_VAR 0 4
90839: PPUSH
90840: LD_VAR 0 5
90844: PPUSH
90845: CALL 93850 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
90849: LD_VAR 0 1
90853: PUSH
90854: LD_INT 253
90856: EQUAL
90857: PUSH
90858: LD_VAR 0 2
90862: PPUSH
90863: CALL_OW 257
90867: PUSH
90868: LD_INT 5
90870: EQUAL
90871: AND
90872: IFFALSE 90893
// ComBinocular ( unit , x , y ) ;
90874: LD_VAR 0 2
90878: PPUSH
90879: LD_VAR 0 4
90883: PPUSH
90884: LD_VAR 0 5
90888: PPUSH
90889: CALL 94221 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
90893: LD_VAR 0 1
90897: PUSH
90898: LD_INT 254
90900: EQUAL
90901: PUSH
90902: LD_VAR 0 2
90906: PPUSH
90907: CALL_OW 264
90911: PUSH
90912: LD_EXP 69
90916: EQUAL
90917: AND
90918: PUSH
90919: LD_VAR 0 3
90923: PPUSH
90924: CALL_OW 263
90928: PUSH
90929: LD_INT 3
90931: EQUAL
90932: AND
90933: IFFALSE 90949
// HackDestroyVehicle ( unit , selectedUnit ) ;
90935: LD_VAR 0 2
90939: PPUSH
90940: LD_VAR 0 3
90944: PPUSH
90945: CALL 92516 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
90949: LD_VAR 0 1
90953: PUSH
90954: LD_INT 255
90956: EQUAL
90957: PUSH
90958: LD_VAR 0 2
90962: PPUSH
90963: CALL_OW 264
90967: PUSH
90968: LD_INT 14
90970: PUSH
90971: LD_INT 53
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: IN
90978: AND
90979: PUSH
90980: LD_VAR 0 4
90984: PPUSH
90985: LD_VAR 0 5
90989: PPUSH
90990: CALL_OW 488
90994: AND
90995: IFFALSE 91019
// CutTreeXYR ( unit , x , y , 12 ) ;
90997: LD_VAR 0 2
91001: PPUSH
91002: LD_VAR 0 4
91006: PPUSH
91007: LD_VAR 0 5
91011: PPUSH
91012: LD_INT 12
91014: PPUSH
91015: CALL 91082 0 4
// if cmd = 256 then
91019: LD_VAR 0 1
91023: PUSH
91024: LD_INT 256
91026: EQUAL
91027: IFFALSE 91048
// SetFactoryWaypoint ( unit , x , y ) ;
91029: LD_VAR 0 2
91033: PPUSH
91034: LD_VAR 0 4
91038: PPUSH
91039: LD_VAR 0 5
91043: PPUSH
91044: CALL 109142 0 3
// if cmd = 257 then
91048: LD_VAR 0 1
91052: PUSH
91053: LD_INT 257
91055: EQUAL
91056: IFFALSE 91077
// SetWarehouseGatheringPoint ( unit , x , y ) ;
91058: LD_VAR 0 2
91062: PPUSH
91063: LD_VAR 0 4
91067: PPUSH
91068: LD_VAR 0 5
91072: PPUSH
91073: CALL 109504 0 3
// end ;
91077: LD_VAR 0 6
91081: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91082: LD_INT 0
91084: PPUSH
91085: PPUSH
91086: PPUSH
91087: PPUSH
91088: PPUSH
91089: PPUSH
91090: PPUSH
91091: PPUSH
91092: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
91093: LD_VAR 0 1
91097: NOT
91098: PUSH
91099: LD_VAR 0 2
91103: PPUSH
91104: LD_VAR 0 3
91108: PPUSH
91109: CALL_OW 488
91113: NOT
91114: OR
91115: PUSH
91116: LD_VAR 0 4
91120: NOT
91121: OR
91122: IFFALSE 91126
// exit ;
91124: GO 91466
// list := [ ] ;
91126: LD_ADDR_VAR 0 13
91130: PUSH
91131: EMPTY
91132: ST_TO_ADDR
// if x - r < 0 then
91133: LD_VAR 0 2
91137: PUSH
91138: LD_VAR 0 4
91142: MINUS
91143: PUSH
91144: LD_INT 0
91146: LESS
91147: IFFALSE 91159
// min_x := 0 else
91149: LD_ADDR_VAR 0 7
91153: PUSH
91154: LD_INT 0
91156: ST_TO_ADDR
91157: GO 91175
// min_x := x - r ;
91159: LD_ADDR_VAR 0 7
91163: PUSH
91164: LD_VAR 0 2
91168: PUSH
91169: LD_VAR 0 4
91173: MINUS
91174: ST_TO_ADDR
// if y - r < 0 then
91175: LD_VAR 0 3
91179: PUSH
91180: LD_VAR 0 4
91184: MINUS
91185: PUSH
91186: LD_INT 0
91188: LESS
91189: IFFALSE 91201
// min_y := 0 else
91191: LD_ADDR_VAR 0 8
91195: PUSH
91196: LD_INT 0
91198: ST_TO_ADDR
91199: GO 91217
// min_y := y - r ;
91201: LD_ADDR_VAR 0 8
91205: PUSH
91206: LD_VAR 0 3
91210: PUSH
91211: LD_VAR 0 4
91215: MINUS
91216: ST_TO_ADDR
// max_x := x + r ;
91217: LD_ADDR_VAR 0 9
91221: PUSH
91222: LD_VAR 0 2
91226: PUSH
91227: LD_VAR 0 4
91231: PLUS
91232: ST_TO_ADDR
// max_y := y + r ;
91233: LD_ADDR_VAR 0 10
91237: PUSH
91238: LD_VAR 0 3
91242: PUSH
91243: LD_VAR 0 4
91247: PLUS
91248: ST_TO_ADDR
// for _x = min_x to max_x do
91249: LD_ADDR_VAR 0 11
91253: PUSH
91254: DOUBLE
91255: LD_VAR 0 7
91259: DEC
91260: ST_TO_ADDR
91261: LD_VAR 0 9
91265: PUSH
91266: FOR_TO
91267: IFFALSE 91384
// for _y = min_y to max_y do
91269: LD_ADDR_VAR 0 12
91273: PUSH
91274: DOUBLE
91275: LD_VAR 0 8
91279: DEC
91280: ST_TO_ADDR
91281: LD_VAR 0 10
91285: PUSH
91286: FOR_TO
91287: IFFALSE 91380
// begin if not ValidHex ( _x , _y ) then
91289: LD_VAR 0 11
91293: PPUSH
91294: LD_VAR 0 12
91298: PPUSH
91299: CALL_OW 488
91303: NOT
91304: IFFALSE 91308
// continue ;
91306: GO 91286
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91308: LD_VAR 0 11
91312: PPUSH
91313: LD_VAR 0 12
91317: PPUSH
91318: CALL_OW 351
91322: PUSH
91323: LD_VAR 0 11
91327: PPUSH
91328: LD_VAR 0 12
91332: PPUSH
91333: CALL_OW 554
91337: AND
91338: IFFALSE 91378
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91340: LD_ADDR_VAR 0 13
91344: PUSH
91345: LD_VAR 0 13
91349: PPUSH
91350: LD_VAR 0 13
91354: PUSH
91355: LD_INT 1
91357: PLUS
91358: PPUSH
91359: LD_VAR 0 11
91363: PUSH
91364: LD_VAR 0 12
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PPUSH
91373: CALL_OW 2
91377: ST_TO_ADDR
// end ;
91378: GO 91286
91380: POP
91381: POP
91382: GO 91266
91384: POP
91385: POP
// if not list then
91386: LD_VAR 0 13
91390: NOT
91391: IFFALSE 91395
// exit ;
91393: GO 91466
// for i in list do
91395: LD_ADDR_VAR 0 6
91399: PUSH
91400: LD_VAR 0 13
91404: PUSH
91405: FOR_IN
91406: IFFALSE 91464
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91408: LD_VAR 0 1
91412: PPUSH
91413: LD_STRING M
91415: PUSH
91416: LD_VAR 0 6
91420: PUSH
91421: LD_INT 1
91423: ARRAY
91424: PUSH
91425: LD_VAR 0 6
91429: PUSH
91430: LD_INT 2
91432: ARRAY
91433: PUSH
91434: LD_INT 0
91436: PUSH
91437: LD_INT 0
91439: PUSH
91440: LD_INT 0
91442: PUSH
91443: LD_INT 0
91445: PUSH
91446: EMPTY
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: PUSH
91455: EMPTY
91456: LIST
91457: PPUSH
91458: CALL_OW 447
91462: GO 91405
91464: POP
91465: POP
// end ;
91466: LD_VAR 0 5
91470: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91471: LD_EXP 85
91475: NOT
91476: IFFALSE 91526
91478: GO 91480
91480: DISABLE
// begin initHack := true ;
91481: LD_ADDR_EXP 85
91485: PUSH
91486: LD_INT 1
91488: ST_TO_ADDR
// hackTanks := [ ] ;
91489: LD_ADDR_EXP 86
91493: PUSH
91494: EMPTY
91495: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91496: LD_ADDR_EXP 87
91500: PUSH
91501: EMPTY
91502: ST_TO_ADDR
// hackLimit := 3 ;
91503: LD_ADDR_EXP 88
91507: PUSH
91508: LD_INT 3
91510: ST_TO_ADDR
// hackDist := 12 ;
91511: LD_ADDR_EXP 89
91515: PUSH
91516: LD_INT 12
91518: ST_TO_ADDR
// hackCounter := [ ] ;
91519: LD_ADDR_EXP 90
91523: PUSH
91524: EMPTY
91525: ST_TO_ADDR
// end ;
91526: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91527: LD_EXP 85
91531: PUSH
91532: LD_INT 34
91534: PUSH
91535: LD_EXP 69
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: PPUSH
91544: CALL_OW 69
91548: AND
91549: IFFALSE 91804
91551: GO 91553
91553: DISABLE
91554: LD_INT 0
91556: PPUSH
91557: PPUSH
// begin enable ;
91558: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91559: LD_ADDR_VAR 0 1
91563: PUSH
91564: LD_INT 34
91566: PUSH
91567: LD_EXP 69
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PPUSH
91576: CALL_OW 69
91580: PUSH
91581: FOR_IN
91582: IFFALSE 91802
// begin if not i in hackTanks then
91584: LD_VAR 0 1
91588: PUSH
91589: LD_EXP 86
91593: IN
91594: NOT
91595: IFFALSE 91678
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91597: LD_ADDR_EXP 86
91601: PUSH
91602: LD_EXP 86
91606: PPUSH
91607: LD_EXP 86
91611: PUSH
91612: LD_INT 1
91614: PLUS
91615: PPUSH
91616: LD_VAR 0 1
91620: PPUSH
91621: CALL_OW 1
91625: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91626: LD_ADDR_EXP 87
91630: PUSH
91631: LD_EXP 87
91635: PPUSH
91636: LD_EXP 87
91640: PUSH
91641: LD_INT 1
91643: PLUS
91644: PPUSH
91645: EMPTY
91646: PPUSH
91647: CALL_OW 1
91651: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91652: LD_ADDR_EXP 90
91656: PUSH
91657: LD_EXP 90
91661: PPUSH
91662: LD_EXP 90
91666: PUSH
91667: LD_INT 1
91669: PLUS
91670: PPUSH
91671: EMPTY
91672: PPUSH
91673: CALL_OW 1
91677: ST_TO_ADDR
// end ; if not IsOk ( i ) then
91678: LD_VAR 0 1
91682: PPUSH
91683: CALL_OW 302
91687: NOT
91688: IFFALSE 91701
// begin HackUnlinkAll ( i ) ;
91690: LD_VAR 0 1
91694: PPUSH
91695: CALL 91807 0 1
// continue ;
91699: GO 91581
// end ; HackCheckCapturedStatus ( i ) ;
91701: LD_VAR 0 1
91705: PPUSH
91706: CALL 92250 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
91710: LD_ADDR_VAR 0 2
91714: PUSH
91715: LD_INT 81
91717: PUSH
91718: LD_VAR 0 1
91722: PPUSH
91723: CALL_OW 255
91727: PUSH
91728: EMPTY
91729: LIST
91730: LIST
91731: PUSH
91732: LD_INT 33
91734: PUSH
91735: LD_INT 3
91737: PUSH
91738: EMPTY
91739: LIST
91740: LIST
91741: PUSH
91742: LD_INT 91
91744: PUSH
91745: LD_VAR 0 1
91749: PUSH
91750: LD_EXP 89
91754: PUSH
91755: EMPTY
91756: LIST
91757: LIST
91758: LIST
91759: PUSH
91760: LD_INT 50
91762: PUSH
91763: EMPTY
91764: LIST
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: PPUSH
91772: CALL_OW 69
91776: ST_TO_ADDR
// if not tmp then
91777: LD_VAR 0 2
91781: NOT
91782: IFFALSE 91786
// continue ;
91784: GO 91581
// HackLink ( i , tmp ) ;
91786: LD_VAR 0 1
91790: PPUSH
91791: LD_VAR 0 2
91795: PPUSH
91796: CALL 91943 0 2
// end ;
91800: GO 91581
91802: POP
91803: POP
// end ;
91804: PPOPN 2
91806: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
91807: LD_INT 0
91809: PPUSH
91810: PPUSH
91811: PPUSH
// if not hack in hackTanks then
91812: LD_VAR 0 1
91816: PUSH
91817: LD_EXP 86
91821: IN
91822: NOT
91823: IFFALSE 91827
// exit ;
91825: GO 91938
// index := GetElementIndex ( hackTanks , hack ) ;
91827: LD_ADDR_VAR 0 4
91831: PUSH
91832: LD_EXP 86
91836: PPUSH
91837: LD_VAR 0 1
91841: PPUSH
91842: CALL 15951 0 2
91846: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
91847: LD_EXP 87
91851: PUSH
91852: LD_VAR 0 4
91856: ARRAY
91857: IFFALSE 91938
// begin for i in hackTanksCaptured [ index ] do
91859: LD_ADDR_VAR 0 3
91863: PUSH
91864: LD_EXP 87
91868: PUSH
91869: LD_VAR 0 4
91873: ARRAY
91874: PUSH
91875: FOR_IN
91876: IFFALSE 91902
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
91878: LD_VAR 0 3
91882: PUSH
91883: LD_INT 1
91885: ARRAY
91886: PPUSH
91887: LD_VAR 0 3
91891: PUSH
91892: LD_INT 2
91894: ARRAY
91895: PPUSH
91896: CALL_OW 235
91900: GO 91875
91902: POP
91903: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
91904: LD_ADDR_EXP 87
91908: PUSH
91909: LD_EXP 87
91913: PPUSH
91914: LD_VAR 0 4
91918: PPUSH
91919: EMPTY
91920: PPUSH
91921: CALL_OW 1
91925: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
91926: LD_VAR 0 1
91930: PPUSH
91931: LD_INT 0
91933: PPUSH
91934: CALL_OW 505
// end ; end ;
91938: LD_VAR 0 2
91942: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
91943: LD_INT 0
91945: PPUSH
91946: PPUSH
91947: PPUSH
// if not hack in hackTanks or not vehicles then
91948: LD_VAR 0 1
91952: PUSH
91953: LD_EXP 86
91957: IN
91958: NOT
91959: PUSH
91960: LD_VAR 0 2
91964: NOT
91965: OR
91966: IFFALSE 91970
// exit ;
91968: GO 92245
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
91970: LD_ADDR_VAR 0 2
91974: PUSH
91975: LD_VAR 0 1
91979: PPUSH
91980: LD_VAR 0 2
91984: PPUSH
91985: LD_INT 1
91987: PPUSH
91988: LD_INT 1
91990: PPUSH
91991: CALL 16601 0 4
91995: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
91996: LD_ADDR_VAR 0 5
92000: PUSH
92001: LD_EXP 86
92005: PPUSH
92006: LD_VAR 0 1
92010: PPUSH
92011: CALL 15951 0 2
92015: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
92016: LD_EXP 87
92020: PUSH
92021: LD_VAR 0 5
92025: ARRAY
92026: PUSH
92027: LD_EXP 88
92031: LESS
92032: IFFALSE 92221
// begin for i := 1 to vehicles do
92034: LD_ADDR_VAR 0 4
92038: PUSH
92039: DOUBLE
92040: LD_INT 1
92042: DEC
92043: ST_TO_ADDR
92044: LD_VAR 0 2
92048: PUSH
92049: FOR_TO
92050: IFFALSE 92219
// begin if hackTanksCaptured [ index ] = hackLimit then
92052: LD_EXP 87
92056: PUSH
92057: LD_VAR 0 5
92061: ARRAY
92062: PUSH
92063: LD_EXP 88
92067: EQUAL
92068: IFFALSE 92072
// break ;
92070: GO 92219
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
92072: LD_ADDR_EXP 90
92076: PUSH
92077: LD_EXP 90
92081: PPUSH
92082: LD_VAR 0 5
92086: PPUSH
92087: LD_EXP 90
92091: PUSH
92092: LD_VAR 0 5
92096: ARRAY
92097: PUSH
92098: LD_INT 1
92100: PLUS
92101: PPUSH
92102: CALL_OW 1
92106: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
92107: LD_ADDR_EXP 87
92111: PUSH
92112: LD_EXP 87
92116: PPUSH
92117: LD_VAR 0 5
92121: PUSH
92122: LD_EXP 87
92126: PUSH
92127: LD_VAR 0 5
92131: ARRAY
92132: PUSH
92133: LD_INT 1
92135: PLUS
92136: PUSH
92137: EMPTY
92138: LIST
92139: LIST
92140: PPUSH
92141: LD_VAR 0 2
92145: PUSH
92146: LD_VAR 0 4
92150: ARRAY
92151: PUSH
92152: LD_VAR 0 2
92156: PUSH
92157: LD_VAR 0 4
92161: ARRAY
92162: PPUSH
92163: CALL_OW 255
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: PPUSH
92172: CALL 16166 0 3
92176: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
92177: LD_VAR 0 2
92181: PUSH
92182: LD_VAR 0 4
92186: ARRAY
92187: PPUSH
92188: LD_VAR 0 1
92192: PPUSH
92193: CALL_OW 255
92197: PPUSH
92198: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
92202: LD_VAR 0 2
92206: PUSH
92207: LD_VAR 0 4
92211: ARRAY
92212: PPUSH
92213: CALL_OW 141
// end ;
92217: GO 92049
92219: POP
92220: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92221: LD_VAR 0 1
92225: PPUSH
92226: LD_EXP 87
92230: PUSH
92231: LD_VAR 0 5
92235: ARRAY
92236: PUSH
92237: LD_INT 0
92239: PLUS
92240: PPUSH
92241: CALL_OW 505
// end ;
92245: LD_VAR 0 3
92249: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92250: LD_INT 0
92252: PPUSH
92253: PPUSH
92254: PPUSH
92255: PPUSH
// if not hack in hackTanks then
92256: LD_VAR 0 1
92260: PUSH
92261: LD_EXP 86
92265: IN
92266: NOT
92267: IFFALSE 92271
// exit ;
92269: GO 92511
// index := GetElementIndex ( hackTanks , hack ) ;
92271: LD_ADDR_VAR 0 4
92275: PUSH
92276: LD_EXP 86
92280: PPUSH
92281: LD_VAR 0 1
92285: PPUSH
92286: CALL 15951 0 2
92290: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92291: LD_ADDR_VAR 0 3
92295: PUSH
92296: DOUBLE
92297: LD_EXP 87
92301: PUSH
92302: LD_VAR 0 4
92306: ARRAY
92307: INC
92308: ST_TO_ADDR
92309: LD_INT 1
92311: PUSH
92312: FOR_DOWNTO
92313: IFFALSE 92485
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92315: LD_ADDR_VAR 0 5
92319: PUSH
92320: LD_EXP 87
92324: PUSH
92325: LD_VAR 0 4
92329: ARRAY
92330: PUSH
92331: LD_VAR 0 3
92335: ARRAY
92336: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92337: LD_VAR 0 5
92341: PUSH
92342: LD_INT 1
92344: ARRAY
92345: PPUSH
92346: CALL_OW 302
92350: NOT
92351: PUSH
92352: LD_VAR 0 5
92356: PUSH
92357: LD_INT 1
92359: ARRAY
92360: PPUSH
92361: CALL_OW 255
92365: PUSH
92366: LD_VAR 0 1
92370: PPUSH
92371: CALL_OW 255
92375: NONEQUAL
92376: OR
92377: IFFALSE 92483
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92379: LD_VAR 0 5
92383: PUSH
92384: LD_INT 1
92386: ARRAY
92387: PPUSH
92388: CALL_OW 305
92392: PUSH
92393: LD_VAR 0 5
92397: PUSH
92398: LD_INT 1
92400: ARRAY
92401: PPUSH
92402: CALL_OW 255
92406: PUSH
92407: LD_VAR 0 1
92411: PPUSH
92412: CALL_OW 255
92416: EQUAL
92417: AND
92418: IFFALSE 92442
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92420: LD_VAR 0 5
92424: PUSH
92425: LD_INT 1
92427: ARRAY
92428: PPUSH
92429: LD_VAR 0 5
92433: PUSH
92434: LD_INT 2
92436: ARRAY
92437: PPUSH
92438: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92442: LD_ADDR_EXP 87
92446: PUSH
92447: LD_EXP 87
92451: PPUSH
92452: LD_VAR 0 4
92456: PPUSH
92457: LD_EXP 87
92461: PUSH
92462: LD_VAR 0 4
92466: ARRAY
92467: PPUSH
92468: LD_VAR 0 3
92472: PPUSH
92473: CALL_OW 3
92477: PPUSH
92478: CALL_OW 1
92482: ST_TO_ADDR
// end ; end ;
92483: GO 92312
92485: POP
92486: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92487: LD_VAR 0 1
92491: PPUSH
92492: LD_EXP 87
92496: PUSH
92497: LD_VAR 0 4
92501: ARRAY
92502: PUSH
92503: LD_INT 0
92505: PLUS
92506: PPUSH
92507: CALL_OW 505
// end ;
92511: LD_VAR 0 2
92515: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92516: LD_INT 0
92518: PPUSH
92519: PPUSH
92520: PPUSH
92521: PPUSH
// if not hack in hackTanks then
92522: LD_VAR 0 1
92526: PUSH
92527: LD_EXP 86
92531: IN
92532: NOT
92533: IFFALSE 92537
// exit ;
92535: GO 92622
// index := GetElementIndex ( hackTanks , hack ) ;
92537: LD_ADDR_VAR 0 5
92541: PUSH
92542: LD_EXP 86
92546: PPUSH
92547: LD_VAR 0 1
92551: PPUSH
92552: CALL 15951 0 2
92556: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92557: LD_ADDR_VAR 0 4
92561: PUSH
92562: DOUBLE
92563: LD_INT 1
92565: DEC
92566: ST_TO_ADDR
92567: LD_EXP 87
92571: PUSH
92572: LD_VAR 0 5
92576: ARRAY
92577: PUSH
92578: FOR_TO
92579: IFFALSE 92620
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92581: LD_EXP 87
92585: PUSH
92586: LD_VAR 0 5
92590: ARRAY
92591: PUSH
92592: LD_VAR 0 4
92596: ARRAY
92597: PUSH
92598: LD_INT 1
92600: ARRAY
92601: PUSH
92602: LD_VAR 0 2
92606: EQUAL
92607: IFFALSE 92618
// KillUnit ( vehicle ) ;
92609: LD_VAR 0 2
92613: PPUSH
92614: CALL_OW 66
92618: GO 92578
92620: POP
92621: POP
// end ;
92622: LD_VAR 0 3
92626: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92627: LD_EXP 91
92631: NOT
92632: IFFALSE 92667
92634: GO 92636
92636: DISABLE
// begin initMiner := true ;
92637: LD_ADDR_EXP 91
92641: PUSH
92642: LD_INT 1
92644: ST_TO_ADDR
// minersList := [ ] ;
92645: LD_ADDR_EXP 92
92649: PUSH
92650: EMPTY
92651: ST_TO_ADDR
// minerMinesList := [ ] ;
92652: LD_ADDR_EXP 93
92656: PUSH
92657: EMPTY
92658: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92659: LD_ADDR_EXP 94
92663: PUSH
92664: LD_INT 5
92666: ST_TO_ADDR
// end ;
92667: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92668: LD_EXP 91
92672: PUSH
92673: LD_INT 34
92675: PUSH
92676: LD_EXP 74
92680: PUSH
92681: EMPTY
92682: LIST
92683: LIST
92684: PPUSH
92685: CALL_OW 69
92689: AND
92690: IFFALSE 93153
92692: GO 92694
92694: DISABLE
92695: LD_INT 0
92697: PPUSH
92698: PPUSH
92699: PPUSH
92700: PPUSH
// begin enable ;
92701: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
92702: LD_ADDR_VAR 0 1
92706: PUSH
92707: LD_INT 34
92709: PUSH
92710: LD_EXP 74
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: PPUSH
92719: CALL_OW 69
92723: PUSH
92724: FOR_IN
92725: IFFALSE 92797
// begin if not i in minersList then
92727: LD_VAR 0 1
92731: PUSH
92732: LD_EXP 92
92736: IN
92737: NOT
92738: IFFALSE 92795
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
92740: LD_ADDR_EXP 92
92744: PUSH
92745: LD_EXP 92
92749: PPUSH
92750: LD_EXP 92
92754: PUSH
92755: LD_INT 1
92757: PLUS
92758: PPUSH
92759: LD_VAR 0 1
92763: PPUSH
92764: CALL_OW 1
92768: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
92769: LD_ADDR_EXP 93
92773: PUSH
92774: LD_EXP 93
92778: PPUSH
92779: LD_EXP 93
92783: PUSH
92784: LD_INT 1
92786: PLUS
92787: PPUSH
92788: EMPTY
92789: PPUSH
92790: CALL_OW 1
92794: ST_TO_ADDR
// end end ;
92795: GO 92724
92797: POP
92798: POP
// for i := minerMinesList downto 1 do
92799: LD_ADDR_VAR 0 1
92803: PUSH
92804: DOUBLE
92805: LD_EXP 93
92809: INC
92810: ST_TO_ADDR
92811: LD_INT 1
92813: PUSH
92814: FOR_DOWNTO
92815: IFFALSE 93151
// begin if IsLive ( minersList [ i ] ) then
92817: LD_EXP 92
92821: PUSH
92822: LD_VAR 0 1
92826: ARRAY
92827: PPUSH
92828: CALL_OW 300
92832: IFFALSE 92860
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
92834: LD_EXP 92
92838: PUSH
92839: LD_VAR 0 1
92843: ARRAY
92844: PPUSH
92845: LD_EXP 93
92849: PUSH
92850: LD_VAR 0 1
92854: ARRAY
92855: PPUSH
92856: CALL_OW 505
// if not minerMinesList [ i ] then
92860: LD_EXP 93
92864: PUSH
92865: LD_VAR 0 1
92869: ARRAY
92870: NOT
92871: IFFALSE 92875
// continue ;
92873: GO 92814
// for j := minerMinesList [ i ] downto 1 do
92875: LD_ADDR_VAR 0 2
92879: PUSH
92880: DOUBLE
92881: LD_EXP 93
92885: PUSH
92886: LD_VAR 0 1
92890: ARRAY
92891: INC
92892: ST_TO_ADDR
92893: LD_INT 1
92895: PUSH
92896: FOR_DOWNTO
92897: IFFALSE 93147
// begin side := GetSide ( minersList [ i ] ) ;
92899: LD_ADDR_VAR 0 3
92903: PUSH
92904: LD_EXP 92
92908: PUSH
92909: LD_VAR 0 1
92913: ARRAY
92914: PPUSH
92915: CALL_OW 255
92919: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
92920: LD_ADDR_VAR 0 4
92924: PUSH
92925: LD_EXP 93
92929: PUSH
92930: LD_VAR 0 1
92934: ARRAY
92935: PUSH
92936: LD_VAR 0 2
92940: ARRAY
92941: PUSH
92942: LD_INT 1
92944: ARRAY
92945: PPUSH
92946: LD_EXP 93
92950: PUSH
92951: LD_VAR 0 1
92955: ARRAY
92956: PUSH
92957: LD_VAR 0 2
92961: ARRAY
92962: PUSH
92963: LD_INT 2
92965: ARRAY
92966: PPUSH
92967: CALL_OW 428
92971: ST_TO_ADDR
// if not tmp then
92972: LD_VAR 0 4
92976: NOT
92977: IFFALSE 92981
// continue ;
92979: GO 92896
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
92981: LD_VAR 0 4
92985: PUSH
92986: LD_INT 81
92988: PUSH
92989: LD_VAR 0 3
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PPUSH
92998: CALL_OW 69
93002: IN
93003: PUSH
93004: LD_EXP 93
93008: PUSH
93009: LD_VAR 0 1
93013: ARRAY
93014: PUSH
93015: LD_VAR 0 2
93019: ARRAY
93020: PUSH
93021: LD_INT 1
93023: ARRAY
93024: PPUSH
93025: LD_EXP 93
93029: PUSH
93030: LD_VAR 0 1
93034: ARRAY
93035: PUSH
93036: LD_VAR 0 2
93040: ARRAY
93041: PUSH
93042: LD_INT 2
93044: ARRAY
93045: PPUSH
93046: CALL_OW 458
93050: AND
93051: IFFALSE 93145
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
93053: LD_EXP 93
93057: PUSH
93058: LD_VAR 0 1
93062: ARRAY
93063: PUSH
93064: LD_VAR 0 2
93068: ARRAY
93069: PUSH
93070: LD_INT 1
93072: ARRAY
93073: PPUSH
93074: LD_EXP 93
93078: PUSH
93079: LD_VAR 0 1
93083: ARRAY
93084: PUSH
93085: LD_VAR 0 2
93089: ARRAY
93090: PUSH
93091: LD_INT 2
93093: ARRAY
93094: PPUSH
93095: LD_VAR 0 3
93099: PPUSH
93100: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
93104: LD_ADDR_EXP 93
93108: PUSH
93109: LD_EXP 93
93113: PPUSH
93114: LD_VAR 0 1
93118: PPUSH
93119: LD_EXP 93
93123: PUSH
93124: LD_VAR 0 1
93128: ARRAY
93129: PPUSH
93130: LD_VAR 0 2
93134: PPUSH
93135: CALL_OW 3
93139: PPUSH
93140: CALL_OW 1
93144: ST_TO_ADDR
// end ; end ;
93145: GO 92896
93147: POP
93148: POP
// end ;
93149: GO 92814
93151: POP
93152: POP
// end ;
93153: PPOPN 4
93155: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
93156: LD_INT 0
93158: PPUSH
93159: PPUSH
// result := false ;
93160: LD_ADDR_VAR 0 4
93164: PUSH
93165: LD_INT 0
93167: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
93168: LD_VAR 0 1
93172: PPUSH
93173: CALL_OW 264
93177: PUSH
93178: LD_EXP 74
93182: EQUAL
93183: NOT
93184: IFFALSE 93188
// exit ;
93186: GO 93428
// index := GetElementIndex ( minersList , unit ) ;
93188: LD_ADDR_VAR 0 5
93192: PUSH
93193: LD_EXP 92
93197: PPUSH
93198: LD_VAR 0 1
93202: PPUSH
93203: CALL 15951 0 2
93207: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
93208: LD_EXP 93
93212: PUSH
93213: LD_VAR 0 5
93217: ARRAY
93218: PUSH
93219: LD_EXP 94
93223: GREATEREQUAL
93224: IFFALSE 93228
// exit ;
93226: GO 93428
// ComMoveXY ( unit , x , y ) ;
93228: LD_VAR 0 1
93232: PPUSH
93233: LD_VAR 0 2
93237: PPUSH
93238: LD_VAR 0 3
93242: PPUSH
93243: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93247: LD_INT 35
93249: PPUSH
93250: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93254: LD_VAR 0 1
93258: PPUSH
93259: LD_VAR 0 2
93263: PPUSH
93264: LD_VAR 0 3
93268: PPUSH
93269: CALL 47237 0 3
93273: NOT
93274: PUSH
93275: LD_VAR 0 1
93279: PPUSH
93280: CALL_OW 314
93284: AND
93285: IFFALSE 93289
// exit ;
93287: GO 93428
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93289: LD_VAR 0 2
93293: PPUSH
93294: LD_VAR 0 3
93298: PPUSH
93299: CALL_OW 428
93303: PUSH
93304: LD_VAR 0 1
93308: EQUAL
93309: PUSH
93310: LD_VAR 0 1
93314: PPUSH
93315: CALL_OW 314
93319: NOT
93320: AND
93321: IFFALSE 93247
// PlaySoundXY ( x , y , PlantMine ) ;
93323: LD_VAR 0 2
93327: PPUSH
93328: LD_VAR 0 3
93332: PPUSH
93333: LD_STRING PlantMine
93335: PPUSH
93336: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93340: LD_VAR 0 2
93344: PPUSH
93345: LD_VAR 0 3
93349: PPUSH
93350: LD_VAR 0 1
93354: PPUSH
93355: CALL_OW 255
93359: PPUSH
93360: LD_INT 0
93362: PPUSH
93363: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93367: LD_ADDR_EXP 93
93371: PUSH
93372: LD_EXP 93
93376: PPUSH
93377: LD_VAR 0 5
93381: PUSH
93382: LD_EXP 93
93386: PUSH
93387: LD_VAR 0 5
93391: ARRAY
93392: PUSH
93393: LD_INT 1
93395: PLUS
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PPUSH
93401: LD_VAR 0 2
93405: PUSH
93406: LD_VAR 0 3
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PPUSH
93415: CALL 16166 0 3
93419: ST_TO_ADDR
// result := true ;
93420: LD_ADDR_VAR 0 4
93424: PUSH
93425: LD_INT 1
93427: ST_TO_ADDR
// end ;
93428: LD_VAR 0 4
93432: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93433: LD_INT 0
93435: PPUSH
93436: PPUSH
93437: PPUSH
// if not unit in minersList then
93438: LD_VAR 0 1
93442: PUSH
93443: LD_EXP 92
93447: IN
93448: NOT
93449: IFFALSE 93453
// exit ;
93451: GO 93845
// index := GetElementIndex ( minersList , unit ) ;
93453: LD_ADDR_VAR 0 6
93457: PUSH
93458: LD_EXP 92
93462: PPUSH
93463: LD_VAR 0 1
93467: PPUSH
93468: CALL 15951 0 2
93472: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93473: LD_ADDR_VAR 0 5
93477: PUSH
93478: DOUBLE
93479: LD_EXP 93
93483: PUSH
93484: LD_VAR 0 6
93488: ARRAY
93489: INC
93490: ST_TO_ADDR
93491: LD_INT 1
93493: PUSH
93494: FOR_DOWNTO
93495: IFFALSE 93656
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93497: LD_EXP 93
93501: PUSH
93502: LD_VAR 0 6
93506: ARRAY
93507: PUSH
93508: LD_VAR 0 5
93512: ARRAY
93513: PUSH
93514: LD_INT 1
93516: ARRAY
93517: PUSH
93518: LD_VAR 0 2
93522: EQUAL
93523: PUSH
93524: LD_EXP 93
93528: PUSH
93529: LD_VAR 0 6
93533: ARRAY
93534: PUSH
93535: LD_VAR 0 5
93539: ARRAY
93540: PUSH
93541: LD_INT 2
93543: ARRAY
93544: PUSH
93545: LD_VAR 0 3
93549: EQUAL
93550: AND
93551: IFFALSE 93654
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93553: LD_EXP 93
93557: PUSH
93558: LD_VAR 0 6
93562: ARRAY
93563: PUSH
93564: LD_VAR 0 5
93568: ARRAY
93569: PUSH
93570: LD_INT 1
93572: ARRAY
93573: PPUSH
93574: LD_EXP 93
93578: PUSH
93579: LD_VAR 0 6
93583: ARRAY
93584: PUSH
93585: LD_VAR 0 5
93589: ARRAY
93590: PUSH
93591: LD_INT 2
93593: ARRAY
93594: PPUSH
93595: LD_VAR 0 1
93599: PPUSH
93600: CALL_OW 255
93604: PPUSH
93605: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93609: LD_ADDR_EXP 93
93613: PUSH
93614: LD_EXP 93
93618: PPUSH
93619: LD_VAR 0 6
93623: PPUSH
93624: LD_EXP 93
93628: PUSH
93629: LD_VAR 0 6
93633: ARRAY
93634: PPUSH
93635: LD_VAR 0 5
93639: PPUSH
93640: CALL_OW 3
93644: PPUSH
93645: CALL_OW 1
93649: ST_TO_ADDR
// exit ;
93650: POP
93651: POP
93652: GO 93845
// end ; end ;
93654: GO 93494
93656: POP
93657: POP
// for i := minerMinesList [ index ] downto 1 do
93658: LD_ADDR_VAR 0 5
93662: PUSH
93663: DOUBLE
93664: LD_EXP 93
93668: PUSH
93669: LD_VAR 0 6
93673: ARRAY
93674: INC
93675: ST_TO_ADDR
93676: LD_INT 1
93678: PUSH
93679: FOR_DOWNTO
93680: IFFALSE 93843
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93682: LD_EXP 93
93686: PUSH
93687: LD_VAR 0 6
93691: ARRAY
93692: PUSH
93693: LD_VAR 0 5
93697: ARRAY
93698: PUSH
93699: LD_INT 1
93701: ARRAY
93702: PPUSH
93703: LD_EXP 93
93707: PUSH
93708: LD_VAR 0 6
93712: ARRAY
93713: PUSH
93714: LD_VAR 0 5
93718: ARRAY
93719: PUSH
93720: LD_INT 2
93722: ARRAY
93723: PPUSH
93724: LD_VAR 0 2
93728: PPUSH
93729: LD_VAR 0 3
93733: PPUSH
93734: CALL_OW 298
93738: PUSH
93739: LD_INT 6
93741: LESS
93742: IFFALSE 93841
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93744: LD_EXP 93
93748: PUSH
93749: LD_VAR 0 6
93753: ARRAY
93754: PUSH
93755: LD_VAR 0 5
93759: ARRAY
93760: PUSH
93761: LD_INT 1
93763: ARRAY
93764: PPUSH
93765: LD_EXP 93
93769: PUSH
93770: LD_VAR 0 6
93774: ARRAY
93775: PUSH
93776: LD_VAR 0 5
93780: ARRAY
93781: PUSH
93782: LD_INT 2
93784: ARRAY
93785: PPUSH
93786: LD_VAR 0 1
93790: PPUSH
93791: CALL_OW 255
93795: PPUSH
93796: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93800: LD_ADDR_EXP 93
93804: PUSH
93805: LD_EXP 93
93809: PPUSH
93810: LD_VAR 0 6
93814: PPUSH
93815: LD_EXP 93
93819: PUSH
93820: LD_VAR 0 6
93824: ARRAY
93825: PPUSH
93826: LD_VAR 0 5
93830: PPUSH
93831: CALL_OW 3
93835: PPUSH
93836: CALL_OW 1
93840: ST_TO_ADDR
// end ; end ;
93841: GO 93679
93843: POP
93844: POP
// end ;
93845: LD_VAR 0 4
93849: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
93850: LD_INT 0
93852: PPUSH
93853: PPUSH
93854: PPUSH
93855: PPUSH
93856: PPUSH
93857: PPUSH
93858: PPUSH
93859: PPUSH
93860: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
93861: LD_VAR 0 1
93865: PPUSH
93866: CALL_OW 264
93870: PUSH
93871: LD_EXP 74
93875: EQUAL
93876: NOT
93877: PUSH
93878: LD_VAR 0 1
93882: PUSH
93883: LD_EXP 92
93887: IN
93888: NOT
93889: OR
93890: IFFALSE 93894
// exit ;
93892: GO 94216
// index := GetElementIndex ( minersList , unit ) ;
93894: LD_ADDR_VAR 0 6
93898: PUSH
93899: LD_EXP 92
93903: PPUSH
93904: LD_VAR 0 1
93908: PPUSH
93909: CALL 15951 0 2
93913: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
93914: LD_ADDR_VAR 0 8
93918: PUSH
93919: LD_EXP 94
93923: PUSH
93924: LD_EXP 93
93928: PUSH
93929: LD_VAR 0 6
93933: ARRAY
93934: MINUS
93935: ST_TO_ADDR
// if not minesFreeAmount then
93936: LD_VAR 0 8
93940: NOT
93941: IFFALSE 93945
// exit ;
93943: GO 94216
// tmp := [ ] ;
93945: LD_ADDR_VAR 0 7
93949: PUSH
93950: EMPTY
93951: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
93952: LD_ADDR_VAR 0 5
93956: PUSH
93957: DOUBLE
93958: LD_INT 1
93960: DEC
93961: ST_TO_ADDR
93962: LD_VAR 0 8
93966: PUSH
93967: FOR_TO
93968: IFFALSE 94163
// begin _d := rand ( 0 , 5 ) ;
93970: LD_ADDR_VAR 0 11
93974: PUSH
93975: LD_INT 0
93977: PPUSH
93978: LD_INT 5
93980: PPUSH
93981: CALL_OW 12
93985: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
93986: LD_ADDR_VAR 0 12
93990: PUSH
93991: LD_INT 2
93993: PPUSH
93994: LD_INT 6
93996: PPUSH
93997: CALL_OW 12
94001: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
94002: LD_ADDR_VAR 0 9
94006: PUSH
94007: LD_VAR 0 2
94011: PPUSH
94012: LD_VAR 0 11
94016: PPUSH
94017: LD_VAR 0 12
94021: PPUSH
94022: CALL_OW 272
94026: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
94027: LD_ADDR_VAR 0 10
94031: PUSH
94032: LD_VAR 0 3
94036: PPUSH
94037: LD_VAR 0 11
94041: PPUSH
94042: LD_VAR 0 12
94046: PPUSH
94047: CALL_OW 273
94051: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
94052: LD_VAR 0 9
94056: PPUSH
94057: LD_VAR 0 10
94061: PPUSH
94062: CALL_OW 488
94066: PUSH
94067: LD_VAR 0 9
94071: PUSH
94072: LD_VAR 0 10
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_VAR 0 7
94085: IN
94086: NOT
94087: AND
94088: PUSH
94089: LD_VAR 0 9
94093: PPUSH
94094: LD_VAR 0 10
94098: PPUSH
94099: CALL_OW 458
94103: NOT
94104: AND
94105: IFFALSE 94147
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
94107: LD_ADDR_VAR 0 7
94111: PUSH
94112: LD_VAR 0 7
94116: PPUSH
94117: LD_VAR 0 7
94121: PUSH
94122: LD_INT 1
94124: PLUS
94125: PPUSH
94126: LD_VAR 0 9
94130: PUSH
94131: LD_VAR 0 10
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: PPUSH
94140: CALL_OW 1
94144: ST_TO_ADDR
94145: GO 94161
// i := i - 1 ;
94147: LD_ADDR_VAR 0 5
94151: PUSH
94152: LD_VAR 0 5
94156: PUSH
94157: LD_INT 1
94159: MINUS
94160: ST_TO_ADDR
// end ;
94161: GO 93967
94163: POP
94164: POP
// for i in tmp do
94165: LD_ADDR_VAR 0 5
94169: PUSH
94170: LD_VAR 0 7
94174: PUSH
94175: FOR_IN
94176: IFFALSE 94214
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
94178: LD_VAR 0 1
94182: PPUSH
94183: LD_VAR 0 5
94187: PUSH
94188: LD_INT 1
94190: ARRAY
94191: PPUSH
94192: LD_VAR 0 5
94196: PUSH
94197: LD_INT 2
94199: ARRAY
94200: PPUSH
94201: CALL 93156 0 3
94205: NOT
94206: IFFALSE 94212
// exit ;
94208: POP
94209: POP
94210: GO 94216
94212: GO 94175
94214: POP
94215: POP
// end ;
94216: LD_VAR 0 4
94220: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
94221: LD_INT 0
94223: PPUSH
94224: PPUSH
94225: PPUSH
94226: PPUSH
94227: PPUSH
94228: PPUSH
94229: PPUSH
// if not GetClass ( unit ) = class_sniper then
94230: LD_VAR 0 1
94234: PPUSH
94235: CALL_OW 257
94239: PUSH
94240: LD_INT 5
94242: EQUAL
94243: NOT
94244: IFFALSE 94248
// exit ;
94246: GO 94636
// dist := 8 ;
94248: LD_ADDR_VAR 0 5
94252: PUSH
94253: LD_INT 8
94255: ST_TO_ADDR
// viewRange := 12 ;
94256: LD_ADDR_VAR 0 7
94260: PUSH
94261: LD_INT 12
94263: ST_TO_ADDR
// side := GetSide ( unit ) ;
94264: LD_ADDR_VAR 0 6
94268: PUSH
94269: LD_VAR 0 1
94273: PPUSH
94274: CALL_OW 255
94278: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94279: LD_INT 61
94281: PPUSH
94282: LD_VAR 0 6
94286: PPUSH
94287: CALL_OW 321
94291: PUSH
94292: LD_INT 2
94294: EQUAL
94295: IFFALSE 94305
// viewRange := 16 ;
94297: LD_ADDR_VAR 0 7
94301: PUSH
94302: LD_INT 16
94304: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94305: LD_VAR 0 1
94309: PPUSH
94310: LD_VAR 0 2
94314: PPUSH
94315: LD_VAR 0 3
94319: PPUSH
94320: CALL_OW 297
94324: PUSH
94325: LD_VAR 0 5
94329: GREATER
94330: IFFALSE 94409
// begin ComMoveXY ( unit , x , y ) ;
94332: LD_VAR 0 1
94336: PPUSH
94337: LD_VAR 0 2
94341: PPUSH
94342: LD_VAR 0 3
94346: PPUSH
94347: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94351: LD_INT 35
94353: PPUSH
94354: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94358: LD_VAR 0 1
94362: PPUSH
94363: LD_VAR 0 2
94367: PPUSH
94368: LD_VAR 0 3
94372: PPUSH
94373: CALL 47237 0 3
94377: NOT
94378: IFFALSE 94382
// exit ;
94380: GO 94636
// until GetDistUnitXY ( unit , x , y ) < dist ;
94382: LD_VAR 0 1
94386: PPUSH
94387: LD_VAR 0 2
94391: PPUSH
94392: LD_VAR 0 3
94396: PPUSH
94397: CALL_OW 297
94401: PUSH
94402: LD_VAR 0 5
94406: LESS
94407: IFFALSE 94351
// end ; ComTurnXY ( unit , x , y ) ;
94409: LD_VAR 0 1
94413: PPUSH
94414: LD_VAR 0 2
94418: PPUSH
94419: LD_VAR 0 3
94423: PPUSH
94424: CALL_OW 118
// wait ( 5 ) ;
94428: LD_INT 5
94430: PPUSH
94431: CALL_OW 67
// _d := GetDir ( unit ) ;
94435: LD_ADDR_VAR 0 10
94439: PUSH
94440: LD_VAR 0 1
94444: PPUSH
94445: CALL_OW 254
94449: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94450: LD_ADDR_VAR 0 8
94454: PUSH
94455: LD_VAR 0 1
94459: PPUSH
94460: CALL_OW 250
94464: PPUSH
94465: LD_VAR 0 10
94469: PPUSH
94470: LD_VAR 0 5
94474: PPUSH
94475: CALL_OW 272
94479: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94480: LD_ADDR_VAR 0 9
94484: PUSH
94485: LD_VAR 0 1
94489: PPUSH
94490: CALL_OW 251
94494: PPUSH
94495: LD_VAR 0 10
94499: PPUSH
94500: LD_VAR 0 5
94504: PPUSH
94505: CALL_OW 273
94509: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94510: LD_VAR 0 8
94514: PPUSH
94515: LD_VAR 0 9
94519: PPUSH
94520: CALL_OW 488
94524: NOT
94525: IFFALSE 94529
// exit ;
94527: GO 94636
// ComAnimCustom ( unit , 1 ) ;
94529: LD_VAR 0 1
94533: PPUSH
94534: LD_INT 1
94536: PPUSH
94537: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94541: LD_VAR 0 8
94545: PPUSH
94546: LD_VAR 0 9
94550: PPUSH
94551: LD_VAR 0 6
94555: PPUSH
94556: LD_VAR 0 7
94560: PPUSH
94561: CALL_OW 330
// repeat wait ( 1 ) ;
94565: LD_INT 1
94567: PPUSH
94568: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94572: LD_VAR 0 1
94576: PPUSH
94577: CALL_OW 316
94581: PUSH
94582: LD_VAR 0 1
94586: PPUSH
94587: CALL_OW 314
94591: OR
94592: PUSH
94593: LD_VAR 0 1
94597: PPUSH
94598: CALL_OW 302
94602: NOT
94603: OR
94604: PUSH
94605: LD_VAR 0 1
94609: PPUSH
94610: CALL_OW 301
94614: OR
94615: IFFALSE 94565
// RemoveSeeing ( _x , _y , side ) ;
94617: LD_VAR 0 8
94621: PPUSH
94622: LD_VAR 0 9
94626: PPUSH
94627: LD_VAR 0 6
94631: PPUSH
94632: CALL_OW 331
// end ; end_of_file end_of_file
94636: LD_VAR 0 4
94640: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94641: LD_VAR 0 1
94645: PUSH
94646: LD_INT 200
94648: DOUBLE
94649: GREATEREQUAL
94650: IFFALSE 94658
94652: LD_INT 299
94654: DOUBLE
94655: LESSEQUAL
94656: IFTRUE 94660
94658: GO 94692
94660: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94661: LD_VAR 0 1
94665: PPUSH
94666: LD_VAR 0 2
94670: PPUSH
94671: LD_VAR 0 3
94675: PPUSH
94676: LD_VAR 0 4
94680: PPUSH
94681: LD_VAR 0 5
94685: PPUSH
94686: CALL 90708 0 5
94690: GO 94769
94692: LD_INT 300
94694: DOUBLE
94695: GREATEREQUAL
94696: IFFALSE 94704
94698: LD_INT 399
94700: DOUBLE
94701: LESSEQUAL
94702: IFTRUE 94706
94704: GO 94768
94706: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
94707: LD_VAR 0 1
94711: PPUSH
94712: LD_VAR 0 2
94716: PPUSH
94717: LD_VAR 0 3
94721: PPUSH
94722: LD_VAR 0 4
94726: PPUSH
94727: LD_VAR 0 5
94731: PPUSH
94732: LD_VAR 0 6
94736: PPUSH
94737: LD_VAR 0 7
94741: PPUSH
94742: LD_VAR 0 8
94746: PPUSH
94747: LD_VAR 0 9
94751: PPUSH
94752: LD_VAR 0 10
94756: PPUSH
94757: LD_VAR 0 11
94761: PPUSH
94762: CALL 107162 0 11
94766: GO 94769
94768: POP
// end ;
94769: PPOPN 11
94771: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
94772: LD_VAR 0 1
94776: PPUSH
94777: LD_VAR 0 2
94781: PPUSH
94782: LD_VAR 0 3
94786: PPUSH
94787: LD_VAR 0 4
94791: PPUSH
94792: LD_VAR 0 5
94796: PPUSH
94797: CALL 90444 0 5
// end ; end_of_file
94801: PPOPN 5
94803: END
// every 0 0$1 do
94804: GO 94806
94806: DISABLE
// begin enable ;
94807: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94808: LD_STRING updateTimer(
94810: PUSH
94811: LD_OWVAR 1
94815: STR
94816: PUSH
94817: LD_STRING );
94819: STR
94820: PPUSH
94821: CALL_OW 559
// end ;
94825: END
// export function SOS_MapStart ( ) ; begin
94826: LD_INT 0
94828: PPUSH
// if streamModeActive then
94829: LD_EXP 95
94833: IFFALSE 94842
// DefineStreamItems ( true ) ;
94835: LD_INT 1
94837: PPUSH
94838: CALL 96496 0 1
// UpdateFactoryWaypoints ( ) ;
94842: CALL 109357 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94846: CALL 109614 0 0
// end ;
94850: LD_VAR 0 1
94854: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94855: LD_INT 0
94857: PPUSH
// if p2 = 100 then
94858: LD_VAR 0 2
94862: PUSH
94863: LD_INT 100
94865: EQUAL
94866: IFFALSE 95869
// begin if not StreamModeActive then
94868: LD_EXP 95
94872: NOT
94873: IFFALSE 94883
// StreamModeActive := true ;
94875: LD_ADDR_EXP 95
94879: PUSH
94880: LD_INT 1
94882: ST_TO_ADDR
// if p3 = 0 then
94883: LD_VAR 0 3
94887: PUSH
94888: LD_INT 0
94890: EQUAL
94891: IFFALSE 94897
// InitStreamMode ;
94893: CALL 96032 0 0
// if p3 = 1 then
94897: LD_VAR 0 3
94901: PUSH
94902: LD_INT 1
94904: EQUAL
94905: IFFALSE 94915
// sRocket := true ;
94907: LD_ADDR_EXP 100
94911: PUSH
94912: LD_INT 1
94914: ST_TO_ADDR
// if p3 = 2 then
94915: LD_VAR 0 3
94919: PUSH
94920: LD_INT 2
94922: EQUAL
94923: IFFALSE 94933
// sSpeed := true ;
94925: LD_ADDR_EXP 99
94929: PUSH
94930: LD_INT 1
94932: ST_TO_ADDR
// if p3 = 3 then
94933: LD_VAR 0 3
94937: PUSH
94938: LD_INT 3
94940: EQUAL
94941: IFFALSE 94951
// sEngine := true ;
94943: LD_ADDR_EXP 101
94947: PUSH
94948: LD_INT 1
94950: ST_TO_ADDR
// if p3 = 4 then
94951: LD_VAR 0 3
94955: PUSH
94956: LD_INT 4
94958: EQUAL
94959: IFFALSE 94969
// sSpec := true ;
94961: LD_ADDR_EXP 98
94965: PUSH
94966: LD_INT 1
94968: ST_TO_ADDR
// if p3 = 5 then
94969: LD_VAR 0 3
94973: PUSH
94974: LD_INT 5
94976: EQUAL
94977: IFFALSE 94987
// sLevel := true ;
94979: LD_ADDR_EXP 102
94983: PUSH
94984: LD_INT 1
94986: ST_TO_ADDR
// if p3 = 6 then
94987: LD_VAR 0 3
94991: PUSH
94992: LD_INT 6
94994: EQUAL
94995: IFFALSE 95005
// sArmoury := true ;
94997: LD_ADDR_EXP 103
95001: PUSH
95002: LD_INT 1
95004: ST_TO_ADDR
// if p3 = 7 then
95005: LD_VAR 0 3
95009: PUSH
95010: LD_INT 7
95012: EQUAL
95013: IFFALSE 95023
// sRadar := true ;
95015: LD_ADDR_EXP 104
95019: PUSH
95020: LD_INT 1
95022: ST_TO_ADDR
// if p3 = 8 then
95023: LD_VAR 0 3
95027: PUSH
95028: LD_INT 8
95030: EQUAL
95031: IFFALSE 95041
// sBunker := true ;
95033: LD_ADDR_EXP 105
95037: PUSH
95038: LD_INT 1
95040: ST_TO_ADDR
// if p3 = 9 then
95041: LD_VAR 0 3
95045: PUSH
95046: LD_INT 9
95048: EQUAL
95049: IFFALSE 95059
// sHack := true ;
95051: LD_ADDR_EXP 106
95055: PUSH
95056: LD_INT 1
95058: ST_TO_ADDR
// if p3 = 10 then
95059: LD_VAR 0 3
95063: PUSH
95064: LD_INT 10
95066: EQUAL
95067: IFFALSE 95077
// sFire := true ;
95069: LD_ADDR_EXP 107
95073: PUSH
95074: LD_INT 1
95076: ST_TO_ADDR
// if p3 = 11 then
95077: LD_VAR 0 3
95081: PUSH
95082: LD_INT 11
95084: EQUAL
95085: IFFALSE 95095
// sRefresh := true ;
95087: LD_ADDR_EXP 108
95091: PUSH
95092: LD_INT 1
95094: ST_TO_ADDR
// if p3 = 12 then
95095: LD_VAR 0 3
95099: PUSH
95100: LD_INT 12
95102: EQUAL
95103: IFFALSE 95113
// sExp := true ;
95105: LD_ADDR_EXP 109
95109: PUSH
95110: LD_INT 1
95112: ST_TO_ADDR
// if p3 = 13 then
95113: LD_VAR 0 3
95117: PUSH
95118: LD_INT 13
95120: EQUAL
95121: IFFALSE 95131
// sDepot := true ;
95123: LD_ADDR_EXP 110
95127: PUSH
95128: LD_INT 1
95130: ST_TO_ADDR
// if p3 = 14 then
95131: LD_VAR 0 3
95135: PUSH
95136: LD_INT 14
95138: EQUAL
95139: IFFALSE 95149
// sFlag := true ;
95141: LD_ADDR_EXP 111
95145: PUSH
95146: LD_INT 1
95148: ST_TO_ADDR
// if p3 = 15 then
95149: LD_VAR 0 3
95153: PUSH
95154: LD_INT 15
95156: EQUAL
95157: IFFALSE 95167
// sKamikadze := true ;
95159: LD_ADDR_EXP 119
95163: PUSH
95164: LD_INT 1
95166: ST_TO_ADDR
// if p3 = 16 then
95167: LD_VAR 0 3
95171: PUSH
95172: LD_INT 16
95174: EQUAL
95175: IFFALSE 95185
// sTroll := true ;
95177: LD_ADDR_EXP 120
95181: PUSH
95182: LD_INT 1
95184: ST_TO_ADDR
// if p3 = 17 then
95185: LD_VAR 0 3
95189: PUSH
95190: LD_INT 17
95192: EQUAL
95193: IFFALSE 95203
// sSlow := true ;
95195: LD_ADDR_EXP 121
95199: PUSH
95200: LD_INT 1
95202: ST_TO_ADDR
// if p3 = 18 then
95203: LD_VAR 0 3
95207: PUSH
95208: LD_INT 18
95210: EQUAL
95211: IFFALSE 95221
// sLack := true ;
95213: LD_ADDR_EXP 122
95217: PUSH
95218: LD_INT 1
95220: ST_TO_ADDR
// if p3 = 19 then
95221: LD_VAR 0 3
95225: PUSH
95226: LD_INT 19
95228: EQUAL
95229: IFFALSE 95239
// sTank := true ;
95231: LD_ADDR_EXP 124
95235: PUSH
95236: LD_INT 1
95238: ST_TO_ADDR
// if p3 = 20 then
95239: LD_VAR 0 3
95243: PUSH
95244: LD_INT 20
95246: EQUAL
95247: IFFALSE 95257
// sRemote := true ;
95249: LD_ADDR_EXP 125
95253: PUSH
95254: LD_INT 1
95256: ST_TO_ADDR
// if p3 = 21 then
95257: LD_VAR 0 3
95261: PUSH
95262: LD_INT 21
95264: EQUAL
95265: IFFALSE 95275
// sPowell := true ;
95267: LD_ADDR_EXP 126
95271: PUSH
95272: LD_INT 1
95274: ST_TO_ADDR
// if p3 = 22 then
95275: LD_VAR 0 3
95279: PUSH
95280: LD_INT 22
95282: EQUAL
95283: IFFALSE 95293
// sTeleport := true ;
95285: LD_ADDR_EXP 129
95289: PUSH
95290: LD_INT 1
95292: ST_TO_ADDR
// if p3 = 23 then
95293: LD_VAR 0 3
95297: PUSH
95298: LD_INT 23
95300: EQUAL
95301: IFFALSE 95311
// sOilTower := true ;
95303: LD_ADDR_EXP 131
95307: PUSH
95308: LD_INT 1
95310: ST_TO_ADDR
// if p3 = 24 then
95311: LD_VAR 0 3
95315: PUSH
95316: LD_INT 24
95318: EQUAL
95319: IFFALSE 95329
// sShovel := true ;
95321: LD_ADDR_EXP 132
95325: PUSH
95326: LD_INT 1
95328: ST_TO_ADDR
// if p3 = 25 then
95329: LD_VAR 0 3
95333: PUSH
95334: LD_INT 25
95336: EQUAL
95337: IFFALSE 95347
// sSheik := true ;
95339: LD_ADDR_EXP 133
95343: PUSH
95344: LD_INT 1
95346: ST_TO_ADDR
// if p3 = 26 then
95347: LD_VAR 0 3
95351: PUSH
95352: LD_INT 26
95354: EQUAL
95355: IFFALSE 95365
// sEarthquake := true ;
95357: LD_ADDR_EXP 135
95361: PUSH
95362: LD_INT 1
95364: ST_TO_ADDR
// if p3 = 27 then
95365: LD_VAR 0 3
95369: PUSH
95370: LD_INT 27
95372: EQUAL
95373: IFFALSE 95383
// sAI := true ;
95375: LD_ADDR_EXP 136
95379: PUSH
95380: LD_INT 1
95382: ST_TO_ADDR
// if p3 = 28 then
95383: LD_VAR 0 3
95387: PUSH
95388: LD_INT 28
95390: EQUAL
95391: IFFALSE 95401
// sCargo := true ;
95393: LD_ADDR_EXP 139
95397: PUSH
95398: LD_INT 1
95400: ST_TO_ADDR
// if p3 = 29 then
95401: LD_VAR 0 3
95405: PUSH
95406: LD_INT 29
95408: EQUAL
95409: IFFALSE 95419
// sDLaser := true ;
95411: LD_ADDR_EXP 140
95415: PUSH
95416: LD_INT 1
95418: ST_TO_ADDR
// if p3 = 30 then
95419: LD_VAR 0 3
95423: PUSH
95424: LD_INT 30
95426: EQUAL
95427: IFFALSE 95437
// sExchange := true ;
95429: LD_ADDR_EXP 141
95433: PUSH
95434: LD_INT 1
95436: ST_TO_ADDR
// if p3 = 31 then
95437: LD_VAR 0 3
95441: PUSH
95442: LD_INT 31
95444: EQUAL
95445: IFFALSE 95455
// sFac := true ;
95447: LD_ADDR_EXP 142
95451: PUSH
95452: LD_INT 1
95454: ST_TO_ADDR
// if p3 = 32 then
95455: LD_VAR 0 3
95459: PUSH
95460: LD_INT 32
95462: EQUAL
95463: IFFALSE 95473
// sPower := true ;
95465: LD_ADDR_EXP 143
95469: PUSH
95470: LD_INT 1
95472: ST_TO_ADDR
// if p3 = 33 then
95473: LD_VAR 0 3
95477: PUSH
95478: LD_INT 33
95480: EQUAL
95481: IFFALSE 95491
// sRandom := true ;
95483: LD_ADDR_EXP 144
95487: PUSH
95488: LD_INT 1
95490: ST_TO_ADDR
// if p3 = 34 then
95491: LD_VAR 0 3
95495: PUSH
95496: LD_INT 34
95498: EQUAL
95499: IFFALSE 95509
// sShield := true ;
95501: LD_ADDR_EXP 145
95505: PUSH
95506: LD_INT 1
95508: ST_TO_ADDR
// if p3 = 35 then
95509: LD_VAR 0 3
95513: PUSH
95514: LD_INT 35
95516: EQUAL
95517: IFFALSE 95527
// sTime := true ;
95519: LD_ADDR_EXP 146
95523: PUSH
95524: LD_INT 1
95526: ST_TO_ADDR
// if p3 = 36 then
95527: LD_VAR 0 3
95531: PUSH
95532: LD_INT 36
95534: EQUAL
95535: IFFALSE 95545
// sTools := true ;
95537: LD_ADDR_EXP 147
95541: PUSH
95542: LD_INT 1
95544: ST_TO_ADDR
// if p3 = 101 then
95545: LD_VAR 0 3
95549: PUSH
95550: LD_INT 101
95552: EQUAL
95553: IFFALSE 95563
// sSold := true ;
95555: LD_ADDR_EXP 112
95559: PUSH
95560: LD_INT 1
95562: ST_TO_ADDR
// if p3 = 102 then
95563: LD_VAR 0 3
95567: PUSH
95568: LD_INT 102
95570: EQUAL
95571: IFFALSE 95581
// sDiff := true ;
95573: LD_ADDR_EXP 113
95577: PUSH
95578: LD_INT 1
95580: ST_TO_ADDR
// if p3 = 103 then
95581: LD_VAR 0 3
95585: PUSH
95586: LD_INT 103
95588: EQUAL
95589: IFFALSE 95599
// sFog := true ;
95591: LD_ADDR_EXP 116
95595: PUSH
95596: LD_INT 1
95598: ST_TO_ADDR
// if p3 = 104 then
95599: LD_VAR 0 3
95603: PUSH
95604: LD_INT 104
95606: EQUAL
95607: IFFALSE 95617
// sReset := true ;
95609: LD_ADDR_EXP 117
95613: PUSH
95614: LD_INT 1
95616: ST_TO_ADDR
// if p3 = 105 then
95617: LD_VAR 0 3
95621: PUSH
95622: LD_INT 105
95624: EQUAL
95625: IFFALSE 95635
// sSun := true ;
95627: LD_ADDR_EXP 118
95631: PUSH
95632: LD_INT 1
95634: ST_TO_ADDR
// if p3 = 106 then
95635: LD_VAR 0 3
95639: PUSH
95640: LD_INT 106
95642: EQUAL
95643: IFFALSE 95653
// sTiger := true ;
95645: LD_ADDR_EXP 114
95649: PUSH
95650: LD_INT 1
95652: ST_TO_ADDR
// if p3 = 107 then
95653: LD_VAR 0 3
95657: PUSH
95658: LD_INT 107
95660: EQUAL
95661: IFFALSE 95671
// sBomb := true ;
95663: LD_ADDR_EXP 115
95667: PUSH
95668: LD_INT 1
95670: ST_TO_ADDR
// if p3 = 108 then
95671: LD_VAR 0 3
95675: PUSH
95676: LD_INT 108
95678: EQUAL
95679: IFFALSE 95689
// sWound := true ;
95681: LD_ADDR_EXP 123
95685: PUSH
95686: LD_INT 1
95688: ST_TO_ADDR
// if p3 = 109 then
95689: LD_VAR 0 3
95693: PUSH
95694: LD_INT 109
95696: EQUAL
95697: IFFALSE 95707
// sBetray := true ;
95699: LD_ADDR_EXP 127
95703: PUSH
95704: LD_INT 1
95706: ST_TO_ADDR
// if p3 = 110 then
95707: LD_VAR 0 3
95711: PUSH
95712: LD_INT 110
95714: EQUAL
95715: IFFALSE 95725
// sContamin := true ;
95717: LD_ADDR_EXP 128
95721: PUSH
95722: LD_INT 1
95724: ST_TO_ADDR
// if p3 = 111 then
95725: LD_VAR 0 3
95729: PUSH
95730: LD_INT 111
95732: EQUAL
95733: IFFALSE 95743
// sOil := true ;
95735: LD_ADDR_EXP 130
95739: PUSH
95740: LD_INT 1
95742: ST_TO_ADDR
// if p3 = 112 then
95743: LD_VAR 0 3
95747: PUSH
95748: LD_INT 112
95750: EQUAL
95751: IFFALSE 95761
// sStu := true ;
95753: LD_ADDR_EXP 134
95757: PUSH
95758: LD_INT 1
95760: ST_TO_ADDR
// if p3 = 113 then
95761: LD_VAR 0 3
95765: PUSH
95766: LD_INT 113
95768: EQUAL
95769: IFFALSE 95779
// sBazooka := true ;
95771: LD_ADDR_EXP 137
95775: PUSH
95776: LD_INT 1
95778: ST_TO_ADDR
// if p3 = 114 then
95779: LD_VAR 0 3
95783: PUSH
95784: LD_INT 114
95786: EQUAL
95787: IFFALSE 95797
// sMortar := true ;
95789: LD_ADDR_EXP 138
95793: PUSH
95794: LD_INT 1
95796: ST_TO_ADDR
// if p3 = 115 then
95797: LD_VAR 0 3
95801: PUSH
95802: LD_INT 115
95804: EQUAL
95805: IFFALSE 95815
// sRanger := true ;
95807: LD_ADDR_EXP 148
95811: PUSH
95812: LD_INT 1
95814: ST_TO_ADDR
// if p3 = 116 then
95815: LD_VAR 0 3
95819: PUSH
95820: LD_INT 116
95822: EQUAL
95823: IFFALSE 95833
// sComputer := true ;
95825: LD_ADDR_EXP 149
95829: PUSH
95830: LD_INT 1
95832: ST_TO_ADDR
// if p3 = 117 then
95833: LD_VAR 0 3
95837: PUSH
95838: LD_INT 117
95840: EQUAL
95841: IFFALSE 95851
// s30 := true ;
95843: LD_ADDR_EXP 150
95847: PUSH
95848: LD_INT 1
95850: ST_TO_ADDR
// if p3 = 118 then
95851: LD_VAR 0 3
95855: PUSH
95856: LD_INT 118
95858: EQUAL
95859: IFFALSE 95869
// s60 := true ;
95861: LD_ADDR_EXP 151
95865: PUSH
95866: LD_INT 1
95868: ST_TO_ADDR
// end ; if p2 = 101 then
95869: LD_VAR 0 2
95873: PUSH
95874: LD_INT 101
95876: EQUAL
95877: IFFALSE 96005
// begin case p3 of 1 :
95879: LD_VAR 0 3
95883: PUSH
95884: LD_INT 1
95886: DOUBLE
95887: EQUAL
95888: IFTRUE 95892
95890: GO 95899
95892: POP
// hHackUnlimitedResources ; 2 :
95893: CALL 108103 0 0
95897: GO 96005
95899: LD_INT 2
95901: DOUBLE
95902: EQUAL
95903: IFTRUE 95907
95905: GO 95914
95907: POP
// hHackSetLevel10 ; 3 :
95908: CALL 108236 0 0
95912: GO 96005
95914: LD_INT 3
95916: DOUBLE
95917: EQUAL
95918: IFTRUE 95922
95920: GO 95929
95922: POP
// hHackSetLevel10YourUnits ; 4 :
95923: CALL 108321 0 0
95927: GO 96005
95929: LD_INT 4
95931: DOUBLE
95932: EQUAL
95933: IFTRUE 95937
95935: GO 95944
95937: POP
// hHackInvincible ; 5 :
95938: CALL 108769 0 0
95942: GO 96005
95944: LD_INT 5
95946: DOUBLE
95947: EQUAL
95948: IFTRUE 95952
95950: GO 95959
95952: POP
// hHackInvisible ; 6 :
95953: CALL 108880 0 0
95957: GO 96005
95959: LD_INT 6
95961: DOUBLE
95962: EQUAL
95963: IFTRUE 95967
95965: GO 95974
95967: POP
// hHackChangeYourSide ; 7 :
95968: CALL 108937 0 0
95972: GO 96005
95974: LD_INT 7
95976: DOUBLE
95977: EQUAL
95978: IFTRUE 95982
95980: GO 95989
95982: POP
// hHackChangeUnitSide ; 8 :
95983: CALL 108979 0 0
95987: GO 96005
95989: LD_INT 8
95991: DOUBLE
95992: EQUAL
95993: IFTRUE 95997
95995: GO 96004
95997: POP
// hHackFog ; end ;
95998: CALL 109080 0 0
96002: GO 96005
96004: POP
// end ; end ;
96005: LD_VAR 0 7
96009: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
96010: GO 96012
96012: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
96013: LD_STRING initStreamRollete();
96015: PPUSH
96016: CALL_OW 559
// InitStreamMode ;
96020: CALL 96032 0 0
// DefineStreamItems ( false ) ;
96024: LD_INT 0
96026: PPUSH
96027: CALL 96496 0 1
// end ;
96031: END
// function InitStreamMode ; begin
96032: LD_INT 0
96034: PPUSH
// streamModeActive := false ;
96035: LD_ADDR_EXP 95
96039: PUSH
96040: LD_INT 0
96042: ST_TO_ADDR
// normalCounter := 36 ;
96043: LD_ADDR_EXP 96
96047: PUSH
96048: LD_INT 36
96050: ST_TO_ADDR
// hardcoreCounter := 18 ;
96051: LD_ADDR_EXP 97
96055: PUSH
96056: LD_INT 18
96058: ST_TO_ADDR
// sRocket := false ;
96059: LD_ADDR_EXP 100
96063: PUSH
96064: LD_INT 0
96066: ST_TO_ADDR
// sSpeed := false ;
96067: LD_ADDR_EXP 99
96071: PUSH
96072: LD_INT 0
96074: ST_TO_ADDR
// sEngine := false ;
96075: LD_ADDR_EXP 101
96079: PUSH
96080: LD_INT 0
96082: ST_TO_ADDR
// sSpec := false ;
96083: LD_ADDR_EXP 98
96087: PUSH
96088: LD_INT 0
96090: ST_TO_ADDR
// sLevel := false ;
96091: LD_ADDR_EXP 102
96095: PUSH
96096: LD_INT 0
96098: ST_TO_ADDR
// sArmoury := false ;
96099: LD_ADDR_EXP 103
96103: PUSH
96104: LD_INT 0
96106: ST_TO_ADDR
// sRadar := false ;
96107: LD_ADDR_EXP 104
96111: PUSH
96112: LD_INT 0
96114: ST_TO_ADDR
// sBunker := false ;
96115: LD_ADDR_EXP 105
96119: PUSH
96120: LD_INT 0
96122: ST_TO_ADDR
// sHack := false ;
96123: LD_ADDR_EXP 106
96127: PUSH
96128: LD_INT 0
96130: ST_TO_ADDR
// sFire := false ;
96131: LD_ADDR_EXP 107
96135: PUSH
96136: LD_INT 0
96138: ST_TO_ADDR
// sRefresh := false ;
96139: LD_ADDR_EXP 108
96143: PUSH
96144: LD_INT 0
96146: ST_TO_ADDR
// sExp := false ;
96147: LD_ADDR_EXP 109
96151: PUSH
96152: LD_INT 0
96154: ST_TO_ADDR
// sDepot := false ;
96155: LD_ADDR_EXP 110
96159: PUSH
96160: LD_INT 0
96162: ST_TO_ADDR
// sFlag := false ;
96163: LD_ADDR_EXP 111
96167: PUSH
96168: LD_INT 0
96170: ST_TO_ADDR
// sKamikadze := false ;
96171: LD_ADDR_EXP 119
96175: PUSH
96176: LD_INT 0
96178: ST_TO_ADDR
// sTroll := false ;
96179: LD_ADDR_EXP 120
96183: PUSH
96184: LD_INT 0
96186: ST_TO_ADDR
// sSlow := false ;
96187: LD_ADDR_EXP 121
96191: PUSH
96192: LD_INT 0
96194: ST_TO_ADDR
// sLack := false ;
96195: LD_ADDR_EXP 122
96199: PUSH
96200: LD_INT 0
96202: ST_TO_ADDR
// sTank := false ;
96203: LD_ADDR_EXP 124
96207: PUSH
96208: LD_INT 0
96210: ST_TO_ADDR
// sRemote := false ;
96211: LD_ADDR_EXP 125
96215: PUSH
96216: LD_INT 0
96218: ST_TO_ADDR
// sPowell := false ;
96219: LD_ADDR_EXP 126
96223: PUSH
96224: LD_INT 0
96226: ST_TO_ADDR
// sTeleport := false ;
96227: LD_ADDR_EXP 129
96231: PUSH
96232: LD_INT 0
96234: ST_TO_ADDR
// sOilTower := false ;
96235: LD_ADDR_EXP 131
96239: PUSH
96240: LD_INT 0
96242: ST_TO_ADDR
// sShovel := false ;
96243: LD_ADDR_EXP 132
96247: PUSH
96248: LD_INT 0
96250: ST_TO_ADDR
// sSheik := false ;
96251: LD_ADDR_EXP 133
96255: PUSH
96256: LD_INT 0
96258: ST_TO_ADDR
// sEarthquake := false ;
96259: LD_ADDR_EXP 135
96263: PUSH
96264: LD_INT 0
96266: ST_TO_ADDR
// sAI := false ;
96267: LD_ADDR_EXP 136
96271: PUSH
96272: LD_INT 0
96274: ST_TO_ADDR
// sCargo := false ;
96275: LD_ADDR_EXP 139
96279: PUSH
96280: LD_INT 0
96282: ST_TO_ADDR
// sDLaser := false ;
96283: LD_ADDR_EXP 140
96287: PUSH
96288: LD_INT 0
96290: ST_TO_ADDR
// sExchange := false ;
96291: LD_ADDR_EXP 141
96295: PUSH
96296: LD_INT 0
96298: ST_TO_ADDR
// sFac := false ;
96299: LD_ADDR_EXP 142
96303: PUSH
96304: LD_INT 0
96306: ST_TO_ADDR
// sPower := false ;
96307: LD_ADDR_EXP 143
96311: PUSH
96312: LD_INT 0
96314: ST_TO_ADDR
// sRandom := false ;
96315: LD_ADDR_EXP 144
96319: PUSH
96320: LD_INT 0
96322: ST_TO_ADDR
// sShield := false ;
96323: LD_ADDR_EXP 145
96327: PUSH
96328: LD_INT 0
96330: ST_TO_ADDR
// sTime := false ;
96331: LD_ADDR_EXP 146
96335: PUSH
96336: LD_INT 0
96338: ST_TO_ADDR
// sTools := false ;
96339: LD_ADDR_EXP 147
96343: PUSH
96344: LD_INT 0
96346: ST_TO_ADDR
// sSold := false ;
96347: LD_ADDR_EXP 112
96351: PUSH
96352: LD_INT 0
96354: ST_TO_ADDR
// sDiff := false ;
96355: LD_ADDR_EXP 113
96359: PUSH
96360: LD_INT 0
96362: ST_TO_ADDR
// sFog := false ;
96363: LD_ADDR_EXP 116
96367: PUSH
96368: LD_INT 0
96370: ST_TO_ADDR
// sReset := false ;
96371: LD_ADDR_EXP 117
96375: PUSH
96376: LD_INT 0
96378: ST_TO_ADDR
// sSun := false ;
96379: LD_ADDR_EXP 118
96383: PUSH
96384: LD_INT 0
96386: ST_TO_ADDR
// sTiger := false ;
96387: LD_ADDR_EXP 114
96391: PUSH
96392: LD_INT 0
96394: ST_TO_ADDR
// sBomb := false ;
96395: LD_ADDR_EXP 115
96399: PUSH
96400: LD_INT 0
96402: ST_TO_ADDR
// sWound := false ;
96403: LD_ADDR_EXP 123
96407: PUSH
96408: LD_INT 0
96410: ST_TO_ADDR
// sBetray := false ;
96411: LD_ADDR_EXP 127
96415: PUSH
96416: LD_INT 0
96418: ST_TO_ADDR
// sContamin := false ;
96419: LD_ADDR_EXP 128
96423: PUSH
96424: LD_INT 0
96426: ST_TO_ADDR
// sOil := false ;
96427: LD_ADDR_EXP 130
96431: PUSH
96432: LD_INT 0
96434: ST_TO_ADDR
// sStu := false ;
96435: LD_ADDR_EXP 134
96439: PUSH
96440: LD_INT 0
96442: ST_TO_ADDR
// sBazooka := false ;
96443: LD_ADDR_EXP 137
96447: PUSH
96448: LD_INT 0
96450: ST_TO_ADDR
// sMortar := false ;
96451: LD_ADDR_EXP 138
96455: PUSH
96456: LD_INT 0
96458: ST_TO_ADDR
// sRanger := false ;
96459: LD_ADDR_EXP 148
96463: PUSH
96464: LD_INT 0
96466: ST_TO_ADDR
// sComputer := false ;
96467: LD_ADDR_EXP 149
96471: PUSH
96472: LD_INT 0
96474: ST_TO_ADDR
// s30 := false ;
96475: LD_ADDR_EXP 150
96479: PUSH
96480: LD_INT 0
96482: ST_TO_ADDR
// s60 := false ;
96483: LD_ADDR_EXP 151
96487: PUSH
96488: LD_INT 0
96490: ST_TO_ADDR
// end ;
96491: LD_VAR 0 1
96495: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96496: LD_INT 0
96498: PPUSH
96499: PPUSH
96500: PPUSH
96501: PPUSH
96502: PPUSH
96503: PPUSH
96504: PPUSH
// result := [ ] ;
96505: LD_ADDR_VAR 0 2
96509: PUSH
96510: EMPTY
96511: ST_TO_ADDR
// if campaign_id = 1 then
96512: LD_OWVAR 69
96516: PUSH
96517: LD_INT 1
96519: EQUAL
96520: IFFALSE 99686
// begin case mission_number of 1 :
96522: LD_OWVAR 70
96526: PUSH
96527: LD_INT 1
96529: DOUBLE
96530: EQUAL
96531: IFTRUE 96535
96533: GO 96611
96535: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96536: LD_ADDR_VAR 0 2
96540: PUSH
96541: LD_INT 2
96543: PUSH
96544: LD_INT 4
96546: PUSH
96547: LD_INT 11
96549: PUSH
96550: LD_INT 12
96552: PUSH
96553: LD_INT 15
96555: PUSH
96556: LD_INT 16
96558: PUSH
96559: LD_INT 22
96561: PUSH
96562: LD_INT 23
96564: PUSH
96565: LD_INT 26
96567: PUSH
96568: EMPTY
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: PUSH
96579: LD_INT 101
96581: PUSH
96582: LD_INT 102
96584: PUSH
96585: LD_INT 106
96587: PUSH
96588: LD_INT 116
96590: PUSH
96591: LD_INT 117
96593: PUSH
96594: LD_INT 118
96596: PUSH
96597: EMPTY
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: ST_TO_ADDR
96609: GO 99684
96611: LD_INT 2
96613: DOUBLE
96614: EQUAL
96615: IFTRUE 96619
96617: GO 96703
96619: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96620: LD_ADDR_VAR 0 2
96624: PUSH
96625: LD_INT 2
96627: PUSH
96628: LD_INT 4
96630: PUSH
96631: LD_INT 11
96633: PUSH
96634: LD_INT 12
96636: PUSH
96637: LD_INT 15
96639: PUSH
96640: LD_INT 16
96642: PUSH
96643: LD_INT 22
96645: PUSH
96646: LD_INT 23
96648: PUSH
96649: LD_INT 26
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: LIST
96656: LIST
96657: LIST
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: PUSH
96663: LD_INT 101
96665: PUSH
96666: LD_INT 102
96668: PUSH
96669: LD_INT 105
96671: PUSH
96672: LD_INT 106
96674: PUSH
96675: LD_INT 108
96677: PUSH
96678: LD_INT 116
96680: PUSH
96681: LD_INT 117
96683: PUSH
96684: LD_INT 118
96686: PUSH
96687: EMPTY
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: PUSH
96697: EMPTY
96698: LIST
96699: LIST
96700: ST_TO_ADDR
96701: GO 99684
96703: LD_INT 3
96705: DOUBLE
96706: EQUAL
96707: IFTRUE 96711
96709: GO 96799
96711: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96712: LD_ADDR_VAR 0 2
96716: PUSH
96717: LD_INT 2
96719: PUSH
96720: LD_INT 4
96722: PUSH
96723: LD_INT 5
96725: PUSH
96726: LD_INT 11
96728: PUSH
96729: LD_INT 12
96731: PUSH
96732: LD_INT 15
96734: PUSH
96735: LD_INT 16
96737: PUSH
96738: LD_INT 22
96740: PUSH
96741: LD_INT 26
96743: PUSH
96744: LD_INT 36
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: LIST
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: PUSH
96759: LD_INT 101
96761: PUSH
96762: LD_INT 102
96764: PUSH
96765: LD_INT 105
96767: PUSH
96768: LD_INT 106
96770: PUSH
96771: LD_INT 108
96773: PUSH
96774: LD_INT 116
96776: PUSH
96777: LD_INT 117
96779: PUSH
96780: LD_INT 118
96782: PUSH
96783: EMPTY
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: ST_TO_ADDR
96797: GO 99684
96799: LD_INT 4
96801: DOUBLE
96802: EQUAL
96803: IFTRUE 96807
96805: GO 96903
96807: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96808: LD_ADDR_VAR 0 2
96812: PUSH
96813: LD_INT 2
96815: PUSH
96816: LD_INT 4
96818: PUSH
96819: LD_INT 5
96821: PUSH
96822: LD_INT 8
96824: PUSH
96825: LD_INT 11
96827: PUSH
96828: LD_INT 12
96830: PUSH
96831: LD_INT 15
96833: PUSH
96834: LD_INT 16
96836: PUSH
96837: LD_INT 22
96839: PUSH
96840: LD_INT 23
96842: PUSH
96843: LD_INT 26
96845: PUSH
96846: LD_INT 36
96848: PUSH
96849: EMPTY
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: PUSH
96863: LD_INT 101
96865: PUSH
96866: LD_INT 102
96868: PUSH
96869: LD_INT 105
96871: PUSH
96872: LD_INT 106
96874: PUSH
96875: LD_INT 108
96877: PUSH
96878: LD_INT 116
96880: PUSH
96881: LD_INT 117
96883: PUSH
96884: LD_INT 118
96886: PUSH
96887: EMPTY
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: ST_TO_ADDR
96901: GO 99684
96903: LD_INT 5
96905: DOUBLE
96906: EQUAL
96907: IFTRUE 96911
96909: GO 97023
96911: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
96912: LD_ADDR_VAR 0 2
96916: PUSH
96917: LD_INT 2
96919: PUSH
96920: LD_INT 4
96922: PUSH
96923: LD_INT 5
96925: PUSH
96926: LD_INT 6
96928: PUSH
96929: LD_INT 8
96931: PUSH
96932: LD_INT 11
96934: PUSH
96935: LD_INT 12
96937: PUSH
96938: LD_INT 15
96940: PUSH
96941: LD_INT 16
96943: PUSH
96944: LD_INT 22
96946: PUSH
96947: LD_INT 23
96949: PUSH
96950: LD_INT 25
96952: PUSH
96953: LD_INT 26
96955: PUSH
96956: LD_INT 36
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: PUSH
96975: LD_INT 101
96977: PUSH
96978: LD_INT 102
96980: PUSH
96981: LD_INT 105
96983: PUSH
96984: LD_INT 106
96986: PUSH
96987: LD_INT 108
96989: PUSH
96990: LD_INT 109
96992: PUSH
96993: LD_INT 112
96995: PUSH
96996: LD_INT 116
96998: PUSH
96999: LD_INT 117
97001: PUSH
97002: LD_INT 118
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: LIST
97015: LIST
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: ST_TO_ADDR
97021: GO 99684
97023: LD_INT 6
97025: DOUBLE
97026: EQUAL
97027: IFTRUE 97031
97029: GO 97163
97031: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97032: LD_ADDR_VAR 0 2
97036: PUSH
97037: LD_INT 2
97039: PUSH
97040: LD_INT 4
97042: PUSH
97043: LD_INT 5
97045: PUSH
97046: LD_INT 6
97048: PUSH
97049: LD_INT 8
97051: PUSH
97052: LD_INT 11
97054: PUSH
97055: LD_INT 12
97057: PUSH
97058: LD_INT 15
97060: PUSH
97061: LD_INT 16
97063: PUSH
97064: LD_INT 20
97066: PUSH
97067: LD_INT 21
97069: PUSH
97070: LD_INT 22
97072: PUSH
97073: LD_INT 23
97075: PUSH
97076: LD_INT 25
97078: PUSH
97079: LD_INT 26
97081: PUSH
97082: LD_INT 30
97084: PUSH
97085: LD_INT 31
97087: PUSH
97088: LD_INT 32
97090: PUSH
97091: LD_INT 36
97093: PUSH
97094: EMPTY
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: PUSH
97115: LD_INT 101
97117: PUSH
97118: LD_INT 102
97120: PUSH
97121: LD_INT 105
97123: PUSH
97124: LD_INT 106
97126: PUSH
97127: LD_INT 108
97129: PUSH
97130: LD_INT 109
97132: PUSH
97133: LD_INT 112
97135: PUSH
97136: LD_INT 116
97138: PUSH
97139: LD_INT 117
97141: PUSH
97142: LD_INT 118
97144: PUSH
97145: EMPTY
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: ST_TO_ADDR
97161: GO 99684
97163: LD_INT 7
97165: DOUBLE
97166: EQUAL
97167: IFTRUE 97171
97169: GO 97283
97171: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97172: LD_ADDR_VAR 0 2
97176: PUSH
97177: LD_INT 2
97179: PUSH
97180: LD_INT 4
97182: PUSH
97183: LD_INT 5
97185: PUSH
97186: LD_INT 7
97188: PUSH
97189: LD_INT 11
97191: PUSH
97192: LD_INT 12
97194: PUSH
97195: LD_INT 15
97197: PUSH
97198: LD_INT 16
97200: PUSH
97201: LD_INT 20
97203: PUSH
97204: LD_INT 21
97206: PUSH
97207: LD_INT 22
97209: PUSH
97210: LD_INT 23
97212: PUSH
97213: LD_INT 25
97215: PUSH
97216: LD_INT 26
97218: PUSH
97219: EMPTY
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: PUSH
97235: LD_INT 101
97237: PUSH
97238: LD_INT 102
97240: PUSH
97241: LD_INT 103
97243: PUSH
97244: LD_INT 105
97246: PUSH
97247: LD_INT 106
97249: PUSH
97250: LD_INT 108
97252: PUSH
97253: LD_INT 112
97255: PUSH
97256: LD_INT 116
97258: PUSH
97259: LD_INT 117
97261: PUSH
97262: LD_INT 118
97264: PUSH
97265: EMPTY
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: LIST
97272: LIST
97273: LIST
97274: LIST
97275: LIST
97276: PUSH
97277: EMPTY
97278: LIST
97279: LIST
97280: ST_TO_ADDR
97281: GO 99684
97283: LD_INT 8
97285: DOUBLE
97286: EQUAL
97287: IFTRUE 97291
97289: GO 97431
97291: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97292: LD_ADDR_VAR 0 2
97296: PUSH
97297: LD_INT 2
97299: PUSH
97300: LD_INT 4
97302: PUSH
97303: LD_INT 5
97305: PUSH
97306: LD_INT 6
97308: PUSH
97309: LD_INT 7
97311: PUSH
97312: LD_INT 8
97314: PUSH
97315: LD_INT 11
97317: PUSH
97318: LD_INT 12
97320: PUSH
97321: LD_INT 15
97323: PUSH
97324: LD_INT 16
97326: PUSH
97327: LD_INT 20
97329: PUSH
97330: LD_INT 21
97332: PUSH
97333: LD_INT 22
97335: PUSH
97336: LD_INT 23
97338: PUSH
97339: LD_INT 25
97341: PUSH
97342: LD_INT 26
97344: PUSH
97345: LD_INT 30
97347: PUSH
97348: LD_INT 31
97350: PUSH
97351: LD_INT 32
97353: PUSH
97354: LD_INT 36
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: LIST
97361: LIST
97362: LIST
97363: LIST
97364: LIST
97365: LIST
97366: LIST
97367: LIST
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: LIST
97375: LIST
97376: LIST
97377: LIST
97378: PUSH
97379: LD_INT 101
97381: PUSH
97382: LD_INT 102
97384: PUSH
97385: LD_INT 103
97387: PUSH
97388: LD_INT 105
97390: PUSH
97391: LD_INT 106
97393: PUSH
97394: LD_INT 108
97396: PUSH
97397: LD_INT 109
97399: PUSH
97400: LD_INT 112
97402: PUSH
97403: LD_INT 116
97405: PUSH
97406: LD_INT 117
97408: PUSH
97409: LD_INT 118
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: LIST
97420: LIST
97421: LIST
97422: LIST
97423: LIST
97424: PUSH
97425: EMPTY
97426: LIST
97427: LIST
97428: ST_TO_ADDR
97429: GO 99684
97431: LD_INT 9
97433: DOUBLE
97434: EQUAL
97435: IFTRUE 97439
97437: GO 97587
97439: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97440: LD_ADDR_VAR 0 2
97444: PUSH
97445: LD_INT 2
97447: PUSH
97448: LD_INT 4
97450: PUSH
97451: LD_INT 5
97453: PUSH
97454: LD_INT 6
97456: PUSH
97457: LD_INT 7
97459: PUSH
97460: LD_INT 8
97462: PUSH
97463: LD_INT 11
97465: PUSH
97466: LD_INT 12
97468: PUSH
97469: LD_INT 15
97471: PUSH
97472: LD_INT 16
97474: PUSH
97475: LD_INT 20
97477: PUSH
97478: LD_INT 21
97480: PUSH
97481: LD_INT 22
97483: PUSH
97484: LD_INT 23
97486: PUSH
97487: LD_INT 25
97489: PUSH
97490: LD_INT 26
97492: PUSH
97493: LD_INT 28
97495: PUSH
97496: LD_INT 30
97498: PUSH
97499: LD_INT 31
97501: PUSH
97502: LD_INT 32
97504: PUSH
97505: LD_INT 36
97507: PUSH
97508: EMPTY
97509: LIST
97510: LIST
97511: LIST
97512: LIST
97513: LIST
97514: LIST
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 101
97533: PUSH
97534: LD_INT 102
97536: PUSH
97537: LD_INT 103
97539: PUSH
97540: LD_INT 105
97542: PUSH
97543: LD_INT 106
97545: PUSH
97546: LD_INT 108
97548: PUSH
97549: LD_INT 109
97551: PUSH
97552: LD_INT 112
97554: PUSH
97555: LD_INT 114
97557: PUSH
97558: LD_INT 116
97560: PUSH
97561: LD_INT 117
97563: PUSH
97564: LD_INT 118
97566: PUSH
97567: EMPTY
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: PUSH
97581: EMPTY
97582: LIST
97583: LIST
97584: ST_TO_ADDR
97585: GO 99684
97587: LD_INT 10
97589: DOUBLE
97590: EQUAL
97591: IFTRUE 97595
97593: GO 97791
97595: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97596: LD_ADDR_VAR 0 2
97600: PUSH
97601: LD_INT 2
97603: PUSH
97604: LD_INT 4
97606: PUSH
97607: LD_INT 5
97609: PUSH
97610: LD_INT 6
97612: PUSH
97613: LD_INT 7
97615: PUSH
97616: LD_INT 8
97618: PUSH
97619: LD_INT 9
97621: PUSH
97622: LD_INT 10
97624: PUSH
97625: LD_INT 11
97627: PUSH
97628: LD_INT 12
97630: PUSH
97631: LD_INT 13
97633: PUSH
97634: LD_INT 14
97636: PUSH
97637: LD_INT 15
97639: PUSH
97640: LD_INT 16
97642: PUSH
97643: LD_INT 17
97645: PUSH
97646: LD_INT 18
97648: PUSH
97649: LD_INT 19
97651: PUSH
97652: LD_INT 20
97654: PUSH
97655: LD_INT 21
97657: PUSH
97658: LD_INT 22
97660: PUSH
97661: LD_INT 23
97663: PUSH
97664: LD_INT 24
97666: PUSH
97667: LD_INT 25
97669: PUSH
97670: LD_INT 26
97672: PUSH
97673: LD_INT 28
97675: PUSH
97676: LD_INT 30
97678: PUSH
97679: LD_INT 31
97681: PUSH
97682: LD_INT 32
97684: PUSH
97685: LD_INT 36
97687: PUSH
97688: EMPTY
97689: LIST
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: PUSH
97719: LD_INT 101
97721: PUSH
97722: LD_INT 102
97724: PUSH
97725: LD_INT 103
97727: PUSH
97728: LD_INT 104
97730: PUSH
97731: LD_INT 105
97733: PUSH
97734: LD_INT 106
97736: PUSH
97737: LD_INT 107
97739: PUSH
97740: LD_INT 108
97742: PUSH
97743: LD_INT 109
97745: PUSH
97746: LD_INT 110
97748: PUSH
97749: LD_INT 111
97751: PUSH
97752: LD_INT 112
97754: PUSH
97755: LD_INT 114
97757: PUSH
97758: LD_INT 116
97760: PUSH
97761: LD_INT 117
97763: PUSH
97764: LD_INT 118
97766: PUSH
97767: EMPTY
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: ST_TO_ADDR
97789: GO 99684
97791: LD_INT 11
97793: DOUBLE
97794: EQUAL
97795: IFTRUE 97799
97797: GO 98003
97799: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97800: LD_ADDR_VAR 0 2
97804: PUSH
97805: LD_INT 2
97807: PUSH
97808: LD_INT 3
97810: PUSH
97811: LD_INT 4
97813: PUSH
97814: LD_INT 5
97816: PUSH
97817: LD_INT 6
97819: PUSH
97820: LD_INT 7
97822: PUSH
97823: LD_INT 8
97825: PUSH
97826: LD_INT 9
97828: PUSH
97829: LD_INT 10
97831: PUSH
97832: LD_INT 11
97834: PUSH
97835: LD_INT 12
97837: PUSH
97838: LD_INT 13
97840: PUSH
97841: LD_INT 14
97843: PUSH
97844: LD_INT 15
97846: PUSH
97847: LD_INT 16
97849: PUSH
97850: LD_INT 17
97852: PUSH
97853: LD_INT 18
97855: PUSH
97856: LD_INT 19
97858: PUSH
97859: LD_INT 20
97861: PUSH
97862: LD_INT 21
97864: PUSH
97865: LD_INT 22
97867: PUSH
97868: LD_INT 23
97870: PUSH
97871: LD_INT 24
97873: PUSH
97874: LD_INT 25
97876: PUSH
97877: LD_INT 26
97879: PUSH
97880: LD_INT 28
97882: PUSH
97883: LD_INT 30
97885: PUSH
97886: LD_INT 31
97888: PUSH
97889: LD_INT 32
97891: PUSH
97892: LD_INT 34
97894: PUSH
97895: LD_INT 36
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: LIST
97921: LIST
97922: LIST
97923: LIST
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: PUSH
97931: LD_INT 101
97933: PUSH
97934: LD_INT 102
97936: PUSH
97937: LD_INT 103
97939: PUSH
97940: LD_INT 104
97942: PUSH
97943: LD_INT 105
97945: PUSH
97946: LD_INT 106
97948: PUSH
97949: LD_INT 107
97951: PUSH
97952: LD_INT 108
97954: PUSH
97955: LD_INT 109
97957: PUSH
97958: LD_INT 110
97960: PUSH
97961: LD_INT 111
97963: PUSH
97964: LD_INT 112
97966: PUSH
97967: LD_INT 114
97969: PUSH
97970: LD_INT 116
97972: PUSH
97973: LD_INT 117
97975: PUSH
97976: LD_INT 118
97978: PUSH
97979: EMPTY
97980: LIST
97981: LIST
97982: LIST
97983: LIST
97984: LIST
97985: LIST
97986: LIST
97987: LIST
97988: LIST
97989: LIST
97990: LIST
97991: LIST
97992: LIST
97993: LIST
97994: LIST
97995: LIST
97996: PUSH
97997: EMPTY
97998: LIST
97999: LIST
98000: ST_TO_ADDR
98001: GO 99684
98003: LD_INT 12
98005: DOUBLE
98006: EQUAL
98007: IFTRUE 98011
98009: GO 98231
98011: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
98012: LD_ADDR_VAR 0 2
98016: PUSH
98017: LD_INT 1
98019: PUSH
98020: LD_INT 2
98022: PUSH
98023: LD_INT 3
98025: PUSH
98026: LD_INT 4
98028: PUSH
98029: LD_INT 5
98031: PUSH
98032: LD_INT 6
98034: PUSH
98035: LD_INT 7
98037: PUSH
98038: LD_INT 8
98040: PUSH
98041: LD_INT 9
98043: PUSH
98044: LD_INT 10
98046: PUSH
98047: LD_INT 11
98049: PUSH
98050: LD_INT 12
98052: PUSH
98053: LD_INT 13
98055: PUSH
98056: LD_INT 14
98058: PUSH
98059: LD_INT 15
98061: PUSH
98062: LD_INT 16
98064: PUSH
98065: LD_INT 17
98067: PUSH
98068: LD_INT 18
98070: PUSH
98071: LD_INT 19
98073: PUSH
98074: LD_INT 20
98076: PUSH
98077: LD_INT 21
98079: PUSH
98080: LD_INT 22
98082: PUSH
98083: LD_INT 23
98085: PUSH
98086: LD_INT 24
98088: PUSH
98089: LD_INT 25
98091: PUSH
98092: LD_INT 26
98094: PUSH
98095: LD_INT 27
98097: PUSH
98098: LD_INT 28
98100: PUSH
98101: LD_INT 30
98103: PUSH
98104: LD_INT 31
98106: PUSH
98107: LD_INT 32
98109: PUSH
98110: LD_INT 33
98112: PUSH
98113: LD_INT 34
98115: PUSH
98116: LD_INT 36
98118: PUSH
98119: EMPTY
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: LIST
98129: LIST
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: LIST
98135: LIST
98136: LIST
98137: LIST
98138: LIST
98139: LIST
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: LIST
98152: LIST
98153: LIST
98154: PUSH
98155: LD_INT 101
98157: PUSH
98158: LD_INT 102
98160: PUSH
98161: LD_INT 103
98163: PUSH
98164: LD_INT 104
98166: PUSH
98167: LD_INT 105
98169: PUSH
98170: LD_INT 106
98172: PUSH
98173: LD_INT 107
98175: PUSH
98176: LD_INT 108
98178: PUSH
98179: LD_INT 109
98181: PUSH
98182: LD_INT 110
98184: PUSH
98185: LD_INT 111
98187: PUSH
98188: LD_INT 112
98190: PUSH
98191: LD_INT 113
98193: PUSH
98194: LD_INT 114
98196: PUSH
98197: LD_INT 116
98199: PUSH
98200: LD_INT 117
98202: PUSH
98203: LD_INT 118
98205: PUSH
98206: EMPTY
98207: LIST
98208: LIST
98209: LIST
98210: LIST
98211: LIST
98212: LIST
98213: LIST
98214: LIST
98215: LIST
98216: LIST
98217: LIST
98218: LIST
98219: LIST
98220: LIST
98221: LIST
98222: LIST
98223: LIST
98224: PUSH
98225: EMPTY
98226: LIST
98227: LIST
98228: ST_TO_ADDR
98229: GO 99684
98231: LD_INT 13
98233: DOUBLE
98234: EQUAL
98235: IFTRUE 98239
98237: GO 98447
98239: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98240: LD_ADDR_VAR 0 2
98244: PUSH
98245: LD_INT 1
98247: PUSH
98248: LD_INT 2
98250: PUSH
98251: LD_INT 3
98253: PUSH
98254: LD_INT 4
98256: PUSH
98257: LD_INT 5
98259: PUSH
98260: LD_INT 8
98262: PUSH
98263: LD_INT 9
98265: PUSH
98266: LD_INT 10
98268: PUSH
98269: LD_INT 11
98271: PUSH
98272: LD_INT 12
98274: PUSH
98275: LD_INT 14
98277: PUSH
98278: LD_INT 15
98280: PUSH
98281: LD_INT 16
98283: PUSH
98284: LD_INT 17
98286: PUSH
98287: LD_INT 18
98289: PUSH
98290: LD_INT 19
98292: PUSH
98293: LD_INT 20
98295: PUSH
98296: LD_INT 21
98298: PUSH
98299: LD_INT 22
98301: PUSH
98302: LD_INT 23
98304: PUSH
98305: LD_INT 24
98307: PUSH
98308: LD_INT 25
98310: PUSH
98311: LD_INT 26
98313: PUSH
98314: LD_INT 27
98316: PUSH
98317: LD_INT 28
98319: PUSH
98320: LD_INT 30
98322: PUSH
98323: LD_INT 31
98325: PUSH
98326: LD_INT 32
98328: PUSH
98329: LD_INT 33
98331: PUSH
98332: LD_INT 34
98334: PUSH
98335: LD_INT 36
98337: PUSH
98338: EMPTY
98339: LIST
98340: LIST
98341: LIST
98342: LIST
98343: LIST
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: LIST
98350: LIST
98351: LIST
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: LIST
98362: LIST
98363: LIST
98364: LIST
98365: LIST
98366: LIST
98367: LIST
98368: LIST
98369: LIST
98370: PUSH
98371: LD_INT 101
98373: PUSH
98374: LD_INT 102
98376: PUSH
98377: LD_INT 103
98379: PUSH
98380: LD_INT 104
98382: PUSH
98383: LD_INT 105
98385: PUSH
98386: LD_INT 106
98388: PUSH
98389: LD_INT 107
98391: PUSH
98392: LD_INT 108
98394: PUSH
98395: LD_INT 109
98397: PUSH
98398: LD_INT 110
98400: PUSH
98401: LD_INT 111
98403: PUSH
98404: LD_INT 112
98406: PUSH
98407: LD_INT 113
98409: PUSH
98410: LD_INT 114
98412: PUSH
98413: LD_INT 116
98415: PUSH
98416: LD_INT 117
98418: PUSH
98419: LD_INT 118
98421: PUSH
98422: EMPTY
98423: LIST
98424: LIST
98425: LIST
98426: LIST
98427: LIST
98428: LIST
98429: LIST
98430: LIST
98431: LIST
98432: LIST
98433: LIST
98434: LIST
98435: LIST
98436: LIST
98437: LIST
98438: LIST
98439: LIST
98440: PUSH
98441: EMPTY
98442: LIST
98443: LIST
98444: ST_TO_ADDR
98445: GO 99684
98447: LD_INT 14
98449: DOUBLE
98450: EQUAL
98451: IFTRUE 98455
98453: GO 98679
98455: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98456: LD_ADDR_VAR 0 2
98460: PUSH
98461: LD_INT 1
98463: PUSH
98464: LD_INT 2
98466: PUSH
98467: LD_INT 3
98469: PUSH
98470: LD_INT 4
98472: PUSH
98473: LD_INT 5
98475: PUSH
98476: LD_INT 6
98478: PUSH
98479: LD_INT 7
98481: PUSH
98482: LD_INT 8
98484: PUSH
98485: LD_INT 9
98487: PUSH
98488: LD_INT 10
98490: PUSH
98491: LD_INT 11
98493: PUSH
98494: LD_INT 12
98496: PUSH
98497: LD_INT 13
98499: PUSH
98500: LD_INT 14
98502: PUSH
98503: LD_INT 15
98505: PUSH
98506: LD_INT 16
98508: PUSH
98509: LD_INT 17
98511: PUSH
98512: LD_INT 18
98514: PUSH
98515: LD_INT 19
98517: PUSH
98518: LD_INT 20
98520: PUSH
98521: LD_INT 21
98523: PUSH
98524: LD_INT 22
98526: PUSH
98527: LD_INT 23
98529: PUSH
98530: LD_INT 24
98532: PUSH
98533: LD_INT 25
98535: PUSH
98536: LD_INT 26
98538: PUSH
98539: LD_INT 27
98541: PUSH
98542: LD_INT 28
98544: PUSH
98545: LD_INT 29
98547: PUSH
98548: LD_INT 30
98550: PUSH
98551: LD_INT 31
98553: PUSH
98554: LD_INT 32
98556: PUSH
98557: LD_INT 33
98559: PUSH
98560: LD_INT 34
98562: PUSH
98563: LD_INT 36
98565: PUSH
98566: EMPTY
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: LIST
98589: LIST
98590: LIST
98591: LIST
98592: LIST
98593: LIST
98594: LIST
98595: LIST
98596: LIST
98597: LIST
98598: LIST
98599: LIST
98600: LIST
98601: LIST
98602: PUSH
98603: LD_INT 101
98605: PUSH
98606: LD_INT 102
98608: PUSH
98609: LD_INT 103
98611: PUSH
98612: LD_INT 104
98614: PUSH
98615: LD_INT 105
98617: PUSH
98618: LD_INT 106
98620: PUSH
98621: LD_INT 107
98623: PUSH
98624: LD_INT 108
98626: PUSH
98627: LD_INT 109
98629: PUSH
98630: LD_INT 110
98632: PUSH
98633: LD_INT 111
98635: PUSH
98636: LD_INT 112
98638: PUSH
98639: LD_INT 113
98641: PUSH
98642: LD_INT 114
98644: PUSH
98645: LD_INT 116
98647: PUSH
98648: LD_INT 117
98650: PUSH
98651: LD_INT 118
98653: PUSH
98654: EMPTY
98655: LIST
98656: LIST
98657: LIST
98658: LIST
98659: LIST
98660: LIST
98661: LIST
98662: LIST
98663: LIST
98664: LIST
98665: LIST
98666: LIST
98667: LIST
98668: LIST
98669: LIST
98670: LIST
98671: LIST
98672: PUSH
98673: EMPTY
98674: LIST
98675: LIST
98676: ST_TO_ADDR
98677: GO 99684
98679: LD_INT 15
98681: DOUBLE
98682: EQUAL
98683: IFTRUE 98687
98685: GO 98911
98687: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98688: LD_ADDR_VAR 0 2
98692: PUSH
98693: LD_INT 1
98695: PUSH
98696: LD_INT 2
98698: PUSH
98699: LD_INT 3
98701: PUSH
98702: LD_INT 4
98704: PUSH
98705: LD_INT 5
98707: PUSH
98708: LD_INT 6
98710: PUSH
98711: LD_INT 7
98713: PUSH
98714: LD_INT 8
98716: PUSH
98717: LD_INT 9
98719: PUSH
98720: LD_INT 10
98722: PUSH
98723: LD_INT 11
98725: PUSH
98726: LD_INT 12
98728: PUSH
98729: LD_INT 13
98731: PUSH
98732: LD_INT 14
98734: PUSH
98735: LD_INT 15
98737: PUSH
98738: LD_INT 16
98740: PUSH
98741: LD_INT 17
98743: PUSH
98744: LD_INT 18
98746: PUSH
98747: LD_INT 19
98749: PUSH
98750: LD_INT 20
98752: PUSH
98753: LD_INT 21
98755: PUSH
98756: LD_INT 22
98758: PUSH
98759: LD_INT 23
98761: PUSH
98762: LD_INT 24
98764: PUSH
98765: LD_INT 25
98767: PUSH
98768: LD_INT 26
98770: PUSH
98771: LD_INT 27
98773: PUSH
98774: LD_INT 28
98776: PUSH
98777: LD_INT 29
98779: PUSH
98780: LD_INT 30
98782: PUSH
98783: LD_INT 31
98785: PUSH
98786: LD_INT 32
98788: PUSH
98789: LD_INT 33
98791: PUSH
98792: LD_INT 34
98794: PUSH
98795: LD_INT 36
98797: PUSH
98798: EMPTY
98799: LIST
98800: LIST
98801: LIST
98802: LIST
98803: LIST
98804: LIST
98805: LIST
98806: LIST
98807: LIST
98808: LIST
98809: LIST
98810: LIST
98811: LIST
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: LIST
98834: PUSH
98835: LD_INT 101
98837: PUSH
98838: LD_INT 102
98840: PUSH
98841: LD_INT 103
98843: PUSH
98844: LD_INT 104
98846: PUSH
98847: LD_INT 105
98849: PUSH
98850: LD_INT 106
98852: PUSH
98853: LD_INT 107
98855: PUSH
98856: LD_INT 108
98858: PUSH
98859: LD_INT 109
98861: PUSH
98862: LD_INT 110
98864: PUSH
98865: LD_INT 111
98867: PUSH
98868: LD_INT 112
98870: PUSH
98871: LD_INT 113
98873: PUSH
98874: LD_INT 114
98876: PUSH
98877: LD_INT 116
98879: PUSH
98880: LD_INT 117
98882: PUSH
98883: LD_INT 118
98885: PUSH
98886: EMPTY
98887: LIST
98888: LIST
98889: LIST
98890: LIST
98891: LIST
98892: LIST
98893: LIST
98894: LIST
98895: LIST
98896: LIST
98897: LIST
98898: LIST
98899: LIST
98900: LIST
98901: LIST
98902: LIST
98903: LIST
98904: PUSH
98905: EMPTY
98906: LIST
98907: LIST
98908: ST_TO_ADDR
98909: GO 99684
98911: LD_INT 16
98913: DOUBLE
98914: EQUAL
98915: IFTRUE 98919
98917: GO 99055
98919: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
98920: LD_ADDR_VAR 0 2
98924: PUSH
98925: LD_INT 2
98927: PUSH
98928: LD_INT 4
98930: PUSH
98931: LD_INT 5
98933: PUSH
98934: LD_INT 7
98936: PUSH
98937: LD_INT 11
98939: PUSH
98940: LD_INT 12
98942: PUSH
98943: LD_INT 15
98945: PUSH
98946: LD_INT 16
98948: PUSH
98949: LD_INT 20
98951: PUSH
98952: LD_INT 21
98954: PUSH
98955: LD_INT 22
98957: PUSH
98958: LD_INT 23
98960: PUSH
98961: LD_INT 25
98963: PUSH
98964: LD_INT 26
98966: PUSH
98967: LD_INT 30
98969: PUSH
98970: LD_INT 31
98972: PUSH
98973: LD_INT 32
98975: PUSH
98976: LD_INT 33
98978: PUSH
98979: LD_INT 34
98981: PUSH
98982: EMPTY
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: LIST
98992: LIST
98993: LIST
98994: LIST
98995: LIST
98996: LIST
98997: LIST
98998: LIST
98999: LIST
99000: LIST
99001: LIST
99002: PUSH
99003: LD_INT 101
99005: PUSH
99006: LD_INT 102
99008: PUSH
99009: LD_INT 103
99011: PUSH
99012: LD_INT 106
99014: PUSH
99015: LD_INT 108
99017: PUSH
99018: LD_INT 112
99020: PUSH
99021: LD_INT 113
99023: PUSH
99024: LD_INT 114
99026: PUSH
99027: LD_INT 116
99029: PUSH
99030: LD_INT 117
99032: PUSH
99033: LD_INT 118
99035: PUSH
99036: EMPTY
99037: LIST
99038: LIST
99039: LIST
99040: LIST
99041: LIST
99042: LIST
99043: LIST
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: PUSH
99049: EMPTY
99050: LIST
99051: LIST
99052: ST_TO_ADDR
99053: GO 99684
99055: LD_INT 17
99057: DOUBLE
99058: EQUAL
99059: IFTRUE 99063
99061: GO 99287
99063: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99064: LD_ADDR_VAR 0 2
99068: PUSH
99069: LD_INT 1
99071: PUSH
99072: LD_INT 2
99074: PUSH
99075: LD_INT 3
99077: PUSH
99078: LD_INT 4
99080: PUSH
99081: LD_INT 5
99083: PUSH
99084: LD_INT 6
99086: PUSH
99087: LD_INT 7
99089: PUSH
99090: LD_INT 8
99092: PUSH
99093: LD_INT 9
99095: PUSH
99096: LD_INT 10
99098: PUSH
99099: LD_INT 11
99101: PUSH
99102: LD_INT 12
99104: PUSH
99105: LD_INT 13
99107: PUSH
99108: LD_INT 14
99110: PUSH
99111: LD_INT 15
99113: PUSH
99114: LD_INT 16
99116: PUSH
99117: LD_INT 17
99119: PUSH
99120: LD_INT 18
99122: PUSH
99123: LD_INT 19
99125: PUSH
99126: LD_INT 20
99128: PUSH
99129: LD_INT 21
99131: PUSH
99132: LD_INT 22
99134: PUSH
99135: LD_INT 23
99137: PUSH
99138: LD_INT 24
99140: PUSH
99141: LD_INT 25
99143: PUSH
99144: LD_INT 26
99146: PUSH
99147: LD_INT 27
99149: PUSH
99150: LD_INT 28
99152: PUSH
99153: LD_INT 29
99155: PUSH
99156: LD_INT 30
99158: PUSH
99159: LD_INT 31
99161: PUSH
99162: LD_INT 32
99164: PUSH
99165: LD_INT 33
99167: PUSH
99168: LD_INT 34
99170: PUSH
99171: LD_INT 36
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: LIST
99178: LIST
99179: LIST
99180: LIST
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: LIST
99186: LIST
99187: LIST
99188: LIST
99189: LIST
99190: LIST
99191: LIST
99192: LIST
99193: LIST
99194: LIST
99195: LIST
99196: LIST
99197: LIST
99198: LIST
99199: LIST
99200: LIST
99201: LIST
99202: LIST
99203: LIST
99204: LIST
99205: LIST
99206: LIST
99207: LIST
99208: LIST
99209: LIST
99210: PUSH
99211: LD_INT 101
99213: PUSH
99214: LD_INT 102
99216: PUSH
99217: LD_INT 103
99219: PUSH
99220: LD_INT 104
99222: PUSH
99223: LD_INT 105
99225: PUSH
99226: LD_INT 106
99228: PUSH
99229: LD_INT 107
99231: PUSH
99232: LD_INT 108
99234: PUSH
99235: LD_INT 109
99237: PUSH
99238: LD_INT 110
99240: PUSH
99241: LD_INT 111
99243: PUSH
99244: LD_INT 112
99246: PUSH
99247: LD_INT 113
99249: PUSH
99250: LD_INT 114
99252: PUSH
99253: LD_INT 116
99255: PUSH
99256: LD_INT 117
99258: PUSH
99259: LD_INT 118
99261: PUSH
99262: EMPTY
99263: LIST
99264: LIST
99265: LIST
99266: LIST
99267: LIST
99268: LIST
99269: LIST
99270: LIST
99271: LIST
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: LIST
99277: LIST
99278: LIST
99279: LIST
99280: PUSH
99281: EMPTY
99282: LIST
99283: LIST
99284: ST_TO_ADDR
99285: GO 99684
99287: LD_INT 18
99289: DOUBLE
99290: EQUAL
99291: IFTRUE 99295
99293: GO 99443
99295: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99296: LD_ADDR_VAR 0 2
99300: PUSH
99301: LD_INT 2
99303: PUSH
99304: LD_INT 4
99306: PUSH
99307: LD_INT 5
99309: PUSH
99310: LD_INT 7
99312: PUSH
99313: LD_INT 11
99315: PUSH
99316: LD_INT 12
99318: PUSH
99319: LD_INT 15
99321: PUSH
99322: LD_INT 16
99324: PUSH
99325: LD_INT 20
99327: PUSH
99328: LD_INT 21
99330: PUSH
99331: LD_INT 22
99333: PUSH
99334: LD_INT 23
99336: PUSH
99337: LD_INT 25
99339: PUSH
99340: LD_INT 26
99342: PUSH
99343: LD_INT 30
99345: PUSH
99346: LD_INT 31
99348: PUSH
99349: LD_INT 32
99351: PUSH
99352: LD_INT 33
99354: PUSH
99355: LD_INT 34
99357: PUSH
99358: LD_INT 35
99360: PUSH
99361: LD_INT 36
99363: PUSH
99364: EMPTY
99365: LIST
99366: LIST
99367: LIST
99368: LIST
99369: LIST
99370: LIST
99371: LIST
99372: LIST
99373: LIST
99374: LIST
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: LIST
99384: LIST
99385: LIST
99386: PUSH
99387: LD_INT 101
99389: PUSH
99390: LD_INT 102
99392: PUSH
99393: LD_INT 103
99395: PUSH
99396: LD_INT 106
99398: PUSH
99399: LD_INT 108
99401: PUSH
99402: LD_INT 112
99404: PUSH
99405: LD_INT 113
99407: PUSH
99408: LD_INT 114
99410: PUSH
99411: LD_INT 115
99413: PUSH
99414: LD_INT 116
99416: PUSH
99417: LD_INT 117
99419: PUSH
99420: LD_INT 118
99422: PUSH
99423: EMPTY
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: LIST
99431: LIST
99432: LIST
99433: LIST
99434: LIST
99435: LIST
99436: PUSH
99437: EMPTY
99438: LIST
99439: LIST
99440: ST_TO_ADDR
99441: GO 99684
99443: LD_INT 19
99445: DOUBLE
99446: EQUAL
99447: IFTRUE 99451
99449: GO 99683
99451: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99452: LD_ADDR_VAR 0 2
99456: PUSH
99457: LD_INT 1
99459: PUSH
99460: LD_INT 2
99462: PUSH
99463: LD_INT 3
99465: PUSH
99466: LD_INT 4
99468: PUSH
99469: LD_INT 5
99471: PUSH
99472: LD_INT 6
99474: PUSH
99475: LD_INT 7
99477: PUSH
99478: LD_INT 8
99480: PUSH
99481: LD_INT 9
99483: PUSH
99484: LD_INT 10
99486: PUSH
99487: LD_INT 11
99489: PUSH
99490: LD_INT 12
99492: PUSH
99493: LD_INT 13
99495: PUSH
99496: LD_INT 14
99498: PUSH
99499: LD_INT 15
99501: PUSH
99502: LD_INT 16
99504: PUSH
99505: LD_INT 17
99507: PUSH
99508: LD_INT 18
99510: PUSH
99511: LD_INT 19
99513: PUSH
99514: LD_INT 20
99516: PUSH
99517: LD_INT 21
99519: PUSH
99520: LD_INT 22
99522: PUSH
99523: LD_INT 23
99525: PUSH
99526: LD_INT 24
99528: PUSH
99529: LD_INT 25
99531: PUSH
99532: LD_INT 26
99534: PUSH
99535: LD_INT 27
99537: PUSH
99538: LD_INT 28
99540: PUSH
99541: LD_INT 29
99543: PUSH
99544: LD_INT 30
99546: PUSH
99547: LD_INT 31
99549: PUSH
99550: LD_INT 32
99552: PUSH
99553: LD_INT 33
99555: PUSH
99556: LD_INT 34
99558: PUSH
99559: LD_INT 35
99561: PUSH
99562: LD_INT 36
99564: PUSH
99565: EMPTY
99566: LIST
99567: LIST
99568: LIST
99569: LIST
99570: LIST
99571: LIST
99572: LIST
99573: LIST
99574: LIST
99575: LIST
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: LIST
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: LIST
99594: LIST
99595: LIST
99596: LIST
99597: LIST
99598: LIST
99599: LIST
99600: LIST
99601: LIST
99602: PUSH
99603: LD_INT 101
99605: PUSH
99606: LD_INT 102
99608: PUSH
99609: LD_INT 103
99611: PUSH
99612: LD_INT 104
99614: PUSH
99615: LD_INT 105
99617: PUSH
99618: LD_INT 106
99620: PUSH
99621: LD_INT 107
99623: PUSH
99624: LD_INT 108
99626: PUSH
99627: LD_INT 109
99629: PUSH
99630: LD_INT 110
99632: PUSH
99633: LD_INT 111
99635: PUSH
99636: LD_INT 112
99638: PUSH
99639: LD_INT 113
99641: PUSH
99642: LD_INT 114
99644: PUSH
99645: LD_INT 115
99647: PUSH
99648: LD_INT 116
99650: PUSH
99651: LD_INT 117
99653: PUSH
99654: LD_INT 118
99656: PUSH
99657: EMPTY
99658: LIST
99659: LIST
99660: LIST
99661: LIST
99662: LIST
99663: LIST
99664: LIST
99665: LIST
99666: LIST
99667: LIST
99668: LIST
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: LIST
99675: LIST
99676: PUSH
99677: EMPTY
99678: LIST
99679: LIST
99680: ST_TO_ADDR
99681: GO 99684
99683: POP
// end else
99684: GO 99915
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99686: LD_ADDR_VAR 0 2
99690: PUSH
99691: LD_INT 1
99693: PUSH
99694: LD_INT 2
99696: PUSH
99697: LD_INT 3
99699: PUSH
99700: LD_INT 4
99702: PUSH
99703: LD_INT 5
99705: PUSH
99706: LD_INT 6
99708: PUSH
99709: LD_INT 7
99711: PUSH
99712: LD_INT 8
99714: PUSH
99715: LD_INT 9
99717: PUSH
99718: LD_INT 10
99720: PUSH
99721: LD_INT 11
99723: PUSH
99724: LD_INT 12
99726: PUSH
99727: LD_INT 13
99729: PUSH
99730: LD_INT 14
99732: PUSH
99733: LD_INT 15
99735: PUSH
99736: LD_INT 16
99738: PUSH
99739: LD_INT 17
99741: PUSH
99742: LD_INT 18
99744: PUSH
99745: LD_INT 19
99747: PUSH
99748: LD_INT 20
99750: PUSH
99751: LD_INT 21
99753: PUSH
99754: LD_INT 22
99756: PUSH
99757: LD_INT 23
99759: PUSH
99760: LD_INT 24
99762: PUSH
99763: LD_INT 25
99765: PUSH
99766: LD_INT 26
99768: PUSH
99769: LD_INT 27
99771: PUSH
99772: LD_INT 28
99774: PUSH
99775: LD_INT 29
99777: PUSH
99778: LD_INT 30
99780: PUSH
99781: LD_INT 31
99783: PUSH
99784: LD_INT 32
99786: PUSH
99787: LD_INT 33
99789: PUSH
99790: LD_INT 34
99792: PUSH
99793: LD_INT 35
99795: PUSH
99796: LD_INT 36
99798: PUSH
99799: EMPTY
99800: LIST
99801: LIST
99802: LIST
99803: LIST
99804: LIST
99805: LIST
99806: LIST
99807: LIST
99808: LIST
99809: LIST
99810: LIST
99811: LIST
99812: LIST
99813: LIST
99814: LIST
99815: LIST
99816: LIST
99817: LIST
99818: LIST
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: LIST
99824: LIST
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: LIST
99833: LIST
99834: LIST
99835: LIST
99836: PUSH
99837: LD_INT 101
99839: PUSH
99840: LD_INT 102
99842: PUSH
99843: LD_INT 103
99845: PUSH
99846: LD_INT 104
99848: PUSH
99849: LD_INT 105
99851: PUSH
99852: LD_INT 106
99854: PUSH
99855: LD_INT 107
99857: PUSH
99858: LD_INT 108
99860: PUSH
99861: LD_INT 109
99863: PUSH
99864: LD_INT 110
99866: PUSH
99867: LD_INT 111
99869: PUSH
99870: LD_INT 112
99872: PUSH
99873: LD_INT 113
99875: PUSH
99876: LD_INT 114
99878: PUSH
99879: LD_INT 115
99881: PUSH
99882: LD_INT 116
99884: PUSH
99885: LD_INT 117
99887: PUSH
99888: LD_INT 118
99890: PUSH
99891: EMPTY
99892: LIST
99893: LIST
99894: LIST
99895: LIST
99896: LIST
99897: LIST
99898: LIST
99899: LIST
99900: LIST
99901: LIST
99902: LIST
99903: LIST
99904: LIST
99905: LIST
99906: LIST
99907: LIST
99908: LIST
99909: LIST
99910: PUSH
99911: EMPTY
99912: LIST
99913: LIST
99914: ST_TO_ADDR
// if result then
99915: LD_VAR 0 2
99919: IFFALSE 100705
// begin normal :=  ;
99921: LD_ADDR_VAR 0 5
99925: PUSH
99926: LD_STRING 
99928: ST_TO_ADDR
// hardcore :=  ;
99929: LD_ADDR_VAR 0 6
99933: PUSH
99934: LD_STRING 
99936: ST_TO_ADDR
// active :=  ;
99937: LD_ADDR_VAR 0 7
99941: PUSH
99942: LD_STRING 
99944: ST_TO_ADDR
// for i = 1 to normalCounter do
99945: LD_ADDR_VAR 0 8
99949: PUSH
99950: DOUBLE
99951: LD_INT 1
99953: DEC
99954: ST_TO_ADDR
99955: LD_EXP 96
99959: PUSH
99960: FOR_TO
99961: IFFALSE 100062
// begin tmp := 0 ;
99963: LD_ADDR_VAR 0 3
99967: PUSH
99968: LD_STRING 0
99970: ST_TO_ADDR
// if result [ 1 ] then
99971: LD_VAR 0 2
99975: PUSH
99976: LD_INT 1
99978: ARRAY
99979: IFFALSE 100044
// if result [ 1 ] [ 1 ] = i then
99981: LD_VAR 0 2
99985: PUSH
99986: LD_INT 1
99988: ARRAY
99989: PUSH
99990: LD_INT 1
99992: ARRAY
99993: PUSH
99994: LD_VAR 0 8
99998: EQUAL
99999: IFFALSE 100044
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
100001: LD_ADDR_VAR 0 2
100005: PUSH
100006: LD_VAR 0 2
100010: PPUSH
100011: LD_INT 1
100013: PPUSH
100014: LD_VAR 0 2
100018: PUSH
100019: LD_INT 1
100021: ARRAY
100022: PPUSH
100023: LD_INT 1
100025: PPUSH
100026: CALL_OW 3
100030: PPUSH
100031: CALL_OW 1
100035: ST_TO_ADDR
// tmp := 1 ;
100036: LD_ADDR_VAR 0 3
100040: PUSH
100041: LD_STRING 1
100043: ST_TO_ADDR
// end ; normal := normal & tmp ;
100044: LD_ADDR_VAR 0 5
100048: PUSH
100049: LD_VAR 0 5
100053: PUSH
100054: LD_VAR 0 3
100058: STR
100059: ST_TO_ADDR
// end ;
100060: GO 99960
100062: POP
100063: POP
// for i = 1 to hardcoreCounter do
100064: LD_ADDR_VAR 0 8
100068: PUSH
100069: DOUBLE
100070: LD_INT 1
100072: DEC
100073: ST_TO_ADDR
100074: LD_EXP 97
100078: PUSH
100079: FOR_TO
100080: IFFALSE 100185
// begin tmp := 0 ;
100082: LD_ADDR_VAR 0 3
100086: PUSH
100087: LD_STRING 0
100089: ST_TO_ADDR
// if result [ 2 ] then
100090: LD_VAR 0 2
100094: PUSH
100095: LD_INT 2
100097: ARRAY
100098: IFFALSE 100167
// if result [ 2 ] [ 1 ] = 100 + i then
100100: LD_VAR 0 2
100104: PUSH
100105: LD_INT 2
100107: ARRAY
100108: PUSH
100109: LD_INT 1
100111: ARRAY
100112: PUSH
100113: LD_INT 100
100115: PUSH
100116: LD_VAR 0 8
100120: PLUS
100121: EQUAL
100122: IFFALSE 100167
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100124: LD_ADDR_VAR 0 2
100128: PUSH
100129: LD_VAR 0 2
100133: PPUSH
100134: LD_INT 2
100136: PPUSH
100137: LD_VAR 0 2
100141: PUSH
100142: LD_INT 2
100144: ARRAY
100145: PPUSH
100146: LD_INT 1
100148: PPUSH
100149: CALL_OW 3
100153: PPUSH
100154: CALL_OW 1
100158: ST_TO_ADDR
// tmp := 1 ;
100159: LD_ADDR_VAR 0 3
100163: PUSH
100164: LD_STRING 1
100166: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100167: LD_ADDR_VAR 0 6
100171: PUSH
100172: LD_VAR 0 6
100176: PUSH
100177: LD_VAR 0 3
100181: STR
100182: ST_TO_ADDR
// end ;
100183: GO 100079
100185: POP
100186: POP
// if isGameLoad then
100187: LD_VAR 0 1
100191: IFFALSE 100666
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100193: LD_ADDR_VAR 0 4
100197: PUSH
100198: LD_EXP 100
100202: PUSH
100203: LD_EXP 99
100207: PUSH
100208: LD_EXP 101
100212: PUSH
100213: LD_EXP 98
100217: PUSH
100218: LD_EXP 102
100222: PUSH
100223: LD_EXP 103
100227: PUSH
100228: LD_EXP 104
100232: PUSH
100233: LD_EXP 105
100237: PUSH
100238: LD_EXP 106
100242: PUSH
100243: LD_EXP 107
100247: PUSH
100248: LD_EXP 108
100252: PUSH
100253: LD_EXP 109
100257: PUSH
100258: LD_EXP 110
100262: PUSH
100263: LD_EXP 111
100267: PUSH
100268: LD_EXP 119
100272: PUSH
100273: LD_EXP 120
100277: PUSH
100278: LD_EXP 121
100282: PUSH
100283: LD_EXP 122
100287: PUSH
100288: LD_EXP 124
100292: PUSH
100293: LD_EXP 125
100297: PUSH
100298: LD_EXP 126
100302: PUSH
100303: LD_EXP 129
100307: PUSH
100308: LD_EXP 131
100312: PUSH
100313: LD_EXP 132
100317: PUSH
100318: LD_EXP 133
100322: PUSH
100323: LD_EXP 135
100327: PUSH
100328: LD_EXP 136
100332: PUSH
100333: LD_EXP 139
100337: PUSH
100338: LD_EXP 140
100342: PUSH
100343: LD_EXP 141
100347: PUSH
100348: LD_EXP 142
100352: PUSH
100353: LD_EXP 143
100357: PUSH
100358: LD_EXP 144
100362: PUSH
100363: LD_EXP 145
100367: PUSH
100368: LD_EXP 146
100372: PUSH
100373: LD_EXP 147
100377: PUSH
100378: LD_EXP 112
100382: PUSH
100383: LD_EXP 113
100387: PUSH
100388: LD_EXP 116
100392: PUSH
100393: LD_EXP 117
100397: PUSH
100398: LD_EXP 118
100402: PUSH
100403: LD_EXP 114
100407: PUSH
100408: LD_EXP 115
100412: PUSH
100413: LD_EXP 123
100417: PUSH
100418: LD_EXP 127
100422: PUSH
100423: LD_EXP 128
100427: PUSH
100428: LD_EXP 130
100432: PUSH
100433: LD_EXP 134
100437: PUSH
100438: LD_EXP 137
100442: PUSH
100443: LD_EXP 138
100447: PUSH
100448: LD_EXP 148
100452: PUSH
100453: LD_EXP 149
100457: PUSH
100458: LD_EXP 150
100462: PUSH
100463: LD_EXP 151
100467: PUSH
100468: EMPTY
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: LIST
100507: LIST
100508: LIST
100509: LIST
100510: LIST
100511: LIST
100512: LIST
100513: LIST
100514: LIST
100515: LIST
100516: LIST
100517: LIST
100518: LIST
100519: LIST
100520: LIST
100521: LIST
100522: LIST
100523: ST_TO_ADDR
// tmp :=  ;
100524: LD_ADDR_VAR 0 3
100528: PUSH
100529: LD_STRING 
100531: ST_TO_ADDR
// for i = 1 to normalCounter do
100532: LD_ADDR_VAR 0 8
100536: PUSH
100537: DOUBLE
100538: LD_INT 1
100540: DEC
100541: ST_TO_ADDR
100542: LD_EXP 96
100546: PUSH
100547: FOR_TO
100548: IFFALSE 100584
// begin if flags [ i ] then
100550: LD_VAR 0 4
100554: PUSH
100555: LD_VAR 0 8
100559: ARRAY
100560: IFFALSE 100582
// tmp := tmp & i & ; ;
100562: LD_ADDR_VAR 0 3
100566: PUSH
100567: LD_VAR 0 3
100571: PUSH
100572: LD_VAR 0 8
100576: STR
100577: PUSH
100578: LD_STRING ;
100580: STR
100581: ST_TO_ADDR
// end ;
100582: GO 100547
100584: POP
100585: POP
// for i = 1 to hardcoreCounter do
100586: LD_ADDR_VAR 0 8
100590: PUSH
100591: DOUBLE
100592: LD_INT 1
100594: DEC
100595: ST_TO_ADDR
100596: LD_EXP 97
100600: PUSH
100601: FOR_TO
100602: IFFALSE 100648
// begin if flags [ normalCounter + i ] then
100604: LD_VAR 0 4
100608: PUSH
100609: LD_EXP 96
100613: PUSH
100614: LD_VAR 0 8
100618: PLUS
100619: ARRAY
100620: IFFALSE 100646
// tmp := tmp & ( 100 + i ) & ; ;
100622: LD_ADDR_VAR 0 3
100626: PUSH
100627: LD_VAR 0 3
100631: PUSH
100632: LD_INT 100
100634: PUSH
100635: LD_VAR 0 8
100639: PLUS
100640: STR
100641: PUSH
100642: LD_STRING ;
100644: STR
100645: ST_TO_ADDR
// end ;
100646: GO 100601
100648: POP
100649: POP
// if tmp then
100650: LD_VAR 0 3
100654: IFFALSE 100666
// active := tmp ;
100656: LD_ADDR_VAR 0 7
100660: PUSH
100661: LD_VAR 0 3
100665: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100666: LD_STRING getStreamItemsFromMission("
100668: PUSH
100669: LD_VAR 0 5
100673: STR
100674: PUSH
100675: LD_STRING ","
100677: STR
100678: PUSH
100679: LD_VAR 0 6
100683: STR
100684: PUSH
100685: LD_STRING ","
100687: STR
100688: PUSH
100689: LD_VAR 0 7
100693: STR
100694: PUSH
100695: LD_STRING ")
100697: STR
100698: PPUSH
100699: CALL_OW 559
// end else
100703: GO 100712
// ToLua ( getStreamItemsFromMission("","","") ) ;
100705: LD_STRING getStreamItemsFromMission("","","")
100707: PPUSH
100708: CALL_OW 559
// end ;
100712: LD_VAR 0 2
100716: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100717: LD_EXP 95
100721: PUSH
100722: LD_EXP 100
100726: AND
100727: IFFALSE 100851
100729: GO 100731
100731: DISABLE
100732: LD_INT 0
100734: PPUSH
100735: PPUSH
// begin enable ;
100736: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100737: LD_ADDR_VAR 0 2
100741: PUSH
100742: LD_INT 22
100744: PUSH
100745: LD_OWVAR 2
100749: PUSH
100750: EMPTY
100751: LIST
100752: LIST
100753: PUSH
100754: LD_INT 2
100756: PUSH
100757: LD_INT 34
100759: PUSH
100760: LD_INT 7
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: PUSH
100767: LD_INT 34
100769: PUSH
100770: LD_INT 45
100772: PUSH
100773: EMPTY
100774: LIST
100775: LIST
100776: PUSH
100777: LD_INT 34
100779: PUSH
100780: LD_INT 28
100782: PUSH
100783: EMPTY
100784: LIST
100785: LIST
100786: PUSH
100787: LD_INT 34
100789: PUSH
100790: LD_INT 47
100792: PUSH
100793: EMPTY
100794: LIST
100795: LIST
100796: PUSH
100797: EMPTY
100798: LIST
100799: LIST
100800: LIST
100801: LIST
100802: LIST
100803: PUSH
100804: EMPTY
100805: LIST
100806: LIST
100807: PPUSH
100808: CALL_OW 69
100812: ST_TO_ADDR
// if not tmp then
100813: LD_VAR 0 2
100817: NOT
100818: IFFALSE 100822
// exit ;
100820: GO 100851
// for i in tmp do
100822: LD_ADDR_VAR 0 1
100826: PUSH
100827: LD_VAR 0 2
100831: PUSH
100832: FOR_IN
100833: IFFALSE 100849
// begin SetLives ( i , 0 ) ;
100835: LD_VAR 0 1
100839: PPUSH
100840: LD_INT 0
100842: PPUSH
100843: CALL_OW 234
// end ;
100847: GO 100832
100849: POP
100850: POP
// end ;
100851: PPOPN 2
100853: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
100854: LD_EXP 95
100858: PUSH
100859: LD_EXP 101
100863: AND
100864: IFFALSE 100948
100866: GO 100868
100868: DISABLE
100869: LD_INT 0
100871: PPUSH
100872: PPUSH
// begin enable ;
100873: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
100874: LD_ADDR_VAR 0 2
100878: PUSH
100879: LD_INT 22
100881: PUSH
100882: LD_OWVAR 2
100886: PUSH
100887: EMPTY
100888: LIST
100889: LIST
100890: PUSH
100891: LD_INT 32
100893: PUSH
100894: LD_INT 3
100896: PUSH
100897: EMPTY
100898: LIST
100899: LIST
100900: PUSH
100901: EMPTY
100902: LIST
100903: LIST
100904: PPUSH
100905: CALL_OW 69
100909: ST_TO_ADDR
// if not tmp then
100910: LD_VAR 0 2
100914: NOT
100915: IFFALSE 100919
// exit ;
100917: GO 100948
// for i in tmp do
100919: LD_ADDR_VAR 0 1
100923: PUSH
100924: LD_VAR 0 2
100928: PUSH
100929: FOR_IN
100930: IFFALSE 100946
// begin SetLives ( i , 0 ) ;
100932: LD_VAR 0 1
100936: PPUSH
100937: LD_INT 0
100939: PPUSH
100940: CALL_OW 234
// end ;
100944: GO 100929
100946: POP
100947: POP
// end ;
100948: PPOPN 2
100950: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
100951: LD_EXP 95
100955: PUSH
100956: LD_EXP 98
100960: AND
100961: IFFALSE 101054
100963: GO 100965
100965: DISABLE
100966: LD_INT 0
100968: PPUSH
// begin enable ;
100969: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
100970: LD_ADDR_VAR 0 1
100974: PUSH
100975: LD_INT 22
100977: PUSH
100978: LD_OWVAR 2
100982: PUSH
100983: EMPTY
100984: LIST
100985: LIST
100986: PUSH
100987: LD_INT 2
100989: PUSH
100990: LD_INT 25
100992: PUSH
100993: LD_INT 5
100995: PUSH
100996: EMPTY
100997: LIST
100998: LIST
100999: PUSH
101000: LD_INT 25
101002: PUSH
101003: LD_INT 9
101005: PUSH
101006: EMPTY
101007: LIST
101008: LIST
101009: PUSH
101010: LD_INT 25
101012: PUSH
101013: LD_INT 8
101015: PUSH
101016: EMPTY
101017: LIST
101018: LIST
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: PUSH
101026: EMPTY
101027: LIST
101028: LIST
101029: PPUSH
101030: CALL_OW 69
101034: PUSH
101035: FOR_IN
101036: IFFALSE 101052
// begin SetClass ( i , 1 ) ;
101038: LD_VAR 0 1
101042: PPUSH
101043: LD_INT 1
101045: PPUSH
101046: CALL_OW 336
// end ;
101050: GO 101035
101052: POP
101053: POP
// end ;
101054: PPOPN 1
101056: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101057: LD_EXP 95
101061: PUSH
101062: LD_EXP 99
101066: AND
101067: PUSH
101068: LD_OWVAR 65
101072: PUSH
101073: LD_INT 7
101075: LESS
101076: AND
101077: IFFALSE 101091
101079: GO 101081
101081: DISABLE
// begin enable ;
101082: ENABLE
// game_speed := 7 ;
101083: LD_ADDR_OWVAR 65
101087: PUSH
101088: LD_INT 7
101090: ST_TO_ADDR
// end ;
101091: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101092: LD_EXP 95
101096: PUSH
101097: LD_EXP 102
101101: AND
101102: IFFALSE 101304
101104: GO 101106
101106: DISABLE
101107: LD_INT 0
101109: PPUSH
101110: PPUSH
101111: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101112: LD_ADDR_VAR 0 3
101116: PUSH
101117: LD_INT 81
101119: PUSH
101120: LD_OWVAR 2
101124: PUSH
101125: EMPTY
101126: LIST
101127: LIST
101128: PUSH
101129: LD_INT 21
101131: PUSH
101132: LD_INT 1
101134: PUSH
101135: EMPTY
101136: LIST
101137: LIST
101138: PUSH
101139: EMPTY
101140: LIST
101141: LIST
101142: PPUSH
101143: CALL_OW 69
101147: ST_TO_ADDR
// if not tmp then
101148: LD_VAR 0 3
101152: NOT
101153: IFFALSE 101157
// exit ;
101155: GO 101304
// if tmp > 5 then
101157: LD_VAR 0 3
101161: PUSH
101162: LD_INT 5
101164: GREATER
101165: IFFALSE 101177
// k := 5 else
101167: LD_ADDR_VAR 0 2
101171: PUSH
101172: LD_INT 5
101174: ST_TO_ADDR
101175: GO 101187
// k := tmp ;
101177: LD_ADDR_VAR 0 2
101181: PUSH
101182: LD_VAR 0 3
101186: ST_TO_ADDR
// for i := 1 to k do
101187: LD_ADDR_VAR 0 1
101191: PUSH
101192: DOUBLE
101193: LD_INT 1
101195: DEC
101196: ST_TO_ADDR
101197: LD_VAR 0 2
101201: PUSH
101202: FOR_TO
101203: IFFALSE 101302
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101205: LD_VAR 0 3
101209: PUSH
101210: LD_VAR 0 1
101214: ARRAY
101215: PPUSH
101216: LD_VAR 0 1
101220: PUSH
101221: LD_INT 4
101223: MOD
101224: PUSH
101225: LD_INT 1
101227: PLUS
101228: PPUSH
101229: CALL_OW 259
101233: PUSH
101234: LD_INT 10
101236: LESS
101237: IFFALSE 101300
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101239: LD_VAR 0 3
101243: PUSH
101244: LD_VAR 0 1
101248: ARRAY
101249: PPUSH
101250: LD_VAR 0 1
101254: PUSH
101255: LD_INT 4
101257: MOD
101258: PUSH
101259: LD_INT 1
101261: PLUS
101262: PPUSH
101263: LD_VAR 0 3
101267: PUSH
101268: LD_VAR 0 1
101272: ARRAY
101273: PPUSH
101274: LD_VAR 0 1
101278: PUSH
101279: LD_INT 4
101281: MOD
101282: PUSH
101283: LD_INT 1
101285: PLUS
101286: PPUSH
101287: CALL_OW 259
101291: PUSH
101292: LD_INT 1
101294: PLUS
101295: PPUSH
101296: CALL_OW 237
101300: GO 101202
101302: POP
101303: POP
// end ;
101304: PPOPN 3
101306: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101307: LD_EXP 95
101311: PUSH
101312: LD_EXP 103
101316: AND
101317: IFFALSE 101337
101319: GO 101321
101321: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101322: LD_INT 4
101324: PPUSH
101325: LD_OWVAR 2
101329: PPUSH
101330: LD_INT 0
101332: PPUSH
101333: CALL_OW 324
101337: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101338: LD_EXP 95
101342: PUSH
101343: LD_EXP 132
101347: AND
101348: IFFALSE 101368
101350: GO 101352
101352: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101353: LD_INT 19
101355: PPUSH
101356: LD_OWVAR 2
101360: PPUSH
101361: LD_INT 0
101363: PPUSH
101364: CALL_OW 324
101368: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101369: LD_EXP 95
101373: PUSH
101374: LD_EXP 104
101378: AND
101379: IFFALSE 101481
101381: GO 101383
101383: DISABLE
101384: LD_INT 0
101386: PPUSH
101387: PPUSH
// begin enable ;
101388: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101389: LD_ADDR_VAR 0 2
101393: PUSH
101394: LD_INT 22
101396: PUSH
101397: LD_OWVAR 2
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: PUSH
101406: LD_INT 2
101408: PUSH
101409: LD_INT 34
101411: PUSH
101412: LD_INT 11
101414: PUSH
101415: EMPTY
101416: LIST
101417: LIST
101418: PUSH
101419: LD_INT 34
101421: PUSH
101422: LD_INT 30
101424: PUSH
101425: EMPTY
101426: LIST
101427: LIST
101428: PUSH
101429: EMPTY
101430: LIST
101431: LIST
101432: LIST
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PPUSH
101438: CALL_OW 69
101442: ST_TO_ADDR
// if not tmp then
101443: LD_VAR 0 2
101447: NOT
101448: IFFALSE 101452
// exit ;
101450: GO 101481
// for i in tmp do
101452: LD_ADDR_VAR 0 1
101456: PUSH
101457: LD_VAR 0 2
101461: PUSH
101462: FOR_IN
101463: IFFALSE 101479
// begin SetLives ( i , 0 ) ;
101465: LD_VAR 0 1
101469: PPUSH
101470: LD_INT 0
101472: PPUSH
101473: CALL_OW 234
// end ;
101477: GO 101462
101479: POP
101480: POP
// end ;
101481: PPOPN 2
101483: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101484: LD_EXP 95
101488: PUSH
101489: LD_EXP 105
101493: AND
101494: IFFALSE 101514
101496: GO 101498
101498: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101499: LD_INT 32
101501: PPUSH
101502: LD_OWVAR 2
101506: PPUSH
101507: LD_INT 0
101509: PPUSH
101510: CALL_OW 324
101514: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101515: LD_EXP 95
101519: PUSH
101520: LD_EXP 106
101524: AND
101525: IFFALSE 101706
101527: GO 101529
101529: DISABLE
101530: LD_INT 0
101532: PPUSH
101533: PPUSH
101534: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101535: LD_ADDR_VAR 0 2
101539: PUSH
101540: LD_INT 22
101542: PUSH
101543: LD_OWVAR 2
101547: PUSH
101548: EMPTY
101549: LIST
101550: LIST
101551: PUSH
101552: LD_INT 33
101554: PUSH
101555: LD_INT 3
101557: PUSH
101558: EMPTY
101559: LIST
101560: LIST
101561: PUSH
101562: EMPTY
101563: LIST
101564: LIST
101565: PPUSH
101566: CALL_OW 69
101570: ST_TO_ADDR
// if not tmp then
101571: LD_VAR 0 2
101575: NOT
101576: IFFALSE 101580
// exit ;
101578: GO 101706
// side := 0 ;
101580: LD_ADDR_VAR 0 3
101584: PUSH
101585: LD_INT 0
101587: ST_TO_ADDR
// for i := 1 to 8 do
101588: LD_ADDR_VAR 0 1
101592: PUSH
101593: DOUBLE
101594: LD_INT 1
101596: DEC
101597: ST_TO_ADDR
101598: LD_INT 8
101600: PUSH
101601: FOR_TO
101602: IFFALSE 101650
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101604: LD_OWVAR 2
101608: PUSH
101609: LD_VAR 0 1
101613: NONEQUAL
101614: PUSH
101615: LD_OWVAR 2
101619: PPUSH
101620: LD_VAR 0 1
101624: PPUSH
101625: CALL_OW 81
101629: PUSH
101630: LD_INT 2
101632: EQUAL
101633: AND
101634: IFFALSE 101648
// begin side := i ;
101636: LD_ADDR_VAR 0 3
101640: PUSH
101641: LD_VAR 0 1
101645: ST_TO_ADDR
// break ;
101646: GO 101650
// end ;
101648: GO 101601
101650: POP
101651: POP
// if not side then
101652: LD_VAR 0 3
101656: NOT
101657: IFFALSE 101661
// exit ;
101659: GO 101706
// for i := 1 to tmp do
101661: LD_ADDR_VAR 0 1
101665: PUSH
101666: DOUBLE
101667: LD_INT 1
101669: DEC
101670: ST_TO_ADDR
101671: LD_VAR 0 2
101675: PUSH
101676: FOR_TO
101677: IFFALSE 101704
// if Prob ( 60 ) then
101679: LD_INT 60
101681: PPUSH
101682: CALL_OW 13
101686: IFFALSE 101702
// SetSide ( i , side ) ;
101688: LD_VAR 0 1
101692: PPUSH
101693: LD_VAR 0 3
101697: PPUSH
101698: CALL_OW 235
101702: GO 101676
101704: POP
101705: POP
// end ;
101706: PPOPN 3
101708: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101709: LD_EXP 95
101713: PUSH
101714: LD_EXP 108
101718: AND
101719: IFFALSE 101838
101721: GO 101723
101723: DISABLE
101724: LD_INT 0
101726: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101727: LD_ADDR_VAR 0 1
101731: PUSH
101732: LD_INT 22
101734: PUSH
101735: LD_OWVAR 2
101739: PUSH
101740: EMPTY
101741: LIST
101742: LIST
101743: PUSH
101744: LD_INT 21
101746: PUSH
101747: LD_INT 1
101749: PUSH
101750: EMPTY
101751: LIST
101752: LIST
101753: PUSH
101754: LD_INT 3
101756: PUSH
101757: LD_INT 23
101759: PUSH
101760: LD_INT 0
101762: PUSH
101763: EMPTY
101764: LIST
101765: LIST
101766: PUSH
101767: EMPTY
101768: LIST
101769: LIST
101770: PUSH
101771: EMPTY
101772: LIST
101773: LIST
101774: LIST
101775: PPUSH
101776: CALL_OW 69
101780: PUSH
101781: FOR_IN
101782: IFFALSE 101836
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101784: LD_VAR 0 1
101788: PPUSH
101789: CALL_OW 257
101793: PUSH
101794: LD_INT 1
101796: PUSH
101797: LD_INT 2
101799: PUSH
101800: LD_INT 3
101802: PUSH
101803: LD_INT 4
101805: PUSH
101806: EMPTY
101807: LIST
101808: LIST
101809: LIST
101810: LIST
101811: IN
101812: IFFALSE 101834
// SetClass ( un , rand ( 1 , 4 ) ) ;
101814: LD_VAR 0 1
101818: PPUSH
101819: LD_INT 1
101821: PPUSH
101822: LD_INT 4
101824: PPUSH
101825: CALL_OW 12
101829: PPUSH
101830: CALL_OW 336
101834: GO 101781
101836: POP
101837: POP
// end ;
101838: PPOPN 1
101840: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101841: LD_EXP 95
101845: PUSH
101846: LD_EXP 107
101850: AND
101851: IFFALSE 101930
101853: GO 101855
101855: DISABLE
101856: LD_INT 0
101858: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
101859: LD_ADDR_VAR 0 1
101863: PUSH
101864: LD_INT 22
101866: PUSH
101867: LD_OWVAR 2
101871: PUSH
101872: EMPTY
101873: LIST
101874: LIST
101875: PUSH
101876: LD_INT 21
101878: PUSH
101879: LD_INT 3
101881: PUSH
101882: EMPTY
101883: LIST
101884: LIST
101885: PUSH
101886: EMPTY
101887: LIST
101888: LIST
101889: PPUSH
101890: CALL_OW 69
101894: ST_TO_ADDR
// if not tmp then
101895: LD_VAR 0 1
101899: NOT
101900: IFFALSE 101904
// exit ;
101902: GO 101930
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
101904: LD_VAR 0 1
101908: PUSH
101909: LD_INT 1
101911: PPUSH
101912: LD_VAR 0 1
101916: PPUSH
101917: CALL_OW 12
101921: ARRAY
101922: PPUSH
101923: LD_INT 100
101925: PPUSH
101926: CALL_OW 234
// end ;
101930: PPOPN 1
101932: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
101933: LD_EXP 95
101937: PUSH
101938: LD_EXP 109
101942: AND
101943: IFFALSE 102041
101945: GO 101947
101947: DISABLE
101948: LD_INT 0
101950: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101951: LD_ADDR_VAR 0 1
101955: PUSH
101956: LD_INT 22
101958: PUSH
101959: LD_OWVAR 2
101963: PUSH
101964: EMPTY
101965: LIST
101966: LIST
101967: PUSH
101968: LD_INT 21
101970: PUSH
101971: LD_INT 1
101973: PUSH
101974: EMPTY
101975: LIST
101976: LIST
101977: PUSH
101978: EMPTY
101979: LIST
101980: LIST
101981: PPUSH
101982: CALL_OW 69
101986: ST_TO_ADDR
// if not tmp then
101987: LD_VAR 0 1
101991: NOT
101992: IFFALSE 101996
// exit ;
101994: GO 102041
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
101996: LD_VAR 0 1
102000: PUSH
102001: LD_INT 1
102003: PPUSH
102004: LD_VAR 0 1
102008: PPUSH
102009: CALL_OW 12
102013: ARRAY
102014: PPUSH
102015: LD_INT 1
102017: PPUSH
102018: LD_INT 4
102020: PPUSH
102021: CALL_OW 12
102025: PPUSH
102026: LD_INT 3000
102028: PPUSH
102029: LD_INT 9000
102031: PPUSH
102032: CALL_OW 12
102036: PPUSH
102037: CALL_OW 492
// end ;
102041: PPOPN 1
102043: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102044: LD_EXP 95
102048: PUSH
102049: LD_EXP 110
102053: AND
102054: IFFALSE 102074
102056: GO 102058
102058: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102059: LD_INT 1
102061: PPUSH
102062: LD_OWVAR 2
102066: PPUSH
102067: LD_INT 0
102069: PPUSH
102070: CALL_OW 324
102074: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102075: LD_EXP 95
102079: PUSH
102080: LD_EXP 111
102084: AND
102085: IFFALSE 102168
102087: GO 102089
102089: DISABLE
102090: LD_INT 0
102092: PPUSH
102093: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102094: LD_ADDR_VAR 0 2
102098: PUSH
102099: LD_INT 22
102101: PUSH
102102: LD_OWVAR 2
102106: PUSH
102107: EMPTY
102108: LIST
102109: LIST
102110: PUSH
102111: LD_INT 21
102113: PUSH
102114: LD_INT 3
102116: PUSH
102117: EMPTY
102118: LIST
102119: LIST
102120: PUSH
102121: EMPTY
102122: LIST
102123: LIST
102124: PPUSH
102125: CALL_OW 69
102129: ST_TO_ADDR
// if not tmp then
102130: LD_VAR 0 2
102134: NOT
102135: IFFALSE 102139
// exit ;
102137: GO 102168
// for i in tmp do
102139: LD_ADDR_VAR 0 1
102143: PUSH
102144: LD_VAR 0 2
102148: PUSH
102149: FOR_IN
102150: IFFALSE 102166
// SetBLevel ( i , 10 ) ;
102152: LD_VAR 0 1
102156: PPUSH
102157: LD_INT 10
102159: PPUSH
102160: CALL_OW 241
102164: GO 102149
102166: POP
102167: POP
// end ;
102168: PPOPN 2
102170: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102171: LD_EXP 95
102175: PUSH
102176: LD_EXP 112
102180: AND
102181: IFFALSE 102292
102183: GO 102185
102185: DISABLE
102186: LD_INT 0
102188: PPUSH
102189: PPUSH
102190: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102191: LD_ADDR_VAR 0 3
102195: PUSH
102196: LD_INT 22
102198: PUSH
102199: LD_OWVAR 2
102203: PUSH
102204: EMPTY
102205: LIST
102206: LIST
102207: PUSH
102208: LD_INT 25
102210: PUSH
102211: LD_INT 1
102213: PUSH
102214: EMPTY
102215: LIST
102216: LIST
102217: PUSH
102218: EMPTY
102219: LIST
102220: LIST
102221: PPUSH
102222: CALL_OW 69
102226: ST_TO_ADDR
// if not tmp then
102227: LD_VAR 0 3
102231: NOT
102232: IFFALSE 102236
// exit ;
102234: GO 102292
// un := tmp [ rand ( 1 , tmp ) ] ;
102236: LD_ADDR_VAR 0 2
102240: PUSH
102241: LD_VAR 0 3
102245: PUSH
102246: LD_INT 1
102248: PPUSH
102249: LD_VAR 0 3
102253: PPUSH
102254: CALL_OW 12
102258: ARRAY
102259: ST_TO_ADDR
// if Crawls ( un ) then
102260: LD_VAR 0 2
102264: PPUSH
102265: CALL_OW 318
102269: IFFALSE 102280
// ComWalk ( un ) ;
102271: LD_VAR 0 2
102275: PPUSH
102276: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102280: LD_VAR 0 2
102284: PPUSH
102285: LD_INT 5
102287: PPUSH
102288: CALL_OW 336
// end ;
102292: PPOPN 3
102294: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102295: LD_EXP 95
102299: PUSH
102300: LD_EXP 113
102304: AND
102305: PUSH
102306: LD_OWVAR 67
102310: PUSH
102311: LD_INT 4
102313: LESS
102314: AND
102315: IFFALSE 102334
102317: GO 102319
102319: DISABLE
// begin Difficulty := Difficulty + 1 ;
102320: LD_ADDR_OWVAR 67
102324: PUSH
102325: LD_OWVAR 67
102329: PUSH
102330: LD_INT 1
102332: PLUS
102333: ST_TO_ADDR
// end ;
102334: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102335: LD_EXP 95
102339: PUSH
102340: LD_EXP 114
102344: AND
102345: IFFALSE 102448
102347: GO 102349
102349: DISABLE
102350: LD_INT 0
102352: PPUSH
// begin for i := 1 to 5 do
102353: LD_ADDR_VAR 0 1
102357: PUSH
102358: DOUBLE
102359: LD_INT 1
102361: DEC
102362: ST_TO_ADDR
102363: LD_INT 5
102365: PUSH
102366: FOR_TO
102367: IFFALSE 102446
// begin uc_nation := nation_nature ;
102369: LD_ADDR_OWVAR 21
102373: PUSH
102374: LD_INT 0
102376: ST_TO_ADDR
// uc_side := 0 ;
102377: LD_ADDR_OWVAR 20
102381: PUSH
102382: LD_INT 0
102384: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102385: LD_ADDR_OWVAR 29
102389: PUSH
102390: LD_INT 12
102392: PUSH
102393: LD_INT 12
102395: PUSH
102396: EMPTY
102397: LIST
102398: LIST
102399: ST_TO_ADDR
// hc_agressivity := 20 ;
102400: LD_ADDR_OWVAR 35
102404: PUSH
102405: LD_INT 20
102407: ST_TO_ADDR
// hc_class := class_tiger ;
102408: LD_ADDR_OWVAR 28
102412: PUSH
102413: LD_INT 14
102415: ST_TO_ADDR
// hc_gallery :=  ;
102416: LD_ADDR_OWVAR 33
102420: PUSH
102421: LD_STRING 
102423: ST_TO_ADDR
// hc_name :=  ;
102424: LD_ADDR_OWVAR 26
102428: PUSH
102429: LD_STRING 
102431: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102432: CALL_OW 44
102436: PPUSH
102437: LD_INT 0
102439: PPUSH
102440: CALL_OW 51
// end ;
102444: GO 102366
102446: POP
102447: POP
// end ;
102448: PPOPN 1
102450: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102451: LD_EXP 95
102455: PUSH
102456: LD_EXP 115
102460: AND
102461: IFFALSE 102470
102463: GO 102465
102465: DISABLE
// StreamSibBomb ;
102466: CALL 102471 0 0
102470: END
// export function StreamSibBomb ; var i , x , y ; begin
102471: LD_INT 0
102473: PPUSH
102474: PPUSH
102475: PPUSH
102476: PPUSH
// result := false ;
102477: LD_ADDR_VAR 0 1
102481: PUSH
102482: LD_INT 0
102484: ST_TO_ADDR
// for i := 1 to 16 do
102485: LD_ADDR_VAR 0 2
102489: PUSH
102490: DOUBLE
102491: LD_INT 1
102493: DEC
102494: ST_TO_ADDR
102495: LD_INT 16
102497: PUSH
102498: FOR_TO
102499: IFFALSE 102698
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102501: LD_ADDR_VAR 0 3
102505: PUSH
102506: LD_INT 10
102508: PUSH
102509: LD_INT 20
102511: PUSH
102512: LD_INT 30
102514: PUSH
102515: LD_INT 40
102517: PUSH
102518: LD_INT 50
102520: PUSH
102521: LD_INT 60
102523: PUSH
102524: LD_INT 70
102526: PUSH
102527: LD_INT 80
102529: PUSH
102530: LD_INT 90
102532: PUSH
102533: LD_INT 100
102535: PUSH
102536: LD_INT 110
102538: PUSH
102539: LD_INT 120
102541: PUSH
102542: LD_INT 130
102544: PUSH
102545: LD_INT 140
102547: PUSH
102548: LD_INT 150
102550: PUSH
102551: EMPTY
102552: LIST
102553: LIST
102554: LIST
102555: LIST
102556: LIST
102557: LIST
102558: LIST
102559: LIST
102560: LIST
102561: LIST
102562: LIST
102563: LIST
102564: LIST
102565: LIST
102566: LIST
102567: PUSH
102568: LD_INT 1
102570: PPUSH
102571: LD_INT 15
102573: PPUSH
102574: CALL_OW 12
102578: ARRAY
102579: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102580: LD_ADDR_VAR 0 4
102584: PUSH
102585: LD_INT 10
102587: PUSH
102588: LD_INT 20
102590: PUSH
102591: LD_INT 30
102593: PUSH
102594: LD_INT 40
102596: PUSH
102597: LD_INT 50
102599: PUSH
102600: LD_INT 60
102602: PUSH
102603: LD_INT 70
102605: PUSH
102606: LD_INT 80
102608: PUSH
102609: LD_INT 90
102611: PUSH
102612: LD_INT 100
102614: PUSH
102615: LD_INT 110
102617: PUSH
102618: LD_INT 120
102620: PUSH
102621: LD_INT 130
102623: PUSH
102624: LD_INT 140
102626: PUSH
102627: LD_INT 150
102629: PUSH
102630: EMPTY
102631: LIST
102632: LIST
102633: LIST
102634: LIST
102635: LIST
102636: LIST
102637: LIST
102638: LIST
102639: LIST
102640: LIST
102641: LIST
102642: LIST
102643: LIST
102644: LIST
102645: LIST
102646: PUSH
102647: LD_INT 1
102649: PPUSH
102650: LD_INT 15
102652: PPUSH
102653: CALL_OW 12
102657: ARRAY
102658: ST_TO_ADDR
// if ValidHex ( x , y ) then
102659: LD_VAR 0 3
102663: PPUSH
102664: LD_VAR 0 4
102668: PPUSH
102669: CALL_OW 488
102673: IFFALSE 102696
// begin result := [ x , y ] ;
102675: LD_ADDR_VAR 0 1
102679: PUSH
102680: LD_VAR 0 3
102684: PUSH
102685: LD_VAR 0 4
102689: PUSH
102690: EMPTY
102691: LIST
102692: LIST
102693: ST_TO_ADDR
// break ;
102694: GO 102698
// end ; end ;
102696: GO 102498
102698: POP
102699: POP
// if result then
102700: LD_VAR 0 1
102704: IFFALSE 102764
// begin ToLua ( playSibBomb() ) ;
102706: LD_STRING playSibBomb()
102708: PPUSH
102709: CALL_OW 559
// wait ( 0 0$14 ) ;
102713: LD_INT 490
102715: PPUSH
102716: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102720: LD_VAR 0 1
102724: PUSH
102725: LD_INT 1
102727: ARRAY
102728: PPUSH
102729: LD_VAR 0 1
102733: PUSH
102734: LD_INT 2
102736: ARRAY
102737: PPUSH
102738: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102742: LD_VAR 0 1
102746: PUSH
102747: LD_INT 1
102749: ARRAY
102750: PPUSH
102751: LD_VAR 0 1
102755: PUSH
102756: LD_INT 2
102758: ARRAY
102759: PPUSH
102760: CALL_OW 429
// end ; end ;
102764: LD_VAR 0 1
102768: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102769: LD_EXP 95
102773: PUSH
102774: LD_EXP 117
102778: AND
102779: IFFALSE 102791
102781: GO 102783
102783: DISABLE
// YouLost (  ) ;
102784: LD_STRING 
102786: PPUSH
102787: CALL_OW 104
102791: END
// every 0 0$1 trigger StreamModeActive and sFog do
102792: LD_EXP 95
102796: PUSH
102797: LD_EXP 116
102801: AND
102802: IFFALSE 102816
102804: GO 102806
102806: DISABLE
// FogOff ( your_side ) ;
102807: LD_OWVAR 2
102811: PPUSH
102812: CALL_OW 344
102816: END
// every 0 0$1 trigger StreamModeActive and sSun do
102817: LD_EXP 95
102821: PUSH
102822: LD_EXP 118
102826: AND
102827: IFFALSE 102855
102829: GO 102831
102831: DISABLE
// begin solar_recharge_percent := 0 ;
102832: LD_ADDR_OWVAR 79
102836: PUSH
102837: LD_INT 0
102839: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102840: LD_INT 10500
102842: PPUSH
102843: CALL_OW 67
// solar_recharge_percent := 100 ;
102847: LD_ADDR_OWVAR 79
102851: PUSH
102852: LD_INT 100
102854: ST_TO_ADDR
// end ;
102855: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
102856: LD_EXP 95
102860: PUSH
102861: LD_EXP 119
102865: AND
102866: IFFALSE 103105
102868: GO 102870
102870: DISABLE
102871: LD_INT 0
102873: PPUSH
102874: PPUSH
102875: PPUSH
// begin tmp := [ ] ;
102876: LD_ADDR_VAR 0 3
102880: PUSH
102881: EMPTY
102882: ST_TO_ADDR
// for i := 1 to 6 do
102883: LD_ADDR_VAR 0 1
102887: PUSH
102888: DOUBLE
102889: LD_INT 1
102891: DEC
102892: ST_TO_ADDR
102893: LD_INT 6
102895: PUSH
102896: FOR_TO
102897: IFFALSE 103002
// begin uc_nation := nation_nature ;
102899: LD_ADDR_OWVAR 21
102903: PUSH
102904: LD_INT 0
102906: ST_TO_ADDR
// uc_side := 0 ;
102907: LD_ADDR_OWVAR 20
102911: PUSH
102912: LD_INT 0
102914: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102915: LD_ADDR_OWVAR 29
102919: PUSH
102920: LD_INT 12
102922: PUSH
102923: LD_INT 12
102925: PUSH
102926: EMPTY
102927: LIST
102928: LIST
102929: ST_TO_ADDR
// hc_agressivity := 20 ;
102930: LD_ADDR_OWVAR 35
102934: PUSH
102935: LD_INT 20
102937: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
102938: LD_ADDR_OWVAR 28
102942: PUSH
102943: LD_INT 17
102945: ST_TO_ADDR
// hc_gallery :=  ;
102946: LD_ADDR_OWVAR 33
102950: PUSH
102951: LD_STRING 
102953: ST_TO_ADDR
// hc_name :=  ;
102954: LD_ADDR_OWVAR 26
102958: PUSH
102959: LD_STRING 
102961: ST_TO_ADDR
// un := CreateHuman ;
102962: LD_ADDR_VAR 0 2
102966: PUSH
102967: CALL_OW 44
102971: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
102972: LD_VAR 0 2
102976: PPUSH
102977: LD_INT 1
102979: PPUSH
102980: CALL_OW 51
// tmp := tmp ^ un ;
102984: LD_ADDR_VAR 0 3
102988: PUSH
102989: LD_VAR 0 3
102993: PUSH
102994: LD_VAR 0 2
102998: ADD
102999: ST_TO_ADDR
// end ;
103000: GO 102896
103002: POP
103003: POP
// repeat wait ( 0 0$1 ) ;
103004: LD_INT 35
103006: PPUSH
103007: CALL_OW 67
// for un in tmp do
103011: LD_ADDR_VAR 0 2
103015: PUSH
103016: LD_VAR 0 3
103020: PUSH
103021: FOR_IN
103022: IFFALSE 103096
// begin if IsDead ( un ) then
103024: LD_VAR 0 2
103028: PPUSH
103029: CALL_OW 301
103033: IFFALSE 103053
// begin tmp := tmp diff un ;
103035: LD_ADDR_VAR 0 3
103039: PUSH
103040: LD_VAR 0 3
103044: PUSH
103045: LD_VAR 0 2
103049: DIFF
103050: ST_TO_ADDR
// continue ;
103051: GO 103021
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103053: LD_VAR 0 2
103057: PPUSH
103058: LD_INT 3
103060: PUSH
103061: LD_INT 22
103063: PUSH
103064: LD_INT 0
103066: PUSH
103067: EMPTY
103068: LIST
103069: LIST
103070: PUSH
103071: EMPTY
103072: LIST
103073: LIST
103074: PPUSH
103075: CALL_OW 69
103079: PPUSH
103080: LD_VAR 0 2
103084: PPUSH
103085: CALL_OW 74
103089: PPUSH
103090: CALL_OW 115
// end ;
103094: GO 103021
103096: POP
103097: POP
// until not tmp ;
103098: LD_VAR 0 3
103102: NOT
103103: IFFALSE 103004
// end ;
103105: PPOPN 3
103107: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103108: LD_EXP 95
103112: PUSH
103113: LD_EXP 120
103117: AND
103118: IFFALSE 103172
103120: GO 103122
103122: DISABLE
// begin ToLua ( displayTroll(); ) ;
103123: LD_STRING displayTroll();
103125: PPUSH
103126: CALL_OW 559
// wait ( 3 3$00 ) ;
103130: LD_INT 6300
103132: PPUSH
103133: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103137: LD_STRING hideTroll();
103139: PPUSH
103140: CALL_OW 559
// wait ( 1 1$00 ) ;
103144: LD_INT 2100
103146: PPUSH
103147: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103151: LD_STRING displayTroll();
103153: PPUSH
103154: CALL_OW 559
// wait ( 1 1$00 ) ;
103158: LD_INT 2100
103160: PPUSH
103161: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103165: LD_STRING hideTroll();
103167: PPUSH
103168: CALL_OW 559
// end ;
103172: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103173: LD_EXP 95
103177: PUSH
103178: LD_EXP 121
103182: AND
103183: IFFALSE 103246
103185: GO 103187
103187: DISABLE
103188: LD_INT 0
103190: PPUSH
// begin p := 0 ;
103191: LD_ADDR_VAR 0 1
103195: PUSH
103196: LD_INT 0
103198: ST_TO_ADDR
// repeat game_speed := 1 ;
103199: LD_ADDR_OWVAR 65
103203: PUSH
103204: LD_INT 1
103206: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103207: LD_INT 35
103209: PPUSH
103210: CALL_OW 67
// p := p + 1 ;
103214: LD_ADDR_VAR 0 1
103218: PUSH
103219: LD_VAR 0 1
103223: PUSH
103224: LD_INT 1
103226: PLUS
103227: ST_TO_ADDR
// until p >= 60 ;
103228: LD_VAR 0 1
103232: PUSH
103233: LD_INT 60
103235: GREATEREQUAL
103236: IFFALSE 103199
// game_speed := 4 ;
103238: LD_ADDR_OWVAR 65
103242: PUSH
103243: LD_INT 4
103245: ST_TO_ADDR
// end ;
103246: PPOPN 1
103248: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103249: LD_EXP 95
103253: PUSH
103254: LD_EXP 122
103258: AND
103259: IFFALSE 103405
103261: GO 103263
103263: DISABLE
103264: LD_INT 0
103266: PPUSH
103267: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103268: LD_ADDR_VAR 0 1
103272: PUSH
103273: LD_INT 22
103275: PUSH
103276: LD_OWVAR 2
103280: PUSH
103281: EMPTY
103282: LIST
103283: LIST
103284: PUSH
103285: LD_INT 2
103287: PUSH
103288: LD_INT 30
103290: PUSH
103291: LD_INT 0
103293: PUSH
103294: EMPTY
103295: LIST
103296: LIST
103297: PUSH
103298: LD_INT 30
103300: PUSH
103301: LD_INT 1
103303: PUSH
103304: EMPTY
103305: LIST
103306: LIST
103307: PUSH
103308: EMPTY
103309: LIST
103310: LIST
103311: LIST
103312: PUSH
103313: EMPTY
103314: LIST
103315: LIST
103316: PPUSH
103317: CALL_OW 69
103321: ST_TO_ADDR
// if not depot then
103322: LD_VAR 0 1
103326: NOT
103327: IFFALSE 103331
// exit ;
103329: GO 103405
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103331: LD_ADDR_VAR 0 2
103335: PUSH
103336: LD_VAR 0 1
103340: PUSH
103341: LD_INT 1
103343: PPUSH
103344: LD_VAR 0 1
103348: PPUSH
103349: CALL_OW 12
103353: ARRAY
103354: PPUSH
103355: CALL_OW 274
103359: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103360: LD_VAR 0 2
103364: PPUSH
103365: LD_INT 1
103367: PPUSH
103368: LD_INT 0
103370: PPUSH
103371: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103375: LD_VAR 0 2
103379: PPUSH
103380: LD_INT 2
103382: PPUSH
103383: LD_INT 0
103385: PPUSH
103386: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103390: LD_VAR 0 2
103394: PPUSH
103395: LD_INT 3
103397: PPUSH
103398: LD_INT 0
103400: PPUSH
103401: CALL_OW 277
// end ;
103405: PPOPN 2
103407: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103408: LD_EXP 95
103412: PUSH
103413: LD_EXP 123
103417: AND
103418: IFFALSE 103515
103420: GO 103422
103422: DISABLE
103423: LD_INT 0
103425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103426: LD_ADDR_VAR 0 1
103430: PUSH
103431: LD_INT 22
103433: PUSH
103434: LD_OWVAR 2
103438: PUSH
103439: EMPTY
103440: LIST
103441: LIST
103442: PUSH
103443: LD_INT 21
103445: PUSH
103446: LD_INT 1
103448: PUSH
103449: EMPTY
103450: LIST
103451: LIST
103452: PUSH
103453: LD_INT 3
103455: PUSH
103456: LD_INT 23
103458: PUSH
103459: LD_INT 0
103461: PUSH
103462: EMPTY
103463: LIST
103464: LIST
103465: PUSH
103466: EMPTY
103467: LIST
103468: LIST
103469: PUSH
103470: EMPTY
103471: LIST
103472: LIST
103473: LIST
103474: PPUSH
103475: CALL_OW 69
103479: ST_TO_ADDR
// if not tmp then
103480: LD_VAR 0 1
103484: NOT
103485: IFFALSE 103489
// exit ;
103487: GO 103515
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103489: LD_VAR 0 1
103493: PUSH
103494: LD_INT 1
103496: PPUSH
103497: LD_VAR 0 1
103501: PPUSH
103502: CALL_OW 12
103506: ARRAY
103507: PPUSH
103508: LD_INT 200
103510: PPUSH
103511: CALL_OW 234
// end ;
103515: PPOPN 1
103517: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103518: LD_EXP 95
103522: PUSH
103523: LD_EXP 124
103527: AND
103528: IFFALSE 103607
103530: GO 103532
103532: DISABLE
103533: LD_INT 0
103535: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103536: LD_ADDR_VAR 0 1
103540: PUSH
103541: LD_INT 22
103543: PUSH
103544: LD_OWVAR 2
103548: PUSH
103549: EMPTY
103550: LIST
103551: LIST
103552: PUSH
103553: LD_INT 21
103555: PUSH
103556: LD_INT 2
103558: PUSH
103559: EMPTY
103560: LIST
103561: LIST
103562: PUSH
103563: EMPTY
103564: LIST
103565: LIST
103566: PPUSH
103567: CALL_OW 69
103571: ST_TO_ADDR
// if not tmp then
103572: LD_VAR 0 1
103576: NOT
103577: IFFALSE 103581
// exit ;
103579: GO 103607
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103581: LD_VAR 0 1
103585: PUSH
103586: LD_INT 1
103588: PPUSH
103589: LD_VAR 0 1
103593: PPUSH
103594: CALL_OW 12
103598: ARRAY
103599: PPUSH
103600: LD_INT 60
103602: PPUSH
103603: CALL_OW 234
// end ;
103607: PPOPN 1
103609: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103610: LD_EXP 95
103614: PUSH
103615: LD_EXP 125
103619: AND
103620: IFFALSE 103719
103622: GO 103624
103624: DISABLE
103625: LD_INT 0
103627: PPUSH
103628: PPUSH
// begin enable ;
103629: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103630: LD_ADDR_VAR 0 1
103634: PUSH
103635: LD_INT 22
103637: PUSH
103638: LD_OWVAR 2
103642: PUSH
103643: EMPTY
103644: LIST
103645: LIST
103646: PUSH
103647: LD_INT 61
103649: PUSH
103650: EMPTY
103651: LIST
103652: PUSH
103653: LD_INT 33
103655: PUSH
103656: LD_INT 2
103658: PUSH
103659: EMPTY
103660: LIST
103661: LIST
103662: PUSH
103663: EMPTY
103664: LIST
103665: LIST
103666: LIST
103667: PPUSH
103668: CALL_OW 69
103672: ST_TO_ADDR
// if not tmp then
103673: LD_VAR 0 1
103677: NOT
103678: IFFALSE 103682
// exit ;
103680: GO 103719
// for i in tmp do
103682: LD_ADDR_VAR 0 2
103686: PUSH
103687: LD_VAR 0 1
103691: PUSH
103692: FOR_IN
103693: IFFALSE 103717
// if IsControledBy ( i ) then
103695: LD_VAR 0 2
103699: PPUSH
103700: CALL_OW 312
103704: IFFALSE 103715
// ComUnlink ( i ) ;
103706: LD_VAR 0 2
103710: PPUSH
103711: CALL_OW 136
103715: GO 103692
103717: POP
103718: POP
// end ;
103719: PPOPN 2
103721: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103722: LD_EXP 95
103726: PUSH
103727: LD_EXP 126
103731: AND
103732: IFFALSE 103872
103734: GO 103736
103736: DISABLE
103737: LD_INT 0
103739: PPUSH
103740: PPUSH
// begin ToLua ( displayPowell(); ) ;
103741: LD_STRING displayPowell();
103743: PPUSH
103744: CALL_OW 559
// uc_side := 0 ;
103748: LD_ADDR_OWVAR 20
103752: PUSH
103753: LD_INT 0
103755: ST_TO_ADDR
// uc_nation := 2 ;
103756: LD_ADDR_OWVAR 21
103760: PUSH
103761: LD_INT 2
103763: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103764: LD_ADDR_OWVAR 37
103768: PUSH
103769: LD_INT 14
103771: ST_TO_ADDR
// vc_engine := engine_siberite ;
103772: LD_ADDR_OWVAR 39
103776: PUSH
103777: LD_INT 3
103779: ST_TO_ADDR
// vc_control := control_apeman ;
103780: LD_ADDR_OWVAR 38
103784: PUSH
103785: LD_INT 5
103787: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103788: LD_ADDR_OWVAR 40
103792: PUSH
103793: LD_INT 29
103795: ST_TO_ADDR
// un := CreateVehicle ;
103796: LD_ADDR_VAR 0 2
103800: PUSH
103801: CALL_OW 45
103805: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103806: LD_VAR 0 2
103810: PPUSH
103811: LD_INT 1
103813: PPUSH
103814: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103818: LD_INT 35
103820: PPUSH
103821: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103825: LD_VAR 0 2
103829: PPUSH
103830: LD_INT 22
103832: PUSH
103833: LD_OWVAR 2
103837: PUSH
103838: EMPTY
103839: LIST
103840: LIST
103841: PPUSH
103842: CALL_OW 69
103846: PPUSH
103847: LD_VAR 0 2
103851: PPUSH
103852: CALL_OW 74
103856: PPUSH
103857: CALL_OW 115
// until IsDead ( un ) ;
103861: LD_VAR 0 2
103865: PPUSH
103866: CALL_OW 301
103870: IFFALSE 103818
// end ;
103872: PPOPN 2
103874: END
// every 0 0$1 trigger StreamModeActive and sStu do
103875: LD_EXP 95
103879: PUSH
103880: LD_EXP 134
103884: AND
103885: IFFALSE 103901
103887: GO 103889
103889: DISABLE
// begin ToLua ( displayStucuk(); ) ;
103890: LD_STRING displayStucuk();
103892: PPUSH
103893: CALL_OW 559
// ResetFog ;
103897: CALL_OW 335
// end ;
103901: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
103902: LD_EXP 95
103906: PUSH
103907: LD_EXP 127
103911: AND
103912: IFFALSE 104053
103914: GO 103916
103916: DISABLE
103917: LD_INT 0
103919: PPUSH
103920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
103921: LD_ADDR_VAR 0 2
103925: PUSH
103926: LD_INT 22
103928: PUSH
103929: LD_OWVAR 2
103933: PUSH
103934: EMPTY
103935: LIST
103936: LIST
103937: PUSH
103938: LD_INT 21
103940: PUSH
103941: LD_INT 1
103943: PUSH
103944: EMPTY
103945: LIST
103946: LIST
103947: PUSH
103948: EMPTY
103949: LIST
103950: LIST
103951: PPUSH
103952: CALL_OW 69
103956: ST_TO_ADDR
// if not tmp then
103957: LD_VAR 0 2
103961: NOT
103962: IFFALSE 103966
// exit ;
103964: GO 104053
// un := tmp [ rand ( 1 , tmp ) ] ;
103966: LD_ADDR_VAR 0 1
103970: PUSH
103971: LD_VAR 0 2
103975: PUSH
103976: LD_INT 1
103978: PPUSH
103979: LD_VAR 0 2
103983: PPUSH
103984: CALL_OW 12
103988: ARRAY
103989: ST_TO_ADDR
// SetSide ( un , 0 ) ;
103990: LD_VAR 0 1
103994: PPUSH
103995: LD_INT 0
103997: PPUSH
103998: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
104002: LD_VAR 0 1
104006: PPUSH
104007: LD_OWVAR 3
104011: PUSH
104012: LD_VAR 0 1
104016: DIFF
104017: PPUSH
104018: LD_VAR 0 1
104022: PPUSH
104023: CALL_OW 74
104027: PPUSH
104028: CALL_OW 115
// wait ( 0 0$20 ) ;
104032: LD_INT 700
104034: PPUSH
104035: CALL_OW 67
// SetSide ( un , your_side ) ;
104039: LD_VAR 0 1
104043: PPUSH
104044: LD_OWVAR 2
104048: PPUSH
104049: CALL_OW 235
// end ;
104053: PPOPN 2
104055: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104056: LD_EXP 95
104060: PUSH
104061: LD_EXP 128
104065: AND
104066: IFFALSE 104172
104068: GO 104070
104070: DISABLE
104071: LD_INT 0
104073: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104074: LD_ADDR_VAR 0 1
104078: PUSH
104079: LD_INT 22
104081: PUSH
104082: LD_OWVAR 2
104086: PUSH
104087: EMPTY
104088: LIST
104089: LIST
104090: PUSH
104091: LD_INT 2
104093: PUSH
104094: LD_INT 30
104096: PUSH
104097: LD_INT 0
104099: PUSH
104100: EMPTY
104101: LIST
104102: LIST
104103: PUSH
104104: LD_INT 30
104106: PUSH
104107: LD_INT 1
104109: PUSH
104110: EMPTY
104111: LIST
104112: LIST
104113: PUSH
104114: EMPTY
104115: LIST
104116: LIST
104117: LIST
104118: PUSH
104119: EMPTY
104120: LIST
104121: LIST
104122: PPUSH
104123: CALL_OW 69
104127: ST_TO_ADDR
// if not depot then
104128: LD_VAR 0 1
104132: NOT
104133: IFFALSE 104137
// exit ;
104135: GO 104172
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104137: LD_VAR 0 1
104141: PUSH
104142: LD_INT 1
104144: ARRAY
104145: PPUSH
104146: CALL_OW 250
104150: PPUSH
104151: LD_VAR 0 1
104155: PUSH
104156: LD_INT 1
104158: ARRAY
104159: PPUSH
104160: CALL_OW 251
104164: PPUSH
104165: LD_INT 70
104167: PPUSH
104168: CALL_OW 495
// end ;
104172: PPOPN 1
104174: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104175: LD_EXP 95
104179: PUSH
104180: LD_EXP 129
104184: AND
104185: IFFALSE 104396
104187: GO 104189
104189: DISABLE
104190: LD_INT 0
104192: PPUSH
104193: PPUSH
104194: PPUSH
104195: PPUSH
104196: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104197: LD_ADDR_VAR 0 5
104201: PUSH
104202: LD_INT 22
104204: PUSH
104205: LD_OWVAR 2
104209: PUSH
104210: EMPTY
104211: LIST
104212: LIST
104213: PUSH
104214: LD_INT 21
104216: PUSH
104217: LD_INT 1
104219: PUSH
104220: EMPTY
104221: LIST
104222: LIST
104223: PUSH
104224: EMPTY
104225: LIST
104226: LIST
104227: PPUSH
104228: CALL_OW 69
104232: ST_TO_ADDR
// if not tmp then
104233: LD_VAR 0 5
104237: NOT
104238: IFFALSE 104242
// exit ;
104240: GO 104396
// for i in tmp do
104242: LD_ADDR_VAR 0 1
104246: PUSH
104247: LD_VAR 0 5
104251: PUSH
104252: FOR_IN
104253: IFFALSE 104394
// begin d := rand ( 0 , 5 ) ;
104255: LD_ADDR_VAR 0 4
104259: PUSH
104260: LD_INT 0
104262: PPUSH
104263: LD_INT 5
104265: PPUSH
104266: CALL_OW 12
104270: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104271: LD_ADDR_VAR 0 2
104275: PUSH
104276: LD_VAR 0 1
104280: PPUSH
104281: CALL_OW 250
104285: PPUSH
104286: LD_VAR 0 4
104290: PPUSH
104291: LD_INT 3
104293: PPUSH
104294: LD_INT 12
104296: PPUSH
104297: CALL_OW 12
104301: PPUSH
104302: CALL_OW 272
104306: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104307: LD_ADDR_VAR 0 3
104311: PUSH
104312: LD_VAR 0 1
104316: PPUSH
104317: CALL_OW 251
104321: PPUSH
104322: LD_VAR 0 4
104326: PPUSH
104327: LD_INT 3
104329: PPUSH
104330: LD_INT 12
104332: PPUSH
104333: CALL_OW 12
104337: PPUSH
104338: CALL_OW 273
104342: ST_TO_ADDR
// if ValidHex ( x , y ) then
104343: LD_VAR 0 2
104347: PPUSH
104348: LD_VAR 0 3
104352: PPUSH
104353: CALL_OW 488
104357: IFFALSE 104392
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104359: LD_VAR 0 1
104363: PPUSH
104364: LD_VAR 0 2
104368: PPUSH
104369: LD_VAR 0 3
104373: PPUSH
104374: LD_INT 3
104376: PPUSH
104377: LD_INT 6
104379: PPUSH
104380: CALL_OW 12
104384: PPUSH
104385: LD_INT 1
104387: PPUSH
104388: CALL_OW 483
// end ;
104392: GO 104252
104394: POP
104395: POP
// end ;
104396: PPOPN 5
104398: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104399: LD_EXP 95
104403: PUSH
104404: LD_EXP 130
104408: AND
104409: IFFALSE 104503
104411: GO 104413
104413: DISABLE
104414: LD_INT 0
104416: PPUSH
104417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104418: LD_ADDR_VAR 0 2
104422: PUSH
104423: LD_INT 22
104425: PUSH
104426: LD_OWVAR 2
104430: PUSH
104431: EMPTY
104432: LIST
104433: LIST
104434: PUSH
104435: LD_INT 32
104437: PUSH
104438: LD_INT 1
104440: PUSH
104441: EMPTY
104442: LIST
104443: LIST
104444: PUSH
104445: LD_INT 21
104447: PUSH
104448: LD_INT 2
104450: PUSH
104451: EMPTY
104452: LIST
104453: LIST
104454: PUSH
104455: EMPTY
104456: LIST
104457: LIST
104458: LIST
104459: PPUSH
104460: CALL_OW 69
104464: ST_TO_ADDR
// if not tmp then
104465: LD_VAR 0 2
104469: NOT
104470: IFFALSE 104474
// exit ;
104472: GO 104503
// for i in tmp do
104474: LD_ADDR_VAR 0 1
104478: PUSH
104479: LD_VAR 0 2
104483: PUSH
104484: FOR_IN
104485: IFFALSE 104501
// SetFuel ( i , 0 ) ;
104487: LD_VAR 0 1
104491: PPUSH
104492: LD_INT 0
104494: PPUSH
104495: CALL_OW 240
104499: GO 104484
104501: POP
104502: POP
// end ;
104503: PPOPN 2
104505: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104506: LD_EXP 95
104510: PUSH
104511: LD_EXP 131
104515: AND
104516: IFFALSE 104582
104518: GO 104520
104520: DISABLE
104521: LD_INT 0
104523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104524: LD_ADDR_VAR 0 1
104528: PUSH
104529: LD_INT 22
104531: PUSH
104532: LD_OWVAR 2
104536: PUSH
104537: EMPTY
104538: LIST
104539: LIST
104540: PUSH
104541: LD_INT 30
104543: PUSH
104544: LD_INT 29
104546: PUSH
104547: EMPTY
104548: LIST
104549: LIST
104550: PUSH
104551: EMPTY
104552: LIST
104553: LIST
104554: PPUSH
104555: CALL_OW 69
104559: ST_TO_ADDR
// if not tmp then
104560: LD_VAR 0 1
104564: NOT
104565: IFFALSE 104569
// exit ;
104567: GO 104582
// DestroyUnit ( tmp [ 1 ] ) ;
104569: LD_VAR 0 1
104573: PUSH
104574: LD_INT 1
104576: ARRAY
104577: PPUSH
104578: CALL_OW 65
// end ;
104582: PPOPN 1
104584: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104585: LD_EXP 95
104589: PUSH
104590: LD_EXP 133
104594: AND
104595: IFFALSE 104724
104597: GO 104599
104599: DISABLE
104600: LD_INT 0
104602: PPUSH
// begin uc_side := 0 ;
104603: LD_ADDR_OWVAR 20
104607: PUSH
104608: LD_INT 0
104610: ST_TO_ADDR
// uc_nation := nation_arabian ;
104611: LD_ADDR_OWVAR 21
104615: PUSH
104616: LD_INT 2
104618: ST_TO_ADDR
// hc_gallery :=  ;
104619: LD_ADDR_OWVAR 33
104623: PUSH
104624: LD_STRING 
104626: ST_TO_ADDR
// hc_name :=  ;
104627: LD_ADDR_OWVAR 26
104631: PUSH
104632: LD_STRING 
104634: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104635: LD_INT 1
104637: PPUSH
104638: LD_INT 11
104640: PPUSH
104641: LD_INT 10
104643: PPUSH
104644: CALL_OW 380
// un := CreateHuman ;
104648: LD_ADDR_VAR 0 1
104652: PUSH
104653: CALL_OW 44
104657: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104658: LD_VAR 0 1
104662: PPUSH
104663: LD_INT 1
104665: PPUSH
104666: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104670: LD_INT 35
104672: PPUSH
104673: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104677: LD_VAR 0 1
104681: PPUSH
104682: LD_INT 22
104684: PUSH
104685: LD_OWVAR 2
104689: PUSH
104690: EMPTY
104691: LIST
104692: LIST
104693: PPUSH
104694: CALL_OW 69
104698: PPUSH
104699: LD_VAR 0 1
104703: PPUSH
104704: CALL_OW 74
104708: PPUSH
104709: CALL_OW 115
// until IsDead ( un ) ;
104713: LD_VAR 0 1
104717: PPUSH
104718: CALL_OW 301
104722: IFFALSE 104670
// end ;
104724: PPOPN 1
104726: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104727: LD_EXP 95
104731: PUSH
104732: LD_EXP 135
104736: AND
104737: IFFALSE 104749
104739: GO 104741
104741: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104742: LD_STRING earthquake(getX(game), 0, 32)
104744: PPUSH
104745: CALL_OW 559
104749: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104750: LD_EXP 95
104754: PUSH
104755: LD_EXP 136
104759: AND
104760: IFFALSE 104851
104762: GO 104764
104764: DISABLE
104765: LD_INT 0
104767: PPUSH
// begin enable ;
104768: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104769: LD_ADDR_VAR 0 1
104773: PUSH
104774: LD_INT 22
104776: PUSH
104777: LD_OWVAR 2
104781: PUSH
104782: EMPTY
104783: LIST
104784: LIST
104785: PUSH
104786: LD_INT 21
104788: PUSH
104789: LD_INT 2
104791: PUSH
104792: EMPTY
104793: LIST
104794: LIST
104795: PUSH
104796: LD_INT 33
104798: PUSH
104799: LD_INT 3
104801: PUSH
104802: EMPTY
104803: LIST
104804: LIST
104805: PUSH
104806: EMPTY
104807: LIST
104808: LIST
104809: LIST
104810: PPUSH
104811: CALL_OW 69
104815: ST_TO_ADDR
// if not tmp then
104816: LD_VAR 0 1
104820: NOT
104821: IFFALSE 104825
// exit ;
104823: GO 104851
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104825: LD_VAR 0 1
104829: PUSH
104830: LD_INT 1
104832: PPUSH
104833: LD_VAR 0 1
104837: PPUSH
104838: CALL_OW 12
104842: ARRAY
104843: PPUSH
104844: LD_INT 1
104846: PPUSH
104847: CALL_OW 234
// end ;
104851: PPOPN 1
104853: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
104854: LD_EXP 95
104858: PUSH
104859: LD_EXP 137
104863: AND
104864: IFFALSE 105005
104866: GO 104868
104868: DISABLE
104869: LD_INT 0
104871: PPUSH
104872: PPUSH
104873: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
104874: LD_ADDR_VAR 0 3
104878: PUSH
104879: LD_INT 22
104881: PUSH
104882: LD_OWVAR 2
104886: PUSH
104887: EMPTY
104888: LIST
104889: LIST
104890: PUSH
104891: LD_INT 25
104893: PUSH
104894: LD_INT 1
104896: PUSH
104897: EMPTY
104898: LIST
104899: LIST
104900: PUSH
104901: EMPTY
104902: LIST
104903: LIST
104904: PPUSH
104905: CALL_OW 69
104909: ST_TO_ADDR
// if not tmp then
104910: LD_VAR 0 3
104914: NOT
104915: IFFALSE 104919
// exit ;
104917: GO 105005
// un := tmp [ rand ( 1 , tmp ) ] ;
104919: LD_ADDR_VAR 0 2
104923: PUSH
104924: LD_VAR 0 3
104928: PUSH
104929: LD_INT 1
104931: PPUSH
104932: LD_VAR 0 3
104936: PPUSH
104937: CALL_OW 12
104941: ARRAY
104942: ST_TO_ADDR
// if Crawls ( un ) then
104943: LD_VAR 0 2
104947: PPUSH
104948: CALL_OW 318
104952: IFFALSE 104963
// ComWalk ( un ) ;
104954: LD_VAR 0 2
104958: PPUSH
104959: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
104963: LD_VAR 0 2
104967: PPUSH
104968: LD_INT 9
104970: PPUSH
104971: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
104975: LD_INT 28
104977: PPUSH
104978: LD_OWVAR 2
104982: PPUSH
104983: LD_INT 2
104985: PPUSH
104986: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
104990: LD_INT 29
104992: PPUSH
104993: LD_OWVAR 2
104997: PPUSH
104998: LD_INT 2
105000: PPUSH
105001: CALL_OW 322
// end ;
105005: PPOPN 3
105007: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105008: LD_EXP 95
105012: PUSH
105013: LD_EXP 138
105017: AND
105018: IFFALSE 105129
105020: GO 105022
105022: DISABLE
105023: LD_INT 0
105025: PPUSH
105026: PPUSH
105027: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105028: LD_ADDR_VAR 0 3
105032: PUSH
105033: LD_INT 22
105035: PUSH
105036: LD_OWVAR 2
105040: PUSH
105041: EMPTY
105042: LIST
105043: LIST
105044: PUSH
105045: LD_INT 25
105047: PUSH
105048: LD_INT 1
105050: PUSH
105051: EMPTY
105052: LIST
105053: LIST
105054: PUSH
105055: EMPTY
105056: LIST
105057: LIST
105058: PPUSH
105059: CALL_OW 69
105063: ST_TO_ADDR
// if not tmp then
105064: LD_VAR 0 3
105068: NOT
105069: IFFALSE 105073
// exit ;
105071: GO 105129
// un := tmp [ rand ( 1 , tmp ) ] ;
105073: LD_ADDR_VAR 0 2
105077: PUSH
105078: LD_VAR 0 3
105082: PUSH
105083: LD_INT 1
105085: PPUSH
105086: LD_VAR 0 3
105090: PPUSH
105091: CALL_OW 12
105095: ARRAY
105096: ST_TO_ADDR
// if Crawls ( un ) then
105097: LD_VAR 0 2
105101: PPUSH
105102: CALL_OW 318
105106: IFFALSE 105117
// ComWalk ( un ) ;
105108: LD_VAR 0 2
105112: PPUSH
105113: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105117: LD_VAR 0 2
105121: PPUSH
105122: LD_INT 8
105124: PPUSH
105125: CALL_OW 336
// end ;
105129: PPOPN 3
105131: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105132: LD_EXP 95
105136: PUSH
105137: LD_EXP 139
105141: AND
105142: IFFALSE 105286
105144: GO 105146
105146: DISABLE
105147: LD_INT 0
105149: PPUSH
105150: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105151: LD_ADDR_VAR 0 2
105155: PUSH
105156: LD_INT 22
105158: PUSH
105159: LD_OWVAR 2
105163: PUSH
105164: EMPTY
105165: LIST
105166: LIST
105167: PUSH
105168: LD_INT 21
105170: PUSH
105171: LD_INT 2
105173: PUSH
105174: EMPTY
105175: LIST
105176: LIST
105177: PUSH
105178: LD_INT 2
105180: PUSH
105181: LD_INT 34
105183: PUSH
105184: LD_INT 12
105186: PUSH
105187: EMPTY
105188: LIST
105189: LIST
105190: PUSH
105191: LD_INT 34
105193: PUSH
105194: LD_INT 51
105196: PUSH
105197: EMPTY
105198: LIST
105199: LIST
105200: PUSH
105201: LD_INT 34
105203: PUSH
105204: LD_INT 32
105206: PUSH
105207: EMPTY
105208: LIST
105209: LIST
105210: PUSH
105211: EMPTY
105212: LIST
105213: LIST
105214: LIST
105215: LIST
105216: PUSH
105217: EMPTY
105218: LIST
105219: LIST
105220: LIST
105221: PPUSH
105222: CALL_OW 69
105226: ST_TO_ADDR
// if not tmp then
105227: LD_VAR 0 2
105231: NOT
105232: IFFALSE 105236
// exit ;
105234: GO 105286
// for i in tmp do
105236: LD_ADDR_VAR 0 1
105240: PUSH
105241: LD_VAR 0 2
105245: PUSH
105246: FOR_IN
105247: IFFALSE 105284
// if GetCargo ( i , mat_artifact ) = 0 then
105249: LD_VAR 0 1
105253: PPUSH
105254: LD_INT 4
105256: PPUSH
105257: CALL_OW 289
105261: PUSH
105262: LD_INT 0
105264: EQUAL
105265: IFFALSE 105282
// SetCargo ( i , mat_siberit , 100 ) ;
105267: LD_VAR 0 1
105271: PPUSH
105272: LD_INT 3
105274: PPUSH
105275: LD_INT 100
105277: PPUSH
105278: CALL_OW 290
105282: GO 105246
105284: POP
105285: POP
// end ;
105286: PPOPN 2
105288: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105289: LD_EXP 95
105293: PUSH
105294: LD_EXP 140
105298: AND
105299: IFFALSE 105482
105301: GO 105303
105303: DISABLE
105304: LD_INT 0
105306: PPUSH
105307: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105308: LD_ADDR_VAR 0 2
105312: PUSH
105313: LD_INT 22
105315: PUSH
105316: LD_OWVAR 2
105320: PUSH
105321: EMPTY
105322: LIST
105323: LIST
105324: PPUSH
105325: CALL_OW 69
105329: ST_TO_ADDR
// if not tmp then
105330: LD_VAR 0 2
105334: NOT
105335: IFFALSE 105339
// exit ;
105337: GO 105482
// for i := 1 to 2 do
105339: LD_ADDR_VAR 0 1
105343: PUSH
105344: DOUBLE
105345: LD_INT 1
105347: DEC
105348: ST_TO_ADDR
105349: LD_INT 2
105351: PUSH
105352: FOR_TO
105353: IFFALSE 105480
// begin uc_side := your_side ;
105355: LD_ADDR_OWVAR 20
105359: PUSH
105360: LD_OWVAR 2
105364: ST_TO_ADDR
// uc_nation := nation_american ;
105365: LD_ADDR_OWVAR 21
105369: PUSH
105370: LD_INT 1
105372: ST_TO_ADDR
// vc_chassis := us_morphling ;
105373: LD_ADDR_OWVAR 37
105377: PUSH
105378: LD_INT 5
105380: ST_TO_ADDR
// vc_engine := engine_siberite ;
105381: LD_ADDR_OWVAR 39
105385: PUSH
105386: LD_INT 3
105388: ST_TO_ADDR
// vc_control := control_computer ;
105389: LD_ADDR_OWVAR 38
105393: PUSH
105394: LD_INT 3
105396: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105397: LD_ADDR_OWVAR 40
105401: PUSH
105402: LD_INT 10
105404: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105405: LD_VAR 0 2
105409: PUSH
105410: LD_INT 1
105412: ARRAY
105413: PPUSH
105414: CALL_OW 310
105418: NOT
105419: IFFALSE 105466
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105421: CALL_OW 45
105425: PPUSH
105426: LD_VAR 0 2
105430: PUSH
105431: LD_INT 1
105433: ARRAY
105434: PPUSH
105435: CALL_OW 250
105439: PPUSH
105440: LD_VAR 0 2
105444: PUSH
105445: LD_INT 1
105447: ARRAY
105448: PPUSH
105449: CALL_OW 251
105453: PPUSH
105454: LD_INT 12
105456: PPUSH
105457: LD_INT 1
105459: PPUSH
105460: CALL_OW 50
105464: GO 105478
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105466: CALL_OW 45
105470: PPUSH
105471: LD_INT 1
105473: PPUSH
105474: CALL_OW 51
// end ;
105478: GO 105352
105480: POP
105481: POP
// end ;
105482: PPOPN 2
105484: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105485: LD_EXP 95
105489: PUSH
105490: LD_EXP 141
105494: AND
105495: IFFALSE 105717
105497: GO 105499
105499: DISABLE
105500: LD_INT 0
105502: PPUSH
105503: PPUSH
105504: PPUSH
105505: PPUSH
105506: PPUSH
105507: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105508: LD_ADDR_VAR 0 6
105512: PUSH
105513: LD_INT 22
105515: PUSH
105516: LD_OWVAR 2
105520: PUSH
105521: EMPTY
105522: LIST
105523: LIST
105524: PUSH
105525: LD_INT 21
105527: PUSH
105528: LD_INT 1
105530: PUSH
105531: EMPTY
105532: LIST
105533: LIST
105534: PUSH
105535: LD_INT 3
105537: PUSH
105538: LD_INT 23
105540: PUSH
105541: LD_INT 0
105543: PUSH
105544: EMPTY
105545: LIST
105546: LIST
105547: PUSH
105548: EMPTY
105549: LIST
105550: LIST
105551: PUSH
105552: EMPTY
105553: LIST
105554: LIST
105555: LIST
105556: PPUSH
105557: CALL_OW 69
105561: ST_TO_ADDR
// if not tmp then
105562: LD_VAR 0 6
105566: NOT
105567: IFFALSE 105571
// exit ;
105569: GO 105717
// s1 := rand ( 1 , 4 ) ;
105571: LD_ADDR_VAR 0 2
105575: PUSH
105576: LD_INT 1
105578: PPUSH
105579: LD_INT 4
105581: PPUSH
105582: CALL_OW 12
105586: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105587: LD_ADDR_VAR 0 4
105591: PUSH
105592: LD_VAR 0 6
105596: PUSH
105597: LD_INT 1
105599: ARRAY
105600: PPUSH
105601: LD_VAR 0 2
105605: PPUSH
105606: CALL_OW 259
105610: ST_TO_ADDR
// if s1 = 1 then
105611: LD_VAR 0 2
105615: PUSH
105616: LD_INT 1
105618: EQUAL
105619: IFFALSE 105639
// s2 := rand ( 2 , 4 ) else
105621: LD_ADDR_VAR 0 3
105625: PUSH
105626: LD_INT 2
105628: PPUSH
105629: LD_INT 4
105631: PPUSH
105632: CALL_OW 12
105636: ST_TO_ADDR
105637: GO 105647
// s2 := 1 ;
105639: LD_ADDR_VAR 0 3
105643: PUSH
105644: LD_INT 1
105646: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105647: LD_ADDR_VAR 0 5
105651: PUSH
105652: LD_VAR 0 6
105656: PUSH
105657: LD_INT 1
105659: ARRAY
105660: PPUSH
105661: LD_VAR 0 3
105665: PPUSH
105666: CALL_OW 259
105670: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105671: LD_VAR 0 6
105675: PUSH
105676: LD_INT 1
105678: ARRAY
105679: PPUSH
105680: LD_VAR 0 2
105684: PPUSH
105685: LD_VAR 0 5
105689: PPUSH
105690: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105694: LD_VAR 0 6
105698: PUSH
105699: LD_INT 1
105701: ARRAY
105702: PPUSH
105703: LD_VAR 0 3
105707: PPUSH
105708: LD_VAR 0 4
105712: PPUSH
105713: CALL_OW 237
// end ;
105717: PPOPN 6
105719: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105720: LD_EXP 95
105724: PUSH
105725: LD_EXP 142
105729: AND
105730: IFFALSE 105809
105732: GO 105734
105734: DISABLE
105735: LD_INT 0
105737: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105738: LD_ADDR_VAR 0 1
105742: PUSH
105743: LD_INT 22
105745: PUSH
105746: LD_OWVAR 2
105750: PUSH
105751: EMPTY
105752: LIST
105753: LIST
105754: PUSH
105755: LD_INT 30
105757: PUSH
105758: LD_INT 3
105760: PUSH
105761: EMPTY
105762: LIST
105763: LIST
105764: PUSH
105765: EMPTY
105766: LIST
105767: LIST
105768: PPUSH
105769: CALL_OW 69
105773: ST_TO_ADDR
// if not tmp then
105774: LD_VAR 0 1
105778: NOT
105779: IFFALSE 105783
// exit ;
105781: GO 105809
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105783: LD_VAR 0 1
105787: PUSH
105788: LD_INT 1
105790: PPUSH
105791: LD_VAR 0 1
105795: PPUSH
105796: CALL_OW 12
105800: ARRAY
105801: PPUSH
105802: LD_INT 1
105804: PPUSH
105805: CALL_OW 234
// end ;
105809: PPOPN 1
105811: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105812: LD_EXP 95
105816: PUSH
105817: LD_EXP 143
105821: AND
105822: IFFALSE 105934
105824: GO 105826
105826: DISABLE
105827: LD_INT 0
105829: PPUSH
105830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105831: LD_ADDR_VAR 0 2
105835: PUSH
105836: LD_INT 22
105838: PUSH
105839: LD_OWVAR 2
105843: PUSH
105844: EMPTY
105845: LIST
105846: LIST
105847: PUSH
105848: LD_INT 2
105850: PUSH
105851: LD_INT 30
105853: PUSH
105854: LD_INT 27
105856: PUSH
105857: EMPTY
105858: LIST
105859: LIST
105860: PUSH
105861: LD_INT 30
105863: PUSH
105864: LD_INT 26
105866: PUSH
105867: EMPTY
105868: LIST
105869: LIST
105870: PUSH
105871: LD_INT 30
105873: PUSH
105874: LD_INT 28
105876: PUSH
105877: EMPTY
105878: LIST
105879: LIST
105880: PUSH
105881: EMPTY
105882: LIST
105883: LIST
105884: LIST
105885: LIST
105886: PUSH
105887: EMPTY
105888: LIST
105889: LIST
105890: PPUSH
105891: CALL_OW 69
105895: ST_TO_ADDR
// if not tmp then
105896: LD_VAR 0 2
105900: NOT
105901: IFFALSE 105905
// exit ;
105903: GO 105934
// for i in tmp do
105905: LD_ADDR_VAR 0 1
105909: PUSH
105910: LD_VAR 0 2
105914: PUSH
105915: FOR_IN
105916: IFFALSE 105932
// SetLives ( i , 1 ) ;
105918: LD_VAR 0 1
105922: PPUSH
105923: LD_INT 1
105925: PPUSH
105926: CALL_OW 234
105930: GO 105915
105932: POP
105933: POP
// end ;
105934: PPOPN 2
105936: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
105937: LD_EXP 95
105941: PUSH
105942: LD_EXP 144
105946: AND
105947: IFFALSE 106234
105949: GO 105951
105951: DISABLE
105952: LD_INT 0
105954: PPUSH
105955: PPUSH
105956: PPUSH
// begin i := rand ( 1 , 7 ) ;
105957: LD_ADDR_VAR 0 1
105961: PUSH
105962: LD_INT 1
105964: PPUSH
105965: LD_INT 7
105967: PPUSH
105968: CALL_OW 12
105972: ST_TO_ADDR
// case i of 1 :
105973: LD_VAR 0 1
105977: PUSH
105978: LD_INT 1
105980: DOUBLE
105981: EQUAL
105982: IFTRUE 105986
105984: GO 105996
105986: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
105987: LD_STRING earthquake(getX(game), 0, 32)
105989: PPUSH
105990: CALL_OW 559
105994: GO 106234
105996: LD_INT 2
105998: DOUBLE
105999: EQUAL
106000: IFTRUE 106004
106002: GO 106018
106004: POP
// begin ToLua ( displayStucuk(); ) ;
106005: LD_STRING displayStucuk();
106007: PPUSH
106008: CALL_OW 559
// ResetFog ;
106012: CALL_OW 335
// end ; 3 :
106016: GO 106234
106018: LD_INT 3
106020: DOUBLE
106021: EQUAL
106022: IFTRUE 106026
106024: GO 106130
106026: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106027: LD_ADDR_VAR 0 2
106031: PUSH
106032: LD_INT 22
106034: PUSH
106035: LD_OWVAR 2
106039: PUSH
106040: EMPTY
106041: LIST
106042: LIST
106043: PUSH
106044: LD_INT 25
106046: PUSH
106047: LD_INT 1
106049: PUSH
106050: EMPTY
106051: LIST
106052: LIST
106053: PUSH
106054: EMPTY
106055: LIST
106056: LIST
106057: PPUSH
106058: CALL_OW 69
106062: ST_TO_ADDR
// if not tmp then
106063: LD_VAR 0 2
106067: NOT
106068: IFFALSE 106072
// exit ;
106070: GO 106234
// un := tmp [ rand ( 1 , tmp ) ] ;
106072: LD_ADDR_VAR 0 3
106076: PUSH
106077: LD_VAR 0 2
106081: PUSH
106082: LD_INT 1
106084: PPUSH
106085: LD_VAR 0 2
106089: PPUSH
106090: CALL_OW 12
106094: ARRAY
106095: ST_TO_ADDR
// if Crawls ( un ) then
106096: LD_VAR 0 3
106100: PPUSH
106101: CALL_OW 318
106105: IFFALSE 106116
// ComWalk ( un ) ;
106107: LD_VAR 0 3
106111: PPUSH
106112: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106116: LD_VAR 0 3
106120: PPUSH
106121: LD_INT 8
106123: PPUSH
106124: CALL_OW 336
// end ; 4 :
106128: GO 106234
106130: LD_INT 4
106132: DOUBLE
106133: EQUAL
106134: IFTRUE 106138
106136: GO 106212
106138: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106139: LD_ADDR_VAR 0 2
106143: PUSH
106144: LD_INT 22
106146: PUSH
106147: LD_OWVAR 2
106151: PUSH
106152: EMPTY
106153: LIST
106154: LIST
106155: PUSH
106156: LD_INT 30
106158: PUSH
106159: LD_INT 29
106161: PUSH
106162: EMPTY
106163: LIST
106164: LIST
106165: PUSH
106166: EMPTY
106167: LIST
106168: LIST
106169: PPUSH
106170: CALL_OW 69
106174: ST_TO_ADDR
// if not tmp then
106175: LD_VAR 0 2
106179: NOT
106180: IFFALSE 106184
// exit ;
106182: GO 106234
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106184: LD_VAR 0 2
106188: PUSH
106189: LD_INT 1
106191: ARRAY
106192: PPUSH
106193: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106197: LD_VAR 0 2
106201: PUSH
106202: LD_INT 1
106204: ARRAY
106205: PPUSH
106206: CALL_OW 65
// end ; 5 .. 7 :
106210: GO 106234
106212: LD_INT 5
106214: DOUBLE
106215: GREATEREQUAL
106216: IFFALSE 106224
106218: LD_INT 7
106220: DOUBLE
106221: LESSEQUAL
106222: IFTRUE 106226
106224: GO 106233
106226: POP
// StreamSibBomb ; end ;
106227: CALL 102471 0 0
106231: GO 106234
106233: POP
// end ;
106234: PPOPN 3
106236: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106237: LD_EXP 95
106241: PUSH
106242: LD_EXP 145
106246: AND
106247: IFFALSE 106403
106249: GO 106251
106251: DISABLE
106252: LD_INT 0
106254: PPUSH
106255: PPUSH
106256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106257: LD_ADDR_VAR 0 2
106261: PUSH
106262: LD_INT 81
106264: PUSH
106265: LD_OWVAR 2
106269: PUSH
106270: EMPTY
106271: LIST
106272: LIST
106273: PUSH
106274: LD_INT 2
106276: PUSH
106277: LD_INT 21
106279: PUSH
106280: LD_INT 1
106282: PUSH
106283: EMPTY
106284: LIST
106285: LIST
106286: PUSH
106287: LD_INT 21
106289: PUSH
106290: LD_INT 2
106292: PUSH
106293: EMPTY
106294: LIST
106295: LIST
106296: PUSH
106297: EMPTY
106298: LIST
106299: LIST
106300: LIST
106301: PUSH
106302: EMPTY
106303: LIST
106304: LIST
106305: PPUSH
106306: CALL_OW 69
106310: ST_TO_ADDR
// if not tmp then
106311: LD_VAR 0 2
106315: NOT
106316: IFFALSE 106320
// exit ;
106318: GO 106403
// p := 0 ;
106320: LD_ADDR_VAR 0 3
106324: PUSH
106325: LD_INT 0
106327: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106328: LD_INT 35
106330: PPUSH
106331: CALL_OW 67
// p := p + 1 ;
106335: LD_ADDR_VAR 0 3
106339: PUSH
106340: LD_VAR 0 3
106344: PUSH
106345: LD_INT 1
106347: PLUS
106348: ST_TO_ADDR
// for i in tmp do
106349: LD_ADDR_VAR 0 1
106353: PUSH
106354: LD_VAR 0 2
106358: PUSH
106359: FOR_IN
106360: IFFALSE 106391
// if GetLives ( i ) < 1000 then
106362: LD_VAR 0 1
106366: PPUSH
106367: CALL_OW 256
106371: PUSH
106372: LD_INT 1000
106374: LESS
106375: IFFALSE 106389
// SetLives ( i , 1000 ) ;
106377: LD_VAR 0 1
106381: PPUSH
106382: LD_INT 1000
106384: PPUSH
106385: CALL_OW 234
106389: GO 106359
106391: POP
106392: POP
// until p > 20 ;
106393: LD_VAR 0 3
106397: PUSH
106398: LD_INT 20
106400: GREATER
106401: IFFALSE 106328
// end ;
106403: PPOPN 3
106405: END
// every 0 0$1 trigger StreamModeActive and sTime do
106406: LD_EXP 95
106410: PUSH
106411: LD_EXP 146
106415: AND
106416: IFFALSE 106451
106418: GO 106420
106420: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106421: LD_INT 28
106423: PPUSH
106424: LD_OWVAR 2
106428: PPUSH
106429: LD_INT 2
106431: PPUSH
106432: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106436: LD_INT 30
106438: PPUSH
106439: LD_OWVAR 2
106443: PPUSH
106444: LD_INT 2
106446: PPUSH
106447: CALL_OW 322
// end ;
106451: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106452: LD_EXP 95
106456: PUSH
106457: LD_EXP 147
106461: AND
106462: IFFALSE 106583
106464: GO 106466
106466: DISABLE
106467: LD_INT 0
106469: PPUSH
106470: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106471: LD_ADDR_VAR 0 2
106475: PUSH
106476: LD_INT 22
106478: PUSH
106479: LD_OWVAR 2
106483: PUSH
106484: EMPTY
106485: LIST
106486: LIST
106487: PUSH
106488: LD_INT 21
106490: PUSH
106491: LD_INT 1
106493: PUSH
106494: EMPTY
106495: LIST
106496: LIST
106497: PUSH
106498: LD_INT 3
106500: PUSH
106501: LD_INT 23
106503: PUSH
106504: LD_INT 0
106506: PUSH
106507: EMPTY
106508: LIST
106509: LIST
106510: PUSH
106511: EMPTY
106512: LIST
106513: LIST
106514: PUSH
106515: EMPTY
106516: LIST
106517: LIST
106518: LIST
106519: PPUSH
106520: CALL_OW 69
106524: ST_TO_ADDR
// if not tmp then
106525: LD_VAR 0 2
106529: NOT
106530: IFFALSE 106534
// exit ;
106532: GO 106583
// for i in tmp do
106534: LD_ADDR_VAR 0 1
106538: PUSH
106539: LD_VAR 0 2
106543: PUSH
106544: FOR_IN
106545: IFFALSE 106581
// begin if Crawls ( i ) then
106547: LD_VAR 0 1
106551: PPUSH
106552: CALL_OW 318
106556: IFFALSE 106567
// ComWalk ( i ) ;
106558: LD_VAR 0 1
106562: PPUSH
106563: CALL_OW 138
// SetClass ( i , 2 ) ;
106567: LD_VAR 0 1
106571: PPUSH
106572: LD_INT 2
106574: PPUSH
106575: CALL_OW 336
// end ;
106579: GO 106544
106581: POP
106582: POP
// end ;
106583: PPOPN 2
106585: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106586: LD_EXP 95
106590: PUSH
106591: LD_EXP 148
106595: AND
106596: IFFALSE 106884
106598: GO 106600
106600: DISABLE
106601: LD_INT 0
106603: PPUSH
106604: PPUSH
106605: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106606: LD_OWVAR 2
106610: PPUSH
106611: LD_INT 9
106613: PPUSH
106614: LD_INT 1
106616: PPUSH
106617: LD_INT 1
106619: PPUSH
106620: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106624: LD_INT 9
106626: PPUSH
106627: LD_OWVAR 2
106631: PPUSH
106632: CALL_OW 343
// uc_side := 9 ;
106636: LD_ADDR_OWVAR 20
106640: PUSH
106641: LD_INT 9
106643: ST_TO_ADDR
// uc_nation := 2 ;
106644: LD_ADDR_OWVAR 21
106648: PUSH
106649: LD_INT 2
106651: ST_TO_ADDR
// hc_name := Dark Warrior ;
106652: LD_ADDR_OWVAR 26
106656: PUSH
106657: LD_STRING Dark Warrior
106659: ST_TO_ADDR
// hc_gallery :=  ;
106660: LD_ADDR_OWVAR 33
106664: PUSH
106665: LD_STRING 
106667: ST_TO_ADDR
// hc_noskilllimit := true ;
106668: LD_ADDR_OWVAR 76
106672: PUSH
106673: LD_INT 1
106675: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106676: LD_ADDR_OWVAR 31
106680: PUSH
106681: LD_INT 30
106683: PUSH
106684: LD_INT 30
106686: PUSH
106687: LD_INT 30
106689: PUSH
106690: LD_INT 30
106692: PUSH
106693: EMPTY
106694: LIST
106695: LIST
106696: LIST
106697: LIST
106698: ST_TO_ADDR
// un := CreateHuman ;
106699: LD_ADDR_VAR 0 3
106703: PUSH
106704: CALL_OW 44
106708: ST_TO_ADDR
// hc_noskilllimit := false ;
106709: LD_ADDR_OWVAR 76
106713: PUSH
106714: LD_INT 0
106716: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106717: LD_VAR 0 3
106721: PPUSH
106722: LD_INT 1
106724: PPUSH
106725: CALL_OW 51
// ToLua ( playRanger() ) ;
106729: LD_STRING playRanger()
106731: PPUSH
106732: CALL_OW 559
// p := 0 ;
106736: LD_ADDR_VAR 0 2
106740: PUSH
106741: LD_INT 0
106743: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106744: LD_INT 35
106746: PPUSH
106747: CALL_OW 67
// p := p + 1 ;
106751: LD_ADDR_VAR 0 2
106755: PUSH
106756: LD_VAR 0 2
106760: PUSH
106761: LD_INT 1
106763: PLUS
106764: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106765: LD_VAR 0 3
106769: PPUSH
106770: CALL_OW 256
106774: PUSH
106775: LD_INT 1000
106777: LESS
106778: IFFALSE 106792
// SetLives ( un , 1000 ) ;
106780: LD_VAR 0 3
106784: PPUSH
106785: LD_INT 1000
106787: PPUSH
106788: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106792: LD_VAR 0 3
106796: PPUSH
106797: LD_INT 81
106799: PUSH
106800: LD_OWVAR 2
106804: PUSH
106805: EMPTY
106806: LIST
106807: LIST
106808: PUSH
106809: LD_INT 91
106811: PUSH
106812: LD_VAR 0 3
106816: PUSH
106817: LD_INT 30
106819: PUSH
106820: EMPTY
106821: LIST
106822: LIST
106823: LIST
106824: PUSH
106825: EMPTY
106826: LIST
106827: LIST
106828: PPUSH
106829: CALL_OW 69
106833: PPUSH
106834: LD_VAR 0 3
106838: PPUSH
106839: CALL_OW 74
106843: PPUSH
106844: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
106848: LD_VAR 0 2
106852: PUSH
106853: LD_INT 80
106855: GREATER
106856: PUSH
106857: LD_VAR 0 3
106861: PPUSH
106862: CALL_OW 301
106866: OR
106867: IFFALSE 106744
// if un then
106869: LD_VAR 0 3
106873: IFFALSE 106884
// RemoveUnit ( un ) ;
106875: LD_VAR 0 3
106879: PPUSH
106880: CALL_OW 64
// end ;
106884: PPOPN 3
106886: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
106887: LD_EXP 149
106891: IFFALSE 107007
106893: GO 106895
106895: DISABLE
106896: LD_INT 0
106898: PPUSH
106899: PPUSH
106900: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106901: LD_ADDR_VAR 0 2
106905: PUSH
106906: LD_INT 81
106908: PUSH
106909: LD_OWVAR 2
106913: PUSH
106914: EMPTY
106915: LIST
106916: LIST
106917: PUSH
106918: LD_INT 21
106920: PUSH
106921: LD_INT 1
106923: PUSH
106924: EMPTY
106925: LIST
106926: LIST
106927: PUSH
106928: EMPTY
106929: LIST
106930: LIST
106931: PPUSH
106932: CALL_OW 69
106936: ST_TO_ADDR
// ToLua ( playComputer() ) ;
106937: LD_STRING playComputer()
106939: PPUSH
106940: CALL_OW 559
// if not tmp then
106944: LD_VAR 0 2
106948: NOT
106949: IFFALSE 106953
// exit ;
106951: GO 107007
// for i in tmp do
106953: LD_ADDR_VAR 0 1
106957: PUSH
106958: LD_VAR 0 2
106962: PUSH
106963: FOR_IN
106964: IFFALSE 107005
// for j := 1 to 4 do
106966: LD_ADDR_VAR 0 3
106970: PUSH
106971: DOUBLE
106972: LD_INT 1
106974: DEC
106975: ST_TO_ADDR
106976: LD_INT 4
106978: PUSH
106979: FOR_TO
106980: IFFALSE 107001
// SetSkill ( i , j , 10 ) ;
106982: LD_VAR 0 1
106986: PPUSH
106987: LD_VAR 0 3
106991: PPUSH
106992: LD_INT 10
106994: PPUSH
106995: CALL_OW 237
106999: GO 106979
107001: POP
107002: POP
107003: GO 106963
107005: POP
107006: POP
// end ;
107007: PPOPN 3
107009: END
// every 0 0$1 trigger s30 do var i , tmp ;
107010: LD_EXP 150
107014: IFFALSE 107083
107016: GO 107018
107018: DISABLE
107019: LD_INT 0
107021: PPUSH
107022: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107023: LD_ADDR_VAR 0 2
107027: PUSH
107028: LD_INT 22
107030: PUSH
107031: LD_OWVAR 2
107035: PUSH
107036: EMPTY
107037: LIST
107038: LIST
107039: PPUSH
107040: CALL_OW 69
107044: ST_TO_ADDR
// if not tmp then
107045: LD_VAR 0 2
107049: NOT
107050: IFFALSE 107054
// exit ;
107052: GO 107083
// for i in tmp do
107054: LD_ADDR_VAR 0 1
107058: PUSH
107059: LD_VAR 0 2
107063: PUSH
107064: FOR_IN
107065: IFFALSE 107081
// SetLives ( i , 300 ) ;
107067: LD_VAR 0 1
107071: PPUSH
107072: LD_INT 300
107074: PPUSH
107075: CALL_OW 234
107079: GO 107064
107081: POP
107082: POP
// end ;
107083: PPOPN 2
107085: END
// every 0 0$1 trigger s60 do var i , tmp ;
107086: LD_EXP 151
107090: IFFALSE 107159
107092: GO 107094
107094: DISABLE
107095: LD_INT 0
107097: PPUSH
107098: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107099: LD_ADDR_VAR 0 2
107103: PUSH
107104: LD_INT 22
107106: PUSH
107107: LD_OWVAR 2
107111: PUSH
107112: EMPTY
107113: LIST
107114: LIST
107115: PPUSH
107116: CALL_OW 69
107120: ST_TO_ADDR
// if not tmp then
107121: LD_VAR 0 2
107125: NOT
107126: IFFALSE 107130
// exit ;
107128: GO 107159
// for i in tmp do
107130: LD_ADDR_VAR 0 1
107134: PUSH
107135: LD_VAR 0 2
107139: PUSH
107140: FOR_IN
107141: IFFALSE 107157
// SetLives ( i , 600 ) ;
107143: LD_VAR 0 1
107147: PPUSH
107148: LD_INT 600
107150: PPUSH
107151: CALL_OW 234
107155: GO 107140
107157: POP
107158: POP
// end ;
107159: PPOPN 2
107161: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107162: LD_INT 0
107164: PPUSH
// case cmd of 301 :
107165: LD_VAR 0 1
107169: PUSH
107170: LD_INT 301
107172: DOUBLE
107173: EQUAL
107174: IFTRUE 107178
107176: GO 107210
107178: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107179: LD_VAR 0 6
107183: PPUSH
107184: LD_VAR 0 7
107188: PPUSH
107189: LD_VAR 0 8
107193: PPUSH
107194: LD_VAR 0 4
107198: PPUSH
107199: LD_VAR 0 5
107203: PPUSH
107204: CALL 108411 0 5
107208: GO 107331
107210: LD_INT 302
107212: DOUBLE
107213: EQUAL
107214: IFTRUE 107218
107216: GO 107255
107218: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107219: LD_VAR 0 6
107223: PPUSH
107224: LD_VAR 0 7
107228: PPUSH
107229: LD_VAR 0 8
107233: PPUSH
107234: LD_VAR 0 9
107238: PPUSH
107239: LD_VAR 0 4
107243: PPUSH
107244: LD_VAR 0 5
107248: PPUSH
107249: CALL 108502 0 6
107253: GO 107331
107255: LD_INT 303
107257: DOUBLE
107258: EQUAL
107259: IFTRUE 107263
107261: GO 107300
107263: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107264: LD_VAR 0 6
107268: PPUSH
107269: LD_VAR 0 7
107273: PPUSH
107274: LD_VAR 0 8
107278: PPUSH
107279: LD_VAR 0 9
107283: PPUSH
107284: LD_VAR 0 4
107288: PPUSH
107289: LD_VAR 0 5
107293: PPUSH
107294: CALL 107336 0 6
107298: GO 107331
107300: LD_INT 304
107302: DOUBLE
107303: EQUAL
107304: IFTRUE 107308
107306: GO 107330
107308: POP
// hHackTeleport ( unit , x , y ) ; end ;
107309: LD_VAR 0 2
107313: PPUSH
107314: LD_VAR 0 4
107318: PPUSH
107319: LD_VAR 0 5
107323: PPUSH
107324: CALL 109095 0 3
107328: GO 107331
107330: POP
// end ;
107331: LD_VAR 0 12
107335: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107336: LD_INT 0
107338: PPUSH
107339: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107340: LD_VAR 0 1
107344: PUSH
107345: LD_INT 1
107347: LESS
107348: PUSH
107349: LD_VAR 0 1
107353: PUSH
107354: LD_INT 3
107356: GREATER
107357: OR
107358: PUSH
107359: LD_VAR 0 5
107363: PPUSH
107364: LD_VAR 0 6
107368: PPUSH
107369: CALL_OW 428
107373: OR
107374: IFFALSE 107378
// exit ;
107376: GO 108098
// uc_side := your_side ;
107378: LD_ADDR_OWVAR 20
107382: PUSH
107383: LD_OWVAR 2
107387: ST_TO_ADDR
// uc_nation := nation ;
107388: LD_ADDR_OWVAR 21
107392: PUSH
107393: LD_VAR 0 1
107397: ST_TO_ADDR
// bc_level = 1 ;
107398: LD_ADDR_OWVAR 43
107402: PUSH
107403: LD_INT 1
107405: ST_TO_ADDR
// case btype of 1 :
107406: LD_VAR 0 2
107410: PUSH
107411: LD_INT 1
107413: DOUBLE
107414: EQUAL
107415: IFTRUE 107419
107417: GO 107430
107419: POP
// bc_type := b_depot ; 2 :
107420: LD_ADDR_OWVAR 42
107424: PUSH
107425: LD_INT 0
107427: ST_TO_ADDR
107428: GO 108042
107430: LD_INT 2
107432: DOUBLE
107433: EQUAL
107434: IFTRUE 107438
107436: GO 107449
107438: POP
// bc_type := b_warehouse ; 3 :
107439: LD_ADDR_OWVAR 42
107443: PUSH
107444: LD_INT 1
107446: ST_TO_ADDR
107447: GO 108042
107449: LD_INT 3
107451: DOUBLE
107452: EQUAL
107453: IFTRUE 107457
107455: GO 107468
107457: POP
// bc_type := b_lab ; 4 .. 9 :
107458: LD_ADDR_OWVAR 42
107462: PUSH
107463: LD_INT 6
107465: ST_TO_ADDR
107466: GO 108042
107468: LD_INT 4
107470: DOUBLE
107471: GREATEREQUAL
107472: IFFALSE 107480
107474: LD_INT 9
107476: DOUBLE
107477: LESSEQUAL
107478: IFTRUE 107482
107480: GO 107534
107482: POP
// begin bc_type := b_lab_half ;
107483: LD_ADDR_OWVAR 42
107487: PUSH
107488: LD_INT 7
107490: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107491: LD_ADDR_OWVAR 44
107495: PUSH
107496: LD_INT 10
107498: PUSH
107499: LD_INT 11
107501: PUSH
107502: LD_INT 12
107504: PUSH
107505: LD_INT 15
107507: PUSH
107508: LD_INT 14
107510: PUSH
107511: LD_INT 13
107513: PUSH
107514: EMPTY
107515: LIST
107516: LIST
107517: LIST
107518: LIST
107519: LIST
107520: LIST
107521: PUSH
107522: LD_VAR 0 2
107526: PUSH
107527: LD_INT 3
107529: MINUS
107530: ARRAY
107531: ST_TO_ADDR
// end ; 10 .. 13 :
107532: GO 108042
107534: LD_INT 10
107536: DOUBLE
107537: GREATEREQUAL
107538: IFFALSE 107546
107540: LD_INT 13
107542: DOUBLE
107543: LESSEQUAL
107544: IFTRUE 107548
107546: GO 107625
107548: POP
// begin bc_type := b_lab_full ;
107549: LD_ADDR_OWVAR 42
107553: PUSH
107554: LD_INT 8
107556: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107557: LD_ADDR_OWVAR 44
107561: PUSH
107562: LD_INT 10
107564: PUSH
107565: LD_INT 12
107567: PUSH
107568: LD_INT 14
107570: PUSH
107571: LD_INT 13
107573: PUSH
107574: EMPTY
107575: LIST
107576: LIST
107577: LIST
107578: LIST
107579: PUSH
107580: LD_VAR 0 2
107584: PUSH
107585: LD_INT 9
107587: MINUS
107588: ARRAY
107589: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107590: LD_ADDR_OWVAR 45
107594: PUSH
107595: LD_INT 11
107597: PUSH
107598: LD_INT 15
107600: PUSH
107601: LD_INT 12
107603: PUSH
107604: LD_INT 15
107606: PUSH
107607: EMPTY
107608: LIST
107609: LIST
107610: LIST
107611: LIST
107612: PUSH
107613: LD_VAR 0 2
107617: PUSH
107618: LD_INT 9
107620: MINUS
107621: ARRAY
107622: ST_TO_ADDR
// end ; 14 :
107623: GO 108042
107625: LD_INT 14
107627: DOUBLE
107628: EQUAL
107629: IFTRUE 107633
107631: GO 107644
107633: POP
// bc_type := b_workshop ; 15 :
107634: LD_ADDR_OWVAR 42
107638: PUSH
107639: LD_INT 2
107641: ST_TO_ADDR
107642: GO 108042
107644: LD_INT 15
107646: DOUBLE
107647: EQUAL
107648: IFTRUE 107652
107650: GO 107663
107652: POP
// bc_type := b_factory ; 16 :
107653: LD_ADDR_OWVAR 42
107657: PUSH
107658: LD_INT 3
107660: ST_TO_ADDR
107661: GO 108042
107663: LD_INT 16
107665: DOUBLE
107666: EQUAL
107667: IFTRUE 107671
107669: GO 107682
107671: POP
// bc_type := b_ext_gun ; 17 :
107672: LD_ADDR_OWVAR 42
107676: PUSH
107677: LD_INT 17
107679: ST_TO_ADDR
107680: GO 108042
107682: LD_INT 17
107684: DOUBLE
107685: EQUAL
107686: IFTRUE 107690
107688: GO 107718
107690: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107691: LD_ADDR_OWVAR 42
107695: PUSH
107696: LD_INT 19
107698: PUSH
107699: LD_INT 23
107701: PUSH
107702: LD_INT 19
107704: PUSH
107705: EMPTY
107706: LIST
107707: LIST
107708: LIST
107709: PUSH
107710: LD_VAR 0 1
107714: ARRAY
107715: ST_TO_ADDR
107716: GO 108042
107718: LD_INT 18
107720: DOUBLE
107721: EQUAL
107722: IFTRUE 107726
107724: GO 107737
107726: POP
// bc_type := b_ext_radar ; 19 :
107727: LD_ADDR_OWVAR 42
107731: PUSH
107732: LD_INT 20
107734: ST_TO_ADDR
107735: GO 108042
107737: LD_INT 19
107739: DOUBLE
107740: EQUAL
107741: IFTRUE 107745
107743: GO 107756
107745: POP
// bc_type := b_ext_radio ; 20 :
107746: LD_ADDR_OWVAR 42
107750: PUSH
107751: LD_INT 22
107753: ST_TO_ADDR
107754: GO 108042
107756: LD_INT 20
107758: DOUBLE
107759: EQUAL
107760: IFTRUE 107764
107762: GO 107775
107764: POP
// bc_type := b_ext_siberium ; 21 :
107765: LD_ADDR_OWVAR 42
107769: PUSH
107770: LD_INT 21
107772: ST_TO_ADDR
107773: GO 108042
107775: LD_INT 21
107777: DOUBLE
107778: EQUAL
107779: IFTRUE 107783
107781: GO 107794
107783: POP
// bc_type := b_ext_computer ; 22 :
107784: LD_ADDR_OWVAR 42
107788: PUSH
107789: LD_INT 24
107791: ST_TO_ADDR
107792: GO 108042
107794: LD_INT 22
107796: DOUBLE
107797: EQUAL
107798: IFTRUE 107802
107800: GO 107813
107802: POP
// bc_type := b_ext_track ; 23 :
107803: LD_ADDR_OWVAR 42
107807: PUSH
107808: LD_INT 16
107810: ST_TO_ADDR
107811: GO 108042
107813: LD_INT 23
107815: DOUBLE
107816: EQUAL
107817: IFTRUE 107821
107819: GO 107832
107821: POP
// bc_type := b_ext_laser ; 24 :
107822: LD_ADDR_OWVAR 42
107826: PUSH
107827: LD_INT 25
107829: ST_TO_ADDR
107830: GO 108042
107832: LD_INT 24
107834: DOUBLE
107835: EQUAL
107836: IFTRUE 107840
107838: GO 107851
107840: POP
// bc_type := b_control_tower ; 25 :
107841: LD_ADDR_OWVAR 42
107845: PUSH
107846: LD_INT 36
107848: ST_TO_ADDR
107849: GO 108042
107851: LD_INT 25
107853: DOUBLE
107854: EQUAL
107855: IFTRUE 107859
107857: GO 107870
107859: POP
// bc_type := b_breastwork ; 26 :
107860: LD_ADDR_OWVAR 42
107864: PUSH
107865: LD_INT 31
107867: ST_TO_ADDR
107868: GO 108042
107870: LD_INT 26
107872: DOUBLE
107873: EQUAL
107874: IFTRUE 107878
107876: GO 107889
107878: POP
// bc_type := b_bunker ; 27 :
107879: LD_ADDR_OWVAR 42
107883: PUSH
107884: LD_INT 32
107886: ST_TO_ADDR
107887: GO 108042
107889: LD_INT 27
107891: DOUBLE
107892: EQUAL
107893: IFTRUE 107897
107895: GO 107908
107897: POP
// bc_type := b_turret ; 28 :
107898: LD_ADDR_OWVAR 42
107902: PUSH
107903: LD_INT 33
107905: ST_TO_ADDR
107906: GO 108042
107908: LD_INT 28
107910: DOUBLE
107911: EQUAL
107912: IFTRUE 107916
107914: GO 107927
107916: POP
// bc_type := b_armoury ; 29 :
107917: LD_ADDR_OWVAR 42
107921: PUSH
107922: LD_INT 4
107924: ST_TO_ADDR
107925: GO 108042
107927: LD_INT 29
107929: DOUBLE
107930: EQUAL
107931: IFTRUE 107935
107933: GO 107946
107935: POP
// bc_type := b_barracks ; 30 :
107936: LD_ADDR_OWVAR 42
107940: PUSH
107941: LD_INT 5
107943: ST_TO_ADDR
107944: GO 108042
107946: LD_INT 30
107948: DOUBLE
107949: EQUAL
107950: IFTRUE 107954
107952: GO 107965
107954: POP
// bc_type := b_solar_power ; 31 :
107955: LD_ADDR_OWVAR 42
107959: PUSH
107960: LD_INT 27
107962: ST_TO_ADDR
107963: GO 108042
107965: LD_INT 31
107967: DOUBLE
107968: EQUAL
107969: IFTRUE 107973
107971: GO 107984
107973: POP
// bc_type := b_oil_power ; 32 :
107974: LD_ADDR_OWVAR 42
107978: PUSH
107979: LD_INT 26
107981: ST_TO_ADDR
107982: GO 108042
107984: LD_INT 32
107986: DOUBLE
107987: EQUAL
107988: IFTRUE 107992
107990: GO 108003
107992: POP
// bc_type := b_siberite_power ; 33 :
107993: LD_ADDR_OWVAR 42
107997: PUSH
107998: LD_INT 28
108000: ST_TO_ADDR
108001: GO 108042
108003: LD_INT 33
108005: DOUBLE
108006: EQUAL
108007: IFTRUE 108011
108009: GO 108022
108011: POP
// bc_type := b_oil_mine ; 34 :
108012: LD_ADDR_OWVAR 42
108016: PUSH
108017: LD_INT 29
108019: ST_TO_ADDR
108020: GO 108042
108022: LD_INT 34
108024: DOUBLE
108025: EQUAL
108026: IFTRUE 108030
108028: GO 108041
108030: POP
// bc_type := b_siberite_mine ; end ;
108031: LD_ADDR_OWVAR 42
108035: PUSH
108036: LD_INT 30
108038: ST_TO_ADDR
108039: GO 108042
108041: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108042: LD_ADDR_VAR 0 8
108046: PUSH
108047: LD_VAR 0 5
108051: PPUSH
108052: LD_VAR 0 6
108056: PPUSH
108057: LD_VAR 0 3
108061: PPUSH
108062: CALL_OW 47
108066: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108067: LD_OWVAR 42
108071: PUSH
108072: LD_INT 32
108074: PUSH
108075: LD_INT 33
108077: PUSH
108078: EMPTY
108079: LIST
108080: LIST
108081: IN
108082: IFFALSE 108098
// PlaceWeaponTurret ( b , weapon ) ;
108084: LD_VAR 0 8
108088: PPUSH
108089: LD_VAR 0 4
108093: PPUSH
108094: CALL_OW 431
// end ;
108098: LD_VAR 0 7
108102: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108103: LD_INT 0
108105: PPUSH
108106: PPUSH
108107: PPUSH
108108: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108109: LD_ADDR_VAR 0 4
108113: PUSH
108114: LD_INT 22
108116: PUSH
108117: LD_OWVAR 2
108121: PUSH
108122: EMPTY
108123: LIST
108124: LIST
108125: PUSH
108126: LD_INT 2
108128: PUSH
108129: LD_INT 30
108131: PUSH
108132: LD_INT 0
108134: PUSH
108135: EMPTY
108136: LIST
108137: LIST
108138: PUSH
108139: LD_INT 30
108141: PUSH
108142: LD_INT 1
108144: PUSH
108145: EMPTY
108146: LIST
108147: LIST
108148: PUSH
108149: EMPTY
108150: LIST
108151: LIST
108152: LIST
108153: PUSH
108154: EMPTY
108155: LIST
108156: LIST
108157: PPUSH
108158: CALL_OW 69
108162: ST_TO_ADDR
// if not tmp then
108163: LD_VAR 0 4
108167: NOT
108168: IFFALSE 108172
// exit ;
108170: GO 108231
// for i in tmp do
108172: LD_ADDR_VAR 0 2
108176: PUSH
108177: LD_VAR 0 4
108181: PUSH
108182: FOR_IN
108183: IFFALSE 108229
// for j = 1 to 3 do
108185: LD_ADDR_VAR 0 3
108189: PUSH
108190: DOUBLE
108191: LD_INT 1
108193: DEC
108194: ST_TO_ADDR
108195: LD_INT 3
108197: PUSH
108198: FOR_TO
108199: IFFALSE 108225
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108201: LD_VAR 0 2
108205: PPUSH
108206: CALL_OW 274
108210: PPUSH
108211: LD_VAR 0 3
108215: PPUSH
108216: LD_INT 99999
108218: PPUSH
108219: CALL_OW 277
108223: GO 108198
108225: POP
108226: POP
108227: GO 108182
108229: POP
108230: POP
// end ;
108231: LD_VAR 0 1
108235: RET
// export function hHackSetLevel10 ; var i , j ; begin
108236: LD_INT 0
108238: PPUSH
108239: PPUSH
108240: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108241: LD_ADDR_VAR 0 2
108245: PUSH
108246: LD_INT 21
108248: PUSH
108249: LD_INT 1
108251: PUSH
108252: EMPTY
108253: LIST
108254: LIST
108255: PPUSH
108256: CALL_OW 69
108260: PUSH
108261: FOR_IN
108262: IFFALSE 108314
// if IsSelected ( i ) then
108264: LD_VAR 0 2
108268: PPUSH
108269: CALL_OW 306
108273: IFFALSE 108312
// begin for j := 1 to 4 do
108275: LD_ADDR_VAR 0 3
108279: PUSH
108280: DOUBLE
108281: LD_INT 1
108283: DEC
108284: ST_TO_ADDR
108285: LD_INT 4
108287: PUSH
108288: FOR_TO
108289: IFFALSE 108310
// SetSkill ( i , j , 10 ) ;
108291: LD_VAR 0 2
108295: PPUSH
108296: LD_VAR 0 3
108300: PPUSH
108301: LD_INT 10
108303: PPUSH
108304: CALL_OW 237
108308: GO 108288
108310: POP
108311: POP
// end ;
108312: GO 108261
108314: POP
108315: POP
// end ;
108316: LD_VAR 0 1
108320: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108321: LD_INT 0
108323: PPUSH
108324: PPUSH
108325: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108326: LD_ADDR_VAR 0 2
108330: PUSH
108331: LD_INT 22
108333: PUSH
108334: LD_OWVAR 2
108338: PUSH
108339: EMPTY
108340: LIST
108341: LIST
108342: PUSH
108343: LD_INT 21
108345: PUSH
108346: LD_INT 1
108348: PUSH
108349: EMPTY
108350: LIST
108351: LIST
108352: PUSH
108353: EMPTY
108354: LIST
108355: LIST
108356: PPUSH
108357: CALL_OW 69
108361: PUSH
108362: FOR_IN
108363: IFFALSE 108404
// begin for j := 1 to 4 do
108365: LD_ADDR_VAR 0 3
108369: PUSH
108370: DOUBLE
108371: LD_INT 1
108373: DEC
108374: ST_TO_ADDR
108375: LD_INT 4
108377: PUSH
108378: FOR_TO
108379: IFFALSE 108400
// SetSkill ( i , j , 10 ) ;
108381: LD_VAR 0 2
108385: PPUSH
108386: LD_VAR 0 3
108390: PPUSH
108391: LD_INT 10
108393: PPUSH
108394: CALL_OW 237
108398: GO 108378
108400: POP
108401: POP
// end ;
108402: GO 108362
108404: POP
108405: POP
// end ;
108406: LD_VAR 0 1
108410: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108411: LD_INT 0
108413: PPUSH
// uc_side := your_side ;
108414: LD_ADDR_OWVAR 20
108418: PUSH
108419: LD_OWVAR 2
108423: ST_TO_ADDR
// uc_nation := nation ;
108424: LD_ADDR_OWVAR 21
108428: PUSH
108429: LD_VAR 0 1
108433: ST_TO_ADDR
// InitHc ;
108434: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108438: LD_INT 0
108440: PPUSH
108441: LD_VAR 0 2
108445: PPUSH
108446: LD_VAR 0 3
108450: PPUSH
108451: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108455: LD_VAR 0 4
108459: PPUSH
108460: LD_VAR 0 5
108464: PPUSH
108465: CALL_OW 428
108469: PUSH
108470: LD_INT 0
108472: EQUAL
108473: IFFALSE 108497
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108475: CALL_OW 44
108479: PPUSH
108480: LD_VAR 0 4
108484: PPUSH
108485: LD_VAR 0 5
108489: PPUSH
108490: LD_INT 1
108492: PPUSH
108493: CALL_OW 48
// end ;
108497: LD_VAR 0 6
108501: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108502: LD_INT 0
108504: PPUSH
108505: PPUSH
// uc_side := your_side ;
108506: LD_ADDR_OWVAR 20
108510: PUSH
108511: LD_OWVAR 2
108515: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108516: LD_VAR 0 1
108520: PUSH
108521: LD_INT 1
108523: PUSH
108524: LD_INT 2
108526: PUSH
108527: LD_INT 3
108529: PUSH
108530: LD_INT 4
108532: PUSH
108533: LD_INT 5
108535: PUSH
108536: EMPTY
108537: LIST
108538: LIST
108539: LIST
108540: LIST
108541: LIST
108542: IN
108543: IFFALSE 108555
// uc_nation := nation_american else
108545: LD_ADDR_OWVAR 21
108549: PUSH
108550: LD_INT 1
108552: ST_TO_ADDR
108553: GO 108598
// if chassis in [ 11 , 12 , 13 , 14 ] then
108555: LD_VAR 0 1
108559: PUSH
108560: LD_INT 11
108562: PUSH
108563: LD_INT 12
108565: PUSH
108566: LD_INT 13
108568: PUSH
108569: LD_INT 14
108571: PUSH
108572: EMPTY
108573: LIST
108574: LIST
108575: LIST
108576: LIST
108577: IN
108578: IFFALSE 108590
// uc_nation := nation_arabian else
108580: LD_ADDR_OWVAR 21
108584: PUSH
108585: LD_INT 2
108587: ST_TO_ADDR
108588: GO 108598
// uc_nation := nation_russian ;
108590: LD_ADDR_OWVAR 21
108594: PUSH
108595: LD_INT 3
108597: ST_TO_ADDR
// vc_chassis := chassis ;
108598: LD_ADDR_OWVAR 37
108602: PUSH
108603: LD_VAR 0 1
108607: ST_TO_ADDR
// vc_engine := engine ;
108608: LD_ADDR_OWVAR 39
108612: PUSH
108613: LD_VAR 0 2
108617: ST_TO_ADDR
// vc_control := control ;
108618: LD_ADDR_OWVAR 38
108622: PUSH
108623: LD_VAR 0 3
108627: ST_TO_ADDR
// vc_weapon := weapon ;
108628: LD_ADDR_OWVAR 40
108632: PUSH
108633: LD_VAR 0 4
108637: ST_TO_ADDR
// un := CreateVehicle ;
108638: LD_ADDR_VAR 0 8
108642: PUSH
108643: CALL_OW 45
108647: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108648: LD_VAR 0 8
108652: PPUSH
108653: LD_INT 0
108655: PPUSH
108656: LD_INT 5
108658: PPUSH
108659: CALL_OW 12
108663: PPUSH
108664: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108668: LD_VAR 0 8
108672: PPUSH
108673: LD_VAR 0 5
108677: PPUSH
108678: LD_VAR 0 6
108682: PPUSH
108683: LD_INT 1
108685: PPUSH
108686: CALL_OW 48
// end ;
108690: LD_VAR 0 7
108694: RET
// export hInvincible ; every 1 do
108695: GO 108697
108697: DISABLE
// hInvincible := [ ] ;
108698: LD_ADDR_EXP 152
108702: PUSH
108703: EMPTY
108704: ST_TO_ADDR
108705: END
// every 10 do var i ;
108706: GO 108708
108708: DISABLE
108709: LD_INT 0
108711: PPUSH
// begin enable ;
108712: ENABLE
// if not hInvincible then
108713: LD_EXP 152
108717: NOT
108718: IFFALSE 108722
// exit ;
108720: GO 108766
// for i in hInvincible do
108722: LD_ADDR_VAR 0 1
108726: PUSH
108727: LD_EXP 152
108731: PUSH
108732: FOR_IN
108733: IFFALSE 108764
// if GetLives ( i ) < 1000 then
108735: LD_VAR 0 1
108739: PPUSH
108740: CALL_OW 256
108744: PUSH
108745: LD_INT 1000
108747: LESS
108748: IFFALSE 108762
// SetLives ( i , 1000 ) ;
108750: LD_VAR 0 1
108754: PPUSH
108755: LD_INT 1000
108757: PPUSH
108758: CALL_OW 234
108762: GO 108732
108764: POP
108765: POP
// end ;
108766: PPOPN 1
108768: END
// export function hHackInvincible ; var i ; begin
108769: LD_INT 0
108771: PPUSH
108772: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108773: LD_ADDR_VAR 0 2
108777: PUSH
108778: LD_INT 2
108780: PUSH
108781: LD_INT 21
108783: PUSH
108784: LD_INT 1
108786: PUSH
108787: EMPTY
108788: LIST
108789: LIST
108790: PUSH
108791: LD_INT 21
108793: PUSH
108794: LD_INT 2
108796: PUSH
108797: EMPTY
108798: LIST
108799: LIST
108800: PUSH
108801: EMPTY
108802: LIST
108803: LIST
108804: LIST
108805: PPUSH
108806: CALL_OW 69
108810: PUSH
108811: FOR_IN
108812: IFFALSE 108873
// if IsSelected ( i ) then
108814: LD_VAR 0 2
108818: PPUSH
108819: CALL_OW 306
108823: IFFALSE 108871
// begin if i in hInvincible then
108825: LD_VAR 0 2
108829: PUSH
108830: LD_EXP 152
108834: IN
108835: IFFALSE 108855
// hInvincible := hInvincible diff i else
108837: LD_ADDR_EXP 152
108841: PUSH
108842: LD_EXP 152
108846: PUSH
108847: LD_VAR 0 2
108851: DIFF
108852: ST_TO_ADDR
108853: GO 108871
// hInvincible := hInvincible union i ;
108855: LD_ADDR_EXP 152
108859: PUSH
108860: LD_EXP 152
108864: PUSH
108865: LD_VAR 0 2
108869: UNION
108870: ST_TO_ADDR
// end ;
108871: GO 108811
108873: POP
108874: POP
// end ;
108875: LD_VAR 0 1
108879: RET
// export function hHackInvisible ; var i , j ; begin
108880: LD_INT 0
108882: PPUSH
108883: PPUSH
108884: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108885: LD_ADDR_VAR 0 2
108889: PUSH
108890: LD_INT 21
108892: PUSH
108893: LD_INT 1
108895: PUSH
108896: EMPTY
108897: LIST
108898: LIST
108899: PPUSH
108900: CALL_OW 69
108904: PUSH
108905: FOR_IN
108906: IFFALSE 108930
// if IsSelected ( i ) then
108908: LD_VAR 0 2
108912: PPUSH
108913: CALL_OW 306
108917: IFFALSE 108928
// ComForceInvisible ( i ) ;
108919: LD_VAR 0 2
108923: PPUSH
108924: CALL_OW 496
108928: GO 108905
108930: POP
108931: POP
// end ;
108932: LD_VAR 0 1
108936: RET
// export function hHackChangeYourSide ; begin
108937: LD_INT 0
108939: PPUSH
// if your_side = 8 then
108940: LD_OWVAR 2
108944: PUSH
108945: LD_INT 8
108947: EQUAL
108948: IFFALSE 108960
// your_side := 0 else
108950: LD_ADDR_OWVAR 2
108954: PUSH
108955: LD_INT 0
108957: ST_TO_ADDR
108958: GO 108974
// your_side := your_side + 1 ;
108960: LD_ADDR_OWVAR 2
108964: PUSH
108965: LD_OWVAR 2
108969: PUSH
108970: LD_INT 1
108972: PLUS
108973: ST_TO_ADDR
// end ;
108974: LD_VAR 0 1
108978: RET
// export function hHackChangeUnitSide ; var i , j ; begin
108979: LD_INT 0
108981: PPUSH
108982: PPUSH
108983: PPUSH
// for i in all_units do
108984: LD_ADDR_VAR 0 2
108988: PUSH
108989: LD_OWVAR 3
108993: PUSH
108994: FOR_IN
108995: IFFALSE 109073
// if IsSelected ( i ) then
108997: LD_VAR 0 2
109001: PPUSH
109002: CALL_OW 306
109006: IFFALSE 109071
// begin j := GetSide ( i ) ;
109008: LD_ADDR_VAR 0 3
109012: PUSH
109013: LD_VAR 0 2
109017: PPUSH
109018: CALL_OW 255
109022: ST_TO_ADDR
// if j = 8 then
109023: LD_VAR 0 3
109027: PUSH
109028: LD_INT 8
109030: EQUAL
109031: IFFALSE 109043
// j := 0 else
109033: LD_ADDR_VAR 0 3
109037: PUSH
109038: LD_INT 0
109040: ST_TO_ADDR
109041: GO 109057
// j := j + 1 ;
109043: LD_ADDR_VAR 0 3
109047: PUSH
109048: LD_VAR 0 3
109052: PUSH
109053: LD_INT 1
109055: PLUS
109056: ST_TO_ADDR
// SetSide ( i , j ) ;
109057: LD_VAR 0 2
109061: PPUSH
109062: LD_VAR 0 3
109066: PPUSH
109067: CALL_OW 235
// end ;
109071: GO 108994
109073: POP
109074: POP
// end ;
109075: LD_VAR 0 1
109079: RET
// export function hHackFog ; begin
109080: LD_INT 0
109082: PPUSH
// FogOff ( true ) ;
109083: LD_INT 1
109085: PPUSH
109086: CALL_OW 344
// end ;
109090: LD_VAR 0 1
109094: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109095: LD_INT 0
109097: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109098: LD_VAR 0 1
109102: PPUSH
109103: LD_VAR 0 2
109107: PPUSH
109108: LD_VAR 0 3
109112: PPUSH
109113: LD_INT 1
109115: PPUSH
109116: LD_INT 1
109118: PPUSH
109119: CALL_OW 483
// CenterOnXY ( x , y ) ;
109123: LD_VAR 0 2
109127: PPUSH
109128: LD_VAR 0 3
109132: PPUSH
109133: CALL_OW 84
// end ;
109137: LD_VAR 0 4
109141: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109142: LD_INT 0
109144: PPUSH
109145: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109146: LD_VAR 0 1
109150: NOT
109151: PUSH
109152: LD_VAR 0 2
109156: PPUSH
109157: LD_VAR 0 3
109161: PPUSH
109162: CALL_OW 488
109166: NOT
109167: OR
109168: PUSH
109169: LD_VAR 0 1
109173: PPUSH
109174: CALL_OW 266
109178: PUSH
109179: LD_INT 3
109181: NONEQUAL
109182: PUSH
109183: LD_VAR 0 1
109187: PPUSH
109188: CALL_OW 247
109192: PUSH
109193: LD_INT 1
109195: EQUAL
109196: NOT
109197: AND
109198: OR
109199: IFFALSE 109203
// exit ;
109201: GO 109352
// if GetType ( factory ) = unit_human then
109203: LD_VAR 0 1
109207: PPUSH
109208: CALL_OW 247
109212: PUSH
109213: LD_INT 1
109215: EQUAL
109216: IFFALSE 109233
// factory := IsInUnit ( factory ) ;
109218: LD_ADDR_VAR 0 1
109222: PUSH
109223: LD_VAR 0 1
109227: PPUSH
109228: CALL_OW 310
109232: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109233: LD_VAR 0 1
109237: PPUSH
109238: CALL_OW 266
109242: PUSH
109243: LD_INT 3
109245: NONEQUAL
109246: IFFALSE 109250
// exit ;
109248: GO 109352
// if HexInfo ( x , y ) = factory then
109250: LD_VAR 0 2
109254: PPUSH
109255: LD_VAR 0 3
109259: PPUSH
109260: CALL_OW 428
109264: PUSH
109265: LD_VAR 0 1
109269: EQUAL
109270: IFFALSE 109297
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109272: LD_ADDR_EXP 153
109276: PUSH
109277: LD_EXP 153
109281: PPUSH
109282: LD_VAR 0 1
109286: PPUSH
109287: LD_INT 0
109289: PPUSH
109290: CALL_OW 1
109294: ST_TO_ADDR
109295: GO 109348
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109297: LD_ADDR_EXP 153
109301: PUSH
109302: LD_EXP 153
109306: PPUSH
109307: LD_VAR 0 1
109311: PPUSH
109312: LD_VAR 0 1
109316: PPUSH
109317: CALL_OW 255
109321: PUSH
109322: LD_VAR 0 1
109326: PUSH
109327: LD_VAR 0 2
109331: PUSH
109332: LD_VAR 0 3
109336: PUSH
109337: EMPTY
109338: LIST
109339: LIST
109340: LIST
109341: LIST
109342: PPUSH
109343: CALL_OW 1
109347: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109348: CALL 109357 0 0
// end ;
109352: LD_VAR 0 4
109356: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109357: LD_INT 0
109359: PPUSH
109360: PPUSH
109361: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109362: LD_STRING resetFactoryWaypoint();
109364: PPUSH
109365: CALL_OW 559
// if factoryWaypoints then
109369: LD_EXP 153
109373: IFFALSE 109499
// begin list := PrepareArray ( factoryWaypoints ) ;
109375: LD_ADDR_VAR 0 3
109379: PUSH
109380: LD_EXP 153
109384: PPUSH
109385: CALL 52192 0 1
109389: ST_TO_ADDR
// for i := 1 to list do
109390: LD_ADDR_VAR 0 2
109394: PUSH
109395: DOUBLE
109396: LD_INT 1
109398: DEC
109399: ST_TO_ADDR
109400: LD_VAR 0 3
109404: PUSH
109405: FOR_TO
109406: IFFALSE 109497
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109408: LD_STRING setFactoryWaypointXY(
109410: PUSH
109411: LD_VAR 0 3
109415: PUSH
109416: LD_VAR 0 2
109420: ARRAY
109421: PUSH
109422: LD_INT 1
109424: ARRAY
109425: STR
109426: PUSH
109427: LD_STRING ,
109429: STR
109430: PUSH
109431: LD_VAR 0 3
109435: PUSH
109436: LD_VAR 0 2
109440: ARRAY
109441: PUSH
109442: LD_INT 2
109444: ARRAY
109445: STR
109446: PUSH
109447: LD_STRING ,
109449: STR
109450: PUSH
109451: LD_VAR 0 3
109455: PUSH
109456: LD_VAR 0 2
109460: ARRAY
109461: PUSH
109462: LD_INT 3
109464: ARRAY
109465: STR
109466: PUSH
109467: LD_STRING ,
109469: STR
109470: PUSH
109471: LD_VAR 0 3
109475: PUSH
109476: LD_VAR 0 2
109480: ARRAY
109481: PUSH
109482: LD_INT 4
109484: ARRAY
109485: STR
109486: PUSH
109487: LD_STRING )
109489: STR
109490: PPUSH
109491: CALL_OW 559
109495: GO 109405
109497: POP
109498: POP
// end ; end ;
109499: LD_VAR 0 1
109503: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109504: LD_INT 0
109506: PPUSH
// if HexInfo ( x , y ) = warehouse then
109507: LD_VAR 0 2
109511: PPUSH
109512: LD_VAR 0 3
109516: PPUSH
109517: CALL_OW 428
109521: PUSH
109522: LD_VAR 0 1
109526: EQUAL
109527: IFFALSE 109554
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109529: LD_ADDR_EXP 154
109533: PUSH
109534: LD_EXP 154
109538: PPUSH
109539: LD_VAR 0 1
109543: PPUSH
109544: LD_INT 0
109546: PPUSH
109547: CALL_OW 1
109551: ST_TO_ADDR
109552: GO 109605
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109554: LD_ADDR_EXP 154
109558: PUSH
109559: LD_EXP 154
109563: PPUSH
109564: LD_VAR 0 1
109568: PPUSH
109569: LD_VAR 0 1
109573: PPUSH
109574: CALL_OW 255
109578: PUSH
109579: LD_VAR 0 1
109583: PUSH
109584: LD_VAR 0 2
109588: PUSH
109589: LD_VAR 0 3
109593: PUSH
109594: EMPTY
109595: LIST
109596: LIST
109597: LIST
109598: LIST
109599: PPUSH
109600: CALL_OW 1
109604: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109605: CALL 109614 0 0
// end ;
109609: LD_VAR 0 4
109613: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109614: LD_INT 0
109616: PPUSH
109617: PPUSH
109618: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109619: LD_STRING resetWarehouseGatheringPoints();
109621: PPUSH
109622: CALL_OW 559
// if warehouseGatheringPoints then
109626: LD_EXP 154
109630: IFFALSE 109756
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109632: LD_ADDR_VAR 0 3
109636: PUSH
109637: LD_EXP 154
109641: PPUSH
109642: CALL 52192 0 1
109646: ST_TO_ADDR
// for i := 1 to list do
109647: LD_ADDR_VAR 0 2
109651: PUSH
109652: DOUBLE
109653: LD_INT 1
109655: DEC
109656: ST_TO_ADDR
109657: LD_VAR 0 3
109661: PUSH
109662: FOR_TO
109663: IFFALSE 109754
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109665: LD_STRING setWarehouseGatheringPointXY(
109667: PUSH
109668: LD_VAR 0 3
109672: PUSH
109673: LD_VAR 0 2
109677: ARRAY
109678: PUSH
109679: LD_INT 1
109681: ARRAY
109682: STR
109683: PUSH
109684: LD_STRING ,
109686: STR
109687: PUSH
109688: LD_VAR 0 3
109692: PUSH
109693: LD_VAR 0 2
109697: ARRAY
109698: PUSH
109699: LD_INT 2
109701: ARRAY
109702: STR
109703: PUSH
109704: LD_STRING ,
109706: STR
109707: PUSH
109708: LD_VAR 0 3
109712: PUSH
109713: LD_VAR 0 2
109717: ARRAY
109718: PUSH
109719: LD_INT 3
109721: ARRAY
109722: STR
109723: PUSH
109724: LD_STRING ,
109726: STR
109727: PUSH
109728: LD_VAR 0 3
109732: PUSH
109733: LD_VAR 0 2
109737: ARRAY
109738: PUSH
109739: LD_INT 4
109741: ARRAY
109742: STR
109743: PUSH
109744: LD_STRING )
109746: STR
109747: PPUSH
109748: CALL_OW 559
109752: GO 109662
109754: POP
109755: POP
// end ; end ;
109756: LD_VAR 0 1
109760: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109761: LD_EXP 154
109765: IFFALSE 110452
109767: GO 109769
109769: DISABLE
109770: LD_INT 0
109772: PPUSH
109773: PPUSH
109774: PPUSH
109775: PPUSH
109776: PPUSH
109777: PPUSH
109778: PPUSH
109779: PPUSH
109780: PPUSH
// begin enable ;
109781: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109782: LD_ADDR_VAR 0 3
109786: PUSH
109787: LD_EXP 154
109791: PPUSH
109792: CALL 52192 0 1
109796: ST_TO_ADDR
// if not list then
109797: LD_VAR 0 3
109801: NOT
109802: IFFALSE 109806
// exit ;
109804: GO 110452
// for i := 1 to list do
109806: LD_ADDR_VAR 0 1
109810: PUSH
109811: DOUBLE
109812: LD_INT 1
109814: DEC
109815: ST_TO_ADDR
109816: LD_VAR 0 3
109820: PUSH
109821: FOR_TO
109822: IFFALSE 110450
// begin depot := list [ i ] [ 2 ] ;
109824: LD_ADDR_VAR 0 8
109828: PUSH
109829: LD_VAR 0 3
109833: PUSH
109834: LD_VAR 0 1
109838: ARRAY
109839: PUSH
109840: LD_INT 2
109842: ARRAY
109843: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
109844: LD_ADDR_VAR 0 5
109848: PUSH
109849: LD_VAR 0 3
109853: PUSH
109854: LD_VAR 0 1
109858: ARRAY
109859: PUSH
109860: LD_INT 1
109862: ARRAY
109863: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
109864: LD_VAR 0 8
109868: PPUSH
109869: CALL_OW 301
109873: PUSH
109874: LD_VAR 0 5
109878: PUSH
109879: LD_VAR 0 8
109883: PPUSH
109884: CALL_OW 255
109888: NONEQUAL
109889: OR
109890: IFFALSE 109919
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
109892: LD_ADDR_EXP 154
109896: PUSH
109897: LD_EXP 154
109901: PPUSH
109902: LD_VAR 0 8
109906: PPUSH
109907: LD_INT 0
109909: PPUSH
109910: CALL_OW 1
109914: ST_TO_ADDR
// exit ;
109915: POP
109916: POP
109917: GO 110452
// end ; x := list [ i ] [ 3 ] ;
109919: LD_ADDR_VAR 0 6
109923: PUSH
109924: LD_VAR 0 3
109928: PUSH
109929: LD_VAR 0 1
109933: ARRAY
109934: PUSH
109935: LD_INT 3
109937: ARRAY
109938: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
109939: LD_ADDR_VAR 0 7
109943: PUSH
109944: LD_VAR 0 3
109948: PUSH
109949: LD_VAR 0 1
109953: ARRAY
109954: PUSH
109955: LD_INT 4
109957: ARRAY
109958: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
109959: LD_ADDR_VAR 0 9
109963: PUSH
109964: LD_VAR 0 6
109968: PPUSH
109969: LD_VAR 0 7
109973: PPUSH
109974: LD_INT 16
109976: PPUSH
109977: CALL 50776 0 3
109981: ST_TO_ADDR
// if not cratesNearbyPoint then
109982: LD_VAR 0 9
109986: NOT
109987: IFFALSE 109993
// exit ;
109989: POP
109990: POP
109991: GO 110452
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
109993: LD_ADDR_VAR 0 4
109997: PUSH
109998: LD_INT 22
110000: PUSH
110001: LD_VAR 0 5
110005: PUSH
110006: EMPTY
110007: LIST
110008: LIST
110009: PUSH
110010: LD_INT 3
110012: PUSH
110013: LD_INT 60
110015: PUSH
110016: EMPTY
110017: LIST
110018: PUSH
110019: EMPTY
110020: LIST
110021: LIST
110022: PUSH
110023: LD_INT 91
110025: PUSH
110026: LD_VAR 0 8
110030: PUSH
110031: LD_INT 6
110033: PUSH
110034: EMPTY
110035: LIST
110036: LIST
110037: LIST
110038: PUSH
110039: LD_INT 2
110041: PUSH
110042: LD_INT 25
110044: PUSH
110045: LD_INT 2
110047: PUSH
110048: EMPTY
110049: LIST
110050: LIST
110051: PUSH
110052: LD_INT 25
110054: PUSH
110055: LD_INT 16
110057: PUSH
110058: EMPTY
110059: LIST
110060: LIST
110061: PUSH
110062: EMPTY
110063: LIST
110064: LIST
110065: LIST
110066: PUSH
110067: EMPTY
110068: LIST
110069: LIST
110070: LIST
110071: LIST
110072: PPUSH
110073: CALL_OW 69
110077: PUSH
110078: LD_VAR 0 8
110082: PPUSH
110083: CALL_OW 313
110087: PPUSH
110088: LD_INT 3
110090: PUSH
110091: LD_INT 60
110093: PUSH
110094: EMPTY
110095: LIST
110096: PUSH
110097: EMPTY
110098: LIST
110099: LIST
110100: PUSH
110101: LD_INT 2
110103: PUSH
110104: LD_INT 25
110106: PUSH
110107: LD_INT 2
110109: PUSH
110110: EMPTY
110111: LIST
110112: LIST
110113: PUSH
110114: LD_INT 25
110116: PUSH
110117: LD_INT 16
110119: PUSH
110120: EMPTY
110121: LIST
110122: LIST
110123: PUSH
110124: EMPTY
110125: LIST
110126: LIST
110127: LIST
110128: PUSH
110129: EMPTY
110130: LIST
110131: LIST
110132: PPUSH
110133: CALL_OW 72
110137: UNION
110138: ST_TO_ADDR
// if tmp then
110139: LD_VAR 0 4
110143: IFFALSE 110223
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110145: LD_ADDR_VAR 0 4
110149: PUSH
110150: LD_VAR 0 4
110154: PPUSH
110155: LD_INT 3
110157: PPUSH
110158: CALL 48743 0 2
110162: ST_TO_ADDR
// for j in tmp do
110163: LD_ADDR_VAR 0 2
110167: PUSH
110168: LD_VAR 0 4
110172: PUSH
110173: FOR_IN
110174: IFFALSE 110217
// begin if IsInUnit ( j ) then
110176: LD_VAR 0 2
110180: PPUSH
110181: CALL_OW 310
110185: IFFALSE 110196
// ComExit ( j ) ;
110187: LD_VAR 0 2
110191: PPUSH
110192: CALL 48826 0 1
// AddComCollect ( j , x , y ) ;
110196: LD_VAR 0 2
110200: PPUSH
110201: LD_VAR 0 6
110205: PPUSH
110206: LD_VAR 0 7
110210: PPUSH
110211: CALL_OW 177
// end ;
110215: GO 110173
110217: POP
110218: POP
// exit ;
110219: POP
110220: POP
110221: GO 110452
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110223: LD_ADDR_VAR 0 4
110227: PUSH
110228: LD_INT 22
110230: PUSH
110231: LD_VAR 0 5
110235: PUSH
110236: EMPTY
110237: LIST
110238: LIST
110239: PUSH
110240: LD_INT 91
110242: PUSH
110243: LD_VAR 0 8
110247: PUSH
110248: LD_INT 8
110250: PUSH
110251: EMPTY
110252: LIST
110253: LIST
110254: LIST
110255: PUSH
110256: LD_INT 2
110258: PUSH
110259: LD_INT 34
110261: PUSH
110262: LD_INT 12
110264: PUSH
110265: EMPTY
110266: LIST
110267: LIST
110268: PUSH
110269: LD_INT 34
110271: PUSH
110272: LD_INT 51
110274: PUSH
110275: EMPTY
110276: LIST
110277: LIST
110278: PUSH
110279: LD_INT 34
110281: PUSH
110282: LD_INT 32
110284: PUSH
110285: EMPTY
110286: LIST
110287: LIST
110288: PUSH
110289: LD_INT 34
110291: PUSH
110292: LD_EXP 68
110296: PUSH
110297: EMPTY
110298: LIST
110299: LIST
110300: PUSH
110301: EMPTY
110302: LIST
110303: LIST
110304: LIST
110305: LIST
110306: LIST
110307: PUSH
110308: EMPTY
110309: LIST
110310: LIST
110311: LIST
110312: PPUSH
110313: CALL_OW 69
110317: ST_TO_ADDR
// if tmp then
110318: LD_VAR 0 4
110322: IFFALSE 110448
// begin for j in tmp do
110324: LD_ADDR_VAR 0 2
110328: PUSH
110329: LD_VAR 0 4
110333: PUSH
110334: FOR_IN
110335: IFFALSE 110446
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110337: LD_VAR 0 2
110341: PPUSH
110342: CALL_OW 262
110346: PUSH
110347: LD_INT 3
110349: EQUAL
110350: PUSH
110351: LD_VAR 0 2
110355: PPUSH
110356: CALL_OW 261
110360: PUSH
110361: LD_INT 20
110363: GREATER
110364: OR
110365: PUSH
110366: LD_VAR 0 2
110370: PPUSH
110371: CALL_OW 314
110375: NOT
110376: AND
110377: PUSH
110378: LD_VAR 0 2
110382: PPUSH
110383: CALL_OW 263
110387: PUSH
110388: LD_INT 1
110390: NONEQUAL
110391: PUSH
110392: LD_VAR 0 2
110396: PPUSH
110397: CALL_OW 311
110401: OR
110402: AND
110403: IFFALSE 110444
// begin ComCollect ( j , x , y ) ;
110405: LD_VAR 0 2
110409: PPUSH
110410: LD_VAR 0 6
110414: PPUSH
110415: LD_VAR 0 7
110419: PPUSH
110420: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110424: LD_VAR 0 2
110428: PPUSH
110429: LD_VAR 0 8
110433: PPUSH
110434: CALL_OW 172
// exit ;
110438: POP
110439: POP
110440: POP
110441: POP
110442: GO 110452
// end ;
110444: GO 110334
110446: POP
110447: POP
// end ; end ;
110448: GO 109821
110450: POP
110451: POP
// end ; end_of_file
110452: PPOPN 9
110454: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110455: LD_VAR 0 1
110459: PPUSH
110460: LD_VAR 0 2
110464: PPUSH
110465: LD_VAR 0 3
110469: PPUSH
110470: LD_VAR 0 4
110474: PPUSH
110475: LD_VAR 0 5
110479: PPUSH
110480: LD_VAR 0 6
110484: PPUSH
110485: CALL 94855 0 6
// end ;
110489: PPOPN 6
110491: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110492: LD_INT 0
110494: PPUSH
// begin if not units then
110495: LD_VAR 0 1
110499: NOT
110500: IFFALSE 110504
// exit ;
110502: GO 110504
// end ;
110504: PPOPN 7
110506: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110507: CALL 94826 0 0
// end ;
110511: PPOPN 1
110513: END
