// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 81489 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 44367 0 9
// PrepareGensher ;
 189: CALL 3160 0 0
// PreparePopov ;
 193: CALL 6371 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 9059 0 0
// MC_Start ( ) ;
 205: CALL 53028 0 0
// Action ;
 209: CALL 9466 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 4294 0 0
// InitMC_Powell ( ) ;
 284: CALL 1515 0 0
// InitMC_Popov ( ) ;
 288: CALL 7529 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
 599: PPUSH
// powell_side := 4 ;
 600: LD_ADDR_EXP 11
 604: PUSH
 605: LD_INT 4
 607: ST_TO_ADDR
// uc_side := powell_side ;
 608: LD_ADDR_OWVAR 20
 612: PUSH
 613: LD_EXP 11
 617: ST_TO_ADDR
// uc_nation := 1 ;
 618: LD_ADDR_OWVAR 21
 622: PUSH
 623: LD_INT 1
 625: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 626: LD_ADDR_EXP 10
 630: PUSH
 631: LD_STRING Powell
 633: PPUSH
 634: CALL_OW 25
 638: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 639: LD_EXP 10
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 7
 649: PPUSH
 650: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 654: LD_EXP 10
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 5
 664: PPUSH
 665: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 669: LD_EXP 10
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: LD_INT 6
 679: PPUSH
 680: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 684: LD_EXP 10
 688: PPUSH
 689: LD_INT 4
 691: PPUSH
 692: LD_INT 4
 694: PPUSH
 695: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 699: LD_EXP 10
 703: PPUSH
 704: LD_INT 4
 706: PPUSH
 707: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 711: LD_ADDR_VAR 0 3
 715: PUSH
 716: LD_INT 5
 718: PUSH
 719: LD_INT 178
 721: PUSH
 722: LD_INT 117
 724: PUSH
 725: LD_INT 2
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 29
 736: PUSH
 737: LD_INT 167
 739: PUSH
 740: LD_INT 102
 742: PUSH
 743: LD_INT 0
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 6
 754: PUSH
 755: LD_INT 200
 757: PUSH
 758: LD_INT 111
 760: PUSH
 761: LD_INT 4
 763: PUSH
 764: LD_INT 10
 766: PUSH
 767: LD_INT 11
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 201
 783: PUSH
 784: LD_INT 140
 786: PUSH
 787: LD_INT 4
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 27
 798: PUSH
 799: LD_INT 206
 801: PUSH
 802: LD_INT 124
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 27
 816: PUSH
 817: LD_INT 209
 819: PUSH
 820: LD_INT 128
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_INT 27
 834: PUSH
 835: LD_INT 211
 837: PUSH
 838: LD_INT 132
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 173
 855: PUSH
 856: LD_INT 83
 858: PUSH
 859: LD_INT 3
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 6
 870: PUSH
 871: LD_INT 186
 873: PUSH
 874: LD_INT 103
 876: PUSH
 877: LD_INT 2
 879: PUSH
 880: LD_INT 12
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: PUSH
 894: LD_INT 33
 896: PUSH
 897: LD_INT 173
 899: PUSH
 900: LD_INT 99
 902: PUSH
 903: LD_INT 2
 905: PUSH
 906: LD_INT 6
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 32
 918: PUSH
 919: LD_INT 174
 921: PUSH
 922: LD_INT 102
 924: PUSH
 925: LD_INT 2
 927: PUSH
 928: LD_INT 6
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PUSH
 938: LD_INT 32
 940: PUSH
 941: LD_INT 178
 943: PUSH
 944: LD_INT 100
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 6
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 33
 962: PUSH
 963: LD_INT 174
 965: PUSH
 966: LD_INT 108
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: LD_INT 7
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 33
 984: PUSH
 985: LD_INT 182
 987: PUSH
 988: LD_INT 122
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 7
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 36
1006: PUSH
1007: LD_INT 194
1009: PUSH
1010: LD_INT 124
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: LD_INT 184
1027: PUSH
1028: LD_INT 141
1030: PUSH
1031: LD_INT 1
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: PUSH
1044: LD_INT 33
1046: PUSH
1047: LD_INT 183
1049: PUSH
1050: LD_INT 131
1052: PUSH
1053: LD_INT 2
1055: PUSH
1056: LD_INT 11
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_INT 33
1068: PUSH
1069: LD_INT 194
1071: PUSH
1072: LD_INT 146
1074: PUSH
1075: LD_INT 4
1077: PUSH
1078: LD_INT 7
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: LD_INT 33
1090: PUSH
1091: LD_INT 190
1093: PUSH
1094: LD_INT 142
1096: PUSH
1097: LD_INT 4
1099: PUSH
1100: LD_INT 7
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 28
1112: PUSH
1113: LD_INT 204
1115: PUSH
1116: LD_INT 133
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 201
1133: PUSH
1134: LD_INT 133
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 28
1148: PUSH
1149: LD_INT 199
1151: PUSH
1152: LD_INT 119
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: ST_TO_ADDR
// for i in list do
1188: LD_ADDR_VAR 0 2
1192: PUSH
1193: LD_VAR 0 3
1197: PUSH
1198: FOR_IN
1199: IFFALSE 1377
// begin uc_side := 4 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 4
1208: ST_TO_ADDR
// uc_nation := 1 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// bc_kind1 := - 1 ;
1231: LD_ADDR_OWVAR 44
1235: PUSH
1236: LD_INT 1
1238: NEG
1239: ST_TO_ADDR
// bc_kind2 := - 1 ;
1240: LD_ADDR_OWVAR 45
1244: PUSH
1245: LD_INT 1
1247: NEG
1248: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1249: LD_VAR 0 2
1253: PUSH
1254: LD_INT 1
1256: ARRAY
1257: PUSH
1258: LD_INT 6
1260: EQUAL
1261: IFFALSE 1299
// begin bc_type := b_lab_full ;
1263: LD_ADDR_OWVAR 42
1267: PUSH
1268: LD_INT 8
1270: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1271: LD_ADDR_OWVAR 44
1275: PUSH
1276: LD_VAR 0 2
1280: PUSH
1281: LD_INT 5
1283: ARRAY
1284: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1285: LD_ADDR_OWVAR 45
1289: PUSH
1290: LD_VAR 0 2
1294: PUSH
1295: LD_INT 6
1297: ARRAY
1298: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1299: LD_ADDR_VAR 0 4
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 2
1311: ARRAY
1312: PPUSH
1313: LD_VAR 0 2
1317: PUSH
1318: LD_INT 3
1320: ARRAY
1321: PPUSH
1322: LD_VAR 0 2
1326: PUSH
1327: LD_INT 4
1329: ARRAY
1330: PPUSH
1331: CALL_OW 47
1335: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1336: LD_VAR 0 2
1340: PUSH
1341: LD_INT 1
1343: ARRAY
1344: PUSH
1345: LD_INT 33
1347: PUSH
1348: LD_INT 32
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: IN
1355: IFFALSE 1375
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1357: LD_VAR 0 4
1361: PPUSH
1362: LD_VAR 0 2
1366: PUSH
1367: LD_INT 5
1369: ARRAY
1370: PPUSH
1371: CALL_OW 431
// end ;
1375: GO 1198
1377: POP
1378: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1379: LD_ADDR_VAR 0 5
1383: PUSH
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_STRING 
1392: PPUSH
1393: LD_INT 8
1395: PUSH
1396: LD_INT 7
1398: PUSH
1399: LD_INT 6
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: PUSH
1407: LD_OWVAR 67
1411: ARRAY
1412: PPUSH
1413: LD_INT 5500
1415: PUSH
1416: LD_INT 500
1418: PUSH
1419: LD_INT 0
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: LIST
1426: PPUSH
1427: LD_INT 6
1429: PUSH
1430: LD_INT 6
1432: PUSH
1433: LD_INT 6
1435: PUSH
1436: LD_INT 6
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 19314 0 6
1449: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1450: LD_ADDR_EXP 23
1454: PUSH
1455: LD_EXP 23
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: LD_VAR 0 5
1467: PUSH
1468: LD_INT 22
1470: PUSH
1471: LD_INT 4
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: PUSH
1478: LD_INT 21
1480: PUSH
1481: LD_INT 3
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PPUSH
1492: CALL_OW 69
1496: UNION
1497: PPUSH
1498: CALL_OW 1
1502: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1503: LD_ADDR_EXP 12
1507: PUSH
1508: EMPTY
1509: ST_TO_ADDR
// end ;
1510: LD_VAR 0 1
1514: RET
// export function InitMC_Powell ( ) ; begin
1515: LD_INT 0
1517: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1518: LD_INT 1
1520: PPUSH
1521: LD_INT 1
1523: PPUSH
1524: CALL 76356 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1528: LD_INT 1
1530: PPUSH
1531: LD_INT 6
1533: PPUSH
1534: CALL 76300 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1538: LD_INT 1
1540: PPUSH
1541: LD_INT 167
1543: PUSH
1544: LD_INT 102
1546: PUSH
1547: LD_INT 0
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 173
1557: PUSH
1558: LD_INT 83
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 171
1571: PUSH
1572: LD_INT 141
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 178
1585: PUSH
1586: LD_INT 148
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: PPUSH
1603: CALL 75359 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1607: LD_INT 1
1609: PPUSH
1610: LD_INT 11
1612: PUSH
1613: LD_INT 6
1615: PUSH
1616: LD_INT 7
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PPUSH
1624: CALL 76188 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 5
1633: PPUSH
1634: CALL 75870 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 4
1643: PPUSH
1644: CALL 75601 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1648: LD_INT 1
1650: PPUSH
1651: LD_INT 4
1653: PPUSH
1654: CALL 75220 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 3
1663: PUSH
1664: LD_INT 1
1666: PUSH
1667: LD_INT 2
1669: PUSH
1670: LD_INT 5
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: PUSH
1679: LD_INT 4
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 6
1690: PUSH
1691: EMPTY
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_INT 4
1699: PUSH
1700: LD_INT 1
1702: PUSH
1703: LD_INT 2
1705: PUSH
1706: LD_INT 7
1708: PUSH
1709: EMPTY
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 6
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: PUSH
1733: EMPTY
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PPUSH
1739: CALL 75035 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1743: LD_INT 1
1745: PPUSH
1746: LD_INT 201
1748: PPUSH
1749: LD_INT 140
1751: PPUSH
1752: LD_INT 4
1754: PPUSH
1755: LD_INT 19
1757: PUSH
1758: LD_INT 16
1760: PUSH
1761: LD_INT 17
1763: PUSH
1764: LD_INT 18
1766: PUSH
1767: LD_INT 22
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 75982 0 5
// end ;
1781: LD_VAR 0 1
1785: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1786: LD_INT 4
1788: PPUSH
1789: CALL_OW 302
1793: IFFALSE 2453
1795: GO 1797
1797: DISABLE
1798: LD_INT 0
1800: PPUSH
1801: PPUSH
1802: PPUSH
1803: PPUSH
1804: PPUSH
// begin enable ;
1805: ENABLE
// base := 1 ;
1806: LD_ADDR_VAR 0 2
1810: PUSH
1811: LD_INT 1
1813: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: LD_INT 4
1821: PUSH
1822: LD_INT 1
1824: PUSH
1825: LD_INT 2
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 4
1839: PUSH
1840: LD_INT 1
1842: PUSH
1843: LD_INT 2
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: LD_INT 1
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: LD_INT 7
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PUSH
1873: LD_INT 3
1875: PUSH
1876: LD_INT 1
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 7
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_OWVAR 1
1911: PUSH
1912: LD_INT 21000
1914: DIV
1915: PLUS
1916: ST_TO_ADDR
// if amount > 8 then
1917: LD_VAR 0 5
1921: PUSH
1922: LD_INT 8
1924: GREATER
1925: IFFALSE 1935
// amount := 8 ;
1927: LD_ADDR_VAR 0 5
1931: PUSH
1932: LD_INT 8
1934: ST_TO_ADDR
// for i = 1 to amount do
1935: LD_ADDR_VAR 0 1
1939: PUSH
1940: DOUBLE
1941: LD_INT 1
1943: DEC
1944: ST_TO_ADDR
1945: LD_VAR 0 5
1949: PUSH
1950: FOR_TO
1951: IFFALSE 2035
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1953: LD_ADDR_VAR 0 3
1957: PUSH
1958: LD_VAR 0 3
1962: PPUSH
1963: LD_VAR 0 3
1967: PUSH
1968: LD_INT 1
1970: PLUS
1971: PPUSH
1972: LD_INT 3
1974: PUSH
1975: LD_INT 4
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 2
1987: PPUSH
1988: CALL_OW 12
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 2
1999: PUSH
2000: LD_INT 7
2002: PUSH
2003: LD_INT 5
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
2033: GO 1950
2035: POP
2036: POP
// MC_InsertProduceList ( base , tmp ) ;
2037: LD_VAR 0 2
2041: PPUSH
2042: LD_VAR 0 3
2046: PPUSH
2047: CALL 75083 0 2
// repeat wait ( 0 0$1 ) ;
2051: LD_INT 35
2053: PPUSH
2054: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_INT 1
2065: PPUSH
2066: CALL 76501 0 2
2070: PUSH
2071: LD_VAR 0 5
2075: GREATEREQUAL
2076: IFFALSE 2051
// wait ( 0 0$30 ) ;
2078: LD_INT 1050
2080: PPUSH
2081: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2085: LD_ADDR_VAR 0 4
2089: PUSH
2090: LD_EXP 42
2094: PUSH
2095: LD_VAR 0 2
2099: ARRAY
2100: PUSH
2101: LD_EXP 42
2105: PUSH
2106: LD_VAR 0 2
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PUSH
2115: LD_INT 34
2117: PUSH
2118: LD_INT 12
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 34
2127: PUSH
2128: LD_INT 13
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 34
2137: PUSH
2138: LD_INT 14
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: PPUSH
2151: CALL_OW 72
2155: DIFF
2156: ST_TO_ADDR
// if not attackers then
2157: LD_VAR 0 4
2161: NOT
2162: IFFALSE 2166
// exit ;
2164: GO 2453
// DialogPowellsAttack ;
2166: CALL 9597 0 0
// powellAttackGroup := attackers ;
2170: LD_ADDR_EXP 12
2174: PUSH
2175: LD_VAR 0 4
2179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2180: LD_ADDR_EXP 42
2184: PUSH
2185: LD_EXP 42
2189: PPUSH
2190: LD_VAR 0 2
2194: PPUSH
2195: LD_EXP 42
2199: PUSH
2200: LD_VAR 0 2
2204: ARRAY
2205: PUSH
2206: LD_VAR 0 4
2210: DIFF
2211: PPUSH
2212: CALL_OW 1
2216: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2217: LD_EXP 9
2221: PUSH
2222: LD_INT 16
2224: PPUSH
2225: LD_INT 81
2227: PUSH
2228: LD_INT 4
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PPUSH
2235: CALL_OW 70
2239: AND
2240: IFFALSE 2259
// ComAgressiveMove ( attackers , 135 , 21 ) else
2242: LD_VAR 0 4
2246: PPUSH
2247: LD_INT 135
2249: PPUSH
2250: LD_INT 21
2252: PPUSH
2253: CALL_OW 114
2257: GO 2274
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2259: LD_VAR 0 4
2263: PPUSH
2264: LD_INT 146
2266: PPUSH
2267: LD_INT 103
2269: PPUSH
2270: CALL_OW 114
// wait ( 0 0$5 ) ;
2274: LD_INT 175
2276: PPUSH
2277: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2281: LD_INT 35
2283: PPUSH
2284: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2288: LD_VAR 0 4
2292: PPUSH
2293: LD_INT 60
2295: PUSH
2296: EMPTY
2297: LIST
2298: PPUSH
2299: CALL_OW 72
2303: NOT
2304: IFFALSE 2281
// if FilterAllUnits ( [ f_side , 3 ] ) then
2306: LD_INT 22
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: IFFALSE 2339
// ComAgressiveMove ( attackers , 102 , 116 ) else
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 102
2329: PPUSH
2330: LD_INT 116
2332: PPUSH
2333: CALL_OW 114
2337: GO 2354
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 66
2346: PPUSH
2347: LD_INT 41
2349: PPUSH
2350: CALL_OW 114
// wait ( 0 0$10 ) ;
2354: LD_INT 350
2356: PPUSH
2357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2361: LD_INT 35
2363: PPUSH
2364: CALL_OW 67
// for i in attackers do
2368: LD_ADDR_VAR 0 1
2372: PUSH
2373: LD_VAR 0 4
2377: PUSH
2378: FOR_IN
2379: IFFALSE 2429
// if not HasTask ( i ) then
2381: LD_VAR 0 1
2385: PPUSH
2386: CALL_OW 314
2390: NOT
2391: IFFALSE 2427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 81
2400: PUSH
2401: LD_INT 4
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PPUSH
2408: CALL_OW 69
2412: PPUSH
2413: LD_VAR 0 1
2417: PPUSH
2418: CALL_OW 74
2422: PPUSH
2423: CALL_OW 115
2427: GO 2378
2429: POP
2430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2431: LD_VAR 0 4
2435: PPUSH
2436: LD_INT 50
2438: PUSH
2439: EMPTY
2440: LIST
2441: PPUSH
2442: CALL_OW 72
2446: NOT
2447: IFFALSE 2361
// DialogPowellsAttackFailed ;
2449: CALL 9862 0 0
// end ;
2453: PPOPN 5
2455: END
// every 0 0$2 do var vehicles , mechs , i ;
2456: GO 2458
2458: DISABLE
2459: LD_INT 0
2461: PPUSH
2462: PPUSH
2463: PPUSH
// begin enable ;
2464: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2465: LD_ADDR_VAR 0 1
2469: PUSH
2470: LD_INT 22
2472: PUSH
2473: LD_INT 1
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 21
2482: PUSH
2483: LD_INT 2
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 3
2492: PUSH
2493: LD_INT 24
2495: PUSH
2496: LD_INT 1000
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: PUSH
2507: LD_INT 92
2509: PUSH
2510: LD_INT 191
2512: PUSH
2513: LD_INT 140
2515: PUSH
2516: LD_INT 10
2518: PUSH
2519: EMPTY
2520: LIST
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 69
2535: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_INT 22
2543: PUSH
2544: LD_INT 4
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: PUSH
2551: LD_INT 25
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PPUSH
2565: CALL_OW 69
2569: ST_TO_ADDR
// if not mechs then
2570: LD_VAR 0 2
2574: NOT
2575: IFFALSE 2579
// exit ;
2577: GO 2753
// if mc_remote_driver [ 1 ] then
2579: LD_EXP 63
2583: PUSH
2584: LD_INT 1
2586: ARRAY
2587: IFFALSE 2609
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_VAR 0 2
2598: PUSH
2599: LD_EXP 63
2603: PUSH
2604: LD_INT 1
2606: ARRAY
2607: DIFF
2608: ST_TO_ADDR
// if not mechs then
2609: LD_VAR 0 2
2613: NOT
2614: IFFALSE 2618
// exit ;
2616: GO 2753
// if vehicles then
2618: LD_VAR 0 1
2622: IFFALSE 2710
// begin for i in mechs do
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: LD_VAR 0 2
2633: PUSH
2634: FOR_IN
2635: IFFALSE 2706
// begin if GetTag ( i ) <> 120 then
2637: LD_VAR 0 3
2641: PPUSH
2642: CALL_OW 110
2646: PUSH
2647: LD_INT 120
2649: NONEQUAL
2650: IFFALSE 2664
// SetTag ( i , 120 ) ;
2652: LD_VAR 0 3
2656: PPUSH
2657: LD_INT 120
2659: PPUSH
2660: CALL_OW 109
// if IsInUnit ( i ) then
2664: LD_VAR 0 3
2668: PPUSH
2669: CALL_OW 310
2673: IFFALSE 2686
// ComExitBuilding ( i ) else
2675: LD_VAR 0 3
2679: PPUSH
2680: CALL_OW 122
2684: GO 2704
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2686: LD_VAR 0 3
2690: PPUSH
2691: LD_VAR 0 1
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 129
// end ;
2704: GO 2634
2706: POP
2707: POP
// end else
2708: GO 2753
// if FilterByTag ( mechs , 120 ) then
2710: LD_VAR 0 2
2714: PPUSH
2715: LD_INT 120
2717: PPUSH
2718: CALL 45259 0 2
2722: IFFALSE 2753
// begin for i in mechs do
2724: LD_ADDR_VAR 0 3
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: FOR_IN
2735: IFFALSE 2751
// begin SetTag ( i , 0 ) ;
2737: LD_VAR 0 3
2741: PPUSH
2742: LD_INT 0
2744: PPUSH
2745: CALL_OW 109
// end ;
2749: GO 2734
2751: POP
2752: POP
// end ; end ;
2753: PPOPN 3
2755: END
// every 0 0$2 do var people , sci , i ;
2756: GO 2758
2758: DISABLE
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 1
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 21
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 3
2792: PUSH
2793: LD_INT 24
2795: PUSH
2796: LD_INT 1000
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: LD_INT 92
2809: PUSH
2810: LD_INT 188
2812: PUSH
2813: LD_INT 112
2815: PUSH
2816: LD_INT 10
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: LIST
2829: LIST
2830: PPUSH
2831: CALL_OW 69
2835: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2836: LD_ADDR_VAR 0 2
2840: PUSH
2841: LD_INT 22
2843: PUSH
2844: LD_INT 4
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: LD_INT 25
2853: PUSH
2854: LD_INT 4
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 69
2869: ST_TO_ADDR
// if not sci then
2870: LD_VAR 0 2
2874: NOT
2875: IFFALSE 2879
// exit ;
2877: GO 3014
// if people then
2879: LD_VAR 0 1
2883: IFFALSE 2971
// begin for i in sci do
2885: LD_ADDR_VAR 0 3
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2967
// begin if GetTag ( i ) <> 102 then
2898: LD_VAR 0 3
2902: PPUSH
2903: CALL_OW 110
2907: PUSH
2908: LD_INT 102
2910: NONEQUAL
2911: IFFALSE 2925
// SetTag ( i , 102 ) ;
2913: LD_VAR 0 3
2917: PPUSH
2918: LD_INT 102
2920: PPUSH
2921: CALL_OW 109
// if IsInUnit ( i ) then
2925: LD_VAR 0 3
2929: PPUSH
2930: CALL_OW 310
2934: IFFALSE 2947
// ComExitBuilding ( i ) else
2936: LD_VAR 0 3
2940: PPUSH
2941: CALL_OW 122
2945: GO 2965
// ComHeal ( i , people [ 1 ] ) ;
2947: LD_VAR 0 3
2951: PPUSH
2952: LD_VAR 0 1
2956: PUSH
2957: LD_INT 1
2959: ARRAY
2960: PPUSH
2961: CALL_OW 128
// end ;
2965: GO 2895
2967: POP
2968: POP
// end else
2969: GO 3014
// if FilterByTag ( sci , 102 ) then
2971: LD_VAR 0 2
2975: PPUSH
2976: LD_INT 102
2978: PPUSH
2979: CALL 45259 0 2
2983: IFFALSE 3014
// begin for i in sci do
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_VAR 0 2
2994: PUSH
2995: FOR_IN
2996: IFFALSE 3012
// begin SetTag ( i , 0 ) ;
2998: LD_VAR 0 3
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 109
// end ;
3010: GO 2995
3012: POP
3013: POP
// end ; end ;
3014: PPOPN 3
3016: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3017: LD_INT 22
3019: PUSH
3020: LD_INT 4
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 33
3029: PUSH
3030: LD_INT 2
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 50
3039: PUSH
3040: EMPTY
3041: LIST
3042: PUSH
3043: LD_INT 3
3045: PUSH
3046: LD_INT 61
3048: PUSH
3049: EMPTY
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PPUSH
3062: CALL_OW 69
3066: IFFALSE 3157
3068: GO 3070
3070: DISABLE
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
// begin enable ;
3075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3076: LD_ADDR_VAR 0 2
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 4
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 33
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: EMPTY
3105: LIST
3106: PUSH
3107: LD_INT 3
3109: PUSH
3110: LD_INT 61
3112: PUSH
3113: EMPTY
3114: LIST
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: CALL_OW 69
3130: ST_TO_ADDR
// for i in tmp do
3131: LD_ADDR_VAR 0 1
3135: PUSH
3136: LD_VAR 0 2
3140: PUSH
3141: FOR_IN
3142: IFFALSE 3155
// Connect ( i ) ;
3144: LD_VAR 0 1
3148: PPUSH
3149: CALL 18961 0 1
3153: GO 3141
3155: POP
3156: POP
// end ; end_of_file
3157: PPOPN 2
3159: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3160: LD_INT 0
3162: PPUSH
3163: PPUSH
3164: PPUSH
3165: PPUSH
3166: PPUSH
3167: PPUSH
// gensher_side := 2 ;
3168: LD_ADDR_EXP 14
3172: PUSH
3173: LD_INT 2
3175: ST_TO_ADDR
// uc_side := gensher_side ;
3176: LD_ADDR_OWVAR 20
3180: PUSH
3181: LD_EXP 14
3185: ST_TO_ADDR
// uc_nation := 2 ;
3186: LD_ADDR_OWVAR 21
3190: PUSH
3191: LD_INT 2
3193: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3194: LD_ADDR_VAR 0 6
3198: PUSH
3199: LD_INT 5
3201: PUSH
3202: LD_INT 42
3204: PUSH
3205: LD_INT 29
3207: PUSH
3208: LD_INT 5
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 5
3219: PUSH
3220: LD_INT 36
3222: PUSH
3223: LD_INT 40
3225: PUSH
3226: LD_INT 5
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 13
3240: PUSH
3241: LD_INT 18
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: LD_INT 10
3249: PUSH
3250: LD_INT 15
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 27
3263: PUSH
3264: LD_INT 17
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 29
3281: PUSH
3282: LD_INT 56
3284: PUSH
3285: LD_INT 23
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: PUSH
3297: LD_INT 3
3299: PUSH
3300: LD_INT 11
3302: PUSH
3303: LD_INT 7
3305: PUSH
3306: LD_INT 2
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 27
3317: PUSH
3318: LD_INT 20
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: LD_INT 0
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 27
3335: PUSH
3336: LD_INT 23
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: LD_INT 0
3344: PUSH
3345: EMPTY
3346: LIST
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 27
3353: PUSH
3354: LD_INT 26
3356: PUSH
3357: LD_INT 3
3359: PUSH
3360: LD_INT 0
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 6
3371: PUSH
3372: LD_INT 17
3374: PUSH
3375: LD_INT 27
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 13
3383: PUSH
3384: LD_INT 11
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 27
3400: PUSH
3401: LD_INT 44
3403: PUSH
3404: LD_INT 5
3406: PUSH
3407: LD_INT 27
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: PUSH
3417: LD_INT 32
3419: PUSH
3420: LD_INT 41
3422: PUSH
3423: LD_INT 41
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: LD_INT 27
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 32
3441: PUSH
3442: LD_INT 45
3444: PUSH
3445: LD_INT 24
3447: PUSH
3448: LD_INT 5
3450: PUSH
3451: LD_INT 28
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 32
3463: PUSH
3464: LD_INT 48
3466: PUSH
3467: LD_INT 19
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 28
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: PUSH
3483: LD_INT 32
3485: PUSH
3486: LD_INT 41
3488: PUSH
3489: LD_INT 3
3491: PUSH
3492: LD_INT 4
3494: PUSH
3495: LD_INT 28
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 5
3507: PUSH
3508: LD_INT 44
3510: PUSH
3511: LD_INT 9
3513: PUSH
3514: LD_INT 4
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 30
3525: PUSH
3526: LD_INT 52
3528: PUSH
3529: LD_INT 40
3531: PUSH
3532: LD_INT 3
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: ST_TO_ADDR
// for i in list do
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: FOR_IN
3571: IFFALSE 3749
// begin uc_side := 2 ;
3573: LD_ADDR_OWVAR 20
3577: PUSH
3578: LD_INT 2
3580: ST_TO_ADDR
// uc_nation := 2 ;
3581: LD_ADDR_OWVAR 21
3585: PUSH
3586: LD_INT 2
3588: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3589: LD_ADDR_OWVAR 42
3593: PUSH
3594: LD_VAR 0 2
3598: PUSH
3599: LD_INT 1
3601: ARRAY
3602: ST_TO_ADDR
// bc_kind1 := - 1 ;
3603: LD_ADDR_OWVAR 44
3607: PUSH
3608: LD_INT 1
3610: NEG
3611: ST_TO_ADDR
// bc_kind2 := - 1 ;
3612: LD_ADDR_OWVAR 45
3616: PUSH
3617: LD_INT 1
3619: NEG
3620: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3621: LD_VAR 0 2
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: PUSH
3630: LD_INT 6
3632: EQUAL
3633: IFFALSE 3671
// begin bc_type := b_lab_full ;
3635: LD_ADDR_OWVAR 42
3639: PUSH
3640: LD_INT 8
3642: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3643: LD_ADDR_OWVAR 44
3647: PUSH
3648: LD_VAR 0 2
3652: PUSH
3653: LD_INT 5
3655: ARRAY
3656: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3657: LD_ADDR_OWVAR 45
3661: PUSH
3662: LD_VAR 0 2
3666: PUSH
3667: LD_INT 6
3669: ARRAY
3670: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3671: LD_ADDR_VAR 0 3
3675: PUSH
3676: LD_VAR 0 2
3680: PUSH
3681: LD_INT 2
3683: ARRAY
3684: PPUSH
3685: LD_VAR 0 2
3689: PUSH
3690: LD_INT 3
3692: ARRAY
3693: PPUSH
3694: LD_VAR 0 2
3698: PUSH
3699: LD_INT 4
3701: ARRAY
3702: PPUSH
3703: CALL_OW 47
3707: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 1
3715: ARRAY
3716: PUSH
3717: LD_INT 33
3719: PUSH
3720: LD_INT 32
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: IN
3727: IFFALSE 3747
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3729: LD_VAR 0 3
3733: PPUSH
3734: LD_VAR 0 2
3738: PUSH
3739: LD_INT 5
3741: ARRAY
3742: PPUSH
3743: CALL_OW 431
// end ;
3747: GO 3570
3749: POP
3750: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3751: LD_ADDR_VAR 0 4
3755: PUSH
3756: LD_INT 7
3758: PPUSH
3759: LD_INT 2
3761: PPUSH
3762: LD_STRING 
3764: PPUSH
3765: LD_INT 8
3767: PUSH
3768: LD_INT 7
3770: PUSH
3771: LD_INT 6
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: LD_INT 11500
3787: PUSH
3788: LD_INT 1100
3790: PUSH
3791: LD_INT 60
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: LIST
3798: PPUSH
3799: LD_INT 6
3801: PUSH
3802: LD_INT 6
3804: PUSH
3805: LD_INT 6
3807: PUSH
3808: LD_INT 6
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL 19314 0 6
3821: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3822: LD_ADDR_EXP 23
3826: PUSH
3827: LD_EXP 23
3831: PPUSH
3832: LD_INT 2
3834: PPUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_INT 2
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 3
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PPUSH
3864: CALL_OW 69
3868: UNION
3869: PPUSH
3870: CALL_OW 1
3874: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3875: LD_ADDR_VAR 0 4
3879: PUSH
3880: LD_INT 22
3882: PUSH
3883: LD_INT 2
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_INT 30
3892: PUSH
3893: LD_INT 31
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PPUSH
3904: CALL_OW 69
3908: ST_TO_ADDR
// for i in tmp do
3909: LD_ADDR_VAR 0 2
3913: PUSH
3914: LD_VAR 0 4
3918: PUSH
3919: FOR_IN
3920: IFFALSE 3990
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 4
3930: PUSH
3931: LD_INT 3
3933: PUSH
3934: LD_INT 3
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: LD_OWVAR 67
3946: ARRAY
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 1
3969: PPUSH
3970: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3974: LD_VAR 0 5
3978: PPUSH
3979: LD_VAR 0 2
3983: PPUSH
3984: CALL_OW 52
// end ;
3988: GO 3919
3990: POP
3991: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3992: LD_ADDR_VAR 0 4
3996: PUSH
3997: LD_INT 15
3999: PPUSH
4000: LD_INT 0
4002: PPUSH
4003: CALL_OW 517
4007: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4008: LD_ADDR_VAR 0 2
4012: PUSH
4013: DOUBLE
4014: LD_INT 1
4016: DEC
4017: ST_TO_ADDR
4018: LD_VAR 0 4
4022: PUSH
4023: LD_INT 1
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4130
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4030: LD_VAR 0 4
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PUSH
4039: LD_VAR 0 2
4043: ARRAY
4044: PPUSH
4045: LD_VAR 0 4
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PUSH
4054: LD_VAR 0 2
4058: ARRAY
4059: PPUSH
4060: LD_INT 2
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4070: LD_ADDR_EXP 3
4074: PUSH
4075: LD_EXP 3
4079: PPUSH
4080: LD_EXP 3
4084: PUSH
4085: LD_INT 1
4087: PLUS
4088: PPUSH
4089: LD_VAR 0 4
4093: PUSH
4094: LD_INT 1
4096: ARRAY
4097: PUSH
4098: LD_VAR 0 2
4102: ARRAY
4103: PUSH
4104: LD_VAR 0 4
4108: PUSH
4109: LD_INT 2
4111: ARRAY
4112: PUSH
4113: LD_VAR 0 2
4117: ARRAY
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: PPUSH
4123: CALL_OW 2
4127: ST_TO_ADDR
// end ;
4128: GO 4027
4130: POP
4131: POP
// if Difficulty > 1 then
4132: LD_OWVAR 67
4136: PUSH
4137: LD_INT 1
4139: GREATER
4140: IFFALSE 4282
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4142: LD_ADDR_VAR 0 4
4146: PUSH
4147: LD_INT 19
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL_OW 517
4157: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4158: LD_ADDR_VAR 0 2
4162: PUSH
4163: DOUBLE
4164: LD_INT 1
4166: DEC
4167: ST_TO_ADDR
4168: LD_VAR 0 4
4172: PUSH
4173: LD_INT 1
4175: ARRAY
4176: PUSH
4177: FOR_TO
4178: IFFALSE 4280
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4180: LD_VAR 0 4
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: PUSH
4189: LD_VAR 0 2
4193: ARRAY
4194: PPUSH
4195: LD_VAR 0 4
4199: PUSH
4200: LD_INT 2
4202: ARRAY
4203: PUSH
4204: LD_VAR 0 2
4208: ARRAY
4209: PPUSH
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4220: LD_ADDR_EXP 3
4224: PUSH
4225: LD_EXP 3
4229: PPUSH
4230: LD_EXP 3
4234: PUSH
4235: LD_INT 1
4237: PLUS
4238: PPUSH
4239: LD_VAR 0 4
4243: PUSH
4244: LD_INT 1
4246: ARRAY
4247: PUSH
4248: LD_VAR 0 2
4252: ARRAY
4253: PUSH
4254: LD_VAR 0 4
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PUSH
4263: LD_VAR 0 2
4267: ARRAY
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PPUSH
4273: CALL_OW 2
4277: ST_TO_ADDR
// end ;
4278: GO 4177
4280: POP
4281: POP
// end ; gensherAttackGroup := [ ] ;
4282: LD_ADDR_EXP 15
4286: PUSH
4287: EMPTY
4288: ST_TO_ADDR
// end ;
4289: LD_VAR 0 1
4293: RET
// export function InitMC_Gensher ( ) ; begin
4294: LD_INT 0
4296: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4297: LD_INT 2
4299: PPUSH
4300: LD_INT 2
4302: PPUSH
4303: CALL 76356 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4307: LD_INT 2
4309: PPUSH
4310: LD_INT 9
4312: PPUSH
4313: CALL 76300 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4317: LD_INT 2
4319: PPUSH
4320: LD_INT 56
4322: PUSH
4323: LD_INT 23
4325: PUSH
4326: LD_INT 0
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: LD_INT 52
4336: PUSH
4337: LD_INT 40
4339: PUSH
4340: LD_INT 1
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PPUSH
4352: CALL 75359 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4356: LD_INT 2
4358: PPUSH
4359: LD_INT 27
4361: PUSH
4362: LD_INT 28
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PPUSH
4369: CALL 76188 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4373: LD_INT 2
4375: PPUSH
4376: LD_INT 8
4378: PPUSH
4379: CALL 75870 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4383: LD_INT 2
4385: PPUSH
4386: LD_INT 7
4388: PPUSH
4389: CALL 75601 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4393: LD_INT 2
4395: PPUSH
4396: LD_INT 4
4398: PPUSH
4399: CALL 75220 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4403: LD_INT 2
4405: PPUSH
4406: LD_INT 13
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: LD_INT 31
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: LD_INT 13
4426: PUSH
4427: LD_INT 2
4429: PUSH
4430: LD_INT 1
4432: PUSH
4433: LD_INT 31
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 14
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 27
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 14
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: LD_INT 2
4468: PUSH
4469: LD_INT 27
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 14
4480: PUSH
4481: LD_INT 1
4483: PUSH
4484: LD_INT 2
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 14
4498: PUSH
4499: LD_INT 1
4501: PUSH
4502: LD_INT 2
4504: PUSH
4505: LD_INT 26
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL 75035 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4526: LD_INT 2
4528: PPUSH
4529: LD_INT 11
4531: PPUSH
4532: LD_INT 7
4534: PPUSH
4535: LD_INT 2
4537: PPUSH
4538: LD_INT 23
4540: PUSH
4541: LD_INT 16
4543: PUSH
4544: LD_INT 17
4546: PUSH
4547: LD_INT 18
4549: PUSH
4550: LD_INT 22
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PPUSH
4560: CALL 75982 0 5
// end ;
4564: LD_VAR 0 1
4568: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4569: LD_EXP 3
4573: PUSH
4574: LD_INT 15
4576: PPUSH
4577: LD_INT 81
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 70
4591: AND
4592: IFFALSE 4805
4594: GO 4596
4596: DISABLE
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
// begin enable ;
4604: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4605: LD_ADDR_VAR 0 3
4609: PUSH
4610: LD_INT 15
4612: PPUSH
4613: LD_INT 81
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 70
4627: ST_TO_ADDR
// if not tmp then
4628: LD_VAR 0 3
4632: NOT
4633: IFFALSE 4637
// exit ;
4635: GO 4805
// for i in tmp do
4637: LD_ADDR_VAR 0 1
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: FOR_IN
4648: IFFALSE 4803
// begin x := GetX ( i ) ;
4650: LD_ADDR_VAR 0 4
4654: PUSH
4655: LD_VAR 0 1
4659: PPUSH
4660: CALL_OW 250
4664: ST_TO_ADDR
// y := GetY ( i ) ;
4665: LD_ADDR_VAR 0 5
4669: PUSH
4670: LD_VAR 0 1
4674: PPUSH
4675: CALL_OW 251
4679: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4680: LD_VAR 0 4
4684: PPUSH
4685: LD_VAR 0 5
4689: PPUSH
4690: CALL_OW 458
4694: IFFALSE 4801
// begin LaunchMineAtPos ( x , y , 2 ) ;
4696: LD_VAR 0 4
4700: PPUSH
4701: LD_VAR 0 5
4705: PPUSH
4706: LD_INT 2
4708: PPUSH
4709: CALL_OW 456
// for j = 1 to staticMines do
4713: LD_ADDR_VAR 0 2
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_EXP 3
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4799
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4731: LD_EXP 3
4735: PUSH
4736: LD_VAR 0 2
4740: ARRAY
4741: PUSH
4742: LD_INT 1
4744: ARRAY
4745: PUSH
4746: LD_VAR 0 4
4750: EQUAL
4751: PUSH
4752: LD_EXP 3
4756: PUSH
4757: LD_VAR 0 2
4761: ARRAY
4762: PUSH
4763: LD_INT 2
4765: ARRAY
4766: PUSH
4767: LD_VAR 0 5
4771: EQUAL
4772: AND
4773: IFFALSE 4797
// begin staticMines := Delete ( staticMines , j ) ;
4775: LD_ADDR_EXP 3
4779: PUSH
4780: LD_EXP 3
4784: PPUSH
4785: LD_VAR 0 2
4789: PPUSH
4790: CALL_OW 3
4794: ST_TO_ADDR
// break ;
4795: GO 4799
// end ;
4797: GO 4728
4799: POP
4800: POP
// end ; end ;
4801: GO 4647
4803: POP
4804: POP
// end ;
4805: PPOPN 5
4807: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4808: LD_INT 7
4810: PPUSH
4811: CALL_OW 302
4815: PUSH
4816: LD_EXP 4
4820: NOT
4821: AND
4822: IFFALSE 5426
4824: GO 4826
4826: DISABLE
4827: LD_INT 0
4829: PPUSH
4830: PPUSH
4831: PPUSH
4832: PPUSH
4833: PPUSH
// begin enable ;
4834: ENABLE
// base := 2 ;
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_INT 2
4842: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4843: LD_ADDR_VAR 0 3
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 27
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 27
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 14
4886: PUSH
4887: LD_INT 1
4889: PUSH
4890: LD_INT 2
4892: PUSH
4893: LD_EXP 72
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 14
4906: PUSH
4907: LD_INT 1
4909: PUSH
4910: LD_INT 2
4912: PUSH
4913: LD_INT 26
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: LIST
4926: LIST
4927: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4928: LD_ADDR_VAR 0 5
4932: PUSH
4933: LD_VAR 0 5
4937: PUSH
4938: LD_OWVAR 1
4942: PUSH
4943: LD_INT 21000
4945: DIV
4946: PLUS
4947: ST_TO_ADDR
// if amount > 8 then
4948: LD_VAR 0 5
4952: PUSH
4953: LD_INT 8
4955: GREATER
4956: IFFALSE 4966
// amount := 8 ;
4958: LD_ADDR_VAR 0 5
4962: PUSH
4963: LD_INT 8
4965: ST_TO_ADDR
// for i = 1 to amount do
4966: LD_ADDR_VAR 0 1
4970: PUSH
4971: DOUBLE
4972: LD_INT 1
4974: DEC
4975: ST_TO_ADDR
4976: LD_VAR 0 5
4980: PUSH
4981: FOR_TO
4982: IFFALSE 5070
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4984: LD_ADDR_VAR 0 3
4988: PUSH
4989: LD_VAR 0 3
4993: PPUSH
4994: LD_VAR 0 3
4998: PUSH
4999: LD_INT 1
5001: PLUS
5002: PPUSH
5003: LD_INT 14
5005: PUSH
5006: LD_INT 13
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 1
5015: PPUSH
5016: LD_INT 2
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: PUSH
5025: LD_INT 1
5027: PUSH
5028: LD_INT 2
5030: PUSH
5031: LD_INT 28
5033: PUSH
5034: LD_INT 25
5036: PUSH
5037: LD_INT 27
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: PUSH
5045: LD_INT 1
5047: PPUSH
5048: LD_INT 3
5050: PPUSH
5051: CALL_OW 12
5055: ARRAY
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 2
5067: ST_TO_ADDR
5068: GO 4981
5070: POP
5071: POP
// MC_InsertProduceList ( base , tmp ) ;
5072: LD_VAR 0 2
5076: PPUSH
5077: LD_VAR 0 3
5081: PPUSH
5082: CALL 75083 0 2
// repeat wait ( 0 0$1 ) ;
5086: LD_INT 35
5088: PPUSH
5089: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5093: LD_VAR 0 2
5097: PPUSH
5098: LD_INT 1
5100: PPUSH
5101: CALL 76501 0 2
5105: PUSH
5106: LD_VAR 0 5
5110: GREATEREQUAL
5111: IFFALSE 5086
// wait ( 0 0$30 ) ;
5113: LD_INT 1050
5115: PPUSH
5116: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5120: LD_ADDR_VAR 0 4
5124: PUSH
5125: LD_EXP 42
5129: PUSH
5130: LD_VAR 0 2
5134: ARRAY
5135: PUSH
5136: LD_EXP 42
5140: PUSH
5141: LD_VAR 0 2
5145: ARRAY
5146: PPUSH
5147: LD_INT 2
5149: PUSH
5150: LD_INT 34
5152: PUSH
5153: LD_INT 31
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 34
5162: PUSH
5163: LD_INT 32
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 34
5172: PUSH
5173: LD_EXP 73
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: LIST
5186: LIST
5187: PPUSH
5188: CALL_OW 72
5192: DIFF
5193: ST_TO_ADDR
// if not attackers then
5194: LD_VAR 0 4
5198: NOT
5199: IFFALSE 5203
// exit ;
5201: GO 5426
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5203: LD_ADDR_EXP 42
5207: PUSH
5208: LD_EXP 42
5212: PPUSH
5213: LD_VAR 0 2
5217: PPUSH
5218: LD_EXP 42
5222: PUSH
5223: LD_VAR 0 2
5227: ARRAY
5228: PUSH
5229: LD_VAR 0 4
5233: DIFF
5234: PPUSH
5235: CALL_OW 1
5239: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5240: LD_VAR 0 4
5244: PPUSH
5245: LD_INT 107
5247: PPUSH
5248: LD_INT 74
5250: PPUSH
5251: CALL_OW 114
// wait ( 0 0$5 ) ;
5255: LD_INT 175
5257: PPUSH
5258: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5262: LD_INT 35
5264: PPUSH
5265: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5269: LD_VAR 0 4
5273: PPUSH
5274: LD_INT 60
5276: PUSH
5277: EMPTY
5278: LIST
5279: PPUSH
5280: CALL_OW 72
5284: NOT
5285: IFFALSE 5262
// if rand ( 0 , 1 ) then
5287: LD_INT 0
5289: PPUSH
5290: LD_INT 1
5292: PPUSH
5293: CALL_OW 12
5297: IFFALSE 5316
// ComAgressiveMove ( attackers , 155 , 108 ) else
5299: LD_VAR 0 4
5303: PPUSH
5304: LD_INT 155
5306: PPUSH
5307: LD_INT 108
5309: PPUSH
5310: CALL_OW 114
5314: GO 5331
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5316: LD_VAR 0 4
5320: PPUSH
5321: LD_INT 149
5323: PPUSH
5324: LD_INT 55
5326: PPUSH
5327: CALL_OW 114
// wait ( 0 0$10 ) ;
5331: LD_INT 350
5333: PPUSH
5334: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5338: LD_INT 35
5340: PPUSH
5341: CALL_OW 67
// for i in attackers do
5345: LD_ADDR_VAR 0 1
5349: PUSH
5350: LD_VAR 0 4
5354: PUSH
5355: FOR_IN
5356: IFFALSE 5406
// if not HasTask ( i ) then
5358: LD_VAR 0 1
5362: PPUSH
5363: CALL_OW 314
5367: NOT
5368: IFFALSE 5404
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5370: LD_VAR 0 1
5374: PPUSH
5375: LD_INT 81
5377: PUSH
5378: LD_INT 2
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: PPUSH
5390: LD_VAR 0 1
5394: PPUSH
5395: CALL_OW 74
5399: PPUSH
5400: CALL_OW 115
5404: GO 5355
5406: POP
5407: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5408: LD_VAR 0 4
5412: PPUSH
5413: LD_INT 50
5415: PUSH
5416: EMPTY
5417: LIST
5418: PPUSH
5419: CALL_OW 72
5423: NOT
5424: IFFALSE 5338
// end ;
5426: PPOPN 5
5428: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5429: LD_EXP 4
5433: NOT
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 191100
5442: LESS
5443: AND
5444: IFFALSE 6116
5446: GO 5448
5448: DISABLE
5449: LD_INT 0
5451: PPUSH
5452: PPUSH
5453: PPUSH
// begin enable ;
5454: ENABLE
// tmp := [ ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: EMPTY
5461: ST_TO_ADDR
// if tick < 35 35$00 then
5462: LD_OWVAR 1
5466: PUSH
5467: LD_INT 73500
5469: LESS
5470: IFFALSE 5668
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5472: LD_ADDR_VAR 0 1
5476: PUSH
5477: DOUBLE
5478: LD_INT 1
5480: DEC
5481: ST_TO_ADDR
5482: LD_INT 4
5484: PUSH
5485: LD_INT 5
5487: PUSH
5488: LD_INT 5
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5664
// begin uc_side := 2 ;
5505: LD_ADDR_OWVAR 20
5509: PUSH
5510: LD_INT 2
5512: ST_TO_ADDR
// uc_nation := 2 ;
5513: LD_ADDR_OWVAR 21
5517: PUSH
5518: LD_INT 2
5520: ST_TO_ADDR
// InitHC_All ( ) ;
5521: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: LD_INT 5
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 7
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: PUSH
5545: LD_OWVAR 67
5549: ARRAY
5550: PPUSH
5551: CALL_OW 380
// un := CreateHuman ;
5555: LD_ADDR_VAR 0 2
5559: PUSH
5560: CALL_OW 44
5564: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5565: LD_VAR 0 2
5569: PPUSH
5570: LD_INT 17
5572: PPUSH
5573: LD_INT 0
5575: PPUSH
5576: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5580: LD_VAR 0 2
5584: PPUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 1
5597: PPUSH
5598: LD_INT 2
5600: PPUSH
5601: CALL_OW 12
5605: ARRAY
5606: PPUSH
5607: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5611: LD_VAR 0 2
5615: PPUSH
5616: LD_INT 111
5618: PPUSH
5619: LD_INT 34
5621: PPUSH
5622: CALL_OW 114
// wait ( 0 0$2 ) ;
5626: LD_INT 70
5628: PPUSH
5629: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5633: LD_ADDR_VAR 0 3
5637: PUSH
5638: LD_VAR 0 3
5642: PPUSH
5643: LD_VAR 0 3
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: PPUSH
5652: LD_VAR 0 2
5656: PPUSH
5657: CALL_OW 1
5661: ST_TO_ADDR
// end ;
5662: GO 5502
5664: POP
5665: POP
// end else
5666: GO 5809
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5668: LD_ADDR_VAR 0 1
5672: PUSH
5673: DOUBLE
5674: LD_INT 1
5676: DEC
5677: ST_TO_ADDR
5678: LD_INT 4
5680: PUSH
5681: LD_INT 5
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_OWVAR 67
5696: ARRAY
5697: PUSH
5698: FOR_TO
5699: IFFALSE 5807
// begin uc_side := 2 ;
5701: LD_ADDR_OWVAR 20
5705: PUSH
5706: LD_INT 2
5708: ST_TO_ADDR
// uc_nation := 0 ;
5709: LD_ADDR_OWVAR 21
5713: PUSH
5714: LD_INT 0
5716: ST_TO_ADDR
// InitHC_All ( ) ;
5717: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5721: LD_ADDR_OWVAR 28
5725: PUSH
5726: LD_INT 17
5728: ST_TO_ADDR
// un := CreateHuman ;
5729: LD_ADDR_VAR 0 2
5733: PUSH
5734: CALL_OW 44
5738: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5739: LD_VAR 0 2
5743: PPUSH
5744: LD_INT 17
5746: PPUSH
5747: LD_INT 0
5749: PPUSH
5750: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5754: LD_VAR 0 2
5758: PPUSH
5759: LD_INT 110
5761: PPUSH
5762: LD_INT 33
5764: PPUSH
5765: CALL_OW 114
// wait ( 0 0$2 ) ;
5769: LD_INT 70
5771: PPUSH
5772: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5776: LD_ADDR_VAR 0 3
5780: PUSH
5781: LD_VAR 0 3
5785: PPUSH
5786: LD_VAR 0 3
5790: PUSH
5791: LD_INT 1
5793: PLUS
5794: PPUSH
5795: LD_VAR 0 2
5799: PPUSH
5800: CALL_OW 1
5804: ST_TO_ADDR
// end ;
5805: GO 5698
5807: POP
5808: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5809: LD_ADDR_VAR 0 1
5813: PUSH
5814: DOUBLE
5815: LD_INT 1
5817: DEC
5818: ST_TO_ADDR
5819: LD_INT 3
5821: PUSH
5822: LD_INT 4
5824: PUSH
5825: LD_INT 5
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_OWVAR 67
5837: ARRAY
5838: PUSH
5839: FOR_TO
5840: IFFALSE 6005
// begin uc_side := 2 ;
5842: LD_ADDR_OWVAR 20
5846: PUSH
5847: LD_INT 2
5849: ST_TO_ADDR
// uc_nation := 2 ;
5850: LD_ADDR_OWVAR 21
5854: PUSH
5855: LD_INT 2
5857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5858: LD_INT 14
5860: PPUSH
5861: LD_INT 3
5863: PPUSH
5864: LD_INT 5
5866: PPUSH
5867: LD_INT 29
5869: PUSH
5870: LD_INT 28
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: CALL_OW 12
5891: ARRAY
5892: PPUSH
5893: LD_INT 90
5895: PPUSH
5896: CALL 15868 0 5
// un := CreateVehicle ;
5900: LD_ADDR_VAR 0 2
5904: PUSH
5905: CALL_OW 45
5909: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5910: LD_VAR 0 2
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5922: LD_VAR 0 2
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_INT 0
5932: PPUSH
5933: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5937: LD_VAR 0 2
5941: PPUSH
5942: LD_INT 66
5944: PPUSH
5945: LD_INT 23
5947: PPUSH
5948: CALL_OW 111
// wait ( 0 0$3 ) ;
5952: LD_INT 105
5954: PPUSH
5955: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_INT 147
5966: PPUSH
5967: LD_INT 103
5969: PPUSH
5970: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5974: LD_ADDR_VAR 0 3
5978: PUSH
5979: LD_VAR 0 3
5983: PPUSH
5984: LD_VAR 0 3
5988: PUSH
5989: LD_INT 1
5991: PLUS
5992: PPUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: CALL_OW 1
6002: ST_TO_ADDR
// end ;
6003: GO 5839
6005: POP
6006: POP
// if not tmp then
6007: LD_VAR 0 3
6011: NOT
6012: IFFALSE 6016
// exit ;
6014: GO 6116
// wait ( 0 0$5 ) ;
6016: LD_INT 175
6018: PPUSH
6019: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6023: LD_INT 70
6025: PPUSH
6026: CALL_OW 67
// for i in tmp do
6030: LD_ADDR_VAR 0 1
6034: PUSH
6035: LD_VAR 0 3
6039: PUSH
6040: FOR_IN
6041: IFFALSE 6107
// begin if not IsOk ( i ) then
6043: LD_VAR 0 1
6047: PPUSH
6048: CALL_OW 302
6052: NOT
6053: IFFALSE 6071
// tmp := tmp diff i ;
6055: LD_ADDR_VAR 0 3
6059: PUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_VAR 0 1
6069: DIFF
6070: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6071: LD_VAR 0 1
6075: PPUSH
6076: LD_INT 81
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 69
6090: PPUSH
6091: LD_VAR 0 1
6095: PPUSH
6096: CALL_OW 74
6100: PPUSH
6101: CALL_OW 115
// end ;
6105: GO 6040
6107: POP
6108: POP
// until not tmp ;
6109: LD_VAR 0 3
6113: NOT
6114: IFFALSE 6023
// end ;
6116: PPOPN 3
6118: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6119: LD_OWVAR 67
6123: PUSH
6124: LD_INT 1
6126: GREATER
6127: IFFALSE 6225
6129: GO 6131
6131: DISABLE
6132: LD_INT 0
6134: PPUSH
// begin uc_side := 2 ;
6135: LD_ADDR_OWVAR 20
6139: PUSH
6140: LD_INT 2
6142: ST_TO_ADDR
// uc_nation := 2 ;
6143: LD_ADDR_OWVAR 21
6147: PUSH
6148: LD_INT 2
6150: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6151: LD_INT 0
6153: PPUSH
6154: LD_INT 4
6156: PPUSH
6157: LD_INT 6
6159: PPUSH
6160: CALL_OW 380
// un := CreateHuman ;
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: CALL_OW 44
6173: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 88
6181: PPUSH
6182: LD_INT 1
6184: PPUSH
6185: LD_INT 2
6187: PPUSH
6188: LD_INT 0
6190: PPUSH
6191: CALL 49829 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 130
6202: PPUSH
6203: LD_INT 35
6205: PPUSH
6206: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6210: LD_VAR 0 1
6214: PPUSH
6215: LD_INT 132
6217: PPUSH
6218: LD_INT 39
6220: PPUSH
6221: CALL_OW 218
// end ;
6225: PPOPN 1
6227: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6228: LD_INT 22
6230: PUSH
6231: LD_INT 2
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 33
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 50
6250: PUSH
6251: EMPTY
6252: LIST
6253: PUSH
6254: LD_INT 3
6256: PUSH
6257: LD_INT 61
6259: PUSH
6260: EMPTY
6261: LIST
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: PPUSH
6273: CALL_OW 69
6277: IFFALSE 6368
6279: GO 6281
6281: DISABLE
6282: LD_INT 0
6284: PPUSH
6285: PPUSH
// begin enable ;
6286: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6287: LD_ADDR_VAR 0 2
6291: PUSH
6292: LD_INT 22
6294: PUSH
6295: LD_INT 2
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 33
6304: PUSH
6305: LD_INT 2
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: LD_INT 50
6314: PUSH
6315: EMPTY
6316: LIST
6317: PUSH
6318: LD_INT 3
6320: PUSH
6321: LD_INT 61
6323: PUSH
6324: EMPTY
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PPUSH
6337: CALL_OW 69
6341: ST_TO_ADDR
// for i in tmp do
6342: LD_ADDR_VAR 0 1
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: FOR_IN
6353: IFFALSE 6366
// Connect ( i ) ;
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL 18961 0 1
6364: GO 6352
6366: POP
6367: POP
// end ; end_of_file
6368: PPOPN 2
6370: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6371: LD_INT 0
6373: PPUSH
6374: PPUSH
6375: PPUSH
6376: PPUSH
6377: PPUSH
6378: PPUSH
// popov_side := 3 ;
6379: LD_ADDR_EXP 17
6383: PUSH
6384: LD_INT 3
6386: ST_TO_ADDR
// uc_side := popov_side ;
6387: LD_ADDR_OWVAR 20
6391: PUSH
6392: LD_EXP 17
6396: ST_TO_ADDR
// uc_nation := 3 ;
6397: LD_ADDR_OWVAR 21
6401: PUSH
6402: LD_INT 3
6404: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6405: LD_ADDR_VAR 0 6
6409: PUSH
6410: LD_INT 5
6412: PUSH
6413: LD_INT 103
6415: PUSH
6416: LD_INT 147
6418: PUSH
6419: LD_INT 3
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 5
6430: PUSH
6431: LD_INT 70
6433: PUSH
6434: LD_INT 117
6436: PUSH
6437: LD_INT 3
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: LD_INT 76
6451: PUSH
6452: LD_INT 145
6454: PUSH
6455: LD_INT 1
6457: PUSH
6458: LD_INT 10
6460: PUSH
6461: LD_INT 11
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 26
6474: PUSH
6475: LD_INT 87
6477: PUSH
6478: LD_INT 144
6480: PUSH
6481: LD_INT 0
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 29
6492: PUSH
6493: LD_INT 86
6495: PUSH
6496: LD_INT 118
6498: PUSH
6499: LD_INT 0
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 29
6510: PUSH
6511: LD_INT 98
6513: PUSH
6514: LD_INT 121
6516: PUSH
6517: LD_INT 0
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 26
6528: PUSH
6529: LD_INT 87
6531: PUSH
6532: LD_INT 147
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 30
6546: PUSH
6547: LD_INT 123
6549: PUSH
6550: LD_INT 151
6552: PUSH
6553: LD_INT 1
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 3
6564: PUSH
6565: LD_INT 94
6567: PUSH
6568: LD_INT 161
6570: PUSH
6571: LD_INT 0
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: LD_INT 6
6582: PUSH
6583: LD_INT 81
6585: PUSH
6586: LD_INT 155
6588: PUSH
6589: LD_INT 1
6591: PUSH
6592: LD_INT 12
6594: PUSH
6595: LD_INT 14
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 26
6608: PUSH
6609: LD_INT 96
6611: PUSH
6612: LD_INT 152
6614: PUSH
6615: LD_INT 0
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 26
6626: PUSH
6627: LD_INT 96
6629: PUSH
6630: LD_INT 149
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 32
6644: PUSH
6645: LD_INT 109
6647: PUSH
6648: LD_INT 142
6650: PUSH
6651: LD_INT 3
6653: PUSH
6654: LD_INT 46
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 32
6666: PUSH
6667: LD_INT 112
6669: PUSH
6670: LD_INT 148
6672: PUSH
6673: LD_INT 3
6675: PUSH
6676: LD_INT 46
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 33
6688: PUSH
6689: LD_INT 120
6691: PUSH
6692: LD_INT 159
6694: PUSH
6695: LD_INT 4
6697: PUSH
6698: LD_INT 45
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 33
6710: PUSH
6711: LD_INT 122
6713: PUSH
6714: LD_INT 163
6716: PUSH
6717: LD_INT 4
6719: PUSH
6720: LD_INT 45
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 33
6732: PUSH
6733: LD_INT 123
6735: PUSH
6736: LD_INT 167
6738: PUSH
6739: LD_INT 4
6741: PUSH
6742: LD_INT 45
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 33
6754: PUSH
6755: LD_INT 59
6757: PUSH
6758: LD_INT 111
6760: PUSH
6761: LD_INT 3
6763: PUSH
6764: LD_INT 45
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 33
6776: PUSH
6777: LD_INT 65
6779: PUSH
6780: LD_INT 111
6782: PUSH
6783: LD_INT 3
6785: PUSH
6786: LD_INT 46
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 33
6798: PUSH
6799: LD_INT 76
6801: PUSH
6802: LD_INT 117
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: LD_INT 45
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 33
6820: PUSH
6821: LD_INT 80
6823: PUSH
6824: LD_INT 119
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: LD_INT 46
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 33
6842: PUSH
6843: LD_INT 87
6845: PUSH
6846: LD_INT 125
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 45
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 92
6867: PUSH
6868: LD_INT 129
6870: PUSH
6871: LD_INT 3
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 28
6882: PUSH
6883: LD_INT 85
6885: PUSH
6886: LD_INT 165
6888: PUSH
6889: LD_INT 0
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 28
6900: PUSH
6901: LD_INT 83
6903: PUSH
6904: LD_INT 161
6906: PUSH
6907: LD_INT 4
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: LIST
6915: PUSH
6916: LD_INT 28
6918: PUSH
6919: LD_INT 91
6921: PUSH
6922: LD_INT 166
6924: PUSH
6925: LD_INT 3
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_INT 28
6936: PUSH
6937: LD_INT 102
6939: PUSH
6940: LD_INT 166
6942: PUSH
6943: LD_INT 2
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: LIST
6974: LIST
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: ST_TO_ADDR
// for i in list do
6981: LD_ADDR_VAR 0 2
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7170
// begin uc_side := 3 ;
6994: LD_ADDR_OWVAR 20
6998: PUSH
6999: LD_INT 3
7001: ST_TO_ADDR
// uc_nation := 3 ;
7002: LD_ADDR_OWVAR 21
7006: PUSH
7007: LD_INT 3
7009: ST_TO_ADDR
// bc_type := i [ 1 ] ;
7010: LD_ADDR_OWVAR 42
7014: PUSH
7015: LD_VAR 0 2
7019: PUSH
7020: LD_INT 1
7022: ARRAY
7023: ST_TO_ADDR
// bc_kind1 := - 1 ;
7024: LD_ADDR_OWVAR 44
7028: PUSH
7029: LD_INT 1
7031: NEG
7032: ST_TO_ADDR
// bc_kind2 := - 1 ;
7033: LD_ADDR_OWVAR 45
7037: PUSH
7038: LD_INT 1
7040: NEG
7041: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7042: LD_VAR 0 2
7046: PUSH
7047: LD_INT 1
7049: ARRAY
7050: PUSH
7051: LD_INT 6
7053: EQUAL
7054: IFFALSE 7092
// begin bc_type := b_lab_full ;
7056: LD_ADDR_OWVAR 42
7060: PUSH
7061: LD_INT 8
7063: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7064: LD_ADDR_OWVAR 44
7068: PUSH
7069: LD_VAR 0 2
7073: PUSH
7074: LD_INT 5
7076: ARRAY
7077: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7078: LD_ADDR_OWVAR 45
7082: PUSH
7083: LD_VAR 0 2
7087: PUSH
7088: LD_INT 6
7090: ARRAY
7091: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7092: LD_ADDR_VAR 0 5
7096: PUSH
7097: LD_VAR 0 2
7101: PUSH
7102: LD_INT 2
7104: ARRAY
7105: PPUSH
7106: LD_VAR 0 2
7110: PUSH
7111: LD_INT 3
7113: ARRAY
7114: PPUSH
7115: LD_VAR 0 2
7119: PUSH
7120: LD_INT 4
7122: ARRAY
7123: PPUSH
7124: CALL_OW 47
7128: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7129: LD_VAR 0 2
7133: PUSH
7134: LD_INT 1
7136: ARRAY
7137: PUSH
7138: LD_INT 33
7140: PUSH
7141: LD_INT 32
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: IN
7148: IFFALSE 7168
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7150: LD_VAR 0 5
7154: PPUSH
7155: LD_VAR 0 2
7159: PUSH
7160: LD_INT 5
7162: ARRAY
7163: PPUSH
7164: CALL_OW 431
// end ;
7168: GO 6991
7170: POP
7171: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7172: LD_ADDR_VAR 0 4
7176: PUSH
7177: LD_INT 9
7179: PPUSH
7180: LD_INT 3
7182: PPUSH
7183: LD_STRING 
7185: PPUSH
7186: LD_INT 8
7188: PUSH
7189: LD_INT 7
7191: PUSH
7192: LD_INT 6
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: PPUSH
7206: LD_INT 11500
7208: PUSH
7209: LD_INT 1100
7211: PUSH
7212: LD_INT 60
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: LD_INT 6
7222: PUSH
7223: LD_INT 6
7225: PUSH
7226: LD_INT 6
7228: PUSH
7229: LD_INT 6
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PPUSH
7238: CALL 19314 0 6
7242: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7243: LD_ADDR_EXP 23
7247: PUSH
7248: LD_EXP 23
7252: PPUSH
7253: LD_INT 3
7255: PPUSH
7256: LD_VAR 0 4
7260: PUSH
7261: LD_INT 22
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 3
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: UNION
7290: PPUSH
7291: CALL_OW 1
7295: ST_TO_ADDR
// extraPopovForces := [ ] ;
7296: LD_ADDR_EXP 18
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7303: LD_ADDR_VAR 0 2
7307: PUSH
7308: DOUBLE
7309: LD_INT 1
7311: DEC
7312: ST_TO_ADDR
7313: LD_INT 8
7315: PUSH
7316: LD_INT 9
7318: PUSH
7319: LD_INT 10
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: LIST
7326: PUSH
7327: LD_OWVAR 67
7331: ARRAY
7332: PUSH
7333: FOR_TO
7334: IFFALSE 7463
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7336: LD_INT 0
7338: PPUSH
7339: LD_INT 1
7341: PPUSH
7342: LD_INT 4
7344: PUSH
7345: LD_INT 5
7347: PUSH
7348: LD_INT 6
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_OWVAR 67
7360: ARRAY
7361: PPUSH
7362: CALL_OW 380
// un := CreateHuman ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: CALL_OW 44
7375: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7376: LD_INT 0
7378: PPUSH
7379: LD_INT 1
7381: PPUSH
7382: CALL_OW 12
7386: IFFALSE 7411
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_INT 131
7395: PPUSH
7396: LD_INT 110
7398: PPUSH
7399: LD_INT 8
7401: PPUSH
7402: LD_INT 0
7404: PPUSH
7405: CALL_OW 50
7409: GO 7432
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7411: LD_VAR 0 3
7415: PPUSH
7416: LD_INT 100
7418: PPUSH
7419: LD_INT 99
7421: PPUSH
7422: LD_INT 8
7424: PPUSH
7425: LD_INT 0
7427: PPUSH
7428: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7432: LD_ADDR_EXP 18
7436: PUSH
7437: LD_EXP 18
7441: PPUSH
7442: LD_EXP 18
7446: PUSH
7447: LD_INT 1
7449: PLUS
7450: PPUSH
7451: LD_VAR 0 3
7455: PPUSH
7456: CALL_OW 1
7460: ST_TO_ADDR
// end ;
7461: GO 7333
7463: POP
7464: POP
// PrepareSoldier ( false , 6 ) ;
7465: LD_INT 0
7467: PPUSH
7468: LD_INT 6
7470: PPUSH
7471: CALL_OW 381
// un := CreateHuman ;
7475: LD_ADDR_VAR 0 3
7479: PUSH
7480: CALL_OW 44
7484: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7485: LD_VAR 0 3
7489: PPUSH
7490: LD_INT 1
7492: PPUSH
7493: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7497: LD_VAR 0 3
7501: PPUSH
7502: LD_INT 150
7504: PPUSH
7505: LD_INT 158
7507: PPUSH
7508: CALL_OW 428
7512: PPUSH
7513: CALL_OW 52
// popovAttackGroup := [ ] ;
7517: LD_ADDR_EXP 19
7521: PUSH
7522: EMPTY
7523: ST_TO_ADDR
// end ;
7524: LD_VAR 0 1
7528: RET
// export function InitMC_Popov ( ) ; begin
7529: LD_INT 0
7531: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7532: LD_INT 3
7534: PPUSH
7535: LD_INT 3
7537: PPUSH
7538: CALL 76356 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7542: LD_INT 3
7544: PPUSH
7545: LD_INT 10
7547: PPUSH
7548: CALL 76300 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7552: LD_INT 3
7554: PPUSH
7555: LD_INT 86
7557: PUSH
7558: LD_INT 118
7560: PUSH
7561: LD_INT 0
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 123
7571: PUSH
7572: LD_INT 151
7574: PUSH
7575: LD_INT 1
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 98
7585: PUSH
7586: LD_INT 121
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: LIST
7601: PPUSH
7602: CALL 75359 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7606: LD_INT 3
7608: PPUSH
7609: LD_INT 46
7611: PUSH
7612: LD_INT 45
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PPUSH
7619: CALL 76188 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7623: LD_INT 3
7625: PPUSH
7626: LD_INT 12
7628: PPUSH
7629: CALL 75870 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7633: LD_INT 3
7635: PPUSH
7636: LD_INT 11
7638: PPUSH
7639: CALL 75601 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7643: LD_INT 3
7645: PPUSH
7646: LD_INT 4
7648: PPUSH
7649: CALL 75220 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7653: LD_INT 3
7655: PPUSH
7656: LD_INT 23
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 44
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 23
7676: PUSH
7677: LD_INT 1
7679: PUSH
7680: LD_INT 3
7682: PUSH
7683: LD_INT 45
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 21
7694: PUSH
7695: LD_INT 1
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 44
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 21
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 45
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL 75035 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7738: LD_INT 3
7740: PPUSH
7741: LD_INT 94
7743: PPUSH
7744: LD_INT 161
7746: PPUSH
7747: LD_INT 0
7749: PPUSH
7750: LD_INT 19
7752: PUSH
7753: LD_INT 17
7755: PUSH
7756: LD_INT 18
7758: PUSH
7759: LD_INT 24
7761: PUSH
7762: LD_INT 21
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: PPUSH
7772: CALL 75982 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7776: LD_INT 3
7778: PPUSH
7779: LD_INT 21
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: LD_INT 3
7787: PUSH
7788: LD_INT 51
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: PPUSH
7800: CALL 75083 0 2
// end ;
7804: LD_VAR 0 1
7808: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7809: LD_EXP 18
7813: PUSH
7814: LD_EXP 5
7818: NOT
7819: AND
7820: IFFALSE 7880
7822: GO 7824
7824: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7825: LD_EXP 18
7829: PPUSH
7830: LD_INT 106
7832: PPUSH
7833: LD_INT 137
7835: PPUSH
7836: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7840: LD_ADDR_EXP 23
7844: PUSH
7845: LD_EXP 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_EXP 23
7857: PUSH
7858: LD_INT 3
7860: ARRAY
7861: PUSH
7862: LD_EXP 18
7866: UNION
7867: PPUSH
7868: CALL_OW 1
7872: ST_TO_ADDR
// extraPopovForces := [ ] ;
7873: LD_ADDR_EXP 18
7877: PUSH
7878: EMPTY
7879: ST_TO_ADDR
// end ;
7880: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7881: LD_INT 9
7883: PPUSH
7884: CALL_OW 302
7888: PUSH
7889: LD_EXP 5
7893: NOT
7894: AND
7895: IFFALSE 8461
7897: GO 7899
7899: DISABLE
7900: LD_INT 0
7902: PPUSH
7903: PPUSH
7904: PPUSH
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// base := 3 ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7916: LD_ADDR_VAR 0 3
7920: PUSH
7921: LD_INT 22
7923: PUSH
7924: LD_INT 1
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 44
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 24
7941: PUSH
7942: LD_INT 1
7944: PUSH
7945: LD_INT 3
7947: PUSH
7948: LD_INT 46
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 24
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: LD_INT 3
7965: PUSH
7966: LD_INT 46
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: LD_INT 24
7977: PUSH
7978: LD_INT 1
7980: PUSH
7981: LD_INT 3
7983: PUSH
7984: LD_INT 46
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7999: LD_ADDR_VAR 0 5
8003: PUSH
8004: LD_VAR 0 5
8008: PUSH
8009: LD_OWVAR 1
8013: PUSH
8014: LD_INT 21000
8016: DIV
8017: PLUS
8018: ST_TO_ADDR
// if amount > 8 then
8019: LD_VAR 0 5
8023: PUSH
8024: LD_INT 8
8026: GREATER
8027: IFFALSE 8037
// amount := 8 ;
8029: LD_ADDR_VAR 0 5
8033: PUSH
8034: LD_INT 8
8036: ST_TO_ADDR
// for i = 1 to amount do
8037: LD_ADDR_VAR 0 1
8041: PUSH
8042: DOUBLE
8043: LD_INT 1
8045: DEC
8046: ST_TO_ADDR
8047: LD_VAR 0 5
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8118
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8055: LD_ADDR_VAR 0 3
8059: PUSH
8060: LD_VAR 0 3
8064: PPUSH
8065: LD_VAR 0 3
8069: PUSH
8070: LD_INT 1
8072: PLUS
8073: PPUSH
8074: LD_INT 24
8076: PUSH
8077: LD_INT 1
8079: PUSH
8080: LD_INT 3
8082: PUSH
8083: LD_INT 46
8085: PUSH
8086: LD_INT 45
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: PUSH
8093: LD_INT 1
8095: PPUSH
8096: LD_INT 2
8098: PPUSH
8099: CALL_OW 12
8103: ARRAY
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: LIST
8109: LIST
8110: PPUSH
8111: CALL_OW 2
8115: ST_TO_ADDR
8116: GO 8052
8118: POP
8119: POP
// MC_InsertProduceList ( base , tmp ) ;
8120: LD_VAR 0 2
8124: PPUSH
8125: LD_VAR 0 3
8129: PPUSH
8130: CALL 75083 0 2
// repeat wait ( 0 0$1 ) ;
8134: LD_INT 35
8136: PPUSH
8137: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8141: LD_VAR 0 2
8145: PPUSH
8146: LD_INT 1
8148: PPUSH
8149: CALL 76501 0 2
8153: PUSH
8154: LD_VAR 0 5
8158: GREATEREQUAL
8159: IFFALSE 8134
// wait ( 0 0$30 ) ;
8161: LD_INT 1050
8163: PPUSH
8164: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8168: LD_ADDR_VAR 0 4
8172: PUSH
8173: LD_EXP 42
8177: PUSH
8178: LD_VAR 0 2
8182: ARRAY
8183: PUSH
8184: LD_EXP 42
8188: PUSH
8189: LD_VAR 0 2
8193: ARRAY
8194: PPUSH
8195: LD_INT 2
8197: PUSH
8198: LD_INT 34
8200: PUSH
8201: LD_INT 51
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PUSH
8208: LD_INT 34
8210: PUSH
8211: LD_INT 52
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 72
8227: DIFF
8228: ST_TO_ADDR
// if not attackers then
8229: LD_VAR 0 4
8233: NOT
8234: IFFALSE 8238
// exit ;
8236: GO 8461
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8238: LD_ADDR_EXP 42
8242: PUSH
8243: LD_EXP 42
8247: PPUSH
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_EXP 42
8257: PUSH
8258: LD_VAR 0 2
8262: ARRAY
8263: PUSH
8264: LD_VAR 0 4
8268: DIFF
8269: PPUSH
8270: CALL_OW 1
8274: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8275: LD_VAR 0 4
8279: PPUSH
8280: LD_INT 107
8282: PPUSH
8283: LD_INT 74
8285: PPUSH
8286: CALL_OW 114
// wait ( 0 0$5 ) ;
8290: LD_INT 175
8292: PPUSH
8293: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8304: LD_VAR 0 4
8308: PPUSH
8309: LD_INT 60
8311: PUSH
8312: EMPTY
8313: LIST
8314: PPUSH
8315: CALL_OW 72
8319: NOT
8320: IFFALSE 8297
// if rand ( 0 , 1 ) then
8322: LD_INT 0
8324: PPUSH
8325: LD_INT 1
8327: PPUSH
8328: CALL_OW 12
8332: IFFALSE 8351
// ComAgressiveMove ( attackers , 155 , 108 ) else
8334: LD_VAR 0 4
8338: PPUSH
8339: LD_INT 155
8341: PPUSH
8342: LD_INT 108
8344: PPUSH
8345: CALL_OW 114
8349: GO 8366
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8351: LD_VAR 0 4
8355: PPUSH
8356: LD_INT 149
8358: PPUSH
8359: LD_INT 55
8361: PPUSH
8362: CALL_OW 114
// wait ( 0 0$10 ) ;
8366: LD_INT 350
8368: PPUSH
8369: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8373: LD_INT 35
8375: PPUSH
8376: CALL_OW 67
// for i in attackers do
8380: LD_ADDR_VAR 0 1
8384: PUSH
8385: LD_VAR 0 4
8389: PUSH
8390: FOR_IN
8391: IFFALSE 8441
// if not HasTask ( i ) then
8393: LD_VAR 0 1
8397: PPUSH
8398: CALL_OW 314
8402: NOT
8403: IFFALSE 8439
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8405: LD_VAR 0 1
8409: PPUSH
8410: LD_INT 81
8412: PUSH
8413: LD_INT 3
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: PPUSH
8425: LD_VAR 0 1
8429: PPUSH
8430: CALL_OW 74
8434: PPUSH
8435: CALL_OW 115
8439: GO 8390
8441: POP
8442: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8443: LD_VAR 0 4
8447: PPUSH
8448: LD_INT 50
8450: PUSH
8451: EMPTY
8452: LIST
8453: PPUSH
8454: CALL_OW 72
8458: NOT
8459: IFFALSE 8373
// end ;
8461: PPOPN 5
8463: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8464: LD_EXP 5
8468: NOT
8469: IFFALSE 9056
8471: GO 8473
8473: DISABLE
8474: LD_INT 0
8476: PPUSH
8477: PPUSH
8478: PPUSH
8479: PPUSH
// begin enable ;
8480: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8481: LD_OWVAR 67
8485: PUSH
8486: LD_INT 1
8488: EQUAL
8489: PUSH
8490: LD_OWVAR 1
8494: PUSH
8495: LD_INT 63000
8497: LESS
8498: AND
8499: IFFALSE 8503
// exit ;
8501: GO 9056
// tmp := [ ] ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// if tick < 45 45$00 then
8510: LD_OWVAR 1
8514: PUSH
8515: LD_INT 94500
8517: LESS
8518: IFFALSE 8695
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8520: LD_ADDR_VAR 0 1
8524: PUSH
8525: DOUBLE
8526: LD_INT 1
8528: DEC
8529: ST_TO_ADDR
8530: LD_INT 2
8532: PUSH
8533: LD_INT 3
8535: PUSH
8536: LD_INT 4
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PUSH
8544: LD_OWVAR 67
8548: ARRAY
8549: PUSH
8550: FOR_TO
8551: IFFALSE 8693
// begin uc_side := 3 ;
8553: LD_ADDR_OWVAR 20
8557: PUSH
8558: LD_INT 3
8560: ST_TO_ADDR
// uc_nation := 3 ;
8561: LD_ADDR_OWVAR 21
8565: PUSH
8566: LD_INT 3
8568: ST_TO_ADDR
// InitHC_All ( ) ;
8569: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_INT 1
8578: PPUSH
8579: LD_INT 5
8581: PUSH
8582: LD_INT 6
8584: PUSH
8585: LD_INT 7
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PPUSH
8599: CALL_OW 380
// un := CreateHuman ;
8603: LD_ADDR_VAR 0 2
8607: PUSH
8608: CALL_OW 44
8612: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8613: LD_VAR 0 2
8617: PPUSH
8618: LD_INT 18
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_INT 9
8635: PPUSH
8636: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8640: LD_VAR 0 2
8644: PPUSH
8645: LD_INT 147
8647: PPUSH
8648: LD_INT 161
8650: PPUSH
8651: CALL_OW 111
// wait ( 0 0$2 ) ;
8655: LD_INT 70
8657: PPUSH
8658: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8662: LD_ADDR_VAR 0 3
8666: PUSH
8667: LD_VAR 0 3
8671: PPUSH
8672: LD_VAR 0 3
8676: PUSH
8677: LD_INT 1
8679: PLUS
8680: PPUSH
8681: LD_VAR 0 2
8685: PPUSH
8686: CALL_OW 1
8690: ST_TO_ADDR
// end ;
8691: GO 8550
8693: POP
8694: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8695: LD_ADDR_VAR 0 4
8699: PUSH
8700: LD_INT 3
8702: PUSH
8703: LD_INT 4
8705: PUSH
8706: LD_INT 5
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_OWVAR 67
8718: ARRAY
8719: PUSH
8720: LD_OWVAR 1
8724: PUSH
8725: LD_INT 21000
8727: DIV
8728: PLUS
8729: ST_TO_ADDR
// if amount > 15 then
8730: LD_VAR 0 4
8734: PUSH
8735: LD_INT 15
8737: GREATER
8738: IFFALSE 8748
// amount := 15 ;
8740: LD_ADDR_VAR 0 4
8744: PUSH
8745: LD_INT 15
8747: ST_TO_ADDR
// for i := 1 to amount do
8748: LD_ADDR_VAR 0 1
8752: PUSH
8753: DOUBLE
8754: LD_INT 1
8756: DEC
8757: ST_TO_ADDR
8758: LD_VAR 0 4
8762: PUSH
8763: FOR_TO
8764: IFFALSE 8910
// begin uc_side := 3 ;
8766: LD_ADDR_OWVAR 20
8770: PUSH
8771: LD_INT 3
8773: ST_TO_ADDR
// uc_nation := 3 ;
8774: LD_ADDR_OWVAR 21
8778: PUSH
8779: LD_INT 3
8781: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8782: LD_INT 24
8784: PPUSH
8785: LD_INT 1
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: LD_INT 46
8793: PUSH
8794: LD_INT 45
8796: PUSH
8797: LD_INT 44
8799: PUSH
8800: LD_INT 43
8802: PUSH
8803: LD_INT 42
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 5
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: PPUSH
8825: LD_INT 90
8827: PPUSH
8828: CALL 15868 0 5
// un := CreateVehicle ;
8832: LD_ADDR_VAR 0 2
8836: PUSH
8837: CALL_OW 45
8841: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8842: LD_VAR 0 2
8846: PPUSH
8847: LD_INT 18
8849: PPUSH
8850: LD_INT 0
8852: PPUSH
8853: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8857: LD_VAR 0 2
8861: PPUSH
8862: LD_INT 147
8864: PPUSH
8865: LD_INT 161
8867: PPUSH
8868: CALL_OW 111
// wait ( 0 0$3 ) ;
8872: LD_INT 105
8874: PPUSH
8875: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8879: LD_ADDR_VAR 0 3
8883: PUSH
8884: LD_VAR 0 3
8888: PPUSH
8889: LD_VAR 0 3
8893: PUSH
8894: LD_INT 1
8896: PLUS
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// end ;
8908: GO 8763
8910: POP
8911: POP
// if not tmp then
8912: LD_VAR 0 3
8916: NOT
8917: IFFALSE 8921
// exit ;
8919: GO 9056
// wait ( 0 0$5 ) ;
8921: LD_INT 175
8923: PPUSH
8924: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8928: LD_INT 70
8930: PPUSH
8931: CALL_OW 67
// for i in tmp do
8935: LD_ADDR_VAR 0 1
8939: PUSH
8940: LD_VAR 0 3
8944: PUSH
8945: FOR_IN
8946: IFFALSE 9047
// begin if not IsOk ( i ) or IsDead ( i ) then
8948: LD_VAR 0 1
8952: PPUSH
8953: CALL_OW 302
8957: NOT
8958: PUSH
8959: LD_VAR 0 1
8963: PPUSH
8964: CALL_OW 301
8968: OR
8969: IFFALSE 8987
// tmp := tmp diff i ;
8971: LD_ADDR_VAR 0 3
8975: PUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 1
8985: DIFF
8986: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8987: LD_VAR 0 1
8991: PPUSH
8992: CALL_OW 257
8996: PUSH
8997: LD_INT 9
8999: EQUAL
9000: IFFALSE 9011
// ComSpaceTimeShoot ( i ) ;
9002: LD_VAR 0 1
9006: PPUSH
9007: CALL 11951 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9011: LD_VAR 0 1
9015: PPUSH
9016: LD_INT 81
9018: PUSH
9019: LD_INT 3
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: PPUSH
9031: LD_VAR 0 1
9035: PPUSH
9036: CALL_OW 74
9040: PPUSH
9041: CALL_OW 115
// end ;
9045: GO 8945
9047: POP
9048: POP
// until not tmp ;
9049: LD_VAR 0 3
9053: NOT
9054: IFFALSE 8928
// end ; end_of_file
9056: PPOPN 4
9058: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
// uc_side := 1 ;
9065: LD_ADDR_OWVAR 20
9069: PUSH
9070: LD_INT 1
9072: ST_TO_ADDR
// uc_nation := 1 ;
9073: LD_ADDR_OWVAR 21
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// hc_importance := 100 ;
9081: LD_ADDR_OWVAR 32
9085: PUSH
9086: LD_INT 100
9088: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9089: LD_ADDR_OWVAR 26
9093: PUSH
9094: LD_STRING Jeremy Sikorski
9096: ST_TO_ADDR
// hc_gallery := us ;
9097: LD_ADDR_OWVAR 33
9101: PUSH
9102: LD_STRING us
9104: ST_TO_ADDR
// hc_face_number := 19 ;
9105: LD_ADDR_OWVAR 34
9109: PUSH
9110: LD_INT 19
9112: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 4
9121: PUSH
9122: LD_INT 4
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: PUSH
9133: LD_OWVAR 67
9137: ARRAY
9138: PPUSH
9139: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9143: LD_ADDR_OWVAR 29
9147: PUSH
9148: LD_INT 10
9150: PUSH
9151: LD_INT 12
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: ST_TO_ADDR
// Sikorski := CreateHuman ;
9158: LD_ADDR_EXP 20
9162: PUSH
9163: CALL_OW 44
9167: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9168: LD_EXP 20
9172: PPUSH
9173: LD_INT 133
9175: PPUSH
9176: LD_INT 19
9178: PPUSH
9179: LD_INT 2
9181: PPUSH
9182: LD_INT 0
9184: PPUSH
9185: CALL_OW 50
// InitHc_All ( ) ;
9189: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_INT 4
9205: PUSH
9206: LD_INT 3
9208: PUSH
9209: LD_INT 3
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: LIST
9216: PUSH
9217: LD_OWVAR 67
9221: ARRAY
9222: PUSH
9223: FOR_TO
9224: IFFALSE 9340
// for j := 1 to 4 do
9226: LD_ADDR_VAR 0 3
9230: PUSH
9231: DOUBLE
9232: LD_INT 1
9234: DEC
9235: ST_TO_ADDR
9236: LD_INT 4
9238: PUSH
9239: FOR_TO
9240: IFFALSE 9336
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9242: LD_INT 0
9244: PPUSH
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 5
9252: PUSH
9253: LD_INT 4
9255: PUSH
9256: LD_INT 3
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: LIST
9263: PUSH
9264: LD_OWVAR 67
9268: ARRAY
9269: PPUSH
9270: CALL_OW 380
// un := CreateHuman ;
9274: LD_ADDR_VAR 0 4
9278: PUSH
9279: CALL_OW 44
9283: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9284: LD_VAR 0 4
9288: PPUSH
9289: LD_INT 0
9291: PPUSH
9292: LD_INT 5
9294: PPUSH
9295: CALL_OW 12
9299: PPUSH
9300: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9304: LD_VAR 0 4
9308: PPUSH
9309: LD_INT 133
9311: PPUSH
9312: LD_INT 19
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 0
9320: PPUSH
9321: CALL_OW 50
// ComHold ( un ) ;
9325: LD_VAR 0 4
9329: PPUSH
9330: CALL_OW 140
// end ;
9334: GO 9239
9336: POP
9337: POP
9338: GO 9223
9340: POP
9341: POP
// vc_chassis := us_heavy_tracked ;
9342: LD_ADDR_OWVAR 37
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// vc_engine := engine_combustion ;
9350: LD_ADDR_OWVAR 39
9354: PUSH
9355: LD_INT 1
9357: ST_TO_ADDR
// vc_control := control_manual ;
9358: LD_ADDR_OWVAR 38
9362: PUSH
9363: LD_INT 1
9365: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9366: LD_ADDR_OWVAR 40
9370: PUSH
9371: LD_INT 14
9373: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9374: LD_ADDR_OWVAR 41
9378: PUSH
9379: LD_INT 60
9381: ST_TO_ADDR
// un := CreateVehicle ;
9382: LD_ADDR_VAR 0 4
9386: PUSH
9387: CALL_OW 45
9391: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 2
9399: PPUSH
9400: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9404: LD_VAR 0 4
9408: PPUSH
9409: LD_INT 128
9411: PPUSH
9412: LD_INT 12
9414: PPUSH
9415: LD_INT 0
9417: PPUSH
9418: CALL_OW 48
// for i := 1 to 3 do
9422: LD_ADDR_VAR 0 2
9426: PUSH
9427: DOUBLE
9428: LD_INT 1
9430: DEC
9431: ST_TO_ADDR
9432: LD_INT 3
9434: PUSH
9435: FOR_TO
9436: IFFALSE 9459
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9438: LD_INT 5
9440: PPUSH
9441: LD_INT 133
9443: PPUSH
9444: LD_INT 19
9446: PPUSH
9447: LD_INT 3
9449: PPUSH
9450: LD_INT 0
9452: PPUSH
9453: CALL_OW 56
9457: GO 9435
9459: POP
9460: POP
// end ; end_of_file
9461: LD_VAR 0 1
9465: RET
// export function Action ; begin
9466: LD_INT 0
9468: PPUSH
// InGameOn ;
9469: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9473: LD_INT 133
9475: PPUSH
9476: LD_INT 19
9478: PPUSH
9479: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9483: LD_EXP 20
9487: PPUSH
9488: LD_STRING WT-DS-1
9490: PPUSH
9491: CALL_OW 88
// InGameOff ;
9495: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9499: LD_STRING DestroyEnemy
9501: PPUSH
9502: CALL_OW 337
// wait ( 0 0$20 ) ;
9506: LD_INT 700
9508: PPUSH
9509: CALL_OW 67
// DialogueOn ;
9513: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9517: LD_INT 100
9519: PPUSH
9520: LD_INT 37
9522: PPUSH
9523: LD_INT 1
9525: PPUSH
9526: LD_INT 30
9528: NEG
9529: PPUSH
9530: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9534: LD_INT 100
9536: PPUSH
9537: LD_INT 37
9539: PPUSH
9540: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9544: LD_EXP 10
9548: PPUSH
9549: LD_STRING WT-PL-1
9551: PPUSH
9552: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9556: LD_EXP 20
9560: PPUSH
9561: LD_STRING WT-DS-2
9563: PPUSH
9564: CALL_OW 88
// DialogueOff ;
9568: CALL_OW 7
// wait ( 0 0$2 ) ;
9572: LD_INT 70
9574: PPUSH
9575: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9579: LD_INT 100
9581: PPUSH
9582: LD_INT 37
9584: PPUSH
9585: LD_INT 1
9587: PPUSH
9588: CALL_OW 331
// end ;
9592: LD_VAR 0 1
9596: RET
// export function DialogPowellsAttack ; begin
9597: LD_INT 0
9599: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9600: LD_EXP 10
9604: PPUSH
9605: LD_STRING WT-PL-8
9607: PPUSH
9608: CALL_OW 94
// end ;
9612: LD_VAR 0 1
9616: RET
// export function DialogContaminateSib ( x , y ) ; begin
9617: LD_INT 0
9619: PPUSH
// DialogueOn ;
9620: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9624: LD_VAR 0 1
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9638: LD_EXP 20
9642: PPUSH
9643: LD_STRING WT-DS-3
9645: PPUSH
9646: CALL_OW 88
// DialogueOff ;
9650: CALL_OW 7
// end ;
9654: LD_VAR 0 3
9658: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9659: LD_EXP 8
9663: NOT
9664: PUSH
9665: LD_INT 1
9667: PPUSH
9668: LD_INT 81
9670: PUSH
9671: LD_INT 4
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL_OW 70
9682: PUSH
9683: LD_INT 3
9685: GREATER
9686: AND
9687: IFFALSE 9759
9689: GO 9691
9691: DISABLE
// begin powellInTrouble := true ;
9692: LD_ADDR_EXP 8
9696: PUSH
9697: LD_INT 1
9699: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9700: LD_EXP 20
9704: PPUSH
9705: LD_STRING WT-DS-6
9707: PPUSH
9708: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9712: LD_INT 1
9714: PPUSH
9715: LD_INT 22
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 70
9729: NOT
9730: IFFALSE 9744
// SayRadio ( Powell , WT-PL-6 ) ;
9732: LD_EXP 10
9736: PPUSH
9737: LD_STRING WT-PL-6
9739: PPUSH
9740: CALL_OW 94
// wait ( 1 1$30 ) ;
9744: LD_INT 3150
9746: PPUSH
9747: CALL_OW 67
// powellInTrouble := false ;
9751: LD_ADDR_EXP 8
9755: PUSH
9756: LD_INT 0
9758: ST_TO_ADDR
// end ;
9759: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9760: LD_EXP 9
9764: NOT
9765: PUSH
9766: LD_INT 16
9768: PPUSH
9769: LD_INT 81
9771: PUSH
9772: LD_INT 1
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 70
9783: PUSH
9784: LD_INT 6
9786: GREATER
9787: AND
9788: IFFALSE 9861
9790: GO 9792
9792: DISABLE
// begin sikorskiInTrouble := true ;
9793: LD_ADDR_EXP 9
9797: PUSH
9798: LD_INT 1
9800: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9801: LD_EXP 20
9805: PPUSH
9806: LD_STRING WT-DS-7
9808: PPUSH
9809: CALL_OW 88
// if not powellAttackGroup then
9813: LD_EXP 12
9817: NOT
9818: IFFALSE 9834
// SayRadio ( Powell , WT-PL-7n ) else
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-7n
9827: PPUSH
9828: CALL_OW 94
9832: GO 9846
// SayRadio ( Powell , WT-PL-7y ) ;
9834: LD_EXP 10
9838: PPUSH
9839: LD_STRING WT-PL-7y
9841: PPUSH
9842: CALL_OW 94
// wait ( 1 1$30 ) ;
9846: LD_INT 3150
9848: PPUSH
9849: CALL_OW 67
// sikorskiInTrouble := false ;
9853: LD_ADDR_EXP 9
9857: PUSH
9858: LD_INT 0
9860: ST_TO_ADDR
// end ;
9861: END
// export function DialogPowellsAttackFailed ; begin
9862: LD_INT 0
9864: PPUSH
// if not ruDestroyed then
9865: LD_EXP 5
9869: NOT
9870: IFFALSE 9886
// SayRadio ( Powell , WT-PL-9 ) else
9872: LD_EXP 10
9876: PPUSH
9877: LD_STRING WT-PL-9
9879: PPUSH
9880: CALL_OW 94
9884: GO 9898
// SayRadio ( Powell , WT-PL-10 ) ;
9886: LD_EXP 10
9890: PPUSH
9891: LD_STRING WT-PL-10
9893: PPUSH
9894: CALL_OW 94
// end ;
9898: LD_VAR 0 1
9902: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9903: LD_INT 22
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 1
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: PPUSH
9927: CALL_OW 69
9931: PUSH
9932: LD_INT 0
9934: EQUAL
9935: IFFALSE 9979
9937: GO 9939
9939: DISABLE
// begin arDestroyed := true ;
9940: LD_ADDR_EXP 4
9944: PUSH
9945: LD_INT 1
9947: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9948: LD_INT 2
9950: PPUSH
9951: CALL 51105 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9955: LD_EXP 20
9959: PPUSH
9960: LD_STRING WT-DS-4
9962: PPUSH
9963: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9967: LD_EXP 10
9971: PPUSH
9972: LD_STRING WT-PL-4
9974: PPUSH
9975: CALL_OW 94
// end ;
9979: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9980: LD_INT 22
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 21
9992: PUSH
9993: LD_INT 1
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PPUSH
10004: CALL_OW 69
10008: PUSH
10009: LD_INT 0
10011: EQUAL
10012: IFFALSE 10056
10014: GO 10016
10016: DISABLE
// begin ruDestroyed := true ;
10017: LD_ADDR_EXP 5
10021: PUSH
10022: LD_INT 1
10024: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10025: LD_INT 3
10027: PPUSH
10028: CALL 51105 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10032: LD_EXP 20
10036: PPUSH
10037: LD_STRING WT-DS-5
10039: PPUSH
10040: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10044: LD_EXP 10
10048: PPUSH
10049: LD_STRING WT-PL-5
10051: PPUSH
10052: CALL_OW 94
// end ;
10056: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10057: LD_EXP 5
10061: PUSH
10062: LD_EXP 4
10066: AND
10067: IFFALSE 10240
10069: GO 10071
10071: DISABLE
// begin wait ( 0 0$3 ) ;
10072: LD_INT 105
10074: PPUSH
10075: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10079: LD_OWVAR 1
10083: PUSH
10084: LD_INT 126000
10086: PUSH
10087: LD_INT 105000
10089: PUSH
10090: LD_INT 94500
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: PUSH
10098: LD_OWVAR 67
10102: ARRAY
10103: GREATEREQUAL
10104: IFFALSE 10119
// AddMedal ( WoT-med-1 , - 1 ) else
10106: LD_STRING WoT-med-1
10108: PPUSH
10109: LD_INT 1
10111: NEG
10112: PPUSH
10113: CALL_OW 101
10117: GO 10129
// AddMedal ( WoT-med-1 , 1 ) ;
10119: LD_STRING WoT-med-1
10121: PPUSH
10122: LD_INT 1
10124: PPUSH
10125: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10129: LD_EXP 6
10133: PUSH
10134: LD_INT 4
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 2
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_OWVAR 67
10152: ARRAY
10153: GREATEREQUAL
10154: IFFALSE 10169
// AddMedal ( WoT-med-2 , - 1 ) else
10156: LD_STRING WoT-med-2
10158: PPUSH
10159: LD_INT 1
10161: NEG
10162: PPUSH
10163: CALL_OW 101
10167: GO 10179
// AddMedal ( WoT-med-2 , 1 ) ;
10169: LD_STRING WoT-med-2
10171: PPUSH
10172: LD_INT 1
10174: PPUSH
10175: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10179: LD_EXP 7
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 5
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: LIST
10197: PUSH
10198: LD_OWVAR 67
10202: ARRAY
10203: GREATEREQUAL
10204: IFFALSE 10219
// AddMedal ( WoT-med-3 , - 1 ) else
10206: LD_STRING WoT-med-3
10208: PPUSH
10209: LD_INT 1
10211: NEG
10212: PPUSH
10213: CALL_OW 101
10217: GO 10229
// AddMedal ( WoT-med-3 , 1 ) ;
10219: LD_STRING WoT-med-3
10221: PPUSH
10222: LD_INT 1
10224: PPUSH
10225: CALL_OW 101
// GiveMedals ( MAIN ) ;
10229: LD_STRING MAIN
10231: PPUSH
10232: CALL_OW 102
// YouWin ;
10236: CALL_OW 103
// end ; end_of_file
10240: END
// export function CustomEvent ( event ) ; begin
10241: LD_INT 0
10243: PPUSH
// end ;
10244: LD_VAR 0 2
10248: RET
// on Command ( com ) do var i , j , temp ;
10249: LD_INT 0
10251: PPUSH
10252: PPUSH
10253: PPUSH
// begin if com = 60 then
10254: LD_VAR 0 1
10258: PUSH
10259: LD_INT 60
10261: EQUAL
10262: IFFALSE 10441
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10264: LD_ADDR_VAR 0 2
10268: PUSH
10269: LD_INT 22
10271: PUSH
10272: LD_INT 1
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 2
10281: PUSH
10282: LD_INT 21
10284: PUSH
10285: LD_INT 1
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 34
10294: PUSH
10295: LD_INT 12
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: EMPTY
10308: LIST
10309: LIST
10310: PPUSH
10311: CALL_OW 69
10315: PUSH
10316: FOR_IN
10317: IFFALSE 10439
// begin if GetTaskList ( i ) > 0 then
10319: LD_VAR 0 2
10323: PPUSH
10324: CALL_OW 437
10328: PUSH
10329: LD_INT 0
10331: GREATER
10332: IFFALSE 10437
// for j = 1 to GetTaskList ( i ) do
10334: LD_ADDR_VAR 0 3
10338: PUSH
10339: DOUBLE
10340: LD_INT 1
10342: DEC
10343: ST_TO_ADDR
10344: LD_VAR 0 2
10348: PPUSH
10349: CALL_OW 437
10353: PUSH
10354: FOR_TO
10355: IFFALSE 10435
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10357: LD_ADDR_VAR 0 4
10361: PUSH
10362: LD_VAR 0 2
10366: PPUSH
10367: CALL_OW 437
10371: PUSH
10372: LD_VAR 0 3
10376: ARRAY
10377: PUSH
10378: LD_INT 4
10380: ARRAY
10381: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10382: LD_VAR 0 4
10386: PPUSH
10387: CALL_OW 255
10391: PUSH
10392: LD_INT 4
10394: EQUAL
10395: PUSH
10396: LD_VAR 0 2
10400: PPUSH
10401: CALL_OW 437
10405: PUSH
10406: LD_VAR 0 3
10410: ARRAY
10411: PUSH
10412: LD_INT 1
10414: ARRAY
10415: PUSH
10416: LD_STRING <
10418: EQUAL
10419: AND
10420: IFFALSE 10433
// SetTaskList ( i , [ ] ) ;
10422: LD_VAR 0 2
10426: PPUSH
10427: EMPTY
10428: PPUSH
10429: CALL_OW 446
// end ;
10433: GO 10354
10435: POP
10436: POP
// end ;
10437: GO 10316
10439: POP
10440: POP
// end ; end ;
10441: PPOPN 4
10443: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10444: LD_VAR 0 2
10448: PPUSH
10449: LD_VAR 0 3
10453: PPUSH
10454: CALL_OW 428
10458: PPUSH
10459: CALL_OW 255
10463: PUSH
10464: LD_INT 1
10466: EQUAL
10467: PUSH
10468: LD_VAR 0 2
10472: PUSH
10473: LD_INT 132
10475: EQUAL
10476: PUSH
10477: LD_VAR 0 3
10481: PUSH
10482: LD_INT 39
10484: EQUAL
10485: AND
10486: OR
10487: IFFALSE 10503
// DialogContaminateSib ( x , y ) ;
10489: LD_VAR 0 2
10493: PPUSH
10494: LD_VAR 0 3
10498: PPUSH
10499: CALL 9617 0 2
// end ;
10503: PPOPN 3
10505: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
10506: LD_VAR 0 1
10510: PPUSH
10511: CALL 78503 0 1
// if un = Powell then
10515: LD_VAR 0 1
10519: PUSH
10520: LD_EXP 10
10524: EQUAL
10525: IFFALSE 10534
// YouLost ( Powell ) ;
10527: LD_STRING Powell
10529: PPUSH
10530: CALL_OW 104
// if un = Sikorski then
10534: LD_VAR 0 1
10538: PUSH
10539: LD_EXP 20
10543: EQUAL
10544: IFFALSE 10553
// YouLost ( Sikorski ) ;
10546: LD_STRING Sikorski
10548: PPUSH
10549: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10553: LD_VAR 0 1
10557: PUSH
10558: LD_INT 22
10560: PUSH
10561: LD_INT 1
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 21
10570: PUSH
10571: LD_INT 1
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PUSH
10578: EMPTY
10579: LIST
10580: LIST
10581: PPUSH
10582: CALL_OW 69
10586: IN
10587: IFFALSE 10603
// loseCounter := loseCounter + 1 ;
10589: LD_ADDR_EXP 6
10593: PUSH
10594: LD_EXP 6
10598: PUSH
10599: LD_INT 1
10601: PLUS
10602: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10603: LD_VAR 0 1
10607: PUSH
10608: LD_INT 22
10610: PUSH
10611: LD_INT 4
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: PUSH
10618: LD_INT 21
10620: PUSH
10621: LD_INT 1
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 69
10636: IN
10637: IFFALSE 10653
// powellLoseCounter := powellLoseCounter + 1 ;
10639: LD_ADDR_EXP 7
10643: PUSH
10644: LD_EXP 7
10648: PUSH
10649: LD_INT 1
10651: PLUS
10652: ST_TO_ADDR
// if un in powellAttackGroup then
10653: LD_VAR 0 1
10657: PUSH
10658: LD_EXP 12
10662: IN
10663: IFFALSE 10681
// powellAttackGroup := powellAttackGroup diff un ;
10665: LD_ADDR_EXP 12
10669: PUSH
10670: LD_EXP 12
10674: PUSH
10675: LD_VAR 0 1
10679: DIFF
10680: ST_TO_ADDR
// if un in gensherAttackGroup then
10681: LD_VAR 0 1
10685: PUSH
10686: LD_EXP 15
10690: IN
10691: IFFALSE 10709
// gensherAttackGroup := gensherAttackGroup diff un ;
10693: LD_ADDR_EXP 15
10697: PUSH
10698: LD_EXP 15
10702: PUSH
10703: LD_VAR 0 1
10707: DIFF
10708: ST_TO_ADDR
// if un in popovAttackGroup then
10709: LD_VAR 0 1
10713: PUSH
10714: LD_EXP 19
10718: IN
10719: IFFALSE 10737
// popovAttackGroup := popovAttackGroup diff un ;
10721: LD_ADDR_EXP 19
10725: PUSH
10726: LD_EXP 19
10730: PUSH
10731: LD_VAR 0 1
10735: DIFF
10736: ST_TO_ADDR
// end ;
10737: PPOPN 1
10739: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_VAR 0 2
10749: PPUSH
10750: CALL 80837 0 2
// end ;
10754: PPOPN 2
10756: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10757: LD_VAR 0 1
10761: PPUSH
10762: CALL 79905 0 1
// end ;
10766: PPOPN 1
10768: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10769: LD_VAR 0 1
10773: PPUSH
10774: CALL 80146 0 1
// end ;
10778: PPOPN 1
10780: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10781: LD_VAR 0 1
10785: PPUSH
10786: LD_VAR 0 2
10790: PPUSH
10791: CALL 78199 0 2
// end ;
10795: PPOPN 2
10797: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10798: LD_VAR 0 1
10802: PPUSH
10803: LD_VAR 0 2
10807: PPUSH
10808: LD_VAR 0 3
10812: PPUSH
10813: LD_VAR 0 4
10817: PPUSH
10818: LD_VAR 0 5
10822: PPUSH
10823: CALL 77819 0 5
// end ;
10827: PPOPN 5
10829: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10830: LD_VAR 0 1
10834: PPUSH
10835: LD_VAR 0 2
10839: PPUSH
10840: CALL 77400 0 2
// end ;
10844: PPOPN 2
10846: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10847: LD_VAR 0 1
10851: PPUSH
10852: LD_VAR 0 2
10856: PPUSH
10857: LD_VAR 0 3
10861: PPUSH
10862: LD_VAR 0 4
10866: PPUSH
10867: CALL 77238 0 4
// end ;
10871: PPOPN 4
10873: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10874: LD_VAR 0 1
10878: PPUSH
10879: LD_VAR 0 2
10883: PPUSH
10884: LD_VAR 0 3
10888: PPUSH
10889: CALL 77013 0 3
// end ;
10893: PPOPN 3
10895: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_VAR 0 2
10905: PPUSH
10906: CALL 76898 0 2
// end ;
10910: PPOPN 2
10912: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10913: LD_VAR 0 1
10917: PPUSH
10918: LD_VAR 0 2
10922: PPUSH
10923: CALL 81132 0 2
// end ;
10927: PPOPN 2
10929: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_VAR 0 2
10939: PPUSH
10940: LD_VAR 0 3
10944: PPUSH
10945: LD_VAR 0 4
10949: PPUSH
10950: CALL 81348 0 4
// end ;
10954: PPOPN 4
10956: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10957: LD_VAR 0 1
10961: PPUSH
10962: LD_VAR 0 2
10966: PPUSH
10967: CALL 76707 0 2
// end ;
10971: PPOPN 2
10973: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10974: LD_VAR 0 1
10978: PUSH
10979: LD_INT 1
10981: EQUAL
10982: PUSH
10983: LD_VAR 0 2
10987: PUSH
10988: LD_INT 4
10990: EQUAL
10991: AND
10992: IFFALSE 11001
// YouLost ( FriendlyFire ) ;
10994: LD_STRING FriendlyFire
10996: PPUSH
10997: CALL_OW 104
// end ; end_of_file
11001: PPOPN 2
11003: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11004: LD_INT 0
11006: PPUSH
11007: PPUSH
// if exist_mode then
11008: LD_VAR 0 2
11012: IFFALSE 11037
// unit := CreateCharacter ( prefix & ident ) else
11014: LD_ADDR_VAR 0 5
11018: PUSH
11019: LD_VAR 0 3
11023: PUSH
11024: LD_VAR 0 1
11028: STR
11029: PPUSH
11030: CALL_OW 34
11034: ST_TO_ADDR
11035: GO 11052
// unit := NewCharacter ( ident ) ;
11037: LD_ADDR_VAR 0 5
11041: PUSH
11042: LD_VAR 0 1
11046: PPUSH
11047: CALL_OW 25
11051: ST_TO_ADDR
// result := unit ;
11052: LD_ADDR_VAR 0 4
11056: PUSH
11057: LD_VAR 0 5
11061: ST_TO_ADDR
// end ;
11062: LD_VAR 0 4
11066: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11067: LD_INT 0
11069: PPUSH
11070: PPUSH
// if not side or not nation then
11071: LD_VAR 0 1
11075: NOT
11076: PUSH
11077: LD_VAR 0 2
11081: NOT
11082: OR
11083: IFFALSE 11087
// exit ;
11085: GO 11855
// case nation of nation_american :
11087: LD_VAR 0 2
11091: PUSH
11092: LD_INT 1
11094: DOUBLE
11095: EQUAL
11096: IFTRUE 11100
11098: GO 11314
11100: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11101: LD_ADDR_VAR 0 4
11105: PUSH
11106: LD_INT 35
11108: PUSH
11109: LD_INT 45
11111: PUSH
11112: LD_INT 46
11114: PUSH
11115: LD_INT 47
11117: PUSH
11118: LD_INT 82
11120: PUSH
11121: LD_INT 83
11123: PUSH
11124: LD_INT 84
11126: PUSH
11127: LD_INT 85
11129: PUSH
11130: LD_INT 86
11132: PUSH
11133: LD_INT 1
11135: PUSH
11136: LD_INT 2
11138: PUSH
11139: LD_INT 6
11141: PUSH
11142: LD_INT 15
11144: PUSH
11145: LD_INT 16
11147: PUSH
11148: LD_INT 7
11150: PUSH
11151: LD_INT 12
11153: PUSH
11154: LD_INT 13
11156: PUSH
11157: LD_INT 10
11159: PUSH
11160: LD_INT 14
11162: PUSH
11163: LD_INT 20
11165: PUSH
11166: LD_INT 21
11168: PUSH
11169: LD_INT 22
11171: PUSH
11172: LD_INT 25
11174: PUSH
11175: LD_INT 32
11177: PUSH
11178: LD_INT 27
11180: PUSH
11181: LD_INT 36
11183: PUSH
11184: LD_INT 69
11186: PUSH
11187: LD_INT 39
11189: PUSH
11190: LD_INT 34
11192: PUSH
11193: LD_INT 40
11195: PUSH
11196: LD_INT 48
11198: PUSH
11199: LD_INT 49
11201: PUSH
11202: LD_INT 50
11204: PUSH
11205: LD_INT 51
11207: PUSH
11208: LD_INT 52
11210: PUSH
11211: LD_INT 53
11213: PUSH
11214: LD_INT 54
11216: PUSH
11217: LD_INT 55
11219: PUSH
11220: LD_INT 56
11222: PUSH
11223: LD_INT 57
11225: PUSH
11226: LD_INT 58
11228: PUSH
11229: LD_INT 59
11231: PUSH
11232: LD_INT 60
11234: PUSH
11235: LD_INT 61
11237: PUSH
11238: LD_INT 62
11240: PUSH
11241: LD_INT 80
11243: PUSH
11244: LD_INT 82
11246: PUSH
11247: LD_INT 83
11249: PUSH
11250: LD_INT 84
11252: PUSH
11253: LD_INT 85
11255: PUSH
11256: LD_INT 86
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: ST_TO_ADDR
11312: GO 11779
11314: LD_INT 2
11316: DOUBLE
11317: EQUAL
11318: IFTRUE 11322
11320: GO 11548
11322: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11323: LD_ADDR_VAR 0 4
11327: PUSH
11328: LD_INT 35
11330: PUSH
11331: LD_INT 45
11333: PUSH
11334: LD_INT 46
11336: PUSH
11337: LD_INT 47
11339: PUSH
11340: LD_INT 82
11342: PUSH
11343: LD_INT 83
11345: PUSH
11346: LD_INT 84
11348: PUSH
11349: LD_INT 85
11351: PUSH
11352: LD_INT 87
11354: PUSH
11355: LD_INT 70
11357: PUSH
11358: LD_INT 1
11360: PUSH
11361: LD_INT 11
11363: PUSH
11364: LD_INT 3
11366: PUSH
11367: LD_INT 4
11369: PUSH
11370: LD_INT 5
11372: PUSH
11373: LD_INT 6
11375: PUSH
11376: LD_INT 15
11378: PUSH
11379: LD_INT 18
11381: PUSH
11382: LD_INT 7
11384: PUSH
11385: LD_INT 17
11387: PUSH
11388: LD_INT 8
11390: PUSH
11391: LD_INT 20
11393: PUSH
11394: LD_INT 21
11396: PUSH
11397: LD_INT 22
11399: PUSH
11400: LD_INT 72
11402: PUSH
11403: LD_INT 26
11405: PUSH
11406: LD_INT 69
11408: PUSH
11409: LD_INT 39
11411: PUSH
11412: LD_INT 40
11414: PUSH
11415: LD_INT 41
11417: PUSH
11418: LD_INT 42
11420: PUSH
11421: LD_INT 43
11423: PUSH
11424: LD_INT 48
11426: PUSH
11427: LD_INT 49
11429: PUSH
11430: LD_INT 50
11432: PUSH
11433: LD_INT 51
11435: PUSH
11436: LD_INT 52
11438: PUSH
11439: LD_INT 53
11441: PUSH
11442: LD_INT 54
11444: PUSH
11445: LD_INT 55
11447: PUSH
11448: LD_INT 56
11450: PUSH
11451: LD_INT 60
11453: PUSH
11454: LD_INT 61
11456: PUSH
11457: LD_INT 62
11459: PUSH
11460: LD_INT 66
11462: PUSH
11463: LD_INT 67
11465: PUSH
11466: LD_INT 68
11468: PUSH
11469: LD_INT 81
11471: PUSH
11472: LD_INT 82
11474: PUSH
11475: LD_INT 83
11477: PUSH
11478: LD_INT 84
11480: PUSH
11481: LD_INT 85
11483: PUSH
11484: LD_INT 87
11486: PUSH
11487: LD_INT 88
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: ST_TO_ADDR
11546: GO 11779
11548: LD_INT 3
11550: DOUBLE
11551: EQUAL
11552: IFTRUE 11556
11554: GO 11778
11556: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11557: LD_ADDR_VAR 0 4
11561: PUSH
11562: LD_INT 46
11564: PUSH
11565: LD_INT 47
11567: PUSH
11568: LD_INT 1
11570: PUSH
11571: LD_INT 2
11573: PUSH
11574: LD_INT 82
11576: PUSH
11577: LD_INT 83
11579: PUSH
11580: LD_INT 84
11582: PUSH
11583: LD_INT 85
11585: PUSH
11586: LD_INT 86
11588: PUSH
11589: LD_INT 11
11591: PUSH
11592: LD_INT 9
11594: PUSH
11595: LD_INT 20
11597: PUSH
11598: LD_INT 19
11600: PUSH
11601: LD_INT 21
11603: PUSH
11604: LD_INT 24
11606: PUSH
11607: LD_INT 22
11609: PUSH
11610: LD_INT 25
11612: PUSH
11613: LD_INT 28
11615: PUSH
11616: LD_INT 29
11618: PUSH
11619: LD_INT 30
11621: PUSH
11622: LD_INT 31
11624: PUSH
11625: LD_INT 37
11627: PUSH
11628: LD_INT 38
11630: PUSH
11631: LD_INT 32
11633: PUSH
11634: LD_INT 27
11636: PUSH
11637: LD_INT 33
11639: PUSH
11640: LD_INT 69
11642: PUSH
11643: LD_INT 39
11645: PUSH
11646: LD_INT 34
11648: PUSH
11649: LD_INT 40
11651: PUSH
11652: LD_INT 71
11654: PUSH
11655: LD_INT 23
11657: PUSH
11658: LD_INT 44
11660: PUSH
11661: LD_INT 48
11663: PUSH
11664: LD_INT 49
11666: PUSH
11667: LD_INT 50
11669: PUSH
11670: LD_INT 51
11672: PUSH
11673: LD_INT 52
11675: PUSH
11676: LD_INT 53
11678: PUSH
11679: LD_INT 54
11681: PUSH
11682: LD_INT 55
11684: PUSH
11685: LD_INT 56
11687: PUSH
11688: LD_INT 57
11690: PUSH
11691: LD_INT 58
11693: PUSH
11694: LD_INT 59
11696: PUSH
11697: LD_INT 63
11699: PUSH
11700: LD_INT 64
11702: PUSH
11703: LD_INT 65
11705: PUSH
11706: LD_INT 82
11708: PUSH
11709: LD_INT 83
11711: PUSH
11712: LD_INT 84
11714: PUSH
11715: LD_INT 85
11717: PUSH
11718: LD_INT 86
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: ST_TO_ADDR
11776: GO 11779
11778: POP
// if state > - 1 and state < 3 then
11779: LD_VAR 0 3
11783: PUSH
11784: LD_INT 1
11786: NEG
11787: GREATER
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_INT 3
11796: LESS
11797: AND
11798: IFFALSE 11855
// for i in result do
11800: LD_ADDR_VAR 0 5
11804: PUSH
11805: LD_VAR 0 4
11809: PUSH
11810: FOR_IN
11811: IFFALSE 11853
// if GetTech ( i , side ) <> state then
11813: LD_VAR 0 5
11817: PPUSH
11818: LD_VAR 0 1
11822: PPUSH
11823: CALL_OW 321
11827: PUSH
11828: LD_VAR 0 3
11832: NONEQUAL
11833: IFFALSE 11851
// result := result diff i ;
11835: LD_ADDR_VAR 0 4
11839: PUSH
11840: LD_VAR 0 4
11844: PUSH
11845: LD_VAR 0 5
11849: DIFF
11850: ST_TO_ADDR
11851: GO 11810
11853: POP
11854: POP
// end ;
11855: LD_VAR 0 4
11859: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11860: LD_INT 0
11862: PPUSH
11863: PPUSH
11864: PPUSH
// result := true ;
11865: LD_ADDR_VAR 0 3
11869: PUSH
11870: LD_INT 1
11872: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11873: LD_ADDR_VAR 0 5
11877: PUSH
11878: LD_VAR 0 2
11882: PPUSH
11883: CALL_OW 480
11887: ST_TO_ADDR
// if not tmp then
11888: LD_VAR 0 5
11892: NOT
11893: IFFALSE 11897
// exit ;
11895: GO 11946
// for i in tmp do
11897: LD_ADDR_VAR 0 4
11901: PUSH
11902: LD_VAR 0 5
11906: PUSH
11907: FOR_IN
11908: IFFALSE 11944
// if GetTech ( i , side ) <> state_researched then
11910: LD_VAR 0 4
11914: PPUSH
11915: LD_VAR 0 1
11919: PPUSH
11920: CALL_OW 321
11924: PUSH
11925: LD_INT 2
11927: NONEQUAL
11928: IFFALSE 11942
// begin result := false ;
11930: LD_ADDR_VAR 0 3
11934: PUSH
11935: LD_INT 0
11937: ST_TO_ADDR
// exit ;
11938: POP
11939: POP
11940: GO 11946
// end ;
11942: GO 11907
11944: POP
11945: POP
// end ;
11946: LD_VAR 0 3
11950: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11951: LD_INT 0
11953: PPUSH
11954: PPUSH
11955: PPUSH
11956: PPUSH
11957: PPUSH
11958: PPUSH
11959: PPUSH
11960: PPUSH
11961: PPUSH
11962: PPUSH
11963: PPUSH
11964: PPUSH
11965: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11966: LD_VAR 0 1
11970: NOT
11971: PUSH
11972: LD_VAR 0 1
11976: PPUSH
11977: CALL_OW 257
11981: PUSH
11982: LD_INT 9
11984: NONEQUAL
11985: OR
11986: IFFALSE 11990
// exit ;
11988: GO 12563
// side := GetSide ( unit ) ;
11990: LD_ADDR_VAR 0 9
11994: PUSH
11995: LD_VAR 0 1
11999: PPUSH
12000: CALL_OW 255
12004: ST_TO_ADDR
// tech_space := tech_spacanom ;
12005: LD_ADDR_VAR 0 12
12009: PUSH
12010: LD_INT 29
12012: ST_TO_ADDR
// tech_time := tech_taurad ;
12013: LD_ADDR_VAR 0 13
12017: PUSH
12018: LD_INT 28
12020: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12021: LD_ADDR_VAR 0 11
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 310
12035: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12036: LD_VAR 0 11
12040: PPUSH
12041: CALL_OW 247
12045: PUSH
12046: LD_INT 2
12048: EQUAL
12049: IFFALSE 12053
// exit ;
12051: GO 12563
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12053: LD_ADDR_VAR 0 8
12057: PUSH
12058: LD_INT 81
12060: PUSH
12061: LD_VAR 0 9
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 3
12072: PUSH
12073: LD_INT 21
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: EMPTY
12084: LIST
12085: LIST
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PPUSH
12091: CALL_OW 69
12095: ST_TO_ADDR
// if not tmp then
12096: LD_VAR 0 8
12100: NOT
12101: IFFALSE 12105
// exit ;
12103: GO 12563
// if in_unit then
12105: LD_VAR 0 11
12109: IFFALSE 12133
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12111: LD_ADDR_VAR 0 10
12115: PUSH
12116: LD_VAR 0 8
12120: PPUSH
12121: LD_VAR 0 11
12125: PPUSH
12126: CALL_OW 74
12130: ST_TO_ADDR
12131: GO 12153
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12133: LD_ADDR_VAR 0 10
12137: PUSH
12138: LD_VAR 0 8
12142: PPUSH
12143: LD_VAR 0 1
12147: PPUSH
12148: CALL_OW 74
12152: ST_TO_ADDR
// if not enemy then
12153: LD_VAR 0 10
12157: NOT
12158: IFFALSE 12162
// exit ;
12160: GO 12563
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12162: LD_VAR 0 11
12166: PUSH
12167: LD_VAR 0 11
12171: PPUSH
12172: LD_VAR 0 10
12176: PPUSH
12177: CALL_OW 296
12181: PUSH
12182: LD_INT 13
12184: GREATER
12185: AND
12186: PUSH
12187: LD_VAR 0 1
12191: PPUSH
12192: LD_VAR 0 10
12196: PPUSH
12197: CALL_OW 296
12201: PUSH
12202: LD_INT 12
12204: GREATER
12205: OR
12206: IFFALSE 12210
// exit ;
12208: GO 12563
// missile := [ 1 ] ;
12210: LD_ADDR_VAR 0 14
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12221: LD_VAR 0 9
12225: PPUSH
12226: LD_VAR 0 12
12230: PPUSH
12231: CALL_OW 325
12235: IFFALSE 12264
// missile := Insert ( missile , missile + 1 , 2 ) ;
12237: LD_ADDR_VAR 0 14
12241: PUSH
12242: LD_VAR 0 14
12246: PPUSH
12247: LD_VAR 0 14
12251: PUSH
12252: LD_INT 1
12254: PLUS
12255: PPUSH
12256: LD_INT 2
12258: PPUSH
12259: CALL_OW 2
12263: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12264: LD_VAR 0 9
12268: PPUSH
12269: LD_VAR 0 13
12273: PPUSH
12274: CALL_OW 325
12278: PUSH
12279: LD_VAR 0 10
12283: PPUSH
12284: CALL_OW 255
12288: PPUSH
12289: LD_VAR 0 13
12293: PPUSH
12294: CALL_OW 325
12298: NOT
12299: AND
12300: IFFALSE 12329
// missile := Insert ( missile , missile + 1 , 3 ) ;
12302: LD_ADDR_VAR 0 14
12306: PUSH
12307: LD_VAR 0 14
12311: PPUSH
12312: LD_VAR 0 14
12316: PUSH
12317: LD_INT 1
12319: PLUS
12320: PPUSH
12321: LD_INT 3
12323: PPUSH
12324: CALL_OW 2
12328: ST_TO_ADDR
// if missile < 2 then
12329: LD_VAR 0 14
12333: PUSH
12334: LD_INT 2
12336: LESS
12337: IFFALSE 12341
// exit ;
12339: GO 12563
// x := GetX ( enemy ) ;
12341: LD_ADDR_VAR 0 4
12345: PUSH
12346: LD_VAR 0 10
12350: PPUSH
12351: CALL_OW 250
12355: ST_TO_ADDR
// y := GetY ( enemy ) ;
12356: LD_ADDR_VAR 0 5
12360: PUSH
12361: LD_VAR 0 10
12365: PPUSH
12366: CALL_OW 251
12370: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12371: LD_ADDR_VAR 0 6
12375: PUSH
12376: LD_VAR 0 4
12380: PUSH
12381: LD_INT 1
12383: NEG
12384: PPUSH
12385: LD_INT 1
12387: PPUSH
12388: CALL_OW 12
12392: PLUS
12393: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12394: LD_ADDR_VAR 0 7
12398: PUSH
12399: LD_VAR 0 5
12403: PUSH
12404: LD_INT 1
12406: NEG
12407: PPUSH
12408: LD_INT 1
12410: PPUSH
12411: CALL_OW 12
12415: PLUS
12416: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12417: LD_VAR 0 6
12421: PPUSH
12422: LD_VAR 0 7
12426: PPUSH
12427: CALL_OW 488
12431: NOT
12432: IFFALSE 12454
// begin _x := x ;
12434: LD_ADDR_VAR 0 6
12438: PUSH
12439: LD_VAR 0 4
12443: ST_TO_ADDR
// _y := y ;
12444: LD_ADDR_VAR 0 7
12448: PUSH
12449: LD_VAR 0 5
12453: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12454: LD_ADDR_VAR 0 3
12458: PUSH
12459: LD_INT 1
12461: PPUSH
12462: LD_VAR 0 14
12466: PPUSH
12467: CALL_OW 12
12471: ST_TO_ADDR
// case i of 1 :
12472: LD_VAR 0 3
12476: PUSH
12477: LD_INT 1
12479: DOUBLE
12480: EQUAL
12481: IFTRUE 12485
12483: GO 12502
12485: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12486: LD_VAR 0 1
12490: PPUSH
12491: LD_VAR 0 10
12495: PPUSH
12496: CALL_OW 115
12500: GO 12563
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12532
12510: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12511: LD_VAR 0 1
12515: PPUSH
12516: LD_VAR 0 6
12520: PPUSH
12521: LD_VAR 0 7
12525: PPUSH
12526: CALL_OW 153
12530: GO 12563
12532: LD_INT 3
12534: DOUBLE
12535: EQUAL
12536: IFTRUE 12540
12538: GO 12562
12540: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 6
12550: PPUSH
12551: LD_VAR 0 7
12555: PPUSH
12556: CALL_OW 154
12560: GO 12563
12562: POP
// end ;
12563: LD_VAR 0 2
12567: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12568: LD_INT 0
12570: PPUSH
12571: PPUSH
12572: PPUSH
12573: PPUSH
12574: PPUSH
12575: PPUSH
// if not unit or not building then
12576: LD_VAR 0 1
12580: NOT
12581: PUSH
12582: LD_VAR 0 2
12586: NOT
12587: OR
12588: IFFALSE 12592
// exit ;
12590: GO 12750
// x := GetX ( building ) ;
12592: LD_ADDR_VAR 0 5
12596: PUSH
12597: LD_VAR 0 2
12601: PPUSH
12602: CALL_OW 250
12606: ST_TO_ADDR
// y := GetY ( building ) ;
12607: LD_ADDR_VAR 0 6
12611: PUSH
12612: LD_VAR 0 2
12616: PPUSH
12617: CALL_OW 251
12621: ST_TO_ADDR
// for i = 0 to 5 do
12622: LD_ADDR_VAR 0 4
12626: PUSH
12627: DOUBLE
12628: LD_INT 0
12630: DEC
12631: ST_TO_ADDR
12632: LD_INT 5
12634: PUSH
12635: FOR_TO
12636: IFFALSE 12748
// begin _x := ShiftX ( x , i , 3 ) ;
12638: LD_ADDR_VAR 0 7
12642: PUSH
12643: LD_VAR 0 5
12647: PPUSH
12648: LD_VAR 0 4
12652: PPUSH
12653: LD_INT 3
12655: PPUSH
12656: CALL_OW 272
12660: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12661: LD_ADDR_VAR 0 8
12665: PUSH
12666: LD_VAR 0 6
12670: PPUSH
12671: LD_VAR 0 4
12675: PPUSH
12676: LD_INT 3
12678: PPUSH
12679: CALL_OW 273
12683: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12684: LD_VAR 0 7
12688: PPUSH
12689: LD_VAR 0 8
12693: PPUSH
12694: CALL_OW 488
12698: NOT
12699: IFFALSE 12703
// continue ;
12701: GO 12635
// if HexInfo ( _x , _y ) = 0 then
12703: LD_VAR 0 7
12707: PPUSH
12708: LD_VAR 0 8
12712: PPUSH
12713: CALL_OW 428
12717: PUSH
12718: LD_INT 0
12720: EQUAL
12721: IFFALSE 12746
// begin ComMoveXY ( unit , _x , _y ) ;
12723: LD_VAR 0 1
12727: PPUSH
12728: LD_VAR 0 7
12732: PPUSH
12733: LD_VAR 0 8
12737: PPUSH
12738: CALL_OW 111
// exit ;
12742: POP
12743: POP
12744: GO 12750
// end ; end ;
12746: GO 12635
12748: POP
12749: POP
// end ;
12750: LD_VAR 0 3
12754: RET
// export function ScanBase ( side , base_area ) ; begin
12755: LD_INT 0
12757: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_VAR 0 2
12767: PPUSH
12768: LD_INT 81
12770: PUSH
12771: LD_VAR 0 1
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PPUSH
12780: CALL_OW 70
12784: ST_TO_ADDR
// end ;
12785: LD_VAR 0 3
12789: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12790: LD_INT 0
12792: PPUSH
12793: PPUSH
12794: PPUSH
12795: PPUSH
// result := false ;
12796: LD_ADDR_VAR 0 2
12800: PUSH
12801: LD_INT 0
12803: ST_TO_ADDR
// side := GetSide ( unit ) ;
12804: LD_ADDR_VAR 0 3
12808: PUSH
12809: LD_VAR 0 1
12813: PPUSH
12814: CALL_OW 255
12818: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12819: LD_ADDR_VAR 0 4
12823: PUSH
12824: LD_VAR 0 1
12828: PPUSH
12829: CALL_OW 248
12833: ST_TO_ADDR
// case nat of 1 :
12834: LD_VAR 0 4
12838: PUSH
12839: LD_INT 1
12841: DOUBLE
12842: EQUAL
12843: IFTRUE 12847
12845: GO 12858
12847: POP
// tech := tech_lassight ; 2 :
12848: LD_ADDR_VAR 0 5
12852: PUSH
12853: LD_INT 12
12855: ST_TO_ADDR
12856: GO 12897
12858: LD_INT 2
12860: DOUBLE
12861: EQUAL
12862: IFTRUE 12866
12864: GO 12877
12866: POP
// tech := tech_mortar ; 3 :
12867: LD_ADDR_VAR 0 5
12871: PUSH
12872: LD_INT 41
12874: ST_TO_ADDR
12875: GO 12897
12877: LD_INT 3
12879: DOUBLE
12880: EQUAL
12881: IFTRUE 12885
12883: GO 12896
12885: POP
// tech := tech_bazooka ; end ;
12886: LD_ADDR_VAR 0 5
12890: PUSH
12891: LD_INT 44
12893: ST_TO_ADDR
12894: GO 12897
12896: POP
// if Researched ( side , tech ) then
12897: LD_VAR 0 3
12901: PPUSH
12902: LD_VAR 0 5
12906: PPUSH
12907: CALL_OW 325
12911: IFFALSE 12938
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12913: LD_ADDR_VAR 0 2
12917: PUSH
12918: LD_INT 5
12920: PUSH
12921: LD_INT 8
12923: PUSH
12924: LD_INT 9
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: LIST
12931: PUSH
12932: LD_VAR 0 4
12936: ARRAY
12937: ST_TO_ADDR
// end ;
12938: LD_VAR 0 2
12942: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12943: LD_INT 0
12945: PPUSH
12946: PPUSH
12947: PPUSH
// if not mines then
12948: LD_VAR 0 2
12952: NOT
12953: IFFALSE 12957
// exit ;
12955: GO 13101
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12957: LD_ADDR_VAR 0 5
12961: PUSH
12962: LD_INT 81
12964: PUSH
12965: LD_VAR 0 1
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 3
12976: PUSH
12977: LD_INT 21
12979: PUSH
12980: LD_INT 3
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PPUSH
12995: CALL_OW 69
12999: ST_TO_ADDR
// for i in mines do
13000: LD_ADDR_VAR 0 4
13004: PUSH
13005: LD_VAR 0 2
13009: PUSH
13010: FOR_IN
13011: IFFALSE 13099
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13013: LD_VAR 0 4
13017: PUSH
13018: LD_INT 1
13020: ARRAY
13021: PPUSH
13022: LD_VAR 0 4
13026: PUSH
13027: LD_INT 2
13029: ARRAY
13030: PPUSH
13031: CALL_OW 458
13035: NOT
13036: IFFALSE 13040
// continue ;
13038: GO 13010
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13040: LD_VAR 0 4
13044: PUSH
13045: LD_INT 1
13047: ARRAY
13048: PPUSH
13049: LD_VAR 0 4
13053: PUSH
13054: LD_INT 2
13056: ARRAY
13057: PPUSH
13058: CALL_OW 428
13062: PUSH
13063: LD_VAR 0 5
13067: IN
13068: IFFALSE 13097
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13070: LD_VAR 0 4
13074: PUSH
13075: LD_INT 1
13077: ARRAY
13078: PPUSH
13079: LD_VAR 0 4
13083: PUSH
13084: LD_INT 2
13086: ARRAY
13087: PPUSH
13088: LD_VAR 0 1
13092: PPUSH
13093: CALL_OW 456
// end ;
13097: GO 13010
13099: POP
13100: POP
// end ;
13101: LD_VAR 0 3
13105: RET
// export function Count ( array ) ; var i ; begin
13106: LD_INT 0
13108: PPUSH
13109: PPUSH
// result := 0 ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_INT 0
13117: ST_TO_ADDR
// for i in array do
13118: LD_ADDR_VAR 0 3
13122: PUSH
13123: LD_VAR 0 1
13127: PUSH
13128: FOR_IN
13129: IFFALSE 13153
// if i then
13131: LD_VAR 0 3
13135: IFFALSE 13151
// result := result + 1 ;
13137: LD_ADDR_VAR 0 2
13141: PUSH
13142: LD_VAR 0 2
13146: PUSH
13147: LD_INT 1
13149: PLUS
13150: ST_TO_ADDR
13151: GO 13128
13153: POP
13154: POP
// end ;
13155: LD_VAR 0 2
13159: RET
// export function IsEmpty ( building ) ; begin
13160: LD_INT 0
13162: PPUSH
// if not building then
13163: LD_VAR 0 1
13167: NOT
13168: IFFALSE 13172
// exit ;
13170: GO 13215
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13172: LD_ADDR_VAR 0 2
13176: PUSH
13177: LD_VAR 0 1
13181: PUSH
13182: LD_INT 22
13184: PUSH
13185: LD_VAR 0 1
13189: PPUSH
13190: CALL_OW 255
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 58
13201: PUSH
13202: EMPTY
13203: LIST
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PPUSH
13209: CALL_OW 69
13213: IN
13214: ST_TO_ADDR
// end ;
13215: LD_VAR 0 2
13219: RET
// export function IsNotFull ( building ) ; begin
13220: LD_INT 0
13222: PPUSH
// if not building then
13223: LD_VAR 0 1
13227: NOT
13228: IFFALSE 13232
// exit ;
13230: GO 13251
// result := UnitsInside ( building ) < 6 ;
13232: LD_ADDR_VAR 0 2
13236: PUSH
13237: LD_VAR 0 1
13241: PPUSH
13242: CALL_OW 313
13246: PUSH
13247: LD_INT 6
13249: LESS
13250: ST_TO_ADDR
// end ;
13251: LD_VAR 0 2
13255: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13256: LD_INT 0
13258: PPUSH
13259: PPUSH
13260: PPUSH
13261: PPUSH
// tmp := [ ] ;
13262: LD_ADDR_VAR 0 3
13266: PUSH
13267: EMPTY
13268: ST_TO_ADDR
// list := [ ] ;
13269: LD_ADDR_VAR 0 5
13273: PUSH
13274: EMPTY
13275: ST_TO_ADDR
// for i = 16 to 25 do
13276: LD_ADDR_VAR 0 4
13280: PUSH
13281: DOUBLE
13282: LD_INT 16
13284: DEC
13285: ST_TO_ADDR
13286: LD_INT 25
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13363
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13292: LD_ADDR_VAR 0 3
13296: PUSH
13297: LD_VAR 0 3
13301: PUSH
13302: LD_INT 22
13304: PUSH
13305: LD_VAR 0 1
13309: PPUSH
13310: CALL_OW 255
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: PUSH
13319: LD_INT 91
13321: PUSH
13322: LD_VAR 0 1
13326: PUSH
13327: LD_INT 6
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 30
13337: PUSH
13338: LD_VAR 0 4
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: LIST
13351: PUSH
13352: EMPTY
13353: LIST
13354: PPUSH
13355: CALL_OW 69
13359: ADD
13360: ST_TO_ADDR
13361: GO 13289
13363: POP
13364: POP
// for i = 1 to tmp do
13365: LD_ADDR_VAR 0 4
13369: PUSH
13370: DOUBLE
13371: LD_INT 1
13373: DEC
13374: ST_TO_ADDR
13375: LD_VAR 0 3
13379: PUSH
13380: FOR_TO
13381: IFFALSE 13469
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13383: LD_ADDR_VAR 0 5
13387: PUSH
13388: LD_VAR 0 5
13392: PUSH
13393: LD_VAR 0 3
13397: PUSH
13398: LD_VAR 0 4
13402: ARRAY
13403: PPUSH
13404: CALL_OW 266
13408: PUSH
13409: LD_VAR 0 3
13413: PUSH
13414: LD_VAR 0 4
13418: ARRAY
13419: PPUSH
13420: CALL_OW 250
13424: PUSH
13425: LD_VAR 0 3
13429: PUSH
13430: LD_VAR 0 4
13434: ARRAY
13435: PPUSH
13436: CALL_OW 251
13440: PUSH
13441: LD_VAR 0 3
13445: PUSH
13446: LD_VAR 0 4
13450: ARRAY
13451: PPUSH
13452: CALL_OW 254
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: PUSH
13463: EMPTY
13464: LIST
13465: ADD
13466: ST_TO_ADDR
13467: GO 13380
13469: POP
13470: POP
// result := list ;
13471: LD_ADDR_VAR 0 2
13475: PUSH
13476: LD_VAR 0 5
13480: ST_TO_ADDR
// end ;
13481: LD_VAR 0 2
13485: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13486: LD_INT 0
13488: PPUSH
13489: PPUSH
13490: PPUSH
13491: PPUSH
13492: PPUSH
13493: PPUSH
13494: PPUSH
// if not factory then
13495: LD_VAR 0 1
13499: NOT
13500: IFFALSE 13504
// exit ;
13502: GO 14097
// if control = control_apeman then
13504: LD_VAR 0 4
13508: PUSH
13509: LD_INT 5
13511: EQUAL
13512: IFFALSE 13621
// begin tmp := UnitsInside ( factory ) ;
13514: LD_ADDR_VAR 0 8
13518: PUSH
13519: LD_VAR 0 1
13523: PPUSH
13524: CALL_OW 313
13528: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13529: LD_VAR 0 8
13533: PPUSH
13534: LD_INT 25
13536: PUSH
13537: LD_INT 12
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: PPUSH
13544: CALL_OW 72
13548: NOT
13549: IFFALSE 13559
// control := control_manual ;
13551: LD_ADDR_VAR 0 4
13555: PUSH
13556: LD_INT 1
13558: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13559: LD_ADDR_VAR 0 8
13563: PUSH
13564: LD_VAR 0 1
13568: PPUSH
13569: CALL 13256 0 1
13573: ST_TO_ADDR
// if tmp then
13574: LD_VAR 0 8
13578: IFFALSE 13621
// begin for i in tmp do
13580: LD_ADDR_VAR 0 7
13584: PUSH
13585: LD_VAR 0 8
13589: PUSH
13590: FOR_IN
13591: IFFALSE 13619
// if i [ 1 ] = b_ext_radio then
13593: LD_VAR 0 7
13597: PUSH
13598: LD_INT 1
13600: ARRAY
13601: PUSH
13602: LD_INT 22
13604: EQUAL
13605: IFFALSE 13617
// begin control := control_remote ;
13607: LD_ADDR_VAR 0 4
13611: PUSH
13612: LD_INT 2
13614: ST_TO_ADDR
// break ;
13615: GO 13619
// end ;
13617: GO 13590
13619: POP
13620: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13621: LD_VAR 0 1
13625: PPUSH
13626: LD_VAR 0 2
13630: PPUSH
13631: LD_VAR 0 3
13635: PPUSH
13636: LD_VAR 0 4
13640: PPUSH
13641: LD_VAR 0 5
13645: PPUSH
13646: CALL_OW 448
13650: IFFALSE 13685
// begin result := [ chassis , engine , control , weapon ] ;
13652: LD_ADDR_VAR 0 6
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: LD_VAR 0 3
13666: PUSH
13667: LD_VAR 0 4
13671: PUSH
13672: LD_VAR 0 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: ST_TO_ADDR
// exit ;
13683: GO 14097
// end ; _chassis := AvailableChassisList ( factory ) ;
13685: LD_ADDR_VAR 0 9
13689: PUSH
13690: LD_VAR 0 1
13694: PPUSH
13695: CALL_OW 475
13699: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13700: LD_ADDR_VAR 0 11
13704: PUSH
13705: LD_VAR 0 1
13709: PPUSH
13710: CALL_OW 476
13714: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13715: LD_ADDR_VAR 0 12
13719: PUSH
13720: LD_VAR 0 1
13724: PPUSH
13725: CALL_OW 477
13729: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13730: LD_ADDR_VAR 0 10
13734: PUSH
13735: LD_VAR 0 1
13739: PPUSH
13740: CALL_OW 478
13744: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13745: LD_VAR 0 9
13749: NOT
13750: PUSH
13751: LD_VAR 0 11
13755: NOT
13756: OR
13757: PUSH
13758: LD_VAR 0 12
13762: NOT
13763: OR
13764: PUSH
13765: LD_VAR 0 10
13769: NOT
13770: OR
13771: IFFALSE 13806
// begin result := [ chassis , engine , control , weapon ] ;
13773: LD_ADDR_VAR 0 6
13777: PUSH
13778: LD_VAR 0 2
13782: PUSH
13783: LD_VAR 0 3
13787: PUSH
13788: LD_VAR 0 4
13792: PUSH
13793: LD_VAR 0 5
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: ST_TO_ADDR
// exit ;
13804: GO 14097
// end ; if not chassis in _chassis then
13806: LD_VAR 0 2
13810: PUSH
13811: LD_VAR 0 9
13815: IN
13816: NOT
13817: IFFALSE 13843
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13819: LD_ADDR_VAR 0 2
13823: PUSH
13824: LD_VAR 0 9
13828: PUSH
13829: LD_INT 1
13831: PPUSH
13832: LD_VAR 0 9
13836: PPUSH
13837: CALL_OW 12
13841: ARRAY
13842: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13843: LD_VAR 0 2
13847: PPUSH
13848: LD_VAR 0 3
13852: PPUSH
13853: CALL 14102 0 2
13857: NOT
13858: IFFALSE 13917
// repeat engine := _engine [ 1 ] ;
13860: LD_ADDR_VAR 0 3
13864: PUSH
13865: LD_VAR 0 11
13869: PUSH
13870: LD_INT 1
13872: ARRAY
13873: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13874: LD_ADDR_VAR 0 11
13878: PUSH
13879: LD_VAR 0 11
13883: PPUSH
13884: LD_INT 1
13886: PPUSH
13887: CALL_OW 3
13891: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13892: LD_VAR 0 2
13896: PPUSH
13897: LD_VAR 0 3
13901: PPUSH
13902: CALL 14102 0 2
13906: PUSH
13907: LD_VAR 0 11
13911: PUSH
13912: EMPTY
13913: EQUAL
13914: OR
13915: IFFALSE 13860
// if not control in _control then
13917: LD_VAR 0 4
13921: PUSH
13922: LD_VAR 0 12
13926: IN
13927: NOT
13928: IFFALSE 13954
// control := _control [ rand ( 1 , _control ) ] ;
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_VAR 0 12
13939: PUSH
13940: LD_INT 1
13942: PPUSH
13943: LD_VAR 0 12
13947: PPUSH
13948: CALL_OW 12
13952: ARRAY
13953: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
13954: LD_VAR 0 2
13958: PPUSH
13959: LD_VAR 0 5
13963: PPUSH
13964: CALL 14322 0 2
13968: NOT
13969: IFFALSE 14028
// repeat weapon := _weapon [ 1 ] ;
13971: LD_ADDR_VAR 0 5
13975: PUSH
13976: LD_VAR 0 10
13980: PUSH
13981: LD_INT 1
13983: ARRAY
13984: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
13985: LD_ADDR_VAR 0 10
13989: PUSH
13990: LD_VAR 0 10
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: CALL_OW 3
14002: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14003: LD_VAR 0 2
14007: PPUSH
14008: LD_VAR 0 5
14012: PPUSH
14013: CALL 14322 0 2
14017: PUSH
14018: LD_VAR 0 10
14022: PUSH
14023: EMPTY
14024: EQUAL
14025: OR
14026: IFFALSE 13971
// result := [ ] ;
14028: LD_ADDR_VAR 0 6
14032: PUSH
14033: EMPTY
14034: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14035: LD_VAR 0 1
14039: PPUSH
14040: LD_VAR 0 2
14044: PPUSH
14045: LD_VAR 0 3
14049: PPUSH
14050: LD_VAR 0 4
14054: PPUSH
14055: LD_VAR 0 5
14059: PPUSH
14060: CALL_OW 448
14064: IFFALSE 14097
// result := [ chassis , engine , control , weapon ] ;
14066: LD_ADDR_VAR 0 6
14070: PUSH
14071: LD_VAR 0 2
14075: PUSH
14076: LD_VAR 0 3
14080: PUSH
14081: LD_VAR 0 4
14085: PUSH
14086: LD_VAR 0 5
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: ST_TO_ADDR
// end ;
14097: LD_VAR 0 6
14101: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14102: LD_INT 0
14104: PPUSH
// if not chassis or not engine then
14105: LD_VAR 0 1
14109: NOT
14110: PUSH
14111: LD_VAR 0 2
14115: NOT
14116: OR
14117: IFFALSE 14121
// exit ;
14119: GO 14317
// case engine of engine_solar :
14121: LD_VAR 0 2
14125: PUSH
14126: LD_INT 2
14128: DOUBLE
14129: EQUAL
14130: IFTRUE 14134
14132: GO 14172
14134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14135: LD_ADDR_VAR 0 3
14139: PUSH
14140: LD_INT 11
14142: PUSH
14143: LD_INT 12
14145: PUSH
14146: LD_INT 13
14148: PUSH
14149: LD_INT 14
14151: PUSH
14152: LD_INT 1
14154: PUSH
14155: LD_INT 2
14157: PUSH
14158: LD_INT 3
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: ST_TO_ADDR
14170: GO 14301
14172: LD_INT 1
14174: DOUBLE
14175: EQUAL
14176: IFTRUE 14180
14178: GO 14242
14180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14181: LD_ADDR_VAR 0 3
14185: PUSH
14186: LD_INT 11
14188: PUSH
14189: LD_INT 12
14191: PUSH
14192: LD_INT 13
14194: PUSH
14195: LD_INT 14
14197: PUSH
14198: LD_INT 1
14200: PUSH
14201: LD_INT 2
14203: PUSH
14204: LD_INT 3
14206: PUSH
14207: LD_INT 4
14209: PUSH
14210: LD_INT 5
14212: PUSH
14213: LD_INT 21
14215: PUSH
14216: LD_INT 23
14218: PUSH
14219: LD_INT 22
14221: PUSH
14222: LD_INT 24
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: ST_TO_ADDR
14240: GO 14301
14242: LD_INT 3
14244: DOUBLE
14245: EQUAL
14246: IFTRUE 14250
14248: GO 14300
14250: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14251: LD_ADDR_VAR 0 3
14255: PUSH
14256: LD_INT 13
14258: PUSH
14259: LD_INT 14
14261: PUSH
14262: LD_INT 2
14264: PUSH
14265: LD_INT 3
14267: PUSH
14268: LD_INT 4
14270: PUSH
14271: LD_INT 5
14273: PUSH
14274: LD_INT 21
14276: PUSH
14277: LD_INT 22
14279: PUSH
14280: LD_INT 23
14282: PUSH
14283: LD_INT 24
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: ST_TO_ADDR
14298: GO 14301
14300: POP
// result := ( chassis in result ) ;
14301: LD_ADDR_VAR 0 3
14305: PUSH
14306: LD_VAR 0 1
14310: PUSH
14311: LD_VAR 0 3
14315: IN
14316: ST_TO_ADDR
// end ;
14317: LD_VAR 0 3
14321: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14322: LD_INT 0
14324: PPUSH
// if not chassis or not weapon then
14325: LD_VAR 0 1
14329: NOT
14330: PUSH
14331: LD_VAR 0 2
14335: NOT
14336: OR
14337: IFFALSE 14341
// exit ;
14339: GO 15403
// case weapon of us_machine_gun :
14341: LD_VAR 0 2
14345: PUSH
14346: LD_INT 2
14348: DOUBLE
14349: EQUAL
14350: IFTRUE 14354
14352: GO 14384
14354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14355: LD_ADDR_VAR 0 3
14359: PUSH
14360: LD_INT 1
14362: PUSH
14363: LD_INT 2
14365: PUSH
14366: LD_INT 3
14368: PUSH
14369: LD_INT 4
14371: PUSH
14372: LD_INT 5
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: ST_TO_ADDR
14382: GO 15387
14384: LD_INT 3
14386: DOUBLE
14387: EQUAL
14388: IFTRUE 14392
14390: GO 14422
14392: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 1
14400: PUSH
14401: LD_INT 2
14403: PUSH
14404: LD_INT 3
14406: PUSH
14407: LD_INT 4
14409: PUSH
14410: LD_INT 5
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: ST_TO_ADDR
14420: GO 15387
14422: LD_INT 11
14424: DOUBLE
14425: EQUAL
14426: IFTRUE 14430
14428: GO 14460
14430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14431: LD_ADDR_VAR 0 3
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: LD_INT 2
14441: PUSH
14442: LD_INT 3
14444: PUSH
14445: LD_INT 4
14447: PUSH
14448: LD_INT 5
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: ST_TO_ADDR
14458: GO 15387
14460: LD_INT 4
14462: DOUBLE
14463: EQUAL
14464: IFTRUE 14468
14466: GO 14494
14468: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14469: LD_ADDR_VAR 0 3
14473: PUSH
14474: LD_INT 2
14476: PUSH
14477: LD_INT 3
14479: PUSH
14480: LD_INT 4
14482: PUSH
14483: LD_INT 5
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: ST_TO_ADDR
14492: GO 15387
14494: LD_INT 5
14496: DOUBLE
14497: EQUAL
14498: IFTRUE 14502
14500: GO 14528
14502: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14503: LD_ADDR_VAR 0 3
14507: PUSH
14508: LD_INT 2
14510: PUSH
14511: LD_INT 3
14513: PUSH
14514: LD_INT 4
14516: PUSH
14517: LD_INT 5
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: ST_TO_ADDR
14526: GO 15387
14528: LD_INT 9
14530: DOUBLE
14531: EQUAL
14532: IFTRUE 14536
14534: GO 14562
14536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 2
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: LD_INT 4
14550: PUSH
14551: LD_INT 5
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: ST_TO_ADDR
14560: GO 15387
14562: LD_INT 7
14564: DOUBLE
14565: EQUAL
14566: IFTRUE 14570
14568: GO 14596
14570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14571: LD_ADDR_VAR 0 3
14575: PUSH
14576: LD_INT 2
14578: PUSH
14579: LD_INT 3
14581: PUSH
14582: LD_INT 4
14584: PUSH
14585: LD_INT 5
14587: PUSH
14588: EMPTY
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: ST_TO_ADDR
14594: GO 15387
14596: LD_INT 12
14598: DOUBLE
14599: EQUAL
14600: IFTRUE 14604
14602: GO 14630
14604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14605: LD_ADDR_VAR 0 3
14609: PUSH
14610: LD_INT 2
14612: PUSH
14613: LD_INT 3
14615: PUSH
14616: LD_INT 4
14618: PUSH
14619: LD_INT 5
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: ST_TO_ADDR
14628: GO 15387
14630: LD_INT 13
14632: DOUBLE
14633: EQUAL
14634: IFTRUE 14638
14636: GO 14664
14638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14639: LD_ADDR_VAR 0 3
14643: PUSH
14644: LD_INT 2
14646: PUSH
14647: LD_INT 3
14649: PUSH
14650: LD_INT 4
14652: PUSH
14653: LD_INT 5
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: ST_TO_ADDR
14662: GO 15387
14664: LD_INT 14
14666: DOUBLE
14667: EQUAL
14668: IFTRUE 14672
14670: GO 14690
14672: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 4
14680: PUSH
14681: LD_INT 5
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: ST_TO_ADDR
14688: GO 15387
14690: LD_INT 6
14692: DOUBLE
14693: EQUAL
14694: IFTRUE 14698
14696: GO 14716
14698: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14699: LD_ADDR_VAR 0 3
14703: PUSH
14704: LD_INT 4
14706: PUSH
14707: LD_INT 5
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: ST_TO_ADDR
14714: GO 15387
14716: LD_INT 10
14718: DOUBLE
14719: EQUAL
14720: IFTRUE 14724
14722: GO 14742
14724: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14725: LD_ADDR_VAR 0 3
14729: PUSH
14730: LD_INT 4
14732: PUSH
14733: LD_INT 5
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: ST_TO_ADDR
14740: GO 15387
14742: LD_INT 22
14744: DOUBLE
14745: EQUAL
14746: IFTRUE 14750
14748: GO 14776
14750: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14751: LD_ADDR_VAR 0 3
14755: PUSH
14756: LD_INT 11
14758: PUSH
14759: LD_INT 12
14761: PUSH
14762: LD_INT 13
14764: PUSH
14765: LD_INT 14
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: ST_TO_ADDR
14774: GO 15387
14776: LD_INT 23
14778: DOUBLE
14779: EQUAL
14780: IFTRUE 14784
14782: GO 14810
14784: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14785: LD_ADDR_VAR 0 3
14789: PUSH
14790: LD_INT 11
14792: PUSH
14793: LD_INT 12
14795: PUSH
14796: LD_INT 13
14798: PUSH
14799: LD_INT 14
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: ST_TO_ADDR
14808: GO 15387
14810: LD_INT 24
14812: DOUBLE
14813: EQUAL
14814: IFTRUE 14818
14816: GO 14844
14818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14819: LD_ADDR_VAR 0 3
14823: PUSH
14824: LD_INT 11
14826: PUSH
14827: LD_INT 12
14829: PUSH
14830: LD_INT 13
14832: PUSH
14833: LD_INT 14
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: ST_TO_ADDR
14842: GO 15387
14844: LD_INT 30
14846: DOUBLE
14847: EQUAL
14848: IFTRUE 14852
14850: GO 14878
14852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14853: LD_ADDR_VAR 0 3
14857: PUSH
14858: LD_INT 11
14860: PUSH
14861: LD_INT 12
14863: PUSH
14864: LD_INT 13
14866: PUSH
14867: LD_INT 14
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: ST_TO_ADDR
14876: GO 15387
14878: LD_INT 25
14880: DOUBLE
14881: EQUAL
14882: IFTRUE 14886
14884: GO 14904
14886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14887: LD_ADDR_VAR 0 3
14891: PUSH
14892: LD_INT 13
14894: PUSH
14895: LD_INT 14
14897: PUSH
14898: EMPTY
14899: LIST
14900: LIST
14901: ST_TO_ADDR
14902: GO 15387
14904: LD_INT 27
14906: DOUBLE
14907: EQUAL
14908: IFTRUE 14912
14910: GO 14930
14912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
14913: LD_ADDR_VAR 0 3
14917: PUSH
14918: LD_INT 13
14920: PUSH
14921: LD_INT 14
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: ST_TO_ADDR
14928: GO 15387
14930: LD_EXP 72
14934: DOUBLE
14935: EQUAL
14936: IFTRUE 14940
14938: GO 14966
14940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_INT 11
14948: PUSH
14949: LD_INT 12
14951: PUSH
14952: LD_INT 13
14954: PUSH
14955: LD_INT 14
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: ST_TO_ADDR
14964: GO 15387
14966: LD_INT 28
14968: DOUBLE
14969: EQUAL
14970: IFTRUE 14974
14972: GO 14992
14974: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
14975: LD_ADDR_VAR 0 3
14979: PUSH
14980: LD_INT 13
14982: PUSH
14983: LD_INT 14
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: ST_TO_ADDR
14990: GO 15387
14992: LD_INT 29
14994: DOUBLE
14995: EQUAL
14996: IFTRUE 15000
14998: GO 15018
15000: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15001: LD_ADDR_VAR 0 3
15005: PUSH
15006: LD_INT 13
15008: PUSH
15009: LD_INT 14
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: ST_TO_ADDR
15016: GO 15387
15018: LD_INT 31
15020: DOUBLE
15021: EQUAL
15022: IFTRUE 15026
15024: GO 15044
15026: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15027: LD_ADDR_VAR 0 3
15031: PUSH
15032: LD_INT 13
15034: PUSH
15035: LD_INT 14
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: ST_TO_ADDR
15042: GO 15387
15044: LD_INT 26
15046: DOUBLE
15047: EQUAL
15048: IFTRUE 15052
15050: GO 15070
15052: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15053: LD_ADDR_VAR 0 3
15057: PUSH
15058: LD_INT 13
15060: PUSH
15061: LD_INT 14
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: ST_TO_ADDR
15068: GO 15387
15070: LD_INT 42
15072: DOUBLE
15073: EQUAL
15074: IFTRUE 15078
15076: GO 15104
15078: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15079: LD_ADDR_VAR 0 3
15083: PUSH
15084: LD_INT 21
15086: PUSH
15087: LD_INT 22
15089: PUSH
15090: LD_INT 23
15092: PUSH
15093: LD_INT 24
15095: PUSH
15096: EMPTY
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: ST_TO_ADDR
15102: GO 15387
15104: LD_INT 43
15106: DOUBLE
15107: EQUAL
15108: IFTRUE 15112
15110: GO 15138
15112: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15113: LD_ADDR_VAR 0 3
15117: PUSH
15118: LD_INT 21
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 23
15126: PUSH
15127: LD_INT 24
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: ST_TO_ADDR
15136: GO 15387
15138: LD_INT 44
15140: DOUBLE
15141: EQUAL
15142: IFTRUE 15146
15144: GO 15172
15146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15147: LD_ADDR_VAR 0 3
15151: PUSH
15152: LD_INT 21
15154: PUSH
15155: LD_INT 22
15157: PUSH
15158: LD_INT 23
15160: PUSH
15161: LD_INT 24
15163: PUSH
15164: EMPTY
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: ST_TO_ADDR
15170: GO 15387
15172: LD_INT 45
15174: DOUBLE
15175: EQUAL
15176: IFTRUE 15180
15178: GO 15206
15180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15181: LD_ADDR_VAR 0 3
15185: PUSH
15186: LD_INT 21
15188: PUSH
15189: LD_INT 22
15191: PUSH
15192: LD_INT 23
15194: PUSH
15195: LD_INT 24
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: ST_TO_ADDR
15204: GO 15387
15206: LD_INT 49
15208: DOUBLE
15209: EQUAL
15210: IFTRUE 15214
15212: GO 15240
15214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15215: LD_ADDR_VAR 0 3
15219: PUSH
15220: LD_INT 21
15222: PUSH
15223: LD_INT 22
15225: PUSH
15226: LD_INT 23
15228: PUSH
15229: LD_INT 24
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: ST_TO_ADDR
15238: GO 15387
15240: LD_INT 51
15242: DOUBLE
15243: EQUAL
15244: IFTRUE 15248
15246: GO 15274
15248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15249: LD_ADDR_VAR 0 3
15253: PUSH
15254: LD_INT 21
15256: PUSH
15257: LD_INT 22
15259: PUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 24
15265: PUSH
15266: EMPTY
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: ST_TO_ADDR
15272: GO 15387
15274: LD_INT 52
15276: DOUBLE
15277: EQUAL
15278: IFTRUE 15282
15280: GO 15308
15282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15283: LD_ADDR_VAR 0 3
15287: PUSH
15288: LD_INT 21
15290: PUSH
15291: LD_INT 22
15293: PUSH
15294: LD_INT 23
15296: PUSH
15297: LD_INT 24
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: ST_TO_ADDR
15306: GO 15387
15308: LD_INT 53
15310: DOUBLE
15311: EQUAL
15312: IFTRUE 15316
15314: GO 15334
15316: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15317: LD_ADDR_VAR 0 3
15321: PUSH
15322: LD_INT 23
15324: PUSH
15325: LD_INT 24
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: ST_TO_ADDR
15332: GO 15387
15334: LD_INT 46
15336: DOUBLE
15337: EQUAL
15338: IFTRUE 15342
15340: GO 15360
15342: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15343: LD_ADDR_VAR 0 3
15347: PUSH
15348: LD_INT 23
15350: PUSH
15351: LD_INT 24
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: ST_TO_ADDR
15358: GO 15387
15360: LD_INT 47
15362: DOUBLE
15363: EQUAL
15364: IFTRUE 15368
15366: GO 15386
15368: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15369: LD_ADDR_VAR 0 3
15373: PUSH
15374: LD_INT 23
15376: PUSH
15377: LD_INT 24
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: ST_TO_ADDR
15384: GO 15387
15386: POP
// result := ( chassis in result ) ;
15387: LD_ADDR_VAR 0 3
15391: PUSH
15392: LD_VAR 0 1
15396: PUSH
15397: LD_VAR 0 3
15401: IN
15402: ST_TO_ADDR
// end ;
15403: LD_VAR 0 3
15407: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15408: LD_INT 0
15410: PPUSH
15411: PPUSH
15412: PPUSH
15413: PPUSH
15414: PPUSH
15415: PPUSH
15416: PPUSH
// result := array ;
15417: LD_ADDR_VAR 0 5
15421: PUSH
15422: LD_VAR 0 1
15426: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15427: LD_VAR 0 1
15431: NOT
15432: PUSH
15433: LD_VAR 0 2
15437: NOT
15438: OR
15439: PUSH
15440: LD_VAR 0 3
15444: NOT
15445: OR
15446: PUSH
15447: LD_VAR 0 2
15451: PUSH
15452: LD_VAR 0 1
15456: GREATER
15457: OR
15458: PUSH
15459: LD_VAR 0 3
15463: PUSH
15464: LD_VAR 0 1
15468: GREATER
15469: OR
15470: IFFALSE 15474
// exit ;
15472: GO 15770
// if direction then
15474: LD_VAR 0 4
15478: IFFALSE 15542
// begin d := 1 ;
15480: LD_ADDR_VAR 0 9
15484: PUSH
15485: LD_INT 1
15487: ST_TO_ADDR
// if i_from > i_to then
15488: LD_VAR 0 2
15492: PUSH
15493: LD_VAR 0 3
15497: GREATER
15498: IFFALSE 15524
// length := ( array - i_from ) + i_to else
15500: LD_ADDR_VAR 0 11
15504: PUSH
15505: LD_VAR 0 1
15509: PUSH
15510: LD_VAR 0 2
15514: MINUS
15515: PUSH
15516: LD_VAR 0 3
15520: PLUS
15521: ST_TO_ADDR
15522: GO 15540
// length := i_to - i_from ;
15524: LD_ADDR_VAR 0 11
15528: PUSH
15529: LD_VAR 0 3
15533: PUSH
15534: LD_VAR 0 2
15538: MINUS
15539: ST_TO_ADDR
// end else
15540: GO 15603
// begin d := - 1 ;
15542: LD_ADDR_VAR 0 9
15546: PUSH
15547: LD_INT 1
15549: NEG
15550: ST_TO_ADDR
// if i_from > i_to then
15551: LD_VAR 0 2
15555: PUSH
15556: LD_VAR 0 3
15560: GREATER
15561: IFFALSE 15581
// length := i_from - i_to else
15563: LD_ADDR_VAR 0 11
15567: PUSH
15568: LD_VAR 0 2
15572: PUSH
15573: LD_VAR 0 3
15577: MINUS
15578: ST_TO_ADDR
15579: GO 15603
// length := ( array - i_to ) + i_from ;
15581: LD_ADDR_VAR 0 11
15585: PUSH
15586: LD_VAR 0 1
15590: PUSH
15591: LD_VAR 0 3
15595: MINUS
15596: PUSH
15597: LD_VAR 0 2
15601: PLUS
15602: ST_TO_ADDR
// end ; if not length then
15603: LD_VAR 0 11
15607: NOT
15608: IFFALSE 15612
// exit ;
15610: GO 15770
// tmp := array ;
15612: LD_ADDR_VAR 0 10
15616: PUSH
15617: LD_VAR 0 1
15621: ST_TO_ADDR
// for i = 1 to length do
15622: LD_ADDR_VAR 0 6
15626: PUSH
15627: DOUBLE
15628: LD_INT 1
15630: DEC
15631: ST_TO_ADDR
15632: LD_VAR 0 11
15636: PUSH
15637: FOR_TO
15638: IFFALSE 15758
// begin for j = 1 to array do
15640: LD_ADDR_VAR 0 7
15644: PUSH
15645: DOUBLE
15646: LD_INT 1
15648: DEC
15649: ST_TO_ADDR
15650: LD_VAR 0 1
15654: PUSH
15655: FOR_TO
15656: IFFALSE 15744
// begin k := j + d ;
15658: LD_ADDR_VAR 0 8
15662: PUSH
15663: LD_VAR 0 7
15667: PUSH
15668: LD_VAR 0 9
15672: PLUS
15673: ST_TO_ADDR
// if k > array then
15674: LD_VAR 0 8
15678: PUSH
15679: LD_VAR 0 1
15683: GREATER
15684: IFFALSE 15694
// k := 1 ;
15686: LD_ADDR_VAR 0 8
15690: PUSH
15691: LD_INT 1
15693: ST_TO_ADDR
// if not k then
15694: LD_VAR 0 8
15698: NOT
15699: IFFALSE 15711
// k := array ;
15701: LD_ADDR_VAR 0 8
15705: PUSH
15706: LD_VAR 0 1
15710: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15711: LD_ADDR_VAR 0 10
15715: PUSH
15716: LD_VAR 0 10
15720: PPUSH
15721: LD_VAR 0 8
15725: PPUSH
15726: LD_VAR 0 1
15730: PUSH
15731: LD_VAR 0 7
15735: ARRAY
15736: PPUSH
15737: CALL_OW 1
15741: ST_TO_ADDR
// end ;
15742: GO 15655
15744: POP
15745: POP
// array := tmp ;
15746: LD_ADDR_VAR 0 1
15750: PUSH
15751: LD_VAR 0 10
15755: ST_TO_ADDR
// end ;
15756: GO 15637
15758: POP
15759: POP
// result := array ;
15760: LD_ADDR_VAR 0 5
15764: PUSH
15765: LD_VAR 0 1
15769: ST_TO_ADDR
// end ;
15770: LD_VAR 0 5
15774: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15775: LD_INT 0
15777: PPUSH
15778: PPUSH
// result := 0 ;
15779: LD_ADDR_VAR 0 3
15783: PUSH
15784: LD_INT 0
15786: ST_TO_ADDR
// if not array or not value in array then
15787: LD_VAR 0 1
15791: NOT
15792: PUSH
15793: LD_VAR 0 2
15797: PUSH
15798: LD_VAR 0 1
15802: IN
15803: NOT
15804: OR
15805: IFFALSE 15809
// exit ;
15807: GO 15863
// for i = 1 to array do
15809: LD_ADDR_VAR 0 4
15813: PUSH
15814: DOUBLE
15815: LD_INT 1
15817: DEC
15818: ST_TO_ADDR
15819: LD_VAR 0 1
15823: PUSH
15824: FOR_TO
15825: IFFALSE 15861
// if value = array [ i ] then
15827: LD_VAR 0 2
15831: PUSH
15832: LD_VAR 0 1
15836: PUSH
15837: LD_VAR 0 4
15841: ARRAY
15842: EQUAL
15843: IFFALSE 15859
// begin result := i ;
15845: LD_ADDR_VAR 0 3
15849: PUSH
15850: LD_VAR 0 4
15854: ST_TO_ADDR
// exit ;
15855: POP
15856: POP
15857: GO 15863
// end ;
15859: GO 15824
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15868: LD_INT 0
15870: PPUSH
// vc_chassis := chassis ;
15871: LD_ADDR_OWVAR 37
15875: PUSH
15876: LD_VAR 0 1
15880: ST_TO_ADDR
// vc_engine := engine ;
15881: LD_ADDR_OWVAR 39
15885: PUSH
15886: LD_VAR 0 2
15890: ST_TO_ADDR
// vc_control := control ;
15891: LD_ADDR_OWVAR 38
15895: PUSH
15896: LD_VAR 0 3
15900: ST_TO_ADDR
// vc_weapon := weapon ;
15901: LD_ADDR_OWVAR 40
15905: PUSH
15906: LD_VAR 0 4
15910: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15911: LD_ADDR_OWVAR 41
15915: PUSH
15916: LD_VAR 0 5
15920: ST_TO_ADDR
// end ;
15921: LD_VAR 0 6
15925: RET
// export function WantPlant ( unit ) ; var task ; begin
15926: LD_INT 0
15928: PPUSH
15929: PPUSH
// result := false ;
15930: LD_ADDR_VAR 0 2
15934: PUSH
15935: LD_INT 0
15937: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
15938: LD_ADDR_VAR 0 3
15942: PUSH
15943: LD_VAR 0 1
15947: PPUSH
15948: CALL_OW 437
15952: ST_TO_ADDR
// if task then
15953: LD_VAR 0 3
15957: IFFALSE 15985
// if task [ 1 ] [ 1 ] = p then
15959: LD_VAR 0 3
15963: PUSH
15964: LD_INT 1
15966: ARRAY
15967: PUSH
15968: LD_INT 1
15970: ARRAY
15971: PUSH
15972: LD_STRING p
15974: EQUAL
15975: IFFALSE 15985
// result := true ;
15977: LD_ADDR_VAR 0 2
15981: PUSH
15982: LD_INT 1
15984: ST_TO_ADDR
// end ;
15985: LD_VAR 0 2
15989: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
15990: LD_INT 0
15992: PPUSH
15993: PPUSH
15994: PPUSH
15995: PPUSH
// if pos < 1 then
15996: LD_VAR 0 2
16000: PUSH
16001: LD_INT 1
16003: LESS
16004: IFFALSE 16008
// exit ;
16006: GO 16311
// if pos = 1 then
16008: LD_VAR 0 2
16012: PUSH
16013: LD_INT 1
16015: EQUAL
16016: IFFALSE 16049
// result := Replace ( arr , pos [ 1 ] , value ) else
16018: LD_ADDR_VAR 0 4
16022: PUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 2
16032: PUSH
16033: LD_INT 1
16035: ARRAY
16036: PPUSH
16037: LD_VAR 0 3
16041: PPUSH
16042: CALL_OW 1
16046: ST_TO_ADDR
16047: GO 16311
// begin tmp := arr ;
16049: LD_ADDR_VAR 0 6
16053: PUSH
16054: LD_VAR 0 1
16058: ST_TO_ADDR
// s_arr := [ tmp ] ;
16059: LD_ADDR_VAR 0 7
16063: PUSH
16064: LD_VAR 0 6
16068: PUSH
16069: EMPTY
16070: LIST
16071: ST_TO_ADDR
// for i = 1 to pos - 1 do
16072: LD_ADDR_VAR 0 5
16076: PUSH
16077: DOUBLE
16078: LD_INT 1
16080: DEC
16081: ST_TO_ADDR
16082: LD_VAR 0 2
16086: PUSH
16087: LD_INT 1
16089: MINUS
16090: PUSH
16091: FOR_TO
16092: IFFALSE 16137
// begin tmp := tmp [ pos [ i ] ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_VAR 0 6
16103: PUSH
16104: LD_VAR 0 2
16108: PUSH
16109: LD_VAR 0 5
16113: ARRAY
16114: ARRAY
16115: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16116: LD_ADDR_VAR 0 7
16120: PUSH
16121: LD_VAR 0 7
16125: PUSH
16126: LD_VAR 0 6
16130: PUSH
16131: EMPTY
16132: LIST
16133: ADD
16134: ST_TO_ADDR
// end ;
16135: GO 16091
16137: POP
16138: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16139: LD_ADDR_VAR 0 6
16143: PUSH
16144: LD_VAR 0 6
16148: PPUSH
16149: LD_VAR 0 2
16153: PUSH
16154: LD_VAR 0 2
16158: ARRAY
16159: PPUSH
16160: LD_VAR 0 3
16164: PPUSH
16165: CALL_OW 1
16169: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16170: LD_ADDR_VAR 0 7
16174: PUSH
16175: LD_VAR 0 7
16179: PPUSH
16180: LD_VAR 0 7
16184: PPUSH
16185: LD_VAR 0 6
16189: PPUSH
16190: CALL_OW 1
16194: ST_TO_ADDR
// for i = s_arr downto 2 do
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: DOUBLE
16201: LD_VAR 0 7
16205: INC
16206: ST_TO_ADDR
16207: LD_INT 2
16209: PUSH
16210: FOR_DOWNTO
16211: IFFALSE 16295
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16213: LD_ADDR_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: PUSH
16223: LD_VAR 0 5
16227: PUSH
16228: LD_INT 1
16230: MINUS
16231: ARRAY
16232: PPUSH
16233: LD_VAR 0 2
16237: PUSH
16238: LD_VAR 0 5
16242: PUSH
16243: LD_INT 1
16245: MINUS
16246: ARRAY
16247: PPUSH
16248: LD_VAR 0 7
16252: PUSH
16253: LD_VAR 0 5
16257: ARRAY
16258: PPUSH
16259: CALL_OW 1
16263: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16264: LD_ADDR_VAR 0 7
16268: PUSH
16269: LD_VAR 0 7
16273: PPUSH
16274: LD_VAR 0 5
16278: PUSH
16279: LD_INT 1
16281: MINUS
16282: PPUSH
16283: LD_VAR 0 6
16287: PPUSH
16288: CALL_OW 1
16292: ST_TO_ADDR
// end ;
16293: GO 16210
16295: POP
16296: POP
// result := s_arr [ 1 ] ;
16297: LD_ADDR_VAR 0 4
16301: PUSH
16302: LD_VAR 0 7
16306: PUSH
16307: LD_INT 1
16309: ARRAY
16310: ST_TO_ADDR
// end ; end ;
16311: LD_VAR 0 4
16315: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16316: LD_INT 0
16318: PPUSH
16319: PPUSH
// if not list then
16320: LD_VAR 0 1
16324: NOT
16325: IFFALSE 16329
// exit ;
16327: GO 16420
// i := list [ pos1 ] ;
16329: LD_ADDR_VAR 0 5
16333: PUSH
16334: LD_VAR 0 1
16338: PUSH
16339: LD_VAR 0 2
16343: ARRAY
16344: ST_TO_ADDR
// if not i then
16345: LD_VAR 0 5
16349: NOT
16350: IFFALSE 16354
// exit ;
16352: GO 16420
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16354: LD_ADDR_VAR 0 1
16358: PUSH
16359: LD_VAR 0 1
16363: PPUSH
16364: LD_VAR 0 2
16368: PPUSH
16369: LD_VAR 0 1
16373: PUSH
16374: LD_VAR 0 3
16378: ARRAY
16379: PPUSH
16380: CALL_OW 1
16384: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16385: LD_ADDR_VAR 0 1
16389: PUSH
16390: LD_VAR 0 1
16394: PPUSH
16395: LD_VAR 0 3
16399: PPUSH
16400: LD_VAR 0 5
16404: PPUSH
16405: CALL_OW 1
16409: ST_TO_ADDR
// result := list ;
16410: LD_ADDR_VAR 0 4
16414: PUSH
16415: LD_VAR 0 1
16419: ST_TO_ADDR
// end ;
16420: LD_VAR 0 4
16424: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16425: LD_INT 0
16427: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16428: LD_ADDR_VAR 0 5
16432: PUSH
16433: LD_VAR 0 1
16437: PPUSH
16438: CALL_OW 250
16442: PPUSH
16443: LD_VAR 0 1
16447: PPUSH
16448: CALL_OW 251
16452: PPUSH
16453: LD_VAR 0 2
16457: PPUSH
16458: LD_VAR 0 3
16462: PPUSH
16463: LD_VAR 0 4
16467: PPUSH
16468: CALL 16478 0 5
16472: ST_TO_ADDR
// end ;
16473: LD_VAR 0 5
16477: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16478: LD_INT 0
16480: PPUSH
16481: PPUSH
16482: PPUSH
16483: PPUSH
// if not list then
16484: LD_VAR 0 3
16488: NOT
16489: IFFALSE 16493
// exit ;
16491: GO 16881
// result := [ ] ;
16493: LD_ADDR_VAR 0 6
16497: PUSH
16498: EMPTY
16499: ST_TO_ADDR
// for i in list do
16500: LD_ADDR_VAR 0 7
16504: PUSH
16505: LD_VAR 0 3
16509: PUSH
16510: FOR_IN
16511: IFFALSE 16713
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16513: LD_ADDR_VAR 0 9
16517: PUSH
16518: LD_VAR 0 7
16522: PPUSH
16523: LD_VAR 0 1
16527: PPUSH
16528: LD_VAR 0 2
16532: PPUSH
16533: CALL_OW 297
16537: ST_TO_ADDR
// if not result then
16538: LD_VAR 0 6
16542: NOT
16543: IFFALSE 16569
// result := [ [ i , tmp ] ] else
16545: LD_ADDR_VAR 0 6
16549: PUSH
16550: LD_VAR 0 7
16554: PUSH
16555: LD_VAR 0 9
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: PUSH
16564: EMPTY
16565: LIST
16566: ST_TO_ADDR
16567: GO 16711
// begin if result [ result ] [ 2 ] < tmp then
16569: LD_VAR 0 6
16573: PUSH
16574: LD_VAR 0 6
16578: ARRAY
16579: PUSH
16580: LD_INT 2
16582: ARRAY
16583: PUSH
16584: LD_VAR 0 9
16588: LESS
16589: IFFALSE 16631
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16591: LD_ADDR_VAR 0 6
16595: PUSH
16596: LD_VAR 0 6
16600: PPUSH
16601: LD_VAR 0 6
16605: PUSH
16606: LD_INT 1
16608: PLUS
16609: PPUSH
16610: LD_VAR 0 7
16614: PUSH
16615: LD_VAR 0 9
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 2
16628: ST_TO_ADDR
16629: GO 16711
// for j = 1 to result do
16631: LD_ADDR_VAR 0 8
16635: PUSH
16636: DOUBLE
16637: LD_INT 1
16639: DEC
16640: ST_TO_ADDR
16641: LD_VAR 0 6
16645: PUSH
16646: FOR_TO
16647: IFFALSE 16709
// begin if tmp < result [ j ] [ 2 ] then
16649: LD_VAR 0 9
16653: PUSH
16654: LD_VAR 0 6
16658: PUSH
16659: LD_VAR 0 8
16663: ARRAY
16664: PUSH
16665: LD_INT 2
16667: ARRAY
16668: LESS
16669: IFFALSE 16707
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16671: LD_ADDR_VAR 0 6
16675: PUSH
16676: LD_VAR 0 6
16680: PPUSH
16681: LD_VAR 0 8
16685: PPUSH
16686: LD_VAR 0 7
16690: PUSH
16691: LD_VAR 0 9
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PPUSH
16700: CALL_OW 2
16704: ST_TO_ADDR
// break ;
16705: GO 16709
// end ; end ;
16707: GO 16646
16709: POP
16710: POP
// end ; end ;
16711: GO 16510
16713: POP
16714: POP
// if result and not asc then
16715: LD_VAR 0 6
16719: PUSH
16720: LD_VAR 0 4
16724: NOT
16725: AND
16726: IFFALSE 16801
// begin tmp := result ;
16728: LD_ADDR_VAR 0 9
16732: PUSH
16733: LD_VAR 0 6
16737: ST_TO_ADDR
// for i = tmp downto 1 do
16738: LD_ADDR_VAR 0 7
16742: PUSH
16743: DOUBLE
16744: LD_VAR 0 9
16748: INC
16749: ST_TO_ADDR
16750: LD_INT 1
16752: PUSH
16753: FOR_DOWNTO
16754: IFFALSE 16799
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16756: LD_ADDR_VAR 0 6
16760: PUSH
16761: LD_VAR 0 6
16765: PPUSH
16766: LD_VAR 0 9
16770: PUSH
16771: LD_VAR 0 7
16775: MINUS
16776: PUSH
16777: LD_INT 1
16779: PLUS
16780: PPUSH
16781: LD_VAR 0 9
16785: PUSH
16786: LD_VAR 0 7
16790: ARRAY
16791: PPUSH
16792: CALL_OW 1
16796: ST_TO_ADDR
16797: GO 16753
16799: POP
16800: POP
// end ; tmp := [ ] ;
16801: LD_ADDR_VAR 0 9
16805: PUSH
16806: EMPTY
16807: ST_TO_ADDR
// if mode then
16808: LD_VAR 0 5
16812: IFFALSE 16881
// begin for i = 1 to result do
16814: LD_ADDR_VAR 0 7
16818: PUSH
16819: DOUBLE
16820: LD_INT 1
16822: DEC
16823: ST_TO_ADDR
16824: LD_VAR 0 6
16828: PUSH
16829: FOR_TO
16830: IFFALSE 16869
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16832: LD_ADDR_VAR 0 9
16836: PUSH
16837: LD_VAR 0 9
16841: PPUSH
16842: LD_VAR 0 7
16846: PPUSH
16847: LD_VAR 0 6
16851: PUSH
16852: LD_VAR 0 7
16856: ARRAY
16857: PUSH
16858: LD_INT 1
16860: ARRAY
16861: PPUSH
16862: CALL_OW 1
16866: ST_TO_ADDR
16867: GO 16829
16869: POP
16870: POP
// result := tmp ;
16871: LD_ADDR_VAR 0 6
16875: PUSH
16876: LD_VAR 0 9
16880: ST_TO_ADDR
// end ; end ;
16881: LD_VAR 0 6
16885: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
16886: LD_INT 0
16888: PPUSH
16889: PPUSH
16890: PPUSH
16891: PPUSH
16892: PPUSH
16893: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
16894: LD_ADDR_VAR 0 5
16898: PUSH
16899: LD_INT 0
16901: PUSH
16902: LD_INT 0
16904: PUSH
16905: LD_INT 0
16907: PUSH
16908: EMPTY
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: ST_TO_ADDR
// if not x or not y then
16916: LD_VAR 0 2
16920: NOT
16921: PUSH
16922: LD_VAR 0 3
16926: NOT
16927: OR
16928: IFFALSE 16932
// exit ;
16930: GO 18584
// if not range then
16932: LD_VAR 0 4
16936: NOT
16937: IFFALSE 16947
// range := 10 ;
16939: LD_ADDR_VAR 0 4
16943: PUSH
16944: LD_INT 10
16946: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16947: LD_ADDR_VAR 0 8
16951: PUSH
16952: LD_INT 81
16954: PUSH
16955: LD_VAR 0 1
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PUSH
16964: LD_INT 92
16966: PUSH
16967: LD_VAR 0 2
16971: PUSH
16972: LD_VAR 0 3
16976: PUSH
16977: LD_VAR 0 4
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 3
16990: PUSH
16991: LD_INT 21
16993: PUSH
16994: LD_INT 3
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: PPUSH
17010: CALL_OW 69
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 8
17019: NOT
17020: IFFALSE 17024
// exit ;
17022: GO 18584
// for i in tmp do
17024: LD_ADDR_VAR 0 6
17028: PUSH
17029: LD_VAR 0 8
17033: PUSH
17034: FOR_IN
17035: IFFALSE 18559
// begin points := [ 0 , 0 , 0 ] ;
17037: LD_ADDR_VAR 0 9
17041: PUSH
17042: LD_INT 0
17044: PUSH
17045: LD_INT 0
17047: PUSH
17048: LD_INT 0
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: LIST
17055: ST_TO_ADDR
// bpoints := 1 ;
17056: LD_ADDR_VAR 0 10
17060: PUSH
17061: LD_INT 1
17063: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17064: LD_VAR 0 6
17068: PPUSH
17069: CALL_OW 247
17073: PUSH
17074: LD_INT 1
17076: DOUBLE
17077: EQUAL
17078: IFTRUE 17082
17080: GO 17660
17082: POP
// begin if GetClass ( i ) = 1 then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 257
17092: PUSH
17093: LD_INT 1
17095: EQUAL
17096: IFFALSE 17117
// points := [ 10 , 5 , 3 ] ;
17098: LD_ADDR_VAR 0 9
17102: PUSH
17103: LD_INT 10
17105: PUSH
17106: LD_INT 5
17108: PUSH
17109: LD_INT 3
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17117: LD_VAR 0 6
17121: PPUSH
17122: CALL_OW 257
17126: PUSH
17127: LD_INT 2
17129: PUSH
17130: LD_INT 3
17132: PUSH
17133: LD_INT 4
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: LIST
17140: IN
17141: IFFALSE 17162
// points := [ 3 , 2 , 1 ] ;
17143: LD_ADDR_VAR 0 9
17147: PUSH
17148: LD_INT 3
17150: PUSH
17151: LD_INT 2
17153: PUSH
17154: LD_INT 1
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17162: LD_VAR 0 6
17166: PPUSH
17167: CALL_OW 257
17171: PUSH
17172: LD_INT 5
17174: EQUAL
17175: IFFALSE 17196
// points := [ 130 , 5 , 2 ] ;
17177: LD_ADDR_VAR 0 9
17181: PUSH
17182: LD_INT 130
17184: PUSH
17185: LD_INT 5
17187: PUSH
17188: LD_INT 2
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: LIST
17195: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17196: LD_VAR 0 6
17200: PPUSH
17201: CALL_OW 257
17205: PUSH
17206: LD_INT 8
17208: EQUAL
17209: IFFALSE 17230
// points := [ 35 , 35 , 30 ] ;
17211: LD_ADDR_VAR 0 9
17215: PUSH
17216: LD_INT 35
17218: PUSH
17219: LD_INT 35
17221: PUSH
17222: LD_INT 30
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17230: LD_VAR 0 6
17234: PPUSH
17235: CALL_OW 257
17239: PUSH
17240: LD_INT 9
17242: EQUAL
17243: IFFALSE 17264
// points := [ 20 , 55 , 40 ] ;
17245: LD_ADDR_VAR 0 9
17249: PUSH
17250: LD_INT 20
17252: PUSH
17253: LD_INT 55
17255: PUSH
17256: LD_INT 40
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: LIST
17263: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17264: LD_VAR 0 6
17268: PPUSH
17269: CALL_OW 257
17273: PUSH
17274: LD_INT 12
17276: PUSH
17277: LD_INT 16
17279: PUSH
17280: EMPTY
17281: LIST
17282: LIST
17283: IN
17284: IFFALSE 17305
// points := [ 5 , 3 , 2 ] ;
17286: LD_ADDR_VAR 0 9
17290: PUSH
17291: LD_INT 5
17293: PUSH
17294: LD_INT 3
17296: PUSH
17297: LD_INT 2
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: LIST
17304: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17305: LD_VAR 0 6
17309: PPUSH
17310: CALL_OW 257
17314: PUSH
17315: LD_INT 17
17317: EQUAL
17318: IFFALSE 17339
// points := [ 100 , 50 , 75 ] ;
17320: LD_ADDR_VAR 0 9
17324: PUSH
17325: LD_INT 100
17327: PUSH
17328: LD_INT 50
17330: PUSH
17331: LD_INT 75
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: LIST
17338: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17339: LD_VAR 0 6
17343: PPUSH
17344: CALL_OW 257
17348: PUSH
17349: LD_INT 15
17351: EQUAL
17352: IFFALSE 17373
// points := [ 10 , 5 , 3 ] ;
17354: LD_ADDR_VAR 0 9
17358: PUSH
17359: LD_INT 10
17361: PUSH
17362: LD_INT 5
17364: PUSH
17365: LD_INT 3
17367: PUSH
17368: EMPTY
17369: LIST
17370: LIST
17371: LIST
17372: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17373: LD_VAR 0 6
17377: PPUSH
17378: CALL_OW 257
17382: PUSH
17383: LD_INT 14
17385: EQUAL
17386: IFFALSE 17407
// points := [ 10 , 0 , 0 ] ;
17388: LD_ADDR_VAR 0 9
17392: PUSH
17393: LD_INT 10
17395: PUSH
17396: LD_INT 0
17398: PUSH
17399: LD_INT 0
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: LIST
17406: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17407: LD_VAR 0 6
17411: PPUSH
17412: CALL_OW 257
17416: PUSH
17417: LD_INT 11
17419: EQUAL
17420: IFFALSE 17441
// points := [ 30 , 10 , 5 ] ;
17422: LD_ADDR_VAR 0 9
17426: PUSH
17427: LD_INT 30
17429: PUSH
17430: LD_INT 10
17432: PUSH
17433: LD_INT 5
17435: PUSH
17436: EMPTY
17437: LIST
17438: LIST
17439: LIST
17440: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17441: LD_VAR 0 1
17445: PPUSH
17446: LD_INT 5
17448: PPUSH
17449: CALL_OW 321
17453: PUSH
17454: LD_INT 2
17456: EQUAL
17457: IFFALSE 17474
// bpoints := bpoints * 1.8 ;
17459: LD_ADDR_VAR 0 10
17463: PUSH
17464: LD_VAR 0 10
17468: PUSH
17469: LD_REAL  1.80000000000000E+0000
17472: MUL
17473: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17474: LD_VAR 0 6
17478: PPUSH
17479: CALL_OW 257
17483: PUSH
17484: LD_INT 1
17486: PUSH
17487: LD_INT 2
17489: PUSH
17490: LD_INT 3
17492: PUSH
17493: LD_INT 4
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: IN
17502: PUSH
17503: LD_VAR 0 1
17507: PPUSH
17508: LD_INT 51
17510: PPUSH
17511: CALL_OW 321
17515: PUSH
17516: LD_INT 2
17518: EQUAL
17519: AND
17520: IFFALSE 17537
// bpoints := bpoints * 1.2 ;
17522: LD_ADDR_VAR 0 10
17526: PUSH
17527: LD_VAR 0 10
17531: PUSH
17532: LD_REAL  1.20000000000000E+0000
17535: MUL
17536: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17537: LD_VAR 0 6
17541: PPUSH
17542: CALL_OW 257
17546: PUSH
17547: LD_INT 5
17549: PUSH
17550: LD_INT 7
17552: PUSH
17553: LD_INT 9
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: IN
17561: PUSH
17562: LD_VAR 0 1
17566: PPUSH
17567: LD_INT 52
17569: PPUSH
17570: CALL_OW 321
17574: PUSH
17575: LD_INT 2
17577: EQUAL
17578: AND
17579: IFFALSE 17596
// bpoints := bpoints * 1.5 ;
17581: LD_ADDR_VAR 0 10
17585: PUSH
17586: LD_VAR 0 10
17590: PUSH
17591: LD_REAL  1.50000000000000E+0000
17594: MUL
17595: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17596: LD_VAR 0 1
17600: PPUSH
17601: LD_INT 66
17603: PPUSH
17604: CALL_OW 321
17608: PUSH
17609: LD_INT 2
17611: EQUAL
17612: IFFALSE 17629
// bpoints := bpoints * 1.1 ;
17614: LD_ADDR_VAR 0 10
17618: PUSH
17619: LD_VAR 0 10
17623: PUSH
17624: LD_REAL  1.10000000000000E+0000
17627: MUL
17628: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17629: LD_ADDR_VAR 0 10
17633: PUSH
17634: LD_VAR 0 10
17638: PUSH
17639: LD_VAR 0 6
17643: PPUSH
17644: LD_INT 1
17646: PPUSH
17647: CALL_OW 259
17651: PUSH
17652: LD_REAL  1.15000000000000E+0000
17655: MUL
17656: MUL
17657: ST_TO_ADDR
// end ; unit_vehicle :
17658: GO 18488
17660: LD_INT 2
17662: DOUBLE
17663: EQUAL
17664: IFTRUE 17668
17666: GO 18476
17668: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17669: LD_VAR 0 6
17673: PPUSH
17674: CALL_OW 264
17678: PUSH
17679: LD_INT 2
17681: PUSH
17682: LD_INT 42
17684: PUSH
17685: LD_INT 24
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: IN
17693: IFFALSE 17714
// points := [ 25 , 5 , 3 ] ;
17695: LD_ADDR_VAR 0 9
17699: PUSH
17700: LD_INT 25
17702: PUSH
17703: LD_INT 5
17705: PUSH
17706: LD_INT 3
17708: PUSH
17709: EMPTY
17710: LIST
17711: LIST
17712: LIST
17713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17714: LD_VAR 0 6
17718: PPUSH
17719: CALL_OW 264
17723: PUSH
17724: LD_INT 4
17726: PUSH
17727: LD_INT 43
17729: PUSH
17730: LD_INT 25
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: IN
17738: IFFALSE 17759
// points := [ 40 , 15 , 5 ] ;
17740: LD_ADDR_VAR 0 9
17744: PUSH
17745: LD_INT 40
17747: PUSH
17748: LD_INT 15
17750: PUSH
17751: LD_INT 5
17753: PUSH
17754: EMPTY
17755: LIST
17756: LIST
17757: LIST
17758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17759: LD_VAR 0 6
17763: PPUSH
17764: CALL_OW 264
17768: PUSH
17769: LD_INT 3
17771: PUSH
17772: LD_INT 23
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: IN
17779: IFFALSE 17800
// points := [ 7 , 25 , 8 ] ;
17781: LD_ADDR_VAR 0 9
17785: PUSH
17786: LD_INT 7
17788: PUSH
17789: LD_INT 25
17791: PUSH
17792: LD_INT 8
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: LIST
17799: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17800: LD_VAR 0 6
17804: PPUSH
17805: CALL_OW 264
17809: PUSH
17810: LD_INT 5
17812: PUSH
17813: LD_INT 27
17815: PUSH
17816: LD_INT 44
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: IN
17824: IFFALSE 17845
// points := [ 14 , 50 , 16 ] ;
17826: LD_ADDR_VAR 0 9
17830: PUSH
17831: LD_INT 14
17833: PUSH
17834: LD_INT 50
17836: PUSH
17837: LD_INT 16
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17845: LD_VAR 0 6
17849: PPUSH
17850: CALL_OW 264
17854: PUSH
17855: LD_INT 6
17857: PUSH
17858: LD_INT 46
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: IN
17865: IFFALSE 17886
// points := [ 32 , 120 , 70 ] ;
17867: LD_ADDR_VAR 0 9
17871: PUSH
17872: LD_INT 32
17874: PUSH
17875: LD_INT 120
17877: PUSH
17878: LD_INT 70
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: LIST
17885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
17886: LD_VAR 0 6
17890: PPUSH
17891: CALL_OW 264
17895: PUSH
17896: LD_INT 7
17898: PUSH
17899: LD_INT 28
17901: PUSH
17902: LD_INT 45
17904: PUSH
17905: LD_EXP 72
17909: PUSH
17910: EMPTY
17911: LIST
17912: LIST
17913: LIST
17914: LIST
17915: IN
17916: IFFALSE 17937
// points := [ 35 , 20 , 45 ] ;
17918: LD_ADDR_VAR 0 9
17922: PUSH
17923: LD_INT 35
17925: PUSH
17926: LD_INT 20
17928: PUSH
17929: LD_INT 45
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
17937: LD_VAR 0 6
17941: PPUSH
17942: CALL_OW 264
17946: PUSH
17947: LD_INT 47
17949: PUSH
17950: EMPTY
17951: LIST
17952: IN
17953: IFFALSE 17974
// points := [ 67 , 45 , 75 ] ;
17955: LD_ADDR_VAR 0 9
17959: PUSH
17960: LD_INT 67
17962: PUSH
17963: LD_INT 45
17965: PUSH
17966: LD_INT 75
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
17974: LD_VAR 0 6
17978: PPUSH
17979: CALL_OW 264
17983: PUSH
17984: LD_INT 26
17986: PUSH
17987: EMPTY
17988: LIST
17989: IN
17990: IFFALSE 18011
// points := [ 120 , 30 , 80 ] ;
17992: LD_ADDR_VAR 0 9
17996: PUSH
17997: LD_INT 120
17999: PUSH
18000: LD_INT 30
18002: PUSH
18003: LD_INT 80
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: LIST
18010: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18011: LD_VAR 0 6
18015: PPUSH
18016: CALL_OW 264
18020: PUSH
18021: LD_INT 22
18023: PUSH
18024: EMPTY
18025: LIST
18026: IN
18027: IFFALSE 18048
// points := [ 40 , 1 , 1 ] ;
18029: LD_ADDR_VAR 0 9
18033: PUSH
18034: LD_INT 40
18036: PUSH
18037: LD_INT 1
18039: PUSH
18040: LD_INT 1
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18048: LD_VAR 0 6
18052: PPUSH
18053: CALL_OW 264
18057: PUSH
18058: LD_INT 29
18060: PUSH
18061: EMPTY
18062: LIST
18063: IN
18064: IFFALSE 18085
// points := [ 70 , 200 , 400 ] ;
18066: LD_ADDR_VAR 0 9
18070: PUSH
18071: LD_INT 70
18073: PUSH
18074: LD_INT 200
18076: PUSH
18077: LD_INT 400
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: LIST
18084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18085: LD_VAR 0 6
18089: PPUSH
18090: CALL_OW 264
18094: PUSH
18095: LD_INT 14
18097: PUSH
18098: LD_INT 53
18100: PUSH
18101: EMPTY
18102: LIST
18103: LIST
18104: IN
18105: IFFALSE 18126
// points := [ 40 , 10 , 20 ] ;
18107: LD_ADDR_VAR 0 9
18111: PUSH
18112: LD_INT 40
18114: PUSH
18115: LD_INT 10
18117: PUSH
18118: LD_INT 20
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: LIST
18125: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18126: LD_VAR 0 6
18130: PPUSH
18131: CALL_OW 264
18135: PUSH
18136: LD_INT 9
18138: PUSH
18139: EMPTY
18140: LIST
18141: IN
18142: IFFALSE 18163
// points := [ 5 , 70 , 20 ] ;
18144: LD_ADDR_VAR 0 9
18148: PUSH
18149: LD_INT 5
18151: PUSH
18152: LD_INT 70
18154: PUSH
18155: LD_INT 20
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18163: LD_VAR 0 6
18167: PPUSH
18168: CALL_OW 264
18172: PUSH
18173: LD_INT 10
18175: PUSH
18176: EMPTY
18177: LIST
18178: IN
18179: IFFALSE 18200
// points := [ 35 , 110 , 70 ] ;
18181: LD_ADDR_VAR 0 9
18185: PUSH
18186: LD_INT 35
18188: PUSH
18189: LD_INT 110
18191: PUSH
18192: LD_INT 70
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: LIST
18199: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18200: LD_VAR 0 6
18204: PPUSH
18205: CALL_OW 265
18209: PUSH
18210: LD_INT 25
18212: EQUAL
18213: IFFALSE 18234
// points := [ 80 , 65 , 100 ] ;
18215: LD_ADDR_VAR 0 9
18219: PUSH
18220: LD_INT 80
18222: PUSH
18223: LD_INT 65
18225: PUSH
18226: LD_INT 100
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: LIST
18233: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18234: LD_VAR 0 6
18238: PPUSH
18239: CALL_OW 263
18243: PUSH
18244: LD_INT 1
18246: EQUAL
18247: IFFALSE 18282
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18249: LD_ADDR_VAR 0 10
18253: PUSH
18254: LD_VAR 0 10
18258: PUSH
18259: LD_VAR 0 6
18263: PPUSH
18264: CALL_OW 311
18268: PPUSH
18269: LD_INT 3
18271: PPUSH
18272: CALL_OW 259
18276: PUSH
18277: LD_INT 4
18279: MUL
18280: MUL
18281: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18282: LD_VAR 0 6
18286: PPUSH
18287: CALL_OW 263
18291: PUSH
18292: LD_INT 2
18294: EQUAL
18295: IFFALSE 18346
// begin j := IsControledBy ( i ) ;
18297: LD_ADDR_VAR 0 7
18301: PUSH
18302: LD_VAR 0 6
18306: PPUSH
18307: CALL_OW 312
18311: ST_TO_ADDR
// if j then
18312: LD_VAR 0 7
18316: IFFALSE 18346
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18318: LD_ADDR_VAR 0 10
18322: PUSH
18323: LD_VAR 0 10
18327: PUSH
18328: LD_VAR 0 7
18332: PPUSH
18333: LD_INT 3
18335: PPUSH
18336: CALL_OW 259
18340: PUSH
18341: LD_INT 3
18343: MUL
18344: MUL
18345: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18346: LD_VAR 0 6
18350: PPUSH
18351: CALL_OW 264
18355: PUSH
18356: LD_INT 5
18358: PUSH
18359: LD_INT 6
18361: PUSH
18362: LD_INT 46
18364: PUSH
18365: LD_INT 44
18367: PUSH
18368: LD_INT 47
18370: PUSH
18371: LD_INT 45
18373: PUSH
18374: LD_INT 28
18376: PUSH
18377: LD_INT 7
18379: PUSH
18380: LD_INT 27
18382: PUSH
18383: LD_INT 29
18385: PUSH
18386: EMPTY
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: IN
18398: PUSH
18399: LD_VAR 0 1
18403: PPUSH
18404: LD_INT 52
18406: PPUSH
18407: CALL_OW 321
18411: PUSH
18412: LD_INT 2
18414: EQUAL
18415: AND
18416: IFFALSE 18433
// bpoints := bpoints * 1.2 ;
18418: LD_ADDR_VAR 0 10
18422: PUSH
18423: LD_VAR 0 10
18427: PUSH
18428: LD_REAL  1.20000000000000E+0000
18431: MUL
18432: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18433: LD_VAR 0 6
18437: PPUSH
18438: CALL_OW 264
18442: PUSH
18443: LD_INT 6
18445: PUSH
18446: LD_INT 46
18448: PUSH
18449: LD_INT 47
18451: PUSH
18452: EMPTY
18453: LIST
18454: LIST
18455: LIST
18456: IN
18457: IFFALSE 18474
// bpoints := bpoints * 1.2 ;
18459: LD_ADDR_VAR 0 10
18463: PUSH
18464: LD_VAR 0 10
18468: PUSH
18469: LD_REAL  1.20000000000000E+0000
18472: MUL
18473: ST_TO_ADDR
// end ; unit_building :
18474: GO 18488
18476: LD_INT 3
18478: DOUBLE
18479: EQUAL
18480: IFTRUE 18484
18482: GO 18487
18484: POP
// ; end ;
18485: GO 18488
18487: POP
// for j = 1 to 3 do
18488: LD_ADDR_VAR 0 7
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_INT 3
18500: PUSH
18501: FOR_TO
18502: IFFALSE 18555
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18504: LD_ADDR_VAR 0 5
18508: PUSH
18509: LD_VAR 0 5
18513: PPUSH
18514: LD_VAR 0 7
18518: PPUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_VAR 0 7
18528: ARRAY
18529: PUSH
18530: LD_VAR 0 9
18534: PUSH
18535: LD_VAR 0 7
18539: ARRAY
18540: PUSH
18541: LD_VAR 0 10
18545: MUL
18546: PLUS
18547: PPUSH
18548: CALL_OW 1
18552: ST_TO_ADDR
18553: GO 18501
18555: POP
18556: POP
// end ;
18557: GO 17034
18559: POP
18560: POP
// result := Replace ( result , 4 , tmp ) ;
18561: LD_ADDR_VAR 0 5
18565: PUSH
18566: LD_VAR 0 5
18570: PPUSH
18571: LD_INT 4
18573: PPUSH
18574: LD_VAR 0 8
18578: PPUSH
18579: CALL_OW 1
18583: ST_TO_ADDR
// end ;
18584: LD_VAR 0 5
18588: RET
// export function DangerAtRange ( unit , range ) ; begin
18589: LD_INT 0
18591: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18592: LD_ADDR_VAR 0 3
18596: PUSH
18597: LD_VAR 0 1
18601: PPUSH
18602: CALL_OW 255
18606: PPUSH
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL_OW 250
18616: PPUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL_OW 251
18626: PPUSH
18627: LD_VAR 0 2
18631: PPUSH
18632: CALL 16886 0 4
18636: ST_TO_ADDR
// end ;
18637: LD_VAR 0 3
18641: RET
// export function DangerInArea ( side , area ) ; begin
18642: LD_INT 0
18644: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18645: LD_ADDR_VAR 0 3
18649: PUSH
18650: LD_VAR 0 2
18654: PPUSH
18655: LD_INT 81
18657: PUSH
18658: LD_VAR 0 1
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PPUSH
18667: CALL_OW 70
18671: ST_TO_ADDR
// end ;
18672: LD_VAR 0 3
18676: RET
// export function IsExtension ( b ) ; begin
18677: LD_INT 0
18679: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18680: LD_ADDR_VAR 0 2
18684: PUSH
18685: LD_VAR 0 1
18689: PUSH
18690: LD_INT 23
18692: PUSH
18693: LD_INT 20
18695: PUSH
18696: LD_INT 22
18698: PUSH
18699: LD_INT 17
18701: PUSH
18702: LD_INT 24
18704: PUSH
18705: LD_INT 21
18707: PUSH
18708: LD_INT 19
18710: PUSH
18711: LD_INT 16
18713: PUSH
18714: LD_INT 25
18716: PUSH
18717: LD_INT 18
18719: PUSH
18720: EMPTY
18721: LIST
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: IN
18732: ST_TO_ADDR
// end ;
18733: LD_VAR 0 2
18737: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18738: LD_INT 0
18740: PPUSH
18741: PPUSH
18742: PPUSH
// result := [ ] ;
18743: LD_ADDR_VAR 0 4
18747: PUSH
18748: EMPTY
18749: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18750: LD_ADDR_VAR 0 5
18754: PUSH
18755: LD_VAR 0 2
18759: PPUSH
18760: LD_INT 21
18762: PUSH
18763: LD_INT 3
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PPUSH
18770: CALL_OW 70
18774: ST_TO_ADDR
// if not tmp then
18775: LD_VAR 0 5
18779: NOT
18780: IFFALSE 18784
// exit ;
18782: GO 18848
// if checkLink then
18784: LD_VAR 0 3
18788: IFFALSE 18838
// begin for i in tmp do
18790: LD_ADDR_VAR 0 6
18794: PUSH
18795: LD_VAR 0 5
18799: PUSH
18800: FOR_IN
18801: IFFALSE 18836
// if GetBase ( i ) <> base then
18803: LD_VAR 0 6
18807: PPUSH
18808: CALL_OW 274
18812: PUSH
18813: LD_VAR 0 1
18817: NONEQUAL
18818: IFFALSE 18834
// ComLinkToBase ( base , i ) ;
18820: LD_VAR 0 1
18824: PPUSH
18825: LD_VAR 0 6
18829: PPUSH
18830: CALL_OW 169
18834: GO 18800
18836: POP
18837: POP
// end ; result := tmp ;
18838: LD_ADDR_VAR 0 4
18842: PUSH
18843: LD_VAR 0 5
18847: ST_TO_ADDR
// end ;
18848: LD_VAR 0 4
18852: RET
// export function ComComplete ( units , b ) ; var i ; begin
18853: LD_INT 0
18855: PPUSH
18856: PPUSH
// if not units then
18857: LD_VAR 0 1
18861: NOT
18862: IFFALSE 18866
// exit ;
18864: GO 18956
// for i in units do
18866: LD_ADDR_VAR 0 4
18870: PUSH
18871: LD_VAR 0 1
18875: PUSH
18876: FOR_IN
18877: IFFALSE 18954
// if BuildingStatus ( b ) = bs_build then
18879: LD_VAR 0 2
18883: PPUSH
18884: CALL_OW 461
18888: PUSH
18889: LD_INT 1
18891: EQUAL
18892: IFFALSE 18952
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
18894: LD_VAR 0 4
18898: PPUSH
18899: LD_STRING h
18901: PUSH
18902: LD_VAR 0 2
18906: PPUSH
18907: CALL_OW 250
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: CALL_OW 251
18921: PUSH
18922: LD_VAR 0 2
18926: PUSH
18927: LD_INT 0
18929: PUSH
18930: LD_INT 0
18932: PUSH
18933: LD_INT 0
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: PUSH
18945: EMPTY
18946: LIST
18947: PPUSH
18948: CALL_OW 446
18952: GO 18876
18954: POP
18955: POP
// end ;
18956: LD_VAR 0 3
18960: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
18961: LD_INT 0
18963: PPUSH
18964: PPUSH
18965: PPUSH
18966: PPUSH
18967: PPUSH
18968: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
18969: LD_VAR 0 1
18973: NOT
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: CALL_OW 263
18984: PUSH
18985: LD_INT 2
18987: NONEQUAL
18988: OR
18989: IFFALSE 18993
// exit ;
18991: GO 19309
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
18993: LD_ADDR_VAR 0 6
18997: PUSH
18998: LD_INT 22
19000: PUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 255
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: PUSH
19015: LD_INT 2
19017: PUSH
19018: LD_INT 30
19020: PUSH
19021: LD_INT 36
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: LD_INT 34
19030: PUSH
19031: LD_INT 31
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: LIST
19042: PUSH
19043: EMPTY
19044: LIST
19045: LIST
19046: PPUSH
19047: CALL_OW 69
19051: ST_TO_ADDR
// if not tmp then
19052: LD_VAR 0 6
19056: NOT
19057: IFFALSE 19061
// exit ;
19059: GO 19309
// result := [ ] ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: EMPTY
19067: ST_TO_ADDR
// for i in tmp do
19068: LD_ADDR_VAR 0 3
19072: PUSH
19073: LD_VAR 0 6
19077: PUSH
19078: FOR_IN
19079: IFFALSE 19150
// begin t := UnitsInside ( i ) ;
19081: LD_ADDR_VAR 0 4
19085: PUSH
19086: LD_VAR 0 3
19090: PPUSH
19091: CALL_OW 313
19095: ST_TO_ADDR
// if t then
19096: LD_VAR 0 4
19100: IFFALSE 19148
// for j in t do
19102: LD_ADDR_VAR 0 7
19106: PUSH
19107: LD_VAR 0 4
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19146
// result := Replace ( result , result + 1 , j ) ;
19115: LD_ADDR_VAR 0 2
19119: PUSH
19120: LD_VAR 0 2
19124: PPUSH
19125: LD_VAR 0 2
19129: PUSH
19130: LD_INT 1
19132: PLUS
19133: PPUSH
19134: LD_VAR 0 7
19138: PPUSH
19139: CALL_OW 1
19143: ST_TO_ADDR
19144: GO 19112
19146: POP
19147: POP
// end ;
19148: GO 19078
19150: POP
19151: POP
// if not result then
19152: LD_VAR 0 2
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 19309
// mech := result [ 1 ] ;
19161: LD_ADDR_VAR 0 5
19165: PUSH
19166: LD_VAR 0 2
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: ST_TO_ADDR
// if result > 1 then
19175: LD_VAR 0 2
19179: PUSH
19180: LD_INT 1
19182: GREATER
19183: IFFALSE 19295
// begin for i = 2 to result do
19185: LD_ADDR_VAR 0 3
19189: PUSH
19190: DOUBLE
19191: LD_INT 2
19193: DEC
19194: ST_TO_ADDR
19195: LD_VAR 0 2
19199: PUSH
19200: FOR_TO
19201: IFFALSE 19293
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19203: LD_ADDR_VAR 0 4
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_VAR 0 3
19217: ARRAY
19218: PPUSH
19219: LD_INT 3
19221: PPUSH
19222: CALL_OW 259
19226: PUSH
19227: LD_VAR 0 2
19231: PUSH
19232: LD_VAR 0 3
19236: ARRAY
19237: PPUSH
19238: CALL_OW 432
19242: MINUS
19243: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19244: LD_VAR 0 4
19248: PUSH
19249: LD_VAR 0 5
19253: PPUSH
19254: LD_INT 3
19256: PPUSH
19257: CALL_OW 259
19261: PUSH
19262: LD_VAR 0 5
19266: PPUSH
19267: CALL_OW 432
19271: MINUS
19272: GREATEREQUAL
19273: IFFALSE 19291
// mech := result [ i ] ;
19275: LD_ADDR_VAR 0 5
19279: PUSH
19280: LD_VAR 0 2
19284: PUSH
19285: LD_VAR 0 3
19289: ARRAY
19290: ST_TO_ADDR
// end ;
19291: GO 19200
19293: POP
19294: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 5
19304: PPUSH
19305: CALL_OW 135
// end ;
19309: LD_VAR 0 2
19313: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19314: LD_INT 0
19316: PPUSH
19317: PPUSH
19318: PPUSH
19319: PPUSH
19320: PPUSH
19321: PPUSH
19322: PPUSH
19323: PPUSH
19324: PPUSH
19325: PPUSH
19326: PPUSH
19327: PPUSH
19328: PPUSH
// result := [ ] ;
19329: LD_ADDR_VAR 0 7
19333: PUSH
19334: EMPTY
19335: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 266
19345: PUSH
19346: LD_INT 0
19348: PUSH
19349: LD_INT 1
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: IN
19356: NOT
19357: IFFALSE 19361
// exit ;
19359: GO 20995
// if name then
19361: LD_VAR 0 3
19365: IFFALSE 19381
// SetBName ( base_dep , name ) ;
19367: LD_VAR 0 1
19371: PPUSH
19372: LD_VAR 0 3
19376: PPUSH
19377: CALL_OW 500
// base := GetBase ( base_dep ) ;
19381: LD_ADDR_VAR 0 15
19385: PUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: CALL_OW 274
19395: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19396: LD_ADDR_VAR 0 16
19400: PUSH
19401: LD_VAR 0 1
19405: PPUSH
19406: CALL_OW 255
19410: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19411: LD_ADDR_VAR 0 17
19415: PUSH
19416: LD_VAR 0 1
19420: PPUSH
19421: CALL_OW 248
19425: ST_TO_ADDR
// if sources then
19426: LD_VAR 0 5
19430: IFFALSE 19477
// for i = 1 to 3 do
19432: LD_ADDR_VAR 0 8
19436: PUSH
19437: DOUBLE
19438: LD_INT 1
19440: DEC
19441: ST_TO_ADDR
19442: LD_INT 3
19444: PUSH
19445: FOR_TO
19446: IFFALSE 19475
// AddResourceType ( base , i , sources [ i ] ) ;
19448: LD_VAR 0 15
19452: PPUSH
19453: LD_VAR 0 8
19457: PPUSH
19458: LD_VAR 0 5
19462: PUSH
19463: LD_VAR 0 8
19467: ARRAY
19468: PPUSH
19469: CALL_OW 276
19473: GO 19445
19475: POP
19476: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19477: LD_ADDR_VAR 0 18
19481: PUSH
19482: LD_VAR 0 15
19486: PPUSH
19487: LD_VAR 0 2
19491: PPUSH
19492: LD_INT 1
19494: PPUSH
19495: CALL 18738 0 3
19499: ST_TO_ADDR
// InitHc ;
19500: CALL_OW 19
// InitUc ;
19504: CALL_OW 18
// uc_side := side ;
19508: LD_ADDR_OWVAR 20
19512: PUSH
19513: LD_VAR 0 16
19517: ST_TO_ADDR
// uc_nation := nation ;
19518: LD_ADDR_OWVAR 21
19522: PUSH
19523: LD_VAR 0 17
19527: ST_TO_ADDR
// if buildings then
19528: LD_VAR 0 18
19532: IFFALSE 20854
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19534: LD_ADDR_VAR 0 19
19538: PUSH
19539: LD_VAR 0 18
19543: PPUSH
19544: LD_INT 2
19546: PUSH
19547: LD_INT 30
19549: PUSH
19550: LD_INT 29
19552: PUSH
19553: EMPTY
19554: LIST
19555: LIST
19556: PUSH
19557: LD_INT 30
19559: PUSH
19560: LD_INT 30
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 72
19576: ST_TO_ADDR
// if tmp then
19577: LD_VAR 0 19
19581: IFFALSE 19629
// for i in tmp do
19583: LD_ADDR_VAR 0 8
19587: PUSH
19588: LD_VAR 0 19
19592: PUSH
19593: FOR_IN
19594: IFFALSE 19627
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19596: LD_VAR 0 8
19600: PPUSH
19601: CALL_OW 250
19605: PPUSH
19606: LD_VAR 0 8
19610: PPUSH
19611: CALL_OW 251
19615: PPUSH
19616: LD_VAR 0 16
19620: PPUSH
19621: CALL_OW 441
19625: GO 19593
19627: POP
19628: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19629: LD_VAR 0 18
19633: PPUSH
19634: LD_INT 2
19636: PUSH
19637: LD_INT 30
19639: PUSH
19640: LD_INT 32
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: PUSH
19647: LD_INT 30
19649: PUSH
19650: LD_INT 33
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: PUSH
19657: EMPTY
19658: LIST
19659: LIST
19660: LIST
19661: PPUSH
19662: CALL_OW 72
19666: IFFALSE 19754
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19668: LD_ADDR_VAR 0 8
19672: PUSH
19673: LD_VAR 0 18
19677: PPUSH
19678: LD_INT 2
19680: PUSH
19681: LD_INT 30
19683: PUSH
19684: LD_INT 32
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: PUSH
19691: LD_INT 30
19693: PUSH
19694: LD_INT 33
19696: PUSH
19697: EMPTY
19698: LIST
19699: LIST
19700: PUSH
19701: EMPTY
19702: LIST
19703: LIST
19704: LIST
19705: PPUSH
19706: CALL_OW 72
19710: PUSH
19711: FOR_IN
19712: IFFALSE 19752
// begin if not GetBWeapon ( i ) then
19714: LD_VAR 0 8
19718: PPUSH
19719: CALL_OW 269
19723: NOT
19724: IFFALSE 19750
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19726: LD_VAR 0 8
19730: PPUSH
19731: LD_VAR 0 8
19735: PPUSH
19736: LD_VAR 0 2
19740: PPUSH
19741: CALL 21000 0 2
19745: PPUSH
19746: CALL_OW 431
// end ;
19750: GO 19711
19752: POP
19753: POP
// end ; for i = 1 to personel do
19754: LD_ADDR_VAR 0 8
19758: PUSH
19759: DOUBLE
19760: LD_INT 1
19762: DEC
19763: ST_TO_ADDR
19764: LD_VAR 0 6
19768: PUSH
19769: FOR_TO
19770: IFFALSE 20834
// begin if i > 4 then
19772: LD_VAR 0 8
19776: PUSH
19777: LD_INT 4
19779: GREATER
19780: IFFALSE 19784
// break ;
19782: GO 20834
// case i of 1 :
19784: LD_VAR 0 8
19788: PUSH
19789: LD_INT 1
19791: DOUBLE
19792: EQUAL
19793: IFTRUE 19797
19795: GO 19877
19797: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19798: LD_ADDR_VAR 0 12
19802: PUSH
19803: LD_VAR 0 18
19807: PPUSH
19808: LD_INT 22
19810: PUSH
19811: LD_VAR 0 16
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 58
19822: PUSH
19823: EMPTY
19824: LIST
19825: PUSH
19826: LD_INT 2
19828: PUSH
19829: LD_INT 30
19831: PUSH
19832: LD_INT 32
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 4
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: PUSH
19849: LD_INT 30
19851: PUSH
19852: LD_INT 5
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: LIST
19869: PPUSH
19870: CALL_OW 72
19874: ST_TO_ADDR
19875: GO 20099
19877: LD_INT 2
19879: DOUBLE
19880: EQUAL
19881: IFTRUE 19885
19883: GO 19947
19885: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
19886: LD_ADDR_VAR 0 12
19890: PUSH
19891: LD_VAR 0 18
19895: PPUSH
19896: LD_INT 22
19898: PUSH
19899: LD_VAR 0 16
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: LD_INT 2
19910: PUSH
19911: LD_INT 30
19913: PUSH
19914: LD_INT 0
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: PUSH
19921: LD_INT 30
19923: PUSH
19924: LD_INT 1
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: LIST
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: PPUSH
19940: CALL_OW 72
19944: ST_TO_ADDR
19945: GO 20099
19947: LD_INT 3
19949: DOUBLE
19950: EQUAL
19951: IFTRUE 19955
19953: GO 20017
19955: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
19956: LD_ADDR_VAR 0 12
19960: PUSH
19961: LD_VAR 0 18
19965: PPUSH
19966: LD_INT 22
19968: PUSH
19969: LD_VAR 0 16
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: PUSH
19978: LD_INT 2
19980: PUSH
19981: LD_INT 30
19983: PUSH
19984: LD_INT 2
19986: PUSH
19987: EMPTY
19988: LIST
19989: LIST
19990: PUSH
19991: LD_INT 30
19993: PUSH
19994: LD_INT 3
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PUSH
20001: EMPTY
20002: LIST
20003: LIST
20004: LIST
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PPUSH
20010: CALL_OW 72
20014: ST_TO_ADDR
20015: GO 20099
20017: LD_INT 4
20019: DOUBLE
20020: EQUAL
20021: IFTRUE 20025
20023: GO 20098
20025: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20026: LD_ADDR_VAR 0 12
20030: PUSH
20031: LD_VAR 0 18
20035: PPUSH
20036: LD_INT 22
20038: PUSH
20039: LD_VAR 0 16
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: PUSH
20048: LD_INT 2
20050: PUSH
20051: LD_INT 30
20053: PUSH
20054: LD_INT 6
20056: PUSH
20057: EMPTY
20058: LIST
20059: LIST
20060: PUSH
20061: LD_INT 30
20063: PUSH
20064: LD_INT 7
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: PUSH
20071: LD_INT 30
20073: PUSH
20074: LD_INT 8
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: PPUSH
20091: CALL_OW 72
20095: ST_TO_ADDR
20096: GO 20099
20098: POP
// if i = 1 then
20099: LD_VAR 0 8
20103: PUSH
20104: LD_INT 1
20106: EQUAL
20107: IFFALSE 20218
// begin tmp := [ ] ;
20109: LD_ADDR_VAR 0 19
20113: PUSH
20114: EMPTY
20115: ST_TO_ADDR
// for j in f do
20116: LD_ADDR_VAR 0 9
20120: PUSH
20121: LD_VAR 0 12
20125: PUSH
20126: FOR_IN
20127: IFFALSE 20200
// if GetBType ( j ) = b_bunker then
20129: LD_VAR 0 9
20133: PPUSH
20134: CALL_OW 266
20138: PUSH
20139: LD_INT 32
20141: EQUAL
20142: IFFALSE 20169
// tmp := Insert ( tmp , 1 , j ) else
20144: LD_ADDR_VAR 0 19
20148: PUSH
20149: LD_VAR 0 19
20153: PPUSH
20154: LD_INT 1
20156: PPUSH
20157: LD_VAR 0 9
20161: PPUSH
20162: CALL_OW 2
20166: ST_TO_ADDR
20167: GO 20198
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20169: LD_ADDR_VAR 0 19
20173: PUSH
20174: LD_VAR 0 19
20178: PPUSH
20179: LD_VAR 0 19
20183: PUSH
20184: LD_INT 1
20186: PLUS
20187: PPUSH
20188: LD_VAR 0 9
20192: PPUSH
20193: CALL_OW 2
20197: ST_TO_ADDR
20198: GO 20126
20200: POP
20201: POP
// if tmp then
20202: LD_VAR 0 19
20206: IFFALSE 20218
// f := tmp ;
20208: LD_ADDR_VAR 0 12
20212: PUSH
20213: LD_VAR 0 19
20217: ST_TO_ADDR
// end ; x := personel [ i ] ;
20218: LD_ADDR_VAR 0 13
20222: PUSH
20223: LD_VAR 0 6
20227: PUSH
20228: LD_VAR 0 8
20232: ARRAY
20233: ST_TO_ADDR
// if x = - 1 then
20234: LD_VAR 0 13
20238: PUSH
20239: LD_INT 1
20241: NEG
20242: EQUAL
20243: IFFALSE 20452
// begin for j in f do
20245: LD_ADDR_VAR 0 9
20249: PUSH
20250: LD_VAR 0 12
20254: PUSH
20255: FOR_IN
20256: IFFALSE 20448
// repeat InitHc ;
20258: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20262: LD_VAR 0 9
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 5
20274: EQUAL
20275: IFFALSE 20345
// begin if UnitsInside ( j ) < 3 then
20277: LD_VAR 0 9
20281: PPUSH
20282: CALL_OW 313
20286: PUSH
20287: LD_INT 3
20289: LESS
20290: IFFALSE 20326
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20292: LD_INT 0
20294: PPUSH
20295: LD_INT 5
20297: PUSH
20298: LD_INT 8
20300: PUSH
20301: LD_INT 9
20303: PUSH
20304: EMPTY
20305: LIST
20306: LIST
20307: LIST
20308: PUSH
20309: LD_VAR 0 17
20313: ARRAY
20314: PPUSH
20315: LD_VAR 0 4
20319: PPUSH
20320: CALL_OW 380
20324: GO 20343
// PrepareHuman ( false , i , skill ) ;
20326: LD_INT 0
20328: PPUSH
20329: LD_VAR 0 8
20333: PPUSH
20334: LD_VAR 0 4
20338: PPUSH
20339: CALL_OW 380
// end else
20343: GO 20362
// PrepareHuman ( false , i , skill ) ;
20345: LD_INT 0
20347: PPUSH
20348: LD_VAR 0 8
20352: PPUSH
20353: LD_VAR 0 4
20357: PPUSH
20358: CALL_OW 380
// un := CreateHuman ;
20362: LD_ADDR_VAR 0 14
20366: PUSH
20367: CALL_OW 44
20371: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20372: LD_ADDR_VAR 0 7
20376: PUSH
20377: LD_VAR 0 7
20381: PPUSH
20382: LD_INT 1
20384: PPUSH
20385: LD_VAR 0 14
20389: PPUSH
20390: CALL_OW 2
20394: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20395: LD_VAR 0 14
20399: PPUSH
20400: LD_VAR 0 9
20404: PPUSH
20405: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20409: LD_VAR 0 9
20413: PPUSH
20414: CALL_OW 313
20418: PUSH
20419: LD_INT 6
20421: EQUAL
20422: PUSH
20423: LD_VAR 0 9
20427: PPUSH
20428: CALL_OW 266
20432: PUSH
20433: LD_INT 32
20435: PUSH
20436: LD_INT 31
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: IN
20443: OR
20444: IFFALSE 20258
20446: GO 20255
20448: POP
20449: POP
// end else
20450: GO 20832
// for j = 1 to x do
20452: LD_ADDR_VAR 0 9
20456: PUSH
20457: DOUBLE
20458: LD_INT 1
20460: DEC
20461: ST_TO_ADDR
20462: LD_VAR 0 13
20466: PUSH
20467: FOR_TO
20468: IFFALSE 20830
// begin InitHc ;
20470: CALL_OW 19
// if not f then
20474: LD_VAR 0 12
20478: NOT
20479: IFFALSE 20568
// begin PrepareHuman ( false , i , skill ) ;
20481: LD_INT 0
20483: PPUSH
20484: LD_VAR 0 8
20488: PPUSH
20489: LD_VAR 0 4
20493: PPUSH
20494: CALL_OW 380
// un := CreateHuman ;
20498: LD_ADDR_VAR 0 14
20502: PUSH
20503: CALL_OW 44
20507: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20508: LD_ADDR_VAR 0 7
20512: PUSH
20513: LD_VAR 0 7
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: LD_VAR 0 14
20525: PPUSH
20526: CALL_OW 2
20530: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20531: LD_VAR 0 14
20535: PPUSH
20536: LD_VAR 0 1
20540: PPUSH
20541: CALL_OW 250
20545: PPUSH
20546: LD_VAR 0 1
20550: PPUSH
20551: CALL_OW 251
20555: PPUSH
20556: LD_INT 10
20558: PPUSH
20559: LD_INT 0
20561: PPUSH
20562: CALL_OW 50
// continue ;
20566: GO 20467
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20568: LD_VAR 0 12
20572: PUSH
20573: LD_INT 1
20575: ARRAY
20576: PPUSH
20577: CALL_OW 313
20581: PUSH
20582: LD_VAR 0 12
20586: PUSH
20587: LD_INT 1
20589: ARRAY
20590: PPUSH
20591: CALL_OW 266
20595: PUSH
20596: LD_INT 32
20598: PUSH
20599: LD_INT 31
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: IN
20606: AND
20607: PUSH
20608: LD_VAR 0 12
20612: PUSH
20613: LD_INT 1
20615: ARRAY
20616: PPUSH
20617: CALL_OW 313
20621: PUSH
20622: LD_INT 6
20624: EQUAL
20625: OR
20626: IFFALSE 20646
// f := Delete ( f , 1 ) ;
20628: LD_ADDR_VAR 0 12
20632: PUSH
20633: LD_VAR 0 12
20637: PPUSH
20638: LD_INT 1
20640: PPUSH
20641: CALL_OW 3
20645: ST_TO_ADDR
// if not f then
20646: LD_VAR 0 12
20650: NOT
20651: IFFALSE 20669
// begin x := x + 2 ;
20653: LD_ADDR_VAR 0 13
20657: PUSH
20658: LD_VAR 0 13
20662: PUSH
20663: LD_INT 2
20665: PLUS
20666: ST_TO_ADDR
// continue ;
20667: GO 20467
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20669: LD_VAR 0 12
20673: PUSH
20674: LD_INT 1
20676: ARRAY
20677: PPUSH
20678: CALL_OW 266
20682: PUSH
20683: LD_INT 5
20685: EQUAL
20686: IFFALSE 20760
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20688: LD_VAR 0 12
20692: PUSH
20693: LD_INT 1
20695: ARRAY
20696: PPUSH
20697: CALL_OW 313
20701: PUSH
20702: LD_INT 3
20704: LESS
20705: IFFALSE 20741
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20707: LD_INT 0
20709: PPUSH
20710: LD_INT 5
20712: PUSH
20713: LD_INT 8
20715: PUSH
20716: LD_INT 9
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: LIST
20723: PUSH
20724: LD_VAR 0 17
20728: ARRAY
20729: PPUSH
20730: LD_VAR 0 4
20734: PPUSH
20735: CALL_OW 380
20739: GO 20758
// PrepareHuman ( false , i , skill ) ;
20741: LD_INT 0
20743: PPUSH
20744: LD_VAR 0 8
20748: PPUSH
20749: LD_VAR 0 4
20753: PPUSH
20754: CALL_OW 380
// end else
20758: GO 20777
// PrepareHuman ( false , i , skill ) ;
20760: LD_INT 0
20762: PPUSH
20763: LD_VAR 0 8
20767: PPUSH
20768: LD_VAR 0 4
20772: PPUSH
20773: CALL_OW 380
// un := CreateHuman ;
20777: LD_ADDR_VAR 0 14
20781: PUSH
20782: CALL_OW 44
20786: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20787: LD_ADDR_VAR 0 7
20791: PUSH
20792: LD_VAR 0 7
20796: PPUSH
20797: LD_INT 1
20799: PPUSH
20800: LD_VAR 0 14
20804: PPUSH
20805: CALL_OW 2
20809: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20810: LD_VAR 0 14
20814: PPUSH
20815: LD_VAR 0 12
20819: PUSH
20820: LD_INT 1
20822: ARRAY
20823: PPUSH
20824: CALL_OW 52
// end ;
20828: GO 20467
20830: POP
20831: POP
// end ;
20832: GO 19769
20834: POP
20835: POP
// result := result ^ buildings ;
20836: LD_ADDR_VAR 0 7
20840: PUSH
20841: LD_VAR 0 7
20845: PUSH
20846: LD_VAR 0 18
20850: ADD
20851: ST_TO_ADDR
// end else
20852: GO 20995
// begin for i = 1 to personel do
20854: LD_ADDR_VAR 0 8
20858: PUSH
20859: DOUBLE
20860: LD_INT 1
20862: DEC
20863: ST_TO_ADDR
20864: LD_VAR 0 6
20868: PUSH
20869: FOR_TO
20870: IFFALSE 20993
// begin if i > 4 then
20872: LD_VAR 0 8
20876: PUSH
20877: LD_INT 4
20879: GREATER
20880: IFFALSE 20884
// break ;
20882: GO 20993
// x := personel [ i ] ;
20884: LD_ADDR_VAR 0 13
20888: PUSH
20889: LD_VAR 0 6
20893: PUSH
20894: LD_VAR 0 8
20898: ARRAY
20899: ST_TO_ADDR
// if x = - 1 then
20900: LD_VAR 0 13
20904: PUSH
20905: LD_INT 1
20907: NEG
20908: EQUAL
20909: IFFALSE 20913
// continue ;
20911: GO 20869
// PrepareHuman ( false , i , skill ) ;
20913: LD_INT 0
20915: PPUSH
20916: LD_VAR 0 8
20920: PPUSH
20921: LD_VAR 0 4
20925: PPUSH
20926: CALL_OW 380
// un := CreateHuman ;
20930: LD_ADDR_VAR 0 14
20934: PUSH
20935: CALL_OW 44
20939: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20940: LD_VAR 0 14
20944: PPUSH
20945: LD_VAR 0 1
20949: PPUSH
20950: CALL_OW 250
20954: PPUSH
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 251
20964: PPUSH
20965: LD_INT 10
20967: PPUSH
20968: LD_INT 0
20970: PPUSH
20971: CALL_OW 50
// result := result ^ un ;
20975: LD_ADDR_VAR 0 7
20979: PUSH
20980: LD_VAR 0 7
20984: PUSH
20985: LD_VAR 0 14
20989: ADD
20990: ST_TO_ADDR
// end ;
20991: GO 20869
20993: POP
20994: POP
// end ; end ;
20995: LD_VAR 0 7
20999: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21000: LD_INT 0
21002: PPUSH
21003: PPUSH
21004: PPUSH
21005: PPUSH
21006: PPUSH
21007: PPUSH
21008: PPUSH
21009: PPUSH
21010: PPUSH
21011: PPUSH
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
21016: PPUSH
21017: PPUSH
// result := false ;
21018: LD_ADDR_VAR 0 3
21022: PUSH
21023: LD_INT 0
21025: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21026: LD_VAR 0 1
21030: NOT
21031: PUSH
21032: LD_VAR 0 1
21036: PPUSH
21037: CALL_OW 266
21041: PUSH
21042: LD_INT 32
21044: PUSH
21045: LD_INT 33
21047: PUSH
21048: EMPTY
21049: LIST
21050: LIST
21051: IN
21052: NOT
21053: OR
21054: IFFALSE 21058
// exit ;
21056: GO 22167
// nat := GetNation ( tower ) ;
21058: LD_ADDR_VAR 0 12
21062: PUSH
21063: LD_VAR 0 1
21067: PPUSH
21068: CALL_OW 248
21072: ST_TO_ADDR
// side := GetSide ( tower ) ;
21073: LD_ADDR_VAR 0 16
21077: PUSH
21078: LD_VAR 0 1
21082: PPUSH
21083: CALL_OW 255
21087: ST_TO_ADDR
// x := GetX ( tower ) ;
21088: LD_ADDR_VAR 0 10
21092: PUSH
21093: LD_VAR 0 1
21097: PPUSH
21098: CALL_OW 250
21102: ST_TO_ADDR
// y := GetY ( tower ) ;
21103: LD_ADDR_VAR 0 11
21107: PUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 251
21117: ST_TO_ADDR
// if not x or not y then
21118: LD_VAR 0 10
21122: NOT
21123: PUSH
21124: LD_VAR 0 11
21128: NOT
21129: OR
21130: IFFALSE 21134
// exit ;
21132: GO 22167
// weapon := 0 ;
21134: LD_ADDR_VAR 0 18
21138: PUSH
21139: LD_INT 0
21141: ST_TO_ADDR
// fac_list := [ ] ;
21142: LD_ADDR_VAR 0 17
21146: PUSH
21147: EMPTY
21148: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21149: LD_ADDR_VAR 0 6
21153: PUSH
21154: LD_VAR 0 1
21158: PPUSH
21159: CALL_OW 274
21163: PPUSH
21164: LD_VAR 0 2
21168: PPUSH
21169: LD_INT 0
21171: PPUSH
21172: CALL 18738 0 3
21176: PPUSH
21177: LD_INT 30
21179: PUSH
21180: LD_INT 3
21182: PUSH
21183: EMPTY
21184: LIST
21185: LIST
21186: PPUSH
21187: CALL_OW 72
21191: ST_TO_ADDR
// if not factories then
21192: LD_VAR 0 6
21196: NOT
21197: IFFALSE 21201
// exit ;
21199: GO 22167
// for i in factories do
21201: LD_ADDR_VAR 0 8
21205: PUSH
21206: LD_VAR 0 6
21210: PUSH
21211: FOR_IN
21212: IFFALSE 21237
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21214: LD_ADDR_VAR 0 17
21218: PUSH
21219: LD_VAR 0 17
21223: PUSH
21224: LD_VAR 0 8
21228: PPUSH
21229: CALL_OW 478
21233: UNION
21234: ST_TO_ADDR
21235: GO 21211
21237: POP
21238: POP
// if not fac_list then
21239: LD_VAR 0 17
21243: NOT
21244: IFFALSE 21248
// exit ;
21246: GO 22167
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21248: LD_ADDR_VAR 0 5
21252: PUSH
21253: LD_INT 4
21255: PUSH
21256: LD_INT 5
21258: PUSH
21259: LD_INT 9
21261: PUSH
21262: LD_INT 10
21264: PUSH
21265: LD_INT 6
21267: PUSH
21268: LD_INT 7
21270: PUSH
21271: LD_INT 11
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 27
21285: PUSH
21286: LD_INT 28
21288: PUSH
21289: LD_INT 26
21291: PUSH
21292: LD_INT 30
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: PUSH
21301: LD_INT 43
21303: PUSH
21304: LD_INT 44
21306: PUSH
21307: LD_INT 46
21309: PUSH
21310: LD_INT 45
21312: PUSH
21313: LD_INT 47
21315: PUSH
21316: LD_INT 49
21318: PUSH
21319: EMPTY
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: LIST
21331: PUSH
21332: LD_VAR 0 12
21336: ARRAY
21337: ST_TO_ADDR
// list := list isect fac_list ;
21338: LD_ADDR_VAR 0 5
21342: PUSH
21343: LD_VAR 0 5
21347: PUSH
21348: LD_VAR 0 17
21352: ISECT
21353: ST_TO_ADDR
// if not list then
21354: LD_VAR 0 5
21358: NOT
21359: IFFALSE 21363
// exit ;
21361: GO 22167
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21363: LD_VAR 0 12
21367: PUSH
21368: LD_INT 3
21370: EQUAL
21371: PUSH
21372: LD_INT 49
21374: PUSH
21375: LD_VAR 0 5
21379: IN
21380: AND
21381: PUSH
21382: LD_INT 31
21384: PPUSH
21385: LD_VAR 0 16
21389: PPUSH
21390: CALL_OW 321
21394: PUSH
21395: LD_INT 2
21397: EQUAL
21398: AND
21399: IFFALSE 21459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21401: LD_INT 22
21403: PUSH
21404: LD_VAR 0 16
21408: PUSH
21409: EMPTY
21410: LIST
21411: LIST
21412: PUSH
21413: LD_INT 35
21415: PUSH
21416: LD_INT 49
21418: PUSH
21419: EMPTY
21420: LIST
21421: LIST
21422: PUSH
21423: LD_INT 91
21425: PUSH
21426: LD_VAR 0 1
21430: PUSH
21431: LD_INT 10
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: LIST
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: LIST
21443: PPUSH
21444: CALL_OW 69
21448: NOT
21449: IFFALSE 21459
// weapon := ru_time_lapser ;
21451: LD_ADDR_VAR 0 18
21455: PUSH
21456: LD_INT 49
21458: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21459: LD_VAR 0 12
21463: PUSH
21464: LD_INT 1
21466: PUSH
21467: LD_INT 2
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: IN
21474: PUSH
21475: LD_INT 11
21477: PUSH
21478: LD_VAR 0 5
21482: IN
21483: PUSH
21484: LD_INT 30
21486: PUSH
21487: LD_VAR 0 5
21491: IN
21492: OR
21493: AND
21494: PUSH
21495: LD_INT 6
21497: PPUSH
21498: LD_VAR 0 16
21502: PPUSH
21503: CALL_OW 321
21507: PUSH
21508: LD_INT 2
21510: EQUAL
21511: AND
21512: IFFALSE 21677
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21514: LD_INT 22
21516: PUSH
21517: LD_VAR 0 16
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: PUSH
21526: LD_INT 2
21528: PUSH
21529: LD_INT 35
21531: PUSH
21532: LD_INT 11
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 35
21541: PUSH
21542: LD_INT 30
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: LIST
21553: PUSH
21554: LD_INT 91
21556: PUSH
21557: LD_VAR 0 1
21561: PUSH
21562: LD_INT 18
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: LIST
21569: PUSH
21570: EMPTY
21571: LIST
21572: LIST
21573: LIST
21574: PPUSH
21575: CALL_OW 69
21579: NOT
21580: PUSH
21581: LD_INT 22
21583: PUSH
21584: LD_VAR 0 16
21588: PUSH
21589: EMPTY
21590: LIST
21591: LIST
21592: PUSH
21593: LD_INT 2
21595: PUSH
21596: LD_INT 30
21598: PUSH
21599: LD_INT 32
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: PUSH
21606: LD_INT 30
21608: PUSH
21609: LD_INT 33
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: PUSH
21616: EMPTY
21617: LIST
21618: LIST
21619: LIST
21620: PUSH
21621: LD_INT 91
21623: PUSH
21624: LD_VAR 0 1
21628: PUSH
21629: LD_INT 12
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: LIST
21636: PUSH
21637: EMPTY
21638: LIST
21639: LIST
21640: LIST
21641: PUSH
21642: EMPTY
21643: LIST
21644: PPUSH
21645: CALL_OW 69
21649: PUSH
21650: LD_INT 2
21652: GREATER
21653: AND
21654: IFFALSE 21677
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21656: LD_ADDR_VAR 0 18
21660: PUSH
21661: LD_INT 11
21663: PUSH
21664: LD_INT 30
21666: PUSH
21667: EMPTY
21668: LIST
21669: LIST
21670: PUSH
21671: LD_VAR 0 12
21675: ARRAY
21676: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21677: LD_VAR 0 18
21681: NOT
21682: PUSH
21683: LD_INT 40
21685: PPUSH
21686: LD_VAR 0 16
21690: PPUSH
21691: CALL_OW 321
21695: PUSH
21696: LD_INT 2
21698: EQUAL
21699: AND
21700: PUSH
21701: LD_INT 7
21703: PUSH
21704: LD_VAR 0 5
21708: IN
21709: PUSH
21710: LD_INT 28
21712: PUSH
21713: LD_VAR 0 5
21717: IN
21718: OR
21719: PUSH
21720: LD_INT 45
21722: PUSH
21723: LD_VAR 0 5
21727: IN
21728: OR
21729: AND
21730: IFFALSE 21984
// begin hex := GetHexInfo ( x , y ) ;
21732: LD_ADDR_VAR 0 4
21736: PUSH
21737: LD_VAR 0 10
21741: PPUSH
21742: LD_VAR 0 11
21746: PPUSH
21747: CALL_OW 546
21751: ST_TO_ADDR
// if hex [ 1 ] then
21752: LD_VAR 0 4
21756: PUSH
21757: LD_INT 1
21759: ARRAY
21760: IFFALSE 21764
// exit ;
21762: GO 22167
// height := hex [ 2 ] ;
21764: LD_ADDR_VAR 0 15
21768: PUSH
21769: LD_VAR 0 4
21773: PUSH
21774: LD_INT 2
21776: ARRAY
21777: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21778: LD_ADDR_VAR 0 14
21782: PUSH
21783: LD_INT 0
21785: PUSH
21786: LD_INT 2
21788: PUSH
21789: LD_INT 3
21791: PUSH
21792: LD_INT 5
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: ST_TO_ADDR
// for i in tmp do
21801: LD_ADDR_VAR 0 8
21805: PUSH
21806: LD_VAR 0 14
21810: PUSH
21811: FOR_IN
21812: IFFALSE 21982
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21814: LD_ADDR_VAR 0 9
21818: PUSH
21819: LD_VAR 0 10
21823: PPUSH
21824: LD_VAR 0 8
21828: PPUSH
21829: LD_INT 5
21831: PPUSH
21832: CALL_OW 272
21836: PUSH
21837: LD_VAR 0 11
21841: PPUSH
21842: LD_VAR 0 8
21846: PPUSH
21847: LD_INT 5
21849: PPUSH
21850: CALL_OW 273
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21859: LD_VAR 0 9
21863: PUSH
21864: LD_INT 1
21866: ARRAY
21867: PPUSH
21868: LD_VAR 0 9
21872: PUSH
21873: LD_INT 2
21875: ARRAY
21876: PPUSH
21877: CALL_OW 488
21881: IFFALSE 21980
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
21883: LD_ADDR_VAR 0 4
21887: PUSH
21888: LD_VAR 0 9
21892: PUSH
21893: LD_INT 1
21895: ARRAY
21896: PPUSH
21897: LD_VAR 0 9
21901: PUSH
21902: LD_INT 2
21904: ARRAY
21905: PPUSH
21906: CALL_OW 546
21910: ST_TO_ADDR
// if hex [ 1 ] then
21911: LD_VAR 0 4
21915: PUSH
21916: LD_INT 1
21918: ARRAY
21919: IFFALSE 21923
// continue ;
21921: GO 21811
// h := hex [ 2 ] ;
21923: LD_ADDR_VAR 0 13
21927: PUSH
21928: LD_VAR 0 4
21932: PUSH
21933: LD_INT 2
21935: ARRAY
21936: ST_TO_ADDR
// if h + 7 < height then
21937: LD_VAR 0 13
21941: PUSH
21942: LD_INT 7
21944: PLUS
21945: PUSH
21946: LD_VAR 0 15
21950: LESS
21951: IFFALSE 21980
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
21953: LD_ADDR_VAR 0 18
21957: PUSH
21958: LD_INT 7
21960: PUSH
21961: LD_INT 28
21963: PUSH
21964: LD_INT 45
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: LIST
21971: PUSH
21972: LD_VAR 0 12
21976: ARRAY
21977: ST_TO_ADDR
// break ;
21978: GO 21982
// end ; end ; end ;
21980: GO 21811
21982: POP
21983: POP
// end ; if not weapon then
21984: LD_VAR 0 18
21988: NOT
21989: IFFALSE 22049
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
21991: LD_ADDR_VAR 0 5
21995: PUSH
21996: LD_VAR 0 5
22000: PUSH
22001: LD_INT 11
22003: PUSH
22004: LD_INT 30
22006: PUSH
22007: LD_INT 49
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: LIST
22014: DIFF
22015: ST_TO_ADDR
// if not list then
22016: LD_VAR 0 5
22020: NOT
22021: IFFALSE 22025
// exit ;
22023: GO 22167
// weapon := list [ rand ( 1 , list ) ] ;
22025: LD_ADDR_VAR 0 18
22029: PUSH
22030: LD_VAR 0 5
22034: PUSH
22035: LD_INT 1
22037: PPUSH
22038: LD_VAR 0 5
22042: PPUSH
22043: CALL_OW 12
22047: ARRAY
22048: ST_TO_ADDR
// end ; if weapon then
22049: LD_VAR 0 18
22053: IFFALSE 22167
// begin tmp := CostOfWeapon ( weapon ) ;
22055: LD_ADDR_VAR 0 14
22059: PUSH
22060: LD_VAR 0 18
22064: PPUSH
22065: CALL_OW 451
22069: ST_TO_ADDR
// j := GetBase ( tower ) ;
22070: LD_ADDR_VAR 0 9
22074: PUSH
22075: LD_VAR 0 1
22079: PPUSH
22080: CALL_OW 274
22084: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22085: LD_VAR 0 9
22089: PPUSH
22090: LD_INT 1
22092: PPUSH
22093: CALL_OW 275
22097: PUSH
22098: LD_VAR 0 14
22102: PUSH
22103: LD_INT 1
22105: ARRAY
22106: GREATEREQUAL
22107: PUSH
22108: LD_VAR 0 9
22112: PPUSH
22113: LD_INT 2
22115: PPUSH
22116: CALL_OW 275
22120: PUSH
22121: LD_VAR 0 14
22125: PUSH
22126: LD_INT 2
22128: ARRAY
22129: GREATEREQUAL
22130: AND
22131: PUSH
22132: LD_VAR 0 9
22136: PPUSH
22137: LD_INT 3
22139: PPUSH
22140: CALL_OW 275
22144: PUSH
22145: LD_VAR 0 14
22149: PUSH
22150: LD_INT 3
22152: ARRAY
22153: GREATEREQUAL
22154: AND
22155: IFFALSE 22167
// result := weapon ;
22157: LD_ADDR_VAR 0 3
22161: PUSH
22162: LD_VAR 0 18
22166: ST_TO_ADDR
// end ; end ;
22167: LD_VAR 0 3
22171: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22172: LD_INT 0
22174: PPUSH
22175: PPUSH
// result := true ;
22176: LD_ADDR_VAR 0 3
22180: PUSH
22181: LD_INT 1
22183: ST_TO_ADDR
// if array1 = array2 then
22184: LD_VAR 0 1
22188: PUSH
22189: LD_VAR 0 2
22193: EQUAL
22194: IFFALSE 22254
// begin for i = 1 to array1 do
22196: LD_ADDR_VAR 0 4
22200: PUSH
22201: DOUBLE
22202: LD_INT 1
22204: DEC
22205: ST_TO_ADDR
22206: LD_VAR 0 1
22210: PUSH
22211: FOR_TO
22212: IFFALSE 22250
// if array1 [ i ] <> array2 [ i ] then
22214: LD_VAR 0 1
22218: PUSH
22219: LD_VAR 0 4
22223: ARRAY
22224: PUSH
22225: LD_VAR 0 2
22229: PUSH
22230: LD_VAR 0 4
22234: ARRAY
22235: NONEQUAL
22236: IFFALSE 22248
// begin result := false ;
22238: LD_ADDR_VAR 0 3
22242: PUSH
22243: LD_INT 0
22245: ST_TO_ADDR
// break ;
22246: GO 22250
// end ;
22248: GO 22211
22250: POP
22251: POP
// end else
22252: GO 22262
// result := false ;
22254: LD_ADDR_VAR 0 3
22258: PUSH
22259: LD_INT 0
22261: ST_TO_ADDR
// end ;
22262: LD_VAR 0 3
22266: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22267: LD_INT 0
22269: PPUSH
22270: PPUSH
// if not array1 or not array2 then
22271: LD_VAR 0 1
22275: NOT
22276: PUSH
22277: LD_VAR 0 2
22281: NOT
22282: OR
22283: IFFALSE 22287
// exit ;
22285: GO 22351
// result := true ;
22287: LD_ADDR_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ST_TO_ADDR
// for i = 1 to array1 do
22295: LD_ADDR_VAR 0 4
22299: PUSH
22300: DOUBLE
22301: LD_INT 1
22303: DEC
22304: ST_TO_ADDR
22305: LD_VAR 0 1
22309: PUSH
22310: FOR_TO
22311: IFFALSE 22349
// if array1 [ i ] <> array2 [ i ] then
22313: LD_VAR 0 1
22317: PUSH
22318: LD_VAR 0 4
22322: ARRAY
22323: PUSH
22324: LD_VAR 0 2
22328: PUSH
22329: LD_VAR 0 4
22333: ARRAY
22334: NONEQUAL
22335: IFFALSE 22347
// begin result := false ;
22337: LD_ADDR_VAR 0 3
22341: PUSH
22342: LD_INT 0
22344: ST_TO_ADDR
// break ;
22345: GO 22349
// end ;
22347: GO 22310
22349: POP
22350: POP
// end ;
22351: LD_VAR 0 3
22355: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22356: LD_INT 0
22358: PPUSH
22359: PPUSH
22360: PPUSH
// pom := GetBase ( fac ) ;
22361: LD_ADDR_VAR 0 5
22365: PUSH
22366: LD_VAR 0 1
22370: PPUSH
22371: CALL_OW 274
22375: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22376: LD_ADDR_VAR 0 4
22380: PUSH
22381: LD_VAR 0 2
22385: PUSH
22386: LD_INT 1
22388: ARRAY
22389: PPUSH
22390: LD_VAR 0 2
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: PPUSH
22399: LD_VAR 0 2
22403: PUSH
22404: LD_INT 3
22406: ARRAY
22407: PPUSH
22408: LD_VAR 0 2
22412: PUSH
22413: LD_INT 4
22415: ARRAY
22416: PPUSH
22417: CALL_OW 449
22421: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22422: LD_ADDR_VAR 0 3
22426: PUSH
22427: LD_VAR 0 5
22431: PPUSH
22432: LD_INT 1
22434: PPUSH
22435: CALL_OW 275
22439: PUSH
22440: LD_VAR 0 4
22444: PUSH
22445: LD_INT 1
22447: ARRAY
22448: GREATEREQUAL
22449: PUSH
22450: LD_VAR 0 5
22454: PPUSH
22455: LD_INT 2
22457: PPUSH
22458: CALL_OW 275
22462: PUSH
22463: LD_VAR 0 4
22467: PUSH
22468: LD_INT 2
22470: ARRAY
22471: GREATEREQUAL
22472: AND
22473: PUSH
22474: LD_VAR 0 5
22478: PPUSH
22479: LD_INT 3
22481: PPUSH
22482: CALL_OW 275
22486: PUSH
22487: LD_VAR 0 4
22491: PUSH
22492: LD_INT 3
22494: ARRAY
22495: GREATEREQUAL
22496: AND
22497: ST_TO_ADDR
// end ;
22498: LD_VAR 0 3
22502: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22503: LD_INT 0
22505: PPUSH
22506: PPUSH
22507: PPUSH
22508: PPUSH
// pom := GetBase ( building ) ;
22509: LD_ADDR_VAR 0 3
22513: PUSH
22514: LD_VAR 0 1
22518: PPUSH
22519: CALL_OW 274
22523: ST_TO_ADDR
// if not pom then
22524: LD_VAR 0 3
22528: NOT
22529: IFFALSE 22533
// exit ;
22531: GO 22703
// btype := GetBType ( building ) ;
22533: LD_ADDR_VAR 0 5
22537: PUSH
22538: LD_VAR 0 1
22542: PPUSH
22543: CALL_OW 266
22547: ST_TO_ADDR
// if btype = b_armoury then
22548: LD_VAR 0 5
22552: PUSH
22553: LD_INT 4
22555: EQUAL
22556: IFFALSE 22566
// btype := b_barracks ;
22558: LD_ADDR_VAR 0 5
22562: PUSH
22563: LD_INT 5
22565: ST_TO_ADDR
// if btype = b_depot then
22566: LD_VAR 0 5
22570: PUSH
22571: LD_INT 0
22573: EQUAL
22574: IFFALSE 22584
// btype := b_warehouse ;
22576: LD_ADDR_VAR 0 5
22580: PUSH
22581: LD_INT 1
22583: ST_TO_ADDR
// if btype = b_workshop then
22584: LD_VAR 0 5
22588: PUSH
22589: LD_INT 2
22591: EQUAL
22592: IFFALSE 22602
// btype := b_factory ;
22594: LD_ADDR_VAR 0 5
22598: PUSH
22599: LD_INT 3
22601: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22602: LD_ADDR_VAR 0 4
22606: PUSH
22607: LD_VAR 0 5
22611: PPUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 248
22621: PPUSH
22622: CALL_OW 450
22626: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22627: LD_ADDR_VAR 0 2
22631: PUSH
22632: LD_VAR 0 3
22636: PPUSH
22637: LD_INT 1
22639: PPUSH
22640: CALL_OW 275
22644: PUSH
22645: LD_VAR 0 4
22649: PUSH
22650: LD_INT 1
22652: ARRAY
22653: GREATEREQUAL
22654: PUSH
22655: LD_VAR 0 3
22659: PPUSH
22660: LD_INT 2
22662: PPUSH
22663: CALL_OW 275
22667: PUSH
22668: LD_VAR 0 4
22672: PUSH
22673: LD_INT 2
22675: ARRAY
22676: GREATEREQUAL
22677: AND
22678: PUSH
22679: LD_VAR 0 3
22683: PPUSH
22684: LD_INT 3
22686: PPUSH
22687: CALL_OW 275
22691: PUSH
22692: LD_VAR 0 4
22696: PUSH
22697: LD_INT 3
22699: ARRAY
22700: GREATEREQUAL
22701: AND
22702: ST_TO_ADDR
// end ;
22703: LD_VAR 0 2
22707: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22708: LD_INT 0
22710: PPUSH
22711: PPUSH
22712: PPUSH
// pom := GetBase ( building ) ;
22713: LD_ADDR_VAR 0 4
22717: PUSH
22718: LD_VAR 0 1
22722: PPUSH
22723: CALL_OW 274
22727: ST_TO_ADDR
// if not pom then
22728: LD_VAR 0 4
22732: NOT
22733: IFFALSE 22737
// exit ;
22735: GO 22838
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22737: LD_ADDR_VAR 0 5
22741: PUSH
22742: LD_VAR 0 2
22746: PPUSH
22747: LD_VAR 0 1
22751: PPUSH
22752: CALL_OW 248
22756: PPUSH
22757: CALL_OW 450
22761: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22762: LD_ADDR_VAR 0 3
22766: PUSH
22767: LD_VAR 0 4
22771: PPUSH
22772: LD_INT 1
22774: PPUSH
22775: CALL_OW 275
22779: PUSH
22780: LD_VAR 0 5
22784: PUSH
22785: LD_INT 1
22787: ARRAY
22788: GREATEREQUAL
22789: PUSH
22790: LD_VAR 0 4
22794: PPUSH
22795: LD_INT 2
22797: PPUSH
22798: CALL_OW 275
22802: PUSH
22803: LD_VAR 0 5
22807: PUSH
22808: LD_INT 2
22810: ARRAY
22811: GREATEREQUAL
22812: AND
22813: PUSH
22814: LD_VAR 0 4
22818: PPUSH
22819: LD_INT 3
22821: PPUSH
22822: CALL_OW 275
22826: PUSH
22827: LD_VAR 0 5
22831: PUSH
22832: LD_INT 3
22834: ARRAY
22835: GREATEREQUAL
22836: AND
22837: ST_TO_ADDR
// end ;
22838: LD_VAR 0 3
22842: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22843: LD_INT 0
22845: PPUSH
22846: PPUSH
22847: PPUSH
22848: PPUSH
22849: PPUSH
22850: PPUSH
22851: PPUSH
22852: PPUSH
22853: PPUSH
22854: PPUSH
22855: PPUSH
// result := false ;
22856: LD_ADDR_VAR 0 8
22860: PUSH
22861: LD_INT 0
22863: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22864: LD_VAR 0 5
22868: NOT
22869: PUSH
22870: LD_VAR 0 1
22874: NOT
22875: OR
22876: PUSH
22877: LD_VAR 0 2
22881: NOT
22882: OR
22883: PUSH
22884: LD_VAR 0 3
22888: NOT
22889: OR
22890: IFFALSE 22894
// exit ;
22892: GO 23708
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
22894: LD_ADDR_VAR 0 14
22898: PUSH
22899: LD_VAR 0 1
22903: PPUSH
22904: LD_VAR 0 2
22908: PPUSH
22909: LD_VAR 0 3
22913: PPUSH
22914: LD_VAR 0 4
22918: PPUSH
22919: LD_VAR 0 5
22923: PUSH
22924: LD_INT 1
22926: ARRAY
22927: PPUSH
22928: CALL_OW 248
22932: PPUSH
22933: LD_INT 0
22935: PPUSH
22936: CALL 24945 0 6
22940: ST_TO_ADDR
// if not hexes then
22941: LD_VAR 0 14
22945: NOT
22946: IFFALSE 22950
// exit ;
22948: GO 23708
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22950: LD_ADDR_VAR 0 17
22954: PUSH
22955: LD_VAR 0 5
22959: PPUSH
22960: LD_INT 22
22962: PUSH
22963: LD_VAR 0 13
22967: PPUSH
22968: CALL_OW 255
22972: PUSH
22973: EMPTY
22974: LIST
22975: LIST
22976: PUSH
22977: LD_INT 2
22979: PUSH
22980: LD_INT 30
22982: PUSH
22983: LD_INT 0
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PUSH
22990: LD_INT 30
22992: PUSH
22993: LD_INT 1
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: LIST
23004: PUSH
23005: EMPTY
23006: LIST
23007: LIST
23008: PPUSH
23009: CALL_OW 72
23013: ST_TO_ADDR
// for i = 1 to hexes do
23014: LD_ADDR_VAR 0 9
23018: PUSH
23019: DOUBLE
23020: LD_INT 1
23022: DEC
23023: ST_TO_ADDR
23024: LD_VAR 0 14
23028: PUSH
23029: FOR_TO
23030: IFFALSE 23706
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23032: LD_ADDR_VAR 0 13
23036: PUSH
23037: LD_VAR 0 14
23041: PUSH
23042: LD_VAR 0 9
23046: ARRAY
23047: PUSH
23048: LD_INT 1
23050: ARRAY
23051: PPUSH
23052: LD_VAR 0 14
23056: PUSH
23057: LD_VAR 0 9
23061: ARRAY
23062: PUSH
23063: LD_INT 2
23065: ARRAY
23066: PPUSH
23067: CALL_OW 428
23071: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23072: LD_VAR 0 14
23076: PUSH
23077: LD_VAR 0 9
23081: ARRAY
23082: PUSH
23083: LD_INT 1
23085: ARRAY
23086: PPUSH
23087: LD_VAR 0 14
23091: PUSH
23092: LD_VAR 0 9
23096: ARRAY
23097: PUSH
23098: LD_INT 2
23100: ARRAY
23101: PPUSH
23102: CALL_OW 351
23106: PUSH
23107: LD_VAR 0 14
23111: PUSH
23112: LD_VAR 0 9
23116: ARRAY
23117: PUSH
23118: LD_INT 1
23120: ARRAY
23121: PPUSH
23122: LD_VAR 0 14
23126: PUSH
23127: LD_VAR 0 9
23131: ARRAY
23132: PUSH
23133: LD_INT 2
23135: ARRAY
23136: PPUSH
23137: CALL_OW 488
23141: NOT
23142: OR
23143: PUSH
23144: LD_VAR 0 13
23148: PPUSH
23149: CALL_OW 247
23153: PUSH
23154: LD_INT 3
23156: EQUAL
23157: OR
23158: IFFALSE 23164
// exit ;
23160: POP
23161: POP
23162: GO 23708
// if not tmp then
23164: LD_VAR 0 13
23168: NOT
23169: IFFALSE 23173
// continue ;
23171: GO 23029
// result := true ;
23173: LD_ADDR_VAR 0 8
23177: PUSH
23178: LD_INT 1
23180: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23181: LD_VAR 0 6
23185: PUSH
23186: LD_VAR 0 13
23190: PPUSH
23191: CALL_OW 247
23195: PUSH
23196: LD_INT 2
23198: EQUAL
23199: AND
23200: PUSH
23201: LD_VAR 0 13
23205: PPUSH
23206: CALL_OW 263
23210: PUSH
23211: LD_INT 1
23213: EQUAL
23214: AND
23215: IFFALSE 23379
// begin if IsDrivenBy ( tmp ) then
23217: LD_VAR 0 13
23221: PPUSH
23222: CALL_OW 311
23226: IFFALSE 23230
// continue ;
23228: GO 23029
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23230: LD_VAR 0 6
23234: PPUSH
23235: LD_INT 3
23237: PUSH
23238: LD_INT 60
23240: PUSH
23241: EMPTY
23242: LIST
23243: PUSH
23244: EMPTY
23245: LIST
23246: LIST
23247: PUSH
23248: LD_INT 3
23250: PUSH
23251: LD_INT 55
23253: PUSH
23254: EMPTY
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PPUSH
23265: CALL_OW 72
23269: IFFALSE 23377
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23271: LD_ADDR_VAR 0 18
23275: PUSH
23276: LD_VAR 0 6
23280: PPUSH
23281: LD_INT 3
23283: PUSH
23284: LD_INT 60
23286: PUSH
23287: EMPTY
23288: LIST
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 3
23296: PUSH
23297: LD_INT 55
23299: PUSH
23300: EMPTY
23301: LIST
23302: PUSH
23303: EMPTY
23304: LIST
23305: LIST
23306: PUSH
23307: EMPTY
23308: LIST
23309: LIST
23310: PPUSH
23311: CALL_OW 72
23315: PUSH
23316: LD_INT 1
23318: ARRAY
23319: ST_TO_ADDR
// if IsInUnit ( driver ) then
23320: LD_VAR 0 18
23324: PPUSH
23325: CALL_OW 310
23329: IFFALSE 23340
// ComExit ( driver ) ;
23331: LD_VAR 0 18
23335: PPUSH
23336: CALL 48129 0 1
// AddComEnterUnit ( driver , tmp ) ;
23340: LD_VAR 0 18
23344: PPUSH
23345: LD_VAR 0 13
23349: PPUSH
23350: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23354: LD_VAR 0 18
23358: PPUSH
23359: LD_VAR 0 7
23363: PPUSH
23364: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23368: LD_VAR 0 18
23372: PPUSH
23373: CALL_OW 181
// end ; continue ;
23377: GO 23029
// end ; if not cleaners or not tmp in cleaners then
23379: LD_VAR 0 6
23383: NOT
23384: PUSH
23385: LD_VAR 0 13
23389: PUSH
23390: LD_VAR 0 6
23394: IN
23395: NOT
23396: OR
23397: IFFALSE 23704
// begin if dep then
23399: LD_VAR 0 17
23403: IFFALSE 23539
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23405: LD_ADDR_VAR 0 16
23409: PUSH
23410: LD_VAR 0 17
23414: PUSH
23415: LD_INT 1
23417: ARRAY
23418: PPUSH
23419: CALL_OW 250
23423: PPUSH
23424: LD_VAR 0 17
23428: PUSH
23429: LD_INT 1
23431: ARRAY
23432: PPUSH
23433: CALL_OW 254
23437: PPUSH
23438: LD_INT 5
23440: PPUSH
23441: CALL_OW 272
23445: PUSH
23446: LD_VAR 0 17
23450: PUSH
23451: LD_INT 1
23453: ARRAY
23454: PPUSH
23455: CALL_OW 251
23459: PPUSH
23460: LD_VAR 0 17
23464: PUSH
23465: LD_INT 1
23467: ARRAY
23468: PPUSH
23469: CALL_OW 254
23473: PPUSH
23474: LD_INT 5
23476: PPUSH
23477: CALL_OW 273
23481: PUSH
23482: EMPTY
23483: LIST
23484: LIST
23485: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23486: LD_VAR 0 16
23490: PUSH
23491: LD_INT 1
23493: ARRAY
23494: PPUSH
23495: LD_VAR 0 16
23499: PUSH
23500: LD_INT 2
23502: ARRAY
23503: PPUSH
23504: CALL_OW 488
23508: IFFALSE 23539
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23510: LD_VAR 0 13
23514: PPUSH
23515: LD_VAR 0 16
23519: PUSH
23520: LD_INT 1
23522: ARRAY
23523: PPUSH
23524: LD_VAR 0 16
23528: PUSH
23529: LD_INT 2
23531: ARRAY
23532: PPUSH
23533: CALL_OW 111
// continue ;
23537: GO 23029
// end ; end ; r := GetDir ( tmp ) ;
23539: LD_ADDR_VAR 0 15
23543: PUSH
23544: LD_VAR 0 13
23548: PPUSH
23549: CALL_OW 254
23553: ST_TO_ADDR
// if r = 5 then
23554: LD_VAR 0 15
23558: PUSH
23559: LD_INT 5
23561: EQUAL
23562: IFFALSE 23572
// r := 0 ;
23564: LD_ADDR_VAR 0 15
23568: PUSH
23569: LD_INT 0
23571: ST_TO_ADDR
// for j = r to 5 do
23572: LD_ADDR_VAR 0 10
23576: PUSH
23577: DOUBLE
23578: LD_VAR 0 15
23582: DEC
23583: ST_TO_ADDR
23584: LD_INT 5
23586: PUSH
23587: FOR_TO
23588: IFFALSE 23702
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23590: LD_ADDR_VAR 0 11
23594: PUSH
23595: LD_VAR 0 13
23599: PPUSH
23600: CALL_OW 250
23604: PPUSH
23605: LD_VAR 0 10
23609: PPUSH
23610: LD_INT 2
23612: PPUSH
23613: CALL_OW 272
23617: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23618: LD_ADDR_VAR 0 12
23622: PUSH
23623: LD_VAR 0 13
23627: PPUSH
23628: CALL_OW 251
23632: PPUSH
23633: LD_VAR 0 10
23637: PPUSH
23638: LD_INT 2
23640: PPUSH
23641: CALL_OW 273
23645: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23646: LD_VAR 0 11
23650: PPUSH
23651: LD_VAR 0 12
23655: PPUSH
23656: CALL_OW 488
23660: PUSH
23661: LD_VAR 0 11
23665: PPUSH
23666: LD_VAR 0 12
23670: PPUSH
23671: CALL_OW 428
23675: NOT
23676: AND
23677: IFFALSE 23700
// begin ComMoveXY ( tmp , _x , _y ) ;
23679: LD_VAR 0 13
23683: PPUSH
23684: LD_VAR 0 11
23688: PPUSH
23689: LD_VAR 0 12
23693: PPUSH
23694: CALL_OW 111
// break ;
23698: GO 23702
// end ; end ;
23700: GO 23587
23702: POP
23703: POP
// end ; end ;
23704: GO 23029
23706: POP
23707: POP
// end ;
23708: LD_VAR 0 8
23712: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23713: LD_INT 0
23715: PPUSH
// result := true ;
23716: LD_ADDR_VAR 0 3
23720: PUSH
23721: LD_INT 1
23723: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23724: LD_VAR 0 2
23728: PUSH
23729: LD_INT 24
23731: DOUBLE
23732: EQUAL
23733: IFTRUE 23743
23735: LD_INT 33
23737: DOUBLE
23738: EQUAL
23739: IFTRUE 23743
23741: GO 23768
23743: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23744: LD_ADDR_VAR 0 3
23748: PUSH
23749: LD_INT 32
23751: PPUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 321
23761: PUSH
23762: LD_INT 2
23764: EQUAL
23765: ST_TO_ADDR
23766: GO 24088
23768: LD_INT 20
23770: DOUBLE
23771: EQUAL
23772: IFTRUE 23776
23774: GO 23801
23776: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23777: LD_ADDR_VAR 0 3
23781: PUSH
23782: LD_INT 6
23784: PPUSH
23785: LD_VAR 0 1
23789: PPUSH
23790: CALL_OW 321
23794: PUSH
23795: LD_INT 2
23797: EQUAL
23798: ST_TO_ADDR
23799: GO 24088
23801: LD_INT 22
23803: DOUBLE
23804: EQUAL
23805: IFTRUE 23815
23807: LD_INT 36
23809: DOUBLE
23810: EQUAL
23811: IFTRUE 23815
23813: GO 23840
23815: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23816: LD_ADDR_VAR 0 3
23820: PUSH
23821: LD_INT 15
23823: PPUSH
23824: LD_VAR 0 1
23828: PPUSH
23829: CALL_OW 321
23833: PUSH
23834: LD_INT 2
23836: EQUAL
23837: ST_TO_ADDR
23838: GO 24088
23840: LD_INT 30
23842: DOUBLE
23843: EQUAL
23844: IFTRUE 23848
23846: GO 23873
23848: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23849: LD_ADDR_VAR 0 3
23853: PUSH
23854: LD_INT 20
23856: PPUSH
23857: LD_VAR 0 1
23861: PPUSH
23862: CALL_OW 321
23866: PUSH
23867: LD_INT 2
23869: EQUAL
23870: ST_TO_ADDR
23871: GO 24088
23873: LD_INT 28
23875: DOUBLE
23876: EQUAL
23877: IFTRUE 23887
23879: LD_INT 21
23881: DOUBLE
23882: EQUAL
23883: IFTRUE 23887
23885: GO 23912
23887: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
23888: LD_ADDR_VAR 0 3
23892: PUSH
23893: LD_INT 21
23895: PPUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: CALL_OW 321
23905: PUSH
23906: LD_INT 2
23908: EQUAL
23909: ST_TO_ADDR
23910: GO 24088
23912: LD_INT 16
23914: DOUBLE
23915: EQUAL
23916: IFTRUE 23920
23918: GO 23947
23920: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
23921: LD_ADDR_VAR 0 3
23925: PUSH
23926: LD_EXP 79
23930: PPUSH
23931: LD_VAR 0 1
23935: PPUSH
23936: CALL_OW 321
23940: PUSH
23941: LD_INT 2
23943: EQUAL
23944: ST_TO_ADDR
23945: GO 24088
23947: LD_INT 19
23949: DOUBLE
23950: EQUAL
23951: IFTRUE 23961
23953: LD_INT 23
23955: DOUBLE
23956: EQUAL
23957: IFTRUE 23961
23959: GO 23988
23961: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
23962: LD_ADDR_VAR 0 3
23966: PUSH
23967: LD_EXP 78
23971: PPUSH
23972: LD_VAR 0 1
23976: PPUSH
23977: CALL_OW 321
23981: PUSH
23982: LD_INT 2
23984: EQUAL
23985: ST_TO_ADDR
23986: GO 24088
23988: LD_INT 17
23990: DOUBLE
23991: EQUAL
23992: IFTRUE 23996
23994: GO 24021
23996: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
23997: LD_ADDR_VAR 0 3
24001: PUSH
24002: LD_INT 39
24004: PPUSH
24005: LD_VAR 0 1
24009: PPUSH
24010: CALL_OW 321
24014: PUSH
24015: LD_INT 2
24017: EQUAL
24018: ST_TO_ADDR
24019: GO 24088
24021: LD_INT 18
24023: DOUBLE
24024: EQUAL
24025: IFTRUE 24029
24027: GO 24054
24029: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24030: LD_ADDR_VAR 0 3
24034: PUSH
24035: LD_INT 40
24037: PPUSH
24038: LD_VAR 0 1
24042: PPUSH
24043: CALL_OW 321
24047: PUSH
24048: LD_INT 2
24050: EQUAL
24051: ST_TO_ADDR
24052: GO 24088
24054: LD_INT 27
24056: DOUBLE
24057: EQUAL
24058: IFTRUE 24062
24060: GO 24087
24062: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24063: LD_ADDR_VAR 0 3
24067: PUSH
24068: LD_INT 35
24070: PPUSH
24071: LD_VAR 0 1
24075: PPUSH
24076: CALL_OW 321
24080: PUSH
24081: LD_INT 2
24083: EQUAL
24084: ST_TO_ADDR
24085: GO 24088
24087: POP
// end ;
24088: LD_VAR 0 3
24092: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24093: LD_INT 0
24095: PPUSH
24096: PPUSH
24097: PPUSH
24098: PPUSH
24099: PPUSH
24100: PPUSH
24101: PPUSH
24102: PPUSH
24103: PPUSH
24104: PPUSH
24105: PPUSH
// result := false ;
24106: LD_ADDR_VAR 0 6
24110: PUSH
24111: LD_INT 0
24113: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24114: LD_VAR 0 1
24118: NOT
24119: PUSH
24120: LD_VAR 0 1
24124: PPUSH
24125: CALL_OW 266
24129: PUSH
24130: LD_INT 0
24132: PUSH
24133: LD_INT 1
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: IN
24140: NOT
24141: OR
24142: PUSH
24143: LD_VAR 0 2
24147: NOT
24148: OR
24149: PUSH
24150: LD_VAR 0 5
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: LD_INT 1
24160: PUSH
24161: LD_INT 2
24163: PUSH
24164: LD_INT 3
24166: PUSH
24167: LD_INT 4
24169: PUSH
24170: LD_INT 5
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: IN
24181: NOT
24182: OR
24183: PUSH
24184: LD_VAR 0 3
24188: PPUSH
24189: LD_VAR 0 4
24193: PPUSH
24194: CALL_OW 488
24198: NOT
24199: OR
24200: IFFALSE 24204
// exit ;
24202: GO 24940
// side := GetSide ( depot ) ;
24204: LD_ADDR_VAR 0 9
24208: PUSH
24209: LD_VAR 0 1
24213: PPUSH
24214: CALL_OW 255
24218: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24219: LD_VAR 0 9
24223: PPUSH
24224: LD_VAR 0 2
24228: PPUSH
24229: CALL 23713 0 2
24233: NOT
24234: IFFALSE 24238
// exit ;
24236: GO 24940
// pom := GetBase ( depot ) ;
24238: LD_ADDR_VAR 0 10
24242: PUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: CALL_OW 274
24252: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24253: LD_ADDR_VAR 0 11
24257: PUSH
24258: LD_VAR 0 2
24262: PPUSH
24263: LD_VAR 0 1
24267: PPUSH
24268: CALL_OW 248
24272: PPUSH
24273: CALL_OW 450
24277: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24278: LD_VAR 0 10
24282: PPUSH
24283: LD_INT 1
24285: PPUSH
24286: CALL_OW 275
24290: PUSH
24291: LD_VAR 0 11
24295: PUSH
24296: LD_INT 1
24298: ARRAY
24299: GREATEREQUAL
24300: PUSH
24301: LD_VAR 0 10
24305: PPUSH
24306: LD_INT 2
24308: PPUSH
24309: CALL_OW 275
24313: PUSH
24314: LD_VAR 0 11
24318: PUSH
24319: LD_INT 2
24321: ARRAY
24322: GREATEREQUAL
24323: AND
24324: PUSH
24325: LD_VAR 0 10
24329: PPUSH
24330: LD_INT 3
24332: PPUSH
24333: CALL_OW 275
24337: PUSH
24338: LD_VAR 0 11
24342: PUSH
24343: LD_INT 3
24345: ARRAY
24346: GREATEREQUAL
24347: AND
24348: NOT
24349: IFFALSE 24353
// exit ;
24351: GO 24940
// if GetBType ( depot ) = b_depot then
24353: LD_VAR 0 1
24357: PPUSH
24358: CALL_OW 266
24362: PUSH
24363: LD_INT 0
24365: EQUAL
24366: IFFALSE 24378
// dist := 28 else
24368: LD_ADDR_VAR 0 14
24372: PUSH
24373: LD_INT 28
24375: ST_TO_ADDR
24376: GO 24386
// dist := 36 ;
24378: LD_ADDR_VAR 0 14
24382: PUSH
24383: LD_INT 36
24385: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24386: LD_VAR 0 1
24390: PPUSH
24391: LD_VAR 0 3
24395: PPUSH
24396: LD_VAR 0 4
24400: PPUSH
24401: CALL_OW 297
24405: PUSH
24406: LD_VAR 0 14
24410: GREATER
24411: IFFALSE 24415
// exit ;
24413: GO 24940
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24415: LD_ADDR_VAR 0 12
24419: PUSH
24420: LD_VAR 0 2
24424: PPUSH
24425: LD_VAR 0 3
24429: PPUSH
24430: LD_VAR 0 4
24434: PPUSH
24435: LD_VAR 0 5
24439: PPUSH
24440: LD_VAR 0 1
24444: PPUSH
24445: CALL_OW 248
24449: PPUSH
24450: LD_INT 0
24452: PPUSH
24453: CALL 24945 0 6
24457: ST_TO_ADDR
// if not hexes then
24458: LD_VAR 0 12
24462: NOT
24463: IFFALSE 24467
// exit ;
24465: GO 24940
// hex := GetHexInfo ( x , y ) ;
24467: LD_ADDR_VAR 0 15
24471: PUSH
24472: LD_VAR 0 3
24476: PPUSH
24477: LD_VAR 0 4
24481: PPUSH
24482: CALL_OW 546
24486: ST_TO_ADDR
// if hex [ 1 ] then
24487: LD_VAR 0 15
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: IFFALSE 24499
// exit ;
24497: GO 24940
// height := hex [ 2 ] ;
24499: LD_ADDR_VAR 0 13
24503: PUSH
24504: LD_VAR 0 15
24508: PUSH
24509: LD_INT 2
24511: ARRAY
24512: ST_TO_ADDR
// for i = 1 to hexes do
24513: LD_ADDR_VAR 0 7
24517: PUSH
24518: DOUBLE
24519: LD_INT 1
24521: DEC
24522: ST_TO_ADDR
24523: LD_VAR 0 12
24527: PUSH
24528: FOR_TO
24529: IFFALSE 24859
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24531: LD_VAR 0 12
24535: PUSH
24536: LD_VAR 0 7
24540: ARRAY
24541: PUSH
24542: LD_INT 1
24544: ARRAY
24545: PPUSH
24546: LD_VAR 0 12
24550: PUSH
24551: LD_VAR 0 7
24555: ARRAY
24556: PUSH
24557: LD_INT 2
24559: ARRAY
24560: PPUSH
24561: CALL_OW 488
24565: NOT
24566: PUSH
24567: LD_VAR 0 12
24571: PUSH
24572: LD_VAR 0 7
24576: ARRAY
24577: PUSH
24578: LD_INT 1
24580: ARRAY
24581: PPUSH
24582: LD_VAR 0 12
24586: PUSH
24587: LD_VAR 0 7
24591: ARRAY
24592: PUSH
24593: LD_INT 2
24595: ARRAY
24596: PPUSH
24597: CALL_OW 428
24601: PUSH
24602: LD_INT 0
24604: GREATER
24605: OR
24606: PUSH
24607: LD_VAR 0 12
24611: PUSH
24612: LD_VAR 0 7
24616: ARRAY
24617: PUSH
24618: LD_INT 1
24620: ARRAY
24621: PPUSH
24622: LD_VAR 0 12
24626: PUSH
24627: LD_VAR 0 7
24631: ARRAY
24632: PUSH
24633: LD_INT 2
24635: ARRAY
24636: PPUSH
24637: CALL_OW 351
24641: OR
24642: IFFALSE 24648
// exit ;
24644: POP
24645: POP
24646: GO 24940
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24648: LD_ADDR_VAR 0 8
24652: PUSH
24653: LD_VAR 0 12
24657: PUSH
24658: LD_VAR 0 7
24662: ARRAY
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PPUSH
24668: LD_VAR 0 12
24672: PUSH
24673: LD_VAR 0 7
24677: ARRAY
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PPUSH
24683: CALL_OW 546
24687: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24688: LD_VAR 0 8
24692: PUSH
24693: LD_INT 1
24695: ARRAY
24696: PUSH
24697: LD_VAR 0 8
24701: PUSH
24702: LD_INT 2
24704: ARRAY
24705: PUSH
24706: LD_VAR 0 13
24710: PUSH
24711: LD_INT 2
24713: PLUS
24714: GREATER
24715: OR
24716: PUSH
24717: LD_VAR 0 8
24721: PUSH
24722: LD_INT 2
24724: ARRAY
24725: PUSH
24726: LD_VAR 0 13
24730: PUSH
24731: LD_INT 2
24733: MINUS
24734: LESS
24735: OR
24736: PUSH
24737: LD_VAR 0 8
24741: PUSH
24742: LD_INT 3
24744: ARRAY
24745: PUSH
24746: LD_INT 0
24748: PUSH
24749: LD_INT 8
24751: PUSH
24752: LD_INT 9
24754: PUSH
24755: LD_INT 10
24757: PUSH
24758: LD_INT 11
24760: PUSH
24761: LD_INT 12
24763: PUSH
24764: LD_INT 13
24766: PUSH
24767: LD_INT 16
24769: PUSH
24770: LD_INT 17
24772: PUSH
24773: LD_INT 18
24775: PUSH
24776: LD_INT 19
24778: PUSH
24779: LD_INT 20
24781: PUSH
24782: LD_INT 21
24784: PUSH
24785: EMPTY
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: LIST
24796: LIST
24797: LIST
24798: LIST
24799: IN
24800: NOT
24801: OR
24802: PUSH
24803: LD_VAR 0 8
24807: PUSH
24808: LD_INT 5
24810: ARRAY
24811: NOT
24812: OR
24813: PUSH
24814: LD_VAR 0 8
24818: PUSH
24819: LD_INT 6
24821: ARRAY
24822: PUSH
24823: LD_INT 1
24825: PUSH
24826: LD_INT 2
24828: PUSH
24829: LD_INT 7
24831: PUSH
24832: LD_INT 9
24834: PUSH
24835: LD_INT 10
24837: PUSH
24838: LD_INT 11
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: LIST
24845: LIST
24846: LIST
24847: LIST
24848: IN
24849: NOT
24850: OR
24851: IFFALSE 24857
// exit ;
24853: POP
24854: POP
24855: GO 24940
// end ;
24857: GO 24528
24859: POP
24860: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24861: LD_VAR 0 9
24865: PPUSH
24866: LD_VAR 0 3
24870: PPUSH
24871: LD_VAR 0 4
24875: PPUSH
24876: LD_INT 20
24878: PPUSH
24879: CALL 16886 0 4
24883: PUSH
24884: LD_INT 4
24886: ARRAY
24887: IFFALSE 24891
// exit ;
24889: GO 24940
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
24891: LD_VAR 0 2
24895: PUSH
24896: LD_INT 29
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: IN
24906: PUSH
24907: LD_VAR 0 3
24911: PPUSH
24912: LD_VAR 0 4
24916: PPUSH
24917: LD_VAR 0 9
24921: PPUSH
24922: CALL_OW 440
24926: NOT
24927: AND
24928: IFFALSE 24932
// exit ;
24930: GO 24940
// result := true ;
24932: LD_ADDR_VAR 0 6
24936: PUSH
24937: LD_INT 1
24939: ST_TO_ADDR
// end ;
24940: LD_VAR 0 6
24944: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
24945: LD_INT 0
24947: PPUSH
24948: PPUSH
24949: PPUSH
24950: PPUSH
24951: PPUSH
24952: PPUSH
24953: PPUSH
24954: PPUSH
24955: PPUSH
24956: PPUSH
24957: PPUSH
24958: PPUSH
24959: PPUSH
24960: PPUSH
24961: PPUSH
24962: PPUSH
24963: PPUSH
24964: PPUSH
24965: PPUSH
24966: PPUSH
24967: PPUSH
24968: PPUSH
24969: PPUSH
24970: PPUSH
24971: PPUSH
24972: PPUSH
24973: PPUSH
24974: PPUSH
24975: PPUSH
24976: PPUSH
24977: PPUSH
24978: PPUSH
24979: PPUSH
24980: PPUSH
24981: PPUSH
24982: PPUSH
24983: PPUSH
24984: PPUSH
24985: PPUSH
24986: PPUSH
24987: PPUSH
24988: PPUSH
24989: PPUSH
24990: PPUSH
24991: PPUSH
24992: PPUSH
24993: PPUSH
24994: PPUSH
24995: PPUSH
24996: PPUSH
24997: PPUSH
24998: PPUSH
24999: PPUSH
25000: PPUSH
25001: PPUSH
25002: PPUSH
25003: PPUSH
25004: PPUSH
// result = [ ] ;
25005: LD_ADDR_VAR 0 7
25009: PUSH
25010: EMPTY
25011: ST_TO_ADDR
// temp_list = [ ] ;
25012: LD_ADDR_VAR 0 9
25016: PUSH
25017: EMPTY
25018: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25019: LD_VAR 0 4
25023: PUSH
25024: LD_INT 0
25026: PUSH
25027: LD_INT 1
25029: PUSH
25030: LD_INT 2
25032: PUSH
25033: LD_INT 3
25035: PUSH
25036: LD_INT 4
25038: PUSH
25039: LD_INT 5
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: IN
25050: NOT
25051: PUSH
25052: LD_VAR 0 1
25056: PUSH
25057: LD_INT 0
25059: PUSH
25060: LD_INT 1
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: IN
25067: PUSH
25068: LD_VAR 0 5
25072: PUSH
25073: LD_INT 1
25075: PUSH
25076: LD_INT 2
25078: PUSH
25079: LD_INT 3
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: LIST
25086: IN
25087: NOT
25088: AND
25089: OR
25090: IFFALSE 25094
// exit ;
25092: GO 43485
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25094: LD_VAR 0 1
25098: PUSH
25099: LD_INT 6
25101: PUSH
25102: LD_INT 7
25104: PUSH
25105: LD_INT 8
25107: PUSH
25108: LD_INT 13
25110: PUSH
25111: LD_INT 12
25113: PUSH
25114: LD_INT 15
25116: PUSH
25117: LD_INT 11
25119: PUSH
25120: LD_INT 14
25122: PUSH
25123: LD_INT 10
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: LIST
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: LIST
25136: IN
25137: IFFALSE 25147
// btype = b_lab ;
25139: LD_ADDR_VAR 0 1
25143: PUSH
25144: LD_INT 6
25146: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25147: LD_VAR 0 6
25151: PUSH
25152: LD_INT 0
25154: PUSH
25155: LD_INT 1
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: LIST
25165: IN
25166: NOT
25167: PUSH
25168: LD_VAR 0 1
25172: PUSH
25173: LD_INT 0
25175: PUSH
25176: LD_INT 1
25178: PUSH
25179: LD_INT 2
25181: PUSH
25182: LD_INT 3
25184: PUSH
25185: LD_INT 6
25187: PUSH
25188: LD_INT 36
25190: PUSH
25191: LD_INT 4
25193: PUSH
25194: LD_INT 5
25196: PUSH
25197: LD_INT 31
25199: PUSH
25200: LD_INT 32
25202: PUSH
25203: LD_INT 33
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: LIST
25217: LIST
25218: IN
25219: NOT
25220: PUSH
25221: LD_VAR 0 6
25225: PUSH
25226: LD_INT 1
25228: EQUAL
25229: AND
25230: OR
25231: PUSH
25232: LD_VAR 0 1
25236: PUSH
25237: LD_INT 2
25239: PUSH
25240: LD_INT 3
25242: PUSH
25243: EMPTY
25244: LIST
25245: LIST
25246: IN
25247: NOT
25248: PUSH
25249: LD_VAR 0 6
25253: PUSH
25254: LD_INT 2
25256: EQUAL
25257: AND
25258: OR
25259: IFFALSE 25269
// mode = 0 ;
25261: LD_ADDR_VAR 0 6
25265: PUSH
25266: LD_INT 0
25268: ST_TO_ADDR
// case mode of 0 :
25269: LD_VAR 0 6
25273: PUSH
25274: LD_INT 0
25276: DOUBLE
25277: EQUAL
25278: IFTRUE 25282
25280: GO 36735
25282: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25283: LD_ADDR_VAR 0 11
25287: PUSH
25288: LD_INT 0
25290: PUSH
25291: LD_INT 0
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: PUSH
25298: LD_INT 0
25300: PUSH
25301: LD_INT 1
25303: NEG
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PUSH
25309: LD_INT 1
25311: PUSH
25312: LD_INT 0
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 1
25321: PUSH
25322: LD_INT 1
25324: PUSH
25325: EMPTY
25326: LIST
25327: LIST
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: LD_INT 1
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 1
25341: NEG
25342: PUSH
25343: LD_INT 0
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 1
25352: NEG
25353: PUSH
25354: LD_INT 1
25356: NEG
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: LD_INT 1
25364: NEG
25365: PUSH
25366: LD_INT 2
25368: NEG
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PUSH
25374: LD_INT 0
25376: PUSH
25377: LD_INT 2
25379: NEG
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 1
25387: PUSH
25388: LD_INT 1
25390: NEG
25391: PUSH
25392: EMPTY
25393: LIST
25394: LIST
25395: PUSH
25396: LD_INT 1
25398: PUSH
25399: LD_INT 2
25401: PUSH
25402: EMPTY
25403: LIST
25404: LIST
25405: PUSH
25406: LD_INT 0
25408: PUSH
25409: LD_INT 2
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: LD_INT 1
25418: NEG
25419: PUSH
25420: LD_INT 1
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 1
25429: PUSH
25430: LD_INT 3
25432: PUSH
25433: EMPTY
25434: LIST
25435: LIST
25436: PUSH
25437: LD_INT 0
25439: PUSH
25440: LD_INT 3
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: LD_INT 1
25449: NEG
25450: PUSH
25451: LD_INT 2
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25476: LD_ADDR_VAR 0 12
25480: PUSH
25481: LD_INT 0
25483: PUSH
25484: LD_INT 0
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 0
25493: PUSH
25494: LD_INT 1
25496: NEG
25497: PUSH
25498: EMPTY
25499: LIST
25500: LIST
25501: PUSH
25502: LD_INT 1
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: PUSH
25512: LD_INT 1
25514: PUSH
25515: LD_INT 1
25517: PUSH
25518: EMPTY
25519: LIST
25520: LIST
25521: PUSH
25522: LD_INT 0
25524: PUSH
25525: LD_INT 1
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: PUSH
25532: LD_INT 1
25534: NEG
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: LD_INT 1
25545: NEG
25546: PUSH
25547: LD_INT 1
25549: NEG
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: PUSH
25555: LD_INT 1
25557: PUSH
25558: LD_INT 1
25560: NEG
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 2
25568: PUSH
25569: LD_INT 0
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 2
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 1
25588: NEG
25589: PUSH
25590: LD_INT 1
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 2
25599: NEG
25600: PUSH
25601: LD_INT 0
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 2
25610: NEG
25611: PUSH
25612: LD_INT 1
25614: NEG
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 2
25622: NEG
25623: PUSH
25624: LD_INT 1
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 3
25633: NEG
25634: PUSH
25635: LD_INT 0
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 3
25644: NEG
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25672: LD_ADDR_VAR 0 13
25676: PUSH
25677: LD_INT 0
25679: PUSH
25680: LD_INT 0
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: LD_INT 0
25689: PUSH
25690: LD_INT 1
25692: NEG
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 1
25700: PUSH
25701: LD_INT 0
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 1
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: LD_INT 0
25720: PUSH
25721: LD_INT 1
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PUSH
25728: LD_INT 1
25730: NEG
25731: PUSH
25732: LD_INT 0
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: LD_INT 1
25741: NEG
25742: PUSH
25743: LD_INT 1
25745: NEG
25746: PUSH
25747: EMPTY
25748: LIST
25749: LIST
25750: PUSH
25751: LD_INT 1
25753: NEG
25754: PUSH
25755: LD_INT 2
25757: NEG
25758: PUSH
25759: EMPTY
25760: LIST
25761: LIST
25762: PUSH
25763: LD_INT 2
25765: PUSH
25766: LD_INT 1
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 2
25775: PUSH
25776: LD_INT 2
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: LD_INT 1
25785: PUSH
25786: LD_INT 2
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 2
25795: NEG
25796: PUSH
25797: LD_INT 1
25799: NEG
25800: PUSH
25801: EMPTY
25802: LIST
25803: LIST
25804: PUSH
25805: LD_INT 2
25807: NEG
25808: PUSH
25809: LD_INT 2
25811: NEG
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 2
25819: NEG
25820: PUSH
25821: LD_INT 3
25823: NEG
25824: PUSH
25825: EMPTY
25826: LIST
25827: LIST
25828: PUSH
25829: LD_INT 3
25831: NEG
25832: PUSH
25833: LD_INT 2
25835: NEG
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: PUSH
25841: LD_INT 3
25843: NEG
25844: PUSH
25845: LD_INT 3
25847: NEG
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: LIST
25857: LIST
25858: LIST
25859: LIST
25860: LIST
25861: LIST
25862: LIST
25863: LIST
25864: LIST
25865: LIST
25866: LIST
25867: LIST
25868: LIST
25869: LIST
25870: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25871: LD_ADDR_VAR 0 14
25875: PUSH
25876: LD_INT 0
25878: PUSH
25879: LD_INT 0
25881: PUSH
25882: EMPTY
25883: LIST
25884: LIST
25885: PUSH
25886: LD_INT 0
25888: PUSH
25889: LD_INT 1
25891: NEG
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: LD_INT 0
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 1
25909: PUSH
25910: LD_INT 1
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 0
25919: PUSH
25920: LD_INT 1
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: PUSH
25927: LD_INT 1
25929: NEG
25930: PUSH
25931: LD_INT 0
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_INT 1
25940: NEG
25941: PUSH
25942: LD_INT 1
25944: NEG
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: LD_INT 1
25952: NEG
25953: PUSH
25954: LD_INT 2
25956: NEG
25957: PUSH
25958: EMPTY
25959: LIST
25960: LIST
25961: PUSH
25962: LD_INT 0
25964: PUSH
25965: LD_INT 2
25967: NEG
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: LD_INT 1
25975: PUSH
25976: LD_INT 1
25978: NEG
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 1
25986: PUSH
25987: LD_INT 2
25989: PUSH
25990: EMPTY
25991: LIST
25992: LIST
25993: PUSH
25994: LD_INT 0
25996: PUSH
25997: LD_INT 2
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 1
26006: NEG
26007: PUSH
26008: LD_INT 1
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: LD_INT 1
26017: NEG
26018: PUSH
26019: LD_INT 3
26021: NEG
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PUSH
26027: LD_INT 0
26029: PUSH
26030: LD_INT 3
26032: NEG
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 1
26040: PUSH
26041: LD_INT 2
26043: NEG
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: LIST
26053: LIST
26054: LIST
26055: LIST
26056: LIST
26057: LIST
26058: LIST
26059: LIST
26060: LIST
26061: LIST
26062: LIST
26063: LIST
26064: LIST
26065: LIST
26066: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26067: LD_ADDR_VAR 0 15
26071: PUSH
26072: LD_INT 0
26074: PUSH
26075: LD_INT 0
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 0
26084: PUSH
26085: LD_INT 1
26087: NEG
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 1
26095: PUSH
26096: LD_INT 0
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 1
26105: PUSH
26106: LD_INT 1
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: LD_INT 1
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 1
26125: NEG
26126: PUSH
26127: LD_INT 0
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: PUSH
26134: LD_INT 1
26136: NEG
26137: PUSH
26138: LD_INT 1
26140: NEG
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: LD_INT 1
26148: PUSH
26149: LD_INT 1
26151: NEG
26152: PUSH
26153: EMPTY
26154: LIST
26155: LIST
26156: PUSH
26157: LD_INT 2
26159: PUSH
26160: LD_INT 0
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: PUSH
26167: LD_INT 2
26169: PUSH
26170: LD_INT 1
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: LD_INT 1
26179: NEG
26180: PUSH
26181: LD_INT 1
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 2
26190: NEG
26191: PUSH
26192: LD_INT 0
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: LD_INT 2
26201: NEG
26202: PUSH
26203: LD_INT 1
26205: NEG
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: LD_INT 2
26213: PUSH
26214: LD_INT 1
26216: NEG
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 3
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 3
26234: PUSH
26235: LD_INT 1
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: LIST
26253: LIST
26254: LIST
26255: LIST
26256: LIST
26257: LIST
26258: LIST
26259: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26260: LD_ADDR_VAR 0 16
26264: PUSH
26265: LD_INT 0
26267: PUSH
26268: LD_INT 0
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 0
26277: PUSH
26278: LD_INT 1
26280: NEG
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 1
26288: PUSH
26289: LD_INT 0
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PUSH
26296: LD_INT 1
26298: PUSH
26299: LD_INT 1
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 0
26308: PUSH
26309: LD_INT 1
26311: PUSH
26312: EMPTY
26313: LIST
26314: LIST
26315: PUSH
26316: LD_INT 1
26318: NEG
26319: PUSH
26320: LD_INT 0
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: LD_INT 1
26329: NEG
26330: PUSH
26331: LD_INT 1
26333: NEG
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 1
26341: NEG
26342: PUSH
26343: LD_INT 2
26345: NEG
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PUSH
26351: LD_INT 2
26353: PUSH
26354: LD_INT 1
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PUSH
26361: LD_INT 2
26363: PUSH
26364: LD_INT 2
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PUSH
26371: LD_INT 1
26373: PUSH
26374: LD_INT 2
26376: PUSH
26377: EMPTY
26378: LIST
26379: LIST
26380: PUSH
26381: LD_INT 2
26383: NEG
26384: PUSH
26385: LD_INT 1
26387: NEG
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 2
26395: NEG
26396: PUSH
26397: LD_INT 2
26399: NEG
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 3
26407: PUSH
26408: LD_INT 2
26410: PUSH
26411: EMPTY
26412: LIST
26413: LIST
26414: PUSH
26415: LD_INT 3
26417: PUSH
26418: LD_INT 3
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 2
26427: PUSH
26428: LD_INT 3
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: LIST
26450: LIST
26451: LIST
26452: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26453: LD_ADDR_VAR 0 17
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: LD_INT 0
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: LD_INT 0
26470: PUSH
26471: LD_INT 1
26473: NEG
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 1
26481: PUSH
26482: LD_INT 0
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PUSH
26489: LD_INT 1
26491: PUSH
26492: LD_INT 1
26494: PUSH
26495: EMPTY
26496: LIST
26497: LIST
26498: PUSH
26499: LD_INT 0
26501: PUSH
26502: LD_INT 1
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 1
26511: NEG
26512: PUSH
26513: LD_INT 0
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: LD_INT 1
26522: NEG
26523: PUSH
26524: LD_INT 1
26526: NEG
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PUSH
26532: LD_INT 1
26534: NEG
26535: PUSH
26536: LD_INT 2
26538: NEG
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: LD_INT 0
26546: PUSH
26547: LD_INT 2
26549: NEG
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 1
26557: PUSH
26558: LD_INT 1
26560: NEG
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 2
26568: PUSH
26569: LD_INT 0
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: LD_INT 2
26578: PUSH
26579: LD_INT 1
26581: PUSH
26582: EMPTY
26583: LIST
26584: LIST
26585: PUSH
26586: LD_INT 2
26588: PUSH
26589: LD_INT 2
26591: PUSH
26592: EMPTY
26593: LIST
26594: LIST
26595: PUSH
26596: LD_INT 1
26598: PUSH
26599: LD_INT 2
26601: PUSH
26602: EMPTY
26603: LIST
26604: LIST
26605: PUSH
26606: LD_INT 0
26608: PUSH
26609: LD_INT 2
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: PUSH
26616: LD_INT 1
26618: NEG
26619: PUSH
26620: LD_INT 1
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 2
26629: NEG
26630: PUSH
26631: LD_INT 0
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 2
26640: NEG
26641: PUSH
26642: LD_INT 1
26644: NEG
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 2
26652: NEG
26653: PUSH
26654: LD_INT 2
26656: NEG
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26683: LD_ADDR_VAR 0 18
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: LD_INT 0
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 0
26700: PUSH
26701: LD_INT 1
26703: NEG
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: LD_INT 0
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: LD_INT 1
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: PUSH
26729: LD_INT 0
26731: PUSH
26732: LD_INT 1
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PUSH
26739: LD_INT 1
26741: NEG
26742: PUSH
26743: LD_INT 0
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PUSH
26750: LD_INT 1
26752: NEG
26753: PUSH
26754: LD_INT 1
26756: NEG
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 1
26764: NEG
26765: PUSH
26766: LD_INT 2
26768: NEG
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 0
26776: PUSH
26777: LD_INT 2
26779: NEG
26780: PUSH
26781: EMPTY
26782: LIST
26783: LIST
26784: PUSH
26785: LD_INT 1
26787: PUSH
26788: LD_INT 1
26790: NEG
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: LD_INT 2
26798: PUSH
26799: LD_INT 0
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 2
26808: PUSH
26809: LD_INT 1
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 2
26818: PUSH
26819: LD_INT 2
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 1
26828: PUSH
26829: LD_INT 2
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 2
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: PUSH
26846: LD_INT 1
26848: NEG
26849: PUSH
26850: LD_INT 1
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 2
26859: NEG
26860: PUSH
26861: LD_INT 0
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 2
26870: NEG
26871: PUSH
26872: LD_INT 1
26874: NEG
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 2
26882: NEG
26883: PUSH
26884: LD_INT 2
26886: NEG
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: LIST
26896: LIST
26897: LIST
26898: LIST
26899: LIST
26900: LIST
26901: LIST
26902: LIST
26903: LIST
26904: LIST
26905: LIST
26906: LIST
26907: LIST
26908: LIST
26909: LIST
26910: LIST
26911: LIST
26912: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26913: LD_ADDR_VAR 0 19
26917: PUSH
26918: LD_INT 0
26920: PUSH
26921: LD_INT 0
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PUSH
26928: LD_INT 0
26930: PUSH
26931: LD_INT 1
26933: NEG
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 1
26941: PUSH
26942: LD_INT 0
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 1
26951: PUSH
26952: LD_INT 1
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 0
26961: PUSH
26962: LD_INT 1
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PUSH
26969: LD_INT 1
26971: NEG
26972: PUSH
26973: LD_INT 0
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PUSH
26980: LD_INT 1
26982: NEG
26983: PUSH
26984: LD_INT 1
26986: NEG
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 1
26994: NEG
26995: PUSH
26996: LD_INT 2
26998: NEG
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: PUSH
27004: LD_INT 0
27006: PUSH
27007: LD_INT 2
27009: NEG
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: LD_INT 1
27017: PUSH
27018: LD_INT 1
27020: NEG
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: PUSH
27026: LD_INT 2
27028: PUSH
27029: LD_INT 0
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 2
27038: PUSH
27039: LD_INT 1
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 2
27048: PUSH
27049: LD_INT 2
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: PUSH
27056: LD_INT 1
27058: PUSH
27059: LD_INT 2
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: LD_INT 0
27068: PUSH
27069: LD_INT 2
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 1
27078: NEG
27079: PUSH
27080: LD_INT 1
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 2
27089: NEG
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: LD_INT 2
27100: NEG
27101: PUSH
27102: LD_INT 1
27104: NEG
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 2
27112: NEG
27113: PUSH
27114: LD_INT 2
27116: NEG
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: LIST
27130: LIST
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: LIST
27136: LIST
27137: LIST
27138: LIST
27139: LIST
27140: LIST
27141: LIST
27142: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27143: LD_ADDR_VAR 0 20
27147: PUSH
27148: LD_INT 0
27150: PUSH
27151: LD_INT 0
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 0
27160: PUSH
27161: LD_INT 1
27163: NEG
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 1
27181: PUSH
27182: LD_INT 1
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_INT 0
27191: PUSH
27192: LD_INT 1
27194: PUSH
27195: EMPTY
27196: LIST
27197: LIST
27198: PUSH
27199: LD_INT 1
27201: NEG
27202: PUSH
27203: LD_INT 0
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: LD_INT 1
27216: NEG
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 1
27224: NEG
27225: PUSH
27226: LD_INT 2
27228: NEG
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: PUSH
27234: LD_INT 0
27236: PUSH
27237: LD_INT 2
27239: NEG
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PUSH
27245: LD_INT 1
27247: PUSH
27248: LD_INT 1
27250: NEG
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 2
27258: PUSH
27259: LD_INT 0
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 2
27268: PUSH
27269: LD_INT 1
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 2
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 1
27288: PUSH
27289: LD_INT 2
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: LD_INT 2
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 1
27308: NEG
27309: PUSH
27310: LD_INT 1
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: LD_INT 2
27319: NEG
27320: PUSH
27321: LD_INT 0
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: PUSH
27328: LD_INT 2
27330: NEG
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 2
27342: NEG
27343: PUSH
27344: LD_INT 2
27346: NEG
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: LIST
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27373: LD_ADDR_VAR 0 21
27377: PUSH
27378: LD_INT 0
27380: PUSH
27381: LD_INT 0
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 0
27390: PUSH
27391: LD_INT 1
27393: NEG
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 1
27401: PUSH
27402: LD_INT 0
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: LD_INT 1
27411: PUSH
27412: LD_INT 1
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: LD_INT 1
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 1
27431: NEG
27432: PUSH
27433: LD_INT 0
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 1
27442: NEG
27443: PUSH
27444: LD_INT 1
27446: NEG
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 1
27454: NEG
27455: PUSH
27456: LD_INT 2
27458: NEG
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: PUSH
27464: LD_INT 0
27466: PUSH
27467: LD_INT 2
27469: NEG
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 1
27477: PUSH
27478: LD_INT 1
27480: NEG
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: PUSH
27486: LD_INT 2
27488: PUSH
27489: LD_INT 0
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 2
27498: PUSH
27499: LD_INT 1
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PUSH
27506: LD_INT 2
27508: PUSH
27509: LD_INT 2
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 1
27518: PUSH
27519: LD_INT 2
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: LD_INT 2
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 1
27538: NEG
27539: PUSH
27540: LD_INT 1
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: LD_INT 2
27549: NEG
27550: PUSH
27551: LD_INT 0
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: LD_INT 2
27560: NEG
27561: PUSH
27562: LD_INT 1
27564: NEG
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: LD_INT 2
27572: NEG
27573: PUSH
27574: LD_INT 2
27576: NEG
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: LIST
27600: LIST
27601: LIST
27602: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27603: LD_ADDR_VAR 0 22
27607: PUSH
27608: LD_INT 0
27610: PUSH
27611: LD_INT 0
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: LD_INT 1
27623: NEG
27624: PUSH
27625: EMPTY
27626: LIST
27627: LIST
27628: PUSH
27629: LD_INT 1
27631: PUSH
27632: LD_INT 0
27634: PUSH
27635: EMPTY
27636: LIST
27637: LIST
27638: PUSH
27639: LD_INT 1
27641: PUSH
27642: LD_INT 1
27644: PUSH
27645: EMPTY
27646: LIST
27647: LIST
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: LD_INT 1
27654: PUSH
27655: EMPTY
27656: LIST
27657: LIST
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: LD_INT 1
27672: NEG
27673: PUSH
27674: LD_INT 1
27676: NEG
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PUSH
27682: LD_INT 1
27684: NEG
27685: PUSH
27686: LD_INT 2
27688: NEG
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PUSH
27694: LD_INT 0
27696: PUSH
27697: LD_INT 2
27699: NEG
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 1
27707: PUSH
27708: LD_INT 1
27710: NEG
27711: PUSH
27712: EMPTY
27713: LIST
27714: LIST
27715: PUSH
27716: LD_INT 2
27718: PUSH
27719: LD_INT 0
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 2
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 2
27738: PUSH
27739: LD_INT 2
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 1
27748: PUSH
27749: LD_INT 2
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 0
27758: PUSH
27759: LD_INT 2
27761: PUSH
27762: EMPTY
27763: LIST
27764: LIST
27765: PUSH
27766: LD_INT 1
27768: NEG
27769: PUSH
27770: LD_INT 1
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 2
27779: NEG
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 2
27790: NEG
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 2
27802: NEG
27803: PUSH
27804: LD_INT 2
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: LIST
27825: LIST
27826: LIST
27827: LIST
27828: LIST
27829: LIST
27830: LIST
27831: LIST
27832: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27833: LD_ADDR_VAR 0 23
27837: PUSH
27838: LD_INT 0
27840: PUSH
27841: LD_INT 0
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 0
27850: PUSH
27851: LD_INT 1
27853: NEG
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 1
27861: PUSH
27862: LD_INT 0
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 1
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 0
27881: PUSH
27882: LD_INT 1
27884: PUSH
27885: EMPTY
27886: LIST
27887: LIST
27888: PUSH
27889: LD_INT 1
27891: NEG
27892: PUSH
27893: LD_INT 0
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: PUSH
27900: LD_INT 1
27902: NEG
27903: PUSH
27904: LD_INT 1
27906: NEG
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 1
27914: NEG
27915: PUSH
27916: LD_INT 2
27918: NEG
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: PUSH
27924: LD_INT 0
27926: PUSH
27927: LD_INT 2
27929: NEG
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 1
27937: PUSH
27938: LD_INT 1
27940: NEG
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 2
27948: PUSH
27949: LD_INT 0
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 2
27958: PUSH
27959: LD_INT 1
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 2
27968: PUSH
27969: LD_INT 2
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 1
27978: PUSH
27979: LD_INT 2
27981: PUSH
27982: EMPTY
27983: LIST
27984: LIST
27985: PUSH
27986: LD_INT 0
27988: PUSH
27989: LD_INT 2
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 1
27998: NEG
27999: PUSH
28000: LD_INT 1
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 2
28009: NEG
28010: PUSH
28011: LD_INT 0
28013: PUSH
28014: EMPTY
28015: LIST
28016: LIST
28017: PUSH
28018: LD_INT 2
28020: NEG
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 2
28032: NEG
28033: PUSH
28034: LD_INT 2
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 2
28044: NEG
28045: PUSH
28046: LD_INT 3
28048: NEG
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 1
28056: NEG
28057: PUSH
28058: LD_INT 3
28060: NEG
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 1
28068: PUSH
28069: LD_INT 2
28071: NEG
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 2
28079: PUSH
28080: LD_INT 1
28082: NEG
28083: PUSH
28084: EMPTY
28085: LIST
28086: LIST
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28113: LD_ADDR_VAR 0 24
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: LD_INT 0
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 0
28130: PUSH
28131: LD_INT 1
28133: NEG
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 1
28141: PUSH
28142: LD_INT 0
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 1
28151: PUSH
28152: LD_INT 1
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: LD_INT 0
28161: PUSH
28162: LD_INT 1
28164: PUSH
28165: EMPTY
28166: LIST
28167: LIST
28168: PUSH
28169: LD_INT 1
28171: NEG
28172: PUSH
28173: LD_INT 0
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: PUSH
28180: LD_INT 1
28182: NEG
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PUSH
28192: LD_INT 1
28194: NEG
28195: PUSH
28196: LD_INT 2
28198: NEG
28199: PUSH
28200: EMPTY
28201: LIST
28202: LIST
28203: PUSH
28204: LD_INT 0
28206: PUSH
28207: LD_INT 2
28209: NEG
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 1
28217: PUSH
28218: LD_INT 1
28220: NEG
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 2
28228: PUSH
28229: LD_INT 0
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 2
28238: PUSH
28239: LD_INT 1
28241: PUSH
28242: EMPTY
28243: LIST
28244: LIST
28245: PUSH
28246: LD_INT 2
28248: PUSH
28249: LD_INT 2
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: PUSH
28256: LD_INT 1
28258: PUSH
28259: LD_INT 2
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: LD_INT 2
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 1
28278: NEG
28279: PUSH
28280: LD_INT 1
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 2
28289: NEG
28290: PUSH
28291: LD_INT 0
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 2
28300: NEG
28301: PUSH
28302: LD_INT 1
28304: NEG
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 2
28312: NEG
28313: PUSH
28314: LD_INT 2
28316: NEG
28317: PUSH
28318: EMPTY
28319: LIST
28320: LIST
28321: PUSH
28322: LD_INT 1
28324: PUSH
28325: LD_INT 2
28327: NEG
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: PUSH
28336: LD_INT 1
28338: NEG
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 3
28346: PUSH
28347: LD_INT 1
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 3
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: LIST
28368: LIST
28369: LIST
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: LIST
28377: LIST
28378: LIST
28379: LIST
28380: LIST
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: LIST
28388: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28389: LD_ADDR_VAR 0 25
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 0
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 0
28406: PUSH
28407: LD_INT 1
28409: NEG
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 1
28417: PUSH
28418: LD_INT 0
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: LD_INT 1
28427: PUSH
28428: LD_INT 1
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: LD_INT 0
28437: PUSH
28438: LD_INT 1
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: PUSH
28445: LD_INT 1
28447: NEG
28448: PUSH
28449: LD_INT 0
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 1
28458: NEG
28459: PUSH
28460: LD_INT 1
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 1
28470: NEG
28471: PUSH
28472: LD_INT 2
28474: NEG
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 0
28482: PUSH
28483: LD_INT 2
28485: NEG
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 1
28493: PUSH
28494: LD_INT 1
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 2
28504: PUSH
28505: LD_INT 0
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: LD_INT 2
28514: PUSH
28515: LD_INT 1
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PUSH
28522: LD_INT 2
28524: PUSH
28525: LD_INT 2
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 1
28534: PUSH
28535: LD_INT 2
28537: PUSH
28538: EMPTY
28539: LIST
28540: LIST
28541: PUSH
28542: LD_INT 0
28544: PUSH
28545: LD_INT 2
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PUSH
28552: LD_INT 1
28554: NEG
28555: PUSH
28556: LD_INT 1
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PUSH
28563: LD_INT 2
28565: NEG
28566: PUSH
28567: LD_INT 0
28569: PUSH
28570: EMPTY
28571: LIST
28572: LIST
28573: PUSH
28574: LD_INT 2
28576: NEG
28577: PUSH
28578: LD_INT 1
28580: NEG
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: LD_INT 2
28592: NEG
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 3
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 3
28610: PUSH
28611: LD_INT 2
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 2
28620: PUSH
28621: LD_INT 3
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: PUSH
28628: LD_INT 1
28630: PUSH
28631: LD_INT 3
28633: PUSH
28634: EMPTY
28635: LIST
28636: LIST
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: LIST
28642: LIST
28643: LIST
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28663: LD_ADDR_VAR 0 26
28667: PUSH
28668: LD_INT 0
28670: PUSH
28671: LD_INT 0
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 0
28680: PUSH
28681: LD_INT 1
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 1
28691: PUSH
28692: LD_INT 0
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 1
28701: PUSH
28702: LD_INT 1
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: LD_INT 0
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 1
28721: NEG
28722: PUSH
28723: LD_INT 0
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: NEG
28733: PUSH
28734: LD_INT 1
28736: NEG
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: NEG
28745: PUSH
28746: LD_INT 2
28748: NEG
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 0
28756: PUSH
28757: LD_INT 2
28759: NEG
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 1
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 2
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 2
28798: PUSH
28799: LD_INT 2
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 0
28818: PUSH
28819: LD_INT 2
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: NEG
28829: PUSH
28830: LD_INT 1
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 2
28839: NEG
28840: PUSH
28841: LD_INT 0
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: PUSH
28848: LD_INT 2
28850: NEG
28851: PUSH
28852: LD_INT 1
28854: NEG
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PUSH
28860: LD_INT 2
28862: NEG
28863: PUSH
28864: LD_INT 2
28866: NEG
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PUSH
28872: LD_INT 2
28874: PUSH
28875: LD_INT 3
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 1
28884: PUSH
28885: LD_INT 3
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: NEG
28895: PUSH
28896: LD_INT 2
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 2
28905: NEG
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28939: LD_ADDR_VAR 0 27
28943: PUSH
28944: LD_INT 0
28946: PUSH
28947: LD_INT 0
28949: PUSH
28950: EMPTY
28951: LIST
28952: LIST
28953: PUSH
28954: LD_INT 0
28956: PUSH
28957: LD_INT 1
28959: NEG
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: LD_INT 0
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: LD_INT 1
28977: PUSH
28978: LD_INT 1
28980: PUSH
28981: EMPTY
28982: LIST
28983: LIST
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: LD_INT 1
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: PUSH
28995: LD_INT 1
28997: NEG
28998: PUSH
28999: LD_INT 0
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: LD_INT 1
29008: NEG
29009: PUSH
29010: LD_INT 1
29012: NEG
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PUSH
29018: LD_INT 1
29020: NEG
29021: PUSH
29022: LD_INT 2
29024: NEG
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 0
29032: PUSH
29033: LD_INT 2
29035: NEG
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 1
29043: PUSH
29044: LD_INT 1
29046: NEG
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 2
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: PUSH
29062: LD_INT 2
29064: PUSH
29065: LD_INT 1
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 2
29074: PUSH
29075: LD_INT 2
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 1
29084: PUSH
29085: LD_INT 2
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 0
29094: PUSH
29095: LD_INT 2
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 1
29104: NEG
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: LD_INT 2
29115: NEG
29116: PUSH
29117: LD_INT 0
29119: PUSH
29120: EMPTY
29121: LIST
29122: LIST
29123: PUSH
29124: LD_INT 2
29126: NEG
29127: PUSH
29128: LD_INT 1
29130: NEG
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 2
29138: NEG
29139: PUSH
29140: LD_INT 2
29142: NEG
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: PUSH
29148: LD_INT 1
29150: NEG
29151: PUSH
29152: LD_INT 2
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: NEG
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 3
29172: NEG
29173: PUSH
29174: LD_INT 1
29176: NEG
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 3
29184: NEG
29185: PUSH
29186: LD_INT 2
29188: NEG
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29219: LD_ADDR_VAR 0 28
29223: PUSH
29224: LD_INT 0
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: LD_INT 1
29239: NEG
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 1
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: LD_INT 1
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 0
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: EMPTY
29272: LIST
29273: LIST
29274: PUSH
29275: LD_INT 1
29277: NEG
29278: PUSH
29279: LD_INT 0
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 1
29288: NEG
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: EMPTY
29295: LIST
29296: LIST
29297: PUSH
29298: LD_INT 1
29300: NEG
29301: PUSH
29302: LD_INT 2
29304: NEG
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PUSH
29310: LD_INT 0
29312: PUSH
29313: LD_INT 2
29315: NEG
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: PUSH
29321: LD_INT 1
29323: PUSH
29324: LD_INT 1
29326: NEG
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 2
29334: PUSH
29335: LD_INT 0
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 2
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 2
29354: PUSH
29355: LD_INT 2
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: LD_INT 2
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 2
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: NEG
29385: PUSH
29386: LD_INT 1
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 2
29395: NEG
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 2
29406: NEG
29407: PUSH
29408: LD_INT 1
29410: NEG
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 2
29418: NEG
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 2
29430: NEG
29431: PUSH
29432: LD_INT 3
29434: NEG
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: NEG
29443: PUSH
29444: LD_INT 3
29446: NEG
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: LD_INT 3
29454: NEG
29455: PUSH
29456: LD_INT 1
29458: NEG
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 3
29466: NEG
29467: PUSH
29468: LD_INT 2
29470: NEG
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29501: LD_ADDR_VAR 0 29
29505: PUSH
29506: LD_INT 0
29508: PUSH
29509: LD_INT 0
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 1
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 0
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 0
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: NEG
29560: PUSH
29561: LD_INT 0
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: LD_INT 1
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: LD_INT 2
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 0
29594: PUSH
29595: LD_INT 2
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: PUSH
29617: LD_INT 0
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: PUSH
29637: LD_INT 2
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: NEG
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 2
29667: NEG
29668: PUSH
29669: LD_INT 1
29671: NEG
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 2
29679: NEG
29680: PUSH
29681: LD_INT 2
29683: NEG
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 2
29691: NEG
29692: PUSH
29693: LD_INT 3
29695: NEG
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: PUSH
29701: LD_INT 2
29703: PUSH
29704: LD_INT 1
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 3
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: LD_INT 3
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 1
29734: NEG
29735: PUSH
29736: LD_INT 2
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 3
29745: NEG
29746: PUSH
29747: LD_INT 2
29749: NEG
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: LIST
29759: LIST
29760: LIST
29761: LIST
29762: LIST
29763: LIST
29764: LIST
29765: LIST
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29780: LD_ADDR_VAR 0 30
29784: PUSH
29785: LD_INT 0
29787: PUSH
29788: LD_INT 0
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 0
29797: PUSH
29798: LD_INT 1
29800: NEG
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 1
29808: PUSH
29809: LD_INT 0
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 1
29818: PUSH
29819: LD_INT 1
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 0
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: NEG
29839: PUSH
29840: LD_INT 0
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 1
29849: NEG
29850: PUSH
29851: LD_INT 1
29853: NEG
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 1
29861: NEG
29862: PUSH
29863: LD_INT 2
29865: NEG
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 0
29873: PUSH
29874: LD_INT 2
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 2
29895: PUSH
29896: LD_INT 0
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 2
29905: PUSH
29906: LD_INT 1
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 2
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 2
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: NEG
29936: PUSH
29937: LD_INT 1
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: LD_INT 0
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 2
29957: NEG
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 1
29969: NEG
29970: PUSH
29971: LD_INT 3
29973: NEG
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: LD_INT 2
29984: NEG
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: LD_INT 2
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 2
30002: PUSH
30003: LD_INT 3
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 2
30012: NEG
30013: PUSH
30014: LD_INT 1
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: PUSH
30021: LD_INT 3
30023: NEG
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30058: LD_ADDR_VAR 0 31
30062: PUSH
30063: LD_INT 0
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 0
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 1
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 1
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: NEG
30117: PUSH
30118: LD_INT 0
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 1
30127: NEG
30128: PUSH
30129: LD_INT 1
30131: NEG
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 1
30139: NEG
30140: PUSH
30141: LD_INT 2
30143: NEG
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 1
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: PUSH
30163: LD_INT 0
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 2
30172: PUSH
30173: LD_INT 1
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 2
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 1
30192: PUSH
30193: LD_INT 2
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 0
30202: PUSH
30203: LD_INT 2
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 2
30223: NEG
30224: PUSH
30225: LD_INT 1
30227: NEG
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 2
30235: NEG
30236: PUSH
30237: LD_INT 2
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 2
30247: NEG
30248: PUSH
30249: LD_INT 3
30251: NEG
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 2
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 3
30270: PUSH
30271: LD_INT 1
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 1
30280: PUSH
30281: LD_INT 3
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 2
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 3
30301: NEG
30302: PUSH
30303: LD_INT 2
30305: NEG
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30336: LD_ADDR_VAR 0 32
30340: PUSH
30341: LD_INT 0
30343: PUSH
30344: LD_INT 0
30346: PUSH
30347: EMPTY
30348: LIST
30349: LIST
30350: PUSH
30351: LD_INT 0
30353: PUSH
30354: LD_INT 1
30356: NEG
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: LD_INT 0
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: PUSH
30375: LD_INT 1
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: LD_INT 1
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: NEG
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: NEG
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: LD_INT 2
30421: NEG
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: LD_INT 2
30432: NEG
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: LD_INT 1
30443: NEG
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 2
30451: PUSH
30452: LD_INT 1
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 2
30461: PUSH
30462: LD_INT 2
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 1
30471: PUSH
30472: LD_INT 2
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: LD_INT 2
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 1
30491: NEG
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 2
30502: NEG
30503: PUSH
30504: LD_INT 0
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 2
30513: NEG
30514: PUSH
30515: LD_INT 1
30517: NEG
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 1
30525: NEG
30526: PUSH
30527: LD_INT 3
30529: NEG
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: LD_INT 2
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 3
30548: PUSH
30549: LD_INT 2
30551: PUSH
30552: EMPTY
30553: LIST
30554: LIST
30555: PUSH
30556: LD_INT 2
30558: PUSH
30559: LD_INT 3
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 2
30568: NEG
30569: PUSH
30570: LD_INT 1
30572: PUSH
30573: EMPTY
30574: LIST
30575: LIST
30576: PUSH
30577: LD_INT 3
30579: NEG
30580: PUSH
30581: LD_INT 1
30583: NEG
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30614: LD_ADDR_VAR 0 33
30618: PUSH
30619: LD_INT 0
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 0
30631: PUSH
30632: LD_INT 1
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 1
30642: PUSH
30643: LD_INT 0
30645: PUSH
30646: EMPTY
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 1
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: LD_INT 0
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: LD_INT 1
30683: NEG
30684: PUSH
30685: LD_INT 1
30687: NEG
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 1
30695: NEG
30696: PUSH
30697: LD_INT 2
30699: NEG
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 1
30707: PUSH
30708: LD_INT 1
30710: NEG
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: LD_INT 0
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 2
30728: PUSH
30729: LD_INT 1
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: LD_INT 2
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 0
30748: PUSH
30749: LD_INT 2
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: NEG
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 2
30804: NEG
30805: PUSH
30806: LD_INT 3
30808: NEG
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: LD_INT 1
30819: NEG
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 3
30827: PUSH
30828: LD_INT 1
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 1
30837: PUSH
30838: LD_INT 3
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: LD_INT 2
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 3
30858: NEG
30859: PUSH
30860: LD_INT 2
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30893: LD_ADDR_VAR 0 34
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: LD_INT 0
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 0
30910: PUSH
30911: LD_INT 1
30913: NEG
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 1
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 0
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: NEG
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 1
30962: NEG
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: LD_INT 2
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 0
30986: PUSH
30987: LD_INT 2
30989: NEG
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 1
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 2
31008: PUSH
31009: LD_INT 1
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 2
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 1
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 2
31060: NEG
31061: PUSH
31062: LD_INT 1
31064: NEG
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: LD_INT 2
31076: NEG
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 1
31084: NEG
31085: PUSH
31086: LD_INT 3
31088: NEG
31089: PUSH
31090: EMPTY
31091: LIST
31092: LIST
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: LD_INT 2
31099: NEG
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 3
31107: PUSH
31108: LD_INT 2
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 2
31117: PUSH
31118: LD_INT 3
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: LD_INT 1
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 3
31138: NEG
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: LIST
31157: LIST
31158: LIST
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31173: LD_ADDR_VAR 0 35
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: LD_INT 0
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 0
31190: PUSH
31191: LD_INT 1
31193: NEG
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 1
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 0
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: NEG
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: NEG
31243: PUSH
31244: LD_INT 1
31246: NEG
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 2
31254: PUSH
31255: LD_INT 1
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 2
31264: NEG
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31285: LD_ADDR_VAR 0 36
31289: PUSH
31290: LD_INT 0
31292: PUSH
31293: LD_INT 0
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: LD_INT 1
31305: NEG
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: LD_INT 0
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 1
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 0
31333: PUSH
31334: LD_INT 1
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: LD_INT 0
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: LD_INT 1
31354: NEG
31355: PUSH
31356: LD_INT 1
31358: NEG
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 1
31366: NEG
31367: PUSH
31368: LD_INT 2
31370: NEG
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 1
31378: PUSH
31379: LD_INT 2
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31397: LD_ADDR_VAR 0 37
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: LD_INT 0
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: LD_INT 1
31417: NEG
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 0
31445: PUSH
31446: LD_INT 1
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: NEG
31456: PUSH
31457: LD_INT 0
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 1
31466: NEG
31467: PUSH
31468: LD_INT 1
31470: NEG
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 1
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: NEG
31490: PUSH
31491: LD_INT 1
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31509: LD_ADDR_VAR 0 38
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: LD_INT 0
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: LD_INT 1
31529: NEG
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: PUSH
31538: LD_INT 0
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: LD_INT 1
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: LD_INT 1
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: LD_INT 0
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: LD_INT 1
31582: NEG
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 2
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 2
31600: NEG
31601: PUSH
31602: LD_INT 1
31604: NEG
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31621: LD_ADDR_VAR 0 39
31625: PUSH
31626: LD_INT 0
31628: PUSH
31629: LD_INT 0
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 0
31638: PUSH
31639: LD_INT 1
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: PUSH
31660: LD_INT 1
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 0
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 0
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 1
31694: NEG
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 2
31706: NEG
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: LD_INT 2
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31733: LD_ADDR_VAR 0 40
31737: PUSH
31738: LD_INT 0
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: LD_INT 1
31753: NEG
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: PUSH
31762: LD_INT 0
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: LD_INT 1
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 0
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: NEG
31792: PUSH
31793: LD_INT 0
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: LD_INT 1
31806: NEG
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 1
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 1
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31845: LD_ADDR_VAR 0 41
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 0
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: LD_INT 1
31865: NEG
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 1
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 1
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 0
31893: PUSH
31894: LD_INT 1
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: NEG
31904: PUSH
31905: LD_INT 0
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 1
31914: NEG
31915: PUSH
31916: LD_INT 1
31918: NEG
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 1
31926: NEG
31927: PUSH
31928: LD_INT 2
31930: NEG
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: PUSH
31939: LD_INT 1
31941: NEG
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 2
31949: PUSH
31950: LD_INT 0
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: PUSH
31957: LD_INT 2
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 1
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 2
32000: NEG
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: NEG
32012: PUSH
32013: LD_INT 1
32015: NEG
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 2
32023: NEG
32024: PUSH
32025: LD_INT 2
32027: NEG
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 2
32035: NEG
32036: PUSH
32037: LD_INT 3
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 2
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 3
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 3
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 3
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 3
32088: PUSH
32089: LD_INT 3
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 2
32098: PUSH
32099: LD_INT 3
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 2
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 3
32119: NEG
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 3
32130: NEG
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 3
32142: NEG
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 3
32154: NEG
32155: PUSH
32156: LD_INT 3
32158: NEG
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32195: LD_ADDR_VAR 0 42
32199: PUSH
32200: LD_INT 0
32202: PUSH
32203: LD_INT 0
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 0
32212: PUSH
32213: LD_INT 1
32215: NEG
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 1
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 1
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 0
32243: PUSH
32244: LD_INT 1
32246: PUSH
32247: EMPTY
32248: LIST
32249: LIST
32250: PUSH
32251: LD_INT 1
32253: NEG
32254: PUSH
32255: LD_INT 0
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: NEG
32265: PUSH
32266: LD_INT 1
32268: NEG
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 1
32276: NEG
32277: PUSH
32278: LD_INT 2
32280: NEG
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: LD_INT 2
32291: NEG
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 1
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 2
32310: PUSH
32311: LD_INT 1
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 2
32320: PUSH
32321: LD_INT 2
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: PUSH
32331: LD_INT 2
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: LD_INT 2
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 1
32350: NEG
32351: PUSH
32352: LD_INT 1
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 2
32361: NEG
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 2
32373: NEG
32374: PUSH
32375: LD_INT 2
32377: NEG
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 2
32385: NEG
32386: PUSH
32387: LD_INT 3
32389: NEG
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PUSH
32399: LD_INT 3
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 3
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 3
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 3
32441: PUSH
32442: LD_INT 3
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 2
32451: PUSH
32452: LD_INT 3
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 1
32461: PUSH
32462: LD_INT 3
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 3
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: NEG
32482: PUSH
32483: LD_INT 2
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 3
32492: NEG
32493: PUSH
32494: LD_INT 2
32496: NEG
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 3
32504: NEG
32505: PUSH
32506: LD_INT 3
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32545: LD_ADDR_VAR 0 43
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: LD_INT 1
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 1
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 0
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: LD_INT 0
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 1
32614: NEG
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: LD_INT 2
32630: NEG
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 0
32638: PUSH
32639: LD_INT 2
32641: NEG
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 2
32670: PUSH
32671: LD_INT 1
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 1
32680: PUSH
32681: LD_INT 2
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: LD_INT 2
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 2
32711: NEG
32712: PUSH
32713: LD_INT 0
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: NEG
32723: PUSH
32724: LD_INT 1
32726: NEG
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 3
32738: NEG
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: LD_INT 3
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 2
32768: PUSH
32769: LD_INT 1
32771: NEG
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 3
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 3
32789: PUSH
32790: LD_INT 1
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 1
32799: PUSH
32800: LD_INT 3
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 0
32809: PUSH
32810: LD_INT 3
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: NEG
32831: PUSH
32832: LD_INT 1
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 3
32841: NEG
32842: PUSH
32843: LD_INT 0
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 3
32852: NEG
32853: PUSH
32854: LD_INT 1
32856: NEG
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32893: LD_ADDR_VAR 0 44
32897: PUSH
32898: LD_INT 0
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 1
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 1
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 1
32951: NEG
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: NEG
32963: PUSH
32964: LD_INT 1
32966: NEG
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: LD_INT 2
32978: NEG
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 1
32986: PUSH
32987: LD_INT 1
32989: NEG
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 2
32997: PUSH
32998: LD_INT 0
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 2
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 2
33017: PUSH
33018: LD_INT 2
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: NEG
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: LD_INT 0
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: NEG
33060: PUSH
33061: LD_INT 1
33063: NEG
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 2
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 2
33083: NEG
33084: PUSH
33085: LD_INT 3
33087: NEG
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 2
33095: PUSH
33096: LD_INT 1
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 3
33106: PUSH
33107: LD_INT 0
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 3
33116: PUSH
33117: LD_INT 1
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 3
33126: PUSH
33127: LD_INT 2
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 3
33136: PUSH
33137: LD_INT 3
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 2
33146: PUSH
33147: LD_INT 3
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 2
33156: NEG
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 3
33167: NEG
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 3
33178: NEG
33179: PUSH
33180: LD_INT 1
33182: NEG
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 3
33190: NEG
33191: PUSH
33192: LD_INT 2
33194: NEG
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 3
33202: NEG
33203: PUSH
33204: LD_INT 3
33206: NEG
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33243: LD_ADDR_VAR 0 45
33247: PUSH
33248: LD_INT 0
33250: PUSH
33251: LD_INT 0
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: NEG
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: LD_INT 1
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 0
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 1
33312: NEG
33313: PUSH
33314: LD_INT 1
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 0
33336: PUSH
33337: LD_INT 2
33339: NEG
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: PUSH
33348: LD_INT 1
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 2
33368: PUSH
33369: LD_INT 2
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 1
33378: PUSH
33379: LD_INT 2
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: NEG
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 2
33409: NEG
33410: PUSH
33411: LD_INT 1
33413: NEG
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 2
33421: NEG
33422: PUSH
33423: LD_INT 2
33425: NEG
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 2
33433: NEG
33434: PUSH
33435: LD_INT 3
33437: NEG
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: LD_INT 3
33449: NEG
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 3
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: PUSH
33469: LD_INT 2
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 3
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 3
33489: PUSH
33490: LD_INT 3
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 2
33499: PUSH
33500: LD_INT 3
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: LD_INT 3
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 3
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: NEG
33530: PUSH
33531: LD_INT 2
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 3
33540: NEG
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 3
33552: NEG
33553: PUSH
33554: LD_INT 3
33556: NEG
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33593: LD_ADDR_VAR 0 46
33597: PUSH
33598: LD_INT 0
33600: PUSH
33601: LD_INT 0
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 0
33610: PUSH
33611: LD_INT 1
33613: NEG
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: LD_INT 1
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: LD_INT 1
33666: NEG
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 1
33674: NEG
33675: PUSH
33676: LD_INT 2
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 0
33686: PUSH
33687: LD_INT 2
33689: NEG
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 1
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: LD_INT 0
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 2
33718: PUSH
33719: LD_INT 1
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 1
33728: PUSH
33729: LD_INT 2
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: LD_INT 2
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 1
33748: NEG
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 2
33759: NEG
33760: PUSH
33761: LD_INT 0
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: LD_INT 1
33774: NEG
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 3
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 0
33794: PUSH
33795: LD_INT 3
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 2
33816: PUSH
33817: LD_INT 1
33819: NEG
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 3
33827: PUSH
33828: LD_INT 0
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 3
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: LD_INT 3
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: LD_INT 3
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: LD_INT 2
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 2
33878: NEG
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 3
33889: NEG
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 3
33900: NEG
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: LIST
33921: LIST
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33941: LD_ADDR_VAR 0 47
33945: PUSH
33946: LD_INT 0
33948: PUSH
33949: LD_INT 0
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 1
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 1
33979: PUSH
33980: LD_INT 1
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 0
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: LD_INT 0
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: LD_INT 1
34014: NEG
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 1
34022: NEG
34023: PUSH
34024: LD_INT 2
34026: NEG
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 0
34034: PUSH
34035: LD_INT 2
34037: NEG
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: PUSH
34046: LD_INT 1
34048: NEG
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: NEG
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 2
34068: NEG
34069: PUSH
34070: LD_INT 2
34072: NEG
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34092: LD_ADDR_VAR 0 48
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: LD_INT 1
34112: NEG
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 1
34120: PUSH
34121: LD_INT 0
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 1
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: LD_INT 0
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 1
34199: NEG
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 2
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 2
34217: PUSH
34218: LD_INT 1
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34239: LD_ADDR_VAR 0 49
34243: PUSH
34244: LD_INT 0
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 0
34256: PUSH
34257: LD_INT 1
34259: NEG
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 1
34267: PUSH
34268: LD_INT 0
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 0
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: NEG
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: PUSH
34332: LD_INT 0
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 2
34341: PUSH
34342: LD_INT 1
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 2
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 1
34361: PUSH
34362: LD_INT 2
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34383: LD_ADDR_VAR 0 50
34387: PUSH
34388: LD_INT 0
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 0
34400: PUSH
34401: LD_INT 1
34403: NEG
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: LD_INT 1
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 0
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 1
34441: NEG
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: NEG
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 1
34504: NEG
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: LIST
34524: LIST
34525: LIST
34526: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34527: LD_ADDR_VAR 0 51
34531: PUSH
34532: LD_INT 0
34534: PUSH
34535: LD_INT 0
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: LD_INT 1
34547: NEG
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: LD_INT 1
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: LD_INT 0
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: LD_INT 1
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 2
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 2
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 1
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 2
34639: NEG
34640: PUSH
34641: LD_INT 0
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 2
34650: NEG
34651: PUSH
34652: LD_INT 1
34654: NEG
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34674: LD_ADDR_VAR 0 52
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: LD_INT 0
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 0
34691: PUSH
34692: LD_INT 1
34694: NEG
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 2
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 2
34778: NEG
34779: PUSH
34780: LD_INT 0
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 2
34789: NEG
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 2
34801: NEG
34802: PUSH
34803: LD_INT 2
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34825: LD_ADDR_VAR 0 53
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: LD_INT 1
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: LD_INT 1
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: LD_INT 1
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: LD_INT 1
34898: NEG
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 1
34906: NEG
34907: PUSH
34908: LD_INT 2
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: LD_INT 1
34932: NEG
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: LD_INT 0
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 2
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 2
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: PUSH
34971: LD_INT 2
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: LD_INT 2
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 1
34990: NEG
34991: PUSH
34992: LD_INT 1
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 2
35001: NEG
35002: PUSH
35003: LD_INT 0
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 2
35012: NEG
35013: PUSH
35014: LD_INT 1
35016: NEG
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: LD_INT 2
35028: NEG
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35055: LD_ADDR_VAR 0 54
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 0
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 1
35083: PUSH
35084: LD_INT 0
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 1
35093: PUSH
35094: LD_INT 1
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: LD_INT 1
35128: NEG
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: LD_INT 2
35140: NEG
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 0
35148: PUSH
35149: LD_INT 2
35151: NEG
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 2
35170: PUSH
35171: LD_INT 0
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 2
35190: PUSH
35191: LD_INT 2
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 0
35210: PUSH
35211: LD_INT 2
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 2
35231: NEG
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: NEG
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 2
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35285: LD_ADDR_VAR 0 55
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 0
35378: PUSH
35379: LD_INT 2
35381: NEG
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 1
35389: PUSH
35390: LD_INT 1
35392: NEG
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PUSH
35398: LD_INT 2
35400: PUSH
35401: LD_INT 0
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 2
35410: PUSH
35411: LD_INT 1
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: PUSH
35421: LD_INT 2
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: LD_INT 2
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 2
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 2
35461: NEG
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: EMPTY
35467: LIST
35468: LIST
35469: PUSH
35470: LD_INT 2
35472: NEG
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: LD_INT 2
35488: NEG
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: LIST
35511: LIST
35512: LIST
35513: LIST
35514: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35515: LD_ADDR_VAR 0 56
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: LD_INT 0
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: LD_INT 1
35535: NEG
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: LD_INT 0
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 1
35553: PUSH
35554: LD_INT 1
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 0
35563: PUSH
35564: LD_INT 1
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 1
35573: NEG
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: NEG
35585: PUSH
35586: LD_INT 1
35588: NEG
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: LD_INT 2
35600: NEG
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 0
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 2
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: PUSH
35641: LD_INT 1
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 2
35650: PUSH
35651: LD_INT 2
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 1
35660: PUSH
35661: LD_INT 2
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: LD_INT 2
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 1
35680: NEG
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 2
35691: NEG
35692: PUSH
35693: LD_INT 0
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 2
35702: NEG
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: LD_INT 2
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35745: LD_ADDR_VAR 0 57
35749: PUSH
35750: LD_INT 0
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 0
35762: PUSH
35763: LD_INT 1
35765: NEG
35766: PUSH
35767: EMPTY
35768: LIST
35769: LIST
35770: PUSH
35771: LD_INT 1
35773: PUSH
35774: LD_INT 0
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 1
35783: PUSH
35784: LD_INT 1
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: LD_INT 1
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: LD_INT 0
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: LD_INT 1
35818: NEG
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: LD_INT 2
35830: NEG
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: LD_INT 2
35841: NEG
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 2
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 2
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 2
35880: PUSH
35881: LD_INT 2
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 1
35890: PUSH
35891: LD_INT 2
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: LD_INT 0
35900: PUSH
35901: LD_INT 2
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 2
35921: NEG
35922: PUSH
35923: LD_INT 0
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 2
35932: NEG
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: NEG
35945: PUSH
35946: LD_INT 2
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35975: LD_ADDR_VAR 0 58
35979: PUSH
35980: LD_INT 0
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 0
35992: PUSH
35993: LD_INT 1
35995: NEG
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 1
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 1
36013: PUSH
36014: LD_INT 1
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: LD_INT 1
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: NEG
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: NEG
36045: PUSH
36046: LD_INT 1
36048: NEG
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 1
36056: NEG
36057: PUSH
36058: LD_INT 2
36060: NEG
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: LD_INT 2
36071: NEG
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 1
36079: PUSH
36080: LD_INT 1
36082: NEG
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 2
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 2
36100: PUSH
36101: LD_INT 1
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 2
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: LD_INT 2
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: LD_INT 0
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 2
36162: NEG
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 2
36174: NEG
36175: PUSH
36176: LD_INT 2
36178: NEG
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36205: LD_ADDR_VAR 0 59
36209: PUSH
36210: LD_INT 0
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 0
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 1
36233: PUSH
36234: LD_INT 0
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 1
36243: PUSH
36244: LD_INT 1
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: LD_INT 1
36263: NEG
36264: PUSH
36265: LD_INT 0
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: NEG
36275: PUSH
36276: LD_INT 1
36278: NEG
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36293: LD_ADDR_VAR 0 60
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 1
36321: PUSH
36322: LD_INT 0
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: LD_INT 1
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: NEG
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 1
36362: NEG
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36381: LD_ADDR_VAR 0 61
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 0
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: LD_INT 1
36401: NEG
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 1
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 1
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: NEG
36451: PUSH
36452: LD_INT 1
36454: NEG
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36469: LD_ADDR_VAR 0 62
36473: PUSH
36474: LD_INT 0
36476: PUSH
36477: LD_INT 0
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 0
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 1
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 1
36507: PUSH
36508: LD_INT 1
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: LD_INT 1
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 1
36527: NEG
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 1
36538: NEG
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36557: LD_ADDR_VAR 0 63
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 1
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 0
36605: PUSH
36606: LD_INT 1
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 1
36626: NEG
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: LIST
36644: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36645: LD_ADDR_VAR 0 64
36649: PUSH
36650: LD_INT 0
36652: PUSH
36653: LD_INT 0
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: LD_INT 1
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: NEG
36715: PUSH
36716: LD_INT 1
36718: NEG
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: LIST
36730: LIST
36731: LIST
36732: ST_TO_ADDR
// end ; 1 :
36733: GO 42630
36735: LD_INT 1
36737: DOUBLE
36738: EQUAL
36739: IFTRUE 36743
36741: GO 39366
36743: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36744: LD_ADDR_VAR 0 11
36748: PUSH
36749: LD_INT 1
36751: NEG
36752: PUSH
36753: LD_INT 3
36755: NEG
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: LD_INT 3
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: PUSH
36775: LD_INT 2
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: LIST
36787: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36788: LD_ADDR_VAR 0 12
36792: PUSH
36793: LD_INT 2
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 3
36806: PUSH
36807: LD_INT 0
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 3
36816: PUSH
36817: LD_INT 1
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: LIST
36828: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36829: LD_ADDR_VAR 0 13
36833: PUSH
36834: LD_INT 3
36836: PUSH
36837: LD_INT 2
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 3
36846: PUSH
36847: LD_INT 3
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 2
36856: PUSH
36857: LD_INT 3
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: LIST
36868: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36869: LD_ADDR_VAR 0 14
36873: PUSH
36874: LD_INT 1
36876: PUSH
36877: LD_INT 3
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 0
36886: PUSH
36887: LD_INT 3
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: NEG
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: LIST
36909: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36910: LD_ADDR_VAR 0 15
36914: PUSH
36915: LD_INT 2
36917: NEG
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 3
36928: NEG
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 3
36939: NEG
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: LIST
36953: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36954: LD_ADDR_VAR 0 16
36958: PUSH
36959: LD_INT 2
36961: NEG
36962: PUSH
36963: LD_INT 3
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: NEG
36974: PUSH
36975: LD_INT 2
36977: NEG
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 3
36985: NEG
36986: PUSH
36987: LD_INT 3
36989: NEG
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: LIST
36999: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37000: LD_ADDR_VAR 0 17
37004: PUSH
37005: LD_INT 1
37007: NEG
37008: PUSH
37009: LD_INT 3
37011: NEG
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: LD_INT 3
37022: NEG
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: LD_INT 2
37033: NEG
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: LIST
37043: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37044: LD_ADDR_VAR 0 18
37048: PUSH
37049: LD_INT 2
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 3
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 3
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: LIST
37084: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37085: LD_ADDR_VAR 0 19
37089: PUSH
37090: LD_INT 3
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 3
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 2
37112: PUSH
37113: LD_INT 3
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: LIST
37124: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37125: LD_ADDR_VAR 0 20
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: LD_INT 3
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 3
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: LIST
37165: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37166: LD_ADDR_VAR 0 21
37170: PUSH
37171: LD_INT 2
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 3
37184: NEG
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 3
37195: NEG
37196: PUSH
37197: LD_INT 1
37199: NEG
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: LIST
37209: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37210: LD_ADDR_VAR 0 22
37214: PUSH
37215: LD_INT 2
37217: NEG
37218: PUSH
37219: LD_INT 3
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 3
37229: NEG
37230: PUSH
37231: LD_INT 2
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: LD_INT 3
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: LIST
37255: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37256: LD_ADDR_VAR 0 23
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: LD_INT 3
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 1
37274: NEG
37275: PUSH
37276: LD_INT 4
37278: NEG
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 1
37286: PUSH
37287: LD_INT 3
37289: NEG
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: LIST
37299: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37300: LD_ADDR_VAR 0 24
37304: PUSH
37305: LD_INT 3
37307: PUSH
37308: LD_INT 0
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 3
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 4
37328: PUSH
37329: LD_INT 1
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: LIST
37340: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37341: LD_ADDR_VAR 0 25
37345: PUSH
37346: LD_INT 3
37348: PUSH
37349: LD_INT 3
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 4
37358: PUSH
37359: LD_INT 3
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 3
37368: PUSH
37369: LD_INT 4
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: LIST
37380: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37381: LD_ADDR_VAR 0 26
37385: PUSH
37386: LD_INT 0
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: PUSH
37399: LD_INT 4
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 1
37408: NEG
37409: PUSH
37410: LD_INT 3
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: LIST
37421: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37422: LD_ADDR_VAR 0 27
37426: PUSH
37427: LD_INT 3
37429: NEG
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 3
37440: NEG
37441: PUSH
37442: LD_INT 1
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 4
37451: NEG
37452: PUSH
37453: LD_INT 1
37455: NEG
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: LIST
37465: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37466: LD_ADDR_VAR 0 28
37470: PUSH
37471: LD_INT 3
37473: NEG
37474: PUSH
37475: LD_INT 3
37477: NEG
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 3
37485: NEG
37486: PUSH
37487: LD_INT 4
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 4
37497: NEG
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: LIST
37511: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37512: LD_ADDR_VAR 0 29
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 3
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 4
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 0
37565: PUSH
37566: LD_INT 4
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: PUSH
37577: LD_INT 3
37579: NEG
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 1
37587: NEG
37588: PUSH
37589: LD_INT 5
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: LD_INT 5
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 1
37610: PUSH
37611: LD_INT 4
37613: NEG
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 1
37621: NEG
37622: PUSH
37623: LD_INT 6
37625: NEG
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 6
37636: NEG
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 5
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37667: LD_ADDR_VAR 0 30
37671: PUSH
37672: LD_INT 2
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 3
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 3
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 4
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 4
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 4
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 5
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 5
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 5
37767: PUSH
37768: LD_INT 1
37770: NEG
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 6
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 6
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37810: LD_ADDR_VAR 0 31
37814: PUSH
37815: LD_INT 3
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 3
37827: PUSH
37828: LD_INT 3
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 2
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 4
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 4
37857: PUSH
37858: LD_INT 4
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 3
37867: PUSH
37868: LD_INT 4
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 5
37877: PUSH
37878: LD_INT 4
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 5
37887: PUSH
37888: LD_INT 5
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 4
37897: PUSH
37898: LD_INT 5
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 6
37907: PUSH
37908: LD_INT 5
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 6
37917: PUSH
37918: LD_INT 6
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 5
37927: PUSH
37928: LD_INT 6
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
37949: LD_ADDR_VAR 0 32
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 0
37966: PUSH
37967: LD_INT 3
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 1
37976: NEG
37977: PUSH
37978: LD_INT 2
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: LD_INT 4
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 0
37997: PUSH
37998: LD_INT 4
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 1
38007: NEG
38008: PUSH
38009: LD_INT 3
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 1
38018: PUSH
38019: LD_INT 5
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 0
38028: PUSH
38029: LD_INT 5
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: NEG
38039: PUSH
38040: LD_INT 4
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 1
38049: PUSH
38050: LD_INT 6
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 0
38059: PUSH
38060: LD_INT 6
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 5
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38092: LD_ADDR_VAR 0 33
38096: PUSH
38097: LD_INT 2
38099: NEG
38100: PUSH
38101: LD_INT 1
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 3
38110: NEG
38111: PUSH
38112: LD_INT 0
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 3
38121: NEG
38122: PUSH
38123: LD_INT 1
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 3
38133: NEG
38134: PUSH
38135: LD_INT 1
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 4
38144: NEG
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 4
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: NEG
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 4
38167: NEG
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 5
38178: NEG
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 5
38189: NEG
38190: PUSH
38191: LD_INT 1
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 5
38201: NEG
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 6
38212: NEG
38213: PUSH
38214: LD_INT 0
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 6
38223: NEG
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38247: LD_ADDR_VAR 0 34
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: LD_INT 3
38258: NEG
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 3
38266: NEG
38267: PUSH
38268: LD_INT 2
38270: NEG
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 3
38278: NEG
38279: PUSH
38280: LD_INT 3
38282: NEG
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: NEG
38291: PUSH
38292: LD_INT 4
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 4
38302: NEG
38303: PUSH
38304: LD_INT 3
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: LD_INT 4
38314: NEG
38315: PUSH
38316: LD_INT 4
38318: NEG
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 4
38326: NEG
38327: PUSH
38328: LD_INT 5
38330: NEG
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 5
38338: NEG
38339: PUSH
38340: LD_INT 4
38342: NEG
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 5
38350: NEG
38351: PUSH
38352: LD_INT 5
38354: NEG
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 5
38362: NEG
38363: PUSH
38364: LD_INT 6
38366: NEG
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 6
38374: NEG
38375: PUSH
38376: LD_INT 5
38378: NEG
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 6
38386: NEG
38387: PUSH
38388: LD_INT 6
38390: NEG
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38410: LD_ADDR_VAR 0 41
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 1
38428: NEG
38429: PUSH
38430: LD_INT 3
38432: NEG
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: LIST
38453: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38454: LD_ADDR_VAR 0 42
38458: PUSH
38459: LD_INT 2
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 2
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 3
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: LIST
38494: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38495: LD_ADDR_VAR 0 43
38499: PUSH
38500: LD_INT 2
38502: PUSH
38503: LD_INT 2
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 3
38512: PUSH
38513: LD_INT 2
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 2
38522: PUSH
38523: LD_INT 3
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: LIST
38534: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38535: LD_ADDR_VAR 0 44
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 3
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 1
38562: NEG
38563: PUSH
38564: LD_INT 2
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: LIST
38575: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38576: LD_ADDR_VAR 0 45
38580: PUSH
38581: LD_INT 2
38583: NEG
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 2
38594: NEG
38595: PUSH
38596: LD_INT 1
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 3
38605: NEG
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: LIST
38619: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38620: LD_ADDR_VAR 0 46
38624: PUSH
38625: LD_INT 2
38627: NEG
38628: PUSH
38629: LD_INT 2
38631: NEG
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: LD_INT 3
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 3
38651: NEG
38652: PUSH
38653: LD_INT 2
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: LIST
38665: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38666: LD_ADDR_VAR 0 47
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 3
38677: NEG
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 1
38685: NEG
38686: PUSH
38687: LD_INT 3
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38699: LD_ADDR_VAR 0 48
38703: PUSH
38704: LD_INT 1
38706: PUSH
38707: LD_INT 2
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 2
38717: PUSH
38718: LD_INT 1
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38730: LD_ADDR_VAR 0 49
38734: PUSH
38735: LD_INT 3
38737: PUSH
38738: LD_INT 1
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 3
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38759: LD_ADDR_VAR 0 50
38763: PUSH
38764: LD_INT 2
38766: PUSH
38767: LD_INT 3
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 3
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38788: LD_ADDR_VAR 0 51
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: LD_INT 2
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 2
38806: NEG
38807: PUSH
38808: LD_INT 1
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38819: LD_ADDR_VAR 0 52
38823: PUSH
38824: LD_INT 3
38826: NEG
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 3
38838: NEG
38839: PUSH
38840: LD_INT 2
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38852: LD_ADDR_VAR 0 53
38856: PUSH
38857: LD_INT 1
38859: NEG
38860: PUSH
38861: LD_INT 3
38863: NEG
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 0
38871: PUSH
38872: LD_INT 3
38874: NEG
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 1
38882: PUSH
38883: LD_INT 2
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: LIST
38895: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38896: LD_ADDR_VAR 0 54
38900: PUSH
38901: LD_INT 2
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 3
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: LIST
38936: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38937: LD_ADDR_VAR 0 55
38941: PUSH
38942: LD_INT 3
38944: PUSH
38945: LD_INT 2
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 3
38954: PUSH
38955: LD_INT 3
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 3
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: LIST
38976: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38977: LD_ADDR_VAR 0 56
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 3
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 3
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 2
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: LIST
39017: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39018: LD_ADDR_VAR 0 57
39022: PUSH
39023: LD_INT 2
39025: NEG
39026: PUSH
39027: LD_INT 1
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 3
39036: NEG
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: NEG
39048: PUSH
39049: LD_INT 1
39051: NEG
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39062: LD_ADDR_VAR 0 58
39066: PUSH
39067: LD_INT 2
39069: NEG
39070: PUSH
39071: LD_INT 3
39073: NEG
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 3
39081: NEG
39082: PUSH
39083: LD_INT 2
39085: NEG
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 3
39093: NEG
39094: PUSH
39095: LD_INT 3
39097: NEG
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: LIST
39107: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39108: LD_ADDR_VAR 0 59
39112: PUSH
39113: LD_INT 1
39115: NEG
39116: PUSH
39117: LD_INT 2
39119: NEG
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 0
39127: PUSH
39128: LD_INT 2
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39152: LD_ADDR_VAR 0 60
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: LD_INT 1
39162: NEG
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 2
39170: PUSH
39171: LD_INT 0
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 2
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: LIST
39192: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39193: LD_ADDR_VAR 0 61
39197: PUSH
39198: LD_INT 2
39200: PUSH
39201: LD_INT 1
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: LD_INT 2
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 1
39220: PUSH
39221: LD_INT 2
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: LIST
39232: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39233: LD_ADDR_VAR 0 62
39237: PUSH
39238: LD_INT 1
39240: PUSH
39241: LD_INT 2
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 2
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: LD_INT 1
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: LIST
39273: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39274: LD_ADDR_VAR 0 63
39278: PUSH
39279: LD_INT 1
39281: NEG
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 2
39303: NEG
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: LIST
39317: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39318: LD_ADDR_VAR 0 64
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: LD_INT 2
39329: NEG
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 2
39337: NEG
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 2
39349: NEG
39350: PUSH
39351: LD_INT 2
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: LIST
39363: ST_TO_ADDR
// end ; 2 :
39364: GO 42630
39366: LD_INT 2
39368: DOUBLE
39369: EQUAL
39370: IFTRUE 39374
39372: GO 42629
39374: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39375: LD_ADDR_VAR 0 29
39379: PUSH
39380: LD_INT 4
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 4
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 5
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 5
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 4
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 3
39433: PUSH
39434: LD_INT 0
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 3
39443: PUSH
39444: LD_INT 1
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 3
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 5
39465: PUSH
39466: LD_INT 2
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 3
39475: PUSH
39476: LD_INT 3
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: LD_INT 2
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 4
39495: PUSH
39496: LD_INT 3
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 4
39505: PUSH
39506: LD_INT 4
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 3
39515: PUSH
39516: LD_INT 4
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: PUSH
39526: LD_INT 3
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 2
39535: PUSH
39536: LD_INT 2
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 4
39545: PUSH
39546: LD_INT 2
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 2
39555: PUSH
39556: LD_INT 4
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 0
39565: PUSH
39566: LD_INT 4
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 0
39575: PUSH
39576: LD_INT 3
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 1
39585: PUSH
39586: LD_INT 4
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 5
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_INT 5
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: LD_INT 4
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 3
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 2
39637: PUSH
39638: LD_INT 5
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 2
39647: NEG
39648: PUSH
39649: LD_INT 3
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 3
39658: NEG
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 3
39669: NEG
39670: PUSH
39671: LD_INT 1
39673: NEG
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: NEG
39682: PUSH
39683: LD_INT 0
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 2
39692: NEG
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 3
39703: NEG
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 4
39714: NEG
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 4
39725: NEG
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 4
39737: NEG
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 2
39749: NEG
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 4
39760: NEG
39761: PUSH
39762: LD_INT 4
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 4
39772: NEG
39773: PUSH
39774: LD_INT 5
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 3
39784: NEG
39785: PUSH
39786: LD_INT 4
39788: NEG
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 3
39796: NEG
39797: PUSH
39798: LD_INT 3
39800: NEG
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 4
39808: NEG
39809: PUSH
39810: LD_INT 3
39812: NEG
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 5
39820: NEG
39821: PUSH
39822: LD_INT 4
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 5
39832: NEG
39833: PUSH
39834: LD_INT 5
39836: NEG
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 3
39844: NEG
39845: PUSH
39846: LD_INT 5
39848: NEG
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 5
39856: NEG
39857: PUSH
39858: LD_INT 3
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
39913: LD_ADDR_VAR 0 30
39917: PUSH
39918: LD_INT 4
39920: PUSH
39921: LD_INT 4
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 4
39930: PUSH
39931: LD_INT 3
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 5
39940: PUSH
39941: LD_INT 4
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 5
39950: PUSH
39951: LD_INT 5
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 4
39960: PUSH
39961: LD_INT 5
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 3
39970: PUSH
39971: LD_INT 4
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: PUSH
39981: LD_INT 3
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 5
39990: PUSH
39991: LD_INT 3
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: LD_INT 5
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 0
40010: PUSH
40011: LD_INT 3
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 0
40020: PUSH
40021: LD_INT 2
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 1
40030: PUSH
40031: LD_INT 3
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 1
40040: PUSH
40041: LD_INT 4
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 0
40050: PUSH
40051: LD_INT 4
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 1
40060: NEG
40061: PUSH
40062: LD_INT 3
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 1
40071: NEG
40072: PUSH
40073: LD_INT 2
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: LD_INT 4
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 2
40092: NEG
40093: PUSH
40094: LD_INT 2
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 4
40103: NEG
40104: PUSH
40105: LD_INT 0
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 4
40114: NEG
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 3
40126: NEG
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 3
40137: NEG
40138: PUSH
40139: LD_INT 1
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 4
40148: NEG
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 5
40159: NEG
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 5
40170: NEG
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 5
40182: NEG
40183: PUSH
40184: LD_INT 2
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 3
40194: NEG
40195: PUSH
40196: LD_INT 2
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 3
40205: NEG
40206: PUSH
40207: LD_INT 3
40209: NEG
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 3
40217: NEG
40218: PUSH
40219: LD_INT 4
40221: NEG
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 2
40229: NEG
40230: PUSH
40231: LD_INT 3
40233: NEG
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 2
40241: NEG
40242: PUSH
40243: LD_INT 2
40245: NEG
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 3
40253: NEG
40254: PUSH
40255: LD_INT 2
40257: NEG
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 4
40265: NEG
40266: PUSH
40267: LD_INT 3
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 4
40277: NEG
40278: PUSH
40279: LD_INT 4
40281: NEG
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: NEG
40290: PUSH
40291: LD_INT 4
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 4
40301: NEG
40302: PUSH
40303: LD_INT 2
40305: NEG
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 4
40316: NEG
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: LD_INT 5
40327: NEG
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: LD_INT 4
40338: NEG
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 1
40346: PUSH
40347: LD_INT 3
40349: NEG
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 0
40357: PUSH
40358: LD_INT 3
40360: NEG
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 4
40372: NEG
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 1
40380: NEG
40381: PUSH
40382: LD_INT 5
40384: NEG
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PUSH
40390: LD_INT 2
40392: PUSH
40393: LD_INT 3
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 2
40403: NEG
40404: PUSH
40405: LD_INT 5
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: LIST
40430: LIST
40431: LIST
40432: LIST
40433: LIST
40434: LIST
40435: LIST
40436: LIST
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40460: LD_ADDR_VAR 0 31
40464: PUSH
40465: LD_INT 0
40467: PUSH
40468: LD_INT 4
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: LD_INT 3
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: PUSH
40488: LD_INT 4
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: LD_INT 5
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: LD_INT 5
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: NEG
40518: PUSH
40519: LD_INT 4
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: NEG
40529: PUSH
40530: LD_INT 3
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 2
40539: PUSH
40540: LD_INT 5
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 2
40549: NEG
40550: PUSH
40551: LD_INT 3
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 3
40560: NEG
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 3
40571: NEG
40572: PUSH
40573: LD_INT 1
40575: NEG
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 2
40583: NEG
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 2
40594: NEG
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 3
40605: NEG
40606: PUSH
40607: LD_INT 1
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 4
40616: NEG
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 4
40627: NEG
40628: PUSH
40629: LD_INT 1
40631: NEG
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 4
40639: NEG
40640: PUSH
40641: LD_INT 2
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 2
40651: NEG
40652: PUSH
40653: LD_INT 2
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 4
40662: NEG
40663: PUSH
40664: LD_INT 4
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 4
40674: NEG
40675: PUSH
40676: LD_INT 5
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 3
40686: NEG
40687: PUSH
40688: LD_INT 4
40690: NEG
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 3
40698: NEG
40699: PUSH
40700: LD_INT 3
40702: NEG
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 4
40710: NEG
40711: PUSH
40712: LD_INT 3
40714: NEG
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: LD_INT 5
40722: NEG
40723: PUSH
40724: LD_INT 4
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 5
40734: NEG
40735: PUSH
40736: LD_INT 5
40738: NEG
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 3
40746: NEG
40747: PUSH
40748: LD_INT 5
40750: NEG
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 5
40758: NEG
40759: PUSH
40760: LD_INT 3
40762: NEG
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: LD_INT 3
40773: NEG
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: LD_INT 4
40784: NEG
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: LD_INT 3
40795: NEG
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: LD_INT 2
40806: NEG
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: LD_INT 2
40817: NEG
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 3
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 1
40837: NEG
40838: PUSH
40839: LD_INT 4
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: LD_INT 2
40852: NEG
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 2
40860: NEG
40861: PUSH
40862: LD_INT 4
40864: NEG
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 4
40872: PUSH
40873: LD_INT 0
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 4
40882: PUSH
40883: LD_INT 1
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 5
40893: PUSH
40894: LD_INT 0
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 5
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 4
40913: PUSH
40914: LD_INT 1
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 3
40923: PUSH
40924: LD_INT 0
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 3
40933: PUSH
40934: LD_INT 1
40936: NEG
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 3
40944: PUSH
40945: LD_INT 2
40947: NEG
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 5
40955: PUSH
40956: LD_INT 2
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: LIST
40982: LIST
40983: LIST
40984: LIST
40985: LIST
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41010: LD_ADDR_VAR 0 32
41014: PUSH
41015: LD_INT 4
41017: NEG
41018: PUSH
41019: LD_INT 0
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 4
41028: NEG
41029: PUSH
41030: LD_INT 1
41032: NEG
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 3
41040: NEG
41041: PUSH
41042: LD_INT 0
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: NEG
41052: PUSH
41053: LD_INT 1
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 4
41062: NEG
41063: PUSH
41064: LD_INT 1
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 5
41073: NEG
41074: PUSH
41075: LD_INT 0
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 5
41084: NEG
41085: PUSH
41086: LD_INT 1
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 5
41096: NEG
41097: PUSH
41098: LD_INT 2
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 3
41108: NEG
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 3
41119: NEG
41120: PUSH
41121: LD_INT 3
41123: NEG
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 3
41131: NEG
41132: PUSH
41133: LD_INT 4
41135: NEG
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 2
41143: NEG
41144: PUSH
41145: LD_INT 3
41147: NEG
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 2
41155: NEG
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 4
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 4
41191: NEG
41192: PUSH
41193: LD_INT 4
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: LD_INT 4
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: LD_INT 4
41215: NEG
41216: PUSH
41217: LD_INT 2
41219: NEG
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 0
41227: PUSH
41228: LD_INT 4
41230: NEG
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 0
41238: PUSH
41239: LD_INT 5
41241: NEG
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 1
41249: PUSH
41250: LD_INT 4
41252: NEG
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 1
41260: PUSH
41261: LD_INT 3
41263: NEG
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: LD_INT 0
41271: PUSH
41272: LD_INT 3
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 1
41282: NEG
41283: PUSH
41284: LD_INT 4
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 1
41294: NEG
41295: PUSH
41296: LD_INT 5
41298: NEG
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 3
41309: NEG
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 2
41317: NEG
41318: PUSH
41319: LD_INT 5
41321: NEG
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 3
41329: PUSH
41330: LD_INT 0
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 3
41339: PUSH
41340: LD_INT 1
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 4
41360: PUSH
41361: LD_INT 1
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 3
41370: PUSH
41371: LD_INT 1
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 0
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 2
41390: PUSH
41391: LD_INT 1
41393: NEG
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 2
41401: PUSH
41402: LD_INT 2
41404: NEG
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 4
41412: PUSH
41413: LD_INT 2
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 4
41422: PUSH
41423: LD_INT 4
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 4
41432: PUSH
41433: LD_INT 3
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 5
41442: PUSH
41443: LD_INT 4
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 5
41452: PUSH
41453: LD_INT 5
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: LD_INT 5
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 3
41472: PUSH
41473: LD_INT 4
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 3
41482: PUSH
41483: LD_INT 3
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 5
41492: PUSH
41493: LD_INT 3
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 3
41502: PUSH
41503: LD_INT 5
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: LIST
41516: LIST
41517: LIST
41518: LIST
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41557: LD_ADDR_VAR 0 33
41561: PUSH
41562: LD_INT 4
41564: NEG
41565: PUSH
41566: LD_INT 4
41568: NEG
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 4
41576: NEG
41577: PUSH
41578: LD_INT 5
41580: NEG
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 3
41588: NEG
41589: PUSH
41590: LD_INT 4
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 3
41600: NEG
41601: PUSH
41602: LD_INT 3
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 4
41612: NEG
41613: PUSH
41614: LD_INT 3
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 5
41624: NEG
41625: PUSH
41626: LD_INT 4
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 5
41636: NEG
41637: PUSH
41638: LD_INT 5
41640: NEG
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 3
41648: NEG
41649: PUSH
41650: LD_INT 5
41652: NEG
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: LD_INT 5
41660: NEG
41661: PUSH
41662: LD_INT 3
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 0
41672: PUSH
41673: LD_INT 3
41675: NEG
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 0
41683: PUSH
41684: LD_INT 4
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 1
41694: PUSH
41695: LD_INT 3
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 2
41708: NEG
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 0
41716: PUSH
41717: LD_INT 2
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: LD_INT 3
41731: NEG
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 1
41739: NEG
41740: PUSH
41741: LD_INT 4
41743: NEG
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 2
41751: PUSH
41752: LD_INT 2
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 2
41762: NEG
41763: PUSH
41764: LD_INT 4
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 4
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 4
41784: PUSH
41785: LD_INT 1
41787: NEG
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 5
41795: PUSH
41796: LD_INT 0
41798: PUSH
41799: EMPTY
41800: LIST
41801: LIST
41802: PUSH
41803: LD_INT 5
41805: PUSH
41806: LD_INT 1
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 4
41815: PUSH
41816: LD_INT 1
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: PUSH
41823: LD_INT 3
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: PUSH
41833: LD_INT 3
41835: PUSH
41836: LD_INT 1
41838: NEG
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 3
41846: PUSH
41847: LD_INT 2
41849: NEG
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 5
41857: PUSH
41858: LD_INT 2
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: PUSH
41865: LD_INT 3
41867: PUSH
41868: LD_INT 3
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 3
41877: PUSH
41878: LD_INT 2
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 4
41887: PUSH
41888: LD_INT 3
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 4
41897: PUSH
41898: LD_INT 4
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 3
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 2
41917: PUSH
41918: LD_INT 3
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 2
41927: PUSH
41928: LD_INT 2
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: LD_INT 4
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 2
41947: PUSH
41948: LD_INT 4
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: LD_INT 4
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 0
41967: PUSH
41968: LD_INT 3
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 1
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: PUSH
41988: LD_INT 5
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 0
41997: PUSH
41998: LD_INT 5
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 1
42007: NEG
42008: PUSH
42009: LD_INT 4
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: LD_INT 3
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 2
42029: PUSH
42030: LD_INT 5
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 2
42039: NEG
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42095: LD_ADDR_VAR 0 34
42099: PUSH
42100: LD_INT 0
42102: PUSH
42103: LD_INT 4
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: LD_INT 5
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 1
42124: PUSH
42125: LD_INT 4
42127: NEG
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: LD_INT 3
42138: NEG
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 0
42146: PUSH
42147: LD_INT 3
42149: NEG
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 1
42157: NEG
42158: PUSH
42159: LD_INT 4
42161: NEG
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 1
42169: NEG
42170: PUSH
42171: LD_INT 5
42173: NEG
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: PUSH
42182: LD_INT 3
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 2
42192: NEG
42193: PUSH
42194: LD_INT 5
42196: NEG
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PUSH
42202: LD_INT 3
42204: PUSH
42205: LD_INT 0
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: LD_INT 1
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 4
42225: PUSH
42226: LD_INT 0
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 4
42235: PUSH
42236: LD_INT 1
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 3
42245: PUSH
42246: LD_INT 1
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 2
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 2
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 2
42276: PUSH
42277: LD_INT 2
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 4
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: PUSH
42298: LD_INT 4
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 4
42307: PUSH
42308: LD_INT 3
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 5
42317: PUSH
42318: LD_INT 4
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 5
42327: PUSH
42328: LD_INT 5
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 4
42337: PUSH
42338: LD_INT 5
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 3
42347: PUSH
42348: LD_INT 4
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 3
42357: PUSH
42358: LD_INT 3
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 5
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 3
42377: PUSH
42378: LD_INT 5
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 0
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 0
42397: PUSH
42398: LD_INT 2
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: LD_INT 3
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 1
42417: PUSH
42418: LD_INT 4
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 0
42427: PUSH
42428: LD_INT 4
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 1
42437: NEG
42438: PUSH
42439: LD_INT 3
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 1
42448: NEG
42449: PUSH
42450: LD_INT 2
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: PUSH
42457: LD_INT 2
42459: PUSH
42460: LD_INT 4
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: LD_INT 2
42469: NEG
42470: PUSH
42471: LD_INT 2
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 4
42480: NEG
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 4
42491: NEG
42492: PUSH
42493: LD_INT 1
42495: NEG
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 3
42503: NEG
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: NEG
42515: PUSH
42516: LD_INT 1
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 4
42525: NEG
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 5
42536: NEG
42537: PUSH
42538: LD_INT 0
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 5
42547: NEG
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 5
42559: NEG
42560: PUSH
42561: LD_INT 2
42563: NEG
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 3
42571: NEG
42572: PUSH
42573: LD_INT 2
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: LIST
42584: LIST
42585: LIST
42586: LIST
42587: LIST
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: ST_TO_ADDR
// end ; end ;
42627: GO 42630
42629: POP
// case btype of b_depot , b_warehouse :
42630: LD_VAR 0 1
42634: PUSH
42635: LD_INT 0
42637: DOUBLE
42638: EQUAL
42639: IFTRUE 42649
42641: LD_INT 1
42643: DOUBLE
42644: EQUAL
42645: IFTRUE 42649
42647: GO 42850
42649: POP
// case nation of nation_american :
42650: LD_VAR 0 5
42654: PUSH
42655: LD_INT 1
42657: DOUBLE
42658: EQUAL
42659: IFTRUE 42663
42661: GO 42719
42663: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42664: LD_ADDR_VAR 0 9
42668: PUSH
42669: LD_VAR 0 11
42673: PUSH
42674: LD_VAR 0 12
42678: PUSH
42679: LD_VAR 0 13
42683: PUSH
42684: LD_VAR 0 14
42688: PUSH
42689: LD_VAR 0 15
42693: PUSH
42694: LD_VAR 0 16
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: PUSH
42707: LD_VAR 0 4
42711: PUSH
42712: LD_INT 1
42714: PLUS
42715: ARRAY
42716: ST_TO_ADDR
42717: GO 42848
42719: LD_INT 2
42721: DOUBLE
42722: EQUAL
42723: IFTRUE 42727
42725: GO 42783
42727: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42728: LD_ADDR_VAR 0 9
42732: PUSH
42733: LD_VAR 0 17
42737: PUSH
42738: LD_VAR 0 18
42742: PUSH
42743: LD_VAR 0 19
42747: PUSH
42748: LD_VAR 0 20
42752: PUSH
42753: LD_VAR 0 21
42757: PUSH
42758: LD_VAR 0 22
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: PUSH
42771: LD_VAR 0 4
42775: PUSH
42776: LD_INT 1
42778: PLUS
42779: ARRAY
42780: ST_TO_ADDR
42781: GO 42848
42783: LD_INT 3
42785: DOUBLE
42786: EQUAL
42787: IFTRUE 42791
42789: GO 42847
42791: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42792: LD_ADDR_VAR 0 9
42796: PUSH
42797: LD_VAR 0 23
42801: PUSH
42802: LD_VAR 0 24
42806: PUSH
42807: LD_VAR 0 25
42811: PUSH
42812: LD_VAR 0 26
42816: PUSH
42817: LD_VAR 0 27
42821: PUSH
42822: LD_VAR 0 28
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: PUSH
42835: LD_VAR 0 4
42839: PUSH
42840: LD_INT 1
42842: PLUS
42843: ARRAY
42844: ST_TO_ADDR
42845: GO 42848
42847: POP
42848: GO 43403
42850: LD_INT 2
42852: DOUBLE
42853: EQUAL
42854: IFTRUE 42864
42856: LD_INT 3
42858: DOUBLE
42859: EQUAL
42860: IFTRUE 42864
42862: GO 42920
42864: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42865: LD_ADDR_VAR 0 9
42869: PUSH
42870: LD_VAR 0 29
42874: PUSH
42875: LD_VAR 0 30
42879: PUSH
42880: LD_VAR 0 31
42884: PUSH
42885: LD_VAR 0 32
42889: PUSH
42890: LD_VAR 0 33
42894: PUSH
42895: LD_VAR 0 34
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: LIST
42907: PUSH
42908: LD_VAR 0 4
42912: PUSH
42913: LD_INT 1
42915: PLUS
42916: ARRAY
42917: ST_TO_ADDR
42918: GO 43403
42920: LD_INT 16
42922: DOUBLE
42923: EQUAL
42924: IFTRUE 42982
42926: LD_INT 17
42928: DOUBLE
42929: EQUAL
42930: IFTRUE 42982
42932: LD_INT 18
42934: DOUBLE
42935: EQUAL
42936: IFTRUE 42982
42938: LD_INT 19
42940: DOUBLE
42941: EQUAL
42942: IFTRUE 42982
42944: LD_INT 22
42946: DOUBLE
42947: EQUAL
42948: IFTRUE 42982
42950: LD_INT 20
42952: DOUBLE
42953: EQUAL
42954: IFTRUE 42982
42956: LD_INT 21
42958: DOUBLE
42959: EQUAL
42960: IFTRUE 42982
42962: LD_INT 23
42964: DOUBLE
42965: EQUAL
42966: IFTRUE 42982
42968: LD_INT 24
42970: DOUBLE
42971: EQUAL
42972: IFTRUE 42982
42974: LD_INT 25
42976: DOUBLE
42977: EQUAL
42978: IFTRUE 42982
42980: GO 43038
42982: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
42983: LD_ADDR_VAR 0 9
42987: PUSH
42988: LD_VAR 0 35
42992: PUSH
42993: LD_VAR 0 36
42997: PUSH
42998: LD_VAR 0 37
43002: PUSH
43003: LD_VAR 0 38
43007: PUSH
43008: LD_VAR 0 39
43012: PUSH
43013: LD_VAR 0 40
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: PUSH
43026: LD_VAR 0 4
43030: PUSH
43031: LD_INT 1
43033: PLUS
43034: ARRAY
43035: ST_TO_ADDR
43036: GO 43403
43038: LD_INT 6
43040: DOUBLE
43041: EQUAL
43042: IFTRUE 43094
43044: LD_INT 7
43046: DOUBLE
43047: EQUAL
43048: IFTRUE 43094
43050: LD_INT 8
43052: DOUBLE
43053: EQUAL
43054: IFTRUE 43094
43056: LD_INT 13
43058: DOUBLE
43059: EQUAL
43060: IFTRUE 43094
43062: LD_INT 12
43064: DOUBLE
43065: EQUAL
43066: IFTRUE 43094
43068: LD_INT 15
43070: DOUBLE
43071: EQUAL
43072: IFTRUE 43094
43074: LD_INT 11
43076: DOUBLE
43077: EQUAL
43078: IFTRUE 43094
43080: LD_INT 14
43082: DOUBLE
43083: EQUAL
43084: IFTRUE 43094
43086: LD_INT 10
43088: DOUBLE
43089: EQUAL
43090: IFTRUE 43094
43092: GO 43150
43094: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43095: LD_ADDR_VAR 0 9
43099: PUSH
43100: LD_VAR 0 41
43104: PUSH
43105: LD_VAR 0 42
43109: PUSH
43110: LD_VAR 0 43
43114: PUSH
43115: LD_VAR 0 44
43119: PUSH
43120: LD_VAR 0 45
43124: PUSH
43125: LD_VAR 0 46
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: PUSH
43138: LD_VAR 0 4
43142: PUSH
43143: LD_INT 1
43145: PLUS
43146: ARRAY
43147: ST_TO_ADDR
43148: GO 43403
43150: LD_INT 36
43152: DOUBLE
43153: EQUAL
43154: IFTRUE 43158
43156: GO 43214
43158: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43159: LD_ADDR_VAR 0 9
43163: PUSH
43164: LD_VAR 0 47
43168: PUSH
43169: LD_VAR 0 48
43173: PUSH
43174: LD_VAR 0 49
43178: PUSH
43179: LD_VAR 0 50
43183: PUSH
43184: LD_VAR 0 51
43188: PUSH
43189: LD_VAR 0 52
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: PUSH
43202: LD_VAR 0 4
43206: PUSH
43207: LD_INT 1
43209: PLUS
43210: ARRAY
43211: ST_TO_ADDR
43212: GO 43403
43214: LD_INT 4
43216: DOUBLE
43217: EQUAL
43218: IFTRUE 43240
43220: LD_INT 5
43222: DOUBLE
43223: EQUAL
43224: IFTRUE 43240
43226: LD_INT 34
43228: DOUBLE
43229: EQUAL
43230: IFTRUE 43240
43232: LD_INT 37
43234: DOUBLE
43235: EQUAL
43236: IFTRUE 43240
43238: GO 43296
43240: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43241: LD_ADDR_VAR 0 9
43245: PUSH
43246: LD_VAR 0 53
43250: PUSH
43251: LD_VAR 0 54
43255: PUSH
43256: LD_VAR 0 55
43260: PUSH
43261: LD_VAR 0 56
43265: PUSH
43266: LD_VAR 0 57
43270: PUSH
43271: LD_VAR 0 58
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: LIST
43280: LIST
43281: LIST
43282: LIST
43283: PUSH
43284: LD_VAR 0 4
43288: PUSH
43289: LD_INT 1
43291: PLUS
43292: ARRAY
43293: ST_TO_ADDR
43294: GO 43403
43296: LD_INT 31
43298: DOUBLE
43299: EQUAL
43300: IFTRUE 43346
43302: LD_INT 32
43304: DOUBLE
43305: EQUAL
43306: IFTRUE 43346
43308: LD_INT 33
43310: DOUBLE
43311: EQUAL
43312: IFTRUE 43346
43314: LD_INT 27
43316: DOUBLE
43317: EQUAL
43318: IFTRUE 43346
43320: LD_INT 26
43322: DOUBLE
43323: EQUAL
43324: IFTRUE 43346
43326: LD_INT 28
43328: DOUBLE
43329: EQUAL
43330: IFTRUE 43346
43332: LD_INT 29
43334: DOUBLE
43335: EQUAL
43336: IFTRUE 43346
43338: LD_INT 30
43340: DOUBLE
43341: EQUAL
43342: IFTRUE 43346
43344: GO 43402
43346: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43347: LD_ADDR_VAR 0 9
43351: PUSH
43352: LD_VAR 0 59
43356: PUSH
43357: LD_VAR 0 60
43361: PUSH
43362: LD_VAR 0 61
43366: PUSH
43367: LD_VAR 0 62
43371: PUSH
43372: LD_VAR 0 63
43376: PUSH
43377: LD_VAR 0 64
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: PUSH
43390: LD_VAR 0 4
43394: PUSH
43395: LD_INT 1
43397: PLUS
43398: ARRAY
43399: ST_TO_ADDR
43400: GO 43403
43402: POP
// temp_list2 = [ ] ;
43403: LD_ADDR_VAR 0 10
43407: PUSH
43408: EMPTY
43409: ST_TO_ADDR
// for i in temp_list do
43410: LD_ADDR_VAR 0 8
43414: PUSH
43415: LD_VAR 0 9
43419: PUSH
43420: FOR_IN
43421: IFFALSE 43473
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43423: LD_ADDR_VAR 0 10
43427: PUSH
43428: LD_VAR 0 10
43432: PUSH
43433: LD_VAR 0 8
43437: PUSH
43438: LD_INT 1
43440: ARRAY
43441: PUSH
43442: LD_VAR 0 2
43446: PLUS
43447: PUSH
43448: LD_VAR 0 8
43452: PUSH
43453: LD_INT 2
43455: ARRAY
43456: PUSH
43457: LD_VAR 0 3
43461: PLUS
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: EMPTY
43468: LIST
43469: ADD
43470: ST_TO_ADDR
43471: GO 43420
43473: POP
43474: POP
// result = temp_list2 ;
43475: LD_ADDR_VAR 0 7
43479: PUSH
43480: LD_VAR 0 10
43484: ST_TO_ADDR
// end ;
43485: LD_VAR 0 7
43489: RET
// export function EnemyInRange ( unit , dist ) ; begin
43490: LD_INT 0
43492: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43493: LD_ADDR_VAR 0 3
43497: PUSH
43498: LD_VAR 0 1
43502: PPUSH
43503: CALL_OW 255
43507: PPUSH
43508: LD_VAR 0 1
43512: PPUSH
43513: CALL_OW 250
43517: PPUSH
43518: LD_VAR 0 1
43522: PPUSH
43523: CALL_OW 251
43527: PPUSH
43528: LD_VAR 0 2
43532: PPUSH
43533: CALL 16886 0 4
43537: PUSH
43538: LD_INT 4
43540: ARRAY
43541: ST_TO_ADDR
// end ;
43542: LD_VAR 0 3
43546: RET
// export function PlayerSeeMe ( unit ) ; begin
43547: LD_INT 0
43549: PPUSH
// result := See ( your_side , unit ) ;
43550: LD_ADDR_VAR 0 2
43554: PUSH
43555: LD_OWVAR 2
43559: PPUSH
43560: LD_VAR 0 1
43564: PPUSH
43565: CALL_OW 292
43569: ST_TO_ADDR
// end ;
43570: LD_VAR 0 2
43574: RET
// export function ReverseDir ( unit ) ; begin
43575: LD_INT 0
43577: PPUSH
// if not unit then
43578: LD_VAR 0 1
43582: NOT
43583: IFFALSE 43587
// exit ;
43585: GO 43610
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43587: LD_ADDR_VAR 0 2
43591: PUSH
43592: LD_VAR 0 1
43596: PPUSH
43597: CALL_OW 254
43601: PUSH
43602: LD_INT 3
43604: PLUS
43605: PUSH
43606: LD_INT 6
43608: MOD
43609: ST_TO_ADDR
// end ;
43610: LD_VAR 0 2
43614: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
43615: LD_INT 0
43617: PPUSH
43618: PPUSH
43619: PPUSH
43620: PPUSH
43621: PPUSH
// if not hexes then
43622: LD_VAR 0 2
43626: NOT
43627: IFFALSE 43631
// exit ;
43629: GO 43779
// dist := 9999 ;
43631: LD_ADDR_VAR 0 5
43635: PUSH
43636: LD_INT 9999
43638: ST_TO_ADDR
// for i = 1 to hexes do
43639: LD_ADDR_VAR 0 4
43643: PUSH
43644: DOUBLE
43645: LD_INT 1
43647: DEC
43648: ST_TO_ADDR
43649: LD_VAR 0 2
43653: PUSH
43654: FOR_TO
43655: IFFALSE 43767
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
43657: LD_VAR 0 1
43661: PPUSH
43662: LD_VAR 0 2
43666: PUSH
43667: LD_VAR 0 4
43671: ARRAY
43672: PUSH
43673: LD_INT 1
43675: ARRAY
43676: PPUSH
43677: LD_VAR 0 2
43681: PUSH
43682: LD_VAR 0 4
43686: ARRAY
43687: PUSH
43688: LD_INT 2
43690: ARRAY
43691: PPUSH
43692: CALL_OW 297
43696: PUSH
43697: LD_VAR 0 5
43701: LESS
43702: IFFALSE 43765
// begin hex := hexes [ i ] ;
43704: LD_ADDR_VAR 0 7
43708: PUSH
43709: LD_VAR 0 2
43713: PUSH
43714: LD_VAR 0 4
43718: ARRAY
43719: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43720: LD_ADDR_VAR 0 5
43724: PUSH
43725: LD_VAR 0 1
43729: PPUSH
43730: LD_VAR 0 2
43734: PUSH
43735: LD_VAR 0 4
43739: ARRAY
43740: PUSH
43741: LD_INT 1
43743: ARRAY
43744: PPUSH
43745: LD_VAR 0 2
43749: PUSH
43750: LD_VAR 0 4
43754: ARRAY
43755: PUSH
43756: LD_INT 2
43758: ARRAY
43759: PPUSH
43760: CALL_OW 297
43764: ST_TO_ADDR
// end ; end ;
43765: GO 43654
43767: POP
43768: POP
// result := hex ;
43769: LD_ADDR_VAR 0 3
43773: PUSH
43774: LD_VAR 0 7
43778: ST_TO_ADDR
// end ;
43779: LD_VAR 0 3
43783: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43784: LD_INT 0
43786: PPUSH
43787: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43788: LD_VAR 0 1
43792: NOT
43793: PUSH
43794: LD_VAR 0 1
43798: PUSH
43799: LD_INT 21
43801: PUSH
43802: LD_INT 2
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 23
43811: PUSH
43812: LD_INT 2
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PPUSH
43823: CALL_OW 69
43827: IN
43828: NOT
43829: OR
43830: IFFALSE 43834
// exit ;
43832: GO 43881
// for i = 1 to 3 do
43834: LD_ADDR_VAR 0 3
43838: PUSH
43839: DOUBLE
43840: LD_INT 1
43842: DEC
43843: ST_TO_ADDR
43844: LD_INT 3
43846: PUSH
43847: FOR_TO
43848: IFFALSE 43879
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
43850: LD_VAR 0 1
43854: PPUSH
43855: CALL_OW 250
43859: PPUSH
43860: LD_VAR 0 1
43864: PPUSH
43865: CALL_OW 251
43869: PPUSH
43870: LD_INT 1
43872: PPUSH
43873: CALL_OW 453
43877: GO 43847
43879: POP
43880: POP
// end ;
43881: LD_VAR 0 2
43885: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
43886: LD_INT 0
43888: PPUSH
43889: PPUSH
43890: PPUSH
43891: PPUSH
43892: PPUSH
43893: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
43894: LD_VAR 0 1
43898: NOT
43899: PUSH
43900: LD_VAR 0 2
43904: NOT
43905: OR
43906: PUSH
43907: LD_VAR 0 1
43911: PPUSH
43912: CALL_OW 314
43916: OR
43917: IFFALSE 43921
// exit ;
43919: GO 44362
// x := GetX ( enemy_unit ) ;
43921: LD_ADDR_VAR 0 7
43925: PUSH
43926: LD_VAR 0 2
43930: PPUSH
43931: CALL_OW 250
43935: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43936: LD_ADDR_VAR 0 8
43940: PUSH
43941: LD_VAR 0 2
43945: PPUSH
43946: CALL_OW 251
43950: ST_TO_ADDR
// if not x or not y then
43951: LD_VAR 0 7
43955: NOT
43956: PUSH
43957: LD_VAR 0 8
43961: NOT
43962: OR
43963: IFFALSE 43967
// exit ;
43965: GO 44362
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43967: LD_ADDR_VAR 0 6
43971: PUSH
43972: LD_VAR 0 7
43976: PPUSH
43977: LD_INT 0
43979: PPUSH
43980: LD_INT 4
43982: PPUSH
43983: CALL_OW 272
43987: PUSH
43988: LD_VAR 0 8
43992: PPUSH
43993: LD_INT 0
43995: PPUSH
43996: LD_INT 4
43998: PPUSH
43999: CALL_OW 273
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_VAR 0 7
44012: PPUSH
44013: LD_INT 1
44015: PPUSH
44016: LD_INT 4
44018: PPUSH
44019: CALL_OW 272
44023: PUSH
44024: LD_VAR 0 8
44028: PPUSH
44029: LD_INT 1
44031: PPUSH
44032: LD_INT 4
44034: PPUSH
44035: CALL_OW 273
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_VAR 0 7
44048: PPUSH
44049: LD_INT 2
44051: PPUSH
44052: LD_INT 4
44054: PPUSH
44055: CALL_OW 272
44059: PUSH
44060: LD_VAR 0 8
44064: PPUSH
44065: LD_INT 2
44067: PPUSH
44068: LD_INT 4
44070: PPUSH
44071: CALL_OW 273
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_VAR 0 7
44084: PPUSH
44085: LD_INT 3
44087: PPUSH
44088: LD_INT 4
44090: PPUSH
44091: CALL_OW 272
44095: PUSH
44096: LD_VAR 0 8
44100: PPUSH
44101: LD_INT 3
44103: PPUSH
44104: LD_INT 4
44106: PPUSH
44107: CALL_OW 273
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_VAR 0 7
44120: PPUSH
44121: LD_INT 4
44123: PPUSH
44124: LD_INT 4
44126: PPUSH
44127: CALL_OW 272
44131: PUSH
44132: LD_VAR 0 8
44136: PPUSH
44137: LD_INT 4
44139: PPUSH
44140: LD_INT 4
44142: PPUSH
44143: CALL_OW 273
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_VAR 0 7
44156: PPUSH
44157: LD_INT 5
44159: PPUSH
44160: LD_INT 4
44162: PPUSH
44163: CALL_OW 272
44167: PUSH
44168: LD_VAR 0 8
44172: PPUSH
44173: LD_INT 5
44175: PPUSH
44176: LD_INT 4
44178: PPUSH
44179: CALL_OW 273
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: LIST
44195: ST_TO_ADDR
// for i = tmp downto 1 do
44196: LD_ADDR_VAR 0 4
44200: PUSH
44201: DOUBLE
44202: LD_VAR 0 6
44206: INC
44207: ST_TO_ADDR
44208: LD_INT 1
44210: PUSH
44211: FOR_DOWNTO
44212: IFFALSE 44313
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44214: LD_VAR 0 6
44218: PUSH
44219: LD_VAR 0 4
44223: ARRAY
44224: PUSH
44225: LD_INT 1
44227: ARRAY
44228: PPUSH
44229: LD_VAR 0 6
44233: PUSH
44234: LD_VAR 0 4
44238: ARRAY
44239: PUSH
44240: LD_INT 2
44242: ARRAY
44243: PPUSH
44244: CALL_OW 488
44248: NOT
44249: PUSH
44250: LD_VAR 0 6
44254: PUSH
44255: LD_VAR 0 4
44259: ARRAY
44260: PUSH
44261: LD_INT 1
44263: ARRAY
44264: PPUSH
44265: LD_VAR 0 6
44269: PUSH
44270: LD_VAR 0 4
44274: ARRAY
44275: PUSH
44276: LD_INT 2
44278: ARRAY
44279: PPUSH
44280: CALL_OW 428
44284: PUSH
44285: LD_INT 0
44287: NONEQUAL
44288: OR
44289: IFFALSE 44311
// tmp := Delete ( tmp , i ) ;
44291: LD_ADDR_VAR 0 6
44295: PUSH
44296: LD_VAR 0 6
44300: PPUSH
44301: LD_VAR 0 4
44305: PPUSH
44306: CALL_OW 3
44310: ST_TO_ADDR
44311: GO 44211
44313: POP
44314: POP
// j := GetClosestHex ( unit , tmp ) ;
44315: LD_ADDR_VAR 0 5
44319: PUSH
44320: LD_VAR 0 1
44324: PPUSH
44325: LD_VAR 0 6
44329: PPUSH
44330: CALL 43615 0 2
44334: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44335: LD_VAR 0 1
44339: PPUSH
44340: LD_VAR 0 5
44344: PUSH
44345: LD_INT 1
44347: ARRAY
44348: PPUSH
44349: LD_VAR 0 5
44353: PUSH
44354: LD_INT 2
44356: ARRAY
44357: PPUSH
44358: CALL_OW 111
// end ;
44362: LD_VAR 0 3
44366: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44367: LD_INT 0
44369: PPUSH
44370: PPUSH
44371: PPUSH
// uc_side = 0 ;
44372: LD_ADDR_OWVAR 20
44376: PUSH
44377: LD_INT 0
44379: ST_TO_ADDR
// uc_nation = 0 ;
44380: LD_ADDR_OWVAR 21
44384: PUSH
44385: LD_INT 0
44387: ST_TO_ADDR
// InitHc_All ( ) ;
44388: CALL_OW 584
// InitVc ;
44392: CALL_OW 20
// if mastodonts then
44396: LD_VAR 0 6
44400: IFFALSE 44467
// for i = 1 to mastodonts do
44402: LD_ADDR_VAR 0 11
44406: PUSH
44407: DOUBLE
44408: LD_INT 1
44410: DEC
44411: ST_TO_ADDR
44412: LD_VAR 0 6
44416: PUSH
44417: FOR_TO
44418: IFFALSE 44465
// begin vc_chassis := 31 ;
44420: LD_ADDR_OWVAR 37
44424: PUSH
44425: LD_INT 31
44427: ST_TO_ADDR
// vc_control := control_rider ;
44428: LD_ADDR_OWVAR 38
44432: PUSH
44433: LD_INT 4
44435: ST_TO_ADDR
// animal := CreateVehicle ;
44436: LD_ADDR_VAR 0 12
44440: PUSH
44441: CALL_OW 45
44445: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44446: LD_VAR 0 12
44450: PPUSH
44451: LD_VAR 0 8
44455: PPUSH
44456: LD_INT 0
44458: PPUSH
44459: CALL 46655 0 3
// end ;
44463: GO 44417
44465: POP
44466: POP
// if horses then
44467: LD_VAR 0 5
44471: IFFALSE 44538
// for i = 1 to horses do
44473: LD_ADDR_VAR 0 11
44477: PUSH
44478: DOUBLE
44479: LD_INT 1
44481: DEC
44482: ST_TO_ADDR
44483: LD_VAR 0 5
44487: PUSH
44488: FOR_TO
44489: IFFALSE 44536
// begin hc_class := 21 ;
44491: LD_ADDR_OWVAR 28
44495: PUSH
44496: LD_INT 21
44498: ST_TO_ADDR
// hc_gallery :=  ;
44499: LD_ADDR_OWVAR 33
44503: PUSH
44504: LD_STRING 
44506: ST_TO_ADDR
// animal := CreateHuman ;
44507: LD_ADDR_VAR 0 12
44511: PUSH
44512: CALL_OW 44
44516: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44517: LD_VAR 0 12
44521: PPUSH
44522: LD_VAR 0 8
44526: PPUSH
44527: LD_INT 0
44529: PPUSH
44530: CALL 46655 0 3
// end ;
44534: GO 44488
44536: POP
44537: POP
// if birds then
44538: LD_VAR 0 1
44542: IFFALSE 44609
// for i = 1 to birds do
44544: LD_ADDR_VAR 0 11
44548: PUSH
44549: DOUBLE
44550: LD_INT 1
44552: DEC
44553: ST_TO_ADDR
44554: LD_VAR 0 1
44558: PUSH
44559: FOR_TO
44560: IFFALSE 44607
// begin hc_class = 18 ;
44562: LD_ADDR_OWVAR 28
44566: PUSH
44567: LD_INT 18
44569: ST_TO_ADDR
// hc_gallery =  ;
44570: LD_ADDR_OWVAR 33
44574: PUSH
44575: LD_STRING 
44577: ST_TO_ADDR
// animal := CreateHuman ;
44578: LD_ADDR_VAR 0 12
44582: PUSH
44583: CALL_OW 44
44587: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44588: LD_VAR 0 12
44592: PPUSH
44593: LD_VAR 0 8
44597: PPUSH
44598: LD_INT 0
44600: PPUSH
44601: CALL 46655 0 3
// end ;
44605: GO 44559
44607: POP
44608: POP
// if tigers then
44609: LD_VAR 0 2
44613: IFFALSE 44697
// for i = 1 to tigers do
44615: LD_ADDR_VAR 0 11
44619: PUSH
44620: DOUBLE
44621: LD_INT 1
44623: DEC
44624: ST_TO_ADDR
44625: LD_VAR 0 2
44629: PUSH
44630: FOR_TO
44631: IFFALSE 44695
// begin hc_class = class_tiger ;
44633: LD_ADDR_OWVAR 28
44637: PUSH
44638: LD_INT 14
44640: ST_TO_ADDR
// hc_gallery =  ;
44641: LD_ADDR_OWVAR 33
44645: PUSH
44646: LD_STRING 
44648: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44649: LD_ADDR_OWVAR 35
44653: PUSH
44654: LD_INT 7
44656: NEG
44657: PPUSH
44658: LD_INT 7
44660: PPUSH
44661: CALL_OW 12
44665: ST_TO_ADDR
// animal := CreateHuman ;
44666: LD_ADDR_VAR 0 12
44670: PUSH
44671: CALL_OW 44
44675: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44676: LD_VAR 0 12
44680: PPUSH
44681: LD_VAR 0 8
44685: PPUSH
44686: LD_INT 0
44688: PPUSH
44689: CALL 46655 0 3
// end ;
44693: GO 44630
44695: POP
44696: POP
// if apemans then
44697: LD_VAR 0 3
44701: IFFALSE 44824
// for i = 1 to apemans do
44703: LD_ADDR_VAR 0 11
44707: PUSH
44708: DOUBLE
44709: LD_INT 1
44711: DEC
44712: ST_TO_ADDR
44713: LD_VAR 0 3
44717: PUSH
44718: FOR_TO
44719: IFFALSE 44822
// begin hc_class = class_apeman ;
44721: LD_ADDR_OWVAR 28
44725: PUSH
44726: LD_INT 12
44728: ST_TO_ADDR
// hc_gallery =  ;
44729: LD_ADDR_OWVAR 33
44733: PUSH
44734: LD_STRING 
44736: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44737: LD_ADDR_OWVAR 35
44741: PUSH
44742: LD_INT 2
44744: NEG
44745: PPUSH
44746: LD_INT 2
44748: PPUSH
44749: CALL_OW 12
44753: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44754: LD_ADDR_OWVAR 31
44758: PUSH
44759: LD_INT 1
44761: PPUSH
44762: LD_INT 3
44764: PPUSH
44765: CALL_OW 12
44769: PUSH
44770: LD_INT 1
44772: PPUSH
44773: LD_INT 3
44775: PPUSH
44776: CALL_OW 12
44780: PUSH
44781: LD_INT 0
44783: PUSH
44784: LD_INT 0
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: ST_TO_ADDR
// animal := CreateHuman ;
44793: LD_ADDR_VAR 0 12
44797: PUSH
44798: CALL_OW 44
44802: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44803: LD_VAR 0 12
44807: PPUSH
44808: LD_VAR 0 8
44812: PPUSH
44813: LD_INT 0
44815: PPUSH
44816: CALL 46655 0 3
// end ;
44820: GO 44718
44822: POP
44823: POP
// if enchidnas then
44824: LD_VAR 0 4
44828: IFFALSE 44895
// for i = 1 to enchidnas do
44830: LD_ADDR_VAR 0 11
44834: PUSH
44835: DOUBLE
44836: LD_INT 1
44838: DEC
44839: ST_TO_ADDR
44840: LD_VAR 0 4
44844: PUSH
44845: FOR_TO
44846: IFFALSE 44893
// begin hc_class = 13 ;
44848: LD_ADDR_OWVAR 28
44852: PUSH
44853: LD_INT 13
44855: ST_TO_ADDR
// hc_gallery =  ;
44856: LD_ADDR_OWVAR 33
44860: PUSH
44861: LD_STRING 
44863: ST_TO_ADDR
// animal := CreateHuman ;
44864: LD_ADDR_VAR 0 12
44868: PUSH
44869: CALL_OW 44
44873: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44874: LD_VAR 0 12
44878: PPUSH
44879: LD_VAR 0 8
44883: PPUSH
44884: LD_INT 0
44886: PPUSH
44887: CALL 46655 0 3
// end ;
44891: GO 44845
44893: POP
44894: POP
// if fishes then
44895: LD_VAR 0 7
44899: IFFALSE 44966
// for i = 1 to fishes do
44901: LD_ADDR_VAR 0 11
44905: PUSH
44906: DOUBLE
44907: LD_INT 1
44909: DEC
44910: ST_TO_ADDR
44911: LD_VAR 0 7
44915: PUSH
44916: FOR_TO
44917: IFFALSE 44964
// begin hc_class = 20 ;
44919: LD_ADDR_OWVAR 28
44923: PUSH
44924: LD_INT 20
44926: ST_TO_ADDR
// hc_gallery =  ;
44927: LD_ADDR_OWVAR 33
44931: PUSH
44932: LD_STRING 
44934: ST_TO_ADDR
// animal := CreateHuman ;
44935: LD_ADDR_VAR 0 12
44939: PUSH
44940: CALL_OW 44
44944: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44945: LD_VAR 0 12
44949: PPUSH
44950: LD_VAR 0 9
44954: PPUSH
44955: LD_INT 0
44957: PPUSH
44958: CALL 46655 0 3
// end ;
44962: GO 44916
44964: POP
44965: POP
// end ;
44966: LD_VAR 0 10
44970: RET
// export function WantHeal ( sci , unit ) ; begin
44971: LD_INT 0
44973: PPUSH
// if GetTaskList ( sci ) > 0 then
44974: LD_VAR 0 1
44978: PPUSH
44979: CALL_OW 437
44983: PUSH
44984: LD_INT 0
44986: GREATER
44987: IFFALSE 45057
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44989: LD_VAR 0 1
44993: PPUSH
44994: CALL_OW 437
44998: PUSH
44999: LD_INT 1
45001: ARRAY
45002: PUSH
45003: LD_INT 1
45005: ARRAY
45006: PUSH
45007: LD_STRING l
45009: EQUAL
45010: PUSH
45011: LD_VAR 0 1
45015: PPUSH
45016: CALL_OW 437
45020: PUSH
45021: LD_INT 1
45023: ARRAY
45024: PUSH
45025: LD_INT 4
45027: ARRAY
45028: PUSH
45029: LD_VAR 0 2
45033: EQUAL
45034: AND
45035: IFFALSE 45047
// result := true else
45037: LD_ADDR_VAR 0 3
45041: PUSH
45042: LD_INT 1
45044: ST_TO_ADDR
45045: GO 45055
// result := false ;
45047: LD_ADDR_VAR 0 3
45051: PUSH
45052: LD_INT 0
45054: ST_TO_ADDR
// end else
45055: GO 45065
// result := false ;
45057: LD_ADDR_VAR 0 3
45061: PUSH
45062: LD_INT 0
45064: ST_TO_ADDR
// end ;
45065: LD_VAR 0 3
45069: RET
// export function HealTarget ( sci ) ; begin
45070: LD_INT 0
45072: PPUSH
// if not sci then
45073: LD_VAR 0 1
45077: NOT
45078: IFFALSE 45082
// exit ;
45080: GO 45147
// result := 0 ;
45082: LD_ADDR_VAR 0 2
45086: PUSH
45087: LD_INT 0
45089: ST_TO_ADDR
// if GetTaskList ( sci ) then
45090: LD_VAR 0 1
45094: PPUSH
45095: CALL_OW 437
45099: IFFALSE 45147
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45101: LD_VAR 0 1
45105: PPUSH
45106: CALL_OW 437
45110: PUSH
45111: LD_INT 1
45113: ARRAY
45114: PUSH
45115: LD_INT 1
45117: ARRAY
45118: PUSH
45119: LD_STRING l
45121: EQUAL
45122: IFFALSE 45147
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45124: LD_ADDR_VAR 0 2
45128: PUSH
45129: LD_VAR 0 1
45133: PPUSH
45134: CALL_OW 437
45138: PUSH
45139: LD_INT 1
45141: ARRAY
45142: PUSH
45143: LD_INT 4
45145: ARRAY
45146: ST_TO_ADDR
// end ;
45147: LD_VAR 0 2
45151: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45152: LD_INT 0
45154: PPUSH
45155: PPUSH
45156: PPUSH
45157: PPUSH
// if not base_units then
45158: LD_VAR 0 1
45162: NOT
45163: IFFALSE 45167
// exit ;
45165: GO 45254
// result := false ;
45167: LD_ADDR_VAR 0 2
45171: PUSH
45172: LD_INT 0
45174: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45175: LD_ADDR_VAR 0 5
45179: PUSH
45180: LD_VAR 0 1
45184: PPUSH
45185: LD_INT 21
45187: PUSH
45188: LD_INT 3
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PPUSH
45195: CALL_OW 72
45199: ST_TO_ADDR
// if not tmp then
45200: LD_VAR 0 5
45204: NOT
45205: IFFALSE 45209
// exit ;
45207: GO 45254
// for i in tmp do
45209: LD_ADDR_VAR 0 3
45213: PUSH
45214: LD_VAR 0 5
45218: PUSH
45219: FOR_IN
45220: IFFALSE 45252
// begin result := EnemyInRange ( i , 22 ) ;
45222: LD_ADDR_VAR 0 2
45226: PUSH
45227: LD_VAR 0 3
45231: PPUSH
45232: LD_INT 22
45234: PPUSH
45235: CALL 43490 0 2
45239: ST_TO_ADDR
// if result then
45240: LD_VAR 0 2
45244: IFFALSE 45250
// exit ;
45246: POP
45247: POP
45248: GO 45254
// end ;
45250: GO 45219
45252: POP
45253: POP
// end ;
45254: LD_VAR 0 2
45258: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
45259: LD_INT 0
45261: PPUSH
45262: PPUSH
// if not units then
45263: LD_VAR 0 1
45267: NOT
45268: IFFALSE 45272
// exit ;
45270: GO 45342
// result := [ ] ;
45272: LD_ADDR_VAR 0 3
45276: PUSH
45277: EMPTY
45278: ST_TO_ADDR
// for i in units do
45279: LD_ADDR_VAR 0 4
45283: PUSH
45284: LD_VAR 0 1
45288: PUSH
45289: FOR_IN
45290: IFFALSE 45340
// if GetTag ( i ) = tag then
45292: LD_VAR 0 4
45296: PPUSH
45297: CALL_OW 110
45301: PUSH
45302: LD_VAR 0 2
45306: EQUAL
45307: IFFALSE 45338
// result := Replace ( result , result + 1 , i ) ;
45309: LD_ADDR_VAR 0 3
45313: PUSH
45314: LD_VAR 0 3
45318: PPUSH
45319: LD_VAR 0 3
45323: PUSH
45324: LD_INT 1
45326: PLUS
45327: PPUSH
45328: LD_VAR 0 4
45332: PPUSH
45333: CALL_OW 1
45337: ST_TO_ADDR
45338: GO 45289
45340: POP
45341: POP
// end ;
45342: LD_VAR 0 3
45346: RET
// export function IsDriver ( un ) ; begin
45347: LD_INT 0
45349: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
45350: LD_ADDR_VAR 0 2
45354: PUSH
45355: LD_VAR 0 1
45359: PUSH
45360: LD_INT 55
45362: PUSH
45363: EMPTY
45364: LIST
45365: PPUSH
45366: CALL_OW 69
45370: IN
45371: ST_TO_ADDR
// end ;
45372: LD_VAR 0 2
45376: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
45377: LD_INT 0
45379: PPUSH
45380: PPUSH
// list := [ ] ;
45381: LD_ADDR_VAR 0 5
45385: PUSH
45386: EMPTY
45387: ST_TO_ADDR
// case d of 0 :
45388: LD_VAR 0 3
45392: PUSH
45393: LD_INT 0
45395: DOUBLE
45396: EQUAL
45397: IFTRUE 45401
45399: GO 45534
45401: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
45402: LD_ADDR_VAR 0 5
45406: PUSH
45407: LD_VAR 0 1
45411: PUSH
45412: LD_INT 4
45414: MINUS
45415: PUSH
45416: LD_VAR 0 2
45420: PUSH
45421: LD_INT 4
45423: MINUS
45424: PUSH
45425: LD_INT 2
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: LIST
45432: PUSH
45433: LD_VAR 0 1
45437: PUSH
45438: LD_INT 3
45440: MINUS
45441: PUSH
45442: LD_VAR 0 2
45446: PUSH
45447: LD_INT 1
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: LIST
45454: PUSH
45455: LD_VAR 0 1
45459: PUSH
45460: LD_INT 4
45462: PLUS
45463: PUSH
45464: LD_VAR 0 2
45468: PUSH
45469: LD_INT 4
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: LIST
45476: PUSH
45477: LD_VAR 0 1
45481: PUSH
45482: LD_INT 3
45484: PLUS
45485: PUSH
45486: LD_VAR 0 2
45490: PUSH
45491: LD_INT 3
45493: PLUS
45494: PUSH
45495: LD_INT 5
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: PUSH
45503: LD_VAR 0 1
45507: PUSH
45508: LD_VAR 0 2
45512: PUSH
45513: LD_INT 4
45515: PLUS
45516: PUSH
45517: LD_INT 0
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: LIST
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: ST_TO_ADDR
// end ; 1 :
45532: GO 46232
45534: LD_INT 1
45536: DOUBLE
45537: EQUAL
45538: IFTRUE 45542
45540: GO 45675
45542: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45543: LD_ADDR_VAR 0 5
45547: PUSH
45548: LD_VAR 0 1
45552: PUSH
45553: LD_VAR 0 2
45557: PUSH
45558: LD_INT 4
45560: MINUS
45561: PUSH
45562: LD_INT 3
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: LIST
45569: PUSH
45570: LD_VAR 0 1
45574: PUSH
45575: LD_INT 3
45577: MINUS
45578: PUSH
45579: LD_VAR 0 2
45583: PUSH
45584: LD_INT 3
45586: MINUS
45587: PUSH
45588: LD_INT 2
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: LIST
45595: PUSH
45596: LD_VAR 0 1
45600: PUSH
45601: LD_INT 4
45603: MINUS
45604: PUSH
45605: LD_VAR 0 2
45609: PUSH
45610: LD_INT 1
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: LIST
45617: PUSH
45618: LD_VAR 0 1
45622: PUSH
45623: LD_VAR 0 2
45627: PUSH
45628: LD_INT 3
45630: PLUS
45631: PUSH
45632: LD_INT 0
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: LIST
45639: PUSH
45640: LD_VAR 0 1
45644: PUSH
45645: LD_INT 4
45647: PLUS
45648: PUSH
45649: LD_VAR 0 2
45653: PUSH
45654: LD_INT 4
45656: PLUS
45657: PUSH
45658: LD_INT 5
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: ST_TO_ADDR
// end ; 2 :
45673: GO 46232
45675: LD_INT 2
45677: DOUBLE
45678: EQUAL
45679: IFTRUE 45683
45681: GO 45812
45683: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45684: LD_ADDR_VAR 0 5
45688: PUSH
45689: LD_VAR 0 1
45693: PUSH
45694: LD_VAR 0 2
45698: PUSH
45699: LD_INT 3
45701: MINUS
45702: PUSH
45703: LD_INT 3
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: LIST
45710: PUSH
45711: LD_VAR 0 1
45715: PUSH
45716: LD_INT 4
45718: PLUS
45719: PUSH
45720: LD_VAR 0 2
45724: PUSH
45725: LD_INT 4
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: PUSH
45733: LD_VAR 0 1
45737: PUSH
45738: LD_VAR 0 2
45742: PUSH
45743: LD_INT 4
45745: PLUS
45746: PUSH
45747: LD_INT 0
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: LIST
45754: PUSH
45755: LD_VAR 0 1
45759: PUSH
45760: LD_INT 3
45762: MINUS
45763: PUSH
45764: LD_VAR 0 2
45768: PUSH
45769: LD_INT 1
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: LIST
45776: PUSH
45777: LD_VAR 0 1
45781: PUSH
45782: LD_INT 4
45784: MINUS
45785: PUSH
45786: LD_VAR 0 2
45790: PUSH
45791: LD_INT 4
45793: MINUS
45794: PUSH
45795: LD_INT 2
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: LIST
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: ST_TO_ADDR
// end ; 3 :
45810: GO 46232
45812: LD_INT 3
45814: DOUBLE
45815: EQUAL
45816: IFTRUE 45820
45818: GO 45953
45820: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45821: LD_ADDR_VAR 0 5
45825: PUSH
45826: LD_VAR 0 1
45830: PUSH
45831: LD_INT 3
45833: PLUS
45834: PUSH
45835: LD_VAR 0 2
45839: PUSH
45840: LD_INT 4
45842: PUSH
45843: EMPTY
45844: LIST
45845: LIST
45846: LIST
45847: PUSH
45848: LD_VAR 0 1
45852: PUSH
45853: LD_INT 4
45855: PLUS
45856: PUSH
45857: LD_VAR 0 2
45861: PUSH
45862: LD_INT 4
45864: PLUS
45865: PUSH
45866: LD_INT 5
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: LIST
45873: PUSH
45874: LD_VAR 0 1
45878: PUSH
45879: LD_INT 4
45881: MINUS
45882: PUSH
45883: LD_VAR 0 2
45887: PUSH
45888: LD_INT 1
45890: PUSH
45891: EMPTY
45892: LIST
45893: LIST
45894: LIST
45895: PUSH
45896: LD_VAR 0 1
45900: PUSH
45901: LD_VAR 0 2
45905: PUSH
45906: LD_INT 4
45908: MINUS
45909: PUSH
45910: LD_INT 3
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: LIST
45917: PUSH
45918: LD_VAR 0 1
45922: PUSH
45923: LD_INT 3
45925: MINUS
45926: PUSH
45927: LD_VAR 0 2
45931: PUSH
45932: LD_INT 3
45934: MINUS
45935: PUSH
45936: LD_INT 2
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: LIST
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: ST_TO_ADDR
// end ; 4 :
45951: GO 46232
45953: LD_INT 4
45955: DOUBLE
45956: EQUAL
45957: IFTRUE 45961
45959: GO 46094
45961: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45962: LD_ADDR_VAR 0 5
45966: PUSH
45967: LD_VAR 0 1
45971: PUSH
45972: LD_VAR 0 2
45976: PUSH
45977: LD_INT 4
45979: PLUS
45980: PUSH
45981: LD_INT 0
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: LIST
45988: PUSH
45989: LD_VAR 0 1
45993: PUSH
45994: LD_INT 3
45996: PLUS
45997: PUSH
45998: LD_VAR 0 2
46002: PUSH
46003: LD_INT 3
46005: PLUS
46006: PUSH
46007: LD_INT 5
46009: PUSH
46010: EMPTY
46011: LIST
46012: LIST
46013: LIST
46014: PUSH
46015: LD_VAR 0 1
46019: PUSH
46020: LD_INT 4
46022: PLUS
46023: PUSH
46024: LD_VAR 0 2
46028: PUSH
46029: LD_INT 4
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: LIST
46036: PUSH
46037: LD_VAR 0 1
46041: PUSH
46042: LD_VAR 0 2
46046: PUSH
46047: LD_INT 3
46049: MINUS
46050: PUSH
46051: LD_INT 3
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: LIST
46058: PUSH
46059: LD_VAR 0 1
46063: PUSH
46064: LD_INT 4
46066: MINUS
46067: PUSH
46068: LD_VAR 0 2
46072: PUSH
46073: LD_INT 4
46075: MINUS
46076: PUSH
46077: LD_INT 2
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: LIST
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: ST_TO_ADDR
// end ; 5 :
46092: GO 46232
46094: LD_INT 5
46096: DOUBLE
46097: EQUAL
46098: IFTRUE 46102
46100: GO 46231
46102: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46103: LD_ADDR_VAR 0 5
46107: PUSH
46108: LD_VAR 0 1
46112: PUSH
46113: LD_INT 4
46115: MINUS
46116: PUSH
46117: LD_VAR 0 2
46121: PUSH
46122: LD_INT 1
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: LIST
46129: PUSH
46130: LD_VAR 0 1
46134: PUSH
46135: LD_VAR 0 2
46139: PUSH
46140: LD_INT 4
46142: MINUS
46143: PUSH
46144: LD_INT 3
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: LIST
46151: PUSH
46152: LD_VAR 0 1
46156: PUSH
46157: LD_INT 4
46159: PLUS
46160: PUSH
46161: LD_VAR 0 2
46165: PUSH
46166: LD_INT 4
46168: PLUS
46169: PUSH
46170: LD_INT 5
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: LIST
46177: PUSH
46178: LD_VAR 0 1
46182: PUSH
46183: LD_INT 3
46185: PLUS
46186: PUSH
46187: LD_VAR 0 2
46191: PUSH
46192: LD_INT 4
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: LIST
46199: PUSH
46200: LD_VAR 0 1
46204: PUSH
46205: LD_VAR 0 2
46209: PUSH
46210: LD_INT 3
46212: PLUS
46213: PUSH
46214: LD_INT 0
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: LIST
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: ST_TO_ADDR
// end ; end ;
46229: GO 46232
46231: POP
// result := list ;
46232: LD_ADDR_VAR 0 4
46236: PUSH
46237: LD_VAR 0 5
46241: ST_TO_ADDR
// end ;
46242: LD_VAR 0 4
46246: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46247: LD_INT 0
46249: PPUSH
46250: PPUSH
46251: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46252: LD_VAR 0 1
46256: NOT
46257: PUSH
46258: LD_VAR 0 2
46262: PUSH
46263: LD_INT 1
46265: PUSH
46266: LD_INT 2
46268: PUSH
46269: LD_INT 3
46271: PUSH
46272: LD_INT 4
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: LIST
46279: LIST
46280: IN
46281: NOT
46282: OR
46283: IFFALSE 46287
// exit ;
46285: GO 46379
// tmp := [ ] ;
46287: LD_ADDR_VAR 0 5
46291: PUSH
46292: EMPTY
46293: ST_TO_ADDR
// for i in units do
46294: LD_ADDR_VAR 0 4
46298: PUSH
46299: LD_VAR 0 1
46303: PUSH
46304: FOR_IN
46305: IFFALSE 46348
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
46307: LD_ADDR_VAR 0 5
46311: PUSH
46312: LD_VAR 0 5
46316: PPUSH
46317: LD_VAR 0 5
46321: PUSH
46322: LD_INT 1
46324: PLUS
46325: PPUSH
46326: LD_VAR 0 4
46330: PPUSH
46331: LD_VAR 0 2
46335: PPUSH
46336: CALL_OW 259
46340: PPUSH
46341: CALL_OW 2
46345: ST_TO_ADDR
46346: GO 46304
46348: POP
46349: POP
// if not tmp then
46350: LD_VAR 0 5
46354: NOT
46355: IFFALSE 46359
// exit ;
46357: GO 46379
// result := SortListByListDesc ( units , tmp ) ;
46359: LD_ADDR_VAR 0 3
46363: PUSH
46364: LD_VAR 0 1
46368: PPUSH
46369: LD_VAR 0 5
46373: PPUSH
46374: CALL_OW 77
46378: ST_TO_ADDR
// end ;
46379: LD_VAR 0 3
46383: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
46384: LD_INT 0
46386: PPUSH
46387: PPUSH
46388: PPUSH
// result := false ;
46389: LD_ADDR_VAR 0 3
46393: PUSH
46394: LD_INT 0
46396: ST_TO_ADDR
// x := GetX ( building ) ;
46397: LD_ADDR_VAR 0 4
46401: PUSH
46402: LD_VAR 0 2
46406: PPUSH
46407: CALL_OW 250
46411: ST_TO_ADDR
// y := GetY ( building ) ;
46412: LD_ADDR_VAR 0 5
46416: PUSH
46417: LD_VAR 0 2
46421: PPUSH
46422: CALL_OW 251
46426: ST_TO_ADDR
// if not building or not x or not y then
46427: LD_VAR 0 2
46431: NOT
46432: PUSH
46433: LD_VAR 0 4
46437: NOT
46438: OR
46439: PUSH
46440: LD_VAR 0 5
46444: NOT
46445: OR
46446: IFFALSE 46450
// exit ;
46448: GO 46542
// if GetTaskList ( unit ) then
46450: LD_VAR 0 1
46454: PPUSH
46455: CALL_OW 437
46459: IFFALSE 46542
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46461: LD_STRING e
46463: PUSH
46464: LD_VAR 0 1
46468: PPUSH
46469: CALL_OW 437
46473: PUSH
46474: LD_INT 1
46476: ARRAY
46477: PUSH
46478: LD_INT 1
46480: ARRAY
46481: EQUAL
46482: PUSH
46483: LD_VAR 0 4
46487: PUSH
46488: LD_VAR 0 1
46492: PPUSH
46493: CALL_OW 437
46497: PUSH
46498: LD_INT 1
46500: ARRAY
46501: PUSH
46502: LD_INT 2
46504: ARRAY
46505: EQUAL
46506: AND
46507: PUSH
46508: LD_VAR 0 5
46512: PUSH
46513: LD_VAR 0 1
46517: PPUSH
46518: CALL_OW 437
46522: PUSH
46523: LD_INT 1
46525: ARRAY
46526: PUSH
46527: LD_INT 3
46529: ARRAY
46530: EQUAL
46531: AND
46532: IFFALSE 46542
// result := true end ;
46534: LD_ADDR_VAR 0 3
46538: PUSH
46539: LD_INT 1
46541: ST_TO_ADDR
// end ;
46542: LD_VAR 0 3
46546: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46547: LD_INT 0
46549: PPUSH
// result := false ;
46550: LD_ADDR_VAR 0 4
46554: PUSH
46555: LD_INT 0
46557: ST_TO_ADDR
// if GetTaskList ( unit ) then
46558: LD_VAR 0 1
46562: PPUSH
46563: CALL_OW 437
46567: IFFALSE 46650
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46569: LD_STRING M
46571: PUSH
46572: LD_VAR 0 1
46576: PPUSH
46577: CALL_OW 437
46581: PUSH
46582: LD_INT 1
46584: ARRAY
46585: PUSH
46586: LD_INT 1
46588: ARRAY
46589: EQUAL
46590: PUSH
46591: LD_VAR 0 2
46595: PUSH
46596: LD_VAR 0 1
46600: PPUSH
46601: CALL_OW 437
46605: PUSH
46606: LD_INT 1
46608: ARRAY
46609: PUSH
46610: LD_INT 2
46612: ARRAY
46613: EQUAL
46614: AND
46615: PUSH
46616: LD_VAR 0 3
46620: PUSH
46621: LD_VAR 0 1
46625: PPUSH
46626: CALL_OW 437
46630: PUSH
46631: LD_INT 1
46633: ARRAY
46634: PUSH
46635: LD_INT 3
46637: ARRAY
46638: EQUAL
46639: AND
46640: IFFALSE 46650
// result := true ;
46642: LD_ADDR_VAR 0 4
46646: PUSH
46647: LD_INT 1
46649: ST_TO_ADDR
// end ; end ;
46650: LD_VAR 0 4
46654: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46655: LD_INT 0
46657: PPUSH
46658: PPUSH
46659: PPUSH
46660: PPUSH
// if not unit or not area then
46661: LD_VAR 0 1
46665: NOT
46666: PUSH
46667: LD_VAR 0 2
46671: NOT
46672: OR
46673: IFFALSE 46677
// exit ;
46675: GO 46841
// tmp := AreaToList ( area , i ) ;
46677: LD_ADDR_VAR 0 6
46681: PUSH
46682: LD_VAR 0 2
46686: PPUSH
46687: LD_VAR 0 5
46691: PPUSH
46692: CALL_OW 517
46696: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46697: LD_ADDR_VAR 0 5
46701: PUSH
46702: DOUBLE
46703: LD_INT 1
46705: DEC
46706: ST_TO_ADDR
46707: LD_VAR 0 6
46711: PUSH
46712: LD_INT 1
46714: ARRAY
46715: PUSH
46716: FOR_TO
46717: IFFALSE 46839
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46719: LD_ADDR_VAR 0 7
46723: PUSH
46724: LD_VAR 0 6
46728: PUSH
46729: LD_INT 1
46731: ARRAY
46732: PUSH
46733: LD_VAR 0 5
46737: ARRAY
46738: PUSH
46739: LD_VAR 0 6
46743: PUSH
46744: LD_INT 2
46746: ARRAY
46747: PUSH
46748: LD_VAR 0 5
46752: ARRAY
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46758: LD_VAR 0 7
46762: PUSH
46763: LD_INT 1
46765: ARRAY
46766: PPUSH
46767: LD_VAR 0 7
46771: PUSH
46772: LD_INT 2
46774: ARRAY
46775: PPUSH
46776: CALL_OW 428
46780: PUSH
46781: LD_INT 0
46783: EQUAL
46784: IFFALSE 46837
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46786: LD_VAR 0 1
46790: PPUSH
46791: LD_VAR 0 7
46795: PUSH
46796: LD_INT 1
46798: ARRAY
46799: PPUSH
46800: LD_VAR 0 7
46804: PUSH
46805: LD_INT 2
46807: ARRAY
46808: PPUSH
46809: LD_VAR 0 3
46813: PPUSH
46814: CALL_OW 48
// result := IsPlaced ( unit ) ;
46818: LD_ADDR_VAR 0 4
46822: PUSH
46823: LD_VAR 0 1
46827: PPUSH
46828: CALL_OW 305
46832: ST_TO_ADDR
// exit ;
46833: POP
46834: POP
46835: GO 46841
// end ; end ;
46837: GO 46716
46839: POP
46840: POP
// end ;
46841: LD_VAR 0 4
46845: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46846: LD_INT 0
46848: PPUSH
46849: PPUSH
46850: PPUSH
// if not side or side > 8 then
46851: LD_VAR 0 1
46855: NOT
46856: PUSH
46857: LD_VAR 0 1
46861: PUSH
46862: LD_INT 8
46864: GREATER
46865: OR
46866: IFFALSE 46870
// exit ;
46868: GO 47057
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46870: LD_ADDR_VAR 0 4
46874: PUSH
46875: LD_INT 22
46877: PUSH
46878: LD_VAR 0 1
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: PUSH
46887: LD_INT 21
46889: PUSH
46890: LD_INT 3
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PPUSH
46901: CALL_OW 69
46905: ST_TO_ADDR
// if not tmp then
46906: LD_VAR 0 4
46910: NOT
46911: IFFALSE 46915
// exit ;
46913: GO 47057
// enable_addtolog := true ;
46915: LD_ADDR_OWVAR 81
46919: PUSH
46920: LD_INT 1
46922: ST_TO_ADDR
// AddToLog ( [ ) ;
46923: LD_STRING [
46925: PPUSH
46926: CALL_OW 561
// for i in tmp do
46930: LD_ADDR_VAR 0 3
46934: PUSH
46935: LD_VAR 0 4
46939: PUSH
46940: FOR_IN
46941: IFFALSE 47048
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46943: LD_STRING [
46945: PUSH
46946: LD_VAR 0 3
46950: PPUSH
46951: CALL_OW 266
46955: STR
46956: PUSH
46957: LD_STRING , 
46959: STR
46960: PUSH
46961: LD_VAR 0 3
46965: PPUSH
46966: CALL_OW 250
46970: STR
46971: PUSH
46972: LD_STRING , 
46974: STR
46975: PUSH
46976: LD_VAR 0 3
46980: PPUSH
46981: CALL_OW 251
46985: STR
46986: PUSH
46987: LD_STRING , 
46989: STR
46990: PUSH
46991: LD_VAR 0 3
46995: PPUSH
46996: CALL_OW 254
47000: STR
47001: PUSH
47002: LD_STRING , 
47004: STR
47005: PUSH
47006: LD_VAR 0 3
47010: PPUSH
47011: LD_INT 1
47013: PPUSH
47014: CALL_OW 268
47018: STR
47019: PUSH
47020: LD_STRING , 
47022: STR
47023: PUSH
47024: LD_VAR 0 3
47028: PPUSH
47029: LD_INT 2
47031: PPUSH
47032: CALL_OW 268
47036: STR
47037: PUSH
47038: LD_STRING ],
47040: STR
47041: PPUSH
47042: CALL_OW 561
// end ;
47046: GO 46940
47048: POP
47049: POP
// AddToLog ( ]; ) ;
47050: LD_STRING ];
47052: PPUSH
47053: CALL_OW 561
// end ;
47057: LD_VAR 0 2
47061: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47062: LD_INT 0
47064: PPUSH
47065: PPUSH
47066: PPUSH
47067: PPUSH
47068: PPUSH
// if not area or not rate or not max then
47069: LD_VAR 0 1
47073: NOT
47074: PUSH
47075: LD_VAR 0 2
47079: NOT
47080: OR
47081: PUSH
47082: LD_VAR 0 4
47086: NOT
47087: OR
47088: IFFALSE 47092
// exit ;
47090: GO 47284
// while 1 do
47092: LD_INT 1
47094: IFFALSE 47284
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47096: LD_ADDR_VAR 0 9
47100: PUSH
47101: LD_VAR 0 1
47105: PPUSH
47106: LD_INT 1
47108: PPUSH
47109: CALL_OW 287
47113: PUSH
47114: LD_INT 10
47116: MUL
47117: ST_TO_ADDR
// r := rate / 10 ;
47118: LD_ADDR_VAR 0 7
47122: PUSH
47123: LD_VAR 0 2
47127: PUSH
47128: LD_INT 10
47130: DIVREAL
47131: ST_TO_ADDR
// time := 1 1$00 ;
47132: LD_ADDR_VAR 0 8
47136: PUSH
47137: LD_INT 2100
47139: ST_TO_ADDR
// if amount < min then
47140: LD_VAR 0 9
47144: PUSH
47145: LD_VAR 0 3
47149: LESS
47150: IFFALSE 47168
// r := r * 2 else
47152: LD_ADDR_VAR 0 7
47156: PUSH
47157: LD_VAR 0 7
47161: PUSH
47162: LD_INT 2
47164: MUL
47165: ST_TO_ADDR
47166: GO 47194
// if amount > max then
47168: LD_VAR 0 9
47172: PUSH
47173: LD_VAR 0 4
47177: GREATER
47178: IFFALSE 47194
// r := r / 2 ;
47180: LD_ADDR_VAR 0 7
47184: PUSH
47185: LD_VAR 0 7
47189: PUSH
47190: LD_INT 2
47192: DIVREAL
47193: ST_TO_ADDR
// time := time / r ;
47194: LD_ADDR_VAR 0 8
47198: PUSH
47199: LD_VAR 0 8
47203: PUSH
47204: LD_VAR 0 7
47208: DIVREAL
47209: ST_TO_ADDR
// if time < 0 then
47210: LD_VAR 0 8
47214: PUSH
47215: LD_INT 0
47217: LESS
47218: IFFALSE 47235
// time := time * - 1 ;
47220: LD_ADDR_VAR 0 8
47224: PUSH
47225: LD_VAR 0 8
47229: PUSH
47230: LD_INT 1
47232: NEG
47233: MUL
47234: ST_TO_ADDR
// wait ( time ) ;
47235: LD_VAR 0 8
47239: PPUSH
47240: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
47244: LD_INT 35
47246: PPUSH
47247: LD_INT 875
47249: PPUSH
47250: CALL_OW 12
47254: PPUSH
47255: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47259: LD_INT 1
47261: PPUSH
47262: LD_INT 5
47264: PPUSH
47265: CALL_OW 12
47269: PPUSH
47270: LD_VAR 0 1
47274: PPUSH
47275: LD_INT 1
47277: PPUSH
47278: CALL_OW 55
// end ;
47282: GO 47092
// end ;
47284: LD_VAR 0 5
47288: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47289: LD_INT 0
47291: PPUSH
47292: PPUSH
47293: PPUSH
47294: PPUSH
47295: PPUSH
47296: PPUSH
47297: PPUSH
47298: PPUSH
// if not turrets or not factories then
47299: LD_VAR 0 1
47303: NOT
47304: PUSH
47305: LD_VAR 0 2
47309: NOT
47310: OR
47311: IFFALSE 47315
// exit ;
47313: GO 47622
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47315: LD_ADDR_VAR 0 10
47319: PUSH
47320: LD_INT 5
47322: PUSH
47323: LD_INT 6
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PUSH
47330: LD_INT 2
47332: PUSH
47333: LD_INT 4
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PUSH
47340: LD_INT 3
47342: PUSH
47343: LD_INT 5
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 24
47357: PUSH
47358: LD_INT 25
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 23
47367: PUSH
47368: LD_INT 27
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: PUSH
47379: LD_INT 42
47381: PUSH
47382: LD_INT 43
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: LD_INT 44
47391: PUSH
47392: LD_INT 46
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: PUSH
47399: LD_INT 45
47401: PUSH
47402: LD_INT 47
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: EMPTY
47410: LIST
47411: LIST
47412: LIST
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: LIST
47418: ST_TO_ADDR
// result := [ ] ;
47419: LD_ADDR_VAR 0 3
47423: PUSH
47424: EMPTY
47425: ST_TO_ADDR
// for i in turrets do
47426: LD_ADDR_VAR 0 4
47430: PUSH
47431: LD_VAR 0 1
47435: PUSH
47436: FOR_IN
47437: IFFALSE 47620
// begin nat := GetNation ( i ) ;
47439: LD_ADDR_VAR 0 7
47443: PUSH
47444: LD_VAR 0 4
47448: PPUSH
47449: CALL_OW 248
47453: ST_TO_ADDR
// weapon := 0 ;
47454: LD_ADDR_VAR 0 8
47458: PUSH
47459: LD_INT 0
47461: ST_TO_ADDR
// if not nat then
47462: LD_VAR 0 7
47466: NOT
47467: IFFALSE 47471
// continue ;
47469: GO 47436
// for j in list [ nat ] do
47471: LD_ADDR_VAR 0 5
47475: PUSH
47476: LD_VAR 0 10
47480: PUSH
47481: LD_VAR 0 7
47485: ARRAY
47486: PUSH
47487: FOR_IN
47488: IFFALSE 47529
// if GetBWeapon ( i ) = j [ 1 ] then
47490: LD_VAR 0 4
47494: PPUSH
47495: CALL_OW 269
47499: PUSH
47500: LD_VAR 0 5
47504: PUSH
47505: LD_INT 1
47507: ARRAY
47508: EQUAL
47509: IFFALSE 47527
// begin weapon := j [ 2 ] ;
47511: LD_ADDR_VAR 0 8
47515: PUSH
47516: LD_VAR 0 5
47520: PUSH
47521: LD_INT 2
47523: ARRAY
47524: ST_TO_ADDR
// break ;
47525: GO 47529
// end ;
47527: GO 47487
47529: POP
47530: POP
// if not weapon then
47531: LD_VAR 0 8
47535: NOT
47536: IFFALSE 47540
// continue ;
47538: GO 47436
// for k in factories do
47540: LD_ADDR_VAR 0 6
47544: PUSH
47545: LD_VAR 0 2
47549: PUSH
47550: FOR_IN
47551: IFFALSE 47616
// begin weapons := AvailableWeaponList ( k ) ;
47553: LD_ADDR_VAR 0 9
47557: PUSH
47558: LD_VAR 0 6
47562: PPUSH
47563: CALL_OW 478
47567: ST_TO_ADDR
// if not weapons then
47568: LD_VAR 0 9
47572: NOT
47573: IFFALSE 47577
// continue ;
47575: GO 47550
// if weapon in weapons then
47577: LD_VAR 0 8
47581: PUSH
47582: LD_VAR 0 9
47586: IN
47587: IFFALSE 47614
// begin result := [ i , weapon ] ;
47589: LD_ADDR_VAR 0 3
47593: PUSH
47594: LD_VAR 0 4
47598: PUSH
47599: LD_VAR 0 8
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: ST_TO_ADDR
// exit ;
47608: POP
47609: POP
47610: POP
47611: POP
47612: GO 47622
// end ; end ;
47614: GO 47550
47616: POP
47617: POP
// end ;
47618: GO 47436
47620: POP
47621: POP
// end ;
47622: LD_VAR 0 3
47626: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47627: LD_INT 0
47629: PPUSH
// if not side or side > 8 then
47630: LD_VAR 0 3
47634: NOT
47635: PUSH
47636: LD_VAR 0 3
47640: PUSH
47641: LD_INT 8
47643: GREATER
47644: OR
47645: IFFALSE 47649
// exit ;
47647: GO 47708
// if not range then
47649: LD_VAR 0 4
47653: NOT
47654: IFFALSE 47665
// range := - 12 ;
47656: LD_ADDR_VAR 0 4
47660: PUSH
47661: LD_INT 12
47663: NEG
47664: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47665: LD_VAR 0 1
47669: PPUSH
47670: LD_VAR 0 2
47674: PPUSH
47675: LD_VAR 0 3
47679: PPUSH
47680: LD_VAR 0 4
47684: PPUSH
47685: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47689: LD_VAR 0 1
47693: PPUSH
47694: LD_VAR 0 2
47698: PPUSH
47699: LD_VAR 0 3
47703: PPUSH
47704: CALL_OW 331
// end ;
47708: LD_VAR 0 5
47712: RET
// export function Video ( mode ) ; begin
47713: LD_INT 0
47715: PPUSH
// ingame_video = mode ;
47716: LD_ADDR_OWVAR 52
47720: PUSH
47721: LD_VAR 0 1
47725: ST_TO_ADDR
// interface_hidden = mode ;
47726: LD_ADDR_OWVAR 54
47730: PUSH
47731: LD_VAR 0 1
47735: ST_TO_ADDR
// end ;
47736: LD_VAR 0 2
47740: RET
// export function Join ( array , element ) ; begin
47741: LD_INT 0
47743: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47744: LD_ADDR_VAR 0 3
47748: PUSH
47749: LD_VAR 0 1
47753: PPUSH
47754: LD_VAR 0 1
47758: PUSH
47759: LD_INT 1
47761: PLUS
47762: PPUSH
47763: LD_VAR 0 2
47767: PPUSH
47768: CALL_OW 1
47772: ST_TO_ADDR
// end ;
47773: LD_VAR 0 3
47777: RET
// export function JoinUnion ( array , element ) ; begin
47778: LD_INT 0
47780: PPUSH
// result := array union element ;
47781: LD_ADDR_VAR 0 3
47785: PUSH
47786: LD_VAR 0 1
47790: PUSH
47791: LD_VAR 0 2
47795: UNION
47796: ST_TO_ADDR
// end ;
47797: LD_VAR 0 3
47801: RET
// export function GetBehemoths ( side ) ; begin
47802: LD_INT 0
47804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
47805: LD_ADDR_VAR 0 2
47809: PUSH
47810: LD_INT 22
47812: PUSH
47813: LD_VAR 0 1
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: PUSH
47822: LD_INT 31
47824: PUSH
47825: LD_INT 25
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PPUSH
47836: CALL_OW 69
47840: ST_TO_ADDR
// end ;
47841: LD_VAR 0 2
47845: RET
// export function Shuffle ( array ) ; var i , index ; begin
47846: LD_INT 0
47848: PPUSH
47849: PPUSH
47850: PPUSH
// result := [ ] ;
47851: LD_ADDR_VAR 0 2
47855: PUSH
47856: EMPTY
47857: ST_TO_ADDR
// if not array then
47858: LD_VAR 0 1
47862: NOT
47863: IFFALSE 47867
// exit ;
47865: GO 47966
// Randomize ;
47867: CALL_OW 10
// for i = array downto 1 do
47871: LD_ADDR_VAR 0 3
47875: PUSH
47876: DOUBLE
47877: LD_VAR 0 1
47881: INC
47882: ST_TO_ADDR
47883: LD_INT 1
47885: PUSH
47886: FOR_DOWNTO
47887: IFFALSE 47964
// begin index := rand ( 1 , array ) ;
47889: LD_ADDR_VAR 0 4
47893: PUSH
47894: LD_INT 1
47896: PPUSH
47897: LD_VAR 0 1
47901: PPUSH
47902: CALL_OW 12
47906: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47907: LD_ADDR_VAR 0 2
47911: PUSH
47912: LD_VAR 0 2
47916: PPUSH
47917: LD_VAR 0 2
47921: PUSH
47922: LD_INT 1
47924: PLUS
47925: PPUSH
47926: LD_VAR 0 1
47930: PUSH
47931: LD_VAR 0 4
47935: ARRAY
47936: PPUSH
47937: CALL_OW 2
47941: ST_TO_ADDR
// array := Delete ( array , index ) ;
47942: LD_ADDR_VAR 0 1
47946: PUSH
47947: LD_VAR 0 1
47951: PPUSH
47952: LD_VAR 0 4
47956: PPUSH
47957: CALL_OW 3
47961: ST_TO_ADDR
// end ;
47962: GO 47886
47964: POP
47965: POP
// end ;
47966: LD_VAR 0 2
47970: RET
// export function GetBaseMaterials ( base ) ; begin
47971: LD_INT 0
47973: PPUSH
// result := [ 0 , 0 , 0 ] ;
47974: LD_ADDR_VAR 0 2
47978: PUSH
47979: LD_INT 0
47981: PUSH
47982: LD_INT 0
47984: PUSH
47985: LD_INT 0
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: LIST
47992: ST_TO_ADDR
// if not base then
47993: LD_VAR 0 1
47997: NOT
47998: IFFALSE 48002
// exit ;
48000: GO 48051
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48002: LD_ADDR_VAR 0 2
48006: PUSH
48007: LD_VAR 0 1
48011: PPUSH
48012: LD_INT 1
48014: PPUSH
48015: CALL_OW 275
48019: PUSH
48020: LD_VAR 0 1
48024: PPUSH
48025: LD_INT 2
48027: PPUSH
48028: CALL_OW 275
48032: PUSH
48033: LD_VAR 0 1
48037: PPUSH
48038: LD_INT 3
48040: PPUSH
48041: CALL_OW 275
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: LIST
48050: ST_TO_ADDR
// end ;
48051: LD_VAR 0 2
48055: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48056: LD_INT 0
48058: PPUSH
48059: PPUSH
// result := array ;
48060: LD_ADDR_VAR 0 3
48064: PUSH
48065: LD_VAR 0 1
48069: ST_TO_ADDR
// if size > 0 then
48070: LD_VAR 0 2
48074: PUSH
48075: LD_INT 0
48077: GREATER
48078: IFFALSE 48124
// for i := array downto size do
48080: LD_ADDR_VAR 0 4
48084: PUSH
48085: DOUBLE
48086: LD_VAR 0 1
48090: INC
48091: ST_TO_ADDR
48092: LD_VAR 0 2
48096: PUSH
48097: FOR_DOWNTO
48098: IFFALSE 48122
// result := Delete ( result , result ) ;
48100: LD_ADDR_VAR 0 3
48104: PUSH
48105: LD_VAR 0 3
48109: PPUSH
48110: LD_VAR 0 3
48114: PPUSH
48115: CALL_OW 3
48119: ST_TO_ADDR
48120: GO 48097
48122: POP
48123: POP
// end ;
48124: LD_VAR 0 3
48128: RET
// export function ComExit ( unit ) ; var tmp ; begin
48129: LD_INT 0
48131: PPUSH
48132: PPUSH
// if not IsInUnit ( unit ) then
48133: LD_VAR 0 1
48137: PPUSH
48138: CALL_OW 310
48142: NOT
48143: IFFALSE 48147
// exit ;
48145: GO 48207
// tmp := IsInUnit ( unit ) ;
48147: LD_ADDR_VAR 0 3
48151: PUSH
48152: LD_VAR 0 1
48156: PPUSH
48157: CALL_OW 310
48161: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48162: LD_VAR 0 3
48166: PPUSH
48167: CALL_OW 247
48171: PUSH
48172: LD_INT 2
48174: EQUAL
48175: IFFALSE 48188
// ComExitVehicle ( unit ) else
48177: LD_VAR 0 1
48181: PPUSH
48182: CALL_OW 121
48186: GO 48197
// ComExitBuilding ( unit ) ;
48188: LD_VAR 0 1
48192: PPUSH
48193: CALL_OW 122
// result := tmp ;
48197: LD_ADDR_VAR 0 2
48201: PUSH
48202: LD_VAR 0 3
48206: ST_TO_ADDR
// end ;
48207: LD_VAR 0 2
48211: RET
// export function ComExitAll ( units ) ; var i ; begin
48212: LD_INT 0
48214: PPUSH
48215: PPUSH
// if not units then
48216: LD_VAR 0 1
48220: NOT
48221: IFFALSE 48225
// exit ;
48223: GO 48251
// for i in units do
48225: LD_ADDR_VAR 0 3
48229: PUSH
48230: LD_VAR 0 1
48234: PUSH
48235: FOR_IN
48236: IFFALSE 48249
// ComExit ( i ) ;
48238: LD_VAR 0 3
48242: PPUSH
48243: CALL 48129 0 1
48247: GO 48235
48249: POP
48250: POP
// end ;
48251: LD_VAR 0 2
48255: RET
// export function ResetHc ; begin
48256: LD_INT 0
48258: PPUSH
// InitHc ;
48259: CALL_OW 19
// hc_importance := 0 ;
48263: LD_ADDR_OWVAR 32
48267: PUSH
48268: LD_INT 0
48270: ST_TO_ADDR
// end ;
48271: LD_VAR 0 1
48275: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48276: LD_INT 0
48278: PPUSH
48279: PPUSH
48280: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48281: LD_ADDR_VAR 0 6
48285: PUSH
48286: LD_VAR 0 1
48290: PUSH
48291: LD_VAR 0 3
48295: PLUS
48296: PUSH
48297: LD_INT 2
48299: DIV
48300: ST_TO_ADDR
// if _x < 0 then
48301: LD_VAR 0 6
48305: PUSH
48306: LD_INT 0
48308: LESS
48309: IFFALSE 48326
// _x := _x * - 1 ;
48311: LD_ADDR_VAR 0 6
48315: PUSH
48316: LD_VAR 0 6
48320: PUSH
48321: LD_INT 1
48323: NEG
48324: MUL
48325: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
48326: LD_ADDR_VAR 0 7
48330: PUSH
48331: LD_VAR 0 2
48335: PUSH
48336: LD_VAR 0 4
48340: PLUS
48341: PUSH
48342: LD_INT 2
48344: DIV
48345: ST_TO_ADDR
// if _y < 0 then
48346: LD_VAR 0 7
48350: PUSH
48351: LD_INT 0
48353: LESS
48354: IFFALSE 48371
// _y := _y * - 1 ;
48356: LD_ADDR_VAR 0 7
48360: PUSH
48361: LD_VAR 0 7
48365: PUSH
48366: LD_INT 1
48368: NEG
48369: MUL
48370: ST_TO_ADDR
// result := [ _x , _y ] ;
48371: LD_ADDR_VAR 0 5
48375: PUSH
48376: LD_VAR 0 6
48380: PUSH
48381: LD_VAR 0 7
48385: PUSH
48386: EMPTY
48387: LIST
48388: LIST
48389: ST_TO_ADDR
// end ;
48390: LD_VAR 0 5
48394: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
48395: LD_INT 0
48397: PPUSH
48398: PPUSH
48399: PPUSH
48400: PPUSH
// task := GetTaskList ( unit ) ;
48401: LD_ADDR_VAR 0 7
48405: PUSH
48406: LD_VAR 0 1
48410: PPUSH
48411: CALL_OW 437
48415: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48416: LD_VAR 0 7
48420: NOT
48421: PUSH
48422: LD_VAR 0 1
48426: PPUSH
48427: LD_VAR 0 2
48431: PPUSH
48432: CALL_OW 308
48436: NOT
48437: AND
48438: IFFALSE 48442
// exit ;
48440: GO 48560
// if IsInArea ( unit , area ) then
48442: LD_VAR 0 1
48446: PPUSH
48447: LD_VAR 0 2
48451: PPUSH
48452: CALL_OW 308
48456: IFFALSE 48474
// begin ComMoveToArea ( unit , goAway ) ;
48458: LD_VAR 0 1
48462: PPUSH
48463: LD_VAR 0 3
48467: PPUSH
48468: CALL_OW 113
// exit ;
48472: GO 48560
// end ; if task [ 1 ] [ 1 ] <> M then
48474: LD_VAR 0 7
48478: PUSH
48479: LD_INT 1
48481: ARRAY
48482: PUSH
48483: LD_INT 1
48485: ARRAY
48486: PUSH
48487: LD_STRING M
48489: NONEQUAL
48490: IFFALSE 48494
// exit ;
48492: GO 48560
// x := task [ 1 ] [ 2 ] ;
48494: LD_ADDR_VAR 0 5
48498: PUSH
48499: LD_VAR 0 7
48503: PUSH
48504: LD_INT 1
48506: ARRAY
48507: PUSH
48508: LD_INT 2
48510: ARRAY
48511: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48512: LD_ADDR_VAR 0 6
48516: PUSH
48517: LD_VAR 0 7
48521: PUSH
48522: LD_INT 1
48524: ARRAY
48525: PUSH
48526: LD_INT 3
48528: ARRAY
48529: ST_TO_ADDR
// if InArea ( x , y , area ) then
48530: LD_VAR 0 5
48534: PPUSH
48535: LD_VAR 0 6
48539: PPUSH
48540: LD_VAR 0 2
48544: PPUSH
48545: CALL_OW 309
48549: IFFALSE 48560
// ComStop ( unit ) ;
48551: LD_VAR 0 1
48555: PPUSH
48556: CALL_OW 141
// end ;
48560: LD_VAR 0 4
48564: RET
// export function Abs ( value ) ; begin
48565: LD_INT 0
48567: PPUSH
// result := value ;
48568: LD_ADDR_VAR 0 2
48572: PUSH
48573: LD_VAR 0 1
48577: ST_TO_ADDR
// if value < 0 then
48578: LD_VAR 0 1
48582: PUSH
48583: LD_INT 0
48585: LESS
48586: IFFALSE 48603
// result := value * - 1 ;
48588: LD_ADDR_VAR 0 2
48592: PUSH
48593: LD_VAR 0 1
48597: PUSH
48598: LD_INT 1
48600: NEG
48601: MUL
48602: ST_TO_ADDR
// end ;
48603: LD_VAR 0 2
48607: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48608: LD_INT 0
48610: PPUSH
48611: PPUSH
48612: PPUSH
48613: PPUSH
48614: PPUSH
48615: PPUSH
48616: PPUSH
48617: PPUSH
// if not unit or not building then
48618: LD_VAR 0 1
48622: NOT
48623: PUSH
48624: LD_VAR 0 2
48628: NOT
48629: OR
48630: IFFALSE 48634
// exit ;
48632: GO 48860
// x := GetX ( building ) ;
48634: LD_ADDR_VAR 0 4
48638: PUSH
48639: LD_VAR 0 2
48643: PPUSH
48644: CALL_OW 250
48648: ST_TO_ADDR
// y := GetY ( building ) ;
48649: LD_ADDR_VAR 0 6
48653: PUSH
48654: LD_VAR 0 2
48658: PPUSH
48659: CALL_OW 251
48663: ST_TO_ADDR
// d := GetDir ( building ) ;
48664: LD_ADDR_VAR 0 8
48668: PUSH
48669: LD_VAR 0 2
48673: PPUSH
48674: CALL_OW 254
48678: ST_TO_ADDR
// r := 4 ;
48679: LD_ADDR_VAR 0 9
48683: PUSH
48684: LD_INT 4
48686: ST_TO_ADDR
// for i := 1 to 5 do
48687: LD_ADDR_VAR 0 10
48691: PUSH
48692: DOUBLE
48693: LD_INT 1
48695: DEC
48696: ST_TO_ADDR
48697: LD_INT 5
48699: PUSH
48700: FOR_TO
48701: IFFALSE 48858
// begin _x := ShiftX ( x , d , r + i ) ;
48703: LD_ADDR_VAR 0 5
48707: PUSH
48708: LD_VAR 0 4
48712: PPUSH
48713: LD_VAR 0 8
48717: PPUSH
48718: LD_VAR 0 9
48722: PUSH
48723: LD_VAR 0 10
48727: PLUS
48728: PPUSH
48729: CALL_OW 272
48733: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48734: LD_ADDR_VAR 0 7
48738: PUSH
48739: LD_VAR 0 6
48743: PPUSH
48744: LD_VAR 0 8
48748: PPUSH
48749: LD_VAR 0 9
48753: PUSH
48754: LD_VAR 0 10
48758: PLUS
48759: PPUSH
48760: CALL_OW 273
48764: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48765: LD_VAR 0 5
48769: PPUSH
48770: LD_VAR 0 7
48774: PPUSH
48775: CALL_OW 488
48779: PUSH
48780: LD_VAR 0 5
48784: PPUSH
48785: LD_VAR 0 7
48789: PPUSH
48790: CALL_OW 428
48794: PPUSH
48795: CALL_OW 247
48799: PUSH
48800: LD_INT 3
48802: PUSH
48803: LD_INT 2
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: IN
48810: NOT
48811: AND
48812: IFFALSE 48856
// begin ComMoveXY ( unit , _x , _y ) ;
48814: LD_VAR 0 1
48818: PPUSH
48819: LD_VAR 0 5
48823: PPUSH
48824: LD_VAR 0 7
48828: PPUSH
48829: CALL_OW 111
// result := [ _x , _y ] ;
48833: LD_ADDR_VAR 0 3
48837: PUSH
48838: LD_VAR 0 5
48842: PUSH
48843: LD_VAR 0 7
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: ST_TO_ADDR
// exit ;
48852: POP
48853: POP
48854: GO 48860
// end ; end ;
48856: GO 48700
48858: POP
48859: POP
// end ;
48860: LD_VAR 0 3
48864: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48865: LD_INT 0
48867: PPUSH
48868: PPUSH
48869: PPUSH
// result := 0 ;
48870: LD_ADDR_VAR 0 3
48874: PUSH
48875: LD_INT 0
48877: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48878: LD_VAR 0 1
48882: PUSH
48883: LD_INT 0
48885: LESS
48886: PUSH
48887: LD_VAR 0 1
48891: PUSH
48892: LD_INT 8
48894: GREATER
48895: OR
48896: PUSH
48897: LD_VAR 0 2
48901: PUSH
48902: LD_INT 0
48904: LESS
48905: OR
48906: PUSH
48907: LD_VAR 0 2
48911: PUSH
48912: LD_INT 8
48914: GREATER
48915: OR
48916: IFFALSE 48920
// exit ;
48918: GO 48995
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48920: LD_ADDR_VAR 0 4
48924: PUSH
48925: LD_INT 22
48927: PUSH
48928: LD_VAR 0 2
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PPUSH
48937: CALL_OW 69
48941: PUSH
48942: FOR_IN
48943: IFFALSE 48993
// begin un := UnitShoot ( i ) ;
48945: LD_ADDR_VAR 0 5
48949: PUSH
48950: LD_VAR 0 4
48954: PPUSH
48955: CALL_OW 504
48959: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48960: LD_VAR 0 5
48964: PPUSH
48965: CALL_OW 255
48969: PUSH
48970: LD_VAR 0 1
48974: EQUAL
48975: IFFALSE 48991
// begin result := un ;
48977: LD_ADDR_VAR 0 3
48981: PUSH
48982: LD_VAR 0 5
48986: ST_TO_ADDR
// exit ;
48987: POP
48988: POP
48989: GO 48995
// end ; end ;
48991: GO 48942
48993: POP
48994: POP
// end ;
48995: LD_VAR 0 3
48999: RET
// export function GetCargoBay ( units ) ; begin
49000: LD_INT 0
49002: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49003: LD_ADDR_VAR 0 2
49007: PUSH
49008: LD_VAR 0 1
49012: PPUSH
49013: LD_INT 2
49015: PUSH
49016: LD_INT 34
49018: PUSH
49019: LD_INT 12
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: PUSH
49026: LD_INT 34
49028: PUSH
49029: LD_INT 51
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 34
49038: PUSH
49039: LD_INT 32
49041: PUSH
49042: EMPTY
49043: LIST
49044: LIST
49045: PUSH
49046: LD_INT 34
49048: PUSH
49049: LD_EXP 68
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: PPUSH
49065: CALL_OW 72
49069: ST_TO_ADDR
// end ;
49070: LD_VAR 0 2
49074: RET
// export function Negate ( value ) ; begin
49075: LD_INT 0
49077: PPUSH
// result := not value ;
49078: LD_ADDR_VAR 0 2
49082: PUSH
49083: LD_VAR 0 1
49087: NOT
49088: ST_TO_ADDR
// end ;
49089: LD_VAR 0 2
49093: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49094: LD_INT 0
49096: PPUSH
49097: PPUSH
49098: PPUSH
49099: PPUSH
49100: PPUSH
49101: PPUSH
49102: PPUSH
49103: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49104: LD_VAR 0 1
49108: PPUSH
49109: LD_VAR 0 2
49113: PPUSH
49114: CALL_OW 488
49118: NOT
49119: PUSH
49120: LD_VAR 0 3
49124: PPUSH
49125: LD_VAR 0 4
49129: PPUSH
49130: CALL_OW 488
49134: NOT
49135: OR
49136: IFFALSE 49149
// begin result := - 1 ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_INT 1
49145: NEG
49146: ST_TO_ADDR
// exit ;
49147: GO 49384
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49149: LD_ADDR_VAR 0 12
49153: PUSH
49154: LD_VAR 0 1
49158: PPUSH
49159: LD_VAR 0 2
49163: PPUSH
49164: LD_VAR 0 3
49168: PPUSH
49169: LD_VAR 0 4
49173: PPUSH
49174: CALL 48276 0 4
49178: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49179: LD_ADDR_VAR 0 11
49183: PUSH
49184: LD_VAR 0 1
49188: PPUSH
49189: LD_VAR 0 2
49193: PPUSH
49194: LD_VAR 0 12
49198: PUSH
49199: LD_INT 1
49201: ARRAY
49202: PPUSH
49203: LD_VAR 0 12
49207: PUSH
49208: LD_INT 2
49210: ARRAY
49211: PPUSH
49212: CALL_OW 298
49216: ST_TO_ADDR
// distance := 9999 ;
49217: LD_ADDR_VAR 0 10
49221: PUSH
49222: LD_INT 9999
49224: ST_TO_ADDR
// for i := 0 to 5 do
49225: LD_ADDR_VAR 0 6
49229: PUSH
49230: DOUBLE
49231: LD_INT 0
49233: DEC
49234: ST_TO_ADDR
49235: LD_INT 5
49237: PUSH
49238: FOR_TO
49239: IFFALSE 49382
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49241: LD_ADDR_VAR 0 7
49245: PUSH
49246: LD_VAR 0 1
49250: PPUSH
49251: LD_VAR 0 6
49255: PPUSH
49256: LD_VAR 0 11
49260: PPUSH
49261: CALL_OW 272
49265: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
49266: LD_ADDR_VAR 0 8
49270: PUSH
49271: LD_VAR 0 2
49275: PPUSH
49276: LD_VAR 0 6
49280: PPUSH
49281: LD_VAR 0 11
49285: PPUSH
49286: CALL_OW 273
49290: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49291: LD_VAR 0 7
49295: PPUSH
49296: LD_VAR 0 8
49300: PPUSH
49301: CALL_OW 488
49305: NOT
49306: IFFALSE 49310
// continue ;
49308: GO 49238
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
49310: LD_ADDR_VAR 0 9
49314: PUSH
49315: LD_VAR 0 12
49319: PUSH
49320: LD_INT 1
49322: ARRAY
49323: PPUSH
49324: LD_VAR 0 12
49328: PUSH
49329: LD_INT 2
49331: ARRAY
49332: PPUSH
49333: LD_VAR 0 7
49337: PPUSH
49338: LD_VAR 0 8
49342: PPUSH
49343: CALL_OW 298
49347: ST_TO_ADDR
// if tmp < distance then
49348: LD_VAR 0 9
49352: PUSH
49353: LD_VAR 0 10
49357: LESS
49358: IFFALSE 49380
// begin result := i ;
49360: LD_ADDR_VAR 0 5
49364: PUSH
49365: LD_VAR 0 6
49369: ST_TO_ADDR
// distance := tmp ;
49370: LD_ADDR_VAR 0 10
49374: PUSH
49375: LD_VAR 0 9
49379: ST_TO_ADDR
// end ; end ;
49380: GO 49238
49382: POP
49383: POP
// end ;
49384: LD_VAR 0 5
49388: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49389: LD_INT 0
49391: PPUSH
49392: PPUSH
// if not driver or not IsInUnit ( driver ) then
49393: LD_VAR 0 1
49397: NOT
49398: PUSH
49399: LD_VAR 0 1
49403: PPUSH
49404: CALL_OW 310
49408: NOT
49409: OR
49410: IFFALSE 49414
// exit ;
49412: GO 49504
// vehicle := IsInUnit ( driver ) ;
49414: LD_ADDR_VAR 0 3
49418: PUSH
49419: LD_VAR 0 1
49423: PPUSH
49424: CALL_OW 310
49428: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49429: LD_VAR 0 1
49433: PPUSH
49434: LD_STRING \
49436: PUSH
49437: LD_INT 0
49439: PUSH
49440: LD_INT 0
49442: PUSH
49443: LD_INT 0
49445: PUSH
49446: LD_INT 0
49448: PUSH
49449: LD_INT 0
49451: PUSH
49452: LD_INT 0
49454: PUSH
49455: EMPTY
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: PUSH
49464: LD_STRING E
49466: PUSH
49467: LD_INT 0
49469: PUSH
49470: LD_INT 0
49472: PUSH
49473: LD_VAR 0 3
49477: PUSH
49478: LD_INT 0
49480: PUSH
49481: LD_INT 0
49483: PUSH
49484: LD_INT 0
49486: PUSH
49487: EMPTY
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: LIST
49493: LIST
49494: LIST
49495: PUSH
49496: EMPTY
49497: LIST
49498: LIST
49499: PPUSH
49500: CALL_OW 446
// end ;
49504: LD_VAR 0 2
49508: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49509: LD_INT 0
49511: PPUSH
49512: PPUSH
// if not driver or not IsInUnit ( driver ) then
49513: LD_VAR 0 1
49517: NOT
49518: PUSH
49519: LD_VAR 0 1
49523: PPUSH
49524: CALL_OW 310
49528: NOT
49529: OR
49530: IFFALSE 49534
// exit ;
49532: GO 49624
// vehicle := IsInUnit ( driver ) ;
49534: LD_ADDR_VAR 0 3
49538: PUSH
49539: LD_VAR 0 1
49543: PPUSH
49544: CALL_OW 310
49548: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49549: LD_VAR 0 1
49553: PPUSH
49554: LD_STRING \
49556: PUSH
49557: LD_INT 0
49559: PUSH
49560: LD_INT 0
49562: PUSH
49563: LD_INT 0
49565: PUSH
49566: LD_INT 0
49568: PUSH
49569: LD_INT 0
49571: PUSH
49572: LD_INT 0
49574: PUSH
49575: EMPTY
49576: LIST
49577: LIST
49578: LIST
49579: LIST
49580: LIST
49581: LIST
49582: LIST
49583: PUSH
49584: LD_STRING E
49586: PUSH
49587: LD_INT 0
49589: PUSH
49590: LD_INT 0
49592: PUSH
49593: LD_VAR 0 3
49597: PUSH
49598: LD_INT 0
49600: PUSH
49601: LD_INT 0
49603: PUSH
49604: LD_INT 0
49606: PUSH
49607: EMPTY
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: PUSH
49616: EMPTY
49617: LIST
49618: LIST
49619: PPUSH
49620: CALL_OW 447
// end ;
49624: LD_VAR 0 2
49628: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49629: LD_INT 0
49631: PPUSH
49632: PPUSH
49633: PPUSH
// tmp := [ ] ;
49634: LD_ADDR_VAR 0 5
49638: PUSH
49639: EMPTY
49640: ST_TO_ADDR
// for i in units do
49641: LD_ADDR_VAR 0 4
49645: PUSH
49646: LD_VAR 0 1
49650: PUSH
49651: FOR_IN
49652: IFFALSE 49690
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49654: LD_ADDR_VAR 0 5
49658: PUSH
49659: LD_VAR 0 5
49663: PPUSH
49664: LD_VAR 0 5
49668: PUSH
49669: LD_INT 1
49671: PLUS
49672: PPUSH
49673: LD_VAR 0 4
49677: PPUSH
49678: CALL_OW 256
49682: PPUSH
49683: CALL_OW 2
49687: ST_TO_ADDR
49688: GO 49651
49690: POP
49691: POP
// if not tmp then
49692: LD_VAR 0 5
49696: NOT
49697: IFFALSE 49701
// exit ;
49699: GO 49749
// if asc then
49701: LD_VAR 0 2
49705: IFFALSE 49729
// result := SortListByListAsc ( units , tmp ) else
49707: LD_ADDR_VAR 0 3
49711: PUSH
49712: LD_VAR 0 1
49716: PPUSH
49717: LD_VAR 0 5
49721: PPUSH
49722: CALL_OW 76
49726: ST_TO_ADDR
49727: GO 49749
// result := SortListByListDesc ( units , tmp ) ;
49729: LD_ADDR_VAR 0 3
49733: PUSH
49734: LD_VAR 0 1
49738: PPUSH
49739: LD_VAR 0 5
49743: PPUSH
49744: CALL_OW 77
49748: ST_TO_ADDR
// end ;
49749: LD_VAR 0 3
49753: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49754: LD_INT 0
49756: PPUSH
49757: PPUSH
// task := GetTaskList ( mech ) ;
49758: LD_ADDR_VAR 0 4
49762: PUSH
49763: LD_VAR 0 1
49767: PPUSH
49768: CALL_OW 437
49772: ST_TO_ADDR
// if not task then
49773: LD_VAR 0 4
49777: NOT
49778: IFFALSE 49782
// exit ;
49780: GO 49824
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49782: LD_ADDR_VAR 0 3
49786: PUSH
49787: LD_VAR 0 4
49791: PUSH
49792: LD_INT 1
49794: ARRAY
49795: PUSH
49796: LD_INT 1
49798: ARRAY
49799: PUSH
49800: LD_STRING r
49802: EQUAL
49803: PUSH
49804: LD_VAR 0 4
49808: PUSH
49809: LD_INT 1
49811: ARRAY
49812: PUSH
49813: LD_INT 4
49815: ARRAY
49816: PUSH
49817: LD_VAR 0 2
49821: EQUAL
49822: AND
49823: ST_TO_ADDR
// end ;
49824: LD_VAR 0 3
49828: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49829: LD_INT 0
49831: PPUSH
// SetDir ( unit , d ) ;
49832: LD_VAR 0 1
49836: PPUSH
49837: LD_VAR 0 4
49841: PPUSH
49842: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49846: LD_VAR 0 1
49850: PPUSH
49851: LD_VAR 0 2
49855: PPUSH
49856: LD_VAR 0 3
49860: PPUSH
49861: LD_VAR 0 5
49865: PPUSH
49866: CALL_OW 48
// end ;
49870: LD_VAR 0 6
49874: RET
// export function ToNaturalNumber ( number ) ; begin
49875: LD_INT 0
49877: PPUSH
// result := number div 1 ;
49878: LD_ADDR_VAR 0 2
49882: PUSH
49883: LD_VAR 0 1
49887: PUSH
49888: LD_INT 1
49890: DIV
49891: ST_TO_ADDR
// if number < 0 then
49892: LD_VAR 0 1
49896: PUSH
49897: LD_INT 0
49899: LESS
49900: IFFALSE 49910
// result := 0 ;
49902: LD_ADDR_VAR 0 2
49906: PUSH
49907: LD_INT 0
49909: ST_TO_ADDR
// end ;
49910: LD_VAR 0 2
49914: RET
// export function SortByClass ( units , class ) ; var un ; begin
49915: LD_INT 0
49917: PPUSH
49918: PPUSH
// if not units or not class then
49919: LD_VAR 0 1
49923: NOT
49924: PUSH
49925: LD_VAR 0 2
49929: NOT
49930: OR
49931: IFFALSE 49935
// exit ;
49933: GO 50030
// result := [ ] ;
49935: LD_ADDR_VAR 0 3
49939: PUSH
49940: EMPTY
49941: ST_TO_ADDR
// for un in units do
49942: LD_ADDR_VAR 0 4
49946: PUSH
49947: LD_VAR 0 1
49951: PUSH
49952: FOR_IN
49953: IFFALSE 50028
// if GetClass ( un ) = class then
49955: LD_VAR 0 4
49959: PPUSH
49960: CALL_OW 257
49964: PUSH
49965: LD_VAR 0 2
49969: EQUAL
49970: IFFALSE 49997
// result := Insert ( result , 1 , un ) else
49972: LD_ADDR_VAR 0 3
49976: PUSH
49977: LD_VAR 0 3
49981: PPUSH
49982: LD_INT 1
49984: PPUSH
49985: LD_VAR 0 4
49989: PPUSH
49990: CALL_OW 2
49994: ST_TO_ADDR
49995: GO 50026
// result := Replace ( result , result + 1 , un ) ;
49997: LD_ADDR_VAR 0 3
50001: PUSH
50002: LD_VAR 0 3
50006: PPUSH
50007: LD_VAR 0 3
50011: PUSH
50012: LD_INT 1
50014: PLUS
50015: PPUSH
50016: LD_VAR 0 4
50020: PPUSH
50021: CALL_OW 1
50025: ST_TO_ADDR
50026: GO 49952
50028: POP
50029: POP
// end ;
50030: LD_VAR 0 3
50034: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50035: LD_INT 0
50037: PPUSH
50038: PPUSH
50039: PPUSH
50040: PPUSH
50041: PPUSH
50042: PPUSH
50043: PPUSH
// result := [ ] ;
50044: LD_ADDR_VAR 0 4
50048: PUSH
50049: EMPTY
50050: ST_TO_ADDR
// if x - r < 0 then
50051: LD_VAR 0 1
50055: PUSH
50056: LD_VAR 0 3
50060: MINUS
50061: PUSH
50062: LD_INT 0
50064: LESS
50065: IFFALSE 50077
// min_x := 0 else
50067: LD_ADDR_VAR 0 8
50071: PUSH
50072: LD_INT 0
50074: ST_TO_ADDR
50075: GO 50093
// min_x := x - r ;
50077: LD_ADDR_VAR 0 8
50081: PUSH
50082: LD_VAR 0 1
50086: PUSH
50087: LD_VAR 0 3
50091: MINUS
50092: ST_TO_ADDR
// if y - r < 0 then
50093: LD_VAR 0 2
50097: PUSH
50098: LD_VAR 0 3
50102: MINUS
50103: PUSH
50104: LD_INT 0
50106: LESS
50107: IFFALSE 50119
// min_y := 0 else
50109: LD_ADDR_VAR 0 7
50113: PUSH
50114: LD_INT 0
50116: ST_TO_ADDR
50117: GO 50135
// min_y := y - r ;
50119: LD_ADDR_VAR 0 7
50123: PUSH
50124: LD_VAR 0 2
50128: PUSH
50129: LD_VAR 0 3
50133: MINUS
50134: ST_TO_ADDR
// max_x := x + r ;
50135: LD_ADDR_VAR 0 9
50139: PUSH
50140: LD_VAR 0 1
50144: PUSH
50145: LD_VAR 0 3
50149: PLUS
50150: ST_TO_ADDR
// max_y := y + r ;
50151: LD_ADDR_VAR 0 10
50155: PUSH
50156: LD_VAR 0 2
50160: PUSH
50161: LD_VAR 0 3
50165: PLUS
50166: ST_TO_ADDR
// for _x = min_x to max_x do
50167: LD_ADDR_VAR 0 5
50171: PUSH
50172: DOUBLE
50173: LD_VAR 0 8
50177: DEC
50178: ST_TO_ADDR
50179: LD_VAR 0 9
50183: PUSH
50184: FOR_TO
50185: IFFALSE 50286
// for _y = min_y to max_y do
50187: LD_ADDR_VAR 0 6
50191: PUSH
50192: DOUBLE
50193: LD_VAR 0 7
50197: DEC
50198: ST_TO_ADDR
50199: LD_VAR 0 10
50203: PUSH
50204: FOR_TO
50205: IFFALSE 50282
// begin if not ValidHex ( _x , _y ) then
50207: LD_VAR 0 5
50211: PPUSH
50212: LD_VAR 0 6
50216: PPUSH
50217: CALL_OW 488
50221: NOT
50222: IFFALSE 50226
// continue ;
50224: GO 50204
// if GetResourceTypeXY ( _x , _y ) then
50226: LD_VAR 0 5
50230: PPUSH
50231: LD_VAR 0 6
50235: PPUSH
50236: CALL_OW 283
50240: IFFALSE 50280
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50242: LD_ADDR_VAR 0 4
50246: PUSH
50247: LD_VAR 0 4
50251: PPUSH
50252: LD_VAR 0 4
50256: PUSH
50257: LD_INT 1
50259: PLUS
50260: PPUSH
50261: LD_VAR 0 5
50265: PUSH
50266: LD_VAR 0 6
50270: PUSH
50271: EMPTY
50272: LIST
50273: LIST
50274: PPUSH
50275: CALL_OW 1
50279: ST_TO_ADDR
// end ;
50280: GO 50204
50282: POP
50283: POP
50284: GO 50184
50286: POP
50287: POP
// end ;
50288: LD_VAR 0 4
50292: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
50293: LD_INT 0
50295: PPUSH
50296: PPUSH
50297: PPUSH
50298: PPUSH
50299: PPUSH
50300: PPUSH
50301: PPUSH
50302: PPUSH
// if not units then
50303: LD_VAR 0 1
50307: NOT
50308: IFFALSE 50312
// exit ;
50310: GO 50737
// result := UnitFilter ( units , [ f_ok ] ) ;
50312: LD_ADDR_VAR 0 3
50316: PUSH
50317: LD_VAR 0 1
50321: PPUSH
50322: LD_INT 50
50324: PUSH
50325: EMPTY
50326: LIST
50327: PPUSH
50328: CALL_OW 72
50332: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
50333: LD_ADDR_VAR 0 8
50337: PUSH
50338: LD_VAR 0 1
50342: PUSH
50343: LD_INT 1
50345: ARRAY
50346: PPUSH
50347: CALL_OW 255
50351: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
50352: LD_ADDR_VAR 0 10
50356: PUSH
50357: LD_INT 29
50359: PUSH
50360: LD_EXP 71
50364: PUSH
50365: EMPTY
50366: LIST
50367: LIST
50368: ST_TO_ADDR
// if not result then
50369: LD_VAR 0 3
50373: NOT
50374: IFFALSE 50378
// exit ;
50376: GO 50737
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
50378: LD_ADDR_VAR 0 5
50382: PUSH
50383: LD_INT 81
50385: PUSH
50386: LD_VAR 0 8
50390: PUSH
50391: EMPTY
50392: LIST
50393: LIST
50394: PPUSH
50395: CALL_OW 69
50399: ST_TO_ADDR
// for i in result do
50400: LD_ADDR_VAR 0 4
50404: PUSH
50405: LD_VAR 0 3
50409: PUSH
50410: FOR_IN
50411: IFFALSE 50735
// begin tag := GetTag ( i ) + 1 ;
50413: LD_ADDR_VAR 0 9
50417: PUSH
50418: LD_VAR 0 4
50422: PPUSH
50423: CALL_OW 110
50427: PUSH
50428: LD_INT 1
50430: PLUS
50431: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50432: LD_ADDR_VAR 0 7
50436: PUSH
50437: LD_VAR 0 4
50441: PPUSH
50442: CALL_OW 250
50446: PPUSH
50447: LD_VAR 0 4
50451: PPUSH
50452: CALL_OW 251
50456: PPUSH
50457: LD_INT 6
50459: PPUSH
50460: CALL 50035 0 3
50464: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
50465: LD_VAR 0 7
50469: PUSH
50470: LD_VAR 0 4
50474: PPUSH
50475: CALL_OW 264
50479: PUSH
50480: LD_VAR 0 10
50484: IN
50485: NOT
50486: AND
50487: IFFALSE 50526
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50489: LD_VAR 0 4
50493: PPUSH
50494: LD_VAR 0 7
50498: PUSH
50499: LD_INT 1
50501: ARRAY
50502: PUSH
50503: LD_INT 1
50505: ARRAY
50506: PPUSH
50507: LD_VAR 0 7
50511: PUSH
50512: LD_INT 1
50514: ARRAY
50515: PUSH
50516: LD_INT 2
50518: ARRAY
50519: PPUSH
50520: CALL_OW 116
50524: GO 50733
// if path > tag then
50526: LD_VAR 0 2
50530: PUSH
50531: LD_VAR 0 9
50535: GREATER
50536: IFFALSE 50703
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
50538: LD_ADDR_VAR 0 6
50542: PUSH
50543: LD_VAR 0 5
50547: PPUSH
50548: LD_INT 91
50550: PUSH
50551: LD_VAR 0 4
50555: PUSH
50556: LD_INT 12
50558: PUSH
50559: EMPTY
50560: LIST
50561: LIST
50562: LIST
50563: PPUSH
50564: CALL_OW 72
50568: ST_TO_ADDR
// if nearEnemy then
50569: LD_VAR 0 6
50573: IFFALSE 50601
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
50575: LD_VAR 0 4
50579: PPUSH
50580: LD_VAR 0 6
50584: PPUSH
50585: LD_VAR 0 4
50589: PPUSH
50590: CALL_OW 74
50594: PPUSH
50595: CALL_OW 115
50599: GO 50701
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50601: LD_VAR 0 4
50605: PPUSH
50606: LD_VAR 0 2
50610: PUSH
50611: LD_VAR 0 9
50615: ARRAY
50616: PUSH
50617: LD_INT 1
50619: ARRAY
50620: PPUSH
50621: LD_VAR 0 2
50625: PUSH
50626: LD_VAR 0 9
50630: ARRAY
50631: PUSH
50632: LD_INT 2
50634: ARRAY
50635: PPUSH
50636: CALL_OW 297
50640: PUSH
50641: LD_INT 6
50643: GREATER
50644: IFFALSE 50687
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50646: LD_VAR 0 4
50650: PPUSH
50651: LD_VAR 0 2
50655: PUSH
50656: LD_VAR 0 9
50660: ARRAY
50661: PUSH
50662: LD_INT 1
50664: ARRAY
50665: PPUSH
50666: LD_VAR 0 2
50670: PUSH
50671: LD_VAR 0 9
50675: ARRAY
50676: PUSH
50677: LD_INT 2
50679: ARRAY
50680: PPUSH
50681: CALL_OW 114
50685: GO 50701
// SetTag ( i , tag ) ;
50687: LD_VAR 0 4
50691: PPUSH
50692: LD_VAR 0 9
50696: PPUSH
50697: CALL_OW 109
// end else
50701: GO 50733
// if enemy then
50703: LD_VAR 0 5
50707: IFFALSE 50733
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50709: LD_VAR 0 4
50713: PPUSH
50714: LD_VAR 0 5
50718: PPUSH
50719: LD_VAR 0 4
50723: PPUSH
50724: CALL_OW 74
50728: PPUSH
50729: CALL_OW 115
// end ;
50733: GO 50410
50735: POP
50736: POP
// end ;
50737: LD_VAR 0 3
50741: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
50742: LD_INT 0
50744: PPUSH
50745: PPUSH
50746: PPUSH
// if not unit or IsInUnit ( unit ) then
50747: LD_VAR 0 1
50751: NOT
50752: PUSH
50753: LD_VAR 0 1
50757: PPUSH
50758: CALL_OW 310
50762: OR
50763: IFFALSE 50767
// exit ;
50765: GO 50858
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
50767: LD_ADDR_VAR 0 4
50771: PUSH
50772: LD_VAR 0 1
50776: PPUSH
50777: CALL_OW 250
50781: PPUSH
50782: LD_VAR 0 2
50786: PPUSH
50787: LD_INT 1
50789: PPUSH
50790: CALL_OW 272
50794: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
50795: LD_ADDR_VAR 0 5
50799: PUSH
50800: LD_VAR 0 1
50804: PPUSH
50805: CALL_OW 251
50809: PPUSH
50810: LD_VAR 0 2
50814: PPUSH
50815: LD_INT 1
50817: PPUSH
50818: CALL_OW 273
50822: ST_TO_ADDR
// if ValidHex ( x , y ) then
50823: LD_VAR 0 4
50827: PPUSH
50828: LD_VAR 0 5
50832: PPUSH
50833: CALL_OW 488
50837: IFFALSE 50858
// ComTurnXY ( unit , x , y ) ;
50839: LD_VAR 0 1
50843: PPUSH
50844: LD_VAR 0 4
50848: PPUSH
50849: LD_VAR 0 5
50853: PPUSH
50854: CALL_OW 118
// end ; end_of_file
50858: LD_VAR 0 3
50862: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
50863: LD_INT 0
50865: PPUSH
50866: PPUSH
// skirmish := false ;
50867: LD_ADDR_EXP 21
50871: PUSH
50872: LD_INT 0
50874: ST_TO_ADDR
// debug_mc := false ;
50875: LD_ADDR_EXP 22
50879: PUSH
50880: LD_INT 0
50882: ST_TO_ADDR
// mc_bases := [ ] ;
50883: LD_ADDR_EXP 23
50887: PUSH
50888: EMPTY
50889: ST_TO_ADDR
// mc_sides := [ ] ;
50890: LD_ADDR_EXP 49
50894: PUSH
50895: EMPTY
50896: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50897: LD_ADDR_EXP 24
50901: PUSH
50902: EMPTY
50903: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50904: LD_ADDR_EXP 25
50908: PUSH
50909: EMPTY
50910: ST_TO_ADDR
// mc_need_heal := [ ] ;
50911: LD_ADDR_EXP 26
50915: PUSH
50916: EMPTY
50917: ST_TO_ADDR
// mc_healers := [ ] ;
50918: LD_ADDR_EXP 27
50922: PUSH
50923: EMPTY
50924: ST_TO_ADDR
// mc_build_list := [ ] ;
50925: LD_ADDR_EXP 28
50929: PUSH
50930: EMPTY
50931: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50932: LD_ADDR_EXP 55
50936: PUSH
50937: EMPTY
50938: ST_TO_ADDR
// mc_builders := [ ] ;
50939: LD_ADDR_EXP 29
50943: PUSH
50944: EMPTY
50945: ST_TO_ADDR
// mc_construct_list := [ ] ;
50946: LD_ADDR_EXP 30
50950: PUSH
50951: EMPTY
50952: ST_TO_ADDR
// mc_turret_list := [ ] ;
50953: LD_ADDR_EXP 31
50957: PUSH
50958: EMPTY
50959: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50960: LD_ADDR_EXP 32
50964: PUSH
50965: EMPTY
50966: ST_TO_ADDR
// mc_miners := [ ] ;
50967: LD_ADDR_EXP 37
50971: PUSH
50972: EMPTY
50973: ST_TO_ADDR
// mc_mines := [ ] ;
50974: LD_ADDR_EXP 36
50978: PUSH
50979: EMPTY
50980: ST_TO_ADDR
// mc_minefields := [ ] ;
50981: LD_ADDR_EXP 38
50985: PUSH
50986: EMPTY
50987: ST_TO_ADDR
// mc_crates := [ ] ;
50988: LD_ADDR_EXP 39
50992: PUSH
50993: EMPTY
50994: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50995: LD_ADDR_EXP 40
50999: PUSH
51000: EMPTY
51001: ST_TO_ADDR
// mc_crates_area := [ ] ;
51002: LD_ADDR_EXP 41
51006: PUSH
51007: EMPTY
51008: ST_TO_ADDR
// mc_vehicles := [ ] ;
51009: LD_ADDR_EXP 42
51013: PUSH
51014: EMPTY
51015: ST_TO_ADDR
// mc_attack := [ ] ;
51016: LD_ADDR_EXP 43
51020: PUSH
51021: EMPTY
51022: ST_TO_ADDR
// mc_produce := [ ] ;
51023: LD_ADDR_EXP 44
51027: PUSH
51028: EMPTY
51029: ST_TO_ADDR
// mc_defender := [ ] ;
51030: LD_ADDR_EXP 45
51034: PUSH
51035: EMPTY
51036: ST_TO_ADDR
// mc_parking := [ ] ;
51037: LD_ADDR_EXP 47
51041: PUSH
51042: EMPTY
51043: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51044: LD_ADDR_EXP 33
51048: PUSH
51049: EMPTY
51050: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51051: LD_ADDR_EXP 35
51055: PUSH
51056: EMPTY
51057: ST_TO_ADDR
// mc_scan := [ ] ;
51058: LD_ADDR_EXP 46
51062: PUSH
51063: EMPTY
51064: ST_TO_ADDR
// mc_scan_area := [ ] ;
51065: LD_ADDR_EXP 48
51069: PUSH
51070: EMPTY
51071: ST_TO_ADDR
// mc_tech := [ ] ;
51072: LD_ADDR_EXP 50
51076: PUSH
51077: EMPTY
51078: ST_TO_ADDR
// mc_class := [ ] ;
51079: LD_ADDR_EXP 64
51083: PUSH
51084: EMPTY
51085: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51086: LD_ADDR_EXP 65
51090: PUSH
51091: EMPTY
51092: ST_TO_ADDR
// mc_is_defending := [ ] ;
51093: LD_ADDR_EXP 66
51097: PUSH
51098: EMPTY
51099: ST_TO_ADDR
// end ;
51100: LD_VAR 0 1
51104: RET
// export function MC_Kill ( base ) ; begin
51105: LD_INT 0
51107: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51108: LD_ADDR_EXP 23
51112: PUSH
51113: LD_EXP 23
51117: PPUSH
51118: LD_VAR 0 1
51122: PPUSH
51123: EMPTY
51124: PPUSH
51125: CALL_OW 1
51129: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51130: LD_ADDR_EXP 24
51134: PUSH
51135: LD_EXP 24
51139: PPUSH
51140: LD_VAR 0 1
51144: PPUSH
51145: EMPTY
51146: PPUSH
51147: CALL_OW 1
51151: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51152: LD_ADDR_EXP 25
51156: PUSH
51157: LD_EXP 25
51161: PPUSH
51162: LD_VAR 0 1
51166: PPUSH
51167: EMPTY
51168: PPUSH
51169: CALL_OW 1
51173: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51174: LD_ADDR_EXP 26
51178: PUSH
51179: LD_EXP 26
51183: PPUSH
51184: LD_VAR 0 1
51188: PPUSH
51189: EMPTY
51190: PPUSH
51191: CALL_OW 1
51195: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51196: LD_ADDR_EXP 27
51200: PUSH
51201: LD_EXP 27
51205: PPUSH
51206: LD_VAR 0 1
51210: PPUSH
51211: EMPTY
51212: PPUSH
51213: CALL_OW 1
51217: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51218: LD_ADDR_EXP 28
51222: PUSH
51223: LD_EXP 28
51227: PPUSH
51228: LD_VAR 0 1
51232: PPUSH
51233: EMPTY
51234: PPUSH
51235: CALL_OW 1
51239: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51240: LD_ADDR_EXP 29
51244: PUSH
51245: LD_EXP 29
51249: PPUSH
51250: LD_VAR 0 1
51254: PPUSH
51255: EMPTY
51256: PPUSH
51257: CALL_OW 1
51261: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51262: LD_ADDR_EXP 30
51266: PUSH
51267: LD_EXP 30
51271: PPUSH
51272: LD_VAR 0 1
51276: PPUSH
51277: EMPTY
51278: PPUSH
51279: CALL_OW 1
51283: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51284: LD_ADDR_EXP 31
51288: PUSH
51289: LD_EXP 31
51293: PPUSH
51294: LD_VAR 0 1
51298: PPUSH
51299: EMPTY
51300: PPUSH
51301: CALL_OW 1
51305: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51306: LD_ADDR_EXP 32
51310: PUSH
51311: LD_EXP 32
51315: PPUSH
51316: LD_VAR 0 1
51320: PPUSH
51321: EMPTY
51322: PPUSH
51323: CALL_OW 1
51327: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51328: LD_ADDR_EXP 33
51332: PUSH
51333: LD_EXP 33
51337: PPUSH
51338: LD_VAR 0 1
51342: PPUSH
51343: EMPTY
51344: PPUSH
51345: CALL_OW 1
51349: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51350: LD_ADDR_EXP 34
51354: PUSH
51355: LD_EXP 34
51359: PPUSH
51360: LD_VAR 0 1
51364: PPUSH
51365: LD_INT 0
51367: PPUSH
51368: CALL_OW 1
51372: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51373: LD_ADDR_EXP 35
51377: PUSH
51378: LD_EXP 35
51382: PPUSH
51383: LD_VAR 0 1
51387: PPUSH
51388: EMPTY
51389: PPUSH
51390: CALL_OW 1
51394: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51395: LD_ADDR_EXP 36
51399: PUSH
51400: LD_EXP 36
51404: PPUSH
51405: LD_VAR 0 1
51409: PPUSH
51410: EMPTY
51411: PPUSH
51412: CALL_OW 1
51416: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51417: LD_ADDR_EXP 37
51421: PUSH
51422: LD_EXP 37
51426: PPUSH
51427: LD_VAR 0 1
51431: PPUSH
51432: EMPTY
51433: PPUSH
51434: CALL_OW 1
51438: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51439: LD_ADDR_EXP 38
51443: PUSH
51444: LD_EXP 38
51448: PPUSH
51449: LD_VAR 0 1
51453: PPUSH
51454: EMPTY
51455: PPUSH
51456: CALL_OW 1
51460: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51461: LD_ADDR_EXP 39
51465: PUSH
51466: LD_EXP 39
51470: PPUSH
51471: LD_VAR 0 1
51475: PPUSH
51476: EMPTY
51477: PPUSH
51478: CALL_OW 1
51482: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51483: LD_ADDR_EXP 40
51487: PUSH
51488: LD_EXP 40
51492: PPUSH
51493: LD_VAR 0 1
51497: PPUSH
51498: EMPTY
51499: PPUSH
51500: CALL_OW 1
51504: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51505: LD_ADDR_EXP 41
51509: PUSH
51510: LD_EXP 41
51514: PPUSH
51515: LD_VAR 0 1
51519: PPUSH
51520: EMPTY
51521: PPUSH
51522: CALL_OW 1
51526: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51527: LD_ADDR_EXP 42
51531: PUSH
51532: LD_EXP 42
51536: PPUSH
51537: LD_VAR 0 1
51541: PPUSH
51542: EMPTY
51543: PPUSH
51544: CALL_OW 1
51548: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51549: LD_ADDR_EXP 43
51553: PUSH
51554: LD_EXP 43
51558: PPUSH
51559: LD_VAR 0 1
51563: PPUSH
51564: EMPTY
51565: PPUSH
51566: CALL_OW 1
51570: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51571: LD_ADDR_EXP 44
51575: PUSH
51576: LD_EXP 44
51580: PPUSH
51581: LD_VAR 0 1
51585: PPUSH
51586: EMPTY
51587: PPUSH
51588: CALL_OW 1
51592: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51593: LD_ADDR_EXP 45
51597: PUSH
51598: LD_EXP 45
51602: PPUSH
51603: LD_VAR 0 1
51607: PPUSH
51608: EMPTY
51609: PPUSH
51610: CALL_OW 1
51614: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51615: LD_ADDR_EXP 46
51619: PUSH
51620: LD_EXP 46
51624: PPUSH
51625: LD_VAR 0 1
51629: PPUSH
51630: EMPTY
51631: PPUSH
51632: CALL_OW 1
51636: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51637: LD_ADDR_EXP 47
51641: PUSH
51642: LD_EXP 47
51646: PPUSH
51647: LD_VAR 0 1
51651: PPUSH
51652: EMPTY
51653: PPUSH
51654: CALL_OW 1
51658: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51659: LD_ADDR_EXP 48
51663: PUSH
51664: LD_EXP 48
51668: PPUSH
51669: LD_VAR 0 1
51673: PPUSH
51674: EMPTY
51675: PPUSH
51676: CALL_OW 1
51680: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51681: LD_ADDR_EXP 50
51685: PUSH
51686: LD_EXP 50
51690: PPUSH
51691: LD_VAR 0 1
51695: PPUSH
51696: EMPTY
51697: PPUSH
51698: CALL_OW 1
51702: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51703: LD_ADDR_EXP 52
51707: PUSH
51708: LD_EXP 52
51712: PPUSH
51713: LD_VAR 0 1
51717: PPUSH
51718: EMPTY
51719: PPUSH
51720: CALL_OW 1
51724: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51725: LD_ADDR_EXP 53
51729: PUSH
51730: LD_EXP 53
51734: PPUSH
51735: LD_VAR 0 1
51739: PPUSH
51740: EMPTY
51741: PPUSH
51742: CALL_OW 1
51746: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51747: LD_ADDR_EXP 54
51751: PUSH
51752: LD_EXP 54
51756: PPUSH
51757: LD_VAR 0 1
51761: PPUSH
51762: EMPTY
51763: PPUSH
51764: CALL_OW 1
51768: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51769: LD_ADDR_EXP 55
51773: PUSH
51774: LD_EXP 55
51778: PPUSH
51779: LD_VAR 0 1
51783: PPUSH
51784: EMPTY
51785: PPUSH
51786: CALL_OW 1
51790: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51791: LD_ADDR_EXP 56
51795: PUSH
51796: LD_EXP 56
51800: PPUSH
51801: LD_VAR 0 1
51805: PPUSH
51806: EMPTY
51807: PPUSH
51808: CALL_OW 1
51812: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51813: LD_ADDR_EXP 57
51817: PUSH
51818: LD_EXP 57
51822: PPUSH
51823: LD_VAR 0 1
51827: PPUSH
51828: EMPTY
51829: PPUSH
51830: CALL_OW 1
51834: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51835: LD_ADDR_EXP 58
51839: PUSH
51840: LD_EXP 58
51844: PPUSH
51845: LD_VAR 0 1
51849: PPUSH
51850: EMPTY
51851: PPUSH
51852: CALL_OW 1
51856: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51857: LD_ADDR_EXP 59
51861: PUSH
51862: LD_EXP 59
51866: PPUSH
51867: LD_VAR 0 1
51871: PPUSH
51872: EMPTY
51873: PPUSH
51874: CALL_OW 1
51878: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51879: LD_ADDR_EXP 60
51883: PUSH
51884: LD_EXP 60
51888: PPUSH
51889: LD_VAR 0 1
51893: PPUSH
51894: EMPTY
51895: PPUSH
51896: CALL_OW 1
51900: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51901: LD_ADDR_EXP 61
51905: PUSH
51906: LD_EXP 61
51910: PPUSH
51911: LD_VAR 0 1
51915: PPUSH
51916: EMPTY
51917: PPUSH
51918: CALL_OW 1
51922: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51923: LD_ADDR_EXP 62
51927: PUSH
51928: LD_EXP 62
51932: PPUSH
51933: LD_VAR 0 1
51937: PPUSH
51938: EMPTY
51939: PPUSH
51940: CALL_OW 1
51944: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51945: LD_ADDR_EXP 63
51949: PUSH
51950: LD_EXP 63
51954: PPUSH
51955: LD_VAR 0 1
51959: PPUSH
51960: EMPTY
51961: PPUSH
51962: CALL_OW 1
51966: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51967: LD_ADDR_EXP 64
51971: PUSH
51972: LD_EXP 64
51976: PPUSH
51977: LD_VAR 0 1
51981: PPUSH
51982: EMPTY
51983: PPUSH
51984: CALL_OW 1
51988: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51989: LD_ADDR_EXP 65
51993: PUSH
51994: LD_EXP 65
51998: PPUSH
51999: LD_VAR 0 1
52003: PPUSH
52004: LD_INT 0
52006: PPUSH
52007: CALL_OW 1
52011: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52012: LD_ADDR_EXP 66
52016: PUSH
52017: LD_EXP 66
52021: PPUSH
52022: LD_VAR 0 1
52026: PPUSH
52027: LD_INT 0
52029: PPUSH
52030: CALL_OW 1
52034: ST_TO_ADDR
// end ;
52035: LD_VAR 0 2
52039: RET
// export function MC_Add ( side , units ) ; var base ; begin
52040: LD_INT 0
52042: PPUSH
52043: PPUSH
// base := mc_bases + 1 ;
52044: LD_ADDR_VAR 0 4
52048: PUSH
52049: LD_EXP 23
52053: PUSH
52054: LD_INT 1
52056: PLUS
52057: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52058: LD_ADDR_EXP 49
52062: PUSH
52063: LD_EXP 49
52067: PPUSH
52068: LD_VAR 0 4
52072: PPUSH
52073: LD_VAR 0 1
52077: PPUSH
52078: CALL_OW 1
52082: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52083: LD_ADDR_EXP 23
52087: PUSH
52088: LD_EXP 23
52092: PPUSH
52093: LD_VAR 0 4
52097: PPUSH
52098: LD_VAR 0 2
52102: PPUSH
52103: CALL_OW 1
52107: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52108: LD_ADDR_EXP 24
52112: PUSH
52113: LD_EXP 24
52117: PPUSH
52118: LD_VAR 0 4
52122: PPUSH
52123: EMPTY
52124: PPUSH
52125: CALL_OW 1
52129: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52130: LD_ADDR_EXP 25
52134: PUSH
52135: LD_EXP 25
52139: PPUSH
52140: LD_VAR 0 4
52144: PPUSH
52145: EMPTY
52146: PPUSH
52147: CALL_OW 1
52151: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52152: LD_ADDR_EXP 26
52156: PUSH
52157: LD_EXP 26
52161: PPUSH
52162: LD_VAR 0 4
52166: PPUSH
52167: EMPTY
52168: PPUSH
52169: CALL_OW 1
52173: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52174: LD_ADDR_EXP 27
52178: PUSH
52179: LD_EXP 27
52183: PPUSH
52184: LD_VAR 0 4
52188: PPUSH
52189: EMPTY
52190: PPUSH
52191: CALL_OW 1
52195: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52196: LD_ADDR_EXP 28
52200: PUSH
52201: LD_EXP 28
52205: PPUSH
52206: LD_VAR 0 4
52210: PPUSH
52211: EMPTY
52212: PPUSH
52213: CALL_OW 1
52217: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52218: LD_ADDR_EXP 29
52222: PUSH
52223: LD_EXP 29
52227: PPUSH
52228: LD_VAR 0 4
52232: PPUSH
52233: EMPTY
52234: PPUSH
52235: CALL_OW 1
52239: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52240: LD_ADDR_EXP 30
52244: PUSH
52245: LD_EXP 30
52249: PPUSH
52250: LD_VAR 0 4
52254: PPUSH
52255: EMPTY
52256: PPUSH
52257: CALL_OW 1
52261: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52262: LD_ADDR_EXP 31
52266: PUSH
52267: LD_EXP 31
52271: PPUSH
52272: LD_VAR 0 4
52276: PPUSH
52277: EMPTY
52278: PPUSH
52279: CALL_OW 1
52283: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52284: LD_ADDR_EXP 32
52288: PUSH
52289: LD_EXP 32
52293: PPUSH
52294: LD_VAR 0 4
52298: PPUSH
52299: EMPTY
52300: PPUSH
52301: CALL_OW 1
52305: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52306: LD_ADDR_EXP 33
52310: PUSH
52311: LD_EXP 33
52315: PPUSH
52316: LD_VAR 0 4
52320: PPUSH
52321: EMPTY
52322: PPUSH
52323: CALL_OW 1
52327: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52328: LD_ADDR_EXP 34
52332: PUSH
52333: LD_EXP 34
52337: PPUSH
52338: LD_VAR 0 4
52342: PPUSH
52343: LD_INT 0
52345: PPUSH
52346: CALL_OW 1
52350: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52351: LD_ADDR_EXP 35
52355: PUSH
52356: LD_EXP 35
52360: PPUSH
52361: LD_VAR 0 4
52365: PPUSH
52366: EMPTY
52367: PPUSH
52368: CALL_OW 1
52372: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52373: LD_ADDR_EXP 36
52377: PUSH
52378: LD_EXP 36
52382: PPUSH
52383: LD_VAR 0 4
52387: PPUSH
52388: EMPTY
52389: PPUSH
52390: CALL_OW 1
52394: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52395: LD_ADDR_EXP 37
52399: PUSH
52400: LD_EXP 37
52404: PPUSH
52405: LD_VAR 0 4
52409: PPUSH
52410: EMPTY
52411: PPUSH
52412: CALL_OW 1
52416: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52417: LD_ADDR_EXP 38
52421: PUSH
52422: LD_EXP 38
52426: PPUSH
52427: LD_VAR 0 4
52431: PPUSH
52432: EMPTY
52433: PPUSH
52434: CALL_OW 1
52438: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52439: LD_ADDR_EXP 39
52443: PUSH
52444: LD_EXP 39
52448: PPUSH
52449: LD_VAR 0 4
52453: PPUSH
52454: EMPTY
52455: PPUSH
52456: CALL_OW 1
52460: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52461: LD_ADDR_EXP 40
52465: PUSH
52466: LD_EXP 40
52470: PPUSH
52471: LD_VAR 0 4
52475: PPUSH
52476: EMPTY
52477: PPUSH
52478: CALL_OW 1
52482: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52483: LD_ADDR_EXP 41
52487: PUSH
52488: LD_EXP 41
52492: PPUSH
52493: LD_VAR 0 4
52497: PPUSH
52498: EMPTY
52499: PPUSH
52500: CALL_OW 1
52504: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52505: LD_ADDR_EXP 42
52509: PUSH
52510: LD_EXP 42
52514: PPUSH
52515: LD_VAR 0 4
52519: PPUSH
52520: EMPTY
52521: PPUSH
52522: CALL_OW 1
52526: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52527: LD_ADDR_EXP 43
52531: PUSH
52532: LD_EXP 43
52536: PPUSH
52537: LD_VAR 0 4
52541: PPUSH
52542: EMPTY
52543: PPUSH
52544: CALL_OW 1
52548: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52549: LD_ADDR_EXP 44
52553: PUSH
52554: LD_EXP 44
52558: PPUSH
52559: LD_VAR 0 4
52563: PPUSH
52564: EMPTY
52565: PPUSH
52566: CALL_OW 1
52570: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52571: LD_ADDR_EXP 45
52575: PUSH
52576: LD_EXP 45
52580: PPUSH
52581: LD_VAR 0 4
52585: PPUSH
52586: EMPTY
52587: PPUSH
52588: CALL_OW 1
52592: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52593: LD_ADDR_EXP 46
52597: PUSH
52598: LD_EXP 46
52602: PPUSH
52603: LD_VAR 0 4
52607: PPUSH
52608: EMPTY
52609: PPUSH
52610: CALL_OW 1
52614: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52615: LD_ADDR_EXP 47
52619: PUSH
52620: LD_EXP 47
52624: PPUSH
52625: LD_VAR 0 4
52629: PPUSH
52630: EMPTY
52631: PPUSH
52632: CALL_OW 1
52636: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52637: LD_ADDR_EXP 48
52641: PUSH
52642: LD_EXP 48
52646: PPUSH
52647: LD_VAR 0 4
52651: PPUSH
52652: EMPTY
52653: PPUSH
52654: CALL_OW 1
52658: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52659: LD_ADDR_EXP 50
52663: PUSH
52664: LD_EXP 50
52668: PPUSH
52669: LD_VAR 0 4
52673: PPUSH
52674: EMPTY
52675: PPUSH
52676: CALL_OW 1
52680: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52681: LD_ADDR_EXP 52
52685: PUSH
52686: LD_EXP 52
52690: PPUSH
52691: LD_VAR 0 4
52695: PPUSH
52696: EMPTY
52697: PPUSH
52698: CALL_OW 1
52702: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52703: LD_ADDR_EXP 53
52707: PUSH
52708: LD_EXP 53
52712: PPUSH
52713: LD_VAR 0 4
52717: PPUSH
52718: EMPTY
52719: PPUSH
52720: CALL_OW 1
52724: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52725: LD_ADDR_EXP 54
52729: PUSH
52730: LD_EXP 54
52734: PPUSH
52735: LD_VAR 0 4
52739: PPUSH
52740: EMPTY
52741: PPUSH
52742: CALL_OW 1
52746: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52747: LD_ADDR_EXP 55
52751: PUSH
52752: LD_EXP 55
52756: PPUSH
52757: LD_VAR 0 4
52761: PPUSH
52762: EMPTY
52763: PPUSH
52764: CALL_OW 1
52768: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52769: LD_ADDR_EXP 56
52773: PUSH
52774: LD_EXP 56
52778: PPUSH
52779: LD_VAR 0 4
52783: PPUSH
52784: EMPTY
52785: PPUSH
52786: CALL_OW 1
52790: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52791: LD_ADDR_EXP 57
52795: PUSH
52796: LD_EXP 57
52800: PPUSH
52801: LD_VAR 0 4
52805: PPUSH
52806: EMPTY
52807: PPUSH
52808: CALL_OW 1
52812: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52813: LD_ADDR_EXP 58
52817: PUSH
52818: LD_EXP 58
52822: PPUSH
52823: LD_VAR 0 4
52827: PPUSH
52828: EMPTY
52829: PPUSH
52830: CALL_OW 1
52834: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52835: LD_ADDR_EXP 59
52839: PUSH
52840: LD_EXP 59
52844: PPUSH
52845: LD_VAR 0 4
52849: PPUSH
52850: EMPTY
52851: PPUSH
52852: CALL_OW 1
52856: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52857: LD_ADDR_EXP 60
52861: PUSH
52862: LD_EXP 60
52866: PPUSH
52867: LD_VAR 0 4
52871: PPUSH
52872: EMPTY
52873: PPUSH
52874: CALL_OW 1
52878: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52879: LD_ADDR_EXP 61
52883: PUSH
52884: LD_EXP 61
52888: PPUSH
52889: LD_VAR 0 4
52893: PPUSH
52894: EMPTY
52895: PPUSH
52896: CALL_OW 1
52900: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52901: LD_ADDR_EXP 62
52905: PUSH
52906: LD_EXP 62
52910: PPUSH
52911: LD_VAR 0 4
52915: PPUSH
52916: EMPTY
52917: PPUSH
52918: CALL_OW 1
52922: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52923: LD_ADDR_EXP 63
52927: PUSH
52928: LD_EXP 63
52932: PPUSH
52933: LD_VAR 0 4
52937: PPUSH
52938: EMPTY
52939: PPUSH
52940: CALL_OW 1
52944: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52945: LD_ADDR_EXP 64
52949: PUSH
52950: LD_EXP 64
52954: PPUSH
52955: LD_VAR 0 4
52959: PPUSH
52960: EMPTY
52961: PPUSH
52962: CALL_OW 1
52966: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52967: LD_ADDR_EXP 65
52971: PUSH
52972: LD_EXP 65
52976: PPUSH
52977: LD_VAR 0 4
52981: PPUSH
52982: LD_INT 0
52984: PPUSH
52985: CALL_OW 1
52989: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52990: LD_ADDR_EXP 66
52994: PUSH
52995: LD_EXP 66
52999: PPUSH
53000: LD_VAR 0 4
53004: PPUSH
53005: LD_INT 0
53007: PPUSH
53008: CALL_OW 1
53012: ST_TO_ADDR
// result := base ;
53013: LD_ADDR_VAR 0 3
53017: PUSH
53018: LD_VAR 0 4
53022: ST_TO_ADDR
// end ;
53023: LD_VAR 0 3
53027: RET
// export function MC_Start ( ) ; var i ; begin
53028: LD_INT 0
53030: PPUSH
53031: PPUSH
// for i = 1 to mc_bases do
53032: LD_ADDR_VAR 0 2
53036: PUSH
53037: DOUBLE
53038: LD_INT 1
53040: DEC
53041: ST_TO_ADDR
53042: LD_EXP 23
53046: PUSH
53047: FOR_TO
53048: IFFALSE 54148
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53050: LD_ADDR_EXP 23
53054: PUSH
53055: LD_EXP 23
53059: PPUSH
53060: LD_VAR 0 2
53064: PPUSH
53065: LD_EXP 23
53069: PUSH
53070: LD_VAR 0 2
53074: ARRAY
53075: PUSH
53076: LD_INT 0
53078: DIFF
53079: PPUSH
53080: CALL_OW 1
53084: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53085: LD_ADDR_EXP 24
53089: PUSH
53090: LD_EXP 24
53094: PPUSH
53095: LD_VAR 0 2
53099: PPUSH
53100: EMPTY
53101: PPUSH
53102: CALL_OW 1
53106: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53107: LD_ADDR_EXP 25
53111: PUSH
53112: LD_EXP 25
53116: PPUSH
53117: LD_VAR 0 2
53121: PPUSH
53122: EMPTY
53123: PPUSH
53124: CALL_OW 1
53128: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53129: LD_ADDR_EXP 26
53133: PUSH
53134: LD_EXP 26
53138: PPUSH
53139: LD_VAR 0 2
53143: PPUSH
53144: EMPTY
53145: PPUSH
53146: CALL_OW 1
53150: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53151: LD_ADDR_EXP 27
53155: PUSH
53156: LD_EXP 27
53160: PPUSH
53161: LD_VAR 0 2
53165: PPUSH
53166: EMPTY
53167: PUSH
53168: EMPTY
53169: PUSH
53170: EMPTY
53171: LIST
53172: LIST
53173: PPUSH
53174: CALL_OW 1
53178: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53179: LD_ADDR_EXP 28
53183: PUSH
53184: LD_EXP 28
53188: PPUSH
53189: LD_VAR 0 2
53193: PPUSH
53194: EMPTY
53195: PPUSH
53196: CALL_OW 1
53200: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53201: LD_ADDR_EXP 55
53205: PUSH
53206: LD_EXP 55
53210: PPUSH
53211: LD_VAR 0 2
53215: PPUSH
53216: EMPTY
53217: PPUSH
53218: CALL_OW 1
53222: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53223: LD_ADDR_EXP 29
53227: PUSH
53228: LD_EXP 29
53232: PPUSH
53233: LD_VAR 0 2
53237: PPUSH
53238: EMPTY
53239: PPUSH
53240: CALL_OW 1
53244: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53245: LD_ADDR_EXP 30
53249: PUSH
53250: LD_EXP 30
53254: PPUSH
53255: LD_VAR 0 2
53259: PPUSH
53260: EMPTY
53261: PPUSH
53262: CALL_OW 1
53266: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53267: LD_ADDR_EXP 31
53271: PUSH
53272: LD_EXP 31
53276: PPUSH
53277: LD_VAR 0 2
53281: PPUSH
53282: LD_EXP 23
53286: PUSH
53287: LD_VAR 0 2
53291: ARRAY
53292: PPUSH
53293: LD_INT 2
53295: PUSH
53296: LD_INT 30
53298: PUSH
53299: LD_INT 32
53301: PUSH
53302: EMPTY
53303: LIST
53304: LIST
53305: PUSH
53306: LD_INT 30
53308: PUSH
53309: LD_INT 33
53311: PUSH
53312: EMPTY
53313: LIST
53314: LIST
53315: PUSH
53316: EMPTY
53317: LIST
53318: LIST
53319: LIST
53320: PPUSH
53321: CALL_OW 72
53325: PPUSH
53326: CALL_OW 1
53330: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53331: LD_ADDR_EXP 32
53335: PUSH
53336: LD_EXP 32
53340: PPUSH
53341: LD_VAR 0 2
53345: PPUSH
53346: LD_EXP 23
53350: PUSH
53351: LD_VAR 0 2
53355: ARRAY
53356: PPUSH
53357: LD_INT 2
53359: PUSH
53360: LD_INT 30
53362: PUSH
53363: LD_INT 32
53365: PUSH
53366: EMPTY
53367: LIST
53368: LIST
53369: PUSH
53370: LD_INT 30
53372: PUSH
53373: LD_INT 31
53375: PUSH
53376: EMPTY
53377: LIST
53378: LIST
53379: PUSH
53380: EMPTY
53381: LIST
53382: LIST
53383: LIST
53384: PUSH
53385: LD_INT 58
53387: PUSH
53388: EMPTY
53389: LIST
53390: PUSH
53391: EMPTY
53392: LIST
53393: LIST
53394: PPUSH
53395: CALL_OW 72
53399: PPUSH
53400: CALL_OW 1
53404: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53405: LD_ADDR_EXP 33
53409: PUSH
53410: LD_EXP 33
53414: PPUSH
53415: LD_VAR 0 2
53419: PPUSH
53420: EMPTY
53421: PPUSH
53422: CALL_OW 1
53426: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53427: LD_ADDR_EXP 37
53431: PUSH
53432: LD_EXP 37
53436: PPUSH
53437: LD_VAR 0 2
53441: PPUSH
53442: EMPTY
53443: PPUSH
53444: CALL_OW 1
53448: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53449: LD_ADDR_EXP 36
53453: PUSH
53454: LD_EXP 36
53458: PPUSH
53459: LD_VAR 0 2
53463: PPUSH
53464: EMPTY
53465: PPUSH
53466: CALL_OW 1
53470: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53471: LD_ADDR_EXP 38
53475: PUSH
53476: LD_EXP 38
53480: PPUSH
53481: LD_VAR 0 2
53485: PPUSH
53486: EMPTY
53487: PPUSH
53488: CALL_OW 1
53492: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53493: LD_ADDR_EXP 39
53497: PUSH
53498: LD_EXP 39
53502: PPUSH
53503: LD_VAR 0 2
53507: PPUSH
53508: EMPTY
53509: PPUSH
53510: CALL_OW 1
53514: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53515: LD_ADDR_EXP 40
53519: PUSH
53520: LD_EXP 40
53524: PPUSH
53525: LD_VAR 0 2
53529: PPUSH
53530: EMPTY
53531: PPUSH
53532: CALL_OW 1
53536: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53537: LD_ADDR_EXP 41
53541: PUSH
53542: LD_EXP 41
53546: PPUSH
53547: LD_VAR 0 2
53551: PPUSH
53552: EMPTY
53553: PPUSH
53554: CALL_OW 1
53558: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53559: LD_ADDR_EXP 42
53563: PUSH
53564: LD_EXP 42
53568: PPUSH
53569: LD_VAR 0 2
53573: PPUSH
53574: EMPTY
53575: PPUSH
53576: CALL_OW 1
53580: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53581: LD_ADDR_EXP 43
53585: PUSH
53586: LD_EXP 43
53590: PPUSH
53591: LD_VAR 0 2
53595: PPUSH
53596: EMPTY
53597: PPUSH
53598: CALL_OW 1
53602: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53603: LD_ADDR_EXP 44
53607: PUSH
53608: LD_EXP 44
53612: PPUSH
53613: LD_VAR 0 2
53617: PPUSH
53618: EMPTY
53619: PPUSH
53620: CALL_OW 1
53624: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53625: LD_ADDR_EXP 45
53629: PUSH
53630: LD_EXP 45
53634: PPUSH
53635: LD_VAR 0 2
53639: PPUSH
53640: EMPTY
53641: PPUSH
53642: CALL_OW 1
53646: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53647: LD_ADDR_EXP 34
53651: PUSH
53652: LD_EXP 34
53656: PPUSH
53657: LD_VAR 0 2
53661: PPUSH
53662: LD_INT 0
53664: PPUSH
53665: CALL_OW 1
53669: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53670: LD_ADDR_EXP 47
53674: PUSH
53675: LD_EXP 47
53679: PPUSH
53680: LD_VAR 0 2
53684: PPUSH
53685: LD_INT 0
53687: PPUSH
53688: CALL_OW 1
53692: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53693: LD_ADDR_EXP 35
53697: PUSH
53698: LD_EXP 35
53702: PPUSH
53703: LD_VAR 0 2
53707: PPUSH
53708: EMPTY
53709: PPUSH
53710: CALL_OW 1
53714: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53715: LD_ADDR_EXP 46
53719: PUSH
53720: LD_EXP 46
53724: PPUSH
53725: LD_VAR 0 2
53729: PPUSH
53730: LD_INT 0
53732: PPUSH
53733: CALL_OW 1
53737: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53738: LD_ADDR_EXP 48
53742: PUSH
53743: LD_EXP 48
53747: PPUSH
53748: LD_VAR 0 2
53752: PPUSH
53753: EMPTY
53754: PPUSH
53755: CALL_OW 1
53759: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53760: LD_ADDR_EXP 51
53764: PUSH
53765: LD_EXP 51
53769: PPUSH
53770: LD_VAR 0 2
53774: PPUSH
53775: LD_INT 0
53777: PPUSH
53778: CALL_OW 1
53782: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53783: LD_ADDR_EXP 52
53787: PUSH
53788: LD_EXP 52
53792: PPUSH
53793: LD_VAR 0 2
53797: PPUSH
53798: EMPTY
53799: PPUSH
53800: CALL_OW 1
53804: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53805: LD_ADDR_EXP 53
53809: PUSH
53810: LD_EXP 53
53814: PPUSH
53815: LD_VAR 0 2
53819: PPUSH
53820: EMPTY
53821: PPUSH
53822: CALL_OW 1
53826: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53827: LD_ADDR_EXP 54
53831: PUSH
53832: LD_EXP 54
53836: PPUSH
53837: LD_VAR 0 2
53841: PPUSH
53842: EMPTY
53843: PPUSH
53844: CALL_OW 1
53848: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
53849: LD_ADDR_EXP 56
53853: PUSH
53854: LD_EXP 56
53858: PPUSH
53859: LD_VAR 0 2
53863: PPUSH
53864: LD_EXP 23
53868: PUSH
53869: LD_VAR 0 2
53873: ARRAY
53874: PPUSH
53875: LD_INT 2
53877: PUSH
53878: LD_INT 30
53880: PUSH
53881: LD_INT 6
53883: PUSH
53884: EMPTY
53885: LIST
53886: LIST
53887: PUSH
53888: LD_INT 30
53890: PUSH
53891: LD_INT 7
53893: PUSH
53894: EMPTY
53895: LIST
53896: LIST
53897: PUSH
53898: LD_INT 30
53900: PUSH
53901: LD_INT 8
53903: PUSH
53904: EMPTY
53905: LIST
53906: LIST
53907: PUSH
53908: EMPTY
53909: LIST
53910: LIST
53911: LIST
53912: LIST
53913: PPUSH
53914: CALL_OW 72
53918: PPUSH
53919: CALL_OW 1
53923: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53924: LD_ADDR_EXP 57
53928: PUSH
53929: LD_EXP 57
53933: PPUSH
53934: LD_VAR 0 2
53938: PPUSH
53939: EMPTY
53940: PPUSH
53941: CALL_OW 1
53945: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53946: LD_ADDR_EXP 58
53950: PUSH
53951: LD_EXP 58
53955: PPUSH
53956: LD_VAR 0 2
53960: PPUSH
53961: EMPTY
53962: PPUSH
53963: CALL_OW 1
53967: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53968: LD_ADDR_EXP 59
53972: PUSH
53973: LD_EXP 59
53977: PPUSH
53978: LD_VAR 0 2
53982: PPUSH
53983: EMPTY
53984: PPUSH
53985: CALL_OW 1
53989: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53990: LD_ADDR_EXP 60
53994: PUSH
53995: LD_EXP 60
53999: PPUSH
54000: LD_VAR 0 2
54004: PPUSH
54005: EMPTY
54006: PPUSH
54007: CALL_OW 1
54011: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54012: LD_ADDR_EXP 61
54016: PUSH
54017: LD_EXP 61
54021: PPUSH
54022: LD_VAR 0 2
54026: PPUSH
54027: EMPTY
54028: PPUSH
54029: CALL_OW 1
54033: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54034: LD_ADDR_EXP 62
54038: PUSH
54039: LD_EXP 62
54043: PPUSH
54044: LD_VAR 0 2
54048: PPUSH
54049: EMPTY
54050: PPUSH
54051: CALL_OW 1
54055: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54056: LD_ADDR_EXP 63
54060: PUSH
54061: LD_EXP 63
54065: PPUSH
54066: LD_VAR 0 2
54070: PPUSH
54071: EMPTY
54072: PPUSH
54073: CALL_OW 1
54077: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54078: LD_ADDR_EXP 64
54082: PUSH
54083: LD_EXP 64
54087: PPUSH
54088: LD_VAR 0 2
54092: PPUSH
54093: EMPTY
54094: PPUSH
54095: CALL_OW 1
54099: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54100: LD_ADDR_EXP 65
54104: PUSH
54105: LD_EXP 65
54109: PPUSH
54110: LD_VAR 0 2
54114: PPUSH
54115: LD_INT 0
54117: PPUSH
54118: CALL_OW 1
54122: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54123: LD_ADDR_EXP 66
54127: PUSH
54128: LD_EXP 66
54132: PPUSH
54133: LD_VAR 0 2
54137: PPUSH
54138: LD_INT 0
54140: PPUSH
54141: CALL_OW 1
54145: ST_TO_ADDR
// end ;
54146: GO 53047
54148: POP
54149: POP
// MC_InitSides ( ) ;
54150: CALL 54436 0 0
// MC_InitResearch ( ) ;
54154: CALL 54175 0 0
// CustomInitMacro ( ) ;
54158: CALL 277 0 0
// skirmish := true ;
54162: LD_ADDR_EXP 21
54166: PUSH
54167: LD_INT 1
54169: ST_TO_ADDR
// end ;
54170: LD_VAR 0 1
54174: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54175: LD_INT 0
54177: PPUSH
54178: PPUSH
54179: PPUSH
54180: PPUSH
54181: PPUSH
54182: PPUSH
// if not mc_bases then
54183: LD_EXP 23
54187: NOT
54188: IFFALSE 54192
// exit ;
54190: GO 54431
// for i = 1 to 8 do
54192: LD_ADDR_VAR 0 2
54196: PUSH
54197: DOUBLE
54198: LD_INT 1
54200: DEC
54201: ST_TO_ADDR
54202: LD_INT 8
54204: PUSH
54205: FOR_TO
54206: IFFALSE 54232
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54208: LD_ADDR_EXP 50
54212: PUSH
54213: LD_EXP 50
54217: PPUSH
54218: LD_VAR 0 2
54222: PPUSH
54223: EMPTY
54224: PPUSH
54225: CALL_OW 1
54229: ST_TO_ADDR
54230: GO 54205
54232: POP
54233: POP
// tmp := [ ] ;
54234: LD_ADDR_VAR 0 5
54238: PUSH
54239: EMPTY
54240: ST_TO_ADDR
// for i = 1 to mc_sides do
54241: LD_ADDR_VAR 0 2
54245: PUSH
54246: DOUBLE
54247: LD_INT 1
54249: DEC
54250: ST_TO_ADDR
54251: LD_EXP 49
54255: PUSH
54256: FOR_TO
54257: IFFALSE 54315
// if not mc_sides [ i ] in tmp then
54259: LD_EXP 49
54263: PUSH
54264: LD_VAR 0 2
54268: ARRAY
54269: PUSH
54270: LD_VAR 0 5
54274: IN
54275: NOT
54276: IFFALSE 54313
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54278: LD_ADDR_VAR 0 5
54282: PUSH
54283: LD_VAR 0 5
54287: PPUSH
54288: LD_VAR 0 5
54292: PUSH
54293: LD_INT 1
54295: PLUS
54296: PPUSH
54297: LD_EXP 49
54301: PUSH
54302: LD_VAR 0 2
54306: ARRAY
54307: PPUSH
54308: CALL_OW 2
54312: ST_TO_ADDR
54313: GO 54256
54315: POP
54316: POP
// if not tmp then
54317: LD_VAR 0 5
54321: NOT
54322: IFFALSE 54326
// exit ;
54324: GO 54431
// for j in tmp do
54326: LD_ADDR_VAR 0 3
54330: PUSH
54331: LD_VAR 0 5
54335: PUSH
54336: FOR_IN
54337: IFFALSE 54429
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54339: LD_ADDR_VAR 0 6
54343: PUSH
54344: LD_INT 22
54346: PUSH
54347: LD_VAR 0 3
54351: PUSH
54352: EMPTY
54353: LIST
54354: LIST
54355: PPUSH
54356: CALL_OW 69
54360: ST_TO_ADDR
// if not un then
54361: LD_VAR 0 6
54365: NOT
54366: IFFALSE 54370
// continue ;
54368: GO 54336
// nation := GetNation ( un [ 1 ] ) ;
54370: LD_ADDR_VAR 0 4
54374: PUSH
54375: LD_VAR 0 6
54379: PUSH
54380: LD_INT 1
54382: ARRAY
54383: PPUSH
54384: CALL_OW 248
54388: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54389: LD_ADDR_EXP 50
54393: PUSH
54394: LD_EXP 50
54398: PPUSH
54399: LD_VAR 0 3
54403: PPUSH
54404: LD_VAR 0 3
54408: PPUSH
54409: LD_VAR 0 4
54413: PPUSH
54414: LD_INT 1
54416: PPUSH
54417: CALL 11067 0 3
54421: PPUSH
54422: CALL_OW 1
54426: ST_TO_ADDR
// end ;
54427: GO 54336
54429: POP
54430: POP
// end ;
54431: LD_VAR 0 1
54435: RET
// export function MC_InitSides ( ) ; var i ; begin
54436: LD_INT 0
54438: PPUSH
54439: PPUSH
// if not mc_bases then
54440: LD_EXP 23
54444: NOT
54445: IFFALSE 54449
// exit ;
54447: GO 54523
// for i = 1 to mc_bases do
54449: LD_ADDR_VAR 0 2
54453: PUSH
54454: DOUBLE
54455: LD_INT 1
54457: DEC
54458: ST_TO_ADDR
54459: LD_EXP 23
54463: PUSH
54464: FOR_TO
54465: IFFALSE 54521
// if mc_bases [ i ] then
54467: LD_EXP 23
54471: PUSH
54472: LD_VAR 0 2
54476: ARRAY
54477: IFFALSE 54519
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54479: LD_ADDR_EXP 49
54483: PUSH
54484: LD_EXP 49
54488: PPUSH
54489: LD_VAR 0 2
54493: PPUSH
54494: LD_EXP 23
54498: PUSH
54499: LD_VAR 0 2
54503: ARRAY
54504: PUSH
54505: LD_INT 1
54507: ARRAY
54508: PPUSH
54509: CALL_OW 255
54513: PPUSH
54514: CALL_OW 1
54518: ST_TO_ADDR
54519: GO 54464
54521: POP
54522: POP
// end ;
54523: LD_VAR 0 1
54527: RET
// every 0 0$03 trigger skirmish do
54528: LD_EXP 21
54532: IFFALSE 54686
54534: GO 54536
54536: DISABLE
// begin enable ;
54537: ENABLE
// MC_CheckBuildings ( ) ;
54538: CALL 59184 0 0
// MC_CheckPeopleLife ( ) ;
54542: CALL 59345 0 0
// RaiseSailEvent ( 100 ) ;
54546: LD_INT 100
54548: PPUSH
54549: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54553: LD_INT 103
54555: PPUSH
54556: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54560: LD_INT 104
54562: PPUSH
54563: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54567: LD_INT 105
54569: PPUSH
54570: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54574: LD_INT 106
54576: PPUSH
54577: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54581: LD_INT 107
54583: PPUSH
54584: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54588: LD_INT 108
54590: PPUSH
54591: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54595: LD_INT 109
54597: PPUSH
54598: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54602: LD_INT 110
54604: PPUSH
54605: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54609: LD_INT 111
54611: PPUSH
54612: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54616: LD_INT 112
54618: PPUSH
54619: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54623: LD_INT 113
54625: PPUSH
54626: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54630: LD_INT 120
54632: PPUSH
54633: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54637: LD_INT 121
54639: PPUSH
54640: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54644: LD_INT 122
54646: PPUSH
54647: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54651: LD_INT 123
54653: PPUSH
54654: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54658: LD_INT 124
54660: PPUSH
54661: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54665: LD_INT 125
54667: PPUSH
54668: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54672: LD_INT 126
54674: PPUSH
54675: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54679: LD_INT 200
54681: PPUSH
54682: CALL_OW 427
// end ;
54686: END
// on SailEvent ( event ) do begin if event < 100 then
54687: LD_VAR 0 1
54691: PUSH
54692: LD_INT 100
54694: LESS
54695: IFFALSE 54706
// CustomEvent ( event ) ;
54697: LD_VAR 0 1
54701: PPUSH
54702: CALL 10241 0 1
// if event = 100 then
54706: LD_VAR 0 1
54710: PUSH
54711: LD_INT 100
54713: EQUAL
54714: IFFALSE 54720
// MC_ClassManager ( ) ;
54716: CALL 55112 0 0
// if event = 101 then
54720: LD_VAR 0 1
54724: PUSH
54725: LD_INT 101
54727: EQUAL
54728: IFFALSE 54734
// MC_RepairBuildings ( ) ;
54730: CALL 59930 0 0
// if event = 102 then
54734: LD_VAR 0 1
54738: PUSH
54739: LD_INT 102
54741: EQUAL
54742: IFFALSE 54748
// MC_Heal ( ) ;
54744: CALL 60837 0 0
// if event = 103 then
54748: LD_VAR 0 1
54752: PUSH
54753: LD_INT 103
54755: EQUAL
54756: IFFALSE 54762
// MC_Build ( ) ;
54758: CALL 61259 0 0
// if event = 104 then
54762: LD_VAR 0 1
54766: PUSH
54767: LD_INT 104
54769: EQUAL
54770: IFFALSE 54776
// MC_TurretWeapon ( ) ;
54772: CALL 62900 0 0
// if event = 105 then
54776: LD_VAR 0 1
54780: PUSH
54781: LD_INT 105
54783: EQUAL
54784: IFFALSE 54790
// MC_BuildUpgrade ( ) ;
54786: CALL 62451 0 0
// if event = 106 then
54790: LD_VAR 0 1
54794: PUSH
54795: LD_INT 106
54797: EQUAL
54798: IFFALSE 54804
// MC_PlantMines ( ) ;
54800: CALL 63330 0 0
// if event = 107 then
54804: LD_VAR 0 1
54808: PUSH
54809: LD_INT 107
54811: EQUAL
54812: IFFALSE 54818
// MC_CollectCrates ( ) ;
54814: CALL 64121 0 0
// if event = 108 then
54818: LD_VAR 0 1
54822: PUSH
54823: LD_INT 108
54825: EQUAL
54826: IFFALSE 54832
// MC_LinkRemoteControl ( ) ;
54828: CALL 65971 0 0
// if event = 109 then
54832: LD_VAR 0 1
54836: PUSH
54837: LD_INT 109
54839: EQUAL
54840: IFFALSE 54846
// MC_ProduceVehicle ( ) ;
54842: CALL 66152 0 0
// if event = 110 then
54846: LD_VAR 0 1
54850: PUSH
54851: LD_INT 110
54853: EQUAL
54854: IFFALSE 54860
// MC_SendAttack ( ) ;
54856: CALL 66618 0 0
// if event = 111 then
54860: LD_VAR 0 1
54864: PUSH
54865: LD_INT 111
54867: EQUAL
54868: IFFALSE 54874
// MC_Defend ( ) ;
54870: CALL 66726 0 0
// if event = 112 then
54874: LD_VAR 0 1
54878: PUSH
54879: LD_INT 112
54881: EQUAL
54882: IFFALSE 54888
// MC_Research ( ) ;
54884: CALL 67606 0 0
// if event = 113 then
54888: LD_VAR 0 1
54892: PUSH
54893: LD_INT 113
54895: EQUAL
54896: IFFALSE 54902
// MC_MinesTrigger ( ) ;
54898: CALL 68720 0 0
// if event = 120 then
54902: LD_VAR 0 1
54906: PUSH
54907: LD_INT 120
54909: EQUAL
54910: IFFALSE 54916
// MC_RepairVehicle ( ) ;
54912: CALL 68819 0 0
// if event = 121 then
54916: LD_VAR 0 1
54920: PUSH
54921: LD_INT 121
54923: EQUAL
54924: IFFALSE 54930
// MC_TameApe ( ) ;
54926: CALL 69560 0 0
// if event = 122 then
54930: LD_VAR 0 1
54934: PUSH
54935: LD_INT 122
54937: EQUAL
54938: IFFALSE 54944
// MC_ChangeApeClass ( ) ;
54940: CALL 70389 0 0
// if event = 123 then
54944: LD_VAR 0 1
54948: PUSH
54949: LD_INT 123
54951: EQUAL
54952: IFFALSE 54958
// MC_Bazooka ( ) ;
54954: CALL 71039 0 0
// if event = 124 then
54958: LD_VAR 0 1
54962: PUSH
54963: LD_INT 124
54965: EQUAL
54966: IFFALSE 54972
// MC_TeleportExit ( ) ;
54968: CALL 71237 0 0
// if event = 125 then
54972: LD_VAR 0 1
54976: PUSH
54977: LD_INT 125
54979: EQUAL
54980: IFFALSE 54986
// MC_Deposits ( ) ;
54982: CALL 71884 0 0
// if event = 126 then
54986: LD_VAR 0 1
54990: PUSH
54991: LD_INT 126
54993: EQUAL
54994: IFFALSE 55000
// MC_RemoteDriver ( ) ;
54996: CALL 72509 0 0
// if event = 200 then
55000: LD_VAR 0 1
55004: PUSH
55005: LD_INT 200
55007: EQUAL
55008: IFFALSE 55014
// MC_Idle ( ) ;
55010: CALL 74458 0 0
// end ;
55014: PPOPN 1
55016: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55017: LD_INT 0
55019: PPUSH
55020: PPUSH
// if not mc_bases [ base ] or not tag then
55021: LD_EXP 23
55025: PUSH
55026: LD_VAR 0 1
55030: ARRAY
55031: NOT
55032: PUSH
55033: LD_VAR 0 2
55037: NOT
55038: OR
55039: IFFALSE 55043
// exit ;
55041: GO 55107
// for i in mc_bases [ base ] union mc_ape [ base ] do
55043: LD_ADDR_VAR 0 4
55047: PUSH
55048: LD_EXP 23
55052: PUSH
55053: LD_VAR 0 1
55057: ARRAY
55058: PUSH
55059: LD_EXP 52
55063: PUSH
55064: LD_VAR 0 1
55068: ARRAY
55069: UNION
55070: PUSH
55071: FOR_IN
55072: IFFALSE 55105
// if GetTag ( i ) = tag then
55074: LD_VAR 0 4
55078: PPUSH
55079: CALL_OW 110
55083: PUSH
55084: LD_VAR 0 2
55088: EQUAL
55089: IFFALSE 55103
// SetTag ( i , 0 ) ;
55091: LD_VAR 0 4
55095: PPUSH
55096: LD_INT 0
55098: PPUSH
55099: CALL_OW 109
55103: GO 55071
55105: POP
55106: POP
// end ;
55107: LD_VAR 0 3
55111: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55112: LD_INT 0
55114: PPUSH
55115: PPUSH
55116: PPUSH
55117: PPUSH
55118: PPUSH
55119: PPUSH
55120: PPUSH
55121: PPUSH
// if not mc_bases then
55122: LD_EXP 23
55126: NOT
55127: IFFALSE 55131
// exit ;
55129: GO 55589
// for i = 1 to mc_bases do
55131: LD_ADDR_VAR 0 2
55135: PUSH
55136: DOUBLE
55137: LD_INT 1
55139: DEC
55140: ST_TO_ADDR
55141: LD_EXP 23
55145: PUSH
55146: FOR_TO
55147: IFFALSE 55587
// begin tmp := MC_ClassCheckReq ( i ) ;
55149: LD_ADDR_VAR 0 4
55153: PUSH
55154: LD_VAR 0 2
55158: PPUSH
55159: CALL 55594 0 1
55163: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55164: LD_ADDR_EXP 64
55168: PUSH
55169: LD_EXP 64
55173: PPUSH
55174: LD_VAR 0 2
55178: PPUSH
55179: LD_VAR 0 4
55183: PPUSH
55184: CALL_OW 1
55188: ST_TO_ADDR
// if not tmp then
55189: LD_VAR 0 4
55193: NOT
55194: IFFALSE 55198
// continue ;
55196: GO 55146
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55198: LD_ADDR_VAR 0 6
55202: PUSH
55203: LD_EXP 23
55207: PUSH
55208: LD_VAR 0 2
55212: ARRAY
55213: PPUSH
55214: LD_INT 2
55216: PUSH
55217: LD_INT 30
55219: PUSH
55220: LD_INT 4
55222: PUSH
55223: EMPTY
55224: LIST
55225: LIST
55226: PUSH
55227: LD_INT 30
55229: PUSH
55230: LD_INT 5
55232: PUSH
55233: EMPTY
55234: LIST
55235: LIST
55236: PUSH
55237: EMPTY
55238: LIST
55239: LIST
55240: LIST
55241: PPUSH
55242: CALL_OW 72
55246: PUSH
55247: LD_EXP 23
55251: PUSH
55252: LD_VAR 0 2
55256: ARRAY
55257: PPUSH
55258: LD_INT 2
55260: PUSH
55261: LD_INT 30
55263: PUSH
55264: LD_INT 0
55266: PUSH
55267: EMPTY
55268: LIST
55269: LIST
55270: PUSH
55271: LD_INT 30
55273: PUSH
55274: LD_INT 1
55276: PUSH
55277: EMPTY
55278: LIST
55279: LIST
55280: PUSH
55281: EMPTY
55282: LIST
55283: LIST
55284: LIST
55285: PPUSH
55286: CALL_OW 72
55290: PUSH
55291: LD_EXP 23
55295: PUSH
55296: LD_VAR 0 2
55300: ARRAY
55301: PPUSH
55302: LD_INT 30
55304: PUSH
55305: LD_INT 3
55307: PUSH
55308: EMPTY
55309: LIST
55310: LIST
55311: PPUSH
55312: CALL_OW 72
55316: PUSH
55317: LD_EXP 23
55321: PUSH
55322: LD_VAR 0 2
55326: ARRAY
55327: PPUSH
55328: LD_INT 2
55330: PUSH
55331: LD_INT 30
55333: PUSH
55334: LD_INT 6
55336: PUSH
55337: EMPTY
55338: LIST
55339: LIST
55340: PUSH
55341: LD_INT 30
55343: PUSH
55344: LD_INT 7
55346: PUSH
55347: EMPTY
55348: LIST
55349: LIST
55350: PUSH
55351: LD_INT 30
55353: PUSH
55354: LD_INT 8
55356: PUSH
55357: EMPTY
55358: LIST
55359: LIST
55360: PUSH
55361: EMPTY
55362: LIST
55363: LIST
55364: LIST
55365: LIST
55366: PPUSH
55367: CALL_OW 72
55371: PUSH
55372: EMPTY
55373: LIST
55374: LIST
55375: LIST
55376: LIST
55377: ST_TO_ADDR
// for j = 1 to 4 do
55378: LD_ADDR_VAR 0 3
55382: PUSH
55383: DOUBLE
55384: LD_INT 1
55386: DEC
55387: ST_TO_ADDR
55388: LD_INT 4
55390: PUSH
55391: FOR_TO
55392: IFFALSE 55583
// begin if not tmp [ j ] then
55394: LD_VAR 0 4
55398: PUSH
55399: LD_VAR 0 3
55403: ARRAY
55404: NOT
55405: IFFALSE 55409
// continue ;
55407: GO 55391
// for p in tmp [ j ] do
55409: LD_ADDR_VAR 0 5
55413: PUSH
55414: LD_VAR 0 4
55418: PUSH
55419: LD_VAR 0 3
55423: ARRAY
55424: PUSH
55425: FOR_IN
55426: IFFALSE 55579
// begin if not b [ j ] then
55428: LD_VAR 0 6
55432: PUSH
55433: LD_VAR 0 3
55437: ARRAY
55438: NOT
55439: IFFALSE 55443
// break ;
55441: GO 55579
// e := 0 ;
55443: LD_ADDR_VAR 0 7
55447: PUSH
55448: LD_INT 0
55450: ST_TO_ADDR
// for k in b [ j ] do
55451: LD_ADDR_VAR 0 8
55455: PUSH
55456: LD_VAR 0 6
55460: PUSH
55461: LD_VAR 0 3
55465: ARRAY
55466: PUSH
55467: FOR_IN
55468: IFFALSE 55495
// if IsNotFull ( k ) then
55470: LD_VAR 0 8
55474: PPUSH
55475: CALL 13220 0 1
55479: IFFALSE 55493
// begin e := k ;
55481: LD_ADDR_VAR 0 7
55485: PUSH
55486: LD_VAR 0 8
55490: ST_TO_ADDR
// break ;
55491: GO 55495
// end ;
55493: GO 55467
55495: POP
55496: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55497: LD_VAR 0 7
55501: PUSH
55502: LD_VAR 0 5
55506: PPUSH
55507: LD_VAR 0 7
55511: PPUSH
55512: CALL 46384 0 2
55516: NOT
55517: AND
55518: IFFALSE 55577
// begin if IsInUnit ( p ) then
55520: LD_VAR 0 5
55524: PPUSH
55525: CALL_OW 310
55529: IFFALSE 55540
// ComExitBuilding ( p ) ;
55531: LD_VAR 0 5
55535: PPUSH
55536: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55540: LD_VAR 0 5
55544: PPUSH
55545: LD_VAR 0 7
55549: PPUSH
55550: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55554: LD_VAR 0 5
55558: PPUSH
55559: LD_VAR 0 3
55563: PPUSH
55564: CALL_OW 183
// AddComExitBuilding ( p ) ;
55568: LD_VAR 0 5
55572: PPUSH
55573: CALL_OW 182
// end ; end ;
55577: GO 55425
55579: POP
55580: POP
// end ;
55581: GO 55391
55583: POP
55584: POP
// end ;
55585: GO 55146
55587: POP
55588: POP
// end ;
55589: LD_VAR 0 1
55593: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55594: LD_INT 0
55596: PPUSH
55597: PPUSH
55598: PPUSH
55599: PPUSH
55600: PPUSH
55601: PPUSH
55602: PPUSH
55603: PPUSH
55604: PPUSH
55605: PPUSH
55606: PPUSH
55607: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55608: LD_VAR 0 1
55612: NOT
55613: PUSH
55614: LD_EXP 23
55618: PUSH
55619: LD_VAR 0 1
55623: ARRAY
55624: NOT
55625: OR
55626: PUSH
55627: LD_EXP 23
55631: PUSH
55632: LD_VAR 0 1
55636: ARRAY
55637: PPUSH
55638: LD_INT 2
55640: PUSH
55641: LD_INT 30
55643: PUSH
55644: LD_INT 0
55646: PUSH
55647: EMPTY
55648: LIST
55649: LIST
55650: PUSH
55651: LD_INT 30
55653: PUSH
55654: LD_INT 1
55656: PUSH
55657: EMPTY
55658: LIST
55659: LIST
55660: PUSH
55661: EMPTY
55662: LIST
55663: LIST
55664: LIST
55665: PPUSH
55666: CALL_OW 72
55670: NOT
55671: OR
55672: IFFALSE 55676
// exit ;
55674: GO 59179
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55676: LD_ADDR_VAR 0 4
55680: PUSH
55681: LD_EXP 23
55685: PUSH
55686: LD_VAR 0 1
55690: ARRAY
55691: PPUSH
55692: LD_INT 2
55694: PUSH
55695: LD_INT 25
55697: PUSH
55698: LD_INT 1
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: PUSH
55705: LD_INT 25
55707: PUSH
55708: LD_INT 2
55710: PUSH
55711: EMPTY
55712: LIST
55713: LIST
55714: PUSH
55715: LD_INT 25
55717: PUSH
55718: LD_INT 3
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: PUSH
55725: LD_INT 25
55727: PUSH
55728: LD_INT 4
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: PUSH
55735: LD_INT 25
55737: PUSH
55738: LD_INT 5
55740: PUSH
55741: EMPTY
55742: LIST
55743: LIST
55744: PUSH
55745: LD_INT 25
55747: PUSH
55748: LD_INT 8
55750: PUSH
55751: EMPTY
55752: LIST
55753: LIST
55754: PUSH
55755: LD_INT 25
55757: PUSH
55758: LD_INT 9
55760: PUSH
55761: EMPTY
55762: LIST
55763: LIST
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: LIST
55770: LIST
55771: LIST
55772: LIST
55773: LIST
55774: PPUSH
55775: CALL_OW 72
55779: ST_TO_ADDR
// if not tmp then
55780: LD_VAR 0 4
55784: NOT
55785: IFFALSE 55789
// exit ;
55787: GO 59179
// for i in tmp do
55789: LD_ADDR_VAR 0 3
55793: PUSH
55794: LD_VAR 0 4
55798: PUSH
55799: FOR_IN
55800: IFFALSE 55831
// if GetTag ( i ) then
55802: LD_VAR 0 3
55806: PPUSH
55807: CALL_OW 110
55811: IFFALSE 55829
// tmp := tmp diff i ;
55813: LD_ADDR_VAR 0 4
55817: PUSH
55818: LD_VAR 0 4
55822: PUSH
55823: LD_VAR 0 3
55827: DIFF
55828: ST_TO_ADDR
55829: GO 55799
55831: POP
55832: POP
// if not tmp then
55833: LD_VAR 0 4
55837: NOT
55838: IFFALSE 55842
// exit ;
55840: GO 59179
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55842: LD_ADDR_VAR 0 5
55846: PUSH
55847: LD_EXP 23
55851: PUSH
55852: LD_VAR 0 1
55856: ARRAY
55857: PPUSH
55858: LD_INT 2
55860: PUSH
55861: LD_INT 25
55863: PUSH
55864: LD_INT 1
55866: PUSH
55867: EMPTY
55868: LIST
55869: LIST
55870: PUSH
55871: LD_INT 25
55873: PUSH
55874: LD_INT 5
55876: PUSH
55877: EMPTY
55878: LIST
55879: LIST
55880: PUSH
55881: LD_INT 25
55883: PUSH
55884: LD_INT 8
55886: PUSH
55887: EMPTY
55888: LIST
55889: LIST
55890: PUSH
55891: LD_INT 25
55893: PUSH
55894: LD_INT 9
55896: PUSH
55897: EMPTY
55898: LIST
55899: LIST
55900: PUSH
55901: EMPTY
55902: LIST
55903: LIST
55904: LIST
55905: LIST
55906: LIST
55907: PPUSH
55908: CALL_OW 72
55912: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55913: LD_ADDR_VAR 0 6
55917: PUSH
55918: LD_EXP 23
55922: PUSH
55923: LD_VAR 0 1
55927: ARRAY
55928: PPUSH
55929: LD_INT 25
55931: PUSH
55932: LD_INT 2
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: PPUSH
55939: CALL_OW 72
55943: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55944: LD_ADDR_VAR 0 7
55948: PUSH
55949: LD_EXP 23
55953: PUSH
55954: LD_VAR 0 1
55958: ARRAY
55959: PPUSH
55960: LD_INT 25
55962: PUSH
55963: LD_INT 3
55965: PUSH
55966: EMPTY
55967: LIST
55968: LIST
55969: PPUSH
55970: CALL_OW 72
55974: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55975: LD_ADDR_VAR 0 8
55979: PUSH
55980: LD_EXP 23
55984: PUSH
55985: LD_VAR 0 1
55989: ARRAY
55990: PPUSH
55991: LD_INT 25
55993: PUSH
55994: LD_INT 4
55996: PUSH
55997: EMPTY
55998: LIST
55999: LIST
56000: PUSH
56001: LD_INT 24
56003: PUSH
56004: LD_INT 251
56006: PUSH
56007: EMPTY
56008: LIST
56009: LIST
56010: PUSH
56011: EMPTY
56012: LIST
56013: LIST
56014: PPUSH
56015: CALL_OW 72
56019: ST_TO_ADDR
// if mc_is_defending [ base ] then
56020: LD_EXP 66
56024: PUSH
56025: LD_VAR 0 1
56029: ARRAY
56030: IFFALSE 56491
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56032: LD_ADDR_EXP 65
56036: PUSH
56037: LD_EXP 65
56041: PPUSH
56042: LD_VAR 0 1
56046: PPUSH
56047: LD_INT 4
56049: PPUSH
56050: CALL_OW 1
56054: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56055: LD_ADDR_VAR 0 12
56059: PUSH
56060: LD_EXP 23
56064: PUSH
56065: LD_VAR 0 1
56069: ARRAY
56070: PPUSH
56071: LD_INT 2
56073: PUSH
56074: LD_INT 30
56076: PUSH
56077: LD_INT 4
56079: PUSH
56080: EMPTY
56081: LIST
56082: LIST
56083: PUSH
56084: LD_INT 30
56086: PUSH
56087: LD_INT 5
56089: PUSH
56090: EMPTY
56091: LIST
56092: LIST
56093: PUSH
56094: EMPTY
56095: LIST
56096: LIST
56097: LIST
56098: PPUSH
56099: CALL_OW 72
56103: ST_TO_ADDR
// if not b then
56104: LD_VAR 0 12
56108: NOT
56109: IFFALSE 56113
// exit ;
56111: GO 59179
// p := [ ] ;
56113: LD_ADDR_VAR 0 11
56117: PUSH
56118: EMPTY
56119: ST_TO_ADDR
// if sci >= 2 then
56120: LD_VAR 0 8
56124: PUSH
56125: LD_INT 2
56127: GREATEREQUAL
56128: IFFALSE 56159
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56130: LD_ADDR_VAR 0 8
56134: PUSH
56135: LD_VAR 0 8
56139: PUSH
56140: LD_INT 1
56142: ARRAY
56143: PUSH
56144: LD_VAR 0 8
56148: PUSH
56149: LD_INT 2
56151: ARRAY
56152: PUSH
56153: EMPTY
56154: LIST
56155: LIST
56156: ST_TO_ADDR
56157: GO 56220
// if sci = 1 then
56159: LD_VAR 0 8
56163: PUSH
56164: LD_INT 1
56166: EQUAL
56167: IFFALSE 56188
// sci := [ sci [ 1 ] ] else
56169: LD_ADDR_VAR 0 8
56173: PUSH
56174: LD_VAR 0 8
56178: PUSH
56179: LD_INT 1
56181: ARRAY
56182: PUSH
56183: EMPTY
56184: LIST
56185: ST_TO_ADDR
56186: GO 56220
// if sci = 0 then
56188: LD_VAR 0 8
56192: PUSH
56193: LD_INT 0
56195: EQUAL
56196: IFFALSE 56220
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56198: LD_ADDR_VAR 0 11
56202: PUSH
56203: LD_VAR 0 4
56207: PPUSH
56208: LD_INT 4
56210: PPUSH
56211: CALL 46247 0 2
56215: PUSH
56216: LD_INT 1
56218: ARRAY
56219: ST_TO_ADDR
// if eng > 4 then
56220: LD_VAR 0 6
56224: PUSH
56225: LD_INT 4
56227: GREATER
56228: IFFALSE 56274
// for i = eng downto 4 do
56230: LD_ADDR_VAR 0 3
56234: PUSH
56235: DOUBLE
56236: LD_VAR 0 6
56240: INC
56241: ST_TO_ADDR
56242: LD_INT 4
56244: PUSH
56245: FOR_DOWNTO
56246: IFFALSE 56272
// eng := eng diff eng [ i ] ;
56248: LD_ADDR_VAR 0 6
56252: PUSH
56253: LD_VAR 0 6
56257: PUSH
56258: LD_VAR 0 6
56262: PUSH
56263: LD_VAR 0 3
56267: ARRAY
56268: DIFF
56269: ST_TO_ADDR
56270: GO 56245
56272: POP
56273: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56274: LD_ADDR_VAR 0 4
56278: PUSH
56279: LD_VAR 0 4
56283: PUSH
56284: LD_VAR 0 5
56288: PUSH
56289: LD_VAR 0 6
56293: UNION
56294: PUSH
56295: LD_VAR 0 7
56299: UNION
56300: PUSH
56301: LD_VAR 0 8
56305: UNION
56306: DIFF
56307: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56308: LD_ADDR_VAR 0 13
56312: PUSH
56313: LD_EXP 23
56317: PUSH
56318: LD_VAR 0 1
56322: ARRAY
56323: PPUSH
56324: LD_INT 2
56326: PUSH
56327: LD_INT 30
56329: PUSH
56330: LD_INT 32
56332: PUSH
56333: EMPTY
56334: LIST
56335: LIST
56336: PUSH
56337: LD_INT 30
56339: PUSH
56340: LD_INT 31
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: PUSH
56347: EMPTY
56348: LIST
56349: LIST
56350: LIST
56351: PPUSH
56352: CALL_OW 72
56356: PUSH
56357: LD_EXP 23
56361: PUSH
56362: LD_VAR 0 1
56366: ARRAY
56367: PPUSH
56368: LD_INT 2
56370: PUSH
56371: LD_INT 30
56373: PUSH
56374: LD_INT 4
56376: PUSH
56377: EMPTY
56378: LIST
56379: LIST
56380: PUSH
56381: LD_INT 30
56383: PUSH
56384: LD_INT 5
56386: PUSH
56387: EMPTY
56388: LIST
56389: LIST
56390: PUSH
56391: EMPTY
56392: LIST
56393: LIST
56394: LIST
56395: PPUSH
56396: CALL_OW 72
56400: PUSH
56401: LD_INT 6
56403: MUL
56404: PLUS
56405: ST_TO_ADDR
// if bcount < tmp then
56406: LD_VAR 0 13
56410: PUSH
56411: LD_VAR 0 4
56415: LESS
56416: IFFALSE 56462
// for i = tmp downto bcount do
56418: LD_ADDR_VAR 0 3
56422: PUSH
56423: DOUBLE
56424: LD_VAR 0 4
56428: INC
56429: ST_TO_ADDR
56430: LD_VAR 0 13
56434: PUSH
56435: FOR_DOWNTO
56436: IFFALSE 56460
// tmp := Delete ( tmp , tmp ) ;
56438: LD_ADDR_VAR 0 4
56442: PUSH
56443: LD_VAR 0 4
56447: PPUSH
56448: LD_VAR 0 4
56452: PPUSH
56453: CALL_OW 3
56457: ST_TO_ADDR
56458: GO 56435
56460: POP
56461: POP
// result := [ tmp , 0 , 0 , p ] ;
56462: LD_ADDR_VAR 0 2
56466: PUSH
56467: LD_VAR 0 4
56471: PUSH
56472: LD_INT 0
56474: PUSH
56475: LD_INT 0
56477: PUSH
56478: LD_VAR 0 11
56482: PUSH
56483: EMPTY
56484: LIST
56485: LIST
56486: LIST
56487: LIST
56488: ST_TO_ADDR
// exit ;
56489: GO 59179
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56491: LD_EXP 23
56495: PUSH
56496: LD_VAR 0 1
56500: ARRAY
56501: PPUSH
56502: LD_INT 2
56504: PUSH
56505: LD_INT 30
56507: PUSH
56508: LD_INT 6
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: PUSH
56515: LD_INT 30
56517: PUSH
56518: LD_INT 7
56520: PUSH
56521: EMPTY
56522: LIST
56523: LIST
56524: PUSH
56525: LD_INT 30
56527: PUSH
56528: LD_INT 8
56530: PUSH
56531: EMPTY
56532: LIST
56533: LIST
56534: PUSH
56535: EMPTY
56536: LIST
56537: LIST
56538: LIST
56539: LIST
56540: PPUSH
56541: CALL_OW 72
56545: NOT
56546: PUSH
56547: LD_EXP 23
56551: PUSH
56552: LD_VAR 0 1
56556: ARRAY
56557: PPUSH
56558: LD_INT 30
56560: PUSH
56561: LD_INT 3
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: PPUSH
56568: CALL_OW 72
56572: NOT
56573: AND
56574: IFFALSE 56646
// begin if eng = tmp then
56576: LD_VAR 0 6
56580: PUSH
56581: LD_VAR 0 4
56585: EQUAL
56586: IFFALSE 56590
// exit ;
56588: GO 59179
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56590: LD_ADDR_EXP 65
56594: PUSH
56595: LD_EXP 65
56599: PPUSH
56600: LD_VAR 0 1
56604: PPUSH
56605: LD_INT 1
56607: PPUSH
56608: CALL_OW 1
56612: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56613: LD_ADDR_VAR 0 2
56617: PUSH
56618: LD_INT 0
56620: PUSH
56621: LD_VAR 0 4
56625: PUSH
56626: LD_VAR 0 6
56630: DIFF
56631: PUSH
56632: LD_INT 0
56634: PUSH
56635: LD_INT 0
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: LIST
56642: LIST
56643: ST_TO_ADDR
// exit ;
56644: GO 59179
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56646: LD_EXP 50
56650: PUSH
56651: LD_EXP 49
56655: PUSH
56656: LD_VAR 0 1
56660: ARRAY
56661: ARRAY
56662: PUSH
56663: LD_EXP 23
56667: PUSH
56668: LD_VAR 0 1
56672: ARRAY
56673: PPUSH
56674: LD_INT 2
56676: PUSH
56677: LD_INT 30
56679: PUSH
56680: LD_INT 6
56682: PUSH
56683: EMPTY
56684: LIST
56685: LIST
56686: PUSH
56687: LD_INT 30
56689: PUSH
56690: LD_INT 7
56692: PUSH
56693: EMPTY
56694: LIST
56695: LIST
56696: PUSH
56697: LD_INT 30
56699: PUSH
56700: LD_INT 8
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: PUSH
56707: EMPTY
56708: LIST
56709: LIST
56710: LIST
56711: LIST
56712: PPUSH
56713: CALL_OW 72
56717: AND
56718: PUSH
56719: LD_EXP 23
56723: PUSH
56724: LD_VAR 0 1
56728: ARRAY
56729: PPUSH
56730: LD_INT 30
56732: PUSH
56733: LD_INT 3
56735: PUSH
56736: EMPTY
56737: LIST
56738: LIST
56739: PPUSH
56740: CALL_OW 72
56744: NOT
56745: AND
56746: IFFALSE 56960
// begin if sci >= 6 then
56748: LD_VAR 0 8
56752: PUSH
56753: LD_INT 6
56755: GREATEREQUAL
56756: IFFALSE 56760
// exit ;
56758: GO 59179
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56760: LD_ADDR_EXP 65
56764: PUSH
56765: LD_EXP 65
56769: PPUSH
56770: LD_VAR 0 1
56774: PPUSH
56775: LD_INT 2
56777: PPUSH
56778: CALL_OW 1
56782: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56783: LD_ADDR_VAR 0 9
56787: PUSH
56788: LD_VAR 0 4
56792: PUSH
56793: LD_VAR 0 8
56797: DIFF
56798: PPUSH
56799: LD_INT 4
56801: PPUSH
56802: CALL 46247 0 2
56806: ST_TO_ADDR
// p := [ ] ;
56807: LD_ADDR_VAR 0 11
56811: PUSH
56812: EMPTY
56813: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56814: LD_VAR 0 8
56818: PUSH
56819: LD_INT 6
56821: LESS
56822: PUSH
56823: LD_VAR 0 9
56827: PUSH
56828: LD_INT 6
56830: GREATER
56831: AND
56832: IFFALSE 56913
// begin for i = 1 to 6 - sci do
56834: LD_ADDR_VAR 0 3
56838: PUSH
56839: DOUBLE
56840: LD_INT 1
56842: DEC
56843: ST_TO_ADDR
56844: LD_INT 6
56846: PUSH
56847: LD_VAR 0 8
56851: MINUS
56852: PUSH
56853: FOR_TO
56854: IFFALSE 56909
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
56856: LD_ADDR_VAR 0 11
56860: PUSH
56861: LD_VAR 0 11
56865: PPUSH
56866: LD_VAR 0 11
56870: PUSH
56871: LD_INT 1
56873: PLUS
56874: PPUSH
56875: LD_VAR 0 9
56879: PUSH
56880: LD_INT 1
56882: ARRAY
56883: PPUSH
56884: CALL_OW 2
56888: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56889: LD_ADDR_VAR 0 9
56893: PUSH
56894: LD_VAR 0 9
56898: PPUSH
56899: LD_INT 1
56901: PPUSH
56902: CALL_OW 3
56906: ST_TO_ADDR
// end ;
56907: GO 56853
56909: POP
56910: POP
// end else
56911: GO 56933
// if sort then
56913: LD_VAR 0 9
56917: IFFALSE 56933
// p := sort [ 1 ] ;
56919: LD_ADDR_VAR 0 11
56923: PUSH
56924: LD_VAR 0 9
56928: PUSH
56929: LD_INT 1
56931: ARRAY
56932: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56933: LD_ADDR_VAR 0 2
56937: PUSH
56938: LD_INT 0
56940: PUSH
56941: LD_INT 0
56943: PUSH
56944: LD_INT 0
56946: PUSH
56947: LD_VAR 0 11
56951: PUSH
56952: EMPTY
56953: LIST
56954: LIST
56955: LIST
56956: LIST
56957: ST_TO_ADDR
// exit ;
56958: GO 59179
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56960: LD_EXP 50
56964: PUSH
56965: LD_EXP 49
56969: PUSH
56970: LD_VAR 0 1
56974: ARRAY
56975: ARRAY
56976: PUSH
56977: LD_EXP 23
56981: PUSH
56982: LD_VAR 0 1
56986: ARRAY
56987: PPUSH
56988: LD_INT 2
56990: PUSH
56991: LD_INT 30
56993: PUSH
56994: LD_INT 6
56996: PUSH
56997: EMPTY
56998: LIST
56999: LIST
57000: PUSH
57001: LD_INT 30
57003: PUSH
57004: LD_INT 7
57006: PUSH
57007: EMPTY
57008: LIST
57009: LIST
57010: PUSH
57011: LD_INT 30
57013: PUSH
57014: LD_INT 8
57016: PUSH
57017: EMPTY
57018: LIST
57019: LIST
57020: PUSH
57021: EMPTY
57022: LIST
57023: LIST
57024: LIST
57025: LIST
57026: PPUSH
57027: CALL_OW 72
57031: AND
57032: PUSH
57033: LD_EXP 23
57037: PUSH
57038: LD_VAR 0 1
57042: ARRAY
57043: PPUSH
57044: LD_INT 30
57046: PUSH
57047: LD_INT 3
57049: PUSH
57050: EMPTY
57051: LIST
57052: LIST
57053: PPUSH
57054: CALL_OW 72
57058: AND
57059: IFFALSE 57793
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57061: LD_ADDR_EXP 65
57065: PUSH
57066: LD_EXP 65
57070: PPUSH
57071: LD_VAR 0 1
57075: PPUSH
57076: LD_INT 3
57078: PPUSH
57079: CALL_OW 1
57083: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57084: LD_ADDR_VAR 0 2
57088: PUSH
57089: LD_INT 0
57091: PUSH
57092: LD_INT 0
57094: PUSH
57095: LD_INT 0
57097: PUSH
57098: LD_INT 0
57100: PUSH
57101: EMPTY
57102: LIST
57103: LIST
57104: LIST
57105: LIST
57106: ST_TO_ADDR
// if not eng then
57107: LD_VAR 0 6
57111: NOT
57112: IFFALSE 57175
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57114: LD_ADDR_VAR 0 11
57118: PUSH
57119: LD_VAR 0 4
57123: PPUSH
57124: LD_INT 2
57126: PPUSH
57127: CALL 46247 0 2
57131: PUSH
57132: LD_INT 1
57134: ARRAY
57135: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57136: LD_ADDR_VAR 0 2
57140: PUSH
57141: LD_VAR 0 2
57145: PPUSH
57146: LD_INT 2
57148: PPUSH
57149: LD_VAR 0 11
57153: PPUSH
57154: CALL_OW 1
57158: ST_TO_ADDR
// tmp := tmp diff p ;
57159: LD_ADDR_VAR 0 4
57163: PUSH
57164: LD_VAR 0 4
57168: PUSH
57169: LD_VAR 0 11
57173: DIFF
57174: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57175: LD_VAR 0 4
57179: PUSH
57180: LD_VAR 0 8
57184: PUSH
57185: LD_INT 6
57187: LESS
57188: AND
57189: IFFALSE 57377
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57191: LD_ADDR_VAR 0 9
57195: PUSH
57196: LD_VAR 0 4
57200: PUSH
57201: LD_VAR 0 8
57205: PUSH
57206: LD_VAR 0 7
57210: UNION
57211: DIFF
57212: PPUSH
57213: LD_INT 4
57215: PPUSH
57216: CALL 46247 0 2
57220: ST_TO_ADDR
// p := [ ] ;
57221: LD_ADDR_VAR 0 11
57225: PUSH
57226: EMPTY
57227: ST_TO_ADDR
// if sort then
57228: LD_VAR 0 9
57232: IFFALSE 57348
// for i = 1 to 6 - sci do
57234: LD_ADDR_VAR 0 3
57238: PUSH
57239: DOUBLE
57240: LD_INT 1
57242: DEC
57243: ST_TO_ADDR
57244: LD_INT 6
57246: PUSH
57247: LD_VAR 0 8
57251: MINUS
57252: PUSH
57253: FOR_TO
57254: IFFALSE 57346
// begin if i = sort then
57256: LD_VAR 0 3
57260: PUSH
57261: LD_VAR 0 9
57265: EQUAL
57266: IFFALSE 57270
// break ;
57268: GO 57346
// if GetClass ( i ) = 4 then
57270: LD_VAR 0 3
57274: PPUSH
57275: CALL_OW 257
57279: PUSH
57280: LD_INT 4
57282: EQUAL
57283: IFFALSE 57287
// continue ;
57285: GO 57253
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57287: LD_ADDR_VAR 0 11
57291: PUSH
57292: LD_VAR 0 11
57296: PPUSH
57297: LD_VAR 0 11
57301: PUSH
57302: LD_INT 1
57304: PLUS
57305: PPUSH
57306: LD_VAR 0 9
57310: PUSH
57311: LD_VAR 0 3
57315: ARRAY
57316: PPUSH
57317: CALL_OW 2
57321: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57322: LD_ADDR_VAR 0 4
57326: PUSH
57327: LD_VAR 0 4
57331: PUSH
57332: LD_VAR 0 9
57336: PUSH
57337: LD_VAR 0 3
57341: ARRAY
57342: DIFF
57343: ST_TO_ADDR
// end ;
57344: GO 57253
57346: POP
57347: POP
// if p then
57348: LD_VAR 0 11
57352: IFFALSE 57377
// result := Replace ( result , 4 , p ) ;
57354: LD_ADDR_VAR 0 2
57358: PUSH
57359: LD_VAR 0 2
57363: PPUSH
57364: LD_INT 4
57366: PPUSH
57367: LD_VAR 0 11
57371: PPUSH
57372: CALL_OW 1
57376: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57377: LD_VAR 0 4
57381: PUSH
57382: LD_VAR 0 7
57386: PUSH
57387: LD_INT 6
57389: LESS
57390: AND
57391: IFFALSE 57579
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57393: LD_ADDR_VAR 0 9
57397: PUSH
57398: LD_VAR 0 4
57402: PUSH
57403: LD_VAR 0 8
57407: PUSH
57408: LD_VAR 0 7
57412: UNION
57413: DIFF
57414: PPUSH
57415: LD_INT 3
57417: PPUSH
57418: CALL 46247 0 2
57422: ST_TO_ADDR
// p := [ ] ;
57423: LD_ADDR_VAR 0 11
57427: PUSH
57428: EMPTY
57429: ST_TO_ADDR
// if sort then
57430: LD_VAR 0 9
57434: IFFALSE 57550
// for i = 1 to 6 - mech do
57436: LD_ADDR_VAR 0 3
57440: PUSH
57441: DOUBLE
57442: LD_INT 1
57444: DEC
57445: ST_TO_ADDR
57446: LD_INT 6
57448: PUSH
57449: LD_VAR 0 7
57453: MINUS
57454: PUSH
57455: FOR_TO
57456: IFFALSE 57548
// begin if i = sort then
57458: LD_VAR 0 3
57462: PUSH
57463: LD_VAR 0 9
57467: EQUAL
57468: IFFALSE 57472
// break ;
57470: GO 57548
// if GetClass ( i ) = 3 then
57472: LD_VAR 0 3
57476: PPUSH
57477: CALL_OW 257
57481: PUSH
57482: LD_INT 3
57484: EQUAL
57485: IFFALSE 57489
// continue ;
57487: GO 57455
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57489: LD_ADDR_VAR 0 11
57493: PUSH
57494: LD_VAR 0 11
57498: PPUSH
57499: LD_VAR 0 11
57503: PUSH
57504: LD_INT 1
57506: PLUS
57507: PPUSH
57508: LD_VAR 0 9
57512: PUSH
57513: LD_VAR 0 3
57517: ARRAY
57518: PPUSH
57519: CALL_OW 2
57523: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57524: LD_ADDR_VAR 0 4
57528: PUSH
57529: LD_VAR 0 4
57533: PUSH
57534: LD_VAR 0 9
57538: PUSH
57539: LD_VAR 0 3
57543: ARRAY
57544: DIFF
57545: ST_TO_ADDR
// end ;
57546: GO 57455
57548: POP
57549: POP
// if p then
57550: LD_VAR 0 11
57554: IFFALSE 57579
// result := Replace ( result , 3 , p ) ;
57556: LD_ADDR_VAR 0 2
57560: PUSH
57561: LD_VAR 0 2
57565: PPUSH
57566: LD_INT 3
57568: PPUSH
57569: LD_VAR 0 11
57573: PPUSH
57574: CALL_OW 1
57578: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57579: LD_VAR 0 4
57583: PUSH
57584: LD_INT 6
57586: GREATER
57587: PUSH
57588: LD_VAR 0 6
57592: PUSH
57593: LD_INT 6
57595: LESS
57596: AND
57597: IFFALSE 57791
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57599: LD_ADDR_VAR 0 9
57603: PUSH
57604: LD_VAR 0 4
57608: PUSH
57609: LD_VAR 0 8
57613: PUSH
57614: LD_VAR 0 7
57618: UNION
57619: PUSH
57620: LD_VAR 0 6
57624: UNION
57625: DIFF
57626: PPUSH
57627: LD_INT 2
57629: PPUSH
57630: CALL 46247 0 2
57634: ST_TO_ADDR
// p := [ ] ;
57635: LD_ADDR_VAR 0 11
57639: PUSH
57640: EMPTY
57641: ST_TO_ADDR
// if sort then
57642: LD_VAR 0 9
57646: IFFALSE 57762
// for i = 1 to 6 - eng do
57648: LD_ADDR_VAR 0 3
57652: PUSH
57653: DOUBLE
57654: LD_INT 1
57656: DEC
57657: ST_TO_ADDR
57658: LD_INT 6
57660: PUSH
57661: LD_VAR 0 6
57665: MINUS
57666: PUSH
57667: FOR_TO
57668: IFFALSE 57760
// begin if i = sort then
57670: LD_VAR 0 3
57674: PUSH
57675: LD_VAR 0 9
57679: EQUAL
57680: IFFALSE 57684
// break ;
57682: GO 57760
// if GetClass ( i ) = 2 then
57684: LD_VAR 0 3
57688: PPUSH
57689: CALL_OW 257
57693: PUSH
57694: LD_INT 2
57696: EQUAL
57697: IFFALSE 57701
// continue ;
57699: GO 57667
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57701: LD_ADDR_VAR 0 11
57705: PUSH
57706: LD_VAR 0 11
57710: PPUSH
57711: LD_VAR 0 11
57715: PUSH
57716: LD_INT 1
57718: PLUS
57719: PPUSH
57720: LD_VAR 0 9
57724: PUSH
57725: LD_VAR 0 3
57729: ARRAY
57730: PPUSH
57731: CALL_OW 2
57735: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57736: LD_ADDR_VAR 0 4
57740: PUSH
57741: LD_VAR 0 4
57745: PUSH
57746: LD_VAR 0 9
57750: PUSH
57751: LD_VAR 0 3
57755: ARRAY
57756: DIFF
57757: ST_TO_ADDR
// end ;
57758: GO 57667
57760: POP
57761: POP
// if p then
57762: LD_VAR 0 11
57766: IFFALSE 57791
// result := Replace ( result , 2 , p ) ;
57768: LD_ADDR_VAR 0 2
57772: PUSH
57773: LD_VAR 0 2
57777: PPUSH
57778: LD_INT 2
57780: PPUSH
57781: LD_VAR 0 11
57785: PPUSH
57786: CALL_OW 1
57790: ST_TO_ADDR
// end ; exit ;
57791: GO 59179
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57793: LD_EXP 50
57797: PUSH
57798: LD_EXP 49
57802: PUSH
57803: LD_VAR 0 1
57807: ARRAY
57808: ARRAY
57809: NOT
57810: PUSH
57811: LD_EXP 23
57815: PUSH
57816: LD_VAR 0 1
57820: ARRAY
57821: PPUSH
57822: LD_INT 30
57824: PUSH
57825: LD_INT 3
57827: PUSH
57828: EMPTY
57829: LIST
57830: LIST
57831: PPUSH
57832: CALL_OW 72
57836: AND
57837: PUSH
57838: LD_EXP 28
57842: PUSH
57843: LD_VAR 0 1
57847: ARRAY
57848: AND
57849: IFFALSE 58457
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
57851: LD_ADDR_EXP 65
57855: PUSH
57856: LD_EXP 65
57860: PPUSH
57861: LD_VAR 0 1
57865: PPUSH
57866: LD_INT 5
57868: PPUSH
57869: CALL_OW 1
57873: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57874: LD_ADDR_VAR 0 2
57878: PUSH
57879: LD_INT 0
57881: PUSH
57882: LD_INT 0
57884: PUSH
57885: LD_INT 0
57887: PUSH
57888: LD_INT 0
57890: PUSH
57891: EMPTY
57892: LIST
57893: LIST
57894: LIST
57895: LIST
57896: ST_TO_ADDR
// if sci > 1 then
57897: LD_VAR 0 8
57901: PUSH
57902: LD_INT 1
57904: GREATER
57905: IFFALSE 57933
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57907: LD_ADDR_VAR 0 4
57911: PUSH
57912: LD_VAR 0 4
57916: PUSH
57917: LD_VAR 0 8
57921: PUSH
57922: LD_VAR 0 8
57926: PUSH
57927: LD_INT 1
57929: ARRAY
57930: DIFF
57931: DIFF
57932: ST_TO_ADDR
// if tmp and not sci then
57933: LD_VAR 0 4
57937: PUSH
57938: LD_VAR 0 8
57942: NOT
57943: AND
57944: IFFALSE 58013
// begin sort := SortBySkill ( tmp , 4 ) ;
57946: LD_ADDR_VAR 0 9
57950: PUSH
57951: LD_VAR 0 4
57955: PPUSH
57956: LD_INT 4
57958: PPUSH
57959: CALL 46247 0 2
57963: ST_TO_ADDR
// if sort then
57964: LD_VAR 0 9
57968: IFFALSE 57984
// p := sort [ 1 ] ;
57970: LD_ADDR_VAR 0 11
57974: PUSH
57975: LD_VAR 0 9
57979: PUSH
57980: LD_INT 1
57982: ARRAY
57983: ST_TO_ADDR
// if p then
57984: LD_VAR 0 11
57988: IFFALSE 58013
// result := Replace ( result , 4 , p ) ;
57990: LD_ADDR_VAR 0 2
57994: PUSH
57995: LD_VAR 0 2
57999: PPUSH
58000: LD_INT 4
58002: PPUSH
58003: LD_VAR 0 11
58007: PPUSH
58008: CALL_OW 1
58012: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58013: LD_ADDR_VAR 0 4
58017: PUSH
58018: LD_VAR 0 4
58022: PUSH
58023: LD_VAR 0 7
58027: DIFF
58028: ST_TO_ADDR
// if tmp and mech < 6 then
58029: LD_VAR 0 4
58033: PUSH
58034: LD_VAR 0 7
58038: PUSH
58039: LD_INT 6
58041: LESS
58042: AND
58043: IFFALSE 58231
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58045: LD_ADDR_VAR 0 9
58049: PUSH
58050: LD_VAR 0 4
58054: PUSH
58055: LD_VAR 0 8
58059: PUSH
58060: LD_VAR 0 7
58064: UNION
58065: DIFF
58066: PPUSH
58067: LD_INT 3
58069: PPUSH
58070: CALL 46247 0 2
58074: ST_TO_ADDR
// p := [ ] ;
58075: LD_ADDR_VAR 0 11
58079: PUSH
58080: EMPTY
58081: ST_TO_ADDR
// if sort then
58082: LD_VAR 0 9
58086: IFFALSE 58202
// for i = 1 to 6 - mech do
58088: LD_ADDR_VAR 0 3
58092: PUSH
58093: DOUBLE
58094: LD_INT 1
58096: DEC
58097: ST_TO_ADDR
58098: LD_INT 6
58100: PUSH
58101: LD_VAR 0 7
58105: MINUS
58106: PUSH
58107: FOR_TO
58108: IFFALSE 58200
// begin if i = sort then
58110: LD_VAR 0 3
58114: PUSH
58115: LD_VAR 0 9
58119: EQUAL
58120: IFFALSE 58124
// break ;
58122: GO 58200
// if GetClass ( i ) = 3 then
58124: LD_VAR 0 3
58128: PPUSH
58129: CALL_OW 257
58133: PUSH
58134: LD_INT 3
58136: EQUAL
58137: IFFALSE 58141
// continue ;
58139: GO 58107
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58141: LD_ADDR_VAR 0 11
58145: PUSH
58146: LD_VAR 0 11
58150: PPUSH
58151: LD_VAR 0 11
58155: PUSH
58156: LD_INT 1
58158: PLUS
58159: PPUSH
58160: LD_VAR 0 9
58164: PUSH
58165: LD_VAR 0 3
58169: ARRAY
58170: PPUSH
58171: CALL_OW 2
58175: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58176: LD_ADDR_VAR 0 4
58180: PUSH
58181: LD_VAR 0 4
58185: PUSH
58186: LD_VAR 0 9
58190: PUSH
58191: LD_VAR 0 3
58195: ARRAY
58196: DIFF
58197: ST_TO_ADDR
// end ;
58198: GO 58107
58200: POP
58201: POP
// if p then
58202: LD_VAR 0 11
58206: IFFALSE 58231
// result := Replace ( result , 3 , p ) ;
58208: LD_ADDR_VAR 0 2
58212: PUSH
58213: LD_VAR 0 2
58217: PPUSH
58218: LD_INT 3
58220: PPUSH
58221: LD_VAR 0 11
58225: PPUSH
58226: CALL_OW 1
58230: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58231: LD_ADDR_VAR 0 4
58235: PUSH
58236: LD_VAR 0 4
58240: PUSH
58241: LD_VAR 0 6
58245: DIFF
58246: ST_TO_ADDR
// if tmp and eng < 6 then
58247: LD_VAR 0 4
58251: PUSH
58252: LD_VAR 0 6
58256: PUSH
58257: LD_INT 6
58259: LESS
58260: AND
58261: IFFALSE 58455
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58263: LD_ADDR_VAR 0 9
58267: PUSH
58268: LD_VAR 0 4
58272: PUSH
58273: LD_VAR 0 8
58277: PUSH
58278: LD_VAR 0 7
58282: UNION
58283: PUSH
58284: LD_VAR 0 6
58288: UNION
58289: DIFF
58290: PPUSH
58291: LD_INT 2
58293: PPUSH
58294: CALL 46247 0 2
58298: ST_TO_ADDR
// p := [ ] ;
58299: LD_ADDR_VAR 0 11
58303: PUSH
58304: EMPTY
58305: ST_TO_ADDR
// if sort then
58306: LD_VAR 0 9
58310: IFFALSE 58426
// for i = 1 to 6 - eng do
58312: LD_ADDR_VAR 0 3
58316: PUSH
58317: DOUBLE
58318: LD_INT 1
58320: DEC
58321: ST_TO_ADDR
58322: LD_INT 6
58324: PUSH
58325: LD_VAR 0 6
58329: MINUS
58330: PUSH
58331: FOR_TO
58332: IFFALSE 58424
// begin if i = sort then
58334: LD_VAR 0 3
58338: PUSH
58339: LD_VAR 0 9
58343: EQUAL
58344: IFFALSE 58348
// break ;
58346: GO 58424
// if GetClass ( i ) = 2 then
58348: LD_VAR 0 3
58352: PPUSH
58353: CALL_OW 257
58357: PUSH
58358: LD_INT 2
58360: EQUAL
58361: IFFALSE 58365
// continue ;
58363: GO 58331
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58365: LD_ADDR_VAR 0 11
58369: PUSH
58370: LD_VAR 0 11
58374: PPUSH
58375: LD_VAR 0 11
58379: PUSH
58380: LD_INT 1
58382: PLUS
58383: PPUSH
58384: LD_VAR 0 9
58388: PUSH
58389: LD_VAR 0 3
58393: ARRAY
58394: PPUSH
58395: CALL_OW 2
58399: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58400: LD_ADDR_VAR 0 4
58404: PUSH
58405: LD_VAR 0 4
58409: PUSH
58410: LD_VAR 0 9
58414: PUSH
58415: LD_VAR 0 3
58419: ARRAY
58420: DIFF
58421: ST_TO_ADDR
// end ;
58422: GO 58331
58424: POP
58425: POP
// if p then
58426: LD_VAR 0 11
58430: IFFALSE 58455
// result := Replace ( result , 2 , p ) ;
58432: LD_ADDR_VAR 0 2
58436: PUSH
58437: LD_VAR 0 2
58441: PPUSH
58442: LD_INT 2
58444: PPUSH
58445: LD_VAR 0 11
58449: PPUSH
58450: CALL_OW 1
58454: ST_TO_ADDR
// end ; exit ;
58455: GO 59179
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58457: LD_EXP 50
58461: PUSH
58462: LD_EXP 49
58466: PUSH
58467: LD_VAR 0 1
58471: ARRAY
58472: ARRAY
58473: NOT
58474: PUSH
58475: LD_EXP 23
58479: PUSH
58480: LD_VAR 0 1
58484: ARRAY
58485: PPUSH
58486: LD_INT 30
58488: PUSH
58489: LD_INT 3
58491: PUSH
58492: EMPTY
58493: LIST
58494: LIST
58495: PPUSH
58496: CALL_OW 72
58500: AND
58501: PUSH
58502: LD_EXP 28
58506: PUSH
58507: LD_VAR 0 1
58511: ARRAY
58512: NOT
58513: AND
58514: IFFALSE 59179
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58516: LD_ADDR_EXP 65
58520: PUSH
58521: LD_EXP 65
58525: PPUSH
58526: LD_VAR 0 1
58530: PPUSH
58531: LD_INT 6
58533: PPUSH
58534: CALL_OW 1
58538: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58539: LD_ADDR_VAR 0 2
58543: PUSH
58544: LD_INT 0
58546: PUSH
58547: LD_INT 0
58549: PUSH
58550: LD_INT 0
58552: PUSH
58553: LD_INT 0
58555: PUSH
58556: EMPTY
58557: LIST
58558: LIST
58559: LIST
58560: LIST
58561: ST_TO_ADDR
// if sci >= 1 then
58562: LD_VAR 0 8
58566: PUSH
58567: LD_INT 1
58569: GREATEREQUAL
58570: IFFALSE 58592
// tmp := tmp diff sci [ 1 ] ;
58572: LD_ADDR_VAR 0 4
58576: PUSH
58577: LD_VAR 0 4
58581: PUSH
58582: LD_VAR 0 8
58586: PUSH
58587: LD_INT 1
58589: ARRAY
58590: DIFF
58591: ST_TO_ADDR
// if tmp and not sci then
58592: LD_VAR 0 4
58596: PUSH
58597: LD_VAR 0 8
58601: NOT
58602: AND
58603: IFFALSE 58672
// begin sort := SortBySkill ( tmp , 4 ) ;
58605: LD_ADDR_VAR 0 9
58609: PUSH
58610: LD_VAR 0 4
58614: PPUSH
58615: LD_INT 4
58617: PPUSH
58618: CALL 46247 0 2
58622: ST_TO_ADDR
// if sort then
58623: LD_VAR 0 9
58627: IFFALSE 58643
// p := sort [ 1 ] ;
58629: LD_ADDR_VAR 0 11
58633: PUSH
58634: LD_VAR 0 9
58638: PUSH
58639: LD_INT 1
58641: ARRAY
58642: ST_TO_ADDR
// if p then
58643: LD_VAR 0 11
58647: IFFALSE 58672
// result := Replace ( result , 4 , p ) ;
58649: LD_ADDR_VAR 0 2
58653: PUSH
58654: LD_VAR 0 2
58658: PPUSH
58659: LD_INT 4
58661: PPUSH
58662: LD_VAR 0 11
58666: PPUSH
58667: CALL_OW 1
58671: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58672: LD_ADDR_VAR 0 4
58676: PUSH
58677: LD_VAR 0 4
58681: PUSH
58682: LD_VAR 0 7
58686: DIFF
58687: ST_TO_ADDR
// if tmp and mech < 6 then
58688: LD_VAR 0 4
58692: PUSH
58693: LD_VAR 0 7
58697: PUSH
58698: LD_INT 6
58700: LESS
58701: AND
58702: IFFALSE 58884
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58704: LD_ADDR_VAR 0 9
58708: PUSH
58709: LD_VAR 0 4
58713: PUSH
58714: LD_VAR 0 7
58718: DIFF
58719: PPUSH
58720: LD_INT 3
58722: PPUSH
58723: CALL 46247 0 2
58727: ST_TO_ADDR
// p := [ ] ;
58728: LD_ADDR_VAR 0 11
58732: PUSH
58733: EMPTY
58734: ST_TO_ADDR
// if sort then
58735: LD_VAR 0 9
58739: IFFALSE 58855
// for i = 1 to 6 - mech do
58741: LD_ADDR_VAR 0 3
58745: PUSH
58746: DOUBLE
58747: LD_INT 1
58749: DEC
58750: ST_TO_ADDR
58751: LD_INT 6
58753: PUSH
58754: LD_VAR 0 7
58758: MINUS
58759: PUSH
58760: FOR_TO
58761: IFFALSE 58853
// begin if i = sort then
58763: LD_VAR 0 3
58767: PUSH
58768: LD_VAR 0 9
58772: EQUAL
58773: IFFALSE 58777
// break ;
58775: GO 58853
// if GetClass ( i ) = 3 then
58777: LD_VAR 0 3
58781: PPUSH
58782: CALL_OW 257
58786: PUSH
58787: LD_INT 3
58789: EQUAL
58790: IFFALSE 58794
// continue ;
58792: GO 58760
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58794: LD_ADDR_VAR 0 11
58798: PUSH
58799: LD_VAR 0 11
58803: PPUSH
58804: LD_VAR 0 11
58808: PUSH
58809: LD_INT 1
58811: PLUS
58812: PPUSH
58813: LD_VAR 0 9
58817: PUSH
58818: LD_VAR 0 3
58822: ARRAY
58823: PPUSH
58824: CALL_OW 2
58828: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58829: LD_ADDR_VAR 0 4
58833: PUSH
58834: LD_VAR 0 4
58838: PUSH
58839: LD_VAR 0 9
58843: PUSH
58844: LD_VAR 0 3
58848: ARRAY
58849: DIFF
58850: ST_TO_ADDR
// end ;
58851: GO 58760
58853: POP
58854: POP
// if p then
58855: LD_VAR 0 11
58859: IFFALSE 58884
// result := Replace ( result , 3 , p ) ;
58861: LD_ADDR_VAR 0 2
58865: PUSH
58866: LD_VAR 0 2
58870: PPUSH
58871: LD_INT 3
58873: PPUSH
58874: LD_VAR 0 11
58878: PPUSH
58879: CALL_OW 1
58883: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58884: LD_ADDR_VAR 0 4
58888: PUSH
58889: LD_VAR 0 4
58893: PUSH
58894: LD_VAR 0 6
58898: DIFF
58899: ST_TO_ADDR
// if tmp and eng < 4 then
58900: LD_VAR 0 4
58904: PUSH
58905: LD_VAR 0 6
58909: PUSH
58910: LD_INT 4
58912: LESS
58913: AND
58914: IFFALSE 59104
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58916: LD_ADDR_VAR 0 9
58920: PUSH
58921: LD_VAR 0 4
58925: PUSH
58926: LD_VAR 0 7
58930: PUSH
58931: LD_VAR 0 6
58935: UNION
58936: DIFF
58937: PPUSH
58938: LD_INT 2
58940: PPUSH
58941: CALL 46247 0 2
58945: ST_TO_ADDR
// p := [ ] ;
58946: LD_ADDR_VAR 0 11
58950: PUSH
58951: EMPTY
58952: ST_TO_ADDR
// if sort then
58953: LD_VAR 0 9
58957: IFFALSE 59073
// for i = 1 to 4 - eng do
58959: LD_ADDR_VAR 0 3
58963: PUSH
58964: DOUBLE
58965: LD_INT 1
58967: DEC
58968: ST_TO_ADDR
58969: LD_INT 4
58971: PUSH
58972: LD_VAR 0 6
58976: MINUS
58977: PUSH
58978: FOR_TO
58979: IFFALSE 59071
// begin if i = sort then
58981: LD_VAR 0 3
58985: PUSH
58986: LD_VAR 0 9
58990: EQUAL
58991: IFFALSE 58995
// break ;
58993: GO 59071
// if GetClass ( i ) = 2 then
58995: LD_VAR 0 3
58999: PPUSH
59000: CALL_OW 257
59004: PUSH
59005: LD_INT 2
59007: EQUAL
59008: IFFALSE 59012
// continue ;
59010: GO 58978
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59012: LD_ADDR_VAR 0 11
59016: PUSH
59017: LD_VAR 0 11
59021: PPUSH
59022: LD_VAR 0 11
59026: PUSH
59027: LD_INT 1
59029: PLUS
59030: PPUSH
59031: LD_VAR 0 9
59035: PUSH
59036: LD_VAR 0 3
59040: ARRAY
59041: PPUSH
59042: CALL_OW 2
59046: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59047: LD_ADDR_VAR 0 4
59051: PUSH
59052: LD_VAR 0 4
59056: PUSH
59057: LD_VAR 0 9
59061: PUSH
59062: LD_VAR 0 3
59066: ARRAY
59067: DIFF
59068: ST_TO_ADDR
// end ;
59069: GO 58978
59071: POP
59072: POP
// if p then
59073: LD_VAR 0 11
59077: IFFALSE 59102
// result := Replace ( result , 2 , p ) ;
59079: LD_ADDR_VAR 0 2
59083: PUSH
59084: LD_VAR 0 2
59088: PPUSH
59089: LD_INT 2
59091: PPUSH
59092: LD_VAR 0 11
59096: PPUSH
59097: CALL_OW 1
59101: ST_TO_ADDR
// end else
59102: GO 59148
// for i = eng downto 5 do
59104: LD_ADDR_VAR 0 3
59108: PUSH
59109: DOUBLE
59110: LD_VAR 0 6
59114: INC
59115: ST_TO_ADDR
59116: LD_INT 5
59118: PUSH
59119: FOR_DOWNTO
59120: IFFALSE 59146
// tmp := tmp union eng [ i ] ;
59122: LD_ADDR_VAR 0 4
59126: PUSH
59127: LD_VAR 0 4
59131: PUSH
59132: LD_VAR 0 6
59136: PUSH
59137: LD_VAR 0 3
59141: ARRAY
59142: UNION
59143: ST_TO_ADDR
59144: GO 59119
59146: POP
59147: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59148: LD_ADDR_VAR 0 2
59152: PUSH
59153: LD_VAR 0 2
59157: PPUSH
59158: LD_INT 1
59160: PPUSH
59161: LD_VAR 0 4
59165: PUSH
59166: LD_VAR 0 5
59170: DIFF
59171: PPUSH
59172: CALL_OW 1
59176: ST_TO_ADDR
// exit ;
59177: GO 59179
// end ; end ;
59179: LD_VAR 0 2
59183: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59184: LD_INT 0
59186: PPUSH
59187: PPUSH
59188: PPUSH
// if not mc_bases then
59189: LD_EXP 23
59193: NOT
59194: IFFALSE 59198
// exit ;
59196: GO 59340
// for i = 1 to mc_bases do
59198: LD_ADDR_VAR 0 2
59202: PUSH
59203: DOUBLE
59204: LD_INT 1
59206: DEC
59207: ST_TO_ADDR
59208: LD_EXP 23
59212: PUSH
59213: FOR_TO
59214: IFFALSE 59331
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59216: LD_ADDR_VAR 0 3
59220: PUSH
59221: LD_EXP 23
59225: PUSH
59226: LD_VAR 0 2
59230: ARRAY
59231: PPUSH
59232: LD_INT 21
59234: PUSH
59235: LD_INT 3
59237: PUSH
59238: EMPTY
59239: LIST
59240: LIST
59241: PUSH
59242: LD_INT 3
59244: PUSH
59245: LD_INT 2
59247: PUSH
59248: LD_INT 30
59250: PUSH
59251: LD_INT 29
59253: PUSH
59254: EMPTY
59255: LIST
59256: LIST
59257: PUSH
59258: LD_INT 30
59260: PUSH
59261: LD_INT 30
59263: PUSH
59264: EMPTY
59265: LIST
59266: LIST
59267: PUSH
59268: EMPTY
59269: LIST
59270: LIST
59271: LIST
59272: PUSH
59273: EMPTY
59274: LIST
59275: LIST
59276: PUSH
59277: LD_INT 3
59279: PUSH
59280: LD_INT 24
59282: PUSH
59283: LD_INT 1000
59285: PUSH
59286: EMPTY
59287: LIST
59288: LIST
59289: PUSH
59290: EMPTY
59291: LIST
59292: LIST
59293: PUSH
59294: EMPTY
59295: LIST
59296: LIST
59297: LIST
59298: PPUSH
59299: CALL_OW 72
59303: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59304: LD_ADDR_EXP 24
59308: PUSH
59309: LD_EXP 24
59313: PPUSH
59314: LD_VAR 0 2
59318: PPUSH
59319: LD_VAR 0 3
59323: PPUSH
59324: CALL_OW 1
59328: ST_TO_ADDR
// end ;
59329: GO 59213
59331: POP
59332: POP
// RaiseSailEvent ( 101 ) ;
59333: LD_INT 101
59335: PPUSH
59336: CALL_OW 427
// end ;
59340: LD_VAR 0 1
59344: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59345: LD_INT 0
59347: PPUSH
59348: PPUSH
59349: PPUSH
59350: PPUSH
59351: PPUSH
59352: PPUSH
59353: PPUSH
// if not mc_bases then
59354: LD_EXP 23
59358: NOT
59359: IFFALSE 59363
// exit ;
59361: GO 59925
// for i = 1 to mc_bases do
59363: LD_ADDR_VAR 0 2
59367: PUSH
59368: DOUBLE
59369: LD_INT 1
59371: DEC
59372: ST_TO_ADDR
59373: LD_EXP 23
59377: PUSH
59378: FOR_TO
59379: IFFALSE 59916
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59381: LD_ADDR_VAR 0 5
59385: PUSH
59386: LD_EXP 23
59390: PUSH
59391: LD_VAR 0 2
59395: ARRAY
59396: PUSH
59397: LD_EXP 52
59401: PUSH
59402: LD_VAR 0 2
59406: ARRAY
59407: UNION
59408: PPUSH
59409: LD_INT 21
59411: PUSH
59412: LD_INT 1
59414: PUSH
59415: EMPTY
59416: LIST
59417: LIST
59418: PUSH
59419: LD_INT 1
59421: PUSH
59422: LD_INT 3
59424: PUSH
59425: LD_INT 54
59427: PUSH
59428: EMPTY
59429: LIST
59430: PUSH
59431: EMPTY
59432: LIST
59433: LIST
59434: PUSH
59435: LD_INT 3
59437: PUSH
59438: LD_INT 24
59440: PUSH
59441: LD_INT 1000
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: PUSH
59448: EMPTY
59449: LIST
59450: LIST
59451: PUSH
59452: EMPTY
59453: LIST
59454: LIST
59455: LIST
59456: PUSH
59457: EMPTY
59458: LIST
59459: LIST
59460: PPUSH
59461: CALL_OW 72
59465: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59466: LD_ADDR_VAR 0 6
59470: PUSH
59471: LD_EXP 23
59475: PUSH
59476: LD_VAR 0 2
59480: ARRAY
59481: PPUSH
59482: LD_INT 21
59484: PUSH
59485: LD_INT 1
59487: PUSH
59488: EMPTY
59489: LIST
59490: LIST
59491: PUSH
59492: LD_INT 1
59494: PUSH
59495: LD_INT 3
59497: PUSH
59498: LD_INT 54
59500: PUSH
59501: EMPTY
59502: LIST
59503: PUSH
59504: EMPTY
59505: LIST
59506: LIST
59507: PUSH
59508: LD_INT 3
59510: PUSH
59511: LD_INT 24
59513: PUSH
59514: LD_INT 250
59516: PUSH
59517: EMPTY
59518: LIST
59519: LIST
59520: PUSH
59521: EMPTY
59522: LIST
59523: LIST
59524: PUSH
59525: EMPTY
59526: LIST
59527: LIST
59528: LIST
59529: PUSH
59530: EMPTY
59531: LIST
59532: LIST
59533: PPUSH
59534: CALL_OW 72
59538: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59539: LD_ADDR_VAR 0 7
59543: PUSH
59544: LD_VAR 0 5
59548: PUSH
59549: LD_VAR 0 6
59553: DIFF
59554: ST_TO_ADDR
// if not need_heal_1 then
59555: LD_VAR 0 6
59559: NOT
59560: IFFALSE 59593
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59562: LD_ADDR_EXP 26
59566: PUSH
59567: LD_EXP 26
59571: PPUSH
59572: LD_VAR 0 2
59576: PUSH
59577: LD_INT 1
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: PPUSH
59584: EMPTY
59585: PPUSH
59586: CALL 15990 0 3
59590: ST_TO_ADDR
59591: GO 59663
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59593: LD_ADDR_EXP 26
59597: PUSH
59598: LD_EXP 26
59602: PPUSH
59603: LD_VAR 0 2
59607: PUSH
59608: LD_INT 1
59610: PUSH
59611: EMPTY
59612: LIST
59613: LIST
59614: PPUSH
59615: LD_EXP 26
59619: PUSH
59620: LD_VAR 0 2
59624: ARRAY
59625: PUSH
59626: LD_INT 1
59628: ARRAY
59629: PPUSH
59630: LD_INT 3
59632: PUSH
59633: LD_INT 24
59635: PUSH
59636: LD_INT 1000
59638: PUSH
59639: EMPTY
59640: LIST
59641: LIST
59642: PUSH
59643: EMPTY
59644: LIST
59645: LIST
59646: PPUSH
59647: CALL_OW 72
59651: PUSH
59652: LD_VAR 0 6
59656: UNION
59657: PPUSH
59658: CALL 15990 0 3
59662: ST_TO_ADDR
// if not need_heal_2 then
59663: LD_VAR 0 7
59667: NOT
59668: IFFALSE 59701
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59670: LD_ADDR_EXP 26
59674: PUSH
59675: LD_EXP 26
59679: PPUSH
59680: LD_VAR 0 2
59684: PUSH
59685: LD_INT 2
59687: PUSH
59688: EMPTY
59689: LIST
59690: LIST
59691: PPUSH
59692: EMPTY
59693: PPUSH
59694: CALL 15990 0 3
59698: ST_TO_ADDR
59699: GO 59733
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59701: LD_ADDR_EXP 26
59705: PUSH
59706: LD_EXP 26
59710: PPUSH
59711: LD_VAR 0 2
59715: PUSH
59716: LD_INT 2
59718: PUSH
59719: EMPTY
59720: LIST
59721: LIST
59722: PPUSH
59723: LD_VAR 0 7
59727: PPUSH
59728: CALL 15990 0 3
59732: ST_TO_ADDR
// if need_heal_2 then
59733: LD_VAR 0 7
59737: IFFALSE 59898
// for j in need_heal_2 do
59739: LD_ADDR_VAR 0 3
59743: PUSH
59744: LD_VAR 0 7
59748: PUSH
59749: FOR_IN
59750: IFFALSE 59896
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59752: LD_ADDR_VAR 0 5
59756: PUSH
59757: LD_EXP 23
59761: PUSH
59762: LD_VAR 0 2
59766: ARRAY
59767: PPUSH
59768: LD_INT 2
59770: PUSH
59771: LD_INT 30
59773: PUSH
59774: LD_INT 6
59776: PUSH
59777: EMPTY
59778: LIST
59779: LIST
59780: PUSH
59781: LD_INT 30
59783: PUSH
59784: LD_INT 7
59786: PUSH
59787: EMPTY
59788: LIST
59789: LIST
59790: PUSH
59791: LD_INT 30
59793: PUSH
59794: LD_INT 8
59796: PUSH
59797: EMPTY
59798: LIST
59799: LIST
59800: PUSH
59801: LD_INT 30
59803: PUSH
59804: LD_INT 0
59806: PUSH
59807: EMPTY
59808: LIST
59809: LIST
59810: PUSH
59811: LD_INT 30
59813: PUSH
59814: LD_INT 1
59816: PUSH
59817: EMPTY
59818: LIST
59819: LIST
59820: PUSH
59821: EMPTY
59822: LIST
59823: LIST
59824: LIST
59825: LIST
59826: LIST
59827: LIST
59828: PPUSH
59829: CALL_OW 72
59833: ST_TO_ADDR
// if tmp then
59834: LD_VAR 0 5
59838: IFFALSE 59894
// begin k := NearestUnitToUnit ( tmp , j ) ;
59840: LD_ADDR_VAR 0 4
59844: PUSH
59845: LD_VAR 0 5
59849: PPUSH
59850: LD_VAR 0 3
59854: PPUSH
59855: CALL_OW 74
59859: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
59860: LD_VAR 0 3
59864: PPUSH
59865: LD_VAR 0 4
59869: PPUSH
59870: CALL_OW 296
59874: PUSH
59875: LD_INT 5
59877: GREATER
59878: IFFALSE 59894
// ComMoveToNearbyEntrance ( j , k ) ;
59880: LD_VAR 0 3
59884: PPUSH
59885: LD_VAR 0 4
59889: PPUSH
59890: CALL 48608 0 2
// end ; end ;
59894: GO 59749
59896: POP
59897: POP
// if not need_heal_1 and not need_heal_2 then
59898: LD_VAR 0 6
59902: NOT
59903: PUSH
59904: LD_VAR 0 7
59908: NOT
59909: AND
59910: IFFALSE 59914
// continue ;
59912: GO 59378
// end ;
59914: GO 59378
59916: POP
59917: POP
// RaiseSailEvent ( 102 ) ;
59918: LD_INT 102
59920: PPUSH
59921: CALL_OW 427
// end ;
59925: LD_VAR 0 1
59929: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59930: LD_INT 0
59932: PPUSH
59933: PPUSH
59934: PPUSH
59935: PPUSH
59936: PPUSH
59937: PPUSH
59938: PPUSH
59939: PPUSH
// if not mc_bases then
59940: LD_EXP 23
59944: NOT
59945: IFFALSE 59949
// exit ;
59947: GO 60832
// for i = 1 to mc_bases do
59949: LD_ADDR_VAR 0 2
59953: PUSH
59954: DOUBLE
59955: LD_INT 1
59957: DEC
59958: ST_TO_ADDR
59959: LD_EXP 23
59963: PUSH
59964: FOR_TO
59965: IFFALSE 60830
// begin if not mc_building_need_repair [ i ] then
59967: LD_EXP 24
59971: PUSH
59972: LD_VAR 0 2
59976: ARRAY
59977: NOT
59978: IFFALSE 60165
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
59980: LD_ADDR_VAR 0 6
59984: PUSH
59985: LD_EXP 42
59989: PUSH
59990: LD_VAR 0 2
59994: ARRAY
59995: PPUSH
59996: LD_INT 3
59998: PUSH
59999: LD_INT 24
60001: PUSH
60002: LD_INT 1000
60004: PUSH
60005: EMPTY
60006: LIST
60007: LIST
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: PUSH
60013: LD_INT 2
60015: PUSH
60016: LD_INT 34
60018: PUSH
60019: LD_INT 13
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: PUSH
60026: LD_INT 34
60028: PUSH
60029: LD_INT 52
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: PUSH
60036: LD_INT 34
60038: PUSH
60039: LD_EXP 73
60043: PUSH
60044: EMPTY
60045: LIST
60046: LIST
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: LIST
60052: LIST
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PPUSH
60058: CALL_OW 72
60062: ST_TO_ADDR
// if cranes then
60063: LD_VAR 0 6
60067: IFFALSE 60129
// for j in cranes do
60069: LD_ADDR_VAR 0 3
60073: PUSH
60074: LD_VAR 0 6
60078: PUSH
60079: FOR_IN
60080: IFFALSE 60127
// if not IsInArea ( j , mc_parking [ i ] ) then
60082: LD_VAR 0 3
60086: PPUSH
60087: LD_EXP 47
60091: PUSH
60092: LD_VAR 0 2
60096: ARRAY
60097: PPUSH
60098: CALL_OW 308
60102: NOT
60103: IFFALSE 60125
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60105: LD_VAR 0 3
60109: PPUSH
60110: LD_EXP 47
60114: PUSH
60115: LD_VAR 0 2
60119: ARRAY
60120: PPUSH
60121: CALL_OW 113
60125: GO 60079
60127: POP
60128: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60129: LD_ADDR_EXP 25
60133: PUSH
60134: LD_EXP 25
60138: PPUSH
60139: LD_VAR 0 2
60143: PPUSH
60144: EMPTY
60145: PPUSH
60146: CALL_OW 1
60150: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60151: LD_VAR 0 2
60155: PPUSH
60156: LD_INT 101
60158: PPUSH
60159: CALL 55017 0 2
// continue ;
60163: GO 59964
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60165: LD_ADDR_EXP 29
60169: PUSH
60170: LD_EXP 29
60174: PPUSH
60175: LD_VAR 0 2
60179: PPUSH
60180: EMPTY
60181: PPUSH
60182: CALL_OW 1
60186: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60187: LD_VAR 0 2
60191: PPUSH
60192: LD_INT 103
60194: PPUSH
60195: CALL 55017 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
60199: LD_ADDR_VAR 0 5
60203: PUSH
60204: LD_EXP 23
60208: PUSH
60209: LD_VAR 0 2
60213: ARRAY
60214: PUSH
60215: LD_EXP 52
60219: PUSH
60220: LD_VAR 0 2
60224: ARRAY
60225: UNION
60226: PPUSH
60227: LD_INT 2
60229: PUSH
60230: LD_INT 25
60232: PUSH
60233: LD_INT 2
60235: PUSH
60236: EMPTY
60237: LIST
60238: LIST
60239: PUSH
60240: LD_INT 25
60242: PUSH
60243: LD_INT 16
60245: PUSH
60246: EMPTY
60247: LIST
60248: LIST
60249: PUSH
60250: EMPTY
60251: LIST
60252: LIST
60253: LIST
60254: PUSH
60255: EMPTY
60256: LIST
60257: PPUSH
60258: CALL_OW 72
60262: ST_TO_ADDR
// if mc_need_heal [ i ] then
60263: LD_EXP 26
60267: PUSH
60268: LD_VAR 0 2
60272: ARRAY
60273: IFFALSE 60317
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60275: LD_ADDR_VAR 0 5
60279: PUSH
60280: LD_VAR 0 5
60284: PUSH
60285: LD_EXP 26
60289: PUSH
60290: LD_VAR 0 2
60294: ARRAY
60295: PUSH
60296: LD_INT 1
60298: ARRAY
60299: PUSH
60300: LD_EXP 26
60304: PUSH
60305: LD_VAR 0 2
60309: ARRAY
60310: PUSH
60311: LD_INT 2
60313: ARRAY
60314: UNION
60315: DIFF
60316: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60317: LD_ADDR_VAR 0 6
60321: PUSH
60322: LD_EXP 42
60326: PUSH
60327: LD_VAR 0 2
60331: ARRAY
60332: PPUSH
60333: LD_INT 2
60335: PUSH
60336: LD_INT 34
60338: PUSH
60339: LD_INT 13
60341: PUSH
60342: EMPTY
60343: LIST
60344: LIST
60345: PUSH
60346: LD_INT 34
60348: PUSH
60349: LD_INT 52
60351: PUSH
60352: EMPTY
60353: LIST
60354: LIST
60355: PUSH
60356: LD_INT 34
60358: PUSH
60359: LD_EXP 73
60363: PUSH
60364: EMPTY
60365: LIST
60366: LIST
60367: PUSH
60368: EMPTY
60369: LIST
60370: LIST
60371: LIST
60372: LIST
60373: PPUSH
60374: CALL_OW 72
60378: ST_TO_ADDR
// if cranes then
60379: LD_VAR 0 6
60383: IFFALSE 60519
// begin for j in cranes do
60385: LD_ADDR_VAR 0 3
60389: PUSH
60390: LD_VAR 0 6
60394: PUSH
60395: FOR_IN
60396: IFFALSE 60517
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60398: LD_VAR 0 3
60402: PPUSH
60403: CALL_OW 256
60407: PUSH
60408: LD_INT 1000
60410: EQUAL
60411: PUSH
60412: LD_VAR 0 3
60416: PPUSH
60417: CALL_OW 314
60421: NOT
60422: AND
60423: IFFALSE 60457
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60425: LD_VAR 0 3
60429: PPUSH
60430: LD_EXP 24
60434: PUSH
60435: LD_VAR 0 2
60439: ARRAY
60440: PPUSH
60441: LD_VAR 0 3
60445: PPUSH
60446: CALL_OW 74
60450: PPUSH
60451: CALL_OW 130
60455: GO 60515
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60457: LD_VAR 0 3
60461: PPUSH
60462: CALL_OW 256
60466: PUSH
60467: LD_INT 500
60469: LESS
60470: PUSH
60471: LD_VAR 0 3
60475: PPUSH
60476: LD_EXP 47
60480: PUSH
60481: LD_VAR 0 2
60485: ARRAY
60486: PPUSH
60487: CALL_OW 308
60491: NOT
60492: AND
60493: IFFALSE 60515
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60495: LD_VAR 0 3
60499: PPUSH
60500: LD_EXP 47
60504: PUSH
60505: LD_VAR 0 2
60509: ARRAY
60510: PPUSH
60511: CALL_OW 113
// end ;
60515: GO 60395
60517: POP
60518: POP
// end ; if tmp > 3 then
60519: LD_VAR 0 5
60523: PUSH
60524: LD_INT 3
60526: GREATER
60527: IFFALSE 60547
// tmp := ShrinkArray ( tmp , 4 ) ;
60529: LD_ADDR_VAR 0 5
60533: PUSH
60534: LD_VAR 0 5
60538: PPUSH
60539: LD_INT 4
60541: PPUSH
60542: CALL 48056 0 2
60546: ST_TO_ADDR
// if not tmp then
60547: LD_VAR 0 5
60551: NOT
60552: IFFALSE 60556
// continue ;
60554: GO 59964
// for j in tmp do
60556: LD_ADDR_VAR 0 3
60560: PUSH
60561: LD_VAR 0 5
60565: PUSH
60566: FOR_IN
60567: IFFALSE 60826
// begin if IsInUnit ( j ) then
60569: LD_VAR 0 3
60573: PPUSH
60574: CALL_OW 310
60578: IFFALSE 60589
// ComExitBuilding ( j ) ;
60580: LD_VAR 0 3
60584: PPUSH
60585: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60589: LD_VAR 0 3
60593: PUSH
60594: LD_EXP 25
60598: PUSH
60599: LD_VAR 0 2
60603: ARRAY
60604: IN
60605: NOT
60606: IFFALSE 60664
// begin SetTag ( j , 101 ) ;
60608: LD_VAR 0 3
60612: PPUSH
60613: LD_INT 101
60615: PPUSH
60616: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60620: LD_ADDR_EXP 25
60624: PUSH
60625: LD_EXP 25
60629: PPUSH
60630: LD_VAR 0 2
60634: PUSH
60635: LD_EXP 25
60639: PUSH
60640: LD_VAR 0 2
60644: ARRAY
60645: PUSH
60646: LD_INT 1
60648: PLUS
60649: PUSH
60650: EMPTY
60651: LIST
60652: LIST
60653: PPUSH
60654: LD_VAR 0 3
60658: PPUSH
60659: CALL 15990 0 3
60663: ST_TO_ADDR
// end ; wait ( 1 ) ;
60664: LD_INT 1
60666: PPUSH
60667: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60671: LD_ADDR_VAR 0 7
60675: PUSH
60676: LD_EXP 24
60680: PUSH
60681: LD_VAR 0 2
60685: ARRAY
60686: ST_TO_ADDR
// if mc_scan [ i ] then
60687: LD_EXP 46
60691: PUSH
60692: LD_VAR 0 2
60696: ARRAY
60697: IFFALSE 60759
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60699: LD_ADDR_VAR 0 7
60703: PUSH
60704: LD_EXP 24
60708: PUSH
60709: LD_VAR 0 2
60713: ARRAY
60714: PPUSH
60715: LD_INT 3
60717: PUSH
60718: LD_INT 30
60720: PUSH
60721: LD_INT 32
60723: PUSH
60724: EMPTY
60725: LIST
60726: LIST
60727: PUSH
60728: LD_INT 30
60730: PUSH
60731: LD_INT 33
60733: PUSH
60734: EMPTY
60735: LIST
60736: LIST
60737: PUSH
60738: LD_INT 30
60740: PUSH
60741: LD_INT 31
60743: PUSH
60744: EMPTY
60745: LIST
60746: LIST
60747: PUSH
60748: EMPTY
60749: LIST
60750: LIST
60751: LIST
60752: LIST
60753: PPUSH
60754: CALL_OW 72
60758: ST_TO_ADDR
// if not to_repair_tmp then
60759: LD_VAR 0 7
60763: NOT
60764: IFFALSE 60768
// continue ;
60766: GO 60566
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60768: LD_ADDR_VAR 0 8
60772: PUSH
60773: LD_VAR 0 7
60777: PPUSH
60778: LD_VAR 0 3
60782: PPUSH
60783: CALL_OW 74
60787: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60788: LD_VAR 0 8
60792: PPUSH
60793: LD_INT 16
60795: PPUSH
60796: CALL 18589 0 2
60800: PUSH
60801: LD_INT 4
60803: ARRAY
60804: PUSH
60805: LD_INT 10
60807: LESS
60808: IFFALSE 60824
// ComRepairBuilding ( j , to_repair ) ;
60810: LD_VAR 0 3
60814: PPUSH
60815: LD_VAR 0 8
60819: PPUSH
60820: CALL_OW 130
// end ;
60824: GO 60566
60826: POP
60827: POP
// end ;
60828: GO 59964
60830: POP
60831: POP
// end ;
60832: LD_VAR 0 1
60836: RET
// export function MC_Heal ; var i , j , tmp ; begin
60837: LD_INT 0
60839: PPUSH
60840: PPUSH
60841: PPUSH
60842: PPUSH
// if not mc_bases then
60843: LD_EXP 23
60847: NOT
60848: IFFALSE 60852
// exit ;
60850: GO 61254
// for i = 1 to mc_bases do
60852: LD_ADDR_VAR 0 2
60856: PUSH
60857: DOUBLE
60858: LD_INT 1
60860: DEC
60861: ST_TO_ADDR
60862: LD_EXP 23
60866: PUSH
60867: FOR_TO
60868: IFFALSE 61252
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60870: LD_EXP 26
60874: PUSH
60875: LD_VAR 0 2
60879: ARRAY
60880: PUSH
60881: LD_INT 1
60883: ARRAY
60884: NOT
60885: PUSH
60886: LD_EXP 26
60890: PUSH
60891: LD_VAR 0 2
60895: ARRAY
60896: PUSH
60897: LD_INT 2
60899: ARRAY
60900: NOT
60901: AND
60902: IFFALSE 60940
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60904: LD_ADDR_EXP 27
60908: PUSH
60909: LD_EXP 27
60913: PPUSH
60914: LD_VAR 0 2
60918: PPUSH
60919: EMPTY
60920: PPUSH
60921: CALL_OW 1
60925: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60926: LD_VAR 0 2
60930: PPUSH
60931: LD_INT 102
60933: PPUSH
60934: CALL 55017 0 2
// continue ;
60938: GO 60867
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60940: LD_ADDR_VAR 0 4
60944: PUSH
60945: LD_EXP 23
60949: PUSH
60950: LD_VAR 0 2
60954: ARRAY
60955: PPUSH
60956: LD_INT 25
60958: PUSH
60959: LD_INT 4
60961: PUSH
60962: EMPTY
60963: LIST
60964: LIST
60965: PPUSH
60966: CALL_OW 72
60970: ST_TO_ADDR
// if not tmp then
60971: LD_VAR 0 4
60975: NOT
60976: IFFALSE 60980
// continue ;
60978: GO 60867
// if mc_taming [ i ] then
60980: LD_EXP 54
60984: PUSH
60985: LD_VAR 0 2
60989: ARRAY
60990: IFFALSE 61014
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60992: LD_ADDR_EXP 54
60996: PUSH
60997: LD_EXP 54
61001: PPUSH
61002: LD_VAR 0 2
61006: PPUSH
61007: EMPTY
61008: PPUSH
61009: CALL_OW 1
61013: ST_TO_ADDR
// for j in tmp do
61014: LD_ADDR_VAR 0 3
61018: PUSH
61019: LD_VAR 0 4
61023: PUSH
61024: FOR_IN
61025: IFFALSE 61248
// begin if IsInUnit ( j ) then
61027: LD_VAR 0 3
61031: PPUSH
61032: CALL_OW 310
61036: IFFALSE 61047
// ComExitBuilding ( j ) ;
61038: LD_VAR 0 3
61042: PPUSH
61043: CALL_OW 122
// if not j in mc_healers [ i ] then
61047: LD_VAR 0 3
61051: PUSH
61052: LD_EXP 27
61056: PUSH
61057: LD_VAR 0 2
61061: ARRAY
61062: IN
61063: NOT
61064: IFFALSE 61110
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61066: LD_ADDR_EXP 27
61070: PUSH
61071: LD_EXP 27
61075: PPUSH
61076: LD_VAR 0 2
61080: PUSH
61081: LD_EXP 27
61085: PUSH
61086: LD_VAR 0 2
61090: ARRAY
61091: PUSH
61092: LD_INT 1
61094: PLUS
61095: PUSH
61096: EMPTY
61097: LIST
61098: LIST
61099: PPUSH
61100: LD_VAR 0 3
61104: PPUSH
61105: CALL 15990 0 3
61109: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61110: LD_VAR 0 3
61114: PPUSH
61115: CALL_OW 110
61119: PUSH
61120: LD_INT 102
61122: NONEQUAL
61123: IFFALSE 61137
// SetTag ( j , 102 ) ;
61125: LD_VAR 0 3
61129: PPUSH
61130: LD_INT 102
61132: PPUSH
61133: CALL_OW 109
// Wait ( 3 ) ;
61137: LD_INT 3
61139: PPUSH
61140: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61144: LD_EXP 26
61148: PUSH
61149: LD_VAR 0 2
61153: ARRAY
61154: PUSH
61155: LD_INT 1
61157: ARRAY
61158: IFFALSE 61190
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61160: LD_VAR 0 3
61164: PPUSH
61165: LD_EXP 26
61169: PUSH
61170: LD_VAR 0 2
61174: ARRAY
61175: PUSH
61176: LD_INT 1
61178: ARRAY
61179: PUSH
61180: LD_INT 1
61182: ARRAY
61183: PPUSH
61184: CALL_OW 128
61188: GO 61246
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61190: LD_VAR 0 3
61194: PPUSH
61195: CALL_OW 314
61199: NOT
61200: PUSH
61201: LD_EXP 26
61205: PUSH
61206: LD_VAR 0 2
61210: ARRAY
61211: PUSH
61212: LD_INT 2
61214: ARRAY
61215: AND
61216: IFFALSE 61246
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61218: LD_VAR 0 3
61222: PPUSH
61223: LD_EXP 26
61227: PUSH
61228: LD_VAR 0 2
61232: ARRAY
61233: PUSH
61234: LD_INT 2
61236: ARRAY
61237: PUSH
61238: LD_INT 1
61240: ARRAY
61241: PPUSH
61242: CALL_OW 128
// end ;
61246: GO 61024
61248: POP
61249: POP
// end ;
61250: GO 60867
61252: POP
61253: POP
// end ;
61254: LD_VAR 0 1
61258: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61259: LD_INT 0
61261: PPUSH
61262: PPUSH
61263: PPUSH
61264: PPUSH
61265: PPUSH
// if not mc_bases then
61266: LD_EXP 23
61270: NOT
61271: IFFALSE 61275
// exit ;
61273: GO 62446
// for i = 1 to mc_bases do
61275: LD_ADDR_VAR 0 2
61279: PUSH
61280: DOUBLE
61281: LD_INT 1
61283: DEC
61284: ST_TO_ADDR
61285: LD_EXP 23
61289: PUSH
61290: FOR_TO
61291: IFFALSE 62444
// begin if mc_scan [ i ] then
61293: LD_EXP 46
61297: PUSH
61298: LD_VAR 0 2
61302: ARRAY
61303: IFFALSE 61307
// continue ;
61305: GO 61290
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61307: LD_EXP 28
61311: PUSH
61312: LD_VAR 0 2
61316: ARRAY
61317: NOT
61318: PUSH
61319: LD_EXP 30
61323: PUSH
61324: LD_VAR 0 2
61328: ARRAY
61329: NOT
61330: AND
61331: PUSH
61332: LD_EXP 29
61336: PUSH
61337: LD_VAR 0 2
61341: ARRAY
61342: AND
61343: IFFALSE 61381
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61345: LD_ADDR_EXP 29
61349: PUSH
61350: LD_EXP 29
61354: PPUSH
61355: LD_VAR 0 2
61359: PPUSH
61360: EMPTY
61361: PPUSH
61362: CALL_OW 1
61366: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61367: LD_VAR 0 2
61371: PPUSH
61372: LD_INT 103
61374: PPUSH
61375: CALL 55017 0 2
// continue ;
61379: GO 61290
// end ; if mc_construct_list [ i ] then
61381: LD_EXP 30
61385: PUSH
61386: LD_VAR 0 2
61390: ARRAY
61391: IFFALSE 61611
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61393: LD_ADDR_VAR 0 4
61397: PUSH
61398: LD_EXP 23
61402: PUSH
61403: LD_VAR 0 2
61407: ARRAY
61408: PPUSH
61409: LD_INT 25
61411: PUSH
61412: LD_INT 2
61414: PUSH
61415: EMPTY
61416: LIST
61417: LIST
61418: PPUSH
61419: CALL_OW 72
61423: PUSH
61424: LD_EXP 25
61428: PUSH
61429: LD_VAR 0 2
61433: ARRAY
61434: DIFF
61435: ST_TO_ADDR
// if not tmp then
61436: LD_VAR 0 4
61440: NOT
61441: IFFALSE 61445
// continue ;
61443: GO 61290
// for j in tmp do
61445: LD_ADDR_VAR 0 3
61449: PUSH
61450: LD_VAR 0 4
61454: PUSH
61455: FOR_IN
61456: IFFALSE 61607
// begin if not mc_builders [ i ] then
61458: LD_EXP 29
61462: PUSH
61463: LD_VAR 0 2
61467: ARRAY
61468: NOT
61469: IFFALSE 61527
// begin SetTag ( j , 103 ) ;
61471: LD_VAR 0 3
61475: PPUSH
61476: LD_INT 103
61478: PPUSH
61479: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61483: LD_ADDR_EXP 29
61487: PUSH
61488: LD_EXP 29
61492: PPUSH
61493: LD_VAR 0 2
61497: PUSH
61498: LD_EXP 29
61502: PUSH
61503: LD_VAR 0 2
61507: ARRAY
61508: PUSH
61509: LD_INT 1
61511: PLUS
61512: PUSH
61513: EMPTY
61514: LIST
61515: LIST
61516: PPUSH
61517: LD_VAR 0 3
61521: PPUSH
61522: CALL 15990 0 3
61526: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61527: LD_VAR 0 3
61531: PPUSH
61532: CALL_OW 310
61536: IFFALSE 61547
// ComExitBuilding ( j ) ;
61538: LD_VAR 0 3
61542: PPUSH
61543: CALL_OW 122
// wait ( 3 ) ;
61547: LD_INT 3
61549: PPUSH
61550: CALL_OW 67
// if not mc_construct_list [ i ] then
61554: LD_EXP 30
61558: PUSH
61559: LD_VAR 0 2
61563: ARRAY
61564: NOT
61565: IFFALSE 61569
// break ;
61567: GO 61607
// if not HasTask ( j ) then
61569: LD_VAR 0 3
61573: PPUSH
61574: CALL_OW 314
61578: NOT
61579: IFFALSE 61605
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61581: LD_VAR 0 3
61585: PPUSH
61586: LD_EXP 30
61590: PUSH
61591: LD_VAR 0 2
61595: ARRAY
61596: PUSH
61597: LD_INT 1
61599: ARRAY
61600: PPUSH
61601: CALL 18853 0 2
// end ;
61605: GO 61455
61607: POP
61608: POP
// end else
61609: GO 62442
// if mc_build_list [ i ] then
61611: LD_EXP 28
61615: PUSH
61616: LD_VAR 0 2
61620: ARRAY
61621: IFFALSE 62442
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61623: LD_ADDR_VAR 0 5
61627: PUSH
61628: LD_EXP 23
61632: PUSH
61633: LD_VAR 0 2
61637: ARRAY
61638: PPUSH
61639: LD_INT 2
61641: PUSH
61642: LD_INT 30
61644: PUSH
61645: LD_INT 0
61647: PUSH
61648: EMPTY
61649: LIST
61650: LIST
61651: PUSH
61652: LD_INT 30
61654: PUSH
61655: LD_INT 1
61657: PUSH
61658: EMPTY
61659: LIST
61660: LIST
61661: PUSH
61662: EMPTY
61663: LIST
61664: LIST
61665: LIST
61666: PPUSH
61667: CALL_OW 72
61671: ST_TO_ADDR
// if depot then
61672: LD_VAR 0 5
61676: IFFALSE 61694
// depot := depot [ 1 ] else
61678: LD_ADDR_VAR 0 5
61682: PUSH
61683: LD_VAR 0 5
61687: PUSH
61688: LD_INT 1
61690: ARRAY
61691: ST_TO_ADDR
61692: GO 61702
// depot := 0 ;
61694: LD_ADDR_VAR 0 5
61698: PUSH
61699: LD_INT 0
61701: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61702: LD_EXP 28
61706: PUSH
61707: LD_VAR 0 2
61711: ARRAY
61712: PUSH
61713: LD_INT 1
61715: ARRAY
61716: PUSH
61717: LD_INT 1
61719: ARRAY
61720: PPUSH
61721: CALL 18677 0 1
61725: PUSH
61726: LD_EXP 23
61730: PUSH
61731: LD_VAR 0 2
61735: ARRAY
61736: PPUSH
61737: LD_INT 2
61739: PUSH
61740: LD_INT 30
61742: PUSH
61743: LD_INT 2
61745: PUSH
61746: EMPTY
61747: LIST
61748: LIST
61749: PUSH
61750: LD_INT 30
61752: PUSH
61753: LD_INT 3
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: PUSH
61760: EMPTY
61761: LIST
61762: LIST
61763: LIST
61764: PPUSH
61765: CALL_OW 72
61769: NOT
61770: AND
61771: IFFALSE 61876
// begin for j = 1 to mc_build_list [ i ] do
61773: LD_ADDR_VAR 0 3
61777: PUSH
61778: DOUBLE
61779: LD_INT 1
61781: DEC
61782: ST_TO_ADDR
61783: LD_EXP 28
61787: PUSH
61788: LD_VAR 0 2
61792: ARRAY
61793: PUSH
61794: FOR_TO
61795: IFFALSE 61874
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61797: LD_EXP 28
61801: PUSH
61802: LD_VAR 0 2
61806: ARRAY
61807: PUSH
61808: LD_VAR 0 3
61812: ARRAY
61813: PUSH
61814: LD_INT 1
61816: ARRAY
61817: PUSH
61818: LD_INT 2
61820: EQUAL
61821: IFFALSE 61872
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61823: LD_ADDR_EXP 28
61827: PUSH
61828: LD_EXP 28
61832: PPUSH
61833: LD_VAR 0 2
61837: PPUSH
61838: LD_EXP 28
61842: PUSH
61843: LD_VAR 0 2
61847: ARRAY
61848: PPUSH
61849: LD_VAR 0 3
61853: PPUSH
61854: LD_INT 1
61856: PPUSH
61857: LD_INT 0
61859: PPUSH
61860: CALL 15408 0 4
61864: PPUSH
61865: CALL_OW 1
61869: ST_TO_ADDR
// break ;
61870: GO 61874
// end ;
61872: GO 61794
61874: POP
61875: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61876: LD_EXP 28
61880: PUSH
61881: LD_VAR 0 2
61885: ARRAY
61886: PUSH
61887: LD_INT 1
61889: ARRAY
61890: PUSH
61891: LD_INT 1
61893: ARRAY
61894: PUSH
61895: LD_INT 0
61897: EQUAL
61898: PUSH
61899: LD_VAR 0 5
61903: PUSH
61904: LD_VAR 0 5
61908: PPUSH
61909: LD_EXP 28
61913: PUSH
61914: LD_VAR 0 2
61918: ARRAY
61919: PUSH
61920: LD_INT 1
61922: ARRAY
61923: PUSH
61924: LD_INT 1
61926: ARRAY
61927: PPUSH
61928: LD_EXP 28
61932: PUSH
61933: LD_VAR 0 2
61937: ARRAY
61938: PUSH
61939: LD_INT 1
61941: ARRAY
61942: PUSH
61943: LD_INT 2
61945: ARRAY
61946: PPUSH
61947: LD_EXP 28
61951: PUSH
61952: LD_VAR 0 2
61956: ARRAY
61957: PUSH
61958: LD_INT 1
61960: ARRAY
61961: PUSH
61962: LD_INT 3
61964: ARRAY
61965: PPUSH
61966: LD_EXP 28
61970: PUSH
61971: LD_VAR 0 2
61975: ARRAY
61976: PUSH
61977: LD_INT 1
61979: ARRAY
61980: PUSH
61981: LD_INT 4
61983: ARRAY
61984: PPUSH
61985: CALL 24093 0 5
61989: AND
61990: OR
61991: IFFALSE 62272
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61993: LD_ADDR_VAR 0 4
61997: PUSH
61998: LD_EXP 23
62002: PUSH
62003: LD_VAR 0 2
62007: ARRAY
62008: PPUSH
62009: LD_INT 25
62011: PUSH
62012: LD_INT 2
62014: PUSH
62015: EMPTY
62016: LIST
62017: LIST
62018: PPUSH
62019: CALL_OW 72
62023: PUSH
62024: LD_EXP 25
62028: PUSH
62029: LD_VAR 0 2
62033: ARRAY
62034: DIFF
62035: ST_TO_ADDR
// if not tmp then
62036: LD_VAR 0 4
62040: NOT
62041: IFFALSE 62045
// continue ;
62043: GO 61290
// for j in tmp do
62045: LD_ADDR_VAR 0 3
62049: PUSH
62050: LD_VAR 0 4
62054: PUSH
62055: FOR_IN
62056: IFFALSE 62268
// begin if not mc_builders [ i ] then
62058: LD_EXP 29
62062: PUSH
62063: LD_VAR 0 2
62067: ARRAY
62068: NOT
62069: IFFALSE 62127
// begin SetTag ( j , 103 ) ;
62071: LD_VAR 0 3
62075: PPUSH
62076: LD_INT 103
62078: PPUSH
62079: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62083: LD_ADDR_EXP 29
62087: PUSH
62088: LD_EXP 29
62092: PPUSH
62093: LD_VAR 0 2
62097: PUSH
62098: LD_EXP 29
62102: PUSH
62103: LD_VAR 0 2
62107: ARRAY
62108: PUSH
62109: LD_INT 1
62111: PLUS
62112: PUSH
62113: EMPTY
62114: LIST
62115: LIST
62116: PPUSH
62117: LD_VAR 0 3
62121: PPUSH
62122: CALL 15990 0 3
62126: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62127: LD_VAR 0 3
62131: PPUSH
62132: CALL_OW 310
62136: IFFALSE 62147
// ComExitBuilding ( j ) ;
62138: LD_VAR 0 3
62142: PPUSH
62143: CALL_OW 122
// wait ( 3 ) ;
62147: LD_INT 3
62149: PPUSH
62150: CALL_OW 67
// if not mc_build_list [ i ] then
62154: LD_EXP 28
62158: PUSH
62159: LD_VAR 0 2
62163: ARRAY
62164: NOT
62165: IFFALSE 62169
// break ;
62167: GO 62268
// if not HasTask ( j ) then
62169: LD_VAR 0 3
62173: PPUSH
62174: CALL_OW 314
62178: NOT
62179: IFFALSE 62266
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62181: LD_VAR 0 3
62185: PPUSH
62186: LD_EXP 28
62190: PUSH
62191: LD_VAR 0 2
62195: ARRAY
62196: PUSH
62197: LD_INT 1
62199: ARRAY
62200: PUSH
62201: LD_INT 1
62203: ARRAY
62204: PPUSH
62205: LD_EXP 28
62209: PUSH
62210: LD_VAR 0 2
62214: ARRAY
62215: PUSH
62216: LD_INT 1
62218: ARRAY
62219: PUSH
62220: LD_INT 2
62222: ARRAY
62223: PPUSH
62224: LD_EXP 28
62228: PUSH
62229: LD_VAR 0 2
62233: ARRAY
62234: PUSH
62235: LD_INT 1
62237: ARRAY
62238: PUSH
62239: LD_INT 3
62241: ARRAY
62242: PPUSH
62243: LD_EXP 28
62247: PUSH
62248: LD_VAR 0 2
62252: ARRAY
62253: PUSH
62254: LD_INT 1
62256: ARRAY
62257: PUSH
62258: LD_INT 4
62260: ARRAY
62261: PPUSH
62262: CALL_OW 145
// end ;
62266: GO 62055
62268: POP
62269: POP
// end else
62270: GO 62442
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
62272: LD_EXP 23
62276: PUSH
62277: LD_VAR 0 2
62281: ARRAY
62282: PPUSH
62283: LD_EXP 28
62287: PUSH
62288: LD_VAR 0 2
62292: ARRAY
62293: PUSH
62294: LD_INT 1
62296: ARRAY
62297: PUSH
62298: LD_INT 1
62300: ARRAY
62301: PPUSH
62302: LD_EXP 28
62306: PUSH
62307: LD_VAR 0 2
62311: ARRAY
62312: PUSH
62313: LD_INT 1
62315: ARRAY
62316: PUSH
62317: LD_INT 2
62319: ARRAY
62320: PPUSH
62321: LD_EXP 28
62325: PUSH
62326: LD_VAR 0 2
62330: ARRAY
62331: PUSH
62332: LD_INT 1
62334: ARRAY
62335: PUSH
62336: LD_INT 3
62338: ARRAY
62339: PPUSH
62340: LD_EXP 28
62344: PUSH
62345: LD_VAR 0 2
62349: ARRAY
62350: PUSH
62351: LD_INT 1
62353: ARRAY
62354: PUSH
62355: LD_INT 4
62357: ARRAY
62358: PPUSH
62359: LD_EXP 23
62363: PUSH
62364: LD_VAR 0 2
62368: ARRAY
62369: PPUSH
62370: LD_INT 21
62372: PUSH
62373: LD_INT 3
62375: PUSH
62376: EMPTY
62377: LIST
62378: LIST
62379: PPUSH
62380: CALL_OW 72
62384: PPUSH
62385: EMPTY
62386: PPUSH
62387: CALL 22843 0 7
62391: NOT
62392: IFFALSE 62442
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62394: LD_ADDR_EXP 28
62398: PUSH
62399: LD_EXP 28
62403: PPUSH
62404: LD_VAR 0 2
62408: PPUSH
62409: LD_EXP 28
62413: PUSH
62414: LD_VAR 0 2
62418: ARRAY
62419: PPUSH
62420: LD_INT 1
62422: PPUSH
62423: LD_INT 1
62425: NEG
62426: PPUSH
62427: LD_INT 0
62429: PPUSH
62430: CALL 15408 0 4
62434: PPUSH
62435: CALL_OW 1
62439: ST_TO_ADDR
// continue ;
62440: GO 61290
// end ; end ; end ;
62442: GO 61290
62444: POP
62445: POP
// end ;
62446: LD_VAR 0 1
62450: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62451: LD_INT 0
62453: PPUSH
62454: PPUSH
62455: PPUSH
62456: PPUSH
62457: PPUSH
62458: PPUSH
// if not mc_bases then
62459: LD_EXP 23
62463: NOT
62464: IFFALSE 62468
// exit ;
62466: GO 62895
// for i = 1 to mc_bases do
62468: LD_ADDR_VAR 0 2
62472: PUSH
62473: DOUBLE
62474: LD_INT 1
62476: DEC
62477: ST_TO_ADDR
62478: LD_EXP 23
62482: PUSH
62483: FOR_TO
62484: IFFALSE 62893
// begin tmp := mc_build_upgrade [ i ] ;
62486: LD_ADDR_VAR 0 4
62490: PUSH
62491: LD_EXP 55
62495: PUSH
62496: LD_VAR 0 2
62500: ARRAY
62501: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62502: LD_ADDR_VAR 0 6
62506: PUSH
62507: LD_EXP 56
62511: PUSH
62512: LD_VAR 0 2
62516: ARRAY
62517: PPUSH
62518: LD_INT 2
62520: PUSH
62521: LD_INT 30
62523: PUSH
62524: LD_INT 6
62526: PUSH
62527: EMPTY
62528: LIST
62529: LIST
62530: PUSH
62531: LD_INT 30
62533: PUSH
62534: LD_INT 7
62536: PUSH
62537: EMPTY
62538: LIST
62539: LIST
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: LIST
62545: PPUSH
62546: CALL_OW 72
62550: ST_TO_ADDR
// if not tmp and not lab then
62551: LD_VAR 0 4
62555: NOT
62556: PUSH
62557: LD_VAR 0 6
62561: NOT
62562: AND
62563: IFFALSE 62567
// continue ;
62565: GO 62483
// if tmp then
62567: LD_VAR 0 4
62571: IFFALSE 62691
// for j in tmp do
62573: LD_ADDR_VAR 0 3
62577: PUSH
62578: LD_VAR 0 4
62582: PUSH
62583: FOR_IN
62584: IFFALSE 62689
// begin if UpgradeCost ( j ) then
62586: LD_VAR 0 3
62590: PPUSH
62591: CALL 22503 0 1
62595: IFFALSE 62687
// begin ComUpgrade ( j ) ;
62597: LD_VAR 0 3
62601: PPUSH
62602: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62606: LD_ADDR_EXP 55
62610: PUSH
62611: LD_EXP 55
62615: PPUSH
62616: LD_VAR 0 2
62620: PPUSH
62621: LD_EXP 55
62625: PUSH
62626: LD_VAR 0 2
62630: ARRAY
62631: PUSH
62632: LD_VAR 0 3
62636: DIFF
62637: PPUSH
62638: CALL_OW 1
62642: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62643: LD_ADDR_EXP 30
62647: PUSH
62648: LD_EXP 30
62652: PPUSH
62653: LD_VAR 0 2
62657: PUSH
62658: LD_EXP 30
62662: PUSH
62663: LD_VAR 0 2
62667: ARRAY
62668: PUSH
62669: LD_INT 1
62671: PLUS
62672: PUSH
62673: EMPTY
62674: LIST
62675: LIST
62676: PPUSH
62677: LD_VAR 0 3
62681: PPUSH
62682: CALL 15990 0 3
62686: ST_TO_ADDR
// end ; end ;
62687: GO 62583
62689: POP
62690: POP
// if not lab or not mc_lab_upgrade [ i ] then
62691: LD_VAR 0 6
62695: NOT
62696: PUSH
62697: LD_EXP 57
62701: PUSH
62702: LD_VAR 0 2
62706: ARRAY
62707: NOT
62708: OR
62709: IFFALSE 62713
// continue ;
62711: GO 62483
// for j in lab do
62713: LD_ADDR_VAR 0 3
62717: PUSH
62718: LD_VAR 0 6
62722: PUSH
62723: FOR_IN
62724: IFFALSE 62889
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62726: LD_VAR 0 3
62730: PPUSH
62731: CALL_OW 266
62735: PUSH
62736: LD_INT 6
62738: PUSH
62739: LD_INT 7
62741: PUSH
62742: EMPTY
62743: LIST
62744: LIST
62745: IN
62746: PUSH
62747: LD_VAR 0 3
62751: PPUSH
62752: CALL_OW 461
62756: PUSH
62757: LD_INT 1
62759: NONEQUAL
62760: AND
62761: IFFALSE 62887
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62763: LD_VAR 0 3
62767: PPUSH
62768: LD_EXP 57
62772: PUSH
62773: LD_VAR 0 2
62777: ARRAY
62778: PUSH
62779: LD_INT 1
62781: ARRAY
62782: PPUSH
62783: CALL 22708 0 2
62787: IFFALSE 62887
// begin ComCancel ( j ) ;
62789: LD_VAR 0 3
62793: PPUSH
62794: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62798: LD_VAR 0 3
62802: PPUSH
62803: LD_EXP 57
62807: PUSH
62808: LD_VAR 0 2
62812: ARRAY
62813: PUSH
62814: LD_INT 1
62816: ARRAY
62817: PPUSH
62818: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62822: LD_VAR 0 3
62826: PUSH
62827: LD_EXP 30
62831: PUSH
62832: LD_VAR 0 2
62836: ARRAY
62837: IN
62838: NOT
62839: IFFALSE 62885
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62841: LD_ADDR_EXP 30
62845: PUSH
62846: LD_EXP 30
62850: PPUSH
62851: LD_VAR 0 2
62855: PUSH
62856: LD_EXP 30
62860: PUSH
62861: LD_VAR 0 2
62865: ARRAY
62866: PUSH
62867: LD_INT 1
62869: PLUS
62870: PUSH
62871: EMPTY
62872: LIST
62873: LIST
62874: PPUSH
62875: LD_VAR 0 3
62879: PPUSH
62880: CALL 15990 0 3
62884: ST_TO_ADDR
// break ;
62885: GO 62889
// end ; end ; end ;
62887: GO 62723
62889: POP
62890: POP
// end ;
62891: GO 62483
62893: POP
62894: POP
// end ;
62895: LD_VAR 0 1
62899: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62900: LD_INT 0
62902: PPUSH
62903: PPUSH
62904: PPUSH
62905: PPUSH
62906: PPUSH
62907: PPUSH
62908: PPUSH
62909: PPUSH
62910: PPUSH
// if not mc_bases then
62911: LD_EXP 23
62915: NOT
62916: IFFALSE 62920
// exit ;
62918: GO 63325
// for i = 1 to mc_bases do
62920: LD_ADDR_VAR 0 2
62924: PUSH
62925: DOUBLE
62926: LD_INT 1
62928: DEC
62929: ST_TO_ADDR
62930: LD_EXP 23
62934: PUSH
62935: FOR_TO
62936: IFFALSE 63323
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62938: LD_EXP 31
62942: PUSH
62943: LD_VAR 0 2
62947: ARRAY
62948: NOT
62949: PUSH
62950: LD_EXP 23
62954: PUSH
62955: LD_VAR 0 2
62959: ARRAY
62960: PPUSH
62961: LD_INT 30
62963: PUSH
62964: LD_INT 3
62966: PUSH
62967: EMPTY
62968: LIST
62969: LIST
62970: PPUSH
62971: CALL_OW 72
62975: NOT
62976: OR
62977: IFFALSE 62981
// continue ;
62979: GO 62935
// busy := false ;
62981: LD_ADDR_VAR 0 8
62985: PUSH
62986: LD_INT 0
62988: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62989: LD_ADDR_VAR 0 4
62993: PUSH
62994: LD_EXP 23
62998: PUSH
62999: LD_VAR 0 2
63003: ARRAY
63004: PPUSH
63005: LD_INT 30
63007: PUSH
63008: LD_INT 3
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: PPUSH
63015: CALL_OW 72
63019: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63020: LD_ADDR_VAR 0 6
63024: PUSH
63025: LD_EXP 31
63029: PUSH
63030: LD_VAR 0 2
63034: ARRAY
63035: PPUSH
63036: LD_INT 2
63038: PUSH
63039: LD_INT 30
63041: PUSH
63042: LD_INT 32
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: PUSH
63049: LD_INT 30
63051: PUSH
63052: LD_INT 33
63054: PUSH
63055: EMPTY
63056: LIST
63057: LIST
63058: PUSH
63059: EMPTY
63060: LIST
63061: LIST
63062: LIST
63063: PPUSH
63064: CALL_OW 72
63068: ST_TO_ADDR
// if not t then
63069: LD_VAR 0 6
63073: NOT
63074: IFFALSE 63078
// continue ;
63076: GO 62935
// for j in tmp do
63078: LD_ADDR_VAR 0 3
63082: PUSH
63083: LD_VAR 0 4
63087: PUSH
63088: FOR_IN
63089: IFFALSE 63119
// if not BuildingStatus ( j ) = bs_idle then
63091: LD_VAR 0 3
63095: PPUSH
63096: CALL_OW 461
63100: PUSH
63101: LD_INT 2
63103: EQUAL
63104: NOT
63105: IFFALSE 63117
// begin busy := true ;
63107: LD_ADDR_VAR 0 8
63111: PUSH
63112: LD_INT 1
63114: ST_TO_ADDR
// break ;
63115: GO 63119
// end ;
63117: GO 63088
63119: POP
63120: POP
// if busy then
63121: LD_VAR 0 8
63125: IFFALSE 63129
// continue ;
63127: GO 62935
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63129: LD_ADDR_VAR 0 7
63133: PUSH
63134: LD_VAR 0 6
63138: PPUSH
63139: LD_INT 35
63141: PUSH
63142: LD_INT 0
63144: PUSH
63145: EMPTY
63146: LIST
63147: LIST
63148: PPUSH
63149: CALL_OW 72
63153: ST_TO_ADDR
// if tw then
63154: LD_VAR 0 7
63158: IFFALSE 63235
// begin tw := tw [ 1 ] ;
63160: LD_ADDR_VAR 0 7
63164: PUSH
63165: LD_VAR 0 7
63169: PUSH
63170: LD_INT 1
63172: ARRAY
63173: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63174: LD_ADDR_VAR 0 9
63178: PUSH
63179: LD_VAR 0 7
63183: PPUSH
63184: LD_EXP 48
63188: PUSH
63189: LD_VAR 0 2
63193: ARRAY
63194: PPUSH
63195: CALL 21000 0 2
63199: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63200: LD_EXP 62
63204: PUSH
63205: LD_VAR 0 2
63209: ARRAY
63210: IFFALSE 63233
// if not weapon in mc_allowed_tower_weapons [ i ] then
63212: LD_VAR 0 9
63216: PUSH
63217: LD_EXP 62
63221: PUSH
63222: LD_VAR 0 2
63226: ARRAY
63227: IN
63228: NOT
63229: IFFALSE 63233
// continue ;
63231: GO 62935
// end else
63233: GO 63298
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63235: LD_ADDR_VAR 0 5
63239: PUSH
63240: LD_EXP 31
63244: PUSH
63245: LD_VAR 0 2
63249: ARRAY
63250: PPUSH
63251: LD_VAR 0 4
63255: PPUSH
63256: CALL 47289 0 2
63260: ST_TO_ADDR
// if not tmp2 then
63261: LD_VAR 0 5
63265: NOT
63266: IFFALSE 63270
// continue ;
63268: GO 62935
// tw := tmp2 [ 1 ] ;
63270: LD_ADDR_VAR 0 7
63274: PUSH
63275: LD_VAR 0 5
63279: PUSH
63280: LD_INT 1
63282: ARRAY
63283: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63284: LD_ADDR_VAR 0 9
63288: PUSH
63289: LD_VAR 0 5
63293: PUSH
63294: LD_INT 2
63296: ARRAY
63297: ST_TO_ADDR
// end ; if not weapon then
63298: LD_VAR 0 9
63302: NOT
63303: IFFALSE 63307
// continue ;
63305: GO 62935
// ComPlaceWeapon ( tw , weapon ) ;
63307: LD_VAR 0 7
63311: PPUSH
63312: LD_VAR 0 9
63316: PPUSH
63317: CALL_OW 148
// end ;
63321: GO 62935
63323: POP
63324: POP
// end ;
63325: LD_VAR 0 1
63329: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63330: LD_INT 0
63332: PPUSH
63333: PPUSH
63334: PPUSH
63335: PPUSH
63336: PPUSH
63337: PPUSH
63338: PPUSH
// if not mc_bases then
63339: LD_EXP 23
63343: NOT
63344: IFFALSE 63348
// exit ;
63346: GO 64116
// for i = 1 to mc_bases do
63348: LD_ADDR_VAR 0 2
63352: PUSH
63353: DOUBLE
63354: LD_INT 1
63356: DEC
63357: ST_TO_ADDR
63358: LD_EXP 23
63362: PUSH
63363: FOR_TO
63364: IFFALSE 64114
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63366: LD_EXP 36
63370: PUSH
63371: LD_VAR 0 2
63375: ARRAY
63376: NOT
63377: PUSH
63378: LD_EXP 36
63382: PUSH
63383: LD_VAR 0 2
63387: ARRAY
63388: PUSH
63389: LD_EXP 37
63393: PUSH
63394: LD_VAR 0 2
63398: ARRAY
63399: EQUAL
63400: OR
63401: PUSH
63402: LD_EXP 46
63406: PUSH
63407: LD_VAR 0 2
63411: ARRAY
63412: OR
63413: IFFALSE 63417
// continue ;
63415: GO 63363
// if mc_miners [ i ] then
63417: LD_EXP 37
63421: PUSH
63422: LD_VAR 0 2
63426: ARRAY
63427: IFFALSE 63801
// begin for j = mc_miners [ i ] downto 1 do
63429: LD_ADDR_VAR 0 3
63433: PUSH
63434: DOUBLE
63435: LD_EXP 37
63439: PUSH
63440: LD_VAR 0 2
63444: ARRAY
63445: INC
63446: ST_TO_ADDR
63447: LD_INT 1
63449: PUSH
63450: FOR_DOWNTO
63451: IFFALSE 63799
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63453: LD_EXP 37
63457: PUSH
63458: LD_VAR 0 2
63462: ARRAY
63463: PUSH
63464: LD_VAR 0 3
63468: ARRAY
63469: PPUSH
63470: CALL_OW 301
63474: PUSH
63475: LD_EXP 37
63479: PUSH
63480: LD_VAR 0 2
63484: ARRAY
63485: PUSH
63486: LD_VAR 0 3
63490: ARRAY
63491: PPUSH
63492: CALL_OW 257
63496: PUSH
63497: LD_INT 1
63499: NONEQUAL
63500: OR
63501: IFFALSE 63564
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63503: LD_ADDR_VAR 0 5
63507: PUSH
63508: LD_EXP 37
63512: PUSH
63513: LD_VAR 0 2
63517: ARRAY
63518: PUSH
63519: LD_EXP 37
63523: PUSH
63524: LD_VAR 0 2
63528: ARRAY
63529: PUSH
63530: LD_VAR 0 3
63534: ARRAY
63535: DIFF
63536: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63537: LD_ADDR_EXP 37
63541: PUSH
63542: LD_EXP 37
63546: PPUSH
63547: LD_VAR 0 2
63551: PPUSH
63552: LD_VAR 0 5
63556: PPUSH
63557: CALL_OW 1
63561: ST_TO_ADDR
// continue ;
63562: GO 63450
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63564: LD_EXP 37
63568: PUSH
63569: LD_VAR 0 2
63573: ARRAY
63574: PUSH
63575: LD_VAR 0 3
63579: ARRAY
63580: PPUSH
63581: CALL_OW 257
63585: PUSH
63586: LD_INT 1
63588: EQUAL
63589: PUSH
63590: LD_EXP 37
63594: PUSH
63595: LD_VAR 0 2
63599: ARRAY
63600: PUSH
63601: LD_VAR 0 3
63605: ARRAY
63606: PPUSH
63607: CALL_OW 459
63611: NOT
63612: AND
63613: PUSH
63614: LD_EXP 37
63618: PUSH
63619: LD_VAR 0 2
63623: ARRAY
63624: PUSH
63625: LD_VAR 0 3
63629: ARRAY
63630: PPUSH
63631: CALL_OW 314
63635: NOT
63636: AND
63637: IFFALSE 63797
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63639: LD_EXP 37
63643: PUSH
63644: LD_VAR 0 2
63648: ARRAY
63649: PUSH
63650: LD_VAR 0 3
63654: ARRAY
63655: PPUSH
63656: CALL_OW 310
63660: IFFALSE 63683
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63662: LD_EXP 37
63666: PUSH
63667: LD_VAR 0 2
63671: ARRAY
63672: PUSH
63673: LD_VAR 0 3
63677: ARRAY
63678: PPUSH
63679: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63683: LD_EXP 37
63687: PUSH
63688: LD_VAR 0 2
63692: ARRAY
63693: PUSH
63694: LD_VAR 0 3
63698: ARRAY
63699: PPUSH
63700: CALL_OW 314
63704: NOT
63705: IFFALSE 63797
// begin r := rand ( 1 , mc_mines [ i ] ) ;
63707: LD_ADDR_VAR 0 7
63711: PUSH
63712: LD_INT 1
63714: PPUSH
63715: LD_EXP 36
63719: PUSH
63720: LD_VAR 0 2
63724: ARRAY
63725: PPUSH
63726: CALL_OW 12
63730: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
63731: LD_EXP 37
63735: PUSH
63736: LD_VAR 0 2
63740: ARRAY
63741: PUSH
63742: LD_VAR 0 3
63746: ARRAY
63747: PPUSH
63748: LD_EXP 36
63752: PUSH
63753: LD_VAR 0 2
63757: ARRAY
63758: PUSH
63759: LD_VAR 0 7
63763: ARRAY
63764: PUSH
63765: LD_INT 1
63767: ARRAY
63768: PPUSH
63769: LD_EXP 36
63773: PUSH
63774: LD_VAR 0 2
63778: ARRAY
63779: PUSH
63780: LD_VAR 0 7
63784: ARRAY
63785: PUSH
63786: LD_INT 2
63788: ARRAY
63789: PPUSH
63790: LD_INT 0
63792: PPUSH
63793: CALL_OW 193
// end ; end ; end ;
63797: GO 63450
63799: POP
63800: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63801: LD_ADDR_VAR 0 5
63805: PUSH
63806: LD_EXP 23
63810: PUSH
63811: LD_VAR 0 2
63815: ARRAY
63816: PPUSH
63817: LD_INT 2
63819: PUSH
63820: LD_INT 30
63822: PUSH
63823: LD_INT 4
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: PUSH
63830: LD_INT 30
63832: PUSH
63833: LD_INT 5
63835: PUSH
63836: EMPTY
63837: LIST
63838: LIST
63839: PUSH
63840: LD_INT 30
63842: PUSH
63843: LD_INT 32
63845: PUSH
63846: EMPTY
63847: LIST
63848: LIST
63849: PUSH
63850: EMPTY
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: PPUSH
63856: CALL_OW 72
63860: ST_TO_ADDR
// if not tmp then
63861: LD_VAR 0 5
63865: NOT
63866: IFFALSE 63870
// continue ;
63868: GO 63363
// list := [ ] ;
63870: LD_ADDR_VAR 0 6
63874: PUSH
63875: EMPTY
63876: ST_TO_ADDR
// for j in tmp do
63877: LD_ADDR_VAR 0 3
63881: PUSH
63882: LD_VAR 0 5
63886: PUSH
63887: FOR_IN
63888: IFFALSE 63957
// begin for k in UnitsInside ( j ) do
63890: LD_ADDR_VAR 0 4
63894: PUSH
63895: LD_VAR 0 3
63899: PPUSH
63900: CALL_OW 313
63904: PUSH
63905: FOR_IN
63906: IFFALSE 63953
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63908: LD_VAR 0 4
63912: PPUSH
63913: CALL_OW 257
63917: PUSH
63918: LD_INT 1
63920: EQUAL
63921: PUSH
63922: LD_VAR 0 4
63926: PPUSH
63927: CALL_OW 459
63931: NOT
63932: AND
63933: IFFALSE 63951
// list := list ^ k ;
63935: LD_ADDR_VAR 0 6
63939: PUSH
63940: LD_VAR 0 6
63944: PUSH
63945: LD_VAR 0 4
63949: ADD
63950: ST_TO_ADDR
63951: GO 63905
63953: POP
63954: POP
// end ;
63955: GO 63887
63957: POP
63958: POP
// list := list diff mc_miners [ i ] ;
63959: LD_ADDR_VAR 0 6
63963: PUSH
63964: LD_VAR 0 6
63968: PUSH
63969: LD_EXP 37
63973: PUSH
63974: LD_VAR 0 2
63978: ARRAY
63979: DIFF
63980: ST_TO_ADDR
// if not list then
63981: LD_VAR 0 6
63985: NOT
63986: IFFALSE 63990
// continue ;
63988: GO 63363
// k := mc_mines [ i ] - mc_miners [ i ] ;
63990: LD_ADDR_VAR 0 4
63994: PUSH
63995: LD_EXP 36
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: PUSH
64006: LD_EXP 37
64010: PUSH
64011: LD_VAR 0 2
64015: ARRAY
64016: MINUS
64017: ST_TO_ADDR
// if k > list then
64018: LD_VAR 0 4
64022: PUSH
64023: LD_VAR 0 6
64027: GREATER
64028: IFFALSE 64040
// k := list ;
64030: LD_ADDR_VAR 0 4
64034: PUSH
64035: LD_VAR 0 6
64039: ST_TO_ADDR
// for j = 1 to k do
64040: LD_ADDR_VAR 0 3
64044: PUSH
64045: DOUBLE
64046: LD_INT 1
64048: DEC
64049: ST_TO_ADDR
64050: LD_VAR 0 4
64054: PUSH
64055: FOR_TO
64056: IFFALSE 64110
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64058: LD_ADDR_EXP 37
64062: PUSH
64063: LD_EXP 37
64067: PPUSH
64068: LD_VAR 0 2
64072: PUSH
64073: LD_EXP 37
64077: PUSH
64078: LD_VAR 0 2
64082: ARRAY
64083: PUSH
64084: LD_INT 1
64086: PLUS
64087: PUSH
64088: EMPTY
64089: LIST
64090: LIST
64091: PPUSH
64092: LD_VAR 0 6
64096: PUSH
64097: LD_VAR 0 3
64101: ARRAY
64102: PPUSH
64103: CALL 15990 0 3
64107: ST_TO_ADDR
64108: GO 64055
64110: POP
64111: POP
// end ;
64112: GO 63363
64114: POP
64115: POP
// end ;
64116: LD_VAR 0 1
64120: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
64121: LD_INT 0
64123: PPUSH
64124: PPUSH
64125: PPUSH
64126: PPUSH
64127: PPUSH
64128: PPUSH
64129: PPUSH
64130: PPUSH
64131: PPUSH
64132: PPUSH
64133: PPUSH
// if not mc_bases then
64134: LD_EXP 23
64138: NOT
64139: IFFALSE 64143
// exit ;
64141: GO 65966
// for i = 1 to mc_bases do
64143: LD_ADDR_VAR 0 2
64147: PUSH
64148: DOUBLE
64149: LD_INT 1
64151: DEC
64152: ST_TO_ADDR
64153: LD_EXP 23
64157: PUSH
64158: FOR_TO
64159: IFFALSE 65964
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64161: LD_EXP 23
64165: PUSH
64166: LD_VAR 0 2
64170: ARRAY
64171: NOT
64172: PUSH
64173: LD_EXP 30
64177: PUSH
64178: LD_VAR 0 2
64182: ARRAY
64183: OR
64184: IFFALSE 64188
// continue ;
64186: GO 64158
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64188: LD_EXP 39
64192: PUSH
64193: LD_VAR 0 2
64197: ARRAY
64198: NOT
64199: PUSH
64200: LD_EXP 40
64204: PUSH
64205: LD_VAR 0 2
64209: ARRAY
64210: AND
64211: IFFALSE 64249
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64213: LD_ADDR_EXP 40
64217: PUSH
64218: LD_EXP 40
64222: PPUSH
64223: LD_VAR 0 2
64227: PPUSH
64228: EMPTY
64229: PPUSH
64230: CALL_OW 1
64234: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64235: LD_VAR 0 2
64239: PPUSH
64240: LD_INT 107
64242: PPUSH
64243: CALL 55017 0 2
// continue ;
64247: GO 64158
// end ; target := [ ] ;
64249: LD_ADDR_VAR 0 7
64253: PUSH
64254: EMPTY
64255: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64256: LD_ADDR_VAR 0 6
64260: PUSH
64261: LD_EXP 23
64265: PUSH
64266: LD_VAR 0 2
64270: ARRAY
64271: PUSH
64272: LD_INT 1
64274: ARRAY
64275: PPUSH
64276: CALL_OW 255
64280: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64281: LD_ADDR_VAR 0 9
64285: PUSH
64286: LD_EXP 23
64290: PUSH
64291: LD_VAR 0 2
64295: ARRAY
64296: PPUSH
64297: LD_INT 2
64299: PUSH
64300: LD_INT 30
64302: PUSH
64303: LD_INT 0
64305: PUSH
64306: EMPTY
64307: LIST
64308: LIST
64309: PUSH
64310: LD_INT 30
64312: PUSH
64313: LD_INT 1
64315: PUSH
64316: EMPTY
64317: LIST
64318: LIST
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: LIST
64324: PPUSH
64325: CALL_OW 72
64329: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64330: LD_ADDR_VAR 0 3
64334: PUSH
64335: DOUBLE
64336: LD_EXP 39
64340: PUSH
64341: LD_VAR 0 2
64345: ARRAY
64346: INC
64347: ST_TO_ADDR
64348: LD_INT 1
64350: PUSH
64351: FOR_DOWNTO
64352: IFFALSE 64597
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64354: LD_EXP 39
64358: PUSH
64359: LD_VAR 0 2
64363: ARRAY
64364: PUSH
64365: LD_VAR 0 3
64369: ARRAY
64370: PUSH
64371: LD_INT 2
64373: ARRAY
64374: PPUSH
64375: LD_EXP 39
64379: PUSH
64380: LD_VAR 0 2
64384: ARRAY
64385: PUSH
64386: LD_VAR 0 3
64390: ARRAY
64391: PUSH
64392: LD_INT 3
64394: ARRAY
64395: PPUSH
64396: CALL_OW 488
64400: PUSH
64401: LD_EXP 39
64405: PUSH
64406: LD_VAR 0 2
64410: ARRAY
64411: PUSH
64412: LD_VAR 0 3
64416: ARRAY
64417: PUSH
64418: LD_INT 2
64420: ARRAY
64421: PPUSH
64422: LD_EXP 39
64426: PUSH
64427: LD_VAR 0 2
64431: ARRAY
64432: PUSH
64433: LD_VAR 0 3
64437: ARRAY
64438: PUSH
64439: LD_INT 3
64441: ARRAY
64442: PPUSH
64443: CALL_OW 284
64447: PUSH
64448: LD_INT 0
64450: EQUAL
64451: AND
64452: IFFALSE 64507
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64454: LD_ADDR_VAR 0 5
64458: PUSH
64459: LD_EXP 39
64463: PUSH
64464: LD_VAR 0 2
64468: ARRAY
64469: PPUSH
64470: LD_VAR 0 3
64474: PPUSH
64475: CALL_OW 3
64479: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64480: LD_ADDR_EXP 39
64484: PUSH
64485: LD_EXP 39
64489: PPUSH
64490: LD_VAR 0 2
64494: PPUSH
64495: LD_VAR 0 5
64499: PPUSH
64500: CALL_OW 1
64504: ST_TO_ADDR
// continue ;
64505: GO 64351
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64507: LD_VAR 0 6
64511: PPUSH
64512: LD_EXP 39
64516: PUSH
64517: LD_VAR 0 2
64521: ARRAY
64522: PUSH
64523: LD_VAR 0 3
64527: ARRAY
64528: PUSH
64529: LD_INT 2
64531: ARRAY
64532: PPUSH
64533: LD_EXP 39
64537: PUSH
64538: LD_VAR 0 2
64542: ARRAY
64543: PUSH
64544: LD_VAR 0 3
64548: ARRAY
64549: PUSH
64550: LD_INT 3
64552: ARRAY
64553: PPUSH
64554: LD_INT 30
64556: PPUSH
64557: CALL 16886 0 4
64561: PUSH
64562: LD_INT 4
64564: ARRAY
64565: PUSH
64566: LD_INT 0
64568: EQUAL
64569: IFFALSE 64595
// begin target := mc_crates [ i ] [ j ] ;
64571: LD_ADDR_VAR 0 7
64575: PUSH
64576: LD_EXP 39
64580: PUSH
64581: LD_VAR 0 2
64585: ARRAY
64586: PUSH
64587: LD_VAR 0 3
64591: ARRAY
64592: ST_TO_ADDR
// break ;
64593: GO 64597
// end ; end ;
64595: GO 64351
64597: POP
64598: POP
// if not target then
64599: LD_VAR 0 7
64603: NOT
64604: IFFALSE 64608
// continue ;
64606: GO 64158
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64608: LD_ADDR_VAR 0 8
64612: PUSH
64613: LD_EXP 42
64617: PUSH
64618: LD_VAR 0 2
64622: ARRAY
64623: PPUSH
64624: LD_INT 2
64626: PUSH
64627: LD_INT 3
64629: PUSH
64630: LD_INT 58
64632: PUSH
64633: EMPTY
64634: LIST
64635: PUSH
64636: EMPTY
64637: LIST
64638: LIST
64639: PUSH
64640: LD_INT 61
64642: PUSH
64643: EMPTY
64644: LIST
64645: PUSH
64646: LD_INT 33
64648: PUSH
64649: LD_INT 5
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: LD_INT 33
64658: PUSH
64659: LD_INT 3
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PUSH
64666: EMPTY
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 2
64675: PUSH
64676: LD_INT 34
64678: PUSH
64679: LD_INT 32
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 34
64688: PUSH
64689: LD_INT 51
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: LD_INT 34
64698: PUSH
64699: LD_INT 12
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: PUSH
64706: EMPTY
64707: LIST
64708: LIST
64709: LIST
64710: LIST
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PPUSH
64716: CALL_OW 72
64720: ST_TO_ADDR
// if not cargo then
64721: LD_VAR 0 8
64725: NOT
64726: IFFALSE 65432
// begin if mc_crates_collector [ i ] < 5 then
64728: LD_EXP 40
64732: PUSH
64733: LD_VAR 0 2
64737: ARRAY
64738: PUSH
64739: LD_INT 5
64741: LESS
64742: IFFALSE 65108
// begin if mc_ape [ i ] then
64744: LD_EXP 52
64748: PUSH
64749: LD_VAR 0 2
64753: ARRAY
64754: IFFALSE 64801
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64756: LD_ADDR_VAR 0 5
64760: PUSH
64761: LD_EXP 52
64765: PUSH
64766: LD_VAR 0 2
64770: ARRAY
64771: PPUSH
64772: LD_INT 25
64774: PUSH
64775: LD_INT 16
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: PUSH
64782: LD_INT 24
64784: PUSH
64785: LD_INT 750
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: EMPTY
64793: LIST
64794: LIST
64795: PPUSH
64796: CALL_OW 72
64800: ST_TO_ADDR
// if not tmp then
64801: LD_VAR 0 5
64805: NOT
64806: IFFALSE 64853
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64808: LD_ADDR_VAR 0 5
64812: PUSH
64813: LD_EXP 23
64817: PUSH
64818: LD_VAR 0 2
64822: ARRAY
64823: PPUSH
64824: LD_INT 25
64826: PUSH
64827: LD_INT 2
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: LD_INT 24
64836: PUSH
64837: LD_INT 750
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: EMPTY
64845: LIST
64846: LIST
64847: PPUSH
64848: CALL_OW 72
64852: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64853: LD_EXP 52
64857: PUSH
64858: LD_VAR 0 2
64862: ARRAY
64863: PUSH
64864: LD_EXP 23
64868: PUSH
64869: LD_VAR 0 2
64873: ARRAY
64874: PPUSH
64875: LD_INT 25
64877: PUSH
64878: LD_INT 2
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 24
64887: PUSH
64888: LD_INT 750
64890: PUSH
64891: EMPTY
64892: LIST
64893: LIST
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PPUSH
64899: CALL_OW 72
64903: AND
64904: PUSH
64905: LD_VAR 0 5
64909: PUSH
64910: LD_INT 5
64912: LESS
64913: AND
64914: IFFALSE 64996
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64916: LD_ADDR_VAR 0 3
64920: PUSH
64921: LD_EXP 23
64925: PUSH
64926: LD_VAR 0 2
64930: ARRAY
64931: PPUSH
64932: LD_INT 25
64934: PUSH
64935: LD_INT 2
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 24
64944: PUSH
64945: LD_INT 750
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PPUSH
64956: CALL_OW 72
64960: PUSH
64961: FOR_IN
64962: IFFALSE 64994
// begin tmp := tmp union j ;
64964: LD_ADDR_VAR 0 5
64968: PUSH
64969: LD_VAR 0 5
64973: PUSH
64974: LD_VAR 0 3
64978: UNION
64979: ST_TO_ADDR
// if tmp >= 5 then
64980: LD_VAR 0 5
64984: PUSH
64985: LD_INT 5
64987: GREATEREQUAL
64988: IFFALSE 64992
// break ;
64990: GO 64994
// end ;
64992: GO 64961
64994: POP
64995: POP
// end ; if not tmp then
64996: LD_VAR 0 5
65000: NOT
65001: IFFALSE 65005
// continue ;
65003: GO 64158
// for j in tmp do
65005: LD_ADDR_VAR 0 3
65009: PUSH
65010: LD_VAR 0 5
65014: PUSH
65015: FOR_IN
65016: IFFALSE 65106
// if not GetTag ( j ) then
65018: LD_VAR 0 3
65022: PPUSH
65023: CALL_OW 110
65027: NOT
65028: IFFALSE 65104
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65030: LD_ADDR_EXP 40
65034: PUSH
65035: LD_EXP 40
65039: PPUSH
65040: LD_VAR 0 2
65044: PUSH
65045: LD_EXP 40
65049: PUSH
65050: LD_VAR 0 2
65054: ARRAY
65055: PUSH
65056: LD_INT 1
65058: PLUS
65059: PUSH
65060: EMPTY
65061: LIST
65062: LIST
65063: PPUSH
65064: LD_VAR 0 3
65068: PPUSH
65069: CALL 15990 0 3
65073: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65074: LD_VAR 0 3
65078: PPUSH
65079: LD_INT 107
65081: PPUSH
65082: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65086: LD_EXP 40
65090: PUSH
65091: LD_VAR 0 2
65095: ARRAY
65096: PUSH
65097: LD_INT 5
65099: GREATEREQUAL
65100: IFFALSE 65104
// break ;
65102: GO 65106
// end ;
65104: GO 65015
65106: POP
65107: POP
// end ; if mc_crates_collector [ i ] and target then
65108: LD_EXP 40
65112: PUSH
65113: LD_VAR 0 2
65117: ARRAY
65118: PUSH
65119: LD_VAR 0 7
65123: AND
65124: IFFALSE 65430
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65126: LD_EXP 40
65130: PUSH
65131: LD_VAR 0 2
65135: ARRAY
65136: PUSH
65137: LD_VAR 0 7
65141: PUSH
65142: LD_INT 1
65144: ARRAY
65145: LESS
65146: IFFALSE 65166
// tmp := mc_crates_collector [ i ] else
65148: LD_ADDR_VAR 0 5
65152: PUSH
65153: LD_EXP 40
65157: PUSH
65158: LD_VAR 0 2
65162: ARRAY
65163: ST_TO_ADDR
65164: GO 65180
// tmp := target [ 1 ] ;
65166: LD_ADDR_VAR 0 5
65170: PUSH
65171: LD_VAR 0 7
65175: PUSH
65176: LD_INT 1
65178: ARRAY
65179: ST_TO_ADDR
// k := 0 ;
65180: LD_ADDR_VAR 0 4
65184: PUSH
65185: LD_INT 0
65187: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65188: LD_ADDR_VAR 0 3
65192: PUSH
65193: LD_EXP 40
65197: PUSH
65198: LD_VAR 0 2
65202: ARRAY
65203: PUSH
65204: FOR_IN
65205: IFFALSE 65428
// begin k := k + 1 ;
65207: LD_ADDR_VAR 0 4
65211: PUSH
65212: LD_VAR 0 4
65216: PUSH
65217: LD_INT 1
65219: PLUS
65220: ST_TO_ADDR
// if k > tmp then
65221: LD_VAR 0 4
65225: PUSH
65226: LD_VAR 0 5
65230: GREATER
65231: IFFALSE 65235
// break ;
65233: GO 65428
// if not GetClass ( j ) in [ 2 , 16 ] then
65235: LD_VAR 0 3
65239: PPUSH
65240: CALL_OW 257
65244: PUSH
65245: LD_INT 2
65247: PUSH
65248: LD_INT 16
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: IN
65255: NOT
65256: IFFALSE 65309
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65258: LD_ADDR_EXP 40
65262: PUSH
65263: LD_EXP 40
65267: PPUSH
65268: LD_VAR 0 2
65272: PPUSH
65273: LD_EXP 40
65277: PUSH
65278: LD_VAR 0 2
65282: ARRAY
65283: PUSH
65284: LD_VAR 0 3
65288: DIFF
65289: PPUSH
65290: CALL_OW 1
65294: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65295: LD_VAR 0 3
65299: PPUSH
65300: LD_INT 0
65302: PPUSH
65303: CALL_OW 109
// continue ;
65307: GO 65204
// end ; if IsInUnit ( j ) then
65309: LD_VAR 0 3
65313: PPUSH
65314: CALL_OW 310
65318: IFFALSE 65329
// ComExitBuilding ( j ) ;
65320: LD_VAR 0 3
65324: PPUSH
65325: CALL_OW 122
// wait ( 3 ) ;
65329: LD_INT 3
65331: PPUSH
65332: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65336: LD_VAR 0 3
65340: PPUSH
65341: CALL_OW 314
65345: PUSH
65346: LD_VAR 0 6
65350: PPUSH
65351: LD_VAR 0 7
65355: PUSH
65356: LD_INT 2
65358: ARRAY
65359: PPUSH
65360: LD_VAR 0 7
65364: PUSH
65365: LD_INT 3
65367: ARRAY
65368: PPUSH
65369: LD_INT 30
65371: PPUSH
65372: CALL 16886 0 4
65376: PUSH
65377: LD_INT 4
65379: ARRAY
65380: AND
65381: IFFALSE 65399
// ComStandNearbyBuilding ( j , depot ) else
65383: LD_VAR 0 3
65387: PPUSH
65388: LD_VAR 0 9
65392: PPUSH
65393: CALL 12568 0 2
65397: GO 65426
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65399: LD_VAR 0 3
65403: PPUSH
65404: LD_VAR 0 7
65408: PUSH
65409: LD_INT 2
65411: ARRAY
65412: PPUSH
65413: LD_VAR 0 7
65417: PUSH
65418: LD_INT 3
65420: ARRAY
65421: PPUSH
65422: CALL_OW 117
// end ;
65426: GO 65204
65428: POP
65429: POP
// end ; end else
65430: GO 65962
// begin for j in cargo do
65432: LD_ADDR_VAR 0 3
65436: PUSH
65437: LD_VAR 0 8
65441: PUSH
65442: FOR_IN
65443: IFFALSE 65960
// begin if GetTag ( j ) <> 0 then
65445: LD_VAR 0 3
65449: PPUSH
65450: CALL_OW 110
65454: PUSH
65455: LD_INT 0
65457: NONEQUAL
65458: IFFALSE 65462
// continue ;
65460: GO 65442
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65462: LD_VAR 0 3
65466: PPUSH
65467: CALL_OW 256
65471: PUSH
65472: LD_INT 1000
65474: LESS
65475: PUSH
65476: LD_VAR 0 3
65480: PPUSH
65481: LD_EXP 47
65485: PUSH
65486: LD_VAR 0 2
65490: ARRAY
65491: PPUSH
65492: CALL_OW 308
65496: NOT
65497: AND
65498: IFFALSE 65520
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65500: LD_VAR 0 3
65504: PPUSH
65505: LD_EXP 47
65509: PUSH
65510: LD_VAR 0 2
65514: ARRAY
65515: PPUSH
65516: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65520: LD_VAR 0 3
65524: PPUSH
65525: CALL_OW 256
65529: PUSH
65530: LD_INT 1000
65532: LESS
65533: PUSH
65534: LD_VAR 0 3
65538: PPUSH
65539: LD_EXP 47
65543: PUSH
65544: LD_VAR 0 2
65548: ARRAY
65549: PPUSH
65550: CALL_OW 308
65554: AND
65555: IFFALSE 65559
// continue ;
65557: GO 65442
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65559: LD_VAR 0 3
65563: PPUSH
65564: CALL_OW 262
65568: PUSH
65569: LD_INT 2
65571: EQUAL
65572: PUSH
65573: LD_VAR 0 3
65577: PPUSH
65578: CALL_OW 261
65582: PUSH
65583: LD_INT 15
65585: LESS
65586: AND
65587: IFFALSE 65591
// continue ;
65589: GO 65442
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65591: LD_VAR 0 3
65595: PPUSH
65596: CALL_OW 262
65600: PUSH
65601: LD_INT 1
65603: EQUAL
65604: PUSH
65605: LD_VAR 0 3
65609: PPUSH
65610: CALL_OW 261
65614: PUSH
65615: LD_INT 10
65617: LESS
65618: AND
65619: IFFALSE 65899
// begin if not depot then
65621: LD_VAR 0 9
65625: NOT
65626: IFFALSE 65630
// continue ;
65628: GO 65442
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65630: LD_VAR 0 3
65634: PPUSH
65635: LD_VAR 0 9
65639: PPUSH
65640: LD_VAR 0 3
65644: PPUSH
65645: CALL_OW 74
65649: PPUSH
65650: CALL_OW 296
65654: PUSH
65655: LD_INT 6
65657: LESS
65658: IFFALSE 65674
// SetFuel ( j , 100 ) else
65660: LD_VAR 0 3
65664: PPUSH
65665: LD_INT 100
65667: PPUSH
65668: CALL_OW 240
65672: GO 65899
// if GetFuel ( j ) = 0 then
65674: LD_VAR 0 3
65678: PPUSH
65679: CALL_OW 261
65683: PUSH
65684: LD_INT 0
65686: EQUAL
65687: IFFALSE 65899
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65689: LD_ADDR_EXP 42
65693: PUSH
65694: LD_EXP 42
65698: PPUSH
65699: LD_VAR 0 2
65703: PPUSH
65704: LD_EXP 42
65708: PUSH
65709: LD_VAR 0 2
65713: ARRAY
65714: PUSH
65715: LD_VAR 0 3
65719: DIFF
65720: PPUSH
65721: CALL_OW 1
65725: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65726: LD_VAR 0 3
65730: PPUSH
65731: CALL_OW 263
65735: PUSH
65736: LD_INT 1
65738: EQUAL
65739: IFFALSE 65755
// ComExitVehicle ( IsInUnit ( j ) ) ;
65741: LD_VAR 0 3
65745: PPUSH
65746: CALL_OW 310
65750: PPUSH
65751: CALL_OW 121
// if GetControl ( j ) = control_remote then
65755: LD_VAR 0 3
65759: PPUSH
65760: CALL_OW 263
65764: PUSH
65765: LD_INT 2
65767: EQUAL
65768: IFFALSE 65779
// ComUnlink ( j ) ;
65770: LD_VAR 0 3
65774: PPUSH
65775: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65779: LD_ADDR_VAR 0 10
65783: PUSH
65784: LD_VAR 0 2
65788: PPUSH
65789: LD_INT 3
65791: PPUSH
65792: CALL 75538 0 2
65796: ST_TO_ADDR
// if fac then
65797: LD_VAR 0 10
65801: IFFALSE 65897
// begin for k in fac do
65803: LD_ADDR_VAR 0 4
65807: PUSH
65808: LD_VAR 0 10
65812: PUSH
65813: FOR_IN
65814: IFFALSE 65895
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65816: LD_ADDR_VAR 0 11
65820: PUSH
65821: LD_VAR 0 10
65825: PPUSH
65826: LD_VAR 0 3
65830: PPUSH
65831: CALL_OW 265
65835: PPUSH
65836: LD_VAR 0 3
65840: PPUSH
65841: CALL_OW 262
65845: PPUSH
65846: LD_VAR 0 3
65850: PPUSH
65851: CALL_OW 263
65855: PPUSH
65856: LD_VAR 0 3
65860: PPUSH
65861: CALL_OW 264
65865: PPUSH
65866: CALL 13486 0 5
65870: ST_TO_ADDR
// if components then
65871: LD_VAR 0 11
65875: IFFALSE 65893
// begin MC_InsertProduceList ( i , components ) ;
65877: LD_VAR 0 2
65881: PPUSH
65882: LD_VAR 0 11
65886: PPUSH
65887: CALL 75083 0 2
// break ;
65891: GO 65895
// end ; end ;
65893: GO 65813
65895: POP
65896: POP
// end ; continue ;
65897: GO 65442
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65899: LD_VAR 0 3
65903: PPUSH
65904: LD_INT 1
65906: PPUSH
65907: CALL_OW 289
65911: PUSH
65912: LD_INT 100
65914: LESS
65915: PUSH
65916: LD_VAR 0 3
65920: PPUSH
65921: CALL_OW 314
65925: NOT
65926: AND
65927: IFFALSE 65956
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65929: LD_VAR 0 3
65933: PPUSH
65934: LD_VAR 0 7
65938: PUSH
65939: LD_INT 2
65941: ARRAY
65942: PPUSH
65943: LD_VAR 0 7
65947: PUSH
65948: LD_INT 3
65950: ARRAY
65951: PPUSH
65952: CALL_OW 117
// break ;
65956: GO 65960
// end ;
65958: GO 65442
65960: POP
65961: POP
// end ; end ;
65962: GO 64158
65964: POP
65965: POP
// end ;
65966: LD_VAR 0 1
65970: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65971: LD_INT 0
65973: PPUSH
65974: PPUSH
65975: PPUSH
65976: PPUSH
// if not mc_bases then
65977: LD_EXP 23
65981: NOT
65982: IFFALSE 65986
// exit ;
65984: GO 66147
// for i = 1 to mc_bases do
65986: LD_ADDR_VAR 0 2
65990: PUSH
65991: DOUBLE
65992: LD_INT 1
65994: DEC
65995: ST_TO_ADDR
65996: LD_EXP 23
66000: PUSH
66001: FOR_TO
66002: IFFALSE 66145
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66004: LD_ADDR_VAR 0 4
66008: PUSH
66009: LD_EXP 42
66013: PUSH
66014: LD_VAR 0 2
66018: ARRAY
66019: PUSH
66020: LD_EXP 45
66024: PUSH
66025: LD_VAR 0 2
66029: ARRAY
66030: UNION
66031: PPUSH
66032: LD_INT 33
66034: PUSH
66035: LD_INT 2
66037: PUSH
66038: EMPTY
66039: LIST
66040: LIST
66041: PPUSH
66042: CALL_OW 72
66046: ST_TO_ADDR
// if tmp then
66047: LD_VAR 0 4
66051: IFFALSE 66143
// for j in tmp do
66053: LD_ADDR_VAR 0 3
66057: PUSH
66058: LD_VAR 0 4
66062: PUSH
66063: FOR_IN
66064: IFFALSE 66141
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66066: LD_VAR 0 3
66070: PPUSH
66071: CALL_OW 312
66075: NOT
66076: PUSH
66077: LD_VAR 0 3
66081: PPUSH
66082: CALL_OW 256
66086: PUSH
66087: LD_INT 250
66089: GREATEREQUAL
66090: AND
66091: IFFALSE 66104
// Connect ( j ) else
66093: LD_VAR 0 3
66097: PPUSH
66098: CALL 18961 0 1
66102: GO 66139
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66104: LD_VAR 0 3
66108: PPUSH
66109: CALL_OW 256
66113: PUSH
66114: LD_INT 250
66116: LESS
66117: PUSH
66118: LD_VAR 0 3
66122: PPUSH
66123: CALL_OW 312
66127: AND
66128: IFFALSE 66139
// ComUnlink ( j ) ;
66130: LD_VAR 0 3
66134: PPUSH
66135: CALL_OW 136
66139: GO 66063
66141: POP
66142: POP
// end ;
66143: GO 66001
66145: POP
66146: POP
// end ;
66147: LD_VAR 0 1
66151: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66152: LD_INT 0
66154: PPUSH
66155: PPUSH
66156: PPUSH
66157: PPUSH
66158: PPUSH
// if not mc_bases then
66159: LD_EXP 23
66163: NOT
66164: IFFALSE 66168
// exit ;
66166: GO 66613
// for i = 1 to mc_bases do
66168: LD_ADDR_VAR 0 2
66172: PUSH
66173: DOUBLE
66174: LD_INT 1
66176: DEC
66177: ST_TO_ADDR
66178: LD_EXP 23
66182: PUSH
66183: FOR_TO
66184: IFFALSE 66611
// begin if not mc_produce [ i ] then
66186: LD_EXP 44
66190: PUSH
66191: LD_VAR 0 2
66195: ARRAY
66196: NOT
66197: IFFALSE 66201
// continue ;
66199: GO 66183
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66201: LD_ADDR_VAR 0 5
66205: PUSH
66206: LD_EXP 23
66210: PUSH
66211: LD_VAR 0 2
66215: ARRAY
66216: PPUSH
66217: LD_INT 30
66219: PUSH
66220: LD_INT 3
66222: PUSH
66223: EMPTY
66224: LIST
66225: LIST
66226: PPUSH
66227: CALL_OW 72
66231: ST_TO_ADDR
// if not fac then
66232: LD_VAR 0 5
66236: NOT
66237: IFFALSE 66241
// continue ;
66239: GO 66183
// for j in fac do
66241: LD_ADDR_VAR 0 3
66245: PUSH
66246: LD_VAR 0 5
66250: PUSH
66251: FOR_IN
66252: IFFALSE 66607
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66254: LD_VAR 0 3
66258: PPUSH
66259: CALL_OW 461
66263: PUSH
66264: LD_INT 2
66266: NONEQUAL
66267: PUSH
66268: LD_VAR 0 3
66272: PPUSH
66273: LD_INT 15
66275: PPUSH
66276: CALL 18589 0 2
66280: PUSH
66281: LD_INT 4
66283: ARRAY
66284: OR
66285: IFFALSE 66289
// continue ;
66287: GO 66251
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66289: LD_VAR 0 3
66293: PPUSH
66294: LD_EXP 44
66298: PUSH
66299: LD_VAR 0 2
66303: ARRAY
66304: PUSH
66305: LD_INT 1
66307: ARRAY
66308: PUSH
66309: LD_INT 1
66311: ARRAY
66312: PPUSH
66313: LD_EXP 44
66317: PUSH
66318: LD_VAR 0 2
66322: ARRAY
66323: PUSH
66324: LD_INT 1
66326: ARRAY
66327: PUSH
66328: LD_INT 2
66330: ARRAY
66331: PPUSH
66332: LD_EXP 44
66336: PUSH
66337: LD_VAR 0 2
66341: ARRAY
66342: PUSH
66343: LD_INT 1
66345: ARRAY
66346: PUSH
66347: LD_INT 3
66349: ARRAY
66350: PPUSH
66351: LD_EXP 44
66355: PUSH
66356: LD_VAR 0 2
66360: ARRAY
66361: PUSH
66362: LD_INT 1
66364: ARRAY
66365: PUSH
66366: LD_INT 4
66368: ARRAY
66369: PPUSH
66370: CALL_OW 448
66374: PUSH
66375: LD_VAR 0 3
66379: PPUSH
66380: LD_EXP 44
66384: PUSH
66385: LD_VAR 0 2
66389: ARRAY
66390: PUSH
66391: LD_INT 1
66393: ARRAY
66394: PUSH
66395: LD_INT 1
66397: ARRAY
66398: PUSH
66399: LD_EXP 44
66403: PUSH
66404: LD_VAR 0 2
66408: ARRAY
66409: PUSH
66410: LD_INT 1
66412: ARRAY
66413: PUSH
66414: LD_INT 2
66416: ARRAY
66417: PUSH
66418: LD_EXP 44
66422: PUSH
66423: LD_VAR 0 2
66427: ARRAY
66428: PUSH
66429: LD_INT 1
66431: ARRAY
66432: PUSH
66433: LD_INT 3
66435: ARRAY
66436: PUSH
66437: LD_EXP 44
66441: PUSH
66442: LD_VAR 0 2
66446: ARRAY
66447: PUSH
66448: LD_INT 1
66450: ARRAY
66451: PUSH
66452: LD_INT 4
66454: ARRAY
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: LIST
66460: LIST
66461: PPUSH
66462: CALL 22356 0 2
66466: AND
66467: IFFALSE 66605
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66469: LD_VAR 0 3
66473: PPUSH
66474: LD_EXP 44
66478: PUSH
66479: LD_VAR 0 2
66483: ARRAY
66484: PUSH
66485: LD_INT 1
66487: ARRAY
66488: PUSH
66489: LD_INT 1
66491: ARRAY
66492: PPUSH
66493: LD_EXP 44
66497: PUSH
66498: LD_VAR 0 2
66502: ARRAY
66503: PUSH
66504: LD_INT 1
66506: ARRAY
66507: PUSH
66508: LD_INT 2
66510: ARRAY
66511: PPUSH
66512: LD_EXP 44
66516: PUSH
66517: LD_VAR 0 2
66521: ARRAY
66522: PUSH
66523: LD_INT 1
66525: ARRAY
66526: PUSH
66527: LD_INT 3
66529: ARRAY
66530: PPUSH
66531: LD_EXP 44
66535: PUSH
66536: LD_VAR 0 2
66540: ARRAY
66541: PUSH
66542: LD_INT 1
66544: ARRAY
66545: PUSH
66546: LD_INT 4
66548: ARRAY
66549: PPUSH
66550: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66554: LD_ADDR_VAR 0 4
66558: PUSH
66559: LD_EXP 44
66563: PUSH
66564: LD_VAR 0 2
66568: ARRAY
66569: PPUSH
66570: LD_INT 1
66572: PPUSH
66573: CALL_OW 3
66577: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66578: LD_ADDR_EXP 44
66582: PUSH
66583: LD_EXP 44
66587: PPUSH
66588: LD_VAR 0 2
66592: PPUSH
66593: LD_VAR 0 4
66597: PPUSH
66598: CALL_OW 1
66602: ST_TO_ADDR
// break ;
66603: GO 66607
// end ; end ;
66605: GO 66251
66607: POP
66608: POP
// end ;
66609: GO 66183
66611: POP
66612: POP
// end ;
66613: LD_VAR 0 1
66617: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66618: LD_INT 0
66620: PPUSH
66621: PPUSH
66622: PPUSH
// if not mc_bases then
66623: LD_EXP 23
66627: NOT
66628: IFFALSE 66632
// exit ;
66630: GO 66721
// for i = 1 to mc_bases do
66632: LD_ADDR_VAR 0 2
66636: PUSH
66637: DOUBLE
66638: LD_INT 1
66640: DEC
66641: ST_TO_ADDR
66642: LD_EXP 23
66646: PUSH
66647: FOR_TO
66648: IFFALSE 66719
// begin if mc_attack [ i ] then
66650: LD_EXP 43
66654: PUSH
66655: LD_VAR 0 2
66659: ARRAY
66660: IFFALSE 66717
// begin tmp := mc_attack [ i ] [ 1 ] ;
66662: LD_ADDR_VAR 0 3
66666: PUSH
66667: LD_EXP 43
66671: PUSH
66672: LD_VAR 0 2
66676: ARRAY
66677: PUSH
66678: LD_INT 1
66680: ARRAY
66681: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66682: LD_ADDR_EXP 43
66686: PUSH
66687: LD_EXP 43
66691: PPUSH
66692: LD_VAR 0 2
66696: PPUSH
66697: EMPTY
66698: PPUSH
66699: CALL_OW 1
66703: ST_TO_ADDR
// Attack ( tmp ) ;
66704: LD_VAR 0 3
66708: PPUSH
66709: CALL 81657 0 1
// exit ;
66713: POP
66714: POP
66715: GO 66721
// end ; end ;
66717: GO 66647
66719: POP
66720: POP
// end ;
66721: LD_VAR 0 1
66725: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66726: LD_INT 0
66728: PPUSH
66729: PPUSH
66730: PPUSH
66731: PPUSH
66732: PPUSH
66733: PPUSH
66734: PPUSH
// if not mc_bases then
66735: LD_EXP 23
66739: NOT
66740: IFFALSE 66744
// exit ;
66742: GO 67601
// for i = 1 to mc_bases do
66744: LD_ADDR_VAR 0 2
66748: PUSH
66749: DOUBLE
66750: LD_INT 1
66752: DEC
66753: ST_TO_ADDR
66754: LD_EXP 23
66758: PUSH
66759: FOR_TO
66760: IFFALSE 67599
// begin if not mc_bases [ i ] then
66762: LD_EXP 23
66766: PUSH
66767: LD_VAR 0 2
66771: ARRAY
66772: NOT
66773: IFFALSE 66777
// continue ;
66775: GO 66759
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66777: LD_ADDR_VAR 0 7
66781: PUSH
66782: LD_EXP 23
66786: PUSH
66787: LD_VAR 0 2
66791: ARRAY
66792: PUSH
66793: LD_INT 1
66795: ARRAY
66796: PPUSH
66797: CALL 12790 0 1
66801: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66802: LD_ADDR_EXP 46
66806: PUSH
66807: LD_EXP 46
66811: PPUSH
66812: LD_VAR 0 2
66816: PPUSH
66817: LD_EXP 23
66821: PUSH
66822: LD_VAR 0 2
66826: ARRAY
66827: PUSH
66828: LD_INT 1
66830: ARRAY
66831: PPUSH
66832: CALL_OW 255
66836: PPUSH
66837: LD_EXP 48
66841: PUSH
66842: LD_VAR 0 2
66846: ARRAY
66847: PPUSH
66848: CALL 12755 0 2
66852: PPUSH
66853: CALL_OW 1
66857: ST_TO_ADDR
// if not mc_scan [ i ] then
66858: LD_EXP 46
66862: PUSH
66863: LD_VAR 0 2
66867: ARRAY
66868: NOT
66869: IFFALSE 67047
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
66871: LD_ADDR_EXP 66
66875: PUSH
66876: LD_EXP 66
66880: PPUSH
66881: LD_VAR 0 2
66885: PPUSH
66886: LD_INT 0
66888: PPUSH
66889: CALL_OW 1
66893: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66894: LD_ADDR_VAR 0 4
66898: PUSH
66899: LD_EXP 23
66903: PUSH
66904: LD_VAR 0 2
66908: ARRAY
66909: PPUSH
66910: LD_INT 2
66912: PUSH
66913: LD_INT 25
66915: PUSH
66916: LD_INT 5
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: LD_INT 25
66925: PUSH
66926: LD_INT 8
66928: PUSH
66929: EMPTY
66930: LIST
66931: LIST
66932: PUSH
66933: LD_INT 25
66935: PUSH
66936: LD_INT 9
66938: PUSH
66939: EMPTY
66940: LIST
66941: LIST
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: LIST
66947: LIST
66948: PPUSH
66949: CALL_OW 72
66953: ST_TO_ADDR
// if not tmp then
66954: LD_VAR 0 4
66958: NOT
66959: IFFALSE 66963
// continue ;
66961: GO 66759
// for j in tmp do
66963: LD_ADDR_VAR 0 3
66967: PUSH
66968: LD_VAR 0 4
66972: PUSH
66973: FOR_IN
66974: IFFALSE 67045
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66976: LD_VAR 0 3
66980: PPUSH
66981: CALL_OW 310
66985: PPUSH
66986: CALL_OW 266
66990: PUSH
66991: LD_INT 5
66993: EQUAL
66994: PUSH
66995: LD_VAR 0 3
66999: PPUSH
67000: CALL_OW 257
67004: PUSH
67005: LD_INT 1
67007: EQUAL
67008: AND
67009: PUSH
67010: LD_VAR 0 3
67014: PPUSH
67015: CALL_OW 459
67019: NOT
67020: AND
67021: PUSH
67022: LD_VAR 0 7
67026: AND
67027: IFFALSE 67043
// ComChangeProfession ( j , class ) ;
67029: LD_VAR 0 3
67033: PPUSH
67034: LD_VAR 0 7
67038: PPUSH
67039: CALL_OW 123
67043: GO 66973
67045: POP
67046: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
67047: LD_EXP 46
67051: PUSH
67052: LD_VAR 0 2
67056: ARRAY
67057: PUSH
67058: LD_EXP 66
67062: PUSH
67063: LD_VAR 0 2
67067: ARRAY
67068: NOT
67069: AND
67070: PUSH
67071: LD_EXP 45
67075: PUSH
67076: LD_VAR 0 2
67080: ARRAY
67081: NOT
67082: AND
67083: PUSH
67084: LD_EXP 23
67088: PUSH
67089: LD_VAR 0 2
67093: ARRAY
67094: PPUSH
67095: LD_INT 50
67097: PUSH
67098: EMPTY
67099: LIST
67100: PUSH
67101: LD_INT 2
67103: PUSH
67104: LD_INT 30
67106: PUSH
67107: LD_INT 32
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: LD_INT 30
67116: PUSH
67117: LD_INT 33
67119: PUSH
67120: EMPTY
67121: LIST
67122: LIST
67123: PUSH
67124: LD_INT 30
67126: PUSH
67127: LD_INT 4
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 30
67136: PUSH
67137: LD_INT 5
67139: PUSH
67140: EMPTY
67141: LIST
67142: LIST
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: LIST
67148: LIST
67149: LIST
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PPUSH
67155: CALL_OW 72
67159: PUSH
67160: LD_INT 4
67162: LESS
67163: PUSH
67164: LD_EXP 23
67168: PUSH
67169: LD_VAR 0 2
67173: ARRAY
67174: PPUSH
67175: LD_INT 3
67177: PUSH
67178: LD_INT 24
67180: PUSH
67181: LD_INT 1000
67183: PUSH
67184: EMPTY
67185: LIST
67186: LIST
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PUSH
67192: LD_INT 2
67194: PUSH
67195: LD_INT 30
67197: PUSH
67198: LD_INT 0
67200: PUSH
67201: EMPTY
67202: LIST
67203: LIST
67204: PUSH
67205: LD_INT 30
67207: PUSH
67208: LD_INT 1
67210: PUSH
67211: EMPTY
67212: LIST
67213: LIST
67214: PUSH
67215: EMPTY
67216: LIST
67217: LIST
67218: LIST
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PPUSH
67224: CALL_OW 72
67228: OR
67229: AND
67230: IFFALSE 67481
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67232: LD_ADDR_EXP 66
67236: PUSH
67237: LD_EXP 66
67241: PPUSH
67242: LD_VAR 0 2
67246: PPUSH
67247: LD_INT 1
67249: PPUSH
67250: CALL_OW 1
67254: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67255: LD_ADDR_VAR 0 4
67259: PUSH
67260: LD_EXP 23
67264: PUSH
67265: LD_VAR 0 2
67269: ARRAY
67270: PPUSH
67271: LD_INT 2
67273: PUSH
67274: LD_INT 25
67276: PUSH
67277: LD_INT 1
67279: PUSH
67280: EMPTY
67281: LIST
67282: LIST
67283: PUSH
67284: LD_INT 25
67286: PUSH
67287: LD_INT 5
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: LD_INT 25
67296: PUSH
67297: LD_INT 8
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: PUSH
67304: LD_INT 25
67306: PUSH
67307: LD_INT 9
67309: PUSH
67310: EMPTY
67311: LIST
67312: LIST
67313: PUSH
67314: EMPTY
67315: LIST
67316: LIST
67317: LIST
67318: LIST
67319: LIST
67320: PPUSH
67321: CALL_OW 72
67325: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67326: LD_ADDR_VAR 0 4
67330: PUSH
67331: LD_VAR 0 4
67335: PUSH
67336: LD_VAR 0 4
67340: PPUSH
67341: LD_INT 18
67343: PPUSH
67344: CALL 45259 0 2
67348: DIFF
67349: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67350: LD_VAR 0 4
67354: NOT
67355: PUSH
67356: LD_EXP 23
67360: PUSH
67361: LD_VAR 0 2
67365: ARRAY
67366: PPUSH
67367: LD_INT 2
67369: PUSH
67370: LD_INT 30
67372: PUSH
67373: LD_INT 4
67375: PUSH
67376: EMPTY
67377: LIST
67378: LIST
67379: PUSH
67380: LD_INT 30
67382: PUSH
67383: LD_INT 5
67385: PUSH
67386: EMPTY
67387: LIST
67388: LIST
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: LIST
67394: PPUSH
67395: CALL_OW 72
67399: NOT
67400: AND
67401: IFFALSE 67463
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67403: LD_ADDR_VAR 0 4
67407: PUSH
67408: LD_EXP 23
67412: PUSH
67413: LD_VAR 0 2
67417: ARRAY
67418: PPUSH
67419: LD_INT 2
67421: PUSH
67422: LD_INT 25
67424: PUSH
67425: LD_INT 2
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: LD_INT 25
67434: PUSH
67435: LD_INT 3
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 25
67444: PUSH
67445: LD_INT 4
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: LIST
67456: LIST
67457: PPUSH
67458: CALL_OW 72
67462: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67463: LD_VAR 0 2
67467: PPUSH
67468: LD_VAR 0 4
67472: PPUSH
67473: CALL 86366 0 2
// exit ;
67477: POP
67478: POP
67479: GO 67601
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67481: LD_EXP 46
67485: PUSH
67486: LD_VAR 0 2
67490: ARRAY
67491: PUSH
67492: LD_EXP 66
67496: PUSH
67497: LD_VAR 0 2
67501: ARRAY
67502: NOT
67503: AND
67504: PUSH
67505: LD_EXP 45
67509: PUSH
67510: LD_VAR 0 2
67514: ARRAY
67515: AND
67516: IFFALSE 67597
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67518: LD_ADDR_EXP 66
67522: PUSH
67523: LD_EXP 66
67527: PPUSH
67528: LD_VAR 0 2
67532: PPUSH
67533: LD_INT 1
67535: PPUSH
67536: CALL_OW 1
67540: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67541: LD_ADDR_VAR 0 4
67545: PUSH
67546: LD_EXP 45
67550: PUSH
67551: LD_VAR 0 2
67555: ARRAY
67556: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67557: LD_ADDR_EXP 45
67561: PUSH
67562: LD_EXP 45
67566: PPUSH
67567: LD_VAR 0 2
67571: PPUSH
67572: EMPTY
67573: PPUSH
67574: CALL_OW 1
67578: ST_TO_ADDR
// Defend ( i , tmp ) ;
67579: LD_VAR 0 2
67583: PPUSH
67584: LD_VAR 0 4
67588: PPUSH
67589: CALL 86962 0 2
// exit ;
67593: POP
67594: POP
67595: GO 67601
// end ; end ;
67597: GO 66759
67599: POP
67600: POP
// end ;
67601: LD_VAR 0 1
67605: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67606: LD_INT 0
67608: PPUSH
67609: PPUSH
67610: PPUSH
67611: PPUSH
67612: PPUSH
67613: PPUSH
67614: PPUSH
67615: PPUSH
67616: PPUSH
67617: PPUSH
67618: PPUSH
// if not mc_bases then
67619: LD_EXP 23
67623: NOT
67624: IFFALSE 67628
// exit ;
67626: GO 68715
// for i = 1 to mc_bases do
67628: LD_ADDR_VAR 0 2
67632: PUSH
67633: DOUBLE
67634: LD_INT 1
67636: DEC
67637: ST_TO_ADDR
67638: LD_EXP 23
67642: PUSH
67643: FOR_TO
67644: IFFALSE 68713
// begin tmp := mc_lab [ i ] ;
67646: LD_ADDR_VAR 0 6
67650: PUSH
67651: LD_EXP 56
67655: PUSH
67656: LD_VAR 0 2
67660: ARRAY
67661: ST_TO_ADDR
// if not tmp then
67662: LD_VAR 0 6
67666: NOT
67667: IFFALSE 67671
// continue ;
67669: GO 67643
// idle_lab := 0 ;
67671: LD_ADDR_VAR 0 11
67675: PUSH
67676: LD_INT 0
67678: ST_TO_ADDR
// for j in tmp do
67679: LD_ADDR_VAR 0 3
67683: PUSH
67684: LD_VAR 0 6
67688: PUSH
67689: FOR_IN
67690: IFFALSE 68709
// begin researching := false ;
67692: LD_ADDR_VAR 0 10
67696: PUSH
67697: LD_INT 0
67699: ST_TO_ADDR
// side := GetSide ( j ) ;
67700: LD_ADDR_VAR 0 4
67704: PUSH
67705: LD_VAR 0 3
67709: PPUSH
67710: CALL_OW 255
67714: ST_TO_ADDR
// if not mc_tech [ side ] then
67715: LD_EXP 50
67719: PUSH
67720: LD_VAR 0 4
67724: ARRAY
67725: NOT
67726: IFFALSE 67730
// continue ;
67728: GO 67689
// if BuildingStatus ( j ) = bs_idle then
67730: LD_VAR 0 3
67734: PPUSH
67735: CALL_OW 461
67739: PUSH
67740: LD_INT 2
67742: EQUAL
67743: IFFALSE 67931
// begin if idle_lab and UnitsInside ( j ) < 6 then
67745: LD_VAR 0 11
67749: PUSH
67750: LD_VAR 0 3
67754: PPUSH
67755: CALL_OW 313
67759: PUSH
67760: LD_INT 6
67762: LESS
67763: AND
67764: IFFALSE 67835
// begin tmp2 := UnitsInside ( idle_lab ) ;
67766: LD_ADDR_VAR 0 9
67770: PUSH
67771: LD_VAR 0 11
67775: PPUSH
67776: CALL_OW 313
67780: ST_TO_ADDR
// if tmp2 then
67781: LD_VAR 0 9
67785: IFFALSE 67827
// for x in tmp2 do
67787: LD_ADDR_VAR 0 7
67791: PUSH
67792: LD_VAR 0 9
67796: PUSH
67797: FOR_IN
67798: IFFALSE 67825
// begin ComExitBuilding ( x ) ;
67800: LD_VAR 0 7
67804: PPUSH
67805: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67809: LD_VAR 0 7
67813: PPUSH
67814: LD_VAR 0 3
67818: PPUSH
67819: CALL_OW 180
// end ;
67823: GO 67797
67825: POP
67826: POP
// idle_lab := 0 ;
67827: LD_ADDR_VAR 0 11
67831: PUSH
67832: LD_INT 0
67834: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67835: LD_ADDR_VAR 0 5
67839: PUSH
67840: LD_EXP 50
67844: PUSH
67845: LD_VAR 0 4
67849: ARRAY
67850: PUSH
67851: FOR_IN
67852: IFFALSE 67912
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67854: LD_VAR 0 3
67858: PPUSH
67859: LD_VAR 0 5
67863: PPUSH
67864: CALL_OW 430
67868: PUSH
67869: LD_VAR 0 4
67873: PPUSH
67874: LD_VAR 0 5
67878: PPUSH
67879: CALL 11860 0 2
67883: AND
67884: IFFALSE 67910
// begin researching := true ;
67886: LD_ADDR_VAR 0 10
67890: PUSH
67891: LD_INT 1
67893: ST_TO_ADDR
// ComResearch ( j , t ) ;
67894: LD_VAR 0 3
67898: PPUSH
67899: LD_VAR 0 5
67903: PPUSH
67904: CALL_OW 124
// break ;
67908: GO 67912
// end ;
67910: GO 67851
67912: POP
67913: POP
// if not researching then
67914: LD_VAR 0 10
67918: NOT
67919: IFFALSE 67931
// idle_lab := j ;
67921: LD_ADDR_VAR 0 11
67925: PUSH
67926: LD_VAR 0 3
67930: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67931: LD_VAR 0 3
67935: PPUSH
67936: CALL_OW 461
67940: PUSH
67941: LD_INT 10
67943: EQUAL
67944: IFFALSE 68532
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67946: LD_EXP 52
67950: PUSH
67951: LD_VAR 0 2
67955: ARRAY
67956: NOT
67957: PUSH
67958: LD_EXP 53
67962: PUSH
67963: LD_VAR 0 2
67967: ARRAY
67968: NOT
67969: AND
67970: PUSH
67971: LD_EXP 50
67975: PUSH
67976: LD_VAR 0 4
67980: ARRAY
67981: PUSH
67982: LD_INT 1
67984: GREATER
67985: AND
67986: IFFALSE 68117
// begin ComCancel ( j ) ;
67988: LD_VAR 0 3
67992: PPUSH
67993: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67997: LD_ADDR_EXP 50
68001: PUSH
68002: LD_EXP 50
68006: PPUSH
68007: LD_VAR 0 4
68011: PPUSH
68012: LD_EXP 50
68016: PUSH
68017: LD_VAR 0 4
68021: ARRAY
68022: PPUSH
68023: LD_EXP 50
68027: PUSH
68028: LD_VAR 0 4
68032: ARRAY
68033: PUSH
68034: LD_INT 1
68036: MINUS
68037: PPUSH
68038: LD_EXP 50
68042: PUSH
68043: LD_VAR 0 4
68047: ARRAY
68048: PPUSH
68049: LD_INT 0
68051: PPUSH
68052: CALL 15408 0 4
68056: PPUSH
68057: CALL_OW 1
68061: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68062: LD_ADDR_EXP 50
68066: PUSH
68067: LD_EXP 50
68071: PPUSH
68072: LD_VAR 0 4
68076: PPUSH
68077: LD_EXP 50
68081: PUSH
68082: LD_VAR 0 4
68086: ARRAY
68087: PPUSH
68088: LD_EXP 50
68092: PUSH
68093: LD_VAR 0 4
68097: ARRAY
68098: PPUSH
68099: LD_INT 1
68101: PPUSH
68102: LD_INT 0
68104: PPUSH
68105: CALL 15408 0 4
68109: PPUSH
68110: CALL_OW 1
68114: ST_TO_ADDR
// continue ;
68115: GO 67689
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68117: LD_EXP 52
68121: PUSH
68122: LD_VAR 0 2
68126: ARRAY
68127: PUSH
68128: LD_EXP 53
68132: PUSH
68133: LD_VAR 0 2
68137: ARRAY
68138: NOT
68139: AND
68140: IFFALSE 68267
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68142: LD_ADDR_EXP 53
68146: PUSH
68147: LD_EXP 53
68151: PPUSH
68152: LD_VAR 0 2
68156: PUSH
68157: LD_EXP 53
68161: PUSH
68162: LD_VAR 0 2
68166: ARRAY
68167: PUSH
68168: LD_INT 1
68170: PLUS
68171: PUSH
68172: EMPTY
68173: LIST
68174: LIST
68175: PPUSH
68176: LD_EXP 52
68180: PUSH
68181: LD_VAR 0 2
68185: ARRAY
68186: PUSH
68187: LD_INT 1
68189: ARRAY
68190: PPUSH
68191: CALL 15990 0 3
68195: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68196: LD_EXP 52
68200: PUSH
68201: LD_VAR 0 2
68205: ARRAY
68206: PUSH
68207: LD_INT 1
68209: ARRAY
68210: PPUSH
68211: LD_INT 112
68213: PPUSH
68214: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68218: LD_ADDR_VAR 0 9
68222: PUSH
68223: LD_EXP 52
68227: PUSH
68228: LD_VAR 0 2
68232: ARRAY
68233: PPUSH
68234: LD_INT 1
68236: PPUSH
68237: CALL_OW 3
68241: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68242: LD_ADDR_EXP 52
68246: PUSH
68247: LD_EXP 52
68251: PPUSH
68252: LD_VAR 0 2
68256: PPUSH
68257: LD_VAR 0 9
68261: PPUSH
68262: CALL_OW 1
68266: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68267: LD_EXP 52
68271: PUSH
68272: LD_VAR 0 2
68276: ARRAY
68277: PUSH
68278: LD_EXP 53
68282: PUSH
68283: LD_VAR 0 2
68287: ARRAY
68288: AND
68289: PUSH
68290: LD_EXP 53
68294: PUSH
68295: LD_VAR 0 2
68299: ARRAY
68300: PUSH
68301: LD_INT 1
68303: ARRAY
68304: PPUSH
68305: CALL_OW 310
68309: NOT
68310: AND
68311: PUSH
68312: LD_VAR 0 3
68316: PPUSH
68317: CALL_OW 313
68321: PUSH
68322: LD_INT 6
68324: EQUAL
68325: AND
68326: IFFALSE 68382
// begin tmp2 := UnitsInside ( j ) ;
68328: LD_ADDR_VAR 0 9
68332: PUSH
68333: LD_VAR 0 3
68337: PPUSH
68338: CALL_OW 313
68342: ST_TO_ADDR
// if tmp2 = 6 then
68343: LD_VAR 0 9
68347: PUSH
68348: LD_INT 6
68350: EQUAL
68351: IFFALSE 68382
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68353: LD_VAR 0 9
68357: PUSH
68358: LD_INT 1
68360: ARRAY
68361: PPUSH
68362: LD_INT 112
68364: PPUSH
68365: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68369: LD_VAR 0 9
68373: PUSH
68374: LD_INT 1
68376: ARRAY
68377: PPUSH
68378: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68382: LD_EXP 53
68386: PUSH
68387: LD_VAR 0 2
68391: ARRAY
68392: PUSH
68393: LD_EXP 53
68397: PUSH
68398: LD_VAR 0 2
68402: ARRAY
68403: PUSH
68404: LD_INT 1
68406: ARRAY
68407: PPUSH
68408: CALL_OW 314
68412: NOT
68413: AND
68414: PUSH
68415: LD_EXP 53
68419: PUSH
68420: LD_VAR 0 2
68424: ARRAY
68425: PUSH
68426: LD_INT 1
68428: ARRAY
68429: PPUSH
68430: CALL_OW 310
68434: NOT
68435: AND
68436: IFFALSE 68462
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68438: LD_EXP 53
68442: PUSH
68443: LD_VAR 0 2
68447: ARRAY
68448: PUSH
68449: LD_INT 1
68451: ARRAY
68452: PPUSH
68453: LD_VAR 0 3
68457: PPUSH
68458: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68462: LD_EXP 53
68466: PUSH
68467: LD_VAR 0 2
68471: ARRAY
68472: PUSH
68473: LD_INT 1
68475: ARRAY
68476: PPUSH
68477: CALL_OW 310
68481: PUSH
68482: LD_EXP 53
68486: PUSH
68487: LD_VAR 0 2
68491: ARRAY
68492: PUSH
68493: LD_INT 1
68495: ARRAY
68496: PPUSH
68497: CALL_OW 310
68501: PPUSH
68502: CALL_OW 461
68506: PUSH
68507: LD_INT 3
68509: NONEQUAL
68510: AND
68511: IFFALSE 68532
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68513: LD_EXP 53
68517: PUSH
68518: LD_VAR 0 2
68522: ARRAY
68523: PUSH
68524: LD_INT 1
68526: ARRAY
68527: PPUSH
68528: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68532: LD_VAR 0 3
68536: PPUSH
68537: CALL_OW 461
68541: PUSH
68542: LD_INT 6
68544: EQUAL
68545: PUSH
68546: LD_VAR 0 6
68550: PUSH
68551: LD_INT 1
68553: GREATER
68554: AND
68555: IFFALSE 68707
// begin sci := [ ] ;
68557: LD_ADDR_VAR 0 8
68561: PUSH
68562: EMPTY
68563: ST_TO_ADDR
// for x in ( tmp diff j ) do
68564: LD_ADDR_VAR 0 7
68568: PUSH
68569: LD_VAR 0 6
68573: PUSH
68574: LD_VAR 0 3
68578: DIFF
68579: PUSH
68580: FOR_IN
68581: IFFALSE 68633
// begin if sci = 6 then
68583: LD_VAR 0 8
68587: PUSH
68588: LD_INT 6
68590: EQUAL
68591: IFFALSE 68595
// break ;
68593: GO 68633
// if BuildingStatus ( x ) = bs_idle then
68595: LD_VAR 0 7
68599: PPUSH
68600: CALL_OW 461
68604: PUSH
68605: LD_INT 2
68607: EQUAL
68608: IFFALSE 68631
// sci := sci ^ UnitsInside ( x ) ;
68610: LD_ADDR_VAR 0 8
68614: PUSH
68615: LD_VAR 0 8
68619: PUSH
68620: LD_VAR 0 7
68624: PPUSH
68625: CALL_OW 313
68629: ADD
68630: ST_TO_ADDR
// end ;
68631: GO 68580
68633: POP
68634: POP
// if not sci then
68635: LD_VAR 0 8
68639: NOT
68640: IFFALSE 68644
// continue ;
68642: GO 67689
// for x in sci do
68644: LD_ADDR_VAR 0 7
68648: PUSH
68649: LD_VAR 0 8
68653: PUSH
68654: FOR_IN
68655: IFFALSE 68705
// if IsInUnit ( x ) and not HasTask ( x ) then
68657: LD_VAR 0 7
68661: PPUSH
68662: CALL_OW 310
68666: PUSH
68667: LD_VAR 0 7
68671: PPUSH
68672: CALL_OW 314
68676: NOT
68677: AND
68678: IFFALSE 68703
// begin ComExitBuilding ( x ) ;
68680: LD_VAR 0 7
68684: PPUSH
68685: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68689: LD_VAR 0 7
68693: PPUSH
68694: LD_VAR 0 3
68698: PPUSH
68699: CALL_OW 180
// end ;
68703: GO 68654
68705: POP
68706: POP
// end ; end ;
68707: GO 67689
68709: POP
68710: POP
// end ;
68711: GO 67643
68713: POP
68714: POP
// end ;
68715: LD_VAR 0 1
68719: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68720: LD_INT 0
68722: PPUSH
68723: PPUSH
// if not mc_bases then
68724: LD_EXP 23
68728: NOT
68729: IFFALSE 68733
// exit ;
68731: GO 68814
// for i = 1 to mc_bases do
68733: LD_ADDR_VAR 0 2
68737: PUSH
68738: DOUBLE
68739: LD_INT 1
68741: DEC
68742: ST_TO_ADDR
68743: LD_EXP 23
68747: PUSH
68748: FOR_TO
68749: IFFALSE 68812
// if mc_mines [ i ] and mc_miners [ i ] then
68751: LD_EXP 36
68755: PUSH
68756: LD_VAR 0 2
68760: ARRAY
68761: PUSH
68762: LD_EXP 37
68766: PUSH
68767: LD_VAR 0 2
68771: ARRAY
68772: AND
68773: IFFALSE 68810
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68775: LD_EXP 37
68779: PUSH
68780: LD_VAR 0 2
68784: ARRAY
68785: PUSH
68786: LD_INT 1
68788: ARRAY
68789: PPUSH
68790: CALL_OW 255
68794: PPUSH
68795: LD_EXP 36
68799: PUSH
68800: LD_VAR 0 2
68804: ARRAY
68805: PPUSH
68806: CALL 12943 0 2
68810: GO 68748
68812: POP
68813: POP
// end ;
68814: LD_VAR 0 1
68818: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
68819: LD_INT 0
68821: PPUSH
68822: PPUSH
68823: PPUSH
68824: PPUSH
68825: PPUSH
68826: PPUSH
68827: PPUSH
68828: PPUSH
// if not mc_bases or not mc_parking then
68829: LD_EXP 23
68833: NOT
68834: PUSH
68835: LD_EXP 47
68839: NOT
68840: OR
68841: IFFALSE 68845
// exit ;
68843: GO 69555
// for i = 1 to mc_bases do
68845: LD_ADDR_VAR 0 2
68849: PUSH
68850: DOUBLE
68851: LD_INT 1
68853: DEC
68854: ST_TO_ADDR
68855: LD_EXP 23
68859: PUSH
68860: FOR_TO
68861: IFFALSE 69553
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68863: LD_EXP 23
68867: PUSH
68868: LD_VAR 0 2
68872: ARRAY
68873: NOT
68874: PUSH
68875: LD_EXP 47
68879: PUSH
68880: LD_VAR 0 2
68884: ARRAY
68885: NOT
68886: OR
68887: IFFALSE 68891
// continue ;
68889: GO 68860
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68891: LD_ADDR_VAR 0 5
68895: PUSH
68896: LD_EXP 23
68900: PUSH
68901: LD_VAR 0 2
68905: ARRAY
68906: PUSH
68907: LD_INT 1
68909: ARRAY
68910: PPUSH
68911: CALL_OW 255
68915: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68916: LD_ADDR_VAR 0 6
68920: PUSH
68921: LD_EXP 23
68925: PUSH
68926: LD_VAR 0 2
68930: ARRAY
68931: PPUSH
68932: LD_INT 30
68934: PUSH
68935: LD_INT 3
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PPUSH
68942: CALL_OW 72
68946: ST_TO_ADDR
// if not fac then
68947: LD_VAR 0 6
68951: NOT
68952: IFFALSE 69003
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68954: LD_ADDR_VAR 0 6
68958: PUSH
68959: LD_EXP 23
68963: PUSH
68964: LD_VAR 0 2
68968: ARRAY
68969: PPUSH
68970: LD_INT 2
68972: PUSH
68973: LD_INT 30
68975: PUSH
68976: LD_INT 0
68978: PUSH
68979: EMPTY
68980: LIST
68981: LIST
68982: PUSH
68983: LD_INT 30
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: LIST
68997: PPUSH
68998: CALL_OW 72
69002: ST_TO_ADDR
// if not fac then
69003: LD_VAR 0 6
69007: NOT
69008: IFFALSE 69012
// continue ;
69010: GO 68860
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69012: LD_ADDR_VAR 0 7
69016: PUSH
69017: LD_EXP 47
69021: PUSH
69022: LD_VAR 0 2
69026: ARRAY
69027: PPUSH
69028: LD_INT 22
69030: PUSH
69031: LD_VAR 0 5
69035: PUSH
69036: EMPTY
69037: LIST
69038: LIST
69039: PUSH
69040: LD_INT 21
69042: PUSH
69043: LD_INT 2
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: PUSH
69050: LD_INT 3
69052: PUSH
69053: LD_INT 24
69055: PUSH
69056: LD_INT 1000
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: LIST
69071: PPUSH
69072: CALL_OW 70
69076: ST_TO_ADDR
// for j in fac do
69077: LD_ADDR_VAR 0 3
69081: PUSH
69082: LD_VAR 0 6
69086: PUSH
69087: FOR_IN
69088: IFFALSE 69169
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69090: LD_ADDR_VAR 0 7
69094: PUSH
69095: LD_VAR 0 7
69099: PUSH
69100: LD_INT 22
69102: PUSH
69103: LD_VAR 0 5
69107: PUSH
69108: EMPTY
69109: LIST
69110: LIST
69111: PUSH
69112: LD_INT 91
69114: PUSH
69115: LD_VAR 0 3
69119: PUSH
69120: LD_INT 15
69122: PUSH
69123: EMPTY
69124: LIST
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 21
69130: PUSH
69131: LD_INT 2
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 3
69140: PUSH
69141: LD_INT 24
69143: PUSH
69144: LD_INT 1000
69146: PUSH
69147: EMPTY
69148: LIST
69149: LIST
69150: PUSH
69151: EMPTY
69152: LIST
69153: LIST
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: LIST
69159: LIST
69160: PPUSH
69161: CALL_OW 69
69165: UNION
69166: ST_TO_ADDR
69167: GO 69087
69169: POP
69170: POP
// if not vehs then
69171: LD_VAR 0 7
69175: NOT
69176: IFFALSE 69202
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69178: LD_ADDR_EXP 35
69182: PUSH
69183: LD_EXP 35
69187: PPUSH
69188: LD_VAR 0 2
69192: PPUSH
69193: EMPTY
69194: PPUSH
69195: CALL_OW 1
69199: ST_TO_ADDR
// continue ;
69200: GO 68860
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69202: LD_ADDR_VAR 0 8
69206: PUSH
69207: LD_EXP 23
69211: PUSH
69212: LD_VAR 0 2
69216: ARRAY
69217: PPUSH
69218: LD_INT 30
69220: PUSH
69221: LD_INT 3
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PPUSH
69228: CALL_OW 72
69232: ST_TO_ADDR
// if tmp then
69233: LD_VAR 0 8
69237: IFFALSE 69340
// begin for j in tmp do
69239: LD_ADDR_VAR 0 3
69243: PUSH
69244: LD_VAR 0 8
69248: PUSH
69249: FOR_IN
69250: IFFALSE 69338
// for k in UnitsInside ( j ) do
69252: LD_ADDR_VAR 0 4
69256: PUSH
69257: LD_VAR 0 3
69261: PPUSH
69262: CALL_OW 313
69266: PUSH
69267: FOR_IN
69268: IFFALSE 69334
// if k then
69270: LD_VAR 0 4
69274: IFFALSE 69332
// if not k in mc_repair_vehicle [ i ] then
69276: LD_VAR 0 4
69280: PUSH
69281: LD_EXP 35
69285: PUSH
69286: LD_VAR 0 2
69290: ARRAY
69291: IN
69292: NOT
69293: IFFALSE 69332
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69295: LD_ADDR_EXP 35
69299: PUSH
69300: LD_EXP 35
69304: PPUSH
69305: LD_VAR 0 2
69309: PPUSH
69310: LD_EXP 35
69314: PUSH
69315: LD_VAR 0 2
69319: ARRAY
69320: PUSH
69321: LD_VAR 0 4
69325: UNION
69326: PPUSH
69327: CALL_OW 1
69331: ST_TO_ADDR
69332: GO 69267
69334: POP
69335: POP
69336: GO 69249
69338: POP
69339: POP
// end ; if not mc_repair_vehicle [ i ] then
69340: LD_EXP 35
69344: PUSH
69345: LD_VAR 0 2
69349: ARRAY
69350: NOT
69351: IFFALSE 69355
// continue ;
69353: GO 68860
// for j in mc_repair_vehicle [ i ] do
69355: LD_ADDR_VAR 0 3
69359: PUSH
69360: LD_EXP 35
69364: PUSH
69365: LD_VAR 0 2
69369: ARRAY
69370: PUSH
69371: FOR_IN
69372: IFFALSE 69549
// begin if GetClass ( j ) <> 3 then
69374: LD_VAR 0 3
69378: PPUSH
69379: CALL_OW 257
69383: PUSH
69384: LD_INT 3
69386: NONEQUAL
69387: IFFALSE 69428
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69389: LD_ADDR_EXP 35
69393: PUSH
69394: LD_EXP 35
69398: PPUSH
69399: LD_VAR 0 2
69403: PPUSH
69404: LD_EXP 35
69408: PUSH
69409: LD_VAR 0 2
69413: ARRAY
69414: PUSH
69415: LD_VAR 0 3
69419: DIFF
69420: PPUSH
69421: CALL_OW 1
69425: ST_TO_ADDR
// continue ;
69426: GO 69371
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69428: LD_VAR 0 3
69432: PPUSH
69433: CALL_OW 311
69437: NOT
69438: PUSH
69439: LD_VAR 0 3
69443: PUSH
69444: LD_EXP 26
69448: PUSH
69449: LD_VAR 0 2
69453: ARRAY
69454: PUSH
69455: LD_INT 1
69457: ARRAY
69458: IN
69459: NOT
69460: AND
69461: PUSH
69462: LD_VAR 0 3
69466: PUSH
69467: LD_EXP 26
69471: PUSH
69472: LD_VAR 0 2
69476: ARRAY
69477: PUSH
69478: LD_INT 2
69480: ARRAY
69481: IN
69482: NOT
69483: AND
69484: IFFALSE 69547
// begin if IsInUnit ( j ) then
69486: LD_VAR 0 3
69490: PPUSH
69491: CALL_OW 310
69495: IFFALSE 69508
// ComExitBuilding ( j ) else
69497: LD_VAR 0 3
69501: PPUSH
69502: CALL_OW 122
69506: GO 69547
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69508: LD_VAR 0 3
69512: PPUSH
69513: LD_VAR 0 7
69517: PUSH
69518: LD_INT 1
69520: ARRAY
69521: PPUSH
69522: CALL 49754 0 2
69526: NOT
69527: IFFALSE 69547
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69529: LD_VAR 0 3
69533: PPUSH
69534: LD_VAR 0 7
69538: PUSH
69539: LD_INT 1
69541: ARRAY
69542: PPUSH
69543: CALL_OW 129
// end ; end ;
69547: GO 69371
69549: POP
69550: POP
// end ;
69551: GO 68860
69553: POP
69554: POP
// end ;
69555: LD_VAR 0 1
69559: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69560: LD_INT 0
69562: PPUSH
69563: PPUSH
69564: PPUSH
69565: PPUSH
69566: PPUSH
69567: PPUSH
69568: PPUSH
69569: PPUSH
69570: PPUSH
69571: PPUSH
69572: PPUSH
// if not mc_bases then
69573: LD_EXP 23
69577: NOT
69578: IFFALSE 69582
// exit ;
69580: GO 70384
// for i = 1 to mc_bases do
69582: LD_ADDR_VAR 0 2
69586: PUSH
69587: DOUBLE
69588: LD_INT 1
69590: DEC
69591: ST_TO_ADDR
69592: LD_EXP 23
69596: PUSH
69597: FOR_TO
69598: IFFALSE 70382
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69600: LD_EXP 51
69604: PUSH
69605: LD_VAR 0 2
69609: ARRAY
69610: NOT
69611: PUSH
69612: LD_EXP 26
69616: PUSH
69617: LD_VAR 0 2
69621: ARRAY
69622: PUSH
69623: LD_INT 1
69625: ARRAY
69626: OR
69627: PUSH
69628: LD_EXP 26
69632: PUSH
69633: LD_VAR 0 2
69637: ARRAY
69638: PUSH
69639: LD_INT 2
69641: ARRAY
69642: OR
69643: PUSH
69644: LD_EXP 49
69648: PUSH
69649: LD_VAR 0 2
69653: ARRAY
69654: PPUSH
69655: LD_INT 1
69657: PPUSH
69658: CALL_OW 325
69662: NOT
69663: OR
69664: PUSH
69665: LD_EXP 46
69669: PUSH
69670: LD_VAR 0 2
69674: ARRAY
69675: OR
69676: IFFALSE 69680
// continue ;
69678: GO 69597
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69680: LD_ADDR_VAR 0 8
69684: PUSH
69685: LD_EXP 23
69689: PUSH
69690: LD_VAR 0 2
69694: ARRAY
69695: PPUSH
69696: LD_INT 25
69698: PUSH
69699: LD_INT 4
69701: PUSH
69702: EMPTY
69703: LIST
69704: LIST
69705: PUSH
69706: LD_INT 50
69708: PUSH
69709: EMPTY
69710: LIST
69711: PUSH
69712: LD_INT 3
69714: PUSH
69715: LD_INT 60
69717: PUSH
69718: EMPTY
69719: LIST
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: LIST
69729: PPUSH
69730: CALL_OW 72
69734: PUSH
69735: LD_EXP 27
69739: PUSH
69740: LD_VAR 0 2
69744: ARRAY
69745: DIFF
69746: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69747: LD_ADDR_VAR 0 9
69751: PUSH
69752: LD_EXP 23
69756: PUSH
69757: LD_VAR 0 2
69761: ARRAY
69762: PPUSH
69763: LD_INT 2
69765: PUSH
69766: LD_INT 30
69768: PUSH
69769: LD_INT 0
69771: PUSH
69772: EMPTY
69773: LIST
69774: LIST
69775: PUSH
69776: LD_INT 30
69778: PUSH
69779: LD_INT 1
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: PUSH
69786: EMPTY
69787: LIST
69788: LIST
69789: LIST
69790: PPUSH
69791: CALL_OW 72
69795: ST_TO_ADDR
// if not tmp or not dep then
69796: LD_VAR 0 8
69800: NOT
69801: PUSH
69802: LD_VAR 0 9
69806: NOT
69807: OR
69808: IFFALSE 69812
// continue ;
69810: GO 69597
// side := GetSide ( tmp [ 1 ] ) ;
69812: LD_ADDR_VAR 0 11
69816: PUSH
69817: LD_VAR 0 8
69821: PUSH
69822: LD_INT 1
69824: ARRAY
69825: PPUSH
69826: CALL_OW 255
69830: ST_TO_ADDR
// dep := dep [ 1 ] ;
69831: LD_ADDR_VAR 0 9
69835: PUSH
69836: LD_VAR 0 9
69840: PUSH
69841: LD_INT 1
69843: ARRAY
69844: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
69845: LD_ADDR_VAR 0 7
69849: PUSH
69850: LD_EXP 51
69854: PUSH
69855: LD_VAR 0 2
69859: ARRAY
69860: PPUSH
69861: LD_INT 22
69863: PUSH
69864: LD_INT 0
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 25
69873: PUSH
69874: LD_INT 12
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PPUSH
69885: CALL_OW 70
69889: PUSH
69890: LD_INT 22
69892: PUSH
69893: LD_INT 0
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 25
69902: PUSH
69903: LD_INT 12
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 91
69912: PUSH
69913: LD_VAR 0 9
69917: PUSH
69918: LD_INT 20
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: LIST
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: LIST
69930: PPUSH
69931: CALL_OW 69
69935: UNION
69936: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69937: LD_ADDR_VAR 0 10
69941: PUSH
69942: LD_EXP 51
69946: PUSH
69947: LD_VAR 0 2
69951: ARRAY
69952: PPUSH
69953: LD_INT 81
69955: PUSH
69956: LD_VAR 0 11
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PPUSH
69965: CALL_OW 70
69969: ST_TO_ADDR
// if not apes or danger_at_area then
69970: LD_VAR 0 7
69974: NOT
69975: PUSH
69976: LD_VAR 0 10
69980: OR
69981: IFFALSE 70031
// begin if mc_taming [ i ] then
69983: LD_EXP 54
69987: PUSH
69988: LD_VAR 0 2
69992: ARRAY
69993: IFFALSE 70029
// begin MC_Reset ( i , 121 ) ;
69995: LD_VAR 0 2
69999: PPUSH
70000: LD_INT 121
70002: PPUSH
70003: CALL 55017 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70007: LD_ADDR_EXP 54
70011: PUSH
70012: LD_EXP 54
70016: PPUSH
70017: LD_VAR 0 2
70021: PPUSH
70022: EMPTY
70023: PPUSH
70024: CALL_OW 1
70028: ST_TO_ADDR
// end ; continue ;
70029: GO 69597
// end ; for j in tmp do
70031: LD_ADDR_VAR 0 3
70035: PUSH
70036: LD_VAR 0 8
70040: PUSH
70041: FOR_IN
70042: IFFALSE 70378
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70044: LD_VAR 0 3
70048: PUSH
70049: LD_EXP 54
70053: PUSH
70054: LD_VAR 0 2
70058: ARRAY
70059: IN
70060: NOT
70061: PUSH
70062: LD_EXP 54
70066: PUSH
70067: LD_VAR 0 2
70071: ARRAY
70072: PUSH
70073: LD_INT 3
70075: LESS
70076: AND
70077: IFFALSE 70135
// begin SetTag ( j , 121 ) ;
70079: LD_VAR 0 3
70083: PPUSH
70084: LD_INT 121
70086: PPUSH
70087: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70091: LD_ADDR_EXP 54
70095: PUSH
70096: LD_EXP 54
70100: PPUSH
70101: LD_VAR 0 2
70105: PUSH
70106: LD_EXP 54
70110: PUSH
70111: LD_VAR 0 2
70115: ARRAY
70116: PUSH
70117: LD_INT 1
70119: PLUS
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PPUSH
70125: LD_VAR 0 3
70129: PPUSH
70130: CALL 15990 0 3
70134: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70135: LD_VAR 0 3
70139: PUSH
70140: LD_EXP 54
70144: PUSH
70145: LD_VAR 0 2
70149: ARRAY
70150: IN
70151: IFFALSE 70376
// begin if GetClass ( j ) <> 4 then
70153: LD_VAR 0 3
70157: PPUSH
70158: CALL_OW 257
70162: PUSH
70163: LD_INT 4
70165: NONEQUAL
70166: IFFALSE 70219
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70168: LD_ADDR_EXP 54
70172: PUSH
70173: LD_EXP 54
70177: PPUSH
70178: LD_VAR 0 2
70182: PPUSH
70183: LD_EXP 54
70187: PUSH
70188: LD_VAR 0 2
70192: ARRAY
70193: PUSH
70194: LD_VAR 0 3
70198: DIFF
70199: PPUSH
70200: CALL_OW 1
70204: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70205: LD_VAR 0 3
70209: PPUSH
70210: LD_INT 0
70212: PPUSH
70213: CALL_OW 109
// continue ;
70217: GO 70041
// end ; if IsInUnit ( j ) then
70219: LD_VAR 0 3
70223: PPUSH
70224: CALL_OW 310
70228: IFFALSE 70239
// ComExitBuilding ( j ) ;
70230: LD_VAR 0 3
70234: PPUSH
70235: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70239: LD_ADDR_VAR 0 6
70243: PUSH
70244: LD_VAR 0 7
70248: PPUSH
70249: LD_VAR 0 3
70253: PPUSH
70254: CALL_OW 74
70258: ST_TO_ADDR
// if not ape then
70259: LD_VAR 0 6
70263: NOT
70264: IFFALSE 70268
// break ;
70266: GO 70378
// x := GetX ( ape ) ;
70268: LD_ADDR_VAR 0 4
70272: PUSH
70273: LD_VAR 0 6
70277: PPUSH
70278: CALL_OW 250
70282: ST_TO_ADDR
// y := GetY ( ape ) ;
70283: LD_ADDR_VAR 0 5
70287: PUSH
70288: LD_VAR 0 6
70292: PPUSH
70293: CALL_OW 251
70297: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70298: LD_VAR 0 4
70302: PPUSH
70303: LD_VAR 0 5
70307: PPUSH
70308: CALL_OW 488
70312: NOT
70313: PUSH
70314: LD_VAR 0 11
70318: PPUSH
70319: LD_VAR 0 4
70323: PPUSH
70324: LD_VAR 0 5
70328: PPUSH
70329: LD_INT 20
70331: PPUSH
70332: CALL 16886 0 4
70336: PUSH
70337: LD_INT 4
70339: ARRAY
70340: OR
70341: IFFALSE 70345
// break ;
70343: GO 70378
// if not HasTask ( j ) then
70345: LD_VAR 0 3
70349: PPUSH
70350: CALL_OW 314
70354: NOT
70355: IFFALSE 70376
// ComTameXY ( j , x , y ) ;
70357: LD_VAR 0 3
70361: PPUSH
70362: LD_VAR 0 4
70366: PPUSH
70367: LD_VAR 0 5
70371: PPUSH
70372: CALL_OW 131
// end ; end ;
70376: GO 70041
70378: POP
70379: POP
// end ;
70380: GO 69597
70382: POP
70383: POP
// end ;
70384: LD_VAR 0 1
70388: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70389: LD_INT 0
70391: PPUSH
70392: PPUSH
70393: PPUSH
70394: PPUSH
70395: PPUSH
70396: PPUSH
70397: PPUSH
70398: PPUSH
// if not mc_bases then
70399: LD_EXP 23
70403: NOT
70404: IFFALSE 70408
// exit ;
70406: GO 71034
// for i = 1 to mc_bases do
70408: LD_ADDR_VAR 0 2
70412: PUSH
70413: DOUBLE
70414: LD_INT 1
70416: DEC
70417: ST_TO_ADDR
70418: LD_EXP 23
70422: PUSH
70423: FOR_TO
70424: IFFALSE 71032
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70426: LD_EXP 52
70430: PUSH
70431: LD_VAR 0 2
70435: ARRAY
70436: NOT
70437: PUSH
70438: LD_EXP 52
70442: PUSH
70443: LD_VAR 0 2
70447: ARRAY
70448: PPUSH
70449: LD_INT 25
70451: PUSH
70452: LD_INT 12
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PPUSH
70459: CALL_OW 72
70463: NOT
70464: OR
70465: IFFALSE 70469
// continue ;
70467: GO 70423
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70469: LD_ADDR_VAR 0 5
70473: PUSH
70474: LD_EXP 52
70478: PUSH
70479: LD_VAR 0 2
70483: ARRAY
70484: PUSH
70485: LD_INT 1
70487: ARRAY
70488: PPUSH
70489: CALL_OW 255
70493: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70494: LD_VAR 0 5
70498: PPUSH
70499: LD_INT 2
70501: PPUSH
70502: CALL_OW 325
70506: IFFALSE 70759
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70508: LD_ADDR_VAR 0 4
70512: PUSH
70513: LD_EXP 52
70517: PUSH
70518: LD_VAR 0 2
70522: ARRAY
70523: PPUSH
70524: LD_INT 25
70526: PUSH
70527: LD_INT 16
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PPUSH
70534: CALL_OW 72
70538: ST_TO_ADDR
// if tmp < 6 then
70539: LD_VAR 0 4
70543: PUSH
70544: LD_INT 6
70546: LESS
70547: IFFALSE 70759
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70549: LD_ADDR_VAR 0 6
70553: PUSH
70554: LD_EXP 23
70558: PUSH
70559: LD_VAR 0 2
70563: ARRAY
70564: PPUSH
70565: LD_INT 2
70567: PUSH
70568: LD_INT 30
70570: PUSH
70571: LD_INT 0
70573: PUSH
70574: EMPTY
70575: LIST
70576: LIST
70577: PUSH
70578: LD_INT 30
70580: PUSH
70581: LD_INT 1
70583: PUSH
70584: EMPTY
70585: LIST
70586: LIST
70587: PUSH
70588: EMPTY
70589: LIST
70590: LIST
70591: LIST
70592: PPUSH
70593: CALL_OW 72
70597: ST_TO_ADDR
// if depot then
70598: LD_VAR 0 6
70602: IFFALSE 70759
// begin selected := 0 ;
70604: LD_ADDR_VAR 0 7
70608: PUSH
70609: LD_INT 0
70611: ST_TO_ADDR
// for j in depot do
70612: LD_ADDR_VAR 0 3
70616: PUSH
70617: LD_VAR 0 6
70621: PUSH
70622: FOR_IN
70623: IFFALSE 70654
// begin if UnitsInside ( j ) < 6 then
70625: LD_VAR 0 3
70629: PPUSH
70630: CALL_OW 313
70634: PUSH
70635: LD_INT 6
70637: LESS
70638: IFFALSE 70652
// begin selected := j ;
70640: LD_ADDR_VAR 0 7
70644: PUSH
70645: LD_VAR 0 3
70649: ST_TO_ADDR
// break ;
70650: GO 70654
// end ; end ;
70652: GO 70622
70654: POP
70655: POP
// if selected then
70656: LD_VAR 0 7
70660: IFFALSE 70759
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70662: LD_ADDR_VAR 0 3
70666: PUSH
70667: LD_EXP 52
70671: PUSH
70672: LD_VAR 0 2
70676: ARRAY
70677: PPUSH
70678: LD_INT 25
70680: PUSH
70681: LD_INT 12
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PPUSH
70688: CALL_OW 72
70692: PUSH
70693: FOR_IN
70694: IFFALSE 70757
// if not HasTask ( j ) then
70696: LD_VAR 0 3
70700: PPUSH
70701: CALL_OW 314
70705: NOT
70706: IFFALSE 70755
// begin if not IsInUnit ( j ) then
70708: LD_VAR 0 3
70712: PPUSH
70713: CALL_OW 310
70717: NOT
70718: IFFALSE 70734
// ComEnterUnit ( j , selected ) ;
70720: LD_VAR 0 3
70724: PPUSH
70725: LD_VAR 0 7
70729: PPUSH
70730: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70734: LD_VAR 0 3
70738: PPUSH
70739: LD_INT 16
70741: PPUSH
70742: CALL_OW 183
// AddComExitBuilding ( j ) ;
70746: LD_VAR 0 3
70750: PPUSH
70751: CALL_OW 182
// end ;
70755: GO 70693
70757: POP
70758: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70759: LD_VAR 0 5
70763: PPUSH
70764: LD_INT 11
70766: PPUSH
70767: CALL_OW 325
70771: IFFALSE 71030
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70773: LD_ADDR_VAR 0 4
70777: PUSH
70778: LD_EXP 52
70782: PUSH
70783: LD_VAR 0 2
70787: ARRAY
70788: PPUSH
70789: LD_INT 25
70791: PUSH
70792: LD_INT 16
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PPUSH
70799: CALL_OW 72
70803: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70804: LD_VAR 0 4
70808: PUSH
70809: LD_INT 6
70811: GREATEREQUAL
70812: PUSH
70813: LD_VAR 0 5
70817: PPUSH
70818: LD_INT 2
70820: PPUSH
70821: CALL_OW 325
70825: NOT
70826: OR
70827: IFFALSE 71030
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70829: LD_ADDR_VAR 0 8
70833: PUSH
70834: LD_EXP 23
70838: PUSH
70839: LD_VAR 0 2
70843: ARRAY
70844: PPUSH
70845: LD_INT 2
70847: PUSH
70848: LD_INT 30
70850: PUSH
70851: LD_INT 4
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 30
70860: PUSH
70861: LD_INT 5
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: EMPTY
70869: LIST
70870: LIST
70871: LIST
70872: PPUSH
70873: CALL_OW 72
70877: ST_TO_ADDR
// if barracks then
70878: LD_VAR 0 8
70882: IFFALSE 71030
// begin selected := 0 ;
70884: LD_ADDR_VAR 0 7
70888: PUSH
70889: LD_INT 0
70891: ST_TO_ADDR
// for j in barracks do
70892: LD_ADDR_VAR 0 3
70896: PUSH
70897: LD_VAR 0 8
70901: PUSH
70902: FOR_IN
70903: IFFALSE 70934
// begin if UnitsInside ( j ) < 6 then
70905: LD_VAR 0 3
70909: PPUSH
70910: CALL_OW 313
70914: PUSH
70915: LD_INT 6
70917: LESS
70918: IFFALSE 70932
// begin selected := j ;
70920: LD_ADDR_VAR 0 7
70924: PUSH
70925: LD_VAR 0 3
70929: ST_TO_ADDR
// break ;
70930: GO 70934
// end ; end ;
70932: GO 70902
70934: POP
70935: POP
// if selected then
70936: LD_VAR 0 7
70940: IFFALSE 71030
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70942: LD_ADDR_VAR 0 3
70946: PUSH
70947: LD_EXP 52
70951: PUSH
70952: LD_VAR 0 2
70956: ARRAY
70957: PPUSH
70958: LD_INT 25
70960: PUSH
70961: LD_INT 12
70963: PUSH
70964: EMPTY
70965: LIST
70966: LIST
70967: PPUSH
70968: CALL_OW 72
70972: PUSH
70973: FOR_IN
70974: IFFALSE 71028
// if not IsInUnit ( j ) and not HasTask ( j ) then
70976: LD_VAR 0 3
70980: PPUSH
70981: CALL_OW 310
70985: NOT
70986: PUSH
70987: LD_VAR 0 3
70991: PPUSH
70992: CALL_OW 314
70996: NOT
70997: AND
70998: IFFALSE 71026
// begin ComEnterUnit ( j , selected ) ;
71000: LD_VAR 0 3
71004: PPUSH
71005: LD_VAR 0 7
71009: PPUSH
71010: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71014: LD_VAR 0 3
71018: PPUSH
71019: LD_INT 15
71021: PPUSH
71022: CALL_OW 183
// end ;
71026: GO 70973
71028: POP
71029: POP
// end ; end ; end ; end ; end ;
71030: GO 70423
71032: POP
71033: POP
// end ;
71034: LD_VAR 0 1
71038: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71039: LD_INT 0
71041: PPUSH
71042: PPUSH
71043: PPUSH
71044: PPUSH
// if not mc_bases then
71045: LD_EXP 23
71049: NOT
71050: IFFALSE 71054
// exit ;
71052: GO 71232
// for i = 1 to mc_bases do
71054: LD_ADDR_VAR 0 2
71058: PUSH
71059: DOUBLE
71060: LD_INT 1
71062: DEC
71063: ST_TO_ADDR
71064: LD_EXP 23
71068: PUSH
71069: FOR_TO
71070: IFFALSE 71230
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71072: LD_ADDR_VAR 0 4
71076: PUSH
71077: LD_EXP 23
71081: PUSH
71082: LD_VAR 0 2
71086: ARRAY
71087: PPUSH
71088: LD_INT 25
71090: PUSH
71091: LD_INT 9
71093: PUSH
71094: EMPTY
71095: LIST
71096: LIST
71097: PPUSH
71098: CALL_OW 72
71102: ST_TO_ADDR
// if not tmp then
71103: LD_VAR 0 4
71107: NOT
71108: IFFALSE 71112
// continue ;
71110: GO 71069
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71112: LD_EXP 49
71116: PUSH
71117: LD_VAR 0 2
71121: ARRAY
71122: PPUSH
71123: LD_INT 29
71125: PPUSH
71126: CALL_OW 325
71130: NOT
71131: PUSH
71132: LD_EXP 49
71136: PUSH
71137: LD_VAR 0 2
71141: ARRAY
71142: PPUSH
71143: LD_INT 28
71145: PPUSH
71146: CALL_OW 325
71150: NOT
71151: AND
71152: IFFALSE 71156
// continue ;
71154: GO 71069
// for j in tmp do
71156: LD_ADDR_VAR 0 3
71160: PUSH
71161: LD_VAR 0 4
71165: PUSH
71166: FOR_IN
71167: IFFALSE 71226
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71169: LD_VAR 0 3
71173: PUSH
71174: LD_EXP 26
71178: PUSH
71179: LD_VAR 0 2
71183: ARRAY
71184: PUSH
71185: LD_INT 1
71187: ARRAY
71188: IN
71189: NOT
71190: PUSH
71191: LD_VAR 0 3
71195: PUSH
71196: LD_EXP 26
71200: PUSH
71201: LD_VAR 0 2
71205: ARRAY
71206: PUSH
71207: LD_INT 2
71209: ARRAY
71210: IN
71211: NOT
71212: AND
71213: IFFALSE 71224
// ComSpaceTimeShoot ( j ) ;
71215: LD_VAR 0 3
71219: PPUSH
71220: CALL 11951 0 1
71224: GO 71166
71226: POP
71227: POP
// end ;
71228: GO 71069
71230: POP
71231: POP
// end ;
71232: LD_VAR 0 1
71236: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71237: LD_INT 0
71239: PPUSH
71240: PPUSH
71241: PPUSH
71242: PPUSH
71243: PPUSH
71244: PPUSH
71245: PPUSH
71246: PPUSH
71247: PPUSH
// if not mc_bases then
71248: LD_EXP 23
71252: NOT
71253: IFFALSE 71257
// exit ;
71255: GO 71879
// for i = 1 to mc_bases do
71257: LD_ADDR_VAR 0 2
71261: PUSH
71262: DOUBLE
71263: LD_INT 1
71265: DEC
71266: ST_TO_ADDR
71267: LD_EXP 23
71271: PUSH
71272: FOR_TO
71273: IFFALSE 71877
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71275: LD_EXP 58
71279: PUSH
71280: LD_VAR 0 2
71284: ARRAY
71285: NOT
71286: PUSH
71287: LD_INT 38
71289: PPUSH
71290: LD_EXP 49
71294: PUSH
71295: LD_VAR 0 2
71299: ARRAY
71300: PPUSH
71301: CALL_OW 321
71305: PUSH
71306: LD_INT 2
71308: NONEQUAL
71309: OR
71310: IFFALSE 71314
// continue ;
71312: GO 71272
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71314: LD_ADDR_VAR 0 8
71318: PUSH
71319: LD_EXP 23
71323: PUSH
71324: LD_VAR 0 2
71328: ARRAY
71329: PPUSH
71330: LD_INT 30
71332: PUSH
71333: LD_INT 34
71335: PUSH
71336: EMPTY
71337: LIST
71338: LIST
71339: PPUSH
71340: CALL_OW 72
71344: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71345: LD_ADDR_VAR 0 9
71349: PUSH
71350: LD_EXP 23
71354: PUSH
71355: LD_VAR 0 2
71359: ARRAY
71360: PPUSH
71361: LD_INT 25
71363: PUSH
71364: LD_INT 4
71366: PUSH
71367: EMPTY
71368: LIST
71369: LIST
71370: PPUSH
71371: CALL_OW 72
71375: PPUSH
71376: LD_INT 0
71378: PPUSH
71379: CALL 45259 0 2
71383: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71384: LD_VAR 0 9
71388: NOT
71389: PUSH
71390: LD_VAR 0 8
71394: NOT
71395: OR
71396: PUSH
71397: LD_EXP 23
71401: PUSH
71402: LD_VAR 0 2
71406: ARRAY
71407: PPUSH
71408: LD_INT 124
71410: PPUSH
71411: CALL 45259 0 2
71415: OR
71416: IFFALSE 71420
// continue ;
71418: GO 71272
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71420: LD_EXP 59
71424: PUSH
71425: LD_VAR 0 2
71429: ARRAY
71430: PUSH
71431: LD_EXP 58
71435: PUSH
71436: LD_VAR 0 2
71440: ARRAY
71441: LESS
71442: PUSH
71443: LD_EXP 59
71447: PUSH
71448: LD_VAR 0 2
71452: ARRAY
71453: PUSH
71454: LD_VAR 0 8
71458: LESS
71459: AND
71460: IFFALSE 71875
// begin tmp := sci [ 1 ] ;
71462: LD_ADDR_VAR 0 7
71466: PUSH
71467: LD_VAR 0 9
71471: PUSH
71472: LD_INT 1
71474: ARRAY
71475: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71476: LD_VAR 0 7
71480: PPUSH
71481: LD_INT 124
71483: PPUSH
71484: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71488: LD_ADDR_VAR 0 3
71492: PUSH
71493: DOUBLE
71494: LD_EXP 58
71498: PUSH
71499: LD_VAR 0 2
71503: ARRAY
71504: INC
71505: ST_TO_ADDR
71506: LD_EXP 58
71510: PUSH
71511: LD_VAR 0 2
71515: ARRAY
71516: PUSH
71517: FOR_DOWNTO
71518: IFFALSE 71861
// begin if IsInUnit ( tmp ) then
71520: LD_VAR 0 7
71524: PPUSH
71525: CALL_OW 310
71529: IFFALSE 71540
// ComExitBuilding ( tmp ) ;
71531: LD_VAR 0 7
71535: PPUSH
71536: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71540: LD_INT 35
71542: PPUSH
71543: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71547: LD_VAR 0 7
71551: PPUSH
71552: CALL_OW 310
71556: NOT
71557: PUSH
71558: LD_VAR 0 7
71562: PPUSH
71563: CALL_OW 314
71567: NOT
71568: AND
71569: IFFALSE 71540
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71571: LD_ADDR_VAR 0 6
71575: PUSH
71576: LD_VAR 0 7
71580: PPUSH
71581: CALL_OW 250
71585: PUSH
71586: LD_VAR 0 7
71590: PPUSH
71591: CALL_OW 251
71595: PUSH
71596: EMPTY
71597: LIST
71598: LIST
71599: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71600: LD_INT 35
71602: PPUSH
71603: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71607: LD_ADDR_VAR 0 4
71611: PUSH
71612: LD_EXP 58
71616: PUSH
71617: LD_VAR 0 2
71621: ARRAY
71622: PUSH
71623: LD_VAR 0 3
71627: ARRAY
71628: PUSH
71629: LD_INT 1
71631: ARRAY
71632: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71633: LD_ADDR_VAR 0 5
71637: PUSH
71638: LD_EXP 58
71642: PUSH
71643: LD_VAR 0 2
71647: ARRAY
71648: PUSH
71649: LD_VAR 0 3
71653: ARRAY
71654: PUSH
71655: LD_INT 2
71657: ARRAY
71658: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71659: LD_VAR 0 7
71663: PPUSH
71664: LD_INT 10
71666: PPUSH
71667: CALL 18589 0 2
71671: PUSH
71672: LD_INT 4
71674: ARRAY
71675: IFFALSE 71713
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71677: LD_VAR 0 7
71681: PPUSH
71682: LD_VAR 0 6
71686: PUSH
71687: LD_INT 1
71689: ARRAY
71690: PPUSH
71691: LD_VAR 0 6
71695: PUSH
71696: LD_INT 2
71698: ARRAY
71699: PPUSH
71700: CALL_OW 111
// wait ( 0 0$10 ) ;
71704: LD_INT 350
71706: PPUSH
71707: CALL_OW 67
// end else
71711: GO 71739
// begin ComMoveXY ( tmp , x , y ) ;
71713: LD_VAR 0 7
71717: PPUSH
71718: LD_VAR 0 4
71722: PPUSH
71723: LD_VAR 0 5
71727: PPUSH
71728: CALL_OW 111
// wait ( 0 0$3 ) ;
71732: LD_INT 105
71734: PPUSH
71735: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71739: LD_VAR 0 7
71743: PPUSH
71744: LD_VAR 0 4
71748: PPUSH
71749: LD_VAR 0 5
71753: PPUSH
71754: CALL_OW 307
71758: IFFALSE 71600
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71760: LD_VAR 0 7
71764: PPUSH
71765: LD_VAR 0 4
71769: PPUSH
71770: LD_VAR 0 5
71774: PPUSH
71775: LD_VAR 0 8
71779: PUSH
71780: LD_VAR 0 3
71784: ARRAY
71785: PPUSH
71786: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71790: LD_INT 35
71792: PPUSH
71793: CALL_OW 67
// until not HasTask ( tmp ) ;
71797: LD_VAR 0 7
71801: PPUSH
71802: CALL_OW 314
71806: NOT
71807: IFFALSE 71790
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71809: LD_ADDR_EXP 59
71813: PUSH
71814: LD_EXP 59
71818: PPUSH
71819: LD_VAR 0 2
71823: PUSH
71824: LD_EXP 59
71828: PUSH
71829: LD_VAR 0 2
71833: ARRAY
71834: PUSH
71835: LD_INT 1
71837: PLUS
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PPUSH
71843: LD_VAR 0 8
71847: PUSH
71848: LD_VAR 0 3
71852: ARRAY
71853: PPUSH
71854: CALL 15990 0 3
71858: ST_TO_ADDR
// end ;
71859: GO 71517
71861: POP
71862: POP
// MC_Reset ( i , 124 ) ;
71863: LD_VAR 0 2
71867: PPUSH
71868: LD_INT 124
71870: PPUSH
71871: CALL 55017 0 2
// end ; end ;
71875: GO 71272
71877: POP
71878: POP
// end ;
71879: LD_VAR 0 1
71883: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71884: LD_INT 0
71886: PPUSH
71887: PPUSH
71888: PPUSH
// if not mc_bases then
71889: LD_EXP 23
71893: NOT
71894: IFFALSE 71898
// exit ;
71896: GO 72504
// for i = 1 to mc_bases do
71898: LD_ADDR_VAR 0 2
71902: PUSH
71903: DOUBLE
71904: LD_INT 1
71906: DEC
71907: ST_TO_ADDR
71908: LD_EXP 23
71912: PUSH
71913: FOR_TO
71914: IFFALSE 72502
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71916: LD_ADDR_VAR 0 3
71920: PUSH
71921: LD_EXP 23
71925: PUSH
71926: LD_VAR 0 2
71930: ARRAY
71931: PPUSH
71932: LD_INT 25
71934: PUSH
71935: LD_INT 4
71937: PUSH
71938: EMPTY
71939: LIST
71940: LIST
71941: PPUSH
71942: CALL_OW 72
71946: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71947: LD_VAR 0 3
71951: NOT
71952: PUSH
71953: LD_EXP 60
71957: PUSH
71958: LD_VAR 0 2
71962: ARRAY
71963: NOT
71964: OR
71965: PUSH
71966: LD_EXP 23
71970: PUSH
71971: LD_VAR 0 2
71975: ARRAY
71976: PPUSH
71977: LD_INT 2
71979: PUSH
71980: LD_INT 30
71982: PUSH
71983: LD_INT 0
71985: PUSH
71986: EMPTY
71987: LIST
71988: LIST
71989: PUSH
71990: LD_INT 30
71992: PUSH
71993: LD_INT 1
71995: PUSH
71996: EMPTY
71997: LIST
71998: LIST
71999: PUSH
72000: EMPTY
72001: LIST
72002: LIST
72003: LIST
72004: PPUSH
72005: CALL_OW 72
72009: NOT
72010: OR
72011: IFFALSE 72061
// begin if mc_deposits_finder [ i ] then
72013: LD_EXP 61
72017: PUSH
72018: LD_VAR 0 2
72022: ARRAY
72023: IFFALSE 72059
// begin MC_Reset ( i , 125 ) ;
72025: LD_VAR 0 2
72029: PPUSH
72030: LD_INT 125
72032: PPUSH
72033: CALL 55017 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72037: LD_ADDR_EXP 61
72041: PUSH
72042: LD_EXP 61
72046: PPUSH
72047: LD_VAR 0 2
72051: PPUSH
72052: EMPTY
72053: PPUSH
72054: CALL_OW 1
72058: ST_TO_ADDR
// end ; continue ;
72059: GO 71913
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72061: LD_EXP 60
72065: PUSH
72066: LD_VAR 0 2
72070: ARRAY
72071: PUSH
72072: LD_INT 1
72074: ARRAY
72075: PUSH
72076: LD_INT 3
72078: ARRAY
72079: PUSH
72080: LD_INT 1
72082: EQUAL
72083: PUSH
72084: LD_INT 20
72086: PPUSH
72087: LD_EXP 49
72091: PUSH
72092: LD_VAR 0 2
72096: ARRAY
72097: PPUSH
72098: CALL_OW 321
72102: PUSH
72103: LD_INT 2
72105: NONEQUAL
72106: AND
72107: IFFALSE 72157
// begin if mc_deposits_finder [ i ] then
72109: LD_EXP 61
72113: PUSH
72114: LD_VAR 0 2
72118: ARRAY
72119: IFFALSE 72155
// begin MC_Reset ( i , 125 ) ;
72121: LD_VAR 0 2
72125: PPUSH
72126: LD_INT 125
72128: PPUSH
72129: CALL 55017 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72133: LD_ADDR_EXP 61
72137: PUSH
72138: LD_EXP 61
72142: PPUSH
72143: LD_VAR 0 2
72147: PPUSH
72148: EMPTY
72149: PPUSH
72150: CALL_OW 1
72154: ST_TO_ADDR
// end ; continue ;
72155: GO 71913
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72157: LD_EXP 60
72161: PUSH
72162: LD_VAR 0 2
72166: ARRAY
72167: PUSH
72168: LD_INT 1
72170: ARRAY
72171: PUSH
72172: LD_INT 1
72174: ARRAY
72175: PPUSH
72176: LD_EXP 60
72180: PUSH
72181: LD_VAR 0 2
72185: ARRAY
72186: PUSH
72187: LD_INT 1
72189: ARRAY
72190: PUSH
72191: LD_INT 2
72193: ARRAY
72194: PPUSH
72195: LD_EXP 49
72199: PUSH
72200: LD_VAR 0 2
72204: ARRAY
72205: PPUSH
72206: CALL_OW 440
72210: IFFALSE 72253
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72212: LD_ADDR_EXP 60
72216: PUSH
72217: LD_EXP 60
72221: PPUSH
72222: LD_VAR 0 2
72226: PPUSH
72227: LD_EXP 60
72231: PUSH
72232: LD_VAR 0 2
72236: ARRAY
72237: PPUSH
72238: LD_INT 1
72240: PPUSH
72241: CALL_OW 3
72245: PPUSH
72246: CALL_OW 1
72250: ST_TO_ADDR
72251: GO 72500
// begin if not mc_deposits_finder [ i ] then
72253: LD_EXP 61
72257: PUSH
72258: LD_VAR 0 2
72262: ARRAY
72263: NOT
72264: IFFALSE 72316
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72266: LD_ADDR_EXP 61
72270: PUSH
72271: LD_EXP 61
72275: PPUSH
72276: LD_VAR 0 2
72280: PPUSH
72281: LD_VAR 0 3
72285: PUSH
72286: LD_INT 1
72288: ARRAY
72289: PUSH
72290: EMPTY
72291: LIST
72292: PPUSH
72293: CALL_OW 1
72297: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72298: LD_VAR 0 3
72302: PUSH
72303: LD_INT 1
72305: ARRAY
72306: PPUSH
72307: LD_INT 125
72309: PPUSH
72310: CALL_OW 109
// end else
72314: GO 72500
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72316: LD_EXP 61
72320: PUSH
72321: LD_VAR 0 2
72325: ARRAY
72326: PUSH
72327: LD_INT 1
72329: ARRAY
72330: PPUSH
72331: CALL_OW 310
72335: IFFALSE 72358
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72337: LD_EXP 61
72341: PUSH
72342: LD_VAR 0 2
72346: ARRAY
72347: PUSH
72348: LD_INT 1
72350: ARRAY
72351: PPUSH
72352: CALL_OW 122
72356: GO 72500
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72358: LD_EXP 61
72362: PUSH
72363: LD_VAR 0 2
72367: ARRAY
72368: PUSH
72369: LD_INT 1
72371: ARRAY
72372: PPUSH
72373: CALL_OW 314
72377: NOT
72378: PUSH
72379: LD_EXP 61
72383: PUSH
72384: LD_VAR 0 2
72388: ARRAY
72389: PUSH
72390: LD_INT 1
72392: ARRAY
72393: PPUSH
72394: LD_EXP 60
72398: PUSH
72399: LD_VAR 0 2
72403: ARRAY
72404: PUSH
72405: LD_INT 1
72407: ARRAY
72408: PUSH
72409: LD_INT 1
72411: ARRAY
72412: PPUSH
72413: LD_EXP 60
72417: PUSH
72418: LD_VAR 0 2
72422: ARRAY
72423: PUSH
72424: LD_INT 1
72426: ARRAY
72427: PUSH
72428: LD_INT 2
72430: ARRAY
72431: PPUSH
72432: CALL_OW 297
72436: PUSH
72437: LD_INT 6
72439: GREATER
72440: AND
72441: IFFALSE 72500
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72443: LD_EXP 61
72447: PUSH
72448: LD_VAR 0 2
72452: ARRAY
72453: PUSH
72454: LD_INT 1
72456: ARRAY
72457: PPUSH
72458: LD_EXP 60
72462: PUSH
72463: LD_VAR 0 2
72467: ARRAY
72468: PUSH
72469: LD_INT 1
72471: ARRAY
72472: PUSH
72473: LD_INT 1
72475: ARRAY
72476: PPUSH
72477: LD_EXP 60
72481: PUSH
72482: LD_VAR 0 2
72486: ARRAY
72487: PUSH
72488: LD_INT 1
72490: ARRAY
72491: PUSH
72492: LD_INT 2
72494: ARRAY
72495: PPUSH
72496: CALL_OW 111
// end ; end ; end ;
72500: GO 71913
72502: POP
72503: POP
// end ;
72504: LD_VAR 0 1
72508: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72509: LD_INT 0
72511: PPUSH
72512: PPUSH
72513: PPUSH
72514: PPUSH
72515: PPUSH
72516: PPUSH
72517: PPUSH
72518: PPUSH
72519: PPUSH
72520: PPUSH
72521: PPUSH
// if not mc_bases then
72522: LD_EXP 23
72526: NOT
72527: IFFALSE 72531
// exit ;
72529: GO 73471
// for i = 1 to mc_bases do
72531: LD_ADDR_VAR 0 2
72535: PUSH
72536: DOUBLE
72537: LD_INT 1
72539: DEC
72540: ST_TO_ADDR
72541: LD_EXP 23
72545: PUSH
72546: FOR_TO
72547: IFFALSE 73469
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72549: LD_EXP 23
72553: PUSH
72554: LD_VAR 0 2
72558: ARRAY
72559: NOT
72560: PUSH
72561: LD_EXP 46
72565: PUSH
72566: LD_VAR 0 2
72570: ARRAY
72571: OR
72572: IFFALSE 72576
// continue ;
72574: GO 72546
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72576: LD_ADDR_VAR 0 7
72580: PUSH
72581: LD_EXP 23
72585: PUSH
72586: LD_VAR 0 2
72590: ARRAY
72591: PUSH
72592: LD_INT 1
72594: ARRAY
72595: PPUSH
72596: CALL_OW 248
72600: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72601: LD_VAR 0 7
72605: PUSH
72606: LD_INT 3
72608: EQUAL
72609: PUSH
72610: LD_EXP 42
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: PUSH
72621: LD_EXP 45
72625: PUSH
72626: LD_VAR 0 2
72630: ARRAY
72631: UNION
72632: PPUSH
72633: LD_INT 33
72635: PUSH
72636: LD_INT 2
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: PPUSH
72643: CALL_OW 72
72647: NOT
72648: OR
72649: IFFALSE 72653
// continue ;
72651: GO 72546
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72653: LD_ADDR_VAR 0 9
72657: PUSH
72658: LD_EXP 23
72662: PUSH
72663: LD_VAR 0 2
72667: ARRAY
72668: PPUSH
72669: LD_INT 30
72671: PUSH
72672: LD_INT 36
72674: PUSH
72675: EMPTY
72676: LIST
72677: LIST
72678: PPUSH
72679: CALL_OW 72
72683: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72684: LD_ADDR_VAR 0 10
72688: PUSH
72689: LD_EXP 42
72693: PUSH
72694: LD_VAR 0 2
72698: ARRAY
72699: PPUSH
72700: LD_INT 34
72702: PUSH
72703: LD_INT 31
72705: PUSH
72706: EMPTY
72707: LIST
72708: LIST
72709: PPUSH
72710: CALL_OW 72
72714: ST_TO_ADDR
// if not cts and not mcts then
72715: LD_VAR 0 9
72719: NOT
72720: PUSH
72721: LD_VAR 0 10
72725: NOT
72726: AND
72727: IFFALSE 72731
// continue ;
72729: GO 72546
// x := cts ;
72731: LD_ADDR_VAR 0 11
72735: PUSH
72736: LD_VAR 0 9
72740: ST_TO_ADDR
// if not x then
72741: LD_VAR 0 11
72745: NOT
72746: IFFALSE 72758
// x := mcts ;
72748: LD_ADDR_VAR 0 11
72752: PUSH
72753: LD_VAR 0 10
72757: ST_TO_ADDR
// if not x then
72758: LD_VAR 0 11
72762: NOT
72763: IFFALSE 72767
// continue ;
72765: GO 72546
// if mc_remote_driver [ i ] then
72767: LD_EXP 63
72771: PUSH
72772: LD_VAR 0 2
72776: ARRAY
72777: IFFALSE 73164
// for j in mc_remote_driver [ i ] do
72779: LD_ADDR_VAR 0 3
72783: PUSH
72784: LD_EXP 63
72788: PUSH
72789: LD_VAR 0 2
72793: ARRAY
72794: PUSH
72795: FOR_IN
72796: IFFALSE 73162
// begin if GetClass ( j ) <> 3 then
72798: LD_VAR 0 3
72802: PPUSH
72803: CALL_OW 257
72807: PUSH
72808: LD_INT 3
72810: NONEQUAL
72811: IFFALSE 72864
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
72813: LD_ADDR_EXP 63
72817: PUSH
72818: LD_EXP 63
72822: PPUSH
72823: LD_VAR 0 2
72827: PPUSH
72828: LD_EXP 63
72832: PUSH
72833: LD_VAR 0 2
72837: ARRAY
72838: PUSH
72839: LD_VAR 0 3
72843: DIFF
72844: PPUSH
72845: CALL_OW 1
72849: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72850: LD_VAR 0 3
72854: PPUSH
72855: LD_INT 0
72857: PPUSH
72858: CALL_OW 109
// continue ;
72862: GO 72795
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72864: LD_EXP 42
72868: PUSH
72869: LD_VAR 0 2
72873: ARRAY
72874: PPUSH
72875: LD_INT 34
72877: PUSH
72878: LD_INT 31
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 58
72887: PUSH
72888: EMPTY
72889: LIST
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PPUSH
72895: CALL_OW 72
72899: PUSH
72900: LD_VAR 0 3
72904: PPUSH
72905: CALL 45347 0 1
72909: NOT
72910: AND
72911: IFFALSE 72982
// begin if IsInUnit ( j ) then
72913: LD_VAR 0 3
72917: PPUSH
72918: CALL_OW 310
72922: IFFALSE 72933
// ComExitBuilding ( j ) ;
72924: LD_VAR 0 3
72928: PPUSH
72929: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72933: LD_VAR 0 3
72937: PPUSH
72938: LD_EXP 42
72942: PUSH
72943: LD_VAR 0 2
72947: ARRAY
72948: PPUSH
72949: LD_INT 34
72951: PUSH
72952: LD_INT 31
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 58
72961: PUSH
72962: EMPTY
72963: LIST
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PPUSH
72969: CALL_OW 72
72973: PUSH
72974: LD_INT 1
72976: ARRAY
72977: PPUSH
72978: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72982: LD_VAR 0 3
72986: PPUSH
72987: CALL_OW 310
72991: NOT
72992: PUSH
72993: LD_VAR 0 3
72997: PPUSH
72998: CALL_OW 310
73002: PPUSH
73003: CALL_OW 266
73007: PUSH
73008: LD_INT 36
73010: NONEQUAL
73011: PUSH
73012: LD_VAR 0 3
73016: PPUSH
73017: CALL 45347 0 1
73021: NOT
73022: AND
73023: OR
73024: IFFALSE 73160
// begin if IsInUnit ( j ) then
73026: LD_VAR 0 3
73030: PPUSH
73031: CALL_OW 310
73035: IFFALSE 73046
// ComExitBuilding ( j ) ;
73037: LD_VAR 0 3
73041: PPUSH
73042: CALL_OW 122
// ct := 0 ;
73046: LD_ADDR_VAR 0 8
73050: PUSH
73051: LD_INT 0
73053: ST_TO_ADDR
// for k in x do
73054: LD_ADDR_VAR 0 4
73058: PUSH
73059: LD_VAR 0 11
73063: PUSH
73064: FOR_IN
73065: IFFALSE 73138
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73067: LD_VAR 0 4
73071: PPUSH
73072: CALL_OW 264
73076: PUSH
73077: LD_INT 31
73079: EQUAL
73080: PUSH
73081: LD_VAR 0 4
73085: PPUSH
73086: CALL_OW 311
73090: NOT
73091: AND
73092: PUSH
73093: LD_VAR 0 4
73097: PPUSH
73098: CALL_OW 266
73102: PUSH
73103: LD_INT 36
73105: EQUAL
73106: PUSH
73107: LD_VAR 0 4
73111: PPUSH
73112: CALL_OW 313
73116: PUSH
73117: LD_INT 3
73119: LESS
73120: AND
73121: OR
73122: IFFALSE 73136
// begin ct := k ;
73124: LD_ADDR_VAR 0 8
73128: PUSH
73129: LD_VAR 0 4
73133: ST_TO_ADDR
// break ;
73134: GO 73138
// end ;
73136: GO 73064
73138: POP
73139: POP
// if ct then
73140: LD_VAR 0 8
73144: IFFALSE 73160
// ComEnterUnit ( j , ct ) ;
73146: LD_VAR 0 3
73150: PPUSH
73151: LD_VAR 0 8
73155: PPUSH
73156: CALL_OW 120
// end ; end ;
73160: GO 72795
73162: POP
73163: POP
// places := 0 ;
73164: LD_ADDR_VAR 0 5
73168: PUSH
73169: LD_INT 0
73171: ST_TO_ADDR
// for j = 1 to x do
73172: LD_ADDR_VAR 0 3
73176: PUSH
73177: DOUBLE
73178: LD_INT 1
73180: DEC
73181: ST_TO_ADDR
73182: LD_VAR 0 11
73186: PUSH
73187: FOR_TO
73188: IFFALSE 73264
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73190: LD_VAR 0 11
73194: PUSH
73195: LD_VAR 0 3
73199: ARRAY
73200: PPUSH
73201: CALL_OW 264
73205: PUSH
73206: LD_INT 31
73208: EQUAL
73209: IFFALSE 73227
// places := places + 1 else
73211: LD_ADDR_VAR 0 5
73215: PUSH
73216: LD_VAR 0 5
73220: PUSH
73221: LD_INT 1
73223: PLUS
73224: ST_TO_ADDR
73225: GO 73262
// if GetBType ( x [ j ] ) = b_control_tower then
73227: LD_VAR 0 11
73231: PUSH
73232: LD_VAR 0 3
73236: ARRAY
73237: PPUSH
73238: CALL_OW 266
73242: PUSH
73243: LD_INT 36
73245: EQUAL
73246: IFFALSE 73262
// places := places + 3 ;
73248: LD_ADDR_VAR 0 5
73252: PUSH
73253: LD_VAR 0 5
73257: PUSH
73258: LD_INT 3
73260: PLUS
73261: ST_TO_ADDR
73262: GO 73187
73264: POP
73265: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73266: LD_VAR 0 5
73270: PUSH
73271: LD_INT 0
73273: EQUAL
73274: PUSH
73275: LD_VAR 0 5
73279: PUSH
73280: LD_EXP 63
73284: PUSH
73285: LD_VAR 0 2
73289: ARRAY
73290: LESSEQUAL
73291: OR
73292: IFFALSE 73296
// continue ;
73294: GO 72546
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73296: LD_ADDR_VAR 0 6
73300: PUSH
73301: LD_EXP 23
73305: PUSH
73306: LD_VAR 0 2
73310: ARRAY
73311: PPUSH
73312: LD_INT 25
73314: PUSH
73315: LD_INT 3
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PPUSH
73322: CALL_OW 72
73326: PUSH
73327: LD_EXP 63
73331: PUSH
73332: LD_VAR 0 2
73336: ARRAY
73337: DIFF
73338: PPUSH
73339: LD_INT 3
73341: PPUSH
73342: CALL 46247 0 2
73346: ST_TO_ADDR
// for j in tmp do
73347: LD_ADDR_VAR 0 3
73351: PUSH
73352: LD_VAR 0 6
73356: PUSH
73357: FOR_IN
73358: IFFALSE 73393
// if GetTag ( j ) > 0 then
73360: LD_VAR 0 3
73364: PPUSH
73365: CALL_OW 110
73369: PUSH
73370: LD_INT 0
73372: GREATER
73373: IFFALSE 73391
// tmp := tmp diff j ;
73375: LD_ADDR_VAR 0 6
73379: PUSH
73380: LD_VAR 0 6
73384: PUSH
73385: LD_VAR 0 3
73389: DIFF
73390: ST_TO_ADDR
73391: GO 73357
73393: POP
73394: POP
// if not tmp then
73395: LD_VAR 0 6
73399: NOT
73400: IFFALSE 73404
// continue ;
73402: GO 72546
// if places then
73404: LD_VAR 0 5
73408: IFFALSE 73467
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73410: LD_ADDR_EXP 63
73414: PUSH
73415: LD_EXP 63
73419: PPUSH
73420: LD_VAR 0 2
73424: PPUSH
73425: LD_EXP 63
73429: PUSH
73430: LD_VAR 0 2
73434: ARRAY
73435: PUSH
73436: LD_VAR 0 6
73440: PUSH
73441: LD_INT 1
73443: ARRAY
73444: UNION
73445: PPUSH
73446: CALL_OW 1
73450: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73451: LD_VAR 0 6
73455: PUSH
73456: LD_INT 1
73458: ARRAY
73459: PPUSH
73460: LD_INT 126
73462: PPUSH
73463: CALL_OW 109
// end ; end ;
73467: GO 72546
73469: POP
73470: POP
// end ;
73471: LD_VAR 0 1
73475: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73476: LD_INT 0
73478: PPUSH
73479: PPUSH
73480: PPUSH
73481: PPUSH
73482: PPUSH
73483: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73484: LD_VAR 0 1
73488: NOT
73489: PUSH
73490: LD_VAR 0 2
73494: NOT
73495: OR
73496: PUSH
73497: LD_VAR 0 3
73501: NOT
73502: OR
73503: PUSH
73504: LD_VAR 0 4
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: LD_INT 2
73514: PUSH
73515: LD_INT 3
73517: PUSH
73518: LD_INT 4
73520: PUSH
73521: LD_INT 5
73523: PUSH
73524: LD_INT 8
73526: PUSH
73527: LD_INT 9
73529: PUSH
73530: LD_INT 15
73532: PUSH
73533: LD_INT 16
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: LIST
73543: LIST
73544: LIST
73545: LIST
73546: IN
73547: NOT
73548: OR
73549: IFFALSE 73553
// exit ;
73551: GO 74453
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73553: LD_ADDR_VAR 0 2
73557: PUSH
73558: LD_VAR 0 2
73562: PPUSH
73563: LD_INT 21
73565: PUSH
73566: LD_INT 3
73568: PUSH
73569: EMPTY
73570: LIST
73571: LIST
73572: PUSH
73573: LD_INT 24
73575: PUSH
73576: LD_INT 250
73578: PUSH
73579: EMPTY
73580: LIST
73581: LIST
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PPUSH
73587: CALL_OW 72
73591: ST_TO_ADDR
// case class of 1 , 15 :
73592: LD_VAR 0 4
73596: PUSH
73597: LD_INT 1
73599: DOUBLE
73600: EQUAL
73601: IFTRUE 73611
73603: LD_INT 15
73605: DOUBLE
73606: EQUAL
73607: IFTRUE 73611
73609: GO 73696
73611: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73612: LD_ADDR_VAR 0 8
73616: PUSH
73617: LD_VAR 0 2
73621: PPUSH
73622: LD_INT 2
73624: PUSH
73625: LD_INT 30
73627: PUSH
73628: LD_INT 32
73630: PUSH
73631: EMPTY
73632: LIST
73633: LIST
73634: PUSH
73635: LD_INT 30
73637: PUSH
73638: LD_INT 31
73640: PUSH
73641: EMPTY
73642: LIST
73643: LIST
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: LIST
73649: PPUSH
73650: CALL_OW 72
73654: PUSH
73655: LD_VAR 0 2
73659: PPUSH
73660: LD_INT 2
73662: PUSH
73663: LD_INT 30
73665: PUSH
73666: LD_INT 4
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 30
73675: PUSH
73676: LD_INT 5
73678: PUSH
73679: EMPTY
73680: LIST
73681: LIST
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: LIST
73687: PPUSH
73688: CALL_OW 72
73692: ADD
73693: ST_TO_ADDR
73694: GO 73942
73696: LD_INT 2
73698: DOUBLE
73699: EQUAL
73700: IFTRUE 73710
73702: LD_INT 16
73704: DOUBLE
73705: EQUAL
73706: IFTRUE 73710
73708: GO 73756
73710: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73711: LD_ADDR_VAR 0 8
73715: PUSH
73716: LD_VAR 0 2
73720: PPUSH
73721: LD_INT 2
73723: PUSH
73724: LD_INT 30
73726: PUSH
73727: LD_INT 0
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 30
73736: PUSH
73737: LD_INT 1
73739: PUSH
73740: EMPTY
73741: LIST
73742: LIST
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: LIST
73748: PPUSH
73749: CALL_OW 72
73753: ST_TO_ADDR
73754: GO 73942
73756: LD_INT 3
73758: DOUBLE
73759: EQUAL
73760: IFTRUE 73764
73762: GO 73810
73764: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73765: LD_ADDR_VAR 0 8
73769: PUSH
73770: LD_VAR 0 2
73774: PPUSH
73775: LD_INT 2
73777: PUSH
73778: LD_INT 30
73780: PUSH
73781: LD_INT 2
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 30
73790: PUSH
73791: LD_INT 3
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: LIST
73802: PPUSH
73803: CALL_OW 72
73807: ST_TO_ADDR
73808: GO 73942
73810: LD_INT 4
73812: DOUBLE
73813: EQUAL
73814: IFTRUE 73818
73816: GO 73875
73818: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
73819: LD_ADDR_VAR 0 8
73823: PUSH
73824: LD_VAR 0 2
73828: PPUSH
73829: LD_INT 2
73831: PUSH
73832: LD_INT 30
73834: PUSH
73835: LD_INT 6
73837: PUSH
73838: EMPTY
73839: LIST
73840: LIST
73841: PUSH
73842: LD_INT 30
73844: PUSH
73845: LD_INT 7
73847: PUSH
73848: EMPTY
73849: LIST
73850: LIST
73851: PUSH
73852: LD_INT 30
73854: PUSH
73855: LD_INT 8
73857: PUSH
73858: EMPTY
73859: LIST
73860: LIST
73861: PUSH
73862: EMPTY
73863: LIST
73864: LIST
73865: LIST
73866: LIST
73867: PPUSH
73868: CALL_OW 72
73872: ST_TO_ADDR
73873: GO 73942
73875: LD_INT 5
73877: DOUBLE
73878: EQUAL
73879: IFTRUE 73895
73881: LD_INT 8
73883: DOUBLE
73884: EQUAL
73885: IFTRUE 73895
73887: LD_INT 9
73889: DOUBLE
73890: EQUAL
73891: IFTRUE 73895
73893: GO 73941
73895: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73896: LD_ADDR_VAR 0 8
73900: PUSH
73901: LD_VAR 0 2
73905: PPUSH
73906: LD_INT 2
73908: PUSH
73909: LD_INT 30
73911: PUSH
73912: LD_INT 4
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: LD_INT 30
73921: PUSH
73922: LD_INT 5
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: PUSH
73929: EMPTY
73930: LIST
73931: LIST
73932: LIST
73933: PPUSH
73934: CALL_OW 72
73938: ST_TO_ADDR
73939: GO 73942
73941: POP
// if not tmp then
73942: LD_VAR 0 8
73946: NOT
73947: IFFALSE 73951
// exit ;
73949: GO 74453
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73951: LD_VAR 0 4
73955: PUSH
73956: LD_INT 1
73958: PUSH
73959: LD_INT 15
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: IN
73966: PUSH
73967: LD_EXP 32
73971: PUSH
73972: LD_VAR 0 1
73976: ARRAY
73977: AND
73978: IFFALSE 74134
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73980: LD_ADDR_VAR 0 9
73984: PUSH
73985: LD_EXP 32
73989: PUSH
73990: LD_VAR 0 1
73994: ARRAY
73995: PUSH
73996: LD_INT 1
73998: ARRAY
73999: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74000: LD_VAR 0 9
74004: PUSH
74005: LD_EXP 33
74009: PUSH
74010: LD_VAR 0 1
74014: ARRAY
74015: IN
74016: NOT
74017: IFFALSE 74132
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74019: LD_ADDR_EXP 33
74023: PUSH
74024: LD_EXP 33
74028: PPUSH
74029: LD_VAR 0 1
74033: PUSH
74034: LD_EXP 33
74038: PUSH
74039: LD_VAR 0 1
74043: ARRAY
74044: PUSH
74045: LD_INT 1
74047: PLUS
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PPUSH
74053: LD_VAR 0 9
74057: PPUSH
74058: CALL 15990 0 3
74062: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74063: LD_ADDR_EXP 32
74067: PUSH
74068: LD_EXP 32
74072: PPUSH
74073: LD_VAR 0 1
74077: PPUSH
74078: LD_EXP 32
74082: PUSH
74083: LD_VAR 0 1
74087: ARRAY
74088: PUSH
74089: LD_VAR 0 9
74093: DIFF
74094: PPUSH
74095: CALL_OW 1
74099: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74100: LD_VAR 0 3
74104: PPUSH
74105: LD_EXP 33
74109: PUSH
74110: LD_VAR 0 1
74114: ARRAY
74115: PUSH
74116: LD_EXP 33
74120: PUSH
74121: LD_VAR 0 1
74125: ARRAY
74126: ARRAY
74127: PPUSH
74128: CALL_OW 120
// end ; exit ;
74132: GO 74453
// end ; if tmp > 1 then
74134: LD_VAR 0 8
74138: PUSH
74139: LD_INT 1
74141: GREATER
74142: IFFALSE 74246
// for i = 2 to tmp do
74144: LD_ADDR_VAR 0 6
74148: PUSH
74149: DOUBLE
74150: LD_INT 2
74152: DEC
74153: ST_TO_ADDR
74154: LD_VAR 0 8
74158: PUSH
74159: FOR_TO
74160: IFFALSE 74244
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74162: LD_VAR 0 8
74166: PUSH
74167: LD_VAR 0 6
74171: ARRAY
74172: PPUSH
74173: CALL_OW 461
74177: PUSH
74178: LD_INT 6
74180: EQUAL
74181: IFFALSE 74242
// begin x := tmp [ i ] ;
74183: LD_ADDR_VAR 0 9
74187: PUSH
74188: LD_VAR 0 8
74192: PUSH
74193: LD_VAR 0 6
74197: ARRAY
74198: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74199: LD_ADDR_VAR 0 8
74203: PUSH
74204: LD_VAR 0 8
74208: PPUSH
74209: LD_VAR 0 6
74213: PPUSH
74214: CALL_OW 3
74218: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74219: LD_ADDR_VAR 0 8
74223: PUSH
74224: LD_VAR 0 8
74228: PPUSH
74229: LD_INT 1
74231: PPUSH
74232: LD_VAR 0 9
74236: PPUSH
74237: CALL_OW 2
74241: ST_TO_ADDR
// end ;
74242: GO 74159
74244: POP
74245: POP
// for i in tmp do
74246: LD_ADDR_VAR 0 6
74250: PUSH
74251: LD_VAR 0 8
74255: PUSH
74256: FOR_IN
74257: IFFALSE 74326
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74259: LD_VAR 0 6
74263: PPUSH
74264: CALL_OW 313
74268: PUSH
74269: LD_INT 6
74271: LESS
74272: PUSH
74273: LD_VAR 0 6
74277: PPUSH
74278: CALL_OW 266
74282: PUSH
74283: LD_INT 31
74285: PUSH
74286: LD_INT 32
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: IN
74293: NOT
74294: AND
74295: PUSH
74296: LD_VAR 0 6
74300: PPUSH
74301: CALL_OW 313
74305: PUSH
74306: LD_INT 0
74308: EQUAL
74309: OR
74310: IFFALSE 74324
// begin j := i ;
74312: LD_ADDR_VAR 0 7
74316: PUSH
74317: LD_VAR 0 6
74321: ST_TO_ADDR
// break ;
74322: GO 74326
// end ; end ;
74324: GO 74256
74326: POP
74327: POP
// if j then
74328: LD_VAR 0 7
74332: IFFALSE 74350
// ComEnterUnit ( unit , j ) else
74334: LD_VAR 0 3
74338: PPUSH
74339: LD_VAR 0 7
74343: PPUSH
74344: CALL_OW 120
74348: GO 74453
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74350: LD_ADDR_VAR 0 10
74354: PUSH
74355: LD_VAR 0 2
74359: PPUSH
74360: LD_INT 2
74362: PUSH
74363: LD_INT 30
74365: PUSH
74366: LD_INT 0
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PUSH
74373: LD_INT 30
74375: PUSH
74376: LD_INT 1
74378: PUSH
74379: EMPTY
74380: LIST
74381: LIST
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: LIST
74387: PPUSH
74388: CALL_OW 72
74392: ST_TO_ADDR
// if depot then
74393: LD_VAR 0 10
74397: IFFALSE 74453
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74399: LD_ADDR_VAR 0 10
74403: PUSH
74404: LD_VAR 0 10
74408: PPUSH
74409: LD_VAR 0 3
74413: PPUSH
74414: CALL_OW 74
74418: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74419: LD_VAR 0 3
74423: PPUSH
74424: LD_VAR 0 10
74428: PPUSH
74429: CALL_OW 296
74433: PUSH
74434: LD_INT 10
74436: GREATER
74437: IFFALSE 74453
// ComStandNearbyBuilding ( unit , depot ) ;
74439: LD_VAR 0 3
74443: PPUSH
74444: LD_VAR 0 10
74448: PPUSH
74449: CALL 12568 0 2
// end ; end ; end ;
74453: LD_VAR 0 5
74457: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74458: LD_INT 0
74460: PPUSH
74461: PPUSH
74462: PPUSH
74463: PPUSH
// if not mc_bases then
74464: LD_EXP 23
74468: NOT
74469: IFFALSE 74473
// exit ;
74471: GO 74712
// for i = 1 to mc_bases do
74473: LD_ADDR_VAR 0 2
74477: PUSH
74478: DOUBLE
74479: LD_INT 1
74481: DEC
74482: ST_TO_ADDR
74483: LD_EXP 23
74487: PUSH
74488: FOR_TO
74489: IFFALSE 74710
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74491: LD_ADDR_VAR 0 4
74495: PUSH
74496: LD_EXP 23
74500: PUSH
74501: LD_VAR 0 2
74505: ARRAY
74506: PPUSH
74507: LD_INT 21
74509: PUSH
74510: LD_INT 1
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PPUSH
74517: CALL_OW 72
74521: PUSH
74522: LD_EXP 52
74526: PUSH
74527: LD_VAR 0 2
74531: ARRAY
74532: UNION
74533: ST_TO_ADDR
// if not tmp then
74534: LD_VAR 0 4
74538: NOT
74539: IFFALSE 74543
// continue ;
74541: GO 74488
// for j in tmp do
74543: LD_ADDR_VAR 0 3
74547: PUSH
74548: LD_VAR 0 4
74552: PUSH
74553: FOR_IN
74554: IFFALSE 74706
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74556: LD_VAR 0 3
74560: PPUSH
74561: CALL_OW 110
74565: NOT
74566: PUSH
74567: LD_VAR 0 3
74571: PPUSH
74572: CALL_OW 314
74576: NOT
74577: AND
74578: PUSH
74579: LD_VAR 0 3
74583: PPUSH
74584: CALL_OW 311
74588: NOT
74589: AND
74590: PUSH
74591: LD_VAR 0 3
74595: PPUSH
74596: CALL_OW 310
74600: NOT
74601: AND
74602: PUSH
74603: LD_VAR 0 3
74607: PUSH
74608: LD_EXP 26
74612: PUSH
74613: LD_VAR 0 2
74617: ARRAY
74618: PUSH
74619: LD_INT 1
74621: ARRAY
74622: IN
74623: NOT
74624: AND
74625: PUSH
74626: LD_VAR 0 3
74630: PUSH
74631: LD_EXP 26
74635: PUSH
74636: LD_VAR 0 2
74640: ARRAY
74641: PUSH
74642: LD_INT 2
74644: ARRAY
74645: IN
74646: NOT
74647: AND
74648: PUSH
74649: LD_VAR 0 3
74653: PUSH
74654: LD_EXP 35
74658: PUSH
74659: LD_VAR 0 2
74663: ARRAY
74664: IN
74665: NOT
74666: AND
74667: IFFALSE 74704
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74669: LD_VAR 0 2
74673: PPUSH
74674: LD_EXP 23
74678: PUSH
74679: LD_VAR 0 2
74683: ARRAY
74684: PPUSH
74685: LD_VAR 0 3
74689: PPUSH
74690: LD_VAR 0 3
74694: PPUSH
74695: CALL_OW 257
74699: PPUSH
74700: CALL 73476 0 4
// end ;
74704: GO 74553
74706: POP
74707: POP
// end ;
74708: GO 74488
74710: POP
74711: POP
// end ;
74712: LD_VAR 0 1
74716: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74717: LD_INT 0
74719: PPUSH
74720: PPUSH
74721: PPUSH
74722: PPUSH
74723: PPUSH
74724: PPUSH
// if not mc_bases [ base ] then
74725: LD_EXP 23
74729: PUSH
74730: LD_VAR 0 1
74734: ARRAY
74735: NOT
74736: IFFALSE 74740
// exit ;
74738: GO 74922
// tmp := [ ] ;
74740: LD_ADDR_VAR 0 6
74744: PUSH
74745: EMPTY
74746: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74747: LD_ADDR_VAR 0 7
74751: PUSH
74752: LD_VAR 0 3
74756: PPUSH
74757: LD_INT 0
74759: PPUSH
74760: CALL_OW 517
74764: ST_TO_ADDR
// if not list then
74765: LD_VAR 0 7
74769: NOT
74770: IFFALSE 74774
// exit ;
74772: GO 74922
// for i = 1 to amount do
74774: LD_ADDR_VAR 0 5
74778: PUSH
74779: DOUBLE
74780: LD_INT 1
74782: DEC
74783: ST_TO_ADDR
74784: LD_VAR 0 2
74788: PUSH
74789: FOR_TO
74790: IFFALSE 74870
// begin x := rand ( 1 , list [ 1 ] ) ;
74792: LD_ADDR_VAR 0 8
74796: PUSH
74797: LD_INT 1
74799: PPUSH
74800: LD_VAR 0 7
74804: PUSH
74805: LD_INT 1
74807: ARRAY
74808: PPUSH
74809: CALL_OW 12
74813: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
74814: LD_ADDR_VAR 0 6
74818: PUSH
74819: LD_VAR 0 6
74823: PPUSH
74824: LD_VAR 0 5
74828: PPUSH
74829: LD_VAR 0 7
74833: PUSH
74834: LD_INT 1
74836: ARRAY
74837: PUSH
74838: LD_VAR 0 8
74842: ARRAY
74843: PUSH
74844: LD_VAR 0 7
74848: PUSH
74849: LD_INT 2
74851: ARRAY
74852: PUSH
74853: LD_VAR 0 8
74857: ARRAY
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PPUSH
74863: CALL_OW 1
74867: ST_TO_ADDR
// end ;
74868: GO 74789
74870: POP
74871: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74872: LD_ADDR_EXP 36
74876: PUSH
74877: LD_EXP 36
74881: PPUSH
74882: LD_VAR 0 1
74886: PPUSH
74887: LD_VAR 0 6
74891: PPUSH
74892: CALL_OW 1
74896: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74897: LD_ADDR_EXP 38
74901: PUSH
74902: LD_EXP 38
74906: PPUSH
74907: LD_VAR 0 1
74911: PPUSH
74912: LD_VAR 0 3
74916: PPUSH
74917: CALL_OW 1
74921: ST_TO_ADDR
// end ;
74922: LD_VAR 0 4
74926: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74927: LD_INT 0
74929: PPUSH
// if not mc_bases [ base ] then
74930: LD_EXP 23
74934: PUSH
74935: LD_VAR 0 1
74939: ARRAY
74940: NOT
74941: IFFALSE 74945
// exit ;
74943: GO 74970
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74945: LD_ADDR_EXP 28
74949: PUSH
74950: LD_EXP 28
74954: PPUSH
74955: LD_VAR 0 1
74959: PPUSH
74960: LD_VAR 0 2
74964: PPUSH
74965: CALL_OW 1
74969: ST_TO_ADDR
// end ;
74970: LD_VAR 0 3
74974: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74975: LD_INT 0
74977: PPUSH
// if not mc_bases [ base ] then
74978: LD_EXP 23
74982: PUSH
74983: LD_VAR 0 1
74987: ARRAY
74988: NOT
74989: IFFALSE 74993
// exit ;
74991: GO 75030
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74993: LD_ADDR_EXP 28
74997: PUSH
74998: LD_EXP 28
75002: PPUSH
75003: LD_VAR 0 1
75007: PPUSH
75008: LD_EXP 28
75012: PUSH
75013: LD_VAR 0 1
75017: ARRAY
75018: PUSH
75019: LD_VAR 0 2
75023: UNION
75024: PPUSH
75025: CALL_OW 1
75029: ST_TO_ADDR
// end ;
75030: LD_VAR 0 3
75034: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75035: LD_INT 0
75037: PPUSH
// if not mc_bases [ base ] then
75038: LD_EXP 23
75042: PUSH
75043: LD_VAR 0 1
75047: ARRAY
75048: NOT
75049: IFFALSE 75053
// exit ;
75051: GO 75078
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75053: LD_ADDR_EXP 44
75057: PUSH
75058: LD_EXP 44
75062: PPUSH
75063: LD_VAR 0 1
75067: PPUSH
75068: LD_VAR 0 2
75072: PPUSH
75073: CALL_OW 1
75077: ST_TO_ADDR
// end ;
75078: LD_VAR 0 3
75082: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75083: LD_INT 0
75085: PPUSH
// if not mc_bases [ base ] then
75086: LD_EXP 23
75090: PUSH
75091: LD_VAR 0 1
75095: ARRAY
75096: NOT
75097: IFFALSE 75101
// exit ;
75099: GO 75138
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75101: LD_ADDR_EXP 44
75105: PUSH
75106: LD_EXP 44
75110: PPUSH
75111: LD_VAR 0 1
75115: PPUSH
75116: LD_EXP 44
75120: PUSH
75121: LD_VAR 0 1
75125: ARRAY
75126: PUSH
75127: LD_VAR 0 2
75131: ADD
75132: PPUSH
75133: CALL_OW 1
75137: ST_TO_ADDR
// end ;
75138: LD_VAR 0 3
75142: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75143: LD_INT 0
75145: PPUSH
// if not mc_bases [ base ] then
75146: LD_EXP 23
75150: PUSH
75151: LD_VAR 0 1
75155: ARRAY
75156: NOT
75157: IFFALSE 75161
// exit ;
75159: GO 75215
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75161: LD_ADDR_EXP 45
75165: PUSH
75166: LD_EXP 45
75170: PPUSH
75171: LD_VAR 0 1
75175: PPUSH
75176: LD_VAR 0 2
75180: PPUSH
75181: CALL_OW 1
75185: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75186: LD_ADDR_EXP 34
75190: PUSH
75191: LD_EXP 34
75195: PPUSH
75196: LD_VAR 0 1
75200: PPUSH
75201: LD_VAR 0 2
75205: PUSH
75206: LD_INT 0
75208: PLUS
75209: PPUSH
75210: CALL_OW 1
75214: ST_TO_ADDR
// end ;
75215: LD_VAR 0 3
75219: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75220: LD_INT 0
75222: PPUSH
// if not mc_bases [ base ] then
75223: LD_EXP 23
75227: PUSH
75228: LD_VAR 0 1
75232: ARRAY
75233: NOT
75234: IFFALSE 75238
// exit ;
75236: GO 75263
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75238: LD_ADDR_EXP 34
75242: PUSH
75243: LD_EXP 34
75247: PPUSH
75248: LD_VAR 0 1
75252: PPUSH
75253: LD_VAR 0 2
75257: PPUSH
75258: CALL_OW 1
75262: ST_TO_ADDR
// end ;
75263: LD_VAR 0 3
75267: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75268: LD_INT 0
75270: PPUSH
75271: PPUSH
75272: PPUSH
75273: PPUSH
// if not mc_bases [ base ] then
75274: LD_EXP 23
75278: PUSH
75279: LD_VAR 0 1
75283: ARRAY
75284: NOT
75285: IFFALSE 75289
// exit ;
75287: GO 75354
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75289: LD_ADDR_EXP 43
75293: PUSH
75294: LD_EXP 43
75298: PPUSH
75299: LD_VAR 0 1
75303: PUSH
75304: LD_EXP 43
75308: PUSH
75309: LD_VAR 0 1
75313: ARRAY
75314: PUSH
75315: LD_INT 1
75317: PLUS
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PPUSH
75323: LD_VAR 0 1
75327: PUSH
75328: LD_VAR 0 2
75332: PUSH
75333: LD_VAR 0 3
75337: PUSH
75338: LD_VAR 0 4
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: LIST
75347: LIST
75348: PPUSH
75349: CALL 15990 0 3
75353: ST_TO_ADDR
// end ;
75354: LD_VAR 0 5
75358: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75359: LD_INT 0
75361: PPUSH
// if not mc_bases [ base ] then
75362: LD_EXP 23
75366: PUSH
75367: LD_VAR 0 1
75371: ARRAY
75372: NOT
75373: IFFALSE 75377
// exit ;
75375: GO 75402
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75377: LD_ADDR_EXP 60
75381: PUSH
75382: LD_EXP 60
75386: PPUSH
75387: LD_VAR 0 1
75391: PPUSH
75392: LD_VAR 0 2
75396: PPUSH
75397: CALL_OW 1
75401: ST_TO_ADDR
// end ;
75402: LD_VAR 0 3
75406: RET
// export function MC_GetMinesField ( base ) ; begin
75407: LD_INT 0
75409: PPUSH
// result := mc_mines [ base ] ;
75410: LD_ADDR_VAR 0 2
75414: PUSH
75415: LD_EXP 36
75419: PUSH
75420: LD_VAR 0 1
75424: ARRAY
75425: ST_TO_ADDR
// end ;
75426: LD_VAR 0 2
75430: RET
// export function MC_GetProduceList ( base ) ; begin
75431: LD_INT 0
75433: PPUSH
// result := mc_produce [ base ] ;
75434: LD_ADDR_VAR 0 2
75438: PUSH
75439: LD_EXP 44
75443: PUSH
75444: LD_VAR 0 1
75448: ARRAY
75449: ST_TO_ADDR
// end ;
75450: LD_VAR 0 2
75454: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75455: LD_INT 0
75457: PPUSH
75458: PPUSH
// if not mc_bases then
75459: LD_EXP 23
75463: NOT
75464: IFFALSE 75468
// exit ;
75466: GO 75533
// if mc_bases [ base ] then
75468: LD_EXP 23
75472: PUSH
75473: LD_VAR 0 1
75477: ARRAY
75478: IFFALSE 75533
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75480: LD_ADDR_VAR 0 3
75484: PUSH
75485: LD_EXP 23
75489: PUSH
75490: LD_VAR 0 1
75494: ARRAY
75495: PPUSH
75496: LD_INT 30
75498: PUSH
75499: LD_VAR 0 2
75503: PUSH
75504: EMPTY
75505: LIST
75506: LIST
75507: PPUSH
75508: CALL_OW 72
75512: ST_TO_ADDR
// if result then
75513: LD_VAR 0 3
75517: IFFALSE 75533
// result := result [ 1 ] ;
75519: LD_ADDR_VAR 0 3
75523: PUSH
75524: LD_VAR 0 3
75528: PUSH
75529: LD_INT 1
75531: ARRAY
75532: ST_TO_ADDR
// end ; end ;
75533: LD_VAR 0 3
75537: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75538: LD_INT 0
75540: PPUSH
75541: PPUSH
// if not mc_bases then
75542: LD_EXP 23
75546: NOT
75547: IFFALSE 75551
// exit ;
75549: GO 75596
// if mc_bases [ base ] then
75551: LD_EXP 23
75555: PUSH
75556: LD_VAR 0 1
75560: ARRAY
75561: IFFALSE 75596
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75563: LD_ADDR_VAR 0 3
75567: PUSH
75568: LD_EXP 23
75572: PUSH
75573: LD_VAR 0 1
75577: ARRAY
75578: PPUSH
75579: LD_INT 30
75581: PUSH
75582: LD_VAR 0 2
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: PPUSH
75591: CALL_OW 72
75595: ST_TO_ADDR
// end ;
75596: LD_VAR 0 3
75600: RET
// export function MC_SetTame ( base , area ) ; begin
75601: LD_INT 0
75603: PPUSH
// if not mc_bases or not base then
75604: LD_EXP 23
75608: NOT
75609: PUSH
75610: LD_VAR 0 1
75614: NOT
75615: OR
75616: IFFALSE 75620
// exit ;
75618: GO 75645
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75620: LD_ADDR_EXP 51
75624: PUSH
75625: LD_EXP 51
75629: PPUSH
75630: LD_VAR 0 1
75634: PPUSH
75635: LD_VAR 0 2
75639: PPUSH
75640: CALL_OW 1
75644: ST_TO_ADDR
// end ;
75645: LD_VAR 0 3
75649: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75650: LD_INT 0
75652: PPUSH
75653: PPUSH
// if not mc_bases or not base then
75654: LD_EXP 23
75658: NOT
75659: PUSH
75660: LD_VAR 0 1
75664: NOT
75665: OR
75666: IFFALSE 75670
// exit ;
75668: GO 75772
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75670: LD_ADDR_VAR 0 4
75674: PUSH
75675: LD_EXP 23
75679: PUSH
75680: LD_VAR 0 1
75684: ARRAY
75685: PPUSH
75686: LD_INT 30
75688: PUSH
75689: LD_VAR 0 2
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PPUSH
75698: CALL_OW 72
75702: ST_TO_ADDR
// if not tmp then
75703: LD_VAR 0 4
75707: NOT
75708: IFFALSE 75712
// exit ;
75710: GO 75772
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75712: LD_ADDR_EXP 55
75716: PUSH
75717: LD_EXP 55
75721: PPUSH
75722: LD_VAR 0 1
75726: PPUSH
75727: LD_EXP 55
75731: PUSH
75732: LD_VAR 0 1
75736: ARRAY
75737: PPUSH
75738: LD_EXP 55
75742: PUSH
75743: LD_VAR 0 1
75747: ARRAY
75748: PUSH
75749: LD_INT 1
75751: PLUS
75752: PPUSH
75753: LD_VAR 0 4
75757: PUSH
75758: LD_INT 1
75760: ARRAY
75761: PPUSH
75762: CALL_OW 2
75766: PPUSH
75767: CALL_OW 1
75771: ST_TO_ADDR
// end ;
75772: LD_VAR 0 3
75776: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75777: LD_INT 0
75779: PPUSH
75780: PPUSH
// if not mc_bases or not base or not kinds then
75781: LD_EXP 23
75785: NOT
75786: PUSH
75787: LD_VAR 0 1
75791: NOT
75792: OR
75793: PUSH
75794: LD_VAR 0 2
75798: NOT
75799: OR
75800: IFFALSE 75804
// exit ;
75802: GO 75865
// for i in kinds do
75804: LD_ADDR_VAR 0 4
75808: PUSH
75809: LD_VAR 0 2
75813: PUSH
75814: FOR_IN
75815: IFFALSE 75863
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
75817: LD_ADDR_EXP 57
75821: PUSH
75822: LD_EXP 57
75826: PPUSH
75827: LD_VAR 0 1
75831: PUSH
75832: LD_EXP 57
75836: PUSH
75837: LD_VAR 0 1
75841: ARRAY
75842: PUSH
75843: LD_INT 1
75845: PLUS
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PPUSH
75851: LD_VAR 0 4
75855: PPUSH
75856: CALL 15990 0 3
75860: ST_TO_ADDR
75861: GO 75814
75863: POP
75864: POP
// end ;
75865: LD_VAR 0 3
75869: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75870: LD_INT 0
75872: PPUSH
// if not mc_bases or not base or not areas then
75873: LD_EXP 23
75877: NOT
75878: PUSH
75879: LD_VAR 0 1
75883: NOT
75884: OR
75885: PUSH
75886: LD_VAR 0 2
75890: NOT
75891: OR
75892: IFFALSE 75896
// exit ;
75894: GO 75921
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75896: LD_ADDR_EXP 41
75900: PUSH
75901: LD_EXP 41
75905: PPUSH
75906: LD_VAR 0 1
75910: PPUSH
75911: LD_VAR 0 2
75915: PPUSH
75916: CALL_OW 1
75920: ST_TO_ADDR
// end ;
75921: LD_VAR 0 3
75925: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75926: LD_INT 0
75928: PPUSH
// if not mc_bases or not base or not teleports_exit then
75929: LD_EXP 23
75933: NOT
75934: PUSH
75935: LD_VAR 0 1
75939: NOT
75940: OR
75941: PUSH
75942: LD_VAR 0 2
75946: NOT
75947: OR
75948: IFFALSE 75952
// exit ;
75950: GO 75977
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75952: LD_ADDR_EXP 58
75956: PUSH
75957: LD_EXP 58
75961: PPUSH
75962: LD_VAR 0 1
75966: PPUSH
75967: LD_VAR 0 2
75971: PPUSH
75972: CALL_OW 1
75976: ST_TO_ADDR
// end ;
75977: LD_VAR 0 3
75981: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75982: LD_INT 0
75984: PPUSH
75985: PPUSH
75986: PPUSH
// if not mc_bases or not base or not ext_list then
75987: LD_EXP 23
75991: NOT
75992: PUSH
75993: LD_VAR 0 1
75997: NOT
75998: OR
75999: PUSH
76000: LD_VAR 0 5
76004: NOT
76005: OR
76006: IFFALSE 76010
// exit ;
76008: GO 76183
// tmp := GetFacExtXYD ( x , y , d ) ;
76010: LD_ADDR_VAR 0 8
76014: PUSH
76015: LD_VAR 0 2
76019: PPUSH
76020: LD_VAR 0 3
76024: PPUSH
76025: LD_VAR 0 4
76029: PPUSH
76030: CALL 45377 0 3
76034: ST_TO_ADDR
// if not tmp then
76035: LD_VAR 0 8
76039: NOT
76040: IFFALSE 76044
// exit ;
76042: GO 76183
// for i in tmp do
76044: LD_ADDR_VAR 0 7
76048: PUSH
76049: LD_VAR 0 8
76053: PUSH
76054: FOR_IN
76055: IFFALSE 76181
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76057: LD_ADDR_EXP 28
76061: PUSH
76062: LD_EXP 28
76066: PPUSH
76067: LD_VAR 0 1
76071: PPUSH
76072: LD_EXP 28
76076: PUSH
76077: LD_VAR 0 1
76081: ARRAY
76082: PPUSH
76083: LD_EXP 28
76087: PUSH
76088: LD_VAR 0 1
76092: ARRAY
76093: PUSH
76094: LD_INT 1
76096: PLUS
76097: PPUSH
76098: LD_VAR 0 5
76102: PUSH
76103: LD_INT 1
76105: ARRAY
76106: PUSH
76107: LD_VAR 0 7
76111: PUSH
76112: LD_INT 1
76114: ARRAY
76115: PUSH
76116: LD_VAR 0 7
76120: PUSH
76121: LD_INT 2
76123: ARRAY
76124: PUSH
76125: LD_VAR 0 7
76129: PUSH
76130: LD_INT 3
76132: ARRAY
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: LIST
76138: LIST
76139: PPUSH
76140: CALL_OW 2
76144: PPUSH
76145: CALL_OW 1
76149: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76150: LD_ADDR_VAR 0 5
76154: PUSH
76155: LD_VAR 0 5
76159: PPUSH
76160: LD_INT 1
76162: PPUSH
76163: CALL_OW 3
76167: ST_TO_ADDR
// if not ext_list then
76168: LD_VAR 0 5
76172: NOT
76173: IFFALSE 76179
// exit ;
76175: POP
76176: POP
76177: GO 76183
// end ;
76179: GO 76054
76181: POP
76182: POP
// end ;
76183: LD_VAR 0 6
76187: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76188: LD_INT 0
76190: PPUSH
// if not mc_bases or not base or not weapon_list then
76191: LD_EXP 23
76195: NOT
76196: PUSH
76197: LD_VAR 0 1
76201: NOT
76202: OR
76203: PUSH
76204: LD_VAR 0 2
76208: NOT
76209: OR
76210: IFFALSE 76214
// exit ;
76212: GO 76239
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76214: LD_ADDR_EXP 62
76218: PUSH
76219: LD_EXP 62
76223: PPUSH
76224: LD_VAR 0 1
76228: PPUSH
76229: LD_VAR 0 2
76233: PPUSH
76234: CALL_OW 1
76238: ST_TO_ADDR
// end ;
76239: LD_VAR 0 3
76243: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76244: LD_INT 0
76246: PPUSH
// if not mc_bases or not base or not tech_list then
76247: LD_EXP 23
76251: NOT
76252: PUSH
76253: LD_VAR 0 1
76257: NOT
76258: OR
76259: PUSH
76260: LD_VAR 0 2
76264: NOT
76265: OR
76266: IFFALSE 76270
// exit ;
76268: GO 76295
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76270: LD_ADDR_EXP 50
76274: PUSH
76275: LD_EXP 50
76279: PPUSH
76280: LD_VAR 0 1
76284: PPUSH
76285: LD_VAR 0 2
76289: PPUSH
76290: CALL_OW 1
76294: ST_TO_ADDR
// end ;
76295: LD_VAR 0 3
76299: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76300: LD_INT 0
76302: PPUSH
// if not mc_bases or not parking_area or not base then
76303: LD_EXP 23
76307: NOT
76308: PUSH
76309: LD_VAR 0 2
76313: NOT
76314: OR
76315: PUSH
76316: LD_VAR 0 1
76320: NOT
76321: OR
76322: IFFALSE 76326
// exit ;
76324: GO 76351
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76326: LD_ADDR_EXP 47
76330: PUSH
76331: LD_EXP 47
76335: PPUSH
76336: LD_VAR 0 1
76340: PPUSH
76341: LD_VAR 0 2
76345: PPUSH
76346: CALL_OW 1
76350: ST_TO_ADDR
// end ;
76351: LD_VAR 0 3
76355: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76356: LD_INT 0
76358: PPUSH
// if not mc_bases or not base or not scan_area then
76359: LD_EXP 23
76363: NOT
76364: PUSH
76365: LD_VAR 0 1
76369: NOT
76370: OR
76371: PUSH
76372: LD_VAR 0 2
76376: NOT
76377: OR
76378: IFFALSE 76382
// exit ;
76380: GO 76407
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76382: LD_ADDR_EXP 48
76386: PUSH
76387: LD_EXP 48
76391: PPUSH
76392: LD_VAR 0 1
76396: PPUSH
76397: LD_VAR 0 2
76401: PPUSH
76402: CALL_OW 1
76406: ST_TO_ADDR
// end ;
76407: LD_VAR 0 3
76411: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76412: LD_INT 0
76414: PPUSH
76415: PPUSH
// if not mc_bases or not base then
76416: LD_EXP 23
76420: NOT
76421: PUSH
76422: LD_VAR 0 1
76426: NOT
76427: OR
76428: IFFALSE 76432
// exit ;
76430: GO 76496
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76432: LD_ADDR_VAR 0 3
76436: PUSH
76437: LD_INT 1
76439: PUSH
76440: LD_INT 2
76442: PUSH
76443: LD_INT 3
76445: PUSH
76446: LD_INT 4
76448: PUSH
76449: LD_INT 11
76451: PUSH
76452: EMPTY
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76459: LD_ADDR_EXP 50
76463: PUSH
76464: LD_EXP 50
76468: PPUSH
76469: LD_VAR 0 1
76473: PPUSH
76474: LD_EXP 50
76478: PUSH
76479: LD_VAR 0 1
76483: ARRAY
76484: PUSH
76485: LD_VAR 0 3
76489: DIFF
76490: PPUSH
76491: CALL_OW 1
76495: ST_TO_ADDR
// end ;
76496: LD_VAR 0 2
76500: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76501: LD_INT 0
76503: PPUSH
// result := mc_vehicles [ base ] ;
76504: LD_ADDR_VAR 0 3
76508: PUSH
76509: LD_EXP 42
76513: PUSH
76514: LD_VAR 0 1
76518: ARRAY
76519: ST_TO_ADDR
// if onlyCombat then
76520: LD_VAR 0 2
76524: IFFALSE 76702
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76526: LD_ADDR_VAR 0 3
76530: PUSH
76531: LD_VAR 0 3
76535: PUSH
76536: LD_VAR 0 3
76540: PPUSH
76541: LD_INT 2
76543: PUSH
76544: LD_INT 34
76546: PUSH
76547: LD_INT 12
76549: PUSH
76550: EMPTY
76551: LIST
76552: LIST
76553: PUSH
76554: LD_INT 34
76556: PUSH
76557: LD_INT 51
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: LD_INT 34
76566: PUSH
76567: LD_EXP 68
76571: PUSH
76572: EMPTY
76573: LIST
76574: LIST
76575: PUSH
76576: LD_INT 34
76578: PUSH
76579: LD_INT 32
76581: PUSH
76582: EMPTY
76583: LIST
76584: LIST
76585: PUSH
76586: LD_INT 34
76588: PUSH
76589: LD_INT 13
76591: PUSH
76592: EMPTY
76593: LIST
76594: LIST
76595: PUSH
76596: LD_INT 34
76598: PUSH
76599: LD_INT 52
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PUSH
76606: LD_INT 34
76608: PUSH
76609: LD_EXP 73
76613: PUSH
76614: EMPTY
76615: LIST
76616: LIST
76617: PUSH
76618: LD_INT 34
76620: PUSH
76621: LD_INT 14
76623: PUSH
76624: EMPTY
76625: LIST
76626: LIST
76627: PUSH
76628: LD_INT 34
76630: PUSH
76631: LD_INT 53
76633: PUSH
76634: EMPTY
76635: LIST
76636: LIST
76637: PUSH
76638: LD_INT 34
76640: PUSH
76641: LD_EXP 67
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 34
76652: PUSH
76653: LD_INT 31
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: LD_INT 34
76662: PUSH
76663: LD_INT 48
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PUSH
76670: LD_INT 34
76672: PUSH
76673: LD_INT 8
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: LIST
76684: LIST
76685: LIST
76686: LIST
76687: LIST
76688: LIST
76689: LIST
76690: LIST
76691: LIST
76692: LIST
76693: LIST
76694: LIST
76695: PPUSH
76696: CALL_OW 72
76700: DIFF
76701: ST_TO_ADDR
// end ; end_of_file
76702: LD_VAR 0 3
76706: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76707: LD_INT 0
76709: PPUSH
76710: PPUSH
76711: PPUSH
// if not mc_bases or not skirmish then
76712: LD_EXP 23
76716: NOT
76717: PUSH
76718: LD_EXP 21
76722: NOT
76723: OR
76724: IFFALSE 76728
// exit ;
76726: GO 76893
// for i = 1 to mc_bases do
76728: LD_ADDR_VAR 0 4
76732: PUSH
76733: DOUBLE
76734: LD_INT 1
76736: DEC
76737: ST_TO_ADDR
76738: LD_EXP 23
76742: PUSH
76743: FOR_TO
76744: IFFALSE 76891
// begin if sci in mc_bases [ i ] then
76746: LD_VAR 0 2
76750: PUSH
76751: LD_EXP 23
76755: PUSH
76756: LD_VAR 0 4
76760: ARRAY
76761: IN
76762: IFFALSE 76889
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76764: LD_ADDR_EXP 52
76768: PUSH
76769: LD_EXP 52
76773: PPUSH
76774: LD_VAR 0 4
76778: PUSH
76779: LD_EXP 52
76783: PUSH
76784: LD_VAR 0 4
76788: ARRAY
76789: PUSH
76790: LD_INT 1
76792: PLUS
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PPUSH
76798: LD_VAR 0 1
76802: PPUSH
76803: CALL 15990 0 3
76807: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76808: LD_ADDR_VAR 0 5
76812: PUSH
76813: LD_EXP 23
76817: PUSH
76818: LD_VAR 0 4
76822: ARRAY
76823: PPUSH
76824: LD_INT 2
76826: PUSH
76827: LD_INT 30
76829: PUSH
76830: LD_INT 0
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 30
76839: PUSH
76840: LD_INT 1
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: LIST
76851: PPUSH
76852: CALL_OW 72
76856: PPUSH
76857: LD_VAR 0 1
76861: PPUSH
76862: CALL_OW 74
76866: ST_TO_ADDR
// if tmp then
76867: LD_VAR 0 5
76871: IFFALSE 76887
// ComStandNearbyBuilding ( ape , tmp ) ;
76873: LD_VAR 0 1
76877: PPUSH
76878: LD_VAR 0 5
76882: PPUSH
76883: CALL 12568 0 2
// break ;
76887: GO 76891
// end ; end ;
76889: GO 76743
76891: POP
76892: POP
// end ;
76893: LD_VAR 0 3
76897: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76898: LD_INT 0
76900: PPUSH
76901: PPUSH
76902: PPUSH
// if not mc_bases or not skirmish then
76903: LD_EXP 23
76907: NOT
76908: PUSH
76909: LD_EXP 21
76913: NOT
76914: OR
76915: IFFALSE 76919
// exit ;
76917: GO 77008
// for i = 1 to mc_bases do
76919: LD_ADDR_VAR 0 4
76923: PUSH
76924: DOUBLE
76925: LD_INT 1
76927: DEC
76928: ST_TO_ADDR
76929: LD_EXP 23
76933: PUSH
76934: FOR_TO
76935: IFFALSE 77006
// begin if building in mc_busy_turret_list [ i ] then
76937: LD_VAR 0 1
76941: PUSH
76942: LD_EXP 33
76946: PUSH
76947: LD_VAR 0 4
76951: ARRAY
76952: IN
76953: IFFALSE 77004
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76955: LD_ADDR_VAR 0 5
76959: PUSH
76960: LD_EXP 33
76964: PUSH
76965: LD_VAR 0 4
76969: ARRAY
76970: PUSH
76971: LD_VAR 0 1
76975: DIFF
76976: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76977: LD_ADDR_EXP 33
76981: PUSH
76982: LD_EXP 33
76986: PPUSH
76987: LD_VAR 0 4
76991: PPUSH
76992: LD_VAR 0 5
76996: PPUSH
76997: CALL_OW 1
77001: ST_TO_ADDR
// break ;
77002: GO 77006
// end ; end ;
77004: GO 76934
77006: POP
77007: POP
// end ;
77008: LD_VAR 0 3
77012: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77013: LD_INT 0
77015: PPUSH
77016: PPUSH
77017: PPUSH
// if not mc_bases or not skirmish then
77018: LD_EXP 23
77022: NOT
77023: PUSH
77024: LD_EXP 21
77028: NOT
77029: OR
77030: IFFALSE 77034
// exit ;
77032: GO 77233
// for i = 1 to mc_bases do
77034: LD_ADDR_VAR 0 5
77038: PUSH
77039: DOUBLE
77040: LD_INT 1
77042: DEC
77043: ST_TO_ADDR
77044: LD_EXP 23
77048: PUSH
77049: FOR_TO
77050: IFFALSE 77231
// if building in mc_bases [ i ] then
77052: LD_VAR 0 1
77056: PUSH
77057: LD_EXP 23
77061: PUSH
77062: LD_VAR 0 5
77066: ARRAY
77067: IN
77068: IFFALSE 77229
// begin tmp := mc_bases [ i ] diff building ;
77070: LD_ADDR_VAR 0 6
77074: PUSH
77075: LD_EXP 23
77079: PUSH
77080: LD_VAR 0 5
77084: ARRAY
77085: PUSH
77086: LD_VAR 0 1
77090: DIFF
77091: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77092: LD_ADDR_EXP 23
77096: PUSH
77097: LD_EXP 23
77101: PPUSH
77102: LD_VAR 0 5
77106: PPUSH
77107: LD_VAR 0 6
77111: PPUSH
77112: CALL_OW 1
77116: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77117: LD_VAR 0 1
77121: PUSH
77122: LD_EXP 31
77126: PUSH
77127: LD_VAR 0 5
77131: ARRAY
77132: IN
77133: IFFALSE 77172
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77135: LD_ADDR_EXP 31
77139: PUSH
77140: LD_EXP 31
77144: PPUSH
77145: LD_VAR 0 5
77149: PPUSH
77150: LD_EXP 31
77154: PUSH
77155: LD_VAR 0 5
77159: ARRAY
77160: PUSH
77161: LD_VAR 0 1
77165: DIFF
77166: PPUSH
77167: CALL_OW 1
77171: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77172: LD_VAR 0 1
77176: PUSH
77177: LD_EXP 32
77181: PUSH
77182: LD_VAR 0 5
77186: ARRAY
77187: IN
77188: IFFALSE 77227
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77190: LD_ADDR_EXP 32
77194: PUSH
77195: LD_EXP 32
77199: PPUSH
77200: LD_VAR 0 5
77204: PPUSH
77205: LD_EXP 32
77209: PUSH
77210: LD_VAR 0 5
77214: ARRAY
77215: PUSH
77216: LD_VAR 0 1
77220: DIFF
77221: PPUSH
77222: CALL_OW 1
77226: ST_TO_ADDR
// break ;
77227: GO 77231
// end ;
77229: GO 77049
77231: POP
77232: POP
// end ;
77233: LD_VAR 0 4
77237: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77238: LD_INT 0
77240: PPUSH
77241: PPUSH
77242: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77243: LD_EXP 23
77247: NOT
77248: PUSH
77249: LD_EXP 21
77253: NOT
77254: OR
77255: PUSH
77256: LD_VAR 0 3
77260: PUSH
77261: LD_EXP 49
77265: IN
77266: NOT
77267: OR
77268: IFFALSE 77272
// exit ;
77270: GO 77395
// for i = 1 to mc_vehicles do
77272: LD_ADDR_VAR 0 6
77276: PUSH
77277: DOUBLE
77278: LD_INT 1
77280: DEC
77281: ST_TO_ADDR
77282: LD_EXP 42
77286: PUSH
77287: FOR_TO
77288: IFFALSE 77393
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77290: LD_VAR 0 2
77294: PUSH
77295: LD_EXP 42
77299: PUSH
77300: LD_VAR 0 6
77304: ARRAY
77305: IN
77306: PUSH
77307: LD_VAR 0 1
77311: PUSH
77312: LD_EXP 42
77316: PUSH
77317: LD_VAR 0 6
77321: ARRAY
77322: IN
77323: OR
77324: IFFALSE 77391
// begin tmp := mc_vehicles [ i ] diff old ;
77326: LD_ADDR_VAR 0 7
77330: PUSH
77331: LD_EXP 42
77335: PUSH
77336: LD_VAR 0 6
77340: ARRAY
77341: PUSH
77342: LD_VAR 0 2
77346: DIFF
77347: ST_TO_ADDR
// tmp := tmp diff new ;
77348: LD_ADDR_VAR 0 7
77352: PUSH
77353: LD_VAR 0 7
77357: PUSH
77358: LD_VAR 0 1
77362: DIFF
77363: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77364: LD_ADDR_EXP 42
77368: PUSH
77369: LD_EXP 42
77373: PPUSH
77374: LD_VAR 0 6
77378: PPUSH
77379: LD_VAR 0 7
77383: PPUSH
77384: CALL_OW 1
77388: ST_TO_ADDR
// break ;
77389: GO 77393
// end ;
77391: GO 77287
77393: POP
77394: POP
// end ;
77395: LD_VAR 0 5
77399: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77400: LD_INT 0
77402: PPUSH
77403: PPUSH
77404: PPUSH
77405: PPUSH
// if not mc_bases or not skirmish then
77406: LD_EXP 23
77410: NOT
77411: PUSH
77412: LD_EXP 21
77416: NOT
77417: OR
77418: IFFALSE 77422
// exit ;
77420: GO 77814
// side := GetSide ( vehicle ) ;
77422: LD_ADDR_VAR 0 5
77426: PUSH
77427: LD_VAR 0 1
77431: PPUSH
77432: CALL_OW 255
77436: ST_TO_ADDR
// for i = 1 to mc_bases do
77437: LD_ADDR_VAR 0 4
77441: PUSH
77442: DOUBLE
77443: LD_INT 1
77445: DEC
77446: ST_TO_ADDR
77447: LD_EXP 23
77451: PUSH
77452: FOR_TO
77453: IFFALSE 77812
// begin if factory in mc_bases [ i ] then
77455: LD_VAR 0 2
77459: PUSH
77460: LD_EXP 23
77464: PUSH
77465: LD_VAR 0 4
77469: ARRAY
77470: IN
77471: IFFALSE 77810
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77473: LD_EXP 45
77477: PUSH
77478: LD_VAR 0 4
77482: ARRAY
77483: PUSH
77484: LD_EXP 34
77488: PUSH
77489: LD_VAR 0 4
77493: ARRAY
77494: LESS
77495: PUSH
77496: LD_VAR 0 1
77500: PPUSH
77501: CALL_OW 264
77505: PUSH
77506: LD_INT 31
77508: PUSH
77509: LD_INT 32
77511: PUSH
77512: LD_INT 51
77514: PUSH
77515: LD_EXP 68
77519: PUSH
77520: LD_INT 12
77522: PUSH
77523: LD_INT 30
77525: PUSH
77526: LD_EXP 67
77530: PUSH
77531: LD_INT 11
77533: PUSH
77534: LD_INT 53
77536: PUSH
77537: LD_INT 14
77539: PUSH
77540: LD_EXP 71
77544: PUSH
77545: LD_INT 29
77547: PUSH
77548: LD_EXP 69
77552: PUSH
77553: LD_INT 13
77555: PUSH
77556: LD_INT 52
77558: PUSH
77559: LD_EXP 73
77563: PUSH
77564: LD_INT 48
77566: PUSH
77567: LD_INT 8
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: IN
77590: NOT
77591: AND
77592: IFFALSE 77640
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77594: LD_ADDR_EXP 45
77598: PUSH
77599: LD_EXP 45
77603: PPUSH
77604: LD_VAR 0 4
77608: PUSH
77609: LD_EXP 45
77613: PUSH
77614: LD_VAR 0 4
77618: ARRAY
77619: PUSH
77620: LD_INT 1
77622: PLUS
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PPUSH
77628: LD_VAR 0 1
77632: PPUSH
77633: CALL 15990 0 3
77637: ST_TO_ADDR
77638: GO 77684
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77640: LD_ADDR_EXP 42
77644: PUSH
77645: LD_EXP 42
77649: PPUSH
77650: LD_VAR 0 4
77654: PUSH
77655: LD_EXP 42
77659: PUSH
77660: LD_VAR 0 4
77664: ARRAY
77665: PUSH
77666: LD_INT 1
77668: PLUS
77669: PUSH
77670: EMPTY
77671: LIST
77672: LIST
77673: PPUSH
77674: LD_VAR 0 1
77678: PPUSH
77679: CALL 15990 0 3
77683: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77684: LD_VAR 0 1
77688: PPUSH
77689: CALL_OW 263
77693: PUSH
77694: LD_INT 2
77696: EQUAL
77697: IFFALSE 77726
// begin repeat wait ( 0 0$3 ) ;
77699: LD_INT 105
77701: PPUSH
77702: CALL_OW 67
// Connect ( vehicle ) ;
77706: LD_VAR 0 1
77710: PPUSH
77711: CALL 18961 0 1
// until IsControledBy ( vehicle ) ;
77715: LD_VAR 0 1
77719: PPUSH
77720: CALL_OW 312
77724: IFFALSE 77699
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77726: LD_VAR 0 1
77730: PPUSH
77731: LD_EXP 47
77735: PUSH
77736: LD_VAR 0 4
77740: ARRAY
77741: PPUSH
77742: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77746: LD_VAR 0 1
77750: PPUSH
77751: CALL_OW 263
77755: PUSH
77756: LD_INT 1
77758: NONEQUAL
77759: IFFALSE 77763
// break ;
77761: GO 77812
// repeat wait ( 0 0$1 ) ;
77763: LD_INT 35
77765: PPUSH
77766: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77770: LD_VAR 0 1
77774: PPUSH
77775: LD_EXP 47
77779: PUSH
77780: LD_VAR 0 4
77784: ARRAY
77785: PPUSH
77786: CALL_OW 308
77790: IFFALSE 77763
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77792: LD_VAR 0 1
77796: PPUSH
77797: CALL_OW 311
77801: PPUSH
77802: CALL_OW 121
// exit ;
77806: POP
77807: POP
77808: GO 77814
// end ; end ;
77810: GO 77452
77812: POP
77813: POP
// end ;
77814: LD_VAR 0 3
77818: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
77819: LD_INT 0
77821: PPUSH
77822: PPUSH
77823: PPUSH
77824: PPUSH
// if not mc_bases or not skirmish then
77825: LD_EXP 23
77829: NOT
77830: PUSH
77831: LD_EXP 21
77835: NOT
77836: OR
77837: IFFALSE 77841
// exit ;
77839: GO 78194
// repeat wait ( 0 0$1 ) ;
77841: LD_INT 35
77843: PPUSH
77844: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
77848: LD_VAR 0 2
77852: PPUSH
77853: LD_VAR 0 3
77857: PPUSH
77858: CALL_OW 284
77862: IFFALSE 77841
// if GetResourceTypeXY ( x , y ) = mat_artefact then
77864: LD_VAR 0 2
77868: PPUSH
77869: LD_VAR 0 3
77873: PPUSH
77874: CALL_OW 283
77878: PUSH
77879: LD_INT 4
77881: EQUAL
77882: IFFALSE 77886
// exit ;
77884: GO 78194
// for i = 1 to mc_bases do
77886: LD_ADDR_VAR 0 7
77890: PUSH
77891: DOUBLE
77892: LD_INT 1
77894: DEC
77895: ST_TO_ADDR
77896: LD_EXP 23
77900: PUSH
77901: FOR_TO
77902: IFFALSE 78192
// begin if mc_crates_area [ i ] then
77904: LD_EXP 41
77908: PUSH
77909: LD_VAR 0 7
77913: ARRAY
77914: IFFALSE 78025
// for j in mc_crates_area [ i ] do
77916: LD_ADDR_VAR 0 8
77920: PUSH
77921: LD_EXP 41
77925: PUSH
77926: LD_VAR 0 7
77930: ARRAY
77931: PUSH
77932: FOR_IN
77933: IFFALSE 78023
// if InArea ( x , y , j ) then
77935: LD_VAR 0 2
77939: PPUSH
77940: LD_VAR 0 3
77944: PPUSH
77945: LD_VAR 0 8
77949: PPUSH
77950: CALL_OW 309
77954: IFFALSE 78021
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77956: LD_ADDR_EXP 39
77960: PUSH
77961: LD_EXP 39
77965: PPUSH
77966: LD_VAR 0 7
77970: PUSH
77971: LD_EXP 39
77975: PUSH
77976: LD_VAR 0 7
77980: ARRAY
77981: PUSH
77982: LD_INT 1
77984: PLUS
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PPUSH
77990: LD_VAR 0 4
77994: PUSH
77995: LD_VAR 0 2
77999: PUSH
78000: LD_VAR 0 3
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: LIST
78009: PPUSH
78010: CALL 15990 0 3
78014: ST_TO_ADDR
// exit ;
78015: POP
78016: POP
78017: POP
78018: POP
78019: GO 78194
// end ;
78021: GO 77932
78023: POP
78024: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78025: LD_ADDR_VAR 0 9
78029: PUSH
78030: LD_EXP 23
78034: PUSH
78035: LD_VAR 0 7
78039: ARRAY
78040: PPUSH
78041: LD_INT 2
78043: PUSH
78044: LD_INT 30
78046: PUSH
78047: LD_INT 0
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: PUSH
78054: LD_INT 30
78056: PUSH
78057: LD_INT 1
78059: PUSH
78060: EMPTY
78061: LIST
78062: LIST
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: LIST
78068: PPUSH
78069: CALL_OW 72
78073: ST_TO_ADDR
// if not depot then
78074: LD_VAR 0 9
78078: NOT
78079: IFFALSE 78083
// continue ;
78081: GO 77901
// for j in depot do
78083: LD_ADDR_VAR 0 8
78087: PUSH
78088: LD_VAR 0 9
78092: PUSH
78093: FOR_IN
78094: IFFALSE 78188
// if GetDistUnitXY ( j , x , y ) < 30 then
78096: LD_VAR 0 8
78100: PPUSH
78101: LD_VAR 0 2
78105: PPUSH
78106: LD_VAR 0 3
78110: PPUSH
78111: CALL_OW 297
78115: PUSH
78116: LD_INT 30
78118: LESS
78119: IFFALSE 78186
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78121: LD_ADDR_EXP 39
78125: PUSH
78126: LD_EXP 39
78130: PPUSH
78131: LD_VAR 0 7
78135: PUSH
78136: LD_EXP 39
78140: PUSH
78141: LD_VAR 0 7
78145: ARRAY
78146: PUSH
78147: LD_INT 1
78149: PLUS
78150: PUSH
78151: EMPTY
78152: LIST
78153: LIST
78154: PPUSH
78155: LD_VAR 0 4
78159: PUSH
78160: LD_VAR 0 2
78164: PUSH
78165: LD_VAR 0 3
78169: PUSH
78170: EMPTY
78171: LIST
78172: LIST
78173: LIST
78174: PPUSH
78175: CALL 15990 0 3
78179: ST_TO_ADDR
// exit ;
78180: POP
78181: POP
78182: POP
78183: POP
78184: GO 78194
// end ;
78186: GO 78093
78188: POP
78189: POP
// end ;
78190: GO 77901
78192: POP
78193: POP
// end ;
78194: LD_VAR 0 6
78198: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78199: LD_INT 0
78201: PPUSH
78202: PPUSH
78203: PPUSH
78204: PPUSH
// if not mc_bases or not skirmish then
78205: LD_EXP 23
78209: NOT
78210: PUSH
78211: LD_EXP 21
78215: NOT
78216: OR
78217: IFFALSE 78221
// exit ;
78219: GO 78498
// side := GetSide ( lab ) ;
78221: LD_ADDR_VAR 0 4
78225: PUSH
78226: LD_VAR 0 2
78230: PPUSH
78231: CALL_OW 255
78235: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78236: LD_VAR 0 4
78240: PUSH
78241: LD_EXP 49
78245: IN
78246: NOT
78247: PUSH
78248: LD_EXP 50
78252: NOT
78253: OR
78254: PUSH
78255: LD_EXP 23
78259: NOT
78260: OR
78261: IFFALSE 78265
// exit ;
78263: GO 78498
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78265: LD_ADDR_EXP 50
78269: PUSH
78270: LD_EXP 50
78274: PPUSH
78275: LD_VAR 0 4
78279: PPUSH
78280: LD_EXP 50
78284: PUSH
78285: LD_VAR 0 4
78289: ARRAY
78290: PUSH
78291: LD_VAR 0 1
78295: DIFF
78296: PPUSH
78297: CALL_OW 1
78301: ST_TO_ADDR
// for i = 1 to mc_bases do
78302: LD_ADDR_VAR 0 5
78306: PUSH
78307: DOUBLE
78308: LD_INT 1
78310: DEC
78311: ST_TO_ADDR
78312: LD_EXP 23
78316: PUSH
78317: FOR_TO
78318: IFFALSE 78496
// begin if lab in mc_bases [ i ] then
78320: LD_VAR 0 2
78324: PUSH
78325: LD_EXP 23
78329: PUSH
78330: LD_VAR 0 5
78334: ARRAY
78335: IN
78336: IFFALSE 78494
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78338: LD_VAR 0 1
78342: PUSH
78343: LD_INT 11
78345: PUSH
78346: LD_INT 4
78348: PUSH
78349: LD_INT 3
78351: PUSH
78352: LD_INT 2
78354: PUSH
78355: EMPTY
78356: LIST
78357: LIST
78358: LIST
78359: LIST
78360: IN
78361: PUSH
78362: LD_EXP 53
78366: PUSH
78367: LD_VAR 0 5
78371: ARRAY
78372: AND
78373: IFFALSE 78494
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78375: LD_ADDR_VAR 0 6
78379: PUSH
78380: LD_EXP 53
78384: PUSH
78385: LD_VAR 0 5
78389: ARRAY
78390: PUSH
78391: LD_INT 1
78393: ARRAY
78394: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78395: LD_ADDR_EXP 53
78399: PUSH
78400: LD_EXP 53
78404: PPUSH
78405: LD_VAR 0 5
78409: PPUSH
78410: EMPTY
78411: PPUSH
78412: CALL_OW 1
78416: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78417: LD_VAR 0 6
78421: PPUSH
78422: LD_INT 0
78424: PPUSH
78425: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78429: LD_VAR 0 6
78433: PPUSH
78434: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78438: LD_ADDR_EXP 52
78442: PUSH
78443: LD_EXP 52
78447: PPUSH
78448: LD_VAR 0 5
78452: PPUSH
78453: LD_EXP 52
78457: PUSH
78458: LD_VAR 0 5
78462: ARRAY
78463: PPUSH
78464: LD_INT 1
78466: PPUSH
78467: LD_VAR 0 6
78471: PPUSH
78472: CALL_OW 2
78476: PPUSH
78477: CALL_OW 1
78481: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78482: LD_VAR 0 5
78486: PPUSH
78487: LD_INT 112
78489: PPUSH
78490: CALL 55017 0 2
// end ; end ; end ;
78494: GO 78317
78496: POP
78497: POP
// end ;
78498: LD_VAR 0 3
78502: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78503: LD_INT 0
78505: PPUSH
78506: PPUSH
78507: PPUSH
78508: PPUSH
78509: PPUSH
78510: PPUSH
78511: PPUSH
78512: PPUSH
// if not mc_bases or not skirmish then
78513: LD_EXP 23
78517: NOT
78518: PUSH
78519: LD_EXP 21
78523: NOT
78524: OR
78525: IFFALSE 78529
// exit ;
78527: GO 79900
// for i = 1 to mc_bases do
78529: LD_ADDR_VAR 0 3
78533: PUSH
78534: DOUBLE
78535: LD_INT 1
78537: DEC
78538: ST_TO_ADDR
78539: LD_EXP 23
78543: PUSH
78544: FOR_TO
78545: IFFALSE 79898
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78547: LD_VAR 0 1
78551: PUSH
78552: LD_EXP 23
78556: PUSH
78557: LD_VAR 0 3
78561: ARRAY
78562: IN
78563: PUSH
78564: LD_VAR 0 1
78568: PUSH
78569: LD_EXP 30
78573: PUSH
78574: LD_VAR 0 3
78578: ARRAY
78579: IN
78580: OR
78581: PUSH
78582: LD_VAR 0 1
78586: PUSH
78587: LD_EXP 45
78591: PUSH
78592: LD_VAR 0 3
78596: ARRAY
78597: IN
78598: OR
78599: PUSH
78600: LD_VAR 0 1
78604: PUSH
78605: LD_EXP 42
78609: PUSH
78610: LD_VAR 0 3
78614: ARRAY
78615: IN
78616: OR
78617: PUSH
78618: LD_VAR 0 1
78622: PUSH
78623: LD_EXP 52
78627: PUSH
78628: LD_VAR 0 3
78632: ARRAY
78633: IN
78634: OR
78635: PUSH
78636: LD_VAR 0 1
78640: PUSH
78641: LD_EXP 53
78645: PUSH
78646: LD_VAR 0 3
78650: ARRAY
78651: IN
78652: OR
78653: IFFALSE 79896
// begin if un in mc_ape [ i ] then
78655: LD_VAR 0 1
78659: PUSH
78660: LD_EXP 52
78664: PUSH
78665: LD_VAR 0 3
78669: ARRAY
78670: IN
78671: IFFALSE 78710
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78673: LD_ADDR_EXP 52
78677: PUSH
78678: LD_EXP 52
78682: PPUSH
78683: LD_VAR 0 3
78687: PPUSH
78688: LD_EXP 52
78692: PUSH
78693: LD_VAR 0 3
78697: ARRAY
78698: PUSH
78699: LD_VAR 0 1
78703: DIFF
78704: PPUSH
78705: CALL_OW 1
78709: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78710: LD_VAR 0 1
78714: PUSH
78715: LD_EXP 53
78719: PUSH
78720: LD_VAR 0 3
78724: ARRAY
78725: IN
78726: IFFALSE 78750
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78728: LD_ADDR_EXP 53
78732: PUSH
78733: LD_EXP 53
78737: PPUSH
78738: LD_VAR 0 3
78742: PPUSH
78743: EMPTY
78744: PPUSH
78745: CALL_OW 1
78749: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78750: LD_VAR 0 1
78754: PPUSH
78755: CALL_OW 247
78759: PUSH
78760: LD_INT 2
78762: EQUAL
78763: PUSH
78764: LD_VAR 0 1
78768: PPUSH
78769: CALL_OW 110
78773: PUSH
78774: LD_INT 20
78776: EQUAL
78777: PUSH
78778: LD_VAR 0 1
78782: PUSH
78783: LD_EXP 45
78787: PUSH
78788: LD_VAR 0 3
78792: ARRAY
78793: IN
78794: OR
78795: PUSH
78796: LD_VAR 0 1
78800: PPUSH
78801: CALL_OW 264
78805: PUSH
78806: LD_INT 12
78808: PUSH
78809: LD_INT 51
78811: PUSH
78812: LD_EXP 68
78816: PUSH
78817: LD_INT 32
78819: PUSH
78820: LD_INT 13
78822: PUSH
78823: LD_INT 52
78825: PUSH
78826: LD_INT 31
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: LIST
78837: IN
78838: OR
78839: AND
78840: IFFALSE 79148
// begin if un in mc_defender [ i ] then
78842: LD_VAR 0 1
78846: PUSH
78847: LD_EXP 45
78851: PUSH
78852: LD_VAR 0 3
78856: ARRAY
78857: IN
78858: IFFALSE 78897
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78860: LD_ADDR_EXP 45
78864: PUSH
78865: LD_EXP 45
78869: PPUSH
78870: LD_VAR 0 3
78874: PPUSH
78875: LD_EXP 45
78879: PUSH
78880: LD_VAR 0 3
78884: ARRAY
78885: PUSH
78886: LD_VAR 0 1
78890: DIFF
78891: PPUSH
78892: CALL_OW 1
78896: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78897: LD_ADDR_VAR 0 8
78901: PUSH
78902: LD_VAR 0 3
78906: PPUSH
78907: LD_INT 3
78909: PPUSH
78910: CALL 75538 0 2
78914: ST_TO_ADDR
// if fac then
78915: LD_VAR 0 8
78919: IFFALSE 79148
// begin for j in fac do
78921: LD_ADDR_VAR 0 4
78925: PUSH
78926: LD_VAR 0 8
78930: PUSH
78931: FOR_IN
78932: IFFALSE 79146
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78934: LD_ADDR_VAR 0 9
78938: PUSH
78939: LD_VAR 0 8
78943: PPUSH
78944: LD_VAR 0 1
78948: PPUSH
78949: CALL_OW 265
78953: PPUSH
78954: LD_VAR 0 1
78958: PPUSH
78959: CALL_OW 262
78963: PPUSH
78964: LD_VAR 0 1
78968: PPUSH
78969: CALL_OW 263
78973: PPUSH
78974: LD_VAR 0 1
78978: PPUSH
78979: CALL_OW 264
78983: PPUSH
78984: CALL 13486 0 5
78988: ST_TO_ADDR
// if components then
78989: LD_VAR 0 9
78993: IFFALSE 79144
// begin if GetWeapon ( un ) = ar_control_tower then
78995: LD_VAR 0 1
78999: PPUSH
79000: CALL_OW 264
79004: PUSH
79005: LD_INT 31
79007: EQUAL
79008: IFFALSE 79125
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79010: LD_VAR 0 1
79014: PPUSH
79015: CALL_OW 311
79019: PPUSH
79020: LD_INT 0
79022: PPUSH
79023: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79027: LD_ADDR_EXP 63
79031: PUSH
79032: LD_EXP 63
79036: PPUSH
79037: LD_VAR 0 3
79041: PPUSH
79042: LD_EXP 63
79046: PUSH
79047: LD_VAR 0 3
79051: ARRAY
79052: PUSH
79053: LD_VAR 0 1
79057: PPUSH
79058: CALL_OW 311
79062: DIFF
79063: PPUSH
79064: CALL_OW 1
79068: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79069: LD_ADDR_VAR 0 7
79073: PUSH
79074: LD_EXP 44
79078: PUSH
79079: LD_VAR 0 3
79083: ARRAY
79084: PPUSH
79085: LD_INT 1
79087: PPUSH
79088: LD_VAR 0 9
79092: PPUSH
79093: CALL_OW 2
79097: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79098: LD_ADDR_EXP 44
79102: PUSH
79103: LD_EXP 44
79107: PPUSH
79108: LD_VAR 0 3
79112: PPUSH
79113: LD_VAR 0 7
79117: PPUSH
79118: CALL_OW 1
79122: ST_TO_ADDR
// end else
79123: GO 79142
// MC_InsertProduceList ( i , [ components ] ) ;
79125: LD_VAR 0 3
79129: PPUSH
79130: LD_VAR 0 9
79134: PUSH
79135: EMPTY
79136: LIST
79137: PPUSH
79138: CALL 75083 0 2
// break ;
79142: GO 79146
// end ; end ;
79144: GO 78931
79146: POP
79147: POP
// end ; end ; if GetType ( un ) = unit_building then
79148: LD_VAR 0 1
79152: PPUSH
79153: CALL_OW 247
79157: PUSH
79158: LD_INT 3
79160: EQUAL
79161: IFFALSE 79564
// begin btype := GetBType ( un ) ;
79163: LD_ADDR_VAR 0 5
79167: PUSH
79168: LD_VAR 0 1
79172: PPUSH
79173: CALL_OW 266
79177: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79178: LD_VAR 0 5
79182: PUSH
79183: LD_INT 29
79185: PUSH
79186: LD_INT 30
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: IN
79193: IFFALSE 79266
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79195: LD_VAR 0 1
79199: PPUSH
79200: CALL_OW 250
79204: PPUSH
79205: LD_VAR 0 1
79209: PPUSH
79210: CALL_OW 251
79214: PPUSH
79215: LD_VAR 0 1
79219: PPUSH
79220: CALL_OW 255
79224: PPUSH
79225: CALL_OW 440
79229: NOT
79230: IFFALSE 79266
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79232: LD_VAR 0 1
79236: PPUSH
79237: CALL_OW 250
79241: PPUSH
79242: LD_VAR 0 1
79246: PPUSH
79247: CALL_OW 251
79251: PPUSH
79252: LD_VAR 0 1
79256: PPUSH
79257: CALL_OW 255
79261: PPUSH
79262: CALL_OW 441
// end ; if btype = b_warehouse then
79266: LD_VAR 0 5
79270: PUSH
79271: LD_INT 1
79273: EQUAL
79274: IFFALSE 79292
// begin btype := b_depot ;
79276: LD_ADDR_VAR 0 5
79280: PUSH
79281: LD_INT 0
79283: ST_TO_ADDR
// pos := 1 ;
79284: LD_ADDR_VAR 0 6
79288: PUSH
79289: LD_INT 1
79291: ST_TO_ADDR
// end ; if btype = b_factory then
79292: LD_VAR 0 5
79296: PUSH
79297: LD_INT 3
79299: EQUAL
79300: IFFALSE 79318
// begin btype := b_workshop ;
79302: LD_ADDR_VAR 0 5
79306: PUSH
79307: LD_INT 2
79309: ST_TO_ADDR
// pos := 1 ;
79310: LD_ADDR_VAR 0 6
79314: PUSH
79315: LD_INT 1
79317: ST_TO_ADDR
// end ; if btype = b_barracks then
79318: LD_VAR 0 5
79322: PUSH
79323: LD_INT 5
79325: EQUAL
79326: IFFALSE 79336
// btype := b_armoury ;
79328: LD_ADDR_VAR 0 5
79332: PUSH
79333: LD_INT 4
79335: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79336: LD_VAR 0 5
79340: PUSH
79341: LD_INT 7
79343: PUSH
79344: LD_INT 8
79346: PUSH
79347: EMPTY
79348: LIST
79349: LIST
79350: IN
79351: IFFALSE 79361
// btype := b_lab ;
79353: LD_ADDR_VAR 0 5
79357: PUSH
79358: LD_INT 6
79360: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79361: LD_ADDR_EXP 28
79365: PUSH
79366: LD_EXP 28
79370: PPUSH
79371: LD_VAR 0 3
79375: PUSH
79376: LD_EXP 28
79380: PUSH
79381: LD_VAR 0 3
79385: ARRAY
79386: PUSH
79387: LD_INT 1
79389: PLUS
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PPUSH
79395: LD_VAR 0 5
79399: PUSH
79400: LD_VAR 0 1
79404: PPUSH
79405: CALL_OW 250
79409: PUSH
79410: LD_VAR 0 1
79414: PPUSH
79415: CALL_OW 251
79419: PUSH
79420: LD_VAR 0 1
79424: PPUSH
79425: CALL_OW 254
79429: PUSH
79430: EMPTY
79431: LIST
79432: LIST
79433: LIST
79434: LIST
79435: PPUSH
79436: CALL 15990 0 3
79440: ST_TO_ADDR
// if pos = 1 then
79441: LD_VAR 0 6
79445: PUSH
79446: LD_INT 1
79448: EQUAL
79449: IFFALSE 79564
// begin tmp := mc_build_list [ i ] ;
79451: LD_ADDR_VAR 0 7
79455: PUSH
79456: LD_EXP 28
79460: PUSH
79461: LD_VAR 0 3
79465: ARRAY
79466: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79467: LD_VAR 0 7
79471: PPUSH
79472: LD_INT 2
79474: PUSH
79475: LD_INT 30
79477: PUSH
79478: LD_INT 0
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: LD_INT 30
79487: PUSH
79488: LD_INT 1
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: LIST
79499: PPUSH
79500: CALL_OW 72
79504: IFFALSE 79514
// pos := 2 ;
79506: LD_ADDR_VAR 0 6
79510: PUSH
79511: LD_INT 2
79513: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79514: LD_ADDR_VAR 0 7
79518: PUSH
79519: LD_VAR 0 7
79523: PPUSH
79524: LD_VAR 0 6
79528: PPUSH
79529: LD_VAR 0 7
79533: PPUSH
79534: CALL 16316 0 3
79538: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79539: LD_ADDR_EXP 28
79543: PUSH
79544: LD_EXP 28
79548: PPUSH
79549: LD_VAR 0 3
79553: PPUSH
79554: LD_VAR 0 7
79558: PPUSH
79559: CALL_OW 1
79563: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79564: LD_VAR 0 1
79568: PUSH
79569: LD_EXP 23
79573: PUSH
79574: LD_VAR 0 3
79578: ARRAY
79579: IN
79580: IFFALSE 79619
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79582: LD_ADDR_EXP 23
79586: PUSH
79587: LD_EXP 23
79591: PPUSH
79592: LD_VAR 0 3
79596: PPUSH
79597: LD_EXP 23
79601: PUSH
79602: LD_VAR 0 3
79606: ARRAY
79607: PUSH
79608: LD_VAR 0 1
79612: DIFF
79613: PPUSH
79614: CALL_OW 1
79618: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79619: LD_VAR 0 1
79623: PUSH
79624: LD_EXP 30
79628: PUSH
79629: LD_VAR 0 3
79633: ARRAY
79634: IN
79635: IFFALSE 79674
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79637: LD_ADDR_EXP 30
79641: PUSH
79642: LD_EXP 30
79646: PPUSH
79647: LD_VAR 0 3
79651: PPUSH
79652: LD_EXP 30
79656: PUSH
79657: LD_VAR 0 3
79661: ARRAY
79662: PUSH
79663: LD_VAR 0 1
79667: DIFF
79668: PPUSH
79669: CALL_OW 1
79673: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79674: LD_VAR 0 1
79678: PUSH
79679: LD_EXP 42
79683: PUSH
79684: LD_VAR 0 3
79688: ARRAY
79689: IN
79690: IFFALSE 79729
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79692: LD_ADDR_EXP 42
79696: PUSH
79697: LD_EXP 42
79701: PPUSH
79702: LD_VAR 0 3
79706: PPUSH
79707: LD_EXP 42
79711: PUSH
79712: LD_VAR 0 3
79716: ARRAY
79717: PUSH
79718: LD_VAR 0 1
79722: DIFF
79723: PPUSH
79724: CALL_OW 1
79728: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79729: LD_VAR 0 1
79733: PUSH
79734: LD_EXP 45
79738: PUSH
79739: LD_VAR 0 3
79743: ARRAY
79744: IN
79745: IFFALSE 79784
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79747: LD_ADDR_EXP 45
79751: PUSH
79752: LD_EXP 45
79756: PPUSH
79757: LD_VAR 0 3
79761: PPUSH
79762: LD_EXP 45
79766: PUSH
79767: LD_VAR 0 3
79771: ARRAY
79772: PUSH
79773: LD_VAR 0 1
79777: DIFF
79778: PPUSH
79779: CALL_OW 1
79783: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79784: LD_VAR 0 1
79788: PUSH
79789: LD_EXP 32
79793: PUSH
79794: LD_VAR 0 3
79798: ARRAY
79799: IN
79800: IFFALSE 79839
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79802: LD_ADDR_EXP 32
79806: PUSH
79807: LD_EXP 32
79811: PPUSH
79812: LD_VAR 0 3
79816: PPUSH
79817: LD_EXP 32
79821: PUSH
79822: LD_VAR 0 3
79826: ARRAY
79827: PUSH
79828: LD_VAR 0 1
79832: DIFF
79833: PPUSH
79834: CALL_OW 1
79838: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
79839: LD_VAR 0 1
79843: PUSH
79844: LD_EXP 31
79848: PUSH
79849: LD_VAR 0 3
79853: ARRAY
79854: IN
79855: IFFALSE 79894
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
79857: LD_ADDR_EXP 31
79861: PUSH
79862: LD_EXP 31
79866: PPUSH
79867: LD_VAR 0 3
79871: PPUSH
79872: LD_EXP 31
79876: PUSH
79877: LD_VAR 0 3
79881: ARRAY
79882: PUSH
79883: LD_VAR 0 1
79887: DIFF
79888: PPUSH
79889: CALL_OW 1
79893: ST_TO_ADDR
// end ; break ;
79894: GO 79898
// end ;
79896: GO 78544
79898: POP
79899: POP
// end ;
79900: LD_VAR 0 2
79904: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79905: LD_INT 0
79907: PPUSH
79908: PPUSH
79909: PPUSH
// if not mc_bases or not skirmish then
79910: LD_EXP 23
79914: NOT
79915: PUSH
79916: LD_EXP 21
79920: NOT
79921: OR
79922: IFFALSE 79926
// exit ;
79924: GO 80141
// for i = 1 to mc_bases do
79926: LD_ADDR_VAR 0 3
79930: PUSH
79931: DOUBLE
79932: LD_INT 1
79934: DEC
79935: ST_TO_ADDR
79936: LD_EXP 23
79940: PUSH
79941: FOR_TO
79942: IFFALSE 80139
// begin if building in mc_construct_list [ i ] then
79944: LD_VAR 0 1
79948: PUSH
79949: LD_EXP 30
79953: PUSH
79954: LD_VAR 0 3
79958: ARRAY
79959: IN
79960: IFFALSE 80137
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79962: LD_ADDR_EXP 30
79966: PUSH
79967: LD_EXP 30
79971: PPUSH
79972: LD_VAR 0 3
79976: PPUSH
79977: LD_EXP 30
79981: PUSH
79982: LD_VAR 0 3
79986: ARRAY
79987: PUSH
79988: LD_VAR 0 1
79992: DIFF
79993: PPUSH
79994: CALL_OW 1
79998: ST_TO_ADDR
// if building in mc_lab [ i ] then
79999: LD_VAR 0 1
80003: PUSH
80004: LD_EXP 56
80008: PUSH
80009: LD_VAR 0 3
80013: ARRAY
80014: IN
80015: IFFALSE 80070
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80017: LD_ADDR_EXP 57
80021: PUSH
80022: LD_EXP 57
80026: PPUSH
80027: LD_VAR 0 3
80031: PPUSH
80032: LD_EXP 57
80036: PUSH
80037: LD_VAR 0 3
80041: ARRAY
80042: PPUSH
80043: LD_INT 1
80045: PPUSH
80046: LD_EXP 57
80050: PUSH
80051: LD_VAR 0 3
80055: ARRAY
80056: PPUSH
80057: LD_INT 0
80059: PPUSH
80060: CALL 15408 0 4
80064: PPUSH
80065: CALL_OW 1
80069: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80070: LD_VAR 0 1
80074: PUSH
80075: LD_EXP 23
80079: PUSH
80080: LD_VAR 0 3
80084: ARRAY
80085: IN
80086: NOT
80087: IFFALSE 80133
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80089: LD_ADDR_EXP 23
80093: PUSH
80094: LD_EXP 23
80098: PPUSH
80099: LD_VAR 0 3
80103: PUSH
80104: LD_EXP 23
80108: PUSH
80109: LD_VAR 0 3
80113: ARRAY
80114: PUSH
80115: LD_INT 1
80117: PLUS
80118: PUSH
80119: EMPTY
80120: LIST
80121: LIST
80122: PPUSH
80123: LD_VAR 0 1
80127: PPUSH
80128: CALL 15990 0 3
80132: ST_TO_ADDR
// exit ;
80133: POP
80134: POP
80135: GO 80141
// end ; end ;
80137: GO 79941
80139: POP
80140: POP
// end ;
80141: LD_VAR 0 2
80145: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80146: LD_INT 0
80148: PPUSH
80149: PPUSH
80150: PPUSH
80151: PPUSH
80152: PPUSH
80153: PPUSH
80154: PPUSH
// if not mc_bases or not skirmish then
80155: LD_EXP 23
80159: NOT
80160: PUSH
80161: LD_EXP 21
80165: NOT
80166: OR
80167: IFFALSE 80171
// exit ;
80169: GO 80832
// for i = 1 to mc_bases do
80171: LD_ADDR_VAR 0 3
80175: PUSH
80176: DOUBLE
80177: LD_INT 1
80179: DEC
80180: ST_TO_ADDR
80181: LD_EXP 23
80185: PUSH
80186: FOR_TO
80187: IFFALSE 80830
// begin if building in mc_construct_list [ i ] then
80189: LD_VAR 0 1
80193: PUSH
80194: LD_EXP 30
80198: PUSH
80199: LD_VAR 0 3
80203: ARRAY
80204: IN
80205: IFFALSE 80828
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80207: LD_ADDR_EXP 30
80211: PUSH
80212: LD_EXP 30
80216: PPUSH
80217: LD_VAR 0 3
80221: PPUSH
80222: LD_EXP 30
80226: PUSH
80227: LD_VAR 0 3
80231: ARRAY
80232: PUSH
80233: LD_VAR 0 1
80237: DIFF
80238: PPUSH
80239: CALL_OW 1
80243: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80244: LD_ADDR_EXP 23
80248: PUSH
80249: LD_EXP 23
80253: PPUSH
80254: LD_VAR 0 3
80258: PUSH
80259: LD_EXP 23
80263: PUSH
80264: LD_VAR 0 3
80268: ARRAY
80269: PUSH
80270: LD_INT 1
80272: PLUS
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PPUSH
80278: LD_VAR 0 1
80282: PPUSH
80283: CALL 15990 0 3
80287: ST_TO_ADDR
// btype := GetBType ( building ) ;
80288: LD_ADDR_VAR 0 5
80292: PUSH
80293: LD_VAR 0 1
80297: PPUSH
80298: CALL_OW 266
80302: ST_TO_ADDR
// side := GetSide ( building ) ;
80303: LD_ADDR_VAR 0 8
80307: PUSH
80308: LD_VAR 0 1
80312: PPUSH
80313: CALL_OW 255
80317: ST_TO_ADDR
// if btype = b_lab then
80318: LD_VAR 0 5
80322: PUSH
80323: LD_INT 6
80325: EQUAL
80326: IFFALSE 80376
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80328: LD_ADDR_EXP 56
80332: PUSH
80333: LD_EXP 56
80337: PPUSH
80338: LD_VAR 0 3
80342: PUSH
80343: LD_EXP 56
80347: PUSH
80348: LD_VAR 0 3
80352: ARRAY
80353: PUSH
80354: LD_INT 1
80356: PLUS
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PPUSH
80362: LD_VAR 0 1
80366: PPUSH
80367: CALL 15990 0 3
80371: ST_TO_ADDR
// exit ;
80372: POP
80373: POP
80374: GO 80832
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80376: LD_VAR 0 5
80380: PUSH
80381: LD_INT 0
80383: PUSH
80384: LD_INT 2
80386: PUSH
80387: LD_INT 4
80389: PUSH
80390: EMPTY
80391: LIST
80392: LIST
80393: LIST
80394: IN
80395: IFFALSE 80519
// begin if btype = b_armoury then
80397: LD_VAR 0 5
80401: PUSH
80402: LD_INT 4
80404: EQUAL
80405: IFFALSE 80415
// btype := b_barracks ;
80407: LD_ADDR_VAR 0 5
80411: PUSH
80412: LD_INT 5
80414: ST_TO_ADDR
// if btype = b_depot then
80415: LD_VAR 0 5
80419: PUSH
80420: LD_INT 0
80422: EQUAL
80423: IFFALSE 80433
// btype := b_warehouse ;
80425: LD_ADDR_VAR 0 5
80429: PUSH
80430: LD_INT 1
80432: ST_TO_ADDR
// if btype = b_workshop then
80433: LD_VAR 0 5
80437: PUSH
80438: LD_INT 2
80440: EQUAL
80441: IFFALSE 80451
// btype := b_factory ;
80443: LD_ADDR_VAR 0 5
80447: PUSH
80448: LD_INT 3
80450: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80451: LD_VAR 0 5
80455: PPUSH
80456: LD_VAR 0 8
80460: PPUSH
80461: CALL_OW 323
80465: PUSH
80466: LD_INT 1
80468: EQUAL
80469: IFFALSE 80515
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80471: LD_ADDR_EXP 55
80475: PUSH
80476: LD_EXP 55
80480: PPUSH
80481: LD_VAR 0 3
80485: PUSH
80486: LD_EXP 55
80490: PUSH
80491: LD_VAR 0 3
80495: ARRAY
80496: PUSH
80497: LD_INT 1
80499: PLUS
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PPUSH
80505: LD_VAR 0 1
80509: PPUSH
80510: CALL 15990 0 3
80514: ST_TO_ADDR
// exit ;
80515: POP
80516: POP
80517: GO 80832
// end ; if btype in [ b_bunker , b_turret ] then
80519: LD_VAR 0 5
80523: PUSH
80524: LD_INT 32
80526: PUSH
80527: LD_INT 33
80529: PUSH
80530: EMPTY
80531: LIST
80532: LIST
80533: IN
80534: IFFALSE 80824
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80536: LD_ADDR_EXP 31
80540: PUSH
80541: LD_EXP 31
80545: PPUSH
80546: LD_VAR 0 3
80550: PUSH
80551: LD_EXP 31
80555: PUSH
80556: LD_VAR 0 3
80560: ARRAY
80561: PUSH
80562: LD_INT 1
80564: PLUS
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PPUSH
80570: LD_VAR 0 1
80574: PPUSH
80575: CALL 15990 0 3
80579: ST_TO_ADDR
// if btype = b_bunker then
80580: LD_VAR 0 5
80584: PUSH
80585: LD_INT 32
80587: EQUAL
80588: IFFALSE 80824
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80590: LD_ADDR_EXP 32
80594: PUSH
80595: LD_EXP 32
80599: PPUSH
80600: LD_VAR 0 3
80604: PUSH
80605: LD_EXP 32
80609: PUSH
80610: LD_VAR 0 3
80614: ARRAY
80615: PUSH
80616: LD_INT 1
80618: PLUS
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PPUSH
80624: LD_VAR 0 1
80628: PPUSH
80629: CALL 15990 0 3
80633: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80634: LD_ADDR_VAR 0 6
80638: PUSH
80639: LD_EXP 23
80643: PUSH
80644: LD_VAR 0 3
80648: ARRAY
80649: PPUSH
80650: LD_INT 25
80652: PUSH
80653: LD_INT 1
80655: PUSH
80656: EMPTY
80657: LIST
80658: LIST
80659: PUSH
80660: LD_INT 3
80662: PUSH
80663: LD_INT 54
80665: PUSH
80666: EMPTY
80667: LIST
80668: PUSH
80669: EMPTY
80670: LIST
80671: LIST
80672: PUSH
80673: EMPTY
80674: LIST
80675: LIST
80676: PPUSH
80677: CALL_OW 72
80681: ST_TO_ADDR
// if tmp then
80682: LD_VAR 0 6
80686: IFFALSE 80692
// exit ;
80688: POP
80689: POP
80690: GO 80832
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80692: LD_ADDR_VAR 0 6
80696: PUSH
80697: LD_EXP 23
80701: PUSH
80702: LD_VAR 0 3
80706: ARRAY
80707: PPUSH
80708: LD_INT 2
80710: PUSH
80711: LD_INT 30
80713: PUSH
80714: LD_INT 4
80716: PUSH
80717: EMPTY
80718: LIST
80719: LIST
80720: PUSH
80721: LD_INT 30
80723: PUSH
80724: LD_INT 5
80726: PUSH
80727: EMPTY
80728: LIST
80729: LIST
80730: PUSH
80731: EMPTY
80732: LIST
80733: LIST
80734: LIST
80735: PPUSH
80736: CALL_OW 72
80740: ST_TO_ADDR
// if not tmp then
80741: LD_VAR 0 6
80745: NOT
80746: IFFALSE 80752
// exit ;
80748: POP
80749: POP
80750: GO 80832
// for j in tmp do
80752: LD_ADDR_VAR 0 4
80756: PUSH
80757: LD_VAR 0 6
80761: PUSH
80762: FOR_IN
80763: IFFALSE 80822
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80765: LD_ADDR_VAR 0 7
80769: PUSH
80770: LD_VAR 0 4
80774: PPUSH
80775: CALL_OW 313
80779: PPUSH
80780: LD_INT 25
80782: PUSH
80783: LD_INT 1
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: PPUSH
80790: CALL_OW 72
80794: ST_TO_ADDR
// if units then
80795: LD_VAR 0 7
80799: IFFALSE 80820
// begin ComExitBuilding ( units [ 1 ] ) ;
80801: LD_VAR 0 7
80805: PUSH
80806: LD_INT 1
80808: ARRAY
80809: PPUSH
80810: CALL_OW 122
// exit ;
80814: POP
80815: POP
80816: POP
80817: POP
80818: GO 80832
// end ; end ;
80820: GO 80762
80822: POP
80823: POP
// end ; end ; exit ;
80824: POP
80825: POP
80826: GO 80832
// end ; end ;
80828: GO 80186
80830: POP
80831: POP
// end ;
80832: LD_VAR 0 2
80836: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
80837: LD_INT 0
80839: PPUSH
80840: PPUSH
80841: PPUSH
80842: PPUSH
80843: PPUSH
80844: PPUSH
80845: PPUSH
// if not mc_bases or not skirmish then
80846: LD_EXP 23
80850: NOT
80851: PUSH
80852: LD_EXP 21
80856: NOT
80857: OR
80858: IFFALSE 80862
// exit ;
80860: GO 81127
// btype := GetBType ( building ) ;
80862: LD_ADDR_VAR 0 6
80866: PUSH
80867: LD_VAR 0 1
80871: PPUSH
80872: CALL_OW 266
80876: ST_TO_ADDR
// x := GetX ( building ) ;
80877: LD_ADDR_VAR 0 7
80881: PUSH
80882: LD_VAR 0 1
80886: PPUSH
80887: CALL_OW 250
80891: ST_TO_ADDR
// y := GetY ( building ) ;
80892: LD_ADDR_VAR 0 8
80896: PUSH
80897: LD_VAR 0 1
80901: PPUSH
80902: CALL_OW 251
80906: ST_TO_ADDR
// d := GetDir ( building ) ;
80907: LD_ADDR_VAR 0 9
80911: PUSH
80912: LD_VAR 0 1
80916: PPUSH
80917: CALL_OW 254
80921: ST_TO_ADDR
// for i = 1 to mc_bases do
80922: LD_ADDR_VAR 0 4
80926: PUSH
80927: DOUBLE
80928: LD_INT 1
80930: DEC
80931: ST_TO_ADDR
80932: LD_EXP 23
80936: PUSH
80937: FOR_TO
80938: IFFALSE 81125
// begin if not mc_build_list [ i ] then
80940: LD_EXP 28
80944: PUSH
80945: LD_VAR 0 4
80949: ARRAY
80950: NOT
80951: IFFALSE 80955
// continue ;
80953: GO 80937
// for j := 1 to mc_build_list [ i ] do
80955: LD_ADDR_VAR 0 5
80959: PUSH
80960: DOUBLE
80961: LD_INT 1
80963: DEC
80964: ST_TO_ADDR
80965: LD_EXP 28
80969: PUSH
80970: LD_VAR 0 4
80974: ARRAY
80975: PUSH
80976: FOR_TO
80977: IFFALSE 81121
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
80979: LD_VAR 0 6
80983: PUSH
80984: LD_VAR 0 7
80988: PUSH
80989: LD_VAR 0 8
80993: PUSH
80994: LD_VAR 0 9
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: PPUSH
81005: LD_EXP 28
81009: PUSH
81010: LD_VAR 0 4
81014: ARRAY
81015: PUSH
81016: LD_VAR 0 5
81020: ARRAY
81021: PPUSH
81022: CALL 22172 0 2
81026: IFFALSE 81119
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
81028: LD_ADDR_EXP 28
81032: PUSH
81033: LD_EXP 28
81037: PPUSH
81038: LD_VAR 0 4
81042: PPUSH
81043: LD_EXP 28
81047: PUSH
81048: LD_VAR 0 4
81052: ARRAY
81053: PPUSH
81054: LD_VAR 0 5
81058: PPUSH
81059: CALL_OW 3
81063: PPUSH
81064: CALL_OW 1
81068: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81069: LD_ADDR_EXP 30
81073: PUSH
81074: LD_EXP 30
81078: PPUSH
81079: LD_VAR 0 4
81083: PUSH
81084: LD_EXP 30
81088: PUSH
81089: LD_VAR 0 4
81093: ARRAY
81094: PUSH
81095: LD_INT 1
81097: PLUS
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PPUSH
81103: LD_VAR 0 1
81107: PPUSH
81108: CALL 15990 0 3
81112: ST_TO_ADDR
// exit ;
81113: POP
81114: POP
81115: POP
81116: POP
81117: GO 81127
// end ;
81119: GO 80976
81121: POP
81122: POP
// end ;
81123: GO 80937
81125: POP
81126: POP
// end ;
81127: LD_VAR 0 3
81131: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81132: LD_INT 0
81134: PPUSH
81135: PPUSH
81136: PPUSH
// if not mc_bases or not skirmish then
81137: LD_EXP 23
81141: NOT
81142: PUSH
81143: LD_EXP 21
81147: NOT
81148: OR
81149: IFFALSE 81153
// exit ;
81151: GO 81343
// for i = 1 to mc_bases do
81153: LD_ADDR_VAR 0 4
81157: PUSH
81158: DOUBLE
81159: LD_INT 1
81161: DEC
81162: ST_TO_ADDR
81163: LD_EXP 23
81167: PUSH
81168: FOR_TO
81169: IFFALSE 81256
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81171: LD_VAR 0 1
81175: PUSH
81176: LD_EXP 31
81180: PUSH
81181: LD_VAR 0 4
81185: ARRAY
81186: IN
81187: PUSH
81188: LD_VAR 0 1
81192: PUSH
81193: LD_EXP 32
81197: PUSH
81198: LD_VAR 0 4
81202: ARRAY
81203: IN
81204: NOT
81205: AND
81206: IFFALSE 81254
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81208: LD_ADDR_EXP 32
81212: PUSH
81213: LD_EXP 32
81217: PPUSH
81218: LD_VAR 0 4
81222: PUSH
81223: LD_EXP 32
81227: PUSH
81228: LD_VAR 0 4
81232: ARRAY
81233: PUSH
81234: LD_INT 1
81236: PLUS
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PPUSH
81242: LD_VAR 0 1
81246: PPUSH
81247: CALL 15990 0 3
81251: ST_TO_ADDR
// break ;
81252: GO 81256
// end ; end ;
81254: GO 81168
81256: POP
81257: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81258: LD_VAR 0 1
81262: PPUSH
81263: CALL_OW 257
81267: PUSH
81268: LD_EXP 49
81272: IN
81273: PUSH
81274: LD_VAR 0 1
81278: PPUSH
81279: CALL_OW 266
81283: PUSH
81284: LD_INT 5
81286: EQUAL
81287: AND
81288: PUSH
81289: LD_VAR 0 2
81293: PPUSH
81294: CALL_OW 110
81298: PUSH
81299: LD_INT 18
81301: NONEQUAL
81302: AND
81303: IFFALSE 81343
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81305: LD_VAR 0 2
81309: PPUSH
81310: CALL_OW 257
81314: PUSH
81315: LD_INT 5
81317: PUSH
81318: LD_INT 8
81320: PUSH
81321: LD_INT 9
81323: PUSH
81324: EMPTY
81325: LIST
81326: LIST
81327: LIST
81328: IN
81329: IFFALSE 81343
// SetClass ( unit , 1 ) ;
81331: LD_VAR 0 2
81335: PPUSH
81336: LD_INT 1
81338: PPUSH
81339: CALL_OW 336
// end ;
81343: LD_VAR 0 3
81347: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81348: LD_INT 0
81350: PPUSH
81351: PPUSH
// if not mc_bases or not skirmish then
81352: LD_EXP 23
81356: NOT
81357: PUSH
81358: LD_EXP 21
81362: NOT
81363: OR
81364: IFFALSE 81368
// exit ;
81366: GO 81484
// if GetLives ( abandoned_vehicle ) > 250 then
81368: LD_VAR 0 2
81372: PPUSH
81373: CALL_OW 256
81377: PUSH
81378: LD_INT 250
81380: GREATER
81381: IFFALSE 81385
// exit ;
81383: GO 81484
// for i = 1 to mc_bases do
81385: LD_ADDR_VAR 0 6
81389: PUSH
81390: DOUBLE
81391: LD_INT 1
81393: DEC
81394: ST_TO_ADDR
81395: LD_EXP 23
81399: PUSH
81400: FOR_TO
81401: IFFALSE 81482
// begin if driver in mc_bases [ i ] then
81403: LD_VAR 0 1
81407: PUSH
81408: LD_EXP 23
81412: PUSH
81413: LD_VAR 0 6
81417: ARRAY
81418: IN
81419: IFFALSE 81480
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81421: LD_VAR 0 1
81425: PPUSH
81426: LD_EXP 23
81430: PUSH
81431: LD_VAR 0 6
81435: ARRAY
81436: PPUSH
81437: LD_INT 2
81439: PUSH
81440: LD_INT 30
81442: PUSH
81443: LD_INT 0
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 30
81452: PUSH
81453: LD_INT 1
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: EMPTY
81461: LIST
81462: LIST
81463: LIST
81464: PPUSH
81465: CALL_OW 72
81469: PUSH
81470: LD_INT 1
81472: ARRAY
81473: PPUSH
81474: CALL 48608 0 2
// break ;
81478: GO 81482
// end ; end ;
81480: GO 81400
81482: POP
81483: POP
// end ; end_of_file
81484: LD_VAR 0 5
81488: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
81489: LD_INT 0
81491: PPUSH
// ar_miner := 81 ;
81492: LD_ADDR_EXP 74
81496: PUSH
81497: LD_INT 81
81499: ST_TO_ADDR
// ar_crane := 88 ;
81500: LD_ADDR_EXP 73
81504: PUSH
81505: LD_INT 88
81507: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81508: LD_ADDR_EXP 68
81512: PUSH
81513: LD_INT 89
81515: ST_TO_ADDR
// us_hack := 99 ;
81516: LD_ADDR_EXP 69
81520: PUSH
81521: LD_INT 99
81523: ST_TO_ADDR
// us_artillery := 97 ;
81524: LD_ADDR_EXP 70
81528: PUSH
81529: LD_INT 97
81531: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81532: LD_ADDR_EXP 71
81536: PUSH
81537: LD_INT 91
81539: ST_TO_ADDR
// ar_mortar := 92 ;
81540: LD_ADDR_EXP 72
81544: PUSH
81545: LD_INT 92
81547: ST_TO_ADDR
// ru_radar := 98 ;
81548: LD_ADDR_EXP 67
81552: PUSH
81553: LD_INT 98
81555: ST_TO_ADDR
// tech_Artillery := 80 ;
81556: LD_ADDR_EXP 75
81560: PUSH
81561: LD_INT 80
81563: ST_TO_ADDR
// tech_RadMat := 81 ;
81564: LD_ADDR_EXP 76
81568: PUSH
81569: LD_INT 81
81571: ST_TO_ADDR
// tech_BasicTools := 82 ;
81572: LD_ADDR_EXP 77
81576: PUSH
81577: LD_INT 82
81579: ST_TO_ADDR
// tech_Cargo := 83 ;
81580: LD_ADDR_EXP 78
81584: PUSH
81585: LD_INT 83
81587: ST_TO_ADDR
// tech_Track := 84 ;
81588: LD_ADDR_EXP 79
81592: PUSH
81593: LD_INT 84
81595: ST_TO_ADDR
// tech_Crane := 85 ;
81596: LD_ADDR_EXP 80
81600: PUSH
81601: LD_INT 85
81603: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81604: LD_ADDR_EXP 81
81608: PUSH
81609: LD_INT 86
81611: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81612: LD_ADDR_EXP 82
81616: PUSH
81617: LD_INT 87
81619: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
81620: LD_ADDR_EXP 83
81624: PUSH
81625: LD_INT 88
81627: ST_TO_ADDR
// class_mastodont := 31 ;
81628: LD_ADDR_EXP 84
81632: PUSH
81633: LD_INT 31
81635: ST_TO_ADDR
// class_horse := 21 ;
81636: LD_ADDR_EXP 85
81640: PUSH
81641: LD_INT 21
81643: ST_TO_ADDR
// end ;
81644: LD_VAR 0 1
81648: RET
// every 1 do
81649: GO 81651
81651: DISABLE
// InitGlobalVariables ; end_of_file
81652: CALL 81489 0 0
81656: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81657: LD_INT 0
81659: PPUSH
81660: PPUSH
81661: PPUSH
81662: PPUSH
81663: PPUSH
81664: PPUSH
81665: PPUSH
81666: PPUSH
81667: PPUSH
81668: PPUSH
81669: PPUSH
81670: PPUSH
81671: PPUSH
81672: PPUSH
81673: PPUSH
81674: PPUSH
81675: PPUSH
81676: PPUSH
81677: PPUSH
81678: PPUSH
81679: PPUSH
81680: PPUSH
81681: PPUSH
81682: PPUSH
81683: PPUSH
81684: PPUSH
81685: PPUSH
81686: PPUSH
81687: PPUSH
81688: PPUSH
81689: PPUSH
81690: PPUSH
81691: PPUSH
81692: PPUSH
// if not list then
81693: LD_VAR 0 1
81697: NOT
81698: IFFALSE 81702
// exit ;
81700: GO 86361
// base := list [ 1 ] ;
81702: LD_ADDR_VAR 0 3
81706: PUSH
81707: LD_VAR 0 1
81711: PUSH
81712: LD_INT 1
81714: ARRAY
81715: ST_TO_ADDR
// group := list [ 2 ] ;
81716: LD_ADDR_VAR 0 4
81720: PUSH
81721: LD_VAR 0 1
81725: PUSH
81726: LD_INT 2
81728: ARRAY
81729: ST_TO_ADDR
// path := list [ 3 ] ;
81730: LD_ADDR_VAR 0 5
81734: PUSH
81735: LD_VAR 0 1
81739: PUSH
81740: LD_INT 3
81742: ARRAY
81743: ST_TO_ADDR
// flags := list [ 4 ] ;
81744: LD_ADDR_VAR 0 6
81748: PUSH
81749: LD_VAR 0 1
81753: PUSH
81754: LD_INT 4
81756: ARRAY
81757: ST_TO_ADDR
// mined := [ ] ;
81758: LD_ADDR_VAR 0 27
81762: PUSH
81763: EMPTY
81764: ST_TO_ADDR
// bombed := [ ] ;
81765: LD_ADDR_VAR 0 28
81769: PUSH
81770: EMPTY
81771: ST_TO_ADDR
// healers := [ ] ;
81772: LD_ADDR_VAR 0 31
81776: PUSH
81777: EMPTY
81778: ST_TO_ADDR
// to_heal := [ ] ;
81779: LD_ADDR_VAR 0 30
81783: PUSH
81784: EMPTY
81785: ST_TO_ADDR
// repairs := [ ] ;
81786: LD_ADDR_VAR 0 33
81790: PUSH
81791: EMPTY
81792: ST_TO_ADDR
// to_repair := [ ] ;
81793: LD_ADDR_VAR 0 32
81797: PUSH
81798: EMPTY
81799: ST_TO_ADDR
// if not group or not path then
81800: LD_VAR 0 4
81804: NOT
81805: PUSH
81806: LD_VAR 0 5
81810: NOT
81811: OR
81812: IFFALSE 81816
// exit ;
81814: GO 86361
// side := GetSide ( group [ 1 ] ) ;
81816: LD_ADDR_VAR 0 35
81820: PUSH
81821: LD_VAR 0 4
81825: PUSH
81826: LD_INT 1
81828: ARRAY
81829: PPUSH
81830: CALL_OW 255
81834: ST_TO_ADDR
// if flags then
81835: LD_VAR 0 6
81839: IFFALSE 81983
// begin f_ignore_area := flags [ 1 ] ;
81841: LD_ADDR_VAR 0 17
81845: PUSH
81846: LD_VAR 0 6
81850: PUSH
81851: LD_INT 1
81853: ARRAY
81854: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
81855: LD_ADDR_VAR 0 18
81859: PUSH
81860: LD_VAR 0 6
81864: PUSH
81865: LD_INT 2
81867: ARRAY
81868: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
81869: LD_ADDR_VAR 0 19
81873: PUSH
81874: LD_VAR 0 6
81878: PUSH
81879: LD_INT 3
81881: ARRAY
81882: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
81883: LD_ADDR_VAR 0 20
81887: PUSH
81888: LD_VAR 0 6
81892: PUSH
81893: LD_INT 4
81895: ARRAY
81896: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
81897: LD_ADDR_VAR 0 21
81901: PUSH
81902: LD_VAR 0 6
81906: PUSH
81907: LD_INT 5
81909: ARRAY
81910: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
81911: LD_ADDR_VAR 0 22
81915: PUSH
81916: LD_VAR 0 6
81920: PUSH
81921: LD_INT 6
81923: ARRAY
81924: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
81925: LD_ADDR_VAR 0 23
81929: PUSH
81930: LD_VAR 0 6
81934: PUSH
81935: LD_INT 7
81937: ARRAY
81938: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
81939: LD_ADDR_VAR 0 24
81943: PUSH
81944: LD_VAR 0 6
81948: PUSH
81949: LD_INT 8
81951: ARRAY
81952: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81953: LD_ADDR_VAR 0 25
81957: PUSH
81958: LD_VAR 0 6
81962: PUSH
81963: LD_INT 9
81965: ARRAY
81966: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81967: LD_ADDR_VAR 0 26
81971: PUSH
81972: LD_VAR 0 6
81976: PUSH
81977: LD_INT 10
81979: ARRAY
81980: ST_TO_ADDR
// end else
81981: GO 82063
// begin f_ignore_area := false ;
81983: LD_ADDR_VAR 0 17
81987: PUSH
81988: LD_INT 0
81990: ST_TO_ADDR
// f_capture := false ;
81991: LD_ADDR_VAR 0 18
81995: PUSH
81996: LD_INT 0
81998: ST_TO_ADDR
// f_ignore_civ := false ;
81999: LD_ADDR_VAR 0 19
82003: PUSH
82004: LD_INT 0
82006: ST_TO_ADDR
// f_murder := false ;
82007: LD_ADDR_VAR 0 20
82011: PUSH
82012: LD_INT 0
82014: ST_TO_ADDR
// f_mines := false ;
82015: LD_ADDR_VAR 0 21
82019: PUSH
82020: LD_INT 0
82022: ST_TO_ADDR
// f_repair := false ;
82023: LD_ADDR_VAR 0 22
82027: PUSH
82028: LD_INT 0
82030: ST_TO_ADDR
// f_heal := false ;
82031: LD_ADDR_VAR 0 23
82035: PUSH
82036: LD_INT 0
82038: ST_TO_ADDR
// f_spacetime := false ;
82039: LD_ADDR_VAR 0 24
82043: PUSH
82044: LD_INT 0
82046: ST_TO_ADDR
// f_attack_depot := false ;
82047: LD_ADDR_VAR 0 25
82051: PUSH
82052: LD_INT 0
82054: ST_TO_ADDR
// f_crawl := false ;
82055: LD_ADDR_VAR 0 26
82059: PUSH
82060: LD_INT 0
82062: ST_TO_ADDR
// end ; if f_heal then
82063: LD_VAR 0 23
82067: IFFALSE 82094
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
82069: LD_ADDR_VAR 0 31
82073: PUSH
82074: LD_VAR 0 4
82078: PPUSH
82079: LD_INT 25
82081: PUSH
82082: LD_INT 4
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PPUSH
82089: CALL_OW 72
82093: ST_TO_ADDR
// if f_repair then
82094: LD_VAR 0 22
82098: IFFALSE 82125
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
82100: LD_ADDR_VAR 0 33
82104: PUSH
82105: LD_VAR 0 4
82109: PPUSH
82110: LD_INT 25
82112: PUSH
82113: LD_INT 3
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PPUSH
82120: CALL_OW 72
82124: ST_TO_ADDR
// units_path := [ ] ;
82125: LD_ADDR_VAR 0 16
82129: PUSH
82130: EMPTY
82131: ST_TO_ADDR
// for i = 1 to group do
82132: LD_ADDR_VAR 0 7
82136: PUSH
82137: DOUBLE
82138: LD_INT 1
82140: DEC
82141: ST_TO_ADDR
82142: LD_VAR 0 4
82146: PUSH
82147: FOR_TO
82148: IFFALSE 82177
// units_path := Replace ( units_path , i , path ) ;
82150: LD_ADDR_VAR 0 16
82154: PUSH
82155: LD_VAR 0 16
82159: PPUSH
82160: LD_VAR 0 7
82164: PPUSH
82165: LD_VAR 0 5
82169: PPUSH
82170: CALL_OW 1
82174: ST_TO_ADDR
82175: GO 82147
82177: POP
82178: POP
// repeat for i = group downto 1 do
82179: LD_ADDR_VAR 0 7
82183: PUSH
82184: DOUBLE
82185: LD_VAR 0 4
82189: INC
82190: ST_TO_ADDR
82191: LD_INT 1
82193: PUSH
82194: FOR_DOWNTO
82195: IFFALSE 86317
// begin wait ( 5 ) ;
82197: LD_INT 5
82199: PPUSH
82200: CALL_OW 67
// tmp := [ ] ;
82204: LD_ADDR_VAR 0 14
82208: PUSH
82209: EMPTY
82210: ST_TO_ADDR
// attacking := false ;
82211: LD_ADDR_VAR 0 29
82215: PUSH
82216: LD_INT 0
82218: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
82219: LD_VAR 0 4
82223: PUSH
82224: LD_VAR 0 7
82228: ARRAY
82229: PPUSH
82230: CALL_OW 301
82234: PUSH
82235: LD_VAR 0 4
82239: PUSH
82240: LD_VAR 0 7
82244: ARRAY
82245: NOT
82246: OR
82247: IFFALSE 82356
// begin if GetType ( group [ i ] ) = unit_human then
82249: LD_VAR 0 4
82253: PUSH
82254: LD_VAR 0 7
82258: ARRAY
82259: PPUSH
82260: CALL_OW 247
82264: PUSH
82265: LD_INT 1
82267: EQUAL
82268: IFFALSE 82314
// begin to_heal := to_heal diff group [ i ] ;
82270: LD_ADDR_VAR 0 30
82274: PUSH
82275: LD_VAR 0 30
82279: PUSH
82280: LD_VAR 0 4
82284: PUSH
82285: LD_VAR 0 7
82289: ARRAY
82290: DIFF
82291: ST_TO_ADDR
// healers := healers diff group [ i ] ;
82292: LD_ADDR_VAR 0 31
82296: PUSH
82297: LD_VAR 0 31
82301: PUSH
82302: LD_VAR 0 4
82306: PUSH
82307: LD_VAR 0 7
82311: ARRAY
82312: DIFF
82313: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82314: LD_ADDR_VAR 0 4
82318: PUSH
82319: LD_VAR 0 4
82323: PPUSH
82324: LD_VAR 0 7
82328: PPUSH
82329: CALL_OW 3
82333: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82334: LD_ADDR_VAR 0 16
82338: PUSH
82339: LD_VAR 0 16
82343: PPUSH
82344: LD_VAR 0 7
82348: PPUSH
82349: CALL_OW 3
82353: ST_TO_ADDR
// continue ;
82354: GO 82194
// end ; if f_repair then
82356: LD_VAR 0 22
82360: IFFALSE 82849
// begin if GetType ( group [ i ] ) = unit_vehicle then
82362: LD_VAR 0 4
82366: PUSH
82367: LD_VAR 0 7
82371: ARRAY
82372: PPUSH
82373: CALL_OW 247
82377: PUSH
82378: LD_INT 2
82380: EQUAL
82381: IFFALSE 82571
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82383: LD_VAR 0 4
82387: PUSH
82388: LD_VAR 0 7
82392: ARRAY
82393: PPUSH
82394: CALL_OW 256
82398: PUSH
82399: LD_INT 700
82401: LESS
82402: PUSH
82403: LD_VAR 0 4
82407: PUSH
82408: LD_VAR 0 7
82412: ARRAY
82413: PUSH
82414: LD_VAR 0 32
82418: IN
82419: NOT
82420: AND
82421: IFFALSE 82445
// to_repair := to_repair union group [ i ] ;
82423: LD_ADDR_VAR 0 32
82427: PUSH
82428: LD_VAR 0 32
82432: PUSH
82433: LD_VAR 0 4
82437: PUSH
82438: LD_VAR 0 7
82442: ARRAY
82443: UNION
82444: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82445: LD_VAR 0 4
82449: PUSH
82450: LD_VAR 0 7
82454: ARRAY
82455: PPUSH
82456: CALL_OW 256
82460: PUSH
82461: LD_INT 1000
82463: EQUAL
82464: PUSH
82465: LD_VAR 0 4
82469: PUSH
82470: LD_VAR 0 7
82474: ARRAY
82475: PUSH
82476: LD_VAR 0 32
82480: IN
82481: AND
82482: IFFALSE 82506
// to_repair := to_repair diff group [ i ] ;
82484: LD_ADDR_VAR 0 32
82488: PUSH
82489: LD_VAR 0 32
82493: PUSH
82494: LD_VAR 0 4
82498: PUSH
82499: LD_VAR 0 7
82503: ARRAY
82504: DIFF
82505: ST_TO_ADDR
// if group [ i ] in to_repair then
82506: LD_VAR 0 4
82510: PUSH
82511: LD_VAR 0 7
82515: ARRAY
82516: PUSH
82517: LD_VAR 0 32
82521: IN
82522: IFFALSE 82569
// begin if not IsInArea ( group [ i ] , f_repair ) then
82524: LD_VAR 0 4
82528: PUSH
82529: LD_VAR 0 7
82533: ARRAY
82534: PPUSH
82535: LD_VAR 0 22
82539: PPUSH
82540: CALL_OW 308
82544: NOT
82545: IFFALSE 82567
// ComMoveToArea ( group [ i ] , f_repair ) ;
82547: LD_VAR 0 4
82551: PUSH
82552: LD_VAR 0 7
82556: ARRAY
82557: PPUSH
82558: LD_VAR 0 22
82562: PPUSH
82563: CALL_OW 113
// continue ;
82567: GO 82194
// end ; end else
82569: GO 82849
// if group [ i ] in repairs then
82571: LD_VAR 0 4
82575: PUSH
82576: LD_VAR 0 7
82580: ARRAY
82581: PUSH
82582: LD_VAR 0 33
82586: IN
82587: IFFALSE 82849
// begin if IsInUnit ( group [ i ] ) then
82589: LD_VAR 0 4
82593: PUSH
82594: LD_VAR 0 7
82598: ARRAY
82599: PPUSH
82600: CALL_OW 310
82604: IFFALSE 82672
// begin z := IsInUnit ( group [ i ] ) ;
82606: LD_ADDR_VAR 0 13
82610: PUSH
82611: LD_VAR 0 4
82615: PUSH
82616: LD_VAR 0 7
82620: ARRAY
82621: PPUSH
82622: CALL_OW 310
82626: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82627: LD_VAR 0 13
82631: PUSH
82632: LD_VAR 0 32
82636: IN
82637: PUSH
82638: LD_VAR 0 13
82642: PPUSH
82643: LD_VAR 0 22
82647: PPUSH
82648: CALL_OW 308
82652: AND
82653: IFFALSE 82670
// ComExitVehicle ( group [ i ] ) ;
82655: LD_VAR 0 4
82659: PUSH
82660: LD_VAR 0 7
82664: ARRAY
82665: PPUSH
82666: CALL_OW 121
// end else
82670: GO 82849
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82672: LD_ADDR_VAR 0 13
82676: PUSH
82677: LD_VAR 0 4
82681: PPUSH
82682: LD_INT 95
82684: PUSH
82685: LD_VAR 0 22
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 58
82696: PUSH
82697: EMPTY
82698: LIST
82699: PUSH
82700: EMPTY
82701: LIST
82702: LIST
82703: PPUSH
82704: CALL_OW 72
82708: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82709: LD_VAR 0 4
82713: PUSH
82714: LD_VAR 0 7
82718: ARRAY
82719: PPUSH
82720: CALL_OW 314
82724: NOT
82725: IFFALSE 82847
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
82727: LD_ADDR_VAR 0 10
82731: PUSH
82732: LD_VAR 0 13
82736: PPUSH
82737: LD_VAR 0 4
82741: PUSH
82742: LD_VAR 0 7
82746: ARRAY
82747: PPUSH
82748: CALL_OW 74
82752: ST_TO_ADDR
// if not x then
82753: LD_VAR 0 10
82757: NOT
82758: IFFALSE 82762
// continue ;
82760: GO 82194
// if GetLives ( x ) < 1000 then
82762: LD_VAR 0 10
82766: PPUSH
82767: CALL_OW 256
82771: PUSH
82772: LD_INT 1000
82774: LESS
82775: IFFALSE 82799
// ComRepairVehicle ( group [ i ] , x ) else
82777: LD_VAR 0 4
82781: PUSH
82782: LD_VAR 0 7
82786: ARRAY
82787: PPUSH
82788: LD_VAR 0 10
82792: PPUSH
82793: CALL_OW 129
82797: GO 82847
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
82799: LD_VAR 0 23
82803: PUSH
82804: LD_VAR 0 4
82808: PUSH
82809: LD_VAR 0 7
82813: ARRAY
82814: PPUSH
82815: CALL_OW 256
82819: PUSH
82820: LD_INT 1000
82822: LESS
82823: AND
82824: NOT
82825: IFFALSE 82847
// ComEnterUnit ( group [ i ] , x ) ;
82827: LD_VAR 0 4
82831: PUSH
82832: LD_VAR 0 7
82836: ARRAY
82837: PPUSH
82838: LD_VAR 0 10
82842: PPUSH
82843: CALL_OW 120
// end ; continue ;
82847: GO 82194
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
82849: LD_VAR 0 23
82853: PUSH
82854: LD_VAR 0 4
82858: PUSH
82859: LD_VAR 0 7
82863: ARRAY
82864: PPUSH
82865: CALL_OW 247
82869: PUSH
82870: LD_INT 1
82872: EQUAL
82873: AND
82874: IFFALSE 83352
// begin if group [ i ] in healers then
82876: LD_VAR 0 4
82880: PUSH
82881: LD_VAR 0 7
82885: ARRAY
82886: PUSH
82887: LD_VAR 0 31
82891: IN
82892: IFFALSE 83165
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
82894: LD_VAR 0 4
82898: PUSH
82899: LD_VAR 0 7
82903: ARRAY
82904: PPUSH
82905: LD_VAR 0 23
82909: PPUSH
82910: CALL_OW 308
82914: NOT
82915: PUSH
82916: LD_VAR 0 4
82920: PUSH
82921: LD_VAR 0 7
82925: ARRAY
82926: PPUSH
82927: CALL_OW 314
82931: NOT
82932: AND
82933: IFFALSE 82957
// ComMoveToArea ( group [ i ] , f_heal ) else
82935: LD_VAR 0 4
82939: PUSH
82940: LD_VAR 0 7
82944: ARRAY
82945: PPUSH
82946: LD_VAR 0 23
82950: PPUSH
82951: CALL_OW 113
82955: GO 83163
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82957: LD_VAR 0 4
82961: PUSH
82962: LD_VAR 0 7
82966: ARRAY
82967: PPUSH
82968: CALL 45070 0 1
82972: PPUSH
82973: CALL_OW 256
82977: PUSH
82978: LD_INT 1000
82980: EQUAL
82981: IFFALSE 83000
// ComStop ( group [ i ] ) else
82983: LD_VAR 0 4
82987: PUSH
82988: LD_VAR 0 7
82992: ARRAY
82993: PPUSH
82994: CALL_OW 141
82998: GO 83163
// if not HasTask ( group [ i ] ) and to_heal then
83000: LD_VAR 0 4
83004: PUSH
83005: LD_VAR 0 7
83009: ARRAY
83010: PPUSH
83011: CALL_OW 314
83015: NOT
83016: PUSH
83017: LD_VAR 0 30
83021: AND
83022: IFFALSE 83163
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
83024: LD_ADDR_VAR 0 13
83028: PUSH
83029: LD_VAR 0 30
83033: PPUSH
83034: LD_INT 3
83036: PUSH
83037: LD_INT 54
83039: PUSH
83040: EMPTY
83041: LIST
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PPUSH
83047: CALL_OW 72
83051: PPUSH
83052: LD_VAR 0 4
83056: PUSH
83057: LD_VAR 0 7
83061: ARRAY
83062: PPUSH
83063: CALL_OW 74
83067: ST_TO_ADDR
// if z then
83068: LD_VAR 0 13
83072: IFFALSE 83163
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
83074: LD_INT 91
83076: PUSH
83077: LD_VAR 0 13
83081: PUSH
83082: LD_INT 10
83084: PUSH
83085: EMPTY
83086: LIST
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 81
83092: PUSH
83093: LD_VAR 0 13
83097: PPUSH
83098: CALL_OW 255
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PPUSH
83111: CALL_OW 69
83115: PUSH
83116: LD_INT 0
83118: EQUAL
83119: IFFALSE 83143
// ComHeal ( group [ i ] , z ) else
83121: LD_VAR 0 4
83125: PUSH
83126: LD_VAR 0 7
83130: ARRAY
83131: PPUSH
83132: LD_VAR 0 13
83136: PPUSH
83137: CALL_OW 128
83141: GO 83163
// ComMoveToArea ( group [ i ] , f_heal ) ;
83143: LD_VAR 0 4
83147: PUSH
83148: LD_VAR 0 7
83152: ARRAY
83153: PPUSH
83154: LD_VAR 0 23
83158: PPUSH
83159: CALL_OW 113
// end ; continue ;
83163: GO 82194
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
83165: LD_VAR 0 4
83169: PUSH
83170: LD_VAR 0 7
83174: ARRAY
83175: PPUSH
83176: CALL_OW 256
83180: PUSH
83181: LD_INT 700
83183: LESS
83184: PUSH
83185: LD_VAR 0 4
83189: PUSH
83190: LD_VAR 0 7
83194: ARRAY
83195: PUSH
83196: LD_VAR 0 30
83200: IN
83201: NOT
83202: AND
83203: IFFALSE 83227
// to_heal := to_heal union group [ i ] ;
83205: LD_ADDR_VAR 0 30
83209: PUSH
83210: LD_VAR 0 30
83214: PUSH
83215: LD_VAR 0 4
83219: PUSH
83220: LD_VAR 0 7
83224: ARRAY
83225: UNION
83226: ST_TO_ADDR
// if group [ i ] in to_heal then
83227: LD_VAR 0 4
83231: PUSH
83232: LD_VAR 0 7
83236: ARRAY
83237: PUSH
83238: LD_VAR 0 30
83242: IN
83243: IFFALSE 83352
// begin if GetLives ( group [ i ] ) = 1000 then
83245: LD_VAR 0 4
83249: PUSH
83250: LD_VAR 0 7
83254: ARRAY
83255: PPUSH
83256: CALL_OW 256
83260: PUSH
83261: LD_INT 1000
83263: EQUAL
83264: IFFALSE 83290
// to_heal := to_heal diff group [ i ] else
83266: LD_ADDR_VAR 0 30
83270: PUSH
83271: LD_VAR 0 30
83275: PUSH
83276: LD_VAR 0 4
83280: PUSH
83281: LD_VAR 0 7
83285: ARRAY
83286: DIFF
83287: ST_TO_ADDR
83288: GO 83352
// begin if not IsInArea ( group [ i ] , to_heal ) then
83290: LD_VAR 0 4
83294: PUSH
83295: LD_VAR 0 7
83299: ARRAY
83300: PPUSH
83301: LD_VAR 0 30
83305: PPUSH
83306: CALL_OW 308
83310: NOT
83311: IFFALSE 83335
// ComMoveToArea ( group [ i ] , f_heal ) else
83313: LD_VAR 0 4
83317: PUSH
83318: LD_VAR 0 7
83322: ARRAY
83323: PPUSH
83324: LD_VAR 0 23
83328: PPUSH
83329: CALL_OW 113
83333: GO 83350
// ComHold ( group [ i ] ) ;
83335: LD_VAR 0 4
83339: PUSH
83340: LD_VAR 0 7
83344: ARRAY
83345: PPUSH
83346: CALL_OW 140
// continue ;
83350: GO 82194
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83352: LD_VAR 0 4
83356: PUSH
83357: LD_VAR 0 7
83361: ARRAY
83362: PPUSH
83363: LD_INT 10
83365: PPUSH
83366: CALL 43490 0 2
83370: NOT
83371: PUSH
83372: LD_VAR 0 16
83376: PUSH
83377: LD_VAR 0 7
83381: ARRAY
83382: PUSH
83383: EMPTY
83384: EQUAL
83385: NOT
83386: AND
83387: IFFALSE 83653
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83389: LD_VAR 0 4
83393: PUSH
83394: LD_VAR 0 7
83398: ARRAY
83399: PPUSH
83400: CALL_OW 262
83404: PUSH
83405: LD_INT 1
83407: PUSH
83408: LD_INT 2
83410: PUSH
83411: EMPTY
83412: LIST
83413: LIST
83414: IN
83415: IFFALSE 83456
// if GetFuel ( group [ i ] ) < 10 then
83417: LD_VAR 0 4
83421: PUSH
83422: LD_VAR 0 7
83426: ARRAY
83427: PPUSH
83428: CALL_OW 261
83432: PUSH
83433: LD_INT 10
83435: LESS
83436: IFFALSE 83456
// SetFuel ( group [ i ] , 12 ) ;
83438: LD_VAR 0 4
83442: PUSH
83443: LD_VAR 0 7
83447: ARRAY
83448: PPUSH
83449: LD_INT 12
83451: PPUSH
83452: CALL_OW 240
// if units_path [ i ] then
83456: LD_VAR 0 16
83460: PUSH
83461: LD_VAR 0 7
83465: ARRAY
83466: IFFALSE 83651
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83468: LD_VAR 0 4
83472: PUSH
83473: LD_VAR 0 7
83477: ARRAY
83478: PPUSH
83479: LD_VAR 0 16
83483: PUSH
83484: LD_VAR 0 7
83488: ARRAY
83489: PUSH
83490: LD_INT 1
83492: ARRAY
83493: PUSH
83494: LD_INT 1
83496: ARRAY
83497: PPUSH
83498: LD_VAR 0 16
83502: PUSH
83503: LD_VAR 0 7
83507: ARRAY
83508: PUSH
83509: LD_INT 1
83511: ARRAY
83512: PUSH
83513: LD_INT 2
83515: ARRAY
83516: PPUSH
83517: CALL_OW 297
83521: PUSH
83522: LD_INT 6
83524: GREATER
83525: IFFALSE 83600
// begin if not HasTask ( group [ i ] ) then
83527: LD_VAR 0 4
83531: PUSH
83532: LD_VAR 0 7
83536: ARRAY
83537: PPUSH
83538: CALL_OW 314
83542: NOT
83543: IFFALSE 83598
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83545: LD_VAR 0 4
83549: PUSH
83550: LD_VAR 0 7
83554: ARRAY
83555: PPUSH
83556: LD_VAR 0 16
83560: PUSH
83561: LD_VAR 0 7
83565: ARRAY
83566: PUSH
83567: LD_INT 1
83569: ARRAY
83570: PUSH
83571: LD_INT 1
83573: ARRAY
83574: PPUSH
83575: LD_VAR 0 16
83579: PUSH
83580: LD_VAR 0 7
83584: ARRAY
83585: PUSH
83586: LD_INT 1
83588: ARRAY
83589: PUSH
83590: LD_INT 2
83592: ARRAY
83593: PPUSH
83594: CALL_OW 114
// end else
83598: GO 83651
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83600: LD_ADDR_VAR 0 15
83604: PUSH
83605: LD_VAR 0 16
83609: PUSH
83610: LD_VAR 0 7
83614: ARRAY
83615: PPUSH
83616: LD_INT 1
83618: PPUSH
83619: CALL_OW 3
83623: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83624: LD_ADDR_VAR 0 16
83628: PUSH
83629: LD_VAR 0 16
83633: PPUSH
83634: LD_VAR 0 7
83638: PPUSH
83639: LD_VAR 0 15
83643: PPUSH
83644: CALL_OW 1
83648: ST_TO_ADDR
// continue ;
83649: GO 82194
// end ; end ; end else
83651: GO 86315
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83653: LD_ADDR_VAR 0 14
83657: PUSH
83658: LD_INT 81
83660: PUSH
83661: LD_VAR 0 4
83665: PUSH
83666: LD_VAR 0 7
83670: ARRAY
83671: PPUSH
83672: CALL_OW 255
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PPUSH
83681: CALL_OW 69
83685: ST_TO_ADDR
// if not tmp then
83686: LD_VAR 0 14
83690: NOT
83691: IFFALSE 83695
// continue ;
83693: GO 82194
// if f_ignore_area then
83695: LD_VAR 0 17
83699: IFFALSE 83787
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83701: LD_ADDR_VAR 0 15
83705: PUSH
83706: LD_VAR 0 14
83710: PPUSH
83711: LD_INT 3
83713: PUSH
83714: LD_INT 92
83716: PUSH
83717: LD_VAR 0 17
83721: PUSH
83722: LD_INT 1
83724: ARRAY
83725: PUSH
83726: LD_VAR 0 17
83730: PUSH
83731: LD_INT 2
83733: ARRAY
83734: PUSH
83735: LD_VAR 0 17
83739: PUSH
83740: LD_INT 3
83742: ARRAY
83743: PUSH
83744: EMPTY
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: PUSH
83750: EMPTY
83751: LIST
83752: LIST
83753: PPUSH
83754: CALL_OW 72
83758: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83759: LD_VAR 0 14
83763: PUSH
83764: LD_VAR 0 15
83768: DIFF
83769: IFFALSE 83787
// tmp := tmp diff tmp2 ;
83771: LD_ADDR_VAR 0 14
83775: PUSH
83776: LD_VAR 0 14
83780: PUSH
83781: LD_VAR 0 15
83785: DIFF
83786: ST_TO_ADDR
// end ; if not f_murder then
83787: LD_VAR 0 20
83791: NOT
83792: IFFALSE 83850
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
83794: LD_ADDR_VAR 0 15
83798: PUSH
83799: LD_VAR 0 14
83803: PPUSH
83804: LD_INT 3
83806: PUSH
83807: LD_INT 50
83809: PUSH
83810: EMPTY
83811: LIST
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: PPUSH
83817: CALL_OW 72
83821: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83822: LD_VAR 0 14
83826: PUSH
83827: LD_VAR 0 15
83831: DIFF
83832: IFFALSE 83850
// tmp := tmp diff tmp2 ;
83834: LD_ADDR_VAR 0 14
83838: PUSH
83839: LD_VAR 0 14
83843: PUSH
83844: LD_VAR 0 15
83848: DIFF
83849: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
83850: LD_ADDR_VAR 0 14
83854: PUSH
83855: LD_VAR 0 4
83859: PUSH
83860: LD_VAR 0 7
83864: ARRAY
83865: PPUSH
83866: LD_VAR 0 14
83870: PPUSH
83871: LD_INT 1
83873: PPUSH
83874: LD_INT 1
83876: PPUSH
83877: CALL 16425 0 4
83881: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
83882: LD_VAR 0 4
83886: PUSH
83887: LD_VAR 0 7
83891: ARRAY
83892: PPUSH
83893: CALL_OW 257
83897: PUSH
83898: LD_INT 1
83900: EQUAL
83901: IFFALSE 84349
// begin if WantPlant ( group [ i ] ) then
83903: LD_VAR 0 4
83907: PUSH
83908: LD_VAR 0 7
83912: ARRAY
83913: PPUSH
83914: CALL 15926 0 1
83918: IFFALSE 83922
// continue ;
83920: GO 82194
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
83922: LD_VAR 0 18
83926: PUSH
83927: LD_VAR 0 4
83931: PUSH
83932: LD_VAR 0 7
83936: ARRAY
83937: PPUSH
83938: CALL_OW 310
83942: NOT
83943: AND
83944: PUSH
83945: LD_VAR 0 14
83949: PUSH
83950: LD_INT 1
83952: ARRAY
83953: PUSH
83954: LD_VAR 0 14
83958: PPUSH
83959: LD_INT 21
83961: PUSH
83962: LD_INT 2
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: PUSH
83969: LD_INT 58
83971: PUSH
83972: EMPTY
83973: LIST
83974: PUSH
83975: EMPTY
83976: LIST
83977: LIST
83978: PPUSH
83979: CALL_OW 72
83983: IN
83984: AND
83985: IFFALSE 84021
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83987: LD_VAR 0 4
83991: PUSH
83992: LD_VAR 0 7
83996: ARRAY
83997: PPUSH
83998: LD_VAR 0 14
84002: PUSH
84003: LD_INT 1
84005: ARRAY
84006: PPUSH
84007: CALL_OW 120
// attacking := true ;
84011: LD_ADDR_VAR 0 29
84015: PUSH
84016: LD_INT 1
84018: ST_TO_ADDR
// continue ;
84019: GO 82194
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
84021: LD_VAR 0 26
84025: PUSH
84026: LD_VAR 0 4
84030: PUSH
84031: LD_VAR 0 7
84035: ARRAY
84036: PPUSH
84037: CALL_OW 257
84041: PUSH
84042: LD_INT 1
84044: EQUAL
84045: AND
84046: PUSH
84047: LD_VAR 0 4
84051: PUSH
84052: LD_VAR 0 7
84056: ARRAY
84057: PPUSH
84058: CALL_OW 256
84062: PUSH
84063: LD_INT 800
84065: LESS
84066: AND
84067: PUSH
84068: LD_VAR 0 4
84072: PUSH
84073: LD_VAR 0 7
84077: ARRAY
84078: PPUSH
84079: CALL_OW 318
84083: NOT
84084: AND
84085: IFFALSE 84102
// ComCrawl ( group [ i ] ) ;
84087: LD_VAR 0 4
84091: PUSH
84092: LD_VAR 0 7
84096: ARRAY
84097: PPUSH
84098: CALL_OW 137
// if f_mines then
84102: LD_VAR 0 21
84106: IFFALSE 84349
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
84108: LD_VAR 0 14
84112: PUSH
84113: LD_INT 1
84115: ARRAY
84116: PPUSH
84117: CALL_OW 247
84121: PUSH
84122: LD_INT 3
84124: EQUAL
84125: PUSH
84126: LD_VAR 0 14
84130: PUSH
84131: LD_INT 1
84133: ARRAY
84134: PUSH
84135: LD_VAR 0 27
84139: IN
84140: NOT
84141: AND
84142: IFFALSE 84349
// begin x := GetX ( tmp [ 1 ] ) ;
84144: LD_ADDR_VAR 0 10
84148: PUSH
84149: LD_VAR 0 14
84153: PUSH
84154: LD_INT 1
84156: ARRAY
84157: PPUSH
84158: CALL_OW 250
84162: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
84163: LD_ADDR_VAR 0 11
84167: PUSH
84168: LD_VAR 0 14
84172: PUSH
84173: LD_INT 1
84175: ARRAY
84176: PPUSH
84177: CALL_OW 251
84181: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
84182: LD_ADDR_VAR 0 12
84186: PUSH
84187: LD_VAR 0 4
84191: PUSH
84192: LD_VAR 0 7
84196: ARRAY
84197: PPUSH
84198: CALL 43575 0 1
84202: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
84203: LD_VAR 0 4
84207: PUSH
84208: LD_VAR 0 7
84212: ARRAY
84213: PPUSH
84214: LD_VAR 0 10
84218: PPUSH
84219: LD_VAR 0 11
84223: PPUSH
84224: LD_VAR 0 14
84228: PUSH
84229: LD_INT 1
84231: ARRAY
84232: PPUSH
84233: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
84237: LD_VAR 0 4
84241: PUSH
84242: LD_VAR 0 7
84246: ARRAY
84247: PPUSH
84248: LD_VAR 0 10
84252: PPUSH
84253: LD_VAR 0 12
84257: PPUSH
84258: LD_INT 7
84260: PPUSH
84261: CALL_OW 272
84265: PPUSH
84266: LD_VAR 0 11
84270: PPUSH
84271: LD_VAR 0 12
84275: PPUSH
84276: LD_INT 7
84278: PPUSH
84279: CALL_OW 273
84283: PPUSH
84284: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
84288: LD_VAR 0 4
84292: PUSH
84293: LD_VAR 0 7
84297: ARRAY
84298: PPUSH
84299: LD_INT 71
84301: PPUSH
84302: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84306: LD_ADDR_VAR 0 27
84310: PUSH
84311: LD_VAR 0 27
84315: PPUSH
84316: LD_VAR 0 27
84320: PUSH
84321: LD_INT 1
84323: PLUS
84324: PPUSH
84325: LD_VAR 0 14
84329: PUSH
84330: LD_INT 1
84332: ARRAY
84333: PPUSH
84334: CALL_OW 1
84338: ST_TO_ADDR
// attacking := true ;
84339: LD_ADDR_VAR 0 29
84343: PUSH
84344: LD_INT 1
84346: ST_TO_ADDR
// continue ;
84347: GO 82194
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84349: LD_VAR 0 4
84353: PUSH
84354: LD_VAR 0 7
84358: ARRAY
84359: PPUSH
84360: CALL_OW 257
84364: PUSH
84365: LD_INT 17
84367: EQUAL
84368: PUSH
84369: LD_VAR 0 4
84373: PUSH
84374: LD_VAR 0 7
84378: ARRAY
84379: PPUSH
84380: CALL_OW 110
84384: PUSH
84385: LD_INT 71
84387: EQUAL
84388: NOT
84389: AND
84390: IFFALSE 84536
// begin attacking := false ;
84392: LD_ADDR_VAR 0 29
84396: PUSH
84397: LD_INT 0
84399: ST_TO_ADDR
// k := 5 ;
84400: LD_ADDR_VAR 0 9
84404: PUSH
84405: LD_INT 5
84407: ST_TO_ADDR
// if tmp < k then
84408: LD_VAR 0 14
84412: PUSH
84413: LD_VAR 0 9
84417: LESS
84418: IFFALSE 84430
// k := tmp ;
84420: LD_ADDR_VAR 0 9
84424: PUSH
84425: LD_VAR 0 14
84429: ST_TO_ADDR
// for j = 1 to k do
84430: LD_ADDR_VAR 0 8
84434: PUSH
84435: DOUBLE
84436: LD_INT 1
84438: DEC
84439: ST_TO_ADDR
84440: LD_VAR 0 9
84444: PUSH
84445: FOR_TO
84446: IFFALSE 84534
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84448: LD_VAR 0 14
84452: PUSH
84453: LD_VAR 0 8
84457: ARRAY
84458: PUSH
84459: LD_VAR 0 14
84463: PPUSH
84464: LD_INT 58
84466: PUSH
84467: EMPTY
84468: LIST
84469: PPUSH
84470: CALL_OW 72
84474: IN
84475: NOT
84476: IFFALSE 84532
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84478: LD_VAR 0 4
84482: PUSH
84483: LD_VAR 0 7
84487: ARRAY
84488: PPUSH
84489: LD_VAR 0 14
84493: PUSH
84494: LD_VAR 0 8
84498: ARRAY
84499: PPUSH
84500: CALL_OW 115
// attacking := true ;
84504: LD_ADDR_VAR 0 29
84508: PUSH
84509: LD_INT 1
84511: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84512: LD_VAR 0 4
84516: PUSH
84517: LD_VAR 0 7
84521: ARRAY
84522: PPUSH
84523: LD_INT 71
84525: PPUSH
84526: CALL_OW 109
// continue ;
84530: GO 84445
// end ; end ;
84532: GO 84445
84534: POP
84535: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84536: LD_VAR 0 4
84540: PUSH
84541: LD_VAR 0 7
84545: ARRAY
84546: PPUSH
84547: CALL_OW 257
84551: PUSH
84552: LD_INT 8
84554: EQUAL
84555: PUSH
84556: LD_VAR 0 4
84560: PUSH
84561: LD_VAR 0 7
84565: ARRAY
84566: PPUSH
84567: CALL_OW 264
84571: PUSH
84572: LD_INT 28
84574: PUSH
84575: LD_INT 45
84577: PUSH
84578: LD_INT 7
84580: PUSH
84581: LD_INT 47
84583: PUSH
84584: EMPTY
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: IN
84590: OR
84591: IFFALSE 84847
// begin attacking := false ;
84593: LD_ADDR_VAR 0 29
84597: PUSH
84598: LD_INT 0
84600: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84601: LD_VAR 0 14
84605: PUSH
84606: LD_INT 1
84608: ARRAY
84609: PPUSH
84610: CALL_OW 266
84614: PUSH
84615: LD_INT 32
84617: PUSH
84618: LD_INT 31
84620: PUSH
84621: LD_INT 33
84623: PUSH
84624: LD_INT 4
84626: PUSH
84627: LD_INT 5
84629: PUSH
84630: EMPTY
84631: LIST
84632: LIST
84633: LIST
84634: LIST
84635: LIST
84636: IN
84637: IFFALSE 84823
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84639: LD_ADDR_VAR 0 9
84643: PUSH
84644: LD_VAR 0 14
84648: PUSH
84649: LD_INT 1
84651: ARRAY
84652: PPUSH
84653: CALL_OW 266
84657: PPUSH
84658: LD_VAR 0 14
84662: PUSH
84663: LD_INT 1
84665: ARRAY
84666: PPUSH
84667: CALL_OW 250
84671: PPUSH
84672: LD_VAR 0 14
84676: PUSH
84677: LD_INT 1
84679: ARRAY
84680: PPUSH
84681: CALL_OW 251
84685: PPUSH
84686: LD_VAR 0 14
84690: PUSH
84691: LD_INT 1
84693: ARRAY
84694: PPUSH
84695: CALL_OW 254
84699: PPUSH
84700: LD_VAR 0 14
84704: PUSH
84705: LD_INT 1
84707: ARRAY
84708: PPUSH
84709: CALL_OW 248
84713: PPUSH
84714: LD_INT 0
84716: PPUSH
84717: CALL 24945 0 6
84721: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
84722: LD_ADDR_VAR 0 8
84726: PUSH
84727: LD_VAR 0 4
84731: PUSH
84732: LD_VAR 0 7
84736: ARRAY
84737: PPUSH
84738: LD_VAR 0 9
84742: PPUSH
84743: CALL 43615 0 2
84747: ST_TO_ADDR
// if j then
84748: LD_VAR 0 8
84752: IFFALSE 84821
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
84754: LD_VAR 0 8
84758: PUSH
84759: LD_INT 1
84761: ARRAY
84762: PPUSH
84763: LD_VAR 0 8
84767: PUSH
84768: LD_INT 2
84770: ARRAY
84771: PPUSH
84772: CALL_OW 488
84776: IFFALSE 84821
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
84778: LD_VAR 0 4
84782: PUSH
84783: LD_VAR 0 7
84787: ARRAY
84788: PPUSH
84789: LD_VAR 0 8
84793: PUSH
84794: LD_INT 1
84796: ARRAY
84797: PPUSH
84798: LD_VAR 0 8
84802: PUSH
84803: LD_INT 2
84805: ARRAY
84806: PPUSH
84807: CALL_OW 116
// attacking := true ;
84811: LD_ADDR_VAR 0 29
84815: PUSH
84816: LD_INT 1
84818: ST_TO_ADDR
// continue ;
84819: GO 82194
// end ; end else
84821: GO 84847
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84823: LD_VAR 0 4
84827: PUSH
84828: LD_VAR 0 7
84832: ARRAY
84833: PPUSH
84834: LD_VAR 0 14
84838: PUSH
84839: LD_INT 1
84841: ARRAY
84842: PPUSH
84843: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
84847: LD_VAR 0 4
84851: PUSH
84852: LD_VAR 0 7
84856: ARRAY
84857: PPUSH
84858: CALL_OW 265
84862: PUSH
84863: LD_INT 11
84865: EQUAL
84866: IFFALSE 85144
// begin k := 10 ;
84868: LD_ADDR_VAR 0 9
84872: PUSH
84873: LD_INT 10
84875: ST_TO_ADDR
// x := 0 ;
84876: LD_ADDR_VAR 0 10
84880: PUSH
84881: LD_INT 0
84883: ST_TO_ADDR
// if tmp < k then
84884: LD_VAR 0 14
84888: PUSH
84889: LD_VAR 0 9
84893: LESS
84894: IFFALSE 84906
// k := tmp ;
84896: LD_ADDR_VAR 0 9
84900: PUSH
84901: LD_VAR 0 14
84905: ST_TO_ADDR
// for j = k downto 1 do
84906: LD_ADDR_VAR 0 8
84910: PUSH
84911: DOUBLE
84912: LD_VAR 0 9
84916: INC
84917: ST_TO_ADDR
84918: LD_INT 1
84920: PUSH
84921: FOR_DOWNTO
84922: IFFALSE 84997
// begin if GetType ( tmp [ j ] ) = unit_human then
84924: LD_VAR 0 14
84928: PUSH
84929: LD_VAR 0 8
84933: ARRAY
84934: PPUSH
84935: CALL_OW 247
84939: PUSH
84940: LD_INT 1
84942: EQUAL
84943: IFFALSE 84995
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
84945: LD_VAR 0 4
84949: PUSH
84950: LD_VAR 0 7
84954: ARRAY
84955: PPUSH
84956: LD_VAR 0 14
84960: PUSH
84961: LD_VAR 0 8
84965: ARRAY
84966: PPUSH
84967: CALL 43886 0 2
// x := tmp [ j ] ;
84971: LD_ADDR_VAR 0 10
84975: PUSH
84976: LD_VAR 0 14
84980: PUSH
84981: LD_VAR 0 8
84985: ARRAY
84986: ST_TO_ADDR
// attacking := true ;
84987: LD_ADDR_VAR 0 29
84991: PUSH
84992: LD_INT 1
84994: ST_TO_ADDR
// end ; end ;
84995: GO 84921
84997: POP
84998: POP
// if not x then
84999: LD_VAR 0 10
85003: NOT
85004: IFFALSE 85144
// begin attacking := true ;
85006: LD_ADDR_VAR 0 29
85010: PUSH
85011: LD_INT 1
85013: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
85014: LD_VAR 0 4
85018: PUSH
85019: LD_VAR 0 7
85023: ARRAY
85024: PPUSH
85025: CALL_OW 250
85029: PPUSH
85030: LD_VAR 0 4
85034: PUSH
85035: LD_VAR 0 7
85039: ARRAY
85040: PPUSH
85041: CALL_OW 251
85045: PPUSH
85046: CALL_OW 546
85050: PUSH
85051: LD_INT 2
85053: ARRAY
85054: PUSH
85055: LD_VAR 0 14
85059: PUSH
85060: LD_INT 1
85062: ARRAY
85063: PPUSH
85064: CALL_OW 250
85068: PPUSH
85069: LD_VAR 0 14
85073: PUSH
85074: LD_INT 1
85076: ARRAY
85077: PPUSH
85078: CALL_OW 251
85082: PPUSH
85083: CALL_OW 546
85087: PUSH
85088: LD_INT 2
85090: ARRAY
85091: EQUAL
85092: IFFALSE 85120
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
85094: LD_VAR 0 4
85098: PUSH
85099: LD_VAR 0 7
85103: ARRAY
85104: PPUSH
85105: LD_VAR 0 14
85109: PUSH
85110: LD_INT 1
85112: ARRAY
85113: PPUSH
85114: CALL 43886 0 2
85118: GO 85144
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85120: LD_VAR 0 4
85124: PUSH
85125: LD_VAR 0 7
85129: ARRAY
85130: PPUSH
85131: LD_VAR 0 14
85135: PUSH
85136: LD_INT 1
85138: ARRAY
85139: PPUSH
85140: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
85144: LD_VAR 0 4
85148: PUSH
85149: LD_VAR 0 7
85153: ARRAY
85154: PPUSH
85155: CALL_OW 264
85159: PUSH
85160: LD_INT 29
85162: EQUAL
85163: IFFALSE 85529
// begin if WantsToAttack ( group [ i ] ) in bombed then
85165: LD_VAR 0 4
85169: PUSH
85170: LD_VAR 0 7
85174: ARRAY
85175: PPUSH
85176: CALL_OW 319
85180: PUSH
85181: LD_VAR 0 28
85185: IN
85186: IFFALSE 85190
// continue ;
85188: GO 82194
// k := 8 ;
85190: LD_ADDR_VAR 0 9
85194: PUSH
85195: LD_INT 8
85197: ST_TO_ADDR
// x := 0 ;
85198: LD_ADDR_VAR 0 10
85202: PUSH
85203: LD_INT 0
85205: ST_TO_ADDR
// if tmp < k then
85206: LD_VAR 0 14
85210: PUSH
85211: LD_VAR 0 9
85215: LESS
85216: IFFALSE 85228
// k := tmp ;
85218: LD_ADDR_VAR 0 9
85222: PUSH
85223: LD_VAR 0 14
85227: ST_TO_ADDR
// for j = 1 to k do
85228: LD_ADDR_VAR 0 8
85232: PUSH
85233: DOUBLE
85234: LD_INT 1
85236: DEC
85237: ST_TO_ADDR
85238: LD_VAR 0 9
85242: PUSH
85243: FOR_TO
85244: IFFALSE 85376
// begin if GetType ( tmp [ j ] ) = unit_building then
85246: LD_VAR 0 14
85250: PUSH
85251: LD_VAR 0 8
85255: ARRAY
85256: PPUSH
85257: CALL_OW 247
85261: PUSH
85262: LD_INT 3
85264: EQUAL
85265: IFFALSE 85374
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
85267: LD_VAR 0 14
85271: PUSH
85272: LD_VAR 0 8
85276: ARRAY
85277: PUSH
85278: LD_VAR 0 28
85282: IN
85283: NOT
85284: PUSH
85285: LD_VAR 0 14
85289: PUSH
85290: LD_VAR 0 8
85294: ARRAY
85295: PPUSH
85296: CALL_OW 313
85300: AND
85301: IFFALSE 85374
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85303: LD_VAR 0 4
85307: PUSH
85308: LD_VAR 0 7
85312: ARRAY
85313: PPUSH
85314: LD_VAR 0 14
85318: PUSH
85319: LD_VAR 0 8
85323: ARRAY
85324: PPUSH
85325: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85329: LD_ADDR_VAR 0 28
85333: PUSH
85334: LD_VAR 0 28
85338: PPUSH
85339: LD_VAR 0 28
85343: PUSH
85344: LD_INT 1
85346: PLUS
85347: PPUSH
85348: LD_VAR 0 14
85352: PUSH
85353: LD_VAR 0 8
85357: ARRAY
85358: PPUSH
85359: CALL_OW 1
85363: ST_TO_ADDR
// attacking := true ;
85364: LD_ADDR_VAR 0 29
85368: PUSH
85369: LD_INT 1
85371: ST_TO_ADDR
// break ;
85372: GO 85376
// end ; end ;
85374: GO 85243
85376: POP
85377: POP
// if not attacking and f_attack_depot then
85378: LD_VAR 0 29
85382: NOT
85383: PUSH
85384: LD_VAR 0 25
85388: AND
85389: IFFALSE 85484
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85391: LD_ADDR_VAR 0 13
85395: PUSH
85396: LD_VAR 0 14
85400: PPUSH
85401: LD_INT 2
85403: PUSH
85404: LD_INT 30
85406: PUSH
85407: LD_INT 0
85409: PUSH
85410: EMPTY
85411: LIST
85412: LIST
85413: PUSH
85414: LD_INT 30
85416: PUSH
85417: LD_INT 1
85419: PUSH
85420: EMPTY
85421: LIST
85422: LIST
85423: PUSH
85424: EMPTY
85425: LIST
85426: LIST
85427: LIST
85428: PPUSH
85429: CALL_OW 72
85433: ST_TO_ADDR
// if z then
85434: LD_VAR 0 13
85438: IFFALSE 85484
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85440: LD_VAR 0 4
85444: PUSH
85445: LD_VAR 0 7
85449: ARRAY
85450: PPUSH
85451: LD_VAR 0 13
85455: PPUSH
85456: LD_VAR 0 4
85460: PUSH
85461: LD_VAR 0 7
85465: ARRAY
85466: PPUSH
85467: CALL_OW 74
85471: PPUSH
85472: CALL_OW 115
// attacking := true ;
85476: LD_ADDR_VAR 0 29
85480: PUSH
85481: LD_INT 1
85483: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85484: LD_VAR 0 4
85488: PUSH
85489: LD_VAR 0 7
85493: ARRAY
85494: PPUSH
85495: CALL_OW 256
85499: PUSH
85500: LD_INT 500
85502: LESS
85503: IFFALSE 85529
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85505: LD_VAR 0 4
85509: PUSH
85510: LD_VAR 0 7
85514: ARRAY
85515: PPUSH
85516: LD_VAR 0 14
85520: PUSH
85521: LD_INT 1
85523: ARRAY
85524: PPUSH
85525: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85529: LD_VAR 0 4
85533: PUSH
85534: LD_VAR 0 7
85538: ARRAY
85539: PPUSH
85540: CALL_OW 264
85544: PUSH
85545: LD_INT 49
85547: EQUAL
85548: IFFALSE 85669
// begin if not HasTask ( group [ i ] ) then
85550: LD_VAR 0 4
85554: PUSH
85555: LD_VAR 0 7
85559: ARRAY
85560: PPUSH
85561: CALL_OW 314
85565: NOT
85566: IFFALSE 85669
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85568: LD_ADDR_VAR 0 9
85572: PUSH
85573: LD_INT 81
85575: PUSH
85576: LD_VAR 0 4
85580: PUSH
85581: LD_VAR 0 7
85585: ARRAY
85586: PPUSH
85587: CALL_OW 255
85591: PUSH
85592: EMPTY
85593: LIST
85594: LIST
85595: PPUSH
85596: CALL_OW 69
85600: PPUSH
85601: LD_VAR 0 4
85605: PUSH
85606: LD_VAR 0 7
85610: ARRAY
85611: PPUSH
85612: CALL_OW 74
85616: ST_TO_ADDR
// if k then
85617: LD_VAR 0 9
85621: IFFALSE 85669
// if GetDistUnits ( group [ i ] , k ) > 10 then
85623: LD_VAR 0 4
85627: PUSH
85628: LD_VAR 0 7
85632: ARRAY
85633: PPUSH
85634: LD_VAR 0 9
85638: PPUSH
85639: CALL_OW 296
85643: PUSH
85644: LD_INT 10
85646: GREATER
85647: IFFALSE 85669
// ComMoveUnit ( group [ i ] , k ) ;
85649: LD_VAR 0 4
85653: PUSH
85654: LD_VAR 0 7
85658: ARRAY
85659: PPUSH
85660: LD_VAR 0 9
85664: PPUSH
85665: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85669: LD_VAR 0 4
85673: PUSH
85674: LD_VAR 0 7
85678: ARRAY
85679: PPUSH
85680: CALL_OW 256
85684: PUSH
85685: LD_INT 250
85687: LESS
85688: PUSH
85689: LD_VAR 0 4
85693: PUSH
85694: LD_VAR 0 7
85698: ARRAY
85699: PUSH
85700: LD_INT 21
85702: PUSH
85703: LD_INT 2
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 23
85712: PUSH
85713: LD_INT 2
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PPUSH
85724: CALL_OW 69
85728: IN
85729: AND
85730: IFFALSE 85855
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
85732: LD_ADDR_VAR 0 9
85736: PUSH
85737: LD_OWVAR 3
85741: PUSH
85742: LD_VAR 0 4
85746: PUSH
85747: LD_VAR 0 7
85751: ARRAY
85752: DIFF
85753: PPUSH
85754: LD_VAR 0 4
85758: PUSH
85759: LD_VAR 0 7
85763: ARRAY
85764: PPUSH
85765: CALL_OW 74
85769: ST_TO_ADDR
// if not k then
85770: LD_VAR 0 9
85774: NOT
85775: IFFALSE 85779
// continue ;
85777: GO 82194
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
85779: LD_VAR 0 9
85783: PUSH
85784: LD_INT 81
85786: PUSH
85787: LD_VAR 0 4
85791: PUSH
85792: LD_VAR 0 7
85796: ARRAY
85797: PPUSH
85798: CALL_OW 255
85802: PUSH
85803: EMPTY
85804: LIST
85805: LIST
85806: PPUSH
85807: CALL_OW 69
85811: IN
85812: PUSH
85813: LD_VAR 0 9
85817: PPUSH
85818: LD_VAR 0 4
85822: PUSH
85823: LD_VAR 0 7
85827: ARRAY
85828: PPUSH
85829: CALL_OW 296
85833: PUSH
85834: LD_INT 5
85836: LESS
85837: AND
85838: IFFALSE 85855
// ComAutodestruct ( group [ i ] ) ;
85840: LD_VAR 0 4
85844: PUSH
85845: LD_VAR 0 7
85849: ARRAY
85850: PPUSH
85851: CALL 43784 0 1
// end ; if f_attack_depot then
85855: LD_VAR 0 25
85859: IFFALSE 85971
// begin k := 6 ;
85861: LD_ADDR_VAR 0 9
85865: PUSH
85866: LD_INT 6
85868: ST_TO_ADDR
// if tmp < k then
85869: LD_VAR 0 14
85873: PUSH
85874: LD_VAR 0 9
85878: LESS
85879: IFFALSE 85891
// k := tmp ;
85881: LD_ADDR_VAR 0 9
85885: PUSH
85886: LD_VAR 0 14
85890: ST_TO_ADDR
// for j = 1 to k do
85891: LD_ADDR_VAR 0 8
85895: PUSH
85896: DOUBLE
85897: LD_INT 1
85899: DEC
85900: ST_TO_ADDR
85901: LD_VAR 0 9
85905: PUSH
85906: FOR_TO
85907: IFFALSE 85969
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
85909: LD_VAR 0 8
85913: PPUSH
85914: CALL_OW 266
85918: PUSH
85919: LD_INT 0
85921: PUSH
85922: LD_INT 1
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: IN
85929: IFFALSE 85967
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85931: LD_VAR 0 4
85935: PUSH
85936: LD_VAR 0 7
85940: ARRAY
85941: PPUSH
85942: LD_VAR 0 14
85946: PUSH
85947: LD_VAR 0 8
85951: ARRAY
85952: PPUSH
85953: CALL_OW 115
// attacking := true ;
85957: LD_ADDR_VAR 0 29
85961: PUSH
85962: LD_INT 1
85964: ST_TO_ADDR
// break ;
85965: GO 85969
// end ;
85967: GO 85906
85969: POP
85970: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85971: LD_VAR 0 4
85975: PUSH
85976: LD_VAR 0 7
85980: ARRAY
85981: PPUSH
85982: CALL_OW 302
85986: PUSH
85987: LD_VAR 0 29
85991: NOT
85992: AND
85993: IFFALSE 86315
// begin if GetTag ( group [ i ] ) = 71 then
85995: LD_VAR 0 4
85999: PUSH
86000: LD_VAR 0 7
86004: ARRAY
86005: PPUSH
86006: CALL_OW 110
86010: PUSH
86011: LD_INT 71
86013: EQUAL
86014: IFFALSE 86055
// begin if HasTask ( group [ i ] ) then
86016: LD_VAR 0 4
86020: PUSH
86021: LD_VAR 0 7
86025: ARRAY
86026: PPUSH
86027: CALL_OW 314
86031: IFFALSE 86037
// continue else
86033: GO 82194
86035: GO 86055
// SetTag ( group [ i ] , 0 ) ;
86037: LD_VAR 0 4
86041: PUSH
86042: LD_VAR 0 7
86046: ARRAY
86047: PPUSH
86048: LD_INT 0
86050: PPUSH
86051: CALL_OW 109
// end ; k := 8 ;
86055: LD_ADDR_VAR 0 9
86059: PUSH
86060: LD_INT 8
86062: ST_TO_ADDR
// x := 0 ;
86063: LD_ADDR_VAR 0 10
86067: PUSH
86068: LD_INT 0
86070: ST_TO_ADDR
// if tmp < k then
86071: LD_VAR 0 14
86075: PUSH
86076: LD_VAR 0 9
86080: LESS
86081: IFFALSE 86093
// k := tmp ;
86083: LD_ADDR_VAR 0 9
86087: PUSH
86088: LD_VAR 0 14
86092: ST_TO_ADDR
// for j = 1 to k do
86093: LD_ADDR_VAR 0 8
86097: PUSH
86098: DOUBLE
86099: LD_INT 1
86101: DEC
86102: ST_TO_ADDR
86103: LD_VAR 0 9
86107: PUSH
86108: FOR_TO
86109: IFFALSE 86207
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
86111: LD_VAR 0 14
86115: PUSH
86116: LD_VAR 0 8
86120: ARRAY
86121: PPUSH
86122: CALL_OW 247
86126: PUSH
86127: LD_INT 1
86129: EQUAL
86130: PUSH
86131: LD_VAR 0 14
86135: PUSH
86136: LD_VAR 0 8
86140: ARRAY
86141: PPUSH
86142: CALL_OW 256
86146: PUSH
86147: LD_INT 250
86149: LESS
86150: PUSH
86151: LD_VAR 0 20
86155: AND
86156: PUSH
86157: LD_VAR 0 20
86161: NOT
86162: PUSH
86163: LD_VAR 0 14
86167: PUSH
86168: LD_VAR 0 8
86172: ARRAY
86173: PPUSH
86174: CALL_OW 256
86178: PUSH
86179: LD_INT 250
86181: GREATEREQUAL
86182: AND
86183: OR
86184: AND
86185: IFFALSE 86205
// begin x := tmp [ j ] ;
86187: LD_ADDR_VAR 0 10
86191: PUSH
86192: LD_VAR 0 14
86196: PUSH
86197: LD_VAR 0 8
86201: ARRAY
86202: ST_TO_ADDR
// break ;
86203: GO 86207
// end ;
86205: GO 86108
86207: POP
86208: POP
// if x then
86209: LD_VAR 0 10
86213: IFFALSE 86237
// ComAttackUnit ( group [ i ] , x ) else
86215: LD_VAR 0 4
86219: PUSH
86220: LD_VAR 0 7
86224: ARRAY
86225: PPUSH
86226: LD_VAR 0 10
86230: PPUSH
86231: CALL_OW 115
86235: GO 86261
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86237: LD_VAR 0 4
86241: PUSH
86242: LD_VAR 0 7
86246: ARRAY
86247: PPUSH
86248: LD_VAR 0 14
86252: PUSH
86253: LD_INT 1
86255: ARRAY
86256: PPUSH
86257: CALL_OW 115
// if not HasTask ( group [ i ] ) then
86261: LD_VAR 0 4
86265: PUSH
86266: LD_VAR 0 7
86270: ARRAY
86271: PPUSH
86272: CALL_OW 314
86276: NOT
86277: IFFALSE 86315
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
86279: LD_VAR 0 4
86283: PUSH
86284: LD_VAR 0 7
86288: ARRAY
86289: PPUSH
86290: LD_VAR 0 14
86294: PPUSH
86295: LD_VAR 0 4
86299: PUSH
86300: LD_VAR 0 7
86304: ARRAY
86305: PPUSH
86306: CALL_OW 74
86310: PPUSH
86311: CALL_OW 115
// end ; end ; end ;
86315: GO 82194
86317: POP
86318: POP
// wait ( 0 0$2 ) ;
86319: LD_INT 70
86321: PPUSH
86322: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86326: LD_VAR 0 4
86330: NOT
86331: PUSH
86332: LD_VAR 0 4
86336: PUSH
86337: EMPTY
86338: EQUAL
86339: OR
86340: PUSH
86341: LD_INT 81
86343: PUSH
86344: LD_VAR 0 35
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PPUSH
86353: CALL_OW 69
86357: NOT
86358: OR
86359: IFFALSE 82179
// end ;
86361: LD_VAR 0 2
86365: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86366: LD_INT 0
86368: PPUSH
86369: PPUSH
86370: PPUSH
86371: PPUSH
86372: PPUSH
86373: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86374: LD_VAR 0 1
86378: NOT
86379: PUSH
86380: LD_EXP 23
86384: PUSH
86385: LD_VAR 0 1
86389: ARRAY
86390: NOT
86391: OR
86392: PUSH
86393: LD_VAR 0 2
86397: NOT
86398: OR
86399: IFFALSE 86403
// exit ;
86401: GO 86957
// side := mc_sides [ base ] ;
86403: LD_ADDR_VAR 0 6
86407: PUSH
86408: LD_EXP 49
86412: PUSH
86413: LD_VAR 0 1
86417: ARRAY
86418: ST_TO_ADDR
// if not side then
86419: LD_VAR 0 6
86423: NOT
86424: IFFALSE 86428
// exit ;
86426: GO 86957
// for i in solds do
86428: LD_ADDR_VAR 0 7
86432: PUSH
86433: LD_VAR 0 2
86437: PUSH
86438: FOR_IN
86439: IFFALSE 86500
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86441: LD_VAR 0 7
86445: PPUSH
86446: CALL_OW 310
86450: PPUSH
86451: CALL_OW 266
86455: PUSH
86456: LD_INT 32
86458: PUSH
86459: LD_INT 31
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: IN
86466: IFFALSE 86486
// solds := solds diff i else
86468: LD_ADDR_VAR 0 2
86472: PUSH
86473: LD_VAR 0 2
86477: PUSH
86478: LD_VAR 0 7
86482: DIFF
86483: ST_TO_ADDR
86484: GO 86498
// SetTag ( i , 18 ) ;
86486: LD_VAR 0 7
86490: PPUSH
86491: LD_INT 18
86493: PPUSH
86494: CALL_OW 109
86498: GO 86438
86500: POP
86501: POP
// if not solds then
86502: LD_VAR 0 2
86506: NOT
86507: IFFALSE 86511
// exit ;
86509: GO 86957
// repeat wait ( 0 0$2 ) ;
86511: LD_INT 70
86513: PPUSH
86514: CALL_OW 67
// enemy := mc_scan [ base ] ;
86518: LD_ADDR_VAR 0 4
86522: PUSH
86523: LD_EXP 46
86527: PUSH
86528: LD_VAR 0 1
86532: ARRAY
86533: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86534: LD_EXP 23
86538: PUSH
86539: LD_VAR 0 1
86543: ARRAY
86544: NOT
86545: PUSH
86546: LD_EXP 23
86550: PUSH
86551: LD_VAR 0 1
86555: ARRAY
86556: PUSH
86557: EMPTY
86558: EQUAL
86559: OR
86560: IFFALSE 86597
// begin for i in solds do
86562: LD_ADDR_VAR 0 7
86566: PUSH
86567: LD_VAR 0 2
86571: PUSH
86572: FOR_IN
86573: IFFALSE 86586
// ComStop ( i ) ;
86575: LD_VAR 0 7
86579: PPUSH
86580: CALL_OW 141
86584: GO 86572
86586: POP
86587: POP
// solds := [ ] ;
86588: LD_ADDR_VAR 0 2
86592: PUSH
86593: EMPTY
86594: ST_TO_ADDR
// exit ;
86595: GO 86957
// end ; for i in solds do
86597: LD_ADDR_VAR 0 7
86601: PUSH
86602: LD_VAR 0 2
86606: PUSH
86607: FOR_IN
86608: IFFALSE 86929
// begin if IsInUnit ( i ) then
86610: LD_VAR 0 7
86614: PPUSH
86615: CALL_OW 310
86619: IFFALSE 86630
// ComExitBuilding ( i ) ;
86621: LD_VAR 0 7
86625: PPUSH
86626: CALL_OW 122
// if GetLives ( i ) > 500 then
86630: LD_VAR 0 7
86634: PPUSH
86635: CALL_OW 256
86639: PUSH
86640: LD_INT 500
86642: GREATER
86643: IFFALSE 86696
// begin e := NearestUnitToUnit ( enemy , i ) ;
86645: LD_ADDR_VAR 0 5
86649: PUSH
86650: LD_VAR 0 4
86654: PPUSH
86655: LD_VAR 0 7
86659: PPUSH
86660: CALL_OW 74
86664: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86665: LD_VAR 0 7
86669: PPUSH
86670: LD_VAR 0 5
86674: PPUSH
86675: CALL_OW 250
86679: PPUSH
86680: LD_VAR 0 5
86684: PPUSH
86685: CALL_OW 251
86689: PPUSH
86690: CALL_OW 114
// end else
86694: GO 86927
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86696: LD_VAR 0 7
86700: PPUSH
86701: LD_EXP 23
86705: PUSH
86706: LD_VAR 0 1
86710: ARRAY
86711: PPUSH
86712: LD_INT 2
86714: PUSH
86715: LD_INT 30
86717: PUSH
86718: LD_INT 0
86720: PUSH
86721: EMPTY
86722: LIST
86723: LIST
86724: PUSH
86725: LD_INT 30
86727: PUSH
86728: LD_INT 1
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 30
86737: PUSH
86738: LD_INT 6
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: PPUSH
86751: CALL_OW 72
86755: PPUSH
86756: LD_VAR 0 7
86760: PPUSH
86761: CALL_OW 74
86765: PPUSH
86766: CALL_OW 296
86770: PUSH
86771: LD_INT 10
86773: GREATER
86774: IFFALSE 86927
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
86776: LD_ADDR_VAR 0 8
86780: PUSH
86781: LD_EXP 23
86785: PUSH
86786: LD_VAR 0 1
86790: ARRAY
86791: PPUSH
86792: LD_INT 2
86794: PUSH
86795: LD_INT 30
86797: PUSH
86798: LD_INT 0
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 30
86807: PUSH
86808: LD_INT 1
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 30
86817: PUSH
86818: LD_INT 6
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: LIST
86829: LIST
86830: PPUSH
86831: CALL_OW 72
86835: PPUSH
86836: LD_VAR 0 7
86840: PPUSH
86841: CALL_OW 74
86845: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
86846: LD_VAR 0 7
86850: PPUSH
86851: LD_VAR 0 8
86855: PPUSH
86856: CALL_OW 250
86860: PPUSH
86861: LD_INT 3
86863: PPUSH
86864: LD_INT 5
86866: PPUSH
86867: CALL_OW 272
86871: PPUSH
86872: LD_VAR 0 8
86876: PPUSH
86877: CALL_OW 251
86881: PPUSH
86882: LD_INT 3
86884: PPUSH
86885: LD_INT 5
86887: PPUSH
86888: CALL_OW 273
86892: PPUSH
86893: CALL_OW 111
// SetTag ( i , 0 ) ;
86897: LD_VAR 0 7
86901: PPUSH
86902: LD_INT 0
86904: PPUSH
86905: CALL_OW 109
// solds := solds diff i ;
86909: LD_ADDR_VAR 0 2
86913: PUSH
86914: LD_VAR 0 2
86918: PUSH
86919: LD_VAR 0 7
86923: DIFF
86924: ST_TO_ADDR
// continue ;
86925: GO 86607
// end ; end ;
86927: GO 86607
86929: POP
86930: POP
// until not solds or not enemy ;
86931: LD_VAR 0 2
86935: NOT
86936: PUSH
86937: LD_VAR 0 4
86941: NOT
86942: OR
86943: IFFALSE 86511
// MC_Reset ( base , 18 ) ;
86945: LD_VAR 0 1
86949: PPUSH
86950: LD_INT 18
86952: PPUSH
86953: CALL 55017 0 2
// end ;
86957: LD_VAR 0 3
86961: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86962: LD_INT 0
86964: PPUSH
86965: PPUSH
86966: PPUSH
86967: PPUSH
86968: PPUSH
86969: PPUSH
86970: PPUSH
86971: PPUSH
86972: PPUSH
86973: PPUSH
86974: PPUSH
86975: PPUSH
86976: PPUSH
86977: PPUSH
86978: PPUSH
86979: PPUSH
86980: PPUSH
86981: PPUSH
86982: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86983: LD_ADDR_VAR 0 12
86987: PUSH
86988: LD_EXP 23
86992: PUSH
86993: LD_VAR 0 1
86997: ARRAY
86998: PPUSH
86999: LD_INT 25
87001: PUSH
87002: LD_INT 3
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PPUSH
87009: CALL_OW 72
87013: ST_TO_ADDR
// if mc_remote_driver [ base ] then
87014: LD_EXP 63
87018: PUSH
87019: LD_VAR 0 1
87023: ARRAY
87024: IFFALSE 87048
// mechs := mechs diff mc_remote_driver [ base ] ;
87026: LD_ADDR_VAR 0 12
87030: PUSH
87031: LD_VAR 0 12
87035: PUSH
87036: LD_EXP 63
87040: PUSH
87041: LD_VAR 0 1
87045: ARRAY
87046: DIFF
87047: ST_TO_ADDR
// for i in mechs do
87048: LD_ADDR_VAR 0 4
87052: PUSH
87053: LD_VAR 0 12
87057: PUSH
87058: FOR_IN
87059: IFFALSE 87094
// if GetTag ( i ) > 0 then
87061: LD_VAR 0 4
87065: PPUSH
87066: CALL_OW 110
87070: PUSH
87071: LD_INT 0
87073: GREATER
87074: IFFALSE 87092
// mechs := mechs diff i ;
87076: LD_ADDR_VAR 0 12
87080: PUSH
87081: LD_VAR 0 12
87085: PUSH
87086: LD_VAR 0 4
87090: DIFF
87091: ST_TO_ADDR
87092: GO 87058
87094: POP
87095: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87096: LD_ADDR_VAR 0 8
87100: PUSH
87101: LD_EXP 23
87105: PUSH
87106: LD_VAR 0 1
87110: ARRAY
87111: PPUSH
87112: LD_INT 2
87114: PUSH
87115: LD_INT 25
87117: PUSH
87118: LD_INT 1
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PUSH
87125: LD_INT 25
87127: PUSH
87128: LD_INT 5
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 25
87137: PUSH
87138: LD_INT 8
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PUSH
87145: LD_INT 25
87147: PUSH
87148: LD_INT 9
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: PPUSH
87162: CALL_OW 72
87166: ST_TO_ADDR
// if not defenders and not solds then
87167: LD_VAR 0 2
87171: NOT
87172: PUSH
87173: LD_VAR 0 8
87177: NOT
87178: AND
87179: IFFALSE 87183
// exit ;
87181: GO 88953
// depot_under_attack := false ;
87183: LD_ADDR_VAR 0 16
87187: PUSH
87188: LD_INT 0
87190: ST_TO_ADDR
// sold_defenders := [ ] ;
87191: LD_ADDR_VAR 0 17
87195: PUSH
87196: EMPTY
87197: ST_TO_ADDR
// if mechs then
87198: LD_VAR 0 12
87202: IFFALSE 87355
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
87204: LD_ADDR_VAR 0 4
87208: PUSH
87209: LD_VAR 0 2
87213: PPUSH
87214: LD_INT 21
87216: PUSH
87217: LD_INT 2
87219: PUSH
87220: EMPTY
87221: LIST
87222: LIST
87223: PPUSH
87224: CALL_OW 72
87228: PUSH
87229: FOR_IN
87230: IFFALSE 87353
// begin if GetTag ( i ) <> 20 then
87232: LD_VAR 0 4
87236: PPUSH
87237: CALL_OW 110
87241: PUSH
87242: LD_INT 20
87244: NONEQUAL
87245: IFFALSE 87259
// SetTag ( i , 20 ) ;
87247: LD_VAR 0 4
87251: PPUSH
87252: LD_INT 20
87254: PPUSH
87255: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
87259: LD_VAR 0 4
87263: PPUSH
87264: CALL_OW 263
87268: PUSH
87269: LD_INT 1
87271: EQUAL
87272: PUSH
87273: LD_VAR 0 4
87277: PPUSH
87278: CALL_OW 311
87282: NOT
87283: AND
87284: IFFALSE 87351
// begin un := mechs [ 1 ] ;
87286: LD_ADDR_VAR 0 10
87290: PUSH
87291: LD_VAR 0 12
87295: PUSH
87296: LD_INT 1
87298: ARRAY
87299: ST_TO_ADDR
// ComExit ( un ) ;
87300: LD_VAR 0 10
87304: PPUSH
87305: CALL 48129 0 1
// AddComEnterUnit ( un , i ) ;
87309: LD_VAR 0 10
87313: PPUSH
87314: LD_VAR 0 4
87318: PPUSH
87319: CALL_OW 180
// SetTag ( un , 19 ) ;
87323: LD_VAR 0 10
87327: PPUSH
87328: LD_INT 19
87330: PPUSH
87331: CALL_OW 109
// mechs := mechs diff un ;
87335: LD_ADDR_VAR 0 12
87339: PUSH
87340: LD_VAR 0 12
87344: PUSH
87345: LD_VAR 0 10
87349: DIFF
87350: ST_TO_ADDR
// end ; end ;
87351: GO 87229
87353: POP
87354: POP
// if solds then
87355: LD_VAR 0 8
87359: IFFALSE 87418
// for i in solds do
87361: LD_ADDR_VAR 0 4
87365: PUSH
87366: LD_VAR 0 8
87370: PUSH
87371: FOR_IN
87372: IFFALSE 87416
// if not GetTag ( i ) then
87374: LD_VAR 0 4
87378: PPUSH
87379: CALL_OW 110
87383: NOT
87384: IFFALSE 87414
// begin defenders := defenders union i ;
87386: LD_ADDR_VAR 0 2
87390: PUSH
87391: LD_VAR 0 2
87395: PUSH
87396: LD_VAR 0 4
87400: UNION
87401: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87402: LD_VAR 0 4
87406: PPUSH
87407: LD_INT 18
87409: PPUSH
87410: CALL_OW 109
// end ;
87414: GO 87371
87416: POP
87417: POP
// repeat wait ( 0 0$2 ) ;
87418: LD_INT 70
87420: PPUSH
87421: CALL_OW 67
// enemy := mc_scan [ base ] ;
87425: LD_ADDR_VAR 0 21
87429: PUSH
87430: LD_EXP 46
87434: PUSH
87435: LD_VAR 0 1
87439: ARRAY
87440: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87441: LD_EXP 23
87445: PUSH
87446: LD_VAR 0 1
87450: ARRAY
87451: NOT
87452: PUSH
87453: LD_EXP 23
87457: PUSH
87458: LD_VAR 0 1
87462: ARRAY
87463: PUSH
87464: EMPTY
87465: EQUAL
87466: OR
87467: IFFALSE 87504
// begin for i in defenders do
87469: LD_ADDR_VAR 0 4
87473: PUSH
87474: LD_VAR 0 2
87478: PUSH
87479: FOR_IN
87480: IFFALSE 87493
// ComStop ( i ) ;
87482: LD_VAR 0 4
87486: PPUSH
87487: CALL_OW 141
87491: GO 87479
87493: POP
87494: POP
// defenders := [ ] ;
87495: LD_ADDR_VAR 0 2
87499: PUSH
87500: EMPTY
87501: ST_TO_ADDR
// exit ;
87502: GO 88953
// end ; for i in defenders do
87504: LD_ADDR_VAR 0 4
87508: PUSH
87509: LD_VAR 0 2
87513: PUSH
87514: FOR_IN
87515: IFFALSE 88413
// begin e := NearestUnitToUnit ( enemy , i ) ;
87517: LD_ADDR_VAR 0 13
87521: PUSH
87522: LD_VAR 0 21
87526: PPUSH
87527: LD_VAR 0 4
87531: PPUSH
87532: CALL_OW 74
87536: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87537: LD_ADDR_VAR 0 7
87541: PUSH
87542: LD_EXP 23
87546: PUSH
87547: LD_VAR 0 1
87551: ARRAY
87552: PPUSH
87553: LD_INT 2
87555: PUSH
87556: LD_INT 30
87558: PUSH
87559: LD_INT 0
87561: PUSH
87562: EMPTY
87563: LIST
87564: LIST
87565: PUSH
87566: LD_INT 30
87568: PUSH
87569: LD_INT 1
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: LIST
87580: PPUSH
87581: CALL_OW 72
87585: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87586: LD_ADDR_VAR 0 16
87590: PUSH
87591: LD_VAR 0 7
87595: NOT
87596: PUSH
87597: LD_VAR 0 7
87601: PPUSH
87602: LD_INT 3
87604: PUSH
87605: LD_INT 24
87607: PUSH
87608: LD_INT 600
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PPUSH
87619: CALL_OW 72
87623: OR
87624: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87625: LD_VAR 0 4
87629: PPUSH
87630: CALL_OW 247
87634: PUSH
87635: LD_INT 2
87637: DOUBLE
87638: EQUAL
87639: IFTRUE 87643
87641: GO 88039
87643: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87644: LD_VAR 0 4
87648: PPUSH
87649: CALL_OW 256
87653: PUSH
87654: LD_INT 1000
87656: EQUAL
87657: PUSH
87658: LD_VAR 0 4
87662: PPUSH
87663: LD_VAR 0 13
87667: PPUSH
87668: CALL_OW 296
87672: PUSH
87673: LD_INT 40
87675: LESS
87676: PUSH
87677: LD_VAR 0 13
87681: PPUSH
87682: LD_EXP 48
87686: PUSH
87687: LD_VAR 0 1
87691: ARRAY
87692: PPUSH
87693: CALL_OW 308
87697: OR
87698: AND
87699: IFFALSE 87821
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87701: LD_VAR 0 4
87705: PPUSH
87706: CALL_OW 262
87710: PUSH
87711: LD_INT 1
87713: EQUAL
87714: PUSH
87715: LD_VAR 0 4
87719: PPUSH
87720: CALL_OW 261
87724: PUSH
87725: LD_INT 30
87727: LESS
87728: AND
87729: PUSH
87730: LD_VAR 0 7
87734: AND
87735: IFFALSE 87805
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
87737: LD_VAR 0 4
87741: PPUSH
87742: LD_VAR 0 7
87746: PPUSH
87747: LD_VAR 0 4
87751: PPUSH
87752: CALL_OW 74
87756: PPUSH
87757: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
87761: LD_VAR 0 4
87765: PPUSH
87766: LD_VAR 0 7
87770: PPUSH
87771: LD_VAR 0 4
87775: PPUSH
87776: CALL_OW 74
87780: PPUSH
87781: CALL_OW 296
87785: PUSH
87786: LD_INT 6
87788: LESS
87789: IFFALSE 87803
// SetFuel ( i , 100 ) ;
87791: LD_VAR 0 4
87795: PPUSH
87796: LD_INT 100
87798: PPUSH
87799: CALL_OW 240
// end else
87803: GO 87819
// ComAttackUnit ( i , e ) ;
87805: LD_VAR 0 4
87809: PPUSH
87810: LD_VAR 0 13
87814: PPUSH
87815: CALL_OW 115
// end else
87819: GO 87922
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
87821: LD_VAR 0 13
87825: PPUSH
87826: LD_EXP 48
87830: PUSH
87831: LD_VAR 0 1
87835: ARRAY
87836: PPUSH
87837: CALL_OW 308
87841: NOT
87842: PUSH
87843: LD_VAR 0 4
87847: PPUSH
87848: LD_VAR 0 13
87852: PPUSH
87853: CALL_OW 296
87857: PUSH
87858: LD_INT 40
87860: GREATEREQUAL
87861: AND
87862: PUSH
87863: LD_VAR 0 4
87867: PPUSH
87868: CALL_OW 256
87872: PUSH
87873: LD_INT 650
87875: LESSEQUAL
87876: OR
87877: PUSH
87878: LD_VAR 0 4
87882: PPUSH
87883: LD_EXP 47
87887: PUSH
87888: LD_VAR 0 1
87892: ARRAY
87893: PPUSH
87894: CALL_OW 308
87898: NOT
87899: AND
87900: IFFALSE 87922
// ComMoveToArea ( i , mc_parking [ base ] ) ;
87902: LD_VAR 0 4
87906: PPUSH
87907: LD_EXP 47
87911: PUSH
87912: LD_VAR 0 1
87916: ARRAY
87917: PPUSH
87918: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
87922: LD_VAR 0 4
87926: PPUSH
87927: CALL_OW 256
87931: PUSH
87932: LD_INT 1000
87934: LESS
87935: PUSH
87936: LD_VAR 0 4
87940: PPUSH
87941: CALL_OW 263
87945: PUSH
87946: LD_INT 1
87948: EQUAL
87949: AND
87950: PUSH
87951: LD_VAR 0 4
87955: PPUSH
87956: CALL_OW 311
87960: AND
87961: PUSH
87962: LD_VAR 0 4
87966: PPUSH
87967: LD_EXP 47
87971: PUSH
87972: LD_VAR 0 1
87976: ARRAY
87977: PPUSH
87978: CALL_OW 308
87982: AND
87983: IFFALSE 88037
// begin mech := IsDrivenBy ( i ) ;
87985: LD_ADDR_VAR 0 9
87989: PUSH
87990: LD_VAR 0 4
87994: PPUSH
87995: CALL_OW 311
87999: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
88000: LD_VAR 0 9
88004: PPUSH
88005: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
88009: LD_VAR 0 9
88013: PPUSH
88014: LD_VAR 0 4
88018: PPUSH
88019: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
88023: LD_VAR 0 9
88027: PPUSH
88028: LD_VAR 0 4
88032: PPUSH
88033: CALL_OW 180
// end ; end ; unit_human :
88037: GO 88384
88039: LD_INT 1
88041: DOUBLE
88042: EQUAL
88043: IFTRUE 88047
88045: GO 88383
88047: POP
// begin b := IsInUnit ( i ) ;
88048: LD_ADDR_VAR 0 18
88052: PUSH
88053: LD_VAR 0 4
88057: PPUSH
88058: CALL_OW 310
88062: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
88063: LD_ADDR_VAR 0 19
88067: PUSH
88068: LD_VAR 0 18
88072: NOT
88073: PUSH
88074: LD_VAR 0 18
88078: PPUSH
88079: CALL_OW 266
88083: PUSH
88084: LD_INT 32
88086: PUSH
88087: LD_INT 31
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: IN
88094: OR
88095: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
88096: LD_VAR 0 18
88100: PPUSH
88101: CALL_OW 266
88105: PUSH
88106: LD_INT 5
88108: EQUAL
88109: PUSH
88110: LD_VAR 0 4
88114: PPUSH
88115: CALL_OW 257
88119: PUSH
88120: LD_INT 1
88122: PUSH
88123: LD_INT 2
88125: PUSH
88126: LD_INT 3
88128: PUSH
88129: LD_INT 4
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: IN
88138: AND
88139: IFFALSE 88176
// begin class := AllowSpecClass ( i ) ;
88141: LD_ADDR_VAR 0 20
88145: PUSH
88146: LD_VAR 0 4
88150: PPUSH
88151: CALL 12790 0 1
88155: ST_TO_ADDR
// if class then
88156: LD_VAR 0 20
88160: IFFALSE 88176
// ComChangeProfession ( i , class ) ;
88162: LD_VAR 0 4
88166: PPUSH
88167: LD_VAR 0 20
88171: PPUSH
88172: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
88176: LD_VAR 0 16
88180: PUSH
88181: LD_VAR 0 2
88185: PPUSH
88186: LD_INT 21
88188: PUSH
88189: LD_INT 2
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: PPUSH
88196: CALL_OW 72
88200: PUSH
88201: LD_INT 1
88203: LESSEQUAL
88204: OR
88205: PUSH
88206: LD_VAR 0 19
88210: AND
88211: PUSH
88212: LD_VAR 0 4
88216: PUSH
88217: LD_VAR 0 17
88221: IN
88222: NOT
88223: AND
88224: IFFALSE 88317
// begin if b then
88226: LD_VAR 0 18
88230: IFFALSE 88279
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
88232: LD_VAR 0 18
88236: PPUSH
88237: LD_VAR 0 21
88241: PPUSH
88242: LD_VAR 0 18
88246: PPUSH
88247: CALL_OW 74
88251: PPUSH
88252: CALL_OW 296
88256: PUSH
88257: LD_INT 10
88259: LESS
88260: PUSH
88261: LD_VAR 0 18
88265: PPUSH
88266: CALL_OW 461
88270: PUSH
88271: LD_INT 7
88273: NONEQUAL
88274: AND
88275: IFFALSE 88279
// continue ;
88277: GO 87514
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
88279: LD_ADDR_VAR 0 17
88283: PUSH
88284: LD_VAR 0 17
88288: PPUSH
88289: LD_VAR 0 17
88293: PUSH
88294: LD_INT 1
88296: PLUS
88297: PPUSH
88298: LD_VAR 0 4
88302: PPUSH
88303: CALL_OW 1
88307: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88308: LD_VAR 0 4
88312: PPUSH
88313: CALL_OW 122
// end ; if sold_defenders then
88317: LD_VAR 0 17
88321: IFFALSE 88381
// if i in sold_defenders then
88323: LD_VAR 0 4
88327: PUSH
88328: LD_VAR 0 17
88332: IN
88333: IFFALSE 88381
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88335: LD_VAR 0 4
88339: PPUSH
88340: CALL_OW 314
88344: NOT
88345: PUSH
88346: LD_VAR 0 4
88350: PPUSH
88351: LD_VAR 0 13
88355: PPUSH
88356: CALL_OW 296
88360: PUSH
88361: LD_INT 30
88363: LESS
88364: AND
88365: IFFALSE 88381
// ComAttackUnit ( i , e ) ;
88367: LD_VAR 0 4
88371: PPUSH
88372: LD_VAR 0 13
88376: PPUSH
88377: CALL_OW 115
// end ; end ; end ;
88381: GO 88384
88383: POP
// if IsDead ( i ) then
88384: LD_VAR 0 4
88388: PPUSH
88389: CALL_OW 301
88393: IFFALSE 88411
// defenders := defenders diff i ;
88395: LD_ADDR_VAR 0 2
88399: PUSH
88400: LD_VAR 0 2
88404: PUSH
88405: LD_VAR 0 4
88409: DIFF
88410: ST_TO_ADDR
// end ;
88411: GO 87514
88413: POP
88414: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88415: LD_VAR 0 21
88419: NOT
88420: PUSH
88421: LD_VAR 0 2
88425: NOT
88426: OR
88427: PUSH
88428: LD_EXP 23
88432: PUSH
88433: LD_VAR 0 1
88437: ARRAY
88438: NOT
88439: OR
88440: IFFALSE 87418
// MC_Reset ( base , 18 ) ;
88442: LD_VAR 0 1
88446: PPUSH
88447: LD_INT 18
88449: PPUSH
88450: CALL 55017 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88454: LD_ADDR_VAR 0 2
88458: PUSH
88459: LD_VAR 0 2
88463: PUSH
88464: LD_VAR 0 2
88468: PPUSH
88469: LD_INT 2
88471: PUSH
88472: LD_INT 25
88474: PUSH
88475: LD_INT 1
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: PUSH
88482: LD_INT 25
88484: PUSH
88485: LD_INT 5
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 25
88494: PUSH
88495: LD_INT 8
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 25
88504: PUSH
88505: LD_INT 9
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: PPUSH
88519: CALL_OW 72
88523: DIFF
88524: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88525: LD_VAR 0 21
88529: NOT
88530: PUSH
88531: LD_VAR 0 2
88535: PPUSH
88536: LD_INT 21
88538: PUSH
88539: LD_INT 2
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PPUSH
88546: CALL_OW 72
88550: AND
88551: IFFALSE 88889
// begin tmp := FilterByTag ( defenders , 19 ) ;
88553: LD_ADDR_VAR 0 11
88557: PUSH
88558: LD_VAR 0 2
88562: PPUSH
88563: LD_INT 19
88565: PPUSH
88566: CALL 45259 0 2
88570: ST_TO_ADDR
// if tmp then
88571: LD_VAR 0 11
88575: IFFALSE 88645
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88577: LD_ADDR_VAR 0 11
88581: PUSH
88582: LD_VAR 0 11
88586: PPUSH
88587: LD_INT 25
88589: PUSH
88590: LD_INT 3
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PPUSH
88597: CALL_OW 72
88601: ST_TO_ADDR
// if tmp then
88602: LD_VAR 0 11
88606: IFFALSE 88645
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88608: LD_ADDR_EXP 35
88612: PUSH
88613: LD_EXP 35
88617: PPUSH
88618: LD_VAR 0 1
88622: PPUSH
88623: LD_EXP 35
88627: PUSH
88628: LD_VAR 0 1
88632: ARRAY
88633: PUSH
88634: LD_VAR 0 11
88638: UNION
88639: PPUSH
88640: CALL_OW 1
88644: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88645: LD_VAR 0 1
88649: PPUSH
88650: LD_INT 19
88652: PPUSH
88653: CALL 55017 0 2
// repeat wait ( 0 0$1 ) ;
88657: LD_INT 35
88659: PPUSH
88660: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88664: LD_EXP 23
88668: PUSH
88669: LD_VAR 0 1
88673: ARRAY
88674: NOT
88675: PUSH
88676: LD_EXP 23
88680: PUSH
88681: LD_VAR 0 1
88685: ARRAY
88686: PUSH
88687: EMPTY
88688: EQUAL
88689: OR
88690: IFFALSE 88727
// begin for i in defenders do
88692: LD_ADDR_VAR 0 4
88696: PUSH
88697: LD_VAR 0 2
88701: PUSH
88702: FOR_IN
88703: IFFALSE 88716
// ComStop ( i ) ;
88705: LD_VAR 0 4
88709: PPUSH
88710: CALL_OW 141
88714: GO 88702
88716: POP
88717: POP
// defenders := [ ] ;
88718: LD_ADDR_VAR 0 2
88722: PUSH
88723: EMPTY
88724: ST_TO_ADDR
// exit ;
88725: GO 88953
// end ; for i in defenders do
88727: LD_ADDR_VAR 0 4
88731: PUSH
88732: LD_VAR 0 2
88736: PUSH
88737: FOR_IN
88738: IFFALSE 88827
// begin if not IsInArea ( i , mc_parking [ base ] ) then
88740: LD_VAR 0 4
88744: PPUSH
88745: LD_EXP 47
88749: PUSH
88750: LD_VAR 0 1
88754: ARRAY
88755: PPUSH
88756: CALL_OW 308
88760: NOT
88761: IFFALSE 88785
// ComMoveToArea ( i , mc_parking [ base ] ) else
88763: LD_VAR 0 4
88767: PPUSH
88768: LD_EXP 47
88772: PUSH
88773: LD_VAR 0 1
88777: ARRAY
88778: PPUSH
88779: CALL_OW 113
88783: GO 88825
// if GetControl ( i ) = control_manual then
88785: LD_VAR 0 4
88789: PPUSH
88790: CALL_OW 263
88794: PUSH
88795: LD_INT 1
88797: EQUAL
88798: IFFALSE 88825
// if IsDrivenBy ( i ) then
88800: LD_VAR 0 4
88804: PPUSH
88805: CALL_OW 311
88809: IFFALSE 88825
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
88811: LD_VAR 0 4
88815: PPUSH
88816: CALL_OW 311
88820: PPUSH
88821: CALL_OW 121
// end ;
88825: GO 88737
88827: POP
88828: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
88829: LD_VAR 0 2
88833: PPUSH
88834: LD_INT 95
88836: PUSH
88837: LD_EXP 47
88841: PUSH
88842: LD_VAR 0 1
88846: ARRAY
88847: PUSH
88848: EMPTY
88849: LIST
88850: LIST
88851: PPUSH
88852: CALL_OW 72
88856: PUSH
88857: LD_VAR 0 2
88861: EQUAL
88862: PUSH
88863: LD_EXP 46
88867: PUSH
88868: LD_VAR 0 1
88872: ARRAY
88873: OR
88874: PUSH
88875: LD_EXP 23
88879: PUSH
88880: LD_VAR 0 1
88884: ARRAY
88885: NOT
88886: OR
88887: IFFALSE 88657
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
88889: LD_ADDR_EXP 45
88893: PUSH
88894: LD_EXP 45
88898: PPUSH
88899: LD_VAR 0 1
88903: PPUSH
88904: LD_VAR 0 2
88908: PPUSH
88909: LD_INT 21
88911: PUSH
88912: LD_INT 2
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: PPUSH
88919: CALL_OW 72
88923: PPUSH
88924: CALL_OW 1
88928: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
88929: LD_VAR 0 1
88933: PPUSH
88934: LD_INT 19
88936: PPUSH
88937: CALL 55017 0 2
// MC_Reset ( base , 20 ) ;
88941: LD_VAR 0 1
88945: PPUSH
88946: LD_INT 20
88948: PPUSH
88949: CALL 55017 0 2
// end ; end_of_file
88953: LD_VAR 0 3
88957: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
88958: LD_INT 0
88960: PPUSH
88961: PPUSH
88962: PPUSH
88963: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
88964: LD_VAR 0 1
88968: PPUSH
88969: CALL_OW 264
88973: PUSH
88974: LD_EXP 71
88978: EQUAL
88979: IFFALSE 89051
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
88981: LD_INT 68
88983: PPUSH
88984: LD_VAR 0 1
88988: PPUSH
88989: CALL_OW 255
88993: PPUSH
88994: CALL_OW 321
88998: PUSH
88999: LD_INT 2
89001: EQUAL
89002: IFFALSE 89014
// eff := 70 else
89004: LD_ADDR_VAR 0 4
89008: PUSH
89009: LD_INT 70
89011: ST_TO_ADDR
89012: GO 89022
// eff := 30 ;
89014: LD_ADDR_VAR 0 4
89018: PUSH
89019: LD_INT 30
89021: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
89022: LD_VAR 0 1
89026: PPUSH
89027: CALL_OW 250
89031: PPUSH
89032: LD_VAR 0 1
89036: PPUSH
89037: CALL_OW 251
89041: PPUSH
89042: LD_VAR 0 4
89046: PPUSH
89047: CALL_OW 495
// end ; end ;
89051: LD_VAR 0 2
89055: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
89056: LD_INT 0
89058: PPUSH
// end ;
89059: LD_VAR 0 4
89063: RET
// export function SOS_Command ( cmd ) ; begin
89064: LD_INT 0
89066: PPUSH
// end ;
89067: LD_VAR 0 2
89071: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
89072: LD_INT 0
89074: PPUSH
// end ;
89075: LD_VAR 0 6
89079: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
89080: LD_INT 0
89082: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
89083: LD_VAR 0 1
89087: PUSH
89088: LD_INT 250
89090: EQUAL
89091: PUSH
89092: LD_VAR 0 2
89096: PPUSH
89097: CALL_OW 264
89101: PUSH
89102: LD_EXP 74
89106: EQUAL
89107: AND
89108: IFFALSE 89129
// MinerPlaceMine ( unit , x , y ) ;
89110: LD_VAR 0 2
89114: PPUSH
89115: LD_VAR 0 4
89119: PPUSH
89120: LD_VAR 0 5
89124: PPUSH
89125: CALL 91478 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
89129: LD_VAR 0 1
89133: PUSH
89134: LD_INT 251
89136: EQUAL
89137: PUSH
89138: LD_VAR 0 2
89142: PPUSH
89143: CALL_OW 264
89147: PUSH
89148: LD_EXP 74
89152: EQUAL
89153: AND
89154: IFFALSE 89175
// MinerDetonateMine ( unit , x , y ) ;
89156: LD_VAR 0 2
89160: PPUSH
89161: LD_VAR 0 4
89165: PPUSH
89166: LD_VAR 0 5
89170: PPUSH
89171: CALL 91755 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
89175: LD_VAR 0 1
89179: PUSH
89180: LD_INT 252
89182: EQUAL
89183: PUSH
89184: LD_VAR 0 2
89188: PPUSH
89189: CALL_OW 264
89193: PUSH
89194: LD_EXP 74
89198: EQUAL
89199: AND
89200: IFFALSE 89221
// MinerCreateMinefield ( unit , x , y ) ;
89202: LD_VAR 0 2
89206: PPUSH
89207: LD_VAR 0 4
89211: PPUSH
89212: LD_VAR 0 5
89216: PPUSH
89217: CALL 92172 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
89221: LD_VAR 0 1
89225: PUSH
89226: LD_INT 253
89228: EQUAL
89229: PUSH
89230: LD_VAR 0 2
89234: PPUSH
89235: CALL_OW 257
89239: PUSH
89240: LD_INT 5
89242: EQUAL
89243: AND
89244: IFFALSE 89265
// ComBinocular ( unit , x , y ) ;
89246: LD_VAR 0 2
89250: PPUSH
89251: LD_VAR 0 4
89255: PPUSH
89256: LD_VAR 0 5
89260: PPUSH
89261: CALL 92543 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
89265: LD_VAR 0 1
89269: PUSH
89270: LD_INT 254
89272: EQUAL
89273: PUSH
89274: LD_VAR 0 2
89278: PPUSH
89279: CALL_OW 264
89283: PUSH
89284: LD_EXP 69
89288: EQUAL
89289: AND
89290: PUSH
89291: LD_VAR 0 3
89295: PPUSH
89296: CALL_OW 263
89300: PUSH
89301: LD_INT 3
89303: EQUAL
89304: AND
89305: IFFALSE 89321
// HackDestroyVehicle ( unit , selectedUnit ) ;
89307: LD_VAR 0 2
89311: PPUSH
89312: LD_VAR 0 3
89316: PPUSH
89317: CALL 90838 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89321: LD_VAR 0 1
89325: PUSH
89326: LD_INT 255
89328: EQUAL
89329: PUSH
89330: LD_VAR 0 2
89334: PPUSH
89335: CALL_OW 264
89339: PUSH
89340: LD_INT 14
89342: PUSH
89343: LD_INT 53
89345: PUSH
89346: EMPTY
89347: LIST
89348: LIST
89349: IN
89350: AND
89351: PUSH
89352: LD_VAR 0 4
89356: PPUSH
89357: LD_VAR 0 5
89361: PPUSH
89362: CALL_OW 488
89366: AND
89367: IFFALSE 89391
// CutTreeXYR ( unit , x , y , 12 ) ;
89369: LD_VAR 0 2
89373: PPUSH
89374: LD_VAR 0 4
89378: PPUSH
89379: LD_VAR 0 5
89383: PPUSH
89384: LD_INT 12
89386: PPUSH
89387: CALL 89404 0 4
// end ;
89391: LD_VAR 0 6
89395: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
89396: LD_INT 0
89398: PPUSH
// end ;
89399: LD_VAR 0 4
89403: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89404: LD_INT 0
89406: PPUSH
89407: PPUSH
89408: PPUSH
89409: PPUSH
89410: PPUSH
89411: PPUSH
89412: PPUSH
89413: PPUSH
89414: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
89415: LD_VAR 0 1
89419: NOT
89420: PUSH
89421: LD_VAR 0 2
89425: PPUSH
89426: LD_VAR 0 3
89430: PPUSH
89431: CALL_OW 488
89435: NOT
89436: OR
89437: PUSH
89438: LD_VAR 0 4
89442: NOT
89443: OR
89444: IFFALSE 89448
// exit ;
89446: GO 89788
// list := [ ] ;
89448: LD_ADDR_VAR 0 13
89452: PUSH
89453: EMPTY
89454: ST_TO_ADDR
// if x - r < 0 then
89455: LD_VAR 0 2
89459: PUSH
89460: LD_VAR 0 4
89464: MINUS
89465: PUSH
89466: LD_INT 0
89468: LESS
89469: IFFALSE 89481
// min_x := 0 else
89471: LD_ADDR_VAR 0 7
89475: PUSH
89476: LD_INT 0
89478: ST_TO_ADDR
89479: GO 89497
// min_x := x - r ;
89481: LD_ADDR_VAR 0 7
89485: PUSH
89486: LD_VAR 0 2
89490: PUSH
89491: LD_VAR 0 4
89495: MINUS
89496: ST_TO_ADDR
// if y - r < 0 then
89497: LD_VAR 0 3
89501: PUSH
89502: LD_VAR 0 4
89506: MINUS
89507: PUSH
89508: LD_INT 0
89510: LESS
89511: IFFALSE 89523
// min_y := 0 else
89513: LD_ADDR_VAR 0 8
89517: PUSH
89518: LD_INT 0
89520: ST_TO_ADDR
89521: GO 89539
// min_y := y - r ;
89523: LD_ADDR_VAR 0 8
89527: PUSH
89528: LD_VAR 0 3
89532: PUSH
89533: LD_VAR 0 4
89537: MINUS
89538: ST_TO_ADDR
// max_x := x + r ;
89539: LD_ADDR_VAR 0 9
89543: PUSH
89544: LD_VAR 0 2
89548: PUSH
89549: LD_VAR 0 4
89553: PLUS
89554: ST_TO_ADDR
// max_y := y + r ;
89555: LD_ADDR_VAR 0 10
89559: PUSH
89560: LD_VAR 0 3
89564: PUSH
89565: LD_VAR 0 4
89569: PLUS
89570: ST_TO_ADDR
// for _x = min_x to max_x do
89571: LD_ADDR_VAR 0 11
89575: PUSH
89576: DOUBLE
89577: LD_VAR 0 7
89581: DEC
89582: ST_TO_ADDR
89583: LD_VAR 0 9
89587: PUSH
89588: FOR_TO
89589: IFFALSE 89706
// for _y = min_y to max_y do
89591: LD_ADDR_VAR 0 12
89595: PUSH
89596: DOUBLE
89597: LD_VAR 0 8
89601: DEC
89602: ST_TO_ADDR
89603: LD_VAR 0 10
89607: PUSH
89608: FOR_TO
89609: IFFALSE 89702
// begin if not ValidHex ( _x , _y ) then
89611: LD_VAR 0 11
89615: PPUSH
89616: LD_VAR 0 12
89620: PPUSH
89621: CALL_OW 488
89625: NOT
89626: IFFALSE 89630
// continue ;
89628: GO 89608
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
89630: LD_VAR 0 11
89634: PPUSH
89635: LD_VAR 0 12
89639: PPUSH
89640: CALL_OW 351
89644: PUSH
89645: LD_VAR 0 11
89649: PPUSH
89650: LD_VAR 0 12
89654: PPUSH
89655: CALL_OW 554
89659: AND
89660: IFFALSE 89700
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
89662: LD_ADDR_VAR 0 13
89666: PUSH
89667: LD_VAR 0 13
89671: PPUSH
89672: LD_VAR 0 13
89676: PUSH
89677: LD_INT 1
89679: PLUS
89680: PPUSH
89681: LD_VAR 0 11
89685: PUSH
89686: LD_VAR 0 12
89690: PUSH
89691: EMPTY
89692: LIST
89693: LIST
89694: PPUSH
89695: CALL_OW 2
89699: ST_TO_ADDR
// end ;
89700: GO 89608
89702: POP
89703: POP
89704: GO 89588
89706: POP
89707: POP
// if not list then
89708: LD_VAR 0 13
89712: NOT
89713: IFFALSE 89717
// exit ;
89715: GO 89788
// for i in list do
89717: LD_ADDR_VAR 0 6
89721: PUSH
89722: LD_VAR 0 13
89726: PUSH
89727: FOR_IN
89728: IFFALSE 89786
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
89730: LD_VAR 0 1
89734: PPUSH
89735: LD_STRING M
89737: PUSH
89738: LD_VAR 0 6
89742: PUSH
89743: LD_INT 1
89745: ARRAY
89746: PUSH
89747: LD_VAR 0 6
89751: PUSH
89752: LD_INT 2
89754: ARRAY
89755: PUSH
89756: LD_INT 0
89758: PUSH
89759: LD_INT 0
89761: PUSH
89762: LD_INT 0
89764: PUSH
89765: LD_INT 0
89767: PUSH
89768: EMPTY
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: PUSH
89777: EMPTY
89778: LIST
89779: PPUSH
89780: CALL_OW 447
89784: GO 89727
89786: POP
89787: POP
// end ;
89788: LD_VAR 0 5
89792: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
89793: LD_EXP 88
89797: NOT
89798: IFFALSE 89848
89800: GO 89802
89802: DISABLE
// begin initHack := true ;
89803: LD_ADDR_EXP 88
89807: PUSH
89808: LD_INT 1
89810: ST_TO_ADDR
// hackTanks := [ ] ;
89811: LD_ADDR_EXP 89
89815: PUSH
89816: EMPTY
89817: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
89818: LD_ADDR_EXP 90
89822: PUSH
89823: EMPTY
89824: ST_TO_ADDR
// hackLimit := 3 ;
89825: LD_ADDR_EXP 91
89829: PUSH
89830: LD_INT 3
89832: ST_TO_ADDR
// hackDist := 12 ;
89833: LD_ADDR_EXP 92
89837: PUSH
89838: LD_INT 12
89840: ST_TO_ADDR
// hackCounter := [ ] ;
89841: LD_ADDR_EXP 93
89845: PUSH
89846: EMPTY
89847: ST_TO_ADDR
// end ;
89848: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
89849: LD_EXP 88
89853: PUSH
89854: LD_INT 34
89856: PUSH
89857: LD_EXP 69
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PPUSH
89866: CALL_OW 69
89870: AND
89871: IFFALSE 90126
89873: GO 89875
89875: DISABLE
89876: LD_INT 0
89878: PPUSH
89879: PPUSH
// begin enable ;
89880: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
89881: LD_ADDR_VAR 0 1
89885: PUSH
89886: LD_INT 34
89888: PUSH
89889: LD_EXP 69
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PPUSH
89898: CALL_OW 69
89902: PUSH
89903: FOR_IN
89904: IFFALSE 90124
// begin if not i in hackTanks then
89906: LD_VAR 0 1
89910: PUSH
89911: LD_EXP 89
89915: IN
89916: NOT
89917: IFFALSE 90000
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
89919: LD_ADDR_EXP 89
89923: PUSH
89924: LD_EXP 89
89928: PPUSH
89929: LD_EXP 89
89933: PUSH
89934: LD_INT 1
89936: PLUS
89937: PPUSH
89938: LD_VAR 0 1
89942: PPUSH
89943: CALL_OW 1
89947: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
89948: LD_ADDR_EXP 90
89952: PUSH
89953: LD_EXP 90
89957: PPUSH
89958: LD_EXP 90
89962: PUSH
89963: LD_INT 1
89965: PLUS
89966: PPUSH
89967: EMPTY
89968: PPUSH
89969: CALL_OW 1
89973: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
89974: LD_ADDR_EXP 93
89978: PUSH
89979: LD_EXP 93
89983: PPUSH
89984: LD_EXP 93
89988: PUSH
89989: LD_INT 1
89991: PLUS
89992: PPUSH
89993: EMPTY
89994: PPUSH
89995: CALL_OW 1
89999: ST_TO_ADDR
// end ; if not IsOk ( i ) then
90000: LD_VAR 0 1
90004: PPUSH
90005: CALL_OW 302
90009: NOT
90010: IFFALSE 90023
// begin HackUnlinkAll ( i ) ;
90012: LD_VAR 0 1
90016: PPUSH
90017: CALL 90129 0 1
// continue ;
90021: GO 89903
// end ; HackCheckCapturedStatus ( i ) ;
90023: LD_VAR 0 1
90027: PPUSH
90028: CALL 90572 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
90032: LD_ADDR_VAR 0 2
90036: PUSH
90037: LD_INT 81
90039: PUSH
90040: LD_VAR 0 1
90044: PPUSH
90045: CALL_OW 255
90049: PUSH
90050: EMPTY
90051: LIST
90052: LIST
90053: PUSH
90054: LD_INT 33
90056: PUSH
90057: LD_INT 3
90059: PUSH
90060: EMPTY
90061: LIST
90062: LIST
90063: PUSH
90064: LD_INT 91
90066: PUSH
90067: LD_VAR 0 1
90071: PUSH
90072: LD_EXP 92
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 50
90084: PUSH
90085: EMPTY
90086: LIST
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: PPUSH
90094: CALL_OW 69
90098: ST_TO_ADDR
// if not tmp then
90099: LD_VAR 0 2
90103: NOT
90104: IFFALSE 90108
// continue ;
90106: GO 89903
// HackLink ( i , tmp ) ;
90108: LD_VAR 0 1
90112: PPUSH
90113: LD_VAR 0 2
90117: PPUSH
90118: CALL 90265 0 2
// end ;
90122: GO 89903
90124: POP
90125: POP
// end ;
90126: PPOPN 2
90128: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
90129: LD_INT 0
90131: PPUSH
90132: PPUSH
90133: PPUSH
// if not hack in hackTanks then
90134: LD_VAR 0 1
90138: PUSH
90139: LD_EXP 89
90143: IN
90144: NOT
90145: IFFALSE 90149
// exit ;
90147: GO 90260
// index := GetElementIndex ( hackTanks , hack ) ;
90149: LD_ADDR_VAR 0 4
90153: PUSH
90154: LD_EXP 89
90158: PPUSH
90159: LD_VAR 0 1
90163: PPUSH
90164: CALL 15775 0 2
90168: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
90169: LD_EXP 90
90173: PUSH
90174: LD_VAR 0 4
90178: ARRAY
90179: IFFALSE 90260
// begin for i in hackTanksCaptured [ index ] do
90181: LD_ADDR_VAR 0 3
90185: PUSH
90186: LD_EXP 90
90190: PUSH
90191: LD_VAR 0 4
90195: ARRAY
90196: PUSH
90197: FOR_IN
90198: IFFALSE 90224
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
90200: LD_VAR 0 3
90204: PUSH
90205: LD_INT 1
90207: ARRAY
90208: PPUSH
90209: LD_VAR 0 3
90213: PUSH
90214: LD_INT 2
90216: ARRAY
90217: PPUSH
90218: CALL_OW 235
90222: GO 90197
90224: POP
90225: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
90226: LD_ADDR_EXP 90
90230: PUSH
90231: LD_EXP 90
90235: PPUSH
90236: LD_VAR 0 4
90240: PPUSH
90241: EMPTY
90242: PPUSH
90243: CALL_OW 1
90247: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
90248: LD_VAR 0 1
90252: PPUSH
90253: LD_INT 0
90255: PPUSH
90256: CALL_OW 505
// end ; end ;
90260: LD_VAR 0 2
90264: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
90265: LD_INT 0
90267: PPUSH
90268: PPUSH
90269: PPUSH
// if not hack in hackTanks or not vehicles then
90270: LD_VAR 0 1
90274: PUSH
90275: LD_EXP 89
90279: IN
90280: NOT
90281: PUSH
90282: LD_VAR 0 2
90286: NOT
90287: OR
90288: IFFALSE 90292
// exit ;
90290: GO 90567
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
90292: LD_ADDR_VAR 0 2
90296: PUSH
90297: LD_VAR 0 1
90301: PPUSH
90302: LD_VAR 0 2
90306: PPUSH
90307: LD_INT 1
90309: PPUSH
90310: LD_INT 1
90312: PPUSH
90313: CALL 16425 0 4
90317: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90318: LD_ADDR_VAR 0 5
90322: PUSH
90323: LD_EXP 89
90327: PPUSH
90328: LD_VAR 0 1
90332: PPUSH
90333: CALL 15775 0 2
90337: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90338: LD_EXP 90
90342: PUSH
90343: LD_VAR 0 5
90347: ARRAY
90348: PUSH
90349: LD_EXP 91
90353: LESS
90354: IFFALSE 90543
// begin for i := 1 to vehicles do
90356: LD_ADDR_VAR 0 4
90360: PUSH
90361: DOUBLE
90362: LD_INT 1
90364: DEC
90365: ST_TO_ADDR
90366: LD_VAR 0 2
90370: PUSH
90371: FOR_TO
90372: IFFALSE 90541
// begin if hackTanksCaptured [ index ] = hackLimit then
90374: LD_EXP 90
90378: PUSH
90379: LD_VAR 0 5
90383: ARRAY
90384: PUSH
90385: LD_EXP 91
90389: EQUAL
90390: IFFALSE 90394
// break ;
90392: GO 90541
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90394: LD_ADDR_EXP 93
90398: PUSH
90399: LD_EXP 93
90403: PPUSH
90404: LD_VAR 0 5
90408: PPUSH
90409: LD_EXP 93
90413: PUSH
90414: LD_VAR 0 5
90418: ARRAY
90419: PUSH
90420: LD_INT 1
90422: PLUS
90423: PPUSH
90424: CALL_OW 1
90428: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
90429: LD_ADDR_EXP 90
90433: PUSH
90434: LD_EXP 90
90438: PPUSH
90439: LD_VAR 0 5
90443: PUSH
90444: LD_EXP 90
90448: PUSH
90449: LD_VAR 0 5
90453: ARRAY
90454: PUSH
90455: LD_INT 1
90457: PLUS
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PPUSH
90463: LD_VAR 0 2
90467: PUSH
90468: LD_VAR 0 4
90472: ARRAY
90473: PUSH
90474: LD_VAR 0 2
90478: PUSH
90479: LD_VAR 0 4
90483: ARRAY
90484: PPUSH
90485: CALL_OW 255
90489: PUSH
90490: EMPTY
90491: LIST
90492: LIST
90493: PPUSH
90494: CALL 15990 0 3
90498: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
90499: LD_VAR 0 2
90503: PUSH
90504: LD_VAR 0 4
90508: ARRAY
90509: PPUSH
90510: LD_VAR 0 1
90514: PPUSH
90515: CALL_OW 255
90519: PPUSH
90520: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
90524: LD_VAR 0 2
90528: PUSH
90529: LD_VAR 0 4
90533: ARRAY
90534: PPUSH
90535: CALL_OW 141
// end ;
90539: GO 90371
90541: POP
90542: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
90543: LD_VAR 0 1
90547: PPUSH
90548: LD_EXP 90
90552: PUSH
90553: LD_VAR 0 5
90557: ARRAY
90558: PUSH
90559: LD_INT 0
90561: PLUS
90562: PPUSH
90563: CALL_OW 505
// end ;
90567: LD_VAR 0 3
90571: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
90572: LD_INT 0
90574: PPUSH
90575: PPUSH
90576: PPUSH
90577: PPUSH
// if not hack in hackTanks then
90578: LD_VAR 0 1
90582: PUSH
90583: LD_EXP 89
90587: IN
90588: NOT
90589: IFFALSE 90593
// exit ;
90591: GO 90833
// index := GetElementIndex ( hackTanks , hack ) ;
90593: LD_ADDR_VAR 0 4
90597: PUSH
90598: LD_EXP 89
90602: PPUSH
90603: LD_VAR 0 1
90607: PPUSH
90608: CALL 15775 0 2
90612: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
90613: LD_ADDR_VAR 0 3
90617: PUSH
90618: DOUBLE
90619: LD_EXP 90
90623: PUSH
90624: LD_VAR 0 4
90628: ARRAY
90629: INC
90630: ST_TO_ADDR
90631: LD_INT 1
90633: PUSH
90634: FOR_DOWNTO
90635: IFFALSE 90807
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
90637: LD_ADDR_VAR 0 5
90641: PUSH
90642: LD_EXP 90
90646: PUSH
90647: LD_VAR 0 4
90651: ARRAY
90652: PUSH
90653: LD_VAR 0 3
90657: ARRAY
90658: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
90659: LD_VAR 0 5
90663: PUSH
90664: LD_INT 1
90666: ARRAY
90667: PPUSH
90668: CALL_OW 302
90672: NOT
90673: PUSH
90674: LD_VAR 0 5
90678: PUSH
90679: LD_INT 1
90681: ARRAY
90682: PPUSH
90683: CALL_OW 255
90687: PUSH
90688: LD_VAR 0 1
90692: PPUSH
90693: CALL_OW 255
90697: NONEQUAL
90698: OR
90699: IFFALSE 90805
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
90701: LD_VAR 0 5
90705: PUSH
90706: LD_INT 1
90708: ARRAY
90709: PPUSH
90710: CALL_OW 305
90714: PUSH
90715: LD_VAR 0 5
90719: PUSH
90720: LD_INT 1
90722: ARRAY
90723: PPUSH
90724: CALL_OW 255
90728: PUSH
90729: LD_VAR 0 1
90733: PPUSH
90734: CALL_OW 255
90738: EQUAL
90739: AND
90740: IFFALSE 90764
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
90742: LD_VAR 0 5
90746: PUSH
90747: LD_INT 1
90749: ARRAY
90750: PPUSH
90751: LD_VAR 0 5
90755: PUSH
90756: LD_INT 2
90758: ARRAY
90759: PPUSH
90760: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
90764: LD_ADDR_EXP 90
90768: PUSH
90769: LD_EXP 90
90773: PPUSH
90774: LD_VAR 0 4
90778: PPUSH
90779: LD_EXP 90
90783: PUSH
90784: LD_VAR 0 4
90788: ARRAY
90789: PPUSH
90790: LD_VAR 0 3
90794: PPUSH
90795: CALL_OW 3
90799: PPUSH
90800: CALL_OW 1
90804: ST_TO_ADDR
// end ; end ;
90805: GO 90634
90807: POP
90808: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
90809: LD_VAR 0 1
90813: PPUSH
90814: LD_EXP 90
90818: PUSH
90819: LD_VAR 0 4
90823: ARRAY
90824: PUSH
90825: LD_INT 0
90827: PLUS
90828: PPUSH
90829: CALL_OW 505
// end ;
90833: LD_VAR 0 2
90837: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
90838: LD_INT 0
90840: PPUSH
90841: PPUSH
90842: PPUSH
90843: PPUSH
// if not hack in hackTanks then
90844: LD_VAR 0 1
90848: PUSH
90849: LD_EXP 89
90853: IN
90854: NOT
90855: IFFALSE 90859
// exit ;
90857: GO 90944
// index := GetElementIndex ( hackTanks , hack ) ;
90859: LD_ADDR_VAR 0 5
90863: PUSH
90864: LD_EXP 89
90868: PPUSH
90869: LD_VAR 0 1
90873: PPUSH
90874: CALL 15775 0 2
90878: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
90879: LD_ADDR_VAR 0 4
90883: PUSH
90884: DOUBLE
90885: LD_INT 1
90887: DEC
90888: ST_TO_ADDR
90889: LD_EXP 90
90893: PUSH
90894: LD_VAR 0 5
90898: ARRAY
90899: PUSH
90900: FOR_TO
90901: IFFALSE 90942
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
90903: LD_EXP 90
90907: PUSH
90908: LD_VAR 0 5
90912: ARRAY
90913: PUSH
90914: LD_VAR 0 4
90918: ARRAY
90919: PUSH
90920: LD_INT 1
90922: ARRAY
90923: PUSH
90924: LD_VAR 0 2
90928: EQUAL
90929: IFFALSE 90940
// KillUnit ( vehicle ) ;
90931: LD_VAR 0 2
90935: PPUSH
90936: CALL_OW 66
90940: GO 90900
90942: POP
90943: POP
// end ;
90944: LD_VAR 0 3
90948: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
90949: LD_EXP 94
90953: NOT
90954: IFFALSE 90989
90956: GO 90958
90958: DISABLE
// begin initMiner := true ;
90959: LD_ADDR_EXP 94
90963: PUSH
90964: LD_INT 1
90966: ST_TO_ADDR
// minersList := [ ] ;
90967: LD_ADDR_EXP 95
90971: PUSH
90972: EMPTY
90973: ST_TO_ADDR
// minerMinesList := [ ] ;
90974: LD_ADDR_EXP 96
90978: PUSH
90979: EMPTY
90980: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
90981: LD_ADDR_EXP 97
90985: PUSH
90986: LD_INT 5
90988: ST_TO_ADDR
// end ;
90989: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
90990: LD_EXP 94
90994: PUSH
90995: LD_INT 34
90997: PUSH
90998: LD_EXP 74
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: PPUSH
91007: CALL_OW 69
91011: AND
91012: IFFALSE 91475
91014: GO 91016
91016: DISABLE
91017: LD_INT 0
91019: PPUSH
91020: PPUSH
91021: PPUSH
91022: PPUSH
// begin enable ;
91023: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
91024: LD_ADDR_VAR 0 1
91028: PUSH
91029: LD_INT 34
91031: PUSH
91032: LD_EXP 74
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PPUSH
91041: CALL_OW 69
91045: PUSH
91046: FOR_IN
91047: IFFALSE 91119
// begin if not i in minersList then
91049: LD_VAR 0 1
91053: PUSH
91054: LD_EXP 95
91058: IN
91059: NOT
91060: IFFALSE 91117
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
91062: LD_ADDR_EXP 95
91066: PUSH
91067: LD_EXP 95
91071: PPUSH
91072: LD_EXP 95
91076: PUSH
91077: LD_INT 1
91079: PLUS
91080: PPUSH
91081: LD_VAR 0 1
91085: PPUSH
91086: CALL_OW 1
91090: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
91091: LD_ADDR_EXP 96
91095: PUSH
91096: LD_EXP 96
91100: PPUSH
91101: LD_EXP 96
91105: PUSH
91106: LD_INT 1
91108: PLUS
91109: PPUSH
91110: EMPTY
91111: PPUSH
91112: CALL_OW 1
91116: ST_TO_ADDR
// end end ;
91117: GO 91046
91119: POP
91120: POP
// for i := minerMinesList downto 1 do
91121: LD_ADDR_VAR 0 1
91125: PUSH
91126: DOUBLE
91127: LD_EXP 96
91131: INC
91132: ST_TO_ADDR
91133: LD_INT 1
91135: PUSH
91136: FOR_DOWNTO
91137: IFFALSE 91473
// begin if IsLive ( minersList [ i ] ) then
91139: LD_EXP 95
91143: PUSH
91144: LD_VAR 0 1
91148: ARRAY
91149: PPUSH
91150: CALL_OW 300
91154: IFFALSE 91182
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
91156: LD_EXP 95
91160: PUSH
91161: LD_VAR 0 1
91165: ARRAY
91166: PPUSH
91167: LD_EXP 96
91171: PUSH
91172: LD_VAR 0 1
91176: ARRAY
91177: PPUSH
91178: CALL_OW 505
// if not minerMinesList [ i ] then
91182: LD_EXP 96
91186: PUSH
91187: LD_VAR 0 1
91191: ARRAY
91192: NOT
91193: IFFALSE 91197
// continue ;
91195: GO 91136
// for j := minerMinesList [ i ] downto 1 do
91197: LD_ADDR_VAR 0 2
91201: PUSH
91202: DOUBLE
91203: LD_EXP 96
91207: PUSH
91208: LD_VAR 0 1
91212: ARRAY
91213: INC
91214: ST_TO_ADDR
91215: LD_INT 1
91217: PUSH
91218: FOR_DOWNTO
91219: IFFALSE 91469
// begin side := GetSide ( minersList [ i ] ) ;
91221: LD_ADDR_VAR 0 3
91225: PUSH
91226: LD_EXP 95
91230: PUSH
91231: LD_VAR 0 1
91235: ARRAY
91236: PPUSH
91237: CALL_OW 255
91241: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
91242: LD_ADDR_VAR 0 4
91246: PUSH
91247: LD_EXP 96
91251: PUSH
91252: LD_VAR 0 1
91256: ARRAY
91257: PUSH
91258: LD_VAR 0 2
91262: ARRAY
91263: PUSH
91264: LD_INT 1
91266: ARRAY
91267: PPUSH
91268: LD_EXP 96
91272: PUSH
91273: LD_VAR 0 1
91277: ARRAY
91278: PUSH
91279: LD_VAR 0 2
91283: ARRAY
91284: PUSH
91285: LD_INT 2
91287: ARRAY
91288: PPUSH
91289: CALL_OW 428
91293: ST_TO_ADDR
// if not tmp then
91294: LD_VAR 0 4
91298: NOT
91299: IFFALSE 91303
// continue ;
91301: GO 91218
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
91303: LD_VAR 0 4
91307: PUSH
91308: LD_INT 81
91310: PUSH
91311: LD_VAR 0 3
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: PPUSH
91320: CALL_OW 69
91324: IN
91325: PUSH
91326: LD_EXP 96
91330: PUSH
91331: LD_VAR 0 1
91335: ARRAY
91336: PUSH
91337: LD_VAR 0 2
91341: ARRAY
91342: PUSH
91343: LD_INT 1
91345: ARRAY
91346: PPUSH
91347: LD_EXP 96
91351: PUSH
91352: LD_VAR 0 1
91356: ARRAY
91357: PUSH
91358: LD_VAR 0 2
91362: ARRAY
91363: PUSH
91364: LD_INT 2
91366: ARRAY
91367: PPUSH
91368: CALL_OW 458
91372: AND
91373: IFFALSE 91467
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91375: LD_EXP 96
91379: PUSH
91380: LD_VAR 0 1
91384: ARRAY
91385: PUSH
91386: LD_VAR 0 2
91390: ARRAY
91391: PUSH
91392: LD_INT 1
91394: ARRAY
91395: PPUSH
91396: LD_EXP 96
91400: PUSH
91401: LD_VAR 0 1
91405: ARRAY
91406: PUSH
91407: LD_VAR 0 2
91411: ARRAY
91412: PUSH
91413: LD_INT 2
91415: ARRAY
91416: PPUSH
91417: LD_VAR 0 3
91421: PPUSH
91422: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
91426: LD_ADDR_EXP 96
91430: PUSH
91431: LD_EXP 96
91435: PPUSH
91436: LD_VAR 0 1
91440: PPUSH
91441: LD_EXP 96
91445: PUSH
91446: LD_VAR 0 1
91450: ARRAY
91451: PPUSH
91452: LD_VAR 0 2
91456: PPUSH
91457: CALL_OW 3
91461: PPUSH
91462: CALL_OW 1
91466: ST_TO_ADDR
// end ; end ;
91467: GO 91218
91469: POP
91470: POP
// end ;
91471: GO 91136
91473: POP
91474: POP
// end ;
91475: PPOPN 4
91477: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
91478: LD_INT 0
91480: PPUSH
91481: PPUSH
// result := false ;
91482: LD_ADDR_VAR 0 4
91486: PUSH
91487: LD_INT 0
91489: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
91490: LD_VAR 0 1
91494: PPUSH
91495: CALL_OW 264
91499: PUSH
91500: LD_EXP 74
91504: EQUAL
91505: NOT
91506: IFFALSE 91510
// exit ;
91508: GO 91750
// index := GetElementIndex ( minersList , unit ) ;
91510: LD_ADDR_VAR 0 5
91514: PUSH
91515: LD_EXP 95
91519: PPUSH
91520: LD_VAR 0 1
91524: PPUSH
91525: CALL 15775 0 2
91529: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
91530: LD_EXP 96
91534: PUSH
91535: LD_VAR 0 5
91539: ARRAY
91540: PUSH
91541: LD_EXP 97
91545: GREATEREQUAL
91546: IFFALSE 91550
// exit ;
91548: GO 91750
// ComMoveXY ( unit , x , y ) ;
91550: LD_VAR 0 1
91554: PPUSH
91555: LD_VAR 0 2
91559: PPUSH
91560: LD_VAR 0 3
91564: PPUSH
91565: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
91569: LD_INT 35
91571: PPUSH
91572: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
91576: LD_VAR 0 1
91580: PPUSH
91581: LD_VAR 0 2
91585: PPUSH
91586: LD_VAR 0 3
91590: PPUSH
91591: CALL 46547 0 3
91595: NOT
91596: PUSH
91597: LD_VAR 0 1
91601: PPUSH
91602: CALL_OW 314
91606: AND
91607: IFFALSE 91611
// exit ;
91609: GO 91750
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
91611: LD_VAR 0 2
91615: PPUSH
91616: LD_VAR 0 3
91620: PPUSH
91621: CALL_OW 428
91625: PUSH
91626: LD_VAR 0 1
91630: EQUAL
91631: PUSH
91632: LD_VAR 0 1
91636: PPUSH
91637: CALL_OW 314
91641: NOT
91642: AND
91643: IFFALSE 91569
// PlaySoundXY ( x , y , PlantMine ) ;
91645: LD_VAR 0 2
91649: PPUSH
91650: LD_VAR 0 3
91654: PPUSH
91655: LD_STRING PlantMine
91657: PPUSH
91658: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
91662: LD_VAR 0 2
91666: PPUSH
91667: LD_VAR 0 3
91671: PPUSH
91672: LD_VAR 0 1
91676: PPUSH
91677: CALL_OW 255
91681: PPUSH
91682: LD_INT 0
91684: PPUSH
91685: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
91689: LD_ADDR_EXP 96
91693: PUSH
91694: LD_EXP 96
91698: PPUSH
91699: LD_VAR 0 5
91703: PUSH
91704: LD_EXP 96
91708: PUSH
91709: LD_VAR 0 5
91713: ARRAY
91714: PUSH
91715: LD_INT 1
91717: PLUS
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: PPUSH
91723: LD_VAR 0 2
91727: PUSH
91728: LD_VAR 0 3
91732: PUSH
91733: EMPTY
91734: LIST
91735: LIST
91736: PPUSH
91737: CALL 15990 0 3
91741: ST_TO_ADDR
// result := true ;
91742: LD_ADDR_VAR 0 4
91746: PUSH
91747: LD_INT 1
91749: ST_TO_ADDR
// end ;
91750: LD_VAR 0 4
91754: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
91755: LD_INT 0
91757: PPUSH
91758: PPUSH
91759: PPUSH
// if not unit in minersList then
91760: LD_VAR 0 1
91764: PUSH
91765: LD_EXP 95
91769: IN
91770: NOT
91771: IFFALSE 91775
// exit ;
91773: GO 92167
// index := GetElementIndex ( minersList , unit ) ;
91775: LD_ADDR_VAR 0 6
91779: PUSH
91780: LD_EXP 95
91784: PPUSH
91785: LD_VAR 0 1
91789: PPUSH
91790: CALL 15775 0 2
91794: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
91795: LD_ADDR_VAR 0 5
91799: PUSH
91800: DOUBLE
91801: LD_EXP 96
91805: PUSH
91806: LD_VAR 0 6
91810: ARRAY
91811: INC
91812: ST_TO_ADDR
91813: LD_INT 1
91815: PUSH
91816: FOR_DOWNTO
91817: IFFALSE 91978
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
91819: LD_EXP 96
91823: PUSH
91824: LD_VAR 0 6
91828: ARRAY
91829: PUSH
91830: LD_VAR 0 5
91834: ARRAY
91835: PUSH
91836: LD_INT 1
91838: ARRAY
91839: PUSH
91840: LD_VAR 0 2
91844: EQUAL
91845: PUSH
91846: LD_EXP 96
91850: PUSH
91851: LD_VAR 0 6
91855: ARRAY
91856: PUSH
91857: LD_VAR 0 5
91861: ARRAY
91862: PUSH
91863: LD_INT 2
91865: ARRAY
91866: PUSH
91867: LD_VAR 0 3
91871: EQUAL
91872: AND
91873: IFFALSE 91976
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
91875: LD_EXP 96
91879: PUSH
91880: LD_VAR 0 6
91884: ARRAY
91885: PUSH
91886: LD_VAR 0 5
91890: ARRAY
91891: PUSH
91892: LD_INT 1
91894: ARRAY
91895: PPUSH
91896: LD_EXP 96
91900: PUSH
91901: LD_VAR 0 6
91905: ARRAY
91906: PUSH
91907: LD_VAR 0 5
91911: ARRAY
91912: PUSH
91913: LD_INT 2
91915: ARRAY
91916: PPUSH
91917: LD_VAR 0 1
91921: PPUSH
91922: CALL_OW 255
91926: PPUSH
91927: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
91931: LD_ADDR_EXP 96
91935: PUSH
91936: LD_EXP 96
91940: PPUSH
91941: LD_VAR 0 6
91945: PPUSH
91946: LD_EXP 96
91950: PUSH
91951: LD_VAR 0 6
91955: ARRAY
91956: PPUSH
91957: LD_VAR 0 5
91961: PPUSH
91962: CALL_OW 3
91966: PPUSH
91967: CALL_OW 1
91971: ST_TO_ADDR
// exit ;
91972: POP
91973: POP
91974: GO 92167
// end ; end ;
91976: GO 91816
91978: POP
91979: POP
// for i := minerMinesList [ index ] downto 1 do
91980: LD_ADDR_VAR 0 5
91984: PUSH
91985: DOUBLE
91986: LD_EXP 96
91990: PUSH
91991: LD_VAR 0 6
91995: ARRAY
91996: INC
91997: ST_TO_ADDR
91998: LD_INT 1
92000: PUSH
92001: FOR_DOWNTO
92002: IFFALSE 92165
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
92004: LD_EXP 96
92008: PUSH
92009: LD_VAR 0 6
92013: ARRAY
92014: PUSH
92015: LD_VAR 0 5
92019: ARRAY
92020: PUSH
92021: LD_INT 1
92023: ARRAY
92024: PPUSH
92025: LD_EXP 96
92029: PUSH
92030: LD_VAR 0 6
92034: ARRAY
92035: PUSH
92036: LD_VAR 0 5
92040: ARRAY
92041: PUSH
92042: LD_INT 2
92044: ARRAY
92045: PPUSH
92046: LD_VAR 0 2
92050: PPUSH
92051: LD_VAR 0 3
92055: PPUSH
92056: CALL_OW 298
92060: PUSH
92061: LD_INT 6
92063: LESS
92064: IFFALSE 92163
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
92066: LD_EXP 96
92070: PUSH
92071: LD_VAR 0 6
92075: ARRAY
92076: PUSH
92077: LD_VAR 0 5
92081: ARRAY
92082: PUSH
92083: LD_INT 1
92085: ARRAY
92086: PPUSH
92087: LD_EXP 96
92091: PUSH
92092: LD_VAR 0 6
92096: ARRAY
92097: PUSH
92098: LD_VAR 0 5
92102: ARRAY
92103: PUSH
92104: LD_INT 2
92106: ARRAY
92107: PPUSH
92108: LD_VAR 0 1
92112: PPUSH
92113: CALL_OW 255
92117: PPUSH
92118: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
92122: LD_ADDR_EXP 96
92126: PUSH
92127: LD_EXP 96
92131: PPUSH
92132: LD_VAR 0 6
92136: PPUSH
92137: LD_EXP 96
92141: PUSH
92142: LD_VAR 0 6
92146: ARRAY
92147: PPUSH
92148: LD_VAR 0 5
92152: PPUSH
92153: CALL_OW 3
92157: PPUSH
92158: CALL_OW 1
92162: ST_TO_ADDR
// end ; end ;
92163: GO 92001
92165: POP
92166: POP
// end ;
92167: LD_VAR 0 4
92171: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
92172: LD_INT 0
92174: PPUSH
92175: PPUSH
92176: PPUSH
92177: PPUSH
92178: PPUSH
92179: PPUSH
92180: PPUSH
92181: PPUSH
92182: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
92183: LD_VAR 0 1
92187: PPUSH
92188: CALL_OW 264
92192: PUSH
92193: LD_EXP 74
92197: EQUAL
92198: NOT
92199: PUSH
92200: LD_VAR 0 1
92204: PUSH
92205: LD_EXP 95
92209: IN
92210: NOT
92211: OR
92212: IFFALSE 92216
// exit ;
92214: GO 92538
// index := GetElementIndex ( minersList , unit ) ;
92216: LD_ADDR_VAR 0 6
92220: PUSH
92221: LD_EXP 95
92225: PPUSH
92226: LD_VAR 0 1
92230: PPUSH
92231: CALL 15775 0 2
92235: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
92236: LD_ADDR_VAR 0 8
92240: PUSH
92241: LD_EXP 97
92245: PUSH
92246: LD_EXP 96
92250: PUSH
92251: LD_VAR 0 6
92255: ARRAY
92256: MINUS
92257: ST_TO_ADDR
// if not minesFreeAmount then
92258: LD_VAR 0 8
92262: NOT
92263: IFFALSE 92267
// exit ;
92265: GO 92538
// tmp := [ ] ;
92267: LD_ADDR_VAR 0 7
92271: PUSH
92272: EMPTY
92273: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
92274: LD_ADDR_VAR 0 5
92278: PUSH
92279: DOUBLE
92280: LD_INT 1
92282: DEC
92283: ST_TO_ADDR
92284: LD_VAR 0 8
92288: PUSH
92289: FOR_TO
92290: IFFALSE 92485
// begin _d := rand ( 0 , 5 ) ;
92292: LD_ADDR_VAR 0 11
92296: PUSH
92297: LD_INT 0
92299: PPUSH
92300: LD_INT 5
92302: PPUSH
92303: CALL_OW 12
92307: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92308: LD_ADDR_VAR 0 12
92312: PUSH
92313: LD_INT 2
92315: PPUSH
92316: LD_INT 6
92318: PPUSH
92319: CALL_OW 12
92323: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92324: LD_ADDR_VAR 0 9
92328: PUSH
92329: LD_VAR 0 2
92333: PPUSH
92334: LD_VAR 0 11
92338: PPUSH
92339: LD_VAR 0 12
92343: PPUSH
92344: CALL_OW 272
92348: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92349: LD_ADDR_VAR 0 10
92353: PUSH
92354: LD_VAR 0 3
92358: PPUSH
92359: LD_VAR 0 11
92363: PPUSH
92364: LD_VAR 0 12
92368: PPUSH
92369: CALL_OW 273
92373: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92374: LD_VAR 0 9
92378: PPUSH
92379: LD_VAR 0 10
92383: PPUSH
92384: CALL_OW 488
92388: PUSH
92389: LD_VAR 0 9
92393: PUSH
92394: LD_VAR 0 10
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_VAR 0 7
92407: IN
92408: NOT
92409: AND
92410: PUSH
92411: LD_VAR 0 9
92415: PPUSH
92416: LD_VAR 0 10
92420: PPUSH
92421: CALL_OW 458
92425: NOT
92426: AND
92427: IFFALSE 92469
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
92429: LD_ADDR_VAR 0 7
92433: PUSH
92434: LD_VAR 0 7
92438: PPUSH
92439: LD_VAR 0 7
92443: PUSH
92444: LD_INT 1
92446: PLUS
92447: PPUSH
92448: LD_VAR 0 9
92452: PUSH
92453: LD_VAR 0 10
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PPUSH
92462: CALL_OW 1
92466: ST_TO_ADDR
92467: GO 92483
// i := i - 1 ;
92469: LD_ADDR_VAR 0 5
92473: PUSH
92474: LD_VAR 0 5
92478: PUSH
92479: LD_INT 1
92481: MINUS
92482: ST_TO_ADDR
// end ;
92483: GO 92289
92485: POP
92486: POP
// for i in tmp do
92487: LD_ADDR_VAR 0 5
92491: PUSH
92492: LD_VAR 0 7
92496: PUSH
92497: FOR_IN
92498: IFFALSE 92536
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
92500: LD_VAR 0 1
92504: PPUSH
92505: LD_VAR 0 5
92509: PUSH
92510: LD_INT 1
92512: ARRAY
92513: PPUSH
92514: LD_VAR 0 5
92518: PUSH
92519: LD_INT 2
92521: ARRAY
92522: PPUSH
92523: CALL 91478 0 3
92527: NOT
92528: IFFALSE 92534
// exit ;
92530: POP
92531: POP
92532: GO 92538
92534: GO 92497
92536: POP
92537: POP
// end ;
92538: LD_VAR 0 4
92542: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
92543: LD_INT 0
92545: PPUSH
92546: PPUSH
92547: PPUSH
92548: PPUSH
92549: PPUSH
92550: PPUSH
92551: PPUSH
// if not GetClass ( unit ) = class_sniper then
92552: LD_VAR 0 1
92556: PPUSH
92557: CALL_OW 257
92561: PUSH
92562: LD_INT 5
92564: EQUAL
92565: NOT
92566: IFFALSE 92570
// exit ;
92568: GO 92958
// dist := 8 ;
92570: LD_ADDR_VAR 0 5
92574: PUSH
92575: LD_INT 8
92577: ST_TO_ADDR
// viewRange := 12 ;
92578: LD_ADDR_VAR 0 7
92582: PUSH
92583: LD_INT 12
92585: ST_TO_ADDR
// side := GetSide ( unit ) ;
92586: LD_ADDR_VAR 0 6
92590: PUSH
92591: LD_VAR 0 1
92595: PPUSH
92596: CALL_OW 255
92600: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
92601: LD_INT 61
92603: PPUSH
92604: LD_VAR 0 6
92608: PPUSH
92609: CALL_OW 321
92613: PUSH
92614: LD_INT 2
92616: EQUAL
92617: IFFALSE 92627
// viewRange := 16 ;
92619: LD_ADDR_VAR 0 7
92623: PUSH
92624: LD_INT 16
92626: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
92627: LD_VAR 0 1
92631: PPUSH
92632: LD_VAR 0 2
92636: PPUSH
92637: LD_VAR 0 3
92641: PPUSH
92642: CALL_OW 297
92646: PUSH
92647: LD_VAR 0 5
92651: GREATER
92652: IFFALSE 92731
// begin ComMoveXY ( unit , x , y ) ;
92654: LD_VAR 0 1
92658: PPUSH
92659: LD_VAR 0 2
92663: PPUSH
92664: LD_VAR 0 3
92668: PPUSH
92669: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92673: LD_INT 35
92675: PPUSH
92676: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
92680: LD_VAR 0 1
92684: PPUSH
92685: LD_VAR 0 2
92689: PPUSH
92690: LD_VAR 0 3
92694: PPUSH
92695: CALL 46547 0 3
92699: NOT
92700: IFFALSE 92704
// exit ;
92702: GO 92958
// until GetDistUnitXY ( unit , x , y ) < dist ;
92704: LD_VAR 0 1
92708: PPUSH
92709: LD_VAR 0 2
92713: PPUSH
92714: LD_VAR 0 3
92718: PPUSH
92719: CALL_OW 297
92723: PUSH
92724: LD_VAR 0 5
92728: LESS
92729: IFFALSE 92673
// end ; ComTurnXY ( unit , x , y ) ;
92731: LD_VAR 0 1
92735: PPUSH
92736: LD_VAR 0 2
92740: PPUSH
92741: LD_VAR 0 3
92745: PPUSH
92746: CALL_OW 118
// wait ( 5 ) ;
92750: LD_INT 5
92752: PPUSH
92753: CALL_OW 67
// _d := GetDir ( unit ) ;
92757: LD_ADDR_VAR 0 10
92761: PUSH
92762: LD_VAR 0 1
92766: PPUSH
92767: CALL_OW 254
92771: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
92772: LD_ADDR_VAR 0 8
92776: PUSH
92777: LD_VAR 0 1
92781: PPUSH
92782: CALL_OW 250
92786: PPUSH
92787: LD_VAR 0 10
92791: PPUSH
92792: LD_VAR 0 5
92796: PPUSH
92797: CALL_OW 272
92801: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
92802: LD_ADDR_VAR 0 9
92806: PUSH
92807: LD_VAR 0 1
92811: PPUSH
92812: CALL_OW 251
92816: PPUSH
92817: LD_VAR 0 10
92821: PPUSH
92822: LD_VAR 0 5
92826: PPUSH
92827: CALL_OW 273
92831: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92832: LD_VAR 0 8
92836: PPUSH
92837: LD_VAR 0 9
92841: PPUSH
92842: CALL_OW 488
92846: NOT
92847: IFFALSE 92851
// exit ;
92849: GO 92958
// ComAnimCustom ( unit , 1 ) ;
92851: LD_VAR 0 1
92855: PPUSH
92856: LD_INT 1
92858: PPUSH
92859: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
92863: LD_VAR 0 8
92867: PPUSH
92868: LD_VAR 0 9
92872: PPUSH
92873: LD_VAR 0 6
92877: PPUSH
92878: LD_VAR 0 7
92882: PPUSH
92883: CALL_OW 330
// repeat wait ( 1 ) ;
92887: LD_INT 1
92889: PPUSH
92890: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
92894: LD_VAR 0 1
92898: PPUSH
92899: CALL_OW 316
92903: PUSH
92904: LD_VAR 0 1
92908: PPUSH
92909: CALL_OW 314
92913: OR
92914: PUSH
92915: LD_VAR 0 1
92919: PPUSH
92920: CALL_OW 302
92924: NOT
92925: OR
92926: PUSH
92927: LD_VAR 0 1
92931: PPUSH
92932: CALL_OW 301
92936: OR
92937: IFFALSE 92887
// RemoveSeeing ( _x , _y , side ) ;
92939: LD_VAR 0 8
92943: PPUSH
92944: LD_VAR 0 9
92948: PPUSH
92949: LD_VAR 0 6
92953: PPUSH
92954: CALL_OW 331
// end ; end_of_file end_of_file
92958: LD_VAR 0 4
92962: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
92963: LD_VAR 0 1
92967: PUSH
92968: LD_INT 200
92970: DOUBLE
92971: GREATEREQUAL
92972: IFFALSE 92980
92974: LD_INT 299
92976: DOUBLE
92977: LESSEQUAL
92978: IFTRUE 92982
92980: GO 93014
92982: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
92983: LD_VAR 0 1
92987: PPUSH
92988: LD_VAR 0 2
92992: PPUSH
92993: LD_VAR 0 3
92997: PPUSH
92998: LD_VAR 0 4
93002: PPUSH
93003: LD_VAR 0 5
93007: PPUSH
93008: CALL 89080 0 5
93012: GO 93091
93014: LD_INT 300
93016: DOUBLE
93017: GREATEREQUAL
93018: IFFALSE 93026
93020: LD_INT 399
93022: DOUBLE
93023: LESSEQUAL
93024: IFTRUE 93028
93026: GO 93090
93028: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
93029: LD_VAR 0 1
93033: PPUSH
93034: LD_VAR 0 2
93038: PPUSH
93039: LD_VAR 0 3
93043: PPUSH
93044: LD_VAR 0 4
93048: PPUSH
93049: LD_VAR 0 5
93053: PPUSH
93054: LD_VAR 0 6
93058: PPUSH
93059: LD_VAR 0 7
93063: PPUSH
93064: LD_VAR 0 8
93068: PPUSH
93069: LD_VAR 0 9
93073: PPUSH
93074: LD_VAR 0 10
93078: PPUSH
93079: LD_VAR 0 11
93083: PPUSH
93084: CALL 104931 0 11
93088: GO 93091
93090: POP
// end ;
93091: PPOPN 11
93093: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
93094: LD_VAR 0 1
93098: PPUSH
93099: LD_VAR 0 2
93103: PPUSH
93104: LD_VAR 0 3
93108: PPUSH
93109: LD_VAR 0 4
93113: PPUSH
93114: LD_VAR 0 5
93118: PPUSH
93119: CALL 89072 0 5
// end ; end_of_file
93123: PPOPN 5
93125: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93126: LD_INT 0
93128: PPUSH
// if p2 = 100 then
93129: LD_VAR 0 2
93133: PUSH
93134: LD_INT 100
93136: EQUAL
93137: IFFALSE 94140
// begin if not StreamModeActive then
93139: LD_EXP 98
93143: NOT
93144: IFFALSE 93154
// StreamModeActive := true ;
93146: LD_ADDR_EXP 98
93150: PUSH
93151: LD_INT 1
93153: ST_TO_ADDR
// if p3 = 0 then
93154: LD_VAR 0 3
93158: PUSH
93159: LD_INT 0
93161: EQUAL
93162: IFFALSE 93168
// InitStreamMode ;
93164: CALL 94300 0 0
// if p3 = 1 then
93168: LD_VAR 0 3
93172: PUSH
93173: LD_INT 1
93175: EQUAL
93176: IFFALSE 93186
// sRocket := true ;
93178: LD_ADDR_EXP 103
93182: PUSH
93183: LD_INT 1
93185: ST_TO_ADDR
// if p3 = 2 then
93186: LD_VAR 0 3
93190: PUSH
93191: LD_INT 2
93193: EQUAL
93194: IFFALSE 93204
// sSpeed := true ;
93196: LD_ADDR_EXP 102
93200: PUSH
93201: LD_INT 1
93203: ST_TO_ADDR
// if p3 = 3 then
93204: LD_VAR 0 3
93208: PUSH
93209: LD_INT 3
93211: EQUAL
93212: IFFALSE 93222
// sEngine := true ;
93214: LD_ADDR_EXP 104
93218: PUSH
93219: LD_INT 1
93221: ST_TO_ADDR
// if p3 = 4 then
93222: LD_VAR 0 3
93226: PUSH
93227: LD_INT 4
93229: EQUAL
93230: IFFALSE 93240
// sSpec := true ;
93232: LD_ADDR_EXP 101
93236: PUSH
93237: LD_INT 1
93239: ST_TO_ADDR
// if p3 = 5 then
93240: LD_VAR 0 3
93244: PUSH
93245: LD_INT 5
93247: EQUAL
93248: IFFALSE 93258
// sLevel := true ;
93250: LD_ADDR_EXP 105
93254: PUSH
93255: LD_INT 1
93257: ST_TO_ADDR
// if p3 = 6 then
93258: LD_VAR 0 3
93262: PUSH
93263: LD_INT 6
93265: EQUAL
93266: IFFALSE 93276
// sArmoury := true ;
93268: LD_ADDR_EXP 106
93272: PUSH
93273: LD_INT 1
93275: ST_TO_ADDR
// if p3 = 7 then
93276: LD_VAR 0 3
93280: PUSH
93281: LD_INT 7
93283: EQUAL
93284: IFFALSE 93294
// sRadar := true ;
93286: LD_ADDR_EXP 107
93290: PUSH
93291: LD_INT 1
93293: ST_TO_ADDR
// if p3 = 8 then
93294: LD_VAR 0 3
93298: PUSH
93299: LD_INT 8
93301: EQUAL
93302: IFFALSE 93312
// sBunker := true ;
93304: LD_ADDR_EXP 108
93308: PUSH
93309: LD_INT 1
93311: ST_TO_ADDR
// if p3 = 9 then
93312: LD_VAR 0 3
93316: PUSH
93317: LD_INT 9
93319: EQUAL
93320: IFFALSE 93330
// sHack := true ;
93322: LD_ADDR_EXP 109
93326: PUSH
93327: LD_INT 1
93329: ST_TO_ADDR
// if p3 = 10 then
93330: LD_VAR 0 3
93334: PUSH
93335: LD_INT 10
93337: EQUAL
93338: IFFALSE 93348
// sFire := true ;
93340: LD_ADDR_EXP 110
93344: PUSH
93345: LD_INT 1
93347: ST_TO_ADDR
// if p3 = 11 then
93348: LD_VAR 0 3
93352: PUSH
93353: LD_INT 11
93355: EQUAL
93356: IFFALSE 93366
// sRefresh := true ;
93358: LD_ADDR_EXP 111
93362: PUSH
93363: LD_INT 1
93365: ST_TO_ADDR
// if p3 = 12 then
93366: LD_VAR 0 3
93370: PUSH
93371: LD_INT 12
93373: EQUAL
93374: IFFALSE 93384
// sExp := true ;
93376: LD_ADDR_EXP 112
93380: PUSH
93381: LD_INT 1
93383: ST_TO_ADDR
// if p3 = 13 then
93384: LD_VAR 0 3
93388: PUSH
93389: LD_INT 13
93391: EQUAL
93392: IFFALSE 93402
// sDepot := true ;
93394: LD_ADDR_EXP 113
93398: PUSH
93399: LD_INT 1
93401: ST_TO_ADDR
// if p3 = 14 then
93402: LD_VAR 0 3
93406: PUSH
93407: LD_INT 14
93409: EQUAL
93410: IFFALSE 93420
// sFlag := true ;
93412: LD_ADDR_EXP 114
93416: PUSH
93417: LD_INT 1
93419: ST_TO_ADDR
// if p3 = 15 then
93420: LD_VAR 0 3
93424: PUSH
93425: LD_INT 15
93427: EQUAL
93428: IFFALSE 93438
// sKamikadze := true ;
93430: LD_ADDR_EXP 122
93434: PUSH
93435: LD_INT 1
93437: ST_TO_ADDR
// if p3 = 16 then
93438: LD_VAR 0 3
93442: PUSH
93443: LD_INT 16
93445: EQUAL
93446: IFFALSE 93456
// sTroll := true ;
93448: LD_ADDR_EXP 123
93452: PUSH
93453: LD_INT 1
93455: ST_TO_ADDR
// if p3 = 17 then
93456: LD_VAR 0 3
93460: PUSH
93461: LD_INT 17
93463: EQUAL
93464: IFFALSE 93474
// sSlow := true ;
93466: LD_ADDR_EXP 124
93470: PUSH
93471: LD_INT 1
93473: ST_TO_ADDR
// if p3 = 18 then
93474: LD_VAR 0 3
93478: PUSH
93479: LD_INT 18
93481: EQUAL
93482: IFFALSE 93492
// sLack := true ;
93484: LD_ADDR_EXP 125
93488: PUSH
93489: LD_INT 1
93491: ST_TO_ADDR
// if p3 = 19 then
93492: LD_VAR 0 3
93496: PUSH
93497: LD_INT 19
93499: EQUAL
93500: IFFALSE 93510
// sTank := true ;
93502: LD_ADDR_EXP 127
93506: PUSH
93507: LD_INT 1
93509: ST_TO_ADDR
// if p3 = 20 then
93510: LD_VAR 0 3
93514: PUSH
93515: LD_INT 20
93517: EQUAL
93518: IFFALSE 93528
// sRemote := true ;
93520: LD_ADDR_EXP 128
93524: PUSH
93525: LD_INT 1
93527: ST_TO_ADDR
// if p3 = 21 then
93528: LD_VAR 0 3
93532: PUSH
93533: LD_INT 21
93535: EQUAL
93536: IFFALSE 93546
// sPowell := true ;
93538: LD_ADDR_EXP 129
93542: PUSH
93543: LD_INT 1
93545: ST_TO_ADDR
// if p3 = 22 then
93546: LD_VAR 0 3
93550: PUSH
93551: LD_INT 22
93553: EQUAL
93554: IFFALSE 93564
// sTeleport := true ;
93556: LD_ADDR_EXP 132
93560: PUSH
93561: LD_INT 1
93563: ST_TO_ADDR
// if p3 = 23 then
93564: LD_VAR 0 3
93568: PUSH
93569: LD_INT 23
93571: EQUAL
93572: IFFALSE 93582
// sOilTower := true ;
93574: LD_ADDR_EXP 134
93578: PUSH
93579: LD_INT 1
93581: ST_TO_ADDR
// if p3 = 24 then
93582: LD_VAR 0 3
93586: PUSH
93587: LD_INT 24
93589: EQUAL
93590: IFFALSE 93600
// sShovel := true ;
93592: LD_ADDR_EXP 135
93596: PUSH
93597: LD_INT 1
93599: ST_TO_ADDR
// if p3 = 25 then
93600: LD_VAR 0 3
93604: PUSH
93605: LD_INT 25
93607: EQUAL
93608: IFFALSE 93618
// sSheik := true ;
93610: LD_ADDR_EXP 136
93614: PUSH
93615: LD_INT 1
93617: ST_TO_ADDR
// if p3 = 26 then
93618: LD_VAR 0 3
93622: PUSH
93623: LD_INT 26
93625: EQUAL
93626: IFFALSE 93636
// sEarthquake := true ;
93628: LD_ADDR_EXP 138
93632: PUSH
93633: LD_INT 1
93635: ST_TO_ADDR
// if p3 = 27 then
93636: LD_VAR 0 3
93640: PUSH
93641: LD_INT 27
93643: EQUAL
93644: IFFALSE 93654
// sAI := true ;
93646: LD_ADDR_EXP 139
93650: PUSH
93651: LD_INT 1
93653: ST_TO_ADDR
// if p3 = 28 then
93654: LD_VAR 0 3
93658: PUSH
93659: LD_INT 28
93661: EQUAL
93662: IFFALSE 93672
// sCargo := true ;
93664: LD_ADDR_EXP 142
93668: PUSH
93669: LD_INT 1
93671: ST_TO_ADDR
// if p3 = 29 then
93672: LD_VAR 0 3
93676: PUSH
93677: LD_INT 29
93679: EQUAL
93680: IFFALSE 93690
// sDLaser := true ;
93682: LD_ADDR_EXP 143
93686: PUSH
93687: LD_INT 1
93689: ST_TO_ADDR
// if p3 = 30 then
93690: LD_VAR 0 3
93694: PUSH
93695: LD_INT 30
93697: EQUAL
93698: IFFALSE 93708
// sExchange := true ;
93700: LD_ADDR_EXP 144
93704: PUSH
93705: LD_INT 1
93707: ST_TO_ADDR
// if p3 = 31 then
93708: LD_VAR 0 3
93712: PUSH
93713: LD_INT 31
93715: EQUAL
93716: IFFALSE 93726
// sFac := true ;
93718: LD_ADDR_EXP 145
93722: PUSH
93723: LD_INT 1
93725: ST_TO_ADDR
// if p3 = 32 then
93726: LD_VAR 0 3
93730: PUSH
93731: LD_INT 32
93733: EQUAL
93734: IFFALSE 93744
// sPower := true ;
93736: LD_ADDR_EXP 146
93740: PUSH
93741: LD_INT 1
93743: ST_TO_ADDR
// if p3 = 33 then
93744: LD_VAR 0 3
93748: PUSH
93749: LD_INT 33
93751: EQUAL
93752: IFFALSE 93762
// sRandom := true ;
93754: LD_ADDR_EXP 147
93758: PUSH
93759: LD_INT 1
93761: ST_TO_ADDR
// if p3 = 34 then
93762: LD_VAR 0 3
93766: PUSH
93767: LD_INT 34
93769: EQUAL
93770: IFFALSE 93780
// sShield := true ;
93772: LD_ADDR_EXP 148
93776: PUSH
93777: LD_INT 1
93779: ST_TO_ADDR
// if p3 = 35 then
93780: LD_VAR 0 3
93784: PUSH
93785: LD_INT 35
93787: EQUAL
93788: IFFALSE 93798
// sTime := true ;
93790: LD_ADDR_EXP 149
93794: PUSH
93795: LD_INT 1
93797: ST_TO_ADDR
// if p3 = 36 then
93798: LD_VAR 0 3
93802: PUSH
93803: LD_INT 36
93805: EQUAL
93806: IFFALSE 93816
// sTools := true ;
93808: LD_ADDR_EXP 150
93812: PUSH
93813: LD_INT 1
93815: ST_TO_ADDR
// if p3 = 101 then
93816: LD_VAR 0 3
93820: PUSH
93821: LD_INT 101
93823: EQUAL
93824: IFFALSE 93834
// sSold := true ;
93826: LD_ADDR_EXP 115
93830: PUSH
93831: LD_INT 1
93833: ST_TO_ADDR
// if p3 = 102 then
93834: LD_VAR 0 3
93838: PUSH
93839: LD_INT 102
93841: EQUAL
93842: IFFALSE 93852
// sDiff := true ;
93844: LD_ADDR_EXP 116
93848: PUSH
93849: LD_INT 1
93851: ST_TO_ADDR
// if p3 = 103 then
93852: LD_VAR 0 3
93856: PUSH
93857: LD_INT 103
93859: EQUAL
93860: IFFALSE 93870
// sFog := true ;
93862: LD_ADDR_EXP 119
93866: PUSH
93867: LD_INT 1
93869: ST_TO_ADDR
// if p3 = 104 then
93870: LD_VAR 0 3
93874: PUSH
93875: LD_INT 104
93877: EQUAL
93878: IFFALSE 93888
// sReset := true ;
93880: LD_ADDR_EXP 120
93884: PUSH
93885: LD_INT 1
93887: ST_TO_ADDR
// if p3 = 105 then
93888: LD_VAR 0 3
93892: PUSH
93893: LD_INT 105
93895: EQUAL
93896: IFFALSE 93906
// sSun := true ;
93898: LD_ADDR_EXP 121
93902: PUSH
93903: LD_INT 1
93905: ST_TO_ADDR
// if p3 = 106 then
93906: LD_VAR 0 3
93910: PUSH
93911: LD_INT 106
93913: EQUAL
93914: IFFALSE 93924
// sTiger := true ;
93916: LD_ADDR_EXP 117
93920: PUSH
93921: LD_INT 1
93923: ST_TO_ADDR
// if p3 = 107 then
93924: LD_VAR 0 3
93928: PUSH
93929: LD_INT 107
93931: EQUAL
93932: IFFALSE 93942
// sBomb := true ;
93934: LD_ADDR_EXP 118
93938: PUSH
93939: LD_INT 1
93941: ST_TO_ADDR
// if p3 = 108 then
93942: LD_VAR 0 3
93946: PUSH
93947: LD_INT 108
93949: EQUAL
93950: IFFALSE 93960
// sWound := true ;
93952: LD_ADDR_EXP 126
93956: PUSH
93957: LD_INT 1
93959: ST_TO_ADDR
// if p3 = 109 then
93960: LD_VAR 0 3
93964: PUSH
93965: LD_INT 109
93967: EQUAL
93968: IFFALSE 93978
// sBetray := true ;
93970: LD_ADDR_EXP 130
93974: PUSH
93975: LD_INT 1
93977: ST_TO_ADDR
// if p3 = 110 then
93978: LD_VAR 0 3
93982: PUSH
93983: LD_INT 110
93985: EQUAL
93986: IFFALSE 93996
// sContamin := true ;
93988: LD_ADDR_EXP 131
93992: PUSH
93993: LD_INT 1
93995: ST_TO_ADDR
// if p3 = 111 then
93996: LD_VAR 0 3
94000: PUSH
94001: LD_INT 111
94003: EQUAL
94004: IFFALSE 94014
// sOil := true ;
94006: LD_ADDR_EXP 133
94010: PUSH
94011: LD_INT 1
94013: ST_TO_ADDR
// if p3 = 112 then
94014: LD_VAR 0 3
94018: PUSH
94019: LD_INT 112
94021: EQUAL
94022: IFFALSE 94032
// sStu := true ;
94024: LD_ADDR_EXP 137
94028: PUSH
94029: LD_INT 1
94031: ST_TO_ADDR
// if p3 = 113 then
94032: LD_VAR 0 3
94036: PUSH
94037: LD_INT 113
94039: EQUAL
94040: IFFALSE 94050
// sBazooka := true ;
94042: LD_ADDR_EXP 140
94046: PUSH
94047: LD_INT 1
94049: ST_TO_ADDR
// if p3 = 114 then
94050: LD_VAR 0 3
94054: PUSH
94055: LD_INT 114
94057: EQUAL
94058: IFFALSE 94068
// sMortar := true ;
94060: LD_ADDR_EXP 141
94064: PUSH
94065: LD_INT 1
94067: ST_TO_ADDR
// if p3 = 115 then
94068: LD_VAR 0 3
94072: PUSH
94073: LD_INT 115
94075: EQUAL
94076: IFFALSE 94086
// sRanger := true ;
94078: LD_ADDR_EXP 151
94082: PUSH
94083: LD_INT 1
94085: ST_TO_ADDR
// if p3 = 116 then
94086: LD_VAR 0 3
94090: PUSH
94091: LD_INT 116
94093: EQUAL
94094: IFFALSE 94104
// sComputer := true ;
94096: LD_ADDR_EXP 152
94100: PUSH
94101: LD_INT 1
94103: ST_TO_ADDR
// if p3 = 117 then
94104: LD_VAR 0 3
94108: PUSH
94109: LD_INT 117
94111: EQUAL
94112: IFFALSE 94122
// s30 := true ;
94114: LD_ADDR_EXP 153
94118: PUSH
94119: LD_INT 1
94121: ST_TO_ADDR
// if p3 = 118 then
94122: LD_VAR 0 3
94126: PUSH
94127: LD_INT 118
94129: EQUAL
94130: IFFALSE 94140
// s60 := true ;
94132: LD_ADDR_EXP 154
94136: PUSH
94137: LD_INT 1
94139: ST_TO_ADDR
// end ; if p2 = 101 then
94140: LD_VAR 0 2
94144: PUSH
94145: LD_INT 101
94147: EQUAL
94148: IFFALSE 94276
// begin case p3 of 1 :
94150: LD_VAR 0 3
94154: PUSH
94155: LD_INT 1
94157: DOUBLE
94158: EQUAL
94159: IFTRUE 94163
94161: GO 94170
94163: POP
// hHackUnlimitedResources ; 2 :
94164: CALL 105872 0 0
94168: GO 94276
94170: LD_INT 2
94172: DOUBLE
94173: EQUAL
94174: IFTRUE 94178
94176: GO 94185
94178: POP
// hHackSetLevel10 ; 3 :
94179: CALL 106005 0 0
94183: GO 94276
94185: LD_INT 3
94187: DOUBLE
94188: EQUAL
94189: IFTRUE 94193
94191: GO 94200
94193: POP
// hHackSetLevel10YourUnits ; 4 :
94194: CALL 106090 0 0
94198: GO 94276
94200: LD_INT 4
94202: DOUBLE
94203: EQUAL
94204: IFTRUE 94208
94206: GO 94215
94208: POP
// hHackInvincible ; 5 :
94209: CALL 106538 0 0
94213: GO 94276
94215: LD_INT 5
94217: DOUBLE
94218: EQUAL
94219: IFTRUE 94223
94221: GO 94230
94223: POP
// hHackInvisible ; 6 :
94224: CALL 106649 0 0
94228: GO 94276
94230: LD_INT 6
94232: DOUBLE
94233: EQUAL
94234: IFTRUE 94238
94236: GO 94245
94238: POP
// hHackChangeYourSide ; 7 :
94239: CALL 106706 0 0
94243: GO 94276
94245: LD_INT 7
94247: DOUBLE
94248: EQUAL
94249: IFTRUE 94253
94251: GO 94260
94253: POP
// hHackChangeUnitSide ; 8 :
94254: CALL 106748 0 0
94258: GO 94276
94260: LD_INT 8
94262: DOUBLE
94263: EQUAL
94264: IFTRUE 94268
94266: GO 94275
94268: POP
// hHackFog ; end ;
94269: CALL 106849 0 0
94273: GO 94276
94275: POP
// end ; end ;
94276: LD_VAR 0 7
94280: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
94281: GO 94283
94283: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
94284: LD_STRING initStreamRollete();
94286: PPUSH
94287: CALL_OW 559
// InitStreamMode ;
94291: CALL 94300 0 0
// DefineStreamItems ( ) ;
94295: CALL 94764 0 0
// end ;
94299: END
// function InitStreamMode ; begin
94300: LD_INT 0
94302: PPUSH
// streamModeActive := false ;
94303: LD_ADDR_EXP 98
94307: PUSH
94308: LD_INT 0
94310: ST_TO_ADDR
// normalCounter := 36 ;
94311: LD_ADDR_EXP 99
94315: PUSH
94316: LD_INT 36
94318: ST_TO_ADDR
// hardcoreCounter := 16 ;
94319: LD_ADDR_EXP 100
94323: PUSH
94324: LD_INT 16
94326: ST_TO_ADDR
// sRocket := false ;
94327: LD_ADDR_EXP 103
94331: PUSH
94332: LD_INT 0
94334: ST_TO_ADDR
// sSpeed := false ;
94335: LD_ADDR_EXP 102
94339: PUSH
94340: LD_INT 0
94342: ST_TO_ADDR
// sEngine := false ;
94343: LD_ADDR_EXP 104
94347: PUSH
94348: LD_INT 0
94350: ST_TO_ADDR
// sSpec := false ;
94351: LD_ADDR_EXP 101
94355: PUSH
94356: LD_INT 0
94358: ST_TO_ADDR
// sLevel := false ;
94359: LD_ADDR_EXP 105
94363: PUSH
94364: LD_INT 0
94366: ST_TO_ADDR
// sArmoury := false ;
94367: LD_ADDR_EXP 106
94371: PUSH
94372: LD_INT 0
94374: ST_TO_ADDR
// sRadar := false ;
94375: LD_ADDR_EXP 107
94379: PUSH
94380: LD_INT 0
94382: ST_TO_ADDR
// sBunker := false ;
94383: LD_ADDR_EXP 108
94387: PUSH
94388: LD_INT 0
94390: ST_TO_ADDR
// sHack := false ;
94391: LD_ADDR_EXP 109
94395: PUSH
94396: LD_INT 0
94398: ST_TO_ADDR
// sFire := false ;
94399: LD_ADDR_EXP 110
94403: PUSH
94404: LD_INT 0
94406: ST_TO_ADDR
// sRefresh := false ;
94407: LD_ADDR_EXP 111
94411: PUSH
94412: LD_INT 0
94414: ST_TO_ADDR
// sExp := false ;
94415: LD_ADDR_EXP 112
94419: PUSH
94420: LD_INT 0
94422: ST_TO_ADDR
// sDepot := false ;
94423: LD_ADDR_EXP 113
94427: PUSH
94428: LD_INT 0
94430: ST_TO_ADDR
// sFlag := false ;
94431: LD_ADDR_EXP 114
94435: PUSH
94436: LD_INT 0
94438: ST_TO_ADDR
// sKamikadze := false ;
94439: LD_ADDR_EXP 122
94443: PUSH
94444: LD_INT 0
94446: ST_TO_ADDR
// sTroll := false ;
94447: LD_ADDR_EXP 123
94451: PUSH
94452: LD_INT 0
94454: ST_TO_ADDR
// sSlow := false ;
94455: LD_ADDR_EXP 124
94459: PUSH
94460: LD_INT 0
94462: ST_TO_ADDR
// sLack := false ;
94463: LD_ADDR_EXP 125
94467: PUSH
94468: LD_INT 0
94470: ST_TO_ADDR
// sTank := false ;
94471: LD_ADDR_EXP 127
94475: PUSH
94476: LD_INT 0
94478: ST_TO_ADDR
// sRemote := false ;
94479: LD_ADDR_EXP 128
94483: PUSH
94484: LD_INT 0
94486: ST_TO_ADDR
// sPowell := false ;
94487: LD_ADDR_EXP 129
94491: PUSH
94492: LD_INT 0
94494: ST_TO_ADDR
// sTeleport := false ;
94495: LD_ADDR_EXP 132
94499: PUSH
94500: LD_INT 0
94502: ST_TO_ADDR
// sOilTower := false ;
94503: LD_ADDR_EXP 134
94507: PUSH
94508: LD_INT 0
94510: ST_TO_ADDR
// sShovel := false ;
94511: LD_ADDR_EXP 135
94515: PUSH
94516: LD_INT 0
94518: ST_TO_ADDR
// sSheik := false ;
94519: LD_ADDR_EXP 136
94523: PUSH
94524: LD_INT 0
94526: ST_TO_ADDR
// sEarthquake := false ;
94527: LD_ADDR_EXP 138
94531: PUSH
94532: LD_INT 0
94534: ST_TO_ADDR
// sAI := false ;
94535: LD_ADDR_EXP 139
94539: PUSH
94540: LD_INT 0
94542: ST_TO_ADDR
// sCargo := false ;
94543: LD_ADDR_EXP 142
94547: PUSH
94548: LD_INT 0
94550: ST_TO_ADDR
// sDLaser := false ;
94551: LD_ADDR_EXP 143
94555: PUSH
94556: LD_INT 0
94558: ST_TO_ADDR
// sExchange := false ;
94559: LD_ADDR_EXP 144
94563: PUSH
94564: LD_INT 0
94566: ST_TO_ADDR
// sFac := false ;
94567: LD_ADDR_EXP 145
94571: PUSH
94572: LD_INT 0
94574: ST_TO_ADDR
// sPower := false ;
94575: LD_ADDR_EXP 146
94579: PUSH
94580: LD_INT 0
94582: ST_TO_ADDR
// sRandom := false ;
94583: LD_ADDR_EXP 147
94587: PUSH
94588: LD_INT 0
94590: ST_TO_ADDR
// sShield := false ;
94591: LD_ADDR_EXP 148
94595: PUSH
94596: LD_INT 0
94598: ST_TO_ADDR
// sTime := false ;
94599: LD_ADDR_EXP 149
94603: PUSH
94604: LD_INT 0
94606: ST_TO_ADDR
// sTools := false ;
94607: LD_ADDR_EXP 150
94611: PUSH
94612: LD_INT 0
94614: ST_TO_ADDR
// sSold := false ;
94615: LD_ADDR_EXP 115
94619: PUSH
94620: LD_INT 0
94622: ST_TO_ADDR
// sDiff := false ;
94623: LD_ADDR_EXP 116
94627: PUSH
94628: LD_INT 0
94630: ST_TO_ADDR
// sFog := false ;
94631: LD_ADDR_EXP 119
94635: PUSH
94636: LD_INT 0
94638: ST_TO_ADDR
// sReset := false ;
94639: LD_ADDR_EXP 120
94643: PUSH
94644: LD_INT 0
94646: ST_TO_ADDR
// sSun := false ;
94647: LD_ADDR_EXP 121
94651: PUSH
94652: LD_INT 0
94654: ST_TO_ADDR
// sTiger := false ;
94655: LD_ADDR_EXP 117
94659: PUSH
94660: LD_INT 0
94662: ST_TO_ADDR
// sBomb := false ;
94663: LD_ADDR_EXP 118
94667: PUSH
94668: LD_INT 0
94670: ST_TO_ADDR
// sWound := false ;
94671: LD_ADDR_EXP 126
94675: PUSH
94676: LD_INT 0
94678: ST_TO_ADDR
// sBetray := false ;
94679: LD_ADDR_EXP 130
94683: PUSH
94684: LD_INT 0
94686: ST_TO_ADDR
// sContamin := false ;
94687: LD_ADDR_EXP 131
94691: PUSH
94692: LD_INT 0
94694: ST_TO_ADDR
// sOil := false ;
94695: LD_ADDR_EXP 133
94699: PUSH
94700: LD_INT 0
94702: ST_TO_ADDR
// sStu := false ;
94703: LD_ADDR_EXP 137
94707: PUSH
94708: LD_INT 0
94710: ST_TO_ADDR
// sBazooka := false ;
94711: LD_ADDR_EXP 140
94715: PUSH
94716: LD_INT 0
94718: ST_TO_ADDR
// sMortar := false ;
94719: LD_ADDR_EXP 141
94723: PUSH
94724: LD_INT 0
94726: ST_TO_ADDR
// sRanger := false ;
94727: LD_ADDR_EXP 151
94731: PUSH
94732: LD_INT 0
94734: ST_TO_ADDR
// sComputer := false ;
94735: LD_ADDR_EXP 152
94739: PUSH
94740: LD_INT 0
94742: ST_TO_ADDR
// s30 := false ;
94743: LD_ADDR_EXP 153
94747: PUSH
94748: LD_INT 0
94750: ST_TO_ADDR
// s60 := false ;
94751: LD_ADDR_EXP 154
94755: PUSH
94756: LD_INT 0
94758: ST_TO_ADDR
// end ;
94759: LD_VAR 0 1
94763: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
94764: LD_INT 0
94766: PPUSH
94767: PPUSH
94768: PPUSH
94769: PPUSH
94770: PPUSH
// result := [ ] ;
94771: LD_ADDR_VAR 0 1
94775: PUSH
94776: EMPTY
94777: ST_TO_ADDR
// if campaign_id = 1 then
94778: LD_OWVAR 69
94782: PUSH
94783: LD_INT 1
94785: EQUAL
94786: IFFALSE 97952
// begin case mission_number of 1 :
94788: LD_OWVAR 70
94792: PUSH
94793: LD_INT 1
94795: DOUBLE
94796: EQUAL
94797: IFTRUE 94801
94799: GO 94877
94801: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
94802: LD_ADDR_VAR 0 1
94806: PUSH
94807: LD_INT 2
94809: PUSH
94810: LD_INT 4
94812: PUSH
94813: LD_INT 11
94815: PUSH
94816: LD_INT 12
94818: PUSH
94819: LD_INT 15
94821: PUSH
94822: LD_INT 16
94824: PUSH
94825: LD_INT 22
94827: PUSH
94828: LD_INT 23
94830: PUSH
94831: LD_INT 26
94833: PUSH
94834: EMPTY
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 101
94847: PUSH
94848: LD_INT 102
94850: PUSH
94851: LD_INT 106
94853: PUSH
94854: LD_INT 116
94856: PUSH
94857: LD_INT 117
94859: PUSH
94860: LD_INT 118
94862: PUSH
94863: EMPTY
94864: LIST
94865: LIST
94866: LIST
94867: LIST
94868: LIST
94869: LIST
94870: PUSH
94871: EMPTY
94872: LIST
94873: LIST
94874: ST_TO_ADDR
94875: GO 97950
94877: LD_INT 2
94879: DOUBLE
94880: EQUAL
94881: IFTRUE 94885
94883: GO 94969
94885: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
94886: LD_ADDR_VAR 0 1
94890: PUSH
94891: LD_INT 2
94893: PUSH
94894: LD_INT 4
94896: PUSH
94897: LD_INT 11
94899: PUSH
94900: LD_INT 12
94902: PUSH
94903: LD_INT 15
94905: PUSH
94906: LD_INT 16
94908: PUSH
94909: LD_INT 22
94911: PUSH
94912: LD_INT 23
94914: PUSH
94915: LD_INT 26
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 101
94931: PUSH
94932: LD_INT 102
94934: PUSH
94935: LD_INT 105
94937: PUSH
94938: LD_INT 106
94940: PUSH
94941: LD_INT 108
94943: PUSH
94944: LD_INT 116
94946: PUSH
94947: LD_INT 117
94949: PUSH
94950: LD_INT 118
94952: PUSH
94953: EMPTY
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: PUSH
94963: EMPTY
94964: LIST
94965: LIST
94966: ST_TO_ADDR
94967: GO 97950
94969: LD_INT 3
94971: DOUBLE
94972: EQUAL
94973: IFTRUE 94977
94975: GO 95065
94977: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94978: LD_ADDR_VAR 0 1
94982: PUSH
94983: LD_INT 2
94985: PUSH
94986: LD_INT 4
94988: PUSH
94989: LD_INT 5
94991: PUSH
94992: LD_INT 11
94994: PUSH
94995: LD_INT 12
94997: PUSH
94998: LD_INT 15
95000: PUSH
95001: LD_INT 16
95003: PUSH
95004: LD_INT 22
95006: PUSH
95007: LD_INT 26
95009: PUSH
95010: LD_INT 36
95012: PUSH
95013: EMPTY
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: PUSH
95025: LD_INT 101
95027: PUSH
95028: LD_INT 102
95030: PUSH
95031: LD_INT 105
95033: PUSH
95034: LD_INT 106
95036: PUSH
95037: LD_INT 108
95039: PUSH
95040: LD_INT 116
95042: PUSH
95043: LD_INT 117
95045: PUSH
95046: LD_INT 118
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: PUSH
95059: EMPTY
95060: LIST
95061: LIST
95062: ST_TO_ADDR
95063: GO 97950
95065: LD_INT 4
95067: DOUBLE
95068: EQUAL
95069: IFTRUE 95073
95071: GO 95169
95073: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
95074: LD_ADDR_VAR 0 1
95078: PUSH
95079: LD_INT 2
95081: PUSH
95082: LD_INT 4
95084: PUSH
95085: LD_INT 5
95087: PUSH
95088: LD_INT 8
95090: PUSH
95091: LD_INT 11
95093: PUSH
95094: LD_INT 12
95096: PUSH
95097: LD_INT 15
95099: PUSH
95100: LD_INT 16
95102: PUSH
95103: LD_INT 22
95105: PUSH
95106: LD_INT 23
95108: PUSH
95109: LD_INT 26
95111: PUSH
95112: LD_INT 36
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 101
95131: PUSH
95132: LD_INT 102
95134: PUSH
95135: LD_INT 105
95137: PUSH
95138: LD_INT 106
95140: PUSH
95141: LD_INT 108
95143: PUSH
95144: LD_INT 116
95146: PUSH
95147: LD_INT 117
95149: PUSH
95150: LD_INT 118
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: LIST
95157: LIST
95158: LIST
95159: LIST
95160: LIST
95161: LIST
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: ST_TO_ADDR
95167: GO 97950
95169: LD_INT 5
95171: DOUBLE
95172: EQUAL
95173: IFTRUE 95177
95175: GO 95289
95177: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
95178: LD_ADDR_VAR 0 1
95182: PUSH
95183: LD_INT 2
95185: PUSH
95186: LD_INT 4
95188: PUSH
95189: LD_INT 5
95191: PUSH
95192: LD_INT 6
95194: PUSH
95195: LD_INT 8
95197: PUSH
95198: LD_INT 11
95200: PUSH
95201: LD_INT 12
95203: PUSH
95204: LD_INT 15
95206: PUSH
95207: LD_INT 16
95209: PUSH
95210: LD_INT 22
95212: PUSH
95213: LD_INT 23
95215: PUSH
95216: LD_INT 25
95218: PUSH
95219: LD_INT 26
95221: PUSH
95222: LD_INT 36
95224: PUSH
95225: EMPTY
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: PUSH
95241: LD_INT 101
95243: PUSH
95244: LD_INT 102
95246: PUSH
95247: LD_INT 105
95249: PUSH
95250: LD_INT 106
95252: PUSH
95253: LD_INT 108
95255: PUSH
95256: LD_INT 109
95258: PUSH
95259: LD_INT 112
95261: PUSH
95262: LD_INT 116
95264: PUSH
95265: LD_INT 117
95267: PUSH
95268: LD_INT 118
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: LIST
95278: LIST
95279: LIST
95280: LIST
95281: LIST
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: ST_TO_ADDR
95287: GO 97950
95289: LD_INT 6
95291: DOUBLE
95292: EQUAL
95293: IFTRUE 95297
95295: GO 95429
95297: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
95298: LD_ADDR_VAR 0 1
95302: PUSH
95303: LD_INT 2
95305: PUSH
95306: LD_INT 4
95308: PUSH
95309: LD_INT 5
95311: PUSH
95312: LD_INT 6
95314: PUSH
95315: LD_INT 8
95317: PUSH
95318: LD_INT 11
95320: PUSH
95321: LD_INT 12
95323: PUSH
95324: LD_INT 15
95326: PUSH
95327: LD_INT 16
95329: PUSH
95330: LD_INT 20
95332: PUSH
95333: LD_INT 21
95335: PUSH
95336: LD_INT 22
95338: PUSH
95339: LD_INT 23
95341: PUSH
95342: LD_INT 25
95344: PUSH
95345: LD_INT 26
95347: PUSH
95348: LD_INT 30
95350: PUSH
95351: LD_INT 31
95353: PUSH
95354: LD_INT 32
95356: PUSH
95357: LD_INT 36
95359: PUSH
95360: EMPTY
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 101
95383: PUSH
95384: LD_INT 102
95386: PUSH
95387: LD_INT 105
95389: PUSH
95390: LD_INT 106
95392: PUSH
95393: LD_INT 108
95395: PUSH
95396: LD_INT 109
95398: PUSH
95399: LD_INT 112
95401: PUSH
95402: LD_INT 116
95404: PUSH
95405: LD_INT 117
95407: PUSH
95408: LD_INT 118
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: ST_TO_ADDR
95427: GO 97950
95429: LD_INT 7
95431: DOUBLE
95432: EQUAL
95433: IFTRUE 95437
95435: GO 95549
95437: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95438: LD_ADDR_VAR 0 1
95442: PUSH
95443: LD_INT 2
95445: PUSH
95446: LD_INT 4
95448: PUSH
95449: LD_INT 5
95451: PUSH
95452: LD_INT 7
95454: PUSH
95455: LD_INT 11
95457: PUSH
95458: LD_INT 12
95460: PUSH
95461: LD_INT 15
95463: PUSH
95464: LD_INT 16
95466: PUSH
95467: LD_INT 20
95469: PUSH
95470: LD_INT 21
95472: PUSH
95473: LD_INT 22
95475: PUSH
95476: LD_INT 23
95478: PUSH
95479: LD_INT 25
95481: PUSH
95482: LD_INT 26
95484: PUSH
95485: EMPTY
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: PUSH
95501: LD_INT 101
95503: PUSH
95504: LD_INT 102
95506: PUSH
95507: LD_INT 103
95509: PUSH
95510: LD_INT 105
95512: PUSH
95513: LD_INT 106
95515: PUSH
95516: LD_INT 108
95518: PUSH
95519: LD_INT 112
95521: PUSH
95522: LD_INT 116
95524: PUSH
95525: LD_INT 117
95527: PUSH
95528: LD_INT 118
95530: PUSH
95531: EMPTY
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: ST_TO_ADDR
95547: GO 97950
95549: LD_INT 8
95551: DOUBLE
95552: EQUAL
95553: IFTRUE 95557
95555: GO 95697
95557: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95558: LD_ADDR_VAR 0 1
95562: PUSH
95563: LD_INT 2
95565: PUSH
95566: LD_INT 4
95568: PUSH
95569: LD_INT 5
95571: PUSH
95572: LD_INT 6
95574: PUSH
95575: LD_INT 7
95577: PUSH
95578: LD_INT 8
95580: PUSH
95581: LD_INT 11
95583: PUSH
95584: LD_INT 12
95586: PUSH
95587: LD_INT 15
95589: PUSH
95590: LD_INT 16
95592: PUSH
95593: LD_INT 20
95595: PUSH
95596: LD_INT 21
95598: PUSH
95599: LD_INT 22
95601: PUSH
95602: LD_INT 23
95604: PUSH
95605: LD_INT 25
95607: PUSH
95608: LD_INT 26
95610: PUSH
95611: LD_INT 30
95613: PUSH
95614: LD_INT 31
95616: PUSH
95617: LD_INT 32
95619: PUSH
95620: LD_INT 36
95622: PUSH
95623: EMPTY
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: PUSH
95645: LD_INT 101
95647: PUSH
95648: LD_INT 102
95650: PUSH
95651: LD_INT 103
95653: PUSH
95654: LD_INT 105
95656: PUSH
95657: LD_INT 106
95659: PUSH
95660: LD_INT 108
95662: PUSH
95663: LD_INT 109
95665: PUSH
95666: LD_INT 112
95668: PUSH
95669: LD_INT 116
95671: PUSH
95672: LD_INT 117
95674: PUSH
95675: LD_INT 118
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: ST_TO_ADDR
95695: GO 97950
95697: LD_INT 9
95699: DOUBLE
95700: EQUAL
95701: IFTRUE 95705
95703: GO 95853
95705: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95706: LD_ADDR_VAR 0 1
95710: PUSH
95711: LD_INT 2
95713: PUSH
95714: LD_INT 4
95716: PUSH
95717: LD_INT 5
95719: PUSH
95720: LD_INT 6
95722: PUSH
95723: LD_INT 7
95725: PUSH
95726: LD_INT 8
95728: PUSH
95729: LD_INT 11
95731: PUSH
95732: LD_INT 12
95734: PUSH
95735: LD_INT 15
95737: PUSH
95738: LD_INT 16
95740: PUSH
95741: LD_INT 20
95743: PUSH
95744: LD_INT 21
95746: PUSH
95747: LD_INT 22
95749: PUSH
95750: LD_INT 23
95752: PUSH
95753: LD_INT 25
95755: PUSH
95756: LD_INT 26
95758: PUSH
95759: LD_INT 28
95761: PUSH
95762: LD_INT 30
95764: PUSH
95765: LD_INT 31
95767: PUSH
95768: LD_INT 32
95770: PUSH
95771: LD_INT 36
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: LIST
95786: LIST
95787: LIST
95788: LIST
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: PUSH
95797: LD_INT 101
95799: PUSH
95800: LD_INT 102
95802: PUSH
95803: LD_INT 103
95805: PUSH
95806: LD_INT 105
95808: PUSH
95809: LD_INT 106
95811: PUSH
95812: LD_INT 108
95814: PUSH
95815: LD_INT 109
95817: PUSH
95818: LD_INT 112
95820: PUSH
95821: LD_INT 114
95823: PUSH
95824: LD_INT 116
95826: PUSH
95827: LD_INT 117
95829: PUSH
95830: LD_INT 118
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: LIST
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: ST_TO_ADDR
95851: GO 97950
95853: LD_INT 10
95855: DOUBLE
95856: EQUAL
95857: IFTRUE 95861
95859: GO 96057
95861: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
95862: LD_ADDR_VAR 0 1
95866: PUSH
95867: LD_INT 2
95869: PUSH
95870: LD_INT 4
95872: PUSH
95873: LD_INT 5
95875: PUSH
95876: LD_INT 6
95878: PUSH
95879: LD_INT 7
95881: PUSH
95882: LD_INT 8
95884: PUSH
95885: LD_INT 9
95887: PUSH
95888: LD_INT 10
95890: PUSH
95891: LD_INT 11
95893: PUSH
95894: LD_INT 12
95896: PUSH
95897: LD_INT 13
95899: PUSH
95900: LD_INT 14
95902: PUSH
95903: LD_INT 15
95905: PUSH
95906: LD_INT 16
95908: PUSH
95909: LD_INT 17
95911: PUSH
95912: LD_INT 18
95914: PUSH
95915: LD_INT 19
95917: PUSH
95918: LD_INT 20
95920: PUSH
95921: LD_INT 21
95923: PUSH
95924: LD_INT 22
95926: PUSH
95927: LD_INT 23
95929: PUSH
95930: LD_INT 24
95932: PUSH
95933: LD_INT 25
95935: PUSH
95936: LD_INT 26
95938: PUSH
95939: LD_INT 28
95941: PUSH
95942: LD_INT 30
95944: PUSH
95945: LD_INT 31
95947: PUSH
95948: LD_INT 32
95950: PUSH
95951: LD_INT 36
95953: PUSH
95954: EMPTY
95955: LIST
95956: LIST
95957: LIST
95958: LIST
95959: LIST
95960: LIST
95961: LIST
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: PUSH
95985: LD_INT 101
95987: PUSH
95988: LD_INT 102
95990: PUSH
95991: LD_INT 103
95993: PUSH
95994: LD_INT 104
95996: PUSH
95997: LD_INT 105
95999: PUSH
96000: LD_INT 106
96002: PUSH
96003: LD_INT 107
96005: PUSH
96006: LD_INT 108
96008: PUSH
96009: LD_INT 109
96011: PUSH
96012: LD_INT 110
96014: PUSH
96015: LD_INT 111
96017: PUSH
96018: LD_INT 112
96020: PUSH
96021: LD_INT 114
96023: PUSH
96024: LD_INT 116
96026: PUSH
96027: LD_INT 117
96029: PUSH
96030: LD_INT 118
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: PUSH
96051: EMPTY
96052: LIST
96053: LIST
96054: ST_TO_ADDR
96055: GO 97950
96057: LD_INT 11
96059: DOUBLE
96060: EQUAL
96061: IFTRUE 96065
96063: GO 96269
96065: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
96066: LD_ADDR_VAR 0 1
96070: PUSH
96071: LD_INT 2
96073: PUSH
96074: LD_INT 3
96076: PUSH
96077: LD_INT 4
96079: PUSH
96080: LD_INT 5
96082: PUSH
96083: LD_INT 6
96085: PUSH
96086: LD_INT 7
96088: PUSH
96089: LD_INT 8
96091: PUSH
96092: LD_INT 9
96094: PUSH
96095: LD_INT 10
96097: PUSH
96098: LD_INT 11
96100: PUSH
96101: LD_INT 12
96103: PUSH
96104: LD_INT 13
96106: PUSH
96107: LD_INT 14
96109: PUSH
96110: LD_INT 15
96112: PUSH
96113: LD_INT 16
96115: PUSH
96116: LD_INT 17
96118: PUSH
96119: LD_INT 18
96121: PUSH
96122: LD_INT 19
96124: PUSH
96125: LD_INT 20
96127: PUSH
96128: LD_INT 21
96130: PUSH
96131: LD_INT 22
96133: PUSH
96134: LD_INT 23
96136: PUSH
96137: LD_INT 24
96139: PUSH
96140: LD_INT 25
96142: PUSH
96143: LD_INT 26
96145: PUSH
96146: LD_INT 28
96148: PUSH
96149: LD_INT 30
96151: PUSH
96152: LD_INT 31
96154: PUSH
96155: LD_INT 32
96157: PUSH
96158: LD_INT 34
96160: PUSH
96161: LD_INT 36
96163: PUSH
96164: EMPTY
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: LIST
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: PUSH
96197: LD_INT 101
96199: PUSH
96200: LD_INT 102
96202: PUSH
96203: LD_INT 103
96205: PUSH
96206: LD_INT 104
96208: PUSH
96209: LD_INT 105
96211: PUSH
96212: LD_INT 106
96214: PUSH
96215: LD_INT 107
96217: PUSH
96218: LD_INT 108
96220: PUSH
96221: LD_INT 109
96223: PUSH
96224: LD_INT 110
96226: PUSH
96227: LD_INT 111
96229: PUSH
96230: LD_INT 112
96232: PUSH
96233: LD_INT 114
96235: PUSH
96236: LD_INT 116
96238: PUSH
96239: LD_INT 117
96241: PUSH
96242: LD_INT 118
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: LIST
96249: LIST
96250: LIST
96251: LIST
96252: LIST
96253: LIST
96254: LIST
96255: LIST
96256: LIST
96257: LIST
96258: LIST
96259: LIST
96260: LIST
96261: LIST
96262: PUSH
96263: EMPTY
96264: LIST
96265: LIST
96266: ST_TO_ADDR
96267: GO 97950
96269: LD_INT 12
96271: DOUBLE
96272: EQUAL
96273: IFTRUE 96277
96275: GO 96497
96277: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
96278: LD_ADDR_VAR 0 1
96282: PUSH
96283: LD_INT 1
96285: PUSH
96286: LD_INT 2
96288: PUSH
96289: LD_INT 3
96291: PUSH
96292: LD_INT 4
96294: PUSH
96295: LD_INT 5
96297: PUSH
96298: LD_INT 6
96300: PUSH
96301: LD_INT 7
96303: PUSH
96304: LD_INT 8
96306: PUSH
96307: LD_INT 9
96309: PUSH
96310: LD_INT 10
96312: PUSH
96313: LD_INT 11
96315: PUSH
96316: LD_INT 12
96318: PUSH
96319: LD_INT 13
96321: PUSH
96322: LD_INT 14
96324: PUSH
96325: LD_INT 15
96327: PUSH
96328: LD_INT 16
96330: PUSH
96331: LD_INT 17
96333: PUSH
96334: LD_INT 18
96336: PUSH
96337: LD_INT 19
96339: PUSH
96340: LD_INT 20
96342: PUSH
96343: LD_INT 21
96345: PUSH
96346: LD_INT 22
96348: PUSH
96349: LD_INT 23
96351: PUSH
96352: LD_INT 24
96354: PUSH
96355: LD_INT 25
96357: PUSH
96358: LD_INT 26
96360: PUSH
96361: LD_INT 27
96363: PUSH
96364: LD_INT 28
96366: PUSH
96367: LD_INT 30
96369: PUSH
96370: LD_INT 31
96372: PUSH
96373: LD_INT 32
96375: PUSH
96376: LD_INT 33
96378: PUSH
96379: LD_INT 34
96381: PUSH
96382: LD_INT 36
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: PUSH
96421: LD_INT 101
96423: PUSH
96424: LD_INT 102
96426: PUSH
96427: LD_INT 103
96429: PUSH
96430: LD_INT 104
96432: PUSH
96433: LD_INT 105
96435: PUSH
96436: LD_INT 106
96438: PUSH
96439: LD_INT 107
96441: PUSH
96442: LD_INT 108
96444: PUSH
96445: LD_INT 109
96447: PUSH
96448: LD_INT 110
96450: PUSH
96451: LD_INT 111
96453: PUSH
96454: LD_INT 112
96456: PUSH
96457: LD_INT 113
96459: PUSH
96460: LD_INT 114
96462: PUSH
96463: LD_INT 116
96465: PUSH
96466: LD_INT 117
96468: PUSH
96469: LD_INT 118
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: PUSH
96491: EMPTY
96492: LIST
96493: LIST
96494: ST_TO_ADDR
96495: GO 97950
96497: LD_INT 13
96499: DOUBLE
96500: EQUAL
96501: IFTRUE 96505
96503: GO 96713
96505: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96506: LD_ADDR_VAR 0 1
96510: PUSH
96511: LD_INT 1
96513: PUSH
96514: LD_INT 2
96516: PUSH
96517: LD_INT 3
96519: PUSH
96520: LD_INT 4
96522: PUSH
96523: LD_INT 5
96525: PUSH
96526: LD_INT 8
96528: PUSH
96529: LD_INT 9
96531: PUSH
96532: LD_INT 10
96534: PUSH
96535: LD_INT 11
96537: PUSH
96538: LD_INT 12
96540: PUSH
96541: LD_INT 14
96543: PUSH
96544: LD_INT 15
96546: PUSH
96547: LD_INT 16
96549: PUSH
96550: LD_INT 17
96552: PUSH
96553: LD_INT 18
96555: PUSH
96556: LD_INT 19
96558: PUSH
96559: LD_INT 20
96561: PUSH
96562: LD_INT 21
96564: PUSH
96565: LD_INT 22
96567: PUSH
96568: LD_INT 23
96570: PUSH
96571: LD_INT 24
96573: PUSH
96574: LD_INT 25
96576: PUSH
96577: LD_INT 26
96579: PUSH
96580: LD_INT 27
96582: PUSH
96583: LD_INT 28
96585: PUSH
96586: LD_INT 30
96588: PUSH
96589: LD_INT 31
96591: PUSH
96592: LD_INT 32
96594: PUSH
96595: LD_INT 33
96597: PUSH
96598: LD_INT 34
96600: PUSH
96601: LD_INT 36
96603: PUSH
96604: EMPTY
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: LIST
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: LIST
96635: LIST
96636: PUSH
96637: LD_INT 101
96639: PUSH
96640: LD_INT 102
96642: PUSH
96643: LD_INT 103
96645: PUSH
96646: LD_INT 104
96648: PUSH
96649: LD_INT 105
96651: PUSH
96652: LD_INT 106
96654: PUSH
96655: LD_INT 107
96657: PUSH
96658: LD_INT 108
96660: PUSH
96661: LD_INT 109
96663: PUSH
96664: LD_INT 110
96666: PUSH
96667: LD_INT 111
96669: PUSH
96670: LD_INT 112
96672: PUSH
96673: LD_INT 113
96675: PUSH
96676: LD_INT 114
96678: PUSH
96679: LD_INT 116
96681: PUSH
96682: LD_INT 117
96684: PUSH
96685: LD_INT 118
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: PUSH
96707: EMPTY
96708: LIST
96709: LIST
96710: ST_TO_ADDR
96711: GO 97950
96713: LD_INT 14
96715: DOUBLE
96716: EQUAL
96717: IFTRUE 96721
96719: GO 96945
96721: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
96722: LD_ADDR_VAR 0 1
96726: PUSH
96727: LD_INT 1
96729: PUSH
96730: LD_INT 2
96732: PUSH
96733: LD_INT 3
96735: PUSH
96736: LD_INT 4
96738: PUSH
96739: LD_INT 5
96741: PUSH
96742: LD_INT 6
96744: PUSH
96745: LD_INT 7
96747: PUSH
96748: LD_INT 8
96750: PUSH
96751: LD_INT 9
96753: PUSH
96754: LD_INT 10
96756: PUSH
96757: LD_INT 11
96759: PUSH
96760: LD_INT 12
96762: PUSH
96763: LD_INT 13
96765: PUSH
96766: LD_INT 14
96768: PUSH
96769: LD_INT 15
96771: PUSH
96772: LD_INT 16
96774: PUSH
96775: LD_INT 17
96777: PUSH
96778: LD_INT 18
96780: PUSH
96781: LD_INT 19
96783: PUSH
96784: LD_INT 20
96786: PUSH
96787: LD_INT 21
96789: PUSH
96790: LD_INT 22
96792: PUSH
96793: LD_INT 23
96795: PUSH
96796: LD_INT 24
96798: PUSH
96799: LD_INT 25
96801: PUSH
96802: LD_INT 26
96804: PUSH
96805: LD_INT 27
96807: PUSH
96808: LD_INT 28
96810: PUSH
96811: LD_INT 29
96813: PUSH
96814: LD_INT 30
96816: PUSH
96817: LD_INT 31
96819: PUSH
96820: LD_INT 32
96822: PUSH
96823: LD_INT 33
96825: PUSH
96826: LD_INT 34
96828: PUSH
96829: LD_INT 36
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: LIST
96836: LIST
96837: LIST
96838: LIST
96839: LIST
96840: LIST
96841: LIST
96842: LIST
96843: LIST
96844: LIST
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: LIST
96867: LIST
96868: PUSH
96869: LD_INT 101
96871: PUSH
96872: LD_INT 102
96874: PUSH
96875: LD_INT 103
96877: PUSH
96878: LD_INT 104
96880: PUSH
96881: LD_INT 105
96883: PUSH
96884: LD_INT 106
96886: PUSH
96887: LD_INT 107
96889: PUSH
96890: LD_INT 108
96892: PUSH
96893: LD_INT 109
96895: PUSH
96896: LD_INT 110
96898: PUSH
96899: LD_INT 111
96901: PUSH
96902: LD_INT 112
96904: PUSH
96905: LD_INT 113
96907: PUSH
96908: LD_INT 114
96910: PUSH
96911: LD_INT 116
96913: PUSH
96914: LD_INT 117
96916: PUSH
96917: LD_INT 118
96919: PUSH
96920: EMPTY
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: ST_TO_ADDR
96943: GO 97950
96945: LD_INT 15
96947: DOUBLE
96948: EQUAL
96949: IFTRUE 96953
96951: GO 97177
96953: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96954: LD_ADDR_VAR 0 1
96958: PUSH
96959: LD_INT 1
96961: PUSH
96962: LD_INT 2
96964: PUSH
96965: LD_INT 3
96967: PUSH
96968: LD_INT 4
96970: PUSH
96971: LD_INT 5
96973: PUSH
96974: LD_INT 6
96976: PUSH
96977: LD_INT 7
96979: PUSH
96980: LD_INT 8
96982: PUSH
96983: LD_INT 9
96985: PUSH
96986: LD_INT 10
96988: PUSH
96989: LD_INT 11
96991: PUSH
96992: LD_INT 12
96994: PUSH
96995: LD_INT 13
96997: PUSH
96998: LD_INT 14
97000: PUSH
97001: LD_INT 15
97003: PUSH
97004: LD_INT 16
97006: PUSH
97007: LD_INT 17
97009: PUSH
97010: LD_INT 18
97012: PUSH
97013: LD_INT 19
97015: PUSH
97016: LD_INT 20
97018: PUSH
97019: LD_INT 21
97021: PUSH
97022: LD_INT 22
97024: PUSH
97025: LD_INT 23
97027: PUSH
97028: LD_INT 24
97030: PUSH
97031: LD_INT 25
97033: PUSH
97034: LD_INT 26
97036: PUSH
97037: LD_INT 27
97039: PUSH
97040: LD_INT 28
97042: PUSH
97043: LD_INT 29
97045: PUSH
97046: LD_INT 30
97048: PUSH
97049: LD_INT 31
97051: PUSH
97052: LD_INT 32
97054: PUSH
97055: LD_INT 33
97057: PUSH
97058: LD_INT 34
97060: PUSH
97061: LD_INT 36
97063: PUSH
97064: EMPTY
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: LIST
97073: LIST
97074: LIST
97075: LIST
97076: LIST
97077: LIST
97078: LIST
97079: LIST
97080: LIST
97081: LIST
97082: LIST
97083: LIST
97084: LIST
97085: LIST
97086: LIST
97087: LIST
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: PUSH
97101: LD_INT 101
97103: PUSH
97104: LD_INT 102
97106: PUSH
97107: LD_INT 103
97109: PUSH
97110: LD_INT 104
97112: PUSH
97113: LD_INT 105
97115: PUSH
97116: LD_INT 106
97118: PUSH
97119: LD_INT 107
97121: PUSH
97122: LD_INT 108
97124: PUSH
97125: LD_INT 109
97127: PUSH
97128: LD_INT 110
97130: PUSH
97131: LD_INT 111
97133: PUSH
97134: LD_INT 112
97136: PUSH
97137: LD_INT 113
97139: PUSH
97140: LD_INT 114
97142: PUSH
97143: LD_INT 116
97145: PUSH
97146: LD_INT 117
97148: PUSH
97149: LD_INT 118
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: ST_TO_ADDR
97175: GO 97950
97177: LD_INT 16
97179: DOUBLE
97180: EQUAL
97181: IFTRUE 97185
97183: GO 97321
97185: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
97186: LD_ADDR_VAR 0 1
97190: PUSH
97191: LD_INT 2
97193: PUSH
97194: LD_INT 4
97196: PUSH
97197: LD_INT 5
97199: PUSH
97200: LD_INT 7
97202: PUSH
97203: LD_INT 11
97205: PUSH
97206: LD_INT 12
97208: PUSH
97209: LD_INT 15
97211: PUSH
97212: LD_INT 16
97214: PUSH
97215: LD_INT 20
97217: PUSH
97218: LD_INT 21
97220: PUSH
97221: LD_INT 22
97223: PUSH
97224: LD_INT 23
97226: PUSH
97227: LD_INT 25
97229: PUSH
97230: LD_INT 26
97232: PUSH
97233: LD_INT 30
97235: PUSH
97236: LD_INT 31
97238: PUSH
97239: LD_INT 32
97241: PUSH
97242: LD_INT 33
97244: PUSH
97245: LD_INT 34
97247: PUSH
97248: EMPTY
97249: LIST
97250: LIST
97251: LIST
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: PUSH
97269: LD_INT 101
97271: PUSH
97272: LD_INT 102
97274: PUSH
97275: LD_INT 103
97277: PUSH
97278: LD_INT 106
97280: PUSH
97281: LD_INT 108
97283: PUSH
97284: LD_INT 112
97286: PUSH
97287: LD_INT 113
97289: PUSH
97290: LD_INT 114
97292: PUSH
97293: LD_INT 116
97295: PUSH
97296: LD_INT 117
97298: PUSH
97299: LD_INT 118
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: PUSH
97315: EMPTY
97316: LIST
97317: LIST
97318: ST_TO_ADDR
97319: GO 97950
97321: LD_INT 17
97323: DOUBLE
97324: EQUAL
97325: IFTRUE 97329
97327: GO 97553
97329: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97330: LD_ADDR_VAR 0 1
97334: PUSH
97335: LD_INT 1
97337: PUSH
97338: LD_INT 2
97340: PUSH
97341: LD_INT 3
97343: PUSH
97344: LD_INT 4
97346: PUSH
97347: LD_INT 5
97349: PUSH
97350: LD_INT 6
97352: PUSH
97353: LD_INT 7
97355: PUSH
97356: LD_INT 8
97358: PUSH
97359: LD_INT 9
97361: PUSH
97362: LD_INT 10
97364: PUSH
97365: LD_INT 11
97367: PUSH
97368: LD_INT 12
97370: PUSH
97371: LD_INT 13
97373: PUSH
97374: LD_INT 14
97376: PUSH
97377: LD_INT 15
97379: PUSH
97380: LD_INT 16
97382: PUSH
97383: LD_INT 17
97385: PUSH
97386: LD_INT 18
97388: PUSH
97389: LD_INT 19
97391: PUSH
97392: LD_INT 20
97394: PUSH
97395: LD_INT 21
97397: PUSH
97398: LD_INT 22
97400: PUSH
97401: LD_INT 23
97403: PUSH
97404: LD_INT 24
97406: PUSH
97407: LD_INT 25
97409: PUSH
97410: LD_INT 26
97412: PUSH
97413: LD_INT 27
97415: PUSH
97416: LD_INT 28
97418: PUSH
97419: LD_INT 29
97421: PUSH
97422: LD_INT 30
97424: PUSH
97425: LD_INT 31
97427: PUSH
97428: LD_INT 32
97430: PUSH
97431: LD_INT 33
97433: PUSH
97434: LD_INT 34
97436: PUSH
97437: LD_INT 36
97439: PUSH
97440: EMPTY
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: LIST
97455: LIST
97456: LIST
97457: LIST
97458: LIST
97459: LIST
97460: LIST
97461: LIST
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: PUSH
97477: LD_INT 101
97479: PUSH
97480: LD_INT 102
97482: PUSH
97483: LD_INT 103
97485: PUSH
97486: LD_INT 104
97488: PUSH
97489: LD_INT 105
97491: PUSH
97492: LD_INT 106
97494: PUSH
97495: LD_INT 107
97497: PUSH
97498: LD_INT 108
97500: PUSH
97501: LD_INT 109
97503: PUSH
97504: LD_INT 110
97506: PUSH
97507: LD_INT 111
97509: PUSH
97510: LD_INT 112
97512: PUSH
97513: LD_INT 113
97515: PUSH
97516: LD_INT 114
97518: PUSH
97519: LD_INT 116
97521: PUSH
97522: LD_INT 117
97524: PUSH
97525: LD_INT 118
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: LIST
97532: LIST
97533: LIST
97534: LIST
97535: LIST
97536: LIST
97537: LIST
97538: LIST
97539: LIST
97540: LIST
97541: LIST
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: PUSH
97547: EMPTY
97548: LIST
97549: LIST
97550: ST_TO_ADDR
97551: GO 97950
97553: LD_INT 18
97555: DOUBLE
97556: EQUAL
97557: IFTRUE 97561
97559: GO 97709
97561: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97562: LD_ADDR_VAR 0 1
97566: PUSH
97567: LD_INT 2
97569: PUSH
97570: LD_INT 4
97572: PUSH
97573: LD_INT 5
97575: PUSH
97576: LD_INT 7
97578: PUSH
97579: LD_INT 11
97581: PUSH
97582: LD_INT 12
97584: PUSH
97585: LD_INT 15
97587: PUSH
97588: LD_INT 16
97590: PUSH
97591: LD_INT 20
97593: PUSH
97594: LD_INT 21
97596: PUSH
97597: LD_INT 22
97599: PUSH
97600: LD_INT 23
97602: PUSH
97603: LD_INT 25
97605: PUSH
97606: LD_INT 26
97608: PUSH
97609: LD_INT 30
97611: PUSH
97612: LD_INT 31
97614: PUSH
97615: LD_INT 32
97617: PUSH
97618: LD_INT 33
97620: PUSH
97621: LD_INT 34
97623: PUSH
97624: LD_INT 35
97626: PUSH
97627: LD_INT 36
97629: PUSH
97630: EMPTY
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: LIST
97639: LIST
97640: LIST
97641: LIST
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: LIST
97652: PUSH
97653: LD_INT 101
97655: PUSH
97656: LD_INT 102
97658: PUSH
97659: LD_INT 103
97661: PUSH
97662: LD_INT 106
97664: PUSH
97665: LD_INT 108
97667: PUSH
97668: LD_INT 112
97670: PUSH
97671: LD_INT 113
97673: PUSH
97674: LD_INT 114
97676: PUSH
97677: LD_INT 115
97679: PUSH
97680: LD_INT 116
97682: PUSH
97683: LD_INT 117
97685: PUSH
97686: LD_INT 118
97688: PUSH
97689: EMPTY
97690: LIST
97691: LIST
97692: LIST
97693: LIST
97694: LIST
97695: LIST
97696: LIST
97697: LIST
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: PUSH
97703: EMPTY
97704: LIST
97705: LIST
97706: ST_TO_ADDR
97707: GO 97950
97709: LD_INT 19
97711: DOUBLE
97712: EQUAL
97713: IFTRUE 97717
97715: GO 97949
97717: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
97718: LD_ADDR_VAR 0 1
97722: PUSH
97723: LD_INT 1
97725: PUSH
97726: LD_INT 2
97728: PUSH
97729: LD_INT 3
97731: PUSH
97732: LD_INT 4
97734: PUSH
97735: LD_INT 5
97737: PUSH
97738: LD_INT 6
97740: PUSH
97741: LD_INT 7
97743: PUSH
97744: LD_INT 8
97746: PUSH
97747: LD_INT 9
97749: PUSH
97750: LD_INT 10
97752: PUSH
97753: LD_INT 11
97755: PUSH
97756: LD_INT 12
97758: PUSH
97759: LD_INT 13
97761: PUSH
97762: LD_INT 14
97764: PUSH
97765: LD_INT 15
97767: PUSH
97768: LD_INT 16
97770: PUSH
97771: LD_INT 17
97773: PUSH
97774: LD_INT 18
97776: PUSH
97777: LD_INT 19
97779: PUSH
97780: LD_INT 20
97782: PUSH
97783: LD_INT 21
97785: PUSH
97786: LD_INT 22
97788: PUSH
97789: LD_INT 23
97791: PUSH
97792: LD_INT 24
97794: PUSH
97795: LD_INT 25
97797: PUSH
97798: LD_INT 26
97800: PUSH
97801: LD_INT 27
97803: PUSH
97804: LD_INT 28
97806: PUSH
97807: LD_INT 29
97809: PUSH
97810: LD_INT 30
97812: PUSH
97813: LD_INT 31
97815: PUSH
97816: LD_INT 32
97818: PUSH
97819: LD_INT 33
97821: PUSH
97822: LD_INT 34
97824: PUSH
97825: LD_INT 35
97827: PUSH
97828: LD_INT 36
97830: PUSH
97831: EMPTY
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: PUSH
97869: LD_INT 101
97871: PUSH
97872: LD_INT 102
97874: PUSH
97875: LD_INT 103
97877: PUSH
97878: LD_INT 104
97880: PUSH
97881: LD_INT 105
97883: PUSH
97884: LD_INT 106
97886: PUSH
97887: LD_INT 107
97889: PUSH
97890: LD_INT 108
97892: PUSH
97893: LD_INT 109
97895: PUSH
97896: LD_INT 110
97898: PUSH
97899: LD_INT 111
97901: PUSH
97902: LD_INT 112
97904: PUSH
97905: LD_INT 113
97907: PUSH
97908: LD_INT 114
97910: PUSH
97911: LD_INT 115
97913: PUSH
97914: LD_INT 116
97916: PUSH
97917: LD_INT 117
97919: PUSH
97920: LD_INT 118
97922: PUSH
97923: EMPTY
97924: LIST
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: LIST
97942: PUSH
97943: EMPTY
97944: LIST
97945: LIST
97946: ST_TO_ADDR
97947: GO 97950
97949: POP
// end else
97950: GO 98181
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97952: LD_ADDR_VAR 0 1
97956: PUSH
97957: LD_INT 1
97959: PUSH
97960: LD_INT 2
97962: PUSH
97963: LD_INT 3
97965: PUSH
97966: LD_INT 4
97968: PUSH
97969: LD_INT 5
97971: PUSH
97972: LD_INT 6
97974: PUSH
97975: LD_INT 7
97977: PUSH
97978: LD_INT 8
97980: PUSH
97981: LD_INT 9
97983: PUSH
97984: LD_INT 10
97986: PUSH
97987: LD_INT 11
97989: PUSH
97990: LD_INT 12
97992: PUSH
97993: LD_INT 13
97995: PUSH
97996: LD_INT 14
97998: PUSH
97999: LD_INT 15
98001: PUSH
98002: LD_INT 16
98004: PUSH
98005: LD_INT 17
98007: PUSH
98008: LD_INT 18
98010: PUSH
98011: LD_INT 19
98013: PUSH
98014: LD_INT 20
98016: PUSH
98017: LD_INT 21
98019: PUSH
98020: LD_INT 22
98022: PUSH
98023: LD_INT 23
98025: PUSH
98026: LD_INT 24
98028: PUSH
98029: LD_INT 25
98031: PUSH
98032: LD_INT 26
98034: PUSH
98035: LD_INT 27
98037: PUSH
98038: LD_INT 28
98040: PUSH
98041: LD_INT 29
98043: PUSH
98044: LD_INT 30
98046: PUSH
98047: LD_INT 31
98049: PUSH
98050: LD_INT 32
98052: PUSH
98053: LD_INT 33
98055: PUSH
98056: LD_INT 34
98058: PUSH
98059: LD_INT 35
98061: PUSH
98062: LD_INT 36
98064: PUSH
98065: EMPTY
98066: LIST
98067: LIST
98068: LIST
98069: LIST
98070: LIST
98071: LIST
98072: LIST
98073: LIST
98074: LIST
98075: LIST
98076: LIST
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: LIST
98082: LIST
98083: LIST
98084: LIST
98085: LIST
98086: LIST
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: PUSH
98103: LD_INT 101
98105: PUSH
98106: LD_INT 102
98108: PUSH
98109: LD_INT 103
98111: PUSH
98112: LD_INT 104
98114: PUSH
98115: LD_INT 105
98117: PUSH
98118: LD_INT 106
98120: PUSH
98121: LD_INT 107
98123: PUSH
98124: LD_INT 108
98126: PUSH
98127: LD_INT 109
98129: PUSH
98130: LD_INT 110
98132: PUSH
98133: LD_INT 111
98135: PUSH
98136: LD_INT 112
98138: PUSH
98139: LD_INT 113
98141: PUSH
98142: LD_INT 114
98144: PUSH
98145: LD_INT 115
98147: PUSH
98148: LD_INT 116
98150: PUSH
98151: LD_INT 117
98153: PUSH
98154: LD_INT 118
98156: PUSH
98157: EMPTY
98158: LIST
98159: LIST
98160: LIST
98161: LIST
98162: LIST
98163: LIST
98164: LIST
98165: LIST
98166: LIST
98167: LIST
98168: LIST
98169: LIST
98170: LIST
98171: LIST
98172: LIST
98173: LIST
98174: LIST
98175: LIST
98176: PUSH
98177: EMPTY
98178: LIST
98179: LIST
98180: ST_TO_ADDR
// if result then
98181: LD_VAR 0 1
98185: IFFALSE 98474
// begin normal :=  ;
98187: LD_ADDR_VAR 0 3
98191: PUSH
98192: LD_STRING 
98194: ST_TO_ADDR
// hardcore :=  ;
98195: LD_ADDR_VAR 0 4
98199: PUSH
98200: LD_STRING 
98202: ST_TO_ADDR
// for i = 1 to normalCounter do
98203: LD_ADDR_VAR 0 5
98207: PUSH
98208: DOUBLE
98209: LD_INT 1
98211: DEC
98212: ST_TO_ADDR
98213: LD_EXP 99
98217: PUSH
98218: FOR_TO
98219: IFFALSE 98320
// begin tmp := 0 ;
98221: LD_ADDR_VAR 0 2
98225: PUSH
98226: LD_STRING 0
98228: ST_TO_ADDR
// if result [ 1 ] then
98229: LD_VAR 0 1
98233: PUSH
98234: LD_INT 1
98236: ARRAY
98237: IFFALSE 98302
// if result [ 1 ] [ 1 ] = i then
98239: LD_VAR 0 1
98243: PUSH
98244: LD_INT 1
98246: ARRAY
98247: PUSH
98248: LD_INT 1
98250: ARRAY
98251: PUSH
98252: LD_VAR 0 5
98256: EQUAL
98257: IFFALSE 98302
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
98259: LD_ADDR_VAR 0 1
98263: PUSH
98264: LD_VAR 0 1
98268: PPUSH
98269: LD_INT 1
98271: PPUSH
98272: LD_VAR 0 1
98276: PUSH
98277: LD_INT 1
98279: ARRAY
98280: PPUSH
98281: LD_INT 1
98283: PPUSH
98284: CALL_OW 3
98288: PPUSH
98289: CALL_OW 1
98293: ST_TO_ADDR
// tmp := 1 ;
98294: LD_ADDR_VAR 0 2
98298: PUSH
98299: LD_STRING 1
98301: ST_TO_ADDR
// end ; normal := normal & tmp ;
98302: LD_ADDR_VAR 0 3
98306: PUSH
98307: LD_VAR 0 3
98311: PUSH
98312: LD_VAR 0 2
98316: STR
98317: ST_TO_ADDR
// end ;
98318: GO 98218
98320: POP
98321: POP
// for i = 1 to hardcoreCounter do
98322: LD_ADDR_VAR 0 5
98326: PUSH
98327: DOUBLE
98328: LD_INT 1
98330: DEC
98331: ST_TO_ADDR
98332: LD_EXP 100
98336: PUSH
98337: FOR_TO
98338: IFFALSE 98443
// begin tmp := 0 ;
98340: LD_ADDR_VAR 0 2
98344: PUSH
98345: LD_STRING 0
98347: ST_TO_ADDR
// if result [ 2 ] then
98348: LD_VAR 0 1
98352: PUSH
98353: LD_INT 2
98355: ARRAY
98356: IFFALSE 98425
// if result [ 2 ] [ 1 ] = 100 + i then
98358: LD_VAR 0 1
98362: PUSH
98363: LD_INT 2
98365: ARRAY
98366: PUSH
98367: LD_INT 1
98369: ARRAY
98370: PUSH
98371: LD_INT 100
98373: PUSH
98374: LD_VAR 0 5
98378: PLUS
98379: EQUAL
98380: IFFALSE 98425
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98382: LD_ADDR_VAR 0 1
98386: PUSH
98387: LD_VAR 0 1
98391: PPUSH
98392: LD_INT 2
98394: PPUSH
98395: LD_VAR 0 1
98399: PUSH
98400: LD_INT 2
98402: ARRAY
98403: PPUSH
98404: LD_INT 1
98406: PPUSH
98407: CALL_OW 3
98411: PPUSH
98412: CALL_OW 1
98416: ST_TO_ADDR
// tmp := 1 ;
98417: LD_ADDR_VAR 0 2
98421: PUSH
98422: LD_STRING 1
98424: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98425: LD_ADDR_VAR 0 4
98429: PUSH
98430: LD_VAR 0 4
98434: PUSH
98435: LD_VAR 0 2
98439: STR
98440: ST_TO_ADDR
// end ;
98441: GO 98337
98443: POP
98444: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
98445: LD_STRING getStreamItemsFromMission("
98447: PUSH
98448: LD_VAR 0 3
98452: STR
98453: PUSH
98454: LD_STRING ","
98456: STR
98457: PUSH
98458: LD_VAR 0 4
98462: STR
98463: PUSH
98464: LD_STRING ")
98466: STR
98467: PPUSH
98468: CALL_OW 559
// end else
98472: GO 98481
// ToLua ( getStreamItemsFromMission("","") ) ;
98474: LD_STRING getStreamItemsFromMission("","")
98476: PPUSH
98477: CALL_OW 559
// end ;
98481: LD_VAR 0 1
98485: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98486: LD_EXP 98
98490: PUSH
98491: LD_EXP 103
98495: AND
98496: IFFALSE 98620
98498: GO 98500
98500: DISABLE
98501: LD_INT 0
98503: PPUSH
98504: PPUSH
// begin enable ;
98505: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98506: LD_ADDR_VAR 0 2
98510: PUSH
98511: LD_INT 22
98513: PUSH
98514: LD_OWVAR 2
98518: PUSH
98519: EMPTY
98520: LIST
98521: LIST
98522: PUSH
98523: LD_INT 2
98525: PUSH
98526: LD_INT 34
98528: PUSH
98529: LD_INT 7
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: LD_INT 34
98538: PUSH
98539: LD_INT 45
98541: PUSH
98542: EMPTY
98543: LIST
98544: LIST
98545: PUSH
98546: LD_INT 34
98548: PUSH
98549: LD_INT 28
98551: PUSH
98552: EMPTY
98553: LIST
98554: LIST
98555: PUSH
98556: LD_INT 34
98558: PUSH
98559: LD_INT 47
98561: PUSH
98562: EMPTY
98563: LIST
98564: LIST
98565: PUSH
98566: EMPTY
98567: LIST
98568: LIST
98569: LIST
98570: LIST
98571: LIST
98572: PUSH
98573: EMPTY
98574: LIST
98575: LIST
98576: PPUSH
98577: CALL_OW 69
98581: ST_TO_ADDR
// if not tmp then
98582: LD_VAR 0 2
98586: NOT
98587: IFFALSE 98591
// exit ;
98589: GO 98620
// for i in tmp do
98591: LD_ADDR_VAR 0 1
98595: PUSH
98596: LD_VAR 0 2
98600: PUSH
98601: FOR_IN
98602: IFFALSE 98618
// begin SetLives ( i , 0 ) ;
98604: LD_VAR 0 1
98608: PPUSH
98609: LD_INT 0
98611: PPUSH
98612: CALL_OW 234
// end ;
98616: GO 98601
98618: POP
98619: POP
// end ;
98620: PPOPN 2
98622: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98623: LD_EXP 98
98627: PUSH
98628: LD_EXP 104
98632: AND
98633: IFFALSE 98717
98635: GO 98637
98637: DISABLE
98638: LD_INT 0
98640: PPUSH
98641: PPUSH
// begin enable ;
98642: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98643: LD_ADDR_VAR 0 2
98647: PUSH
98648: LD_INT 22
98650: PUSH
98651: LD_OWVAR 2
98655: PUSH
98656: EMPTY
98657: LIST
98658: LIST
98659: PUSH
98660: LD_INT 32
98662: PUSH
98663: LD_INT 3
98665: PUSH
98666: EMPTY
98667: LIST
98668: LIST
98669: PUSH
98670: EMPTY
98671: LIST
98672: LIST
98673: PPUSH
98674: CALL_OW 69
98678: ST_TO_ADDR
// if not tmp then
98679: LD_VAR 0 2
98683: NOT
98684: IFFALSE 98688
// exit ;
98686: GO 98717
// for i in tmp do
98688: LD_ADDR_VAR 0 1
98692: PUSH
98693: LD_VAR 0 2
98697: PUSH
98698: FOR_IN
98699: IFFALSE 98715
// begin SetLives ( i , 0 ) ;
98701: LD_VAR 0 1
98705: PPUSH
98706: LD_INT 0
98708: PPUSH
98709: CALL_OW 234
// end ;
98713: GO 98698
98715: POP
98716: POP
// end ;
98717: PPOPN 2
98719: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98720: LD_EXP 98
98724: PUSH
98725: LD_EXP 101
98729: AND
98730: IFFALSE 98823
98732: GO 98734
98734: DISABLE
98735: LD_INT 0
98737: PPUSH
// begin enable ;
98738: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98739: LD_ADDR_VAR 0 1
98743: PUSH
98744: LD_INT 22
98746: PUSH
98747: LD_OWVAR 2
98751: PUSH
98752: EMPTY
98753: LIST
98754: LIST
98755: PUSH
98756: LD_INT 2
98758: PUSH
98759: LD_INT 25
98761: PUSH
98762: LD_INT 5
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: PUSH
98769: LD_INT 25
98771: PUSH
98772: LD_INT 9
98774: PUSH
98775: EMPTY
98776: LIST
98777: LIST
98778: PUSH
98779: LD_INT 25
98781: PUSH
98782: LD_INT 8
98784: PUSH
98785: EMPTY
98786: LIST
98787: LIST
98788: PUSH
98789: EMPTY
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: PUSH
98795: EMPTY
98796: LIST
98797: LIST
98798: PPUSH
98799: CALL_OW 69
98803: PUSH
98804: FOR_IN
98805: IFFALSE 98821
// begin SetClass ( i , 1 ) ;
98807: LD_VAR 0 1
98811: PPUSH
98812: LD_INT 1
98814: PPUSH
98815: CALL_OW 336
// end ;
98819: GO 98804
98821: POP
98822: POP
// end ;
98823: PPOPN 1
98825: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98826: LD_EXP 98
98830: PUSH
98831: LD_EXP 102
98835: AND
98836: PUSH
98837: LD_OWVAR 65
98841: PUSH
98842: LD_INT 7
98844: LESS
98845: AND
98846: IFFALSE 98860
98848: GO 98850
98850: DISABLE
// begin enable ;
98851: ENABLE
// game_speed := 7 ;
98852: LD_ADDR_OWVAR 65
98856: PUSH
98857: LD_INT 7
98859: ST_TO_ADDR
// end ;
98860: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98861: LD_EXP 98
98865: PUSH
98866: LD_EXP 105
98870: AND
98871: IFFALSE 99073
98873: GO 98875
98875: DISABLE
98876: LD_INT 0
98878: PPUSH
98879: PPUSH
98880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98881: LD_ADDR_VAR 0 3
98885: PUSH
98886: LD_INT 81
98888: PUSH
98889: LD_OWVAR 2
98893: PUSH
98894: EMPTY
98895: LIST
98896: LIST
98897: PUSH
98898: LD_INT 21
98900: PUSH
98901: LD_INT 1
98903: PUSH
98904: EMPTY
98905: LIST
98906: LIST
98907: PUSH
98908: EMPTY
98909: LIST
98910: LIST
98911: PPUSH
98912: CALL_OW 69
98916: ST_TO_ADDR
// if not tmp then
98917: LD_VAR 0 3
98921: NOT
98922: IFFALSE 98926
// exit ;
98924: GO 99073
// if tmp > 5 then
98926: LD_VAR 0 3
98930: PUSH
98931: LD_INT 5
98933: GREATER
98934: IFFALSE 98946
// k := 5 else
98936: LD_ADDR_VAR 0 2
98940: PUSH
98941: LD_INT 5
98943: ST_TO_ADDR
98944: GO 98956
// k := tmp ;
98946: LD_ADDR_VAR 0 2
98950: PUSH
98951: LD_VAR 0 3
98955: ST_TO_ADDR
// for i := 1 to k do
98956: LD_ADDR_VAR 0 1
98960: PUSH
98961: DOUBLE
98962: LD_INT 1
98964: DEC
98965: ST_TO_ADDR
98966: LD_VAR 0 2
98970: PUSH
98971: FOR_TO
98972: IFFALSE 99071
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98974: LD_VAR 0 3
98978: PUSH
98979: LD_VAR 0 1
98983: ARRAY
98984: PPUSH
98985: LD_VAR 0 1
98989: PUSH
98990: LD_INT 4
98992: MOD
98993: PUSH
98994: LD_INT 1
98996: PLUS
98997: PPUSH
98998: CALL_OW 259
99002: PUSH
99003: LD_INT 10
99005: LESS
99006: IFFALSE 99069
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
99008: LD_VAR 0 3
99012: PUSH
99013: LD_VAR 0 1
99017: ARRAY
99018: PPUSH
99019: LD_VAR 0 1
99023: PUSH
99024: LD_INT 4
99026: MOD
99027: PUSH
99028: LD_INT 1
99030: PLUS
99031: PPUSH
99032: LD_VAR 0 3
99036: PUSH
99037: LD_VAR 0 1
99041: ARRAY
99042: PPUSH
99043: LD_VAR 0 1
99047: PUSH
99048: LD_INT 4
99050: MOD
99051: PUSH
99052: LD_INT 1
99054: PLUS
99055: PPUSH
99056: CALL_OW 259
99060: PUSH
99061: LD_INT 1
99063: PLUS
99064: PPUSH
99065: CALL_OW 237
99069: GO 98971
99071: POP
99072: POP
// end ;
99073: PPOPN 3
99075: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
99076: LD_EXP 98
99080: PUSH
99081: LD_EXP 106
99085: AND
99086: IFFALSE 99106
99088: GO 99090
99090: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
99091: LD_INT 4
99093: PPUSH
99094: LD_OWVAR 2
99098: PPUSH
99099: LD_INT 0
99101: PPUSH
99102: CALL_OW 324
99106: END
// every 0 0$1 trigger StreamModeActive and sShovel do
99107: LD_EXP 98
99111: PUSH
99112: LD_EXP 135
99116: AND
99117: IFFALSE 99137
99119: GO 99121
99121: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
99122: LD_INT 19
99124: PPUSH
99125: LD_OWVAR 2
99129: PPUSH
99130: LD_INT 0
99132: PPUSH
99133: CALL_OW 324
99137: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
99138: LD_EXP 98
99142: PUSH
99143: LD_EXP 107
99147: AND
99148: IFFALSE 99250
99150: GO 99152
99152: DISABLE
99153: LD_INT 0
99155: PPUSH
99156: PPUSH
// begin enable ;
99157: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
99158: LD_ADDR_VAR 0 2
99162: PUSH
99163: LD_INT 22
99165: PUSH
99166: LD_OWVAR 2
99170: PUSH
99171: EMPTY
99172: LIST
99173: LIST
99174: PUSH
99175: LD_INT 2
99177: PUSH
99178: LD_INT 34
99180: PUSH
99181: LD_INT 11
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PUSH
99188: LD_INT 34
99190: PUSH
99191: LD_INT 30
99193: PUSH
99194: EMPTY
99195: LIST
99196: LIST
99197: PUSH
99198: EMPTY
99199: LIST
99200: LIST
99201: LIST
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: PPUSH
99207: CALL_OW 69
99211: ST_TO_ADDR
// if not tmp then
99212: LD_VAR 0 2
99216: NOT
99217: IFFALSE 99221
// exit ;
99219: GO 99250
// for i in tmp do
99221: LD_ADDR_VAR 0 1
99225: PUSH
99226: LD_VAR 0 2
99230: PUSH
99231: FOR_IN
99232: IFFALSE 99248
// begin SetLives ( i , 0 ) ;
99234: LD_VAR 0 1
99238: PPUSH
99239: LD_INT 0
99241: PPUSH
99242: CALL_OW 234
// end ;
99246: GO 99231
99248: POP
99249: POP
// end ;
99250: PPOPN 2
99252: END
// every 0 0$1 trigger StreamModeActive and sBunker do
99253: LD_EXP 98
99257: PUSH
99258: LD_EXP 108
99262: AND
99263: IFFALSE 99283
99265: GO 99267
99267: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
99268: LD_INT 32
99270: PPUSH
99271: LD_OWVAR 2
99275: PPUSH
99276: LD_INT 0
99278: PPUSH
99279: CALL_OW 324
99283: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
99284: LD_EXP 98
99288: PUSH
99289: LD_EXP 109
99293: AND
99294: IFFALSE 99475
99296: GO 99298
99298: DISABLE
99299: LD_INT 0
99301: PPUSH
99302: PPUSH
99303: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99304: LD_ADDR_VAR 0 2
99308: PUSH
99309: LD_INT 22
99311: PUSH
99312: LD_OWVAR 2
99316: PUSH
99317: EMPTY
99318: LIST
99319: LIST
99320: PUSH
99321: LD_INT 33
99323: PUSH
99324: LD_INT 3
99326: PUSH
99327: EMPTY
99328: LIST
99329: LIST
99330: PUSH
99331: EMPTY
99332: LIST
99333: LIST
99334: PPUSH
99335: CALL_OW 69
99339: ST_TO_ADDR
// if not tmp then
99340: LD_VAR 0 2
99344: NOT
99345: IFFALSE 99349
// exit ;
99347: GO 99475
// side := 0 ;
99349: LD_ADDR_VAR 0 3
99353: PUSH
99354: LD_INT 0
99356: ST_TO_ADDR
// for i := 1 to 8 do
99357: LD_ADDR_VAR 0 1
99361: PUSH
99362: DOUBLE
99363: LD_INT 1
99365: DEC
99366: ST_TO_ADDR
99367: LD_INT 8
99369: PUSH
99370: FOR_TO
99371: IFFALSE 99419
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99373: LD_OWVAR 2
99377: PUSH
99378: LD_VAR 0 1
99382: NONEQUAL
99383: PUSH
99384: LD_OWVAR 2
99388: PPUSH
99389: LD_VAR 0 1
99393: PPUSH
99394: CALL_OW 81
99398: PUSH
99399: LD_INT 2
99401: EQUAL
99402: AND
99403: IFFALSE 99417
// begin side := i ;
99405: LD_ADDR_VAR 0 3
99409: PUSH
99410: LD_VAR 0 1
99414: ST_TO_ADDR
// break ;
99415: GO 99419
// end ;
99417: GO 99370
99419: POP
99420: POP
// if not side then
99421: LD_VAR 0 3
99425: NOT
99426: IFFALSE 99430
// exit ;
99428: GO 99475
// for i := 1 to tmp do
99430: LD_ADDR_VAR 0 1
99434: PUSH
99435: DOUBLE
99436: LD_INT 1
99438: DEC
99439: ST_TO_ADDR
99440: LD_VAR 0 2
99444: PUSH
99445: FOR_TO
99446: IFFALSE 99473
// if Prob ( 60 ) then
99448: LD_INT 60
99450: PPUSH
99451: CALL_OW 13
99455: IFFALSE 99471
// SetSide ( i , side ) ;
99457: LD_VAR 0 1
99461: PPUSH
99462: LD_VAR 0 3
99466: PPUSH
99467: CALL_OW 235
99471: GO 99445
99473: POP
99474: POP
// end ;
99475: PPOPN 3
99477: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99478: LD_EXP 98
99482: PUSH
99483: LD_EXP 111
99487: AND
99488: IFFALSE 99607
99490: GO 99492
99492: DISABLE
99493: LD_INT 0
99495: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99496: LD_ADDR_VAR 0 1
99500: PUSH
99501: LD_INT 22
99503: PUSH
99504: LD_OWVAR 2
99508: PUSH
99509: EMPTY
99510: LIST
99511: LIST
99512: PUSH
99513: LD_INT 21
99515: PUSH
99516: LD_INT 1
99518: PUSH
99519: EMPTY
99520: LIST
99521: LIST
99522: PUSH
99523: LD_INT 3
99525: PUSH
99526: LD_INT 23
99528: PUSH
99529: LD_INT 0
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: PUSH
99536: EMPTY
99537: LIST
99538: LIST
99539: PUSH
99540: EMPTY
99541: LIST
99542: LIST
99543: LIST
99544: PPUSH
99545: CALL_OW 69
99549: PUSH
99550: FOR_IN
99551: IFFALSE 99605
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99553: LD_VAR 0 1
99557: PPUSH
99558: CALL_OW 257
99562: PUSH
99563: LD_INT 1
99565: PUSH
99566: LD_INT 2
99568: PUSH
99569: LD_INT 3
99571: PUSH
99572: LD_INT 4
99574: PUSH
99575: EMPTY
99576: LIST
99577: LIST
99578: LIST
99579: LIST
99580: IN
99581: IFFALSE 99603
// SetClass ( un , rand ( 1 , 4 ) ) ;
99583: LD_VAR 0 1
99587: PPUSH
99588: LD_INT 1
99590: PPUSH
99591: LD_INT 4
99593: PPUSH
99594: CALL_OW 12
99598: PPUSH
99599: CALL_OW 336
99603: GO 99550
99605: POP
99606: POP
// end ;
99607: PPOPN 1
99609: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99610: LD_EXP 98
99614: PUSH
99615: LD_EXP 110
99619: AND
99620: IFFALSE 99699
99622: GO 99624
99624: DISABLE
99625: LD_INT 0
99627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99628: LD_ADDR_VAR 0 1
99632: PUSH
99633: LD_INT 22
99635: PUSH
99636: LD_OWVAR 2
99640: PUSH
99641: EMPTY
99642: LIST
99643: LIST
99644: PUSH
99645: LD_INT 21
99647: PUSH
99648: LD_INT 3
99650: PUSH
99651: EMPTY
99652: LIST
99653: LIST
99654: PUSH
99655: EMPTY
99656: LIST
99657: LIST
99658: PPUSH
99659: CALL_OW 69
99663: ST_TO_ADDR
// if not tmp then
99664: LD_VAR 0 1
99668: NOT
99669: IFFALSE 99673
// exit ;
99671: GO 99699
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99673: LD_VAR 0 1
99677: PUSH
99678: LD_INT 1
99680: PPUSH
99681: LD_VAR 0 1
99685: PPUSH
99686: CALL_OW 12
99690: ARRAY
99691: PPUSH
99692: LD_INT 100
99694: PPUSH
99695: CALL_OW 234
// end ;
99699: PPOPN 1
99701: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99702: LD_EXP 98
99706: PUSH
99707: LD_EXP 112
99711: AND
99712: IFFALSE 99810
99714: GO 99716
99716: DISABLE
99717: LD_INT 0
99719: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99720: LD_ADDR_VAR 0 1
99724: PUSH
99725: LD_INT 22
99727: PUSH
99728: LD_OWVAR 2
99732: PUSH
99733: EMPTY
99734: LIST
99735: LIST
99736: PUSH
99737: LD_INT 21
99739: PUSH
99740: LD_INT 1
99742: PUSH
99743: EMPTY
99744: LIST
99745: LIST
99746: PUSH
99747: EMPTY
99748: LIST
99749: LIST
99750: PPUSH
99751: CALL_OW 69
99755: ST_TO_ADDR
// if not tmp then
99756: LD_VAR 0 1
99760: NOT
99761: IFFALSE 99765
// exit ;
99763: GO 99810
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99765: LD_VAR 0 1
99769: PUSH
99770: LD_INT 1
99772: PPUSH
99773: LD_VAR 0 1
99777: PPUSH
99778: CALL_OW 12
99782: ARRAY
99783: PPUSH
99784: LD_INT 1
99786: PPUSH
99787: LD_INT 4
99789: PPUSH
99790: CALL_OW 12
99794: PPUSH
99795: LD_INT 3000
99797: PPUSH
99798: LD_INT 9000
99800: PPUSH
99801: CALL_OW 12
99805: PPUSH
99806: CALL_OW 492
// end ;
99810: PPOPN 1
99812: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99813: LD_EXP 98
99817: PUSH
99818: LD_EXP 113
99822: AND
99823: IFFALSE 99843
99825: GO 99827
99827: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99828: LD_INT 1
99830: PPUSH
99831: LD_OWVAR 2
99835: PPUSH
99836: LD_INT 0
99838: PPUSH
99839: CALL_OW 324
99843: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99844: LD_EXP 98
99848: PUSH
99849: LD_EXP 114
99853: AND
99854: IFFALSE 99937
99856: GO 99858
99858: DISABLE
99859: LD_INT 0
99861: PPUSH
99862: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99863: LD_ADDR_VAR 0 2
99867: PUSH
99868: LD_INT 22
99870: PUSH
99871: LD_OWVAR 2
99875: PUSH
99876: EMPTY
99877: LIST
99878: LIST
99879: PUSH
99880: LD_INT 21
99882: PUSH
99883: LD_INT 3
99885: PUSH
99886: EMPTY
99887: LIST
99888: LIST
99889: PUSH
99890: EMPTY
99891: LIST
99892: LIST
99893: PPUSH
99894: CALL_OW 69
99898: ST_TO_ADDR
// if not tmp then
99899: LD_VAR 0 2
99903: NOT
99904: IFFALSE 99908
// exit ;
99906: GO 99937
// for i in tmp do
99908: LD_ADDR_VAR 0 1
99912: PUSH
99913: LD_VAR 0 2
99917: PUSH
99918: FOR_IN
99919: IFFALSE 99935
// SetBLevel ( i , 10 ) ;
99921: LD_VAR 0 1
99925: PPUSH
99926: LD_INT 10
99928: PPUSH
99929: CALL_OW 241
99933: GO 99918
99935: POP
99936: POP
// end ;
99937: PPOPN 2
99939: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99940: LD_EXP 98
99944: PUSH
99945: LD_EXP 115
99949: AND
99950: IFFALSE 100061
99952: GO 99954
99954: DISABLE
99955: LD_INT 0
99957: PPUSH
99958: PPUSH
99959: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99960: LD_ADDR_VAR 0 3
99964: PUSH
99965: LD_INT 22
99967: PUSH
99968: LD_OWVAR 2
99972: PUSH
99973: EMPTY
99974: LIST
99975: LIST
99976: PUSH
99977: LD_INT 25
99979: PUSH
99980: LD_INT 1
99982: PUSH
99983: EMPTY
99984: LIST
99985: LIST
99986: PUSH
99987: EMPTY
99988: LIST
99989: LIST
99990: PPUSH
99991: CALL_OW 69
99995: ST_TO_ADDR
// if not tmp then
99996: LD_VAR 0 3
100000: NOT
100001: IFFALSE 100005
// exit ;
100003: GO 100061
// un := tmp [ rand ( 1 , tmp ) ] ;
100005: LD_ADDR_VAR 0 2
100009: PUSH
100010: LD_VAR 0 3
100014: PUSH
100015: LD_INT 1
100017: PPUSH
100018: LD_VAR 0 3
100022: PPUSH
100023: CALL_OW 12
100027: ARRAY
100028: ST_TO_ADDR
// if Crawls ( un ) then
100029: LD_VAR 0 2
100033: PPUSH
100034: CALL_OW 318
100038: IFFALSE 100049
// ComWalk ( un ) ;
100040: LD_VAR 0 2
100044: PPUSH
100045: CALL_OW 138
// SetClass ( un , class_sniper ) ;
100049: LD_VAR 0 2
100053: PPUSH
100054: LD_INT 5
100056: PPUSH
100057: CALL_OW 336
// end ;
100061: PPOPN 3
100063: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
100064: LD_EXP 98
100068: PUSH
100069: LD_EXP 116
100073: AND
100074: PUSH
100075: LD_OWVAR 67
100079: PUSH
100080: LD_INT 4
100082: LESS
100083: AND
100084: IFFALSE 100103
100086: GO 100088
100088: DISABLE
// begin Difficulty := Difficulty + 1 ;
100089: LD_ADDR_OWVAR 67
100093: PUSH
100094: LD_OWVAR 67
100098: PUSH
100099: LD_INT 1
100101: PLUS
100102: ST_TO_ADDR
// end ;
100103: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
100104: LD_EXP 98
100108: PUSH
100109: LD_EXP 117
100113: AND
100114: IFFALSE 100217
100116: GO 100118
100118: DISABLE
100119: LD_INT 0
100121: PPUSH
// begin for i := 1 to 5 do
100122: LD_ADDR_VAR 0 1
100126: PUSH
100127: DOUBLE
100128: LD_INT 1
100130: DEC
100131: ST_TO_ADDR
100132: LD_INT 5
100134: PUSH
100135: FOR_TO
100136: IFFALSE 100215
// begin uc_nation := nation_nature ;
100138: LD_ADDR_OWVAR 21
100142: PUSH
100143: LD_INT 0
100145: ST_TO_ADDR
// uc_side := 0 ;
100146: LD_ADDR_OWVAR 20
100150: PUSH
100151: LD_INT 0
100153: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100154: LD_ADDR_OWVAR 29
100158: PUSH
100159: LD_INT 12
100161: PUSH
100162: LD_INT 12
100164: PUSH
100165: EMPTY
100166: LIST
100167: LIST
100168: ST_TO_ADDR
// hc_agressivity := 20 ;
100169: LD_ADDR_OWVAR 35
100173: PUSH
100174: LD_INT 20
100176: ST_TO_ADDR
// hc_class := class_tiger ;
100177: LD_ADDR_OWVAR 28
100181: PUSH
100182: LD_INT 14
100184: ST_TO_ADDR
// hc_gallery :=  ;
100185: LD_ADDR_OWVAR 33
100189: PUSH
100190: LD_STRING 
100192: ST_TO_ADDR
// hc_name :=  ;
100193: LD_ADDR_OWVAR 26
100197: PUSH
100198: LD_STRING 
100200: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
100201: CALL_OW 44
100205: PPUSH
100206: LD_INT 0
100208: PPUSH
100209: CALL_OW 51
// end ;
100213: GO 100135
100215: POP
100216: POP
// end ;
100217: PPOPN 1
100219: END
// every 0 0$1 trigger StreamModeActive and sBomb do
100220: LD_EXP 98
100224: PUSH
100225: LD_EXP 118
100229: AND
100230: IFFALSE 100239
100232: GO 100234
100234: DISABLE
// StreamSibBomb ;
100235: CALL 100240 0 0
100239: END
// export function StreamSibBomb ; var i , x , y ; begin
100240: LD_INT 0
100242: PPUSH
100243: PPUSH
100244: PPUSH
100245: PPUSH
// result := false ;
100246: LD_ADDR_VAR 0 1
100250: PUSH
100251: LD_INT 0
100253: ST_TO_ADDR
// for i := 1 to 16 do
100254: LD_ADDR_VAR 0 2
100258: PUSH
100259: DOUBLE
100260: LD_INT 1
100262: DEC
100263: ST_TO_ADDR
100264: LD_INT 16
100266: PUSH
100267: FOR_TO
100268: IFFALSE 100467
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100270: LD_ADDR_VAR 0 3
100274: PUSH
100275: LD_INT 10
100277: PUSH
100278: LD_INT 20
100280: PUSH
100281: LD_INT 30
100283: PUSH
100284: LD_INT 40
100286: PUSH
100287: LD_INT 50
100289: PUSH
100290: LD_INT 60
100292: PUSH
100293: LD_INT 70
100295: PUSH
100296: LD_INT 80
100298: PUSH
100299: LD_INT 90
100301: PUSH
100302: LD_INT 100
100304: PUSH
100305: LD_INT 110
100307: PUSH
100308: LD_INT 120
100310: PUSH
100311: LD_INT 130
100313: PUSH
100314: LD_INT 140
100316: PUSH
100317: LD_INT 150
100319: PUSH
100320: EMPTY
100321: LIST
100322: LIST
100323: LIST
100324: LIST
100325: LIST
100326: LIST
100327: LIST
100328: LIST
100329: LIST
100330: LIST
100331: LIST
100332: LIST
100333: LIST
100334: LIST
100335: LIST
100336: PUSH
100337: LD_INT 1
100339: PPUSH
100340: LD_INT 15
100342: PPUSH
100343: CALL_OW 12
100347: ARRAY
100348: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100349: LD_ADDR_VAR 0 4
100353: PUSH
100354: LD_INT 10
100356: PUSH
100357: LD_INT 20
100359: PUSH
100360: LD_INT 30
100362: PUSH
100363: LD_INT 40
100365: PUSH
100366: LD_INT 50
100368: PUSH
100369: LD_INT 60
100371: PUSH
100372: LD_INT 70
100374: PUSH
100375: LD_INT 80
100377: PUSH
100378: LD_INT 90
100380: PUSH
100381: LD_INT 100
100383: PUSH
100384: LD_INT 110
100386: PUSH
100387: LD_INT 120
100389: PUSH
100390: LD_INT 130
100392: PUSH
100393: LD_INT 140
100395: PUSH
100396: LD_INT 150
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: LIST
100403: LIST
100404: LIST
100405: LIST
100406: LIST
100407: LIST
100408: LIST
100409: LIST
100410: LIST
100411: LIST
100412: LIST
100413: LIST
100414: LIST
100415: PUSH
100416: LD_INT 1
100418: PPUSH
100419: LD_INT 15
100421: PPUSH
100422: CALL_OW 12
100426: ARRAY
100427: ST_TO_ADDR
// if ValidHex ( x , y ) then
100428: LD_VAR 0 3
100432: PPUSH
100433: LD_VAR 0 4
100437: PPUSH
100438: CALL_OW 488
100442: IFFALSE 100465
// begin result := [ x , y ] ;
100444: LD_ADDR_VAR 0 1
100448: PUSH
100449: LD_VAR 0 3
100453: PUSH
100454: LD_VAR 0 4
100458: PUSH
100459: EMPTY
100460: LIST
100461: LIST
100462: ST_TO_ADDR
// break ;
100463: GO 100467
// end ; end ;
100465: GO 100267
100467: POP
100468: POP
// if result then
100469: LD_VAR 0 1
100473: IFFALSE 100533
// begin ToLua ( playSibBomb() ) ;
100475: LD_STRING playSibBomb()
100477: PPUSH
100478: CALL_OW 559
// wait ( 0 0$14 ) ;
100482: LD_INT 490
100484: PPUSH
100485: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100489: LD_VAR 0 1
100493: PUSH
100494: LD_INT 1
100496: ARRAY
100497: PPUSH
100498: LD_VAR 0 1
100502: PUSH
100503: LD_INT 2
100505: ARRAY
100506: PPUSH
100507: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100511: LD_VAR 0 1
100515: PUSH
100516: LD_INT 1
100518: ARRAY
100519: PPUSH
100520: LD_VAR 0 1
100524: PUSH
100525: LD_INT 2
100527: ARRAY
100528: PPUSH
100529: CALL_OW 429
// end ; end ;
100533: LD_VAR 0 1
100537: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100538: LD_EXP 98
100542: PUSH
100543: LD_EXP 120
100547: AND
100548: IFFALSE 100560
100550: GO 100552
100552: DISABLE
// YouLost (  ) ;
100553: LD_STRING 
100555: PPUSH
100556: CALL_OW 104
100560: END
// every 0 0$1 trigger StreamModeActive and sFog do
100561: LD_EXP 98
100565: PUSH
100566: LD_EXP 119
100570: AND
100571: IFFALSE 100585
100573: GO 100575
100575: DISABLE
// FogOff ( your_side ) ;
100576: LD_OWVAR 2
100580: PPUSH
100581: CALL_OW 344
100585: END
// every 0 0$1 trigger StreamModeActive and sSun do
100586: LD_EXP 98
100590: PUSH
100591: LD_EXP 121
100595: AND
100596: IFFALSE 100624
100598: GO 100600
100600: DISABLE
// begin solar_recharge_percent := 0 ;
100601: LD_ADDR_OWVAR 79
100605: PUSH
100606: LD_INT 0
100608: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100609: LD_INT 10500
100611: PPUSH
100612: CALL_OW 67
// solar_recharge_percent := 100 ;
100616: LD_ADDR_OWVAR 79
100620: PUSH
100621: LD_INT 100
100623: ST_TO_ADDR
// end ;
100624: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100625: LD_EXP 98
100629: PUSH
100630: LD_EXP 122
100634: AND
100635: IFFALSE 100874
100637: GO 100639
100639: DISABLE
100640: LD_INT 0
100642: PPUSH
100643: PPUSH
100644: PPUSH
// begin tmp := [ ] ;
100645: LD_ADDR_VAR 0 3
100649: PUSH
100650: EMPTY
100651: ST_TO_ADDR
// for i := 1 to 6 do
100652: LD_ADDR_VAR 0 1
100656: PUSH
100657: DOUBLE
100658: LD_INT 1
100660: DEC
100661: ST_TO_ADDR
100662: LD_INT 6
100664: PUSH
100665: FOR_TO
100666: IFFALSE 100771
// begin uc_nation := nation_nature ;
100668: LD_ADDR_OWVAR 21
100672: PUSH
100673: LD_INT 0
100675: ST_TO_ADDR
// uc_side := 0 ;
100676: LD_ADDR_OWVAR 20
100680: PUSH
100681: LD_INT 0
100683: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100684: LD_ADDR_OWVAR 29
100688: PUSH
100689: LD_INT 12
100691: PUSH
100692: LD_INT 12
100694: PUSH
100695: EMPTY
100696: LIST
100697: LIST
100698: ST_TO_ADDR
// hc_agressivity := 20 ;
100699: LD_ADDR_OWVAR 35
100703: PUSH
100704: LD_INT 20
100706: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100707: LD_ADDR_OWVAR 28
100711: PUSH
100712: LD_INT 17
100714: ST_TO_ADDR
// hc_gallery :=  ;
100715: LD_ADDR_OWVAR 33
100719: PUSH
100720: LD_STRING 
100722: ST_TO_ADDR
// hc_name :=  ;
100723: LD_ADDR_OWVAR 26
100727: PUSH
100728: LD_STRING 
100730: ST_TO_ADDR
// un := CreateHuman ;
100731: LD_ADDR_VAR 0 2
100735: PUSH
100736: CALL_OW 44
100740: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100741: LD_VAR 0 2
100745: PPUSH
100746: LD_INT 1
100748: PPUSH
100749: CALL_OW 51
// tmp := tmp ^ un ;
100753: LD_ADDR_VAR 0 3
100757: PUSH
100758: LD_VAR 0 3
100762: PUSH
100763: LD_VAR 0 2
100767: ADD
100768: ST_TO_ADDR
// end ;
100769: GO 100665
100771: POP
100772: POP
// repeat wait ( 0 0$1 ) ;
100773: LD_INT 35
100775: PPUSH
100776: CALL_OW 67
// for un in tmp do
100780: LD_ADDR_VAR 0 2
100784: PUSH
100785: LD_VAR 0 3
100789: PUSH
100790: FOR_IN
100791: IFFALSE 100865
// begin if IsDead ( un ) then
100793: LD_VAR 0 2
100797: PPUSH
100798: CALL_OW 301
100802: IFFALSE 100822
// begin tmp := tmp diff un ;
100804: LD_ADDR_VAR 0 3
100808: PUSH
100809: LD_VAR 0 3
100813: PUSH
100814: LD_VAR 0 2
100818: DIFF
100819: ST_TO_ADDR
// continue ;
100820: GO 100790
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100822: LD_VAR 0 2
100826: PPUSH
100827: LD_INT 3
100829: PUSH
100830: LD_INT 22
100832: PUSH
100833: LD_INT 0
100835: PUSH
100836: EMPTY
100837: LIST
100838: LIST
100839: PUSH
100840: EMPTY
100841: LIST
100842: LIST
100843: PPUSH
100844: CALL_OW 69
100848: PPUSH
100849: LD_VAR 0 2
100853: PPUSH
100854: CALL_OW 74
100858: PPUSH
100859: CALL_OW 115
// end ;
100863: GO 100790
100865: POP
100866: POP
// until not tmp ;
100867: LD_VAR 0 3
100871: NOT
100872: IFFALSE 100773
// end ;
100874: PPOPN 3
100876: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100877: LD_EXP 98
100881: PUSH
100882: LD_EXP 123
100886: AND
100887: IFFALSE 100941
100889: GO 100891
100891: DISABLE
// begin ToLua ( displayTroll(); ) ;
100892: LD_STRING displayTroll();
100894: PPUSH
100895: CALL_OW 559
// wait ( 3 3$00 ) ;
100899: LD_INT 6300
100901: PPUSH
100902: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100906: LD_STRING hideTroll();
100908: PPUSH
100909: CALL_OW 559
// wait ( 1 1$00 ) ;
100913: LD_INT 2100
100915: PPUSH
100916: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100920: LD_STRING displayTroll();
100922: PPUSH
100923: CALL_OW 559
// wait ( 1 1$00 ) ;
100927: LD_INT 2100
100929: PPUSH
100930: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100934: LD_STRING hideTroll();
100936: PPUSH
100937: CALL_OW 559
// end ;
100941: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100942: LD_EXP 98
100946: PUSH
100947: LD_EXP 124
100951: AND
100952: IFFALSE 101015
100954: GO 100956
100956: DISABLE
100957: LD_INT 0
100959: PPUSH
// begin p := 0 ;
100960: LD_ADDR_VAR 0 1
100964: PUSH
100965: LD_INT 0
100967: ST_TO_ADDR
// repeat game_speed := 1 ;
100968: LD_ADDR_OWVAR 65
100972: PUSH
100973: LD_INT 1
100975: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100976: LD_INT 35
100978: PPUSH
100979: CALL_OW 67
// p := p + 1 ;
100983: LD_ADDR_VAR 0 1
100987: PUSH
100988: LD_VAR 0 1
100992: PUSH
100993: LD_INT 1
100995: PLUS
100996: ST_TO_ADDR
// until p >= 60 ;
100997: LD_VAR 0 1
101001: PUSH
101002: LD_INT 60
101004: GREATEREQUAL
101005: IFFALSE 100968
// game_speed := 4 ;
101007: LD_ADDR_OWVAR 65
101011: PUSH
101012: LD_INT 4
101014: ST_TO_ADDR
// end ;
101015: PPOPN 1
101017: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
101018: LD_EXP 98
101022: PUSH
101023: LD_EXP 125
101027: AND
101028: IFFALSE 101174
101030: GO 101032
101032: DISABLE
101033: LD_INT 0
101035: PPUSH
101036: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101037: LD_ADDR_VAR 0 1
101041: PUSH
101042: LD_INT 22
101044: PUSH
101045: LD_OWVAR 2
101049: PUSH
101050: EMPTY
101051: LIST
101052: LIST
101053: PUSH
101054: LD_INT 2
101056: PUSH
101057: LD_INT 30
101059: PUSH
101060: LD_INT 0
101062: PUSH
101063: EMPTY
101064: LIST
101065: LIST
101066: PUSH
101067: LD_INT 30
101069: PUSH
101070: LD_INT 1
101072: PUSH
101073: EMPTY
101074: LIST
101075: LIST
101076: PUSH
101077: EMPTY
101078: LIST
101079: LIST
101080: LIST
101081: PUSH
101082: EMPTY
101083: LIST
101084: LIST
101085: PPUSH
101086: CALL_OW 69
101090: ST_TO_ADDR
// if not depot then
101091: LD_VAR 0 1
101095: NOT
101096: IFFALSE 101100
// exit ;
101098: GO 101174
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
101100: LD_ADDR_VAR 0 2
101104: PUSH
101105: LD_VAR 0 1
101109: PUSH
101110: LD_INT 1
101112: PPUSH
101113: LD_VAR 0 1
101117: PPUSH
101118: CALL_OW 12
101122: ARRAY
101123: PPUSH
101124: CALL_OW 274
101128: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
101129: LD_VAR 0 2
101133: PPUSH
101134: LD_INT 1
101136: PPUSH
101137: LD_INT 0
101139: PPUSH
101140: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
101144: LD_VAR 0 2
101148: PPUSH
101149: LD_INT 2
101151: PPUSH
101152: LD_INT 0
101154: PPUSH
101155: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
101159: LD_VAR 0 2
101163: PPUSH
101164: LD_INT 3
101166: PPUSH
101167: LD_INT 0
101169: PPUSH
101170: CALL_OW 277
// end ;
101174: PPOPN 2
101176: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
101177: LD_EXP 98
101181: PUSH
101182: LD_EXP 126
101186: AND
101187: IFFALSE 101284
101189: GO 101191
101191: DISABLE
101192: LD_INT 0
101194: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101195: LD_ADDR_VAR 0 1
101199: PUSH
101200: LD_INT 22
101202: PUSH
101203: LD_OWVAR 2
101207: PUSH
101208: EMPTY
101209: LIST
101210: LIST
101211: PUSH
101212: LD_INT 21
101214: PUSH
101215: LD_INT 1
101217: PUSH
101218: EMPTY
101219: LIST
101220: LIST
101221: PUSH
101222: LD_INT 3
101224: PUSH
101225: LD_INT 23
101227: PUSH
101228: LD_INT 0
101230: PUSH
101231: EMPTY
101232: LIST
101233: LIST
101234: PUSH
101235: EMPTY
101236: LIST
101237: LIST
101238: PUSH
101239: EMPTY
101240: LIST
101241: LIST
101242: LIST
101243: PPUSH
101244: CALL_OW 69
101248: ST_TO_ADDR
// if not tmp then
101249: LD_VAR 0 1
101253: NOT
101254: IFFALSE 101258
// exit ;
101256: GO 101284
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
101258: LD_VAR 0 1
101262: PUSH
101263: LD_INT 1
101265: PPUSH
101266: LD_VAR 0 1
101270: PPUSH
101271: CALL_OW 12
101275: ARRAY
101276: PPUSH
101277: LD_INT 200
101279: PPUSH
101280: CALL_OW 234
// end ;
101284: PPOPN 1
101286: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
101287: LD_EXP 98
101291: PUSH
101292: LD_EXP 127
101296: AND
101297: IFFALSE 101376
101299: GO 101301
101301: DISABLE
101302: LD_INT 0
101304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101305: LD_ADDR_VAR 0 1
101309: PUSH
101310: LD_INT 22
101312: PUSH
101313: LD_OWVAR 2
101317: PUSH
101318: EMPTY
101319: LIST
101320: LIST
101321: PUSH
101322: LD_INT 21
101324: PUSH
101325: LD_INT 2
101327: PUSH
101328: EMPTY
101329: LIST
101330: LIST
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PPUSH
101336: CALL_OW 69
101340: ST_TO_ADDR
// if not tmp then
101341: LD_VAR 0 1
101345: NOT
101346: IFFALSE 101350
// exit ;
101348: GO 101376
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101350: LD_VAR 0 1
101354: PUSH
101355: LD_INT 1
101357: PPUSH
101358: LD_VAR 0 1
101362: PPUSH
101363: CALL_OW 12
101367: ARRAY
101368: PPUSH
101369: LD_INT 60
101371: PPUSH
101372: CALL_OW 234
// end ;
101376: PPOPN 1
101378: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101379: LD_EXP 98
101383: PUSH
101384: LD_EXP 128
101388: AND
101389: IFFALSE 101488
101391: GO 101393
101393: DISABLE
101394: LD_INT 0
101396: PPUSH
101397: PPUSH
// begin enable ;
101398: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101399: LD_ADDR_VAR 0 1
101403: PUSH
101404: LD_INT 22
101406: PUSH
101407: LD_OWVAR 2
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PUSH
101416: LD_INT 61
101418: PUSH
101419: EMPTY
101420: LIST
101421: PUSH
101422: LD_INT 33
101424: PUSH
101425: LD_INT 2
101427: PUSH
101428: EMPTY
101429: LIST
101430: LIST
101431: PUSH
101432: EMPTY
101433: LIST
101434: LIST
101435: LIST
101436: PPUSH
101437: CALL_OW 69
101441: ST_TO_ADDR
// if not tmp then
101442: LD_VAR 0 1
101446: NOT
101447: IFFALSE 101451
// exit ;
101449: GO 101488
// for i in tmp do
101451: LD_ADDR_VAR 0 2
101455: PUSH
101456: LD_VAR 0 1
101460: PUSH
101461: FOR_IN
101462: IFFALSE 101486
// if IsControledBy ( i ) then
101464: LD_VAR 0 2
101468: PPUSH
101469: CALL_OW 312
101473: IFFALSE 101484
// ComUnlink ( i ) ;
101475: LD_VAR 0 2
101479: PPUSH
101480: CALL_OW 136
101484: GO 101461
101486: POP
101487: POP
// end ;
101488: PPOPN 2
101490: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101491: LD_EXP 98
101495: PUSH
101496: LD_EXP 129
101500: AND
101501: IFFALSE 101641
101503: GO 101505
101505: DISABLE
101506: LD_INT 0
101508: PPUSH
101509: PPUSH
// begin ToLua ( displayPowell(); ) ;
101510: LD_STRING displayPowell();
101512: PPUSH
101513: CALL_OW 559
// uc_side := 0 ;
101517: LD_ADDR_OWVAR 20
101521: PUSH
101522: LD_INT 0
101524: ST_TO_ADDR
// uc_nation := 2 ;
101525: LD_ADDR_OWVAR 21
101529: PUSH
101530: LD_INT 2
101532: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101533: LD_ADDR_OWVAR 37
101537: PUSH
101538: LD_INT 14
101540: ST_TO_ADDR
// vc_engine := engine_siberite ;
101541: LD_ADDR_OWVAR 39
101545: PUSH
101546: LD_INT 3
101548: ST_TO_ADDR
// vc_control := control_apeman ;
101549: LD_ADDR_OWVAR 38
101553: PUSH
101554: LD_INT 5
101556: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101557: LD_ADDR_OWVAR 40
101561: PUSH
101562: LD_INT 29
101564: ST_TO_ADDR
// un := CreateVehicle ;
101565: LD_ADDR_VAR 0 2
101569: PUSH
101570: CALL_OW 45
101574: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101575: LD_VAR 0 2
101579: PPUSH
101580: LD_INT 1
101582: PPUSH
101583: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101587: LD_INT 35
101589: PPUSH
101590: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101594: LD_VAR 0 2
101598: PPUSH
101599: LD_INT 22
101601: PUSH
101602: LD_OWVAR 2
101606: PUSH
101607: EMPTY
101608: LIST
101609: LIST
101610: PPUSH
101611: CALL_OW 69
101615: PPUSH
101616: LD_VAR 0 2
101620: PPUSH
101621: CALL_OW 74
101625: PPUSH
101626: CALL_OW 115
// until IsDead ( un ) ;
101630: LD_VAR 0 2
101634: PPUSH
101635: CALL_OW 301
101639: IFFALSE 101587
// end ;
101641: PPOPN 2
101643: END
// every 0 0$1 trigger StreamModeActive and sStu do
101644: LD_EXP 98
101648: PUSH
101649: LD_EXP 137
101653: AND
101654: IFFALSE 101670
101656: GO 101658
101658: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101659: LD_STRING displayStucuk();
101661: PPUSH
101662: CALL_OW 559
// ResetFog ;
101666: CALL_OW 335
// end ;
101670: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101671: LD_EXP 98
101675: PUSH
101676: LD_EXP 130
101680: AND
101681: IFFALSE 101822
101683: GO 101685
101685: DISABLE
101686: LD_INT 0
101688: PPUSH
101689: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101690: LD_ADDR_VAR 0 2
101694: PUSH
101695: LD_INT 22
101697: PUSH
101698: LD_OWVAR 2
101702: PUSH
101703: EMPTY
101704: LIST
101705: LIST
101706: PUSH
101707: LD_INT 21
101709: PUSH
101710: LD_INT 1
101712: PUSH
101713: EMPTY
101714: LIST
101715: LIST
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: PPUSH
101721: CALL_OW 69
101725: ST_TO_ADDR
// if not tmp then
101726: LD_VAR 0 2
101730: NOT
101731: IFFALSE 101735
// exit ;
101733: GO 101822
// un := tmp [ rand ( 1 , tmp ) ] ;
101735: LD_ADDR_VAR 0 1
101739: PUSH
101740: LD_VAR 0 2
101744: PUSH
101745: LD_INT 1
101747: PPUSH
101748: LD_VAR 0 2
101752: PPUSH
101753: CALL_OW 12
101757: ARRAY
101758: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101759: LD_VAR 0 1
101763: PPUSH
101764: LD_INT 0
101766: PPUSH
101767: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101771: LD_VAR 0 1
101775: PPUSH
101776: LD_OWVAR 3
101780: PUSH
101781: LD_VAR 0 1
101785: DIFF
101786: PPUSH
101787: LD_VAR 0 1
101791: PPUSH
101792: CALL_OW 74
101796: PPUSH
101797: CALL_OW 115
// wait ( 0 0$20 ) ;
101801: LD_INT 700
101803: PPUSH
101804: CALL_OW 67
// SetSide ( un , your_side ) ;
101808: LD_VAR 0 1
101812: PPUSH
101813: LD_OWVAR 2
101817: PPUSH
101818: CALL_OW 235
// end ;
101822: PPOPN 2
101824: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101825: LD_EXP 98
101829: PUSH
101830: LD_EXP 131
101834: AND
101835: IFFALSE 101941
101837: GO 101839
101839: DISABLE
101840: LD_INT 0
101842: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101843: LD_ADDR_VAR 0 1
101847: PUSH
101848: LD_INT 22
101850: PUSH
101851: LD_OWVAR 2
101855: PUSH
101856: EMPTY
101857: LIST
101858: LIST
101859: PUSH
101860: LD_INT 2
101862: PUSH
101863: LD_INT 30
101865: PUSH
101866: LD_INT 0
101868: PUSH
101869: EMPTY
101870: LIST
101871: LIST
101872: PUSH
101873: LD_INT 30
101875: PUSH
101876: LD_INT 1
101878: PUSH
101879: EMPTY
101880: LIST
101881: LIST
101882: PUSH
101883: EMPTY
101884: LIST
101885: LIST
101886: LIST
101887: PUSH
101888: EMPTY
101889: LIST
101890: LIST
101891: PPUSH
101892: CALL_OW 69
101896: ST_TO_ADDR
// if not depot then
101897: LD_VAR 0 1
101901: NOT
101902: IFFALSE 101906
// exit ;
101904: GO 101941
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101906: LD_VAR 0 1
101910: PUSH
101911: LD_INT 1
101913: ARRAY
101914: PPUSH
101915: CALL_OW 250
101919: PPUSH
101920: LD_VAR 0 1
101924: PUSH
101925: LD_INT 1
101927: ARRAY
101928: PPUSH
101929: CALL_OW 251
101933: PPUSH
101934: LD_INT 70
101936: PPUSH
101937: CALL_OW 495
// end ;
101941: PPOPN 1
101943: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101944: LD_EXP 98
101948: PUSH
101949: LD_EXP 132
101953: AND
101954: IFFALSE 102165
101956: GO 101958
101958: DISABLE
101959: LD_INT 0
101961: PPUSH
101962: PPUSH
101963: PPUSH
101964: PPUSH
101965: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101966: LD_ADDR_VAR 0 5
101970: PUSH
101971: LD_INT 22
101973: PUSH
101974: LD_OWVAR 2
101978: PUSH
101979: EMPTY
101980: LIST
101981: LIST
101982: PUSH
101983: LD_INT 21
101985: PUSH
101986: LD_INT 1
101988: PUSH
101989: EMPTY
101990: LIST
101991: LIST
101992: PUSH
101993: EMPTY
101994: LIST
101995: LIST
101996: PPUSH
101997: CALL_OW 69
102001: ST_TO_ADDR
// if not tmp then
102002: LD_VAR 0 5
102006: NOT
102007: IFFALSE 102011
// exit ;
102009: GO 102165
// for i in tmp do
102011: LD_ADDR_VAR 0 1
102015: PUSH
102016: LD_VAR 0 5
102020: PUSH
102021: FOR_IN
102022: IFFALSE 102163
// begin d := rand ( 0 , 5 ) ;
102024: LD_ADDR_VAR 0 4
102028: PUSH
102029: LD_INT 0
102031: PPUSH
102032: LD_INT 5
102034: PPUSH
102035: CALL_OW 12
102039: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
102040: LD_ADDR_VAR 0 2
102044: PUSH
102045: LD_VAR 0 1
102049: PPUSH
102050: CALL_OW 250
102054: PPUSH
102055: LD_VAR 0 4
102059: PPUSH
102060: LD_INT 3
102062: PPUSH
102063: LD_INT 12
102065: PPUSH
102066: CALL_OW 12
102070: PPUSH
102071: CALL_OW 272
102075: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
102076: LD_ADDR_VAR 0 3
102080: PUSH
102081: LD_VAR 0 1
102085: PPUSH
102086: CALL_OW 251
102090: PPUSH
102091: LD_VAR 0 4
102095: PPUSH
102096: LD_INT 3
102098: PPUSH
102099: LD_INT 12
102101: PPUSH
102102: CALL_OW 12
102106: PPUSH
102107: CALL_OW 273
102111: ST_TO_ADDR
// if ValidHex ( x , y ) then
102112: LD_VAR 0 2
102116: PPUSH
102117: LD_VAR 0 3
102121: PPUSH
102122: CALL_OW 488
102126: IFFALSE 102161
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
102128: LD_VAR 0 1
102132: PPUSH
102133: LD_VAR 0 2
102137: PPUSH
102138: LD_VAR 0 3
102142: PPUSH
102143: LD_INT 3
102145: PPUSH
102146: LD_INT 6
102148: PPUSH
102149: CALL_OW 12
102153: PPUSH
102154: LD_INT 1
102156: PPUSH
102157: CALL_OW 483
// end ;
102161: GO 102021
102163: POP
102164: POP
// end ;
102165: PPOPN 5
102167: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
102168: LD_EXP 98
102172: PUSH
102173: LD_EXP 133
102177: AND
102178: IFFALSE 102272
102180: GO 102182
102182: DISABLE
102183: LD_INT 0
102185: PPUSH
102186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
102187: LD_ADDR_VAR 0 2
102191: PUSH
102192: LD_INT 22
102194: PUSH
102195: LD_OWVAR 2
102199: PUSH
102200: EMPTY
102201: LIST
102202: LIST
102203: PUSH
102204: LD_INT 32
102206: PUSH
102207: LD_INT 1
102209: PUSH
102210: EMPTY
102211: LIST
102212: LIST
102213: PUSH
102214: LD_INT 21
102216: PUSH
102217: LD_INT 2
102219: PUSH
102220: EMPTY
102221: LIST
102222: LIST
102223: PUSH
102224: EMPTY
102225: LIST
102226: LIST
102227: LIST
102228: PPUSH
102229: CALL_OW 69
102233: ST_TO_ADDR
// if not tmp then
102234: LD_VAR 0 2
102238: NOT
102239: IFFALSE 102243
// exit ;
102241: GO 102272
// for i in tmp do
102243: LD_ADDR_VAR 0 1
102247: PUSH
102248: LD_VAR 0 2
102252: PUSH
102253: FOR_IN
102254: IFFALSE 102270
// SetFuel ( i , 0 ) ;
102256: LD_VAR 0 1
102260: PPUSH
102261: LD_INT 0
102263: PPUSH
102264: CALL_OW 240
102268: GO 102253
102270: POP
102271: POP
// end ;
102272: PPOPN 2
102274: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
102275: LD_EXP 98
102279: PUSH
102280: LD_EXP 134
102284: AND
102285: IFFALSE 102351
102287: GO 102289
102289: DISABLE
102290: LD_INT 0
102292: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102293: LD_ADDR_VAR 0 1
102297: PUSH
102298: LD_INT 22
102300: PUSH
102301: LD_OWVAR 2
102305: PUSH
102306: EMPTY
102307: LIST
102308: LIST
102309: PUSH
102310: LD_INT 30
102312: PUSH
102313: LD_INT 29
102315: PUSH
102316: EMPTY
102317: LIST
102318: LIST
102319: PUSH
102320: EMPTY
102321: LIST
102322: LIST
102323: PPUSH
102324: CALL_OW 69
102328: ST_TO_ADDR
// if not tmp then
102329: LD_VAR 0 1
102333: NOT
102334: IFFALSE 102338
// exit ;
102336: GO 102351
// DestroyUnit ( tmp [ 1 ] ) ;
102338: LD_VAR 0 1
102342: PUSH
102343: LD_INT 1
102345: ARRAY
102346: PPUSH
102347: CALL_OW 65
// end ;
102351: PPOPN 1
102353: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102354: LD_EXP 98
102358: PUSH
102359: LD_EXP 136
102363: AND
102364: IFFALSE 102493
102366: GO 102368
102368: DISABLE
102369: LD_INT 0
102371: PPUSH
// begin uc_side := 0 ;
102372: LD_ADDR_OWVAR 20
102376: PUSH
102377: LD_INT 0
102379: ST_TO_ADDR
// uc_nation := nation_arabian ;
102380: LD_ADDR_OWVAR 21
102384: PUSH
102385: LD_INT 2
102387: ST_TO_ADDR
// hc_gallery :=  ;
102388: LD_ADDR_OWVAR 33
102392: PUSH
102393: LD_STRING 
102395: ST_TO_ADDR
// hc_name :=  ;
102396: LD_ADDR_OWVAR 26
102400: PUSH
102401: LD_STRING 
102403: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102404: LD_INT 1
102406: PPUSH
102407: LD_INT 11
102409: PPUSH
102410: LD_INT 10
102412: PPUSH
102413: CALL_OW 380
// un := CreateHuman ;
102417: LD_ADDR_VAR 0 1
102421: PUSH
102422: CALL_OW 44
102426: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102427: LD_VAR 0 1
102431: PPUSH
102432: LD_INT 1
102434: PPUSH
102435: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102439: LD_INT 35
102441: PPUSH
102442: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102446: LD_VAR 0 1
102450: PPUSH
102451: LD_INT 22
102453: PUSH
102454: LD_OWVAR 2
102458: PUSH
102459: EMPTY
102460: LIST
102461: LIST
102462: PPUSH
102463: CALL_OW 69
102467: PPUSH
102468: LD_VAR 0 1
102472: PPUSH
102473: CALL_OW 74
102477: PPUSH
102478: CALL_OW 115
// until IsDead ( un ) ;
102482: LD_VAR 0 1
102486: PPUSH
102487: CALL_OW 301
102491: IFFALSE 102439
// end ;
102493: PPOPN 1
102495: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102496: LD_EXP 98
102500: PUSH
102501: LD_EXP 138
102505: AND
102506: IFFALSE 102518
102508: GO 102510
102510: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102511: LD_STRING earthquake(getX(game), 0, 32)
102513: PPUSH
102514: CALL_OW 559
102518: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102519: LD_EXP 98
102523: PUSH
102524: LD_EXP 139
102528: AND
102529: IFFALSE 102620
102531: GO 102533
102533: DISABLE
102534: LD_INT 0
102536: PPUSH
// begin enable ;
102537: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102538: LD_ADDR_VAR 0 1
102542: PUSH
102543: LD_INT 22
102545: PUSH
102546: LD_OWVAR 2
102550: PUSH
102551: EMPTY
102552: LIST
102553: LIST
102554: PUSH
102555: LD_INT 21
102557: PUSH
102558: LD_INT 2
102560: PUSH
102561: EMPTY
102562: LIST
102563: LIST
102564: PUSH
102565: LD_INT 33
102567: PUSH
102568: LD_INT 3
102570: PUSH
102571: EMPTY
102572: LIST
102573: LIST
102574: PUSH
102575: EMPTY
102576: LIST
102577: LIST
102578: LIST
102579: PPUSH
102580: CALL_OW 69
102584: ST_TO_ADDR
// if not tmp then
102585: LD_VAR 0 1
102589: NOT
102590: IFFALSE 102594
// exit ;
102592: GO 102620
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102594: LD_VAR 0 1
102598: PUSH
102599: LD_INT 1
102601: PPUSH
102602: LD_VAR 0 1
102606: PPUSH
102607: CALL_OW 12
102611: ARRAY
102612: PPUSH
102613: LD_INT 1
102615: PPUSH
102616: CALL_OW 234
// end ;
102620: PPOPN 1
102622: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102623: LD_EXP 98
102627: PUSH
102628: LD_EXP 140
102632: AND
102633: IFFALSE 102774
102635: GO 102637
102637: DISABLE
102638: LD_INT 0
102640: PPUSH
102641: PPUSH
102642: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102643: LD_ADDR_VAR 0 3
102647: PUSH
102648: LD_INT 22
102650: PUSH
102651: LD_OWVAR 2
102655: PUSH
102656: EMPTY
102657: LIST
102658: LIST
102659: PUSH
102660: LD_INT 25
102662: PUSH
102663: LD_INT 1
102665: PUSH
102666: EMPTY
102667: LIST
102668: LIST
102669: PUSH
102670: EMPTY
102671: LIST
102672: LIST
102673: PPUSH
102674: CALL_OW 69
102678: ST_TO_ADDR
// if not tmp then
102679: LD_VAR 0 3
102683: NOT
102684: IFFALSE 102688
// exit ;
102686: GO 102774
// un := tmp [ rand ( 1 , tmp ) ] ;
102688: LD_ADDR_VAR 0 2
102692: PUSH
102693: LD_VAR 0 3
102697: PUSH
102698: LD_INT 1
102700: PPUSH
102701: LD_VAR 0 3
102705: PPUSH
102706: CALL_OW 12
102710: ARRAY
102711: ST_TO_ADDR
// if Crawls ( un ) then
102712: LD_VAR 0 2
102716: PPUSH
102717: CALL_OW 318
102721: IFFALSE 102732
// ComWalk ( un ) ;
102723: LD_VAR 0 2
102727: PPUSH
102728: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102732: LD_VAR 0 2
102736: PPUSH
102737: LD_INT 9
102739: PPUSH
102740: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102744: LD_INT 28
102746: PPUSH
102747: LD_OWVAR 2
102751: PPUSH
102752: LD_INT 2
102754: PPUSH
102755: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102759: LD_INT 29
102761: PPUSH
102762: LD_OWVAR 2
102766: PPUSH
102767: LD_INT 2
102769: PPUSH
102770: CALL_OW 322
// end ;
102774: PPOPN 3
102776: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102777: LD_EXP 98
102781: PUSH
102782: LD_EXP 141
102786: AND
102787: IFFALSE 102898
102789: GO 102791
102791: DISABLE
102792: LD_INT 0
102794: PPUSH
102795: PPUSH
102796: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102797: LD_ADDR_VAR 0 3
102801: PUSH
102802: LD_INT 22
102804: PUSH
102805: LD_OWVAR 2
102809: PUSH
102810: EMPTY
102811: LIST
102812: LIST
102813: PUSH
102814: LD_INT 25
102816: PUSH
102817: LD_INT 1
102819: PUSH
102820: EMPTY
102821: LIST
102822: LIST
102823: PUSH
102824: EMPTY
102825: LIST
102826: LIST
102827: PPUSH
102828: CALL_OW 69
102832: ST_TO_ADDR
// if not tmp then
102833: LD_VAR 0 3
102837: NOT
102838: IFFALSE 102842
// exit ;
102840: GO 102898
// un := tmp [ rand ( 1 , tmp ) ] ;
102842: LD_ADDR_VAR 0 2
102846: PUSH
102847: LD_VAR 0 3
102851: PUSH
102852: LD_INT 1
102854: PPUSH
102855: LD_VAR 0 3
102859: PPUSH
102860: CALL_OW 12
102864: ARRAY
102865: ST_TO_ADDR
// if Crawls ( un ) then
102866: LD_VAR 0 2
102870: PPUSH
102871: CALL_OW 318
102875: IFFALSE 102886
// ComWalk ( un ) ;
102877: LD_VAR 0 2
102881: PPUSH
102882: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102886: LD_VAR 0 2
102890: PPUSH
102891: LD_INT 8
102893: PPUSH
102894: CALL_OW 336
// end ;
102898: PPOPN 3
102900: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102901: LD_EXP 98
102905: PUSH
102906: LD_EXP 142
102910: AND
102911: IFFALSE 103055
102913: GO 102915
102915: DISABLE
102916: LD_INT 0
102918: PPUSH
102919: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102920: LD_ADDR_VAR 0 2
102924: PUSH
102925: LD_INT 22
102927: PUSH
102928: LD_OWVAR 2
102932: PUSH
102933: EMPTY
102934: LIST
102935: LIST
102936: PUSH
102937: LD_INT 21
102939: PUSH
102940: LD_INT 2
102942: PUSH
102943: EMPTY
102944: LIST
102945: LIST
102946: PUSH
102947: LD_INT 2
102949: PUSH
102950: LD_INT 34
102952: PUSH
102953: LD_INT 12
102955: PUSH
102956: EMPTY
102957: LIST
102958: LIST
102959: PUSH
102960: LD_INT 34
102962: PUSH
102963: LD_INT 51
102965: PUSH
102966: EMPTY
102967: LIST
102968: LIST
102969: PUSH
102970: LD_INT 34
102972: PUSH
102973: LD_INT 32
102975: PUSH
102976: EMPTY
102977: LIST
102978: LIST
102979: PUSH
102980: EMPTY
102981: LIST
102982: LIST
102983: LIST
102984: LIST
102985: PUSH
102986: EMPTY
102987: LIST
102988: LIST
102989: LIST
102990: PPUSH
102991: CALL_OW 69
102995: ST_TO_ADDR
// if not tmp then
102996: LD_VAR 0 2
103000: NOT
103001: IFFALSE 103005
// exit ;
103003: GO 103055
// for i in tmp do
103005: LD_ADDR_VAR 0 1
103009: PUSH
103010: LD_VAR 0 2
103014: PUSH
103015: FOR_IN
103016: IFFALSE 103053
// if GetCargo ( i , mat_artifact ) = 0 then
103018: LD_VAR 0 1
103022: PPUSH
103023: LD_INT 4
103025: PPUSH
103026: CALL_OW 289
103030: PUSH
103031: LD_INT 0
103033: EQUAL
103034: IFFALSE 103051
// SetCargo ( i , mat_siberit , 100 ) ;
103036: LD_VAR 0 1
103040: PPUSH
103041: LD_INT 3
103043: PPUSH
103044: LD_INT 100
103046: PPUSH
103047: CALL_OW 290
103051: GO 103015
103053: POP
103054: POP
// end ;
103055: PPOPN 2
103057: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
103058: LD_EXP 98
103062: PUSH
103063: LD_EXP 143
103067: AND
103068: IFFALSE 103251
103070: GO 103072
103072: DISABLE
103073: LD_INT 0
103075: PPUSH
103076: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103077: LD_ADDR_VAR 0 2
103081: PUSH
103082: LD_INT 22
103084: PUSH
103085: LD_OWVAR 2
103089: PUSH
103090: EMPTY
103091: LIST
103092: LIST
103093: PPUSH
103094: CALL_OW 69
103098: ST_TO_ADDR
// if not tmp then
103099: LD_VAR 0 2
103103: NOT
103104: IFFALSE 103108
// exit ;
103106: GO 103251
// for i := 1 to 2 do
103108: LD_ADDR_VAR 0 1
103112: PUSH
103113: DOUBLE
103114: LD_INT 1
103116: DEC
103117: ST_TO_ADDR
103118: LD_INT 2
103120: PUSH
103121: FOR_TO
103122: IFFALSE 103249
// begin uc_side := your_side ;
103124: LD_ADDR_OWVAR 20
103128: PUSH
103129: LD_OWVAR 2
103133: ST_TO_ADDR
// uc_nation := nation_american ;
103134: LD_ADDR_OWVAR 21
103138: PUSH
103139: LD_INT 1
103141: ST_TO_ADDR
// vc_chassis := us_morphling ;
103142: LD_ADDR_OWVAR 37
103146: PUSH
103147: LD_INT 5
103149: ST_TO_ADDR
// vc_engine := engine_siberite ;
103150: LD_ADDR_OWVAR 39
103154: PUSH
103155: LD_INT 3
103157: ST_TO_ADDR
// vc_control := control_computer ;
103158: LD_ADDR_OWVAR 38
103162: PUSH
103163: LD_INT 3
103165: ST_TO_ADDR
// vc_weapon := us_double_laser ;
103166: LD_ADDR_OWVAR 40
103170: PUSH
103171: LD_INT 10
103173: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
103174: LD_VAR 0 2
103178: PUSH
103179: LD_INT 1
103181: ARRAY
103182: PPUSH
103183: CALL_OW 310
103187: NOT
103188: IFFALSE 103235
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
103190: CALL_OW 45
103194: PPUSH
103195: LD_VAR 0 2
103199: PUSH
103200: LD_INT 1
103202: ARRAY
103203: PPUSH
103204: CALL_OW 250
103208: PPUSH
103209: LD_VAR 0 2
103213: PUSH
103214: LD_INT 1
103216: ARRAY
103217: PPUSH
103218: CALL_OW 251
103222: PPUSH
103223: LD_INT 12
103225: PPUSH
103226: LD_INT 1
103228: PPUSH
103229: CALL_OW 50
103233: GO 103247
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
103235: CALL_OW 45
103239: PPUSH
103240: LD_INT 1
103242: PPUSH
103243: CALL_OW 51
// end ;
103247: GO 103121
103249: POP
103250: POP
// end ;
103251: PPOPN 2
103253: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
103254: LD_EXP 98
103258: PUSH
103259: LD_EXP 144
103263: AND
103264: IFFALSE 103486
103266: GO 103268
103268: DISABLE
103269: LD_INT 0
103271: PPUSH
103272: PPUSH
103273: PPUSH
103274: PPUSH
103275: PPUSH
103276: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103277: LD_ADDR_VAR 0 6
103281: PUSH
103282: LD_INT 22
103284: PUSH
103285: LD_OWVAR 2
103289: PUSH
103290: EMPTY
103291: LIST
103292: LIST
103293: PUSH
103294: LD_INT 21
103296: PUSH
103297: LD_INT 1
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: PUSH
103304: LD_INT 3
103306: PUSH
103307: LD_INT 23
103309: PUSH
103310: LD_INT 0
103312: PUSH
103313: EMPTY
103314: LIST
103315: LIST
103316: PUSH
103317: EMPTY
103318: LIST
103319: LIST
103320: PUSH
103321: EMPTY
103322: LIST
103323: LIST
103324: LIST
103325: PPUSH
103326: CALL_OW 69
103330: ST_TO_ADDR
// if not tmp then
103331: LD_VAR 0 6
103335: NOT
103336: IFFALSE 103340
// exit ;
103338: GO 103486
// s1 := rand ( 1 , 4 ) ;
103340: LD_ADDR_VAR 0 2
103344: PUSH
103345: LD_INT 1
103347: PPUSH
103348: LD_INT 4
103350: PPUSH
103351: CALL_OW 12
103355: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103356: LD_ADDR_VAR 0 4
103360: PUSH
103361: LD_VAR 0 6
103365: PUSH
103366: LD_INT 1
103368: ARRAY
103369: PPUSH
103370: LD_VAR 0 2
103374: PPUSH
103375: CALL_OW 259
103379: ST_TO_ADDR
// if s1 = 1 then
103380: LD_VAR 0 2
103384: PUSH
103385: LD_INT 1
103387: EQUAL
103388: IFFALSE 103408
// s2 := rand ( 2 , 4 ) else
103390: LD_ADDR_VAR 0 3
103394: PUSH
103395: LD_INT 2
103397: PPUSH
103398: LD_INT 4
103400: PPUSH
103401: CALL_OW 12
103405: ST_TO_ADDR
103406: GO 103416
// s2 := 1 ;
103408: LD_ADDR_VAR 0 3
103412: PUSH
103413: LD_INT 1
103415: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103416: LD_ADDR_VAR 0 5
103420: PUSH
103421: LD_VAR 0 6
103425: PUSH
103426: LD_INT 1
103428: ARRAY
103429: PPUSH
103430: LD_VAR 0 3
103434: PPUSH
103435: CALL_OW 259
103439: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103440: LD_VAR 0 6
103444: PUSH
103445: LD_INT 1
103447: ARRAY
103448: PPUSH
103449: LD_VAR 0 2
103453: PPUSH
103454: LD_VAR 0 5
103458: PPUSH
103459: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103463: LD_VAR 0 6
103467: PUSH
103468: LD_INT 1
103470: ARRAY
103471: PPUSH
103472: LD_VAR 0 3
103476: PPUSH
103477: LD_VAR 0 4
103481: PPUSH
103482: CALL_OW 237
// end ;
103486: PPOPN 6
103488: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103489: LD_EXP 98
103493: PUSH
103494: LD_EXP 145
103498: AND
103499: IFFALSE 103578
103501: GO 103503
103503: DISABLE
103504: LD_INT 0
103506: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103507: LD_ADDR_VAR 0 1
103511: PUSH
103512: LD_INT 22
103514: PUSH
103515: LD_OWVAR 2
103519: PUSH
103520: EMPTY
103521: LIST
103522: LIST
103523: PUSH
103524: LD_INT 30
103526: PUSH
103527: LD_INT 3
103529: PUSH
103530: EMPTY
103531: LIST
103532: LIST
103533: PUSH
103534: EMPTY
103535: LIST
103536: LIST
103537: PPUSH
103538: CALL_OW 69
103542: ST_TO_ADDR
// if not tmp then
103543: LD_VAR 0 1
103547: NOT
103548: IFFALSE 103552
// exit ;
103550: GO 103578
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103552: LD_VAR 0 1
103556: PUSH
103557: LD_INT 1
103559: PPUSH
103560: LD_VAR 0 1
103564: PPUSH
103565: CALL_OW 12
103569: ARRAY
103570: PPUSH
103571: LD_INT 1
103573: PPUSH
103574: CALL_OW 234
// end ;
103578: PPOPN 1
103580: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103581: LD_EXP 98
103585: PUSH
103586: LD_EXP 146
103590: AND
103591: IFFALSE 103703
103593: GO 103595
103595: DISABLE
103596: LD_INT 0
103598: PPUSH
103599: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103600: LD_ADDR_VAR 0 2
103604: PUSH
103605: LD_INT 22
103607: PUSH
103608: LD_OWVAR 2
103612: PUSH
103613: EMPTY
103614: LIST
103615: LIST
103616: PUSH
103617: LD_INT 2
103619: PUSH
103620: LD_INT 30
103622: PUSH
103623: LD_INT 27
103625: PUSH
103626: EMPTY
103627: LIST
103628: LIST
103629: PUSH
103630: LD_INT 30
103632: PUSH
103633: LD_INT 26
103635: PUSH
103636: EMPTY
103637: LIST
103638: LIST
103639: PUSH
103640: LD_INT 30
103642: PUSH
103643: LD_INT 28
103645: PUSH
103646: EMPTY
103647: LIST
103648: LIST
103649: PUSH
103650: EMPTY
103651: LIST
103652: LIST
103653: LIST
103654: LIST
103655: PUSH
103656: EMPTY
103657: LIST
103658: LIST
103659: PPUSH
103660: CALL_OW 69
103664: ST_TO_ADDR
// if not tmp then
103665: LD_VAR 0 2
103669: NOT
103670: IFFALSE 103674
// exit ;
103672: GO 103703
// for i in tmp do
103674: LD_ADDR_VAR 0 1
103678: PUSH
103679: LD_VAR 0 2
103683: PUSH
103684: FOR_IN
103685: IFFALSE 103701
// SetLives ( i , 1 ) ;
103687: LD_VAR 0 1
103691: PPUSH
103692: LD_INT 1
103694: PPUSH
103695: CALL_OW 234
103699: GO 103684
103701: POP
103702: POP
// end ;
103703: PPOPN 2
103705: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103706: LD_EXP 98
103710: PUSH
103711: LD_EXP 147
103715: AND
103716: IFFALSE 104003
103718: GO 103720
103720: DISABLE
103721: LD_INT 0
103723: PPUSH
103724: PPUSH
103725: PPUSH
// begin i := rand ( 1 , 7 ) ;
103726: LD_ADDR_VAR 0 1
103730: PUSH
103731: LD_INT 1
103733: PPUSH
103734: LD_INT 7
103736: PPUSH
103737: CALL_OW 12
103741: ST_TO_ADDR
// case i of 1 :
103742: LD_VAR 0 1
103746: PUSH
103747: LD_INT 1
103749: DOUBLE
103750: EQUAL
103751: IFTRUE 103755
103753: GO 103765
103755: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103756: LD_STRING earthquake(getX(game), 0, 32)
103758: PPUSH
103759: CALL_OW 559
103763: GO 104003
103765: LD_INT 2
103767: DOUBLE
103768: EQUAL
103769: IFTRUE 103773
103771: GO 103787
103773: POP
// begin ToLua ( displayStucuk(); ) ;
103774: LD_STRING displayStucuk();
103776: PPUSH
103777: CALL_OW 559
// ResetFog ;
103781: CALL_OW 335
// end ; 3 :
103785: GO 104003
103787: LD_INT 3
103789: DOUBLE
103790: EQUAL
103791: IFTRUE 103795
103793: GO 103899
103795: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103796: LD_ADDR_VAR 0 2
103800: PUSH
103801: LD_INT 22
103803: PUSH
103804: LD_OWVAR 2
103808: PUSH
103809: EMPTY
103810: LIST
103811: LIST
103812: PUSH
103813: LD_INT 25
103815: PUSH
103816: LD_INT 1
103818: PUSH
103819: EMPTY
103820: LIST
103821: LIST
103822: PUSH
103823: EMPTY
103824: LIST
103825: LIST
103826: PPUSH
103827: CALL_OW 69
103831: ST_TO_ADDR
// if not tmp then
103832: LD_VAR 0 2
103836: NOT
103837: IFFALSE 103841
// exit ;
103839: GO 104003
// un := tmp [ rand ( 1 , tmp ) ] ;
103841: LD_ADDR_VAR 0 3
103845: PUSH
103846: LD_VAR 0 2
103850: PUSH
103851: LD_INT 1
103853: PPUSH
103854: LD_VAR 0 2
103858: PPUSH
103859: CALL_OW 12
103863: ARRAY
103864: ST_TO_ADDR
// if Crawls ( un ) then
103865: LD_VAR 0 3
103869: PPUSH
103870: CALL_OW 318
103874: IFFALSE 103885
// ComWalk ( un ) ;
103876: LD_VAR 0 3
103880: PPUSH
103881: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103885: LD_VAR 0 3
103889: PPUSH
103890: LD_INT 8
103892: PPUSH
103893: CALL_OW 336
// end ; 4 :
103897: GO 104003
103899: LD_INT 4
103901: DOUBLE
103902: EQUAL
103903: IFTRUE 103907
103905: GO 103981
103907: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103908: LD_ADDR_VAR 0 2
103912: PUSH
103913: LD_INT 22
103915: PUSH
103916: LD_OWVAR 2
103920: PUSH
103921: EMPTY
103922: LIST
103923: LIST
103924: PUSH
103925: LD_INT 30
103927: PUSH
103928: LD_INT 29
103930: PUSH
103931: EMPTY
103932: LIST
103933: LIST
103934: PUSH
103935: EMPTY
103936: LIST
103937: LIST
103938: PPUSH
103939: CALL_OW 69
103943: ST_TO_ADDR
// if not tmp then
103944: LD_VAR 0 2
103948: NOT
103949: IFFALSE 103953
// exit ;
103951: GO 104003
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103953: LD_VAR 0 2
103957: PUSH
103958: LD_INT 1
103960: ARRAY
103961: PPUSH
103962: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103966: LD_VAR 0 2
103970: PUSH
103971: LD_INT 1
103973: ARRAY
103974: PPUSH
103975: CALL_OW 65
// end ; 5 .. 7 :
103979: GO 104003
103981: LD_INT 5
103983: DOUBLE
103984: GREATEREQUAL
103985: IFFALSE 103993
103987: LD_INT 7
103989: DOUBLE
103990: LESSEQUAL
103991: IFTRUE 103995
103993: GO 104002
103995: POP
// StreamSibBomb ; end ;
103996: CALL 100240 0 0
104000: GO 104003
104002: POP
// end ;
104003: PPOPN 3
104005: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
104006: LD_EXP 98
104010: PUSH
104011: LD_EXP 148
104015: AND
104016: IFFALSE 104172
104018: GO 104020
104020: DISABLE
104021: LD_INT 0
104023: PPUSH
104024: PPUSH
104025: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
104026: LD_ADDR_VAR 0 2
104030: PUSH
104031: LD_INT 81
104033: PUSH
104034: LD_OWVAR 2
104038: PUSH
104039: EMPTY
104040: LIST
104041: LIST
104042: PUSH
104043: LD_INT 2
104045: PUSH
104046: LD_INT 21
104048: PUSH
104049: LD_INT 1
104051: PUSH
104052: EMPTY
104053: LIST
104054: LIST
104055: PUSH
104056: LD_INT 21
104058: PUSH
104059: LD_INT 2
104061: PUSH
104062: EMPTY
104063: LIST
104064: LIST
104065: PUSH
104066: EMPTY
104067: LIST
104068: LIST
104069: LIST
104070: PUSH
104071: EMPTY
104072: LIST
104073: LIST
104074: PPUSH
104075: CALL_OW 69
104079: ST_TO_ADDR
// if not tmp then
104080: LD_VAR 0 2
104084: NOT
104085: IFFALSE 104089
// exit ;
104087: GO 104172
// p := 0 ;
104089: LD_ADDR_VAR 0 3
104093: PUSH
104094: LD_INT 0
104096: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104097: LD_INT 35
104099: PPUSH
104100: CALL_OW 67
// p := p + 1 ;
104104: LD_ADDR_VAR 0 3
104108: PUSH
104109: LD_VAR 0 3
104113: PUSH
104114: LD_INT 1
104116: PLUS
104117: ST_TO_ADDR
// for i in tmp do
104118: LD_ADDR_VAR 0 1
104122: PUSH
104123: LD_VAR 0 2
104127: PUSH
104128: FOR_IN
104129: IFFALSE 104160
// if GetLives ( i ) < 1000 then
104131: LD_VAR 0 1
104135: PPUSH
104136: CALL_OW 256
104140: PUSH
104141: LD_INT 1000
104143: LESS
104144: IFFALSE 104158
// SetLives ( i , 1000 ) ;
104146: LD_VAR 0 1
104150: PPUSH
104151: LD_INT 1000
104153: PPUSH
104154: CALL_OW 234
104158: GO 104128
104160: POP
104161: POP
// until p > 20 ;
104162: LD_VAR 0 3
104166: PUSH
104167: LD_INT 20
104169: GREATER
104170: IFFALSE 104097
// end ;
104172: PPOPN 3
104174: END
// every 0 0$1 trigger StreamModeActive and sTime do
104175: LD_EXP 98
104179: PUSH
104180: LD_EXP 149
104184: AND
104185: IFFALSE 104220
104187: GO 104189
104189: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
104190: LD_INT 28
104192: PPUSH
104193: LD_OWVAR 2
104197: PPUSH
104198: LD_INT 2
104200: PPUSH
104201: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
104205: LD_INT 30
104207: PPUSH
104208: LD_OWVAR 2
104212: PPUSH
104213: LD_INT 2
104215: PPUSH
104216: CALL_OW 322
// end ;
104220: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
104221: LD_EXP 98
104225: PUSH
104226: LD_EXP 150
104230: AND
104231: IFFALSE 104352
104233: GO 104235
104235: DISABLE
104236: LD_INT 0
104238: PPUSH
104239: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
104240: LD_ADDR_VAR 0 2
104244: PUSH
104245: LD_INT 22
104247: PUSH
104248: LD_OWVAR 2
104252: PUSH
104253: EMPTY
104254: LIST
104255: LIST
104256: PUSH
104257: LD_INT 21
104259: PUSH
104260: LD_INT 1
104262: PUSH
104263: EMPTY
104264: LIST
104265: LIST
104266: PUSH
104267: LD_INT 3
104269: PUSH
104270: LD_INT 23
104272: PUSH
104273: LD_INT 0
104275: PUSH
104276: EMPTY
104277: LIST
104278: LIST
104279: PUSH
104280: EMPTY
104281: LIST
104282: LIST
104283: PUSH
104284: EMPTY
104285: LIST
104286: LIST
104287: LIST
104288: PPUSH
104289: CALL_OW 69
104293: ST_TO_ADDR
// if not tmp then
104294: LD_VAR 0 2
104298: NOT
104299: IFFALSE 104303
// exit ;
104301: GO 104352
// for i in tmp do
104303: LD_ADDR_VAR 0 1
104307: PUSH
104308: LD_VAR 0 2
104312: PUSH
104313: FOR_IN
104314: IFFALSE 104350
// begin if Crawls ( i ) then
104316: LD_VAR 0 1
104320: PPUSH
104321: CALL_OW 318
104325: IFFALSE 104336
// ComWalk ( i ) ;
104327: LD_VAR 0 1
104331: PPUSH
104332: CALL_OW 138
// SetClass ( i , 2 ) ;
104336: LD_VAR 0 1
104340: PPUSH
104341: LD_INT 2
104343: PPUSH
104344: CALL_OW 336
// end ;
104348: GO 104313
104350: POP
104351: POP
// end ;
104352: PPOPN 2
104354: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104355: LD_EXP 98
104359: PUSH
104360: LD_EXP 151
104364: AND
104365: IFFALSE 104653
104367: GO 104369
104369: DISABLE
104370: LD_INT 0
104372: PPUSH
104373: PPUSH
104374: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104375: LD_OWVAR 2
104379: PPUSH
104380: LD_INT 9
104382: PPUSH
104383: LD_INT 1
104385: PPUSH
104386: LD_INT 1
104388: PPUSH
104389: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104393: LD_INT 9
104395: PPUSH
104396: LD_OWVAR 2
104400: PPUSH
104401: CALL_OW 343
// uc_side := 9 ;
104405: LD_ADDR_OWVAR 20
104409: PUSH
104410: LD_INT 9
104412: ST_TO_ADDR
// uc_nation := 2 ;
104413: LD_ADDR_OWVAR 21
104417: PUSH
104418: LD_INT 2
104420: ST_TO_ADDR
// hc_name := Dark Warrior ;
104421: LD_ADDR_OWVAR 26
104425: PUSH
104426: LD_STRING Dark Warrior
104428: ST_TO_ADDR
// hc_gallery :=  ;
104429: LD_ADDR_OWVAR 33
104433: PUSH
104434: LD_STRING 
104436: ST_TO_ADDR
// hc_noskilllimit := true ;
104437: LD_ADDR_OWVAR 76
104441: PUSH
104442: LD_INT 1
104444: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104445: LD_ADDR_OWVAR 31
104449: PUSH
104450: LD_INT 30
104452: PUSH
104453: LD_INT 30
104455: PUSH
104456: LD_INT 30
104458: PUSH
104459: LD_INT 30
104461: PUSH
104462: EMPTY
104463: LIST
104464: LIST
104465: LIST
104466: LIST
104467: ST_TO_ADDR
// un := CreateHuman ;
104468: LD_ADDR_VAR 0 3
104472: PUSH
104473: CALL_OW 44
104477: ST_TO_ADDR
// hc_noskilllimit := false ;
104478: LD_ADDR_OWVAR 76
104482: PUSH
104483: LD_INT 0
104485: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104486: LD_VAR 0 3
104490: PPUSH
104491: LD_INT 1
104493: PPUSH
104494: CALL_OW 51
// ToLua ( playRanger() ) ;
104498: LD_STRING playRanger()
104500: PPUSH
104501: CALL_OW 559
// p := 0 ;
104505: LD_ADDR_VAR 0 2
104509: PUSH
104510: LD_INT 0
104512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104513: LD_INT 35
104515: PPUSH
104516: CALL_OW 67
// p := p + 1 ;
104520: LD_ADDR_VAR 0 2
104524: PUSH
104525: LD_VAR 0 2
104529: PUSH
104530: LD_INT 1
104532: PLUS
104533: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104534: LD_VAR 0 3
104538: PPUSH
104539: CALL_OW 256
104543: PUSH
104544: LD_INT 1000
104546: LESS
104547: IFFALSE 104561
// SetLives ( un , 1000 ) ;
104549: LD_VAR 0 3
104553: PPUSH
104554: LD_INT 1000
104556: PPUSH
104557: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104561: LD_VAR 0 3
104565: PPUSH
104566: LD_INT 81
104568: PUSH
104569: LD_OWVAR 2
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: PUSH
104578: LD_INT 91
104580: PUSH
104581: LD_VAR 0 3
104585: PUSH
104586: LD_INT 30
104588: PUSH
104589: EMPTY
104590: LIST
104591: LIST
104592: LIST
104593: PUSH
104594: EMPTY
104595: LIST
104596: LIST
104597: PPUSH
104598: CALL_OW 69
104602: PPUSH
104603: LD_VAR 0 3
104607: PPUSH
104608: CALL_OW 74
104612: PPUSH
104613: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104617: LD_VAR 0 2
104621: PUSH
104622: LD_INT 80
104624: GREATER
104625: PUSH
104626: LD_VAR 0 3
104630: PPUSH
104631: CALL_OW 301
104635: OR
104636: IFFALSE 104513
// if un then
104638: LD_VAR 0 3
104642: IFFALSE 104653
// RemoveUnit ( un ) ;
104644: LD_VAR 0 3
104648: PPUSH
104649: CALL_OW 64
// end ;
104653: PPOPN 3
104655: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104656: LD_EXP 152
104660: IFFALSE 104776
104662: GO 104664
104664: DISABLE
104665: LD_INT 0
104667: PPUSH
104668: PPUSH
104669: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104670: LD_ADDR_VAR 0 2
104674: PUSH
104675: LD_INT 81
104677: PUSH
104678: LD_OWVAR 2
104682: PUSH
104683: EMPTY
104684: LIST
104685: LIST
104686: PUSH
104687: LD_INT 21
104689: PUSH
104690: LD_INT 1
104692: PUSH
104693: EMPTY
104694: LIST
104695: LIST
104696: PUSH
104697: EMPTY
104698: LIST
104699: LIST
104700: PPUSH
104701: CALL_OW 69
104705: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104706: LD_STRING playComputer()
104708: PPUSH
104709: CALL_OW 559
// if not tmp then
104713: LD_VAR 0 2
104717: NOT
104718: IFFALSE 104722
// exit ;
104720: GO 104776
// for i in tmp do
104722: LD_ADDR_VAR 0 1
104726: PUSH
104727: LD_VAR 0 2
104731: PUSH
104732: FOR_IN
104733: IFFALSE 104774
// for j := 1 to 4 do
104735: LD_ADDR_VAR 0 3
104739: PUSH
104740: DOUBLE
104741: LD_INT 1
104743: DEC
104744: ST_TO_ADDR
104745: LD_INT 4
104747: PUSH
104748: FOR_TO
104749: IFFALSE 104770
// SetSkill ( i , j , 10 ) ;
104751: LD_VAR 0 1
104755: PPUSH
104756: LD_VAR 0 3
104760: PPUSH
104761: LD_INT 10
104763: PPUSH
104764: CALL_OW 237
104768: GO 104748
104770: POP
104771: POP
104772: GO 104732
104774: POP
104775: POP
// end ;
104776: PPOPN 3
104778: END
// every 0 0$1 trigger s30 do var i , tmp ;
104779: LD_EXP 153
104783: IFFALSE 104852
104785: GO 104787
104787: DISABLE
104788: LD_INT 0
104790: PPUSH
104791: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104792: LD_ADDR_VAR 0 2
104796: PUSH
104797: LD_INT 22
104799: PUSH
104800: LD_OWVAR 2
104804: PUSH
104805: EMPTY
104806: LIST
104807: LIST
104808: PPUSH
104809: CALL_OW 69
104813: ST_TO_ADDR
// if not tmp then
104814: LD_VAR 0 2
104818: NOT
104819: IFFALSE 104823
// exit ;
104821: GO 104852
// for i in tmp do
104823: LD_ADDR_VAR 0 1
104827: PUSH
104828: LD_VAR 0 2
104832: PUSH
104833: FOR_IN
104834: IFFALSE 104850
// SetLives ( i , 300 ) ;
104836: LD_VAR 0 1
104840: PPUSH
104841: LD_INT 300
104843: PPUSH
104844: CALL_OW 234
104848: GO 104833
104850: POP
104851: POP
// end ;
104852: PPOPN 2
104854: END
// every 0 0$1 trigger s60 do var i , tmp ;
104855: LD_EXP 154
104859: IFFALSE 104928
104861: GO 104863
104863: DISABLE
104864: LD_INT 0
104866: PPUSH
104867: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104868: LD_ADDR_VAR 0 2
104872: PUSH
104873: LD_INT 22
104875: PUSH
104876: LD_OWVAR 2
104880: PUSH
104881: EMPTY
104882: LIST
104883: LIST
104884: PPUSH
104885: CALL_OW 69
104889: ST_TO_ADDR
// if not tmp then
104890: LD_VAR 0 2
104894: NOT
104895: IFFALSE 104899
// exit ;
104897: GO 104928
// for i in tmp do
104899: LD_ADDR_VAR 0 1
104903: PUSH
104904: LD_VAR 0 2
104908: PUSH
104909: FOR_IN
104910: IFFALSE 104926
// SetLives ( i , 600 ) ;
104912: LD_VAR 0 1
104916: PPUSH
104917: LD_INT 600
104919: PPUSH
104920: CALL_OW 234
104924: GO 104909
104926: POP
104927: POP
// end ;
104928: PPOPN 2
104930: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104931: LD_INT 0
104933: PPUSH
// case cmd of 301 :
104934: LD_VAR 0 1
104938: PUSH
104939: LD_INT 301
104941: DOUBLE
104942: EQUAL
104943: IFTRUE 104947
104945: GO 104979
104947: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104948: LD_VAR 0 6
104952: PPUSH
104953: LD_VAR 0 7
104957: PPUSH
104958: LD_VAR 0 8
104962: PPUSH
104963: LD_VAR 0 4
104967: PPUSH
104968: LD_VAR 0 5
104972: PPUSH
104973: CALL 106180 0 5
104977: GO 105100
104979: LD_INT 302
104981: DOUBLE
104982: EQUAL
104983: IFTRUE 104987
104985: GO 105024
104987: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104988: LD_VAR 0 6
104992: PPUSH
104993: LD_VAR 0 7
104997: PPUSH
104998: LD_VAR 0 8
105002: PPUSH
105003: LD_VAR 0 9
105007: PPUSH
105008: LD_VAR 0 4
105012: PPUSH
105013: LD_VAR 0 5
105017: PPUSH
105018: CALL 106271 0 6
105022: GO 105100
105024: LD_INT 303
105026: DOUBLE
105027: EQUAL
105028: IFTRUE 105032
105030: GO 105069
105032: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
105033: LD_VAR 0 6
105037: PPUSH
105038: LD_VAR 0 7
105042: PPUSH
105043: LD_VAR 0 8
105047: PPUSH
105048: LD_VAR 0 9
105052: PPUSH
105053: LD_VAR 0 4
105057: PPUSH
105058: LD_VAR 0 5
105062: PPUSH
105063: CALL 105105 0 6
105067: GO 105100
105069: LD_INT 304
105071: DOUBLE
105072: EQUAL
105073: IFTRUE 105077
105075: GO 105099
105077: POP
// hHackTeleport ( unit , x , y ) ; end ;
105078: LD_VAR 0 2
105082: PPUSH
105083: LD_VAR 0 4
105087: PPUSH
105088: LD_VAR 0 5
105092: PPUSH
105093: CALL 106864 0 3
105097: GO 105100
105099: POP
// end ;
105100: LD_VAR 0 12
105104: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
105105: LD_INT 0
105107: PPUSH
105108: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
105109: LD_VAR 0 1
105113: PUSH
105114: LD_INT 1
105116: LESS
105117: PUSH
105118: LD_VAR 0 1
105122: PUSH
105123: LD_INT 3
105125: GREATER
105126: OR
105127: PUSH
105128: LD_VAR 0 5
105132: PPUSH
105133: LD_VAR 0 6
105137: PPUSH
105138: CALL_OW 428
105142: OR
105143: IFFALSE 105147
// exit ;
105145: GO 105867
// uc_side := your_side ;
105147: LD_ADDR_OWVAR 20
105151: PUSH
105152: LD_OWVAR 2
105156: ST_TO_ADDR
// uc_nation := nation ;
105157: LD_ADDR_OWVAR 21
105161: PUSH
105162: LD_VAR 0 1
105166: ST_TO_ADDR
// bc_level = 1 ;
105167: LD_ADDR_OWVAR 43
105171: PUSH
105172: LD_INT 1
105174: ST_TO_ADDR
// case btype of 1 :
105175: LD_VAR 0 2
105179: PUSH
105180: LD_INT 1
105182: DOUBLE
105183: EQUAL
105184: IFTRUE 105188
105186: GO 105199
105188: POP
// bc_type := b_depot ; 2 :
105189: LD_ADDR_OWVAR 42
105193: PUSH
105194: LD_INT 0
105196: ST_TO_ADDR
105197: GO 105811
105199: LD_INT 2
105201: DOUBLE
105202: EQUAL
105203: IFTRUE 105207
105205: GO 105218
105207: POP
// bc_type := b_warehouse ; 3 :
105208: LD_ADDR_OWVAR 42
105212: PUSH
105213: LD_INT 1
105215: ST_TO_ADDR
105216: GO 105811
105218: LD_INT 3
105220: DOUBLE
105221: EQUAL
105222: IFTRUE 105226
105224: GO 105237
105226: POP
// bc_type := b_lab ; 4 .. 9 :
105227: LD_ADDR_OWVAR 42
105231: PUSH
105232: LD_INT 6
105234: ST_TO_ADDR
105235: GO 105811
105237: LD_INT 4
105239: DOUBLE
105240: GREATEREQUAL
105241: IFFALSE 105249
105243: LD_INT 9
105245: DOUBLE
105246: LESSEQUAL
105247: IFTRUE 105251
105249: GO 105303
105251: POP
// begin bc_type := b_lab_half ;
105252: LD_ADDR_OWVAR 42
105256: PUSH
105257: LD_INT 7
105259: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
105260: LD_ADDR_OWVAR 44
105264: PUSH
105265: LD_INT 10
105267: PUSH
105268: LD_INT 11
105270: PUSH
105271: LD_INT 12
105273: PUSH
105274: LD_INT 15
105276: PUSH
105277: LD_INT 14
105279: PUSH
105280: LD_INT 13
105282: PUSH
105283: EMPTY
105284: LIST
105285: LIST
105286: LIST
105287: LIST
105288: LIST
105289: LIST
105290: PUSH
105291: LD_VAR 0 2
105295: PUSH
105296: LD_INT 3
105298: MINUS
105299: ARRAY
105300: ST_TO_ADDR
// end ; 10 .. 13 :
105301: GO 105811
105303: LD_INT 10
105305: DOUBLE
105306: GREATEREQUAL
105307: IFFALSE 105315
105309: LD_INT 13
105311: DOUBLE
105312: LESSEQUAL
105313: IFTRUE 105317
105315: GO 105394
105317: POP
// begin bc_type := b_lab_full ;
105318: LD_ADDR_OWVAR 42
105322: PUSH
105323: LD_INT 8
105325: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105326: LD_ADDR_OWVAR 44
105330: PUSH
105331: LD_INT 10
105333: PUSH
105334: LD_INT 12
105336: PUSH
105337: LD_INT 14
105339: PUSH
105340: LD_INT 13
105342: PUSH
105343: EMPTY
105344: LIST
105345: LIST
105346: LIST
105347: LIST
105348: PUSH
105349: LD_VAR 0 2
105353: PUSH
105354: LD_INT 9
105356: MINUS
105357: ARRAY
105358: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105359: LD_ADDR_OWVAR 45
105363: PUSH
105364: LD_INT 11
105366: PUSH
105367: LD_INT 15
105369: PUSH
105370: LD_INT 12
105372: PUSH
105373: LD_INT 15
105375: PUSH
105376: EMPTY
105377: LIST
105378: LIST
105379: LIST
105380: LIST
105381: PUSH
105382: LD_VAR 0 2
105386: PUSH
105387: LD_INT 9
105389: MINUS
105390: ARRAY
105391: ST_TO_ADDR
// end ; 14 :
105392: GO 105811
105394: LD_INT 14
105396: DOUBLE
105397: EQUAL
105398: IFTRUE 105402
105400: GO 105413
105402: POP
// bc_type := b_workshop ; 15 :
105403: LD_ADDR_OWVAR 42
105407: PUSH
105408: LD_INT 2
105410: ST_TO_ADDR
105411: GO 105811
105413: LD_INT 15
105415: DOUBLE
105416: EQUAL
105417: IFTRUE 105421
105419: GO 105432
105421: POP
// bc_type := b_factory ; 16 :
105422: LD_ADDR_OWVAR 42
105426: PUSH
105427: LD_INT 3
105429: ST_TO_ADDR
105430: GO 105811
105432: LD_INT 16
105434: DOUBLE
105435: EQUAL
105436: IFTRUE 105440
105438: GO 105451
105440: POP
// bc_type := b_ext_gun ; 17 :
105441: LD_ADDR_OWVAR 42
105445: PUSH
105446: LD_INT 17
105448: ST_TO_ADDR
105449: GO 105811
105451: LD_INT 17
105453: DOUBLE
105454: EQUAL
105455: IFTRUE 105459
105457: GO 105487
105459: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105460: LD_ADDR_OWVAR 42
105464: PUSH
105465: LD_INT 19
105467: PUSH
105468: LD_INT 23
105470: PUSH
105471: LD_INT 19
105473: PUSH
105474: EMPTY
105475: LIST
105476: LIST
105477: LIST
105478: PUSH
105479: LD_VAR 0 1
105483: ARRAY
105484: ST_TO_ADDR
105485: GO 105811
105487: LD_INT 18
105489: DOUBLE
105490: EQUAL
105491: IFTRUE 105495
105493: GO 105506
105495: POP
// bc_type := b_ext_radar ; 19 :
105496: LD_ADDR_OWVAR 42
105500: PUSH
105501: LD_INT 20
105503: ST_TO_ADDR
105504: GO 105811
105506: LD_INT 19
105508: DOUBLE
105509: EQUAL
105510: IFTRUE 105514
105512: GO 105525
105514: POP
// bc_type := b_ext_radio ; 20 :
105515: LD_ADDR_OWVAR 42
105519: PUSH
105520: LD_INT 22
105522: ST_TO_ADDR
105523: GO 105811
105525: LD_INT 20
105527: DOUBLE
105528: EQUAL
105529: IFTRUE 105533
105531: GO 105544
105533: POP
// bc_type := b_ext_siberium ; 21 :
105534: LD_ADDR_OWVAR 42
105538: PUSH
105539: LD_INT 21
105541: ST_TO_ADDR
105542: GO 105811
105544: LD_INT 21
105546: DOUBLE
105547: EQUAL
105548: IFTRUE 105552
105550: GO 105563
105552: POP
// bc_type := b_ext_computer ; 22 :
105553: LD_ADDR_OWVAR 42
105557: PUSH
105558: LD_INT 24
105560: ST_TO_ADDR
105561: GO 105811
105563: LD_INT 22
105565: DOUBLE
105566: EQUAL
105567: IFTRUE 105571
105569: GO 105582
105571: POP
// bc_type := b_ext_track ; 23 :
105572: LD_ADDR_OWVAR 42
105576: PUSH
105577: LD_INT 16
105579: ST_TO_ADDR
105580: GO 105811
105582: LD_INT 23
105584: DOUBLE
105585: EQUAL
105586: IFTRUE 105590
105588: GO 105601
105590: POP
// bc_type := b_ext_laser ; 24 :
105591: LD_ADDR_OWVAR 42
105595: PUSH
105596: LD_INT 25
105598: ST_TO_ADDR
105599: GO 105811
105601: LD_INT 24
105603: DOUBLE
105604: EQUAL
105605: IFTRUE 105609
105607: GO 105620
105609: POP
// bc_type := b_control_tower ; 25 :
105610: LD_ADDR_OWVAR 42
105614: PUSH
105615: LD_INT 36
105617: ST_TO_ADDR
105618: GO 105811
105620: LD_INT 25
105622: DOUBLE
105623: EQUAL
105624: IFTRUE 105628
105626: GO 105639
105628: POP
// bc_type := b_breastwork ; 26 :
105629: LD_ADDR_OWVAR 42
105633: PUSH
105634: LD_INT 31
105636: ST_TO_ADDR
105637: GO 105811
105639: LD_INT 26
105641: DOUBLE
105642: EQUAL
105643: IFTRUE 105647
105645: GO 105658
105647: POP
// bc_type := b_bunker ; 27 :
105648: LD_ADDR_OWVAR 42
105652: PUSH
105653: LD_INT 32
105655: ST_TO_ADDR
105656: GO 105811
105658: LD_INT 27
105660: DOUBLE
105661: EQUAL
105662: IFTRUE 105666
105664: GO 105677
105666: POP
// bc_type := b_turret ; 28 :
105667: LD_ADDR_OWVAR 42
105671: PUSH
105672: LD_INT 33
105674: ST_TO_ADDR
105675: GO 105811
105677: LD_INT 28
105679: DOUBLE
105680: EQUAL
105681: IFTRUE 105685
105683: GO 105696
105685: POP
// bc_type := b_armoury ; 29 :
105686: LD_ADDR_OWVAR 42
105690: PUSH
105691: LD_INT 4
105693: ST_TO_ADDR
105694: GO 105811
105696: LD_INT 29
105698: DOUBLE
105699: EQUAL
105700: IFTRUE 105704
105702: GO 105715
105704: POP
// bc_type := b_barracks ; 30 :
105705: LD_ADDR_OWVAR 42
105709: PUSH
105710: LD_INT 5
105712: ST_TO_ADDR
105713: GO 105811
105715: LD_INT 30
105717: DOUBLE
105718: EQUAL
105719: IFTRUE 105723
105721: GO 105734
105723: POP
// bc_type := b_solar_power ; 31 :
105724: LD_ADDR_OWVAR 42
105728: PUSH
105729: LD_INT 27
105731: ST_TO_ADDR
105732: GO 105811
105734: LD_INT 31
105736: DOUBLE
105737: EQUAL
105738: IFTRUE 105742
105740: GO 105753
105742: POP
// bc_type := b_oil_power ; 32 :
105743: LD_ADDR_OWVAR 42
105747: PUSH
105748: LD_INT 26
105750: ST_TO_ADDR
105751: GO 105811
105753: LD_INT 32
105755: DOUBLE
105756: EQUAL
105757: IFTRUE 105761
105759: GO 105772
105761: POP
// bc_type := b_siberite_power ; 33 :
105762: LD_ADDR_OWVAR 42
105766: PUSH
105767: LD_INT 28
105769: ST_TO_ADDR
105770: GO 105811
105772: LD_INT 33
105774: DOUBLE
105775: EQUAL
105776: IFTRUE 105780
105778: GO 105791
105780: POP
// bc_type := b_oil_mine ; 34 :
105781: LD_ADDR_OWVAR 42
105785: PUSH
105786: LD_INT 29
105788: ST_TO_ADDR
105789: GO 105811
105791: LD_INT 34
105793: DOUBLE
105794: EQUAL
105795: IFTRUE 105799
105797: GO 105810
105799: POP
// bc_type := b_siberite_mine ; end ;
105800: LD_ADDR_OWVAR 42
105804: PUSH
105805: LD_INT 30
105807: ST_TO_ADDR
105808: GO 105811
105810: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105811: LD_ADDR_VAR 0 8
105815: PUSH
105816: LD_VAR 0 5
105820: PPUSH
105821: LD_VAR 0 6
105825: PPUSH
105826: LD_VAR 0 3
105830: PPUSH
105831: CALL_OW 47
105835: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105836: LD_OWVAR 42
105840: PUSH
105841: LD_INT 32
105843: PUSH
105844: LD_INT 33
105846: PUSH
105847: EMPTY
105848: LIST
105849: LIST
105850: IN
105851: IFFALSE 105867
// PlaceWeaponTurret ( b , weapon ) ;
105853: LD_VAR 0 8
105857: PPUSH
105858: LD_VAR 0 4
105862: PPUSH
105863: CALL_OW 431
// end ;
105867: LD_VAR 0 7
105871: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105872: LD_INT 0
105874: PPUSH
105875: PPUSH
105876: PPUSH
105877: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105878: LD_ADDR_VAR 0 4
105882: PUSH
105883: LD_INT 22
105885: PUSH
105886: LD_OWVAR 2
105890: PUSH
105891: EMPTY
105892: LIST
105893: LIST
105894: PUSH
105895: LD_INT 2
105897: PUSH
105898: LD_INT 30
105900: PUSH
105901: LD_INT 0
105903: PUSH
105904: EMPTY
105905: LIST
105906: LIST
105907: PUSH
105908: LD_INT 30
105910: PUSH
105911: LD_INT 1
105913: PUSH
105914: EMPTY
105915: LIST
105916: LIST
105917: PUSH
105918: EMPTY
105919: LIST
105920: LIST
105921: LIST
105922: PUSH
105923: EMPTY
105924: LIST
105925: LIST
105926: PPUSH
105927: CALL_OW 69
105931: ST_TO_ADDR
// if not tmp then
105932: LD_VAR 0 4
105936: NOT
105937: IFFALSE 105941
// exit ;
105939: GO 106000
// for i in tmp do
105941: LD_ADDR_VAR 0 2
105945: PUSH
105946: LD_VAR 0 4
105950: PUSH
105951: FOR_IN
105952: IFFALSE 105998
// for j = 1 to 3 do
105954: LD_ADDR_VAR 0 3
105958: PUSH
105959: DOUBLE
105960: LD_INT 1
105962: DEC
105963: ST_TO_ADDR
105964: LD_INT 3
105966: PUSH
105967: FOR_TO
105968: IFFALSE 105994
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105970: LD_VAR 0 2
105974: PPUSH
105975: CALL_OW 274
105979: PPUSH
105980: LD_VAR 0 3
105984: PPUSH
105985: LD_INT 99999
105987: PPUSH
105988: CALL_OW 277
105992: GO 105967
105994: POP
105995: POP
105996: GO 105951
105998: POP
105999: POP
// end ;
106000: LD_VAR 0 1
106004: RET
// export function hHackSetLevel10 ; var i , j ; begin
106005: LD_INT 0
106007: PPUSH
106008: PPUSH
106009: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106010: LD_ADDR_VAR 0 2
106014: PUSH
106015: LD_INT 21
106017: PUSH
106018: LD_INT 1
106020: PUSH
106021: EMPTY
106022: LIST
106023: LIST
106024: PPUSH
106025: CALL_OW 69
106029: PUSH
106030: FOR_IN
106031: IFFALSE 106083
// if IsSelected ( i ) then
106033: LD_VAR 0 2
106037: PPUSH
106038: CALL_OW 306
106042: IFFALSE 106081
// begin for j := 1 to 4 do
106044: LD_ADDR_VAR 0 3
106048: PUSH
106049: DOUBLE
106050: LD_INT 1
106052: DEC
106053: ST_TO_ADDR
106054: LD_INT 4
106056: PUSH
106057: FOR_TO
106058: IFFALSE 106079
// SetSkill ( i , j , 10 ) ;
106060: LD_VAR 0 2
106064: PPUSH
106065: LD_VAR 0 3
106069: PPUSH
106070: LD_INT 10
106072: PPUSH
106073: CALL_OW 237
106077: GO 106057
106079: POP
106080: POP
// end ;
106081: GO 106030
106083: POP
106084: POP
// end ;
106085: LD_VAR 0 1
106089: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
106090: LD_INT 0
106092: PPUSH
106093: PPUSH
106094: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
106095: LD_ADDR_VAR 0 2
106099: PUSH
106100: LD_INT 22
106102: PUSH
106103: LD_OWVAR 2
106107: PUSH
106108: EMPTY
106109: LIST
106110: LIST
106111: PUSH
106112: LD_INT 21
106114: PUSH
106115: LD_INT 1
106117: PUSH
106118: EMPTY
106119: LIST
106120: LIST
106121: PUSH
106122: EMPTY
106123: LIST
106124: LIST
106125: PPUSH
106126: CALL_OW 69
106130: PUSH
106131: FOR_IN
106132: IFFALSE 106173
// begin for j := 1 to 4 do
106134: LD_ADDR_VAR 0 3
106138: PUSH
106139: DOUBLE
106140: LD_INT 1
106142: DEC
106143: ST_TO_ADDR
106144: LD_INT 4
106146: PUSH
106147: FOR_TO
106148: IFFALSE 106169
// SetSkill ( i , j , 10 ) ;
106150: LD_VAR 0 2
106154: PPUSH
106155: LD_VAR 0 3
106159: PPUSH
106160: LD_INT 10
106162: PPUSH
106163: CALL_OW 237
106167: GO 106147
106169: POP
106170: POP
// end ;
106171: GO 106131
106173: POP
106174: POP
// end ;
106175: LD_VAR 0 1
106179: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
106180: LD_INT 0
106182: PPUSH
// uc_side := your_side ;
106183: LD_ADDR_OWVAR 20
106187: PUSH
106188: LD_OWVAR 2
106192: ST_TO_ADDR
// uc_nation := nation ;
106193: LD_ADDR_OWVAR 21
106197: PUSH
106198: LD_VAR 0 1
106202: ST_TO_ADDR
// InitHc ;
106203: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
106207: LD_INT 0
106209: PPUSH
106210: LD_VAR 0 2
106214: PPUSH
106215: LD_VAR 0 3
106219: PPUSH
106220: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
106224: LD_VAR 0 4
106228: PPUSH
106229: LD_VAR 0 5
106233: PPUSH
106234: CALL_OW 428
106238: PUSH
106239: LD_INT 0
106241: EQUAL
106242: IFFALSE 106266
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
106244: CALL_OW 44
106248: PPUSH
106249: LD_VAR 0 4
106253: PPUSH
106254: LD_VAR 0 5
106258: PPUSH
106259: LD_INT 1
106261: PPUSH
106262: CALL_OW 48
// end ;
106266: LD_VAR 0 6
106270: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
106271: LD_INT 0
106273: PPUSH
106274: PPUSH
// uc_side := your_side ;
106275: LD_ADDR_OWVAR 20
106279: PUSH
106280: LD_OWVAR 2
106284: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106285: LD_VAR 0 1
106289: PUSH
106290: LD_INT 1
106292: PUSH
106293: LD_INT 2
106295: PUSH
106296: LD_INT 3
106298: PUSH
106299: LD_INT 4
106301: PUSH
106302: LD_INT 5
106304: PUSH
106305: EMPTY
106306: LIST
106307: LIST
106308: LIST
106309: LIST
106310: LIST
106311: IN
106312: IFFALSE 106324
// uc_nation := nation_american else
106314: LD_ADDR_OWVAR 21
106318: PUSH
106319: LD_INT 1
106321: ST_TO_ADDR
106322: GO 106367
// if chassis in [ 11 , 12 , 13 , 14 ] then
106324: LD_VAR 0 1
106328: PUSH
106329: LD_INT 11
106331: PUSH
106332: LD_INT 12
106334: PUSH
106335: LD_INT 13
106337: PUSH
106338: LD_INT 14
106340: PUSH
106341: EMPTY
106342: LIST
106343: LIST
106344: LIST
106345: LIST
106346: IN
106347: IFFALSE 106359
// uc_nation := nation_arabian else
106349: LD_ADDR_OWVAR 21
106353: PUSH
106354: LD_INT 2
106356: ST_TO_ADDR
106357: GO 106367
// uc_nation := nation_russian ;
106359: LD_ADDR_OWVAR 21
106363: PUSH
106364: LD_INT 3
106366: ST_TO_ADDR
// vc_chassis := chassis ;
106367: LD_ADDR_OWVAR 37
106371: PUSH
106372: LD_VAR 0 1
106376: ST_TO_ADDR
// vc_engine := engine ;
106377: LD_ADDR_OWVAR 39
106381: PUSH
106382: LD_VAR 0 2
106386: ST_TO_ADDR
// vc_control := control ;
106387: LD_ADDR_OWVAR 38
106391: PUSH
106392: LD_VAR 0 3
106396: ST_TO_ADDR
// vc_weapon := weapon ;
106397: LD_ADDR_OWVAR 40
106401: PUSH
106402: LD_VAR 0 4
106406: ST_TO_ADDR
// un := CreateVehicle ;
106407: LD_ADDR_VAR 0 8
106411: PUSH
106412: CALL_OW 45
106416: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106417: LD_VAR 0 8
106421: PPUSH
106422: LD_INT 0
106424: PPUSH
106425: LD_INT 5
106427: PPUSH
106428: CALL_OW 12
106432: PPUSH
106433: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106437: LD_VAR 0 8
106441: PPUSH
106442: LD_VAR 0 5
106446: PPUSH
106447: LD_VAR 0 6
106451: PPUSH
106452: LD_INT 1
106454: PPUSH
106455: CALL_OW 48
// end ;
106459: LD_VAR 0 7
106463: RET
// export hInvincible ; every 1 do
106464: GO 106466
106466: DISABLE
// hInvincible := [ ] ;
106467: LD_ADDR_EXP 155
106471: PUSH
106472: EMPTY
106473: ST_TO_ADDR
106474: END
// every 10 do var i ;
106475: GO 106477
106477: DISABLE
106478: LD_INT 0
106480: PPUSH
// begin enable ;
106481: ENABLE
// if not hInvincible then
106482: LD_EXP 155
106486: NOT
106487: IFFALSE 106491
// exit ;
106489: GO 106535
// for i in hInvincible do
106491: LD_ADDR_VAR 0 1
106495: PUSH
106496: LD_EXP 155
106500: PUSH
106501: FOR_IN
106502: IFFALSE 106533
// if GetLives ( i ) < 1000 then
106504: LD_VAR 0 1
106508: PPUSH
106509: CALL_OW 256
106513: PUSH
106514: LD_INT 1000
106516: LESS
106517: IFFALSE 106531
// SetLives ( i , 1000 ) ;
106519: LD_VAR 0 1
106523: PPUSH
106524: LD_INT 1000
106526: PPUSH
106527: CALL_OW 234
106531: GO 106501
106533: POP
106534: POP
// end ;
106535: PPOPN 1
106537: END
// export function hHackInvincible ; var i ; begin
106538: LD_INT 0
106540: PPUSH
106541: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106542: LD_ADDR_VAR 0 2
106546: PUSH
106547: LD_INT 2
106549: PUSH
106550: LD_INT 21
106552: PUSH
106553: LD_INT 1
106555: PUSH
106556: EMPTY
106557: LIST
106558: LIST
106559: PUSH
106560: LD_INT 21
106562: PUSH
106563: LD_INT 2
106565: PUSH
106566: EMPTY
106567: LIST
106568: LIST
106569: PUSH
106570: EMPTY
106571: LIST
106572: LIST
106573: LIST
106574: PPUSH
106575: CALL_OW 69
106579: PUSH
106580: FOR_IN
106581: IFFALSE 106642
// if IsSelected ( i ) then
106583: LD_VAR 0 2
106587: PPUSH
106588: CALL_OW 306
106592: IFFALSE 106640
// begin if i in hInvincible then
106594: LD_VAR 0 2
106598: PUSH
106599: LD_EXP 155
106603: IN
106604: IFFALSE 106624
// hInvincible := hInvincible diff i else
106606: LD_ADDR_EXP 155
106610: PUSH
106611: LD_EXP 155
106615: PUSH
106616: LD_VAR 0 2
106620: DIFF
106621: ST_TO_ADDR
106622: GO 106640
// hInvincible := hInvincible union i ;
106624: LD_ADDR_EXP 155
106628: PUSH
106629: LD_EXP 155
106633: PUSH
106634: LD_VAR 0 2
106638: UNION
106639: ST_TO_ADDR
// end ;
106640: GO 106580
106642: POP
106643: POP
// end ;
106644: LD_VAR 0 1
106648: RET
// export function hHackInvisible ; var i , j ; begin
106649: LD_INT 0
106651: PPUSH
106652: PPUSH
106653: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106654: LD_ADDR_VAR 0 2
106658: PUSH
106659: LD_INT 21
106661: PUSH
106662: LD_INT 1
106664: PUSH
106665: EMPTY
106666: LIST
106667: LIST
106668: PPUSH
106669: CALL_OW 69
106673: PUSH
106674: FOR_IN
106675: IFFALSE 106699
// if IsSelected ( i ) then
106677: LD_VAR 0 2
106681: PPUSH
106682: CALL_OW 306
106686: IFFALSE 106697
// ComForceInvisible ( i ) ;
106688: LD_VAR 0 2
106692: PPUSH
106693: CALL_OW 496
106697: GO 106674
106699: POP
106700: POP
// end ;
106701: LD_VAR 0 1
106705: RET
// export function hHackChangeYourSide ; begin
106706: LD_INT 0
106708: PPUSH
// if your_side = 8 then
106709: LD_OWVAR 2
106713: PUSH
106714: LD_INT 8
106716: EQUAL
106717: IFFALSE 106729
// your_side := 0 else
106719: LD_ADDR_OWVAR 2
106723: PUSH
106724: LD_INT 0
106726: ST_TO_ADDR
106727: GO 106743
// your_side := your_side + 1 ;
106729: LD_ADDR_OWVAR 2
106733: PUSH
106734: LD_OWVAR 2
106738: PUSH
106739: LD_INT 1
106741: PLUS
106742: ST_TO_ADDR
// end ;
106743: LD_VAR 0 1
106747: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106748: LD_INT 0
106750: PPUSH
106751: PPUSH
106752: PPUSH
// for i in all_units do
106753: LD_ADDR_VAR 0 2
106757: PUSH
106758: LD_OWVAR 3
106762: PUSH
106763: FOR_IN
106764: IFFALSE 106842
// if IsSelected ( i ) then
106766: LD_VAR 0 2
106770: PPUSH
106771: CALL_OW 306
106775: IFFALSE 106840
// begin j := GetSide ( i ) ;
106777: LD_ADDR_VAR 0 3
106781: PUSH
106782: LD_VAR 0 2
106786: PPUSH
106787: CALL_OW 255
106791: ST_TO_ADDR
// if j = 8 then
106792: LD_VAR 0 3
106796: PUSH
106797: LD_INT 8
106799: EQUAL
106800: IFFALSE 106812
// j := 0 else
106802: LD_ADDR_VAR 0 3
106806: PUSH
106807: LD_INT 0
106809: ST_TO_ADDR
106810: GO 106826
// j := j + 1 ;
106812: LD_ADDR_VAR 0 3
106816: PUSH
106817: LD_VAR 0 3
106821: PUSH
106822: LD_INT 1
106824: PLUS
106825: ST_TO_ADDR
// SetSide ( i , j ) ;
106826: LD_VAR 0 2
106830: PPUSH
106831: LD_VAR 0 3
106835: PPUSH
106836: CALL_OW 235
// end ;
106840: GO 106763
106842: POP
106843: POP
// end ;
106844: LD_VAR 0 1
106848: RET
// export function hHackFog ; begin
106849: LD_INT 0
106851: PPUSH
// FogOff ( true ) ;
106852: LD_INT 1
106854: PPUSH
106855: CALL_OW 344
// end ;
106859: LD_VAR 0 1
106863: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106864: LD_INT 0
106866: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106867: LD_VAR 0 1
106871: PPUSH
106872: LD_VAR 0 2
106876: PPUSH
106877: LD_VAR 0 3
106881: PPUSH
106882: LD_INT 1
106884: PPUSH
106885: LD_INT 1
106887: PPUSH
106888: CALL_OW 483
// CenterOnXY ( x , y ) ;
106892: LD_VAR 0 2
106896: PPUSH
106897: LD_VAR 0 3
106901: PPUSH
106902: CALL_OW 84
// end ; end_of_file
106906: LD_VAR 0 4
106910: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
106911: LD_VAR 0 1
106915: PPUSH
106916: LD_VAR 0 2
106920: PPUSH
106921: LD_VAR 0 3
106925: PPUSH
106926: LD_VAR 0 4
106930: PPUSH
106931: LD_VAR 0 5
106935: PPUSH
106936: LD_VAR 0 6
106940: PPUSH
106941: CALL 93126 0 6
// end ;
106945: PPOPN 6
106947: END
