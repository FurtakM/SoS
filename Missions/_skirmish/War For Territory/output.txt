// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitGlobalVar ;
   8: CALL 116 0 0
// InitGame ;
  12: CALL 24 0 0
// Debug ( 1 ) ;
  16: LD_INT 1
  18: PPUSH
  19: CALL 140 0 1
// end ;
  23: END
// function InitGame ; begin
  24: LD_INT 0
  26: PPUSH
// Difficulty := 2 ;
  27: LD_ADDR_OWVAR 67
  31: PUSH
  32: LD_INT 2
  34: ST_TO_ADDR
// PrepareSquad ( 4 , 1 , powell_base , powell , 4 , 15 ) ;
  35: LD_INT 4
  37: PPUSH
  38: LD_INT 1
  40: PPUSH
  41: LD_INT 1
  43: PPUSH
  44: LD_STRING powell
  46: PPUSH
  47: LD_INT 4
  49: PPUSH
  50: LD_INT 15
  52: PPUSH
  53: CALL 29312 0 6
// Resources ( 3 , 3 , 3 , powell_base ) ;
  57: LD_INT 3
  59: PPUSH
  60: LD_INT 3
  62: PPUSH
  63: LD_INT 3
  65: PPUSH
  66: LD_INT 1
  68: PPUSH
  69: CALL 29769 0 4
// PrepareSquad ( 2 , 2 , gensher_base , gensher , 4 , 15 ) ;
  73: LD_INT 2
  75: PPUSH
  76: LD_INT 2
  78: PPUSH
  79: LD_INT 5
  81: PPUSH
  82: LD_STRING gensher
  84: PPUSH
  85: LD_INT 4
  87: PPUSH
  88: LD_INT 15
  90: PPUSH
  91: CALL 29312 0 6
// Resources ( 3 , 3 , 3 , gensher_base ) ;
  95: LD_INT 3
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 3
 103: PPUSH
 104: LD_INT 5
 106: PPUSH
 107: CALL 29769 0 4
// end ;
 111: LD_VAR 0 1
 115: RET
// export ar_crane , ru_big_cargo_bay ; function InitGlobalVar ; begin
 116: LD_INT 0
 118: PPUSH
// ar_crane := 88 ;
 119: LD_ADDR_EXP 1
 123: PUSH
 124: LD_INT 88
 126: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
 127: LD_ADDR_EXP 2
 131: PUSH
 132: LD_INT 89
 134: ST_TO_ADDR
// end ;
 135: LD_VAR 0 1
 139: RET
// function Debug ( s ) ; begin
 140: LD_INT 0
 142: PPUSH
// TurnFogOff ( ) ;
 143: CALL_OW 537
// Your_Side := s ;
 147: LD_ADDR_OWVAR 2
 151: PUSH
 152: LD_VAR 0 1
 156: ST_TO_ADDR
// CenterNowOnUnits ( FilterAllUnits ( [ f_side , s ] ) [ 1 ] ) ;
 157: LD_INT 22
 159: PUSH
 160: LD_VAR 0 1
 164: PUSH
 165: EMPTY
 166: LIST
 167: LIST
 168: PPUSH
 169: CALL_OW 69
 173: PUSH
 174: LD_INT 1
 176: ARRAY
 177: PPUSH
 178: CALL_OW 87
// end ; end_of_file
 182: LD_VAR 0 2
 186: RET
// export function EnemyNearbyBase ( side , area , x , y ) ; var i ; begin
 187: LD_INT 0
 189: PPUSH
 190: PPUSH
// i := NearestUnitToXY ( FilterAllUnits ( [ f_side , side ] ) , x , y ) ;
 191: LD_ADDR_VAR 0 6
 195: PUSH
 196: LD_INT 22
 198: PUSH
 199: LD_VAR 0 1
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: PPUSH
 208: CALL_OW 69
 212: PPUSH
 213: LD_VAR 0 3
 217: PPUSH
 218: LD_VAR 0 4
 222: PPUSH
 223: CALL_OW 73
 227: ST_TO_ADDR
// if GetDistUnitXY ( i , x , y ) < 17 or FilterUnitsInArea ( area , [ f_side , side ] ) > 0 then
 228: LD_VAR 0 6
 232: PPUSH
 233: LD_VAR 0 3
 237: PPUSH
 238: LD_VAR 0 4
 242: PPUSH
 243: CALL_OW 297
 247: PUSH
 248: LD_INT 17
 250: LESS
 251: PUSH
 252: LD_VAR 0 2
 256: PPUSH
 257: LD_INT 22
 259: PUSH
 260: LD_VAR 0 1
 264: PUSH
 265: EMPTY
 266: LIST
 267: LIST
 268: PPUSH
 269: CALL_OW 70
 273: PUSH
 274: LD_INT 0
 276: GREATER
 277: OR
 278: IFFALSE 290
// result := true else
 280: LD_ADDR_VAR 0 5
 284: PUSH
 285: LD_INT 1
 287: ST_TO_ADDR
 288: GO 298
// result := false ;
 290: LD_ADDR_VAR 0 5
 294: PUSH
 295: LD_INT 0
 297: ST_TO_ADDR
// end ;
 298: LD_VAR 0 5
 302: RET
// export function DistFromEnemy ( unit , enemy_list ) ; var i , dist ; begin
 303: LD_INT 0
 305: PPUSH
 306: PPUSH
 307: PPUSH
// dist := 9999 ;
 308: LD_ADDR_VAR 0 5
 312: PUSH
 313: LD_INT 9999
 315: ST_TO_ADDR
// for i = 1 to enemy_list do
 316: LD_ADDR_VAR 0 4
 320: PUSH
 321: DOUBLE
 322: LD_INT 1
 324: DEC
 325: ST_TO_ADDR
 326: LD_VAR 0 2
 330: PUSH
 331: FOR_TO
 332: IFFALSE 416
// if GetDistUnitToSide ( unit , enemy_list [ i ] ) < dist and GetDistUnitToSide ( unit , enemy_list [ i ] ) > 0 then
 334: LD_VAR 0 1
 338: PPUSH
 339: LD_VAR 0 2
 343: PUSH
 344: LD_VAR 0 4
 348: ARRAY
 349: PPUSH
 350: CALL 11270 0 2
 354: PUSH
 355: LD_VAR 0 5
 359: LESS
 360: PUSH
 361: LD_VAR 0 1
 365: PPUSH
 366: LD_VAR 0 2
 370: PUSH
 371: LD_VAR 0 4
 375: ARRAY
 376: PPUSH
 377: CALL 11270 0 2
 381: PUSH
 382: LD_INT 0
 384: GREATER
 385: AND
 386: IFFALSE 414
// dist := GetDistUnitToSide ( unit , enemy_list [ i ] ) ;
 388: LD_ADDR_VAR 0 5
 392: PUSH
 393: LD_VAR 0 1
 397: PPUSH
 398: LD_VAR 0 2
 402: PUSH
 403: LD_VAR 0 4
 407: ARRAY
 408: PPUSH
 409: CALL 11270 0 2
 413: ST_TO_ADDR
 414: GO 331
 416: POP
 417: POP
// result := dist ;
 418: LD_ADDR_VAR 0 3
 422: PUSH
 423: LD_VAR 0 5
 427: ST_TO_ADDR
// end ;
 428: LD_VAR 0 3
 432: RET
// export function EnemyInRange ( side , xy_list ) ; var i , p , enemy_side , mode , x ; begin
 433: LD_INT 0
 435: PPUSH
 436: PPUSH
 437: PPUSH
 438: PPUSH
 439: PPUSH
 440: PPUSH
// enemy_side := FilterAllUnits ( [ f_enemy , side ] ) ;
 441: LD_ADDR_VAR 0 6
 445: PUSH
 446: LD_INT 81
 448: PUSH
 449: LD_VAR 0 1
 453: PUSH
 454: EMPTY
 455: LIST
 456: LIST
 457: PPUSH
 458: CALL_OW 69
 462: ST_TO_ADDR
// mode := false ;
 463: LD_ADDR_VAR 0 7
 467: PUSH
 468: LD_INT 0
 470: ST_TO_ADDR
// p := 1 ;
 471: LD_ADDR_VAR 0 5
 475: PUSH
 476: LD_INT 1
 478: ST_TO_ADDR
// for i = 1 to xy_list do
 479: LD_ADDR_VAR 0 4
 483: PUSH
 484: DOUBLE
 485: LD_INT 1
 487: DEC
 488: ST_TO_ADDR
 489: LD_VAR 0 2
 493: PUSH
 494: FOR_TO
 495: IFFALSE 590
// begin x := NearestUnitToXY ( enemy_side , xy_list [ p ] , xy_list [ p + 1 ] ) ;
 497: LD_ADDR_VAR 0 8
 501: PUSH
 502: LD_VAR 0 6
 506: PPUSH
 507: LD_VAR 0 2
 511: PUSH
 512: LD_VAR 0 5
 516: ARRAY
 517: PPUSH
 518: LD_VAR 0 2
 522: PUSH
 523: LD_VAR 0 5
 527: PUSH
 528: LD_INT 1
 530: PLUS
 531: ARRAY
 532: PPUSH
 533: CALL_OW 73
 537: ST_TO_ADDR
// if GetDistUnitToSide ( x , side ) > 0 and GetDistUnitToSide ( x , side ) < 26 then
 538: LD_VAR 0 8
 542: PPUSH
 543: LD_VAR 0 1
 547: PPUSH
 548: CALL 11270 0 2
 552: PUSH
 553: LD_INT 0
 555: GREATER
 556: PUSH
 557: LD_VAR 0 8
 561: PPUSH
 562: LD_VAR 0 1
 566: PPUSH
 567: CALL 11270 0 2
 571: PUSH
 572: LD_INT 26
 574: LESS
 575: AND
 576: IFFALSE 588
// begin mode := true ;
 578: LD_ADDR_VAR 0 7
 582: PUSH
 583: LD_INT 1
 585: ST_TO_ADDR
// break ;
 586: GO 590
// end ; end ;
 588: GO 494
 590: POP
 591: POP
// result := mode ;
 592: LD_ADDR_VAR 0 3
 596: PUSH
 597: LD_VAR 0 7
 601: ST_TO_ADDR
// end ;
 602: LD_VAR 0 3
 606: RET
// export function CutTreeInArea ( bulldozer , area ) ; var i ; begin
 607: LD_INT 0
 609: PPUSH
 610: PPUSH
// area = ListEnvironmentArea ( area ) ;
 611: LD_ADDR_VAR 0 2
 615: PUSH
 616: LD_VAR 0 2
 620: PPUSH
 621: CALL_OW 353
 625: ST_TO_ADDR
// if bulldozer > 0 then
 626: LD_VAR 0 1
 630: PUSH
 631: LD_INT 0
 633: GREATER
 634: IFFALSE 745
// for i = 1 to area do
 636: LD_ADDR_VAR 0 4
 640: PUSH
 641: DOUBLE
 642: LD_INT 1
 644: DEC
 645: ST_TO_ADDR
 646: LD_VAR 0 2
 650: PUSH
 651: FOR_TO
 652: IFFALSE 743
// if IsEnvironment ( area [ i ] [ 1 ] , area [ i ] [ 2 ] ) then
 654: LD_VAR 0 2
 658: PUSH
 659: LD_VAR 0 4
 663: ARRAY
 664: PUSH
 665: LD_INT 1
 667: ARRAY
 668: PPUSH
 669: LD_VAR 0 2
 673: PUSH
 674: LD_VAR 0 4
 678: ARRAY
 679: PUSH
 680: LD_INT 2
 682: ARRAY
 683: PPUSH
 684: CALL_OW 351
 688: IFFALSE 741
// if not HasTask ( bulldozer ) then
 690: LD_VAR 0 1
 694: PPUSH
 695: CALL_OW 314
 699: NOT
 700: IFFALSE 741
// AddComMoveXY ( bulldozer , area [ i ] [ 1 ] , area [ i ] [ 2 ] ) ;
 702: LD_VAR 0 1
 706: PPUSH
 707: LD_VAR 0 2
 711: PUSH
 712: LD_VAR 0 4
 716: ARRAY
 717: PUSH
 718: LD_INT 1
 720: ARRAY
 721: PPUSH
 722: LD_VAR 0 2
 726: PUSH
 727: LD_VAR 0 4
 731: ARRAY
 732: PUSH
 733: LD_INT 2
 735: ARRAY
 736: PPUSH
 737: CALL_OW 171
 741: GO 651
 743: POP
 744: POP
// end ;
 745: LD_VAR 0 3
 749: RET
// export function Cost ( bdepot , btype ) ; var pom , cost ; begin
 750: LD_INT 0
 752: PPUSH
 753: PPUSH
 754: PPUSH
// pom := GetBase ( bdepot ) ;
 755: LD_ADDR_VAR 0 4
 759: PUSH
 760: LD_VAR 0 1
 764: PPUSH
 765: CALL_OW 274
 769: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
 770: LD_ADDR_VAR 0 5
 774: PUSH
 775: LD_VAR 0 2
 779: PPUSH
 780: LD_VAR 0 1
 784: PPUSH
 785: CALL_OW 248
 789: PPUSH
 790: CALL_OW 450
 794: ST_TO_ADDR
// if GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] then
 795: LD_VAR 0 4
 799: PPUSH
 800: LD_INT 1
 802: PPUSH
 803: CALL_OW 275
 807: PUSH
 808: LD_VAR 0 5
 812: PUSH
 813: LD_INT 1
 815: ARRAY
 816: GREATEREQUAL
 817: PUSH
 818: LD_VAR 0 4
 822: PPUSH
 823: LD_INT 3
 825: PPUSH
 826: CALL_OW 275
 830: PUSH
 831: LD_VAR 0 5
 835: PUSH
 836: LD_INT 3
 838: ARRAY
 839: GREATEREQUAL
 840: AND
 841: IFFALSE 853
// result := true else
 843: LD_ADDR_VAR 0 3
 847: PUSH
 848: LD_INT 1
 850: ST_TO_ADDR
 851: GO 861
// result := false ;
 853: LD_ADDR_VAR 0 3
 857: PUSH
 858: LD_INT 0
 860: ST_TO_ADDR
// end ;
 861: LD_VAR 0 3
 865: RET
// export function GetBaseSource ( bdepot ) ; var pom , sor ; begin
 866: LD_INT 0
 868: PPUSH
 869: PPUSH
 870: PPUSH
// pom := GetBase ( bdepot ) ;
 871: LD_ADDR_VAR 0 3
 875: PUSH
 876: LD_VAR 0 1
 880: PPUSH
 881: CALL_OW 274
 885: ST_TO_ADDR
// sor := [ ] ;
 886: LD_ADDR_VAR 0 4
 890: PUSH
 891: EMPTY
 892: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_cans ) ;
 893: LD_ADDR_VAR 0 4
 897: PUSH
 898: LD_VAR 0 4
 902: PUSH
 903: LD_VAR 0 3
 907: PPUSH
 908: LD_INT 1
 910: PPUSH
 911: CALL_OW 275
 915: ADD
 916: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_oil ) ;
 917: LD_ADDR_VAR 0 4
 921: PUSH
 922: LD_VAR 0 4
 926: PUSH
 927: LD_VAR 0 3
 931: PPUSH
 932: LD_INT 2
 934: PPUSH
 935: CALL_OW 275
 939: ADD
 940: ST_TO_ADDR
// sor := sor ^ GetResourceType ( pom , mat_siberit ) ;
 941: LD_ADDR_VAR 0 4
 945: PUSH
 946: LD_VAR 0 4
 950: PUSH
 951: LD_VAR 0 3
 955: PPUSH
 956: LD_INT 3
 958: PPUSH
 959: CALL_OW 275
 963: ADD
 964: ST_TO_ADDR
// result := sor ;
 965: LD_ADDR_VAR 0 2
 969: PUSH
 970: LD_VAR 0 4
 974: ST_TO_ADDR
// end ;
 975: LD_VAR 0 2
 979: RET
// export function Hex ( x , y ) ; begin
 980: LD_INT 0
 982: PPUSH
// if ValidHex ( x , y ) and HexInfo ( x , y ) = 0 then
 983: LD_VAR 0 1
 987: PPUSH
 988: LD_VAR 0 2
 992: PPUSH
 993: CALL_OW 488
 997: PUSH
 998: LD_VAR 0 1
1002: PPUSH
1003: LD_VAR 0 2
1007: PPUSH
1008: CALL_OW 428
1012: PUSH
1013: LD_INT 0
1015: EQUAL
1016: AND
1017: IFFALSE 1029
// result := true else
1019: LD_ADDR_VAR 0 3
1023: PUSH
1024: LD_INT 1
1026: ST_TO_ADDR
1027: GO 1037
// result := false ;
1029: LD_ADDR_VAR 0 3
1033: PUSH
1034: LD_INT 0
1036: ST_TO_ADDR
// end ;
1037: LD_VAR 0 3
1041: RET
// export function NeedBuilding ( side , btype ) ; begin
1042: LD_INT 0
1044: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] , [ f_not , [ f_constructed ] ] ] ) = 0 then
1045: LD_INT 22
1047: PUSH
1048: LD_VAR 0 1
1052: PUSH
1053: EMPTY
1054: LIST
1055: LIST
1056: PUSH
1057: LD_INT 30
1059: PUSH
1060: LD_VAR 0 2
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: PUSH
1069: LD_INT 3
1071: PUSH
1072: LD_INT 57
1074: PUSH
1075: EMPTY
1076: LIST
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: PUSH
1082: EMPTY
1083: LIST
1084: LIST
1085: LIST
1086: PPUSH
1087: CALL_OW 69
1091: PUSH
1092: LD_INT 0
1094: EQUAL
1095: IFFALSE 1107
// result := true else
1097: LD_ADDR_VAR 0 3
1101: PUSH
1102: LD_INT 1
1104: ST_TO_ADDR
1105: GO 1115
// result := false ;
1107: LD_ADDR_VAR 0 3
1111: PUSH
1112: LD_INT 0
1114: ST_TO_ADDR
// end ;
1115: LD_VAR 0 3
1119: RET
// export function NeedBase ( side ) ; begin
1120: LD_INT 0
1122: PPUSH
// if NeedBuilding ( side , b_depot ) and NeedBuilding ( side , b_warehouse ) then
1123: LD_VAR 0 1
1127: PPUSH
1128: LD_INT 0
1130: PPUSH
1131: CALL 1042 0 2
1135: PUSH
1136: LD_VAR 0 1
1140: PPUSH
1141: LD_INT 1
1143: PPUSH
1144: CALL 1042 0 2
1148: AND
1149: IFFALSE 1161
// result := true else
1151: LD_ADDR_VAR 0 2
1155: PUSH
1156: LD_INT 1
1158: ST_TO_ADDR
1159: GO 1169
// result := false ;
1161: LD_ADDR_VAR 0 2
1165: PUSH
1166: LD_INT 0
1168: ST_TO_ADDR
// end ;
1169: LD_VAR 0 2
1173: RET
// export function MyBase ( side ) ; begin
1174: LD_INT 0
1176: PPUSH
// if not NeedBase ( side ) then
1177: LD_VAR 0 1
1181: PPUSH
1182: CALL 1120 0 1
1186: NOT
1187: IFFALSE 1252
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) [ 1 ] else
1189: LD_ADDR_VAR 0 2
1193: PUSH
1194: LD_INT 22
1196: PUSH
1197: LD_VAR 0 1
1201: PUSH
1202: EMPTY
1203: LIST
1204: LIST
1205: PUSH
1206: LD_INT 2
1208: PUSH
1209: LD_INT 30
1211: PUSH
1212: LD_INT 0
1214: PUSH
1215: EMPTY
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 30
1221: PUSH
1222: LD_INT 1
1224: PUSH
1225: EMPTY
1226: LIST
1227: LIST
1228: PUSH
1229: EMPTY
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: PUSH
1238: EMPTY
1239: LIST
1240: PPUSH
1241: CALL_OW 69
1245: PUSH
1246: LD_INT 1
1248: ARRAY
1249: ST_TO_ADDR
1250: GO 1260
// result := false ;
1252: LD_ADDR_VAR 0 2
1256: PUSH
1257: LD_INT 0
1259: ST_TO_ADDR
// end ;
1260: LD_VAR 0 2
1264: RET
// export function GetBuilding ( side , btype ) ; begin
1265: LD_INT 0
1267: PPUSH
// if FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) > 0 then
1268: LD_INT 22
1270: PUSH
1271: LD_VAR 0 1
1275: PUSH
1276: EMPTY
1277: LIST
1278: LIST
1279: PUSH
1280: LD_INT 30
1282: PUSH
1283: LD_VAR 0 2
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: PUSH
1292: EMPTY
1293: LIST
1294: LIST
1295: PPUSH
1296: CALL_OW 69
1300: PUSH
1301: LD_INT 0
1303: GREATER
1304: IFFALSE 1346
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) else
1306: LD_ADDR_VAR 0 3
1310: PUSH
1311: LD_INT 22
1313: PUSH
1314: LD_VAR 0 1
1318: PUSH
1319: EMPTY
1320: LIST
1321: LIST
1322: PUSH
1323: LD_INT 30
1325: PUSH
1326: LD_VAR 0 2
1330: PUSH
1331: EMPTY
1332: LIST
1333: LIST
1334: PUSH
1335: EMPTY
1336: LIST
1337: LIST
1338: PPUSH
1339: CALL_OW 69
1343: ST_TO_ADDR
1344: GO 1354
// result := false ;
1346: LD_ADDR_VAR 0 3
1350: PUSH
1351: LD_INT 0
1353: ST_TO_ADDR
// end ;
1354: LD_VAR 0 3
1358: RET
// export function GetCrates ( side ) ; begin
1359: LD_INT 0
1361: PPUSH
// if MyBase ( side ) then
1362: LD_VAR 0 1
1366: PPUSH
1367: CALL 1174 0 1
1371: IFFALSE 1403
// result := GetResourceType ( GetBase ( MyBase ( side ) ) , mat_cans ) else
1373: LD_ADDR_VAR 0 2
1377: PUSH
1378: LD_VAR 0 1
1382: PPUSH
1383: CALL 1174 0 1
1387: PPUSH
1388: CALL_OW 274
1392: PPUSH
1393: LD_INT 1
1395: PPUSH
1396: CALL_OW 275
1400: ST_TO_ADDR
1401: GO 1411
// result := false ;
1403: LD_ADDR_VAR 0 2
1407: PUSH
1408: LD_INT 0
1410: ST_TO_ADDR
// end ;
1411: LD_VAR 0 2
1415: RET
// export function GetLabs ( side ) ; begin
1416: LD_INT 0
1418: PPUSH
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_full ] , [ f_btype , b_lab_half ] ] ] ] ) ;
1419: LD_ADDR_VAR 0 2
1423: PUSH
1424: LD_INT 22
1426: PUSH
1427: LD_VAR 0 1
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: PUSH
1436: LD_INT 2
1438: PUSH
1439: LD_INT 30
1441: PUSH
1442: LD_INT 6
1444: PUSH
1445: EMPTY
1446: LIST
1447: LIST
1448: PUSH
1449: LD_INT 30
1451: PUSH
1452: LD_INT 8
1454: PUSH
1455: EMPTY
1456: LIST
1457: LIST
1458: PUSH
1459: LD_INT 30
1461: PUSH
1462: LD_INT 7
1464: PUSH
1465: EMPTY
1466: LIST
1467: LIST
1468: PUSH
1469: EMPTY
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: PUSH
1479: EMPTY
1480: LIST
1481: PPUSH
1482: CALL_OW 69
1486: ST_TO_ADDR
// end ;
1487: LD_VAR 0 2
1491: RET
// export function GetLabKinds ( lab ) ; var kind1 , kind2 ; begin
1492: LD_INT 0
1494: PPUSH
1495: PPUSH
1496: PPUSH
// kind1 := GetLabKind ( lab , 1 ) ;
1497: LD_ADDR_VAR 0 3
1501: PUSH
1502: LD_VAR 0 1
1506: PPUSH
1507: LD_INT 1
1509: PPUSH
1510: CALL_OW 268
1514: ST_TO_ADDR
// kind2 := GetLabKind ( lab , 2 ) ;
1515: LD_ADDR_VAR 0 4
1519: PUSH
1520: LD_VAR 0 1
1524: PPUSH
1525: LD_INT 2
1527: PPUSH
1528: CALL_OW 268
1532: ST_TO_ADDR
// result := [ kind1 , kind2 ] ;
1533: LD_ADDR_VAR 0 2
1537: PUSH
1538: LD_VAR 0 3
1542: PUSH
1543: LD_VAR 0 4
1547: PUSH
1548: EMPTY
1549: LIST
1550: LIST
1551: ST_TO_ADDR
// end ;
1552: LD_VAR 0 2
1556: RET
// export function CheckTechList ( side , tlist ) ; var i ; begin
1557: LD_INT 0
1559: PPUSH
1560: PPUSH
// result := false ;
1561: LD_ADDR_VAR 0 3
1565: PUSH
1566: LD_INT 0
1568: ST_TO_ADDR
// for i = 1 to tlist do
1569: LD_ADDR_VAR 0 4
1573: PUSH
1574: DOUBLE
1575: LD_INT 1
1577: DEC
1578: ST_TO_ADDR
1579: LD_VAR 0 2
1583: PUSH
1584: FOR_TO
1585: IFFALSE 1625
// if GetTech ( tlist [ i ] , side ) <> state_researched then
1587: LD_VAR 0 2
1591: PUSH
1592: LD_VAR 0 4
1596: ARRAY
1597: PPUSH
1598: LD_VAR 0 1
1602: PPUSH
1603: CALL_OW 321
1607: PUSH
1608: LD_INT 2
1610: NONEQUAL
1611: IFFALSE 1623
// begin result := true ;
1613: LD_ADDR_VAR 0 3
1617: PUSH
1618: LD_INT 1
1620: ST_TO_ADDR
// break ;
1621: GO 1625
// end ;
1623: GO 1584
1625: POP
1626: POP
// end ;
1627: LD_VAR 0 3
1631: RET
// export function ResearchTechList ( side , tlist ) ; var i , lab , pom , tmp , list , mylab , basic_tech ; begin
1632: LD_INT 0
1634: PPUSH
1635: PPUSH
1636: PPUSH
1637: PPUSH
1638: PPUSH
1639: PPUSH
1640: PPUSH
1641: PPUSH
// lab := GetLabs ( side ) ;
1642: LD_ADDR_VAR 0 5
1646: PUSH
1647: LD_VAR 0 1
1651: PPUSH
1652: CALL 1416 0 1
1656: ST_TO_ADDR
// tmp := 0 ;
1657: LD_ADDR_VAR 0 7
1661: PUSH
1662: LD_INT 0
1664: ST_TO_ADDR
// list := [ ] ;
1665: LD_ADDR_VAR 0 8
1669: PUSH
1670: EMPTY
1671: ST_TO_ADDR
// basic_tech := [ 35 , 45 , 46 , 47 , 1 , 2 , 48 , 49 , 50 , 20 ] ;
1672: LD_ADDR_VAR 0 10
1676: PUSH
1677: LD_INT 35
1679: PUSH
1680: LD_INT 45
1682: PUSH
1683: LD_INT 46
1685: PUSH
1686: LD_INT 47
1688: PUSH
1689: LD_INT 1
1691: PUSH
1692: LD_INT 2
1694: PUSH
1695: LD_INT 48
1697: PUSH
1698: LD_INT 49
1700: PUSH
1701: LD_INT 50
1703: PUSH
1704: LD_INT 20
1706: PUSH
1707: EMPTY
1708: LIST
1709: LIST
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: LIST
1715: LIST
1716: LIST
1717: LIST
1718: ST_TO_ADDR
// for i = 1 to tlist do
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: DOUBLE
1725: LD_INT 1
1727: DEC
1728: ST_TO_ADDR
1729: LD_VAR 0 2
1733: PUSH
1734: FOR_TO
1735: IFFALSE 1787
// if GetTech ( tlist [ i ] , side ) <> state_researched then
1737: LD_VAR 0 2
1741: PUSH
1742: LD_VAR 0 4
1746: ARRAY
1747: PPUSH
1748: LD_VAR 0 1
1752: PPUSH
1753: CALL_OW 321
1757: PUSH
1758: LD_INT 2
1760: NONEQUAL
1761: IFFALSE 1785
// list := list ^ tlist [ i ] ;
1763: LD_ADDR_VAR 0 8
1767: PUSH
1768: LD_VAR 0 8
1772: PUSH
1773: LD_VAR 0 2
1777: PUSH
1778: LD_VAR 0 4
1782: ARRAY
1783: ADD
1784: ST_TO_ADDR
1785: GO 1734
1787: POP
1788: POP
// if list then
1789: LD_VAR 0 8
1793: IFFALSE 1958
// begin for i = 1 to lab do
1795: LD_ADDR_VAR 0 4
1799: PUSH
1800: DOUBLE
1801: LD_INT 1
1803: DEC
1804: ST_TO_ADDR
1805: LD_VAR 0 5
1809: PUSH
1810: FOR_TO
1811: IFFALSE 1881
// if ( list [ 1 ] in basic_tech ) or ( GetTechLab ( list [ 1 ] ) in GetLabKinds ( lab [ i ] ) ) then
1813: LD_VAR 0 8
1817: PUSH
1818: LD_INT 1
1820: ARRAY
1821: PUSH
1822: LD_VAR 0 10
1826: IN
1827: PUSH
1828: LD_VAR 0 8
1832: PUSH
1833: LD_INT 1
1835: ARRAY
1836: PPUSH
1837: CALL_OW 481
1841: PUSH
1842: LD_VAR 0 5
1846: PUSH
1847: LD_VAR 0 4
1851: ARRAY
1852: PPUSH
1853: CALL 1492 0 1
1857: IN
1858: OR
1859: IFFALSE 1879
// begin mylab := lab [ i ] ;
1861: LD_ADDR_VAR 0 9
1865: PUSH
1866: LD_VAR 0 5
1870: PUSH
1871: LD_VAR 0 4
1875: ARRAY
1876: ST_TO_ADDR
// break ;
1877: GO 1881
// end ;
1879: GO 1810
1881: POP
1882: POP
// if mylab then
1883: LD_VAR 0 9
1887: IFFALSE 1948
// begin if BuildingStatus ( mylab ) = bs_idle then
1889: LD_VAR 0 9
1893: PPUSH
1894: CALL_OW 461
1898: PUSH
1899: LD_INT 2
1901: EQUAL
1902: IFFALSE 1946
// for i = 1 to list do
1904: LD_ADDR_VAR 0 4
1908: PUSH
1909: DOUBLE
1910: LD_INT 1
1912: DEC
1913: ST_TO_ADDR
1914: LD_VAR 0 8
1918: PUSH
1919: FOR_TO
1920: IFFALSE 1944
// AddComResearch ( mylab , list [ i ] ) ;
1922: LD_VAR 0 9
1926: PPUSH
1927: LD_VAR 0 8
1931: PUSH
1932: LD_VAR 0 4
1936: ARRAY
1937: PPUSH
1938: CALL_OW 184
1942: GO 1919
1944: POP
1945: POP
// end else
1946: GO 1956
// result := false ;
1948: LD_ADDR_VAR 0 3
1952: PUSH
1953: LD_INT 0
1955: ST_TO_ADDR
// end else
1956: GO 1966
// result := false ;
1958: LD_ADDR_VAR 0 3
1962: PUSH
1963: LD_INT 0
1965: ST_TO_ADDR
// end ;
1966: LD_VAR 0 3
1970: RET
// export function GetTowers ( side ) ; begin
1971: LD_INT 0
1973: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ;
1974: LD_ADDR_VAR 0 2
1978: PUSH
1979: LD_INT 22
1981: PUSH
1982: LD_VAR 0 1
1986: PUSH
1987: EMPTY
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 2
1993: PUSH
1994: LD_INT 30
1996: PUSH
1997: LD_INT 32
1999: PUSH
2000: EMPTY
2001: LIST
2002: LIST
2003: PUSH
2004: LD_INT 30
2006: PUSH
2007: LD_INT 33
2009: PUSH
2010: EMPTY
2011: LIST
2012: LIST
2013: PUSH
2014: EMPTY
2015: LIST
2016: LIST
2017: LIST
2018: PUSH
2019: EMPTY
2020: LIST
2021: LIST
2022: PPUSH
2023: CALL_OW 69
2027: ST_TO_ADDR
// end ;
2028: LD_VAR 0 2
2032: RET
// export function ComBuildDepot ( plist , x , y , d ) ; var i ; begin
2033: LD_INT 0
2035: PPUSH
2036: PPUSH
// if Hex ( x , y ) then
2037: LD_VAR 0 2
2041: PPUSH
2042: LD_VAR 0 3
2046: PPUSH
2047: CALL 980 0 2
2051: IFFALSE 2126
// for i = 1 to plist do
2053: LD_ADDR_VAR 0 6
2057: PUSH
2058: DOUBLE
2059: LD_INT 1
2061: DEC
2062: ST_TO_ADDR
2063: LD_VAR 0 1
2067: PUSH
2068: FOR_TO
2069: IFFALSE 2124
// if not HasTask ( plist [ i ] ) then
2071: LD_VAR 0 1
2075: PUSH
2076: LD_VAR 0 6
2080: ARRAY
2081: PPUSH
2082: CALL_OW 314
2086: NOT
2087: IFFALSE 2122
// ComBuild ( plist [ i ] , b_depot , x , y , d ) ;
2089: LD_VAR 0 1
2093: PUSH
2094: LD_VAR 0 6
2098: ARRAY
2099: PPUSH
2100: LD_INT 0
2102: PPUSH
2103: LD_VAR 0 2
2107: PPUSH
2108: LD_VAR 0 3
2112: PPUSH
2113: LD_VAR 0 4
2117: PPUSH
2118: CALL_OW 145
2122: GO 2068
2124: POP
2125: POP
// end ;
2126: LD_VAR 0 5
2130: RET
// export function ComBuildWarehouse ( plist , bident ) ; var i ; begin
2131: LD_INT 0
2133: PPUSH
2134: PPUSH
// if GetBType ( bident ) = b_depot and Cost ( bident , b_warehouse ) and not BuildingsInProgress ( GetSide ( plist [ 1 ] ) ) then
2135: LD_VAR 0 2
2139: PPUSH
2140: CALL_OW 266
2144: PUSH
2145: LD_INT 0
2147: EQUAL
2148: PUSH
2149: LD_VAR 0 2
2153: PPUSH
2154: LD_INT 1
2156: PPUSH
2157: CALL 750 0 2
2161: AND
2162: PUSH
2163: LD_VAR 0 1
2167: PUSH
2168: LD_INT 1
2170: ARRAY
2171: PPUSH
2172: CALL_OW 255
2176: PPUSH
2177: CALL_OW 345
2181: NOT
2182: AND
2183: IFFALSE 2284
// begin ComUpgrade ( bident ) ;
2185: LD_VAR 0 2
2189: PPUSH
2190: CALL_OW 146
// for i = 1 to plist do
2194: LD_ADDR_VAR 0 4
2198: PUSH
2199: DOUBLE
2200: LD_INT 1
2202: DEC
2203: ST_TO_ADDR
2204: LD_VAR 0 1
2208: PUSH
2209: FOR_TO
2210: IFFALSE 2272
// if not HasTask ( plist [ i ] ) then
2212: LD_VAR 0 1
2216: PUSH
2217: LD_VAR 0 4
2221: ARRAY
2222: PPUSH
2223: CALL_OW 314
2227: NOT
2228: IFFALSE 2270
// ComCompleteUpgrade ( plist [ i ] , HexInfo ( GetX ( bident ) , GetY ( bident ) ) ) ;
2230: LD_VAR 0 1
2234: PUSH
2235: LD_VAR 0 4
2239: ARRAY
2240: PPUSH
2241: LD_VAR 0 2
2245: PPUSH
2246: CALL_OW 250
2250: PPUSH
2251: LD_VAR 0 2
2255: PPUSH
2256: CALL_OW 251
2260: PPUSH
2261: CALL_OW 428
2265: PPUSH
2266: CALL 5468 0 2
2270: GO 2209
2272: POP
2273: POP
// result := true ;
2274: LD_ADDR_VAR 0 3
2278: PUSH
2279: LD_INT 1
2281: ST_TO_ADDR
// end else
2282: GO 2292
// result := false ;
2284: LD_ADDR_VAR 0 3
2288: PUSH
2289: LD_INT 0
2291: ST_TO_ADDR
// end ;
2292: LD_VAR 0 3
2296: RET
// export function ComBuildLab ( plist , x , y , d ) ; var i ; begin
2297: LD_INT 0
2299: PPUSH
2300: PPUSH
// if GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 and Hex ( x , y ) then
2301: LD_VAR 0 1
2305: PUSH
2306: LD_INT 1
2308: ARRAY
2309: PPUSH
2310: CALL_OW 255
2314: PPUSH
2315: CALL 1359 0 1
2319: PUSH
2320: LD_INT 20
2322: GREATEREQUAL
2323: PUSH
2324: LD_VAR 0 2
2328: PPUSH
2329: LD_VAR 0 3
2333: PPUSH
2334: CALL 980 0 2
2338: AND
2339: IFFALSE 2424
// begin for i = 1 to plist do
2341: LD_ADDR_VAR 0 6
2345: PUSH
2346: DOUBLE
2347: LD_INT 1
2349: DEC
2350: ST_TO_ADDR
2351: LD_VAR 0 1
2355: PUSH
2356: FOR_TO
2357: IFFALSE 2412
// if not HasTask ( plist [ i ] ) then
2359: LD_VAR 0 1
2363: PUSH
2364: LD_VAR 0 6
2368: ARRAY
2369: PPUSH
2370: CALL_OW 314
2374: NOT
2375: IFFALSE 2410
// ComBuild ( plist [ i ] , b_lab , x , y , d ) ;
2377: LD_VAR 0 1
2381: PUSH
2382: LD_VAR 0 6
2386: ARRAY
2387: PPUSH
2388: LD_INT 6
2390: PPUSH
2391: LD_VAR 0 2
2395: PPUSH
2396: LD_VAR 0 3
2400: PPUSH
2401: LD_VAR 0 4
2405: PPUSH
2406: CALL_OW 145
2410: GO 2356
2412: POP
2413: POP
// result := true ;
2414: LD_ADDR_VAR 0 5
2418: PUSH
2419: LD_INT 1
2421: ST_TO_ADDR
// end else
2422: GO 2432
// result := false ;
2424: LD_ADDR_VAR 0 5
2428: PUSH
2429: LD_INT 0
2431: ST_TO_ADDR
// end ;
2432: LD_VAR 0 5
2436: RET
// export function ComBuildLabKind ( lab , bkind1 , bkind2 ) ; var buildings_cost ; begin
2437: LD_INT 0
2439: PPUSH
2440: PPUSH
// buildings_cost := [ 0 , 0 , 0 ] ;
2441: LD_ADDR_VAR 0 5
2445: PUSH
2446: LD_INT 0
2448: PUSH
2449: LD_INT 0
2451: PUSH
2452: LD_INT 0
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: ST_TO_ADDR
// buildings_cost := RefreshList ( buildings_cost , CostOfBuilding ( bkind1 , GetNation ( lab ) ) ) ;
2460: LD_ADDR_VAR 0 5
2464: PUSH
2465: LD_VAR 0 5
2469: PPUSH
2470: LD_VAR 0 2
2474: PPUSH
2475: LD_VAR 0 1
2479: PPUSH
2480: CALL_OW 248
2484: PPUSH
2485: CALL_OW 450
2489: PPUSH
2490: CALL 6313 0 2
2494: ST_TO_ADDR
// buildings_cost := RefreshList ( buildings_cost , CostOfBuilding ( bkind2 , GetNation ( lab ) ) ) ;
2495: LD_ADDR_VAR 0 5
2499: PUSH
2500: LD_VAR 0 5
2504: PPUSH
2505: LD_VAR 0 3
2509: PPUSH
2510: LD_VAR 0 1
2514: PPUSH
2515: CALL_OW 248
2519: PPUSH
2520: CALL_OW 450
2524: PPUSH
2525: CALL 6313 0 2
2529: ST_TO_ADDR
// if GetLabKind ( lab , 1 ) = b_lab_basic and GetLabKind ( lab , 2 ) = b_lab_basic then
2530: LD_VAR 0 1
2534: PPUSH
2535: LD_INT 1
2537: PPUSH
2538: CALL_OW 268
2542: PUSH
2543: LD_INT 9
2545: EQUAL
2546: PUSH
2547: LD_VAR 0 1
2551: PPUSH
2552: LD_INT 2
2554: PPUSH
2555: CALL_OW 268
2559: PUSH
2560: LD_INT 9
2562: EQUAL
2563: AND
2564: IFFALSE 2660
// begin if buildings_cost < GetBaseSource ( MyBase ( GetSide ( lab ) ) [ 1 ] ) and BuildingStatus ( lab ) = bs_idle then
2566: LD_VAR 0 5
2570: PUSH
2571: LD_VAR 0 1
2575: PPUSH
2576: CALL_OW 255
2580: PPUSH
2581: CALL 1174 0 1
2585: PUSH
2586: LD_INT 1
2588: ARRAY
2589: PPUSH
2590: CALL 866 0 1
2594: LESS
2595: PUSH
2596: LD_VAR 0 1
2600: PPUSH
2601: CALL_OW 461
2605: PUSH
2606: LD_INT 2
2608: EQUAL
2609: AND
2610: IFFALSE 2650
// begin ComUpgradeLab ( lab , bkind1 ) ;
2612: LD_VAR 0 1
2616: PPUSH
2617: LD_VAR 0 2
2621: PPUSH
2622: CALL_OW 147
// AddComUpgradeLab ( lab , bkind2 ) ;
2626: LD_VAR 0 1
2630: PPUSH
2631: LD_VAR 0 3
2635: PPUSH
2636: CALL_OW 207
// result := true ;
2640: LD_ADDR_VAR 0 4
2644: PUSH
2645: LD_INT 1
2647: ST_TO_ADDR
// end else
2648: GO 2658
// result := false ;
2650: LD_ADDR_VAR 0 4
2654: PUSH
2655: LD_INT 0
2657: ST_TO_ADDR
// end else
2658: GO 2668
// result := false ;
2660: LD_ADDR_VAR 0 4
2664: PUSH
2665: LD_INT 0
2667: ST_TO_ADDR
// end ;
2668: LD_VAR 0 4
2672: RET
// export function CheckTowersStatus ( plist , tlist ) ; var i , tmp , p , c ; begin
2673: LD_INT 0
2675: PPUSH
2676: PPUSH
2677: PPUSH
2678: PPUSH
2679: PPUSH
// p := 1 ;
2680: LD_ADDR_VAR 0 6
2684: PUSH
2685: LD_INT 1
2687: ST_TO_ADDR
// for i = 1 to ( tlist / 4 ) do
2688: LD_ADDR_VAR 0 4
2692: PUSH
2693: DOUBLE
2694: LD_INT 1
2696: DEC
2697: ST_TO_ADDR
2698: LD_VAR 0 2
2702: PUSH
2703: LD_INT 4
2705: DIVREAL
2706: PUSH
2707: FOR_TO
2708: IFFALSE 2957
// begin if HexInfo ( tlist [ p + 1 ] , tlist [ p + 2 ] ) = 0 and Hex ( tlist [ p + 1 ] , tlist [ p + 2 ] ) and GetCrates ( GetSide ( plist [ 1 ] ) ) >= 20 then
2710: LD_VAR 0 2
2714: PUSH
2715: LD_VAR 0 6
2719: PUSH
2720: LD_INT 1
2722: PLUS
2723: ARRAY
2724: PPUSH
2725: LD_VAR 0 2
2729: PUSH
2730: LD_VAR 0 6
2734: PUSH
2735: LD_INT 2
2737: PLUS
2738: ARRAY
2739: PPUSH
2740: CALL_OW 428
2744: PUSH
2745: LD_INT 0
2747: EQUAL
2748: PUSH
2749: LD_VAR 0 2
2753: PUSH
2754: LD_VAR 0 6
2758: PUSH
2759: LD_INT 1
2761: PLUS
2762: ARRAY
2763: PPUSH
2764: LD_VAR 0 2
2768: PUSH
2769: LD_VAR 0 6
2773: PUSH
2774: LD_INT 2
2776: PLUS
2777: ARRAY
2778: PPUSH
2779: CALL 980 0 2
2783: AND
2784: PUSH
2785: LD_VAR 0 1
2789: PUSH
2790: LD_INT 1
2792: ARRAY
2793: PPUSH
2794: CALL_OW 255
2798: PPUSH
2799: CALL 1359 0 1
2803: PUSH
2804: LD_INT 20
2806: GREATEREQUAL
2807: AND
2808: IFFALSE 2925
// begin for c = 1 to plist do
2810: LD_ADDR_VAR 0 7
2814: PUSH
2815: DOUBLE
2816: LD_INT 1
2818: DEC
2819: ST_TO_ADDR
2820: LD_VAR 0 1
2824: PUSH
2825: FOR_TO
2826: IFFALSE 2919
// if not HasTask ( plist [ c ] ) then
2828: LD_VAR 0 1
2832: PUSH
2833: LD_VAR 0 7
2837: ARRAY
2838: PPUSH
2839: CALL_OW 314
2843: NOT
2844: IFFALSE 2917
// ComBuild ( plist [ c ] , tlist [ p ] , tlist [ p + 1 ] , tlist [ p + 2 ] , tlist [ p + 3 ] ) ;
2846: LD_VAR 0 1
2850: PUSH
2851: LD_VAR 0 7
2855: ARRAY
2856: PPUSH
2857: LD_VAR 0 2
2861: PUSH
2862: LD_VAR 0 6
2866: ARRAY
2867: PPUSH
2868: LD_VAR 0 2
2872: PUSH
2873: LD_VAR 0 6
2877: PUSH
2878: LD_INT 1
2880: PLUS
2881: ARRAY
2882: PPUSH
2883: LD_VAR 0 2
2887: PUSH
2888: LD_VAR 0 6
2892: PUSH
2893: LD_INT 2
2895: PLUS
2896: ARRAY
2897: PPUSH
2898: LD_VAR 0 2
2902: PUSH
2903: LD_VAR 0 6
2907: PUSH
2908: LD_INT 3
2910: PLUS
2911: ARRAY
2912: PPUSH
2913: CALL_OW 145
2917: GO 2825
2919: POP
2920: POP
// break ;
2921: GO 2957
// end else
2923: GO 2955
// if ( p + 4 < tlist ) then
2925: LD_VAR 0 6
2929: PUSH
2930: LD_INT 4
2932: PLUS
2933: PUSH
2934: LD_VAR 0 2
2938: LESS
2939: IFFALSE 2955
// p := p + 4 ;
2941: LD_ADDR_VAR 0 6
2945: PUSH
2946: LD_VAR 0 6
2950: PUSH
2951: LD_INT 4
2953: PLUS
2954: ST_TO_ADDR
// end ;
2955: GO 2707
2957: POP
2958: POP
// end ;
2959: LD_VAR 0 3
2963: RET
// export function CheckWeaponOnTowers ( side , wlist ) ; var i , tmp , fac ; begin
2964: LD_INT 0
2966: PPUSH
2967: PPUSH
2968: PPUSH
2969: PPUSH
// tmp := GetTowers ( side ) ;
2970: LD_ADDR_VAR 0 5
2974: PUSH
2975: LD_VAR 0 1
2979: PPUSH
2980: CALL 1971 0 1
2984: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
2985: LD_ADDR_VAR 0 6
2989: PUSH
2990: LD_VAR 0 1
2994: PPUSH
2995: LD_INT 3
2997: PPUSH
2998: CALL 1265 0 2
3002: PUSH
3003: LD_INT 1
3005: ARRAY
3006: ST_TO_ADDR
// if fac then
3007: LD_VAR 0 6
3011: IFFALSE 3107
// for i = 1 to tmp do
3013: LD_ADDR_VAR 0 4
3017: PUSH
3018: DOUBLE
3019: LD_INT 1
3021: DEC
3022: ST_TO_ADDR
3023: LD_VAR 0 5
3027: PUSH
3028: FOR_TO
3029: IFFALSE 3105
// if GetBWeapon ( tmp [ i ] ) = 0 then
3031: LD_VAR 0 5
3035: PUSH
3036: LD_VAR 0 4
3040: ARRAY
3041: PPUSH
3042: CALL_OW 269
3046: PUSH
3047: LD_INT 0
3049: EQUAL
3050: IFFALSE 3103
// begin if BuildingStatus ( fac ) = bs_idle then
3052: LD_VAR 0 6
3056: PPUSH
3057: CALL_OW 461
3061: PUSH
3062: LD_INT 2
3064: EQUAL
3065: IFFALSE 3101
// ComPlaceWeapon ( tmp [ i ] , wlist [ Rand ( 1 , wlist ) ] ) ;
3067: LD_VAR 0 5
3071: PUSH
3072: LD_VAR 0 4
3076: ARRAY
3077: PPUSH
3078: LD_VAR 0 2
3082: PUSH
3083: LD_INT 1
3085: PPUSH
3086: LD_VAR 0 2
3090: PPUSH
3091: CALL_OW 12
3095: ARRAY
3096: PPUSH
3097: CALL_OW 148
// break ;
3101: GO 3105
// end ;
3103: GO 3028
3105: POP
3106: POP
// end ;
3107: LD_VAR 0 3
3111: RET
// export function GetVehicle ( side , chassis , weapon ) ; begin
3112: LD_INT 0
3114: PPUSH
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) then
3115: LD_INT 22
3117: PUSH
3118: LD_VAR 0 1
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: PUSH
3127: LD_INT 34
3129: PUSH
3130: LD_VAR 0 3
3134: PUSH
3135: EMPTY
3136: LIST
3137: LIST
3138: PUSH
3139: LD_INT 31
3141: PUSH
3142: LD_VAR 0 2
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: PUSH
3151: EMPTY
3152: LIST
3153: LIST
3154: LIST
3155: PUSH
3156: EMPTY
3157: LIST
3158: PPUSH
3159: CALL_OW 69
3163: IFFALSE 3221
// result := FilterAllUnits ( [ [ [ f_side , side ] , [ f_weapon , weapon ] , [ f_chassis , chassis ] ] ] ) else
3165: LD_ADDR_VAR 0 4
3169: PUSH
3170: LD_INT 22
3172: PUSH
3173: LD_VAR 0 1
3177: PUSH
3178: EMPTY
3179: LIST
3180: LIST
3181: PUSH
3182: LD_INT 34
3184: PUSH
3185: LD_VAR 0 3
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: PUSH
3194: LD_INT 31
3196: PUSH
3197: LD_VAR 0 2
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PUSH
3206: EMPTY
3207: LIST
3208: LIST
3209: LIST
3210: PUSH
3211: EMPTY
3212: LIST
3213: PPUSH
3214: CALL_OW 69
3218: ST_TO_ADDR
3219: GO 3229
// result := false ;
3221: LD_ADDR_VAR 0 4
3225: PUSH
3226: LD_INT 0
3228: ST_TO_ADDR
// end ;
3229: LD_VAR 0 4
3233: RET
// export function ComProduce ( factory , chassis , engine , control , weapon ) ; begin
3234: LD_INT 0
3236: PPUSH
// if BuildingStatus ( factory ) = bs_idle and CanBeConstructed ( factory , chassis , engine , control , weapon ) and CostOfVehicle ( chassis , engine , control , weapon ) [ 1 ] <= GetBaseSource ( factory ) [ 1 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 2 ] <= GetBaseSource ( factory ) [ 2 ] and CostOfVehicle ( chassis , engine , control , weapon ) [ 3 ] <= GetBaseSource ( factory ) [ 3 ] then
3237: LD_VAR 0 1
3241: PPUSH
3242: CALL_OW 461
3246: PUSH
3247: LD_INT 2
3249: EQUAL
3250: PUSH
3251: LD_VAR 0 1
3255: PPUSH
3256: LD_VAR 0 2
3260: PPUSH
3261: LD_VAR 0 3
3265: PPUSH
3266: LD_VAR 0 4
3270: PPUSH
3271: LD_VAR 0 5
3275: PPUSH
3276: CALL_OW 448
3280: AND
3281: PUSH
3282: LD_VAR 0 2
3286: PPUSH
3287: LD_VAR 0 3
3291: PPUSH
3292: LD_VAR 0 4
3296: PPUSH
3297: LD_VAR 0 5
3301: PPUSH
3302: CALL_OW 449
3306: PUSH
3307: LD_INT 1
3309: ARRAY
3310: PUSH
3311: LD_VAR 0 1
3315: PPUSH
3316: CALL 866 0 1
3320: PUSH
3321: LD_INT 1
3323: ARRAY
3324: LESSEQUAL
3325: AND
3326: PUSH
3327: LD_VAR 0 2
3331: PPUSH
3332: LD_VAR 0 3
3336: PPUSH
3337: LD_VAR 0 4
3341: PPUSH
3342: LD_VAR 0 5
3346: PPUSH
3347: CALL_OW 449
3351: PUSH
3352: LD_INT 2
3354: ARRAY
3355: PUSH
3356: LD_VAR 0 1
3360: PPUSH
3361: CALL 866 0 1
3365: PUSH
3366: LD_INT 2
3368: ARRAY
3369: LESSEQUAL
3370: AND
3371: PUSH
3372: LD_VAR 0 2
3376: PPUSH
3377: LD_VAR 0 3
3381: PPUSH
3382: LD_VAR 0 4
3386: PPUSH
3387: LD_VAR 0 5
3391: PPUSH
3392: CALL_OW 449
3396: PUSH
3397: LD_INT 3
3399: ARRAY
3400: PUSH
3401: LD_VAR 0 1
3405: PPUSH
3406: CALL 866 0 1
3410: PUSH
3411: LD_INT 3
3413: ARRAY
3414: LESSEQUAL
3415: AND
3416: IFFALSE 3449
// begin ComConstruct ( factory , chassis , engine , control , weapon ) ;
3418: LD_VAR 0 1
3422: PPUSH
3423: LD_VAR 0 2
3427: PPUSH
3428: LD_VAR 0 3
3432: PPUSH
3433: LD_VAR 0 4
3437: PPUSH
3438: LD_VAR 0 5
3442: PPUSH
3443: CALL_OW 125
// end else
3447: GO 3457
// result := false ;
3449: LD_ADDR_VAR 0 6
3453: PUSH
3454: LD_INT 0
3456: ST_TO_ADDR
// end ;
3457: LD_VAR 0 6
3461: RET
// export function GetBuildingList ( side , type ) ; var i , tmp , filter ; begin
3462: LD_INT 0
3464: PPUSH
3465: PPUSH
3466: PPUSH
3467: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , type ] ] ) ;
3468: LD_ADDR_VAR 0 6
3472: PUSH
3473: LD_INT 22
3475: PUSH
3476: LD_VAR 0 1
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: PUSH
3485: LD_INT 30
3487: PUSH
3488: LD_VAR 0 2
3492: PUSH
3493: EMPTY
3494: LIST
3495: LIST
3496: PUSH
3497: EMPTY
3498: LIST
3499: LIST
3500: PPUSH
3501: CALL_OW 69
3505: ST_TO_ADDR
// tmp := [ ] ;
3506: LD_ADDR_VAR 0 5
3510: PUSH
3511: EMPTY
3512: ST_TO_ADDR
// for i = 1 to filter do
3513: LD_ADDR_VAR 0 4
3517: PUSH
3518: DOUBLE
3519: LD_INT 1
3521: DEC
3522: ST_TO_ADDR
3523: LD_VAR 0 6
3527: PUSH
3528: FOR_TO
3529: IFFALSE 3617
// begin tmp := tmp ^ [ [ GetBType ( filter [ i ] ) , GetX ( filter [ i ] ) , GetY ( filter [ i ] ) , GetDir ( filter [ i ] ) ] ] ;
3531: LD_ADDR_VAR 0 5
3535: PUSH
3536: LD_VAR 0 5
3540: PUSH
3541: LD_VAR 0 6
3545: PUSH
3546: LD_VAR 0 4
3550: ARRAY
3551: PPUSH
3552: CALL_OW 266
3556: PUSH
3557: LD_VAR 0 6
3561: PUSH
3562: LD_VAR 0 4
3566: ARRAY
3567: PPUSH
3568: CALL_OW 250
3572: PUSH
3573: LD_VAR 0 6
3577: PUSH
3578: LD_VAR 0 4
3582: ARRAY
3583: PPUSH
3584: CALL_OW 251
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_VAR 0 4
3598: ARRAY
3599: PPUSH
3600: CALL_OW 254
3604: PUSH
3605: EMPTY
3606: LIST
3607: LIST
3608: LIST
3609: LIST
3610: PUSH
3611: EMPTY
3612: LIST
3613: ADD
3614: ST_TO_ADDR
// end ;
3615: GO 3528
3617: POP
3618: POP
// result := tmp ;
3619: LD_ADDR_VAR 0 3
3623: PUSH
3624: LD_VAR 0 5
3628: ST_TO_ADDR
// end ;
3629: LD_VAR 0 3
3633: RET
// export function ComBuildLabList ( plist , list ) ; var i , p ; begin
3634: LD_INT 0
3636: PPUSH
3637: PPUSH
3638: PPUSH
// if GetBaseSource ( MyBase ( GetSide ( plist [ 1 ] ) ) ) [ 1 ] > 75 then
3639: LD_VAR 0 1
3643: PUSH
3644: LD_INT 1
3646: ARRAY
3647: PPUSH
3648: CALL_OW 255
3652: PPUSH
3653: CALL 1174 0 1
3657: PPUSH
3658: CALL 866 0 1
3662: PUSH
3663: LD_INT 1
3665: ARRAY
3666: PUSH
3667: LD_INT 75
3669: GREATER
3670: IFFALSE 4121
// for i = 1 to list do
3672: LD_ADDR_VAR 0 4
3676: PUSH
3677: DOUBLE
3678: LD_INT 1
3680: DEC
3681: ST_TO_ADDR
3682: LD_VAR 0 2
3686: PUSH
3687: FOR_TO
3688: IFFALSE 4119
// begin if HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) > 0 then
3690: LD_VAR 0 2
3694: PUSH
3695: LD_VAR 0 4
3699: ARRAY
3700: PUSH
3701: LD_INT 1
3703: ARRAY
3704: PPUSH
3705: LD_VAR 0 2
3709: PUSH
3710: LD_VAR 0 4
3714: ARRAY
3715: PUSH
3716: LD_INT 2
3718: ARRAY
3719: PPUSH
3720: CALL_OW 428
3724: PUSH
3725: LD_INT 0
3727: GREATER
3728: IFFALSE 3890
// begin ComBuildLabKind ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) , list [ i ] [ 4 ] , list [ i ] [ 5 ] ) ;
3730: LD_VAR 0 2
3734: PUSH
3735: LD_VAR 0 4
3739: ARRAY
3740: PUSH
3741: LD_INT 1
3743: ARRAY
3744: PPUSH
3745: LD_VAR 0 2
3749: PUSH
3750: LD_VAR 0 4
3754: ARRAY
3755: PUSH
3756: LD_INT 2
3758: ARRAY
3759: PPUSH
3760: CALL_OW 428
3764: PPUSH
3765: LD_VAR 0 2
3769: PUSH
3770: LD_VAR 0 4
3774: ARRAY
3775: PUSH
3776: LD_INT 4
3778: ARRAY
3779: PPUSH
3780: LD_VAR 0 2
3784: PUSH
3785: LD_VAR 0 4
3789: ARRAY
3790: PUSH
3791: LD_INT 5
3793: ARRAY
3794: PPUSH
3795: CALL 2437 0 3
// if GetBType ( HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) <> b_lab_full then
3799: LD_VAR 0 2
3803: PUSH
3804: LD_VAR 0 4
3808: ARRAY
3809: PUSH
3810: LD_INT 1
3812: ARRAY
3813: PPUSH
3814: LD_VAR 0 2
3818: PUSH
3819: LD_VAR 0 4
3823: ARRAY
3824: PUSH
3825: LD_INT 2
3827: ARRAY
3828: PPUSH
3829: CALL_OW 428
3833: PPUSH
3834: CALL_OW 266
3838: PUSH
3839: LD_INT 8
3841: NONEQUAL
3842: IFFALSE 3888
// ComCompleteUpgrade ( plist , HexInfo ( list [ i ] [ 1 ] , list [ i ] [ 2 ] ) ) ;
3844: LD_VAR 0 1
3848: PPUSH
3849: LD_VAR 0 2
3853: PUSH
3854: LD_VAR 0 4
3858: ARRAY
3859: PUSH
3860: LD_INT 1
3862: ARRAY
3863: PPUSH
3864: LD_VAR 0 2
3868: PUSH
3869: LD_VAR 0 4
3873: ARRAY
3874: PUSH
3875: LD_INT 2
3877: ARRAY
3878: PPUSH
3879: CALL_OW 428
3883: PPUSH
3884: CALL 5468 0 2
// end else
3888: GO 4117
// if Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , b_lab ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 4 ] ) and Cost ( MyBase ( GetSide ( plist [ 1 ] ) ) , list [ i ] [ 5 ] ) then
3890: LD_VAR 0 1
3894: PUSH
3895: LD_INT 1
3897: ARRAY
3898: PPUSH
3899: CALL_OW 255
3903: PPUSH
3904: CALL 1174 0 1
3908: PPUSH
3909: LD_INT 6
3911: PPUSH
3912: CALL 750 0 2
3916: PUSH
3917: LD_VAR 0 1
3921: PUSH
3922: LD_INT 1
3924: ARRAY
3925: PPUSH
3926: CALL_OW 255
3930: PPUSH
3931: CALL 1174 0 1
3935: PPUSH
3936: LD_VAR 0 2
3940: PUSH
3941: LD_VAR 0 4
3945: ARRAY
3946: PUSH
3947: LD_INT 4
3949: ARRAY
3950: PPUSH
3951: CALL 750 0 2
3955: AND
3956: PUSH
3957: LD_VAR 0 1
3961: PUSH
3962: LD_INT 1
3964: ARRAY
3965: PPUSH
3966: CALL_OW 255
3970: PPUSH
3971: CALL 1174 0 1
3975: PPUSH
3976: LD_VAR 0 2
3980: PUSH
3981: LD_VAR 0 4
3985: ARRAY
3986: PUSH
3987: LD_INT 5
3989: ARRAY
3990: PPUSH
3991: CALL 750 0 2
3995: AND
3996: IFFALSE 4117
// for p = 1 to plist do
3998: LD_ADDR_VAR 0 5
4002: PUSH
4003: DOUBLE
4004: LD_INT 1
4006: DEC
4007: ST_TO_ADDR
4008: LD_VAR 0 1
4012: PUSH
4013: FOR_TO
4014: IFFALSE 4115
// if IsInUnit ( plist [ p ] ) then
4016: LD_VAR 0 1
4020: PUSH
4021: LD_VAR 0 5
4025: ARRAY
4026: PPUSH
4027: CALL_OW 310
4031: IFFALSE 4050
// ComExitBuilding ( plist [ p ] ) else
4033: LD_VAR 0 1
4037: PUSH
4038: LD_VAR 0 5
4042: ARRAY
4043: PPUSH
4044: CALL_OW 122
4048: GO 4113
// ComBuild ( plist [ p ] , b_lab , list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
4050: LD_VAR 0 1
4054: PUSH
4055: LD_VAR 0 5
4059: ARRAY
4060: PPUSH
4061: LD_INT 6
4063: PPUSH
4064: LD_VAR 0 2
4068: PUSH
4069: LD_VAR 0 4
4073: ARRAY
4074: PUSH
4075: LD_INT 1
4077: ARRAY
4078: PPUSH
4079: LD_VAR 0 2
4083: PUSH
4084: LD_VAR 0 4
4088: ARRAY
4089: PUSH
4090: LD_INT 2
4092: ARRAY
4093: PPUSH
4094: LD_VAR 0 2
4098: PUSH
4099: LD_VAR 0 4
4103: ARRAY
4104: PUSH
4105: LD_INT 3
4107: ARRAY
4108: PPUSH
4109: CALL_OW 145
4113: GO 4013
4115: POP
4116: POP
// end ;
4117: GO 3687
4119: POP
4120: POP
// end ;
4121: LD_VAR 0 3
4125: RET
// export function ComFindDeposit ( sci , x , y ) ; begin
4126: LD_INT 0
4128: PPUSH
// SetTag ( sci , 42 ) ;
4129: LD_VAR 0 1
4133: PPUSH
4134: LD_INT 42
4136: PPUSH
4137: CALL_OW 109
// if IsInUnit ( sci ) then
4141: LD_VAR 0 1
4145: PPUSH
4146: CALL_OW 310
4150: IFFALSE 4163
// ComExitBuilding ( sci ) else
4152: LD_VAR 0 1
4156: PPUSH
4157: CALL_OW 122
4161: GO 4209
// if not HasTask ( sci ) and GetTag ( sci ) = 42 then
4163: LD_VAR 0 1
4167: PPUSH
4168: CALL_OW 314
4172: NOT
4173: PUSH
4174: LD_VAR 0 1
4178: PPUSH
4179: CALL_OW 110
4183: PUSH
4184: LD_INT 42
4186: EQUAL
4187: AND
4188: IFFALSE 4209
// begin ComMoveXY ( sci , x , y ) ;
4190: LD_VAR 0 1
4194: PPUSH
4195: LD_VAR 0 2
4199: PPUSH
4200: LD_VAR 0 3
4204: PPUSH
4205: CALL_OW 111
// end ; end ;
4209: LD_VAR 0 4
4213: RET
// export function NeedHeal ( side , tag_list , list ) ; var i , filter , tmp ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
4218: PPUSH
4219: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) diff list ;
4220: LD_ADDR_VAR 0 6
4224: PUSH
4225: LD_INT 22
4227: PUSH
4228: LD_VAR 0 1
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PUSH
4237: LD_INT 21
4239: PUSH
4240: LD_INT 1
4242: PUSH
4243: EMPTY
4244: LIST
4245: LIST
4246: PUSH
4247: EMPTY
4248: LIST
4249: LIST
4250: PPUSH
4251: CALL_OW 69
4255: PUSH
4256: LD_VAR 0 3
4260: DIFF
4261: ST_TO_ADDR
// tmp := tag_list ;
4262: LD_ADDR_VAR 0 7
4266: PUSH
4267: LD_VAR 0 2
4271: ST_TO_ADDR
// for i = 1 to filter do
4272: LD_ADDR_VAR 0 5
4276: PUSH
4277: DOUBLE
4278: LD_INT 1
4280: DEC
4281: ST_TO_ADDR
4282: LD_VAR 0 6
4286: PUSH
4287: FOR_TO
4288: IFFALSE 4557
// begin if GetLives ( filter [ i ] ) = 1000 and GetTag ( filter [ i ] ) >= 100 then
4290: LD_VAR 0 6
4294: PUSH
4295: LD_VAR 0 5
4299: ARRAY
4300: PPUSH
4301: CALL_OW 256
4305: PUSH
4306: LD_INT 1000
4308: EQUAL
4309: PUSH
4310: LD_VAR 0 6
4314: PUSH
4315: LD_VAR 0 5
4319: ARRAY
4320: PPUSH
4321: CALL_OW 110
4325: PUSH
4326: LD_INT 100
4328: GREATEREQUAL
4329: AND
4330: IFFALSE 4372
// begin SetTag ( filter [ i ] , 0 ) ;
4332: LD_VAR 0 6
4336: PUSH
4337: LD_VAR 0 5
4341: ARRAY
4342: PPUSH
4343: LD_INT 0
4345: PPUSH
4346: CALL_OW 109
// tmp := tmp diff filter [ i ] ;
4350: LD_ADDR_VAR 0 7
4354: PUSH
4355: LD_VAR 0 7
4359: PUSH
4360: LD_VAR 0 6
4364: PUSH
4365: LD_VAR 0 5
4369: ARRAY
4370: DIFF
4371: ST_TO_ADDR
// end ; if GetLives ( filter [ i ] ) < 1000 then
4372: LD_VAR 0 6
4376: PUSH
4377: LD_VAR 0 5
4381: ARRAY
4382: PPUSH
4383: CALL_OW 256
4387: PUSH
4388: LD_INT 1000
4390: LESS
4391: IFFALSE 4555
// begin if not filter [ i ] in tmp then
4393: LD_VAR 0 6
4397: PUSH
4398: LD_VAR 0 5
4402: ARRAY
4403: PUSH
4404: LD_VAR 0 7
4408: IN
4409: NOT
4410: IFFALSE 4434
// tmp := tmp ^ filter [ i ] ;
4412: LD_ADDR_VAR 0 7
4416: PUSH
4417: LD_VAR 0 7
4421: PUSH
4422: LD_VAR 0 6
4426: PUSH
4427: LD_VAR 0 5
4431: ARRAY
4432: ADD
4433: ST_TO_ADDR
// if GetLives ( filter [ i ] ) < 250 then
4434: LD_VAR 0 6
4438: PUSH
4439: LD_VAR 0 5
4443: ARRAY
4444: PPUSH
4445: CALL_OW 256
4449: PUSH
4450: LD_INT 250
4452: LESS
4453: IFFALSE 4475
// SetTag ( filter [ i ] , 100 ) else
4455: LD_VAR 0 6
4459: PUSH
4460: LD_VAR 0 5
4464: ARRAY
4465: PPUSH
4466: LD_INT 100
4468: PPUSH
4469: CALL_OW 109
4473: GO 4555
// if GetLives ( filter [ i ] ) < 500 then
4475: LD_VAR 0 6
4479: PUSH
4480: LD_VAR 0 5
4484: ARRAY
4485: PPUSH
4486: CALL_OW 256
4490: PUSH
4491: LD_INT 500
4493: LESS
4494: IFFALSE 4516
// SetTag ( filter [ i ] , 101 ) else
4496: LD_VAR 0 6
4500: PUSH
4501: LD_VAR 0 5
4505: ARRAY
4506: PPUSH
4507: LD_INT 101
4509: PPUSH
4510: CALL_OW 109
4514: GO 4555
// if GetLives ( filter [ i ] ) < 1000 then
4516: LD_VAR 0 6
4520: PUSH
4521: LD_VAR 0 5
4525: ARRAY
4526: PPUSH
4527: CALL_OW 256
4531: PUSH
4532: LD_INT 1000
4534: LESS
4535: IFFALSE 4555
// SetTag ( filter [ i ] , 102 ) ;
4537: LD_VAR 0 6
4541: PUSH
4542: LD_VAR 0 5
4546: ARRAY
4547: PPUSH
4548: LD_INT 102
4550: PPUSH
4551: CALL_OW 109
// end ; end ;
4555: GO 4287
4557: POP
4558: POP
// result := tmp ;
4559: LD_ADDR_VAR 0 4
4563: PUSH
4564: LD_VAR 0 7
4568: ST_TO_ADDR
// end ;
4569: LD_VAR 0 4
4573: RET
// export function WantHeal ( sci , tag ) ; begin
4574: LD_INT 0
4576: PPUSH
// if GetTaskList ( sci ) > 0 then
4577: LD_VAR 0 1
4581: PPUSH
4582: CALL_OW 437
4586: PUSH
4587: LD_INT 0
4589: GREATER
4590: IFFALSE 4665
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTag ( GetTaskList ( sci ) [ 1 ] [ 4 ] ) = tag then
4592: LD_VAR 0 1
4596: PPUSH
4597: CALL_OW 437
4601: PUSH
4602: LD_INT 1
4604: ARRAY
4605: PUSH
4606: LD_INT 1
4608: ARRAY
4609: PUSH
4610: LD_STRING l
4612: EQUAL
4613: PUSH
4614: LD_VAR 0 1
4618: PPUSH
4619: CALL_OW 437
4623: PUSH
4624: LD_INT 1
4626: ARRAY
4627: PUSH
4628: LD_INT 4
4630: ARRAY
4631: PPUSH
4632: CALL_OW 110
4636: PUSH
4637: LD_VAR 0 2
4641: EQUAL
4642: AND
4643: IFFALSE 4655
// result := true else
4645: LD_ADDR_VAR 0 3
4649: PUSH
4650: LD_INT 1
4652: ST_TO_ADDR
4653: GO 4663
// result := false ;
4655: LD_ADDR_VAR 0 3
4659: PUSH
4660: LD_INT 0
4662: ST_TO_ADDR
// end else
4663: GO 4673
// result := false ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: LD_INT 0
4672: ST_TO_ADDR
// end ;
4673: LD_VAR 0 3
4677: RET
// export function IntBazooka ( list , side ) ; var ta , c , i , filter ; begin
4678: LD_INT 0
4680: PPUSH
4681: PPUSH
4682: PPUSH
4683: PPUSH
4684: PPUSH
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
4685: LD_ADDR_VAR 0 7
4689: PUSH
4690: LD_INT 22
4692: PUSH
4693: LD_VAR 0 2
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 3
4704: PUSH
4705: LD_INT 21
4707: PUSH
4708: LD_INT 3
4710: PUSH
4711: EMPTY
4712: LIST
4713: LIST
4714: PUSH
4715: EMPTY
4716: LIST
4717: LIST
4718: PUSH
4719: EMPTY
4720: LIST
4721: LIST
4722: PPUSH
4723: CALL_OW 69
4727: ST_TO_ADDR
// c := Rand ( 1 , 3 ) ;
4728: LD_ADDR_VAR 0 5
4732: PUSH
4733: LD_INT 1
4735: PPUSH
4736: LD_INT 3
4738: PPUSH
4739: CALL_OW 12
4743: ST_TO_ADDR
// if filter > 0 then
4744: LD_VAR 0 7
4748: PUSH
4749: LD_INT 0
4751: GREATER
4752: IFFALSE 4954
// for i = 1 to list do
4754: LD_ADDR_VAR 0 6
4758: PUSH
4759: DOUBLE
4760: LD_INT 1
4762: DEC
4763: ST_TO_ADDR
4764: LD_VAR 0 1
4768: PUSH
4769: FOR_TO
4770: IFFALSE 4952
// for ta in filter do
4772: LD_ADDR_VAR 0 4
4776: PUSH
4777: LD_VAR 0 7
4781: PUSH
4782: FOR_IN
4783: IFFALSE 4948
// begin if GetDistUnits ( list [ i ] , ta ) <= 13 then
4785: LD_VAR 0 1
4789: PUSH
4790: LD_VAR 0 6
4794: ARRAY
4795: PPUSH
4796: LD_VAR 0 4
4800: PPUSH
4801: CALL_OW 296
4805: PUSH
4806: LD_INT 13
4808: LESSEQUAL
4809: IFFALSE 4946
// begin case c of 1 :
4811: LD_VAR 0 5
4815: PUSH
4816: LD_INT 1
4818: DOUBLE
4819: EQUAL
4820: IFTRUE 4824
4822: GO 4862
4824: POP
// ComTimeShift ( list [ i ] , GetX ( ta ) , GetY ( ta ) ) ; 2 :
4825: LD_VAR 0 1
4829: PUSH
4830: LD_VAR 0 6
4834: ARRAY
4835: PPUSH
4836: LD_VAR 0 4
4840: PPUSH
4841: CALL_OW 250
4845: PPUSH
4846: LD_VAR 0 4
4850: PPUSH
4851: CALL_OW 251
4855: PPUSH
4856: CALL_OW 154
4860: GO 4946
4862: LD_INT 2
4864: DOUBLE
4865: EQUAL
4866: IFTRUE 4870
4868: GO 4934
4870: POP
// ComSpaceShift ( list [ i ] , GetX ( ta ) + Rand ( - 1 , 1 ) , GetY ( ta ) + Rand ( - 1 , 1 ) ) ; 3 :
4871: LD_VAR 0 1
4875: PUSH
4876: LD_VAR 0 6
4880: ARRAY
4881: PPUSH
4882: LD_VAR 0 4
4886: PPUSH
4887: CALL_OW 250
4891: PUSH
4892: LD_INT 1
4894: NEG
4895: PPUSH
4896: LD_INT 1
4898: PPUSH
4899: CALL_OW 12
4903: PLUS
4904: PPUSH
4905: LD_VAR 0 4
4909: PPUSH
4910: CALL_OW 251
4914: PUSH
4915: LD_INT 1
4917: NEG
4918: PPUSH
4919: LD_INT 1
4921: PPUSH
4922: CALL_OW 12
4926: PLUS
4927: PPUSH
4928: CALL_OW 153
4932: GO 4946
4934: LD_INT 3
4936: DOUBLE
4937: EQUAL
4938: IFTRUE 4942
4940: GO 4945
4942: POP
// ; end ;
4943: GO 4946
4945: POP
// end ; end ;
4946: GO 4782
4948: POP
4949: POP
4950: GO 4769
4952: POP
4953: POP
// end ;
4954: LD_VAR 0 3
4958: RET
// export function ComChangeClassToBazooker ( plist ) ; var i ; begin
4959: LD_INT 0
4961: PPUSH
4962: PPUSH
// for i = 1 to plist do
4963: LD_ADDR_VAR 0 3
4967: PUSH
4968: DOUBLE
4969: LD_INT 1
4971: DEC
4972: ST_TO_ADDR
4973: LD_VAR 0 1
4977: PUSH
4978: FOR_TO
4979: IFFALSE 5181
// if not IsInUnit ( plist [ i ] ) in FilterAllUnits ( [ [ f_btype , b_barracks ] ] ) then
4981: LD_VAR 0 1
4985: PUSH
4986: LD_VAR 0 3
4990: ARRAY
4991: PPUSH
4992: CALL_OW 310
4996: PUSH
4997: LD_INT 30
4999: PUSH
5000: LD_INT 5
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PUSH
5007: EMPTY
5008: LIST
5009: PPUSH
5010: CALL_OW 69
5014: IN
5015: NOT
5016: IFFALSE 5161
// begin if IsInUnit ( plist [ i ] ) then
5018: LD_VAR 0 1
5022: PUSH
5023: LD_VAR 0 3
5027: ARRAY
5028: PPUSH
5029: CALL_OW 310
5033: IFFALSE 5052
// ComExitBuilding ( plist [ i ] ) else
5035: LD_VAR 0 1
5039: PUSH
5040: LD_VAR 0 3
5044: ARRAY
5045: PPUSH
5046: CALL_OW 122
5050: GO 5159
// if not HasTask ( plist [ i ] ) then
5052: LD_VAR 0 1
5056: PUSH
5057: LD_VAR 0 3
5061: ARRAY
5062: PPUSH
5063: CALL_OW 314
5067: NOT
5068: IFFALSE 5159
// begin ComEnterUnit ( plist [ i ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_btype , b_barracks ] ] ) , plist [ i ] ) ) ;
5070: LD_VAR 0 1
5074: PUSH
5075: LD_VAR 0 3
5079: ARRAY
5080: PPUSH
5081: LD_INT 22
5083: PUSH
5084: LD_VAR 0 1
5088: PUSH
5089: LD_INT 1
5091: ARRAY
5092: PPUSH
5093: CALL_OW 255
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: PUSH
5102: LD_INT 30
5104: PUSH
5105: LD_INT 5
5107: PUSH
5108: EMPTY
5109: LIST
5110: LIST
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PPUSH
5116: CALL_OW 69
5120: PPUSH
5121: LD_VAR 0 1
5125: PUSH
5126: LD_VAR 0 3
5130: ARRAY
5131: PPUSH
5132: CALL_OW 74
5136: PPUSH
5137: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 9 ) ;
5141: LD_VAR 0 1
5145: PUSH
5146: LD_VAR 0 3
5150: ARRAY
5151: PPUSH
5152: LD_INT 9
5154: PPUSH
5155: CALL_OW 183
// end ; end else
5159: GO 5179
// ComChangeProfession ( plist [ i ] , 9 ) ;
5161: LD_VAR 0 1
5165: PUSH
5166: LD_VAR 0 3
5170: ARRAY
5171: PPUSH
5172: LD_INT 9
5174: PPUSH
5175: CALL_OW 123
5179: GO 4978
5181: POP
5182: POP
// end ;
5183: LD_VAR 0 2
5187: RET
// export function GetHuman ( side ) ; begin
5188: LD_INT 0
5190: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
5191: LD_ADDR_VAR 0 2
5195: PUSH
5196: LD_INT 22
5198: PUSH
5199: LD_VAR 0 1
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: PUSH
5208: LD_INT 21
5210: PUSH
5211: LD_INT 1
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: PPUSH
5222: CALL_OW 69
5226: ST_TO_ADDR
// end ;
5227: LD_VAR 0 2
5231: RET
// export function PrepareTigers ( area ) ; var tiger , i ; begin
5232: LD_INT 0
5234: PPUSH
5235: PPUSH
5236: PPUSH
// uc_side := 0 ;
5237: LD_ADDR_OWVAR 20
5241: PUSH
5242: LD_INT 0
5244: ST_TO_ADDR
// uc_nation := 0 ;
5245: LD_ADDR_OWVAR 21
5249: PUSH
5250: LD_INT 0
5252: ST_TO_ADDR
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
5253: LD_ADDR_VAR 0 4
5257: PUSH
5258: DOUBLE
5259: LD_INT 1
5261: DEC
5262: ST_TO_ADDR
5263: LD_INT 4
5265: PUSH
5266: LD_INT 5
5268: PUSH
5269: LD_INT 6
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: PUSH
5277: LD_OWVAR 67
5281: ARRAY
5282: PUSH
5283: FOR_TO
5284: IFFALSE 5355
// begin hc_class = class_tiger ;
5286: LD_ADDR_OWVAR 28
5290: PUSH
5291: LD_INT 14
5293: ST_TO_ADDR
// hc_gallery = sandnature ;
5294: LD_ADDR_OWVAR 33
5298: PUSH
5299: LD_STRING sandnature
5301: ST_TO_ADDR
// hc_agressivity = Rand ( 0 , 50 ) ;
5302: LD_ADDR_OWVAR 35
5306: PUSH
5307: LD_INT 0
5309: PPUSH
5310: LD_INT 50
5312: PPUSH
5313: CALL_OW 12
5317: ST_TO_ADDR
// hc_face_number = 3 ;
5318: LD_ADDR_OWVAR 34
5322: PUSH
5323: LD_INT 3
5325: ST_TO_ADDR
// tiger := CreateHuman ;
5326: LD_ADDR_VAR 0 3
5330: PUSH
5331: CALL_OW 44
5335: ST_TO_ADDR
// PlaceUnitArea ( tiger , area , false ) ;
5336: LD_VAR 0 3
5340: PPUSH
5341: LD_VAR 0 1
5345: PPUSH
5346: LD_INT 0
5348: PPUSH
5349: CALL_OW 49
// end ;
5353: GO 5283
5355: POP
5356: POP
// end ;
5357: LD_VAR 0 2
5361: RET
// export function PrepareApemans ( area ) ; var ape , i ; begin
5362: LD_INT 0
5364: PPUSH
5365: PPUSH
5366: PPUSH
// uc_side := 0 ;
5367: LD_ADDR_OWVAR 20
5371: PUSH
5372: LD_INT 0
5374: ST_TO_ADDR
// uc_nation := 0 ;
5375: LD_ADDR_OWVAR 21
5379: PUSH
5380: LD_INT 0
5382: ST_TO_ADDR
// for i = 1 to 8 do
5383: LD_ADDR_VAR 0 4
5387: PUSH
5388: DOUBLE
5389: LD_INT 1
5391: DEC
5392: ST_TO_ADDR
5393: LD_INT 8
5395: PUSH
5396: FOR_TO
5397: IFFALSE 5461
// begin hc_class = class_apeman ;
5399: LD_ADDR_OWVAR 28
5403: PUSH
5404: LD_INT 12
5406: ST_TO_ADDR
// hc_gallery =  ;
5407: LD_ADDR_OWVAR 33
5411: PUSH
5412: LD_STRING 
5414: ST_TO_ADDR
// hc_agressivity = Rand ( - 5 , 20 ) ;
5415: LD_ADDR_OWVAR 35
5419: PUSH
5420: LD_INT 5
5422: NEG
5423: PPUSH
5424: LD_INT 20
5426: PPUSH
5427: CALL_OW 12
5431: ST_TO_ADDR
// ape := CreateHuman ;
5432: LD_ADDR_VAR 0 3
5436: PUSH
5437: CALL_OW 44
5441: ST_TO_ADDR
// PlaceUnitArea ( ape , area , false ) ;
5442: LD_VAR 0 3
5446: PPUSH
5447: LD_VAR 0 1
5451: PPUSH
5452: LD_INT 0
5454: PPUSH
5455: CALL_OW 49
// end ;
5459: GO 5396
5461: POP
5462: POP
// end ;
5463: LD_VAR 0 2
5467: RET
// export function ComCompleteUpgrade ( plist , b ) ; var i ; begin
5468: LD_INT 0
5470: PPUSH
5471: PPUSH
// if BuildingStatus ( b ) = bs_build then
5472: LD_VAR 0 2
5476: PPUSH
5477: CALL_OW 461
5481: PUSH
5482: LD_INT 1
5484: EQUAL
5485: IFFALSE 5689
// for i = 1 to plist do
5487: LD_ADDR_VAR 0 4
5491: PUSH
5492: DOUBLE
5493: LD_INT 1
5495: DEC
5496: ST_TO_ADDR
5497: LD_VAR 0 1
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5687
// begin if IsInUnit ( plist [ i ] ) then
5505: LD_VAR 0 1
5509: PUSH
5510: LD_VAR 0 4
5514: ARRAY
5515: PPUSH
5516: CALL_OW 310
5520: IFFALSE 5603
// begin ComExitBuilding ( plist [ i ] ) ;
5522: LD_VAR 0 1
5526: PUSH
5527: LD_VAR 0 4
5531: ARRAY
5532: PPUSH
5533: CALL_OW 122
// AddTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
5537: LD_VAR 0 1
5541: PUSH
5542: LD_VAR 0 4
5546: ARRAY
5547: PPUSH
5548: LD_STRING h
5550: PUSH
5551: LD_VAR 0 2
5555: PPUSH
5556: CALL_OW 250
5560: PUSH
5561: LD_VAR 0 2
5565: PPUSH
5566: CALL_OW 251
5570: PUSH
5571: LD_VAR 0 2
5575: PUSH
5576: LD_INT 0
5578: PUSH
5579: LD_INT 0
5581: PUSH
5582: LD_INT 0
5584: PUSH
5585: EMPTY
5586: LIST
5587: LIST
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: LIST
5593: PUSH
5594: EMPTY
5595: LIST
5596: PPUSH
5597: CALL_OW 447
// end else
5601: GO 5685
// if not HasTask ( plist [ i ] ) then
5603: LD_VAR 0 1
5607: PUSH
5608: LD_VAR 0 4
5612: ARRAY
5613: PPUSH
5614: CALL_OW 314
5618: NOT
5619: IFFALSE 5685
// SetTaskList ( plist [ i ] , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
5621: LD_VAR 0 1
5625: PUSH
5626: LD_VAR 0 4
5630: ARRAY
5631: PPUSH
5632: LD_STRING h
5634: PUSH
5635: LD_VAR 0 2
5639: PPUSH
5640: CALL_OW 250
5644: PUSH
5645: LD_VAR 0 2
5649: PPUSH
5650: CALL_OW 251
5654: PUSH
5655: LD_VAR 0 2
5659: PUSH
5660: LD_INT 0
5662: PUSH
5663: LD_INT 0
5665: PUSH
5666: LD_INT 0
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: LIST
5675: LIST
5676: LIST
5677: PUSH
5678: EMPTY
5679: LIST
5680: PPUSH
5681: CALL_OW 446
// end ;
5685: GO 5502
5687: POP
5688: POP
// end ;
5689: LD_VAR 0 3
5693: RET
// export function WantRepair ( eng , x , y ) ; begin
5694: LD_INT 0
5696: PPUSH
// if GetTaskList ( eng ) > 0 then
5697: LD_VAR 0 1
5701: PPUSH
5702: CALL_OW 437
5706: PUSH
5707: LD_INT 0
5709: GREATER
5710: IFFALSE 5805
// begin if GetTaskList ( eng ) [ 1 ] [ 1 ] = o and GetTaskList ( eng ) [ 1 ] [ 2 ] = x and GetTaskList ( eng ) [ 1 ] [ 3 ] = y then
5712: LD_VAR 0 1
5716: PPUSH
5717: CALL_OW 437
5721: PUSH
5722: LD_INT 1
5724: ARRAY
5725: PUSH
5726: LD_INT 1
5728: ARRAY
5729: PUSH
5730: LD_STRING o
5732: EQUAL
5733: PUSH
5734: LD_VAR 0 1
5738: PPUSH
5739: CALL_OW 437
5743: PUSH
5744: LD_INT 1
5746: ARRAY
5747: PUSH
5748: LD_INT 2
5750: ARRAY
5751: PUSH
5752: LD_VAR 0 2
5756: EQUAL
5757: AND
5758: PUSH
5759: LD_VAR 0 1
5763: PPUSH
5764: CALL_OW 437
5768: PUSH
5769: LD_INT 1
5771: ARRAY
5772: PUSH
5773: LD_INT 3
5775: ARRAY
5776: PUSH
5777: LD_VAR 0 3
5781: EQUAL
5782: AND
5783: IFFALSE 5795
// result := true else
5785: LD_ADDR_VAR 0 4
5789: PUSH
5790: LD_INT 1
5792: ST_TO_ADDR
5793: GO 5803
// result := false ;
5795: LD_ADDR_VAR 0 4
5799: PUSH
5800: LD_INT 0
5802: ST_TO_ADDR
// end else
5803: GO 5813
// result := false ;
5805: LD_ADDR_VAR 0 4
5809: PUSH
5810: LD_INT 0
5812: ST_TO_ADDR
// end ;
5813: LD_VAR 0 4
5817: RET
// export function GetBuildingsList ( side , btype ) ; var i , tmp , list ; begin
5818: LD_INT 0
5820: PPUSH
5821: PPUSH
5822: PPUSH
5823: PPUSH
// if btype = - 1 then
5824: LD_VAR 0 2
5828: PUSH
5829: LD_INT 1
5831: NEG
5832: EQUAL
5833: IFFALSE 5873
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) else
5835: LD_ADDR_VAR 0 5
5839: PUSH
5840: LD_INT 22
5842: PUSH
5843: LD_VAR 0 1
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PUSH
5852: LD_INT 21
5854: PUSH
5855: LD_INT 3
5857: PUSH
5858: EMPTY
5859: LIST
5860: LIST
5861: PUSH
5862: EMPTY
5863: LIST
5864: LIST
5865: PPUSH
5866: CALL_OW 69
5870: ST_TO_ADDR
5871: GO 5911
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , btype ] ] ) ;
5873: LD_ADDR_VAR 0 5
5877: PUSH
5878: LD_INT 22
5880: PUSH
5881: LD_VAR 0 1
5885: PUSH
5886: EMPTY
5887: LIST
5888: LIST
5889: PUSH
5890: LD_INT 30
5892: PUSH
5893: LD_VAR 0 2
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PPUSH
5906: CALL_OW 69
5910: ST_TO_ADDR
// list := [ ] ;
5911: LD_ADDR_VAR 0 6
5915: PUSH
5916: EMPTY
5917: ST_TO_ADDR
// for i = 1 to tmp do
5918: LD_ADDR_VAR 0 4
5922: PUSH
5923: DOUBLE
5924: LD_INT 1
5926: DEC
5927: ST_TO_ADDR
5928: LD_VAR 0 5
5932: PUSH
5933: FOR_TO
5934: IFFALSE 6022
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
5936: LD_ADDR_VAR 0 6
5940: PUSH
5941: LD_VAR 0 6
5945: PUSH
5946: LD_VAR 0 5
5950: PUSH
5951: LD_VAR 0 4
5955: ARRAY
5956: PPUSH
5957: CALL_OW 266
5961: PUSH
5962: LD_VAR 0 5
5966: PUSH
5967: LD_VAR 0 4
5971: ARRAY
5972: PPUSH
5973: CALL_OW 250
5977: PUSH
5978: LD_VAR 0 5
5982: PUSH
5983: LD_VAR 0 4
5987: ARRAY
5988: PPUSH
5989: CALL_OW 251
5993: PUSH
5994: LD_VAR 0 5
5998: PUSH
5999: LD_VAR 0 4
6003: ARRAY
6004: PPUSH
6005: CALL_OW 254
6009: PUSH
6010: EMPTY
6011: LIST
6012: LIST
6013: LIST
6014: LIST
6015: PUSH
6016: EMPTY
6017: LIST
6018: ADD
6019: ST_TO_ADDR
6020: GO 5933
6022: POP
6023: POP
// result = list ;
6024: LD_ADDR_VAR 0 3
6028: PUSH
6029: LD_VAR 0 6
6033: ST_TO_ADDR
// end ;
6034: LD_VAR 0 3
6038: RET
// export function GetBehemoth ( side ) ; begin
6039: LD_INT 0
6041: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
6042: LD_ADDR_VAR 0 2
6046: PUSH
6047: LD_INT 22
6049: PUSH
6050: LD_VAR 0 1
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: PUSH
6059: LD_INT 31
6061: PUSH
6062: LD_INT 25
6064: PUSH
6065: EMPTY
6066: LIST
6067: LIST
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: PPUSH
6073: CALL_OW 69
6077: ST_TO_ADDR
// end ;
6078: LD_VAR 0 2
6082: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
6083: LD_INT 0
6085: PPUSH
6086: PPUSH
6087: PPUSH
6088: PPUSH
// tmp := [ ] ;
6089: LD_ADDR_VAR 0 3
6093: PUSH
6094: EMPTY
6095: ST_TO_ADDR
// list := [ ] ;
6096: LD_ADDR_VAR 0 5
6100: PUSH
6101: EMPTY
6102: ST_TO_ADDR
// for i = 16 to 25 do
6103: LD_ADDR_VAR 0 4
6107: PUSH
6108: DOUBLE
6109: LD_INT 16
6111: DEC
6112: ST_TO_ADDR
6113: LD_INT 25
6115: PUSH
6116: FOR_TO
6117: IFFALSE 6190
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
6119: LD_ADDR_VAR 0 3
6123: PUSH
6124: LD_VAR 0 3
6128: PUSH
6129: LD_INT 22
6131: PUSH
6132: LD_VAR 0 1
6136: PPUSH
6137: CALL_OW 255
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PUSH
6146: LD_INT 91
6148: PUSH
6149: LD_VAR 0 1
6153: PUSH
6154: LD_INT 6
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: PUSH
6162: LD_INT 30
6164: PUSH
6165: LD_VAR 0 4
6169: PUSH
6170: EMPTY
6171: LIST
6172: LIST
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: LIST
6178: PUSH
6179: EMPTY
6180: LIST
6181: PPUSH
6182: CALL_OW 69
6186: ADD
6187: ST_TO_ADDR
6188: GO 6116
6190: POP
6191: POP
// for i = 1 to tmp do
6192: LD_ADDR_VAR 0 4
6196: PUSH
6197: DOUBLE
6198: LD_INT 1
6200: DEC
6201: ST_TO_ADDR
6202: LD_VAR 0 3
6206: PUSH
6207: FOR_TO
6208: IFFALSE 6296
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
6210: LD_ADDR_VAR 0 5
6214: PUSH
6215: LD_VAR 0 5
6219: PUSH
6220: LD_VAR 0 3
6224: PUSH
6225: LD_VAR 0 4
6229: ARRAY
6230: PPUSH
6231: CALL_OW 266
6235: PUSH
6236: LD_VAR 0 3
6240: PUSH
6241: LD_VAR 0 4
6245: ARRAY
6246: PPUSH
6247: CALL_OW 250
6251: PUSH
6252: LD_VAR 0 3
6256: PUSH
6257: LD_VAR 0 4
6261: ARRAY
6262: PPUSH
6263: CALL_OW 251
6267: PUSH
6268: LD_VAR 0 3
6272: PUSH
6273: LD_VAR 0 4
6277: ARRAY
6278: PPUSH
6279: CALL_OW 254
6283: PUSH
6284: EMPTY
6285: LIST
6286: LIST
6287: LIST
6288: LIST
6289: PUSH
6290: EMPTY
6291: LIST
6292: ADD
6293: ST_TO_ADDR
6294: GO 6207
6296: POP
6297: POP
// result := list ;
6298: LD_ADDR_VAR 0 2
6302: PUSH
6303: LD_VAR 0 5
6307: ST_TO_ADDR
// end ;
6308: LD_VAR 0 2
6312: RET
// export function RefreshList ( list , list2 ) ; begin
6313: LD_INT 0
6315: PPUSH
// list := Replace ( list , 1 , list [ 1 ] + list2 [ 1 ] ) ;
6316: LD_ADDR_VAR 0 1
6320: PUSH
6321: LD_VAR 0 1
6325: PPUSH
6326: LD_INT 1
6328: PPUSH
6329: LD_VAR 0 1
6333: PUSH
6334: LD_INT 1
6336: ARRAY
6337: PUSH
6338: LD_VAR 0 2
6342: PUSH
6343: LD_INT 1
6345: ARRAY
6346: PLUS
6347: PPUSH
6348: CALL_OW 1
6352: ST_TO_ADDR
// list := Replace ( list , 2 , list [ 2 ] + list2 [ 2 ] ) ;
6353: LD_ADDR_VAR 0 1
6357: PUSH
6358: LD_VAR 0 1
6362: PPUSH
6363: LD_INT 2
6365: PPUSH
6366: LD_VAR 0 1
6370: PUSH
6371: LD_INT 2
6373: ARRAY
6374: PUSH
6375: LD_VAR 0 2
6379: PUSH
6380: LD_INT 2
6382: ARRAY
6383: PLUS
6384: PPUSH
6385: CALL_OW 1
6389: ST_TO_ADDR
// list := Replace ( list , 3 , list [ 3 ] + list2 [ 3 ] ) ;
6390: LD_ADDR_VAR 0 1
6394: PUSH
6395: LD_VAR 0 1
6399: PPUSH
6400: LD_INT 3
6402: PPUSH
6403: LD_VAR 0 1
6407: PUSH
6408: LD_INT 3
6410: ARRAY
6411: PUSH
6412: LD_VAR 0 2
6416: PUSH
6417: LD_INT 3
6419: ARRAY
6420: PLUS
6421: PPUSH
6422: CALL_OW 1
6426: ST_TO_ADDR
// result := list ;
6427: LD_ADDR_VAR 0 3
6431: PUSH
6432: LD_VAR 0 1
6436: ST_TO_ADDR
// end ;
6437: LD_VAR 0 3
6441: RET
// export function BuildFactory ( plist , x , y , d , ext_list ) ; var i , j , buildings_cost , ext_info , _x , _y , _d ; begin
6442: LD_INT 0
6444: PPUSH
6445: PPUSH
6446: PPUSH
6447: PPUSH
6448: PPUSH
6449: PPUSH
6450: PPUSH
6451: PPUSH
// if not plist then
6452: LD_VAR 0 1
6456: NOT
6457: IFFALSE 6467
// result := false ;
6459: LD_ADDR_VAR 0 6
6463: PUSH
6464: LD_INT 0
6466: ST_TO_ADDR
// buildings_cost := [ 0 , 0 , 0 ] ;
6467: LD_ADDR_VAR 0 9
6471: PUSH
6472: LD_INT 0
6474: PUSH
6475: LD_INT 0
6477: PUSH
6478: LD_INT 0
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: LIST
6485: ST_TO_ADDR
// if GetBType ( HexInfo ( x , y ) ) <> b_workshop then
6486: LD_VAR 0 2
6490: PPUSH
6491: LD_VAR 0 3
6495: PPUSH
6496: CALL_OW 428
6500: PPUSH
6501: CALL_OW 266
6505: PUSH
6506: LD_INT 2
6508: NONEQUAL
6509: IFFALSE 6548
// buildings_cost := RefreshList ( buildings_cost , CostOfBuilding ( b_workshop , GetNation ( plist [ 1 ] ) ) ) ;
6511: LD_ADDR_VAR 0 9
6515: PUSH
6516: LD_VAR 0 9
6520: PPUSH
6521: LD_INT 2
6523: PPUSH
6524: LD_VAR 0 1
6528: PUSH
6529: LD_INT 1
6531: ARRAY
6532: PPUSH
6533: CALL_OW 248
6537: PPUSH
6538: CALL_OW 450
6542: PPUSH
6543: CALL 6313 0 2
6547: ST_TO_ADDR
// if GetBType ( HexInfo ( x , y ) ) <> b_factory then
6548: LD_VAR 0 2
6552: PPUSH
6553: LD_VAR 0 3
6557: PPUSH
6558: CALL_OW 428
6562: PPUSH
6563: CALL_OW 266
6567: PUSH
6568: LD_INT 3
6570: NONEQUAL
6571: IFFALSE 6610
// buildings_cost := RefreshList ( buildings_cost , CostOfBuilding ( b_factory , GetNation ( plist [ 1 ] ) ) ) ;
6573: LD_ADDR_VAR 0 9
6577: PUSH
6578: LD_VAR 0 9
6582: PPUSH
6583: LD_INT 3
6585: PPUSH
6586: LD_VAR 0 1
6590: PUSH
6591: LD_INT 1
6593: ARRAY
6594: PPUSH
6595: CALL_OW 248
6599: PPUSH
6600: CALL_OW 450
6604: PPUSH
6605: CALL 6313 0 2
6609: ST_TO_ADDR
// for i = 1 to ext_list do
6610: LD_ADDR_VAR 0 7
6614: PUSH
6615: DOUBLE
6616: LD_INT 1
6618: DEC
6619: ST_TO_ADDR
6620: LD_VAR 0 5
6624: PUSH
6625: FOR_TO
6626: IFFALSE 6675
// buildings_cost := RefreshList ( buildings_cost , CostOfBuilding ( ext_list [ i ] , GetNation ( plist [ 1 ] ) ) ) ;
6628: LD_ADDR_VAR 0 9
6632: PUSH
6633: LD_VAR 0 9
6637: PPUSH
6638: LD_VAR 0 5
6642: PUSH
6643: LD_VAR 0 7
6647: ARRAY
6648: PPUSH
6649: LD_VAR 0 1
6653: PUSH
6654: LD_INT 1
6656: ARRAY
6657: PPUSH
6658: CALL_OW 248
6662: PPUSH
6663: CALL_OW 450
6667: PPUSH
6668: CALL 6313 0 2
6672: ST_TO_ADDR
6673: GO 6625
6675: POP
6676: POP
// if HexInfo ( x , y ) = 0 and ValidHex ( x , y ) and GetBaseSource ( MyBase ( GetSide ( plist [ 1 ] ) ) ) >= buildings_cost then
6677: LD_VAR 0 2
6681: PPUSH
6682: LD_VAR 0 3
6686: PPUSH
6687: CALL_OW 428
6691: PUSH
6692: LD_INT 0
6694: EQUAL
6695: PUSH
6696: LD_VAR 0 2
6700: PPUSH
6701: LD_VAR 0 3
6705: PPUSH
6706: CALL_OW 488
6710: AND
6711: PUSH
6712: LD_VAR 0 1
6716: PUSH
6717: LD_INT 1
6719: ARRAY
6720: PPUSH
6721: CALL_OW 255
6725: PPUSH
6726: CALL 1174 0 1
6730: PPUSH
6731: CALL 866 0 1
6735: PUSH
6736: LD_VAR 0 9
6740: GREATEREQUAL
6741: AND
6742: IFFALSE 6851
// for i = 1 to plist do
6744: LD_ADDR_VAR 0 7
6748: PUSH
6749: DOUBLE
6750: LD_INT 1
6752: DEC
6753: ST_TO_ADDR
6754: LD_VAR 0 1
6758: PUSH
6759: FOR_TO
6760: IFFALSE 6849
// begin if IsInUnit ( plist [ i ] ) then
6762: LD_VAR 0 1
6766: PUSH
6767: LD_VAR 0 7
6771: ARRAY
6772: PPUSH
6773: CALL_OW 310
6777: IFFALSE 6796
// ComExitBuilding ( plist [ i ] ) else
6779: LD_VAR 0 1
6783: PUSH
6784: LD_VAR 0 7
6788: ARRAY
6789: PPUSH
6790: CALL_OW 122
6794: GO 6847
// if not HasTask ( plist [ i ] ) then
6796: LD_VAR 0 1
6800: PUSH
6801: LD_VAR 0 7
6805: ARRAY
6806: PPUSH
6807: CALL_OW 314
6811: NOT
6812: IFFALSE 6847
// begin ComBuild ( plist [ i ] , b_workshop , x , y , d ) ;
6814: LD_VAR 0 1
6818: PUSH
6819: LD_VAR 0 7
6823: ARRAY
6824: PPUSH
6825: LD_INT 2
6827: PPUSH
6828: LD_VAR 0 2
6832: PPUSH
6833: LD_VAR 0 3
6837: PPUSH
6838: LD_VAR 0 4
6842: PPUSH
6843: CALL_OW 145
// end ; end ;
6847: GO 6759
6849: POP
6850: POP
// if GetBType ( HexInfo ( x , y ) ) = b_workshop and GetBaseSource ( MyBase ( GetSide ( plist [ 1 ] ) ) ) >= buildings_cost then
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_VAR 0 3
6860: PPUSH
6861: CALL_OW 428
6865: PPUSH
6866: CALL_OW 266
6870: PUSH
6871: LD_INT 2
6873: EQUAL
6874: PUSH
6875: LD_VAR 0 1
6879: PUSH
6880: LD_INT 1
6882: ARRAY
6883: PPUSH
6884: CALL_OW 255
6888: PPUSH
6889: CALL 1174 0 1
6893: PPUSH
6894: CALL 866 0 1
6898: PUSH
6899: LD_VAR 0 9
6903: GREATEREQUAL
6904: AND
6905: IFFALSE 6950
// begin ComUpgrade ( HexInfo ( x , y ) ) ;
6907: LD_VAR 0 2
6911: PPUSH
6912: LD_VAR 0 3
6916: PPUSH
6917: CALL_OW 428
6921: PPUSH
6922: CALL_OW 146
// ComCompleteUpgrade ( plist , HexInfo ( x , y ) ) ;
6926: LD_VAR 0 1
6930: PPUSH
6931: LD_VAR 0 2
6935: PPUSH
6936: LD_VAR 0 3
6940: PPUSH
6941: CALL_OW 428
6945: PPUSH
6946: CALL 5468 0 2
// end ; if GetBType ( HexInfo ( x , y ) ) = b_factory and GetBaseSource ( MyBase ( GetSide ( plist [ 1 ] ) ) ) >= buildings_cost then
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_VAR 0 3
6959: PPUSH
6960: CALL_OW 428
6964: PPUSH
6965: CALL_OW 266
6969: PUSH
6970: LD_INT 3
6972: EQUAL
6973: PUSH
6974: LD_VAR 0 1
6978: PUSH
6979: LD_INT 1
6981: ARRAY
6982: PPUSH
6983: CALL_OW 255
6987: PPUSH
6988: CALL 1174 0 1
6992: PPUSH
6993: CALL 866 0 1
6997: PUSH
6998: LD_VAR 0 9
7002: GREATEREQUAL
7003: AND
7004: IFFALSE 7328
// if GetFacExt ( HexInfo ( x , y ) ) < ext_list then
7006: LD_VAR 0 2
7010: PPUSH
7011: LD_VAR 0 3
7015: PPUSH
7016: CALL_OW 428
7020: PPUSH
7021: CALL 6083 0 1
7025: PUSH
7026: LD_VAR 0 5
7030: LESS
7031: IFFALSE 7328
// begin ext_info := GetFacExtDir ( x , y , d ) ;
7033: LD_ADDR_VAR 0 10
7037: PUSH
7038: LD_VAR 0 2
7042: PPUSH
7043: LD_VAR 0 3
7047: PPUSH
7048: LD_VAR 0 4
7052: PPUSH
7053: CALL 7702 0 3
7057: ST_TO_ADDR
// for i = 1 to ext_list do
7058: LD_ADDR_VAR 0 7
7062: PUSH
7063: DOUBLE
7064: LD_INT 1
7066: DEC
7067: ST_TO_ADDR
7068: LD_VAR 0 5
7072: PUSH
7073: FOR_TO
7074: IFFALSE 7326
// begin if HexInfo ( ext_info [ i ] [ 1 ] , ext_info [ i ] [ 2 ] ) = 0 and ExtensionAllow ( GetSide ( plist [ 1 ] ) , ext_list [ i ] ) then
7076: LD_VAR 0 10
7080: PUSH
7081: LD_VAR 0 7
7085: ARRAY
7086: PUSH
7087: LD_INT 1
7089: ARRAY
7090: PPUSH
7091: LD_VAR 0 10
7095: PUSH
7096: LD_VAR 0 7
7100: ARRAY
7101: PUSH
7102: LD_INT 2
7104: ARRAY
7105: PPUSH
7106: CALL_OW 428
7110: PUSH
7111: LD_INT 0
7113: EQUAL
7114: PUSH
7115: LD_VAR 0 1
7119: PUSH
7120: LD_INT 1
7122: ARRAY
7123: PPUSH
7124: CALL_OW 255
7128: PPUSH
7129: LD_VAR 0 5
7133: PUSH
7134: LD_VAR 0 7
7138: ARRAY
7139: PPUSH
7140: CALL 7333 0 2
7144: AND
7145: IFFALSE 7324
// begin _x := ext_info [ i ] [ 1 ] ;
7147: LD_ADDR_VAR 0 11
7151: PUSH
7152: LD_VAR 0 10
7156: PUSH
7157: LD_VAR 0 7
7161: ARRAY
7162: PUSH
7163: LD_INT 1
7165: ARRAY
7166: ST_TO_ADDR
// _y := ext_info [ i ] [ 2 ] ;
7167: LD_ADDR_VAR 0 12
7171: PUSH
7172: LD_VAR 0 10
7176: PUSH
7177: LD_VAR 0 7
7181: ARRAY
7182: PUSH
7183: LD_INT 2
7185: ARRAY
7186: ST_TO_ADDR
// _d := ext_info [ i ] [ 3 ] ;
7187: LD_ADDR_VAR 0 13
7191: PUSH
7192: LD_VAR 0 10
7196: PUSH
7197: LD_VAR 0 7
7201: ARRAY
7202: PUSH
7203: LD_INT 3
7205: ARRAY
7206: ST_TO_ADDR
// for j = 1 to plist do
7207: LD_ADDR_VAR 0 8
7211: PUSH
7212: DOUBLE
7213: LD_INT 1
7215: DEC
7216: ST_TO_ADDR
7217: LD_VAR 0 1
7221: PUSH
7222: FOR_TO
7223: IFFALSE 7320
// begin if IsInUnit ( plist [ j ] ) then
7225: LD_VAR 0 1
7229: PUSH
7230: LD_VAR 0 8
7234: ARRAY
7235: PPUSH
7236: CALL_OW 310
7240: IFFALSE 7259
// ComExitBuilding ( plist [ j ] ) else
7242: LD_VAR 0 1
7246: PUSH
7247: LD_VAR 0 8
7251: ARRAY
7252: PPUSH
7253: CALL_OW 122
7257: GO 7318
// if not HasTask ( plist [ j ] ) then
7259: LD_VAR 0 1
7263: PUSH
7264: LD_VAR 0 8
7268: ARRAY
7269: PPUSH
7270: CALL_OW 314
7274: NOT
7275: IFFALSE 7318
// begin ComBuild ( plist [ j ] , ext_list [ i ] , _x , _y , _d ) ;
7277: LD_VAR 0 1
7281: PUSH
7282: LD_VAR 0 8
7286: ARRAY
7287: PPUSH
7288: LD_VAR 0 5
7292: PUSH
7293: LD_VAR 0 7
7297: ARRAY
7298: PPUSH
7299: LD_VAR 0 11
7303: PPUSH
7304: LD_VAR 0 12
7308: PPUSH
7309: LD_VAR 0 13
7313: PPUSH
7314: CALL_OW 145
// end ; end ;
7318: GO 7222
7320: POP
7321: POP
// break ;
7322: GO 7326
// end ; end ;
7324: GO 7073
7326: POP
7327: POP
// end ; end ;
7328: LD_VAR 0 6
7332: RET
// export function ExtensionAllow ( side , ext_type ) ; var i , mode ; begin
7333: LD_INT 0
7335: PPUSH
7336: PPUSH
7337: PPUSH
// mode := false ;
7338: LD_ADDR_VAR 0 5
7342: PUSH
7343: LD_INT 0
7345: ST_TO_ADDR
// case ext_type of b_ext_gun :
7346: LD_VAR 0 2
7350: PUSH
7351: LD_INT 17
7353: DOUBLE
7354: EQUAL
7355: IFTRUE 7359
7357: GO 7388
7359: POP
// if GetTech ( tech_gun , side ) = state_researched then
7360: LD_INT 39
7362: PPUSH
7363: LD_VAR 0 1
7367: PPUSH
7368: CALL_OW 321
7372: PUSH
7373: LD_INT 2
7375: EQUAL
7376: IFFALSE 7386
// mode := true ; b_ext_laser :
7378: LD_ADDR_VAR 0 5
7382: PUSH
7383: LD_INT 1
7385: ST_TO_ADDR
7386: GO 7631
7388: LD_INT 25
7390: DOUBLE
7391: EQUAL
7392: IFTRUE 7396
7394: GO 7425
7396: POP
// if GetTech ( tech_laser , side ) = state_researched then
7397: LD_INT 10
7399: PPUSH
7400: LD_VAR 0 1
7404: PPUSH
7405: CALL_OW 321
7409: PUSH
7410: LD_INT 2
7412: EQUAL
7413: IFFALSE 7423
// mode := true ; b_ext_rocket :
7415: LD_ADDR_VAR 0 5
7419: PUSH
7420: LD_INT 1
7422: ST_TO_ADDR
7423: GO 7631
7425: LD_INT 18
7427: DOUBLE
7428: EQUAL
7429: IFTRUE 7433
7431: GO 7462
7433: POP
// if GetTech ( tech_rocket , side ) = state_researched then
7434: LD_INT 40
7436: PPUSH
7437: LD_VAR 0 1
7441: PPUSH
7442: CALL_OW 321
7446: PUSH
7447: LD_INT 2
7449: EQUAL
7450: IFFALSE 7460
// mode := true ; b_ext_computer :
7452: LD_ADDR_VAR 0 5
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
7460: GO 7631
7462: LD_INT 24
7464: DOUBLE
7465: EQUAL
7466: IFTRUE 7470
7468: GO 7499
7470: POP
// if GetTech ( tech_ai , side ) = state_researched then
7471: LD_INT 32
7473: PPUSH
7474: LD_VAR 0 1
7478: PPUSH
7479: CALL_OW 321
7483: PUSH
7484: LD_INT 2
7486: EQUAL
7487: IFFALSE 7497
// mode := true ; b_ext_siberium :
7489: LD_ADDR_VAR 0 5
7493: PUSH
7494: LD_INT 1
7496: ST_TO_ADDR
7497: GO 7631
7499: LD_INT 21
7501: DOUBLE
7502: EQUAL
7503: IFTRUE 7507
7505: GO 7536
7507: POP
// if GetTech ( tech_sibeng , side ) = state_researched then
7508: LD_INT 22
7510: PPUSH
7511: LD_VAR 0 1
7515: PPUSH
7516: CALL_OW 321
7520: PUSH
7521: LD_INT 2
7523: EQUAL
7524: IFFALSE 7534
// mode := true ; b_ext_radar :
7526: LD_ADDR_VAR 0 5
7530: PUSH
7531: LD_INT 1
7533: ST_TO_ADDR
7534: GO 7631
7536: LD_INT 20
7538: DOUBLE
7539: EQUAL
7540: IFTRUE 7544
7542: GO 7573
7544: POP
// if GetTech ( tech_radar , side ) = state_researched then
7545: LD_INT 6
7547: PPUSH
7548: LD_VAR 0 1
7552: PPUSH
7553: CALL_OW 321
7557: PUSH
7558: LD_INT 2
7560: EQUAL
7561: IFFALSE 7571
// mode := true ; b_ext_noncombat :
7563: LD_ADDR_VAR 0 5
7567: PUSH
7568: LD_INT 1
7570: ST_TO_ADDR
7571: GO 7631
7573: LD_INT 19
7575: DOUBLE
7576: EQUAL
7577: IFTRUE 7581
7579: GO 7592
7581: POP
// mode := true ; b_ext_track :
7582: LD_ADDR_VAR 0 5
7586: PUSH
7587: LD_INT 1
7589: ST_TO_ADDR
7590: GO 7631
7592: LD_INT 16
7594: DOUBLE
7595: EQUAL
7596: IFTRUE 7600
7598: GO 7611
7600: POP
// mode := true ; b_ext_stitch :
7601: LD_ADDR_VAR 0 5
7605: PUSH
7606: LD_INT 1
7608: ST_TO_ADDR
7609: GO 7631
7611: LD_INT 23
7613: DOUBLE
7614: EQUAL
7615: IFTRUE 7619
7617: GO 7630
7619: POP
// mode := true ; end ;
7620: LD_ADDR_VAR 0 5
7624: PUSH
7625: LD_INT 1
7627: ST_TO_ADDR
7628: GO 7631
7630: POP
// result := mode ;
7631: LD_ADDR_VAR 0 3
7635: PUSH
7636: LD_VAR 0 5
7640: ST_TO_ADDR
// end ;
7641: LD_VAR 0 3
7645: RET
// export function DisplayFactoryInfo ( factory ) ; begin
7646: LD_INT 0
7648: PPUSH
// display_strings := [ Factory(x,y):  , GetX ( factory ) , GetY ( factory ) , Factory Ext:  , GetFacExt ( factory ) ] ;
7649: LD_ADDR_OWVAR 47
7653: PUSH
7654: LD_STRING Factory(x,y): 
7656: PUSH
7657: LD_VAR 0 1
7661: PPUSH
7662: CALL_OW 250
7666: PUSH
7667: LD_VAR 0 1
7671: PPUSH
7672: CALL_OW 251
7676: PUSH
7677: LD_STRING Factory Ext: 
7679: PUSH
7680: LD_VAR 0 1
7684: PPUSH
7685: CALL 6083 0 1
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: LIST
7694: LIST
7695: LIST
7696: ST_TO_ADDR
// end ;
7697: LD_VAR 0 2
7701: RET
// export function GetFacExtDir ( x , y , dir ) ; var list , i ; begin
7702: LD_INT 0
7704: PPUSH
7705: PPUSH
7706: PPUSH
// list := [ ] ;
7707: LD_ADDR_VAR 0 5
7711: PUSH
7712: EMPTY
7713: ST_TO_ADDR
// case dir of 0 :
7714: LD_VAR 0 3
7718: PUSH
7719: LD_INT 0
7721: DOUBLE
7722: EQUAL
7723: IFTRUE 7727
7725: GO 7860
7727: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
7728: LD_ADDR_VAR 0 5
7732: PUSH
7733: LD_VAR 0 1
7737: PUSH
7738: LD_INT 4
7740: MINUS
7741: PUSH
7742: LD_VAR 0 2
7746: PUSH
7747: LD_INT 4
7749: MINUS
7750: PUSH
7751: LD_INT 2
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: LIST
7758: PUSH
7759: LD_VAR 0 1
7763: PUSH
7764: LD_INT 3
7766: MINUS
7767: PUSH
7768: LD_VAR 0 2
7772: PUSH
7773: LD_INT 1
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: LIST
7780: PUSH
7781: LD_VAR 0 1
7785: PUSH
7786: LD_INT 4
7788: PLUS
7789: PUSH
7790: LD_VAR 0 2
7794: PUSH
7795: LD_INT 4
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: LIST
7802: PUSH
7803: LD_VAR 0 1
7807: PUSH
7808: LD_INT 3
7810: PLUS
7811: PUSH
7812: LD_VAR 0 2
7816: PUSH
7817: LD_INT 3
7819: PLUS
7820: PUSH
7821: LD_INT 5
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: LIST
7828: PUSH
7829: LD_VAR 0 1
7833: PUSH
7834: LD_VAR 0 2
7838: PUSH
7839: LD_INT 4
7841: PLUS
7842: PUSH
7843: LD_INT 0
7845: PUSH
7846: EMPTY
7847: LIST
7848: LIST
7849: LIST
7850: PUSH
7851: EMPTY
7852: LIST
7853: LIST
7854: LIST
7855: LIST
7856: LIST
7857: ST_TO_ADDR
// end ; 1 :
7858: GO 8558
7860: LD_INT 1
7862: DOUBLE
7863: EQUAL
7864: IFTRUE 7868
7866: GO 8001
7868: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 3 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
7869: LD_ADDR_VAR 0 5
7873: PUSH
7874: LD_VAR 0 1
7878: PUSH
7879: LD_VAR 0 2
7883: PUSH
7884: LD_INT 4
7886: MINUS
7887: PUSH
7888: LD_INT 3
7890: PUSH
7891: EMPTY
7892: LIST
7893: LIST
7894: LIST
7895: PUSH
7896: LD_VAR 0 1
7900: PUSH
7901: LD_INT 3
7903: MINUS
7904: PUSH
7905: LD_VAR 0 2
7909: PUSH
7910: LD_INT 3
7912: MINUS
7913: PUSH
7914: LD_INT 2
7916: PUSH
7917: EMPTY
7918: LIST
7919: LIST
7920: LIST
7921: PUSH
7922: LD_VAR 0 1
7926: PUSH
7927: LD_INT 3
7929: MINUS
7930: PUSH
7931: LD_VAR 0 2
7935: PUSH
7936: LD_INT 1
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: LIST
7943: PUSH
7944: LD_VAR 0 1
7948: PUSH
7949: LD_VAR 0 2
7953: PUSH
7954: LD_INT 3
7956: PLUS
7957: PUSH
7958: LD_INT 0
7960: PUSH
7961: EMPTY
7962: LIST
7963: LIST
7964: LIST
7965: PUSH
7966: LD_VAR 0 1
7970: PUSH
7971: LD_INT 4
7973: PLUS
7974: PUSH
7975: LD_VAR 0 2
7979: PUSH
7980: LD_INT 4
7982: PLUS
7983: PUSH
7984: LD_INT 5
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: LIST
7991: PUSH
7992: EMPTY
7993: LIST
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
// end ; 2 :
7999: GO 8558
8001: LD_INT 2
8003: DOUBLE
8004: EQUAL
8005: IFTRUE 8009
8007: GO 8138
8009: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 3 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
8010: LD_ADDR_VAR 0 5
8014: PUSH
8015: LD_VAR 0 1
8019: PUSH
8020: LD_VAR 0 2
8024: PUSH
8025: LD_INT 3
8027: MINUS
8028: PUSH
8029: LD_INT 3
8031: PUSH
8032: EMPTY
8033: LIST
8034: LIST
8035: LIST
8036: PUSH
8037: LD_VAR 0 1
8041: PUSH
8042: LD_INT 3
8044: PLUS
8045: PUSH
8046: LD_VAR 0 2
8050: PUSH
8051: LD_INT 4
8053: PUSH
8054: EMPTY
8055: LIST
8056: LIST
8057: LIST
8058: PUSH
8059: LD_VAR 0 1
8063: PUSH
8064: LD_VAR 0 2
8068: PUSH
8069: LD_INT 4
8071: PLUS
8072: PUSH
8073: LD_INT 0
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: LIST
8080: PUSH
8081: LD_VAR 0 1
8085: PUSH
8086: LD_INT 3
8088: MINUS
8089: PUSH
8090: LD_VAR 0 2
8094: PUSH
8095: LD_INT 1
8097: PUSH
8098: EMPTY
8099: LIST
8100: LIST
8101: LIST
8102: PUSH
8103: LD_VAR 0 1
8107: PUSH
8108: LD_INT 4
8110: MINUS
8111: PUSH
8112: LD_VAR 0 2
8116: PUSH
8117: LD_INT 4
8119: MINUS
8120: PUSH
8121: LD_INT 2
8123: PUSH
8124: EMPTY
8125: LIST
8126: LIST
8127: LIST
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: LIST
8133: LIST
8134: LIST
8135: ST_TO_ADDR
// end ; 3 :
8136: GO 8558
8138: LD_INT 3
8140: DOUBLE
8141: EQUAL
8142: IFTRUE 8146
8144: GO 8279
8146: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
8147: LD_ADDR_VAR 0 5
8151: PUSH
8152: LD_VAR 0 1
8156: PUSH
8157: LD_INT 3
8159: PLUS
8160: PUSH
8161: LD_VAR 0 2
8165: PUSH
8166: LD_INT 4
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: LIST
8173: PUSH
8174: LD_VAR 0 1
8178: PUSH
8179: LD_INT 4
8181: PLUS
8182: PUSH
8183: LD_VAR 0 2
8187: PUSH
8188: LD_INT 4
8190: PLUS
8191: PUSH
8192: LD_INT 5
8194: PUSH
8195: EMPTY
8196: LIST
8197: LIST
8198: LIST
8199: PUSH
8200: LD_VAR 0 1
8204: PUSH
8205: LD_INT 4
8207: MINUS
8208: PUSH
8209: LD_VAR 0 2
8213: PUSH
8214: LD_INT 1
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_VAR 0 1
8226: PUSH
8227: LD_VAR 0 2
8231: PUSH
8232: LD_INT 4
8234: MINUS
8235: PUSH
8236: LD_INT 3
8238: PUSH
8239: EMPTY
8240: LIST
8241: LIST
8242: LIST
8243: PUSH
8244: LD_VAR 0 1
8248: PUSH
8249: LD_INT 3
8251: MINUS
8252: PUSH
8253: LD_VAR 0 2
8257: PUSH
8258: LD_INT 3
8260: MINUS
8261: PUSH
8262: LD_INT 2
8264: PUSH
8265: EMPTY
8266: LIST
8267: LIST
8268: LIST
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: LIST
8274: LIST
8275: LIST
8276: ST_TO_ADDR
// end ; 4 :
8277: GO 8558
8279: LD_INT 4
8281: DOUBLE
8282: EQUAL
8283: IFTRUE 8287
8285: GO 8420
8287: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 3 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
8288: LD_ADDR_VAR 0 5
8292: PUSH
8293: LD_VAR 0 1
8297: PUSH
8298: LD_VAR 0 2
8302: PUSH
8303: LD_INT 4
8305: PLUS
8306: PUSH
8307: LD_INT 0
8309: PUSH
8310: EMPTY
8311: LIST
8312: LIST
8313: LIST
8314: PUSH
8315: LD_VAR 0 1
8319: PUSH
8320: LD_INT 3
8322: PLUS
8323: PUSH
8324: LD_VAR 0 2
8328: PUSH
8329: LD_INT 3
8331: PLUS
8332: PUSH
8333: LD_INT 5
8335: PUSH
8336: EMPTY
8337: LIST
8338: LIST
8339: LIST
8340: PUSH
8341: LD_VAR 0 1
8345: PUSH
8346: LD_INT 3
8348: PLUS
8349: PUSH
8350: LD_VAR 0 2
8354: PUSH
8355: LD_INT 4
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: LIST
8362: PUSH
8363: LD_VAR 0 1
8367: PUSH
8368: LD_VAR 0 2
8372: PUSH
8373: LD_INT 3
8375: MINUS
8376: PUSH
8377: LD_INT 3
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: LIST
8384: PUSH
8385: LD_VAR 0 1
8389: PUSH
8390: LD_INT 4
8392: MINUS
8393: PUSH
8394: LD_VAR 0 2
8398: PUSH
8399: LD_INT 4
8401: MINUS
8402: PUSH
8403: LD_INT 2
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: LIST
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: LIST
8415: LIST
8416: LIST
8417: ST_TO_ADDR
// end ; 5 :
8418: GO 8558
8420: LD_INT 5
8422: DOUBLE
8423: EQUAL
8424: IFTRUE 8428
8426: GO 8557
8428: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
8429: LD_ADDR_VAR 0 5
8433: PUSH
8434: LD_VAR 0 1
8438: PUSH
8439: LD_INT 4
8441: MINUS
8442: PUSH
8443: LD_VAR 0 2
8447: PUSH
8448: LD_INT 1
8450: PUSH
8451: EMPTY
8452: LIST
8453: LIST
8454: LIST
8455: PUSH
8456: LD_VAR 0 1
8460: PUSH
8461: LD_VAR 0 2
8465: PUSH
8466: LD_INT 4
8468: MINUS
8469: PUSH
8470: LD_INT 3
8472: PUSH
8473: EMPTY
8474: LIST
8475: LIST
8476: LIST
8477: PUSH
8478: LD_VAR 0 1
8482: PUSH
8483: LD_INT 4
8485: PLUS
8486: PUSH
8487: LD_VAR 0 2
8491: PUSH
8492: LD_INT 4
8494: PLUS
8495: PUSH
8496: LD_INT 5
8498: PUSH
8499: EMPTY
8500: LIST
8501: LIST
8502: LIST
8503: PUSH
8504: LD_VAR 0 1
8508: PUSH
8509: LD_INT 3
8511: PLUS
8512: PUSH
8513: LD_VAR 0 2
8517: PUSH
8518: LD_INT 4
8520: PUSH
8521: EMPTY
8522: LIST
8523: LIST
8524: LIST
8525: PUSH
8526: LD_VAR 0 1
8530: PUSH
8531: LD_VAR 0 2
8535: PUSH
8536: LD_INT 3
8538: PLUS
8539: PUSH
8540: LD_INT 0
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: PUSH
8548: EMPTY
8549: LIST
8550: LIST
8551: LIST
8552: LIST
8553: LIST
8554: ST_TO_ADDR
// end ; end ;
8555: GO 8558
8557: POP
// result := list ;
8558: LD_ADDR_VAR 0 4
8562: PUSH
8563: LD_VAR 0 5
8567: ST_TO_ADDR
// end ;
8568: LD_VAR 0 4
8572: RET
// export function CreateFactoryWithExt ( x , y , d ) ; var i , list , fac ; begin
8573: LD_INT 0
8575: PPUSH
8576: PPUSH
8577: PPUSH
8578: PPUSH
// list := GetFacExtDir ( x , y , d ) ;
8579: LD_ADDR_VAR 0 6
8583: PUSH
8584: LD_VAR 0 1
8588: PPUSH
8589: LD_VAR 0 2
8593: PPUSH
8594: LD_VAR 0 3
8598: PPUSH
8599: CALL 7702 0 3
8603: ST_TO_ADDR
// uc_side := 1 ;
8604: LD_ADDR_OWVAR 20
8608: PUSH
8609: LD_INT 1
8611: ST_TO_ADDR
// uc_nation := 1 ;
8612: LD_ADDR_OWVAR 21
8616: PUSH
8617: LD_INT 1
8619: ST_TO_ADDR
// bc_type = b_factory ;
8620: LD_ADDR_OWVAR 42
8624: PUSH
8625: LD_INT 3
8627: ST_TO_ADDR
// fac = CreateAndPlaceBuildingXYD ( x , y , d ) ;
8628: LD_ADDR_VAR 0 7
8632: PUSH
8633: LD_VAR 0 1
8637: PPUSH
8638: LD_VAR 0 2
8642: PPUSH
8643: LD_VAR 0 3
8647: PPUSH
8648: CALL_OW 47
8652: ST_TO_ADDR
// for i = 1 to 5 do
8653: LD_ADDR_VAR 0 5
8657: PUSH
8658: DOUBLE
8659: LD_INT 1
8661: DEC
8662: ST_TO_ADDR
8663: LD_INT 5
8665: PUSH
8666: FOR_TO
8667: IFFALSE 8776
// begin bc_type = [ b_ext_laser , b_ext_gun , b_ext_radar , b_ext_noncombat , b_ext_rocket ] [ i ] ;
8669: LD_ADDR_OWVAR 42
8673: PUSH
8674: LD_INT 25
8676: PUSH
8677: LD_INT 17
8679: PUSH
8680: LD_INT 20
8682: PUSH
8683: LD_INT 19
8685: PUSH
8686: LD_INT 18
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: LIST
8693: LIST
8694: LIST
8695: PUSH
8696: LD_VAR 0 5
8700: ARRAY
8701: ST_TO_ADDR
// CreateAndPlaceBuildingXYD ( list [ i ] [ 1 ] , list [ i ] [ 2 ] , list [ i ] [ 3 ] ) ;
8702: LD_VAR 0 6
8706: PUSH
8707: LD_VAR 0 5
8711: ARRAY
8712: PUSH
8713: LD_INT 1
8715: ARRAY
8716: PPUSH
8717: LD_VAR 0 6
8721: PUSH
8722: LD_VAR 0 5
8726: ARRAY
8727: PUSH
8728: LD_INT 2
8730: ARRAY
8731: PPUSH
8732: LD_VAR 0 6
8736: PUSH
8737: LD_VAR 0 5
8741: ARRAY
8742: PUSH
8743: LD_INT 3
8745: ARRAY
8746: PPUSH
8747: CALL_OW 47
// display_strings := list [ i ] ;
8751: LD_ADDR_OWVAR 47
8755: PUSH
8756: LD_VAR 0 6
8760: PUSH
8761: LD_VAR 0 5
8765: ARRAY
8766: ST_TO_ADDR
// Wait ( 0 0$01 ) ;
8767: LD_INT 35
8769: PPUSH
8770: CALL_OW 67
// end ;
8774: GO 8666
8776: POP
8777: POP
// end ;
8778: LD_VAR 0 4
8782: RET
// export function ComBuildTurretFromList ( side , tlist ) ; var i , plist , c , j ; begin
8783: LD_INT 0
8785: PPUSH
8786: PPUSH
8787: PPUSH
8788: PPUSH
8789: PPUSH
// plist := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) ;
8790: LD_ADDR_VAR 0 5
8794: PUSH
8795: LD_INT 22
8797: PUSH
8798: LD_VAR 0 1
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 25
8809: PUSH
8810: LD_INT 2
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PPUSH
8821: CALL_OW 69
8825: ST_TO_ADDR
// c := 1 ;
8826: LD_ADDR_VAR 0 6
8830: PUSH
8831: LD_INT 1
8833: ST_TO_ADDR
// for i = 1 to tlist do
8834: LD_ADDR_VAR 0 4
8838: PUSH
8839: DOUBLE
8840: LD_INT 1
8842: DEC
8843: ST_TO_ADDR
8844: LD_VAR 0 2
8848: PUSH
8849: FOR_TO
8850: IFFALSE 9086
// begin if HexInfo ( tlist [ c + 1 ] , tlist [ c + 2 ] ) = 0 then
8852: LD_VAR 0 2
8856: PUSH
8857: LD_VAR 0 6
8861: PUSH
8862: LD_INT 1
8864: PLUS
8865: ARRAY
8866: PPUSH
8867: LD_VAR 0 2
8871: PUSH
8872: LD_VAR 0 6
8876: PUSH
8877: LD_INT 2
8879: PLUS
8880: ARRAY
8881: PPUSH
8882: CALL_OW 428
8886: PUSH
8887: LD_INT 0
8889: EQUAL
8890: IFFALSE 9070
// begin if GetBaseSource ( MyBase ( GetSide ( plist [ 1 ] ) ) ) >= 20 then
8892: LD_VAR 0 5
8896: PUSH
8897: LD_INT 1
8899: ARRAY
8900: PPUSH
8901: CALL_OW 255
8905: PPUSH
8906: CALL 1174 0 1
8910: PPUSH
8911: CALL 866 0 1
8915: PUSH
8916: LD_INT 20
8918: GREATEREQUAL
8919: IFFALSE 9066
// for j = 1 to plist do
8921: LD_ADDR_VAR 0 7
8925: PUSH
8926: DOUBLE
8927: LD_INT 1
8929: DEC
8930: ST_TO_ADDR
8931: LD_VAR 0 5
8935: PUSH
8936: FOR_TO
8937: IFFALSE 9064
// if IsInUnit ( plist [ i ] ) then
8939: LD_VAR 0 5
8943: PUSH
8944: LD_VAR 0 4
8948: ARRAY
8949: PPUSH
8950: CALL_OW 310
8954: IFFALSE 8973
// ComExitBuilding ( plist [ i ] ) else
8956: LD_VAR 0 5
8960: PUSH
8961: LD_VAR 0 4
8965: ARRAY
8966: PPUSH
8967: CALL_OW 122
8971: GO 9062
// if not HasTask ( plist [ i ] ) then
8973: LD_VAR 0 5
8977: PUSH
8978: LD_VAR 0 4
8982: ARRAY
8983: PPUSH
8984: CALL_OW 314
8988: NOT
8989: IFFALSE 9062
// ComBuild ( plist [ i ] , tlist [ c ] , tlist [ c + 1 ] , tlist [ c + 2 ] , tlist [ c + 3 ] ) ;
8991: LD_VAR 0 5
8995: PUSH
8996: LD_VAR 0 4
9000: ARRAY
9001: PPUSH
9002: LD_VAR 0 2
9006: PUSH
9007: LD_VAR 0 6
9011: ARRAY
9012: PPUSH
9013: LD_VAR 0 2
9017: PUSH
9018: LD_VAR 0 6
9022: PUSH
9023: LD_INT 1
9025: PLUS
9026: ARRAY
9027: PPUSH
9028: LD_VAR 0 2
9032: PUSH
9033: LD_VAR 0 6
9037: PUSH
9038: LD_INT 2
9040: PLUS
9041: ARRAY
9042: PPUSH
9043: LD_VAR 0 2
9047: PUSH
9048: LD_VAR 0 6
9052: PUSH
9053: LD_INT 3
9055: PLUS
9056: ARRAY
9057: PPUSH
9058: CALL_OW 145
9062: GO 8936
9064: POP
9065: POP
// break ;
9066: GO 9086
// end else
9068: GO 9084
// c := c + 4 ;
9070: LD_ADDR_VAR 0 6
9074: PUSH
9075: LD_VAR 0 6
9079: PUSH
9080: LD_INT 4
9082: PLUS
9083: ST_TO_ADDR
// end ;
9084: GO 8849
9086: POP
9087: POP
// end ;
9088: LD_VAR 0 3
9092: RET
// export function CollectCrates ( side , area ) ; var cargo , engs , skr ; begin
9093: LD_INT 0
9095: PPUSH
9096: PPUSH
9097: PPUSH
9098: PPUSH
// skr = GetListOfCratesInArea ( area ) ;
9099: LD_ADDR_VAR 0 6
9103: PUSH
9104: LD_VAR 0 2
9108: PPUSH
9109: CALL_OW 435
9113: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , side ] , [ f_lives , 450 ] , [ [ [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ] ] ) ;
9114: LD_ADDR_VAR 0 4
9118: PUSH
9119: LD_INT 22
9121: PUSH
9122: LD_VAR 0 1
9126: PUSH
9127: EMPTY
9128: LIST
9129: LIST
9130: PUSH
9131: LD_INT 24
9133: PUSH
9134: LD_INT 450
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: PUSH
9141: LD_INT 2
9143: PUSH
9144: LD_INT 34
9146: PUSH
9147: LD_INT 12
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: LD_INT 34
9156: PUSH
9157: LD_INT 51
9159: PUSH
9160: EMPTY
9161: LIST
9162: LIST
9163: PUSH
9164: LD_INT 34
9166: PUSH
9167: LD_INT 32
9169: PUSH
9170: EMPTY
9171: LIST
9172: LIST
9173: PUSH
9174: EMPTY
9175: LIST
9176: LIST
9177: LIST
9178: LIST
9179: PUSH
9180: EMPTY
9181: LIST
9182: PUSH
9183: EMPTY
9184: LIST
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: LIST
9190: PPUSH
9191: CALL_OW 69
9195: ST_TO_ADDR
// engs := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
9196: LD_ADDR_VAR 0 5
9200: PUSH
9201: LD_INT 22
9203: PUSH
9204: LD_VAR 0 1
9208: PUSH
9209: EMPTY
9210: LIST
9211: LIST
9212: PUSH
9213: LD_INT 2
9215: PUSH
9216: LD_INT 25
9218: PUSH
9219: LD_INT 2
9221: PUSH
9222: EMPTY
9223: LIST
9224: LIST
9225: PUSH
9226: LD_INT 25
9228: PUSH
9229: LD_INT 16
9231: PUSH
9232: EMPTY
9233: LIST
9234: LIST
9235: PUSH
9236: EMPTY
9237: LIST
9238: LIST
9239: LIST
9240: PUSH
9241: EMPTY
9242: LIST
9243: LIST
9244: PPUSH
9245: CALL_OW 69
9249: ST_TO_ADDR
// if skr then
9250: LD_VAR 0 6
9254: IFFALSE 9458
// begin if cargo then
9256: LD_VAR 0 4
9260: IFFALSE 9401
// begin if GetFuel ( cargo [ 1 ] ) < 30 and GetDistUnits ( cargo [ 1 ] , GetBuilding ( side , b_warehouse ) [ 1 ] ) < 4 then
9262: LD_VAR 0 4
9266: PUSH
9267: LD_INT 1
9269: ARRAY
9270: PPUSH
9271: CALL_OW 261
9275: PUSH
9276: LD_INT 30
9278: LESS
9279: PUSH
9280: LD_VAR 0 4
9284: PUSH
9285: LD_INT 1
9287: ARRAY
9288: PPUSH
9289: LD_VAR 0 1
9293: PPUSH
9294: LD_INT 1
9296: PPUSH
9297: CALL 1265 0 2
9301: PUSH
9302: LD_INT 1
9304: ARRAY
9305: PPUSH
9306: CALL_OW 296
9310: PUSH
9311: LD_INT 4
9313: LESS
9314: AND
9315: IFFALSE 9333
// SetFuel ( cargo [ 1 ] , 100 ) ;
9317: LD_VAR 0 4
9321: PUSH
9322: LD_INT 1
9324: ARRAY
9325: PPUSH
9326: LD_INT 100
9328: PPUSH
9329: CALL_OW 240
// if not HasTask ( cargo [ 1 ] ) and GetTag ( cargo [ 1 ] ) <> 51 then
9333: LD_VAR 0 4
9337: PUSH
9338: LD_INT 1
9340: ARRAY
9341: PPUSH
9342: CALL_OW 314
9346: NOT
9347: PUSH
9348: LD_VAR 0 4
9352: PUSH
9353: LD_INT 1
9355: ARRAY
9356: PPUSH
9357: CALL_OW 110
9361: PUSH
9362: LD_INT 51
9364: NONEQUAL
9365: AND
9366: IFFALSE 9399
// ComCollect ( cargo [ 1 ] , skr [ 1 ] , skr [ 2 ] ) ;
9368: LD_VAR 0 4
9372: PUSH
9373: LD_INT 1
9375: ARRAY
9376: PPUSH
9377: LD_VAR 0 6
9381: PUSH
9382: LD_INT 1
9384: ARRAY
9385: PPUSH
9386: LD_VAR 0 6
9390: PUSH
9391: LD_INT 2
9393: ARRAY
9394: PPUSH
9395: CALL_OW 117
// end else
9399: GO 9458
// if engs then
9401: LD_VAR 0 5
9405: IFFALSE 9458
// if not HasTask ( engs [ engs ] ) then
9407: LD_VAR 0 5
9411: PUSH
9412: LD_VAR 0 5
9416: ARRAY
9417: PPUSH
9418: CALL_OW 314
9422: NOT
9423: IFFALSE 9458
// ComCollect ( engs [ engs ] , skr [ 1 ] , skr [ 2 ] ) ;
9425: LD_VAR 0 5
9429: PUSH
9430: LD_VAR 0 5
9434: ARRAY
9435: PPUSH
9436: LD_VAR 0 6
9440: PUSH
9441: LD_INT 1
9443: ARRAY
9444: PPUSH
9445: LD_VAR 0 6
9449: PUSH
9450: LD_INT 2
9452: ARRAY
9453: PPUSH
9454: CALL_OW 117
// end ; end ;
9458: LD_VAR 0 3
9462: RET
// export function EnterToBuilding ( plist , building ) ; var i ; begin
9463: LD_INT 0
9465: PPUSH
9466: PPUSH
// for i = 1 to plist do
9467: LD_ADDR_VAR 0 4
9471: PUSH
9472: DOUBLE
9473: LD_INT 1
9475: DEC
9476: ST_TO_ADDR
9477: LD_VAR 0 1
9481: PUSH
9482: FOR_TO
9483: IFFALSE 9525
// if not HasTask ( plist [ i ] ) then
9485: LD_VAR 0 1
9489: PUSH
9490: LD_VAR 0 4
9494: ARRAY
9495: PPUSH
9496: CALL_OW 314
9500: NOT
9501: IFFALSE 9523
// ComEnterUnit ( plist [ i ] , building ) ;
9503: LD_VAR 0 1
9507: PUSH
9508: LD_VAR 0 4
9512: ARRAY
9513: PPUSH
9514: LD_VAR 0 2
9518: PPUSH
9519: CALL_OW 120
9523: GO 9482
9525: POP
9526: POP
// end ;
9527: LD_VAR 0 3
9531: RET
// export function Build ( plist , btype , x , y , d ) ; var i , costs , dep ; begin
9532: LD_INT 0
9534: PPUSH
9535: PPUSH
9536: PPUSH
9537: PPUSH
// dep := NearestUnitToXY ( FilterAllUnits ( [ [ [ f_side , GetSide ( plist [ 1 ] ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ] ) , x , y ) ;
9538: LD_ADDR_VAR 0 9
9542: PUSH
9543: LD_INT 22
9545: PUSH
9546: LD_VAR 0 1
9550: PUSH
9551: LD_INT 1
9553: ARRAY
9554: PPUSH
9555: CALL_OW 255
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: PUSH
9564: LD_INT 2
9566: PUSH
9567: LD_INT 30
9569: PUSH
9570: LD_INT 0
9572: PUSH
9573: EMPTY
9574: LIST
9575: LIST
9576: PUSH
9577: LD_INT 30
9579: PUSH
9580: LD_INT 1
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: LIST
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PUSH
9596: EMPTY
9597: LIST
9598: PPUSH
9599: CALL_OW 69
9603: PPUSH
9604: LD_VAR 0 3
9608: PPUSH
9609: LD_VAR 0 4
9613: PPUSH
9614: CALL_OW 73
9618: ST_TO_ADDR
// costs := Cost ( dep , btype ) ;
9619: LD_ADDR_VAR 0 8
9623: PUSH
9624: LD_VAR 0 9
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL 750 0 2
9638: ST_TO_ADDR
// if costs and GetDistUnitXY ( dep , x , y ) <= 30 then
9639: LD_VAR 0 8
9643: PUSH
9644: LD_VAR 0 9
9648: PPUSH
9649: LD_VAR 0 3
9653: PPUSH
9654: LD_VAR 0 4
9658: PPUSH
9659: CALL_OW 297
9663: PUSH
9664: LD_INT 30
9666: LESSEQUAL
9667: AND
9668: IFFALSE 9779
// for i = 1 to plist do
9670: LD_ADDR_VAR 0 7
9674: PUSH
9675: DOUBLE
9676: LD_INT 1
9678: DEC
9679: ST_TO_ADDR
9680: LD_VAR 0 1
9684: PUSH
9685: FOR_TO
9686: IFFALSE 9777
// if IsInUnit ( plist [ i ] ) then
9688: LD_VAR 0 1
9692: PUSH
9693: LD_VAR 0 7
9697: ARRAY
9698: PPUSH
9699: CALL_OW 310
9703: IFFALSE 9722
// ComExitBuilding ( plist [ i ] ) else
9705: LD_VAR 0 1
9709: PUSH
9710: LD_VAR 0 7
9714: ARRAY
9715: PPUSH
9716: CALL_OW 122
9720: GO 9775
// if not HasTask ( plist [ i ] ) then
9722: LD_VAR 0 1
9726: PUSH
9727: LD_VAR 0 7
9731: ARRAY
9732: PPUSH
9733: CALL_OW 314
9737: NOT
9738: IFFALSE 9775
// ComBuild ( plist [ i ] , btype , x , y , d ) ;
9740: LD_VAR 0 1
9744: PUSH
9745: LD_VAR 0 7
9749: ARRAY
9750: PPUSH
9751: LD_VAR 0 2
9755: PPUSH
9756: LD_VAR 0 3
9760: PPUSH
9761: LD_VAR 0 4
9765: PPUSH
9766: LD_VAR 0 5
9770: PPUSH
9771: CALL_OW 145
9775: GO 9685
9777: POP
9778: POP
// end ;
9779: LD_VAR 0 6
9783: RET
// export function BuildPowerFromList ( plist , slist , btype ) ; var p , j , side ; begin
9784: LD_INT 0
9786: PPUSH
9787: PPUSH
9788: PPUSH
9789: PPUSH
// side := GetSide ( plist [ 1 ] ) ;
9790: LD_ADDR_VAR 0 7
9794: PUSH
9795: LD_VAR 0 1
9799: PUSH
9800: LD_INT 1
9802: ARRAY
9803: PPUSH
9804: CALL_OW 255
9808: ST_TO_ADDR
// p := 1 ;
9809: LD_ADDR_VAR 0 5
9813: PUSH
9814: LD_INT 1
9816: ST_TO_ADDR
// if Cost ( MyBase ( side ) [ 1 ] , btype ) then
9817: LD_VAR 0 7
9821: PPUSH
9822: CALL 1174 0 1
9826: PUSH
9827: LD_INT 1
9829: ARRAY
9830: PPUSH
9831: LD_VAR 0 3
9835: PPUSH
9836: CALL 750 0 2
9840: IFFALSE 9965
// begin while ( p < slist ) do
9842: LD_VAR 0 5
9846: PUSH
9847: LD_VAR 0 2
9851: LESS
9852: IFFALSE 9965
// begin if HexInfo ( slist [ p ] , slist [ p + 1 ] ) = 0 then
9854: LD_VAR 0 2
9858: PUSH
9859: LD_VAR 0 5
9863: ARRAY
9864: PPUSH
9865: LD_VAR 0 2
9869: PUSH
9870: LD_VAR 0 5
9874: PUSH
9875: LD_INT 1
9877: PLUS
9878: ARRAY
9879: PPUSH
9880: CALL_OW 428
9884: PUSH
9885: LD_INT 0
9887: EQUAL
9888: IFFALSE 9949
// begin Build ( plist , btype , slist [ p ] , slist [ p + 1 ] , slist [ p + 2 ] ) ;
9890: LD_VAR 0 1
9894: PPUSH
9895: LD_VAR 0 3
9899: PPUSH
9900: LD_VAR 0 2
9904: PUSH
9905: LD_VAR 0 5
9909: ARRAY
9910: PPUSH
9911: LD_VAR 0 2
9915: PUSH
9916: LD_VAR 0 5
9920: PUSH
9921: LD_INT 1
9923: PLUS
9924: ARRAY
9925: PPUSH
9926: LD_VAR 0 2
9930: PUSH
9931: LD_VAR 0 5
9935: PUSH
9936: LD_INT 2
9938: PLUS
9939: ARRAY
9940: PPUSH
9941: CALL 9532 0 5
// break ;
9945: GO 9965
// end else
9947: GO 9963
// p := p + 3 ;
9949: LD_ADDR_VAR 0 5
9953: PUSH
9954: LD_VAR 0 5
9958: PUSH
9959: LD_INT 3
9961: PLUS
9962: ST_TO_ADDR
// end ;
9963: GO 9842
// end ; end ;
9965: LD_VAR 0 4
9969: RET
// export function Tag_List ( plist , tag ) ; var i , list ; begin
9970: LD_INT 0
9972: PPUSH
9973: PPUSH
9974: PPUSH
// list := [ ] ;
9975: LD_ADDR_VAR 0 5
9979: PUSH
9980: EMPTY
9981: ST_TO_ADDR
// for i = 1 to plist do
9982: LD_ADDR_VAR 0 4
9986: PUSH
9987: DOUBLE
9988: LD_INT 1
9990: DEC
9991: ST_TO_ADDR
9992: LD_VAR 0 1
9996: PUSH
9997: FOR_TO
9998: IFFALSE 10047
// if GetTag ( plist [ i ] ) = tag then
10000: LD_VAR 0 1
10004: PUSH
10005: LD_VAR 0 4
10009: ARRAY
10010: PPUSH
10011: CALL_OW 110
10015: PUSH
10016: LD_VAR 0 2
10020: EQUAL
10021: IFFALSE 10045
// list := list ^ plist [ i ] ;
10023: LD_ADDR_VAR 0 5
10027: PUSH
10028: LD_VAR 0 5
10032: PUSH
10033: LD_VAR 0 1
10037: PUSH
10038: LD_VAR 0 4
10042: ARRAY
10043: ADD
10044: ST_TO_ADDR
10045: GO 9997
10047: POP
10048: POP
// result := list ;
10049: LD_ADDR_VAR 0 3
10053: PUSH
10054: LD_VAR 0 5
10058: ST_TO_ADDR
// end ;
10059: LD_VAR 0 3
10063: RET
// export function GoToTower ( plist ) ; var i , filter , towers , barracks , outside , inside , side ; begin
10064: LD_INT 0
10066: PPUSH
10067: PPUSH
10068: PPUSH
10069: PPUSH
10070: PPUSH
10071: PPUSH
10072: PPUSH
10073: PPUSH
// side := GetSide ( plist [ 1 ] ) ;
10074: LD_ADDR_VAR 0 9
10078: PUSH
10079: LD_VAR 0 1
10083: PUSH
10084: LD_INT 1
10086: ARRAY
10087: PPUSH
10088: CALL_OW 255
10092: ST_TO_ADDR
// filter := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] ] ) ;
10093: LD_ADDR_VAR 0 4
10097: PUSH
10098: LD_INT 22
10100: PUSH
10101: LD_VAR 0 9
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: PUSH
10110: LD_INT 30
10112: PUSH
10113: LD_INT 32
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: PPUSH
10124: CALL_OW 69
10128: ST_TO_ADDR
// towers := FilterAllUnits ( [ [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) ;
10129: LD_ADDR_VAR 0 5
10133: PUSH
10134: LD_INT 22
10136: PUSH
10137: LD_VAR 0 9
10141: PUSH
10142: EMPTY
10143: LIST
10144: LIST
10145: PUSH
10146: LD_INT 30
10148: PUSH
10149: LD_INT 32
10151: PUSH
10152: EMPTY
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 58
10158: PUSH
10159: EMPTY
10160: LIST
10161: PUSH
10162: EMPTY
10163: LIST
10164: LIST
10165: LIST
10166: PUSH
10167: EMPTY
10168: LIST
10169: PPUSH
10170: CALL_OW 69
10174: ST_TO_ADDR
// barracks := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_barracks ] ] ) ;
10175: LD_ADDR_VAR 0 6
10179: PUSH
10180: LD_INT 22
10182: PUSH
10183: LD_VAR 0 9
10187: PUSH
10188: EMPTY
10189: LIST
10190: LIST
10191: PUSH
10192: LD_INT 30
10194: PUSH
10195: LD_INT 5
10197: PUSH
10198: EMPTY
10199: LIST
10200: LIST
10201: PUSH
10202: EMPTY
10203: LIST
10204: LIST
10205: PPUSH
10206: CALL_OW 69
10210: ST_TO_ADDR
// if towers then
10211: LD_VAR 0 5
10215: IFFALSE 10314
// begin outside := UnitFilter ( plist , [ f_not , [ f_inside ] ] ) ;
10217: LD_ADDR_VAR 0 7
10221: PUSH
10222: LD_VAR 0 1
10226: PPUSH
10227: LD_INT 3
10229: PUSH
10230: LD_INT 54
10232: PUSH
10233: EMPTY
10234: LIST
10235: PUSH
10236: EMPTY
10237: LIST
10238: LIST
10239: PPUSH
10240: CALL_OW 72
10244: ST_TO_ADDR
// if not outside then
10245: LD_VAR 0 7
10249: NOT
10250: IFFALSE 10292
// begin inside := UnitsInside ( barracks [ 1 ] ) ;
10252: LD_ADDR_VAR 0 8
10256: PUSH
10257: LD_VAR 0 6
10261: PUSH
10262: LD_INT 1
10264: ARRAY
10265: PPUSH
10266: CALL_OW 313
10270: ST_TO_ADDR
// if inside then
10271: LD_VAR 0 8
10275: IFFALSE 10290
// ComExitBuilding ( inside [ 1 ] ) ;
10277: LD_VAR 0 8
10281: PUSH
10282: LD_INT 1
10284: ARRAY
10285: PPUSH
10286: CALL_OW 122
// end else
10290: GO 10314
// ComEnterUnit ( outside [ 1 ] , towers [ 1 ] ) ;
10292: LD_VAR 0 7
10296: PUSH
10297: LD_INT 1
10299: ARRAY
10300: PPUSH
10301: LD_VAR 0 5
10305: PUSH
10306: LD_INT 1
10308: ARRAY
10309: PPUSH
10310: CALL_OW 120
// end ; end ;
10314: LD_VAR 0 2
10318: RET
// export function ControlTower ( side , nation , x , y , d , chassis ) ; var i , eng , mech , fac , ct , remveh ; begin
10319: LD_INT 0
10321: PPUSH
10322: PPUSH
10323: PPUSH
10324: PPUSH
10325: PPUSH
10326: PPUSH
10327: PPUSH
// eng := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) ;
10328: LD_ADDR_VAR 0 9
10332: PUSH
10333: LD_INT 22
10335: PUSH
10336: LD_VAR 0 1
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: PUSH
10345: LD_INT 25
10347: PUSH
10348: LD_INT 2
10350: PUSH
10351: EMPTY
10352: LIST
10353: LIST
10354: PUSH
10355: EMPTY
10356: LIST
10357: LIST
10358: PPUSH
10359: CALL_OW 69
10363: ST_TO_ADDR
// mech := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
10364: LD_ADDR_VAR 0 10
10368: PUSH
10369: LD_INT 22
10371: PUSH
10372: LD_VAR 0 1
10376: PUSH
10377: EMPTY
10378: LIST
10379: LIST
10380: PUSH
10381: LD_INT 25
10383: PUSH
10384: LD_INT 3
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PPUSH
10395: CALL_OW 69
10399: ST_TO_ADDR
// fac := GetBuilding ( side , b_factory ) [ 1 ] ;
10400: LD_ADDR_VAR 0 11
10404: PUSH
10405: LD_VAR 0 1
10409: PPUSH
10410: LD_INT 3
10412: PPUSH
10413: CALL 1265 0 2
10417: PUSH
10418: LD_INT 1
10420: ARRAY
10421: ST_TO_ADDR
// remveh := FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_control , control_remote ] ] ] ) ;
10422: LD_ADDR_VAR 0 13
10426: PUSH
10427: LD_INT 22
10429: PUSH
10430: LD_VAR 0 1
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 21
10441: PUSH
10442: LD_INT 2
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: LD_INT 33
10451: PUSH
10452: LD_INT 2
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: PUSH
10464: EMPTY
10465: LIST
10466: PPUSH
10467: CALL_OW 69
10471: ST_TO_ADDR
// if GetTech ( tech_remCont , side ) = state_researched then
10472: LD_INT 15
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 321
10484: PUSH
10485: LD_INT 2
10487: EQUAL
10488: IFFALSE 10806
// case nation of nation_american :
10490: LD_VAR 0 2
10494: PUSH
10495: LD_INT 1
10497: DOUBLE
10498: EQUAL
10499: IFTRUE 10503
10501: GO 10654
10503: POP
// begin if GetBuilding ( side , b_control_tower ) = 0 then
10504: LD_VAR 0 1
10508: PPUSH
10509: LD_INT 36
10511: PPUSH
10512: CALL 1265 0 2
10516: PUSH
10517: LD_INT 0
10519: EQUAL
10520: IFFALSE 10551
// Build ( eng , b_control_tower , x , y , d ) else
10522: LD_VAR 0 9
10526: PPUSH
10527: LD_INT 36
10529: PPUSH
10530: LD_VAR 0 3
10534: PPUSH
10535: LD_VAR 0 4
10539: PPUSH
10540: LD_VAR 0 5
10544: PPUSH
10545: CALL 9532 0 5
10549: GO 10652
// if UnitsInside ( GetBuilding ( side , b_control_tower ) [ 1 ] ) = 0 and Tag_List ( mech , 32 ) = 0 and BuildingStatus ( GetBuilding ( side , b_control_tower ) [ 1 ] ) <> bs_build then
10551: LD_VAR 0 1
10555: PPUSH
10556: LD_INT 36
10558: PPUSH
10559: CALL 1265 0 2
10563: PUSH
10564: LD_INT 1
10566: ARRAY
10567: PPUSH
10568: CALL_OW 313
10572: PUSH
10573: LD_INT 0
10575: EQUAL
10576: PUSH
10577: LD_VAR 0 10
10581: PPUSH
10582: LD_INT 32
10584: PPUSH
10585: CALL 9970 0 2
10589: PUSH
10590: LD_INT 0
10592: EQUAL
10593: AND
10594: PUSH
10595: LD_VAR 0 1
10599: PPUSH
10600: LD_INT 36
10602: PPUSH
10603: CALL 1265 0 2
10607: PUSH
10608: LD_INT 1
10610: ARRAY
10611: PPUSH
10612: CALL_OW 461
10616: PUSH
10617: LD_INT 1
10619: NONEQUAL
10620: AND
10621: IFFALSE 10634
// GoToControlTower ( side ) else
10623: LD_VAR 0 1
10627: PPUSH
10628: CALL 11062 0 1
10632: GO 10652
// ct := GetBuilding ( side , b_control_tower ) ;
10634: LD_ADDR_VAR 0 12
10638: PUSH
10639: LD_VAR 0 1
10643: PPUSH
10644: LD_INT 36
10646: PPUSH
10647: CALL 1265 0 2
10651: ST_TO_ADDR
// end ; nation_arabian :
10652: GO 10806
10654: LD_INT 2
10656: DOUBLE
10657: EQUAL
10658: IFTRUE 10662
10660: GO 10805
10662: POP
// begin if FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) < 3 then
10663: LD_INT 22
10665: PUSH
10666: LD_VAR 0 1
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: PUSH
10675: LD_INT 34
10677: PUSH
10678: LD_INT 31
10680: PUSH
10681: EMPTY
10682: LIST
10683: LIST
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: PPUSH
10689: CALL_OW 69
10693: PUSH
10694: LD_INT 3
10696: LESS
10697: IFFALSE 10724
// ComProduce ( fac , chassis , engine_combustion , control_manual , ar_control_tower ) else
10699: LD_VAR 0 11
10703: PPUSH
10704: LD_VAR 0 6
10708: PPUSH
10709: LD_INT 1
10711: PPUSH
10712: LD_INT 1
10714: PPUSH
10715: LD_INT 31
10717: PPUSH
10718: CALL 3234 0 5
10722: GO 10803
// begin if HexInfo ( x , y ) = 0 then
10724: LD_VAR 0 3
10728: PPUSH
10729: LD_VAR 0 4
10733: PPUSH
10734: CALL_OW 428
10738: PUSH
10739: LD_INT 0
10741: EQUAL
10742: IFFALSE 10780
// ComMoveXY ( GetVehicle ( side , chassis , ar_control_tower ) [ 1 ] , x , y ) ;
10744: LD_VAR 0 1
10748: PPUSH
10749: LD_VAR 0 6
10753: PPUSH
10754: LD_INT 31
10756: PPUSH
10757: CALL 3112 0 3
10761: PUSH
10762: LD_INT 1
10764: ARRAY
10765: PPUSH
10766: LD_VAR 0 3
10770: PPUSH
10771: LD_VAR 0 4
10775: PPUSH
10776: CALL_OW 111
// ct := GetVehicle ( side , chassis , ar_control_tower ) ;
10780: LD_ADDR_VAR 0 12
10784: PUSH
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_VAR 0 6
10794: PPUSH
10795: LD_INT 31
10797: PPUSH
10798: CALL 3112 0 3
10802: ST_TO_ADDR
// end ; end ; end ;
10803: GO 10806
10805: POP
// if ct and remveh and UnitsInside ( ct [ 1 ] ) then
10806: LD_VAR 0 12
10810: PUSH
10811: LD_VAR 0 13
10815: AND
10816: PUSH
10817: LD_VAR 0 12
10821: PUSH
10822: LD_INT 1
10824: ARRAY
10825: PPUSH
10826: CALL_OW 313
10830: AND
10831: IFFALSE 11057
// begin for i = 1 to remveh do
10833: LD_ADDR_VAR 0 8
10837: PUSH
10838: DOUBLE
10839: LD_INT 1
10841: DEC
10842: ST_TO_ADDR
10843: LD_VAR 0 13
10847: PUSH
10848: FOR_TO
10849: IFFALSE 11055
// begin if IsControledBy ( remveh [ i ] ) = 0 and GetLives ( remveh [ i ] ) >= 250 then
10851: LD_VAR 0 13
10855: PUSH
10856: LD_VAR 0 8
10860: ARRAY
10861: PPUSH
10862: CALL_OW 312
10866: PUSH
10867: LD_INT 0
10869: EQUAL
10870: PUSH
10871: LD_VAR 0 13
10875: PUSH
10876: LD_VAR 0 8
10880: ARRAY
10881: PPUSH
10882: CALL_OW 256
10886: PUSH
10887: LD_INT 250
10889: GREATEREQUAL
10890: AND
10891: IFFALSE 11000
// if GetNation ( ct [ 1 ] ) = 1 then
10893: LD_VAR 0 12
10897: PUSH
10898: LD_INT 1
10900: ARRAY
10901: PPUSH
10902: CALL_OW 248
10906: PUSH
10907: LD_INT 1
10909: EQUAL
10910: IFFALSE 10966
// ComLinkTo ( remveh [ i ] , UnitsInside ( ct [ 1 ] ) [ Rand ( 1 , UnitsInside ( ct [ 1 ] ) ) ] ) else
10912: LD_VAR 0 13
10916: PUSH
10917: LD_VAR 0 8
10921: ARRAY
10922: PPUSH
10923: LD_VAR 0 12
10927: PUSH
10928: LD_INT 1
10930: ARRAY
10931: PPUSH
10932: CALL_OW 313
10936: PUSH
10937: LD_INT 1
10939: PPUSH
10940: LD_VAR 0 12
10944: PUSH
10945: LD_INT 1
10947: ARRAY
10948: PPUSH
10949: CALL_OW 313
10953: PPUSH
10954: CALL_OW 12
10958: ARRAY
10959: PPUSH
10960: CALL_OW 135
10964: GO 11000
// ComLinkTo ( remveh [ i ] , ct [ Rand ( 1 , ct ) ] ) ;
10966: LD_VAR 0 13
10970: PUSH
10971: LD_VAR 0 8
10975: ARRAY
10976: PPUSH
10977: LD_VAR 0 12
10981: PUSH
10982: LD_INT 1
10984: PPUSH
10985: LD_VAR 0 12
10989: PPUSH
10990: CALL_OW 12
10994: ARRAY
10995: PPUSH
10996: CALL_OW 135
// if IsControledBy ( remveh [ i ] ) and GetLives ( remveh [ i ] ) < 250 then
11000: LD_VAR 0 13
11004: PUSH
11005: LD_VAR 0 8
11009: ARRAY
11010: PPUSH
11011: CALL_OW 312
11015: PUSH
11016: LD_VAR 0 13
11020: PUSH
11021: LD_VAR 0 8
11025: ARRAY
11026: PPUSH
11027: CALL_OW 256
11031: PUSH
11032: LD_INT 250
11034: LESS
11035: AND
11036: IFFALSE 11053
// ComUnlink ( remveh [ i ] ) ;
11038: LD_VAR 0 13
11042: PUSH
11043: LD_VAR 0 8
11047: ARRAY
11048: PPUSH
11049: CALL_OW 136
// end ;
11053: GO 10848
11055: POP
11056: POP
// end ; end ;
11057: LD_VAR 0 7
11061: RET
// export function GoToControlTower ( side ) ; var i , mech , n ; begin
11062: LD_INT 0
11064: PPUSH
11065: PPUSH
11066: PPUSH
11067: PPUSH
// mech := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
11068: LD_ADDR_VAR 0 4
11072: PUSH
11073: LD_INT 22
11075: PUSH
11076: LD_VAR 0 1
11080: PUSH
11081: EMPTY
11082: LIST
11083: LIST
11084: PUSH
11085: LD_INT 25
11087: PUSH
11088: LD_INT 3
11090: PUSH
11091: EMPTY
11092: LIST
11093: LIST
11094: PUSH
11095: EMPTY
11096: LIST
11097: LIST
11098: PPUSH
11099: CALL_OW 69
11103: ST_TO_ADDR
// n := 0 ;
11104: LD_ADDR_VAR 0 5
11108: PUSH
11109: LD_INT 0
11111: ST_TO_ADDR
// for i = 1 to mech do
11112: LD_ADDR_VAR 0 3
11116: PUSH
11117: DOUBLE
11118: LD_INT 1
11120: DEC
11121: ST_TO_ADDR
11122: LD_VAR 0 4
11126: PUSH
11127: FOR_TO
11128: IFFALSE 11263
// if GetTag ( mech [ i ] ) = 0 then
11130: LD_VAR 0 4
11134: PUSH
11135: LD_VAR 0 3
11139: ARRAY
11140: PPUSH
11141: CALL_OW 110
11145: PUSH
11146: LD_INT 0
11148: EQUAL
11149: IFFALSE 11261
// begin if IsInUnit ( mech [ i ] ) then
11151: LD_VAR 0 4
11155: PUSH
11156: LD_VAR 0 3
11160: ARRAY
11161: PPUSH
11162: CALL_OW 310
11166: IFFALSE 11185
// ComExitBuilding ( mech [ i ] ) else
11168: LD_VAR 0 4
11172: PUSH
11173: LD_VAR 0 3
11177: ARRAY
11178: PPUSH
11179: CALL_OW 122
11183: GO 11249
// begin SetTag ( mech [ i ] , 32 ) ;
11185: LD_VAR 0 4
11189: PUSH
11190: LD_VAR 0 3
11194: ARRAY
11195: PPUSH
11196: LD_INT 32
11198: PPUSH
11199: CALL_OW 109
// ComEnterUnit ( mech [ i ] , GetBuilding ( side , b_control_tower ) [ 1 ] ) ;
11203: LD_VAR 0 4
11207: PUSH
11208: LD_VAR 0 3
11212: ARRAY
11213: PPUSH
11214: LD_VAR 0 1
11218: PPUSH
11219: LD_INT 36
11221: PPUSH
11222: CALL 1265 0 2
11226: PUSH
11227: LD_INT 1
11229: ARRAY
11230: PPUSH
11231: CALL_OW 120
// n := n + 1 ;
11235: LD_ADDR_VAR 0 5
11239: PUSH
11240: LD_VAR 0 5
11244: PUSH
11245: LD_INT 1
11247: PLUS
11248: ST_TO_ADDR
// end ; if n = 2 then
11249: LD_VAR 0 5
11253: PUSH
11254: LD_INT 2
11256: EQUAL
11257: IFFALSE 11261
// break ;
11259: GO 11263
// end ;
11261: GO 11127
11263: POP
11264: POP
// end ;
11265: LD_VAR 0 2
11269: RET
// export function GetDistUnitToSide ( unit , side ) ; var tmp , dist ; begin
11270: LD_INT 0
11272: PPUSH
11273: PPUSH
11274: PPUSH
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , side ] ) , unit ) ;
11275: LD_ADDR_VAR 0 4
11279: PUSH
11280: LD_INT 22
11282: PUSH
11283: LD_VAR 0 2
11287: PUSH
11288: EMPTY
11289: LIST
11290: LIST
11291: PPUSH
11292: CALL_OW 69
11296: PPUSH
11297: LD_VAR 0 1
11301: PPUSH
11302: CALL_OW 74
11306: ST_TO_ADDR
// dist := GetDistUnits ( unit , tmp ) ;
11307: LD_ADDR_VAR 0 5
11311: PUSH
11312: LD_VAR 0 1
11316: PPUSH
11317: LD_VAR 0 4
11321: PPUSH
11322: CALL_OW 296
11326: ST_TO_ADDR
// if dist >= 9999 then
11327: LD_VAR 0 5
11331: PUSH
11332: LD_INT 9999
11334: GREATEREQUAL
11335: IFFALSE 11348
// result := - 1 else
11337: LD_ADDR_VAR 0 3
11341: PUSH
11342: LD_INT 1
11344: NEG
11345: ST_TO_ADDR
11346: GO 11358
// result := dist ;
11348: LD_ADDR_VAR 0 3
11352: PUSH
11353: LD_VAR 0 5
11357: ST_TO_ADDR
// end ;
11358: LD_VAR 0 3
11362: RET
// export function RepairBase ( side , enemy_list , x , y ) ; var i , j , eng , building , pr_build , crane ; begin
11363: LD_INT 0
11365: PPUSH
11366: PPUSH
11367: PPUSH
11368: PPUSH
11369: PPUSH
11370: PPUSH
11371: PPUSH
// eng := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) ;
11372: LD_ADDR_VAR 0 8
11376: PUSH
11377: LD_INT 22
11379: PUSH
11380: LD_VAR 0 1
11384: PUSH
11385: EMPTY
11386: LIST
11387: LIST
11388: PUSH
11389: LD_INT 25
11391: PUSH
11392: LD_INT 2
11394: PUSH
11395: EMPTY
11396: LIST
11397: LIST
11398: PUSH
11399: EMPTY
11400: LIST
11401: LIST
11402: PPUSH
11403: CALL_OW 69
11407: ST_TO_ADDR
// building := FilterAllUnits ( [ [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_or , [ f_not , [ f_btype , b_oil_mine ] ] , [ f_not , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ] ) ;
11408: LD_ADDR_VAR 0 9
11412: PUSH
11413: LD_INT 22
11415: PUSH
11416: LD_VAR 0 1
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: PUSH
11425: LD_INT 21
11427: PUSH
11428: LD_INT 3
11430: PUSH
11431: EMPTY
11432: LIST
11433: LIST
11434: PUSH
11435: LD_INT 2
11437: PUSH
11438: LD_INT 3
11440: PUSH
11441: LD_INT 30
11443: PUSH
11444: LD_INT 29
11446: PUSH
11447: EMPTY
11448: LIST
11449: LIST
11450: PUSH
11451: EMPTY
11452: LIST
11453: LIST
11454: PUSH
11455: LD_INT 3
11457: PUSH
11458: LD_INT 30
11460: PUSH
11461: LD_INT 30
11463: PUSH
11464: EMPTY
11465: LIST
11466: LIST
11467: PUSH
11468: EMPTY
11469: LIST
11470: LIST
11471: PUSH
11472: EMPTY
11473: LIST
11474: LIST
11475: LIST
11476: PUSH
11477: LD_INT 3
11479: PUSH
11480: LD_INT 24
11482: PUSH
11483: LD_INT 1000
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: PUSH
11500: EMPTY
11501: LIST
11502: PUSH
11503: EMPTY
11504: LIST
11505: PPUSH
11506: CALL_OW 69
11510: ST_TO_ADDR
// pr_build := FilterAllUnits ( [ [ [ [ f_side , side ] , [ f_type , unit_building ] , [ f_or , [ f_not , [ f_btype , b_oil_mine ] ] , [ f_not , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ] ) ;
11511: LD_ADDR_VAR 0 10
11515: PUSH
11516: LD_INT 22
11518: PUSH
11519: LD_VAR 0 1
11523: PUSH
11524: EMPTY
11525: LIST
11526: LIST
11527: PUSH
11528: LD_INT 21
11530: PUSH
11531: LD_INT 3
11533: PUSH
11534: EMPTY
11535: LIST
11536: LIST
11537: PUSH
11538: LD_INT 2
11540: PUSH
11541: LD_INT 3
11543: PUSH
11544: LD_INT 30
11546: PUSH
11547: LD_INT 29
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: PUSH
11554: EMPTY
11555: LIST
11556: LIST
11557: PUSH
11558: LD_INT 3
11560: PUSH
11561: LD_INT 30
11563: PUSH
11564: LD_INT 30
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PUSH
11571: EMPTY
11572: LIST
11573: LIST
11574: PUSH
11575: EMPTY
11576: LIST
11577: LIST
11578: LIST
11579: PUSH
11580: LD_INT 3
11582: PUSH
11583: LD_INT 24
11585: PUSH
11586: LD_INT 250
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PUSH
11597: EMPTY
11598: LIST
11599: LIST
11600: LIST
11601: LIST
11602: PUSH
11603: EMPTY
11604: LIST
11605: PUSH
11606: EMPTY
11607: LIST
11608: PPUSH
11609: CALL_OW 69
11613: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
11614: LD_ADDR_VAR 0 11
11618: PUSH
11619: LD_INT 22
11621: PUSH
11622: LD_VAR 0 1
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: PUSH
11631: LD_INT 2
11633: PUSH
11634: LD_INT 34
11636: PUSH
11637: LD_INT 13
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PUSH
11644: LD_INT 34
11646: PUSH
11647: LD_EXP 1
11651: PUSH
11652: EMPTY
11653: LIST
11654: LIST
11655: PUSH
11656: LD_INT 34
11658: PUSH
11659: LD_INT 52
11661: PUSH
11662: EMPTY
11663: LIST
11664: LIST
11665: PUSH
11666: EMPTY
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: PUSH
11672: EMPTY
11673: LIST
11674: LIST
11675: PPUSH
11676: CALL_OW 69
11680: ST_TO_ADDR
// for i = 1 to eng do
11681: LD_ADDR_VAR 0 6
11685: PUSH
11686: DOUBLE
11687: LD_INT 1
11689: DEC
11690: ST_TO_ADDR
11691: LD_VAR 0 8
11695: PUSH
11696: FOR_TO
11697: IFFALSE 12358
// begin if building = 0 and GetDistUnitXY ( eng [ i ] , x , y ) > 20 and not HasTask ( eng [ i ] ) then
11699: LD_VAR 0 9
11703: PUSH
11704: LD_INT 0
11706: EQUAL
11707: PUSH
11708: LD_VAR 0 8
11712: PUSH
11713: LD_VAR 0 6
11717: ARRAY
11718: PPUSH
11719: LD_VAR 0 3
11723: PPUSH
11724: LD_VAR 0 4
11728: PPUSH
11729: CALL_OW 297
11733: PUSH
11734: LD_INT 20
11736: GREATER
11737: AND
11738: PUSH
11739: LD_VAR 0 8
11743: PUSH
11744: LD_VAR 0 6
11748: ARRAY
11749: PPUSH
11750: CALL_OW 314
11754: NOT
11755: AND
11756: IFFALSE 11783
// ComMoveXY ( eng [ i ] , x , y ) ;
11758: LD_VAR 0 8
11762: PUSH
11763: LD_VAR 0 6
11767: ARRAY
11768: PPUSH
11769: LD_VAR 0 3
11773: PPUSH
11774: LD_VAR 0 4
11778: PPUSH
11779: CALL_OW 111
// if DistFromEnemy ( eng [ i ] , enemy_list ) < 11 then
11783: LD_VAR 0 8
11787: PUSH
11788: LD_VAR 0 6
11792: ARRAY
11793: PPUSH
11794: LD_VAR 0 2
11798: PPUSH
11799: CALL 303 0 2
11803: PUSH
11804: LD_INT 11
11806: LESS
11807: IFFALSE 11834
// ComMoveXY ( eng [ i ] , x , y ) ;
11809: LD_VAR 0 8
11813: PUSH
11814: LD_VAR 0 6
11818: ARRAY
11819: PPUSH
11820: LD_VAR 0 3
11824: PPUSH
11825: LD_VAR 0 4
11829: PPUSH
11830: CALL_OW 111
// if GetLives ( eng [ i ] ) < 750 and GetTag ( eng [ i ] ) = 0 then
11834: LD_VAR 0 8
11838: PUSH
11839: LD_VAR 0 6
11843: ARRAY
11844: PPUSH
11845: CALL_OW 256
11849: PUSH
11850: LD_INT 750
11852: LESS
11853: PUSH
11854: LD_VAR 0 8
11858: PUSH
11859: LD_VAR 0 6
11863: ARRAY
11864: PPUSH
11865: CALL_OW 110
11869: PUSH
11870: LD_INT 0
11872: EQUAL
11873: AND
11874: IFFALSE 11919
// begin SetTag ( eng [ i ] , 99 ) ;
11876: LD_VAR 0 8
11880: PUSH
11881: LD_VAR 0 6
11885: ARRAY
11886: PPUSH
11887: LD_INT 99
11889: PPUSH
11890: CALL_OW 109
// ComMoveXY ( eng [ i ] , x , y ) ;
11894: LD_VAR 0 8
11898: PUSH
11899: LD_VAR 0 6
11903: ARRAY
11904: PPUSH
11905: LD_VAR 0 3
11909: PPUSH
11910: LD_VAR 0 4
11914: PPUSH
11915: CALL_OW 111
// end ; if GetLives ( eng [ i ] ) = 1000 and GetTag ( eng [ i ] ) = 99 then
11919: LD_VAR 0 8
11923: PUSH
11924: LD_VAR 0 6
11928: ARRAY
11929: PPUSH
11930: CALL_OW 256
11934: PUSH
11935: LD_INT 1000
11937: EQUAL
11938: PUSH
11939: LD_VAR 0 8
11943: PUSH
11944: LD_VAR 0 6
11948: ARRAY
11949: PPUSH
11950: CALL_OW 110
11954: PUSH
11955: LD_INT 99
11957: EQUAL
11958: AND
11959: IFFALSE 11979
// SetTag ( eng [ i ] , 0 ) ;
11961: LD_VAR 0 8
11965: PUSH
11966: LD_VAR 0 6
11970: ARRAY
11971: PPUSH
11972: LD_INT 0
11974: PPUSH
11975: CALL_OW 109
// if building > 0 then
11979: LD_VAR 0 9
11983: PUSH
11984: LD_INT 0
11986: GREATER
11987: IFFALSE 12356
// begin if GetTag ( eng [ i ] ) = 0 and IsInUnit ( eng [ i ] ) then
11989: LD_VAR 0 8
11993: PUSH
11994: LD_VAR 0 6
11998: ARRAY
11999: PPUSH
12000: CALL_OW 110
12004: PUSH
12005: LD_INT 0
12007: EQUAL
12008: PUSH
12009: LD_VAR 0 8
12013: PUSH
12014: LD_VAR 0 6
12018: ARRAY
12019: PPUSH
12020: CALL_OW 310
12024: AND
12025: IFFALSE 12042
// ComExitBuilding ( eng [ i ] ) ;
12027: LD_VAR 0 8
12031: PUSH
12032: LD_VAR 0 6
12036: ARRAY
12037: PPUSH
12038: CALL_OW 122
// if GetTag ( eng [ i ] ) = 0 and not HasTask ( eng [ i ] ) and not IsInUnit ( eng [ i ] ) and pr_build = 0 then
12042: LD_VAR 0 8
12046: PUSH
12047: LD_VAR 0 6
12051: ARRAY
12052: PPUSH
12053: CALL_OW 110
12057: PUSH
12058: LD_INT 0
12060: EQUAL
12061: PUSH
12062: LD_VAR 0 8
12066: PUSH
12067: LD_VAR 0 6
12071: ARRAY
12072: PPUSH
12073: CALL_OW 314
12077: NOT
12078: AND
12079: PUSH
12080: LD_VAR 0 8
12084: PUSH
12085: LD_VAR 0 6
12089: ARRAY
12090: PPUSH
12091: CALL_OW 310
12095: NOT
12096: AND
12097: PUSH
12098: LD_VAR 0 10
12102: PUSH
12103: LD_INT 0
12105: EQUAL
12106: AND
12107: IFFALSE 12185
// for j = 1 to building do
12109: LD_ADDR_VAR 0 7
12113: PUSH
12114: DOUBLE
12115: LD_INT 1
12117: DEC
12118: ST_TO_ADDR
12119: LD_VAR 0 9
12123: PUSH
12124: FOR_TO
12125: IFFALSE 12183
// if DistFromEnemy ( building [ j ] , enemy_list ) > 11 then
12127: LD_VAR 0 9
12131: PUSH
12132: LD_VAR 0 7
12136: ARRAY
12137: PPUSH
12138: LD_VAR 0 2
12142: PPUSH
12143: CALL 303 0 2
12147: PUSH
12148: LD_INT 11
12150: GREATER
12151: IFFALSE 12181
// begin ComRepairBuilding ( eng [ i ] , building [ j ] ) ;
12153: LD_VAR 0 8
12157: PUSH
12158: LD_VAR 0 6
12162: ARRAY
12163: PPUSH
12164: LD_VAR 0 9
12168: PUSH
12169: LD_VAR 0 7
12173: ARRAY
12174: PPUSH
12175: CALL_OW 130
// break ;
12179: GO 12183
// end ;
12181: GO 12124
12183: POP
12184: POP
// if GetTag ( eng [ i ] ) = 0 and not IsInUnit ( eng [ i ] ) and pr_build then
12185: LD_VAR 0 8
12189: PUSH
12190: LD_VAR 0 6
12194: ARRAY
12195: PPUSH
12196: CALL_OW 110
12200: PUSH
12201: LD_INT 0
12203: EQUAL
12204: PUSH
12205: LD_VAR 0 8
12209: PUSH
12210: LD_VAR 0 6
12214: ARRAY
12215: PPUSH
12216: CALL_OW 310
12220: NOT
12221: AND
12222: PUSH
12223: LD_VAR 0 10
12227: AND
12228: IFFALSE 12356
// for j = 1 to pr_build do
12230: LD_ADDR_VAR 0 7
12234: PUSH
12235: DOUBLE
12236: LD_INT 1
12238: DEC
12239: ST_TO_ADDR
12240: LD_VAR 0 10
12244: PUSH
12245: FOR_TO
12246: IFFALSE 12354
// if not WantRepair ( eng [ i ] , GetX ( pr_build [ j ] ) , GetY ( pr_build [ j ] ) ) and DistFromEnemy ( pr_build [ j ] , enemy_list ) > 10 then
12248: LD_VAR 0 8
12252: PUSH
12253: LD_VAR 0 6
12257: ARRAY
12258: PPUSH
12259: LD_VAR 0 10
12263: PUSH
12264: LD_VAR 0 7
12268: ARRAY
12269: PPUSH
12270: CALL_OW 250
12274: PPUSH
12275: LD_VAR 0 10
12279: PUSH
12280: LD_VAR 0 7
12284: ARRAY
12285: PPUSH
12286: CALL_OW 251
12290: PPUSH
12291: CALL 5694 0 3
12295: NOT
12296: PUSH
12297: LD_VAR 0 10
12301: PUSH
12302: LD_VAR 0 7
12306: ARRAY
12307: PPUSH
12308: LD_VAR 0 2
12312: PPUSH
12313: CALL 303 0 2
12317: PUSH
12318: LD_INT 10
12320: GREATER
12321: AND
12322: IFFALSE 12352
// begin ComRepairBuilding ( eng [ i ] , pr_build [ j ] ) ;
12324: LD_VAR 0 8
12328: PUSH
12329: LD_VAR 0 6
12333: ARRAY
12334: PPUSH
12335: LD_VAR 0 10
12339: PUSH
12340: LD_VAR 0 7
12344: ARRAY
12345: PPUSH
12346: CALL_OW 130
// break ;
12350: GO 12354
// end ;
12352: GO 12245
12354: POP
12355: POP
// end ; end ;
12356: GO 11696
12358: POP
12359: POP
// if crane and building then
12360: LD_VAR 0 11
12364: PUSH
12365: LD_VAR 0 9
12369: AND
12370: IFFALSE 12650
// begin for i = 1 to crane do
12372: LD_ADDR_VAR 0 6
12376: PUSH
12377: DOUBLE
12378: LD_INT 1
12380: DEC
12381: ST_TO_ADDR
12382: LD_VAR 0 11
12386: PUSH
12387: FOR_TO
12388: IFFALSE 12648
// begin if not HasTask ( crane [ i ] ) and GetLives ( crane [ i ] ) > 450 and GetTag ( crane [ i ] ) = 0 then
12390: LD_VAR 0 11
12394: PUSH
12395: LD_VAR 0 6
12399: ARRAY
12400: PPUSH
12401: CALL_OW 314
12405: NOT
12406: PUSH
12407: LD_VAR 0 11
12411: PUSH
12412: LD_VAR 0 6
12416: ARRAY
12417: PPUSH
12418: CALL_OW 256
12422: PUSH
12423: LD_INT 450
12425: GREATER
12426: AND
12427: PUSH
12428: LD_VAR 0 11
12432: PUSH
12433: LD_VAR 0 6
12437: ARRAY
12438: PPUSH
12439: CALL_OW 110
12443: PUSH
12444: LD_INT 0
12446: EQUAL
12447: AND
12448: IFFALSE 12526
// for j = 1 to building do
12450: LD_ADDR_VAR 0 7
12454: PUSH
12455: DOUBLE
12456: LD_INT 1
12458: DEC
12459: ST_TO_ADDR
12460: LD_VAR 0 9
12464: PUSH
12465: FOR_TO
12466: IFFALSE 12524
// if DistFromEnemy ( building [ j ] , enemy_list ) > 9 then
12468: LD_VAR 0 9
12472: PUSH
12473: LD_VAR 0 7
12477: ARRAY
12478: PPUSH
12479: LD_VAR 0 2
12483: PPUSH
12484: CALL 303 0 2
12488: PUSH
12489: LD_INT 9
12491: GREATER
12492: IFFALSE 12522
// begin ComRepairBuilding ( crane [ i ] , building [ j ] ) ;
12494: LD_VAR 0 11
12498: PUSH
12499: LD_VAR 0 6
12503: ARRAY
12504: PPUSH
12505: LD_VAR 0 9
12509: PUSH
12510: LD_VAR 0 7
12514: ARRAY
12515: PPUSH
12516: CALL_OW 130
// break ;
12520: GO 12524
// end ;
12522: GO 12465
12524: POP
12525: POP
// if GetLives ( crane [ i ] ) < 450 and GetTag ( crane [ i ] ) = 0 then
12526: LD_VAR 0 11
12530: PUSH
12531: LD_VAR 0 6
12535: ARRAY
12536: PPUSH
12537: CALL_OW 256
12541: PUSH
12542: LD_INT 450
12544: LESS
12545: PUSH
12546: LD_VAR 0 11
12550: PUSH
12551: LD_VAR 0 6
12555: ARRAY
12556: PPUSH
12557: CALL_OW 110
12561: PUSH
12562: LD_INT 0
12564: EQUAL
12565: AND
12566: IFFALSE 12586
// SetTag ( crane [ i ] , 81 ) ;
12568: LD_VAR 0 11
12572: PUSH
12573: LD_VAR 0 6
12577: ARRAY
12578: PPUSH
12579: LD_INT 81
12581: PPUSH
12582: CALL_OW 109
// if GetLives ( crane [ i ] ) = 1000 and GetTag ( crane [ i ] ) = 81 then
12586: LD_VAR 0 11
12590: PUSH
12591: LD_VAR 0 6
12595: ARRAY
12596: PPUSH
12597: CALL_OW 256
12601: PUSH
12602: LD_INT 1000
12604: EQUAL
12605: PUSH
12606: LD_VAR 0 11
12610: PUSH
12611: LD_VAR 0 6
12615: ARRAY
12616: PPUSH
12617: CALL_OW 110
12621: PUSH
12622: LD_INT 81
12624: EQUAL
12625: AND
12626: IFFALSE 12646
// SetTag ( crane [ i ] , 0 ) ;
12628: LD_VAR 0 11
12632: PUSH
12633: LD_VAR 0 6
12637: ARRAY
12638: PPUSH
12639: LD_INT 0
12641: PPUSH
12642: CALL_OW 109
// end ;
12646: GO 12387
12648: POP
12649: POP
// end ; end ;
12650: LD_VAR 0 5
12654: RET
// export function HealPersonel ( side , tag ) ; var i , sci , damage , plist ; begin
12655: LD_INT 0
12657: PPUSH
12658: PPUSH
12659: PPUSH
12660: PPUSH
12661: PPUSH
// sci := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] ] ) ;
12662: LD_ADDR_VAR 0 5
12666: PUSH
12667: LD_INT 22
12669: PUSH
12670: LD_VAR 0 1
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: LD_INT 25
12681: PUSH
12682: LD_INT 4
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PUSH
12689: EMPTY
12690: LIST
12691: LIST
12692: PPUSH
12693: CALL_OW 69
12697: ST_TO_ADDR
// plist := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] ] ) ;
12698: LD_ADDR_VAR 0 7
12702: PUSH
12703: LD_INT 22
12705: PUSH
12706: LD_VAR 0 1
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PUSH
12715: LD_INT 21
12717: PUSH
12718: LD_INT 1
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: EMPTY
12726: LIST
12727: LIST
12728: PPUSH
12729: CALL_OW 69
12733: ST_TO_ADDR
// damage := Tag_List ( plist , 99 ) ;
12734: LD_ADDR_VAR 0 6
12738: PUSH
12739: LD_VAR 0 7
12743: PPUSH
12744: LD_INT 99
12746: PPUSH
12747: CALL 9970 0 2
12751: ST_TO_ADDR
// if damage then
12752: LD_VAR 0 6
12756: IFFALSE 12856
// for i = 1 to sci do
12758: LD_ADDR_VAR 0 4
12762: PUSH
12763: DOUBLE
12764: LD_INT 1
12766: DEC
12767: ST_TO_ADDR
12768: LD_VAR 0 5
12772: PUSH
12773: FOR_TO
12774: IFFALSE 12854
// if IsInUnit ( sci [ i ] ) then
12776: LD_VAR 0 5
12780: PUSH
12781: LD_VAR 0 4
12785: ARRAY
12786: PPUSH
12787: CALL_OW 310
12791: IFFALSE 12810
// ComExitBuilding ( sci [ i ] ) else
12793: LD_VAR 0 5
12797: PUSH
12798: LD_VAR 0 4
12802: ARRAY
12803: PPUSH
12804: CALL_OW 122
12808: GO 12852
// if not HasTask ( sci [ i ] ) then
12810: LD_VAR 0 5
12814: PUSH
12815: LD_VAR 0 4
12819: ARRAY
12820: PPUSH
12821: CALL_OW 314
12825: NOT
12826: IFFALSE 12852
// ComHeal ( sci [ i ] , damage [ 1 ] ) ;
12828: LD_VAR 0 5
12832: PUSH
12833: LD_VAR 0 4
12837: ARRAY
12838: PPUSH
12839: LD_VAR 0 6
12843: PUSH
12844: LD_INT 1
12846: ARRAY
12847: PPUSH
12848: CALL_OW 128
12852: GO 12773
12854: POP
12855: POP
// end ;
12856: LD_VAR 0 3
12860: RET
// export function FinishAllBuilds ( side ) ; var plist , builds , i , crane ; begin
12861: LD_INT 0
12863: PPUSH
12864: PPUSH
12865: PPUSH
12866: PPUSH
12867: PPUSH
// plist := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) ;
12868: LD_ADDR_VAR 0 3
12872: PUSH
12873: LD_INT 22
12875: PUSH
12876: LD_VAR 0 1
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 25
12887: PUSH
12888: LD_INT 2
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: PPUSH
12899: CALL_OW 69
12903: ST_TO_ADDR
// builds := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
12904: LD_ADDR_VAR 0 4
12908: PUSH
12909: LD_INT 22
12911: PUSH
12912: LD_VAR 0 1
12916: PUSH
12917: EMPTY
12918: LIST
12919: LIST
12920: PUSH
12921: LD_INT 21
12923: PUSH
12924: LD_INT 3
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: PUSH
12931: EMPTY
12932: LIST
12933: LIST
12934: PPUSH
12935: CALL_OW 69
12939: ST_TO_ADDR
// crane := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
12940: LD_ADDR_VAR 0 6
12944: PUSH
12945: LD_INT 22
12947: PUSH
12948: LD_VAR 0 1
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: PUSH
12957: LD_INT 2
12959: PUSH
12960: LD_INT 34
12962: PUSH
12963: LD_INT 13
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: PUSH
12970: LD_INT 34
12972: PUSH
12973: LD_EXP 1
12977: PUSH
12978: EMPTY
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 34
12984: PUSH
12985: LD_INT 52
12987: PUSH
12988: EMPTY
12989: LIST
12990: LIST
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: LIST
12996: LIST
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PPUSH
13002: CALL_OW 69
13006: ST_TO_ADDR
// if tick mod 175 = 0 and builds and plist then
13007: LD_OWVAR 1
13011: PUSH
13012: LD_INT 175
13014: MOD
13015: PUSH
13016: LD_INT 0
13018: EQUAL
13019: PUSH
13020: LD_VAR 0 4
13024: AND
13025: PUSH
13026: LD_VAR 0 3
13030: AND
13031: IFFALSE 13098
// for i = 1 to builds do
13033: LD_ADDR_VAR 0 5
13037: PUSH
13038: DOUBLE
13039: LD_INT 1
13041: DEC
13042: ST_TO_ADDR
13043: LD_VAR 0 4
13047: PUSH
13048: FOR_TO
13049: IFFALSE 13096
// if BuildingStatus ( builds [ i ] ) = bs_build then
13051: LD_VAR 0 4
13055: PUSH
13056: LD_VAR 0 5
13060: ARRAY
13061: PPUSH
13062: CALL_OW 461
13066: PUSH
13067: LD_INT 1
13069: EQUAL
13070: IFFALSE 13094
// begin ComCompleteUpgrade ( plist , builds [ i ] ) ;
13072: LD_VAR 0 3
13076: PPUSH
13077: LD_VAR 0 4
13081: PUSH
13082: LD_VAR 0 5
13086: ARRAY
13087: PPUSH
13088: CALL 5468 0 2
// break ;
13092: GO 13096
// end ;
13094: GO 13048
13096: POP
13097: POP
// if tick mod 175 = 0 and builds and crane then
13098: LD_OWVAR 1
13102: PUSH
13103: LD_INT 175
13105: MOD
13106: PUSH
13107: LD_INT 0
13109: EQUAL
13110: PUSH
13111: LD_VAR 0 4
13115: AND
13116: PUSH
13117: LD_VAR 0 6
13121: AND
13122: IFFALSE 13189
// for i = 1 to builds do
13124: LD_ADDR_VAR 0 5
13128: PUSH
13129: DOUBLE
13130: LD_INT 1
13132: DEC
13133: ST_TO_ADDR
13134: LD_VAR 0 4
13138: PUSH
13139: FOR_TO
13140: IFFALSE 13187
// if BuildingStatus ( builds [ i ] ) = bs_build then
13142: LD_VAR 0 4
13146: PUSH
13147: LD_VAR 0 5
13151: ARRAY
13152: PPUSH
13153: CALL_OW 461
13157: PUSH
13158: LD_INT 1
13160: EQUAL
13161: IFFALSE 13185
// begin ComCompleteUpgrade ( crane , builds [ i ] ) ;
13163: LD_VAR 0 6
13167: PPUSH
13168: LD_VAR 0 4
13172: PUSH
13173: LD_VAR 0 5
13177: ARRAY
13178: PPUSH
13179: CALL 5468 0 2
// break ;
13183: GO 13187
// end ;
13185: GO 13139
13187: POP
13188: POP
// end ;
13189: LD_VAR 0 2
13193: RET
// export function ElementOnList ( list1 , list2 ) ; var i , mode ; begin
13194: LD_INT 0
13196: PPUSH
13197: PPUSH
13198: PPUSH
// mode := false ;
13199: LD_ADDR_VAR 0 5
13203: PUSH
13204: LD_INT 0
13206: ST_TO_ADDR
// for i = 1 to list1 do
13207: LD_ADDR_VAR 0 4
13211: PUSH
13212: DOUBLE
13213: LD_INT 1
13215: DEC
13216: ST_TO_ADDR
13217: LD_VAR 0 1
13221: PUSH
13222: FOR_TO
13223: IFFALSE 13255
// if list1 [ i ] in list2 then
13225: LD_VAR 0 1
13229: PUSH
13230: LD_VAR 0 4
13234: ARRAY
13235: PUSH
13236: LD_VAR 0 2
13240: IN
13241: IFFALSE 13253
// begin mode := true ;
13243: LD_ADDR_VAR 0 5
13247: PUSH
13248: LD_INT 1
13250: ST_TO_ADDR
// break ;
13251: GO 13255
// end ;
13253: GO 13222
13255: POP
13256: POP
// result := mode ;
13257: LD_ADDR_VAR 0 3
13261: PUSH
13262: LD_VAR 0 5
13266: ST_TO_ADDR
// end ;
13267: LD_VAR 0 3
13271: RET
// export function IntConstruct ( side , chassis , engine , control , weapon_list ) ; var factory , apes , weapon ; begin
13272: LD_INT 0
13274: PPUSH
13275: PPUSH
13276: PPUSH
13277: PPUSH
// factory := GetBuilding ( side , b_factory ) [ 1 ] ;
13278: LD_ADDR_VAR 0 7
13282: PUSH
13283: LD_VAR 0 1
13287: PPUSH
13288: LD_INT 3
13290: PPUSH
13291: CALL 1265 0 2
13295: PUSH
13296: LD_INT 1
13298: ARRAY
13299: ST_TO_ADDR
// apes := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_apeman ] ] ) ;
13300: LD_ADDR_VAR 0 8
13304: PUSH
13305: LD_INT 22
13307: PUSH
13308: LD_VAR 0 1
13312: PUSH
13313: EMPTY
13314: LIST
13315: LIST
13316: PUSH
13317: LD_INT 25
13319: PUSH
13320: LD_INT 12
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: PPUSH
13331: CALL_OW 69
13335: ST_TO_ADDR
// if GetBuilding ( side , b_ext_computer ) then
13336: LD_VAR 0 1
13340: PPUSH
13341: LD_INT 24
13343: PPUSH
13344: CALL 1265 0 2
13348: IFFALSE 13360
// control = control_computer else
13350: LD_ADDR_VAR 0 4
13354: PUSH
13355: LD_INT 3
13357: ST_TO_ADDR
13358: GO 13429
// if GetBuilding ( side , b_ext_radar ) then
13360: LD_VAR 0 1
13364: PPUSH
13365: LD_INT 20
13367: PPUSH
13368: CALL 1265 0 2
13372: IFFALSE 13384
// control = control_remote else
13374: LD_ADDR_VAR 0 4
13378: PUSH
13379: LD_INT 2
13381: ST_TO_ADDR
13382: GO 13429
// if apes then
13384: LD_VAR 0 8
13388: IFFALSE 13429
// if ElementOnList ( UnitsInside ( factory ) , apes ) then
13390: LD_VAR 0 7
13394: PPUSH
13395: CALL_OW 313
13399: PPUSH
13400: LD_VAR 0 8
13404: PPUSH
13405: CALL 13194 0 2
13409: IFFALSE 13421
// control = control_apeman else
13411: LD_ADDR_VAR 0 4
13415: PUSH
13416: LD_INT 5
13418: ST_TO_ADDR
13419: GO 13429
// control = control_manual ;
13421: LD_ADDR_VAR 0 4
13425: PUSH
13426: LD_INT 1
13428: ST_TO_ADDR
// if GetBuilding ( side , b_ext_siberium ) then
13429: LD_VAR 0 1
13433: PPUSH
13434: LD_INT 21
13436: PPUSH
13437: CALL 1265 0 2
13441: IFFALSE 13451
// engine = engine_siberite ;
13443: LD_ADDR_VAR 0 3
13447: PUSH
13448: LD_INT 3
13450: ST_TO_ADDR
// if weapon_list > 1 then
13451: LD_VAR 0 5
13455: PUSH
13456: LD_INT 1
13458: GREATER
13459: IFFALSE 13487
// weapon := weapon_list [ Rand ( 1 , weapon_list ) ] else
13461: LD_ADDR_VAR 0 9
13465: PUSH
13466: LD_VAR 0 5
13470: PUSH
13471: LD_INT 1
13473: PPUSH
13474: LD_VAR 0 5
13478: PPUSH
13479: CALL_OW 12
13483: ARRAY
13484: ST_TO_ADDR
13485: GO 13501
// weapon := weapon_list [ 1 ] ;
13487: LD_ADDR_VAR 0 9
13491: PUSH
13492: LD_VAR 0 5
13496: PUSH
13497: LD_INT 1
13499: ARRAY
13500: ST_TO_ADDR
// ComProduce ( factory , chassis , engine , control , weapon ) ;
13501: LD_VAR 0 7
13505: PPUSH
13506: LD_VAR 0 2
13510: PPUSH
13511: LD_VAR 0 3
13515: PPUSH
13516: LD_VAR 0 4
13520: PPUSH
13521: LD_VAR 0 9
13525: PPUSH
13526: CALL 3234 0 5
// end ;
13530: LD_VAR 0 6
13534: RET
// export function ScoutArea ( unit , xy_list ) ; var i , p , tag ; begin
13535: LD_INT 0
13537: PPUSH
13538: PPUSH
13539: PPUSH
13540: PPUSH
// p := 1 ;
13541: LD_ADDR_VAR 0 5
13545: PUSH
13546: LD_INT 1
13548: ST_TO_ADDR
// case GetClass ( unit ) of class_soldier :
13549: LD_VAR 0 1
13553: PPUSH
13554: CALL_OW 257
13558: PUSH
13559: LD_INT 1
13561: DOUBLE
13562: EQUAL
13563: IFTRUE 13567
13565: GO 13578
13567: POP
// tag = 12 ; class_engineer :
13568: LD_ADDR_VAR 0 6
13572: PUSH
13573: LD_INT 12
13575: ST_TO_ADDR
13576: GO 13617
13578: LD_INT 2
13580: DOUBLE
13581: EQUAL
13582: IFTRUE 13586
13584: GO 13597
13586: POP
// tag = 22 ; class_scientistic :
13587: LD_ADDR_VAR 0 6
13591: PUSH
13592: LD_INT 22
13594: ST_TO_ADDR
13595: GO 13617
13597: LD_INT 4
13599: DOUBLE
13600: EQUAL
13601: IFTRUE 13605
13603: GO 13616
13605: POP
// tag = 42 ; end ;
13606: LD_ADDR_VAR 0 6
13610: PUSH
13611: LD_INT 42
13613: ST_TO_ADDR
13614: GO 13617
13616: POP
// SetTag ( unit , tag ) ;
13617: LD_VAR 0 1
13621: PPUSH
13622: LD_VAR 0 6
13626: PPUSH
13627: CALL_OW 109
// for i = 1 to ( xy_list / 2 ) do
13631: LD_ADDR_VAR 0 4
13635: PUSH
13636: DOUBLE
13637: LD_INT 1
13639: DEC
13640: ST_TO_ADDR
13641: LD_VAR 0 2
13645: PUSH
13646: LD_INT 2
13648: DIVREAL
13649: PUSH
13650: FOR_TO
13651: IFFALSE 13724
// begin AddComMoveXY ( unit , xy_list [ p ] , xy_list [ p + 1 ] ) ;
13653: LD_VAR 0 1
13657: PPUSH
13658: LD_VAR 0 2
13662: PUSH
13663: LD_VAR 0 5
13667: ARRAY
13668: PPUSH
13669: LD_VAR 0 2
13673: PUSH
13674: LD_VAR 0 5
13678: PUSH
13679: LD_INT 1
13681: PLUS
13682: ARRAY
13683: PPUSH
13684: CALL_OW 171
// AddComWait ( unit , Rand ( 0 0$01 , 0 0$03 ) ) ;
13688: LD_VAR 0 1
13692: PPUSH
13693: LD_INT 35
13695: PPUSH
13696: LD_INT 105
13698: PPUSH
13699: CALL_OW 12
13703: PPUSH
13704: CALL_OW 202
// p := p + 2 ;
13708: LD_ADDR_VAR 0 5
13712: PUSH
13713: LD_VAR 0 5
13717: PUSH
13718: LD_INT 2
13720: PLUS
13721: ST_TO_ADDR
// end ;
13722: GO 13650
13724: POP
13725: POP
// SetTag ( unit , 0 ) ;
13726: LD_VAR 0 1
13730: PPUSH
13731: LD_INT 0
13733: PPUSH
13734: CALL_OW 109
// end ;
13738: LD_VAR 0 3
13742: RET
// export function Transport ( eng , from_dep , to_dep , source ) ; var i ; begin
13743: LD_INT 0
13745: PPUSH
13746: PPUSH
// if IsInUnit ( eng ) then
13747: LD_VAR 0 1
13751: PPUSH
13752: CALL_OW 310
13756: IFFALSE 13769
// ComExitBuilding ( eng ) else
13758: LD_VAR 0 1
13762: PPUSH
13763: CALL_OW 122
13767: GO 13814
// if not HasTask ( eng ) then
13769: LD_VAR 0 1
13773: PPUSH
13774: CALL_OW 314
13778: NOT
13779: IFFALSE 13814
// begin ComTransport ( eng , from_dep , source ) ;
13781: LD_VAR 0 1
13785: PPUSH
13786: LD_VAR 0 2
13790: PPUSH
13791: LD_VAR 0 4
13795: PPUSH
13796: CALL_OW 151
// AddComGive ( eng , to_dep ) ;
13800: LD_VAR 0 1
13804: PPUSH
13805: LD_VAR 0 3
13809: PPUSH
13810: CALL_OW 221
// end ; end ;
13814: LD_VAR 0 5
13818: RET
// export function ScanVehicleStatus ( side , x , y ) ; var i , vehs , mech , filter , j , fac ; begin
13819: LD_INT 0
13821: PPUSH
13822: PPUSH
13823: PPUSH
13824: PPUSH
13825: PPUSH
13826: PPUSH
13827: PPUSH
// mech := FilterAllUnits ( [ [ f_side , side ] , [ f_class , class_mechanic ] , [ f_not , [ f_inside ] ] ] ) ;
13828: LD_ADDR_VAR 0 7
13832: PUSH
13833: LD_INT 22
13835: PUSH
13836: LD_VAR 0 1
13840: PUSH
13841: EMPTY
13842: LIST
13843: LIST
13844: PUSH
13845: LD_INT 25
13847: PUSH
13848: LD_INT 3
13850: PUSH
13851: EMPTY
13852: LIST
13853: LIST
13854: PUSH
13855: LD_INT 3
13857: PUSH
13858: LD_INT 54
13860: PUSH
13861: EMPTY
13862: LIST
13863: PUSH
13864: EMPTY
13865: LIST
13866: LIST
13867: PUSH
13868: EMPTY
13869: LIST
13870: LIST
13871: LIST
13872: PPUSH
13873: CALL_OW 69
13877: ST_TO_ADDR
// vehs := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ;
13878: LD_ADDR_VAR 0 6
13882: PUSH
13883: LD_INT 22
13885: PUSH
13886: LD_VAR 0 1
13890: PUSH
13891: EMPTY
13892: LIST
13893: LIST
13894: PUSH
13895: LD_INT 21
13897: PUSH
13898: LD_INT 2
13900: PUSH
13901: EMPTY
13902: LIST
13903: LIST
13904: PUSH
13905: EMPTY
13906: LIST
13907: LIST
13908: PPUSH
13909: CALL_OW 69
13913: ST_TO_ADDR
// filter := UnitFilter ( vehs , [ [ f_not , [ f_lives , 450 ] ] , [ f_distxy , x , y , 10 ] ] ) ;
13914: LD_ADDR_VAR 0 8
13918: PUSH
13919: LD_VAR 0 6
13923: PPUSH
13924: LD_INT 3
13926: PUSH
13927: LD_INT 24
13929: PUSH
13930: LD_INT 450
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PUSH
13941: LD_INT 92
13943: PUSH
13944: LD_VAR 0 2
13948: PUSH
13949: LD_VAR 0 3
13953: PUSH
13954: LD_INT 10
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: PUSH
13963: EMPTY
13964: LIST
13965: LIST
13966: PPUSH
13967: CALL_OW 72
13971: ST_TO_ADDR
// fac := UnitsInside ( GetBuilding ( side , b_factory ) [ 1 ] ) ;
13972: LD_ADDR_VAR 0 10
13976: PUSH
13977: LD_VAR 0 1
13981: PPUSH
13982: LD_INT 3
13984: PPUSH
13985: CALL 1265 0 2
13989: PUSH
13990: LD_INT 1
13992: ARRAY
13993: PPUSH
13994: CALL_OW 313
13998: ST_TO_ADDR
// j := mech ^ fac ;
13999: LD_ADDR_VAR 0 9
14003: PUSH
14004: LD_VAR 0 7
14008: PUSH
14009: LD_VAR 0 10
14013: ADD
14014: ST_TO_ADDR
// for i = 1 to vehs do
14015: LD_ADDR_VAR 0 5
14019: PUSH
14020: DOUBLE
14021: LD_INT 1
14023: DEC
14024: ST_TO_ADDR
14025: LD_VAR 0 6
14029: PUSH
14030: FOR_TO
14031: IFFALSE 14133
// if GetLives ( vehs [ i ] ) < 450 and GetTag ( vehs [ i ] ) = 0 and GetDistUnitXY ( vehs [ i ] , x , y ) > 10 then
14033: LD_VAR 0 6
14037: PUSH
14038: LD_VAR 0 5
14042: ARRAY
14043: PPUSH
14044: CALL_OW 256
14048: PUSH
14049: LD_INT 450
14051: LESS
14052: PUSH
14053: LD_VAR 0 6
14057: PUSH
14058: LD_VAR 0 5
14062: ARRAY
14063: PPUSH
14064: CALL_OW 110
14068: PUSH
14069: LD_INT 0
14071: EQUAL
14072: AND
14073: PUSH
14074: LD_VAR 0 6
14078: PUSH
14079: LD_VAR 0 5
14083: ARRAY
14084: PPUSH
14085: LD_VAR 0 2
14089: PPUSH
14090: LD_VAR 0 3
14094: PPUSH
14095: CALL_OW 297
14099: PUSH
14100: LD_INT 10
14102: GREATER
14103: AND
14104: IFFALSE 14131
// ComMoveXY ( vehs [ i ] , x , y ) ;
14106: LD_VAR 0 6
14110: PUSH
14111: LD_VAR 0 5
14115: ARRAY
14116: PPUSH
14117: LD_VAR 0 2
14121: PPUSH
14122: LD_VAR 0 3
14126: PPUSH
14127: CALL_OW 111
14131: GO 14030
14133: POP
14134: POP
// if filter then
14135: LD_VAR 0 8
14139: IFFALSE 14239
// for i = 1 to j do
14141: LD_ADDR_VAR 0 5
14145: PUSH
14146: DOUBLE
14147: LD_INT 1
14149: DEC
14150: ST_TO_ADDR
14151: LD_VAR 0 9
14155: PUSH
14156: FOR_TO
14157: IFFALSE 14237
// if IsInUnit ( j [ i ] ) then
14159: LD_VAR 0 9
14163: PUSH
14164: LD_VAR 0 5
14168: ARRAY
14169: PPUSH
14170: CALL_OW 310
14174: IFFALSE 14193
// ComExitBuilding ( j [ i ] ) else
14176: LD_VAR 0 9
14180: PUSH
14181: LD_VAR 0 5
14185: ARRAY
14186: PPUSH
14187: CALL_OW 122
14191: GO 14235
// if not HasTask ( j [ i ] ) then
14193: LD_VAR 0 9
14197: PUSH
14198: LD_VAR 0 5
14202: ARRAY
14203: PPUSH
14204: CALL_OW 314
14208: NOT
14209: IFFALSE 14235
// ComRepairVehicle ( j [ i ] , filter [ 1 ] ) ;
14211: LD_VAR 0 9
14215: PUSH
14216: LD_VAR 0 5
14220: ARRAY
14221: PPUSH
14222: LD_VAR 0 8
14226: PUSH
14227: LD_INT 1
14229: ARRAY
14230: PPUSH
14231: CALL_OW 129
14235: GO 14156
14237: POP
14238: POP
// end ;
14239: LD_VAR 0 4
14243: RET
// export function VehicleMove ( side , area , tag , task , info ) ; var i , filter , list , mech , parking , d , enemy ; begin
14244: LD_INT 0
14246: PPUSH
14247: PPUSH
14248: PPUSH
14249: PPUSH
14250: PPUSH
14251: PPUSH
14252: PPUSH
14253: PPUSH
// mech := UnitsInside ( GetBuilding ( side , b_factory ) [ 1 ] ) ^ FilterAllUnits ( [ [ [ f_side , side ] , [ f_class , 3 ] , [ f_not , [ f_inside ] ] ] ] ) ;
14254: LD_ADDR_VAR 0 10
14258: PUSH
14259: LD_VAR 0 1
14263: PPUSH
14264: LD_INT 3
14266: PPUSH
14267: CALL 1265 0 2
14271: PUSH
14272: LD_INT 1
14274: ARRAY
14275: PPUSH
14276: CALL_OW 313
14280: PUSH
14281: LD_INT 22
14283: PUSH
14284: LD_VAR 0 1
14288: PUSH
14289: EMPTY
14290: LIST
14291: LIST
14292: PUSH
14293: LD_INT 25
14295: PUSH
14296: LD_INT 3
14298: PUSH
14299: EMPTY
14300: LIST
14301: LIST
14302: PUSH
14303: LD_INT 3
14305: PUSH
14306: LD_INT 54
14308: PUSH
14309: EMPTY
14310: LIST
14311: PUSH
14312: EMPTY
14313: LIST
14314: LIST
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: LIST
14320: PUSH
14321: EMPTY
14322: LIST
14323: PPUSH
14324: CALL_OW 69
14328: ADD
14329: ST_TO_ADDR
// parking := FilterUnitsInArea ( area , [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ;
14330: LD_ADDR_VAR 0 11
14334: PUSH
14335: LD_VAR 0 2
14339: PPUSH
14340: LD_INT 22
14342: PUSH
14343: LD_VAR 0 1
14347: PUSH
14348: EMPTY
14349: LIST
14350: LIST
14351: PUSH
14352: LD_INT 21
14354: PUSH
14355: LD_INT 2
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: PUSH
14362: EMPTY
14363: LIST
14364: LIST
14365: PPUSH
14366: CALL_OW 70
14370: ST_TO_ADDR
// list := Tag_List ( FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) , tag ) ;
14371: LD_ADDR_VAR 0 9
14375: PUSH
14376: LD_INT 22
14378: PUSH
14379: LD_VAR 0 1
14383: PUSH
14384: EMPTY
14385: LIST
14386: LIST
14387: PUSH
14388: LD_INT 21
14390: PUSH
14391: LD_INT 2
14393: PUSH
14394: EMPTY
14395: LIST
14396: LIST
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: PPUSH
14402: CALL_OW 69
14406: PPUSH
14407: LD_VAR 0 3
14411: PPUSH
14412: CALL 9970 0 2
14416: ST_TO_ADDR
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
14417: LD_ADDR_VAR 0 13
14421: PUSH
14422: LD_INT 81
14424: PUSH
14425: LD_VAR 0 1
14429: PUSH
14430: EMPTY
14431: LIST
14432: LIST
14433: PPUSH
14434: CALL_OW 69
14438: ST_TO_ADDR
// if list then
14439: LD_VAR 0 9
14443: IFFALSE 14953
// for i = 1 to list do
14445: LD_ADDR_VAR 0 7
14449: PUSH
14450: DOUBLE
14451: LD_INT 1
14453: DEC
14454: ST_TO_ADDR
14455: LD_VAR 0 9
14459: PUSH
14460: FOR_TO
14461: IFFALSE 14951
// case task of back :
14463: LD_VAR 0 4
14467: PUSH
14468: LD_STRING back
14470: DOUBLE
14471: EQUAL
14472: IFTRUE 14476
14474: GO 14645
14476: POP
// begin if not GetDistUnitArea ( list [ i ] , area ) > 6 then
14477: LD_VAR 0 9
14481: PUSH
14482: LD_VAR 0 7
14486: ARRAY
14487: PPUSH
14488: LD_VAR 0 2
14492: PPUSH
14493: CALL_OW 299
14497: PUSH
14498: LD_INT 6
14500: GREATER
14501: NOT
14502: IFFALSE 14526
// ComMoveToArea ( list [ i ] , area ) else
14504: LD_VAR 0 9
14508: PUSH
14509: LD_VAR 0 7
14513: ARRAY
14514: PPUSH
14515: LD_VAR 0 2
14519: PPUSH
14520: CALL_OW 113
14524: GO 14643
// begin if GetControl ( list [ i ] ) = control_manual then
14526: LD_VAR 0 9
14530: PUSH
14531: LD_VAR 0 7
14535: ARRAY
14536: PPUSH
14537: CALL_OW 263
14541: PUSH
14542: LD_INT 1
14544: EQUAL
14545: IFFALSE 14604
// begin d := IsDrivenBy ( list [ i ] ) ;
14547: LD_ADDR_VAR 0 12
14551: PUSH
14552: LD_VAR 0 9
14556: PUSH
14557: LD_VAR 0 7
14561: ARRAY
14562: PPUSH
14563: CALL_OW 311
14567: ST_TO_ADDR
// if GetTag ( d ) = 41 then
14568: LD_VAR 0 12
14572: PPUSH
14573: CALL_OW 110
14577: PUSH
14578: LD_INT 41
14580: EQUAL
14581: IFFALSE 14595
// SetTag ( d , 0 ) ;
14583: LD_VAR 0 12
14587: PPUSH
14588: LD_INT 0
14590: PPUSH
14591: CALL_OW 109
// ComExitVehicle ( d ) ;
14595: LD_VAR 0 12
14599: PPUSH
14600: CALL_OW 121
// end ; if GetLives ( list [ i ] ) < 90 then
14604: LD_VAR 0 9
14608: PUSH
14609: LD_VAR 0 7
14613: ARRAY
14614: PPUSH
14615: CALL_OW 256
14619: PUSH
14620: LD_INT 90
14622: LESS
14623: IFFALSE 14643
// SetFuel ( list [ i ] , 100 ) ;
14625: LD_VAR 0 9
14629: PUSH
14630: LD_VAR 0 7
14634: ARRAY
14635: PPUSH
14636: LD_INT 100
14638: PPUSH
14639: CALL_OW 240
// end ; end ; defend :
14643: GO 14949
14645: LD_STRING defend
14647: DOUBLE
14648: EQUAL
14649: IFTRUE 14653
14651: GO 14833
14653: POP
// begin if not IsDrivenBy ( list [ i ] ) then
14654: LD_VAR 0 9
14658: PUSH
14659: LD_VAR 0 7
14663: ARRAY
14664: PPUSH
14665: CALL_OW 311
14669: NOT
14670: IFFALSE 14696
// ComEnterUnit ( mech [ 1 ] , list [ i ] ) ;
14672: LD_VAR 0 10
14676: PUSH
14677: LD_INT 1
14679: ARRAY
14680: PPUSH
14681: LD_VAR 0 9
14685: PUSH
14686: LD_VAR 0 7
14690: ARRAY
14691: PPUSH
14692: CALL_OW 120
// if IsDrivenBy ( list [ i ] ) or not GetControl ( list [ i ] ) = control_manual then
14696: LD_VAR 0 9
14700: PUSH
14701: LD_VAR 0 7
14705: ARRAY
14706: PPUSH
14707: CALL_OW 311
14711: PUSH
14712: LD_VAR 0 9
14716: PUSH
14717: LD_VAR 0 7
14721: ARRAY
14722: PPUSH
14723: CALL_OW 263
14727: PUSH
14728: LD_INT 1
14730: EQUAL
14731: NOT
14732: OR
14733: IFFALSE 14792
// if GetLives ( list [ i ] ) > 450 then
14735: LD_VAR 0 9
14739: PUSH
14740: LD_VAR 0 7
14744: ARRAY
14745: PPUSH
14746: CALL_OW 256
14750: PUSH
14751: LD_INT 450
14753: GREATER
14754: IFFALSE 14792
// ComAttackUnit ( list [ i ] , NearestUnitToUnit ( enemy , list [ i ] ) ) ;
14756: LD_VAR 0 9
14760: PUSH
14761: LD_VAR 0 7
14765: ARRAY
14766: PPUSH
14767: LD_VAR 0 13
14771: PPUSH
14772: LD_VAR 0 9
14776: PUSH
14777: LD_VAR 0 7
14781: ARRAY
14782: PPUSH
14783: CALL_OW 74
14787: PPUSH
14788: CALL_OW 115
// if GetLives ( list [ i ] ) <= 450 then
14792: LD_VAR 0 9
14796: PUSH
14797: LD_VAR 0 7
14801: ARRAY
14802: PPUSH
14803: CALL_OW 256
14807: PUSH
14808: LD_INT 450
14810: LESSEQUAL
14811: IFFALSE 14831
// SetTag ( list [ i ] , 84 ) ;
14813: LD_VAR 0 9
14817: PUSH
14818: LD_VAR 0 7
14822: ARRAY
14823: PPUSH
14824: LD_INT 84
14826: PPUSH
14827: CALL_OW 109
// end ; attack :
14831: GO 14949
14833: LD_STRING attack
14835: DOUBLE
14836: EQUAL
14837: IFTRUE 14841
14839: GO 14948
14841: POP
// begin if GetLives ( list [ i ] ) > 450 and GetFuel ( list [ i ] ) > 20 then
14842: LD_VAR 0 9
14846: PUSH
14847: LD_VAR 0 7
14851: ARRAY
14852: PPUSH
14853: CALL_OW 256
14857: PUSH
14858: LD_INT 450
14860: GREATER
14861: PUSH
14862: LD_VAR 0 9
14866: PUSH
14867: LD_VAR 0 7
14871: ARRAY
14872: PPUSH
14873: CALL_OW 261
14877: PUSH
14878: LD_INT 20
14880: GREATER
14881: AND
14882: IFFALSE 14928
// Attack ( list [ i ] , info [ 1 ] , info [ 2 ] , info [ 3 ] ) else
14884: LD_VAR 0 9
14888: PUSH
14889: LD_VAR 0 7
14893: ARRAY
14894: PPUSH
14895: LD_VAR 0 5
14899: PUSH
14900: LD_INT 1
14902: ARRAY
14903: PPUSH
14904: LD_VAR 0 5
14908: PUSH
14909: LD_INT 2
14911: ARRAY
14912: PPUSH
14913: LD_VAR 0 5
14917: PUSH
14918: LD_INT 3
14920: ARRAY
14921: PPUSH
14922: CALL 14958 0 4
14926: GO 14946
// SetTag ( list [ i ] , 84 ) ;
14928: LD_VAR 0 9
14932: PUSH
14933: LD_VAR 0 7
14937: ARRAY
14938: PPUSH
14939: LD_INT 84
14941: PPUSH
14942: CALL_OW 109
// end ; end ;
14946: GO 14949
14948: POP
14949: GO 14460
14951: POP
14952: POP
// end ;
14953: LD_VAR 0 6
14957: RET
// export function Attack ( unit , enemy_side , path , target ) ; var i , filter , all_vehs , capture_mode ; begin
14958: LD_INT 0
14960: PPUSH
14961: PPUSH
14962: PPUSH
14963: PPUSH
14964: PPUSH
// filter := FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_dist , unit , 20 ] ] ) ;
14965: LD_ADDR_VAR 0 7
14969: PUSH
14970: LD_INT 22
14972: PUSH
14973: LD_VAR 0 2
14977: PUSH
14978: EMPTY
14979: LIST
14980: LIST
14981: PUSH
14982: LD_INT 91
14984: PUSH
14985: LD_VAR 0 1
14989: PUSH
14990: LD_INT 20
14992: PUSH
14993: EMPTY
14994: LIST
14995: LIST
14996: LIST
14997: PUSH
14998: EMPTY
14999: LIST
15000: LIST
15001: PPUSH
15002: CALL_OW 69
15006: ST_TO_ADDR
// all_vehs := FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_type , unit_vehicle ] ] ) ;
15007: LD_ADDR_VAR 0 8
15011: PUSH
15012: LD_INT 22
15014: PUSH
15015: LD_VAR 0 2
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: PUSH
15024: LD_INT 21
15026: PUSH
15027: LD_INT 2
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: EMPTY
15035: LIST
15036: LIST
15037: PPUSH
15038: CALL_OW 69
15042: ST_TO_ADDR
// capture_mode := false ;
15043: LD_ADDR_VAR 0 9
15047: PUSH
15048: LD_INT 0
15050: ST_TO_ADDR
// for i = 1 to target do
15051: LD_ADDR_VAR 0 6
15055: PUSH
15056: DOUBLE
15057: LD_INT 1
15059: DEC
15060: ST_TO_ADDR
15061: LD_VAR 0 4
15065: PUSH
15066: FOR_TO
15067: IFFALSE 15627
// begin case target [ i ] of towers :
15069: LD_VAR 0 4
15073: PUSH
15074: LD_VAR 0 6
15078: ARRAY
15079: PUSH
15080: LD_STRING towers
15082: DOUBLE
15083: EQUAL
15084: IFTRUE 15088
15086: GO 15162
15088: POP
// filter := filter diff FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_or , [ f_btype , b_breastwork ] , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ] ) ; tanks :
15089: LD_ADDR_VAR 0 7
15093: PUSH
15094: LD_VAR 0 7
15098: PUSH
15099: LD_INT 22
15101: PUSH
15102: LD_VAR 0 2
15106: PUSH
15107: EMPTY
15108: LIST
15109: LIST
15110: PUSH
15111: LD_INT 2
15113: PUSH
15114: LD_INT 30
15116: PUSH
15117: LD_INT 31
15119: PUSH
15120: EMPTY
15121: LIST
15122: LIST
15123: PUSH
15124: LD_INT 30
15126: PUSH
15127: LD_INT 32
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: PUSH
15134: LD_INT 30
15136: PUSH
15137: LD_INT 33
15139: PUSH
15140: EMPTY
15141: LIST
15142: LIST
15143: PUSH
15144: EMPTY
15145: LIST
15146: LIST
15147: LIST
15148: LIST
15149: PUSH
15150: EMPTY
15151: LIST
15152: LIST
15153: PPUSH
15154: CALL_OW 69
15158: DIFF
15159: ST_TO_ADDR
15160: GO 15625
15162: LD_STRING tanks
15164: DOUBLE
15165: EQUAL
15166: IFTRUE 15170
15168: GO 15215
15170: POP
// filter := filter diff FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_type , unit_vehicle ] ] ) ; soldiers :
15171: LD_ADDR_VAR 0 7
15175: PUSH
15176: LD_VAR 0 7
15180: PUSH
15181: LD_INT 22
15183: PUSH
15184: LD_VAR 0 2
15188: PUSH
15189: EMPTY
15190: LIST
15191: LIST
15192: PUSH
15193: LD_INT 21
15195: PUSH
15196: LD_INT 2
15198: PUSH
15199: EMPTY
15200: LIST
15201: LIST
15202: PUSH
15203: EMPTY
15204: LIST
15205: LIST
15206: PPUSH
15207: CALL_OW 69
15211: DIFF
15212: ST_TO_ADDR
15213: GO 15625
15215: LD_STRING soldiers
15217: DOUBLE
15218: EQUAL
15219: IFTRUE 15223
15221: GO 15268
15223: POP
// filter := filter diff FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_class , 1 ] ] ) ; civils :
15224: LD_ADDR_VAR 0 7
15228: PUSH
15229: LD_VAR 0 7
15233: PUSH
15234: LD_INT 22
15236: PUSH
15237: LD_VAR 0 2
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: PUSH
15246: LD_INT 25
15248: PUSH
15249: LD_INT 1
15251: PUSH
15252: EMPTY
15253: LIST
15254: LIST
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: PPUSH
15260: CALL_OW 69
15264: DIFF
15265: ST_TO_ADDR
15266: GO 15625
15268: LD_STRING civils
15270: DOUBLE
15271: EQUAL
15272: IFTRUE 15276
15274: GO 15350
15276: POP
// filter := filter diff FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) ; buildings :
15277: LD_ADDR_VAR 0 7
15281: PUSH
15282: LD_VAR 0 7
15286: PUSH
15287: LD_INT 22
15289: PUSH
15290: LD_VAR 0 2
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: PUSH
15299: LD_INT 2
15301: PUSH
15302: LD_INT 25
15304: PUSH
15305: LD_INT 2
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: PUSH
15312: LD_INT 25
15314: PUSH
15315: LD_INT 3
15317: PUSH
15318: EMPTY
15319: LIST
15320: LIST
15321: PUSH
15322: LD_INT 25
15324: PUSH
15325: LD_INT 4
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: PUSH
15332: EMPTY
15333: LIST
15334: LIST
15335: LIST
15336: LIST
15337: PUSH
15338: EMPTY
15339: LIST
15340: LIST
15341: PPUSH
15342: CALL_OW 69
15346: DIFF
15347: ST_TO_ADDR
15348: GO 15625
15350: LD_STRING buildings
15352: DOUBLE
15353: EQUAL
15354: IFTRUE 15358
15356: GO 15403
15358: POP
// filter := filter diff FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_type , unit_building ] ] ) ; empty_buildings :
15359: LD_ADDR_VAR 0 7
15363: PUSH
15364: LD_VAR 0 7
15368: PUSH
15369: LD_INT 22
15371: PUSH
15372: LD_VAR 0 2
15376: PUSH
15377: EMPTY
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 21
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: EMPTY
15388: LIST
15389: LIST
15390: PUSH
15391: EMPTY
15392: LIST
15393: LIST
15394: PPUSH
15395: CALL_OW 69
15399: DIFF
15400: ST_TO_ADDR
15401: GO 15625
15403: LD_STRING empty_buildings
15405: DOUBLE
15406: EQUAL
15407: IFTRUE 15411
15409: GO 15463
15411: POP
// filter := filter diff FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_type , unit_building ] , [ f_empty ] ] ) ; empty_vehicles :
15412: LD_ADDR_VAR 0 7
15416: PUSH
15417: LD_VAR 0 7
15421: PUSH
15422: LD_INT 22
15424: PUSH
15425: LD_VAR 0 2
15429: PUSH
15430: EMPTY
15431: LIST
15432: LIST
15433: PUSH
15434: LD_INT 21
15436: PUSH
15437: LD_INT 3
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PUSH
15444: LD_INT 58
15446: PUSH
15447: EMPTY
15448: LIST
15449: PUSH
15450: EMPTY
15451: LIST
15452: LIST
15453: LIST
15454: PPUSH
15455: CALL_OW 69
15459: DIFF
15460: ST_TO_ADDR
15461: GO 15625
15463: LD_STRING empty_vehicles
15465: DOUBLE
15466: EQUAL
15467: IFTRUE 15471
15469: GO 15523
15471: POP
// filter := filter diff FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ; electro :
15472: LD_ADDR_VAR 0 7
15476: PUSH
15477: LD_VAR 0 7
15481: PUSH
15482: LD_INT 22
15484: PUSH
15485: LD_VAR 0 2
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: PUSH
15494: LD_INT 21
15496: PUSH
15497: LD_INT 2
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: PUSH
15504: LD_INT 58
15506: PUSH
15507: EMPTY
15508: LIST
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: LIST
15514: PPUSH
15515: CALL_OW 69
15519: DIFF
15520: ST_TO_ADDR
15521: GO 15625
15523: LD_STRING electro
15525: DOUBLE
15526: EQUAL
15527: IFTRUE 15531
15529: GO 15605
15531: POP
// filter := filter diff FilterAllUnits ( [ [ f_side , enemy_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ; capture_vehicle :
15532: LD_ADDR_VAR 0 7
15536: PUSH
15537: LD_VAR 0 7
15541: PUSH
15542: LD_INT 22
15544: PUSH
15545: LD_VAR 0 2
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PUSH
15554: LD_INT 2
15556: PUSH
15557: LD_INT 30
15559: PUSH
15560: LD_INT 27
15562: PUSH
15563: EMPTY
15564: LIST
15565: LIST
15566: PUSH
15567: LD_INT 30
15569: PUSH
15570: LD_INT 26
15572: PUSH
15573: EMPTY
15574: LIST
15575: LIST
15576: PUSH
15577: LD_INT 30
15579: PUSH
15580: LD_INT 28
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: PUSH
15587: EMPTY
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: PUSH
15593: EMPTY
15594: LIST
15595: LIST
15596: PPUSH
15597: CALL_OW 69
15601: DIFF
15602: ST_TO_ADDR
15603: GO 15625
15605: LD_STRING capture_vehicle
15607: DOUBLE
15608: EQUAL
15609: IFTRUE 15613
15611: GO 15624
15613: POP
// capture_mode := true ; end ;
15614: LD_ADDR_VAR 0 9
15618: PUSH
15619: LD_INT 1
15621: ST_TO_ADDR
15622: GO 15625
15624: POP
// end ;
15625: GO 15066
15627: POP
15628: POP
// if not WantsToAttack ( unit ) then
15629: LD_VAR 0 1
15633: PPUSH
15634: CALL_OW 319
15638: NOT
15639: IFFALSE 15841
// begin if filter then
15641: LD_VAR 0 7
15645: IFFALSE 15673
// begin ComAttackUnit ( unit , NearestUnitToUnit ( filter , unit ) ) ;
15647: LD_VAR 0 1
15651: PPUSH
15652: LD_VAR 0 7
15656: PPUSH
15657: LD_VAR 0 1
15661: PPUSH
15662: CALL_OW 74
15666: PPUSH
15667: CALL_OW 115
// end else
15671: GO 15733
// if GetDistUnitXY ( unit , path [ 1 ] , path [ 2 ] ) > 7 then
15673: LD_VAR 0 1
15677: PPUSH
15678: LD_VAR 0 3
15682: PUSH
15683: LD_INT 1
15685: ARRAY
15686: PPUSH
15687: LD_VAR 0 3
15691: PUSH
15692: LD_INT 2
15694: ARRAY
15695: PPUSH
15696: CALL_OW 297
15700: PUSH
15701: LD_INT 7
15703: GREATER
15704: IFFALSE 15733
// ComMoveXY ( unit , path [ 1 ] , path [ 2 ] ) ;
15706: LD_VAR 0 1
15710: PPUSH
15711: LD_VAR 0 3
15715: PUSH
15716: LD_INT 1
15718: ARRAY
15719: PPUSH
15720: LD_VAR 0 3
15724: PUSH
15725: LD_INT 2
15727: ARRAY
15728: PPUSH
15729: CALL_OW 111
// if capture_mode and unit in FilterAllUnits ( [ f_type , unit_human ] ) then
15733: LD_VAR 0 9
15737: PUSH
15738: LD_VAR 0 1
15742: PUSH
15743: LD_INT 21
15745: PUSH
15746: LD_INT 1
15748: PUSH
15749: EMPTY
15750: LIST
15751: LIST
15752: PPUSH
15753: CALL_OW 69
15757: IN
15758: AND
15759: IFFALSE 15841
// begin if NearestUnitToUnit ( all_vehs , unit ) in FilterAllUnits ( [ [ [ f_type , unit_vehicle ] , [ f_empty ] , [ f_lives , 251 ] ] ] ) then
15761: LD_VAR 0 8
15765: PPUSH
15766: LD_VAR 0 1
15770: PPUSH
15771: CALL_OW 74
15775: PUSH
15776: LD_INT 21
15778: PUSH
15779: LD_INT 2
15781: PUSH
15782: EMPTY
15783: LIST
15784: LIST
15785: PUSH
15786: LD_INT 58
15788: PUSH
15789: EMPTY
15790: LIST
15791: PUSH
15792: LD_INT 24
15794: PUSH
15795: LD_INT 251
15797: PUSH
15798: EMPTY
15799: LIST
15800: LIST
15801: PUSH
15802: EMPTY
15803: LIST
15804: LIST
15805: LIST
15806: PUSH
15807: EMPTY
15808: LIST
15809: PPUSH
15810: CALL_OW 69
15814: IN
15815: IFFALSE 15841
// ComEnterUnit ( unit , NearestUnitToUnit ( all_vehs , unit ) ) ;
15817: LD_VAR 0 1
15821: PPUSH
15822: LD_VAR 0 8
15826: PPUSH
15827: LD_VAR 0 1
15831: PPUSH
15832: CALL_OW 74
15836: PPUSH
15837: CALL_OW 120
// end ; end ; end ;
15841: LD_VAR 0 5
15845: RET
// export function FilterNonCombatVehicle ( side ) ; begin
15846: LD_INT 0
15848: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_bulldozer ] , [ f_weapon , us_crane ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_control_tower ] ] ] ) ;
15849: LD_ADDR_VAR 0 2
15853: PUSH
15854: LD_INT 22
15856: PUSH
15857: LD_VAR 0 1
15861: PUSH
15862: EMPTY
15863: LIST
15864: LIST
15865: PUSH
15866: LD_INT 2
15868: PUSH
15869: LD_INT 34
15871: PUSH
15872: LD_INT 12
15874: PUSH
15875: EMPTY
15876: LIST
15877: LIST
15878: PUSH
15879: LD_INT 34
15881: PUSH
15882: LD_INT 14
15884: PUSH
15885: EMPTY
15886: LIST
15887: LIST
15888: PUSH
15889: LD_INT 34
15891: PUSH
15892: LD_INT 13
15894: PUSH
15895: EMPTY
15896: LIST
15897: LIST
15898: PUSH
15899: LD_INT 34
15901: PUSH
15902: LD_INT 32
15904: PUSH
15905: EMPTY
15906: LIST
15907: LIST
15908: PUSH
15909: LD_INT 34
15911: PUSH
15912: LD_EXP 1
15916: PUSH
15917: EMPTY
15918: LIST
15919: LIST
15920: PUSH
15921: LD_INT 34
15923: PUSH
15924: LD_INT 51
15926: PUSH
15927: EMPTY
15928: LIST
15929: LIST
15930: PUSH
15931: LD_INT 34
15933: PUSH
15934: LD_EXP 2
15938: PUSH
15939: EMPTY
15940: LIST
15941: LIST
15942: PUSH
15943: LD_INT 34
15945: PUSH
15946: LD_INT 53
15948: PUSH
15949: EMPTY
15950: LIST
15951: LIST
15952: PUSH
15953: LD_INT 34
15955: PUSH
15956: LD_INT 52
15958: PUSH
15959: EMPTY
15960: LIST
15961: LIST
15962: PUSH
15963: LD_INT 34
15965: PUSH
15966: LD_INT 31
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PUSH
15973: EMPTY
15974: LIST
15975: LIST
15976: LIST
15977: LIST
15978: LIST
15979: LIST
15980: LIST
15981: LIST
15982: LIST
15983: LIST
15984: LIST
15985: PUSH
15986: EMPTY
15987: LIST
15988: LIST
15989: PPUSH
15990: CALL_OW 69
15994: ST_TO_ADDR
// end ;
15995: LD_VAR 0 2
15999: RET
// export function SelectEnemy ( side , list ) ; var tlist , i ; begin
16000: LD_INT 0
16002: PPUSH
16003: PPUSH
16004: PPUSH
// tlist := 0 ;
16005: LD_ADDR_VAR 0 4
16009: PUSH
16010: LD_INT 0
16012: ST_TO_ADDR
// for i = 1 to list do
16013: LD_ADDR_VAR 0 5
16017: PUSH
16018: DOUBLE
16019: LD_INT 1
16021: DEC
16022: ST_TO_ADDR
16023: LD_VAR 0 2
16027: PUSH
16028: FOR_TO
16029: IFFALSE 16067
// if FilterAllUnits ( [ f_side , list [ i ] ] ) then
16031: LD_INT 22
16033: PUSH
16034: LD_VAR 0 2
16038: PUSH
16039: LD_VAR 0 5
16043: ARRAY
16044: PUSH
16045: EMPTY
16046: LIST
16047: LIST
16048: PPUSH
16049: CALL_OW 69
16053: IFFALSE 16065
// tlist := i ;
16055: LD_ADDR_VAR 0 4
16059: PUSH
16060: LD_VAR 0 5
16064: ST_TO_ADDR
16065: GO 16028
16067: POP
16068: POP
// result := tlist ;
16069: LD_ADDR_VAR 0 3
16073: PUSH
16074: LD_VAR 0 4
16078: ST_TO_ADDR
// end ;
16079: LD_VAR 0 3
16083: RET
// export function NumAtt ( min , mod_attack , increment , max ) ; var i , n , t_tick ; begin
16084: LD_INT 0
16086: PPUSH
16087: PPUSH
16088: PPUSH
16089: PPUSH
// t_tick := tick ;
16090: LD_ADDR_VAR 0 8
16094: PUSH
16095: LD_OWVAR 1
16099: ST_TO_ADDR
// n := t_tick / mod_attack ;
16100: LD_ADDR_VAR 0 7
16104: PUSH
16105: LD_VAR 0 8
16109: PUSH
16110: LD_VAR 0 2
16114: DIVREAL
16115: ST_TO_ADDR
// if n >= max then
16116: LD_VAR 0 7
16120: PUSH
16121: LD_VAR 0 4
16125: GREATEREQUAL
16126: IFFALSE 16140
// n := max else
16128: LD_ADDR_VAR 0 7
16132: PUSH
16133: LD_VAR 0 4
16137: ST_TO_ADDR
16138: GO 16168
// if n < max then
16140: LD_VAR 0 7
16144: PUSH
16145: LD_VAR 0 4
16149: LESS
16150: IFFALSE 16168
// n := n * increment ;
16152: LD_ADDR_VAR 0 7
16156: PUSH
16157: LD_VAR 0 7
16161: PUSH
16162: LD_VAR 0 3
16166: MUL
16167: ST_TO_ADDR
// if n > max then
16168: LD_VAR 0 7
16172: PUSH
16173: LD_VAR 0 4
16177: GREATER
16178: IFFALSE 16192
// result := max else
16180: LD_ADDR_VAR 0 5
16184: PUSH
16185: LD_VAR 0 4
16189: ST_TO_ADDR
16190: GO 16226
// if n >= min then
16192: LD_VAR 0 7
16196: PUSH
16197: LD_VAR 0 1
16201: GREATEREQUAL
16202: IFFALSE 16216
// result := n else
16204: LD_ADDR_VAR 0 5
16208: PUSH
16209: LD_VAR 0 7
16213: ST_TO_ADDR
16214: GO 16226
// result := min ;
16216: LD_ADDR_VAR 0 5
16220: PUSH
16221: LD_VAR 0 1
16225: ST_TO_ADDR
// end ;
16226: LD_VAR 0 5
16230: RET
// export function AddMechanic ( plist , amount ) ; var i ; begin
16231: LD_INT 0
16233: PPUSH
16234: PPUSH
// if amount >= plist then
16235: LD_VAR 0 2
16239: PUSH
16240: LD_VAR 0 1
16244: GREATEREQUAL
16245: IFFALSE 16257
// result := false else
16247: LD_ADDR_VAR 0 3
16251: PUSH
16252: LD_INT 0
16254: ST_TO_ADDR
16255: GO 16424
// for i = plist downto amount do
16257: LD_ADDR_VAR 0 4
16261: PUSH
16262: DOUBLE
16263: LD_VAR 0 1
16267: INC
16268: ST_TO_ADDR
16269: LD_VAR 0 2
16273: PUSH
16274: FOR_DOWNTO
16275: IFFALSE 16422
// begin if not IsInUnit ( plist [ i ] ) and not HasTask ( plist [ i ] ) and GetTag ( plist [ i ] ) = 0 and GetBuilding ( GetSide ( plist [ plist ] ) , b_factory ) then
16277: LD_VAR 0 1
16281: PUSH
16282: LD_VAR 0 4
16286: ARRAY
16287: PPUSH
16288: CALL_OW 310
16292: NOT
16293: PUSH
16294: LD_VAR 0 1
16298: PUSH
16299: LD_VAR 0 4
16303: ARRAY
16304: PPUSH
16305: CALL_OW 314
16309: NOT
16310: AND
16311: PUSH
16312: LD_VAR 0 1
16316: PUSH
16317: LD_VAR 0 4
16321: ARRAY
16322: PPUSH
16323: CALL_OW 110
16327: PUSH
16328: LD_INT 0
16330: EQUAL
16331: AND
16332: PUSH
16333: LD_VAR 0 1
16337: PUSH
16338: LD_VAR 0 1
16342: ARRAY
16343: PPUSH
16344: CALL_OW 255
16348: PPUSH
16349: LD_INT 3
16351: PPUSH
16352: CALL 1265 0 2
16356: AND
16357: IFFALSE 16420
// begin ComEnterUnit ( plist [ i ] , GetBuilding ( GetSide ( plist [ plist ] ) , b_factory ) [ 1 ] ) ;
16359: LD_VAR 0 1
16363: PUSH
16364: LD_VAR 0 4
16368: ARRAY
16369: PPUSH
16370: LD_VAR 0 1
16374: PUSH
16375: LD_VAR 0 1
16379: ARRAY
16380: PPUSH
16381: CALL_OW 255
16385: PPUSH
16386: LD_INT 3
16388: PPUSH
16389: CALL 1265 0 2
16393: PUSH
16394: LD_INT 1
16396: ARRAY
16397: PPUSH
16398: CALL_OW 120
// AddComChangeProfession ( plist [ i ] , 3 ) ;
16402: LD_VAR 0 1
16406: PUSH
16407: LD_VAR 0 4
16411: ARRAY
16412: PPUSH
16413: LD_INT 3
16415: PPUSH
16416: CALL_OW 183
// end ; end ;
16420: GO 16274
16422: POP
16423: POP
// end ; end_of_file
16424: LD_VAR 0 3
16428: RET
// export sikorski ; end_of_file export powell ; every 0 0$01 do var i , p , sold , eng , mech , sci , b , veh , filter , side , pom , vehicles , tmp , en , enemy_xy , depot_xy , lab_xy , fac_xy , turret_xy , lab_kind , fac_ext , arm_xy , crates_area , tech_list , oil_xy , sib_xy , want_more_oil , want_more_sib , sol_pow_list , oil_pow_list , sib_pow_list , turret_weapon , not_turret_weapon , veh_list , cargo_allow , cargo_chassis , cargo_type , allow_ct , ct_xy , ct_chassis , xy_back , enemy_list , modernize_cargo_allow , crane_allow , crane_type , crane_engine , crane_chassis , crane_num , modernize_crane_allow , bulldozer_allow , bulldozer_chassis , bulldozer_engine , bulldozer_type , tree_area , parking_area , second_base_allow , second_base_xy , transport_from_second_base , build_second_base_after , lab , base_status , sec_points , scout_near_base , repair_xy , vehicle_def , attack_info ;
16429: GO 16431
16431: DISABLE
16432: LD_INT 0
16434: PPUSH
16435: PPUSH
16436: PPUSH
16437: PPUSH
16438: PPUSH
16439: PPUSH
16440: PPUSH
16441: PPUSH
16442: PPUSH
16443: PPUSH
16444: PPUSH
16445: PPUSH
16446: PPUSH
16447: PPUSH
16448: PPUSH
16449: PPUSH
16450: PPUSH
16451: PPUSH
16452: PPUSH
16453: PPUSH
16454: PPUSH
16455: PPUSH
16456: PPUSH
16457: PPUSH
16458: PPUSH
16459: PPUSH
16460: PPUSH
16461: PPUSH
16462: PPUSH
16463: PPUSH
16464: PPUSH
16465: PPUSH
16466: PPUSH
16467: PPUSH
16468: PPUSH
16469: PPUSH
16470: PPUSH
16471: PPUSH
16472: PPUSH
16473: PPUSH
16474: PPUSH
16475: PPUSH
16476: PPUSH
16477: PPUSH
16478: PPUSH
16479: PPUSH
16480: PPUSH
16481: PPUSH
16482: PPUSH
16483: PPUSH
16484: PPUSH
16485: PPUSH
16486: PPUSH
16487: PPUSH
16488: PPUSH
16489: PPUSH
16490: PPUSH
16491: PPUSH
16492: PPUSH
16493: PPUSH
16494: PPUSH
16495: PPUSH
16496: PPUSH
16497: PPUSH
16498: PPUSH
16499: PPUSH
// begin enable ;
16500: ENABLE
// side := 4 ;
16501: LD_ADDR_VAR 0 10
16505: PUSH
16506: LD_INT 4
16508: ST_TO_ADDR
// enemy_list := [ 2 , 3 ] ;
16509: LD_ADDR_VAR 0 42
16513: PUSH
16514: LD_INT 2
16516: PUSH
16517: LD_INT 3
16519: PUSH
16520: EMPTY
16521: LIST
16522: LIST
16523: ST_TO_ADDR
// enemy_xy := [ [ 10 , 9 ] , [ 70 , 137 ] ] ;
16524: LD_ADDR_VAR 0 15
16528: PUSH
16529: LD_INT 10
16531: PUSH
16532: LD_INT 9
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: PUSH
16539: LD_INT 70
16541: PUSH
16542: LD_INT 137
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: ST_TO_ADDR
// sold := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 1 ] ] ) ;
16553: LD_ADDR_VAR 0 3
16557: PUSH
16558: LD_INT 22
16560: PUSH
16561: LD_VAR 0 10
16565: PUSH
16566: EMPTY
16567: LIST
16568: LIST
16569: PUSH
16570: LD_INT 25
16572: PUSH
16573: LD_INT 1
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PPUSH
16584: CALL_OW 69
16588: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) ;
16589: LD_ADDR_VAR 0 4
16593: PUSH
16594: LD_INT 22
16596: PUSH
16597: LD_VAR 0 10
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: PUSH
16606: LD_INT 25
16608: PUSH
16609: LD_INT 2
16611: PUSH
16612: EMPTY
16613: LIST
16614: LIST
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PPUSH
16620: CALL_OW 69
16624: ST_TO_ADDR
// mech := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
16625: LD_ADDR_VAR 0 5
16629: PUSH
16630: LD_INT 22
16632: PUSH
16633: LD_VAR 0 10
16637: PUSH
16638: EMPTY
16639: LIST
16640: LIST
16641: PUSH
16642: LD_INT 25
16644: PUSH
16645: LD_INT 3
16647: PUSH
16648: EMPTY
16649: LIST
16650: LIST
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PPUSH
16656: CALL_OW 69
16660: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] ] ) ;
16661: LD_ADDR_VAR 0 6
16665: PUSH
16666: LD_INT 22
16668: PUSH
16669: LD_VAR 0 10
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: PUSH
16678: LD_INT 25
16680: PUSH
16681: LD_INT 4
16683: PUSH
16684: EMPTY
16685: LIST
16686: LIST
16687: PUSH
16688: EMPTY
16689: LIST
16690: LIST
16691: PPUSH
16692: CALL_OW 69
16696: ST_TO_ADDR
// vehicles := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ;
16697: LD_ADDR_VAR 0 12
16701: PUSH
16702: LD_INT 22
16704: PUSH
16705: LD_VAR 0 10
16709: PUSH
16710: EMPTY
16711: LIST
16712: LIST
16713: PUSH
16714: LD_INT 21
16716: PUSH
16717: LD_INT 2
16719: PUSH
16720: EMPTY
16721: LIST
16722: LIST
16723: PUSH
16724: EMPTY
16725: LIST
16726: LIST
16727: PPUSH
16728: CALL_OW 69
16732: ST_TO_ADDR
// sec_points := [ 158 , 121 , 149 , 103 , 152 , 85 , 147 , 132 ] ;
16733: LD_ADDR_VAR 0 62
16737: PUSH
16738: LD_INT 158
16740: PUSH
16741: LD_INT 121
16743: PUSH
16744: LD_INT 149
16746: PUSH
16747: LD_INT 103
16749: PUSH
16750: LD_INT 152
16752: PUSH
16753: LD_INT 85
16755: PUSH
16756: LD_INT 147
16758: PUSH
16759: LD_INT 132
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: LIST
16766: LIST
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: ST_TO_ADDR
// depot_xy := [ 163 , 97 , 4 ] ;
16772: LD_ADDR_VAR 0 16
16776: PUSH
16777: LD_INT 163
16779: PUSH
16780: LD_INT 97
16782: PUSH
16783: LD_INT 4
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: LIST
16790: ST_TO_ADDR
// lab_xy := [ 169 , 109 , 0 , 150 , 73 , 1 ] ;
16791: LD_ADDR_VAR 0 17
16795: PUSH
16796: LD_INT 169
16798: PUSH
16799: LD_INT 109
16801: PUSH
16802: LD_INT 0
16804: PUSH
16805: LD_INT 150
16807: PUSH
16808: LD_INT 73
16810: PUSH
16811: LD_INT 1
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: LIST
16818: LIST
16819: LIST
16820: LIST
16821: ST_TO_ADDR
// lab_kind := [ b_lab_weapon , b_lab_opto , b_lab_siberium , b_lab_computer ] ;
16822: LD_ADDR_VAR 0 20
16826: PUSH
16827: LD_INT 10
16829: PUSH
16830: LD_INT 15
16832: PUSH
16833: LD_INT 11
16835: PUSH
16836: LD_INT 12
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: ST_TO_ADDR
// fac_xy := [ 175 , 126 , 4 ] ;
16845: LD_ADDR_VAR 0 18
16849: PUSH
16850: LD_INT 175
16852: PUSH
16853: LD_INT 126
16855: PUSH
16856: LD_INT 4
16858: PUSH
16859: EMPTY
16860: LIST
16861: LIST
16862: LIST
16863: ST_TO_ADDR
// arm_xy := [ 159 , 104 , 1 ] ;
16864: LD_ADDR_VAR 0 22
16868: PUSH
16869: LD_INT 159
16871: PUSH
16872: LD_INT 104
16874: PUSH
16875: LD_INT 1
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: LIST
16882: ST_TO_ADDR
// xy_back := [ 160 , 100 ] ;
16883: LD_ADDR_VAR 0 41
16887: PUSH
16888: LD_INT 160
16890: PUSH
16891: LD_INT 100
16893: PUSH
16894: EMPTY
16895: LIST
16896: LIST
16897: ST_TO_ADDR
// turret_xy := [ b_bunker , 152 , 94 , 2 , b_bunker , 141 , 101 , 2 , b_bunker , 143 , 97 , 2 , b_bunker , 158 , 122 , 0 ] ;
16898: LD_ADDR_VAR 0 19
16902: PUSH
16903: LD_INT 32
16905: PUSH
16906: LD_INT 152
16908: PUSH
16909: LD_INT 94
16911: PUSH
16912: LD_INT 2
16914: PUSH
16915: LD_INT 32
16917: PUSH
16918: LD_INT 141
16920: PUSH
16921: LD_INT 101
16923: PUSH
16924: LD_INT 2
16926: PUSH
16927: LD_INT 32
16929: PUSH
16930: LD_INT 143
16932: PUSH
16933: LD_INT 97
16935: PUSH
16936: LD_INT 2
16938: PUSH
16939: LD_INT 32
16941: PUSH
16942: LD_INT 158
16944: PUSH
16945: LD_INT 122
16947: PUSH
16948: LD_INT 0
16950: PUSH
16951: EMPTY
16952: LIST
16953: LIST
16954: LIST
16955: LIST
16956: LIST
16957: LIST
16958: LIST
16959: LIST
16960: LIST
16961: LIST
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: LIST
16967: LIST
16968: ST_TO_ADDR
// not_turret_weapon := [ us_crane , us_cargo_bay , us_bulldozer , us_machine_gun ] ;
16969: LD_ADDR_VAR 0 33
16973: PUSH
16974: LD_INT 13
16976: PUSH
16977: LD_INT 12
16979: PUSH
16980: LD_INT 14
16982: PUSH
16983: LD_INT 2
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: ST_TO_ADDR
// fac_ext := [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radar ] ;
16992: LD_ADDR_VAR 0 21
16996: PUSH
16997: LD_INT 19
16999: PUSH
17000: LD_INT 16
17002: PUSH
17003: LD_INT 17
17005: PUSH
17006: LD_INT 18
17008: PUSH
17009: LD_INT 20
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: ST_TO_ADDR
// sol_pow_list := [ 152 , 86 , 4 , 156 , 87 , 4 , 157 , 110 , 2 ] ;
17019: LD_ADDR_VAR 0 29
17023: PUSH
17024: LD_INT 152
17026: PUSH
17027: LD_INT 86
17029: PUSH
17030: LD_INT 4
17032: PUSH
17033: LD_INT 156
17035: PUSH
17036: LD_INT 87
17038: PUSH
17039: LD_INT 4
17041: PUSH
17042: LD_INT 157
17044: PUSH
17045: LD_INT 110
17047: PUSH
17048: LD_INT 2
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: LIST
17055: LIST
17056: LIST
17057: LIST
17058: LIST
17059: LIST
17060: LIST
17061: ST_TO_ADDR
// oil_pow_list := [ 177 , 120 , 0 ] ;
17062: LD_ADDR_VAR 0 30
17066: PUSH
17067: LD_INT 177
17069: PUSH
17070: LD_INT 120
17072: PUSH
17073: LD_INT 0
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: LIST
17080: ST_TO_ADDR
// sib_pow_list := [ ] ;
17081: LD_ADDR_VAR 0 31
17085: PUSH
17086: EMPTY
17087: ST_TO_ADDR
// allow_ct := true ;
17088: LD_ADDR_VAR 0 38
17092: PUSH
17093: LD_INT 1
17095: ST_TO_ADDR
// ct_xy := [ 168 , 102 , 4 ] ;
17096: LD_ADDR_VAR 0 39
17100: PUSH
17101: LD_INT 168
17103: PUSH
17104: LD_INT 102
17106: PUSH
17107: LD_INT 4
17109: PUSH
17110: EMPTY
17111: LIST
17112: LIST
17113: LIST
17114: ST_TO_ADDR
// ct_chassis := 0 ;
17115: LD_ADDR_VAR 0 40
17119: PUSH
17120: LD_INT 0
17122: ST_TO_ADDR
// second_base_allow := true ;
17123: LD_ADDR_VAR 0 56
17127: PUSH
17128: LD_INT 1
17130: ST_TO_ADDR
// second_base_xy := [ 147 , 135 , 0 ] ;
17131: LD_ADDR_VAR 0 57
17135: PUSH
17136: LD_INT 147
17138: PUSH
17139: LD_INT 135
17141: PUSH
17142: LD_INT 0
17144: PUSH
17145: EMPTY
17146: LIST
17147: LIST
17148: LIST
17149: ST_TO_ADDR
// transport_from_second_base := [ true , 30 ] ;
17150: LD_ADDR_VAR 0 58
17154: PUSH
17155: LD_INT 1
17157: PUSH
17158: LD_INT 30
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: ST_TO_ADDR
// build_second_base_after := [ 11 11$00 , tech_SibDet ] ;
17165: LD_ADDR_VAR 0 59
17169: PUSH
17170: LD_INT 23100
17172: PUSH
17173: LD_INT 20
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: ST_TO_ADDR
// oil_xy := [ 161 , 89 , 146 , 88 ] ;
17180: LD_ADDR_VAR 0 25
17184: PUSH
17185: LD_INT 161
17187: PUSH
17188: LD_INT 89
17190: PUSH
17191: LD_INT 146
17193: PUSH
17194: LD_INT 88
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: ST_TO_ADDR
// sib_xy := [ 157 , 134 ] ;
17203: LD_ADDR_VAR 0 26
17207: PUSH
17208: LD_INT 157
17210: PUSH
17211: LD_INT 134
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: ST_TO_ADDR
// want_more_oil := true ;
17218: LD_ADDR_VAR 0 27
17222: PUSH
17223: LD_INT 1
17225: ST_TO_ADDR
// want_more_sib := false ;
17226: LD_ADDR_VAR 0 28
17230: PUSH
17231: LD_INT 0
17233: ST_TO_ADDR
// tech_list := [ 35 , 45 , 46 , 47 , 1 , 48 , 49 , 50 , 20 , 51 , 52 , 69 , 39 , 60 , 61 , 6 , 15 ] ;
17234: LD_ADDR_VAR 0 24
17238: PUSH
17239: LD_INT 35
17241: PUSH
17242: LD_INT 45
17244: PUSH
17245: LD_INT 46
17247: PUSH
17248: LD_INT 47
17250: PUSH
17251: LD_INT 1
17253: PUSH
17254: LD_INT 48
17256: PUSH
17257: LD_INT 49
17259: PUSH
17260: LD_INT 50
17262: PUSH
17263: LD_INT 20
17265: PUSH
17266: LD_INT 51
17268: PUSH
17269: LD_INT 52
17271: PUSH
17272: LD_INT 69
17274: PUSH
17275: LD_INT 39
17277: PUSH
17278: LD_INT 60
17280: PUSH
17281: LD_INT 61
17283: PUSH
17284: LD_INT 6
17286: PUSH
17287: LD_INT 15
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: LIST
17294: LIST
17295: LIST
17296: LIST
17297: LIST
17298: LIST
17299: LIST
17300: LIST
17301: LIST
17302: LIST
17303: LIST
17304: LIST
17305: LIST
17306: LIST
17307: LIST
17308: ST_TO_ADDR
// crates_area := powell_crates ;
17309: LD_ADDR_VAR 0 23
17313: PUSH
17314: LD_INT 2
17316: ST_TO_ADDR
// veh_list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ;
17317: LD_ADDR_VAR 0 34
17321: PUSH
17322: LD_INT 22
17324: PUSH
17325: LD_VAR 0 10
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: PUSH
17334: LD_INT 21
17336: PUSH
17337: LD_INT 2
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: PUSH
17344: EMPTY
17345: LIST
17346: LIST
17347: PPUSH
17348: CALL_OW 69
17352: ST_TO_ADDR
// repair_xy := [ 171 , 126 ] ;
17353: LD_ADDR_VAR 0 64
17357: PUSH
17358: LD_INT 171
17360: PUSH
17361: LD_INT 126
17363: PUSH
17364: EMPTY
17365: LIST
17366: LIST
17367: ST_TO_ADDR
// vehicle_def := [ 3 , [ after_CRANE , control_remote ] , [ us_medium_tracked , engine_combustion , control_remote ] , [ us_gatling_gun , us_double_gun ] ] ;
17368: LD_ADDR_VAR 0 65
17372: PUSH
17373: LD_INT 3
17375: PUSH
17376: LD_STRING after_CRANE
17378: PUSH
17379: LD_INT 2
17381: PUSH
17382: EMPTY
17383: LIST
17384: LIST
17385: PUSH
17386: LD_INT 3
17388: PUSH
17389: LD_INT 1
17391: PUSH
17392: LD_INT 2
17394: PUSH
17395: EMPTY
17396: LIST
17397: LIST
17398: LIST
17399: PUSH
17400: LD_INT 4
17402: PUSH
17403: LD_INT 5
17405: PUSH
17406: EMPTY
17407: LIST
17408: LIST
17409: PUSH
17410: EMPTY
17411: LIST
17412: LIST
17413: LIST
17414: LIST
17415: ST_TO_ADDR
// parking_area := powell_parking ;
17416: LD_ADDR_VAR 0 55
17420: PUSH
17421: LD_INT 4
17423: ST_TO_ADDR
// cargo_allow := true ;
17424: LD_ADDR_VAR 0 35
17428: PUSH
17429: LD_INT 1
17431: ST_TO_ADDR
// cargo_chassis := us_medium_tracked ;
17432: LD_ADDR_VAR 0 36
17436: PUSH
17437: LD_INT 3
17439: ST_TO_ADDR
// cargo_type := [ us_cargo_bay ] ;
17440: LD_ADDR_VAR 0 37
17444: PUSH
17445: LD_INT 12
17447: PUSH
17448: EMPTY
17449: LIST
17450: ST_TO_ADDR
// modernize_cargo_allow := true ;
17451: LD_ADDR_VAR 0 43
17455: PUSH
17456: LD_INT 1
17458: ST_TO_ADDR
// crane_allow := true ;
17459: LD_ADDR_VAR 0 44
17463: PUSH
17464: LD_INT 1
17466: ST_TO_ADDR
// crane_chassis := us_medium_tracked ;
17467: LD_ADDR_VAR 0 47
17471: PUSH
17472: LD_INT 3
17474: ST_TO_ADDR
// crane_engine := engine_solar ;
17475: LD_ADDR_VAR 0 46
17479: PUSH
17480: LD_INT 2
17482: ST_TO_ADDR
// crane_type := [ us_crane ] ;
17483: LD_ADDR_VAR 0 45
17487: PUSH
17488: LD_INT 13
17490: PUSH
17491: EMPTY
17492: LIST
17493: ST_TO_ADDR
// crane_num := 1 ;
17494: LD_ADDR_VAR 0 48
17498: PUSH
17499: LD_INT 1
17501: ST_TO_ADDR
// modernize_crane_allow := true ;
17502: LD_ADDR_VAR 0 49
17506: PUSH
17507: LD_INT 1
17509: ST_TO_ADDR
// bulldozer_allow := true ;
17510: LD_ADDR_VAR 0 50
17514: PUSH
17515: LD_INT 1
17517: ST_TO_ADDR
// bulldozer_chassis := us_heavy_tracked ;
17518: LD_ADDR_VAR 0 51
17522: PUSH
17523: LD_INT 4
17525: ST_TO_ADDR
// bulldozer_engine := engine_combustion ;
17526: LD_ADDR_VAR 0 52
17530: PUSH
17531: LD_INT 1
17533: ST_TO_ADDR
// bulldozer_type := [ us_bulldozer ] ;
17534: LD_ADDR_VAR 0 53
17538: PUSH
17539: LD_INT 14
17541: PUSH
17542: EMPTY
17543: LIST
17544: ST_TO_ADDR
// tree_area := powell_tree ;
17545: LD_ADDR_VAR 0 54
17549: PUSH
17550: LD_INT 3
17552: ST_TO_ADDR
// attack_info := [ 3 , 5 5$00 , 1 , 4 , [ electro ] ] ;
17553: LD_ADDR_VAR 0 66
17557: PUSH
17558: LD_INT 3
17560: PUSH
17561: LD_INT 10500
17563: PUSH
17564: LD_INT 1
17566: PUSH
17567: LD_INT 4
17569: PUSH
17570: LD_STRING electro
17572: PUSH
17573: EMPTY
17574: LIST
17575: PUSH
17576: EMPTY
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: LIST
17582: ST_TO_ADDR
// scout_near_base := [ sold [ 2 ] , [ 144 , 67 , 134 , 65 , 125 , 47 , 100 , 61 , xy_back [ 1 ] , xy_back [ 2 ] ] , sold [ 3 ] , [ 179 , 134 , 152 , 131 , 121 , 106 , 123 , 86 , xy_back [ 1 ] , xy_back [ 2 ] ] ] ;
17583: LD_ADDR_VAR 0 63
17587: PUSH
17588: LD_VAR 0 3
17592: PUSH
17593: LD_INT 2
17595: ARRAY
17596: PUSH
17597: LD_INT 144
17599: PUSH
17600: LD_INT 67
17602: PUSH
17603: LD_INT 134
17605: PUSH
17606: LD_INT 65
17608: PUSH
17609: LD_INT 125
17611: PUSH
17612: LD_INT 47
17614: PUSH
17615: LD_INT 100
17617: PUSH
17618: LD_INT 61
17620: PUSH
17621: LD_VAR 0 41
17625: PUSH
17626: LD_INT 1
17628: ARRAY
17629: PUSH
17630: LD_VAR 0 41
17634: PUSH
17635: LD_INT 2
17637: ARRAY
17638: PUSH
17639: EMPTY
17640: LIST
17641: LIST
17642: LIST
17643: LIST
17644: LIST
17645: LIST
17646: LIST
17647: LIST
17648: LIST
17649: LIST
17650: PUSH
17651: LD_VAR 0 3
17655: PUSH
17656: LD_INT 3
17658: ARRAY
17659: PUSH
17660: LD_INT 179
17662: PUSH
17663: LD_INT 134
17665: PUSH
17666: LD_INT 152
17668: PUSH
17669: LD_INT 131
17671: PUSH
17672: LD_INT 121
17674: PUSH
17675: LD_INT 106
17677: PUSH
17678: LD_INT 123
17680: PUSH
17681: LD_INT 86
17683: PUSH
17684: LD_VAR 0 41
17688: PUSH
17689: LD_INT 1
17691: ARRAY
17692: PUSH
17693: LD_VAR 0 41
17697: PUSH
17698: LD_INT 2
17700: ARRAY
17701: PUSH
17702: EMPTY
17703: LIST
17704: LIST
17705: LIST
17706: LIST
17707: LIST
17708: LIST
17709: LIST
17710: LIST
17711: LIST
17712: LIST
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: LIST
17718: LIST
17719: ST_TO_ADDR
// if EnemyInRange ( side , sec_points ) then
17720: LD_VAR 0 10
17724: PPUSH
17725: LD_VAR 0 62
17729: PPUSH
17730: CALL 433 0 2
17734: IFFALSE 17746
// base_status := true else
17736: LD_ADDR_VAR 0 61
17740: PUSH
17741: LD_INT 1
17743: ST_TO_ADDR
17744: GO 17754
// base_status := false ;
17746: LD_ADDR_VAR 0 61
17750: PUSH
17751: LD_INT 0
17753: ST_TO_ADDR
// if base_status then
17754: LD_VAR 0 61
17758: IFFALSE 18016
// begin VehicleMove ( side , parking_area , 83 , defend , [ ] ) ;
17760: LD_VAR 0 10
17764: PPUSH
17765: LD_VAR 0 55
17769: PPUSH
17770: LD_INT 83
17772: PPUSH
17773: LD_STRING defend
17775: PPUSH
17776: EMPTY
17777: PPUSH
17778: CALL 14244 0 5
// if eng then
17782: LD_VAR 0 4
17786: IFFALSE 17820
// RepairBase ( side , enemy_list , xy_back [ 1 ] , xy_back [ 2 ] ) ;
17788: LD_VAR 0 10
17792: PPUSH
17793: LD_VAR 0 42
17797: PPUSH
17798: LD_VAR 0 41
17802: PUSH
17803: LD_INT 1
17805: ARRAY
17806: PPUSH
17807: LD_VAR 0 41
17811: PUSH
17812: LD_INT 2
17814: ARRAY
17815: PPUSH
17816: CALL 11363 0 4
// if sci then
17820: LD_VAR 0 6
17824: IFFALSE 17838
// HealPersonel ( side , 99 ) ;
17826: LD_VAR 0 10
17830: PPUSH
17831: LD_INT 99
17833: PPUSH
17834: CALL 12655 0 2
// if sold and not NeedBuilding ( side , b_barracks ) then
17838: LD_VAR 0 3
17842: PUSH
17843: LD_VAR 0 10
17847: PPUSH
17848: LD_INT 5
17850: PPUSH
17851: CALL 1042 0 2
17855: NOT
17856: AND
17857: IFFALSE 18016
// for i = 1 to sold do
17859: LD_ADDR_VAR 0 1
17863: PUSH
17864: DOUBLE
17865: LD_INT 1
17867: DEC
17868: ST_TO_ADDR
17869: LD_VAR 0 3
17873: PUSH
17874: FOR_TO
17875: IFFALSE 18014
// if not IsInUnit ( sold [ i ] ) and not HasTask ( sold [ i ] ) and GetTag ( sold [ i ] ) = 0 and FilterAllUnits ( [ [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) = 0 then
17877: LD_VAR 0 3
17881: PUSH
17882: LD_VAR 0 1
17886: ARRAY
17887: PPUSH
17888: CALL_OW 310
17892: NOT
17893: PUSH
17894: LD_VAR 0 3
17898: PUSH
17899: LD_VAR 0 1
17903: ARRAY
17904: PPUSH
17905: CALL_OW 314
17909: NOT
17910: AND
17911: PUSH
17912: LD_VAR 0 3
17916: PUSH
17917: LD_VAR 0 1
17921: ARRAY
17922: PPUSH
17923: CALL_OW 110
17927: PUSH
17928: LD_INT 0
17930: EQUAL
17931: AND
17932: PUSH
17933: LD_INT 22
17935: PUSH
17936: LD_VAR 0 10
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: PUSH
17945: LD_INT 30
17947: PUSH
17948: LD_INT 32
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: PUSH
17955: LD_INT 58
17957: PUSH
17958: EMPTY
17959: LIST
17960: PUSH
17961: EMPTY
17962: LIST
17963: LIST
17964: LIST
17965: PUSH
17966: EMPTY
17967: LIST
17968: PPUSH
17969: CALL_OW 69
17973: PUSH
17974: LD_INT 0
17976: EQUAL
17977: AND
17978: IFFALSE 18012
// ComEnterUnit ( sold [ i ] , GetBuilding ( side , b_barracks ) [ 1 ] ) ;
17980: LD_VAR 0 3
17984: PUSH
17985: LD_VAR 0 1
17989: ARRAY
17990: PPUSH
17991: LD_VAR 0 10
17995: PPUSH
17996: LD_INT 5
17998: PPUSH
17999: CALL 1265 0 2
18003: PUSH
18004: LD_INT 1
18006: ARRAY
18007: PPUSH
18008: CALL_OW 120
18012: GO 17874
18014: POP
18015: POP
// end ; if tick = 105 then
18016: LD_OWVAR 1
18020: PUSH
18021: LD_INT 105
18023: EQUAL
18024: IFFALSE 18070
// begin ScoutArea ( scout_near_base [ 1 ] , scout_near_base [ 2 ] ) ;
18026: LD_VAR 0 63
18030: PUSH
18031: LD_INT 1
18033: ARRAY
18034: PPUSH
18035: LD_VAR 0 63
18039: PUSH
18040: LD_INT 2
18042: ARRAY
18043: PPUSH
18044: CALL 13535 0 2
// ScoutArea ( scout_near_base [ 3 ] , scout_near_base [ 4 ] ) ;
18048: LD_VAR 0 63
18052: PUSH
18053: LD_INT 3
18055: ARRAY
18056: PPUSH
18057: LD_VAR 0 63
18061: PUSH
18062: LD_INT 4
18064: ARRAY
18065: PPUSH
18066: CALL 13535 0 2
// end ; ScanVehicleStatus ( side , repair_xy [ 1 ] , repair_xy [ 2 ] ) ;
18070: LD_VAR 0 10
18074: PPUSH
18075: LD_VAR 0 64
18079: PUSH
18080: LD_INT 1
18082: ARRAY
18083: PPUSH
18084: LD_VAR 0 64
18088: PUSH
18089: LD_INT 2
18091: ARRAY
18092: PPUSH
18093: CALL 13819 0 3
// if Tag_List ( vehicles , 84 ) >= NumAtt ( attack_info [ 1 ] , attack_info [ 2 ] , attack_info [ 3 ] , attack_info [ 4 ] ) then
18097: LD_VAR 0 12
18101: PPUSH
18102: LD_INT 84
18104: PPUSH
18105: CALL 9970 0 2
18109: PUSH
18110: LD_VAR 0 66
18114: PUSH
18115: LD_INT 1
18117: ARRAY
18118: PPUSH
18119: LD_VAR 0 66
18123: PUSH
18124: LD_INT 2
18126: ARRAY
18127: PPUSH
18128: LD_VAR 0 66
18132: PUSH
18133: LD_INT 3
18135: ARRAY
18136: PPUSH
18137: LD_VAR 0 66
18141: PUSH
18142: LD_INT 4
18144: ARRAY
18145: PPUSH
18146: CALL 16084 0 4
18150: GREATEREQUAL
18151: IFFALSE 18259
// begin en := SelectEnemy ( side , enemy_list ) ;
18153: LD_ADDR_VAR 0 14
18157: PUSH
18158: LD_VAR 0 10
18162: PPUSH
18163: LD_VAR 0 42
18167: PPUSH
18168: CALL 16000 0 2
18172: ST_TO_ADDR
// tmp := Tag_List ( vehicles , 84 ) ;
18173: LD_ADDR_VAR 0 13
18177: PUSH
18178: LD_VAR 0 12
18182: PPUSH
18183: LD_INT 84
18185: PPUSH
18186: CALL 9970 0 2
18190: ST_TO_ADDR
// for i = 1 to tmp do
18191: LD_ADDR_VAR 0 1
18195: PUSH
18196: DOUBLE
18197: LD_INT 1
18199: DEC
18200: ST_TO_ADDR
18201: LD_VAR 0 13
18205: PUSH
18206: FOR_TO
18207: IFFALSE 18257
// Attack ( tmp [ i ] , enemy_list [ en ] , enemy_xy [ en ] , attack_info [ 5 ] ) ;
18209: LD_VAR 0 13
18213: PUSH
18214: LD_VAR 0 1
18218: ARRAY
18219: PPUSH
18220: LD_VAR 0 42
18224: PUSH
18225: LD_VAR 0 14
18229: ARRAY
18230: PPUSH
18231: LD_VAR 0 15
18235: PUSH
18236: LD_VAR 0 14
18240: ARRAY
18241: PPUSH
18242: LD_VAR 0 66
18246: PUSH
18247: LD_INT 5
18249: ARRAY
18250: PPUSH
18251: CALL 14958 0 4
18255: GO 18206
18257: POP
18258: POP
// end ; if eng and base_status = false then
18259: LD_VAR 0 4
18263: PUSH
18264: LD_VAR 0 61
18268: PUSH
18269: LD_INT 0
18271: EQUAL
18272: AND
18273: IFFALSE 22899
// begin VehicleMove ( side , parking_area , 83 , back , [ ] ) ;
18275: LD_VAR 0 10
18279: PPUSH
18280: LD_VAR 0 55
18284: PPUSH
18285: LD_INT 83
18287: PPUSH
18288: LD_STRING back
18290: PPUSH
18291: EMPTY
18292: PPUSH
18293: CALL 14244 0 5
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
18297: LD_INT 22
18299: PUSH
18300: LD_VAR 0 10
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: PUSH
18309: LD_INT 21
18311: PUSH
18312: LD_INT 1
18314: PUSH
18315: EMPTY
18316: LIST
18317: LIST
18318: PUSH
18319: LD_INT 3
18321: PUSH
18322: LD_INT 24
18324: PUSH
18325: LD_INT 1000
18327: PUSH
18328: EMPTY
18329: LIST
18330: LIST
18331: PUSH
18332: EMPTY
18333: LIST
18334: LIST
18335: PUSH
18336: EMPTY
18337: LIST
18338: LIST
18339: LIST
18340: PPUSH
18341: CALL_OW 69
18345: IFFALSE 18359
// HealPersonel ( side , 99 ) ;
18347: LD_VAR 0 10
18351: PPUSH
18352: LD_INT 99
18354: PPUSH
18355: CALL 12655 0 2
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
18359: LD_INT 22
18361: PUSH
18362: LD_VAR 0 10
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PUSH
18371: LD_INT 21
18373: PUSH
18374: LD_INT 3
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: PUSH
18381: LD_INT 3
18383: PUSH
18384: LD_INT 24
18386: PUSH
18387: LD_INT 1000
18389: PUSH
18390: EMPTY
18391: LIST
18392: LIST
18393: PUSH
18394: EMPTY
18395: LIST
18396: LIST
18397: PUSH
18398: EMPTY
18399: LIST
18400: LIST
18401: LIST
18402: PPUSH
18403: CALL_OW 69
18407: IFFALSE 18443
// RepairBase ( side , enemy_list , xy_back [ 1 ] , xy_back [ 2 ] ) else
18409: LD_VAR 0 10
18413: PPUSH
18414: LD_VAR 0 42
18418: PPUSH
18419: LD_VAR 0 41
18423: PUSH
18424: LD_INT 1
18426: ARRAY
18427: PPUSH
18428: LD_VAR 0 41
18432: PUSH
18433: LD_INT 2
18435: ARRAY
18436: PPUSH
18437: CALL 11363 0 4
18441: GO 22899
// if NeedBase ( side ) then
18443: LD_VAR 0 10
18447: PPUSH
18448: CALL 1120 0 1
18452: IFFALSE 18492
// ComBuildDepot ( eng , depot_xy [ 1 ] , depot_xy [ 2 ] , depot_xy [ 3 ] ) else
18454: LD_VAR 0 4
18458: PPUSH
18459: LD_VAR 0 16
18463: PUSH
18464: LD_INT 1
18466: ARRAY
18467: PPUSH
18468: LD_VAR 0 16
18472: PUSH
18473: LD_INT 2
18475: ARRAY
18476: PPUSH
18477: LD_VAR 0 16
18481: PUSH
18482: LD_INT 3
18484: ARRAY
18485: PPUSH
18486: CALL 2033 0 4
18490: GO 22899
// begin FinishAllBuilds ( side ) ;
18492: LD_VAR 0 10
18496: PPUSH
18497: CALL 12861 0 1
// if second_base_allow and tick >= build_second_base_after [ 1 ] and GetTech ( build_second_base_after [ 2 ] , side ) = state_researched and HexInfo ( second_base_xy [ 1 ] , second_base_xy [ 2 ] ) = 0 then
18501: LD_VAR 0 56
18505: PUSH
18506: LD_OWVAR 1
18510: PUSH
18511: LD_VAR 0 59
18515: PUSH
18516: LD_INT 1
18518: ARRAY
18519: GREATEREQUAL
18520: AND
18521: PUSH
18522: LD_VAR 0 59
18526: PUSH
18527: LD_INT 2
18529: ARRAY
18530: PPUSH
18531: LD_VAR 0 10
18535: PPUSH
18536: CALL_OW 321
18540: PUSH
18541: LD_INT 2
18543: EQUAL
18544: AND
18545: PUSH
18546: LD_VAR 0 57
18550: PUSH
18551: LD_INT 1
18553: ARRAY
18554: PPUSH
18555: LD_VAR 0 57
18559: PUSH
18560: LD_INT 2
18562: ARRAY
18563: PPUSH
18564: CALL_OW 428
18568: PUSH
18569: LD_INT 0
18571: EQUAL
18572: AND
18573: IFFALSE 18611
// ComBuildDepot ( eng , second_base_xy [ 1 ] , second_base_xy [ 2 ] , second_base_xy [ 3 ] ) ;
18575: LD_VAR 0 4
18579: PPUSH
18580: LD_VAR 0 57
18584: PUSH
18585: LD_INT 1
18587: ARRAY
18588: PPUSH
18589: LD_VAR 0 57
18593: PUSH
18594: LD_INT 2
18596: ARRAY
18597: PPUSH
18598: LD_VAR 0 57
18602: PUSH
18603: LD_INT 3
18605: ARRAY
18606: PPUSH
18607: CALL 2033 0 4
// if second_base_allow and GetBType ( HexInfo ( second_base_xy [ 1 ] , second_base_xy [ 2 ] ) ) = b_depot and transport_from_second_base [ 1 ] then
18611: LD_VAR 0 56
18615: PUSH
18616: LD_VAR 0 57
18620: PUSH
18621: LD_INT 1
18623: ARRAY
18624: PPUSH
18625: LD_VAR 0 57
18629: PUSH
18630: LD_INT 2
18632: ARRAY
18633: PPUSH
18634: CALL_OW 428
18638: PPUSH
18639: CALL_OW 266
18643: PUSH
18644: LD_INT 0
18646: EQUAL
18647: AND
18648: PUSH
18649: LD_VAR 0 58
18653: PUSH
18654: LD_INT 1
18656: ARRAY
18657: AND
18658: IFFALSE 18791
// begin for i = 1 to 3 do
18660: LD_ADDR_VAR 0 1
18664: PUSH
18665: DOUBLE
18666: LD_INT 1
18668: DEC
18669: ST_TO_ADDR
18670: LD_INT 3
18672: PUSH
18673: FOR_TO
18674: IFFALSE 18789
// if GetBaseSource ( HexInfo ( second_base_xy [ 1 ] , second_base_xy [ 2 ] ) ) [ i ] > transport_from_second_base [ 2 ] then
18676: LD_VAR 0 57
18680: PUSH
18681: LD_INT 1
18683: ARRAY
18684: PPUSH
18685: LD_VAR 0 57
18689: PUSH
18690: LD_INT 2
18692: ARRAY
18693: PPUSH
18694: CALL_OW 428
18698: PPUSH
18699: CALL 866 0 1
18703: PUSH
18704: LD_VAR 0 1
18708: ARRAY
18709: PUSH
18710: LD_VAR 0 58
18714: PUSH
18715: LD_INT 2
18717: ARRAY
18718: GREATER
18719: IFFALSE 18787
// begin Transport ( eng [ 1 ] , HexInfo ( second_base_xy [ 1 ] , second_base_xy [ 2 ] ) , HexInfo ( depot_xy [ 1 ] , depot_xy [ 2 ] ) , i ) ;
18721: LD_VAR 0 4
18725: PUSH
18726: LD_INT 1
18728: ARRAY
18729: PPUSH
18730: LD_VAR 0 57
18734: PUSH
18735: LD_INT 1
18737: ARRAY
18738: PPUSH
18739: LD_VAR 0 57
18743: PUSH
18744: LD_INT 2
18746: ARRAY
18747: PPUSH
18748: CALL_OW 428
18752: PPUSH
18753: LD_VAR 0 16
18757: PUSH
18758: LD_INT 1
18760: ARRAY
18761: PPUSH
18762: LD_VAR 0 16
18766: PUSH
18767: LD_INT 2
18769: ARRAY
18770: PPUSH
18771: CALL_OW 428
18775: PPUSH
18776: LD_VAR 0 1
18780: PPUSH
18781: CALL 13743 0 4
// break ;
18785: GO 18789
// end ;
18787: GO 18673
18789: POP
18790: POP
// end ; if NeedBuilding ( side , GetBuilding ( side , b_depot ) ) then
18791: LD_VAR 0 10
18795: PPUSH
18796: LD_VAR 0 10
18800: PPUSH
18801: LD_INT 0
18803: PPUSH
18804: CALL 1265 0 2
18808: PPUSH
18809: CALL 1042 0 2
18813: IFFALSE 18841
// ComBuildWarehouse ( eng , GetBuilding ( side , b_depot ) [ 1 ] ) ;
18815: LD_VAR 0 4
18819: PPUSH
18820: LD_VAR 0 10
18824: PPUSH
18825: LD_INT 0
18827: PPUSH
18828: CALL 1265 0 2
18832: PUSH
18833: LD_INT 1
18835: ARRAY
18836: PPUSH
18837: CALL 2131 0 2
// ComBuildLabList ( eng , [ [ lab_xy [ 1 ] , lab_xy [ 2 ] , lab_xy [ 3 ] , lab_kind [ 1 ] , lab_kind [ 2 ] ] , [ lab_xy [ 4 ] , lab_xy [ 5 ] , lab_xy [ 6 ] , lab_kind [ 3 ] , lab_kind [ 4 ] ] ] ) ;
18841: LD_VAR 0 4
18845: PPUSH
18846: LD_VAR 0 17
18850: PUSH
18851: LD_INT 1
18853: ARRAY
18854: PUSH
18855: LD_VAR 0 17
18859: PUSH
18860: LD_INT 2
18862: ARRAY
18863: PUSH
18864: LD_VAR 0 17
18868: PUSH
18869: LD_INT 3
18871: ARRAY
18872: PUSH
18873: LD_VAR 0 20
18877: PUSH
18878: LD_INT 1
18880: ARRAY
18881: PUSH
18882: LD_VAR 0 20
18886: PUSH
18887: LD_INT 2
18889: ARRAY
18890: PUSH
18891: EMPTY
18892: LIST
18893: LIST
18894: LIST
18895: LIST
18896: LIST
18897: PUSH
18898: LD_VAR 0 17
18902: PUSH
18903: LD_INT 4
18905: ARRAY
18906: PUSH
18907: LD_VAR 0 17
18911: PUSH
18912: LD_INT 5
18914: ARRAY
18915: PUSH
18916: LD_VAR 0 17
18920: PUSH
18921: LD_INT 6
18923: ARRAY
18924: PUSH
18925: LD_VAR 0 20
18929: PUSH
18930: LD_INT 3
18932: ARRAY
18933: PUSH
18934: LD_VAR 0 20
18938: PUSH
18939: LD_INT 4
18941: ARRAY
18942: PUSH
18943: EMPTY
18944: LIST
18945: LIST
18946: LIST
18947: LIST
18948: LIST
18949: PUSH
18950: EMPTY
18951: LIST
18952: LIST
18953: PPUSH
18954: CALL 3634 0 2
// if GetBuilding ( side , b_lab_full ) and sci then
18958: LD_VAR 0 10
18962: PPUSH
18963: LD_INT 8
18965: PPUSH
18966: CALL 1265 0 2
18970: PUSH
18971: LD_VAR 0 6
18975: AND
18976: IFFALSE 19326
// begin for p = 1 to GetLabs ( side ) do
18978: LD_ADDR_VAR 0 2
18982: PUSH
18983: DOUBLE
18984: LD_INT 1
18986: DEC
18987: ST_TO_ADDR
18988: LD_VAR 0 10
18992: PPUSH
18993: CALL 1416 0 1
18997: PUSH
18998: FOR_TO
18999: IFFALSE 19078
// if BuildingStatus ( GetLabs ( side ) [ p ] ) = bs_working or BuildingStatus ( GetLabs ( side ) [ p ] ) = bs_need_people then
19001: LD_VAR 0 10
19005: PPUSH
19006: CALL 1416 0 1
19010: PUSH
19011: LD_VAR 0 2
19015: ARRAY
19016: PPUSH
19017: CALL_OW 461
19021: PUSH
19022: LD_INT 3
19024: EQUAL
19025: PUSH
19026: LD_VAR 0 10
19030: PPUSH
19031: CALL 1416 0 1
19035: PUSH
19036: LD_VAR 0 2
19040: ARRAY
19041: PPUSH
19042: CALL_OW 461
19046: PUSH
19047: LD_INT 6
19049: EQUAL
19050: OR
19051: IFFALSE 19076
// begin lab := GetLabs ( side ) [ p ] ;
19053: LD_ADDR_VAR 0 60
19057: PUSH
19058: LD_VAR 0 10
19062: PPUSH
19063: CALL 1416 0 1
19067: PUSH
19068: LD_VAR 0 2
19072: ARRAY
19073: ST_TO_ADDR
// break ;
19074: GO 19078
// end ;
19076: GO 18998
19078: POP
19079: POP
// if not lab then
19080: LD_VAR 0 60
19084: NOT
19085: IFFALSE 19106
// lab := GetLabs ( side ) [ 1 ] ;
19087: LD_ADDR_VAR 0 60
19091: PUSH
19092: LD_VAR 0 10
19096: PPUSH
19097: CALL 1416 0 1
19101: PUSH
19102: LD_INT 1
19104: ARRAY
19105: ST_TO_ADDR
// if Tag_List ( sold ^ eng ^ mech ^ sci , 99 ) = 0 then
19106: LD_VAR 0 3
19110: PUSH
19111: LD_VAR 0 4
19115: ADD
19116: PUSH
19117: LD_VAR 0 5
19121: ADD
19122: PUSH
19123: LD_VAR 0 6
19127: ADD
19128: PPUSH
19129: LD_INT 99
19131: PPUSH
19132: CALL 9970 0 2
19136: PUSH
19137: LD_INT 0
19139: EQUAL
19140: IFFALSE 19296
// for i = 1 to sci do
19142: LD_ADDR_VAR 0 1
19146: PUSH
19147: DOUBLE
19148: LD_INT 1
19150: DEC
19151: ST_TO_ADDR
19152: LD_VAR 0 6
19156: PUSH
19157: FOR_TO
19158: IFFALSE 19294
// if not IsInUnit ( sci [ i ] ) = lab and not HasTask ( sci [ i ] ) and GetTag ( sci [ i ] ) = 0 and BuildingStatus ( lab ) <> bs_build then
19160: LD_VAR 0 6
19164: PUSH
19165: LD_VAR 0 1
19169: ARRAY
19170: PPUSH
19171: CALL_OW 310
19175: PUSH
19176: LD_VAR 0 60
19180: EQUAL
19181: NOT
19182: PUSH
19183: LD_VAR 0 6
19187: PUSH
19188: LD_VAR 0 1
19192: ARRAY
19193: PPUSH
19194: CALL_OW 314
19198: NOT
19199: AND
19200: PUSH
19201: LD_VAR 0 6
19205: PUSH
19206: LD_VAR 0 1
19210: ARRAY
19211: PPUSH
19212: CALL_OW 110
19216: PUSH
19217: LD_INT 0
19219: EQUAL
19220: AND
19221: PUSH
19222: LD_VAR 0 60
19226: PPUSH
19227: CALL_OW 461
19231: PUSH
19232: LD_INT 1
19234: NONEQUAL
19235: AND
19236: IFFALSE 19292
// if IsInUnit ( sci [ i ] ) then
19238: LD_VAR 0 6
19242: PUSH
19243: LD_VAR 0 1
19247: ARRAY
19248: PPUSH
19249: CALL_OW 310
19253: IFFALSE 19272
// ComExitBuilding ( sci [ i ] ) else
19255: LD_VAR 0 6
19259: PUSH
19260: LD_VAR 0 1
19264: ARRAY
19265: PPUSH
19266: CALL_OW 122
19270: GO 19292
// ComEnterUnit ( sci [ i ] , lab ) ;
19272: LD_VAR 0 6
19276: PUSH
19277: LD_VAR 0 1
19281: ARRAY
19282: PPUSH
19283: LD_VAR 0 60
19287: PPUSH
19288: CALL_OW 120
19292: GO 19157
19294: POP
19295: POP
// if not BuildingStatus ( lab ) = bs_build then
19296: LD_VAR 0 60
19300: PPUSH
19301: CALL_OW 461
19305: PUSH
19306: LD_INT 1
19308: EQUAL
19309: NOT
19310: IFFALSE 19326
// ResearchTechList ( side , tech_list ) ;
19312: LD_VAR 0 10
19316: PPUSH
19317: LD_VAR 0 24
19321: PPUSH
19322: CALL 1632 0 2
// end ; BuildFactory ( eng , fac_xy [ 1 ] , fac_xy [ 2 ] , fac_xy [ 3 ] , fac_ext ) ;
19326: LD_VAR 0 4
19330: PPUSH
19331: LD_VAR 0 18
19335: PUSH
19336: LD_INT 1
19338: ARRAY
19339: PPUSH
19340: LD_VAR 0 18
19344: PUSH
19345: LD_INT 2
19347: ARRAY
19348: PPUSH
19349: LD_VAR 0 18
19353: PUSH
19354: LD_INT 3
19356: ARRAY
19357: PPUSH
19358: LD_VAR 0 21
19362: PPUSH
19363: CALL 6442 0 5
// if mech and GetBuilding ( side , b_factory ) then
19367: LD_VAR 0 5
19371: PUSH
19372: LD_VAR 0 10
19376: PPUSH
19377: LD_INT 3
19379: PPUSH
19380: CALL 1265 0 2
19384: AND
19385: IFFALSE 21310
// begin for i = 1 to mech do
19387: LD_ADDR_VAR 0 1
19391: PUSH
19392: DOUBLE
19393: LD_INT 1
19395: DEC
19396: ST_TO_ADDR
19397: LD_VAR 0 5
19401: PUSH
19402: FOR_TO
19403: IFFALSE 19584
// if not IsInUnit ( mech [ i ] ) and not HasTask ( mech [ i ] ) and GetTag ( mech [ i ] ) = 0 and FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 450 ] ] , [ f_distxy , repair_xy [ 1 ] , repair_xy [ 2 ] , 10 ] ] ] ) = 0 then
19405: LD_VAR 0 5
19409: PUSH
19410: LD_VAR 0 1
19414: ARRAY
19415: PPUSH
19416: CALL_OW 310
19420: NOT
19421: PUSH
19422: LD_VAR 0 5
19426: PUSH
19427: LD_VAR 0 1
19431: ARRAY
19432: PPUSH
19433: CALL_OW 314
19437: NOT
19438: AND
19439: PUSH
19440: LD_VAR 0 5
19444: PUSH
19445: LD_VAR 0 1
19449: ARRAY
19450: PPUSH
19451: CALL_OW 110
19455: PUSH
19456: LD_INT 0
19458: EQUAL
19459: AND
19460: PUSH
19461: LD_INT 22
19463: PUSH
19464: LD_VAR 0 10
19468: PUSH
19469: EMPTY
19470: LIST
19471: LIST
19472: PUSH
19473: LD_INT 21
19475: PUSH
19476: LD_INT 2
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: PUSH
19483: LD_INT 3
19485: PUSH
19486: LD_INT 24
19488: PUSH
19489: LD_INT 450
19491: PUSH
19492: EMPTY
19493: LIST
19494: LIST
19495: PUSH
19496: EMPTY
19497: LIST
19498: LIST
19499: PUSH
19500: LD_INT 92
19502: PUSH
19503: LD_VAR 0 64
19507: PUSH
19508: LD_INT 1
19510: ARRAY
19511: PUSH
19512: LD_VAR 0 64
19516: PUSH
19517: LD_INT 2
19519: ARRAY
19520: PUSH
19521: LD_INT 10
19523: PUSH
19524: EMPTY
19525: LIST
19526: LIST
19527: LIST
19528: LIST
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: LIST
19534: LIST
19535: PUSH
19536: EMPTY
19537: LIST
19538: PPUSH
19539: CALL_OW 69
19543: PUSH
19544: LD_INT 0
19546: EQUAL
19547: AND
19548: IFFALSE 19582
// ComEnterUnit ( mech [ i ] , GetBuilding ( side , b_factory ) [ 1 ] ) ;
19550: LD_VAR 0 5
19554: PUSH
19555: LD_VAR 0 1
19559: ARRAY
19560: PPUSH
19561: LD_VAR 0 10
19565: PPUSH
19566: LD_INT 3
19568: PPUSH
19569: CALL 1265 0 2
19573: PUSH
19574: LD_INT 1
19576: ARRAY
19577: PPUSH
19578: CALL_OW 120
19582: GO 19402
19584: POP
19585: POP
// CheckTowersStatus ( eng , turret_xy ) ;
19586: LD_VAR 0 4
19590: PPUSH
19591: LD_VAR 0 19
19595: PPUSH
19596: CALL 2673 0 2
// turret_weapon := AvailableWeaponList ( GetBuilding ( side , b_factory ) [ 1 ] ) diff not_turret_weapon ;
19600: LD_ADDR_VAR 0 32
19604: PUSH
19605: LD_VAR 0 10
19609: PPUSH
19610: LD_INT 3
19612: PPUSH
19613: CALL 1265 0 2
19617: PUSH
19618: LD_INT 1
19620: ARRAY
19621: PPUSH
19622: CALL_OW 478
19626: PUSH
19627: LD_VAR 0 33
19631: DIFF
19632: ST_TO_ADDR
// if ( GetBuilding ( side , b_bunker ) > 0 or GetBuilding ( side , b_turret ) > 0 ) and turret_weapon > 1 then
19633: LD_VAR 0 10
19637: PPUSH
19638: LD_INT 32
19640: PPUSH
19641: CALL 1265 0 2
19645: PUSH
19646: LD_INT 0
19648: GREATER
19649: PUSH
19650: LD_VAR 0 10
19654: PPUSH
19655: LD_INT 33
19657: PPUSH
19658: CALL 1265 0 2
19662: PUSH
19663: LD_INT 0
19665: GREATER
19666: OR
19667: PUSH
19668: LD_VAR 0 32
19672: PUSH
19673: LD_INT 1
19675: GREATER
19676: AND
19677: IFFALSE 19693
// CheckWeaponOnTowers ( side , turret_weapon ) ;
19679: LD_VAR 0 10
19683: PPUSH
19684: LD_VAR 0 32
19688: PPUSH
19689: CALL 2964 0 2
// if GetVehicle ( side , cargo_chassis , cargo_type [ 1 ] ) = 0 and ( GetBuilding ( side , b_ext_noncombat ) or GetBuilding ( side , b_ext_stitch ) ) and cargo_allow then
19693: LD_VAR 0 10
19697: PPUSH
19698: LD_VAR 0 36
19702: PPUSH
19703: LD_VAR 0 37
19707: PUSH
19708: LD_INT 1
19710: ARRAY
19711: PPUSH
19712: CALL 3112 0 3
19716: PUSH
19717: LD_INT 0
19719: EQUAL
19720: PUSH
19721: LD_VAR 0 10
19725: PPUSH
19726: LD_INT 19
19728: PPUSH
19729: CALL 1265 0 2
19733: PUSH
19734: LD_VAR 0 10
19738: PPUSH
19739: LD_INT 23
19741: PPUSH
19742: CALL 1265 0 2
19746: OR
19747: AND
19748: PUSH
19749: LD_VAR 0 35
19753: AND
19754: IFFALSE 19781
// IntConstruct ( side , cargo_chassis , engine_combustion , control_manual , cargo_type ) ;
19756: LD_VAR 0 10
19760: PPUSH
19761: LD_VAR 0 36
19765: PPUSH
19766: LD_INT 1
19768: PPUSH
19769: LD_INT 1
19771: PPUSH
19772: LD_VAR 0 37
19776: PPUSH
19777: CALL 13272 0 5
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_control , control_manual ] , [ f_weapon , cargo_type [ 1 ] ] ] ] ) = 1 and modernize_cargo_allow and ( ( GetBuilding ( side , b_ext_radar ) and ( GetBuilding ( side , b_control_tower ) or FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ) ) or GetBuilding ( side , b_ext_computer ) ) then
19781: LD_INT 22
19783: PUSH
19784: LD_VAR 0 10
19788: PUSH
19789: EMPTY
19790: LIST
19791: LIST
19792: PUSH
19793: LD_INT 33
19795: PUSH
19796: LD_INT 1
19798: PUSH
19799: EMPTY
19800: LIST
19801: LIST
19802: PUSH
19803: LD_INT 34
19805: PUSH
19806: LD_VAR 0 37
19810: PUSH
19811: LD_INT 1
19813: ARRAY
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: EMPTY
19820: LIST
19821: LIST
19822: LIST
19823: PUSH
19824: EMPTY
19825: LIST
19826: PPUSH
19827: CALL_OW 69
19831: PUSH
19832: LD_INT 1
19834: EQUAL
19835: PUSH
19836: LD_VAR 0 43
19840: AND
19841: PUSH
19842: LD_VAR 0 10
19846: PPUSH
19847: LD_INT 20
19849: PPUSH
19850: CALL 1265 0 2
19854: PUSH
19855: LD_VAR 0 10
19859: PPUSH
19860: LD_INT 36
19862: PPUSH
19863: CALL 1265 0 2
19867: PUSH
19868: LD_INT 22
19870: PUSH
19871: LD_VAR 0 10
19875: PUSH
19876: EMPTY
19877: LIST
19878: LIST
19879: PUSH
19880: LD_INT 34
19882: PUSH
19883: LD_INT 31
19885: PUSH
19886: EMPTY
19887: LIST
19888: LIST
19889: PUSH
19890: EMPTY
19891: LIST
19892: LIST
19893: PPUSH
19894: CALL_OW 69
19898: OR
19899: AND
19900: PUSH
19901: LD_VAR 0 10
19905: PPUSH
19906: LD_INT 24
19908: PPUSH
19909: CALL 1265 0 2
19913: OR
19914: AND
19915: IFFALSE 20001
// begin SetTag ( GetVehicle ( side , cargo_chassis , cargo_type [ 1 ] ) [ 1 ] , 51 ) ;
19917: LD_VAR 0 10
19921: PPUSH
19922: LD_VAR 0 36
19926: PPUSH
19927: LD_VAR 0 37
19931: PUSH
19932: LD_INT 1
19934: ARRAY
19935: PPUSH
19936: CALL 3112 0 3
19940: PUSH
19941: LD_INT 1
19943: ARRAY
19944: PPUSH
19945: LD_INT 51
19947: PPUSH
19948: CALL_OW 109
// ComRecycle ( GetVehicle ( side , cargo_chassis , cargo_type [ 1 ] ) [ 1 ] , GetBuilding ( side , b_factory ) [ 1 ] ) ;
19952: LD_VAR 0 10
19956: PPUSH
19957: LD_VAR 0 36
19961: PPUSH
19962: LD_VAR 0 37
19966: PUSH
19967: LD_INT 1
19969: ARRAY
19970: PPUSH
19971: CALL 3112 0 3
19975: PUSH
19976: LD_INT 1
19978: ARRAY
19979: PPUSH
19980: LD_VAR 0 10
19984: PPUSH
19985: LD_INT 3
19987: PPUSH
19988: CALL 1265 0 2
19992: PUSH
19993: LD_INT 1
19995: ARRAY
19996: PPUSH
19997: CALL_OW 168
// end ; if GetVehicle ( side , crane_chassis , crane_type [ 1 ] ) < crane_num and ( GetBuilding ( side , b_ext_noncombat ) or GetBuilding ( side , b_ext_stitch ) ) and crane_allow then
20001: LD_VAR 0 10
20005: PPUSH
20006: LD_VAR 0 47
20010: PPUSH
20011: LD_VAR 0 45
20015: PUSH
20016: LD_INT 1
20018: ARRAY
20019: PPUSH
20020: CALL 3112 0 3
20024: PUSH
20025: LD_VAR 0 48
20029: LESS
20030: PUSH
20031: LD_VAR 0 10
20035: PPUSH
20036: LD_INT 19
20038: PPUSH
20039: CALL 1265 0 2
20043: PUSH
20044: LD_VAR 0 10
20048: PPUSH
20049: LD_INT 23
20051: PPUSH
20052: CALL 1265 0 2
20056: OR
20057: AND
20058: PUSH
20059: LD_VAR 0 44
20063: AND
20064: IFFALSE 20093
// IntConstruct ( side , crane_chassis , crane_engine , control_manual , crane_type ) ;
20066: LD_VAR 0 10
20070: PPUSH
20071: LD_VAR 0 47
20075: PPUSH
20076: LD_VAR 0 46
20080: PPUSH
20081: LD_INT 1
20083: PPUSH
20084: LD_VAR 0 45
20088: PPUSH
20089: CALL 13272 0 5
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_control , control_manual ] , [ f_weapon , crane_type [ 1 ] ] ] ] ) and modernize_crane_allow and ( ( GetBuilding ( side , b_ext_radar ) and ( GetBuilding ( side , b_control_tower ) or FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ) ) or GetBuilding ( side , b_ext_computer ) ) then
20093: LD_INT 22
20095: PUSH
20096: LD_VAR 0 10
20100: PUSH
20101: EMPTY
20102: LIST
20103: LIST
20104: PUSH
20105: LD_INT 33
20107: PUSH
20108: LD_INT 1
20110: PUSH
20111: EMPTY
20112: LIST
20113: LIST
20114: PUSH
20115: LD_INT 34
20117: PUSH
20118: LD_VAR 0 45
20122: PUSH
20123: LD_INT 1
20125: ARRAY
20126: PUSH
20127: EMPTY
20128: LIST
20129: LIST
20130: PUSH
20131: EMPTY
20132: LIST
20133: LIST
20134: LIST
20135: PUSH
20136: EMPTY
20137: LIST
20138: PPUSH
20139: CALL_OW 69
20143: PUSH
20144: LD_VAR 0 49
20148: AND
20149: PUSH
20150: LD_VAR 0 10
20154: PPUSH
20155: LD_INT 20
20157: PPUSH
20158: CALL 1265 0 2
20162: PUSH
20163: LD_VAR 0 10
20167: PPUSH
20168: LD_INT 36
20170: PPUSH
20171: CALL 1265 0 2
20175: PUSH
20176: LD_INT 22
20178: PUSH
20179: LD_VAR 0 10
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: PUSH
20188: LD_INT 34
20190: PUSH
20191: LD_INT 31
20193: PUSH
20194: EMPTY
20195: LIST
20196: LIST
20197: PUSH
20198: EMPTY
20199: LIST
20200: LIST
20201: PPUSH
20202: CALL_OW 69
20206: OR
20207: AND
20208: PUSH
20209: LD_VAR 0 10
20213: PPUSH
20214: LD_INT 24
20216: PPUSH
20217: CALL 1265 0 2
20221: OR
20222: AND
20223: IFFALSE 20309
// begin SetTag ( GetVehicle ( side , crane_chassis , crane_type [ 1 ] ) [ 1 ] , 51 ) ;
20225: LD_VAR 0 10
20229: PPUSH
20230: LD_VAR 0 47
20234: PPUSH
20235: LD_VAR 0 45
20239: PUSH
20240: LD_INT 1
20242: ARRAY
20243: PPUSH
20244: CALL 3112 0 3
20248: PUSH
20249: LD_INT 1
20251: ARRAY
20252: PPUSH
20253: LD_INT 51
20255: PPUSH
20256: CALL_OW 109
// ComRecycle ( GetVehicle ( side , crane_chassis , crane_type [ 1 ] ) [ 1 ] , GetBuilding ( side , b_factory ) [ 1 ] ) ;
20260: LD_VAR 0 10
20264: PPUSH
20265: LD_VAR 0 47
20269: PPUSH
20270: LD_VAR 0 45
20274: PUSH
20275: LD_INT 1
20277: ARRAY
20278: PPUSH
20279: CALL 3112 0 3
20283: PUSH
20284: LD_INT 1
20286: ARRAY
20287: PPUSH
20288: LD_VAR 0 10
20292: PPUSH
20293: LD_INT 3
20295: PPUSH
20296: CALL 1265 0 2
20300: PUSH
20301: LD_INT 1
20303: ARRAY
20304: PPUSH
20305: CALL_OW 168
// end ; if GetVehicle ( side , bulldozer_chassis , bulldozer_type [ 1 ] ) = 0 and bulldozer_allow and ListEnvironmentArea ( tree_area ) > 0 then
20309: LD_VAR 0 10
20313: PPUSH
20314: LD_VAR 0 51
20318: PPUSH
20319: LD_VAR 0 53
20323: PUSH
20324: LD_INT 1
20326: ARRAY
20327: PPUSH
20328: CALL 3112 0 3
20332: PUSH
20333: LD_INT 0
20335: EQUAL
20336: PUSH
20337: LD_VAR 0 50
20341: AND
20342: PUSH
20343: LD_VAR 0 54
20347: PPUSH
20348: CALL_OW 353
20352: PUSH
20353: LD_INT 0
20355: GREATER
20356: AND
20357: IFFALSE 20388
// IntConstruct ( side , bulldozer_chassis , bulldozer_engine , control_manual , bulldozer_type ) else
20359: LD_VAR 0 10
20363: PPUSH
20364: LD_VAR 0 51
20368: PPUSH
20369: LD_VAR 0 52
20373: PPUSH
20374: LD_INT 1
20376: PPUSH
20377: LD_VAR 0 53
20381: PPUSH
20382: CALL 13272 0 5
20386: GO 20512
// if GetVehicle ( side , bulldozer_chassis , bulldozer_type [ 1 ] ) then
20388: LD_VAR 0 10
20392: PPUSH
20393: LD_VAR 0 51
20397: PPUSH
20398: LD_VAR 0 53
20402: PUSH
20403: LD_INT 1
20405: ARRAY
20406: PPUSH
20407: CALL 3112 0 3
20411: IFFALSE 20512
// begin if ListEnvironmentArea ( tree_area ) then
20413: LD_VAR 0 54
20417: PPUSH
20418: CALL_OW 353
20422: IFFALSE 20463
// CutTreeInArea ( GetVehicle ( side , bulldozer_chassis , bulldozer_type [ 1 ] ) [ 1 ] , tree_area ) else
20424: LD_VAR 0 10
20428: PPUSH
20429: LD_VAR 0 51
20433: PPUSH
20434: LD_VAR 0 53
20438: PUSH
20439: LD_INT 1
20441: ARRAY
20442: PPUSH
20443: CALL 3112 0 3
20447: PUSH
20448: LD_INT 1
20450: ARRAY
20451: PPUSH
20452: LD_VAR 0 54
20456: PPUSH
20457: CALL 607 0 2
20461: GO 20512
// ComRecycle ( GetVehicle ( side , bulldozer_chassis , bulldozer_type [ 1 ] ) [ 1 ] , GetBuilding ( side , b_factory ) [ 1 ] ) ;
20463: LD_VAR 0 10
20467: PPUSH
20468: LD_VAR 0 51
20472: PPUSH
20473: LD_VAR 0 53
20477: PUSH
20478: LD_INT 1
20480: ARRAY
20481: PPUSH
20482: CALL 3112 0 3
20486: PUSH
20487: LD_INT 1
20489: ARRAY
20490: PPUSH
20491: LD_VAR 0 10
20495: PPUSH
20496: LD_INT 3
20498: PPUSH
20499: CALL 1265 0 2
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PPUSH
20508: CALL_OW 168
// end ; if ( vehicles diff FilterNonCombatVehicle ( side ) ) < NumAtt ( attack_info [ 1 ] , attack_info [ 2 ] , attack_info [ 3 ] , attack_info [ 4 ] ) then
20512: LD_VAR 0 12
20516: PUSH
20517: LD_VAR 0 10
20521: PPUSH
20522: CALL 15846 0 1
20526: DIFF
20527: PUSH
20528: LD_VAR 0 66
20532: PUSH
20533: LD_INT 1
20535: ARRAY
20536: PPUSH
20537: LD_VAR 0 66
20541: PUSH
20542: LD_INT 2
20544: ARRAY
20545: PPUSH
20546: LD_VAR 0 66
20550: PUSH
20551: LD_INT 3
20553: ARRAY
20554: PPUSH
20555: LD_VAR 0 66
20559: PUSH
20560: LD_INT 4
20562: ARRAY
20563: PPUSH
20564: CALL 16084 0 4
20568: LESS
20569: IFFALSE 21218
// begin case vehicle_def [ 2 ] [ 1 ] of - :
20571: LD_VAR 0 65
20575: PUSH
20576: LD_INT 2
20578: ARRAY
20579: PUSH
20580: LD_INT 1
20582: ARRAY
20583: PUSH
20584: LD_STRING -
20586: DOUBLE
20587: EQUAL
20588: IFTRUE 20592
20590: GO 20652
20592: POP
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_CARGO :
20593: LD_VAR 0 10
20597: PPUSH
20598: LD_VAR 0 65
20602: PUSH
20603: LD_INT 3
20605: ARRAY
20606: PUSH
20607: LD_INT 1
20609: ARRAY
20610: PPUSH
20611: LD_VAR 0 65
20615: PUSH
20616: LD_INT 3
20618: ARRAY
20619: PUSH
20620: LD_INT 2
20622: ARRAY
20623: PPUSH
20624: LD_VAR 0 65
20628: PUSH
20629: LD_INT 3
20631: ARRAY
20632: PUSH
20633: LD_INT 3
20635: ARRAY
20636: PPUSH
20637: LD_VAR 0 65
20641: PUSH
20642: LD_INT 4
20644: ARRAY
20645: PPUSH
20646: CALL 13272 0 5
20650: GO 21218
20652: LD_STRING after_CARGO
20654: DOUBLE
20655: EQUAL
20656: IFTRUE 20660
20658: GO 20779
20660: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , cargo_type [ 1 ] ] , [ f_control , vehicle_def [ 2 ] [ 2 ] ] ] ) then
20661: LD_INT 22
20663: PUSH
20664: LD_VAR 0 10
20668: PUSH
20669: EMPTY
20670: LIST
20671: LIST
20672: PUSH
20673: LD_INT 34
20675: PUSH
20676: LD_VAR 0 37
20680: PUSH
20681: LD_INT 1
20683: ARRAY
20684: PUSH
20685: EMPTY
20686: LIST
20687: LIST
20688: PUSH
20689: LD_INT 33
20691: PUSH
20692: LD_VAR 0 65
20696: PUSH
20697: LD_INT 2
20699: ARRAY
20700: PUSH
20701: LD_INT 2
20703: ARRAY
20704: PUSH
20705: EMPTY
20706: LIST
20707: LIST
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: LIST
20713: PPUSH
20714: CALL_OW 69
20718: IFFALSE 20777
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_CRANE :
20720: LD_VAR 0 10
20724: PPUSH
20725: LD_VAR 0 65
20729: PUSH
20730: LD_INT 3
20732: ARRAY
20733: PUSH
20734: LD_INT 1
20736: ARRAY
20737: PPUSH
20738: LD_VAR 0 65
20742: PUSH
20743: LD_INT 3
20745: ARRAY
20746: PUSH
20747: LD_INT 2
20749: ARRAY
20750: PPUSH
20751: LD_VAR 0 65
20755: PUSH
20756: LD_INT 3
20758: ARRAY
20759: PUSH
20760: LD_INT 3
20762: ARRAY
20763: PPUSH
20764: LD_VAR 0 65
20768: PUSH
20769: LD_INT 4
20771: ARRAY
20772: PPUSH
20773: CALL 13272 0 5
20777: GO 21218
20779: LD_STRING after_CRANE
20781: DOUBLE
20782: EQUAL
20783: IFTRUE 20787
20785: GO 20906
20787: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , crane_type [ 1 ] ] , [ f_control , vehicle_def [ 2 ] [ 2 ] ] ] ) then
20788: LD_INT 22
20790: PUSH
20791: LD_VAR 0 10
20795: PUSH
20796: EMPTY
20797: LIST
20798: LIST
20799: PUSH
20800: LD_INT 34
20802: PUSH
20803: LD_VAR 0 45
20807: PUSH
20808: LD_INT 1
20810: ARRAY
20811: PUSH
20812: EMPTY
20813: LIST
20814: LIST
20815: PUSH
20816: LD_INT 33
20818: PUSH
20819: LD_VAR 0 65
20823: PUSH
20824: LD_INT 2
20826: ARRAY
20827: PUSH
20828: LD_INT 2
20830: ARRAY
20831: PUSH
20832: EMPTY
20833: LIST
20834: LIST
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: LIST
20840: PPUSH
20841: CALL_OW 69
20845: IFFALSE 20904
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_BULL :
20847: LD_VAR 0 10
20851: PPUSH
20852: LD_VAR 0 65
20856: PUSH
20857: LD_INT 3
20859: ARRAY
20860: PUSH
20861: LD_INT 1
20863: ARRAY
20864: PPUSH
20865: LD_VAR 0 65
20869: PUSH
20870: LD_INT 3
20872: ARRAY
20873: PUSH
20874: LD_INT 2
20876: ARRAY
20877: PPUSH
20878: LD_VAR 0 65
20882: PUSH
20883: LD_INT 3
20885: ARRAY
20886: PUSH
20887: LD_INT 3
20889: ARRAY
20890: PPUSH
20891: LD_VAR 0 65
20895: PUSH
20896: LD_INT 4
20898: ARRAY
20899: PPUSH
20900: CALL 13272 0 5
20904: GO 21218
20906: LD_STRING after_BULL
20908: DOUBLE
20909: EQUAL
20910: IFTRUE 20914
20912: GO 21033
20914: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , bulldozer_type [ 1 ] ] , [ f_control , vehicle_def [ 2 ] [ 2 ] ] ] ) then
20915: LD_INT 22
20917: PUSH
20918: LD_VAR 0 10
20922: PUSH
20923: EMPTY
20924: LIST
20925: LIST
20926: PUSH
20927: LD_INT 34
20929: PUSH
20930: LD_VAR 0 53
20934: PUSH
20935: LD_INT 1
20937: ARRAY
20938: PUSH
20939: EMPTY
20940: LIST
20941: LIST
20942: PUSH
20943: LD_INT 33
20945: PUSH
20946: LD_VAR 0 65
20950: PUSH
20951: LD_INT 2
20953: ARRAY
20954: PUSH
20955: LD_INT 2
20957: ARRAY
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: PUSH
20963: EMPTY
20964: LIST
20965: LIST
20966: LIST
20967: PPUSH
20968: CALL_OW 69
20972: IFFALSE 21031
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_TICK :
20974: LD_VAR 0 10
20978: PPUSH
20979: LD_VAR 0 65
20983: PUSH
20984: LD_INT 3
20986: ARRAY
20987: PUSH
20988: LD_INT 1
20990: ARRAY
20991: PPUSH
20992: LD_VAR 0 65
20996: PUSH
20997: LD_INT 3
20999: ARRAY
21000: PUSH
21001: LD_INT 2
21003: ARRAY
21004: PPUSH
21005: LD_VAR 0 65
21009: PUSH
21010: LD_INT 3
21012: ARRAY
21013: PUSH
21014: LD_INT 3
21016: ARRAY
21017: PPUSH
21018: LD_VAR 0 65
21022: PUSH
21023: LD_INT 4
21025: ARRAY
21026: PPUSH
21027: CALL 13272 0 5
21031: GO 21218
21033: LD_STRING after_TICK
21035: DOUBLE
21036: EQUAL
21037: IFTRUE 21041
21039: GO 21121
21041: POP
// if vehicle_def [ 2 ] [ 2 ] > tick then
21042: LD_VAR 0 65
21046: PUSH
21047: LD_INT 2
21049: ARRAY
21050: PUSH
21051: LD_INT 2
21053: ARRAY
21054: PUSH
21055: LD_OWVAR 1
21059: GREATER
21060: IFFALSE 21119
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_TECH :
21062: LD_VAR 0 10
21066: PPUSH
21067: LD_VAR 0 65
21071: PUSH
21072: LD_INT 3
21074: ARRAY
21075: PUSH
21076: LD_INT 1
21078: ARRAY
21079: PPUSH
21080: LD_VAR 0 65
21084: PUSH
21085: LD_INT 3
21087: ARRAY
21088: PUSH
21089: LD_INT 2
21091: ARRAY
21092: PPUSH
21093: LD_VAR 0 65
21097: PUSH
21098: LD_INT 3
21100: ARRAY
21101: PUSH
21102: LD_INT 3
21104: ARRAY
21105: PPUSH
21106: LD_VAR 0 65
21110: PUSH
21111: LD_INT 4
21113: ARRAY
21114: PPUSH
21115: CALL 13272 0 5
21119: GO 21218
21121: LD_STRING after_TECH
21123: DOUBLE
21124: EQUAL
21125: IFTRUE 21129
21127: GO 21217
21129: POP
// if GetTech ( vehicle_def [ 2 ] [ 2 ] , side ) = state_researched then
21130: LD_VAR 0 65
21134: PUSH
21135: LD_INT 2
21137: ARRAY
21138: PUSH
21139: LD_INT 2
21141: ARRAY
21142: PPUSH
21143: LD_VAR 0 10
21147: PPUSH
21148: CALL_OW 321
21152: PUSH
21153: LD_INT 2
21155: EQUAL
21156: IFFALSE 21215
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; end ;
21158: LD_VAR 0 10
21162: PPUSH
21163: LD_VAR 0 65
21167: PUSH
21168: LD_INT 3
21170: ARRAY
21171: PUSH
21172: LD_INT 1
21174: ARRAY
21175: PPUSH
21176: LD_VAR 0 65
21180: PUSH
21181: LD_INT 3
21183: ARRAY
21184: PUSH
21185: LD_INT 2
21187: ARRAY
21188: PPUSH
21189: LD_VAR 0 65
21193: PUSH
21194: LD_INT 3
21196: ARRAY
21197: PUSH
21198: LD_INT 3
21200: ARRAY
21201: PPUSH
21202: LD_VAR 0 65
21206: PUSH
21207: LD_INT 4
21209: ARRAY
21210: PPUSH
21211: CALL 13272 0 5
21215: GO 21218
21217: POP
// end ; ControlTower ( side , GetNation ( mech [ 1 ] ) , ct_xy [ 1 ] , ct_xy [ 2 ] , ct_xy [ 3 ] , ct_chassis ) ;
21218: LD_VAR 0 10
21222: PPUSH
21223: LD_VAR 0 5
21227: PUSH
21228: LD_INT 1
21230: ARRAY
21231: PPUSH
21232: CALL_OW 248
21236: PPUSH
21237: LD_VAR 0 39
21241: PUSH
21242: LD_INT 1
21244: ARRAY
21245: PPUSH
21246: LD_VAR 0 39
21250: PUSH
21251: LD_INT 2
21253: ARRAY
21254: PPUSH
21255: LD_VAR 0 39
21259: PUSH
21260: LD_INT 3
21262: ARRAY
21263: PPUSH
21264: LD_VAR 0 40
21268: PPUSH
21269: CALL 10319 0 6
// if GetVehicle ( side , crane_chassis , crane_type [ 1 ] ) then
21273: LD_VAR 0 10
21277: PPUSH
21278: LD_VAR 0 47
21282: PPUSH
21283: LD_VAR 0 45
21287: PUSH
21288: LD_INT 1
21290: ARRAY
21291: PPUSH
21292: CALL 3112 0 3
21296: IFFALSE 21310
// AddMechanic ( eng , 1 ) ;
21298: LD_VAR 0 4
21302: PPUSH
21303: LD_INT 1
21305: PPUSH
21306: CALL 16231 0 2
// end ; if vehicles then
21310: LD_VAR 0 12
21314: IFFALSE 21558
// begin tmp := vehicles diff FilterNonCombatVehicle ( side ) ;
21316: LD_ADDR_VAR 0 13
21320: PUSH
21321: LD_VAR 0 12
21325: PUSH
21326: LD_VAR 0 10
21330: PPUSH
21331: CALL 15846 0 1
21335: DIFF
21336: ST_TO_ADDR
// if Tag_List ( tmp , 0 ) then
21337: LD_VAR 0 13
21341: PPUSH
21342: LD_INT 0
21344: PPUSH
21345: CALL 9970 0 2
21349: IFFALSE 21456
// for i = 1 to tmp do
21351: LD_ADDR_VAR 0 1
21355: PUSH
21356: DOUBLE
21357: LD_INT 1
21359: DEC
21360: ST_TO_ADDR
21361: LD_VAR 0 13
21365: PUSH
21366: FOR_TO
21367: IFFALSE 21454
// if GetTag ( tmp [ i ] ) = 0 then
21369: LD_VAR 0 13
21373: PUSH
21374: LD_VAR 0 1
21378: ARRAY
21379: PPUSH
21380: CALL_OW 110
21384: PUSH
21385: LD_INT 0
21387: EQUAL
21388: IFFALSE 21452
// begin if Tag_List ( vehicles , 83 ) < vehicle_def [ 1 ] then
21390: LD_VAR 0 12
21394: PPUSH
21395: LD_INT 83
21397: PPUSH
21398: CALL 9970 0 2
21402: PUSH
21403: LD_VAR 0 65
21407: PUSH
21408: LD_INT 1
21410: ARRAY
21411: LESS
21412: IFFALSE 21434
// SetTag ( tmp [ i ] , 83 ) else
21414: LD_VAR 0 13
21418: PUSH
21419: LD_VAR 0 1
21423: ARRAY
21424: PPUSH
21425: LD_INT 83
21427: PPUSH
21428: CALL_OW 109
21432: GO 21452
// SetTag ( tmp [ i ] , 82 ) ;
21434: LD_VAR 0 13
21438: PUSH
21439: LD_VAR 0 1
21443: ARRAY
21444: PPUSH
21445: LD_INT 82
21447: PPUSH
21448: CALL_OW 109
// end ;
21452: GO 21366
21454: POP
21455: POP
// if tick mod attack_info [ 3 ] = 0 then
21456: LD_OWVAR 1
21460: PUSH
21461: LD_VAR 0 66
21465: PUSH
21466: LD_INT 3
21468: ARRAY
21469: MOD
21470: PUSH
21471: LD_INT 0
21473: EQUAL
21474: IFFALSE 21558
// begin for i = 1 to tmp do
21476: LD_ADDR_VAR 0 1
21480: PUSH
21481: DOUBLE
21482: LD_INT 1
21484: DEC
21485: ST_TO_ADDR
21486: LD_VAR 0 13
21490: PUSH
21491: FOR_TO
21492: IFFALSE 21556
// if GetTag ( tmp [ i ] ) = 83 or GetTag ( tmp [ i ] ) = 82 then
21494: LD_VAR 0 13
21498: PUSH
21499: LD_VAR 0 1
21503: ARRAY
21504: PPUSH
21505: CALL_OW 110
21509: PUSH
21510: LD_INT 83
21512: EQUAL
21513: PUSH
21514: LD_VAR 0 13
21518: PUSH
21519: LD_VAR 0 1
21523: ARRAY
21524: PPUSH
21525: CALL_OW 110
21529: PUSH
21530: LD_INT 82
21532: EQUAL
21533: OR
21534: IFFALSE 21554
// SetTag ( tmp [ i ] , 84 ) ;
21536: LD_VAR 0 13
21540: PUSH
21541: LD_VAR 0 1
21545: ARRAY
21546: PPUSH
21547: LD_INT 84
21549: PPUSH
21550: CALL_OW 109
21554: GO 21491
21556: POP
21557: POP
// end ; end ; if NeedBuilding ( side , b_barracks ) and GetBaseSource ( MyBase ( side ) [ 1 ] ) [ 1 ] > 30 and GetBuilding ( side , b_lab_full ) then
21558: LD_VAR 0 10
21562: PPUSH
21563: LD_INT 5
21565: PPUSH
21566: CALL 1042 0 2
21570: PUSH
21571: LD_VAR 0 10
21575: PPUSH
21576: CALL 1174 0 1
21580: PUSH
21581: LD_INT 1
21583: ARRAY
21584: PPUSH
21585: CALL 866 0 1
21589: PUSH
21590: LD_INT 1
21592: ARRAY
21593: PUSH
21594: LD_INT 30
21596: GREATER
21597: AND
21598: PUSH
21599: LD_VAR 0 10
21603: PPUSH
21604: LD_INT 8
21606: PPUSH
21607: CALL 1265 0 2
21611: AND
21612: IFFALSE 21718
// if NeedBuilding ( side , b_armoury ) then
21614: LD_VAR 0 10
21618: PPUSH
21619: LD_INT 4
21621: PPUSH
21622: CALL 1042 0 2
21626: IFFALSE 21669
// Build ( eng , b_armoury , arm_xy [ 1 ] , arm_xy [ 2 ] , arm_xy [ 3 ] ) else
21628: LD_VAR 0 4
21632: PPUSH
21633: LD_INT 4
21635: PPUSH
21636: LD_VAR 0 22
21640: PUSH
21641: LD_INT 1
21643: ARRAY
21644: PPUSH
21645: LD_VAR 0 22
21649: PUSH
21650: LD_INT 2
21652: ARRAY
21653: PPUSH
21654: LD_VAR 0 22
21658: PUSH
21659: LD_INT 3
21661: ARRAY
21662: PPUSH
21663: CALL 9532 0 5
21667: GO 21718
// if GetBaseSource ( MyBase ( side ) [ 1 ] ) [ 1 ] > 30 then
21669: LD_VAR 0 10
21673: PPUSH
21674: CALL 1174 0 1
21678: PUSH
21679: LD_INT 1
21681: ARRAY
21682: PPUSH
21683: CALL 866 0 1
21687: PUSH
21688: LD_INT 1
21690: ARRAY
21691: PUSH
21692: LD_INT 30
21694: GREATER
21695: IFFALSE 21718
// ComUpgrade ( GetBuilding ( side , b_armoury ) [ 1 ] ) ;
21697: LD_VAR 0 10
21701: PPUSH
21702: LD_INT 4
21704: PPUSH
21705: CALL 1265 0 2
21709: PUSH
21710: LD_INT 1
21712: ARRAY
21713: PPUSH
21714: CALL_OW 146
// if sold and not NeedBuilding ( side , b_barracks ) then
21718: LD_VAR 0 3
21722: PUSH
21723: LD_VAR 0 10
21727: PPUSH
21728: LD_INT 5
21730: PPUSH
21731: CALL 1042 0 2
21735: NOT
21736: AND
21737: IFFALSE 21896
// for i = 1 to sold do
21739: LD_ADDR_VAR 0 1
21743: PUSH
21744: DOUBLE
21745: LD_INT 1
21747: DEC
21748: ST_TO_ADDR
21749: LD_VAR 0 3
21753: PUSH
21754: FOR_TO
21755: IFFALSE 21894
// if not IsInUnit ( sold [ i ] ) and not HasTask ( sold [ i ] ) and GetTag ( sold [ i ] ) = 0 and FilterAllUnits ( [ [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) = 0 then
21757: LD_VAR 0 3
21761: PUSH
21762: LD_VAR 0 1
21766: ARRAY
21767: PPUSH
21768: CALL_OW 310
21772: NOT
21773: PUSH
21774: LD_VAR 0 3
21778: PUSH
21779: LD_VAR 0 1
21783: ARRAY
21784: PPUSH
21785: CALL_OW 314
21789: NOT
21790: AND
21791: PUSH
21792: LD_VAR 0 3
21796: PUSH
21797: LD_VAR 0 1
21801: ARRAY
21802: PPUSH
21803: CALL_OW 110
21807: PUSH
21808: LD_INT 0
21810: EQUAL
21811: AND
21812: PUSH
21813: LD_INT 22
21815: PUSH
21816: LD_VAR 0 10
21820: PUSH
21821: EMPTY
21822: LIST
21823: LIST
21824: PUSH
21825: LD_INT 30
21827: PUSH
21828: LD_INT 32
21830: PUSH
21831: EMPTY
21832: LIST
21833: LIST
21834: PUSH
21835: LD_INT 58
21837: PUSH
21838: EMPTY
21839: LIST
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: LIST
21845: PUSH
21846: EMPTY
21847: LIST
21848: PPUSH
21849: CALL_OW 69
21853: PUSH
21854: LD_INT 0
21856: EQUAL
21857: AND
21858: IFFALSE 21892
// ComEnterUnit ( sold [ i ] , GetBuilding ( side , b_barracks ) [ 1 ] ) ;
21860: LD_VAR 0 3
21864: PUSH
21865: LD_VAR 0 1
21869: ARRAY
21870: PPUSH
21871: LD_VAR 0 10
21875: PPUSH
21876: LD_INT 5
21878: PPUSH
21879: CALL 1265 0 2
21883: PUSH
21884: LD_INT 1
21886: ARRAY
21887: PPUSH
21888: CALL_OW 120
21892: GO 21754
21894: POP
21895: POP
// GoToTower ( Tag_List ( sold , 0 ) ) ;
21896: LD_VAR 0 3
21900: PPUSH
21901: LD_INT 0
21903: PPUSH
21904: CALL 9970 0 2
21908: PPUSH
21909: CALL 10064 0 1
// if NeedBuilding ( side , b_oil_mine ) then
21913: LD_VAR 0 10
21917: PPUSH
21918: LD_INT 29
21920: PPUSH
21921: CALL 1042 0 2
21925: IFFALSE 22077
// begin if GetResourceVisibility ( oil_xy [ 1 ] , oil_xy [ 2 ] , side ) = false then
21927: LD_VAR 0 25
21931: PUSH
21932: LD_INT 1
21934: ARRAY
21935: PPUSH
21936: LD_VAR 0 25
21940: PUSH
21941: LD_INT 2
21943: ARRAY
21944: PPUSH
21945: LD_VAR 0 10
21949: PPUSH
21950: CALL_OW 440
21954: PUSH
21955: LD_INT 0
21957: EQUAL
21958: IFFALSE 21995
// ComFindDeposit ( sci [ sci ] , oil_xy [ 1 ] , oil_xy [ 2 ] ) else
21960: LD_VAR 0 6
21964: PUSH
21965: LD_VAR 0 6
21969: ARRAY
21970: PPUSH
21971: LD_VAR 0 25
21975: PUSH
21976: LD_INT 1
21978: ARRAY
21979: PPUSH
21980: LD_VAR 0 25
21984: PUSH
21985: LD_INT 2
21987: ARRAY
21988: PPUSH
21989: CALL 4126 0 3
21993: GO 22075
// begin if GetTag ( sci [ sci ] ) = 42 then
21995: LD_VAR 0 6
21999: PUSH
22000: LD_VAR 0 6
22004: ARRAY
22005: PPUSH
22006: CALL_OW 110
22010: PUSH
22011: LD_INT 42
22013: EQUAL
22014: IFFALSE 22034
// SetTag ( sci [ sci ] , 0 ) ;
22016: LD_VAR 0 6
22020: PUSH
22021: LD_VAR 0 6
22025: ARRAY
22026: PPUSH
22027: LD_INT 0
22029: PPUSH
22030: CALL_OW 109
// Build ( eng , b_oil_mine , oil_xy [ 1 ] , oil_xy [ 2 ] , Rand ( 0 , 5 ) ) ;
22034: LD_VAR 0 4
22038: PPUSH
22039: LD_INT 29
22041: PPUSH
22042: LD_VAR 0 25
22046: PUSH
22047: LD_INT 1
22049: ARRAY
22050: PPUSH
22051: LD_VAR 0 25
22055: PUSH
22056: LD_INT 2
22058: ARRAY
22059: PPUSH
22060: LD_INT 0
22062: PPUSH
22063: LD_INT 5
22065: PPUSH
22066: CALL_OW 12
22070: PPUSH
22071: CALL 9532 0 5
// end end else
22075: GO 22249
// if want_more_oil and GetBuilding ( side , b_oil_mine ) < 2 then
22077: LD_VAR 0 27
22081: PUSH
22082: LD_VAR 0 10
22086: PPUSH
22087: LD_INT 29
22089: PPUSH
22090: CALL 1265 0 2
22094: PUSH
22095: LD_INT 2
22097: LESS
22098: AND
22099: IFFALSE 22249
// if GetResourceVisibility ( oil_xy [ 3 ] , oil_xy [ 4 ] , side ) = false then
22101: LD_VAR 0 25
22105: PUSH
22106: LD_INT 3
22108: ARRAY
22109: PPUSH
22110: LD_VAR 0 25
22114: PUSH
22115: LD_INT 4
22117: ARRAY
22118: PPUSH
22119: LD_VAR 0 10
22123: PPUSH
22124: CALL_OW 440
22128: PUSH
22129: LD_INT 0
22131: EQUAL
22132: IFFALSE 22169
// ComFindDeposit ( sci [ sci ] , oil_xy [ 3 ] , oil_xy [ 4 ] ) else
22134: LD_VAR 0 6
22138: PUSH
22139: LD_VAR 0 6
22143: ARRAY
22144: PPUSH
22145: LD_VAR 0 25
22149: PUSH
22150: LD_INT 3
22152: ARRAY
22153: PPUSH
22154: LD_VAR 0 25
22158: PUSH
22159: LD_INT 4
22161: ARRAY
22162: PPUSH
22163: CALL 4126 0 3
22167: GO 22249
// begin if GetTag ( sci [ sci ] ) = 42 then
22169: LD_VAR 0 6
22173: PUSH
22174: LD_VAR 0 6
22178: ARRAY
22179: PPUSH
22180: CALL_OW 110
22184: PUSH
22185: LD_INT 42
22187: EQUAL
22188: IFFALSE 22208
// SetTag ( sci [ sci ] , 0 ) ;
22190: LD_VAR 0 6
22194: PUSH
22195: LD_VAR 0 6
22199: ARRAY
22200: PPUSH
22201: LD_INT 0
22203: PPUSH
22204: CALL_OW 109
// Build ( eng , b_oil_mine , oil_xy [ 3 ] , oil_xy [ 4 ] , Rand ( 0 , 5 ) ) ;
22208: LD_VAR 0 4
22212: PPUSH
22213: LD_INT 29
22215: PPUSH
22216: LD_VAR 0 25
22220: PUSH
22221: LD_INT 3
22223: ARRAY
22224: PPUSH
22225: LD_VAR 0 25
22229: PUSH
22230: LD_INT 4
22232: ARRAY
22233: PPUSH
22234: LD_INT 0
22236: PPUSH
22237: LD_INT 5
22239: PPUSH
22240: CALL_OW 12
22244: PPUSH
22245: CALL 9532 0 5
// end ; if NeedBuilding ( side , b_siberite_mine ) and GetTech ( tech_SibDet , side ) = state_researched then
22249: LD_VAR 0 10
22253: PPUSH
22254: LD_INT 30
22256: PPUSH
22257: CALL 1042 0 2
22261: PUSH
22262: LD_INT 20
22264: PPUSH
22265: LD_VAR 0 10
22269: PPUSH
22270: CALL_OW 321
22274: PUSH
22275: LD_INT 2
22277: EQUAL
22278: AND
22279: IFFALSE 22460
// begin if GetResourceVisibility ( sib_xy [ 1 ] , sib_xy [ 2 ] , side ) = false then
22281: LD_VAR 0 26
22285: PUSH
22286: LD_INT 1
22288: ARRAY
22289: PPUSH
22290: LD_VAR 0 26
22294: PUSH
22295: LD_INT 2
22297: ARRAY
22298: PPUSH
22299: LD_VAR 0 10
22303: PPUSH
22304: CALL_OW 440
22308: PUSH
22309: LD_INT 0
22311: EQUAL
22312: IFFALSE 22349
// ComFindDeposit ( sci [ sci ] , sib_xy [ 1 ] , sib_xy [ 2 ] ) else
22314: LD_VAR 0 6
22318: PUSH
22319: LD_VAR 0 6
22323: ARRAY
22324: PPUSH
22325: LD_VAR 0 26
22329: PUSH
22330: LD_INT 1
22332: ARRAY
22333: PPUSH
22334: LD_VAR 0 26
22338: PUSH
22339: LD_INT 2
22341: ARRAY
22342: PPUSH
22343: CALL 4126 0 3
22347: GO 22458
// if GetResourceVisibility ( sib_xy [ 1 ] , sib_xy [ 2 ] , side ) then
22349: LD_VAR 0 26
22353: PUSH
22354: LD_INT 1
22356: ARRAY
22357: PPUSH
22358: LD_VAR 0 26
22362: PUSH
22363: LD_INT 2
22365: ARRAY
22366: PPUSH
22367: LD_VAR 0 10
22371: PPUSH
22372: CALL_OW 440
22376: IFFALSE 22458
// begin if GetTag ( sci [ sci ] ) = 42 then
22378: LD_VAR 0 6
22382: PUSH
22383: LD_VAR 0 6
22387: ARRAY
22388: PPUSH
22389: CALL_OW 110
22393: PUSH
22394: LD_INT 42
22396: EQUAL
22397: IFFALSE 22417
// SetTag ( sci [ sci ] , 0 ) ;
22399: LD_VAR 0 6
22403: PUSH
22404: LD_VAR 0 6
22408: ARRAY
22409: PPUSH
22410: LD_INT 0
22412: PPUSH
22413: CALL_OW 109
// Build ( eng , b_siberite_mine , sib_xy [ 1 ] , sib_xy [ 2 ] , Rand ( 0 , 5 ) ) ;
22417: LD_VAR 0 4
22421: PPUSH
22422: LD_INT 30
22424: PPUSH
22425: LD_VAR 0 26
22429: PUSH
22430: LD_INT 1
22432: ARRAY
22433: PPUSH
22434: LD_VAR 0 26
22438: PUSH
22439: LD_INT 2
22441: ARRAY
22442: PPUSH
22443: LD_INT 0
22445: PPUSH
22446: LD_INT 5
22448: PPUSH
22449: CALL_OW 12
22453: PPUSH
22454: CALL 9532 0 5
// end ; end else
22458: GO 22679
// if want_more_sib and GetBuilding ( side , b_siberite_mine ) < 2 and GetTech ( tech_SibDet , side ) = state_researched then
22460: LD_VAR 0 28
22464: PUSH
22465: LD_VAR 0 10
22469: PPUSH
22470: LD_INT 30
22472: PPUSH
22473: CALL 1265 0 2
22477: PUSH
22478: LD_INT 2
22480: LESS
22481: AND
22482: PUSH
22483: LD_INT 20
22485: PPUSH
22486: LD_VAR 0 10
22490: PPUSH
22491: CALL_OW 321
22495: PUSH
22496: LD_INT 2
22498: EQUAL
22499: AND
22500: IFFALSE 22679
// if GetResourceVisibility ( sib_xy [ 3 ] , sib_xy [ 4 ] , side ) = false then
22502: LD_VAR 0 26
22506: PUSH
22507: LD_INT 3
22509: ARRAY
22510: PPUSH
22511: LD_VAR 0 26
22515: PUSH
22516: LD_INT 4
22518: ARRAY
22519: PPUSH
22520: LD_VAR 0 10
22524: PPUSH
22525: CALL_OW 440
22529: PUSH
22530: LD_INT 0
22532: EQUAL
22533: IFFALSE 22570
// ComFindDeposit ( sci [ sci ] , sib_xy [ 3 ] , sib_xy [ 4 ] ) else
22535: LD_VAR 0 6
22539: PUSH
22540: LD_VAR 0 6
22544: ARRAY
22545: PPUSH
22546: LD_VAR 0 26
22550: PUSH
22551: LD_INT 3
22553: ARRAY
22554: PPUSH
22555: LD_VAR 0 26
22559: PUSH
22560: LD_INT 4
22562: ARRAY
22563: PPUSH
22564: CALL 4126 0 3
22568: GO 22679
// begin if GetTag ( sci [ sci ] ) = 42 then
22570: LD_VAR 0 6
22574: PUSH
22575: LD_VAR 0 6
22579: ARRAY
22580: PPUSH
22581: CALL_OW 110
22585: PUSH
22586: LD_INT 42
22588: EQUAL
22589: IFFALSE 22609
// SetTag ( sci [ sci ] , 0 ) ;
22591: LD_VAR 0 6
22595: PUSH
22596: LD_VAR 0 6
22600: ARRAY
22601: PPUSH
22602: LD_INT 0
22604: PPUSH
22605: CALL_OW 109
// if GetResourceVisibility ( sib_xy [ 3 ] , sib_xy [ 4 ] , side ) then
22609: LD_VAR 0 26
22613: PUSH
22614: LD_INT 3
22616: ARRAY
22617: PPUSH
22618: LD_VAR 0 26
22622: PUSH
22623: LD_INT 4
22625: ARRAY
22626: PPUSH
22627: LD_VAR 0 10
22631: PPUSH
22632: CALL_OW 440
22636: IFFALSE 22679
// Build ( eng , b_siberite_mine , sib_xy [ 3 ] , sib_xy [ 4 ] , Rand ( 0 , 5 ) ) ;
22638: LD_VAR 0 4
22642: PPUSH
22643: LD_INT 30
22645: PPUSH
22646: LD_VAR 0 26
22650: PUSH
22651: LD_INT 3
22653: ARRAY
22654: PPUSH
22655: LD_VAR 0 26
22659: PUSH
22660: LD_INT 4
22662: ARRAY
22663: PPUSH
22664: LD_INT 0
22666: PPUSH
22667: LD_INT 5
22669: PPUSH
22670: CALL_OW 12
22674: PPUSH
22675: CALL 9532 0 5
// end ; if GetTech ( tech_solpow , side ) = state_researched and sol_pow_list and GetBuilding ( side , b_solar_power ) < ( sol_pow_list / 3 ) then
22679: LD_INT 35
22681: PPUSH
22682: LD_VAR 0 10
22686: PPUSH
22687: CALL_OW 321
22691: PUSH
22692: LD_INT 2
22694: EQUAL
22695: PUSH
22696: LD_VAR 0 29
22700: AND
22701: PUSH
22702: LD_VAR 0 10
22706: PPUSH
22707: LD_INT 27
22709: PPUSH
22710: CALL 1265 0 2
22714: PUSH
22715: LD_VAR 0 29
22719: PUSH
22720: LD_INT 3
22722: DIVREAL
22723: LESS
22724: AND
22725: IFFALSE 22744
// BuildPowerFromList ( eng , sol_pow_list , b_solar_power ) ;
22727: LD_VAR 0 4
22731: PPUSH
22732: LD_VAR 0 29
22736: PPUSH
22737: LD_INT 27
22739: PPUSH
22740: CALL 9784 0 3
// if GetTech ( tech_oilpow , side ) = state_researched and oil_pow_list and GetBuilding ( side , b_oil_power ) < ( oil_pow_list / 3 ) then
22744: LD_INT 46
22746: PPUSH
22747: LD_VAR 0 10
22751: PPUSH
22752: CALL_OW 321
22756: PUSH
22757: LD_INT 2
22759: EQUAL
22760: PUSH
22761: LD_VAR 0 30
22765: AND
22766: PUSH
22767: LD_VAR 0 10
22771: PPUSH
22772: LD_INT 26
22774: PPUSH
22775: CALL 1265 0 2
22779: PUSH
22780: LD_VAR 0 30
22784: PUSH
22785: LD_INT 3
22787: DIVREAL
22788: LESS
22789: AND
22790: IFFALSE 22809
// BuildPowerFromList ( eng , oil_pow_list , b_oil_power ) ;
22792: LD_VAR 0 4
22796: PPUSH
22797: LD_VAR 0 30
22801: PPUSH
22802: LD_INT 26
22804: PPUSH
22805: CALL 9784 0 3
// if GetTech ( tech_sibpow , side ) = state_researched and sib_pow_list and GetBuilding ( side , b_siberite_power ) < ( sib_pow_list / 3 ) then
22809: LD_INT 21
22811: PPUSH
22812: LD_VAR 0 10
22816: PPUSH
22817: CALL_OW 321
22821: PUSH
22822: LD_INT 2
22824: EQUAL
22825: PUSH
22826: LD_VAR 0 31
22830: AND
22831: PUSH
22832: LD_VAR 0 10
22836: PPUSH
22837: LD_INT 28
22839: PPUSH
22840: CALL 1265 0 2
22844: PUSH
22845: LD_VAR 0 31
22849: PUSH
22850: LD_INT 3
22852: DIVREAL
22853: LESS
22854: AND
22855: IFFALSE 22874
// BuildPowerFromList ( eng , sib_pow_list , b_siberite_power ) ;
22857: LD_VAR 0 4
22861: PPUSH
22862: LD_VAR 0 31
22866: PPUSH
22867: LD_INT 28
22869: PPUSH
22870: CALL 9784 0 3
// if GetListOfCratesInArea ( crates_area ) then
22874: LD_VAR 0 23
22878: PPUSH
22879: CALL_OW 435
22883: IFFALSE 22899
// CollectCrates ( side , crates_area ) ;
22885: LD_VAR 0 10
22889: PPUSH
22890: LD_VAR 0 23
22894: PPUSH
22895: CALL 9093 0 2
// end ; end ; end ; end_of_file end_of_file
22899: PPOPN 66
22901: END
// export gensher ; every 0 0$01 do var i , p , sold , eng , mech , sci , b , veh , filter , side , pom , vehicles , tmp , en , enemy_xy , depot_xy , lab_xy , fac_xy , turret_xy , lab_kind , fac_ext , arm_xy , crates_area , tech_list , oil_xy , sib_xy , want_more_oil , want_more_sib , sol_pow_list , oil_pow_list , sib_pow_list , turret_weapon , not_turret_weapon , veh_list , cargo_allow , cargo_chassis , cargo_type , allow_ct , ct_xy , ct_chassis , xy_back , enemy_list , modernize_cargo_allow , crane_allow , crane_type , crane_engine , crane_chassis , crane_num , modernize_crane_allow , bulldozer_allow , bulldozer_chassis , bulldozer_engine , bulldozer_type , tree_area , parking_area , second_base_allow , second_base_xy , transport_from_second_base , build_second_base_after , lab , base_status , sec_points , scout_near_base , repair_xy , vehicle_def , attack_info ;
22902: GO 22904
22904: DISABLE
22905: LD_INT 0
22907: PPUSH
22908: PPUSH
22909: PPUSH
22910: PPUSH
22911: PPUSH
22912: PPUSH
22913: PPUSH
22914: PPUSH
22915: PPUSH
22916: PPUSH
22917: PPUSH
22918: PPUSH
22919: PPUSH
22920: PPUSH
22921: PPUSH
22922: PPUSH
22923: PPUSH
22924: PPUSH
22925: PPUSH
22926: PPUSH
22927: PPUSH
22928: PPUSH
22929: PPUSH
22930: PPUSH
22931: PPUSH
22932: PPUSH
22933: PPUSH
22934: PPUSH
22935: PPUSH
22936: PPUSH
22937: PPUSH
22938: PPUSH
22939: PPUSH
22940: PPUSH
22941: PPUSH
22942: PPUSH
22943: PPUSH
22944: PPUSH
22945: PPUSH
22946: PPUSH
22947: PPUSH
22948: PPUSH
22949: PPUSH
22950: PPUSH
22951: PPUSH
22952: PPUSH
22953: PPUSH
22954: PPUSH
22955: PPUSH
22956: PPUSH
22957: PPUSH
22958: PPUSH
22959: PPUSH
22960: PPUSH
22961: PPUSH
22962: PPUSH
22963: PPUSH
22964: PPUSH
22965: PPUSH
22966: PPUSH
22967: PPUSH
22968: PPUSH
22969: PPUSH
22970: PPUSH
22971: PPUSH
22972: PPUSH
// begin enable ;
22973: ENABLE
// side := 2 ;
22974: LD_ADDR_VAR 0 10
22978: PUSH
22979: LD_INT 2
22981: ST_TO_ADDR
// enemy_list := [ 1 , 4 ] ;
22982: LD_ADDR_VAR 0 42
22986: PUSH
22987: LD_INT 1
22989: PUSH
22990: LD_INT 4
22992: PUSH
22993: EMPTY
22994: LIST
22995: LIST
22996: ST_TO_ADDR
// enemy_xy := [ [ 114 , 8 ] , [ 161 , 100 ] ] ;
22997: LD_ADDR_VAR 0 15
23001: PUSH
23002: LD_INT 114
23004: PUSH
23005: LD_INT 8
23007: PUSH
23008: EMPTY
23009: LIST
23010: LIST
23011: PUSH
23012: LD_INT 161
23014: PUSH
23015: LD_INT 100
23017: PUSH
23018: EMPTY
23019: LIST
23020: LIST
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: ST_TO_ADDR
// sold := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 1 ] ] ) ;
23026: LD_ADDR_VAR 0 3
23030: PUSH
23031: LD_INT 22
23033: PUSH
23034: LD_VAR 0 10
23038: PUSH
23039: EMPTY
23040: LIST
23041: LIST
23042: PUSH
23043: LD_INT 25
23045: PUSH
23046: LD_INT 1
23048: PUSH
23049: EMPTY
23050: LIST
23051: LIST
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PPUSH
23057: CALL_OW 69
23061: ST_TO_ADDR
// eng := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 2 ] ] ) ;
23062: LD_ADDR_VAR 0 4
23066: PUSH
23067: LD_INT 22
23069: PUSH
23070: LD_VAR 0 10
23074: PUSH
23075: EMPTY
23076: LIST
23077: LIST
23078: PUSH
23079: LD_INT 25
23081: PUSH
23082: LD_INT 2
23084: PUSH
23085: EMPTY
23086: LIST
23087: LIST
23088: PUSH
23089: EMPTY
23090: LIST
23091: LIST
23092: PPUSH
23093: CALL_OW 69
23097: ST_TO_ADDR
// mech := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 3 ] ] ) ;
23098: LD_ADDR_VAR 0 5
23102: PUSH
23103: LD_INT 22
23105: PUSH
23106: LD_VAR 0 10
23110: PUSH
23111: EMPTY
23112: LIST
23113: LIST
23114: PUSH
23115: LD_INT 25
23117: PUSH
23118: LD_INT 3
23120: PUSH
23121: EMPTY
23122: LIST
23123: LIST
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PPUSH
23129: CALL_OW 69
23133: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , side ] , [ f_class , 4 ] ] ) ;
23134: LD_ADDR_VAR 0 6
23138: PUSH
23139: LD_INT 22
23141: PUSH
23142: LD_VAR 0 10
23146: PUSH
23147: EMPTY
23148: LIST
23149: LIST
23150: PUSH
23151: LD_INT 25
23153: PUSH
23154: LD_INT 4
23156: PUSH
23157: EMPTY
23158: LIST
23159: LIST
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: PPUSH
23165: CALL_OW 69
23169: ST_TO_ADDR
// vehicles := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ;
23170: LD_ADDR_VAR 0 12
23174: PUSH
23175: LD_INT 22
23177: PUSH
23178: LD_VAR 0 10
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: PUSH
23187: LD_INT 21
23189: PUSH
23190: LD_INT 2
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: PUSH
23197: EMPTY
23198: LIST
23199: LIST
23200: PPUSH
23201: CALL_OW 69
23205: ST_TO_ADDR
// sec_points := [ 33 , 56 , 52 , 67 , 61 , 40 , 45 , 9 ] ;
23206: LD_ADDR_VAR 0 62
23210: PUSH
23211: LD_INT 33
23213: PUSH
23214: LD_INT 56
23216: PUSH
23217: LD_INT 52
23219: PUSH
23220: LD_INT 67
23222: PUSH
23223: LD_INT 61
23225: PUSH
23226: LD_INT 40
23228: PUSH
23229: LD_INT 45
23231: PUSH
23232: LD_INT 9
23234: PUSH
23235: EMPTY
23236: LIST
23237: LIST
23238: LIST
23239: LIST
23240: LIST
23241: LIST
23242: LIST
23243: LIST
23244: ST_TO_ADDR
// depot_xy := [ 8 , 10 , 1 ] ;
23245: LD_ADDR_VAR 0 16
23249: PUSH
23250: LD_INT 8
23252: PUSH
23253: LD_INT 10
23255: PUSH
23256: LD_INT 1
23258: PUSH
23259: EMPTY
23260: LIST
23261: LIST
23262: LIST
23263: ST_TO_ADDR
// lab_xy := [ 12 , 5 , 3 , 12 , 18 , 1 ] ;
23264: LD_ADDR_VAR 0 17
23268: PUSH
23269: LD_INT 12
23271: PUSH
23272: LD_INT 5
23274: PUSH
23275: LD_INT 3
23277: PUSH
23278: LD_INT 12
23280: PUSH
23281: LD_INT 18
23283: PUSH
23284: LD_INT 1
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: ST_TO_ADDR
// lab_kind := [ b_lab_weapon , b_lab_opto , b_lab_siberium , b_lab_biological ] ;
23295: LD_ADDR_VAR 0 20
23299: PUSH
23300: LD_INT 10
23302: PUSH
23303: LD_INT 15
23305: PUSH
23306: LD_INT 11
23308: PUSH
23309: LD_INT 13
23311: PUSH
23312: EMPTY
23313: LIST
23314: LIST
23315: LIST
23316: LIST
23317: ST_TO_ADDR
// fac_xy := [ 31 , 39 , 1 ] ;
23318: LD_ADDR_VAR 0 18
23322: PUSH
23323: LD_INT 31
23325: PUSH
23326: LD_INT 39
23328: PUSH
23329: LD_INT 1
23331: PUSH
23332: EMPTY
23333: LIST
23334: LIST
23335: LIST
23336: ST_TO_ADDR
// arm_xy := [ 22 , 12 , 5 ] ;
23337: LD_ADDR_VAR 0 22
23341: PUSH
23342: LD_INT 22
23344: PUSH
23345: LD_INT 12
23347: PUSH
23348: LD_INT 5
23350: PUSH
23351: EMPTY
23352: LIST
23353: LIST
23354: LIST
23355: ST_TO_ADDR
// xy_back := [ 15 , 10 ] ;
23356: LD_ADDR_VAR 0 41
23360: PUSH
23361: LD_INT 15
23363: PUSH
23364: LD_INT 10
23366: PUSH
23367: EMPTY
23368: LIST
23369: LIST
23370: ST_TO_ADDR
// turret_xy := [ b_bunker , 19 , 27 , 5 , b_bunker , 42 , 26 , 5 ] ;
23371: LD_ADDR_VAR 0 19
23375: PUSH
23376: LD_INT 32
23378: PUSH
23379: LD_INT 19
23381: PUSH
23382: LD_INT 27
23384: PUSH
23385: LD_INT 5
23387: PUSH
23388: LD_INT 32
23390: PUSH
23391: LD_INT 42
23393: PUSH
23394: LD_INT 26
23396: PUSH
23397: LD_INT 5
23399: PUSH
23400: EMPTY
23401: LIST
23402: LIST
23403: LIST
23404: LIST
23405: LIST
23406: LIST
23407: LIST
23408: LIST
23409: ST_TO_ADDR
// not_turret_weapon := [ ar_crane , ar_cargo_bay , ar_control_tower , ar_multimissile_ballista , ar_double_machine_gun , ar_light_gun ] ;
23410: LD_ADDR_VAR 0 33
23414: PUSH
23415: LD_EXP 1
23419: PUSH
23420: LD_INT 32
23422: PUSH
23423: LD_INT 31
23425: PUSH
23426: LD_INT 22
23428: PUSH
23429: LD_INT 24
23431: PUSH
23432: LD_INT 23
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: LIST
23439: LIST
23440: LIST
23441: LIST
23442: ST_TO_ADDR
// fac_ext := [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radar ] ;
23443: LD_ADDR_VAR 0 21
23447: PUSH
23448: LD_INT 23
23450: PUSH
23451: LD_INT 16
23453: PUSH
23454: LD_INT 17
23456: PUSH
23457: LD_INT 18
23459: PUSH
23460: LD_INT 20
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: LIST
23467: LIST
23468: LIST
23469: ST_TO_ADDR
// sol_pow_list := [ 16 , 25 , 0 ] ;
23470: LD_ADDR_VAR 0 29
23474: PUSH
23475: LD_INT 16
23477: PUSH
23478: LD_INT 25
23480: PUSH
23481: LD_INT 0
23483: PUSH
23484: EMPTY
23485: LIST
23486: LIST
23487: LIST
23488: ST_TO_ADDR
// oil_pow_list := [ 17 , 3 , 2 , 20 , 3 , 2 ] ;
23489: LD_ADDR_VAR 0 30
23493: PUSH
23494: LD_INT 17
23496: PUSH
23497: LD_INT 3
23499: PUSH
23500: LD_INT 2
23502: PUSH
23503: LD_INT 20
23505: PUSH
23506: LD_INT 3
23508: PUSH
23509: LD_INT 2
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: LIST
23516: LIST
23517: LIST
23518: LIST
23519: ST_TO_ADDR
// sib_pow_list := [ ] ;
23520: LD_ADDR_VAR 0 31
23524: PUSH
23525: EMPTY
23526: ST_TO_ADDR
// allow_ct := true ;
23527: LD_ADDR_VAR 0 38
23531: PUSH
23532: LD_INT 1
23534: ST_TO_ADDR
// ct_xy := [ 29 , 40 , 4 ] ;
23535: LD_ADDR_VAR 0 39
23539: PUSH
23540: LD_INT 29
23542: PUSH
23543: LD_INT 40
23545: PUSH
23546: LD_INT 4
23548: PUSH
23549: EMPTY
23550: LIST
23551: LIST
23552: LIST
23553: ST_TO_ADDR
// ct_chassis := ar_half_tracked ;
23554: LD_ADDR_VAR 0 40
23558: PUSH
23559: LD_INT 14
23561: ST_TO_ADDR
// second_base_allow := false ;
23562: LD_ADDR_VAR 0 56
23566: PUSH
23567: LD_INT 0
23569: ST_TO_ADDR
// second_base_xy := [ 0 , 0 , 0 ] ;
23570: LD_ADDR_VAR 0 57
23574: PUSH
23575: LD_INT 0
23577: PUSH
23578: LD_INT 0
23580: PUSH
23581: LD_INT 0
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: LIST
23588: ST_TO_ADDR
// transport_from_second_base := [ false , 30 ] ;
23589: LD_ADDR_VAR 0 58
23593: PUSH
23594: LD_INT 0
23596: PUSH
23597: LD_INT 30
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: ST_TO_ADDR
// build_second_base_after := [ 11 11$00 , tech_SibDet ] ;
23604: LD_ADDR_VAR 0 59
23608: PUSH
23609: LD_INT 23100
23611: PUSH
23612: LD_INT 20
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: ST_TO_ADDR
// oil_xy := [ 5 , 4 ] ;
23619: LD_ADDR_VAR 0 25
23623: PUSH
23624: LD_INT 5
23626: PUSH
23627: LD_INT 4
23629: PUSH
23630: EMPTY
23631: LIST
23632: LIST
23633: ST_TO_ADDR
// sib_xy := [ 46 , 64 ] ;
23634: LD_ADDR_VAR 0 26
23638: PUSH
23639: LD_INT 46
23641: PUSH
23642: LD_INT 64
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: ST_TO_ADDR
// want_more_oil := false ;
23649: LD_ADDR_VAR 0 27
23653: PUSH
23654: LD_INT 0
23656: ST_TO_ADDR
// want_more_sib := false ;
23657: LD_ADDR_VAR 0 28
23661: PUSH
23662: LD_INT 0
23664: ST_TO_ADDR
// tech_list := [ 35 , 45 , 46 , 47 , 1 , 48 , 49 , 50 , 51 , 52 , 53 , 69 , 39 , 60 , 61 , 6 , 18 , 62 ] ;
23665: LD_ADDR_VAR 0 24
23669: PUSH
23670: LD_INT 35
23672: PUSH
23673: LD_INT 45
23675: PUSH
23676: LD_INT 46
23678: PUSH
23679: LD_INT 47
23681: PUSH
23682: LD_INT 1
23684: PUSH
23685: LD_INT 48
23687: PUSH
23688: LD_INT 49
23690: PUSH
23691: LD_INT 50
23693: PUSH
23694: LD_INT 51
23696: PUSH
23697: LD_INT 52
23699: PUSH
23700: LD_INT 53
23702: PUSH
23703: LD_INT 69
23705: PUSH
23706: LD_INT 39
23708: PUSH
23709: LD_INT 60
23711: PUSH
23712: LD_INT 61
23714: PUSH
23715: LD_INT 6
23717: PUSH
23718: LD_INT 18
23720: PUSH
23721: LD_INT 62
23723: PUSH
23724: EMPTY
23725: LIST
23726: LIST
23727: LIST
23728: LIST
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: LIST
23734: LIST
23735: LIST
23736: LIST
23737: LIST
23738: LIST
23739: LIST
23740: LIST
23741: LIST
23742: LIST
23743: ST_TO_ADDR
// crates_area := gensher_crates ;
23744: LD_ADDR_VAR 0 23
23748: PUSH
23749: LD_INT 6
23751: ST_TO_ADDR
// veh_list := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_vehicle ] ] ) ;
23752: LD_ADDR_VAR 0 34
23756: PUSH
23757: LD_INT 22
23759: PUSH
23760: LD_VAR 0 10
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: LD_INT 21
23771: PUSH
23772: LD_INT 2
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: PPUSH
23783: CALL_OW 69
23787: ST_TO_ADDR
// repair_xy := [ 32 , 27 ] ;
23788: LD_ADDR_VAR 0 64
23792: PUSH
23793: LD_INT 32
23795: PUSH
23796: LD_INT 27
23798: PUSH
23799: EMPTY
23800: LIST
23801: LIST
23802: ST_TO_ADDR
// vehicle_def := [ 3 , [ after_CARGO , control_remote ] , [ ar_half_tracked , engine_combustion , control_remote ] , [ ar_gatling_gun , ar_gun ] ] ;
23803: LD_ADDR_VAR 0 65
23807: PUSH
23808: LD_INT 3
23810: PUSH
23811: LD_STRING after_CARGO
23813: PUSH
23814: LD_INT 2
23816: PUSH
23817: EMPTY
23818: LIST
23819: LIST
23820: PUSH
23821: LD_INT 14
23823: PUSH
23824: LD_INT 1
23826: PUSH
23827: LD_INT 2
23829: PUSH
23830: EMPTY
23831: LIST
23832: LIST
23833: LIST
23834: PUSH
23835: LD_INT 25
23837: PUSH
23838: LD_INT 27
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: PUSH
23845: EMPTY
23846: LIST
23847: LIST
23848: LIST
23849: LIST
23850: ST_TO_ADDR
// parking_area := gensher_parking ;
23851: LD_ADDR_VAR 0 55
23855: PUSH
23856: LD_INT 7
23858: ST_TO_ADDR
// cargo_allow := true ;
23859: LD_ADDR_VAR 0 35
23863: PUSH
23864: LD_INT 1
23866: ST_TO_ADDR
// cargo_chassis := ar_half_tracked ;
23867: LD_ADDR_VAR 0 36
23871: PUSH
23872: LD_INT 14
23874: ST_TO_ADDR
// cargo_type := [ ar_cargo_bay ] ;
23875: LD_ADDR_VAR 0 37
23879: PUSH
23880: LD_INT 32
23882: PUSH
23883: EMPTY
23884: LIST
23885: ST_TO_ADDR
// modernize_cargo_allow := true ;
23886: LD_ADDR_VAR 0 43
23890: PUSH
23891: LD_INT 1
23893: ST_TO_ADDR
// crane_allow := true ;
23894: LD_ADDR_VAR 0 44
23898: PUSH
23899: LD_INT 1
23901: ST_TO_ADDR
// crane_chassis := ar_half_tracked ;
23902: LD_ADDR_VAR 0 47
23906: PUSH
23907: LD_INT 14
23909: ST_TO_ADDR
// crane_engine := engine_solar ;
23910: LD_ADDR_VAR 0 46
23914: PUSH
23915: LD_INT 2
23917: ST_TO_ADDR
// crane_type := [ ar_crane ] ;
23918: LD_ADDR_VAR 0 45
23922: PUSH
23923: LD_EXP 1
23927: PUSH
23928: EMPTY
23929: LIST
23930: ST_TO_ADDR
// crane_num := 1 ;
23931: LD_ADDR_VAR 0 48
23935: PUSH
23936: LD_INT 1
23938: ST_TO_ADDR
// modernize_crane_allow := false ;
23939: LD_ADDR_VAR 0 49
23943: PUSH
23944: LD_INT 0
23946: ST_TO_ADDR
// bulldozer_allow := false ;
23947: LD_ADDR_VAR 0 50
23951: PUSH
23952: LD_INT 0
23954: ST_TO_ADDR
// bulldozer_chassis := ar_half_tracked ;
23955: LD_ADDR_VAR 0 51
23959: PUSH
23960: LD_INT 14
23962: ST_TO_ADDR
// bulldozer_engine := engine_combustion ;
23963: LD_ADDR_VAR 0 52
23967: PUSH
23968: LD_INT 1
23970: ST_TO_ADDR
// bulldozer_type := 0 ;
23971: LD_ADDR_VAR 0 53
23975: PUSH
23976: LD_INT 0
23978: ST_TO_ADDR
// tree_area := gensher_tree ;
23979: LD_ADDR_VAR 0 54
23983: PUSH
23984: LD_INT 8
23986: ST_TO_ADDR
// attack_info := [ 3 , 8 8$00 , 1 , 4 , [ electro ] ] ;
23987: LD_ADDR_VAR 0 66
23991: PUSH
23992: LD_INT 3
23994: PUSH
23995: LD_INT 16800
23997: PUSH
23998: LD_INT 1
24000: PUSH
24001: LD_INT 4
24003: PUSH
24004: LD_STRING electro
24006: PUSH
24007: EMPTY
24008: LIST
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: LIST
24014: LIST
24015: LIST
24016: ST_TO_ADDR
// scout_near_base := [ sold [ 2 ] , [ 28 , 44 , 55 , 50 , 69 , 51 , xy_back [ 1 ] , xy_back [ 2 ] ] , sold [ 3 ] , [ 71 , 10 , 75 , 40 , xy_back [ 1 ] , xy_back [ 2 ] ] ] ;
24017: LD_ADDR_VAR 0 63
24021: PUSH
24022: LD_VAR 0 3
24026: PUSH
24027: LD_INT 2
24029: ARRAY
24030: PUSH
24031: LD_INT 28
24033: PUSH
24034: LD_INT 44
24036: PUSH
24037: LD_INT 55
24039: PUSH
24040: LD_INT 50
24042: PUSH
24043: LD_INT 69
24045: PUSH
24046: LD_INT 51
24048: PUSH
24049: LD_VAR 0 41
24053: PUSH
24054: LD_INT 1
24056: ARRAY
24057: PUSH
24058: LD_VAR 0 41
24062: PUSH
24063: LD_INT 2
24065: ARRAY
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: LIST
24071: LIST
24072: LIST
24073: LIST
24074: LIST
24075: LIST
24076: PUSH
24077: LD_VAR 0 3
24081: PUSH
24082: LD_INT 3
24084: ARRAY
24085: PUSH
24086: LD_INT 71
24088: PUSH
24089: LD_INT 10
24091: PUSH
24092: LD_INT 75
24094: PUSH
24095: LD_INT 40
24097: PUSH
24098: LD_VAR 0 41
24102: PUSH
24103: LD_INT 1
24105: ARRAY
24106: PUSH
24107: LD_VAR 0 41
24111: PUSH
24112: LD_INT 2
24114: ARRAY
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: PUSH
24124: EMPTY
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: ST_TO_ADDR
// if EnemyInRange ( side , sec_points ) then
24130: LD_VAR 0 10
24134: PPUSH
24135: LD_VAR 0 62
24139: PPUSH
24140: CALL 433 0 2
24144: IFFALSE 24156
// base_status := true else
24146: LD_ADDR_VAR 0 61
24150: PUSH
24151: LD_INT 1
24153: ST_TO_ADDR
24154: GO 24164
// base_status := false ;
24156: LD_ADDR_VAR 0 61
24160: PUSH
24161: LD_INT 0
24163: ST_TO_ADDR
// if base_status then
24164: LD_VAR 0 61
24168: IFFALSE 24426
// begin VehicleMove ( side , parking_area , 83 , defend , [ ] ) ;
24170: LD_VAR 0 10
24174: PPUSH
24175: LD_VAR 0 55
24179: PPUSH
24180: LD_INT 83
24182: PPUSH
24183: LD_STRING defend
24185: PPUSH
24186: EMPTY
24187: PPUSH
24188: CALL 14244 0 5
// if eng then
24192: LD_VAR 0 4
24196: IFFALSE 24230
// RepairBase ( side , enemy_list , xy_back [ 1 ] , xy_back [ 2 ] ) ;
24198: LD_VAR 0 10
24202: PPUSH
24203: LD_VAR 0 42
24207: PPUSH
24208: LD_VAR 0 41
24212: PUSH
24213: LD_INT 1
24215: ARRAY
24216: PPUSH
24217: LD_VAR 0 41
24221: PUSH
24222: LD_INT 2
24224: ARRAY
24225: PPUSH
24226: CALL 11363 0 4
// if sci then
24230: LD_VAR 0 6
24234: IFFALSE 24248
// HealPersonel ( side , 99 ) ;
24236: LD_VAR 0 10
24240: PPUSH
24241: LD_INT 99
24243: PPUSH
24244: CALL 12655 0 2
// if sold and not NeedBuilding ( side , b_barracks ) then
24248: LD_VAR 0 3
24252: PUSH
24253: LD_VAR 0 10
24257: PPUSH
24258: LD_INT 5
24260: PPUSH
24261: CALL 1042 0 2
24265: NOT
24266: AND
24267: IFFALSE 24426
// for i = 1 to sold do
24269: LD_ADDR_VAR 0 1
24273: PUSH
24274: DOUBLE
24275: LD_INT 1
24277: DEC
24278: ST_TO_ADDR
24279: LD_VAR 0 3
24283: PUSH
24284: FOR_TO
24285: IFFALSE 24424
// if not IsInUnit ( sold [ i ] ) and not HasTask ( sold [ i ] ) and GetTag ( sold [ i ] ) = 0 and FilterAllUnits ( [ [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) = 0 then
24287: LD_VAR 0 3
24291: PUSH
24292: LD_VAR 0 1
24296: ARRAY
24297: PPUSH
24298: CALL_OW 310
24302: NOT
24303: PUSH
24304: LD_VAR 0 3
24308: PUSH
24309: LD_VAR 0 1
24313: ARRAY
24314: PPUSH
24315: CALL_OW 314
24319: NOT
24320: AND
24321: PUSH
24322: LD_VAR 0 3
24326: PUSH
24327: LD_VAR 0 1
24331: ARRAY
24332: PPUSH
24333: CALL_OW 110
24337: PUSH
24338: LD_INT 0
24340: EQUAL
24341: AND
24342: PUSH
24343: LD_INT 22
24345: PUSH
24346: LD_VAR 0 10
24350: PUSH
24351: EMPTY
24352: LIST
24353: LIST
24354: PUSH
24355: LD_INT 30
24357: PUSH
24358: LD_INT 32
24360: PUSH
24361: EMPTY
24362: LIST
24363: LIST
24364: PUSH
24365: LD_INT 58
24367: PUSH
24368: EMPTY
24369: LIST
24370: PUSH
24371: EMPTY
24372: LIST
24373: LIST
24374: LIST
24375: PUSH
24376: EMPTY
24377: LIST
24378: PPUSH
24379: CALL_OW 69
24383: PUSH
24384: LD_INT 0
24386: EQUAL
24387: AND
24388: IFFALSE 24422
// ComEnterUnit ( sold [ i ] , GetBuilding ( side , b_barracks ) [ 1 ] ) ;
24390: LD_VAR 0 3
24394: PUSH
24395: LD_VAR 0 1
24399: ARRAY
24400: PPUSH
24401: LD_VAR 0 10
24405: PPUSH
24406: LD_INT 5
24408: PPUSH
24409: CALL 1265 0 2
24413: PUSH
24414: LD_INT 1
24416: ARRAY
24417: PPUSH
24418: CALL_OW 120
24422: GO 24284
24424: POP
24425: POP
// end ; if tick = 105 then
24426: LD_OWVAR 1
24430: PUSH
24431: LD_INT 105
24433: EQUAL
24434: IFFALSE 24480
// begin ScoutArea ( scout_near_base [ 1 ] , scout_near_base [ 2 ] ) ;
24436: LD_VAR 0 63
24440: PUSH
24441: LD_INT 1
24443: ARRAY
24444: PPUSH
24445: LD_VAR 0 63
24449: PUSH
24450: LD_INT 2
24452: ARRAY
24453: PPUSH
24454: CALL 13535 0 2
// ScoutArea ( scout_near_base [ 3 ] , scout_near_base [ 4 ] ) ;
24458: LD_VAR 0 63
24462: PUSH
24463: LD_INT 3
24465: ARRAY
24466: PPUSH
24467: LD_VAR 0 63
24471: PUSH
24472: LD_INT 4
24474: ARRAY
24475: PPUSH
24476: CALL 13535 0 2
// end ; ScanVehicleStatus ( side , repair_xy [ 1 ] , repair_xy [ 2 ] ) ;
24480: LD_VAR 0 10
24484: PPUSH
24485: LD_VAR 0 64
24489: PUSH
24490: LD_INT 1
24492: ARRAY
24493: PPUSH
24494: LD_VAR 0 64
24498: PUSH
24499: LD_INT 2
24501: ARRAY
24502: PPUSH
24503: CALL 13819 0 3
// if Tag_List ( vehicles , 84 ) >= NumAtt ( attack_info [ 1 ] , attack_info [ 2 ] , attack_info [ 3 ] , attack_info [ 4 ] ) then
24507: LD_VAR 0 12
24511: PPUSH
24512: LD_INT 84
24514: PPUSH
24515: CALL 9970 0 2
24519: PUSH
24520: LD_VAR 0 66
24524: PUSH
24525: LD_INT 1
24527: ARRAY
24528: PPUSH
24529: LD_VAR 0 66
24533: PUSH
24534: LD_INT 2
24536: ARRAY
24537: PPUSH
24538: LD_VAR 0 66
24542: PUSH
24543: LD_INT 3
24545: ARRAY
24546: PPUSH
24547: LD_VAR 0 66
24551: PUSH
24552: LD_INT 4
24554: ARRAY
24555: PPUSH
24556: CALL 16084 0 4
24560: GREATEREQUAL
24561: IFFALSE 24669
// begin en := SelectEnemy ( side , enemy_list ) ;
24563: LD_ADDR_VAR 0 14
24567: PUSH
24568: LD_VAR 0 10
24572: PPUSH
24573: LD_VAR 0 42
24577: PPUSH
24578: CALL 16000 0 2
24582: ST_TO_ADDR
// tmp := Tag_List ( vehicles , 84 ) ;
24583: LD_ADDR_VAR 0 13
24587: PUSH
24588: LD_VAR 0 12
24592: PPUSH
24593: LD_INT 84
24595: PPUSH
24596: CALL 9970 0 2
24600: ST_TO_ADDR
// for i = 1 to tmp do
24601: LD_ADDR_VAR 0 1
24605: PUSH
24606: DOUBLE
24607: LD_INT 1
24609: DEC
24610: ST_TO_ADDR
24611: LD_VAR 0 13
24615: PUSH
24616: FOR_TO
24617: IFFALSE 24667
// Attack ( tmp [ i ] , enemy_list [ en ] , enemy_xy [ en ] , attack_info [ 5 ] ) ;
24619: LD_VAR 0 13
24623: PUSH
24624: LD_VAR 0 1
24628: ARRAY
24629: PPUSH
24630: LD_VAR 0 42
24634: PUSH
24635: LD_VAR 0 14
24639: ARRAY
24640: PPUSH
24641: LD_VAR 0 15
24645: PUSH
24646: LD_VAR 0 14
24650: ARRAY
24651: PPUSH
24652: LD_VAR 0 66
24656: PUSH
24657: LD_INT 5
24659: ARRAY
24660: PPUSH
24661: CALL 14958 0 4
24665: GO 24616
24667: POP
24668: POP
// end ; if eng and base_status = false then
24669: LD_VAR 0 4
24673: PUSH
24674: LD_VAR 0 61
24678: PUSH
24679: LD_INT 0
24681: EQUAL
24682: AND
24683: IFFALSE 29309
// begin VehicleMove ( side , parking_area , 83 , back , [ ] ) ;
24685: LD_VAR 0 10
24689: PPUSH
24690: LD_VAR 0 55
24694: PPUSH
24695: LD_INT 83
24697: PPUSH
24698: LD_STRING back
24700: PPUSH
24701: EMPTY
24702: PPUSH
24703: CALL 14244 0 5
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
24707: LD_INT 22
24709: PUSH
24710: LD_VAR 0 10
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PUSH
24719: LD_INT 21
24721: PUSH
24722: LD_INT 1
24724: PUSH
24725: EMPTY
24726: LIST
24727: LIST
24728: PUSH
24729: LD_INT 3
24731: PUSH
24732: LD_INT 24
24734: PUSH
24735: LD_INT 1000
24737: PUSH
24738: EMPTY
24739: LIST
24740: LIST
24741: PUSH
24742: EMPTY
24743: LIST
24744: LIST
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: LIST
24750: PPUSH
24751: CALL_OW 69
24755: IFFALSE 24769
// HealPersonel ( side , 99 ) ;
24757: LD_VAR 0 10
24761: PPUSH
24762: LD_INT 99
24764: PPUSH
24765: CALL 12655 0 2
// if FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) then
24769: LD_INT 22
24771: PUSH
24772: LD_VAR 0 10
24776: PUSH
24777: EMPTY
24778: LIST
24779: LIST
24780: PUSH
24781: LD_INT 21
24783: PUSH
24784: LD_INT 3
24786: PUSH
24787: EMPTY
24788: LIST
24789: LIST
24790: PUSH
24791: LD_INT 3
24793: PUSH
24794: LD_INT 24
24796: PUSH
24797: LD_INT 1000
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: PUSH
24804: EMPTY
24805: LIST
24806: LIST
24807: PUSH
24808: EMPTY
24809: LIST
24810: LIST
24811: LIST
24812: PPUSH
24813: CALL_OW 69
24817: IFFALSE 24853
// RepairBase ( side , enemy_list , xy_back [ 1 ] , xy_back [ 2 ] ) else
24819: LD_VAR 0 10
24823: PPUSH
24824: LD_VAR 0 42
24828: PPUSH
24829: LD_VAR 0 41
24833: PUSH
24834: LD_INT 1
24836: ARRAY
24837: PPUSH
24838: LD_VAR 0 41
24842: PUSH
24843: LD_INT 2
24845: ARRAY
24846: PPUSH
24847: CALL 11363 0 4
24851: GO 29309
// if NeedBase ( side ) then
24853: LD_VAR 0 10
24857: PPUSH
24858: CALL 1120 0 1
24862: IFFALSE 24902
// ComBuildDepot ( eng , depot_xy [ 1 ] , depot_xy [ 2 ] , depot_xy [ 3 ] ) else
24864: LD_VAR 0 4
24868: PPUSH
24869: LD_VAR 0 16
24873: PUSH
24874: LD_INT 1
24876: ARRAY
24877: PPUSH
24878: LD_VAR 0 16
24882: PUSH
24883: LD_INT 2
24885: ARRAY
24886: PPUSH
24887: LD_VAR 0 16
24891: PUSH
24892: LD_INT 3
24894: ARRAY
24895: PPUSH
24896: CALL 2033 0 4
24900: GO 29309
// begin FinishAllBuilds ( side ) ;
24902: LD_VAR 0 10
24906: PPUSH
24907: CALL 12861 0 1
// if second_base_allow and tick >= build_second_base_after [ 1 ] and GetTech ( build_second_base_after [ 2 ] , side ) = state_researched and HexInfo ( second_base_xy [ 1 ] , second_base_xy [ 2 ] ) = 0 then
24911: LD_VAR 0 56
24915: PUSH
24916: LD_OWVAR 1
24920: PUSH
24921: LD_VAR 0 59
24925: PUSH
24926: LD_INT 1
24928: ARRAY
24929: GREATEREQUAL
24930: AND
24931: PUSH
24932: LD_VAR 0 59
24936: PUSH
24937: LD_INT 2
24939: ARRAY
24940: PPUSH
24941: LD_VAR 0 10
24945: PPUSH
24946: CALL_OW 321
24950: PUSH
24951: LD_INT 2
24953: EQUAL
24954: AND
24955: PUSH
24956: LD_VAR 0 57
24960: PUSH
24961: LD_INT 1
24963: ARRAY
24964: PPUSH
24965: LD_VAR 0 57
24969: PUSH
24970: LD_INT 2
24972: ARRAY
24973: PPUSH
24974: CALL_OW 428
24978: PUSH
24979: LD_INT 0
24981: EQUAL
24982: AND
24983: IFFALSE 25021
// ComBuildDepot ( eng , second_base_xy [ 1 ] , second_base_xy [ 2 ] , second_base_xy [ 3 ] ) ;
24985: LD_VAR 0 4
24989: PPUSH
24990: LD_VAR 0 57
24994: PUSH
24995: LD_INT 1
24997: ARRAY
24998: PPUSH
24999: LD_VAR 0 57
25003: PUSH
25004: LD_INT 2
25006: ARRAY
25007: PPUSH
25008: LD_VAR 0 57
25012: PUSH
25013: LD_INT 3
25015: ARRAY
25016: PPUSH
25017: CALL 2033 0 4
// if second_base_allow and GetBType ( HexInfo ( second_base_xy [ 1 ] , second_base_xy [ 2 ] ) ) = b_depot and transport_from_second_base [ 1 ] then
25021: LD_VAR 0 56
25025: PUSH
25026: LD_VAR 0 57
25030: PUSH
25031: LD_INT 1
25033: ARRAY
25034: PPUSH
25035: LD_VAR 0 57
25039: PUSH
25040: LD_INT 2
25042: ARRAY
25043: PPUSH
25044: CALL_OW 428
25048: PPUSH
25049: CALL_OW 266
25053: PUSH
25054: LD_INT 0
25056: EQUAL
25057: AND
25058: PUSH
25059: LD_VAR 0 58
25063: PUSH
25064: LD_INT 1
25066: ARRAY
25067: AND
25068: IFFALSE 25201
// begin for i = 1 to 3 do
25070: LD_ADDR_VAR 0 1
25074: PUSH
25075: DOUBLE
25076: LD_INT 1
25078: DEC
25079: ST_TO_ADDR
25080: LD_INT 3
25082: PUSH
25083: FOR_TO
25084: IFFALSE 25199
// if GetBaseSource ( HexInfo ( second_base_xy [ 1 ] , second_base_xy [ 2 ] ) ) [ i ] > transport_from_second_base [ 2 ] then
25086: LD_VAR 0 57
25090: PUSH
25091: LD_INT 1
25093: ARRAY
25094: PPUSH
25095: LD_VAR 0 57
25099: PUSH
25100: LD_INT 2
25102: ARRAY
25103: PPUSH
25104: CALL_OW 428
25108: PPUSH
25109: CALL 866 0 1
25113: PUSH
25114: LD_VAR 0 1
25118: ARRAY
25119: PUSH
25120: LD_VAR 0 58
25124: PUSH
25125: LD_INT 2
25127: ARRAY
25128: GREATER
25129: IFFALSE 25197
// begin Transport ( eng [ 1 ] , HexInfo ( second_base_xy [ 1 ] , second_base_xy [ 2 ] ) , HexInfo ( depot_xy [ 1 ] , depot_xy [ 2 ] ) , i ) ;
25131: LD_VAR 0 4
25135: PUSH
25136: LD_INT 1
25138: ARRAY
25139: PPUSH
25140: LD_VAR 0 57
25144: PUSH
25145: LD_INT 1
25147: ARRAY
25148: PPUSH
25149: LD_VAR 0 57
25153: PUSH
25154: LD_INT 2
25156: ARRAY
25157: PPUSH
25158: CALL_OW 428
25162: PPUSH
25163: LD_VAR 0 16
25167: PUSH
25168: LD_INT 1
25170: ARRAY
25171: PPUSH
25172: LD_VAR 0 16
25176: PUSH
25177: LD_INT 2
25179: ARRAY
25180: PPUSH
25181: CALL_OW 428
25185: PPUSH
25186: LD_VAR 0 1
25190: PPUSH
25191: CALL 13743 0 4
// break ;
25195: GO 25199
// end ;
25197: GO 25083
25199: POP
25200: POP
// end ; if NeedBuilding ( side , GetBuilding ( side , b_depot ) ) then
25201: LD_VAR 0 10
25205: PPUSH
25206: LD_VAR 0 10
25210: PPUSH
25211: LD_INT 0
25213: PPUSH
25214: CALL 1265 0 2
25218: PPUSH
25219: CALL 1042 0 2
25223: IFFALSE 25251
// ComBuildWarehouse ( eng , GetBuilding ( side , b_depot ) [ 1 ] ) ;
25225: LD_VAR 0 4
25229: PPUSH
25230: LD_VAR 0 10
25234: PPUSH
25235: LD_INT 0
25237: PPUSH
25238: CALL 1265 0 2
25242: PUSH
25243: LD_INT 1
25245: ARRAY
25246: PPUSH
25247: CALL 2131 0 2
// ComBuildLabList ( eng , [ [ lab_xy [ 1 ] , lab_xy [ 2 ] , lab_xy [ 3 ] , lab_kind [ 1 ] , lab_kind [ 2 ] ] , [ lab_xy [ 4 ] , lab_xy [ 5 ] , lab_xy [ 6 ] , lab_kind [ 3 ] , lab_kind [ 4 ] ] ] ) ;
25251: LD_VAR 0 4
25255: PPUSH
25256: LD_VAR 0 17
25260: PUSH
25261: LD_INT 1
25263: ARRAY
25264: PUSH
25265: LD_VAR 0 17
25269: PUSH
25270: LD_INT 2
25272: ARRAY
25273: PUSH
25274: LD_VAR 0 17
25278: PUSH
25279: LD_INT 3
25281: ARRAY
25282: PUSH
25283: LD_VAR 0 20
25287: PUSH
25288: LD_INT 1
25290: ARRAY
25291: PUSH
25292: LD_VAR 0 20
25296: PUSH
25297: LD_INT 2
25299: ARRAY
25300: PUSH
25301: EMPTY
25302: LIST
25303: LIST
25304: LIST
25305: LIST
25306: LIST
25307: PUSH
25308: LD_VAR 0 17
25312: PUSH
25313: LD_INT 4
25315: ARRAY
25316: PUSH
25317: LD_VAR 0 17
25321: PUSH
25322: LD_INT 5
25324: ARRAY
25325: PUSH
25326: LD_VAR 0 17
25330: PUSH
25331: LD_INT 6
25333: ARRAY
25334: PUSH
25335: LD_VAR 0 20
25339: PUSH
25340: LD_INT 3
25342: ARRAY
25343: PUSH
25344: LD_VAR 0 20
25348: PUSH
25349: LD_INT 4
25351: ARRAY
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: LIST
25358: LIST
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: PPUSH
25364: CALL 3634 0 2
// if GetBuilding ( side , b_lab_full ) and sci then
25368: LD_VAR 0 10
25372: PPUSH
25373: LD_INT 8
25375: PPUSH
25376: CALL 1265 0 2
25380: PUSH
25381: LD_VAR 0 6
25385: AND
25386: IFFALSE 25736
// begin for p = 1 to GetLabs ( side ) do
25388: LD_ADDR_VAR 0 2
25392: PUSH
25393: DOUBLE
25394: LD_INT 1
25396: DEC
25397: ST_TO_ADDR
25398: LD_VAR 0 10
25402: PPUSH
25403: CALL 1416 0 1
25407: PUSH
25408: FOR_TO
25409: IFFALSE 25488
// if BuildingStatus ( GetLabs ( side ) [ p ] ) = bs_working or BuildingStatus ( GetLabs ( side ) [ p ] ) = bs_need_people then
25411: LD_VAR 0 10
25415: PPUSH
25416: CALL 1416 0 1
25420: PUSH
25421: LD_VAR 0 2
25425: ARRAY
25426: PPUSH
25427: CALL_OW 461
25431: PUSH
25432: LD_INT 3
25434: EQUAL
25435: PUSH
25436: LD_VAR 0 10
25440: PPUSH
25441: CALL 1416 0 1
25445: PUSH
25446: LD_VAR 0 2
25450: ARRAY
25451: PPUSH
25452: CALL_OW 461
25456: PUSH
25457: LD_INT 6
25459: EQUAL
25460: OR
25461: IFFALSE 25486
// begin lab := GetLabs ( side ) [ p ] ;
25463: LD_ADDR_VAR 0 60
25467: PUSH
25468: LD_VAR 0 10
25472: PPUSH
25473: CALL 1416 0 1
25477: PUSH
25478: LD_VAR 0 2
25482: ARRAY
25483: ST_TO_ADDR
// break ;
25484: GO 25488
// end ;
25486: GO 25408
25488: POP
25489: POP
// if not lab then
25490: LD_VAR 0 60
25494: NOT
25495: IFFALSE 25516
// lab := GetLabs ( side ) [ 1 ] ;
25497: LD_ADDR_VAR 0 60
25501: PUSH
25502: LD_VAR 0 10
25506: PPUSH
25507: CALL 1416 0 1
25511: PUSH
25512: LD_INT 1
25514: ARRAY
25515: ST_TO_ADDR
// if Tag_List ( sold ^ eng ^ mech ^ sci , 99 ) = 0 then
25516: LD_VAR 0 3
25520: PUSH
25521: LD_VAR 0 4
25525: ADD
25526: PUSH
25527: LD_VAR 0 5
25531: ADD
25532: PUSH
25533: LD_VAR 0 6
25537: ADD
25538: PPUSH
25539: LD_INT 99
25541: PPUSH
25542: CALL 9970 0 2
25546: PUSH
25547: LD_INT 0
25549: EQUAL
25550: IFFALSE 25706
// for i = 1 to sci do
25552: LD_ADDR_VAR 0 1
25556: PUSH
25557: DOUBLE
25558: LD_INT 1
25560: DEC
25561: ST_TO_ADDR
25562: LD_VAR 0 6
25566: PUSH
25567: FOR_TO
25568: IFFALSE 25704
// if not IsInUnit ( sci [ i ] ) = lab and not HasTask ( sci [ i ] ) and GetTag ( sci [ i ] ) = 0 and BuildingStatus ( lab ) <> bs_build then
25570: LD_VAR 0 6
25574: PUSH
25575: LD_VAR 0 1
25579: ARRAY
25580: PPUSH
25581: CALL_OW 310
25585: PUSH
25586: LD_VAR 0 60
25590: EQUAL
25591: NOT
25592: PUSH
25593: LD_VAR 0 6
25597: PUSH
25598: LD_VAR 0 1
25602: ARRAY
25603: PPUSH
25604: CALL_OW 314
25608: NOT
25609: AND
25610: PUSH
25611: LD_VAR 0 6
25615: PUSH
25616: LD_VAR 0 1
25620: ARRAY
25621: PPUSH
25622: CALL_OW 110
25626: PUSH
25627: LD_INT 0
25629: EQUAL
25630: AND
25631: PUSH
25632: LD_VAR 0 60
25636: PPUSH
25637: CALL_OW 461
25641: PUSH
25642: LD_INT 1
25644: NONEQUAL
25645: AND
25646: IFFALSE 25702
// if IsInUnit ( sci [ i ] ) then
25648: LD_VAR 0 6
25652: PUSH
25653: LD_VAR 0 1
25657: ARRAY
25658: PPUSH
25659: CALL_OW 310
25663: IFFALSE 25682
// ComExitBuilding ( sci [ i ] ) else
25665: LD_VAR 0 6
25669: PUSH
25670: LD_VAR 0 1
25674: ARRAY
25675: PPUSH
25676: CALL_OW 122
25680: GO 25702
// ComEnterUnit ( sci [ i ] , lab ) ;
25682: LD_VAR 0 6
25686: PUSH
25687: LD_VAR 0 1
25691: ARRAY
25692: PPUSH
25693: LD_VAR 0 60
25697: PPUSH
25698: CALL_OW 120
25702: GO 25567
25704: POP
25705: POP
// if not BuildingStatus ( lab ) = bs_build then
25706: LD_VAR 0 60
25710: PPUSH
25711: CALL_OW 461
25715: PUSH
25716: LD_INT 1
25718: EQUAL
25719: NOT
25720: IFFALSE 25736
// ResearchTechList ( side , tech_list ) ;
25722: LD_VAR 0 10
25726: PPUSH
25727: LD_VAR 0 24
25731: PPUSH
25732: CALL 1632 0 2
// end ; BuildFactory ( eng , fac_xy [ 1 ] , fac_xy [ 2 ] , fac_xy [ 3 ] , fac_ext ) ;
25736: LD_VAR 0 4
25740: PPUSH
25741: LD_VAR 0 18
25745: PUSH
25746: LD_INT 1
25748: ARRAY
25749: PPUSH
25750: LD_VAR 0 18
25754: PUSH
25755: LD_INT 2
25757: ARRAY
25758: PPUSH
25759: LD_VAR 0 18
25763: PUSH
25764: LD_INT 3
25766: ARRAY
25767: PPUSH
25768: LD_VAR 0 21
25772: PPUSH
25773: CALL 6442 0 5
// if mech and GetBuilding ( side , b_factory ) then
25777: LD_VAR 0 5
25781: PUSH
25782: LD_VAR 0 10
25786: PPUSH
25787: LD_INT 3
25789: PPUSH
25790: CALL 1265 0 2
25794: AND
25795: IFFALSE 27720
// begin for i = 1 to mech do
25797: LD_ADDR_VAR 0 1
25801: PUSH
25802: DOUBLE
25803: LD_INT 1
25805: DEC
25806: ST_TO_ADDR
25807: LD_VAR 0 5
25811: PUSH
25812: FOR_TO
25813: IFFALSE 25994
// if not IsInUnit ( mech [ i ] ) and not HasTask ( mech [ i ] ) and GetTag ( mech [ i ] ) = 0 and FilterAllUnits ( [ [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 450 ] ] , [ f_distxy , repair_xy [ 1 ] , repair_xy [ 2 ] , 10 ] ] ] ) = 0 then
25815: LD_VAR 0 5
25819: PUSH
25820: LD_VAR 0 1
25824: ARRAY
25825: PPUSH
25826: CALL_OW 310
25830: NOT
25831: PUSH
25832: LD_VAR 0 5
25836: PUSH
25837: LD_VAR 0 1
25841: ARRAY
25842: PPUSH
25843: CALL_OW 314
25847: NOT
25848: AND
25849: PUSH
25850: LD_VAR 0 5
25854: PUSH
25855: LD_VAR 0 1
25859: ARRAY
25860: PPUSH
25861: CALL_OW 110
25865: PUSH
25866: LD_INT 0
25868: EQUAL
25869: AND
25870: PUSH
25871: LD_INT 22
25873: PUSH
25874: LD_VAR 0 10
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 21
25885: PUSH
25886: LD_INT 2
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 3
25895: PUSH
25896: LD_INT 24
25898: PUSH
25899: LD_INT 450
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: PUSH
25906: EMPTY
25907: LIST
25908: LIST
25909: PUSH
25910: LD_INT 92
25912: PUSH
25913: LD_VAR 0 64
25917: PUSH
25918: LD_INT 1
25920: ARRAY
25921: PUSH
25922: LD_VAR 0 64
25926: PUSH
25927: LD_INT 2
25929: ARRAY
25930: PUSH
25931: LD_INT 10
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: LIST
25938: LIST
25939: PUSH
25940: EMPTY
25941: LIST
25942: LIST
25943: LIST
25944: LIST
25945: PUSH
25946: EMPTY
25947: LIST
25948: PPUSH
25949: CALL_OW 69
25953: PUSH
25954: LD_INT 0
25956: EQUAL
25957: AND
25958: IFFALSE 25992
// ComEnterUnit ( mech [ i ] , GetBuilding ( side , b_factory ) [ 1 ] ) ;
25960: LD_VAR 0 5
25964: PUSH
25965: LD_VAR 0 1
25969: ARRAY
25970: PPUSH
25971: LD_VAR 0 10
25975: PPUSH
25976: LD_INT 3
25978: PPUSH
25979: CALL 1265 0 2
25983: PUSH
25984: LD_INT 1
25986: ARRAY
25987: PPUSH
25988: CALL_OW 120
25992: GO 25812
25994: POP
25995: POP
// CheckTowersStatus ( eng , turret_xy ) ;
25996: LD_VAR 0 4
26000: PPUSH
26001: LD_VAR 0 19
26005: PPUSH
26006: CALL 2673 0 2
// turret_weapon := AvailableWeaponList ( GetBuilding ( side , b_factory ) [ 1 ] ) diff not_turret_weapon ;
26010: LD_ADDR_VAR 0 32
26014: PUSH
26015: LD_VAR 0 10
26019: PPUSH
26020: LD_INT 3
26022: PPUSH
26023: CALL 1265 0 2
26027: PUSH
26028: LD_INT 1
26030: ARRAY
26031: PPUSH
26032: CALL_OW 478
26036: PUSH
26037: LD_VAR 0 33
26041: DIFF
26042: ST_TO_ADDR
// if ( GetBuilding ( side , b_bunker ) > 0 or GetBuilding ( side , b_turret ) > 0 ) and turret_weapon > 1 then
26043: LD_VAR 0 10
26047: PPUSH
26048: LD_INT 32
26050: PPUSH
26051: CALL 1265 0 2
26055: PUSH
26056: LD_INT 0
26058: GREATER
26059: PUSH
26060: LD_VAR 0 10
26064: PPUSH
26065: LD_INT 33
26067: PPUSH
26068: CALL 1265 0 2
26072: PUSH
26073: LD_INT 0
26075: GREATER
26076: OR
26077: PUSH
26078: LD_VAR 0 32
26082: PUSH
26083: LD_INT 1
26085: GREATER
26086: AND
26087: IFFALSE 26103
// CheckWeaponOnTowers ( side , turret_weapon ) ;
26089: LD_VAR 0 10
26093: PPUSH
26094: LD_VAR 0 32
26098: PPUSH
26099: CALL 2964 0 2
// if GetVehicle ( side , cargo_chassis , cargo_type [ 1 ] ) = 0 and ( GetBuilding ( side , b_ext_noncombat ) or GetBuilding ( side , b_ext_stitch ) ) and cargo_allow then
26103: LD_VAR 0 10
26107: PPUSH
26108: LD_VAR 0 36
26112: PPUSH
26113: LD_VAR 0 37
26117: PUSH
26118: LD_INT 1
26120: ARRAY
26121: PPUSH
26122: CALL 3112 0 3
26126: PUSH
26127: LD_INT 0
26129: EQUAL
26130: PUSH
26131: LD_VAR 0 10
26135: PPUSH
26136: LD_INT 19
26138: PPUSH
26139: CALL 1265 0 2
26143: PUSH
26144: LD_VAR 0 10
26148: PPUSH
26149: LD_INT 23
26151: PPUSH
26152: CALL 1265 0 2
26156: OR
26157: AND
26158: PUSH
26159: LD_VAR 0 35
26163: AND
26164: IFFALSE 26191
// IntConstruct ( side , cargo_chassis , engine_combustion , control_manual , cargo_type ) ;
26166: LD_VAR 0 10
26170: PPUSH
26171: LD_VAR 0 36
26175: PPUSH
26176: LD_INT 1
26178: PPUSH
26179: LD_INT 1
26181: PPUSH
26182: LD_VAR 0 37
26186: PPUSH
26187: CALL 13272 0 5
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_control , control_manual ] , [ f_weapon , cargo_type [ 1 ] ] ] ] ) = 1 and modernize_cargo_allow and ( ( GetBuilding ( side , b_ext_radar ) and ( GetBuilding ( side , b_control_tower ) or FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ) ) or GetBuilding ( side , b_ext_computer ) ) then
26191: LD_INT 22
26193: PUSH
26194: LD_VAR 0 10
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: PUSH
26203: LD_INT 33
26205: PUSH
26206: LD_INT 1
26208: PUSH
26209: EMPTY
26210: LIST
26211: LIST
26212: PUSH
26213: LD_INT 34
26215: PUSH
26216: LD_VAR 0 37
26220: PUSH
26221: LD_INT 1
26223: ARRAY
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: PUSH
26229: EMPTY
26230: LIST
26231: LIST
26232: LIST
26233: PUSH
26234: EMPTY
26235: LIST
26236: PPUSH
26237: CALL_OW 69
26241: PUSH
26242: LD_INT 1
26244: EQUAL
26245: PUSH
26246: LD_VAR 0 43
26250: AND
26251: PUSH
26252: LD_VAR 0 10
26256: PPUSH
26257: LD_INT 20
26259: PPUSH
26260: CALL 1265 0 2
26264: PUSH
26265: LD_VAR 0 10
26269: PPUSH
26270: LD_INT 36
26272: PPUSH
26273: CALL 1265 0 2
26277: PUSH
26278: LD_INT 22
26280: PUSH
26281: LD_VAR 0 10
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: PUSH
26290: LD_INT 34
26292: PUSH
26293: LD_INT 31
26295: PUSH
26296: EMPTY
26297: LIST
26298: LIST
26299: PUSH
26300: EMPTY
26301: LIST
26302: LIST
26303: PPUSH
26304: CALL_OW 69
26308: OR
26309: AND
26310: PUSH
26311: LD_VAR 0 10
26315: PPUSH
26316: LD_INT 24
26318: PPUSH
26319: CALL 1265 0 2
26323: OR
26324: AND
26325: IFFALSE 26411
// begin SetTag ( GetVehicle ( side , cargo_chassis , cargo_type [ 1 ] ) [ 1 ] , 51 ) ;
26327: LD_VAR 0 10
26331: PPUSH
26332: LD_VAR 0 36
26336: PPUSH
26337: LD_VAR 0 37
26341: PUSH
26342: LD_INT 1
26344: ARRAY
26345: PPUSH
26346: CALL 3112 0 3
26350: PUSH
26351: LD_INT 1
26353: ARRAY
26354: PPUSH
26355: LD_INT 51
26357: PPUSH
26358: CALL_OW 109
// ComRecycle ( GetVehicle ( side , cargo_chassis , cargo_type [ 1 ] ) [ 1 ] , GetBuilding ( side , b_factory ) [ 1 ] ) ;
26362: LD_VAR 0 10
26366: PPUSH
26367: LD_VAR 0 36
26371: PPUSH
26372: LD_VAR 0 37
26376: PUSH
26377: LD_INT 1
26379: ARRAY
26380: PPUSH
26381: CALL 3112 0 3
26385: PUSH
26386: LD_INT 1
26388: ARRAY
26389: PPUSH
26390: LD_VAR 0 10
26394: PPUSH
26395: LD_INT 3
26397: PPUSH
26398: CALL 1265 0 2
26402: PUSH
26403: LD_INT 1
26405: ARRAY
26406: PPUSH
26407: CALL_OW 168
// end ; if GetVehicle ( side , crane_chassis , crane_type [ 1 ] ) < crane_num and ( GetBuilding ( side , b_ext_noncombat ) or GetBuilding ( side , b_ext_stitch ) ) and crane_allow then
26411: LD_VAR 0 10
26415: PPUSH
26416: LD_VAR 0 47
26420: PPUSH
26421: LD_VAR 0 45
26425: PUSH
26426: LD_INT 1
26428: ARRAY
26429: PPUSH
26430: CALL 3112 0 3
26434: PUSH
26435: LD_VAR 0 48
26439: LESS
26440: PUSH
26441: LD_VAR 0 10
26445: PPUSH
26446: LD_INT 19
26448: PPUSH
26449: CALL 1265 0 2
26453: PUSH
26454: LD_VAR 0 10
26458: PPUSH
26459: LD_INT 23
26461: PPUSH
26462: CALL 1265 0 2
26466: OR
26467: AND
26468: PUSH
26469: LD_VAR 0 44
26473: AND
26474: IFFALSE 26503
// IntConstruct ( side , crane_chassis , crane_engine , control_manual , crane_type ) ;
26476: LD_VAR 0 10
26480: PPUSH
26481: LD_VAR 0 47
26485: PPUSH
26486: LD_VAR 0 46
26490: PPUSH
26491: LD_INT 1
26493: PPUSH
26494: LD_VAR 0 45
26498: PPUSH
26499: CALL 13272 0 5
// if FilterAllUnits ( [ [ [ f_side , side ] , [ f_control , control_manual ] , [ f_weapon , crane_type [ 1 ] ] ] ] ) and modernize_crane_allow and ( ( GetBuilding ( side , b_ext_radar ) and ( GetBuilding ( side , b_control_tower ) or FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , ar_control_tower ] ] ) ) ) or GetBuilding ( side , b_ext_computer ) ) then
26503: LD_INT 22
26505: PUSH
26506: LD_VAR 0 10
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: PUSH
26515: LD_INT 33
26517: PUSH
26518: LD_INT 1
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: PUSH
26525: LD_INT 34
26527: PUSH
26528: LD_VAR 0 45
26532: PUSH
26533: LD_INT 1
26535: ARRAY
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: EMPTY
26542: LIST
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: PPUSH
26549: CALL_OW 69
26553: PUSH
26554: LD_VAR 0 49
26558: AND
26559: PUSH
26560: LD_VAR 0 10
26564: PPUSH
26565: LD_INT 20
26567: PPUSH
26568: CALL 1265 0 2
26572: PUSH
26573: LD_VAR 0 10
26577: PPUSH
26578: LD_INT 36
26580: PPUSH
26581: CALL 1265 0 2
26585: PUSH
26586: LD_INT 22
26588: PUSH
26589: LD_VAR 0 10
26593: PUSH
26594: EMPTY
26595: LIST
26596: LIST
26597: PUSH
26598: LD_INT 34
26600: PUSH
26601: LD_INT 31
26603: PUSH
26604: EMPTY
26605: LIST
26606: LIST
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PPUSH
26612: CALL_OW 69
26616: OR
26617: AND
26618: PUSH
26619: LD_VAR 0 10
26623: PPUSH
26624: LD_INT 24
26626: PPUSH
26627: CALL 1265 0 2
26631: OR
26632: AND
26633: IFFALSE 26719
// begin SetTag ( GetVehicle ( side , crane_chassis , crane_type [ 1 ] ) [ 1 ] , 51 ) ;
26635: LD_VAR 0 10
26639: PPUSH
26640: LD_VAR 0 47
26644: PPUSH
26645: LD_VAR 0 45
26649: PUSH
26650: LD_INT 1
26652: ARRAY
26653: PPUSH
26654: CALL 3112 0 3
26658: PUSH
26659: LD_INT 1
26661: ARRAY
26662: PPUSH
26663: LD_INT 51
26665: PPUSH
26666: CALL_OW 109
// ComRecycle ( GetVehicle ( side , crane_chassis , crane_type [ 1 ] ) [ 1 ] , GetBuilding ( side , b_factory ) [ 1 ] ) ;
26670: LD_VAR 0 10
26674: PPUSH
26675: LD_VAR 0 47
26679: PPUSH
26680: LD_VAR 0 45
26684: PUSH
26685: LD_INT 1
26687: ARRAY
26688: PPUSH
26689: CALL 3112 0 3
26693: PUSH
26694: LD_INT 1
26696: ARRAY
26697: PPUSH
26698: LD_VAR 0 10
26702: PPUSH
26703: LD_INT 3
26705: PPUSH
26706: CALL 1265 0 2
26710: PUSH
26711: LD_INT 1
26713: ARRAY
26714: PPUSH
26715: CALL_OW 168
// end ; if GetVehicle ( side , bulldozer_chassis , bulldozer_type [ 1 ] ) = 0 and bulldozer_allow and ListEnvironmentArea ( tree_area ) > 0 then
26719: LD_VAR 0 10
26723: PPUSH
26724: LD_VAR 0 51
26728: PPUSH
26729: LD_VAR 0 53
26733: PUSH
26734: LD_INT 1
26736: ARRAY
26737: PPUSH
26738: CALL 3112 0 3
26742: PUSH
26743: LD_INT 0
26745: EQUAL
26746: PUSH
26747: LD_VAR 0 50
26751: AND
26752: PUSH
26753: LD_VAR 0 54
26757: PPUSH
26758: CALL_OW 353
26762: PUSH
26763: LD_INT 0
26765: GREATER
26766: AND
26767: IFFALSE 26798
// IntConstruct ( side , bulldozer_chassis , bulldozer_engine , control_manual , bulldozer_type ) else
26769: LD_VAR 0 10
26773: PPUSH
26774: LD_VAR 0 51
26778: PPUSH
26779: LD_VAR 0 52
26783: PPUSH
26784: LD_INT 1
26786: PPUSH
26787: LD_VAR 0 53
26791: PPUSH
26792: CALL 13272 0 5
26796: GO 26922
// if GetVehicle ( side , bulldozer_chassis , bulldozer_type [ 1 ] ) then
26798: LD_VAR 0 10
26802: PPUSH
26803: LD_VAR 0 51
26807: PPUSH
26808: LD_VAR 0 53
26812: PUSH
26813: LD_INT 1
26815: ARRAY
26816: PPUSH
26817: CALL 3112 0 3
26821: IFFALSE 26922
// begin if ListEnvironmentArea ( tree_area ) then
26823: LD_VAR 0 54
26827: PPUSH
26828: CALL_OW 353
26832: IFFALSE 26873
// CutTreeInArea ( GetVehicle ( side , bulldozer_chassis , bulldozer_type [ 1 ] ) [ 1 ] , tree_area ) else
26834: LD_VAR 0 10
26838: PPUSH
26839: LD_VAR 0 51
26843: PPUSH
26844: LD_VAR 0 53
26848: PUSH
26849: LD_INT 1
26851: ARRAY
26852: PPUSH
26853: CALL 3112 0 3
26857: PUSH
26858: LD_INT 1
26860: ARRAY
26861: PPUSH
26862: LD_VAR 0 54
26866: PPUSH
26867: CALL 607 0 2
26871: GO 26922
// ComRecycle ( GetVehicle ( side , bulldozer_chassis , bulldozer_type [ 1 ] ) [ 1 ] , GetBuilding ( side , b_factory ) [ 1 ] ) ;
26873: LD_VAR 0 10
26877: PPUSH
26878: LD_VAR 0 51
26882: PPUSH
26883: LD_VAR 0 53
26887: PUSH
26888: LD_INT 1
26890: ARRAY
26891: PPUSH
26892: CALL 3112 0 3
26896: PUSH
26897: LD_INT 1
26899: ARRAY
26900: PPUSH
26901: LD_VAR 0 10
26905: PPUSH
26906: LD_INT 3
26908: PPUSH
26909: CALL 1265 0 2
26913: PUSH
26914: LD_INT 1
26916: ARRAY
26917: PPUSH
26918: CALL_OW 168
// end ; if ( vehicles diff FilterNonCombatVehicle ( side ) ) < NumAtt ( attack_info [ 1 ] , attack_info [ 2 ] , attack_info [ 3 ] , attack_info [ 4 ] ) then
26922: LD_VAR 0 12
26926: PUSH
26927: LD_VAR 0 10
26931: PPUSH
26932: CALL 15846 0 1
26936: DIFF
26937: PUSH
26938: LD_VAR 0 66
26942: PUSH
26943: LD_INT 1
26945: ARRAY
26946: PPUSH
26947: LD_VAR 0 66
26951: PUSH
26952: LD_INT 2
26954: ARRAY
26955: PPUSH
26956: LD_VAR 0 66
26960: PUSH
26961: LD_INT 3
26963: ARRAY
26964: PPUSH
26965: LD_VAR 0 66
26969: PUSH
26970: LD_INT 4
26972: ARRAY
26973: PPUSH
26974: CALL 16084 0 4
26978: LESS
26979: IFFALSE 27628
// begin case vehicle_def [ 2 ] [ 1 ] of - :
26981: LD_VAR 0 65
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: PUSH
26990: LD_INT 1
26992: ARRAY
26993: PUSH
26994: LD_STRING -
26996: DOUBLE
26997: EQUAL
26998: IFTRUE 27002
27000: GO 27062
27002: POP
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_CARGO :
27003: LD_VAR 0 10
27007: PPUSH
27008: LD_VAR 0 65
27012: PUSH
27013: LD_INT 3
27015: ARRAY
27016: PUSH
27017: LD_INT 1
27019: ARRAY
27020: PPUSH
27021: LD_VAR 0 65
27025: PUSH
27026: LD_INT 3
27028: ARRAY
27029: PUSH
27030: LD_INT 2
27032: ARRAY
27033: PPUSH
27034: LD_VAR 0 65
27038: PUSH
27039: LD_INT 3
27041: ARRAY
27042: PUSH
27043: LD_INT 3
27045: ARRAY
27046: PPUSH
27047: LD_VAR 0 65
27051: PUSH
27052: LD_INT 4
27054: ARRAY
27055: PPUSH
27056: CALL 13272 0 5
27060: GO 27628
27062: LD_STRING after_CARGO
27064: DOUBLE
27065: EQUAL
27066: IFTRUE 27070
27068: GO 27189
27070: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , cargo_type [ 1 ] ] , [ f_control , vehicle_def [ 2 ] [ 2 ] ] ] ) then
27071: LD_INT 22
27073: PUSH
27074: LD_VAR 0 10
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 34
27085: PUSH
27086: LD_VAR 0 37
27090: PUSH
27091: LD_INT 1
27093: ARRAY
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: PUSH
27099: LD_INT 33
27101: PUSH
27102: LD_VAR 0 65
27106: PUSH
27107: LD_INT 2
27109: ARRAY
27110: PUSH
27111: LD_INT 2
27113: ARRAY
27114: PUSH
27115: EMPTY
27116: LIST
27117: LIST
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: LIST
27123: PPUSH
27124: CALL_OW 69
27128: IFFALSE 27187
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_CRANE :
27130: LD_VAR 0 10
27134: PPUSH
27135: LD_VAR 0 65
27139: PUSH
27140: LD_INT 3
27142: ARRAY
27143: PUSH
27144: LD_INT 1
27146: ARRAY
27147: PPUSH
27148: LD_VAR 0 65
27152: PUSH
27153: LD_INT 3
27155: ARRAY
27156: PUSH
27157: LD_INT 2
27159: ARRAY
27160: PPUSH
27161: LD_VAR 0 65
27165: PUSH
27166: LD_INT 3
27168: ARRAY
27169: PUSH
27170: LD_INT 3
27172: ARRAY
27173: PPUSH
27174: LD_VAR 0 65
27178: PUSH
27179: LD_INT 4
27181: ARRAY
27182: PPUSH
27183: CALL 13272 0 5
27187: GO 27628
27189: LD_STRING after_CRANE
27191: DOUBLE
27192: EQUAL
27193: IFTRUE 27197
27195: GO 27316
27197: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , crane_type [ 1 ] ] , [ f_control , vehicle_def [ 2 ] [ 2 ] ] ] ) then
27198: LD_INT 22
27200: PUSH
27201: LD_VAR 0 10
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 34
27212: PUSH
27213: LD_VAR 0 45
27217: PUSH
27218: LD_INT 1
27220: ARRAY
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 33
27228: PUSH
27229: LD_VAR 0 65
27233: PUSH
27234: LD_INT 2
27236: ARRAY
27237: PUSH
27238: LD_INT 2
27240: ARRAY
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: LIST
27250: PPUSH
27251: CALL_OW 69
27255: IFFALSE 27314
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_BULL :
27257: LD_VAR 0 10
27261: PPUSH
27262: LD_VAR 0 65
27266: PUSH
27267: LD_INT 3
27269: ARRAY
27270: PUSH
27271: LD_INT 1
27273: ARRAY
27274: PPUSH
27275: LD_VAR 0 65
27279: PUSH
27280: LD_INT 3
27282: ARRAY
27283: PUSH
27284: LD_INT 2
27286: ARRAY
27287: PPUSH
27288: LD_VAR 0 65
27292: PUSH
27293: LD_INT 3
27295: ARRAY
27296: PUSH
27297: LD_INT 3
27299: ARRAY
27300: PPUSH
27301: LD_VAR 0 65
27305: PUSH
27306: LD_INT 4
27308: ARRAY
27309: PPUSH
27310: CALL 13272 0 5
27314: GO 27628
27316: LD_STRING after_BULL
27318: DOUBLE
27319: EQUAL
27320: IFTRUE 27324
27322: GO 27443
27324: POP
// if FilterAllUnits ( [ [ f_side , side ] , [ f_weapon , bulldozer_type [ 1 ] ] , [ f_control , vehicle_def [ 2 ] [ 2 ] ] ] ) then
27325: LD_INT 22
27327: PUSH
27328: LD_VAR 0 10
27332: PUSH
27333: EMPTY
27334: LIST
27335: LIST
27336: PUSH
27337: LD_INT 34
27339: PUSH
27340: LD_VAR 0 53
27344: PUSH
27345: LD_INT 1
27347: ARRAY
27348: PUSH
27349: EMPTY
27350: LIST
27351: LIST
27352: PUSH
27353: LD_INT 33
27355: PUSH
27356: LD_VAR 0 65
27360: PUSH
27361: LD_INT 2
27363: ARRAY
27364: PUSH
27365: LD_INT 2
27367: ARRAY
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: LIST
27377: PPUSH
27378: CALL_OW 69
27382: IFFALSE 27441
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_TICK :
27384: LD_VAR 0 10
27388: PPUSH
27389: LD_VAR 0 65
27393: PUSH
27394: LD_INT 3
27396: ARRAY
27397: PUSH
27398: LD_INT 1
27400: ARRAY
27401: PPUSH
27402: LD_VAR 0 65
27406: PUSH
27407: LD_INT 3
27409: ARRAY
27410: PUSH
27411: LD_INT 2
27413: ARRAY
27414: PPUSH
27415: LD_VAR 0 65
27419: PUSH
27420: LD_INT 3
27422: ARRAY
27423: PUSH
27424: LD_INT 3
27426: ARRAY
27427: PPUSH
27428: LD_VAR 0 65
27432: PUSH
27433: LD_INT 4
27435: ARRAY
27436: PPUSH
27437: CALL 13272 0 5
27441: GO 27628
27443: LD_STRING after_TICK
27445: DOUBLE
27446: EQUAL
27447: IFTRUE 27451
27449: GO 27531
27451: POP
// if vehicle_def [ 2 ] [ 2 ] > tick then
27452: LD_VAR 0 65
27456: PUSH
27457: LD_INT 2
27459: ARRAY
27460: PUSH
27461: LD_INT 2
27463: ARRAY
27464: PUSH
27465: LD_OWVAR 1
27469: GREATER
27470: IFFALSE 27529
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; after_TECH :
27472: LD_VAR 0 10
27476: PPUSH
27477: LD_VAR 0 65
27481: PUSH
27482: LD_INT 3
27484: ARRAY
27485: PUSH
27486: LD_INT 1
27488: ARRAY
27489: PPUSH
27490: LD_VAR 0 65
27494: PUSH
27495: LD_INT 3
27497: ARRAY
27498: PUSH
27499: LD_INT 2
27501: ARRAY
27502: PPUSH
27503: LD_VAR 0 65
27507: PUSH
27508: LD_INT 3
27510: ARRAY
27511: PUSH
27512: LD_INT 3
27514: ARRAY
27515: PPUSH
27516: LD_VAR 0 65
27520: PUSH
27521: LD_INT 4
27523: ARRAY
27524: PPUSH
27525: CALL 13272 0 5
27529: GO 27628
27531: LD_STRING after_TECH
27533: DOUBLE
27534: EQUAL
27535: IFTRUE 27539
27537: GO 27627
27539: POP
// if GetTech ( vehicle_def [ 2 ] [ 2 ] , side ) = state_researched then
27540: LD_VAR 0 65
27544: PUSH
27545: LD_INT 2
27547: ARRAY
27548: PUSH
27549: LD_INT 2
27551: ARRAY
27552: PPUSH
27553: LD_VAR 0 10
27557: PPUSH
27558: CALL_OW 321
27562: PUSH
27563: LD_INT 2
27565: EQUAL
27566: IFFALSE 27625
// IntConstruct ( side , vehicle_def [ 3 ] [ 1 ] , vehicle_def [ 3 ] [ 2 ] , vehicle_def [ 3 ] [ 3 ] , vehicle_def [ 4 ] ) ; end ;
27568: LD_VAR 0 10
27572: PPUSH
27573: LD_VAR 0 65
27577: PUSH
27578: LD_INT 3
27580: ARRAY
27581: PUSH
27582: LD_INT 1
27584: ARRAY
27585: PPUSH
27586: LD_VAR 0 65
27590: PUSH
27591: LD_INT 3
27593: ARRAY
27594: PUSH
27595: LD_INT 2
27597: ARRAY
27598: PPUSH
27599: LD_VAR 0 65
27603: PUSH
27604: LD_INT 3
27606: ARRAY
27607: PUSH
27608: LD_INT 3
27610: ARRAY
27611: PPUSH
27612: LD_VAR 0 65
27616: PUSH
27617: LD_INT 4
27619: ARRAY
27620: PPUSH
27621: CALL 13272 0 5
27625: GO 27628
27627: POP
// end ; ControlTower ( side , GetNation ( mech [ 1 ] ) , ct_xy [ 1 ] , ct_xy [ 2 ] , ct_xy [ 3 ] , ct_chassis ) ;
27628: LD_VAR 0 10
27632: PPUSH
27633: LD_VAR 0 5
27637: PUSH
27638: LD_INT 1
27640: ARRAY
27641: PPUSH
27642: CALL_OW 248
27646: PPUSH
27647: LD_VAR 0 39
27651: PUSH
27652: LD_INT 1
27654: ARRAY
27655: PPUSH
27656: LD_VAR 0 39
27660: PUSH
27661: LD_INT 2
27663: ARRAY
27664: PPUSH
27665: LD_VAR 0 39
27669: PUSH
27670: LD_INT 3
27672: ARRAY
27673: PPUSH
27674: LD_VAR 0 40
27678: PPUSH
27679: CALL 10319 0 6
// if GetVehicle ( side , crane_chassis , crane_type [ 1 ] ) then
27683: LD_VAR 0 10
27687: PPUSH
27688: LD_VAR 0 47
27692: PPUSH
27693: LD_VAR 0 45
27697: PUSH
27698: LD_INT 1
27700: ARRAY
27701: PPUSH
27702: CALL 3112 0 3
27706: IFFALSE 27720
// AddMechanic ( eng , 1 ) ;
27708: LD_VAR 0 4
27712: PPUSH
27713: LD_INT 1
27715: PPUSH
27716: CALL 16231 0 2
// end ; if vehicles then
27720: LD_VAR 0 12
27724: IFFALSE 27968
// begin tmp := vehicles diff FilterNonCombatVehicle ( side ) ;
27726: LD_ADDR_VAR 0 13
27730: PUSH
27731: LD_VAR 0 12
27735: PUSH
27736: LD_VAR 0 10
27740: PPUSH
27741: CALL 15846 0 1
27745: DIFF
27746: ST_TO_ADDR
// if Tag_List ( tmp , 0 ) then
27747: LD_VAR 0 13
27751: PPUSH
27752: LD_INT 0
27754: PPUSH
27755: CALL 9970 0 2
27759: IFFALSE 27866
// for i = 1 to tmp do
27761: LD_ADDR_VAR 0 1
27765: PUSH
27766: DOUBLE
27767: LD_INT 1
27769: DEC
27770: ST_TO_ADDR
27771: LD_VAR 0 13
27775: PUSH
27776: FOR_TO
27777: IFFALSE 27864
// if GetTag ( tmp [ i ] ) = 0 then
27779: LD_VAR 0 13
27783: PUSH
27784: LD_VAR 0 1
27788: ARRAY
27789: PPUSH
27790: CALL_OW 110
27794: PUSH
27795: LD_INT 0
27797: EQUAL
27798: IFFALSE 27862
// begin if Tag_List ( vehicles , 83 ) < vehicle_def [ 1 ] then
27800: LD_VAR 0 12
27804: PPUSH
27805: LD_INT 83
27807: PPUSH
27808: CALL 9970 0 2
27812: PUSH
27813: LD_VAR 0 65
27817: PUSH
27818: LD_INT 1
27820: ARRAY
27821: LESS
27822: IFFALSE 27844
// SetTag ( tmp [ i ] , 83 ) else
27824: LD_VAR 0 13
27828: PUSH
27829: LD_VAR 0 1
27833: ARRAY
27834: PPUSH
27835: LD_INT 83
27837: PPUSH
27838: CALL_OW 109
27842: GO 27862
// SetTag ( tmp [ i ] , 82 ) ;
27844: LD_VAR 0 13
27848: PUSH
27849: LD_VAR 0 1
27853: ARRAY
27854: PPUSH
27855: LD_INT 82
27857: PPUSH
27858: CALL_OW 109
// end ;
27862: GO 27776
27864: POP
27865: POP
// if tick mod attack_info [ 3 ] = 0 then
27866: LD_OWVAR 1
27870: PUSH
27871: LD_VAR 0 66
27875: PUSH
27876: LD_INT 3
27878: ARRAY
27879: MOD
27880: PUSH
27881: LD_INT 0
27883: EQUAL
27884: IFFALSE 27968
// begin for i = 1 to tmp do
27886: LD_ADDR_VAR 0 1
27890: PUSH
27891: DOUBLE
27892: LD_INT 1
27894: DEC
27895: ST_TO_ADDR
27896: LD_VAR 0 13
27900: PUSH
27901: FOR_TO
27902: IFFALSE 27966
// if GetTag ( tmp [ i ] ) = 83 or GetTag ( tmp [ i ] ) = 82 then
27904: LD_VAR 0 13
27908: PUSH
27909: LD_VAR 0 1
27913: ARRAY
27914: PPUSH
27915: CALL_OW 110
27919: PUSH
27920: LD_INT 83
27922: EQUAL
27923: PUSH
27924: LD_VAR 0 13
27928: PUSH
27929: LD_VAR 0 1
27933: ARRAY
27934: PPUSH
27935: CALL_OW 110
27939: PUSH
27940: LD_INT 82
27942: EQUAL
27943: OR
27944: IFFALSE 27964
// SetTag ( tmp [ i ] , 84 ) ;
27946: LD_VAR 0 13
27950: PUSH
27951: LD_VAR 0 1
27955: ARRAY
27956: PPUSH
27957: LD_INT 84
27959: PPUSH
27960: CALL_OW 109
27964: GO 27901
27966: POP
27967: POP
// end ; end ; if NeedBuilding ( side , b_barracks ) and GetBaseSource ( MyBase ( side ) [ 1 ] ) [ 1 ] > 30 and GetBuilding ( side , b_lab_full ) then
27968: LD_VAR 0 10
27972: PPUSH
27973: LD_INT 5
27975: PPUSH
27976: CALL 1042 0 2
27980: PUSH
27981: LD_VAR 0 10
27985: PPUSH
27986: CALL 1174 0 1
27990: PUSH
27991: LD_INT 1
27993: ARRAY
27994: PPUSH
27995: CALL 866 0 1
27999: PUSH
28000: LD_INT 1
28002: ARRAY
28003: PUSH
28004: LD_INT 30
28006: GREATER
28007: AND
28008: PUSH
28009: LD_VAR 0 10
28013: PPUSH
28014: LD_INT 8
28016: PPUSH
28017: CALL 1265 0 2
28021: AND
28022: IFFALSE 28128
// if NeedBuilding ( side , b_armoury ) then
28024: LD_VAR 0 10
28028: PPUSH
28029: LD_INT 4
28031: PPUSH
28032: CALL 1042 0 2
28036: IFFALSE 28079
// Build ( eng , b_armoury , arm_xy [ 1 ] , arm_xy [ 2 ] , arm_xy [ 3 ] ) else
28038: LD_VAR 0 4
28042: PPUSH
28043: LD_INT 4
28045: PPUSH
28046: LD_VAR 0 22
28050: PUSH
28051: LD_INT 1
28053: ARRAY
28054: PPUSH
28055: LD_VAR 0 22
28059: PUSH
28060: LD_INT 2
28062: ARRAY
28063: PPUSH
28064: LD_VAR 0 22
28068: PUSH
28069: LD_INT 3
28071: ARRAY
28072: PPUSH
28073: CALL 9532 0 5
28077: GO 28128
// if GetBaseSource ( MyBase ( side ) [ 1 ] ) [ 1 ] > 30 then
28079: LD_VAR 0 10
28083: PPUSH
28084: CALL 1174 0 1
28088: PUSH
28089: LD_INT 1
28091: ARRAY
28092: PPUSH
28093: CALL 866 0 1
28097: PUSH
28098: LD_INT 1
28100: ARRAY
28101: PUSH
28102: LD_INT 30
28104: GREATER
28105: IFFALSE 28128
// ComUpgrade ( GetBuilding ( side , b_armoury ) [ 1 ] ) ;
28107: LD_VAR 0 10
28111: PPUSH
28112: LD_INT 4
28114: PPUSH
28115: CALL 1265 0 2
28119: PUSH
28120: LD_INT 1
28122: ARRAY
28123: PPUSH
28124: CALL_OW 146
// if sold and not NeedBuilding ( side , b_barracks ) then
28128: LD_VAR 0 3
28132: PUSH
28133: LD_VAR 0 10
28137: PPUSH
28138: LD_INT 5
28140: PPUSH
28141: CALL 1042 0 2
28145: NOT
28146: AND
28147: IFFALSE 28306
// for i = 1 to sold do
28149: LD_ADDR_VAR 0 1
28153: PUSH
28154: DOUBLE
28155: LD_INT 1
28157: DEC
28158: ST_TO_ADDR
28159: LD_VAR 0 3
28163: PUSH
28164: FOR_TO
28165: IFFALSE 28304
// if not IsInUnit ( sold [ i ] ) and not HasTask ( sold [ i ] ) and GetTag ( sold [ i ] ) = 0 and FilterAllUnits ( [ [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ] ) = 0 then
28167: LD_VAR 0 3
28171: PUSH
28172: LD_VAR 0 1
28176: ARRAY
28177: PPUSH
28178: CALL_OW 310
28182: NOT
28183: PUSH
28184: LD_VAR 0 3
28188: PUSH
28189: LD_VAR 0 1
28193: ARRAY
28194: PPUSH
28195: CALL_OW 314
28199: NOT
28200: AND
28201: PUSH
28202: LD_VAR 0 3
28206: PUSH
28207: LD_VAR 0 1
28211: ARRAY
28212: PPUSH
28213: CALL_OW 110
28217: PUSH
28218: LD_INT 0
28220: EQUAL
28221: AND
28222: PUSH
28223: LD_INT 22
28225: PUSH
28226: LD_VAR 0 10
28230: PUSH
28231: EMPTY
28232: LIST
28233: LIST
28234: PUSH
28235: LD_INT 30
28237: PUSH
28238: LD_INT 32
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: PUSH
28245: LD_INT 58
28247: PUSH
28248: EMPTY
28249: LIST
28250: PUSH
28251: EMPTY
28252: LIST
28253: LIST
28254: LIST
28255: PUSH
28256: EMPTY
28257: LIST
28258: PPUSH
28259: CALL_OW 69
28263: PUSH
28264: LD_INT 0
28266: EQUAL
28267: AND
28268: IFFALSE 28302
// ComEnterUnit ( sold [ i ] , GetBuilding ( side , b_barracks ) [ 1 ] ) ;
28270: LD_VAR 0 3
28274: PUSH
28275: LD_VAR 0 1
28279: ARRAY
28280: PPUSH
28281: LD_VAR 0 10
28285: PPUSH
28286: LD_INT 5
28288: PPUSH
28289: CALL 1265 0 2
28293: PUSH
28294: LD_INT 1
28296: ARRAY
28297: PPUSH
28298: CALL_OW 120
28302: GO 28164
28304: POP
28305: POP
// GoToTower ( Tag_List ( sold , 0 ) ) ;
28306: LD_VAR 0 3
28310: PPUSH
28311: LD_INT 0
28313: PPUSH
28314: CALL 9970 0 2
28318: PPUSH
28319: CALL 10064 0 1
// if NeedBuilding ( side , b_oil_mine ) then
28323: LD_VAR 0 10
28327: PPUSH
28328: LD_INT 29
28330: PPUSH
28331: CALL 1042 0 2
28335: IFFALSE 28487
// begin if GetResourceVisibility ( oil_xy [ 1 ] , oil_xy [ 2 ] , side ) = false then
28337: LD_VAR 0 25
28341: PUSH
28342: LD_INT 1
28344: ARRAY
28345: PPUSH
28346: LD_VAR 0 25
28350: PUSH
28351: LD_INT 2
28353: ARRAY
28354: PPUSH
28355: LD_VAR 0 10
28359: PPUSH
28360: CALL_OW 440
28364: PUSH
28365: LD_INT 0
28367: EQUAL
28368: IFFALSE 28405
// ComFindDeposit ( sci [ sci ] , oil_xy [ 1 ] , oil_xy [ 2 ] ) else
28370: LD_VAR 0 6
28374: PUSH
28375: LD_VAR 0 6
28379: ARRAY
28380: PPUSH
28381: LD_VAR 0 25
28385: PUSH
28386: LD_INT 1
28388: ARRAY
28389: PPUSH
28390: LD_VAR 0 25
28394: PUSH
28395: LD_INT 2
28397: ARRAY
28398: PPUSH
28399: CALL 4126 0 3
28403: GO 28485
// begin if GetTag ( sci [ sci ] ) = 42 then
28405: LD_VAR 0 6
28409: PUSH
28410: LD_VAR 0 6
28414: ARRAY
28415: PPUSH
28416: CALL_OW 110
28420: PUSH
28421: LD_INT 42
28423: EQUAL
28424: IFFALSE 28444
// SetTag ( sci [ sci ] , 0 ) ;
28426: LD_VAR 0 6
28430: PUSH
28431: LD_VAR 0 6
28435: ARRAY
28436: PPUSH
28437: LD_INT 0
28439: PPUSH
28440: CALL_OW 109
// Build ( eng , b_oil_mine , oil_xy [ 1 ] , oil_xy [ 2 ] , Rand ( 0 , 5 ) ) ;
28444: LD_VAR 0 4
28448: PPUSH
28449: LD_INT 29
28451: PPUSH
28452: LD_VAR 0 25
28456: PUSH
28457: LD_INT 1
28459: ARRAY
28460: PPUSH
28461: LD_VAR 0 25
28465: PUSH
28466: LD_INT 2
28468: ARRAY
28469: PPUSH
28470: LD_INT 0
28472: PPUSH
28473: LD_INT 5
28475: PPUSH
28476: CALL_OW 12
28480: PPUSH
28481: CALL 9532 0 5
// end end else
28485: GO 28659
// if want_more_oil and GetBuilding ( side , b_oil_mine ) < 2 then
28487: LD_VAR 0 27
28491: PUSH
28492: LD_VAR 0 10
28496: PPUSH
28497: LD_INT 29
28499: PPUSH
28500: CALL 1265 0 2
28504: PUSH
28505: LD_INT 2
28507: LESS
28508: AND
28509: IFFALSE 28659
// if GetResourceVisibility ( oil_xy [ 3 ] , oil_xy [ 4 ] , side ) = false then
28511: LD_VAR 0 25
28515: PUSH
28516: LD_INT 3
28518: ARRAY
28519: PPUSH
28520: LD_VAR 0 25
28524: PUSH
28525: LD_INT 4
28527: ARRAY
28528: PPUSH
28529: LD_VAR 0 10
28533: PPUSH
28534: CALL_OW 440
28538: PUSH
28539: LD_INT 0
28541: EQUAL
28542: IFFALSE 28579
// ComFindDeposit ( sci [ sci ] , oil_xy [ 3 ] , oil_xy [ 4 ] ) else
28544: LD_VAR 0 6
28548: PUSH
28549: LD_VAR 0 6
28553: ARRAY
28554: PPUSH
28555: LD_VAR 0 25
28559: PUSH
28560: LD_INT 3
28562: ARRAY
28563: PPUSH
28564: LD_VAR 0 25
28568: PUSH
28569: LD_INT 4
28571: ARRAY
28572: PPUSH
28573: CALL 4126 0 3
28577: GO 28659
// begin if GetTag ( sci [ sci ] ) = 42 then
28579: LD_VAR 0 6
28583: PUSH
28584: LD_VAR 0 6
28588: ARRAY
28589: PPUSH
28590: CALL_OW 110
28594: PUSH
28595: LD_INT 42
28597: EQUAL
28598: IFFALSE 28618
// SetTag ( sci [ sci ] , 0 ) ;
28600: LD_VAR 0 6
28604: PUSH
28605: LD_VAR 0 6
28609: ARRAY
28610: PPUSH
28611: LD_INT 0
28613: PPUSH
28614: CALL_OW 109
// Build ( eng , b_oil_mine , oil_xy [ 3 ] , oil_xy [ 4 ] , Rand ( 0 , 5 ) ) ;
28618: LD_VAR 0 4
28622: PPUSH
28623: LD_INT 29
28625: PPUSH
28626: LD_VAR 0 25
28630: PUSH
28631: LD_INT 3
28633: ARRAY
28634: PPUSH
28635: LD_VAR 0 25
28639: PUSH
28640: LD_INT 4
28642: ARRAY
28643: PPUSH
28644: LD_INT 0
28646: PPUSH
28647: LD_INT 5
28649: PPUSH
28650: CALL_OW 12
28654: PPUSH
28655: CALL 9532 0 5
// end ; if NeedBuilding ( side , b_siberite_mine ) and GetTech ( tech_SibDet , side ) = state_researched then
28659: LD_VAR 0 10
28663: PPUSH
28664: LD_INT 30
28666: PPUSH
28667: CALL 1042 0 2
28671: PUSH
28672: LD_INT 20
28674: PPUSH
28675: LD_VAR 0 10
28679: PPUSH
28680: CALL_OW 321
28684: PUSH
28685: LD_INT 2
28687: EQUAL
28688: AND
28689: IFFALSE 28870
// begin if GetResourceVisibility ( sib_xy [ 1 ] , sib_xy [ 2 ] , side ) = false then
28691: LD_VAR 0 26
28695: PUSH
28696: LD_INT 1
28698: ARRAY
28699: PPUSH
28700: LD_VAR 0 26
28704: PUSH
28705: LD_INT 2
28707: ARRAY
28708: PPUSH
28709: LD_VAR 0 10
28713: PPUSH
28714: CALL_OW 440
28718: PUSH
28719: LD_INT 0
28721: EQUAL
28722: IFFALSE 28759
// ComFindDeposit ( sci [ sci ] , sib_xy [ 1 ] , sib_xy [ 2 ] ) else
28724: LD_VAR 0 6
28728: PUSH
28729: LD_VAR 0 6
28733: ARRAY
28734: PPUSH
28735: LD_VAR 0 26
28739: PUSH
28740: LD_INT 1
28742: ARRAY
28743: PPUSH
28744: LD_VAR 0 26
28748: PUSH
28749: LD_INT 2
28751: ARRAY
28752: PPUSH
28753: CALL 4126 0 3
28757: GO 28868
// if GetResourceVisibility ( sib_xy [ 1 ] , sib_xy [ 2 ] , side ) then
28759: LD_VAR 0 26
28763: PUSH
28764: LD_INT 1
28766: ARRAY
28767: PPUSH
28768: LD_VAR 0 26
28772: PUSH
28773: LD_INT 2
28775: ARRAY
28776: PPUSH
28777: LD_VAR 0 10
28781: PPUSH
28782: CALL_OW 440
28786: IFFALSE 28868
// begin if GetTag ( sci [ sci ] ) = 42 then
28788: LD_VAR 0 6
28792: PUSH
28793: LD_VAR 0 6
28797: ARRAY
28798: PPUSH
28799: CALL_OW 110
28803: PUSH
28804: LD_INT 42
28806: EQUAL
28807: IFFALSE 28827
// SetTag ( sci [ sci ] , 0 ) ;
28809: LD_VAR 0 6
28813: PUSH
28814: LD_VAR 0 6
28818: ARRAY
28819: PPUSH
28820: LD_INT 0
28822: PPUSH
28823: CALL_OW 109
// Build ( eng , b_siberite_mine , sib_xy [ 1 ] , sib_xy [ 2 ] , Rand ( 0 , 5 ) ) ;
28827: LD_VAR 0 4
28831: PPUSH
28832: LD_INT 30
28834: PPUSH
28835: LD_VAR 0 26
28839: PUSH
28840: LD_INT 1
28842: ARRAY
28843: PPUSH
28844: LD_VAR 0 26
28848: PUSH
28849: LD_INT 2
28851: ARRAY
28852: PPUSH
28853: LD_INT 0
28855: PPUSH
28856: LD_INT 5
28858: PPUSH
28859: CALL_OW 12
28863: PPUSH
28864: CALL 9532 0 5
// end ; end else
28868: GO 29089
// if want_more_sib and GetBuilding ( side , b_siberite_mine ) < 2 and GetTech ( tech_SibDet , side ) = state_researched then
28870: LD_VAR 0 28
28874: PUSH
28875: LD_VAR 0 10
28879: PPUSH
28880: LD_INT 30
28882: PPUSH
28883: CALL 1265 0 2
28887: PUSH
28888: LD_INT 2
28890: LESS
28891: AND
28892: PUSH
28893: LD_INT 20
28895: PPUSH
28896: LD_VAR 0 10
28900: PPUSH
28901: CALL_OW 321
28905: PUSH
28906: LD_INT 2
28908: EQUAL
28909: AND
28910: IFFALSE 29089
// if GetResourceVisibility ( sib_xy [ 3 ] , sib_xy [ 4 ] , side ) = false then
28912: LD_VAR 0 26
28916: PUSH
28917: LD_INT 3
28919: ARRAY
28920: PPUSH
28921: LD_VAR 0 26
28925: PUSH
28926: LD_INT 4
28928: ARRAY
28929: PPUSH
28930: LD_VAR 0 10
28934: PPUSH
28935: CALL_OW 440
28939: PUSH
28940: LD_INT 0
28942: EQUAL
28943: IFFALSE 28980
// ComFindDeposit ( sci [ sci ] , sib_xy [ 3 ] , sib_xy [ 4 ] ) else
28945: LD_VAR 0 6
28949: PUSH
28950: LD_VAR 0 6
28954: ARRAY
28955: PPUSH
28956: LD_VAR 0 26
28960: PUSH
28961: LD_INT 3
28963: ARRAY
28964: PPUSH
28965: LD_VAR 0 26
28969: PUSH
28970: LD_INT 4
28972: ARRAY
28973: PPUSH
28974: CALL 4126 0 3
28978: GO 29089
// begin if GetTag ( sci [ sci ] ) = 42 then
28980: LD_VAR 0 6
28984: PUSH
28985: LD_VAR 0 6
28989: ARRAY
28990: PPUSH
28991: CALL_OW 110
28995: PUSH
28996: LD_INT 42
28998: EQUAL
28999: IFFALSE 29019
// SetTag ( sci [ sci ] , 0 ) ;
29001: LD_VAR 0 6
29005: PUSH
29006: LD_VAR 0 6
29010: ARRAY
29011: PPUSH
29012: LD_INT 0
29014: PPUSH
29015: CALL_OW 109
// if GetResourceVisibility ( sib_xy [ 3 ] , sib_xy [ 4 ] , side ) then
29019: LD_VAR 0 26
29023: PUSH
29024: LD_INT 3
29026: ARRAY
29027: PPUSH
29028: LD_VAR 0 26
29032: PUSH
29033: LD_INT 4
29035: ARRAY
29036: PPUSH
29037: LD_VAR 0 10
29041: PPUSH
29042: CALL_OW 440
29046: IFFALSE 29089
// Build ( eng , b_siberite_mine , sib_xy [ 3 ] , sib_xy [ 4 ] , Rand ( 0 , 5 ) ) ;
29048: LD_VAR 0 4
29052: PPUSH
29053: LD_INT 30
29055: PPUSH
29056: LD_VAR 0 26
29060: PUSH
29061: LD_INT 3
29063: ARRAY
29064: PPUSH
29065: LD_VAR 0 26
29069: PUSH
29070: LD_INT 4
29072: ARRAY
29073: PPUSH
29074: LD_INT 0
29076: PPUSH
29077: LD_INT 5
29079: PPUSH
29080: CALL_OW 12
29084: PPUSH
29085: CALL 9532 0 5
// end ; if GetTech ( tech_solpow , side ) = state_researched and sol_pow_list and GetBuilding ( side , b_solar_power ) < ( sol_pow_list / 3 ) then
29089: LD_INT 35
29091: PPUSH
29092: LD_VAR 0 10
29096: PPUSH
29097: CALL_OW 321
29101: PUSH
29102: LD_INT 2
29104: EQUAL
29105: PUSH
29106: LD_VAR 0 29
29110: AND
29111: PUSH
29112: LD_VAR 0 10
29116: PPUSH
29117: LD_INT 27
29119: PPUSH
29120: CALL 1265 0 2
29124: PUSH
29125: LD_VAR 0 29
29129: PUSH
29130: LD_INT 3
29132: DIVREAL
29133: LESS
29134: AND
29135: IFFALSE 29154
// BuildPowerFromList ( eng , sol_pow_list , b_solar_power ) ;
29137: LD_VAR 0 4
29141: PPUSH
29142: LD_VAR 0 29
29146: PPUSH
29147: LD_INT 27
29149: PPUSH
29150: CALL 9784 0 3
// if GetTech ( tech_oilpow , side ) = state_researched and oil_pow_list and GetBuilding ( side , b_oil_power ) < ( oil_pow_list / 3 ) then
29154: LD_INT 46
29156: PPUSH
29157: LD_VAR 0 10
29161: PPUSH
29162: CALL_OW 321
29166: PUSH
29167: LD_INT 2
29169: EQUAL
29170: PUSH
29171: LD_VAR 0 30
29175: AND
29176: PUSH
29177: LD_VAR 0 10
29181: PPUSH
29182: LD_INT 26
29184: PPUSH
29185: CALL 1265 0 2
29189: PUSH
29190: LD_VAR 0 30
29194: PUSH
29195: LD_INT 3
29197: DIVREAL
29198: LESS
29199: AND
29200: IFFALSE 29219
// BuildPowerFromList ( eng , oil_pow_list , b_oil_power ) ;
29202: LD_VAR 0 4
29206: PPUSH
29207: LD_VAR 0 30
29211: PPUSH
29212: LD_INT 26
29214: PPUSH
29215: CALL 9784 0 3
// if GetTech ( tech_sibpow , side ) = state_researched and sib_pow_list and GetBuilding ( side , b_siberite_power ) < ( sib_pow_list / 3 ) then
29219: LD_INT 21
29221: PPUSH
29222: LD_VAR 0 10
29226: PPUSH
29227: CALL_OW 321
29231: PUSH
29232: LD_INT 2
29234: EQUAL
29235: PUSH
29236: LD_VAR 0 31
29240: AND
29241: PUSH
29242: LD_VAR 0 10
29246: PPUSH
29247: LD_INT 28
29249: PPUSH
29250: CALL 1265 0 2
29254: PUSH
29255: LD_VAR 0 31
29259: PUSH
29260: LD_INT 3
29262: DIVREAL
29263: LESS
29264: AND
29265: IFFALSE 29284
// BuildPowerFromList ( eng , sib_pow_list , b_siberite_power ) ;
29267: LD_VAR 0 4
29271: PPUSH
29272: LD_VAR 0 31
29276: PPUSH
29277: LD_INT 28
29279: PPUSH
29280: CALL 9784 0 3
// if GetListOfCratesInArea ( crates_area ) then
29284: LD_VAR 0 23
29288: PPUSH
29289: CALL_OW 435
29293: IFFALSE 29309
// CollectCrates ( side , crates_area ) ;
29295: LD_VAR 0 10
29299: PPUSH
29300: LD_VAR 0 23
29304: PPUSH
29305: CALL 9093 0 2
// end ; end ; end ; end_of_file
29309: PPOPN 66
29311: END
// export function PrepareSquad ( side , nat , area , commander , skill , num ) ; var i , un , team , z ; begin
29312: LD_INT 0
29314: PPUSH
29315: PPUSH
29316: PPUSH
29317: PPUSH
29318: PPUSH
// uc_side := side ;
29319: LD_ADDR_OWVAR 20
29323: PUSH
29324: LD_VAR 0 1
29328: ST_TO_ADDR
// uc_nation := nat ;
29329: LD_ADDR_OWVAR 21
29333: PUSH
29334: LD_VAR 0 2
29338: ST_TO_ADDR
// team := [ ] ;
29339: LD_ADDR_VAR 0 10
29343: PUSH
29344: EMPTY
29345: ST_TO_ADDR
// hc_importance := 100 ;
29346: LD_ADDR_OWVAR 32
29350: PUSH
29351: LD_INT 100
29353: ST_TO_ADDR
// case commander of powell :
29354: LD_VAR 0 4
29358: PUSH
29359: LD_STRING powell
29361: DOUBLE
29362: EQUAL
29363: IFTRUE 29367
29365: GO 29435
29367: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
29368: LD_INT 1
29370: PPUSH
29371: LD_INT 1
29373: PPUSH
29374: LD_VAR 0 5
29378: PPUSH
29379: CALL_OW 380
// hc_gallery := us ;
29383: LD_ADDR_OWVAR 33
29387: PUSH
29388: LD_STRING us
29390: ST_TO_ADDR
// hc_face_number := 7 ;
29391: LD_ADDR_OWVAR 34
29395: PUSH
29396: LD_INT 7
29398: ST_TO_ADDR
// hc_name := Arthur Powell ;
29399: LD_ADDR_OWVAR 26
29403: PUSH
29404: LD_STRING Arthur Powell
29406: ST_TO_ADDR
// powell := CreateHuman ;
29407: LD_ADDR_EXP 4
29411: PUSH
29412: CALL_OW 44
29416: ST_TO_ADDR
// team := team ^ powell ;
29417: LD_ADDR_VAR 0 10
29421: PUSH
29422: LD_VAR 0 10
29426: PUSH
29427: LD_EXP 4
29431: ADD
29432: ST_TO_ADDR
// end ; sikorski :
29433: GO 29588
29435: LD_STRING sikorski
29437: DOUBLE
29438: EQUAL
29439: IFTRUE 29443
29441: GO 29511
29443: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
29444: LD_INT 1
29446: PPUSH
29447: LD_INT 1
29449: PPUSH
29450: LD_VAR 0 5
29454: PPUSH
29455: CALL_OW 380
// hc_gallery := us ;
29459: LD_ADDR_OWVAR 33
29463: PUSH
29464: LD_STRING us
29466: ST_TO_ADDR
// hc_face_number := 24 ;
29467: LD_ADDR_OWVAR 34
29471: PUSH
29472: LD_INT 24
29474: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
29475: LD_ADDR_OWVAR 26
29479: PUSH
29480: LD_STRING Jeremy Sikorski
29482: ST_TO_ADDR
// sikorski := CreateHuman ;
29483: LD_ADDR_EXP 3
29487: PUSH
29488: CALL_OW 44
29492: ST_TO_ADDR
// team := team ^ sikorski ;
29493: LD_ADDR_VAR 0 10
29497: PUSH
29498: LD_VAR 0 10
29502: PUSH
29503: LD_EXP 3
29507: ADD
29508: ST_TO_ADDR
// end ; gensher :
29509: GO 29588
29511: LD_STRING gensher
29513: DOUBLE
29514: EQUAL
29515: IFTRUE 29519
29517: GO 29587
29519: POP
// begin PrepareHuman ( sex_male , class_soldier , skill ) ;
29520: LD_INT 1
29522: PPUSH
29523: LD_INT 1
29525: PPUSH
29526: LD_VAR 0 5
29530: PPUSH
29531: CALL_OW 380
// hc_gallery := sandar ;
29535: LD_ADDR_OWVAR 33
29539: PUSH
29540: LD_STRING sandar
29542: ST_TO_ADDR
// hc_face_number := 3 ;
29543: LD_ADDR_OWVAR 34
29547: PUSH
29548: LD_INT 3
29550: ST_TO_ADDR
// hc_name := Dietrich Gensher ;
29551: LD_ADDR_OWVAR 26
29555: PUSH
29556: LD_STRING Dietrich Gensher
29558: ST_TO_ADDR
// gensher := CreateHuman ;
29559: LD_ADDR_EXP 5
29563: PUSH
29564: CALL_OW 44
29568: ST_TO_ADDR
// team := team ^ gensher ;
29569: LD_ADDR_VAR 0 10
29573: PUSH
29574: LD_VAR 0 10
29578: PUSH
29579: LD_EXP 5
29583: ADD
29584: ST_TO_ADDR
// end ; end ;
29585: GO 29588
29587: POP
// z := 1 ;
29588: LD_ADDR_VAR 0 11
29592: PUSH
29593: LD_INT 1
29595: ST_TO_ADDR
// hc_gallery :=  ;
29596: LD_ADDR_OWVAR 33
29600: PUSH
29601: LD_STRING 
29603: ST_TO_ADDR
// hc_name :=  ;
29604: LD_ADDR_OWVAR 26
29608: PUSH
29609: LD_STRING 
29611: ST_TO_ADDR
// hc_importance := 0 ;
29612: LD_ADDR_OWVAR 32
29616: PUSH
29617: LD_INT 0
29619: ST_TO_ADDR
// for i = 1 to num do
29620: LD_ADDR_VAR 0 8
29624: PUSH
29625: DOUBLE
29626: LD_INT 1
29628: DEC
29629: ST_TO_ADDR
29630: LD_VAR 0 6
29634: PUSH
29635: FOR_TO
29636: IFFALSE 29717
// begin if i mod ( num / 4 ) = 0 then
29638: LD_VAR 0 8
29642: PUSH
29643: LD_VAR 0 6
29647: PUSH
29648: LD_INT 4
29650: DIVREAL
29651: MOD
29652: PUSH
29653: LD_INT 0
29655: EQUAL
29656: IFFALSE 29672
// z := z + 1 ;
29658: LD_ADDR_VAR 0 11
29662: PUSH
29663: LD_VAR 0 11
29667: PUSH
29668: LD_INT 1
29670: PLUS
29671: ST_TO_ADDR
// PrepareHuman ( false , z , skill ) ;
29672: LD_INT 0
29674: PPUSH
29675: LD_VAR 0 11
29679: PPUSH
29680: LD_VAR 0 5
29684: PPUSH
29685: CALL_OW 380
// un := CreateHuman ;
29689: LD_ADDR_VAR 0 9
29693: PUSH
29694: CALL_OW 44
29698: ST_TO_ADDR
// team := team ^ un ;
29699: LD_ADDR_VAR 0 10
29703: PUSH
29704: LD_VAR 0 10
29708: PUSH
29709: LD_VAR 0 9
29713: ADD
29714: ST_TO_ADDR
// end ;
29715: GO 29635
29717: POP
29718: POP
// for i = 1 to team do
29719: LD_ADDR_VAR 0 8
29723: PUSH
29724: DOUBLE
29725: LD_INT 1
29727: DEC
29728: ST_TO_ADDR
29729: LD_VAR 0 10
29733: PUSH
29734: FOR_TO
29735: IFFALSE 29762
// PlaceUnitArea ( team [ i ] , area , false ) ;
29737: LD_VAR 0 10
29741: PUSH
29742: LD_VAR 0 8
29746: ARRAY
29747: PPUSH
29748: LD_VAR 0 3
29752: PPUSH
29753: LD_INT 0
29755: PPUSH
29756: CALL_OW 49
29760: GO 29734
29762: POP
29763: POP
// end ;
29764: LD_VAR 0 7
29768: RET
// export function Resources ( n1 , n2 , n3 , area ) ; var i ; begin
29769: LD_INT 0
29771: PPUSH
29772: PPUSH
// for i = 1 to n1 do
29773: LD_ADDR_VAR 0 6
29777: PUSH
29778: DOUBLE
29779: LD_INT 1
29781: DEC
29782: ST_TO_ADDR
29783: LD_VAR 0 1
29787: PUSH
29788: FOR_TO
29789: IFFALSE 29811
// CreateResourcesArea ( mat_cans , 1 , area , false ) ;
29791: LD_INT 1
29793: PPUSH
29794: LD_INT 1
29796: PPUSH
29797: LD_VAR 0 4
29801: PPUSH
29802: LD_INT 0
29804: PPUSH
29805: CALL_OW 59
29809: GO 29788
29811: POP
29812: POP
// for i = 1 to n2 do
29813: LD_ADDR_VAR 0 6
29817: PUSH
29818: DOUBLE
29819: LD_INT 1
29821: DEC
29822: ST_TO_ADDR
29823: LD_VAR 0 2
29827: PUSH
29828: FOR_TO
29829: IFFALSE 29851
// CreateResourcesArea ( mat_oil , 1 , area , false ) ;
29831: LD_INT 2
29833: PPUSH
29834: LD_INT 1
29836: PPUSH
29837: LD_VAR 0 4
29841: PPUSH
29842: LD_INT 0
29844: PPUSH
29845: CALL_OW 59
29849: GO 29828
29851: POP
29852: POP
// for i = 1 to n3 do
29853: LD_ADDR_VAR 0 6
29857: PUSH
29858: DOUBLE
29859: LD_INT 1
29861: DEC
29862: ST_TO_ADDR
29863: LD_VAR 0 3
29867: PUSH
29868: FOR_TO
29869: IFFALSE 29891
// CreateResourcesArea ( mat_siberit , 1 , area , false ) ;
29871: LD_INT 3
29873: PPUSH
29874: LD_INT 1
29876: PPUSH
29877: LD_VAR 0 4
29881: PPUSH
29882: LD_INT 0
29884: PPUSH
29885: CALL_OW 59
29889: GO 29868
29891: POP
29892: POP
// end ; end_of_file
29893: LD_VAR 0 5
29897: RET
// export function AddCrates ( area ) ; begin
29898: LD_INT 0
29900: PPUSH
// CreateCratesArea ( Rand ( 1 , 5 ) , area , true ) ;
29901: LD_INT 1
29903: PPUSH
29904: LD_INT 5
29906: PPUSH
29907: CALL_OW 12
29911: PPUSH
29912: LD_VAR 0 1
29916: PPUSH
29917: LD_INT 1
29919: PPUSH
29920: CALL_OW 55
// end ; end_of_file
29924: LD_VAR 0 2
29928: RET
// on BuildingComplete ( b ) do begin if GetSide ( b ) <> 1 and GetBType ( b ) = b_depot then
29929: LD_VAR 0 1
29933: PPUSH
29934: CALL_OW 255
29938: PUSH
29939: LD_INT 1
29941: NONEQUAL
29942: PUSH
29943: LD_VAR 0 1
29947: PPUSH
29948: CALL_OW 266
29952: PUSH
29953: LD_INT 0
29955: EQUAL
29956: AND
29957: IFFALSE 29979
// SetResourceType ( GetBase ( b ) , mat_cans , 20 ) ;
29959: LD_VAR 0 1
29963: PPUSH
29964: CALL_OW 274
29968: PPUSH
29969: LD_INT 1
29971: PPUSH
29972: LD_INT 20
29974: PPUSH
29975: CALL_OW 277
// end ;
29979: PPOPN 1
29981: END
// on LeaveBuilding ( b , un ) do begin if GetClass ( un ) = 1 and GetTag ( un ) > 0 then
29982: LD_VAR 0 2
29986: PPUSH
29987: CALL_OW 257
29991: PUSH
29992: LD_INT 1
29994: EQUAL
29995: PUSH
29996: LD_VAR 0 2
30000: PPUSH
30001: CALL_OW 110
30005: PUSH
30006: LD_INT 0
30008: GREATER
30009: AND
30010: IFFALSE 30024
// SetTag ( un , 0 ) ;
30012: LD_VAR 0 2
30016: PPUSH
30017: LD_INT 0
30019: PPUSH
30020: CALL_OW 109
// end ;
30024: PPOPN 2
30026: END
