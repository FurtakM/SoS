// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 180 0 0
// if debug then
   8: LD_EXP 1
  12: IFFALSE 21
// begin FogOff ( 1 ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 344
// end ; ChangeSideFog ( 4 , 1 ) ;
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: CALL_OW 343
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 3
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: LD_INT 0
  45: PPUSH
  46: LD_INT 0
  48: PPUSH
  49: LD_INT 0
  51: PPUSH
  52: LD_INT 7
  54: PPUSH
  55: LD_INT 0
  57: PPUSH
  58: CALL 37096 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 3
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 4
  85: PPUSH
  86: LD_INT 0
  88: PPUSH
  89: CALL 37096 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
  93: LD_INT 0
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 3
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 11
 116: PPUSH
 117: LD_INT 0
 119: PPUSH
 120: CALL 37096 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 3
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 14
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: CALL 37096 0 9
// PrepareGensher ;
 155: CALL 1331 0 0
// PreparePopov ;
 159: CALL 2581 0 0
// PreparePowell ;
 163: CALL 394 0 0
// PrepareSikorski ;
 167: CALL 3705 0 0
// MC_Start ( ) ;
 171: CALL 43662 0 0
// Action ;
 175: CALL 4112 0 0
// end ;
 179: END
// export debug , game , staticMines ; function InitVariables ; begin
 180: LD_INT 0
 182: PPUSH
// debug := false ;
 183: LD_ADDR_EXP 1
 187: PUSH
 188: LD_INT 0
 190: ST_TO_ADDR
// game := true ;
 191: LD_ADDR_EXP 2
 195: PUSH
 196: LD_INT 1
 198: ST_TO_ADDR
// staticMines := [ ] ;
 199: LD_ADDR_EXP 3
 203: PUSH
 204: EMPTY
 205: ST_TO_ADDR
// end ;
 206: LD_VAR 0 1
 210: RET
// export function CustomInitMacro ; begin
 211: LD_INT 0
 213: PPUSH
// InitMC_Gensher ( ) ;
 214: CALL 1719 0 0
// InitMC_Powell ( ) ;
 218: CALL 609 0 0
// InitMC_Popov ( ) ;
 222: CALL 2907 0 0
// end ;
 226: LD_VAR 0 1
 230: RET
// every 0 0$10 do var cr , time , i ;
 231: GO 233
 233: DISABLE
 234: LD_INT 0
 236: PPUSH
 237: PPUSH
 238: PPUSH
// begin time := 0 0$30 ;
 239: LD_ADDR_VAR 0 2
 243: PUSH
 244: LD_INT 1050
 246: ST_TO_ADDR
// repeat wait ( time ) ;
 247: LD_VAR 0 2
 251: PPUSH
 252: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 256: LD_ADDR_VAR 0 1
 260: PUSH
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 5
 266: PPUSH
 267: CALL_OW 12
 271: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 272: LD_ADDR_VAR 0 3
 276: PUSH
 277: LD_INT 5
 279: PUSH
 280: LD_INT 8
 282: PUSH
 283: LD_INT 12
 285: PUSH
 286: LD_INT 13
 288: PUSH
 289: EMPTY
 290: LIST
 291: LIST
 292: LIST
 293: LIST
 294: PUSH
 295: FOR_IN
 296: IFFALSE 350
// begin if GetResourceArea ( i , mat_cans ) < 20 then
 298: LD_VAR 0 3
 302: PPUSH
 303: LD_INT 1
 305: PPUSH
 306: CALL_OW 287
 310: PUSH
 311: LD_INT 20
 313: LESS
 314: IFFALSE 333
// CreateCratesArea ( cr , i , true ) ;
 316: LD_VAR 0 1
 320: PPUSH
 321: LD_VAR 0 3
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$20 ) ) ;
 333: LD_INT 175
 335: PPUSH
 336: LD_INT 700
 338: PPUSH
 339: CALL_OW 12
 343: PPUSH
 344: CALL_OW 67
// end ;
 348: GO 295
 350: POP
 351: POP
// time := time + 0 0$2 ;
 352: LD_ADDR_VAR 0 2
 356: PUSH
 357: LD_VAR 0 2
 361: PUSH
 362: LD_INT 70
 364: PLUS
 365: ST_TO_ADDR
// if time > 1 1$00 then
 366: LD_VAR 0 2
 370: PUSH
 371: LD_INT 2100
 373: GREATER
 374: IFFALSE 384
// time := 0 0$25 ;
 376: LD_ADDR_VAR 0 2
 380: PUSH
 381: LD_INT 875
 383: ST_TO_ADDR
// until not game ;
 384: LD_EXP 2
 388: NOT
 389: IFFALSE 247
// end ; end_of_file
 391: PPOPN 3
 393: END
// export Powell , powell_side ; export function PreparePowell ; var i , tmp ; begin
 394: LD_INT 0
 396: PPUSH
 397: PPUSH
 398: PPUSH
// powell_side := 4 ;
 399: LD_ADDR_EXP 5
 403: PUSH
 404: LD_INT 4
 406: ST_TO_ADDR
// uc_side := powell_side ;
 407: LD_ADDR_OWVAR 20
 411: PUSH
 412: LD_EXP 5
 416: ST_TO_ADDR
// uc_nation := 1 ;
 417: LD_ADDR_OWVAR 21
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 425: LD_ADDR_EXP 4
 429: PUSH
 430: LD_STRING Powell
 432: PPUSH
 433: CALL_OW 25
 437: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 438: LD_EXP 4
 442: PPUSH
 443: LD_INT 1
 445: PPUSH
 446: LD_INT 7
 448: PPUSH
 449: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 453: LD_EXP 4
 457: PPUSH
 458: LD_INT 2
 460: PPUSH
 461: LD_INT 5
 463: PPUSH
 464: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 468: LD_EXP 4
 472: PPUSH
 473: LD_INT 3
 475: PPUSH
 476: LD_INT 6
 478: PPUSH
 479: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 483: LD_EXP 4
 487: PPUSH
 488: LD_INT 4
 490: PPUSH
 491: LD_INT 4
 493: PPUSH
 494: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 498: LD_EXP 4
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1000 , 100 , 0 ] , [ 4 , 4 , 4 , 4 ] ) ;
 510: LD_ADDR_VAR 0 3
 514: PUSH
 515: LD_INT 4
 517: PPUSH
 518: LD_INT 1
 520: PPUSH
 521: LD_STRING 
 523: PPUSH
 524: LD_INT 8
 526: PUSH
 527: LD_INT 7
 529: PUSH
 530: LD_INT 6
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PPUSH
 544: LD_INT 1000
 546: PUSH
 547: LD_INT 100
 549: PUSH
 550: LD_INT 0
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: LD_INT 4
 560: PUSH
 561: LD_INT 4
 563: PUSH
 564: LD_INT 4
 566: PUSH
 567: LD_INT 4
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PPUSH
 576: CALL 12714 0 6
 580: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 581: LD_ADDR_EXP 14
 585: PUSH
 586: LD_EXP 14
 590: PPUSH
 591: LD_INT 1
 593: PPUSH
 594: LD_VAR 0 3
 598: PPUSH
 599: CALL_OW 1
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 1
 608: RET
// export function InitMC_Powell ( ) ; begin
 609: LD_INT 0
 611: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 612: LD_INT 1
 614: PPUSH
 615: LD_INT 1
 617: PPUSH
 618: CALL 66550 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 622: LD_INT 1
 624: PPUSH
 625: LD_INT 6
 627: PPUSH
 628: CALL 66494 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 632: LD_INT 1
 634: PPUSH
 635: LD_INT 167
 637: PUSH
 638: LD_INT 102
 640: PUSH
 641: LD_INT 0
 643: PUSH
 644: EMPTY
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 173
 651: PUSH
 652: LD_INT 83
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: PUSH
 663: LD_INT 171
 665: PUSH
 666: LD_INT 141
 668: PUSH
 669: LD_INT 0
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 178
 679: PUSH
 680: LD_INT 148
 682: PUSH
 683: LD_INT 1
 685: PUSH
 686: EMPTY
 687: LIST
 688: LIST
 689: LIST
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 65553 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 701: LD_INT 1
 703: PPUSH
 704: LD_INT 11
 706: PUSH
 707: LD_INT 6
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 9
 715: PUSH
 716: LD_INT 10
 718: PUSH
 719: EMPTY
 720: LIST
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PPUSH
 726: CALL 66382 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 730: LD_INT 1
 732: PPUSH
 733: LD_INT 5
 735: PPUSH
 736: CALL 66064 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 740: LD_INT 1
 742: PPUSH
 743: LD_INT 4
 745: PPUSH
 746: CALL 65795 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 4
 755: PPUSH
 756: CALL 65414 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 760: LD_INT 1
 762: PPUSH
 763: LD_INT 3
 765: PUSH
 766: LD_INT 1
 768: PUSH
 769: LD_INT 2
 771: PUSH
 772: LD_INT 5
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 4
 783: PUSH
 784: LD_INT 1
 786: PUSH
 787: LD_INT 2
 789: PUSH
 790: LD_INT 6
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 4
 801: PUSH
 802: LD_INT 1
 804: PUSH
 805: LD_INT 2
 807: PUSH
 808: LD_INT 7
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 1
 822: PUSH
 823: LD_INT 2
 825: PUSH
 826: LD_INT 6
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 5
 837: PUSH
 838: LD_INT 1
 840: PUSH
 841: LD_INT 2
 843: PUSH
 844: LD_INT 6
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PPUSH
 860: CALL 65229 0 2
// MC_SetBuildingList ( 1 , [ [ b_lab , 200 , 111 , 4 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_armoury , 178 , 117 , 2 ] , [ b_workshop , 197 , 144 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] ] ) ;
 864: LD_INT 1
 866: PPUSH
 867: LD_INT 6
 869: PUSH
 870: LD_INT 200
 872: PUSH
 873: LD_INT 111
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: PUSH
 885: LD_INT 29
 887: PUSH
 888: LD_INT 167
 890: PUSH
 891: LD_INT 102
 893: PUSH
 894: LD_INT 0
 896: PUSH
 897: EMPTY
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: PUSH
 903: LD_INT 4
 905: PUSH
 906: LD_INT 178
 908: PUSH
 909: LD_INT 117
 911: PUSH
 912: LD_INT 2
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 197
 926: PUSH
 927: LD_INT 144
 929: PUSH
 930: LD_INT 4
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: PUSH
 939: LD_INT 27
 941: PUSH
 942: LD_INT 206
 944: PUSH
 945: LD_INT 124
 947: PUSH
 948: LD_INT 3
 950: PUSH
 951: EMPTY
 952: LIST
 953: LIST
 954: LIST
 955: LIST
 956: PUSH
 957: LD_INT 27
 959: PUSH
 960: LD_INT 209
 962: PUSH
 963: LD_INT 128
 965: PUSH
 966: LD_INT 3
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: LIST
 973: LIST
 974: PUSH
 975: LD_INT 27
 977: PUSH
 978: LD_INT 211
 980: PUSH
 981: LD_INT 132
 983: PUSH
 984: LD_INT 3
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PUSH
 993: LD_INT 30
 995: PUSH
 996: LD_INT 173
 998: PUSH
 999: LD_INT 83
1001: PUSH
1002: LD_INT 3
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: PUSH
1011: LD_INT 6
1013: PUSH
1014: LD_INT 186
1016: PUSH
1017: LD_INT 103
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: PUSH
1029: LD_INT 33
1031: PUSH
1032: LD_INT 173
1034: PUSH
1035: LD_INT 99
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_INT 32
1049: PUSH
1050: LD_INT 174
1052: PUSH
1053: LD_INT 102
1055: PUSH
1056: LD_INT 2
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PUSH
1065: LD_INT 32
1067: PUSH
1068: LD_INT 178
1070: PUSH
1071: LD_INT 100
1073: PUSH
1074: LD_INT 2
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: LD_INT 33
1085: PUSH
1086: LD_INT 174
1088: PUSH
1089: LD_INT 108
1091: PUSH
1092: LD_INT 1
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_INT 33
1103: PUSH
1104: LD_INT 182
1106: PUSH
1107: LD_INT 122
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: PUSH
1119: LD_INT 36
1121: PUSH
1122: LD_INT 194
1124: PUSH
1125: LD_INT 124
1127: PUSH
1128: LD_INT 5
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: PUSH
1137: LD_INT 28
1139: PUSH
1140: LD_INT 204
1142: PUSH
1143: LD_INT 133
1145: PUSH
1146: LD_INT 3
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 27
1157: PUSH
1158: LD_INT 201
1160: PUSH
1161: LD_INT 133
1163: PUSH
1164: LD_INT 3
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 28
1175: PUSH
1176: LD_INT 199
1178: PUSH
1179: LD_INT 119
1181: PUSH
1182: LD_INT 5
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 33
1193: PUSH
1194: LD_INT 184
1196: PUSH
1197: LD_INT 141
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 33
1211: PUSH
1212: LD_INT 183
1214: PUSH
1215: LD_INT 131
1217: PUSH
1218: LD_INT 2
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: LIST
1248: PPUSH
1249: CALL 65121 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1253: LD_INT 1
1255: PPUSH
1256: LD_INT 10
1258: PUSH
1259: LD_INT 15
1261: PUSH
1262: LD_INT 12
1264: PUSH
1265: LD_INT 11
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: PPUSH
1274: CALL 65971 0 2
// MC_SetFactoryExtension ( 1 , 197 , 144 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1278: LD_INT 1
1280: PPUSH
1281: LD_INT 197
1283: PPUSH
1284: LD_INT 144
1286: PPUSH
1287: LD_INT 4
1289: PPUSH
1290: LD_INT 19
1292: PUSH
1293: LD_INT 16
1295: PUSH
1296: LD_INT 17
1298: PUSH
1299: LD_INT 18
1301: PUSH
1302: LD_INT 22
1304: PUSH
1305: EMPTY
1306: LIST
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PPUSH
1312: CALL 66176 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 0
1321: PPUSH
1322: CALL 65844 0 2
// end ; end_of_file
1326: LD_VAR 0 1
1330: RET
// export Gensher , gensher_side ; export function PrepareGensher ; var i , tmp , un ; begin
1331: LD_INT 0
1333: PPUSH
1334: PPUSH
1335: PPUSH
1336: PPUSH
// gensher_side := 2 ;
1337: LD_ADDR_EXP 7
1341: PUSH
1342: LD_INT 2
1344: ST_TO_ADDR
// uc_side := gensher_side ;
1345: LD_ADDR_OWVAR 20
1349: PUSH
1350: LD_EXP 7
1354: ST_TO_ADDR
// uc_nation := 2 ;
1355: LD_ADDR_OWVAR 21
1359: PUSH
1360: LD_INT 2
1362: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
1363: LD_ADDR_VAR 0 3
1367: PUSH
1368: LD_INT 7
1370: PPUSH
1371: LD_INT 2
1373: PPUSH
1374: LD_STRING 
1376: PPUSH
1377: LD_INT 8
1379: PUSH
1380: LD_INT 7
1382: PUSH
1383: LD_INT 6
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: LIST
1390: PUSH
1391: LD_OWVAR 67
1395: ARRAY
1396: PPUSH
1397: LD_INT 1500
1399: PUSH
1400: LD_INT 300
1402: PUSH
1403: LD_INT 30
1405: PUSH
1406: EMPTY
1407: LIST
1408: LIST
1409: LIST
1410: PPUSH
1411: LD_INT 4
1413: PUSH
1414: LD_INT 4
1416: PUSH
1417: LD_INT 4
1419: PUSH
1420: LD_INT 4
1422: PUSH
1423: EMPTY
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: PPUSH
1429: CALL 12714 0 6
1433: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
1434: LD_ADDR_EXP 14
1438: PUSH
1439: LD_EXP 14
1443: PPUSH
1444: LD_INT 2
1446: PPUSH
1447: LD_VAR 0 3
1451: PPUSH
1452: CALL_OW 1
1456: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
1457: LD_ADDR_VAR 0 3
1461: PUSH
1462: LD_INT 22
1464: PUSH
1465: LD_INT 2
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: PUSH
1472: LD_INT 30
1474: PUSH
1475: LD_INT 31
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: PPUSH
1486: CALL_OW 69
1490: ST_TO_ADDR
// for i in tmp do
1491: LD_ADDR_VAR 0 2
1495: PUSH
1496: LD_VAR 0 3
1500: PUSH
1501: FOR_IN
1502: IFFALSE 1572
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
1504: LD_INT 0
1506: PPUSH
1507: LD_INT 1
1509: PPUSH
1510: LD_INT 4
1512: PUSH
1513: LD_INT 3
1515: PUSH
1516: LD_INT 3
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: LD_OWVAR 67
1528: ARRAY
1529: PPUSH
1530: CALL_OW 380
// un := CreateHuman ;
1534: LD_ADDR_VAR 0 4
1538: PUSH
1539: CALL_OW 44
1543: ST_TO_ADDR
// SetDir ( un , 1 ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 52
// end ;
1570: GO 1501
1572: POP
1573: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
1574: LD_ADDR_VAR 0 3
1578: PUSH
1579: LD_INT 15
1581: PPUSH
1582: LD_INT 0
1584: PPUSH
1585: CALL_OW 517
1589: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: DOUBLE
1596: LD_INT 1
1598: DEC
1599: ST_TO_ADDR
1600: LD_VAR 0 3
1604: PUSH
1605: LD_INT 1
1607: ARRAY
1608: PUSH
1609: FOR_TO
1610: IFFALSE 1712
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
1612: LD_VAR 0 3
1616: PUSH
1617: LD_INT 1
1619: ARRAY
1620: PUSH
1621: LD_VAR 0 2
1625: ARRAY
1626: PPUSH
1627: LD_VAR 0 3
1631: PUSH
1632: LD_INT 2
1634: ARRAY
1635: PUSH
1636: LD_VAR 0 2
1640: ARRAY
1641: PPUSH
1642: LD_INT 2
1644: PPUSH
1645: LD_INT 0
1647: PPUSH
1648: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
1652: LD_ADDR_EXP 3
1656: PUSH
1657: LD_EXP 3
1661: PPUSH
1662: LD_EXP 3
1666: PUSH
1667: LD_INT 1
1669: PLUS
1670: PPUSH
1671: LD_VAR 0 3
1675: PUSH
1676: LD_INT 1
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 2
1684: ARRAY
1685: PUSH
1686: LD_VAR 0 3
1690: PUSH
1691: LD_INT 2
1693: ARRAY
1694: PUSH
1695: LD_VAR 0 2
1699: ARRAY
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: PPUSH
1705: CALL_OW 2
1709: ST_TO_ADDR
// end ;
1710: GO 1609
1712: POP
1713: POP
// end ;
1714: LD_VAR 0 1
1718: RET
// export function InitMC_Gensher ( ) ; begin
1719: LD_INT 0
1721: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
1722: LD_INT 2
1724: PPUSH
1725: LD_INT 2
1727: PPUSH
1728: CALL 66550 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
1732: LD_INT 2
1734: PPUSH
1735: LD_INT 9
1737: PPUSH
1738: CALL 66494 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
1742: LD_INT 2
1744: PPUSH
1745: LD_INT 56
1747: PUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 0
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_INT 52
1761: PUSH
1762: LD_INT 40
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: LIST
1772: PUSH
1773: EMPTY
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 65553 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
1781: LD_INT 2
1783: PPUSH
1784: LD_INT 27
1786: PUSH
1787: LD_INT 28
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PPUSH
1794: CALL 66382 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
1798: LD_INT 2
1800: PPUSH
1801: LD_INT 8
1803: PPUSH
1804: CALL 66064 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
1808: LD_INT 2
1810: PPUSH
1811: LD_INT 7
1813: PPUSH
1814: CALL 65795 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
1818: LD_INT 2
1820: PPUSH
1821: LD_INT 4
1823: PPUSH
1824: CALL 65414 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower ] ] ) ;
1828: LD_INT 2
1830: PPUSH
1831: LD_INT 13
1833: PUSH
1834: LD_INT 2
1836: PUSH
1837: LD_INT 1
1839: PUSH
1840: LD_INT 31
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_INT 13
1851: PUSH
1852: LD_INT 2
1854: PUSH
1855: LD_INT 1
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: LD_INT 14
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 2
1875: PUSH
1876: LD_INT 27
1878: PUSH
1879: EMPTY
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: PUSH
1885: LD_INT 14
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 2
1893: PUSH
1894: LD_INT 27
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: PUSH
1903: LD_INT 14
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 2
1911: PUSH
1912: LD_INT 28
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: PUSH
1921: LD_INT 14
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 1
1929: PUSH
1930: LD_INT 26
1932: PUSH
1933: EMPTY
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: PUSH
1939: EMPTY
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: PPUSH
1947: CALL 65229 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 13 , 18 , 1 ] , [ b_lab , 17 , 27 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_armoury , 42 , 29 , 5 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
1951: LD_INT 2
1953: PPUSH
1954: LD_INT 6
1956: PUSH
1957: LD_INT 13
1959: PUSH
1960: LD_INT 18
1962: PUSH
1963: LD_INT 1
1965: PUSH
1966: EMPTY
1967: LIST
1968: LIST
1969: LIST
1970: LIST
1971: PUSH
1972: LD_INT 6
1974: PUSH
1975: LD_INT 17
1977: PUSH
1978: LD_INT 27
1980: PUSH
1981: LD_INT 1
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: LIST
1988: LIST
1989: PUSH
1990: LD_INT 27
1992: PUSH
1993: LD_INT 17
1995: PUSH
1996: LD_INT 3
1998: PUSH
1999: LD_INT 0
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: PUSH
2008: LD_INT 29
2010: PUSH
2011: LD_INT 56
2013: PUSH
2014: LD_INT 23
2016: PUSH
2017: LD_INT 0
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: LIST
2025: PUSH
2026: LD_INT 4
2028: PUSH
2029: LD_INT 42
2031: PUSH
2032: LD_INT 29
2034: PUSH
2035: LD_INT 5
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: PUSH
2044: LD_INT 2
2046: PUSH
2047: LD_INT 11
2049: PUSH
2050: LD_INT 7
2052: PUSH
2053: LD_INT 2
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: PUSH
2062: LD_INT 27
2064: PUSH
2065: LD_INT 20
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: LD_INT 0
2073: PUSH
2074: EMPTY
2075: LIST
2076: LIST
2077: LIST
2078: LIST
2079: PUSH
2080: LD_INT 27
2082: PUSH
2083: LD_INT 23
2085: PUSH
2086: LD_INT 3
2088: PUSH
2089: LD_INT 0
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_INT 27
2100: PUSH
2101: LD_INT 26
2103: PUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 0
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: PUSH
2116: LD_INT 32
2118: PUSH
2119: LD_INT 27
2121: PUSH
2122: LD_INT 44
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: PUSH
2134: LD_INT 32
2136: PUSH
2137: LD_INT 41
2139: PUSH
2140: LD_INT 41
2142: PUSH
2143: LD_INT 5
2145: PUSH
2146: EMPTY
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 32
2154: PUSH
2155: LD_INT 45
2157: PUSH
2158: LD_INT 24
2160: PUSH
2161: LD_INT 5
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: LD_INT 32
2172: PUSH
2173: LD_INT 48
2175: PUSH
2176: LD_INT 19
2178: PUSH
2179: LD_INT 5
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: PUSH
2188: LD_INT 32
2190: PUSH
2191: LD_INT 41
2193: PUSH
2194: LD_INT 3
2196: PUSH
2197: LD_INT 4
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: PUSH
2206: LD_INT 4
2208: PUSH
2209: LD_INT 44
2211: PUSH
2212: LD_INT 9
2214: PUSH
2215: LD_INT 4
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 30
2226: PUSH
2227: LD_INT 52
2229: PUSH
2230: LD_INT 40
2232: PUSH
2233: LD_INT 3
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: LIST
2240: LIST
2241: PUSH
2242: EMPTY
2243: LIST
2244: LIST
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: LIST
2250: LIST
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: LIST
2256: LIST
2257: LIST
2258: LIST
2259: PPUSH
2260: CALL 65121 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
2264: LD_INT 2
2266: PPUSH
2267: LD_INT 10
2269: PUSH
2270: LD_INT 15
2272: PUSH
2273: LD_INT 13
2275: PUSH
2276: LD_INT 11
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: LIST
2283: LIST
2284: PPUSH
2285: CALL 65971 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
2289: LD_INT 2
2291: PPUSH
2292: LD_INT 11
2294: PPUSH
2295: LD_INT 7
2297: PPUSH
2298: LD_INT 2
2300: PPUSH
2301: LD_INT 23
2303: PUSH
2304: LD_INT 16
2306: PUSH
2307: LD_INT 17
2309: PUSH
2310: LD_INT 18
2312: PUSH
2313: LD_INT 22
2315: PUSH
2316: EMPTY
2317: LIST
2318: LIST
2319: LIST
2320: LIST
2321: LIST
2322: PPUSH
2323: CALL 66176 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
2327: LD_INT 2
2329: PPUSH
2330: LD_INT 0
2332: PPUSH
2333: CALL 65844 0 2
// end ;
2337: LD_VAR 0 1
2341: RET
// every 10 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
2342: LD_EXP 3
2346: PUSH
2347: LD_INT 15
2349: PPUSH
2350: LD_INT 81
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: PPUSH
2360: CALL_OW 70
2364: AND
2365: IFFALSE 2578
2367: GO 2369
2369: DISABLE
2370: LD_INT 0
2372: PPUSH
2373: PPUSH
2374: PPUSH
2375: PPUSH
2376: PPUSH
// begin enable ;
2377: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: LD_INT 15
2385: PPUSH
2386: LD_INT 81
2388: PUSH
2389: LD_INT 2
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: PPUSH
2396: CALL_OW 70
2400: ST_TO_ADDR
// if not tmp then
2401: LD_VAR 0 3
2405: NOT
2406: IFFALSE 2410
// exit ;
2408: GO 2578
// for i in tmp do
2410: LD_ADDR_VAR 0 1
2414: PUSH
2415: LD_VAR 0 3
2419: PUSH
2420: FOR_IN
2421: IFFALSE 2576
// begin x := GetX ( i ) ;
2423: LD_ADDR_VAR 0 4
2427: PUSH
2428: LD_VAR 0 1
2432: PPUSH
2433: CALL_OW 250
2437: ST_TO_ADDR
// y := GetY ( i ) ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 1
2447: PPUSH
2448: CALL_OW 251
2452: ST_TO_ADDR
// if MineAtPos ( x , y ) then
2453: LD_VAR 0 4
2457: PPUSH
2458: LD_VAR 0 5
2462: PPUSH
2463: CALL_OW 458
2467: IFFALSE 2574
// begin LaunchMineAtPos ( x , y , 2 ) ;
2469: LD_VAR 0 4
2473: PPUSH
2474: LD_VAR 0 5
2478: PPUSH
2479: LD_INT 2
2481: PPUSH
2482: CALL_OW 456
// for j = 1 to staticMines do
2486: LD_ADDR_VAR 0 2
2490: PUSH
2491: DOUBLE
2492: LD_INT 1
2494: DEC
2495: ST_TO_ADDR
2496: LD_EXP 3
2500: PUSH
2501: FOR_TO
2502: IFFALSE 2572
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
2504: LD_EXP 3
2508: PUSH
2509: LD_VAR 0 2
2513: ARRAY
2514: PUSH
2515: LD_INT 1
2517: ARRAY
2518: PUSH
2519: LD_VAR 0 4
2523: EQUAL
2524: PUSH
2525: LD_EXP 3
2529: PUSH
2530: LD_VAR 0 2
2534: ARRAY
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: PUSH
2540: LD_VAR 0 5
2544: EQUAL
2545: AND
2546: IFFALSE 2570
// begin staticMines := Delete ( staticMines , j ) ;
2548: LD_ADDR_EXP 3
2552: PUSH
2553: LD_EXP 3
2557: PPUSH
2558: LD_VAR 0 2
2562: PPUSH
2563: CALL_OW 3
2567: ST_TO_ADDR
// break ;
2568: GO 2572
// end ;
2570: GO 2501
2572: POP
2573: POP
// end ; end ;
2574: GO 2420
2576: POP
2577: POP
// end ; end_of_file
2578: PPOPN 5
2580: END
// export Popov , popov_side , extraPopovForces ; export function PreparePopov ; var i , un , tmp ; begin
2581: LD_INT 0
2583: PPUSH
2584: PPUSH
2585: PPUSH
2586: PPUSH
// popov_side := 3 ;
2587: LD_ADDR_EXP 9
2591: PUSH
2592: LD_INT 3
2594: ST_TO_ADDR
// uc_side := popov_side ;
2595: LD_ADDR_OWVAR 20
2599: PUSH
2600: LD_EXP 9
2604: ST_TO_ADDR
// uc_nation := 3 ;
2605: LD_ADDR_OWVAR 21
2609: PUSH
2610: LD_INT 3
2612: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
2613: LD_ADDR_VAR 0 4
2617: PUSH
2618: LD_INT 9
2620: PPUSH
2621: LD_INT 3
2623: PPUSH
2624: LD_STRING 
2626: PPUSH
2627: LD_INT 8
2629: PUSH
2630: LD_INT 7
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: LD_OWVAR 67
2645: ARRAY
2646: PPUSH
2647: LD_INT 1500
2649: PUSH
2650: LD_INT 300
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: LIST
2660: PPUSH
2661: LD_INT 4
2663: PUSH
2664: LD_INT 4
2666: PUSH
2667: LD_INT 4
2669: PUSH
2670: LD_INT 4
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: PPUSH
2679: CALL 12714 0 6
2683: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
2684: LD_ADDR_EXP 14
2688: PUSH
2689: LD_EXP 14
2693: PPUSH
2694: LD_INT 3
2696: PPUSH
2697: LD_VAR 0 4
2701: PPUSH
2702: CALL_OW 1
2706: ST_TO_ADDR
// extraPopovForces := [ ] ;
2707: LD_ADDR_EXP 10
2711: PUSH
2712: EMPTY
2713: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: DOUBLE
2720: LD_INT 1
2722: DEC
2723: ST_TO_ADDR
2724: LD_INT 4
2726: PUSH
2727: LD_INT 5
2729: PUSH
2730: LD_INT 6
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: LIST
2737: PUSH
2738: LD_OWVAR 67
2742: ARRAY
2743: PUSH
2744: FOR_TO
2745: IFFALSE 2848
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
2747: LD_INT 0
2749: PPUSH
2750: LD_INT 1
2752: PPUSH
2753: LD_INT 4
2755: PUSH
2756: LD_INT 5
2758: PUSH
2759: LD_INT 6
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: LIST
2766: PUSH
2767: LD_OWVAR 67
2771: ARRAY
2772: PPUSH
2773: CALL_OW 380
// un := CreateHuman ;
2777: LD_ADDR_VAR 0 3
2781: PUSH
2782: CALL_OW 44
2786: ST_TO_ADDR
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) ;
2787: LD_VAR 0 3
2791: PPUSH
2792: LD_INT 131
2794: PPUSH
2795: LD_INT 110
2797: PPUSH
2798: LD_INT 8
2800: PPUSH
2801: LD_INT 0
2803: PPUSH
2804: CALL_OW 50
// ComHold ( un ) ;
2808: LD_VAR 0 3
2812: PPUSH
2813: CALL_OW 140
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
2817: LD_ADDR_EXP 10
2821: PUSH
2822: LD_EXP 10
2826: PPUSH
2827: LD_EXP 10
2831: PUSH
2832: LD_INT 1
2834: PLUS
2835: PPUSH
2836: LD_VAR 0 3
2840: PPUSH
2841: CALL_OW 1
2845: ST_TO_ADDR
// end ;
2846: GO 2744
2848: POP
2849: POP
// PrepareSoldier ( false , 6 ) ;
2850: LD_INT 0
2852: PPUSH
2853: LD_INT 6
2855: PPUSH
2856: CALL_OW 381
// un := CreateHuman ;
2860: LD_ADDR_VAR 0 3
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2870: LD_VAR 0 3
2874: PPUSH
2875: LD_INT 1
2877: PPUSH
2878: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
2882: LD_VAR 0 3
2886: PPUSH
2887: LD_INT 150
2889: PPUSH
2890: LD_INT 158
2892: PPUSH
2893: CALL_OW 428
2897: PPUSH
2898: CALL_OW 52
// end ;
2902: LD_VAR 0 1
2906: RET
// export function InitMC_Popov ( ) ; begin
2907: LD_INT 0
2909: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
2910: LD_INT 3
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL 66550 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
2920: LD_INT 3
2922: PPUSH
2923: LD_INT 10
2925: PPUSH
2926: CALL 66494 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 106 , 113 , 0 ] ] ) ;
2930: LD_INT 3
2932: PPUSH
2933: LD_INT 86
2935: PUSH
2936: LD_INT 118
2938: PUSH
2939: LD_INT 0
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: LD_INT 123
2949: PUSH
2950: LD_INT 151
2952: PUSH
2953: LD_INT 1
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 106
2963: PUSH
2964: LD_INT 113
2966: PUSH
2967: LD_INT 0
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: LIST
2974: PUSH
2975: EMPTY
2976: LIST
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL 65553 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ) ;
2984: LD_INT 3
2986: PPUSH
2987: LD_INT 46
2989: PUSH
2990: LD_INT 45
2992: PUSH
2993: LD_INT 47
2995: PUSH
2996: LD_INT 49
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: LIST
3004: PPUSH
3005: CALL 66382 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
3009: LD_INT 3
3011: PPUSH
3012: LD_INT 12
3014: PPUSH
3015: CALL 66064 0 2
// MC_SetTame ( 3 , popov_ape ) ;
3019: LD_INT 3
3021: PPUSH
3022: LD_INT 11
3024: PPUSH
3025: CALL 65795 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
3029: LD_INT 3
3031: PPUSH
3032: LD_INT 4
3034: PPUSH
3035: CALL 65414 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
3039: LD_INT 3
3041: PPUSH
3042: LD_INT 23
3044: PUSH
3045: LD_INT 1
3047: PUSH
3048: LD_INT 1
3050: PUSH
3051: LD_INT 44
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PUSH
3060: LD_INT 23
3062: PUSH
3063: LD_INT 1
3065: PUSH
3066: LD_INT 3
3068: PUSH
3069: LD_INT 45
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_INT 21
3080: PUSH
3081: LD_INT 1
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: LD_INT 43
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: PUSH
3096: LD_INT 21
3098: PUSH
3099: LD_INT 1
3101: PUSH
3102: LD_INT 3
3104: PUSH
3105: LD_INT 45
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL 65229 0 2
// MC_SetBuildingList ( 3 , [ [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 106 , 113 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_armoury , 103 , 147 , 3 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] , [ b_teleport , 91 , 147 , 3 ] ] ) ;
3124: LD_INT 3
3126: PPUSH
3127: LD_INT 6
3129: PUSH
3130: LD_INT 76
3132: PUSH
3133: LD_INT 145
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: PUSH
3145: LD_INT 26
3147: PUSH
3148: LD_INT 87
3150: PUSH
3151: LD_INT 144
3153: PUSH
3154: LD_INT 0
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: LIST
3161: LIST
3162: PUSH
3163: LD_INT 29
3165: PUSH
3166: LD_INT 86
3168: PUSH
3169: LD_INT 118
3171: PUSH
3172: LD_INT 0
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 29
3183: PUSH
3184: LD_INT 106
3186: PUSH
3187: LD_INT 113
3189: PUSH
3190: LD_INT 0
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: PUSH
3199: LD_INT 26
3201: PUSH
3202: LD_INT 87
3204: PUSH
3205: LD_INT 147
3207: PUSH
3208: LD_INT 1
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 94
3222: PUSH
3223: LD_INT 161
3225: PUSH
3226: LD_INT 0
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 81
3240: PUSH
3241: LD_INT 155
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 4
3255: PUSH
3256: LD_INT 103
3258: PUSH
3259: LD_INT 147
3261: PUSH
3262: LD_INT 3
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 26
3273: PUSH
3274: LD_INT 96
3276: PUSH
3277: LD_INT 152
3279: PUSH
3280: LD_INT 0
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 26
3291: PUSH
3292: LD_INT 96
3294: PUSH
3295: LD_INT 149
3297: PUSH
3298: LD_INT 3
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 32
3309: PUSH
3310: LD_INT 109
3312: PUSH
3313: LD_INT 142
3315: PUSH
3316: LD_INT 3
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 32
3327: PUSH
3328: LD_INT 112
3330: PUSH
3331: LD_INT 148
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 33
3345: PUSH
3346: LD_INT 120
3348: PUSH
3349: LD_INT 159
3351: PUSH
3352: LD_INT 4
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 33
3363: PUSH
3364: LD_INT 122
3366: PUSH
3367: LD_INT 163
3369: PUSH
3370: LD_INT 4
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 33
3381: PUSH
3382: LD_INT 123
3384: PUSH
3385: LD_INT 167
3387: PUSH
3388: LD_INT 4
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 33
3399: PUSH
3400: LD_INT 59
3402: PUSH
3403: LD_INT 111
3405: PUSH
3406: LD_INT 3
3408: PUSH
3409: EMPTY
3410: LIST
3411: LIST
3412: LIST
3413: LIST
3414: PUSH
3415: LD_INT 33
3417: PUSH
3418: LD_INT 65
3420: PUSH
3421: LD_INT 111
3423: PUSH
3424: LD_INT 3
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: PUSH
3433: LD_INT 33
3435: PUSH
3436: LD_INT 76
3438: PUSH
3439: LD_INT 117
3441: PUSH
3442: LD_INT 3
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: LIST
3449: LIST
3450: PUSH
3451: LD_INT 33
3453: PUSH
3454: LD_INT 80
3456: PUSH
3457: LD_INT 119
3459: PUSH
3460: LD_INT 3
3462: PUSH
3463: EMPTY
3464: LIST
3465: LIST
3466: LIST
3467: LIST
3468: PUSH
3469: LD_INT 33
3471: PUSH
3472: LD_INT 87
3474: PUSH
3475: LD_INT 125
3477: PUSH
3478: LD_INT 3
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 4
3489: PUSH
3490: LD_INT 92
3492: PUSH
3493: LD_INT 129
3495: PUSH
3496: LD_INT 3
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 28
3507: PUSH
3508: LD_INT 85
3510: PUSH
3511: LD_INT 165
3513: PUSH
3514: LD_INT 0
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 28
3525: PUSH
3526: LD_INT 83
3528: PUSH
3529: LD_INT 161
3531: PUSH
3532: LD_INT 4
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: LD_INT 28
3543: PUSH
3544: LD_INT 91
3546: PUSH
3547: LD_INT 166
3549: PUSH
3550: LD_INT 3
3552: PUSH
3553: EMPTY
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 28
3561: PUSH
3562: LD_INT 102
3564: PUSH
3565: LD_INT 166
3567: PUSH
3568: LD_INT 2
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PUSH
3577: LD_INT 34
3579: PUSH
3580: LD_INT 91
3582: PUSH
3583: LD_INT 147
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: LIST
3606: LIST
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: LIST
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: PPUSH
3623: CALL 65121 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
3627: LD_INT 3
3629: PPUSH
3630: LD_INT 10
3632: PUSH
3633: LD_INT 12
3635: PUSH
3636: LD_INT 14
3638: PUSH
3639: LD_INT 11
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: LIST
3646: LIST
3647: PPUSH
3648: CALL 65971 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
3652: LD_INT 3
3654: PPUSH
3655: LD_INT 94
3657: PPUSH
3658: LD_INT 161
3660: PPUSH
3661: LD_INT 0
3663: PPUSH
3664: LD_INT 19
3666: PUSH
3667: LD_INT 17
3669: PUSH
3670: LD_INT 18
3672: PUSH
3673: LD_INT 24
3675: PUSH
3676: LD_INT 21
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: PPUSH
3686: CALL 66176 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
3690: LD_INT 3
3692: PPUSH
3693: LD_INT 0
3695: PPUSH
3696: CALL 65844 0 2
// end ; end_of_file
3700: LD_VAR 0 1
3704: RET
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
3705: LD_INT 0
3707: PPUSH
3708: PPUSH
3709: PPUSH
3710: PPUSH
// uc_side := 1 ;
3711: LD_ADDR_OWVAR 20
3715: PUSH
3716: LD_INT 1
3718: ST_TO_ADDR
// uc_nation := 1 ;
3719: LD_ADDR_OWVAR 21
3723: PUSH
3724: LD_INT 1
3726: ST_TO_ADDR
// hc_importance := 100 ;
3727: LD_ADDR_OWVAR 32
3731: PUSH
3732: LD_INT 100
3734: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
3735: LD_ADDR_OWVAR 26
3739: PUSH
3740: LD_STRING Jeremy Sikorski
3742: ST_TO_ADDR
// hc_gallery := us ;
3743: LD_ADDR_OWVAR 33
3747: PUSH
3748: LD_STRING us
3750: ST_TO_ADDR
// hc_face_number := 19 ;
3751: LD_ADDR_OWVAR 34
3755: PUSH
3756: LD_INT 19
3758: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
3759: LD_INT 1
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 4
3767: PUSH
3768: LD_INT 4
3770: PUSH
3771: LD_INT 3
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3789: LD_ADDR_OWVAR 29
3793: PUSH
3794: LD_INT 10
3796: PUSH
3797: LD_INT 12
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: ST_TO_ADDR
// Sikorski := CreateHuman ;
3804: LD_ADDR_EXP 11
3808: PUSH
3809: CALL_OW 44
3813: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
3814: LD_EXP 11
3818: PPUSH
3819: LD_INT 133
3821: PPUSH
3822: LD_INT 19
3824: PPUSH
3825: LD_INT 2
3827: PPUSH
3828: LD_INT 0
3830: PPUSH
3831: CALL_OW 50
// InitHc_All ( ) ;
3835: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3839: LD_ADDR_VAR 0 2
3843: PUSH
3844: DOUBLE
3845: LD_INT 1
3847: DEC
3848: ST_TO_ADDR
3849: LD_INT 4
3851: PUSH
3852: LD_INT 3
3854: PUSH
3855: LD_INT 3
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: LIST
3862: PUSH
3863: LD_OWVAR 67
3867: ARRAY
3868: PUSH
3869: FOR_TO
3870: IFFALSE 3986
// for j := 1 to 4 do
3872: LD_ADDR_VAR 0 3
3876: PUSH
3877: DOUBLE
3878: LD_INT 1
3880: DEC
3881: ST_TO_ADDR
3882: LD_INT 4
3884: PUSH
3885: FOR_TO
3886: IFFALSE 3982
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
3888: LD_INT 0
3890: PPUSH
3891: LD_VAR 0 3
3895: PPUSH
3896: LD_INT 5
3898: PUSH
3899: LD_INT 4
3901: PUSH
3902: LD_INT 3
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_OWVAR 67
3914: ARRAY
3915: PPUSH
3916: CALL_OW 380
// un := CreateHuman ;
3920: LD_ADDR_VAR 0 4
3924: PUSH
3925: CALL_OW 44
3929: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3930: LD_VAR 0 4
3934: PPUSH
3935: LD_INT 0
3937: PPUSH
3938: LD_INT 5
3940: PPUSH
3941: CALL_OW 12
3945: PPUSH
3946: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
3950: LD_VAR 0 4
3954: PPUSH
3955: LD_INT 133
3957: PPUSH
3958: LD_INT 19
3960: PPUSH
3961: LD_INT 6
3963: PPUSH
3964: LD_INT 0
3966: PPUSH
3967: CALL_OW 50
// ComHold ( un ) ;
3971: LD_VAR 0 4
3975: PPUSH
3976: CALL_OW 140
// end ;
3980: GO 3885
3982: POP
3983: POP
3984: GO 3869
3986: POP
3987: POP
// vc_chassis := us_heavy_tracked ;
3988: LD_ADDR_OWVAR 37
3992: PUSH
3993: LD_INT 4
3995: ST_TO_ADDR
// vc_engine := engine_combustion ;
3996: LD_ADDR_OWVAR 39
4000: PUSH
4001: LD_INT 1
4003: ST_TO_ADDR
// vc_control := control_manual ;
4004: LD_ADDR_OWVAR 38
4008: PUSH
4009: LD_INT 1
4011: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
4012: LD_ADDR_OWVAR 40
4016: PUSH
4017: LD_INT 14
4019: ST_TO_ADDR
// vc_fuel_battery := 60 ;
4020: LD_ADDR_OWVAR 41
4024: PUSH
4025: LD_INT 60
4027: ST_TO_ADDR
// un := CreateVehicle ;
4028: LD_ADDR_VAR 0 4
4032: PUSH
4033: CALL_OW 45
4037: ST_TO_ADDR
// SetDir ( un , 2 ) ;
4038: LD_VAR 0 4
4042: PPUSH
4043: LD_INT 2
4045: PPUSH
4046: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
4050: LD_VAR 0 4
4054: PPUSH
4055: LD_INT 128
4057: PPUSH
4058: LD_INT 12
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 48
// for i := 1 to 3 do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_INT 3
4080: PUSH
4081: FOR_TO
4082: IFFALSE 4105
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
4084: LD_INT 5
4086: PPUSH
4087: LD_INT 133
4089: PPUSH
4090: LD_INT 19
4092: PPUSH
4093: LD_INT 3
4095: PPUSH
4096: LD_INT 0
4098: PPUSH
4099: CALL_OW 56
4103: GO 4081
4105: POP
4106: POP
// end ; end_of_file
4107: LD_VAR 0 1
4111: RET
// export function Action ; begin
4112: LD_INT 0
4114: PPUSH
// wait ( 0 0$5 ) ;
4115: LD_INT 175
4117: PPUSH
4118: CALL_OW 67
// InGameOn ;
4122: CALL_OW 8
// wait ( 0 0$2 ) ;
4126: LD_INT 70
4128: PPUSH
4129: CALL_OW 67
// CenterNowOnXY ( 133 , 19 ) ;
4133: LD_INT 133
4135: PPUSH
4136: LD_INT 19
4138: PPUSH
4139: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
4143: LD_EXP 11
4147: PPUSH
4148: LD_STRING WT-DS-1
4150: PPUSH
4151: CALL_OW 88
// wait ( 0 0$5 ) ;
4155: LD_INT 175
4157: PPUSH
4158: CALL_OW 67
// InGameOff ;
4162: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
4166: LD_STRING DestroyEnemy
4168: PPUSH
4169: CALL_OW 337
// end ; end_of_file
4173: LD_VAR 0 1
4177: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
4178: LD_VAR 0 1
4182: PPUSH
4183: CALL 68688 0 1
// if un = Powell then
4187: LD_VAR 0 1
4191: PUSH
4192: LD_EXP 4
4196: EQUAL
4197: IFFALSE 4206
// YouLost ( Powell ) ;
4199: LD_STRING Powell
4201: PPUSH
4202: CALL_OW 104
// end ;
4206: PPOPN 1
4208: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
4209: LD_VAR 0 1
4213: PPUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: CALL 71022 0 2
// end ;
4223: PPOPN 2
4225: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
4226: LD_VAR 0 1
4230: PPUSH
4231: CALL 70090 0 1
// end ;
4235: PPOPN 1
4237: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
4238: LD_VAR 0 1
4242: PPUSH
4243: CALL 70331 0 1
// end ;
4247: PPOPN 1
4249: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
4250: LD_VAR 0 1
4254: PPUSH
4255: LD_VAR 0 2
4259: PPUSH
4260: CALL 68384 0 2
// end ;
4264: PPOPN 2
4266: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
4267: LD_VAR 0 1
4271: PPUSH
4272: LD_VAR 0 2
4276: PPUSH
4277: LD_VAR 0 3
4281: PPUSH
4282: LD_VAR 0 4
4286: PPUSH
4287: LD_VAR 0 5
4291: PPUSH
4292: CALL 68004 0 5
// end ;
4296: PPOPN 5
4298: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
4299: LD_VAR 0 1
4303: PPUSH
4304: LD_VAR 0 2
4308: PPUSH
4309: CALL 67594 0 2
// end ;
4313: PPOPN 2
4315: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
4316: LD_VAR 0 1
4320: PPUSH
4321: LD_VAR 0 2
4325: PPUSH
4326: LD_VAR 0 3
4330: PPUSH
4331: LD_VAR 0 4
4335: PPUSH
4336: CALL 67432 0 4
// end ;
4340: PPOPN 4
4342: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
4343: LD_VAR 0 1
4347: PPUSH
4348: LD_VAR 0 2
4352: PPUSH
4353: LD_VAR 0 3
4357: PPUSH
4358: CALL 67207 0 3
// end ;
4362: PPOPN 3
4364: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
4365: LD_VAR 0 1
4369: PPUSH
4370: LD_VAR 0 2
4374: PPUSH
4375: CALL 67092 0 2
// end ;
4379: PPOPN 2
4381: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
4382: LD_VAR 0 1
4386: PPUSH
4387: LD_VAR 0 2
4391: PPUSH
4392: CALL 71283 0 2
// end ;
4396: PPOPN 2
4398: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
4399: LD_VAR 0 1
4403: PPUSH
4404: LD_VAR 0 2
4408: PPUSH
4409: LD_VAR 0 3
4413: PPUSH
4414: LD_VAR 0 4
4418: PPUSH
4419: CALL 71499 0 4
// end ;
4423: PPOPN 4
4425: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
4426: LD_VAR 0 1
4430: PPUSH
4431: LD_VAR 0 2
4435: PPUSH
4436: CALL 66901 0 2
// end ;
4440: PPOPN 2
4442: END
// export function CustomEvent ( event ) ; begin
4443: LD_INT 0
4445: PPUSH
// end ;
4446: LD_VAR 0 2
4450: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
4451: LD_VAR 0 1
4455: PUSH
4456: LD_INT 1
4458: EQUAL
4459: PUSH
4460: LD_VAR 0 2
4464: PUSH
4465: LD_INT 4
4467: EQUAL
4468: AND
4469: IFFALSE 4478
// YouLost ( FriendlyFire ) ;
4471: LD_STRING FriendlyFire
4473: PPUSH
4474: CALL_OW 104
// end ; end_of_file
4478: PPOPN 2
4480: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4481: LD_INT 0
4483: PPUSH
4484: PPUSH
// if exist_mode then
4485: LD_VAR 0 2
4489: IFFALSE 4514
// unit := CreateCharacter ( prefix & ident ) else
4491: LD_ADDR_VAR 0 5
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_VAR 0 1
4505: STR
4506: PPUSH
4507: CALL_OW 34
4511: ST_TO_ADDR
4512: GO 4529
// unit := NewCharacter ( ident ) ;
4514: LD_ADDR_VAR 0 5
4518: PUSH
4519: LD_VAR 0 1
4523: PPUSH
4524: CALL_OW 25
4528: ST_TO_ADDR
// result := unit ;
4529: LD_ADDR_VAR 0 4
4533: PUSH
4534: LD_VAR 0 5
4538: ST_TO_ADDR
// end ;
4539: LD_VAR 0 4
4543: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// if not side or not nation then
4548: LD_VAR 0 1
4552: NOT
4553: PUSH
4554: LD_VAR 0 2
4558: NOT
4559: OR
4560: IFFALSE 4564
// exit ;
4562: GO 5328
// case nation of nation_american :
4564: LD_VAR 0 2
4568: PUSH
4569: LD_INT 1
4571: DOUBLE
4572: EQUAL
4573: IFTRUE 4577
4575: GO 4791
4577: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
4578: LD_ADDR_VAR 0 4
4582: PUSH
4583: LD_INT 35
4585: PUSH
4586: LD_INT 45
4588: PUSH
4589: LD_INT 46
4591: PUSH
4592: LD_INT 47
4594: PUSH
4595: LD_INT 82
4597: PUSH
4598: LD_INT 83
4600: PUSH
4601: LD_INT 84
4603: PUSH
4604: LD_INT 85
4606: PUSH
4607: LD_INT 86
4609: PUSH
4610: LD_INT 1
4612: PUSH
4613: LD_INT 2
4615: PUSH
4616: LD_INT 6
4618: PUSH
4619: LD_INT 15
4621: PUSH
4622: LD_INT 16
4624: PUSH
4625: LD_INT 7
4627: PUSH
4628: LD_INT 12
4630: PUSH
4631: LD_INT 13
4633: PUSH
4634: LD_INT 10
4636: PUSH
4637: LD_INT 14
4639: PUSH
4640: LD_INT 20
4642: PUSH
4643: LD_INT 21
4645: PUSH
4646: LD_INT 22
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: LD_INT 32
4654: PUSH
4655: LD_INT 27
4657: PUSH
4658: LD_INT 36
4660: PUSH
4661: LD_INT 69
4663: PUSH
4664: LD_INT 39
4666: PUSH
4667: LD_INT 34
4669: PUSH
4670: LD_INT 40
4672: PUSH
4673: LD_INT 48
4675: PUSH
4676: LD_INT 49
4678: PUSH
4679: LD_INT 50
4681: PUSH
4682: LD_INT 51
4684: PUSH
4685: LD_INT 52
4687: PUSH
4688: LD_INT 53
4690: PUSH
4691: LD_INT 54
4693: PUSH
4694: LD_INT 55
4696: PUSH
4697: LD_INT 56
4699: PUSH
4700: LD_INT 57
4702: PUSH
4703: LD_INT 58
4705: PUSH
4706: LD_INT 59
4708: PUSH
4709: LD_INT 60
4711: PUSH
4712: LD_INT 61
4714: PUSH
4715: LD_INT 62
4717: PUSH
4718: LD_INT 80
4720: PUSH
4721: LD_INT 82
4723: PUSH
4724: LD_INT 83
4726: PUSH
4727: LD_INT 84
4729: PUSH
4730: LD_INT 85
4732: PUSH
4733: LD_INT 86
4735: PUSH
4736: EMPTY
4737: LIST
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: LIST
4743: LIST
4744: LIST
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: LIST
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: LIST
4771: LIST
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: ST_TO_ADDR
4789: GO 5252
4791: LD_INT 2
4793: DOUBLE
4794: EQUAL
4795: IFTRUE 4799
4797: GO 5021
4799: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
4800: LD_ADDR_VAR 0 4
4804: PUSH
4805: LD_INT 35
4807: PUSH
4808: LD_INT 45
4810: PUSH
4811: LD_INT 46
4813: PUSH
4814: LD_INT 47
4816: PUSH
4817: LD_INT 82
4819: PUSH
4820: LD_INT 83
4822: PUSH
4823: LD_INT 84
4825: PUSH
4826: LD_INT 85
4828: PUSH
4829: LD_INT 87
4831: PUSH
4832: LD_INT 70
4834: PUSH
4835: LD_INT 1
4837: PUSH
4838: LD_INT 11
4840: PUSH
4841: LD_INT 3
4843: PUSH
4844: LD_INT 4
4846: PUSH
4847: LD_INT 5
4849: PUSH
4850: LD_INT 6
4852: PUSH
4853: LD_INT 15
4855: PUSH
4856: LD_INT 18
4858: PUSH
4859: LD_INT 7
4861: PUSH
4862: LD_INT 17
4864: PUSH
4865: LD_INT 8
4867: PUSH
4868: LD_INT 20
4870: PUSH
4871: LD_INT 21
4873: PUSH
4874: LD_INT 22
4876: PUSH
4877: LD_INT 72
4879: PUSH
4880: LD_INT 26
4882: PUSH
4883: LD_INT 69
4885: PUSH
4886: LD_INT 39
4888: PUSH
4889: LD_INT 40
4891: PUSH
4892: LD_INT 41
4894: PUSH
4895: LD_INT 42
4897: PUSH
4898: LD_INT 43
4900: PUSH
4901: LD_INT 48
4903: PUSH
4904: LD_INT 49
4906: PUSH
4907: LD_INT 50
4909: PUSH
4910: LD_INT 51
4912: PUSH
4913: LD_INT 52
4915: PUSH
4916: LD_INT 53
4918: PUSH
4919: LD_INT 54
4921: PUSH
4922: LD_INT 55
4924: PUSH
4925: LD_INT 56
4927: PUSH
4928: LD_INT 60
4930: PUSH
4931: LD_INT 61
4933: PUSH
4934: LD_INT 62
4936: PUSH
4937: LD_INT 66
4939: PUSH
4940: LD_INT 67
4942: PUSH
4943: LD_INT 68
4945: PUSH
4946: LD_INT 81
4948: PUSH
4949: LD_INT 82
4951: PUSH
4952: LD_INT 83
4954: PUSH
4955: LD_INT 84
4957: PUSH
4958: LD_INT 85
4960: PUSH
4961: LD_INT 87
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: LIST
4974: LIST
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: LIST
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: ST_TO_ADDR
5019: GO 5252
5021: LD_INT 3
5023: DOUBLE
5024: EQUAL
5025: IFTRUE 5029
5027: GO 5251
5029: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
5030: LD_ADDR_VAR 0 4
5034: PUSH
5035: LD_INT 46
5037: PUSH
5038: LD_INT 47
5040: PUSH
5041: LD_INT 1
5043: PUSH
5044: LD_INT 2
5046: PUSH
5047: LD_INT 82
5049: PUSH
5050: LD_INT 83
5052: PUSH
5053: LD_INT 84
5055: PUSH
5056: LD_INT 85
5058: PUSH
5059: LD_INT 86
5061: PUSH
5062: LD_INT 11
5064: PUSH
5065: LD_INT 9
5067: PUSH
5068: LD_INT 20
5070: PUSH
5071: LD_INT 19
5073: PUSH
5074: LD_INT 21
5076: PUSH
5077: LD_INT 24
5079: PUSH
5080: LD_INT 22
5082: PUSH
5083: LD_INT 25
5085: PUSH
5086: LD_INT 28
5088: PUSH
5089: LD_INT 29
5091: PUSH
5092: LD_INT 30
5094: PUSH
5095: LD_INT 31
5097: PUSH
5098: LD_INT 37
5100: PUSH
5101: LD_INT 38
5103: PUSH
5104: LD_INT 32
5106: PUSH
5107: LD_INT 27
5109: PUSH
5110: LD_INT 33
5112: PUSH
5113: LD_INT 69
5115: PUSH
5116: LD_INT 39
5118: PUSH
5119: LD_INT 34
5121: PUSH
5122: LD_INT 40
5124: PUSH
5125: LD_INT 71
5127: PUSH
5128: LD_INT 23
5130: PUSH
5131: LD_INT 44
5133: PUSH
5134: LD_INT 48
5136: PUSH
5137: LD_INT 49
5139: PUSH
5140: LD_INT 50
5142: PUSH
5143: LD_INT 51
5145: PUSH
5146: LD_INT 52
5148: PUSH
5149: LD_INT 53
5151: PUSH
5152: LD_INT 54
5154: PUSH
5155: LD_INT 55
5157: PUSH
5158: LD_INT 56
5160: PUSH
5161: LD_INT 57
5163: PUSH
5164: LD_INT 58
5166: PUSH
5167: LD_INT 59
5169: PUSH
5170: LD_INT 63
5172: PUSH
5173: LD_INT 64
5175: PUSH
5176: LD_INT 65
5178: PUSH
5179: LD_INT 82
5181: PUSH
5182: LD_INT 83
5184: PUSH
5185: LD_INT 84
5187: PUSH
5188: LD_INT 85
5190: PUSH
5191: LD_INT 86
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: LIST
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: LIST
5222: LIST
5223: LIST
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: ST_TO_ADDR
5249: GO 5252
5251: POP
// if state > - 1 and state < 3 then
5252: LD_VAR 0 3
5256: PUSH
5257: LD_INT 1
5259: NEG
5260: GREATER
5261: PUSH
5262: LD_VAR 0 3
5266: PUSH
5267: LD_INT 3
5269: LESS
5270: AND
5271: IFFALSE 5328
// for i in result do
5273: LD_ADDR_VAR 0 5
5277: PUSH
5278: LD_VAR 0 4
5282: PUSH
5283: FOR_IN
5284: IFFALSE 5326
// if GetTech ( i , side ) <> state then
5286: LD_VAR 0 5
5290: PPUSH
5291: LD_VAR 0 1
5295: PPUSH
5296: CALL_OW 321
5300: PUSH
5301: LD_VAR 0 3
5305: NONEQUAL
5306: IFFALSE 5324
// result := result diff i ;
5308: LD_ADDR_VAR 0 4
5312: PUSH
5313: LD_VAR 0 4
5317: PUSH
5318: LD_VAR 0 5
5322: DIFF
5323: ST_TO_ADDR
5324: GO 5283
5326: POP
5327: POP
// end ;
5328: LD_VAR 0 4
5332: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
5333: LD_INT 0
5335: PPUSH
5336: PPUSH
5337: PPUSH
// result := true ;
5338: LD_ADDR_VAR 0 3
5342: PUSH
5343: LD_INT 1
5345: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
5346: LD_ADDR_VAR 0 5
5350: PUSH
5351: LD_VAR 0 2
5355: PPUSH
5356: CALL_OW 480
5360: ST_TO_ADDR
// if not tmp then
5361: LD_VAR 0 5
5365: NOT
5366: IFFALSE 5370
// exit ;
5368: GO 5419
// for i in tmp do
5370: LD_ADDR_VAR 0 4
5374: PUSH
5375: LD_VAR 0 5
5379: PUSH
5380: FOR_IN
5381: IFFALSE 5417
// if GetTech ( i , side ) <> state_researched then
5383: LD_VAR 0 4
5387: PPUSH
5388: LD_VAR 0 1
5392: PPUSH
5393: CALL_OW 321
5397: PUSH
5398: LD_INT 2
5400: NONEQUAL
5401: IFFALSE 5415
// begin result := false ;
5403: LD_ADDR_VAR 0 3
5407: PUSH
5408: LD_INT 0
5410: ST_TO_ADDR
// exit ;
5411: POP
5412: POP
5413: GO 5419
// end ;
5415: GO 5380
5417: POP
5418: POP
// end ;
5419: LD_VAR 0 3
5423: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
5424: LD_INT 0
5426: PPUSH
5427: PPUSH
5428: PPUSH
5429: PPUSH
5430: PPUSH
5431: PPUSH
5432: PPUSH
5433: PPUSH
5434: PPUSH
5435: PPUSH
5436: PPUSH
5437: PPUSH
5438: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
5439: LD_VAR 0 1
5443: NOT
5444: PUSH
5445: LD_VAR 0 1
5449: PPUSH
5450: CALL_OW 257
5454: PUSH
5455: LD_INT 9
5457: NONEQUAL
5458: OR
5459: IFFALSE 5463
// exit ;
5461: GO 6036
// side := GetSide ( unit ) ;
5463: LD_ADDR_VAR 0 9
5467: PUSH
5468: LD_VAR 0 1
5472: PPUSH
5473: CALL_OW 255
5477: ST_TO_ADDR
// tech_space := tech_spacanom ;
5478: LD_ADDR_VAR 0 12
5482: PUSH
5483: LD_INT 29
5485: ST_TO_ADDR
// tech_time := tech_taurad ;
5486: LD_ADDR_VAR 0 13
5490: PUSH
5491: LD_INT 28
5493: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
5494: LD_ADDR_VAR 0 11
5498: PUSH
5499: LD_VAR 0 1
5503: PPUSH
5504: CALL_OW 310
5508: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
5509: LD_VAR 0 11
5513: PPUSH
5514: CALL_OW 247
5518: PUSH
5519: LD_INT 2
5521: EQUAL
5522: IFFALSE 5526
// exit ;
5524: GO 6036
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
5526: LD_ADDR_VAR 0 8
5530: PUSH
5531: LD_INT 81
5533: PUSH
5534: LD_VAR 0 9
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PUSH
5543: LD_INT 3
5545: PUSH
5546: LD_INT 21
5548: PUSH
5549: LD_INT 3
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PPUSH
5564: CALL_OW 69
5568: ST_TO_ADDR
// if not tmp then
5569: LD_VAR 0 8
5573: NOT
5574: IFFALSE 5578
// exit ;
5576: GO 6036
// if in_unit then
5578: LD_VAR 0 11
5582: IFFALSE 5606
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
5584: LD_ADDR_VAR 0 10
5588: PUSH
5589: LD_VAR 0 8
5593: PPUSH
5594: LD_VAR 0 11
5598: PPUSH
5599: CALL_OW 74
5603: ST_TO_ADDR
5604: GO 5626
// enemy := NearestUnitToUnit ( tmp , unit ) ;
5606: LD_ADDR_VAR 0 10
5610: PUSH
5611: LD_VAR 0 8
5615: PPUSH
5616: LD_VAR 0 1
5620: PPUSH
5621: CALL_OW 74
5625: ST_TO_ADDR
// if not enemy then
5626: LD_VAR 0 10
5630: NOT
5631: IFFALSE 5635
// exit ;
5633: GO 6036
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
5635: LD_VAR 0 11
5639: PUSH
5640: LD_VAR 0 11
5644: PPUSH
5645: LD_VAR 0 10
5649: PPUSH
5650: CALL_OW 296
5654: PUSH
5655: LD_INT 13
5657: GREATER
5658: AND
5659: PUSH
5660: LD_VAR 0 1
5664: PPUSH
5665: LD_VAR 0 10
5669: PPUSH
5670: CALL_OW 296
5674: PUSH
5675: LD_INT 12
5677: GREATER
5678: OR
5679: IFFALSE 5683
// exit ;
5681: GO 6036
// missile := [ 1 ] ;
5683: LD_ADDR_VAR 0 14
5687: PUSH
5688: LD_INT 1
5690: PUSH
5691: EMPTY
5692: LIST
5693: ST_TO_ADDR
// if Researched ( side , tech_space ) then
5694: LD_VAR 0 9
5698: PPUSH
5699: LD_VAR 0 12
5703: PPUSH
5704: CALL_OW 325
5708: IFFALSE 5737
// missile := Insert ( missile , missile + 1 , 2 ) ;
5710: LD_ADDR_VAR 0 14
5714: PUSH
5715: LD_VAR 0 14
5719: PPUSH
5720: LD_VAR 0 14
5724: PUSH
5725: LD_INT 1
5727: PLUS
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 2
5736: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
5737: LD_VAR 0 9
5741: PPUSH
5742: LD_VAR 0 13
5746: PPUSH
5747: CALL_OW 325
5751: PUSH
5752: LD_VAR 0 10
5756: PPUSH
5757: CALL_OW 255
5761: PPUSH
5762: LD_VAR 0 13
5766: PPUSH
5767: CALL_OW 325
5771: NOT
5772: AND
5773: IFFALSE 5802
// missile := Insert ( missile , missile + 1 , 3 ) ;
5775: LD_ADDR_VAR 0 14
5779: PUSH
5780: LD_VAR 0 14
5784: PPUSH
5785: LD_VAR 0 14
5789: PUSH
5790: LD_INT 1
5792: PLUS
5793: PPUSH
5794: LD_INT 3
5796: PPUSH
5797: CALL_OW 2
5801: ST_TO_ADDR
// if missile < 2 then
5802: LD_VAR 0 14
5806: PUSH
5807: LD_INT 2
5809: LESS
5810: IFFALSE 5814
// exit ;
5812: GO 6036
// x := GetX ( enemy ) ;
5814: LD_ADDR_VAR 0 4
5818: PUSH
5819: LD_VAR 0 10
5823: PPUSH
5824: CALL_OW 250
5828: ST_TO_ADDR
// y := GetY ( enemy ) ;
5829: LD_ADDR_VAR 0 5
5833: PUSH
5834: LD_VAR 0 10
5838: PPUSH
5839: CALL_OW 251
5843: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
5844: LD_ADDR_VAR 0 6
5848: PUSH
5849: LD_VAR 0 4
5853: PUSH
5854: LD_INT 1
5856: NEG
5857: PPUSH
5858: LD_INT 1
5860: PPUSH
5861: CALL_OW 12
5865: PLUS
5866: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
5867: LD_ADDR_VAR 0 7
5871: PUSH
5872: LD_VAR 0 5
5876: PUSH
5877: LD_INT 1
5879: NEG
5880: PPUSH
5881: LD_INT 1
5883: PPUSH
5884: CALL_OW 12
5888: PLUS
5889: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
5890: LD_VAR 0 6
5894: PPUSH
5895: LD_VAR 0 7
5899: PPUSH
5900: CALL_OW 488
5904: NOT
5905: IFFALSE 5927
// begin _x := x ;
5907: LD_ADDR_VAR 0 6
5911: PUSH
5912: LD_VAR 0 4
5916: ST_TO_ADDR
// _y := y ;
5917: LD_ADDR_VAR 0 7
5921: PUSH
5922: LD_VAR 0 5
5926: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
5927: LD_ADDR_VAR 0 3
5931: PUSH
5932: LD_INT 1
5934: PPUSH
5935: LD_VAR 0 14
5939: PPUSH
5940: CALL_OW 12
5944: ST_TO_ADDR
// case i of 1 :
5945: LD_VAR 0 3
5949: PUSH
5950: LD_INT 1
5952: DOUBLE
5953: EQUAL
5954: IFTRUE 5958
5956: GO 5975
5958: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
5959: LD_VAR 0 1
5963: PPUSH
5964: LD_VAR 0 10
5968: PPUSH
5969: CALL_OW 115
5973: GO 6036
5975: LD_INT 2
5977: DOUBLE
5978: EQUAL
5979: IFTRUE 5983
5981: GO 6005
5983: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
5984: LD_VAR 0 1
5988: PPUSH
5989: LD_VAR 0 6
5993: PPUSH
5994: LD_VAR 0 7
5998: PPUSH
5999: CALL_OW 153
6003: GO 6036
6005: LD_INT 3
6007: DOUBLE
6008: EQUAL
6009: IFTRUE 6013
6011: GO 6035
6013: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
6014: LD_VAR 0 1
6018: PPUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: LD_VAR 0 7
6028: PPUSH
6029: CALL_OW 154
6033: GO 6036
6035: POP
// end ;
6036: LD_VAR 0 2
6040: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
6041: LD_INT 0
6043: PPUSH
6044: PPUSH
6045: PPUSH
6046: PPUSH
6047: PPUSH
6048: PPUSH
// if not unit or not building then
6049: LD_VAR 0 1
6053: NOT
6054: PUSH
6055: LD_VAR 0 2
6059: NOT
6060: OR
6061: IFFALSE 6065
// exit ;
6063: GO 6223
// x := GetX ( building ) ;
6065: LD_ADDR_VAR 0 5
6069: PUSH
6070: LD_VAR 0 2
6074: PPUSH
6075: CALL_OW 250
6079: ST_TO_ADDR
// y := GetY ( building ) ;
6080: LD_ADDR_VAR 0 6
6084: PUSH
6085: LD_VAR 0 2
6089: PPUSH
6090: CALL_OW 251
6094: ST_TO_ADDR
// for i = 0 to 5 do
6095: LD_ADDR_VAR 0 4
6099: PUSH
6100: DOUBLE
6101: LD_INT 0
6103: DEC
6104: ST_TO_ADDR
6105: LD_INT 5
6107: PUSH
6108: FOR_TO
6109: IFFALSE 6221
// begin _x := ShiftX ( x , i , 3 ) ;
6111: LD_ADDR_VAR 0 7
6115: PUSH
6116: LD_VAR 0 5
6120: PPUSH
6121: LD_VAR 0 4
6125: PPUSH
6126: LD_INT 3
6128: PPUSH
6129: CALL_OW 272
6133: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
6134: LD_ADDR_VAR 0 8
6138: PUSH
6139: LD_VAR 0 6
6143: PPUSH
6144: LD_VAR 0 4
6148: PPUSH
6149: LD_INT 3
6151: PPUSH
6152: CALL_OW 273
6156: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
6157: LD_VAR 0 7
6161: PPUSH
6162: LD_VAR 0 8
6166: PPUSH
6167: CALL_OW 488
6171: NOT
6172: IFFALSE 6176
// continue ;
6174: GO 6108
// if HexInfo ( _x , _y ) = 0 then
6176: LD_VAR 0 7
6180: PPUSH
6181: LD_VAR 0 8
6185: PPUSH
6186: CALL_OW 428
6190: PUSH
6191: LD_INT 0
6193: EQUAL
6194: IFFALSE 6219
// begin ComMoveXY ( unit , _x , _y ) ;
6196: LD_VAR 0 1
6200: PPUSH
6201: LD_VAR 0 7
6205: PPUSH
6206: LD_VAR 0 8
6210: PPUSH
6211: CALL_OW 111
// exit ;
6215: POP
6216: POP
6217: GO 6223
// end ; end ;
6219: GO 6108
6221: POP
6222: POP
// end ;
6223: LD_VAR 0 3
6227: RET
// export function ScanBase ( side , base_area ) ; begin
6228: LD_INT 0
6230: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
6231: LD_ADDR_VAR 0 3
6235: PUSH
6236: LD_VAR 0 2
6240: PPUSH
6241: LD_INT 81
6243: PUSH
6244: LD_VAR 0 1
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: PPUSH
6253: CALL_OW 70
6257: ST_TO_ADDR
// end ;
6258: LD_VAR 0 3
6262: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
6263: LD_INT 0
6265: PPUSH
6266: PPUSH
6267: PPUSH
6268: PPUSH
// result := false ;
6269: LD_ADDR_VAR 0 2
6273: PUSH
6274: LD_INT 0
6276: ST_TO_ADDR
// side := GetSide ( unit ) ;
6277: LD_ADDR_VAR 0 3
6281: PUSH
6282: LD_VAR 0 1
6286: PPUSH
6287: CALL_OW 255
6291: ST_TO_ADDR
// nat := GetNation ( unit ) ;
6292: LD_ADDR_VAR 0 4
6296: PUSH
6297: LD_VAR 0 1
6301: PPUSH
6302: CALL_OW 248
6306: ST_TO_ADDR
// case nat of 1 :
6307: LD_VAR 0 4
6311: PUSH
6312: LD_INT 1
6314: DOUBLE
6315: EQUAL
6316: IFTRUE 6320
6318: GO 6331
6320: POP
// tech := tech_lassight ; 2 :
6321: LD_ADDR_VAR 0 5
6325: PUSH
6326: LD_INT 12
6328: ST_TO_ADDR
6329: GO 6370
6331: LD_INT 2
6333: DOUBLE
6334: EQUAL
6335: IFTRUE 6339
6337: GO 6350
6339: POP
// tech := tech_mortar ; 3 :
6340: LD_ADDR_VAR 0 5
6344: PUSH
6345: LD_INT 41
6347: ST_TO_ADDR
6348: GO 6370
6350: LD_INT 3
6352: DOUBLE
6353: EQUAL
6354: IFTRUE 6358
6356: GO 6369
6358: POP
// tech := tech_bazooka ; end ;
6359: LD_ADDR_VAR 0 5
6363: PUSH
6364: LD_INT 44
6366: ST_TO_ADDR
6367: GO 6370
6369: POP
// if Researched ( side , tech ) then
6370: LD_VAR 0 3
6374: PPUSH
6375: LD_VAR 0 5
6379: PPUSH
6380: CALL_OW 325
6384: IFFALSE 6411
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
6386: LD_ADDR_VAR 0 2
6390: PUSH
6391: LD_INT 5
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 9
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: LD_VAR 0 4
6409: ARRAY
6410: ST_TO_ADDR
// end ;
6411: LD_VAR 0 2
6415: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
6416: LD_INT 0
6418: PPUSH
6419: PPUSH
6420: PPUSH
// if not mines then
6421: LD_VAR 0 2
6425: NOT
6426: IFFALSE 6430
// exit ;
6428: GO 6574
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
6430: LD_ADDR_VAR 0 5
6434: PUSH
6435: LD_INT 81
6437: PUSH
6438: LD_VAR 0 1
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 3
6449: PUSH
6450: LD_INT 21
6452: PUSH
6453: LD_INT 3
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PPUSH
6468: CALL_OW 69
6472: ST_TO_ADDR
// for i in mines do
6473: LD_ADDR_VAR 0 4
6477: PUSH
6478: LD_VAR 0 2
6482: PUSH
6483: FOR_IN
6484: IFFALSE 6572
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
6486: LD_VAR 0 4
6490: PUSH
6491: LD_INT 1
6493: ARRAY
6494: PPUSH
6495: LD_VAR 0 4
6499: PUSH
6500: LD_INT 2
6502: ARRAY
6503: PPUSH
6504: CALL_OW 458
6508: NOT
6509: IFFALSE 6513
// continue ;
6511: GO 6483
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
6513: LD_VAR 0 4
6517: PUSH
6518: LD_INT 1
6520: ARRAY
6521: PPUSH
6522: LD_VAR 0 4
6526: PUSH
6527: LD_INT 2
6529: ARRAY
6530: PPUSH
6531: CALL_OW 428
6535: PUSH
6536: LD_VAR 0 5
6540: IN
6541: IFFALSE 6570
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
6543: LD_VAR 0 4
6547: PUSH
6548: LD_INT 1
6550: ARRAY
6551: PPUSH
6552: LD_VAR 0 4
6556: PUSH
6557: LD_INT 2
6559: ARRAY
6560: PPUSH
6561: LD_VAR 0 1
6565: PPUSH
6566: CALL_OW 456
// end ;
6570: GO 6483
6572: POP
6573: POP
// end ;
6574: LD_VAR 0 3
6578: RET
// export function Count ( array ) ; var i ; begin
6579: LD_INT 0
6581: PPUSH
6582: PPUSH
// result := 0 ;
6583: LD_ADDR_VAR 0 2
6587: PUSH
6588: LD_INT 0
6590: ST_TO_ADDR
// for i in array do
6591: LD_ADDR_VAR 0 3
6595: PUSH
6596: LD_VAR 0 1
6600: PUSH
6601: FOR_IN
6602: IFFALSE 6626
// if i then
6604: LD_VAR 0 3
6608: IFFALSE 6624
// result := result + 1 ;
6610: LD_ADDR_VAR 0 2
6614: PUSH
6615: LD_VAR 0 2
6619: PUSH
6620: LD_INT 1
6622: PLUS
6623: ST_TO_ADDR
6624: GO 6601
6626: POP
6627: POP
// end ;
6628: LD_VAR 0 2
6632: RET
// export function IsEmpty ( building ) ; begin
6633: LD_INT 0
6635: PPUSH
// if not building then
6636: LD_VAR 0 1
6640: NOT
6641: IFFALSE 6645
// exit ;
6643: GO 6688
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
6645: LD_ADDR_VAR 0 2
6649: PUSH
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 22
6657: PUSH
6658: LD_VAR 0 1
6662: PPUSH
6663: CALL_OW 255
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: EMPTY
6676: LIST
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PPUSH
6682: CALL_OW 69
6686: IN
6687: ST_TO_ADDR
// end ;
6688: LD_VAR 0 2
6692: RET
// export function IsNotFull ( building ) ; begin
6693: LD_INT 0
6695: PPUSH
// if not building then
6696: LD_VAR 0 1
6700: NOT
6701: IFFALSE 6705
// exit ;
6703: GO 6724
// result := UnitsInside ( building ) < 6 ;
6705: LD_ADDR_VAR 0 2
6709: PUSH
6710: LD_VAR 0 1
6714: PPUSH
6715: CALL_OW 313
6719: PUSH
6720: LD_INT 6
6722: LESS
6723: ST_TO_ADDR
// end ;
6724: LD_VAR 0 2
6728: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
6729: LD_INT 0
6731: PPUSH
6732: PPUSH
6733: PPUSH
6734: PPUSH
// tmp := [ ] ;
6735: LD_ADDR_VAR 0 3
6739: PUSH
6740: EMPTY
6741: ST_TO_ADDR
// list := [ ] ;
6742: LD_ADDR_VAR 0 5
6746: PUSH
6747: EMPTY
6748: ST_TO_ADDR
// for i = 16 to 25 do
6749: LD_ADDR_VAR 0 4
6753: PUSH
6754: DOUBLE
6755: LD_INT 16
6757: DEC
6758: ST_TO_ADDR
6759: LD_INT 25
6761: PUSH
6762: FOR_TO
6763: IFFALSE 6836
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
6765: LD_ADDR_VAR 0 3
6769: PUSH
6770: LD_VAR 0 3
6774: PUSH
6775: LD_INT 22
6777: PUSH
6778: LD_VAR 0 1
6782: PPUSH
6783: CALL_OW 255
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 91
6794: PUSH
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 6
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 30
6810: PUSH
6811: LD_VAR 0 4
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: EMPTY
6821: LIST
6822: LIST
6823: LIST
6824: PUSH
6825: EMPTY
6826: LIST
6827: PPUSH
6828: CALL_OW 69
6832: ADD
6833: ST_TO_ADDR
6834: GO 6762
6836: POP
6837: POP
// for i = 1 to tmp do
6838: LD_ADDR_VAR 0 4
6842: PUSH
6843: DOUBLE
6844: LD_INT 1
6846: DEC
6847: ST_TO_ADDR
6848: LD_VAR 0 3
6852: PUSH
6853: FOR_TO
6854: IFFALSE 6942
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
6856: LD_ADDR_VAR 0 5
6860: PUSH
6861: LD_VAR 0 5
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: LD_VAR 0 4
6875: ARRAY
6876: PPUSH
6877: CALL_OW 266
6881: PUSH
6882: LD_VAR 0 3
6886: PUSH
6887: LD_VAR 0 4
6891: ARRAY
6892: PPUSH
6893: CALL_OW 250
6897: PUSH
6898: LD_VAR 0 3
6902: PUSH
6903: LD_VAR 0 4
6907: ARRAY
6908: PPUSH
6909: CALL_OW 251
6913: PUSH
6914: LD_VAR 0 3
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PPUSH
6925: CALL_OW 254
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: ADD
6939: ST_TO_ADDR
6940: GO 6853
6942: POP
6943: POP
// result := list ;
6944: LD_ADDR_VAR 0 2
6948: PUSH
6949: LD_VAR 0 5
6953: ST_TO_ADDR
// end ;
6954: LD_VAR 0 2
6958: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
6959: LD_INT 0
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
6967: PPUSH
// if not factory then
6968: LD_VAR 0 1
6972: NOT
6973: IFFALSE 6977
// exit ;
6975: GO 7570
// if control = control_apeman then
6977: LD_VAR 0 4
6981: PUSH
6982: LD_INT 5
6984: EQUAL
6985: IFFALSE 7094
// begin tmp := UnitsInside ( factory ) ;
6987: LD_ADDR_VAR 0 8
6991: PUSH
6992: LD_VAR 0 1
6996: PPUSH
6997: CALL_OW 313
7001: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
7002: LD_VAR 0 8
7006: PPUSH
7007: LD_INT 25
7009: PUSH
7010: LD_INT 12
7012: PUSH
7013: EMPTY
7014: LIST
7015: LIST
7016: PPUSH
7017: CALL_OW 72
7021: NOT
7022: IFFALSE 7032
// control := control_manual ;
7024: LD_ADDR_VAR 0 4
7028: PUSH
7029: LD_INT 1
7031: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
7032: LD_ADDR_VAR 0 8
7036: PUSH
7037: LD_VAR 0 1
7041: PPUSH
7042: CALL 6729 0 1
7046: ST_TO_ADDR
// if tmp then
7047: LD_VAR 0 8
7051: IFFALSE 7094
// begin for i in tmp do
7053: LD_ADDR_VAR 0 7
7057: PUSH
7058: LD_VAR 0 8
7062: PUSH
7063: FOR_IN
7064: IFFALSE 7092
// if i [ 1 ] = b_ext_radio then
7066: LD_VAR 0 7
7070: PUSH
7071: LD_INT 1
7073: ARRAY
7074: PUSH
7075: LD_INT 22
7077: EQUAL
7078: IFFALSE 7090
// begin control := control_remote ;
7080: LD_ADDR_VAR 0 4
7084: PUSH
7085: LD_INT 2
7087: ST_TO_ADDR
// break ;
7088: GO 7092
// end ;
7090: GO 7063
7092: POP
7093: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7094: LD_VAR 0 1
7098: PPUSH
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_VAR 0 3
7108: PPUSH
7109: LD_VAR 0 4
7113: PPUSH
7114: LD_VAR 0 5
7118: PPUSH
7119: CALL_OW 448
7123: IFFALSE 7158
// begin result := [ chassis , engine , control , weapon ] ;
7125: LD_ADDR_VAR 0 6
7129: PUSH
7130: LD_VAR 0 2
7134: PUSH
7135: LD_VAR 0 3
7139: PUSH
7140: LD_VAR 0 4
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: LIST
7155: ST_TO_ADDR
// exit ;
7156: GO 7570
// end ; _chassis := AvailableChassisList ( factory ) ;
7158: LD_ADDR_VAR 0 9
7162: PUSH
7163: LD_VAR 0 1
7167: PPUSH
7168: CALL_OW 475
7172: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
7173: LD_ADDR_VAR 0 11
7177: PUSH
7178: LD_VAR 0 1
7182: PPUSH
7183: CALL_OW 476
7187: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
7188: LD_ADDR_VAR 0 12
7192: PUSH
7193: LD_VAR 0 1
7197: PPUSH
7198: CALL_OW 477
7202: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
7203: LD_ADDR_VAR 0 10
7207: PUSH
7208: LD_VAR 0 1
7212: PPUSH
7213: CALL_OW 478
7217: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
7218: LD_VAR 0 9
7222: NOT
7223: PUSH
7224: LD_VAR 0 11
7228: NOT
7229: OR
7230: PUSH
7231: LD_VAR 0 12
7235: NOT
7236: OR
7237: PUSH
7238: LD_VAR 0 10
7242: NOT
7243: OR
7244: IFFALSE 7279
// begin result := [ chassis , engine , control , weapon ] ;
7246: LD_ADDR_VAR 0 6
7250: PUSH
7251: LD_VAR 0 2
7255: PUSH
7256: LD_VAR 0 3
7260: PUSH
7261: LD_VAR 0 4
7265: PUSH
7266: LD_VAR 0 5
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: ST_TO_ADDR
// exit ;
7277: GO 7570
// end ; if not chassis in _chassis then
7279: LD_VAR 0 2
7283: PUSH
7284: LD_VAR 0 9
7288: IN
7289: NOT
7290: IFFALSE 7316
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
7292: LD_ADDR_VAR 0 2
7296: PUSH
7297: LD_VAR 0 9
7301: PUSH
7302: LD_INT 1
7304: PPUSH
7305: LD_VAR 0 9
7309: PPUSH
7310: CALL_OW 12
7314: ARRAY
7315: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
7316: LD_VAR 0 2
7320: PPUSH
7321: LD_VAR 0 3
7325: PPUSH
7326: CALL 7575 0 2
7330: NOT
7331: IFFALSE 7390
// repeat engine := _engine [ 1 ] ;
7333: LD_ADDR_VAR 0 3
7337: PUSH
7338: LD_VAR 0 11
7342: PUSH
7343: LD_INT 1
7345: ARRAY
7346: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
7347: LD_ADDR_VAR 0 11
7351: PUSH
7352: LD_VAR 0 11
7356: PPUSH
7357: LD_INT 1
7359: PPUSH
7360: CALL_OW 3
7364: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
7365: LD_VAR 0 2
7369: PPUSH
7370: LD_VAR 0 3
7374: PPUSH
7375: CALL 7575 0 2
7379: PUSH
7380: LD_VAR 0 11
7384: PUSH
7385: EMPTY
7386: EQUAL
7387: OR
7388: IFFALSE 7333
// if not control in _control then
7390: LD_VAR 0 4
7394: PUSH
7395: LD_VAR 0 12
7399: IN
7400: NOT
7401: IFFALSE 7427
// control := _control [ rand ( 1 , _control ) ] ;
7403: LD_ADDR_VAR 0 4
7407: PUSH
7408: LD_VAR 0 12
7412: PUSH
7413: LD_INT 1
7415: PPUSH
7416: LD_VAR 0 12
7420: PPUSH
7421: CALL_OW 12
7425: ARRAY
7426: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
7427: LD_VAR 0 2
7431: PPUSH
7432: LD_VAR 0 5
7436: PPUSH
7437: CALL 7795 0 2
7441: NOT
7442: IFFALSE 7501
// repeat weapon := _weapon [ 1 ] ;
7444: LD_ADDR_VAR 0 5
7448: PUSH
7449: LD_VAR 0 10
7453: PUSH
7454: LD_INT 1
7456: ARRAY
7457: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
7458: LD_ADDR_VAR 0 10
7462: PUSH
7463: LD_VAR 0 10
7467: PPUSH
7468: LD_INT 1
7470: PPUSH
7471: CALL_OW 3
7475: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
7476: LD_VAR 0 2
7480: PPUSH
7481: LD_VAR 0 5
7485: PPUSH
7486: CALL 7795 0 2
7490: PUSH
7491: LD_VAR 0 10
7495: PUSH
7496: EMPTY
7497: EQUAL
7498: OR
7499: IFFALSE 7444
// result := [ ] ;
7501: LD_ADDR_VAR 0 6
7505: PUSH
7506: EMPTY
7507: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7508: LD_VAR 0 1
7512: PPUSH
7513: LD_VAR 0 2
7517: PPUSH
7518: LD_VAR 0 3
7522: PPUSH
7523: LD_VAR 0 4
7527: PPUSH
7528: LD_VAR 0 5
7532: PPUSH
7533: CALL_OW 448
7537: IFFALSE 7570
// result := [ chassis , engine , control , weapon ] ;
7539: LD_ADDR_VAR 0 6
7543: PUSH
7544: LD_VAR 0 2
7548: PUSH
7549: LD_VAR 0 3
7553: PUSH
7554: LD_VAR 0 4
7558: PUSH
7559: LD_VAR 0 5
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: LIST
7569: ST_TO_ADDR
// end ;
7570: LD_VAR 0 6
7574: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
7575: LD_INT 0
7577: PPUSH
// if not chassis or not engine then
7578: LD_VAR 0 1
7582: NOT
7583: PUSH
7584: LD_VAR 0 2
7588: NOT
7589: OR
7590: IFFALSE 7594
// exit ;
7592: GO 7790
// case engine of engine_solar :
7594: LD_VAR 0 2
7598: PUSH
7599: LD_INT 2
7601: DOUBLE
7602: EQUAL
7603: IFTRUE 7607
7605: GO 7645
7607: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
7608: LD_ADDR_VAR 0 3
7612: PUSH
7613: LD_INT 11
7615: PUSH
7616: LD_INT 12
7618: PUSH
7619: LD_INT 13
7621: PUSH
7622: LD_INT 14
7624: PUSH
7625: LD_INT 1
7627: PUSH
7628: LD_INT 2
7630: PUSH
7631: LD_INT 3
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: LIST
7642: ST_TO_ADDR
7643: GO 7774
7645: LD_INT 1
7647: DOUBLE
7648: EQUAL
7649: IFTRUE 7653
7651: GO 7715
7653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
7654: LD_ADDR_VAR 0 3
7658: PUSH
7659: LD_INT 11
7661: PUSH
7662: LD_INT 12
7664: PUSH
7665: LD_INT 13
7667: PUSH
7668: LD_INT 14
7670: PUSH
7671: LD_INT 1
7673: PUSH
7674: LD_INT 2
7676: PUSH
7677: LD_INT 3
7679: PUSH
7680: LD_INT 4
7682: PUSH
7683: LD_INT 5
7685: PUSH
7686: LD_INT 21
7688: PUSH
7689: LD_INT 23
7691: PUSH
7692: LD_INT 22
7694: PUSH
7695: LD_INT 24
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: LIST
7712: ST_TO_ADDR
7713: GO 7774
7715: LD_INT 3
7717: DOUBLE
7718: EQUAL
7719: IFTRUE 7723
7721: GO 7773
7723: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
7724: LD_ADDR_VAR 0 3
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 14
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 3
7740: PUSH
7741: LD_INT 4
7743: PUSH
7744: LD_INT 5
7746: PUSH
7747: LD_INT 21
7749: PUSH
7750: LD_INT 22
7752: PUSH
7753: LD_INT 23
7755: PUSH
7756: LD_INT 24
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: ST_TO_ADDR
7771: GO 7774
7773: POP
// result := ( chassis in result ) ;
7774: LD_ADDR_VAR 0 3
7778: PUSH
7779: LD_VAR 0 1
7783: PUSH
7784: LD_VAR 0 3
7788: IN
7789: ST_TO_ADDR
// end ;
7790: LD_VAR 0 3
7794: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
7795: LD_INT 0
7797: PPUSH
// if not chassis or not weapon then
7798: LD_VAR 0 1
7802: NOT
7803: PUSH
7804: LD_VAR 0 2
7808: NOT
7809: OR
7810: IFFALSE 7814
// exit ;
7812: GO 8840
// case weapon of us_machine_gun :
7814: LD_VAR 0 2
7818: PUSH
7819: LD_INT 2
7821: DOUBLE
7822: EQUAL
7823: IFTRUE 7827
7825: GO 7857
7827: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
7828: LD_ADDR_VAR 0 3
7832: PUSH
7833: LD_INT 1
7835: PUSH
7836: LD_INT 2
7838: PUSH
7839: LD_INT 3
7841: PUSH
7842: LD_INT 4
7844: PUSH
7845: LD_INT 5
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: LIST
7852: LIST
7853: LIST
7854: ST_TO_ADDR
7855: GO 8824
7857: LD_INT 3
7859: DOUBLE
7860: EQUAL
7861: IFTRUE 7865
7863: GO 7895
7865: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
7866: LD_ADDR_VAR 0 3
7870: PUSH
7871: LD_INT 1
7873: PUSH
7874: LD_INT 2
7876: PUSH
7877: LD_INT 3
7879: PUSH
7880: LD_INT 4
7882: PUSH
7883: LD_INT 5
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: ST_TO_ADDR
7893: GO 8824
7895: LD_INT 11
7897: DOUBLE
7898: EQUAL
7899: IFTRUE 7903
7901: GO 7933
7903: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
7904: LD_ADDR_VAR 0 3
7908: PUSH
7909: LD_INT 1
7911: PUSH
7912: LD_INT 2
7914: PUSH
7915: LD_INT 3
7917: PUSH
7918: LD_INT 4
7920: PUSH
7921: LD_INT 5
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: LIST
7928: LIST
7929: LIST
7930: ST_TO_ADDR
7931: GO 8824
7933: LD_INT 4
7935: DOUBLE
7936: EQUAL
7937: IFTRUE 7941
7939: GO 7967
7941: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
7942: LD_ADDR_VAR 0 3
7946: PUSH
7947: LD_INT 2
7949: PUSH
7950: LD_INT 3
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 5
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: LIST
7964: ST_TO_ADDR
7965: GO 8824
7967: LD_INT 5
7969: DOUBLE
7970: EQUAL
7971: IFTRUE 7975
7973: GO 8001
7975: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
7976: LD_ADDR_VAR 0 3
7980: PUSH
7981: LD_INT 2
7983: PUSH
7984: LD_INT 3
7986: PUSH
7987: LD_INT 4
7989: PUSH
7990: LD_INT 5
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
7999: GO 8824
8001: LD_INT 9
8003: DOUBLE
8004: EQUAL
8005: IFTRUE 8009
8007: GO 8035
8009: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
8010: LD_ADDR_VAR 0 3
8014: PUSH
8015: LD_INT 2
8017: PUSH
8018: LD_INT 3
8020: PUSH
8021: LD_INT 4
8023: PUSH
8024: LD_INT 5
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: LIST
8032: ST_TO_ADDR
8033: GO 8824
8035: LD_INT 7
8037: DOUBLE
8038: EQUAL
8039: IFTRUE 8043
8041: GO 8069
8043: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
8044: LD_ADDR_VAR 0 3
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 3
8054: PUSH
8055: LD_INT 4
8057: PUSH
8058: LD_INT 5
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: ST_TO_ADDR
8067: GO 8824
8069: LD_INT 12
8071: DOUBLE
8072: EQUAL
8073: IFTRUE 8077
8075: GO 8103
8077: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
8078: LD_ADDR_VAR 0 3
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 3
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 5
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: ST_TO_ADDR
8101: GO 8824
8103: LD_INT 13
8105: DOUBLE
8106: EQUAL
8107: IFTRUE 8111
8109: GO 8137
8111: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
8112: LD_ADDR_VAR 0 3
8116: PUSH
8117: LD_INT 2
8119: PUSH
8120: LD_INT 3
8122: PUSH
8123: LD_INT 4
8125: PUSH
8126: LD_INT 5
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: LIST
8133: LIST
8134: ST_TO_ADDR
8135: GO 8824
8137: LD_INT 14
8139: DOUBLE
8140: EQUAL
8141: IFTRUE 8145
8143: GO 8163
8145: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
8146: LD_ADDR_VAR 0 3
8150: PUSH
8151: LD_INT 4
8153: PUSH
8154: LD_INT 5
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: ST_TO_ADDR
8161: GO 8824
8163: LD_INT 6
8165: DOUBLE
8166: EQUAL
8167: IFTRUE 8171
8169: GO 8189
8171: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
8172: LD_ADDR_VAR 0 3
8176: PUSH
8177: LD_INT 4
8179: PUSH
8180: LD_INT 5
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: ST_TO_ADDR
8187: GO 8824
8189: LD_INT 10
8191: DOUBLE
8192: EQUAL
8193: IFTRUE 8197
8195: GO 8215
8197: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
8198: LD_ADDR_VAR 0 3
8202: PUSH
8203: LD_INT 4
8205: PUSH
8206: LD_INT 5
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: ST_TO_ADDR
8213: GO 8824
8215: LD_INT 22
8217: DOUBLE
8218: EQUAL
8219: IFTRUE 8223
8221: GO 8249
8223: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
8224: LD_ADDR_VAR 0 3
8228: PUSH
8229: LD_INT 11
8231: PUSH
8232: LD_INT 12
8234: PUSH
8235: LD_INT 13
8237: PUSH
8238: LD_INT 14
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: ST_TO_ADDR
8247: GO 8824
8249: LD_INT 23
8251: DOUBLE
8252: EQUAL
8253: IFTRUE 8257
8255: GO 8283
8257: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
8258: LD_ADDR_VAR 0 3
8262: PUSH
8263: LD_INT 11
8265: PUSH
8266: LD_INT 12
8268: PUSH
8269: LD_INT 13
8271: PUSH
8272: LD_INT 14
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
8281: GO 8824
8283: LD_INT 24
8285: DOUBLE
8286: EQUAL
8287: IFTRUE 8291
8289: GO 8317
8291: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
8292: LD_ADDR_VAR 0 3
8296: PUSH
8297: LD_INT 11
8299: PUSH
8300: LD_INT 12
8302: PUSH
8303: LD_INT 13
8305: PUSH
8306: LD_INT 14
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: ST_TO_ADDR
8315: GO 8824
8317: LD_INT 30
8319: DOUBLE
8320: EQUAL
8321: IFTRUE 8325
8323: GO 8351
8325: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
8326: LD_ADDR_VAR 0 3
8330: PUSH
8331: LD_INT 11
8333: PUSH
8334: LD_INT 12
8336: PUSH
8337: LD_INT 13
8339: PUSH
8340: LD_INT 14
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: ST_TO_ADDR
8349: GO 8824
8351: LD_INT 25
8353: DOUBLE
8354: EQUAL
8355: IFTRUE 8359
8357: GO 8377
8359: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_INT 13
8367: PUSH
8368: LD_INT 14
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: ST_TO_ADDR
8375: GO 8824
8377: LD_INT 27
8379: DOUBLE
8380: EQUAL
8381: IFTRUE 8385
8383: GO 8403
8385: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 13
8393: PUSH
8394: LD_INT 14
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: ST_TO_ADDR
8401: GO 8824
8403: LD_INT 28
8405: DOUBLE
8406: EQUAL
8407: IFTRUE 8411
8409: GO 8429
8411: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
8412: LD_ADDR_VAR 0 3
8416: PUSH
8417: LD_INT 13
8419: PUSH
8420: LD_INT 14
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: ST_TO_ADDR
8427: GO 8824
8429: LD_INT 29
8431: DOUBLE
8432: EQUAL
8433: IFTRUE 8437
8435: GO 8455
8437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
8438: LD_ADDR_VAR 0 3
8442: PUSH
8443: LD_INT 13
8445: PUSH
8446: LD_INT 14
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: ST_TO_ADDR
8453: GO 8824
8455: LD_INT 31
8457: DOUBLE
8458: EQUAL
8459: IFTRUE 8463
8461: GO 8481
8463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
8464: LD_ADDR_VAR 0 3
8468: PUSH
8469: LD_INT 13
8471: PUSH
8472: LD_INT 14
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: ST_TO_ADDR
8479: GO 8824
8481: LD_INT 26
8483: DOUBLE
8484: EQUAL
8485: IFTRUE 8489
8487: GO 8507
8489: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
8490: LD_ADDR_VAR 0 3
8494: PUSH
8495: LD_INT 13
8497: PUSH
8498: LD_INT 14
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: ST_TO_ADDR
8505: GO 8824
8507: LD_INT 42
8509: DOUBLE
8510: EQUAL
8511: IFTRUE 8515
8513: GO 8541
8515: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
8516: LD_ADDR_VAR 0 3
8520: PUSH
8521: LD_INT 21
8523: PUSH
8524: LD_INT 22
8526: PUSH
8527: LD_INT 23
8529: PUSH
8530: LD_INT 24
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: LIST
8538: ST_TO_ADDR
8539: GO 8824
8541: LD_INT 43
8543: DOUBLE
8544: EQUAL
8545: IFTRUE 8549
8547: GO 8575
8549: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
8550: LD_ADDR_VAR 0 3
8554: PUSH
8555: LD_INT 21
8557: PUSH
8558: LD_INT 22
8560: PUSH
8561: LD_INT 23
8563: PUSH
8564: LD_INT 24
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: LIST
8571: LIST
8572: ST_TO_ADDR
8573: GO 8824
8575: LD_INT 44
8577: DOUBLE
8578: EQUAL
8579: IFTRUE 8583
8581: GO 8609
8583: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
8584: LD_ADDR_VAR 0 3
8588: PUSH
8589: LD_INT 21
8591: PUSH
8592: LD_INT 22
8594: PUSH
8595: LD_INT 23
8597: PUSH
8598: LD_INT 24
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: ST_TO_ADDR
8607: GO 8824
8609: LD_INT 45
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 8643
8617: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
8618: LD_ADDR_VAR 0 3
8622: PUSH
8623: LD_INT 21
8625: PUSH
8626: LD_INT 22
8628: PUSH
8629: LD_INT 23
8631: PUSH
8632: LD_INT 24
8634: PUSH
8635: EMPTY
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: ST_TO_ADDR
8641: GO 8824
8643: LD_INT 49
8645: DOUBLE
8646: EQUAL
8647: IFTRUE 8651
8649: GO 8677
8651: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
8652: LD_ADDR_VAR 0 3
8656: PUSH
8657: LD_INT 21
8659: PUSH
8660: LD_INT 22
8662: PUSH
8663: LD_INT 23
8665: PUSH
8666: LD_INT 24
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: LIST
8673: LIST
8674: ST_TO_ADDR
8675: GO 8824
8677: LD_INT 51
8679: DOUBLE
8680: EQUAL
8681: IFTRUE 8685
8683: GO 8711
8685: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
8686: LD_ADDR_VAR 0 3
8690: PUSH
8691: LD_INT 21
8693: PUSH
8694: LD_INT 22
8696: PUSH
8697: LD_INT 23
8699: PUSH
8700: LD_INT 24
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: LIST
8708: ST_TO_ADDR
8709: GO 8824
8711: LD_INT 52
8713: DOUBLE
8714: EQUAL
8715: IFTRUE 8719
8717: GO 8745
8719: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
8720: LD_ADDR_VAR 0 3
8724: PUSH
8725: LD_INT 21
8727: PUSH
8728: LD_INT 22
8730: PUSH
8731: LD_INT 23
8733: PUSH
8734: LD_INT 24
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: ST_TO_ADDR
8743: GO 8824
8745: LD_INT 53
8747: DOUBLE
8748: EQUAL
8749: IFTRUE 8753
8751: GO 8771
8753: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
8754: LD_ADDR_VAR 0 3
8758: PUSH
8759: LD_INT 23
8761: PUSH
8762: LD_INT 24
8764: PUSH
8765: EMPTY
8766: LIST
8767: LIST
8768: ST_TO_ADDR
8769: GO 8824
8771: LD_INT 46
8773: DOUBLE
8774: EQUAL
8775: IFTRUE 8779
8777: GO 8797
8779: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
8780: LD_ADDR_VAR 0 3
8784: PUSH
8785: LD_INT 23
8787: PUSH
8788: LD_INT 24
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: ST_TO_ADDR
8795: GO 8824
8797: LD_INT 47
8799: DOUBLE
8800: EQUAL
8801: IFTRUE 8805
8803: GO 8823
8805: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
8806: LD_ADDR_VAR 0 3
8810: PUSH
8811: LD_INT 23
8813: PUSH
8814: LD_INT 24
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: ST_TO_ADDR
8821: GO 8824
8823: POP
// result := ( chassis in result ) ;
8824: LD_ADDR_VAR 0 3
8828: PUSH
8829: LD_VAR 0 1
8833: PUSH
8834: LD_VAR 0 3
8838: IN
8839: ST_TO_ADDR
// end ;
8840: LD_VAR 0 3
8844: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
8845: LD_INT 0
8847: PPUSH
8848: PPUSH
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
// result := array ;
8854: LD_ADDR_VAR 0 5
8858: PUSH
8859: LD_VAR 0 1
8863: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
8864: LD_VAR 0 1
8868: NOT
8869: PUSH
8870: LD_VAR 0 2
8874: NOT
8875: OR
8876: PUSH
8877: LD_VAR 0 3
8881: NOT
8882: OR
8883: PUSH
8884: LD_VAR 0 2
8888: PUSH
8889: LD_VAR 0 1
8893: GREATER
8894: OR
8895: PUSH
8896: LD_VAR 0 3
8900: PUSH
8901: LD_VAR 0 1
8905: GREATER
8906: OR
8907: IFFALSE 8911
// exit ;
8909: GO 9207
// if direction then
8911: LD_VAR 0 4
8915: IFFALSE 8979
// begin d := 1 ;
8917: LD_ADDR_VAR 0 9
8921: PUSH
8922: LD_INT 1
8924: ST_TO_ADDR
// if i_from > i_to then
8925: LD_VAR 0 2
8929: PUSH
8930: LD_VAR 0 3
8934: GREATER
8935: IFFALSE 8961
// length := ( array - i_from ) + i_to else
8937: LD_ADDR_VAR 0 11
8941: PUSH
8942: LD_VAR 0 1
8946: PUSH
8947: LD_VAR 0 2
8951: MINUS
8952: PUSH
8953: LD_VAR 0 3
8957: PLUS
8958: ST_TO_ADDR
8959: GO 8977
// length := i_to - i_from ;
8961: LD_ADDR_VAR 0 11
8965: PUSH
8966: LD_VAR 0 3
8970: PUSH
8971: LD_VAR 0 2
8975: MINUS
8976: ST_TO_ADDR
// end else
8977: GO 9040
// begin d := - 1 ;
8979: LD_ADDR_VAR 0 9
8983: PUSH
8984: LD_INT 1
8986: NEG
8987: ST_TO_ADDR
// if i_from > i_to then
8988: LD_VAR 0 2
8992: PUSH
8993: LD_VAR 0 3
8997: GREATER
8998: IFFALSE 9018
// length := i_from - i_to else
9000: LD_ADDR_VAR 0 11
9004: PUSH
9005: LD_VAR 0 2
9009: PUSH
9010: LD_VAR 0 3
9014: MINUS
9015: ST_TO_ADDR
9016: GO 9040
// length := ( array - i_to ) + i_from ;
9018: LD_ADDR_VAR 0 11
9022: PUSH
9023: LD_VAR 0 1
9027: PUSH
9028: LD_VAR 0 3
9032: MINUS
9033: PUSH
9034: LD_VAR 0 2
9038: PLUS
9039: ST_TO_ADDR
// end ; if not length then
9040: LD_VAR 0 11
9044: NOT
9045: IFFALSE 9049
// exit ;
9047: GO 9207
// tmp := array ;
9049: LD_ADDR_VAR 0 10
9053: PUSH
9054: LD_VAR 0 1
9058: ST_TO_ADDR
// for i = 1 to length do
9059: LD_ADDR_VAR 0 6
9063: PUSH
9064: DOUBLE
9065: LD_INT 1
9067: DEC
9068: ST_TO_ADDR
9069: LD_VAR 0 11
9073: PUSH
9074: FOR_TO
9075: IFFALSE 9195
// begin for j = 1 to array do
9077: LD_ADDR_VAR 0 7
9081: PUSH
9082: DOUBLE
9083: LD_INT 1
9085: DEC
9086: ST_TO_ADDR
9087: LD_VAR 0 1
9091: PUSH
9092: FOR_TO
9093: IFFALSE 9181
// begin k := j + d ;
9095: LD_ADDR_VAR 0 8
9099: PUSH
9100: LD_VAR 0 7
9104: PUSH
9105: LD_VAR 0 9
9109: PLUS
9110: ST_TO_ADDR
// if k > array then
9111: LD_VAR 0 8
9115: PUSH
9116: LD_VAR 0 1
9120: GREATER
9121: IFFALSE 9131
// k := 1 ;
9123: LD_ADDR_VAR 0 8
9127: PUSH
9128: LD_INT 1
9130: ST_TO_ADDR
// if not k then
9131: LD_VAR 0 8
9135: NOT
9136: IFFALSE 9148
// k := array ;
9138: LD_ADDR_VAR 0 8
9142: PUSH
9143: LD_VAR 0 1
9147: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
9148: LD_ADDR_VAR 0 10
9152: PUSH
9153: LD_VAR 0 10
9157: PPUSH
9158: LD_VAR 0 8
9162: PPUSH
9163: LD_VAR 0 1
9167: PUSH
9168: LD_VAR 0 7
9172: ARRAY
9173: PPUSH
9174: CALL_OW 1
9178: ST_TO_ADDR
// end ;
9179: GO 9092
9181: POP
9182: POP
// array := tmp ;
9183: LD_ADDR_VAR 0 1
9187: PUSH
9188: LD_VAR 0 10
9192: ST_TO_ADDR
// end ;
9193: GO 9074
9195: POP
9196: POP
// result := array ;
9197: LD_ADDR_VAR 0 5
9201: PUSH
9202: LD_VAR 0 1
9206: ST_TO_ADDR
// end ;
9207: LD_VAR 0 5
9211: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
9212: LD_INT 0
9214: PPUSH
9215: PPUSH
// result := 0 ;
9216: LD_ADDR_VAR 0 3
9220: PUSH
9221: LD_INT 0
9223: ST_TO_ADDR
// if not array or not value in array then
9224: LD_VAR 0 1
9228: NOT
9229: PUSH
9230: LD_VAR 0 2
9234: PUSH
9235: LD_VAR 0 1
9239: IN
9240: NOT
9241: OR
9242: IFFALSE 9246
// exit ;
9244: GO 9300
// for i = 1 to array do
9246: LD_ADDR_VAR 0 4
9250: PUSH
9251: DOUBLE
9252: LD_INT 1
9254: DEC
9255: ST_TO_ADDR
9256: LD_VAR 0 1
9260: PUSH
9261: FOR_TO
9262: IFFALSE 9298
// if value = array [ i ] then
9264: LD_VAR 0 2
9268: PUSH
9269: LD_VAR 0 1
9273: PUSH
9274: LD_VAR 0 4
9278: ARRAY
9279: EQUAL
9280: IFFALSE 9296
// begin result := i ;
9282: LD_ADDR_VAR 0 3
9286: PUSH
9287: LD_VAR 0 4
9291: ST_TO_ADDR
// exit ;
9292: POP
9293: POP
9294: GO 9300
// end ;
9296: GO 9261
9298: POP
9299: POP
// end ;
9300: LD_VAR 0 3
9304: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
9305: LD_INT 0
9307: PPUSH
// vc_chassis := chassis ;
9308: LD_ADDR_OWVAR 37
9312: PUSH
9313: LD_VAR 0 1
9317: ST_TO_ADDR
// vc_engine := engine ;
9318: LD_ADDR_OWVAR 39
9322: PUSH
9323: LD_VAR 0 2
9327: ST_TO_ADDR
// vc_control := control ;
9328: LD_ADDR_OWVAR 38
9332: PUSH
9333: LD_VAR 0 3
9337: ST_TO_ADDR
// vc_weapon := weapon ;
9338: LD_ADDR_OWVAR 40
9342: PUSH
9343: LD_VAR 0 4
9347: ST_TO_ADDR
// vc_fuel_battery := fuel ;
9348: LD_ADDR_OWVAR 41
9352: PUSH
9353: LD_VAR 0 5
9357: ST_TO_ADDR
// end ;
9358: LD_VAR 0 6
9362: RET
// export function WantPlant ( unit ) ; var task ; begin
9363: LD_INT 0
9365: PPUSH
9366: PPUSH
// result := false ;
9367: LD_ADDR_VAR 0 2
9371: PUSH
9372: LD_INT 0
9374: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
9375: LD_ADDR_VAR 0 3
9379: PUSH
9380: LD_VAR 0 1
9384: PPUSH
9385: CALL_OW 437
9389: ST_TO_ADDR
// if task then
9390: LD_VAR 0 3
9394: IFFALSE 9422
// if task [ 1 ] [ 1 ] = p then
9396: LD_VAR 0 3
9400: PUSH
9401: LD_INT 1
9403: ARRAY
9404: PUSH
9405: LD_INT 1
9407: ARRAY
9408: PUSH
9409: LD_STRING p
9411: EQUAL
9412: IFFALSE 9422
// result := true ;
9414: LD_ADDR_VAR 0 2
9418: PUSH
9419: LD_INT 1
9421: ST_TO_ADDR
// end ;
9422: LD_VAR 0 2
9426: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
9427: LD_INT 0
9429: PPUSH
9430: PPUSH
9431: PPUSH
9432: PPUSH
// if pos < 1 then
9433: LD_VAR 0 2
9437: PUSH
9438: LD_INT 1
9440: LESS
9441: IFFALSE 9445
// exit ;
9443: GO 9748
// if pos = 1 then
9445: LD_VAR 0 2
9449: PUSH
9450: LD_INT 1
9452: EQUAL
9453: IFFALSE 9486
// result := Replace ( arr , pos [ 1 ] , value ) else
9455: LD_ADDR_VAR 0 4
9459: PUSH
9460: LD_VAR 0 1
9464: PPUSH
9465: LD_VAR 0 2
9469: PUSH
9470: LD_INT 1
9472: ARRAY
9473: PPUSH
9474: LD_VAR 0 3
9478: PPUSH
9479: CALL_OW 1
9483: ST_TO_ADDR
9484: GO 9748
// begin tmp := arr ;
9486: LD_ADDR_VAR 0 6
9490: PUSH
9491: LD_VAR 0 1
9495: ST_TO_ADDR
// s_arr := [ tmp ] ;
9496: LD_ADDR_VAR 0 7
9500: PUSH
9501: LD_VAR 0 6
9505: PUSH
9506: EMPTY
9507: LIST
9508: ST_TO_ADDR
// for i = 1 to pos - 1 do
9509: LD_ADDR_VAR 0 5
9513: PUSH
9514: DOUBLE
9515: LD_INT 1
9517: DEC
9518: ST_TO_ADDR
9519: LD_VAR 0 2
9523: PUSH
9524: LD_INT 1
9526: MINUS
9527: PUSH
9528: FOR_TO
9529: IFFALSE 9574
// begin tmp := tmp [ pos [ i ] ] ;
9531: LD_ADDR_VAR 0 6
9535: PUSH
9536: LD_VAR 0 6
9540: PUSH
9541: LD_VAR 0 2
9545: PUSH
9546: LD_VAR 0 5
9550: ARRAY
9551: ARRAY
9552: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
9553: LD_ADDR_VAR 0 7
9557: PUSH
9558: LD_VAR 0 7
9562: PUSH
9563: LD_VAR 0 6
9567: PUSH
9568: EMPTY
9569: LIST
9570: ADD
9571: ST_TO_ADDR
// end ;
9572: GO 9528
9574: POP
9575: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
9576: LD_ADDR_VAR 0 6
9580: PUSH
9581: LD_VAR 0 6
9585: PPUSH
9586: LD_VAR 0 2
9590: PUSH
9591: LD_VAR 0 2
9595: ARRAY
9596: PPUSH
9597: LD_VAR 0 3
9601: PPUSH
9602: CALL_OW 1
9606: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
9607: LD_ADDR_VAR 0 7
9611: PUSH
9612: LD_VAR 0 7
9616: PPUSH
9617: LD_VAR 0 7
9621: PPUSH
9622: LD_VAR 0 6
9626: PPUSH
9627: CALL_OW 1
9631: ST_TO_ADDR
// for i = s_arr downto 2 do
9632: LD_ADDR_VAR 0 5
9636: PUSH
9637: DOUBLE
9638: LD_VAR 0 7
9642: INC
9643: ST_TO_ADDR
9644: LD_INT 2
9646: PUSH
9647: FOR_DOWNTO
9648: IFFALSE 9732
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
9650: LD_ADDR_VAR 0 6
9654: PUSH
9655: LD_VAR 0 7
9659: PUSH
9660: LD_VAR 0 5
9664: PUSH
9665: LD_INT 1
9667: MINUS
9668: ARRAY
9669: PPUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_VAR 0 5
9679: PUSH
9680: LD_INT 1
9682: MINUS
9683: ARRAY
9684: PPUSH
9685: LD_VAR 0 7
9689: PUSH
9690: LD_VAR 0 5
9694: ARRAY
9695: PPUSH
9696: CALL_OW 1
9700: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
9701: LD_ADDR_VAR 0 7
9705: PUSH
9706: LD_VAR 0 7
9710: PPUSH
9711: LD_VAR 0 5
9715: PUSH
9716: LD_INT 1
9718: MINUS
9719: PPUSH
9720: LD_VAR 0 6
9724: PPUSH
9725: CALL_OW 1
9729: ST_TO_ADDR
// end ;
9730: GO 9647
9732: POP
9733: POP
// result := s_arr [ 1 ] ;
9734: LD_ADDR_VAR 0 4
9738: PUSH
9739: LD_VAR 0 7
9743: PUSH
9744: LD_INT 1
9746: ARRAY
9747: ST_TO_ADDR
// end ; end ;
9748: LD_VAR 0 4
9752: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
9753: LD_INT 0
9755: PPUSH
9756: PPUSH
// if not list then
9757: LD_VAR 0 1
9761: NOT
9762: IFFALSE 9766
// exit ;
9764: GO 9857
// i := list [ pos1 ] ;
9766: LD_ADDR_VAR 0 5
9770: PUSH
9771: LD_VAR 0 1
9775: PUSH
9776: LD_VAR 0 2
9780: ARRAY
9781: ST_TO_ADDR
// if not i then
9782: LD_VAR 0 5
9786: NOT
9787: IFFALSE 9791
// exit ;
9789: GO 9857
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
9791: LD_ADDR_VAR 0 1
9795: PUSH
9796: LD_VAR 0 1
9800: PPUSH
9801: LD_VAR 0 2
9805: PPUSH
9806: LD_VAR 0 1
9810: PUSH
9811: LD_VAR 0 3
9815: ARRAY
9816: PPUSH
9817: CALL_OW 1
9821: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
9822: LD_ADDR_VAR 0 1
9826: PUSH
9827: LD_VAR 0 1
9831: PPUSH
9832: LD_VAR 0 3
9836: PPUSH
9837: LD_VAR 0 5
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// result := list ;
9847: LD_ADDR_VAR 0 4
9851: PUSH
9852: LD_VAR 0 1
9856: ST_TO_ADDR
// end ;
9857: LD_VAR 0 4
9861: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
9862: LD_INT 0
9864: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
9865: LD_ADDR_VAR 0 5
9869: PUSH
9870: LD_VAR 0 1
9874: PPUSH
9875: CALL_OW 250
9879: PPUSH
9880: LD_VAR 0 1
9884: PPUSH
9885: CALL_OW 251
9889: PPUSH
9890: LD_VAR 0 2
9894: PPUSH
9895: LD_VAR 0 3
9899: PPUSH
9900: LD_VAR 0 4
9904: PPUSH
9905: CALL 9915 0 5
9909: ST_TO_ADDR
// end ;
9910: LD_VAR 0 5
9914: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
9915: LD_INT 0
9917: PPUSH
9918: PPUSH
9919: PPUSH
9920: PPUSH
// if not list then
9921: LD_VAR 0 3
9925: NOT
9926: IFFALSE 9930
// exit ;
9928: GO 10318
// result := [ ] ;
9930: LD_ADDR_VAR 0 6
9934: PUSH
9935: EMPTY
9936: ST_TO_ADDR
// for i in list do
9937: LD_ADDR_VAR 0 7
9941: PUSH
9942: LD_VAR 0 3
9946: PUSH
9947: FOR_IN
9948: IFFALSE 10150
// begin tmp := GetDistUnitXY ( i , x , y ) ;
9950: LD_ADDR_VAR 0 9
9954: PUSH
9955: LD_VAR 0 7
9959: PPUSH
9960: LD_VAR 0 1
9964: PPUSH
9965: LD_VAR 0 2
9969: PPUSH
9970: CALL_OW 297
9974: ST_TO_ADDR
// if not result then
9975: LD_VAR 0 6
9979: NOT
9980: IFFALSE 10006
// result := [ [ i , tmp ] ] else
9982: LD_ADDR_VAR 0 6
9986: PUSH
9987: LD_VAR 0 7
9991: PUSH
9992: LD_VAR 0 9
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: ST_TO_ADDR
10004: GO 10148
// begin if result [ result ] [ 2 ] < tmp then
10006: LD_VAR 0 6
10010: PUSH
10011: LD_VAR 0 6
10015: ARRAY
10016: PUSH
10017: LD_INT 2
10019: ARRAY
10020: PUSH
10021: LD_VAR 0 9
10025: LESS
10026: IFFALSE 10068
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
10028: LD_ADDR_VAR 0 6
10032: PUSH
10033: LD_VAR 0 6
10037: PPUSH
10038: LD_VAR 0 6
10042: PUSH
10043: LD_INT 1
10045: PLUS
10046: PPUSH
10047: LD_VAR 0 7
10051: PUSH
10052: LD_VAR 0 9
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 2
10065: ST_TO_ADDR
10066: GO 10148
// for j = 1 to result do
10068: LD_ADDR_VAR 0 8
10072: PUSH
10073: DOUBLE
10074: LD_INT 1
10076: DEC
10077: ST_TO_ADDR
10078: LD_VAR 0 6
10082: PUSH
10083: FOR_TO
10084: IFFALSE 10146
// begin if tmp < result [ j ] [ 2 ] then
10086: LD_VAR 0 9
10090: PUSH
10091: LD_VAR 0 6
10095: PUSH
10096: LD_VAR 0 8
10100: ARRAY
10101: PUSH
10102: LD_INT 2
10104: ARRAY
10105: LESS
10106: IFFALSE 10144
// begin result := Insert ( result , j , [ i , tmp ] ) ;
10108: LD_ADDR_VAR 0 6
10112: PUSH
10113: LD_VAR 0 6
10117: PPUSH
10118: LD_VAR 0 8
10122: PPUSH
10123: LD_VAR 0 7
10127: PUSH
10128: LD_VAR 0 9
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: PPUSH
10137: CALL_OW 2
10141: ST_TO_ADDR
// break ;
10142: GO 10146
// end ; end ;
10144: GO 10083
10146: POP
10147: POP
// end ; end ;
10148: GO 9947
10150: POP
10151: POP
// if result and not asc then
10152: LD_VAR 0 6
10156: PUSH
10157: LD_VAR 0 4
10161: NOT
10162: AND
10163: IFFALSE 10238
// begin tmp := result ;
10165: LD_ADDR_VAR 0 9
10169: PUSH
10170: LD_VAR 0 6
10174: ST_TO_ADDR
// for i = tmp downto 1 do
10175: LD_ADDR_VAR 0 7
10179: PUSH
10180: DOUBLE
10181: LD_VAR 0 9
10185: INC
10186: ST_TO_ADDR
10187: LD_INT 1
10189: PUSH
10190: FOR_DOWNTO
10191: IFFALSE 10236
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
10193: LD_ADDR_VAR 0 6
10197: PUSH
10198: LD_VAR 0 6
10202: PPUSH
10203: LD_VAR 0 9
10207: PUSH
10208: LD_VAR 0 7
10212: MINUS
10213: PUSH
10214: LD_INT 1
10216: PLUS
10217: PPUSH
10218: LD_VAR 0 9
10222: PUSH
10223: LD_VAR 0 7
10227: ARRAY
10228: PPUSH
10229: CALL_OW 1
10233: ST_TO_ADDR
10234: GO 10190
10236: POP
10237: POP
// end ; tmp := [ ] ;
10238: LD_ADDR_VAR 0 9
10242: PUSH
10243: EMPTY
10244: ST_TO_ADDR
// if mode then
10245: LD_VAR 0 5
10249: IFFALSE 10318
// begin for i = 1 to result do
10251: LD_ADDR_VAR 0 7
10255: PUSH
10256: DOUBLE
10257: LD_INT 1
10259: DEC
10260: ST_TO_ADDR
10261: LD_VAR 0 6
10265: PUSH
10266: FOR_TO
10267: IFFALSE 10306
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
10269: LD_ADDR_VAR 0 9
10273: PUSH
10274: LD_VAR 0 9
10278: PPUSH
10279: LD_VAR 0 7
10283: PPUSH
10284: LD_VAR 0 6
10288: PUSH
10289: LD_VAR 0 7
10293: ARRAY
10294: PUSH
10295: LD_INT 1
10297: ARRAY
10298: PPUSH
10299: CALL_OW 1
10303: ST_TO_ADDR
10304: GO 10266
10306: POP
10307: POP
// result := tmp ;
10308: LD_ADDR_VAR 0 6
10312: PUSH
10313: LD_VAR 0 9
10317: ST_TO_ADDR
// end ; end ;
10318: LD_VAR 0 6
10322: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
10323: LD_INT 0
10325: PPUSH
10326: PPUSH
10327: PPUSH
10328: PPUSH
10329: PPUSH
10330: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
10331: LD_ADDR_VAR 0 5
10335: PUSH
10336: LD_INT 0
10338: PUSH
10339: LD_INT 0
10341: PUSH
10342: LD_INT 0
10344: PUSH
10345: EMPTY
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: ST_TO_ADDR
// if not x or not y then
10353: LD_VAR 0 2
10357: NOT
10358: PUSH
10359: LD_VAR 0 3
10363: NOT
10364: OR
10365: IFFALSE 10369
// exit ;
10367: GO 12015
// if not range then
10369: LD_VAR 0 4
10373: NOT
10374: IFFALSE 10384
// range := 10 ;
10376: LD_ADDR_VAR 0 4
10380: PUSH
10381: LD_INT 10
10383: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10384: LD_ADDR_VAR 0 8
10388: PUSH
10389: LD_INT 81
10391: PUSH
10392: LD_VAR 0 1
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 92
10403: PUSH
10404: LD_VAR 0 2
10408: PUSH
10409: LD_VAR 0 3
10413: PUSH
10414: LD_VAR 0 4
10418: PUSH
10419: EMPTY
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 21
10430: PUSH
10431: LD_INT 3
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: LIST
10446: PPUSH
10447: CALL_OW 69
10451: ST_TO_ADDR
// if not tmp then
10452: LD_VAR 0 8
10456: NOT
10457: IFFALSE 10461
// exit ;
10459: GO 12015
// for i in tmp do
10461: LD_ADDR_VAR 0 6
10465: PUSH
10466: LD_VAR 0 8
10470: PUSH
10471: FOR_IN
10472: IFFALSE 11990
// begin points := [ 0 , 0 , 0 ] ;
10474: LD_ADDR_VAR 0 9
10478: PUSH
10479: LD_INT 0
10481: PUSH
10482: LD_INT 0
10484: PUSH
10485: LD_INT 0
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: LIST
10492: ST_TO_ADDR
// bpoints := 1 ;
10493: LD_ADDR_VAR 0 10
10497: PUSH
10498: LD_INT 1
10500: ST_TO_ADDR
// case GetType ( i ) of unit_human :
10501: LD_VAR 0 6
10505: PPUSH
10506: CALL_OW 247
10510: PUSH
10511: LD_INT 1
10513: DOUBLE
10514: EQUAL
10515: IFTRUE 10519
10517: GO 11097
10519: POP
// begin if GetClass ( i ) = 1 then
10520: LD_VAR 0 6
10524: PPUSH
10525: CALL_OW 257
10529: PUSH
10530: LD_INT 1
10532: EQUAL
10533: IFFALSE 10554
// points := [ 10 , 5 , 3 ] ;
10535: LD_ADDR_VAR 0 9
10539: PUSH
10540: LD_INT 10
10542: PUSH
10543: LD_INT 5
10545: PUSH
10546: LD_INT 3
10548: PUSH
10549: EMPTY
10550: LIST
10551: LIST
10552: LIST
10553: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
10554: LD_VAR 0 6
10558: PPUSH
10559: CALL_OW 257
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: LD_INT 3
10569: PUSH
10570: LD_INT 4
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: LIST
10577: IN
10578: IFFALSE 10599
// points := [ 3 , 2 , 1 ] ;
10580: LD_ADDR_VAR 0 9
10584: PUSH
10585: LD_INT 3
10587: PUSH
10588: LD_INT 2
10590: PUSH
10591: LD_INT 1
10593: PUSH
10594: EMPTY
10595: LIST
10596: LIST
10597: LIST
10598: ST_TO_ADDR
// if GetClass ( i ) = 5 then
10599: LD_VAR 0 6
10603: PPUSH
10604: CALL_OW 257
10608: PUSH
10609: LD_INT 5
10611: EQUAL
10612: IFFALSE 10633
// points := [ 130 , 5 , 2 ] ;
10614: LD_ADDR_VAR 0 9
10618: PUSH
10619: LD_INT 130
10621: PUSH
10622: LD_INT 5
10624: PUSH
10625: LD_INT 2
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: LIST
10632: ST_TO_ADDR
// if GetClass ( i ) = 8 then
10633: LD_VAR 0 6
10637: PPUSH
10638: CALL_OW 257
10642: PUSH
10643: LD_INT 8
10645: EQUAL
10646: IFFALSE 10667
// points := [ 35 , 35 , 30 ] ;
10648: LD_ADDR_VAR 0 9
10652: PUSH
10653: LD_INT 35
10655: PUSH
10656: LD_INT 35
10658: PUSH
10659: LD_INT 30
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: LIST
10666: ST_TO_ADDR
// if GetClass ( i ) = 9 then
10667: LD_VAR 0 6
10671: PPUSH
10672: CALL_OW 257
10676: PUSH
10677: LD_INT 9
10679: EQUAL
10680: IFFALSE 10701
// points := [ 20 , 55 , 40 ] ;
10682: LD_ADDR_VAR 0 9
10686: PUSH
10687: LD_INT 20
10689: PUSH
10690: LD_INT 55
10692: PUSH
10693: LD_INT 40
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: LIST
10700: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
10701: LD_VAR 0 6
10705: PPUSH
10706: CALL_OW 257
10710: PUSH
10711: LD_INT 12
10713: PUSH
10714: LD_INT 16
10716: PUSH
10717: EMPTY
10718: LIST
10719: LIST
10720: IN
10721: IFFALSE 10742
// points := [ 5 , 3 , 2 ] ;
10723: LD_ADDR_VAR 0 9
10727: PUSH
10728: LD_INT 5
10730: PUSH
10731: LD_INT 3
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: LIST
10741: ST_TO_ADDR
// if GetClass ( i ) = 17 then
10742: LD_VAR 0 6
10746: PPUSH
10747: CALL_OW 257
10751: PUSH
10752: LD_INT 17
10754: EQUAL
10755: IFFALSE 10776
// points := [ 100 , 50 , 75 ] ;
10757: LD_ADDR_VAR 0 9
10761: PUSH
10762: LD_INT 100
10764: PUSH
10765: LD_INT 50
10767: PUSH
10768: LD_INT 75
10770: PUSH
10771: EMPTY
10772: LIST
10773: LIST
10774: LIST
10775: ST_TO_ADDR
// if GetClass ( i ) = 15 then
10776: LD_VAR 0 6
10780: PPUSH
10781: CALL_OW 257
10785: PUSH
10786: LD_INT 15
10788: EQUAL
10789: IFFALSE 10810
// points := [ 10 , 5 , 3 ] ;
10791: LD_ADDR_VAR 0 9
10795: PUSH
10796: LD_INT 10
10798: PUSH
10799: LD_INT 5
10801: PUSH
10802: LD_INT 3
10804: PUSH
10805: EMPTY
10806: LIST
10807: LIST
10808: LIST
10809: ST_TO_ADDR
// if GetClass ( i ) = 14 then
10810: LD_VAR 0 6
10814: PPUSH
10815: CALL_OW 257
10819: PUSH
10820: LD_INT 14
10822: EQUAL
10823: IFFALSE 10844
// points := [ 10 , 0 , 0 ] ;
10825: LD_ADDR_VAR 0 9
10829: PUSH
10830: LD_INT 10
10832: PUSH
10833: LD_INT 0
10835: PUSH
10836: LD_INT 0
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: LIST
10843: ST_TO_ADDR
// if GetClass ( i ) = 11 then
10844: LD_VAR 0 6
10848: PPUSH
10849: CALL_OW 257
10853: PUSH
10854: LD_INT 11
10856: EQUAL
10857: IFFALSE 10878
// points := [ 30 , 10 , 5 ] ;
10859: LD_ADDR_VAR 0 9
10863: PUSH
10864: LD_INT 30
10866: PUSH
10867: LD_INT 10
10869: PUSH
10870: LD_INT 5
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: LIST
10877: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_INT 5
10885: PPUSH
10886: CALL_OW 321
10890: PUSH
10891: LD_INT 2
10893: EQUAL
10894: IFFALSE 10911
// bpoints := bpoints * 1.8 ;
10896: LD_ADDR_VAR 0 10
10900: PUSH
10901: LD_VAR 0 10
10905: PUSH
10906: LD_REAL  1.80000000000000E+0000
10909: MUL
10910: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
10911: LD_VAR 0 6
10915: PPUSH
10916: CALL_OW 257
10920: PUSH
10921: LD_INT 1
10923: PUSH
10924: LD_INT 2
10926: PUSH
10927: LD_INT 3
10929: PUSH
10930: LD_INT 4
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: LIST
10937: LIST
10938: IN
10939: PUSH
10940: LD_VAR 0 1
10944: PPUSH
10945: LD_INT 51
10947: PPUSH
10948: CALL_OW 321
10952: PUSH
10953: LD_INT 2
10955: EQUAL
10956: AND
10957: IFFALSE 10974
// bpoints := bpoints * 1.2 ;
10959: LD_ADDR_VAR 0 10
10963: PUSH
10964: LD_VAR 0 10
10968: PUSH
10969: LD_REAL  1.20000000000000E+0000
10972: MUL
10973: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
10974: LD_VAR 0 6
10978: PPUSH
10979: CALL_OW 257
10983: PUSH
10984: LD_INT 5
10986: PUSH
10987: LD_INT 7
10989: PUSH
10990: LD_INT 9
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: IN
10998: PUSH
10999: LD_VAR 0 1
11003: PPUSH
11004: LD_INT 52
11006: PPUSH
11007: CALL_OW 321
11011: PUSH
11012: LD_INT 2
11014: EQUAL
11015: AND
11016: IFFALSE 11033
// bpoints := bpoints * 1.5 ;
11018: LD_ADDR_VAR 0 10
11022: PUSH
11023: LD_VAR 0 10
11027: PUSH
11028: LD_REAL  1.50000000000000E+0000
11031: MUL
11032: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
11033: LD_VAR 0 1
11037: PPUSH
11038: LD_INT 66
11040: PPUSH
11041: CALL_OW 321
11045: PUSH
11046: LD_INT 2
11048: EQUAL
11049: IFFALSE 11066
// bpoints := bpoints * 1.1 ;
11051: LD_ADDR_VAR 0 10
11055: PUSH
11056: LD_VAR 0 10
11060: PUSH
11061: LD_REAL  1.10000000000000E+0000
11064: MUL
11065: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
11066: LD_ADDR_VAR 0 10
11070: PUSH
11071: LD_VAR 0 10
11075: PUSH
11076: LD_VAR 0 6
11080: PPUSH
11081: LD_INT 1
11083: PPUSH
11084: CALL_OW 259
11088: PUSH
11089: LD_REAL  1.15000000000000E+0000
11092: MUL
11093: MUL
11094: ST_TO_ADDR
// end ; unit_vehicle :
11095: GO 11919
11097: LD_INT 2
11099: DOUBLE
11100: EQUAL
11101: IFTRUE 11105
11103: GO 11907
11105: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
11106: LD_VAR 0 6
11110: PPUSH
11111: CALL_OW 264
11115: PUSH
11116: LD_INT 2
11118: PUSH
11119: LD_INT 42
11121: PUSH
11122: LD_INT 24
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: LIST
11129: IN
11130: IFFALSE 11151
// points := [ 25 , 5 , 3 ] ;
11132: LD_ADDR_VAR 0 9
11136: PUSH
11137: LD_INT 25
11139: PUSH
11140: LD_INT 5
11142: PUSH
11143: LD_INT 3
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: LIST
11150: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
11151: LD_VAR 0 6
11155: PPUSH
11156: CALL_OW 264
11160: PUSH
11161: LD_INT 4
11163: PUSH
11164: LD_INT 43
11166: PUSH
11167: LD_INT 25
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: LIST
11174: IN
11175: IFFALSE 11196
// points := [ 40 , 15 , 5 ] ;
11177: LD_ADDR_VAR 0 9
11181: PUSH
11182: LD_INT 40
11184: PUSH
11185: LD_INT 15
11187: PUSH
11188: LD_INT 5
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: LIST
11195: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
11196: LD_VAR 0 6
11200: PPUSH
11201: CALL_OW 264
11205: PUSH
11206: LD_INT 3
11208: PUSH
11209: LD_INT 23
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: IN
11216: IFFALSE 11237
// points := [ 7 , 25 , 8 ] ;
11218: LD_ADDR_VAR 0 9
11222: PUSH
11223: LD_INT 7
11225: PUSH
11226: LD_INT 25
11228: PUSH
11229: LD_INT 8
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
11237: LD_VAR 0 6
11241: PPUSH
11242: CALL_OW 264
11246: PUSH
11247: LD_INT 5
11249: PUSH
11250: LD_INT 27
11252: PUSH
11253: LD_INT 44
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: LIST
11260: IN
11261: IFFALSE 11282
// points := [ 14 , 50 , 16 ] ;
11263: LD_ADDR_VAR 0 9
11267: PUSH
11268: LD_INT 14
11270: PUSH
11271: LD_INT 50
11273: PUSH
11274: LD_INT 16
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: LIST
11281: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
11282: LD_VAR 0 6
11286: PPUSH
11287: CALL_OW 264
11291: PUSH
11292: LD_INT 6
11294: PUSH
11295: LD_INT 46
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: IN
11302: IFFALSE 11323
// points := [ 32 , 120 , 70 ] ;
11304: LD_ADDR_VAR 0 9
11308: PUSH
11309: LD_INT 32
11311: PUSH
11312: LD_INT 120
11314: PUSH
11315: LD_INT 70
11317: PUSH
11318: EMPTY
11319: LIST
11320: LIST
11321: LIST
11322: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
11323: LD_VAR 0 6
11327: PPUSH
11328: CALL_OW 264
11332: PUSH
11333: LD_INT 7
11335: PUSH
11336: LD_INT 28
11338: PUSH
11339: LD_INT 45
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: LIST
11346: IN
11347: IFFALSE 11368
// points := [ 35 , 20 , 45 ] ;
11349: LD_ADDR_VAR 0 9
11353: PUSH
11354: LD_INT 35
11356: PUSH
11357: LD_INT 20
11359: PUSH
11360: LD_INT 45
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: LIST
11367: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
11368: LD_VAR 0 6
11372: PPUSH
11373: CALL_OW 264
11377: PUSH
11378: LD_INT 47
11380: PUSH
11381: EMPTY
11382: LIST
11383: IN
11384: IFFALSE 11405
// points := [ 67 , 45 , 75 ] ;
11386: LD_ADDR_VAR 0 9
11390: PUSH
11391: LD_INT 67
11393: PUSH
11394: LD_INT 45
11396: PUSH
11397: LD_INT 75
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: LIST
11404: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
11405: LD_VAR 0 6
11409: PPUSH
11410: CALL_OW 264
11414: PUSH
11415: LD_INT 26
11417: PUSH
11418: EMPTY
11419: LIST
11420: IN
11421: IFFALSE 11442
// points := [ 120 , 30 , 80 ] ;
11423: LD_ADDR_VAR 0 9
11427: PUSH
11428: LD_INT 120
11430: PUSH
11431: LD_INT 30
11433: PUSH
11434: LD_INT 80
11436: PUSH
11437: EMPTY
11438: LIST
11439: LIST
11440: LIST
11441: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
11442: LD_VAR 0 6
11446: PPUSH
11447: CALL_OW 264
11451: PUSH
11452: LD_INT 22
11454: PUSH
11455: EMPTY
11456: LIST
11457: IN
11458: IFFALSE 11479
// points := [ 40 , 1 , 1 ] ;
11460: LD_ADDR_VAR 0 9
11464: PUSH
11465: LD_INT 40
11467: PUSH
11468: LD_INT 1
11470: PUSH
11471: LD_INT 1
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
11479: LD_VAR 0 6
11483: PPUSH
11484: CALL_OW 264
11488: PUSH
11489: LD_INT 29
11491: PUSH
11492: EMPTY
11493: LIST
11494: IN
11495: IFFALSE 11516
// points := [ 70 , 200 , 400 ] ;
11497: LD_ADDR_VAR 0 9
11501: PUSH
11502: LD_INT 70
11504: PUSH
11505: LD_INT 200
11507: PUSH
11508: LD_INT 400
11510: PUSH
11511: EMPTY
11512: LIST
11513: LIST
11514: LIST
11515: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
11516: LD_VAR 0 6
11520: PPUSH
11521: CALL_OW 264
11525: PUSH
11526: LD_INT 14
11528: PUSH
11529: LD_INT 53
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: IN
11536: IFFALSE 11557
// points := [ 40 , 10 , 20 ] ;
11538: LD_ADDR_VAR 0 9
11542: PUSH
11543: LD_INT 40
11545: PUSH
11546: LD_INT 10
11548: PUSH
11549: LD_INT 20
11551: PUSH
11552: EMPTY
11553: LIST
11554: LIST
11555: LIST
11556: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
11557: LD_VAR 0 6
11561: PPUSH
11562: CALL_OW 264
11566: PUSH
11567: LD_INT 9
11569: PUSH
11570: EMPTY
11571: LIST
11572: IN
11573: IFFALSE 11594
// points := [ 5 , 70 , 20 ] ;
11575: LD_ADDR_VAR 0 9
11579: PUSH
11580: LD_INT 5
11582: PUSH
11583: LD_INT 70
11585: PUSH
11586: LD_INT 20
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: LIST
11593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
11594: LD_VAR 0 6
11598: PPUSH
11599: CALL_OW 264
11603: PUSH
11604: LD_INT 10
11606: PUSH
11607: EMPTY
11608: LIST
11609: IN
11610: IFFALSE 11631
// points := [ 35 , 110 , 70 ] ;
11612: LD_ADDR_VAR 0 9
11616: PUSH
11617: LD_INT 35
11619: PUSH
11620: LD_INT 110
11622: PUSH
11623: LD_INT 70
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
11631: LD_VAR 0 6
11635: PPUSH
11636: CALL_OW 265
11640: PUSH
11641: LD_INT 25
11643: EQUAL
11644: IFFALSE 11665
// points := [ 80 , 65 , 100 ] ;
11646: LD_ADDR_VAR 0 9
11650: PUSH
11651: LD_INT 80
11653: PUSH
11654: LD_INT 65
11656: PUSH
11657: LD_INT 100
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
11665: LD_VAR 0 6
11669: PPUSH
11670: CALL_OW 263
11674: PUSH
11675: LD_INT 1
11677: EQUAL
11678: IFFALSE 11713
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
11680: LD_ADDR_VAR 0 10
11684: PUSH
11685: LD_VAR 0 10
11689: PUSH
11690: LD_VAR 0 6
11694: PPUSH
11695: CALL_OW 311
11699: PPUSH
11700: LD_INT 3
11702: PPUSH
11703: CALL_OW 259
11707: PUSH
11708: LD_INT 4
11710: MUL
11711: MUL
11712: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
11713: LD_VAR 0 6
11717: PPUSH
11718: CALL_OW 263
11722: PUSH
11723: LD_INT 2
11725: EQUAL
11726: IFFALSE 11777
// begin j := IsControledBy ( i ) ;
11728: LD_ADDR_VAR 0 7
11732: PUSH
11733: LD_VAR 0 6
11737: PPUSH
11738: CALL_OW 312
11742: ST_TO_ADDR
// if j then
11743: LD_VAR 0 7
11747: IFFALSE 11777
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
11749: LD_ADDR_VAR 0 10
11753: PUSH
11754: LD_VAR 0 10
11758: PUSH
11759: LD_VAR 0 7
11763: PPUSH
11764: LD_INT 3
11766: PPUSH
11767: CALL_OW 259
11771: PUSH
11772: LD_INT 3
11774: MUL
11775: MUL
11776: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
11777: LD_VAR 0 6
11781: PPUSH
11782: CALL_OW 264
11786: PUSH
11787: LD_INT 5
11789: PUSH
11790: LD_INT 6
11792: PUSH
11793: LD_INT 46
11795: PUSH
11796: LD_INT 44
11798: PUSH
11799: LD_INT 47
11801: PUSH
11802: LD_INT 45
11804: PUSH
11805: LD_INT 28
11807: PUSH
11808: LD_INT 7
11810: PUSH
11811: LD_INT 27
11813: PUSH
11814: LD_INT 29
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: IN
11829: PUSH
11830: LD_VAR 0 1
11834: PPUSH
11835: LD_INT 52
11837: PPUSH
11838: CALL_OW 321
11842: PUSH
11843: LD_INT 2
11845: EQUAL
11846: AND
11847: IFFALSE 11864
// bpoints := bpoints * 1.2 ;
11849: LD_ADDR_VAR 0 10
11853: PUSH
11854: LD_VAR 0 10
11858: PUSH
11859: LD_REAL  1.20000000000000E+0000
11862: MUL
11863: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
11864: LD_VAR 0 6
11868: PPUSH
11869: CALL_OW 264
11873: PUSH
11874: LD_INT 6
11876: PUSH
11877: LD_INT 46
11879: PUSH
11880: LD_INT 47
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: LIST
11887: IN
11888: IFFALSE 11905
// bpoints := bpoints * 1.2 ;
11890: LD_ADDR_VAR 0 10
11894: PUSH
11895: LD_VAR 0 10
11899: PUSH
11900: LD_REAL  1.20000000000000E+0000
11903: MUL
11904: ST_TO_ADDR
// end ; unit_building :
11905: GO 11919
11907: LD_INT 3
11909: DOUBLE
11910: EQUAL
11911: IFTRUE 11915
11913: GO 11918
11915: POP
// ; end ;
11916: GO 11919
11918: POP
// for j = 1 to 3 do
11919: LD_ADDR_VAR 0 7
11923: PUSH
11924: DOUBLE
11925: LD_INT 1
11927: DEC
11928: ST_TO_ADDR
11929: LD_INT 3
11931: PUSH
11932: FOR_TO
11933: IFFALSE 11986
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
11935: LD_ADDR_VAR 0 5
11939: PUSH
11940: LD_VAR 0 5
11944: PPUSH
11945: LD_VAR 0 7
11949: PPUSH
11950: LD_VAR 0 5
11954: PUSH
11955: LD_VAR 0 7
11959: ARRAY
11960: PUSH
11961: LD_VAR 0 9
11965: PUSH
11966: LD_VAR 0 7
11970: ARRAY
11971: PUSH
11972: LD_VAR 0 10
11976: MUL
11977: PLUS
11978: PPUSH
11979: CALL_OW 1
11983: ST_TO_ADDR
11984: GO 11932
11986: POP
11987: POP
// end ;
11988: GO 10471
11990: POP
11991: POP
// result := Replace ( result , 4 , tmp ) ;
11992: LD_ADDR_VAR 0 5
11996: PUSH
11997: LD_VAR 0 5
12001: PPUSH
12002: LD_INT 4
12004: PPUSH
12005: LD_VAR 0 8
12009: PPUSH
12010: CALL_OW 1
12014: ST_TO_ADDR
// end ;
12015: LD_VAR 0 5
12019: RET
// export function DangerAtRange ( unit , range ) ; begin
12020: LD_INT 0
12022: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
12023: LD_ADDR_VAR 0 3
12027: PUSH
12028: LD_VAR 0 1
12032: PPUSH
12033: CALL_OW 255
12037: PPUSH
12038: LD_VAR 0 1
12042: PPUSH
12043: CALL_OW 250
12047: PPUSH
12048: LD_VAR 0 1
12052: PPUSH
12053: CALL_OW 251
12057: PPUSH
12058: LD_VAR 0 2
12062: PPUSH
12063: CALL 10323 0 4
12067: ST_TO_ADDR
// end ;
12068: LD_VAR 0 3
12072: RET
// export function DangerInArea ( side , area ) ; begin
12073: LD_INT 0
12075: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
12076: LD_ADDR_VAR 0 3
12080: PUSH
12081: LD_VAR 0 2
12085: PPUSH
12086: LD_INT 81
12088: PUSH
12089: LD_VAR 0 1
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PPUSH
12098: CALL_OW 70
12102: ST_TO_ADDR
// end ;
12103: LD_VAR 0 3
12107: RET
// export function IsExtension ( b ) ; begin
12108: LD_INT 0
12110: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
12111: LD_ADDR_VAR 0 2
12115: PUSH
12116: LD_VAR 0 1
12120: PUSH
12121: LD_INT 23
12123: PUSH
12124: LD_INT 20
12126: PUSH
12127: LD_INT 22
12129: PUSH
12130: LD_INT 17
12132: PUSH
12133: LD_INT 24
12135: PUSH
12136: LD_INT 21
12138: PUSH
12139: LD_INT 19
12141: PUSH
12142: LD_INT 16
12144: PUSH
12145: LD_INT 25
12147: PUSH
12148: LD_INT 18
12150: PUSH
12151: EMPTY
12152: LIST
12153: LIST
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: IN
12163: ST_TO_ADDR
// end ;
12164: LD_VAR 0 2
12168: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
12169: LD_INT 0
12171: PPUSH
12172: PPUSH
12173: PPUSH
// result := [ ] ;
12174: LD_ADDR_VAR 0 3
12178: PUSH
12179: EMPTY
12180: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
12181: LD_ADDR_VAR 0 4
12185: PUSH
12186: LD_VAR 0 2
12190: PPUSH
12191: LD_INT 21
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: PPUSH
12201: CALL_OW 70
12205: ST_TO_ADDR
// if not tmp then
12206: LD_VAR 0 4
12210: NOT
12211: IFFALSE 12215
// exit ;
12213: GO 12273
// for i in tmp do
12215: LD_ADDR_VAR 0 5
12219: PUSH
12220: LD_VAR 0 4
12224: PUSH
12225: FOR_IN
12226: IFFALSE 12261
// if GetBase ( i ) <> base then
12228: LD_VAR 0 5
12232: PPUSH
12233: CALL_OW 274
12237: PUSH
12238: LD_VAR 0 1
12242: NONEQUAL
12243: IFFALSE 12259
// ComLinkToBase ( base , i ) ;
12245: LD_VAR 0 1
12249: PPUSH
12250: LD_VAR 0 5
12254: PPUSH
12255: CALL_OW 169
12259: GO 12225
12261: POP
12262: POP
// result := tmp ;
12263: LD_ADDR_VAR 0 3
12267: PUSH
12268: LD_VAR 0 4
12272: ST_TO_ADDR
// end ;
12273: LD_VAR 0 3
12277: RET
// export function ComComplete ( unit , b ) ; var i ; begin
12278: LD_INT 0
12280: PPUSH
12281: PPUSH
// if BuildingStatus ( b ) = bs_build then
12282: LD_VAR 0 2
12286: PPUSH
12287: CALL_OW 461
12291: PUSH
12292: LD_INT 1
12294: EQUAL
12295: IFFALSE 12355
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
12297: LD_VAR 0 1
12301: PPUSH
12302: LD_STRING h
12304: PUSH
12305: LD_VAR 0 2
12309: PPUSH
12310: CALL_OW 250
12314: PUSH
12315: LD_VAR 0 2
12319: PPUSH
12320: CALL_OW 251
12324: PUSH
12325: LD_VAR 0 2
12329: PUSH
12330: LD_INT 0
12332: PUSH
12333: LD_INT 0
12335: PUSH
12336: LD_INT 0
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: PUSH
12348: EMPTY
12349: LIST
12350: PPUSH
12351: CALL_OW 446
// end ;
12355: LD_VAR 0 3
12359: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
12360: LD_INT 0
12362: PPUSH
12363: PPUSH
12364: PPUSH
12365: PPUSH
12366: PPUSH
12367: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
12368: LD_VAR 0 1
12372: NOT
12373: PUSH
12374: LD_VAR 0 1
12378: PPUSH
12379: CALL_OW 263
12383: PUSH
12384: LD_INT 2
12386: EQUAL
12387: NOT
12388: OR
12389: IFFALSE 12393
// exit ;
12391: GO 12709
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
12393: LD_ADDR_VAR 0 6
12397: PUSH
12398: LD_INT 22
12400: PUSH
12401: LD_VAR 0 1
12405: PPUSH
12406: CALL_OW 255
12410: PUSH
12411: EMPTY
12412: LIST
12413: LIST
12414: PUSH
12415: LD_INT 2
12417: PUSH
12418: LD_INT 30
12420: PUSH
12421: LD_INT 36
12423: PUSH
12424: EMPTY
12425: LIST
12426: LIST
12427: PUSH
12428: LD_INT 34
12430: PUSH
12431: LD_INT 31
12433: PUSH
12434: EMPTY
12435: LIST
12436: LIST
12437: PUSH
12438: EMPTY
12439: LIST
12440: LIST
12441: LIST
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PPUSH
12447: CALL_OW 69
12451: ST_TO_ADDR
// if not tmp then
12452: LD_VAR 0 6
12456: NOT
12457: IFFALSE 12461
// exit ;
12459: GO 12709
// result := [ ] ;
12461: LD_ADDR_VAR 0 2
12465: PUSH
12466: EMPTY
12467: ST_TO_ADDR
// for i in tmp do
12468: LD_ADDR_VAR 0 3
12472: PUSH
12473: LD_VAR 0 6
12477: PUSH
12478: FOR_IN
12479: IFFALSE 12550
// begin t := UnitsInside ( i ) ;
12481: LD_ADDR_VAR 0 4
12485: PUSH
12486: LD_VAR 0 3
12490: PPUSH
12491: CALL_OW 313
12495: ST_TO_ADDR
// if t then
12496: LD_VAR 0 4
12500: IFFALSE 12548
// for j in t do
12502: LD_ADDR_VAR 0 7
12506: PUSH
12507: LD_VAR 0 4
12511: PUSH
12512: FOR_IN
12513: IFFALSE 12546
// result := Insert ( result , result + 1 , j ) ;
12515: LD_ADDR_VAR 0 2
12519: PUSH
12520: LD_VAR 0 2
12524: PPUSH
12525: LD_VAR 0 2
12529: PUSH
12530: LD_INT 1
12532: PLUS
12533: PPUSH
12534: LD_VAR 0 7
12538: PPUSH
12539: CALL_OW 2
12543: ST_TO_ADDR
12544: GO 12512
12546: POP
12547: POP
// end ;
12548: GO 12478
12550: POP
12551: POP
// if not result then
12552: LD_VAR 0 2
12556: NOT
12557: IFFALSE 12561
// exit ;
12559: GO 12709
// mech := result [ 1 ] ;
12561: LD_ADDR_VAR 0 5
12565: PUSH
12566: LD_VAR 0 2
12570: PUSH
12571: LD_INT 1
12573: ARRAY
12574: ST_TO_ADDR
// if result > 1 then
12575: LD_VAR 0 2
12579: PUSH
12580: LD_INT 1
12582: GREATER
12583: IFFALSE 12695
// for i = 2 to result do
12585: LD_ADDR_VAR 0 3
12589: PUSH
12590: DOUBLE
12591: LD_INT 2
12593: DEC
12594: ST_TO_ADDR
12595: LD_VAR 0 2
12599: PUSH
12600: FOR_TO
12601: IFFALSE 12693
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
12603: LD_ADDR_VAR 0 4
12607: PUSH
12608: LD_VAR 0 2
12612: PUSH
12613: LD_VAR 0 3
12617: ARRAY
12618: PPUSH
12619: LD_INT 3
12621: PPUSH
12622: CALL_OW 259
12626: PUSH
12627: LD_VAR 0 2
12631: PUSH
12632: LD_VAR 0 3
12636: ARRAY
12637: PPUSH
12638: CALL_OW 432
12642: MINUS
12643: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
12644: LD_VAR 0 4
12648: PUSH
12649: LD_VAR 0 5
12653: PPUSH
12654: LD_INT 3
12656: PPUSH
12657: CALL_OW 259
12661: PUSH
12662: LD_VAR 0 5
12666: PPUSH
12667: CALL_OW 432
12671: MINUS
12672: GREATEREQUAL
12673: IFFALSE 12691
// mech := result [ i ] ;
12675: LD_ADDR_VAR 0 5
12679: PUSH
12680: LD_VAR 0 2
12684: PUSH
12685: LD_VAR 0 3
12689: ARRAY
12690: ST_TO_ADDR
// end ;
12691: GO 12600
12693: POP
12694: POP
// ComLinkTo ( vehicle , mech ) ;
12695: LD_VAR 0 1
12699: PPUSH
12700: LD_VAR 0 5
12704: PPUSH
12705: CALL_OW 135
// end ;
12709: LD_VAR 0 2
12713: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
12714: LD_INT 0
12716: PPUSH
12717: PPUSH
12718: PPUSH
12719: PPUSH
12720: PPUSH
12721: PPUSH
12722: PPUSH
12723: PPUSH
12724: PPUSH
12725: PPUSH
12726: PPUSH
12727: PPUSH
12728: PPUSH
// result := [ ] ;
12729: LD_ADDR_VAR 0 7
12733: PUSH
12734: EMPTY
12735: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
12736: LD_VAR 0 1
12740: PPUSH
12741: CALL_OW 266
12745: PUSH
12746: LD_INT 0
12748: PUSH
12749: LD_INT 1
12751: PUSH
12752: EMPTY
12753: LIST
12754: LIST
12755: IN
12756: NOT
12757: IFFALSE 12761
// exit ;
12759: GO 14392
// if name then
12761: LD_VAR 0 3
12765: IFFALSE 12781
// SetBName ( base_dep , name ) ;
12767: LD_VAR 0 1
12771: PPUSH
12772: LD_VAR 0 3
12776: PPUSH
12777: CALL_OW 500
// base := GetBase ( base_dep ) ;
12781: LD_ADDR_VAR 0 15
12785: PUSH
12786: LD_VAR 0 1
12790: PPUSH
12791: CALL_OW 274
12795: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
12796: LD_ADDR_VAR 0 16
12800: PUSH
12801: LD_VAR 0 1
12805: PPUSH
12806: CALL_OW 255
12810: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
12811: LD_ADDR_VAR 0 17
12815: PUSH
12816: LD_VAR 0 1
12820: PPUSH
12821: CALL_OW 248
12825: ST_TO_ADDR
// if sources then
12826: LD_VAR 0 5
12830: IFFALSE 12877
// for i = 1 to 3 do
12832: LD_ADDR_VAR 0 8
12836: PUSH
12837: DOUBLE
12838: LD_INT 1
12840: DEC
12841: ST_TO_ADDR
12842: LD_INT 3
12844: PUSH
12845: FOR_TO
12846: IFFALSE 12875
// AddResourceType ( base , i , sources [ i ] ) ;
12848: LD_VAR 0 15
12852: PPUSH
12853: LD_VAR 0 8
12857: PPUSH
12858: LD_VAR 0 5
12862: PUSH
12863: LD_VAR 0 8
12867: ARRAY
12868: PPUSH
12869: CALL_OW 276
12873: GO 12845
12875: POP
12876: POP
// buildings := GetBaseBuildings ( base , area ) ;
12877: LD_ADDR_VAR 0 18
12881: PUSH
12882: LD_VAR 0 15
12886: PPUSH
12887: LD_VAR 0 2
12891: PPUSH
12892: CALL 12169 0 2
12896: ST_TO_ADDR
// InitHc ;
12897: CALL_OW 19
// InitUc ;
12901: CALL_OW 18
// uc_side := side ;
12905: LD_ADDR_OWVAR 20
12909: PUSH
12910: LD_VAR 0 16
12914: ST_TO_ADDR
// uc_nation := nation ;
12915: LD_ADDR_OWVAR 21
12919: PUSH
12920: LD_VAR 0 17
12924: ST_TO_ADDR
// if buildings then
12925: LD_VAR 0 18
12929: IFFALSE 14251
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
12931: LD_ADDR_VAR 0 19
12935: PUSH
12936: LD_VAR 0 18
12940: PPUSH
12941: LD_INT 2
12943: PUSH
12944: LD_INT 30
12946: PUSH
12947: LD_INT 29
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: PUSH
12954: LD_INT 30
12956: PUSH
12957: LD_INT 30
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: EMPTY
12965: LIST
12966: LIST
12967: LIST
12968: PPUSH
12969: CALL_OW 72
12973: ST_TO_ADDR
// if tmp then
12974: LD_VAR 0 19
12978: IFFALSE 13026
// for i in tmp do
12980: LD_ADDR_VAR 0 8
12984: PUSH
12985: LD_VAR 0 19
12989: PUSH
12990: FOR_IN
12991: IFFALSE 13024
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
12993: LD_VAR 0 8
12997: PPUSH
12998: CALL_OW 250
13002: PPUSH
13003: LD_VAR 0 8
13007: PPUSH
13008: CALL_OW 251
13012: PPUSH
13013: LD_VAR 0 16
13017: PPUSH
13018: CALL_OW 441
13022: GO 12990
13024: POP
13025: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
13026: LD_VAR 0 18
13030: PPUSH
13031: LD_INT 2
13033: PUSH
13034: LD_INT 30
13036: PUSH
13037: LD_INT 32
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: PUSH
13044: LD_INT 30
13046: PUSH
13047: LD_INT 33
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: PPUSH
13059: CALL_OW 72
13063: IFFALSE 13151
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
13065: LD_ADDR_VAR 0 8
13069: PUSH
13070: LD_VAR 0 18
13074: PPUSH
13075: LD_INT 2
13077: PUSH
13078: LD_INT 30
13080: PUSH
13081: LD_INT 32
13083: PUSH
13084: EMPTY
13085: LIST
13086: LIST
13087: PUSH
13088: LD_INT 30
13090: PUSH
13091: LD_INT 33
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: LIST
13102: PPUSH
13103: CALL_OW 72
13107: PUSH
13108: FOR_IN
13109: IFFALSE 13149
// begin if not GetBWeapon ( i ) then
13111: LD_VAR 0 8
13115: PPUSH
13116: CALL_OW 269
13120: NOT
13121: IFFALSE 13147
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
13123: LD_VAR 0 8
13127: PPUSH
13128: LD_VAR 0 8
13132: PPUSH
13133: LD_VAR 0 2
13137: PPUSH
13138: CALL 14397 0 2
13142: PPUSH
13143: CALL_OW 431
// end ;
13147: GO 13108
13149: POP
13150: POP
// end ; for i = 1 to personel do
13151: LD_ADDR_VAR 0 8
13155: PUSH
13156: DOUBLE
13157: LD_INT 1
13159: DEC
13160: ST_TO_ADDR
13161: LD_VAR 0 6
13165: PUSH
13166: FOR_TO
13167: IFFALSE 14231
// begin if i > 4 then
13169: LD_VAR 0 8
13173: PUSH
13174: LD_INT 4
13176: GREATER
13177: IFFALSE 13181
// break ;
13179: GO 14231
// case i of 1 :
13181: LD_VAR 0 8
13185: PUSH
13186: LD_INT 1
13188: DOUBLE
13189: EQUAL
13190: IFTRUE 13194
13192: GO 13274
13194: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
13195: LD_ADDR_VAR 0 12
13199: PUSH
13200: LD_VAR 0 18
13204: PPUSH
13205: LD_INT 22
13207: PUSH
13208: LD_VAR 0 16
13212: PUSH
13213: EMPTY
13214: LIST
13215: LIST
13216: PUSH
13217: LD_INT 58
13219: PUSH
13220: EMPTY
13221: LIST
13222: PUSH
13223: LD_INT 2
13225: PUSH
13226: LD_INT 30
13228: PUSH
13229: LD_INT 32
13231: PUSH
13232: EMPTY
13233: LIST
13234: LIST
13235: PUSH
13236: LD_INT 30
13238: PUSH
13239: LD_INT 4
13241: PUSH
13242: EMPTY
13243: LIST
13244: LIST
13245: PUSH
13246: LD_INT 30
13248: PUSH
13249: LD_INT 5
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: PUSH
13262: EMPTY
13263: LIST
13264: LIST
13265: LIST
13266: PPUSH
13267: CALL_OW 72
13271: ST_TO_ADDR
13272: GO 13496
13274: LD_INT 2
13276: DOUBLE
13277: EQUAL
13278: IFTRUE 13282
13280: GO 13344
13282: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
13283: LD_ADDR_VAR 0 12
13287: PUSH
13288: LD_VAR 0 18
13292: PPUSH
13293: LD_INT 22
13295: PUSH
13296: LD_VAR 0 16
13300: PUSH
13301: EMPTY
13302: LIST
13303: LIST
13304: PUSH
13305: LD_INT 2
13307: PUSH
13308: LD_INT 30
13310: PUSH
13311: LD_INT 0
13313: PUSH
13314: EMPTY
13315: LIST
13316: LIST
13317: PUSH
13318: LD_INT 30
13320: PUSH
13321: LD_INT 1
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: PUSH
13328: EMPTY
13329: LIST
13330: LIST
13331: LIST
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: PPUSH
13337: CALL_OW 72
13341: ST_TO_ADDR
13342: GO 13496
13344: LD_INT 3
13346: DOUBLE
13347: EQUAL
13348: IFTRUE 13352
13350: GO 13414
13352: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
13353: LD_ADDR_VAR 0 12
13357: PUSH
13358: LD_VAR 0 18
13362: PPUSH
13363: LD_INT 22
13365: PUSH
13366: LD_VAR 0 16
13370: PUSH
13371: EMPTY
13372: LIST
13373: LIST
13374: PUSH
13375: LD_INT 2
13377: PUSH
13378: LD_INT 30
13380: PUSH
13381: LD_INT 2
13383: PUSH
13384: EMPTY
13385: LIST
13386: LIST
13387: PUSH
13388: LD_INT 30
13390: PUSH
13391: LD_INT 3
13393: PUSH
13394: EMPTY
13395: LIST
13396: LIST
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: LIST
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PPUSH
13407: CALL_OW 72
13411: ST_TO_ADDR
13412: GO 13496
13414: LD_INT 4
13416: DOUBLE
13417: EQUAL
13418: IFTRUE 13422
13420: GO 13495
13422: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
13423: LD_ADDR_VAR 0 12
13427: PUSH
13428: LD_VAR 0 18
13432: PPUSH
13433: LD_INT 22
13435: PUSH
13436: LD_VAR 0 16
13440: PUSH
13441: EMPTY
13442: LIST
13443: LIST
13444: PUSH
13445: LD_INT 2
13447: PUSH
13448: LD_INT 30
13450: PUSH
13451: LD_INT 6
13453: PUSH
13454: EMPTY
13455: LIST
13456: LIST
13457: PUSH
13458: LD_INT 30
13460: PUSH
13461: LD_INT 7
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: PUSH
13468: LD_INT 30
13470: PUSH
13471: LD_INT 8
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: LIST
13482: LIST
13483: PUSH
13484: EMPTY
13485: LIST
13486: LIST
13487: PPUSH
13488: CALL_OW 72
13492: ST_TO_ADDR
13493: GO 13496
13495: POP
// if i = 1 then
13496: LD_VAR 0 8
13500: PUSH
13501: LD_INT 1
13503: EQUAL
13504: IFFALSE 13615
// begin tmp := [ ] ;
13506: LD_ADDR_VAR 0 19
13510: PUSH
13511: EMPTY
13512: ST_TO_ADDR
// for j in f do
13513: LD_ADDR_VAR 0 9
13517: PUSH
13518: LD_VAR 0 12
13522: PUSH
13523: FOR_IN
13524: IFFALSE 13597
// if GetBType ( j ) = b_bunker then
13526: LD_VAR 0 9
13530: PPUSH
13531: CALL_OW 266
13535: PUSH
13536: LD_INT 32
13538: EQUAL
13539: IFFALSE 13566
// tmp := Insert ( tmp , 1 , j ) else
13541: LD_ADDR_VAR 0 19
13545: PUSH
13546: LD_VAR 0 19
13550: PPUSH
13551: LD_INT 1
13553: PPUSH
13554: LD_VAR 0 9
13558: PPUSH
13559: CALL_OW 2
13563: ST_TO_ADDR
13564: GO 13595
// tmp := Insert ( tmp , tmp + 1 , j ) ;
13566: LD_ADDR_VAR 0 19
13570: PUSH
13571: LD_VAR 0 19
13575: PPUSH
13576: LD_VAR 0 19
13580: PUSH
13581: LD_INT 1
13583: PLUS
13584: PPUSH
13585: LD_VAR 0 9
13589: PPUSH
13590: CALL_OW 2
13594: ST_TO_ADDR
13595: GO 13523
13597: POP
13598: POP
// if tmp then
13599: LD_VAR 0 19
13603: IFFALSE 13615
// f := tmp ;
13605: LD_ADDR_VAR 0 12
13609: PUSH
13610: LD_VAR 0 19
13614: ST_TO_ADDR
// end ; x := personel [ i ] ;
13615: LD_ADDR_VAR 0 13
13619: PUSH
13620: LD_VAR 0 6
13624: PUSH
13625: LD_VAR 0 8
13629: ARRAY
13630: ST_TO_ADDR
// if x = - 1 then
13631: LD_VAR 0 13
13635: PUSH
13636: LD_INT 1
13638: NEG
13639: EQUAL
13640: IFFALSE 13849
// begin for j in f do
13642: LD_ADDR_VAR 0 9
13646: PUSH
13647: LD_VAR 0 12
13651: PUSH
13652: FOR_IN
13653: IFFALSE 13845
// repeat InitHc ;
13655: CALL_OW 19
// if GetBType ( j ) = b_barracks then
13659: LD_VAR 0 9
13663: PPUSH
13664: CALL_OW 266
13668: PUSH
13669: LD_INT 5
13671: EQUAL
13672: IFFALSE 13742
// begin if UnitsInside ( j ) < 3 then
13674: LD_VAR 0 9
13678: PPUSH
13679: CALL_OW 313
13683: PUSH
13684: LD_INT 3
13686: LESS
13687: IFFALSE 13723
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
13689: LD_INT 0
13691: PPUSH
13692: LD_INT 5
13694: PUSH
13695: LD_INT 8
13697: PUSH
13698: LD_INT 9
13700: PUSH
13701: EMPTY
13702: LIST
13703: LIST
13704: LIST
13705: PUSH
13706: LD_VAR 0 17
13710: ARRAY
13711: PPUSH
13712: LD_VAR 0 4
13716: PPUSH
13717: CALL_OW 380
13721: GO 13740
// PrepareHuman ( false , i , skill ) ;
13723: LD_INT 0
13725: PPUSH
13726: LD_VAR 0 8
13730: PPUSH
13731: LD_VAR 0 4
13735: PPUSH
13736: CALL_OW 380
// end else
13740: GO 13759
// PrepareHuman ( false , i , skill ) ;
13742: LD_INT 0
13744: PPUSH
13745: LD_VAR 0 8
13749: PPUSH
13750: LD_VAR 0 4
13754: PPUSH
13755: CALL_OW 380
// un := CreateHuman ;
13759: LD_ADDR_VAR 0 14
13763: PUSH
13764: CALL_OW 44
13768: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13769: LD_ADDR_VAR 0 7
13773: PUSH
13774: LD_VAR 0 7
13778: PPUSH
13779: LD_INT 1
13781: PPUSH
13782: LD_VAR 0 14
13786: PPUSH
13787: CALL_OW 2
13791: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
13792: LD_VAR 0 14
13796: PPUSH
13797: LD_VAR 0 9
13801: PPUSH
13802: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
13806: LD_VAR 0 9
13810: PPUSH
13811: CALL_OW 313
13815: PUSH
13816: LD_INT 6
13818: EQUAL
13819: PUSH
13820: LD_VAR 0 9
13824: PPUSH
13825: CALL_OW 266
13829: PUSH
13830: LD_INT 32
13832: PUSH
13833: LD_INT 31
13835: PUSH
13836: EMPTY
13837: LIST
13838: LIST
13839: IN
13840: OR
13841: IFFALSE 13655
13843: GO 13652
13845: POP
13846: POP
// end else
13847: GO 14229
// for j = 1 to x do
13849: LD_ADDR_VAR 0 9
13853: PUSH
13854: DOUBLE
13855: LD_INT 1
13857: DEC
13858: ST_TO_ADDR
13859: LD_VAR 0 13
13863: PUSH
13864: FOR_TO
13865: IFFALSE 14227
// begin InitHc ;
13867: CALL_OW 19
// if not f then
13871: LD_VAR 0 12
13875: NOT
13876: IFFALSE 13965
// begin PrepareHuman ( false , i , skill ) ;
13878: LD_INT 0
13880: PPUSH
13881: LD_VAR 0 8
13885: PPUSH
13886: LD_VAR 0 4
13890: PPUSH
13891: CALL_OW 380
// un := CreateHuman ;
13895: LD_ADDR_VAR 0 14
13899: PUSH
13900: CALL_OW 44
13904: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13905: LD_ADDR_VAR 0 7
13909: PUSH
13910: LD_VAR 0 7
13914: PPUSH
13915: LD_INT 1
13917: PPUSH
13918: LD_VAR 0 14
13922: PPUSH
13923: CALL_OW 2
13927: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
13928: LD_VAR 0 14
13932: PPUSH
13933: LD_VAR 0 1
13937: PPUSH
13938: CALL_OW 250
13942: PPUSH
13943: LD_VAR 0 1
13947: PPUSH
13948: CALL_OW 251
13952: PPUSH
13953: LD_INT 10
13955: PPUSH
13956: LD_INT 0
13958: PPUSH
13959: CALL_OW 50
// continue ;
13963: GO 13864
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
13965: LD_VAR 0 12
13969: PUSH
13970: LD_INT 1
13972: ARRAY
13973: PPUSH
13974: CALL_OW 313
13978: PUSH
13979: LD_VAR 0 12
13983: PUSH
13984: LD_INT 1
13986: ARRAY
13987: PPUSH
13988: CALL_OW 266
13992: PUSH
13993: LD_INT 32
13995: PUSH
13996: LD_INT 31
13998: PUSH
13999: EMPTY
14000: LIST
14001: LIST
14002: IN
14003: AND
14004: PUSH
14005: LD_VAR 0 12
14009: PUSH
14010: LD_INT 1
14012: ARRAY
14013: PPUSH
14014: CALL_OW 313
14018: PUSH
14019: LD_INT 6
14021: EQUAL
14022: OR
14023: IFFALSE 14043
// f := Delete ( f , 1 ) ;
14025: LD_ADDR_VAR 0 12
14029: PUSH
14030: LD_VAR 0 12
14034: PPUSH
14035: LD_INT 1
14037: PPUSH
14038: CALL_OW 3
14042: ST_TO_ADDR
// if not f then
14043: LD_VAR 0 12
14047: NOT
14048: IFFALSE 14066
// begin x := x + 2 ;
14050: LD_ADDR_VAR 0 13
14054: PUSH
14055: LD_VAR 0 13
14059: PUSH
14060: LD_INT 2
14062: PLUS
14063: ST_TO_ADDR
// continue ;
14064: GO 13864
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
14066: LD_VAR 0 12
14070: PUSH
14071: LD_INT 1
14073: ARRAY
14074: PPUSH
14075: CALL_OW 266
14079: PUSH
14080: LD_INT 5
14082: EQUAL
14083: IFFALSE 14157
// begin if UnitsInside ( f [ 1 ] ) < 3 then
14085: LD_VAR 0 12
14089: PUSH
14090: LD_INT 1
14092: ARRAY
14093: PPUSH
14094: CALL_OW 313
14098: PUSH
14099: LD_INT 3
14101: LESS
14102: IFFALSE 14138
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
14104: LD_INT 0
14106: PPUSH
14107: LD_INT 5
14109: PUSH
14110: LD_INT 8
14112: PUSH
14113: LD_INT 9
14115: PUSH
14116: EMPTY
14117: LIST
14118: LIST
14119: LIST
14120: PUSH
14121: LD_VAR 0 17
14125: ARRAY
14126: PPUSH
14127: LD_VAR 0 4
14131: PPUSH
14132: CALL_OW 380
14136: GO 14155
// PrepareHuman ( false , i , skill ) ;
14138: LD_INT 0
14140: PPUSH
14141: LD_VAR 0 8
14145: PPUSH
14146: LD_VAR 0 4
14150: PPUSH
14151: CALL_OW 380
// end else
14155: GO 14174
// PrepareHuman ( false , i , skill ) ;
14157: LD_INT 0
14159: PPUSH
14160: LD_VAR 0 8
14164: PPUSH
14165: LD_VAR 0 4
14169: PPUSH
14170: CALL_OW 380
// un := CreateHuman ;
14174: LD_ADDR_VAR 0 14
14178: PUSH
14179: CALL_OW 44
14183: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
14184: LD_ADDR_VAR 0 7
14188: PUSH
14189: LD_VAR 0 7
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: LD_VAR 0 14
14201: PPUSH
14202: CALL_OW 2
14206: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
14207: LD_VAR 0 14
14211: PPUSH
14212: LD_VAR 0 12
14216: PUSH
14217: LD_INT 1
14219: ARRAY
14220: PPUSH
14221: CALL_OW 52
// end ;
14225: GO 13864
14227: POP
14228: POP
// end ;
14229: GO 13166
14231: POP
14232: POP
// result := result ^ buildings ;
14233: LD_ADDR_VAR 0 7
14237: PUSH
14238: LD_VAR 0 7
14242: PUSH
14243: LD_VAR 0 18
14247: ADD
14248: ST_TO_ADDR
// end else
14249: GO 14392
// begin for i = 1 to personel do
14251: LD_ADDR_VAR 0 8
14255: PUSH
14256: DOUBLE
14257: LD_INT 1
14259: DEC
14260: ST_TO_ADDR
14261: LD_VAR 0 6
14265: PUSH
14266: FOR_TO
14267: IFFALSE 14390
// begin if i > 4 then
14269: LD_VAR 0 8
14273: PUSH
14274: LD_INT 4
14276: GREATER
14277: IFFALSE 14281
// break ;
14279: GO 14390
// x := personel [ i ] ;
14281: LD_ADDR_VAR 0 13
14285: PUSH
14286: LD_VAR 0 6
14290: PUSH
14291: LD_VAR 0 8
14295: ARRAY
14296: ST_TO_ADDR
// if x = - 1 then
14297: LD_VAR 0 13
14301: PUSH
14302: LD_INT 1
14304: NEG
14305: EQUAL
14306: IFFALSE 14310
// continue ;
14308: GO 14266
// PrepareHuman ( false , i , skill ) ;
14310: LD_INT 0
14312: PPUSH
14313: LD_VAR 0 8
14317: PPUSH
14318: LD_VAR 0 4
14322: PPUSH
14323: CALL_OW 380
// un := CreateHuman ;
14327: LD_ADDR_VAR 0 14
14331: PUSH
14332: CALL_OW 44
14336: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
14337: LD_VAR 0 14
14341: PPUSH
14342: LD_VAR 0 1
14346: PPUSH
14347: CALL_OW 250
14351: PPUSH
14352: LD_VAR 0 1
14356: PPUSH
14357: CALL_OW 251
14361: PPUSH
14362: LD_INT 10
14364: PPUSH
14365: LD_INT 0
14367: PPUSH
14368: CALL_OW 50
// result := result ^ un ;
14372: LD_ADDR_VAR 0 7
14376: PUSH
14377: LD_VAR 0 7
14381: PUSH
14382: LD_VAR 0 14
14386: ADD
14387: ST_TO_ADDR
// end ;
14388: GO 14266
14390: POP
14391: POP
// end ; end ;
14392: LD_VAR 0 7
14396: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
14397: LD_INT 0
14399: PPUSH
14400: PPUSH
14401: PPUSH
14402: PPUSH
14403: PPUSH
14404: PPUSH
14405: PPUSH
14406: PPUSH
14407: PPUSH
14408: PPUSH
14409: PPUSH
14410: PPUSH
14411: PPUSH
14412: PPUSH
14413: PPUSH
14414: PPUSH
// result := false ;
14415: LD_ADDR_VAR 0 3
14419: PUSH
14420: LD_INT 0
14422: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
14423: LD_VAR 0 1
14427: NOT
14428: PUSH
14429: LD_VAR 0 1
14433: PPUSH
14434: CALL_OW 266
14438: PUSH
14439: LD_INT 32
14441: PUSH
14442: LD_INT 33
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: IN
14449: NOT
14450: OR
14451: IFFALSE 14455
// exit ;
14453: GO 15591
// nat := GetNation ( tower ) ;
14455: LD_ADDR_VAR 0 12
14459: PUSH
14460: LD_VAR 0 1
14464: PPUSH
14465: CALL_OW 248
14469: ST_TO_ADDR
// side := GetSide ( tower ) ;
14470: LD_ADDR_VAR 0 16
14474: PUSH
14475: LD_VAR 0 1
14479: PPUSH
14480: CALL_OW 255
14484: ST_TO_ADDR
// x := GetX ( tower ) ;
14485: LD_ADDR_VAR 0 10
14489: PUSH
14490: LD_VAR 0 1
14494: PPUSH
14495: CALL_OW 250
14499: ST_TO_ADDR
// y := GetY ( tower ) ;
14500: LD_ADDR_VAR 0 11
14504: PUSH
14505: LD_VAR 0 1
14509: PPUSH
14510: CALL_OW 251
14514: ST_TO_ADDR
// if not x or not y then
14515: LD_VAR 0 10
14519: NOT
14520: PUSH
14521: LD_VAR 0 11
14525: NOT
14526: OR
14527: IFFALSE 14531
// exit ;
14529: GO 15591
// weapon := 0 ;
14531: LD_ADDR_VAR 0 18
14535: PUSH
14536: LD_INT 0
14538: ST_TO_ADDR
// fac_list := [ ] ;
14539: LD_ADDR_VAR 0 17
14543: PUSH
14544: EMPTY
14545: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
14546: LD_ADDR_VAR 0 6
14550: PUSH
14551: LD_VAR 0 1
14555: PPUSH
14556: CALL_OW 274
14560: PPUSH
14561: LD_VAR 0 2
14565: PPUSH
14566: CALL 12169 0 2
14570: PPUSH
14571: LD_INT 30
14573: PUSH
14574: LD_INT 3
14576: PUSH
14577: EMPTY
14578: LIST
14579: LIST
14580: PPUSH
14581: CALL_OW 72
14585: ST_TO_ADDR
// if not factories then
14586: LD_VAR 0 6
14590: NOT
14591: IFFALSE 14595
// exit ;
14593: GO 15591
// for i in factories do
14595: LD_ADDR_VAR 0 8
14599: PUSH
14600: LD_VAR 0 6
14604: PUSH
14605: FOR_IN
14606: IFFALSE 14631
// fac_list := fac_list union AvailableWeaponList ( i ) ;
14608: LD_ADDR_VAR 0 17
14612: PUSH
14613: LD_VAR 0 17
14617: PUSH
14618: LD_VAR 0 8
14622: PPUSH
14623: CALL_OW 478
14627: UNION
14628: ST_TO_ADDR
14629: GO 14605
14631: POP
14632: POP
// if not fac_list then
14633: LD_VAR 0 17
14637: NOT
14638: IFFALSE 14642
// exit ;
14640: GO 15591
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
14642: LD_ADDR_VAR 0 5
14646: PUSH
14647: LD_INT 4
14649: PUSH
14650: LD_INT 5
14652: PUSH
14653: LD_INT 9
14655: PUSH
14656: LD_INT 10
14658: PUSH
14659: LD_INT 6
14661: PUSH
14662: LD_INT 7
14664: PUSH
14665: LD_INT 11
14667: PUSH
14668: EMPTY
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 27
14679: PUSH
14680: LD_INT 28
14682: PUSH
14683: LD_INT 26
14685: PUSH
14686: LD_INT 30
14688: PUSH
14689: EMPTY
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: PUSH
14695: LD_INT 43
14697: PUSH
14698: LD_INT 44
14700: PUSH
14701: LD_INT 46
14703: PUSH
14704: LD_INT 45
14706: PUSH
14707: LD_INT 47
14709: PUSH
14710: LD_INT 49
14712: PUSH
14713: EMPTY
14714: LIST
14715: LIST
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: PUSH
14721: EMPTY
14722: LIST
14723: LIST
14724: LIST
14725: PUSH
14726: LD_VAR 0 12
14730: ARRAY
14731: ST_TO_ADDR
// for i in list do
14732: LD_ADDR_VAR 0 8
14736: PUSH
14737: LD_VAR 0 5
14741: PUSH
14742: FOR_IN
14743: IFFALSE 14776
// if not i in fac_list then
14745: LD_VAR 0 8
14749: PUSH
14750: LD_VAR 0 17
14754: IN
14755: NOT
14756: IFFALSE 14774
// list := list diff i ;
14758: LD_ADDR_VAR 0 5
14762: PUSH
14763: LD_VAR 0 5
14767: PUSH
14768: LD_VAR 0 8
14772: DIFF
14773: ST_TO_ADDR
14774: GO 14742
14776: POP
14777: POP
// if not list then
14778: LD_VAR 0 5
14782: NOT
14783: IFFALSE 14787
// exit ;
14785: GO 15591
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
14787: LD_VAR 0 12
14791: PUSH
14792: LD_INT 3
14794: EQUAL
14795: PUSH
14796: LD_INT 49
14798: PUSH
14799: LD_VAR 0 5
14803: IN
14804: AND
14805: PUSH
14806: LD_INT 31
14808: PPUSH
14809: LD_VAR 0 16
14813: PPUSH
14814: CALL_OW 321
14818: PUSH
14819: LD_INT 2
14821: EQUAL
14822: AND
14823: IFFALSE 14883
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
14825: LD_INT 22
14827: PUSH
14828: LD_VAR 0 16
14832: PUSH
14833: EMPTY
14834: LIST
14835: LIST
14836: PUSH
14837: LD_INT 35
14839: PUSH
14840: LD_INT 49
14842: PUSH
14843: EMPTY
14844: LIST
14845: LIST
14846: PUSH
14847: LD_INT 91
14849: PUSH
14850: LD_VAR 0 1
14854: PUSH
14855: LD_INT 10
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: LIST
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: LIST
14867: PPUSH
14868: CALL_OW 69
14872: NOT
14873: IFFALSE 14883
// weapon := ru_time_lapser ;
14875: LD_ADDR_VAR 0 18
14879: PUSH
14880: LD_INT 49
14882: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
14883: LD_VAR 0 12
14887: PUSH
14888: LD_INT 1
14890: PUSH
14891: LD_INT 2
14893: PUSH
14894: EMPTY
14895: LIST
14896: LIST
14897: IN
14898: PUSH
14899: LD_INT 11
14901: PUSH
14902: LD_VAR 0 5
14906: IN
14907: PUSH
14908: LD_INT 30
14910: PUSH
14911: LD_VAR 0 5
14915: IN
14916: OR
14917: AND
14918: PUSH
14919: LD_INT 6
14921: PPUSH
14922: LD_VAR 0 16
14926: PPUSH
14927: CALL_OW 321
14931: PUSH
14932: LD_INT 2
14934: EQUAL
14935: AND
14936: IFFALSE 15101
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
14938: LD_INT 22
14940: PUSH
14941: LD_VAR 0 16
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: PUSH
14950: LD_INT 2
14952: PUSH
14953: LD_INT 35
14955: PUSH
14956: LD_INT 11
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PUSH
14963: LD_INT 35
14965: PUSH
14966: LD_INT 30
14968: PUSH
14969: EMPTY
14970: LIST
14971: LIST
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: LIST
14977: PUSH
14978: LD_INT 91
14980: PUSH
14981: LD_VAR 0 1
14985: PUSH
14986: LD_INT 18
14988: PUSH
14989: EMPTY
14990: LIST
14991: LIST
14992: LIST
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: LIST
14998: PPUSH
14999: CALL_OW 69
15003: NOT
15004: PUSH
15005: LD_INT 22
15007: PUSH
15008: LD_VAR 0 16
15012: PUSH
15013: EMPTY
15014: LIST
15015: LIST
15016: PUSH
15017: LD_INT 2
15019: PUSH
15020: LD_INT 30
15022: PUSH
15023: LD_INT 32
15025: PUSH
15026: EMPTY
15027: LIST
15028: LIST
15029: PUSH
15030: LD_INT 30
15032: PUSH
15033: LD_INT 33
15035: PUSH
15036: EMPTY
15037: LIST
15038: LIST
15039: PUSH
15040: EMPTY
15041: LIST
15042: LIST
15043: LIST
15044: PUSH
15045: LD_INT 91
15047: PUSH
15048: LD_VAR 0 1
15052: PUSH
15053: LD_INT 12
15055: PUSH
15056: EMPTY
15057: LIST
15058: LIST
15059: LIST
15060: PUSH
15061: EMPTY
15062: LIST
15063: LIST
15064: LIST
15065: PUSH
15066: EMPTY
15067: LIST
15068: PPUSH
15069: CALL_OW 69
15073: PUSH
15074: LD_INT 2
15076: GREATER
15077: AND
15078: IFFALSE 15101
// weapon := [ us_radar , ar_radar ] [ nat ] ;
15080: LD_ADDR_VAR 0 18
15084: PUSH
15085: LD_INT 11
15087: PUSH
15088: LD_INT 30
15090: PUSH
15091: EMPTY
15092: LIST
15093: LIST
15094: PUSH
15095: LD_VAR 0 12
15099: ARRAY
15100: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
15101: LD_VAR 0 18
15105: NOT
15106: PUSH
15107: LD_INT 40
15109: PPUSH
15110: LD_VAR 0 16
15114: PPUSH
15115: CALL_OW 321
15119: PUSH
15120: LD_INT 2
15122: EQUAL
15123: AND
15124: PUSH
15125: LD_INT 7
15127: PUSH
15128: LD_VAR 0 5
15132: IN
15133: PUSH
15134: LD_INT 28
15136: PUSH
15137: LD_VAR 0 5
15141: IN
15142: OR
15143: PUSH
15144: LD_INT 45
15146: PUSH
15147: LD_VAR 0 5
15151: IN
15152: OR
15153: AND
15154: IFFALSE 15408
// begin hex := GetHexInfo ( x , y ) ;
15156: LD_ADDR_VAR 0 4
15160: PUSH
15161: LD_VAR 0 10
15165: PPUSH
15166: LD_VAR 0 11
15170: PPUSH
15171: CALL_OW 546
15175: ST_TO_ADDR
// if hex [ 1 ] then
15176: LD_VAR 0 4
15180: PUSH
15181: LD_INT 1
15183: ARRAY
15184: IFFALSE 15188
// exit ;
15186: GO 15591
// height := hex [ 2 ] ;
15188: LD_ADDR_VAR 0 15
15192: PUSH
15193: LD_VAR 0 4
15197: PUSH
15198: LD_INT 2
15200: ARRAY
15201: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
15202: LD_ADDR_VAR 0 14
15206: PUSH
15207: LD_INT 0
15209: PUSH
15210: LD_INT 2
15212: PUSH
15213: LD_INT 3
15215: PUSH
15216: LD_INT 5
15218: PUSH
15219: EMPTY
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: ST_TO_ADDR
// for i in tmp do
15225: LD_ADDR_VAR 0 8
15229: PUSH
15230: LD_VAR 0 14
15234: PUSH
15235: FOR_IN
15236: IFFALSE 15406
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
15238: LD_ADDR_VAR 0 9
15242: PUSH
15243: LD_VAR 0 10
15247: PPUSH
15248: LD_VAR 0 8
15252: PPUSH
15253: LD_INT 5
15255: PPUSH
15256: CALL_OW 272
15260: PUSH
15261: LD_VAR 0 11
15265: PPUSH
15266: LD_VAR 0 8
15270: PPUSH
15271: LD_INT 5
15273: PPUSH
15274: CALL_OW 273
15278: PUSH
15279: EMPTY
15280: LIST
15281: LIST
15282: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
15283: LD_VAR 0 9
15287: PUSH
15288: LD_INT 1
15290: ARRAY
15291: PPUSH
15292: LD_VAR 0 9
15296: PUSH
15297: LD_INT 2
15299: ARRAY
15300: PPUSH
15301: CALL_OW 488
15305: IFFALSE 15404
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
15307: LD_ADDR_VAR 0 4
15311: PUSH
15312: LD_VAR 0 9
15316: PUSH
15317: LD_INT 1
15319: ARRAY
15320: PPUSH
15321: LD_VAR 0 9
15325: PUSH
15326: LD_INT 2
15328: ARRAY
15329: PPUSH
15330: CALL_OW 546
15334: ST_TO_ADDR
// if hex [ 1 ] then
15335: LD_VAR 0 4
15339: PUSH
15340: LD_INT 1
15342: ARRAY
15343: IFFALSE 15347
// continue ;
15345: GO 15235
// h := hex [ 2 ] ;
15347: LD_ADDR_VAR 0 13
15351: PUSH
15352: LD_VAR 0 4
15356: PUSH
15357: LD_INT 2
15359: ARRAY
15360: ST_TO_ADDR
// if h + 7 < height then
15361: LD_VAR 0 13
15365: PUSH
15366: LD_INT 7
15368: PLUS
15369: PUSH
15370: LD_VAR 0 15
15374: LESS
15375: IFFALSE 15404
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
15377: LD_ADDR_VAR 0 18
15381: PUSH
15382: LD_INT 7
15384: PUSH
15385: LD_INT 28
15387: PUSH
15388: LD_INT 45
15390: PUSH
15391: EMPTY
15392: LIST
15393: LIST
15394: LIST
15395: PUSH
15396: LD_VAR 0 12
15400: ARRAY
15401: ST_TO_ADDR
// break ;
15402: GO 15406
// end ; end ; end ;
15404: GO 15235
15406: POP
15407: POP
// end ; if not weapon then
15408: LD_VAR 0 18
15412: NOT
15413: IFFALSE 15473
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
15415: LD_ADDR_VAR 0 5
15419: PUSH
15420: LD_VAR 0 5
15424: PUSH
15425: LD_INT 11
15427: PUSH
15428: LD_INT 30
15430: PUSH
15431: LD_INT 49
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: LIST
15438: DIFF
15439: ST_TO_ADDR
// if not list then
15440: LD_VAR 0 5
15444: NOT
15445: IFFALSE 15449
// exit ;
15447: GO 15591
// weapon := list [ rand ( 1 , list ) ] ;
15449: LD_ADDR_VAR 0 18
15453: PUSH
15454: LD_VAR 0 5
15458: PUSH
15459: LD_INT 1
15461: PPUSH
15462: LD_VAR 0 5
15466: PPUSH
15467: CALL_OW 12
15471: ARRAY
15472: ST_TO_ADDR
// end ; if weapon then
15473: LD_VAR 0 18
15477: IFFALSE 15591
// begin tmp := CostOfWeapon ( weapon ) ;
15479: LD_ADDR_VAR 0 14
15483: PUSH
15484: LD_VAR 0 18
15488: PPUSH
15489: CALL_OW 451
15493: ST_TO_ADDR
// j := GetBase ( tower ) ;
15494: LD_ADDR_VAR 0 9
15498: PUSH
15499: LD_VAR 0 1
15503: PPUSH
15504: CALL_OW 274
15508: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
15509: LD_VAR 0 9
15513: PPUSH
15514: LD_INT 1
15516: PPUSH
15517: CALL_OW 275
15521: PUSH
15522: LD_VAR 0 14
15526: PUSH
15527: LD_INT 1
15529: ARRAY
15530: GREATEREQUAL
15531: PUSH
15532: LD_VAR 0 9
15536: PPUSH
15537: LD_INT 2
15539: PPUSH
15540: CALL_OW 275
15544: PUSH
15545: LD_VAR 0 14
15549: PUSH
15550: LD_INT 2
15552: ARRAY
15553: GREATEREQUAL
15554: AND
15555: PUSH
15556: LD_VAR 0 9
15560: PPUSH
15561: LD_INT 3
15563: PPUSH
15564: CALL_OW 275
15568: PUSH
15569: LD_VAR 0 14
15573: PUSH
15574: LD_INT 3
15576: ARRAY
15577: GREATEREQUAL
15578: AND
15579: IFFALSE 15591
// result := weapon ;
15581: LD_ADDR_VAR 0 3
15585: PUSH
15586: LD_VAR 0 18
15590: ST_TO_ADDR
// end ; end ;
15591: LD_VAR 0 3
15595: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
15596: LD_INT 0
15598: PPUSH
15599: PPUSH
// result := true ;
15600: LD_ADDR_VAR 0 3
15604: PUSH
15605: LD_INT 1
15607: ST_TO_ADDR
// if array1 = array2 then
15608: LD_VAR 0 1
15612: PUSH
15613: LD_VAR 0 2
15617: EQUAL
15618: IFFALSE 15678
// begin for i = 1 to array1 do
15620: LD_ADDR_VAR 0 4
15624: PUSH
15625: DOUBLE
15626: LD_INT 1
15628: DEC
15629: ST_TO_ADDR
15630: LD_VAR 0 1
15634: PUSH
15635: FOR_TO
15636: IFFALSE 15674
// if array1 [ i ] <> array2 [ i ] then
15638: LD_VAR 0 1
15642: PUSH
15643: LD_VAR 0 4
15647: ARRAY
15648: PUSH
15649: LD_VAR 0 2
15653: PUSH
15654: LD_VAR 0 4
15658: ARRAY
15659: NONEQUAL
15660: IFFALSE 15672
// begin result := false ;
15662: LD_ADDR_VAR 0 3
15666: PUSH
15667: LD_INT 0
15669: ST_TO_ADDR
// break ;
15670: GO 15674
// end ;
15672: GO 15635
15674: POP
15675: POP
// end else
15676: GO 15686
// result := false ;
15678: LD_ADDR_VAR 0 3
15682: PUSH
15683: LD_INT 0
15685: ST_TO_ADDR
// end ;
15686: LD_VAR 0 3
15690: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
15691: LD_INT 0
15693: PPUSH
15694: PPUSH
15695: PPUSH
// pom := GetBase ( fac ) ;
15696: LD_ADDR_VAR 0 5
15700: PUSH
15701: LD_VAR 0 1
15705: PPUSH
15706: CALL_OW 274
15710: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
15711: LD_ADDR_VAR 0 4
15715: PUSH
15716: LD_VAR 0 2
15720: PUSH
15721: LD_INT 1
15723: ARRAY
15724: PPUSH
15725: LD_VAR 0 2
15729: PUSH
15730: LD_INT 2
15732: ARRAY
15733: PPUSH
15734: LD_VAR 0 2
15738: PUSH
15739: LD_INT 3
15741: ARRAY
15742: PPUSH
15743: LD_VAR 0 2
15747: PUSH
15748: LD_INT 4
15750: ARRAY
15751: PPUSH
15752: CALL_OW 449
15756: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
15757: LD_ADDR_VAR 0 3
15761: PUSH
15762: LD_VAR 0 5
15766: PPUSH
15767: LD_INT 1
15769: PPUSH
15770: CALL_OW 275
15774: PUSH
15775: LD_VAR 0 4
15779: PUSH
15780: LD_INT 1
15782: ARRAY
15783: GREATEREQUAL
15784: PUSH
15785: LD_VAR 0 5
15789: PPUSH
15790: LD_INT 2
15792: PPUSH
15793: CALL_OW 275
15797: PUSH
15798: LD_VAR 0 4
15802: PUSH
15803: LD_INT 2
15805: ARRAY
15806: GREATEREQUAL
15807: AND
15808: PUSH
15809: LD_VAR 0 5
15813: PPUSH
15814: LD_INT 3
15816: PPUSH
15817: CALL_OW 275
15821: PUSH
15822: LD_VAR 0 4
15826: PUSH
15827: LD_INT 3
15829: ARRAY
15830: GREATEREQUAL
15831: AND
15832: ST_TO_ADDR
// end ;
15833: LD_VAR 0 3
15837: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
15838: LD_INT 0
15840: PPUSH
15841: PPUSH
15842: PPUSH
15843: PPUSH
// pom := GetBase ( building ) ;
15844: LD_ADDR_VAR 0 3
15848: PUSH
15849: LD_VAR 0 1
15853: PPUSH
15854: CALL_OW 274
15858: ST_TO_ADDR
// if not pom then
15859: LD_VAR 0 3
15863: NOT
15864: IFFALSE 15868
// exit ;
15866: GO 16038
// btype := GetBType ( building ) ;
15868: LD_ADDR_VAR 0 5
15872: PUSH
15873: LD_VAR 0 1
15877: PPUSH
15878: CALL_OW 266
15882: ST_TO_ADDR
// if btype = b_armoury then
15883: LD_VAR 0 5
15887: PUSH
15888: LD_INT 4
15890: EQUAL
15891: IFFALSE 15901
// btype := b_barracks ;
15893: LD_ADDR_VAR 0 5
15897: PUSH
15898: LD_INT 5
15900: ST_TO_ADDR
// if btype = b_depot then
15901: LD_VAR 0 5
15905: PUSH
15906: LD_INT 0
15908: EQUAL
15909: IFFALSE 15919
// btype := b_warehouse ;
15911: LD_ADDR_VAR 0 5
15915: PUSH
15916: LD_INT 1
15918: ST_TO_ADDR
// if btype = b_workshop then
15919: LD_VAR 0 5
15923: PUSH
15924: LD_INT 2
15926: EQUAL
15927: IFFALSE 15937
// btype := b_factory ;
15929: LD_ADDR_VAR 0 5
15933: PUSH
15934: LD_INT 3
15936: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
15937: LD_ADDR_VAR 0 4
15941: PUSH
15942: LD_VAR 0 5
15946: PPUSH
15947: LD_VAR 0 1
15951: PPUSH
15952: CALL_OW 248
15956: PPUSH
15957: CALL_OW 450
15961: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
15962: LD_ADDR_VAR 0 2
15966: PUSH
15967: LD_VAR 0 3
15971: PPUSH
15972: LD_INT 1
15974: PPUSH
15975: CALL_OW 275
15979: PUSH
15980: LD_VAR 0 4
15984: PUSH
15985: LD_INT 1
15987: ARRAY
15988: GREATEREQUAL
15989: PUSH
15990: LD_VAR 0 3
15994: PPUSH
15995: LD_INT 2
15997: PPUSH
15998: CALL_OW 275
16002: PUSH
16003: LD_VAR 0 4
16007: PUSH
16008: LD_INT 2
16010: ARRAY
16011: GREATEREQUAL
16012: AND
16013: PUSH
16014: LD_VAR 0 3
16018: PPUSH
16019: LD_INT 3
16021: PPUSH
16022: CALL_OW 275
16026: PUSH
16027: LD_VAR 0 4
16031: PUSH
16032: LD_INT 3
16034: ARRAY
16035: GREATEREQUAL
16036: AND
16037: ST_TO_ADDR
// end ;
16038: LD_VAR 0 2
16042: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
16043: LD_INT 0
16045: PPUSH
16046: PPUSH
16047: PPUSH
// pom := GetBase ( building ) ;
16048: LD_ADDR_VAR 0 4
16052: PUSH
16053: LD_VAR 0 1
16057: PPUSH
16058: CALL_OW 274
16062: ST_TO_ADDR
// if not pom then
16063: LD_VAR 0 4
16067: NOT
16068: IFFALSE 16072
// exit ;
16070: GO 16173
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
16072: LD_ADDR_VAR 0 5
16076: PUSH
16077: LD_VAR 0 2
16081: PPUSH
16082: LD_VAR 0 1
16086: PPUSH
16087: CALL_OW 248
16091: PPUSH
16092: CALL_OW 450
16096: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
16097: LD_ADDR_VAR 0 3
16101: PUSH
16102: LD_VAR 0 4
16106: PPUSH
16107: LD_INT 1
16109: PPUSH
16110: CALL_OW 275
16114: PUSH
16115: LD_VAR 0 5
16119: PUSH
16120: LD_INT 1
16122: ARRAY
16123: GREATEREQUAL
16124: PUSH
16125: LD_VAR 0 4
16129: PPUSH
16130: LD_INT 2
16132: PPUSH
16133: CALL_OW 275
16137: PUSH
16138: LD_VAR 0 5
16142: PUSH
16143: LD_INT 2
16145: ARRAY
16146: GREATEREQUAL
16147: AND
16148: PUSH
16149: LD_VAR 0 4
16153: PPUSH
16154: LD_INT 3
16156: PPUSH
16157: CALL_OW 275
16161: PUSH
16162: LD_VAR 0 5
16166: PUSH
16167: LD_INT 3
16169: ARRAY
16170: GREATEREQUAL
16171: AND
16172: ST_TO_ADDR
// end ;
16173: LD_VAR 0 3
16177: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
16178: LD_INT 0
16180: PPUSH
16181: PPUSH
16182: PPUSH
16183: PPUSH
16184: PPUSH
16185: PPUSH
16186: PPUSH
16187: PPUSH
16188: PPUSH
16189: PPUSH
// result := false ;
16190: LD_ADDR_VAR 0 6
16194: PUSH
16195: LD_INT 0
16197: ST_TO_ADDR
// if not base or not btype or not x or not y then
16198: LD_VAR 0 1
16202: NOT
16203: PUSH
16204: LD_VAR 0 2
16208: NOT
16209: OR
16210: PUSH
16211: LD_VAR 0 3
16215: NOT
16216: OR
16217: PUSH
16218: LD_VAR 0 4
16222: NOT
16223: OR
16224: IFFALSE 16228
// exit ;
16226: GO 16837
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
16228: LD_ADDR_VAR 0 12
16232: PUSH
16233: LD_VAR 0 2
16237: PPUSH
16238: LD_VAR 0 3
16242: PPUSH
16243: LD_VAR 0 4
16247: PPUSH
16248: LD_VAR 0 5
16252: PPUSH
16253: LD_VAR 0 1
16257: PUSH
16258: LD_INT 1
16260: ARRAY
16261: PPUSH
16262: CALL_OW 248
16266: PPUSH
16267: LD_INT 0
16269: PPUSH
16270: CALL 17674 0 6
16274: ST_TO_ADDR
// if not hexes then
16275: LD_VAR 0 12
16279: NOT
16280: IFFALSE 16284
// exit ;
16282: GO 16837
// for i = 1 to hexes do
16284: LD_ADDR_VAR 0 7
16288: PUSH
16289: DOUBLE
16290: LD_INT 1
16292: DEC
16293: ST_TO_ADDR
16294: LD_VAR 0 12
16298: PUSH
16299: FOR_TO
16300: IFFALSE 16835
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
16302: LD_ADDR_VAR 0 11
16306: PUSH
16307: LD_VAR 0 12
16311: PUSH
16312: LD_VAR 0 7
16316: ARRAY
16317: PUSH
16318: LD_INT 1
16320: ARRAY
16321: PPUSH
16322: LD_VAR 0 12
16326: PUSH
16327: LD_VAR 0 7
16331: ARRAY
16332: PUSH
16333: LD_INT 2
16335: ARRAY
16336: PPUSH
16337: CALL_OW 428
16341: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
16342: LD_VAR 0 12
16346: PUSH
16347: LD_VAR 0 7
16351: ARRAY
16352: PUSH
16353: LD_INT 1
16355: ARRAY
16356: PPUSH
16357: LD_VAR 0 12
16361: PUSH
16362: LD_VAR 0 7
16366: ARRAY
16367: PUSH
16368: LD_INT 2
16370: ARRAY
16371: PPUSH
16372: CALL_OW 351
16376: PUSH
16377: LD_VAR 0 12
16381: PUSH
16382: LD_VAR 0 7
16386: ARRAY
16387: PUSH
16388: LD_INT 1
16390: ARRAY
16391: PPUSH
16392: LD_VAR 0 12
16396: PUSH
16397: LD_VAR 0 7
16401: ARRAY
16402: PUSH
16403: LD_INT 2
16405: ARRAY
16406: PPUSH
16407: CALL_OW 488
16411: NOT
16412: OR
16413: PUSH
16414: LD_VAR 0 11
16418: PPUSH
16419: CALL_OW 247
16423: PUSH
16424: LD_INT 3
16426: EQUAL
16427: OR
16428: IFFALSE 16434
// exit ;
16430: POP
16431: POP
16432: GO 16837
// if not tmp or not tmp in base then
16434: LD_VAR 0 11
16438: NOT
16439: PUSH
16440: LD_VAR 0 11
16444: PUSH
16445: LD_VAR 0 1
16449: IN
16450: NOT
16451: OR
16452: IFFALSE 16456
// continue ;
16454: GO 16299
// result := true ;
16456: LD_ADDR_VAR 0 6
16460: PUSH
16461: LD_INT 1
16463: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16464: LD_ADDR_VAR 0 15
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: LD_INT 22
16476: PUSH
16477: LD_VAR 0 11
16481: PPUSH
16482: CALL_OW 255
16486: PUSH
16487: EMPTY
16488: LIST
16489: LIST
16490: PUSH
16491: LD_INT 2
16493: PUSH
16494: LD_INT 30
16496: PUSH
16497: LD_INT 0
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: PUSH
16504: LD_INT 30
16506: PUSH
16507: LD_INT 1
16509: PUSH
16510: EMPTY
16511: LIST
16512: LIST
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: LIST
16518: PUSH
16519: EMPTY
16520: LIST
16521: LIST
16522: PPUSH
16523: CALL_OW 72
16527: ST_TO_ADDR
// if dep then
16528: LD_VAR 0 15
16532: IFFALSE 16668
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
16534: LD_ADDR_VAR 0 14
16538: PUSH
16539: LD_VAR 0 15
16543: PUSH
16544: LD_INT 1
16546: ARRAY
16547: PPUSH
16548: CALL_OW 250
16552: PPUSH
16553: LD_VAR 0 15
16557: PUSH
16558: LD_INT 1
16560: ARRAY
16561: PPUSH
16562: CALL_OW 254
16566: PPUSH
16567: LD_INT 5
16569: PPUSH
16570: CALL_OW 272
16574: PUSH
16575: LD_VAR 0 15
16579: PUSH
16580: LD_INT 1
16582: ARRAY
16583: PPUSH
16584: CALL_OW 251
16588: PPUSH
16589: LD_VAR 0 15
16593: PUSH
16594: LD_INT 1
16596: ARRAY
16597: PPUSH
16598: CALL_OW 254
16602: PPUSH
16603: LD_INT 5
16605: PPUSH
16606: CALL_OW 273
16610: PUSH
16611: EMPTY
16612: LIST
16613: LIST
16614: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
16615: LD_VAR 0 14
16619: PUSH
16620: LD_INT 1
16622: ARRAY
16623: PPUSH
16624: LD_VAR 0 14
16628: PUSH
16629: LD_INT 2
16631: ARRAY
16632: PPUSH
16633: CALL_OW 488
16637: IFFALSE 16668
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
16639: LD_VAR 0 11
16643: PPUSH
16644: LD_VAR 0 14
16648: PUSH
16649: LD_INT 1
16651: ARRAY
16652: PPUSH
16653: LD_VAR 0 14
16657: PUSH
16658: LD_INT 2
16660: ARRAY
16661: PPUSH
16662: CALL_OW 111
// continue ;
16666: GO 16299
// end ; end ; r := GetDir ( tmp ) ;
16668: LD_ADDR_VAR 0 13
16672: PUSH
16673: LD_VAR 0 11
16677: PPUSH
16678: CALL_OW 254
16682: ST_TO_ADDR
// if r = 5 then
16683: LD_VAR 0 13
16687: PUSH
16688: LD_INT 5
16690: EQUAL
16691: IFFALSE 16701
// r := 0 ;
16693: LD_ADDR_VAR 0 13
16697: PUSH
16698: LD_INT 0
16700: ST_TO_ADDR
// for j = r to 5 do
16701: LD_ADDR_VAR 0 8
16705: PUSH
16706: DOUBLE
16707: LD_VAR 0 13
16711: DEC
16712: ST_TO_ADDR
16713: LD_INT 5
16715: PUSH
16716: FOR_TO
16717: IFFALSE 16831
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
16719: LD_ADDR_VAR 0 9
16723: PUSH
16724: LD_VAR 0 11
16728: PPUSH
16729: CALL_OW 250
16733: PPUSH
16734: LD_VAR 0 8
16738: PPUSH
16739: LD_INT 2
16741: PPUSH
16742: CALL_OW 272
16746: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
16747: LD_ADDR_VAR 0 10
16751: PUSH
16752: LD_VAR 0 11
16756: PPUSH
16757: CALL_OW 251
16761: PPUSH
16762: LD_VAR 0 8
16766: PPUSH
16767: LD_INT 2
16769: PPUSH
16770: CALL_OW 273
16774: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
16775: LD_VAR 0 9
16779: PPUSH
16780: LD_VAR 0 10
16784: PPUSH
16785: CALL_OW 488
16789: PUSH
16790: LD_VAR 0 9
16794: PPUSH
16795: LD_VAR 0 10
16799: PPUSH
16800: CALL_OW 428
16804: NOT
16805: AND
16806: IFFALSE 16829
// begin ComMoveXY ( tmp , _x , _y ) ;
16808: LD_VAR 0 11
16812: PPUSH
16813: LD_VAR 0 9
16817: PPUSH
16818: LD_VAR 0 10
16822: PPUSH
16823: CALL_OW 111
// break ;
16827: GO 16831
// end ; end ;
16829: GO 16716
16831: POP
16832: POP
// end ;
16833: GO 16299
16835: POP
16836: POP
// end ;
16837: LD_VAR 0 6
16841: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
16842: LD_INT 0
16844: PPUSH
16845: PPUSH
16846: PPUSH
16847: PPUSH
16848: PPUSH
16849: PPUSH
16850: PPUSH
16851: PPUSH
16852: PPUSH
16853: PPUSH
// result := false ;
16854: LD_ADDR_VAR 0 6
16858: PUSH
16859: LD_INT 0
16861: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
16862: LD_VAR 0 1
16866: NOT
16867: PUSH
16868: LD_VAR 0 1
16872: PPUSH
16873: CALL_OW 266
16877: PUSH
16878: LD_INT 0
16880: PUSH
16881: LD_INT 1
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: IN
16888: NOT
16889: OR
16890: PUSH
16891: LD_VAR 0 2
16895: NOT
16896: OR
16897: PUSH
16898: LD_VAR 0 5
16902: PUSH
16903: LD_INT 0
16905: PUSH
16906: LD_INT 1
16908: PUSH
16909: LD_INT 2
16911: PUSH
16912: LD_INT 3
16914: PUSH
16915: LD_INT 4
16917: PUSH
16918: LD_INT 5
16920: PUSH
16921: EMPTY
16922: LIST
16923: LIST
16924: LIST
16925: LIST
16926: LIST
16927: LIST
16928: IN
16929: NOT
16930: OR
16931: PUSH
16932: LD_VAR 0 3
16936: PPUSH
16937: LD_VAR 0 4
16941: PPUSH
16942: CALL_OW 488
16946: NOT
16947: OR
16948: IFFALSE 16952
// exit ;
16950: GO 17669
// pom := GetBase ( depot ) ;
16952: LD_ADDR_VAR 0 10
16956: PUSH
16957: LD_VAR 0 1
16961: PPUSH
16962: CALL_OW 274
16966: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
16967: LD_ADDR_VAR 0 11
16971: PUSH
16972: LD_VAR 0 2
16976: PPUSH
16977: LD_VAR 0 1
16981: PPUSH
16982: CALL_OW 248
16986: PPUSH
16987: CALL_OW 450
16991: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
16992: LD_VAR 0 10
16996: PPUSH
16997: LD_INT 1
16999: PPUSH
17000: CALL_OW 275
17004: PUSH
17005: LD_VAR 0 11
17009: PUSH
17010: LD_INT 1
17012: ARRAY
17013: GREATEREQUAL
17014: PUSH
17015: LD_VAR 0 10
17019: PPUSH
17020: LD_INT 2
17022: PPUSH
17023: CALL_OW 275
17027: PUSH
17028: LD_VAR 0 11
17032: PUSH
17033: LD_INT 2
17035: ARRAY
17036: GREATEREQUAL
17037: AND
17038: PUSH
17039: LD_VAR 0 10
17043: PPUSH
17044: LD_INT 3
17046: PPUSH
17047: CALL_OW 275
17051: PUSH
17052: LD_VAR 0 11
17056: PUSH
17057: LD_INT 3
17059: ARRAY
17060: GREATEREQUAL
17061: AND
17062: NOT
17063: IFFALSE 17067
// exit ;
17065: GO 17669
// if GetBType ( depot ) = b_depot then
17067: LD_VAR 0 1
17071: PPUSH
17072: CALL_OW 266
17076: PUSH
17077: LD_INT 0
17079: EQUAL
17080: IFFALSE 17092
// dist := 28 else
17082: LD_ADDR_VAR 0 14
17086: PUSH
17087: LD_INT 28
17089: ST_TO_ADDR
17090: GO 17100
// dist := 36 ;
17092: LD_ADDR_VAR 0 14
17096: PUSH
17097: LD_INT 36
17099: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
17100: LD_VAR 0 1
17104: PPUSH
17105: LD_VAR 0 3
17109: PPUSH
17110: LD_VAR 0 4
17114: PPUSH
17115: CALL_OW 297
17119: PUSH
17120: LD_VAR 0 14
17124: GREATER
17125: IFFALSE 17129
// exit ;
17127: GO 17669
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
17129: LD_ADDR_VAR 0 12
17133: PUSH
17134: LD_VAR 0 2
17138: PPUSH
17139: LD_VAR 0 3
17143: PPUSH
17144: LD_VAR 0 4
17148: PPUSH
17149: LD_VAR 0 5
17153: PPUSH
17154: LD_VAR 0 1
17158: PPUSH
17159: CALL_OW 248
17163: PPUSH
17164: LD_INT 0
17166: PPUSH
17167: CALL 17674 0 6
17171: ST_TO_ADDR
// if not hexes then
17172: LD_VAR 0 12
17176: NOT
17177: IFFALSE 17181
// exit ;
17179: GO 17669
// hex := GetHexInfo ( x , y ) ;
17181: LD_ADDR_VAR 0 15
17185: PUSH
17186: LD_VAR 0 3
17190: PPUSH
17191: LD_VAR 0 4
17195: PPUSH
17196: CALL_OW 546
17200: ST_TO_ADDR
// if hex [ 1 ] then
17201: LD_VAR 0 15
17205: PUSH
17206: LD_INT 1
17208: ARRAY
17209: IFFALSE 17213
// exit ;
17211: GO 17669
// height := hex [ 2 ] ;
17213: LD_ADDR_VAR 0 13
17217: PUSH
17218: LD_VAR 0 15
17222: PUSH
17223: LD_INT 2
17225: ARRAY
17226: ST_TO_ADDR
// for i = 1 to hexes do
17227: LD_ADDR_VAR 0 7
17231: PUSH
17232: DOUBLE
17233: LD_INT 1
17235: DEC
17236: ST_TO_ADDR
17237: LD_VAR 0 12
17241: PUSH
17242: FOR_TO
17243: IFFALSE 17573
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
17245: LD_VAR 0 12
17249: PUSH
17250: LD_VAR 0 7
17254: ARRAY
17255: PUSH
17256: LD_INT 1
17258: ARRAY
17259: PPUSH
17260: LD_VAR 0 12
17264: PUSH
17265: LD_VAR 0 7
17269: ARRAY
17270: PUSH
17271: LD_INT 2
17273: ARRAY
17274: PPUSH
17275: CALL_OW 488
17279: NOT
17280: PUSH
17281: LD_VAR 0 12
17285: PUSH
17286: LD_VAR 0 7
17290: ARRAY
17291: PUSH
17292: LD_INT 1
17294: ARRAY
17295: PPUSH
17296: LD_VAR 0 12
17300: PUSH
17301: LD_VAR 0 7
17305: ARRAY
17306: PUSH
17307: LD_INT 2
17309: ARRAY
17310: PPUSH
17311: CALL_OW 428
17315: PUSH
17316: LD_INT 0
17318: GREATER
17319: OR
17320: PUSH
17321: LD_VAR 0 12
17325: PUSH
17326: LD_VAR 0 7
17330: ARRAY
17331: PUSH
17332: LD_INT 1
17334: ARRAY
17335: PPUSH
17336: LD_VAR 0 12
17340: PUSH
17341: LD_VAR 0 7
17345: ARRAY
17346: PUSH
17347: LD_INT 2
17349: ARRAY
17350: PPUSH
17351: CALL_OW 351
17355: OR
17356: IFFALSE 17362
// exit ;
17358: POP
17359: POP
17360: GO 17669
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
17362: LD_ADDR_VAR 0 8
17366: PUSH
17367: LD_VAR 0 12
17371: PUSH
17372: LD_VAR 0 7
17376: ARRAY
17377: PUSH
17378: LD_INT 1
17380: ARRAY
17381: PPUSH
17382: LD_VAR 0 12
17386: PUSH
17387: LD_VAR 0 7
17391: ARRAY
17392: PUSH
17393: LD_INT 2
17395: ARRAY
17396: PPUSH
17397: CALL_OW 546
17401: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
17402: LD_VAR 0 8
17406: PUSH
17407: LD_INT 1
17409: ARRAY
17410: PUSH
17411: LD_VAR 0 8
17415: PUSH
17416: LD_INT 2
17418: ARRAY
17419: PUSH
17420: LD_VAR 0 13
17424: PUSH
17425: LD_INT 2
17427: PLUS
17428: GREATER
17429: OR
17430: PUSH
17431: LD_VAR 0 8
17435: PUSH
17436: LD_INT 2
17438: ARRAY
17439: PUSH
17440: LD_VAR 0 13
17444: PUSH
17445: LD_INT 2
17447: MINUS
17448: LESS
17449: OR
17450: PUSH
17451: LD_VAR 0 8
17455: PUSH
17456: LD_INT 3
17458: ARRAY
17459: PUSH
17460: LD_INT 0
17462: PUSH
17463: LD_INT 8
17465: PUSH
17466: LD_INT 9
17468: PUSH
17469: LD_INT 10
17471: PUSH
17472: LD_INT 11
17474: PUSH
17475: LD_INT 12
17477: PUSH
17478: LD_INT 13
17480: PUSH
17481: LD_INT 16
17483: PUSH
17484: LD_INT 17
17486: PUSH
17487: LD_INT 18
17489: PUSH
17490: LD_INT 19
17492: PUSH
17493: LD_INT 20
17495: PUSH
17496: LD_INT 21
17498: PUSH
17499: EMPTY
17500: LIST
17501: LIST
17502: LIST
17503: LIST
17504: LIST
17505: LIST
17506: LIST
17507: LIST
17508: LIST
17509: LIST
17510: LIST
17511: LIST
17512: LIST
17513: IN
17514: NOT
17515: OR
17516: PUSH
17517: LD_VAR 0 8
17521: PUSH
17522: LD_INT 5
17524: ARRAY
17525: NOT
17526: OR
17527: PUSH
17528: LD_VAR 0 8
17532: PUSH
17533: LD_INT 6
17535: ARRAY
17536: PUSH
17537: LD_INT 1
17539: PUSH
17540: LD_INT 2
17542: PUSH
17543: LD_INT 7
17545: PUSH
17546: LD_INT 9
17548: PUSH
17549: LD_INT 10
17551: PUSH
17552: LD_INT 11
17554: PUSH
17555: EMPTY
17556: LIST
17557: LIST
17558: LIST
17559: LIST
17560: LIST
17561: LIST
17562: IN
17563: NOT
17564: OR
17565: IFFALSE 17571
// exit ;
17567: POP
17568: POP
17569: GO 17669
// end ;
17571: GO 17242
17573: POP
17574: POP
// side := GetSide ( depot ) ;
17575: LD_ADDR_VAR 0 9
17579: PUSH
17580: LD_VAR 0 1
17584: PPUSH
17585: CALL_OW 255
17589: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
17590: LD_VAR 0 9
17594: PPUSH
17595: LD_VAR 0 3
17599: PPUSH
17600: LD_VAR 0 4
17604: PPUSH
17605: LD_INT 20
17607: PPUSH
17608: CALL 10323 0 4
17612: PUSH
17613: LD_INT 4
17615: ARRAY
17616: IFFALSE 17620
// exit ;
17618: GO 17669
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
17620: LD_VAR 0 2
17624: PUSH
17625: LD_INT 29
17627: PUSH
17628: LD_INT 30
17630: PUSH
17631: EMPTY
17632: LIST
17633: LIST
17634: IN
17635: PUSH
17636: LD_VAR 0 3
17640: PPUSH
17641: LD_VAR 0 4
17645: PPUSH
17646: LD_VAR 0 9
17650: PPUSH
17651: CALL_OW 440
17655: NOT
17656: AND
17657: IFFALSE 17661
// exit ;
17659: GO 17669
// result := true ;
17661: LD_ADDR_VAR 0 6
17665: PUSH
17666: LD_INT 1
17668: ST_TO_ADDR
// end ;
17669: LD_VAR 0 6
17673: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
17674: LD_INT 0
17676: PPUSH
17677: PPUSH
17678: PPUSH
17679: PPUSH
17680: PPUSH
17681: PPUSH
17682: PPUSH
17683: PPUSH
17684: PPUSH
17685: PPUSH
17686: PPUSH
17687: PPUSH
17688: PPUSH
17689: PPUSH
17690: PPUSH
17691: PPUSH
17692: PPUSH
17693: PPUSH
17694: PPUSH
17695: PPUSH
17696: PPUSH
17697: PPUSH
17698: PPUSH
17699: PPUSH
17700: PPUSH
17701: PPUSH
17702: PPUSH
17703: PPUSH
17704: PPUSH
17705: PPUSH
17706: PPUSH
17707: PPUSH
17708: PPUSH
17709: PPUSH
17710: PPUSH
17711: PPUSH
17712: PPUSH
17713: PPUSH
17714: PPUSH
17715: PPUSH
17716: PPUSH
17717: PPUSH
17718: PPUSH
17719: PPUSH
17720: PPUSH
17721: PPUSH
17722: PPUSH
17723: PPUSH
17724: PPUSH
17725: PPUSH
17726: PPUSH
17727: PPUSH
17728: PPUSH
17729: PPUSH
17730: PPUSH
17731: PPUSH
17732: PPUSH
17733: PPUSH
// result = [ ] ;
17734: LD_ADDR_VAR 0 7
17738: PUSH
17739: EMPTY
17740: ST_TO_ADDR
// temp_list = [ ] ;
17741: LD_ADDR_VAR 0 9
17745: PUSH
17746: EMPTY
17747: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
17748: LD_VAR 0 4
17752: PUSH
17753: LD_INT 0
17755: PUSH
17756: LD_INT 1
17758: PUSH
17759: LD_INT 2
17761: PUSH
17762: LD_INT 3
17764: PUSH
17765: LD_INT 4
17767: PUSH
17768: LD_INT 5
17770: PUSH
17771: EMPTY
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: IN
17779: NOT
17780: PUSH
17781: LD_VAR 0 1
17785: PUSH
17786: LD_INT 0
17788: PUSH
17789: LD_INT 1
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: IN
17796: PUSH
17797: LD_VAR 0 5
17801: PUSH
17802: LD_INT 1
17804: PUSH
17805: LD_INT 2
17807: PUSH
17808: LD_INT 3
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: LIST
17815: IN
17816: NOT
17817: AND
17818: OR
17819: IFFALSE 17823
// exit ;
17821: GO 36214
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
17823: LD_VAR 0 1
17827: PUSH
17828: LD_INT 6
17830: PUSH
17831: LD_INT 7
17833: PUSH
17834: LD_INT 8
17836: PUSH
17837: LD_INT 13
17839: PUSH
17840: LD_INT 12
17842: PUSH
17843: LD_INT 15
17845: PUSH
17846: LD_INT 11
17848: PUSH
17849: LD_INT 14
17851: PUSH
17852: LD_INT 10
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: LIST
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: LIST
17864: LIST
17865: IN
17866: IFFALSE 17876
// btype = b_lab ;
17868: LD_ADDR_VAR 0 1
17872: PUSH
17873: LD_INT 6
17875: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
17876: LD_VAR 0 6
17880: PUSH
17881: LD_INT 0
17883: PUSH
17884: LD_INT 1
17886: PUSH
17887: LD_INT 2
17889: PUSH
17890: EMPTY
17891: LIST
17892: LIST
17893: LIST
17894: IN
17895: NOT
17896: PUSH
17897: LD_VAR 0 1
17901: PUSH
17902: LD_INT 0
17904: PUSH
17905: LD_INT 1
17907: PUSH
17908: LD_INT 2
17910: PUSH
17911: LD_INT 3
17913: PUSH
17914: LD_INT 6
17916: PUSH
17917: LD_INT 36
17919: PUSH
17920: LD_INT 4
17922: PUSH
17923: LD_INT 5
17925: PUSH
17926: LD_INT 31
17928: PUSH
17929: LD_INT 32
17931: PUSH
17932: LD_INT 33
17934: PUSH
17935: EMPTY
17936: LIST
17937: LIST
17938: LIST
17939: LIST
17940: LIST
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: LIST
17946: LIST
17947: IN
17948: NOT
17949: PUSH
17950: LD_VAR 0 6
17954: PUSH
17955: LD_INT 1
17957: EQUAL
17958: AND
17959: OR
17960: PUSH
17961: LD_VAR 0 1
17965: PUSH
17966: LD_INT 2
17968: PUSH
17969: LD_INT 3
17971: PUSH
17972: EMPTY
17973: LIST
17974: LIST
17975: IN
17976: NOT
17977: PUSH
17978: LD_VAR 0 6
17982: PUSH
17983: LD_INT 2
17985: EQUAL
17986: AND
17987: OR
17988: IFFALSE 17998
// mode = 0 ;
17990: LD_ADDR_VAR 0 6
17994: PUSH
17995: LD_INT 0
17997: ST_TO_ADDR
// case mode of 0 :
17998: LD_VAR 0 6
18002: PUSH
18003: LD_INT 0
18005: DOUBLE
18006: EQUAL
18007: IFTRUE 18011
18009: GO 29464
18011: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
18012: LD_ADDR_VAR 0 11
18016: PUSH
18017: LD_INT 0
18019: PUSH
18020: LD_INT 0
18022: PUSH
18023: EMPTY
18024: LIST
18025: LIST
18026: PUSH
18027: LD_INT 0
18029: PUSH
18030: LD_INT 1
18032: NEG
18033: PUSH
18034: EMPTY
18035: LIST
18036: LIST
18037: PUSH
18038: LD_INT 1
18040: PUSH
18041: LD_INT 0
18043: PUSH
18044: EMPTY
18045: LIST
18046: LIST
18047: PUSH
18048: LD_INT 1
18050: PUSH
18051: LD_INT 1
18053: PUSH
18054: EMPTY
18055: LIST
18056: LIST
18057: PUSH
18058: LD_INT 0
18060: PUSH
18061: LD_INT 1
18063: PUSH
18064: EMPTY
18065: LIST
18066: LIST
18067: PUSH
18068: LD_INT 1
18070: NEG
18071: PUSH
18072: LD_INT 0
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: PUSH
18079: LD_INT 1
18081: NEG
18082: PUSH
18083: LD_INT 1
18085: NEG
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: PUSH
18091: LD_INT 1
18093: NEG
18094: PUSH
18095: LD_INT 2
18097: NEG
18098: PUSH
18099: EMPTY
18100: LIST
18101: LIST
18102: PUSH
18103: LD_INT 0
18105: PUSH
18106: LD_INT 2
18108: NEG
18109: PUSH
18110: EMPTY
18111: LIST
18112: LIST
18113: PUSH
18114: LD_INT 1
18116: PUSH
18117: LD_INT 1
18119: NEG
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: PUSH
18125: LD_INT 1
18127: PUSH
18128: LD_INT 2
18130: PUSH
18131: EMPTY
18132: LIST
18133: LIST
18134: PUSH
18135: LD_INT 0
18137: PUSH
18138: LD_INT 2
18140: PUSH
18141: EMPTY
18142: LIST
18143: LIST
18144: PUSH
18145: LD_INT 1
18147: NEG
18148: PUSH
18149: LD_INT 1
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: PUSH
18156: LD_INT 1
18158: PUSH
18159: LD_INT 3
18161: PUSH
18162: EMPTY
18163: LIST
18164: LIST
18165: PUSH
18166: LD_INT 0
18168: PUSH
18169: LD_INT 3
18171: PUSH
18172: EMPTY
18173: LIST
18174: LIST
18175: PUSH
18176: LD_INT 1
18178: NEG
18179: PUSH
18180: LD_INT 2
18182: PUSH
18183: EMPTY
18184: LIST
18185: LIST
18186: PUSH
18187: EMPTY
18188: LIST
18189: LIST
18190: LIST
18191: LIST
18192: LIST
18193: LIST
18194: LIST
18195: LIST
18196: LIST
18197: LIST
18198: LIST
18199: LIST
18200: LIST
18201: LIST
18202: LIST
18203: LIST
18204: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
18205: LD_ADDR_VAR 0 12
18209: PUSH
18210: LD_INT 0
18212: PUSH
18213: LD_INT 0
18215: PUSH
18216: EMPTY
18217: LIST
18218: LIST
18219: PUSH
18220: LD_INT 0
18222: PUSH
18223: LD_INT 1
18225: NEG
18226: PUSH
18227: EMPTY
18228: LIST
18229: LIST
18230: PUSH
18231: LD_INT 1
18233: PUSH
18234: LD_INT 0
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: PUSH
18241: LD_INT 1
18243: PUSH
18244: LD_INT 1
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PUSH
18251: LD_INT 0
18253: PUSH
18254: LD_INT 1
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: PUSH
18261: LD_INT 1
18263: NEG
18264: PUSH
18265: LD_INT 0
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: PUSH
18272: LD_INT 1
18274: NEG
18275: PUSH
18276: LD_INT 1
18278: NEG
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: PUSH
18284: LD_INT 1
18286: PUSH
18287: LD_INT 1
18289: NEG
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: PUSH
18295: LD_INT 2
18297: PUSH
18298: LD_INT 0
18300: PUSH
18301: EMPTY
18302: LIST
18303: LIST
18304: PUSH
18305: LD_INT 2
18307: PUSH
18308: LD_INT 1
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: PUSH
18315: LD_INT 1
18317: NEG
18318: PUSH
18319: LD_INT 1
18321: PUSH
18322: EMPTY
18323: LIST
18324: LIST
18325: PUSH
18326: LD_INT 2
18328: NEG
18329: PUSH
18330: LD_INT 0
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: PUSH
18337: LD_INT 2
18339: NEG
18340: PUSH
18341: LD_INT 1
18343: NEG
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PUSH
18349: LD_INT 2
18351: NEG
18352: PUSH
18353: LD_INT 1
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PUSH
18360: LD_INT 3
18362: NEG
18363: PUSH
18364: LD_INT 0
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PUSH
18371: LD_INT 3
18373: NEG
18374: PUSH
18375: LD_INT 1
18377: NEG
18378: PUSH
18379: EMPTY
18380: LIST
18381: LIST
18382: PUSH
18383: EMPTY
18384: LIST
18385: LIST
18386: LIST
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: LIST
18398: LIST
18399: LIST
18400: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
18401: LD_ADDR_VAR 0 13
18405: PUSH
18406: LD_INT 0
18408: PUSH
18409: LD_INT 0
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: PUSH
18416: LD_INT 0
18418: PUSH
18419: LD_INT 1
18421: NEG
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 1
18429: PUSH
18430: LD_INT 0
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 1
18439: PUSH
18440: LD_INT 1
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 0
18449: PUSH
18450: LD_INT 1
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: LD_INT 1
18459: NEG
18460: PUSH
18461: LD_INT 0
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PUSH
18468: LD_INT 1
18470: NEG
18471: PUSH
18472: LD_INT 1
18474: NEG
18475: PUSH
18476: EMPTY
18477: LIST
18478: LIST
18479: PUSH
18480: LD_INT 1
18482: NEG
18483: PUSH
18484: LD_INT 2
18486: NEG
18487: PUSH
18488: EMPTY
18489: LIST
18490: LIST
18491: PUSH
18492: LD_INT 2
18494: PUSH
18495: LD_INT 1
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: PUSH
18502: LD_INT 2
18504: PUSH
18505: LD_INT 2
18507: PUSH
18508: EMPTY
18509: LIST
18510: LIST
18511: PUSH
18512: LD_INT 1
18514: PUSH
18515: LD_INT 2
18517: PUSH
18518: EMPTY
18519: LIST
18520: LIST
18521: PUSH
18522: LD_INT 2
18524: NEG
18525: PUSH
18526: LD_INT 1
18528: NEG
18529: PUSH
18530: EMPTY
18531: LIST
18532: LIST
18533: PUSH
18534: LD_INT 2
18536: NEG
18537: PUSH
18538: LD_INT 2
18540: NEG
18541: PUSH
18542: EMPTY
18543: LIST
18544: LIST
18545: PUSH
18546: LD_INT 2
18548: NEG
18549: PUSH
18550: LD_INT 3
18552: NEG
18553: PUSH
18554: EMPTY
18555: LIST
18556: LIST
18557: PUSH
18558: LD_INT 3
18560: NEG
18561: PUSH
18562: LD_INT 2
18564: NEG
18565: PUSH
18566: EMPTY
18567: LIST
18568: LIST
18569: PUSH
18570: LD_INT 3
18572: NEG
18573: PUSH
18574: LD_INT 3
18576: NEG
18577: PUSH
18578: EMPTY
18579: LIST
18580: LIST
18581: PUSH
18582: EMPTY
18583: LIST
18584: LIST
18585: LIST
18586: LIST
18587: LIST
18588: LIST
18589: LIST
18590: LIST
18591: LIST
18592: LIST
18593: LIST
18594: LIST
18595: LIST
18596: LIST
18597: LIST
18598: LIST
18599: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
18600: LD_ADDR_VAR 0 14
18604: PUSH
18605: LD_INT 0
18607: PUSH
18608: LD_INT 0
18610: PUSH
18611: EMPTY
18612: LIST
18613: LIST
18614: PUSH
18615: LD_INT 0
18617: PUSH
18618: LD_INT 1
18620: NEG
18621: PUSH
18622: EMPTY
18623: LIST
18624: LIST
18625: PUSH
18626: LD_INT 1
18628: PUSH
18629: LD_INT 0
18631: PUSH
18632: EMPTY
18633: LIST
18634: LIST
18635: PUSH
18636: LD_INT 1
18638: PUSH
18639: LD_INT 1
18641: PUSH
18642: EMPTY
18643: LIST
18644: LIST
18645: PUSH
18646: LD_INT 0
18648: PUSH
18649: LD_INT 1
18651: PUSH
18652: EMPTY
18653: LIST
18654: LIST
18655: PUSH
18656: LD_INT 1
18658: NEG
18659: PUSH
18660: LD_INT 0
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PUSH
18667: LD_INT 1
18669: NEG
18670: PUSH
18671: LD_INT 1
18673: NEG
18674: PUSH
18675: EMPTY
18676: LIST
18677: LIST
18678: PUSH
18679: LD_INT 1
18681: NEG
18682: PUSH
18683: LD_INT 2
18685: NEG
18686: PUSH
18687: EMPTY
18688: LIST
18689: LIST
18690: PUSH
18691: LD_INT 0
18693: PUSH
18694: LD_INT 2
18696: NEG
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: PUSH
18702: LD_INT 1
18704: PUSH
18705: LD_INT 1
18707: NEG
18708: PUSH
18709: EMPTY
18710: LIST
18711: LIST
18712: PUSH
18713: LD_INT 1
18715: PUSH
18716: LD_INT 2
18718: PUSH
18719: EMPTY
18720: LIST
18721: LIST
18722: PUSH
18723: LD_INT 0
18725: PUSH
18726: LD_INT 2
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: PUSH
18733: LD_INT 1
18735: NEG
18736: PUSH
18737: LD_INT 1
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 1
18746: NEG
18747: PUSH
18748: LD_INT 3
18750: NEG
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: PUSH
18756: LD_INT 0
18758: PUSH
18759: LD_INT 3
18761: NEG
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 1
18769: PUSH
18770: LD_INT 2
18772: NEG
18773: PUSH
18774: EMPTY
18775: LIST
18776: LIST
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: LIST
18782: LIST
18783: LIST
18784: LIST
18785: LIST
18786: LIST
18787: LIST
18788: LIST
18789: LIST
18790: LIST
18791: LIST
18792: LIST
18793: LIST
18794: LIST
18795: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
18796: LD_ADDR_VAR 0 15
18800: PUSH
18801: LD_INT 0
18803: PUSH
18804: LD_INT 0
18806: PUSH
18807: EMPTY
18808: LIST
18809: LIST
18810: PUSH
18811: LD_INT 0
18813: PUSH
18814: LD_INT 1
18816: NEG
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: PUSH
18822: LD_INT 1
18824: PUSH
18825: LD_INT 0
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: PUSH
18832: LD_INT 1
18834: PUSH
18835: LD_INT 1
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: PUSH
18842: LD_INT 0
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: EMPTY
18849: LIST
18850: LIST
18851: PUSH
18852: LD_INT 1
18854: NEG
18855: PUSH
18856: LD_INT 0
18858: PUSH
18859: EMPTY
18860: LIST
18861: LIST
18862: PUSH
18863: LD_INT 1
18865: NEG
18866: PUSH
18867: LD_INT 1
18869: NEG
18870: PUSH
18871: EMPTY
18872: LIST
18873: LIST
18874: PUSH
18875: LD_INT 1
18877: PUSH
18878: LD_INT 1
18880: NEG
18881: PUSH
18882: EMPTY
18883: LIST
18884: LIST
18885: PUSH
18886: LD_INT 2
18888: PUSH
18889: LD_INT 0
18891: PUSH
18892: EMPTY
18893: LIST
18894: LIST
18895: PUSH
18896: LD_INT 2
18898: PUSH
18899: LD_INT 1
18901: PUSH
18902: EMPTY
18903: LIST
18904: LIST
18905: PUSH
18906: LD_INT 1
18908: NEG
18909: PUSH
18910: LD_INT 1
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: LD_INT 2
18919: NEG
18920: PUSH
18921: LD_INT 0
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: PUSH
18928: LD_INT 2
18930: NEG
18931: PUSH
18932: LD_INT 1
18934: NEG
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: PUSH
18940: LD_INT 2
18942: PUSH
18943: LD_INT 1
18945: NEG
18946: PUSH
18947: EMPTY
18948: LIST
18949: LIST
18950: PUSH
18951: LD_INT 3
18953: PUSH
18954: LD_INT 0
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: PUSH
18961: LD_INT 3
18963: PUSH
18964: LD_INT 1
18966: PUSH
18967: EMPTY
18968: LIST
18969: LIST
18970: PUSH
18971: EMPTY
18972: LIST
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: LIST
18981: LIST
18982: LIST
18983: LIST
18984: LIST
18985: LIST
18986: LIST
18987: LIST
18988: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
18989: LD_ADDR_VAR 0 16
18993: PUSH
18994: LD_INT 0
18996: PUSH
18997: LD_INT 0
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: PUSH
19004: LD_INT 0
19006: PUSH
19007: LD_INT 1
19009: NEG
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: PUSH
19015: LD_INT 1
19017: PUSH
19018: LD_INT 0
19020: PUSH
19021: EMPTY
19022: LIST
19023: LIST
19024: PUSH
19025: LD_INT 1
19027: PUSH
19028: LD_INT 1
19030: PUSH
19031: EMPTY
19032: LIST
19033: LIST
19034: PUSH
19035: LD_INT 0
19037: PUSH
19038: LD_INT 1
19040: PUSH
19041: EMPTY
19042: LIST
19043: LIST
19044: PUSH
19045: LD_INT 1
19047: NEG
19048: PUSH
19049: LD_INT 0
19051: PUSH
19052: EMPTY
19053: LIST
19054: LIST
19055: PUSH
19056: LD_INT 1
19058: NEG
19059: PUSH
19060: LD_INT 1
19062: NEG
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: PUSH
19068: LD_INT 1
19070: NEG
19071: PUSH
19072: LD_INT 2
19074: NEG
19075: PUSH
19076: EMPTY
19077: LIST
19078: LIST
19079: PUSH
19080: LD_INT 2
19082: PUSH
19083: LD_INT 1
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: PUSH
19090: LD_INT 2
19092: PUSH
19093: LD_INT 2
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: PUSH
19100: LD_INT 1
19102: PUSH
19103: LD_INT 2
19105: PUSH
19106: EMPTY
19107: LIST
19108: LIST
19109: PUSH
19110: LD_INT 2
19112: NEG
19113: PUSH
19114: LD_INT 1
19116: NEG
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: PUSH
19122: LD_INT 2
19124: NEG
19125: PUSH
19126: LD_INT 2
19128: NEG
19129: PUSH
19130: EMPTY
19131: LIST
19132: LIST
19133: PUSH
19134: LD_INT 3
19136: PUSH
19137: LD_INT 2
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: PUSH
19144: LD_INT 3
19146: PUSH
19147: LD_INT 3
19149: PUSH
19150: EMPTY
19151: LIST
19152: LIST
19153: PUSH
19154: LD_INT 2
19156: PUSH
19157: LD_INT 3
19159: PUSH
19160: EMPTY
19161: LIST
19162: LIST
19163: PUSH
19164: EMPTY
19165: LIST
19166: LIST
19167: LIST
19168: LIST
19169: LIST
19170: LIST
19171: LIST
19172: LIST
19173: LIST
19174: LIST
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19182: LD_ADDR_VAR 0 17
19186: PUSH
19187: LD_INT 0
19189: PUSH
19190: LD_INT 0
19192: PUSH
19193: EMPTY
19194: LIST
19195: LIST
19196: PUSH
19197: LD_INT 0
19199: PUSH
19200: LD_INT 1
19202: NEG
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: PUSH
19208: LD_INT 1
19210: PUSH
19211: LD_INT 0
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: PUSH
19218: LD_INT 1
19220: PUSH
19221: LD_INT 1
19223: PUSH
19224: EMPTY
19225: LIST
19226: LIST
19227: PUSH
19228: LD_INT 0
19230: PUSH
19231: LD_INT 1
19233: PUSH
19234: EMPTY
19235: LIST
19236: LIST
19237: PUSH
19238: LD_INT 1
19240: NEG
19241: PUSH
19242: LD_INT 0
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: PUSH
19249: LD_INT 1
19251: NEG
19252: PUSH
19253: LD_INT 1
19255: NEG
19256: PUSH
19257: EMPTY
19258: LIST
19259: LIST
19260: PUSH
19261: LD_INT 1
19263: NEG
19264: PUSH
19265: LD_INT 2
19267: NEG
19268: PUSH
19269: EMPTY
19270: LIST
19271: LIST
19272: PUSH
19273: LD_INT 0
19275: PUSH
19276: LD_INT 2
19278: NEG
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PUSH
19284: LD_INT 1
19286: PUSH
19287: LD_INT 1
19289: NEG
19290: PUSH
19291: EMPTY
19292: LIST
19293: LIST
19294: PUSH
19295: LD_INT 2
19297: PUSH
19298: LD_INT 0
19300: PUSH
19301: EMPTY
19302: LIST
19303: LIST
19304: PUSH
19305: LD_INT 2
19307: PUSH
19308: LD_INT 1
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: PUSH
19315: LD_INT 2
19317: PUSH
19318: LD_INT 2
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: PUSH
19325: LD_INT 1
19327: PUSH
19328: LD_INT 2
19330: PUSH
19331: EMPTY
19332: LIST
19333: LIST
19334: PUSH
19335: LD_INT 0
19337: PUSH
19338: LD_INT 2
19340: PUSH
19341: EMPTY
19342: LIST
19343: LIST
19344: PUSH
19345: LD_INT 1
19347: NEG
19348: PUSH
19349: LD_INT 1
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: PUSH
19356: LD_INT 2
19358: NEG
19359: PUSH
19360: LD_INT 0
19362: PUSH
19363: EMPTY
19364: LIST
19365: LIST
19366: PUSH
19367: LD_INT 2
19369: NEG
19370: PUSH
19371: LD_INT 1
19373: NEG
19374: PUSH
19375: EMPTY
19376: LIST
19377: LIST
19378: PUSH
19379: LD_INT 2
19381: NEG
19382: PUSH
19383: LD_INT 2
19385: NEG
19386: PUSH
19387: EMPTY
19388: LIST
19389: LIST
19390: PUSH
19391: EMPTY
19392: LIST
19393: LIST
19394: LIST
19395: LIST
19396: LIST
19397: LIST
19398: LIST
19399: LIST
19400: LIST
19401: LIST
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: LIST
19411: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19412: LD_ADDR_VAR 0 18
19416: PUSH
19417: LD_INT 0
19419: PUSH
19420: LD_INT 0
19422: PUSH
19423: EMPTY
19424: LIST
19425: LIST
19426: PUSH
19427: LD_INT 0
19429: PUSH
19430: LD_INT 1
19432: NEG
19433: PUSH
19434: EMPTY
19435: LIST
19436: LIST
19437: PUSH
19438: LD_INT 1
19440: PUSH
19441: LD_INT 0
19443: PUSH
19444: EMPTY
19445: LIST
19446: LIST
19447: PUSH
19448: LD_INT 1
19450: PUSH
19451: LD_INT 1
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: PUSH
19458: LD_INT 0
19460: PUSH
19461: LD_INT 1
19463: PUSH
19464: EMPTY
19465: LIST
19466: LIST
19467: PUSH
19468: LD_INT 1
19470: NEG
19471: PUSH
19472: LD_INT 0
19474: PUSH
19475: EMPTY
19476: LIST
19477: LIST
19478: PUSH
19479: LD_INT 1
19481: NEG
19482: PUSH
19483: LD_INT 1
19485: NEG
19486: PUSH
19487: EMPTY
19488: LIST
19489: LIST
19490: PUSH
19491: LD_INT 1
19493: NEG
19494: PUSH
19495: LD_INT 2
19497: NEG
19498: PUSH
19499: EMPTY
19500: LIST
19501: LIST
19502: PUSH
19503: LD_INT 0
19505: PUSH
19506: LD_INT 2
19508: NEG
19509: PUSH
19510: EMPTY
19511: LIST
19512: LIST
19513: PUSH
19514: LD_INT 1
19516: PUSH
19517: LD_INT 1
19519: NEG
19520: PUSH
19521: EMPTY
19522: LIST
19523: LIST
19524: PUSH
19525: LD_INT 2
19527: PUSH
19528: LD_INT 0
19530: PUSH
19531: EMPTY
19532: LIST
19533: LIST
19534: PUSH
19535: LD_INT 2
19537: PUSH
19538: LD_INT 1
19540: PUSH
19541: EMPTY
19542: LIST
19543: LIST
19544: PUSH
19545: LD_INT 2
19547: PUSH
19548: LD_INT 2
19550: PUSH
19551: EMPTY
19552: LIST
19553: LIST
19554: PUSH
19555: LD_INT 1
19557: PUSH
19558: LD_INT 2
19560: PUSH
19561: EMPTY
19562: LIST
19563: LIST
19564: PUSH
19565: LD_INT 0
19567: PUSH
19568: LD_INT 2
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: PUSH
19575: LD_INT 1
19577: NEG
19578: PUSH
19579: LD_INT 1
19581: PUSH
19582: EMPTY
19583: LIST
19584: LIST
19585: PUSH
19586: LD_INT 2
19588: NEG
19589: PUSH
19590: LD_INT 0
19592: PUSH
19593: EMPTY
19594: LIST
19595: LIST
19596: PUSH
19597: LD_INT 2
19599: NEG
19600: PUSH
19601: LD_INT 1
19603: NEG
19604: PUSH
19605: EMPTY
19606: LIST
19607: LIST
19608: PUSH
19609: LD_INT 2
19611: NEG
19612: PUSH
19613: LD_INT 2
19615: NEG
19616: PUSH
19617: EMPTY
19618: LIST
19619: LIST
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: LIST
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: LIST
19633: LIST
19634: LIST
19635: LIST
19636: LIST
19637: LIST
19638: LIST
19639: LIST
19640: LIST
19641: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19642: LD_ADDR_VAR 0 19
19646: PUSH
19647: LD_INT 0
19649: PUSH
19650: LD_INT 0
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: PUSH
19657: LD_INT 0
19659: PUSH
19660: LD_INT 1
19662: NEG
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: PUSH
19668: LD_INT 1
19670: PUSH
19671: LD_INT 0
19673: PUSH
19674: EMPTY
19675: LIST
19676: LIST
19677: PUSH
19678: LD_INT 1
19680: PUSH
19681: LD_INT 1
19683: PUSH
19684: EMPTY
19685: LIST
19686: LIST
19687: PUSH
19688: LD_INT 0
19690: PUSH
19691: LD_INT 1
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: PUSH
19698: LD_INT 1
19700: NEG
19701: PUSH
19702: LD_INT 0
19704: PUSH
19705: EMPTY
19706: LIST
19707: LIST
19708: PUSH
19709: LD_INT 1
19711: NEG
19712: PUSH
19713: LD_INT 1
19715: NEG
19716: PUSH
19717: EMPTY
19718: LIST
19719: LIST
19720: PUSH
19721: LD_INT 1
19723: NEG
19724: PUSH
19725: LD_INT 2
19727: NEG
19728: PUSH
19729: EMPTY
19730: LIST
19731: LIST
19732: PUSH
19733: LD_INT 0
19735: PUSH
19736: LD_INT 2
19738: NEG
19739: PUSH
19740: EMPTY
19741: LIST
19742: LIST
19743: PUSH
19744: LD_INT 1
19746: PUSH
19747: LD_INT 1
19749: NEG
19750: PUSH
19751: EMPTY
19752: LIST
19753: LIST
19754: PUSH
19755: LD_INT 2
19757: PUSH
19758: LD_INT 0
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: PUSH
19765: LD_INT 2
19767: PUSH
19768: LD_INT 1
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: PUSH
19775: LD_INT 2
19777: PUSH
19778: LD_INT 2
19780: PUSH
19781: EMPTY
19782: LIST
19783: LIST
19784: PUSH
19785: LD_INT 1
19787: PUSH
19788: LD_INT 2
19790: PUSH
19791: EMPTY
19792: LIST
19793: LIST
19794: PUSH
19795: LD_INT 0
19797: PUSH
19798: LD_INT 2
19800: PUSH
19801: EMPTY
19802: LIST
19803: LIST
19804: PUSH
19805: LD_INT 1
19807: NEG
19808: PUSH
19809: LD_INT 1
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: PUSH
19816: LD_INT 2
19818: NEG
19819: PUSH
19820: LD_INT 0
19822: PUSH
19823: EMPTY
19824: LIST
19825: LIST
19826: PUSH
19827: LD_INT 2
19829: NEG
19830: PUSH
19831: LD_INT 1
19833: NEG
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 2
19841: NEG
19842: PUSH
19843: LD_INT 2
19845: NEG
19846: PUSH
19847: EMPTY
19848: LIST
19849: LIST
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: LIST
19855: LIST
19856: LIST
19857: LIST
19858: LIST
19859: LIST
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19872: LD_ADDR_VAR 0 20
19876: PUSH
19877: LD_INT 0
19879: PUSH
19880: LD_INT 0
19882: PUSH
19883: EMPTY
19884: LIST
19885: LIST
19886: PUSH
19887: LD_INT 0
19889: PUSH
19890: LD_INT 1
19892: NEG
19893: PUSH
19894: EMPTY
19895: LIST
19896: LIST
19897: PUSH
19898: LD_INT 1
19900: PUSH
19901: LD_INT 0
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: LD_INT 1
19910: PUSH
19911: LD_INT 1
19913: PUSH
19914: EMPTY
19915: LIST
19916: LIST
19917: PUSH
19918: LD_INT 0
19920: PUSH
19921: LD_INT 1
19923: PUSH
19924: EMPTY
19925: LIST
19926: LIST
19927: PUSH
19928: LD_INT 1
19930: NEG
19931: PUSH
19932: LD_INT 0
19934: PUSH
19935: EMPTY
19936: LIST
19937: LIST
19938: PUSH
19939: LD_INT 1
19941: NEG
19942: PUSH
19943: LD_INT 1
19945: NEG
19946: PUSH
19947: EMPTY
19948: LIST
19949: LIST
19950: PUSH
19951: LD_INT 1
19953: NEG
19954: PUSH
19955: LD_INT 2
19957: NEG
19958: PUSH
19959: EMPTY
19960: LIST
19961: LIST
19962: PUSH
19963: LD_INT 0
19965: PUSH
19966: LD_INT 2
19968: NEG
19969: PUSH
19970: EMPTY
19971: LIST
19972: LIST
19973: PUSH
19974: LD_INT 1
19976: PUSH
19977: LD_INT 1
19979: NEG
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: PUSH
19985: LD_INT 2
19987: PUSH
19988: LD_INT 0
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: PUSH
19995: LD_INT 2
19997: PUSH
19998: LD_INT 1
20000: PUSH
20001: EMPTY
20002: LIST
20003: LIST
20004: PUSH
20005: LD_INT 2
20007: PUSH
20008: LD_INT 2
20010: PUSH
20011: EMPTY
20012: LIST
20013: LIST
20014: PUSH
20015: LD_INT 1
20017: PUSH
20018: LD_INT 2
20020: PUSH
20021: EMPTY
20022: LIST
20023: LIST
20024: PUSH
20025: LD_INT 0
20027: PUSH
20028: LD_INT 2
20030: PUSH
20031: EMPTY
20032: LIST
20033: LIST
20034: PUSH
20035: LD_INT 1
20037: NEG
20038: PUSH
20039: LD_INT 1
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: PUSH
20046: LD_INT 2
20048: NEG
20049: PUSH
20050: LD_INT 0
20052: PUSH
20053: EMPTY
20054: LIST
20055: LIST
20056: PUSH
20057: LD_INT 2
20059: NEG
20060: PUSH
20061: LD_INT 1
20063: NEG
20064: PUSH
20065: EMPTY
20066: LIST
20067: LIST
20068: PUSH
20069: LD_INT 2
20071: NEG
20072: PUSH
20073: LD_INT 2
20075: NEG
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: LIST
20087: LIST
20088: LIST
20089: LIST
20090: LIST
20091: LIST
20092: LIST
20093: LIST
20094: LIST
20095: LIST
20096: LIST
20097: LIST
20098: LIST
20099: LIST
20100: LIST
20101: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20102: LD_ADDR_VAR 0 21
20106: PUSH
20107: LD_INT 0
20109: PUSH
20110: LD_INT 0
20112: PUSH
20113: EMPTY
20114: LIST
20115: LIST
20116: PUSH
20117: LD_INT 0
20119: PUSH
20120: LD_INT 1
20122: NEG
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: PUSH
20128: LD_INT 1
20130: PUSH
20131: LD_INT 0
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: PUSH
20138: LD_INT 1
20140: PUSH
20141: LD_INT 1
20143: PUSH
20144: EMPTY
20145: LIST
20146: LIST
20147: PUSH
20148: LD_INT 0
20150: PUSH
20151: LD_INT 1
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PUSH
20158: LD_INT 1
20160: NEG
20161: PUSH
20162: LD_INT 0
20164: PUSH
20165: EMPTY
20166: LIST
20167: LIST
20168: PUSH
20169: LD_INT 1
20171: NEG
20172: PUSH
20173: LD_INT 1
20175: NEG
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: PUSH
20181: LD_INT 1
20183: NEG
20184: PUSH
20185: LD_INT 2
20187: NEG
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: PUSH
20193: LD_INT 0
20195: PUSH
20196: LD_INT 2
20198: NEG
20199: PUSH
20200: EMPTY
20201: LIST
20202: LIST
20203: PUSH
20204: LD_INT 1
20206: PUSH
20207: LD_INT 1
20209: NEG
20210: PUSH
20211: EMPTY
20212: LIST
20213: LIST
20214: PUSH
20215: LD_INT 2
20217: PUSH
20218: LD_INT 0
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PUSH
20225: LD_INT 2
20227: PUSH
20228: LD_INT 1
20230: PUSH
20231: EMPTY
20232: LIST
20233: LIST
20234: PUSH
20235: LD_INT 2
20237: PUSH
20238: LD_INT 2
20240: PUSH
20241: EMPTY
20242: LIST
20243: LIST
20244: PUSH
20245: LD_INT 1
20247: PUSH
20248: LD_INT 2
20250: PUSH
20251: EMPTY
20252: LIST
20253: LIST
20254: PUSH
20255: LD_INT 0
20257: PUSH
20258: LD_INT 2
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: PUSH
20265: LD_INT 1
20267: NEG
20268: PUSH
20269: LD_INT 1
20271: PUSH
20272: EMPTY
20273: LIST
20274: LIST
20275: PUSH
20276: LD_INT 2
20278: NEG
20279: PUSH
20280: LD_INT 0
20282: PUSH
20283: EMPTY
20284: LIST
20285: LIST
20286: PUSH
20287: LD_INT 2
20289: NEG
20290: PUSH
20291: LD_INT 1
20293: NEG
20294: PUSH
20295: EMPTY
20296: LIST
20297: LIST
20298: PUSH
20299: LD_INT 2
20301: NEG
20302: PUSH
20303: LD_INT 2
20305: NEG
20306: PUSH
20307: EMPTY
20308: LIST
20309: LIST
20310: PUSH
20311: EMPTY
20312: LIST
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: LIST
20321: LIST
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: LIST
20328: LIST
20329: LIST
20330: LIST
20331: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20332: LD_ADDR_VAR 0 22
20336: PUSH
20337: LD_INT 0
20339: PUSH
20340: LD_INT 0
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: PUSH
20347: LD_INT 0
20349: PUSH
20350: LD_INT 1
20352: NEG
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: PUSH
20358: LD_INT 1
20360: PUSH
20361: LD_INT 0
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: PUSH
20368: LD_INT 1
20370: PUSH
20371: LD_INT 1
20373: PUSH
20374: EMPTY
20375: LIST
20376: LIST
20377: PUSH
20378: LD_INT 0
20380: PUSH
20381: LD_INT 1
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: PUSH
20388: LD_INT 1
20390: NEG
20391: PUSH
20392: LD_INT 0
20394: PUSH
20395: EMPTY
20396: LIST
20397: LIST
20398: PUSH
20399: LD_INT 1
20401: NEG
20402: PUSH
20403: LD_INT 1
20405: NEG
20406: PUSH
20407: EMPTY
20408: LIST
20409: LIST
20410: PUSH
20411: LD_INT 1
20413: NEG
20414: PUSH
20415: LD_INT 2
20417: NEG
20418: PUSH
20419: EMPTY
20420: LIST
20421: LIST
20422: PUSH
20423: LD_INT 0
20425: PUSH
20426: LD_INT 2
20428: NEG
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: PUSH
20434: LD_INT 1
20436: PUSH
20437: LD_INT 1
20439: NEG
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: PUSH
20445: LD_INT 2
20447: PUSH
20448: LD_INT 0
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: PUSH
20455: LD_INT 2
20457: PUSH
20458: LD_INT 1
20460: PUSH
20461: EMPTY
20462: LIST
20463: LIST
20464: PUSH
20465: LD_INT 2
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: EMPTY
20472: LIST
20473: LIST
20474: PUSH
20475: LD_INT 1
20477: PUSH
20478: LD_INT 2
20480: PUSH
20481: EMPTY
20482: LIST
20483: LIST
20484: PUSH
20485: LD_INT 0
20487: PUSH
20488: LD_INT 2
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 1
20497: NEG
20498: PUSH
20499: LD_INT 1
20501: PUSH
20502: EMPTY
20503: LIST
20504: LIST
20505: PUSH
20506: LD_INT 2
20508: NEG
20509: PUSH
20510: LD_INT 0
20512: PUSH
20513: EMPTY
20514: LIST
20515: LIST
20516: PUSH
20517: LD_INT 2
20519: NEG
20520: PUSH
20521: LD_INT 1
20523: NEG
20524: PUSH
20525: EMPTY
20526: LIST
20527: LIST
20528: PUSH
20529: LD_INT 2
20531: NEG
20532: PUSH
20533: LD_INT 2
20535: NEG
20536: PUSH
20537: EMPTY
20538: LIST
20539: LIST
20540: PUSH
20541: EMPTY
20542: LIST
20543: LIST
20544: LIST
20545: LIST
20546: LIST
20547: LIST
20548: LIST
20549: LIST
20550: LIST
20551: LIST
20552: LIST
20553: LIST
20554: LIST
20555: LIST
20556: LIST
20557: LIST
20558: LIST
20559: LIST
20560: LIST
20561: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
20562: LD_ADDR_VAR 0 23
20566: PUSH
20567: LD_INT 0
20569: PUSH
20570: LD_INT 0
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: PUSH
20577: LD_INT 0
20579: PUSH
20580: LD_INT 1
20582: NEG
20583: PUSH
20584: EMPTY
20585: LIST
20586: LIST
20587: PUSH
20588: LD_INT 1
20590: PUSH
20591: LD_INT 0
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: PUSH
20598: LD_INT 1
20600: PUSH
20601: LD_INT 1
20603: PUSH
20604: EMPTY
20605: LIST
20606: LIST
20607: PUSH
20608: LD_INT 0
20610: PUSH
20611: LD_INT 1
20613: PUSH
20614: EMPTY
20615: LIST
20616: LIST
20617: PUSH
20618: LD_INT 1
20620: NEG
20621: PUSH
20622: LD_INT 0
20624: PUSH
20625: EMPTY
20626: LIST
20627: LIST
20628: PUSH
20629: LD_INT 1
20631: NEG
20632: PUSH
20633: LD_INT 1
20635: NEG
20636: PUSH
20637: EMPTY
20638: LIST
20639: LIST
20640: PUSH
20641: LD_INT 1
20643: NEG
20644: PUSH
20645: LD_INT 2
20647: NEG
20648: PUSH
20649: EMPTY
20650: LIST
20651: LIST
20652: PUSH
20653: LD_INT 0
20655: PUSH
20656: LD_INT 2
20658: NEG
20659: PUSH
20660: EMPTY
20661: LIST
20662: LIST
20663: PUSH
20664: LD_INT 1
20666: PUSH
20667: LD_INT 1
20669: NEG
20670: PUSH
20671: EMPTY
20672: LIST
20673: LIST
20674: PUSH
20675: LD_INT 2
20677: PUSH
20678: LD_INT 0
20680: PUSH
20681: EMPTY
20682: LIST
20683: LIST
20684: PUSH
20685: LD_INT 2
20687: PUSH
20688: LD_INT 1
20690: PUSH
20691: EMPTY
20692: LIST
20693: LIST
20694: PUSH
20695: LD_INT 2
20697: PUSH
20698: LD_INT 2
20700: PUSH
20701: EMPTY
20702: LIST
20703: LIST
20704: PUSH
20705: LD_INT 1
20707: PUSH
20708: LD_INT 2
20710: PUSH
20711: EMPTY
20712: LIST
20713: LIST
20714: PUSH
20715: LD_INT 0
20717: PUSH
20718: LD_INT 2
20720: PUSH
20721: EMPTY
20722: LIST
20723: LIST
20724: PUSH
20725: LD_INT 1
20727: NEG
20728: PUSH
20729: LD_INT 1
20731: PUSH
20732: EMPTY
20733: LIST
20734: LIST
20735: PUSH
20736: LD_INT 2
20738: NEG
20739: PUSH
20740: LD_INT 0
20742: PUSH
20743: EMPTY
20744: LIST
20745: LIST
20746: PUSH
20747: LD_INT 2
20749: NEG
20750: PUSH
20751: LD_INT 1
20753: NEG
20754: PUSH
20755: EMPTY
20756: LIST
20757: LIST
20758: PUSH
20759: LD_INT 2
20761: NEG
20762: PUSH
20763: LD_INT 2
20765: NEG
20766: PUSH
20767: EMPTY
20768: LIST
20769: LIST
20770: PUSH
20771: LD_INT 2
20773: NEG
20774: PUSH
20775: LD_INT 3
20777: NEG
20778: PUSH
20779: EMPTY
20780: LIST
20781: LIST
20782: PUSH
20783: LD_INT 1
20785: NEG
20786: PUSH
20787: LD_INT 3
20789: NEG
20790: PUSH
20791: EMPTY
20792: LIST
20793: LIST
20794: PUSH
20795: LD_INT 1
20797: PUSH
20798: LD_INT 2
20800: NEG
20801: PUSH
20802: EMPTY
20803: LIST
20804: LIST
20805: PUSH
20806: LD_INT 2
20808: PUSH
20809: LD_INT 1
20811: NEG
20812: PUSH
20813: EMPTY
20814: LIST
20815: LIST
20816: PUSH
20817: EMPTY
20818: LIST
20819: LIST
20820: LIST
20821: LIST
20822: LIST
20823: LIST
20824: LIST
20825: LIST
20826: LIST
20827: LIST
20828: LIST
20829: LIST
20830: LIST
20831: LIST
20832: LIST
20833: LIST
20834: LIST
20835: LIST
20836: LIST
20837: LIST
20838: LIST
20839: LIST
20840: LIST
20841: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
20842: LD_ADDR_VAR 0 24
20846: PUSH
20847: LD_INT 0
20849: PUSH
20850: LD_INT 0
20852: PUSH
20853: EMPTY
20854: LIST
20855: LIST
20856: PUSH
20857: LD_INT 0
20859: PUSH
20860: LD_INT 1
20862: NEG
20863: PUSH
20864: EMPTY
20865: LIST
20866: LIST
20867: PUSH
20868: LD_INT 1
20870: PUSH
20871: LD_INT 0
20873: PUSH
20874: EMPTY
20875: LIST
20876: LIST
20877: PUSH
20878: LD_INT 1
20880: PUSH
20881: LD_INT 1
20883: PUSH
20884: EMPTY
20885: LIST
20886: LIST
20887: PUSH
20888: LD_INT 0
20890: PUSH
20891: LD_INT 1
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: PUSH
20898: LD_INT 1
20900: NEG
20901: PUSH
20902: LD_INT 0
20904: PUSH
20905: EMPTY
20906: LIST
20907: LIST
20908: PUSH
20909: LD_INT 1
20911: NEG
20912: PUSH
20913: LD_INT 1
20915: NEG
20916: PUSH
20917: EMPTY
20918: LIST
20919: LIST
20920: PUSH
20921: LD_INT 1
20923: NEG
20924: PUSH
20925: LD_INT 2
20927: NEG
20928: PUSH
20929: EMPTY
20930: LIST
20931: LIST
20932: PUSH
20933: LD_INT 0
20935: PUSH
20936: LD_INT 2
20938: NEG
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: PUSH
20944: LD_INT 1
20946: PUSH
20947: LD_INT 1
20949: NEG
20950: PUSH
20951: EMPTY
20952: LIST
20953: LIST
20954: PUSH
20955: LD_INT 2
20957: PUSH
20958: LD_INT 0
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: PUSH
20965: LD_INT 2
20967: PUSH
20968: LD_INT 1
20970: PUSH
20971: EMPTY
20972: LIST
20973: LIST
20974: PUSH
20975: LD_INT 2
20977: PUSH
20978: LD_INT 2
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: PUSH
20985: LD_INT 1
20987: PUSH
20988: LD_INT 2
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: PUSH
20995: LD_INT 0
20997: PUSH
20998: LD_INT 2
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: PUSH
21005: LD_INT 1
21007: NEG
21008: PUSH
21009: LD_INT 1
21011: PUSH
21012: EMPTY
21013: LIST
21014: LIST
21015: PUSH
21016: LD_INT 2
21018: NEG
21019: PUSH
21020: LD_INT 0
21022: PUSH
21023: EMPTY
21024: LIST
21025: LIST
21026: PUSH
21027: LD_INT 2
21029: NEG
21030: PUSH
21031: LD_INT 1
21033: NEG
21034: PUSH
21035: EMPTY
21036: LIST
21037: LIST
21038: PUSH
21039: LD_INT 2
21041: NEG
21042: PUSH
21043: LD_INT 2
21045: NEG
21046: PUSH
21047: EMPTY
21048: LIST
21049: LIST
21050: PUSH
21051: LD_INT 1
21053: PUSH
21054: LD_INT 2
21056: NEG
21057: PUSH
21058: EMPTY
21059: LIST
21060: LIST
21061: PUSH
21062: LD_INT 2
21064: PUSH
21065: LD_INT 1
21067: NEG
21068: PUSH
21069: EMPTY
21070: LIST
21071: LIST
21072: PUSH
21073: LD_INT 3
21075: PUSH
21076: LD_INT 1
21078: PUSH
21079: EMPTY
21080: LIST
21081: LIST
21082: PUSH
21083: LD_INT 3
21085: PUSH
21086: LD_INT 2
21088: PUSH
21089: EMPTY
21090: LIST
21091: LIST
21092: PUSH
21093: EMPTY
21094: LIST
21095: LIST
21096: LIST
21097: LIST
21098: LIST
21099: LIST
21100: LIST
21101: LIST
21102: LIST
21103: LIST
21104: LIST
21105: LIST
21106: LIST
21107: LIST
21108: LIST
21109: LIST
21110: LIST
21111: LIST
21112: LIST
21113: LIST
21114: LIST
21115: LIST
21116: LIST
21117: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
21118: LD_ADDR_VAR 0 25
21122: PUSH
21123: LD_INT 0
21125: PUSH
21126: LD_INT 0
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: PUSH
21133: LD_INT 0
21135: PUSH
21136: LD_INT 1
21138: NEG
21139: PUSH
21140: EMPTY
21141: LIST
21142: LIST
21143: PUSH
21144: LD_INT 1
21146: PUSH
21147: LD_INT 0
21149: PUSH
21150: EMPTY
21151: LIST
21152: LIST
21153: PUSH
21154: LD_INT 1
21156: PUSH
21157: LD_INT 1
21159: PUSH
21160: EMPTY
21161: LIST
21162: LIST
21163: PUSH
21164: LD_INT 0
21166: PUSH
21167: LD_INT 1
21169: PUSH
21170: EMPTY
21171: LIST
21172: LIST
21173: PUSH
21174: LD_INT 1
21176: NEG
21177: PUSH
21178: LD_INT 0
21180: PUSH
21181: EMPTY
21182: LIST
21183: LIST
21184: PUSH
21185: LD_INT 1
21187: NEG
21188: PUSH
21189: LD_INT 1
21191: NEG
21192: PUSH
21193: EMPTY
21194: LIST
21195: LIST
21196: PUSH
21197: LD_INT 1
21199: NEG
21200: PUSH
21201: LD_INT 2
21203: NEG
21204: PUSH
21205: EMPTY
21206: LIST
21207: LIST
21208: PUSH
21209: LD_INT 0
21211: PUSH
21212: LD_INT 2
21214: NEG
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: PUSH
21220: LD_INT 1
21222: PUSH
21223: LD_INT 1
21225: NEG
21226: PUSH
21227: EMPTY
21228: LIST
21229: LIST
21230: PUSH
21231: LD_INT 2
21233: PUSH
21234: LD_INT 0
21236: PUSH
21237: EMPTY
21238: LIST
21239: LIST
21240: PUSH
21241: LD_INT 2
21243: PUSH
21244: LD_INT 1
21246: PUSH
21247: EMPTY
21248: LIST
21249: LIST
21250: PUSH
21251: LD_INT 2
21253: PUSH
21254: LD_INT 2
21256: PUSH
21257: EMPTY
21258: LIST
21259: LIST
21260: PUSH
21261: LD_INT 1
21263: PUSH
21264: LD_INT 2
21266: PUSH
21267: EMPTY
21268: LIST
21269: LIST
21270: PUSH
21271: LD_INT 0
21273: PUSH
21274: LD_INT 2
21276: PUSH
21277: EMPTY
21278: LIST
21279: LIST
21280: PUSH
21281: LD_INT 1
21283: NEG
21284: PUSH
21285: LD_INT 1
21287: PUSH
21288: EMPTY
21289: LIST
21290: LIST
21291: PUSH
21292: LD_INT 2
21294: NEG
21295: PUSH
21296: LD_INT 0
21298: PUSH
21299: EMPTY
21300: LIST
21301: LIST
21302: PUSH
21303: LD_INT 2
21305: NEG
21306: PUSH
21307: LD_INT 1
21309: NEG
21310: PUSH
21311: EMPTY
21312: LIST
21313: LIST
21314: PUSH
21315: LD_INT 2
21317: NEG
21318: PUSH
21319: LD_INT 2
21321: NEG
21322: PUSH
21323: EMPTY
21324: LIST
21325: LIST
21326: PUSH
21327: LD_INT 3
21329: PUSH
21330: LD_INT 1
21332: PUSH
21333: EMPTY
21334: LIST
21335: LIST
21336: PUSH
21337: LD_INT 3
21339: PUSH
21340: LD_INT 2
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: PUSH
21347: LD_INT 2
21349: PUSH
21350: LD_INT 3
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: PUSH
21357: LD_INT 1
21359: PUSH
21360: LD_INT 3
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: LIST
21371: LIST
21372: LIST
21373: LIST
21374: LIST
21375: LIST
21376: LIST
21377: LIST
21378: LIST
21379: LIST
21380: LIST
21381: LIST
21382: LIST
21383: LIST
21384: LIST
21385: LIST
21386: LIST
21387: LIST
21388: LIST
21389: LIST
21390: LIST
21391: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
21392: LD_ADDR_VAR 0 26
21396: PUSH
21397: LD_INT 0
21399: PUSH
21400: LD_INT 0
21402: PUSH
21403: EMPTY
21404: LIST
21405: LIST
21406: PUSH
21407: LD_INT 0
21409: PUSH
21410: LD_INT 1
21412: NEG
21413: PUSH
21414: EMPTY
21415: LIST
21416: LIST
21417: PUSH
21418: LD_INT 1
21420: PUSH
21421: LD_INT 0
21423: PUSH
21424: EMPTY
21425: LIST
21426: LIST
21427: PUSH
21428: LD_INT 1
21430: PUSH
21431: LD_INT 1
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: PUSH
21438: LD_INT 0
21440: PUSH
21441: LD_INT 1
21443: PUSH
21444: EMPTY
21445: LIST
21446: LIST
21447: PUSH
21448: LD_INT 1
21450: NEG
21451: PUSH
21452: LD_INT 0
21454: PUSH
21455: EMPTY
21456: LIST
21457: LIST
21458: PUSH
21459: LD_INT 1
21461: NEG
21462: PUSH
21463: LD_INT 1
21465: NEG
21466: PUSH
21467: EMPTY
21468: LIST
21469: LIST
21470: PUSH
21471: LD_INT 1
21473: NEG
21474: PUSH
21475: LD_INT 2
21477: NEG
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: PUSH
21483: LD_INT 0
21485: PUSH
21486: LD_INT 2
21488: NEG
21489: PUSH
21490: EMPTY
21491: LIST
21492: LIST
21493: PUSH
21494: LD_INT 1
21496: PUSH
21497: LD_INT 1
21499: NEG
21500: PUSH
21501: EMPTY
21502: LIST
21503: LIST
21504: PUSH
21505: LD_INT 2
21507: PUSH
21508: LD_INT 0
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: PUSH
21515: LD_INT 2
21517: PUSH
21518: LD_INT 1
21520: PUSH
21521: EMPTY
21522: LIST
21523: LIST
21524: PUSH
21525: LD_INT 2
21527: PUSH
21528: LD_INT 2
21530: PUSH
21531: EMPTY
21532: LIST
21533: LIST
21534: PUSH
21535: LD_INT 1
21537: PUSH
21538: LD_INT 2
21540: PUSH
21541: EMPTY
21542: LIST
21543: LIST
21544: PUSH
21545: LD_INT 0
21547: PUSH
21548: LD_INT 2
21550: PUSH
21551: EMPTY
21552: LIST
21553: LIST
21554: PUSH
21555: LD_INT 1
21557: NEG
21558: PUSH
21559: LD_INT 1
21561: PUSH
21562: EMPTY
21563: LIST
21564: LIST
21565: PUSH
21566: LD_INT 2
21568: NEG
21569: PUSH
21570: LD_INT 0
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: PUSH
21577: LD_INT 2
21579: NEG
21580: PUSH
21581: LD_INT 1
21583: NEG
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: PUSH
21589: LD_INT 2
21591: NEG
21592: PUSH
21593: LD_INT 2
21595: NEG
21596: PUSH
21597: EMPTY
21598: LIST
21599: LIST
21600: PUSH
21601: LD_INT 2
21603: PUSH
21604: LD_INT 3
21606: PUSH
21607: EMPTY
21608: LIST
21609: LIST
21610: PUSH
21611: LD_INT 1
21613: PUSH
21614: LD_INT 3
21616: PUSH
21617: EMPTY
21618: LIST
21619: LIST
21620: PUSH
21621: LD_INT 1
21623: NEG
21624: PUSH
21625: LD_INT 2
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: PUSH
21632: LD_INT 2
21634: NEG
21635: PUSH
21636: LD_INT 1
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: LIST
21648: LIST
21649: LIST
21650: LIST
21651: LIST
21652: LIST
21653: LIST
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: LIST
21665: LIST
21666: LIST
21667: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
21668: LD_ADDR_VAR 0 27
21672: PUSH
21673: LD_INT 0
21675: PUSH
21676: LD_INT 0
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: PUSH
21683: LD_INT 0
21685: PUSH
21686: LD_INT 1
21688: NEG
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: LD_INT 1
21696: PUSH
21697: LD_INT 0
21699: PUSH
21700: EMPTY
21701: LIST
21702: LIST
21703: PUSH
21704: LD_INT 1
21706: PUSH
21707: LD_INT 1
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: PUSH
21714: LD_INT 0
21716: PUSH
21717: LD_INT 1
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: PUSH
21724: LD_INT 1
21726: NEG
21727: PUSH
21728: LD_INT 0
21730: PUSH
21731: EMPTY
21732: LIST
21733: LIST
21734: PUSH
21735: LD_INT 1
21737: NEG
21738: PUSH
21739: LD_INT 1
21741: NEG
21742: PUSH
21743: EMPTY
21744: LIST
21745: LIST
21746: PUSH
21747: LD_INT 1
21749: NEG
21750: PUSH
21751: LD_INT 2
21753: NEG
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: PUSH
21759: LD_INT 0
21761: PUSH
21762: LD_INT 2
21764: NEG
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: PUSH
21770: LD_INT 1
21772: PUSH
21773: LD_INT 1
21775: NEG
21776: PUSH
21777: EMPTY
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 2
21783: PUSH
21784: LD_INT 0
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: PUSH
21791: LD_INT 2
21793: PUSH
21794: LD_INT 1
21796: PUSH
21797: EMPTY
21798: LIST
21799: LIST
21800: PUSH
21801: LD_INT 2
21803: PUSH
21804: LD_INT 2
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: PUSH
21811: LD_INT 1
21813: PUSH
21814: LD_INT 2
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: PUSH
21821: LD_INT 0
21823: PUSH
21824: LD_INT 2
21826: PUSH
21827: EMPTY
21828: LIST
21829: LIST
21830: PUSH
21831: LD_INT 1
21833: NEG
21834: PUSH
21835: LD_INT 1
21837: PUSH
21838: EMPTY
21839: LIST
21840: LIST
21841: PUSH
21842: LD_INT 2
21844: NEG
21845: PUSH
21846: LD_INT 0
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: PUSH
21853: LD_INT 2
21855: NEG
21856: PUSH
21857: LD_INT 1
21859: NEG
21860: PUSH
21861: EMPTY
21862: LIST
21863: LIST
21864: PUSH
21865: LD_INT 2
21867: NEG
21868: PUSH
21869: LD_INT 2
21871: NEG
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: PUSH
21877: LD_INT 1
21879: NEG
21880: PUSH
21881: LD_INT 2
21883: PUSH
21884: EMPTY
21885: LIST
21886: LIST
21887: PUSH
21888: LD_INT 2
21890: NEG
21891: PUSH
21892: LD_INT 1
21894: PUSH
21895: EMPTY
21896: LIST
21897: LIST
21898: PUSH
21899: LD_INT 3
21901: NEG
21902: PUSH
21903: LD_INT 1
21905: NEG
21906: PUSH
21907: EMPTY
21908: LIST
21909: LIST
21910: PUSH
21911: LD_INT 3
21913: NEG
21914: PUSH
21915: LD_INT 2
21917: NEG
21918: PUSH
21919: EMPTY
21920: LIST
21921: LIST
21922: PUSH
21923: EMPTY
21924: LIST
21925: LIST
21926: LIST
21927: LIST
21928: LIST
21929: LIST
21930: LIST
21931: LIST
21932: LIST
21933: LIST
21934: LIST
21935: LIST
21936: LIST
21937: LIST
21938: LIST
21939: LIST
21940: LIST
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
21948: LD_ADDR_VAR 0 28
21952: PUSH
21953: LD_INT 0
21955: PUSH
21956: LD_INT 0
21958: PUSH
21959: EMPTY
21960: LIST
21961: LIST
21962: PUSH
21963: LD_INT 0
21965: PUSH
21966: LD_INT 1
21968: NEG
21969: PUSH
21970: EMPTY
21971: LIST
21972: LIST
21973: PUSH
21974: LD_INT 1
21976: PUSH
21977: LD_INT 0
21979: PUSH
21980: EMPTY
21981: LIST
21982: LIST
21983: PUSH
21984: LD_INT 1
21986: PUSH
21987: LD_INT 1
21989: PUSH
21990: EMPTY
21991: LIST
21992: LIST
21993: PUSH
21994: LD_INT 0
21996: PUSH
21997: LD_INT 1
21999: PUSH
22000: EMPTY
22001: LIST
22002: LIST
22003: PUSH
22004: LD_INT 1
22006: NEG
22007: PUSH
22008: LD_INT 0
22010: PUSH
22011: EMPTY
22012: LIST
22013: LIST
22014: PUSH
22015: LD_INT 1
22017: NEG
22018: PUSH
22019: LD_INT 1
22021: NEG
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: PUSH
22027: LD_INT 1
22029: NEG
22030: PUSH
22031: LD_INT 2
22033: NEG
22034: PUSH
22035: EMPTY
22036: LIST
22037: LIST
22038: PUSH
22039: LD_INT 0
22041: PUSH
22042: LD_INT 2
22044: NEG
22045: PUSH
22046: EMPTY
22047: LIST
22048: LIST
22049: PUSH
22050: LD_INT 1
22052: PUSH
22053: LD_INT 1
22055: NEG
22056: PUSH
22057: EMPTY
22058: LIST
22059: LIST
22060: PUSH
22061: LD_INT 2
22063: PUSH
22064: LD_INT 0
22066: PUSH
22067: EMPTY
22068: LIST
22069: LIST
22070: PUSH
22071: LD_INT 2
22073: PUSH
22074: LD_INT 1
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: PUSH
22081: LD_INT 2
22083: PUSH
22084: LD_INT 2
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 1
22093: PUSH
22094: LD_INT 2
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: LD_INT 0
22103: PUSH
22104: LD_INT 2
22106: PUSH
22107: EMPTY
22108: LIST
22109: LIST
22110: PUSH
22111: LD_INT 1
22113: NEG
22114: PUSH
22115: LD_INT 1
22117: PUSH
22118: EMPTY
22119: LIST
22120: LIST
22121: PUSH
22122: LD_INT 2
22124: NEG
22125: PUSH
22126: LD_INT 0
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: PUSH
22133: LD_INT 2
22135: NEG
22136: PUSH
22137: LD_INT 1
22139: NEG
22140: PUSH
22141: EMPTY
22142: LIST
22143: LIST
22144: PUSH
22145: LD_INT 2
22147: NEG
22148: PUSH
22149: LD_INT 2
22151: NEG
22152: PUSH
22153: EMPTY
22154: LIST
22155: LIST
22156: PUSH
22157: LD_INT 2
22159: NEG
22160: PUSH
22161: LD_INT 3
22163: NEG
22164: PUSH
22165: EMPTY
22166: LIST
22167: LIST
22168: PUSH
22169: LD_INT 1
22171: NEG
22172: PUSH
22173: LD_INT 3
22175: NEG
22176: PUSH
22177: EMPTY
22178: LIST
22179: LIST
22180: PUSH
22181: LD_INT 3
22183: NEG
22184: PUSH
22185: LD_INT 1
22187: NEG
22188: PUSH
22189: EMPTY
22190: LIST
22191: LIST
22192: PUSH
22193: LD_INT 3
22195: NEG
22196: PUSH
22197: LD_INT 2
22199: NEG
22200: PUSH
22201: EMPTY
22202: LIST
22203: LIST
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: LIST
22209: LIST
22210: LIST
22211: LIST
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: LIST
22217: LIST
22218: LIST
22219: LIST
22220: LIST
22221: LIST
22222: LIST
22223: LIST
22224: LIST
22225: LIST
22226: LIST
22227: LIST
22228: LIST
22229: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
22230: LD_ADDR_VAR 0 29
22234: PUSH
22235: LD_INT 0
22237: PUSH
22238: LD_INT 0
22240: PUSH
22241: EMPTY
22242: LIST
22243: LIST
22244: PUSH
22245: LD_INT 0
22247: PUSH
22248: LD_INT 1
22250: NEG
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PUSH
22256: LD_INT 1
22258: PUSH
22259: LD_INT 0
22261: PUSH
22262: EMPTY
22263: LIST
22264: LIST
22265: PUSH
22266: LD_INT 1
22268: PUSH
22269: LD_INT 1
22271: PUSH
22272: EMPTY
22273: LIST
22274: LIST
22275: PUSH
22276: LD_INT 0
22278: PUSH
22279: LD_INT 1
22281: PUSH
22282: EMPTY
22283: LIST
22284: LIST
22285: PUSH
22286: LD_INT 1
22288: NEG
22289: PUSH
22290: LD_INT 0
22292: PUSH
22293: EMPTY
22294: LIST
22295: LIST
22296: PUSH
22297: LD_INT 1
22299: NEG
22300: PUSH
22301: LD_INT 1
22303: NEG
22304: PUSH
22305: EMPTY
22306: LIST
22307: LIST
22308: PUSH
22309: LD_INT 1
22311: NEG
22312: PUSH
22313: LD_INT 2
22315: NEG
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: PUSH
22321: LD_INT 0
22323: PUSH
22324: LD_INT 2
22326: NEG
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: PUSH
22332: LD_INT 1
22334: PUSH
22335: LD_INT 1
22337: NEG
22338: PUSH
22339: EMPTY
22340: LIST
22341: LIST
22342: PUSH
22343: LD_INT 2
22345: PUSH
22346: LD_INT 0
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: PUSH
22353: LD_INT 2
22355: PUSH
22356: LD_INT 1
22358: PUSH
22359: EMPTY
22360: LIST
22361: LIST
22362: PUSH
22363: LD_INT 1
22365: PUSH
22366: LD_INT 2
22368: PUSH
22369: EMPTY
22370: LIST
22371: LIST
22372: PUSH
22373: LD_INT 0
22375: PUSH
22376: LD_INT 2
22378: PUSH
22379: EMPTY
22380: LIST
22381: LIST
22382: PUSH
22383: LD_INT 1
22385: NEG
22386: PUSH
22387: LD_INT 1
22389: PUSH
22390: EMPTY
22391: LIST
22392: LIST
22393: PUSH
22394: LD_INT 2
22396: NEG
22397: PUSH
22398: LD_INT 1
22400: NEG
22401: PUSH
22402: EMPTY
22403: LIST
22404: LIST
22405: PUSH
22406: LD_INT 2
22408: NEG
22409: PUSH
22410: LD_INT 2
22412: NEG
22413: PUSH
22414: EMPTY
22415: LIST
22416: LIST
22417: PUSH
22418: LD_INT 2
22420: NEG
22421: PUSH
22422: LD_INT 3
22424: NEG
22425: PUSH
22426: EMPTY
22427: LIST
22428: LIST
22429: PUSH
22430: LD_INT 2
22432: PUSH
22433: LD_INT 1
22435: NEG
22436: PUSH
22437: EMPTY
22438: LIST
22439: LIST
22440: PUSH
22441: LD_INT 3
22443: PUSH
22444: LD_INT 1
22446: PUSH
22447: EMPTY
22448: LIST
22449: LIST
22450: PUSH
22451: LD_INT 1
22453: PUSH
22454: LD_INT 3
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: PUSH
22461: LD_INT 1
22463: NEG
22464: PUSH
22465: LD_INT 2
22467: PUSH
22468: EMPTY
22469: LIST
22470: LIST
22471: PUSH
22472: LD_INT 3
22474: NEG
22475: PUSH
22476: LD_INT 2
22478: NEG
22479: PUSH
22480: EMPTY
22481: LIST
22482: LIST
22483: PUSH
22484: EMPTY
22485: LIST
22486: LIST
22487: LIST
22488: LIST
22489: LIST
22490: LIST
22491: LIST
22492: LIST
22493: LIST
22494: LIST
22495: LIST
22496: LIST
22497: LIST
22498: LIST
22499: LIST
22500: LIST
22501: LIST
22502: LIST
22503: LIST
22504: LIST
22505: LIST
22506: LIST
22507: LIST
22508: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
22509: LD_ADDR_VAR 0 30
22513: PUSH
22514: LD_INT 0
22516: PUSH
22517: LD_INT 0
22519: PUSH
22520: EMPTY
22521: LIST
22522: LIST
22523: PUSH
22524: LD_INT 0
22526: PUSH
22527: LD_INT 1
22529: NEG
22530: PUSH
22531: EMPTY
22532: LIST
22533: LIST
22534: PUSH
22535: LD_INT 1
22537: PUSH
22538: LD_INT 0
22540: PUSH
22541: EMPTY
22542: LIST
22543: LIST
22544: PUSH
22545: LD_INT 1
22547: PUSH
22548: LD_INT 1
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: LD_INT 0
22557: PUSH
22558: LD_INT 1
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PUSH
22565: LD_INT 1
22567: NEG
22568: PUSH
22569: LD_INT 0
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: PUSH
22576: LD_INT 1
22578: NEG
22579: PUSH
22580: LD_INT 1
22582: NEG
22583: PUSH
22584: EMPTY
22585: LIST
22586: LIST
22587: PUSH
22588: LD_INT 1
22590: NEG
22591: PUSH
22592: LD_INT 2
22594: NEG
22595: PUSH
22596: EMPTY
22597: LIST
22598: LIST
22599: PUSH
22600: LD_INT 0
22602: PUSH
22603: LD_INT 2
22605: NEG
22606: PUSH
22607: EMPTY
22608: LIST
22609: LIST
22610: PUSH
22611: LD_INT 1
22613: PUSH
22614: LD_INT 1
22616: NEG
22617: PUSH
22618: EMPTY
22619: LIST
22620: LIST
22621: PUSH
22622: LD_INT 2
22624: PUSH
22625: LD_INT 0
22627: PUSH
22628: EMPTY
22629: LIST
22630: LIST
22631: PUSH
22632: LD_INT 2
22634: PUSH
22635: LD_INT 1
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: PUSH
22642: LD_INT 2
22644: PUSH
22645: LD_INT 2
22647: PUSH
22648: EMPTY
22649: LIST
22650: LIST
22651: PUSH
22652: LD_INT 1
22654: PUSH
22655: LD_INT 2
22657: PUSH
22658: EMPTY
22659: LIST
22660: LIST
22661: PUSH
22662: LD_INT 1
22664: NEG
22665: PUSH
22666: LD_INT 1
22668: PUSH
22669: EMPTY
22670: LIST
22671: LIST
22672: PUSH
22673: LD_INT 2
22675: NEG
22676: PUSH
22677: LD_INT 0
22679: PUSH
22680: EMPTY
22681: LIST
22682: LIST
22683: PUSH
22684: LD_INT 2
22686: NEG
22687: PUSH
22688: LD_INT 1
22690: NEG
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: PUSH
22696: LD_INT 1
22698: NEG
22699: PUSH
22700: LD_INT 3
22702: NEG
22703: PUSH
22704: EMPTY
22705: LIST
22706: LIST
22707: PUSH
22708: LD_INT 1
22710: PUSH
22711: LD_INT 2
22713: NEG
22714: PUSH
22715: EMPTY
22716: LIST
22717: LIST
22718: PUSH
22719: LD_INT 3
22721: PUSH
22722: LD_INT 2
22724: PUSH
22725: EMPTY
22726: LIST
22727: LIST
22728: PUSH
22729: LD_INT 2
22731: PUSH
22732: LD_INT 3
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: PUSH
22739: LD_INT 2
22741: NEG
22742: PUSH
22743: LD_INT 1
22745: PUSH
22746: EMPTY
22747: LIST
22748: LIST
22749: PUSH
22750: LD_INT 3
22752: NEG
22753: PUSH
22754: LD_INT 1
22756: NEG
22757: PUSH
22758: EMPTY
22759: LIST
22760: LIST
22761: PUSH
22762: EMPTY
22763: LIST
22764: LIST
22765: LIST
22766: LIST
22767: LIST
22768: LIST
22769: LIST
22770: LIST
22771: LIST
22772: LIST
22773: LIST
22774: LIST
22775: LIST
22776: LIST
22777: LIST
22778: LIST
22779: LIST
22780: LIST
22781: LIST
22782: LIST
22783: LIST
22784: LIST
22785: LIST
22786: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
22787: LD_ADDR_VAR 0 31
22791: PUSH
22792: LD_INT 0
22794: PUSH
22795: LD_INT 0
22797: PUSH
22798: EMPTY
22799: LIST
22800: LIST
22801: PUSH
22802: LD_INT 0
22804: PUSH
22805: LD_INT 1
22807: NEG
22808: PUSH
22809: EMPTY
22810: LIST
22811: LIST
22812: PUSH
22813: LD_INT 1
22815: PUSH
22816: LD_INT 0
22818: PUSH
22819: EMPTY
22820: LIST
22821: LIST
22822: PUSH
22823: LD_INT 1
22825: PUSH
22826: LD_INT 1
22828: PUSH
22829: EMPTY
22830: LIST
22831: LIST
22832: PUSH
22833: LD_INT 0
22835: PUSH
22836: LD_INT 1
22838: PUSH
22839: EMPTY
22840: LIST
22841: LIST
22842: PUSH
22843: LD_INT 1
22845: NEG
22846: PUSH
22847: LD_INT 0
22849: PUSH
22850: EMPTY
22851: LIST
22852: LIST
22853: PUSH
22854: LD_INT 1
22856: NEG
22857: PUSH
22858: LD_INT 1
22860: NEG
22861: PUSH
22862: EMPTY
22863: LIST
22864: LIST
22865: PUSH
22866: LD_INT 1
22868: NEG
22869: PUSH
22870: LD_INT 2
22872: NEG
22873: PUSH
22874: EMPTY
22875: LIST
22876: LIST
22877: PUSH
22878: LD_INT 1
22880: PUSH
22881: LD_INT 1
22883: NEG
22884: PUSH
22885: EMPTY
22886: LIST
22887: LIST
22888: PUSH
22889: LD_INT 2
22891: PUSH
22892: LD_INT 0
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: LD_INT 2
22901: PUSH
22902: LD_INT 1
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: LD_INT 2
22911: PUSH
22912: LD_INT 2
22914: PUSH
22915: EMPTY
22916: LIST
22917: LIST
22918: PUSH
22919: LD_INT 1
22921: PUSH
22922: LD_INT 2
22924: PUSH
22925: EMPTY
22926: LIST
22927: LIST
22928: PUSH
22929: LD_INT 0
22931: PUSH
22932: LD_INT 2
22934: PUSH
22935: EMPTY
22936: LIST
22937: LIST
22938: PUSH
22939: LD_INT 1
22941: NEG
22942: PUSH
22943: LD_INT 1
22945: PUSH
22946: EMPTY
22947: LIST
22948: LIST
22949: PUSH
22950: LD_INT 2
22952: NEG
22953: PUSH
22954: LD_INT 1
22956: NEG
22957: PUSH
22958: EMPTY
22959: LIST
22960: LIST
22961: PUSH
22962: LD_INT 2
22964: NEG
22965: PUSH
22966: LD_INT 2
22968: NEG
22969: PUSH
22970: EMPTY
22971: LIST
22972: LIST
22973: PUSH
22974: LD_INT 2
22976: NEG
22977: PUSH
22978: LD_INT 3
22980: NEG
22981: PUSH
22982: EMPTY
22983: LIST
22984: LIST
22985: PUSH
22986: LD_INT 2
22988: PUSH
22989: LD_INT 1
22991: NEG
22992: PUSH
22993: EMPTY
22994: LIST
22995: LIST
22996: PUSH
22997: LD_INT 3
22999: PUSH
23000: LD_INT 1
23002: PUSH
23003: EMPTY
23004: LIST
23005: LIST
23006: PUSH
23007: LD_INT 1
23009: PUSH
23010: LD_INT 3
23012: PUSH
23013: EMPTY
23014: LIST
23015: LIST
23016: PUSH
23017: LD_INT 1
23019: NEG
23020: PUSH
23021: LD_INT 2
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 3
23030: NEG
23031: PUSH
23032: LD_INT 2
23034: NEG
23035: PUSH
23036: EMPTY
23037: LIST
23038: LIST
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: LIST
23044: LIST
23045: LIST
23046: LIST
23047: LIST
23048: LIST
23049: LIST
23050: LIST
23051: LIST
23052: LIST
23053: LIST
23054: LIST
23055: LIST
23056: LIST
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: LIST
23062: LIST
23063: LIST
23064: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23065: LD_ADDR_VAR 0 32
23069: PUSH
23070: LD_INT 0
23072: PUSH
23073: LD_INT 0
23075: PUSH
23076: EMPTY
23077: LIST
23078: LIST
23079: PUSH
23080: LD_INT 0
23082: PUSH
23083: LD_INT 1
23085: NEG
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: PUSH
23091: LD_INT 1
23093: PUSH
23094: LD_INT 0
23096: PUSH
23097: EMPTY
23098: LIST
23099: LIST
23100: PUSH
23101: LD_INT 1
23103: PUSH
23104: LD_INT 1
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: PUSH
23111: LD_INT 0
23113: PUSH
23114: LD_INT 1
23116: PUSH
23117: EMPTY
23118: LIST
23119: LIST
23120: PUSH
23121: LD_INT 1
23123: NEG
23124: PUSH
23125: LD_INT 0
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: PUSH
23132: LD_INT 1
23134: NEG
23135: PUSH
23136: LD_INT 1
23138: NEG
23139: PUSH
23140: EMPTY
23141: LIST
23142: LIST
23143: PUSH
23144: LD_INT 1
23146: NEG
23147: PUSH
23148: LD_INT 2
23150: NEG
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: PUSH
23156: LD_INT 0
23158: PUSH
23159: LD_INT 2
23161: NEG
23162: PUSH
23163: EMPTY
23164: LIST
23165: LIST
23166: PUSH
23167: LD_INT 1
23169: PUSH
23170: LD_INT 1
23172: NEG
23173: PUSH
23174: EMPTY
23175: LIST
23176: LIST
23177: PUSH
23178: LD_INT 2
23180: PUSH
23181: LD_INT 1
23183: PUSH
23184: EMPTY
23185: LIST
23186: LIST
23187: PUSH
23188: LD_INT 2
23190: PUSH
23191: LD_INT 2
23193: PUSH
23194: EMPTY
23195: LIST
23196: LIST
23197: PUSH
23198: LD_INT 1
23200: PUSH
23201: LD_INT 2
23203: PUSH
23204: EMPTY
23205: LIST
23206: LIST
23207: PUSH
23208: LD_INT 0
23210: PUSH
23211: LD_INT 2
23213: PUSH
23214: EMPTY
23215: LIST
23216: LIST
23217: PUSH
23218: LD_INT 1
23220: NEG
23221: PUSH
23222: LD_INT 1
23224: PUSH
23225: EMPTY
23226: LIST
23227: LIST
23228: PUSH
23229: LD_INT 2
23231: NEG
23232: PUSH
23233: LD_INT 0
23235: PUSH
23236: EMPTY
23237: LIST
23238: LIST
23239: PUSH
23240: LD_INT 2
23242: NEG
23243: PUSH
23244: LD_INT 1
23246: NEG
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: PUSH
23252: LD_INT 1
23254: NEG
23255: PUSH
23256: LD_INT 3
23258: NEG
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: PUSH
23264: LD_INT 1
23266: PUSH
23267: LD_INT 2
23269: NEG
23270: PUSH
23271: EMPTY
23272: LIST
23273: LIST
23274: PUSH
23275: LD_INT 3
23277: PUSH
23278: LD_INT 2
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: PUSH
23285: LD_INT 2
23287: PUSH
23288: LD_INT 3
23290: PUSH
23291: EMPTY
23292: LIST
23293: LIST
23294: PUSH
23295: LD_INT 2
23297: NEG
23298: PUSH
23299: LD_INT 1
23301: PUSH
23302: EMPTY
23303: LIST
23304: LIST
23305: PUSH
23306: LD_INT 3
23308: NEG
23309: PUSH
23310: LD_INT 1
23312: NEG
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: EMPTY
23319: LIST
23320: LIST
23321: LIST
23322: LIST
23323: LIST
23324: LIST
23325: LIST
23326: LIST
23327: LIST
23328: LIST
23329: LIST
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: LIST
23337: LIST
23338: LIST
23339: LIST
23340: LIST
23341: LIST
23342: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
23343: LD_ADDR_VAR 0 33
23347: PUSH
23348: LD_INT 0
23350: PUSH
23351: LD_INT 0
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PUSH
23358: LD_INT 0
23360: PUSH
23361: LD_INT 1
23363: NEG
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: LD_INT 1
23371: PUSH
23372: LD_INT 0
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PUSH
23379: LD_INT 1
23381: PUSH
23382: LD_INT 1
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: PUSH
23389: LD_INT 0
23391: PUSH
23392: LD_INT 1
23394: PUSH
23395: EMPTY
23396: LIST
23397: LIST
23398: PUSH
23399: LD_INT 1
23401: NEG
23402: PUSH
23403: LD_INT 0
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: PUSH
23410: LD_INT 1
23412: NEG
23413: PUSH
23414: LD_INT 1
23416: NEG
23417: PUSH
23418: EMPTY
23419: LIST
23420: LIST
23421: PUSH
23422: LD_INT 1
23424: NEG
23425: PUSH
23426: LD_INT 2
23428: NEG
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 1
23436: PUSH
23437: LD_INT 1
23439: NEG
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: LD_INT 2
23447: PUSH
23448: LD_INT 0
23450: PUSH
23451: EMPTY
23452: LIST
23453: LIST
23454: PUSH
23455: LD_INT 2
23457: PUSH
23458: LD_INT 1
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 1
23467: PUSH
23468: LD_INT 2
23470: PUSH
23471: EMPTY
23472: LIST
23473: LIST
23474: PUSH
23475: LD_INT 0
23477: PUSH
23478: LD_INT 2
23480: PUSH
23481: EMPTY
23482: LIST
23483: LIST
23484: PUSH
23485: LD_INT 1
23487: NEG
23488: PUSH
23489: LD_INT 1
23491: PUSH
23492: EMPTY
23493: LIST
23494: LIST
23495: PUSH
23496: LD_INT 2
23498: NEG
23499: PUSH
23500: LD_INT 0
23502: PUSH
23503: EMPTY
23504: LIST
23505: LIST
23506: PUSH
23507: LD_INT 2
23509: NEG
23510: PUSH
23511: LD_INT 1
23513: NEG
23514: PUSH
23515: EMPTY
23516: LIST
23517: LIST
23518: PUSH
23519: LD_INT 2
23521: NEG
23522: PUSH
23523: LD_INT 2
23525: NEG
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: PUSH
23531: LD_INT 2
23533: NEG
23534: PUSH
23535: LD_INT 3
23537: NEG
23538: PUSH
23539: EMPTY
23540: LIST
23541: LIST
23542: PUSH
23543: LD_INT 2
23545: PUSH
23546: LD_INT 1
23548: NEG
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PUSH
23554: LD_INT 3
23556: PUSH
23557: LD_INT 1
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: LD_INT 1
23566: PUSH
23567: LD_INT 3
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: PUSH
23574: LD_INT 1
23576: NEG
23577: PUSH
23578: LD_INT 2
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: PUSH
23585: LD_INT 3
23587: NEG
23588: PUSH
23589: LD_INT 2
23591: NEG
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: PUSH
23597: EMPTY
23598: LIST
23599: LIST
23600: LIST
23601: LIST
23602: LIST
23603: LIST
23604: LIST
23605: LIST
23606: LIST
23607: LIST
23608: LIST
23609: LIST
23610: LIST
23611: LIST
23612: LIST
23613: LIST
23614: LIST
23615: LIST
23616: LIST
23617: LIST
23618: LIST
23619: LIST
23620: LIST
23621: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23622: LD_ADDR_VAR 0 34
23626: PUSH
23627: LD_INT 0
23629: PUSH
23630: LD_INT 0
23632: PUSH
23633: EMPTY
23634: LIST
23635: LIST
23636: PUSH
23637: LD_INT 0
23639: PUSH
23640: LD_INT 1
23642: NEG
23643: PUSH
23644: EMPTY
23645: LIST
23646: LIST
23647: PUSH
23648: LD_INT 1
23650: PUSH
23651: LD_INT 0
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: PUSH
23658: LD_INT 1
23660: PUSH
23661: LD_INT 1
23663: PUSH
23664: EMPTY
23665: LIST
23666: LIST
23667: PUSH
23668: LD_INT 0
23670: PUSH
23671: LD_INT 1
23673: PUSH
23674: EMPTY
23675: LIST
23676: LIST
23677: PUSH
23678: LD_INT 1
23680: NEG
23681: PUSH
23682: LD_INT 0
23684: PUSH
23685: EMPTY
23686: LIST
23687: LIST
23688: PUSH
23689: LD_INT 1
23691: NEG
23692: PUSH
23693: LD_INT 1
23695: NEG
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: PUSH
23701: LD_INT 1
23703: NEG
23704: PUSH
23705: LD_INT 2
23707: NEG
23708: PUSH
23709: EMPTY
23710: LIST
23711: LIST
23712: PUSH
23713: LD_INT 0
23715: PUSH
23716: LD_INT 2
23718: NEG
23719: PUSH
23720: EMPTY
23721: LIST
23722: LIST
23723: PUSH
23724: LD_INT 1
23726: PUSH
23727: LD_INT 1
23729: NEG
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: PUSH
23735: LD_INT 2
23737: PUSH
23738: LD_INT 1
23740: PUSH
23741: EMPTY
23742: LIST
23743: LIST
23744: PUSH
23745: LD_INT 2
23747: PUSH
23748: LD_INT 2
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PUSH
23755: LD_INT 1
23757: PUSH
23758: LD_INT 2
23760: PUSH
23761: EMPTY
23762: LIST
23763: LIST
23764: PUSH
23765: LD_INT 1
23767: NEG
23768: PUSH
23769: LD_INT 1
23771: PUSH
23772: EMPTY
23773: LIST
23774: LIST
23775: PUSH
23776: LD_INT 2
23778: NEG
23779: PUSH
23780: LD_INT 0
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: PUSH
23787: LD_INT 2
23789: NEG
23790: PUSH
23791: LD_INT 1
23793: NEG
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: PUSH
23799: LD_INT 2
23801: NEG
23802: PUSH
23803: LD_INT 2
23805: NEG
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: PUSH
23811: LD_INT 1
23813: NEG
23814: PUSH
23815: LD_INT 3
23817: NEG
23818: PUSH
23819: EMPTY
23820: LIST
23821: LIST
23822: PUSH
23823: LD_INT 1
23825: PUSH
23826: LD_INT 2
23828: NEG
23829: PUSH
23830: EMPTY
23831: LIST
23832: LIST
23833: PUSH
23834: LD_INT 3
23836: PUSH
23837: LD_INT 2
23839: PUSH
23840: EMPTY
23841: LIST
23842: LIST
23843: PUSH
23844: LD_INT 2
23846: PUSH
23847: LD_INT 3
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: PUSH
23854: LD_INT 2
23856: NEG
23857: PUSH
23858: LD_INT 1
23860: PUSH
23861: EMPTY
23862: LIST
23863: LIST
23864: PUSH
23865: LD_INT 3
23867: NEG
23868: PUSH
23869: LD_INT 1
23871: NEG
23872: PUSH
23873: EMPTY
23874: LIST
23875: LIST
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: LIST
23881: LIST
23882: LIST
23883: LIST
23884: LIST
23885: LIST
23886: LIST
23887: LIST
23888: LIST
23889: LIST
23890: LIST
23891: LIST
23892: LIST
23893: LIST
23894: LIST
23895: LIST
23896: LIST
23897: LIST
23898: LIST
23899: LIST
23900: LIST
23901: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
23902: LD_ADDR_VAR 0 35
23906: PUSH
23907: LD_INT 0
23909: PUSH
23910: LD_INT 0
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: PUSH
23917: LD_INT 0
23919: PUSH
23920: LD_INT 1
23922: NEG
23923: PUSH
23924: EMPTY
23925: LIST
23926: LIST
23927: PUSH
23928: LD_INT 1
23930: PUSH
23931: LD_INT 0
23933: PUSH
23934: EMPTY
23935: LIST
23936: LIST
23937: PUSH
23938: LD_INT 1
23940: PUSH
23941: LD_INT 1
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: PUSH
23948: LD_INT 0
23950: PUSH
23951: LD_INT 1
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: PUSH
23958: LD_INT 1
23960: NEG
23961: PUSH
23962: LD_INT 0
23964: PUSH
23965: EMPTY
23966: LIST
23967: LIST
23968: PUSH
23969: LD_INT 1
23971: NEG
23972: PUSH
23973: LD_INT 1
23975: NEG
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: PUSH
23981: LD_INT 2
23983: PUSH
23984: LD_INT 1
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 2
23993: NEG
23994: PUSH
23995: LD_INT 1
23997: NEG
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: LIST
24007: LIST
24008: LIST
24009: LIST
24010: LIST
24011: LIST
24012: LIST
24013: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24014: LD_ADDR_VAR 0 36
24018: PUSH
24019: LD_INT 0
24021: PUSH
24022: LD_INT 0
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PUSH
24029: LD_INT 0
24031: PUSH
24032: LD_INT 1
24034: NEG
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PUSH
24040: LD_INT 1
24042: PUSH
24043: LD_INT 0
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: PUSH
24050: LD_INT 1
24052: PUSH
24053: LD_INT 1
24055: PUSH
24056: EMPTY
24057: LIST
24058: LIST
24059: PUSH
24060: LD_INT 0
24062: PUSH
24063: LD_INT 1
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: PUSH
24070: LD_INT 1
24072: NEG
24073: PUSH
24074: LD_INT 0
24076: PUSH
24077: EMPTY
24078: LIST
24079: LIST
24080: PUSH
24081: LD_INT 1
24083: NEG
24084: PUSH
24085: LD_INT 1
24087: NEG
24088: PUSH
24089: EMPTY
24090: LIST
24091: LIST
24092: PUSH
24093: LD_INT 1
24095: NEG
24096: PUSH
24097: LD_INT 2
24099: NEG
24100: PUSH
24101: EMPTY
24102: LIST
24103: LIST
24104: PUSH
24105: LD_INT 1
24107: PUSH
24108: LD_INT 2
24110: PUSH
24111: EMPTY
24112: LIST
24113: LIST
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: LIST
24119: LIST
24120: LIST
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24126: LD_ADDR_VAR 0 37
24130: PUSH
24131: LD_INT 0
24133: PUSH
24134: LD_INT 0
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: PUSH
24141: LD_INT 0
24143: PUSH
24144: LD_INT 1
24146: NEG
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: PUSH
24152: LD_INT 1
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: EMPTY
24159: LIST
24160: LIST
24161: PUSH
24162: LD_INT 1
24164: PUSH
24165: LD_INT 1
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: PUSH
24172: LD_INT 0
24174: PUSH
24175: LD_INT 1
24177: PUSH
24178: EMPTY
24179: LIST
24180: LIST
24181: PUSH
24182: LD_INT 1
24184: NEG
24185: PUSH
24186: LD_INT 0
24188: PUSH
24189: EMPTY
24190: LIST
24191: LIST
24192: PUSH
24193: LD_INT 1
24195: NEG
24196: PUSH
24197: LD_INT 1
24199: NEG
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: PUSH
24205: LD_INT 1
24207: PUSH
24208: LD_INT 1
24210: NEG
24211: PUSH
24212: EMPTY
24213: LIST
24214: LIST
24215: PUSH
24216: LD_INT 1
24218: NEG
24219: PUSH
24220: LD_INT 1
24222: PUSH
24223: EMPTY
24224: LIST
24225: LIST
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: LIST
24235: LIST
24236: LIST
24237: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
24238: LD_ADDR_VAR 0 38
24242: PUSH
24243: LD_INT 0
24245: PUSH
24246: LD_INT 0
24248: PUSH
24249: EMPTY
24250: LIST
24251: LIST
24252: PUSH
24253: LD_INT 0
24255: PUSH
24256: LD_INT 1
24258: NEG
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: PUSH
24264: LD_INT 1
24266: PUSH
24267: LD_INT 0
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: PUSH
24274: LD_INT 1
24276: PUSH
24277: LD_INT 1
24279: PUSH
24280: EMPTY
24281: LIST
24282: LIST
24283: PUSH
24284: LD_INT 0
24286: PUSH
24287: LD_INT 1
24289: PUSH
24290: EMPTY
24291: LIST
24292: LIST
24293: PUSH
24294: LD_INT 1
24296: NEG
24297: PUSH
24298: LD_INT 0
24300: PUSH
24301: EMPTY
24302: LIST
24303: LIST
24304: PUSH
24305: LD_INT 1
24307: NEG
24308: PUSH
24309: LD_INT 1
24311: NEG
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: PUSH
24317: LD_INT 2
24319: PUSH
24320: LD_INT 1
24322: PUSH
24323: EMPTY
24324: LIST
24325: LIST
24326: PUSH
24327: LD_INT 2
24329: NEG
24330: PUSH
24331: LD_INT 1
24333: NEG
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: LIST
24347: LIST
24348: LIST
24349: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24350: LD_ADDR_VAR 0 39
24354: PUSH
24355: LD_INT 0
24357: PUSH
24358: LD_INT 0
24360: PUSH
24361: EMPTY
24362: LIST
24363: LIST
24364: PUSH
24365: LD_INT 0
24367: PUSH
24368: LD_INT 1
24370: NEG
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: PUSH
24376: LD_INT 1
24378: PUSH
24379: LD_INT 0
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: PUSH
24386: LD_INT 1
24388: PUSH
24389: LD_INT 1
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: PUSH
24396: LD_INT 0
24398: PUSH
24399: LD_INT 1
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: PUSH
24406: LD_INT 1
24408: NEG
24409: PUSH
24410: LD_INT 0
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: PUSH
24417: LD_INT 1
24419: NEG
24420: PUSH
24421: LD_INT 1
24423: NEG
24424: PUSH
24425: EMPTY
24426: LIST
24427: LIST
24428: PUSH
24429: LD_INT 1
24431: NEG
24432: PUSH
24433: LD_INT 2
24435: NEG
24436: PUSH
24437: EMPTY
24438: LIST
24439: LIST
24440: PUSH
24441: LD_INT 1
24443: PUSH
24444: LD_INT 2
24446: PUSH
24447: EMPTY
24448: LIST
24449: LIST
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: LIST
24459: LIST
24460: LIST
24461: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24462: LD_ADDR_VAR 0 40
24466: PUSH
24467: LD_INT 0
24469: PUSH
24470: LD_INT 0
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PUSH
24477: LD_INT 0
24479: PUSH
24480: LD_INT 1
24482: NEG
24483: PUSH
24484: EMPTY
24485: LIST
24486: LIST
24487: PUSH
24488: LD_INT 1
24490: PUSH
24491: LD_INT 0
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: PUSH
24498: LD_INT 1
24500: PUSH
24501: LD_INT 1
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: PUSH
24508: LD_INT 0
24510: PUSH
24511: LD_INT 1
24513: PUSH
24514: EMPTY
24515: LIST
24516: LIST
24517: PUSH
24518: LD_INT 1
24520: NEG
24521: PUSH
24522: LD_INT 0
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: PUSH
24529: LD_INT 1
24531: NEG
24532: PUSH
24533: LD_INT 1
24535: NEG
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: LD_INT 1
24543: PUSH
24544: LD_INT 1
24546: NEG
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: PUSH
24552: LD_INT 1
24554: NEG
24555: PUSH
24556: LD_INT 1
24558: PUSH
24559: EMPTY
24560: LIST
24561: LIST
24562: PUSH
24563: EMPTY
24564: LIST
24565: LIST
24566: LIST
24567: LIST
24568: LIST
24569: LIST
24570: LIST
24571: LIST
24572: LIST
24573: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24574: LD_ADDR_VAR 0 41
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: LD_INT 0
24584: PUSH
24585: EMPTY
24586: LIST
24587: LIST
24588: PUSH
24589: LD_INT 0
24591: PUSH
24592: LD_INT 1
24594: NEG
24595: PUSH
24596: EMPTY
24597: LIST
24598: LIST
24599: PUSH
24600: LD_INT 1
24602: PUSH
24603: LD_INT 0
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 1
24612: PUSH
24613: LD_INT 1
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 0
24622: PUSH
24623: LD_INT 1
24625: PUSH
24626: EMPTY
24627: LIST
24628: LIST
24629: PUSH
24630: LD_INT 1
24632: NEG
24633: PUSH
24634: LD_INT 0
24636: PUSH
24637: EMPTY
24638: LIST
24639: LIST
24640: PUSH
24641: LD_INT 1
24643: NEG
24644: PUSH
24645: LD_INT 1
24647: NEG
24648: PUSH
24649: EMPTY
24650: LIST
24651: LIST
24652: PUSH
24653: LD_INT 1
24655: NEG
24656: PUSH
24657: LD_INT 2
24659: NEG
24660: PUSH
24661: EMPTY
24662: LIST
24663: LIST
24664: PUSH
24665: LD_INT 1
24667: PUSH
24668: LD_INT 1
24670: NEG
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 2
24678: PUSH
24679: LD_INT 0
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: PUSH
24686: LD_INT 2
24688: PUSH
24689: LD_INT 1
24691: PUSH
24692: EMPTY
24693: LIST
24694: LIST
24695: PUSH
24696: LD_INT 2
24698: PUSH
24699: LD_INT 2
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PUSH
24706: LD_INT 1
24708: PUSH
24709: LD_INT 2
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: PUSH
24716: LD_INT 1
24718: NEG
24719: PUSH
24720: LD_INT 1
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: PUSH
24727: LD_INT 2
24729: NEG
24730: PUSH
24731: LD_INT 0
24733: PUSH
24734: EMPTY
24735: LIST
24736: LIST
24737: PUSH
24738: LD_INT 2
24740: NEG
24741: PUSH
24742: LD_INT 1
24744: NEG
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: PUSH
24750: LD_INT 2
24752: NEG
24753: PUSH
24754: LD_INT 2
24756: NEG
24757: PUSH
24758: EMPTY
24759: LIST
24760: LIST
24761: PUSH
24762: LD_INT 2
24764: NEG
24765: PUSH
24766: LD_INT 3
24768: NEG
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 2
24776: PUSH
24777: LD_INT 1
24779: NEG
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 3
24787: PUSH
24788: LD_INT 0
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 3
24797: PUSH
24798: LD_INT 1
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: LD_INT 3
24807: PUSH
24808: LD_INT 2
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 3
24817: PUSH
24818: LD_INT 3
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 2
24827: PUSH
24828: LD_INT 3
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: LD_INT 2
24837: NEG
24838: PUSH
24839: LD_INT 1
24841: PUSH
24842: EMPTY
24843: LIST
24844: LIST
24845: PUSH
24846: LD_INT 3
24848: NEG
24849: PUSH
24850: LD_INT 0
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: PUSH
24857: LD_INT 3
24859: NEG
24860: PUSH
24861: LD_INT 1
24863: NEG
24864: PUSH
24865: EMPTY
24866: LIST
24867: LIST
24868: PUSH
24869: LD_INT 3
24871: NEG
24872: PUSH
24873: LD_INT 2
24875: NEG
24876: PUSH
24877: EMPTY
24878: LIST
24879: LIST
24880: PUSH
24881: LD_INT 3
24883: NEG
24884: PUSH
24885: LD_INT 3
24887: NEG
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: PUSH
24893: EMPTY
24894: LIST
24895: LIST
24896: LIST
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: LIST
24908: LIST
24909: LIST
24910: LIST
24911: LIST
24912: LIST
24913: LIST
24914: LIST
24915: LIST
24916: LIST
24917: LIST
24918: LIST
24919: LIST
24920: LIST
24921: LIST
24922: LIST
24923: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24924: LD_ADDR_VAR 0 42
24928: PUSH
24929: LD_INT 0
24931: PUSH
24932: LD_INT 0
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PUSH
24939: LD_INT 0
24941: PUSH
24942: LD_INT 1
24944: NEG
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: PUSH
24950: LD_INT 1
24952: PUSH
24953: LD_INT 0
24955: PUSH
24956: EMPTY
24957: LIST
24958: LIST
24959: PUSH
24960: LD_INT 1
24962: PUSH
24963: LD_INT 1
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 0
24972: PUSH
24973: LD_INT 1
24975: PUSH
24976: EMPTY
24977: LIST
24978: LIST
24979: PUSH
24980: LD_INT 1
24982: NEG
24983: PUSH
24984: LD_INT 0
24986: PUSH
24987: EMPTY
24988: LIST
24989: LIST
24990: PUSH
24991: LD_INT 1
24993: NEG
24994: PUSH
24995: LD_INT 1
24997: NEG
24998: PUSH
24999: EMPTY
25000: LIST
25001: LIST
25002: PUSH
25003: LD_INT 1
25005: NEG
25006: PUSH
25007: LD_INT 2
25009: NEG
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 0
25017: PUSH
25018: LD_INT 2
25020: NEG
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PUSH
25026: LD_INT 1
25028: PUSH
25029: LD_INT 1
25031: NEG
25032: PUSH
25033: EMPTY
25034: LIST
25035: LIST
25036: PUSH
25037: LD_INT 2
25039: PUSH
25040: LD_INT 1
25042: PUSH
25043: EMPTY
25044: LIST
25045: LIST
25046: PUSH
25047: LD_INT 2
25049: PUSH
25050: LD_INT 2
25052: PUSH
25053: EMPTY
25054: LIST
25055: LIST
25056: PUSH
25057: LD_INT 1
25059: PUSH
25060: LD_INT 2
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: PUSH
25067: LD_INT 0
25069: PUSH
25070: LD_INT 2
25072: PUSH
25073: EMPTY
25074: LIST
25075: LIST
25076: PUSH
25077: LD_INT 1
25079: NEG
25080: PUSH
25081: LD_INT 1
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PUSH
25088: LD_INT 2
25090: NEG
25091: PUSH
25092: LD_INT 1
25094: NEG
25095: PUSH
25096: EMPTY
25097: LIST
25098: LIST
25099: PUSH
25100: LD_INT 2
25102: NEG
25103: PUSH
25104: LD_INT 2
25106: NEG
25107: PUSH
25108: EMPTY
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 2
25114: NEG
25115: PUSH
25116: LD_INT 3
25118: NEG
25119: PUSH
25120: EMPTY
25121: LIST
25122: LIST
25123: PUSH
25124: LD_INT 1
25126: NEG
25127: PUSH
25128: LD_INT 3
25130: NEG
25131: PUSH
25132: EMPTY
25133: LIST
25134: LIST
25135: PUSH
25136: LD_INT 0
25138: PUSH
25139: LD_INT 3
25141: NEG
25142: PUSH
25143: EMPTY
25144: LIST
25145: LIST
25146: PUSH
25147: LD_INT 1
25149: PUSH
25150: LD_INT 2
25152: NEG
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 3
25160: PUSH
25161: LD_INT 2
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: LD_INT 3
25170: PUSH
25171: LD_INT 3
25173: PUSH
25174: EMPTY
25175: LIST
25176: LIST
25177: PUSH
25178: LD_INT 2
25180: PUSH
25181: LD_INT 3
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PUSH
25188: LD_INT 1
25190: PUSH
25191: LD_INT 3
25193: PUSH
25194: EMPTY
25195: LIST
25196: LIST
25197: PUSH
25198: LD_INT 0
25200: PUSH
25201: LD_INT 3
25203: PUSH
25204: EMPTY
25205: LIST
25206: LIST
25207: PUSH
25208: LD_INT 1
25210: NEG
25211: PUSH
25212: LD_INT 2
25214: PUSH
25215: EMPTY
25216: LIST
25217: LIST
25218: PUSH
25219: LD_INT 3
25221: NEG
25222: PUSH
25223: LD_INT 2
25225: NEG
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: PUSH
25231: LD_INT 3
25233: NEG
25234: PUSH
25235: LD_INT 3
25237: NEG
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: PUSH
25243: EMPTY
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: LIST
25254: LIST
25255: LIST
25256: LIST
25257: LIST
25258: LIST
25259: LIST
25260: LIST
25261: LIST
25262: LIST
25263: LIST
25264: LIST
25265: LIST
25266: LIST
25267: LIST
25268: LIST
25269: LIST
25270: LIST
25271: LIST
25272: LIST
25273: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25274: LD_ADDR_VAR 0 43
25278: PUSH
25279: LD_INT 0
25281: PUSH
25282: LD_INT 0
25284: PUSH
25285: EMPTY
25286: LIST
25287: LIST
25288: PUSH
25289: LD_INT 0
25291: PUSH
25292: LD_INT 1
25294: NEG
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 1
25302: PUSH
25303: LD_INT 0
25305: PUSH
25306: EMPTY
25307: LIST
25308: LIST
25309: PUSH
25310: LD_INT 1
25312: PUSH
25313: LD_INT 1
25315: PUSH
25316: EMPTY
25317: LIST
25318: LIST
25319: PUSH
25320: LD_INT 0
25322: PUSH
25323: LD_INT 1
25325: PUSH
25326: EMPTY
25327: LIST
25328: LIST
25329: PUSH
25330: LD_INT 1
25332: NEG
25333: PUSH
25334: LD_INT 0
25336: PUSH
25337: EMPTY
25338: LIST
25339: LIST
25340: PUSH
25341: LD_INT 1
25343: NEG
25344: PUSH
25345: LD_INT 1
25347: NEG
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: PUSH
25353: LD_INT 1
25355: NEG
25356: PUSH
25357: LD_INT 2
25359: NEG
25360: PUSH
25361: EMPTY
25362: LIST
25363: LIST
25364: PUSH
25365: LD_INT 0
25367: PUSH
25368: LD_INT 2
25370: NEG
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: PUSH
25376: LD_INT 1
25378: PUSH
25379: LD_INT 1
25381: NEG
25382: PUSH
25383: EMPTY
25384: LIST
25385: LIST
25386: PUSH
25387: LD_INT 2
25389: PUSH
25390: LD_INT 0
25392: PUSH
25393: EMPTY
25394: LIST
25395: LIST
25396: PUSH
25397: LD_INT 2
25399: PUSH
25400: LD_INT 1
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 1
25409: PUSH
25410: LD_INT 2
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: LD_INT 0
25419: PUSH
25420: LD_INT 2
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 1
25429: NEG
25430: PUSH
25431: LD_INT 1
25433: PUSH
25434: EMPTY
25435: LIST
25436: LIST
25437: PUSH
25438: LD_INT 2
25440: NEG
25441: PUSH
25442: LD_INT 0
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: PUSH
25449: LD_INT 2
25451: NEG
25452: PUSH
25453: LD_INT 1
25455: NEG
25456: PUSH
25457: EMPTY
25458: LIST
25459: LIST
25460: PUSH
25461: LD_INT 1
25463: NEG
25464: PUSH
25465: LD_INT 3
25467: NEG
25468: PUSH
25469: EMPTY
25470: LIST
25471: LIST
25472: PUSH
25473: LD_INT 0
25475: PUSH
25476: LD_INT 3
25478: NEG
25479: PUSH
25480: EMPTY
25481: LIST
25482: LIST
25483: PUSH
25484: LD_INT 1
25486: PUSH
25487: LD_INT 2
25489: NEG
25490: PUSH
25491: EMPTY
25492: LIST
25493: LIST
25494: PUSH
25495: LD_INT 2
25497: PUSH
25498: LD_INT 1
25500: NEG
25501: PUSH
25502: EMPTY
25503: LIST
25504: LIST
25505: PUSH
25506: LD_INT 3
25508: PUSH
25509: LD_INT 0
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: PUSH
25516: LD_INT 3
25518: PUSH
25519: LD_INT 1
25521: PUSH
25522: EMPTY
25523: LIST
25524: LIST
25525: PUSH
25526: LD_INT 1
25528: PUSH
25529: LD_INT 3
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: LD_INT 3
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: NEG
25549: PUSH
25550: LD_INT 2
25552: PUSH
25553: EMPTY
25554: LIST
25555: LIST
25556: PUSH
25557: LD_INT 2
25559: NEG
25560: PUSH
25561: LD_INT 1
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: PUSH
25568: LD_INT 3
25570: NEG
25571: PUSH
25572: LD_INT 0
25574: PUSH
25575: EMPTY
25576: LIST
25577: LIST
25578: PUSH
25579: LD_INT 3
25581: NEG
25582: PUSH
25583: LD_INT 1
25585: NEG
25586: PUSH
25587: EMPTY
25588: LIST
25589: LIST
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: LIST
25601: LIST
25602: LIST
25603: LIST
25604: LIST
25605: LIST
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: LIST
25613: LIST
25614: LIST
25615: LIST
25616: LIST
25617: LIST
25618: LIST
25619: LIST
25620: LIST
25621: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25622: LD_ADDR_VAR 0 44
25626: PUSH
25627: LD_INT 0
25629: PUSH
25630: LD_INT 0
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PUSH
25637: LD_INT 0
25639: PUSH
25640: LD_INT 1
25642: NEG
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 1
25650: PUSH
25651: LD_INT 0
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: PUSH
25658: LD_INT 1
25660: PUSH
25661: LD_INT 1
25663: PUSH
25664: EMPTY
25665: LIST
25666: LIST
25667: PUSH
25668: LD_INT 0
25670: PUSH
25671: LD_INT 1
25673: PUSH
25674: EMPTY
25675: LIST
25676: LIST
25677: PUSH
25678: LD_INT 1
25680: NEG
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: EMPTY
25686: LIST
25687: LIST
25688: PUSH
25689: LD_INT 1
25691: NEG
25692: PUSH
25693: LD_INT 1
25695: NEG
25696: PUSH
25697: EMPTY
25698: LIST
25699: LIST
25700: PUSH
25701: LD_INT 1
25703: NEG
25704: PUSH
25705: LD_INT 2
25707: NEG
25708: PUSH
25709: EMPTY
25710: LIST
25711: LIST
25712: PUSH
25713: LD_INT 1
25715: PUSH
25716: LD_INT 1
25718: NEG
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: PUSH
25724: LD_INT 2
25726: PUSH
25727: LD_INT 0
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PUSH
25734: LD_INT 2
25736: PUSH
25737: LD_INT 1
25739: PUSH
25740: EMPTY
25741: LIST
25742: LIST
25743: PUSH
25744: LD_INT 2
25746: PUSH
25747: LD_INT 2
25749: PUSH
25750: EMPTY
25751: LIST
25752: LIST
25753: PUSH
25754: LD_INT 1
25756: PUSH
25757: LD_INT 2
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: PUSH
25764: LD_INT 1
25766: NEG
25767: PUSH
25768: LD_INT 1
25770: PUSH
25771: EMPTY
25772: LIST
25773: LIST
25774: PUSH
25775: LD_INT 2
25777: NEG
25778: PUSH
25779: LD_INT 0
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: PUSH
25786: LD_INT 2
25788: NEG
25789: PUSH
25790: LD_INT 1
25792: NEG
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: PUSH
25798: LD_INT 2
25800: NEG
25801: PUSH
25802: LD_INT 2
25804: NEG
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 2
25812: NEG
25813: PUSH
25814: LD_INT 3
25816: NEG
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 2
25824: PUSH
25825: LD_INT 1
25827: NEG
25828: PUSH
25829: EMPTY
25830: LIST
25831: LIST
25832: PUSH
25833: LD_INT 3
25835: PUSH
25836: LD_INT 0
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: PUSH
25843: LD_INT 3
25845: PUSH
25846: LD_INT 1
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 3
25855: PUSH
25856: LD_INT 2
25858: PUSH
25859: EMPTY
25860: LIST
25861: LIST
25862: PUSH
25863: LD_INT 3
25865: PUSH
25866: LD_INT 3
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 2
25875: PUSH
25876: LD_INT 3
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: LD_INT 2
25885: NEG
25886: PUSH
25887: LD_INT 1
25889: PUSH
25890: EMPTY
25891: LIST
25892: LIST
25893: PUSH
25894: LD_INT 3
25896: NEG
25897: PUSH
25898: LD_INT 0
25900: PUSH
25901: EMPTY
25902: LIST
25903: LIST
25904: PUSH
25905: LD_INT 3
25907: NEG
25908: PUSH
25909: LD_INT 1
25911: NEG
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 3
25919: NEG
25920: PUSH
25921: LD_INT 2
25923: NEG
25924: PUSH
25925: EMPTY
25926: LIST
25927: LIST
25928: PUSH
25929: LD_INT 3
25931: NEG
25932: PUSH
25933: LD_INT 3
25935: NEG
25936: PUSH
25937: EMPTY
25938: LIST
25939: LIST
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: LIST
25951: LIST
25952: LIST
25953: LIST
25954: LIST
25955: LIST
25956: LIST
25957: LIST
25958: LIST
25959: LIST
25960: LIST
25961: LIST
25962: LIST
25963: LIST
25964: LIST
25965: LIST
25966: LIST
25967: LIST
25968: LIST
25969: LIST
25970: LIST
25971: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25972: LD_ADDR_VAR 0 45
25976: PUSH
25977: LD_INT 0
25979: PUSH
25980: LD_INT 0
25982: PUSH
25983: EMPTY
25984: LIST
25985: LIST
25986: PUSH
25987: LD_INT 0
25989: PUSH
25990: LD_INT 1
25992: NEG
25993: PUSH
25994: EMPTY
25995: LIST
25996: LIST
25997: PUSH
25998: LD_INT 1
26000: PUSH
26001: LD_INT 0
26003: PUSH
26004: EMPTY
26005: LIST
26006: LIST
26007: PUSH
26008: LD_INT 1
26010: PUSH
26011: LD_INT 1
26013: PUSH
26014: EMPTY
26015: LIST
26016: LIST
26017: PUSH
26018: LD_INT 0
26020: PUSH
26021: LD_INT 1
26023: PUSH
26024: EMPTY
26025: LIST
26026: LIST
26027: PUSH
26028: LD_INT 1
26030: NEG
26031: PUSH
26032: LD_INT 0
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PUSH
26039: LD_INT 1
26041: NEG
26042: PUSH
26043: LD_INT 1
26045: NEG
26046: PUSH
26047: EMPTY
26048: LIST
26049: LIST
26050: PUSH
26051: LD_INT 1
26053: NEG
26054: PUSH
26055: LD_INT 2
26057: NEG
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: PUSH
26063: LD_INT 0
26065: PUSH
26066: LD_INT 2
26068: NEG
26069: PUSH
26070: EMPTY
26071: LIST
26072: LIST
26073: PUSH
26074: LD_INT 1
26076: PUSH
26077: LD_INT 1
26079: NEG
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 2
26087: PUSH
26088: LD_INT 1
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PUSH
26095: LD_INT 2
26097: PUSH
26098: LD_INT 2
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PUSH
26105: LD_INT 1
26107: PUSH
26108: LD_INT 2
26110: PUSH
26111: EMPTY
26112: LIST
26113: LIST
26114: PUSH
26115: LD_INT 0
26117: PUSH
26118: LD_INT 2
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: PUSH
26125: LD_INT 1
26127: NEG
26128: PUSH
26129: LD_INT 1
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: PUSH
26136: LD_INT 2
26138: NEG
26139: PUSH
26140: LD_INT 1
26142: NEG
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: LD_INT 2
26150: NEG
26151: PUSH
26152: LD_INT 2
26154: NEG
26155: PUSH
26156: EMPTY
26157: LIST
26158: LIST
26159: PUSH
26160: LD_INT 2
26162: NEG
26163: PUSH
26164: LD_INT 3
26166: NEG
26167: PUSH
26168: EMPTY
26169: LIST
26170: LIST
26171: PUSH
26172: LD_INT 1
26174: NEG
26175: PUSH
26176: LD_INT 3
26178: NEG
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: PUSH
26184: LD_INT 0
26186: PUSH
26187: LD_INT 3
26189: NEG
26190: PUSH
26191: EMPTY
26192: LIST
26193: LIST
26194: PUSH
26195: LD_INT 1
26197: PUSH
26198: LD_INT 2
26200: NEG
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: PUSH
26206: LD_INT 3
26208: PUSH
26209: LD_INT 2
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 3
26218: PUSH
26219: LD_INT 3
26221: PUSH
26222: EMPTY
26223: LIST
26224: LIST
26225: PUSH
26226: LD_INT 2
26228: PUSH
26229: LD_INT 3
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: PUSH
26236: LD_INT 1
26238: PUSH
26239: LD_INT 3
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: PUSH
26246: LD_INT 0
26248: PUSH
26249: LD_INT 3
26251: PUSH
26252: EMPTY
26253: LIST
26254: LIST
26255: PUSH
26256: LD_INT 1
26258: NEG
26259: PUSH
26260: LD_INT 2
26262: PUSH
26263: EMPTY
26264: LIST
26265: LIST
26266: PUSH
26267: LD_INT 3
26269: NEG
26270: PUSH
26271: LD_INT 2
26273: NEG
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: PUSH
26279: LD_INT 3
26281: NEG
26282: PUSH
26283: LD_INT 3
26285: NEG
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: EMPTY
26292: LIST
26293: LIST
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: LIST
26299: LIST
26300: LIST
26301: LIST
26302: LIST
26303: LIST
26304: LIST
26305: LIST
26306: LIST
26307: LIST
26308: LIST
26309: LIST
26310: LIST
26311: LIST
26312: LIST
26313: LIST
26314: LIST
26315: LIST
26316: LIST
26317: LIST
26318: LIST
26319: LIST
26320: LIST
26321: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26322: LD_ADDR_VAR 0 46
26326: PUSH
26327: LD_INT 0
26329: PUSH
26330: LD_INT 0
26332: PUSH
26333: EMPTY
26334: LIST
26335: LIST
26336: PUSH
26337: LD_INT 0
26339: PUSH
26340: LD_INT 1
26342: NEG
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PUSH
26348: LD_INT 1
26350: PUSH
26351: LD_INT 0
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 1
26360: PUSH
26361: LD_INT 1
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: PUSH
26368: LD_INT 0
26370: PUSH
26371: LD_INT 1
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 1
26380: NEG
26381: PUSH
26382: LD_INT 0
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PUSH
26389: LD_INT 1
26391: NEG
26392: PUSH
26393: LD_INT 1
26395: NEG
26396: PUSH
26397: EMPTY
26398: LIST
26399: LIST
26400: PUSH
26401: LD_INT 1
26403: NEG
26404: PUSH
26405: LD_INT 2
26407: NEG
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 0
26415: PUSH
26416: LD_INT 2
26418: NEG
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: PUSH
26424: LD_INT 1
26426: PUSH
26427: LD_INT 1
26429: NEG
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: LD_INT 2
26437: PUSH
26438: LD_INT 0
26440: PUSH
26441: EMPTY
26442: LIST
26443: LIST
26444: PUSH
26445: LD_INT 2
26447: PUSH
26448: LD_INT 1
26450: PUSH
26451: EMPTY
26452: LIST
26453: LIST
26454: PUSH
26455: LD_INT 1
26457: PUSH
26458: LD_INT 2
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 0
26467: PUSH
26468: LD_INT 2
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 1
26477: NEG
26478: PUSH
26479: LD_INT 1
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 2
26488: NEG
26489: PUSH
26490: LD_INT 0
26492: PUSH
26493: EMPTY
26494: LIST
26495: LIST
26496: PUSH
26497: LD_INT 2
26499: NEG
26500: PUSH
26501: LD_INT 1
26503: NEG
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 1
26511: NEG
26512: PUSH
26513: LD_INT 3
26515: NEG
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: PUSH
26521: LD_INT 0
26523: PUSH
26524: LD_INT 3
26526: NEG
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PUSH
26532: LD_INT 1
26534: PUSH
26535: LD_INT 2
26537: NEG
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 2
26545: PUSH
26546: LD_INT 1
26548: NEG
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: PUSH
26554: LD_INT 3
26556: PUSH
26557: LD_INT 0
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: PUSH
26564: LD_INT 3
26566: PUSH
26567: LD_INT 1
26569: PUSH
26570: EMPTY
26571: LIST
26572: LIST
26573: PUSH
26574: LD_INT 1
26576: PUSH
26577: LD_INT 3
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: LD_INT 0
26586: PUSH
26587: LD_INT 3
26589: PUSH
26590: EMPTY
26591: LIST
26592: LIST
26593: PUSH
26594: LD_INT 1
26596: NEG
26597: PUSH
26598: LD_INT 2
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 2
26607: NEG
26608: PUSH
26609: LD_INT 1
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: PUSH
26616: LD_INT 3
26618: NEG
26619: PUSH
26620: LD_INT 0
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 3
26629: NEG
26630: PUSH
26631: LD_INT 1
26633: NEG
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: PUSH
26639: EMPTY
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: LIST
26653: LIST
26654: LIST
26655: LIST
26656: LIST
26657: LIST
26658: LIST
26659: LIST
26660: LIST
26661: LIST
26662: LIST
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26670: LD_ADDR_VAR 0 47
26674: PUSH
26675: LD_INT 0
26677: PUSH
26678: LD_INT 0
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: LD_INT 0
26687: PUSH
26688: LD_INT 1
26690: NEG
26691: PUSH
26692: EMPTY
26693: LIST
26694: LIST
26695: PUSH
26696: LD_INT 1
26698: PUSH
26699: LD_INT 0
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 1
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 0
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: EMPTY
26723: LIST
26724: LIST
26725: PUSH
26726: LD_INT 1
26728: NEG
26729: PUSH
26730: LD_INT 0
26732: PUSH
26733: EMPTY
26734: LIST
26735: LIST
26736: PUSH
26737: LD_INT 1
26739: NEG
26740: PUSH
26741: LD_INT 1
26743: NEG
26744: PUSH
26745: EMPTY
26746: LIST
26747: LIST
26748: PUSH
26749: LD_INT 1
26751: NEG
26752: PUSH
26753: LD_INT 2
26755: NEG
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: PUSH
26761: LD_INT 0
26763: PUSH
26764: LD_INT 2
26766: NEG
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: LD_INT 1
26774: PUSH
26775: LD_INT 1
26777: NEG
26778: PUSH
26779: EMPTY
26780: LIST
26781: LIST
26782: PUSH
26783: LD_INT 2
26785: NEG
26786: PUSH
26787: LD_INT 1
26789: NEG
26790: PUSH
26791: EMPTY
26792: LIST
26793: LIST
26794: PUSH
26795: LD_INT 2
26797: NEG
26798: PUSH
26799: LD_INT 2
26801: NEG
26802: PUSH
26803: EMPTY
26804: LIST
26805: LIST
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: LIST
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: LIST
26820: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
26821: LD_ADDR_VAR 0 48
26825: PUSH
26826: LD_INT 0
26828: PUSH
26829: LD_INT 0
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 1
26841: NEG
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PUSH
26847: LD_INT 1
26849: PUSH
26850: LD_INT 0
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 1
26859: PUSH
26860: LD_INT 1
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 0
26869: PUSH
26870: LD_INT 1
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 1
26879: NEG
26880: PUSH
26881: LD_INT 0
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: PUSH
26888: LD_INT 1
26890: NEG
26891: PUSH
26892: LD_INT 1
26894: NEG
26895: PUSH
26896: EMPTY
26897: LIST
26898: LIST
26899: PUSH
26900: LD_INT 1
26902: NEG
26903: PUSH
26904: LD_INT 2
26906: NEG
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 0
26914: PUSH
26915: LD_INT 2
26917: NEG
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: LD_INT 1
26928: NEG
26929: PUSH
26930: EMPTY
26931: LIST
26932: LIST
26933: PUSH
26934: LD_INT 2
26936: PUSH
26937: LD_INT 0
26939: PUSH
26940: EMPTY
26941: LIST
26942: LIST
26943: PUSH
26944: LD_INT 2
26946: PUSH
26947: LD_INT 1
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: LIST
26960: LIST
26961: LIST
26962: LIST
26963: LIST
26964: LIST
26965: LIST
26966: LIST
26967: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
26968: LD_ADDR_VAR 0 49
26972: PUSH
26973: LD_INT 0
26975: PUSH
26976: LD_INT 0
26978: PUSH
26979: EMPTY
26980: LIST
26981: LIST
26982: PUSH
26983: LD_INT 0
26985: PUSH
26986: LD_INT 1
26988: NEG
26989: PUSH
26990: EMPTY
26991: LIST
26992: LIST
26993: PUSH
26994: LD_INT 1
26996: PUSH
26997: LD_INT 0
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: PUSH
27004: LD_INT 1
27006: PUSH
27007: LD_INT 1
27009: PUSH
27010: EMPTY
27011: LIST
27012: LIST
27013: PUSH
27014: LD_INT 0
27016: PUSH
27017: LD_INT 1
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PUSH
27024: LD_INT 1
27026: NEG
27027: PUSH
27028: LD_INT 0
27030: PUSH
27031: EMPTY
27032: LIST
27033: LIST
27034: PUSH
27035: LD_INT 1
27037: NEG
27038: PUSH
27039: LD_INT 1
27041: NEG
27042: PUSH
27043: EMPTY
27044: LIST
27045: LIST
27046: PUSH
27047: LD_INT 1
27049: PUSH
27050: LD_INT 1
27052: NEG
27053: PUSH
27054: EMPTY
27055: LIST
27056: LIST
27057: PUSH
27058: LD_INT 2
27060: PUSH
27061: LD_INT 0
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: PUSH
27068: LD_INT 2
27070: PUSH
27071: LD_INT 1
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: LD_INT 2
27080: PUSH
27081: LD_INT 2
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: LD_INT 1
27090: PUSH
27091: LD_INT 2
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: LIST
27102: LIST
27103: LIST
27104: LIST
27105: LIST
27106: LIST
27107: LIST
27108: LIST
27109: LIST
27110: LIST
27111: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
27112: LD_ADDR_VAR 0 50
27116: PUSH
27117: LD_INT 0
27119: PUSH
27120: LD_INT 0
27122: PUSH
27123: EMPTY
27124: LIST
27125: LIST
27126: PUSH
27127: LD_INT 0
27129: PUSH
27130: LD_INT 1
27132: NEG
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: LD_INT 1
27140: PUSH
27141: LD_INT 0
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 1
27150: PUSH
27151: LD_INT 1
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 0
27160: PUSH
27161: LD_INT 1
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 1
27170: NEG
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 1
27181: NEG
27182: PUSH
27183: LD_INT 1
27185: NEG
27186: PUSH
27187: EMPTY
27188: LIST
27189: LIST
27190: PUSH
27191: LD_INT 2
27193: PUSH
27194: LD_INT 1
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 2
27203: PUSH
27204: LD_INT 2
27206: PUSH
27207: EMPTY
27208: LIST
27209: LIST
27210: PUSH
27211: LD_INT 1
27213: PUSH
27214: LD_INT 2
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: LD_INT 0
27223: PUSH
27224: LD_INT 2
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 1
27233: NEG
27234: PUSH
27235: LD_INT 1
27237: PUSH
27238: EMPTY
27239: LIST
27240: LIST
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: LIST
27252: LIST
27253: LIST
27254: LIST
27255: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
27256: LD_ADDR_VAR 0 51
27260: PUSH
27261: LD_INT 0
27263: PUSH
27264: LD_INT 0
27266: PUSH
27267: EMPTY
27268: LIST
27269: LIST
27270: PUSH
27271: LD_INT 0
27273: PUSH
27274: LD_INT 1
27276: NEG
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PUSH
27282: LD_INT 1
27284: PUSH
27285: LD_INT 0
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 1
27294: PUSH
27295: LD_INT 1
27297: PUSH
27298: EMPTY
27299: LIST
27300: LIST
27301: PUSH
27302: LD_INT 0
27304: PUSH
27305: LD_INT 1
27307: PUSH
27308: EMPTY
27309: LIST
27310: LIST
27311: PUSH
27312: LD_INT 1
27314: NEG
27315: PUSH
27316: LD_INT 0
27318: PUSH
27319: EMPTY
27320: LIST
27321: LIST
27322: PUSH
27323: LD_INT 1
27325: NEG
27326: PUSH
27327: LD_INT 1
27329: NEG
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PUSH
27335: LD_INT 1
27337: PUSH
27338: LD_INT 2
27340: PUSH
27341: EMPTY
27342: LIST
27343: LIST
27344: PUSH
27345: LD_INT 0
27347: PUSH
27348: LD_INT 2
27350: PUSH
27351: EMPTY
27352: LIST
27353: LIST
27354: PUSH
27355: LD_INT 1
27357: NEG
27358: PUSH
27359: LD_INT 1
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 2
27368: NEG
27369: PUSH
27370: LD_INT 0
27372: PUSH
27373: EMPTY
27374: LIST
27375: LIST
27376: PUSH
27377: LD_INT 2
27379: NEG
27380: PUSH
27381: LD_INT 1
27383: NEG
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PUSH
27389: EMPTY
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: LIST
27402: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27403: LD_ADDR_VAR 0 52
27407: PUSH
27408: LD_INT 0
27410: PUSH
27411: LD_INT 0
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: PUSH
27418: LD_INT 0
27420: PUSH
27421: LD_INT 1
27423: NEG
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 1
27431: PUSH
27432: LD_INT 0
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PUSH
27439: LD_INT 1
27441: PUSH
27442: LD_INT 1
27444: PUSH
27445: EMPTY
27446: LIST
27447: LIST
27448: PUSH
27449: LD_INT 0
27451: PUSH
27452: LD_INT 1
27454: PUSH
27455: EMPTY
27456: LIST
27457: LIST
27458: PUSH
27459: LD_INT 1
27461: NEG
27462: PUSH
27463: LD_INT 0
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 1
27472: NEG
27473: PUSH
27474: LD_INT 1
27476: NEG
27477: PUSH
27478: EMPTY
27479: LIST
27480: LIST
27481: PUSH
27482: LD_INT 1
27484: NEG
27485: PUSH
27486: LD_INT 2
27488: NEG
27489: PUSH
27490: EMPTY
27491: LIST
27492: LIST
27493: PUSH
27494: LD_INT 1
27496: NEG
27497: PUSH
27498: LD_INT 1
27500: PUSH
27501: EMPTY
27502: LIST
27503: LIST
27504: PUSH
27505: LD_INT 2
27507: NEG
27508: PUSH
27509: LD_INT 0
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 2
27518: NEG
27519: PUSH
27520: LD_INT 1
27522: NEG
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: PUSH
27528: LD_INT 2
27530: NEG
27531: PUSH
27532: LD_INT 2
27534: NEG
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: LIST
27547: LIST
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27554: LD_ADDR_VAR 0 53
27558: PUSH
27559: LD_INT 0
27561: PUSH
27562: LD_INT 0
27564: PUSH
27565: EMPTY
27566: LIST
27567: LIST
27568: PUSH
27569: LD_INT 0
27571: PUSH
27572: LD_INT 1
27574: NEG
27575: PUSH
27576: EMPTY
27577: LIST
27578: LIST
27579: PUSH
27580: LD_INT 1
27582: PUSH
27583: LD_INT 0
27585: PUSH
27586: EMPTY
27587: LIST
27588: LIST
27589: PUSH
27590: LD_INT 1
27592: PUSH
27593: LD_INT 1
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: LD_INT 0
27602: PUSH
27603: LD_INT 1
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 1
27612: NEG
27613: PUSH
27614: LD_INT 0
27616: PUSH
27617: EMPTY
27618: LIST
27619: LIST
27620: PUSH
27621: LD_INT 1
27623: NEG
27624: PUSH
27625: LD_INT 1
27627: NEG
27628: PUSH
27629: EMPTY
27630: LIST
27631: LIST
27632: PUSH
27633: LD_INT 1
27635: NEG
27636: PUSH
27637: LD_INT 2
27639: NEG
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: PUSH
27645: LD_INT 0
27647: PUSH
27648: LD_INT 2
27650: NEG
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 1
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PUSH
27667: LD_INT 2
27669: PUSH
27670: LD_INT 0
27672: PUSH
27673: EMPTY
27674: LIST
27675: LIST
27676: PUSH
27677: LD_INT 2
27679: PUSH
27680: LD_INT 1
27682: PUSH
27683: EMPTY
27684: LIST
27685: LIST
27686: PUSH
27687: LD_INT 2
27689: PUSH
27690: LD_INT 2
27692: PUSH
27693: EMPTY
27694: LIST
27695: LIST
27696: PUSH
27697: LD_INT 1
27699: PUSH
27700: LD_INT 2
27702: PUSH
27703: EMPTY
27704: LIST
27705: LIST
27706: PUSH
27707: LD_INT 0
27709: PUSH
27710: LD_INT 2
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: LD_INT 1
27719: NEG
27720: PUSH
27721: LD_INT 1
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: PUSH
27728: LD_INT 2
27730: NEG
27731: PUSH
27732: LD_INT 0
27734: PUSH
27735: EMPTY
27736: LIST
27737: LIST
27738: PUSH
27739: LD_INT 2
27741: NEG
27742: PUSH
27743: LD_INT 1
27745: NEG
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: PUSH
27751: LD_INT 2
27753: NEG
27754: PUSH
27755: LD_INT 2
27757: NEG
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: LIST
27767: LIST
27768: LIST
27769: LIST
27770: LIST
27771: LIST
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: LIST
27783: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27784: LD_ADDR_VAR 0 54
27788: PUSH
27789: LD_INT 0
27791: PUSH
27792: LD_INT 0
27794: PUSH
27795: EMPTY
27796: LIST
27797: LIST
27798: PUSH
27799: LD_INT 0
27801: PUSH
27802: LD_INT 1
27804: NEG
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PUSH
27810: LD_INT 1
27812: PUSH
27813: LD_INT 0
27815: PUSH
27816: EMPTY
27817: LIST
27818: LIST
27819: PUSH
27820: LD_INT 1
27822: PUSH
27823: LD_INT 1
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PUSH
27830: LD_INT 0
27832: PUSH
27833: LD_INT 1
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: LD_INT 1
27842: NEG
27843: PUSH
27844: LD_INT 0
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: LD_INT 1
27853: NEG
27854: PUSH
27855: LD_INT 1
27857: NEG
27858: PUSH
27859: EMPTY
27860: LIST
27861: LIST
27862: PUSH
27863: LD_INT 1
27865: NEG
27866: PUSH
27867: LD_INT 2
27869: NEG
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: PUSH
27875: LD_INT 0
27877: PUSH
27878: LD_INT 2
27880: NEG
27881: PUSH
27882: EMPTY
27883: LIST
27884: LIST
27885: PUSH
27886: LD_INT 1
27888: PUSH
27889: LD_INT 1
27891: NEG
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: LD_INT 2
27899: PUSH
27900: LD_INT 0
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 2
27909: PUSH
27910: LD_INT 1
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 2
27919: PUSH
27920: LD_INT 2
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 1
27929: PUSH
27930: LD_INT 2
27932: PUSH
27933: EMPTY
27934: LIST
27935: LIST
27936: PUSH
27937: LD_INT 0
27939: PUSH
27940: LD_INT 2
27942: PUSH
27943: EMPTY
27944: LIST
27945: LIST
27946: PUSH
27947: LD_INT 1
27949: NEG
27950: PUSH
27951: LD_INT 1
27953: PUSH
27954: EMPTY
27955: LIST
27956: LIST
27957: PUSH
27958: LD_INT 2
27960: NEG
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: EMPTY
27966: LIST
27967: LIST
27968: PUSH
27969: LD_INT 2
27971: NEG
27972: PUSH
27973: LD_INT 1
27975: NEG
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 2
27983: NEG
27984: PUSH
27985: LD_INT 2
27987: NEG
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: EMPTY
27994: LIST
27995: LIST
27996: LIST
27997: LIST
27998: LIST
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28014: LD_ADDR_VAR 0 55
28018: PUSH
28019: LD_INT 0
28021: PUSH
28022: LD_INT 0
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 0
28031: PUSH
28032: LD_INT 1
28034: NEG
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 1
28042: PUSH
28043: LD_INT 0
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 1
28052: PUSH
28053: LD_INT 1
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 0
28062: PUSH
28063: LD_INT 1
28065: PUSH
28066: EMPTY
28067: LIST
28068: LIST
28069: PUSH
28070: LD_INT 1
28072: NEG
28073: PUSH
28074: LD_INT 0
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 1
28083: NEG
28084: PUSH
28085: LD_INT 1
28087: NEG
28088: PUSH
28089: EMPTY
28090: LIST
28091: LIST
28092: PUSH
28093: LD_INT 1
28095: NEG
28096: PUSH
28097: LD_INT 2
28099: NEG
28100: PUSH
28101: EMPTY
28102: LIST
28103: LIST
28104: PUSH
28105: LD_INT 0
28107: PUSH
28108: LD_INT 2
28110: NEG
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 1
28118: PUSH
28119: LD_INT 1
28121: NEG
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: LD_INT 2
28129: PUSH
28130: LD_INT 0
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 2
28139: PUSH
28140: LD_INT 1
28142: PUSH
28143: EMPTY
28144: LIST
28145: LIST
28146: PUSH
28147: LD_INT 2
28149: PUSH
28150: LD_INT 2
28152: PUSH
28153: EMPTY
28154: LIST
28155: LIST
28156: PUSH
28157: LD_INT 1
28159: PUSH
28160: LD_INT 2
28162: PUSH
28163: EMPTY
28164: LIST
28165: LIST
28166: PUSH
28167: LD_INT 0
28169: PUSH
28170: LD_INT 2
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 1
28179: NEG
28180: PUSH
28181: LD_INT 1
28183: PUSH
28184: EMPTY
28185: LIST
28186: LIST
28187: PUSH
28188: LD_INT 2
28190: NEG
28191: PUSH
28192: LD_INT 0
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 2
28201: NEG
28202: PUSH
28203: LD_INT 1
28205: NEG
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 2
28213: NEG
28214: PUSH
28215: LD_INT 2
28217: NEG
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: LIST
28238: LIST
28239: LIST
28240: LIST
28241: LIST
28242: LIST
28243: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28244: LD_ADDR_VAR 0 56
28248: PUSH
28249: LD_INT 0
28251: PUSH
28252: LD_INT 0
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 0
28261: PUSH
28262: LD_INT 1
28264: NEG
28265: PUSH
28266: EMPTY
28267: LIST
28268: LIST
28269: PUSH
28270: LD_INT 1
28272: PUSH
28273: LD_INT 0
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: LD_INT 1
28282: PUSH
28283: LD_INT 1
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 0
28292: PUSH
28293: LD_INT 1
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: LD_INT 1
28302: NEG
28303: PUSH
28304: LD_INT 0
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 1
28313: NEG
28314: PUSH
28315: LD_INT 1
28317: NEG
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 1
28325: NEG
28326: PUSH
28327: LD_INT 2
28329: NEG
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 0
28337: PUSH
28338: LD_INT 2
28340: NEG
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 1
28348: PUSH
28349: LD_INT 1
28351: NEG
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: LD_INT 0
28362: PUSH
28363: EMPTY
28364: LIST
28365: LIST
28366: PUSH
28367: LD_INT 2
28369: PUSH
28370: LD_INT 1
28372: PUSH
28373: EMPTY
28374: LIST
28375: LIST
28376: PUSH
28377: LD_INT 2
28379: PUSH
28380: LD_INT 2
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: LD_INT 1
28389: PUSH
28390: LD_INT 2
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: PUSH
28397: LD_INT 0
28399: PUSH
28400: LD_INT 2
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: PUSH
28407: LD_INT 1
28409: NEG
28410: PUSH
28411: LD_INT 1
28413: PUSH
28414: EMPTY
28415: LIST
28416: LIST
28417: PUSH
28418: LD_INT 2
28420: NEG
28421: PUSH
28422: LD_INT 0
28424: PUSH
28425: EMPTY
28426: LIST
28427: LIST
28428: PUSH
28429: LD_INT 2
28431: NEG
28432: PUSH
28433: LD_INT 1
28435: NEG
28436: PUSH
28437: EMPTY
28438: LIST
28439: LIST
28440: PUSH
28441: LD_INT 2
28443: NEG
28444: PUSH
28445: LD_INT 2
28447: NEG
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: LIST
28460: LIST
28461: LIST
28462: LIST
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: LIST
28468: LIST
28469: LIST
28470: LIST
28471: LIST
28472: LIST
28473: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28474: LD_ADDR_VAR 0 57
28478: PUSH
28479: LD_INT 0
28481: PUSH
28482: LD_INT 0
28484: PUSH
28485: EMPTY
28486: LIST
28487: LIST
28488: PUSH
28489: LD_INT 0
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 1
28502: PUSH
28503: LD_INT 0
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 1
28512: PUSH
28513: LD_INT 1
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: LD_INT 0
28522: PUSH
28523: LD_INT 1
28525: PUSH
28526: EMPTY
28527: LIST
28528: LIST
28529: PUSH
28530: LD_INT 1
28532: NEG
28533: PUSH
28534: LD_INT 0
28536: PUSH
28537: EMPTY
28538: LIST
28539: LIST
28540: PUSH
28541: LD_INT 1
28543: NEG
28544: PUSH
28545: LD_INT 1
28547: NEG
28548: PUSH
28549: EMPTY
28550: LIST
28551: LIST
28552: PUSH
28553: LD_INT 1
28555: NEG
28556: PUSH
28557: LD_INT 2
28559: NEG
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: PUSH
28565: LD_INT 0
28567: PUSH
28568: LD_INT 2
28570: NEG
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 1
28578: PUSH
28579: LD_INT 1
28581: NEG
28582: PUSH
28583: EMPTY
28584: LIST
28585: LIST
28586: PUSH
28587: LD_INT 2
28589: PUSH
28590: LD_INT 0
28592: PUSH
28593: EMPTY
28594: LIST
28595: LIST
28596: PUSH
28597: LD_INT 2
28599: PUSH
28600: LD_INT 1
28602: PUSH
28603: EMPTY
28604: LIST
28605: LIST
28606: PUSH
28607: LD_INT 2
28609: PUSH
28610: LD_INT 2
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: LD_INT 1
28619: PUSH
28620: LD_INT 2
28622: PUSH
28623: EMPTY
28624: LIST
28625: LIST
28626: PUSH
28627: LD_INT 0
28629: PUSH
28630: LD_INT 2
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PUSH
28637: LD_INT 1
28639: NEG
28640: PUSH
28641: LD_INT 1
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: LD_INT 2
28650: NEG
28651: PUSH
28652: LD_INT 0
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: PUSH
28659: LD_INT 2
28661: NEG
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PUSH
28671: LD_INT 2
28673: NEG
28674: PUSH
28675: LD_INT 2
28677: NEG
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: LIST
28687: LIST
28688: LIST
28689: LIST
28690: LIST
28691: LIST
28692: LIST
28693: LIST
28694: LIST
28695: LIST
28696: LIST
28697: LIST
28698: LIST
28699: LIST
28700: LIST
28701: LIST
28702: LIST
28703: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28704: LD_ADDR_VAR 0 58
28708: PUSH
28709: LD_INT 0
28711: PUSH
28712: LD_INT 0
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 0
28721: PUSH
28722: LD_INT 1
28724: NEG
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: PUSH
28733: LD_INT 0
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 1
28742: PUSH
28743: LD_INT 1
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: PUSH
28750: LD_INT 0
28752: PUSH
28753: LD_INT 1
28755: PUSH
28756: EMPTY
28757: LIST
28758: LIST
28759: PUSH
28760: LD_INT 1
28762: NEG
28763: PUSH
28764: LD_INT 0
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 1
28773: NEG
28774: PUSH
28775: LD_INT 1
28777: NEG
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: LD_INT 1
28785: NEG
28786: PUSH
28787: LD_INT 2
28789: NEG
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: LD_INT 0
28797: PUSH
28798: LD_INT 2
28800: NEG
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: LD_INT 1
28811: NEG
28812: PUSH
28813: EMPTY
28814: LIST
28815: LIST
28816: PUSH
28817: LD_INT 2
28819: PUSH
28820: LD_INT 0
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: PUSH
28827: LD_INT 2
28829: PUSH
28830: LD_INT 1
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 2
28839: PUSH
28840: LD_INT 2
28842: PUSH
28843: EMPTY
28844: LIST
28845: LIST
28846: PUSH
28847: LD_INT 1
28849: PUSH
28850: LD_INT 2
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: PUSH
28857: LD_INT 0
28859: PUSH
28860: LD_INT 2
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: PUSH
28867: LD_INT 1
28869: NEG
28870: PUSH
28871: LD_INT 1
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 2
28880: NEG
28881: PUSH
28882: LD_INT 0
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 2
28891: NEG
28892: PUSH
28893: LD_INT 1
28895: NEG
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 2
28903: NEG
28904: PUSH
28905: LD_INT 2
28907: NEG
28908: PUSH
28909: EMPTY
28910: LIST
28911: LIST
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
28934: LD_ADDR_VAR 0 59
28938: PUSH
28939: LD_INT 0
28941: PUSH
28942: LD_INT 0
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: PUSH
28949: LD_INT 0
28951: PUSH
28952: LD_INT 1
28954: NEG
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 1
28962: PUSH
28963: LD_INT 0
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 1
28972: PUSH
28973: LD_INT 1
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: LD_INT 1
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 1
28992: NEG
28993: PUSH
28994: LD_INT 0
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: LD_INT 1
29003: NEG
29004: PUSH
29005: LD_INT 1
29007: NEG
29008: PUSH
29009: EMPTY
29010: LIST
29011: LIST
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29022: LD_ADDR_VAR 0 60
29026: PUSH
29027: LD_INT 0
29029: PUSH
29030: LD_INT 0
29032: PUSH
29033: EMPTY
29034: LIST
29035: LIST
29036: PUSH
29037: LD_INT 0
29039: PUSH
29040: LD_INT 1
29042: NEG
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 1
29050: PUSH
29051: LD_INT 0
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 0
29070: PUSH
29071: LD_INT 1
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 1
29080: NEG
29081: PUSH
29082: LD_INT 0
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: LD_INT 1
29091: NEG
29092: PUSH
29093: LD_INT 1
29095: NEG
29096: PUSH
29097: EMPTY
29098: LIST
29099: LIST
29100: PUSH
29101: EMPTY
29102: LIST
29103: LIST
29104: LIST
29105: LIST
29106: LIST
29107: LIST
29108: LIST
29109: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29110: LD_ADDR_VAR 0 61
29114: PUSH
29115: LD_INT 0
29117: PUSH
29118: LD_INT 0
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 0
29127: PUSH
29128: LD_INT 1
29130: NEG
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: PUSH
29139: LD_INT 0
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 1
29148: PUSH
29149: LD_INT 1
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 0
29158: PUSH
29159: LD_INT 1
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 1
29168: NEG
29169: PUSH
29170: LD_INT 0
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 1
29179: NEG
29180: PUSH
29181: LD_INT 1
29183: NEG
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: LIST
29193: LIST
29194: LIST
29195: LIST
29196: LIST
29197: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29198: LD_ADDR_VAR 0 62
29202: PUSH
29203: LD_INT 0
29205: PUSH
29206: LD_INT 0
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PUSH
29213: LD_INT 0
29215: PUSH
29216: LD_INT 1
29218: NEG
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: PUSH
29224: LD_INT 1
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 1
29236: PUSH
29237: LD_INT 1
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: PUSH
29244: LD_INT 0
29246: PUSH
29247: LD_INT 1
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: PUSH
29254: LD_INT 1
29256: NEG
29257: PUSH
29258: LD_INT 0
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 1
29267: NEG
29268: PUSH
29269: LD_INT 1
29271: NEG
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29286: LD_ADDR_VAR 0 63
29290: PUSH
29291: LD_INT 0
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: EMPTY
29298: LIST
29299: LIST
29300: PUSH
29301: LD_INT 0
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 1
29314: PUSH
29315: LD_INT 0
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 0
29334: PUSH
29335: LD_INT 1
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 1
29344: NEG
29345: PUSH
29346: LD_INT 0
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: LD_INT 1
29355: NEG
29356: PUSH
29357: LD_INT 1
29359: NEG
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: LIST
29369: LIST
29370: LIST
29371: LIST
29372: LIST
29373: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29374: LD_ADDR_VAR 0 64
29378: PUSH
29379: LD_INT 0
29381: PUSH
29382: LD_INT 0
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: PUSH
29389: LD_INT 0
29391: PUSH
29392: LD_INT 1
29394: NEG
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PUSH
29400: LD_INT 1
29402: PUSH
29403: LD_INT 0
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 1
29412: PUSH
29413: LD_INT 1
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 0
29422: PUSH
29423: LD_INT 1
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 1
29432: NEG
29433: PUSH
29434: LD_INT 0
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 1
29443: NEG
29444: PUSH
29445: LD_INT 1
29447: NEG
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: LIST
29461: ST_TO_ADDR
// end ; 1 :
29462: GO 35359
29464: LD_INT 1
29466: DOUBLE
29467: EQUAL
29468: IFTRUE 29472
29470: GO 32095
29472: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29473: LD_ADDR_VAR 0 11
29477: PUSH
29478: LD_INT 1
29480: NEG
29481: PUSH
29482: LD_INT 3
29484: NEG
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 0
29492: PUSH
29493: LD_INT 3
29495: NEG
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: LD_INT 2
29506: NEG
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: LIST
29516: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29517: LD_ADDR_VAR 0 12
29521: PUSH
29522: LD_INT 2
29524: PUSH
29525: LD_INT 1
29527: NEG
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 3
29535: PUSH
29536: LD_INT 0
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: LD_INT 3
29545: PUSH
29546: LD_INT 1
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: LIST
29557: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29558: LD_ADDR_VAR 0 13
29562: PUSH
29563: LD_INT 3
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PUSH
29573: LD_INT 3
29575: PUSH
29576: LD_INT 3
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PUSH
29583: LD_INT 2
29585: PUSH
29586: LD_INT 3
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: LIST
29597: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29598: LD_ADDR_VAR 0 14
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: LD_INT 3
29608: PUSH
29609: EMPTY
29610: LIST
29611: LIST
29612: PUSH
29613: LD_INT 0
29615: PUSH
29616: LD_INT 3
29618: PUSH
29619: EMPTY
29620: LIST
29621: LIST
29622: PUSH
29623: LD_INT 1
29625: NEG
29626: PUSH
29627: LD_INT 2
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: LIST
29638: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29639: LD_ADDR_VAR 0 15
29643: PUSH
29644: LD_INT 2
29646: NEG
29647: PUSH
29648: LD_INT 1
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 3
29657: NEG
29658: PUSH
29659: LD_INT 0
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: PUSH
29666: LD_INT 3
29668: NEG
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: LIST
29682: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29683: LD_ADDR_VAR 0 16
29687: PUSH
29688: LD_INT 2
29690: NEG
29691: PUSH
29692: LD_INT 3
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 3
29702: NEG
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 3
29714: NEG
29715: PUSH
29716: LD_INT 3
29718: NEG
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: LIST
29728: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29729: LD_ADDR_VAR 0 17
29733: PUSH
29734: LD_INT 1
29736: NEG
29737: PUSH
29738: LD_INT 3
29740: NEG
29741: PUSH
29742: EMPTY
29743: LIST
29744: LIST
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: LD_INT 3
29751: NEG
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: PUSH
29757: LD_INT 1
29759: PUSH
29760: LD_INT 2
29762: NEG
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: LIST
29772: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29773: LD_ADDR_VAR 0 18
29777: PUSH
29778: LD_INT 2
29780: PUSH
29781: LD_INT 1
29783: NEG
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: PUSH
29789: LD_INT 3
29791: PUSH
29792: LD_INT 0
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 3
29801: PUSH
29802: LD_INT 1
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: LIST
29813: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29814: LD_ADDR_VAR 0 19
29818: PUSH
29819: LD_INT 3
29821: PUSH
29822: LD_INT 2
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 3
29831: PUSH
29832: LD_INT 3
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 2
29841: PUSH
29842: LD_INT 3
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: LIST
29853: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29854: LD_ADDR_VAR 0 20
29858: PUSH
29859: LD_INT 1
29861: PUSH
29862: LD_INT 3
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: PUSH
29869: LD_INT 0
29871: PUSH
29872: LD_INT 3
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: PUSH
29879: LD_INT 1
29881: NEG
29882: PUSH
29883: LD_INT 2
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: LIST
29894: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29895: LD_ADDR_VAR 0 21
29899: PUSH
29900: LD_INT 2
29902: NEG
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 3
29913: NEG
29914: PUSH
29915: LD_INT 0
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 3
29924: NEG
29925: PUSH
29926: LD_INT 1
29928: NEG
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: LIST
29938: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29939: LD_ADDR_VAR 0 22
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: LD_INT 3
29950: NEG
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 3
29958: NEG
29959: PUSH
29960: LD_INT 2
29962: NEG
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 3
29970: NEG
29971: PUSH
29972: LD_INT 3
29974: NEG
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: LIST
29984: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
29985: LD_ADDR_VAR 0 23
29989: PUSH
29990: LD_INT 0
29992: PUSH
29993: LD_INT 3
29995: NEG
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 1
30003: NEG
30004: PUSH
30005: LD_INT 4
30007: NEG
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: LD_INT 1
30015: PUSH
30016: LD_INT 3
30018: NEG
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: LIST
30028: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
30029: LD_ADDR_VAR 0 24
30033: PUSH
30034: LD_INT 3
30036: PUSH
30037: LD_INT 0
30039: PUSH
30040: EMPTY
30041: LIST
30042: LIST
30043: PUSH
30044: LD_INT 3
30046: PUSH
30047: LD_INT 1
30049: NEG
30050: PUSH
30051: EMPTY
30052: LIST
30053: LIST
30054: PUSH
30055: LD_INT 4
30057: PUSH
30058: LD_INT 1
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: LIST
30069: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
30070: LD_ADDR_VAR 0 25
30074: PUSH
30075: LD_INT 3
30077: PUSH
30078: LD_INT 3
30080: PUSH
30081: EMPTY
30082: LIST
30083: LIST
30084: PUSH
30085: LD_INT 4
30087: PUSH
30088: LD_INT 3
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 3
30097: PUSH
30098: LD_INT 4
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: LIST
30109: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
30110: LD_ADDR_VAR 0 26
30114: PUSH
30115: LD_INT 0
30117: PUSH
30118: LD_INT 3
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 1
30127: PUSH
30128: LD_INT 4
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 1
30137: NEG
30138: PUSH
30139: LD_INT 3
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: LIST
30150: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
30151: LD_ADDR_VAR 0 27
30155: PUSH
30156: LD_INT 3
30158: NEG
30159: PUSH
30160: LD_INT 0
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 3
30169: NEG
30170: PUSH
30171: LD_INT 1
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 4
30180: NEG
30181: PUSH
30182: LD_INT 1
30184: NEG
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: LIST
30194: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
30195: LD_ADDR_VAR 0 28
30199: PUSH
30200: LD_INT 3
30202: NEG
30203: PUSH
30204: LD_INT 3
30206: NEG
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 3
30214: NEG
30215: PUSH
30216: LD_INT 4
30218: NEG
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 4
30226: NEG
30227: PUSH
30228: LD_INT 3
30230: NEG
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: LIST
30240: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
30241: LD_ADDR_VAR 0 29
30245: PUSH
30246: LD_INT 1
30248: NEG
30249: PUSH
30250: LD_INT 3
30252: NEG
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 0
30260: PUSH
30261: LD_INT 3
30263: NEG
30264: PUSH
30265: EMPTY
30266: LIST
30267: LIST
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: LD_INT 2
30274: NEG
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: LD_INT 4
30286: NEG
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 0
30294: PUSH
30295: LD_INT 4
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: LD_INT 3
30308: NEG
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 1
30316: NEG
30317: PUSH
30318: LD_INT 5
30320: NEG
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: PUSH
30326: LD_INT 0
30328: PUSH
30329: LD_INT 5
30331: NEG
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 1
30339: PUSH
30340: LD_INT 4
30342: NEG
30343: PUSH
30344: EMPTY
30345: LIST
30346: LIST
30347: PUSH
30348: LD_INT 1
30350: NEG
30351: PUSH
30352: LD_INT 6
30354: NEG
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 0
30362: PUSH
30363: LD_INT 6
30365: NEG
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 1
30373: PUSH
30374: LD_INT 5
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
30396: LD_ADDR_VAR 0 30
30400: PUSH
30401: LD_INT 2
30403: PUSH
30404: LD_INT 1
30406: NEG
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 3
30414: PUSH
30415: LD_INT 0
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 3
30424: PUSH
30425: LD_INT 1
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 3
30434: PUSH
30435: LD_INT 1
30437: NEG
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 4
30445: PUSH
30446: LD_INT 0
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 4
30455: PUSH
30456: LD_INT 1
30458: PUSH
30459: EMPTY
30460: LIST
30461: LIST
30462: PUSH
30463: LD_INT 4
30465: PUSH
30466: LD_INT 1
30468: NEG
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PUSH
30474: LD_INT 5
30476: PUSH
30477: LD_INT 0
30479: PUSH
30480: EMPTY
30481: LIST
30482: LIST
30483: PUSH
30484: LD_INT 5
30486: PUSH
30487: LD_INT 1
30489: PUSH
30490: EMPTY
30491: LIST
30492: LIST
30493: PUSH
30494: LD_INT 5
30496: PUSH
30497: LD_INT 1
30499: NEG
30500: PUSH
30501: EMPTY
30502: LIST
30503: LIST
30504: PUSH
30505: LD_INT 6
30507: PUSH
30508: LD_INT 0
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: PUSH
30515: LD_INT 6
30517: PUSH
30518: LD_INT 1
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
30539: LD_ADDR_VAR 0 31
30543: PUSH
30544: LD_INT 3
30546: PUSH
30547: LD_INT 2
30549: PUSH
30550: EMPTY
30551: LIST
30552: LIST
30553: PUSH
30554: LD_INT 3
30556: PUSH
30557: LD_INT 3
30559: PUSH
30560: EMPTY
30561: LIST
30562: LIST
30563: PUSH
30564: LD_INT 2
30566: PUSH
30567: LD_INT 3
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 4
30576: PUSH
30577: LD_INT 3
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 4
30586: PUSH
30587: LD_INT 4
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 3
30596: PUSH
30597: LD_INT 4
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: LD_INT 5
30606: PUSH
30607: LD_INT 4
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 5
30616: PUSH
30617: LD_INT 5
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: PUSH
30624: LD_INT 4
30626: PUSH
30627: LD_INT 5
30629: PUSH
30630: EMPTY
30631: LIST
30632: LIST
30633: PUSH
30634: LD_INT 6
30636: PUSH
30637: LD_INT 5
30639: PUSH
30640: EMPTY
30641: LIST
30642: LIST
30643: PUSH
30644: LD_INT 6
30646: PUSH
30647: LD_INT 6
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 5
30656: PUSH
30657: LD_INT 6
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: LIST
30668: LIST
30669: LIST
30670: LIST
30671: LIST
30672: LIST
30673: LIST
30674: LIST
30675: LIST
30676: LIST
30677: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
30678: LD_ADDR_VAR 0 32
30682: PUSH
30683: LD_INT 1
30685: PUSH
30686: LD_INT 3
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: LD_INT 3
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: LD_INT 1
30705: NEG
30706: PUSH
30707: LD_INT 2
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 1
30716: PUSH
30717: LD_INT 4
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 0
30726: PUSH
30727: LD_INT 4
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: NEG
30737: PUSH
30738: LD_INT 3
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: LD_INT 5
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 0
30757: PUSH
30758: LD_INT 5
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: LD_INT 4
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 1
30778: PUSH
30779: LD_INT 6
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 0
30788: PUSH
30789: LD_INT 6
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: NEG
30799: PUSH
30800: LD_INT 5
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: LIST
30820: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
30821: LD_ADDR_VAR 0 33
30825: PUSH
30826: LD_INT 2
30828: NEG
30829: PUSH
30830: LD_INT 1
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 3
30839: NEG
30840: PUSH
30841: LD_INT 0
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 3
30850: NEG
30851: PUSH
30852: LD_INT 1
30854: NEG
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 3
30862: NEG
30863: PUSH
30864: LD_INT 1
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 4
30873: NEG
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 4
30884: NEG
30885: PUSH
30886: LD_INT 1
30888: NEG
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 4
30896: NEG
30897: PUSH
30898: LD_INT 1
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 5
30907: NEG
30908: PUSH
30909: LD_INT 0
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 5
30918: NEG
30919: PUSH
30920: LD_INT 1
30922: NEG
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 5
30930: NEG
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 6
30941: NEG
30942: PUSH
30943: LD_INT 0
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 6
30952: NEG
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
30976: LD_ADDR_VAR 0 34
30980: PUSH
30981: LD_INT 2
30983: NEG
30984: PUSH
30985: LD_INT 3
30987: NEG
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PUSH
30993: LD_INT 3
30995: NEG
30996: PUSH
30997: LD_INT 2
30999: NEG
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 3
31007: NEG
31008: PUSH
31009: LD_INT 3
31011: NEG
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 3
31019: NEG
31020: PUSH
31021: LD_INT 4
31023: NEG
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 4
31031: NEG
31032: PUSH
31033: LD_INT 3
31035: NEG
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 4
31043: NEG
31044: PUSH
31045: LD_INT 4
31047: NEG
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 4
31055: NEG
31056: PUSH
31057: LD_INT 5
31059: NEG
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: LD_INT 5
31067: NEG
31068: PUSH
31069: LD_INT 4
31071: NEG
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 5
31079: NEG
31080: PUSH
31081: LD_INT 5
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 5
31091: NEG
31092: PUSH
31093: LD_INT 6
31095: NEG
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 6
31103: NEG
31104: PUSH
31105: LD_INT 5
31107: NEG
31108: PUSH
31109: EMPTY
31110: LIST
31111: LIST
31112: PUSH
31113: LD_INT 6
31115: NEG
31116: PUSH
31117: LD_INT 6
31119: NEG
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
31139: LD_ADDR_VAR 0 41
31143: PUSH
31144: LD_INT 0
31146: PUSH
31147: LD_INT 2
31149: NEG
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 1
31157: NEG
31158: PUSH
31159: LD_INT 3
31161: NEG
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 1
31169: PUSH
31170: LD_INT 2
31172: NEG
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: LIST
31182: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
31183: LD_ADDR_VAR 0 42
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: LD_INT 0
31193: PUSH
31194: EMPTY
31195: LIST
31196: LIST
31197: PUSH
31198: LD_INT 2
31200: PUSH
31201: LD_INT 1
31203: NEG
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 3
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: LIST
31223: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
31224: LD_ADDR_VAR 0 43
31228: PUSH
31229: LD_INT 2
31231: PUSH
31232: LD_INT 2
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 3
31241: PUSH
31242: LD_INT 2
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 2
31251: PUSH
31252: LD_INT 3
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: LIST
31263: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
31264: LD_ADDR_VAR 0 44
31268: PUSH
31269: LD_INT 0
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 1
31281: PUSH
31282: LD_INT 3
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: LD_INT 2
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: LIST
31304: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31305: LD_ADDR_VAR 0 45
31309: PUSH
31310: LD_INT 2
31312: NEG
31313: PUSH
31314: LD_INT 0
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 2
31323: NEG
31324: PUSH
31325: LD_INT 1
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 3
31334: NEG
31335: PUSH
31336: LD_INT 1
31338: NEG
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: LIST
31348: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
31349: LD_ADDR_VAR 0 46
31353: PUSH
31354: LD_INT 2
31356: NEG
31357: PUSH
31358: LD_INT 2
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 2
31368: NEG
31369: PUSH
31370: LD_INT 3
31372: NEG
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 3
31380: NEG
31381: PUSH
31382: LD_INT 2
31384: NEG
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: LIST
31394: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
31395: LD_ADDR_VAR 0 47
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: LD_INT 3
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 1
31414: NEG
31415: PUSH
31416: LD_INT 3
31418: NEG
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31428: LD_ADDR_VAR 0 48
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: LD_INT 2
31438: NEG
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 2
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
31459: LD_ADDR_VAR 0 49
31463: PUSH
31464: LD_INT 3
31466: PUSH
31467: LD_INT 1
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PUSH
31474: LD_INT 3
31476: PUSH
31477: LD_INT 2
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
31488: LD_ADDR_VAR 0 50
31492: PUSH
31493: LD_INT 2
31495: PUSH
31496: LD_INT 3
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 1
31505: PUSH
31506: LD_INT 3
31508: PUSH
31509: EMPTY
31510: LIST
31511: LIST
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31517: LD_ADDR_VAR 0 51
31521: PUSH
31522: LD_INT 1
31524: NEG
31525: PUSH
31526: LD_INT 2
31528: PUSH
31529: EMPTY
31530: LIST
31531: LIST
31532: PUSH
31533: LD_INT 2
31535: NEG
31536: PUSH
31537: LD_INT 1
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31548: LD_ADDR_VAR 0 52
31552: PUSH
31553: LD_INT 3
31555: NEG
31556: PUSH
31557: LD_INT 1
31559: NEG
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 3
31567: NEG
31568: PUSH
31569: LD_INT 2
31571: NEG
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31581: LD_ADDR_VAR 0 53
31585: PUSH
31586: LD_INT 1
31588: NEG
31589: PUSH
31590: LD_INT 3
31592: NEG
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 0
31600: PUSH
31601: LD_INT 3
31603: NEG
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: LD_INT 1
31611: PUSH
31612: LD_INT 2
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: EMPTY
31621: LIST
31622: LIST
31623: LIST
31624: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31625: LD_ADDR_VAR 0 54
31629: PUSH
31630: LD_INT 2
31632: PUSH
31633: LD_INT 1
31635: NEG
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 3
31643: PUSH
31644: LD_INT 0
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: LD_INT 3
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: LIST
31665: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31666: LD_ADDR_VAR 0 55
31670: PUSH
31671: LD_INT 3
31673: PUSH
31674: LD_INT 2
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: LD_INT 3
31683: PUSH
31684: LD_INT 3
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PUSH
31691: LD_INT 2
31693: PUSH
31694: LD_INT 3
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: LIST
31705: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
31706: LD_ADDR_VAR 0 56
31710: PUSH
31711: LD_INT 1
31713: PUSH
31714: LD_INT 3
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: LD_INT 3
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 1
31733: NEG
31734: PUSH
31735: LD_INT 2
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: LIST
31746: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31747: LD_ADDR_VAR 0 57
31751: PUSH
31752: LD_INT 2
31754: NEG
31755: PUSH
31756: LD_INT 1
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: LD_INT 3
31765: NEG
31766: PUSH
31767: LD_INT 0
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 3
31776: NEG
31777: PUSH
31778: LD_INT 1
31780: NEG
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: LIST
31790: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31791: LD_ADDR_VAR 0 58
31795: PUSH
31796: LD_INT 2
31798: NEG
31799: PUSH
31800: LD_INT 3
31802: NEG
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 3
31810: NEG
31811: PUSH
31812: LD_INT 2
31814: NEG
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 3
31822: NEG
31823: PUSH
31824: LD_INT 3
31826: NEG
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: LIST
31836: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
31837: LD_ADDR_VAR 0 59
31841: PUSH
31842: LD_INT 1
31844: NEG
31845: PUSH
31846: LD_INT 2
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: LD_INT 2
31859: NEG
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 1
31867: PUSH
31868: LD_INT 1
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: LIST
31880: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
31881: LD_ADDR_VAR 0 60
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: LD_INT 1
31891: NEG
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 2
31899: PUSH
31900: LD_INT 0
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 2
31909: PUSH
31910: LD_INT 1
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: LIST
31921: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
31922: LD_ADDR_VAR 0 61
31926: PUSH
31927: LD_INT 2
31929: PUSH
31930: LD_INT 1
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 2
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 1
31949: PUSH
31950: LD_INT 2
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: LIST
31961: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
31962: LD_ADDR_VAR 0 62
31966: PUSH
31967: LD_INT 1
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 0
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: LIST
32002: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32003: LD_ADDR_VAR 0 63
32007: PUSH
32008: LD_INT 1
32010: NEG
32011: PUSH
32012: LD_INT 1
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 2
32021: NEG
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 2
32032: NEG
32033: PUSH
32034: LD_INT 1
32036: NEG
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: LIST
32046: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32047: LD_ADDR_VAR 0 64
32051: PUSH
32052: LD_INT 1
32054: NEG
32055: PUSH
32056: LD_INT 2
32058: NEG
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: PUSH
32064: LD_INT 2
32066: NEG
32067: PUSH
32068: LD_INT 1
32070: NEG
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: NEG
32079: PUSH
32080: LD_INT 2
32082: NEG
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: LIST
32092: ST_TO_ADDR
// end ; 2 :
32093: GO 35359
32095: LD_INT 2
32097: DOUBLE
32098: EQUAL
32099: IFTRUE 32103
32101: GO 35358
32103: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
32104: LD_ADDR_VAR 0 29
32108: PUSH
32109: LD_INT 4
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 4
32121: PUSH
32122: LD_INT 1
32124: NEG
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 5
32132: PUSH
32133: LD_INT 0
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 5
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 4
32152: PUSH
32153: LD_INT 1
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 3
32162: PUSH
32163: LD_INT 0
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 3
32172: PUSH
32173: LD_INT 1
32175: NEG
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 3
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 5
32194: PUSH
32195: LD_INT 2
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: PUSH
32202: LD_INT 3
32204: PUSH
32205: LD_INT 3
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 3
32214: PUSH
32215: LD_INT 2
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 4
32224: PUSH
32225: LD_INT 3
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 4
32234: PUSH
32235: LD_INT 4
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 3
32244: PUSH
32245: LD_INT 4
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 2
32254: PUSH
32255: LD_INT 3
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 2
32264: PUSH
32265: LD_INT 2
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 4
32274: PUSH
32275: LD_INT 2
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: LD_INT 4
32287: PUSH
32288: EMPTY
32289: LIST
32290: LIST
32291: PUSH
32292: LD_INT 0
32294: PUSH
32295: LD_INT 4
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 0
32304: PUSH
32305: LD_INT 3
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 1
32314: PUSH
32315: LD_INT 4
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 1
32324: PUSH
32325: LD_INT 5
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 0
32334: PUSH
32335: LD_INT 5
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 1
32344: NEG
32345: PUSH
32346: LD_INT 4
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 1
32355: NEG
32356: PUSH
32357: LD_INT 3
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 2
32366: PUSH
32367: LD_INT 5
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: NEG
32377: PUSH
32378: LD_INT 3
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 3
32387: NEG
32388: PUSH
32389: LD_INT 0
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 3
32398: NEG
32399: PUSH
32400: LD_INT 1
32402: NEG
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 2
32410: NEG
32411: PUSH
32412: LD_INT 0
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 2
32421: NEG
32422: PUSH
32423: LD_INT 1
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 3
32432: NEG
32433: PUSH
32434: LD_INT 1
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: LD_INT 4
32443: NEG
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 4
32454: NEG
32455: PUSH
32456: LD_INT 1
32458: NEG
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 4
32466: NEG
32467: PUSH
32468: LD_INT 2
32470: NEG
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 2
32478: NEG
32479: PUSH
32480: LD_INT 2
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 4
32489: NEG
32490: PUSH
32491: LD_INT 4
32493: NEG
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 4
32501: NEG
32502: PUSH
32503: LD_INT 5
32505: NEG
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 3
32513: NEG
32514: PUSH
32515: LD_INT 4
32517: NEG
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 3
32525: NEG
32526: PUSH
32527: LD_INT 3
32529: NEG
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 4
32537: NEG
32538: PUSH
32539: LD_INT 3
32541: NEG
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 5
32549: NEG
32550: PUSH
32551: LD_INT 4
32553: NEG
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 5
32561: NEG
32562: PUSH
32563: LD_INT 5
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 3
32573: NEG
32574: PUSH
32575: LD_INT 5
32577: NEG
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 5
32585: NEG
32586: PUSH
32587: LD_INT 3
32589: NEG
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: LIST
32623: LIST
32624: LIST
32625: LIST
32626: LIST
32627: LIST
32628: LIST
32629: LIST
32630: LIST
32631: LIST
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
32642: LD_ADDR_VAR 0 30
32646: PUSH
32647: LD_INT 4
32649: PUSH
32650: LD_INT 4
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PUSH
32657: LD_INT 4
32659: PUSH
32660: LD_INT 3
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 5
32669: PUSH
32670: LD_INT 4
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 5
32679: PUSH
32680: LD_INT 5
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: LD_INT 4
32689: PUSH
32690: LD_INT 5
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 3
32699: PUSH
32700: LD_INT 4
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 3
32709: PUSH
32710: LD_INT 3
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 5
32719: PUSH
32720: LD_INT 3
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 3
32729: PUSH
32730: LD_INT 5
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 0
32739: PUSH
32740: LD_INT 3
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: LD_INT 2
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: PUSH
32760: LD_INT 3
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 1
32769: PUSH
32770: LD_INT 4
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 0
32779: PUSH
32780: LD_INT 4
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 1
32789: NEG
32790: PUSH
32791: LD_INT 3
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 1
32800: NEG
32801: PUSH
32802: LD_INT 2
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: LD_INT 4
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 2
32821: NEG
32822: PUSH
32823: LD_INT 2
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 4
32832: NEG
32833: PUSH
32834: LD_INT 0
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 4
32843: NEG
32844: PUSH
32845: LD_INT 1
32847: NEG
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 3
32855: NEG
32856: PUSH
32857: LD_INT 0
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 3
32866: NEG
32867: PUSH
32868: LD_INT 1
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 4
32877: NEG
32878: PUSH
32879: LD_INT 1
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 5
32888: NEG
32889: PUSH
32890: LD_INT 0
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 5
32899: NEG
32900: PUSH
32901: LD_INT 1
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 5
32911: NEG
32912: PUSH
32913: LD_INT 2
32915: NEG
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 3
32923: NEG
32924: PUSH
32925: LD_INT 2
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 3
32934: NEG
32935: PUSH
32936: LD_INT 3
32938: NEG
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 3
32946: NEG
32947: PUSH
32948: LD_INT 4
32950: NEG
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 2
32958: NEG
32959: PUSH
32960: LD_INT 3
32962: NEG
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 2
32970: NEG
32971: PUSH
32972: LD_INT 2
32974: NEG
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 3
32982: NEG
32983: PUSH
32984: LD_INT 2
32986: NEG
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 4
32994: NEG
32995: PUSH
32996: LD_INT 3
32998: NEG
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: LD_INT 4
33006: NEG
33007: PUSH
33008: LD_INT 4
33010: NEG
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: LD_INT 2
33018: NEG
33019: PUSH
33020: LD_INT 4
33022: NEG
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 4
33030: NEG
33031: PUSH
33032: LD_INT 2
33034: NEG
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 0
33042: PUSH
33043: LD_INT 4
33045: NEG
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 0
33053: PUSH
33054: LD_INT 5
33056: NEG
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: LD_INT 4
33067: NEG
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 1
33075: PUSH
33076: LD_INT 3
33078: NEG
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: LD_INT 3
33089: NEG
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 1
33097: NEG
33098: PUSH
33099: LD_INT 4
33101: NEG
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: LD_INT 1
33109: NEG
33110: PUSH
33111: LD_INT 5
33113: NEG
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 2
33121: PUSH
33122: LD_INT 3
33124: NEG
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 2
33132: NEG
33133: PUSH
33134: LD_INT 5
33136: NEG
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: LIST
33176: LIST
33177: LIST
33178: LIST
33179: LIST
33180: LIST
33181: LIST
33182: LIST
33183: LIST
33184: LIST
33185: LIST
33186: LIST
33187: LIST
33188: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
33189: LD_ADDR_VAR 0 31
33193: PUSH
33194: LD_INT 0
33196: PUSH
33197: LD_INT 4
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 0
33206: PUSH
33207: LD_INT 3
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 1
33216: PUSH
33217: LD_INT 4
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 1
33226: PUSH
33227: LD_INT 5
33229: PUSH
33230: EMPTY
33231: LIST
33232: LIST
33233: PUSH
33234: LD_INT 0
33236: PUSH
33237: LD_INT 5
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 1
33246: NEG
33247: PUSH
33248: LD_INT 4
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 1
33257: NEG
33258: PUSH
33259: LD_INT 3
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 2
33268: PUSH
33269: LD_INT 5
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 2
33278: NEG
33279: PUSH
33280: LD_INT 3
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: LD_INT 3
33289: NEG
33290: PUSH
33291: LD_INT 0
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 3
33300: NEG
33301: PUSH
33302: LD_INT 1
33304: NEG
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 2
33312: NEG
33313: PUSH
33314: LD_INT 0
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 2
33323: NEG
33324: PUSH
33325: LD_INT 1
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 3
33334: NEG
33335: PUSH
33336: LD_INT 1
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 4
33345: NEG
33346: PUSH
33347: LD_INT 0
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 4
33356: NEG
33357: PUSH
33358: LD_INT 1
33360: NEG
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 4
33368: NEG
33369: PUSH
33370: LD_INT 2
33372: NEG
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 2
33380: NEG
33381: PUSH
33382: LD_INT 2
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 4
33391: NEG
33392: PUSH
33393: LD_INT 4
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 4
33403: NEG
33404: PUSH
33405: LD_INT 5
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 3
33415: NEG
33416: PUSH
33417: LD_INT 4
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 3
33427: NEG
33428: PUSH
33429: LD_INT 3
33431: NEG
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: PUSH
33437: LD_INT 4
33439: NEG
33440: PUSH
33441: LD_INT 3
33443: NEG
33444: PUSH
33445: EMPTY
33446: LIST
33447: LIST
33448: PUSH
33449: LD_INT 5
33451: NEG
33452: PUSH
33453: LD_INT 4
33455: NEG
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: LD_INT 5
33463: NEG
33464: PUSH
33465: LD_INT 5
33467: NEG
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 3
33475: NEG
33476: PUSH
33477: LD_INT 5
33479: NEG
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PUSH
33485: LD_INT 5
33487: NEG
33488: PUSH
33489: LD_INT 3
33491: NEG
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 0
33499: PUSH
33500: LD_INT 3
33502: NEG
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 0
33510: PUSH
33511: LD_INT 4
33513: NEG
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 1
33521: PUSH
33522: LD_INT 3
33524: NEG
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 1
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 0
33543: PUSH
33544: LD_INT 2
33546: NEG
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: NEG
33555: PUSH
33556: LD_INT 3
33558: NEG
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 1
33566: NEG
33567: PUSH
33568: LD_INT 4
33570: NEG
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 2
33578: PUSH
33579: LD_INT 2
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 2
33589: NEG
33590: PUSH
33591: LD_INT 4
33593: NEG
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 4
33601: PUSH
33602: LD_INT 0
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 4
33611: PUSH
33612: LD_INT 1
33614: NEG
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 5
33622: PUSH
33623: LD_INT 0
33625: PUSH
33626: EMPTY
33627: LIST
33628: LIST
33629: PUSH
33630: LD_INT 5
33632: PUSH
33633: LD_INT 1
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 4
33642: PUSH
33643: LD_INT 1
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 3
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: LD_INT 1
33665: NEG
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 3
33673: PUSH
33674: LD_INT 2
33676: NEG
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 5
33684: PUSH
33685: LD_INT 2
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: LIST
33738: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
33739: LD_ADDR_VAR 0 32
33743: PUSH
33744: LD_INT 4
33746: NEG
33747: PUSH
33748: LD_INT 0
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 4
33757: NEG
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 3
33769: NEG
33770: PUSH
33771: LD_INT 0
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: LD_INT 3
33780: NEG
33781: PUSH
33782: LD_INT 1
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 4
33791: NEG
33792: PUSH
33793: LD_INT 1
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 5
33802: NEG
33803: PUSH
33804: LD_INT 0
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 5
33813: NEG
33814: PUSH
33815: LD_INT 1
33817: NEG
33818: PUSH
33819: EMPTY
33820: LIST
33821: LIST
33822: PUSH
33823: LD_INT 5
33825: NEG
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 3
33837: NEG
33838: PUSH
33839: LD_INT 2
33841: PUSH
33842: EMPTY
33843: LIST
33844: LIST
33845: PUSH
33846: LD_INT 3
33848: NEG
33849: PUSH
33850: LD_INT 3
33852: NEG
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 3
33860: NEG
33861: PUSH
33862: LD_INT 4
33864: NEG
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: LD_INT 2
33872: NEG
33873: PUSH
33874: LD_INT 3
33876: NEG
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 2
33884: NEG
33885: PUSH
33886: LD_INT 2
33888: NEG
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 3
33896: NEG
33897: PUSH
33898: LD_INT 2
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 4
33908: NEG
33909: PUSH
33910: LD_INT 3
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 4
33920: NEG
33921: PUSH
33922: LD_INT 4
33924: NEG
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 2
33932: NEG
33933: PUSH
33934: LD_INT 4
33936: NEG
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 4
33944: NEG
33945: PUSH
33946: LD_INT 2
33948: NEG
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: PUSH
33954: LD_INT 0
33956: PUSH
33957: LD_INT 4
33959: NEG
33960: PUSH
33961: EMPTY
33962: LIST
33963: LIST
33964: PUSH
33965: LD_INT 0
33967: PUSH
33968: LD_INT 5
33970: NEG
33971: PUSH
33972: EMPTY
33973: LIST
33974: LIST
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: LD_INT 4
33981: NEG
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 1
33989: PUSH
33990: LD_INT 3
33992: NEG
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: PUSH
33998: LD_INT 0
34000: PUSH
34001: LD_INT 3
34003: NEG
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 1
34011: NEG
34012: PUSH
34013: LD_INT 4
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: LD_INT 5
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 2
34035: PUSH
34036: LD_INT 3
34038: NEG
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: NEG
34047: PUSH
34048: LD_INT 5
34050: NEG
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: PUSH
34056: LD_INT 3
34058: PUSH
34059: LD_INT 0
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 3
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 4
34079: PUSH
34080: LD_INT 0
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: PUSH
34087: LD_INT 4
34089: PUSH
34090: LD_INT 1
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 3
34099: PUSH
34100: LD_INT 1
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 2
34109: PUSH
34110: LD_INT 0
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 2
34119: PUSH
34120: LD_INT 1
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: PUSH
34131: LD_INT 2
34133: NEG
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 4
34141: PUSH
34142: LD_INT 2
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 4
34151: PUSH
34152: LD_INT 4
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 4
34161: PUSH
34162: LD_INT 3
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PUSH
34169: LD_INT 5
34171: PUSH
34172: LD_INT 4
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 5
34181: PUSH
34182: LD_INT 5
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 4
34191: PUSH
34192: LD_INT 5
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 3
34201: PUSH
34202: LD_INT 4
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 3
34211: PUSH
34212: LD_INT 3
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 5
34221: PUSH
34222: LD_INT 3
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 3
34231: PUSH
34232: LD_INT 5
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: LIST
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
34286: LD_ADDR_VAR 0 33
34290: PUSH
34291: LD_INT 4
34293: NEG
34294: PUSH
34295: LD_INT 4
34297: NEG
34298: PUSH
34299: EMPTY
34300: LIST
34301: LIST
34302: PUSH
34303: LD_INT 4
34305: NEG
34306: PUSH
34307: LD_INT 5
34309: NEG
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 3
34317: NEG
34318: PUSH
34319: LD_INT 4
34321: NEG
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 3
34329: NEG
34330: PUSH
34331: LD_INT 3
34333: NEG
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 4
34341: NEG
34342: PUSH
34343: LD_INT 3
34345: NEG
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 5
34353: NEG
34354: PUSH
34355: LD_INT 4
34357: NEG
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 5
34365: NEG
34366: PUSH
34367: LD_INT 5
34369: NEG
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 3
34377: NEG
34378: PUSH
34379: LD_INT 5
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 5
34389: NEG
34390: PUSH
34391: LD_INT 3
34393: NEG
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 3
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 4
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 3
34426: NEG
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: LD_INT 2
34437: NEG
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: LD_INT 2
34448: NEG
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: LD_INT 3
34460: NEG
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: LD_INT 4
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 2
34480: PUSH
34481: LD_INT 2
34483: NEG
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 2
34491: NEG
34492: PUSH
34493: LD_INT 4
34495: NEG
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 4
34503: PUSH
34504: LD_INT 0
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 4
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 5
34524: PUSH
34525: LD_INT 0
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 5
34534: PUSH
34535: LD_INT 1
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 4
34544: PUSH
34545: LD_INT 1
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 3
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 3
34564: PUSH
34565: LD_INT 1
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 3
34575: PUSH
34576: LD_INT 2
34578: NEG
34579: PUSH
34580: EMPTY
34581: LIST
34582: LIST
34583: PUSH
34584: LD_INT 5
34586: PUSH
34587: LD_INT 2
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 3
34596: PUSH
34597: LD_INT 3
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 3
34606: PUSH
34607: LD_INT 2
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 4
34616: PUSH
34617: LD_INT 3
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 4
34626: PUSH
34627: LD_INT 4
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 3
34636: PUSH
34637: LD_INT 4
34639: PUSH
34640: EMPTY
34641: LIST
34642: LIST
34643: PUSH
34644: LD_INT 2
34646: PUSH
34647: LD_INT 3
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 2
34656: PUSH
34657: LD_INT 2
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 4
34666: PUSH
34667: LD_INT 2
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 2
34676: PUSH
34677: LD_INT 4
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 0
34686: PUSH
34687: LD_INT 4
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 0
34696: PUSH
34697: LD_INT 3
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: PUSH
34707: LD_INT 4
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 1
34716: PUSH
34717: LD_INT 5
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 0
34726: PUSH
34727: LD_INT 5
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 1
34736: NEG
34737: PUSH
34738: LD_INT 4
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: LD_INT 3
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: LD_INT 2
34758: PUSH
34759: LD_INT 5
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 2
34768: NEG
34769: PUSH
34770: LD_INT 3
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: LIST
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
34824: LD_ADDR_VAR 0 34
34828: PUSH
34829: LD_INT 0
34831: PUSH
34832: LD_INT 4
34834: NEG
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: LD_INT 5
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: LD_INT 4
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: LD_INT 3
34867: NEG
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 0
34875: PUSH
34876: LD_INT 3
34878: NEG
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 1
34886: NEG
34887: PUSH
34888: LD_INT 4
34890: NEG
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 1
34898: NEG
34899: PUSH
34900: LD_INT 5
34902: NEG
34903: PUSH
34904: EMPTY
34905: LIST
34906: LIST
34907: PUSH
34908: LD_INT 2
34910: PUSH
34911: LD_INT 3
34913: NEG
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: LD_INT 5
34925: NEG
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 3
34933: PUSH
34934: LD_INT 0
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 3
34943: PUSH
34944: LD_INT 1
34946: NEG
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 4
34954: PUSH
34955: LD_INT 0
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 4
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 3
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 2
34984: PUSH
34985: LD_INT 0
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 2
34994: PUSH
34995: LD_INT 1
34997: NEG
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 2
35005: PUSH
35006: LD_INT 2
35008: NEG
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 4
35016: PUSH
35017: LD_INT 2
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 4
35026: PUSH
35027: LD_INT 4
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 4
35036: PUSH
35037: LD_INT 3
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 5
35046: PUSH
35047: LD_INT 4
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 5
35056: PUSH
35057: LD_INT 5
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 4
35066: PUSH
35067: LD_INT 5
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 3
35076: PUSH
35077: LD_INT 4
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 3
35086: PUSH
35087: LD_INT 3
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 5
35096: PUSH
35097: LD_INT 3
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 3
35106: PUSH
35107: LD_INT 5
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: LD_INT 3
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 0
35126: PUSH
35127: LD_INT 2
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: LD_INT 3
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 1
35146: PUSH
35147: LD_INT 4
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 0
35156: PUSH
35157: LD_INT 4
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 3
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: NEG
35178: PUSH
35179: LD_INT 2
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: LD_INT 2
35188: PUSH
35189: LD_INT 4
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 2
35198: NEG
35199: PUSH
35200: LD_INT 2
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 4
35209: NEG
35210: PUSH
35211: LD_INT 0
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 4
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: NEG
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: LD_INT 3
35232: NEG
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 3
35243: NEG
35244: PUSH
35245: LD_INT 1
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 4
35254: NEG
35255: PUSH
35256: LD_INT 1
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 5
35265: NEG
35266: PUSH
35267: LD_INT 0
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 5
35276: NEG
35277: PUSH
35278: LD_INT 1
35280: NEG
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 5
35288: NEG
35289: PUSH
35290: LD_INT 2
35292: NEG
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 3
35300: NEG
35301: PUSH
35302: LD_INT 2
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: LIST
35320: LIST
35321: LIST
35322: LIST
35323: LIST
35324: LIST
35325: LIST
35326: LIST
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: LIST
35332: LIST
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: ST_TO_ADDR
// end ; end ;
35356: GO 35359
35358: POP
// case btype of b_depot , b_warehouse :
35359: LD_VAR 0 1
35363: PUSH
35364: LD_INT 0
35366: DOUBLE
35367: EQUAL
35368: IFTRUE 35378
35370: LD_INT 1
35372: DOUBLE
35373: EQUAL
35374: IFTRUE 35378
35376: GO 35579
35378: POP
// case nation of nation_american :
35379: LD_VAR 0 5
35383: PUSH
35384: LD_INT 1
35386: DOUBLE
35387: EQUAL
35388: IFTRUE 35392
35390: GO 35448
35392: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
35393: LD_ADDR_VAR 0 9
35397: PUSH
35398: LD_VAR 0 11
35402: PUSH
35403: LD_VAR 0 12
35407: PUSH
35408: LD_VAR 0 13
35412: PUSH
35413: LD_VAR 0 14
35417: PUSH
35418: LD_VAR 0 15
35422: PUSH
35423: LD_VAR 0 16
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: PUSH
35436: LD_VAR 0 4
35440: PUSH
35441: LD_INT 1
35443: PLUS
35444: ARRAY
35445: ST_TO_ADDR
35446: GO 35577
35448: LD_INT 2
35450: DOUBLE
35451: EQUAL
35452: IFTRUE 35456
35454: GO 35512
35456: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
35457: LD_ADDR_VAR 0 9
35461: PUSH
35462: LD_VAR 0 17
35466: PUSH
35467: LD_VAR 0 18
35471: PUSH
35472: LD_VAR 0 19
35476: PUSH
35477: LD_VAR 0 20
35481: PUSH
35482: LD_VAR 0 21
35486: PUSH
35487: LD_VAR 0 22
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: PUSH
35500: LD_VAR 0 4
35504: PUSH
35505: LD_INT 1
35507: PLUS
35508: ARRAY
35509: ST_TO_ADDR
35510: GO 35577
35512: LD_INT 3
35514: DOUBLE
35515: EQUAL
35516: IFTRUE 35520
35518: GO 35576
35520: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
35521: LD_ADDR_VAR 0 9
35525: PUSH
35526: LD_VAR 0 23
35530: PUSH
35531: LD_VAR 0 24
35535: PUSH
35536: LD_VAR 0 25
35540: PUSH
35541: LD_VAR 0 26
35545: PUSH
35546: LD_VAR 0 27
35550: PUSH
35551: LD_VAR 0 28
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: PUSH
35564: LD_VAR 0 4
35568: PUSH
35569: LD_INT 1
35571: PLUS
35572: ARRAY
35573: ST_TO_ADDR
35574: GO 35577
35576: POP
35577: GO 36132
35579: LD_INT 2
35581: DOUBLE
35582: EQUAL
35583: IFTRUE 35593
35585: LD_INT 3
35587: DOUBLE
35588: EQUAL
35589: IFTRUE 35593
35591: GO 35649
35593: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
35594: LD_ADDR_VAR 0 9
35598: PUSH
35599: LD_VAR 0 29
35603: PUSH
35604: LD_VAR 0 30
35608: PUSH
35609: LD_VAR 0 31
35613: PUSH
35614: LD_VAR 0 32
35618: PUSH
35619: LD_VAR 0 33
35623: PUSH
35624: LD_VAR 0 34
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: PUSH
35637: LD_VAR 0 4
35641: PUSH
35642: LD_INT 1
35644: PLUS
35645: ARRAY
35646: ST_TO_ADDR
35647: GO 36132
35649: LD_INT 16
35651: DOUBLE
35652: EQUAL
35653: IFTRUE 35711
35655: LD_INT 17
35657: DOUBLE
35658: EQUAL
35659: IFTRUE 35711
35661: LD_INT 18
35663: DOUBLE
35664: EQUAL
35665: IFTRUE 35711
35667: LD_INT 19
35669: DOUBLE
35670: EQUAL
35671: IFTRUE 35711
35673: LD_INT 22
35675: DOUBLE
35676: EQUAL
35677: IFTRUE 35711
35679: LD_INT 20
35681: DOUBLE
35682: EQUAL
35683: IFTRUE 35711
35685: LD_INT 21
35687: DOUBLE
35688: EQUAL
35689: IFTRUE 35711
35691: LD_INT 23
35693: DOUBLE
35694: EQUAL
35695: IFTRUE 35711
35697: LD_INT 24
35699: DOUBLE
35700: EQUAL
35701: IFTRUE 35711
35703: LD_INT 25
35705: DOUBLE
35706: EQUAL
35707: IFTRUE 35711
35709: GO 35767
35711: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
35712: LD_ADDR_VAR 0 9
35716: PUSH
35717: LD_VAR 0 35
35721: PUSH
35722: LD_VAR 0 36
35726: PUSH
35727: LD_VAR 0 37
35731: PUSH
35732: LD_VAR 0 38
35736: PUSH
35737: LD_VAR 0 39
35741: PUSH
35742: LD_VAR 0 40
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: LIST
35753: LIST
35754: PUSH
35755: LD_VAR 0 4
35759: PUSH
35760: LD_INT 1
35762: PLUS
35763: ARRAY
35764: ST_TO_ADDR
35765: GO 36132
35767: LD_INT 6
35769: DOUBLE
35770: EQUAL
35771: IFTRUE 35823
35773: LD_INT 7
35775: DOUBLE
35776: EQUAL
35777: IFTRUE 35823
35779: LD_INT 8
35781: DOUBLE
35782: EQUAL
35783: IFTRUE 35823
35785: LD_INT 13
35787: DOUBLE
35788: EQUAL
35789: IFTRUE 35823
35791: LD_INT 12
35793: DOUBLE
35794: EQUAL
35795: IFTRUE 35823
35797: LD_INT 15
35799: DOUBLE
35800: EQUAL
35801: IFTRUE 35823
35803: LD_INT 11
35805: DOUBLE
35806: EQUAL
35807: IFTRUE 35823
35809: LD_INT 14
35811: DOUBLE
35812: EQUAL
35813: IFTRUE 35823
35815: LD_INT 10
35817: DOUBLE
35818: EQUAL
35819: IFTRUE 35823
35821: GO 35879
35823: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
35824: LD_ADDR_VAR 0 9
35828: PUSH
35829: LD_VAR 0 41
35833: PUSH
35834: LD_VAR 0 42
35838: PUSH
35839: LD_VAR 0 43
35843: PUSH
35844: LD_VAR 0 44
35848: PUSH
35849: LD_VAR 0 45
35853: PUSH
35854: LD_VAR 0 46
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: LIST
35863: LIST
35864: LIST
35865: LIST
35866: PUSH
35867: LD_VAR 0 4
35871: PUSH
35872: LD_INT 1
35874: PLUS
35875: ARRAY
35876: ST_TO_ADDR
35877: GO 36132
35879: LD_INT 36
35881: DOUBLE
35882: EQUAL
35883: IFTRUE 35887
35885: GO 35943
35887: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
35888: LD_ADDR_VAR 0 9
35892: PUSH
35893: LD_VAR 0 47
35897: PUSH
35898: LD_VAR 0 48
35902: PUSH
35903: LD_VAR 0 49
35907: PUSH
35908: LD_VAR 0 50
35912: PUSH
35913: LD_VAR 0 51
35917: PUSH
35918: LD_VAR 0 52
35922: PUSH
35923: EMPTY
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: PUSH
35931: LD_VAR 0 4
35935: PUSH
35936: LD_INT 1
35938: PLUS
35939: ARRAY
35940: ST_TO_ADDR
35941: GO 36132
35943: LD_INT 4
35945: DOUBLE
35946: EQUAL
35947: IFTRUE 35969
35949: LD_INT 5
35951: DOUBLE
35952: EQUAL
35953: IFTRUE 35969
35955: LD_INT 34
35957: DOUBLE
35958: EQUAL
35959: IFTRUE 35969
35961: LD_INT 37
35963: DOUBLE
35964: EQUAL
35965: IFTRUE 35969
35967: GO 36025
35969: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
35970: LD_ADDR_VAR 0 9
35974: PUSH
35975: LD_VAR 0 53
35979: PUSH
35980: LD_VAR 0 54
35984: PUSH
35985: LD_VAR 0 55
35989: PUSH
35990: LD_VAR 0 56
35994: PUSH
35995: LD_VAR 0 57
35999: PUSH
36000: LD_VAR 0 58
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: LIST
36009: LIST
36010: LIST
36011: LIST
36012: PUSH
36013: LD_VAR 0 4
36017: PUSH
36018: LD_INT 1
36020: PLUS
36021: ARRAY
36022: ST_TO_ADDR
36023: GO 36132
36025: LD_INT 31
36027: DOUBLE
36028: EQUAL
36029: IFTRUE 36075
36031: LD_INT 32
36033: DOUBLE
36034: EQUAL
36035: IFTRUE 36075
36037: LD_INT 33
36039: DOUBLE
36040: EQUAL
36041: IFTRUE 36075
36043: LD_INT 27
36045: DOUBLE
36046: EQUAL
36047: IFTRUE 36075
36049: LD_INT 26
36051: DOUBLE
36052: EQUAL
36053: IFTRUE 36075
36055: LD_INT 28
36057: DOUBLE
36058: EQUAL
36059: IFTRUE 36075
36061: LD_INT 29
36063: DOUBLE
36064: EQUAL
36065: IFTRUE 36075
36067: LD_INT 30
36069: DOUBLE
36070: EQUAL
36071: IFTRUE 36075
36073: GO 36131
36075: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
36076: LD_ADDR_VAR 0 9
36080: PUSH
36081: LD_VAR 0 59
36085: PUSH
36086: LD_VAR 0 60
36090: PUSH
36091: LD_VAR 0 61
36095: PUSH
36096: LD_VAR 0 62
36100: PUSH
36101: LD_VAR 0 63
36105: PUSH
36106: LD_VAR 0 64
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: PUSH
36119: LD_VAR 0 4
36123: PUSH
36124: LD_INT 1
36126: PLUS
36127: ARRAY
36128: ST_TO_ADDR
36129: GO 36132
36131: POP
// temp_list2 = [ ] ;
36132: LD_ADDR_VAR 0 10
36136: PUSH
36137: EMPTY
36138: ST_TO_ADDR
// for i in temp_list do
36139: LD_ADDR_VAR 0 8
36143: PUSH
36144: LD_VAR 0 9
36148: PUSH
36149: FOR_IN
36150: IFFALSE 36202
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
36152: LD_ADDR_VAR 0 10
36156: PUSH
36157: LD_VAR 0 10
36161: PUSH
36162: LD_VAR 0 8
36166: PUSH
36167: LD_INT 1
36169: ARRAY
36170: PUSH
36171: LD_VAR 0 2
36175: PLUS
36176: PUSH
36177: LD_VAR 0 8
36181: PUSH
36182: LD_INT 2
36184: ARRAY
36185: PUSH
36186: LD_VAR 0 3
36190: PLUS
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: EMPTY
36197: LIST
36198: ADD
36199: ST_TO_ADDR
36200: GO 36149
36202: POP
36203: POP
// result = temp_list2 ;
36204: LD_ADDR_VAR 0 7
36208: PUSH
36209: LD_VAR 0 10
36213: ST_TO_ADDR
// end ;
36214: LD_VAR 0 7
36218: RET
// export function EnemyInRange ( unit , dist ) ; begin
36219: LD_INT 0
36221: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
36222: LD_ADDR_VAR 0 3
36226: PUSH
36227: LD_VAR 0 1
36231: PPUSH
36232: CALL_OW 255
36236: PPUSH
36237: LD_VAR 0 1
36241: PPUSH
36242: CALL_OW 250
36246: PPUSH
36247: LD_VAR 0 1
36251: PPUSH
36252: CALL_OW 251
36256: PPUSH
36257: LD_VAR 0 2
36261: PPUSH
36262: CALL 10323 0 4
36266: PUSH
36267: LD_INT 4
36269: ARRAY
36270: ST_TO_ADDR
// end ;
36271: LD_VAR 0 3
36275: RET
// export function PlayerSeeMe ( unit ) ; begin
36276: LD_INT 0
36278: PPUSH
// result := See ( your_side , unit ) ;
36279: LD_ADDR_VAR 0 2
36283: PUSH
36284: LD_OWVAR 2
36288: PPUSH
36289: LD_VAR 0 1
36293: PPUSH
36294: CALL_OW 292
36298: ST_TO_ADDR
// end ;
36299: LD_VAR 0 2
36303: RET
// export function ReverseDir ( unit ) ; begin
36304: LD_INT 0
36306: PPUSH
// if not unit then
36307: LD_VAR 0 1
36311: NOT
36312: IFFALSE 36316
// exit ;
36314: GO 36339
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
36316: LD_ADDR_VAR 0 2
36320: PUSH
36321: LD_VAR 0 1
36325: PPUSH
36326: CALL_OW 254
36330: PUSH
36331: LD_INT 3
36333: PLUS
36334: PUSH
36335: LD_INT 6
36337: MOD
36338: ST_TO_ADDR
// end ;
36339: LD_VAR 0 2
36343: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
36344: LD_INT 0
36346: PPUSH
36347: PPUSH
36348: PPUSH
36349: PPUSH
36350: PPUSH
// if not hexes then
36351: LD_VAR 0 2
36355: NOT
36356: IFFALSE 36360
// exit ;
36358: GO 36508
// dist := 9999 ;
36360: LD_ADDR_VAR 0 5
36364: PUSH
36365: LD_INT 9999
36367: ST_TO_ADDR
// for i = 1 to hexes do
36368: LD_ADDR_VAR 0 4
36372: PUSH
36373: DOUBLE
36374: LD_INT 1
36376: DEC
36377: ST_TO_ADDR
36378: LD_VAR 0 2
36382: PUSH
36383: FOR_TO
36384: IFFALSE 36496
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
36386: LD_VAR 0 1
36390: PPUSH
36391: LD_VAR 0 2
36395: PUSH
36396: LD_VAR 0 4
36400: ARRAY
36401: PUSH
36402: LD_INT 1
36404: ARRAY
36405: PPUSH
36406: LD_VAR 0 2
36410: PUSH
36411: LD_VAR 0 4
36415: ARRAY
36416: PUSH
36417: LD_INT 2
36419: ARRAY
36420: PPUSH
36421: CALL_OW 297
36425: PUSH
36426: LD_VAR 0 5
36430: LESS
36431: IFFALSE 36494
// begin hex := hexes [ i ] ;
36433: LD_ADDR_VAR 0 7
36437: PUSH
36438: LD_VAR 0 2
36442: PUSH
36443: LD_VAR 0 4
36447: ARRAY
36448: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
36449: LD_ADDR_VAR 0 5
36453: PUSH
36454: LD_VAR 0 1
36458: PPUSH
36459: LD_VAR 0 2
36463: PUSH
36464: LD_VAR 0 4
36468: ARRAY
36469: PUSH
36470: LD_INT 1
36472: ARRAY
36473: PPUSH
36474: LD_VAR 0 2
36478: PUSH
36479: LD_VAR 0 4
36483: ARRAY
36484: PUSH
36485: LD_INT 2
36487: ARRAY
36488: PPUSH
36489: CALL_OW 297
36493: ST_TO_ADDR
// end ; end ;
36494: GO 36383
36496: POP
36497: POP
// result := hex ;
36498: LD_ADDR_VAR 0 3
36502: PUSH
36503: LD_VAR 0 7
36507: ST_TO_ADDR
// end ;
36508: LD_VAR 0 3
36512: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
36513: LD_INT 0
36515: PPUSH
36516: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
36517: LD_VAR 0 1
36521: NOT
36522: PUSH
36523: LD_VAR 0 1
36527: PUSH
36528: LD_INT 21
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 23
36540: PUSH
36541: LD_INT 2
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PPUSH
36552: CALL_OW 69
36556: IN
36557: NOT
36558: OR
36559: IFFALSE 36563
// exit ;
36561: GO 36610
// for i = 1 to 3 do
36563: LD_ADDR_VAR 0 3
36567: PUSH
36568: DOUBLE
36569: LD_INT 1
36571: DEC
36572: ST_TO_ADDR
36573: LD_INT 3
36575: PUSH
36576: FOR_TO
36577: IFFALSE 36608
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
36579: LD_VAR 0 1
36583: PPUSH
36584: CALL_OW 250
36588: PPUSH
36589: LD_VAR 0 1
36593: PPUSH
36594: CALL_OW 251
36598: PPUSH
36599: LD_INT 1
36601: PPUSH
36602: CALL_OW 453
36606: GO 36576
36608: POP
36609: POP
// end ;
36610: LD_VAR 0 2
36614: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
36615: LD_INT 0
36617: PPUSH
36618: PPUSH
36619: PPUSH
36620: PPUSH
36621: PPUSH
36622: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
36623: LD_VAR 0 1
36627: NOT
36628: PUSH
36629: LD_VAR 0 2
36633: NOT
36634: OR
36635: PUSH
36636: LD_VAR 0 1
36640: PPUSH
36641: CALL_OW 314
36645: OR
36646: IFFALSE 36650
// exit ;
36648: GO 37091
// x := GetX ( enemy_unit ) ;
36650: LD_ADDR_VAR 0 7
36654: PUSH
36655: LD_VAR 0 2
36659: PPUSH
36660: CALL_OW 250
36664: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
36665: LD_ADDR_VAR 0 8
36669: PUSH
36670: LD_VAR 0 2
36674: PPUSH
36675: CALL_OW 251
36679: ST_TO_ADDR
// if not x or not y then
36680: LD_VAR 0 7
36684: NOT
36685: PUSH
36686: LD_VAR 0 8
36690: NOT
36691: OR
36692: IFFALSE 36696
// exit ;
36694: GO 37091
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
36696: LD_ADDR_VAR 0 6
36700: PUSH
36701: LD_VAR 0 7
36705: PPUSH
36706: LD_INT 0
36708: PPUSH
36709: LD_INT 4
36711: PPUSH
36712: CALL_OW 272
36716: PUSH
36717: LD_VAR 0 8
36721: PPUSH
36722: LD_INT 0
36724: PPUSH
36725: LD_INT 4
36727: PPUSH
36728: CALL_OW 273
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_VAR 0 7
36741: PPUSH
36742: LD_INT 1
36744: PPUSH
36745: LD_INT 4
36747: PPUSH
36748: CALL_OW 272
36752: PUSH
36753: LD_VAR 0 8
36757: PPUSH
36758: LD_INT 1
36760: PPUSH
36761: LD_INT 4
36763: PPUSH
36764: CALL_OW 273
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_VAR 0 7
36777: PPUSH
36778: LD_INT 2
36780: PPUSH
36781: LD_INT 4
36783: PPUSH
36784: CALL_OW 272
36788: PUSH
36789: LD_VAR 0 8
36793: PPUSH
36794: LD_INT 2
36796: PPUSH
36797: LD_INT 4
36799: PPUSH
36800: CALL_OW 273
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_VAR 0 7
36813: PPUSH
36814: LD_INT 3
36816: PPUSH
36817: LD_INT 4
36819: PPUSH
36820: CALL_OW 272
36824: PUSH
36825: LD_VAR 0 8
36829: PPUSH
36830: LD_INT 3
36832: PPUSH
36833: LD_INT 4
36835: PPUSH
36836: CALL_OW 273
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_VAR 0 7
36849: PPUSH
36850: LD_INT 4
36852: PPUSH
36853: LD_INT 4
36855: PPUSH
36856: CALL_OW 272
36860: PUSH
36861: LD_VAR 0 8
36865: PPUSH
36866: LD_INT 4
36868: PPUSH
36869: LD_INT 4
36871: PPUSH
36872: CALL_OW 273
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: LD_VAR 0 7
36885: PPUSH
36886: LD_INT 5
36888: PPUSH
36889: LD_INT 4
36891: PPUSH
36892: CALL_OW 272
36896: PUSH
36897: LD_VAR 0 8
36901: PPUSH
36902: LD_INT 5
36904: PPUSH
36905: LD_INT 4
36907: PPUSH
36908: CALL_OW 273
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: LIST
36923: LIST
36924: ST_TO_ADDR
// for i = tmp downto 1 do
36925: LD_ADDR_VAR 0 4
36929: PUSH
36930: DOUBLE
36931: LD_VAR 0 6
36935: INC
36936: ST_TO_ADDR
36937: LD_INT 1
36939: PUSH
36940: FOR_DOWNTO
36941: IFFALSE 37042
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
36943: LD_VAR 0 6
36947: PUSH
36948: LD_VAR 0 4
36952: ARRAY
36953: PUSH
36954: LD_INT 1
36956: ARRAY
36957: PPUSH
36958: LD_VAR 0 6
36962: PUSH
36963: LD_VAR 0 4
36967: ARRAY
36968: PUSH
36969: LD_INT 2
36971: ARRAY
36972: PPUSH
36973: CALL_OW 488
36977: NOT
36978: PUSH
36979: LD_VAR 0 6
36983: PUSH
36984: LD_VAR 0 4
36988: ARRAY
36989: PUSH
36990: LD_INT 1
36992: ARRAY
36993: PPUSH
36994: LD_VAR 0 6
36998: PUSH
36999: LD_VAR 0 4
37003: ARRAY
37004: PUSH
37005: LD_INT 2
37007: ARRAY
37008: PPUSH
37009: CALL_OW 428
37013: PUSH
37014: LD_INT 0
37016: NONEQUAL
37017: OR
37018: IFFALSE 37040
// tmp := Delete ( tmp , i ) ;
37020: LD_ADDR_VAR 0 6
37024: PUSH
37025: LD_VAR 0 6
37029: PPUSH
37030: LD_VAR 0 4
37034: PPUSH
37035: CALL_OW 3
37039: ST_TO_ADDR
37040: GO 36940
37042: POP
37043: POP
// j := GetClosestHex ( unit , tmp ) ;
37044: LD_ADDR_VAR 0 5
37048: PUSH
37049: LD_VAR 0 1
37053: PPUSH
37054: LD_VAR 0 6
37058: PPUSH
37059: CALL 36344 0 2
37063: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
37064: LD_VAR 0 1
37068: PPUSH
37069: LD_VAR 0 5
37073: PUSH
37074: LD_INT 1
37076: ARRAY
37077: PPUSH
37078: LD_VAR 0 5
37082: PUSH
37083: LD_INT 2
37085: ARRAY
37086: PPUSH
37087: CALL_OW 111
// end ;
37091: LD_VAR 0 3
37095: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
37096: LD_INT 0
37098: PPUSH
37099: PPUSH
37100: PPUSH
// uc_side = 0 ;
37101: LD_ADDR_OWVAR 20
37105: PUSH
37106: LD_INT 0
37108: ST_TO_ADDR
// uc_nation = 0 ;
37109: LD_ADDR_OWVAR 21
37113: PUSH
37114: LD_INT 0
37116: ST_TO_ADDR
// InitHc_All ( ) ;
37117: CALL_OW 584
// InitVc ;
37121: CALL_OW 20
// if mastodonts then
37125: LD_VAR 0 6
37129: IFFALSE 37196
// for i = 1 to mastodonts do
37131: LD_ADDR_VAR 0 11
37135: PUSH
37136: DOUBLE
37137: LD_INT 1
37139: DEC
37140: ST_TO_ADDR
37141: LD_VAR 0 6
37145: PUSH
37146: FOR_TO
37147: IFFALSE 37194
// begin vc_chassis := 31 ;
37149: LD_ADDR_OWVAR 37
37153: PUSH
37154: LD_INT 31
37156: ST_TO_ADDR
// vc_control := control_rider ;
37157: LD_ADDR_OWVAR 38
37161: PUSH
37162: LD_INT 4
37164: ST_TO_ADDR
// animal := CreateVehicle ;
37165: LD_ADDR_VAR 0 12
37169: PUSH
37170: CALL_OW 45
37174: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37175: LD_VAR 0 12
37179: PPUSH
37180: LD_VAR 0 8
37184: PPUSH
37185: LD_INT 0
37187: PPUSH
37188: CALL 39384 0 3
// end ;
37192: GO 37146
37194: POP
37195: POP
// if horses then
37196: LD_VAR 0 5
37200: IFFALSE 37267
// for i = 1 to horses do
37202: LD_ADDR_VAR 0 11
37206: PUSH
37207: DOUBLE
37208: LD_INT 1
37210: DEC
37211: ST_TO_ADDR
37212: LD_VAR 0 5
37216: PUSH
37217: FOR_TO
37218: IFFALSE 37265
// begin hc_class := 21 ;
37220: LD_ADDR_OWVAR 28
37224: PUSH
37225: LD_INT 21
37227: ST_TO_ADDR
// hc_gallery :=  ;
37228: LD_ADDR_OWVAR 33
37232: PUSH
37233: LD_STRING 
37235: ST_TO_ADDR
// animal := CreateHuman ;
37236: LD_ADDR_VAR 0 12
37240: PUSH
37241: CALL_OW 44
37245: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37246: LD_VAR 0 12
37250: PPUSH
37251: LD_VAR 0 8
37255: PPUSH
37256: LD_INT 0
37258: PPUSH
37259: CALL 39384 0 3
// end ;
37263: GO 37217
37265: POP
37266: POP
// if birds then
37267: LD_VAR 0 1
37271: IFFALSE 37338
// for i = 1 to birds do
37273: LD_ADDR_VAR 0 11
37277: PUSH
37278: DOUBLE
37279: LD_INT 1
37281: DEC
37282: ST_TO_ADDR
37283: LD_VAR 0 1
37287: PUSH
37288: FOR_TO
37289: IFFALSE 37336
// begin hc_class = 18 ;
37291: LD_ADDR_OWVAR 28
37295: PUSH
37296: LD_INT 18
37298: ST_TO_ADDR
// hc_gallery =  ;
37299: LD_ADDR_OWVAR 33
37303: PUSH
37304: LD_STRING 
37306: ST_TO_ADDR
// animal := CreateHuman ;
37307: LD_ADDR_VAR 0 12
37311: PUSH
37312: CALL_OW 44
37316: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37317: LD_VAR 0 12
37321: PPUSH
37322: LD_VAR 0 8
37326: PPUSH
37327: LD_INT 0
37329: PPUSH
37330: CALL 39384 0 3
// end ;
37334: GO 37288
37336: POP
37337: POP
// if tigers then
37338: LD_VAR 0 2
37342: IFFALSE 37426
// for i = 1 to tigers do
37344: LD_ADDR_VAR 0 11
37348: PUSH
37349: DOUBLE
37350: LD_INT 1
37352: DEC
37353: ST_TO_ADDR
37354: LD_VAR 0 2
37358: PUSH
37359: FOR_TO
37360: IFFALSE 37424
// begin hc_class = class_tiger ;
37362: LD_ADDR_OWVAR 28
37366: PUSH
37367: LD_INT 14
37369: ST_TO_ADDR
// hc_gallery =  ;
37370: LD_ADDR_OWVAR 33
37374: PUSH
37375: LD_STRING 
37377: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
37378: LD_ADDR_OWVAR 35
37382: PUSH
37383: LD_INT 7
37385: NEG
37386: PPUSH
37387: LD_INT 7
37389: PPUSH
37390: CALL_OW 12
37394: ST_TO_ADDR
// animal := CreateHuman ;
37395: LD_ADDR_VAR 0 12
37399: PUSH
37400: CALL_OW 44
37404: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37405: LD_VAR 0 12
37409: PPUSH
37410: LD_VAR 0 8
37414: PPUSH
37415: LD_INT 0
37417: PPUSH
37418: CALL 39384 0 3
// end ;
37422: GO 37359
37424: POP
37425: POP
// if apemans then
37426: LD_VAR 0 3
37430: IFFALSE 37553
// for i = 1 to apemans do
37432: LD_ADDR_VAR 0 11
37436: PUSH
37437: DOUBLE
37438: LD_INT 1
37440: DEC
37441: ST_TO_ADDR
37442: LD_VAR 0 3
37446: PUSH
37447: FOR_TO
37448: IFFALSE 37551
// begin hc_class = class_apeman ;
37450: LD_ADDR_OWVAR 28
37454: PUSH
37455: LD_INT 12
37457: ST_TO_ADDR
// hc_gallery =  ;
37458: LD_ADDR_OWVAR 33
37462: PUSH
37463: LD_STRING 
37465: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
37466: LD_ADDR_OWVAR 35
37470: PUSH
37471: LD_INT 5
37473: NEG
37474: PPUSH
37475: LD_INT 5
37477: PPUSH
37478: CALL_OW 12
37482: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
37483: LD_ADDR_OWVAR 31
37487: PUSH
37488: LD_INT 1
37490: PPUSH
37491: LD_INT 3
37493: PPUSH
37494: CALL_OW 12
37498: PUSH
37499: LD_INT 1
37501: PPUSH
37502: LD_INT 3
37504: PPUSH
37505: CALL_OW 12
37509: PUSH
37510: LD_INT 0
37512: PUSH
37513: LD_INT 0
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: ST_TO_ADDR
// animal := CreateHuman ;
37522: LD_ADDR_VAR 0 12
37526: PUSH
37527: CALL_OW 44
37531: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37532: LD_VAR 0 12
37536: PPUSH
37537: LD_VAR 0 8
37541: PPUSH
37542: LD_INT 0
37544: PPUSH
37545: CALL 39384 0 3
// end ;
37549: GO 37447
37551: POP
37552: POP
// if enchidnas then
37553: LD_VAR 0 4
37557: IFFALSE 37624
// for i = 1 to enchidnas do
37559: LD_ADDR_VAR 0 11
37563: PUSH
37564: DOUBLE
37565: LD_INT 1
37567: DEC
37568: ST_TO_ADDR
37569: LD_VAR 0 4
37573: PUSH
37574: FOR_TO
37575: IFFALSE 37622
// begin hc_class = 13 ;
37577: LD_ADDR_OWVAR 28
37581: PUSH
37582: LD_INT 13
37584: ST_TO_ADDR
// hc_gallery =  ;
37585: LD_ADDR_OWVAR 33
37589: PUSH
37590: LD_STRING 
37592: ST_TO_ADDR
// animal := CreateHuman ;
37593: LD_ADDR_VAR 0 12
37597: PUSH
37598: CALL_OW 44
37602: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37603: LD_VAR 0 12
37607: PPUSH
37608: LD_VAR 0 8
37612: PPUSH
37613: LD_INT 0
37615: PPUSH
37616: CALL 39384 0 3
// end ;
37620: GO 37574
37622: POP
37623: POP
// if fishes then
37624: LD_VAR 0 7
37628: IFFALSE 37695
// for i = 1 to fishes do
37630: LD_ADDR_VAR 0 11
37634: PUSH
37635: DOUBLE
37636: LD_INT 1
37638: DEC
37639: ST_TO_ADDR
37640: LD_VAR 0 7
37644: PUSH
37645: FOR_TO
37646: IFFALSE 37693
// begin hc_class = 20 ;
37648: LD_ADDR_OWVAR 28
37652: PUSH
37653: LD_INT 20
37655: ST_TO_ADDR
// hc_gallery =  ;
37656: LD_ADDR_OWVAR 33
37660: PUSH
37661: LD_STRING 
37663: ST_TO_ADDR
// animal := CreateHuman ;
37664: LD_ADDR_VAR 0 12
37668: PUSH
37669: CALL_OW 44
37673: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
37674: LD_VAR 0 12
37678: PPUSH
37679: LD_VAR 0 9
37683: PPUSH
37684: LD_INT 0
37686: PPUSH
37687: CALL 39384 0 3
// end ;
37691: GO 37645
37693: POP
37694: POP
// end ;
37695: LD_VAR 0 10
37699: RET
// export function WantHeal ( sci , unit ) ; begin
37700: LD_INT 0
37702: PPUSH
// if GetTaskList ( sci ) > 0 then
37703: LD_VAR 0 1
37707: PPUSH
37708: CALL_OW 437
37712: PUSH
37713: LD_INT 0
37715: GREATER
37716: IFFALSE 37786
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
37718: LD_VAR 0 1
37722: PPUSH
37723: CALL_OW 437
37727: PUSH
37728: LD_INT 1
37730: ARRAY
37731: PUSH
37732: LD_INT 1
37734: ARRAY
37735: PUSH
37736: LD_STRING l
37738: EQUAL
37739: PUSH
37740: LD_VAR 0 1
37744: PPUSH
37745: CALL_OW 437
37749: PUSH
37750: LD_INT 1
37752: ARRAY
37753: PUSH
37754: LD_INT 4
37756: ARRAY
37757: PUSH
37758: LD_VAR 0 2
37762: EQUAL
37763: AND
37764: IFFALSE 37776
// result := true else
37766: LD_ADDR_VAR 0 3
37770: PUSH
37771: LD_INT 1
37773: ST_TO_ADDR
37774: GO 37784
// result := false ;
37776: LD_ADDR_VAR 0 3
37780: PUSH
37781: LD_INT 0
37783: ST_TO_ADDR
// end else
37784: GO 37794
// result := false ;
37786: LD_ADDR_VAR 0 3
37790: PUSH
37791: LD_INT 0
37793: ST_TO_ADDR
// end ;
37794: LD_VAR 0 3
37798: RET
// export function HealTarget ( sci ) ; begin
37799: LD_INT 0
37801: PPUSH
// if not sci then
37802: LD_VAR 0 1
37806: NOT
37807: IFFALSE 37811
// exit ;
37809: GO 37876
// result := 0 ;
37811: LD_ADDR_VAR 0 2
37815: PUSH
37816: LD_INT 0
37818: ST_TO_ADDR
// if GetTaskList ( sci ) then
37819: LD_VAR 0 1
37823: PPUSH
37824: CALL_OW 437
37828: IFFALSE 37876
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
37830: LD_VAR 0 1
37834: PPUSH
37835: CALL_OW 437
37839: PUSH
37840: LD_INT 1
37842: ARRAY
37843: PUSH
37844: LD_INT 1
37846: ARRAY
37847: PUSH
37848: LD_STRING l
37850: EQUAL
37851: IFFALSE 37876
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
37853: LD_ADDR_VAR 0 2
37857: PUSH
37858: LD_VAR 0 1
37862: PPUSH
37863: CALL_OW 437
37867: PUSH
37868: LD_INT 1
37870: ARRAY
37871: PUSH
37872: LD_INT 4
37874: ARRAY
37875: ST_TO_ADDR
// end ;
37876: LD_VAR 0 2
37880: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
37881: LD_INT 0
37883: PPUSH
37884: PPUSH
37885: PPUSH
37886: PPUSH
// if not base_units then
37887: LD_VAR 0 1
37891: NOT
37892: IFFALSE 37896
// exit ;
37894: GO 37983
// result := false ;
37896: LD_ADDR_VAR 0 2
37900: PUSH
37901: LD_INT 0
37903: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
37904: LD_ADDR_VAR 0 5
37908: PUSH
37909: LD_VAR 0 1
37913: PPUSH
37914: LD_INT 21
37916: PUSH
37917: LD_INT 3
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PPUSH
37924: CALL_OW 72
37928: ST_TO_ADDR
// if not tmp then
37929: LD_VAR 0 5
37933: NOT
37934: IFFALSE 37938
// exit ;
37936: GO 37983
// for i in tmp do
37938: LD_ADDR_VAR 0 3
37942: PUSH
37943: LD_VAR 0 5
37947: PUSH
37948: FOR_IN
37949: IFFALSE 37981
// begin result := EnemyInRange ( i , 22 ) ;
37951: LD_ADDR_VAR 0 2
37955: PUSH
37956: LD_VAR 0 3
37960: PPUSH
37961: LD_INT 22
37963: PPUSH
37964: CALL 36219 0 2
37968: ST_TO_ADDR
// if result then
37969: LD_VAR 0 2
37973: IFFALSE 37979
// exit ;
37975: POP
37976: POP
37977: GO 37983
// end ;
37979: GO 37948
37981: POP
37982: POP
// end ;
37983: LD_VAR 0 2
37987: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
37988: LD_INT 0
37990: PPUSH
37991: PPUSH
// if not units then
37992: LD_VAR 0 1
37996: NOT
37997: IFFALSE 38001
// exit ;
37999: GO 38071
// result := [ ] ;
38001: LD_ADDR_VAR 0 3
38005: PUSH
38006: EMPTY
38007: ST_TO_ADDR
// for i in units do
38008: LD_ADDR_VAR 0 4
38012: PUSH
38013: LD_VAR 0 1
38017: PUSH
38018: FOR_IN
38019: IFFALSE 38069
// if GetTag ( i ) = tag then
38021: LD_VAR 0 4
38025: PPUSH
38026: CALL_OW 110
38030: PUSH
38031: LD_VAR 0 2
38035: EQUAL
38036: IFFALSE 38067
// result := Insert ( result , result + 1 , i ) ;
38038: LD_ADDR_VAR 0 3
38042: PUSH
38043: LD_VAR 0 3
38047: PPUSH
38048: LD_VAR 0 3
38052: PUSH
38053: LD_INT 1
38055: PLUS
38056: PPUSH
38057: LD_VAR 0 4
38061: PPUSH
38062: CALL_OW 2
38066: ST_TO_ADDR
38067: GO 38018
38069: POP
38070: POP
// end ;
38071: LD_VAR 0 3
38075: RET
// export function IsDriver ( un ) ; begin
38076: LD_INT 0
38078: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
38079: LD_ADDR_VAR 0 2
38083: PUSH
38084: LD_VAR 0 1
38088: PUSH
38089: LD_INT 55
38091: PUSH
38092: EMPTY
38093: LIST
38094: PPUSH
38095: CALL_OW 69
38099: IN
38100: ST_TO_ADDR
// end ;
38101: LD_VAR 0 2
38105: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
38106: LD_INT 0
38108: PPUSH
38109: PPUSH
// list := [ ] ;
38110: LD_ADDR_VAR 0 5
38114: PUSH
38115: EMPTY
38116: ST_TO_ADDR
// case d of 0 :
38117: LD_VAR 0 3
38121: PUSH
38122: LD_INT 0
38124: DOUBLE
38125: EQUAL
38126: IFTRUE 38130
38128: GO 38263
38130: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
38131: LD_ADDR_VAR 0 5
38135: PUSH
38136: LD_VAR 0 1
38140: PUSH
38141: LD_INT 4
38143: MINUS
38144: PUSH
38145: LD_VAR 0 2
38149: PUSH
38150: LD_INT 4
38152: MINUS
38153: PUSH
38154: LD_INT 2
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: LIST
38161: PUSH
38162: LD_VAR 0 1
38166: PUSH
38167: LD_INT 3
38169: MINUS
38170: PUSH
38171: LD_VAR 0 2
38175: PUSH
38176: LD_INT 1
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: LIST
38183: PUSH
38184: LD_VAR 0 1
38188: PUSH
38189: LD_INT 4
38191: PLUS
38192: PUSH
38193: LD_VAR 0 2
38197: PUSH
38198: LD_INT 4
38200: PUSH
38201: EMPTY
38202: LIST
38203: LIST
38204: LIST
38205: PUSH
38206: LD_VAR 0 1
38210: PUSH
38211: LD_INT 3
38213: PLUS
38214: PUSH
38215: LD_VAR 0 2
38219: PUSH
38220: LD_INT 3
38222: PLUS
38223: PUSH
38224: LD_INT 5
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: LIST
38231: PUSH
38232: LD_VAR 0 1
38236: PUSH
38237: LD_VAR 0 2
38241: PUSH
38242: LD_INT 4
38244: PLUS
38245: PUSH
38246: LD_INT 0
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: LIST
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: LIST
38258: LIST
38259: LIST
38260: ST_TO_ADDR
// end ; 1 :
38261: GO 38961
38263: LD_INT 1
38265: DOUBLE
38266: EQUAL
38267: IFTRUE 38271
38269: GO 38404
38271: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
38272: LD_ADDR_VAR 0 5
38276: PUSH
38277: LD_VAR 0 1
38281: PUSH
38282: LD_VAR 0 2
38286: PUSH
38287: LD_INT 4
38289: MINUS
38290: PUSH
38291: LD_INT 3
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: LIST
38298: PUSH
38299: LD_VAR 0 1
38303: PUSH
38304: LD_INT 3
38306: MINUS
38307: PUSH
38308: LD_VAR 0 2
38312: PUSH
38313: LD_INT 3
38315: MINUS
38316: PUSH
38317: LD_INT 2
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: LIST
38324: PUSH
38325: LD_VAR 0 1
38329: PUSH
38330: LD_INT 4
38332: MINUS
38333: PUSH
38334: LD_VAR 0 2
38338: PUSH
38339: LD_INT 1
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: LIST
38346: PUSH
38347: LD_VAR 0 1
38351: PUSH
38352: LD_VAR 0 2
38356: PUSH
38357: LD_INT 3
38359: PLUS
38360: PUSH
38361: LD_INT 0
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: LIST
38368: PUSH
38369: LD_VAR 0 1
38373: PUSH
38374: LD_INT 4
38376: PLUS
38377: PUSH
38378: LD_VAR 0 2
38382: PUSH
38383: LD_INT 4
38385: PLUS
38386: PUSH
38387: LD_INT 5
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: LIST
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: ST_TO_ADDR
// end ; 2 :
38402: GO 38961
38404: LD_INT 2
38406: DOUBLE
38407: EQUAL
38408: IFTRUE 38412
38410: GO 38541
38412: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
38413: LD_ADDR_VAR 0 5
38417: PUSH
38418: LD_VAR 0 1
38422: PUSH
38423: LD_VAR 0 2
38427: PUSH
38428: LD_INT 3
38430: MINUS
38431: PUSH
38432: LD_INT 3
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: LIST
38439: PUSH
38440: LD_VAR 0 1
38444: PUSH
38445: LD_INT 4
38447: PLUS
38448: PUSH
38449: LD_VAR 0 2
38453: PUSH
38454: LD_INT 4
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: LIST
38461: PUSH
38462: LD_VAR 0 1
38466: PUSH
38467: LD_VAR 0 2
38471: PUSH
38472: LD_INT 4
38474: PLUS
38475: PUSH
38476: LD_INT 0
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: LIST
38483: PUSH
38484: LD_VAR 0 1
38488: PUSH
38489: LD_INT 3
38491: MINUS
38492: PUSH
38493: LD_VAR 0 2
38497: PUSH
38498: LD_INT 1
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: LIST
38505: PUSH
38506: LD_VAR 0 1
38510: PUSH
38511: LD_INT 4
38513: MINUS
38514: PUSH
38515: LD_VAR 0 2
38519: PUSH
38520: LD_INT 4
38522: MINUS
38523: PUSH
38524: LD_INT 2
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: LIST
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: ST_TO_ADDR
// end ; 3 :
38539: GO 38961
38541: LD_INT 3
38543: DOUBLE
38544: EQUAL
38545: IFTRUE 38549
38547: GO 38682
38549: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
38550: LD_ADDR_VAR 0 5
38554: PUSH
38555: LD_VAR 0 1
38559: PUSH
38560: LD_INT 3
38562: PLUS
38563: PUSH
38564: LD_VAR 0 2
38568: PUSH
38569: LD_INT 4
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: LIST
38576: PUSH
38577: LD_VAR 0 1
38581: PUSH
38582: LD_INT 4
38584: PLUS
38585: PUSH
38586: LD_VAR 0 2
38590: PUSH
38591: LD_INT 4
38593: PLUS
38594: PUSH
38595: LD_INT 5
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: LIST
38602: PUSH
38603: LD_VAR 0 1
38607: PUSH
38608: LD_INT 4
38610: MINUS
38611: PUSH
38612: LD_VAR 0 2
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: LIST
38624: PUSH
38625: LD_VAR 0 1
38629: PUSH
38630: LD_VAR 0 2
38634: PUSH
38635: LD_INT 4
38637: MINUS
38638: PUSH
38639: LD_INT 3
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: LIST
38646: PUSH
38647: LD_VAR 0 1
38651: PUSH
38652: LD_INT 3
38654: MINUS
38655: PUSH
38656: LD_VAR 0 2
38660: PUSH
38661: LD_INT 3
38663: MINUS
38664: PUSH
38665: LD_INT 2
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: LIST
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: ST_TO_ADDR
// end ; 4 :
38680: GO 38961
38682: LD_INT 4
38684: DOUBLE
38685: EQUAL
38686: IFTRUE 38690
38688: GO 38823
38690: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
38691: LD_ADDR_VAR 0 5
38695: PUSH
38696: LD_VAR 0 1
38700: PUSH
38701: LD_VAR 0 2
38705: PUSH
38706: LD_INT 4
38708: PLUS
38709: PUSH
38710: LD_INT 0
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: LIST
38717: PUSH
38718: LD_VAR 0 1
38722: PUSH
38723: LD_INT 3
38725: PLUS
38726: PUSH
38727: LD_VAR 0 2
38731: PUSH
38732: LD_INT 3
38734: PLUS
38735: PUSH
38736: LD_INT 5
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: LIST
38743: PUSH
38744: LD_VAR 0 1
38748: PUSH
38749: LD_INT 4
38751: PLUS
38752: PUSH
38753: LD_VAR 0 2
38757: PUSH
38758: LD_INT 4
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: LIST
38765: PUSH
38766: LD_VAR 0 1
38770: PUSH
38771: LD_VAR 0 2
38775: PUSH
38776: LD_INT 3
38778: MINUS
38779: PUSH
38780: LD_INT 3
38782: PUSH
38783: EMPTY
38784: LIST
38785: LIST
38786: LIST
38787: PUSH
38788: LD_VAR 0 1
38792: PUSH
38793: LD_INT 4
38795: MINUS
38796: PUSH
38797: LD_VAR 0 2
38801: PUSH
38802: LD_INT 4
38804: MINUS
38805: PUSH
38806: LD_INT 2
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: LIST
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: ST_TO_ADDR
// end ; 5 :
38821: GO 38961
38823: LD_INT 5
38825: DOUBLE
38826: EQUAL
38827: IFTRUE 38831
38829: GO 38960
38831: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
38832: LD_ADDR_VAR 0 5
38836: PUSH
38837: LD_VAR 0 1
38841: PUSH
38842: LD_INT 4
38844: MINUS
38845: PUSH
38846: LD_VAR 0 2
38850: PUSH
38851: LD_INT 1
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: LIST
38858: PUSH
38859: LD_VAR 0 1
38863: PUSH
38864: LD_VAR 0 2
38868: PUSH
38869: LD_INT 4
38871: MINUS
38872: PUSH
38873: LD_INT 3
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: LIST
38880: PUSH
38881: LD_VAR 0 1
38885: PUSH
38886: LD_INT 4
38888: PLUS
38889: PUSH
38890: LD_VAR 0 2
38894: PUSH
38895: LD_INT 4
38897: PLUS
38898: PUSH
38899: LD_INT 5
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: LIST
38906: PUSH
38907: LD_VAR 0 1
38911: PUSH
38912: LD_INT 3
38914: PLUS
38915: PUSH
38916: LD_VAR 0 2
38920: PUSH
38921: LD_INT 4
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: LIST
38928: PUSH
38929: LD_VAR 0 1
38933: PUSH
38934: LD_VAR 0 2
38938: PUSH
38939: LD_INT 3
38941: PLUS
38942: PUSH
38943: LD_INT 0
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: LIST
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: ST_TO_ADDR
// end ; end ;
38958: GO 38961
38960: POP
// result := list ;
38961: LD_ADDR_VAR 0 4
38965: PUSH
38966: LD_VAR 0 5
38970: ST_TO_ADDR
// end ;
38971: LD_VAR 0 4
38975: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
38976: LD_INT 0
38978: PPUSH
38979: PPUSH
38980: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
38981: LD_VAR 0 1
38985: NOT
38986: PUSH
38987: LD_VAR 0 2
38991: PUSH
38992: LD_INT 1
38994: PUSH
38995: LD_INT 2
38997: PUSH
38998: LD_INT 3
39000: PUSH
39001: LD_INT 4
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: IN
39010: NOT
39011: OR
39012: IFFALSE 39016
// exit ;
39014: GO 39108
// tmp := [ ] ;
39016: LD_ADDR_VAR 0 5
39020: PUSH
39021: EMPTY
39022: ST_TO_ADDR
// for i in units do
39023: LD_ADDR_VAR 0 4
39027: PUSH
39028: LD_VAR 0 1
39032: PUSH
39033: FOR_IN
39034: IFFALSE 39077
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
39036: LD_ADDR_VAR 0 5
39040: PUSH
39041: LD_VAR 0 5
39045: PPUSH
39046: LD_VAR 0 5
39050: PUSH
39051: LD_INT 1
39053: PLUS
39054: PPUSH
39055: LD_VAR 0 4
39059: PPUSH
39060: LD_VAR 0 2
39064: PPUSH
39065: CALL_OW 259
39069: PPUSH
39070: CALL_OW 2
39074: ST_TO_ADDR
39075: GO 39033
39077: POP
39078: POP
// if not tmp then
39079: LD_VAR 0 5
39083: NOT
39084: IFFALSE 39088
// exit ;
39086: GO 39108
// result := SortListByListDesc ( units , tmp ) ;
39088: LD_ADDR_VAR 0 3
39092: PUSH
39093: LD_VAR 0 1
39097: PPUSH
39098: LD_VAR 0 5
39102: PPUSH
39103: CALL_OW 77
39107: ST_TO_ADDR
// end ;
39108: LD_VAR 0 3
39112: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
39113: LD_INT 0
39115: PPUSH
39116: PPUSH
39117: PPUSH
// result := false ;
39118: LD_ADDR_VAR 0 3
39122: PUSH
39123: LD_INT 0
39125: ST_TO_ADDR
// x := GetX ( building ) ;
39126: LD_ADDR_VAR 0 4
39130: PUSH
39131: LD_VAR 0 2
39135: PPUSH
39136: CALL_OW 250
39140: ST_TO_ADDR
// y := GetY ( building ) ;
39141: LD_ADDR_VAR 0 5
39145: PUSH
39146: LD_VAR 0 2
39150: PPUSH
39151: CALL_OW 251
39155: ST_TO_ADDR
// if not building or not x or not y then
39156: LD_VAR 0 2
39160: NOT
39161: PUSH
39162: LD_VAR 0 4
39166: NOT
39167: OR
39168: PUSH
39169: LD_VAR 0 5
39173: NOT
39174: OR
39175: IFFALSE 39179
// exit ;
39177: GO 39271
// if GetTaskList ( unit ) then
39179: LD_VAR 0 1
39183: PPUSH
39184: CALL_OW 437
39188: IFFALSE 39271
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39190: LD_STRING e
39192: PUSH
39193: LD_VAR 0 1
39197: PPUSH
39198: CALL_OW 437
39202: PUSH
39203: LD_INT 1
39205: ARRAY
39206: PUSH
39207: LD_INT 1
39209: ARRAY
39210: EQUAL
39211: PUSH
39212: LD_VAR 0 4
39216: PUSH
39217: LD_VAR 0 1
39221: PPUSH
39222: CALL_OW 437
39226: PUSH
39227: LD_INT 1
39229: ARRAY
39230: PUSH
39231: LD_INT 2
39233: ARRAY
39234: EQUAL
39235: AND
39236: PUSH
39237: LD_VAR 0 5
39241: PUSH
39242: LD_VAR 0 1
39246: PPUSH
39247: CALL_OW 437
39251: PUSH
39252: LD_INT 1
39254: ARRAY
39255: PUSH
39256: LD_INT 3
39258: ARRAY
39259: EQUAL
39260: AND
39261: IFFALSE 39271
// result := true end ;
39263: LD_ADDR_VAR 0 3
39267: PUSH
39268: LD_INT 1
39270: ST_TO_ADDR
// end ;
39271: LD_VAR 0 3
39275: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
39276: LD_INT 0
39278: PPUSH
// result := false ;
39279: LD_ADDR_VAR 0 4
39283: PUSH
39284: LD_INT 0
39286: ST_TO_ADDR
// if GetTaskList ( unit ) then
39287: LD_VAR 0 1
39291: PPUSH
39292: CALL_OW 437
39296: IFFALSE 39379
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39298: LD_STRING M
39300: PUSH
39301: LD_VAR 0 1
39305: PPUSH
39306: CALL_OW 437
39310: PUSH
39311: LD_INT 1
39313: ARRAY
39314: PUSH
39315: LD_INT 1
39317: ARRAY
39318: EQUAL
39319: PUSH
39320: LD_VAR 0 2
39324: PUSH
39325: LD_VAR 0 1
39329: PPUSH
39330: CALL_OW 437
39334: PUSH
39335: LD_INT 1
39337: ARRAY
39338: PUSH
39339: LD_INT 2
39341: ARRAY
39342: EQUAL
39343: AND
39344: PUSH
39345: LD_VAR 0 3
39349: PUSH
39350: LD_VAR 0 1
39354: PPUSH
39355: CALL_OW 437
39359: PUSH
39360: LD_INT 1
39362: ARRAY
39363: PUSH
39364: LD_INT 3
39366: ARRAY
39367: EQUAL
39368: AND
39369: IFFALSE 39379
// result := true ;
39371: LD_ADDR_VAR 0 4
39375: PUSH
39376: LD_INT 1
39378: ST_TO_ADDR
// end ; end ;
39379: LD_VAR 0 4
39383: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
39384: LD_INT 0
39386: PPUSH
39387: PPUSH
39388: PPUSH
39389: PPUSH
// if not unit or not area then
39390: LD_VAR 0 1
39394: NOT
39395: PUSH
39396: LD_VAR 0 2
39400: NOT
39401: OR
39402: IFFALSE 39406
// exit ;
39404: GO 39570
// tmp := AreaToList ( area , i ) ;
39406: LD_ADDR_VAR 0 6
39410: PUSH
39411: LD_VAR 0 2
39415: PPUSH
39416: LD_VAR 0 5
39420: PPUSH
39421: CALL_OW 517
39425: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
39426: LD_ADDR_VAR 0 5
39430: PUSH
39431: DOUBLE
39432: LD_INT 1
39434: DEC
39435: ST_TO_ADDR
39436: LD_VAR 0 6
39440: PUSH
39441: LD_INT 1
39443: ARRAY
39444: PUSH
39445: FOR_TO
39446: IFFALSE 39568
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
39448: LD_ADDR_VAR 0 7
39452: PUSH
39453: LD_VAR 0 6
39457: PUSH
39458: LD_INT 1
39460: ARRAY
39461: PUSH
39462: LD_VAR 0 5
39466: ARRAY
39467: PUSH
39468: LD_VAR 0 6
39472: PUSH
39473: LD_INT 2
39475: ARRAY
39476: PUSH
39477: LD_VAR 0 5
39481: ARRAY
39482: PUSH
39483: EMPTY
39484: LIST
39485: LIST
39486: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
39487: LD_VAR 0 7
39491: PUSH
39492: LD_INT 1
39494: ARRAY
39495: PPUSH
39496: LD_VAR 0 7
39500: PUSH
39501: LD_INT 2
39503: ARRAY
39504: PPUSH
39505: CALL_OW 428
39509: PUSH
39510: LD_INT 0
39512: EQUAL
39513: IFFALSE 39566
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
39515: LD_VAR 0 1
39519: PPUSH
39520: LD_VAR 0 7
39524: PUSH
39525: LD_INT 1
39527: ARRAY
39528: PPUSH
39529: LD_VAR 0 7
39533: PUSH
39534: LD_INT 2
39536: ARRAY
39537: PPUSH
39538: LD_VAR 0 3
39542: PPUSH
39543: CALL_OW 48
// result := IsPlaced ( unit ) ;
39547: LD_ADDR_VAR 0 4
39551: PUSH
39552: LD_VAR 0 1
39556: PPUSH
39557: CALL_OW 305
39561: ST_TO_ADDR
// exit ;
39562: POP
39563: POP
39564: GO 39570
// end ; end ;
39566: GO 39445
39568: POP
39569: POP
// end ;
39570: LD_VAR 0 4
39574: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
39575: LD_INT 0
39577: PPUSH
39578: PPUSH
39579: PPUSH
// if not side or side > 8 then
39580: LD_VAR 0 1
39584: NOT
39585: PUSH
39586: LD_VAR 0 1
39590: PUSH
39591: LD_INT 8
39593: GREATER
39594: OR
39595: IFFALSE 39599
// exit ;
39597: GO 39786
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
39599: LD_ADDR_VAR 0 4
39603: PUSH
39604: LD_INT 22
39606: PUSH
39607: LD_VAR 0 1
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: LD_INT 21
39618: PUSH
39619: LD_INT 3
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PPUSH
39630: CALL_OW 69
39634: ST_TO_ADDR
// if not tmp then
39635: LD_VAR 0 4
39639: NOT
39640: IFFALSE 39644
// exit ;
39642: GO 39786
// enable_addtolog := true ;
39644: LD_ADDR_OWVAR 81
39648: PUSH
39649: LD_INT 1
39651: ST_TO_ADDR
// AddToLog ( [ ) ;
39652: LD_STRING [
39654: PPUSH
39655: CALL_OW 561
// for i in tmp do
39659: LD_ADDR_VAR 0 3
39663: PUSH
39664: LD_VAR 0 4
39668: PUSH
39669: FOR_IN
39670: IFFALSE 39777
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
39672: LD_STRING [
39674: PUSH
39675: LD_VAR 0 3
39679: PPUSH
39680: CALL_OW 266
39684: STR
39685: PUSH
39686: LD_STRING , 
39688: STR
39689: PUSH
39690: LD_VAR 0 3
39694: PPUSH
39695: CALL_OW 250
39699: STR
39700: PUSH
39701: LD_STRING , 
39703: STR
39704: PUSH
39705: LD_VAR 0 3
39709: PPUSH
39710: CALL_OW 251
39714: STR
39715: PUSH
39716: LD_STRING , 
39718: STR
39719: PUSH
39720: LD_VAR 0 3
39724: PPUSH
39725: CALL_OW 254
39729: STR
39730: PUSH
39731: LD_STRING , 
39733: STR
39734: PUSH
39735: LD_VAR 0 3
39739: PPUSH
39740: LD_INT 1
39742: PPUSH
39743: CALL_OW 268
39747: STR
39748: PUSH
39749: LD_STRING , 
39751: STR
39752: PUSH
39753: LD_VAR 0 3
39757: PPUSH
39758: LD_INT 2
39760: PPUSH
39761: CALL_OW 268
39765: STR
39766: PUSH
39767: LD_STRING ],
39769: STR
39770: PPUSH
39771: CALL_OW 561
// end ;
39775: GO 39669
39777: POP
39778: POP
// AddToLog ( ]; ) ;
39779: LD_STRING ];
39781: PPUSH
39782: CALL_OW 561
// end ;
39786: LD_VAR 0 2
39790: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
39791: LD_INT 0
39793: PPUSH
39794: PPUSH
39795: PPUSH
39796: PPUSH
39797: PPUSH
// if not area or not rate or not max then
39798: LD_VAR 0 1
39802: NOT
39803: PUSH
39804: LD_VAR 0 2
39808: NOT
39809: OR
39810: PUSH
39811: LD_VAR 0 4
39815: NOT
39816: OR
39817: IFFALSE 39821
// exit ;
39819: GO 40013
// while 1 do
39821: LD_INT 1
39823: IFFALSE 40013
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
39825: LD_ADDR_VAR 0 9
39829: PUSH
39830: LD_VAR 0 1
39834: PPUSH
39835: LD_INT 1
39837: PPUSH
39838: CALL_OW 287
39842: PUSH
39843: LD_INT 10
39845: MUL
39846: ST_TO_ADDR
// r := rate / 10 ;
39847: LD_ADDR_VAR 0 7
39851: PUSH
39852: LD_VAR 0 2
39856: PUSH
39857: LD_INT 10
39859: DIVREAL
39860: ST_TO_ADDR
// time := 1 1$00 ;
39861: LD_ADDR_VAR 0 8
39865: PUSH
39866: LD_INT 2100
39868: ST_TO_ADDR
// if amount < min then
39869: LD_VAR 0 9
39873: PUSH
39874: LD_VAR 0 3
39878: LESS
39879: IFFALSE 39897
// r := r * 2 else
39881: LD_ADDR_VAR 0 7
39885: PUSH
39886: LD_VAR 0 7
39890: PUSH
39891: LD_INT 2
39893: MUL
39894: ST_TO_ADDR
39895: GO 39923
// if amount > max then
39897: LD_VAR 0 9
39901: PUSH
39902: LD_VAR 0 4
39906: GREATER
39907: IFFALSE 39923
// r := r / 2 ;
39909: LD_ADDR_VAR 0 7
39913: PUSH
39914: LD_VAR 0 7
39918: PUSH
39919: LD_INT 2
39921: DIVREAL
39922: ST_TO_ADDR
// time := time / r ;
39923: LD_ADDR_VAR 0 8
39927: PUSH
39928: LD_VAR 0 8
39932: PUSH
39933: LD_VAR 0 7
39937: DIVREAL
39938: ST_TO_ADDR
// if time < 0 then
39939: LD_VAR 0 8
39943: PUSH
39944: LD_INT 0
39946: LESS
39947: IFFALSE 39964
// time := time * - 1 ;
39949: LD_ADDR_VAR 0 8
39953: PUSH
39954: LD_VAR 0 8
39958: PUSH
39959: LD_INT 1
39961: NEG
39962: MUL
39963: ST_TO_ADDR
// wait ( time ) ;
39964: LD_VAR 0 8
39968: PPUSH
39969: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
39973: LD_INT 35
39975: PPUSH
39976: LD_INT 875
39978: PPUSH
39979: CALL_OW 12
39983: PPUSH
39984: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
39988: LD_INT 1
39990: PPUSH
39991: LD_INT 5
39993: PPUSH
39994: CALL_OW 12
39998: PPUSH
39999: LD_VAR 0 1
40003: PPUSH
40004: LD_INT 1
40006: PPUSH
40007: CALL_OW 55
// end ;
40011: GO 39821
// end ;
40013: LD_VAR 0 5
40017: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
40018: LD_INT 0
40020: PPUSH
40021: PPUSH
40022: PPUSH
40023: PPUSH
40024: PPUSH
40025: PPUSH
40026: PPUSH
40027: PPUSH
// if not turrets or not factories then
40028: LD_VAR 0 1
40032: NOT
40033: PUSH
40034: LD_VAR 0 2
40038: NOT
40039: OR
40040: IFFALSE 40044
// exit ;
40042: GO 40351
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
40044: LD_ADDR_VAR 0 10
40048: PUSH
40049: LD_INT 5
40051: PUSH
40052: LD_INT 6
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 2
40061: PUSH
40062: LD_INT 4
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 3
40071: PUSH
40072: LD_INT 5
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 24
40086: PUSH
40087: LD_INT 25
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 23
40096: PUSH
40097: LD_INT 27
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 42
40110: PUSH
40111: LD_INT 43
40113: PUSH
40114: EMPTY
40115: LIST
40116: LIST
40117: PUSH
40118: LD_INT 44
40120: PUSH
40121: LD_INT 46
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 45
40130: PUSH
40131: LD_INT 47
40133: PUSH
40134: EMPTY
40135: LIST
40136: LIST
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: LIST
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: LIST
40147: ST_TO_ADDR
// result := [ ] ;
40148: LD_ADDR_VAR 0 3
40152: PUSH
40153: EMPTY
40154: ST_TO_ADDR
// for i in turrets do
40155: LD_ADDR_VAR 0 4
40159: PUSH
40160: LD_VAR 0 1
40164: PUSH
40165: FOR_IN
40166: IFFALSE 40349
// begin nat := GetNation ( i ) ;
40168: LD_ADDR_VAR 0 7
40172: PUSH
40173: LD_VAR 0 4
40177: PPUSH
40178: CALL_OW 248
40182: ST_TO_ADDR
// weapon := 0 ;
40183: LD_ADDR_VAR 0 8
40187: PUSH
40188: LD_INT 0
40190: ST_TO_ADDR
// if not nat then
40191: LD_VAR 0 7
40195: NOT
40196: IFFALSE 40200
// continue ;
40198: GO 40165
// for j in list [ nat ] do
40200: LD_ADDR_VAR 0 5
40204: PUSH
40205: LD_VAR 0 10
40209: PUSH
40210: LD_VAR 0 7
40214: ARRAY
40215: PUSH
40216: FOR_IN
40217: IFFALSE 40258
// if GetBWeapon ( i ) = j [ 1 ] then
40219: LD_VAR 0 4
40223: PPUSH
40224: CALL_OW 269
40228: PUSH
40229: LD_VAR 0 5
40233: PUSH
40234: LD_INT 1
40236: ARRAY
40237: EQUAL
40238: IFFALSE 40256
// begin weapon := j [ 2 ] ;
40240: LD_ADDR_VAR 0 8
40244: PUSH
40245: LD_VAR 0 5
40249: PUSH
40250: LD_INT 2
40252: ARRAY
40253: ST_TO_ADDR
// break ;
40254: GO 40258
// end ;
40256: GO 40216
40258: POP
40259: POP
// if not weapon then
40260: LD_VAR 0 8
40264: NOT
40265: IFFALSE 40269
// continue ;
40267: GO 40165
// for k in factories do
40269: LD_ADDR_VAR 0 6
40273: PUSH
40274: LD_VAR 0 2
40278: PUSH
40279: FOR_IN
40280: IFFALSE 40345
// begin weapons := AvailableWeaponList ( k ) ;
40282: LD_ADDR_VAR 0 9
40286: PUSH
40287: LD_VAR 0 6
40291: PPUSH
40292: CALL_OW 478
40296: ST_TO_ADDR
// if not weapons then
40297: LD_VAR 0 9
40301: NOT
40302: IFFALSE 40306
// continue ;
40304: GO 40279
// if weapon in weapons then
40306: LD_VAR 0 8
40310: PUSH
40311: LD_VAR 0 9
40315: IN
40316: IFFALSE 40343
// begin result := [ i , weapon ] ;
40318: LD_ADDR_VAR 0 3
40322: PUSH
40323: LD_VAR 0 4
40327: PUSH
40328: LD_VAR 0 8
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: ST_TO_ADDR
// exit ;
40337: POP
40338: POP
40339: POP
40340: POP
40341: GO 40351
// end ; end ;
40343: GO 40279
40345: POP
40346: POP
// end ;
40347: GO 40165
40349: POP
40350: POP
// end ;
40351: LD_VAR 0 3
40355: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
40356: LD_INT 0
40358: PPUSH
// if not side or side > 8 then
40359: LD_VAR 0 3
40363: NOT
40364: PUSH
40365: LD_VAR 0 3
40369: PUSH
40370: LD_INT 8
40372: GREATER
40373: OR
40374: IFFALSE 40378
// exit ;
40376: GO 40437
// if not range then
40378: LD_VAR 0 4
40382: NOT
40383: IFFALSE 40394
// range := - 12 ;
40385: LD_ADDR_VAR 0 4
40389: PUSH
40390: LD_INT 12
40392: NEG
40393: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
40394: LD_VAR 0 1
40398: PPUSH
40399: LD_VAR 0 2
40403: PPUSH
40404: LD_VAR 0 3
40408: PPUSH
40409: LD_VAR 0 4
40413: PPUSH
40414: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
40418: LD_VAR 0 1
40422: PPUSH
40423: LD_VAR 0 2
40427: PPUSH
40428: LD_VAR 0 3
40432: PPUSH
40433: CALL_OW 331
// end ;
40437: LD_VAR 0 5
40441: RET
// export function Video ( mode ) ; begin
40442: LD_INT 0
40444: PPUSH
// ingame_video = mode ;
40445: LD_ADDR_OWVAR 52
40449: PUSH
40450: LD_VAR 0 1
40454: ST_TO_ADDR
// interface_hidden = mode ;
40455: LD_ADDR_OWVAR 54
40459: PUSH
40460: LD_VAR 0 1
40464: ST_TO_ADDR
// end ;
40465: LD_VAR 0 2
40469: RET
// export function Join ( array , element ) ; begin
40470: LD_INT 0
40472: PPUSH
// result := Replace ( array , array + 1 , element ) ;
40473: LD_ADDR_VAR 0 3
40477: PUSH
40478: LD_VAR 0 1
40482: PPUSH
40483: LD_VAR 0 1
40487: PUSH
40488: LD_INT 1
40490: PLUS
40491: PPUSH
40492: LD_VAR 0 2
40496: PPUSH
40497: CALL_OW 1
40501: ST_TO_ADDR
// end ;
40502: LD_VAR 0 3
40506: RET
// export function JoinUnion ( array , element ) ; begin
40507: LD_INT 0
40509: PPUSH
// result := array union element ;
40510: LD_ADDR_VAR 0 3
40514: PUSH
40515: LD_VAR 0 1
40519: PUSH
40520: LD_VAR 0 2
40524: UNION
40525: ST_TO_ADDR
// end ;
40526: LD_VAR 0 3
40530: RET
// export function GetBehemoths ( side ) ; begin
40531: LD_INT 0
40533: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
40534: LD_ADDR_VAR 0 2
40538: PUSH
40539: LD_INT 22
40541: PUSH
40542: LD_VAR 0 1
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: PUSH
40551: LD_INT 31
40553: PUSH
40554: LD_INT 25
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: PPUSH
40565: CALL_OW 69
40569: ST_TO_ADDR
// end ;
40570: LD_VAR 0 2
40574: RET
// export function Shuffle ( array ) ; var i , index ; begin
40575: LD_INT 0
40577: PPUSH
40578: PPUSH
40579: PPUSH
// result := [ ] ;
40580: LD_ADDR_VAR 0 2
40584: PUSH
40585: EMPTY
40586: ST_TO_ADDR
// if not array then
40587: LD_VAR 0 1
40591: NOT
40592: IFFALSE 40596
// exit ;
40594: GO 40695
// Randomize ;
40596: CALL_OW 10
// for i = array downto 1 do
40600: LD_ADDR_VAR 0 3
40604: PUSH
40605: DOUBLE
40606: LD_VAR 0 1
40610: INC
40611: ST_TO_ADDR
40612: LD_INT 1
40614: PUSH
40615: FOR_DOWNTO
40616: IFFALSE 40693
// begin index := rand ( 1 , array ) ;
40618: LD_ADDR_VAR 0 4
40622: PUSH
40623: LD_INT 1
40625: PPUSH
40626: LD_VAR 0 1
40630: PPUSH
40631: CALL_OW 12
40635: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
40636: LD_ADDR_VAR 0 2
40640: PUSH
40641: LD_VAR 0 2
40645: PPUSH
40646: LD_VAR 0 2
40650: PUSH
40651: LD_INT 1
40653: PLUS
40654: PPUSH
40655: LD_VAR 0 1
40659: PUSH
40660: LD_VAR 0 4
40664: ARRAY
40665: PPUSH
40666: CALL_OW 2
40670: ST_TO_ADDR
// array := Delete ( array , index ) ;
40671: LD_ADDR_VAR 0 1
40675: PUSH
40676: LD_VAR 0 1
40680: PPUSH
40681: LD_VAR 0 4
40685: PPUSH
40686: CALL_OW 3
40690: ST_TO_ADDR
// end ;
40691: GO 40615
40693: POP
40694: POP
// end ;
40695: LD_VAR 0 2
40699: RET
// export function GetBaseMaterials ( base ) ; begin
40700: LD_INT 0
40702: PPUSH
// result := [ 0 , 0 , 0 ] ;
40703: LD_ADDR_VAR 0 2
40707: PUSH
40708: LD_INT 0
40710: PUSH
40711: LD_INT 0
40713: PUSH
40714: LD_INT 0
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: LIST
40721: ST_TO_ADDR
// if not base then
40722: LD_VAR 0 1
40726: NOT
40727: IFFALSE 40731
// exit ;
40729: GO 40780
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
40731: LD_ADDR_VAR 0 2
40735: PUSH
40736: LD_VAR 0 1
40740: PPUSH
40741: LD_INT 1
40743: PPUSH
40744: CALL_OW 275
40748: PUSH
40749: LD_VAR 0 1
40753: PPUSH
40754: LD_INT 2
40756: PPUSH
40757: CALL_OW 275
40761: PUSH
40762: LD_VAR 0 1
40766: PPUSH
40767: LD_INT 3
40769: PPUSH
40770: CALL_OW 275
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: LIST
40779: ST_TO_ADDR
// end ;
40780: LD_VAR 0 2
40784: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
40785: LD_INT 0
40787: PPUSH
40788: PPUSH
// result := array ;
40789: LD_ADDR_VAR 0 3
40793: PUSH
40794: LD_VAR 0 1
40798: ST_TO_ADDR
// if size > 0 then
40799: LD_VAR 0 2
40803: PUSH
40804: LD_INT 0
40806: GREATER
40807: IFFALSE 40853
// for i := array downto size do
40809: LD_ADDR_VAR 0 4
40813: PUSH
40814: DOUBLE
40815: LD_VAR 0 1
40819: INC
40820: ST_TO_ADDR
40821: LD_VAR 0 2
40825: PUSH
40826: FOR_DOWNTO
40827: IFFALSE 40851
// result := Delete ( result , result ) ;
40829: LD_ADDR_VAR 0 3
40833: PUSH
40834: LD_VAR 0 3
40838: PPUSH
40839: LD_VAR 0 3
40843: PPUSH
40844: CALL_OW 3
40848: ST_TO_ADDR
40849: GO 40826
40851: POP
40852: POP
// end ;
40853: LD_VAR 0 3
40857: RET
// export function ComExit ( unit ) ; var tmp ; begin
40858: LD_INT 0
40860: PPUSH
40861: PPUSH
// if not IsInUnit ( unit ) then
40862: LD_VAR 0 1
40866: PPUSH
40867: CALL_OW 310
40871: NOT
40872: IFFALSE 40876
// exit ;
40874: GO 40936
// tmp := IsInUnit ( unit ) ;
40876: LD_ADDR_VAR 0 3
40880: PUSH
40881: LD_VAR 0 1
40885: PPUSH
40886: CALL_OW 310
40890: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
40891: LD_VAR 0 3
40895: PPUSH
40896: CALL_OW 247
40900: PUSH
40901: LD_INT 2
40903: EQUAL
40904: IFFALSE 40917
// ComExitVehicle ( unit ) else
40906: LD_VAR 0 1
40910: PPUSH
40911: CALL_OW 121
40915: GO 40926
// ComExitBuilding ( unit ) ;
40917: LD_VAR 0 1
40921: PPUSH
40922: CALL_OW 122
// result := tmp ;
40926: LD_ADDR_VAR 0 2
40930: PUSH
40931: LD_VAR 0 3
40935: ST_TO_ADDR
// end ;
40936: LD_VAR 0 2
40940: RET
// export function ResetHc ; begin
40941: LD_INT 0
40943: PPUSH
// InitHc ;
40944: CALL_OW 19
// hc_importance := 0 ;
40948: LD_ADDR_OWVAR 32
40952: PUSH
40953: LD_INT 0
40955: ST_TO_ADDR
// end ;
40956: LD_VAR 0 1
40960: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
40961: LD_INT 0
40963: PPUSH
40964: PPUSH
40965: PPUSH
// _x := ( x1 + x2 ) div 2 ;
40966: LD_ADDR_VAR 0 6
40970: PUSH
40971: LD_VAR 0 1
40975: PUSH
40976: LD_VAR 0 3
40980: PLUS
40981: PUSH
40982: LD_INT 2
40984: DIV
40985: ST_TO_ADDR
// if _x < 0 then
40986: LD_VAR 0 6
40990: PUSH
40991: LD_INT 0
40993: LESS
40994: IFFALSE 41011
// _x := _x * - 1 ;
40996: LD_ADDR_VAR 0 6
41000: PUSH
41001: LD_VAR 0 6
41005: PUSH
41006: LD_INT 1
41008: NEG
41009: MUL
41010: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
41011: LD_ADDR_VAR 0 7
41015: PUSH
41016: LD_VAR 0 2
41020: PUSH
41021: LD_VAR 0 4
41025: PLUS
41026: PUSH
41027: LD_INT 2
41029: DIV
41030: ST_TO_ADDR
// if _y < 0 then
41031: LD_VAR 0 7
41035: PUSH
41036: LD_INT 0
41038: LESS
41039: IFFALSE 41056
// _y := _y * - 1 ;
41041: LD_ADDR_VAR 0 7
41045: PUSH
41046: LD_VAR 0 7
41050: PUSH
41051: LD_INT 1
41053: NEG
41054: MUL
41055: ST_TO_ADDR
// result := [ _x , _y ] ;
41056: LD_ADDR_VAR 0 5
41060: PUSH
41061: LD_VAR 0 6
41065: PUSH
41066: LD_VAR 0 7
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: ST_TO_ADDR
// end ;
41075: LD_VAR 0 5
41079: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
41080: LD_INT 0
41082: PPUSH
41083: PPUSH
41084: PPUSH
41085: PPUSH
// task := GetTaskList ( unit ) ;
41086: LD_ADDR_VAR 0 7
41090: PUSH
41091: LD_VAR 0 1
41095: PPUSH
41096: CALL_OW 437
41100: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
41101: LD_VAR 0 7
41105: NOT
41106: PUSH
41107: LD_VAR 0 1
41111: PPUSH
41112: LD_VAR 0 2
41116: PPUSH
41117: CALL_OW 308
41121: NOT
41122: AND
41123: IFFALSE 41127
// exit ;
41125: GO 41245
// if IsInArea ( unit , area ) then
41127: LD_VAR 0 1
41131: PPUSH
41132: LD_VAR 0 2
41136: PPUSH
41137: CALL_OW 308
41141: IFFALSE 41159
// begin ComMoveToArea ( unit , goAway ) ;
41143: LD_VAR 0 1
41147: PPUSH
41148: LD_VAR 0 3
41152: PPUSH
41153: CALL_OW 113
// exit ;
41157: GO 41245
// end ; if task [ 1 ] [ 1 ] <> M then
41159: LD_VAR 0 7
41163: PUSH
41164: LD_INT 1
41166: ARRAY
41167: PUSH
41168: LD_INT 1
41170: ARRAY
41171: PUSH
41172: LD_STRING M
41174: NONEQUAL
41175: IFFALSE 41179
// exit ;
41177: GO 41245
// x := task [ 1 ] [ 2 ] ;
41179: LD_ADDR_VAR 0 5
41183: PUSH
41184: LD_VAR 0 7
41188: PUSH
41189: LD_INT 1
41191: ARRAY
41192: PUSH
41193: LD_INT 2
41195: ARRAY
41196: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
41197: LD_ADDR_VAR 0 6
41201: PUSH
41202: LD_VAR 0 7
41206: PUSH
41207: LD_INT 1
41209: ARRAY
41210: PUSH
41211: LD_INT 3
41213: ARRAY
41214: ST_TO_ADDR
// if InArea ( x , y , area ) then
41215: LD_VAR 0 5
41219: PPUSH
41220: LD_VAR 0 6
41224: PPUSH
41225: LD_VAR 0 2
41229: PPUSH
41230: CALL_OW 309
41234: IFFALSE 41245
// ComStop ( unit ) ;
41236: LD_VAR 0 1
41240: PPUSH
41241: CALL_OW 141
// end ;
41245: LD_VAR 0 4
41249: RET
// export function Abs ( value ) ; begin
41250: LD_INT 0
41252: PPUSH
// result := value ;
41253: LD_ADDR_VAR 0 2
41257: PUSH
41258: LD_VAR 0 1
41262: ST_TO_ADDR
// if value < 0 then
41263: LD_VAR 0 1
41267: PUSH
41268: LD_INT 0
41270: LESS
41271: IFFALSE 41288
// result := value * - 1 ;
41273: LD_ADDR_VAR 0 2
41277: PUSH
41278: LD_VAR 0 1
41282: PUSH
41283: LD_INT 1
41285: NEG
41286: MUL
41287: ST_TO_ADDR
// end ;
41288: LD_VAR 0 2
41292: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
41293: LD_INT 0
41295: PPUSH
41296: PPUSH
41297: PPUSH
41298: PPUSH
41299: PPUSH
41300: PPUSH
41301: PPUSH
41302: PPUSH
// if not unit or not building then
41303: LD_VAR 0 1
41307: NOT
41308: PUSH
41309: LD_VAR 0 2
41313: NOT
41314: OR
41315: IFFALSE 41319
// exit ;
41317: GO 41545
// x := GetX ( building ) ;
41319: LD_ADDR_VAR 0 4
41323: PUSH
41324: LD_VAR 0 2
41328: PPUSH
41329: CALL_OW 250
41333: ST_TO_ADDR
// y := GetY ( building ) ;
41334: LD_ADDR_VAR 0 6
41338: PUSH
41339: LD_VAR 0 2
41343: PPUSH
41344: CALL_OW 251
41348: ST_TO_ADDR
// d := GetDir ( building ) ;
41349: LD_ADDR_VAR 0 8
41353: PUSH
41354: LD_VAR 0 2
41358: PPUSH
41359: CALL_OW 254
41363: ST_TO_ADDR
// r := 4 ;
41364: LD_ADDR_VAR 0 9
41368: PUSH
41369: LD_INT 4
41371: ST_TO_ADDR
// for i := 1 to 5 do
41372: LD_ADDR_VAR 0 10
41376: PUSH
41377: DOUBLE
41378: LD_INT 1
41380: DEC
41381: ST_TO_ADDR
41382: LD_INT 5
41384: PUSH
41385: FOR_TO
41386: IFFALSE 41543
// begin _x := ShiftX ( x , d , r + i ) ;
41388: LD_ADDR_VAR 0 5
41392: PUSH
41393: LD_VAR 0 4
41397: PPUSH
41398: LD_VAR 0 8
41402: PPUSH
41403: LD_VAR 0 9
41407: PUSH
41408: LD_VAR 0 10
41412: PLUS
41413: PPUSH
41414: CALL_OW 272
41418: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
41419: LD_ADDR_VAR 0 7
41423: PUSH
41424: LD_VAR 0 6
41428: PPUSH
41429: LD_VAR 0 8
41433: PPUSH
41434: LD_VAR 0 9
41438: PUSH
41439: LD_VAR 0 10
41443: PLUS
41444: PPUSH
41445: CALL_OW 273
41449: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
41450: LD_VAR 0 5
41454: PPUSH
41455: LD_VAR 0 7
41459: PPUSH
41460: CALL_OW 488
41464: PUSH
41465: LD_VAR 0 5
41469: PPUSH
41470: LD_VAR 0 7
41474: PPUSH
41475: CALL_OW 428
41479: PPUSH
41480: CALL_OW 247
41484: PUSH
41485: LD_INT 3
41487: PUSH
41488: LD_INT 2
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: IN
41495: NOT
41496: AND
41497: IFFALSE 41541
// begin ComMoveXY ( unit , _x , _y ) ;
41499: LD_VAR 0 1
41503: PPUSH
41504: LD_VAR 0 5
41508: PPUSH
41509: LD_VAR 0 7
41513: PPUSH
41514: CALL_OW 111
// result := [ _x , _y ] ;
41518: LD_ADDR_VAR 0 3
41522: PUSH
41523: LD_VAR 0 5
41527: PUSH
41528: LD_VAR 0 7
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: ST_TO_ADDR
// exit ;
41537: POP
41538: POP
41539: GO 41545
// end ; end ;
41541: GO 41385
41543: POP
41544: POP
// end ; end_of_file
41545: LD_VAR 0 3
41549: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
41550: LD_INT 0
41552: PPUSH
41553: PPUSH
// skirmish := false ;
41554: LD_ADDR_EXP 12
41558: PUSH
41559: LD_INT 0
41561: ST_TO_ADDR
// debug_mc := false ;
41562: LD_ADDR_EXP 13
41566: PUSH
41567: LD_INT 0
41569: ST_TO_ADDR
// mc_bases := [ ] ;
41570: LD_ADDR_EXP 14
41574: PUSH
41575: EMPTY
41576: ST_TO_ADDR
// mc_sides := [ ] ;
41577: LD_ADDR_EXP 40
41581: PUSH
41582: EMPTY
41583: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
41584: LD_ADDR_EXP 15
41588: PUSH
41589: EMPTY
41590: ST_TO_ADDR
// mc_building_repairs := [ ] ;
41591: LD_ADDR_EXP 16
41595: PUSH
41596: EMPTY
41597: ST_TO_ADDR
// mc_need_heal := [ ] ;
41598: LD_ADDR_EXP 17
41602: PUSH
41603: EMPTY
41604: ST_TO_ADDR
// mc_healers := [ ] ;
41605: LD_ADDR_EXP 18
41609: PUSH
41610: EMPTY
41611: ST_TO_ADDR
// mc_build_list := [ ] ;
41612: LD_ADDR_EXP 19
41616: PUSH
41617: EMPTY
41618: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
41619: LD_ADDR_EXP 46
41623: PUSH
41624: EMPTY
41625: ST_TO_ADDR
// mc_builders := [ ] ;
41626: LD_ADDR_EXP 20
41630: PUSH
41631: EMPTY
41632: ST_TO_ADDR
// mc_construct_list := [ ] ;
41633: LD_ADDR_EXP 21
41637: PUSH
41638: EMPTY
41639: ST_TO_ADDR
// mc_turret_list := [ ] ;
41640: LD_ADDR_EXP 22
41644: PUSH
41645: EMPTY
41646: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
41647: LD_ADDR_EXP 23
41651: PUSH
41652: EMPTY
41653: ST_TO_ADDR
// mc_miners := [ ] ;
41654: LD_ADDR_EXP 28
41658: PUSH
41659: EMPTY
41660: ST_TO_ADDR
// mc_mines := [ ] ;
41661: LD_ADDR_EXP 27
41665: PUSH
41666: EMPTY
41667: ST_TO_ADDR
// mc_minefields := [ ] ;
41668: LD_ADDR_EXP 29
41672: PUSH
41673: EMPTY
41674: ST_TO_ADDR
// mc_crates := [ ] ;
41675: LD_ADDR_EXP 30
41679: PUSH
41680: EMPTY
41681: ST_TO_ADDR
// mc_crates_collector := [ ] ;
41682: LD_ADDR_EXP 31
41686: PUSH
41687: EMPTY
41688: ST_TO_ADDR
// mc_crates_area := [ ] ;
41689: LD_ADDR_EXP 32
41693: PUSH
41694: EMPTY
41695: ST_TO_ADDR
// mc_vehicles := [ ] ;
41696: LD_ADDR_EXP 33
41700: PUSH
41701: EMPTY
41702: ST_TO_ADDR
// mc_attack := [ ] ;
41703: LD_ADDR_EXP 34
41707: PUSH
41708: EMPTY
41709: ST_TO_ADDR
// mc_produce := [ ] ;
41710: LD_ADDR_EXP 35
41714: PUSH
41715: EMPTY
41716: ST_TO_ADDR
// mc_defender := [ ] ;
41717: LD_ADDR_EXP 36
41721: PUSH
41722: EMPTY
41723: ST_TO_ADDR
// mc_parking := [ ] ;
41724: LD_ADDR_EXP 38
41728: PUSH
41729: EMPTY
41730: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
41731: LD_ADDR_EXP 24
41735: PUSH
41736: EMPTY
41737: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
41738: LD_ADDR_EXP 26
41742: PUSH
41743: EMPTY
41744: ST_TO_ADDR
// mc_scan := [ ] ;
41745: LD_ADDR_EXP 37
41749: PUSH
41750: EMPTY
41751: ST_TO_ADDR
// mc_scan_area := [ ] ;
41752: LD_ADDR_EXP 39
41756: PUSH
41757: EMPTY
41758: ST_TO_ADDR
// mc_tech := [ ] ;
41759: LD_ADDR_EXP 41
41763: PUSH
41764: EMPTY
41765: ST_TO_ADDR
// mc_class := [ ] ;
41766: LD_ADDR_EXP 55
41770: PUSH
41771: EMPTY
41772: ST_TO_ADDR
// mc_class_case_use := [ ] ;
41773: LD_ADDR_EXP 56
41777: PUSH
41778: EMPTY
41779: ST_TO_ADDR
// end ;
41780: LD_VAR 0 1
41784: RET
// export function MC_Kill ( base ) ; begin
41785: LD_INT 0
41787: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
41788: LD_ADDR_EXP 14
41792: PUSH
41793: LD_EXP 14
41797: PPUSH
41798: LD_VAR 0 1
41802: PPUSH
41803: EMPTY
41804: PPUSH
41805: CALL_OW 1
41809: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
41810: LD_ADDR_EXP 15
41814: PUSH
41815: LD_EXP 15
41819: PPUSH
41820: LD_VAR 0 1
41824: PPUSH
41825: EMPTY
41826: PPUSH
41827: CALL_OW 1
41831: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
41832: LD_ADDR_EXP 16
41836: PUSH
41837: LD_EXP 16
41841: PPUSH
41842: LD_VAR 0 1
41846: PPUSH
41847: EMPTY
41848: PPUSH
41849: CALL_OW 1
41853: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
41854: LD_ADDR_EXP 17
41858: PUSH
41859: LD_EXP 17
41863: PPUSH
41864: LD_VAR 0 1
41868: PPUSH
41869: EMPTY
41870: PPUSH
41871: CALL_OW 1
41875: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
41876: LD_ADDR_EXP 18
41880: PUSH
41881: LD_EXP 18
41885: PPUSH
41886: LD_VAR 0 1
41890: PPUSH
41891: EMPTY
41892: PPUSH
41893: CALL_OW 1
41897: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
41898: LD_ADDR_EXP 19
41902: PUSH
41903: LD_EXP 19
41907: PPUSH
41908: LD_VAR 0 1
41912: PPUSH
41913: EMPTY
41914: PPUSH
41915: CALL_OW 1
41919: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
41920: LD_ADDR_EXP 20
41924: PUSH
41925: LD_EXP 20
41929: PPUSH
41930: LD_VAR 0 1
41934: PPUSH
41935: EMPTY
41936: PPUSH
41937: CALL_OW 1
41941: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
41942: LD_ADDR_EXP 21
41946: PUSH
41947: LD_EXP 21
41951: PPUSH
41952: LD_VAR 0 1
41956: PPUSH
41957: EMPTY
41958: PPUSH
41959: CALL_OW 1
41963: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
41964: LD_ADDR_EXP 22
41968: PUSH
41969: LD_EXP 22
41973: PPUSH
41974: LD_VAR 0 1
41978: PPUSH
41979: EMPTY
41980: PPUSH
41981: CALL_OW 1
41985: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41986: LD_ADDR_EXP 23
41990: PUSH
41991: LD_EXP 23
41995: PPUSH
41996: LD_VAR 0 1
42000: PPUSH
42001: EMPTY
42002: PPUSH
42003: CALL_OW 1
42007: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
42008: LD_ADDR_EXP 24
42012: PUSH
42013: LD_EXP 24
42017: PPUSH
42018: LD_VAR 0 1
42022: PPUSH
42023: EMPTY
42024: PPUSH
42025: CALL_OW 1
42029: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
42030: LD_ADDR_EXP 25
42034: PUSH
42035: LD_EXP 25
42039: PPUSH
42040: LD_VAR 0 1
42044: PPUSH
42045: LD_INT 0
42047: PPUSH
42048: CALL_OW 1
42052: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
42053: LD_ADDR_EXP 26
42057: PUSH
42058: LD_EXP 26
42062: PPUSH
42063: LD_VAR 0 1
42067: PPUSH
42068: EMPTY
42069: PPUSH
42070: CALL_OW 1
42074: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
42075: LD_ADDR_EXP 27
42079: PUSH
42080: LD_EXP 27
42084: PPUSH
42085: LD_VAR 0 1
42089: PPUSH
42090: EMPTY
42091: PPUSH
42092: CALL_OW 1
42096: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
42097: LD_ADDR_EXP 28
42101: PUSH
42102: LD_EXP 28
42106: PPUSH
42107: LD_VAR 0 1
42111: PPUSH
42112: EMPTY
42113: PPUSH
42114: CALL_OW 1
42118: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
42119: LD_ADDR_EXP 29
42123: PUSH
42124: LD_EXP 29
42128: PPUSH
42129: LD_VAR 0 1
42133: PPUSH
42134: EMPTY
42135: PPUSH
42136: CALL_OW 1
42140: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
42141: LD_ADDR_EXP 30
42145: PUSH
42146: LD_EXP 30
42150: PPUSH
42151: LD_VAR 0 1
42155: PPUSH
42156: EMPTY
42157: PPUSH
42158: CALL_OW 1
42162: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
42163: LD_ADDR_EXP 31
42167: PUSH
42168: LD_EXP 31
42172: PPUSH
42173: LD_VAR 0 1
42177: PPUSH
42178: EMPTY
42179: PPUSH
42180: CALL_OW 1
42184: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
42185: LD_ADDR_EXP 32
42189: PUSH
42190: LD_EXP 32
42194: PPUSH
42195: LD_VAR 0 1
42199: PPUSH
42200: EMPTY
42201: PPUSH
42202: CALL_OW 1
42206: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
42207: LD_ADDR_EXP 33
42211: PUSH
42212: LD_EXP 33
42216: PPUSH
42217: LD_VAR 0 1
42221: PPUSH
42222: EMPTY
42223: PPUSH
42224: CALL_OW 1
42228: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
42229: LD_ADDR_EXP 34
42233: PUSH
42234: LD_EXP 34
42238: PPUSH
42239: LD_VAR 0 1
42243: PPUSH
42244: EMPTY
42245: PPUSH
42246: CALL_OW 1
42250: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
42251: LD_ADDR_EXP 35
42255: PUSH
42256: LD_EXP 35
42260: PPUSH
42261: LD_VAR 0 1
42265: PPUSH
42266: EMPTY
42267: PPUSH
42268: CALL_OW 1
42272: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
42273: LD_ADDR_EXP 36
42277: PUSH
42278: LD_EXP 36
42282: PPUSH
42283: LD_VAR 0 1
42287: PPUSH
42288: EMPTY
42289: PPUSH
42290: CALL_OW 1
42294: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
42295: LD_ADDR_EXP 37
42299: PUSH
42300: LD_EXP 37
42304: PPUSH
42305: LD_VAR 0 1
42309: PPUSH
42310: EMPTY
42311: PPUSH
42312: CALL_OW 1
42316: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
42317: LD_ADDR_EXP 38
42321: PUSH
42322: LD_EXP 38
42326: PPUSH
42327: LD_VAR 0 1
42331: PPUSH
42332: EMPTY
42333: PPUSH
42334: CALL_OW 1
42338: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
42339: LD_ADDR_EXP 39
42343: PUSH
42344: LD_EXP 39
42348: PPUSH
42349: LD_VAR 0 1
42353: PPUSH
42354: EMPTY
42355: PPUSH
42356: CALL_OW 1
42360: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
42361: LD_ADDR_EXP 41
42365: PUSH
42366: LD_EXP 41
42370: PPUSH
42371: LD_VAR 0 1
42375: PPUSH
42376: EMPTY
42377: PPUSH
42378: CALL_OW 1
42382: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
42383: LD_ADDR_EXP 43
42387: PUSH
42388: LD_EXP 43
42392: PPUSH
42393: LD_VAR 0 1
42397: PPUSH
42398: EMPTY
42399: PPUSH
42400: CALL_OW 1
42404: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
42405: LD_ADDR_EXP 44
42409: PUSH
42410: LD_EXP 44
42414: PPUSH
42415: LD_VAR 0 1
42419: PPUSH
42420: EMPTY
42421: PPUSH
42422: CALL_OW 1
42426: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
42427: LD_ADDR_EXP 45
42431: PUSH
42432: LD_EXP 45
42436: PPUSH
42437: LD_VAR 0 1
42441: PPUSH
42442: EMPTY
42443: PPUSH
42444: CALL_OW 1
42448: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
42449: LD_ADDR_EXP 46
42453: PUSH
42454: LD_EXP 46
42458: PPUSH
42459: LD_VAR 0 1
42463: PPUSH
42464: EMPTY
42465: PPUSH
42466: CALL_OW 1
42470: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
42471: LD_ADDR_EXP 47
42475: PUSH
42476: LD_EXP 47
42480: PPUSH
42481: LD_VAR 0 1
42485: PPUSH
42486: EMPTY
42487: PPUSH
42488: CALL_OW 1
42492: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
42493: LD_ADDR_EXP 48
42497: PUSH
42498: LD_EXP 48
42502: PPUSH
42503: LD_VAR 0 1
42507: PPUSH
42508: EMPTY
42509: PPUSH
42510: CALL_OW 1
42514: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
42515: LD_ADDR_EXP 49
42519: PUSH
42520: LD_EXP 49
42524: PPUSH
42525: LD_VAR 0 1
42529: PPUSH
42530: EMPTY
42531: PPUSH
42532: CALL_OW 1
42536: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
42537: LD_ADDR_EXP 50
42541: PUSH
42542: LD_EXP 50
42546: PPUSH
42547: LD_VAR 0 1
42551: PPUSH
42552: EMPTY
42553: PPUSH
42554: CALL_OW 1
42558: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
42559: LD_ADDR_EXP 51
42563: PUSH
42564: LD_EXP 51
42568: PPUSH
42569: LD_VAR 0 1
42573: PPUSH
42574: EMPTY
42575: PPUSH
42576: CALL_OW 1
42580: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
42581: LD_ADDR_EXP 52
42585: PUSH
42586: LD_EXP 52
42590: PPUSH
42591: LD_VAR 0 1
42595: PPUSH
42596: EMPTY
42597: PPUSH
42598: CALL_OW 1
42602: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
42603: LD_ADDR_EXP 53
42607: PUSH
42608: LD_EXP 53
42612: PPUSH
42613: LD_VAR 0 1
42617: PPUSH
42618: EMPTY
42619: PPUSH
42620: CALL_OW 1
42624: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
42625: LD_ADDR_EXP 54
42629: PUSH
42630: LD_EXP 54
42634: PPUSH
42635: LD_VAR 0 1
42639: PPUSH
42640: EMPTY
42641: PPUSH
42642: CALL_OW 1
42646: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
42647: LD_ADDR_EXP 55
42651: PUSH
42652: LD_EXP 55
42656: PPUSH
42657: LD_VAR 0 1
42661: PPUSH
42662: EMPTY
42663: PPUSH
42664: CALL_OW 1
42668: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
42669: LD_ADDR_EXP 56
42673: PUSH
42674: LD_EXP 56
42678: PPUSH
42679: LD_VAR 0 1
42683: PPUSH
42684: LD_INT 0
42686: PPUSH
42687: CALL_OW 1
42691: ST_TO_ADDR
// end ;
42692: LD_VAR 0 2
42696: RET
// export function MC_Add ( side , units ) ; var base ; begin
42697: LD_INT 0
42699: PPUSH
42700: PPUSH
// base := mc_bases + 1 ;
42701: LD_ADDR_VAR 0 4
42705: PUSH
42706: LD_EXP 14
42710: PUSH
42711: LD_INT 1
42713: PLUS
42714: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
42715: LD_ADDR_EXP 40
42719: PUSH
42720: LD_EXP 40
42724: PPUSH
42725: LD_VAR 0 4
42729: PPUSH
42730: LD_VAR 0 1
42734: PPUSH
42735: CALL_OW 1
42739: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
42740: LD_ADDR_EXP 14
42744: PUSH
42745: LD_EXP 14
42749: PPUSH
42750: LD_VAR 0 4
42754: PPUSH
42755: LD_VAR 0 2
42759: PPUSH
42760: CALL_OW 1
42764: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
42765: LD_ADDR_EXP 15
42769: PUSH
42770: LD_EXP 15
42774: PPUSH
42775: LD_VAR 0 4
42779: PPUSH
42780: EMPTY
42781: PPUSH
42782: CALL_OW 1
42786: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
42787: LD_ADDR_EXP 16
42791: PUSH
42792: LD_EXP 16
42796: PPUSH
42797: LD_VAR 0 4
42801: PPUSH
42802: EMPTY
42803: PPUSH
42804: CALL_OW 1
42808: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
42809: LD_ADDR_EXP 17
42813: PUSH
42814: LD_EXP 17
42818: PPUSH
42819: LD_VAR 0 4
42823: PPUSH
42824: EMPTY
42825: PPUSH
42826: CALL_OW 1
42830: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
42831: LD_ADDR_EXP 18
42835: PUSH
42836: LD_EXP 18
42840: PPUSH
42841: LD_VAR 0 4
42845: PPUSH
42846: EMPTY
42847: PPUSH
42848: CALL_OW 1
42852: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
42853: LD_ADDR_EXP 19
42857: PUSH
42858: LD_EXP 19
42862: PPUSH
42863: LD_VAR 0 4
42867: PPUSH
42868: EMPTY
42869: PPUSH
42870: CALL_OW 1
42874: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
42875: LD_ADDR_EXP 20
42879: PUSH
42880: LD_EXP 20
42884: PPUSH
42885: LD_VAR 0 4
42889: PPUSH
42890: EMPTY
42891: PPUSH
42892: CALL_OW 1
42896: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
42897: LD_ADDR_EXP 21
42901: PUSH
42902: LD_EXP 21
42906: PPUSH
42907: LD_VAR 0 4
42911: PPUSH
42912: EMPTY
42913: PPUSH
42914: CALL_OW 1
42918: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
42919: LD_ADDR_EXP 22
42923: PUSH
42924: LD_EXP 22
42928: PPUSH
42929: LD_VAR 0 4
42933: PPUSH
42934: EMPTY
42935: PPUSH
42936: CALL_OW 1
42940: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
42941: LD_ADDR_EXP 23
42945: PUSH
42946: LD_EXP 23
42950: PPUSH
42951: LD_VAR 0 4
42955: PPUSH
42956: EMPTY
42957: PPUSH
42958: CALL_OW 1
42962: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
42963: LD_ADDR_EXP 24
42967: PUSH
42968: LD_EXP 24
42972: PPUSH
42973: LD_VAR 0 4
42977: PPUSH
42978: EMPTY
42979: PPUSH
42980: CALL_OW 1
42984: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
42985: LD_ADDR_EXP 25
42989: PUSH
42990: LD_EXP 25
42994: PPUSH
42995: LD_VAR 0 4
42999: PPUSH
43000: LD_INT 0
43002: PPUSH
43003: CALL_OW 1
43007: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
43008: LD_ADDR_EXP 26
43012: PUSH
43013: LD_EXP 26
43017: PPUSH
43018: LD_VAR 0 4
43022: PPUSH
43023: EMPTY
43024: PPUSH
43025: CALL_OW 1
43029: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
43030: LD_ADDR_EXP 27
43034: PUSH
43035: LD_EXP 27
43039: PPUSH
43040: LD_VAR 0 4
43044: PPUSH
43045: EMPTY
43046: PPUSH
43047: CALL_OW 1
43051: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
43052: LD_ADDR_EXP 28
43056: PUSH
43057: LD_EXP 28
43061: PPUSH
43062: LD_VAR 0 4
43066: PPUSH
43067: EMPTY
43068: PPUSH
43069: CALL_OW 1
43073: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
43074: LD_ADDR_EXP 29
43078: PUSH
43079: LD_EXP 29
43083: PPUSH
43084: LD_VAR 0 4
43088: PPUSH
43089: EMPTY
43090: PPUSH
43091: CALL_OW 1
43095: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
43096: LD_ADDR_EXP 30
43100: PUSH
43101: LD_EXP 30
43105: PPUSH
43106: LD_VAR 0 4
43110: PPUSH
43111: EMPTY
43112: PPUSH
43113: CALL_OW 1
43117: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
43118: LD_ADDR_EXP 31
43122: PUSH
43123: LD_EXP 31
43127: PPUSH
43128: LD_VAR 0 4
43132: PPUSH
43133: EMPTY
43134: PPUSH
43135: CALL_OW 1
43139: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
43140: LD_ADDR_EXP 32
43144: PUSH
43145: LD_EXP 32
43149: PPUSH
43150: LD_VAR 0 4
43154: PPUSH
43155: EMPTY
43156: PPUSH
43157: CALL_OW 1
43161: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
43162: LD_ADDR_EXP 33
43166: PUSH
43167: LD_EXP 33
43171: PPUSH
43172: LD_VAR 0 4
43176: PPUSH
43177: EMPTY
43178: PPUSH
43179: CALL_OW 1
43183: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
43184: LD_ADDR_EXP 34
43188: PUSH
43189: LD_EXP 34
43193: PPUSH
43194: LD_VAR 0 4
43198: PPUSH
43199: EMPTY
43200: PPUSH
43201: CALL_OW 1
43205: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
43206: LD_ADDR_EXP 35
43210: PUSH
43211: LD_EXP 35
43215: PPUSH
43216: LD_VAR 0 4
43220: PPUSH
43221: EMPTY
43222: PPUSH
43223: CALL_OW 1
43227: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
43228: LD_ADDR_EXP 36
43232: PUSH
43233: LD_EXP 36
43237: PPUSH
43238: LD_VAR 0 4
43242: PPUSH
43243: EMPTY
43244: PPUSH
43245: CALL_OW 1
43249: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
43250: LD_ADDR_EXP 37
43254: PUSH
43255: LD_EXP 37
43259: PPUSH
43260: LD_VAR 0 4
43264: PPUSH
43265: EMPTY
43266: PPUSH
43267: CALL_OW 1
43271: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
43272: LD_ADDR_EXP 38
43276: PUSH
43277: LD_EXP 38
43281: PPUSH
43282: LD_VAR 0 4
43286: PPUSH
43287: EMPTY
43288: PPUSH
43289: CALL_OW 1
43293: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
43294: LD_ADDR_EXP 39
43298: PUSH
43299: LD_EXP 39
43303: PPUSH
43304: LD_VAR 0 4
43308: PPUSH
43309: EMPTY
43310: PPUSH
43311: CALL_OW 1
43315: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
43316: LD_ADDR_EXP 41
43320: PUSH
43321: LD_EXP 41
43325: PPUSH
43326: LD_VAR 0 4
43330: PPUSH
43331: EMPTY
43332: PPUSH
43333: CALL_OW 1
43337: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
43338: LD_ADDR_EXP 43
43342: PUSH
43343: LD_EXP 43
43347: PPUSH
43348: LD_VAR 0 4
43352: PPUSH
43353: EMPTY
43354: PPUSH
43355: CALL_OW 1
43359: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
43360: LD_ADDR_EXP 44
43364: PUSH
43365: LD_EXP 44
43369: PPUSH
43370: LD_VAR 0 4
43374: PPUSH
43375: EMPTY
43376: PPUSH
43377: CALL_OW 1
43381: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
43382: LD_ADDR_EXP 45
43386: PUSH
43387: LD_EXP 45
43391: PPUSH
43392: LD_VAR 0 4
43396: PPUSH
43397: EMPTY
43398: PPUSH
43399: CALL_OW 1
43403: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
43404: LD_ADDR_EXP 46
43408: PUSH
43409: LD_EXP 46
43413: PPUSH
43414: LD_VAR 0 4
43418: PPUSH
43419: EMPTY
43420: PPUSH
43421: CALL_OW 1
43425: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
43426: LD_ADDR_EXP 47
43430: PUSH
43431: LD_EXP 47
43435: PPUSH
43436: LD_VAR 0 4
43440: PPUSH
43441: EMPTY
43442: PPUSH
43443: CALL_OW 1
43447: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
43448: LD_ADDR_EXP 48
43452: PUSH
43453: LD_EXP 48
43457: PPUSH
43458: LD_VAR 0 4
43462: PPUSH
43463: EMPTY
43464: PPUSH
43465: CALL_OW 1
43469: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
43470: LD_ADDR_EXP 49
43474: PUSH
43475: LD_EXP 49
43479: PPUSH
43480: LD_VAR 0 4
43484: PPUSH
43485: EMPTY
43486: PPUSH
43487: CALL_OW 1
43491: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
43492: LD_ADDR_EXP 50
43496: PUSH
43497: LD_EXP 50
43501: PPUSH
43502: LD_VAR 0 4
43506: PPUSH
43507: EMPTY
43508: PPUSH
43509: CALL_OW 1
43513: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
43514: LD_ADDR_EXP 51
43518: PUSH
43519: LD_EXP 51
43523: PPUSH
43524: LD_VAR 0 4
43528: PPUSH
43529: EMPTY
43530: PPUSH
43531: CALL_OW 1
43535: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
43536: LD_ADDR_EXP 52
43540: PUSH
43541: LD_EXP 52
43545: PPUSH
43546: LD_VAR 0 4
43550: PPUSH
43551: EMPTY
43552: PPUSH
43553: CALL_OW 1
43557: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
43558: LD_ADDR_EXP 53
43562: PUSH
43563: LD_EXP 53
43567: PPUSH
43568: LD_VAR 0 4
43572: PPUSH
43573: EMPTY
43574: PPUSH
43575: CALL_OW 1
43579: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
43580: LD_ADDR_EXP 54
43584: PUSH
43585: LD_EXP 54
43589: PPUSH
43590: LD_VAR 0 4
43594: PPUSH
43595: EMPTY
43596: PPUSH
43597: CALL_OW 1
43601: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
43602: LD_ADDR_EXP 55
43606: PUSH
43607: LD_EXP 55
43611: PPUSH
43612: LD_VAR 0 4
43616: PPUSH
43617: EMPTY
43618: PPUSH
43619: CALL_OW 1
43623: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
43624: LD_ADDR_EXP 56
43628: PUSH
43629: LD_EXP 56
43633: PPUSH
43634: LD_VAR 0 4
43638: PPUSH
43639: LD_INT 0
43641: PPUSH
43642: CALL_OW 1
43646: ST_TO_ADDR
// result := base ;
43647: LD_ADDR_VAR 0 3
43651: PUSH
43652: LD_VAR 0 4
43656: ST_TO_ADDR
// end ;
43657: LD_VAR 0 3
43661: RET
// export function MC_Start ( ) ; var i ; begin
43662: LD_INT 0
43664: PPUSH
43665: PPUSH
// for i = 1 to mc_bases do
43666: LD_ADDR_VAR 0 2
43670: PUSH
43671: DOUBLE
43672: LD_INT 1
43674: DEC
43675: ST_TO_ADDR
43676: LD_EXP 14
43680: PUSH
43681: FOR_TO
43682: IFFALSE 44759
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
43684: LD_ADDR_EXP 14
43688: PUSH
43689: LD_EXP 14
43693: PPUSH
43694: LD_VAR 0 2
43698: PPUSH
43699: LD_EXP 14
43703: PUSH
43704: LD_VAR 0 2
43708: ARRAY
43709: PUSH
43710: LD_INT 0
43712: DIFF
43713: PPUSH
43714: CALL_OW 1
43718: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
43719: LD_ADDR_EXP 15
43723: PUSH
43724: LD_EXP 15
43728: PPUSH
43729: LD_VAR 0 2
43733: PPUSH
43734: EMPTY
43735: PPUSH
43736: CALL_OW 1
43740: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43741: LD_ADDR_EXP 16
43745: PUSH
43746: LD_EXP 16
43750: PPUSH
43751: LD_VAR 0 2
43755: PPUSH
43756: EMPTY
43757: PPUSH
43758: CALL_OW 1
43762: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
43763: LD_ADDR_EXP 17
43767: PUSH
43768: LD_EXP 17
43772: PPUSH
43773: LD_VAR 0 2
43777: PPUSH
43778: EMPTY
43779: PPUSH
43780: CALL_OW 1
43784: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
43785: LD_ADDR_EXP 18
43789: PUSH
43790: LD_EXP 18
43794: PPUSH
43795: LD_VAR 0 2
43799: PPUSH
43800: EMPTY
43801: PUSH
43802: EMPTY
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PPUSH
43808: CALL_OW 1
43812: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
43813: LD_ADDR_EXP 19
43817: PUSH
43818: LD_EXP 19
43822: PPUSH
43823: LD_VAR 0 2
43827: PPUSH
43828: EMPTY
43829: PPUSH
43830: CALL_OW 1
43834: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
43835: LD_ADDR_EXP 46
43839: PUSH
43840: LD_EXP 46
43844: PPUSH
43845: LD_VAR 0 2
43849: PPUSH
43850: EMPTY
43851: PPUSH
43852: CALL_OW 1
43856: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
43857: LD_ADDR_EXP 20
43861: PUSH
43862: LD_EXP 20
43866: PPUSH
43867: LD_VAR 0 2
43871: PPUSH
43872: EMPTY
43873: PPUSH
43874: CALL_OW 1
43878: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
43879: LD_ADDR_EXP 21
43883: PUSH
43884: LD_EXP 21
43888: PPUSH
43889: LD_VAR 0 2
43893: PPUSH
43894: EMPTY
43895: PPUSH
43896: CALL_OW 1
43900: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
43901: LD_ADDR_EXP 22
43905: PUSH
43906: LD_EXP 22
43910: PPUSH
43911: LD_VAR 0 2
43915: PPUSH
43916: LD_EXP 14
43920: PUSH
43921: LD_VAR 0 2
43925: ARRAY
43926: PPUSH
43927: LD_INT 2
43929: PUSH
43930: LD_INT 30
43932: PUSH
43933: LD_INT 32
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: LD_INT 30
43942: PUSH
43943: LD_INT 33
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: LIST
43954: PPUSH
43955: CALL_OW 72
43959: PPUSH
43960: CALL_OW 1
43964: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
43965: LD_ADDR_EXP 23
43969: PUSH
43970: LD_EXP 23
43974: PPUSH
43975: LD_VAR 0 2
43979: PPUSH
43980: LD_EXP 14
43984: PUSH
43985: LD_VAR 0 2
43989: ARRAY
43990: PPUSH
43991: LD_INT 2
43993: PUSH
43994: LD_INT 30
43996: PUSH
43997: LD_INT 32
43999: PUSH
44000: EMPTY
44001: LIST
44002: LIST
44003: PUSH
44004: LD_INT 30
44006: PUSH
44007: LD_INT 31
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 58
44021: PUSH
44022: EMPTY
44023: LIST
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PPUSH
44029: CALL_OW 72
44033: PPUSH
44034: CALL_OW 1
44038: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
44039: LD_ADDR_EXP 24
44043: PUSH
44044: LD_EXP 24
44048: PPUSH
44049: LD_VAR 0 2
44053: PPUSH
44054: EMPTY
44055: PPUSH
44056: CALL_OW 1
44060: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
44061: LD_ADDR_EXP 28
44065: PUSH
44066: LD_EXP 28
44070: PPUSH
44071: LD_VAR 0 2
44075: PPUSH
44076: EMPTY
44077: PPUSH
44078: CALL_OW 1
44082: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
44083: LD_ADDR_EXP 27
44087: PUSH
44088: LD_EXP 27
44092: PPUSH
44093: LD_VAR 0 2
44097: PPUSH
44098: EMPTY
44099: PPUSH
44100: CALL_OW 1
44104: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
44105: LD_ADDR_EXP 29
44109: PUSH
44110: LD_EXP 29
44114: PPUSH
44115: LD_VAR 0 2
44119: PPUSH
44120: EMPTY
44121: PPUSH
44122: CALL_OW 1
44126: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
44127: LD_ADDR_EXP 30
44131: PUSH
44132: LD_EXP 30
44136: PPUSH
44137: LD_VAR 0 2
44141: PPUSH
44142: EMPTY
44143: PPUSH
44144: CALL_OW 1
44148: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
44149: LD_ADDR_EXP 31
44153: PUSH
44154: LD_EXP 31
44158: PPUSH
44159: LD_VAR 0 2
44163: PPUSH
44164: EMPTY
44165: PPUSH
44166: CALL_OW 1
44170: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
44171: LD_ADDR_EXP 32
44175: PUSH
44176: LD_EXP 32
44180: PPUSH
44181: LD_VAR 0 2
44185: PPUSH
44186: EMPTY
44187: PPUSH
44188: CALL_OW 1
44192: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
44193: LD_ADDR_EXP 33
44197: PUSH
44198: LD_EXP 33
44202: PPUSH
44203: LD_VAR 0 2
44207: PPUSH
44208: EMPTY
44209: PPUSH
44210: CALL_OW 1
44214: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
44215: LD_ADDR_EXP 34
44219: PUSH
44220: LD_EXP 34
44224: PPUSH
44225: LD_VAR 0 2
44229: PPUSH
44230: EMPTY
44231: PPUSH
44232: CALL_OW 1
44236: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
44237: LD_ADDR_EXP 35
44241: PUSH
44242: LD_EXP 35
44246: PPUSH
44247: LD_VAR 0 2
44251: PPUSH
44252: EMPTY
44253: PPUSH
44254: CALL_OW 1
44258: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
44259: LD_ADDR_EXP 36
44263: PUSH
44264: LD_EXP 36
44268: PPUSH
44269: LD_VAR 0 2
44273: PPUSH
44274: EMPTY
44275: PPUSH
44276: CALL_OW 1
44280: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
44281: LD_ADDR_EXP 25
44285: PUSH
44286: LD_EXP 25
44290: PPUSH
44291: LD_VAR 0 2
44295: PPUSH
44296: LD_INT 0
44298: PPUSH
44299: CALL_OW 1
44303: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
44304: LD_ADDR_EXP 38
44308: PUSH
44309: LD_EXP 38
44313: PPUSH
44314: LD_VAR 0 2
44318: PPUSH
44319: LD_INT 0
44321: PPUSH
44322: CALL_OW 1
44326: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
44327: LD_ADDR_EXP 26
44331: PUSH
44332: LD_EXP 26
44336: PPUSH
44337: LD_VAR 0 2
44341: PPUSH
44342: EMPTY
44343: PPUSH
44344: CALL_OW 1
44348: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
44349: LD_ADDR_EXP 37
44353: PUSH
44354: LD_EXP 37
44358: PPUSH
44359: LD_VAR 0 2
44363: PPUSH
44364: LD_INT 0
44366: PPUSH
44367: CALL_OW 1
44371: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
44372: LD_ADDR_EXP 39
44376: PUSH
44377: LD_EXP 39
44381: PPUSH
44382: LD_VAR 0 2
44386: PPUSH
44387: EMPTY
44388: PPUSH
44389: CALL_OW 1
44393: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
44394: LD_ADDR_EXP 42
44398: PUSH
44399: LD_EXP 42
44403: PPUSH
44404: LD_VAR 0 2
44408: PPUSH
44409: LD_INT 0
44411: PPUSH
44412: CALL_OW 1
44416: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
44417: LD_ADDR_EXP 43
44421: PUSH
44422: LD_EXP 43
44426: PPUSH
44427: LD_VAR 0 2
44431: PPUSH
44432: EMPTY
44433: PPUSH
44434: CALL_OW 1
44438: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44439: LD_ADDR_EXP 44
44443: PUSH
44444: LD_EXP 44
44448: PPUSH
44449: LD_VAR 0 2
44453: PPUSH
44454: EMPTY
44455: PPUSH
44456: CALL_OW 1
44460: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44461: LD_ADDR_EXP 45
44465: PUSH
44466: LD_EXP 45
44470: PPUSH
44471: LD_VAR 0 2
44475: PPUSH
44476: EMPTY
44477: PPUSH
44478: CALL_OW 1
44482: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
44483: LD_ADDR_EXP 47
44487: PUSH
44488: LD_EXP 47
44492: PPUSH
44493: LD_VAR 0 2
44497: PPUSH
44498: LD_EXP 14
44502: PUSH
44503: LD_VAR 0 2
44507: ARRAY
44508: PPUSH
44509: LD_INT 2
44511: PUSH
44512: LD_INT 30
44514: PUSH
44515: LD_INT 6
44517: PUSH
44518: EMPTY
44519: LIST
44520: LIST
44521: PUSH
44522: LD_INT 30
44524: PUSH
44525: LD_INT 7
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 30
44534: PUSH
44535: LD_INT 8
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: PUSH
44542: EMPTY
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: PPUSH
44548: CALL_OW 72
44552: PPUSH
44553: CALL_OW 1
44557: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
44558: LD_ADDR_EXP 48
44562: PUSH
44563: LD_EXP 48
44567: PPUSH
44568: LD_VAR 0 2
44572: PPUSH
44573: EMPTY
44574: PPUSH
44575: CALL_OW 1
44579: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
44580: LD_ADDR_EXP 49
44584: PUSH
44585: LD_EXP 49
44589: PPUSH
44590: LD_VAR 0 2
44594: PPUSH
44595: EMPTY
44596: PPUSH
44597: CALL_OW 1
44601: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
44602: LD_ADDR_EXP 50
44606: PUSH
44607: LD_EXP 50
44611: PPUSH
44612: LD_VAR 0 2
44616: PPUSH
44617: EMPTY
44618: PPUSH
44619: CALL_OW 1
44623: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
44624: LD_ADDR_EXP 51
44628: PUSH
44629: LD_EXP 51
44633: PPUSH
44634: LD_VAR 0 2
44638: PPUSH
44639: EMPTY
44640: PPUSH
44641: CALL_OW 1
44645: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
44646: LD_ADDR_EXP 52
44650: PUSH
44651: LD_EXP 52
44655: PPUSH
44656: LD_VAR 0 2
44660: PPUSH
44661: EMPTY
44662: PPUSH
44663: CALL_OW 1
44667: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
44668: LD_ADDR_EXP 53
44672: PUSH
44673: LD_EXP 53
44677: PPUSH
44678: LD_VAR 0 2
44682: PPUSH
44683: EMPTY
44684: PPUSH
44685: CALL_OW 1
44689: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
44690: LD_ADDR_EXP 54
44694: PUSH
44695: LD_EXP 54
44699: PPUSH
44700: LD_VAR 0 2
44704: PPUSH
44705: EMPTY
44706: PPUSH
44707: CALL_OW 1
44711: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
44712: LD_ADDR_EXP 55
44716: PUSH
44717: LD_EXP 55
44721: PPUSH
44722: LD_VAR 0 2
44726: PPUSH
44727: EMPTY
44728: PPUSH
44729: CALL_OW 1
44733: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
44734: LD_ADDR_EXP 56
44738: PUSH
44739: LD_EXP 56
44743: PPUSH
44744: LD_VAR 0 2
44748: PPUSH
44749: LD_INT 0
44751: PPUSH
44752: CALL_OW 1
44756: ST_TO_ADDR
// end ;
44757: GO 43681
44759: POP
44760: POP
// MC_InitSides ( ) ;
44761: CALL 45047 0 0
// MC_InitResearch ( ) ;
44765: CALL 44786 0 0
// CustomInitMacro ( ) ;
44769: CALL 211 0 0
// skirmish := true ;
44773: LD_ADDR_EXP 12
44777: PUSH
44778: LD_INT 1
44780: ST_TO_ADDR
// end ;
44781: LD_VAR 0 1
44785: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
44786: LD_INT 0
44788: PPUSH
44789: PPUSH
44790: PPUSH
44791: PPUSH
44792: PPUSH
44793: PPUSH
// if not mc_bases then
44794: LD_EXP 14
44798: NOT
44799: IFFALSE 44803
// exit ;
44801: GO 45042
// for i = 1 to 8 do
44803: LD_ADDR_VAR 0 2
44807: PUSH
44808: DOUBLE
44809: LD_INT 1
44811: DEC
44812: ST_TO_ADDR
44813: LD_INT 8
44815: PUSH
44816: FOR_TO
44817: IFFALSE 44843
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
44819: LD_ADDR_EXP 41
44823: PUSH
44824: LD_EXP 41
44828: PPUSH
44829: LD_VAR 0 2
44833: PPUSH
44834: EMPTY
44835: PPUSH
44836: CALL_OW 1
44840: ST_TO_ADDR
44841: GO 44816
44843: POP
44844: POP
// tmp := [ ] ;
44845: LD_ADDR_VAR 0 5
44849: PUSH
44850: EMPTY
44851: ST_TO_ADDR
// for i = 1 to mc_sides do
44852: LD_ADDR_VAR 0 2
44856: PUSH
44857: DOUBLE
44858: LD_INT 1
44860: DEC
44861: ST_TO_ADDR
44862: LD_EXP 40
44866: PUSH
44867: FOR_TO
44868: IFFALSE 44926
// if not mc_sides [ i ] in tmp then
44870: LD_EXP 40
44874: PUSH
44875: LD_VAR 0 2
44879: ARRAY
44880: PUSH
44881: LD_VAR 0 5
44885: IN
44886: NOT
44887: IFFALSE 44924
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
44889: LD_ADDR_VAR 0 5
44893: PUSH
44894: LD_VAR 0 5
44898: PPUSH
44899: LD_VAR 0 5
44903: PUSH
44904: LD_INT 1
44906: PLUS
44907: PPUSH
44908: LD_EXP 40
44912: PUSH
44913: LD_VAR 0 2
44917: ARRAY
44918: PPUSH
44919: CALL_OW 2
44923: ST_TO_ADDR
44924: GO 44867
44926: POP
44927: POP
// if not tmp then
44928: LD_VAR 0 5
44932: NOT
44933: IFFALSE 44937
// exit ;
44935: GO 45042
// for j in tmp do
44937: LD_ADDR_VAR 0 3
44941: PUSH
44942: LD_VAR 0 5
44946: PUSH
44947: FOR_IN
44948: IFFALSE 45040
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
44950: LD_ADDR_VAR 0 6
44954: PUSH
44955: LD_INT 22
44957: PUSH
44958: LD_VAR 0 3
44962: PUSH
44963: EMPTY
44964: LIST
44965: LIST
44966: PPUSH
44967: CALL_OW 69
44971: ST_TO_ADDR
// if not un then
44972: LD_VAR 0 6
44976: NOT
44977: IFFALSE 44981
// continue ;
44979: GO 44947
// nation := GetNation ( un [ 1 ] ) ;
44981: LD_ADDR_VAR 0 4
44985: PUSH
44986: LD_VAR 0 6
44990: PUSH
44991: LD_INT 1
44993: ARRAY
44994: PPUSH
44995: CALL_OW 248
44999: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
45000: LD_ADDR_EXP 41
45004: PUSH
45005: LD_EXP 41
45009: PPUSH
45010: LD_VAR 0 3
45014: PPUSH
45015: LD_VAR 0 3
45019: PPUSH
45020: LD_VAR 0 4
45024: PPUSH
45025: LD_INT 1
45027: PPUSH
45028: CALL 4544 0 3
45032: PPUSH
45033: CALL_OW 1
45037: ST_TO_ADDR
// end ;
45038: GO 44947
45040: POP
45041: POP
// end ;
45042: LD_VAR 0 1
45046: RET
// export function MC_InitSides ( ) ; var i ; begin
45047: LD_INT 0
45049: PPUSH
45050: PPUSH
// if not mc_bases then
45051: LD_EXP 14
45055: NOT
45056: IFFALSE 45060
// exit ;
45058: GO 45134
// for i = 1 to mc_bases do
45060: LD_ADDR_VAR 0 2
45064: PUSH
45065: DOUBLE
45066: LD_INT 1
45068: DEC
45069: ST_TO_ADDR
45070: LD_EXP 14
45074: PUSH
45075: FOR_TO
45076: IFFALSE 45132
// if mc_bases [ i ] then
45078: LD_EXP 14
45082: PUSH
45083: LD_VAR 0 2
45087: ARRAY
45088: IFFALSE 45130
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
45090: LD_ADDR_EXP 40
45094: PUSH
45095: LD_EXP 40
45099: PPUSH
45100: LD_VAR 0 2
45104: PPUSH
45105: LD_EXP 14
45109: PUSH
45110: LD_VAR 0 2
45114: ARRAY
45115: PUSH
45116: LD_INT 1
45118: ARRAY
45119: PPUSH
45120: CALL_OW 255
45124: PPUSH
45125: CALL_OW 1
45129: ST_TO_ADDR
45130: GO 45075
45132: POP
45133: POP
// end ;
45134: LD_VAR 0 1
45138: RET
// every 0 0$01 trigger skirmish do
45139: LD_EXP 12
45143: IFFALSE 45297
45145: GO 45147
45147: DISABLE
// begin enable ;
45148: ENABLE
// MC_CheckBuildings ( ) ;
45149: CALL 49795 0 0
// MC_CheckPeopleLife ( ) ;
45153: CALL 49920 0 0
// RaiseSailEvent ( 100 ) ;
45157: LD_INT 100
45159: PPUSH
45160: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
45164: LD_INT 103
45166: PPUSH
45167: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
45171: LD_INT 104
45173: PPUSH
45174: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
45178: LD_INT 105
45180: PPUSH
45181: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
45185: LD_INT 106
45187: PPUSH
45188: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
45192: LD_INT 107
45194: PPUSH
45195: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
45199: LD_INT 108
45201: PPUSH
45202: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
45206: LD_INT 109
45208: PPUSH
45209: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
45213: LD_INT 110
45215: PPUSH
45216: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
45220: LD_INT 111
45222: PPUSH
45223: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
45227: LD_INT 112
45229: PPUSH
45230: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
45234: LD_INT 113
45236: PPUSH
45237: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
45241: LD_INT 120
45243: PPUSH
45244: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
45248: LD_INT 121
45250: PPUSH
45251: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
45255: LD_INT 122
45257: PPUSH
45258: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
45262: LD_INT 123
45264: PPUSH
45265: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
45269: LD_INT 124
45271: PPUSH
45272: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
45276: LD_INT 125
45278: PPUSH
45279: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
45283: LD_INT 126
45285: PPUSH
45286: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
45290: LD_INT 200
45292: PPUSH
45293: CALL_OW 427
// end ;
45297: END
// on SailEvent ( event ) do begin if event < 100 then
45298: LD_VAR 0 1
45302: PUSH
45303: LD_INT 100
45305: LESS
45306: IFFALSE 45317
// CustomEvent ( event ) ;
45308: LD_VAR 0 1
45312: PPUSH
45313: CALL 4443 0 1
// if event = 100 then
45317: LD_VAR 0 1
45321: PUSH
45322: LD_INT 100
45324: EQUAL
45325: IFFALSE 45331
// MC_ClassManager ( ) ;
45327: CALL 45723 0 0
// if event = 101 then
45331: LD_VAR 0 1
45335: PUSH
45336: LD_INT 101
45338: EQUAL
45339: IFFALSE 45345
// MC_RepairBuildings ( ) ;
45341: CALL 50505 0 0
// if event = 102 then
45345: LD_VAR 0 1
45349: PUSH
45350: LD_INT 102
45352: EQUAL
45353: IFFALSE 45359
// MC_Heal ( ) ;
45355: CALL 51390 0 0
// if event = 103 then
45359: LD_VAR 0 1
45363: PUSH
45364: LD_INT 103
45366: EQUAL
45367: IFFALSE 45373
// MC_Build ( ) ;
45369: CALL 51812 0 0
// if event = 104 then
45373: LD_VAR 0 1
45377: PUSH
45378: LD_INT 104
45380: EQUAL
45381: IFFALSE 45387
// MC_TurretWeapon ( ) ;
45383: CALL 53425 0 0
// if event = 105 then
45387: LD_VAR 0 1
45391: PUSH
45392: LD_INT 105
45394: EQUAL
45395: IFFALSE 45401
// MC_BuildUpgrade ( ) ;
45397: CALL 52976 0 0
// if event = 106 then
45401: LD_VAR 0 1
45405: PUSH
45406: LD_INT 106
45408: EQUAL
45409: IFFALSE 45415
// MC_PlantMines ( ) ;
45411: CALL 53855 0 0
// if event = 107 then
45415: LD_VAR 0 1
45419: PUSH
45420: LD_INT 107
45422: EQUAL
45423: IFFALSE 45429
// MC_CollectCrates ( ) ;
45425: CALL 54653 0 0
// if event = 108 then
45429: LD_VAR 0 1
45433: PUSH
45434: LD_INT 108
45436: EQUAL
45437: IFFALSE 45443
// MC_LinkRemoteControl ( ) ;
45439: CALL 56429 0 0
// if event = 109 then
45443: LD_VAR 0 1
45447: PUSH
45448: LD_INT 109
45450: EQUAL
45451: IFFALSE 45457
// MC_ProduceVehicle ( ) ;
45453: CALL 56610 0 0
// if event = 110 then
45457: LD_VAR 0 1
45461: PUSH
45462: LD_INT 110
45464: EQUAL
45465: IFFALSE 45471
// MC_SendAttack ( ) ;
45467: CALL 57076 0 0
// if event = 111 then
45471: LD_VAR 0 1
45475: PUSH
45476: LD_INT 111
45478: EQUAL
45479: IFFALSE 45485
// MC_Defend ( ) ;
45481: CALL 57184 0 0
// if event = 112 then
45485: LD_VAR 0 1
45489: PUSH
45490: LD_INT 112
45492: EQUAL
45493: IFFALSE 45499
// MC_Research ( ) ;
45495: CALL 57811 0 0
// if event = 113 then
45499: LD_VAR 0 1
45503: PUSH
45504: LD_INT 113
45506: EQUAL
45507: IFFALSE 45513
// MC_MinesTrigger ( ) ;
45509: CALL 58925 0 0
// if event = 120 then
45513: LD_VAR 0 1
45517: PUSH
45518: LD_INT 120
45520: EQUAL
45521: IFFALSE 45527
// MC_RepairVehicle ( ) ;
45523: CALL 59024 0 0
// if event = 121 then
45527: LD_VAR 0 1
45531: PUSH
45532: LD_INT 121
45534: EQUAL
45535: IFFALSE 45541
// MC_TameApe ( ) ;
45537: CALL 59754 0 0
// if event = 122 then
45541: LD_VAR 0 1
45545: PUSH
45546: LD_INT 122
45548: EQUAL
45549: IFFALSE 45555
// MC_ChangeApeClass ( ) ;
45551: CALL 60583 0 0
// if event = 123 then
45555: LD_VAR 0 1
45559: PUSH
45560: LD_INT 123
45562: EQUAL
45563: IFFALSE 45569
// MC_Bazooka ( ) ;
45565: CALL 61233 0 0
// if event = 124 then
45569: LD_VAR 0 1
45573: PUSH
45574: LD_INT 124
45576: EQUAL
45577: IFFALSE 45583
// MC_TeleportExit ( ) ;
45579: CALL 61431 0 0
// if event = 125 then
45583: LD_VAR 0 1
45587: PUSH
45588: LD_INT 125
45590: EQUAL
45591: IFFALSE 45597
// MC_Deposits ( ) ;
45593: CALL 62078 0 0
// if event = 126 then
45597: LD_VAR 0 1
45601: PUSH
45602: LD_INT 126
45604: EQUAL
45605: IFFALSE 45611
// MC_RemoteDriver ( ) ;
45607: CALL 62703 0 0
// if event = 200 then
45611: LD_VAR 0 1
45615: PUSH
45616: LD_INT 200
45618: EQUAL
45619: IFFALSE 45625
// MC_Idle ( ) ;
45621: CALL 64652 0 0
// end ;
45625: PPOPN 1
45627: END
// export function MC_Reset ( base , tag ) ; var i ; begin
45628: LD_INT 0
45630: PPUSH
45631: PPUSH
// if not mc_bases [ base ] or not tag then
45632: LD_EXP 14
45636: PUSH
45637: LD_VAR 0 1
45641: ARRAY
45642: NOT
45643: PUSH
45644: LD_VAR 0 2
45648: NOT
45649: OR
45650: IFFALSE 45654
// exit ;
45652: GO 45718
// for i in mc_bases [ base ] union mc_ape [ base ] do
45654: LD_ADDR_VAR 0 4
45658: PUSH
45659: LD_EXP 14
45663: PUSH
45664: LD_VAR 0 1
45668: ARRAY
45669: PUSH
45670: LD_EXP 43
45674: PUSH
45675: LD_VAR 0 1
45679: ARRAY
45680: UNION
45681: PUSH
45682: FOR_IN
45683: IFFALSE 45716
// if GetTag ( i ) = tag then
45685: LD_VAR 0 4
45689: PPUSH
45690: CALL_OW 110
45694: PUSH
45695: LD_VAR 0 2
45699: EQUAL
45700: IFFALSE 45714
// SetTag ( i , 0 ) ;
45702: LD_VAR 0 4
45706: PPUSH
45707: LD_INT 0
45709: PPUSH
45710: CALL_OW 109
45714: GO 45682
45716: POP
45717: POP
// end ;
45718: LD_VAR 0 3
45722: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
45723: LD_INT 0
45725: PPUSH
45726: PPUSH
45727: PPUSH
45728: PPUSH
45729: PPUSH
45730: PPUSH
45731: PPUSH
45732: PPUSH
// if not mc_bases then
45733: LD_EXP 14
45737: NOT
45738: IFFALSE 45742
// exit ;
45740: GO 46200
// for i = 1 to mc_bases do
45742: LD_ADDR_VAR 0 2
45746: PUSH
45747: DOUBLE
45748: LD_INT 1
45750: DEC
45751: ST_TO_ADDR
45752: LD_EXP 14
45756: PUSH
45757: FOR_TO
45758: IFFALSE 46198
// begin tmp := MC_ClassCheckReq ( i ) ;
45760: LD_ADDR_VAR 0 4
45764: PUSH
45765: LD_VAR 0 2
45769: PPUSH
45770: CALL 46205 0 1
45774: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
45775: LD_ADDR_EXP 55
45779: PUSH
45780: LD_EXP 55
45784: PPUSH
45785: LD_VAR 0 2
45789: PPUSH
45790: LD_VAR 0 4
45794: PPUSH
45795: CALL_OW 1
45799: ST_TO_ADDR
// if not tmp then
45800: LD_VAR 0 4
45804: NOT
45805: IFFALSE 45809
// continue ;
45807: GO 45757
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
45809: LD_ADDR_VAR 0 6
45813: PUSH
45814: LD_EXP 14
45818: PUSH
45819: LD_VAR 0 2
45823: ARRAY
45824: PPUSH
45825: LD_INT 2
45827: PUSH
45828: LD_INT 30
45830: PUSH
45831: LD_INT 4
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PUSH
45838: LD_INT 30
45840: PUSH
45841: LD_INT 5
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: EMPTY
45849: LIST
45850: LIST
45851: LIST
45852: PPUSH
45853: CALL_OW 72
45857: PUSH
45858: LD_EXP 14
45862: PUSH
45863: LD_VAR 0 2
45867: ARRAY
45868: PPUSH
45869: LD_INT 2
45871: PUSH
45872: LD_INT 30
45874: PUSH
45875: LD_INT 0
45877: PUSH
45878: EMPTY
45879: LIST
45880: LIST
45881: PUSH
45882: LD_INT 30
45884: PUSH
45885: LD_INT 1
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: LIST
45896: PPUSH
45897: CALL_OW 72
45901: PUSH
45902: LD_EXP 14
45906: PUSH
45907: LD_VAR 0 2
45911: ARRAY
45912: PPUSH
45913: LD_INT 30
45915: PUSH
45916: LD_INT 3
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PPUSH
45923: CALL_OW 72
45927: PUSH
45928: LD_EXP 14
45932: PUSH
45933: LD_VAR 0 2
45937: ARRAY
45938: PPUSH
45939: LD_INT 2
45941: PUSH
45942: LD_INT 30
45944: PUSH
45945: LD_INT 6
45947: PUSH
45948: EMPTY
45949: LIST
45950: LIST
45951: PUSH
45952: LD_INT 30
45954: PUSH
45955: LD_INT 7
45957: PUSH
45958: EMPTY
45959: LIST
45960: LIST
45961: PUSH
45962: LD_INT 30
45964: PUSH
45965: LD_INT 8
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: PPUSH
45978: CALL_OW 72
45982: PUSH
45983: EMPTY
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: ST_TO_ADDR
// for j = 1 to 4 do
45989: LD_ADDR_VAR 0 3
45993: PUSH
45994: DOUBLE
45995: LD_INT 1
45997: DEC
45998: ST_TO_ADDR
45999: LD_INT 4
46001: PUSH
46002: FOR_TO
46003: IFFALSE 46194
// begin if not tmp [ j ] then
46005: LD_VAR 0 4
46009: PUSH
46010: LD_VAR 0 3
46014: ARRAY
46015: NOT
46016: IFFALSE 46020
// continue ;
46018: GO 46002
// for p in tmp [ j ] do
46020: LD_ADDR_VAR 0 5
46024: PUSH
46025: LD_VAR 0 4
46029: PUSH
46030: LD_VAR 0 3
46034: ARRAY
46035: PUSH
46036: FOR_IN
46037: IFFALSE 46190
// begin if not b [ j ] then
46039: LD_VAR 0 6
46043: PUSH
46044: LD_VAR 0 3
46048: ARRAY
46049: NOT
46050: IFFALSE 46054
// break ;
46052: GO 46190
// e := 0 ;
46054: LD_ADDR_VAR 0 7
46058: PUSH
46059: LD_INT 0
46061: ST_TO_ADDR
// for k in b [ j ] do
46062: LD_ADDR_VAR 0 8
46066: PUSH
46067: LD_VAR 0 6
46071: PUSH
46072: LD_VAR 0 3
46076: ARRAY
46077: PUSH
46078: FOR_IN
46079: IFFALSE 46106
// if IsNotFull ( k ) then
46081: LD_VAR 0 8
46085: PPUSH
46086: CALL 6693 0 1
46090: IFFALSE 46104
// begin e := k ;
46092: LD_ADDR_VAR 0 7
46096: PUSH
46097: LD_VAR 0 8
46101: ST_TO_ADDR
// break ;
46102: GO 46106
// end ;
46104: GO 46078
46106: POP
46107: POP
// if e and not UnitGoingToBuilding ( p , e ) then
46108: LD_VAR 0 7
46112: PUSH
46113: LD_VAR 0 5
46117: PPUSH
46118: LD_VAR 0 7
46122: PPUSH
46123: CALL 39113 0 2
46127: NOT
46128: AND
46129: IFFALSE 46188
// begin if IsInUnit ( p ) then
46131: LD_VAR 0 5
46135: PPUSH
46136: CALL_OW 310
46140: IFFALSE 46151
// ComExitBuilding ( p ) ;
46142: LD_VAR 0 5
46146: PPUSH
46147: CALL_OW 122
// ComEnterUnit ( p , e ) ;
46151: LD_VAR 0 5
46155: PPUSH
46156: LD_VAR 0 7
46160: PPUSH
46161: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
46165: LD_VAR 0 5
46169: PPUSH
46170: LD_VAR 0 3
46174: PPUSH
46175: CALL_OW 183
// AddComExitBuilding ( p ) ;
46179: LD_VAR 0 5
46183: PPUSH
46184: CALL_OW 182
// end ; end ;
46188: GO 46036
46190: POP
46191: POP
// end ;
46192: GO 46002
46194: POP
46195: POP
// end ;
46196: GO 45757
46198: POP
46199: POP
// end ;
46200: LD_VAR 0 1
46204: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
46205: LD_INT 0
46207: PPUSH
46208: PPUSH
46209: PPUSH
46210: PPUSH
46211: PPUSH
46212: PPUSH
46213: PPUSH
46214: PPUSH
46215: PPUSH
46216: PPUSH
46217: PPUSH
46218: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46219: LD_VAR 0 1
46223: NOT
46224: PUSH
46225: LD_EXP 14
46229: PUSH
46230: LD_VAR 0 1
46234: ARRAY
46235: NOT
46236: OR
46237: PUSH
46238: LD_EXP 14
46242: PUSH
46243: LD_VAR 0 1
46247: ARRAY
46248: PPUSH
46249: LD_INT 2
46251: PUSH
46252: LD_INT 30
46254: PUSH
46255: LD_INT 0
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: PUSH
46262: LD_INT 30
46264: PUSH
46265: LD_INT 1
46267: PUSH
46268: EMPTY
46269: LIST
46270: LIST
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: LIST
46276: PPUSH
46277: CALL_OW 72
46281: NOT
46282: OR
46283: IFFALSE 46287
// exit ;
46285: GO 49790
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46287: LD_ADDR_VAR 0 4
46291: PUSH
46292: LD_EXP 14
46296: PUSH
46297: LD_VAR 0 1
46301: ARRAY
46302: PPUSH
46303: LD_INT 2
46305: PUSH
46306: LD_INT 25
46308: PUSH
46309: LD_INT 1
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: LD_INT 25
46318: PUSH
46319: LD_INT 2
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: PUSH
46326: LD_INT 25
46328: PUSH
46329: LD_INT 3
46331: PUSH
46332: EMPTY
46333: LIST
46334: LIST
46335: PUSH
46336: LD_INT 25
46338: PUSH
46339: LD_INT 4
46341: PUSH
46342: EMPTY
46343: LIST
46344: LIST
46345: PUSH
46346: LD_INT 25
46348: PUSH
46349: LD_INT 5
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: PUSH
46356: LD_INT 25
46358: PUSH
46359: LD_INT 8
46361: PUSH
46362: EMPTY
46363: LIST
46364: LIST
46365: PUSH
46366: LD_INT 25
46368: PUSH
46369: LD_INT 9
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: PPUSH
46386: CALL_OW 72
46390: ST_TO_ADDR
// if not tmp then
46391: LD_VAR 0 4
46395: NOT
46396: IFFALSE 46400
// exit ;
46398: GO 49790
// for i in tmp do
46400: LD_ADDR_VAR 0 3
46404: PUSH
46405: LD_VAR 0 4
46409: PUSH
46410: FOR_IN
46411: IFFALSE 46442
// if GetTag ( i ) then
46413: LD_VAR 0 3
46417: PPUSH
46418: CALL_OW 110
46422: IFFALSE 46440
// tmp := tmp diff i ;
46424: LD_ADDR_VAR 0 4
46428: PUSH
46429: LD_VAR 0 4
46433: PUSH
46434: LD_VAR 0 3
46438: DIFF
46439: ST_TO_ADDR
46440: GO 46410
46442: POP
46443: POP
// if not tmp then
46444: LD_VAR 0 4
46448: NOT
46449: IFFALSE 46453
// exit ;
46451: GO 49790
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46453: LD_ADDR_VAR 0 5
46457: PUSH
46458: LD_EXP 14
46462: PUSH
46463: LD_VAR 0 1
46467: ARRAY
46468: PPUSH
46469: LD_INT 2
46471: PUSH
46472: LD_INT 25
46474: PUSH
46475: LD_INT 1
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: PUSH
46482: LD_INT 25
46484: PUSH
46485: LD_INT 5
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: PUSH
46492: LD_INT 25
46494: PUSH
46495: LD_INT 8
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: PUSH
46502: LD_INT 25
46504: PUSH
46505: LD_INT 9
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: EMPTY
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: PPUSH
46519: CALL_OW 72
46523: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
46524: LD_ADDR_VAR 0 6
46528: PUSH
46529: LD_EXP 14
46533: PUSH
46534: LD_VAR 0 1
46538: ARRAY
46539: PPUSH
46540: LD_INT 25
46542: PUSH
46543: LD_INT 2
46545: PUSH
46546: EMPTY
46547: LIST
46548: LIST
46549: PPUSH
46550: CALL_OW 72
46554: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
46555: LD_ADDR_VAR 0 7
46559: PUSH
46560: LD_EXP 14
46564: PUSH
46565: LD_VAR 0 1
46569: ARRAY
46570: PPUSH
46571: LD_INT 25
46573: PUSH
46574: LD_INT 3
46576: PUSH
46577: EMPTY
46578: LIST
46579: LIST
46580: PPUSH
46581: CALL_OW 72
46585: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
46586: LD_ADDR_VAR 0 8
46590: PUSH
46591: LD_EXP 14
46595: PUSH
46596: LD_VAR 0 1
46600: ARRAY
46601: PPUSH
46602: LD_INT 25
46604: PUSH
46605: LD_INT 4
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: PUSH
46612: LD_INT 24
46614: PUSH
46615: LD_INT 251
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: PPUSH
46626: CALL_OW 72
46630: ST_TO_ADDR
// if mc_scan [ base ] then
46631: LD_EXP 37
46635: PUSH
46636: LD_VAR 0 1
46640: ARRAY
46641: IFFALSE 47102
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
46643: LD_ADDR_EXP 56
46647: PUSH
46648: LD_EXP 56
46652: PPUSH
46653: LD_VAR 0 1
46657: PPUSH
46658: LD_INT 4
46660: PPUSH
46661: CALL_OW 1
46665: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
46666: LD_ADDR_VAR 0 12
46670: PUSH
46671: LD_EXP 14
46675: PUSH
46676: LD_VAR 0 1
46680: ARRAY
46681: PPUSH
46682: LD_INT 2
46684: PUSH
46685: LD_INT 30
46687: PUSH
46688: LD_INT 4
46690: PUSH
46691: EMPTY
46692: LIST
46693: LIST
46694: PUSH
46695: LD_INT 30
46697: PUSH
46698: LD_INT 5
46700: PUSH
46701: EMPTY
46702: LIST
46703: LIST
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: LIST
46709: PPUSH
46710: CALL_OW 72
46714: ST_TO_ADDR
// if not b then
46715: LD_VAR 0 12
46719: NOT
46720: IFFALSE 46724
// exit ;
46722: GO 49790
// p := [ ] ;
46724: LD_ADDR_VAR 0 11
46728: PUSH
46729: EMPTY
46730: ST_TO_ADDR
// if sci >= 2 then
46731: LD_VAR 0 8
46735: PUSH
46736: LD_INT 2
46738: GREATEREQUAL
46739: IFFALSE 46770
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
46741: LD_ADDR_VAR 0 8
46745: PUSH
46746: LD_VAR 0 8
46750: PUSH
46751: LD_INT 1
46753: ARRAY
46754: PUSH
46755: LD_VAR 0 8
46759: PUSH
46760: LD_INT 2
46762: ARRAY
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: ST_TO_ADDR
46768: GO 46831
// if sci = 1 then
46770: LD_VAR 0 8
46774: PUSH
46775: LD_INT 1
46777: EQUAL
46778: IFFALSE 46799
// sci := [ sci [ 1 ] ] else
46780: LD_ADDR_VAR 0 8
46784: PUSH
46785: LD_VAR 0 8
46789: PUSH
46790: LD_INT 1
46792: ARRAY
46793: PUSH
46794: EMPTY
46795: LIST
46796: ST_TO_ADDR
46797: GO 46831
// if sci = 0 then
46799: LD_VAR 0 8
46803: PUSH
46804: LD_INT 0
46806: EQUAL
46807: IFFALSE 46831
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
46809: LD_ADDR_VAR 0 11
46813: PUSH
46814: LD_VAR 0 4
46818: PPUSH
46819: LD_INT 4
46821: PPUSH
46822: CALL 38976 0 2
46826: PUSH
46827: LD_INT 1
46829: ARRAY
46830: ST_TO_ADDR
// if eng > 4 then
46831: LD_VAR 0 6
46835: PUSH
46836: LD_INT 4
46838: GREATER
46839: IFFALSE 46885
// for i = eng downto 4 do
46841: LD_ADDR_VAR 0 3
46845: PUSH
46846: DOUBLE
46847: LD_VAR 0 6
46851: INC
46852: ST_TO_ADDR
46853: LD_INT 4
46855: PUSH
46856: FOR_DOWNTO
46857: IFFALSE 46883
// eng := eng diff eng [ i ] ;
46859: LD_ADDR_VAR 0 6
46863: PUSH
46864: LD_VAR 0 6
46868: PUSH
46869: LD_VAR 0 6
46873: PUSH
46874: LD_VAR 0 3
46878: ARRAY
46879: DIFF
46880: ST_TO_ADDR
46881: GO 46856
46883: POP
46884: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
46885: LD_ADDR_VAR 0 4
46889: PUSH
46890: LD_VAR 0 4
46894: PUSH
46895: LD_VAR 0 5
46899: PUSH
46900: LD_VAR 0 6
46904: UNION
46905: PUSH
46906: LD_VAR 0 7
46910: UNION
46911: PUSH
46912: LD_VAR 0 8
46916: UNION
46917: DIFF
46918: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
46919: LD_ADDR_VAR 0 13
46923: PUSH
46924: LD_EXP 14
46928: PUSH
46929: LD_VAR 0 1
46933: ARRAY
46934: PPUSH
46935: LD_INT 2
46937: PUSH
46938: LD_INT 30
46940: PUSH
46941: LD_INT 32
46943: PUSH
46944: EMPTY
46945: LIST
46946: LIST
46947: PUSH
46948: LD_INT 30
46950: PUSH
46951: LD_INT 31
46953: PUSH
46954: EMPTY
46955: LIST
46956: LIST
46957: PUSH
46958: EMPTY
46959: LIST
46960: LIST
46961: LIST
46962: PPUSH
46963: CALL_OW 72
46967: PUSH
46968: LD_EXP 14
46972: PUSH
46973: LD_VAR 0 1
46977: ARRAY
46978: PPUSH
46979: LD_INT 2
46981: PUSH
46982: LD_INT 30
46984: PUSH
46985: LD_INT 4
46987: PUSH
46988: EMPTY
46989: LIST
46990: LIST
46991: PUSH
46992: LD_INT 30
46994: PUSH
46995: LD_INT 5
46997: PUSH
46998: EMPTY
46999: LIST
47000: LIST
47001: PUSH
47002: EMPTY
47003: LIST
47004: LIST
47005: LIST
47006: PPUSH
47007: CALL_OW 72
47011: PUSH
47012: LD_INT 6
47014: MUL
47015: PLUS
47016: ST_TO_ADDR
// if bcount < tmp then
47017: LD_VAR 0 13
47021: PUSH
47022: LD_VAR 0 4
47026: LESS
47027: IFFALSE 47073
// for i = tmp downto bcount do
47029: LD_ADDR_VAR 0 3
47033: PUSH
47034: DOUBLE
47035: LD_VAR 0 4
47039: INC
47040: ST_TO_ADDR
47041: LD_VAR 0 13
47045: PUSH
47046: FOR_DOWNTO
47047: IFFALSE 47071
// tmp := Delete ( tmp , tmp ) ;
47049: LD_ADDR_VAR 0 4
47053: PUSH
47054: LD_VAR 0 4
47058: PPUSH
47059: LD_VAR 0 4
47063: PPUSH
47064: CALL_OW 3
47068: ST_TO_ADDR
47069: GO 47046
47071: POP
47072: POP
// result := [ tmp , 0 , 0 , p ] ;
47073: LD_ADDR_VAR 0 2
47077: PUSH
47078: LD_VAR 0 4
47082: PUSH
47083: LD_INT 0
47085: PUSH
47086: LD_INT 0
47088: PUSH
47089: LD_VAR 0 11
47093: PUSH
47094: EMPTY
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: ST_TO_ADDR
// exit ;
47100: GO 49790
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47102: LD_EXP 14
47106: PUSH
47107: LD_VAR 0 1
47111: ARRAY
47112: PPUSH
47113: LD_INT 2
47115: PUSH
47116: LD_INT 30
47118: PUSH
47119: LD_INT 6
47121: PUSH
47122: EMPTY
47123: LIST
47124: LIST
47125: PUSH
47126: LD_INT 30
47128: PUSH
47129: LD_INT 7
47131: PUSH
47132: EMPTY
47133: LIST
47134: LIST
47135: PUSH
47136: LD_INT 30
47138: PUSH
47139: LD_INT 8
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: EMPTY
47147: LIST
47148: LIST
47149: LIST
47150: LIST
47151: PPUSH
47152: CALL_OW 72
47156: NOT
47157: PUSH
47158: LD_EXP 14
47162: PUSH
47163: LD_VAR 0 1
47167: ARRAY
47168: PPUSH
47169: LD_INT 30
47171: PUSH
47172: LD_INT 3
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: PPUSH
47179: CALL_OW 72
47183: NOT
47184: AND
47185: IFFALSE 47257
// begin if eng = tmp then
47187: LD_VAR 0 6
47191: PUSH
47192: LD_VAR 0 4
47196: EQUAL
47197: IFFALSE 47201
// exit ;
47199: GO 49790
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
47201: LD_ADDR_EXP 56
47205: PUSH
47206: LD_EXP 56
47210: PPUSH
47211: LD_VAR 0 1
47215: PPUSH
47216: LD_INT 1
47218: PPUSH
47219: CALL_OW 1
47223: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
47224: LD_ADDR_VAR 0 2
47228: PUSH
47229: LD_INT 0
47231: PUSH
47232: LD_VAR 0 4
47236: PUSH
47237: LD_VAR 0 6
47241: DIFF
47242: PUSH
47243: LD_INT 0
47245: PUSH
47246: LD_INT 0
47248: PUSH
47249: EMPTY
47250: LIST
47251: LIST
47252: LIST
47253: LIST
47254: ST_TO_ADDR
// exit ;
47255: GO 49790
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47257: LD_EXP 41
47261: PUSH
47262: LD_EXP 40
47266: PUSH
47267: LD_VAR 0 1
47271: ARRAY
47272: ARRAY
47273: PUSH
47274: LD_EXP 14
47278: PUSH
47279: LD_VAR 0 1
47283: ARRAY
47284: PPUSH
47285: LD_INT 2
47287: PUSH
47288: LD_INT 30
47290: PUSH
47291: LD_INT 6
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: LD_INT 30
47300: PUSH
47301: LD_INT 7
47303: PUSH
47304: EMPTY
47305: LIST
47306: LIST
47307: PUSH
47308: LD_INT 30
47310: PUSH
47311: LD_INT 8
47313: PUSH
47314: EMPTY
47315: LIST
47316: LIST
47317: PUSH
47318: EMPTY
47319: LIST
47320: LIST
47321: LIST
47322: LIST
47323: PPUSH
47324: CALL_OW 72
47328: AND
47329: PUSH
47330: LD_EXP 14
47334: PUSH
47335: LD_VAR 0 1
47339: ARRAY
47340: PPUSH
47341: LD_INT 30
47343: PUSH
47344: LD_INT 3
47346: PUSH
47347: EMPTY
47348: LIST
47349: LIST
47350: PPUSH
47351: CALL_OW 72
47355: NOT
47356: AND
47357: IFFALSE 47571
// begin if sci >= 6 then
47359: LD_VAR 0 8
47363: PUSH
47364: LD_INT 6
47366: GREATEREQUAL
47367: IFFALSE 47371
// exit ;
47369: GO 49790
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
47371: LD_ADDR_EXP 56
47375: PUSH
47376: LD_EXP 56
47380: PPUSH
47381: LD_VAR 0 1
47385: PPUSH
47386: LD_INT 2
47388: PPUSH
47389: CALL_OW 1
47393: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
47394: LD_ADDR_VAR 0 9
47398: PUSH
47399: LD_VAR 0 4
47403: PUSH
47404: LD_VAR 0 8
47408: DIFF
47409: PPUSH
47410: LD_INT 4
47412: PPUSH
47413: CALL 38976 0 2
47417: ST_TO_ADDR
// p := [ ] ;
47418: LD_ADDR_VAR 0 11
47422: PUSH
47423: EMPTY
47424: ST_TO_ADDR
// if sci < 6 and sort > 6 then
47425: LD_VAR 0 8
47429: PUSH
47430: LD_INT 6
47432: LESS
47433: PUSH
47434: LD_VAR 0 9
47438: PUSH
47439: LD_INT 6
47441: GREATER
47442: AND
47443: IFFALSE 47524
// begin for i = 1 to 6 - sci do
47445: LD_ADDR_VAR 0 3
47449: PUSH
47450: DOUBLE
47451: LD_INT 1
47453: DEC
47454: ST_TO_ADDR
47455: LD_INT 6
47457: PUSH
47458: LD_VAR 0 8
47462: MINUS
47463: PUSH
47464: FOR_TO
47465: IFFALSE 47520
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
47467: LD_ADDR_VAR 0 11
47471: PUSH
47472: LD_VAR 0 11
47476: PPUSH
47477: LD_VAR 0 11
47481: PUSH
47482: LD_INT 1
47484: PLUS
47485: PPUSH
47486: LD_VAR 0 9
47490: PUSH
47491: LD_INT 1
47493: ARRAY
47494: PPUSH
47495: CALL_OW 2
47499: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
47500: LD_ADDR_VAR 0 9
47504: PUSH
47505: LD_VAR 0 9
47509: PPUSH
47510: LD_INT 1
47512: PPUSH
47513: CALL_OW 3
47517: ST_TO_ADDR
// end ;
47518: GO 47464
47520: POP
47521: POP
// end else
47522: GO 47544
// if sort then
47524: LD_VAR 0 9
47528: IFFALSE 47544
// p := sort [ 1 ] ;
47530: LD_ADDR_VAR 0 11
47534: PUSH
47535: LD_VAR 0 9
47539: PUSH
47540: LD_INT 1
47542: ARRAY
47543: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
47544: LD_ADDR_VAR 0 2
47548: PUSH
47549: LD_INT 0
47551: PUSH
47552: LD_INT 0
47554: PUSH
47555: LD_INT 0
47557: PUSH
47558: LD_VAR 0 11
47562: PUSH
47563: EMPTY
47564: LIST
47565: LIST
47566: LIST
47567: LIST
47568: ST_TO_ADDR
// exit ;
47569: GO 49790
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47571: LD_EXP 41
47575: PUSH
47576: LD_EXP 40
47580: PUSH
47581: LD_VAR 0 1
47585: ARRAY
47586: ARRAY
47587: PUSH
47588: LD_EXP 14
47592: PUSH
47593: LD_VAR 0 1
47597: ARRAY
47598: PPUSH
47599: LD_INT 2
47601: PUSH
47602: LD_INT 30
47604: PUSH
47605: LD_INT 6
47607: PUSH
47608: EMPTY
47609: LIST
47610: LIST
47611: PUSH
47612: LD_INT 30
47614: PUSH
47615: LD_INT 7
47617: PUSH
47618: EMPTY
47619: LIST
47620: LIST
47621: PUSH
47622: LD_INT 30
47624: PUSH
47625: LD_INT 8
47627: PUSH
47628: EMPTY
47629: LIST
47630: LIST
47631: PUSH
47632: EMPTY
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: PPUSH
47638: CALL_OW 72
47642: AND
47643: PUSH
47644: LD_EXP 14
47648: PUSH
47649: LD_VAR 0 1
47653: ARRAY
47654: PPUSH
47655: LD_INT 30
47657: PUSH
47658: LD_INT 3
47660: PUSH
47661: EMPTY
47662: LIST
47663: LIST
47664: PPUSH
47665: CALL_OW 72
47669: AND
47670: IFFALSE 48404
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
47672: LD_ADDR_EXP 56
47676: PUSH
47677: LD_EXP 56
47681: PPUSH
47682: LD_VAR 0 1
47686: PPUSH
47687: LD_INT 3
47689: PPUSH
47690: CALL_OW 1
47694: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47695: LD_ADDR_VAR 0 2
47699: PUSH
47700: LD_INT 0
47702: PUSH
47703: LD_INT 0
47705: PUSH
47706: LD_INT 0
47708: PUSH
47709: LD_INT 0
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: LIST
47716: LIST
47717: ST_TO_ADDR
// if not eng then
47718: LD_VAR 0 6
47722: NOT
47723: IFFALSE 47786
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
47725: LD_ADDR_VAR 0 11
47729: PUSH
47730: LD_VAR 0 4
47734: PPUSH
47735: LD_INT 2
47737: PPUSH
47738: CALL 38976 0 2
47742: PUSH
47743: LD_INT 1
47745: ARRAY
47746: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
47747: LD_ADDR_VAR 0 2
47751: PUSH
47752: LD_VAR 0 2
47756: PPUSH
47757: LD_INT 2
47759: PPUSH
47760: LD_VAR 0 11
47764: PPUSH
47765: CALL_OW 1
47769: ST_TO_ADDR
// tmp := tmp diff p ;
47770: LD_ADDR_VAR 0 4
47774: PUSH
47775: LD_VAR 0 4
47779: PUSH
47780: LD_VAR 0 11
47784: DIFF
47785: ST_TO_ADDR
// end ; if tmp and sci < 6 then
47786: LD_VAR 0 4
47790: PUSH
47791: LD_VAR 0 8
47795: PUSH
47796: LD_INT 6
47798: LESS
47799: AND
47800: IFFALSE 47988
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
47802: LD_ADDR_VAR 0 9
47806: PUSH
47807: LD_VAR 0 4
47811: PUSH
47812: LD_VAR 0 8
47816: PUSH
47817: LD_VAR 0 7
47821: UNION
47822: DIFF
47823: PPUSH
47824: LD_INT 4
47826: PPUSH
47827: CALL 38976 0 2
47831: ST_TO_ADDR
// p := [ ] ;
47832: LD_ADDR_VAR 0 11
47836: PUSH
47837: EMPTY
47838: ST_TO_ADDR
// if sort then
47839: LD_VAR 0 9
47843: IFFALSE 47959
// for i = 1 to 6 - sci do
47845: LD_ADDR_VAR 0 3
47849: PUSH
47850: DOUBLE
47851: LD_INT 1
47853: DEC
47854: ST_TO_ADDR
47855: LD_INT 6
47857: PUSH
47858: LD_VAR 0 8
47862: MINUS
47863: PUSH
47864: FOR_TO
47865: IFFALSE 47957
// begin if i = sort then
47867: LD_VAR 0 3
47871: PUSH
47872: LD_VAR 0 9
47876: EQUAL
47877: IFFALSE 47881
// break ;
47879: GO 47957
// if GetClass ( i ) = 4 then
47881: LD_VAR 0 3
47885: PPUSH
47886: CALL_OW 257
47890: PUSH
47891: LD_INT 4
47893: EQUAL
47894: IFFALSE 47898
// continue ;
47896: GO 47864
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47898: LD_ADDR_VAR 0 11
47902: PUSH
47903: LD_VAR 0 11
47907: PPUSH
47908: LD_VAR 0 11
47912: PUSH
47913: LD_INT 1
47915: PLUS
47916: PPUSH
47917: LD_VAR 0 9
47921: PUSH
47922: LD_VAR 0 3
47926: ARRAY
47927: PPUSH
47928: CALL_OW 2
47932: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47933: LD_ADDR_VAR 0 4
47937: PUSH
47938: LD_VAR 0 4
47942: PUSH
47943: LD_VAR 0 9
47947: PUSH
47948: LD_VAR 0 3
47952: ARRAY
47953: DIFF
47954: ST_TO_ADDR
// end ;
47955: GO 47864
47957: POP
47958: POP
// if p then
47959: LD_VAR 0 11
47963: IFFALSE 47988
// result := Replace ( result , 4 , p ) ;
47965: LD_ADDR_VAR 0 2
47969: PUSH
47970: LD_VAR 0 2
47974: PPUSH
47975: LD_INT 4
47977: PPUSH
47978: LD_VAR 0 11
47982: PPUSH
47983: CALL_OW 1
47987: ST_TO_ADDR
// end ; if tmp and mech < 6 then
47988: LD_VAR 0 4
47992: PUSH
47993: LD_VAR 0 7
47997: PUSH
47998: LD_INT 6
48000: LESS
48001: AND
48002: IFFALSE 48190
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
48004: LD_ADDR_VAR 0 9
48008: PUSH
48009: LD_VAR 0 4
48013: PUSH
48014: LD_VAR 0 8
48018: PUSH
48019: LD_VAR 0 7
48023: UNION
48024: DIFF
48025: PPUSH
48026: LD_INT 3
48028: PPUSH
48029: CALL 38976 0 2
48033: ST_TO_ADDR
// p := [ ] ;
48034: LD_ADDR_VAR 0 11
48038: PUSH
48039: EMPTY
48040: ST_TO_ADDR
// if sort then
48041: LD_VAR 0 9
48045: IFFALSE 48161
// for i = 1 to 6 - mech do
48047: LD_ADDR_VAR 0 3
48051: PUSH
48052: DOUBLE
48053: LD_INT 1
48055: DEC
48056: ST_TO_ADDR
48057: LD_INT 6
48059: PUSH
48060: LD_VAR 0 7
48064: MINUS
48065: PUSH
48066: FOR_TO
48067: IFFALSE 48159
// begin if i = sort then
48069: LD_VAR 0 3
48073: PUSH
48074: LD_VAR 0 9
48078: EQUAL
48079: IFFALSE 48083
// break ;
48081: GO 48159
// if GetClass ( i ) = 3 then
48083: LD_VAR 0 3
48087: PPUSH
48088: CALL_OW 257
48092: PUSH
48093: LD_INT 3
48095: EQUAL
48096: IFFALSE 48100
// continue ;
48098: GO 48066
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48100: LD_ADDR_VAR 0 11
48104: PUSH
48105: LD_VAR 0 11
48109: PPUSH
48110: LD_VAR 0 11
48114: PUSH
48115: LD_INT 1
48117: PLUS
48118: PPUSH
48119: LD_VAR 0 9
48123: PUSH
48124: LD_VAR 0 3
48128: ARRAY
48129: PPUSH
48130: CALL_OW 2
48134: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48135: LD_ADDR_VAR 0 4
48139: PUSH
48140: LD_VAR 0 4
48144: PUSH
48145: LD_VAR 0 9
48149: PUSH
48150: LD_VAR 0 3
48154: ARRAY
48155: DIFF
48156: ST_TO_ADDR
// end ;
48157: GO 48066
48159: POP
48160: POP
// if p then
48161: LD_VAR 0 11
48165: IFFALSE 48190
// result := Replace ( result , 3 , p ) ;
48167: LD_ADDR_VAR 0 2
48171: PUSH
48172: LD_VAR 0 2
48176: PPUSH
48177: LD_INT 3
48179: PPUSH
48180: LD_VAR 0 11
48184: PPUSH
48185: CALL_OW 1
48189: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
48190: LD_VAR 0 4
48194: PUSH
48195: LD_INT 6
48197: GREATER
48198: PUSH
48199: LD_VAR 0 6
48203: PUSH
48204: LD_INT 6
48206: LESS
48207: AND
48208: IFFALSE 48402
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
48210: LD_ADDR_VAR 0 9
48214: PUSH
48215: LD_VAR 0 4
48219: PUSH
48220: LD_VAR 0 8
48224: PUSH
48225: LD_VAR 0 7
48229: UNION
48230: PUSH
48231: LD_VAR 0 6
48235: UNION
48236: DIFF
48237: PPUSH
48238: LD_INT 2
48240: PPUSH
48241: CALL 38976 0 2
48245: ST_TO_ADDR
// p := [ ] ;
48246: LD_ADDR_VAR 0 11
48250: PUSH
48251: EMPTY
48252: ST_TO_ADDR
// if sort then
48253: LD_VAR 0 9
48257: IFFALSE 48373
// for i = 1 to 6 - eng do
48259: LD_ADDR_VAR 0 3
48263: PUSH
48264: DOUBLE
48265: LD_INT 1
48267: DEC
48268: ST_TO_ADDR
48269: LD_INT 6
48271: PUSH
48272: LD_VAR 0 6
48276: MINUS
48277: PUSH
48278: FOR_TO
48279: IFFALSE 48371
// begin if i = sort then
48281: LD_VAR 0 3
48285: PUSH
48286: LD_VAR 0 9
48290: EQUAL
48291: IFFALSE 48295
// break ;
48293: GO 48371
// if GetClass ( i ) = 2 then
48295: LD_VAR 0 3
48299: PPUSH
48300: CALL_OW 257
48304: PUSH
48305: LD_INT 2
48307: EQUAL
48308: IFFALSE 48312
// continue ;
48310: GO 48278
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48312: LD_ADDR_VAR 0 11
48316: PUSH
48317: LD_VAR 0 11
48321: PPUSH
48322: LD_VAR 0 11
48326: PUSH
48327: LD_INT 1
48329: PLUS
48330: PPUSH
48331: LD_VAR 0 9
48335: PUSH
48336: LD_VAR 0 3
48340: ARRAY
48341: PPUSH
48342: CALL_OW 2
48346: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48347: LD_ADDR_VAR 0 4
48351: PUSH
48352: LD_VAR 0 4
48356: PUSH
48357: LD_VAR 0 9
48361: PUSH
48362: LD_VAR 0 3
48366: ARRAY
48367: DIFF
48368: ST_TO_ADDR
// end ;
48369: GO 48278
48371: POP
48372: POP
// if p then
48373: LD_VAR 0 11
48377: IFFALSE 48402
// result := Replace ( result , 2 , p ) ;
48379: LD_ADDR_VAR 0 2
48383: PUSH
48384: LD_VAR 0 2
48388: PPUSH
48389: LD_INT 2
48391: PPUSH
48392: LD_VAR 0 11
48396: PPUSH
48397: CALL_OW 1
48401: ST_TO_ADDR
// end ; exit ;
48402: GO 49790
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
48404: LD_EXP 41
48408: PUSH
48409: LD_EXP 40
48413: PUSH
48414: LD_VAR 0 1
48418: ARRAY
48419: ARRAY
48420: NOT
48421: PUSH
48422: LD_EXP 14
48426: PUSH
48427: LD_VAR 0 1
48431: ARRAY
48432: PPUSH
48433: LD_INT 30
48435: PUSH
48436: LD_INT 3
48438: PUSH
48439: EMPTY
48440: LIST
48441: LIST
48442: PPUSH
48443: CALL_OW 72
48447: AND
48448: PUSH
48449: LD_EXP 19
48453: PUSH
48454: LD_VAR 0 1
48458: ARRAY
48459: AND
48460: IFFALSE 49068
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
48462: LD_ADDR_EXP 56
48466: PUSH
48467: LD_EXP 56
48471: PPUSH
48472: LD_VAR 0 1
48476: PPUSH
48477: LD_INT 5
48479: PPUSH
48480: CALL_OW 1
48484: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
48485: LD_ADDR_VAR 0 2
48489: PUSH
48490: LD_INT 0
48492: PUSH
48493: LD_INT 0
48495: PUSH
48496: LD_INT 0
48498: PUSH
48499: LD_INT 0
48501: PUSH
48502: EMPTY
48503: LIST
48504: LIST
48505: LIST
48506: LIST
48507: ST_TO_ADDR
// if sci > 1 then
48508: LD_VAR 0 8
48512: PUSH
48513: LD_INT 1
48515: GREATER
48516: IFFALSE 48544
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
48518: LD_ADDR_VAR 0 4
48522: PUSH
48523: LD_VAR 0 4
48527: PUSH
48528: LD_VAR 0 8
48532: PUSH
48533: LD_VAR 0 8
48537: PUSH
48538: LD_INT 1
48540: ARRAY
48541: DIFF
48542: DIFF
48543: ST_TO_ADDR
// if tmp and not sci then
48544: LD_VAR 0 4
48548: PUSH
48549: LD_VAR 0 8
48553: NOT
48554: AND
48555: IFFALSE 48624
// begin sort := SortBySkill ( tmp , 4 ) ;
48557: LD_ADDR_VAR 0 9
48561: PUSH
48562: LD_VAR 0 4
48566: PPUSH
48567: LD_INT 4
48569: PPUSH
48570: CALL 38976 0 2
48574: ST_TO_ADDR
// if sort then
48575: LD_VAR 0 9
48579: IFFALSE 48595
// p := sort [ 1 ] ;
48581: LD_ADDR_VAR 0 11
48585: PUSH
48586: LD_VAR 0 9
48590: PUSH
48591: LD_INT 1
48593: ARRAY
48594: ST_TO_ADDR
// if p then
48595: LD_VAR 0 11
48599: IFFALSE 48624
// result := Replace ( result , 4 , p ) ;
48601: LD_ADDR_VAR 0 2
48605: PUSH
48606: LD_VAR 0 2
48610: PPUSH
48611: LD_INT 4
48613: PPUSH
48614: LD_VAR 0 11
48618: PPUSH
48619: CALL_OW 1
48623: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
48624: LD_ADDR_VAR 0 4
48628: PUSH
48629: LD_VAR 0 4
48633: PUSH
48634: LD_VAR 0 7
48638: DIFF
48639: ST_TO_ADDR
// if tmp and mech < 6 then
48640: LD_VAR 0 4
48644: PUSH
48645: LD_VAR 0 7
48649: PUSH
48650: LD_INT 6
48652: LESS
48653: AND
48654: IFFALSE 48842
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
48656: LD_ADDR_VAR 0 9
48660: PUSH
48661: LD_VAR 0 4
48665: PUSH
48666: LD_VAR 0 8
48670: PUSH
48671: LD_VAR 0 7
48675: UNION
48676: DIFF
48677: PPUSH
48678: LD_INT 3
48680: PPUSH
48681: CALL 38976 0 2
48685: ST_TO_ADDR
// p := [ ] ;
48686: LD_ADDR_VAR 0 11
48690: PUSH
48691: EMPTY
48692: ST_TO_ADDR
// if sort then
48693: LD_VAR 0 9
48697: IFFALSE 48813
// for i = 1 to 6 - mech do
48699: LD_ADDR_VAR 0 3
48703: PUSH
48704: DOUBLE
48705: LD_INT 1
48707: DEC
48708: ST_TO_ADDR
48709: LD_INT 6
48711: PUSH
48712: LD_VAR 0 7
48716: MINUS
48717: PUSH
48718: FOR_TO
48719: IFFALSE 48811
// begin if i = sort then
48721: LD_VAR 0 3
48725: PUSH
48726: LD_VAR 0 9
48730: EQUAL
48731: IFFALSE 48735
// break ;
48733: GO 48811
// if GetClass ( i ) = 3 then
48735: LD_VAR 0 3
48739: PPUSH
48740: CALL_OW 257
48744: PUSH
48745: LD_INT 3
48747: EQUAL
48748: IFFALSE 48752
// continue ;
48750: GO 48718
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48752: LD_ADDR_VAR 0 11
48756: PUSH
48757: LD_VAR 0 11
48761: PPUSH
48762: LD_VAR 0 11
48766: PUSH
48767: LD_INT 1
48769: PLUS
48770: PPUSH
48771: LD_VAR 0 9
48775: PUSH
48776: LD_VAR 0 3
48780: ARRAY
48781: PPUSH
48782: CALL_OW 2
48786: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48787: LD_ADDR_VAR 0 4
48791: PUSH
48792: LD_VAR 0 4
48796: PUSH
48797: LD_VAR 0 9
48801: PUSH
48802: LD_VAR 0 3
48806: ARRAY
48807: DIFF
48808: ST_TO_ADDR
// end ;
48809: GO 48718
48811: POP
48812: POP
// if p then
48813: LD_VAR 0 11
48817: IFFALSE 48842
// result := Replace ( result , 3 , p ) ;
48819: LD_ADDR_VAR 0 2
48823: PUSH
48824: LD_VAR 0 2
48828: PPUSH
48829: LD_INT 3
48831: PPUSH
48832: LD_VAR 0 11
48836: PPUSH
48837: CALL_OW 1
48841: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
48842: LD_ADDR_VAR 0 4
48846: PUSH
48847: LD_VAR 0 4
48851: PUSH
48852: LD_VAR 0 6
48856: DIFF
48857: ST_TO_ADDR
// if tmp and eng < 6 then
48858: LD_VAR 0 4
48862: PUSH
48863: LD_VAR 0 6
48867: PUSH
48868: LD_INT 6
48870: LESS
48871: AND
48872: IFFALSE 49066
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
48874: LD_ADDR_VAR 0 9
48878: PUSH
48879: LD_VAR 0 4
48883: PUSH
48884: LD_VAR 0 8
48888: PUSH
48889: LD_VAR 0 7
48893: UNION
48894: PUSH
48895: LD_VAR 0 6
48899: UNION
48900: DIFF
48901: PPUSH
48902: LD_INT 2
48904: PPUSH
48905: CALL 38976 0 2
48909: ST_TO_ADDR
// p := [ ] ;
48910: LD_ADDR_VAR 0 11
48914: PUSH
48915: EMPTY
48916: ST_TO_ADDR
// if sort then
48917: LD_VAR 0 9
48921: IFFALSE 49037
// for i = 1 to 6 - eng do
48923: LD_ADDR_VAR 0 3
48927: PUSH
48928: DOUBLE
48929: LD_INT 1
48931: DEC
48932: ST_TO_ADDR
48933: LD_INT 6
48935: PUSH
48936: LD_VAR 0 6
48940: MINUS
48941: PUSH
48942: FOR_TO
48943: IFFALSE 49035
// begin if i = sort then
48945: LD_VAR 0 3
48949: PUSH
48950: LD_VAR 0 9
48954: EQUAL
48955: IFFALSE 48959
// break ;
48957: GO 49035
// if GetClass ( i ) = 2 then
48959: LD_VAR 0 3
48963: PPUSH
48964: CALL_OW 257
48968: PUSH
48969: LD_INT 2
48971: EQUAL
48972: IFFALSE 48976
// continue ;
48974: GO 48942
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48976: LD_ADDR_VAR 0 11
48980: PUSH
48981: LD_VAR 0 11
48985: PPUSH
48986: LD_VAR 0 11
48990: PUSH
48991: LD_INT 1
48993: PLUS
48994: PPUSH
48995: LD_VAR 0 9
48999: PUSH
49000: LD_VAR 0 3
49004: ARRAY
49005: PPUSH
49006: CALL_OW 2
49010: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49011: LD_ADDR_VAR 0 4
49015: PUSH
49016: LD_VAR 0 4
49020: PUSH
49021: LD_VAR 0 9
49025: PUSH
49026: LD_VAR 0 3
49030: ARRAY
49031: DIFF
49032: ST_TO_ADDR
// end ;
49033: GO 48942
49035: POP
49036: POP
// if p then
49037: LD_VAR 0 11
49041: IFFALSE 49066
// result := Replace ( result , 2 , p ) ;
49043: LD_ADDR_VAR 0 2
49047: PUSH
49048: LD_VAR 0 2
49052: PPUSH
49053: LD_INT 2
49055: PPUSH
49056: LD_VAR 0 11
49060: PPUSH
49061: CALL_OW 1
49065: ST_TO_ADDR
// end ; exit ;
49066: GO 49790
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
49068: LD_EXP 41
49072: PUSH
49073: LD_EXP 40
49077: PUSH
49078: LD_VAR 0 1
49082: ARRAY
49083: ARRAY
49084: NOT
49085: PUSH
49086: LD_EXP 14
49090: PUSH
49091: LD_VAR 0 1
49095: ARRAY
49096: PPUSH
49097: LD_INT 30
49099: PUSH
49100: LD_INT 3
49102: PUSH
49103: EMPTY
49104: LIST
49105: LIST
49106: PPUSH
49107: CALL_OW 72
49111: AND
49112: PUSH
49113: LD_EXP 19
49117: PUSH
49118: LD_VAR 0 1
49122: ARRAY
49123: NOT
49124: AND
49125: IFFALSE 49790
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
49127: LD_ADDR_EXP 56
49131: PUSH
49132: LD_EXP 56
49136: PPUSH
49137: LD_VAR 0 1
49141: PPUSH
49142: LD_INT 6
49144: PPUSH
49145: CALL_OW 1
49149: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
49150: LD_ADDR_VAR 0 2
49154: PUSH
49155: LD_INT 0
49157: PUSH
49158: LD_INT 0
49160: PUSH
49161: LD_INT 0
49163: PUSH
49164: LD_INT 0
49166: PUSH
49167: EMPTY
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: ST_TO_ADDR
// if sci >= 1 then
49173: LD_VAR 0 8
49177: PUSH
49178: LD_INT 1
49180: GREATEREQUAL
49181: IFFALSE 49203
// tmp := tmp diff sci [ 1 ] ;
49183: LD_ADDR_VAR 0 4
49187: PUSH
49188: LD_VAR 0 4
49192: PUSH
49193: LD_VAR 0 8
49197: PUSH
49198: LD_INT 1
49200: ARRAY
49201: DIFF
49202: ST_TO_ADDR
// if tmp and not sci then
49203: LD_VAR 0 4
49207: PUSH
49208: LD_VAR 0 8
49212: NOT
49213: AND
49214: IFFALSE 49283
// begin sort := SortBySkill ( tmp , 4 ) ;
49216: LD_ADDR_VAR 0 9
49220: PUSH
49221: LD_VAR 0 4
49225: PPUSH
49226: LD_INT 4
49228: PPUSH
49229: CALL 38976 0 2
49233: ST_TO_ADDR
// if sort then
49234: LD_VAR 0 9
49238: IFFALSE 49254
// p := sort [ 1 ] ;
49240: LD_ADDR_VAR 0 11
49244: PUSH
49245: LD_VAR 0 9
49249: PUSH
49250: LD_INT 1
49252: ARRAY
49253: ST_TO_ADDR
// if p then
49254: LD_VAR 0 11
49258: IFFALSE 49283
// result := Replace ( result , 4 , p ) ;
49260: LD_ADDR_VAR 0 2
49264: PUSH
49265: LD_VAR 0 2
49269: PPUSH
49270: LD_INT 4
49272: PPUSH
49273: LD_VAR 0 11
49277: PPUSH
49278: CALL_OW 1
49282: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
49283: LD_ADDR_VAR 0 4
49287: PUSH
49288: LD_VAR 0 4
49292: PUSH
49293: LD_VAR 0 7
49297: DIFF
49298: ST_TO_ADDR
// if tmp and mech < 6 then
49299: LD_VAR 0 4
49303: PUSH
49304: LD_VAR 0 7
49308: PUSH
49309: LD_INT 6
49311: LESS
49312: AND
49313: IFFALSE 49495
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
49315: LD_ADDR_VAR 0 9
49319: PUSH
49320: LD_VAR 0 4
49324: PUSH
49325: LD_VAR 0 7
49329: DIFF
49330: PPUSH
49331: LD_INT 3
49333: PPUSH
49334: CALL 38976 0 2
49338: ST_TO_ADDR
// p := [ ] ;
49339: LD_ADDR_VAR 0 11
49343: PUSH
49344: EMPTY
49345: ST_TO_ADDR
// if sort then
49346: LD_VAR 0 9
49350: IFFALSE 49466
// for i = 1 to 6 - mech do
49352: LD_ADDR_VAR 0 3
49356: PUSH
49357: DOUBLE
49358: LD_INT 1
49360: DEC
49361: ST_TO_ADDR
49362: LD_INT 6
49364: PUSH
49365: LD_VAR 0 7
49369: MINUS
49370: PUSH
49371: FOR_TO
49372: IFFALSE 49464
// begin if i = sort then
49374: LD_VAR 0 3
49378: PUSH
49379: LD_VAR 0 9
49383: EQUAL
49384: IFFALSE 49388
// break ;
49386: GO 49464
// if GetClass ( i ) = 3 then
49388: LD_VAR 0 3
49392: PPUSH
49393: CALL_OW 257
49397: PUSH
49398: LD_INT 3
49400: EQUAL
49401: IFFALSE 49405
// continue ;
49403: GO 49371
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49405: LD_ADDR_VAR 0 11
49409: PUSH
49410: LD_VAR 0 11
49414: PPUSH
49415: LD_VAR 0 11
49419: PUSH
49420: LD_INT 1
49422: PLUS
49423: PPUSH
49424: LD_VAR 0 9
49428: PUSH
49429: LD_VAR 0 3
49433: ARRAY
49434: PPUSH
49435: CALL_OW 2
49439: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49440: LD_ADDR_VAR 0 4
49444: PUSH
49445: LD_VAR 0 4
49449: PUSH
49450: LD_VAR 0 9
49454: PUSH
49455: LD_VAR 0 3
49459: ARRAY
49460: DIFF
49461: ST_TO_ADDR
// end ;
49462: GO 49371
49464: POP
49465: POP
// if p then
49466: LD_VAR 0 11
49470: IFFALSE 49495
// result := Replace ( result , 3 , p ) ;
49472: LD_ADDR_VAR 0 2
49476: PUSH
49477: LD_VAR 0 2
49481: PPUSH
49482: LD_INT 3
49484: PPUSH
49485: LD_VAR 0 11
49489: PPUSH
49490: CALL_OW 1
49494: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
49495: LD_ADDR_VAR 0 4
49499: PUSH
49500: LD_VAR 0 4
49504: PUSH
49505: LD_VAR 0 6
49509: DIFF
49510: ST_TO_ADDR
// if tmp and eng < 4 then
49511: LD_VAR 0 4
49515: PUSH
49516: LD_VAR 0 6
49520: PUSH
49521: LD_INT 4
49523: LESS
49524: AND
49525: IFFALSE 49715
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
49527: LD_ADDR_VAR 0 9
49531: PUSH
49532: LD_VAR 0 4
49536: PUSH
49537: LD_VAR 0 7
49541: PUSH
49542: LD_VAR 0 6
49546: UNION
49547: DIFF
49548: PPUSH
49549: LD_INT 2
49551: PPUSH
49552: CALL 38976 0 2
49556: ST_TO_ADDR
// p := [ ] ;
49557: LD_ADDR_VAR 0 11
49561: PUSH
49562: EMPTY
49563: ST_TO_ADDR
// if sort then
49564: LD_VAR 0 9
49568: IFFALSE 49684
// for i = 1 to 4 - eng do
49570: LD_ADDR_VAR 0 3
49574: PUSH
49575: DOUBLE
49576: LD_INT 1
49578: DEC
49579: ST_TO_ADDR
49580: LD_INT 4
49582: PUSH
49583: LD_VAR 0 6
49587: MINUS
49588: PUSH
49589: FOR_TO
49590: IFFALSE 49682
// begin if i = sort then
49592: LD_VAR 0 3
49596: PUSH
49597: LD_VAR 0 9
49601: EQUAL
49602: IFFALSE 49606
// break ;
49604: GO 49682
// if GetClass ( i ) = 2 then
49606: LD_VAR 0 3
49610: PPUSH
49611: CALL_OW 257
49615: PUSH
49616: LD_INT 2
49618: EQUAL
49619: IFFALSE 49623
// continue ;
49621: GO 49589
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49623: LD_ADDR_VAR 0 11
49627: PUSH
49628: LD_VAR 0 11
49632: PPUSH
49633: LD_VAR 0 11
49637: PUSH
49638: LD_INT 1
49640: PLUS
49641: PPUSH
49642: LD_VAR 0 9
49646: PUSH
49647: LD_VAR 0 3
49651: ARRAY
49652: PPUSH
49653: CALL_OW 2
49657: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49658: LD_ADDR_VAR 0 4
49662: PUSH
49663: LD_VAR 0 4
49667: PUSH
49668: LD_VAR 0 9
49672: PUSH
49673: LD_VAR 0 3
49677: ARRAY
49678: DIFF
49679: ST_TO_ADDR
// end ;
49680: GO 49589
49682: POP
49683: POP
// if p then
49684: LD_VAR 0 11
49688: IFFALSE 49713
// result := Replace ( result , 2 , p ) ;
49690: LD_ADDR_VAR 0 2
49694: PUSH
49695: LD_VAR 0 2
49699: PPUSH
49700: LD_INT 2
49702: PPUSH
49703: LD_VAR 0 11
49707: PPUSH
49708: CALL_OW 1
49712: ST_TO_ADDR
// end else
49713: GO 49759
// for i = eng downto 5 do
49715: LD_ADDR_VAR 0 3
49719: PUSH
49720: DOUBLE
49721: LD_VAR 0 6
49725: INC
49726: ST_TO_ADDR
49727: LD_INT 5
49729: PUSH
49730: FOR_DOWNTO
49731: IFFALSE 49757
// tmp := tmp union eng [ i ] ;
49733: LD_ADDR_VAR 0 4
49737: PUSH
49738: LD_VAR 0 4
49742: PUSH
49743: LD_VAR 0 6
49747: PUSH
49748: LD_VAR 0 3
49752: ARRAY
49753: UNION
49754: ST_TO_ADDR
49755: GO 49730
49757: POP
49758: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
49759: LD_ADDR_VAR 0 2
49763: PUSH
49764: LD_VAR 0 2
49768: PPUSH
49769: LD_INT 1
49771: PPUSH
49772: LD_VAR 0 4
49776: PUSH
49777: LD_VAR 0 5
49781: DIFF
49782: PPUSH
49783: CALL_OW 1
49787: ST_TO_ADDR
// exit ;
49788: GO 49790
// end ; end ;
49790: LD_VAR 0 2
49794: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
49795: LD_INT 0
49797: PPUSH
49798: PPUSH
49799: PPUSH
// if not mc_bases then
49800: LD_EXP 14
49804: NOT
49805: IFFALSE 49809
// exit ;
49807: GO 49915
// for i = 1 to mc_bases do
49809: LD_ADDR_VAR 0 2
49813: PUSH
49814: DOUBLE
49815: LD_INT 1
49817: DEC
49818: ST_TO_ADDR
49819: LD_EXP 14
49823: PUSH
49824: FOR_TO
49825: IFFALSE 49906
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
49827: LD_ADDR_VAR 0 3
49831: PUSH
49832: LD_EXP 14
49836: PUSH
49837: LD_VAR 0 2
49841: ARRAY
49842: PPUSH
49843: LD_INT 21
49845: PUSH
49846: LD_INT 3
49848: PUSH
49849: EMPTY
49850: LIST
49851: LIST
49852: PUSH
49853: LD_INT 3
49855: PUSH
49856: LD_INT 24
49858: PUSH
49859: LD_INT 1000
49861: PUSH
49862: EMPTY
49863: LIST
49864: LIST
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PUSH
49870: EMPTY
49871: LIST
49872: LIST
49873: PPUSH
49874: CALL_OW 72
49878: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
49879: LD_ADDR_EXP 15
49883: PUSH
49884: LD_EXP 15
49888: PPUSH
49889: LD_VAR 0 2
49893: PPUSH
49894: LD_VAR 0 3
49898: PPUSH
49899: CALL_OW 1
49903: ST_TO_ADDR
// end ;
49904: GO 49824
49906: POP
49907: POP
// RaiseSailEvent ( 101 ) ;
49908: LD_INT 101
49910: PPUSH
49911: CALL_OW 427
// end ;
49915: LD_VAR 0 1
49919: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
49920: LD_INT 0
49922: PPUSH
49923: PPUSH
49924: PPUSH
49925: PPUSH
49926: PPUSH
49927: PPUSH
49928: PPUSH
// if not mc_bases then
49929: LD_EXP 14
49933: NOT
49934: IFFALSE 49938
// exit ;
49936: GO 50500
// for i = 1 to mc_bases do
49938: LD_ADDR_VAR 0 2
49942: PUSH
49943: DOUBLE
49944: LD_INT 1
49946: DEC
49947: ST_TO_ADDR
49948: LD_EXP 14
49952: PUSH
49953: FOR_TO
49954: IFFALSE 50491
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
49956: LD_ADDR_VAR 0 5
49960: PUSH
49961: LD_EXP 14
49965: PUSH
49966: LD_VAR 0 2
49970: ARRAY
49971: PUSH
49972: LD_EXP 43
49976: PUSH
49977: LD_VAR 0 2
49981: ARRAY
49982: UNION
49983: PPUSH
49984: LD_INT 21
49986: PUSH
49987: LD_INT 1
49989: PUSH
49990: EMPTY
49991: LIST
49992: LIST
49993: PUSH
49994: LD_INT 1
49996: PUSH
49997: LD_INT 3
49999: PUSH
50000: LD_INT 54
50002: PUSH
50003: EMPTY
50004: LIST
50005: PUSH
50006: EMPTY
50007: LIST
50008: LIST
50009: PUSH
50010: LD_INT 3
50012: PUSH
50013: LD_INT 24
50015: PUSH
50016: LD_INT 800
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: EMPTY
50024: LIST
50025: LIST
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: LIST
50031: PUSH
50032: EMPTY
50033: LIST
50034: LIST
50035: PPUSH
50036: CALL_OW 72
50040: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
50041: LD_ADDR_VAR 0 6
50045: PUSH
50046: LD_EXP 14
50050: PUSH
50051: LD_VAR 0 2
50055: ARRAY
50056: PPUSH
50057: LD_INT 21
50059: PUSH
50060: LD_INT 1
50062: PUSH
50063: EMPTY
50064: LIST
50065: LIST
50066: PUSH
50067: LD_INT 1
50069: PUSH
50070: LD_INT 3
50072: PUSH
50073: LD_INT 54
50075: PUSH
50076: EMPTY
50077: LIST
50078: PUSH
50079: EMPTY
50080: LIST
50081: LIST
50082: PUSH
50083: LD_INT 3
50085: PUSH
50086: LD_INT 24
50088: PUSH
50089: LD_INT 250
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: PUSH
50096: EMPTY
50097: LIST
50098: LIST
50099: PUSH
50100: EMPTY
50101: LIST
50102: LIST
50103: LIST
50104: PUSH
50105: EMPTY
50106: LIST
50107: LIST
50108: PPUSH
50109: CALL_OW 72
50113: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
50114: LD_ADDR_VAR 0 7
50118: PUSH
50119: LD_VAR 0 5
50123: PUSH
50124: LD_VAR 0 6
50128: DIFF
50129: ST_TO_ADDR
// if not need_heal_1 then
50130: LD_VAR 0 6
50134: NOT
50135: IFFALSE 50168
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
50137: LD_ADDR_EXP 17
50141: PUSH
50142: LD_EXP 17
50146: PPUSH
50147: LD_VAR 0 2
50151: PUSH
50152: LD_INT 1
50154: PUSH
50155: EMPTY
50156: LIST
50157: LIST
50158: PPUSH
50159: EMPTY
50160: PPUSH
50161: CALL 9427 0 3
50165: ST_TO_ADDR
50166: GO 50238
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
50168: LD_ADDR_EXP 17
50172: PUSH
50173: LD_EXP 17
50177: PPUSH
50178: LD_VAR 0 2
50182: PUSH
50183: LD_INT 1
50185: PUSH
50186: EMPTY
50187: LIST
50188: LIST
50189: PPUSH
50190: LD_EXP 17
50194: PUSH
50195: LD_VAR 0 2
50199: ARRAY
50200: PUSH
50201: LD_INT 1
50203: ARRAY
50204: PPUSH
50205: LD_INT 3
50207: PUSH
50208: LD_INT 24
50210: PUSH
50211: LD_INT 1000
50213: PUSH
50214: EMPTY
50215: LIST
50216: LIST
50217: PUSH
50218: EMPTY
50219: LIST
50220: LIST
50221: PPUSH
50222: CALL_OW 72
50226: PUSH
50227: LD_VAR 0 6
50231: UNION
50232: PPUSH
50233: CALL 9427 0 3
50237: ST_TO_ADDR
// if not need_heal_2 then
50238: LD_VAR 0 7
50242: NOT
50243: IFFALSE 50276
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
50245: LD_ADDR_EXP 17
50249: PUSH
50250: LD_EXP 17
50254: PPUSH
50255: LD_VAR 0 2
50259: PUSH
50260: LD_INT 2
50262: PUSH
50263: EMPTY
50264: LIST
50265: LIST
50266: PPUSH
50267: EMPTY
50268: PPUSH
50269: CALL 9427 0 3
50273: ST_TO_ADDR
50274: GO 50308
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
50276: LD_ADDR_EXP 17
50280: PUSH
50281: LD_EXP 17
50285: PPUSH
50286: LD_VAR 0 2
50290: PUSH
50291: LD_INT 2
50293: PUSH
50294: EMPTY
50295: LIST
50296: LIST
50297: PPUSH
50298: LD_VAR 0 7
50302: PPUSH
50303: CALL 9427 0 3
50307: ST_TO_ADDR
// if need_heal_2 then
50308: LD_VAR 0 7
50312: IFFALSE 50473
// for j in need_heal_2 do
50314: LD_ADDR_VAR 0 3
50318: PUSH
50319: LD_VAR 0 7
50323: PUSH
50324: FOR_IN
50325: IFFALSE 50471
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50327: LD_ADDR_VAR 0 5
50331: PUSH
50332: LD_EXP 14
50336: PUSH
50337: LD_VAR 0 2
50341: ARRAY
50342: PPUSH
50343: LD_INT 2
50345: PUSH
50346: LD_INT 30
50348: PUSH
50349: LD_INT 6
50351: PUSH
50352: EMPTY
50353: LIST
50354: LIST
50355: PUSH
50356: LD_INT 30
50358: PUSH
50359: LD_INT 7
50361: PUSH
50362: EMPTY
50363: LIST
50364: LIST
50365: PUSH
50366: LD_INT 30
50368: PUSH
50369: LD_INT 8
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PUSH
50376: LD_INT 30
50378: PUSH
50379: LD_INT 0
50381: PUSH
50382: EMPTY
50383: LIST
50384: LIST
50385: PUSH
50386: LD_INT 30
50388: PUSH
50389: LD_INT 1
50391: PUSH
50392: EMPTY
50393: LIST
50394: LIST
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: LIST
50400: LIST
50401: LIST
50402: LIST
50403: PPUSH
50404: CALL_OW 72
50408: ST_TO_ADDR
// if tmp then
50409: LD_VAR 0 5
50413: IFFALSE 50469
// begin k := NearestUnitToUnit ( tmp , j ) ;
50415: LD_ADDR_VAR 0 4
50419: PUSH
50420: LD_VAR 0 5
50424: PPUSH
50425: LD_VAR 0 3
50429: PPUSH
50430: CALL_OW 74
50434: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
50435: LD_VAR 0 3
50439: PPUSH
50440: LD_VAR 0 4
50444: PPUSH
50445: CALL_OW 296
50449: PUSH
50450: LD_INT 5
50452: GREATER
50453: IFFALSE 50469
// ComMoveToNearbyEntrance ( j , k ) ;
50455: LD_VAR 0 3
50459: PPUSH
50460: LD_VAR 0 4
50464: PPUSH
50465: CALL 41293 0 2
// end ; end ;
50469: GO 50324
50471: POP
50472: POP
// if not need_heal_1 and not need_heal_2 then
50473: LD_VAR 0 6
50477: NOT
50478: PUSH
50479: LD_VAR 0 7
50483: NOT
50484: AND
50485: IFFALSE 50489
// continue ;
50487: GO 49953
// end ;
50489: GO 49953
50491: POP
50492: POP
// RaiseSailEvent ( 102 ) ;
50493: LD_INT 102
50495: PPUSH
50496: CALL_OW 427
// end ;
50500: LD_VAR 0 1
50504: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
50505: LD_INT 0
50507: PPUSH
50508: PPUSH
50509: PPUSH
50510: PPUSH
50511: PPUSH
50512: PPUSH
50513: PPUSH
50514: PPUSH
// if not mc_bases then
50515: LD_EXP 14
50519: NOT
50520: IFFALSE 50524
// exit ;
50522: GO 51385
// for i = 1 to mc_bases do
50524: LD_ADDR_VAR 0 2
50528: PUSH
50529: DOUBLE
50530: LD_INT 1
50532: DEC
50533: ST_TO_ADDR
50534: LD_EXP 14
50538: PUSH
50539: FOR_TO
50540: IFFALSE 51383
// begin if not mc_building_need_repair [ i ] then
50542: LD_EXP 15
50546: PUSH
50547: LD_VAR 0 2
50551: ARRAY
50552: NOT
50553: IFFALSE 50740
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
50555: LD_ADDR_VAR 0 6
50559: PUSH
50560: LD_EXP 33
50564: PUSH
50565: LD_VAR 0 2
50569: ARRAY
50570: PPUSH
50571: LD_INT 3
50573: PUSH
50574: LD_INT 24
50576: PUSH
50577: LD_INT 1000
50579: PUSH
50580: EMPTY
50581: LIST
50582: LIST
50583: PUSH
50584: EMPTY
50585: LIST
50586: LIST
50587: PUSH
50588: LD_INT 2
50590: PUSH
50591: LD_INT 34
50593: PUSH
50594: LD_INT 13
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: PUSH
50601: LD_INT 34
50603: PUSH
50604: LD_INT 52
50606: PUSH
50607: EMPTY
50608: LIST
50609: LIST
50610: PUSH
50611: LD_INT 34
50613: PUSH
50614: LD_EXP 63
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PUSH
50623: EMPTY
50624: LIST
50625: LIST
50626: LIST
50627: LIST
50628: PUSH
50629: EMPTY
50630: LIST
50631: LIST
50632: PPUSH
50633: CALL_OW 72
50637: ST_TO_ADDR
// if cranes then
50638: LD_VAR 0 6
50642: IFFALSE 50704
// for j in cranes do
50644: LD_ADDR_VAR 0 3
50648: PUSH
50649: LD_VAR 0 6
50653: PUSH
50654: FOR_IN
50655: IFFALSE 50702
// if not IsInArea ( j , mc_parking [ i ] ) then
50657: LD_VAR 0 3
50661: PPUSH
50662: LD_EXP 38
50666: PUSH
50667: LD_VAR 0 2
50671: ARRAY
50672: PPUSH
50673: CALL_OW 308
50677: NOT
50678: IFFALSE 50700
// ComMoveToArea ( j , mc_parking [ i ] ) ;
50680: LD_VAR 0 3
50684: PPUSH
50685: LD_EXP 38
50689: PUSH
50690: LD_VAR 0 2
50694: ARRAY
50695: PPUSH
50696: CALL_OW 113
50700: GO 50654
50702: POP
50703: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
50704: LD_ADDR_EXP 16
50708: PUSH
50709: LD_EXP 16
50713: PPUSH
50714: LD_VAR 0 2
50718: PPUSH
50719: EMPTY
50720: PPUSH
50721: CALL_OW 1
50725: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
50726: LD_VAR 0 2
50730: PPUSH
50731: LD_INT 101
50733: PPUSH
50734: CALL 45628 0 2
// continue ;
50738: GO 50539
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
50740: LD_ADDR_EXP 20
50744: PUSH
50745: LD_EXP 20
50749: PPUSH
50750: LD_VAR 0 2
50754: PPUSH
50755: EMPTY
50756: PPUSH
50757: CALL_OW 1
50761: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50762: LD_VAR 0 2
50766: PPUSH
50767: LD_INT 103
50769: PPUSH
50770: CALL 45628 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
50774: LD_ADDR_VAR 0 5
50778: PUSH
50779: LD_EXP 14
50783: PUSH
50784: LD_VAR 0 2
50788: ARRAY
50789: PUSH
50790: LD_EXP 43
50794: PUSH
50795: LD_VAR 0 2
50799: ARRAY
50800: UNION
50801: PPUSH
50802: LD_INT 2
50804: PUSH
50805: LD_INT 25
50807: PUSH
50808: LD_INT 2
50810: PUSH
50811: EMPTY
50812: LIST
50813: LIST
50814: PUSH
50815: LD_INT 25
50817: PUSH
50818: LD_INT 16
50820: PUSH
50821: EMPTY
50822: LIST
50823: LIST
50824: PUSH
50825: EMPTY
50826: LIST
50827: LIST
50828: LIST
50829: PUSH
50830: EMPTY
50831: LIST
50832: PPUSH
50833: CALL_OW 72
50837: PUSH
50838: LD_EXP 17
50842: PUSH
50843: LD_VAR 0 2
50847: ARRAY
50848: PUSH
50849: LD_INT 1
50851: ARRAY
50852: PUSH
50853: LD_EXP 17
50857: PUSH
50858: LD_VAR 0 2
50862: ARRAY
50863: PUSH
50864: LD_INT 2
50866: ARRAY
50867: UNION
50868: DIFF
50869: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
50870: LD_ADDR_VAR 0 6
50874: PUSH
50875: LD_EXP 33
50879: PUSH
50880: LD_VAR 0 2
50884: ARRAY
50885: PPUSH
50886: LD_INT 2
50888: PUSH
50889: LD_INT 34
50891: PUSH
50892: LD_INT 13
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: PUSH
50899: LD_INT 34
50901: PUSH
50902: LD_INT 52
50904: PUSH
50905: EMPTY
50906: LIST
50907: LIST
50908: PUSH
50909: LD_INT 34
50911: PUSH
50912: LD_EXP 63
50916: PUSH
50917: EMPTY
50918: LIST
50919: LIST
50920: PUSH
50921: EMPTY
50922: LIST
50923: LIST
50924: LIST
50925: LIST
50926: PPUSH
50927: CALL_OW 72
50931: ST_TO_ADDR
// if cranes then
50932: LD_VAR 0 6
50936: IFFALSE 51072
// begin for j in cranes do
50938: LD_ADDR_VAR 0 3
50942: PUSH
50943: LD_VAR 0 6
50947: PUSH
50948: FOR_IN
50949: IFFALSE 51070
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
50951: LD_VAR 0 3
50955: PPUSH
50956: CALL_OW 256
50960: PUSH
50961: LD_INT 1000
50963: EQUAL
50964: PUSH
50965: LD_VAR 0 3
50969: PPUSH
50970: CALL_OW 314
50974: NOT
50975: AND
50976: IFFALSE 51010
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
50978: LD_VAR 0 3
50982: PPUSH
50983: LD_EXP 15
50987: PUSH
50988: LD_VAR 0 2
50992: ARRAY
50993: PPUSH
50994: LD_VAR 0 3
50998: PPUSH
50999: CALL_OW 74
51003: PPUSH
51004: CALL_OW 130
51008: GO 51068
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
51010: LD_VAR 0 3
51014: PPUSH
51015: CALL_OW 256
51019: PUSH
51020: LD_INT 500
51022: LESS
51023: PUSH
51024: LD_VAR 0 3
51028: PPUSH
51029: LD_EXP 38
51033: PUSH
51034: LD_VAR 0 2
51038: ARRAY
51039: PPUSH
51040: CALL_OW 308
51044: NOT
51045: AND
51046: IFFALSE 51068
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51048: LD_VAR 0 3
51052: PPUSH
51053: LD_EXP 38
51057: PUSH
51058: LD_VAR 0 2
51062: ARRAY
51063: PPUSH
51064: CALL_OW 113
// end ;
51068: GO 50948
51070: POP
51071: POP
// end ; if tmp > 3 then
51072: LD_VAR 0 5
51076: PUSH
51077: LD_INT 3
51079: GREATER
51080: IFFALSE 51100
// tmp := ShrinkArray ( tmp , 4 ) ;
51082: LD_ADDR_VAR 0 5
51086: PUSH
51087: LD_VAR 0 5
51091: PPUSH
51092: LD_INT 4
51094: PPUSH
51095: CALL 40785 0 2
51099: ST_TO_ADDR
// if not tmp then
51100: LD_VAR 0 5
51104: NOT
51105: IFFALSE 51109
// continue ;
51107: GO 50539
// for j in tmp do
51109: LD_ADDR_VAR 0 3
51113: PUSH
51114: LD_VAR 0 5
51118: PUSH
51119: FOR_IN
51120: IFFALSE 51379
// begin if IsInUnit ( j ) then
51122: LD_VAR 0 3
51126: PPUSH
51127: CALL_OW 310
51131: IFFALSE 51142
// ComExitBuilding ( j ) ;
51133: LD_VAR 0 3
51137: PPUSH
51138: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
51142: LD_VAR 0 3
51146: PUSH
51147: LD_EXP 16
51151: PUSH
51152: LD_VAR 0 2
51156: ARRAY
51157: IN
51158: NOT
51159: IFFALSE 51217
// begin SetTag ( j , 101 ) ;
51161: LD_VAR 0 3
51165: PPUSH
51166: LD_INT 101
51168: PPUSH
51169: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
51173: LD_ADDR_EXP 16
51177: PUSH
51178: LD_EXP 16
51182: PPUSH
51183: LD_VAR 0 2
51187: PUSH
51188: LD_EXP 16
51192: PUSH
51193: LD_VAR 0 2
51197: ARRAY
51198: PUSH
51199: LD_INT 1
51201: PLUS
51202: PUSH
51203: EMPTY
51204: LIST
51205: LIST
51206: PPUSH
51207: LD_VAR 0 3
51211: PPUSH
51212: CALL 9427 0 3
51216: ST_TO_ADDR
// end ; wait ( 1 ) ;
51217: LD_INT 1
51219: PPUSH
51220: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
51224: LD_ADDR_VAR 0 7
51228: PUSH
51229: LD_EXP 15
51233: PUSH
51234: LD_VAR 0 2
51238: ARRAY
51239: ST_TO_ADDR
// if mc_scan [ i ] then
51240: LD_EXP 37
51244: PUSH
51245: LD_VAR 0 2
51249: ARRAY
51250: IFFALSE 51312
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
51252: LD_ADDR_VAR 0 7
51256: PUSH
51257: LD_EXP 15
51261: PUSH
51262: LD_VAR 0 2
51266: ARRAY
51267: PPUSH
51268: LD_INT 3
51270: PUSH
51271: LD_INT 30
51273: PUSH
51274: LD_INT 32
51276: PUSH
51277: EMPTY
51278: LIST
51279: LIST
51280: PUSH
51281: LD_INT 30
51283: PUSH
51284: LD_INT 33
51286: PUSH
51287: EMPTY
51288: LIST
51289: LIST
51290: PUSH
51291: LD_INT 30
51293: PUSH
51294: LD_INT 31
51296: PUSH
51297: EMPTY
51298: LIST
51299: LIST
51300: PUSH
51301: EMPTY
51302: LIST
51303: LIST
51304: LIST
51305: LIST
51306: PPUSH
51307: CALL_OW 72
51311: ST_TO_ADDR
// if not to_repair_tmp then
51312: LD_VAR 0 7
51316: NOT
51317: IFFALSE 51321
// continue ;
51319: GO 51119
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
51321: LD_ADDR_VAR 0 8
51325: PUSH
51326: LD_VAR 0 7
51330: PPUSH
51331: LD_VAR 0 3
51335: PPUSH
51336: CALL_OW 74
51340: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
51341: LD_VAR 0 8
51345: PPUSH
51346: LD_INT 16
51348: PPUSH
51349: CALL 12020 0 2
51353: PUSH
51354: LD_INT 4
51356: ARRAY
51357: PUSH
51358: LD_INT 10
51360: LESS
51361: IFFALSE 51377
// ComRepairBuilding ( j , to_repair ) ;
51363: LD_VAR 0 3
51367: PPUSH
51368: LD_VAR 0 8
51372: PPUSH
51373: CALL_OW 130
// end ;
51377: GO 51119
51379: POP
51380: POP
// end ;
51381: GO 50539
51383: POP
51384: POP
// end ;
51385: LD_VAR 0 1
51389: RET
// export function MC_Heal ; var i , j , tmp ; begin
51390: LD_INT 0
51392: PPUSH
51393: PPUSH
51394: PPUSH
51395: PPUSH
// if not mc_bases then
51396: LD_EXP 14
51400: NOT
51401: IFFALSE 51405
// exit ;
51403: GO 51807
// for i = 1 to mc_bases do
51405: LD_ADDR_VAR 0 2
51409: PUSH
51410: DOUBLE
51411: LD_INT 1
51413: DEC
51414: ST_TO_ADDR
51415: LD_EXP 14
51419: PUSH
51420: FOR_TO
51421: IFFALSE 51805
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
51423: LD_EXP 17
51427: PUSH
51428: LD_VAR 0 2
51432: ARRAY
51433: PUSH
51434: LD_INT 1
51436: ARRAY
51437: NOT
51438: PUSH
51439: LD_EXP 17
51443: PUSH
51444: LD_VAR 0 2
51448: ARRAY
51449: PUSH
51450: LD_INT 2
51452: ARRAY
51453: NOT
51454: AND
51455: IFFALSE 51493
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
51457: LD_ADDR_EXP 18
51461: PUSH
51462: LD_EXP 18
51466: PPUSH
51467: LD_VAR 0 2
51471: PPUSH
51472: EMPTY
51473: PPUSH
51474: CALL_OW 1
51478: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
51479: LD_VAR 0 2
51483: PPUSH
51484: LD_INT 102
51486: PPUSH
51487: CALL 45628 0 2
// continue ;
51491: GO 51420
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
51493: LD_ADDR_VAR 0 4
51497: PUSH
51498: LD_EXP 14
51502: PUSH
51503: LD_VAR 0 2
51507: ARRAY
51508: PPUSH
51509: LD_INT 25
51511: PUSH
51512: LD_INT 4
51514: PUSH
51515: EMPTY
51516: LIST
51517: LIST
51518: PPUSH
51519: CALL_OW 72
51523: ST_TO_ADDR
// if not tmp then
51524: LD_VAR 0 4
51528: NOT
51529: IFFALSE 51533
// continue ;
51531: GO 51420
// if mc_taming [ i ] then
51533: LD_EXP 45
51537: PUSH
51538: LD_VAR 0 2
51542: ARRAY
51543: IFFALSE 51567
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
51545: LD_ADDR_EXP 45
51549: PUSH
51550: LD_EXP 45
51554: PPUSH
51555: LD_VAR 0 2
51559: PPUSH
51560: EMPTY
51561: PPUSH
51562: CALL_OW 1
51566: ST_TO_ADDR
// for j in tmp do
51567: LD_ADDR_VAR 0 3
51571: PUSH
51572: LD_VAR 0 4
51576: PUSH
51577: FOR_IN
51578: IFFALSE 51801
// begin if IsInUnit ( j ) then
51580: LD_VAR 0 3
51584: PPUSH
51585: CALL_OW 310
51589: IFFALSE 51600
// ComExitBuilding ( j ) ;
51591: LD_VAR 0 3
51595: PPUSH
51596: CALL_OW 122
// if not j in mc_healers [ i ] then
51600: LD_VAR 0 3
51604: PUSH
51605: LD_EXP 18
51609: PUSH
51610: LD_VAR 0 2
51614: ARRAY
51615: IN
51616: NOT
51617: IFFALSE 51663
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
51619: LD_ADDR_EXP 18
51623: PUSH
51624: LD_EXP 18
51628: PPUSH
51629: LD_VAR 0 2
51633: PUSH
51634: LD_EXP 18
51638: PUSH
51639: LD_VAR 0 2
51643: ARRAY
51644: PUSH
51645: LD_INT 1
51647: PLUS
51648: PUSH
51649: EMPTY
51650: LIST
51651: LIST
51652: PPUSH
51653: LD_VAR 0 3
51657: PPUSH
51658: CALL 9427 0 3
51662: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
51663: LD_VAR 0 3
51667: PPUSH
51668: CALL_OW 110
51672: PUSH
51673: LD_INT 102
51675: NONEQUAL
51676: IFFALSE 51690
// SetTag ( j , 102 ) ;
51678: LD_VAR 0 3
51682: PPUSH
51683: LD_INT 102
51685: PPUSH
51686: CALL_OW 109
// Wait ( 3 ) ;
51690: LD_INT 3
51692: PPUSH
51693: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
51697: LD_EXP 17
51701: PUSH
51702: LD_VAR 0 2
51706: ARRAY
51707: PUSH
51708: LD_INT 1
51710: ARRAY
51711: IFFALSE 51743
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
51713: LD_VAR 0 3
51717: PPUSH
51718: LD_EXP 17
51722: PUSH
51723: LD_VAR 0 2
51727: ARRAY
51728: PUSH
51729: LD_INT 1
51731: ARRAY
51732: PUSH
51733: LD_INT 1
51735: ARRAY
51736: PPUSH
51737: CALL_OW 128
51741: GO 51799
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
51743: LD_VAR 0 3
51747: PPUSH
51748: CALL_OW 314
51752: NOT
51753: PUSH
51754: LD_EXP 17
51758: PUSH
51759: LD_VAR 0 2
51763: ARRAY
51764: PUSH
51765: LD_INT 2
51767: ARRAY
51768: AND
51769: IFFALSE 51799
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
51771: LD_VAR 0 3
51775: PPUSH
51776: LD_EXP 17
51780: PUSH
51781: LD_VAR 0 2
51785: ARRAY
51786: PUSH
51787: LD_INT 2
51789: ARRAY
51790: PUSH
51791: LD_INT 1
51793: ARRAY
51794: PPUSH
51795: CALL_OW 128
// end ;
51799: GO 51577
51801: POP
51802: POP
// end ;
51803: GO 51420
51805: POP
51806: POP
// end ;
51807: LD_VAR 0 1
51811: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
51812: LD_INT 0
51814: PPUSH
51815: PPUSH
51816: PPUSH
51817: PPUSH
51818: PPUSH
// if not mc_bases then
51819: LD_EXP 14
51823: NOT
51824: IFFALSE 51828
// exit ;
51826: GO 52971
// for i = 1 to mc_bases do
51828: LD_ADDR_VAR 0 2
51832: PUSH
51833: DOUBLE
51834: LD_INT 1
51836: DEC
51837: ST_TO_ADDR
51838: LD_EXP 14
51842: PUSH
51843: FOR_TO
51844: IFFALSE 52969
// begin if mc_scan [ i ] then
51846: LD_EXP 37
51850: PUSH
51851: LD_VAR 0 2
51855: ARRAY
51856: IFFALSE 51860
// continue ;
51858: GO 51843
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
51860: LD_EXP 19
51864: PUSH
51865: LD_VAR 0 2
51869: ARRAY
51870: NOT
51871: PUSH
51872: LD_EXP 21
51876: PUSH
51877: LD_VAR 0 2
51881: ARRAY
51882: NOT
51883: AND
51884: PUSH
51885: LD_EXP 20
51889: PUSH
51890: LD_VAR 0 2
51894: ARRAY
51895: AND
51896: IFFALSE 51934
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
51898: LD_ADDR_EXP 20
51902: PUSH
51903: LD_EXP 20
51907: PPUSH
51908: LD_VAR 0 2
51912: PPUSH
51913: EMPTY
51914: PPUSH
51915: CALL_OW 1
51919: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
51920: LD_VAR 0 2
51924: PPUSH
51925: LD_INT 103
51927: PPUSH
51928: CALL 45628 0 2
// continue ;
51932: GO 51843
// end ; if mc_construct_list [ i ] then
51934: LD_EXP 21
51938: PUSH
51939: LD_VAR 0 2
51943: ARRAY
51944: IFFALSE 52164
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
51946: LD_ADDR_VAR 0 4
51950: PUSH
51951: LD_EXP 14
51955: PUSH
51956: LD_VAR 0 2
51960: ARRAY
51961: PPUSH
51962: LD_INT 25
51964: PUSH
51965: LD_INT 2
51967: PUSH
51968: EMPTY
51969: LIST
51970: LIST
51971: PPUSH
51972: CALL_OW 72
51976: PUSH
51977: LD_EXP 16
51981: PUSH
51982: LD_VAR 0 2
51986: ARRAY
51987: DIFF
51988: ST_TO_ADDR
// if not tmp then
51989: LD_VAR 0 4
51993: NOT
51994: IFFALSE 51998
// continue ;
51996: GO 51843
// for j in tmp do
51998: LD_ADDR_VAR 0 3
52002: PUSH
52003: LD_VAR 0 4
52007: PUSH
52008: FOR_IN
52009: IFFALSE 52160
// begin if not mc_builders [ i ] then
52011: LD_EXP 20
52015: PUSH
52016: LD_VAR 0 2
52020: ARRAY
52021: NOT
52022: IFFALSE 52080
// begin SetTag ( j , 103 ) ;
52024: LD_VAR 0 3
52028: PPUSH
52029: LD_INT 103
52031: PPUSH
52032: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
52036: LD_ADDR_EXP 20
52040: PUSH
52041: LD_EXP 20
52045: PPUSH
52046: LD_VAR 0 2
52050: PUSH
52051: LD_EXP 20
52055: PUSH
52056: LD_VAR 0 2
52060: ARRAY
52061: PUSH
52062: LD_INT 1
52064: PLUS
52065: PUSH
52066: EMPTY
52067: LIST
52068: LIST
52069: PPUSH
52070: LD_VAR 0 3
52074: PPUSH
52075: CALL 9427 0 3
52079: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
52080: LD_VAR 0 3
52084: PPUSH
52085: CALL_OW 310
52089: IFFALSE 52100
// ComExitBuilding ( j ) ;
52091: LD_VAR 0 3
52095: PPUSH
52096: CALL_OW 122
// wait ( 3 ) ;
52100: LD_INT 3
52102: PPUSH
52103: CALL_OW 67
// if not mc_construct_list [ i ] then
52107: LD_EXP 21
52111: PUSH
52112: LD_VAR 0 2
52116: ARRAY
52117: NOT
52118: IFFALSE 52122
// break ;
52120: GO 52160
// if not HasTask ( j ) then
52122: LD_VAR 0 3
52126: PPUSH
52127: CALL_OW 314
52131: NOT
52132: IFFALSE 52158
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
52134: LD_VAR 0 3
52138: PPUSH
52139: LD_EXP 21
52143: PUSH
52144: LD_VAR 0 2
52148: ARRAY
52149: PUSH
52150: LD_INT 1
52152: ARRAY
52153: PPUSH
52154: CALL 12278 0 2
// end ;
52158: GO 52008
52160: POP
52161: POP
// end else
52162: GO 52967
// if mc_build_list [ i ] then
52164: LD_EXP 19
52168: PUSH
52169: LD_VAR 0 2
52173: ARRAY
52174: IFFALSE 52967
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52176: LD_ADDR_VAR 0 5
52180: PUSH
52181: LD_EXP 14
52185: PUSH
52186: LD_VAR 0 2
52190: ARRAY
52191: PPUSH
52192: LD_INT 2
52194: PUSH
52195: LD_INT 30
52197: PUSH
52198: LD_INT 0
52200: PUSH
52201: EMPTY
52202: LIST
52203: LIST
52204: PUSH
52205: LD_INT 30
52207: PUSH
52208: LD_INT 1
52210: PUSH
52211: EMPTY
52212: LIST
52213: LIST
52214: PUSH
52215: EMPTY
52216: LIST
52217: LIST
52218: LIST
52219: PPUSH
52220: CALL_OW 72
52224: ST_TO_ADDR
// if depot then
52225: LD_VAR 0 5
52229: IFFALSE 52247
// depot := depot [ 1 ] else
52231: LD_ADDR_VAR 0 5
52235: PUSH
52236: LD_VAR 0 5
52240: PUSH
52241: LD_INT 1
52243: ARRAY
52244: ST_TO_ADDR
52245: GO 52255
// depot := 0 ;
52247: LD_ADDR_VAR 0 5
52251: PUSH
52252: LD_INT 0
52254: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
52255: LD_EXP 19
52259: PUSH
52260: LD_VAR 0 2
52264: ARRAY
52265: PUSH
52266: LD_INT 1
52268: ARRAY
52269: PUSH
52270: LD_INT 1
52272: ARRAY
52273: PPUSH
52274: CALL 12108 0 1
52278: PUSH
52279: LD_EXP 14
52283: PUSH
52284: LD_VAR 0 2
52288: ARRAY
52289: PPUSH
52290: LD_INT 2
52292: PUSH
52293: LD_INT 30
52295: PUSH
52296: LD_INT 2
52298: PUSH
52299: EMPTY
52300: LIST
52301: LIST
52302: PUSH
52303: LD_INT 30
52305: PUSH
52306: LD_INT 3
52308: PUSH
52309: EMPTY
52310: LIST
52311: LIST
52312: PUSH
52313: EMPTY
52314: LIST
52315: LIST
52316: LIST
52317: PPUSH
52318: CALL_OW 72
52322: NOT
52323: AND
52324: IFFALSE 52429
// begin for j = 1 to mc_build_list [ i ] do
52326: LD_ADDR_VAR 0 3
52330: PUSH
52331: DOUBLE
52332: LD_INT 1
52334: DEC
52335: ST_TO_ADDR
52336: LD_EXP 19
52340: PUSH
52341: LD_VAR 0 2
52345: ARRAY
52346: PUSH
52347: FOR_TO
52348: IFFALSE 52427
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
52350: LD_EXP 19
52354: PUSH
52355: LD_VAR 0 2
52359: ARRAY
52360: PUSH
52361: LD_VAR 0 3
52365: ARRAY
52366: PUSH
52367: LD_INT 1
52369: ARRAY
52370: PUSH
52371: LD_INT 2
52373: EQUAL
52374: IFFALSE 52425
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
52376: LD_ADDR_EXP 19
52380: PUSH
52381: LD_EXP 19
52385: PPUSH
52386: LD_VAR 0 2
52390: PPUSH
52391: LD_EXP 19
52395: PUSH
52396: LD_VAR 0 2
52400: ARRAY
52401: PPUSH
52402: LD_VAR 0 3
52406: PPUSH
52407: LD_INT 1
52409: PPUSH
52410: LD_INT 0
52412: PPUSH
52413: CALL 8845 0 4
52417: PPUSH
52418: CALL_OW 1
52422: ST_TO_ADDR
// break ;
52423: GO 52427
// end ;
52425: GO 52347
52427: POP
52428: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
52429: LD_EXP 19
52433: PUSH
52434: LD_VAR 0 2
52438: ARRAY
52439: PUSH
52440: LD_INT 1
52442: ARRAY
52443: PUSH
52444: LD_INT 1
52446: ARRAY
52447: PUSH
52448: LD_INT 0
52450: EQUAL
52451: PUSH
52452: LD_VAR 0 5
52456: PUSH
52457: LD_VAR 0 5
52461: PPUSH
52462: LD_EXP 19
52466: PUSH
52467: LD_VAR 0 2
52471: ARRAY
52472: PUSH
52473: LD_INT 1
52475: ARRAY
52476: PUSH
52477: LD_INT 1
52479: ARRAY
52480: PPUSH
52481: LD_EXP 19
52485: PUSH
52486: LD_VAR 0 2
52490: ARRAY
52491: PUSH
52492: LD_INT 1
52494: ARRAY
52495: PUSH
52496: LD_INT 2
52498: ARRAY
52499: PPUSH
52500: LD_EXP 19
52504: PUSH
52505: LD_VAR 0 2
52509: ARRAY
52510: PUSH
52511: LD_INT 1
52513: ARRAY
52514: PUSH
52515: LD_INT 3
52517: ARRAY
52518: PPUSH
52519: LD_EXP 19
52523: PUSH
52524: LD_VAR 0 2
52528: ARRAY
52529: PUSH
52530: LD_INT 1
52532: ARRAY
52533: PUSH
52534: LD_INT 4
52536: ARRAY
52537: PPUSH
52538: CALL 16842 0 5
52542: AND
52543: OR
52544: IFFALSE 52825
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
52546: LD_ADDR_VAR 0 4
52550: PUSH
52551: LD_EXP 14
52555: PUSH
52556: LD_VAR 0 2
52560: ARRAY
52561: PPUSH
52562: LD_INT 25
52564: PUSH
52565: LD_INT 2
52567: PUSH
52568: EMPTY
52569: LIST
52570: LIST
52571: PPUSH
52572: CALL_OW 72
52576: PUSH
52577: LD_EXP 16
52581: PUSH
52582: LD_VAR 0 2
52586: ARRAY
52587: DIFF
52588: ST_TO_ADDR
// if not tmp then
52589: LD_VAR 0 4
52593: NOT
52594: IFFALSE 52598
// continue ;
52596: GO 51843
// for j in tmp do
52598: LD_ADDR_VAR 0 3
52602: PUSH
52603: LD_VAR 0 4
52607: PUSH
52608: FOR_IN
52609: IFFALSE 52821
// begin if not mc_builders [ i ] then
52611: LD_EXP 20
52615: PUSH
52616: LD_VAR 0 2
52620: ARRAY
52621: NOT
52622: IFFALSE 52680
// begin SetTag ( j , 103 ) ;
52624: LD_VAR 0 3
52628: PPUSH
52629: LD_INT 103
52631: PPUSH
52632: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
52636: LD_ADDR_EXP 20
52640: PUSH
52641: LD_EXP 20
52645: PPUSH
52646: LD_VAR 0 2
52650: PUSH
52651: LD_EXP 20
52655: PUSH
52656: LD_VAR 0 2
52660: ARRAY
52661: PUSH
52662: LD_INT 1
52664: PLUS
52665: PUSH
52666: EMPTY
52667: LIST
52668: LIST
52669: PPUSH
52670: LD_VAR 0 3
52674: PPUSH
52675: CALL 9427 0 3
52679: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
52680: LD_VAR 0 3
52684: PPUSH
52685: CALL_OW 310
52689: IFFALSE 52700
// ComExitBuilding ( j ) ;
52691: LD_VAR 0 3
52695: PPUSH
52696: CALL_OW 122
// wait ( 3 ) ;
52700: LD_INT 3
52702: PPUSH
52703: CALL_OW 67
// if not mc_build_list [ i ] then
52707: LD_EXP 19
52711: PUSH
52712: LD_VAR 0 2
52716: ARRAY
52717: NOT
52718: IFFALSE 52722
// break ;
52720: GO 52821
// if not HasTask ( j ) then
52722: LD_VAR 0 3
52726: PPUSH
52727: CALL_OW 314
52731: NOT
52732: IFFALSE 52819
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
52734: LD_VAR 0 3
52738: PPUSH
52739: LD_EXP 19
52743: PUSH
52744: LD_VAR 0 2
52748: ARRAY
52749: PUSH
52750: LD_INT 1
52752: ARRAY
52753: PUSH
52754: LD_INT 1
52756: ARRAY
52757: PPUSH
52758: LD_EXP 19
52762: PUSH
52763: LD_VAR 0 2
52767: ARRAY
52768: PUSH
52769: LD_INT 1
52771: ARRAY
52772: PUSH
52773: LD_INT 2
52775: ARRAY
52776: PPUSH
52777: LD_EXP 19
52781: PUSH
52782: LD_VAR 0 2
52786: ARRAY
52787: PUSH
52788: LD_INT 1
52790: ARRAY
52791: PUSH
52792: LD_INT 3
52794: ARRAY
52795: PPUSH
52796: LD_EXP 19
52800: PUSH
52801: LD_VAR 0 2
52805: ARRAY
52806: PUSH
52807: LD_INT 1
52809: ARRAY
52810: PUSH
52811: LD_INT 4
52813: ARRAY
52814: PPUSH
52815: CALL_OW 145
// end ;
52819: GO 52608
52821: POP
52822: POP
// end else
52823: GO 52967
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
52825: LD_EXP 14
52829: PUSH
52830: LD_VAR 0 2
52834: ARRAY
52835: PPUSH
52836: LD_EXP 19
52840: PUSH
52841: LD_VAR 0 2
52845: ARRAY
52846: PUSH
52847: LD_INT 1
52849: ARRAY
52850: PUSH
52851: LD_INT 1
52853: ARRAY
52854: PPUSH
52855: LD_EXP 19
52859: PUSH
52860: LD_VAR 0 2
52864: ARRAY
52865: PUSH
52866: LD_INT 1
52868: ARRAY
52869: PUSH
52870: LD_INT 2
52872: ARRAY
52873: PPUSH
52874: LD_EXP 19
52878: PUSH
52879: LD_VAR 0 2
52883: ARRAY
52884: PUSH
52885: LD_INT 1
52887: ARRAY
52888: PUSH
52889: LD_INT 3
52891: ARRAY
52892: PPUSH
52893: LD_EXP 19
52897: PUSH
52898: LD_VAR 0 2
52902: ARRAY
52903: PUSH
52904: LD_INT 1
52906: ARRAY
52907: PUSH
52908: LD_INT 4
52910: ARRAY
52911: PPUSH
52912: CALL 16178 0 5
52916: NOT
52917: IFFALSE 52967
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
52919: LD_ADDR_EXP 19
52923: PUSH
52924: LD_EXP 19
52928: PPUSH
52929: LD_VAR 0 2
52933: PPUSH
52934: LD_EXP 19
52938: PUSH
52939: LD_VAR 0 2
52943: ARRAY
52944: PPUSH
52945: LD_INT 1
52947: PPUSH
52948: LD_INT 1
52950: NEG
52951: PPUSH
52952: LD_INT 0
52954: PPUSH
52955: CALL 8845 0 4
52959: PPUSH
52960: CALL_OW 1
52964: ST_TO_ADDR
// continue ;
52965: GO 51843
// end ; end ; end ;
52967: GO 51843
52969: POP
52970: POP
// end ;
52971: LD_VAR 0 1
52975: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
52976: LD_INT 0
52978: PPUSH
52979: PPUSH
52980: PPUSH
52981: PPUSH
52982: PPUSH
52983: PPUSH
// if not mc_bases then
52984: LD_EXP 14
52988: NOT
52989: IFFALSE 52993
// exit ;
52991: GO 53420
// for i = 1 to mc_bases do
52993: LD_ADDR_VAR 0 2
52997: PUSH
52998: DOUBLE
52999: LD_INT 1
53001: DEC
53002: ST_TO_ADDR
53003: LD_EXP 14
53007: PUSH
53008: FOR_TO
53009: IFFALSE 53418
// begin tmp := mc_build_upgrade [ i ] ;
53011: LD_ADDR_VAR 0 4
53015: PUSH
53016: LD_EXP 46
53020: PUSH
53021: LD_VAR 0 2
53025: ARRAY
53026: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
53027: LD_ADDR_VAR 0 6
53031: PUSH
53032: LD_EXP 47
53036: PUSH
53037: LD_VAR 0 2
53041: ARRAY
53042: PPUSH
53043: LD_INT 2
53045: PUSH
53046: LD_INT 30
53048: PUSH
53049: LD_INT 6
53051: PUSH
53052: EMPTY
53053: LIST
53054: LIST
53055: PUSH
53056: LD_INT 30
53058: PUSH
53059: LD_INT 7
53061: PUSH
53062: EMPTY
53063: LIST
53064: LIST
53065: PUSH
53066: EMPTY
53067: LIST
53068: LIST
53069: LIST
53070: PPUSH
53071: CALL_OW 72
53075: ST_TO_ADDR
// if not tmp and not lab then
53076: LD_VAR 0 4
53080: NOT
53081: PUSH
53082: LD_VAR 0 6
53086: NOT
53087: AND
53088: IFFALSE 53092
// continue ;
53090: GO 53008
// if tmp then
53092: LD_VAR 0 4
53096: IFFALSE 53216
// for j in tmp do
53098: LD_ADDR_VAR 0 3
53102: PUSH
53103: LD_VAR 0 4
53107: PUSH
53108: FOR_IN
53109: IFFALSE 53214
// begin if UpgradeCost ( j ) then
53111: LD_VAR 0 3
53115: PPUSH
53116: CALL 15838 0 1
53120: IFFALSE 53212
// begin ComUpgrade ( j ) ;
53122: LD_VAR 0 3
53126: PPUSH
53127: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
53131: LD_ADDR_EXP 46
53135: PUSH
53136: LD_EXP 46
53140: PPUSH
53141: LD_VAR 0 2
53145: PPUSH
53146: LD_EXP 46
53150: PUSH
53151: LD_VAR 0 2
53155: ARRAY
53156: PUSH
53157: LD_VAR 0 3
53161: DIFF
53162: PPUSH
53163: CALL_OW 1
53167: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
53168: LD_ADDR_EXP 21
53172: PUSH
53173: LD_EXP 21
53177: PPUSH
53178: LD_VAR 0 2
53182: PUSH
53183: LD_EXP 21
53187: PUSH
53188: LD_VAR 0 2
53192: ARRAY
53193: PUSH
53194: LD_INT 1
53196: PLUS
53197: PUSH
53198: EMPTY
53199: LIST
53200: LIST
53201: PPUSH
53202: LD_VAR 0 3
53206: PPUSH
53207: CALL 9427 0 3
53211: ST_TO_ADDR
// end ; end ;
53212: GO 53108
53214: POP
53215: POP
// if not lab or not mc_lab_upgrade [ i ] then
53216: LD_VAR 0 6
53220: NOT
53221: PUSH
53222: LD_EXP 48
53226: PUSH
53227: LD_VAR 0 2
53231: ARRAY
53232: NOT
53233: OR
53234: IFFALSE 53238
// continue ;
53236: GO 53008
// for j in lab do
53238: LD_ADDR_VAR 0 3
53242: PUSH
53243: LD_VAR 0 6
53247: PUSH
53248: FOR_IN
53249: IFFALSE 53414
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
53251: LD_VAR 0 3
53255: PPUSH
53256: CALL_OW 266
53260: PUSH
53261: LD_INT 6
53263: PUSH
53264: LD_INT 7
53266: PUSH
53267: EMPTY
53268: LIST
53269: LIST
53270: IN
53271: PUSH
53272: LD_VAR 0 3
53276: PPUSH
53277: CALL_OW 461
53281: PUSH
53282: LD_INT 1
53284: NONEQUAL
53285: AND
53286: IFFALSE 53412
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
53288: LD_VAR 0 3
53292: PPUSH
53293: LD_EXP 48
53297: PUSH
53298: LD_VAR 0 2
53302: ARRAY
53303: PUSH
53304: LD_INT 1
53306: ARRAY
53307: PPUSH
53308: CALL 16043 0 2
53312: IFFALSE 53412
// begin ComCancel ( j ) ;
53314: LD_VAR 0 3
53318: PPUSH
53319: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
53323: LD_VAR 0 3
53327: PPUSH
53328: LD_EXP 48
53332: PUSH
53333: LD_VAR 0 2
53337: ARRAY
53338: PUSH
53339: LD_INT 1
53341: ARRAY
53342: PPUSH
53343: CALL_OW 207
// if not j in mc_construct_list [ i ] then
53347: LD_VAR 0 3
53351: PUSH
53352: LD_EXP 21
53356: PUSH
53357: LD_VAR 0 2
53361: ARRAY
53362: IN
53363: NOT
53364: IFFALSE 53410
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
53366: LD_ADDR_EXP 21
53370: PUSH
53371: LD_EXP 21
53375: PPUSH
53376: LD_VAR 0 2
53380: PUSH
53381: LD_EXP 21
53385: PUSH
53386: LD_VAR 0 2
53390: ARRAY
53391: PUSH
53392: LD_INT 1
53394: PLUS
53395: PUSH
53396: EMPTY
53397: LIST
53398: LIST
53399: PPUSH
53400: LD_VAR 0 3
53404: PPUSH
53405: CALL 9427 0 3
53409: ST_TO_ADDR
// break ;
53410: GO 53414
// end ; end ; end ;
53412: GO 53248
53414: POP
53415: POP
// end ;
53416: GO 53008
53418: POP
53419: POP
// end ;
53420: LD_VAR 0 1
53424: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
53425: LD_INT 0
53427: PPUSH
53428: PPUSH
53429: PPUSH
53430: PPUSH
53431: PPUSH
53432: PPUSH
53433: PPUSH
53434: PPUSH
53435: PPUSH
// if not mc_bases then
53436: LD_EXP 14
53440: NOT
53441: IFFALSE 53445
// exit ;
53443: GO 53850
// for i = 1 to mc_bases do
53445: LD_ADDR_VAR 0 2
53449: PUSH
53450: DOUBLE
53451: LD_INT 1
53453: DEC
53454: ST_TO_ADDR
53455: LD_EXP 14
53459: PUSH
53460: FOR_TO
53461: IFFALSE 53848
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
53463: LD_EXP 22
53467: PUSH
53468: LD_VAR 0 2
53472: ARRAY
53473: NOT
53474: PUSH
53475: LD_EXP 14
53479: PUSH
53480: LD_VAR 0 2
53484: ARRAY
53485: PPUSH
53486: LD_INT 30
53488: PUSH
53489: LD_INT 3
53491: PUSH
53492: EMPTY
53493: LIST
53494: LIST
53495: PPUSH
53496: CALL_OW 72
53500: NOT
53501: OR
53502: IFFALSE 53506
// continue ;
53504: GO 53460
// busy := false ;
53506: LD_ADDR_VAR 0 8
53510: PUSH
53511: LD_INT 0
53513: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53514: LD_ADDR_VAR 0 4
53518: PUSH
53519: LD_EXP 14
53523: PUSH
53524: LD_VAR 0 2
53528: ARRAY
53529: PPUSH
53530: LD_INT 30
53532: PUSH
53533: LD_INT 3
53535: PUSH
53536: EMPTY
53537: LIST
53538: LIST
53539: PPUSH
53540: CALL_OW 72
53544: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
53545: LD_ADDR_VAR 0 6
53549: PUSH
53550: LD_EXP 22
53554: PUSH
53555: LD_VAR 0 2
53559: ARRAY
53560: PPUSH
53561: LD_INT 2
53563: PUSH
53564: LD_INT 30
53566: PUSH
53567: LD_INT 32
53569: PUSH
53570: EMPTY
53571: LIST
53572: LIST
53573: PUSH
53574: LD_INT 30
53576: PUSH
53577: LD_INT 33
53579: PUSH
53580: EMPTY
53581: LIST
53582: LIST
53583: PUSH
53584: EMPTY
53585: LIST
53586: LIST
53587: LIST
53588: PPUSH
53589: CALL_OW 72
53593: ST_TO_ADDR
// if not t then
53594: LD_VAR 0 6
53598: NOT
53599: IFFALSE 53603
// continue ;
53601: GO 53460
// for j in tmp do
53603: LD_ADDR_VAR 0 3
53607: PUSH
53608: LD_VAR 0 4
53612: PUSH
53613: FOR_IN
53614: IFFALSE 53644
// if not BuildingStatus ( j ) = bs_idle then
53616: LD_VAR 0 3
53620: PPUSH
53621: CALL_OW 461
53625: PUSH
53626: LD_INT 2
53628: EQUAL
53629: NOT
53630: IFFALSE 53642
// begin busy := true ;
53632: LD_ADDR_VAR 0 8
53636: PUSH
53637: LD_INT 1
53639: ST_TO_ADDR
// break ;
53640: GO 53644
// end ;
53642: GO 53613
53644: POP
53645: POP
// if busy then
53646: LD_VAR 0 8
53650: IFFALSE 53654
// continue ;
53652: GO 53460
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
53654: LD_ADDR_VAR 0 7
53658: PUSH
53659: LD_VAR 0 6
53663: PPUSH
53664: LD_INT 35
53666: PUSH
53667: LD_INT 0
53669: PUSH
53670: EMPTY
53671: LIST
53672: LIST
53673: PPUSH
53674: CALL_OW 72
53678: ST_TO_ADDR
// if tw then
53679: LD_VAR 0 7
53683: IFFALSE 53760
// begin tw := tw [ 1 ] ;
53685: LD_ADDR_VAR 0 7
53689: PUSH
53690: LD_VAR 0 7
53694: PUSH
53695: LD_INT 1
53697: ARRAY
53698: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
53699: LD_ADDR_VAR 0 9
53703: PUSH
53704: LD_VAR 0 7
53708: PPUSH
53709: LD_EXP 39
53713: PUSH
53714: LD_VAR 0 2
53718: ARRAY
53719: PPUSH
53720: CALL 14397 0 2
53724: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
53725: LD_EXP 53
53729: PUSH
53730: LD_VAR 0 2
53734: ARRAY
53735: IFFALSE 53758
// if not weapon in mc_allowed_tower_weapons [ i ] then
53737: LD_VAR 0 9
53741: PUSH
53742: LD_EXP 53
53746: PUSH
53747: LD_VAR 0 2
53751: ARRAY
53752: IN
53753: NOT
53754: IFFALSE 53758
// continue ;
53756: GO 53460
// end else
53758: GO 53823
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
53760: LD_ADDR_VAR 0 5
53764: PUSH
53765: LD_EXP 22
53769: PUSH
53770: LD_VAR 0 2
53774: ARRAY
53775: PPUSH
53776: LD_VAR 0 4
53780: PPUSH
53781: CALL 40018 0 2
53785: ST_TO_ADDR
// if not tmp2 then
53786: LD_VAR 0 5
53790: NOT
53791: IFFALSE 53795
// continue ;
53793: GO 53460
// tw := tmp2 [ 1 ] ;
53795: LD_ADDR_VAR 0 7
53799: PUSH
53800: LD_VAR 0 5
53804: PUSH
53805: LD_INT 1
53807: ARRAY
53808: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
53809: LD_ADDR_VAR 0 9
53813: PUSH
53814: LD_VAR 0 5
53818: PUSH
53819: LD_INT 2
53821: ARRAY
53822: ST_TO_ADDR
// end ; if not weapon then
53823: LD_VAR 0 9
53827: NOT
53828: IFFALSE 53832
// continue ;
53830: GO 53460
// ComPlaceWeapon ( tw , weapon ) ;
53832: LD_VAR 0 7
53836: PPUSH
53837: LD_VAR 0 9
53841: PPUSH
53842: CALL_OW 148
// end ;
53846: GO 53460
53848: POP
53849: POP
// end ;
53850: LD_VAR 0 1
53854: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
53855: LD_INT 0
53857: PPUSH
53858: PPUSH
53859: PPUSH
53860: PPUSH
53861: PPUSH
53862: PPUSH
// if not mc_bases then
53863: LD_EXP 14
53867: NOT
53868: IFFALSE 53872
// exit ;
53870: GO 54648
// for i = 1 to mc_bases do
53872: LD_ADDR_VAR 0 2
53876: PUSH
53877: DOUBLE
53878: LD_INT 1
53880: DEC
53881: ST_TO_ADDR
53882: LD_EXP 14
53886: PUSH
53887: FOR_TO
53888: IFFALSE 54646
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
53890: LD_EXP 27
53894: PUSH
53895: LD_VAR 0 2
53899: ARRAY
53900: NOT
53901: PUSH
53902: LD_EXP 27
53906: PUSH
53907: LD_VAR 0 2
53911: ARRAY
53912: PUSH
53913: LD_EXP 28
53917: PUSH
53918: LD_VAR 0 2
53922: ARRAY
53923: EQUAL
53924: OR
53925: PUSH
53926: LD_EXP 37
53930: PUSH
53931: LD_VAR 0 2
53935: ARRAY
53936: OR
53937: IFFALSE 53941
// continue ;
53939: GO 53887
// if mc_miners [ i ] then
53941: LD_EXP 28
53945: PUSH
53946: LD_VAR 0 2
53950: ARRAY
53951: IFFALSE 54333
// begin for j = mc_miners [ i ] downto 1 do
53953: LD_ADDR_VAR 0 3
53957: PUSH
53958: DOUBLE
53959: LD_EXP 28
53963: PUSH
53964: LD_VAR 0 2
53968: ARRAY
53969: INC
53970: ST_TO_ADDR
53971: LD_INT 1
53973: PUSH
53974: FOR_DOWNTO
53975: IFFALSE 54331
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
53977: LD_EXP 28
53981: PUSH
53982: LD_VAR 0 2
53986: ARRAY
53987: PUSH
53988: LD_VAR 0 3
53992: ARRAY
53993: PPUSH
53994: CALL_OW 301
53998: PUSH
53999: LD_EXP 28
54003: PUSH
54004: LD_VAR 0 2
54008: ARRAY
54009: PUSH
54010: LD_VAR 0 3
54014: ARRAY
54015: PPUSH
54016: CALL_OW 257
54020: PUSH
54021: LD_INT 1
54023: NONEQUAL
54024: OR
54025: IFFALSE 54088
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
54027: LD_ADDR_VAR 0 5
54031: PUSH
54032: LD_EXP 28
54036: PUSH
54037: LD_VAR 0 2
54041: ARRAY
54042: PUSH
54043: LD_EXP 28
54047: PUSH
54048: LD_VAR 0 2
54052: ARRAY
54053: PUSH
54054: LD_VAR 0 3
54058: ARRAY
54059: DIFF
54060: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
54061: LD_ADDR_EXP 28
54065: PUSH
54066: LD_EXP 28
54070: PPUSH
54071: LD_VAR 0 2
54075: PPUSH
54076: LD_VAR 0 5
54080: PPUSH
54081: CALL_OW 1
54085: ST_TO_ADDR
// continue ;
54086: GO 53974
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
54088: LD_EXP 28
54092: PUSH
54093: LD_VAR 0 2
54097: ARRAY
54098: PUSH
54099: LD_VAR 0 3
54103: ARRAY
54104: PPUSH
54105: CALL_OW 257
54109: PUSH
54110: LD_INT 1
54112: EQUAL
54113: PUSH
54114: LD_EXP 28
54118: PUSH
54119: LD_VAR 0 2
54123: ARRAY
54124: PUSH
54125: LD_VAR 0 3
54129: ARRAY
54130: PPUSH
54131: CALL_OW 459
54135: NOT
54136: AND
54137: PUSH
54138: LD_EXP 28
54142: PUSH
54143: LD_VAR 0 2
54147: ARRAY
54148: PUSH
54149: LD_VAR 0 3
54153: ARRAY
54154: PPUSH
54155: CALL_OW 314
54159: NOT
54160: AND
54161: IFFALSE 54329
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
54163: LD_EXP 28
54167: PUSH
54168: LD_VAR 0 2
54172: ARRAY
54173: PUSH
54174: LD_VAR 0 3
54178: ARRAY
54179: PPUSH
54180: CALL_OW 310
54184: IFFALSE 54207
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
54186: LD_EXP 28
54190: PUSH
54191: LD_VAR 0 2
54195: ARRAY
54196: PUSH
54197: LD_VAR 0 3
54201: ARRAY
54202: PPUSH
54203: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
54207: LD_EXP 28
54211: PUSH
54212: LD_VAR 0 2
54216: ARRAY
54217: PUSH
54218: LD_VAR 0 3
54222: ARRAY
54223: PPUSH
54224: CALL_OW 314
54228: NOT
54229: IFFALSE 54329
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
54231: LD_EXP 28
54235: PUSH
54236: LD_VAR 0 2
54240: ARRAY
54241: PUSH
54242: LD_VAR 0 3
54246: ARRAY
54247: PPUSH
54248: LD_EXP 27
54252: PUSH
54253: LD_VAR 0 2
54257: ARRAY
54258: PUSH
54259: LD_VAR 0 3
54263: PUSH
54264: LD_EXP 27
54268: PUSH
54269: LD_VAR 0 2
54273: ARRAY
54274: MOD
54275: PUSH
54276: LD_INT 1
54278: PLUS
54279: ARRAY
54280: PUSH
54281: LD_INT 1
54283: ARRAY
54284: PPUSH
54285: LD_EXP 27
54289: PUSH
54290: LD_VAR 0 2
54294: ARRAY
54295: PUSH
54296: LD_VAR 0 3
54300: PUSH
54301: LD_EXP 27
54305: PUSH
54306: LD_VAR 0 2
54310: ARRAY
54311: MOD
54312: PUSH
54313: LD_INT 1
54315: PLUS
54316: ARRAY
54317: PUSH
54318: LD_INT 2
54320: ARRAY
54321: PPUSH
54322: LD_INT 0
54324: PPUSH
54325: CALL_OW 193
// end ; end ;
54329: GO 53974
54331: POP
54332: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
54333: LD_ADDR_VAR 0 5
54337: PUSH
54338: LD_EXP 14
54342: PUSH
54343: LD_VAR 0 2
54347: ARRAY
54348: PPUSH
54349: LD_INT 2
54351: PUSH
54352: LD_INT 30
54354: PUSH
54355: LD_INT 4
54357: PUSH
54358: EMPTY
54359: LIST
54360: LIST
54361: PUSH
54362: LD_INT 30
54364: PUSH
54365: LD_INT 5
54367: PUSH
54368: EMPTY
54369: LIST
54370: LIST
54371: PUSH
54372: LD_INT 30
54374: PUSH
54375: LD_INT 32
54377: PUSH
54378: EMPTY
54379: LIST
54380: LIST
54381: PUSH
54382: EMPTY
54383: LIST
54384: LIST
54385: LIST
54386: LIST
54387: PPUSH
54388: CALL_OW 72
54392: ST_TO_ADDR
// if not tmp then
54393: LD_VAR 0 5
54397: NOT
54398: IFFALSE 54402
// continue ;
54400: GO 53887
// list := [ ] ;
54402: LD_ADDR_VAR 0 6
54406: PUSH
54407: EMPTY
54408: ST_TO_ADDR
// for j in tmp do
54409: LD_ADDR_VAR 0 3
54413: PUSH
54414: LD_VAR 0 5
54418: PUSH
54419: FOR_IN
54420: IFFALSE 54489
// begin for k in UnitsInside ( j ) do
54422: LD_ADDR_VAR 0 4
54426: PUSH
54427: LD_VAR 0 3
54431: PPUSH
54432: CALL_OW 313
54436: PUSH
54437: FOR_IN
54438: IFFALSE 54485
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
54440: LD_VAR 0 4
54444: PPUSH
54445: CALL_OW 257
54449: PUSH
54450: LD_INT 1
54452: EQUAL
54453: PUSH
54454: LD_VAR 0 4
54458: PPUSH
54459: CALL_OW 459
54463: NOT
54464: AND
54465: IFFALSE 54483
// list := list ^ k ;
54467: LD_ADDR_VAR 0 6
54471: PUSH
54472: LD_VAR 0 6
54476: PUSH
54477: LD_VAR 0 4
54481: ADD
54482: ST_TO_ADDR
54483: GO 54437
54485: POP
54486: POP
// end ;
54487: GO 54419
54489: POP
54490: POP
// list := list diff mc_miners [ i ] ;
54491: LD_ADDR_VAR 0 6
54495: PUSH
54496: LD_VAR 0 6
54500: PUSH
54501: LD_EXP 28
54505: PUSH
54506: LD_VAR 0 2
54510: ARRAY
54511: DIFF
54512: ST_TO_ADDR
// if not list then
54513: LD_VAR 0 6
54517: NOT
54518: IFFALSE 54522
// continue ;
54520: GO 53887
// k := mc_mines [ i ] - mc_miners [ i ] ;
54522: LD_ADDR_VAR 0 4
54526: PUSH
54527: LD_EXP 27
54531: PUSH
54532: LD_VAR 0 2
54536: ARRAY
54537: PUSH
54538: LD_EXP 28
54542: PUSH
54543: LD_VAR 0 2
54547: ARRAY
54548: MINUS
54549: ST_TO_ADDR
// if k > list then
54550: LD_VAR 0 4
54554: PUSH
54555: LD_VAR 0 6
54559: GREATER
54560: IFFALSE 54572
// k := list ;
54562: LD_ADDR_VAR 0 4
54566: PUSH
54567: LD_VAR 0 6
54571: ST_TO_ADDR
// for j = 1 to k do
54572: LD_ADDR_VAR 0 3
54576: PUSH
54577: DOUBLE
54578: LD_INT 1
54580: DEC
54581: ST_TO_ADDR
54582: LD_VAR 0 4
54586: PUSH
54587: FOR_TO
54588: IFFALSE 54642
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
54590: LD_ADDR_EXP 28
54594: PUSH
54595: LD_EXP 28
54599: PPUSH
54600: LD_VAR 0 2
54604: PUSH
54605: LD_EXP 28
54609: PUSH
54610: LD_VAR 0 2
54614: ARRAY
54615: PUSH
54616: LD_INT 1
54618: PLUS
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: PPUSH
54624: LD_VAR 0 6
54628: PUSH
54629: LD_VAR 0 3
54633: ARRAY
54634: PPUSH
54635: CALL 9427 0 3
54639: ST_TO_ADDR
54640: GO 54587
54642: POP
54643: POP
// end ;
54644: GO 53887
54646: POP
54647: POP
// end ;
54648: LD_VAR 0 1
54652: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
54653: LD_INT 0
54655: PPUSH
54656: PPUSH
54657: PPUSH
54658: PPUSH
54659: PPUSH
54660: PPUSH
54661: PPUSH
54662: PPUSH
54663: PPUSH
54664: PPUSH
// if not mc_bases then
54665: LD_EXP 14
54669: NOT
54670: IFFALSE 54674
// exit ;
54672: GO 56424
// for i = 1 to mc_bases do
54674: LD_ADDR_VAR 0 2
54678: PUSH
54679: DOUBLE
54680: LD_INT 1
54682: DEC
54683: ST_TO_ADDR
54684: LD_EXP 14
54688: PUSH
54689: FOR_TO
54690: IFFALSE 56422
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
54692: LD_EXP 14
54696: PUSH
54697: LD_VAR 0 2
54701: ARRAY
54702: NOT
54703: PUSH
54704: LD_EXP 21
54708: PUSH
54709: LD_VAR 0 2
54713: ARRAY
54714: OR
54715: IFFALSE 54719
// continue ;
54717: GO 54689
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
54719: LD_EXP 30
54723: PUSH
54724: LD_VAR 0 2
54728: ARRAY
54729: NOT
54730: PUSH
54731: LD_EXP 31
54735: PUSH
54736: LD_VAR 0 2
54740: ARRAY
54741: AND
54742: IFFALSE 54780
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54744: LD_ADDR_EXP 31
54748: PUSH
54749: LD_EXP 31
54753: PPUSH
54754: LD_VAR 0 2
54758: PPUSH
54759: EMPTY
54760: PPUSH
54761: CALL_OW 1
54765: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
54766: LD_VAR 0 2
54770: PPUSH
54771: LD_INT 107
54773: PPUSH
54774: CALL 45628 0 2
// continue ;
54778: GO 54689
// end ; target := [ ] ;
54780: LD_ADDR_VAR 0 6
54784: PUSH
54785: EMPTY
54786: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
54787: LD_ADDR_VAR 0 3
54791: PUSH
54792: DOUBLE
54793: LD_EXP 30
54797: PUSH
54798: LD_VAR 0 2
54802: ARRAY
54803: INC
54804: ST_TO_ADDR
54805: LD_INT 1
54807: PUSH
54808: FOR_DOWNTO
54809: IFFALSE 55069
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
54811: LD_EXP 30
54815: PUSH
54816: LD_VAR 0 2
54820: ARRAY
54821: PUSH
54822: LD_VAR 0 3
54826: ARRAY
54827: PUSH
54828: LD_INT 2
54830: ARRAY
54831: PPUSH
54832: LD_EXP 30
54836: PUSH
54837: LD_VAR 0 2
54841: ARRAY
54842: PUSH
54843: LD_VAR 0 3
54847: ARRAY
54848: PUSH
54849: LD_INT 3
54851: ARRAY
54852: PPUSH
54853: CALL_OW 488
54857: PUSH
54858: LD_EXP 30
54862: PUSH
54863: LD_VAR 0 2
54867: ARRAY
54868: PUSH
54869: LD_VAR 0 3
54873: ARRAY
54874: PUSH
54875: LD_INT 2
54877: ARRAY
54878: PPUSH
54879: LD_EXP 30
54883: PUSH
54884: LD_VAR 0 2
54888: ARRAY
54889: PUSH
54890: LD_VAR 0 3
54894: ARRAY
54895: PUSH
54896: LD_INT 3
54898: ARRAY
54899: PPUSH
54900: CALL_OW 284
54904: PUSH
54905: LD_INT 0
54907: EQUAL
54908: AND
54909: IFFALSE 54964
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
54911: LD_ADDR_VAR 0 5
54915: PUSH
54916: LD_EXP 30
54920: PUSH
54921: LD_VAR 0 2
54925: ARRAY
54926: PPUSH
54927: LD_VAR 0 3
54931: PPUSH
54932: CALL_OW 3
54936: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
54937: LD_ADDR_EXP 30
54941: PUSH
54942: LD_EXP 30
54946: PPUSH
54947: LD_VAR 0 2
54951: PPUSH
54952: LD_VAR 0 5
54956: PPUSH
54957: CALL_OW 1
54961: ST_TO_ADDR
// continue ;
54962: GO 54808
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
54964: LD_EXP 14
54968: PUSH
54969: LD_VAR 0 2
54973: ARRAY
54974: PUSH
54975: LD_INT 1
54977: ARRAY
54978: PPUSH
54979: CALL_OW 255
54983: PPUSH
54984: LD_EXP 30
54988: PUSH
54989: LD_VAR 0 2
54993: ARRAY
54994: PUSH
54995: LD_VAR 0 3
54999: ARRAY
55000: PUSH
55001: LD_INT 2
55003: ARRAY
55004: PPUSH
55005: LD_EXP 30
55009: PUSH
55010: LD_VAR 0 2
55014: ARRAY
55015: PUSH
55016: LD_VAR 0 3
55020: ARRAY
55021: PUSH
55022: LD_INT 3
55024: ARRAY
55025: PPUSH
55026: LD_INT 30
55028: PPUSH
55029: CALL 10323 0 4
55033: PUSH
55034: LD_INT 4
55036: ARRAY
55037: PUSH
55038: LD_INT 0
55040: EQUAL
55041: IFFALSE 55067
// begin target := mc_crates [ i ] [ j ] ;
55043: LD_ADDR_VAR 0 6
55047: PUSH
55048: LD_EXP 30
55052: PUSH
55053: LD_VAR 0 2
55057: ARRAY
55058: PUSH
55059: LD_VAR 0 3
55063: ARRAY
55064: ST_TO_ADDR
// break ;
55065: GO 55069
// end ; end ;
55067: GO 54808
55069: POP
55070: POP
// if not target then
55071: LD_VAR 0 6
55075: NOT
55076: IFFALSE 55080
// continue ;
55078: GO 54689
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
55080: LD_ADDR_VAR 0 7
55084: PUSH
55085: LD_EXP 33
55089: PUSH
55090: LD_VAR 0 2
55094: ARRAY
55095: PPUSH
55096: LD_INT 2
55098: PUSH
55099: LD_INT 3
55101: PUSH
55102: LD_INT 58
55104: PUSH
55105: EMPTY
55106: LIST
55107: PUSH
55108: EMPTY
55109: LIST
55110: LIST
55111: PUSH
55112: LD_INT 61
55114: PUSH
55115: EMPTY
55116: LIST
55117: PUSH
55118: LD_INT 33
55120: PUSH
55121: LD_INT 5
55123: PUSH
55124: EMPTY
55125: LIST
55126: LIST
55127: PUSH
55128: LD_INT 33
55130: PUSH
55131: LD_INT 3
55133: PUSH
55134: EMPTY
55135: LIST
55136: LIST
55137: PUSH
55138: EMPTY
55139: LIST
55140: LIST
55141: LIST
55142: LIST
55143: LIST
55144: PUSH
55145: LD_INT 2
55147: PUSH
55148: LD_INT 34
55150: PUSH
55151: LD_INT 32
55153: PUSH
55154: EMPTY
55155: LIST
55156: LIST
55157: PUSH
55158: LD_INT 34
55160: PUSH
55161: LD_INT 51
55163: PUSH
55164: EMPTY
55165: LIST
55166: LIST
55167: PUSH
55168: LD_INT 34
55170: PUSH
55171: LD_INT 12
55173: PUSH
55174: EMPTY
55175: LIST
55176: LIST
55177: PUSH
55178: EMPTY
55179: LIST
55180: LIST
55181: LIST
55182: LIST
55183: PUSH
55184: EMPTY
55185: LIST
55186: LIST
55187: PPUSH
55188: CALL_OW 72
55192: ST_TO_ADDR
// if not cargo then
55193: LD_VAR 0 7
55197: NOT
55198: IFFALSE 55841
// begin if mc_crates_collector [ i ] < 5 then
55200: LD_EXP 31
55204: PUSH
55205: LD_VAR 0 2
55209: ARRAY
55210: PUSH
55211: LD_INT 5
55213: LESS
55214: IFFALSE 55580
// begin if mc_ape [ i ] then
55216: LD_EXP 43
55220: PUSH
55221: LD_VAR 0 2
55225: ARRAY
55226: IFFALSE 55273
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
55228: LD_ADDR_VAR 0 5
55232: PUSH
55233: LD_EXP 43
55237: PUSH
55238: LD_VAR 0 2
55242: ARRAY
55243: PPUSH
55244: LD_INT 25
55246: PUSH
55247: LD_INT 16
55249: PUSH
55250: EMPTY
55251: LIST
55252: LIST
55253: PUSH
55254: LD_INT 24
55256: PUSH
55257: LD_INT 750
55259: PUSH
55260: EMPTY
55261: LIST
55262: LIST
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: PPUSH
55268: CALL_OW 72
55272: ST_TO_ADDR
// if not tmp then
55273: LD_VAR 0 5
55277: NOT
55278: IFFALSE 55325
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
55280: LD_ADDR_VAR 0 5
55284: PUSH
55285: LD_EXP 14
55289: PUSH
55290: LD_VAR 0 2
55294: ARRAY
55295: PPUSH
55296: LD_INT 25
55298: PUSH
55299: LD_INT 2
55301: PUSH
55302: EMPTY
55303: LIST
55304: LIST
55305: PUSH
55306: LD_INT 24
55308: PUSH
55309: LD_INT 750
55311: PUSH
55312: EMPTY
55313: LIST
55314: LIST
55315: PUSH
55316: EMPTY
55317: LIST
55318: LIST
55319: PPUSH
55320: CALL_OW 72
55324: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
55325: LD_EXP 43
55329: PUSH
55330: LD_VAR 0 2
55334: ARRAY
55335: PUSH
55336: LD_EXP 14
55340: PUSH
55341: LD_VAR 0 2
55345: ARRAY
55346: PPUSH
55347: LD_INT 25
55349: PUSH
55350: LD_INT 2
55352: PUSH
55353: EMPTY
55354: LIST
55355: LIST
55356: PUSH
55357: LD_INT 24
55359: PUSH
55360: LD_INT 750
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: PPUSH
55371: CALL_OW 72
55375: AND
55376: PUSH
55377: LD_VAR 0 5
55381: PUSH
55382: LD_INT 5
55384: LESS
55385: AND
55386: IFFALSE 55468
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
55388: LD_ADDR_VAR 0 3
55392: PUSH
55393: LD_EXP 14
55397: PUSH
55398: LD_VAR 0 2
55402: ARRAY
55403: PPUSH
55404: LD_INT 25
55406: PUSH
55407: LD_INT 2
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: PUSH
55414: LD_INT 24
55416: PUSH
55417: LD_INT 750
55419: PUSH
55420: EMPTY
55421: LIST
55422: LIST
55423: PUSH
55424: EMPTY
55425: LIST
55426: LIST
55427: PPUSH
55428: CALL_OW 72
55432: PUSH
55433: FOR_IN
55434: IFFALSE 55466
// begin tmp := tmp union j ;
55436: LD_ADDR_VAR 0 5
55440: PUSH
55441: LD_VAR 0 5
55445: PUSH
55446: LD_VAR 0 3
55450: UNION
55451: ST_TO_ADDR
// if tmp >= 5 then
55452: LD_VAR 0 5
55456: PUSH
55457: LD_INT 5
55459: GREATEREQUAL
55460: IFFALSE 55464
// break ;
55462: GO 55466
// end ;
55464: GO 55433
55466: POP
55467: POP
// end ; if not tmp then
55468: LD_VAR 0 5
55472: NOT
55473: IFFALSE 55477
// continue ;
55475: GO 54689
// for j in tmp do
55477: LD_ADDR_VAR 0 3
55481: PUSH
55482: LD_VAR 0 5
55486: PUSH
55487: FOR_IN
55488: IFFALSE 55578
// if not GetTag ( j ) then
55490: LD_VAR 0 3
55494: PPUSH
55495: CALL_OW 110
55499: NOT
55500: IFFALSE 55576
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
55502: LD_ADDR_EXP 31
55506: PUSH
55507: LD_EXP 31
55511: PPUSH
55512: LD_VAR 0 2
55516: PUSH
55517: LD_EXP 31
55521: PUSH
55522: LD_VAR 0 2
55526: ARRAY
55527: PUSH
55528: LD_INT 1
55530: PLUS
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: PPUSH
55536: LD_VAR 0 3
55540: PPUSH
55541: CALL 9427 0 3
55545: ST_TO_ADDR
// SetTag ( j , 107 ) ;
55546: LD_VAR 0 3
55550: PPUSH
55551: LD_INT 107
55553: PPUSH
55554: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
55558: LD_EXP 31
55562: PUSH
55563: LD_VAR 0 2
55567: ARRAY
55568: PUSH
55569: LD_INT 5
55571: GREATEREQUAL
55572: IFFALSE 55576
// break ;
55574: GO 55578
// end ;
55576: GO 55487
55578: POP
55579: POP
// end ; if mc_crates_collector [ i ] and target then
55580: LD_EXP 31
55584: PUSH
55585: LD_VAR 0 2
55589: ARRAY
55590: PUSH
55591: LD_VAR 0 6
55595: AND
55596: IFFALSE 55839
// begin if mc_crates_collector [ i ] < target [ 1 ] then
55598: LD_EXP 31
55602: PUSH
55603: LD_VAR 0 2
55607: ARRAY
55608: PUSH
55609: LD_VAR 0 6
55613: PUSH
55614: LD_INT 1
55616: ARRAY
55617: LESS
55618: IFFALSE 55638
// tmp := mc_crates_collector [ i ] else
55620: LD_ADDR_VAR 0 5
55624: PUSH
55625: LD_EXP 31
55629: PUSH
55630: LD_VAR 0 2
55634: ARRAY
55635: ST_TO_ADDR
55636: GO 55652
// tmp := target [ 1 ] ;
55638: LD_ADDR_VAR 0 5
55642: PUSH
55643: LD_VAR 0 6
55647: PUSH
55648: LD_INT 1
55650: ARRAY
55651: ST_TO_ADDR
// k := 0 ;
55652: LD_ADDR_VAR 0 4
55656: PUSH
55657: LD_INT 0
55659: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
55660: LD_ADDR_VAR 0 3
55664: PUSH
55665: LD_EXP 31
55669: PUSH
55670: LD_VAR 0 2
55674: ARRAY
55675: PUSH
55676: FOR_IN
55677: IFFALSE 55837
// begin k := k + 1 ;
55679: LD_ADDR_VAR 0 4
55683: PUSH
55684: LD_VAR 0 4
55688: PUSH
55689: LD_INT 1
55691: PLUS
55692: ST_TO_ADDR
// if k > tmp then
55693: LD_VAR 0 4
55697: PUSH
55698: LD_VAR 0 5
55702: GREATER
55703: IFFALSE 55707
// break ;
55705: GO 55837
// if not GetClass ( j ) in [ 2 , 16 ] then
55707: LD_VAR 0 3
55711: PPUSH
55712: CALL_OW 257
55716: PUSH
55717: LD_INT 2
55719: PUSH
55720: LD_INT 16
55722: PUSH
55723: EMPTY
55724: LIST
55725: LIST
55726: IN
55727: NOT
55728: IFFALSE 55781
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
55730: LD_ADDR_EXP 31
55734: PUSH
55735: LD_EXP 31
55739: PPUSH
55740: LD_VAR 0 2
55744: PPUSH
55745: LD_EXP 31
55749: PUSH
55750: LD_VAR 0 2
55754: ARRAY
55755: PUSH
55756: LD_VAR 0 3
55760: DIFF
55761: PPUSH
55762: CALL_OW 1
55766: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55767: LD_VAR 0 3
55771: PPUSH
55772: LD_INT 0
55774: PPUSH
55775: CALL_OW 109
// continue ;
55779: GO 55676
// end ; if IsInUnit ( j ) then
55781: LD_VAR 0 3
55785: PPUSH
55786: CALL_OW 310
55790: IFFALSE 55801
// ComExitBuilding ( j ) ;
55792: LD_VAR 0 3
55796: PPUSH
55797: CALL_OW 122
// wait ( 3 ) ;
55801: LD_INT 3
55803: PPUSH
55804: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
55808: LD_VAR 0 3
55812: PPUSH
55813: LD_VAR 0 6
55817: PUSH
55818: LD_INT 2
55820: ARRAY
55821: PPUSH
55822: LD_VAR 0 6
55826: PUSH
55827: LD_INT 3
55829: ARRAY
55830: PPUSH
55831: CALL_OW 117
// end ;
55835: GO 55676
55837: POP
55838: POP
// end ; end else
55839: GO 56420
// begin for j in cargo do
55841: LD_ADDR_VAR 0 3
55845: PUSH
55846: LD_VAR 0 7
55850: PUSH
55851: FOR_IN
55852: IFFALSE 56418
// begin if GetTag ( j ) <> 0 then
55854: LD_VAR 0 3
55858: PPUSH
55859: CALL_OW 110
55863: PUSH
55864: LD_INT 0
55866: NONEQUAL
55867: IFFALSE 55871
// continue ;
55869: GO 55851
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
55871: LD_VAR 0 3
55875: PPUSH
55876: CALL_OW 256
55880: PUSH
55881: LD_INT 1000
55883: LESS
55884: PUSH
55885: LD_VAR 0 3
55889: PPUSH
55890: LD_EXP 38
55894: PUSH
55895: LD_VAR 0 2
55899: ARRAY
55900: PPUSH
55901: CALL_OW 308
55905: NOT
55906: AND
55907: IFFALSE 55929
// ComMoveToArea ( j , mc_parking [ i ] ) ;
55909: LD_VAR 0 3
55913: PPUSH
55914: LD_EXP 38
55918: PUSH
55919: LD_VAR 0 2
55923: ARRAY
55924: PPUSH
55925: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
55929: LD_VAR 0 3
55933: PPUSH
55934: CALL_OW 256
55938: PUSH
55939: LD_INT 1000
55941: LESS
55942: PUSH
55943: LD_VAR 0 3
55947: PPUSH
55948: LD_EXP 38
55952: PUSH
55953: LD_VAR 0 2
55957: ARRAY
55958: PPUSH
55959: CALL_OW 308
55963: AND
55964: IFFALSE 55968
// continue ;
55966: GO 55851
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
55968: LD_VAR 0 3
55972: PPUSH
55973: CALL_OW 262
55977: PUSH
55978: LD_INT 2
55980: EQUAL
55981: PUSH
55982: LD_VAR 0 3
55986: PPUSH
55987: CALL_OW 261
55991: PUSH
55992: LD_INT 15
55994: LESS
55995: AND
55996: IFFALSE 56000
// continue ;
55998: GO 55851
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
56000: LD_VAR 0 3
56004: PPUSH
56005: CALL_OW 262
56009: PUSH
56010: LD_INT 1
56012: EQUAL
56013: PUSH
56014: LD_VAR 0 3
56018: PPUSH
56019: CALL_OW 261
56023: PUSH
56024: LD_INT 10
56026: LESS
56027: AND
56028: IFFALSE 56357
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56030: LD_ADDR_VAR 0 8
56034: PUSH
56035: LD_EXP 14
56039: PUSH
56040: LD_VAR 0 2
56044: ARRAY
56045: PPUSH
56046: LD_INT 2
56048: PUSH
56049: LD_INT 30
56051: PUSH
56052: LD_INT 0
56054: PUSH
56055: EMPTY
56056: LIST
56057: LIST
56058: PUSH
56059: LD_INT 30
56061: PUSH
56062: LD_INT 1
56064: PUSH
56065: EMPTY
56066: LIST
56067: LIST
56068: PUSH
56069: EMPTY
56070: LIST
56071: LIST
56072: LIST
56073: PPUSH
56074: CALL_OW 72
56078: ST_TO_ADDR
// if not depot then
56079: LD_VAR 0 8
56083: NOT
56084: IFFALSE 56088
// continue ;
56086: GO 55851
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
56088: LD_VAR 0 3
56092: PPUSH
56093: LD_VAR 0 8
56097: PPUSH
56098: LD_VAR 0 3
56102: PPUSH
56103: CALL_OW 74
56107: PPUSH
56108: CALL_OW 296
56112: PUSH
56113: LD_INT 6
56115: LESS
56116: IFFALSE 56132
// SetFuel ( j , 100 ) else
56118: LD_VAR 0 3
56122: PPUSH
56123: LD_INT 100
56125: PPUSH
56126: CALL_OW 240
56130: GO 56357
// if GetFuel ( j ) = 0 then
56132: LD_VAR 0 3
56136: PPUSH
56137: CALL_OW 261
56141: PUSH
56142: LD_INT 0
56144: EQUAL
56145: IFFALSE 56357
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
56147: LD_ADDR_EXP 33
56151: PUSH
56152: LD_EXP 33
56156: PPUSH
56157: LD_VAR 0 2
56161: PPUSH
56162: LD_EXP 33
56166: PUSH
56167: LD_VAR 0 2
56171: ARRAY
56172: PUSH
56173: LD_VAR 0 3
56177: DIFF
56178: PPUSH
56179: CALL_OW 1
56183: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
56184: LD_VAR 0 3
56188: PPUSH
56189: CALL_OW 263
56193: PUSH
56194: LD_INT 1
56196: EQUAL
56197: IFFALSE 56213
// ComExitVehicle ( IsInUnit ( j ) ) ;
56199: LD_VAR 0 3
56203: PPUSH
56204: CALL_OW 310
56208: PPUSH
56209: CALL_OW 121
// if GetControl ( j ) = control_remote then
56213: LD_VAR 0 3
56217: PPUSH
56218: CALL_OW 263
56222: PUSH
56223: LD_INT 2
56225: EQUAL
56226: IFFALSE 56237
// ComUnlink ( j ) ;
56228: LD_VAR 0 3
56232: PPUSH
56233: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
56237: LD_ADDR_VAR 0 9
56241: PUSH
56242: LD_VAR 0 2
56246: PPUSH
56247: LD_INT 3
56249: PPUSH
56250: CALL 65732 0 2
56254: ST_TO_ADDR
// if fac then
56255: LD_VAR 0 9
56259: IFFALSE 56355
// begin for k in fac do
56261: LD_ADDR_VAR 0 4
56265: PUSH
56266: LD_VAR 0 9
56270: PUSH
56271: FOR_IN
56272: IFFALSE 56353
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
56274: LD_ADDR_VAR 0 10
56278: PUSH
56279: LD_VAR 0 9
56283: PPUSH
56284: LD_VAR 0 3
56288: PPUSH
56289: CALL_OW 265
56293: PPUSH
56294: LD_VAR 0 3
56298: PPUSH
56299: CALL_OW 262
56303: PPUSH
56304: LD_VAR 0 3
56308: PPUSH
56309: CALL_OW 263
56313: PPUSH
56314: LD_VAR 0 3
56318: PPUSH
56319: CALL_OW 264
56323: PPUSH
56324: CALL 6959 0 5
56328: ST_TO_ADDR
// if components then
56329: LD_VAR 0 10
56333: IFFALSE 56351
// begin MC_InsertProduceList ( i , components ) ;
56335: LD_VAR 0 2
56339: PPUSH
56340: LD_VAR 0 10
56344: PPUSH
56345: CALL 65277 0 2
// break ;
56349: GO 56353
// end ; end ;
56351: GO 56271
56353: POP
56354: POP
// end ; continue ;
56355: GO 55851
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
56357: LD_VAR 0 3
56361: PPUSH
56362: LD_INT 1
56364: PPUSH
56365: CALL_OW 289
56369: PUSH
56370: LD_INT 100
56372: LESS
56373: PUSH
56374: LD_VAR 0 3
56378: PPUSH
56379: CALL_OW 314
56383: NOT
56384: AND
56385: IFFALSE 56414
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
56387: LD_VAR 0 3
56391: PPUSH
56392: LD_VAR 0 6
56396: PUSH
56397: LD_INT 2
56399: ARRAY
56400: PPUSH
56401: LD_VAR 0 6
56405: PUSH
56406: LD_INT 3
56408: ARRAY
56409: PPUSH
56410: CALL_OW 117
// break ;
56414: GO 56418
// end ;
56416: GO 55851
56418: POP
56419: POP
// end ; end ;
56420: GO 54689
56422: POP
56423: POP
// end ;
56424: LD_VAR 0 1
56428: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
56429: LD_INT 0
56431: PPUSH
56432: PPUSH
56433: PPUSH
56434: PPUSH
// if not mc_bases then
56435: LD_EXP 14
56439: NOT
56440: IFFALSE 56444
// exit ;
56442: GO 56605
// for i = 1 to mc_bases do
56444: LD_ADDR_VAR 0 2
56448: PUSH
56449: DOUBLE
56450: LD_INT 1
56452: DEC
56453: ST_TO_ADDR
56454: LD_EXP 14
56458: PUSH
56459: FOR_TO
56460: IFFALSE 56603
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
56462: LD_ADDR_VAR 0 4
56466: PUSH
56467: LD_EXP 33
56471: PUSH
56472: LD_VAR 0 2
56476: ARRAY
56477: PUSH
56478: LD_EXP 36
56482: PUSH
56483: LD_VAR 0 2
56487: ARRAY
56488: UNION
56489: PPUSH
56490: LD_INT 33
56492: PUSH
56493: LD_INT 2
56495: PUSH
56496: EMPTY
56497: LIST
56498: LIST
56499: PPUSH
56500: CALL_OW 72
56504: ST_TO_ADDR
// if tmp then
56505: LD_VAR 0 4
56509: IFFALSE 56601
// for j in tmp do
56511: LD_ADDR_VAR 0 3
56515: PUSH
56516: LD_VAR 0 4
56520: PUSH
56521: FOR_IN
56522: IFFALSE 56599
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
56524: LD_VAR 0 3
56528: PPUSH
56529: CALL_OW 312
56533: NOT
56534: PUSH
56535: LD_VAR 0 3
56539: PPUSH
56540: CALL_OW 256
56544: PUSH
56545: LD_INT 250
56547: GREATEREQUAL
56548: AND
56549: IFFALSE 56562
// Connect ( j ) else
56551: LD_VAR 0 3
56555: PPUSH
56556: CALL 12360 0 1
56560: GO 56597
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
56562: LD_VAR 0 3
56566: PPUSH
56567: CALL_OW 256
56571: PUSH
56572: LD_INT 250
56574: LESS
56575: PUSH
56576: LD_VAR 0 3
56580: PPUSH
56581: CALL_OW 312
56585: AND
56586: IFFALSE 56597
// ComUnlink ( j ) ;
56588: LD_VAR 0 3
56592: PPUSH
56593: CALL_OW 136
56597: GO 56521
56599: POP
56600: POP
// end ;
56601: GO 56459
56603: POP
56604: POP
// end ;
56605: LD_VAR 0 1
56609: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
56610: LD_INT 0
56612: PPUSH
56613: PPUSH
56614: PPUSH
56615: PPUSH
56616: PPUSH
// if not mc_bases then
56617: LD_EXP 14
56621: NOT
56622: IFFALSE 56626
// exit ;
56624: GO 57071
// for i = 1 to mc_bases do
56626: LD_ADDR_VAR 0 2
56630: PUSH
56631: DOUBLE
56632: LD_INT 1
56634: DEC
56635: ST_TO_ADDR
56636: LD_EXP 14
56640: PUSH
56641: FOR_TO
56642: IFFALSE 57069
// begin if not mc_produce [ i ] then
56644: LD_EXP 35
56648: PUSH
56649: LD_VAR 0 2
56653: ARRAY
56654: NOT
56655: IFFALSE 56659
// continue ;
56657: GO 56641
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56659: LD_ADDR_VAR 0 5
56663: PUSH
56664: LD_EXP 14
56668: PUSH
56669: LD_VAR 0 2
56673: ARRAY
56674: PPUSH
56675: LD_INT 30
56677: PUSH
56678: LD_INT 3
56680: PUSH
56681: EMPTY
56682: LIST
56683: LIST
56684: PPUSH
56685: CALL_OW 72
56689: ST_TO_ADDR
// if not fac then
56690: LD_VAR 0 5
56694: NOT
56695: IFFALSE 56699
// continue ;
56697: GO 56641
// for j in fac do
56699: LD_ADDR_VAR 0 3
56703: PUSH
56704: LD_VAR 0 5
56708: PUSH
56709: FOR_IN
56710: IFFALSE 57065
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
56712: LD_VAR 0 3
56716: PPUSH
56717: CALL_OW 461
56721: PUSH
56722: LD_INT 2
56724: NONEQUAL
56725: PUSH
56726: LD_VAR 0 3
56730: PPUSH
56731: LD_INT 15
56733: PPUSH
56734: CALL 12020 0 2
56738: PUSH
56739: LD_INT 4
56741: ARRAY
56742: OR
56743: IFFALSE 56747
// continue ;
56745: GO 56709
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
56747: LD_VAR 0 3
56751: PPUSH
56752: LD_EXP 35
56756: PUSH
56757: LD_VAR 0 2
56761: ARRAY
56762: PUSH
56763: LD_INT 1
56765: ARRAY
56766: PUSH
56767: LD_INT 1
56769: ARRAY
56770: PPUSH
56771: LD_EXP 35
56775: PUSH
56776: LD_VAR 0 2
56780: ARRAY
56781: PUSH
56782: LD_INT 1
56784: ARRAY
56785: PUSH
56786: LD_INT 2
56788: ARRAY
56789: PPUSH
56790: LD_EXP 35
56794: PUSH
56795: LD_VAR 0 2
56799: ARRAY
56800: PUSH
56801: LD_INT 1
56803: ARRAY
56804: PUSH
56805: LD_INT 3
56807: ARRAY
56808: PPUSH
56809: LD_EXP 35
56813: PUSH
56814: LD_VAR 0 2
56818: ARRAY
56819: PUSH
56820: LD_INT 1
56822: ARRAY
56823: PUSH
56824: LD_INT 4
56826: ARRAY
56827: PPUSH
56828: CALL_OW 448
56832: PUSH
56833: LD_VAR 0 3
56837: PPUSH
56838: LD_EXP 35
56842: PUSH
56843: LD_VAR 0 2
56847: ARRAY
56848: PUSH
56849: LD_INT 1
56851: ARRAY
56852: PUSH
56853: LD_INT 1
56855: ARRAY
56856: PUSH
56857: LD_EXP 35
56861: PUSH
56862: LD_VAR 0 2
56866: ARRAY
56867: PUSH
56868: LD_INT 1
56870: ARRAY
56871: PUSH
56872: LD_INT 2
56874: ARRAY
56875: PUSH
56876: LD_EXP 35
56880: PUSH
56881: LD_VAR 0 2
56885: ARRAY
56886: PUSH
56887: LD_INT 1
56889: ARRAY
56890: PUSH
56891: LD_INT 3
56893: ARRAY
56894: PUSH
56895: LD_EXP 35
56899: PUSH
56900: LD_VAR 0 2
56904: ARRAY
56905: PUSH
56906: LD_INT 1
56908: ARRAY
56909: PUSH
56910: LD_INT 4
56912: ARRAY
56913: PUSH
56914: EMPTY
56915: LIST
56916: LIST
56917: LIST
56918: LIST
56919: PPUSH
56920: CALL 15691 0 2
56924: AND
56925: IFFALSE 57063
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
56927: LD_VAR 0 3
56931: PPUSH
56932: LD_EXP 35
56936: PUSH
56937: LD_VAR 0 2
56941: ARRAY
56942: PUSH
56943: LD_INT 1
56945: ARRAY
56946: PUSH
56947: LD_INT 1
56949: ARRAY
56950: PPUSH
56951: LD_EXP 35
56955: PUSH
56956: LD_VAR 0 2
56960: ARRAY
56961: PUSH
56962: LD_INT 1
56964: ARRAY
56965: PUSH
56966: LD_INT 2
56968: ARRAY
56969: PPUSH
56970: LD_EXP 35
56974: PUSH
56975: LD_VAR 0 2
56979: ARRAY
56980: PUSH
56981: LD_INT 1
56983: ARRAY
56984: PUSH
56985: LD_INT 3
56987: ARRAY
56988: PPUSH
56989: LD_EXP 35
56993: PUSH
56994: LD_VAR 0 2
56998: ARRAY
56999: PUSH
57000: LD_INT 1
57002: ARRAY
57003: PUSH
57004: LD_INT 4
57006: ARRAY
57007: PPUSH
57008: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
57012: LD_ADDR_VAR 0 4
57016: PUSH
57017: LD_EXP 35
57021: PUSH
57022: LD_VAR 0 2
57026: ARRAY
57027: PPUSH
57028: LD_INT 1
57030: PPUSH
57031: CALL_OW 3
57035: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
57036: LD_ADDR_EXP 35
57040: PUSH
57041: LD_EXP 35
57045: PPUSH
57046: LD_VAR 0 2
57050: PPUSH
57051: LD_VAR 0 4
57055: PPUSH
57056: CALL_OW 1
57060: ST_TO_ADDR
// break ;
57061: GO 57065
// end ; end ;
57063: GO 56709
57065: POP
57066: POP
// end ;
57067: GO 56641
57069: POP
57070: POP
// end ;
57071: LD_VAR 0 1
57075: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
57076: LD_INT 0
57078: PPUSH
57079: PPUSH
57080: PPUSH
// if not mc_bases then
57081: LD_EXP 14
57085: NOT
57086: IFFALSE 57090
// exit ;
57088: GO 57179
// for i = 1 to mc_bases do
57090: LD_ADDR_VAR 0 2
57094: PUSH
57095: DOUBLE
57096: LD_INT 1
57098: DEC
57099: ST_TO_ADDR
57100: LD_EXP 14
57104: PUSH
57105: FOR_TO
57106: IFFALSE 57177
// begin if mc_attack [ i ] then
57108: LD_EXP 34
57112: PUSH
57113: LD_VAR 0 2
57117: ARRAY
57118: IFFALSE 57175
// begin tmp := mc_attack [ i ] [ 1 ] ;
57120: LD_ADDR_VAR 0 3
57124: PUSH
57125: LD_EXP 34
57129: PUSH
57130: LD_VAR 0 2
57134: ARRAY
57135: PUSH
57136: LD_INT 1
57138: ARRAY
57139: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57140: LD_ADDR_EXP 34
57144: PUSH
57145: LD_EXP 34
57149: PPUSH
57150: LD_VAR 0 2
57154: PPUSH
57155: EMPTY
57156: PPUSH
57157: CALL_OW 1
57161: ST_TO_ADDR
// Attack ( tmp ) ;
57162: LD_VAR 0 3
57166: PPUSH
57167: CALL 71784 0 1
// exit ;
57171: POP
57172: POP
57173: GO 57179
// end ; end ;
57175: GO 57105
57177: POP
57178: POP
// end ;
57179: LD_VAR 0 1
57183: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
57184: LD_INT 0
57186: PPUSH
57187: PPUSH
57188: PPUSH
57189: PPUSH
57190: PPUSH
57191: PPUSH
57192: PPUSH
// if not mc_bases then
57193: LD_EXP 14
57197: NOT
57198: IFFALSE 57202
// exit ;
57200: GO 57806
// for i = 1 to mc_bases do
57202: LD_ADDR_VAR 0 2
57206: PUSH
57207: DOUBLE
57208: LD_INT 1
57210: DEC
57211: ST_TO_ADDR
57212: LD_EXP 14
57216: PUSH
57217: FOR_TO
57218: IFFALSE 57804
// begin if not mc_bases [ i ] then
57220: LD_EXP 14
57224: PUSH
57225: LD_VAR 0 2
57229: ARRAY
57230: NOT
57231: IFFALSE 57235
// continue ;
57233: GO 57217
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
57235: LD_ADDR_VAR 0 7
57239: PUSH
57240: LD_EXP 14
57244: PUSH
57245: LD_VAR 0 2
57249: ARRAY
57250: PUSH
57251: LD_INT 1
57253: ARRAY
57254: PPUSH
57255: CALL 6263 0 1
57259: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
57260: LD_ADDR_EXP 37
57264: PUSH
57265: LD_EXP 37
57269: PPUSH
57270: LD_VAR 0 2
57274: PPUSH
57275: LD_EXP 14
57279: PUSH
57280: LD_VAR 0 2
57284: ARRAY
57285: PUSH
57286: LD_INT 1
57288: ARRAY
57289: PPUSH
57290: CALL_OW 255
57294: PPUSH
57295: LD_EXP 39
57299: PUSH
57300: LD_VAR 0 2
57304: ARRAY
57305: PPUSH
57306: CALL 6228 0 2
57310: PPUSH
57311: CALL_OW 1
57315: ST_TO_ADDR
// if not mc_scan [ i ] then
57316: LD_EXP 37
57320: PUSH
57321: LD_VAR 0 2
57325: ARRAY
57326: NOT
57327: IFFALSE 57482
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57329: LD_ADDR_VAR 0 4
57333: PUSH
57334: LD_EXP 14
57338: PUSH
57339: LD_VAR 0 2
57343: ARRAY
57344: PPUSH
57345: LD_INT 2
57347: PUSH
57348: LD_INT 25
57350: PUSH
57351: LD_INT 5
57353: PUSH
57354: EMPTY
57355: LIST
57356: LIST
57357: PUSH
57358: LD_INT 25
57360: PUSH
57361: LD_INT 8
57363: PUSH
57364: EMPTY
57365: LIST
57366: LIST
57367: PUSH
57368: LD_INT 25
57370: PUSH
57371: LD_INT 9
57373: PUSH
57374: EMPTY
57375: LIST
57376: LIST
57377: PUSH
57378: EMPTY
57379: LIST
57380: LIST
57381: LIST
57382: LIST
57383: PPUSH
57384: CALL_OW 72
57388: ST_TO_ADDR
// if not tmp then
57389: LD_VAR 0 4
57393: NOT
57394: IFFALSE 57398
// continue ;
57396: GO 57217
// for j in tmp do
57398: LD_ADDR_VAR 0 3
57402: PUSH
57403: LD_VAR 0 4
57407: PUSH
57408: FOR_IN
57409: IFFALSE 57480
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
57411: LD_VAR 0 3
57415: PPUSH
57416: CALL_OW 310
57420: PPUSH
57421: CALL_OW 266
57425: PUSH
57426: LD_INT 5
57428: EQUAL
57429: PUSH
57430: LD_VAR 0 3
57434: PPUSH
57435: CALL_OW 257
57439: PUSH
57440: LD_INT 1
57442: EQUAL
57443: AND
57444: PUSH
57445: LD_VAR 0 3
57449: PPUSH
57450: CALL_OW 459
57454: NOT
57455: AND
57456: PUSH
57457: LD_VAR 0 7
57461: AND
57462: IFFALSE 57478
// ComChangeProfession ( j , class ) ;
57464: LD_VAR 0 3
57468: PPUSH
57469: LD_VAR 0 7
57473: PPUSH
57474: CALL_OW 123
57478: GO 57408
57480: POP
57481: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
57482: LD_EXP 37
57486: PUSH
57487: LD_VAR 0 2
57491: ARRAY
57492: PUSH
57493: LD_EXP 36
57497: PUSH
57498: LD_VAR 0 2
57502: ARRAY
57503: NOT
57504: AND
57505: PUSH
57506: LD_EXP 14
57510: PUSH
57511: LD_VAR 0 2
57515: ARRAY
57516: PPUSH
57517: LD_INT 30
57519: PUSH
57520: LD_INT 32
57522: PUSH
57523: EMPTY
57524: LIST
57525: LIST
57526: PPUSH
57527: CALL_OW 72
57531: NOT
57532: AND
57533: PUSH
57534: LD_EXP 14
57538: PUSH
57539: LD_VAR 0 2
57543: ARRAY
57544: PPUSH
57545: LD_INT 2
57547: PUSH
57548: LD_INT 30
57550: PUSH
57551: LD_INT 4
57553: PUSH
57554: EMPTY
57555: LIST
57556: LIST
57557: PUSH
57558: LD_INT 30
57560: PUSH
57561: LD_INT 5
57563: PUSH
57564: EMPTY
57565: LIST
57566: LIST
57567: PUSH
57568: EMPTY
57569: LIST
57570: LIST
57571: LIST
57572: PPUSH
57573: CALL_OW 72
57577: NOT
57578: AND
57579: IFFALSE 57711
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57581: LD_ADDR_VAR 0 4
57585: PUSH
57586: LD_EXP 14
57590: PUSH
57591: LD_VAR 0 2
57595: ARRAY
57596: PPUSH
57597: LD_INT 2
57599: PUSH
57600: LD_INT 25
57602: PUSH
57603: LD_INT 1
57605: PUSH
57606: EMPTY
57607: LIST
57608: LIST
57609: PUSH
57610: LD_INT 25
57612: PUSH
57613: LD_INT 5
57615: PUSH
57616: EMPTY
57617: LIST
57618: LIST
57619: PUSH
57620: LD_INT 25
57622: PUSH
57623: LD_INT 8
57625: PUSH
57626: EMPTY
57627: LIST
57628: LIST
57629: PUSH
57630: LD_INT 25
57632: PUSH
57633: LD_INT 9
57635: PUSH
57636: EMPTY
57637: LIST
57638: LIST
57639: PUSH
57640: EMPTY
57641: LIST
57642: LIST
57643: LIST
57644: LIST
57645: LIST
57646: PPUSH
57647: CALL_OW 72
57651: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
57652: LD_ADDR_VAR 0 4
57656: PUSH
57657: LD_VAR 0 4
57661: PUSH
57662: LD_VAR 0 4
57666: PPUSH
57667: LD_INT 18
57669: PPUSH
57670: CALL 37988 0 2
57674: DIFF
57675: ST_TO_ADDR
// if tmp then
57676: LD_VAR 0 4
57680: IFFALSE 57711
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
57682: LD_VAR 0 2
57686: PPUSH
57687: LD_VAR 0 4
57691: PPUSH
57692: LD_EXP 39
57696: PUSH
57697: LD_VAR 0 2
57701: ARRAY
57702: PPUSH
57703: CALL 76493 0 3
// exit ;
57707: POP
57708: POP
57709: GO 57806
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
57711: LD_EXP 37
57715: PUSH
57716: LD_VAR 0 2
57720: ARRAY
57721: PUSH
57722: LD_EXP 36
57726: PUSH
57727: LD_VAR 0 2
57731: ARRAY
57732: AND
57733: IFFALSE 57802
// begin tmp := mc_defender [ i ] ;
57735: LD_ADDR_VAR 0 4
57739: PUSH
57740: LD_EXP 36
57744: PUSH
57745: LD_VAR 0 2
57749: ARRAY
57750: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57751: LD_ADDR_EXP 36
57755: PUSH
57756: LD_EXP 36
57760: PPUSH
57761: LD_VAR 0 2
57765: PPUSH
57766: EMPTY
57767: PPUSH
57768: CALL_OW 1
57772: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
57773: LD_VAR 0 2
57777: PPUSH
57778: LD_VAR 0 4
57782: PPUSH
57783: LD_EXP 37
57787: PUSH
57788: LD_VAR 0 2
57792: ARRAY
57793: PPUSH
57794: CALL 77054 0 3
// exit ;
57798: POP
57799: POP
57800: GO 57806
// end ; end ;
57802: GO 57217
57804: POP
57805: POP
// end ;
57806: LD_VAR 0 1
57810: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
57811: LD_INT 0
57813: PPUSH
57814: PPUSH
57815: PPUSH
57816: PPUSH
57817: PPUSH
57818: PPUSH
57819: PPUSH
57820: PPUSH
57821: PPUSH
57822: PPUSH
57823: PPUSH
// if not mc_bases then
57824: LD_EXP 14
57828: NOT
57829: IFFALSE 57833
// exit ;
57831: GO 58920
// for i = 1 to mc_bases do
57833: LD_ADDR_VAR 0 2
57837: PUSH
57838: DOUBLE
57839: LD_INT 1
57841: DEC
57842: ST_TO_ADDR
57843: LD_EXP 14
57847: PUSH
57848: FOR_TO
57849: IFFALSE 58918
// begin tmp := mc_lab [ i ] ;
57851: LD_ADDR_VAR 0 6
57855: PUSH
57856: LD_EXP 47
57860: PUSH
57861: LD_VAR 0 2
57865: ARRAY
57866: ST_TO_ADDR
// if not tmp then
57867: LD_VAR 0 6
57871: NOT
57872: IFFALSE 57876
// continue ;
57874: GO 57848
// idle_lab := 0 ;
57876: LD_ADDR_VAR 0 11
57880: PUSH
57881: LD_INT 0
57883: ST_TO_ADDR
// for j in tmp do
57884: LD_ADDR_VAR 0 3
57888: PUSH
57889: LD_VAR 0 6
57893: PUSH
57894: FOR_IN
57895: IFFALSE 58914
// begin researching := false ;
57897: LD_ADDR_VAR 0 10
57901: PUSH
57902: LD_INT 0
57904: ST_TO_ADDR
// side := GetSide ( j ) ;
57905: LD_ADDR_VAR 0 4
57909: PUSH
57910: LD_VAR 0 3
57914: PPUSH
57915: CALL_OW 255
57919: ST_TO_ADDR
// if not mc_tech [ side ] then
57920: LD_EXP 41
57924: PUSH
57925: LD_VAR 0 4
57929: ARRAY
57930: NOT
57931: IFFALSE 57935
// continue ;
57933: GO 57894
// if BuildingStatus ( j ) = bs_idle then
57935: LD_VAR 0 3
57939: PPUSH
57940: CALL_OW 461
57944: PUSH
57945: LD_INT 2
57947: EQUAL
57948: IFFALSE 58136
// begin if idle_lab and UnitsInside ( j ) < 6 then
57950: LD_VAR 0 11
57954: PUSH
57955: LD_VAR 0 3
57959: PPUSH
57960: CALL_OW 313
57964: PUSH
57965: LD_INT 6
57967: LESS
57968: AND
57969: IFFALSE 58040
// begin tmp2 := UnitsInside ( idle_lab ) ;
57971: LD_ADDR_VAR 0 9
57975: PUSH
57976: LD_VAR 0 11
57980: PPUSH
57981: CALL_OW 313
57985: ST_TO_ADDR
// if tmp2 then
57986: LD_VAR 0 9
57990: IFFALSE 58032
// for x in tmp2 do
57992: LD_ADDR_VAR 0 7
57996: PUSH
57997: LD_VAR 0 9
58001: PUSH
58002: FOR_IN
58003: IFFALSE 58030
// begin ComExitBuilding ( x ) ;
58005: LD_VAR 0 7
58009: PPUSH
58010: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
58014: LD_VAR 0 7
58018: PPUSH
58019: LD_VAR 0 3
58023: PPUSH
58024: CALL_OW 180
// end ;
58028: GO 58002
58030: POP
58031: POP
// idle_lab := 0 ;
58032: LD_ADDR_VAR 0 11
58036: PUSH
58037: LD_INT 0
58039: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
58040: LD_ADDR_VAR 0 5
58044: PUSH
58045: LD_EXP 41
58049: PUSH
58050: LD_VAR 0 4
58054: ARRAY
58055: PUSH
58056: FOR_IN
58057: IFFALSE 58117
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
58059: LD_VAR 0 3
58063: PPUSH
58064: LD_VAR 0 5
58068: PPUSH
58069: CALL_OW 430
58073: PUSH
58074: LD_VAR 0 4
58078: PPUSH
58079: LD_VAR 0 5
58083: PPUSH
58084: CALL 5333 0 2
58088: AND
58089: IFFALSE 58115
// begin researching := true ;
58091: LD_ADDR_VAR 0 10
58095: PUSH
58096: LD_INT 1
58098: ST_TO_ADDR
// ComResearch ( j , t ) ;
58099: LD_VAR 0 3
58103: PPUSH
58104: LD_VAR 0 5
58108: PPUSH
58109: CALL_OW 124
// break ;
58113: GO 58117
// end ;
58115: GO 58056
58117: POP
58118: POP
// if not researching then
58119: LD_VAR 0 10
58123: NOT
58124: IFFALSE 58136
// idle_lab := j ;
58126: LD_ADDR_VAR 0 11
58130: PUSH
58131: LD_VAR 0 3
58135: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
58136: LD_VAR 0 3
58140: PPUSH
58141: CALL_OW 461
58145: PUSH
58146: LD_INT 10
58148: EQUAL
58149: IFFALSE 58737
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
58151: LD_EXP 43
58155: PUSH
58156: LD_VAR 0 2
58160: ARRAY
58161: NOT
58162: PUSH
58163: LD_EXP 44
58167: PUSH
58168: LD_VAR 0 2
58172: ARRAY
58173: NOT
58174: AND
58175: PUSH
58176: LD_EXP 41
58180: PUSH
58181: LD_VAR 0 4
58185: ARRAY
58186: PUSH
58187: LD_INT 1
58189: GREATER
58190: AND
58191: IFFALSE 58322
// begin ComCancel ( j ) ;
58193: LD_VAR 0 3
58197: PPUSH
58198: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
58202: LD_ADDR_EXP 41
58206: PUSH
58207: LD_EXP 41
58211: PPUSH
58212: LD_VAR 0 4
58216: PPUSH
58217: LD_EXP 41
58221: PUSH
58222: LD_VAR 0 4
58226: ARRAY
58227: PPUSH
58228: LD_EXP 41
58232: PUSH
58233: LD_VAR 0 4
58237: ARRAY
58238: PUSH
58239: LD_INT 1
58241: MINUS
58242: PPUSH
58243: LD_EXP 41
58247: PUSH
58248: LD_VAR 0 4
58252: ARRAY
58253: PPUSH
58254: LD_INT 0
58256: PPUSH
58257: CALL 8845 0 4
58261: PPUSH
58262: CALL_OW 1
58266: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
58267: LD_ADDR_EXP 41
58271: PUSH
58272: LD_EXP 41
58276: PPUSH
58277: LD_VAR 0 4
58281: PPUSH
58282: LD_EXP 41
58286: PUSH
58287: LD_VAR 0 4
58291: ARRAY
58292: PPUSH
58293: LD_EXP 41
58297: PUSH
58298: LD_VAR 0 4
58302: ARRAY
58303: PPUSH
58304: LD_INT 1
58306: PPUSH
58307: LD_INT 0
58309: PPUSH
58310: CALL 8845 0 4
58314: PPUSH
58315: CALL_OW 1
58319: ST_TO_ADDR
// continue ;
58320: GO 57894
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
58322: LD_EXP 43
58326: PUSH
58327: LD_VAR 0 2
58331: ARRAY
58332: PUSH
58333: LD_EXP 44
58337: PUSH
58338: LD_VAR 0 2
58342: ARRAY
58343: NOT
58344: AND
58345: IFFALSE 58472
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
58347: LD_ADDR_EXP 44
58351: PUSH
58352: LD_EXP 44
58356: PPUSH
58357: LD_VAR 0 2
58361: PUSH
58362: LD_EXP 44
58366: PUSH
58367: LD_VAR 0 2
58371: ARRAY
58372: PUSH
58373: LD_INT 1
58375: PLUS
58376: PUSH
58377: EMPTY
58378: LIST
58379: LIST
58380: PPUSH
58381: LD_EXP 43
58385: PUSH
58386: LD_VAR 0 2
58390: ARRAY
58391: PUSH
58392: LD_INT 1
58394: ARRAY
58395: PPUSH
58396: CALL 9427 0 3
58400: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
58401: LD_EXP 43
58405: PUSH
58406: LD_VAR 0 2
58410: ARRAY
58411: PUSH
58412: LD_INT 1
58414: ARRAY
58415: PPUSH
58416: LD_INT 112
58418: PPUSH
58419: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
58423: LD_ADDR_VAR 0 9
58427: PUSH
58428: LD_EXP 43
58432: PUSH
58433: LD_VAR 0 2
58437: ARRAY
58438: PPUSH
58439: LD_INT 1
58441: PPUSH
58442: CALL_OW 3
58446: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
58447: LD_ADDR_EXP 43
58451: PUSH
58452: LD_EXP 43
58456: PPUSH
58457: LD_VAR 0 2
58461: PPUSH
58462: LD_VAR 0 9
58466: PPUSH
58467: CALL_OW 1
58471: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
58472: LD_EXP 43
58476: PUSH
58477: LD_VAR 0 2
58481: ARRAY
58482: PUSH
58483: LD_EXP 44
58487: PUSH
58488: LD_VAR 0 2
58492: ARRAY
58493: AND
58494: PUSH
58495: LD_EXP 44
58499: PUSH
58500: LD_VAR 0 2
58504: ARRAY
58505: PUSH
58506: LD_INT 1
58508: ARRAY
58509: PPUSH
58510: CALL_OW 310
58514: NOT
58515: AND
58516: PUSH
58517: LD_VAR 0 3
58521: PPUSH
58522: CALL_OW 313
58526: PUSH
58527: LD_INT 6
58529: EQUAL
58530: AND
58531: IFFALSE 58587
// begin tmp2 := UnitsInside ( j ) ;
58533: LD_ADDR_VAR 0 9
58537: PUSH
58538: LD_VAR 0 3
58542: PPUSH
58543: CALL_OW 313
58547: ST_TO_ADDR
// if tmp2 = 6 then
58548: LD_VAR 0 9
58552: PUSH
58553: LD_INT 6
58555: EQUAL
58556: IFFALSE 58587
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
58558: LD_VAR 0 9
58562: PUSH
58563: LD_INT 1
58565: ARRAY
58566: PPUSH
58567: LD_INT 112
58569: PPUSH
58570: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
58574: LD_VAR 0 9
58578: PUSH
58579: LD_INT 1
58581: ARRAY
58582: PPUSH
58583: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
58587: LD_EXP 44
58591: PUSH
58592: LD_VAR 0 2
58596: ARRAY
58597: PUSH
58598: LD_EXP 44
58602: PUSH
58603: LD_VAR 0 2
58607: ARRAY
58608: PUSH
58609: LD_INT 1
58611: ARRAY
58612: PPUSH
58613: CALL_OW 314
58617: NOT
58618: AND
58619: PUSH
58620: LD_EXP 44
58624: PUSH
58625: LD_VAR 0 2
58629: ARRAY
58630: PUSH
58631: LD_INT 1
58633: ARRAY
58634: PPUSH
58635: CALL_OW 310
58639: NOT
58640: AND
58641: IFFALSE 58667
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
58643: LD_EXP 44
58647: PUSH
58648: LD_VAR 0 2
58652: ARRAY
58653: PUSH
58654: LD_INT 1
58656: ARRAY
58657: PPUSH
58658: LD_VAR 0 3
58662: PPUSH
58663: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
58667: LD_EXP 44
58671: PUSH
58672: LD_VAR 0 2
58676: ARRAY
58677: PUSH
58678: LD_INT 1
58680: ARRAY
58681: PPUSH
58682: CALL_OW 310
58686: PUSH
58687: LD_EXP 44
58691: PUSH
58692: LD_VAR 0 2
58696: ARRAY
58697: PUSH
58698: LD_INT 1
58700: ARRAY
58701: PPUSH
58702: CALL_OW 310
58706: PPUSH
58707: CALL_OW 461
58711: PUSH
58712: LD_INT 3
58714: NONEQUAL
58715: AND
58716: IFFALSE 58737
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
58718: LD_EXP 44
58722: PUSH
58723: LD_VAR 0 2
58727: ARRAY
58728: PUSH
58729: LD_INT 1
58731: ARRAY
58732: PPUSH
58733: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
58737: LD_VAR 0 3
58741: PPUSH
58742: CALL_OW 461
58746: PUSH
58747: LD_INT 6
58749: EQUAL
58750: PUSH
58751: LD_VAR 0 6
58755: PUSH
58756: LD_INT 1
58758: GREATER
58759: AND
58760: IFFALSE 58912
// begin sci := [ ] ;
58762: LD_ADDR_VAR 0 8
58766: PUSH
58767: EMPTY
58768: ST_TO_ADDR
// for x in ( tmp diff j ) do
58769: LD_ADDR_VAR 0 7
58773: PUSH
58774: LD_VAR 0 6
58778: PUSH
58779: LD_VAR 0 3
58783: DIFF
58784: PUSH
58785: FOR_IN
58786: IFFALSE 58838
// begin if sci = 6 then
58788: LD_VAR 0 8
58792: PUSH
58793: LD_INT 6
58795: EQUAL
58796: IFFALSE 58800
// break ;
58798: GO 58838
// if BuildingStatus ( x ) = bs_idle then
58800: LD_VAR 0 7
58804: PPUSH
58805: CALL_OW 461
58809: PUSH
58810: LD_INT 2
58812: EQUAL
58813: IFFALSE 58836
// sci := sci ^ UnitsInside ( x ) ;
58815: LD_ADDR_VAR 0 8
58819: PUSH
58820: LD_VAR 0 8
58824: PUSH
58825: LD_VAR 0 7
58829: PPUSH
58830: CALL_OW 313
58834: ADD
58835: ST_TO_ADDR
// end ;
58836: GO 58785
58838: POP
58839: POP
// if not sci then
58840: LD_VAR 0 8
58844: NOT
58845: IFFALSE 58849
// continue ;
58847: GO 57894
// for x in sci do
58849: LD_ADDR_VAR 0 7
58853: PUSH
58854: LD_VAR 0 8
58858: PUSH
58859: FOR_IN
58860: IFFALSE 58910
// if IsInUnit ( x ) and not HasTask ( x ) then
58862: LD_VAR 0 7
58866: PPUSH
58867: CALL_OW 310
58871: PUSH
58872: LD_VAR 0 7
58876: PPUSH
58877: CALL_OW 314
58881: NOT
58882: AND
58883: IFFALSE 58908
// begin ComExitBuilding ( x ) ;
58885: LD_VAR 0 7
58889: PPUSH
58890: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
58894: LD_VAR 0 7
58898: PPUSH
58899: LD_VAR 0 3
58903: PPUSH
58904: CALL_OW 180
// end ;
58908: GO 58859
58910: POP
58911: POP
// end ; end ;
58912: GO 57894
58914: POP
58915: POP
// end ;
58916: GO 57848
58918: POP
58919: POP
// end ;
58920: LD_VAR 0 1
58924: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
58925: LD_INT 0
58927: PPUSH
58928: PPUSH
// if not mc_bases then
58929: LD_EXP 14
58933: NOT
58934: IFFALSE 58938
// exit ;
58936: GO 59019
// for i = 1 to mc_bases do
58938: LD_ADDR_VAR 0 2
58942: PUSH
58943: DOUBLE
58944: LD_INT 1
58946: DEC
58947: ST_TO_ADDR
58948: LD_EXP 14
58952: PUSH
58953: FOR_TO
58954: IFFALSE 59017
// if mc_mines [ i ] and mc_miners [ i ] then
58956: LD_EXP 27
58960: PUSH
58961: LD_VAR 0 2
58965: ARRAY
58966: PUSH
58967: LD_EXP 28
58971: PUSH
58972: LD_VAR 0 2
58976: ARRAY
58977: AND
58978: IFFALSE 59015
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
58980: LD_EXP 28
58984: PUSH
58985: LD_VAR 0 2
58989: ARRAY
58990: PUSH
58991: LD_INT 1
58993: ARRAY
58994: PPUSH
58995: CALL_OW 255
58999: PPUSH
59000: LD_EXP 27
59004: PUSH
59005: LD_VAR 0 2
59009: ARRAY
59010: PPUSH
59011: CALL 6416 0 2
59015: GO 58953
59017: POP
59018: POP
// end ;
59019: LD_VAR 0 1
59023: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
59024: LD_INT 0
59026: PPUSH
59027: PPUSH
59028: PPUSH
59029: PPUSH
59030: PPUSH
59031: PPUSH
59032: PPUSH
59033: PPUSH
// if not mc_bases or not mc_parking then
59034: LD_EXP 14
59038: NOT
59039: PUSH
59040: LD_EXP 38
59044: NOT
59045: OR
59046: IFFALSE 59050
// exit ;
59048: GO 59749
// for i = 1 to mc_bases do
59050: LD_ADDR_VAR 0 2
59054: PUSH
59055: DOUBLE
59056: LD_INT 1
59058: DEC
59059: ST_TO_ADDR
59060: LD_EXP 14
59064: PUSH
59065: FOR_TO
59066: IFFALSE 59747
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
59068: LD_EXP 14
59072: PUSH
59073: LD_VAR 0 2
59077: ARRAY
59078: NOT
59079: PUSH
59080: LD_EXP 38
59084: PUSH
59085: LD_VAR 0 2
59089: ARRAY
59090: NOT
59091: OR
59092: IFFALSE 59096
// continue ;
59094: GO 59065
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
59096: LD_ADDR_VAR 0 5
59100: PUSH
59101: LD_EXP 14
59105: PUSH
59106: LD_VAR 0 2
59110: ARRAY
59111: PUSH
59112: LD_INT 1
59114: ARRAY
59115: PPUSH
59116: CALL_OW 255
59120: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59121: LD_ADDR_VAR 0 6
59125: PUSH
59126: LD_EXP 14
59130: PUSH
59131: LD_VAR 0 2
59135: ARRAY
59136: PPUSH
59137: LD_INT 30
59139: PUSH
59140: LD_INT 3
59142: PUSH
59143: EMPTY
59144: LIST
59145: LIST
59146: PPUSH
59147: CALL_OW 72
59151: ST_TO_ADDR
// if not fac then
59152: LD_VAR 0 6
59156: NOT
59157: IFFALSE 59208
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59159: LD_ADDR_VAR 0 6
59163: PUSH
59164: LD_EXP 14
59168: PUSH
59169: LD_VAR 0 2
59173: ARRAY
59174: PPUSH
59175: LD_INT 2
59177: PUSH
59178: LD_INT 30
59180: PUSH
59181: LD_INT 0
59183: PUSH
59184: EMPTY
59185: LIST
59186: LIST
59187: PUSH
59188: LD_INT 30
59190: PUSH
59191: LD_INT 1
59193: PUSH
59194: EMPTY
59195: LIST
59196: LIST
59197: PUSH
59198: EMPTY
59199: LIST
59200: LIST
59201: LIST
59202: PPUSH
59203: CALL_OW 72
59207: ST_TO_ADDR
// if not fac then
59208: LD_VAR 0 6
59212: NOT
59213: IFFALSE 59217
// continue ;
59215: GO 59065
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59217: LD_ADDR_VAR 0 7
59221: PUSH
59222: LD_EXP 38
59226: PUSH
59227: LD_VAR 0 2
59231: ARRAY
59232: PPUSH
59233: LD_INT 22
59235: PUSH
59236: LD_VAR 0 5
59240: PUSH
59241: EMPTY
59242: LIST
59243: LIST
59244: PUSH
59245: LD_INT 21
59247: PUSH
59248: LD_INT 2
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: PUSH
59255: LD_INT 3
59257: PUSH
59258: LD_INT 24
59260: PUSH
59261: LD_INT 1000
59263: PUSH
59264: EMPTY
59265: LIST
59266: LIST
59267: PUSH
59268: EMPTY
59269: LIST
59270: LIST
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: LIST
59276: PPUSH
59277: CALL_OW 70
59281: ST_TO_ADDR
// for j in fac do
59282: LD_ADDR_VAR 0 3
59286: PUSH
59287: LD_VAR 0 6
59291: PUSH
59292: FOR_IN
59293: IFFALSE 59374
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59295: LD_ADDR_VAR 0 7
59299: PUSH
59300: LD_VAR 0 7
59304: PUSH
59305: LD_INT 22
59307: PUSH
59308: LD_VAR 0 5
59312: PUSH
59313: EMPTY
59314: LIST
59315: LIST
59316: PUSH
59317: LD_INT 91
59319: PUSH
59320: LD_VAR 0 3
59324: PUSH
59325: LD_INT 15
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: LIST
59332: PUSH
59333: LD_INT 21
59335: PUSH
59336: LD_INT 2
59338: PUSH
59339: EMPTY
59340: LIST
59341: LIST
59342: PUSH
59343: LD_INT 3
59345: PUSH
59346: LD_INT 24
59348: PUSH
59349: LD_INT 1000
59351: PUSH
59352: EMPTY
59353: LIST
59354: LIST
59355: PUSH
59356: EMPTY
59357: LIST
59358: LIST
59359: PUSH
59360: EMPTY
59361: LIST
59362: LIST
59363: LIST
59364: LIST
59365: PPUSH
59366: CALL_OW 69
59370: UNION
59371: ST_TO_ADDR
59372: GO 59292
59374: POP
59375: POP
// if not vehs then
59376: LD_VAR 0 7
59380: NOT
59381: IFFALSE 59407
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59383: LD_ADDR_EXP 26
59387: PUSH
59388: LD_EXP 26
59392: PPUSH
59393: LD_VAR 0 2
59397: PPUSH
59398: EMPTY
59399: PPUSH
59400: CALL_OW 1
59404: ST_TO_ADDR
// continue ;
59405: GO 59065
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59407: LD_ADDR_VAR 0 8
59411: PUSH
59412: LD_EXP 14
59416: PUSH
59417: LD_VAR 0 2
59421: ARRAY
59422: PPUSH
59423: LD_INT 30
59425: PUSH
59426: LD_INT 3
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: PPUSH
59433: CALL_OW 72
59437: ST_TO_ADDR
// if tmp then
59438: LD_VAR 0 8
59442: IFFALSE 59545
// begin for j in tmp do
59444: LD_ADDR_VAR 0 3
59448: PUSH
59449: LD_VAR 0 8
59453: PUSH
59454: FOR_IN
59455: IFFALSE 59543
// for k in UnitsInside ( j ) do
59457: LD_ADDR_VAR 0 4
59461: PUSH
59462: LD_VAR 0 3
59466: PPUSH
59467: CALL_OW 313
59471: PUSH
59472: FOR_IN
59473: IFFALSE 59539
// if k then
59475: LD_VAR 0 4
59479: IFFALSE 59537
// if not k in mc_repair_vehicle [ i ] then
59481: LD_VAR 0 4
59485: PUSH
59486: LD_EXP 26
59490: PUSH
59491: LD_VAR 0 2
59495: ARRAY
59496: IN
59497: NOT
59498: IFFALSE 59537
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
59500: LD_ADDR_EXP 26
59504: PUSH
59505: LD_EXP 26
59509: PPUSH
59510: LD_VAR 0 2
59514: PPUSH
59515: LD_EXP 26
59519: PUSH
59520: LD_VAR 0 2
59524: ARRAY
59525: PUSH
59526: LD_VAR 0 4
59530: UNION
59531: PPUSH
59532: CALL_OW 1
59536: ST_TO_ADDR
59537: GO 59472
59539: POP
59540: POP
59541: GO 59454
59543: POP
59544: POP
// end ; if not mc_repair_vehicle [ i ] then
59545: LD_EXP 26
59549: PUSH
59550: LD_VAR 0 2
59554: ARRAY
59555: NOT
59556: IFFALSE 59560
// continue ;
59558: GO 59065
// for j in mc_repair_vehicle [ i ] do
59560: LD_ADDR_VAR 0 3
59564: PUSH
59565: LD_EXP 26
59569: PUSH
59570: LD_VAR 0 2
59574: ARRAY
59575: PUSH
59576: FOR_IN
59577: IFFALSE 59743
// begin if GetClass ( j ) <> 3 then
59579: LD_VAR 0 3
59583: PPUSH
59584: CALL_OW 257
59588: PUSH
59589: LD_INT 3
59591: NONEQUAL
59592: IFFALSE 59633
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
59594: LD_ADDR_EXP 26
59598: PUSH
59599: LD_EXP 26
59603: PPUSH
59604: LD_VAR 0 2
59608: PPUSH
59609: LD_EXP 26
59613: PUSH
59614: LD_VAR 0 2
59618: ARRAY
59619: PUSH
59620: LD_VAR 0 3
59624: DIFF
59625: PPUSH
59626: CALL_OW 1
59630: ST_TO_ADDR
// continue ;
59631: GO 59576
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
59633: LD_VAR 0 3
59637: PPUSH
59638: CALL_OW 311
59642: NOT
59643: PUSH
59644: LD_VAR 0 3
59648: PUSH
59649: LD_EXP 17
59653: PUSH
59654: LD_VAR 0 2
59658: ARRAY
59659: PUSH
59660: LD_INT 1
59662: ARRAY
59663: IN
59664: NOT
59665: AND
59666: PUSH
59667: LD_VAR 0 3
59671: PUSH
59672: LD_EXP 17
59676: PUSH
59677: LD_VAR 0 2
59681: ARRAY
59682: PUSH
59683: LD_INT 2
59685: ARRAY
59686: IN
59687: NOT
59688: AND
59689: IFFALSE 59741
// begin if IsInUnit ( j ) then
59691: LD_VAR 0 3
59695: PPUSH
59696: CALL_OW 310
59700: IFFALSE 59711
// ComExitBuilding ( j ) ;
59702: LD_VAR 0 3
59706: PPUSH
59707: CALL_OW 122
// if not HasTask ( j ) then
59711: LD_VAR 0 3
59715: PPUSH
59716: CALL_OW 314
59720: NOT
59721: IFFALSE 59741
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
59723: LD_VAR 0 3
59727: PPUSH
59728: LD_VAR 0 7
59732: PUSH
59733: LD_INT 1
59735: ARRAY
59736: PPUSH
59737: CALL_OW 189
// end ; end ;
59741: GO 59576
59743: POP
59744: POP
// end ;
59745: GO 59065
59747: POP
59748: POP
// end ;
59749: LD_VAR 0 1
59753: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
59754: LD_INT 0
59756: PPUSH
59757: PPUSH
59758: PPUSH
59759: PPUSH
59760: PPUSH
59761: PPUSH
59762: PPUSH
59763: PPUSH
59764: PPUSH
59765: PPUSH
59766: PPUSH
// if not mc_bases then
59767: LD_EXP 14
59771: NOT
59772: IFFALSE 59776
// exit ;
59774: GO 60578
// for i = 1 to mc_bases do
59776: LD_ADDR_VAR 0 2
59780: PUSH
59781: DOUBLE
59782: LD_INT 1
59784: DEC
59785: ST_TO_ADDR
59786: LD_EXP 14
59790: PUSH
59791: FOR_TO
59792: IFFALSE 60576
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
59794: LD_EXP 42
59798: PUSH
59799: LD_VAR 0 2
59803: ARRAY
59804: NOT
59805: PUSH
59806: LD_EXP 17
59810: PUSH
59811: LD_VAR 0 2
59815: ARRAY
59816: PUSH
59817: LD_INT 1
59819: ARRAY
59820: OR
59821: PUSH
59822: LD_EXP 17
59826: PUSH
59827: LD_VAR 0 2
59831: ARRAY
59832: PUSH
59833: LD_INT 2
59835: ARRAY
59836: OR
59837: PUSH
59838: LD_EXP 40
59842: PUSH
59843: LD_VAR 0 2
59847: ARRAY
59848: PPUSH
59849: LD_INT 1
59851: PPUSH
59852: CALL_OW 325
59856: NOT
59857: OR
59858: PUSH
59859: LD_EXP 37
59863: PUSH
59864: LD_VAR 0 2
59868: ARRAY
59869: OR
59870: IFFALSE 59874
// continue ;
59872: GO 59791
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
59874: LD_ADDR_VAR 0 8
59878: PUSH
59879: LD_EXP 14
59883: PUSH
59884: LD_VAR 0 2
59888: ARRAY
59889: PPUSH
59890: LD_INT 25
59892: PUSH
59893: LD_INT 4
59895: PUSH
59896: EMPTY
59897: LIST
59898: LIST
59899: PUSH
59900: LD_INT 50
59902: PUSH
59903: EMPTY
59904: LIST
59905: PUSH
59906: LD_INT 3
59908: PUSH
59909: LD_INT 60
59911: PUSH
59912: EMPTY
59913: LIST
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PUSH
59919: EMPTY
59920: LIST
59921: LIST
59922: LIST
59923: PPUSH
59924: CALL_OW 72
59928: PUSH
59929: LD_EXP 18
59933: PUSH
59934: LD_VAR 0 2
59938: ARRAY
59939: DIFF
59940: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59941: LD_ADDR_VAR 0 9
59945: PUSH
59946: LD_EXP 14
59950: PUSH
59951: LD_VAR 0 2
59955: ARRAY
59956: PPUSH
59957: LD_INT 2
59959: PUSH
59960: LD_INT 30
59962: PUSH
59963: LD_INT 0
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: PUSH
59970: LD_INT 30
59972: PUSH
59973: LD_INT 1
59975: PUSH
59976: EMPTY
59977: LIST
59978: LIST
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: LIST
59984: PPUSH
59985: CALL_OW 72
59989: ST_TO_ADDR
// if not tmp or not dep then
59990: LD_VAR 0 8
59994: NOT
59995: PUSH
59996: LD_VAR 0 9
60000: NOT
60001: OR
60002: IFFALSE 60006
// continue ;
60004: GO 59791
// side := GetSide ( tmp [ 1 ] ) ;
60006: LD_ADDR_VAR 0 11
60010: PUSH
60011: LD_VAR 0 8
60015: PUSH
60016: LD_INT 1
60018: ARRAY
60019: PPUSH
60020: CALL_OW 255
60024: ST_TO_ADDR
// dep := dep [ 1 ] ;
60025: LD_ADDR_VAR 0 9
60029: PUSH
60030: LD_VAR 0 9
60034: PUSH
60035: LD_INT 1
60037: ARRAY
60038: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
60039: LD_ADDR_VAR 0 7
60043: PUSH
60044: LD_EXP 42
60048: PUSH
60049: LD_VAR 0 2
60053: ARRAY
60054: PPUSH
60055: LD_INT 22
60057: PUSH
60058: LD_INT 0
60060: PUSH
60061: EMPTY
60062: LIST
60063: LIST
60064: PUSH
60065: LD_INT 25
60067: PUSH
60068: LD_INT 12
60070: PUSH
60071: EMPTY
60072: LIST
60073: LIST
60074: PUSH
60075: EMPTY
60076: LIST
60077: LIST
60078: PPUSH
60079: CALL_OW 70
60083: PUSH
60084: LD_INT 22
60086: PUSH
60087: LD_INT 0
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PUSH
60094: LD_INT 25
60096: PUSH
60097: LD_INT 12
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PUSH
60104: LD_INT 91
60106: PUSH
60107: LD_VAR 0 9
60111: PUSH
60112: LD_INT 20
60114: PUSH
60115: EMPTY
60116: LIST
60117: LIST
60118: LIST
60119: PUSH
60120: EMPTY
60121: LIST
60122: LIST
60123: LIST
60124: PPUSH
60125: CALL_OW 69
60129: UNION
60130: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
60131: LD_ADDR_VAR 0 10
60135: PUSH
60136: LD_EXP 42
60140: PUSH
60141: LD_VAR 0 2
60145: ARRAY
60146: PPUSH
60147: LD_INT 81
60149: PUSH
60150: LD_VAR 0 11
60154: PUSH
60155: EMPTY
60156: LIST
60157: LIST
60158: PPUSH
60159: CALL_OW 70
60163: ST_TO_ADDR
// if not apes or danger_at_area then
60164: LD_VAR 0 7
60168: NOT
60169: PUSH
60170: LD_VAR 0 10
60174: OR
60175: IFFALSE 60225
// begin if mc_taming [ i ] then
60177: LD_EXP 45
60181: PUSH
60182: LD_VAR 0 2
60186: ARRAY
60187: IFFALSE 60223
// begin MC_Reset ( i , 121 ) ;
60189: LD_VAR 0 2
60193: PPUSH
60194: LD_INT 121
60196: PPUSH
60197: CALL 45628 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60201: LD_ADDR_EXP 45
60205: PUSH
60206: LD_EXP 45
60210: PPUSH
60211: LD_VAR 0 2
60215: PPUSH
60216: EMPTY
60217: PPUSH
60218: CALL_OW 1
60222: ST_TO_ADDR
// end ; continue ;
60223: GO 59791
// end ; for j in tmp do
60225: LD_ADDR_VAR 0 3
60229: PUSH
60230: LD_VAR 0 8
60234: PUSH
60235: FOR_IN
60236: IFFALSE 60572
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
60238: LD_VAR 0 3
60242: PUSH
60243: LD_EXP 45
60247: PUSH
60248: LD_VAR 0 2
60252: ARRAY
60253: IN
60254: NOT
60255: PUSH
60256: LD_EXP 45
60260: PUSH
60261: LD_VAR 0 2
60265: ARRAY
60266: PUSH
60267: LD_INT 3
60269: LESS
60270: AND
60271: IFFALSE 60329
// begin SetTag ( j , 121 ) ;
60273: LD_VAR 0 3
60277: PPUSH
60278: LD_INT 121
60280: PPUSH
60281: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
60285: LD_ADDR_EXP 45
60289: PUSH
60290: LD_EXP 45
60294: PPUSH
60295: LD_VAR 0 2
60299: PUSH
60300: LD_EXP 45
60304: PUSH
60305: LD_VAR 0 2
60309: ARRAY
60310: PUSH
60311: LD_INT 1
60313: PLUS
60314: PUSH
60315: EMPTY
60316: LIST
60317: LIST
60318: PPUSH
60319: LD_VAR 0 3
60323: PPUSH
60324: CALL 9427 0 3
60328: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
60329: LD_VAR 0 3
60333: PUSH
60334: LD_EXP 45
60338: PUSH
60339: LD_VAR 0 2
60343: ARRAY
60344: IN
60345: IFFALSE 60570
// begin if GetClass ( j ) <> 4 then
60347: LD_VAR 0 3
60351: PPUSH
60352: CALL_OW 257
60356: PUSH
60357: LD_INT 4
60359: NONEQUAL
60360: IFFALSE 60413
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
60362: LD_ADDR_EXP 45
60366: PUSH
60367: LD_EXP 45
60371: PPUSH
60372: LD_VAR 0 2
60376: PPUSH
60377: LD_EXP 45
60381: PUSH
60382: LD_VAR 0 2
60386: ARRAY
60387: PUSH
60388: LD_VAR 0 3
60392: DIFF
60393: PPUSH
60394: CALL_OW 1
60398: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60399: LD_VAR 0 3
60403: PPUSH
60404: LD_INT 0
60406: PPUSH
60407: CALL_OW 109
// continue ;
60411: GO 60235
// end ; if IsInUnit ( j ) then
60413: LD_VAR 0 3
60417: PPUSH
60418: CALL_OW 310
60422: IFFALSE 60433
// ComExitBuilding ( j ) ;
60424: LD_VAR 0 3
60428: PPUSH
60429: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
60433: LD_ADDR_VAR 0 6
60437: PUSH
60438: LD_VAR 0 7
60442: PPUSH
60443: LD_VAR 0 3
60447: PPUSH
60448: CALL_OW 74
60452: ST_TO_ADDR
// if not ape then
60453: LD_VAR 0 6
60457: NOT
60458: IFFALSE 60462
// break ;
60460: GO 60572
// x := GetX ( ape ) ;
60462: LD_ADDR_VAR 0 4
60466: PUSH
60467: LD_VAR 0 6
60471: PPUSH
60472: CALL_OW 250
60476: ST_TO_ADDR
// y := GetY ( ape ) ;
60477: LD_ADDR_VAR 0 5
60481: PUSH
60482: LD_VAR 0 6
60486: PPUSH
60487: CALL_OW 251
60491: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60492: LD_VAR 0 4
60496: PPUSH
60497: LD_VAR 0 5
60501: PPUSH
60502: CALL_OW 488
60506: NOT
60507: PUSH
60508: LD_VAR 0 11
60512: PPUSH
60513: LD_VAR 0 4
60517: PPUSH
60518: LD_VAR 0 5
60522: PPUSH
60523: LD_INT 20
60525: PPUSH
60526: CALL 10323 0 4
60530: PUSH
60531: LD_INT 4
60533: ARRAY
60534: OR
60535: IFFALSE 60539
// break ;
60537: GO 60572
// if not HasTask ( j ) then
60539: LD_VAR 0 3
60543: PPUSH
60544: CALL_OW 314
60548: NOT
60549: IFFALSE 60570
// ComTameXY ( j , x , y ) ;
60551: LD_VAR 0 3
60555: PPUSH
60556: LD_VAR 0 4
60560: PPUSH
60561: LD_VAR 0 5
60565: PPUSH
60566: CALL_OW 131
// end ; end ;
60570: GO 60235
60572: POP
60573: POP
// end ;
60574: GO 59791
60576: POP
60577: POP
// end ;
60578: LD_VAR 0 1
60582: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
60583: LD_INT 0
60585: PPUSH
60586: PPUSH
60587: PPUSH
60588: PPUSH
60589: PPUSH
60590: PPUSH
60591: PPUSH
60592: PPUSH
// if not mc_bases then
60593: LD_EXP 14
60597: NOT
60598: IFFALSE 60602
// exit ;
60600: GO 61228
// for i = 1 to mc_bases do
60602: LD_ADDR_VAR 0 2
60606: PUSH
60607: DOUBLE
60608: LD_INT 1
60610: DEC
60611: ST_TO_ADDR
60612: LD_EXP 14
60616: PUSH
60617: FOR_TO
60618: IFFALSE 61226
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
60620: LD_EXP 43
60624: PUSH
60625: LD_VAR 0 2
60629: ARRAY
60630: NOT
60631: PUSH
60632: LD_EXP 43
60636: PUSH
60637: LD_VAR 0 2
60641: ARRAY
60642: PPUSH
60643: LD_INT 25
60645: PUSH
60646: LD_INT 12
60648: PUSH
60649: EMPTY
60650: LIST
60651: LIST
60652: PPUSH
60653: CALL_OW 72
60657: NOT
60658: OR
60659: IFFALSE 60663
// continue ;
60661: GO 60617
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
60663: LD_ADDR_VAR 0 5
60667: PUSH
60668: LD_EXP 43
60672: PUSH
60673: LD_VAR 0 2
60677: ARRAY
60678: PUSH
60679: LD_INT 1
60681: ARRAY
60682: PPUSH
60683: CALL_OW 255
60687: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
60688: LD_VAR 0 5
60692: PPUSH
60693: LD_INT 2
60695: PPUSH
60696: CALL_OW 325
60700: IFFALSE 60953
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60702: LD_ADDR_VAR 0 4
60706: PUSH
60707: LD_EXP 43
60711: PUSH
60712: LD_VAR 0 2
60716: ARRAY
60717: PPUSH
60718: LD_INT 25
60720: PUSH
60721: LD_INT 16
60723: PUSH
60724: EMPTY
60725: LIST
60726: LIST
60727: PPUSH
60728: CALL_OW 72
60732: ST_TO_ADDR
// if tmp < 6 then
60733: LD_VAR 0 4
60737: PUSH
60738: LD_INT 6
60740: LESS
60741: IFFALSE 60953
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60743: LD_ADDR_VAR 0 6
60747: PUSH
60748: LD_EXP 14
60752: PUSH
60753: LD_VAR 0 2
60757: ARRAY
60758: PPUSH
60759: LD_INT 2
60761: PUSH
60762: LD_INT 30
60764: PUSH
60765: LD_INT 0
60767: PUSH
60768: EMPTY
60769: LIST
60770: LIST
60771: PUSH
60772: LD_INT 30
60774: PUSH
60775: LD_INT 1
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: LIST
60786: PPUSH
60787: CALL_OW 72
60791: ST_TO_ADDR
// if depot then
60792: LD_VAR 0 6
60796: IFFALSE 60953
// begin selected := 0 ;
60798: LD_ADDR_VAR 0 7
60802: PUSH
60803: LD_INT 0
60805: ST_TO_ADDR
// for j in depot do
60806: LD_ADDR_VAR 0 3
60810: PUSH
60811: LD_VAR 0 6
60815: PUSH
60816: FOR_IN
60817: IFFALSE 60848
// begin if UnitsInside ( j ) < 6 then
60819: LD_VAR 0 3
60823: PPUSH
60824: CALL_OW 313
60828: PUSH
60829: LD_INT 6
60831: LESS
60832: IFFALSE 60846
// begin selected := j ;
60834: LD_ADDR_VAR 0 7
60838: PUSH
60839: LD_VAR 0 3
60843: ST_TO_ADDR
// break ;
60844: GO 60848
// end ; end ;
60846: GO 60816
60848: POP
60849: POP
// if selected then
60850: LD_VAR 0 7
60854: IFFALSE 60953
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
60856: LD_ADDR_VAR 0 3
60860: PUSH
60861: LD_EXP 43
60865: PUSH
60866: LD_VAR 0 2
60870: ARRAY
60871: PPUSH
60872: LD_INT 25
60874: PUSH
60875: LD_INT 12
60877: PUSH
60878: EMPTY
60879: LIST
60880: LIST
60881: PPUSH
60882: CALL_OW 72
60886: PUSH
60887: FOR_IN
60888: IFFALSE 60951
// if not HasTask ( j ) then
60890: LD_VAR 0 3
60894: PPUSH
60895: CALL_OW 314
60899: NOT
60900: IFFALSE 60949
// begin if not IsInUnit ( j ) then
60902: LD_VAR 0 3
60906: PPUSH
60907: CALL_OW 310
60911: NOT
60912: IFFALSE 60928
// ComEnterUnit ( j , selected ) ;
60914: LD_VAR 0 3
60918: PPUSH
60919: LD_VAR 0 7
60923: PPUSH
60924: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
60928: LD_VAR 0 3
60932: PPUSH
60933: LD_INT 16
60935: PPUSH
60936: CALL_OW 183
// AddComExitBuilding ( j ) ;
60940: LD_VAR 0 3
60944: PPUSH
60945: CALL_OW 182
// end ;
60949: GO 60887
60951: POP
60952: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
60953: LD_VAR 0 5
60957: PPUSH
60958: LD_INT 11
60960: PPUSH
60961: CALL_OW 325
60965: IFFALSE 61224
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60967: LD_ADDR_VAR 0 4
60971: PUSH
60972: LD_EXP 43
60976: PUSH
60977: LD_VAR 0 2
60981: ARRAY
60982: PPUSH
60983: LD_INT 25
60985: PUSH
60986: LD_INT 16
60988: PUSH
60989: EMPTY
60990: LIST
60991: LIST
60992: PPUSH
60993: CALL_OW 72
60997: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
60998: LD_VAR 0 4
61002: PUSH
61003: LD_INT 6
61005: GREATEREQUAL
61006: PUSH
61007: LD_VAR 0 5
61011: PPUSH
61012: LD_INT 2
61014: PPUSH
61015: CALL_OW 325
61019: NOT
61020: OR
61021: IFFALSE 61224
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61023: LD_ADDR_VAR 0 8
61027: PUSH
61028: LD_EXP 14
61032: PUSH
61033: LD_VAR 0 2
61037: ARRAY
61038: PPUSH
61039: LD_INT 2
61041: PUSH
61042: LD_INT 30
61044: PUSH
61045: LD_INT 4
61047: PUSH
61048: EMPTY
61049: LIST
61050: LIST
61051: PUSH
61052: LD_INT 30
61054: PUSH
61055: LD_INT 5
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PUSH
61062: EMPTY
61063: LIST
61064: LIST
61065: LIST
61066: PPUSH
61067: CALL_OW 72
61071: ST_TO_ADDR
// if barracks then
61072: LD_VAR 0 8
61076: IFFALSE 61224
// begin selected := 0 ;
61078: LD_ADDR_VAR 0 7
61082: PUSH
61083: LD_INT 0
61085: ST_TO_ADDR
// for j in barracks do
61086: LD_ADDR_VAR 0 3
61090: PUSH
61091: LD_VAR 0 8
61095: PUSH
61096: FOR_IN
61097: IFFALSE 61128
// begin if UnitsInside ( j ) < 6 then
61099: LD_VAR 0 3
61103: PPUSH
61104: CALL_OW 313
61108: PUSH
61109: LD_INT 6
61111: LESS
61112: IFFALSE 61126
// begin selected := j ;
61114: LD_ADDR_VAR 0 7
61118: PUSH
61119: LD_VAR 0 3
61123: ST_TO_ADDR
// break ;
61124: GO 61128
// end ; end ;
61126: GO 61096
61128: POP
61129: POP
// if selected then
61130: LD_VAR 0 7
61134: IFFALSE 61224
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
61136: LD_ADDR_VAR 0 3
61140: PUSH
61141: LD_EXP 43
61145: PUSH
61146: LD_VAR 0 2
61150: ARRAY
61151: PPUSH
61152: LD_INT 25
61154: PUSH
61155: LD_INT 12
61157: PUSH
61158: EMPTY
61159: LIST
61160: LIST
61161: PPUSH
61162: CALL_OW 72
61166: PUSH
61167: FOR_IN
61168: IFFALSE 61222
// if not IsInUnit ( j ) and not HasTask ( j ) then
61170: LD_VAR 0 3
61174: PPUSH
61175: CALL_OW 310
61179: NOT
61180: PUSH
61181: LD_VAR 0 3
61185: PPUSH
61186: CALL_OW 314
61190: NOT
61191: AND
61192: IFFALSE 61220
// begin ComEnterUnit ( j , selected ) ;
61194: LD_VAR 0 3
61198: PPUSH
61199: LD_VAR 0 7
61203: PPUSH
61204: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
61208: LD_VAR 0 3
61212: PPUSH
61213: LD_INT 15
61215: PPUSH
61216: CALL_OW 183
// end ;
61220: GO 61167
61222: POP
61223: POP
// end ; end ; end ; end ; end ;
61224: GO 60617
61226: POP
61227: POP
// end ;
61228: LD_VAR 0 1
61232: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
61233: LD_INT 0
61235: PPUSH
61236: PPUSH
61237: PPUSH
61238: PPUSH
// if not mc_bases then
61239: LD_EXP 14
61243: NOT
61244: IFFALSE 61248
// exit ;
61246: GO 61426
// for i = 1 to mc_bases do
61248: LD_ADDR_VAR 0 2
61252: PUSH
61253: DOUBLE
61254: LD_INT 1
61256: DEC
61257: ST_TO_ADDR
61258: LD_EXP 14
61262: PUSH
61263: FOR_TO
61264: IFFALSE 61424
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
61266: LD_ADDR_VAR 0 4
61270: PUSH
61271: LD_EXP 14
61275: PUSH
61276: LD_VAR 0 2
61280: ARRAY
61281: PPUSH
61282: LD_INT 25
61284: PUSH
61285: LD_INT 9
61287: PUSH
61288: EMPTY
61289: LIST
61290: LIST
61291: PPUSH
61292: CALL_OW 72
61296: ST_TO_ADDR
// if not tmp then
61297: LD_VAR 0 4
61301: NOT
61302: IFFALSE 61306
// continue ;
61304: GO 61263
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
61306: LD_EXP 40
61310: PUSH
61311: LD_VAR 0 2
61315: ARRAY
61316: PPUSH
61317: LD_INT 29
61319: PPUSH
61320: CALL_OW 325
61324: NOT
61325: PUSH
61326: LD_EXP 40
61330: PUSH
61331: LD_VAR 0 2
61335: ARRAY
61336: PPUSH
61337: LD_INT 28
61339: PPUSH
61340: CALL_OW 325
61344: NOT
61345: AND
61346: IFFALSE 61350
// continue ;
61348: GO 61263
// for j in tmp do
61350: LD_ADDR_VAR 0 3
61354: PUSH
61355: LD_VAR 0 4
61359: PUSH
61360: FOR_IN
61361: IFFALSE 61420
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
61363: LD_VAR 0 3
61367: PUSH
61368: LD_EXP 17
61372: PUSH
61373: LD_VAR 0 2
61377: ARRAY
61378: PUSH
61379: LD_INT 1
61381: ARRAY
61382: IN
61383: NOT
61384: PUSH
61385: LD_VAR 0 3
61389: PUSH
61390: LD_EXP 17
61394: PUSH
61395: LD_VAR 0 2
61399: ARRAY
61400: PUSH
61401: LD_INT 2
61403: ARRAY
61404: IN
61405: NOT
61406: AND
61407: IFFALSE 61418
// ComSpaceTimeShoot ( j ) ;
61409: LD_VAR 0 3
61413: PPUSH
61414: CALL 5424 0 1
61418: GO 61360
61420: POP
61421: POP
// end ;
61422: GO 61263
61424: POP
61425: POP
// end ;
61426: LD_VAR 0 1
61430: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
61431: LD_INT 0
61433: PPUSH
61434: PPUSH
61435: PPUSH
61436: PPUSH
61437: PPUSH
61438: PPUSH
61439: PPUSH
61440: PPUSH
61441: PPUSH
// if not mc_bases then
61442: LD_EXP 14
61446: NOT
61447: IFFALSE 61451
// exit ;
61449: GO 62073
// for i = 1 to mc_bases do
61451: LD_ADDR_VAR 0 2
61455: PUSH
61456: DOUBLE
61457: LD_INT 1
61459: DEC
61460: ST_TO_ADDR
61461: LD_EXP 14
61465: PUSH
61466: FOR_TO
61467: IFFALSE 62071
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
61469: LD_EXP 49
61473: PUSH
61474: LD_VAR 0 2
61478: ARRAY
61479: NOT
61480: PUSH
61481: LD_INT 38
61483: PPUSH
61484: LD_EXP 40
61488: PUSH
61489: LD_VAR 0 2
61493: ARRAY
61494: PPUSH
61495: CALL_OW 321
61499: PUSH
61500: LD_INT 2
61502: NONEQUAL
61503: OR
61504: IFFALSE 61508
// continue ;
61506: GO 61466
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
61508: LD_ADDR_VAR 0 8
61512: PUSH
61513: LD_EXP 14
61517: PUSH
61518: LD_VAR 0 2
61522: ARRAY
61523: PPUSH
61524: LD_INT 30
61526: PUSH
61527: LD_INT 34
61529: PUSH
61530: EMPTY
61531: LIST
61532: LIST
61533: PPUSH
61534: CALL_OW 72
61538: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
61539: LD_ADDR_VAR 0 9
61543: PUSH
61544: LD_EXP 14
61548: PUSH
61549: LD_VAR 0 2
61553: ARRAY
61554: PPUSH
61555: LD_INT 25
61557: PUSH
61558: LD_INT 4
61560: PUSH
61561: EMPTY
61562: LIST
61563: LIST
61564: PPUSH
61565: CALL_OW 72
61569: PPUSH
61570: LD_INT 0
61572: PPUSH
61573: CALL 37988 0 2
61577: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
61578: LD_VAR 0 9
61582: NOT
61583: PUSH
61584: LD_VAR 0 8
61588: NOT
61589: OR
61590: PUSH
61591: LD_EXP 14
61595: PUSH
61596: LD_VAR 0 2
61600: ARRAY
61601: PPUSH
61602: LD_INT 124
61604: PPUSH
61605: CALL 37988 0 2
61609: OR
61610: IFFALSE 61614
// continue ;
61612: GO 61466
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
61614: LD_EXP 50
61618: PUSH
61619: LD_VAR 0 2
61623: ARRAY
61624: PUSH
61625: LD_EXP 49
61629: PUSH
61630: LD_VAR 0 2
61634: ARRAY
61635: LESS
61636: PUSH
61637: LD_EXP 50
61641: PUSH
61642: LD_VAR 0 2
61646: ARRAY
61647: PUSH
61648: LD_VAR 0 8
61652: LESS
61653: AND
61654: IFFALSE 62069
// begin tmp := sci [ 1 ] ;
61656: LD_ADDR_VAR 0 7
61660: PUSH
61661: LD_VAR 0 9
61665: PUSH
61666: LD_INT 1
61668: ARRAY
61669: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
61670: LD_VAR 0 7
61674: PPUSH
61675: LD_INT 124
61677: PPUSH
61678: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
61682: LD_ADDR_VAR 0 3
61686: PUSH
61687: DOUBLE
61688: LD_EXP 49
61692: PUSH
61693: LD_VAR 0 2
61697: ARRAY
61698: INC
61699: ST_TO_ADDR
61700: LD_EXP 49
61704: PUSH
61705: LD_VAR 0 2
61709: ARRAY
61710: PUSH
61711: FOR_DOWNTO
61712: IFFALSE 62055
// begin if IsInUnit ( tmp ) then
61714: LD_VAR 0 7
61718: PPUSH
61719: CALL_OW 310
61723: IFFALSE 61734
// ComExitBuilding ( tmp ) ;
61725: LD_VAR 0 7
61729: PPUSH
61730: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
61734: LD_INT 35
61736: PPUSH
61737: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
61741: LD_VAR 0 7
61745: PPUSH
61746: CALL_OW 310
61750: NOT
61751: PUSH
61752: LD_VAR 0 7
61756: PPUSH
61757: CALL_OW 314
61761: NOT
61762: AND
61763: IFFALSE 61734
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
61765: LD_ADDR_VAR 0 6
61769: PUSH
61770: LD_VAR 0 7
61774: PPUSH
61775: CALL_OW 250
61779: PUSH
61780: LD_VAR 0 7
61784: PPUSH
61785: CALL_OW 251
61789: PUSH
61790: EMPTY
61791: LIST
61792: LIST
61793: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
61794: LD_INT 35
61796: PPUSH
61797: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
61801: LD_ADDR_VAR 0 4
61805: PUSH
61806: LD_EXP 49
61810: PUSH
61811: LD_VAR 0 2
61815: ARRAY
61816: PUSH
61817: LD_VAR 0 3
61821: ARRAY
61822: PUSH
61823: LD_INT 1
61825: ARRAY
61826: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
61827: LD_ADDR_VAR 0 5
61831: PUSH
61832: LD_EXP 49
61836: PUSH
61837: LD_VAR 0 2
61841: ARRAY
61842: PUSH
61843: LD_VAR 0 3
61847: ARRAY
61848: PUSH
61849: LD_INT 2
61851: ARRAY
61852: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
61853: LD_VAR 0 7
61857: PPUSH
61858: LD_INT 10
61860: PPUSH
61861: CALL 12020 0 2
61865: PUSH
61866: LD_INT 4
61868: ARRAY
61869: IFFALSE 61907
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
61871: LD_VAR 0 7
61875: PPUSH
61876: LD_VAR 0 6
61880: PUSH
61881: LD_INT 1
61883: ARRAY
61884: PPUSH
61885: LD_VAR 0 6
61889: PUSH
61890: LD_INT 2
61892: ARRAY
61893: PPUSH
61894: CALL_OW 111
// wait ( 0 0$10 ) ;
61898: LD_INT 350
61900: PPUSH
61901: CALL_OW 67
// end else
61905: GO 61933
// begin ComMoveXY ( tmp , x , y ) ;
61907: LD_VAR 0 7
61911: PPUSH
61912: LD_VAR 0 4
61916: PPUSH
61917: LD_VAR 0 5
61921: PPUSH
61922: CALL_OW 111
// wait ( 0 0$3 ) ;
61926: LD_INT 105
61928: PPUSH
61929: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
61933: LD_VAR 0 7
61937: PPUSH
61938: LD_VAR 0 4
61942: PPUSH
61943: LD_VAR 0 5
61947: PPUSH
61948: CALL_OW 307
61952: IFFALSE 61794
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
61954: LD_VAR 0 7
61958: PPUSH
61959: LD_VAR 0 4
61963: PPUSH
61964: LD_VAR 0 5
61968: PPUSH
61969: LD_VAR 0 8
61973: PUSH
61974: LD_VAR 0 3
61978: ARRAY
61979: PPUSH
61980: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
61984: LD_INT 35
61986: PPUSH
61987: CALL_OW 67
// until not HasTask ( tmp ) ;
61991: LD_VAR 0 7
61995: PPUSH
61996: CALL_OW 314
62000: NOT
62001: IFFALSE 61984
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
62003: LD_ADDR_EXP 50
62007: PUSH
62008: LD_EXP 50
62012: PPUSH
62013: LD_VAR 0 2
62017: PUSH
62018: LD_EXP 50
62022: PUSH
62023: LD_VAR 0 2
62027: ARRAY
62028: PUSH
62029: LD_INT 1
62031: PLUS
62032: PUSH
62033: EMPTY
62034: LIST
62035: LIST
62036: PPUSH
62037: LD_VAR 0 8
62041: PUSH
62042: LD_VAR 0 3
62046: ARRAY
62047: PPUSH
62048: CALL 9427 0 3
62052: ST_TO_ADDR
// end ;
62053: GO 61711
62055: POP
62056: POP
// MC_Reset ( i , 124 ) ;
62057: LD_VAR 0 2
62061: PPUSH
62062: LD_INT 124
62064: PPUSH
62065: CALL 45628 0 2
// end ; end ;
62069: GO 61466
62071: POP
62072: POP
// end ;
62073: LD_VAR 0 1
62077: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
62078: LD_INT 0
62080: PPUSH
62081: PPUSH
62082: PPUSH
// if not mc_bases then
62083: LD_EXP 14
62087: NOT
62088: IFFALSE 62092
// exit ;
62090: GO 62698
// for i = 1 to mc_bases do
62092: LD_ADDR_VAR 0 2
62096: PUSH
62097: DOUBLE
62098: LD_INT 1
62100: DEC
62101: ST_TO_ADDR
62102: LD_EXP 14
62106: PUSH
62107: FOR_TO
62108: IFFALSE 62696
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62110: LD_ADDR_VAR 0 3
62114: PUSH
62115: LD_EXP 14
62119: PUSH
62120: LD_VAR 0 2
62124: ARRAY
62125: PPUSH
62126: LD_INT 25
62128: PUSH
62129: LD_INT 4
62131: PUSH
62132: EMPTY
62133: LIST
62134: LIST
62135: PPUSH
62136: CALL_OW 72
62140: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62141: LD_VAR 0 3
62145: NOT
62146: PUSH
62147: LD_EXP 51
62151: PUSH
62152: LD_VAR 0 2
62156: ARRAY
62157: NOT
62158: OR
62159: PUSH
62160: LD_EXP 14
62164: PUSH
62165: LD_VAR 0 2
62169: ARRAY
62170: PPUSH
62171: LD_INT 2
62173: PUSH
62174: LD_INT 30
62176: PUSH
62177: LD_INT 0
62179: PUSH
62180: EMPTY
62181: LIST
62182: LIST
62183: PUSH
62184: LD_INT 30
62186: PUSH
62187: LD_INT 1
62189: PUSH
62190: EMPTY
62191: LIST
62192: LIST
62193: PUSH
62194: EMPTY
62195: LIST
62196: LIST
62197: LIST
62198: PPUSH
62199: CALL_OW 72
62203: NOT
62204: OR
62205: IFFALSE 62255
// begin if mc_deposits_finder [ i ] then
62207: LD_EXP 52
62211: PUSH
62212: LD_VAR 0 2
62216: ARRAY
62217: IFFALSE 62253
// begin MC_Reset ( i , 125 ) ;
62219: LD_VAR 0 2
62223: PPUSH
62224: LD_INT 125
62226: PPUSH
62227: CALL 45628 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62231: LD_ADDR_EXP 52
62235: PUSH
62236: LD_EXP 52
62240: PPUSH
62241: LD_VAR 0 2
62245: PPUSH
62246: EMPTY
62247: PPUSH
62248: CALL_OW 1
62252: ST_TO_ADDR
// end ; continue ;
62253: GO 62107
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
62255: LD_EXP 51
62259: PUSH
62260: LD_VAR 0 2
62264: ARRAY
62265: PUSH
62266: LD_INT 1
62268: ARRAY
62269: PUSH
62270: LD_INT 3
62272: ARRAY
62273: PUSH
62274: LD_INT 1
62276: EQUAL
62277: PUSH
62278: LD_INT 20
62280: PPUSH
62281: LD_EXP 40
62285: PUSH
62286: LD_VAR 0 2
62290: ARRAY
62291: PPUSH
62292: CALL_OW 321
62296: PUSH
62297: LD_INT 2
62299: NONEQUAL
62300: AND
62301: IFFALSE 62351
// begin if mc_deposits_finder [ i ] then
62303: LD_EXP 52
62307: PUSH
62308: LD_VAR 0 2
62312: ARRAY
62313: IFFALSE 62349
// begin MC_Reset ( i , 125 ) ;
62315: LD_VAR 0 2
62319: PPUSH
62320: LD_INT 125
62322: PPUSH
62323: CALL 45628 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62327: LD_ADDR_EXP 52
62331: PUSH
62332: LD_EXP 52
62336: PPUSH
62337: LD_VAR 0 2
62341: PPUSH
62342: EMPTY
62343: PPUSH
62344: CALL_OW 1
62348: ST_TO_ADDR
// end ; continue ;
62349: GO 62107
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
62351: LD_EXP 51
62355: PUSH
62356: LD_VAR 0 2
62360: ARRAY
62361: PUSH
62362: LD_INT 1
62364: ARRAY
62365: PUSH
62366: LD_INT 1
62368: ARRAY
62369: PPUSH
62370: LD_EXP 51
62374: PUSH
62375: LD_VAR 0 2
62379: ARRAY
62380: PUSH
62381: LD_INT 1
62383: ARRAY
62384: PUSH
62385: LD_INT 2
62387: ARRAY
62388: PPUSH
62389: LD_EXP 40
62393: PUSH
62394: LD_VAR 0 2
62398: ARRAY
62399: PPUSH
62400: CALL_OW 440
62404: IFFALSE 62447
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
62406: LD_ADDR_EXP 51
62410: PUSH
62411: LD_EXP 51
62415: PPUSH
62416: LD_VAR 0 2
62420: PPUSH
62421: LD_EXP 51
62425: PUSH
62426: LD_VAR 0 2
62430: ARRAY
62431: PPUSH
62432: LD_INT 1
62434: PPUSH
62435: CALL_OW 3
62439: PPUSH
62440: CALL_OW 1
62444: ST_TO_ADDR
62445: GO 62694
// begin if not mc_deposits_finder [ i ] then
62447: LD_EXP 52
62451: PUSH
62452: LD_VAR 0 2
62456: ARRAY
62457: NOT
62458: IFFALSE 62510
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
62460: LD_ADDR_EXP 52
62464: PUSH
62465: LD_EXP 52
62469: PPUSH
62470: LD_VAR 0 2
62474: PPUSH
62475: LD_VAR 0 3
62479: PUSH
62480: LD_INT 1
62482: ARRAY
62483: PUSH
62484: EMPTY
62485: LIST
62486: PPUSH
62487: CALL_OW 1
62491: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
62492: LD_VAR 0 3
62496: PUSH
62497: LD_INT 1
62499: ARRAY
62500: PPUSH
62501: LD_INT 125
62503: PPUSH
62504: CALL_OW 109
// end else
62508: GO 62694
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
62510: LD_EXP 52
62514: PUSH
62515: LD_VAR 0 2
62519: ARRAY
62520: PUSH
62521: LD_INT 1
62523: ARRAY
62524: PPUSH
62525: CALL_OW 310
62529: IFFALSE 62552
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
62531: LD_EXP 52
62535: PUSH
62536: LD_VAR 0 2
62540: ARRAY
62541: PUSH
62542: LD_INT 1
62544: ARRAY
62545: PPUSH
62546: CALL_OW 122
62550: GO 62694
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
62552: LD_EXP 52
62556: PUSH
62557: LD_VAR 0 2
62561: ARRAY
62562: PUSH
62563: LD_INT 1
62565: ARRAY
62566: PPUSH
62567: CALL_OW 314
62571: NOT
62572: PUSH
62573: LD_EXP 52
62577: PUSH
62578: LD_VAR 0 2
62582: ARRAY
62583: PUSH
62584: LD_INT 1
62586: ARRAY
62587: PPUSH
62588: LD_EXP 51
62592: PUSH
62593: LD_VAR 0 2
62597: ARRAY
62598: PUSH
62599: LD_INT 1
62601: ARRAY
62602: PUSH
62603: LD_INT 1
62605: ARRAY
62606: PPUSH
62607: LD_EXP 51
62611: PUSH
62612: LD_VAR 0 2
62616: ARRAY
62617: PUSH
62618: LD_INT 1
62620: ARRAY
62621: PUSH
62622: LD_INT 2
62624: ARRAY
62625: PPUSH
62626: CALL_OW 297
62630: PUSH
62631: LD_INT 6
62633: GREATER
62634: AND
62635: IFFALSE 62694
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
62637: LD_EXP 52
62641: PUSH
62642: LD_VAR 0 2
62646: ARRAY
62647: PUSH
62648: LD_INT 1
62650: ARRAY
62651: PPUSH
62652: LD_EXP 51
62656: PUSH
62657: LD_VAR 0 2
62661: ARRAY
62662: PUSH
62663: LD_INT 1
62665: ARRAY
62666: PUSH
62667: LD_INT 1
62669: ARRAY
62670: PPUSH
62671: LD_EXP 51
62675: PUSH
62676: LD_VAR 0 2
62680: ARRAY
62681: PUSH
62682: LD_INT 1
62684: ARRAY
62685: PUSH
62686: LD_INT 2
62688: ARRAY
62689: PPUSH
62690: CALL_OW 111
// end ; end ; end ;
62694: GO 62107
62696: POP
62697: POP
// end ;
62698: LD_VAR 0 1
62702: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
62703: LD_INT 0
62705: PPUSH
62706: PPUSH
62707: PPUSH
62708: PPUSH
62709: PPUSH
62710: PPUSH
62711: PPUSH
62712: PPUSH
62713: PPUSH
62714: PPUSH
62715: PPUSH
// if not mc_bases then
62716: LD_EXP 14
62720: NOT
62721: IFFALSE 62725
// exit ;
62723: GO 63665
// for i = 1 to mc_bases do
62725: LD_ADDR_VAR 0 2
62729: PUSH
62730: DOUBLE
62731: LD_INT 1
62733: DEC
62734: ST_TO_ADDR
62735: LD_EXP 14
62739: PUSH
62740: FOR_TO
62741: IFFALSE 63663
// begin if not mc_bases [ i ] or mc_scan [ i ] then
62743: LD_EXP 14
62747: PUSH
62748: LD_VAR 0 2
62752: ARRAY
62753: NOT
62754: PUSH
62755: LD_EXP 37
62759: PUSH
62760: LD_VAR 0 2
62764: ARRAY
62765: OR
62766: IFFALSE 62770
// continue ;
62768: GO 62740
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
62770: LD_ADDR_VAR 0 7
62774: PUSH
62775: LD_EXP 14
62779: PUSH
62780: LD_VAR 0 2
62784: ARRAY
62785: PUSH
62786: LD_INT 1
62788: ARRAY
62789: PPUSH
62790: CALL_OW 248
62794: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
62795: LD_VAR 0 7
62799: PUSH
62800: LD_INT 3
62802: EQUAL
62803: PUSH
62804: LD_EXP 33
62808: PUSH
62809: LD_VAR 0 2
62813: ARRAY
62814: PUSH
62815: LD_EXP 36
62819: PUSH
62820: LD_VAR 0 2
62824: ARRAY
62825: UNION
62826: PPUSH
62827: LD_INT 33
62829: PUSH
62830: LD_INT 2
62832: PUSH
62833: EMPTY
62834: LIST
62835: LIST
62836: PPUSH
62837: CALL_OW 72
62841: NOT
62842: OR
62843: IFFALSE 62847
// continue ;
62845: GO 62740
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
62847: LD_ADDR_VAR 0 9
62851: PUSH
62852: LD_EXP 14
62856: PUSH
62857: LD_VAR 0 2
62861: ARRAY
62862: PPUSH
62863: LD_INT 30
62865: PUSH
62866: LD_INT 36
62868: PUSH
62869: EMPTY
62870: LIST
62871: LIST
62872: PPUSH
62873: CALL_OW 72
62877: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
62878: LD_ADDR_VAR 0 10
62882: PUSH
62883: LD_EXP 33
62887: PUSH
62888: LD_VAR 0 2
62892: ARRAY
62893: PPUSH
62894: LD_INT 34
62896: PUSH
62897: LD_INT 31
62899: PUSH
62900: EMPTY
62901: LIST
62902: LIST
62903: PPUSH
62904: CALL_OW 72
62908: ST_TO_ADDR
// if not cts and not mcts then
62909: LD_VAR 0 9
62913: NOT
62914: PUSH
62915: LD_VAR 0 10
62919: NOT
62920: AND
62921: IFFALSE 62925
// continue ;
62923: GO 62740
// x := cts ;
62925: LD_ADDR_VAR 0 11
62929: PUSH
62930: LD_VAR 0 9
62934: ST_TO_ADDR
// if not x then
62935: LD_VAR 0 11
62939: NOT
62940: IFFALSE 62952
// x := mcts ;
62942: LD_ADDR_VAR 0 11
62946: PUSH
62947: LD_VAR 0 10
62951: ST_TO_ADDR
// if not x then
62952: LD_VAR 0 11
62956: NOT
62957: IFFALSE 62961
// continue ;
62959: GO 62740
// if mc_remote_driver [ i ] then
62961: LD_EXP 54
62965: PUSH
62966: LD_VAR 0 2
62970: ARRAY
62971: IFFALSE 63358
// for j in mc_remote_driver [ i ] do
62973: LD_ADDR_VAR 0 3
62977: PUSH
62978: LD_EXP 54
62982: PUSH
62983: LD_VAR 0 2
62987: ARRAY
62988: PUSH
62989: FOR_IN
62990: IFFALSE 63356
// begin if GetClass ( j ) <> 3 then
62992: LD_VAR 0 3
62996: PPUSH
62997: CALL_OW 257
63001: PUSH
63002: LD_INT 3
63004: NONEQUAL
63005: IFFALSE 63058
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
63007: LD_ADDR_EXP 54
63011: PUSH
63012: LD_EXP 54
63016: PPUSH
63017: LD_VAR 0 2
63021: PPUSH
63022: LD_EXP 54
63026: PUSH
63027: LD_VAR 0 2
63031: ARRAY
63032: PUSH
63033: LD_VAR 0 3
63037: DIFF
63038: PPUSH
63039: CALL_OW 1
63043: ST_TO_ADDR
// SetTag ( j , 0 ) ;
63044: LD_VAR 0 3
63048: PPUSH
63049: LD_INT 0
63051: PPUSH
63052: CALL_OW 109
// continue ;
63056: GO 62989
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
63058: LD_EXP 33
63062: PUSH
63063: LD_VAR 0 2
63067: ARRAY
63068: PPUSH
63069: LD_INT 34
63071: PUSH
63072: LD_INT 31
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: PUSH
63079: LD_INT 58
63081: PUSH
63082: EMPTY
63083: LIST
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: PPUSH
63089: CALL_OW 72
63093: PUSH
63094: LD_VAR 0 3
63098: PPUSH
63099: CALL 38076 0 1
63103: NOT
63104: AND
63105: IFFALSE 63176
// begin if IsInUnit ( j ) then
63107: LD_VAR 0 3
63111: PPUSH
63112: CALL_OW 310
63116: IFFALSE 63127
// ComExitBuilding ( j ) ;
63118: LD_VAR 0 3
63122: PPUSH
63123: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
63127: LD_VAR 0 3
63131: PPUSH
63132: LD_EXP 33
63136: PUSH
63137: LD_VAR 0 2
63141: ARRAY
63142: PPUSH
63143: LD_INT 34
63145: PUSH
63146: LD_INT 31
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: PUSH
63153: LD_INT 58
63155: PUSH
63156: EMPTY
63157: LIST
63158: PUSH
63159: EMPTY
63160: LIST
63161: LIST
63162: PPUSH
63163: CALL_OW 72
63167: PUSH
63168: LD_INT 1
63170: ARRAY
63171: PPUSH
63172: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
63176: LD_VAR 0 3
63180: PPUSH
63181: CALL_OW 310
63185: NOT
63186: PUSH
63187: LD_VAR 0 3
63191: PPUSH
63192: CALL_OW 310
63196: PPUSH
63197: CALL_OW 266
63201: PUSH
63202: LD_INT 36
63204: NONEQUAL
63205: PUSH
63206: LD_VAR 0 3
63210: PPUSH
63211: CALL 38076 0 1
63215: NOT
63216: AND
63217: OR
63218: IFFALSE 63354
// begin if IsInUnit ( j ) then
63220: LD_VAR 0 3
63224: PPUSH
63225: CALL_OW 310
63229: IFFALSE 63240
// ComExitBuilding ( j ) ;
63231: LD_VAR 0 3
63235: PPUSH
63236: CALL_OW 122
// ct := 0 ;
63240: LD_ADDR_VAR 0 8
63244: PUSH
63245: LD_INT 0
63247: ST_TO_ADDR
// for k in x do
63248: LD_ADDR_VAR 0 4
63252: PUSH
63253: LD_VAR 0 11
63257: PUSH
63258: FOR_IN
63259: IFFALSE 63332
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
63261: LD_VAR 0 4
63265: PPUSH
63266: CALL_OW 264
63270: PUSH
63271: LD_INT 31
63273: EQUAL
63274: PUSH
63275: LD_VAR 0 4
63279: PPUSH
63280: CALL_OW 311
63284: NOT
63285: AND
63286: PUSH
63287: LD_VAR 0 4
63291: PPUSH
63292: CALL_OW 266
63296: PUSH
63297: LD_INT 36
63299: EQUAL
63300: PUSH
63301: LD_VAR 0 4
63305: PPUSH
63306: CALL_OW 313
63310: PUSH
63311: LD_INT 3
63313: LESS
63314: AND
63315: OR
63316: IFFALSE 63330
// begin ct := k ;
63318: LD_ADDR_VAR 0 8
63322: PUSH
63323: LD_VAR 0 4
63327: ST_TO_ADDR
// break ;
63328: GO 63332
// end ;
63330: GO 63258
63332: POP
63333: POP
// if ct then
63334: LD_VAR 0 8
63338: IFFALSE 63354
// ComEnterUnit ( j , ct ) ;
63340: LD_VAR 0 3
63344: PPUSH
63345: LD_VAR 0 8
63349: PPUSH
63350: CALL_OW 120
// end ; end ;
63354: GO 62989
63356: POP
63357: POP
// places := 0 ;
63358: LD_ADDR_VAR 0 5
63362: PUSH
63363: LD_INT 0
63365: ST_TO_ADDR
// for j = 1 to x do
63366: LD_ADDR_VAR 0 3
63370: PUSH
63371: DOUBLE
63372: LD_INT 1
63374: DEC
63375: ST_TO_ADDR
63376: LD_VAR 0 11
63380: PUSH
63381: FOR_TO
63382: IFFALSE 63458
// if GetWeapon ( x [ j ] ) = ar_control_tower then
63384: LD_VAR 0 11
63388: PUSH
63389: LD_VAR 0 3
63393: ARRAY
63394: PPUSH
63395: CALL_OW 264
63399: PUSH
63400: LD_INT 31
63402: EQUAL
63403: IFFALSE 63421
// places := places + 1 else
63405: LD_ADDR_VAR 0 5
63409: PUSH
63410: LD_VAR 0 5
63414: PUSH
63415: LD_INT 1
63417: PLUS
63418: ST_TO_ADDR
63419: GO 63456
// if GetBType ( x [ j ] ) = b_control_tower then
63421: LD_VAR 0 11
63425: PUSH
63426: LD_VAR 0 3
63430: ARRAY
63431: PPUSH
63432: CALL_OW 266
63436: PUSH
63437: LD_INT 36
63439: EQUAL
63440: IFFALSE 63456
// places := places + 3 ;
63442: LD_ADDR_VAR 0 5
63446: PUSH
63447: LD_VAR 0 5
63451: PUSH
63452: LD_INT 3
63454: PLUS
63455: ST_TO_ADDR
63456: GO 63381
63458: POP
63459: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
63460: LD_VAR 0 5
63464: PUSH
63465: LD_INT 0
63467: EQUAL
63468: PUSH
63469: LD_VAR 0 5
63473: PUSH
63474: LD_EXP 54
63478: PUSH
63479: LD_VAR 0 2
63483: ARRAY
63484: LESSEQUAL
63485: OR
63486: IFFALSE 63490
// continue ;
63488: GO 62740
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
63490: LD_ADDR_VAR 0 6
63494: PUSH
63495: LD_EXP 14
63499: PUSH
63500: LD_VAR 0 2
63504: ARRAY
63505: PPUSH
63506: LD_INT 25
63508: PUSH
63509: LD_INT 3
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PPUSH
63516: CALL_OW 72
63520: PUSH
63521: LD_EXP 54
63525: PUSH
63526: LD_VAR 0 2
63530: ARRAY
63531: DIFF
63532: PPUSH
63533: LD_INT 3
63535: PPUSH
63536: CALL 38976 0 2
63540: ST_TO_ADDR
// for j in tmp do
63541: LD_ADDR_VAR 0 3
63545: PUSH
63546: LD_VAR 0 6
63550: PUSH
63551: FOR_IN
63552: IFFALSE 63587
// if GetTag ( j ) > 0 then
63554: LD_VAR 0 3
63558: PPUSH
63559: CALL_OW 110
63563: PUSH
63564: LD_INT 0
63566: GREATER
63567: IFFALSE 63585
// tmp := tmp diff j ;
63569: LD_ADDR_VAR 0 6
63573: PUSH
63574: LD_VAR 0 6
63578: PUSH
63579: LD_VAR 0 3
63583: DIFF
63584: ST_TO_ADDR
63585: GO 63551
63587: POP
63588: POP
// if not tmp then
63589: LD_VAR 0 6
63593: NOT
63594: IFFALSE 63598
// continue ;
63596: GO 62740
// if places then
63598: LD_VAR 0 5
63602: IFFALSE 63661
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
63604: LD_ADDR_EXP 54
63608: PUSH
63609: LD_EXP 54
63613: PPUSH
63614: LD_VAR 0 2
63618: PPUSH
63619: LD_EXP 54
63623: PUSH
63624: LD_VAR 0 2
63628: ARRAY
63629: PUSH
63630: LD_VAR 0 6
63634: PUSH
63635: LD_INT 1
63637: ARRAY
63638: UNION
63639: PPUSH
63640: CALL_OW 1
63644: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
63645: LD_VAR 0 6
63649: PUSH
63650: LD_INT 1
63652: ARRAY
63653: PPUSH
63654: LD_INT 126
63656: PPUSH
63657: CALL_OW 109
// end ; end ;
63661: GO 62740
63663: POP
63664: POP
// end ;
63665: LD_VAR 0 1
63669: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
63670: LD_INT 0
63672: PPUSH
63673: PPUSH
63674: PPUSH
63675: PPUSH
63676: PPUSH
63677: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
63678: LD_VAR 0 1
63682: NOT
63683: PUSH
63684: LD_VAR 0 2
63688: NOT
63689: OR
63690: PUSH
63691: LD_VAR 0 3
63695: NOT
63696: OR
63697: PUSH
63698: LD_VAR 0 4
63702: PUSH
63703: LD_INT 1
63705: PUSH
63706: LD_INT 2
63708: PUSH
63709: LD_INT 3
63711: PUSH
63712: LD_INT 4
63714: PUSH
63715: LD_INT 5
63717: PUSH
63718: LD_INT 8
63720: PUSH
63721: LD_INT 9
63723: PUSH
63724: LD_INT 15
63726: PUSH
63727: LD_INT 16
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: LIST
63734: LIST
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: IN
63741: NOT
63742: OR
63743: IFFALSE 63747
// exit ;
63745: GO 64647
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
63747: LD_ADDR_VAR 0 2
63751: PUSH
63752: LD_VAR 0 2
63756: PPUSH
63757: LD_INT 21
63759: PUSH
63760: LD_INT 3
63762: PUSH
63763: EMPTY
63764: LIST
63765: LIST
63766: PUSH
63767: LD_INT 24
63769: PUSH
63770: LD_INT 250
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: EMPTY
63778: LIST
63779: LIST
63780: PPUSH
63781: CALL_OW 72
63785: ST_TO_ADDR
// case class of 1 , 15 :
63786: LD_VAR 0 4
63790: PUSH
63791: LD_INT 1
63793: DOUBLE
63794: EQUAL
63795: IFTRUE 63805
63797: LD_INT 15
63799: DOUBLE
63800: EQUAL
63801: IFTRUE 63805
63803: GO 63890
63805: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
63806: LD_ADDR_VAR 0 8
63810: PUSH
63811: LD_VAR 0 2
63815: PPUSH
63816: LD_INT 2
63818: PUSH
63819: LD_INT 30
63821: PUSH
63822: LD_INT 32
63824: PUSH
63825: EMPTY
63826: LIST
63827: LIST
63828: PUSH
63829: LD_INT 30
63831: PUSH
63832: LD_INT 31
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: EMPTY
63840: LIST
63841: LIST
63842: LIST
63843: PPUSH
63844: CALL_OW 72
63848: PUSH
63849: LD_VAR 0 2
63853: PPUSH
63854: LD_INT 2
63856: PUSH
63857: LD_INT 30
63859: PUSH
63860: LD_INT 4
63862: PUSH
63863: EMPTY
63864: LIST
63865: LIST
63866: PUSH
63867: LD_INT 30
63869: PUSH
63870: LD_INT 5
63872: PUSH
63873: EMPTY
63874: LIST
63875: LIST
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: LIST
63881: PPUSH
63882: CALL_OW 72
63886: ADD
63887: ST_TO_ADDR
63888: GO 64136
63890: LD_INT 2
63892: DOUBLE
63893: EQUAL
63894: IFTRUE 63904
63896: LD_INT 16
63898: DOUBLE
63899: EQUAL
63900: IFTRUE 63904
63902: GO 63950
63904: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
63905: LD_ADDR_VAR 0 8
63909: PUSH
63910: LD_VAR 0 2
63914: PPUSH
63915: LD_INT 2
63917: PUSH
63918: LD_INT 30
63920: PUSH
63921: LD_INT 0
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: PUSH
63928: LD_INT 30
63930: PUSH
63931: LD_INT 1
63933: PUSH
63934: EMPTY
63935: LIST
63936: LIST
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: LIST
63942: PPUSH
63943: CALL_OW 72
63947: ST_TO_ADDR
63948: GO 64136
63950: LD_INT 3
63952: DOUBLE
63953: EQUAL
63954: IFTRUE 63958
63956: GO 64004
63958: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
63959: LD_ADDR_VAR 0 8
63963: PUSH
63964: LD_VAR 0 2
63968: PPUSH
63969: LD_INT 2
63971: PUSH
63972: LD_INT 30
63974: PUSH
63975: LD_INT 2
63977: PUSH
63978: EMPTY
63979: LIST
63980: LIST
63981: PUSH
63982: LD_INT 30
63984: PUSH
63985: LD_INT 3
63987: PUSH
63988: EMPTY
63989: LIST
63990: LIST
63991: PUSH
63992: EMPTY
63993: LIST
63994: LIST
63995: LIST
63996: PPUSH
63997: CALL_OW 72
64001: ST_TO_ADDR
64002: GO 64136
64004: LD_INT 4
64006: DOUBLE
64007: EQUAL
64008: IFTRUE 64012
64010: GO 64069
64012: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
64013: LD_ADDR_VAR 0 8
64017: PUSH
64018: LD_VAR 0 2
64022: PPUSH
64023: LD_INT 2
64025: PUSH
64026: LD_INT 30
64028: PUSH
64029: LD_INT 6
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: PUSH
64036: LD_INT 30
64038: PUSH
64039: LD_INT 7
64041: PUSH
64042: EMPTY
64043: LIST
64044: LIST
64045: PUSH
64046: LD_INT 30
64048: PUSH
64049: LD_INT 8
64051: PUSH
64052: EMPTY
64053: LIST
64054: LIST
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: LIST
64060: LIST
64061: PPUSH
64062: CALL_OW 72
64066: ST_TO_ADDR
64067: GO 64136
64069: LD_INT 5
64071: DOUBLE
64072: EQUAL
64073: IFTRUE 64089
64075: LD_INT 8
64077: DOUBLE
64078: EQUAL
64079: IFTRUE 64089
64081: LD_INT 9
64083: DOUBLE
64084: EQUAL
64085: IFTRUE 64089
64087: GO 64135
64089: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
64090: LD_ADDR_VAR 0 8
64094: PUSH
64095: LD_VAR 0 2
64099: PPUSH
64100: LD_INT 2
64102: PUSH
64103: LD_INT 30
64105: PUSH
64106: LD_INT 4
64108: PUSH
64109: EMPTY
64110: LIST
64111: LIST
64112: PUSH
64113: LD_INT 30
64115: PUSH
64116: LD_INT 5
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: LIST
64127: PPUSH
64128: CALL_OW 72
64132: ST_TO_ADDR
64133: GO 64136
64135: POP
// if not tmp then
64136: LD_VAR 0 8
64140: NOT
64141: IFFALSE 64145
// exit ;
64143: GO 64647
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
64145: LD_VAR 0 4
64149: PUSH
64150: LD_INT 1
64152: PUSH
64153: LD_INT 15
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: IN
64160: PUSH
64161: LD_EXP 23
64165: PUSH
64166: LD_VAR 0 1
64170: ARRAY
64171: AND
64172: IFFALSE 64328
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
64174: LD_ADDR_VAR 0 9
64178: PUSH
64179: LD_EXP 23
64183: PUSH
64184: LD_VAR 0 1
64188: ARRAY
64189: PUSH
64190: LD_INT 1
64192: ARRAY
64193: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
64194: LD_VAR 0 9
64198: PUSH
64199: LD_EXP 24
64203: PUSH
64204: LD_VAR 0 1
64208: ARRAY
64209: IN
64210: NOT
64211: IFFALSE 64326
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
64213: LD_ADDR_EXP 24
64217: PUSH
64218: LD_EXP 24
64222: PPUSH
64223: LD_VAR 0 1
64227: PUSH
64228: LD_EXP 24
64232: PUSH
64233: LD_VAR 0 1
64237: ARRAY
64238: PUSH
64239: LD_INT 1
64241: PLUS
64242: PUSH
64243: EMPTY
64244: LIST
64245: LIST
64246: PPUSH
64247: LD_VAR 0 9
64251: PPUSH
64252: CALL 9427 0 3
64256: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
64257: LD_ADDR_EXP 23
64261: PUSH
64262: LD_EXP 23
64266: PPUSH
64267: LD_VAR 0 1
64271: PPUSH
64272: LD_EXP 23
64276: PUSH
64277: LD_VAR 0 1
64281: ARRAY
64282: PUSH
64283: LD_VAR 0 9
64287: DIFF
64288: PPUSH
64289: CALL_OW 1
64293: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
64294: LD_VAR 0 3
64298: PPUSH
64299: LD_EXP 24
64303: PUSH
64304: LD_VAR 0 1
64308: ARRAY
64309: PUSH
64310: LD_EXP 24
64314: PUSH
64315: LD_VAR 0 1
64319: ARRAY
64320: ARRAY
64321: PPUSH
64322: CALL_OW 120
// end ; exit ;
64326: GO 64647
// end ; if tmp > 1 then
64328: LD_VAR 0 8
64332: PUSH
64333: LD_INT 1
64335: GREATER
64336: IFFALSE 64440
// for i = 2 to tmp do
64338: LD_ADDR_VAR 0 6
64342: PUSH
64343: DOUBLE
64344: LD_INT 2
64346: DEC
64347: ST_TO_ADDR
64348: LD_VAR 0 8
64352: PUSH
64353: FOR_TO
64354: IFFALSE 64438
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
64356: LD_VAR 0 8
64360: PUSH
64361: LD_VAR 0 6
64365: ARRAY
64366: PPUSH
64367: CALL_OW 461
64371: PUSH
64372: LD_INT 6
64374: EQUAL
64375: IFFALSE 64436
// begin x := tmp [ i ] ;
64377: LD_ADDR_VAR 0 9
64381: PUSH
64382: LD_VAR 0 8
64386: PUSH
64387: LD_VAR 0 6
64391: ARRAY
64392: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
64393: LD_ADDR_VAR 0 8
64397: PUSH
64398: LD_VAR 0 8
64402: PPUSH
64403: LD_VAR 0 6
64407: PPUSH
64408: CALL_OW 3
64412: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
64413: LD_ADDR_VAR 0 8
64417: PUSH
64418: LD_VAR 0 8
64422: PPUSH
64423: LD_INT 1
64425: PPUSH
64426: LD_VAR 0 9
64430: PPUSH
64431: CALL_OW 2
64435: ST_TO_ADDR
// end ;
64436: GO 64353
64438: POP
64439: POP
// for i in tmp do
64440: LD_ADDR_VAR 0 6
64444: PUSH
64445: LD_VAR 0 8
64449: PUSH
64450: FOR_IN
64451: IFFALSE 64520
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
64453: LD_VAR 0 6
64457: PPUSH
64458: CALL_OW 313
64462: PUSH
64463: LD_INT 6
64465: LESS
64466: PUSH
64467: LD_VAR 0 6
64471: PPUSH
64472: CALL_OW 266
64476: PUSH
64477: LD_INT 31
64479: PUSH
64480: LD_INT 32
64482: PUSH
64483: EMPTY
64484: LIST
64485: LIST
64486: IN
64487: NOT
64488: AND
64489: PUSH
64490: LD_VAR 0 6
64494: PPUSH
64495: CALL_OW 313
64499: PUSH
64500: LD_INT 0
64502: EQUAL
64503: OR
64504: IFFALSE 64518
// begin j := i ;
64506: LD_ADDR_VAR 0 7
64510: PUSH
64511: LD_VAR 0 6
64515: ST_TO_ADDR
// break ;
64516: GO 64520
// end ; end ;
64518: GO 64450
64520: POP
64521: POP
// if j then
64522: LD_VAR 0 7
64526: IFFALSE 64544
// ComEnterUnit ( unit , j ) else
64528: LD_VAR 0 3
64532: PPUSH
64533: LD_VAR 0 7
64537: PPUSH
64538: CALL_OW 120
64542: GO 64647
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64544: LD_ADDR_VAR 0 10
64548: PUSH
64549: LD_VAR 0 2
64553: PPUSH
64554: LD_INT 2
64556: PUSH
64557: LD_INT 30
64559: PUSH
64560: LD_INT 0
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: LD_INT 30
64569: PUSH
64570: LD_INT 1
64572: PUSH
64573: EMPTY
64574: LIST
64575: LIST
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: LIST
64581: PPUSH
64582: CALL_OW 72
64586: ST_TO_ADDR
// if depot then
64587: LD_VAR 0 10
64591: IFFALSE 64647
// begin depot := NearestUnitToUnit ( depot , unit ) ;
64593: LD_ADDR_VAR 0 10
64597: PUSH
64598: LD_VAR 0 10
64602: PPUSH
64603: LD_VAR 0 3
64607: PPUSH
64608: CALL_OW 74
64612: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
64613: LD_VAR 0 3
64617: PPUSH
64618: LD_VAR 0 10
64622: PPUSH
64623: CALL_OW 296
64627: PUSH
64628: LD_INT 10
64630: GREATER
64631: IFFALSE 64647
// ComStandNearbyBuilding ( unit , depot ) ;
64633: LD_VAR 0 3
64637: PPUSH
64638: LD_VAR 0 10
64642: PPUSH
64643: CALL 6041 0 2
// end ; end ; end ;
64647: LD_VAR 0 5
64651: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
64652: LD_INT 0
64654: PPUSH
64655: PPUSH
64656: PPUSH
64657: PPUSH
// if not mc_bases then
64658: LD_EXP 14
64662: NOT
64663: IFFALSE 64667
// exit ;
64665: GO 64906
// for i = 1 to mc_bases do
64667: LD_ADDR_VAR 0 2
64671: PUSH
64672: DOUBLE
64673: LD_INT 1
64675: DEC
64676: ST_TO_ADDR
64677: LD_EXP 14
64681: PUSH
64682: FOR_TO
64683: IFFALSE 64904
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
64685: LD_ADDR_VAR 0 4
64689: PUSH
64690: LD_EXP 14
64694: PUSH
64695: LD_VAR 0 2
64699: ARRAY
64700: PPUSH
64701: LD_INT 21
64703: PUSH
64704: LD_INT 1
64706: PUSH
64707: EMPTY
64708: LIST
64709: LIST
64710: PPUSH
64711: CALL_OW 72
64715: PUSH
64716: LD_EXP 43
64720: PUSH
64721: LD_VAR 0 2
64725: ARRAY
64726: UNION
64727: ST_TO_ADDR
// if not tmp then
64728: LD_VAR 0 4
64732: NOT
64733: IFFALSE 64737
// continue ;
64735: GO 64682
// for j in tmp do
64737: LD_ADDR_VAR 0 3
64741: PUSH
64742: LD_VAR 0 4
64746: PUSH
64747: FOR_IN
64748: IFFALSE 64900
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
64750: LD_VAR 0 3
64754: PPUSH
64755: CALL_OW 110
64759: NOT
64760: PUSH
64761: LD_VAR 0 3
64765: PPUSH
64766: CALL_OW 314
64770: NOT
64771: AND
64772: PUSH
64773: LD_VAR 0 3
64777: PPUSH
64778: CALL_OW 311
64782: NOT
64783: AND
64784: PUSH
64785: LD_VAR 0 3
64789: PPUSH
64790: CALL_OW 310
64794: NOT
64795: AND
64796: PUSH
64797: LD_VAR 0 3
64801: PUSH
64802: LD_EXP 17
64806: PUSH
64807: LD_VAR 0 2
64811: ARRAY
64812: PUSH
64813: LD_INT 1
64815: ARRAY
64816: IN
64817: NOT
64818: AND
64819: PUSH
64820: LD_VAR 0 3
64824: PUSH
64825: LD_EXP 17
64829: PUSH
64830: LD_VAR 0 2
64834: ARRAY
64835: PUSH
64836: LD_INT 2
64838: ARRAY
64839: IN
64840: NOT
64841: AND
64842: PUSH
64843: LD_VAR 0 3
64847: PUSH
64848: LD_EXP 26
64852: PUSH
64853: LD_VAR 0 2
64857: ARRAY
64858: IN
64859: NOT
64860: AND
64861: IFFALSE 64898
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
64863: LD_VAR 0 2
64867: PPUSH
64868: LD_EXP 14
64872: PUSH
64873: LD_VAR 0 2
64877: ARRAY
64878: PPUSH
64879: LD_VAR 0 3
64883: PPUSH
64884: LD_VAR 0 3
64888: PPUSH
64889: CALL_OW 257
64893: PPUSH
64894: CALL 63670 0 4
// end ;
64898: GO 64747
64900: POP
64901: POP
// end ;
64902: GO 64682
64904: POP
64905: POP
// end ;
64906: LD_VAR 0 1
64910: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
64911: LD_INT 0
64913: PPUSH
64914: PPUSH
64915: PPUSH
64916: PPUSH
64917: PPUSH
64918: PPUSH
// if not mc_bases [ base ] then
64919: LD_EXP 14
64923: PUSH
64924: LD_VAR 0 1
64928: ARRAY
64929: NOT
64930: IFFALSE 64934
// exit ;
64932: GO 65116
// tmp := [ ] ;
64934: LD_ADDR_VAR 0 6
64938: PUSH
64939: EMPTY
64940: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
64941: LD_ADDR_VAR 0 7
64945: PUSH
64946: LD_VAR 0 3
64950: PPUSH
64951: LD_INT 0
64953: PPUSH
64954: CALL_OW 517
64958: ST_TO_ADDR
// if not list then
64959: LD_VAR 0 7
64963: NOT
64964: IFFALSE 64968
// exit ;
64966: GO 65116
// for i = 1 to amount do
64968: LD_ADDR_VAR 0 5
64972: PUSH
64973: DOUBLE
64974: LD_INT 1
64976: DEC
64977: ST_TO_ADDR
64978: LD_VAR 0 2
64982: PUSH
64983: FOR_TO
64984: IFFALSE 65064
// begin x := rand ( 1 , list [ 1 ] ) ;
64986: LD_ADDR_VAR 0 8
64990: PUSH
64991: LD_INT 1
64993: PPUSH
64994: LD_VAR 0 7
64998: PUSH
64999: LD_INT 1
65001: ARRAY
65002: PPUSH
65003: CALL_OW 12
65007: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
65008: LD_ADDR_VAR 0 6
65012: PUSH
65013: LD_VAR 0 6
65017: PPUSH
65018: LD_VAR 0 5
65022: PPUSH
65023: LD_VAR 0 7
65027: PUSH
65028: LD_INT 1
65030: ARRAY
65031: PUSH
65032: LD_VAR 0 8
65036: ARRAY
65037: PUSH
65038: LD_VAR 0 7
65042: PUSH
65043: LD_INT 2
65045: ARRAY
65046: PUSH
65047: LD_VAR 0 8
65051: ARRAY
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PPUSH
65057: CALL_OW 1
65061: ST_TO_ADDR
// end ;
65062: GO 64983
65064: POP
65065: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
65066: LD_ADDR_EXP 27
65070: PUSH
65071: LD_EXP 27
65075: PPUSH
65076: LD_VAR 0 1
65080: PPUSH
65081: LD_VAR 0 6
65085: PPUSH
65086: CALL_OW 1
65090: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
65091: LD_ADDR_EXP 29
65095: PUSH
65096: LD_EXP 29
65100: PPUSH
65101: LD_VAR 0 1
65105: PPUSH
65106: LD_VAR 0 3
65110: PPUSH
65111: CALL_OW 1
65115: ST_TO_ADDR
// end ;
65116: LD_VAR 0 4
65120: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
65121: LD_INT 0
65123: PPUSH
// if not mc_bases [ base ] then
65124: LD_EXP 14
65128: PUSH
65129: LD_VAR 0 1
65133: ARRAY
65134: NOT
65135: IFFALSE 65139
// exit ;
65137: GO 65164
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
65139: LD_ADDR_EXP 19
65143: PUSH
65144: LD_EXP 19
65148: PPUSH
65149: LD_VAR 0 1
65153: PPUSH
65154: LD_VAR 0 2
65158: PPUSH
65159: CALL_OW 1
65163: ST_TO_ADDR
// end ;
65164: LD_VAR 0 3
65168: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
65169: LD_INT 0
65171: PPUSH
// if not mc_bases [ base ] then
65172: LD_EXP 14
65176: PUSH
65177: LD_VAR 0 1
65181: ARRAY
65182: NOT
65183: IFFALSE 65187
// exit ;
65185: GO 65224
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
65187: LD_ADDR_EXP 19
65191: PUSH
65192: LD_EXP 19
65196: PPUSH
65197: LD_VAR 0 1
65201: PPUSH
65202: LD_EXP 19
65206: PUSH
65207: LD_VAR 0 1
65211: ARRAY
65212: PUSH
65213: LD_VAR 0 2
65217: UNION
65218: PPUSH
65219: CALL_OW 1
65223: ST_TO_ADDR
// end ;
65224: LD_VAR 0 3
65228: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
65229: LD_INT 0
65231: PPUSH
// if not mc_bases [ base ] then
65232: LD_EXP 14
65236: PUSH
65237: LD_VAR 0 1
65241: ARRAY
65242: NOT
65243: IFFALSE 65247
// exit ;
65245: GO 65272
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
65247: LD_ADDR_EXP 35
65251: PUSH
65252: LD_EXP 35
65256: PPUSH
65257: LD_VAR 0 1
65261: PPUSH
65262: LD_VAR 0 2
65266: PPUSH
65267: CALL_OW 1
65271: ST_TO_ADDR
// end ;
65272: LD_VAR 0 3
65276: RET
// export function MC_InsertProduceList ( base , components ) ; begin
65277: LD_INT 0
65279: PPUSH
// if not mc_bases [ base ] then
65280: LD_EXP 14
65284: PUSH
65285: LD_VAR 0 1
65289: ARRAY
65290: NOT
65291: IFFALSE 65295
// exit ;
65293: GO 65332
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
65295: LD_ADDR_EXP 35
65299: PUSH
65300: LD_EXP 35
65304: PPUSH
65305: LD_VAR 0 1
65309: PPUSH
65310: LD_EXP 35
65314: PUSH
65315: LD_VAR 0 1
65319: ARRAY
65320: PUSH
65321: LD_VAR 0 2
65325: ADD
65326: PPUSH
65327: CALL_OW 1
65331: ST_TO_ADDR
// end ;
65332: LD_VAR 0 3
65336: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
65337: LD_INT 0
65339: PPUSH
// if not mc_bases [ base ] then
65340: LD_EXP 14
65344: PUSH
65345: LD_VAR 0 1
65349: ARRAY
65350: NOT
65351: IFFALSE 65355
// exit ;
65353: GO 65409
// mc_defender := Replace ( mc_defender , base , deflist ) ;
65355: LD_ADDR_EXP 36
65359: PUSH
65360: LD_EXP 36
65364: PPUSH
65365: LD_VAR 0 1
65369: PPUSH
65370: LD_VAR 0 2
65374: PPUSH
65375: CALL_OW 1
65379: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
65380: LD_ADDR_EXP 25
65384: PUSH
65385: LD_EXP 25
65389: PPUSH
65390: LD_VAR 0 1
65394: PPUSH
65395: LD_VAR 0 2
65399: PUSH
65400: LD_INT 0
65402: PLUS
65403: PPUSH
65404: CALL_OW 1
65408: ST_TO_ADDR
// end ;
65409: LD_VAR 0 3
65413: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
65414: LD_INT 0
65416: PPUSH
// if not mc_bases [ base ] then
65417: LD_EXP 14
65421: PUSH
65422: LD_VAR 0 1
65426: ARRAY
65427: NOT
65428: IFFALSE 65432
// exit ;
65430: GO 65457
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
65432: LD_ADDR_EXP 25
65436: PUSH
65437: LD_EXP 25
65441: PPUSH
65442: LD_VAR 0 1
65446: PPUSH
65447: LD_VAR 0 2
65451: PPUSH
65452: CALL_OW 1
65456: ST_TO_ADDR
// end ;
65457: LD_VAR 0 3
65461: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
65462: LD_INT 0
65464: PPUSH
65465: PPUSH
65466: PPUSH
65467: PPUSH
// if not mc_bases [ base ] then
65468: LD_EXP 14
65472: PUSH
65473: LD_VAR 0 1
65477: ARRAY
65478: NOT
65479: IFFALSE 65483
// exit ;
65481: GO 65548
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
65483: LD_ADDR_EXP 34
65487: PUSH
65488: LD_EXP 34
65492: PPUSH
65493: LD_VAR 0 1
65497: PUSH
65498: LD_EXP 34
65502: PUSH
65503: LD_VAR 0 1
65507: ARRAY
65508: PUSH
65509: LD_INT 1
65511: PLUS
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PPUSH
65517: LD_VAR 0 1
65521: PUSH
65522: LD_VAR 0 2
65526: PUSH
65527: LD_VAR 0 3
65531: PUSH
65532: LD_VAR 0 4
65536: PUSH
65537: EMPTY
65538: LIST
65539: LIST
65540: LIST
65541: LIST
65542: PPUSH
65543: CALL 9427 0 3
65547: ST_TO_ADDR
// end ;
65548: LD_VAR 0 5
65552: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
65553: LD_INT 0
65555: PPUSH
// if not mc_bases [ base ] then
65556: LD_EXP 14
65560: PUSH
65561: LD_VAR 0 1
65565: ARRAY
65566: NOT
65567: IFFALSE 65571
// exit ;
65569: GO 65596
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
65571: LD_ADDR_EXP 51
65575: PUSH
65576: LD_EXP 51
65580: PPUSH
65581: LD_VAR 0 1
65585: PPUSH
65586: LD_VAR 0 2
65590: PPUSH
65591: CALL_OW 1
65595: ST_TO_ADDR
// end ;
65596: LD_VAR 0 3
65600: RET
// export function MC_GetMinesField ( base ) ; begin
65601: LD_INT 0
65603: PPUSH
// result := mc_mines [ base ] ;
65604: LD_ADDR_VAR 0 2
65608: PUSH
65609: LD_EXP 27
65613: PUSH
65614: LD_VAR 0 1
65618: ARRAY
65619: ST_TO_ADDR
// end ;
65620: LD_VAR 0 2
65624: RET
// export function MC_GetProduceList ( base ) ; begin
65625: LD_INT 0
65627: PPUSH
// result := mc_produce [ base ] ;
65628: LD_ADDR_VAR 0 2
65632: PUSH
65633: LD_EXP 35
65637: PUSH
65638: LD_VAR 0 1
65642: ARRAY
65643: ST_TO_ADDR
// end ;
65644: LD_VAR 0 2
65648: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
65649: LD_INT 0
65651: PPUSH
65652: PPUSH
// if not mc_bases then
65653: LD_EXP 14
65657: NOT
65658: IFFALSE 65662
// exit ;
65660: GO 65727
// if mc_bases [ base ] then
65662: LD_EXP 14
65666: PUSH
65667: LD_VAR 0 1
65671: ARRAY
65672: IFFALSE 65727
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65674: LD_ADDR_VAR 0 3
65678: PUSH
65679: LD_EXP 14
65683: PUSH
65684: LD_VAR 0 1
65688: ARRAY
65689: PPUSH
65690: LD_INT 30
65692: PUSH
65693: LD_VAR 0 2
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PPUSH
65702: CALL_OW 72
65706: ST_TO_ADDR
// if result then
65707: LD_VAR 0 3
65711: IFFALSE 65727
// result := result [ 1 ] ;
65713: LD_ADDR_VAR 0 3
65717: PUSH
65718: LD_VAR 0 3
65722: PUSH
65723: LD_INT 1
65725: ARRAY
65726: ST_TO_ADDR
// end ; end ;
65727: LD_VAR 0 3
65731: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
65732: LD_INT 0
65734: PPUSH
65735: PPUSH
// if not mc_bases then
65736: LD_EXP 14
65740: NOT
65741: IFFALSE 65745
// exit ;
65743: GO 65790
// if mc_bases [ base ] then
65745: LD_EXP 14
65749: PUSH
65750: LD_VAR 0 1
65754: ARRAY
65755: IFFALSE 65790
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65757: LD_ADDR_VAR 0 3
65761: PUSH
65762: LD_EXP 14
65766: PUSH
65767: LD_VAR 0 1
65771: ARRAY
65772: PPUSH
65773: LD_INT 30
65775: PUSH
65776: LD_VAR 0 2
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PPUSH
65785: CALL_OW 72
65789: ST_TO_ADDR
// end ;
65790: LD_VAR 0 3
65794: RET
// export function MC_SetTame ( base , area ) ; begin
65795: LD_INT 0
65797: PPUSH
// if not mc_bases or not base then
65798: LD_EXP 14
65802: NOT
65803: PUSH
65804: LD_VAR 0 1
65808: NOT
65809: OR
65810: IFFALSE 65814
// exit ;
65812: GO 65839
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
65814: LD_ADDR_EXP 42
65818: PUSH
65819: LD_EXP 42
65823: PPUSH
65824: LD_VAR 0 1
65828: PPUSH
65829: LD_VAR 0 2
65833: PPUSH
65834: CALL_OW 1
65838: ST_TO_ADDR
// end ;
65839: LD_VAR 0 3
65843: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
65844: LD_INT 0
65846: PPUSH
65847: PPUSH
// if not mc_bases or not base then
65848: LD_EXP 14
65852: NOT
65853: PUSH
65854: LD_VAR 0 1
65858: NOT
65859: OR
65860: IFFALSE 65864
// exit ;
65862: GO 65966
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65864: LD_ADDR_VAR 0 4
65868: PUSH
65869: LD_EXP 14
65873: PUSH
65874: LD_VAR 0 1
65878: ARRAY
65879: PPUSH
65880: LD_INT 30
65882: PUSH
65883: LD_VAR 0 2
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PPUSH
65892: CALL_OW 72
65896: ST_TO_ADDR
// if not tmp then
65897: LD_VAR 0 4
65901: NOT
65902: IFFALSE 65906
// exit ;
65904: GO 65966
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
65906: LD_ADDR_EXP 46
65910: PUSH
65911: LD_EXP 46
65915: PPUSH
65916: LD_VAR 0 1
65920: PPUSH
65921: LD_EXP 46
65925: PUSH
65926: LD_VAR 0 1
65930: ARRAY
65931: PPUSH
65932: LD_EXP 46
65936: PUSH
65937: LD_VAR 0 1
65941: ARRAY
65942: PUSH
65943: LD_INT 1
65945: PLUS
65946: PPUSH
65947: LD_VAR 0 4
65951: PUSH
65952: LD_INT 1
65954: ARRAY
65955: PPUSH
65956: CALL_OW 2
65960: PPUSH
65961: CALL_OW 1
65965: ST_TO_ADDR
// end ;
65966: LD_VAR 0 3
65970: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
65971: LD_INT 0
65973: PPUSH
65974: PPUSH
// if not mc_bases or not base or not kinds then
65975: LD_EXP 14
65979: NOT
65980: PUSH
65981: LD_VAR 0 1
65985: NOT
65986: OR
65987: PUSH
65988: LD_VAR 0 2
65992: NOT
65993: OR
65994: IFFALSE 65998
// exit ;
65996: GO 66059
// for i in kinds do
65998: LD_ADDR_VAR 0 4
66002: PUSH
66003: LD_VAR 0 2
66007: PUSH
66008: FOR_IN
66009: IFFALSE 66057
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
66011: LD_ADDR_EXP 48
66015: PUSH
66016: LD_EXP 48
66020: PPUSH
66021: LD_VAR 0 1
66025: PUSH
66026: LD_EXP 48
66030: PUSH
66031: LD_VAR 0 1
66035: ARRAY
66036: PUSH
66037: LD_INT 1
66039: PLUS
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: PPUSH
66045: LD_VAR 0 4
66049: PPUSH
66050: CALL 9427 0 3
66054: ST_TO_ADDR
66055: GO 66008
66057: POP
66058: POP
// end ;
66059: LD_VAR 0 3
66063: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
66064: LD_INT 0
66066: PPUSH
// if not mc_bases or not base or not areas then
66067: LD_EXP 14
66071: NOT
66072: PUSH
66073: LD_VAR 0 1
66077: NOT
66078: OR
66079: PUSH
66080: LD_VAR 0 2
66084: NOT
66085: OR
66086: IFFALSE 66090
// exit ;
66088: GO 66115
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
66090: LD_ADDR_EXP 32
66094: PUSH
66095: LD_EXP 32
66099: PPUSH
66100: LD_VAR 0 1
66104: PPUSH
66105: LD_VAR 0 2
66109: PPUSH
66110: CALL_OW 1
66114: ST_TO_ADDR
// end ;
66115: LD_VAR 0 3
66119: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
66120: LD_INT 0
66122: PPUSH
// if not mc_bases or not base or not teleports_exit then
66123: LD_EXP 14
66127: NOT
66128: PUSH
66129: LD_VAR 0 1
66133: NOT
66134: OR
66135: PUSH
66136: LD_VAR 0 2
66140: NOT
66141: OR
66142: IFFALSE 66146
// exit ;
66144: GO 66171
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
66146: LD_ADDR_EXP 49
66150: PUSH
66151: LD_EXP 49
66155: PPUSH
66156: LD_VAR 0 1
66160: PPUSH
66161: LD_VAR 0 2
66165: PPUSH
66166: CALL_OW 1
66170: ST_TO_ADDR
// end ;
66171: LD_VAR 0 3
66175: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
66176: LD_INT 0
66178: PPUSH
66179: PPUSH
66180: PPUSH
// if not mc_bases or not base or not ext_list then
66181: LD_EXP 14
66185: NOT
66186: PUSH
66187: LD_VAR 0 1
66191: NOT
66192: OR
66193: PUSH
66194: LD_VAR 0 5
66198: NOT
66199: OR
66200: IFFALSE 66204
// exit ;
66202: GO 66377
// tmp := GetFacExtXYD ( x , y , d ) ;
66204: LD_ADDR_VAR 0 8
66208: PUSH
66209: LD_VAR 0 2
66213: PPUSH
66214: LD_VAR 0 3
66218: PPUSH
66219: LD_VAR 0 4
66223: PPUSH
66224: CALL 38106 0 3
66228: ST_TO_ADDR
// if not tmp then
66229: LD_VAR 0 8
66233: NOT
66234: IFFALSE 66238
// exit ;
66236: GO 66377
// for i in tmp do
66238: LD_ADDR_VAR 0 7
66242: PUSH
66243: LD_VAR 0 8
66247: PUSH
66248: FOR_IN
66249: IFFALSE 66375
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
66251: LD_ADDR_EXP 19
66255: PUSH
66256: LD_EXP 19
66260: PPUSH
66261: LD_VAR 0 1
66265: PPUSH
66266: LD_EXP 19
66270: PUSH
66271: LD_VAR 0 1
66275: ARRAY
66276: PPUSH
66277: LD_EXP 19
66281: PUSH
66282: LD_VAR 0 1
66286: ARRAY
66287: PUSH
66288: LD_INT 1
66290: PLUS
66291: PPUSH
66292: LD_VAR 0 5
66296: PUSH
66297: LD_INT 1
66299: ARRAY
66300: PUSH
66301: LD_VAR 0 7
66305: PUSH
66306: LD_INT 1
66308: ARRAY
66309: PUSH
66310: LD_VAR 0 7
66314: PUSH
66315: LD_INT 2
66317: ARRAY
66318: PUSH
66319: LD_VAR 0 7
66323: PUSH
66324: LD_INT 3
66326: ARRAY
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: LIST
66332: LIST
66333: PPUSH
66334: CALL_OW 2
66338: PPUSH
66339: CALL_OW 1
66343: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
66344: LD_ADDR_VAR 0 5
66348: PUSH
66349: LD_VAR 0 5
66353: PPUSH
66354: LD_INT 1
66356: PPUSH
66357: CALL_OW 3
66361: ST_TO_ADDR
// if not ext_list then
66362: LD_VAR 0 5
66366: NOT
66367: IFFALSE 66373
// exit ;
66369: POP
66370: POP
66371: GO 66377
// end ;
66373: GO 66248
66375: POP
66376: POP
// end ;
66377: LD_VAR 0 6
66381: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
66382: LD_INT 0
66384: PPUSH
// if not mc_bases or not base or not weapon_list then
66385: LD_EXP 14
66389: NOT
66390: PUSH
66391: LD_VAR 0 1
66395: NOT
66396: OR
66397: PUSH
66398: LD_VAR 0 2
66402: NOT
66403: OR
66404: IFFALSE 66408
// exit ;
66406: GO 66433
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
66408: LD_ADDR_EXP 53
66412: PUSH
66413: LD_EXP 53
66417: PPUSH
66418: LD_VAR 0 1
66422: PPUSH
66423: LD_VAR 0 2
66427: PPUSH
66428: CALL_OW 1
66432: ST_TO_ADDR
// end ;
66433: LD_VAR 0 3
66437: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
66438: LD_INT 0
66440: PPUSH
// if not mc_bases or not base or not tech_list then
66441: LD_EXP 14
66445: NOT
66446: PUSH
66447: LD_VAR 0 1
66451: NOT
66452: OR
66453: PUSH
66454: LD_VAR 0 2
66458: NOT
66459: OR
66460: IFFALSE 66464
// exit ;
66462: GO 66489
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
66464: LD_ADDR_EXP 41
66468: PUSH
66469: LD_EXP 41
66473: PPUSH
66474: LD_VAR 0 1
66478: PPUSH
66479: LD_VAR 0 2
66483: PPUSH
66484: CALL_OW 1
66488: ST_TO_ADDR
// end ;
66489: LD_VAR 0 3
66493: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
66494: LD_INT 0
66496: PPUSH
// if not mc_bases or not parking_area or not base then
66497: LD_EXP 14
66501: NOT
66502: PUSH
66503: LD_VAR 0 2
66507: NOT
66508: OR
66509: PUSH
66510: LD_VAR 0 1
66514: NOT
66515: OR
66516: IFFALSE 66520
// exit ;
66518: GO 66545
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
66520: LD_ADDR_EXP 38
66524: PUSH
66525: LD_EXP 38
66529: PPUSH
66530: LD_VAR 0 1
66534: PPUSH
66535: LD_VAR 0 2
66539: PPUSH
66540: CALL_OW 1
66544: ST_TO_ADDR
// end ;
66545: LD_VAR 0 3
66549: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
66550: LD_INT 0
66552: PPUSH
// if not mc_bases or not base or not scan_area then
66553: LD_EXP 14
66557: NOT
66558: PUSH
66559: LD_VAR 0 1
66563: NOT
66564: OR
66565: PUSH
66566: LD_VAR 0 2
66570: NOT
66571: OR
66572: IFFALSE 66576
// exit ;
66574: GO 66601
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
66576: LD_ADDR_EXP 39
66580: PUSH
66581: LD_EXP 39
66585: PPUSH
66586: LD_VAR 0 1
66590: PPUSH
66591: LD_VAR 0 2
66595: PPUSH
66596: CALL_OW 1
66600: ST_TO_ADDR
// end ;
66601: LD_VAR 0 3
66605: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
66606: LD_INT 0
66608: PPUSH
66609: PPUSH
// if not mc_bases or not base then
66610: LD_EXP 14
66614: NOT
66615: PUSH
66616: LD_VAR 0 1
66620: NOT
66621: OR
66622: IFFALSE 66626
// exit ;
66624: GO 66690
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
66626: LD_ADDR_VAR 0 3
66630: PUSH
66631: LD_INT 1
66633: PUSH
66634: LD_INT 2
66636: PUSH
66637: LD_INT 3
66639: PUSH
66640: LD_INT 4
66642: PUSH
66643: LD_INT 11
66645: PUSH
66646: EMPTY
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
66653: LD_ADDR_EXP 41
66657: PUSH
66658: LD_EXP 41
66662: PPUSH
66663: LD_VAR 0 1
66667: PPUSH
66668: LD_EXP 41
66672: PUSH
66673: LD_VAR 0 1
66677: ARRAY
66678: PUSH
66679: LD_VAR 0 3
66683: DIFF
66684: PPUSH
66685: CALL_OW 1
66689: ST_TO_ADDR
// end ;
66690: LD_VAR 0 2
66694: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
66695: LD_INT 0
66697: PPUSH
// result := mc_vehicles [ base ] ;
66698: LD_ADDR_VAR 0 3
66702: PUSH
66703: LD_EXP 33
66707: PUSH
66708: LD_VAR 0 1
66712: ARRAY
66713: ST_TO_ADDR
// if onlyCombat then
66714: LD_VAR 0 2
66718: IFFALSE 66896
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
66720: LD_ADDR_VAR 0 3
66724: PUSH
66725: LD_VAR 0 3
66729: PUSH
66730: LD_VAR 0 3
66734: PPUSH
66735: LD_INT 2
66737: PUSH
66738: LD_INT 34
66740: PUSH
66741: LD_INT 12
66743: PUSH
66744: EMPTY
66745: LIST
66746: LIST
66747: PUSH
66748: LD_INT 34
66750: PUSH
66751: LD_INT 51
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 34
66760: PUSH
66761: LD_EXP 58
66765: PUSH
66766: EMPTY
66767: LIST
66768: LIST
66769: PUSH
66770: LD_INT 34
66772: PUSH
66773: LD_INT 32
66775: PUSH
66776: EMPTY
66777: LIST
66778: LIST
66779: PUSH
66780: LD_INT 34
66782: PUSH
66783: LD_INT 13
66785: PUSH
66786: EMPTY
66787: LIST
66788: LIST
66789: PUSH
66790: LD_INT 34
66792: PUSH
66793: LD_INT 52
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: LD_INT 34
66802: PUSH
66803: LD_EXP 63
66807: PUSH
66808: EMPTY
66809: LIST
66810: LIST
66811: PUSH
66812: LD_INT 34
66814: PUSH
66815: LD_INT 14
66817: PUSH
66818: EMPTY
66819: LIST
66820: LIST
66821: PUSH
66822: LD_INT 34
66824: PUSH
66825: LD_INT 53
66827: PUSH
66828: EMPTY
66829: LIST
66830: LIST
66831: PUSH
66832: LD_INT 34
66834: PUSH
66835: LD_EXP 57
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: PUSH
66844: LD_INT 34
66846: PUSH
66847: LD_INT 31
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 34
66856: PUSH
66857: LD_INT 48
66859: PUSH
66860: EMPTY
66861: LIST
66862: LIST
66863: PUSH
66864: LD_INT 34
66866: PUSH
66867: LD_INT 8
66869: PUSH
66870: EMPTY
66871: LIST
66872: LIST
66873: PUSH
66874: EMPTY
66875: LIST
66876: LIST
66877: LIST
66878: LIST
66879: LIST
66880: LIST
66881: LIST
66882: LIST
66883: LIST
66884: LIST
66885: LIST
66886: LIST
66887: LIST
66888: LIST
66889: PPUSH
66890: CALL_OW 72
66894: DIFF
66895: ST_TO_ADDR
// end ; end_of_file
66896: LD_VAR 0 3
66900: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
66901: LD_INT 0
66903: PPUSH
66904: PPUSH
66905: PPUSH
// if not mc_bases or not skirmish then
66906: LD_EXP 14
66910: NOT
66911: PUSH
66912: LD_EXP 12
66916: NOT
66917: OR
66918: IFFALSE 66922
// exit ;
66920: GO 67087
// for i = 1 to mc_bases do
66922: LD_ADDR_VAR 0 4
66926: PUSH
66927: DOUBLE
66928: LD_INT 1
66930: DEC
66931: ST_TO_ADDR
66932: LD_EXP 14
66936: PUSH
66937: FOR_TO
66938: IFFALSE 67085
// begin if sci in mc_bases [ i ] then
66940: LD_VAR 0 2
66944: PUSH
66945: LD_EXP 14
66949: PUSH
66950: LD_VAR 0 4
66954: ARRAY
66955: IN
66956: IFFALSE 67083
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
66958: LD_ADDR_EXP 43
66962: PUSH
66963: LD_EXP 43
66967: PPUSH
66968: LD_VAR 0 4
66972: PUSH
66973: LD_EXP 43
66977: PUSH
66978: LD_VAR 0 4
66982: ARRAY
66983: PUSH
66984: LD_INT 1
66986: PLUS
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PPUSH
66992: LD_VAR 0 1
66996: PPUSH
66997: CALL 9427 0 3
67001: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
67002: LD_ADDR_VAR 0 5
67006: PUSH
67007: LD_EXP 14
67011: PUSH
67012: LD_VAR 0 4
67016: ARRAY
67017: PPUSH
67018: LD_INT 2
67020: PUSH
67021: LD_INT 30
67023: PUSH
67024: LD_INT 0
67026: PUSH
67027: EMPTY
67028: LIST
67029: LIST
67030: PUSH
67031: LD_INT 30
67033: PUSH
67034: LD_INT 1
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PUSH
67041: EMPTY
67042: LIST
67043: LIST
67044: LIST
67045: PPUSH
67046: CALL_OW 72
67050: PPUSH
67051: LD_VAR 0 1
67055: PPUSH
67056: CALL_OW 74
67060: ST_TO_ADDR
// if tmp then
67061: LD_VAR 0 5
67065: IFFALSE 67081
// ComStandNearbyBuilding ( ape , tmp ) ;
67067: LD_VAR 0 1
67071: PPUSH
67072: LD_VAR 0 5
67076: PPUSH
67077: CALL 6041 0 2
// break ;
67081: GO 67085
// end ; end ;
67083: GO 66937
67085: POP
67086: POP
// end ;
67087: LD_VAR 0 3
67091: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
67092: LD_INT 0
67094: PPUSH
67095: PPUSH
67096: PPUSH
// if not mc_bases or not skirmish then
67097: LD_EXP 14
67101: NOT
67102: PUSH
67103: LD_EXP 12
67107: NOT
67108: OR
67109: IFFALSE 67113
// exit ;
67111: GO 67202
// for i = 1 to mc_bases do
67113: LD_ADDR_VAR 0 4
67117: PUSH
67118: DOUBLE
67119: LD_INT 1
67121: DEC
67122: ST_TO_ADDR
67123: LD_EXP 14
67127: PUSH
67128: FOR_TO
67129: IFFALSE 67200
// begin if building in mc_busy_turret_list [ i ] then
67131: LD_VAR 0 1
67135: PUSH
67136: LD_EXP 24
67140: PUSH
67141: LD_VAR 0 4
67145: ARRAY
67146: IN
67147: IFFALSE 67198
// begin tmp := mc_busy_turret_list [ i ] diff building ;
67149: LD_ADDR_VAR 0 5
67153: PUSH
67154: LD_EXP 24
67158: PUSH
67159: LD_VAR 0 4
67163: ARRAY
67164: PUSH
67165: LD_VAR 0 1
67169: DIFF
67170: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
67171: LD_ADDR_EXP 24
67175: PUSH
67176: LD_EXP 24
67180: PPUSH
67181: LD_VAR 0 4
67185: PPUSH
67186: LD_VAR 0 5
67190: PPUSH
67191: CALL_OW 1
67195: ST_TO_ADDR
// break ;
67196: GO 67200
// end ; end ;
67198: GO 67128
67200: POP
67201: POP
// end ;
67202: LD_VAR 0 3
67206: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
67207: LD_INT 0
67209: PPUSH
67210: PPUSH
67211: PPUSH
// if not mc_bases or not skirmish then
67212: LD_EXP 14
67216: NOT
67217: PUSH
67218: LD_EXP 12
67222: NOT
67223: OR
67224: IFFALSE 67228
// exit ;
67226: GO 67427
// for i = 1 to mc_bases do
67228: LD_ADDR_VAR 0 5
67232: PUSH
67233: DOUBLE
67234: LD_INT 1
67236: DEC
67237: ST_TO_ADDR
67238: LD_EXP 14
67242: PUSH
67243: FOR_TO
67244: IFFALSE 67425
// if building in mc_bases [ i ] then
67246: LD_VAR 0 1
67250: PUSH
67251: LD_EXP 14
67255: PUSH
67256: LD_VAR 0 5
67260: ARRAY
67261: IN
67262: IFFALSE 67423
// begin tmp := mc_bases [ i ] diff building ;
67264: LD_ADDR_VAR 0 6
67268: PUSH
67269: LD_EXP 14
67273: PUSH
67274: LD_VAR 0 5
67278: ARRAY
67279: PUSH
67280: LD_VAR 0 1
67284: DIFF
67285: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
67286: LD_ADDR_EXP 14
67290: PUSH
67291: LD_EXP 14
67295: PPUSH
67296: LD_VAR 0 5
67300: PPUSH
67301: LD_VAR 0 6
67305: PPUSH
67306: CALL_OW 1
67310: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
67311: LD_VAR 0 1
67315: PUSH
67316: LD_EXP 22
67320: PUSH
67321: LD_VAR 0 5
67325: ARRAY
67326: IN
67327: IFFALSE 67366
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
67329: LD_ADDR_EXP 22
67333: PUSH
67334: LD_EXP 22
67338: PPUSH
67339: LD_VAR 0 5
67343: PPUSH
67344: LD_EXP 22
67348: PUSH
67349: LD_VAR 0 5
67353: ARRAY
67354: PUSH
67355: LD_VAR 0 1
67359: DIFF
67360: PPUSH
67361: CALL_OW 1
67365: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
67366: LD_VAR 0 1
67370: PUSH
67371: LD_EXP 23
67375: PUSH
67376: LD_VAR 0 5
67380: ARRAY
67381: IN
67382: IFFALSE 67421
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
67384: LD_ADDR_EXP 23
67388: PUSH
67389: LD_EXP 23
67393: PPUSH
67394: LD_VAR 0 5
67398: PPUSH
67399: LD_EXP 23
67403: PUSH
67404: LD_VAR 0 5
67408: ARRAY
67409: PUSH
67410: LD_VAR 0 1
67414: DIFF
67415: PPUSH
67416: CALL_OW 1
67420: ST_TO_ADDR
// break ;
67421: GO 67425
// end ;
67423: GO 67243
67425: POP
67426: POP
// end ;
67427: LD_VAR 0 4
67431: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
67432: LD_INT 0
67434: PPUSH
67435: PPUSH
67436: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
67437: LD_EXP 14
67441: NOT
67442: PUSH
67443: LD_EXP 12
67447: NOT
67448: OR
67449: PUSH
67450: LD_VAR 0 3
67454: PUSH
67455: LD_EXP 40
67459: IN
67460: NOT
67461: OR
67462: IFFALSE 67466
// exit ;
67464: GO 67589
// for i = 1 to mc_vehicles do
67466: LD_ADDR_VAR 0 6
67470: PUSH
67471: DOUBLE
67472: LD_INT 1
67474: DEC
67475: ST_TO_ADDR
67476: LD_EXP 33
67480: PUSH
67481: FOR_TO
67482: IFFALSE 67587
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
67484: LD_VAR 0 2
67488: PUSH
67489: LD_EXP 33
67493: PUSH
67494: LD_VAR 0 6
67498: ARRAY
67499: IN
67500: PUSH
67501: LD_VAR 0 1
67505: PUSH
67506: LD_EXP 33
67510: PUSH
67511: LD_VAR 0 6
67515: ARRAY
67516: IN
67517: OR
67518: IFFALSE 67585
// begin tmp := mc_vehicles [ i ] diff old ;
67520: LD_ADDR_VAR 0 7
67524: PUSH
67525: LD_EXP 33
67529: PUSH
67530: LD_VAR 0 6
67534: ARRAY
67535: PUSH
67536: LD_VAR 0 2
67540: DIFF
67541: ST_TO_ADDR
// tmp := tmp diff new ;
67542: LD_ADDR_VAR 0 7
67546: PUSH
67547: LD_VAR 0 7
67551: PUSH
67552: LD_VAR 0 1
67556: DIFF
67557: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
67558: LD_ADDR_EXP 33
67562: PUSH
67563: LD_EXP 33
67567: PPUSH
67568: LD_VAR 0 6
67572: PPUSH
67573: LD_VAR 0 7
67577: PPUSH
67578: CALL_OW 1
67582: ST_TO_ADDR
// break ;
67583: GO 67587
// end ;
67585: GO 67481
67587: POP
67588: POP
// end ;
67589: LD_VAR 0 5
67593: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
67594: LD_INT 0
67596: PPUSH
67597: PPUSH
67598: PPUSH
67599: PPUSH
// if not mc_bases or not skirmish then
67600: LD_EXP 14
67604: NOT
67605: PUSH
67606: LD_EXP 12
67610: NOT
67611: OR
67612: IFFALSE 67616
// exit ;
67614: GO 67999
// side := GetSide ( vehicle ) ;
67616: LD_ADDR_VAR 0 5
67620: PUSH
67621: LD_VAR 0 1
67625: PPUSH
67626: CALL_OW 255
67630: ST_TO_ADDR
// for i = 1 to mc_bases do
67631: LD_ADDR_VAR 0 4
67635: PUSH
67636: DOUBLE
67637: LD_INT 1
67639: DEC
67640: ST_TO_ADDR
67641: LD_EXP 14
67645: PUSH
67646: FOR_TO
67647: IFFALSE 67997
// begin if factory in mc_bases [ i ] then
67649: LD_VAR 0 2
67653: PUSH
67654: LD_EXP 14
67658: PUSH
67659: LD_VAR 0 4
67663: ARRAY
67664: IN
67665: IFFALSE 67995
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
67667: LD_EXP 36
67671: PUSH
67672: LD_VAR 0 4
67676: ARRAY
67677: PUSH
67678: LD_EXP 25
67682: PUSH
67683: LD_VAR 0 4
67687: ARRAY
67688: LESS
67689: PUSH
67690: LD_VAR 0 1
67694: PPUSH
67695: CALL_OW 264
67699: PUSH
67700: LD_INT 31
67702: PUSH
67703: LD_INT 32
67705: PUSH
67706: LD_INT 51
67708: PUSH
67709: LD_EXP 58
67713: PUSH
67714: LD_INT 12
67716: PUSH
67717: LD_INT 30
67719: PUSH
67720: LD_EXP 57
67724: PUSH
67725: LD_INT 11
67727: PUSH
67728: LD_INT 53
67730: PUSH
67731: LD_INT 14
67733: PUSH
67734: LD_EXP 61
67738: PUSH
67739: LD_INT 29
67741: PUSH
67742: LD_EXP 59
67746: PUSH
67747: LD_INT 13
67749: PUSH
67750: LD_INT 52
67752: PUSH
67753: LD_EXP 63
67757: PUSH
67758: LD_INT 48
67760: PUSH
67761: LD_INT 8
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: LIST
67777: LIST
67778: LIST
67779: LIST
67780: LIST
67781: LIST
67782: LIST
67783: IN
67784: NOT
67785: AND
67786: IFFALSE 67834
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
67788: LD_ADDR_EXP 36
67792: PUSH
67793: LD_EXP 36
67797: PPUSH
67798: LD_VAR 0 4
67802: PUSH
67803: LD_EXP 36
67807: PUSH
67808: LD_VAR 0 4
67812: ARRAY
67813: PUSH
67814: LD_INT 1
67816: PLUS
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PPUSH
67822: LD_VAR 0 1
67826: PPUSH
67827: CALL 9427 0 3
67831: ST_TO_ADDR
67832: GO 67878
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
67834: LD_ADDR_EXP 33
67838: PUSH
67839: LD_EXP 33
67843: PPUSH
67844: LD_VAR 0 4
67848: PUSH
67849: LD_EXP 33
67853: PUSH
67854: LD_VAR 0 4
67858: ARRAY
67859: PUSH
67860: LD_INT 1
67862: PLUS
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PPUSH
67868: LD_VAR 0 1
67872: PPUSH
67873: CALL 9427 0 3
67877: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
67878: LD_VAR 0 1
67882: PPUSH
67883: CALL_OW 263
67887: PUSH
67888: LD_INT 2
67890: EQUAL
67891: IFFALSE 67911
// begin repeat wait ( 0 0$1 ) ;
67893: LD_INT 35
67895: PPUSH
67896: CALL_OW 67
// until IsControledBy ( vehicle ) ;
67900: LD_VAR 0 1
67904: PPUSH
67905: CALL_OW 312
67909: IFFALSE 67893
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
67911: LD_VAR 0 1
67915: PPUSH
67916: LD_EXP 38
67920: PUSH
67921: LD_VAR 0 4
67925: ARRAY
67926: PPUSH
67927: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
67931: LD_VAR 0 1
67935: PPUSH
67936: CALL_OW 263
67940: PUSH
67941: LD_INT 1
67943: NONEQUAL
67944: IFFALSE 67948
// break ;
67946: GO 67997
// repeat wait ( 0 0$1 ) ;
67948: LD_INT 35
67950: PPUSH
67951: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
67955: LD_VAR 0 1
67959: PPUSH
67960: LD_EXP 38
67964: PUSH
67965: LD_VAR 0 4
67969: ARRAY
67970: PPUSH
67971: CALL_OW 308
67975: IFFALSE 67948
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
67977: LD_VAR 0 1
67981: PPUSH
67982: CALL_OW 311
67986: PPUSH
67987: CALL_OW 121
// exit ;
67991: POP
67992: POP
67993: GO 67999
// end ; end ;
67995: GO 67646
67997: POP
67998: POP
// end ;
67999: LD_VAR 0 3
68003: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
68004: LD_INT 0
68006: PPUSH
68007: PPUSH
68008: PPUSH
68009: PPUSH
// if not mc_bases or not skirmish then
68010: LD_EXP 14
68014: NOT
68015: PUSH
68016: LD_EXP 12
68020: NOT
68021: OR
68022: IFFALSE 68026
// exit ;
68024: GO 68379
// repeat wait ( 0 0$1 ) ;
68026: LD_INT 35
68028: PPUSH
68029: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
68033: LD_VAR 0 2
68037: PPUSH
68038: LD_VAR 0 3
68042: PPUSH
68043: CALL_OW 284
68047: IFFALSE 68026
// if GetResourceTypeXY ( x , y ) = mat_artefact then
68049: LD_VAR 0 2
68053: PPUSH
68054: LD_VAR 0 3
68058: PPUSH
68059: CALL_OW 283
68063: PUSH
68064: LD_INT 4
68066: EQUAL
68067: IFFALSE 68071
// exit ;
68069: GO 68379
// for i = 1 to mc_bases do
68071: LD_ADDR_VAR 0 7
68075: PUSH
68076: DOUBLE
68077: LD_INT 1
68079: DEC
68080: ST_TO_ADDR
68081: LD_EXP 14
68085: PUSH
68086: FOR_TO
68087: IFFALSE 68377
// begin if mc_crates_area [ i ] then
68089: LD_EXP 32
68093: PUSH
68094: LD_VAR 0 7
68098: ARRAY
68099: IFFALSE 68210
// for j in mc_crates_area [ i ] do
68101: LD_ADDR_VAR 0 8
68105: PUSH
68106: LD_EXP 32
68110: PUSH
68111: LD_VAR 0 7
68115: ARRAY
68116: PUSH
68117: FOR_IN
68118: IFFALSE 68208
// if InArea ( x , y , j ) then
68120: LD_VAR 0 2
68124: PPUSH
68125: LD_VAR 0 3
68129: PPUSH
68130: LD_VAR 0 8
68134: PPUSH
68135: CALL_OW 309
68139: IFFALSE 68206
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
68141: LD_ADDR_EXP 30
68145: PUSH
68146: LD_EXP 30
68150: PPUSH
68151: LD_VAR 0 7
68155: PUSH
68156: LD_EXP 30
68160: PUSH
68161: LD_VAR 0 7
68165: ARRAY
68166: PUSH
68167: LD_INT 1
68169: PLUS
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: PPUSH
68175: LD_VAR 0 4
68179: PUSH
68180: LD_VAR 0 2
68184: PUSH
68185: LD_VAR 0 3
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: LIST
68194: PPUSH
68195: CALL 9427 0 3
68199: ST_TO_ADDR
// exit ;
68200: POP
68201: POP
68202: POP
68203: POP
68204: GO 68379
// end ;
68206: GO 68117
68208: POP
68209: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68210: LD_ADDR_VAR 0 9
68214: PUSH
68215: LD_EXP 14
68219: PUSH
68220: LD_VAR 0 7
68224: ARRAY
68225: PPUSH
68226: LD_INT 2
68228: PUSH
68229: LD_INT 30
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: EMPTY
68236: LIST
68237: LIST
68238: PUSH
68239: LD_INT 30
68241: PUSH
68242: LD_INT 1
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: LIST
68253: PPUSH
68254: CALL_OW 72
68258: ST_TO_ADDR
// if not depot then
68259: LD_VAR 0 9
68263: NOT
68264: IFFALSE 68268
// continue ;
68266: GO 68086
// for j in depot do
68268: LD_ADDR_VAR 0 8
68272: PUSH
68273: LD_VAR 0 9
68277: PUSH
68278: FOR_IN
68279: IFFALSE 68373
// if GetDistUnitXY ( j , x , y ) < 30 then
68281: LD_VAR 0 8
68285: PPUSH
68286: LD_VAR 0 2
68290: PPUSH
68291: LD_VAR 0 3
68295: PPUSH
68296: CALL_OW 297
68300: PUSH
68301: LD_INT 30
68303: LESS
68304: IFFALSE 68371
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
68306: LD_ADDR_EXP 30
68310: PUSH
68311: LD_EXP 30
68315: PPUSH
68316: LD_VAR 0 7
68320: PUSH
68321: LD_EXP 30
68325: PUSH
68326: LD_VAR 0 7
68330: ARRAY
68331: PUSH
68332: LD_INT 1
68334: PLUS
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: PPUSH
68340: LD_VAR 0 4
68344: PUSH
68345: LD_VAR 0 2
68349: PUSH
68350: LD_VAR 0 3
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: LIST
68359: PPUSH
68360: CALL 9427 0 3
68364: ST_TO_ADDR
// exit ;
68365: POP
68366: POP
68367: POP
68368: POP
68369: GO 68379
// end ;
68371: GO 68278
68373: POP
68374: POP
// end ;
68375: GO 68086
68377: POP
68378: POP
// end ;
68379: LD_VAR 0 6
68383: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
68384: LD_INT 0
68386: PPUSH
68387: PPUSH
68388: PPUSH
68389: PPUSH
// if not mc_bases or not skirmish then
68390: LD_EXP 14
68394: NOT
68395: PUSH
68396: LD_EXP 12
68400: NOT
68401: OR
68402: IFFALSE 68406
// exit ;
68404: GO 68683
// side := GetSide ( lab ) ;
68406: LD_ADDR_VAR 0 4
68410: PUSH
68411: LD_VAR 0 2
68415: PPUSH
68416: CALL_OW 255
68420: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
68421: LD_VAR 0 4
68425: PUSH
68426: LD_EXP 40
68430: IN
68431: NOT
68432: PUSH
68433: LD_EXP 41
68437: NOT
68438: OR
68439: PUSH
68440: LD_EXP 14
68444: NOT
68445: OR
68446: IFFALSE 68450
// exit ;
68448: GO 68683
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
68450: LD_ADDR_EXP 41
68454: PUSH
68455: LD_EXP 41
68459: PPUSH
68460: LD_VAR 0 4
68464: PPUSH
68465: LD_EXP 41
68469: PUSH
68470: LD_VAR 0 4
68474: ARRAY
68475: PUSH
68476: LD_VAR 0 1
68480: DIFF
68481: PPUSH
68482: CALL_OW 1
68486: ST_TO_ADDR
// for i = 1 to mc_bases do
68487: LD_ADDR_VAR 0 5
68491: PUSH
68492: DOUBLE
68493: LD_INT 1
68495: DEC
68496: ST_TO_ADDR
68497: LD_EXP 14
68501: PUSH
68502: FOR_TO
68503: IFFALSE 68681
// begin if lab in mc_bases [ i ] then
68505: LD_VAR 0 2
68509: PUSH
68510: LD_EXP 14
68514: PUSH
68515: LD_VAR 0 5
68519: ARRAY
68520: IN
68521: IFFALSE 68679
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
68523: LD_VAR 0 1
68527: PUSH
68528: LD_INT 11
68530: PUSH
68531: LD_INT 4
68533: PUSH
68534: LD_INT 3
68536: PUSH
68537: LD_INT 2
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: LIST
68544: LIST
68545: IN
68546: PUSH
68547: LD_EXP 44
68551: PUSH
68552: LD_VAR 0 5
68556: ARRAY
68557: AND
68558: IFFALSE 68679
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
68560: LD_ADDR_VAR 0 6
68564: PUSH
68565: LD_EXP 44
68569: PUSH
68570: LD_VAR 0 5
68574: ARRAY
68575: PUSH
68576: LD_INT 1
68578: ARRAY
68579: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68580: LD_ADDR_EXP 44
68584: PUSH
68585: LD_EXP 44
68589: PPUSH
68590: LD_VAR 0 5
68594: PPUSH
68595: EMPTY
68596: PPUSH
68597: CALL_OW 1
68601: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
68602: LD_VAR 0 6
68606: PPUSH
68607: LD_INT 0
68609: PPUSH
68610: CALL_OW 109
// ComExitBuilding ( tmp ) ;
68614: LD_VAR 0 6
68618: PPUSH
68619: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
68623: LD_ADDR_EXP 43
68627: PUSH
68628: LD_EXP 43
68632: PPUSH
68633: LD_VAR 0 5
68637: PPUSH
68638: LD_EXP 43
68642: PUSH
68643: LD_VAR 0 5
68647: ARRAY
68648: PPUSH
68649: LD_INT 1
68651: PPUSH
68652: LD_VAR 0 6
68656: PPUSH
68657: CALL_OW 2
68661: PPUSH
68662: CALL_OW 1
68666: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
68667: LD_VAR 0 5
68671: PPUSH
68672: LD_INT 112
68674: PPUSH
68675: CALL 45628 0 2
// end ; end ; end ;
68679: GO 68502
68681: POP
68682: POP
// end ;
68683: LD_VAR 0 3
68687: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
68688: LD_INT 0
68690: PPUSH
68691: PPUSH
68692: PPUSH
68693: PPUSH
68694: PPUSH
68695: PPUSH
68696: PPUSH
68697: PPUSH
// if not mc_bases or not skirmish then
68698: LD_EXP 14
68702: NOT
68703: PUSH
68704: LD_EXP 12
68708: NOT
68709: OR
68710: IFFALSE 68714
// exit ;
68712: GO 70085
// for i = 1 to mc_bases do
68714: LD_ADDR_VAR 0 3
68718: PUSH
68719: DOUBLE
68720: LD_INT 1
68722: DEC
68723: ST_TO_ADDR
68724: LD_EXP 14
68728: PUSH
68729: FOR_TO
68730: IFFALSE 70083
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
68732: LD_VAR 0 1
68736: PUSH
68737: LD_EXP 14
68741: PUSH
68742: LD_VAR 0 3
68746: ARRAY
68747: IN
68748: PUSH
68749: LD_VAR 0 1
68753: PUSH
68754: LD_EXP 21
68758: PUSH
68759: LD_VAR 0 3
68763: ARRAY
68764: IN
68765: OR
68766: PUSH
68767: LD_VAR 0 1
68771: PUSH
68772: LD_EXP 36
68776: PUSH
68777: LD_VAR 0 3
68781: ARRAY
68782: IN
68783: OR
68784: PUSH
68785: LD_VAR 0 1
68789: PUSH
68790: LD_EXP 33
68794: PUSH
68795: LD_VAR 0 3
68799: ARRAY
68800: IN
68801: OR
68802: PUSH
68803: LD_VAR 0 1
68807: PUSH
68808: LD_EXP 43
68812: PUSH
68813: LD_VAR 0 3
68817: ARRAY
68818: IN
68819: OR
68820: PUSH
68821: LD_VAR 0 1
68825: PUSH
68826: LD_EXP 44
68830: PUSH
68831: LD_VAR 0 3
68835: ARRAY
68836: IN
68837: OR
68838: IFFALSE 70081
// begin if un in mc_ape [ i ] then
68840: LD_VAR 0 1
68844: PUSH
68845: LD_EXP 43
68849: PUSH
68850: LD_VAR 0 3
68854: ARRAY
68855: IN
68856: IFFALSE 68895
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
68858: LD_ADDR_EXP 43
68862: PUSH
68863: LD_EXP 43
68867: PPUSH
68868: LD_VAR 0 3
68872: PPUSH
68873: LD_EXP 43
68877: PUSH
68878: LD_VAR 0 3
68882: ARRAY
68883: PUSH
68884: LD_VAR 0 1
68888: DIFF
68889: PPUSH
68890: CALL_OW 1
68894: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
68895: LD_VAR 0 1
68899: PUSH
68900: LD_EXP 44
68904: PUSH
68905: LD_VAR 0 3
68909: ARRAY
68910: IN
68911: IFFALSE 68935
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68913: LD_ADDR_EXP 44
68917: PUSH
68918: LD_EXP 44
68922: PPUSH
68923: LD_VAR 0 3
68927: PPUSH
68928: EMPTY
68929: PPUSH
68930: CALL_OW 1
68934: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
68935: LD_VAR 0 1
68939: PPUSH
68940: CALL_OW 247
68944: PUSH
68945: LD_INT 2
68947: EQUAL
68948: PUSH
68949: LD_VAR 0 1
68953: PPUSH
68954: CALL_OW 110
68958: PUSH
68959: LD_INT 20
68961: EQUAL
68962: PUSH
68963: LD_VAR 0 1
68967: PUSH
68968: LD_EXP 36
68972: PUSH
68973: LD_VAR 0 3
68977: ARRAY
68978: IN
68979: OR
68980: PUSH
68981: LD_VAR 0 1
68985: PPUSH
68986: CALL_OW 264
68990: PUSH
68991: LD_INT 12
68993: PUSH
68994: LD_INT 51
68996: PUSH
68997: LD_EXP 58
69001: PUSH
69002: LD_INT 32
69004: PUSH
69005: LD_INT 13
69007: PUSH
69008: LD_INT 52
69010: PUSH
69011: LD_INT 31
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: LIST
69018: LIST
69019: LIST
69020: LIST
69021: LIST
69022: IN
69023: OR
69024: AND
69025: IFFALSE 69333
// begin if un in mc_defender [ i ] then
69027: LD_VAR 0 1
69031: PUSH
69032: LD_EXP 36
69036: PUSH
69037: LD_VAR 0 3
69041: ARRAY
69042: IN
69043: IFFALSE 69082
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69045: LD_ADDR_EXP 36
69049: PUSH
69050: LD_EXP 36
69054: PPUSH
69055: LD_VAR 0 3
69059: PPUSH
69060: LD_EXP 36
69064: PUSH
69065: LD_VAR 0 3
69069: ARRAY
69070: PUSH
69071: LD_VAR 0 1
69075: DIFF
69076: PPUSH
69077: CALL_OW 1
69081: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
69082: LD_ADDR_VAR 0 8
69086: PUSH
69087: LD_VAR 0 3
69091: PPUSH
69092: LD_INT 3
69094: PPUSH
69095: CALL 65732 0 2
69099: ST_TO_ADDR
// if fac then
69100: LD_VAR 0 8
69104: IFFALSE 69333
// begin for j in fac do
69106: LD_ADDR_VAR 0 4
69110: PUSH
69111: LD_VAR 0 8
69115: PUSH
69116: FOR_IN
69117: IFFALSE 69331
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
69119: LD_ADDR_VAR 0 9
69123: PUSH
69124: LD_VAR 0 8
69128: PPUSH
69129: LD_VAR 0 1
69133: PPUSH
69134: CALL_OW 265
69138: PPUSH
69139: LD_VAR 0 1
69143: PPUSH
69144: CALL_OW 262
69148: PPUSH
69149: LD_VAR 0 1
69153: PPUSH
69154: CALL_OW 263
69158: PPUSH
69159: LD_VAR 0 1
69163: PPUSH
69164: CALL_OW 264
69168: PPUSH
69169: CALL 6959 0 5
69173: ST_TO_ADDR
// if components then
69174: LD_VAR 0 9
69178: IFFALSE 69329
// begin if GetWeapon ( un ) = ar_control_tower then
69180: LD_VAR 0 1
69184: PPUSH
69185: CALL_OW 264
69189: PUSH
69190: LD_INT 31
69192: EQUAL
69193: IFFALSE 69310
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
69195: LD_VAR 0 1
69199: PPUSH
69200: CALL_OW 311
69204: PPUSH
69205: LD_INT 0
69207: PPUSH
69208: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
69212: LD_ADDR_EXP 54
69216: PUSH
69217: LD_EXP 54
69221: PPUSH
69222: LD_VAR 0 3
69226: PPUSH
69227: LD_EXP 54
69231: PUSH
69232: LD_VAR 0 3
69236: ARRAY
69237: PUSH
69238: LD_VAR 0 1
69242: PPUSH
69243: CALL_OW 311
69247: DIFF
69248: PPUSH
69249: CALL_OW 1
69253: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
69254: LD_ADDR_VAR 0 7
69258: PUSH
69259: LD_EXP 35
69263: PUSH
69264: LD_VAR 0 3
69268: ARRAY
69269: PPUSH
69270: LD_INT 1
69272: PPUSH
69273: LD_VAR 0 9
69277: PPUSH
69278: CALL_OW 2
69282: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69283: LD_ADDR_EXP 35
69287: PUSH
69288: LD_EXP 35
69292: PPUSH
69293: LD_VAR 0 3
69297: PPUSH
69298: LD_VAR 0 7
69302: PPUSH
69303: CALL_OW 1
69307: ST_TO_ADDR
// end else
69308: GO 69327
// MC_InsertProduceList ( i , [ components ] ) ;
69310: LD_VAR 0 3
69314: PPUSH
69315: LD_VAR 0 9
69319: PUSH
69320: EMPTY
69321: LIST
69322: PPUSH
69323: CALL 65277 0 2
// break ;
69327: GO 69331
// end ; end ;
69329: GO 69116
69331: POP
69332: POP
// end ; end ; if GetType ( un ) = unit_building then
69333: LD_VAR 0 1
69337: PPUSH
69338: CALL_OW 247
69342: PUSH
69343: LD_INT 3
69345: EQUAL
69346: IFFALSE 69749
// begin btype := GetBType ( un ) ;
69348: LD_ADDR_VAR 0 5
69352: PUSH
69353: LD_VAR 0 1
69357: PPUSH
69358: CALL_OW 266
69362: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
69363: LD_VAR 0 5
69367: PUSH
69368: LD_INT 29
69370: PUSH
69371: LD_INT 30
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: IN
69378: IFFALSE 69451
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
69380: LD_VAR 0 1
69384: PPUSH
69385: CALL_OW 250
69389: PPUSH
69390: LD_VAR 0 1
69394: PPUSH
69395: CALL_OW 251
69399: PPUSH
69400: LD_VAR 0 1
69404: PPUSH
69405: CALL_OW 255
69409: PPUSH
69410: CALL_OW 440
69414: NOT
69415: IFFALSE 69451
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
69417: LD_VAR 0 1
69421: PPUSH
69422: CALL_OW 250
69426: PPUSH
69427: LD_VAR 0 1
69431: PPUSH
69432: CALL_OW 251
69436: PPUSH
69437: LD_VAR 0 1
69441: PPUSH
69442: CALL_OW 255
69446: PPUSH
69447: CALL_OW 441
// end ; if btype = b_warehouse then
69451: LD_VAR 0 5
69455: PUSH
69456: LD_INT 1
69458: EQUAL
69459: IFFALSE 69477
// begin btype := b_depot ;
69461: LD_ADDR_VAR 0 5
69465: PUSH
69466: LD_INT 0
69468: ST_TO_ADDR
// pos := 1 ;
69469: LD_ADDR_VAR 0 6
69473: PUSH
69474: LD_INT 1
69476: ST_TO_ADDR
// end ; if btype = b_factory then
69477: LD_VAR 0 5
69481: PUSH
69482: LD_INT 3
69484: EQUAL
69485: IFFALSE 69503
// begin btype := b_workshop ;
69487: LD_ADDR_VAR 0 5
69491: PUSH
69492: LD_INT 2
69494: ST_TO_ADDR
// pos := 1 ;
69495: LD_ADDR_VAR 0 6
69499: PUSH
69500: LD_INT 1
69502: ST_TO_ADDR
// end ; if btype = b_barracks then
69503: LD_VAR 0 5
69507: PUSH
69508: LD_INT 5
69510: EQUAL
69511: IFFALSE 69521
// btype := b_armoury ;
69513: LD_ADDR_VAR 0 5
69517: PUSH
69518: LD_INT 4
69520: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
69521: LD_VAR 0 5
69525: PUSH
69526: LD_INT 7
69528: PUSH
69529: LD_INT 8
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: IN
69536: IFFALSE 69546
// btype := b_lab ;
69538: LD_ADDR_VAR 0 5
69542: PUSH
69543: LD_INT 6
69545: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
69546: LD_ADDR_EXP 19
69550: PUSH
69551: LD_EXP 19
69555: PPUSH
69556: LD_VAR 0 3
69560: PUSH
69561: LD_EXP 19
69565: PUSH
69566: LD_VAR 0 3
69570: ARRAY
69571: PUSH
69572: LD_INT 1
69574: PLUS
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PPUSH
69580: LD_VAR 0 5
69584: PUSH
69585: LD_VAR 0 1
69589: PPUSH
69590: CALL_OW 250
69594: PUSH
69595: LD_VAR 0 1
69599: PPUSH
69600: CALL_OW 251
69604: PUSH
69605: LD_VAR 0 1
69609: PPUSH
69610: CALL_OW 254
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: LIST
69619: LIST
69620: PPUSH
69621: CALL 9427 0 3
69625: ST_TO_ADDR
// if pos = 1 then
69626: LD_VAR 0 6
69630: PUSH
69631: LD_INT 1
69633: EQUAL
69634: IFFALSE 69749
// begin tmp := mc_build_list [ i ] ;
69636: LD_ADDR_VAR 0 7
69640: PUSH
69641: LD_EXP 19
69645: PUSH
69646: LD_VAR 0 3
69650: ARRAY
69651: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
69652: LD_VAR 0 7
69656: PPUSH
69657: LD_INT 2
69659: PUSH
69660: LD_INT 30
69662: PUSH
69663: LD_INT 0
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 30
69672: PUSH
69673: LD_INT 1
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: LIST
69684: PPUSH
69685: CALL_OW 72
69689: IFFALSE 69699
// pos := 2 ;
69691: LD_ADDR_VAR 0 6
69695: PUSH
69696: LD_INT 2
69698: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
69699: LD_ADDR_VAR 0 7
69703: PUSH
69704: LD_VAR 0 7
69708: PPUSH
69709: LD_VAR 0 6
69713: PPUSH
69714: LD_VAR 0 7
69718: PPUSH
69719: CALL 9753 0 3
69723: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
69724: LD_ADDR_EXP 19
69728: PUSH
69729: LD_EXP 19
69733: PPUSH
69734: LD_VAR 0 3
69738: PPUSH
69739: LD_VAR 0 7
69743: PPUSH
69744: CALL_OW 1
69748: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
69749: LD_VAR 0 1
69753: PUSH
69754: LD_EXP 14
69758: PUSH
69759: LD_VAR 0 3
69763: ARRAY
69764: IN
69765: IFFALSE 69804
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
69767: LD_ADDR_EXP 14
69771: PUSH
69772: LD_EXP 14
69776: PPUSH
69777: LD_VAR 0 3
69781: PPUSH
69782: LD_EXP 14
69786: PUSH
69787: LD_VAR 0 3
69791: ARRAY
69792: PUSH
69793: LD_VAR 0 1
69797: DIFF
69798: PPUSH
69799: CALL_OW 1
69803: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
69804: LD_VAR 0 1
69808: PUSH
69809: LD_EXP 21
69813: PUSH
69814: LD_VAR 0 3
69818: ARRAY
69819: IN
69820: IFFALSE 69859
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
69822: LD_ADDR_EXP 21
69826: PUSH
69827: LD_EXP 21
69831: PPUSH
69832: LD_VAR 0 3
69836: PPUSH
69837: LD_EXP 21
69841: PUSH
69842: LD_VAR 0 3
69846: ARRAY
69847: PUSH
69848: LD_VAR 0 1
69852: DIFF
69853: PPUSH
69854: CALL_OW 1
69858: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
69859: LD_VAR 0 1
69863: PUSH
69864: LD_EXP 33
69868: PUSH
69869: LD_VAR 0 3
69873: ARRAY
69874: IN
69875: IFFALSE 69914
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
69877: LD_ADDR_EXP 33
69881: PUSH
69882: LD_EXP 33
69886: PPUSH
69887: LD_VAR 0 3
69891: PPUSH
69892: LD_EXP 33
69896: PUSH
69897: LD_VAR 0 3
69901: ARRAY
69902: PUSH
69903: LD_VAR 0 1
69907: DIFF
69908: PPUSH
69909: CALL_OW 1
69913: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
69914: LD_VAR 0 1
69918: PUSH
69919: LD_EXP 36
69923: PUSH
69924: LD_VAR 0 3
69928: ARRAY
69929: IN
69930: IFFALSE 69969
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69932: LD_ADDR_EXP 36
69936: PUSH
69937: LD_EXP 36
69941: PPUSH
69942: LD_VAR 0 3
69946: PPUSH
69947: LD_EXP 36
69951: PUSH
69952: LD_VAR 0 3
69956: ARRAY
69957: PUSH
69958: LD_VAR 0 1
69962: DIFF
69963: PPUSH
69964: CALL_OW 1
69968: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
69969: LD_VAR 0 1
69973: PUSH
69974: LD_EXP 23
69978: PUSH
69979: LD_VAR 0 3
69983: ARRAY
69984: IN
69985: IFFALSE 70024
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
69987: LD_ADDR_EXP 23
69991: PUSH
69992: LD_EXP 23
69996: PPUSH
69997: LD_VAR 0 3
70001: PPUSH
70002: LD_EXP 23
70006: PUSH
70007: LD_VAR 0 3
70011: ARRAY
70012: PUSH
70013: LD_VAR 0 1
70017: DIFF
70018: PPUSH
70019: CALL_OW 1
70023: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
70024: LD_VAR 0 1
70028: PUSH
70029: LD_EXP 22
70033: PUSH
70034: LD_VAR 0 3
70038: ARRAY
70039: IN
70040: IFFALSE 70079
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
70042: LD_ADDR_EXP 22
70046: PUSH
70047: LD_EXP 22
70051: PPUSH
70052: LD_VAR 0 3
70056: PPUSH
70057: LD_EXP 22
70061: PUSH
70062: LD_VAR 0 3
70066: ARRAY
70067: PUSH
70068: LD_VAR 0 1
70072: DIFF
70073: PPUSH
70074: CALL_OW 1
70078: ST_TO_ADDR
// end ; break ;
70079: GO 70083
// end ;
70081: GO 68729
70083: POP
70084: POP
// end ;
70085: LD_VAR 0 2
70089: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
70090: LD_INT 0
70092: PPUSH
70093: PPUSH
70094: PPUSH
// if not mc_bases or not skirmish then
70095: LD_EXP 14
70099: NOT
70100: PUSH
70101: LD_EXP 12
70105: NOT
70106: OR
70107: IFFALSE 70111
// exit ;
70109: GO 70326
// for i = 1 to mc_bases do
70111: LD_ADDR_VAR 0 3
70115: PUSH
70116: DOUBLE
70117: LD_INT 1
70119: DEC
70120: ST_TO_ADDR
70121: LD_EXP 14
70125: PUSH
70126: FOR_TO
70127: IFFALSE 70324
// begin if building in mc_construct_list [ i ] then
70129: LD_VAR 0 1
70133: PUSH
70134: LD_EXP 21
70138: PUSH
70139: LD_VAR 0 3
70143: ARRAY
70144: IN
70145: IFFALSE 70322
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
70147: LD_ADDR_EXP 21
70151: PUSH
70152: LD_EXP 21
70156: PPUSH
70157: LD_VAR 0 3
70161: PPUSH
70162: LD_EXP 21
70166: PUSH
70167: LD_VAR 0 3
70171: ARRAY
70172: PUSH
70173: LD_VAR 0 1
70177: DIFF
70178: PPUSH
70179: CALL_OW 1
70183: ST_TO_ADDR
// if building in mc_lab [ i ] then
70184: LD_VAR 0 1
70188: PUSH
70189: LD_EXP 47
70193: PUSH
70194: LD_VAR 0 3
70198: ARRAY
70199: IN
70200: IFFALSE 70255
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
70202: LD_ADDR_EXP 48
70206: PUSH
70207: LD_EXP 48
70211: PPUSH
70212: LD_VAR 0 3
70216: PPUSH
70217: LD_EXP 48
70221: PUSH
70222: LD_VAR 0 3
70226: ARRAY
70227: PPUSH
70228: LD_INT 1
70230: PPUSH
70231: LD_EXP 48
70235: PUSH
70236: LD_VAR 0 3
70240: ARRAY
70241: PPUSH
70242: LD_INT 0
70244: PPUSH
70245: CALL 8845 0 4
70249: PPUSH
70250: CALL_OW 1
70254: ST_TO_ADDR
// if not building in mc_bases [ i ] then
70255: LD_VAR 0 1
70259: PUSH
70260: LD_EXP 14
70264: PUSH
70265: LD_VAR 0 3
70269: ARRAY
70270: IN
70271: NOT
70272: IFFALSE 70318
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
70274: LD_ADDR_EXP 14
70278: PUSH
70279: LD_EXP 14
70283: PPUSH
70284: LD_VAR 0 3
70288: PUSH
70289: LD_EXP 14
70293: PUSH
70294: LD_VAR 0 3
70298: ARRAY
70299: PUSH
70300: LD_INT 1
70302: PLUS
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PPUSH
70308: LD_VAR 0 1
70312: PPUSH
70313: CALL 9427 0 3
70317: ST_TO_ADDR
// exit ;
70318: POP
70319: POP
70320: GO 70326
// end ; end ;
70322: GO 70126
70324: POP
70325: POP
// end ;
70326: LD_VAR 0 2
70330: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
70331: LD_INT 0
70333: PPUSH
70334: PPUSH
70335: PPUSH
70336: PPUSH
70337: PPUSH
70338: PPUSH
70339: PPUSH
// if not mc_bases or not skirmish then
70340: LD_EXP 14
70344: NOT
70345: PUSH
70346: LD_EXP 12
70350: NOT
70351: OR
70352: IFFALSE 70356
// exit ;
70354: GO 71017
// for i = 1 to mc_bases do
70356: LD_ADDR_VAR 0 3
70360: PUSH
70361: DOUBLE
70362: LD_INT 1
70364: DEC
70365: ST_TO_ADDR
70366: LD_EXP 14
70370: PUSH
70371: FOR_TO
70372: IFFALSE 71015
// begin if building in mc_construct_list [ i ] then
70374: LD_VAR 0 1
70378: PUSH
70379: LD_EXP 21
70383: PUSH
70384: LD_VAR 0 3
70388: ARRAY
70389: IN
70390: IFFALSE 71013
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
70392: LD_ADDR_EXP 21
70396: PUSH
70397: LD_EXP 21
70401: PPUSH
70402: LD_VAR 0 3
70406: PPUSH
70407: LD_EXP 21
70411: PUSH
70412: LD_VAR 0 3
70416: ARRAY
70417: PUSH
70418: LD_VAR 0 1
70422: DIFF
70423: PPUSH
70424: CALL_OW 1
70428: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
70429: LD_ADDR_EXP 14
70433: PUSH
70434: LD_EXP 14
70438: PPUSH
70439: LD_VAR 0 3
70443: PUSH
70444: LD_EXP 14
70448: PUSH
70449: LD_VAR 0 3
70453: ARRAY
70454: PUSH
70455: LD_INT 1
70457: PLUS
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PPUSH
70463: LD_VAR 0 1
70467: PPUSH
70468: CALL 9427 0 3
70472: ST_TO_ADDR
// btype := GetBType ( building ) ;
70473: LD_ADDR_VAR 0 5
70477: PUSH
70478: LD_VAR 0 1
70482: PPUSH
70483: CALL_OW 266
70487: ST_TO_ADDR
// side := GetSide ( building ) ;
70488: LD_ADDR_VAR 0 8
70492: PUSH
70493: LD_VAR 0 1
70497: PPUSH
70498: CALL_OW 255
70502: ST_TO_ADDR
// if btype = b_lab then
70503: LD_VAR 0 5
70507: PUSH
70508: LD_INT 6
70510: EQUAL
70511: IFFALSE 70561
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
70513: LD_ADDR_EXP 47
70517: PUSH
70518: LD_EXP 47
70522: PPUSH
70523: LD_VAR 0 3
70527: PUSH
70528: LD_EXP 47
70532: PUSH
70533: LD_VAR 0 3
70537: ARRAY
70538: PUSH
70539: LD_INT 1
70541: PLUS
70542: PUSH
70543: EMPTY
70544: LIST
70545: LIST
70546: PPUSH
70547: LD_VAR 0 1
70551: PPUSH
70552: CALL 9427 0 3
70556: ST_TO_ADDR
// exit ;
70557: POP
70558: POP
70559: GO 71017
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
70561: LD_VAR 0 5
70565: PUSH
70566: LD_INT 0
70568: PUSH
70569: LD_INT 2
70571: PUSH
70572: LD_INT 4
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: LIST
70579: IN
70580: IFFALSE 70704
// begin if btype = b_armoury then
70582: LD_VAR 0 5
70586: PUSH
70587: LD_INT 4
70589: EQUAL
70590: IFFALSE 70600
// btype := b_barracks ;
70592: LD_ADDR_VAR 0 5
70596: PUSH
70597: LD_INT 5
70599: ST_TO_ADDR
// if btype = b_depot then
70600: LD_VAR 0 5
70604: PUSH
70605: LD_INT 0
70607: EQUAL
70608: IFFALSE 70618
// btype := b_warehouse ;
70610: LD_ADDR_VAR 0 5
70614: PUSH
70615: LD_INT 1
70617: ST_TO_ADDR
// if btype = b_workshop then
70618: LD_VAR 0 5
70622: PUSH
70623: LD_INT 2
70625: EQUAL
70626: IFFALSE 70636
// btype := b_factory ;
70628: LD_ADDR_VAR 0 5
70632: PUSH
70633: LD_INT 3
70635: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
70636: LD_VAR 0 5
70640: PPUSH
70641: LD_VAR 0 8
70645: PPUSH
70646: CALL_OW 323
70650: PUSH
70651: LD_INT 1
70653: EQUAL
70654: IFFALSE 70700
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
70656: LD_ADDR_EXP 46
70660: PUSH
70661: LD_EXP 46
70665: PPUSH
70666: LD_VAR 0 3
70670: PUSH
70671: LD_EXP 46
70675: PUSH
70676: LD_VAR 0 3
70680: ARRAY
70681: PUSH
70682: LD_INT 1
70684: PLUS
70685: PUSH
70686: EMPTY
70687: LIST
70688: LIST
70689: PPUSH
70690: LD_VAR 0 1
70694: PPUSH
70695: CALL 9427 0 3
70699: ST_TO_ADDR
// exit ;
70700: POP
70701: POP
70702: GO 71017
// end ; if btype in [ b_bunker , b_turret ] then
70704: LD_VAR 0 5
70708: PUSH
70709: LD_INT 32
70711: PUSH
70712: LD_INT 33
70714: PUSH
70715: EMPTY
70716: LIST
70717: LIST
70718: IN
70719: IFFALSE 71009
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
70721: LD_ADDR_EXP 22
70725: PUSH
70726: LD_EXP 22
70730: PPUSH
70731: LD_VAR 0 3
70735: PUSH
70736: LD_EXP 22
70740: PUSH
70741: LD_VAR 0 3
70745: ARRAY
70746: PUSH
70747: LD_INT 1
70749: PLUS
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PPUSH
70755: LD_VAR 0 1
70759: PPUSH
70760: CALL 9427 0 3
70764: ST_TO_ADDR
// if btype = b_bunker then
70765: LD_VAR 0 5
70769: PUSH
70770: LD_INT 32
70772: EQUAL
70773: IFFALSE 71009
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70775: LD_ADDR_EXP 23
70779: PUSH
70780: LD_EXP 23
70784: PPUSH
70785: LD_VAR 0 3
70789: PUSH
70790: LD_EXP 23
70794: PUSH
70795: LD_VAR 0 3
70799: ARRAY
70800: PUSH
70801: LD_INT 1
70803: PLUS
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PPUSH
70809: LD_VAR 0 1
70813: PPUSH
70814: CALL 9427 0 3
70818: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
70819: LD_ADDR_VAR 0 6
70823: PUSH
70824: LD_EXP 14
70828: PUSH
70829: LD_VAR 0 3
70833: ARRAY
70834: PPUSH
70835: LD_INT 25
70837: PUSH
70838: LD_INT 1
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: PUSH
70845: LD_INT 3
70847: PUSH
70848: LD_INT 54
70850: PUSH
70851: EMPTY
70852: LIST
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PPUSH
70862: CALL_OW 72
70866: ST_TO_ADDR
// if tmp then
70867: LD_VAR 0 6
70871: IFFALSE 70877
// exit ;
70873: POP
70874: POP
70875: GO 71017
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70877: LD_ADDR_VAR 0 6
70881: PUSH
70882: LD_EXP 14
70886: PUSH
70887: LD_VAR 0 3
70891: ARRAY
70892: PPUSH
70893: LD_INT 2
70895: PUSH
70896: LD_INT 30
70898: PUSH
70899: LD_INT 4
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: PUSH
70906: LD_INT 30
70908: PUSH
70909: LD_INT 5
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: LIST
70920: PPUSH
70921: CALL_OW 72
70925: ST_TO_ADDR
// if not tmp then
70926: LD_VAR 0 6
70930: NOT
70931: IFFALSE 70937
// exit ;
70933: POP
70934: POP
70935: GO 71017
// for j in tmp do
70937: LD_ADDR_VAR 0 4
70941: PUSH
70942: LD_VAR 0 6
70946: PUSH
70947: FOR_IN
70948: IFFALSE 71007
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
70950: LD_ADDR_VAR 0 7
70954: PUSH
70955: LD_VAR 0 4
70959: PPUSH
70960: CALL_OW 313
70964: PPUSH
70965: LD_INT 25
70967: PUSH
70968: LD_INT 1
70970: PUSH
70971: EMPTY
70972: LIST
70973: LIST
70974: PPUSH
70975: CALL_OW 72
70979: ST_TO_ADDR
// if units then
70980: LD_VAR 0 7
70984: IFFALSE 71005
// begin ComExitBuilding ( units [ 1 ] ) ;
70986: LD_VAR 0 7
70990: PUSH
70991: LD_INT 1
70993: ARRAY
70994: PPUSH
70995: CALL_OW 122
// exit ;
70999: POP
71000: POP
71001: POP
71002: POP
71003: GO 71017
// end ; end ;
71005: GO 70947
71007: POP
71008: POP
// end ; end ; exit ;
71009: POP
71010: POP
71011: GO 71017
// end ; end ;
71013: GO 70371
71015: POP
71016: POP
// end ;
71017: LD_VAR 0 2
71021: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
71022: LD_INT 0
71024: PPUSH
71025: PPUSH
71026: PPUSH
71027: PPUSH
71028: PPUSH
71029: PPUSH
71030: PPUSH
// if not mc_bases or not skirmish then
71031: LD_EXP 14
71035: NOT
71036: PUSH
71037: LD_EXP 12
71041: NOT
71042: OR
71043: IFFALSE 71047
// exit ;
71045: GO 71278
// btype := GetBType ( building ) ;
71047: LD_ADDR_VAR 0 6
71051: PUSH
71052: LD_VAR 0 1
71056: PPUSH
71057: CALL_OW 266
71061: ST_TO_ADDR
// x := GetX ( building ) ;
71062: LD_ADDR_VAR 0 7
71066: PUSH
71067: LD_VAR 0 1
71071: PPUSH
71072: CALL_OW 250
71076: ST_TO_ADDR
// y := GetY ( building ) ;
71077: LD_ADDR_VAR 0 8
71081: PUSH
71082: LD_VAR 0 1
71086: PPUSH
71087: CALL_OW 251
71091: ST_TO_ADDR
// d := GetDir ( building ) ;
71092: LD_ADDR_VAR 0 9
71096: PUSH
71097: LD_VAR 0 1
71101: PPUSH
71102: CALL_OW 254
71106: ST_TO_ADDR
// for i = 1 to mc_bases do
71107: LD_ADDR_VAR 0 4
71111: PUSH
71112: DOUBLE
71113: LD_INT 1
71115: DEC
71116: ST_TO_ADDR
71117: LD_EXP 14
71121: PUSH
71122: FOR_TO
71123: IFFALSE 71276
// begin if not mc_build_list [ i ] then
71125: LD_EXP 19
71129: PUSH
71130: LD_VAR 0 4
71134: ARRAY
71135: NOT
71136: IFFALSE 71140
// continue ;
71138: GO 71122
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
71140: LD_VAR 0 6
71144: PUSH
71145: LD_VAR 0 7
71149: PUSH
71150: LD_VAR 0 8
71154: PUSH
71155: LD_VAR 0 9
71159: PUSH
71160: EMPTY
71161: LIST
71162: LIST
71163: LIST
71164: LIST
71165: PPUSH
71166: LD_EXP 19
71170: PUSH
71171: LD_VAR 0 4
71175: ARRAY
71176: PUSH
71177: LD_INT 1
71179: ARRAY
71180: PPUSH
71181: CALL 15596 0 2
71185: IFFALSE 71274
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
71187: LD_ADDR_EXP 19
71191: PUSH
71192: LD_EXP 19
71196: PPUSH
71197: LD_VAR 0 4
71201: PPUSH
71202: LD_EXP 19
71206: PUSH
71207: LD_VAR 0 4
71211: ARRAY
71212: PPUSH
71213: LD_INT 1
71215: PPUSH
71216: CALL_OW 3
71220: PPUSH
71221: CALL_OW 1
71225: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
71226: LD_ADDR_EXP 21
71230: PUSH
71231: LD_EXP 21
71235: PPUSH
71236: LD_VAR 0 4
71240: PUSH
71241: LD_EXP 21
71245: PUSH
71246: LD_VAR 0 4
71250: ARRAY
71251: PUSH
71252: LD_INT 1
71254: PLUS
71255: PUSH
71256: EMPTY
71257: LIST
71258: LIST
71259: PPUSH
71260: LD_VAR 0 1
71264: PPUSH
71265: CALL 9427 0 3
71269: ST_TO_ADDR
// exit ;
71270: POP
71271: POP
71272: GO 71278
// end ; end ;
71274: GO 71122
71276: POP
71277: POP
// end ;
71278: LD_VAR 0 3
71282: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
71283: LD_INT 0
71285: PPUSH
71286: PPUSH
71287: PPUSH
// if not mc_bases or not skirmish then
71288: LD_EXP 14
71292: NOT
71293: PUSH
71294: LD_EXP 12
71298: NOT
71299: OR
71300: IFFALSE 71304
// exit ;
71302: GO 71494
// for i = 1 to mc_bases do
71304: LD_ADDR_VAR 0 4
71308: PUSH
71309: DOUBLE
71310: LD_INT 1
71312: DEC
71313: ST_TO_ADDR
71314: LD_EXP 14
71318: PUSH
71319: FOR_TO
71320: IFFALSE 71407
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
71322: LD_VAR 0 1
71326: PUSH
71327: LD_EXP 22
71331: PUSH
71332: LD_VAR 0 4
71336: ARRAY
71337: IN
71338: PUSH
71339: LD_VAR 0 1
71343: PUSH
71344: LD_EXP 23
71348: PUSH
71349: LD_VAR 0 4
71353: ARRAY
71354: IN
71355: NOT
71356: AND
71357: IFFALSE 71405
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
71359: LD_ADDR_EXP 23
71363: PUSH
71364: LD_EXP 23
71368: PPUSH
71369: LD_VAR 0 4
71373: PUSH
71374: LD_EXP 23
71378: PUSH
71379: LD_VAR 0 4
71383: ARRAY
71384: PUSH
71385: LD_INT 1
71387: PLUS
71388: PUSH
71389: EMPTY
71390: LIST
71391: LIST
71392: PPUSH
71393: LD_VAR 0 1
71397: PPUSH
71398: CALL 9427 0 3
71402: ST_TO_ADDR
// break ;
71403: GO 71407
// end ; end ;
71405: GO 71319
71407: POP
71408: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
71409: LD_VAR 0 1
71413: PPUSH
71414: CALL_OW 257
71418: PUSH
71419: LD_EXP 40
71423: IN
71424: PUSH
71425: LD_VAR 0 1
71429: PPUSH
71430: CALL_OW 266
71434: PUSH
71435: LD_INT 5
71437: EQUAL
71438: AND
71439: PUSH
71440: LD_VAR 0 2
71444: PPUSH
71445: CALL_OW 110
71449: PUSH
71450: LD_INT 18
71452: NONEQUAL
71453: AND
71454: IFFALSE 71494
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
71456: LD_VAR 0 2
71460: PPUSH
71461: CALL_OW 257
71465: PUSH
71466: LD_INT 5
71468: PUSH
71469: LD_INT 8
71471: PUSH
71472: LD_INT 9
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: LIST
71479: IN
71480: IFFALSE 71494
// SetClass ( unit , 1 ) ;
71482: LD_VAR 0 2
71486: PPUSH
71487: LD_INT 1
71489: PPUSH
71490: CALL_OW 336
// end ;
71494: LD_VAR 0 3
71498: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
71499: LD_INT 0
71501: PPUSH
71502: PPUSH
// if not mc_bases or not skirmish then
71503: LD_EXP 14
71507: NOT
71508: PUSH
71509: LD_EXP 12
71513: NOT
71514: OR
71515: IFFALSE 71519
// exit ;
71517: GO 71635
// if GetLives ( abandoned_vehicle ) > 250 then
71519: LD_VAR 0 2
71523: PPUSH
71524: CALL_OW 256
71528: PUSH
71529: LD_INT 250
71531: GREATER
71532: IFFALSE 71536
// exit ;
71534: GO 71635
// for i = 1 to mc_bases do
71536: LD_ADDR_VAR 0 6
71540: PUSH
71541: DOUBLE
71542: LD_INT 1
71544: DEC
71545: ST_TO_ADDR
71546: LD_EXP 14
71550: PUSH
71551: FOR_TO
71552: IFFALSE 71633
// begin if driver in mc_bases [ i ] then
71554: LD_VAR 0 1
71558: PUSH
71559: LD_EXP 14
71563: PUSH
71564: LD_VAR 0 6
71568: ARRAY
71569: IN
71570: IFFALSE 71631
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
71572: LD_VAR 0 1
71576: PPUSH
71577: LD_EXP 14
71581: PUSH
71582: LD_VAR 0 6
71586: ARRAY
71587: PPUSH
71588: LD_INT 2
71590: PUSH
71591: LD_INT 30
71593: PUSH
71594: LD_INT 0
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: PUSH
71601: LD_INT 30
71603: PUSH
71604: LD_INT 1
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: PUSH
71611: EMPTY
71612: LIST
71613: LIST
71614: LIST
71615: PPUSH
71616: CALL_OW 72
71620: PUSH
71621: LD_INT 1
71623: ARRAY
71624: PPUSH
71625: CALL 41293 0 2
// break ;
71629: GO 71633
// end ; end ;
71631: GO 71551
71633: POP
71634: POP
// end ; end_of_file
71635: LD_VAR 0 5
71639: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
71640: LD_INT 0
71642: PPUSH
// ar_miner := 81 ;
71643: LD_ADDR_EXP 64
71647: PUSH
71648: LD_INT 81
71650: ST_TO_ADDR
// ar_crane := 88 ;
71651: LD_ADDR_EXP 63
71655: PUSH
71656: LD_INT 88
71658: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
71659: LD_ADDR_EXP 58
71663: PUSH
71664: LD_INT 89
71666: ST_TO_ADDR
// us_hack := 99 ;
71667: LD_ADDR_EXP 59
71671: PUSH
71672: LD_INT 99
71674: ST_TO_ADDR
// us_artillery := 97 ;
71675: LD_ADDR_EXP 60
71679: PUSH
71680: LD_INT 97
71682: ST_TO_ADDR
// ar_bio_bomb := 91 ;
71683: LD_ADDR_EXP 61
71687: PUSH
71688: LD_INT 91
71690: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
71691: LD_ADDR_EXP 62
71695: PUSH
71696: LD_INT 92
71698: ST_TO_ADDR
// ru_radar := 98 ;
71699: LD_ADDR_EXP 57
71703: PUSH
71704: LD_INT 98
71706: ST_TO_ADDR
// tech_Artillery := 80 ;
71707: LD_ADDR_EXP 65
71711: PUSH
71712: LD_INT 80
71714: ST_TO_ADDR
// tech_RadMat := 81 ;
71715: LD_ADDR_EXP 66
71719: PUSH
71720: LD_INT 81
71722: ST_TO_ADDR
// tech_BasicTools := 82 ;
71723: LD_ADDR_EXP 67
71727: PUSH
71728: LD_INT 82
71730: ST_TO_ADDR
// tech_Cargo := 83 ;
71731: LD_ADDR_EXP 68
71735: PUSH
71736: LD_INT 83
71738: ST_TO_ADDR
// tech_Track := 84 ;
71739: LD_ADDR_EXP 69
71743: PUSH
71744: LD_INT 84
71746: ST_TO_ADDR
// tech_Crane := 85 ;
71747: LD_ADDR_EXP 70
71751: PUSH
71752: LD_INT 85
71754: ST_TO_ADDR
// tech_Bulldozer := 86 ;
71755: LD_ADDR_EXP 71
71759: PUSH
71760: LD_INT 86
71762: ST_TO_ADDR
// tech_Hovercraft := 87 ;
71763: LD_ADDR_EXP 72
71767: PUSH
71768: LD_INT 87
71770: ST_TO_ADDR
// end ;
71771: LD_VAR 0 1
71775: RET
// every 1 do
71776: GO 71778
71778: DISABLE
// InitGlobalVariables ; end_of_file
71779: CALL 71640 0 0
71783: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
71784: LD_INT 0
71786: PPUSH
71787: PPUSH
71788: PPUSH
71789: PPUSH
71790: PPUSH
71791: PPUSH
71792: PPUSH
71793: PPUSH
71794: PPUSH
71795: PPUSH
71796: PPUSH
71797: PPUSH
71798: PPUSH
71799: PPUSH
71800: PPUSH
71801: PPUSH
71802: PPUSH
71803: PPUSH
71804: PPUSH
71805: PPUSH
71806: PPUSH
71807: PPUSH
71808: PPUSH
71809: PPUSH
71810: PPUSH
71811: PPUSH
71812: PPUSH
71813: PPUSH
71814: PPUSH
71815: PPUSH
71816: PPUSH
71817: PPUSH
71818: PPUSH
71819: PPUSH
// if not list then
71820: LD_VAR 0 1
71824: NOT
71825: IFFALSE 71829
// exit ;
71827: GO 76488
// base := list [ 1 ] ;
71829: LD_ADDR_VAR 0 3
71833: PUSH
71834: LD_VAR 0 1
71838: PUSH
71839: LD_INT 1
71841: ARRAY
71842: ST_TO_ADDR
// group := list [ 2 ] ;
71843: LD_ADDR_VAR 0 4
71847: PUSH
71848: LD_VAR 0 1
71852: PUSH
71853: LD_INT 2
71855: ARRAY
71856: ST_TO_ADDR
// path := list [ 3 ] ;
71857: LD_ADDR_VAR 0 5
71861: PUSH
71862: LD_VAR 0 1
71866: PUSH
71867: LD_INT 3
71869: ARRAY
71870: ST_TO_ADDR
// flags := list [ 4 ] ;
71871: LD_ADDR_VAR 0 6
71875: PUSH
71876: LD_VAR 0 1
71880: PUSH
71881: LD_INT 4
71883: ARRAY
71884: ST_TO_ADDR
// mined := [ ] ;
71885: LD_ADDR_VAR 0 27
71889: PUSH
71890: EMPTY
71891: ST_TO_ADDR
// bombed := [ ] ;
71892: LD_ADDR_VAR 0 28
71896: PUSH
71897: EMPTY
71898: ST_TO_ADDR
// healers := [ ] ;
71899: LD_ADDR_VAR 0 31
71903: PUSH
71904: EMPTY
71905: ST_TO_ADDR
// to_heal := [ ] ;
71906: LD_ADDR_VAR 0 30
71910: PUSH
71911: EMPTY
71912: ST_TO_ADDR
// repairs := [ ] ;
71913: LD_ADDR_VAR 0 33
71917: PUSH
71918: EMPTY
71919: ST_TO_ADDR
// to_repair := [ ] ;
71920: LD_ADDR_VAR 0 32
71924: PUSH
71925: EMPTY
71926: ST_TO_ADDR
// if not group or not path then
71927: LD_VAR 0 4
71931: NOT
71932: PUSH
71933: LD_VAR 0 5
71937: NOT
71938: OR
71939: IFFALSE 71943
// exit ;
71941: GO 76488
// side := GetSide ( group [ 1 ] ) ;
71943: LD_ADDR_VAR 0 35
71947: PUSH
71948: LD_VAR 0 4
71952: PUSH
71953: LD_INT 1
71955: ARRAY
71956: PPUSH
71957: CALL_OW 255
71961: ST_TO_ADDR
// if flags then
71962: LD_VAR 0 6
71966: IFFALSE 72110
// begin f_ignore_area := flags [ 1 ] ;
71968: LD_ADDR_VAR 0 17
71972: PUSH
71973: LD_VAR 0 6
71977: PUSH
71978: LD_INT 1
71980: ARRAY
71981: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
71982: LD_ADDR_VAR 0 18
71986: PUSH
71987: LD_VAR 0 6
71991: PUSH
71992: LD_INT 2
71994: ARRAY
71995: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
71996: LD_ADDR_VAR 0 19
72000: PUSH
72001: LD_VAR 0 6
72005: PUSH
72006: LD_INT 3
72008: ARRAY
72009: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
72010: LD_ADDR_VAR 0 20
72014: PUSH
72015: LD_VAR 0 6
72019: PUSH
72020: LD_INT 4
72022: ARRAY
72023: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
72024: LD_ADDR_VAR 0 21
72028: PUSH
72029: LD_VAR 0 6
72033: PUSH
72034: LD_INT 5
72036: ARRAY
72037: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
72038: LD_ADDR_VAR 0 22
72042: PUSH
72043: LD_VAR 0 6
72047: PUSH
72048: LD_INT 6
72050: ARRAY
72051: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
72052: LD_ADDR_VAR 0 23
72056: PUSH
72057: LD_VAR 0 6
72061: PUSH
72062: LD_INT 7
72064: ARRAY
72065: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
72066: LD_ADDR_VAR 0 24
72070: PUSH
72071: LD_VAR 0 6
72075: PUSH
72076: LD_INT 8
72078: ARRAY
72079: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
72080: LD_ADDR_VAR 0 25
72084: PUSH
72085: LD_VAR 0 6
72089: PUSH
72090: LD_INT 9
72092: ARRAY
72093: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
72094: LD_ADDR_VAR 0 26
72098: PUSH
72099: LD_VAR 0 6
72103: PUSH
72104: LD_INT 10
72106: ARRAY
72107: ST_TO_ADDR
// end else
72108: GO 72190
// begin f_ignore_area := false ;
72110: LD_ADDR_VAR 0 17
72114: PUSH
72115: LD_INT 0
72117: ST_TO_ADDR
// f_capture := false ;
72118: LD_ADDR_VAR 0 18
72122: PUSH
72123: LD_INT 0
72125: ST_TO_ADDR
// f_ignore_civ := false ;
72126: LD_ADDR_VAR 0 19
72130: PUSH
72131: LD_INT 0
72133: ST_TO_ADDR
// f_murder := false ;
72134: LD_ADDR_VAR 0 20
72138: PUSH
72139: LD_INT 0
72141: ST_TO_ADDR
// f_mines := false ;
72142: LD_ADDR_VAR 0 21
72146: PUSH
72147: LD_INT 0
72149: ST_TO_ADDR
// f_repair := false ;
72150: LD_ADDR_VAR 0 22
72154: PUSH
72155: LD_INT 0
72157: ST_TO_ADDR
// f_heal := false ;
72158: LD_ADDR_VAR 0 23
72162: PUSH
72163: LD_INT 0
72165: ST_TO_ADDR
// f_spacetime := false ;
72166: LD_ADDR_VAR 0 24
72170: PUSH
72171: LD_INT 0
72173: ST_TO_ADDR
// f_attack_depot := false ;
72174: LD_ADDR_VAR 0 25
72178: PUSH
72179: LD_INT 0
72181: ST_TO_ADDR
// f_crawl := false ;
72182: LD_ADDR_VAR 0 26
72186: PUSH
72187: LD_INT 0
72189: ST_TO_ADDR
// end ; if f_heal then
72190: LD_VAR 0 23
72194: IFFALSE 72221
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
72196: LD_ADDR_VAR 0 31
72200: PUSH
72201: LD_VAR 0 4
72205: PPUSH
72206: LD_INT 25
72208: PUSH
72209: LD_INT 4
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PPUSH
72216: CALL_OW 72
72220: ST_TO_ADDR
// if f_repair then
72221: LD_VAR 0 22
72225: IFFALSE 72252
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
72227: LD_ADDR_VAR 0 33
72231: PUSH
72232: LD_VAR 0 4
72236: PPUSH
72237: LD_INT 25
72239: PUSH
72240: LD_INT 3
72242: PUSH
72243: EMPTY
72244: LIST
72245: LIST
72246: PPUSH
72247: CALL_OW 72
72251: ST_TO_ADDR
// units_path := [ ] ;
72252: LD_ADDR_VAR 0 16
72256: PUSH
72257: EMPTY
72258: ST_TO_ADDR
// for i = 1 to group do
72259: LD_ADDR_VAR 0 7
72263: PUSH
72264: DOUBLE
72265: LD_INT 1
72267: DEC
72268: ST_TO_ADDR
72269: LD_VAR 0 4
72273: PUSH
72274: FOR_TO
72275: IFFALSE 72304
// units_path := Replace ( units_path , i , path ) ;
72277: LD_ADDR_VAR 0 16
72281: PUSH
72282: LD_VAR 0 16
72286: PPUSH
72287: LD_VAR 0 7
72291: PPUSH
72292: LD_VAR 0 5
72296: PPUSH
72297: CALL_OW 1
72301: ST_TO_ADDR
72302: GO 72274
72304: POP
72305: POP
// repeat for i = group downto 1 do
72306: LD_ADDR_VAR 0 7
72310: PUSH
72311: DOUBLE
72312: LD_VAR 0 4
72316: INC
72317: ST_TO_ADDR
72318: LD_INT 1
72320: PUSH
72321: FOR_DOWNTO
72322: IFFALSE 76444
// begin wait ( 5 ) ;
72324: LD_INT 5
72326: PPUSH
72327: CALL_OW 67
// tmp := [ ] ;
72331: LD_ADDR_VAR 0 14
72335: PUSH
72336: EMPTY
72337: ST_TO_ADDR
// attacking := false ;
72338: LD_ADDR_VAR 0 29
72342: PUSH
72343: LD_INT 0
72345: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
72346: LD_VAR 0 4
72350: PUSH
72351: LD_VAR 0 7
72355: ARRAY
72356: PPUSH
72357: CALL_OW 301
72361: PUSH
72362: LD_VAR 0 4
72366: PUSH
72367: LD_VAR 0 7
72371: ARRAY
72372: NOT
72373: OR
72374: IFFALSE 72483
// begin if GetType ( group [ i ] ) = unit_human then
72376: LD_VAR 0 4
72380: PUSH
72381: LD_VAR 0 7
72385: ARRAY
72386: PPUSH
72387: CALL_OW 247
72391: PUSH
72392: LD_INT 1
72394: EQUAL
72395: IFFALSE 72441
// begin to_heal := to_heal diff group [ i ] ;
72397: LD_ADDR_VAR 0 30
72401: PUSH
72402: LD_VAR 0 30
72406: PUSH
72407: LD_VAR 0 4
72411: PUSH
72412: LD_VAR 0 7
72416: ARRAY
72417: DIFF
72418: ST_TO_ADDR
// healers := healers diff group [ i ] ;
72419: LD_ADDR_VAR 0 31
72423: PUSH
72424: LD_VAR 0 31
72428: PUSH
72429: LD_VAR 0 4
72433: PUSH
72434: LD_VAR 0 7
72438: ARRAY
72439: DIFF
72440: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
72441: LD_ADDR_VAR 0 4
72445: PUSH
72446: LD_VAR 0 4
72450: PPUSH
72451: LD_VAR 0 7
72455: PPUSH
72456: CALL_OW 3
72460: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
72461: LD_ADDR_VAR 0 16
72465: PUSH
72466: LD_VAR 0 16
72470: PPUSH
72471: LD_VAR 0 7
72475: PPUSH
72476: CALL_OW 3
72480: ST_TO_ADDR
// continue ;
72481: GO 72321
// end ; if f_repair then
72483: LD_VAR 0 22
72487: IFFALSE 72976
// begin if GetType ( group [ i ] ) = unit_vehicle then
72489: LD_VAR 0 4
72493: PUSH
72494: LD_VAR 0 7
72498: ARRAY
72499: PPUSH
72500: CALL_OW 247
72504: PUSH
72505: LD_INT 2
72507: EQUAL
72508: IFFALSE 72698
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
72510: LD_VAR 0 4
72514: PUSH
72515: LD_VAR 0 7
72519: ARRAY
72520: PPUSH
72521: CALL_OW 256
72525: PUSH
72526: LD_INT 700
72528: LESS
72529: PUSH
72530: LD_VAR 0 4
72534: PUSH
72535: LD_VAR 0 7
72539: ARRAY
72540: PUSH
72541: LD_VAR 0 32
72545: IN
72546: NOT
72547: AND
72548: IFFALSE 72572
// to_repair := to_repair union group [ i ] ;
72550: LD_ADDR_VAR 0 32
72554: PUSH
72555: LD_VAR 0 32
72559: PUSH
72560: LD_VAR 0 4
72564: PUSH
72565: LD_VAR 0 7
72569: ARRAY
72570: UNION
72571: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
72572: LD_VAR 0 4
72576: PUSH
72577: LD_VAR 0 7
72581: ARRAY
72582: PPUSH
72583: CALL_OW 256
72587: PUSH
72588: LD_INT 1000
72590: EQUAL
72591: PUSH
72592: LD_VAR 0 4
72596: PUSH
72597: LD_VAR 0 7
72601: ARRAY
72602: PUSH
72603: LD_VAR 0 32
72607: IN
72608: AND
72609: IFFALSE 72633
// to_repair := to_repair diff group [ i ] ;
72611: LD_ADDR_VAR 0 32
72615: PUSH
72616: LD_VAR 0 32
72620: PUSH
72621: LD_VAR 0 4
72625: PUSH
72626: LD_VAR 0 7
72630: ARRAY
72631: DIFF
72632: ST_TO_ADDR
// if group [ i ] in to_repair then
72633: LD_VAR 0 4
72637: PUSH
72638: LD_VAR 0 7
72642: ARRAY
72643: PUSH
72644: LD_VAR 0 32
72648: IN
72649: IFFALSE 72696
// begin if not IsInArea ( group [ i ] , f_repair ) then
72651: LD_VAR 0 4
72655: PUSH
72656: LD_VAR 0 7
72660: ARRAY
72661: PPUSH
72662: LD_VAR 0 22
72666: PPUSH
72667: CALL_OW 308
72671: NOT
72672: IFFALSE 72694
// ComMoveToArea ( group [ i ] , f_repair ) ;
72674: LD_VAR 0 4
72678: PUSH
72679: LD_VAR 0 7
72683: ARRAY
72684: PPUSH
72685: LD_VAR 0 22
72689: PPUSH
72690: CALL_OW 113
// continue ;
72694: GO 72321
// end ; end else
72696: GO 72976
// if group [ i ] in repairs then
72698: LD_VAR 0 4
72702: PUSH
72703: LD_VAR 0 7
72707: ARRAY
72708: PUSH
72709: LD_VAR 0 33
72713: IN
72714: IFFALSE 72976
// begin if IsInUnit ( group [ i ] ) then
72716: LD_VAR 0 4
72720: PUSH
72721: LD_VAR 0 7
72725: ARRAY
72726: PPUSH
72727: CALL_OW 310
72731: IFFALSE 72799
// begin z := IsInUnit ( group [ i ] ) ;
72733: LD_ADDR_VAR 0 13
72737: PUSH
72738: LD_VAR 0 4
72742: PUSH
72743: LD_VAR 0 7
72747: ARRAY
72748: PPUSH
72749: CALL_OW 310
72753: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
72754: LD_VAR 0 13
72758: PUSH
72759: LD_VAR 0 32
72763: IN
72764: PUSH
72765: LD_VAR 0 13
72769: PPUSH
72770: LD_VAR 0 22
72774: PPUSH
72775: CALL_OW 308
72779: AND
72780: IFFALSE 72797
// ComExitVehicle ( group [ i ] ) ;
72782: LD_VAR 0 4
72786: PUSH
72787: LD_VAR 0 7
72791: ARRAY
72792: PPUSH
72793: CALL_OW 121
// end else
72797: GO 72976
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
72799: LD_ADDR_VAR 0 13
72803: PUSH
72804: LD_VAR 0 4
72808: PPUSH
72809: LD_INT 95
72811: PUSH
72812: LD_VAR 0 22
72816: PUSH
72817: EMPTY
72818: LIST
72819: LIST
72820: PUSH
72821: LD_INT 58
72823: PUSH
72824: EMPTY
72825: LIST
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: PPUSH
72831: CALL_OW 72
72835: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
72836: LD_VAR 0 4
72840: PUSH
72841: LD_VAR 0 7
72845: ARRAY
72846: PPUSH
72847: CALL_OW 314
72851: NOT
72852: IFFALSE 72974
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
72854: LD_ADDR_VAR 0 10
72858: PUSH
72859: LD_VAR 0 13
72863: PPUSH
72864: LD_VAR 0 4
72868: PUSH
72869: LD_VAR 0 7
72873: ARRAY
72874: PPUSH
72875: CALL_OW 74
72879: ST_TO_ADDR
// if not x then
72880: LD_VAR 0 10
72884: NOT
72885: IFFALSE 72889
// continue ;
72887: GO 72321
// if GetLives ( x ) < 1000 then
72889: LD_VAR 0 10
72893: PPUSH
72894: CALL_OW 256
72898: PUSH
72899: LD_INT 1000
72901: LESS
72902: IFFALSE 72926
// ComRepairVehicle ( group [ i ] , x ) else
72904: LD_VAR 0 4
72908: PUSH
72909: LD_VAR 0 7
72913: ARRAY
72914: PPUSH
72915: LD_VAR 0 10
72919: PPUSH
72920: CALL_OW 129
72924: GO 72974
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
72926: LD_VAR 0 23
72930: PUSH
72931: LD_VAR 0 4
72935: PUSH
72936: LD_VAR 0 7
72940: ARRAY
72941: PPUSH
72942: CALL_OW 256
72946: PUSH
72947: LD_INT 1000
72949: LESS
72950: AND
72951: NOT
72952: IFFALSE 72974
// ComEnterUnit ( group [ i ] , x ) ;
72954: LD_VAR 0 4
72958: PUSH
72959: LD_VAR 0 7
72963: ARRAY
72964: PPUSH
72965: LD_VAR 0 10
72969: PPUSH
72970: CALL_OW 120
// end ; continue ;
72974: GO 72321
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
72976: LD_VAR 0 23
72980: PUSH
72981: LD_VAR 0 4
72985: PUSH
72986: LD_VAR 0 7
72990: ARRAY
72991: PPUSH
72992: CALL_OW 247
72996: PUSH
72997: LD_INT 1
72999: EQUAL
73000: AND
73001: IFFALSE 73479
// begin if group [ i ] in healers then
73003: LD_VAR 0 4
73007: PUSH
73008: LD_VAR 0 7
73012: ARRAY
73013: PUSH
73014: LD_VAR 0 31
73018: IN
73019: IFFALSE 73292
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
73021: LD_VAR 0 4
73025: PUSH
73026: LD_VAR 0 7
73030: ARRAY
73031: PPUSH
73032: LD_VAR 0 23
73036: PPUSH
73037: CALL_OW 308
73041: NOT
73042: PUSH
73043: LD_VAR 0 4
73047: PUSH
73048: LD_VAR 0 7
73052: ARRAY
73053: PPUSH
73054: CALL_OW 314
73058: NOT
73059: AND
73060: IFFALSE 73084
// ComMoveToArea ( group [ i ] , f_heal ) else
73062: LD_VAR 0 4
73066: PUSH
73067: LD_VAR 0 7
73071: ARRAY
73072: PPUSH
73073: LD_VAR 0 23
73077: PPUSH
73078: CALL_OW 113
73082: GO 73290
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
73084: LD_VAR 0 4
73088: PUSH
73089: LD_VAR 0 7
73093: ARRAY
73094: PPUSH
73095: CALL 37799 0 1
73099: PPUSH
73100: CALL_OW 256
73104: PUSH
73105: LD_INT 1000
73107: EQUAL
73108: IFFALSE 73127
// ComStop ( group [ i ] ) else
73110: LD_VAR 0 4
73114: PUSH
73115: LD_VAR 0 7
73119: ARRAY
73120: PPUSH
73121: CALL_OW 141
73125: GO 73290
// if not HasTask ( group [ i ] ) and to_heal then
73127: LD_VAR 0 4
73131: PUSH
73132: LD_VAR 0 7
73136: ARRAY
73137: PPUSH
73138: CALL_OW 314
73142: NOT
73143: PUSH
73144: LD_VAR 0 30
73148: AND
73149: IFFALSE 73290
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
73151: LD_ADDR_VAR 0 13
73155: PUSH
73156: LD_VAR 0 30
73160: PPUSH
73161: LD_INT 3
73163: PUSH
73164: LD_INT 54
73166: PUSH
73167: EMPTY
73168: LIST
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PPUSH
73174: CALL_OW 72
73178: PPUSH
73179: LD_VAR 0 4
73183: PUSH
73184: LD_VAR 0 7
73188: ARRAY
73189: PPUSH
73190: CALL_OW 74
73194: ST_TO_ADDR
// if z then
73195: LD_VAR 0 13
73199: IFFALSE 73290
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
73201: LD_INT 91
73203: PUSH
73204: LD_VAR 0 13
73208: PUSH
73209: LD_INT 10
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: LIST
73216: PUSH
73217: LD_INT 81
73219: PUSH
73220: LD_VAR 0 13
73224: PPUSH
73225: CALL_OW 255
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: EMPTY
73235: LIST
73236: LIST
73237: PPUSH
73238: CALL_OW 69
73242: PUSH
73243: LD_INT 0
73245: EQUAL
73246: IFFALSE 73270
// ComHeal ( group [ i ] , z ) else
73248: LD_VAR 0 4
73252: PUSH
73253: LD_VAR 0 7
73257: ARRAY
73258: PPUSH
73259: LD_VAR 0 13
73263: PPUSH
73264: CALL_OW 128
73268: GO 73290
// ComMoveToArea ( group [ i ] , f_heal ) ;
73270: LD_VAR 0 4
73274: PUSH
73275: LD_VAR 0 7
73279: ARRAY
73280: PPUSH
73281: LD_VAR 0 23
73285: PPUSH
73286: CALL_OW 113
// end ; continue ;
73290: GO 72321
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
73292: LD_VAR 0 4
73296: PUSH
73297: LD_VAR 0 7
73301: ARRAY
73302: PPUSH
73303: CALL_OW 256
73307: PUSH
73308: LD_INT 700
73310: LESS
73311: PUSH
73312: LD_VAR 0 4
73316: PUSH
73317: LD_VAR 0 7
73321: ARRAY
73322: PUSH
73323: LD_VAR 0 30
73327: IN
73328: NOT
73329: AND
73330: IFFALSE 73354
// to_heal := to_heal union group [ i ] ;
73332: LD_ADDR_VAR 0 30
73336: PUSH
73337: LD_VAR 0 30
73341: PUSH
73342: LD_VAR 0 4
73346: PUSH
73347: LD_VAR 0 7
73351: ARRAY
73352: UNION
73353: ST_TO_ADDR
// if group [ i ] in to_heal then
73354: LD_VAR 0 4
73358: PUSH
73359: LD_VAR 0 7
73363: ARRAY
73364: PUSH
73365: LD_VAR 0 30
73369: IN
73370: IFFALSE 73479
// begin if GetLives ( group [ i ] ) = 1000 then
73372: LD_VAR 0 4
73376: PUSH
73377: LD_VAR 0 7
73381: ARRAY
73382: PPUSH
73383: CALL_OW 256
73387: PUSH
73388: LD_INT 1000
73390: EQUAL
73391: IFFALSE 73417
// to_heal := to_heal diff group [ i ] else
73393: LD_ADDR_VAR 0 30
73397: PUSH
73398: LD_VAR 0 30
73402: PUSH
73403: LD_VAR 0 4
73407: PUSH
73408: LD_VAR 0 7
73412: ARRAY
73413: DIFF
73414: ST_TO_ADDR
73415: GO 73479
// begin if not IsInArea ( group [ i ] , to_heal ) then
73417: LD_VAR 0 4
73421: PUSH
73422: LD_VAR 0 7
73426: ARRAY
73427: PPUSH
73428: LD_VAR 0 30
73432: PPUSH
73433: CALL_OW 308
73437: NOT
73438: IFFALSE 73462
// ComMoveToArea ( group [ i ] , f_heal ) else
73440: LD_VAR 0 4
73444: PUSH
73445: LD_VAR 0 7
73449: ARRAY
73450: PPUSH
73451: LD_VAR 0 23
73455: PPUSH
73456: CALL_OW 113
73460: GO 73477
// ComHold ( group [ i ] ) ;
73462: LD_VAR 0 4
73466: PUSH
73467: LD_VAR 0 7
73471: ARRAY
73472: PPUSH
73473: CALL_OW 140
// continue ;
73477: GO 72321
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
73479: LD_VAR 0 4
73483: PUSH
73484: LD_VAR 0 7
73488: ARRAY
73489: PPUSH
73490: LD_INT 10
73492: PPUSH
73493: CALL 36219 0 2
73497: NOT
73498: PUSH
73499: LD_VAR 0 16
73503: PUSH
73504: LD_VAR 0 7
73508: ARRAY
73509: PUSH
73510: EMPTY
73511: EQUAL
73512: NOT
73513: AND
73514: IFFALSE 73780
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
73516: LD_VAR 0 4
73520: PUSH
73521: LD_VAR 0 7
73525: ARRAY
73526: PPUSH
73527: CALL_OW 262
73531: PUSH
73532: LD_INT 1
73534: PUSH
73535: LD_INT 2
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: IN
73542: IFFALSE 73583
// if GetFuel ( group [ i ] ) < 10 then
73544: LD_VAR 0 4
73548: PUSH
73549: LD_VAR 0 7
73553: ARRAY
73554: PPUSH
73555: CALL_OW 261
73559: PUSH
73560: LD_INT 10
73562: LESS
73563: IFFALSE 73583
// SetFuel ( group [ i ] , 12 ) ;
73565: LD_VAR 0 4
73569: PUSH
73570: LD_VAR 0 7
73574: ARRAY
73575: PPUSH
73576: LD_INT 12
73578: PPUSH
73579: CALL_OW 240
// if units_path [ i ] then
73583: LD_VAR 0 16
73587: PUSH
73588: LD_VAR 0 7
73592: ARRAY
73593: IFFALSE 73778
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
73595: LD_VAR 0 4
73599: PUSH
73600: LD_VAR 0 7
73604: ARRAY
73605: PPUSH
73606: LD_VAR 0 16
73610: PUSH
73611: LD_VAR 0 7
73615: ARRAY
73616: PUSH
73617: LD_INT 1
73619: ARRAY
73620: PUSH
73621: LD_INT 1
73623: ARRAY
73624: PPUSH
73625: LD_VAR 0 16
73629: PUSH
73630: LD_VAR 0 7
73634: ARRAY
73635: PUSH
73636: LD_INT 1
73638: ARRAY
73639: PUSH
73640: LD_INT 2
73642: ARRAY
73643: PPUSH
73644: CALL_OW 297
73648: PUSH
73649: LD_INT 6
73651: GREATER
73652: IFFALSE 73727
// begin if not HasTask ( group [ i ] ) then
73654: LD_VAR 0 4
73658: PUSH
73659: LD_VAR 0 7
73663: ARRAY
73664: PPUSH
73665: CALL_OW 314
73669: NOT
73670: IFFALSE 73725
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
73672: LD_VAR 0 4
73676: PUSH
73677: LD_VAR 0 7
73681: ARRAY
73682: PPUSH
73683: LD_VAR 0 16
73687: PUSH
73688: LD_VAR 0 7
73692: ARRAY
73693: PUSH
73694: LD_INT 1
73696: ARRAY
73697: PUSH
73698: LD_INT 1
73700: ARRAY
73701: PPUSH
73702: LD_VAR 0 16
73706: PUSH
73707: LD_VAR 0 7
73711: ARRAY
73712: PUSH
73713: LD_INT 1
73715: ARRAY
73716: PUSH
73717: LD_INT 2
73719: ARRAY
73720: PPUSH
73721: CALL_OW 114
// end else
73725: GO 73778
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
73727: LD_ADDR_VAR 0 15
73731: PUSH
73732: LD_VAR 0 16
73736: PUSH
73737: LD_VAR 0 7
73741: ARRAY
73742: PPUSH
73743: LD_INT 1
73745: PPUSH
73746: CALL_OW 3
73750: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
73751: LD_ADDR_VAR 0 16
73755: PUSH
73756: LD_VAR 0 16
73760: PPUSH
73761: LD_VAR 0 7
73765: PPUSH
73766: LD_VAR 0 15
73770: PPUSH
73771: CALL_OW 1
73775: ST_TO_ADDR
// continue ;
73776: GO 72321
// end ; end ; end else
73778: GO 76442
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
73780: LD_ADDR_VAR 0 14
73784: PUSH
73785: LD_INT 81
73787: PUSH
73788: LD_VAR 0 4
73792: PUSH
73793: LD_VAR 0 7
73797: ARRAY
73798: PPUSH
73799: CALL_OW 255
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: PPUSH
73808: CALL_OW 69
73812: ST_TO_ADDR
// if not tmp then
73813: LD_VAR 0 14
73817: NOT
73818: IFFALSE 73822
// continue ;
73820: GO 72321
// if f_ignore_area then
73822: LD_VAR 0 17
73826: IFFALSE 73914
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
73828: LD_ADDR_VAR 0 15
73832: PUSH
73833: LD_VAR 0 14
73837: PPUSH
73838: LD_INT 3
73840: PUSH
73841: LD_INT 92
73843: PUSH
73844: LD_VAR 0 17
73848: PUSH
73849: LD_INT 1
73851: ARRAY
73852: PUSH
73853: LD_VAR 0 17
73857: PUSH
73858: LD_INT 2
73860: ARRAY
73861: PUSH
73862: LD_VAR 0 17
73866: PUSH
73867: LD_INT 3
73869: ARRAY
73870: PUSH
73871: EMPTY
73872: LIST
73873: LIST
73874: LIST
73875: LIST
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PPUSH
73881: CALL_OW 72
73885: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
73886: LD_VAR 0 14
73890: PUSH
73891: LD_VAR 0 15
73895: DIFF
73896: IFFALSE 73914
// tmp := tmp diff tmp2 ;
73898: LD_ADDR_VAR 0 14
73902: PUSH
73903: LD_VAR 0 14
73907: PUSH
73908: LD_VAR 0 15
73912: DIFF
73913: ST_TO_ADDR
// end ; if not f_murder then
73914: LD_VAR 0 20
73918: NOT
73919: IFFALSE 73977
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
73921: LD_ADDR_VAR 0 15
73925: PUSH
73926: LD_VAR 0 14
73930: PPUSH
73931: LD_INT 3
73933: PUSH
73934: LD_INT 50
73936: PUSH
73937: EMPTY
73938: LIST
73939: PUSH
73940: EMPTY
73941: LIST
73942: LIST
73943: PPUSH
73944: CALL_OW 72
73948: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
73949: LD_VAR 0 14
73953: PUSH
73954: LD_VAR 0 15
73958: DIFF
73959: IFFALSE 73977
// tmp := tmp diff tmp2 ;
73961: LD_ADDR_VAR 0 14
73965: PUSH
73966: LD_VAR 0 14
73970: PUSH
73971: LD_VAR 0 15
73975: DIFF
73976: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
73977: LD_ADDR_VAR 0 14
73981: PUSH
73982: LD_VAR 0 4
73986: PUSH
73987: LD_VAR 0 7
73991: ARRAY
73992: PPUSH
73993: LD_VAR 0 14
73997: PPUSH
73998: LD_INT 1
74000: PPUSH
74001: LD_INT 1
74003: PPUSH
74004: CALL 9862 0 4
74008: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
74009: LD_VAR 0 4
74013: PUSH
74014: LD_VAR 0 7
74018: ARRAY
74019: PPUSH
74020: CALL_OW 257
74024: PUSH
74025: LD_INT 1
74027: EQUAL
74028: IFFALSE 74476
// begin if WantPlant ( group [ i ] ) then
74030: LD_VAR 0 4
74034: PUSH
74035: LD_VAR 0 7
74039: ARRAY
74040: PPUSH
74041: CALL 9363 0 1
74045: IFFALSE 74049
// continue ;
74047: GO 72321
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
74049: LD_VAR 0 18
74053: PUSH
74054: LD_VAR 0 4
74058: PUSH
74059: LD_VAR 0 7
74063: ARRAY
74064: PPUSH
74065: CALL_OW 310
74069: NOT
74070: AND
74071: PUSH
74072: LD_VAR 0 14
74076: PUSH
74077: LD_INT 1
74079: ARRAY
74080: PUSH
74081: LD_VAR 0 14
74085: PPUSH
74086: LD_INT 21
74088: PUSH
74089: LD_INT 2
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 58
74098: PUSH
74099: EMPTY
74100: LIST
74101: PUSH
74102: EMPTY
74103: LIST
74104: LIST
74105: PPUSH
74106: CALL_OW 72
74110: IN
74111: AND
74112: IFFALSE 74148
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
74114: LD_VAR 0 4
74118: PUSH
74119: LD_VAR 0 7
74123: ARRAY
74124: PPUSH
74125: LD_VAR 0 14
74129: PUSH
74130: LD_INT 1
74132: ARRAY
74133: PPUSH
74134: CALL_OW 120
// attacking := true ;
74138: LD_ADDR_VAR 0 29
74142: PUSH
74143: LD_INT 1
74145: ST_TO_ADDR
// continue ;
74146: GO 72321
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
74148: LD_VAR 0 26
74152: PUSH
74153: LD_VAR 0 4
74157: PUSH
74158: LD_VAR 0 7
74162: ARRAY
74163: PPUSH
74164: CALL_OW 257
74168: PUSH
74169: LD_INT 1
74171: EQUAL
74172: AND
74173: PUSH
74174: LD_VAR 0 4
74178: PUSH
74179: LD_VAR 0 7
74183: ARRAY
74184: PPUSH
74185: CALL_OW 256
74189: PUSH
74190: LD_INT 800
74192: LESS
74193: AND
74194: PUSH
74195: LD_VAR 0 4
74199: PUSH
74200: LD_VAR 0 7
74204: ARRAY
74205: PPUSH
74206: CALL_OW 318
74210: NOT
74211: AND
74212: IFFALSE 74229
// ComCrawl ( group [ i ] ) ;
74214: LD_VAR 0 4
74218: PUSH
74219: LD_VAR 0 7
74223: ARRAY
74224: PPUSH
74225: CALL_OW 137
// if f_mines then
74229: LD_VAR 0 21
74233: IFFALSE 74476
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
74235: LD_VAR 0 14
74239: PUSH
74240: LD_INT 1
74242: ARRAY
74243: PPUSH
74244: CALL_OW 247
74248: PUSH
74249: LD_INT 3
74251: EQUAL
74252: PUSH
74253: LD_VAR 0 14
74257: PUSH
74258: LD_INT 1
74260: ARRAY
74261: PUSH
74262: LD_VAR 0 27
74266: IN
74267: NOT
74268: AND
74269: IFFALSE 74476
// begin x := GetX ( tmp [ 1 ] ) ;
74271: LD_ADDR_VAR 0 10
74275: PUSH
74276: LD_VAR 0 14
74280: PUSH
74281: LD_INT 1
74283: ARRAY
74284: PPUSH
74285: CALL_OW 250
74289: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
74290: LD_ADDR_VAR 0 11
74294: PUSH
74295: LD_VAR 0 14
74299: PUSH
74300: LD_INT 1
74302: ARRAY
74303: PPUSH
74304: CALL_OW 251
74308: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
74309: LD_ADDR_VAR 0 12
74313: PUSH
74314: LD_VAR 0 4
74318: PUSH
74319: LD_VAR 0 7
74323: ARRAY
74324: PPUSH
74325: CALL 36304 0 1
74329: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
74330: LD_VAR 0 4
74334: PUSH
74335: LD_VAR 0 7
74339: ARRAY
74340: PPUSH
74341: LD_VAR 0 10
74345: PPUSH
74346: LD_VAR 0 11
74350: PPUSH
74351: LD_VAR 0 14
74355: PUSH
74356: LD_INT 1
74358: ARRAY
74359: PPUSH
74360: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
74364: LD_VAR 0 4
74368: PUSH
74369: LD_VAR 0 7
74373: ARRAY
74374: PPUSH
74375: LD_VAR 0 10
74379: PPUSH
74380: LD_VAR 0 12
74384: PPUSH
74385: LD_INT 7
74387: PPUSH
74388: CALL_OW 272
74392: PPUSH
74393: LD_VAR 0 11
74397: PPUSH
74398: LD_VAR 0 12
74402: PPUSH
74403: LD_INT 7
74405: PPUSH
74406: CALL_OW 273
74410: PPUSH
74411: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
74415: LD_VAR 0 4
74419: PUSH
74420: LD_VAR 0 7
74424: ARRAY
74425: PPUSH
74426: LD_INT 71
74428: PPUSH
74429: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
74433: LD_ADDR_VAR 0 27
74437: PUSH
74438: LD_VAR 0 27
74442: PPUSH
74443: LD_VAR 0 27
74447: PUSH
74448: LD_INT 1
74450: PLUS
74451: PPUSH
74452: LD_VAR 0 14
74456: PUSH
74457: LD_INT 1
74459: ARRAY
74460: PPUSH
74461: CALL_OW 1
74465: ST_TO_ADDR
// attacking := true ;
74466: LD_ADDR_VAR 0 29
74470: PUSH
74471: LD_INT 1
74473: ST_TO_ADDR
// continue ;
74474: GO 72321
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
74476: LD_VAR 0 4
74480: PUSH
74481: LD_VAR 0 7
74485: ARRAY
74486: PPUSH
74487: CALL_OW 257
74491: PUSH
74492: LD_INT 17
74494: EQUAL
74495: PUSH
74496: LD_VAR 0 4
74500: PUSH
74501: LD_VAR 0 7
74505: ARRAY
74506: PPUSH
74507: CALL_OW 110
74511: PUSH
74512: LD_INT 71
74514: EQUAL
74515: NOT
74516: AND
74517: IFFALSE 74663
// begin attacking := false ;
74519: LD_ADDR_VAR 0 29
74523: PUSH
74524: LD_INT 0
74526: ST_TO_ADDR
// k := 5 ;
74527: LD_ADDR_VAR 0 9
74531: PUSH
74532: LD_INT 5
74534: ST_TO_ADDR
// if tmp < k then
74535: LD_VAR 0 14
74539: PUSH
74540: LD_VAR 0 9
74544: LESS
74545: IFFALSE 74557
// k := tmp ;
74547: LD_ADDR_VAR 0 9
74551: PUSH
74552: LD_VAR 0 14
74556: ST_TO_ADDR
// for j = 1 to k do
74557: LD_ADDR_VAR 0 8
74561: PUSH
74562: DOUBLE
74563: LD_INT 1
74565: DEC
74566: ST_TO_ADDR
74567: LD_VAR 0 9
74571: PUSH
74572: FOR_TO
74573: IFFALSE 74661
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
74575: LD_VAR 0 14
74579: PUSH
74580: LD_VAR 0 8
74584: ARRAY
74585: PUSH
74586: LD_VAR 0 14
74590: PPUSH
74591: LD_INT 58
74593: PUSH
74594: EMPTY
74595: LIST
74596: PPUSH
74597: CALL_OW 72
74601: IN
74602: NOT
74603: IFFALSE 74659
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
74605: LD_VAR 0 4
74609: PUSH
74610: LD_VAR 0 7
74614: ARRAY
74615: PPUSH
74616: LD_VAR 0 14
74620: PUSH
74621: LD_VAR 0 8
74625: ARRAY
74626: PPUSH
74627: CALL_OW 115
// attacking := true ;
74631: LD_ADDR_VAR 0 29
74635: PUSH
74636: LD_INT 1
74638: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
74639: LD_VAR 0 4
74643: PUSH
74644: LD_VAR 0 7
74648: ARRAY
74649: PPUSH
74650: LD_INT 71
74652: PPUSH
74653: CALL_OW 109
// continue ;
74657: GO 74572
// end ; end ;
74659: GO 74572
74661: POP
74662: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
74663: LD_VAR 0 4
74667: PUSH
74668: LD_VAR 0 7
74672: ARRAY
74673: PPUSH
74674: CALL_OW 257
74678: PUSH
74679: LD_INT 8
74681: EQUAL
74682: PUSH
74683: LD_VAR 0 4
74687: PUSH
74688: LD_VAR 0 7
74692: ARRAY
74693: PPUSH
74694: CALL_OW 264
74698: PUSH
74699: LD_INT 28
74701: PUSH
74702: LD_INT 45
74704: PUSH
74705: LD_INT 7
74707: PUSH
74708: LD_INT 47
74710: PUSH
74711: EMPTY
74712: LIST
74713: LIST
74714: LIST
74715: LIST
74716: IN
74717: OR
74718: IFFALSE 74974
// begin attacking := false ;
74720: LD_ADDR_VAR 0 29
74724: PUSH
74725: LD_INT 0
74727: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
74728: LD_VAR 0 14
74732: PUSH
74733: LD_INT 1
74735: ARRAY
74736: PPUSH
74737: CALL_OW 266
74741: PUSH
74742: LD_INT 32
74744: PUSH
74745: LD_INT 31
74747: PUSH
74748: LD_INT 33
74750: PUSH
74751: LD_INT 4
74753: PUSH
74754: LD_INT 5
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: LIST
74761: LIST
74762: LIST
74763: IN
74764: IFFALSE 74950
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
74766: LD_ADDR_VAR 0 9
74770: PUSH
74771: LD_VAR 0 14
74775: PUSH
74776: LD_INT 1
74778: ARRAY
74779: PPUSH
74780: CALL_OW 266
74784: PPUSH
74785: LD_VAR 0 14
74789: PUSH
74790: LD_INT 1
74792: ARRAY
74793: PPUSH
74794: CALL_OW 250
74798: PPUSH
74799: LD_VAR 0 14
74803: PUSH
74804: LD_INT 1
74806: ARRAY
74807: PPUSH
74808: CALL_OW 251
74812: PPUSH
74813: LD_VAR 0 14
74817: PUSH
74818: LD_INT 1
74820: ARRAY
74821: PPUSH
74822: CALL_OW 254
74826: PPUSH
74827: LD_VAR 0 14
74831: PUSH
74832: LD_INT 1
74834: ARRAY
74835: PPUSH
74836: CALL_OW 248
74840: PPUSH
74841: LD_INT 0
74843: PPUSH
74844: CALL 17674 0 6
74848: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
74849: LD_ADDR_VAR 0 8
74853: PUSH
74854: LD_VAR 0 4
74858: PUSH
74859: LD_VAR 0 7
74863: ARRAY
74864: PPUSH
74865: LD_VAR 0 9
74869: PPUSH
74870: CALL 36344 0 2
74874: ST_TO_ADDR
// if j then
74875: LD_VAR 0 8
74879: IFFALSE 74948
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
74881: LD_VAR 0 8
74885: PUSH
74886: LD_INT 1
74888: ARRAY
74889: PPUSH
74890: LD_VAR 0 8
74894: PUSH
74895: LD_INT 2
74897: ARRAY
74898: PPUSH
74899: CALL_OW 488
74903: IFFALSE 74948
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
74905: LD_VAR 0 4
74909: PUSH
74910: LD_VAR 0 7
74914: ARRAY
74915: PPUSH
74916: LD_VAR 0 8
74920: PUSH
74921: LD_INT 1
74923: ARRAY
74924: PPUSH
74925: LD_VAR 0 8
74929: PUSH
74930: LD_INT 2
74932: ARRAY
74933: PPUSH
74934: CALL_OW 116
// attacking := true ;
74938: LD_ADDR_VAR 0 29
74942: PUSH
74943: LD_INT 1
74945: ST_TO_ADDR
// continue ;
74946: GO 72321
// end ; end else
74948: GO 74974
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
74950: LD_VAR 0 4
74954: PUSH
74955: LD_VAR 0 7
74959: ARRAY
74960: PPUSH
74961: LD_VAR 0 14
74965: PUSH
74966: LD_INT 1
74968: ARRAY
74969: PPUSH
74970: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
74974: LD_VAR 0 4
74978: PUSH
74979: LD_VAR 0 7
74983: ARRAY
74984: PPUSH
74985: CALL_OW 265
74989: PUSH
74990: LD_INT 11
74992: EQUAL
74993: IFFALSE 75271
// begin k := 10 ;
74995: LD_ADDR_VAR 0 9
74999: PUSH
75000: LD_INT 10
75002: ST_TO_ADDR
// x := 0 ;
75003: LD_ADDR_VAR 0 10
75007: PUSH
75008: LD_INT 0
75010: ST_TO_ADDR
// if tmp < k then
75011: LD_VAR 0 14
75015: PUSH
75016: LD_VAR 0 9
75020: LESS
75021: IFFALSE 75033
// k := tmp ;
75023: LD_ADDR_VAR 0 9
75027: PUSH
75028: LD_VAR 0 14
75032: ST_TO_ADDR
// for j = k downto 1 do
75033: LD_ADDR_VAR 0 8
75037: PUSH
75038: DOUBLE
75039: LD_VAR 0 9
75043: INC
75044: ST_TO_ADDR
75045: LD_INT 1
75047: PUSH
75048: FOR_DOWNTO
75049: IFFALSE 75124
// begin if GetType ( tmp [ j ] ) = unit_human then
75051: LD_VAR 0 14
75055: PUSH
75056: LD_VAR 0 8
75060: ARRAY
75061: PPUSH
75062: CALL_OW 247
75066: PUSH
75067: LD_INT 1
75069: EQUAL
75070: IFFALSE 75122
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
75072: LD_VAR 0 4
75076: PUSH
75077: LD_VAR 0 7
75081: ARRAY
75082: PPUSH
75083: LD_VAR 0 14
75087: PUSH
75088: LD_VAR 0 8
75092: ARRAY
75093: PPUSH
75094: CALL 36615 0 2
// x := tmp [ j ] ;
75098: LD_ADDR_VAR 0 10
75102: PUSH
75103: LD_VAR 0 14
75107: PUSH
75108: LD_VAR 0 8
75112: ARRAY
75113: ST_TO_ADDR
// attacking := true ;
75114: LD_ADDR_VAR 0 29
75118: PUSH
75119: LD_INT 1
75121: ST_TO_ADDR
// end ; end ;
75122: GO 75048
75124: POP
75125: POP
// if not x then
75126: LD_VAR 0 10
75130: NOT
75131: IFFALSE 75271
// begin attacking := true ;
75133: LD_ADDR_VAR 0 29
75137: PUSH
75138: LD_INT 1
75140: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
75141: LD_VAR 0 4
75145: PUSH
75146: LD_VAR 0 7
75150: ARRAY
75151: PPUSH
75152: CALL_OW 250
75156: PPUSH
75157: LD_VAR 0 4
75161: PUSH
75162: LD_VAR 0 7
75166: ARRAY
75167: PPUSH
75168: CALL_OW 251
75172: PPUSH
75173: CALL_OW 546
75177: PUSH
75178: LD_INT 2
75180: ARRAY
75181: PUSH
75182: LD_VAR 0 14
75186: PUSH
75187: LD_INT 1
75189: ARRAY
75190: PPUSH
75191: CALL_OW 250
75195: PPUSH
75196: LD_VAR 0 14
75200: PUSH
75201: LD_INT 1
75203: ARRAY
75204: PPUSH
75205: CALL_OW 251
75209: PPUSH
75210: CALL_OW 546
75214: PUSH
75215: LD_INT 2
75217: ARRAY
75218: EQUAL
75219: IFFALSE 75247
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
75221: LD_VAR 0 4
75225: PUSH
75226: LD_VAR 0 7
75230: ARRAY
75231: PPUSH
75232: LD_VAR 0 14
75236: PUSH
75237: LD_INT 1
75239: ARRAY
75240: PPUSH
75241: CALL 36615 0 2
75245: GO 75271
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
75247: LD_VAR 0 4
75251: PUSH
75252: LD_VAR 0 7
75256: ARRAY
75257: PPUSH
75258: LD_VAR 0 14
75262: PUSH
75263: LD_INT 1
75265: ARRAY
75266: PPUSH
75267: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
75271: LD_VAR 0 4
75275: PUSH
75276: LD_VAR 0 7
75280: ARRAY
75281: PPUSH
75282: CALL_OW 264
75286: PUSH
75287: LD_INT 29
75289: EQUAL
75290: IFFALSE 75656
// begin if WantsToAttack ( group [ i ] ) in bombed then
75292: LD_VAR 0 4
75296: PUSH
75297: LD_VAR 0 7
75301: ARRAY
75302: PPUSH
75303: CALL_OW 319
75307: PUSH
75308: LD_VAR 0 28
75312: IN
75313: IFFALSE 75317
// continue ;
75315: GO 72321
// k := 8 ;
75317: LD_ADDR_VAR 0 9
75321: PUSH
75322: LD_INT 8
75324: ST_TO_ADDR
// x := 0 ;
75325: LD_ADDR_VAR 0 10
75329: PUSH
75330: LD_INT 0
75332: ST_TO_ADDR
// if tmp < k then
75333: LD_VAR 0 14
75337: PUSH
75338: LD_VAR 0 9
75342: LESS
75343: IFFALSE 75355
// k := tmp ;
75345: LD_ADDR_VAR 0 9
75349: PUSH
75350: LD_VAR 0 14
75354: ST_TO_ADDR
// for j = 1 to k do
75355: LD_ADDR_VAR 0 8
75359: PUSH
75360: DOUBLE
75361: LD_INT 1
75363: DEC
75364: ST_TO_ADDR
75365: LD_VAR 0 9
75369: PUSH
75370: FOR_TO
75371: IFFALSE 75503
// begin if GetType ( tmp [ j ] ) = unit_building then
75373: LD_VAR 0 14
75377: PUSH
75378: LD_VAR 0 8
75382: ARRAY
75383: PPUSH
75384: CALL_OW 247
75388: PUSH
75389: LD_INT 3
75391: EQUAL
75392: IFFALSE 75501
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
75394: LD_VAR 0 14
75398: PUSH
75399: LD_VAR 0 8
75403: ARRAY
75404: PUSH
75405: LD_VAR 0 28
75409: IN
75410: NOT
75411: PUSH
75412: LD_VAR 0 14
75416: PUSH
75417: LD_VAR 0 8
75421: ARRAY
75422: PPUSH
75423: CALL_OW 313
75427: AND
75428: IFFALSE 75501
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
75430: LD_VAR 0 4
75434: PUSH
75435: LD_VAR 0 7
75439: ARRAY
75440: PPUSH
75441: LD_VAR 0 14
75445: PUSH
75446: LD_VAR 0 8
75450: ARRAY
75451: PPUSH
75452: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
75456: LD_ADDR_VAR 0 28
75460: PUSH
75461: LD_VAR 0 28
75465: PPUSH
75466: LD_VAR 0 28
75470: PUSH
75471: LD_INT 1
75473: PLUS
75474: PPUSH
75475: LD_VAR 0 14
75479: PUSH
75480: LD_VAR 0 8
75484: ARRAY
75485: PPUSH
75486: CALL_OW 1
75490: ST_TO_ADDR
// attacking := true ;
75491: LD_ADDR_VAR 0 29
75495: PUSH
75496: LD_INT 1
75498: ST_TO_ADDR
// break ;
75499: GO 75503
// end ; end ;
75501: GO 75370
75503: POP
75504: POP
// if not attacking and f_attack_depot then
75505: LD_VAR 0 29
75509: NOT
75510: PUSH
75511: LD_VAR 0 25
75515: AND
75516: IFFALSE 75611
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75518: LD_ADDR_VAR 0 13
75522: PUSH
75523: LD_VAR 0 14
75527: PPUSH
75528: LD_INT 2
75530: PUSH
75531: LD_INT 30
75533: PUSH
75534: LD_INT 0
75536: PUSH
75537: EMPTY
75538: LIST
75539: LIST
75540: PUSH
75541: LD_INT 30
75543: PUSH
75544: LD_INT 1
75546: PUSH
75547: EMPTY
75548: LIST
75549: LIST
75550: PUSH
75551: EMPTY
75552: LIST
75553: LIST
75554: LIST
75555: PPUSH
75556: CALL_OW 72
75560: ST_TO_ADDR
// if z then
75561: LD_VAR 0 13
75565: IFFALSE 75611
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
75567: LD_VAR 0 4
75571: PUSH
75572: LD_VAR 0 7
75576: ARRAY
75577: PPUSH
75578: LD_VAR 0 13
75582: PPUSH
75583: LD_VAR 0 4
75587: PUSH
75588: LD_VAR 0 7
75592: ARRAY
75593: PPUSH
75594: CALL_OW 74
75598: PPUSH
75599: CALL_OW 115
// attacking := true ;
75603: LD_ADDR_VAR 0 29
75607: PUSH
75608: LD_INT 1
75610: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
75611: LD_VAR 0 4
75615: PUSH
75616: LD_VAR 0 7
75620: ARRAY
75621: PPUSH
75622: CALL_OW 256
75626: PUSH
75627: LD_INT 500
75629: LESS
75630: IFFALSE 75656
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
75632: LD_VAR 0 4
75636: PUSH
75637: LD_VAR 0 7
75641: ARRAY
75642: PPUSH
75643: LD_VAR 0 14
75647: PUSH
75648: LD_INT 1
75650: ARRAY
75651: PPUSH
75652: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
75656: LD_VAR 0 4
75660: PUSH
75661: LD_VAR 0 7
75665: ARRAY
75666: PPUSH
75667: CALL_OW 264
75671: PUSH
75672: LD_INT 49
75674: EQUAL
75675: IFFALSE 75796
// begin if not HasTask ( group [ i ] ) then
75677: LD_VAR 0 4
75681: PUSH
75682: LD_VAR 0 7
75686: ARRAY
75687: PPUSH
75688: CALL_OW 314
75692: NOT
75693: IFFALSE 75796
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
75695: LD_ADDR_VAR 0 9
75699: PUSH
75700: LD_INT 81
75702: PUSH
75703: LD_VAR 0 4
75707: PUSH
75708: LD_VAR 0 7
75712: ARRAY
75713: PPUSH
75714: CALL_OW 255
75718: PUSH
75719: EMPTY
75720: LIST
75721: LIST
75722: PPUSH
75723: CALL_OW 69
75727: PPUSH
75728: LD_VAR 0 4
75732: PUSH
75733: LD_VAR 0 7
75737: ARRAY
75738: PPUSH
75739: CALL_OW 74
75743: ST_TO_ADDR
// if k then
75744: LD_VAR 0 9
75748: IFFALSE 75796
// if GetDistUnits ( group [ i ] , k ) > 10 then
75750: LD_VAR 0 4
75754: PUSH
75755: LD_VAR 0 7
75759: ARRAY
75760: PPUSH
75761: LD_VAR 0 9
75765: PPUSH
75766: CALL_OW 296
75770: PUSH
75771: LD_INT 10
75773: GREATER
75774: IFFALSE 75796
// ComMoveUnit ( group [ i ] , k ) ;
75776: LD_VAR 0 4
75780: PUSH
75781: LD_VAR 0 7
75785: ARRAY
75786: PPUSH
75787: LD_VAR 0 9
75791: PPUSH
75792: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
75796: LD_VAR 0 4
75800: PUSH
75801: LD_VAR 0 7
75805: ARRAY
75806: PPUSH
75807: CALL_OW 256
75811: PUSH
75812: LD_INT 250
75814: LESS
75815: PUSH
75816: LD_VAR 0 4
75820: PUSH
75821: LD_VAR 0 7
75825: ARRAY
75826: PUSH
75827: LD_INT 21
75829: PUSH
75830: LD_INT 2
75832: PUSH
75833: EMPTY
75834: LIST
75835: LIST
75836: PUSH
75837: LD_INT 23
75839: PUSH
75840: LD_INT 2
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: PUSH
75847: EMPTY
75848: LIST
75849: LIST
75850: PPUSH
75851: CALL_OW 69
75855: IN
75856: AND
75857: IFFALSE 75982
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
75859: LD_ADDR_VAR 0 9
75863: PUSH
75864: LD_OWVAR 3
75868: PUSH
75869: LD_VAR 0 4
75873: PUSH
75874: LD_VAR 0 7
75878: ARRAY
75879: DIFF
75880: PPUSH
75881: LD_VAR 0 4
75885: PUSH
75886: LD_VAR 0 7
75890: ARRAY
75891: PPUSH
75892: CALL_OW 74
75896: ST_TO_ADDR
// if not k then
75897: LD_VAR 0 9
75901: NOT
75902: IFFALSE 75906
// continue ;
75904: GO 72321
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
75906: LD_VAR 0 9
75910: PUSH
75911: LD_INT 81
75913: PUSH
75914: LD_VAR 0 4
75918: PUSH
75919: LD_VAR 0 7
75923: ARRAY
75924: PPUSH
75925: CALL_OW 255
75929: PUSH
75930: EMPTY
75931: LIST
75932: LIST
75933: PPUSH
75934: CALL_OW 69
75938: IN
75939: PUSH
75940: LD_VAR 0 9
75944: PPUSH
75945: LD_VAR 0 4
75949: PUSH
75950: LD_VAR 0 7
75954: ARRAY
75955: PPUSH
75956: CALL_OW 296
75960: PUSH
75961: LD_INT 5
75963: LESS
75964: AND
75965: IFFALSE 75982
// ComAutodestruct ( group [ i ] ) ;
75967: LD_VAR 0 4
75971: PUSH
75972: LD_VAR 0 7
75976: ARRAY
75977: PPUSH
75978: CALL 36513 0 1
// end ; if f_attack_depot then
75982: LD_VAR 0 25
75986: IFFALSE 76098
// begin k := 6 ;
75988: LD_ADDR_VAR 0 9
75992: PUSH
75993: LD_INT 6
75995: ST_TO_ADDR
// if tmp < k then
75996: LD_VAR 0 14
76000: PUSH
76001: LD_VAR 0 9
76005: LESS
76006: IFFALSE 76018
// k := tmp ;
76008: LD_ADDR_VAR 0 9
76012: PUSH
76013: LD_VAR 0 14
76017: ST_TO_ADDR
// for j = 1 to k do
76018: LD_ADDR_VAR 0 8
76022: PUSH
76023: DOUBLE
76024: LD_INT 1
76026: DEC
76027: ST_TO_ADDR
76028: LD_VAR 0 9
76032: PUSH
76033: FOR_TO
76034: IFFALSE 76096
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
76036: LD_VAR 0 8
76040: PPUSH
76041: CALL_OW 266
76045: PUSH
76046: LD_INT 0
76048: PUSH
76049: LD_INT 1
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: IN
76056: IFFALSE 76094
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
76058: LD_VAR 0 4
76062: PUSH
76063: LD_VAR 0 7
76067: ARRAY
76068: PPUSH
76069: LD_VAR 0 14
76073: PUSH
76074: LD_VAR 0 8
76078: ARRAY
76079: PPUSH
76080: CALL_OW 115
// attacking := true ;
76084: LD_ADDR_VAR 0 29
76088: PUSH
76089: LD_INT 1
76091: ST_TO_ADDR
// break ;
76092: GO 76096
// end ;
76094: GO 76033
76096: POP
76097: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
76098: LD_VAR 0 4
76102: PUSH
76103: LD_VAR 0 7
76107: ARRAY
76108: PPUSH
76109: CALL_OW 302
76113: PUSH
76114: LD_VAR 0 29
76118: NOT
76119: AND
76120: IFFALSE 76442
// begin if GetTag ( group [ i ] ) = 71 then
76122: LD_VAR 0 4
76126: PUSH
76127: LD_VAR 0 7
76131: ARRAY
76132: PPUSH
76133: CALL_OW 110
76137: PUSH
76138: LD_INT 71
76140: EQUAL
76141: IFFALSE 76182
// begin if HasTask ( group [ i ] ) then
76143: LD_VAR 0 4
76147: PUSH
76148: LD_VAR 0 7
76152: ARRAY
76153: PPUSH
76154: CALL_OW 314
76158: IFFALSE 76164
// continue else
76160: GO 72321
76162: GO 76182
// SetTag ( group [ i ] , 0 ) ;
76164: LD_VAR 0 4
76168: PUSH
76169: LD_VAR 0 7
76173: ARRAY
76174: PPUSH
76175: LD_INT 0
76177: PPUSH
76178: CALL_OW 109
// end ; k := 8 ;
76182: LD_ADDR_VAR 0 9
76186: PUSH
76187: LD_INT 8
76189: ST_TO_ADDR
// x := 0 ;
76190: LD_ADDR_VAR 0 10
76194: PUSH
76195: LD_INT 0
76197: ST_TO_ADDR
// if tmp < k then
76198: LD_VAR 0 14
76202: PUSH
76203: LD_VAR 0 9
76207: LESS
76208: IFFALSE 76220
// k := tmp ;
76210: LD_ADDR_VAR 0 9
76214: PUSH
76215: LD_VAR 0 14
76219: ST_TO_ADDR
// for j = 1 to k do
76220: LD_ADDR_VAR 0 8
76224: PUSH
76225: DOUBLE
76226: LD_INT 1
76228: DEC
76229: ST_TO_ADDR
76230: LD_VAR 0 9
76234: PUSH
76235: FOR_TO
76236: IFFALSE 76334
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
76238: LD_VAR 0 14
76242: PUSH
76243: LD_VAR 0 8
76247: ARRAY
76248: PPUSH
76249: CALL_OW 247
76253: PUSH
76254: LD_INT 1
76256: EQUAL
76257: PUSH
76258: LD_VAR 0 14
76262: PUSH
76263: LD_VAR 0 8
76267: ARRAY
76268: PPUSH
76269: CALL_OW 256
76273: PUSH
76274: LD_INT 250
76276: LESS
76277: PUSH
76278: LD_VAR 0 20
76282: AND
76283: PUSH
76284: LD_VAR 0 20
76288: NOT
76289: PUSH
76290: LD_VAR 0 14
76294: PUSH
76295: LD_VAR 0 8
76299: ARRAY
76300: PPUSH
76301: CALL_OW 256
76305: PUSH
76306: LD_INT 250
76308: GREATEREQUAL
76309: AND
76310: OR
76311: AND
76312: IFFALSE 76332
// begin x := tmp [ j ] ;
76314: LD_ADDR_VAR 0 10
76318: PUSH
76319: LD_VAR 0 14
76323: PUSH
76324: LD_VAR 0 8
76328: ARRAY
76329: ST_TO_ADDR
// break ;
76330: GO 76334
// end ;
76332: GO 76235
76334: POP
76335: POP
// if x then
76336: LD_VAR 0 10
76340: IFFALSE 76364
// ComAttackUnit ( group [ i ] , x ) else
76342: LD_VAR 0 4
76346: PUSH
76347: LD_VAR 0 7
76351: ARRAY
76352: PPUSH
76353: LD_VAR 0 10
76357: PPUSH
76358: CALL_OW 115
76362: GO 76388
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76364: LD_VAR 0 4
76368: PUSH
76369: LD_VAR 0 7
76373: ARRAY
76374: PPUSH
76375: LD_VAR 0 14
76379: PUSH
76380: LD_INT 1
76382: ARRAY
76383: PPUSH
76384: CALL_OW 115
// if not HasTask ( group [ i ] ) then
76388: LD_VAR 0 4
76392: PUSH
76393: LD_VAR 0 7
76397: ARRAY
76398: PPUSH
76399: CALL_OW 314
76403: NOT
76404: IFFALSE 76442
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
76406: LD_VAR 0 4
76410: PUSH
76411: LD_VAR 0 7
76415: ARRAY
76416: PPUSH
76417: LD_VAR 0 14
76421: PPUSH
76422: LD_VAR 0 4
76426: PUSH
76427: LD_VAR 0 7
76431: ARRAY
76432: PPUSH
76433: CALL_OW 74
76437: PPUSH
76438: CALL_OW 115
// end ; end ; end ;
76442: GO 72321
76444: POP
76445: POP
// wait ( 0 0$2 ) ;
76446: LD_INT 70
76448: PPUSH
76449: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
76453: LD_VAR 0 4
76457: NOT
76458: PUSH
76459: LD_VAR 0 4
76463: PUSH
76464: EMPTY
76465: EQUAL
76466: OR
76467: PUSH
76468: LD_INT 81
76470: PUSH
76471: LD_VAR 0 35
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: PPUSH
76480: CALL_OW 69
76484: NOT
76485: OR
76486: IFFALSE 72306
// end ;
76488: LD_VAR 0 2
76492: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
76493: LD_INT 0
76495: PPUSH
76496: PPUSH
76497: PPUSH
76498: PPUSH
76499: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
76500: LD_VAR 0 1
76504: NOT
76505: PUSH
76506: LD_EXP 14
76510: PUSH
76511: LD_VAR 0 1
76515: ARRAY
76516: NOT
76517: OR
76518: PUSH
76519: LD_VAR 0 2
76523: NOT
76524: OR
76525: PUSH
76526: LD_VAR 0 3
76530: NOT
76531: OR
76532: IFFALSE 76536
// exit ;
76534: GO 77049
// side := mc_sides [ base ] ;
76536: LD_ADDR_VAR 0 6
76540: PUSH
76541: LD_EXP 40
76545: PUSH
76546: LD_VAR 0 1
76550: ARRAY
76551: ST_TO_ADDR
// if not side then
76552: LD_VAR 0 6
76556: NOT
76557: IFFALSE 76561
// exit ;
76559: GO 77049
// for i in solds do
76561: LD_ADDR_VAR 0 7
76565: PUSH
76566: LD_VAR 0 2
76570: PUSH
76571: FOR_IN
76572: IFFALSE 76633
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
76574: LD_VAR 0 7
76578: PPUSH
76579: CALL_OW 310
76583: PPUSH
76584: CALL_OW 266
76588: PUSH
76589: LD_INT 32
76591: PUSH
76592: LD_INT 31
76594: PUSH
76595: EMPTY
76596: LIST
76597: LIST
76598: IN
76599: IFFALSE 76619
// solds := solds diff i else
76601: LD_ADDR_VAR 0 2
76605: PUSH
76606: LD_VAR 0 2
76610: PUSH
76611: LD_VAR 0 7
76615: DIFF
76616: ST_TO_ADDR
76617: GO 76631
// SetTag ( i , 18 ) ;
76619: LD_VAR 0 7
76623: PPUSH
76624: LD_INT 18
76626: PPUSH
76627: CALL_OW 109
76631: GO 76571
76633: POP
76634: POP
// if not solds then
76635: LD_VAR 0 2
76639: NOT
76640: IFFALSE 76644
// exit ;
76642: GO 77049
// repeat wait ( 0 0$2 ) ;
76644: LD_INT 70
76646: PPUSH
76647: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
76651: LD_ADDR_VAR 0 5
76655: PUSH
76656: LD_VAR 0 6
76660: PPUSH
76661: LD_VAR 0 3
76665: PPUSH
76666: CALL 6228 0 2
76670: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
76671: LD_EXP 14
76675: PUSH
76676: LD_VAR 0 1
76680: ARRAY
76681: NOT
76682: PUSH
76683: LD_EXP 14
76687: PUSH
76688: LD_VAR 0 1
76692: ARRAY
76693: PUSH
76694: EMPTY
76695: EQUAL
76696: OR
76697: IFFALSE 76734
// begin for i in solds do
76699: LD_ADDR_VAR 0 7
76703: PUSH
76704: LD_VAR 0 2
76708: PUSH
76709: FOR_IN
76710: IFFALSE 76723
// ComStop ( i ) ;
76712: LD_VAR 0 7
76716: PPUSH
76717: CALL_OW 141
76721: GO 76709
76723: POP
76724: POP
// solds := [ ] ;
76725: LD_ADDR_VAR 0 2
76729: PUSH
76730: EMPTY
76731: ST_TO_ADDR
// exit ;
76732: GO 77049
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
76734: LD_VAR 0 5
76738: NOT
76739: PUSH
76740: LD_VAR 0 5
76744: PUSH
76745: LD_INT 3
76747: GREATER
76748: OR
76749: PUSH
76750: LD_EXP 36
76754: PUSH
76755: LD_VAR 0 1
76759: ARRAY
76760: OR
76761: IFFALSE 76802
// begin for i in solds do
76763: LD_ADDR_VAR 0 7
76767: PUSH
76768: LD_VAR 0 2
76772: PUSH
76773: FOR_IN
76774: IFFALSE 76798
// if HasTask ( i ) then
76776: LD_VAR 0 7
76780: PPUSH
76781: CALL_OW 314
76785: IFFALSE 76796
// ComStop ( i ) ;
76787: LD_VAR 0 7
76791: PPUSH
76792: CALL_OW 141
76796: GO 76773
76798: POP
76799: POP
// break ;
76800: GO 77037
// end ; for i in solds do
76802: LD_ADDR_VAR 0 7
76806: PUSH
76807: LD_VAR 0 2
76811: PUSH
76812: FOR_IN
76813: IFFALSE 77029
// begin if IsInUnit ( i ) then
76815: LD_VAR 0 7
76819: PPUSH
76820: CALL_OW 310
76824: IFFALSE 76835
// ComExitBuilding ( i ) ;
76826: LD_VAR 0 7
76830: PPUSH
76831: CALL_OW 122
// if GetLives ( i ) > 333 then
76835: LD_VAR 0 7
76839: PPUSH
76840: CALL_OW 256
76844: PUSH
76845: LD_INT 333
76847: GREATER
76848: IFFALSE 76876
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
76850: LD_VAR 0 7
76854: PPUSH
76855: LD_VAR 0 5
76859: PPUSH
76860: LD_VAR 0 7
76864: PPUSH
76865: CALL_OW 74
76869: PPUSH
76870: CALL_OW 115
76874: GO 77027
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
76876: LD_ADDR_VAR 0 8
76880: PUSH
76881: LD_EXP 14
76885: PUSH
76886: LD_VAR 0 1
76890: ARRAY
76891: PPUSH
76892: LD_INT 2
76894: PUSH
76895: LD_INT 30
76897: PUSH
76898: LD_INT 0
76900: PUSH
76901: EMPTY
76902: LIST
76903: LIST
76904: PUSH
76905: LD_INT 30
76907: PUSH
76908: LD_INT 1
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: LD_INT 30
76917: PUSH
76918: LD_INT 6
76920: PUSH
76921: EMPTY
76922: LIST
76923: LIST
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: LIST
76929: LIST
76930: PPUSH
76931: CALL_OW 72
76935: PPUSH
76936: LD_VAR 0 7
76940: PPUSH
76941: CALL_OW 74
76945: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
76946: LD_VAR 0 7
76950: PPUSH
76951: LD_VAR 0 8
76955: PPUSH
76956: CALL_OW 250
76960: PPUSH
76961: LD_INT 3
76963: PPUSH
76964: LD_INT 5
76966: PPUSH
76967: CALL_OW 272
76971: PPUSH
76972: LD_VAR 0 8
76976: PPUSH
76977: CALL_OW 251
76981: PPUSH
76982: LD_INT 3
76984: PPUSH
76985: LD_INT 5
76987: PPUSH
76988: CALL_OW 273
76992: PPUSH
76993: CALL_OW 111
// SetTag ( i , 0 ) ;
76997: LD_VAR 0 7
77001: PPUSH
77002: LD_INT 0
77004: PPUSH
77005: CALL_OW 109
// solds := solds diff i ;
77009: LD_ADDR_VAR 0 2
77013: PUSH
77014: LD_VAR 0 2
77018: PUSH
77019: LD_VAR 0 7
77023: DIFF
77024: ST_TO_ADDR
// continue ;
77025: GO 76812
// end ; end ;
77027: GO 76812
77029: POP
77030: POP
// until solds ;
77031: LD_VAR 0 2
77035: IFFALSE 76644
// MC_Reset ( base , 18 ) ;
77037: LD_VAR 0 1
77041: PPUSH
77042: LD_INT 18
77044: PPUSH
77045: CALL 45628 0 2
// end ;
77049: LD_VAR 0 4
77053: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
77054: LD_INT 0
77056: PPUSH
77057: PPUSH
77058: PPUSH
77059: PPUSH
77060: PPUSH
77061: PPUSH
77062: PPUSH
77063: PPUSH
77064: PPUSH
77065: PPUSH
77066: PPUSH
77067: PPUSH
77068: PPUSH
77069: PPUSH
77070: PPUSH
77071: PPUSH
77072: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
77073: LD_ADDR_VAR 0 13
77077: PUSH
77078: LD_EXP 14
77082: PUSH
77083: LD_VAR 0 1
77087: ARRAY
77088: PPUSH
77089: LD_INT 25
77091: PUSH
77092: LD_INT 3
77094: PUSH
77095: EMPTY
77096: LIST
77097: LIST
77098: PPUSH
77099: CALL_OW 72
77103: ST_TO_ADDR
// if mc_remote_driver [ base ] then
77104: LD_EXP 54
77108: PUSH
77109: LD_VAR 0 1
77113: ARRAY
77114: IFFALSE 77138
// mechs := mechs diff mc_remote_driver [ base ] ;
77116: LD_ADDR_VAR 0 13
77120: PUSH
77121: LD_VAR 0 13
77125: PUSH
77126: LD_EXP 54
77130: PUSH
77131: LD_VAR 0 1
77135: ARRAY
77136: DIFF
77137: ST_TO_ADDR
// for i in mechs do
77138: LD_ADDR_VAR 0 5
77142: PUSH
77143: LD_VAR 0 13
77147: PUSH
77148: FOR_IN
77149: IFFALSE 77184
// if GetTag ( i ) > 0 then
77151: LD_VAR 0 5
77155: PPUSH
77156: CALL_OW 110
77160: PUSH
77161: LD_INT 0
77163: GREATER
77164: IFFALSE 77182
// mechs := mechs diff i ;
77166: LD_ADDR_VAR 0 13
77170: PUSH
77171: LD_VAR 0 13
77175: PUSH
77176: LD_VAR 0 5
77180: DIFF
77181: ST_TO_ADDR
77182: GO 77148
77184: POP
77185: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77186: LD_ADDR_VAR 0 9
77190: PUSH
77191: LD_EXP 14
77195: PUSH
77196: LD_VAR 0 1
77200: ARRAY
77201: PPUSH
77202: LD_INT 2
77204: PUSH
77205: LD_INT 25
77207: PUSH
77208: LD_INT 1
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: PUSH
77215: LD_INT 25
77217: PUSH
77218: LD_INT 5
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 25
77227: PUSH
77228: LD_INT 8
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 25
77237: PUSH
77238: LD_INT 9
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: EMPTY
77246: LIST
77247: LIST
77248: LIST
77249: LIST
77250: LIST
77251: PPUSH
77252: CALL_OW 72
77256: ST_TO_ADDR
// if not defenders and not solds then
77257: LD_VAR 0 2
77261: NOT
77262: PUSH
77263: LD_VAR 0 9
77267: NOT
77268: AND
77269: IFFALSE 77273
// exit ;
77271: GO 78963
// depot_under_attack := false ;
77273: LD_ADDR_VAR 0 17
77277: PUSH
77278: LD_INT 0
77280: ST_TO_ADDR
// sold_defenders := [ ] ;
77281: LD_ADDR_VAR 0 18
77285: PUSH
77286: EMPTY
77287: ST_TO_ADDR
// if mechs then
77288: LD_VAR 0 13
77292: IFFALSE 77445
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
77294: LD_ADDR_VAR 0 5
77298: PUSH
77299: LD_VAR 0 2
77303: PPUSH
77304: LD_INT 21
77306: PUSH
77307: LD_INT 2
77309: PUSH
77310: EMPTY
77311: LIST
77312: LIST
77313: PPUSH
77314: CALL_OW 72
77318: PUSH
77319: FOR_IN
77320: IFFALSE 77443
// begin if GetTag ( i ) <> 20 then
77322: LD_VAR 0 5
77326: PPUSH
77327: CALL_OW 110
77331: PUSH
77332: LD_INT 20
77334: NONEQUAL
77335: IFFALSE 77349
// SetTag ( i , 20 ) ;
77337: LD_VAR 0 5
77341: PPUSH
77342: LD_INT 20
77344: PPUSH
77345: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
77349: LD_VAR 0 5
77353: PPUSH
77354: CALL_OW 263
77358: PUSH
77359: LD_INT 1
77361: EQUAL
77362: PUSH
77363: LD_VAR 0 5
77367: PPUSH
77368: CALL_OW 311
77372: NOT
77373: AND
77374: IFFALSE 77441
// begin un := mechs [ 1 ] ;
77376: LD_ADDR_VAR 0 11
77380: PUSH
77381: LD_VAR 0 13
77385: PUSH
77386: LD_INT 1
77388: ARRAY
77389: ST_TO_ADDR
// ComExit ( un ) ;
77390: LD_VAR 0 11
77394: PPUSH
77395: CALL 40858 0 1
// AddComEnterUnit ( un , i ) ;
77399: LD_VAR 0 11
77403: PPUSH
77404: LD_VAR 0 5
77408: PPUSH
77409: CALL_OW 180
// SetTag ( un , 19 ) ;
77413: LD_VAR 0 11
77417: PPUSH
77418: LD_INT 19
77420: PPUSH
77421: CALL_OW 109
// mechs := mechs diff un ;
77425: LD_ADDR_VAR 0 13
77429: PUSH
77430: LD_VAR 0 13
77434: PUSH
77435: LD_VAR 0 11
77439: DIFF
77440: ST_TO_ADDR
// end ; end ;
77441: GO 77319
77443: POP
77444: POP
// if solds then
77445: LD_VAR 0 9
77449: IFFALSE 77508
// for i in solds do
77451: LD_ADDR_VAR 0 5
77455: PUSH
77456: LD_VAR 0 9
77460: PUSH
77461: FOR_IN
77462: IFFALSE 77506
// if not GetTag ( i ) then
77464: LD_VAR 0 5
77468: PPUSH
77469: CALL_OW 110
77473: NOT
77474: IFFALSE 77504
// begin defenders := defenders union i ;
77476: LD_ADDR_VAR 0 2
77480: PUSH
77481: LD_VAR 0 2
77485: PUSH
77486: LD_VAR 0 5
77490: UNION
77491: ST_TO_ADDR
// SetTag ( i , 18 ) ;
77492: LD_VAR 0 5
77496: PPUSH
77497: LD_INT 18
77499: PPUSH
77500: CALL_OW 109
// end ;
77504: GO 77461
77506: POP
77507: POP
// repeat wait ( 0 0$2 ) ;
77508: LD_INT 70
77510: PPUSH
77511: CALL_OW 67
// enemy := mc_scan [ base ] ;
77515: LD_ADDR_VAR 0 3
77519: PUSH
77520: LD_EXP 37
77524: PUSH
77525: LD_VAR 0 1
77529: ARRAY
77530: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
77531: LD_EXP 14
77535: PUSH
77536: LD_VAR 0 1
77540: ARRAY
77541: NOT
77542: PUSH
77543: LD_EXP 14
77547: PUSH
77548: LD_VAR 0 1
77552: ARRAY
77553: PUSH
77554: EMPTY
77555: EQUAL
77556: OR
77557: IFFALSE 77594
// begin for i in defenders do
77559: LD_ADDR_VAR 0 5
77563: PUSH
77564: LD_VAR 0 2
77568: PUSH
77569: FOR_IN
77570: IFFALSE 77583
// ComStop ( i ) ;
77572: LD_VAR 0 5
77576: PPUSH
77577: CALL_OW 141
77581: GO 77569
77583: POP
77584: POP
// defenders := [ ] ;
77585: LD_ADDR_VAR 0 2
77589: PUSH
77590: EMPTY
77591: ST_TO_ADDR
// exit ;
77592: GO 78963
// end ; for i in defenders do
77594: LD_ADDR_VAR 0 5
77598: PUSH
77599: LD_VAR 0 2
77603: PUSH
77604: FOR_IN
77605: IFFALSE 78423
// begin e := NearestUnitToUnit ( enemy , i ) ;
77607: LD_ADDR_VAR 0 14
77611: PUSH
77612: LD_VAR 0 3
77616: PPUSH
77617: LD_VAR 0 5
77621: PPUSH
77622: CALL_OW 74
77626: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77627: LD_ADDR_VAR 0 8
77631: PUSH
77632: LD_EXP 14
77636: PUSH
77637: LD_VAR 0 1
77641: ARRAY
77642: PPUSH
77643: LD_INT 2
77645: PUSH
77646: LD_INT 30
77648: PUSH
77649: LD_INT 0
77651: PUSH
77652: EMPTY
77653: LIST
77654: LIST
77655: PUSH
77656: LD_INT 30
77658: PUSH
77659: LD_INT 1
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: EMPTY
77667: LIST
77668: LIST
77669: LIST
77670: PPUSH
77671: CALL_OW 72
77675: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
77676: LD_ADDR_VAR 0 17
77680: PUSH
77681: LD_VAR 0 8
77685: NOT
77686: PUSH
77687: LD_VAR 0 8
77691: PPUSH
77692: LD_INT 3
77694: PUSH
77695: LD_INT 24
77697: PUSH
77698: LD_INT 600
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PPUSH
77709: CALL_OW 72
77713: OR
77714: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
77715: LD_VAR 0 5
77719: PPUSH
77720: CALL_OW 247
77724: PUSH
77725: LD_INT 2
77727: DOUBLE
77728: EQUAL
77729: IFTRUE 77733
77731: GO 78129
77733: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
77734: LD_VAR 0 5
77738: PPUSH
77739: CALL_OW 256
77743: PUSH
77744: LD_INT 650
77746: GREATER
77747: PUSH
77748: LD_VAR 0 5
77752: PPUSH
77753: LD_VAR 0 14
77757: PPUSH
77758: CALL_OW 296
77762: PUSH
77763: LD_INT 40
77765: LESS
77766: PUSH
77767: LD_VAR 0 14
77771: PPUSH
77772: LD_EXP 39
77776: PUSH
77777: LD_VAR 0 1
77781: ARRAY
77782: PPUSH
77783: CALL_OW 308
77787: OR
77788: AND
77789: IFFALSE 77911
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
77791: LD_VAR 0 5
77795: PPUSH
77796: CALL_OW 262
77800: PUSH
77801: LD_INT 1
77803: EQUAL
77804: PUSH
77805: LD_VAR 0 5
77809: PPUSH
77810: CALL_OW 261
77814: PUSH
77815: LD_INT 30
77817: LESS
77818: AND
77819: PUSH
77820: LD_VAR 0 8
77824: AND
77825: IFFALSE 77895
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
77827: LD_VAR 0 5
77831: PPUSH
77832: LD_VAR 0 8
77836: PPUSH
77837: LD_VAR 0 5
77841: PPUSH
77842: CALL_OW 74
77846: PPUSH
77847: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
77851: LD_VAR 0 5
77855: PPUSH
77856: LD_VAR 0 8
77860: PPUSH
77861: LD_VAR 0 5
77865: PPUSH
77866: CALL_OW 74
77870: PPUSH
77871: CALL_OW 296
77875: PUSH
77876: LD_INT 6
77878: LESS
77879: IFFALSE 77893
// SetFuel ( i , 100 ) ;
77881: LD_VAR 0 5
77885: PPUSH
77886: LD_INT 100
77888: PPUSH
77889: CALL_OW 240
// end else
77893: GO 77909
// ComAttackUnit ( i , e ) ;
77895: LD_VAR 0 5
77899: PPUSH
77900: LD_VAR 0 14
77904: PPUSH
77905: CALL_OW 115
// end else
77909: GO 78012
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
77911: LD_VAR 0 14
77915: PPUSH
77916: LD_EXP 39
77920: PUSH
77921: LD_VAR 0 1
77925: ARRAY
77926: PPUSH
77927: CALL_OW 308
77931: NOT
77932: PUSH
77933: LD_VAR 0 5
77937: PPUSH
77938: LD_VAR 0 14
77942: PPUSH
77943: CALL_OW 296
77947: PUSH
77948: LD_INT 40
77950: GREATEREQUAL
77951: AND
77952: PUSH
77953: LD_VAR 0 5
77957: PPUSH
77958: CALL_OW 256
77962: PUSH
77963: LD_INT 650
77965: LESSEQUAL
77966: OR
77967: PUSH
77968: LD_VAR 0 5
77972: PPUSH
77973: LD_EXP 38
77977: PUSH
77978: LD_VAR 0 1
77982: ARRAY
77983: PPUSH
77984: CALL_OW 308
77988: NOT
77989: AND
77990: IFFALSE 78012
// ComMoveToArea ( i , mc_parking [ base ] ) ;
77992: LD_VAR 0 5
77996: PPUSH
77997: LD_EXP 38
78001: PUSH
78002: LD_VAR 0 1
78006: ARRAY
78007: PPUSH
78008: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
78012: LD_VAR 0 5
78016: PPUSH
78017: CALL_OW 256
78021: PUSH
78022: LD_INT 998
78024: LESS
78025: PUSH
78026: LD_VAR 0 5
78030: PPUSH
78031: CALL_OW 263
78035: PUSH
78036: LD_INT 1
78038: EQUAL
78039: AND
78040: PUSH
78041: LD_VAR 0 5
78045: PPUSH
78046: CALL_OW 311
78050: AND
78051: PUSH
78052: LD_VAR 0 5
78056: PPUSH
78057: LD_EXP 38
78061: PUSH
78062: LD_VAR 0 1
78066: ARRAY
78067: PPUSH
78068: CALL_OW 308
78072: AND
78073: IFFALSE 78127
// begin mech := IsDrivenBy ( i ) ;
78075: LD_ADDR_VAR 0 10
78079: PUSH
78080: LD_VAR 0 5
78084: PPUSH
78085: CALL_OW 311
78089: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
78090: LD_VAR 0 10
78094: PPUSH
78095: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
78099: LD_VAR 0 10
78103: PPUSH
78104: LD_VAR 0 5
78108: PPUSH
78109: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
78113: LD_VAR 0 10
78117: PPUSH
78118: LD_VAR 0 5
78122: PPUSH
78123: CALL_OW 180
// end ; end ; unit_human :
78127: GO 78394
78129: LD_INT 1
78131: DOUBLE
78132: EQUAL
78133: IFTRUE 78137
78135: GO 78393
78137: POP
// begin b := IsInUnit ( i ) ;
78138: LD_ADDR_VAR 0 19
78142: PUSH
78143: LD_VAR 0 5
78147: PPUSH
78148: CALL_OW 310
78152: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
78153: LD_ADDR_VAR 0 20
78157: PUSH
78158: LD_VAR 0 19
78162: NOT
78163: PUSH
78164: LD_VAR 0 19
78168: PPUSH
78169: CALL_OW 266
78173: PUSH
78174: LD_INT 32
78176: PUSH
78177: LD_INT 31
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: IN
78184: OR
78185: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
78186: LD_VAR 0 17
78190: PUSH
78191: LD_VAR 0 2
78195: PPUSH
78196: LD_INT 21
78198: PUSH
78199: LD_INT 2
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PPUSH
78206: CALL_OW 72
78210: PUSH
78211: LD_INT 1
78213: LESSEQUAL
78214: OR
78215: PUSH
78216: LD_VAR 0 20
78220: AND
78221: PUSH
78222: LD_VAR 0 5
78226: PUSH
78227: LD_VAR 0 18
78231: IN
78232: NOT
78233: AND
78234: IFFALSE 78327
// begin if b then
78236: LD_VAR 0 19
78240: IFFALSE 78289
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
78242: LD_VAR 0 19
78246: PPUSH
78247: LD_VAR 0 3
78251: PPUSH
78252: LD_VAR 0 19
78256: PPUSH
78257: CALL_OW 74
78261: PPUSH
78262: CALL_OW 296
78266: PUSH
78267: LD_INT 10
78269: LESS
78270: PUSH
78271: LD_VAR 0 19
78275: PPUSH
78276: CALL_OW 461
78280: PUSH
78281: LD_INT 7
78283: NONEQUAL
78284: AND
78285: IFFALSE 78289
// continue ;
78287: GO 77604
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
78289: LD_ADDR_VAR 0 18
78293: PUSH
78294: LD_VAR 0 18
78298: PPUSH
78299: LD_VAR 0 18
78303: PUSH
78304: LD_INT 1
78306: PLUS
78307: PPUSH
78308: LD_VAR 0 5
78312: PPUSH
78313: CALL_OW 1
78317: ST_TO_ADDR
// ComExitBuilding ( i ) ;
78318: LD_VAR 0 5
78322: PPUSH
78323: CALL_OW 122
// end ; if sold_defenders then
78327: LD_VAR 0 18
78331: IFFALSE 78391
// if i in sold_defenders then
78333: LD_VAR 0 5
78337: PUSH
78338: LD_VAR 0 18
78342: IN
78343: IFFALSE 78391
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
78345: LD_VAR 0 5
78349: PPUSH
78350: CALL_OW 314
78354: NOT
78355: PUSH
78356: LD_VAR 0 5
78360: PPUSH
78361: LD_VAR 0 14
78365: PPUSH
78366: CALL_OW 296
78370: PUSH
78371: LD_INT 30
78373: LESS
78374: AND
78375: IFFALSE 78391
// ComAttackUnit ( i , e ) ;
78377: LD_VAR 0 5
78381: PPUSH
78382: LD_VAR 0 14
78386: PPUSH
78387: CALL_OW 115
// end ; end ; end ;
78391: GO 78394
78393: POP
// if IsDead ( i ) then
78394: LD_VAR 0 5
78398: PPUSH
78399: CALL_OW 301
78403: IFFALSE 78421
// defenders := defenders diff i ;
78405: LD_ADDR_VAR 0 2
78409: PUSH
78410: LD_VAR 0 2
78414: PUSH
78415: LD_VAR 0 5
78419: DIFF
78420: ST_TO_ADDR
// end ;
78421: GO 77604
78423: POP
78424: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
78425: LD_VAR 0 3
78429: NOT
78430: PUSH
78431: LD_VAR 0 2
78435: NOT
78436: OR
78437: PUSH
78438: LD_EXP 14
78442: PUSH
78443: LD_VAR 0 1
78447: ARRAY
78448: NOT
78449: OR
78450: IFFALSE 77508
// MC_Reset ( base , 18 ) ;
78452: LD_VAR 0 1
78456: PPUSH
78457: LD_INT 18
78459: PPUSH
78460: CALL 45628 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
78464: LD_ADDR_VAR 0 2
78468: PUSH
78469: LD_VAR 0 2
78473: PUSH
78474: LD_VAR 0 2
78478: PPUSH
78479: LD_INT 2
78481: PUSH
78482: LD_INT 25
78484: PUSH
78485: LD_INT 1
78487: PUSH
78488: EMPTY
78489: LIST
78490: LIST
78491: PUSH
78492: LD_INT 25
78494: PUSH
78495: LD_INT 5
78497: PUSH
78498: EMPTY
78499: LIST
78500: LIST
78501: PUSH
78502: LD_INT 25
78504: PUSH
78505: LD_INT 8
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 25
78514: PUSH
78515: LD_INT 9
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: PPUSH
78529: CALL_OW 72
78533: DIFF
78534: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
78535: LD_VAR 0 3
78539: NOT
78540: PUSH
78541: LD_VAR 0 2
78545: PPUSH
78546: LD_INT 21
78548: PUSH
78549: LD_INT 2
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PPUSH
78556: CALL_OW 72
78560: AND
78561: IFFALSE 78899
// begin tmp := FilterByTag ( defenders , 19 ) ;
78563: LD_ADDR_VAR 0 12
78567: PUSH
78568: LD_VAR 0 2
78572: PPUSH
78573: LD_INT 19
78575: PPUSH
78576: CALL 37988 0 2
78580: ST_TO_ADDR
// if tmp then
78581: LD_VAR 0 12
78585: IFFALSE 78655
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
78587: LD_ADDR_VAR 0 12
78591: PUSH
78592: LD_VAR 0 12
78596: PPUSH
78597: LD_INT 25
78599: PUSH
78600: LD_INT 3
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PPUSH
78607: CALL_OW 72
78611: ST_TO_ADDR
// if tmp then
78612: LD_VAR 0 12
78616: IFFALSE 78655
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
78618: LD_ADDR_EXP 26
78622: PUSH
78623: LD_EXP 26
78627: PPUSH
78628: LD_VAR 0 1
78632: PPUSH
78633: LD_EXP 26
78637: PUSH
78638: LD_VAR 0 1
78642: ARRAY
78643: PUSH
78644: LD_VAR 0 12
78648: UNION
78649: PPUSH
78650: CALL_OW 1
78654: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
78655: LD_VAR 0 1
78659: PPUSH
78660: LD_INT 19
78662: PPUSH
78663: CALL 45628 0 2
// repeat wait ( 0 0$1 ) ;
78667: LD_INT 35
78669: PPUSH
78670: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
78674: LD_EXP 14
78678: PUSH
78679: LD_VAR 0 1
78683: ARRAY
78684: NOT
78685: PUSH
78686: LD_EXP 14
78690: PUSH
78691: LD_VAR 0 1
78695: ARRAY
78696: PUSH
78697: EMPTY
78698: EQUAL
78699: OR
78700: IFFALSE 78737
// begin for i in defenders do
78702: LD_ADDR_VAR 0 5
78706: PUSH
78707: LD_VAR 0 2
78711: PUSH
78712: FOR_IN
78713: IFFALSE 78726
// ComStop ( i ) ;
78715: LD_VAR 0 5
78719: PPUSH
78720: CALL_OW 141
78724: GO 78712
78726: POP
78727: POP
// defenders := [ ] ;
78728: LD_ADDR_VAR 0 2
78732: PUSH
78733: EMPTY
78734: ST_TO_ADDR
// exit ;
78735: GO 78963
// end ; for i in defenders do
78737: LD_ADDR_VAR 0 5
78741: PUSH
78742: LD_VAR 0 2
78746: PUSH
78747: FOR_IN
78748: IFFALSE 78837
// begin if not IsInArea ( i , mc_parking [ base ] ) then
78750: LD_VAR 0 5
78754: PPUSH
78755: LD_EXP 38
78759: PUSH
78760: LD_VAR 0 1
78764: ARRAY
78765: PPUSH
78766: CALL_OW 308
78770: NOT
78771: IFFALSE 78795
// ComMoveToArea ( i , mc_parking [ base ] ) else
78773: LD_VAR 0 5
78777: PPUSH
78778: LD_EXP 38
78782: PUSH
78783: LD_VAR 0 1
78787: ARRAY
78788: PPUSH
78789: CALL_OW 113
78793: GO 78835
// if GetControl ( i ) = control_manual then
78795: LD_VAR 0 5
78799: PPUSH
78800: CALL_OW 263
78804: PUSH
78805: LD_INT 1
78807: EQUAL
78808: IFFALSE 78835
// if IsDrivenBy ( i ) then
78810: LD_VAR 0 5
78814: PPUSH
78815: CALL_OW 311
78819: IFFALSE 78835
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
78821: LD_VAR 0 5
78825: PPUSH
78826: CALL_OW 311
78830: PPUSH
78831: CALL_OW 121
// end ;
78835: GO 78747
78837: POP
78838: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
78839: LD_VAR 0 2
78843: PPUSH
78844: LD_INT 95
78846: PUSH
78847: LD_EXP 38
78851: PUSH
78852: LD_VAR 0 1
78856: ARRAY
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PPUSH
78862: CALL_OW 72
78866: PUSH
78867: LD_VAR 0 2
78871: EQUAL
78872: PUSH
78873: LD_EXP 37
78877: PUSH
78878: LD_VAR 0 1
78882: ARRAY
78883: OR
78884: PUSH
78885: LD_EXP 14
78889: PUSH
78890: LD_VAR 0 1
78894: ARRAY
78895: NOT
78896: OR
78897: IFFALSE 78667
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
78899: LD_ADDR_EXP 36
78903: PUSH
78904: LD_EXP 36
78908: PPUSH
78909: LD_VAR 0 1
78913: PPUSH
78914: LD_VAR 0 2
78918: PPUSH
78919: LD_INT 21
78921: PUSH
78922: LD_INT 2
78924: PUSH
78925: EMPTY
78926: LIST
78927: LIST
78928: PPUSH
78929: CALL_OW 72
78933: PPUSH
78934: CALL_OW 1
78938: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
78939: LD_VAR 0 1
78943: PPUSH
78944: LD_INT 19
78946: PPUSH
78947: CALL 45628 0 2
// MC_Reset ( base , 20 ) ;
78951: LD_VAR 0 1
78955: PPUSH
78956: LD_INT 20
78958: PPUSH
78959: CALL 45628 0 2
// end ; end_of_file
78963: LD_VAR 0 4
78967: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
78968: LD_INT 0
78970: PPUSH
78971: PPUSH
78972: PPUSH
78973: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
78974: LD_VAR 0 1
78978: PPUSH
78979: CALL_OW 264
78983: PUSH
78984: LD_EXP 61
78988: EQUAL
78989: IFFALSE 79061
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
78991: LD_INT 68
78993: PPUSH
78994: LD_VAR 0 1
78998: PPUSH
78999: CALL_OW 255
79003: PPUSH
79004: CALL_OW 321
79008: PUSH
79009: LD_INT 2
79011: EQUAL
79012: IFFALSE 79024
// eff := 70 else
79014: LD_ADDR_VAR 0 4
79018: PUSH
79019: LD_INT 70
79021: ST_TO_ADDR
79022: GO 79032
// eff := 30 ;
79024: LD_ADDR_VAR 0 4
79028: PUSH
79029: LD_INT 30
79031: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
79032: LD_VAR 0 1
79036: PPUSH
79037: CALL_OW 250
79041: PPUSH
79042: LD_VAR 0 1
79046: PPUSH
79047: CALL_OW 251
79051: PPUSH
79052: LD_VAR 0 4
79056: PPUSH
79057: CALL_OW 495
// end ; end ;
79061: LD_VAR 0 2
79065: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
79066: LD_INT 0
79068: PPUSH
// end ;
79069: LD_VAR 0 4
79073: RET
// export function SOS_Command ( cmd ) ; begin
79074: LD_INT 0
79076: PPUSH
// end ;
79077: LD_VAR 0 2
79081: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
79082: LD_INT 0
79084: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
79085: LD_VAR 0 1
79089: PUSH
79090: LD_INT 250
79092: EQUAL
79093: PUSH
79094: LD_VAR 0 2
79098: PPUSH
79099: CALL_OW 264
79103: PUSH
79104: LD_EXP 64
79108: EQUAL
79109: AND
79110: IFFALSE 79131
// MinerPlaceMine ( unit , x , y ) ;
79112: LD_VAR 0 2
79116: PPUSH
79117: LD_VAR 0 4
79121: PPUSH
79122: LD_VAR 0 5
79126: PPUSH
79127: CALL 81472 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
79131: LD_VAR 0 1
79135: PUSH
79136: LD_INT 251
79138: EQUAL
79139: PUSH
79140: LD_VAR 0 2
79144: PPUSH
79145: CALL_OW 264
79149: PUSH
79150: LD_EXP 64
79154: EQUAL
79155: AND
79156: IFFALSE 79177
// MinerDetonateMine ( unit , x , y ) ;
79158: LD_VAR 0 2
79162: PPUSH
79163: LD_VAR 0 4
79167: PPUSH
79168: LD_VAR 0 5
79172: PPUSH
79173: CALL 81749 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
79177: LD_VAR 0 1
79181: PUSH
79182: LD_INT 252
79184: EQUAL
79185: PUSH
79186: LD_VAR 0 2
79190: PPUSH
79191: CALL_OW 264
79195: PUSH
79196: LD_EXP 64
79200: EQUAL
79201: AND
79202: IFFALSE 79223
// MinerCreateMinefield ( unit , x , y ) ;
79204: LD_VAR 0 2
79208: PPUSH
79209: LD_VAR 0 4
79213: PPUSH
79214: LD_VAR 0 5
79218: PPUSH
79219: CALL 82166 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
79223: LD_VAR 0 1
79227: PUSH
79228: LD_INT 253
79230: EQUAL
79231: PUSH
79232: LD_VAR 0 2
79236: PPUSH
79237: CALL_OW 257
79241: PUSH
79242: LD_INT 5
79244: EQUAL
79245: AND
79246: IFFALSE 79267
// ComBinocular ( unit , x , y ) ;
79248: LD_VAR 0 2
79252: PPUSH
79253: LD_VAR 0 4
79257: PPUSH
79258: LD_VAR 0 5
79262: PPUSH
79263: CALL 82537 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
79267: LD_VAR 0 1
79271: PUSH
79272: LD_INT 254
79274: EQUAL
79275: PUSH
79276: LD_VAR 0 2
79280: PPUSH
79281: CALL_OW 264
79285: PUSH
79286: LD_EXP 59
79290: EQUAL
79291: AND
79292: PUSH
79293: LD_VAR 0 3
79297: PPUSH
79298: CALL_OW 263
79302: PUSH
79303: LD_INT 3
79305: EQUAL
79306: AND
79307: IFFALSE 79323
// HackDestroyVehicle ( unit , selectedUnit ) ;
79309: LD_VAR 0 2
79313: PPUSH
79314: LD_VAR 0 3
79318: PPUSH
79319: CALL 80832 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
79323: LD_VAR 0 1
79327: PUSH
79328: LD_INT 255
79330: EQUAL
79331: PUSH
79332: LD_VAR 0 2
79336: PPUSH
79337: CALL_OW 264
79341: PUSH
79342: LD_INT 14
79344: PUSH
79345: LD_INT 53
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: IN
79352: AND
79353: PUSH
79354: LD_VAR 0 4
79358: PPUSH
79359: LD_VAR 0 5
79363: PPUSH
79364: CALL_OW 488
79368: AND
79369: IFFALSE 79393
// CutTreeXYR ( unit , x , y , 12 ) ;
79371: LD_VAR 0 2
79375: PPUSH
79376: LD_VAR 0 4
79380: PPUSH
79381: LD_VAR 0 5
79385: PPUSH
79386: LD_INT 12
79388: PPUSH
79389: CALL 79398 0 4
// end ;
79393: LD_VAR 0 6
79397: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
79398: LD_INT 0
79400: PPUSH
79401: PPUSH
79402: PPUSH
79403: PPUSH
79404: PPUSH
79405: PPUSH
79406: PPUSH
79407: PPUSH
79408: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
79409: LD_VAR 0 1
79413: NOT
79414: PUSH
79415: LD_VAR 0 2
79419: PPUSH
79420: LD_VAR 0 3
79424: PPUSH
79425: CALL_OW 488
79429: NOT
79430: OR
79431: PUSH
79432: LD_VAR 0 4
79436: NOT
79437: OR
79438: IFFALSE 79442
// exit ;
79440: GO 79782
// list := [ ] ;
79442: LD_ADDR_VAR 0 13
79446: PUSH
79447: EMPTY
79448: ST_TO_ADDR
// if x - r < 0 then
79449: LD_VAR 0 2
79453: PUSH
79454: LD_VAR 0 4
79458: MINUS
79459: PUSH
79460: LD_INT 0
79462: LESS
79463: IFFALSE 79475
// min_x := 0 else
79465: LD_ADDR_VAR 0 7
79469: PUSH
79470: LD_INT 0
79472: ST_TO_ADDR
79473: GO 79491
// min_x := x - r ;
79475: LD_ADDR_VAR 0 7
79479: PUSH
79480: LD_VAR 0 2
79484: PUSH
79485: LD_VAR 0 4
79489: MINUS
79490: ST_TO_ADDR
// if y - r < 0 then
79491: LD_VAR 0 3
79495: PUSH
79496: LD_VAR 0 4
79500: MINUS
79501: PUSH
79502: LD_INT 0
79504: LESS
79505: IFFALSE 79517
// min_y := 0 else
79507: LD_ADDR_VAR 0 8
79511: PUSH
79512: LD_INT 0
79514: ST_TO_ADDR
79515: GO 79533
// min_y := y - r ;
79517: LD_ADDR_VAR 0 8
79521: PUSH
79522: LD_VAR 0 3
79526: PUSH
79527: LD_VAR 0 4
79531: MINUS
79532: ST_TO_ADDR
// max_x := x + r ;
79533: LD_ADDR_VAR 0 9
79537: PUSH
79538: LD_VAR 0 2
79542: PUSH
79543: LD_VAR 0 4
79547: PLUS
79548: ST_TO_ADDR
// max_y := y + r ;
79549: LD_ADDR_VAR 0 10
79553: PUSH
79554: LD_VAR 0 3
79558: PUSH
79559: LD_VAR 0 4
79563: PLUS
79564: ST_TO_ADDR
// for _x = min_x to max_x do
79565: LD_ADDR_VAR 0 11
79569: PUSH
79570: DOUBLE
79571: LD_VAR 0 7
79575: DEC
79576: ST_TO_ADDR
79577: LD_VAR 0 9
79581: PUSH
79582: FOR_TO
79583: IFFALSE 79700
// for _y = min_y to max_y do
79585: LD_ADDR_VAR 0 12
79589: PUSH
79590: DOUBLE
79591: LD_VAR 0 8
79595: DEC
79596: ST_TO_ADDR
79597: LD_VAR 0 10
79601: PUSH
79602: FOR_TO
79603: IFFALSE 79696
// begin if not ValidHex ( _x , _y ) then
79605: LD_VAR 0 11
79609: PPUSH
79610: LD_VAR 0 12
79614: PPUSH
79615: CALL_OW 488
79619: NOT
79620: IFFALSE 79624
// continue ;
79622: GO 79602
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
79624: LD_VAR 0 11
79628: PPUSH
79629: LD_VAR 0 12
79633: PPUSH
79634: CALL_OW 351
79638: PUSH
79639: LD_VAR 0 11
79643: PPUSH
79644: LD_VAR 0 12
79648: PPUSH
79649: CALL_OW 554
79653: AND
79654: IFFALSE 79694
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
79656: LD_ADDR_VAR 0 13
79660: PUSH
79661: LD_VAR 0 13
79665: PPUSH
79666: LD_VAR 0 13
79670: PUSH
79671: LD_INT 1
79673: PLUS
79674: PPUSH
79675: LD_VAR 0 11
79679: PUSH
79680: LD_VAR 0 12
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PPUSH
79689: CALL_OW 2
79693: ST_TO_ADDR
// end ;
79694: GO 79602
79696: POP
79697: POP
79698: GO 79582
79700: POP
79701: POP
// if not list then
79702: LD_VAR 0 13
79706: NOT
79707: IFFALSE 79711
// exit ;
79709: GO 79782
// for i in list do
79711: LD_ADDR_VAR 0 6
79715: PUSH
79716: LD_VAR 0 13
79720: PUSH
79721: FOR_IN
79722: IFFALSE 79780
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
79724: LD_VAR 0 1
79728: PPUSH
79729: LD_STRING M
79731: PUSH
79732: LD_VAR 0 6
79736: PUSH
79737: LD_INT 1
79739: ARRAY
79740: PUSH
79741: LD_VAR 0 6
79745: PUSH
79746: LD_INT 2
79748: ARRAY
79749: PUSH
79750: LD_INT 0
79752: PUSH
79753: LD_INT 0
79755: PUSH
79756: LD_INT 0
79758: PUSH
79759: LD_INT 0
79761: PUSH
79762: EMPTY
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: PUSH
79771: EMPTY
79772: LIST
79773: PPUSH
79774: CALL_OW 447
79778: GO 79721
79780: POP
79781: POP
// end ;
79782: LD_VAR 0 5
79786: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
79787: LD_EXP 73
79791: NOT
79792: IFFALSE 79842
79794: GO 79796
79796: DISABLE
// begin initHack := true ;
79797: LD_ADDR_EXP 73
79801: PUSH
79802: LD_INT 1
79804: ST_TO_ADDR
// hackTanks := [ ] ;
79805: LD_ADDR_EXP 74
79809: PUSH
79810: EMPTY
79811: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
79812: LD_ADDR_EXP 75
79816: PUSH
79817: EMPTY
79818: ST_TO_ADDR
// hackLimit := 3 ;
79819: LD_ADDR_EXP 76
79823: PUSH
79824: LD_INT 3
79826: ST_TO_ADDR
// hackDist := 12 ;
79827: LD_ADDR_EXP 77
79831: PUSH
79832: LD_INT 12
79834: ST_TO_ADDR
// hackCounter := [ ] ;
79835: LD_ADDR_EXP 78
79839: PUSH
79840: EMPTY
79841: ST_TO_ADDR
// end ;
79842: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
79843: LD_EXP 73
79847: PUSH
79848: LD_INT 34
79850: PUSH
79851: LD_EXP 59
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PPUSH
79860: CALL_OW 69
79864: AND
79865: IFFALSE 80120
79867: GO 79869
79869: DISABLE
79870: LD_INT 0
79872: PPUSH
79873: PPUSH
// begin enable ;
79874: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
79875: LD_ADDR_VAR 0 1
79879: PUSH
79880: LD_INT 34
79882: PUSH
79883: LD_EXP 59
79887: PUSH
79888: EMPTY
79889: LIST
79890: LIST
79891: PPUSH
79892: CALL_OW 69
79896: PUSH
79897: FOR_IN
79898: IFFALSE 80118
// begin if not i in hackTanks then
79900: LD_VAR 0 1
79904: PUSH
79905: LD_EXP 74
79909: IN
79910: NOT
79911: IFFALSE 79994
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
79913: LD_ADDR_EXP 74
79917: PUSH
79918: LD_EXP 74
79922: PPUSH
79923: LD_EXP 74
79927: PUSH
79928: LD_INT 1
79930: PLUS
79931: PPUSH
79932: LD_VAR 0 1
79936: PPUSH
79937: CALL_OW 1
79941: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
79942: LD_ADDR_EXP 75
79946: PUSH
79947: LD_EXP 75
79951: PPUSH
79952: LD_EXP 75
79956: PUSH
79957: LD_INT 1
79959: PLUS
79960: PPUSH
79961: EMPTY
79962: PPUSH
79963: CALL_OW 1
79967: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
79968: LD_ADDR_EXP 78
79972: PUSH
79973: LD_EXP 78
79977: PPUSH
79978: LD_EXP 78
79982: PUSH
79983: LD_INT 1
79985: PLUS
79986: PPUSH
79987: EMPTY
79988: PPUSH
79989: CALL_OW 1
79993: ST_TO_ADDR
// end ; if not IsOk ( i ) then
79994: LD_VAR 0 1
79998: PPUSH
79999: CALL_OW 302
80003: NOT
80004: IFFALSE 80017
// begin HackUnlinkAll ( i ) ;
80006: LD_VAR 0 1
80010: PPUSH
80011: CALL 80123 0 1
// continue ;
80015: GO 79897
// end ; HackCheckCapturedStatus ( i ) ;
80017: LD_VAR 0 1
80021: PPUSH
80022: CALL 80566 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
80026: LD_ADDR_VAR 0 2
80030: PUSH
80031: LD_INT 81
80033: PUSH
80034: LD_VAR 0 1
80038: PPUSH
80039: CALL_OW 255
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 33
80050: PUSH
80051: LD_INT 3
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: LD_INT 91
80060: PUSH
80061: LD_VAR 0 1
80065: PUSH
80066: LD_EXP 77
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: LIST
80075: PUSH
80076: LD_INT 50
80078: PUSH
80079: EMPTY
80080: LIST
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: PPUSH
80088: CALL_OW 69
80092: ST_TO_ADDR
// if not tmp then
80093: LD_VAR 0 2
80097: NOT
80098: IFFALSE 80102
// continue ;
80100: GO 79897
// HackLink ( i , tmp ) ;
80102: LD_VAR 0 1
80106: PPUSH
80107: LD_VAR 0 2
80111: PPUSH
80112: CALL 80259 0 2
// end ;
80116: GO 79897
80118: POP
80119: POP
// end ;
80120: PPOPN 2
80122: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
80123: LD_INT 0
80125: PPUSH
80126: PPUSH
80127: PPUSH
// if not hack in hackTanks then
80128: LD_VAR 0 1
80132: PUSH
80133: LD_EXP 74
80137: IN
80138: NOT
80139: IFFALSE 80143
// exit ;
80141: GO 80254
// index := GetElementIndex ( hackTanks , hack ) ;
80143: LD_ADDR_VAR 0 4
80147: PUSH
80148: LD_EXP 74
80152: PPUSH
80153: LD_VAR 0 1
80157: PPUSH
80158: CALL 9212 0 2
80162: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
80163: LD_EXP 75
80167: PUSH
80168: LD_VAR 0 4
80172: ARRAY
80173: IFFALSE 80254
// begin for i in hackTanksCaptured [ index ] do
80175: LD_ADDR_VAR 0 3
80179: PUSH
80180: LD_EXP 75
80184: PUSH
80185: LD_VAR 0 4
80189: ARRAY
80190: PUSH
80191: FOR_IN
80192: IFFALSE 80218
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
80194: LD_VAR 0 3
80198: PUSH
80199: LD_INT 1
80201: ARRAY
80202: PPUSH
80203: LD_VAR 0 3
80207: PUSH
80208: LD_INT 2
80210: ARRAY
80211: PPUSH
80212: CALL_OW 235
80216: GO 80191
80218: POP
80219: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
80220: LD_ADDR_EXP 75
80224: PUSH
80225: LD_EXP 75
80229: PPUSH
80230: LD_VAR 0 4
80234: PPUSH
80235: EMPTY
80236: PPUSH
80237: CALL_OW 1
80241: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
80242: LD_VAR 0 1
80246: PPUSH
80247: LD_INT 0
80249: PPUSH
80250: CALL_OW 505
// end ; end ;
80254: LD_VAR 0 2
80258: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
80259: LD_INT 0
80261: PPUSH
80262: PPUSH
80263: PPUSH
// if not hack in hackTanks or not vehicles then
80264: LD_VAR 0 1
80268: PUSH
80269: LD_EXP 74
80273: IN
80274: NOT
80275: PUSH
80276: LD_VAR 0 2
80280: NOT
80281: OR
80282: IFFALSE 80286
// exit ;
80284: GO 80561
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
80286: LD_ADDR_VAR 0 2
80290: PUSH
80291: LD_VAR 0 1
80295: PPUSH
80296: LD_VAR 0 2
80300: PPUSH
80301: LD_INT 1
80303: PPUSH
80304: LD_INT 1
80306: PPUSH
80307: CALL 9862 0 4
80311: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
80312: LD_ADDR_VAR 0 5
80316: PUSH
80317: LD_EXP 74
80321: PPUSH
80322: LD_VAR 0 1
80326: PPUSH
80327: CALL 9212 0 2
80331: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
80332: LD_EXP 75
80336: PUSH
80337: LD_VAR 0 5
80341: ARRAY
80342: PUSH
80343: LD_EXP 76
80347: LESS
80348: IFFALSE 80537
// begin for i := 1 to vehicles do
80350: LD_ADDR_VAR 0 4
80354: PUSH
80355: DOUBLE
80356: LD_INT 1
80358: DEC
80359: ST_TO_ADDR
80360: LD_VAR 0 2
80364: PUSH
80365: FOR_TO
80366: IFFALSE 80535
// begin if hackTanksCaptured [ index ] = hackLimit then
80368: LD_EXP 75
80372: PUSH
80373: LD_VAR 0 5
80377: ARRAY
80378: PUSH
80379: LD_EXP 76
80383: EQUAL
80384: IFFALSE 80388
// break ;
80386: GO 80535
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
80388: LD_ADDR_EXP 78
80392: PUSH
80393: LD_EXP 78
80397: PPUSH
80398: LD_VAR 0 5
80402: PPUSH
80403: LD_EXP 78
80407: PUSH
80408: LD_VAR 0 5
80412: ARRAY
80413: PUSH
80414: LD_INT 1
80416: PLUS
80417: PPUSH
80418: CALL_OW 1
80422: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
80423: LD_ADDR_EXP 75
80427: PUSH
80428: LD_EXP 75
80432: PPUSH
80433: LD_VAR 0 5
80437: PUSH
80438: LD_EXP 75
80442: PUSH
80443: LD_VAR 0 5
80447: ARRAY
80448: PUSH
80449: LD_INT 1
80451: PLUS
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PPUSH
80457: LD_VAR 0 2
80461: PUSH
80462: LD_VAR 0 4
80466: ARRAY
80467: PUSH
80468: LD_VAR 0 2
80472: PUSH
80473: LD_VAR 0 4
80477: ARRAY
80478: PPUSH
80479: CALL_OW 255
80483: PUSH
80484: EMPTY
80485: LIST
80486: LIST
80487: PPUSH
80488: CALL 9427 0 3
80492: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
80493: LD_VAR 0 2
80497: PUSH
80498: LD_VAR 0 4
80502: ARRAY
80503: PPUSH
80504: LD_VAR 0 1
80508: PPUSH
80509: CALL_OW 255
80513: PPUSH
80514: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
80518: LD_VAR 0 2
80522: PUSH
80523: LD_VAR 0 4
80527: ARRAY
80528: PPUSH
80529: CALL_OW 141
// end ;
80533: GO 80365
80535: POP
80536: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
80537: LD_VAR 0 1
80541: PPUSH
80542: LD_EXP 75
80546: PUSH
80547: LD_VAR 0 5
80551: ARRAY
80552: PUSH
80553: LD_INT 0
80555: PLUS
80556: PPUSH
80557: CALL_OW 505
// end ;
80561: LD_VAR 0 3
80565: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
80566: LD_INT 0
80568: PPUSH
80569: PPUSH
80570: PPUSH
80571: PPUSH
// if not hack in hackTanks then
80572: LD_VAR 0 1
80576: PUSH
80577: LD_EXP 74
80581: IN
80582: NOT
80583: IFFALSE 80587
// exit ;
80585: GO 80827
// index := GetElementIndex ( hackTanks , hack ) ;
80587: LD_ADDR_VAR 0 4
80591: PUSH
80592: LD_EXP 74
80596: PPUSH
80597: LD_VAR 0 1
80601: PPUSH
80602: CALL 9212 0 2
80606: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
80607: LD_ADDR_VAR 0 3
80611: PUSH
80612: DOUBLE
80613: LD_EXP 75
80617: PUSH
80618: LD_VAR 0 4
80622: ARRAY
80623: INC
80624: ST_TO_ADDR
80625: LD_INT 1
80627: PUSH
80628: FOR_DOWNTO
80629: IFFALSE 80801
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
80631: LD_ADDR_VAR 0 5
80635: PUSH
80636: LD_EXP 75
80640: PUSH
80641: LD_VAR 0 4
80645: ARRAY
80646: PUSH
80647: LD_VAR 0 3
80651: ARRAY
80652: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
80653: LD_VAR 0 5
80657: PUSH
80658: LD_INT 1
80660: ARRAY
80661: PPUSH
80662: CALL_OW 302
80666: NOT
80667: PUSH
80668: LD_VAR 0 5
80672: PUSH
80673: LD_INT 1
80675: ARRAY
80676: PPUSH
80677: CALL_OW 255
80681: PUSH
80682: LD_VAR 0 1
80686: PPUSH
80687: CALL_OW 255
80691: NONEQUAL
80692: OR
80693: IFFALSE 80799
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
80695: LD_VAR 0 5
80699: PUSH
80700: LD_INT 1
80702: ARRAY
80703: PPUSH
80704: CALL_OW 305
80708: PUSH
80709: LD_VAR 0 5
80713: PUSH
80714: LD_INT 1
80716: ARRAY
80717: PPUSH
80718: CALL_OW 255
80722: PUSH
80723: LD_VAR 0 1
80727: PPUSH
80728: CALL_OW 255
80732: EQUAL
80733: AND
80734: IFFALSE 80758
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
80736: LD_VAR 0 5
80740: PUSH
80741: LD_INT 1
80743: ARRAY
80744: PPUSH
80745: LD_VAR 0 5
80749: PUSH
80750: LD_INT 2
80752: ARRAY
80753: PPUSH
80754: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
80758: LD_ADDR_EXP 75
80762: PUSH
80763: LD_EXP 75
80767: PPUSH
80768: LD_VAR 0 4
80772: PPUSH
80773: LD_EXP 75
80777: PUSH
80778: LD_VAR 0 4
80782: ARRAY
80783: PPUSH
80784: LD_VAR 0 3
80788: PPUSH
80789: CALL_OW 3
80793: PPUSH
80794: CALL_OW 1
80798: ST_TO_ADDR
// end ; end ;
80799: GO 80628
80801: POP
80802: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
80803: LD_VAR 0 1
80807: PPUSH
80808: LD_EXP 75
80812: PUSH
80813: LD_VAR 0 4
80817: ARRAY
80818: PUSH
80819: LD_INT 0
80821: PLUS
80822: PPUSH
80823: CALL_OW 505
// end ;
80827: LD_VAR 0 2
80831: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
80832: LD_INT 0
80834: PPUSH
80835: PPUSH
80836: PPUSH
80837: PPUSH
// if not hack in hackTanks then
80838: LD_VAR 0 1
80842: PUSH
80843: LD_EXP 74
80847: IN
80848: NOT
80849: IFFALSE 80853
// exit ;
80851: GO 80938
// index := GetElementIndex ( hackTanks , hack ) ;
80853: LD_ADDR_VAR 0 5
80857: PUSH
80858: LD_EXP 74
80862: PPUSH
80863: LD_VAR 0 1
80867: PPUSH
80868: CALL 9212 0 2
80872: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
80873: LD_ADDR_VAR 0 4
80877: PUSH
80878: DOUBLE
80879: LD_INT 1
80881: DEC
80882: ST_TO_ADDR
80883: LD_EXP 75
80887: PUSH
80888: LD_VAR 0 5
80892: ARRAY
80893: PUSH
80894: FOR_TO
80895: IFFALSE 80936
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
80897: LD_EXP 75
80901: PUSH
80902: LD_VAR 0 5
80906: ARRAY
80907: PUSH
80908: LD_VAR 0 4
80912: ARRAY
80913: PUSH
80914: LD_INT 1
80916: ARRAY
80917: PUSH
80918: LD_VAR 0 2
80922: EQUAL
80923: IFFALSE 80934
// KillUnit ( vehicle ) ;
80925: LD_VAR 0 2
80929: PPUSH
80930: CALL_OW 66
80934: GO 80894
80936: POP
80937: POP
// end ;
80938: LD_VAR 0 3
80942: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
80943: LD_EXP 79
80947: NOT
80948: IFFALSE 80983
80950: GO 80952
80952: DISABLE
// begin initMiner := true ;
80953: LD_ADDR_EXP 79
80957: PUSH
80958: LD_INT 1
80960: ST_TO_ADDR
// minersList := [ ] ;
80961: LD_ADDR_EXP 80
80965: PUSH
80966: EMPTY
80967: ST_TO_ADDR
// minerMinesList := [ ] ;
80968: LD_ADDR_EXP 81
80972: PUSH
80973: EMPTY
80974: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
80975: LD_ADDR_EXP 82
80979: PUSH
80980: LD_INT 5
80982: ST_TO_ADDR
// end ;
80983: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
80984: LD_EXP 79
80988: PUSH
80989: LD_INT 34
80991: PUSH
80992: LD_EXP 64
80996: PUSH
80997: EMPTY
80998: LIST
80999: LIST
81000: PPUSH
81001: CALL_OW 69
81005: AND
81006: IFFALSE 81469
81008: GO 81010
81010: DISABLE
81011: LD_INT 0
81013: PPUSH
81014: PPUSH
81015: PPUSH
81016: PPUSH
// begin enable ;
81017: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
81018: LD_ADDR_VAR 0 1
81022: PUSH
81023: LD_INT 34
81025: PUSH
81026: LD_EXP 64
81030: PUSH
81031: EMPTY
81032: LIST
81033: LIST
81034: PPUSH
81035: CALL_OW 69
81039: PUSH
81040: FOR_IN
81041: IFFALSE 81113
// begin if not i in minersList then
81043: LD_VAR 0 1
81047: PUSH
81048: LD_EXP 80
81052: IN
81053: NOT
81054: IFFALSE 81111
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
81056: LD_ADDR_EXP 80
81060: PUSH
81061: LD_EXP 80
81065: PPUSH
81066: LD_EXP 80
81070: PUSH
81071: LD_INT 1
81073: PLUS
81074: PPUSH
81075: LD_VAR 0 1
81079: PPUSH
81080: CALL_OW 1
81084: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
81085: LD_ADDR_EXP 81
81089: PUSH
81090: LD_EXP 81
81094: PPUSH
81095: LD_EXP 81
81099: PUSH
81100: LD_INT 1
81102: PLUS
81103: PPUSH
81104: EMPTY
81105: PPUSH
81106: CALL_OW 1
81110: ST_TO_ADDR
// end end ;
81111: GO 81040
81113: POP
81114: POP
// for i := minerMinesList downto 1 do
81115: LD_ADDR_VAR 0 1
81119: PUSH
81120: DOUBLE
81121: LD_EXP 81
81125: INC
81126: ST_TO_ADDR
81127: LD_INT 1
81129: PUSH
81130: FOR_DOWNTO
81131: IFFALSE 81467
// begin if IsLive ( minersList [ i ] ) then
81133: LD_EXP 80
81137: PUSH
81138: LD_VAR 0 1
81142: ARRAY
81143: PPUSH
81144: CALL_OW 300
81148: IFFALSE 81176
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
81150: LD_EXP 80
81154: PUSH
81155: LD_VAR 0 1
81159: ARRAY
81160: PPUSH
81161: LD_EXP 81
81165: PUSH
81166: LD_VAR 0 1
81170: ARRAY
81171: PPUSH
81172: CALL_OW 505
// if not minerMinesList [ i ] then
81176: LD_EXP 81
81180: PUSH
81181: LD_VAR 0 1
81185: ARRAY
81186: NOT
81187: IFFALSE 81191
// continue ;
81189: GO 81130
// for j := minerMinesList [ i ] downto 1 do
81191: LD_ADDR_VAR 0 2
81195: PUSH
81196: DOUBLE
81197: LD_EXP 81
81201: PUSH
81202: LD_VAR 0 1
81206: ARRAY
81207: INC
81208: ST_TO_ADDR
81209: LD_INT 1
81211: PUSH
81212: FOR_DOWNTO
81213: IFFALSE 81463
// begin side := GetSide ( minersList [ i ] ) ;
81215: LD_ADDR_VAR 0 3
81219: PUSH
81220: LD_EXP 80
81224: PUSH
81225: LD_VAR 0 1
81229: ARRAY
81230: PPUSH
81231: CALL_OW 255
81235: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
81236: LD_ADDR_VAR 0 4
81240: PUSH
81241: LD_EXP 81
81245: PUSH
81246: LD_VAR 0 1
81250: ARRAY
81251: PUSH
81252: LD_VAR 0 2
81256: ARRAY
81257: PUSH
81258: LD_INT 1
81260: ARRAY
81261: PPUSH
81262: LD_EXP 81
81266: PUSH
81267: LD_VAR 0 1
81271: ARRAY
81272: PUSH
81273: LD_VAR 0 2
81277: ARRAY
81278: PUSH
81279: LD_INT 2
81281: ARRAY
81282: PPUSH
81283: CALL_OW 428
81287: ST_TO_ADDR
// if not tmp then
81288: LD_VAR 0 4
81292: NOT
81293: IFFALSE 81297
// continue ;
81295: GO 81212
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
81297: LD_VAR 0 4
81301: PUSH
81302: LD_INT 81
81304: PUSH
81305: LD_VAR 0 3
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PPUSH
81314: CALL_OW 69
81318: IN
81319: PUSH
81320: LD_EXP 81
81324: PUSH
81325: LD_VAR 0 1
81329: ARRAY
81330: PUSH
81331: LD_VAR 0 2
81335: ARRAY
81336: PUSH
81337: LD_INT 1
81339: ARRAY
81340: PPUSH
81341: LD_EXP 81
81345: PUSH
81346: LD_VAR 0 1
81350: ARRAY
81351: PUSH
81352: LD_VAR 0 2
81356: ARRAY
81357: PUSH
81358: LD_INT 2
81360: ARRAY
81361: PPUSH
81362: CALL_OW 458
81366: AND
81367: IFFALSE 81461
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
81369: LD_EXP 81
81373: PUSH
81374: LD_VAR 0 1
81378: ARRAY
81379: PUSH
81380: LD_VAR 0 2
81384: ARRAY
81385: PUSH
81386: LD_INT 1
81388: ARRAY
81389: PPUSH
81390: LD_EXP 81
81394: PUSH
81395: LD_VAR 0 1
81399: ARRAY
81400: PUSH
81401: LD_VAR 0 2
81405: ARRAY
81406: PUSH
81407: LD_INT 2
81409: ARRAY
81410: PPUSH
81411: LD_VAR 0 3
81415: PPUSH
81416: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
81420: LD_ADDR_EXP 81
81424: PUSH
81425: LD_EXP 81
81429: PPUSH
81430: LD_VAR 0 1
81434: PPUSH
81435: LD_EXP 81
81439: PUSH
81440: LD_VAR 0 1
81444: ARRAY
81445: PPUSH
81446: LD_VAR 0 2
81450: PPUSH
81451: CALL_OW 3
81455: PPUSH
81456: CALL_OW 1
81460: ST_TO_ADDR
// end ; end ;
81461: GO 81212
81463: POP
81464: POP
// end ;
81465: GO 81130
81467: POP
81468: POP
// end ;
81469: PPOPN 4
81471: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
81472: LD_INT 0
81474: PPUSH
81475: PPUSH
// result := false ;
81476: LD_ADDR_VAR 0 4
81480: PUSH
81481: LD_INT 0
81483: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
81484: LD_VAR 0 1
81488: PPUSH
81489: CALL_OW 264
81493: PUSH
81494: LD_EXP 64
81498: EQUAL
81499: NOT
81500: IFFALSE 81504
// exit ;
81502: GO 81744
// index := GetElementIndex ( minersList , unit ) ;
81504: LD_ADDR_VAR 0 5
81508: PUSH
81509: LD_EXP 80
81513: PPUSH
81514: LD_VAR 0 1
81518: PPUSH
81519: CALL 9212 0 2
81523: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
81524: LD_EXP 81
81528: PUSH
81529: LD_VAR 0 5
81533: ARRAY
81534: PUSH
81535: LD_EXP 82
81539: GREATEREQUAL
81540: IFFALSE 81544
// exit ;
81542: GO 81744
// ComMoveXY ( unit , x , y ) ;
81544: LD_VAR 0 1
81548: PPUSH
81549: LD_VAR 0 2
81553: PPUSH
81554: LD_VAR 0 3
81558: PPUSH
81559: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
81563: LD_INT 35
81565: PPUSH
81566: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
81570: LD_VAR 0 1
81574: PPUSH
81575: LD_VAR 0 2
81579: PPUSH
81580: LD_VAR 0 3
81584: PPUSH
81585: CALL 39276 0 3
81589: NOT
81590: PUSH
81591: LD_VAR 0 1
81595: PPUSH
81596: CALL_OW 314
81600: AND
81601: IFFALSE 81605
// exit ;
81603: GO 81744
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
81605: LD_VAR 0 2
81609: PPUSH
81610: LD_VAR 0 3
81614: PPUSH
81615: CALL_OW 428
81619: PUSH
81620: LD_VAR 0 1
81624: EQUAL
81625: PUSH
81626: LD_VAR 0 1
81630: PPUSH
81631: CALL_OW 314
81635: NOT
81636: AND
81637: IFFALSE 81563
// PlaySoundXY ( x , y , PlantMine ) ;
81639: LD_VAR 0 2
81643: PPUSH
81644: LD_VAR 0 3
81648: PPUSH
81649: LD_STRING PlantMine
81651: PPUSH
81652: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
81656: LD_VAR 0 2
81660: PPUSH
81661: LD_VAR 0 3
81665: PPUSH
81666: LD_VAR 0 1
81670: PPUSH
81671: CALL_OW 255
81675: PPUSH
81676: LD_INT 0
81678: PPUSH
81679: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
81683: LD_ADDR_EXP 81
81687: PUSH
81688: LD_EXP 81
81692: PPUSH
81693: LD_VAR 0 5
81697: PUSH
81698: LD_EXP 81
81702: PUSH
81703: LD_VAR 0 5
81707: ARRAY
81708: PUSH
81709: LD_INT 1
81711: PLUS
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PPUSH
81717: LD_VAR 0 2
81721: PUSH
81722: LD_VAR 0 3
81726: PUSH
81727: EMPTY
81728: LIST
81729: LIST
81730: PPUSH
81731: CALL 9427 0 3
81735: ST_TO_ADDR
// result := true ;
81736: LD_ADDR_VAR 0 4
81740: PUSH
81741: LD_INT 1
81743: ST_TO_ADDR
// end ;
81744: LD_VAR 0 4
81748: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
81749: LD_INT 0
81751: PPUSH
81752: PPUSH
81753: PPUSH
// if not unit in minersList then
81754: LD_VAR 0 1
81758: PUSH
81759: LD_EXP 80
81763: IN
81764: NOT
81765: IFFALSE 81769
// exit ;
81767: GO 82161
// index := GetElementIndex ( minersList , unit ) ;
81769: LD_ADDR_VAR 0 6
81773: PUSH
81774: LD_EXP 80
81778: PPUSH
81779: LD_VAR 0 1
81783: PPUSH
81784: CALL 9212 0 2
81788: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
81789: LD_ADDR_VAR 0 5
81793: PUSH
81794: DOUBLE
81795: LD_EXP 81
81799: PUSH
81800: LD_VAR 0 6
81804: ARRAY
81805: INC
81806: ST_TO_ADDR
81807: LD_INT 1
81809: PUSH
81810: FOR_DOWNTO
81811: IFFALSE 81972
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
81813: LD_EXP 81
81817: PUSH
81818: LD_VAR 0 6
81822: ARRAY
81823: PUSH
81824: LD_VAR 0 5
81828: ARRAY
81829: PUSH
81830: LD_INT 1
81832: ARRAY
81833: PUSH
81834: LD_VAR 0 2
81838: EQUAL
81839: PUSH
81840: LD_EXP 81
81844: PUSH
81845: LD_VAR 0 6
81849: ARRAY
81850: PUSH
81851: LD_VAR 0 5
81855: ARRAY
81856: PUSH
81857: LD_INT 2
81859: ARRAY
81860: PUSH
81861: LD_VAR 0 3
81865: EQUAL
81866: AND
81867: IFFALSE 81970
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
81869: LD_EXP 81
81873: PUSH
81874: LD_VAR 0 6
81878: ARRAY
81879: PUSH
81880: LD_VAR 0 5
81884: ARRAY
81885: PUSH
81886: LD_INT 1
81888: ARRAY
81889: PPUSH
81890: LD_EXP 81
81894: PUSH
81895: LD_VAR 0 6
81899: ARRAY
81900: PUSH
81901: LD_VAR 0 5
81905: ARRAY
81906: PUSH
81907: LD_INT 2
81909: ARRAY
81910: PPUSH
81911: LD_VAR 0 1
81915: PPUSH
81916: CALL_OW 255
81920: PPUSH
81921: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
81925: LD_ADDR_EXP 81
81929: PUSH
81930: LD_EXP 81
81934: PPUSH
81935: LD_VAR 0 6
81939: PPUSH
81940: LD_EXP 81
81944: PUSH
81945: LD_VAR 0 6
81949: ARRAY
81950: PPUSH
81951: LD_VAR 0 5
81955: PPUSH
81956: CALL_OW 3
81960: PPUSH
81961: CALL_OW 1
81965: ST_TO_ADDR
// exit ;
81966: POP
81967: POP
81968: GO 82161
// end ; end ;
81970: GO 81810
81972: POP
81973: POP
// for i := minerMinesList [ index ] downto 1 do
81974: LD_ADDR_VAR 0 5
81978: PUSH
81979: DOUBLE
81980: LD_EXP 81
81984: PUSH
81985: LD_VAR 0 6
81989: ARRAY
81990: INC
81991: ST_TO_ADDR
81992: LD_INT 1
81994: PUSH
81995: FOR_DOWNTO
81996: IFFALSE 82159
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
81998: LD_EXP 81
82002: PUSH
82003: LD_VAR 0 6
82007: ARRAY
82008: PUSH
82009: LD_VAR 0 5
82013: ARRAY
82014: PUSH
82015: LD_INT 1
82017: ARRAY
82018: PPUSH
82019: LD_EXP 81
82023: PUSH
82024: LD_VAR 0 6
82028: ARRAY
82029: PUSH
82030: LD_VAR 0 5
82034: ARRAY
82035: PUSH
82036: LD_INT 2
82038: ARRAY
82039: PPUSH
82040: LD_VAR 0 2
82044: PPUSH
82045: LD_VAR 0 3
82049: PPUSH
82050: CALL_OW 298
82054: PUSH
82055: LD_INT 6
82057: LESS
82058: IFFALSE 82157
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
82060: LD_EXP 81
82064: PUSH
82065: LD_VAR 0 6
82069: ARRAY
82070: PUSH
82071: LD_VAR 0 5
82075: ARRAY
82076: PUSH
82077: LD_INT 1
82079: ARRAY
82080: PPUSH
82081: LD_EXP 81
82085: PUSH
82086: LD_VAR 0 6
82090: ARRAY
82091: PUSH
82092: LD_VAR 0 5
82096: ARRAY
82097: PUSH
82098: LD_INT 2
82100: ARRAY
82101: PPUSH
82102: LD_VAR 0 1
82106: PPUSH
82107: CALL_OW 255
82111: PPUSH
82112: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
82116: LD_ADDR_EXP 81
82120: PUSH
82121: LD_EXP 81
82125: PPUSH
82126: LD_VAR 0 6
82130: PPUSH
82131: LD_EXP 81
82135: PUSH
82136: LD_VAR 0 6
82140: ARRAY
82141: PPUSH
82142: LD_VAR 0 5
82146: PPUSH
82147: CALL_OW 3
82151: PPUSH
82152: CALL_OW 1
82156: ST_TO_ADDR
// end ; end ;
82157: GO 81995
82159: POP
82160: POP
// end ;
82161: LD_VAR 0 4
82165: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
82166: LD_INT 0
82168: PPUSH
82169: PPUSH
82170: PPUSH
82171: PPUSH
82172: PPUSH
82173: PPUSH
82174: PPUSH
82175: PPUSH
82176: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
82177: LD_VAR 0 1
82181: PPUSH
82182: CALL_OW 264
82186: PUSH
82187: LD_EXP 64
82191: EQUAL
82192: NOT
82193: PUSH
82194: LD_VAR 0 1
82198: PUSH
82199: LD_EXP 80
82203: IN
82204: NOT
82205: OR
82206: IFFALSE 82210
// exit ;
82208: GO 82532
// index := GetElementIndex ( minersList , unit ) ;
82210: LD_ADDR_VAR 0 6
82214: PUSH
82215: LD_EXP 80
82219: PPUSH
82220: LD_VAR 0 1
82224: PPUSH
82225: CALL 9212 0 2
82229: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
82230: LD_ADDR_VAR 0 8
82234: PUSH
82235: LD_EXP 82
82239: PUSH
82240: LD_EXP 81
82244: PUSH
82245: LD_VAR 0 6
82249: ARRAY
82250: MINUS
82251: ST_TO_ADDR
// if not minesFreeAmount then
82252: LD_VAR 0 8
82256: NOT
82257: IFFALSE 82261
// exit ;
82259: GO 82532
// tmp := [ ] ;
82261: LD_ADDR_VAR 0 7
82265: PUSH
82266: EMPTY
82267: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
82268: LD_ADDR_VAR 0 5
82272: PUSH
82273: DOUBLE
82274: LD_INT 1
82276: DEC
82277: ST_TO_ADDR
82278: LD_VAR 0 8
82282: PUSH
82283: FOR_TO
82284: IFFALSE 82479
// begin _d := rand ( 0 , 5 ) ;
82286: LD_ADDR_VAR 0 11
82290: PUSH
82291: LD_INT 0
82293: PPUSH
82294: LD_INT 5
82296: PPUSH
82297: CALL_OW 12
82301: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
82302: LD_ADDR_VAR 0 12
82306: PUSH
82307: LD_INT 2
82309: PPUSH
82310: LD_INT 6
82312: PPUSH
82313: CALL_OW 12
82317: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
82318: LD_ADDR_VAR 0 9
82322: PUSH
82323: LD_VAR 0 2
82327: PPUSH
82328: LD_VAR 0 11
82332: PPUSH
82333: LD_VAR 0 12
82337: PPUSH
82338: CALL_OW 272
82342: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
82343: LD_ADDR_VAR 0 10
82347: PUSH
82348: LD_VAR 0 3
82352: PPUSH
82353: LD_VAR 0 11
82357: PPUSH
82358: LD_VAR 0 12
82362: PPUSH
82363: CALL_OW 273
82367: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
82368: LD_VAR 0 9
82372: PPUSH
82373: LD_VAR 0 10
82377: PPUSH
82378: CALL_OW 488
82382: PUSH
82383: LD_VAR 0 9
82387: PUSH
82388: LD_VAR 0 10
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_VAR 0 7
82401: IN
82402: NOT
82403: AND
82404: PUSH
82405: LD_VAR 0 9
82409: PPUSH
82410: LD_VAR 0 10
82414: PPUSH
82415: CALL_OW 458
82419: NOT
82420: AND
82421: IFFALSE 82463
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
82423: LD_ADDR_VAR 0 7
82427: PUSH
82428: LD_VAR 0 7
82432: PPUSH
82433: LD_VAR 0 7
82437: PUSH
82438: LD_INT 1
82440: PLUS
82441: PPUSH
82442: LD_VAR 0 9
82446: PUSH
82447: LD_VAR 0 10
82451: PUSH
82452: EMPTY
82453: LIST
82454: LIST
82455: PPUSH
82456: CALL_OW 1
82460: ST_TO_ADDR
82461: GO 82477
// i := i - 1 ;
82463: LD_ADDR_VAR 0 5
82467: PUSH
82468: LD_VAR 0 5
82472: PUSH
82473: LD_INT 1
82475: MINUS
82476: ST_TO_ADDR
// end ;
82477: GO 82283
82479: POP
82480: POP
// for i in tmp do
82481: LD_ADDR_VAR 0 5
82485: PUSH
82486: LD_VAR 0 7
82490: PUSH
82491: FOR_IN
82492: IFFALSE 82530
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
82494: LD_VAR 0 1
82498: PPUSH
82499: LD_VAR 0 5
82503: PUSH
82504: LD_INT 1
82506: ARRAY
82507: PPUSH
82508: LD_VAR 0 5
82512: PUSH
82513: LD_INT 2
82515: ARRAY
82516: PPUSH
82517: CALL 81472 0 3
82521: NOT
82522: IFFALSE 82528
// exit ;
82524: POP
82525: POP
82526: GO 82532
82528: GO 82491
82530: POP
82531: POP
// end ;
82532: LD_VAR 0 4
82536: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
82537: LD_INT 0
82539: PPUSH
82540: PPUSH
82541: PPUSH
82542: PPUSH
82543: PPUSH
82544: PPUSH
82545: PPUSH
// if not GetClass ( unit ) = class_sniper then
82546: LD_VAR 0 1
82550: PPUSH
82551: CALL_OW 257
82555: PUSH
82556: LD_INT 5
82558: EQUAL
82559: NOT
82560: IFFALSE 82564
// exit ;
82562: GO 82952
// dist := 8 ;
82564: LD_ADDR_VAR 0 5
82568: PUSH
82569: LD_INT 8
82571: ST_TO_ADDR
// viewRange := 12 ;
82572: LD_ADDR_VAR 0 7
82576: PUSH
82577: LD_INT 12
82579: ST_TO_ADDR
// side := GetSide ( unit ) ;
82580: LD_ADDR_VAR 0 6
82584: PUSH
82585: LD_VAR 0 1
82589: PPUSH
82590: CALL_OW 255
82594: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
82595: LD_INT 61
82597: PPUSH
82598: LD_VAR 0 6
82602: PPUSH
82603: CALL_OW 321
82607: PUSH
82608: LD_INT 2
82610: EQUAL
82611: IFFALSE 82621
// viewRange := 16 ;
82613: LD_ADDR_VAR 0 7
82617: PUSH
82618: LD_INT 16
82620: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
82621: LD_VAR 0 1
82625: PPUSH
82626: LD_VAR 0 2
82630: PPUSH
82631: LD_VAR 0 3
82635: PPUSH
82636: CALL_OW 297
82640: PUSH
82641: LD_VAR 0 5
82645: GREATER
82646: IFFALSE 82725
// begin ComMoveXY ( unit , x , y ) ;
82648: LD_VAR 0 1
82652: PPUSH
82653: LD_VAR 0 2
82657: PPUSH
82658: LD_VAR 0 3
82662: PPUSH
82663: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
82667: LD_INT 35
82669: PPUSH
82670: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
82674: LD_VAR 0 1
82678: PPUSH
82679: LD_VAR 0 2
82683: PPUSH
82684: LD_VAR 0 3
82688: PPUSH
82689: CALL 39276 0 3
82693: NOT
82694: IFFALSE 82698
// exit ;
82696: GO 82952
// until GetDistUnitXY ( unit , x , y ) < dist ;
82698: LD_VAR 0 1
82702: PPUSH
82703: LD_VAR 0 2
82707: PPUSH
82708: LD_VAR 0 3
82712: PPUSH
82713: CALL_OW 297
82717: PUSH
82718: LD_VAR 0 5
82722: LESS
82723: IFFALSE 82667
// end ; ComTurnXY ( unit , x , y ) ;
82725: LD_VAR 0 1
82729: PPUSH
82730: LD_VAR 0 2
82734: PPUSH
82735: LD_VAR 0 3
82739: PPUSH
82740: CALL_OW 118
// wait ( 5 ) ;
82744: LD_INT 5
82746: PPUSH
82747: CALL_OW 67
// _d := GetDir ( unit ) ;
82751: LD_ADDR_VAR 0 10
82755: PUSH
82756: LD_VAR 0 1
82760: PPUSH
82761: CALL_OW 254
82765: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
82766: LD_ADDR_VAR 0 8
82770: PUSH
82771: LD_VAR 0 1
82775: PPUSH
82776: CALL_OW 250
82780: PPUSH
82781: LD_VAR 0 10
82785: PPUSH
82786: LD_VAR 0 5
82790: PPUSH
82791: CALL_OW 272
82795: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
82796: LD_ADDR_VAR 0 9
82800: PUSH
82801: LD_VAR 0 1
82805: PPUSH
82806: CALL_OW 251
82810: PPUSH
82811: LD_VAR 0 10
82815: PPUSH
82816: LD_VAR 0 5
82820: PPUSH
82821: CALL_OW 273
82825: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
82826: LD_VAR 0 8
82830: PPUSH
82831: LD_VAR 0 9
82835: PPUSH
82836: CALL_OW 488
82840: NOT
82841: IFFALSE 82845
// exit ;
82843: GO 82952
// ComAnimCustom ( unit , 1 ) ;
82845: LD_VAR 0 1
82849: PPUSH
82850: LD_INT 1
82852: PPUSH
82853: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
82857: LD_VAR 0 8
82861: PPUSH
82862: LD_VAR 0 9
82866: PPUSH
82867: LD_VAR 0 6
82871: PPUSH
82872: LD_VAR 0 7
82876: PPUSH
82877: CALL_OW 330
// repeat wait ( 1 ) ;
82881: LD_INT 1
82883: PPUSH
82884: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
82888: LD_VAR 0 1
82892: PPUSH
82893: CALL_OW 316
82897: PUSH
82898: LD_VAR 0 1
82902: PPUSH
82903: CALL_OW 314
82907: OR
82908: PUSH
82909: LD_VAR 0 1
82913: PPUSH
82914: CALL_OW 302
82918: NOT
82919: OR
82920: PUSH
82921: LD_VAR 0 1
82925: PPUSH
82926: CALL_OW 301
82930: OR
82931: IFFALSE 82881
// RemoveSeeing ( _x , _y , side ) ;
82933: LD_VAR 0 8
82937: PPUSH
82938: LD_VAR 0 9
82942: PPUSH
82943: LD_VAR 0 6
82947: PPUSH
82948: CALL_OW 331
// end ; end_of_file end_of_file
82952: LD_VAR 0 4
82956: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
82957: LD_VAR 0 1
82961: PUSH
82962: LD_INT 200
82964: DOUBLE
82965: GREATEREQUAL
82966: IFFALSE 82974
82968: LD_INT 299
82970: DOUBLE
82971: LESSEQUAL
82972: IFTRUE 82976
82974: GO 83008
82976: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
82977: LD_VAR 0 1
82981: PPUSH
82982: LD_VAR 0 2
82986: PPUSH
82987: LD_VAR 0 3
82991: PPUSH
82992: LD_VAR 0 4
82996: PPUSH
82997: LD_VAR 0 5
83001: PPUSH
83002: CALL 79082 0 5
83006: GO 83085
83008: LD_INT 300
83010: DOUBLE
83011: GREATEREQUAL
83012: IFFALSE 83020
83014: LD_INT 399
83016: DOUBLE
83017: LESSEQUAL
83018: IFTRUE 83022
83020: GO 83084
83022: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
83023: LD_VAR 0 1
83027: PPUSH
83028: LD_VAR 0 2
83032: PPUSH
83033: LD_VAR 0 3
83037: PPUSH
83038: LD_VAR 0 4
83042: PPUSH
83043: LD_VAR 0 5
83047: PPUSH
83048: LD_VAR 0 6
83052: PPUSH
83053: LD_VAR 0 7
83057: PPUSH
83058: LD_VAR 0 8
83062: PPUSH
83063: LD_VAR 0 9
83067: PPUSH
83068: LD_VAR 0 10
83072: PPUSH
83073: LD_VAR 0 11
83077: PPUSH
83078: CALL 94275 0 11
83082: GO 83085
83084: POP
// end ; end_of_file
83085: PPOPN 11
83087: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
83088: LD_VAR 0 2
83092: PUSH
83093: LD_INT 100
83095: EQUAL
83096: IFFALSE 84045
// begin if not StreamModeActive then
83098: LD_EXP 83
83102: NOT
83103: IFFALSE 83113
// StreamModeActive := true ;
83105: LD_ADDR_EXP 83
83109: PUSH
83110: LD_INT 1
83112: ST_TO_ADDR
// if p3 = 0 then
83113: LD_VAR 0 3
83117: PUSH
83118: LD_INT 0
83120: EQUAL
83121: IFFALSE 83127
// InitStreamMode ;
83123: CALL 84203 0 0
// if p3 = 1 then
83127: LD_VAR 0 3
83131: PUSH
83132: LD_INT 1
83134: EQUAL
83135: IFFALSE 83145
// sRocket := true ;
83137: LD_ADDR_EXP 88
83141: PUSH
83142: LD_INT 1
83144: ST_TO_ADDR
// if p3 = 2 then
83145: LD_VAR 0 3
83149: PUSH
83150: LD_INT 2
83152: EQUAL
83153: IFFALSE 83163
// sSpeed := true ;
83155: LD_ADDR_EXP 87
83159: PUSH
83160: LD_INT 1
83162: ST_TO_ADDR
// if p3 = 3 then
83163: LD_VAR 0 3
83167: PUSH
83168: LD_INT 3
83170: EQUAL
83171: IFFALSE 83181
// sEngine := true ;
83173: LD_ADDR_EXP 89
83177: PUSH
83178: LD_INT 1
83180: ST_TO_ADDR
// if p3 = 4 then
83181: LD_VAR 0 3
83185: PUSH
83186: LD_INT 4
83188: EQUAL
83189: IFFALSE 83199
// sSpec := true ;
83191: LD_ADDR_EXP 86
83195: PUSH
83196: LD_INT 1
83198: ST_TO_ADDR
// if p3 = 5 then
83199: LD_VAR 0 3
83203: PUSH
83204: LD_INT 5
83206: EQUAL
83207: IFFALSE 83217
// sLevel := true ;
83209: LD_ADDR_EXP 90
83213: PUSH
83214: LD_INT 1
83216: ST_TO_ADDR
// if p3 = 6 then
83217: LD_VAR 0 3
83221: PUSH
83222: LD_INT 6
83224: EQUAL
83225: IFFALSE 83235
// sArmoury := true ;
83227: LD_ADDR_EXP 91
83231: PUSH
83232: LD_INT 1
83234: ST_TO_ADDR
// if p3 = 7 then
83235: LD_VAR 0 3
83239: PUSH
83240: LD_INT 7
83242: EQUAL
83243: IFFALSE 83253
// sRadar := true ;
83245: LD_ADDR_EXP 92
83249: PUSH
83250: LD_INT 1
83252: ST_TO_ADDR
// if p3 = 8 then
83253: LD_VAR 0 3
83257: PUSH
83258: LD_INT 8
83260: EQUAL
83261: IFFALSE 83271
// sBunker := true ;
83263: LD_ADDR_EXP 93
83267: PUSH
83268: LD_INT 1
83270: ST_TO_ADDR
// if p3 = 9 then
83271: LD_VAR 0 3
83275: PUSH
83276: LD_INT 9
83278: EQUAL
83279: IFFALSE 83289
// sHack := true ;
83281: LD_ADDR_EXP 94
83285: PUSH
83286: LD_INT 1
83288: ST_TO_ADDR
// if p3 = 10 then
83289: LD_VAR 0 3
83293: PUSH
83294: LD_INT 10
83296: EQUAL
83297: IFFALSE 83307
// sFire := true ;
83299: LD_ADDR_EXP 95
83303: PUSH
83304: LD_INT 1
83306: ST_TO_ADDR
// if p3 = 11 then
83307: LD_VAR 0 3
83311: PUSH
83312: LD_INT 11
83314: EQUAL
83315: IFFALSE 83325
// sRefresh := true ;
83317: LD_ADDR_EXP 96
83321: PUSH
83322: LD_INT 1
83324: ST_TO_ADDR
// if p3 = 12 then
83325: LD_VAR 0 3
83329: PUSH
83330: LD_INT 12
83332: EQUAL
83333: IFFALSE 83343
// sExp := true ;
83335: LD_ADDR_EXP 97
83339: PUSH
83340: LD_INT 1
83342: ST_TO_ADDR
// if p3 = 13 then
83343: LD_VAR 0 3
83347: PUSH
83348: LD_INT 13
83350: EQUAL
83351: IFFALSE 83361
// sDepot := true ;
83353: LD_ADDR_EXP 98
83357: PUSH
83358: LD_INT 1
83360: ST_TO_ADDR
// if p3 = 14 then
83361: LD_VAR 0 3
83365: PUSH
83366: LD_INT 14
83368: EQUAL
83369: IFFALSE 83379
// sFlag := true ;
83371: LD_ADDR_EXP 99
83375: PUSH
83376: LD_INT 1
83378: ST_TO_ADDR
// if p3 = 15 then
83379: LD_VAR 0 3
83383: PUSH
83384: LD_INT 15
83386: EQUAL
83387: IFFALSE 83397
// sKamikadze := true ;
83389: LD_ADDR_EXP 107
83393: PUSH
83394: LD_INT 1
83396: ST_TO_ADDR
// if p3 = 16 then
83397: LD_VAR 0 3
83401: PUSH
83402: LD_INT 16
83404: EQUAL
83405: IFFALSE 83415
// sTroll := true ;
83407: LD_ADDR_EXP 108
83411: PUSH
83412: LD_INT 1
83414: ST_TO_ADDR
// if p3 = 17 then
83415: LD_VAR 0 3
83419: PUSH
83420: LD_INT 17
83422: EQUAL
83423: IFFALSE 83433
// sSlow := true ;
83425: LD_ADDR_EXP 109
83429: PUSH
83430: LD_INT 1
83432: ST_TO_ADDR
// if p3 = 18 then
83433: LD_VAR 0 3
83437: PUSH
83438: LD_INT 18
83440: EQUAL
83441: IFFALSE 83451
// sLack := true ;
83443: LD_ADDR_EXP 110
83447: PUSH
83448: LD_INT 1
83450: ST_TO_ADDR
// if p3 = 19 then
83451: LD_VAR 0 3
83455: PUSH
83456: LD_INT 19
83458: EQUAL
83459: IFFALSE 83469
// sTank := true ;
83461: LD_ADDR_EXP 112
83465: PUSH
83466: LD_INT 1
83468: ST_TO_ADDR
// if p3 = 20 then
83469: LD_VAR 0 3
83473: PUSH
83474: LD_INT 20
83476: EQUAL
83477: IFFALSE 83487
// sRemote := true ;
83479: LD_ADDR_EXP 113
83483: PUSH
83484: LD_INT 1
83486: ST_TO_ADDR
// if p3 = 21 then
83487: LD_VAR 0 3
83491: PUSH
83492: LD_INT 21
83494: EQUAL
83495: IFFALSE 83505
// sPowell := true ;
83497: LD_ADDR_EXP 114
83501: PUSH
83502: LD_INT 1
83504: ST_TO_ADDR
// if p3 = 22 then
83505: LD_VAR 0 3
83509: PUSH
83510: LD_INT 22
83512: EQUAL
83513: IFFALSE 83523
// sTeleport := true ;
83515: LD_ADDR_EXP 117
83519: PUSH
83520: LD_INT 1
83522: ST_TO_ADDR
// if p3 = 23 then
83523: LD_VAR 0 3
83527: PUSH
83528: LD_INT 23
83530: EQUAL
83531: IFFALSE 83541
// sOilTower := true ;
83533: LD_ADDR_EXP 119
83537: PUSH
83538: LD_INT 1
83540: ST_TO_ADDR
// if p3 = 24 then
83541: LD_VAR 0 3
83545: PUSH
83546: LD_INT 24
83548: EQUAL
83549: IFFALSE 83559
// sShovel := true ;
83551: LD_ADDR_EXP 120
83555: PUSH
83556: LD_INT 1
83558: ST_TO_ADDR
// if p3 = 25 then
83559: LD_VAR 0 3
83563: PUSH
83564: LD_INT 25
83566: EQUAL
83567: IFFALSE 83577
// sSheik := true ;
83569: LD_ADDR_EXP 121
83573: PUSH
83574: LD_INT 1
83576: ST_TO_ADDR
// if p3 = 26 then
83577: LD_VAR 0 3
83581: PUSH
83582: LD_INT 26
83584: EQUAL
83585: IFFALSE 83595
// sEarthquake := true ;
83587: LD_ADDR_EXP 123
83591: PUSH
83592: LD_INT 1
83594: ST_TO_ADDR
// if p3 = 27 then
83595: LD_VAR 0 3
83599: PUSH
83600: LD_INT 27
83602: EQUAL
83603: IFFALSE 83613
// sAI := true ;
83605: LD_ADDR_EXP 124
83609: PUSH
83610: LD_INT 1
83612: ST_TO_ADDR
// if p3 = 28 then
83613: LD_VAR 0 3
83617: PUSH
83618: LD_INT 28
83620: EQUAL
83621: IFFALSE 83631
// sCargo := true ;
83623: LD_ADDR_EXP 127
83627: PUSH
83628: LD_INT 1
83630: ST_TO_ADDR
// if p3 = 29 then
83631: LD_VAR 0 3
83635: PUSH
83636: LD_INT 29
83638: EQUAL
83639: IFFALSE 83649
// sDLaser := true ;
83641: LD_ADDR_EXP 128
83645: PUSH
83646: LD_INT 1
83648: ST_TO_ADDR
// if p3 = 30 then
83649: LD_VAR 0 3
83653: PUSH
83654: LD_INT 30
83656: EQUAL
83657: IFFALSE 83667
// sExchange := true ;
83659: LD_ADDR_EXP 129
83663: PUSH
83664: LD_INT 1
83666: ST_TO_ADDR
// if p3 = 31 then
83667: LD_VAR 0 3
83671: PUSH
83672: LD_INT 31
83674: EQUAL
83675: IFFALSE 83685
// sFac := true ;
83677: LD_ADDR_EXP 130
83681: PUSH
83682: LD_INT 1
83684: ST_TO_ADDR
// if p3 = 32 then
83685: LD_VAR 0 3
83689: PUSH
83690: LD_INT 32
83692: EQUAL
83693: IFFALSE 83703
// sPower := true ;
83695: LD_ADDR_EXP 131
83699: PUSH
83700: LD_INT 1
83702: ST_TO_ADDR
// if p3 = 33 then
83703: LD_VAR 0 3
83707: PUSH
83708: LD_INT 33
83710: EQUAL
83711: IFFALSE 83721
// sRandom := true ;
83713: LD_ADDR_EXP 132
83717: PUSH
83718: LD_INT 1
83720: ST_TO_ADDR
// if p3 = 34 then
83721: LD_VAR 0 3
83725: PUSH
83726: LD_INT 34
83728: EQUAL
83729: IFFALSE 83739
// sShield := true ;
83731: LD_ADDR_EXP 133
83735: PUSH
83736: LD_INT 1
83738: ST_TO_ADDR
// if p3 = 35 then
83739: LD_VAR 0 3
83743: PUSH
83744: LD_INT 35
83746: EQUAL
83747: IFFALSE 83757
// sTime := true ;
83749: LD_ADDR_EXP 134
83753: PUSH
83754: LD_INT 1
83756: ST_TO_ADDR
// if p3 = 36 then
83757: LD_VAR 0 3
83761: PUSH
83762: LD_INT 36
83764: EQUAL
83765: IFFALSE 83775
// sTools := true ;
83767: LD_ADDR_EXP 135
83771: PUSH
83772: LD_INT 1
83774: ST_TO_ADDR
// if p3 = 101 then
83775: LD_VAR 0 3
83779: PUSH
83780: LD_INT 101
83782: EQUAL
83783: IFFALSE 83793
// sSold := true ;
83785: LD_ADDR_EXP 100
83789: PUSH
83790: LD_INT 1
83792: ST_TO_ADDR
// if p3 = 102 then
83793: LD_VAR 0 3
83797: PUSH
83798: LD_INT 102
83800: EQUAL
83801: IFFALSE 83811
// sDiff := true ;
83803: LD_ADDR_EXP 101
83807: PUSH
83808: LD_INT 1
83810: ST_TO_ADDR
// if p3 = 103 then
83811: LD_VAR 0 3
83815: PUSH
83816: LD_INT 103
83818: EQUAL
83819: IFFALSE 83829
// sFog := true ;
83821: LD_ADDR_EXP 104
83825: PUSH
83826: LD_INT 1
83828: ST_TO_ADDR
// if p3 = 104 then
83829: LD_VAR 0 3
83833: PUSH
83834: LD_INT 104
83836: EQUAL
83837: IFFALSE 83847
// sReset := true ;
83839: LD_ADDR_EXP 105
83843: PUSH
83844: LD_INT 1
83846: ST_TO_ADDR
// if p3 = 105 then
83847: LD_VAR 0 3
83851: PUSH
83852: LD_INT 105
83854: EQUAL
83855: IFFALSE 83865
// sSun := true ;
83857: LD_ADDR_EXP 106
83861: PUSH
83862: LD_INT 1
83864: ST_TO_ADDR
// if p3 = 106 then
83865: LD_VAR 0 3
83869: PUSH
83870: LD_INT 106
83872: EQUAL
83873: IFFALSE 83883
// sTiger := true ;
83875: LD_ADDR_EXP 102
83879: PUSH
83880: LD_INT 1
83882: ST_TO_ADDR
// if p3 = 107 then
83883: LD_VAR 0 3
83887: PUSH
83888: LD_INT 107
83890: EQUAL
83891: IFFALSE 83901
// sBomb := true ;
83893: LD_ADDR_EXP 103
83897: PUSH
83898: LD_INT 1
83900: ST_TO_ADDR
// if p3 = 108 then
83901: LD_VAR 0 3
83905: PUSH
83906: LD_INT 108
83908: EQUAL
83909: IFFALSE 83919
// sWound := true ;
83911: LD_ADDR_EXP 111
83915: PUSH
83916: LD_INT 1
83918: ST_TO_ADDR
// if p3 = 109 then
83919: LD_VAR 0 3
83923: PUSH
83924: LD_INT 109
83926: EQUAL
83927: IFFALSE 83937
// sBetray := true ;
83929: LD_ADDR_EXP 115
83933: PUSH
83934: LD_INT 1
83936: ST_TO_ADDR
// if p3 = 110 then
83937: LD_VAR 0 3
83941: PUSH
83942: LD_INT 110
83944: EQUAL
83945: IFFALSE 83955
// sContamin := true ;
83947: LD_ADDR_EXP 116
83951: PUSH
83952: LD_INT 1
83954: ST_TO_ADDR
// if p3 = 111 then
83955: LD_VAR 0 3
83959: PUSH
83960: LD_INT 111
83962: EQUAL
83963: IFFALSE 83973
// sOil := true ;
83965: LD_ADDR_EXP 118
83969: PUSH
83970: LD_INT 1
83972: ST_TO_ADDR
// if p3 = 112 then
83973: LD_VAR 0 3
83977: PUSH
83978: LD_INT 112
83980: EQUAL
83981: IFFALSE 83991
// sStu := true ;
83983: LD_ADDR_EXP 122
83987: PUSH
83988: LD_INT 1
83990: ST_TO_ADDR
// if p3 = 113 then
83991: LD_VAR 0 3
83995: PUSH
83996: LD_INT 113
83998: EQUAL
83999: IFFALSE 84009
// sBazooka := true ;
84001: LD_ADDR_EXP 125
84005: PUSH
84006: LD_INT 1
84008: ST_TO_ADDR
// if p3 = 114 then
84009: LD_VAR 0 3
84013: PUSH
84014: LD_INT 114
84016: EQUAL
84017: IFFALSE 84027
// sMortar := true ;
84019: LD_ADDR_EXP 126
84023: PUSH
84024: LD_INT 1
84026: ST_TO_ADDR
// if p3 = 115 then
84027: LD_VAR 0 3
84031: PUSH
84032: LD_INT 115
84034: EQUAL
84035: IFFALSE 84045
// sRanger := true ;
84037: LD_ADDR_EXP 136
84041: PUSH
84042: LD_INT 1
84044: ST_TO_ADDR
// end ; if p2 = 101 then
84045: LD_VAR 0 2
84049: PUSH
84050: LD_INT 101
84052: EQUAL
84053: IFFALSE 84181
// begin case p3 of 1 :
84055: LD_VAR 0 3
84059: PUSH
84060: LD_INT 1
84062: DOUBLE
84063: EQUAL
84064: IFTRUE 84068
84066: GO 84075
84068: POP
// hHackUnlimitedResources ; 2 :
84069: CALL 95216 0 0
84073: GO 84181
84075: LD_INT 2
84077: DOUBLE
84078: EQUAL
84079: IFTRUE 84083
84081: GO 84090
84083: POP
// hHackSetLevel10 ; 3 :
84084: CALL 95349 0 0
84088: GO 84181
84090: LD_INT 3
84092: DOUBLE
84093: EQUAL
84094: IFTRUE 84098
84096: GO 84105
84098: POP
// hHackSetLevel10YourUnits ; 4 :
84099: CALL 95434 0 0
84103: GO 84181
84105: LD_INT 4
84107: DOUBLE
84108: EQUAL
84109: IFTRUE 84113
84111: GO 84120
84113: POP
// hHackInvincible ; 5 :
84114: CALL 95882 0 0
84118: GO 84181
84120: LD_INT 5
84122: DOUBLE
84123: EQUAL
84124: IFTRUE 84128
84126: GO 84135
84128: POP
// hHackInvisible ; 6 :
84129: CALL 95993 0 0
84133: GO 84181
84135: LD_INT 6
84137: DOUBLE
84138: EQUAL
84139: IFTRUE 84143
84141: GO 84150
84143: POP
// hHackChangeYourSide ; 7 :
84144: CALL 96050 0 0
84148: GO 84181
84150: LD_INT 7
84152: DOUBLE
84153: EQUAL
84154: IFTRUE 84158
84156: GO 84165
84158: POP
// hHackChangeUnitSide ; 8 :
84159: CALL 96092 0 0
84163: GO 84181
84165: LD_INT 8
84167: DOUBLE
84168: EQUAL
84169: IFTRUE 84173
84171: GO 84180
84173: POP
// hHackFog ; end ;
84174: CALL 96193 0 0
84178: GO 84181
84180: POP
// end ; end ;
84181: PPOPN 6
84183: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
84184: GO 84186
84186: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
84187: LD_STRING initStreamRollete();
84189: PPUSH
84190: CALL_OW 559
// InitStreamMode ;
84194: CALL 84203 0 0
// DefineStreamItems ( ) ;
84198: CALL 84643 0 0
// end ;
84202: END
// function InitStreamMode ; begin
84203: LD_INT 0
84205: PPUSH
// streamModeActive := false ;
84206: LD_ADDR_EXP 83
84210: PUSH
84211: LD_INT 0
84213: ST_TO_ADDR
// normalCounter := 36 ;
84214: LD_ADDR_EXP 84
84218: PUSH
84219: LD_INT 36
84221: ST_TO_ADDR
// hardcoreCounter := 16 ;
84222: LD_ADDR_EXP 85
84226: PUSH
84227: LD_INT 16
84229: ST_TO_ADDR
// sRocket := false ;
84230: LD_ADDR_EXP 88
84234: PUSH
84235: LD_INT 0
84237: ST_TO_ADDR
// sSpeed := false ;
84238: LD_ADDR_EXP 87
84242: PUSH
84243: LD_INT 0
84245: ST_TO_ADDR
// sEngine := false ;
84246: LD_ADDR_EXP 89
84250: PUSH
84251: LD_INT 0
84253: ST_TO_ADDR
// sSpec := false ;
84254: LD_ADDR_EXP 86
84258: PUSH
84259: LD_INT 0
84261: ST_TO_ADDR
// sLevel := false ;
84262: LD_ADDR_EXP 90
84266: PUSH
84267: LD_INT 0
84269: ST_TO_ADDR
// sArmoury := false ;
84270: LD_ADDR_EXP 91
84274: PUSH
84275: LD_INT 0
84277: ST_TO_ADDR
// sRadar := false ;
84278: LD_ADDR_EXP 92
84282: PUSH
84283: LD_INT 0
84285: ST_TO_ADDR
// sBunker := false ;
84286: LD_ADDR_EXP 93
84290: PUSH
84291: LD_INT 0
84293: ST_TO_ADDR
// sHack := false ;
84294: LD_ADDR_EXP 94
84298: PUSH
84299: LD_INT 0
84301: ST_TO_ADDR
// sFire := false ;
84302: LD_ADDR_EXP 95
84306: PUSH
84307: LD_INT 0
84309: ST_TO_ADDR
// sRefresh := false ;
84310: LD_ADDR_EXP 96
84314: PUSH
84315: LD_INT 0
84317: ST_TO_ADDR
// sExp := false ;
84318: LD_ADDR_EXP 97
84322: PUSH
84323: LD_INT 0
84325: ST_TO_ADDR
// sDepot := false ;
84326: LD_ADDR_EXP 98
84330: PUSH
84331: LD_INT 0
84333: ST_TO_ADDR
// sFlag := false ;
84334: LD_ADDR_EXP 99
84338: PUSH
84339: LD_INT 0
84341: ST_TO_ADDR
// sKamikadze := false ;
84342: LD_ADDR_EXP 107
84346: PUSH
84347: LD_INT 0
84349: ST_TO_ADDR
// sTroll := false ;
84350: LD_ADDR_EXP 108
84354: PUSH
84355: LD_INT 0
84357: ST_TO_ADDR
// sSlow := false ;
84358: LD_ADDR_EXP 109
84362: PUSH
84363: LD_INT 0
84365: ST_TO_ADDR
// sLack := false ;
84366: LD_ADDR_EXP 110
84370: PUSH
84371: LD_INT 0
84373: ST_TO_ADDR
// sTank := false ;
84374: LD_ADDR_EXP 112
84378: PUSH
84379: LD_INT 0
84381: ST_TO_ADDR
// sRemote := false ;
84382: LD_ADDR_EXP 113
84386: PUSH
84387: LD_INT 0
84389: ST_TO_ADDR
// sPowell := false ;
84390: LD_ADDR_EXP 114
84394: PUSH
84395: LD_INT 0
84397: ST_TO_ADDR
// sTeleport := false ;
84398: LD_ADDR_EXP 117
84402: PUSH
84403: LD_INT 0
84405: ST_TO_ADDR
// sOilTower := false ;
84406: LD_ADDR_EXP 119
84410: PUSH
84411: LD_INT 0
84413: ST_TO_ADDR
// sShovel := false ;
84414: LD_ADDR_EXP 120
84418: PUSH
84419: LD_INT 0
84421: ST_TO_ADDR
// sSheik := false ;
84422: LD_ADDR_EXP 121
84426: PUSH
84427: LD_INT 0
84429: ST_TO_ADDR
// sEarthquake := false ;
84430: LD_ADDR_EXP 123
84434: PUSH
84435: LD_INT 0
84437: ST_TO_ADDR
// sAI := false ;
84438: LD_ADDR_EXP 124
84442: PUSH
84443: LD_INT 0
84445: ST_TO_ADDR
// sCargo := false ;
84446: LD_ADDR_EXP 127
84450: PUSH
84451: LD_INT 0
84453: ST_TO_ADDR
// sDLaser := false ;
84454: LD_ADDR_EXP 128
84458: PUSH
84459: LD_INT 0
84461: ST_TO_ADDR
// sExchange := false ;
84462: LD_ADDR_EXP 129
84466: PUSH
84467: LD_INT 0
84469: ST_TO_ADDR
// sFac := false ;
84470: LD_ADDR_EXP 130
84474: PUSH
84475: LD_INT 0
84477: ST_TO_ADDR
// sPower := false ;
84478: LD_ADDR_EXP 131
84482: PUSH
84483: LD_INT 0
84485: ST_TO_ADDR
// sRandom := false ;
84486: LD_ADDR_EXP 132
84490: PUSH
84491: LD_INT 0
84493: ST_TO_ADDR
// sShield := false ;
84494: LD_ADDR_EXP 133
84498: PUSH
84499: LD_INT 0
84501: ST_TO_ADDR
// sTime := false ;
84502: LD_ADDR_EXP 134
84506: PUSH
84507: LD_INT 0
84509: ST_TO_ADDR
// sTools := false ;
84510: LD_ADDR_EXP 135
84514: PUSH
84515: LD_INT 0
84517: ST_TO_ADDR
// sSold := false ;
84518: LD_ADDR_EXP 100
84522: PUSH
84523: LD_INT 0
84525: ST_TO_ADDR
// sDiff := false ;
84526: LD_ADDR_EXP 101
84530: PUSH
84531: LD_INT 0
84533: ST_TO_ADDR
// sFog := false ;
84534: LD_ADDR_EXP 104
84538: PUSH
84539: LD_INT 0
84541: ST_TO_ADDR
// sReset := false ;
84542: LD_ADDR_EXP 105
84546: PUSH
84547: LD_INT 0
84549: ST_TO_ADDR
// sSun := false ;
84550: LD_ADDR_EXP 106
84554: PUSH
84555: LD_INT 0
84557: ST_TO_ADDR
// sTiger := false ;
84558: LD_ADDR_EXP 102
84562: PUSH
84563: LD_INT 0
84565: ST_TO_ADDR
// sBomb := false ;
84566: LD_ADDR_EXP 103
84570: PUSH
84571: LD_INT 0
84573: ST_TO_ADDR
// sWound := false ;
84574: LD_ADDR_EXP 111
84578: PUSH
84579: LD_INT 0
84581: ST_TO_ADDR
// sBetray := false ;
84582: LD_ADDR_EXP 115
84586: PUSH
84587: LD_INT 0
84589: ST_TO_ADDR
// sContamin := false ;
84590: LD_ADDR_EXP 116
84594: PUSH
84595: LD_INT 0
84597: ST_TO_ADDR
// sOil := false ;
84598: LD_ADDR_EXP 118
84602: PUSH
84603: LD_INT 0
84605: ST_TO_ADDR
// sStu := false ;
84606: LD_ADDR_EXP 122
84610: PUSH
84611: LD_INT 0
84613: ST_TO_ADDR
// sBazooka := false ;
84614: LD_ADDR_EXP 125
84618: PUSH
84619: LD_INT 0
84621: ST_TO_ADDR
// sMortar := false ;
84622: LD_ADDR_EXP 126
84626: PUSH
84627: LD_INT 0
84629: ST_TO_ADDR
// sRanger := false ;
84630: LD_ADDR_EXP 136
84634: PUSH
84635: LD_INT 0
84637: ST_TO_ADDR
// end ;
84638: LD_VAR 0 1
84642: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
84643: LD_INT 0
84645: PPUSH
84646: PPUSH
84647: PPUSH
84648: PPUSH
84649: PPUSH
// result := [ ] ;
84650: LD_ADDR_VAR 0 1
84654: PUSH
84655: EMPTY
84656: ST_TO_ADDR
// if campaign_id = 1 then
84657: LD_OWVAR 69
84661: PUSH
84662: LD_INT 1
84664: EQUAL
84665: IFFALSE 87603
// begin case mission_number of 1 :
84667: LD_OWVAR 70
84671: PUSH
84672: LD_INT 1
84674: DOUBLE
84675: EQUAL
84676: IFTRUE 84680
84678: GO 84744
84680: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
84681: LD_ADDR_VAR 0 1
84685: PUSH
84686: LD_INT 2
84688: PUSH
84689: LD_INT 4
84691: PUSH
84692: LD_INT 11
84694: PUSH
84695: LD_INT 12
84697: PUSH
84698: LD_INT 15
84700: PUSH
84701: LD_INT 16
84703: PUSH
84704: LD_INT 22
84706: PUSH
84707: LD_INT 23
84709: PUSH
84710: LD_INT 26
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: LIST
84717: LIST
84718: LIST
84719: LIST
84720: LIST
84721: LIST
84722: LIST
84723: PUSH
84724: LD_INT 101
84726: PUSH
84727: LD_INT 102
84729: PUSH
84730: LD_INT 106
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: LIST
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: ST_TO_ADDR
84742: GO 87601
84744: LD_INT 2
84746: DOUBLE
84747: EQUAL
84748: IFTRUE 84752
84750: GO 84824
84752: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
84753: LD_ADDR_VAR 0 1
84757: PUSH
84758: LD_INT 2
84760: PUSH
84761: LD_INT 4
84763: PUSH
84764: LD_INT 11
84766: PUSH
84767: LD_INT 12
84769: PUSH
84770: LD_INT 15
84772: PUSH
84773: LD_INT 16
84775: PUSH
84776: LD_INT 22
84778: PUSH
84779: LD_INT 23
84781: PUSH
84782: LD_INT 26
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: LIST
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 101
84798: PUSH
84799: LD_INT 102
84801: PUSH
84802: LD_INT 105
84804: PUSH
84805: LD_INT 106
84807: PUSH
84808: LD_INT 108
84810: PUSH
84811: EMPTY
84812: LIST
84813: LIST
84814: LIST
84815: LIST
84816: LIST
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: ST_TO_ADDR
84822: GO 87601
84824: LD_INT 3
84826: DOUBLE
84827: EQUAL
84828: IFTRUE 84832
84830: GO 84908
84832: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
84833: LD_ADDR_VAR 0 1
84837: PUSH
84838: LD_INT 2
84840: PUSH
84841: LD_INT 4
84843: PUSH
84844: LD_INT 5
84846: PUSH
84847: LD_INT 11
84849: PUSH
84850: LD_INT 12
84852: PUSH
84853: LD_INT 15
84855: PUSH
84856: LD_INT 16
84858: PUSH
84859: LD_INT 22
84861: PUSH
84862: LD_INT 26
84864: PUSH
84865: LD_INT 36
84867: PUSH
84868: EMPTY
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: PUSH
84880: LD_INT 101
84882: PUSH
84883: LD_INT 102
84885: PUSH
84886: LD_INT 105
84888: PUSH
84889: LD_INT 106
84891: PUSH
84892: LD_INT 108
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: LIST
84899: LIST
84900: LIST
84901: PUSH
84902: EMPTY
84903: LIST
84904: LIST
84905: ST_TO_ADDR
84906: GO 87601
84908: LD_INT 4
84910: DOUBLE
84911: EQUAL
84912: IFTRUE 84916
84914: GO 85000
84916: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
84917: LD_ADDR_VAR 0 1
84921: PUSH
84922: LD_INT 2
84924: PUSH
84925: LD_INT 4
84927: PUSH
84928: LD_INT 5
84930: PUSH
84931: LD_INT 8
84933: PUSH
84934: LD_INT 11
84936: PUSH
84937: LD_INT 12
84939: PUSH
84940: LD_INT 15
84942: PUSH
84943: LD_INT 16
84945: PUSH
84946: LD_INT 22
84948: PUSH
84949: LD_INT 23
84951: PUSH
84952: LD_INT 26
84954: PUSH
84955: LD_INT 36
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 101
84974: PUSH
84975: LD_INT 102
84977: PUSH
84978: LD_INT 105
84980: PUSH
84981: LD_INT 106
84983: PUSH
84984: LD_INT 108
84986: PUSH
84987: EMPTY
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: ST_TO_ADDR
84998: GO 87601
85000: LD_INT 5
85002: DOUBLE
85003: EQUAL
85004: IFTRUE 85008
85006: GO 85108
85008: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
85009: LD_ADDR_VAR 0 1
85013: PUSH
85014: LD_INT 2
85016: PUSH
85017: LD_INT 4
85019: PUSH
85020: LD_INT 5
85022: PUSH
85023: LD_INT 6
85025: PUSH
85026: LD_INT 8
85028: PUSH
85029: LD_INT 11
85031: PUSH
85032: LD_INT 12
85034: PUSH
85035: LD_INT 15
85037: PUSH
85038: LD_INT 16
85040: PUSH
85041: LD_INT 22
85043: PUSH
85044: LD_INT 23
85046: PUSH
85047: LD_INT 25
85049: PUSH
85050: LD_INT 26
85052: PUSH
85053: LD_INT 36
85055: PUSH
85056: EMPTY
85057: LIST
85058: LIST
85059: LIST
85060: LIST
85061: LIST
85062: LIST
85063: LIST
85064: LIST
85065: LIST
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: PUSH
85072: LD_INT 101
85074: PUSH
85075: LD_INT 102
85077: PUSH
85078: LD_INT 105
85080: PUSH
85081: LD_INT 106
85083: PUSH
85084: LD_INT 108
85086: PUSH
85087: LD_INT 109
85089: PUSH
85090: LD_INT 112
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: PUSH
85102: EMPTY
85103: LIST
85104: LIST
85105: ST_TO_ADDR
85106: GO 87601
85108: LD_INT 6
85110: DOUBLE
85111: EQUAL
85112: IFTRUE 85116
85114: GO 85236
85116: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
85117: LD_ADDR_VAR 0 1
85121: PUSH
85122: LD_INT 2
85124: PUSH
85125: LD_INT 4
85127: PUSH
85128: LD_INT 5
85130: PUSH
85131: LD_INT 6
85133: PUSH
85134: LD_INT 8
85136: PUSH
85137: LD_INT 11
85139: PUSH
85140: LD_INT 12
85142: PUSH
85143: LD_INT 15
85145: PUSH
85146: LD_INT 16
85148: PUSH
85149: LD_INT 20
85151: PUSH
85152: LD_INT 21
85154: PUSH
85155: LD_INT 22
85157: PUSH
85158: LD_INT 23
85160: PUSH
85161: LD_INT 25
85163: PUSH
85164: LD_INT 26
85166: PUSH
85167: LD_INT 30
85169: PUSH
85170: LD_INT 31
85172: PUSH
85173: LD_INT 32
85175: PUSH
85176: LD_INT 36
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: LIST
85183: LIST
85184: LIST
85185: LIST
85186: LIST
85187: LIST
85188: LIST
85189: LIST
85190: LIST
85191: LIST
85192: LIST
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: PUSH
85200: LD_INT 101
85202: PUSH
85203: LD_INT 102
85205: PUSH
85206: LD_INT 105
85208: PUSH
85209: LD_INT 106
85211: PUSH
85212: LD_INT 108
85214: PUSH
85215: LD_INT 109
85217: PUSH
85218: LD_INT 112
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: PUSH
85230: EMPTY
85231: LIST
85232: LIST
85233: ST_TO_ADDR
85234: GO 87601
85236: LD_INT 7
85238: DOUBLE
85239: EQUAL
85240: IFTRUE 85244
85242: GO 85344
85244: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
85245: LD_ADDR_VAR 0 1
85249: PUSH
85250: LD_INT 2
85252: PUSH
85253: LD_INT 4
85255: PUSH
85256: LD_INT 5
85258: PUSH
85259: LD_INT 7
85261: PUSH
85262: LD_INT 11
85264: PUSH
85265: LD_INT 12
85267: PUSH
85268: LD_INT 15
85270: PUSH
85271: LD_INT 16
85273: PUSH
85274: LD_INT 20
85276: PUSH
85277: LD_INT 21
85279: PUSH
85280: LD_INT 22
85282: PUSH
85283: LD_INT 23
85285: PUSH
85286: LD_INT 25
85288: PUSH
85289: LD_INT 26
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 101
85310: PUSH
85311: LD_INT 102
85313: PUSH
85314: LD_INT 103
85316: PUSH
85317: LD_INT 105
85319: PUSH
85320: LD_INT 106
85322: PUSH
85323: LD_INT 108
85325: PUSH
85326: LD_INT 112
85328: PUSH
85329: EMPTY
85330: LIST
85331: LIST
85332: LIST
85333: LIST
85334: LIST
85335: LIST
85336: LIST
85337: PUSH
85338: EMPTY
85339: LIST
85340: LIST
85341: ST_TO_ADDR
85342: GO 87601
85344: LD_INT 8
85346: DOUBLE
85347: EQUAL
85348: IFTRUE 85352
85350: GO 85480
85352: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
85353: LD_ADDR_VAR 0 1
85357: PUSH
85358: LD_INT 2
85360: PUSH
85361: LD_INT 4
85363: PUSH
85364: LD_INT 5
85366: PUSH
85367: LD_INT 6
85369: PUSH
85370: LD_INT 7
85372: PUSH
85373: LD_INT 8
85375: PUSH
85376: LD_INT 11
85378: PUSH
85379: LD_INT 12
85381: PUSH
85382: LD_INT 15
85384: PUSH
85385: LD_INT 16
85387: PUSH
85388: LD_INT 20
85390: PUSH
85391: LD_INT 21
85393: PUSH
85394: LD_INT 22
85396: PUSH
85397: LD_INT 23
85399: PUSH
85400: LD_INT 25
85402: PUSH
85403: LD_INT 26
85405: PUSH
85406: LD_INT 30
85408: PUSH
85409: LD_INT 31
85411: PUSH
85412: LD_INT 32
85414: PUSH
85415: LD_INT 36
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: LIST
85422: LIST
85423: LIST
85424: LIST
85425: LIST
85426: LIST
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 101
85442: PUSH
85443: LD_INT 102
85445: PUSH
85446: LD_INT 103
85448: PUSH
85449: LD_INT 105
85451: PUSH
85452: LD_INT 106
85454: PUSH
85455: LD_INT 108
85457: PUSH
85458: LD_INT 109
85460: PUSH
85461: LD_INT 112
85463: PUSH
85464: EMPTY
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: PUSH
85474: EMPTY
85475: LIST
85476: LIST
85477: ST_TO_ADDR
85478: GO 87601
85480: LD_INT 9
85482: DOUBLE
85483: EQUAL
85484: IFTRUE 85488
85486: GO 85624
85488: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
85489: LD_ADDR_VAR 0 1
85493: PUSH
85494: LD_INT 2
85496: PUSH
85497: LD_INT 4
85499: PUSH
85500: LD_INT 5
85502: PUSH
85503: LD_INT 6
85505: PUSH
85506: LD_INT 7
85508: PUSH
85509: LD_INT 8
85511: PUSH
85512: LD_INT 11
85514: PUSH
85515: LD_INT 12
85517: PUSH
85518: LD_INT 15
85520: PUSH
85521: LD_INT 16
85523: PUSH
85524: LD_INT 20
85526: PUSH
85527: LD_INT 21
85529: PUSH
85530: LD_INT 22
85532: PUSH
85533: LD_INT 23
85535: PUSH
85536: LD_INT 25
85538: PUSH
85539: LD_INT 26
85541: PUSH
85542: LD_INT 28
85544: PUSH
85545: LD_INT 30
85547: PUSH
85548: LD_INT 31
85550: PUSH
85551: LD_INT 32
85553: PUSH
85554: LD_INT 36
85556: PUSH
85557: EMPTY
85558: LIST
85559: LIST
85560: LIST
85561: LIST
85562: LIST
85563: LIST
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 101
85582: PUSH
85583: LD_INT 102
85585: PUSH
85586: LD_INT 103
85588: PUSH
85589: LD_INT 105
85591: PUSH
85592: LD_INT 106
85594: PUSH
85595: LD_INT 108
85597: PUSH
85598: LD_INT 109
85600: PUSH
85601: LD_INT 112
85603: PUSH
85604: LD_INT 114
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: LIST
85615: LIST
85616: LIST
85617: PUSH
85618: EMPTY
85619: LIST
85620: LIST
85621: ST_TO_ADDR
85622: GO 87601
85624: LD_INT 10
85626: DOUBLE
85627: EQUAL
85628: IFTRUE 85632
85630: GO 85816
85632: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
85633: LD_ADDR_VAR 0 1
85637: PUSH
85638: LD_INT 2
85640: PUSH
85641: LD_INT 4
85643: PUSH
85644: LD_INT 5
85646: PUSH
85647: LD_INT 6
85649: PUSH
85650: LD_INT 7
85652: PUSH
85653: LD_INT 8
85655: PUSH
85656: LD_INT 9
85658: PUSH
85659: LD_INT 10
85661: PUSH
85662: LD_INT 11
85664: PUSH
85665: LD_INT 12
85667: PUSH
85668: LD_INT 13
85670: PUSH
85671: LD_INT 14
85673: PUSH
85674: LD_INT 15
85676: PUSH
85677: LD_INT 16
85679: PUSH
85680: LD_INT 17
85682: PUSH
85683: LD_INT 18
85685: PUSH
85686: LD_INT 19
85688: PUSH
85689: LD_INT 20
85691: PUSH
85692: LD_INT 21
85694: PUSH
85695: LD_INT 22
85697: PUSH
85698: LD_INT 23
85700: PUSH
85701: LD_INT 24
85703: PUSH
85704: LD_INT 25
85706: PUSH
85707: LD_INT 26
85709: PUSH
85710: LD_INT 28
85712: PUSH
85713: LD_INT 30
85715: PUSH
85716: LD_INT 31
85718: PUSH
85719: LD_INT 32
85721: PUSH
85722: LD_INT 36
85724: PUSH
85725: EMPTY
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: LIST
85736: LIST
85737: LIST
85738: LIST
85739: LIST
85740: LIST
85741: LIST
85742: LIST
85743: LIST
85744: LIST
85745: LIST
85746: LIST
85747: LIST
85748: LIST
85749: LIST
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: PUSH
85756: LD_INT 101
85758: PUSH
85759: LD_INT 102
85761: PUSH
85762: LD_INT 103
85764: PUSH
85765: LD_INT 104
85767: PUSH
85768: LD_INT 105
85770: PUSH
85771: LD_INT 106
85773: PUSH
85774: LD_INT 107
85776: PUSH
85777: LD_INT 108
85779: PUSH
85780: LD_INT 109
85782: PUSH
85783: LD_INT 110
85785: PUSH
85786: LD_INT 111
85788: PUSH
85789: LD_INT 112
85791: PUSH
85792: LD_INT 114
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: LIST
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: PUSH
85810: EMPTY
85811: LIST
85812: LIST
85813: ST_TO_ADDR
85814: GO 87601
85816: LD_INT 11
85818: DOUBLE
85819: EQUAL
85820: IFTRUE 85824
85822: GO 86016
85824: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
85825: LD_ADDR_VAR 0 1
85829: PUSH
85830: LD_INT 2
85832: PUSH
85833: LD_INT 3
85835: PUSH
85836: LD_INT 4
85838: PUSH
85839: LD_INT 5
85841: PUSH
85842: LD_INT 6
85844: PUSH
85845: LD_INT 7
85847: PUSH
85848: LD_INT 8
85850: PUSH
85851: LD_INT 9
85853: PUSH
85854: LD_INT 10
85856: PUSH
85857: LD_INT 11
85859: PUSH
85860: LD_INT 12
85862: PUSH
85863: LD_INT 13
85865: PUSH
85866: LD_INT 14
85868: PUSH
85869: LD_INT 15
85871: PUSH
85872: LD_INT 16
85874: PUSH
85875: LD_INT 17
85877: PUSH
85878: LD_INT 18
85880: PUSH
85881: LD_INT 19
85883: PUSH
85884: LD_INT 20
85886: PUSH
85887: LD_INT 21
85889: PUSH
85890: LD_INT 22
85892: PUSH
85893: LD_INT 23
85895: PUSH
85896: LD_INT 24
85898: PUSH
85899: LD_INT 25
85901: PUSH
85902: LD_INT 26
85904: PUSH
85905: LD_INT 28
85907: PUSH
85908: LD_INT 30
85910: PUSH
85911: LD_INT 31
85913: PUSH
85914: LD_INT 32
85916: PUSH
85917: LD_INT 34
85919: PUSH
85920: LD_INT 36
85922: PUSH
85923: EMPTY
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: LIST
85945: LIST
85946: LIST
85947: LIST
85948: LIST
85949: LIST
85950: LIST
85951: LIST
85952: LIST
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 101
85958: PUSH
85959: LD_INT 102
85961: PUSH
85962: LD_INT 103
85964: PUSH
85965: LD_INT 104
85967: PUSH
85968: LD_INT 105
85970: PUSH
85971: LD_INT 106
85973: PUSH
85974: LD_INT 107
85976: PUSH
85977: LD_INT 108
85979: PUSH
85980: LD_INT 109
85982: PUSH
85983: LD_INT 110
85985: PUSH
85986: LD_INT 111
85988: PUSH
85989: LD_INT 112
85991: PUSH
85992: LD_INT 114
85994: PUSH
85995: EMPTY
85996: LIST
85997: LIST
85998: LIST
85999: LIST
86000: LIST
86001: LIST
86002: LIST
86003: LIST
86004: LIST
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: ST_TO_ADDR
86014: GO 87601
86016: LD_INT 12
86018: DOUBLE
86019: EQUAL
86020: IFTRUE 86024
86022: GO 86232
86024: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
86025: LD_ADDR_VAR 0 1
86029: PUSH
86030: LD_INT 1
86032: PUSH
86033: LD_INT 2
86035: PUSH
86036: LD_INT 3
86038: PUSH
86039: LD_INT 4
86041: PUSH
86042: LD_INT 5
86044: PUSH
86045: LD_INT 6
86047: PUSH
86048: LD_INT 7
86050: PUSH
86051: LD_INT 8
86053: PUSH
86054: LD_INT 9
86056: PUSH
86057: LD_INT 10
86059: PUSH
86060: LD_INT 11
86062: PUSH
86063: LD_INT 12
86065: PUSH
86066: LD_INT 13
86068: PUSH
86069: LD_INT 14
86071: PUSH
86072: LD_INT 15
86074: PUSH
86075: LD_INT 16
86077: PUSH
86078: LD_INT 17
86080: PUSH
86081: LD_INT 18
86083: PUSH
86084: LD_INT 19
86086: PUSH
86087: LD_INT 20
86089: PUSH
86090: LD_INT 21
86092: PUSH
86093: LD_INT 22
86095: PUSH
86096: LD_INT 23
86098: PUSH
86099: LD_INT 24
86101: PUSH
86102: LD_INT 25
86104: PUSH
86105: LD_INT 26
86107: PUSH
86108: LD_INT 27
86110: PUSH
86111: LD_INT 28
86113: PUSH
86114: LD_INT 30
86116: PUSH
86117: LD_INT 31
86119: PUSH
86120: LD_INT 32
86122: PUSH
86123: LD_INT 33
86125: PUSH
86126: LD_INT 34
86128: PUSH
86129: LD_INT 36
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 101
86170: PUSH
86171: LD_INT 102
86173: PUSH
86174: LD_INT 103
86176: PUSH
86177: LD_INT 104
86179: PUSH
86180: LD_INT 105
86182: PUSH
86183: LD_INT 106
86185: PUSH
86186: LD_INT 107
86188: PUSH
86189: LD_INT 108
86191: PUSH
86192: LD_INT 109
86194: PUSH
86195: LD_INT 110
86197: PUSH
86198: LD_INT 111
86200: PUSH
86201: LD_INT 112
86203: PUSH
86204: LD_INT 113
86206: PUSH
86207: LD_INT 114
86209: PUSH
86210: EMPTY
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: PUSH
86226: EMPTY
86227: LIST
86228: LIST
86229: ST_TO_ADDR
86230: GO 87601
86232: LD_INT 13
86234: DOUBLE
86235: EQUAL
86236: IFTRUE 86240
86238: GO 86436
86240: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
86241: LD_ADDR_VAR 0 1
86245: PUSH
86246: LD_INT 1
86248: PUSH
86249: LD_INT 2
86251: PUSH
86252: LD_INT 3
86254: PUSH
86255: LD_INT 4
86257: PUSH
86258: LD_INT 5
86260: PUSH
86261: LD_INT 8
86263: PUSH
86264: LD_INT 9
86266: PUSH
86267: LD_INT 10
86269: PUSH
86270: LD_INT 11
86272: PUSH
86273: LD_INT 12
86275: PUSH
86276: LD_INT 14
86278: PUSH
86279: LD_INT 15
86281: PUSH
86282: LD_INT 16
86284: PUSH
86285: LD_INT 17
86287: PUSH
86288: LD_INT 18
86290: PUSH
86291: LD_INT 19
86293: PUSH
86294: LD_INT 20
86296: PUSH
86297: LD_INT 21
86299: PUSH
86300: LD_INT 22
86302: PUSH
86303: LD_INT 23
86305: PUSH
86306: LD_INT 24
86308: PUSH
86309: LD_INT 25
86311: PUSH
86312: LD_INT 26
86314: PUSH
86315: LD_INT 27
86317: PUSH
86318: LD_INT 28
86320: PUSH
86321: LD_INT 30
86323: PUSH
86324: LD_INT 31
86326: PUSH
86327: LD_INT 32
86329: PUSH
86330: LD_INT 33
86332: PUSH
86333: LD_INT 34
86335: PUSH
86336: LD_INT 36
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: LIST
86343: LIST
86344: LIST
86345: LIST
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: LIST
86351: LIST
86352: LIST
86353: LIST
86354: LIST
86355: LIST
86356: LIST
86357: LIST
86358: LIST
86359: LIST
86360: LIST
86361: LIST
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: LIST
86368: LIST
86369: LIST
86370: LIST
86371: PUSH
86372: LD_INT 101
86374: PUSH
86375: LD_INT 102
86377: PUSH
86378: LD_INT 103
86380: PUSH
86381: LD_INT 104
86383: PUSH
86384: LD_INT 105
86386: PUSH
86387: LD_INT 106
86389: PUSH
86390: LD_INT 107
86392: PUSH
86393: LD_INT 108
86395: PUSH
86396: LD_INT 109
86398: PUSH
86399: LD_INT 110
86401: PUSH
86402: LD_INT 111
86404: PUSH
86405: LD_INT 112
86407: PUSH
86408: LD_INT 113
86410: PUSH
86411: LD_INT 114
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: LIST
86418: LIST
86419: LIST
86420: LIST
86421: LIST
86422: LIST
86423: LIST
86424: LIST
86425: LIST
86426: LIST
86427: LIST
86428: LIST
86429: PUSH
86430: EMPTY
86431: LIST
86432: LIST
86433: ST_TO_ADDR
86434: GO 87601
86436: LD_INT 14
86438: DOUBLE
86439: EQUAL
86440: IFTRUE 86444
86442: GO 86656
86444: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
86445: LD_ADDR_VAR 0 1
86449: PUSH
86450: LD_INT 1
86452: PUSH
86453: LD_INT 2
86455: PUSH
86456: LD_INT 3
86458: PUSH
86459: LD_INT 4
86461: PUSH
86462: LD_INT 5
86464: PUSH
86465: LD_INT 6
86467: PUSH
86468: LD_INT 7
86470: PUSH
86471: LD_INT 8
86473: PUSH
86474: LD_INT 9
86476: PUSH
86477: LD_INT 10
86479: PUSH
86480: LD_INT 11
86482: PUSH
86483: LD_INT 12
86485: PUSH
86486: LD_INT 13
86488: PUSH
86489: LD_INT 14
86491: PUSH
86492: LD_INT 15
86494: PUSH
86495: LD_INT 16
86497: PUSH
86498: LD_INT 17
86500: PUSH
86501: LD_INT 18
86503: PUSH
86504: LD_INT 19
86506: PUSH
86507: LD_INT 20
86509: PUSH
86510: LD_INT 21
86512: PUSH
86513: LD_INT 22
86515: PUSH
86516: LD_INT 23
86518: PUSH
86519: LD_INT 24
86521: PUSH
86522: LD_INT 25
86524: PUSH
86525: LD_INT 26
86527: PUSH
86528: LD_INT 27
86530: PUSH
86531: LD_INT 28
86533: PUSH
86534: LD_INT 29
86536: PUSH
86537: LD_INT 30
86539: PUSH
86540: LD_INT 31
86542: PUSH
86543: LD_INT 32
86545: PUSH
86546: LD_INT 33
86548: PUSH
86549: LD_INT 34
86551: PUSH
86552: LD_INT 36
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: LIST
86559: LIST
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: LIST
86591: PUSH
86592: LD_INT 101
86594: PUSH
86595: LD_INT 102
86597: PUSH
86598: LD_INT 103
86600: PUSH
86601: LD_INT 104
86603: PUSH
86604: LD_INT 105
86606: PUSH
86607: LD_INT 106
86609: PUSH
86610: LD_INT 107
86612: PUSH
86613: LD_INT 108
86615: PUSH
86616: LD_INT 109
86618: PUSH
86619: LD_INT 110
86621: PUSH
86622: LD_INT 111
86624: PUSH
86625: LD_INT 112
86627: PUSH
86628: LD_INT 113
86630: PUSH
86631: LD_INT 114
86633: PUSH
86634: EMPTY
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: PUSH
86650: EMPTY
86651: LIST
86652: LIST
86653: ST_TO_ADDR
86654: GO 87601
86656: LD_INT 15
86658: DOUBLE
86659: EQUAL
86660: IFTRUE 86664
86662: GO 86876
86664: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
86665: LD_ADDR_VAR 0 1
86669: PUSH
86670: LD_INT 1
86672: PUSH
86673: LD_INT 2
86675: PUSH
86676: LD_INT 3
86678: PUSH
86679: LD_INT 4
86681: PUSH
86682: LD_INT 5
86684: PUSH
86685: LD_INT 6
86687: PUSH
86688: LD_INT 7
86690: PUSH
86691: LD_INT 8
86693: PUSH
86694: LD_INT 9
86696: PUSH
86697: LD_INT 10
86699: PUSH
86700: LD_INT 11
86702: PUSH
86703: LD_INT 12
86705: PUSH
86706: LD_INT 13
86708: PUSH
86709: LD_INT 14
86711: PUSH
86712: LD_INT 15
86714: PUSH
86715: LD_INT 16
86717: PUSH
86718: LD_INT 17
86720: PUSH
86721: LD_INT 18
86723: PUSH
86724: LD_INT 19
86726: PUSH
86727: LD_INT 20
86729: PUSH
86730: LD_INT 21
86732: PUSH
86733: LD_INT 22
86735: PUSH
86736: LD_INT 23
86738: PUSH
86739: LD_INT 24
86741: PUSH
86742: LD_INT 25
86744: PUSH
86745: LD_INT 26
86747: PUSH
86748: LD_INT 27
86750: PUSH
86751: LD_INT 28
86753: PUSH
86754: LD_INT 29
86756: PUSH
86757: LD_INT 30
86759: PUSH
86760: LD_INT 31
86762: PUSH
86763: LD_INT 32
86765: PUSH
86766: LD_INT 33
86768: PUSH
86769: LD_INT 34
86771: PUSH
86772: LD_INT 36
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: LIST
86803: LIST
86804: LIST
86805: LIST
86806: LIST
86807: LIST
86808: LIST
86809: LIST
86810: LIST
86811: PUSH
86812: LD_INT 101
86814: PUSH
86815: LD_INT 102
86817: PUSH
86818: LD_INT 103
86820: PUSH
86821: LD_INT 104
86823: PUSH
86824: LD_INT 105
86826: PUSH
86827: LD_INT 106
86829: PUSH
86830: LD_INT 107
86832: PUSH
86833: LD_INT 108
86835: PUSH
86836: LD_INT 109
86838: PUSH
86839: LD_INT 110
86841: PUSH
86842: LD_INT 111
86844: PUSH
86845: LD_INT 112
86847: PUSH
86848: LD_INT 113
86850: PUSH
86851: LD_INT 114
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: PUSH
86870: EMPTY
86871: LIST
86872: LIST
86873: ST_TO_ADDR
86874: GO 87601
86876: LD_INT 16
86878: DOUBLE
86879: EQUAL
86880: IFTRUE 86884
86882: GO 87008
86884: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
86885: LD_ADDR_VAR 0 1
86889: PUSH
86890: LD_INT 2
86892: PUSH
86893: LD_INT 4
86895: PUSH
86896: LD_INT 5
86898: PUSH
86899: LD_INT 7
86901: PUSH
86902: LD_INT 11
86904: PUSH
86905: LD_INT 12
86907: PUSH
86908: LD_INT 15
86910: PUSH
86911: LD_INT 16
86913: PUSH
86914: LD_INT 20
86916: PUSH
86917: LD_INT 21
86919: PUSH
86920: LD_INT 22
86922: PUSH
86923: LD_INT 23
86925: PUSH
86926: LD_INT 25
86928: PUSH
86929: LD_INT 26
86931: PUSH
86932: LD_INT 30
86934: PUSH
86935: LD_INT 31
86937: PUSH
86938: LD_INT 32
86940: PUSH
86941: LD_INT 33
86943: PUSH
86944: LD_INT 34
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: LIST
86951: LIST
86952: LIST
86953: LIST
86954: LIST
86955: LIST
86956: LIST
86957: LIST
86958: LIST
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: LIST
86966: LIST
86967: PUSH
86968: LD_INT 101
86970: PUSH
86971: LD_INT 102
86973: PUSH
86974: LD_INT 103
86976: PUSH
86977: LD_INT 106
86979: PUSH
86980: LD_INT 108
86982: PUSH
86983: LD_INT 112
86985: PUSH
86986: LD_INT 113
86988: PUSH
86989: LD_INT 114
86991: PUSH
86992: EMPTY
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: PUSH
87002: EMPTY
87003: LIST
87004: LIST
87005: ST_TO_ADDR
87006: GO 87601
87008: LD_INT 17
87010: DOUBLE
87011: EQUAL
87012: IFTRUE 87016
87014: GO 87228
87016: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
87017: LD_ADDR_VAR 0 1
87021: PUSH
87022: LD_INT 1
87024: PUSH
87025: LD_INT 2
87027: PUSH
87028: LD_INT 3
87030: PUSH
87031: LD_INT 4
87033: PUSH
87034: LD_INT 5
87036: PUSH
87037: LD_INT 6
87039: PUSH
87040: LD_INT 7
87042: PUSH
87043: LD_INT 8
87045: PUSH
87046: LD_INT 9
87048: PUSH
87049: LD_INT 10
87051: PUSH
87052: LD_INT 11
87054: PUSH
87055: LD_INT 12
87057: PUSH
87058: LD_INT 13
87060: PUSH
87061: LD_INT 14
87063: PUSH
87064: LD_INT 15
87066: PUSH
87067: LD_INT 16
87069: PUSH
87070: LD_INT 17
87072: PUSH
87073: LD_INT 18
87075: PUSH
87076: LD_INT 19
87078: PUSH
87079: LD_INT 20
87081: PUSH
87082: LD_INT 21
87084: PUSH
87085: LD_INT 22
87087: PUSH
87088: LD_INT 23
87090: PUSH
87091: LD_INT 24
87093: PUSH
87094: LD_INT 25
87096: PUSH
87097: LD_INT 26
87099: PUSH
87100: LD_INT 27
87102: PUSH
87103: LD_INT 28
87105: PUSH
87106: LD_INT 29
87108: PUSH
87109: LD_INT 30
87111: PUSH
87112: LD_INT 31
87114: PUSH
87115: LD_INT 32
87117: PUSH
87118: LD_INT 33
87120: PUSH
87121: LD_INT 34
87123: PUSH
87124: LD_INT 36
87126: PUSH
87127: EMPTY
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: LIST
87150: LIST
87151: LIST
87152: LIST
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: PUSH
87164: LD_INT 101
87166: PUSH
87167: LD_INT 102
87169: PUSH
87170: LD_INT 103
87172: PUSH
87173: LD_INT 104
87175: PUSH
87176: LD_INT 105
87178: PUSH
87179: LD_INT 106
87181: PUSH
87182: LD_INT 107
87184: PUSH
87185: LD_INT 108
87187: PUSH
87188: LD_INT 109
87190: PUSH
87191: LD_INT 110
87193: PUSH
87194: LD_INT 111
87196: PUSH
87197: LD_INT 112
87199: PUSH
87200: LD_INT 113
87202: PUSH
87203: LD_INT 114
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: LIST
87212: LIST
87213: LIST
87214: LIST
87215: LIST
87216: LIST
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: ST_TO_ADDR
87226: GO 87601
87228: LD_INT 18
87230: DOUBLE
87231: EQUAL
87232: IFTRUE 87236
87234: GO 87372
87236: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
87237: LD_ADDR_VAR 0 1
87241: PUSH
87242: LD_INT 2
87244: PUSH
87245: LD_INT 4
87247: PUSH
87248: LD_INT 5
87250: PUSH
87251: LD_INT 7
87253: PUSH
87254: LD_INT 11
87256: PUSH
87257: LD_INT 12
87259: PUSH
87260: LD_INT 15
87262: PUSH
87263: LD_INT 16
87265: PUSH
87266: LD_INT 20
87268: PUSH
87269: LD_INT 21
87271: PUSH
87272: LD_INT 22
87274: PUSH
87275: LD_INT 23
87277: PUSH
87278: LD_INT 25
87280: PUSH
87281: LD_INT 26
87283: PUSH
87284: LD_INT 30
87286: PUSH
87287: LD_INT 31
87289: PUSH
87290: LD_INT 32
87292: PUSH
87293: LD_INT 33
87295: PUSH
87296: LD_INT 34
87298: PUSH
87299: LD_INT 35
87301: PUSH
87302: LD_INT 36
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 101
87330: PUSH
87331: LD_INT 102
87333: PUSH
87334: LD_INT 103
87336: PUSH
87337: LD_INT 106
87339: PUSH
87340: LD_INT 108
87342: PUSH
87343: LD_INT 112
87345: PUSH
87346: LD_INT 113
87348: PUSH
87349: LD_INT 114
87351: PUSH
87352: LD_INT 115
87354: PUSH
87355: EMPTY
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: LIST
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: ST_TO_ADDR
87370: GO 87601
87372: LD_INT 19
87374: DOUBLE
87375: EQUAL
87376: IFTRUE 87380
87378: GO 87600
87380: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
87381: LD_ADDR_VAR 0 1
87385: PUSH
87386: LD_INT 1
87388: PUSH
87389: LD_INT 2
87391: PUSH
87392: LD_INT 3
87394: PUSH
87395: LD_INT 4
87397: PUSH
87398: LD_INT 5
87400: PUSH
87401: LD_INT 6
87403: PUSH
87404: LD_INT 7
87406: PUSH
87407: LD_INT 8
87409: PUSH
87410: LD_INT 9
87412: PUSH
87413: LD_INT 10
87415: PUSH
87416: LD_INT 11
87418: PUSH
87419: LD_INT 12
87421: PUSH
87422: LD_INT 13
87424: PUSH
87425: LD_INT 14
87427: PUSH
87428: LD_INT 15
87430: PUSH
87431: LD_INT 16
87433: PUSH
87434: LD_INT 17
87436: PUSH
87437: LD_INT 18
87439: PUSH
87440: LD_INT 19
87442: PUSH
87443: LD_INT 20
87445: PUSH
87446: LD_INT 21
87448: PUSH
87449: LD_INT 22
87451: PUSH
87452: LD_INT 23
87454: PUSH
87455: LD_INT 24
87457: PUSH
87458: LD_INT 25
87460: PUSH
87461: LD_INT 26
87463: PUSH
87464: LD_INT 27
87466: PUSH
87467: LD_INT 28
87469: PUSH
87470: LD_INT 29
87472: PUSH
87473: LD_INT 30
87475: PUSH
87476: LD_INT 31
87478: PUSH
87479: LD_INT 32
87481: PUSH
87482: LD_INT 33
87484: PUSH
87485: LD_INT 34
87487: PUSH
87488: LD_INT 35
87490: PUSH
87491: LD_INT 36
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: LIST
87503: LIST
87504: LIST
87505: LIST
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: LIST
87511: LIST
87512: LIST
87513: LIST
87514: LIST
87515: LIST
87516: LIST
87517: LIST
87518: LIST
87519: LIST
87520: LIST
87521: LIST
87522: LIST
87523: LIST
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: PUSH
87532: LD_INT 101
87534: PUSH
87535: LD_INT 102
87537: PUSH
87538: LD_INT 103
87540: PUSH
87541: LD_INT 104
87543: PUSH
87544: LD_INT 105
87546: PUSH
87547: LD_INT 106
87549: PUSH
87550: LD_INT 107
87552: PUSH
87553: LD_INT 108
87555: PUSH
87556: LD_INT 109
87558: PUSH
87559: LD_INT 110
87561: PUSH
87562: LD_INT 111
87564: PUSH
87565: LD_INT 112
87567: PUSH
87568: LD_INT 113
87570: PUSH
87571: LD_INT 114
87573: PUSH
87574: LD_INT 115
87576: PUSH
87577: EMPTY
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: LIST
87584: LIST
87585: LIST
87586: LIST
87587: LIST
87588: LIST
87589: LIST
87590: LIST
87591: LIST
87592: LIST
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: ST_TO_ADDR
87598: GO 87601
87600: POP
// end else
87601: GO 87820
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
87603: LD_ADDR_VAR 0 1
87607: PUSH
87608: LD_INT 1
87610: PUSH
87611: LD_INT 2
87613: PUSH
87614: LD_INT 3
87616: PUSH
87617: LD_INT 4
87619: PUSH
87620: LD_INT 5
87622: PUSH
87623: LD_INT 6
87625: PUSH
87626: LD_INT 7
87628: PUSH
87629: LD_INT 8
87631: PUSH
87632: LD_INT 9
87634: PUSH
87635: LD_INT 10
87637: PUSH
87638: LD_INT 11
87640: PUSH
87641: LD_INT 12
87643: PUSH
87644: LD_INT 13
87646: PUSH
87647: LD_INT 14
87649: PUSH
87650: LD_INT 15
87652: PUSH
87653: LD_INT 16
87655: PUSH
87656: LD_INT 17
87658: PUSH
87659: LD_INT 18
87661: PUSH
87662: LD_INT 19
87664: PUSH
87665: LD_INT 20
87667: PUSH
87668: LD_INT 21
87670: PUSH
87671: LD_INT 22
87673: PUSH
87674: LD_INT 23
87676: PUSH
87677: LD_INT 24
87679: PUSH
87680: LD_INT 25
87682: PUSH
87683: LD_INT 26
87685: PUSH
87686: LD_INT 27
87688: PUSH
87689: LD_INT 28
87691: PUSH
87692: LD_INT 29
87694: PUSH
87695: LD_INT 30
87697: PUSH
87698: LD_INT 31
87700: PUSH
87701: LD_INT 32
87703: PUSH
87704: LD_INT 33
87706: PUSH
87707: LD_INT 34
87709: PUSH
87710: LD_INT 35
87712: PUSH
87713: LD_INT 36
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: LIST
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: PUSH
87754: LD_INT 101
87756: PUSH
87757: LD_INT 102
87759: PUSH
87760: LD_INT 103
87762: PUSH
87763: LD_INT 104
87765: PUSH
87766: LD_INT 105
87768: PUSH
87769: LD_INT 106
87771: PUSH
87772: LD_INT 107
87774: PUSH
87775: LD_INT 108
87777: PUSH
87778: LD_INT 109
87780: PUSH
87781: LD_INT 110
87783: PUSH
87784: LD_INT 111
87786: PUSH
87787: LD_INT 112
87789: PUSH
87790: LD_INT 113
87792: PUSH
87793: LD_INT 114
87795: PUSH
87796: LD_INT 115
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: LIST
87803: LIST
87804: LIST
87805: LIST
87806: LIST
87807: LIST
87808: LIST
87809: LIST
87810: LIST
87811: LIST
87812: LIST
87813: LIST
87814: LIST
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: ST_TO_ADDR
// if result then
87820: LD_VAR 0 1
87824: IFFALSE 88113
// begin normal :=  ;
87826: LD_ADDR_VAR 0 3
87830: PUSH
87831: LD_STRING 
87833: ST_TO_ADDR
// hardcore :=  ;
87834: LD_ADDR_VAR 0 4
87838: PUSH
87839: LD_STRING 
87841: ST_TO_ADDR
// for i = 1 to normalCounter do
87842: LD_ADDR_VAR 0 5
87846: PUSH
87847: DOUBLE
87848: LD_INT 1
87850: DEC
87851: ST_TO_ADDR
87852: LD_EXP 84
87856: PUSH
87857: FOR_TO
87858: IFFALSE 87959
// begin tmp := 0 ;
87860: LD_ADDR_VAR 0 2
87864: PUSH
87865: LD_STRING 0
87867: ST_TO_ADDR
// if result [ 1 ] then
87868: LD_VAR 0 1
87872: PUSH
87873: LD_INT 1
87875: ARRAY
87876: IFFALSE 87941
// if result [ 1 ] [ 1 ] = i then
87878: LD_VAR 0 1
87882: PUSH
87883: LD_INT 1
87885: ARRAY
87886: PUSH
87887: LD_INT 1
87889: ARRAY
87890: PUSH
87891: LD_VAR 0 5
87895: EQUAL
87896: IFFALSE 87941
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
87898: LD_ADDR_VAR 0 1
87902: PUSH
87903: LD_VAR 0 1
87907: PPUSH
87908: LD_INT 1
87910: PPUSH
87911: LD_VAR 0 1
87915: PUSH
87916: LD_INT 1
87918: ARRAY
87919: PPUSH
87920: LD_INT 1
87922: PPUSH
87923: CALL_OW 3
87927: PPUSH
87928: CALL_OW 1
87932: ST_TO_ADDR
// tmp := 1 ;
87933: LD_ADDR_VAR 0 2
87937: PUSH
87938: LD_STRING 1
87940: ST_TO_ADDR
// end ; normal := normal & tmp ;
87941: LD_ADDR_VAR 0 3
87945: PUSH
87946: LD_VAR 0 3
87950: PUSH
87951: LD_VAR 0 2
87955: STR
87956: ST_TO_ADDR
// end ;
87957: GO 87857
87959: POP
87960: POP
// for i = 1 to hardcoreCounter do
87961: LD_ADDR_VAR 0 5
87965: PUSH
87966: DOUBLE
87967: LD_INT 1
87969: DEC
87970: ST_TO_ADDR
87971: LD_EXP 85
87975: PUSH
87976: FOR_TO
87977: IFFALSE 88082
// begin tmp := 0 ;
87979: LD_ADDR_VAR 0 2
87983: PUSH
87984: LD_STRING 0
87986: ST_TO_ADDR
// if result [ 2 ] then
87987: LD_VAR 0 1
87991: PUSH
87992: LD_INT 2
87994: ARRAY
87995: IFFALSE 88064
// if result [ 2 ] [ 1 ] = 100 + i then
87997: LD_VAR 0 1
88001: PUSH
88002: LD_INT 2
88004: ARRAY
88005: PUSH
88006: LD_INT 1
88008: ARRAY
88009: PUSH
88010: LD_INT 100
88012: PUSH
88013: LD_VAR 0 5
88017: PLUS
88018: EQUAL
88019: IFFALSE 88064
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
88021: LD_ADDR_VAR 0 1
88025: PUSH
88026: LD_VAR 0 1
88030: PPUSH
88031: LD_INT 2
88033: PPUSH
88034: LD_VAR 0 1
88038: PUSH
88039: LD_INT 2
88041: ARRAY
88042: PPUSH
88043: LD_INT 1
88045: PPUSH
88046: CALL_OW 3
88050: PPUSH
88051: CALL_OW 1
88055: ST_TO_ADDR
// tmp := 1 ;
88056: LD_ADDR_VAR 0 2
88060: PUSH
88061: LD_STRING 1
88063: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
88064: LD_ADDR_VAR 0 4
88068: PUSH
88069: LD_VAR 0 4
88073: PUSH
88074: LD_VAR 0 2
88078: STR
88079: ST_TO_ADDR
// end ;
88080: GO 87976
88082: POP
88083: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
88084: LD_STRING getStreamItemsFromMission("
88086: PUSH
88087: LD_VAR 0 3
88091: STR
88092: PUSH
88093: LD_STRING ","
88095: STR
88096: PUSH
88097: LD_VAR 0 4
88101: STR
88102: PUSH
88103: LD_STRING ")
88105: STR
88106: PPUSH
88107: CALL_OW 559
// end else
88111: GO 88120
// ToLua ( getStreamItemsFromMission("","") ) ;
88113: LD_STRING getStreamItemsFromMission("","")
88115: PPUSH
88116: CALL_OW 559
// end ;
88120: LD_VAR 0 1
88124: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
88125: LD_EXP 83
88129: PUSH
88130: LD_EXP 88
88134: AND
88135: IFFALSE 88259
88137: GO 88139
88139: DISABLE
88140: LD_INT 0
88142: PPUSH
88143: PPUSH
// begin enable ;
88144: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
88145: LD_ADDR_VAR 0 2
88149: PUSH
88150: LD_INT 22
88152: PUSH
88153: LD_OWVAR 2
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 2
88164: PUSH
88165: LD_INT 34
88167: PUSH
88168: LD_INT 7
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: LD_INT 34
88177: PUSH
88178: LD_INT 45
88180: PUSH
88181: EMPTY
88182: LIST
88183: LIST
88184: PUSH
88185: LD_INT 34
88187: PUSH
88188: LD_INT 28
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 34
88197: PUSH
88198: LD_INT 47
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PPUSH
88216: CALL_OW 69
88220: ST_TO_ADDR
// if not tmp then
88221: LD_VAR 0 2
88225: NOT
88226: IFFALSE 88230
// exit ;
88228: GO 88259
// for i in tmp do
88230: LD_ADDR_VAR 0 1
88234: PUSH
88235: LD_VAR 0 2
88239: PUSH
88240: FOR_IN
88241: IFFALSE 88257
// begin SetLives ( i , 0 ) ;
88243: LD_VAR 0 1
88247: PPUSH
88248: LD_INT 0
88250: PPUSH
88251: CALL_OW 234
// end ;
88255: GO 88240
88257: POP
88258: POP
// end ;
88259: PPOPN 2
88261: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
88262: LD_EXP 83
88266: PUSH
88267: LD_EXP 89
88271: AND
88272: IFFALSE 88356
88274: GO 88276
88276: DISABLE
88277: LD_INT 0
88279: PPUSH
88280: PPUSH
// begin enable ;
88281: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
88282: LD_ADDR_VAR 0 2
88286: PUSH
88287: LD_INT 22
88289: PUSH
88290: LD_OWVAR 2
88294: PUSH
88295: EMPTY
88296: LIST
88297: LIST
88298: PUSH
88299: LD_INT 32
88301: PUSH
88302: LD_INT 3
88304: PUSH
88305: EMPTY
88306: LIST
88307: LIST
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PPUSH
88313: CALL_OW 69
88317: ST_TO_ADDR
// if not tmp then
88318: LD_VAR 0 2
88322: NOT
88323: IFFALSE 88327
// exit ;
88325: GO 88356
// for i in tmp do
88327: LD_ADDR_VAR 0 1
88331: PUSH
88332: LD_VAR 0 2
88336: PUSH
88337: FOR_IN
88338: IFFALSE 88354
// begin SetLives ( i , 0 ) ;
88340: LD_VAR 0 1
88344: PPUSH
88345: LD_INT 0
88347: PPUSH
88348: CALL_OW 234
// end ;
88352: GO 88337
88354: POP
88355: POP
// end ;
88356: PPOPN 2
88358: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
88359: LD_EXP 83
88363: PUSH
88364: LD_EXP 86
88368: AND
88369: IFFALSE 88462
88371: GO 88373
88373: DISABLE
88374: LD_INT 0
88376: PPUSH
// begin enable ;
88377: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
88378: LD_ADDR_VAR 0 1
88382: PUSH
88383: LD_INT 22
88385: PUSH
88386: LD_OWVAR 2
88390: PUSH
88391: EMPTY
88392: LIST
88393: LIST
88394: PUSH
88395: LD_INT 2
88397: PUSH
88398: LD_INT 25
88400: PUSH
88401: LD_INT 5
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 25
88410: PUSH
88411: LD_INT 9
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 25
88420: PUSH
88421: LD_INT 8
88423: PUSH
88424: EMPTY
88425: LIST
88426: LIST
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: PUSH
88434: EMPTY
88435: LIST
88436: LIST
88437: PPUSH
88438: CALL_OW 69
88442: PUSH
88443: FOR_IN
88444: IFFALSE 88460
// begin SetClass ( i , 1 ) ;
88446: LD_VAR 0 1
88450: PPUSH
88451: LD_INT 1
88453: PPUSH
88454: CALL_OW 336
// end ;
88458: GO 88443
88460: POP
88461: POP
// end ;
88462: PPOPN 1
88464: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
88465: LD_EXP 83
88469: PUSH
88470: LD_EXP 87
88474: AND
88475: PUSH
88476: LD_OWVAR 65
88480: PUSH
88481: LD_INT 7
88483: LESS
88484: AND
88485: IFFALSE 88499
88487: GO 88489
88489: DISABLE
// begin enable ;
88490: ENABLE
// game_speed := 7 ;
88491: LD_ADDR_OWVAR 65
88495: PUSH
88496: LD_INT 7
88498: ST_TO_ADDR
// end ;
88499: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
88500: LD_EXP 83
88504: PUSH
88505: LD_EXP 90
88509: AND
88510: IFFALSE 88712
88512: GO 88514
88514: DISABLE
88515: LD_INT 0
88517: PPUSH
88518: PPUSH
88519: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
88520: LD_ADDR_VAR 0 3
88524: PUSH
88525: LD_INT 81
88527: PUSH
88528: LD_OWVAR 2
88532: PUSH
88533: EMPTY
88534: LIST
88535: LIST
88536: PUSH
88537: LD_INT 21
88539: PUSH
88540: LD_INT 1
88542: PUSH
88543: EMPTY
88544: LIST
88545: LIST
88546: PUSH
88547: EMPTY
88548: LIST
88549: LIST
88550: PPUSH
88551: CALL_OW 69
88555: ST_TO_ADDR
// if not tmp then
88556: LD_VAR 0 3
88560: NOT
88561: IFFALSE 88565
// exit ;
88563: GO 88712
// if tmp > 5 then
88565: LD_VAR 0 3
88569: PUSH
88570: LD_INT 5
88572: GREATER
88573: IFFALSE 88585
// k := 5 else
88575: LD_ADDR_VAR 0 2
88579: PUSH
88580: LD_INT 5
88582: ST_TO_ADDR
88583: GO 88595
// k := tmp ;
88585: LD_ADDR_VAR 0 2
88589: PUSH
88590: LD_VAR 0 3
88594: ST_TO_ADDR
// for i := 1 to k do
88595: LD_ADDR_VAR 0 1
88599: PUSH
88600: DOUBLE
88601: LD_INT 1
88603: DEC
88604: ST_TO_ADDR
88605: LD_VAR 0 2
88609: PUSH
88610: FOR_TO
88611: IFFALSE 88710
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
88613: LD_VAR 0 3
88617: PUSH
88618: LD_VAR 0 1
88622: ARRAY
88623: PPUSH
88624: LD_VAR 0 1
88628: PUSH
88629: LD_INT 4
88631: MOD
88632: PUSH
88633: LD_INT 1
88635: PLUS
88636: PPUSH
88637: CALL_OW 259
88641: PUSH
88642: LD_INT 10
88644: LESS
88645: IFFALSE 88708
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
88647: LD_VAR 0 3
88651: PUSH
88652: LD_VAR 0 1
88656: ARRAY
88657: PPUSH
88658: LD_VAR 0 1
88662: PUSH
88663: LD_INT 4
88665: MOD
88666: PUSH
88667: LD_INT 1
88669: PLUS
88670: PPUSH
88671: LD_VAR 0 3
88675: PUSH
88676: LD_VAR 0 1
88680: ARRAY
88681: PPUSH
88682: LD_VAR 0 1
88686: PUSH
88687: LD_INT 4
88689: MOD
88690: PUSH
88691: LD_INT 1
88693: PLUS
88694: PPUSH
88695: CALL_OW 259
88699: PUSH
88700: LD_INT 1
88702: PLUS
88703: PPUSH
88704: CALL_OW 237
88708: GO 88610
88710: POP
88711: POP
// end ;
88712: PPOPN 3
88714: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
88715: LD_EXP 83
88719: PUSH
88720: LD_EXP 91
88724: AND
88725: IFFALSE 88745
88727: GO 88729
88729: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
88730: LD_INT 4
88732: PPUSH
88733: LD_OWVAR 2
88737: PPUSH
88738: LD_INT 0
88740: PPUSH
88741: CALL_OW 324
88745: END
// every 0 0$1 trigger StreamModeActive and sShovel do
88746: LD_EXP 83
88750: PUSH
88751: LD_EXP 120
88755: AND
88756: IFFALSE 88776
88758: GO 88760
88760: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
88761: LD_INT 19
88763: PPUSH
88764: LD_OWVAR 2
88768: PPUSH
88769: LD_INT 0
88771: PPUSH
88772: CALL_OW 324
88776: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
88777: LD_EXP 83
88781: PUSH
88782: LD_EXP 92
88786: AND
88787: IFFALSE 88889
88789: GO 88791
88791: DISABLE
88792: LD_INT 0
88794: PPUSH
88795: PPUSH
// begin enable ;
88796: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
88797: LD_ADDR_VAR 0 2
88801: PUSH
88802: LD_INT 22
88804: PUSH
88805: LD_OWVAR 2
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: PUSH
88814: LD_INT 2
88816: PUSH
88817: LD_INT 34
88819: PUSH
88820: LD_INT 11
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 34
88829: PUSH
88830: LD_INT 30
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: EMPTY
88838: LIST
88839: LIST
88840: LIST
88841: PUSH
88842: EMPTY
88843: LIST
88844: LIST
88845: PPUSH
88846: CALL_OW 69
88850: ST_TO_ADDR
// if not tmp then
88851: LD_VAR 0 2
88855: NOT
88856: IFFALSE 88860
// exit ;
88858: GO 88889
// for i in tmp do
88860: LD_ADDR_VAR 0 1
88864: PUSH
88865: LD_VAR 0 2
88869: PUSH
88870: FOR_IN
88871: IFFALSE 88887
// begin SetLives ( i , 0 ) ;
88873: LD_VAR 0 1
88877: PPUSH
88878: LD_INT 0
88880: PPUSH
88881: CALL_OW 234
// end ;
88885: GO 88870
88887: POP
88888: POP
// end ;
88889: PPOPN 2
88891: END
// every 0 0$1 trigger StreamModeActive and sBunker do
88892: LD_EXP 83
88896: PUSH
88897: LD_EXP 93
88901: AND
88902: IFFALSE 88922
88904: GO 88906
88906: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
88907: LD_INT 32
88909: PPUSH
88910: LD_OWVAR 2
88914: PPUSH
88915: LD_INT 0
88917: PPUSH
88918: CALL_OW 324
88922: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
88923: LD_EXP 83
88927: PUSH
88928: LD_EXP 94
88932: AND
88933: IFFALSE 89114
88935: GO 88937
88937: DISABLE
88938: LD_INT 0
88940: PPUSH
88941: PPUSH
88942: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
88943: LD_ADDR_VAR 0 2
88947: PUSH
88948: LD_INT 22
88950: PUSH
88951: LD_OWVAR 2
88955: PUSH
88956: EMPTY
88957: LIST
88958: LIST
88959: PUSH
88960: LD_INT 33
88962: PUSH
88963: LD_INT 3
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PPUSH
88974: CALL_OW 69
88978: ST_TO_ADDR
// if not tmp then
88979: LD_VAR 0 2
88983: NOT
88984: IFFALSE 88988
// exit ;
88986: GO 89114
// side := 0 ;
88988: LD_ADDR_VAR 0 3
88992: PUSH
88993: LD_INT 0
88995: ST_TO_ADDR
// for i := 1 to 8 do
88996: LD_ADDR_VAR 0 1
89000: PUSH
89001: DOUBLE
89002: LD_INT 1
89004: DEC
89005: ST_TO_ADDR
89006: LD_INT 8
89008: PUSH
89009: FOR_TO
89010: IFFALSE 89058
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
89012: LD_OWVAR 2
89016: PUSH
89017: LD_VAR 0 1
89021: NONEQUAL
89022: PUSH
89023: LD_OWVAR 2
89027: PPUSH
89028: LD_VAR 0 1
89032: PPUSH
89033: CALL_OW 81
89037: PUSH
89038: LD_INT 2
89040: EQUAL
89041: AND
89042: IFFALSE 89056
// begin side := i ;
89044: LD_ADDR_VAR 0 3
89048: PUSH
89049: LD_VAR 0 1
89053: ST_TO_ADDR
// break ;
89054: GO 89058
// end ;
89056: GO 89009
89058: POP
89059: POP
// if not side then
89060: LD_VAR 0 3
89064: NOT
89065: IFFALSE 89069
// exit ;
89067: GO 89114
// for i := 1 to tmp do
89069: LD_ADDR_VAR 0 1
89073: PUSH
89074: DOUBLE
89075: LD_INT 1
89077: DEC
89078: ST_TO_ADDR
89079: LD_VAR 0 2
89083: PUSH
89084: FOR_TO
89085: IFFALSE 89112
// if Prob ( 60 ) then
89087: LD_INT 60
89089: PPUSH
89090: CALL_OW 13
89094: IFFALSE 89110
// SetSide ( i , side ) ;
89096: LD_VAR 0 1
89100: PPUSH
89101: LD_VAR 0 3
89105: PPUSH
89106: CALL_OW 235
89110: GO 89084
89112: POP
89113: POP
// end ;
89114: PPOPN 3
89116: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
89117: LD_EXP 83
89121: PUSH
89122: LD_EXP 96
89126: AND
89127: IFFALSE 89246
89129: GO 89131
89131: DISABLE
89132: LD_INT 0
89134: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
89135: LD_ADDR_VAR 0 1
89139: PUSH
89140: LD_INT 22
89142: PUSH
89143: LD_OWVAR 2
89147: PUSH
89148: EMPTY
89149: LIST
89150: LIST
89151: PUSH
89152: LD_INT 21
89154: PUSH
89155: LD_INT 1
89157: PUSH
89158: EMPTY
89159: LIST
89160: LIST
89161: PUSH
89162: LD_INT 3
89164: PUSH
89165: LD_INT 23
89167: PUSH
89168: LD_INT 0
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: EMPTY
89176: LIST
89177: LIST
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: LIST
89183: PPUSH
89184: CALL_OW 69
89188: PUSH
89189: FOR_IN
89190: IFFALSE 89244
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
89192: LD_VAR 0 1
89196: PPUSH
89197: CALL_OW 257
89201: PUSH
89202: LD_INT 1
89204: PUSH
89205: LD_INT 2
89207: PUSH
89208: LD_INT 3
89210: PUSH
89211: LD_INT 4
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: LIST
89218: LIST
89219: IN
89220: IFFALSE 89242
// SetClass ( un , rand ( 1 , 4 ) ) ;
89222: LD_VAR 0 1
89226: PPUSH
89227: LD_INT 1
89229: PPUSH
89230: LD_INT 4
89232: PPUSH
89233: CALL_OW 12
89237: PPUSH
89238: CALL_OW 336
89242: GO 89189
89244: POP
89245: POP
// end ;
89246: PPOPN 1
89248: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
89249: LD_EXP 83
89253: PUSH
89254: LD_EXP 95
89258: AND
89259: IFFALSE 89338
89261: GO 89263
89263: DISABLE
89264: LD_INT 0
89266: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89267: LD_ADDR_VAR 0 1
89271: PUSH
89272: LD_INT 22
89274: PUSH
89275: LD_OWVAR 2
89279: PUSH
89280: EMPTY
89281: LIST
89282: LIST
89283: PUSH
89284: LD_INT 21
89286: PUSH
89287: LD_INT 3
89289: PUSH
89290: EMPTY
89291: LIST
89292: LIST
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PPUSH
89298: CALL_OW 69
89302: ST_TO_ADDR
// if not tmp then
89303: LD_VAR 0 1
89307: NOT
89308: IFFALSE 89312
// exit ;
89310: GO 89338
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
89312: LD_VAR 0 1
89316: PUSH
89317: LD_INT 1
89319: PPUSH
89320: LD_VAR 0 1
89324: PPUSH
89325: CALL_OW 12
89329: ARRAY
89330: PPUSH
89331: LD_INT 100
89333: PPUSH
89334: CALL_OW 234
// end ;
89338: PPOPN 1
89340: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
89341: LD_EXP 83
89345: PUSH
89346: LD_EXP 97
89350: AND
89351: IFFALSE 89449
89353: GO 89355
89355: DISABLE
89356: LD_INT 0
89358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89359: LD_ADDR_VAR 0 1
89363: PUSH
89364: LD_INT 22
89366: PUSH
89367: LD_OWVAR 2
89371: PUSH
89372: EMPTY
89373: LIST
89374: LIST
89375: PUSH
89376: LD_INT 21
89378: PUSH
89379: LD_INT 1
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PPUSH
89390: CALL_OW 69
89394: ST_TO_ADDR
// if not tmp then
89395: LD_VAR 0 1
89399: NOT
89400: IFFALSE 89404
// exit ;
89402: GO 89449
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
89404: LD_VAR 0 1
89408: PUSH
89409: LD_INT 1
89411: PPUSH
89412: LD_VAR 0 1
89416: PPUSH
89417: CALL_OW 12
89421: ARRAY
89422: PPUSH
89423: LD_INT 1
89425: PPUSH
89426: LD_INT 4
89428: PPUSH
89429: CALL_OW 12
89433: PPUSH
89434: LD_INT 3000
89436: PPUSH
89437: LD_INT 9000
89439: PPUSH
89440: CALL_OW 12
89444: PPUSH
89445: CALL_OW 492
// end ;
89449: PPOPN 1
89451: END
// every 0 0$1 trigger StreamModeActive and sDepot do
89452: LD_EXP 83
89456: PUSH
89457: LD_EXP 98
89461: AND
89462: IFFALSE 89482
89464: GO 89466
89466: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
89467: LD_INT 1
89469: PPUSH
89470: LD_OWVAR 2
89474: PPUSH
89475: LD_INT 0
89477: PPUSH
89478: CALL_OW 324
89482: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
89483: LD_EXP 83
89487: PUSH
89488: LD_EXP 99
89492: AND
89493: IFFALSE 89576
89495: GO 89497
89497: DISABLE
89498: LD_INT 0
89500: PPUSH
89501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
89502: LD_ADDR_VAR 0 2
89506: PUSH
89507: LD_INT 22
89509: PUSH
89510: LD_OWVAR 2
89514: PUSH
89515: EMPTY
89516: LIST
89517: LIST
89518: PUSH
89519: LD_INT 21
89521: PUSH
89522: LD_INT 3
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PPUSH
89533: CALL_OW 69
89537: ST_TO_ADDR
// if not tmp then
89538: LD_VAR 0 2
89542: NOT
89543: IFFALSE 89547
// exit ;
89545: GO 89576
// for i in tmp do
89547: LD_ADDR_VAR 0 1
89551: PUSH
89552: LD_VAR 0 2
89556: PUSH
89557: FOR_IN
89558: IFFALSE 89574
// SetBLevel ( i , 10 ) ;
89560: LD_VAR 0 1
89564: PPUSH
89565: LD_INT 10
89567: PPUSH
89568: CALL_OW 241
89572: GO 89557
89574: POP
89575: POP
// end ;
89576: PPOPN 2
89578: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
89579: LD_EXP 83
89583: PUSH
89584: LD_EXP 100
89588: AND
89589: IFFALSE 89700
89591: GO 89593
89593: DISABLE
89594: LD_INT 0
89596: PPUSH
89597: PPUSH
89598: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89599: LD_ADDR_VAR 0 3
89603: PUSH
89604: LD_INT 22
89606: PUSH
89607: LD_OWVAR 2
89611: PUSH
89612: EMPTY
89613: LIST
89614: LIST
89615: PUSH
89616: LD_INT 25
89618: PUSH
89619: LD_INT 1
89621: PUSH
89622: EMPTY
89623: LIST
89624: LIST
89625: PUSH
89626: EMPTY
89627: LIST
89628: LIST
89629: PPUSH
89630: CALL_OW 69
89634: ST_TO_ADDR
// if not tmp then
89635: LD_VAR 0 3
89639: NOT
89640: IFFALSE 89644
// exit ;
89642: GO 89700
// un := tmp [ rand ( 1 , tmp ) ] ;
89644: LD_ADDR_VAR 0 2
89648: PUSH
89649: LD_VAR 0 3
89653: PUSH
89654: LD_INT 1
89656: PPUSH
89657: LD_VAR 0 3
89661: PPUSH
89662: CALL_OW 12
89666: ARRAY
89667: ST_TO_ADDR
// if Crawls ( un ) then
89668: LD_VAR 0 2
89672: PPUSH
89673: CALL_OW 318
89677: IFFALSE 89688
// ComWalk ( un ) ;
89679: LD_VAR 0 2
89683: PPUSH
89684: CALL_OW 138
// SetClass ( un , class_sniper ) ;
89688: LD_VAR 0 2
89692: PPUSH
89693: LD_INT 5
89695: PPUSH
89696: CALL_OW 336
// end ;
89700: PPOPN 3
89702: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
89703: LD_EXP 83
89707: PUSH
89708: LD_EXP 101
89712: AND
89713: PUSH
89714: LD_OWVAR 67
89718: PUSH
89719: LD_INT 3
89721: LESS
89722: AND
89723: IFFALSE 89742
89725: GO 89727
89727: DISABLE
// Difficulty := Difficulty + 1 ;
89728: LD_ADDR_OWVAR 67
89732: PUSH
89733: LD_OWVAR 67
89737: PUSH
89738: LD_INT 1
89740: PLUS
89741: ST_TO_ADDR
89742: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
89743: LD_EXP 83
89747: PUSH
89748: LD_EXP 102
89752: AND
89753: IFFALSE 89856
89755: GO 89757
89757: DISABLE
89758: LD_INT 0
89760: PPUSH
// begin for i := 1 to 5 do
89761: LD_ADDR_VAR 0 1
89765: PUSH
89766: DOUBLE
89767: LD_INT 1
89769: DEC
89770: ST_TO_ADDR
89771: LD_INT 5
89773: PUSH
89774: FOR_TO
89775: IFFALSE 89854
// begin uc_nation := nation_nature ;
89777: LD_ADDR_OWVAR 21
89781: PUSH
89782: LD_INT 0
89784: ST_TO_ADDR
// uc_side := 0 ;
89785: LD_ADDR_OWVAR 20
89789: PUSH
89790: LD_INT 0
89792: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89793: LD_ADDR_OWVAR 29
89797: PUSH
89798: LD_INT 12
89800: PUSH
89801: LD_INT 12
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: ST_TO_ADDR
// hc_agressivity := 20 ;
89808: LD_ADDR_OWVAR 35
89812: PUSH
89813: LD_INT 20
89815: ST_TO_ADDR
// hc_class := class_tiger ;
89816: LD_ADDR_OWVAR 28
89820: PUSH
89821: LD_INT 14
89823: ST_TO_ADDR
// hc_gallery :=  ;
89824: LD_ADDR_OWVAR 33
89828: PUSH
89829: LD_STRING 
89831: ST_TO_ADDR
// hc_name :=  ;
89832: LD_ADDR_OWVAR 26
89836: PUSH
89837: LD_STRING 
89839: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
89840: CALL_OW 44
89844: PPUSH
89845: LD_INT 0
89847: PPUSH
89848: CALL_OW 51
// end ;
89852: GO 89774
89854: POP
89855: POP
// end ;
89856: PPOPN 1
89858: END
// every 0 0$1 trigger StreamModeActive and sBomb do
89859: LD_EXP 83
89863: PUSH
89864: LD_EXP 103
89868: AND
89869: IFFALSE 89878
89871: GO 89873
89873: DISABLE
// StreamSibBomb ;
89874: CALL 89879 0 0
89878: END
// export function StreamSibBomb ; var i , x , y ; begin
89879: LD_INT 0
89881: PPUSH
89882: PPUSH
89883: PPUSH
89884: PPUSH
// result := false ;
89885: LD_ADDR_VAR 0 1
89889: PUSH
89890: LD_INT 0
89892: ST_TO_ADDR
// for i := 1 to 16 do
89893: LD_ADDR_VAR 0 2
89897: PUSH
89898: DOUBLE
89899: LD_INT 1
89901: DEC
89902: ST_TO_ADDR
89903: LD_INT 16
89905: PUSH
89906: FOR_TO
89907: IFFALSE 90106
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89909: LD_ADDR_VAR 0 3
89913: PUSH
89914: LD_INT 10
89916: PUSH
89917: LD_INT 20
89919: PUSH
89920: LD_INT 30
89922: PUSH
89923: LD_INT 40
89925: PUSH
89926: LD_INT 50
89928: PUSH
89929: LD_INT 60
89931: PUSH
89932: LD_INT 70
89934: PUSH
89935: LD_INT 80
89937: PUSH
89938: LD_INT 90
89940: PUSH
89941: LD_INT 100
89943: PUSH
89944: LD_INT 110
89946: PUSH
89947: LD_INT 120
89949: PUSH
89950: LD_INT 130
89952: PUSH
89953: LD_INT 140
89955: PUSH
89956: LD_INT 150
89958: PUSH
89959: EMPTY
89960: LIST
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 1
89978: PPUSH
89979: LD_INT 15
89981: PPUSH
89982: CALL_OW 12
89986: ARRAY
89987: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89988: LD_ADDR_VAR 0 4
89992: PUSH
89993: LD_INT 10
89995: PUSH
89996: LD_INT 20
89998: PUSH
89999: LD_INT 30
90001: PUSH
90002: LD_INT 40
90004: PUSH
90005: LD_INT 50
90007: PUSH
90008: LD_INT 60
90010: PUSH
90011: LD_INT 70
90013: PUSH
90014: LD_INT 80
90016: PUSH
90017: LD_INT 90
90019: PUSH
90020: LD_INT 100
90022: PUSH
90023: LD_INT 110
90025: PUSH
90026: LD_INT 120
90028: PUSH
90029: LD_INT 130
90031: PUSH
90032: LD_INT 140
90034: PUSH
90035: LD_INT 150
90037: PUSH
90038: EMPTY
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: PUSH
90055: LD_INT 1
90057: PPUSH
90058: LD_INT 15
90060: PPUSH
90061: CALL_OW 12
90065: ARRAY
90066: ST_TO_ADDR
// if ValidHex ( x , y ) then
90067: LD_VAR 0 3
90071: PPUSH
90072: LD_VAR 0 4
90076: PPUSH
90077: CALL_OW 488
90081: IFFALSE 90104
// begin result := [ x , y ] ;
90083: LD_ADDR_VAR 0 1
90087: PUSH
90088: LD_VAR 0 3
90092: PUSH
90093: LD_VAR 0 4
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: ST_TO_ADDR
// break ;
90102: GO 90106
// end ; end ;
90104: GO 89906
90106: POP
90107: POP
// if result then
90108: LD_VAR 0 1
90112: IFFALSE 90172
// begin ToLua ( playSibBomb() ) ;
90114: LD_STRING playSibBomb()
90116: PPUSH
90117: CALL_OW 559
// wait ( 0 0$14 ) ;
90121: LD_INT 490
90123: PPUSH
90124: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
90128: LD_VAR 0 1
90132: PUSH
90133: LD_INT 1
90135: ARRAY
90136: PPUSH
90137: LD_VAR 0 1
90141: PUSH
90142: LD_INT 2
90144: ARRAY
90145: PPUSH
90146: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
90150: LD_VAR 0 1
90154: PUSH
90155: LD_INT 1
90157: ARRAY
90158: PPUSH
90159: LD_VAR 0 1
90163: PUSH
90164: LD_INT 2
90166: ARRAY
90167: PPUSH
90168: CALL_OW 429
// end ; end ;
90172: LD_VAR 0 1
90176: RET
// every 0 0$1 trigger StreamModeActive and sReset do
90177: LD_EXP 83
90181: PUSH
90182: LD_EXP 105
90186: AND
90187: IFFALSE 90199
90189: GO 90191
90191: DISABLE
// YouLost (  ) ;
90192: LD_STRING 
90194: PPUSH
90195: CALL_OW 104
90199: END
// every 0 0$1 trigger StreamModeActive and sFog do
90200: LD_EXP 83
90204: PUSH
90205: LD_EXP 104
90209: AND
90210: IFFALSE 90224
90212: GO 90214
90214: DISABLE
// FogOff ( your_side ) ;
90215: LD_OWVAR 2
90219: PPUSH
90220: CALL_OW 344
90224: END
// every 0 0$1 trigger StreamModeActive and sSun do
90225: LD_EXP 83
90229: PUSH
90230: LD_EXP 106
90234: AND
90235: IFFALSE 90263
90237: GO 90239
90239: DISABLE
// begin solar_recharge_percent := 0 ;
90240: LD_ADDR_OWVAR 79
90244: PUSH
90245: LD_INT 0
90247: ST_TO_ADDR
// wait ( 5 5$00 ) ;
90248: LD_INT 10500
90250: PPUSH
90251: CALL_OW 67
// solar_recharge_percent := 100 ;
90255: LD_ADDR_OWVAR 79
90259: PUSH
90260: LD_INT 100
90262: ST_TO_ADDR
// end ;
90263: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
90264: LD_EXP 83
90268: PUSH
90269: LD_EXP 107
90273: AND
90274: IFFALSE 90513
90276: GO 90278
90278: DISABLE
90279: LD_INT 0
90281: PPUSH
90282: PPUSH
90283: PPUSH
// begin tmp := [ ] ;
90284: LD_ADDR_VAR 0 3
90288: PUSH
90289: EMPTY
90290: ST_TO_ADDR
// for i := 1 to 6 do
90291: LD_ADDR_VAR 0 1
90295: PUSH
90296: DOUBLE
90297: LD_INT 1
90299: DEC
90300: ST_TO_ADDR
90301: LD_INT 6
90303: PUSH
90304: FOR_TO
90305: IFFALSE 90410
// begin uc_nation := nation_nature ;
90307: LD_ADDR_OWVAR 21
90311: PUSH
90312: LD_INT 0
90314: ST_TO_ADDR
// uc_side := 0 ;
90315: LD_ADDR_OWVAR 20
90319: PUSH
90320: LD_INT 0
90322: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90323: LD_ADDR_OWVAR 29
90327: PUSH
90328: LD_INT 12
90330: PUSH
90331: LD_INT 12
90333: PUSH
90334: EMPTY
90335: LIST
90336: LIST
90337: ST_TO_ADDR
// hc_agressivity := 20 ;
90338: LD_ADDR_OWVAR 35
90342: PUSH
90343: LD_INT 20
90345: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
90346: LD_ADDR_OWVAR 28
90350: PUSH
90351: LD_INT 17
90353: ST_TO_ADDR
// hc_gallery :=  ;
90354: LD_ADDR_OWVAR 33
90358: PUSH
90359: LD_STRING 
90361: ST_TO_ADDR
// hc_name :=  ;
90362: LD_ADDR_OWVAR 26
90366: PUSH
90367: LD_STRING 
90369: ST_TO_ADDR
// un := CreateHuman ;
90370: LD_ADDR_VAR 0 2
90374: PUSH
90375: CALL_OW 44
90379: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
90380: LD_VAR 0 2
90384: PPUSH
90385: LD_INT 1
90387: PPUSH
90388: CALL_OW 51
// tmp := tmp ^ un ;
90392: LD_ADDR_VAR 0 3
90396: PUSH
90397: LD_VAR 0 3
90401: PUSH
90402: LD_VAR 0 2
90406: ADD
90407: ST_TO_ADDR
// end ;
90408: GO 90304
90410: POP
90411: POP
// repeat wait ( 0 0$1 ) ;
90412: LD_INT 35
90414: PPUSH
90415: CALL_OW 67
// for un in tmp do
90419: LD_ADDR_VAR 0 2
90423: PUSH
90424: LD_VAR 0 3
90428: PUSH
90429: FOR_IN
90430: IFFALSE 90504
// begin if IsDead ( un ) then
90432: LD_VAR 0 2
90436: PPUSH
90437: CALL_OW 301
90441: IFFALSE 90461
// begin tmp := tmp diff un ;
90443: LD_ADDR_VAR 0 3
90447: PUSH
90448: LD_VAR 0 3
90452: PUSH
90453: LD_VAR 0 2
90457: DIFF
90458: ST_TO_ADDR
// continue ;
90459: GO 90429
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
90461: LD_VAR 0 2
90465: PPUSH
90466: LD_INT 3
90468: PUSH
90469: LD_INT 22
90471: PUSH
90472: LD_INT 0
90474: PUSH
90475: EMPTY
90476: LIST
90477: LIST
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PPUSH
90483: CALL_OW 69
90487: PPUSH
90488: LD_VAR 0 2
90492: PPUSH
90493: CALL_OW 74
90497: PPUSH
90498: CALL_OW 115
// end ;
90502: GO 90429
90504: POP
90505: POP
// until not tmp ;
90506: LD_VAR 0 3
90510: NOT
90511: IFFALSE 90412
// end ;
90513: PPOPN 3
90515: END
// every 0 0$1 trigger StreamModeActive and sTroll do
90516: LD_EXP 83
90520: PUSH
90521: LD_EXP 108
90525: AND
90526: IFFALSE 90580
90528: GO 90530
90530: DISABLE
// begin ToLua ( displayTroll(); ) ;
90531: LD_STRING displayTroll();
90533: PPUSH
90534: CALL_OW 559
// wait ( 3 3$00 ) ;
90538: LD_INT 6300
90540: PPUSH
90541: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90545: LD_STRING hideTroll();
90547: PPUSH
90548: CALL_OW 559
// wait ( 1 1$00 ) ;
90552: LD_INT 2100
90554: PPUSH
90555: CALL_OW 67
// ToLua ( displayTroll(); ) ;
90559: LD_STRING displayTroll();
90561: PPUSH
90562: CALL_OW 559
// wait ( 1 1$00 ) ;
90566: LD_INT 2100
90568: PPUSH
90569: CALL_OW 67
// ToLua ( hideTroll(); ) ;
90573: LD_STRING hideTroll();
90575: PPUSH
90576: CALL_OW 559
// end ;
90580: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
90581: LD_EXP 83
90585: PUSH
90586: LD_EXP 109
90590: AND
90591: IFFALSE 90654
90593: GO 90595
90595: DISABLE
90596: LD_INT 0
90598: PPUSH
// begin p := 0 ;
90599: LD_ADDR_VAR 0 1
90603: PUSH
90604: LD_INT 0
90606: ST_TO_ADDR
// repeat game_speed := 1 ;
90607: LD_ADDR_OWVAR 65
90611: PUSH
90612: LD_INT 1
90614: ST_TO_ADDR
// wait ( 0 0$1 ) ;
90615: LD_INT 35
90617: PPUSH
90618: CALL_OW 67
// p := p + 1 ;
90622: LD_ADDR_VAR 0 1
90626: PUSH
90627: LD_VAR 0 1
90631: PUSH
90632: LD_INT 1
90634: PLUS
90635: ST_TO_ADDR
// until p >= 60 ;
90636: LD_VAR 0 1
90640: PUSH
90641: LD_INT 60
90643: GREATEREQUAL
90644: IFFALSE 90607
// game_speed := 4 ;
90646: LD_ADDR_OWVAR 65
90650: PUSH
90651: LD_INT 4
90653: ST_TO_ADDR
// end ;
90654: PPOPN 1
90656: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
90657: LD_EXP 83
90661: PUSH
90662: LD_EXP 110
90666: AND
90667: IFFALSE 90813
90669: GO 90671
90671: DISABLE
90672: LD_INT 0
90674: PPUSH
90675: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90676: LD_ADDR_VAR 0 1
90680: PUSH
90681: LD_INT 22
90683: PUSH
90684: LD_OWVAR 2
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 2
90695: PUSH
90696: LD_INT 30
90698: PUSH
90699: LD_INT 0
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 30
90708: PUSH
90709: LD_INT 1
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: LIST
90720: PUSH
90721: EMPTY
90722: LIST
90723: LIST
90724: PPUSH
90725: CALL_OW 69
90729: ST_TO_ADDR
// if not depot then
90730: LD_VAR 0 1
90734: NOT
90735: IFFALSE 90739
// exit ;
90737: GO 90813
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
90739: LD_ADDR_VAR 0 2
90743: PUSH
90744: LD_VAR 0 1
90748: PUSH
90749: LD_INT 1
90751: PPUSH
90752: LD_VAR 0 1
90756: PPUSH
90757: CALL_OW 12
90761: ARRAY
90762: PPUSH
90763: CALL_OW 274
90767: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
90768: LD_VAR 0 2
90772: PPUSH
90773: LD_INT 1
90775: PPUSH
90776: LD_INT 0
90778: PPUSH
90779: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
90783: LD_VAR 0 2
90787: PPUSH
90788: LD_INT 2
90790: PPUSH
90791: LD_INT 0
90793: PPUSH
90794: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
90798: LD_VAR 0 2
90802: PPUSH
90803: LD_INT 3
90805: PPUSH
90806: LD_INT 0
90808: PPUSH
90809: CALL_OW 277
// end ;
90813: PPOPN 2
90815: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
90816: LD_EXP 83
90820: PUSH
90821: LD_EXP 111
90825: AND
90826: IFFALSE 90923
90828: GO 90830
90830: DISABLE
90831: LD_INT 0
90833: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90834: LD_ADDR_VAR 0 1
90838: PUSH
90839: LD_INT 22
90841: PUSH
90842: LD_OWVAR 2
90846: PUSH
90847: EMPTY
90848: LIST
90849: LIST
90850: PUSH
90851: LD_INT 21
90853: PUSH
90854: LD_INT 1
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 3
90863: PUSH
90864: LD_INT 23
90866: PUSH
90867: LD_INT 0
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: LIST
90882: PPUSH
90883: CALL_OW 69
90887: ST_TO_ADDR
// if not tmp then
90888: LD_VAR 0 1
90892: NOT
90893: IFFALSE 90897
// exit ;
90895: GO 90923
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
90897: LD_VAR 0 1
90901: PUSH
90902: LD_INT 1
90904: PPUSH
90905: LD_VAR 0 1
90909: PPUSH
90910: CALL_OW 12
90914: ARRAY
90915: PPUSH
90916: LD_INT 200
90918: PPUSH
90919: CALL_OW 234
// end ;
90923: PPOPN 1
90925: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
90926: LD_EXP 83
90930: PUSH
90931: LD_EXP 112
90935: AND
90936: IFFALSE 91015
90938: GO 90940
90940: DISABLE
90941: LD_INT 0
90943: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
90944: LD_ADDR_VAR 0 1
90948: PUSH
90949: LD_INT 22
90951: PUSH
90952: LD_OWVAR 2
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 21
90963: PUSH
90964: LD_INT 2
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PPUSH
90975: CALL_OW 69
90979: ST_TO_ADDR
// if not tmp then
90980: LD_VAR 0 1
90984: NOT
90985: IFFALSE 90989
// exit ;
90987: GO 91015
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
90989: LD_VAR 0 1
90993: PUSH
90994: LD_INT 1
90996: PPUSH
90997: LD_VAR 0 1
91001: PPUSH
91002: CALL_OW 12
91006: ARRAY
91007: PPUSH
91008: LD_INT 60
91010: PPUSH
91011: CALL_OW 234
// end ;
91015: PPOPN 1
91017: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
91018: LD_EXP 83
91022: PUSH
91023: LD_EXP 113
91027: AND
91028: IFFALSE 91127
91030: GO 91032
91032: DISABLE
91033: LD_INT 0
91035: PPUSH
91036: PPUSH
// begin enable ;
91037: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
91038: LD_ADDR_VAR 0 1
91042: PUSH
91043: LD_INT 22
91045: PUSH
91046: LD_OWVAR 2
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PUSH
91055: LD_INT 61
91057: PUSH
91058: EMPTY
91059: LIST
91060: PUSH
91061: LD_INT 33
91063: PUSH
91064: LD_INT 2
91066: PUSH
91067: EMPTY
91068: LIST
91069: LIST
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: LIST
91075: PPUSH
91076: CALL_OW 69
91080: ST_TO_ADDR
// if not tmp then
91081: LD_VAR 0 1
91085: NOT
91086: IFFALSE 91090
// exit ;
91088: GO 91127
// for i in tmp do
91090: LD_ADDR_VAR 0 2
91094: PUSH
91095: LD_VAR 0 1
91099: PUSH
91100: FOR_IN
91101: IFFALSE 91125
// if IsControledBy ( i ) then
91103: LD_VAR 0 2
91107: PPUSH
91108: CALL_OW 312
91112: IFFALSE 91123
// ComUnlink ( i ) ;
91114: LD_VAR 0 2
91118: PPUSH
91119: CALL_OW 136
91123: GO 91100
91125: POP
91126: POP
// end ;
91127: PPOPN 2
91129: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
91130: LD_EXP 83
91134: PUSH
91135: LD_EXP 114
91139: AND
91140: IFFALSE 91280
91142: GO 91144
91144: DISABLE
91145: LD_INT 0
91147: PPUSH
91148: PPUSH
// begin ToLua ( displayPowell(); ) ;
91149: LD_STRING displayPowell();
91151: PPUSH
91152: CALL_OW 559
// uc_side := 0 ;
91156: LD_ADDR_OWVAR 20
91160: PUSH
91161: LD_INT 0
91163: ST_TO_ADDR
// uc_nation := 2 ;
91164: LD_ADDR_OWVAR 21
91168: PUSH
91169: LD_INT 2
91171: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
91172: LD_ADDR_OWVAR 37
91176: PUSH
91177: LD_INT 14
91179: ST_TO_ADDR
// vc_engine := engine_siberite ;
91180: LD_ADDR_OWVAR 39
91184: PUSH
91185: LD_INT 3
91187: ST_TO_ADDR
// vc_control := control_apeman ;
91188: LD_ADDR_OWVAR 38
91192: PUSH
91193: LD_INT 5
91195: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
91196: LD_ADDR_OWVAR 40
91200: PUSH
91201: LD_INT 29
91203: ST_TO_ADDR
// un := CreateVehicle ;
91204: LD_ADDR_VAR 0 2
91208: PUSH
91209: CALL_OW 45
91213: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91214: LD_VAR 0 2
91218: PPUSH
91219: LD_INT 1
91221: PPUSH
91222: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91226: LD_INT 35
91228: PPUSH
91229: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91233: LD_VAR 0 2
91237: PPUSH
91238: LD_INT 22
91240: PUSH
91241: LD_OWVAR 2
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: PPUSH
91250: CALL_OW 69
91254: PPUSH
91255: LD_VAR 0 2
91259: PPUSH
91260: CALL_OW 74
91264: PPUSH
91265: CALL_OW 115
// until IsDead ( un ) ;
91269: LD_VAR 0 2
91273: PPUSH
91274: CALL_OW 301
91278: IFFALSE 91226
// end ;
91280: PPOPN 2
91282: END
// every 0 0$1 trigger StreamModeActive and sStu do
91283: LD_EXP 83
91287: PUSH
91288: LD_EXP 122
91292: AND
91293: IFFALSE 91309
91295: GO 91297
91297: DISABLE
// begin ToLua ( displayStucuk(); ) ;
91298: LD_STRING displayStucuk();
91300: PPUSH
91301: CALL_OW 559
// ResetFog ;
91305: CALL_OW 335
// end ;
91309: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
91310: LD_EXP 83
91314: PUSH
91315: LD_EXP 115
91319: AND
91320: IFFALSE 91461
91322: GO 91324
91324: DISABLE
91325: LD_INT 0
91327: PPUSH
91328: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91329: LD_ADDR_VAR 0 2
91333: PUSH
91334: LD_INT 22
91336: PUSH
91337: LD_OWVAR 2
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 21
91348: PUSH
91349: LD_INT 1
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PPUSH
91360: CALL_OW 69
91364: ST_TO_ADDR
// if not tmp then
91365: LD_VAR 0 2
91369: NOT
91370: IFFALSE 91374
// exit ;
91372: GO 91461
// un := tmp [ rand ( 1 , tmp ) ] ;
91374: LD_ADDR_VAR 0 1
91378: PUSH
91379: LD_VAR 0 2
91383: PUSH
91384: LD_INT 1
91386: PPUSH
91387: LD_VAR 0 2
91391: PPUSH
91392: CALL_OW 12
91396: ARRAY
91397: ST_TO_ADDR
// SetSide ( un , 0 ) ;
91398: LD_VAR 0 1
91402: PPUSH
91403: LD_INT 0
91405: PPUSH
91406: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
91410: LD_VAR 0 1
91414: PPUSH
91415: LD_OWVAR 3
91419: PUSH
91420: LD_VAR 0 1
91424: DIFF
91425: PPUSH
91426: LD_VAR 0 1
91430: PPUSH
91431: CALL_OW 74
91435: PPUSH
91436: CALL_OW 115
// wait ( 0 0$20 ) ;
91440: LD_INT 700
91442: PPUSH
91443: CALL_OW 67
// SetSide ( un , your_side ) ;
91447: LD_VAR 0 1
91451: PPUSH
91452: LD_OWVAR 2
91456: PPUSH
91457: CALL_OW 235
// end ;
91461: PPOPN 2
91463: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
91464: LD_EXP 83
91468: PUSH
91469: LD_EXP 116
91473: AND
91474: IFFALSE 91580
91476: GO 91478
91478: DISABLE
91479: LD_INT 0
91481: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91482: LD_ADDR_VAR 0 1
91486: PUSH
91487: LD_INT 22
91489: PUSH
91490: LD_OWVAR 2
91494: PUSH
91495: EMPTY
91496: LIST
91497: LIST
91498: PUSH
91499: LD_INT 2
91501: PUSH
91502: LD_INT 30
91504: PUSH
91505: LD_INT 0
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 30
91514: PUSH
91515: LD_INT 1
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: LIST
91526: PUSH
91527: EMPTY
91528: LIST
91529: LIST
91530: PPUSH
91531: CALL_OW 69
91535: ST_TO_ADDR
// if not depot then
91536: LD_VAR 0 1
91540: NOT
91541: IFFALSE 91545
// exit ;
91543: GO 91580
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
91545: LD_VAR 0 1
91549: PUSH
91550: LD_INT 1
91552: ARRAY
91553: PPUSH
91554: CALL_OW 250
91558: PPUSH
91559: LD_VAR 0 1
91563: PUSH
91564: LD_INT 1
91566: ARRAY
91567: PPUSH
91568: CALL_OW 251
91572: PPUSH
91573: LD_INT 70
91575: PPUSH
91576: CALL_OW 495
// end ;
91580: PPOPN 1
91582: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
91583: LD_EXP 83
91587: PUSH
91588: LD_EXP 117
91592: AND
91593: IFFALSE 91804
91595: GO 91597
91597: DISABLE
91598: LD_INT 0
91600: PPUSH
91601: PPUSH
91602: PPUSH
91603: PPUSH
91604: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91605: LD_ADDR_VAR 0 5
91609: PUSH
91610: LD_INT 22
91612: PUSH
91613: LD_OWVAR 2
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: PUSH
91622: LD_INT 21
91624: PUSH
91625: LD_INT 1
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: PPUSH
91636: CALL_OW 69
91640: ST_TO_ADDR
// if not tmp then
91641: LD_VAR 0 5
91645: NOT
91646: IFFALSE 91650
// exit ;
91648: GO 91804
// for i in tmp do
91650: LD_ADDR_VAR 0 1
91654: PUSH
91655: LD_VAR 0 5
91659: PUSH
91660: FOR_IN
91661: IFFALSE 91802
// begin d := rand ( 0 , 5 ) ;
91663: LD_ADDR_VAR 0 4
91667: PUSH
91668: LD_INT 0
91670: PPUSH
91671: LD_INT 5
91673: PPUSH
91674: CALL_OW 12
91678: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
91679: LD_ADDR_VAR 0 2
91683: PUSH
91684: LD_VAR 0 1
91688: PPUSH
91689: CALL_OW 250
91693: PPUSH
91694: LD_VAR 0 4
91698: PPUSH
91699: LD_INT 3
91701: PPUSH
91702: LD_INT 12
91704: PPUSH
91705: CALL_OW 12
91709: PPUSH
91710: CALL_OW 272
91714: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
91715: LD_ADDR_VAR 0 3
91719: PUSH
91720: LD_VAR 0 1
91724: PPUSH
91725: CALL_OW 251
91729: PPUSH
91730: LD_VAR 0 4
91734: PPUSH
91735: LD_INT 3
91737: PPUSH
91738: LD_INT 12
91740: PPUSH
91741: CALL_OW 12
91745: PPUSH
91746: CALL_OW 273
91750: ST_TO_ADDR
// if ValidHex ( x , y ) then
91751: LD_VAR 0 2
91755: PPUSH
91756: LD_VAR 0 3
91760: PPUSH
91761: CALL_OW 488
91765: IFFALSE 91800
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
91767: LD_VAR 0 1
91771: PPUSH
91772: LD_VAR 0 2
91776: PPUSH
91777: LD_VAR 0 3
91781: PPUSH
91782: LD_INT 3
91784: PPUSH
91785: LD_INT 6
91787: PPUSH
91788: CALL_OW 12
91792: PPUSH
91793: LD_INT 1
91795: PPUSH
91796: CALL_OW 483
// end ;
91800: GO 91660
91802: POP
91803: POP
// end ;
91804: PPOPN 5
91806: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
91807: LD_EXP 83
91811: PUSH
91812: LD_EXP 118
91816: AND
91817: IFFALSE 91911
91819: GO 91821
91821: DISABLE
91822: LD_INT 0
91824: PPUSH
91825: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
91826: LD_ADDR_VAR 0 2
91830: PUSH
91831: LD_INT 22
91833: PUSH
91834: LD_OWVAR 2
91838: PUSH
91839: EMPTY
91840: LIST
91841: LIST
91842: PUSH
91843: LD_INT 32
91845: PUSH
91846: LD_INT 1
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: PUSH
91853: LD_INT 21
91855: PUSH
91856: LD_INT 2
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: PUSH
91863: EMPTY
91864: LIST
91865: LIST
91866: LIST
91867: PPUSH
91868: CALL_OW 69
91872: ST_TO_ADDR
// if not tmp then
91873: LD_VAR 0 2
91877: NOT
91878: IFFALSE 91882
// exit ;
91880: GO 91911
// for i in tmp do
91882: LD_ADDR_VAR 0 1
91886: PUSH
91887: LD_VAR 0 2
91891: PUSH
91892: FOR_IN
91893: IFFALSE 91909
// SetFuel ( i , 0 ) ;
91895: LD_VAR 0 1
91899: PPUSH
91900: LD_INT 0
91902: PPUSH
91903: CALL_OW 240
91907: GO 91892
91909: POP
91910: POP
// end ;
91911: PPOPN 2
91913: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
91914: LD_EXP 83
91918: PUSH
91919: LD_EXP 119
91923: AND
91924: IFFALSE 91990
91926: GO 91928
91928: DISABLE
91929: LD_INT 0
91931: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91932: LD_ADDR_VAR 0 1
91936: PUSH
91937: LD_INT 22
91939: PUSH
91940: LD_OWVAR 2
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: PUSH
91949: LD_INT 30
91951: PUSH
91952: LD_INT 29
91954: PUSH
91955: EMPTY
91956: LIST
91957: LIST
91958: PUSH
91959: EMPTY
91960: LIST
91961: LIST
91962: PPUSH
91963: CALL_OW 69
91967: ST_TO_ADDR
// if not tmp then
91968: LD_VAR 0 1
91972: NOT
91973: IFFALSE 91977
// exit ;
91975: GO 91990
// DestroyUnit ( tmp [ 1 ] ) ;
91977: LD_VAR 0 1
91981: PUSH
91982: LD_INT 1
91984: ARRAY
91985: PPUSH
91986: CALL_OW 65
// end ;
91990: PPOPN 1
91992: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
91993: LD_EXP 83
91997: PUSH
91998: LD_EXP 121
92002: AND
92003: IFFALSE 92132
92005: GO 92007
92007: DISABLE
92008: LD_INT 0
92010: PPUSH
// begin uc_side := 0 ;
92011: LD_ADDR_OWVAR 20
92015: PUSH
92016: LD_INT 0
92018: ST_TO_ADDR
// uc_nation := nation_arabian ;
92019: LD_ADDR_OWVAR 21
92023: PUSH
92024: LD_INT 2
92026: ST_TO_ADDR
// hc_gallery :=  ;
92027: LD_ADDR_OWVAR 33
92031: PUSH
92032: LD_STRING 
92034: ST_TO_ADDR
// hc_name :=  ;
92035: LD_ADDR_OWVAR 26
92039: PUSH
92040: LD_STRING 
92042: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
92043: LD_INT 1
92045: PPUSH
92046: LD_INT 11
92048: PPUSH
92049: LD_INT 10
92051: PPUSH
92052: CALL_OW 380
// un := CreateHuman ;
92056: LD_ADDR_VAR 0 1
92060: PUSH
92061: CALL_OW 44
92065: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92066: LD_VAR 0 1
92070: PPUSH
92071: LD_INT 1
92073: PPUSH
92074: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92078: LD_INT 35
92080: PPUSH
92081: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92085: LD_VAR 0 1
92089: PPUSH
92090: LD_INT 22
92092: PUSH
92093: LD_OWVAR 2
92097: PUSH
92098: EMPTY
92099: LIST
92100: LIST
92101: PPUSH
92102: CALL_OW 69
92106: PPUSH
92107: LD_VAR 0 1
92111: PPUSH
92112: CALL_OW 74
92116: PPUSH
92117: CALL_OW 115
// until IsDead ( un ) ;
92121: LD_VAR 0 1
92125: PPUSH
92126: CALL_OW 301
92130: IFFALSE 92078
// end ;
92132: PPOPN 1
92134: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
92135: LD_EXP 83
92139: PUSH
92140: LD_EXP 123
92144: AND
92145: IFFALSE 92157
92147: GO 92149
92149: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
92150: LD_STRING earthquake(getX(game), 0, 32)
92152: PPUSH
92153: CALL_OW 559
92157: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
92158: LD_EXP 83
92162: PUSH
92163: LD_EXP 124
92167: AND
92168: IFFALSE 92259
92170: GO 92172
92172: DISABLE
92173: LD_INT 0
92175: PPUSH
// begin enable ;
92176: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
92177: LD_ADDR_VAR 0 1
92181: PUSH
92182: LD_INT 22
92184: PUSH
92185: LD_OWVAR 2
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 21
92196: PUSH
92197: LD_INT 2
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 33
92206: PUSH
92207: LD_INT 3
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: LIST
92218: PPUSH
92219: CALL_OW 69
92223: ST_TO_ADDR
// if not tmp then
92224: LD_VAR 0 1
92228: NOT
92229: IFFALSE 92233
// exit ;
92231: GO 92259
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92233: LD_VAR 0 1
92237: PUSH
92238: LD_INT 1
92240: PPUSH
92241: LD_VAR 0 1
92245: PPUSH
92246: CALL_OW 12
92250: ARRAY
92251: PPUSH
92252: LD_INT 1
92254: PPUSH
92255: CALL_OW 234
// end ;
92259: PPOPN 1
92261: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
92262: LD_EXP 83
92266: PUSH
92267: LD_EXP 125
92271: AND
92272: IFFALSE 92413
92274: GO 92276
92276: DISABLE
92277: LD_INT 0
92279: PPUSH
92280: PPUSH
92281: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92282: LD_ADDR_VAR 0 3
92286: PUSH
92287: LD_INT 22
92289: PUSH
92290: LD_OWVAR 2
92294: PUSH
92295: EMPTY
92296: LIST
92297: LIST
92298: PUSH
92299: LD_INT 25
92301: PUSH
92302: LD_INT 1
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: EMPTY
92310: LIST
92311: LIST
92312: PPUSH
92313: CALL_OW 69
92317: ST_TO_ADDR
// if not tmp then
92318: LD_VAR 0 3
92322: NOT
92323: IFFALSE 92327
// exit ;
92325: GO 92413
// un := tmp [ rand ( 1 , tmp ) ] ;
92327: LD_ADDR_VAR 0 2
92331: PUSH
92332: LD_VAR 0 3
92336: PUSH
92337: LD_INT 1
92339: PPUSH
92340: LD_VAR 0 3
92344: PPUSH
92345: CALL_OW 12
92349: ARRAY
92350: ST_TO_ADDR
// if Crawls ( un ) then
92351: LD_VAR 0 2
92355: PPUSH
92356: CALL_OW 318
92360: IFFALSE 92371
// ComWalk ( un ) ;
92362: LD_VAR 0 2
92366: PPUSH
92367: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
92371: LD_VAR 0 2
92375: PPUSH
92376: LD_INT 9
92378: PPUSH
92379: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
92383: LD_INT 28
92385: PPUSH
92386: LD_OWVAR 2
92390: PPUSH
92391: LD_INT 2
92393: PPUSH
92394: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
92398: LD_INT 29
92400: PPUSH
92401: LD_OWVAR 2
92405: PPUSH
92406: LD_INT 2
92408: PPUSH
92409: CALL_OW 322
// end ;
92413: PPOPN 3
92415: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
92416: LD_EXP 83
92420: PUSH
92421: LD_EXP 126
92425: AND
92426: IFFALSE 92537
92428: GO 92430
92430: DISABLE
92431: LD_INT 0
92433: PPUSH
92434: PPUSH
92435: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92436: LD_ADDR_VAR 0 3
92440: PUSH
92441: LD_INT 22
92443: PUSH
92444: LD_OWVAR 2
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PUSH
92453: LD_INT 25
92455: PUSH
92456: LD_INT 1
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PPUSH
92467: CALL_OW 69
92471: ST_TO_ADDR
// if not tmp then
92472: LD_VAR 0 3
92476: NOT
92477: IFFALSE 92481
// exit ;
92479: GO 92537
// un := tmp [ rand ( 1 , tmp ) ] ;
92481: LD_ADDR_VAR 0 2
92485: PUSH
92486: LD_VAR 0 3
92490: PUSH
92491: LD_INT 1
92493: PPUSH
92494: LD_VAR 0 3
92498: PPUSH
92499: CALL_OW 12
92503: ARRAY
92504: ST_TO_ADDR
// if Crawls ( un ) then
92505: LD_VAR 0 2
92509: PPUSH
92510: CALL_OW 318
92514: IFFALSE 92525
// ComWalk ( un ) ;
92516: LD_VAR 0 2
92520: PPUSH
92521: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92525: LD_VAR 0 2
92529: PPUSH
92530: LD_INT 8
92532: PPUSH
92533: CALL_OW 336
// end ;
92537: PPOPN 3
92539: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
92540: LD_EXP 83
92544: PUSH
92545: LD_EXP 127
92549: AND
92550: IFFALSE 92694
92552: GO 92554
92554: DISABLE
92555: LD_INT 0
92557: PPUSH
92558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
92559: LD_ADDR_VAR 0 2
92563: PUSH
92564: LD_INT 22
92566: PUSH
92567: LD_OWVAR 2
92571: PUSH
92572: EMPTY
92573: LIST
92574: LIST
92575: PUSH
92576: LD_INT 21
92578: PUSH
92579: LD_INT 2
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: PUSH
92586: LD_INT 2
92588: PUSH
92589: LD_INT 34
92591: PUSH
92592: LD_INT 12
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: PUSH
92599: LD_INT 34
92601: PUSH
92602: LD_INT 51
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 34
92611: PUSH
92612: LD_INT 32
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: EMPTY
92620: LIST
92621: LIST
92622: LIST
92623: LIST
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: LIST
92629: PPUSH
92630: CALL_OW 69
92634: ST_TO_ADDR
// if not tmp then
92635: LD_VAR 0 2
92639: NOT
92640: IFFALSE 92644
// exit ;
92642: GO 92694
// for i in tmp do
92644: LD_ADDR_VAR 0 1
92648: PUSH
92649: LD_VAR 0 2
92653: PUSH
92654: FOR_IN
92655: IFFALSE 92692
// if GetCargo ( i , mat_artifact ) = 0 then
92657: LD_VAR 0 1
92661: PPUSH
92662: LD_INT 4
92664: PPUSH
92665: CALL_OW 289
92669: PUSH
92670: LD_INT 0
92672: EQUAL
92673: IFFALSE 92690
// SetCargo ( i , mat_siberit , 100 ) ;
92675: LD_VAR 0 1
92679: PPUSH
92680: LD_INT 3
92682: PPUSH
92683: LD_INT 100
92685: PPUSH
92686: CALL_OW 290
92690: GO 92654
92692: POP
92693: POP
// end ;
92694: PPOPN 2
92696: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
92697: LD_EXP 83
92701: PUSH
92702: LD_EXP 128
92706: AND
92707: IFFALSE 92890
92709: GO 92711
92711: DISABLE
92712: LD_INT 0
92714: PPUSH
92715: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
92716: LD_ADDR_VAR 0 2
92720: PUSH
92721: LD_INT 22
92723: PUSH
92724: LD_OWVAR 2
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PPUSH
92733: CALL_OW 69
92737: ST_TO_ADDR
// if not tmp then
92738: LD_VAR 0 2
92742: NOT
92743: IFFALSE 92747
// exit ;
92745: GO 92890
// for i := 1 to 2 do
92747: LD_ADDR_VAR 0 1
92751: PUSH
92752: DOUBLE
92753: LD_INT 1
92755: DEC
92756: ST_TO_ADDR
92757: LD_INT 2
92759: PUSH
92760: FOR_TO
92761: IFFALSE 92888
// begin uc_side := your_side ;
92763: LD_ADDR_OWVAR 20
92767: PUSH
92768: LD_OWVAR 2
92772: ST_TO_ADDR
// uc_nation := nation_american ;
92773: LD_ADDR_OWVAR 21
92777: PUSH
92778: LD_INT 1
92780: ST_TO_ADDR
// vc_chassis := us_morphling ;
92781: LD_ADDR_OWVAR 37
92785: PUSH
92786: LD_INT 5
92788: ST_TO_ADDR
// vc_engine := engine_siberite ;
92789: LD_ADDR_OWVAR 39
92793: PUSH
92794: LD_INT 3
92796: ST_TO_ADDR
// vc_control := control_computer ;
92797: LD_ADDR_OWVAR 38
92801: PUSH
92802: LD_INT 3
92804: ST_TO_ADDR
// vc_weapon := us_double_laser ;
92805: LD_ADDR_OWVAR 40
92809: PUSH
92810: LD_INT 10
92812: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
92813: LD_VAR 0 2
92817: PUSH
92818: LD_INT 1
92820: ARRAY
92821: PPUSH
92822: CALL_OW 310
92826: NOT
92827: IFFALSE 92874
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
92829: CALL_OW 45
92833: PPUSH
92834: LD_VAR 0 2
92838: PUSH
92839: LD_INT 1
92841: ARRAY
92842: PPUSH
92843: CALL_OW 250
92847: PPUSH
92848: LD_VAR 0 2
92852: PUSH
92853: LD_INT 1
92855: ARRAY
92856: PPUSH
92857: CALL_OW 251
92861: PPUSH
92862: LD_INT 12
92864: PPUSH
92865: LD_INT 1
92867: PPUSH
92868: CALL_OW 50
92872: GO 92886
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
92874: CALL_OW 45
92878: PPUSH
92879: LD_INT 1
92881: PPUSH
92882: CALL_OW 51
// end ;
92886: GO 92760
92888: POP
92889: POP
// end ;
92890: PPOPN 2
92892: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
92893: LD_EXP 83
92897: PUSH
92898: LD_EXP 129
92902: AND
92903: IFFALSE 93125
92905: GO 92907
92907: DISABLE
92908: LD_INT 0
92910: PPUSH
92911: PPUSH
92912: PPUSH
92913: PPUSH
92914: PPUSH
92915: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92916: LD_ADDR_VAR 0 6
92920: PUSH
92921: LD_INT 22
92923: PUSH
92924: LD_OWVAR 2
92928: PUSH
92929: EMPTY
92930: LIST
92931: LIST
92932: PUSH
92933: LD_INT 21
92935: PUSH
92936: LD_INT 1
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 3
92945: PUSH
92946: LD_INT 23
92948: PUSH
92949: LD_INT 0
92951: PUSH
92952: EMPTY
92953: LIST
92954: LIST
92955: PUSH
92956: EMPTY
92957: LIST
92958: LIST
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: LIST
92964: PPUSH
92965: CALL_OW 69
92969: ST_TO_ADDR
// if not tmp then
92970: LD_VAR 0 6
92974: NOT
92975: IFFALSE 92979
// exit ;
92977: GO 93125
// s1 := rand ( 1 , 4 ) ;
92979: LD_ADDR_VAR 0 2
92983: PUSH
92984: LD_INT 1
92986: PPUSH
92987: LD_INT 4
92989: PPUSH
92990: CALL_OW 12
92994: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
92995: LD_ADDR_VAR 0 4
92999: PUSH
93000: LD_VAR 0 6
93004: PUSH
93005: LD_INT 1
93007: ARRAY
93008: PPUSH
93009: LD_VAR 0 2
93013: PPUSH
93014: CALL_OW 259
93018: ST_TO_ADDR
// if s1 = 1 then
93019: LD_VAR 0 2
93023: PUSH
93024: LD_INT 1
93026: EQUAL
93027: IFFALSE 93047
// s2 := rand ( 2 , 4 ) else
93029: LD_ADDR_VAR 0 3
93033: PUSH
93034: LD_INT 2
93036: PPUSH
93037: LD_INT 4
93039: PPUSH
93040: CALL_OW 12
93044: ST_TO_ADDR
93045: GO 93055
// s2 := 1 ;
93047: LD_ADDR_VAR 0 3
93051: PUSH
93052: LD_INT 1
93054: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
93055: LD_ADDR_VAR 0 5
93059: PUSH
93060: LD_VAR 0 6
93064: PUSH
93065: LD_INT 1
93067: ARRAY
93068: PPUSH
93069: LD_VAR 0 3
93073: PPUSH
93074: CALL_OW 259
93078: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
93079: LD_VAR 0 6
93083: PUSH
93084: LD_INT 1
93086: ARRAY
93087: PPUSH
93088: LD_VAR 0 2
93092: PPUSH
93093: LD_VAR 0 5
93097: PPUSH
93098: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
93102: LD_VAR 0 6
93106: PUSH
93107: LD_INT 1
93109: ARRAY
93110: PPUSH
93111: LD_VAR 0 3
93115: PPUSH
93116: LD_VAR 0 4
93120: PPUSH
93121: CALL_OW 237
// end ;
93125: PPOPN 6
93127: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
93128: LD_EXP 83
93132: PUSH
93133: LD_EXP 130
93137: AND
93138: IFFALSE 93217
93140: GO 93142
93142: DISABLE
93143: LD_INT 0
93145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
93146: LD_ADDR_VAR 0 1
93150: PUSH
93151: LD_INT 22
93153: PUSH
93154: LD_OWVAR 2
93158: PUSH
93159: EMPTY
93160: LIST
93161: LIST
93162: PUSH
93163: LD_INT 30
93165: PUSH
93166: LD_INT 3
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PUSH
93173: EMPTY
93174: LIST
93175: LIST
93176: PPUSH
93177: CALL_OW 69
93181: ST_TO_ADDR
// if not tmp then
93182: LD_VAR 0 1
93186: NOT
93187: IFFALSE 93191
// exit ;
93189: GO 93217
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93191: LD_VAR 0 1
93195: PUSH
93196: LD_INT 1
93198: PPUSH
93199: LD_VAR 0 1
93203: PPUSH
93204: CALL_OW 12
93208: ARRAY
93209: PPUSH
93210: LD_INT 1
93212: PPUSH
93213: CALL_OW 234
// end ;
93217: PPOPN 1
93219: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
93220: LD_EXP 83
93224: PUSH
93225: LD_EXP 131
93229: AND
93230: IFFALSE 93342
93232: GO 93234
93234: DISABLE
93235: LD_INT 0
93237: PPUSH
93238: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
93239: LD_ADDR_VAR 0 2
93243: PUSH
93244: LD_INT 22
93246: PUSH
93247: LD_OWVAR 2
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: LD_INT 2
93258: PUSH
93259: LD_INT 30
93261: PUSH
93262: LD_INT 27
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 30
93271: PUSH
93272: LD_INT 26
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: LD_INT 30
93281: PUSH
93282: LD_INT 28
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: PUSH
93295: EMPTY
93296: LIST
93297: LIST
93298: PPUSH
93299: CALL_OW 69
93303: ST_TO_ADDR
// if not tmp then
93304: LD_VAR 0 2
93308: NOT
93309: IFFALSE 93313
// exit ;
93311: GO 93342
// for i in tmp do
93313: LD_ADDR_VAR 0 1
93317: PUSH
93318: LD_VAR 0 2
93322: PUSH
93323: FOR_IN
93324: IFFALSE 93340
// SetLives ( i , 1 ) ;
93326: LD_VAR 0 1
93330: PPUSH
93331: LD_INT 1
93333: PPUSH
93334: CALL_OW 234
93338: GO 93323
93340: POP
93341: POP
// end ;
93342: PPOPN 2
93344: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
93345: LD_EXP 83
93349: PUSH
93350: LD_EXP 132
93354: AND
93355: IFFALSE 93629
93357: GO 93359
93359: DISABLE
93360: LD_INT 0
93362: PPUSH
93363: PPUSH
93364: PPUSH
// begin i := rand ( 1 , 7 ) ;
93365: LD_ADDR_VAR 0 1
93369: PUSH
93370: LD_INT 1
93372: PPUSH
93373: LD_INT 7
93375: PPUSH
93376: CALL_OW 12
93380: ST_TO_ADDR
// case i of 1 :
93381: LD_VAR 0 1
93385: PUSH
93386: LD_INT 1
93388: DOUBLE
93389: EQUAL
93390: IFTRUE 93394
93392: GO 93404
93394: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
93395: LD_STRING earthquake(getX(game), 0, 32)
93397: PPUSH
93398: CALL_OW 559
93402: GO 93629
93404: LD_INT 2
93406: DOUBLE
93407: EQUAL
93408: IFTRUE 93412
93410: GO 93426
93412: POP
// begin ToLua ( displayStucuk(); ) ;
93413: LD_STRING displayStucuk();
93415: PPUSH
93416: CALL_OW 559
// ResetFog ;
93420: CALL_OW 335
// end ; 3 :
93424: GO 93629
93426: LD_INT 3
93428: DOUBLE
93429: EQUAL
93430: IFTRUE 93434
93432: GO 93538
93434: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93435: LD_ADDR_VAR 0 2
93439: PUSH
93440: LD_INT 22
93442: PUSH
93443: LD_OWVAR 2
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PUSH
93452: LD_INT 25
93454: PUSH
93455: LD_INT 1
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: EMPTY
93463: LIST
93464: LIST
93465: PPUSH
93466: CALL_OW 69
93470: ST_TO_ADDR
// if not tmp then
93471: LD_VAR 0 2
93475: NOT
93476: IFFALSE 93480
// exit ;
93478: GO 93629
// un := tmp [ rand ( 1 , tmp ) ] ;
93480: LD_ADDR_VAR 0 3
93484: PUSH
93485: LD_VAR 0 2
93489: PUSH
93490: LD_INT 1
93492: PPUSH
93493: LD_VAR 0 2
93497: PPUSH
93498: CALL_OW 12
93502: ARRAY
93503: ST_TO_ADDR
// if Crawls ( un ) then
93504: LD_VAR 0 3
93508: PPUSH
93509: CALL_OW 318
93513: IFFALSE 93524
// ComWalk ( un ) ;
93515: LD_VAR 0 3
93519: PPUSH
93520: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93524: LD_VAR 0 3
93528: PPUSH
93529: LD_INT 8
93531: PPUSH
93532: CALL_OW 336
// end ; 4 :
93536: GO 93629
93538: LD_INT 4
93540: DOUBLE
93541: EQUAL
93542: IFTRUE 93546
93544: GO 93607
93546: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93547: LD_ADDR_VAR 0 2
93551: PUSH
93552: LD_INT 22
93554: PUSH
93555: LD_OWVAR 2
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 30
93566: PUSH
93567: LD_INT 29
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: PUSH
93574: EMPTY
93575: LIST
93576: LIST
93577: PPUSH
93578: CALL_OW 69
93582: ST_TO_ADDR
// if not tmp then
93583: LD_VAR 0 2
93587: NOT
93588: IFFALSE 93592
// exit ;
93590: GO 93629
// DestroyUnit ( tmp [ 1 ] ) ;
93592: LD_VAR 0 2
93596: PUSH
93597: LD_INT 1
93599: ARRAY
93600: PPUSH
93601: CALL_OW 65
// end ; 5 .. 7 :
93605: GO 93629
93607: LD_INT 5
93609: DOUBLE
93610: GREATEREQUAL
93611: IFFALSE 93619
93613: LD_INT 7
93615: DOUBLE
93616: LESSEQUAL
93617: IFTRUE 93621
93619: GO 93628
93621: POP
// StreamSibBomb ; end ;
93622: CALL 89879 0 0
93626: GO 93629
93628: POP
// end ;
93629: PPOPN 3
93631: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
93632: LD_EXP 83
93636: PUSH
93637: LD_EXP 133
93641: AND
93642: IFFALSE 93798
93644: GO 93646
93646: DISABLE
93647: LD_INT 0
93649: PPUSH
93650: PPUSH
93651: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
93652: LD_ADDR_VAR 0 2
93656: PUSH
93657: LD_INT 81
93659: PUSH
93660: LD_OWVAR 2
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 2
93671: PUSH
93672: LD_INT 21
93674: PUSH
93675: LD_INT 1
93677: PUSH
93678: EMPTY
93679: LIST
93680: LIST
93681: PUSH
93682: LD_INT 21
93684: PUSH
93685: LD_INT 2
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: LIST
93696: PUSH
93697: EMPTY
93698: LIST
93699: LIST
93700: PPUSH
93701: CALL_OW 69
93705: ST_TO_ADDR
// if not tmp then
93706: LD_VAR 0 2
93710: NOT
93711: IFFALSE 93715
// exit ;
93713: GO 93798
// p := 0 ;
93715: LD_ADDR_VAR 0 3
93719: PUSH
93720: LD_INT 0
93722: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93723: LD_INT 35
93725: PPUSH
93726: CALL_OW 67
// p := p + 1 ;
93730: LD_ADDR_VAR 0 3
93734: PUSH
93735: LD_VAR 0 3
93739: PUSH
93740: LD_INT 1
93742: PLUS
93743: ST_TO_ADDR
// for i in tmp do
93744: LD_ADDR_VAR 0 1
93748: PUSH
93749: LD_VAR 0 2
93753: PUSH
93754: FOR_IN
93755: IFFALSE 93786
// if GetLives ( i ) < 1000 then
93757: LD_VAR 0 1
93761: PPUSH
93762: CALL_OW 256
93766: PUSH
93767: LD_INT 1000
93769: LESS
93770: IFFALSE 93784
// SetLives ( i , 1000 ) ;
93772: LD_VAR 0 1
93776: PPUSH
93777: LD_INT 1000
93779: PPUSH
93780: CALL_OW 234
93784: GO 93754
93786: POP
93787: POP
// until p > 20 ;
93788: LD_VAR 0 3
93792: PUSH
93793: LD_INT 20
93795: GREATER
93796: IFFALSE 93723
// end ;
93798: PPOPN 3
93800: END
// every 0 0$1 trigger StreamModeActive and sTime do
93801: LD_EXP 83
93805: PUSH
93806: LD_EXP 134
93810: AND
93811: IFFALSE 93846
93813: GO 93815
93815: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
93816: LD_INT 28
93818: PPUSH
93819: LD_OWVAR 2
93823: PPUSH
93824: LD_INT 2
93826: PPUSH
93827: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
93831: LD_INT 30
93833: PPUSH
93834: LD_OWVAR 2
93838: PPUSH
93839: LD_INT 2
93841: PPUSH
93842: CALL_OW 322
// end ;
93846: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
93847: LD_EXP 83
93851: PUSH
93852: LD_EXP 135
93856: AND
93857: IFFALSE 93978
93859: GO 93861
93861: DISABLE
93862: LD_INT 0
93864: PPUSH
93865: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93866: LD_ADDR_VAR 0 2
93870: PUSH
93871: LD_INT 22
93873: PUSH
93874: LD_OWVAR 2
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 21
93885: PUSH
93886: LD_INT 1
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: PUSH
93893: LD_INT 3
93895: PUSH
93896: LD_INT 23
93898: PUSH
93899: LD_INT 0
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: PUSH
93906: EMPTY
93907: LIST
93908: LIST
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: LIST
93914: PPUSH
93915: CALL_OW 69
93919: ST_TO_ADDR
// if not tmp then
93920: LD_VAR 0 2
93924: NOT
93925: IFFALSE 93929
// exit ;
93927: GO 93978
// for i in tmp do
93929: LD_ADDR_VAR 0 1
93933: PUSH
93934: LD_VAR 0 2
93938: PUSH
93939: FOR_IN
93940: IFFALSE 93976
// begin if Crawls ( i ) then
93942: LD_VAR 0 1
93946: PPUSH
93947: CALL_OW 318
93951: IFFALSE 93962
// ComWalk ( i ) ;
93953: LD_VAR 0 1
93957: PPUSH
93958: CALL_OW 138
// SetClass ( i , 2 ) ;
93962: LD_VAR 0 1
93966: PPUSH
93967: LD_INT 2
93969: PPUSH
93970: CALL_OW 336
// end ;
93974: GO 93939
93976: POP
93977: POP
// end ;
93978: PPOPN 2
93980: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
93981: LD_EXP 83
93985: PUSH
93986: LD_EXP 136
93990: AND
93991: IFFALSE 94272
93993: GO 93995
93995: DISABLE
93996: LD_INT 0
93998: PPUSH
93999: PPUSH
94000: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
94001: LD_OWVAR 2
94005: PPUSH
94006: LD_INT 9
94008: PPUSH
94009: LD_INT 1
94011: PPUSH
94012: LD_INT 1
94014: PPUSH
94015: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
94019: LD_INT 9
94021: PPUSH
94022: LD_OWVAR 2
94026: PPUSH
94027: CALL_OW 343
// uc_side := 9 ;
94031: LD_ADDR_OWVAR 20
94035: PUSH
94036: LD_INT 9
94038: ST_TO_ADDR
// uc_nation := 2 ;
94039: LD_ADDR_OWVAR 21
94043: PUSH
94044: LD_INT 2
94046: ST_TO_ADDR
// hc_name := Dark Warrior ;
94047: LD_ADDR_OWVAR 26
94051: PUSH
94052: LD_STRING Dark Warrior
94054: ST_TO_ADDR
// hc_gallery :=  ;
94055: LD_ADDR_OWVAR 33
94059: PUSH
94060: LD_STRING 
94062: ST_TO_ADDR
// hc_noskilllimit := true ;
94063: LD_ADDR_OWVAR 76
94067: PUSH
94068: LD_INT 1
94070: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
94071: LD_ADDR_OWVAR 31
94075: PUSH
94076: LD_INT 30
94078: PUSH
94079: LD_INT 30
94081: PUSH
94082: LD_INT 30
94084: PUSH
94085: LD_INT 30
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: LIST
94092: LIST
94093: ST_TO_ADDR
// un := CreateHuman ;
94094: LD_ADDR_VAR 0 3
94098: PUSH
94099: CALL_OW 44
94103: ST_TO_ADDR
// hc_noskilllimit := false ;
94104: LD_ADDR_OWVAR 76
94108: PUSH
94109: LD_INT 0
94111: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94112: LD_VAR 0 3
94116: PPUSH
94117: LD_INT 1
94119: PPUSH
94120: CALL_OW 51
// p := 0 ;
94124: LD_ADDR_VAR 0 2
94128: PUSH
94129: LD_INT 0
94131: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94132: LD_INT 35
94134: PPUSH
94135: CALL_OW 67
// p := p + 1 ;
94139: LD_ADDR_VAR 0 2
94143: PUSH
94144: LD_VAR 0 2
94148: PUSH
94149: LD_INT 1
94151: PLUS
94152: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
94153: LD_VAR 0 3
94157: PPUSH
94158: CALL_OW 256
94162: PUSH
94163: LD_INT 1000
94165: LESS
94166: IFFALSE 94180
// SetLives ( un , 1000 ) ;
94168: LD_VAR 0 3
94172: PPUSH
94173: LD_INT 1000
94175: PPUSH
94176: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
94180: LD_VAR 0 3
94184: PPUSH
94185: LD_INT 81
94187: PUSH
94188: LD_OWVAR 2
94192: PUSH
94193: EMPTY
94194: LIST
94195: LIST
94196: PUSH
94197: LD_INT 91
94199: PUSH
94200: LD_VAR 0 3
94204: PUSH
94205: LD_INT 30
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: LIST
94212: PUSH
94213: EMPTY
94214: LIST
94215: LIST
94216: PPUSH
94217: CALL_OW 69
94221: PPUSH
94222: LD_VAR 0 3
94226: PPUSH
94227: CALL_OW 74
94231: PPUSH
94232: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
94236: LD_VAR 0 2
94240: PUSH
94241: LD_INT 60
94243: GREATER
94244: PUSH
94245: LD_VAR 0 3
94249: PPUSH
94250: CALL_OW 301
94254: OR
94255: IFFALSE 94132
// if un then
94257: LD_VAR 0 3
94261: IFFALSE 94272
// RemoveUnit ( un ) ;
94263: LD_VAR 0 3
94267: PPUSH
94268: CALL_OW 64
// end ;
94272: PPOPN 3
94274: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94275: LD_INT 0
94277: PPUSH
// case cmd of 301 :
94278: LD_VAR 0 1
94282: PUSH
94283: LD_INT 301
94285: DOUBLE
94286: EQUAL
94287: IFTRUE 94291
94289: GO 94323
94291: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
94292: LD_VAR 0 6
94296: PPUSH
94297: LD_VAR 0 7
94301: PPUSH
94302: LD_VAR 0 8
94306: PPUSH
94307: LD_VAR 0 4
94311: PPUSH
94312: LD_VAR 0 5
94316: PPUSH
94317: CALL 95524 0 5
94321: GO 94444
94323: LD_INT 302
94325: DOUBLE
94326: EQUAL
94327: IFTRUE 94331
94329: GO 94368
94331: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
94332: LD_VAR 0 6
94336: PPUSH
94337: LD_VAR 0 7
94341: PPUSH
94342: LD_VAR 0 8
94346: PPUSH
94347: LD_VAR 0 9
94351: PPUSH
94352: LD_VAR 0 4
94356: PPUSH
94357: LD_VAR 0 5
94361: PPUSH
94362: CALL 95615 0 6
94366: GO 94444
94368: LD_INT 303
94370: DOUBLE
94371: EQUAL
94372: IFTRUE 94376
94374: GO 94413
94376: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
94377: LD_VAR 0 6
94381: PPUSH
94382: LD_VAR 0 7
94386: PPUSH
94387: LD_VAR 0 8
94391: PPUSH
94392: LD_VAR 0 9
94396: PPUSH
94397: LD_VAR 0 4
94401: PPUSH
94402: LD_VAR 0 5
94406: PPUSH
94407: CALL 94449 0 6
94411: GO 94444
94413: LD_INT 304
94415: DOUBLE
94416: EQUAL
94417: IFTRUE 94421
94419: GO 94443
94421: POP
// hHackTeleport ( unit , x , y ) ; end ;
94422: LD_VAR 0 2
94426: PPUSH
94427: LD_VAR 0 4
94431: PPUSH
94432: LD_VAR 0 5
94436: PPUSH
94437: CALL 96208 0 3
94441: GO 94444
94443: POP
// end ;
94444: LD_VAR 0 12
94448: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
94449: LD_INT 0
94451: PPUSH
94452: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
94453: LD_VAR 0 1
94457: PUSH
94458: LD_INT 1
94460: LESS
94461: PUSH
94462: LD_VAR 0 1
94466: PUSH
94467: LD_INT 3
94469: GREATER
94470: OR
94471: PUSH
94472: LD_VAR 0 5
94476: PPUSH
94477: LD_VAR 0 6
94481: PPUSH
94482: CALL_OW 428
94486: OR
94487: IFFALSE 94491
// exit ;
94489: GO 95211
// uc_side := your_side ;
94491: LD_ADDR_OWVAR 20
94495: PUSH
94496: LD_OWVAR 2
94500: ST_TO_ADDR
// uc_nation := nation ;
94501: LD_ADDR_OWVAR 21
94505: PUSH
94506: LD_VAR 0 1
94510: ST_TO_ADDR
// bc_level = 1 ;
94511: LD_ADDR_OWVAR 43
94515: PUSH
94516: LD_INT 1
94518: ST_TO_ADDR
// case btype of 1 :
94519: LD_VAR 0 2
94523: PUSH
94524: LD_INT 1
94526: DOUBLE
94527: EQUAL
94528: IFTRUE 94532
94530: GO 94543
94532: POP
// bc_type := b_depot ; 2 :
94533: LD_ADDR_OWVAR 42
94537: PUSH
94538: LD_INT 0
94540: ST_TO_ADDR
94541: GO 95155
94543: LD_INT 2
94545: DOUBLE
94546: EQUAL
94547: IFTRUE 94551
94549: GO 94562
94551: POP
// bc_type := b_warehouse ; 3 :
94552: LD_ADDR_OWVAR 42
94556: PUSH
94557: LD_INT 1
94559: ST_TO_ADDR
94560: GO 95155
94562: LD_INT 3
94564: DOUBLE
94565: EQUAL
94566: IFTRUE 94570
94568: GO 94581
94570: POP
// bc_type := b_lab ; 4 .. 9 :
94571: LD_ADDR_OWVAR 42
94575: PUSH
94576: LD_INT 6
94578: ST_TO_ADDR
94579: GO 95155
94581: LD_INT 4
94583: DOUBLE
94584: GREATEREQUAL
94585: IFFALSE 94593
94587: LD_INT 9
94589: DOUBLE
94590: LESSEQUAL
94591: IFTRUE 94595
94593: GO 94647
94595: POP
// begin bc_type := b_lab_half ;
94596: LD_ADDR_OWVAR 42
94600: PUSH
94601: LD_INT 7
94603: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
94604: LD_ADDR_OWVAR 44
94608: PUSH
94609: LD_INT 10
94611: PUSH
94612: LD_INT 11
94614: PUSH
94615: LD_INT 12
94617: PUSH
94618: LD_INT 15
94620: PUSH
94621: LD_INT 14
94623: PUSH
94624: LD_INT 13
94626: PUSH
94627: EMPTY
94628: LIST
94629: LIST
94630: LIST
94631: LIST
94632: LIST
94633: LIST
94634: PUSH
94635: LD_VAR 0 2
94639: PUSH
94640: LD_INT 3
94642: MINUS
94643: ARRAY
94644: ST_TO_ADDR
// end ; 10 .. 13 :
94645: GO 95155
94647: LD_INT 10
94649: DOUBLE
94650: GREATEREQUAL
94651: IFFALSE 94659
94653: LD_INT 13
94655: DOUBLE
94656: LESSEQUAL
94657: IFTRUE 94661
94659: GO 94738
94661: POP
// begin bc_type := b_lab_full ;
94662: LD_ADDR_OWVAR 42
94666: PUSH
94667: LD_INT 8
94669: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
94670: LD_ADDR_OWVAR 44
94674: PUSH
94675: LD_INT 10
94677: PUSH
94678: LD_INT 12
94680: PUSH
94681: LD_INT 14
94683: PUSH
94684: LD_INT 13
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: PUSH
94693: LD_VAR 0 2
94697: PUSH
94698: LD_INT 9
94700: MINUS
94701: ARRAY
94702: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
94703: LD_ADDR_OWVAR 45
94707: PUSH
94708: LD_INT 11
94710: PUSH
94711: LD_INT 15
94713: PUSH
94714: LD_INT 12
94716: PUSH
94717: LD_INT 15
94719: PUSH
94720: EMPTY
94721: LIST
94722: LIST
94723: LIST
94724: LIST
94725: PUSH
94726: LD_VAR 0 2
94730: PUSH
94731: LD_INT 9
94733: MINUS
94734: ARRAY
94735: ST_TO_ADDR
// end ; 14 :
94736: GO 95155
94738: LD_INT 14
94740: DOUBLE
94741: EQUAL
94742: IFTRUE 94746
94744: GO 94757
94746: POP
// bc_type := b_workshop ; 15 :
94747: LD_ADDR_OWVAR 42
94751: PUSH
94752: LD_INT 2
94754: ST_TO_ADDR
94755: GO 95155
94757: LD_INT 15
94759: DOUBLE
94760: EQUAL
94761: IFTRUE 94765
94763: GO 94776
94765: POP
// bc_type := b_factory ; 16 :
94766: LD_ADDR_OWVAR 42
94770: PUSH
94771: LD_INT 3
94773: ST_TO_ADDR
94774: GO 95155
94776: LD_INT 16
94778: DOUBLE
94779: EQUAL
94780: IFTRUE 94784
94782: GO 94795
94784: POP
// bc_type := b_ext_gun ; 17 :
94785: LD_ADDR_OWVAR 42
94789: PUSH
94790: LD_INT 17
94792: ST_TO_ADDR
94793: GO 95155
94795: LD_INT 17
94797: DOUBLE
94798: EQUAL
94799: IFTRUE 94803
94801: GO 94831
94803: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
94804: LD_ADDR_OWVAR 42
94808: PUSH
94809: LD_INT 19
94811: PUSH
94812: LD_INT 23
94814: PUSH
94815: LD_INT 19
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: LIST
94822: PUSH
94823: LD_VAR 0 1
94827: ARRAY
94828: ST_TO_ADDR
94829: GO 95155
94831: LD_INT 18
94833: DOUBLE
94834: EQUAL
94835: IFTRUE 94839
94837: GO 94850
94839: POP
// bc_type := b_ext_radar ; 19 :
94840: LD_ADDR_OWVAR 42
94844: PUSH
94845: LD_INT 20
94847: ST_TO_ADDR
94848: GO 95155
94850: LD_INT 19
94852: DOUBLE
94853: EQUAL
94854: IFTRUE 94858
94856: GO 94869
94858: POP
// bc_type := b_ext_radio ; 20 :
94859: LD_ADDR_OWVAR 42
94863: PUSH
94864: LD_INT 22
94866: ST_TO_ADDR
94867: GO 95155
94869: LD_INT 20
94871: DOUBLE
94872: EQUAL
94873: IFTRUE 94877
94875: GO 94888
94877: POP
// bc_type := b_ext_siberium ; 21 :
94878: LD_ADDR_OWVAR 42
94882: PUSH
94883: LD_INT 21
94885: ST_TO_ADDR
94886: GO 95155
94888: LD_INT 21
94890: DOUBLE
94891: EQUAL
94892: IFTRUE 94896
94894: GO 94907
94896: POP
// bc_type := b_ext_computer ; 22 :
94897: LD_ADDR_OWVAR 42
94901: PUSH
94902: LD_INT 24
94904: ST_TO_ADDR
94905: GO 95155
94907: LD_INT 22
94909: DOUBLE
94910: EQUAL
94911: IFTRUE 94915
94913: GO 94926
94915: POP
// bc_type := b_ext_track ; 23 :
94916: LD_ADDR_OWVAR 42
94920: PUSH
94921: LD_INT 16
94923: ST_TO_ADDR
94924: GO 95155
94926: LD_INT 23
94928: DOUBLE
94929: EQUAL
94930: IFTRUE 94934
94932: GO 94945
94934: POP
// bc_type := b_ext_laser ; 24 :
94935: LD_ADDR_OWVAR 42
94939: PUSH
94940: LD_INT 25
94942: ST_TO_ADDR
94943: GO 95155
94945: LD_INT 24
94947: DOUBLE
94948: EQUAL
94949: IFTRUE 94953
94951: GO 94964
94953: POP
// bc_type := b_control_tower ; 25 :
94954: LD_ADDR_OWVAR 42
94958: PUSH
94959: LD_INT 36
94961: ST_TO_ADDR
94962: GO 95155
94964: LD_INT 25
94966: DOUBLE
94967: EQUAL
94968: IFTRUE 94972
94970: GO 94983
94972: POP
// bc_type := b_breastwork ; 26 :
94973: LD_ADDR_OWVAR 42
94977: PUSH
94978: LD_INT 31
94980: ST_TO_ADDR
94981: GO 95155
94983: LD_INT 26
94985: DOUBLE
94986: EQUAL
94987: IFTRUE 94991
94989: GO 95002
94991: POP
// bc_type := b_bunker ; 27 :
94992: LD_ADDR_OWVAR 42
94996: PUSH
94997: LD_INT 32
94999: ST_TO_ADDR
95000: GO 95155
95002: LD_INT 27
95004: DOUBLE
95005: EQUAL
95006: IFTRUE 95010
95008: GO 95021
95010: POP
// bc_type := b_turret ; 28 :
95011: LD_ADDR_OWVAR 42
95015: PUSH
95016: LD_INT 33
95018: ST_TO_ADDR
95019: GO 95155
95021: LD_INT 28
95023: DOUBLE
95024: EQUAL
95025: IFTRUE 95029
95027: GO 95040
95029: POP
// bc_type := b_armoury ; 29 :
95030: LD_ADDR_OWVAR 42
95034: PUSH
95035: LD_INT 4
95037: ST_TO_ADDR
95038: GO 95155
95040: LD_INT 29
95042: DOUBLE
95043: EQUAL
95044: IFTRUE 95048
95046: GO 95059
95048: POP
// bc_type := b_barracks ; 30 :
95049: LD_ADDR_OWVAR 42
95053: PUSH
95054: LD_INT 5
95056: ST_TO_ADDR
95057: GO 95155
95059: LD_INT 30
95061: DOUBLE
95062: EQUAL
95063: IFTRUE 95067
95065: GO 95078
95067: POP
// bc_type := b_solar_power ; 31 :
95068: LD_ADDR_OWVAR 42
95072: PUSH
95073: LD_INT 27
95075: ST_TO_ADDR
95076: GO 95155
95078: LD_INT 31
95080: DOUBLE
95081: EQUAL
95082: IFTRUE 95086
95084: GO 95097
95086: POP
// bc_type := b_oil_power ; 32 :
95087: LD_ADDR_OWVAR 42
95091: PUSH
95092: LD_INT 26
95094: ST_TO_ADDR
95095: GO 95155
95097: LD_INT 32
95099: DOUBLE
95100: EQUAL
95101: IFTRUE 95105
95103: GO 95116
95105: POP
// bc_type := b_siberite_power ; 33 :
95106: LD_ADDR_OWVAR 42
95110: PUSH
95111: LD_INT 28
95113: ST_TO_ADDR
95114: GO 95155
95116: LD_INT 33
95118: DOUBLE
95119: EQUAL
95120: IFTRUE 95124
95122: GO 95135
95124: POP
// bc_type := b_oil_mine ; 34 :
95125: LD_ADDR_OWVAR 42
95129: PUSH
95130: LD_INT 29
95132: ST_TO_ADDR
95133: GO 95155
95135: LD_INT 34
95137: DOUBLE
95138: EQUAL
95139: IFTRUE 95143
95141: GO 95154
95143: POP
// bc_type := b_siberite_mine ; end ;
95144: LD_ADDR_OWVAR 42
95148: PUSH
95149: LD_INT 30
95151: ST_TO_ADDR
95152: GO 95155
95154: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
95155: LD_ADDR_VAR 0 8
95159: PUSH
95160: LD_VAR 0 5
95164: PPUSH
95165: LD_VAR 0 6
95169: PPUSH
95170: LD_VAR 0 3
95174: PPUSH
95175: CALL_OW 47
95179: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
95180: LD_OWVAR 42
95184: PUSH
95185: LD_INT 32
95187: PUSH
95188: LD_INT 33
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: IN
95195: IFFALSE 95211
// PlaceWeaponTurret ( b , weapon ) ;
95197: LD_VAR 0 8
95201: PPUSH
95202: LD_VAR 0 4
95206: PPUSH
95207: CALL_OW 431
// end ;
95211: LD_VAR 0 7
95215: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
95216: LD_INT 0
95218: PPUSH
95219: PPUSH
95220: PPUSH
95221: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95222: LD_ADDR_VAR 0 4
95226: PUSH
95227: LD_INT 22
95229: PUSH
95230: LD_OWVAR 2
95234: PUSH
95235: EMPTY
95236: LIST
95237: LIST
95238: PUSH
95239: LD_INT 2
95241: PUSH
95242: LD_INT 30
95244: PUSH
95245: LD_INT 0
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: PUSH
95252: LD_INT 30
95254: PUSH
95255: LD_INT 1
95257: PUSH
95258: EMPTY
95259: LIST
95260: LIST
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: LIST
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: PPUSH
95271: CALL_OW 69
95275: ST_TO_ADDR
// if not tmp then
95276: LD_VAR 0 4
95280: NOT
95281: IFFALSE 95285
// exit ;
95283: GO 95344
// for i in tmp do
95285: LD_ADDR_VAR 0 2
95289: PUSH
95290: LD_VAR 0 4
95294: PUSH
95295: FOR_IN
95296: IFFALSE 95342
// for j = 1 to 3 do
95298: LD_ADDR_VAR 0 3
95302: PUSH
95303: DOUBLE
95304: LD_INT 1
95306: DEC
95307: ST_TO_ADDR
95308: LD_INT 3
95310: PUSH
95311: FOR_TO
95312: IFFALSE 95338
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
95314: LD_VAR 0 2
95318: PPUSH
95319: CALL_OW 274
95323: PPUSH
95324: LD_VAR 0 3
95328: PPUSH
95329: LD_INT 99999
95331: PPUSH
95332: CALL_OW 277
95336: GO 95311
95338: POP
95339: POP
95340: GO 95295
95342: POP
95343: POP
// end ;
95344: LD_VAR 0 1
95348: RET
// export function hHackSetLevel10 ; var i , j ; begin
95349: LD_INT 0
95351: PPUSH
95352: PPUSH
95353: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95354: LD_ADDR_VAR 0 2
95358: PUSH
95359: LD_INT 21
95361: PUSH
95362: LD_INT 1
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PPUSH
95369: CALL_OW 69
95373: PUSH
95374: FOR_IN
95375: IFFALSE 95427
// if IsSelected ( i ) then
95377: LD_VAR 0 2
95381: PPUSH
95382: CALL_OW 306
95386: IFFALSE 95425
// begin for j := 1 to 4 do
95388: LD_ADDR_VAR 0 3
95392: PUSH
95393: DOUBLE
95394: LD_INT 1
95396: DEC
95397: ST_TO_ADDR
95398: LD_INT 4
95400: PUSH
95401: FOR_TO
95402: IFFALSE 95423
// SetSkill ( i , j , 10 ) ;
95404: LD_VAR 0 2
95408: PPUSH
95409: LD_VAR 0 3
95413: PPUSH
95414: LD_INT 10
95416: PPUSH
95417: CALL_OW 237
95421: GO 95401
95423: POP
95424: POP
// end ;
95425: GO 95374
95427: POP
95428: POP
// end ;
95429: LD_VAR 0 1
95433: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
95434: LD_INT 0
95436: PPUSH
95437: PPUSH
95438: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
95439: LD_ADDR_VAR 0 2
95443: PUSH
95444: LD_INT 22
95446: PUSH
95447: LD_OWVAR 2
95451: PUSH
95452: EMPTY
95453: LIST
95454: LIST
95455: PUSH
95456: LD_INT 21
95458: PUSH
95459: LD_INT 1
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: PUSH
95466: EMPTY
95467: LIST
95468: LIST
95469: PPUSH
95470: CALL_OW 69
95474: PUSH
95475: FOR_IN
95476: IFFALSE 95517
// begin for j := 1 to 4 do
95478: LD_ADDR_VAR 0 3
95482: PUSH
95483: DOUBLE
95484: LD_INT 1
95486: DEC
95487: ST_TO_ADDR
95488: LD_INT 4
95490: PUSH
95491: FOR_TO
95492: IFFALSE 95513
// SetSkill ( i , j , 10 ) ;
95494: LD_VAR 0 2
95498: PPUSH
95499: LD_VAR 0 3
95503: PPUSH
95504: LD_INT 10
95506: PPUSH
95507: CALL_OW 237
95511: GO 95491
95513: POP
95514: POP
// end ;
95515: GO 95475
95517: POP
95518: POP
// end ;
95519: LD_VAR 0 1
95523: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
95524: LD_INT 0
95526: PPUSH
// uc_side := your_side ;
95527: LD_ADDR_OWVAR 20
95531: PUSH
95532: LD_OWVAR 2
95536: ST_TO_ADDR
// uc_nation := nation ;
95537: LD_ADDR_OWVAR 21
95541: PUSH
95542: LD_VAR 0 1
95546: ST_TO_ADDR
// InitHc ;
95547: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
95551: LD_INT 0
95553: PPUSH
95554: LD_VAR 0 2
95558: PPUSH
95559: LD_VAR 0 3
95563: PPUSH
95564: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
95568: LD_VAR 0 4
95572: PPUSH
95573: LD_VAR 0 5
95577: PPUSH
95578: CALL_OW 428
95582: PUSH
95583: LD_INT 0
95585: EQUAL
95586: IFFALSE 95610
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
95588: CALL_OW 44
95592: PPUSH
95593: LD_VAR 0 4
95597: PPUSH
95598: LD_VAR 0 5
95602: PPUSH
95603: LD_INT 1
95605: PPUSH
95606: CALL_OW 48
// end ;
95610: LD_VAR 0 6
95614: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
95615: LD_INT 0
95617: PPUSH
95618: PPUSH
// uc_side := your_side ;
95619: LD_ADDR_OWVAR 20
95623: PUSH
95624: LD_OWVAR 2
95628: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
95629: LD_VAR 0 1
95633: PUSH
95634: LD_INT 1
95636: PUSH
95637: LD_INT 2
95639: PUSH
95640: LD_INT 3
95642: PUSH
95643: LD_INT 4
95645: PUSH
95646: LD_INT 5
95648: PUSH
95649: EMPTY
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: IN
95656: IFFALSE 95668
// uc_nation := nation_american else
95658: LD_ADDR_OWVAR 21
95662: PUSH
95663: LD_INT 1
95665: ST_TO_ADDR
95666: GO 95711
// if chassis in [ 11 , 12 , 13 , 14 ] then
95668: LD_VAR 0 1
95672: PUSH
95673: LD_INT 11
95675: PUSH
95676: LD_INT 12
95678: PUSH
95679: LD_INT 13
95681: PUSH
95682: LD_INT 14
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: IN
95691: IFFALSE 95703
// uc_nation := nation_arabian else
95693: LD_ADDR_OWVAR 21
95697: PUSH
95698: LD_INT 2
95700: ST_TO_ADDR
95701: GO 95711
// uc_nation := nation_russian ;
95703: LD_ADDR_OWVAR 21
95707: PUSH
95708: LD_INT 3
95710: ST_TO_ADDR
// vc_chassis := chassis ;
95711: LD_ADDR_OWVAR 37
95715: PUSH
95716: LD_VAR 0 1
95720: ST_TO_ADDR
// vc_engine := engine ;
95721: LD_ADDR_OWVAR 39
95725: PUSH
95726: LD_VAR 0 2
95730: ST_TO_ADDR
// vc_control := control ;
95731: LD_ADDR_OWVAR 38
95735: PUSH
95736: LD_VAR 0 3
95740: ST_TO_ADDR
// vc_weapon := weapon ;
95741: LD_ADDR_OWVAR 40
95745: PUSH
95746: LD_VAR 0 4
95750: ST_TO_ADDR
// un := CreateVehicle ;
95751: LD_ADDR_VAR 0 8
95755: PUSH
95756: CALL_OW 45
95760: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
95761: LD_VAR 0 8
95765: PPUSH
95766: LD_INT 0
95768: PPUSH
95769: LD_INT 5
95771: PPUSH
95772: CALL_OW 12
95776: PPUSH
95777: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
95781: LD_VAR 0 8
95785: PPUSH
95786: LD_VAR 0 5
95790: PPUSH
95791: LD_VAR 0 6
95795: PPUSH
95796: LD_INT 1
95798: PPUSH
95799: CALL_OW 48
// end ;
95803: LD_VAR 0 7
95807: RET
// export hInvincible ; every 1 do
95808: GO 95810
95810: DISABLE
// hInvincible := [ ] ;
95811: LD_ADDR_EXP 137
95815: PUSH
95816: EMPTY
95817: ST_TO_ADDR
95818: END
// every 10 do var i ;
95819: GO 95821
95821: DISABLE
95822: LD_INT 0
95824: PPUSH
// begin enable ;
95825: ENABLE
// if not hInvincible then
95826: LD_EXP 137
95830: NOT
95831: IFFALSE 95835
// exit ;
95833: GO 95879
// for i in hInvincible do
95835: LD_ADDR_VAR 0 1
95839: PUSH
95840: LD_EXP 137
95844: PUSH
95845: FOR_IN
95846: IFFALSE 95877
// if GetLives ( i ) < 1000 then
95848: LD_VAR 0 1
95852: PPUSH
95853: CALL_OW 256
95857: PUSH
95858: LD_INT 1000
95860: LESS
95861: IFFALSE 95875
// SetLives ( i , 1000 ) ;
95863: LD_VAR 0 1
95867: PPUSH
95868: LD_INT 1000
95870: PPUSH
95871: CALL_OW 234
95875: GO 95845
95877: POP
95878: POP
// end ;
95879: PPOPN 1
95881: END
// export function hHackInvincible ; var i ; begin
95882: LD_INT 0
95884: PPUSH
95885: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
95886: LD_ADDR_VAR 0 2
95890: PUSH
95891: LD_INT 2
95893: PUSH
95894: LD_INT 21
95896: PUSH
95897: LD_INT 1
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 21
95906: PUSH
95907: LD_INT 2
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: LIST
95918: PPUSH
95919: CALL_OW 69
95923: PUSH
95924: FOR_IN
95925: IFFALSE 95986
// if IsSelected ( i ) then
95927: LD_VAR 0 2
95931: PPUSH
95932: CALL_OW 306
95936: IFFALSE 95984
// begin if i in hInvincible then
95938: LD_VAR 0 2
95942: PUSH
95943: LD_EXP 137
95947: IN
95948: IFFALSE 95968
// hInvincible := hInvincible diff i else
95950: LD_ADDR_EXP 137
95954: PUSH
95955: LD_EXP 137
95959: PUSH
95960: LD_VAR 0 2
95964: DIFF
95965: ST_TO_ADDR
95966: GO 95984
// hInvincible := hInvincible union i ;
95968: LD_ADDR_EXP 137
95972: PUSH
95973: LD_EXP 137
95977: PUSH
95978: LD_VAR 0 2
95982: UNION
95983: ST_TO_ADDR
// end ;
95984: GO 95924
95986: POP
95987: POP
// end ;
95988: LD_VAR 0 1
95992: RET
// export function hHackInvisible ; var i , j ; begin
95993: LD_INT 0
95995: PPUSH
95996: PPUSH
95997: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95998: LD_ADDR_VAR 0 2
96002: PUSH
96003: LD_INT 21
96005: PUSH
96006: LD_INT 1
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PPUSH
96013: CALL_OW 69
96017: PUSH
96018: FOR_IN
96019: IFFALSE 96043
// if IsSelected ( i ) then
96021: LD_VAR 0 2
96025: PPUSH
96026: CALL_OW 306
96030: IFFALSE 96041
// ComForceInvisible ( i ) ;
96032: LD_VAR 0 2
96036: PPUSH
96037: CALL_OW 496
96041: GO 96018
96043: POP
96044: POP
// end ;
96045: LD_VAR 0 1
96049: RET
// export function hHackChangeYourSide ; begin
96050: LD_INT 0
96052: PPUSH
// if your_side = 8 then
96053: LD_OWVAR 2
96057: PUSH
96058: LD_INT 8
96060: EQUAL
96061: IFFALSE 96073
// your_side := 0 else
96063: LD_ADDR_OWVAR 2
96067: PUSH
96068: LD_INT 0
96070: ST_TO_ADDR
96071: GO 96087
// your_side := your_side + 1 ;
96073: LD_ADDR_OWVAR 2
96077: PUSH
96078: LD_OWVAR 2
96082: PUSH
96083: LD_INT 1
96085: PLUS
96086: ST_TO_ADDR
// end ;
96087: LD_VAR 0 1
96091: RET
// export function hHackChangeUnitSide ; var i , j ; begin
96092: LD_INT 0
96094: PPUSH
96095: PPUSH
96096: PPUSH
// for i in all_units do
96097: LD_ADDR_VAR 0 2
96101: PUSH
96102: LD_OWVAR 3
96106: PUSH
96107: FOR_IN
96108: IFFALSE 96186
// if IsSelected ( i ) then
96110: LD_VAR 0 2
96114: PPUSH
96115: CALL_OW 306
96119: IFFALSE 96184
// begin j := GetSide ( i ) ;
96121: LD_ADDR_VAR 0 3
96125: PUSH
96126: LD_VAR 0 2
96130: PPUSH
96131: CALL_OW 255
96135: ST_TO_ADDR
// if j = 8 then
96136: LD_VAR 0 3
96140: PUSH
96141: LD_INT 8
96143: EQUAL
96144: IFFALSE 96156
// j := 0 else
96146: LD_ADDR_VAR 0 3
96150: PUSH
96151: LD_INT 0
96153: ST_TO_ADDR
96154: GO 96170
// j := j + 1 ;
96156: LD_ADDR_VAR 0 3
96160: PUSH
96161: LD_VAR 0 3
96165: PUSH
96166: LD_INT 1
96168: PLUS
96169: ST_TO_ADDR
// SetSide ( i , j ) ;
96170: LD_VAR 0 2
96174: PPUSH
96175: LD_VAR 0 3
96179: PPUSH
96180: CALL_OW 235
// end ;
96184: GO 96107
96186: POP
96187: POP
// end ;
96188: LD_VAR 0 1
96192: RET
// export function hHackFog ; begin
96193: LD_INT 0
96195: PPUSH
// FogOff ( true ) ;
96196: LD_INT 1
96198: PPUSH
96199: CALL_OW 344
// end ;
96203: LD_VAR 0 1
96207: RET
// export function hHackTeleport ( unit , x , y ) ; begin
96208: LD_INT 0
96210: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
96211: LD_VAR 0 1
96215: PPUSH
96216: LD_VAR 0 2
96220: PPUSH
96221: LD_VAR 0 3
96225: PPUSH
96226: LD_INT 1
96228: PPUSH
96229: LD_INT 1
96231: PPUSH
96232: CALL_OW 483
// CenterOnXY ( x , y ) ;
96236: LD_VAR 0 2
96240: PPUSH
96241: LD_VAR 0 3
96245: PPUSH
96246: CALL_OW 84
// end ;
96250: LD_VAR 0 4
96254: RET
