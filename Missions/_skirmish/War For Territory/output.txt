// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 80071 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 44081 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 44081 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 44081 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 44081 0 9
// PrepareGensher ;
 189: CALL 3017 0 0
// PreparePopov ;
 193: CALL 6085 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 8773 0 0
// MC_Start ( ) ;
 205: CALL 51757 0 0
// Action ;
 209: CALL 9180 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 4151 0 0
// InitMC_Powell ( ) ;
 284: CALL 1515 0 0
// InitMC_Popov ( ) ;
 288: CALL 7243 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
 599: PPUSH
// powell_side := 4 ;
 600: LD_ADDR_EXP 11
 604: PUSH
 605: LD_INT 4
 607: ST_TO_ADDR
// uc_side := powell_side ;
 608: LD_ADDR_OWVAR 20
 612: PUSH
 613: LD_EXP 11
 617: ST_TO_ADDR
// uc_nation := 1 ;
 618: LD_ADDR_OWVAR 21
 622: PUSH
 623: LD_INT 1
 625: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 626: LD_ADDR_EXP 10
 630: PUSH
 631: LD_STRING Powell
 633: PPUSH
 634: CALL_OW 25
 638: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 639: LD_EXP 10
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 7
 649: PPUSH
 650: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 654: LD_EXP 10
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 5
 664: PPUSH
 665: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 669: LD_EXP 10
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: LD_INT 6
 679: PPUSH
 680: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 684: LD_EXP 10
 688: PPUSH
 689: LD_INT 4
 691: PPUSH
 692: LD_INT 4
 694: PPUSH
 695: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 699: LD_EXP 10
 703: PPUSH
 704: LD_INT 4
 706: PPUSH
 707: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 711: LD_ADDR_VAR 0 3
 715: PUSH
 716: LD_INT 5
 718: PUSH
 719: LD_INT 178
 721: PUSH
 722: LD_INT 117
 724: PUSH
 725: LD_INT 2
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 29
 736: PUSH
 737: LD_INT 167
 739: PUSH
 740: LD_INT 102
 742: PUSH
 743: LD_INT 0
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 6
 754: PUSH
 755: LD_INT 200
 757: PUSH
 758: LD_INT 111
 760: PUSH
 761: LD_INT 4
 763: PUSH
 764: LD_INT 10
 766: PUSH
 767: LD_INT 11
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 201
 783: PUSH
 784: LD_INT 140
 786: PUSH
 787: LD_INT 4
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 27
 798: PUSH
 799: LD_INT 206
 801: PUSH
 802: LD_INT 124
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 27
 816: PUSH
 817: LD_INT 209
 819: PUSH
 820: LD_INT 128
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_INT 27
 834: PUSH
 835: LD_INT 211
 837: PUSH
 838: LD_INT 132
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 173
 855: PUSH
 856: LD_INT 83
 858: PUSH
 859: LD_INT 3
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 6
 870: PUSH
 871: LD_INT 186
 873: PUSH
 874: LD_INT 103
 876: PUSH
 877: LD_INT 2
 879: PUSH
 880: LD_INT 12
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: PUSH
 894: LD_INT 33
 896: PUSH
 897: LD_INT 173
 899: PUSH
 900: LD_INT 99
 902: PUSH
 903: LD_INT 2
 905: PUSH
 906: LD_INT 6
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 32
 918: PUSH
 919: LD_INT 174
 921: PUSH
 922: LD_INT 102
 924: PUSH
 925: LD_INT 2
 927: PUSH
 928: LD_INT 6
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PUSH
 938: LD_INT 32
 940: PUSH
 941: LD_INT 178
 943: PUSH
 944: LD_INT 100
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 6
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 33
 962: PUSH
 963: LD_INT 174
 965: PUSH
 966: LD_INT 108
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: LD_INT 7
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 33
 984: PUSH
 985: LD_INT 182
 987: PUSH
 988: LD_INT 122
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 7
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 36
1006: PUSH
1007: LD_INT 194
1009: PUSH
1010: LD_INT 124
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: LD_INT 184
1027: PUSH
1028: LD_INT 141
1030: PUSH
1031: LD_INT 1
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: PUSH
1044: LD_INT 33
1046: PUSH
1047: LD_INT 183
1049: PUSH
1050: LD_INT 131
1052: PUSH
1053: LD_INT 2
1055: PUSH
1056: LD_INT 11
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_INT 33
1068: PUSH
1069: LD_INT 194
1071: PUSH
1072: LD_INT 146
1074: PUSH
1075: LD_INT 4
1077: PUSH
1078: LD_INT 7
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: LD_INT 33
1090: PUSH
1091: LD_INT 190
1093: PUSH
1094: LD_INT 142
1096: PUSH
1097: LD_INT 4
1099: PUSH
1100: LD_INT 7
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 28
1112: PUSH
1113: LD_INT 204
1115: PUSH
1116: LD_INT 133
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 201
1133: PUSH
1134: LD_INT 133
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 28
1148: PUSH
1149: LD_INT 199
1151: PUSH
1152: LD_INT 119
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: ST_TO_ADDR
// for i in list do
1188: LD_ADDR_VAR 0 2
1192: PUSH
1193: LD_VAR 0 3
1197: PUSH
1198: FOR_IN
1199: IFFALSE 1377
// begin uc_side := 4 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 4
1208: ST_TO_ADDR
// uc_nation := 1 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// bc_kind1 := - 1 ;
1231: LD_ADDR_OWVAR 44
1235: PUSH
1236: LD_INT 1
1238: NEG
1239: ST_TO_ADDR
// bc_kind2 := - 1 ;
1240: LD_ADDR_OWVAR 45
1244: PUSH
1245: LD_INT 1
1247: NEG
1248: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1249: LD_VAR 0 2
1253: PUSH
1254: LD_INT 1
1256: ARRAY
1257: PUSH
1258: LD_INT 6
1260: EQUAL
1261: IFFALSE 1299
// begin bc_type := b_lab_full ;
1263: LD_ADDR_OWVAR 42
1267: PUSH
1268: LD_INT 8
1270: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1271: LD_ADDR_OWVAR 44
1275: PUSH
1276: LD_VAR 0 2
1280: PUSH
1281: LD_INT 5
1283: ARRAY
1284: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1285: LD_ADDR_OWVAR 45
1289: PUSH
1290: LD_VAR 0 2
1294: PUSH
1295: LD_INT 6
1297: ARRAY
1298: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1299: LD_ADDR_VAR 0 4
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 2
1311: ARRAY
1312: PPUSH
1313: LD_VAR 0 2
1317: PUSH
1318: LD_INT 3
1320: ARRAY
1321: PPUSH
1322: LD_VAR 0 2
1326: PUSH
1327: LD_INT 4
1329: ARRAY
1330: PPUSH
1331: CALL_OW 47
1335: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1336: LD_VAR 0 2
1340: PUSH
1341: LD_INT 1
1343: ARRAY
1344: PUSH
1345: LD_INT 33
1347: PUSH
1348: LD_INT 32
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: IN
1355: IFFALSE 1375
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1357: LD_VAR 0 4
1361: PPUSH
1362: LD_VAR 0 2
1366: PUSH
1367: LD_INT 5
1369: ARRAY
1370: PPUSH
1371: CALL_OW 431
// end ;
1375: GO 1198
1377: POP
1378: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1379: LD_ADDR_VAR 0 5
1383: PUSH
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_STRING 
1392: PPUSH
1393: LD_INT 8
1395: PUSH
1396: LD_INT 7
1398: PUSH
1399: LD_INT 6
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: PUSH
1407: LD_OWVAR 67
1411: ARRAY
1412: PPUSH
1413: LD_INT 5500
1415: PUSH
1416: LD_INT 500
1418: PUSH
1419: LD_INT 0
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: LIST
1426: PPUSH
1427: LD_INT 6
1429: PUSH
1430: LD_INT 6
1432: PUSH
1433: LD_INT 6
1435: PUSH
1436: LD_INT 6
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 19028 0 6
1449: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1450: LD_ADDR_EXP 23
1454: PUSH
1455: LD_EXP 23
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: LD_VAR 0 5
1467: PUSH
1468: LD_INT 22
1470: PUSH
1471: LD_INT 4
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: PUSH
1478: LD_INT 21
1480: PUSH
1481: LD_INT 3
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PPUSH
1492: CALL_OW 69
1496: UNION
1497: PPUSH
1498: CALL_OW 1
1502: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1503: LD_ADDR_EXP 12
1507: PUSH
1508: EMPTY
1509: ST_TO_ADDR
// end ;
1510: LD_VAR 0 1
1514: RET
// export function InitMC_Powell ( ) ; begin
1515: LD_INT 0
1517: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1518: LD_INT 1
1520: PPUSH
1521: LD_INT 1
1523: PPUSH
1524: CALL 74938 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1528: LD_INT 1
1530: PPUSH
1531: LD_INT 6
1533: PPUSH
1534: CALL 74882 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1538: LD_INT 1
1540: PPUSH
1541: LD_INT 167
1543: PUSH
1544: LD_INT 102
1546: PUSH
1547: LD_INT 0
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 173
1557: PUSH
1558: LD_INT 83
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 171
1571: PUSH
1572: LD_INT 141
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 178
1585: PUSH
1586: LD_INT 148
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: PPUSH
1603: CALL 73941 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1607: LD_INT 1
1609: PPUSH
1610: LD_INT 11
1612: PUSH
1613: LD_INT 6
1615: PUSH
1616: LD_INT 7
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PPUSH
1624: CALL 74770 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 5
1633: PPUSH
1634: CALL 74452 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 4
1643: PPUSH
1644: CALL 74183 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1648: LD_INT 1
1650: PPUSH
1651: LD_INT 4
1653: PPUSH
1654: CALL 73802 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 3
1663: PUSH
1664: LD_INT 1
1666: PUSH
1667: LD_INT 2
1669: PUSH
1670: LD_INT 5
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: PUSH
1679: LD_INT 4
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 6
1690: PUSH
1691: EMPTY
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_INT 4
1699: PUSH
1700: LD_INT 1
1702: PUSH
1703: LD_INT 2
1705: PUSH
1706: LD_INT 7
1708: PUSH
1709: EMPTY
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 6
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: PUSH
1733: EMPTY
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PPUSH
1739: CALL 73617 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1743: LD_INT 1
1745: PPUSH
1746: LD_INT 201
1748: PPUSH
1749: LD_INT 140
1751: PPUSH
1752: LD_INT 4
1754: PPUSH
1755: LD_INT 19
1757: PUSH
1758: LD_INT 16
1760: PUSH
1761: LD_INT 17
1763: PUSH
1764: LD_INT 18
1766: PUSH
1767: LD_INT 22
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 74564 0 5
// end ;
1781: LD_VAR 0 1
1785: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1786: LD_INT 4
1788: PPUSH
1789: CALL_OW 302
1793: IFFALSE 2453
1795: GO 1797
1797: DISABLE
1798: LD_INT 0
1800: PPUSH
1801: PPUSH
1802: PPUSH
1803: PPUSH
1804: PPUSH
// begin enable ;
1805: ENABLE
// base := 1 ;
1806: LD_ADDR_VAR 0 2
1810: PUSH
1811: LD_INT 1
1813: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: LD_INT 4
1821: PUSH
1822: LD_INT 1
1824: PUSH
1825: LD_INT 2
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 4
1839: PUSH
1840: LD_INT 1
1842: PUSH
1843: LD_INT 2
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: LD_INT 1
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: LD_INT 7
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PUSH
1873: LD_INT 3
1875: PUSH
1876: LD_INT 1
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 7
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_OWVAR 1
1911: PUSH
1912: LD_INT 21000
1914: DIV
1915: PLUS
1916: ST_TO_ADDR
// if amount > 8 then
1917: LD_VAR 0 5
1921: PUSH
1922: LD_INT 8
1924: GREATER
1925: IFFALSE 1935
// amount := 8 ;
1927: LD_ADDR_VAR 0 5
1931: PUSH
1932: LD_INT 8
1934: ST_TO_ADDR
// for i = 1 to amount do
1935: LD_ADDR_VAR 0 1
1939: PUSH
1940: DOUBLE
1941: LD_INT 1
1943: DEC
1944: ST_TO_ADDR
1945: LD_VAR 0 5
1949: PUSH
1950: FOR_TO
1951: IFFALSE 2035
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1953: LD_ADDR_VAR 0 3
1957: PUSH
1958: LD_VAR 0 3
1962: PPUSH
1963: LD_VAR 0 3
1967: PUSH
1968: LD_INT 1
1970: PLUS
1971: PPUSH
1972: LD_INT 3
1974: PUSH
1975: LD_INT 4
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 2
1987: PPUSH
1988: CALL_OW 12
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 2
1999: PUSH
2000: LD_INT 7
2002: PUSH
2003: LD_INT 5
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
2033: GO 1950
2035: POP
2036: POP
// MC_InsertProduceList ( base , tmp ) ;
2037: LD_VAR 0 2
2041: PPUSH
2042: LD_VAR 0 3
2046: PPUSH
2047: CALL 73665 0 2
// repeat wait ( 0 0$1 ) ;
2051: LD_INT 35
2053: PPUSH
2054: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_INT 1
2065: PPUSH
2066: CALL 75083 0 2
2070: PUSH
2071: LD_VAR 0 5
2075: GREATEREQUAL
2076: IFFALSE 2051
// wait ( 0 0$30 ) ;
2078: LD_INT 1050
2080: PPUSH
2081: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2085: LD_ADDR_VAR 0 4
2089: PUSH
2090: LD_EXP 42
2094: PUSH
2095: LD_VAR 0 2
2099: ARRAY
2100: PUSH
2101: LD_EXP 42
2105: PUSH
2106: LD_VAR 0 2
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PUSH
2115: LD_INT 34
2117: PUSH
2118: LD_INT 12
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 34
2127: PUSH
2128: LD_INT 13
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 34
2137: PUSH
2138: LD_INT 14
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: PPUSH
2151: CALL_OW 72
2155: DIFF
2156: ST_TO_ADDR
// if not attackers then
2157: LD_VAR 0 4
2161: NOT
2162: IFFALSE 2166
// exit ;
2164: GO 2453
// DialogPowellsAttack ;
2166: CALL 9311 0 0
// powellAttackGroup := attackers ;
2170: LD_ADDR_EXP 12
2174: PUSH
2175: LD_VAR 0 4
2179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2180: LD_ADDR_EXP 42
2184: PUSH
2185: LD_EXP 42
2189: PPUSH
2190: LD_VAR 0 2
2194: PPUSH
2195: LD_EXP 42
2199: PUSH
2200: LD_VAR 0 2
2204: ARRAY
2205: PUSH
2206: LD_VAR 0 4
2210: DIFF
2211: PPUSH
2212: CALL_OW 1
2216: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2217: LD_EXP 9
2221: PUSH
2222: LD_INT 16
2224: PPUSH
2225: LD_INT 81
2227: PUSH
2228: LD_INT 4
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PPUSH
2235: CALL_OW 70
2239: AND
2240: IFFALSE 2259
// ComAgressiveMove ( attackers , 135 , 21 ) else
2242: LD_VAR 0 4
2246: PPUSH
2247: LD_INT 135
2249: PPUSH
2250: LD_INT 21
2252: PPUSH
2253: CALL_OW 114
2257: GO 2274
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2259: LD_VAR 0 4
2263: PPUSH
2264: LD_INT 146
2266: PPUSH
2267: LD_INT 103
2269: PPUSH
2270: CALL_OW 114
// wait ( 0 0$5 ) ;
2274: LD_INT 175
2276: PPUSH
2277: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2281: LD_INT 35
2283: PPUSH
2284: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2288: LD_VAR 0 4
2292: PPUSH
2293: LD_INT 60
2295: PUSH
2296: EMPTY
2297: LIST
2298: PPUSH
2299: CALL_OW 72
2303: NOT
2304: IFFALSE 2281
// if FilterAllUnits ( [ f_side , 3 ] ) then
2306: LD_INT 22
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: IFFALSE 2339
// ComAgressiveMove ( attackers , 102 , 116 ) else
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 102
2329: PPUSH
2330: LD_INT 116
2332: PPUSH
2333: CALL_OW 114
2337: GO 2354
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 66
2346: PPUSH
2347: LD_INT 41
2349: PPUSH
2350: CALL_OW 114
// wait ( 0 0$10 ) ;
2354: LD_INT 350
2356: PPUSH
2357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2361: LD_INT 35
2363: PPUSH
2364: CALL_OW 67
// for i in attackers do
2368: LD_ADDR_VAR 0 1
2372: PUSH
2373: LD_VAR 0 4
2377: PUSH
2378: FOR_IN
2379: IFFALSE 2429
// if not HasTask ( i ) then
2381: LD_VAR 0 1
2385: PPUSH
2386: CALL_OW 314
2390: NOT
2391: IFFALSE 2427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 81
2400: PUSH
2401: LD_INT 4
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PPUSH
2408: CALL_OW 69
2412: PPUSH
2413: LD_VAR 0 1
2417: PPUSH
2418: CALL_OW 74
2422: PPUSH
2423: CALL_OW 115
2427: GO 2378
2429: POP
2430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2431: LD_VAR 0 4
2435: PPUSH
2436: LD_INT 50
2438: PUSH
2439: EMPTY
2440: LIST
2441: PPUSH
2442: CALL_OW 72
2446: NOT
2447: IFFALSE 2361
// DialogPowellsAttackFailed ;
2449: CALL 9576 0 0
// end ;
2453: PPOPN 5
2455: END
// every 0 0$2 do var vehicles , mechs , i ;
2456: GO 2458
2458: DISABLE
2459: LD_INT 0
2461: PPUSH
2462: PPUSH
2463: PPUSH
// begin enable ;
2464: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2465: LD_ADDR_VAR 0 1
2469: PUSH
2470: LD_INT 22
2472: PUSH
2473: LD_INT 1
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 21
2482: PUSH
2483: LD_INT 2
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 3
2492: PUSH
2493: LD_INT 24
2495: PUSH
2496: LD_INT 1000
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: PUSH
2507: LD_INT 92
2509: PUSH
2510: LD_INT 191
2512: PUSH
2513: LD_INT 140
2515: PUSH
2516: LD_INT 10
2518: PUSH
2519: EMPTY
2520: LIST
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 69
2535: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_INT 22
2543: PUSH
2544: LD_INT 4
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: PUSH
2551: LD_INT 25
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PPUSH
2565: CALL_OW 69
2569: ST_TO_ADDR
// if not mechs then
2570: LD_VAR 0 2
2574: NOT
2575: IFFALSE 2579
// exit ;
2577: GO 2753
// if mc_remote_driver [ 1 ] then
2579: LD_EXP 63
2583: PUSH
2584: LD_INT 1
2586: ARRAY
2587: IFFALSE 2609
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_VAR 0 2
2598: PUSH
2599: LD_EXP 63
2603: PUSH
2604: LD_INT 1
2606: ARRAY
2607: DIFF
2608: ST_TO_ADDR
// if not mechs then
2609: LD_VAR 0 2
2613: NOT
2614: IFFALSE 2618
// exit ;
2616: GO 2753
// if vehicles then
2618: LD_VAR 0 1
2622: IFFALSE 2710
// begin for i in mechs do
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: LD_VAR 0 2
2633: PUSH
2634: FOR_IN
2635: IFFALSE 2706
// begin if GetTag ( i ) <> 120 then
2637: LD_VAR 0 3
2641: PPUSH
2642: CALL_OW 110
2646: PUSH
2647: LD_INT 120
2649: NONEQUAL
2650: IFFALSE 2664
// SetTag ( i , 120 ) ;
2652: LD_VAR 0 3
2656: PPUSH
2657: LD_INT 120
2659: PPUSH
2660: CALL_OW 109
// if IsInUnit ( i ) then
2664: LD_VAR 0 3
2668: PPUSH
2669: CALL_OW 310
2673: IFFALSE 2686
// ComExitBuilding ( i ) else
2675: LD_VAR 0 3
2679: PPUSH
2680: CALL_OW 122
2684: GO 2704
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2686: LD_VAR 0 3
2690: PPUSH
2691: LD_VAR 0 1
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 129
// end ;
2704: GO 2634
2706: POP
2707: POP
// end else
2708: GO 2753
// if FilterByTag ( mechs , 120 ) then
2710: LD_VAR 0 2
2714: PPUSH
2715: LD_INT 120
2717: PPUSH
2718: CALL 44973 0 2
2722: IFFALSE 2753
// begin for i in mechs do
2724: LD_ADDR_VAR 0 3
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: FOR_IN
2735: IFFALSE 2751
// begin SetTag ( i , 0 ) ;
2737: LD_VAR 0 3
2741: PPUSH
2742: LD_INT 0
2744: PPUSH
2745: CALL_OW 109
// end ;
2749: GO 2734
2751: POP
2752: POP
// end ; end ;
2753: PPOPN 3
2755: END
// every 0 0$2 do var people , sci , i ;
2756: GO 2758
2758: DISABLE
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 1
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 21
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 3
2792: PUSH
2793: LD_INT 24
2795: PUSH
2796: LD_INT 1000
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: LD_INT 92
2809: PUSH
2810: LD_INT 188
2812: PUSH
2813: LD_INT 112
2815: PUSH
2816: LD_INT 10
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: LIST
2829: LIST
2830: PPUSH
2831: CALL_OW 69
2835: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2836: LD_ADDR_VAR 0 2
2840: PUSH
2841: LD_INT 22
2843: PUSH
2844: LD_INT 4
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: LD_INT 25
2853: PUSH
2854: LD_INT 4
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 69
2869: ST_TO_ADDR
// if not sci then
2870: LD_VAR 0 2
2874: NOT
2875: IFFALSE 2879
// exit ;
2877: GO 3014
// if people then
2879: LD_VAR 0 1
2883: IFFALSE 2971
// begin for i in sci do
2885: LD_ADDR_VAR 0 3
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2967
// begin if GetTag ( i ) <> 102 then
2898: LD_VAR 0 3
2902: PPUSH
2903: CALL_OW 110
2907: PUSH
2908: LD_INT 102
2910: NONEQUAL
2911: IFFALSE 2925
// SetTag ( i , 102 ) ;
2913: LD_VAR 0 3
2917: PPUSH
2918: LD_INT 102
2920: PPUSH
2921: CALL_OW 109
// if IsInUnit ( i ) then
2925: LD_VAR 0 3
2929: PPUSH
2930: CALL_OW 310
2934: IFFALSE 2947
// ComExitBuilding ( i ) else
2936: LD_VAR 0 3
2940: PPUSH
2941: CALL_OW 122
2945: GO 2965
// ComHeal ( i , people [ 1 ] ) ;
2947: LD_VAR 0 3
2951: PPUSH
2952: LD_VAR 0 1
2956: PUSH
2957: LD_INT 1
2959: ARRAY
2960: PPUSH
2961: CALL_OW 128
// end ;
2965: GO 2895
2967: POP
2968: POP
// end else
2969: GO 3014
// if FilterByTag ( sci , 102 ) then
2971: LD_VAR 0 2
2975: PPUSH
2976: LD_INT 102
2978: PPUSH
2979: CALL 44973 0 2
2983: IFFALSE 3014
// begin for i in sci do
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_VAR 0 2
2994: PUSH
2995: FOR_IN
2996: IFFALSE 3012
// begin SetTag ( i , 0 ) ;
2998: LD_VAR 0 3
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 109
// end ;
3010: GO 2995
3012: POP
3013: POP
// end ; end ; end_of_file
3014: PPOPN 3
3016: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3017: LD_INT 0
3019: PPUSH
3020: PPUSH
3021: PPUSH
3022: PPUSH
3023: PPUSH
3024: PPUSH
// gensher_side := 2 ;
3025: LD_ADDR_EXP 14
3029: PUSH
3030: LD_INT 2
3032: ST_TO_ADDR
// uc_side := gensher_side ;
3033: LD_ADDR_OWVAR 20
3037: PUSH
3038: LD_EXP 14
3042: ST_TO_ADDR
// uc_nation := 2 ;
3043: LD_ADDR_OWVAR 21
3047: PUSH
3048: LD_INT 2
3050: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3051: LD_ADDR_VAR 0 6
3055: PUSH
3056: LD_INT 5
3058: PUSH
3059: LD_INT 42
3061: PUSH
3062: LD_INT 29
3064: PUSH
3065: LD_INT 5
3067: PUSH
3068: EMPTY
3069: LIST
3070: LIST
3071: LIST
3072: LIST
3073: PUSH
3074: LD_INT 5
3076: PUSH
3077: LD_INT 36
3079: PUSH
3080: LD_INT 40
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_INT 6
3094: PUSH
3095: LD_INT 13
3097: PUSH
3098: LD_INT 18
3100: PUSH
3101: LD_INT 1
3103: PUSH
3104: LD_INT 10
3106: PUSH
3107: LD_INT 15
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: LIST
3114: LIST
3115: LIST
3116: LIST
3117: PUSH
3118: LD_INT 27
3120: PUSH
3121: LD_INT 17
3123: PUSH
3124: LD_INT 3
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: EMPTY
3131: LIST
3132: LIST
3133: LIST
3134: LIST
3135: PUSH
3136: LD_INT 29
3138: PUSH
3139: LD_INT 56
3141: PUSH
3142: LD_INT 23
3144: PUSH
3145: LD_INT 0
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: PUSH
3154: LD_INT 3
3156: PUSH
3157: LD_INT 11
3159: PUSH
3160: LD_INT 7
3162: PUSH
3163: LD_INT 2
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: LIST
3170: LIST
3171: PUSH
3172: LD_INT 27
3174: PUSH
3175: LD_INT 20
3177: PUSH
3178: LD_INT 3
3180: PUSH
3181: LD_INT 0
3183: PUSH
3184: EMPTY
3185: LIST
3186: LIST
3187: LIST
3188: LIST
3189: PUSH
3190: LD_INT 27
3192: PUSH
3193: LD_INT 23
3195: PUSH
3196: LD_INT 3
3198: PUSH
3199: LD_INT 0
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: LIST
3206: LIST
3207: PUSH
3208: LD_INT 27
3210: PUSH
3211: LD_INT 26
3213: PUSH
3214: LD_INT 3
3216: PUSH
3217: LD_INT 0
3219: PUSH
3220: EMPTY
3221: LIST
3222: LIST
3223: LIST
3224: LIST
3225: PUSH
3226: LD_INT 6
3228: PUSH
3229: LD_INT 17
3231: PUSH
3232: LD_INT 27
3234: PUSH
3235: LD_INT 1
3237: PUSH
3238: LD_INT 13
3240: PUSH
3241: LD_INT 11
3243: PUSH
3244: EMPTY
3245: LIST
3246: LIST
3247: LIST
3248: LIST
3249: LIST
3250: LIST
3251: PUSH
3252: LD_INT 32
3254: PUSH
3255: LD_INT 27
3257: PUSH
3258: LD_INT 44
3260: PUSH
3261: LD_INT 5
3263: PUSH
3264: LD_INT 27
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: LIST
3271: LIST
3272: LIST
3273: PUSH
3274: LD_INT 32
3276: PUSH
3277: LD_INT 41
3279: PUSH
3280: LD_INT 41
3282: PUSH
3283: LD_INT 5
3285: PUSH
3286: LD_INT 27
3288: PUSH
3289: EMPTY
3290: LIST
3291: LIST
3292: LIST
3293: LIST
3294: LIST
3295: PUSH
3296: LD_INT 32
3298: PUSH
3299: LD_INT 45
3301: PUSH
3302: LD_INT 24
3304: PUSH
3305: LD_INT 5
3307: PUSH
3308: LD_INT 28
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: LIST
3316: LIST
3317: PUSH
3318: LD_INT 32
3320: PUSH
3321: LD_INT 48
3323: PUSH
3324: LD_INT 19
3326: PUSH
3327: LD_INT 5
3329: PUSH
3330: LD_INT 28
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: PUSH
3340: LD_INT 32
3342: PUSH
3343: LD_INT 41
3345: PUSH
3346: LD_INT 3
3348: PUSH
3349: LD_INT 4
3351: PUSH
3352: LD_INT 28
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: LIST
3361: PUSH
3362: LD_INT 5
3364: PUSH
3365: LD_INT 44
3367: PUSH
3368: LD_INT 9
3370: PUSH
3371: LD_INT 4
3373: PUSH
3374: EMPTY
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: PUSH
3380: LD_INT 30
3382: PUSH
3383: LD_INT 52
3385: PUSH
3386: LD_INT 40
3388: PUSH
3389: LD_INT 3
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: LIST
3396: LIST
3397: PUSH
3398: EMPTY
3399: LIST
3400: LIST
3401: LIST
3402: LIST
3403: LIST
3404: LIST
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: LIST
3410: LIST
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: ST_TO_ADDR
// for i in list do
3417: LD_ADDR_VAR 0 2
3421: PUSH
3422: LD_VAR 0 6
3426: PUSH
3427: FOR_IN
3428: IFFALSE 3606
// begin uc_side := 2 ;
3430: LD_ADDR_OWVAR 20
3434: PUSH
3435: LD_INT 2
3437: ST_TO_ADDR
// uc_nation := 2 ;
3438: LD_ADDR_OWVAR 21
3442: PUSH
3443: LD_INT 2
3445: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3446: LD_ADDR_OWVAR 42
3450: PUSH
3451: LD_VAR 0 2
3455: PUSH
3456: LD_INT 1
3458: ARRAY
3459: ST_TO_ADDR
// bc_kind1 := - 1 ;
3460: LD_ADDR_OWVAR 44
3464: PUSH
3465: LD_INT 1
3467: NEG
3468: ST_TO_ADDR
// bc_kind2 := - 1 ;
3469: LD_ADDR_OWVAR 45
3473: PUSH
3474: LD_INT 1
3476: NEG
3477: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3478: LD_VAR 0 2
3482: PUSH
3483: LD_INT 1
3485: ARRAY
3486: PUSH
3487: LD_INT 6
3489: EQUAL
3490: IFFALSE 3528
// begin bc_type := b_lab_full ;
3492: LD_ADDR_OWVAR 42
3496: PUSH
3497: LD_INT 8
3499: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3500: LD_ADDR_OWVAR 44
3504: PUSH
3505: LD_VAR 0 2
3509: PUSH
3510: LD_INT 5
3512: ARRAY
3513: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3514: LD_ADDR_OWVAR 45
3518: PUSH
3519: LD_VAR 0 2
3523: PUSH
3524: LD_INT 6
3526: ARRAY
3527: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3528: LD_ADDR_VAR 0 3
3532: PUSH
3533: LD_VAR 0 2
3537: PUSH
3538: LD_INT 2
3540: ARRAY
3541: PPUSH
3542: LD_VAR 0 2
3546: PUSH
3547: LD_INT 3
3549: ARRAY
3550: PPUSH
3551: LD_VAR 0 2
3555: PUSH
3556: LD_INT 4
3558: ARRAY
3559: PPUSH
3560: CALL_OW 47
3564: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3565: LD_VAR 0 2
3569: PUSH
3570: LD_INT 1
3572: ARRAY
3573: PUSH
3574: LD_INT 33
3576: PUSH
3577: LD_INT 32
3579: PUSH
3580: EMPTY
3581: LIST
3582: LIST
3583: IN
3584: IFFALSE 3604
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3586: LD_VAR 0 3
3590: PPUSH
3591: LD_VAR 0 2
3595: PUSH
3596: LD_INT 5
3598: ARRAY
3599: PPUSH
3600: CALL_OW 431
// end ;
3604: GO 3427
3606: POP
3607: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3608: LD_ADDR_VAR 0 4
3612: PUSH
3613: LD_INT 7
3615: PPUSH
3616: LD_INT 2
3618: PPUSH
3619: LD_STRING 
3621: PPUSH
3622: LD_INT 8
3624: PUSH
3625: LD_INT 7
3627: PUSH
3628: LD_INT 6
3630: PUSH
3631: EMPTY
3632: LIST
3633: LIST
3634: LIST
3635: PUSH
3636: LD_OWVAR 67
3640: ARRAY
3641: PPUSH
3642: LD_INT 11500
3644: PUSH
3645: LD_INT 1100
3647: PUSH
3648: LD_INT 60
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: LIST
3655: PPUSH
3656: LD_INT 6
3658: PUSH
3659: LD_INT 6
3661: PUSH
3662: LD_INT 6
3664: PUSH
3665: LD_INT 6
3667: PUSH
3668: EMPTY
3669: LIST
3670: LIST
3671: LIST
3672: LIST
3673: PPUSH
3674: CALL 19028 0 6
3678: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3679: LD_ADDR_EXP 23
3683: PUSH
3684: LD_EXP 23
3688: PPUSH
3689: LD_INT 2
3691: PPUSH
3692: LD_VAR 0 4
3696: PUSH
3697: LD_INT 22
3699: PUSH
3700: LD_INT 2
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 21
3709: PUSH
3710: LD_INT 3
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PPUSH
3721: CALL_OW 69
3725: UNION
3726: PPUSH
3727: CALL_OW 1
3731: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3732: LD_ADDR_VAR 0 4
3736: PUSH
3737: LD_INT 22
3739: PUSH
3740: LD_INT 2
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 30
3749: PUSH
3750: LD_INT 31
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: EMPTY
3758: LIST
3759: LIST
3760: PPUSH
3761: CALL_OW 69
3765: ST_TO_ADDR
// for i in tmp do
3766: LD_ADDR_VAR 0 2
3770: PUSH
3771: LD_VAR 0 4
3775: PUSH
3776: FOR_IN
3777: IFFALSE 3847
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3779: LD_INT 0
3781: PPUSH
3782: LD_INT 1
3784: PPUSH
3785: LD_INT 4
3787: PUSH
3788: LD_INT 3
3790: PUSH
3791: LD_INT 3
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: LIST
3798: PUSH
3799: LD_OWVAR 67
3803: ARRAY
3804: PPUSH
3805: CALL_OW 380
// un := CreateHuman ;
3809: LD_ADDR_VAR 0 5
3813: PUSH
3814: CALL_OW 44
3818: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3819: LD_VAR 0 5
3823: PPUSH
3824: LD_INT 1
3826: PPUSH
3827: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3831: LD_VAR 0 5
3835: PPUSH
3836: LD_VAR 0 2
3840: PPUSH
3841: CALL_OW 52
// end ;
3845: GO 3776
3847: POP
3848: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3849: LD_ADDR_VAR 0 4
3853: PUSH
3854: LD_INT 15
3856: PPUSH
3857: LD_INT 0
3859: PPUSH
3860: CALL_OW 517
3864: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
3865: LD_ADDR_VAR 0 2
3869: PUSH
3870: DOUBLE
3871: LD_INT 1
3873: DEC
3874: ST_TO_ADDR
3875: LD_VAR 0 4
3879: PUSH
3880: LD_INT 1
3882: ARRAY
3883: PUSH
3884: FOR_TO
3885: IFFALSE 3987
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
3887: LD_VAR 0 4
3891: PUSH
3892: LD_INT 1
3894: ARRAY
3895: PUSH
3896: LD_VAR 0 2
3900: ARRAY
3901: PPUSH
3902: LD_VAR 0 4
3906: PUSH
3907: LD_INT 2
3909: ARRAY
3910: PUSH
3911: LD_VAR 0 2
3915: ARRAY
3916: PPUSH
3917: LD_INT 2
3919: PPUSH
3920: LD_INT 0
3922: PPUSH
3923: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
3927: LD_ADDR_EXP 3
3931: PUSH
3932: LD_EXP 3
3936: PPUSH
3937: LD_EXP 3
3941: PUSH
3942: LD_INT 1
3944: PLUS
3945: PPUSH
3946: LD_VAR 0 4
3950: PUSH
3951: LD_INT 1
3953: ARRAY
3954: PUSH
3955: LD_VAR 0 2
3959: ARRAY
3960: PUSH
3961: LD_VAR 0 4
3965: PUSH
3966: LD_INT 2
3968: ARRAY
3969: PUSH
3970: LD_VAR 0 2
3974: ARRAY
3975: PUSH
3976: EMPTY
3977: LIST
3978: LIST
3979: PPUSH
3980: CALL_OW 2
3984: ST_TO_ADDR
// end ;
3985: GO 3884
3987: POP
3988: POP
// if Difficulty > 1 then
3989: LD_OWVAR 67
3993: PUSH
3994: LD_INT 1
3996: GREATER
3997: IFFALSE 4139
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
3999: LD_ADDR_VAR 0 4
4003: PUSH
4004: LD_INT 19
4006: PPUSH
4007: LD_INT 0
4009: PPUSH
4010: CALL_OW 517
4014: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4015: LD_ADDR_VAR 0 2
4019: PUSH
4020: DOUBLE
4021: LD_INT 1
4023: DEC
4024: ST_TO_ADDR
4025: LD_VAR 0 4
4029: PUSH
4030: LD_INT 1
4032: ARRAY
4033: PUSH
4034: FOR_TO
4035: IFFALSE 4137
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4037: LD_VAR 0 4
4041: PUSH
4042: LD_INT 1
4044: ARRAY
4045: PUSH
4046: LD_VAR 0 2
4050: ARRAY
4051: PPUSH
4052: LD_VAR 0 4
4056: PUSH
4057: LD_INT 2
4059: ARRAY
4060: PUSH
4061: LD_VAR 0 2
4065: ARRAY
4066: PPUSH
4067: LD_INT 2
4069: PPUSH
4070: LD_INT 0
4072: PPUSH
4073: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4077: LD_ADDR_EXP 3
4081: PUSH
4082: LD_EXP 3
4086: PPUSH
4087: LD_EXP 3
4091: PUSH
4092: LD_INT 1
4094: PLUS
4095: PPUSH
4096: LD_VAR 0 4
4100: PUSH
4101: LD_INT 1
4103: ARRAY
4104: PUSH
4105: LD_VAR 0 2
4109: ARRAY
4110: PUSH
4111: LD_VAR 0 4
4115: PUSH
4116: LD_INT 2
4118: ARRAY
4119: PUSH
4120: LD_VAR 0 2
4124: ARRAY
4125: PUSH
4126: EMPTY
4127: LIST
4128: LIST
4129: PPUSH
4130: CALL_OW 2
4134: ST_TO_ADDR
// end ;
4135: GO 4034
4137: POP
4138: POP
// end ; gensherAttackGroup := [ ] ;
4139: LD_ADDR_EXP 15
4143: PUSH
4144: EMPTY
4145: ST_TO_ADDR
// end ;
4146: LD_VAR 0 1
4150: RET
// export function InitMC_Gensher ( ) ; begin
4151: LD_INT 0
4153: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4154: LD_INT 2
4156: PPUSH
4157: LD_INT 2
4159: PPUSH
4160: CALL 74938 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4164: LD_INT 2
4166: PPUSH
4167: LD_INT 9
4169: PPUSH
4170: CALL 74882 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4174: LD_INT 2
4176: PPUSH
4177: LD_INT 56
4179: PUSH
4180: LD_INT 23
4182: PUSH
4183: LD_INT 0
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 52
4193: PUSH
4194: LD_INT 40
4196: PUSH
4197: LD_INT 1
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: LIST
4204: PUSH
4205: EMPTY
4206: LIST
4207: LIST
4208: PPUSH
4209: CALL 73941 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4213: LD_INT 2
4215: PPUSH
4216: LD_INT 27
4218: PUSH
4219: LD_INT 28
4221: PUSH
4222: EMPTY
4223: LIST
4224: LIST
4225: PPUSH
4226: CALL 74770 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4230: LD_INT 2
4232: PPUSH
4233: LD_INT 8
4235: PPUSH
4236: CALL 74452 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4240: LD_INT 2
4242: PPUSH
4243: LD_INT 7
4245: PPUSH
4246: CALL 74183 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4250: LD_INT 2
4252: PPUSH
4253: LD_INT 4
4255: PPUSH
4256: CALL 73802 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4260: LD_INT 2
4262: PPUSH
4263: LD_INT 13
4265: PUSH
4266: LD_INT 2
4268: PUSH
4269: LD_INT 1
4271: PUSH
4272: LD_INT 31
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: LIST
4279: LIST
4280: PUSH
4281: LD_INT 13
4283: PUSH
4284: LD_INT 2
4286: PUSH
4287: LD_INT 1
4289: PUSH
4290: LD_INT 31
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: LIST
4298: PUSH
4299: LD_INT 14
4301: PUSH
4302: LD_INT 1
4304: PUSH
4305: LD_INT 2
4307: PUSH
4308: LD_INT 27
4310: PUSH
4311: EMPTY
4312: LIST
4313: LIST
4314: LIST
4315: LIST
4316: PUSH
4317: LD_INT 14
4319: PUSH
4320: LD_INT 1
4322: PUSH
4323: LD_INT 2
4325: PUSH
4326: LD_INT 27
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: LIST
4334: PUSH
4335: LD_INT 14
4337: PUSH
4338: LD_INT 1
4340: PUSH
4341: LD_INT 2
4343: PUSH
4344: LD_INT 28
4346: PUSH
4347: EMPTY
4348: LIST
4349: LIST
4350: LIST
4351: LIST
4352: PUSH
4353: LD_INT 14
4355: PUSH
4356: LD_INT 1
4358: PUSH
4359: LD_INT 2
4361: PUSH
4362: LD_INT 26
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: LIST
4370: PUSH
4371: EMPTY
4372: LIST
4373: LIST
4374: LIST
4375: LIST
4376: LIST
4377: LIST
4378: PPUSH
4379: CALL 73617 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4383: LD_INT 2
4385: PPUSH
4386: LD_INT 11
4388: PPUSH
4389: LD_INT 7
4391: PPUSH
4392: LD_INT 2
4394: PPUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 16
4400: PUSH
4401: LD_INT 17
4403: PUSH
4404: LD_INT 18
4406: PUSH
4407: LD_INT 22
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: LIST
4416: PPUSH
4417: CALL 74564 0 5
// end ;
4421: LD_VAR 0 1
4425: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4426: LD_EXP 3
4430: PUSH
4431: LD_INT 15
4433: PPUSH
4434: LD_INT 81
4436: PUSH
4437: LD_INT 2
4439: PUSH
4440: EMPTY
4441: LIST
4442: LIST
4443: PPUSH
4444: CALL_OW 70
4448: AND
4449: IFFALSE 4662
4451: GO 4453
4453: DISABLE
4454: LD_INT 0
4456: PPUSH
4457: PPUSH
4458: PPUSH
4459: PPUSH
4460: PPUSH
// begin enable ;
4461: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4462: LD_ADDR_VAR 0 3
4466: PUSH
4467: LD_INT 15
4469: PPUSH
4470: LD_INT 81
4472: PUSH
4473: LD_INT 2
4475: PUSH
4476: EMPTY
4477: LIST
4478: LIST
4479: PPUSH
4480: CALL_OW 70
4484: ST_TO_ADDR
// if not tmp then
4485: LD_VAR 0 3
4489: NOT
4490: IFFALSE 4494
// exit ;
4492: GO 4662
// for i in tmp do
4494: LD_ADDR_VAR 0 1
4498: PUSH
4499: LD_VAR 0 3
4503: PUSH
4504: FOR_IN
4505: IFFALSE 4660
// begin x := GetX ( i ) ;
4507: LD_ADDR_VAR 0 4
4511: PUSH
4512: LD_VAR 0 1
4516: PPUSH
4517: CALL_OW 250
4521: ST_TO_ADDR
// y := GetY ( i ) ;
4522: LD_ADDR_VAR 0 5
4526: PUSH
4527: LD_VAR 0 1
4531: PPUSH
4532: CALL_OW 251
4536: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4537: LD_VAR 0 4
4541: PPUSH
4542: LD_VAR 0 5
4546: PPUSH
4547: CALL_OW 458
4551: IFFALSE 4658
// begin LaunchMineAtPos ( x , y , 2 ) ;
4553: LD_VAR 0 4
4557: PPUSH
4558: LD_VAR 0 5
4562: PPUSH
4563: LD_INT 2
4565: PPUSH
4566: CALL_OW 456
// for j = 1 to staticMines do
4570: LD_ADDR_VAR 0 2
4574: PUSH
4575: DOUBLE
4576: LD_INT 1
4578: DEC
4579: ST_TO_ADDR
4580: LD_EXP 3
4584: PUSH
4585: FOR_TO
4586: IFFALSE 4656
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4588: LD_EXP 3
4592: PUSH
4593: LD_VAR 0 2
4597: ARRAY
4598: PUSH
4599: LD_INT 1
4601: ARRAY
4602: PUSH
4603: LD_VAR 0 4
4607: EQUAL
4608: PUSH
4609: LD_EXP 3
4613: PUSH
4614: LD_VAR 0 2
4618: ARRAY
4619: PUSH
4620: LD_INT 2
4622: ARRAY
4623: PUSH
4624: LD_VAR 0 5
4628: EQUAL
4629: AND
4630: IFFALSE 4654
// begin staticMines := Delete ( staticMines , j ) ;
4632: LD_ADDR_EXP 3
4636: PUSH
4637: LD_EXP 3
4641: PPUSH
4642: LD_VAR 0 2
4646: PPUSH
4647: CALL_OW 3
4651: ST_TO_ADDR
// break ;
4652: GO 4656
// end ;
4654: GO 4585
4656: POP
4657: POP
// end ; end ;
4658: GO 4504
4660: POP
4661: POP
// end ;
4662: PPOPN 5
4664: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4665: LD_INT 7
4667: PPUSH
4668: CALL_OW 302
4672: PUSH
4673: LD_EXP 4
4677: NOT
4678: AND
4679: IFFALSE 5283
4681: GO 4683
4683: DISABLE
4684: LD_INT 0
4686: PPUSH
4687: PPUSH
4688: PPUSH
4689: PPUSH
4690: PPUSH
// begin enable ;
4691: ENABLE
// base := 2 ;
4692: LD_ADDR_VAR 0 2
4696: PUSH
4697: LD_INT 2
4699: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4700: LD_ADDR_VAR 0 3
4704: PUSH
4705: LD_INT 14
4707: PUSH
4708: LD_INT 1
4710: PUSH
4711: LD_INT 2
4713: PUSH
4714: LD_INT 27
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: LIST
4721: LIST
4722: PUSH
4723: LD_INT 14
4725: PUSH
4726: LD_INT 1
4728: PUSH
4729: LD_INT 2
4731: PUSH
4732: LD_INT 27
4734: PUSH
4735: EMPTY
4736: LIST
4737: LIST
4738: LIST
4739: LIST
4740: PUSH
4741: LD_INT 14
4743: PUSH
4744: LD_INT 1
4746: PUSH
4747: LD_INT 2
4749: PUSH
4750: LD_EXP 72
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: PUSH
4761: LD_INT 14
4763: PUSH
4764: LD_INT 1
4766: PUSH
4767: LD_INT 2
4769: PUSH
4770: LD_INT 26
4772: PUSH
4773: EMPTY
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4785: LD_ADDR_VAR 0 5
4789: PUSH
4790: LD_VAR 0 5
4794: PUSH
4795: LD_OWVAR 1
4799: PUSH
4800: LD_INT 21000
4802: DIV
4803: PLUS
4804: ST_TO_ADDR
// if amount > 8 then
4805: LD_VAR 0 5
4809: PUSH
4810: LD_INT 8
4812: GREATER
4813: IFFALSE 4823
// amount := 8 ;
4815: LD_ADDR_VAR 0 5
4819: PUSH
4820: LD_INT 8
4822: ST_TO_ADDR
// for i = 1 to amount do
4823: LD_ADDR_VAR 0 1
4827: PUSH
4828: DOUBLE
4829: LD_INT 1
4831: DEC
4832: ST_TO_ADDR
4833: LD_VAR 0 5
4837: PUSH
4838: FOR_TO
4839: IFFALSE 4927
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4841: LD_ADDR_VAR 0 3
4845: PUSH
4846: LD_VAR 0 3
4850: PPUSH
4851: LD_VAR 0 3
4855: PUSH
4856: LD_INT 1
4858: PLUS
4859: PPUSH
4860: LD_INT 14
4862: PUSH
4863: LD_INT 13
4865: PUSH
4866: EMPTY
4867: LIST
4868: LIST
4869: PUSH
4870: LD_INT 1
4872: PPUSH
4873: LD_INT 2
4875: PPUSH
4876: CALL_OW 12
4880: ARRAY
4881: PUSH
4882: LD_INT 1
4884: PUSH
4885: LD_INT 2
4887: PUSH
4888: LD_INT 28
4890: PUSH
4891: LD_INT 25
4893: PUSH
4894: LD_INT 27
4896: PUSH
4897: EMPTY
4898: LIST
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 1
4904: PPUSH
4905: LD_INT 3
4907: PPUSH
4908: CALL_OW 12
4912: ARRAY
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: LIST
4918: LIST
4919: PPUSH
4920: CALL_OW 2
4924: ST_TO_ADDR
4925: GO 4838
4927: POP
4928: POP
// MC_InsertProduceList ( base , tmp ) ;
4929: LD_VAR 0 2
4933: PPUSH
4934: LD_VAR 0 3
4938: PPUSH
4939: CALL 73665 0 2
// repeat wait ( 0 0$1 ) ;
4943: LD_INT 35
4945: PPUSH
4946: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
4950: LD_VAR 0 2
4954: PPUSH
4955: LD_INT 1
4957: PPUSH
4958: CALL 75083 0 2
4962: PUSH
4963: LD_VAR 0 5
4967: GREATEREQUAL
4968: IFFALSE 4943
// wait ( 0 0$30 ) ;
4970: LD_INT 1050
4972: PPUSH
4973: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
4977: LD_ADDR_VAR 0 4
4981: PUSH
4982: LD_EXP 42
4986: PUSH
4987: LD_VAR 0 2
4991: ARRAY
4992: PUSH
4993: LD_EXP 42
4997: PUSH
4998: LD_VAR 0 2
5002: ARRAY
5003: PPUSH
5004: LD_INT 2
5006: PUSH
5007: LD_INT 34
5009: PUSH
5010: LD_INT 31
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 34
5019: PUSH
5020: LD_INT 32
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 34
5029: PUSH
5030: LD_EXP 73
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: PUSH
5039: EMPTY
5040: LIST
5041: LIST
5042: LIST
5043: LIST
5044: PPUSH
5045: CALL_OW 72
5049: DIFF
5050: ST_TO_ADDR
// if not attackers then
5051: LD_VAR 0 4
5055: NOT
5056: IFFALSE 5060
// exit ;
5058: GO 5283
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5060: LD_ADDR_EXP 42
5064: PUSH
5065: LD_EXP 42
5069: PPUSH
5070: LD_VAR 0 2
5074: PPUSH
5075: LD_EXP 42
5079: PUSH
5080: LD_VAR 0 2
5084: ARRAY
5085: PUSH
5086: LD_VAR 0 4
5090: DIFF
5091: PPUSH
5092: CALL_OW 1
5096: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5097: LD_VAR 0 4
5101: PPUSH
5102: LD_INT 107
5104: PPUSH
5105: LD_INT 74
5107: PPUSH
5108: CALL_OW 114
// wait ( 0 0$5 ) ;
5112: LD_INT 175
5114: PPUSH
5115: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5119: LD_INT 35
5121: PPUSH
5122: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5126: LD_VAR 0 4
5130: PPUSH
5131: LD_INT 60
5133: PUSH
5134: EMPTY
5135: LIST
5136: PPUSH
5137: CALL_OW 72
5141: NOT
5142: IFFALSE 5119
// if rand ( 0 , 1 ) then
5144: LD_INT 0
5146: PPUSH
5147: LD_INT 1
5149: PPUSH
5150: CALL_OW 12
5154: IFFALSE 5173
// ComAgressiveMove ( attackers , 155 , 108 ) else
5156: LD_VAR 0 4
5160: PPUSH
5161: LD_INT 155
5163: PPUSH
5164: LD_INT 108
5166: PPUSH
5167: CALL_OW 114
5171: GO 5188
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5173: LD_VAR 0 4
5177: PPUSH
5178: LD_INT 149
5180: PPUSH
5181: LD_INT 55
5183: PPUSH
5184: CALL_OW 114
// wait ( 0 0$10 ) ;
5188: LD_INT 350
5190: PPUSH
5191: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5195: LD_INT 35
5197: PPUSH
5198: CALL_OW 67
// for i in attackers do
5202: LD_ADDR_VAR 0 1
5206: PUSH
5207: LD_VAR 0 4
5211: PUSH
5212: FOR_IN
5213: IFFALSE 5263
// if not HasTask ( i ) then
5215: LD_VAR 0 1
5219: PPUSH
5220: CALL_OW 314
5224: NOT
5225: IFFALSE 5261
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5227: LD_VAR 0 1
5231: PPUSH
5232: LD_INT 81
5234: PUSH
5235: LD_INT 2
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: PPUSH
5242: CALL_OW 69
5246: PPUSH
5247: LD_VAR 0 1
5251: PPUSH
5252: CALL_OW 74
5256: PPUSH
5257: CALL_OW 115
5261: GO 5212
5263: POP
5264: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5265: LD_VAR 0 4
5269: PPUSH
5270: LD_INT 50
5272: PUSH
5273: EMPTY
5274: LIST
5275: PPUSH
5276: CALL_OW 72
5280: NOT
5281: IFFALSE 5195
// end ;
5283: PPOPN 5
5285: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5286: LD_EXP 4
5290: NOT
5291: PUSH
5292: LD_OWVAR 1
5296: PUSH
5297: LD_INT 191100
5299: LESS
5300: AND
5301: IFFALSE 5973
5303: GO 5305
5305: DISABLE
5306: LD_INT 0
5308: PPUSH
5309: PPUSH
5310: PPUSH
// begin enable ;
5311: ENABLE
// tmp := [ ] ;
5312: LD_ADDR_VAR 0 3
5316: PUSH
5317: EMPTY
5318: ST_TO_ADDR
// if tick < 35 35$00 then
5319: LD_OWVAR 1
5323: PUSH
5324: LD_INT 73500
5326: LESS
5327: IFFALSE 5525
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5329: LD_ADDR_VAR 0 1
5333: PUSH
5334: DOUBLE
5335: LD_INT 1
5337: DEC
5338: ST_TO_ADDR
5339: LD_INT 4
5341: PUSH
5342: LD_INT 5
5344: PUSH
5345: LD_INT 5
5347: PUSH
5348: EMPTY
5349: LIST
5350: LIST
5351: LIST
5352: PUSH
5353: LD_OWVAR 67
5357: ARRAY
5358: PUSH
5359: FOR_TO
5360: IFFALSE 5521
// begin uc_side := 2 ;
5362: LD_ADDR_OWVAR 20
5366: PUSH
5367: LD_INT 2
5369: ST_TO_ADDR
// uc_nation := 2 ;
5370: LD_ADDR_OWVAR 21
5374: PUSH
5375: LD_INT 2
5377: ST_TO_ADDR
// InitHC_All ( ) ;
5378: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5382: LD_INT 0
5384: PPUSH
5385: LD_INT 1
5387: PPUSH
5388: LD_INT 5
5390: PUSH
5391: LD_INT 6
5393: PUSH
5394: LD_INT 7
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: LIST
5401: PUSH
5402: LD_OWVAR 67
5406: ARRAY
5407: PPUSH
5408: CALL_OW 380
// un := CreateHuman ;
5412: LD_ADDR_VAR 0 2
5416: PUSH
5417: CALL_OW 44
5421: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5422: LD_VAR 0 2
5426: PPUSH
5427: LD_INT 17
5429: PPUSH
5430: LD_INT 0
5432: PPUSH
5433: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5437: LD_VAR 0 2
5441: PPUSH
5442: LD_INT 1
5444: PUSH
5445: LD_INT 8
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: PUSH
5452: LD_INT 1
5454: PPUSH
5455: LD_INT 2
5457: PPUSH
5458: CALL_OW 12
5462: ARRAY
5463: PPUSH
5464: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5468: LD_VAR 0 2
5472: PPUSH
5473: LD_INT 111
5475: PPUSH
5476: LD_INT 34
5478: PPUSH
5479: CALL_OW 114
// wait ( 0 0$2 ) ;
5483: LD_INT 70
5485: PPUSH
5486: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5490: LD_ADDR_VAR 0 3
5494: PUSH
5495: LD_VAR 0 3
5499: PPUSH
5500: LD_VAR 0 3
5504: PUSH
5505: LD_INT 1
5507: PLUS
5508: PPUSH
5509: LD_VAR 0 2
5513: PPUSH
5514: CALL_OW 1
5518: ST_TO_ADDR
// end ;
5519: GO 5359
5521: POP
5522: POP
// end else
5523: GO 5666
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5525: LD_ADDR_VAR 0 1
5529: PUSH
5530: DOUBLE
5531: LD_INT 1
5533: DEC
5534: ST_TO_ADDR
5535: LD_INT 4
5537: PUSH
5538: LD_INT 5
5540: PUSH
5541: LD_INT 5
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_OWVAR 67
5553: ARRAY
5554: PUSH
5555: FOR_TO
5556: IFFALSE 5664
// begin uc_side := 2 ;
5558: LD_ADDR_OWVAR 20
5562: PUSH
5563: LD_INT 2
5565: ST_TO_ADDR
// uc_nation := 0 ;
5566: LD_ADDR_OWVAR 21
5570: PUSH
5571: LD_INT 0
5573: ST_TO_ADDR
// InitHC_All ( ) ;
5574: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5578: LD_ADDR_OWVAR 28
5582: PUSH
5583: LD_INT 17
5585: ST_TO_ADDR
// un := CreateHuman ;
5586: LD_ADDR_VAR 0 2
5590: PUSH
5591: CALL_OW 44
5595: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5596: LD_VAR 0 2
5600: PPUSH
5601: LD_INT 17
5603: PPUSH
5604: LD_INT 0
5606: PPUSH
5607: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5611: LD_VAR 0 2
5615: PPUSH
5616: LD_INT 110
5618: PPUSH
5619: LD_INT 33
5621: PPUSH
5622: CALL_OW 114
// wait ( 0 0$2 ) ;
5626: LD_INT 70
5628: PPUSH
5629: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5633: LD_ADDR_VAR 0 3
5637: PUSH
5638: LD_VAR 0 3
5642: PPUSH
5643: LD_VAR 0 3
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: PPUSH
5652: LD_VAR 0 2
5656: PPUSH
5657: CALL_OW 1
5661: ST_TO_ADDR
// end ;
5662: GO 5555
5664: POP
5665: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5666: LD_ADDR_VAR 0 1
5670: PUSH
5671: DOUBLE
5672: LD_INT 1
5674: DEC
5675: ST_TO_ADDR
5676: LD_INT 3
5678: PUSH
5679: LD_INT 4
5681: PUSH
5682: LD_INT 5
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_OWVAR 67
5694: ARRAY
5695: PUSH
5696: FOR_TO
5697: IFFALSE 5862
// begin uc_side := 2 ;
5699: LD_ADDR_OWVAR 20
5703: PUSH
5704: LD_INT 2
5706: ST_TO_ADDR
// uc_nation := 2 ;
5707: LD_ADDR_OWVAR 21
5711: PUSH
5712: LD_INT 2
5714: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5715: LD_INT 14
5717: PPUSH
5718: LD_INT 3
5720: PPUSH
5721: LD_INT 5
5723: PPUSH
5724: LD_INT 29
5726: PUSH
5727: LD_INT 28
5729: PUSH
5730: LD_INT 27
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: LIST
5737: PUSH
5738: LD_INT 1
5740: PPUSH
5741: LD_INT 3
5743: PPUSH
5744: CALL_OW 12
5748: ARRAY
5749: PPUSH
5750: LD_INT 90
5752: PPUSH
5753: CALL 15582 0 5
// un := CreateVehicle ;
5757: LD_ADDR_VAR 0 2
5761: PUSH
5762: CALL_OW 45
5766: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5767: LD_VAR 0 2
5771: PPUSH
5772: LD_INT 2
5774: PPUSH
5775: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5779: LD_VAR 0 2
5783: PPUSH
5784: LD_INT 17
5786: PPUSH
5787: LD_INT 0
5789: PPUSH
5790: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5794: LD_VAR 0 2
5798: PPUSH
5799: LD_INT 66
5801: PPUSH
5802: LD_INT 23
5804: PPUSH
5805: CALL_OW 111
// wait ( 0 0$3 ) ;
5809: LD_INT 105
5811: PPUSH
5812: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5816: LD_VAR 0 2
5820: PPUSH
5821: LD_INT 147
5823: PPUSH
5824: LD_INT 103
5826: PPUSH
5827: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5831: LD_ADDR_VAR 0 3
5835: PUSH
5836: LD_VAR 0 3
5840: PPUSH
5841: LD_VAR 0 3
5845: PUSH
5846: LD_INT 1
5848: PLUS
5849: PPUSH
5850: LD_VAR 0 2
5854: PPUSH
5855: CALL_OW 1
5859: ST_TO_ADDR
// end ;
5860: GO 5696
5862: POP
5863: POP
// if not tmp then
5864: LD_VAR 0 3
5868: NOT
5869: IFFALSE 5873
// exit ;
5871: GO 5973
// wait ( 0 0$5 ) ;
5873: LD_INT 175
5875: PPUSH
5876: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
5880: LD_INT 70
5882: PPUSH
5883: CALL_OW 67
// for i in tmp do
5887: LD_ADDR_VAR 0 1
5891: PUSH
5892: LD_VAR 0 3
5896: PUSH
5897: FOR_IN
5898: IFFALSE 5964
// begin if not IsOk ( i ) then
5900: LD_VAR 0 1
5904: PPUSH
5905: CALL_OW 302
5909: NOT
5910: IFFALSE 5928
// tmp := tmp diff i ;
5912: LD_ADDR_VAR 0 3
5916: PUSH
5917: LD_VAR 0 3
5921: PUSH
5922: LD_VAR 0 1
5926: DIFF
5927: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5928: LD_VAR 0 1
5932: PPUSH
5933: LD_INT 81
5935: PUSH
5936: LD_INT 2
5938: PUSH
5939: EMPTY
5940: LIST
5941: LIST
5942: PPUSH
5943: CALL_OW 69
5947: PPUSH
5948: LD_VAR 0 1
5952: PPUSH
5953: CALL_OW 74
5957: PPUSH
5958: CALL_OW 115
// end ;
5962: GO 5897
5964: POP
5965: POP
// until not tmp ;
5966: LD_VAR 0 3
5970: NOT
5971: IFFALSE 5880
// end ;
5973: PPOPN 3
5975: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
5976: LD_OWVAR 67
5980: PUSH
5981: LD_INT 1
5983: GREATER
5984: IFFALSE 6082
5986: GO 5988
5988: DISABLE
5989: LD_INT 0
5991: PPUSH
// begin uc_side := 2 ;
5992: LD_ADDR_OWVAR 20
5996: PUSH
5997: LD_INT 2
5999: ST_TO_ADDR
// uc_nation := 2 ;
6000: LD_ADDR_OWVAR 21
6004: PUSH
6005: LD_INT 2
6007: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6008: LD_INT 0
6010: PPUSH
6011: LD_INT 4
6013: PPUSH
6014: LD_INT 6
6016: PPUSH
6017: CALL_OW 380
// un := CreateHuman ;
6021: LD_ADDR_VAR 0 1
6025: PUSH
6026: CALL_OW 44
6030: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6031: LD_VAR 0 1
6035: PPUSH
6036: LD_INT 88
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: LD_INT 2
6044: PPUSH
6045: LD_INT 0
6047: PPUSH
6048: CALL 49386 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6052: LD_VAR 0 1
6056: PPUSH
6057: LD_INT 130
6059: PPUSH
6060: LD_INT 35
6062: PPUSH
6063: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6067: LD_VAR 0 1
6071: PPUSH
6072: LD_INT 132
6074: PPUSH
6075: LD_INT 39
6077: PPUSH
6078: CALL_OW 218
// end ; end_of_file
6082: PPOPN 1
6084: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6085: LD_INT 0
6087: PPUSH
6088: PPUSH
6089: PPUSH
6090: PPUSH
6091: PPUSH
6092: PPUSH
// popov_side := 3 ;
6093: LD_ADDR_EXP 17
6097: PUSH
6098: LD_INT 3
6100: ST_TO_ADDR
// uc_side := popov_side ;
6101: LD_ADDR_OWVAR 20
6105: PUSH
6106: LD_EXP 17
6110: ST_TO_ADDR
// uc_nation := 3 ;
6111: LD_ADDR_OWVAR 21
6115: PUSH
6116: LD_INT 3
6118: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6119: LD_ADDR_VAR 0 6
6123: PUSH
6124: LD_INT 5
6126: PUSH
6127: LD_INT 103
6129: PUSH
6130: LD_INT 147
6132: PUSH
6133: LD_INT 3
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PUSH
6142: LD_INT 5
6144: PUSH
6145: LD_INT 70
6147: PUSH
6148: LD_INT 117
6150: PUSH
6151: LD_INT 3
6153: PUSH
6154: EMPTY
6155: LIST
6156: LIST
6157: LIST
6158: LIST
6159: PUSH
6160: LD_INT 6
6162: PUSH
6163: LD_INT 76
6165: PUSH
6166: LD_INT 145
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 10
6174: PUSH
6175: LD_INT 11
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: LIST
6184: LIST
6185: PUSH
6186: LD_INT 26
6188: PUSH
6189: LD_INT 87
6191: PUSH
6192: LD_INT 144
6194: PUSH
6195: LD_INT 0
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: LIST
6202: LIST
6203: PUSH
6204: LD_INT 29
6206: PUSH
6207: LD_INT 86
6209: PUSH
6210: LD_INT 118
6212: PUSH
6213: LD_INT 0
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: LIST
6220: LIST
6221: PUSH
6222: LD_INT 29
6224: PUSH
6225: LD_INT 98
6227: PUSH
6228: LD_INT 121
6230: PUSH
6231: LD_INT 0
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: LIST
6238: LIST
6239: PUSH
6240: LD_INT 26
6242: PUSH
6243: LD_INT 87
6245: PUSH
6246: LD_INT 147
6248: PUSH
6249: LD_INT 1
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: LIST
6256: LIST
6257: PUSH
6258: LD_INT 30
6260: PUSH
6261: LD_INT 123
6263: PUSH
6264: LD_INT 151
6266: PUSH
6267: LD_INT 1
6269: PUSH
6270: EMPTY
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: PUSH
6276: LD_INT 3
6278: PUSH
6279: LD_INT 94
6281: PUSH
6282: LD_INT 161
6284: PUSH
6285: LD_INT 0
6287: PUSH
6288: EMPTY
6289: LIST
6290: LIST
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 6
6296: PUSH
6297: LD_INT 81
6299: PUSH
6300: LD_INT 155
6302: PUSH
6303: LD_INT 1
6305: PUSH
6306: LD_INT 12
6308: PUSH
6309: LD_INT 14
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: LIST
6317: LIST
6318: LIST
6319: PUSH
6320: LD_INT 26
6322: PUSH
6323: LD_INT 96
6325: PUSH
6326: LD_INT 152
6328: PUSH
6329: LD_INT 0
6331: PUSH
6332: EMPTY
6333: LIST
6334: LIST
6335: LIST
6336: LIST
6337: PUSH
6338: LD_INT 26
6340: PUSH
6341: LD_INT 96
6343: PUSH
6344: LD_INT 149
6346: PUSH
6347: LD_INT 3
6349: PUSH
6350: EMPTY
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: PUSH
6356: LD_INT 32
6358: PUSH
6359: LD_INT 109
6361: PUSH
6362: LD_INT 142
6364: PUSH
6365: LD_INT 3
6367: PUSH
6368: LD_INT 46
6370: PUSH
6371: EMPTY
6372: LIST
6373: LIST
6374: LIST
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 32
6380: PUSH
6381: LD_INT 112
6383: PUSH
6384: LD_INT 148
6386: PUSH
6387: LD_INT 3
6389: PUSH
6390: LD_INT 46
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: LIST
6397: LIST
6398: LIST
6399: PUSH
6400: LD_INT 33
6402: PUSH
6403: LD_INT 120
6405: PUSH
6406: LD_INT 159
6408: PUSH
6409: LD_INT 4
6411: PUSH
6412: LD_INT 45
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: LIST
6419: LIST
6420: LIST
6421: PUSH
6422: LD_INT 33
6424: PUSH
6425: LD_INT 122
6427: PUSH
6428: LD_INT 163
6430: PUSH
6431: LD_INT 4
6433: PUSH
6434: LD_INT 45
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: LIST
6442: LIST
6443: PUSH
6444: LD_INT 33
6446: PUSH
6447: LD_INT 123
6449: PUSH
6450: LD_INT 167
6452: PUSH
6453: LD_INT 4
6455: PUSH
6456: LD_INT 45
6458: PUSH
6459: EMPTY
6460: LIST
6461: LIST
6462: LIST
6463: LIST
6464: LIST
6465: PUSH
6466: LD_INT 33
6468: PUSH
6469: LD_INT 59
6471: PUSH
6472: LD_INT 111
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: LD_INT 45
6480: PUSH
6481: EMPTY
6482: LIST
6483: LIST
6484: LIST
6485: LIST
6486: LIST
6487: PUSH
6488: LD_INT 33
6490: PUSH
6491: LD_INT 65
6493: PUSH
6494: LD_INT 111
6496: PUSH
6497: LD_INT 3
6499: PUSH
6500: LD_INT 46
6502: PUSH
6503: EMPTY
6504: LIST
6505: LIST
6506: LIST
6507: LIST
6508: LIST
6509: PUSH
6510: LD_INT 33
6512: PUSH
6513: LD_INT 76
6515: PUSH
6516: LD_INT 117
6518: PUSH
6519: LD_INT 3
6521: PUSH
6522: LD_INT 45
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: PUSH
6532: LD_INT 33
6534: PUSH
6535: LD_INT 80
6537: PUSH
6538: LD_INT 119
6540: PUSH
6541: LD_INT 3
6543: PUSH
6544: LD_INT 46
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: LIST
6551: LIST
6552: LIST
6553: PUSH
6554: LD_INT 33
6556: PUSH
6557: LD_INT 87
6559: PUSH
6560: LD_INT 125
6562: PUSH
6563: LD_INT 3
6565: PUSH
6566: LD_INT 45
6568: PUSH
6569: EMPTY
6570: LIST
6571: LIST
6572: LIST
6573: LIST
6574: LIST
6575: PUSH
6576: LD_INT 5
6578: PUSH
6579: LD_INT 92
6581: PUSH
6582: LD_INT 129
6584: PUSH
6585: LD_INT 3
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: LIST
6592: LIST
6593: PUSH
6594: LD_INT 28
6596: PUSH
6597: LD_INT 85
6599: PUSH
6600: LD_INT 165
6602: PUSH
6603: LD_INT 0
6605: PUSH
6606: EMPTY
6607: LIST
6608: LIST
6609: LIST
6610: LIST
6611: PUSH
6612: LD_INT 28
6614: PUSH
6615: LD_INT 83
6617: PUSH
6618: LD_INT 161
6620: PUSH
6621: LD_INT 4
6623: PUSH
6624: EMPTY
6625: LIST
6626: LIST
6627: LIST
6628: LIST
6629: PUSH
6630: LD_INT 28
6632: PUSH
6633: LD_INT 91
6635: PUSH
6636: LD_INT 166
6638: PUSH
6639: LD_INT 3
6641: PUSH
6642: EMPTY
6643: LIST
6644: LIST
6645: LIST
6646: LIST
6647: PUSH
6648: LD_INT 28
6650: PUSH
6651: LD_INT 102
6653: PUSH
6654: LD_INT 166
6656: PUSH
6657: LD_INT 2
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: LIST
6664: LIST
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: LIST
6672: LIST
6673: LIST
6674: LIST
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: LIST
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: LIST
6690: LIST
6691: LIST
6692: LIST
6693: LIST
6694: ST_TO_ADDR
// for i in list do
6695: LD_ADDR_VAR 0 2
6699: PUSH
6700: LD_VAR 0 6
6704: PUSH
6705: FOR_IN
6706: IFFALSE 6884
// begin uc_side := 3 ;
6708: LD_ADDR_OWVAR 20
6712: PUSH
6713: LD_INT 3
6715: ST_TO_ADDR
// uc_nation := 3 ;
6716: LD_ADDR_OWVAR 21
6720: PUSH
6721: LD_INT 3
6723: ST_TO_ADDR
// bc_type := i [ 1 ] ;
6724: LD_ADDR_OWVAR 42
6728: PUSH
6729: LD_VAR 0 2
6733: PUSH
6734: LD_INT 1
6736: ARRAY
6737: ST_TO_ADDR
// bc_kind1 := - 1 ;
6738: LD_ADDR_OWVAR 44
6742: PUSH
6743: LD_INT 1
6745: NEG
6746: ST_TO_ADDR
// bc_kind2 := - 1 ;
6747: LD_ADDR_OWVAR 45
6751: PUSH
6752: LD_INT 1
6754: NEG
6755: ST_TO_ADDR
// if i [ 1 ] = b_lab then
6756: LD_VAR 0 2
6760: PUSH
6761: LD_INT 1
6763: ARRAY
6764: PUSH
6765: LD_INT 6
6767: EQUAL
6768: IFFALSE 6806
// begin bc_type := b_lab_full ;
6770: LD_ADDR_OWVAR 42
6774: PUSH
6775: LD_INT 8
6777: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
6778: LD_ADDR_OWVAR 44
6782: PUSH
6783: LD_VAR 0 2
6787: PUSH
6788: LD_INT 5
6790: ARRAY
6791: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
6792: LD_ADDR_OWVAR 45
6796: PUSH
6797: LD_VAR 0 2
6801: PUSH
6802: LD_INT 6
6804: ARRAY
6805: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
6806: LD_ADDR_VAR 0 5
6810: PUSH
6811: LD_VAR 0 2
6815: PUSH
6816: LD_INT 2
6818: ARRAY
6819: PPUSH
6820: LD_VAR 0 2
6824: PUSH
6825: LD_INT 3
6827: ARRAY
6828: PPUSH
6829: LD_VAR 0 2
6833: PUSH
6834: LD_INT 4
6836: ARRAY
6837: PPUSH
6838: CALL_OW 47
6842: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
6843: LD_VAR 0 2
6847: PUSH
6848: LD_INT 1
6850: ARRAY
6851: PUSH
6852: LD_INT 33
6854: PUSH
6855: LD_INT 32
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: IN
6862: IFFALSE 6882
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
6864: LD_VAR 0 5
6868: PPUSH
6869: LD_VAR 0 2
6873: PUSH
6874: LD_INT 5
6876: ARRAY
6877: PPUSH
6878: CALL_OW 431
// end ;
6882: GO 6705
6884: POP
6885: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
6886: LD_ADDR_VAR 0 4
6890: PUSH
6891: LD_INT 9
6893: PPUSH
6894: LD_INT 3
6896: PPUSH
6897: LD_STRING 
6899: PPUSH
6900: LD_INT 8
6902: PUSH
6903: LD_INT 7
6905: PUSH
6906: LD_INT 6
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: LIST
6913: PUSH
6914: LD_OWVAR 67
6918: ARRAY
6919: PPUSH
6920: LD_INT 11500
6922: PUSH
6923: LD_INT 1100
6925: PUSH
6926: LD_INT 60
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: LIST
6933: PPUSH
6934: LD_INT 6
6936: PUSH
6937: LD_INT 6
6939: PUSH
6940: LD_INT 6
6942: PUSH
6943: LD_INT 6
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: PPUSH
6952: CALL 19028 0 6
6956: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
6957: LD_ADDR_EXP 23
6961: PUSH
6962: LD_EXP 23
6966: PPUSH
6967: LD_INT 3
6969: PPUSH
6970: LD_VAR 0 4
6974: PUSH
6975: LD_INT 22
6977: PUSH
6978: LD_INT 3
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PUSH
6985: LD_INT 21
6987: PUSH
6988: LD_INT 3
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: PPUSH
6999: CALL_OW 69
7003: UNION
7004: PPUSH
7005: CALL_OW 1
7009: ST_TO_ADDR
// extraPopovForces := [ ] ;
7010: LD_ADDR_EXP 18
7014: PUSH
7015: EMPTY
7016: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7017: LD_ADDR_VAR 0 2
7021: PUSH
7022: DOUBLE
7023: LD_INT 1
7025: DEC
7026: ST_TO_ADDR
7027: LD_INT 8
7029: PUSH
7030: LD_INT 9
7032: PUSH
7033: LD_INT 10
7035: PUSH
7036: EMPTY
7037: LIST
7038: LIST
7039: LIST
7040: PUSH
7041: LD_OWVAR 67
7045: ARRAY
7046: PUSH
7047: FOR_TO
7048: IFFALSE 7177
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7050: LD_INT 0
7052: PPUSH
7053: LD_INT 1
7055: PPUSH
7056: LD_INT 4
7058: PUSH
7059: LD_INT 5
7061: PUSH
7062: LD_INT 6
7064: PUSH
7065: EMPTY
7066: LIST
7067: LIST
7068: LIST
7069: PUSH
7070: LD_OWVAR 67
7074: ARRAY
7075: PPUSH
7076: CALL_OW 380
// un := CreateHuman ;
7080: LD_ADDR_VAR 0 3
7084: PUSH
7085: CALL_OW 44
7089: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7090: LD_INT 0
7092: PPUSH
7093: LD_INT 1
7095: PPUSH
7096: CALL_OW 12
7100: IFFALSE 7125
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7102: LD_VAR 0 3
7106: PPUSH
7107: LD_INT 131
7109: PPUSH
7110: LD_INT 110
7112: PPUSH
7113: LD_INT 8
7115: PPUSH
7116: LD_INT 0
7118: PPUSH
7119: CALL_OW 50
7123: GO 7146
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7125: LD_VAR 0 3
7129: PPUSH
7130: LD_INT 100
7132: PPUSH
7133: LD_INT 99
7135: PPUSH
7136: LD_INT 8
7138: PPUSH
7139: LD_INT 0
7141: PPUSH
7142: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7146: LD_ADDR_EXP 18
7150: PUSH
7151: LD_EXP 18
7155: PPUSH
7156: LD_EXP 18
7160: PUSH
7161: LD_INT 1
7163: PLUS
7164: PPUSH
7165: LD_VAR 0 3
7169: PPUSH
7170: CALL_OW 1
7174: ST_TO_ADDR
// end ;
7175: GO 7047
7177: POP
7178: POP
// PrepareSoldier ( false , 6 ) ;
7179: LD_INT 0
7181: PPUSH
7182: LD_INT 6
7184: PPUSH
7185: CALL_OW 381
// un := CreateHuman ;
7189: LD_ADDR_VAR 0 3
7193: PUSH
7194: CALL_OW 44
7198: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7199: LD_VAR 0 3
7203: PPUSH
7204: LD_INT 1
7206: PPUSH
7207: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7211: LD_VAR 0 3
7215: PPUSH
7216: LD_INT 150
7218: PPUSH
7219: LD_INT 158
7221: PPUSH
7222: CALL_OW 428
7226: PPUSH
7227: CALL_OW 52
// popovAttackGroup := [ ] ;
7231: LD_ADDR_EXP 19
7235: PUSH
7236: EMPTY
7237: ST_TO_ADDR
// end ;
7238: LD_VAR 0 1
7242: RET
// export function InitMC_Popov ( ) ; begin
7243: LD_INT 0
7245: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7246: LD_INT 3
7248: PPUSH
7249: LD_INT 3
7251: PPUSH
7252: CALL 74938 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7256: LD_INT 3
7258: PPUSH
7259: LD_INT 10
7261: PPUSH
7262: CALL 74882 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7266: LD_INT 3
7268: PPUSH
7269: LD_INT 86
7271: PUSH
7272: LD_INT 118
7274: PUSH
7275: LD_INT 0
7277: PUSH
7278: EMPTY
7279: LIST
7280: LIST
7281: LIST
7282: PUSH
7283: LD_INT 123
7285: PUSH
7286: LD_INT 151
7288: PUSH
7289: LD_INT 1
7291: PUSH
7292: EMPTY
7293: LIST
7294: LIST
7295: LIST
7296: PUSH
7297: LD_INT 98
7299: PUSH
7300: LD_INT 121
7302: PUSH
7303: LD_INT 0
7305: PUSH
7306: EMPTY
7307: LIST
7308: LIST
7309: LIST
7310: PUSH
7311: EMPTY
7312: LIST
7313: LIST
7314: LIST
7315: PPUSH
7316: CALL 73941 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7320: LD_INT 3
7322: PPUSH
7323: LD_INT 46
7325: PUSH
7326: LD_INT 45
7328: PUSH
7329: EMPTY
7330: LIST
7331: LIST
7332: PPUSH
7333: CALL 74770 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7337: LD_INT 3
7339: PPUSH
7340: LD_INT 12
7342: PPUSH
7343: CALL 74452 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7347: LD_INT 3
7349: PPUSH
7350: LD_INT 11
7352: PPUSH
7353: CALL 74183 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7357: LD_INT 3
7359: PPUSH
7360: LD_INT 4
7362: PPUSH
7363: CALL 73802 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7367: LD_INT 3
7369: PPUSH
7370: LD_INT 23
7372: PUSH
7373: LD_INT 1
7375: PUSH
7376: LD_INT 3
7378: PUSH
7379: LD_INT 44
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: LIST
7386: LIST
7387: PUSH
7388: LD_INT 23
7390: PUSH
7391: LD_INT 1
7393: PUSH
7394: LD_INT 3
7396: PUSH
7397: LD_INT 45
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: LD_INT 21
7408: PUSH
7409: LD_INT 1
7411: PUSH
7412: LD_INT 3
7414: PUSH
7415: LD_INT 44
7417: PUSH
7418: EMPTY
7419: LIST
7420: LIST
7421: LIST
7422: LIST
7423: PUSH
7424: LD_INT 21
7426: PUSH
7427: LD_INT 1
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: LD_INT 45
7435: PUSH
7436: EMPTY
7437: LIST
7438: LIST
7439: LIST
7440: LIST
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PPUSH
7448: CALL 73617 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7452: LD_INT 3
7454: PPUSH
7455: LD_INT 94
7457: PPUSH
7458: LD_INT 161
7460: PPUSH
7461: LD_INT 0
7463: PPUSH
7464: LD_INT 19
7466: PUSH
7467: LD_INT 17
7469: PUSH
7470: LD_INT 18
7472: PUSH
7473: LD_INT 24
7475: PUSH
7476: LD_INT 21
7478: PUSH
7479: EMPTY
7480: LIST
7481: LIST
7482: LIST
7483: LIST
7484: LIST
7485: PPUSH
7486: CALL 74564 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7490: LD_INT 3
7492: PPUSH
7493: LD_INT 21
7495: PUSH
7496: LD_INT 1
7498: PUSH
7499: LD_INT 3
7501: PUSH
7502: LD_INT 51
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: LIST
7509: LIST
7510: PUSH
7511: EMPTY
7512: LIST
7513: PPUSH
7514: CALL 73665 0 2
// end ;
7518: LD_VAR 0 1
7522: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7523: LD_EXP 18
7527: PUSH
7528: LD_EXP 5
7532: NOT
7533: AND
7534: IFFALSE 7594
7536: GO 7538
7538: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7539: LD_EXP 18
7543: PPUSH
7544: LD_INT 106
7546: PPUSH
7547: LD_INT 137
7549: PPUSH
7550: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7554: LD_ADDR_EXP 23
7558: PUSH
7559: LD_EXP 23
7563: PPUSH
7564: LD_INT 3
7566: PPUSH
7567: LD_EXP 23
7571: PUSH
7572: LD_INT 3
7574: ARRAY
7575: PUSH
7576: LD_EXP 18
7580: UNION
7581: PPUSH
7582: CALL_OW 1
7586: ST_TO_ADDR
// extraPopovForces := [ ] ;
7587: LD_ADDR_EXP 18
7591: PUSH
7592: EMPTY
7593: ST_TO_ADDR
// end ;
7594: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7595: LD_INT 9
7597: PPUSH
7598: CALL_OW 302
7602: PUSH
7603: LD_EXP 5
7607: NOT
7608: AND
7609: IFFALSE 8175
7611: GO 7613
7613: DISABLE
7614: LD_INT 0
7616: PPUSH
7617: PPUSH
7618: PPUSH
7619: PPUSH
7620: PPUSH
// begin enable ;
7621: ENABLE
// base := 3 ;
7622: LD_ADDR_VAR 0 2
7626: PUSH
7627: LD_INT 3
7629: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7630: LD_ADDR_VAR 0 3
7634: PUSH
7635: LD_INT 22
7637: PUSH
7638: LD_INT 1
7640: PUSH
7641: LD_INT 3
7643: PUSH
7644: LD_INT 44
7646: PUSH
7647: EMPTY
7648: LIST
7649: LIST
7650: LIST
7651: LIST
7652: PUSH
7653: LD_INT 24
7655: PUSH
7656: LD_INT 1
7658: PUSH
7659: LD_INT 3
7661: PUSH
7662: LD_INT 46
7664: PUSH
7665: EMPTY
7666: LIST
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 24
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: LD_INT 3
7679: PUSH
7680: LD_INT 46
7682: PUSH
7683: EMPTY
7684: LIST
7685: LIST
7686: LIST
7687: LIST
7688: PUSH
7689: LD_INT 24
7691: PUSH
7692: LD_INT 1
7694: PUSH
7695: LD_INT 3
7697: PUSH
7698: LD_INT 46
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: PUSH
7707: EMPTY
7708: LIST
7709: LIST
7710: LIST
7711: LIST
7712: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7713: LD_ADDR_VAR 0 5
7717: PUSH
7718: LD_VAR 0 5
7722: PUSH
7723: LD_OWVAR 1
7727: PUSH
7728: LD_INT 21000
7730: DIV
7731: PLUS
7732: ST_TO_ADDR
// if amount > 8 then
7733: LD_VAR 0 5
7737: PUSH
7738: LD_INT 8
7740: GREATER
7741: IFFALSE 7751
// amount := 8 ;
7743: LD_ADDR_VAR 0 5
7747: PUSH
7748: LD_INT 8
7750: ST_TO_ADDR
// for i = 1 to amount do
7751: LD_ADDR_VAR 0 1
7755: PUSH
7756: DOUBLE
7757: LD_INT 1
7759: DEC
7760: ST_TO_ADDR
7761: LD_VAR 0 5
7765: PUSH
7766: FOR_TO
7767: IFFALSE 7832
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7769: LD_ADDR_VAR 0 3
7773: PUSH
7774: LD_VAR 0 3
7778: PPUSH
7779: LD_VAR 0 3
7783: PUSH
7784: LD_INT 1
7786: PLUS
7787: PPUSH
7788: LD_INT 24
7790: PUSH
7791: LD_INT 1
7793: PUSH
7794: LD_INT 3
7796: PUSH
7797: LD_INT 46
7799: PUSH
7800: LD_INT 45
7802: PUSH
7803: EMPTY
7804: LIST
7805: LIST
7806: PUSH
7807: LD_INT 1
7809: PPUSH
7810: LD_INT 2
7812: PPUSH
7813: CALL_OW 12
7817: ARRAY
7818: PUSH
7819: EMPTY
7820: LIST
7821: LIST
7822: LIST
7823: LIST
7824: PPUSH
7825: CALL_OW 2
7829: ST_TO_ADDR
7830: GO 7766
7832: POP
7833: POP
// MC_InsertProduceList ( base , tmp ) ;
7834: LD_VAR 0 2
7838: PPUSH
7839: LD_VAR 0 3
7843: PPUSH
7844: CALL 73665 0 2
// repeat wait ( 0 0$1 ) ;
7848: LD_INT 35
7850: PPUSH
7851: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
7855: LD_VAR 0 2
7859: PPUSH
7860: LD_INT 1
7862: PPUSH
7863: CALL 75083 0 2
7867: PUSH
7868: LD_VAR 0 5
7872: GREATEREQUAL
7873: IFFALSE 7848
// wait ( 0 0$30 ) ;
7875: LD_INT 1050
7877: PPUSH
7878: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
7882: LD_ADDR_VAR 0 4
7886: PUSH
7887: LD_EXP 42
7891: PUSH
7892: LD_VAR 0 2
7896: ARRAY
7897: PUSH
7898: LD_EXP 42
7902: PUSH
7903: LD_VAR 0 2
7907: ARRAY
7908: PPUSH
7909: LD_INT 2
7911: PUSH
7912: LD_INT 34
7914: PUSH
7915: LD_INT 51
7917: PUSH
7918: EMPTY
7919: LIST
7920: LIST
7921: PUSH
7922: LD_INT 34
7924: PUSH
7925: LD_INT 52
7927: PUSH
7928: EMPTY
7929: LIST
7930: LIST
7931: PUSH
7932: EMPTY
7933: LIST
7934: LIST
7935: LIST
7936: PPUSH
7937: CALL_OW 72
7941: DIFF
7942: ST_TO_ADDR
// if not attackers then
7943: LD_VAR 0 4
7947: NOT
7948: IFFALSE 7952
// exit ;
7950: GO 8175
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
7952: LD_ADDR_EXP 42
7956: PUSH
7957: LD_EXP 42
7961: PPUSH
7962: LD_VAR 0 2
7966: PPUSH
7967: LD_EXP 42
7971: PUSH
7972: LD_VAR 0 2
7976: ARRAY
7977: PUSH
7978: LD_VAR 0 4
7982: DIFF
7983: PPUSH
7984: CALL_OW 1
7988: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
7989: LD_VAR 0 4
7993: PPUSH
7994: LD_INT 107
7996: PPUSH
7997: LD_INT 74
7999: PPUSH
8000: CALL_OW 114
// wait ( 0 0$5 ) ;
8004: LD_INT 175
8006: PPUSH
8007: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8011: LD_INT 35
8013: PPUSH
8014: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8018: LD_VAR 0 4
8022: PPUSH
8023: LD_INT 60
8025: PUSH
8026: EMPTY
8027: LIST
8028: PPUSH
8029: CALL_OW 72
8033: NOT
8034: IFFALSE 8011
// if rand ( 0 , 1 ) then
8036: LD_INT 0
8038: PPUSH
8039: LD_INT 1
8041: PPUSH
8042: CALL_OW 12
8046: IFFALSE 8065
// ComAgressiveMove ( attackers , 155 , 108 ) else
8048: LD_VAR 0 4
8052: PPUSH
8053: LD_INT 155
8055: PPUSH
8056: LD_INT 108
8058: PPUSH
8059: CALL_OW 114
8063: GO 8080
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8065: LD_VAR 0 4
8069: PPUSH
8070: LD_INT 149
8072: PPUSH
8073: LD_INT 55
8075: PPUSH
8076: CALL_OW 114
// wait ( 0 0$10 ) ;
8080: LD_INT 350
8082: PPUSH
8083: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8087: LD_INT 35
8089: PPUSH
8090: CALL_OW 67
// for i in attackers do
8094: LD_ADDR_VAR 0 1
8098: PUSH
8099: LD_VAR 0 4
8103: PUSH
8104: FOR_IN
8105: IFFALSE 8155
// if not HasTask ( i ) then
8107: LD_VAR 0 1
8111: PPUSH
8112: CALL_OW 314
8116: NOT
8117: IFFALSE 8153
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8119: LD_VAR 0 1
8123: PPUSH
8124: LD_INT 81
8126: PUSH
8127: LD_INT 3
8129: PUSH
8130: EMPTY
8131: LIST
8132: LIST
8133: PPUSH
8134: CALL_OW 69
8138: PPUSH
8139: LD_VAR 0 1
8143: PPUSH
8144: CALL_OW 74
8148: PPUSH
8149: CALL_OW 115
8153: GO 8104
8155: POP
8156: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8157: LD_VAR 0 4
8161: PPUSH
8162: LD_INT 50
8164: PUSH
8165: EMPTY
8166: LIST
8167: PPUSH
8168: CALL_OW 72
8172: NOT
8173: IFFALSE 8087
// end ;
8175: PPOPN 5
8177: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8178: LD_EXP 5
8182: NOT
8183: IFFALSE 8770
8185: GO 8187
8187: DISABLE
8188: LD_INT 0
8190: PPUSH
8191: PPUSH
8192: PPUSH
8193: PPUSH
// begin enable ;
8194: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8195: LD_OWVAR 67
8199: PUSH
8200: LD_INT 1
8202: EQUAL
8203: PUSH
8204: LD_OWVAR 1
8208: PUSH
8209: LD_INT 63000
8211: LESS
8212: AND
8213: IFFALSE 8217
// exit ;
8215: GO 8770
// tmp := [ ] ;
8217: LD_ADDR_VAR 0 3
8221: PUSH
8222: EMPTY
8223: ST_TO_ADDR
// if tick < 45 45$00 then
8224: LD_OWVAR 1
8228: PUSH
8229: LD_INT 94500
8231: LESS
8232: IFFALSE 8409
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8234: LD_ADDR_VAR 0 1
8238: PUSH
8239: DOUBLE
8240: LD_INT 1
8242: DEC
8243: ST_TO_ADDR
8244: LD_INT 2
8246: PUSH
8247: LD_INT 3
8249: PUSH
8250: LD_INT 4
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: LIST
8257: PUSH
8258: LD_OWVAR 67
8262: ARRAY
8263: PUSH
8264: FOR_TO
8265: IFFALSE 8407
// begin uc_side := 3 ;
8267: LD_ADDR_OWVAR 20
8271: PUSH
8272: LD_INT 3
8274: ST_TO_ADDR
// uc_nation := 3 ;
8275: LD_ADDR_OWVAR 21
8279: PUSH
8280: LD_INT 3
8282: ST_TO_ADDR
// InitHC_All ( ) ;
8283: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8287: LD_INT 0
8289: PPUSH
8290: LD_INT 1
8292: PPUSH
8293: LD_INT 5
8295: PUSH
8296: LD_INT 6
8298: PUSH
8299: LD_INT 7
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: LIST
8306: PUSH
8307: LD_OWVAR 67
8311: ARRAY
8312: PPUSH
8313: CALL_OW 380
// un := CreateHuman ;
8317: LD_ADDR_VAR 0 2
8321: PUSH
8322: CALL_OW 44
8326: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8327: LD_VAR 0 2
8331: PPUSH
8332: LD_INT 18
8334: PPUSH
8335: LD_INT 0
8337: PPUSH
8338: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8342: LD_VAR 0 2
8346: PPUSH
8347: LD_INT 9
8349: PPUSH
8350: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8354: LD_VAR 0 2
8358: PPUSH
8359: LD_INT 147
8361: PPUSH
8362: LD_INT 161
8364: PPUSH
8365: CALL_OW 111
// wait ( 0 0$2 ) ;
8369: LD_INT 70
8371: PPUSH
8372: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8376: LD_ADDR_VAR 0 3
8380: PUSH
8381: LD_VAR 0 3
8385: PPUSH
8386: LD_VAR 0 3
8390: PUSH
8391: LD_INT 1
8393: PLUS
8394: PPUSH
8395: LD_VAR 0 2
8399: PPUSH
8400: CALL_OW 1
8404: ST_TO_ADDR
// end ;
8405: GO 8264
8407: POP
8408: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8409: LD_ADDR_VAR 0 4
8413: PUSH
8414: LD_INT 3
8416: PUSH
8417: LD_INT 4
8419: PUSH
8420: LD_INT 5
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: LIST
8427: PUSH
8428: LD_OWVAR 67
8432: ARRAY
8433: PUSH
8434: LD_OWVAR 1
8438: PUSH
8439: LD_INT 21000
8441: DIV
8442: PLUS
8443: ST_TO_ADDR
// if amount > 15 then
8444: LD_VAR 0 4
8448: PUSH
8449: LD_INT 15
8451: GREATER
8452: IFFALSE 8462
// amount := 15 ;
8454: LD_ADDR_VAR 0 4
8458: PUSH
8459: LD_INT 15
8461: ST_TO_ADDR
// for i := 1 to amount do
8462: LD_ADDR_VAR 0 1
8466: PUSH
8467: DOUBLE
8468: LD_INT 1
8470: DEC
8471: ST_TO_ADDR
8472: LD_VAR 0 4
8476: PUSH
8477: FOR_TO
8478: IFFALSE 8624
// begin uc_side := 3 ;
8480: LD_ADDR_OWVAR 20
8484: PUSH
8485: LD_INT 3
8487: ST_TO_ADDR
// uc_nation := 3 ;
8488: LD_ADDR_OWVAR 21
8492: PUSH
8493: LD_INT 3
8495: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8496: LD_INT 24
8498: PPUSH
8499: LD_INT 1
8501: PPUSH
8502: LD_INT 3
8504: PPUSH
8505: LD_INT 46
8507: PUSH
8508: LD_INT 45
8510: PUSH
8511: LD_INT 44
8513: PUSH
8514: LD_INT 43
8516: PUSH
8517: LD_INT 42
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: LIST
8524: LIST
8525: LIST
8526: PUSH
8527: LD_INT 1
8529: PPUSH
8530: LD_INT 5
8532: PPUSH
8533: CALL_OW 12
8537: ARRAY
8538: PPUSH
8539: LD_INT 90
8541: PPUSH
8542: CALL 15582 0 5
// un := CreateVehicle ;
8546: LD_ADDR_VAR 0 2
8550: PUSH
8551: CALL_OW 45
8555: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8556: LD_VAR 0 2
8560: PPUSH
8561: LD_INT 18
8563: PPUSH
8564: LD_INT 0
8566: PPUSH
8567: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8571: LD_VAR 0 2
8575: PPUSH
8576: LD_INT 147
8578: PPUSH
8579: LD_INT 161
8581: PPUSH
8582: CALL_OW 111
// wait ( 0 0$3 ) ;
8586: LD_INT 105
8588: PPUSH
8589: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8593: LD_ADDR_VAR 0 3
8597: PUSH
8598: LD_VAR 0 3
8602: PPUSH
8603: LD_VAR 0 3
8607: PUSH
8608: LD_INT 1
8610: PLUS
8611: PPUSH
8612: LD_VAR 0 2
8616: PPUSH
8617: CALL_OW 1
8621: ST_TO_ADDR
// end ;
8622: GO 8477
8624: POP
8625: POP
// if not tmp then
8626: LD_VAR 0 3
8630: NOT
8631: IFFALSE 8635
// exit ;
8633: GO 8770
// wait ( 0 0$5 ) ;
8635: LD_INT 175
8637: PPUSH
8638: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8642: LD_INT 70
8644: PPUSH
8645: CALL_OW 67
// for i in tmp do
8649: LD_ADDR_VAR 0 1
8653: PUSH
8654: LD_VAR 0 3
8658: PUSH
8659: FOR_IN
8660: IFFALSE 8761
// begin if not IsOk ( i ) or IsDead ( i ) then
8662: LD_VAR 0 1
8666: PPUSH
8667: CALL_OW 302
8671: NOT
8672: PUSH
8673: LD_VAR 0 1
8677: PPUSH
8678: CALL_OW 301
8682: OR
8683: IFFALSE 8701
// tmp := tmp diff i ;
8685: LD_ADDR_VAR 0 3
8689: PUSH
8690: LD_VAR 0 3
8694: PUSH
8695: LD_VAR 0 1
8699: DIFF
8700: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8701: LD_VAR 0 1
8705: PPUSH
8706: CALL_OW 257
8710: PUSH
8711: LD_INT 9
8713: EQUAL
8714: IFFALSE 8725
// ComSpaceTimeShoot ( i ) ;
8716: LD_VAR 0 1
8720: PPUSH
8721: CALL 11665 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8725: LD_VAR 0 1
8729: PPUSH
8730: LD_INT 81
8732: PUSH
8733: LD_INT 3
8735: PUSH
8736: EMPTY
8737: LIST
8738: LIST
8739: PPUSH
8740: CALL_OW 69
8744: PPUSH
8745: LD_VAR 0 1
8749: PPUSH
8750: CALL_OW 74
8754: PPUSH
8755: CALL_OW 115
// end ;
8759: GO 8659
8761: POP
8762: POP
// until not tmp ;
8763: LD_VAR 0 3
8767: NOT
8768: IFFALSE 8642
// end ; end_of_file
8770: PPOPN 4
8772: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
8773: LD_INT 0
8775: PPUSH
8776: PPUSH
8777: PPUSH
8778: PPUSH
// uc_side := 1 ;
8779: LD_ADDR_OWVAR 20
8783: PUSH
8784: LD_INT 1
8786: ST_TO_ADDR
// uc_nation := 1 ;
8787: LD_ADDR_OWVAR 21
8791: PUSH
8792: LD_INT 1
8794: ST_TO_ADDR
// hc_importance := 100 ;
8795: LD_ADDR_OWVAR 32
8799: PUSH
8800: LD_INT 100
8802: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
8803: LD_ADDR_OWVAR 26
8807: PUSH
8808: LD_STRING Jeremy Sikorski
8810: ST_TO_ADDR
// hc_gallery := us ;
8811: LD_ADDR_OWVAR 33
8815: PUSH
8816: LD_STRING us
8818: ST_TO_ADDR
// hc_face_number := 19 ;
8819: LD_ADDR_OWVAR 34
8823: PUSH
8824: LD_INT 19
8826: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
8827: LD_INT 1
8829: PPUSH
8830: LD_INT 1
8832: PPUSH
8833: LD_INT 4
8835: PUSH
8836: LD_INT 4
8838: PUSH
8839: LD_INT 3
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: LIST
8846: PUSH
8847: LD_OWVAR 67
8851: ARRAY
8852: PPUSH
8853: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
8857: LD_ADDR_OWVAR 29
8861: PUSH
8862: LD_INT 10
8864: PUSH
8865: LD_INT 12
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: ST_TO_ADDR
// Sikorski := CreateHuman ;
8872: LD_ADDR_EXP 20
8876: PUSH
8877: CALL_OW 44
8881: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
8882: LD_EXP 20
8886: PPUSH
8887: LD_INT 133
8889: PPUSH
8890: LD_INT 19
8892: PPUSH
8893: LD_INT 2
8895: PPUSH
8896: LD_INT 0
8898: PPUSH
8899: CALL_OW 50
// InitHc_All ( ) ;
8903: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
8907: LD_ADDR_VAR 0 2
8911: PUSH
8912: DOUBLE
8913: LD_INT 1
8915: DEC
8916: ST_TO_ADDR
8917: LD_INT 4
8919: PUSH
8920: LD_INT 3
8922: PUSH
8923: LD_INT 3
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: LIST
8930: PUSH
8931: LD_OWVAR 67
8935: ARRAY
8936: PUSH
8937: FOR_TO
8938: IFFALSE 9054
// for j := 1 to 4 do
8940: LD_ADDR_VAR 0 3
8944: PUSH
8945: DOUBLE
8946: LD_INT 1
8948: DEC
8949: ST_TO_ADDR
8950: LD_INT 4
8952: PUSH
8953: FOR_TO
8954: IFFALSE 9050
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
8956: LD_INT 0
8958: PPUSH
8959: LD_VAR 0 3
8963: PPUSH
8964: LD_INT 5
8966: PUSH
8967: LD_INT 4
8969: PUSH
8970: LD_INT 3
8972: PUSH
8973: EMPTY
8974: LIST
8975: LIST
8976: LIST
8977: PUSH
8978: LD_OWVAR 67
8982: ARRAY
8983: PPUSH
8984: CALL_OW 380
// un := CreateHuman ;
8988: LD_ADDR_VAR 0 4
8992: PUSH
8993: CALL_OW 44
8997: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
8998: LD_VAR 0 4
9002: PPUSH
9003: LD_INT 0
9005: PPUSH
9006: LD_INT 5
9008: PPUSH
9009: CALL_OW 12
9013: PPUSH
9014: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9018: LD_VAR 0 4
9022: PPUSH
9023: LD_INT 133
9025: PPUSH
9026: LD_INT 19
9028: PPUSH
9029: LD_INT 6
9031: PPUSH
9032: LD_INT 0
9034: PPUSH
9035: CALL_OW 50
// ComHold ( un ) ;
9039: LD_VAR 0 4
9043: PPUSH
9044: CALL_OW 140
// end ;
9048: GO 8953
9050: POP
9051: POP
9052: GO 8937
9054: POP
9055: POP
// vc_chassis := us_heavy_tracked ;
9056: LD_ADDR_OWVAR 37
9060: PUSH
9061: LD_INT 4
9063: ST_TO_ADDR
// vc_engine := engine_combustion ;
9064: LD_ADDR_OWVAR 39
9068: PUSH
9069: LD_INT 1
9071: ST_TO_ADDR
// vc_control := control_manual ;
9072: LD_ADDR_OWVAR 38
9076: PUSH
9077: LD_INT 1
9079: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9080: LD_ADDR_OWVAR 40
9084: PUSH
9085: LD_INT 14
9087: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9088: LD_ADDR_OWVAR 41
9092: PUSH
9093: LD_INT 60
9095: ST_TO_ADDR
// un := CreateVehicle ;
9096: LD_ADDR_VAR 0 4
9100: PUSH
9101: CALL_OW 45
9105: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9106: LD_VAR 0 4
9110: PPUSH
9111: LD_INT 2
9113: PPUSH
9114: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9118: LD_VAR 0 4
9122: PPUSH
9123: LD_INT 128
9125: PPUSH
9126: LD_INT 12
9128: PPUSH
9129: LD_INT 0
9131: PPUSH
9132: CALL_OW 48
// for i := 1 to 3 do
9136: LD_ADDR_VAR 0 2
9140: PUSH
9141: DOUBLE
9142: LD_INT 1
9144: DEC
9145: ST_TO_ADDR
9146: LD_INT 3
9148: PUSH
9149: FOR_TO
9150: IFFALSE 9173
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9152: LD_INT 5
9154: PPUSH
9155: LD_INT 133
9157: PPUSH
9158: LD_INT 19
9160: PPUSH
9161: LD_INT 3
9163: PPUSH
9164: LD_INT 0
9166: PPUSH
9167: CALL_OW 56
9171: GO 9149
9173: POP
9174: POP
// end ; end_of_file
9175: LD_VAR 0 1
9179: RET
// export function Action ; begin
9180: LD_INT 0
9182: PPUSH
// InGameOn ;
9183: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9187: LD_INT 133
9189: PPUSH
9190: LD_INT 19
9192: PPUSH
9193: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9197: LD_EXP 20
9201: PPUSH
9202: LD_STRING WT-DS-1
9204: PPUSH
9205: CALL_OW 88
// InGameOff ;
9209: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9213: LD_STRING DestroyEnemy
9215: PPUSH
9216: CALL_OW 337
// wait ( 0 0$20 ) ;
9220: LD_INT 700
9222: PPUSH
9223: CALL_OW 67
// DialogueOn ;
9227: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9231: LD_INT 100
9233: PPUSH
9234: LD_INT 37
9236: PPUSH
9237: LD_INT 1
9239: PPUSH
9240: LD_INT 30
9242: NEG
9243: PPUSH
9244: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9248: LD_INT 100
9250: PPUSH
9251: LD_INT 37
9253: PPUSH
9254: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9258: LD_EXP 10
9262: PPUSH
9263: LD_STRING WT-PL-1
9265: PPUSH
9266: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9270: LD_EXP 20
9274: PPUSH
9275: LD_STRING WT-DS-2
9277: PPUSH
9278: CALL_OW 88
// DialogueOff ;
9282: CALL_OW 7
// wait ( 0 0$2 ) ;
9286: LD_INT 70
9288: PPUSH
9289: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9293: LD_INT 100
9295: PPUSH
9296: LD_INT 37
9298: PPUSH
9299: LD_INT 1
9301: PPUSH
9302: CALL_OW 331
// end ;
9306: LD_VAR 0 1
9310: RET
// export function DialogPowellsAttack ; begin
9311: LD_INT 0
9313: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9314: LD_EXP 10
9318: PPUSH
9319: LD_STRING WT-PL-8
9321: PPUSH
9322: CALL_OW 94
// end ;
9326: LD_VAR 0 1
9330: RET
// export function DialogContaminateSib ( x , y ) ; begin
9331: LD_INT 0
9333: PPUSH
// DialogueOn ;
9334: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9338: LD_VAR 0 1
9342: PPUSH
9343: LD_VAR 0 2
9347: PPUSH
9348: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9352: LD_EXP 20
9356: PPUSH
9357: LD_STRING WT-DS-3
9359: PPUSH
9360: CALL_OW 88
// DialogueOff ;
9364: CALL_OW 7
// end ;
9368: LD_VAR 0 3
9372: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9373: LD_EXP 8
9377: NOT
9378: PUSH
9379: LD_INT 1
9381: PPUSH
9382: LD_INT 81
9384: PUSH
9385: LD_INT 4
9387: PUSH
9388: EMPTY
9389: LIST
9390: LIST
9391: PPUSH
9392: CALL_OW 70
9396: PUSH
9397: LD_INT 3
9399: GREATER
9400: AND
9401: IFFALSE 9473
9403: GO 9405
9405: DISABLE
// begin powellInTrouble := true ;
9406: LD_ADDR_EXP 8
9410: PUSH
9411: LD_INT 1
9413: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9414: LD_EXP 20
9418: PPUSH
9419: LD_STRING WT-DS-6
9421: PPUSH
9422: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9426: LD_INT 1
9428: PPUSH
9429: LD_INT 22
9431: PUSH
9432: LD_INT 1
9434: PUSH
9435: EMPTY
9436: LIST
9437: LIST
9438: PPUSH
9439: CALL_OW 70
9443: NOT
9444: IFFALSE 9458
// SayRadio ( Powell , WT-PL-6 ) ;
9446: LD_EXP 10
9450: PPUSH
9451: LD_STRING WT-PL-6
9453: PPUSH
9454: CALL_OW 94
// wait ( 1 1$30 ) ;
9458: LD_INT 3150
9460: PPUSH
9461: CALL_OW 67
// powellInTrouble := false ;
9465: LD_ADDR_EXP 8
9469: PUSH
9470: LD_INT 0
9472: ST_TO_ADDR
// end ;
9473: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9474: LD_EXP 9
9478: NOT
9479: PUSH
9480: LD_INT 16
9482: PPUSH
9483: LD_INT 81
9485: PUSH
9486: LD_INT 1
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 70
9497: PUSH
9498: LD_INT 6
9500: GREATER
9501: AND
9502: IFFALSE 9575
9504: GO 9506
9506: DISABLE
// begin sikorskiInTrouble := true ;
9507: LD_ADDR_EXP 9
9511: PUSH
9512: LD_INT 1
9514: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9515: LD_EXP 20
9519: PPUSH
9520: LD_STRING WT-DS-7
9522: PPUSH
9523: CALL_OW 88
// if not powellAttackGroup then
9527: LD_EXP 12
9531: NOT
9532: IFFALSE 9548
// SayRadio ( Powell , WT-PL-7n ) else
9534: LD_EXP 10
9538: PPUSH
9539: LD_STRING WT-PL-7n
9541: PPUSH
9542: CALL_OW 94
9546: GO 9560
// SayRadio ( Powell , WT-PL-7y ) ;
9548: LD_EXP 10
9552: PPUSH
9553: LD_STRING WT-PL-7y
9555: PPUSH
9556: CALL_OW 94
// wait ( 1 1$30 ) ;
9560: LD_INT 3150
9562: PPUSH
9563: CALL_OW 67
// sikorskiInTrouble := false ;
9567: LD_ADDR_EXP 9
9571: PUSH
9572: LD_INT 0
9574: ST_TO_ADDR
// end ;
9575: END
// export function DialogPowellsAttackFailed ; begin
9576: LD_INT 0
9578: PPUSH
// if not ruDestroyed then
9579: LD_EXP 5
9583: NOT
9584: IFFALSE 9600
// SayRadio ( Powell , WT-PL-9 ) else
9586: LD_EXP 10
9590: PPUSH
9591: LD_STRING WT-PL-9
9593: PPUSH
9594: CALL_OW 94
9598: GO 9612
// SayRadio ( Powell , WT-PL-10 ) ;
9600: LD_EXP 10
9604: PPUSH
9605: LD_STRING WT-PL-10
9607: PPUSH
9608: CALL_OW 94
// end ;
9612: LD_VAR 0 1
9616: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9617: LD_INT 22
9619: PUSH
9620: LD_INT 2
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: PUSH
9627: LD_INT 21
9629: PUSH
9630: LD_INT 1
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: PUSH
9637: EMPTY
9638: LIST
9639: LIST
9640: PPUSH
9641: CALL_OW 69
9645: PUSH
9646: LD_INT 0
9648: EQUAL
9649: IFFALSE 9693
9651: GO 9653
9653: DISABLE
// begin arDestroyed := true ;
9654: LD_ADDR_EXP 4
9658: PUSH
9659: LD_INT 1
9661: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9662: LD_INT 2
9664: PPUSH
9665: CALL 49834 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9669: LD_EXP 20
9673: PPUSH
9674: LD_STRING WT-DS-4
9676: PPUSH
9677: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9681: LD_EXP 10
9685: PPUSH
9686: LD_STRING WT-PL-4
9688: PPUSH
9689: CALL_OW 94
// end ;
9693: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9694: LD_INT 22
9696: PUSH
9697: LD_INT 3
9699: PUSH
9700: EMPTY
9701: LIST
9702: LIST
9703: PUSH
9704: LD_INT 21
9706: PUSH
9707: LD_INT 1
9709: PUSH
9710: EMPTY
9711: LIST
9712: LIST
9713: PUSH
9714: EMPTY
9715: LIST
9716: LIST
9717: PPUSH
9718: CALL_OW 69
9722: PUSH
9723: LD_INT 0
9725: EQUAL
9726: IFFALSE 9770
9728: GO 9730
9730: DISABLE
// begin ruDestroyed := true ;
9731: LD_ADDR_EXP 5
9735: PUSH
9736: LD_INT 1
9738: ST_TO_ADDR
// MC_Kill ( 3 ) ;
9739: LD_INT 3
9741: PPUSH
9742: CALL 49834 0 1
// Say ( Sikorski , WT-DS-5 ) ;
9746: LD_EXP 20
9750: PPUSH
9751: LD_STRING WT-DS-5
9753: PPUSH
9754: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
9758: LD_EXP 10
9762: PPUSH
9763: LD_STRING WT-PL-5
9765: PPUSH
9766: CALL_OW 94
// end ;
9770: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
9771: LD_EXP 5
9775: PUSH
9776: LD_EXP 4
9780: AND
9781: IFFALSE 9954
9783: GO 9785
9785: DISABLE
// begin wait ( 0 0$3 ) ;
9786: LD_INT 105
9788: PPUSH
9789: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
9793: LD_OWVAR 1
9797: PUSH
9798: LD_INT 126000
9800: PUSH
9801: LD_INT 105000
9803: PUSH
9804: LD_INT 94500
9806: PUSH
9807: EMPTY
9808: LIST
9809: LIST
9810: LIST
9811: PUSH
9812: LD_OWVAR 67
9816: ARRAY
9817: GREATEREQUAL
9818: IFFALSE 9833
// AddMedal ( WoT-med-1 , - 1 ) else
9820: LD_STRING WoT-med-1
9822: PPUSH
9823: LD_INT 1
9825: NEG
9826: PPUSH
9827: CALL_OW 101
9831: GO 9843
// AddMedal ( WoT-med-1 , 1 ) ;
9833: LD_STRING WoT-med-1
9835: PPUSH
9836: LD_INT 1
9838: PPUSH
9839: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
9843: LD_EXP 6
9847: PUSH
9848: LD_INT 4
9850: PUSH
9851: LD_INT 3
9853: PUSH
9854: LD_INT 2
9856: PUSH
9857: EMPTY
9858: LIST
9859: LIST
9860: LIST
9861: PUSH
9862: LD_OWVAR 67
9866: ARRAY
9867: GREATEREQUAL
9868: IFFALSE 9883
// AddMedal ( WoT-med-2 , - 1 ) else
9870: LD_STRING WoT-med-2
9872: PPUSH
9873: LD_INT 1
9875: NEG
9876: PPUSH
9877: CALL_OW 101
9881: GO 9893
// AddMedal ( WoT-med-2 , 1 ) ;
9883: LD_STRING WoT-med-2
9885: PPUSH
9886: LD_INT 1
9888: PPUSH
9889: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
9893: LD_EXP 7
9897: PUSH
9898: LD_INT 8
9900: PUSH
9901: LD_INT 6
9903: PUSH
9904: LD_INT 5
9906: PUSH
9907: EMPTY
9908: LIST
9909: LIST
9910: LIST
9911: PUSH
9912: LD_OWVAR 67
9916: ARRAY
9917: GREATEREQUAL
9918: IFFALSE 9933
// AddMedal ( WoT-med-3 , - 1 ) else
9920: LD_STRING WoT-med-3
9922: PPUSH
9923: LD_INT 1
9925: NEG
9926: PPUSH
9927: CALL_OW 101
9931: GO 9943
// AddMedal ( WoT-med-3 , 1 ) ;
9933: LD_STRING WoT-med-3
9935: PPUSH
9936: LD_INT 1
9938: PPUSH
9939: CALL_OW 101
// GiveMedals ( MAIN ) ;
9943: LD_STRING MAIN
9945: PPUSH
9946: CALL_OW 102
// YouWin ;
9950: CALL_OW 103
// end ; end_of_file
9954: END
// export function CustomEvent ( event ) ; begin
9955: LD_INT 0
9957: PPUSH
// end ;
9958: LD_VAR 0 2
9962: RET
// on Command ( com ) do var i , j , temp ;
9963: LD_INT 0
9965: PPUSH
9966: PPUSH
9967: PPUSH
// begin if com = 60 then
9968: LD_VAR 0 1
9972: PUSH
9973: LD_INT 60
9975: EQUAL
9976: IFFALSE 10155
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
9978: LD_ADDR_VAR 0 2
9982: PUSH
9983: LD_INT 22
9985: PUSH
9986: LD_INT 1
9988: PUSH
9989: EMPTY
9990: LIST
9991: LIST
9992: PUSH
9993: LD_INT 2
9995: PUSH
9996: LD_INT 21
9998: PUSH
9999: LD_INT 1
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PUSH
10006: LD_INT 34
10008: PUSH
10009: LD_INT 12
10011: PUSH
10012: EMPTY
10013: LIST
10014: LIST
10015: PUSH
10016: EMPTY
10017: LIST
10018: LIST
10019: LIST
10020: PUSH
10021: EMPTY
10022: LIST
10023: LIST
10024: PPUSH
10025: CALL_OW 69
10029: PUSH
10030: FOR_IN
10031: IFFALSE 10153
// begin if GetTaskList ( i ) > 0 then
10033: LD_VAR 0 2
10037: PPUSH
10038: CALL_OW 437
10042: PUSH
10043: LD_INT 0
10045: GREATER
10046: IFFALSE 10151
// for j = 1 to GetTaskList ( i ) do
10048: LD_ADDR_VAR 0 3
10052: PUSH
10053: DOUBLE
10054: LD_INT 1
10056: DEC
10057: ST_TO_ADDR
10058: LD_VAR 0 2
10062: PPUSH
10063: CALL_OW 437
10067: PUSH
10068: FOR_TO
10069: IFFALSE 10149
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10071: LD_ADDR_VAR 0 4
10075: PUSH
10076: LD_VAR 0 2
10080: PPUSH
10081: CALL_OW 437
10085: PUSH
10086: LD_VAR 0 3
10090: ARRAY
10091: PUSH
10092: LD_INT 4
10094: ARRAY
10095: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10096: LD_VAR 0 4
10100: PPUSH
10101: CALL_OW 255
10105: PUSH
10106: LD_INT 4
10108: EQUAL
10109: PUSH
10110: LD_VAR 0 2
10114: PPUSH
10115: CALL_OW 437
10119: PUSH
10120: LD_VAR 0 3
10124: ARRAY
10125: PUSH
10126: LD_INT 1
10128: ARRAY
10129: PUSH
10130: LD_STRING <
10132: EQUAL
10133: AND
10134: IFFALSE 10147
// SetTaskList ( i , [ ] ) ;
10136: LD_VAR 0 2
10140: PPUSH
10141: EMPTY
10142: PPUSH
10143: CALL_OW 446
// end ;
10147: GO 10068
10149: POP
10150: POP
// end ;
10151: GO 10030
10153: POP
10154: POP
// end ; end ;
10155: PPOPN 4
10157: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10158: LD_VAR 0 2
10162: PPUSH
10163: LD_VAR 0 3
10167: PPUSH
10168: CALL_OW 428
10172: PPUSH
10173: CALL_OW 255
10177: PUSH
10178: LD_INT 1
10180: EQUAL
10181: PUSH
10182: LD_VAR 0 2
10186: PUSH
10187: LD_INT 132
10189: EQUAL
10190: PUSH
10191: LD_VAR 0 3
10195: PUSH
10196: LD_INT 39
10198: EQUAL
10199: AND
10200: OR
10201: IFFALSE 10217
// DialogContaminateSib ( x , y ) ;
10203: LD_VAR 0 2
10207: PPUSH
10208: LD_VAR 0 3
10212: PPUSH
10213: CALL 9331 0 2
// end ;
10217: PPOPN 3
10219: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
10220: LD_VAR 0 1
10224: PPUSH
10225: CALL 77085 0 1
// if un = Powell then
10229: LD_VAR 0 1
10233: PUSH
10234: LD_EXP 10
10238: EQUAL
10239: IFFALSE 10248
// YouLost ( Powell ) ;
10241: LD_STRING Powell
10243: PPUSH
10244: CALL_OW 104
// if un = Sikorski then
10248: LD_VAR 0 1
10252: PUSH
10253: LD_EXP 20
10257: EQUAL
10258: IFFALSE 10267
// YouLost ( Sikorski ) ;
10260: LD_STRING Sikorski
10262: PPUSH
10263: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10267: LD_VAR 0 1
10271: PUSH
10272: LD_INT 22
10274: PUSH
10275: LD_INT 1
10277: PUSH
10278: EMPTY
10279: LIST
10280: LIST
10281: PUSH
10282: LD_INT 21
10284: PUSH
10285: LD_INT 1
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: EMPTY
10293: LIST
10294: LIST
10295: PPUSH
10296: CALL_OW 69
10300: IN
10301: IFFALSE 10317
// loseCounter := loseCounter + 1 ;
10303: LD_ADDR_EXP 6
10307: PUSH
10308: LD_EXP 6
10312: PUSH
10313: LD_INT 1
10315: PLUS
10316: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10317: LD_VAR 0 1
10321: PUSH
10322: LD_INT 22
10324: PUSH
10325: LD_INT 4
10327: PUSH
10328: EMPTY
10329: LIST
10330: LIST
10331: PUSH
10332: LD_INT 21
10334: PUSH
10335: LD_INT 1
10337: PUSH
10338: EMPTY
10339: LIST
10340: LIST
10341: PUSH
10342: EMPTY
10343: LIST
10344: LIST
10345: PPUSH
10346: CALL_OW 69
10350: IN
10351: IFFALSE 10367
// powellLoseCounter := powellLoseCounter + 1 ;
10353: LD_ADDR_EXP 7
10357: PUSH
10358: LD_EXP 7
10362: PUSH
10363: LD_INT 1
10365: PLUS
10366: ST_TO_ADDR
// if un in powellAttackGroup then
10367: LD_VAR 0 1
10371: PUSH
10372: LD_EXP 12
10376: IN
10377: IFFALSE 10395
// powellAttackGroup := powellAttackGroup diff un ;
10379: LD_ADDR_EXP 12
10383: PUSH
10384: LD_EXP 12
10388: PUSH
10389: LD_VAR 0 1
10393: DIFF
10394: ST_TO_ADDR
// if un in gensherAttackGroup then
10395: LD_VAR 0 1
10399: PUSH
10400: LD_EXP 15
10404: IN
10405: IFFALSE 10423
// gensherAttackGroup := gensherAttackGroup diff un ;
10407: LD_ADDR_EXP 15
10411: PUSH
10412: LD_EXP 15
10416: PUSH
10417: LD_VAR 0 1
10421: DIFF
10422: ST_TO_ADDR
// if un in popovAttackGroup then
10423: LD_VAR 0 1
10427: PUSH
10428: LD_EXP 19
10432: IN
10433: IFFALSE 10451
// popovAttackGroup := popovAttackGroup diff un ;
10435: LD_ADDR_EXP 19
10439: PUSH
10440: LD_EXP 19
10444: PUSH
10445: LD_VAR 0 1
10449: DIFF
10450: ST_TO_ADDR
// end ;
10451: PPOPN 1
10453: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10454: LD_VAR 0 1
10458: PPUSH
10459: LD_VAR 0 2
10463: PPUSH
10464: CALL 79419 0 2
// end ;
10468: PPOPN 2
10470: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10471: LD_VAR 0 1
10475: PPUSH
10476: CALL 78487 0 1
// end ;
10480: PPOPN 1
10482: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10483: LD_VAR 0 1
10487: PPUSH
10488: CALL 78728 0 1
// end ;
10492: PPOPN 1
10494: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10495: LD_VAR 0 1
10499: PPUSH
10500: LD_VAR 0 2
10504: PPUSH
10505: CALL 76781 0 2
// end ;
10509: PPOPN 2
10511: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10512: LD_VAR 0 1
10516: PPUSH
10517: LD_VAR 0 2
10521: PPUSH
10522: LD_VAR 0 3
10526: PPUSH
10527: LD_VAR 0 4
10531: PPUSH
10532: LD_VAR 0 5
10536: PPUSH
10537: CALL 76401 0 5
// end ;
10541: PPOPN 5
10543: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10544: LD_VAR 0 1
10548: PPUSH
10549: LD_VAR 0 2
10553: PPUSH
10554: CALL 75982 0 2
// end ;
10558: PPOPN 2
10560: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10561: LD_VAR 0 1
10565: PPUSH
10566: LD_VAR 0 2
10570: PPUSH
10571: LD_VAR 0 3
10575: PPUSH
10576: LD_VAR 0 4
10580: PPUSH
10581: CALL 75820 0 4
// end ;
10585: PPOPN 4
10587: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10588: LD_VAR 0 1
10592: PPUSH
10593: LD_VAR 0 2
10597: PPUSH
10598: LD_VAR 0 3
10602: PPUSH
10603: CALL 75595 0 3
// end ;
10607: PPOPN 3
10609: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10610: LD_VAR 0 1
10614: PPUSH
10615: LD_VAR 0 2
10619: PPUSH
10620: CALL 75480 0 2
// end ;
10624: PPOPN 2
10626: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10627: LD_VAR 0 1
10631: PPUSH
10632: LD_VAR 0 2
10636: PPUSH
10637: CALL 79714 0 2
// end ;
10641: PPOPN 2
10643: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10644: LD_VAR 0 1
10648: PPUSH
10649: LD_VAR 0 2
10653: PPUSH
10654: LD_VAR 0 3
10658: PPUSH
10659: LD_VAR 0 4
10663: PPUSH
10664: CALL 79930 0 4
// end ;
10668: PPOPN 4
10670: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10671: LD_VAR 0 1
10675: PPUSH
10676: LD_VAR 0 2
10680: PPUSH
10681: CALL 75289 0 2
// end ;
10685: PPOPN 2
10687: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10688: LD_VAR 0 1
10692: PUSH
10693: LD_INT 1
10695: EQUAL
10696: PUSH
10697: LD_VAR 0 2
10701: PUSH
10702: LD_INT 4
10704: EQUAL
10705: AND
10706: IFFALSE 10715
// YouLost ( FriendlyFire ) ;
10708: LD_STRING FriendlyFire
10710: PPUSH
10711: CALL_OW 104
// end ; end_of_file
10715: PPOPN 2
10717: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
10718: LD_INT 0
10720: PPUSH
10721: PPUSH
// if exist_mode then
10722: LD_VAR 0 2
10726: IFFALSE 10751
// unit := CreateCharacter ( prefix & ident ) else
10728: LD_ADDR_VAR 0 5
10732: PUSH
10733: LD_VAR 0 3
10737: PUSH
10738: LD_VAR 0 1
10742: STR
10743: PPUSH
10744: CALL_OW 34
10748: ST_TO_ADDR
10749: GO 10766
// unit := NewCharacter ( ident ) ;
10751: LD_ADDR_VAR 0 5
10755: PUSH
10756: LD_VAR 0 1
10760: PPUSH
10761: CALL_OW 25
10765: ST_TO_ADDR
// result := unit ;
10766: LD_ADDR_VAR 0 4
10770: PUSH
10771: LD_VAR 0 5
10775: ST_TO_ADDR
// end ;
10776: LD_VAR 0 4
10780: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
10781: LD_INT 0
10783: PPUSH
10784: PPUSH
// if not side or not nation then
10785: LD_VAR 0 1
10789: NOT
10790: PUSH
10791: LD_VAR 0 2
10795: NOT
10796: OR
10797: IFFALSE 10801
// exit ;
10799: GO 11569
// case nation of nation_american :
10801: LD_VAR 0 2
10805: PUSH
10806: LD_INT 1
10808: DOUBLE
10809: EQUAL
10810: IFTRUE 10814
10812: GO 11028
10814: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
10815: LD_ADDR_VAR 0 4
10819: PUSH
10820: LD_INT 35
10822: PUSH
10823: LD_INT 45
10825: PUSH
10826: LD_INT 46
10828: PUSH
10829: LD_INT 47
10831: PUSH
10832: LD_INT 82
10834: PUSH
10835: LD_INT 83
10837: PUSH
10838: LD_INT 84
10840: PUSH
10841: LD_INT 85
10843: PUSH
10844: LD_INT 86
10846: PUSH
10847: LD_INT 1
10849: PUSH
10850: LD_INT 2
10852: PUSH
10853: LD_INT 6
10855: PUSH
10856: LD_INT 15
10858: PUSH
10859: LD_INT 16
10861: PUSH
10862: LD_INT 7
10864: PUSH
10865: LD_INT 12
10867: PUSH
10868: LD_INT 13
10870: PUSH
10871: LD_INT 10
10873: PUSH
10874: LD_INT 14
10876: PUSH
10877: LD_INT 20
10879: PUSH
10880: LD_INT 21
10882: PUSH
10883: LD_INT 22
10885: PUSH
10886: LD_INT 25
10888: PUSH
10889: LD_INT 32
10891: PUSH
10892: LD_INT 27
10894: PUSH
10895: LD_INT 36
10897: PUSH
10898: LD_INT 69
10900: PUSH
10901: LD_INT 39
10903: PUSH
10904: LD_INT 34
10906: PUSH
10907: LD_INT 40
10909: PUSH
10910: LD_INT 48
10912: PUSH
10913: LD_INT 49
10915: PUSH
10916: LD_INT 50
10918: PUSH
10919: LD_INT 51
10921: PUSH
10922: LD_INT 52
10924: PUSH
10925: LD_INT 53
10927: PUSH
10928: LD_INT 54
10930: PUSH
10931: LD_INT 55
10933: PUSH
10934: LD_INT 56
10936: PUSH
10937: LD_INT 57
10939: PUSH
10940: LD_INT 58
10942: PUSH
10943: LD_INT 59
10945: PUSH
10946: LD_INT 60
10948: PUSH
10949: LD_INT 61
10951: PUSH
10952: LD_INT 62
10954: PUSH
10955: LD_INT 80
10957: PUSH
10958: LD_INT 82
10960: PUSH
10961: LD_INT 83
10963: PUSH
10964: LD_INT 84
10966: PUSH
10967: LD_INT 85
10969: PUSH
10970: LD_INT 86
10972: PUSH
10973: EMPTY
10974: LIST
10975: LIST
10976: LIST
10977: LIST
10978: LIST
10979: LIST
10980: LIST
10981: LIST
10982: LIST
10983: LIST
10984: LIST
10985: LIST
10986: LIST
10987: LIST
10988: LIST
10989: LIST
10990: LIST
10991: LIST
10992: LIST
10993: LIST
10994: LIST
10995: LIST
10996: LIST
10997: LIST
10998: LIST
10999: LIST
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: LIST
11005: LIST
11006: LIST
11007: LIST
11008: LIST
11009: LIST
11010: LIST
11011: LIST
11012: LIST
11013: LIST
11014: LIST
11015: LIST
11016: LIST
11017: LIST
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: LIST
11023: LIST
11024: LIST
11025: ST_TO_ADDR
11026: GO 11493
11028: LD_INT 2
11030: DOUBLE
11031: EQUAL
11032: IFTRUE 11036
11034: GO 11262
11036: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11037: LD_ADDR_VAR 0 4
11041: PUSH
11042: LD_INT 35
11044: PUSH
11045: LD_INT 45
11047: PUSH
11048: LD_INT 46
11050: PUSH
11051: LD_INT 47
11053: PUSH
11054: LD_INT 82
11056: PUSH
11057: LD_INT 83
11059: PUSH
11060: LD_INT 84
11062: PUSH
11063: LD_INT 85
11065: PUSH
11066: LD_INT 87
11068: PUSH
11069: LD_INT 70
11071: PUSH
11072: LD_INT 1
11074: PUSH
11075: LD_INT 11
11077: PUSH
11078: LD_INT 3
11080: PUSH
11081: LD_INT 4
11083: PUSH
11084: LD_INT 5
11086: PUSH
11087: LD_INT 6
11089: PUSH
11090: LD_INT 15
11092: PUSH
11093: LD_INT 18
11095: PUSH
11096: LD_INT 7
11098: PUSH
11099: LD_INT 17
11101: PUSH
11102: LD_INT 8
11104: PUSH
11105: LD_INT 20
11107: PUSH
11108: LD_INT 21
11110: PUSH
11111: LD_INT 22
11113: PUSH
11114: LD_INT 72
11116: PUSH
11117: LD_INT 26
11119: PUSH
11120: LD_INT 69
11122: PUSH
11123: LD_INT 39
11125: PUSH
11126: LD_INT 40
11128: PUSH
11129: LD_INT 41
11131: PUSH
11132: LD_INT 42
11134: PUSH
11135: LD_INT 43
11137: PUSH
11138: LD_INT 48
11140: PUSH
11141: LD_INT 49
11143: PUSH
11144: LD_INT 50
11146: PUSH
11147: LD_INT 51
11149: PUSH
11150: LD_INT 52
11152: PUSH
11153: LD_INT 53
11155: PUSH
11156: LD_INT 54
11158: PUSH
11159: LD_INT 55
11161: PUSH
11162: LD_INT 56
11164: PUSH
11165: LD_INT 60
11167: PUSH
11168: LD_INT 61
11170: PUSH
11171: LD_INT 62
11173: PUSH
11174: LD_INT 66
11176: PUSH
11177: LD_INT 67
11179: PUSH
11180: LD_INT 68
11182: PUSH
11183: LD_INT 81
11185: PUSH
11186: LD_INT 82
11188: PUSH
11189: LD_INT 83
11191: PUSH
11192: LD_INT 84
11194: PUSH
11195: LD_INT 85
11197: PUSH
11198: LD_INT 87
11200: PUSH
11201: LD_INT 88
11203: PUSH
11204: EMPTY
11205: LIST
11206: LIST
11207: LIST
11208: LIST
11209: LIST
11210: LIST
11211: LIST
11212: LIST
11213: LIST
11214: LIST
11215: LIST
11216: LIST
11217: LIST
11218: LIST
11219: LIST
11220: LIST
11221: LIST
11222: LIST
11223: LIST
11224: LIST
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: LIST
11251: LIST
11252: LIST
11253: LIST
11254: LIST
11255: LIST
11256: LIST
11257: LIST
11258: LIST
11259: ST_TO_ADDR
11260: GO 11493
11262: LD_INT 3
11264: DOUBLE
11265: EQUAL
11266: IFTRUE 11270
11268: GO 11492
11270: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11271: LD_ADDR_VAR 0 4
11275: PUSH
11276: LD_INT 46
11278: PUSH
11279: LD_INT 47
11281: PUSH
11282: LD_INT 1
11284: PUSH
11285: LD_INT 2
11287: PUSH
11288: LD_INT 82
11290: PUSH
11291: LD_INT 83
11293: PUSH
11294: LD_INT 84
11296: PUSH
11297: LD_INT 85
11299: PUSH
11300: LD_INT 86
11302: PUSH
11303: LD_INT 11
11305: PUSH
11306: LD_INT 9
11308: PUSH
11309: LD_INT 20
11311: PUSH
11312: LD_INT 19
11314: PUSH
11315: LD_INT 21
11317: PUSH
11318: LD_INT 24
11320: PUSH
11321: LD_INT 22
11323: PUSH
11324: LD_INT 25
11326: PUSH
11327: LD_INT 28
11329: PUSH
11330: LD_INT 29
11332: PUSH
11333: LD_INT 30
11335: PUSH
11336: LD_INT 31
11338: PUSH
11339: LD_INT 37
11341: PUSH
11342: LD_INT 38
11344: PUSH
11345: LD_INT 32
11347: PUSH
11348: LD_INT 27
11350: PUSH
11351: LD_INT 33
11353: PUSH
11354: LD_INT 69
11356: PUSH
11357: LD_INT 39
11359: PUSH
11360: LD_INT 34
11362: PUSH
11363: LD_INT 40
11365: PUSH
11366: LD_INT 71
11368: PUSH
11369: LD_INT 23
11371: PUSH
11372: LD_INT 44
11374: PUSH
11375: LD_INT 48
11377: PUSH
11378: LD_INT 49
11380: PUSH
11381: LD_INT 50
11383: PUSH
11384: LD_INT 51
11386: PUSH
11387: LD_INT 52
11389: PUSH
11390: LD_INT 53
11392: PUSH
11393: LD_INT 54
11395: PUSH
11396: LD_INT 55
11398: PUSH
11399: LD_INT 56
11401: PUSH
11402: LD_INT 57
11404: PUSH
11405: LD_INT 58
11407: PUSH
11408: LD_INT 59
11410: PUSH
11411: LD_INT 63
11413: PUSH
11414: LD_INT 64
11416: PUSH
11417: LD_INT 65
11419: PUSH
11420: LD_INT 82
11422: PUSH
11423: LD_INT 83
11425: PUSH
11426: LD_INT 84
11428: PUSH
11429: LD_INT 85
11431: PUSH
11432: LD_INT 86
11434: PUSH
11435: EMPTY
11436: LIST
11437: LIST
11438: LIST
11439: LIST
11440: LIST
11441: LIST
11442: LIST
11443: LIST
11444: LIST
11445: LIST
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: LIST
11456: LIST
11457: LIST
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: LIST
11463: LIST
11464: LIST
11465: LIST
11466: LIST
11467: LIST
11468: LIST
11469: LIST
11470: LIST
11471: LIST
11472: LIST
11473: LIST
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: LIST
11480: LIST
11481: LIST
11482: LIST
11483: LIST
11484: LIST
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: ST_TO_ADDR
11490: GO 11493
11492: POP
// if state > - 1 and state < 3 then
11493: LD_VAR 0 3
11497: PUSH
11498: LD_INT 1
11500: NEG
11501: GREATER
11502: PUSH
11503: LD_VAR 0 3
11507: PUSH
11508: LD_INT 3
11510: LESS
11511: AND
11512: IFFALSE 11569
// for i in result do
11514: LD_ADDR_VAR 0 5
11518: PUSH
11519: LD_VAR 0 4
11523: PUSH
11524: FOR_IN
11525: IFFALSE 11567
// if GetTech ( i , side ) <> state then
11527: LD_VAR 0 5
11531: PPUSH
11532: LD_VAR 0 1
11536: PPUSH
11537: CALL_OW 321
11541: PUSH
11542: LD_VAR 0 3
11546: NONEQUAL
11547: IFFALSE 11565
// result := result diff i ;
11549: LD_ADDR_VAR 0 4
11553: PUSH
11554: LD_VAR 0 4
11558: PUSH
11559: LD_VAR 0 5
11563: DIFF
11564: ST_TO_ADDR
11565: GO 11524
11567: POP
11568: POP
// end ;
11569: LD_VAR 0 4
11573: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11574: LD_INT 0
11576: PPUSH
11577: PPUSH
11578: PPUSH
// result := true ;
11579: LD_ADDR_VAR 0 3
11583: PUSH
11584: LD_INT 1
11586: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11587: LD_ADDR_VAR 0 5
11591: PUSH
11592: LD_VAR 0 2
11596: PPUSH
11597: CALL_OW 480
11601: ST_TO_ADDR
// if not tmp then
11602: LD_VAR 0 5
11606: NOT
11607: IFFALSE 11611
// exit ;
11609: GO 11660
// for i in tmp do
11611: LD_ADDR_VAR 0 4
11615: PUSH
11616: LD_VAR 0 5
11620: PUSH
11621: FOR_IN
11622: IFFALSE 11658
// if GetTech ( i , side ) <> state_researched then
11624: LD_VAR 0 4
11628: PPUSH
11629: LD_VAR 0 1
11633: PPUSH
11634: CALL_OW 321
11638: PUSH
11639: LD_INT 2
11641: NONEQUAL
11642: IFFALSE 11656
// begin result := false ;
11644: LD_ADDR_VAR 0 3
11648: PUSH
11649: LD_INT 0
11651: ST_TO_ADDR
// exit ;
11652: POP
11653: POP
11654: GO 11660
// end ;
11656: GO 11621
11658: POP
11659: POP
// end ;
11660: LD_VAR 0 3
11664: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11665: LD_INT 0
11667: PPUSH
11668: PPUSH
11669: PPUSH
11670: PPUSH
11671: PPUSH
11672: PPUSH
11673: PPUSH
11674: PPUSH
11675: PPUSH
11676: PPUSH
11677: PPUSH
11678: PPUSH
11679: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11680: LD_VAR 0 1
11684: NOT
11685: PUSH
11686: LD_VAR 0 1
11690: PPUSH
11691: CALL_OW 257
11695: PUSH
11696: LD_INT 9
11698: NONEQUAL
11699: OR
11700: IFFALSE 11704
// exit ;
11702: GO 12277
// side := GetSide ( unit ) ;
11704: LD_ADDR_VAR 0 9
11708: PUSH
11709: LD_VAR 0 1
11713: PPUSH
11714: CALL_OW 255
11718: ST_TO_ADDR
// tech_space := tech_spacanom ;
11719: LD_ADDR_VAR 0 12
11723: PUSH
11724: LD_INT 29
11726: ST_TO_ADDR
// tech_time := tech_taurad ;
11727: LD_ADDR_VAR 0 13
11731: PUSH
11732: LD_INT 28
11734: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
11735: LD_ADDR_VAR 0 11
11739: PUSH
11740: LD_VAR 0 1
11744: PPUSH
11745: CALL_OW 310
11749: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
11750: LD_VAR 0 11
11754: PPUSH
11755: CALL_OW 247
11759: PUSH
11760: LD_INT 2
11762: EQUAL
11763: IFFALSE 11767
// exit ;
11765: GO 12277
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11767: LD_ADDR_VAR 0 8
11771: PUSH
11772: LD_INT 81
11774: PUSH
11775: LD_VAR 0 9
11779: PUSH
11780: EMPTY
11781: LIST
11782: LIST
11783: PUSH
11784: LD_INT 3
11786: PUSH
11787: LD_INT 21
11789: PUSH
11790: LD_INT 3
11792: PUSH
11793: EMPTY
11794: LIST
11795: LIST
11796: PUSH
11797: EMPTY
11798: LIST
11799: LIST
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PPUSH
11805: CALL_OW 69
11809: ST_TO_ADDR
// if not tmp then
11810: LD_VAR 0 8
11814: NOT
11815: IFFALSE 11819
// exit ;
11817: GO 12277
// if in_unit then
11819: LD_VAR 0 11
11823: IFFALSE 11847
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
11825: LD_ADDR_VAR 0 10
11829: PUSH
11830: LD_VAR 0 8
11834: PPUSH
11835: LD_VAR 0 11
11839: PPUSH
11840: CALL_OW 74
11844: ST_TO_ADDR
11845: GO 11867
// enemy := NearestUnitToUnit ( tmp , unit ) ;
11847: LD_ADDR_VAR 0 10
11851: PUSH
11852: LD_VAR 0 8
11856: PPUSH
11857: LD_VAR 0 1
11861: PPUSH
11862: CALL_OW 74
11866: ST_TO_ADDR
// if not enemy then
11867: LD_VAR 0 10
11871: NOT
11872: IFFALSE 11876
// exit ;
11874: GO 12277
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
11876: LD_VAR 0 11
11880: PUSH
11881: LD_VAR 0 11
11885: PPUSH
11886: LD_VAR 0 10
11890: PPUSH
11891: CALL_OW 296
11895: PUSH
11896: LD_INT 13
11898: GREATER
11899: AND
11900: PUSH
11901: LD_VAR 0 1
11905: PPUSH
11906: LD_VAR 0 10
11910: PPUSH
11911: CALL_OW 296
11915: PUSH
11916: LD_INT 12
11918: GREATER
11919: OR
11920: IFFALSE 11924
// exit ;
11922: GO 12277
// missile := [ 1 ] ;
11924: LD_ADDR_VAR 0 14
11928: PUSH
11929: LD_INT 1
11931: PUSH
11932: EMPTY
11933: LIST
11934: ST_TO_ADDR
// if Researched ( side , tech_space ) then
11935: LD_VAR 0 9
11939: PPUSH
11940: LD_VAR 0 12
11944: PPUSH
11945: CALL_OW 325
11949: IFFALSE 11978
// missile := Insert ( missile , missile + 1 , 2 ) ;
11951: LD_ADDR_VAR 0 14
11955: PUSH
11956: LD_VAR 0 14
11960: PPUSH
11961: LD_VAR 0 14
11965: PUSH
11966: LD_INT 1
11968: PLUS
11969: PPUSH
11970: LD_INT 2
11972: PPUSH
11973: CALL_OW 2
11977: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
11978: LD_VAR 0 9
11982: PPUSH
11983: LD_VAR 0 13
11987: PPUSH
11988: CALL_OW 325
11992: PUSH
11993: LD_VAR 0 10
11997: PPUSH
11998: CALL_OW 255
12002: PPUSH
12003: LD_VAR 0 13
12007: PPUSH
12008: CALL_OW 325
12012: NOT
12013: AND
12014: IFFALSE 12043
// missile := Insert ( missile , missile + 1 , 3 ) ;
12016: LD_ADDR_VAR 0 14
12020: PUSH
12021: LD_VAR 0 14
12025: PPUSH
12026: LD_VAR 0 14
12030: PUSH
12031: LD_INT 1
12033: PLUS
12034: PPUSH
12035: LD_INT 3
12037: PPUSH
12038: CALL_OW 2
12042: ST_TO_ADDR
// if missile < 2 then
12043: LD_VAR 0 14
12047: PUSH
12048: LD_INT 2
12050: LESS
12051: IFFALSE 12055
// exit ;
12053: GO 12277
// x := GetX ( enemy ) ;
12055: LD_ADDR_VAR 0 4
12059: PUSH
12060: LD_VAR 0 10
12064: PPUSH
12065: CALL_OW 250
12069: ST_TO_ADDR
// y := GetY ( enemy ) ;
12070: LD_ADDR_VAR 0 5
12074: PUSH
12075: LD_VAR 0 10
12079: PPUSH
12080: CALL_OW 251
12084: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12085: LD_ADDR_VAR 0 6
12089: PUSH
12090: LD_VAR 0 4
12094: PUSH
12095: LD_INT 1
12097: NEG
12098: PPUSH
12099: LD_INT 1
12101: PPUSH
12102: CALL_OW 12
12106: PLUS
12107: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12108: LD_ADDR_VAR 0 7
12112: PUSH
12113: LD_VAR 0 5
12117: PUSH
12118: LD_INT 1
12120: NEG
12121: PPUSH
12122: LD_INT 1
12124: PPUSH
12125: CALL_OW 12
12129: PLUS
12130: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12131: LD_VAR 0 6
12135: PPUSH
12136: LD_VAR 0 7
12140: PPUSH
12141: CALL_OW 488
12145: NOT
12146: IFFALSE 12168
// begin _x := x ;
12148: LD_ADDR_VAR 0 6
12152: PUSH
12153: LD_VAR 0 4
12157: ST_TO_ADDR
// _y := y ;
12158: LD_ADDR_VAR 0 7
12162: PUSH
12163: LD_VAR 0 5
12167: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12168: LD_ADDR_VAR 0 3
12172: PUSH
12173: LD_INT 1
12175: PPUSH
12176: LD_VAR 0 14
12180: PPUSH
12181: CALL_OW 12
12185: ST_TO_ADDR
// case i of 1 :
12186: LD_VAR 0 3
12190: PUSH
12191: LD_INT 1
12193: DOUBLE
12194: EQUAL
12195: IFTRUE 12199
12197: GO 12216
12199: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12200: LD_VAR 0 1
12204: PPUSH
12205: LD_VAR 0 10
12209: PPUSH
12210: CALL_OW 115
12214: GO 12277
12216: LD_INT 2
12218: DOUBLE
12219: EQUAL
12220: IFTRUE 12224
12222: GO 12246
12224: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12225: LD_VAR 0 1
12229: PPUSH
12230: LD_VAR 0 6
12234: PPUSH
12235: LD_VAR 0 7
12239: PPUSH
12240: CALL_OW 153
12244: GO 12277
12246: LD_INT 3
12248: DOUBLE
12249: EQUAL
12250: IFTRUE 12254
12252: GO 12276
12254: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12255: LD_VAR 0 1
12259: PPUSH
12260: LD_VAR 0 6
12264: PPUSH
12265: LD_VAR 0 7
12269: PPUSH
12270: CALL_OW 154
12274: GO 12277
12276: POP
// end ;
12277: LD_VAR 0 2
12281: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12282: LD_INT 0
12284: PPUSH
12285: PPUSH
12286: PPUSH
12287: PPUSH
12288: PPUSH
12289: PPUSH
// if not unit or not building then
12290: LD_VAR 0 1
12294: NOT
12295: PUSH
12296: LD_VAR 0 2
12300: NOT
12301: OR
12302: IFFALSE 12306
// exit ;
12304: GO 12464
// x := GetX ( building ) ;
12306: LD_ADDR_VAR 0 5
12310: PUSH
12311: LD_VAR 0 2
12315: PPUSH
12316: CALL_OW 250
12320: ST_TO_ADDR
// y := GetY ( building ) ;
12321: LD_ADDR_VAR 0 6
12325: PUSH
12326: LD_VAR 0 2
12330: PPUSH
12331: CALL_OW 251
12335: ST_TO_ADDR
// for i = 0 to 5 do
12336: LD_ADDR_VAR 0 4
12340: PUSH
12341: DOUBLE
12342: LD_INT 0
12344: DEC
12345: ST_TO_ADDR
12346: LD_INT 5
12348: PUSH
12349: FOR_TO
12350: IFFALSE 12462
// begin _x := ShiftX ( x , i , 3 ) ;
12352: LD_ADDR_VAR 0 7
12356: PUSH
12357: LD_VAR 0 5
12361: PPUSH
12362: LD_VAR 0 4
12366: PPUSH
12367: LD_INT 3
12369: PPUSH
12370: CALL_OW 272
12374: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12375: LD_ADDR_VAR 0 8
12379: PUSH
12380: LD_VAR 0 6
12384: PPUSH
12385: LD_VAR 0 4
12389: PPUSH
12390: LD_INT 3
12392: PPUSH
12393: CALL_OW 273
12397: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12398: LD_VAR 0 7
12402: PPUSH
12403: LD_VAR 0 8
12407: PPUSH
12408: CALL_OW 488
12412: NOT
12413: IFFALSE 12417
// continue ;
12415: GO 12349
// if HexInfo ( _x , _y ) = 0 then
12417: LD_VAR 0 7
12421: PPUSH
12422: LD_VAR 0 8
12426: PPUSH
12427: CALL_OW 428
12431: PUSH
12432: LD_INT 0
12434: EQUAL
12435: IFFALSE 12460
// begin ComMoveXY ( unit , _x , _y ) ;
12437: LD_VAR 0 1
12441: PPUSH
12442: LD_VAR 0 7
12446: PPUSH
12447: LD_VAR 0 8
12451: PPUSH
12452: CALL_OW 111
// exit ;
12456: POP
12457: POP
12458: GO 12464
// end ; end ;
12460: GO 12349
12462: POP
12463: POP
// end ;
12464: LD_VAR 0 3
12468: RET
// export function ScanBase ( side , base_area ) ; begin
12469: LD_INT 0
12471: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12472: LD_ADDR_VAR 0 3
12476: PUSH
12477: LD_VAR 0 2
12481: PPUSH
12482: LD_INT 81
12484: PUSH
12485: LD_VAR 0 1
12489: PUSH
12490: EMPTY
12491: LIST
12492: LIST
12493: PPUSH
12494: CALL_OW 70
12498: ST_TO_ADDR
// end ;
12499: LD_VAR 0 3
12503: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12504: LD_INT 0
12506: PPUSH
12507: PPUSH
12508: PPUSH
12509: PPUSH
// result := false ;
12510: LD_ADDR_VAR 0 2
12514: PUSH
12515: LD_INT 0
12517: ST_TO_ADDR
// side := GetSide ( unit ) ;
12518: LD_ADDR_VAR 0 3
12522: PUSH
12523: LD_VAR 0 1
12527: PPUSH
12528: CALL_OW 255
12532: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12533: LD_ADDR_VAR 0 4
12537: PUSH
12538: LD_VAR 0 1
12542: PPUSH
12543: CALL_OW 248
12547: ST_TO_ADDR
// case nat of 1 :
12548: LD_VAR 0 4
12552: PUSH
12553: LD_INT 1
12555: DOUBLE
12556: EQUAL
12557: IFTRUE 12561
12559: GO 12572
12561: POP
// tech := tech_lassight ; 2 :
12562: LD_ADDR_VAR 0 5
12566: PUSH
12567: LD_INT 12
12569: ST_TO_ADDR
12570: GO 12611
12572: LD_INT 2
12574: DOUBLE
12575: EQUAL
12576: IFTRUE 12580
12578: GO 12591
12580: POP
// tech := tech_mortar ; 3 :
12581: LD_ADDR_VAR 0 5
12585: PUSH
12586: LD_INT 41
12588: ST_TO_ADDR
12589: GO 12611
12591: LD_INT 3
12593: DOUBLE
12594: EQUAL
12595: IFTRUE 12599
12597: GO 12610
12599: POP
// tech := tech_bazooka ; end ;
12600: LD_ADDR_VAR 0 5
12604: PUSH
12605: LD_INT 44
12607: ST_TO_ADDR
12608: GO 12611
12610: POP
// if Researched ( side , tech ) then
12611: LD_VAR 0 3
12615: PPUSH
12616: LD_VAR 0 5
12620: PPUSH
12621: CALL_OW 325
12625: IFFALSE 12652
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12627: LD_ADDR_VAR 0 2
12631: PUSH
12632: LD_INT 5
12634: PUSH
12635: LD_INT 8
12637: PUSH
12638: LD_INT 9
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: LIST
12645: PUSH
12646: LD_VAR 0 4
12650: ARRAY
12651: ST_TO_ADDR
// end ;
12652: LD_VAR 0 2
12656: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12657: LD_INT 0
12659: PPUSH
12660: PPUSH
12661: PPUSH
// if not mines then
12662: LD_VAR 0 2
12666: NOT
12667: IFFALSE 12671
// exit ;
12669: GO 12815
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12671: LD_ADDR_VAR 0 5
12675: PUSH
12676: LD_INT 81
12678: PUSH
12679: LD_VAR 0 1
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: PUSH
12688: LD_INT 3
12690: PUSH
12691: LD_INT 21
12693: PUSH
12694: LD_INT 3
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: PPUSH
12709: CALL_OW 69
12713: ST_TO_ADDR
// for i in mines do
12714: LD_ADDR_VAR 0 4
12718: PUSH
12719: LD_VAR 0 2
12723: PUSH
12724: FOR_IN
12725: IFFALSE 12813
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
12727: LD_VAR 0 4
12731: PUSH
12732: LD_INT 1
12734: ARRAY
12735: PPUSH
12736: LD_VAR 0 4
12740: PUSH
12741: LD_INT 2
12743: ARRAY
12744: PPUSH
12745: CALL_OW 458
12749: NOT
12750: IFFALSE 12754
// continue ;
12752: GO 12724
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
12754: LD_VAR 0 4
12758: PUSH
12759: LD_INT 1
12761: ARRAY
12762: PPUSH
12763: LD_VAR 0 4
12767: PUSH
12768: LD_INT 2
12770: ARRAY
12771: PPUSH
12772: CALL_OW 428
12776: PUSH
12777: LD_VAR 0 5
12781: IN
12782: IFFALSE 12811
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
12784: LD_VAR 0 4
12788: PUSH
12789: LD_INT 1
12791: ARRAY
12792: PPUSH
12793: LD_VAR 0 4
12797: PUSH
12798: LD_INT 2
12800: ARRAY
12801: PPUSH
12802: LD_VAR 0 1
12806: PPUSH
12807: CALL_OW 456
// end ;
12811: GO 12724
12813: POP
12814: POP
// end ;
12815: LD_VAR 0 3
12819: RET
// export function Count ( array ) ; var i ; begin
12820: LD_INT 0
12822: PPUSH
12823: PPUSH
// result := 0 ;
12824: LD_ADDR_VAR 0 2
12828: PUSH
12829: LD_INT 0
12831: ST_TO_ADDR
// for i in array do
12832: LD_ADDR_VAR 0 3
12836: PUSH
12837: LD_VAR 0 1
12841: PUSH
12842: FOR_IN
12843: IFFALSE 12867
// if i then
12845: LD_VAR 0 3
12849: IFFALSE 12865
// result := result + 1 ;
12851: LD_ADDR_VAR 0 2
12855: PUSH
12856: LD_VAR 0 2
12860: PUSH
12861: LD_INT 1
12863: PLUS
12864: ST_TO_ADDR
12865: GO 12842
12867: POP
12868: POP
// end ;
12869: LD_VAR 0 2
12873: RET
// export function IsEmpty ( building ) ; begin
12874: LD_INT 0
12876: PPUSH
// if not building then
12877: LD_VAR 0 1
12881: NOT
12882: IFFALSE 12886
// exit ;
12884: GO 12929
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
12886: LD_ADDR_VAR 0 2
12890: PUSH
12891: LD_VAR 0 1
12895: PUSH
12896: LD_INT 22
12898: PUSH
12899: LD_VAR 0 1
12903: PPUSH
12904: CALL_OW 255
12908: PUSH
12909: EMPTY
12910: LIST
12911: LIST
12912: PUSH
12913: LD_INT 58
12915: PUSH
12916: EMPTY
12917: LIST
12918: PUSH
12919: EMPTY
12920: LIST
12921: LIST
12922: PPUSH
12923: CALL_OW 69
12927: IN
12928: ST_TO_ADDR
// end ;
12929: LD_VAR 0 2
12933: RET
// export function IsNotFull ( building ) ; begin
12934: LD_INT 0
12936: PPUSH
// if not building then
12937: LD_VAR 0 1
12941: NOT
12942: IFFALSE 12946
// exit ;
12944: GO 12965
// result := UnitsInside ( building ) < 6 ;
12946: LD_ADDR_VAR 0 2
12950: PUSH
12951: LD_VAR 0 1
12955: PPUSH
12956: CALL_OW 313
12960: PUSH
12961: LD_INT 6
12963: LESS
12964: ST_TO_ADDR
// end ;
12965: LD_VAR 0 2
12969: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
12970: LD_INT 0
12972: PPUSH
12973: PPUSH
12974: PPUSH
12975: PPUSH
// tmp := [ ] ;
12976: LD_ADDR_VAR 0 3
12980: PUSH
12981: EMPTY
12982: ST_TO_ADDR
// list := [ ] ;
12983: LD_ADDR_VAR 0 5
12987: PUSH
12988: EMPTY
12989: ST_TO_ADDR
// for i = 16 to 25 do
12990: LD_ADDR_VAR 0 4
12994: PUSH
12995: DOUBLE
12996: LD_INT 16
12998: DEC
12999: ST_TO_ADDR
13000: LD_INT 25
13002: PUSH
13003: FOR_TO
13004: IFFALSE 13077
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13006: LD_ADDR_VAR 0 3
13010: PUSH
13011: LD_VAR 0 3
13015: PUSH
13016: LD_INT 22
13018: PUSH
13019: LD_VAR 0 1
13023: PPUSH
13024: CALL_OW 255
13028: PUSH
13029: EMPTY
13030: LIST
13031: LIST
13032: PUSH
13033: LD_INT 91
13035: PUSH
13036: LD_VAR 0 1
13040: PUSH
13041: LD_INT 6
13043: PUSH
13044: EMPTY
13045: LIST
13046: LIST
13047: LIST
13048: PUSH
13049: LD_INT 30
13051: PUSH
13052: LD_VAR 0 4
13056: PUSH
13057: EMPTY
13058: LIST
13059: LIST
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: LIST
13065: PUSH
13066: EMPTY
13067: LIST
13068: PPUSH
13069: CALL_OW 69
13073: ADD
13074: ST_TO_ADDR
13075: GO 13003
13077: POP
13078: POP
// for i = 1 to tmp do
13079: LD_ADDR_VAR 0 4
13083: PUSH
13084: DOUBLE
13085: LD_INT 1
13087: DEC
13088: ST_TO_ADDR
13089: LD_VAR 0 3
13093: PUSH
13094: FOR_TO
13095: IFFALSE 13183
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13097: LD_ADDR_VAR 0 5
13101: PUSH
13102: LD_VAR 0 5
13106: PUSH
13107: LD_VAR 0 3
13111: PUSH
13112: LD_VAR 0 4
13116: ARRAY
13117: PPUSH
13118: CALL_OW 266
13122: PUSH
13123: LD_VAR 0 3
13127: PUSH
13128: LD_VAR 0 4
13132: ARRAY
13133: PPUSH
13134: CALL_OW 250
13138: PUSH
13139: LD_VAR 0 3
13143: PUSH
13144: LD_VAR 0 4
13148: ARRAY
13149: PPUSH
13150: CALL_OW 251
13154: PUSH
13155: LD_VAR 0 3
13159: PUSH
13160: LD_VAR 0 4
13164: ARRAY
13165: PPUSH
13166: CALL_OW 254
13170: PUSH
13171: EMPTY
13172: LIST
13173: LIST
13174: LIST
13175: LIST
13176: PUSH
13177: EMPTY
13178: LIST
13179: ADD
13180: ST_TO_ADDR
13181: GO 13094
13183: POP
13184: POP
// result := list ;
13185: LD_ADDR_VAR 0 2
13189: PUSH
13190: LD_VAR 0 5
13194: ST_TO_ADDR
// end ;
13195: LD_VAR 0 2
13199: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13200: LD_INT 0
13202: PPUSH
13203: PPUSH
13204: PPUSH
13205: PPUSH
13206: PPUSH
13207: PPUSH
13208: PPUSH
// if not factory then
13209: LD_VAR 0 1
13213: NOT
13214: IFFALSE 13218
// exit ;
13216: GO 13811
// if control = control_apeman then
13218: LD_VAR 0 4
13222: PUSH
13223: LD_INT 5
13225: EQUAL
13226: IFFALSE 13335
// begin tmp := UnitsInside ( factory ) ;
13228: LD_ADDR_VAR 0 8
13232: PUSH
13233: LD_VAR 0 1
13237: PPUSH
13238: CALL_OW 313
13242: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13243: LD_VAR 0 8
13247: PPUSH
13248: LD_INT 25
13250: PUSH
13251: LD_INT 12
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: PPUSH
13258: CALL_OW 72
13262: NOT
13263: IFFALSE 13273
// control := control_manual ;
13265: LD_ADDR_VAR 0 4
13269: PUSH
13270: LD_INT 1
13272: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13273: LD_ADDR_VAR 0 8
13277: PUSH
13278: LD_VAR 0 1
13282: PPUSH
13283: CALL 12970 0 1
13287: ST_TO_ADDR
// if tmp then
13288: LD_VAR 0 8
13292: IFFALSE 13335
// begin for i in tmp do
13294: LD_ADDR_VAR 0 7
13298: PUSH
13299: LD_VAR 0 8
13303: PUSH
13304: FOR_IN
13305: IFFALSE 13333
// if i [ 1 ] = b_ext_radio then
13307: LD_VAR 0 7
13311: PUSH
13312: LD_INT 1
13314: ARRAY
13315: PUSH
13316: LD_INT 22
13318: EQUAL
13319: IFFALSE 13331
// begin control := control_remote ;
13321: LD_ADDR_VAR 0 4
13325: PUSH
13326: LD_INT 2
13328: ST_TO_ADDR
// break ;
13329: GO 13333
// end ;
13331: GO 13304
13333: POP
13334: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13335: LD_VAR 0 1
13339: PPUSH
13340: LD_VAR 0 2
13344: PPUSH
13345: LD_VAR 0 3
13349: PPUSH
13350: LD_VAR 0 4
13354: PPUSH
13355: LD_VAR 0 5
13359: PPUSH
13360: CALL_OW 448
13364: IFFALSE 13399
// begin result := [ chassis , engine , control , weapon ] ;
13366: LD_ADDR_VAR 0 6
13370: PUSH
13371: LD_VAR 0 2
13375: PUSH
13376: LD_VAR 0 3
13380: PUSH
13381: LD_VAR 0 4
13385: PUSH
13386: LD_VAR 0 5
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: LIST
13395: LIST
13396: ST_TO_ADDR
// exit ;
13397: GO 13811
// end ; _chassis := AvailableChassisList ( factory ) ;
13399: LD_ADDR_VAR 0 9
13403: PUSH
13404: LD_VAR 0 1
13408: PPUSH
13409: CALL_OW 475
13413: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13414: LD_ADDR_VAR 0 11
13418: PUSH
13419: LD_VAR 0 1
13423: PPUSH
13424: CALL_OW 476
13428: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13429: LD_ADDR_VAR 0 12
13433: PUSH
13434: LD_VAR 0 1
13438: PPUSH
13439: CALL_OW 477
13443: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13444: LD_ADDR_VAR 0 10
13448: PUSH
13449: LD_VAR 0 1
13453: PPUSH
13454: CALL_OW 478
13458: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13459: LD_VAR 0 9
13463: NOT
13464: PUSH
13465: LD_VAR 0 11
13469: NOT
13470: OR
13471: PUSH
13472: LD_VAR 0 12
13476: NOT
13477: OR
13478: PUSH
13479: LD_VAR 0 10
13483: NOT
13484: OR
13485: IFFALSE 13520
// begin result := [ chassis , engine , control , weapon ] ;
13487: LD_ADDR_VAR 0 6
13491: PUSH
13492: LD_VAR 0 2
13496: PUSH
13497: LD_VAR 0 3
13501: PUSH
13502: LD_VAR 0 4
13506: PUSH
13507: LD_VAR 0 5
13511: PUSH
13512: EMPTY
13513: LIST
13514: LIST
13515: LIST
13516: LIST
13517: ST_TO_ADDR
// exit ;
13518: GO 13811
// end ; if not chassis in _chassis then
13520: LD_VAR 0 2
13524: PUSH
13525: LD_VAR 0 9
13529: IN
13530: NOT
13531: IFFALSE 13557
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13533: LD_ADDR_VAR 0 2
13537: PUSH
13538: LD_VAR 0 9
13542: PUSH
13543: LD_INT 1
13545: PPUSH
13546: LD_VAR 0 9
13550: PPUSH
13551: CALL_OW 12
13555: ARRAY
13556: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13557: LD_VAR 0 2
13561: PPUSH
13562: LD_VAR 0 3
13566: PPUSH
13567: CALL 13816 0 2
13571: NOT
13572: IFFALSE 13631
// repeat engine := _engine [ 1 ] ;
13574: LD_ADDR_VAR 0 3
13578: PUSH
13579: LD_VAR 0 11
13583: PUSH
13584: LD_INT 1
13586: ARRAY
13587: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13588: LD_ADDR_VAR 0 11
13592: PUSH
13593: LD_VAR 0 11
13597: PPUSH
13598: LD_INT 1
13600: PPUSH
13601: CALL_OW 3
13605: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13606: LD_VAR 0 2
13610: PPUSH
13611: LD_VAR 0 3
13615: PPUSH
13616: CALL 13816 0 2
13620: PUSH
13621: LD_VAR 0 11
13625: PUSH
13626: EMPTY
13627: EQUAL
13628: OR
13629: IFFALSE 13574
// if not control in _control then
13631: LD_VAR 0 4
13635: PUSH
13636: LD_VAR 0 12
13640: IN
13641: NOT
13642: IFFALSE 13668
// control := _control [ rand ( 1 , _control ) ] ;
13644: LD_ADDR_VAR 0 4
13648: PUSH
13649: LD_VAR 0 12
13653: PUSH
13654: LD_INT 1
13656: PPUSH
13657: LD_VAR 0 12
13661: PPUSH
13662: CALL_OW 12
13666: ARRAY
13667: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
13668: LD_VAR 0 2
13672: PPUSH
13673: LD_VAR 0 5
13677: PPUSH
13678: CALL 14036 0 2
13682: NOT
13683: IFFALSE 13742
// repeat weapon := _weapon [ 1 ] ;
13685: LD_ADDR_VAR 0 5
13689: PUSH
13690: LD_VAR 0 10
13694: PUSH
13695: LD_INT 1
13697: ARRAY
13698: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
13699: LD_ADDR_VAR 0 10
13703: PUSH
13704: LD_VAR 0 10
13708: PPUSH
13709: LD_INT 1
13711: PPUSH
13712: CALL_OW 3
13716: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
13717: LD_VAR 0 2
13721: PPUSH
13722: LD_VAR 0 5
13726: PPUSH
13727: CALL 14036 0 2
13731: PUSH
13732: LD_VAR 0 10
13736: PUSH
13737: EMPTY
13738: EQUAL
13739: OR
13740: IFFALSE 13685
// result := [ ] ;
13742: LD_ADDR_VAR 0 6
13746: PUSH
13747: EMPTY
13748: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13749: LD_VAR 0 1
13753: PPUSH
13754: LD_VAR 0 2
13758: PPUSH
13759: LD_VAR 0 3
13763: PPUSH
13764: LD_VAR 0 4
13768: PPUSH
13769: LD_VAR 0 5
13773: PPUSH
13774: CALL_OW 448
13778: IFFALSE 13811
// result := [ chassis , engine , control , weapon ] ;
13780: LD_ADDR_VAR 0 6
13784: PUSH
13785: LD_VAR 0 2
13789: PUSH
13790: LD_VAR 0 3
13794: PUSH
13795: LD_VAR 0 4
13799: PUSH
13800: LD_VAR 0 5
13804: PUSH
13805: EMPTY
13806: LIST
13807: LIST
13808: LIST
13809: LIST
13810: ST_TO_ADDR
// end ;
13811: LD_VAR 0 6
13815: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
13816: LD_INT 0
13818: PPUSH
// if not chassis or not engine then
13819: LD_VAR 0 1
13823: NOT
13824: PUSH
13825: LD_VAR 0 2
13829: NOT
13830: OR
13831: IFFALSE 13835
// exit ;
13833: GO 14031
// case engine of engine_solar :
13835: LD_VAR 0 2
13839: PUSH
13840: LD_INT 2
13842: DOUBLE
13843: EQUAL
13844: IFTRUE 13848
13846: GO 13886
13848: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
13849: LD_ADDR_VAR 0 3
13853: PUSH
13854: LD_INT 11
13856: PUSH
13857: LD_INT 12
13859: PUSH
13860: LD_INT 13
13862: PUSH
13863: LD_INT 14
13865: PUSH
13866: LD_INT 1
13868: PUSH
13869: LD_INT 2
13871: PUSH
13872: LD_INT 3
13874: PUSH
13875: EMPTY
13876: LIST
13877: LIST
13878: LIST
13879: LIST
13880: LIST
13881: LIST
13882: LIST
13883: ST_TO_ADDR
13884: GO 14015
13886: LD_INT 1
13888: DOUBLE
13889: EQUAL
13890: IFTRUE 13894
13892: GO 13956
13894: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
13895: LD_ADDR_VAR 0 3
13899: PUSH
13900: LD_INT 11
13902: PUSH
13903: LD_INT 12
13905: PUSH
13906: LD_INT 13
13908: PUSH
13909: LD_INT 14
13911: PUSH
13912: LD_INT 1
13914: PUSH
13915: LD_INT 2
13917: PUSH
13918: LD_INT 3
13920: PUSH
13921: LD_INT 4
13923: PUSH
13924: LD_INT 5
13926: PUSH
13927: LD_INT 21
13929: PUSH
13930: LD_INT 23
13932: PUSH
13933: LD_INT 22
13935: PUSH
13936: LD_INT 24
13938: PUSH
13939: EMPTY
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: ST_TO_ADDR
13954: GO 14015
13956: LD_INT 3
13958: DOUBLE
13959: EQUAL
13960: IFTRUE 13964
13962: GO 14014
13964: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13965: LD_ADDR_VAR 0 3
13969: PUSH
13970: LD_INT 13
13972: PUSH
13973: LD_INT 14
13975: PUSH
13976: LD_INT 2
13978: PUSH
13979: LD_INT 3
13981: PUSH
13982: LD_INT 4
13984: PUSH
13985: LD_INT 5
13987: PUSH
13988: LD_INT 21
13990: PUSH
13991: LD_INT 22
13993: PUSH
13994: LD_INT 23
13996: PUSH
13997: LD_INT 24
13999: PUSH
14000: EMPTY
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: LIST
14006: LIST
14007: LIST
14008: LIST
14009: LIST
14010: LIST
14011: ST_TO_ADDR
14012: GO 14015
14014: POP
// result := ( chassis in result ) ;
14015: LD_ADDR_VAR 0 3
14019: PUSH
14020: LD_VAR 0 1
14024: PUSH
14025: LD_VAR 0 3
14029: IN
14030: ST_TO_ADDR
// end ;
14031: LD_VAR 0 3
14035: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14036: LD_INT 0
14038: PPUSH
// if not chassis or not weapon then
14039: LD_VAR 0 1
14043: NOT
14044: PUSH
14045: LD_VAR 0 2
14049: NOT
14050: OR
14051: IFFALSE 14055
// exit ;
14053: GO 15117
// case weapon of us_machine_gun :
14055: LD_VAR 0 2
14059: PUSH
14060: LD_INT 2
14062: DOUBLE
14063: EQUAL
14064: IFTRUE 14068
14066: GO 14098
14068: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14069: LD_ADDR_VAR 0 3
14073: PUSH
14074: LD_INT 1
14076: PUSH
14077: LD_INT 2
14079: PUSH
14080: LD_INT 3
14082: PUSH
14083: LD_INT 4
14085: PUSH
14086: LD_INT 5
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: ST_TO_ADDR
14096: GO 15101
14098: LD_INT 3
14100: DOUBLE
14101: EQUAL
14102: IFTRUE 14106
14104: GO 14136
14106: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14107: LD_ADDR_VAR 0 3
14111: PUSH
14112: LD_INT 1
14114: PUSH
14115: LD_INT 2
14117: PUSH
14118: LD_INT 3
14120: PUSH
14121: LD_INT 4
14123: PUSH
14124: LD_INT 5
14126: PUSH
14127: EMPTY
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: ST_TO_ADDR
14134: GO 15101
14136: LD_INT 11
14138: DOUBLE
14139: EQUAL
14140: IFTRUE 14144
14142: GO 14174
14144: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14145: LD_ADDR_VAR 0 3
14149: PUSH
14150: LD_INT 1
14152: PUSH
14153: LD_INT 2
14155: PUSH
14156: LD_INT 3
14158: PUSH
14159: LD_INT 4
14161: PUSH
14162: LD_INT 5
14164: PUSH
14165: EMPTY
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: ST_TO_ADDR
14172: GO 15101
14174: LD_INT 4
14176: DOUBLE
14177: EQUAL
14178: IFTRUE 14182
14180: GO 14208
14182: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14183: LD_ADDR_VAR 0 3
14187: PUSH
14188: LD_INT 2
14190: PUSH
14191: LD_INT 3
14193: PUSH
14194: LD_INT 4
14196: PUSH
14197: LD_INT 5
14199: PUSH
14200: EMPTY
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: ST_TO_ADDR
14206: GO 15101
14208: LD_INT 5
14210: DOUBLE
14211: EQUAL
14212: IFTRUE 14216
14214: GO 14242
14216: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14217: LD_ADDR_VAR 0 3
14221: PUSH
14222: LD_INT 2
14224: PUSH
14225: LD_INT 3
14227: PUSH
14228: LD_INT 4
14230: PUSH
14231: LD_INT 5
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: ST_TO_ADDR
14240: GO 15101
14242: LD_INT 9
14244: DOUBLE
14245: EQUAL
14246: IFTRUE 14250
14248: GO 14276
14250: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14251: LD_ADDR_VAR 0 3
14255: PUSH
14256: LD_INT 2
14258: PUSH
14259: LD_INT 3
14261: PUSH
14262: LD_INT 4
14264: PUSH
14265: LD_INT 5
14267: PUSH
14268: EMPTY
14269: LIST
14270: LIST
14271: LIST
14272: LIST
14273: ST_TO_ADDR
14274: GO 15101
14276: LD_INT 7
14278: DOUBLE
14279: EQUAL
14280: IFTRUE 14284
14282: GO 14310
14284: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14285: LD_ADDR_VAR 0 3
14289: PUSH
14290: LD_INT 2
14292: PUSH
14293: LD_INT 3
14295: PUSH
14296: LD_INT 4
14298: PUSH
14299: LD_INT 5
14301: PUSH
14302: EMPTY
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: ST_TO_ADDR
14308: GO 15101
14310: LD_INT 12
14312: DOUBLE
14313: EQUAL
14314: IFTRUE 14318
14316: GO 14344
14318: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14319: LD_ADDR_VAR 0 3
14323: PUSH
14324: LD_INT 2
14326: PUSH
14327: LD_INT 3
14329: PUSH
14330: LD_INT 4
14332: PUSH
14333: LD_INT 5
14335: PUSH
14336: EMPTY
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: ST_TO_ADDR
14342: GO 15101
14344: LD_INT 13
14346: DOUBLE
14347: EQUAL
14348: IFTRUE 14352
14350: GO 14378
14352: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14353: LD_ADDR_VAR 0 3
14357: PUSH
14358: LD_INT 2
14360: PUSH
14361: LD_INT 3
14363: PUSH
14364: LD_INT 4
14366: PUSH
14367: LD_INT 5
14369: PUSH
14370: EMPTY
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: ST_TO_ADDR
14376: GO 15101
14378: LD_INT 14
14380: DOUBLE
14381: EQUAL
14382: IFTRUE 14386
14384: GO 14404
14386: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14387: LD_ADDR_VAR 0 3
14391: PUSH
14392: LD_INT 4
14394: PUSH
14395: LD_INT 5
14397: PUSH
14398: EMPTY
14399: LIST
14400: LIST
14401: ST_TO_ADDR
14402: GO 15101
14404: LD_INT 6
14406: DOUBLE
14407: EQUAL
14408: IFTRUE 14412
14410: GO 14430
14412: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14413: LD_ADDR_VAR 0 3
14417: PUSH
14418: LD_INT 4
14420: PUSH
14421: LD_INT 5
14423: PUSH
14424: EMPTY
14425: LIST
14426: LIST
14427: ST_TO_ADDR
14428: GO 15101
14430: LD_INT 10
14432: DOUBLE
14433: EQUAL
14434: IFTRUE 14438
14436: GO 14456
14438: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14439: LD_ADDR_VAR 0 3
14443: PUSH
14444: LD_INT 4
14446: PUSH
14447: LD_INT 5
14449: PUSH
14450: EMPTY
14451: LIST
14452: LIST
14453: ST_TO_ADDR
14454: GO 15101
14456: LD_INT 22
14458: DOUBLE
14459: EQUAL
14460: IFTRUE 14464
14462: GO 14490
14464: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14465: LD_ADDR_VAR 0 3
14469: PUSH
14470: LD_INT 11
14472: PUSH
14473: LD_INT 12
14475: PUSH
14476: LD_INT 13
14478: PUSH
14479: LD_INT 14
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: LIST
14486: LIST
14487: ST_TO_ADDR
14488: GO 15101
14490: LD_INT 23
14492: DOUBLE
14493: EQUAL
14494: IFTRUE 14498
14496: GO 14524
14498: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14499: LD_ADDR_VAR 0 3
14503: PUSH
14504: LD_INT 11
14506: PUSH
14507: LD_INT 12
14509: PUSH
14510: LD_INT 13
14512: PUSH
14513: LD_INT 14
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: ST_TO_ADDR
14522: GO 15101
14524: LD_INT 24
14526: DOUBLE
14527: EQUAL
14528: IFTRUE 14532
14530: GO 14558
14532: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14533: LD_ADDR_VAR 0 3
14537: PUSH
14538: LD_INT 11
14540: PUSH
14541: LD_INT 12
14543: PUSH
14544: LD_INT 13
14546: PUSH
14547: LD_INT 14
14549: PUSH
14550: EMPTY
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: ST_TO_ADDR
14556: GO 15101
14558: LD_INT 30
14560: DOUBLE
14561: EQUAL
14562: IFTRUE 14566
14564: GO 14592
14566: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14567: LD_ADDR_VAR 0 3
14571: PUSH
14572: LD_INT 11
14574: PUSH
14575: LD_INT 12
14577: PUSH
14578: LD_INT 13
14580: PUSH
14581: LD_INT 14
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: ST_TO_ADDR
14590: GO 15101
14592: LD_INT 25
14594: DOUBLE
14595: EQUAL
14596: IFTRUE 14600
14598: GO 14618
14600: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14601: LD_ADDR_VAR 0 3
14605: PUSH
14606: LD_INT 13
14608: PUSH
14609: LD_INT 14
14611: PUSH
14612: EMPTY
14613: LIST
14614: LIST
14615: ST_TO_ADDR
14616: GO 15101
14618: LD_INT 27
14620: DOUBLE
14621: EQUAL
14622: IFTRUE 14626
14624: GO 14644
14626: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
14627: LD_ADDR_VAR 0 3
14631: PUSH
14632: LD_INT 13
14634: PUSH
14635: LD_INT 14
14637: PUSH
14638: EMPTY
14639: LIST
14640: LIST
14641: ST_TO_ADDR
14642: GO 15101
14644: LD_EXP 72
14648: DOUBLE
14649: EQUAL
14650: IFTRUE 14654
14652: GO 14680
14654: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
14655: LD_ADDR_VAR 0 3
14659: PUSH
14660: LD_INT 11
14662: PUSH
14663: LD_INT 12
14665: PUSH
14666: LD_INT 13
14668: PUSH
14669: LD_INT 14
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: LIST
14676: LIST
14677: ST_TO_ADDR
14678: GO 15101
14680: LD_INT 28
14682: DOUBLE
14683: EQUAL
14684: IFTRUE 14688
14686: GO 14706
14688: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
14689: LD_ADDR_VAR 0 3
14693: PUSH
14694: LD_INT 13
14696: PUSH
14697: LD_INT 14
14699: PUSH
14700: EMPTY
14701: LIST
14702: LIST
14703: ST_TO_ADDR
14704: GO 15101
14706: LD_INT 29
14708: DOUBLE
14709: EQUAL
14710: IFTRUE 14714
14712: GO 14732
14714: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
14715: LD_ADDR_VAR 0 3
14719: PUSH
14720: LD_INT 13
14722: PUSH
14723: LD_INT 14
14725: PUSH
14726: EMPTY
14727: LIST
14728: LIST
14729: ST_TO_ADDR
14730: GO 15101
14732: LD_INT 31
14734: DOUBLE
14735: EQUAL
14736: IFTRUE 14740
14738: GO 14758
14740: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
14741: LD_ADDR_VAR 0 3
14745: PUSH
14746: LD_INT 13
14748: PUSH
14749: LD_INT 14
14751: PUSH
14752: EMPTY
14753: LIST
14754: LIST
14755: ST_TO_ADDR
14756: GO 15101
14758: LD_INT 26
14760: DOUBLE
14761: EQUAL
14762: IFTRUE 14766
14764: GO 14784
14766: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
14767: LD_ADDR_VAR 0 3
14771: PUSH
14772: LD_INT 13
14774: PUSH
14775: LD_INT 14
14777: PUSH
14778: EMPTY
14779: LIST
14780: LIST
14781: ST_TO_ADDR
14782: GO 15101
14784: LD_INT 42
14786: DOUBLE
14787: EQUAL
14788: IFTRUE 14792
14790: GO 14818
14792: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
14793: LD_ADDR_VAR 0 3
14797: PUSH
14798: LD_INT 21
14800: PUSH
14801: LD_INT 22
14803: PUSH
14804: LD_INT 23
14806: PUSH
14807: LD_INT 24
14809: PUSH
14810: EMPTY
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: ST_TO_ADDR
14816: GO 15101
14818: LD_INT 43
14820: DOUBLE
14821: EQUAL
14822: IFTRUE 14826
14824: GO 14852
14826: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
14827: LD_ADDR_VAR 0 3
14831: PUSH
14832: LD_INT 21
14834: PUSH
14835: LD_INT 22
14837: PUSH
14838: LD_INT 23
14840: PUSH
14841: LD_INT 24
14843: PUSH
14844: EMPTY
14845: LIST
14846: LIST
14847: LIST
14848: LIST
14849: ST_TO_ADDR
14850: GO 15101
14852: LD_INT 44
14854: DOUBLE
14855: EQUAL
14856: IFTRUE 14860
14858: GO 14886
14860: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
14861: LD_ADDR_VAR 0 3
14865: PUSH
14866: LD_INT 21
14868: PUSH
14869: LD_INT 22
14871: PUSH
14872: LD_INT 23
14874: PUSH
14875: LD_INT 24
14877: PUSH
14878: EMPTY
14879: LIST
14880: LIST
14881: LIST
14882: LIST
14883: ST_TO_ADDR
14884: GO 15101
14886: LD_INT 45
14888: DOUBLE
14889: EQUAL
14890: IFTRUE 14894
14892: GO 14920
14894: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
14895: LD_ADDR_VAR 0 3
14899: PUSH
14900: LD_INT 21
14902: PUSH
14903: LD_INT 22
14905: PUSH
14906: LD_INT 23
14908: PUSH
14909: LD_INT 24
14911: PUSH
14912: EMPTY
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: ST_TO_ADDR
14918: GO 15101
14920: LD_INT 49
14922: DOUBLE
14923: EQUAL
14924: IFTRUE 14928
14926: GO 14954
14928: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
14929: LD_ADDR_VAR 0 3
14933: PUSH
14934: LD_INT 21
14936: PUSH
14937: LD_INT 22
14939: PUSH
14940: LD_INT 23
14942: PUSH
14943: LD_INT 24
14945: PUSH
14946: EMPTY
14947: LIST
14948: LIST
14949: LIST
14950: LIST
14951: ST_TO_ADDR
14952: GO 15101
14954: LD_INT 51
14956: DOUBLE
14957: EQUAL
14958: IFTRUE 14962
14960: GO 14988
14962: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
14963: LD_ADDR_VAR 0 3
14967: PUSH
14968: LD_INT 21
14970: PUSH
14971: LD_INT 22
14973: PUSH
14974: LD_INT 23
14976: PUSH
14977: LD_INT 24
14979: PUSH
14980: EMPTY
14981: LIST
14982: LIST
14983: LIST
14984: LIST
14985: ST_TO_ADDR
14986: GO 15101
14988: LD_INT 52
14990: DOUBLE
14991: EQUAL
14992: IFTRUE 14996
14994: GO 15022
14996: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
14997: LD_ADDR_VAR 0 3
15001: PUSH
15002: LD_INT 21
15004: PUSH
15005: LD_INT 22
15007: PUSH
15008: LD_INT 23
15010: PUSH
15011: LD_INT 24
15013: PUSH
15014: EMPTY
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: ST_TO_ADDR
15020: GO 15101
15022: LD_INT 53
15024: DOUBLE
15025: EQUAL
15026: IFTRUE 15030
15028: GO 15048
15030: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15031: LD_ADDR_VAR 0 3
15035: PUSH
15036: LD_INT 23
15038: PUSH
15039: LD_INT 24
15041: PUSH
15042: EMPTY
15043: LIST
15044: LIST
15045: ST_TO_ADDR
15046: GO 15101
15048: LD_INT 46
15050: DOUBLE
15051: EQUAL
15052: IFTRUE 15056
15054: GO 15074
15056: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15057: LD_ADDR_VAR 0 3
15061: PUSH
15062: LD_INT 23
15064: PUSH
15065: LD_INT 24
15067: PUSH
15068: EMPTY
15069: LIST
15070: LIST
15071: ST_TO_ADDR
15072: GO 15101
15074: LD_INT 47
15076: DOUBLE
15077: EQUAL
15078: IFTRUE 15082
15080: GO 15100
15082: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15083: LD_ADDR_VAR 0 3
15087: PUSH
15088: LD_INT 23
15090: PUSH
15091: LD_INT 24
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: ST_TO_ADDR
15098: GO 15101
15100: POP
// result := ( chassis in result ) ;
15101: LD_ADDR_VAR 0 3
15105: PUSH
15106: LD_VAR 0 1
15110: PUSH
15111: LD_VAR 0 3
15115: IN
15116: ST_TO_ADDR
// end ;
15117: LD_VAR 0 3
15121: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15122: LD_INT 0
15124: PPUSH
15125: PPUSH
15126: PPUSH
15127: PPUSH
15128: PPUSH
15129: PPUSH
15130: PPUSH
// result := array ;
15131: LD_ADDR_VAR 0 5
15135: PUSH
15136: LD_VAR 0 1
15140: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15141: LD_VAR 0 1
15145: NOT
15146: PUSH
15147: LD_VAR 0 2
15151: NOT
15152: OR
15153: PUSH
15154: LD_VAR 0 3
15158: NOT
15159: OR
15160: PUSH
15161: LD_VAR 0 2
15165: PUSH
15166: LD_VAR 0 1
15170: GREATER
15171: OR
15172: PUSH
15173: LD_VAR 0 3
15177: PUSH
15178: LD_VAR 0 1
15182: GREATER
15183: OR
15184: IFFALSE 15188
// exit ;
15186: GO 15484
// if direction then
15188: LD_VAR 0 4
15192: IFFALSE 15256
// begin d := 1 ;
15194: LD_ADDR_VAR 0 9
15198: PUSH
15199: LD_INT 1
15201: ST_TO_ADDR
// if i_from > i_to then
15202: LD_VAR 0 2
15206: PUSH
15207: LD_VAR 0 3
15211: GREATER
15212: IFFALSE 15238
// length := ( array - i_from ) + i_to else
15214: LD_ADDR_VAR 0 11
15218: PUSH
15219: LD_VAR 0 1
15223: PUSH
15224: LD_VAR 0 2
15228: MINUS
15229: PUSH
15230: LD_VAR 0 3
15234: PLUS
15235: ST_TO_ADDR
15236: GO 15254
// length := i_to - i_from ;
15238: LD_ADDR_VAR 0 11
15242: PUSH
15243: LD_VAR 0 3
15247: PUSH
15248: LD_VAR 0 2
15252: MINUS
15253: ST_TO_ADDR
// end else
15254: GO 15317
// begin d := - 1 ;
15256: LD_ADDR_VAR 0 9
15260: PUSH
15261: LD_INT 1
15263: NEG
15264: ST_TO_ADDR
// if i_from > i_to then
15265: LD_VAR 0 2
15269: PUSH
15270: LD_VAR 0 3
15274: GREATER
15275: IFFALSE 15295
// length := i_from - i_to else
15277: LD_ADDR_VAR 0 11
15281: PUSH
15282: LD_VAR 0 2
15286: PUSH
15287: LD_VAR 0 3
15291: MINUS
15292: ST_TO_ADDR
15293: GO 15317
// length := ( array - i_to ) + i_from ;
15295: LD_ADDR_VAR 0 11
15299: PUSH
15300: LD_VAR 0 1
15304: PUSH
15305: LD_VAR 0 3
15309: MINUS
15310: PUSH
15311: LD_VAR 0 2
15315: PLUS
15316: ST_TO_ADDR
// end ; if not length then
15317: LD_VAR 0 11
15321: NOT
15322: IFFALSE 15326
// exit ;
15324: GO 15484
// tmp := array ;
15326: LD_ADDR_VAR 0 10
15330: PUSH
15331: LD_VAR 0 1
15335: ST_TO_ADDR
// for i = 1 to length do
15336: LD_ADDR_VAR 0 6
15340: PUSH
15341: DOUBLE
15342: LD_INT 1
15344: DEC
15345: ST_TO_ADDR
15346: LD_VAR 0 11
15350: PUSH
15351: FOR_TO
15352: IFFALSE 15472
// begin for j = 1 to array do
15354: LD_ADDR_VAR 0 7
15358: PUSH
15359: DOUBLE
15360: LD_INT 1
15362: DEC
15363: ST_TO_ADDR
15364: LD_VAR 0 1
15368: PUSH
15369: FOR_TO
15370: IFFALSE 15458
// begin k := j + d ;
15372: LD_ADDR_VAR 0 8
15376: PUSH
15377: LD_VAR 0 7
15381: PUSH
15382: LD_VAR 0 9
15386: PLUS
15387: ST_TO_ADDR
// if k > array then
15388: LD_VAR 0 8
15392: PUSH
15393: LD_VAR 0 1
15397: GREATER
15398: IFFALSE 15408
// k := 1 ;
15400: LD_ADDR_VAR 0 8
15404: PUSH
15405: LD_INT 1
15407: ST_TO_ADDR
// if not k then
15408: LD_VAR 0 8
15412: NOT
15413: IFFALSE 15425
// k := array ;
15415: LD_ADDR_VAR 0 8
15419: PUSH
15420: LD_VAR 0 1
15424: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15425: LD_ADDR_VAR 0 10
15429: PUSH
15430: LD_VAR 0 10
15434: PPUSH
15435: LD_VAR 0 8
15439: PPUSH
15440: LD_VAR 0 1
15444: PUSH
15445: LD_VAR 0 7
15449: ARRAY
15450: PPUSH
15451: CALL_OW 1
15455: ST_TO_ADDR
// end ;
15456: GO 15369
15458: POP
15459: POP
// array := tmp ;
15460: LD_ADDR_VAR 0 1
15464: PUSH
15465: LD_VAR 0 10
15469: ST_TO_ADDR
// end ;
15470: GO 15351
15472: POP
15473: POP
// result := array ;
15474: LD_ADDR_VAR 0 5
15478: PUSH
15479: LD_VAR 0 1
15483: ST_TO_ADDR
// end ;
15484: LD_VAR 0 5
15488: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15489: LD_INT 0
15491: PPUSH
15492: PPUSH
// result := 0 ;
15493: LD_ADDR_VAR 0 3
15497: PUSH
15498: LD_INT 0
15500: ST_TO_ADDR
// if not array or not value in array then
15501: LD_VAR 0 1
15505: NOT
15506: PUSH
15507: LD_VAR 0 2
15511: PUSH
15512: LD_VAR 0 1
15516: IN
15517: NOT
15518: OR
15519: IFFALSE 15523
// exit ;
15521: GO 15577
// for i = 1 to array do
15523: LD_ADDR_VAR 0 4
15527: PUSH
15528: DOUBLE
15529: LD_INT 1
15531: DEC
15532: ST_TO_ADDR
15533: LD_VAR 0 1
15537: PUSH
15538: FOR_TO
15539: IFFALSE 15575
// if value = array [ i ] then
15541: LD_VAR 0 2
15545: PUSH
15546: LD_VAR 0 1
15550: PUSH
15551: LD_VAR 0 4
15555: ARRAY
15556: EQUAL
15557: IFFALSE 15573
// begin result := i ;
15559: LD_ADDR_VAR 0 3
15563: PUSH
15564: LD_VAR 0 4
15568: ST_TO_ADDR
// exit ;
15569: POP
15570: POP
15571: GO 15577
// end ;
15573: GO 15538
15575: POP
15576: POP
// end ;
15577: LD_VAR 0 3
15581: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15582: LD_INT 0
15584: PPUSH
// vc_chassis := chassis ;
15585: LD_ADDR_OWVAR 37
15589: PUSH
15590: LD_VAR 0 1
15594: ST_TO_ADDR
// vc_engine := engine ;
15595: LD_ADDR_OWVAR 39
15599: PUSH
15600: LD_VAR 0 2
15604: ST_TO_ADDR
// vc_control := control ;
15605: LD_ADDR_OWVAR 38
15609: PUSH
15610: LD_VAR 0 3
15614: ST_TO_ADDR
// vc_weapon := weapon ;
15615: LD_ADDR_OWVAR 40
15619: PUSH
15620: LD_VAR 0 4
15624: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15625: LD_ADDR_OWVAR 41
15629: PUSH
15630: LD_VAR 0 5
15634: ST_TO_ADDR
// end ;
15635: LD_VAR 0 6
15639: RET
// export function WantPlant ( unit ) ; var task ; begin
15640: LD_INT 0
15642: PPUSH
15643: PPUSH
// result := false ;
15644: LD_ADDR_VAR 0 2
15648: PUSH
15649: LD_INT 0
15651: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
15652: LD_ADDR_VAR 0 3
15656: PUSH
15657: LD_VAR 0 1
15661: PPUSH
15662: CALL_OW 437
15666: ST_TO_ADDR
// if task then
15667: LD_VAR 0 3
15671: IFFALSE 15699
// if task [ 1 ] [ 1 ] = p then
15673: LD_VAR 0 3
15677: PUSH
15678: LD_INT 1
15680: ARRAY
15681: PUSH
15682: LD_INT 1
15684: ARRAY
15685: PUSH
15686: LD_STRING p
15688: EQUAL
15689: IFFALSE 15699
// result := true ;
15691: LD_ADDR_VAR 0 2
15695: PUSH
15696: LD_INT 1
15698: ST_TO_ADDR
// end ;
15699: LD_VAR 0 2
15703: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
15704: LD_INT 0
15706: PPUSH
15707: PPUSH
15708: PPUSH
15709: PPUSH
// if pos < 1 then
15710: LD_VAR 0 2
15714: PUSH
15715: LD_INT 1
15717: LESS
15718: IFFALSE 15722
// exit ;
15720: GO 16025
// if pos = 1 then
15722: LD_VAR 0 2
15726: PUSH
15727: LD_INT 1
15729: EQUAL
15730: IFFALSE 15763
// result := Replace ( arr , pos [ 1 ] , value ) else
15732: LD_ADDR_VAR 0 4
15736: PUSH
15737: LD_VAR 0 1
15741: PPUSH
15742: LD_VAR 0 2
15746: PUSH
15747: LD_INT 1
15749: ARRAY
15750: PPUSH
15751: LD_VAR 0 3
15755: PPUSH
15756: CALL_OW 1
15760: ST_TO_ADDR
15761: GO 16025
// begin tmp := arr ;
15763: LD_ADDR_VAR 0 6
15767: PUSH
15768: LD_VAR 0 1
15772: ST_TO_ADDR
// s_arr := [ tmp ] ;
15773: LD_ADDR_VAR 0 7
15777: PUSH
15778: LD_VAR 0 6
15782: PUSH
15783: EMPTY
15784: LIST
15785: ST_TO_ADDR
// for i = 1 to pos - 1 do
15786: LD_ADDR_VAR 0 5
15790: PUSH
15791: DOUBLE
15792: LD_INT 1
15794: DEC
15795: ST_TO_ADDR
15796: LD_VAR 0 2
15800: PUSH
15801: LD_INT 1
15803: MINUS
15804: PUSH
15805: FOR_TO
15806: IFFALSE 15851
// begin tmp := tmp [ pos [ i ] ] ;
15808: LD_ADDR_VAR 0 6
15812: PUSH
15813: LD_VAR 0 6
15817: PUSH
15818: LD_VAR 0 2
15822: PUSH
15823: LD_VAR 0 5
15827: ARRAY
15828: ARRAY
15829: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
15830: LD_ADDR_VAR 0 7
15834: PUSH
15835: LD_VAR 0 7
15839: PUSH
15840: LD_VAR 0 6
15844: PUSH
15845: EMPTY
15846: LIST
15847: ADD
15848: ST_TO_ADDR
// end ;
15849: GO 15805
15851: POP
15852: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
15853: LD_ADDR_VAR 0 6
15857: PUSH
15858: LD_VAR 0 6
15862: PPUSH
15863: LD_VAR 0 2
15867: PUSH
15868: LD_VAR 0 2
15872: ARRAY
15873: PPUSH
15874: LD_VAR 0 3
15878: PPUSH
15879: CALL_OW 1
15883: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
15884: LD_ADDR_VAR 0 7
15888: PUSH
15889: LD_VAR 0 7
15893: PPUSH
15894: LD_VAR 0 7
15898: PPUSH
15899: LD_VAR 0 6
15903: PPUSH
15904: CALL_OW 1
15908: ST_TO_ADDR
// for i = s_arr downto 2 do
15909: LD_ADDR_VAR 0 5
15913: PUSH
15914: DOUBLE
15915: LD_VAR 0 7
15919: INC
15920: ST_TO_ADDR
15921: LD_INT 2
15923: PUSH
15924: FOR_DOWNTO
15925: IFFALSE 16009
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
15927: LD_ADDR_VAR 0 6
15931: PUSH
15932: LD_VAR 0 7
15936: PUSH
15937: LD_VAR 0 5
15941: PUSH
15942: LD_INT 1
15944: MINUS
15945: ARRAY
15946: PPUSH
15947: LD_VAR 0 2
15951: PUSH
15952: LD_VAR 0 5
15956: PUSH
15957: LD_INT 1
15959: MINUS
15960: ARRAY
15961: PPUSH
15962: LD_VAR 0 7
15966: PUSH
15967: LD_VAR 0 5
15971: ARRAY
15972: PPUSH
15973: CALL_OW 1
15977: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
15978: LD_ADDR_VAR 0 7
15982: PUSH
15983: LD_VAR 0 7
15987: PPUSH
15988: LD_VAR 0 5
15992: PUSH
15993: LD_INT 1
15995: MINUS
15996: PPUSH
15997: LD_VAR 0 6
16001: PPUSH
16002: CALL_OW 1
16006: ST_TO_ADDR
// end ;
16007: GO 15924
16009: POP
16010: POP
// result := s_arr [ 1 ] ;
16011: LD_ADDR_VAR 0 4
16015: PUSH
16016: LD_VAR 0 7
16020: PUSH
16021: LD_INT 1
16023: ARRAY
16024: ST_TO_ADDR
// end ; end ;
16025: LD_VAR 0 4
16029: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16030: LD_INT 0
16032: PPUSH
16033: PPUSH
// if not list then
16034: LD_VAR 0 1
16038: NOT
16039: IFFALSE 16043
// exit ;
16041: GO 16134
// i := list [ pos1 ] ;
16043: LD_ADDR_VAR 0 5
16047: PUSH
16048: LD_VAR 0 1
16052: PUSH
16053: LD_VAR 0 2
16057: ARRAY
16058: ST_TO_ADDR
// if not i then
16059: LD_VAR 0 5
16063: NOT
16064: IFFALSE 16068
// exit ;
16066: GO 16134
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16068: LD_ADDR_VAR 0 1
16072: PUSH
16073: LD_VAR 0 1
16077: PPUSH
16078: LD_VAR 0 2
16082: PPUSH
16083: LD_VAR 0 1
16087: PUSH
16088: LD_VAR 0 3
16092: ARRAY
16093: PPUSH
16094: CALL_OW 1
16098: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16099: LD_ADDR_VAR 0 1
16103: PUSH
16104: LD_VAR 0 1
16108: PPUSH
16109: LD_VAR 0 3
16113: PPUSH
16114: LD_VAR 0 5
16118: PPUSH
16119: CALL_OW 1
16123: ST_TO_ADDR
// result := list ;
16124: LD_ADDR_VAR 0 4
16128: PUSH
16129: LD_VAR 0 1
16133: ST_TO_ADDR
// end ;
16134: LD_VAR 0 4
16138: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16139: LD_INT 0
16141: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16142: LD_ADDR_VAR 0 5
16146: PUSH
16147: LD_VAR 0 1
16151: PPUSH
16152: CALL_OW 250
16156: PPUSH
16157: LD_VAR 0 1
16161: PPUSH
16162: CALL_OW 251
16166: PPUSH
16167: LD_VAR 0 2
16171: PPUSH
16172: LD_VAR 0 3
16176: PPUSH
16177: LD_VAR 0 4
16181: PPUSH
16182: CALL 16192 0 5
16186: ST_TO_ADDR
// end ;
16187: LD_VAR 0 5
16191: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16192: LD_INT 0
16194: PPUSH
16195: PPUSH
16196: PPUSH
16197: PPUSH
// if not list then
16198: LD_VAR 0 3
16202: NOT
16203: IFFALSE 16207
// exit ;
16205: GO 16595
// result := [ ] ;
16207: LD_ADDR_VAR 0 6
16211: PUSH
16212: EMPTY
16213: ST_TO_ADDR
// for i in list do
16214: LD_ADDR_VAR 0 7
16218: PUSH
16219: LD_VAR 0 3
16223: PUSH
16224: FOR_IN
16225: IFFALSE 16427
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16227: LD_ADDR_VAR 0 9
16231: PUSH
16232: LD_VAR 0 7
16236: PPUSH
16237: LD_VAR 0 1
16241: PPUSH
16242: LD_VAR 0 2
16246: PPUSH
16247: CALL_OW 297
16251: ST_TO_ADDR
// if not result then
16252: LD_VAR 0 6
16256: NOT
16257: IFFALSE 16283
// result := [ [ i , tmp ] ] else
16259: LD_ADDR_VAR 0 6
16263: PUSH
16264: LD_VAR 0 7
16268: PUSH
16269: LD_VAR 0 9
16273: PUSH
16274: EMPTY
16275: LIST
16276: LIST
16277: PUSH
16278: EMPTY
16279: LIST
16280: ST_TO_ADDR
16281: GO 16425
// begin if result [ result ] [ 2 ] < tmp then
16283: LD_VAR 0 6
16287: PUSH
16288: LD_VAR 0 6
16292: ARRAY
16293: PUSH
16294: LD_INT 2
16296: ARRAY
16297: PUSH
16298: LD_VAR 0 9
16302: LESS
16303: IFFALSE 16345
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16305: LD_ADDR_VAR 0 6
16309: PUSH
16310: LD_VAR 0 6
16314: PPUSH
16315: LD_VAR 0 6
16319: PUSH
16320: LD_INT 1
16322: PLUS
16323: PPUSH
16324: LD_VAR 0 7
16328: PUSH
16329: LD_VAR 0 9
16333: PUSH
16334: EMPTY
16335: LIST
16336: LIST
16337: PPUSH
16338: CALL_OW 2
16342: ST_TO_ADDR
16343: GO 16425
// for j = 1 to result do
16345: LD_ADDR_VAR 0 8
16349: PUSH
16350: DOUBLE
16351: LD_INT 1
16353: DEC
16354: ST_TO_ADDR
16355: LD_VAR 0 6
16359: PUSH
16360: FOR_TO
16361: IFFALSE 16423
// begin if tmp < result [ j ] [ 2 ] then
16363: LD_VAR 0 9
16367: PUSH
16368: LD_VAR 0 6
16372: PUSH
16373: LD_VAR 0 8
16377: ARRAY
16378: PUSH
16379: LD_INT 2
16381: ARRAY
16382: LESS
16383: IFFALSE 16421
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16385: LD_ADDR_VAR 0 6
16389: PUSH
16390: LD_VAR 0 6
16394: PPUSH
16395: LD_VAR 0 8
16399: PPUSH
16400: LD_VAR 0 7
16404: PUSH
16405: LD_VAR 0 9
16409: PUSH
16410: EMPTY
16411: LIST
16412: LIST
16413: PPUSH
16414: CALL_OW 2
16418: ST_TO_ADDR
// break ;
16419: GO 16423
// end ; end ;
16421: GO 16360
16423: POP
16424: POP
// end ; end ;
16425: GO 16224
16427: POP
16428: POP
// if result and not asc then
16429: LD_VAR 0 6
16433: PUSH
16434: LD_VAR 0 4
16438: NOT
16439: AND
16440: IFFALSE 16515
// begin tmp := result ;
16442: LD_ADDR_VAR 0 9
16446: PUSH
16447: LD_VAR 0 6
16451: ST_TO_ADDR
// for i = tmp downto 1 do
16452: LD_ADDR_VAR 0 7
16456: PUSH
16457: DOUBLE
16458: LD_VAR 0 9
16462: INC
16463: ST_TO_ADDR
16464: LD_INT 1
16466: PUSH
16467: FOR_DOWNTO
16468: IFFALSE 16513
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16470: LD_ADDR_VAR 0 6
16474: PUSH
16475: LD_VAR 0 6
16479: PPUSH
16480: LD_VAR 0 9
16484: PUSH
16485: LD_VAR 0 7
16489: MINUS
16490: PUSH
16491: LD_INT 1
16493: PLUS
16494: PPUSH
16495: LD_VAR 0 9
16499: PUSH
16500: LD_VAR 0 7
16504: ARRAY
16505: PPUSH
16506: CALL_OW 1
16510: ST_TO_ADDR
16511: GO 16467
16513: POP
16514: POP
// end ; tmp := [ ] ;
16515: LD_ADDR_VAR 0 9
16519: PUSH
16520: EMPTY
16521: ST_TO_ADDR
// if mode then
16522: LD_VAR 0 5
16526: IFFALSE 16595
// begin for i = 1 to result do
16528: LD_ADDR_VAR 0 7
16532: PUSH
16533: DOUBLE
16534: LD_INT 1
16536: DEC
16537: ST_TO_ADDR
16538: LD_VAR 0 6
16542: PUSH
16543: FOR_TO
16544: IFFALSE 16583
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16546: LD_ADDR_VAR 0 9
16550: PUSH
16551: LD_VAR 0 9
16555: PPUSH
16556: LD_VAR 0 7
16560: PPUSH
16561: LD_VAR 0 6
16565: PUSH
16566: LD_VAR 0 7
16570: ARRAY
16571: PUSH
16572: LD_INT 1
16574: ARRAY
16575: PPUSH
16576: CALL_OW 1
16580: ST_TO_ADDR
16581: GO 16543
16583: POP
16584: POP
// result := tmp ;
16585: LD_ADDR_VAR 0 6
16589: PUSH
16590: LD_VAR 0 9
16594: ST_TO_ADDR
// end ; end ;
16595: LD_VAR 0 6
16599: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
16600: LD_INT 0
16602: PPUSH
16603: PPUSH
16604: PPUSH
16605: PPUSH
16606: PPUSH
16607: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
16608: LD_ADDR_VAR 0 5
16612: PUSH
16613: LD_INT 0
16615: PUSH
16616: LD_INT 0
16618: PUSH
16619: LD_INT 0
16621: PUSH
16622: EMPTY
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: LIST
16629: ST_TO_ADDR
// if not x or not y then
16630: LD_VAR 0 2
16634: NOT
16635: PUSH
16636: LD_VAR 0 3
16640: NOT
16641: OR
16642: IFFALSE 16646
// exit ;
16644: GO 18298
// if not range then
16646: LD_VAR 0 4
16650: NOT
16651: IFFALSE 16661
// range := 10 ;
16653: LD_ADDR_VAR 0 4
16657: PUSH
16658: LD_INT 10
16660: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16661: LD_ADDR_VAR 0 8
16665: PUSH
16666: LD_INT 81
16668: PUSH
16669: LD_VAR 0 1
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: PUSH
16678: LD_INT 92
16680: PUSH
16681: LD_VAR 0 2
16685: PUSH
16686: LD_VAR 0 3
16690: PUSH
16691: LD_VAR 0 4
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: LIST
16700: LIST
16701: PUSH
16702: LD_INT 3
16704: PUSH
16705: LD_INT 21
16707: PUSH
16708: LD_INT 3
16710: PUSH
16711: EMPTY
16712: LIST
16713: LIST
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: LIST
16723: PPUSH
16724: CALL_OW 69
16728: ST_TO_ADDR
// if not tmp then
16729: LD_VAR 0 8
16733: NOT
16734: IFFALSE 16738
// exit ;
16736: GO 18298
// for i in tmp do
16738: LD_ADDR_VAR 0 6
16742: PUSH
16743: LD_VAR 0 8
16747: PUSH
16748: FOR_IN
16749: IFFALSE 18273
// begin points := [ 0 , 0 , 0 ] ;
16751: LD_ADDR_VAR 0 9
16755: PUSH
16756: LD_INT 0
16758: PUSH
16759: LD_INT 0
16761: PUSH
16762: LD_INT 0
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: LIST
16769: ST_TO_ADDR
// bpoints := 1 ;
16770: LD_ADDR_VAR 0 10
16774: PUSH
16775: LD_INT 1
16777: ST_TO_ADDR
// case GetType ( i ) of unit_human :
16778: LD_VAR 0 6
16782: PPUSH
16783: CALL_OW 247
16787: PUSH
16788: LD_INT 1
16790: DOUBLE
16791: EQUAL
16792: IFTRUE 16796
16794: GO 17374
16796: POP
// begin if GetClass ( i ) = 1 then
16797: LD_VAR 0 6
16801: PPUSH
16802: CALL_OW 257
16806: PUSH
16807: LD_INT 1
16809: EQUAL
16810: IFFALSE 16831
// points := [ 10 , 5 , 3 ] ;
16812: LD_ADDR_VAR 0 9
16816: PUSH
16817: LD_INT 10
16819: PUSH
16820: LD_INT 5
16822: PUSH
16823: LD_INT 3
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: LIST
16830: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
16831: LD_VAR 0 6
16835: PPUSH
16836: CALL_OW 257
16840: PUSH
16841: LD_INT 2
16843: PUSH
16844: LD_INT 3
16846: PUSH
16847: LD_INT 4
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: LIST
16854: IN
16855: IFFALSE 16876
// points := [ 3 , 2 , 1 ] ;
16857: LD_ADDR_VAR 0 9
16861: PUSH
16862: LD_INT 3
16864: PUSH
16865: LD_INT 2
16867: PUSH
16868: LD_INT 1
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: LIST
16875: ST_TO_ADDR
// if GetClass ( i ) = 5 then
16876: LD_VAR 0 6
16880: PPUSH
16881: CALL_OW 257
16885: PUSH
16886: LD_INT 5
16888: EQUAL
16889: IFFALSE 16910
// points := [ 130 , 5 , 2 ] ;
16891: LD_ADDR_VAR 0 9
16895: PUSH
16896: LD_INT 130
16898: PUSH
16899: LD_INT 5
16901: PUSH
16902: LD_INT 2
16904: PUSH
16905: EMPTY
16906: LIST
16907: LIST
16908: LIST
16909: ST_TO_ADDR
// if GetClass ( i ) = 8 then
16910: LD_VAR 0 6
16914: PPUSH
16915: CALL_OW 257
16919: PUSH
16920: LD_INT 8
16922: EQUAL
16923: IFFALSE 16944
// points := [ 35 , 35 , 30 ] ;
16925: LD_ADDR_VAR 0 9
16929: PUSH
16930: LD_INT 35
16932: PUSH
16933: LD_INT 35
16935: PUSH
16936: LD_INT 30
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: LIST
16943: ST_TO_ADDR
// if GetClass ( i ) = 9 then
16944: LD_VAR 0 6
16948: PPUSH
16949: CALL_OW 257
16953: PUSH
16954: LD_INT 9
16956: EQUAL
16957: IFFALSE 16978
// points := [ 20 , 55 , 40 ] ;
16959: LD_ADDR_VAR 0 9
16963: PUSH
16964: LD_INT 20
16966: PUSH
16967: LD_INT 55
16969: PUSH
16970: LD_INT 40
16972: PUSH
16973: EMPTY
16974: LIST
16975: LIST
16976: LIST
16977: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
16978: LD_VAR 0 6
16982: PPUSH
16983: CALL_OW 257
16987: PUSH
16988: LD_INT 12
16990: PUSH
16991: LD_INT 16
16993: PUSH
16994: EMPTY
16995: LIST
16996: LIST
16997: IN
16998: IFFALSE 17019
// points := [ 5 , 3 , 2 ] ;
17000: LD_ADDR_VAR 0 9
17004: PUSH
17005: LD_INT 5
17007: PUSH
17008: LD_INT 3
17010: PUSH
17011: LD_INT 2
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: LIST
17018: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17019: LD_VAR 0 6
17023: PPUSH
17024: CALL_OW 257
17028: PUSH
17029: LD_INT 17
17031: EQUAL
17032: IFFALSE 17053
// points := [ 100 , 50 , 75 ] ;
17034: LD_ADDR_VAR 0 9
17038: PUSH
17039: LD_INT 100
17041: PUSH
17042: LD_INT 50
17044: PUSH
17045: LD_INT 75
17047: PUSH
17048: EMPTY
17049: LIST
17050: LIST
17051: LIST
17052: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17053: LD_VAR 0 6
17057: PPUSH
17058: CALL_OW 257
17062: PUSH
17063: LD_INT 15
17065: EQUAL
17066: IFFALSE 17087
// points := [ 10 , 5 , 3 ] ;
17068: LD_ADDR_VAR 0 9
17072: PUSH
17073: LD_INT 10
17075: PUSH
17076: LD_INT 5
17078: PUSH
17079: LD_INT 3
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: LIST
17086: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17087: LD_VAR 0 6
17091: PPUSH
17092: CALL_OW 257
17096: PUSH
17097: LD_INT 14
17099: EQUAL
17100: IFFALSE 17121
// points := [ 10 , 0 , 0 ] ;
17102: LD_ADDR_VAR 0 9
17106: PUSH
17107: LD_INT 10
17109: PUSH
17110: LD_INT 0
17112: PUSH
17113: LD_INT 0
17115: PUSH
17116: EMPTY
17117: LIST
17118: LIST
17119: LIST
17120: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17121: LD_VAR 0 6
17125: PPUSH
17126: CALL_OW 257
17130: PUSH
17131: LD_INT 11
17133: EQUAL
17134: IFFALSE 17155
// points := [ 30 , 10 , 5 ] ;
17136: LD_ADDR_VAR 0 9
17140: PUSH
17141: LD_INT 30
17143: PUSH
17144: LD_INT 10
17146: PUSH
17147: LD_INT 5
17149: PUSH
17150: EMPTY
17151: LIST
17152: LIST
17153: LIST
17154: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17155: LD_VAR 0 1
17159: PPUSH
17160: LD_INT 5
17162: PPUSH
17163: CALL_OW 321
17167: PUSH
17168: LD_INT 2
17170: EQUAL
17171: IFFALSE 17188
// bpoints := bpoints * 1.8 ;
17173: LD_ADDR_VAR 0 10
17177: PUSH
17178: LD_VAR 0 10
17182: PUSH
17183: LD_REAL  1.80000000000000E+0000
17186: MUL
17187: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17188: LD_VAR 0 6
17192: PPUSH
17193: CALL_OW 257
17197: PUSH
17198: LD_INT 1
17200: PUSH
17201: LD_INT 2
17203: PUSH
17204: LD_INT 3
17206: PUSH
17207: LD_INT 4
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: LIST
17214: LIST
17215: IN
17216: PUSH
17217: LD_VAR 0 1
17221: PPUSH
17222: LD_INT 51
17224: PPUSH
17225: CALL_OW 321
17229: PUSH
17230: LD_INT 2
17232: EQUAL
17233: AND
17234: IFFALSE 17251
// bpoints := bpoints * 1.2 ;
17236: LD_ADDR_VAR 0 10
17240: PUSH
17241: LD_VAR 0 10
17245: PUSH
17246: LD_REAL  1.20000000000000E+0000
17249: MUL
17250: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17251: LD_VAR 0 6
17255: PPUSH
17256: CALL_OW 257
17260: PUSH
17261: LD_INT 5
17263: PUSH
17264: LD_INT 7
17266: PUSH
17267: LD_INT 9
17269: PUSH
17270: EMPTY
17271: LIST
17272: LIST
17273: LIST
17274: IN
17275: PUSH
17276: LD_VAR 0 1
17280: PPUSH
17281: LD_INT 52
17283: PPUSH
17284: CALL_OW 321
17288: PUSH
17289: LD_INT 2
17291: EQUAL
17292: AND
17293: IFFALSE 17310
// bpoints := bpoints * 1.5 ;
17295: LD_ADDR_VAR 0 10
17299: PUSH
17300: LD_VAR 0 10
17304: PUSH
17305: LD_REAL  1.50000000000000E+0000
17308: MUL
17309: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17310: LD_VAR 0 1
17314: PPUSH
17315: LD_INT 66
17317: PPUSH
17318: CALL_OW 321
17322: PUSH
17323: LD_INT 2
17325: EQUAL
17326: IFFALSE 17343
// bpoints := bpoints * 1.1 ;
17328: LD_ADDR_VAR 0 10
17332: PUSH
17333: LD_VAR 0 10
17337: PUSH
17338: LD_REAL  1.10000000000000E+0000
17341: MUL
17342: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17343: LD_ADDR_VAR 0 10
17347: PUSH
17348: LD_VAR 0 10
17352: PUSH
17353: LD_VAR 0 6
17357: PPUSH
17358: LD_INT 1
17360: PPUSH
17361: CALL_OW 259
17365: PUSH
17366: LD_REAL  1.15000000000000E+0000
17369: MUL
17370: MUL
17371: ST_TO_ADDR
// end ; unit_vehicle :
17372: GO 18202
17374: LD_INT 2
17376: DOUBLE
17377: EQUAL
17378: IFTRUE 17382
17380: GO 18190
17382: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17383: LD_VAR 0 6
17387: PPUSH
17388: CALL_OW 264
17392: PUSH
17393: LD_INT 2
17395: PUSH
17396: LD_INT 42
17398: PUSH
17399: LD_INT 24
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: LIST
17406: IN
17407: IFFALSE 17428
// points := [ 25 , 5 , 3 ] ;
17409: LD_ADDR_VAR 0 9
17413: PUSH
17414: LD_INT 25
17416: PUSH
17417: LD_INT 5
17419: PUSH
17420: LD_INT 3
17422: PUSH
17423: EMPTY
17424: LIST
17425: LIST
17426: LIST
17427: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17428: LD_VAR 0 6
17432: PPUSH
17433: CALL_OW 264
17437: PUSH
17438: LD_INT 4
17440: PUSH
17441: LD_INT 43
17443: PUSH
17444: LD_INT 25
17446: PUSH
17447: EMPTY
17448: LIST
17449: LIST
17450: LIST
17451: IN
17452: IFFALSE 17473
// points := [ 40 , 15 , 5 ] ;
17454: LD_ADDR_VAR 0 9
17458: PUSH
17459: LD_INT 40
17461: PUSH
17462: LD_INT 15
17464: PUSH
17465: LD_INT 5
17467: PUSH
17468: EMPTY
17469: LIST
17470: LIST
17471: LIST
17472: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17473: LD_VAR 0 6
17477: PPUSH
17478: CALL_OW 264
17482: PUSH
17483: LD_INT 3
17485: PUSH
17486: LD_INT 23
17488: PUSH
17489: EMPTY
17490: LIST
17491: LIST
17492: IN
17493: IFFALSE 17514
// points := [ 7 , 25 , 8 ] ;
17495: LD_ADDR_VAR 0 9
17499: PUSH
17500: LD_INT 7
17502: PUSH
17503: LD_INT 25
17505: PUSH
17506: LD_INT 8
17508: PUSH
17509: EMPTY
17510: LIST
17511: LIST
17512: LIST
17513: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17514: LD_VAR 0 6
17518: PPUSH
17519: CALL_OW 264
17523: PUSH
17524: LD_INT 5
17526: PUSH
17527: LD_INT 27
17529: PUSH
17530: LD_INT 44
17532: PUSH
17533: EMPTY
17534: LIST
17535: LIST
17536: LIST
17537: IN
17538: IFFALSE 17559
// points := [ 14 , 50 , 16 ] ;
17540: LD_ADDR_VAR 0 9
17544: PUSH
17545: LD_INT 14
17547: PUSH
17548: LD_INT 50
17550: PUSH
17551: LD_INT 16
17553: PUSH
17554: EMPTY
17555: LIST
17556: LIST
17557: LIST
17558: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17559: LD_VAR 0 6
17563: PPUSH
17564: CALL_OW 264
17568: PUSH
17569: LD_INT 6
17571: PUSH
17572: LD_INT 46
17574: PUSH
17575: EMPTY
17576: LIST
17577: LIST
17578: IN
17579: IFFALSE 17600
// points := [ 32 , 120 , 70 ] ;
17581: LD_ADDR_VAR 0 9
17585: PUSH
17586: LD_INT 32
17588: PUSH
17589: LD_INT 120
17591: PUSH
17592: LD_INT 70
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: LIST
17599: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
17600: LD_VAR 0 6
17604: PPUSH
17605: CALL_OW 264
17609: PUSH
17610: LD_INT 7
17612: PUSH
17613: LD_INT 28
17615: PUSH
17616: LD_INT 45
17618: PUSH
17619: LD_EXP 72
17623: PUSH
17624: EMPTY
17625: LIST
17626: LIST
17627: LIST
17628: LIST
17629: IN
17630: IFFALSE 17651
// points := [ 35 , 20 , 45 ] ;
17632: LD_ADDR_VAR 0 9
17636: PUSH
17637: LD_INT 35
17639: PUSH
17640: LD_INT 20
17642: PUSH
17643: LD_INT 45
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: LIST
17650: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
17651: LD_VAR 0 6
17655: PPUSH
17656: CALL_OW 264
17660: PUSH
17661: LD_INT 47
17663: PUSH
17664: EMPTY
17665: LIST
17666: IN
17667: IFFALSE 17688
// points := [ 67 , 45 , 75 ] ;
17669: LD_ADDR_VAR 0 9
17673: PUSH
17674: LD_INT 67
17676: PUSH
17677: LD_INT 45
17679: PUSH
17680: LD_INT 75
17682: PUSH
17683: EMPTY
17684: LIST
17685: LIST
17686: LIST
17687: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
17688: LD_VAR 0 6
17692: PPUSH
17693: CALL_OW 264
17697: PUSH
17698: LD_INT 26
17700: PUSH
17701: EMPTY
17702: LIST
17703: IN
17704: IFFALSE 17725
// points := [ 120 , 30 , 80 ] ;
17706: LD_ADDR_VAR 0 9
17710: PUSH
17711: LD_INT 120
17713: PUSH
17714: LD_INT 30
17716: PUSH
17717: LD_INT 80
17719: PUSH
17720: EMPTY
17721: LIST
17722: LIST
17723: LIST
17724: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
17725: LD_VAR 0 6
17729: PPUSH
17730: CALL_OW 264
17734: PUSH
17735: LD_INT 22
17737: PUSH
17738: EMPTY
17739: LIST
17740: IN
17741: IFFALSE 17762
// points := [ 40 , 1 , 1 ] ;
17743: LD_ADDR_VAR 0 9
17747: PUSH
17748: LD_INT 40
17750: PUSH
17751: LD_INT 1
17753: PUSH
17754: LD_INT 1
17756: PUSH
17757: EMPTY
17758: LIST
17759: LIST
17760: LIST
17761: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
17762: LD_VAR 0 6
17766: PPUSH
17767: CALL_OW 264
17771: PUSH
17772: LD_INT 29
17774: PUSH
17775: EMPTY
17776: LIST
17777: IN
17778: IFFALSE 17799
// points := [ 70 , 200 , 400 ] ;
17780: LD_ADDR_VAR 0 9
17784: PUSH
17785: LD_INT 70
17787: PUSH
17788: LD_INT 200
17790: PUSH
17791: LD_INT 400
17793: PUSH
17794: EMPTY
17795: LIST
17796: LIST
17797: LIST
17798: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
17799: LD_VAR 0 6
17803: PPUSH
17804: CALL_OW 264
17808: PUSH
17809: LD_INT 14
17811: PUSH
17812: LD_INT 53
17814: PUSH
17815: EMPTY
17816: LIST
17817: LIST
17818: IN
17819: IFFALSE 17840
// points := [ 40 , 10 , 20 ] ;
17821: LD_ADDR_VAR 0 9
17825: PUSH
17826: LD_INT 40
17828: PUSH
17829: LD_INT 10
17831: PUSH
17832: LD_INT 20
17834: PUSH
17835: EMPTY
17836: LIST
17837: LIST
17838: LIST
17839: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
17840: LD_VAR 0 6
17844: PPUSH
17845: CALL_OW 264
17849: PUSH
17850: LD_INT 9
17852: PUSH
17853: EMPTY
17854: LIST
17855: IN
17856: IFFALSE 17877
// points := [ 5 , 70 , 20 ] ;
17858: LD_ADDR_VAR 0 9
17862: PUSH
17863: LD_INT 5
17865: PUSH
17866: LD_INT 70
17868: PUSH
17869: LD_INT 20
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: LIST
17876: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
17877: LD_VAR 0 6
17881: PPUSH
17882: CALL_OW 264
17886: PUSH
17887: LD_INT 10
17889: PUSH
17890: EMPTY
17891: LIST
17892: IN
17893: IFFALSE 17914
// points := [ 35 , 110 , 70 ] ;
17895: LD_ADDR_VAR 0 9
17899: PUSH
17900: LD_INT 35
17902: PUSH
17903: LD_INT 110
17905: PUSH
17906: LD_INT 70
17908: PUSH
17909: EMPTY
17910: LIST
17911: LIST
17912: LIST
17913: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
17914: LD_VAR 0 6
17918: PPUSH
17919: CALL_OW 265
17923: PUSH
17924: LD_INT 25
17926: EQUAL
17927: IFFALSE 17948
// points := [ 80 , 65 , 100 ] ;
17929: LD_ADDR_VAR 0 9
17933: PUSH
17934: LD_INT 80
17936: PUSH
17937: LD_INT 65
17939: PUSH
17940: LD_INT 100
17942: PUSH
17943: EMPTY
17944: LIST
17945: LIST
17946: LIST
17947: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
17948: LD_VAR 0 6
17952: PPUSH
17953: CALL_OW 263
17957: PUSH
17958: LD_INT 1
17960: EQUAL
17961: IFFALSE 17996
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
17963: LD_ADDR_VAR 0 10
17967: PUSH
17968: LD_VAR 0 10
17972: PUSH
17973: LD_VAR 0 6
17977: PPUSH
17978: CALL_OW 311
17982: PPUSH
17983: LD_INT 3
17985: PPUSH
17986: CALL_OW 259
17990: PUSH
17991: LD_INT 4
17993: MUL
17994: MUL
17995: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
17996: LD_VAR 0 6
18000: PPUSH
18001: CALL_OW 263
18005: PUSH
18006: LD_INT 2
18008: EQUAL
18009: IFFALSE 18060
// begin j := IsControledBy ( i ) ;
18011: LD_ADDR_VAR 0 7
18015: PUSH
18016: LD_VAR 0 6
18020: PPUSH
18021: CALL_OW 312
18025: ST_TO_ADDR
// if j then
18026: LD_VAR 0 7
18030: IFFALSE 18060
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18032: LD_ADDR_VAR 0 10
18036: PUSH
18037: LD_VAR 0 10
18041: PUSH
18042: LD_VAR 0 7
18046: PPUSH
18047: LD_INT 3
18049: PPUSH
18050: CALL_OW 259
18054: PUSH
18055: LD_INT 3
18057: MUL
18058: MUL
18059: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18060: LD_VAR 0 6
18064: PPUSH
18065: CALL_OW 264
18069: PUSH
18070: LD_INT 5
18072: PUSH
18073: LD_INT 6
18075: PUSH
18076: LD_INT 46
18078: PUSH
18079: LD_INT 44
18081: PUSH
18082: LD_INT 47
18084: PUSH
18085: LD_INT 45
18087: PUSH
18088: LD_INT 28
18090: PUSH
18091: LD_INT 7
18093: PUSH
18094: LD_INT 27
18096: PUSH
18097: LD_INT 29
18099: PUSH
18100: EMPTY
18101: LIST
18102: LIST
18103: LIST
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: IN
18112: PUSH
18113: LD_VAR 0 1
18117: PPUSH
18118: LD_INT 52
18120: PPUSH
18121: CALL_OW 321
18125: PUSH
18126: LD_INT 2
18128: EQUAL
18129: AND
18130: IFFALSE 18147
// bpoints := bpoints * 1.2 ;
18132: LD_ADDR_VAR 0 10
18136: PUSH
18137: LD_VAR 0 10
18141: PUSH
18142: LD_REAL  1.20000000000000E+0000
18145: MUL
18146: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18147: LD_VAR 0 6
18151: PPUSH
18152: CALL_OW 264
18156: PUSH
18157: LD_INT 6
18159: PUSH
18160: LD_INT 46
18162: PUSH
18163: LD_INT 47
18165: PUSH
18166: EMPTY
18167: LIST
18168: LIST
18169: LIST
18170: IN
18171: IFFALSE 18188
// bpoints := bpoints * 1.2 ;
18173: LD_ADDR_VAR 0 10
18177: PUSH
18178: LD_VAR 0 10
18182: PUSH
18183: LD_REAL  1.20000000000000E+0000
18186: MUL
18187: ST_TO_ADDR
// end ; unit_building :
18188: GO 18202
18190: LD_INT 3
18192: DOUBLE
18193: EQUAL
18194: IFTRUE 18198
18196: GO 18201
18198: POP
// ; end ;
18199: GO 18202
18201: POP
// for j = 1 to 3 do
18202: LD_ADDR_VAR 0 7
18206: PUSH
18207: DOUBLE
18208: LD_INT 1
18210: DEC
18211: ST_TO_ADDR
18212: LD_INT 3
18214: PUSH
18215: FOR_TO
18216: IFFALSE 18269
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18218: LD_ADDR_VAR 0 5
18222: PUSH
18223: LD_VAR 0 5
18227: PPUSH
18228: LD_VAR 0 7
18232: PPUSH
18233: LD_VAR 0 5
18237: PUSH
18238: LD_VAR 0 7
18242: ARRAY
18243: PUSH
18244: LD_VAR 0 9
18248: PUSH
18249: LD_VAR 0 7
18253: ARRAY
18254: PUSH
18255: LD_VAR 0 10
18259: MUL
18260: PLUS
18261: PPUSH
18262: CALL_OW 1
18266: ST_TO_ADDR
18267: GO 18215
18269: POP
18270: POP
// end ;
18271: GO 16748
18273: POP
18274: POP
// result := Replace ( result , 4 , tmp ) ;
18275: LD_ADDR_VAR 0 5
18279: PUSH
18280: LD_VAR 0 5
18284: PPUSH
18285: LD_INT 4
18287: PPUSH
18288: LD_VAR 0 8
18292: PPUSH
18293: CALL_OW 1
18297: ST_TO_ADDR
// end ;
18298: LD_VAR 0 5
18302: RET
// export function DangerAtRange ( unit , range ) ; begin
18303: LD_INT 0
18305: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18306: LD_ADDR_VAR 0 3
18310: PUSH
18311: LD_VAR 0 1
18315: PPUSH
18316: CALL_OW 255
18320: PPUSH
18321: LD_VAR 0 1
18325: PPUSH
18326: CALL_OW 250
18330: PPUSH
18331: LD_VAR 0 1
18335: PPUSH
18336: CALL_OW 251
18340: PPUSH
18341: LD_VAR 0 2
18345: PPUSH
18346: CALL 16600 0 4
18350: ST_TO_ADDR
// end ;
18351: LD_VAR 0 3
18355: RET
// export function DangerInArea ( side , area ) ; begin
18356: LD_INT 0
18358: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18359: LD_ADDR_VAR 0 3
18363: PUSH
18364: LD_VAR 0 2
18368: PPUSH
18369: LD_INT 81
18371: PUSH
18372: LD_VAR 0 1
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: PPUSH
18381: CALL_OW 70
18385: ST_TO_ADDR
// end ;
18386: LD_VAR 0 3
18390: RET
// export function IsExtension ( b ) ; begin
18391: LD_INT 0
18393: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18394: LD_ADDR_VAR 0 2
18398: PUSH
18399: LD_VAR 0 1
18403: PUSH
18404: LD_INT 23
18406: PUSH
18407: LD_INT 20
18409: PUSH
18410: LD_INT 22
18412: PUSH
18413: LD_INT 17
18415: PUSH
18416: LD_INT 24
18418: PUSH
18419: LD_INT 21
18421: PUSH
18422: LD_INT 19
18424: PUSH
18425: LD_INT 16
18427: PUSH
18428: LD_INT 25
18430: PUSH
18431: LD_INT 18
18433: PUSH
18434: EMPTY
18435: LIST
18436: LIST
18437: LIST
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: LIST
18443: LIST
18444: LIST
18445: IN
18446: ST_TO_ADDR
// end ;
18447: LD_VAR 0 2
18451: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18452: LD_INT 0
18454: PPUSH
18455: PPUSH
18456: PPUSH
// result := [ ] ;
18457: LD_ADDR_VAR 0 4
18461: PUSH
18462: EMPTY
18463: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18464: LD_ADDR_VAR 0 5
18468: PUSH
18469: LD_VAR 0 2
18473: PPUSH
18474: LD_INT 21
18476: PUSH
18477: LD_INT 3
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PPUSH
18484: CALL_OW 70
18488: ST_TO_ADDR
// if not tmp then
18489: LD_VAR 0 5
18493: NOT
18494: IFFALSE 18498
// exit ;
18496: GO 18562
// if checkLink then
18498: LD_VAR 0 3
18502: IFFALSE 18552
// begin for i in tmp do
18504: LD_ADDR_VAR 0 6
18508: PUSH
18509: LD_VAR 0 5
18513: PUSH
18514: FOR_IN
18515: IFFALSE 18550
// if GetBase ( i ) <> base then
18517: LD_VAR 0 6
18521: PPUSH
18522: CALL_OW 274
18526: PUSH
18527: LD_VAR 0 1
18531: NONEQUAL
18532: IFFALSE 18548
// ComLinkToBase ( base , i ) ;
18534: LD_VAR 0 1
18538: PPUSH
18539: LD_VAR 0 6
18543: PPUSH
18544: CALL_OW 169
18548: GO 18514
18550: POP
18551: POP
// end ; result := tmp ;
18552: LD_ADDR_VAR 0 4
18556: PUSH
18557: LD_VAR 0 5
18561: ST_TO_ADDR
// end ;
18562: LD_VAR 0 4
18566: RET
// export function ComComplete ( units , b ) ; var i ; begin
18567: LD_INT 0
18569: PPUSH
18570: PPUSH
// if not units then
18571: LD_VAR 0 1
18575: NOT
18576: IFFALSE 18580
// exit ;
18578: GO 18670
// for i in units do
18580: LD_ADDR_VAR 0 4
18584: PUSH
18585: LD_VAR 0 1
18589: PUSH
18590: FOR_IN
18591: IFFALSE 18668
// if BuildingStatus ( b ) = bs_build then
18593: LD_VAR 0 2
18597: PPUSH
18598: CALL_OW 461
18602: PUSH
18603: LD_INT 1
18605: EQUAL
18606: IFFALSE 18666
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
18608: LD_VAR 0 4
18612: PPUSH
18613: LD_STRING h
18615: PUSH
18616: LD_VAR 0 2
18620: PPUSH
18621: CALL_OW 250
18625: PUSH
18626: LD_VAR 0 2
18630: PPUSH
18631: CALL_OW 251
18635: PUSH
18636: LD_VAR 0 2
18640: PUSH
18641: LD_INT 0
18643: PUSH
18644: LD_INT 0
18646: PUSH
18647: LD_INT 0
18649: PUSH
18650: EMPTY
18651: LIST
18652: LIST
18653: LIST
18654: LIST
18655: LIST
18656: LIST
18657: LIST
18658: PUSH
18659: EMPTY
18660: LIST
18661: PPUSH
18662: CALL_OW 446
18666: GO 18590
18668: POP
18669: POP
// end ;
18670: LD_VAR 0 3
18674: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
18675: LD_INT 0
18677: PPUSH
18678: PPUSH
18679: PPUSH
18680: PPUSH
18681: PPUSH
18682: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
18683: LD_VAR 0 1
18687: NOT
18688: PUSH
18689: LD_VAR 0 1
18693: PPUSH
18694: CALL_OW 263
18698: PUSH
18699: LD_INT 2
18701: NONEQUAL
18702: OR
18703: IFFALSE 18707
// exit ;
18705: GO 19023
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
18707: LD_ADDR_VAR 0 6
18711: PUSH
18712: LD_INT 22
18714: PUSH
18715: LD_VAR 0 1
18719: PPUSH
18720: CALL_OW 255
18724: PUSH
18725: EMPTY
18726: LIST
18727: LIST
18728: PUSH
18729: LD_INT 2
18731: PUSH
18732: LD_INT 30
18734: PUSH
18735: LD_INT 36
18737: PUSH
18738: EMPTY
18739: LIST
18740: LIST
18741: PUSH
18742: LD_INT 34
18744: PUSH
18745: LD_INT 31
18747: PUSH
18748: EMPTY
18749: LIST
18750: LIST
18751: PUSH
18752: EMPTY
18753: LIST
18754: LIST
18755: LIST
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: PPUSH
18761: CALL_OW 69
18765: ST_TO_ADDR
// if not tmp then
18766: LD_VAR 0 6
18770: NOT
18771: IFFALSE 18775
// exit ;
18773: GO 19023
// result := [ ] ;
18775: LD_ADDR_VAR 0 2
18779: PUSH
18780: EMPTY
18781: ST_TO_ADDR
// for i in tmp do
18782: LD_ADDR_VAR 0 3
18786: PUSH
18787: LD_VAR 0 6
18791: PUSH
18792: FOR_IN
18793: IFFALSE 18864
// begin t := UnitsInside ( i ) ;
18795: LD_ADDR_VAR 0 4
18799: PUSH
18800: LD_VAR 0 3
18804: PPUSH
18805: CALL_OW 313
18809: ST_TO_ADDR
// if t then
18810: LD_VAR 0 4
18814: IFFALSE 18862
// for j in t do
18816: LD_ADDR_VAR 0 7
18820: PUSH
18821: LD_VAR 0 4
18825: PUSH
18826: FOR_IN
18827: IFFALSE 18860
// result := Replace ( result , result + 1 , j ) ;
18829: LD_ADDR_VAR 0 2
18833: PUSH
18834: LD_VAR 0 2
18838: PPUSH
18839: LD_VAR 0 2
18843: PUSH
18844: LD_INT 1
18846: PLUS
18847: PPUSH
18848: LD_VAR 0 7
18852: PPUSH
18853: CALL_OW 1
18857: ST_TO_ADDR
18858: GO 18826
18860: POP
18861: POP
// end ;
18862: GO 18792
18864: POP
18865: POP
// if not result then
18866: LD_VAR 0 2
18870: NOT
18871: IFFALSE 18875
// exit ;
18873: GO 19023
// mech := result [ 1 ] ;
18875: LD_ADDR_VAR 0 5
18879: PUSH
18880: LD_VAR 0 2
18884: PUSH
18885: LD_INT 1
18887: ARRAY
18888: ST_TO_ADDR
// if result > 1 then
18889: LD_VAR 0 2
18893: PUSH
18894: LD_INT 1
18896: GREATER
18897: IFFALSE 19009
// begin for i = 2 to result do
18899: LD_ADDR_VAR 0 3
18903: PUSH
18904: DOUBLE
18905: LD_INT 2
18907: DEC
18908: ST_TO_ADDR
18909: LD_VAR 0 2
18913: PUSH
18914: FOR_TO
18915: IFFALSE 19007
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
18917: LD_ADDR_VAR 0 4
18921: PUSH
18922: LD_VAR 0 2
18926: PUSH
18927: LD_VAR 0 3
18931: ARRAY
18932: PPUSH
18933: LD_INT 3
18935: PPUSH
18936: CALL_OW 259
18940: PUSH
18941: LD_VAR 0 2
18945: PUSH
18946: LD_VAR 0 3
18950: ARRAY
18951: PPUSH
18952: CALL_OW 432
18956: MINUS
18957: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
18958: LD_VAR 0 4
18962: PUSH
18963: LD_VAR 0 5
18967: PPUSH
18968: LD_INT 3
18970: PPUSH
18971: CALL_OW 259
18975: PUSH
18976: LD_VAR 0 5
18980: PPUSH
18981: CALL_OW 432
18985: MINUS
18986: GREATEREQUAL
18987: IFFALSE 19005
// mech := result [ i ] ;
18989: LD_ADDR_VAR 0 5
18993: PUSH
18994: LD_VAR 0 2
18998: PUSH
18999: LD_VAR 0 3
19003: ARRAY
19004: ST_TO_ADDR
// end ;
19005: GO 18914
19007: POP
19008: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19009: LD_VAR 0 1
19013: PPUSH
19014: LD_VAR 0 5
19018: PPUSH
19019: CALL_OW 135
// end ;
19023: LD_VAR 0 2
19027: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19028: LD_INT 0
19030: PPUSH
19031: PPUSH
19032: PPUSH
19033: PPUSH
19034: PPUSH
19035: PPUSH
19036: PPUSH
19037: PPUSH
19038: PPUSH
19039: PPUSH
19040: PPUSH
19041: PPUSH
19042: PPUSH
// result := [ ] ;
19043: LD_ADDR_VAR 0 7
19047: PUSH
19048: EMPTY
19049: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19050: LD_VAR 0 1
19054: PPUSH
19055: CALL_OW 266
19059: PUSH
19060: LD_INT 0
19062: PUSH
19063: LD_INT 1
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: IN
19070: NOT
19071: IFFALSE 19075
// exit ;
19073: GO 20709
// if name then
19075: LD_VAR 0 3
19079: IFFALSE 19095
// SetBName ( base_dep , name ) ;
19081: LD_VAR 0 1
19085: PPUSH
19086: LD_VAR 0 3
19090: PPUSH
19091: CALL_OW 500
// base := GetBase ( base_dep ) ;
19095: LD_ADDR_VAR 0 15
19099: PUSH
19100: LD_VAR 0 1
19104: PPUSH
19105: CALL_OW 274
19109: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19110: LD_ADDR_VAR 0 16
19114: PUSH
19115: LD_VAR 0 1
19119: PPUSH
19120: CALL_OW 255
19124: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19125: LD_ADDR_VAR 0 17
19129: PUSH
19130: LD_VAR 0 1
19134: PPUSH
19135: CALL_OW 248
19139: ST_TO_ADDR
// if sources then
19140: LD_VAR 0 5
19144: IFFALSE 19191
// for i = 1 to 3 do
19146: LD_ADDR_VAR 0 8
19150: PUSH
19151: DOUBLE
19152: LD_INT 1
19154: DEC
19155: ST_TO_ADDR
19156: LD_INT 3
19158: PUSH
19159: FOR_TO
19160: IFFALSE 19189
// AddResourceType ( base , i , sources [ i ] ) ;
19162: LD_VAR 0 15
19166: PPUSH
19167: LD_VAR 0 8
19171: PPUSH
19172: LD_VAR 0 5
19176: PUSH
19177: LD_VAR 0 8
19181: ARRAY
19182: PPUSH
19183: CALL_OW 276
19187: GO 19159
19189: POP
19190: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19191: LD_ADDR_VAR 0 18
19195: PUSH
19196: LD_VAR 0 15
19200: PPUSH
19201: LD_VAR 0 2
19205: PPUSH
19206: LD_INT 1
19208: PPUSH
19209: CALL 18452 0 3
19213: ST_TO_ADDR
// InitHc ;
19214: CALL_OW 19
// InitUc ;
19218: CALL_OW 18
// uc_side := side ;
19222: LD_ADDR_OWVAR 20
19226: PUSH
19227: LD_VAR 0 16
19231: ST_TO_ADDR
// uc_nation := nation ;
19232: LD_ADDR_OWVAR 21
19236: PUSH
19237: LD_VAR 0 17
19241: ST_TO_ADDR
// if buildings then
19242: LD_VAR 0 18
19246: IFFALSE 20568
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19248: LD_ADDR_VAR 0 19
19252: PUSH
19253: LD_VAR 0 18
19257: PPUSH
19258: LD_INT 2
19260: PUSH
19261: LD_INT 30
19263: PUSH
19264: LD_INT 29
19266: PUSH
19267: EMPTY
19268: LIST
19269: LIST
19270: PUSH
19271: LD_INT 30
19273: PUSH
19274: LD_INT 30
19276: PUSH
19277: EMPTY
19278: LIST
19279: LIST
19280: PUSH
19281: EMPTY
19282: LIST
19283: LIST
19284: LIST
19285: PPUSH
19286: CALL_OW 72
19290: ST_TO_ADDR
// if tmp then
19291: LD_VAR 0 19
19295: IFFALSE 19343
// for i in tmp do
19297: LD_ADDR_VAR 0 8
19301: PUSH
19302: LD_VAR 0 19
19306: PUSH
19307: FOR_IN
19308: IFFALSE 19341
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19310: LD_VAR 0 8
19314: PPUSH
19315: CALL_OW 250
19319: PPUSH
19320: LD_VAR 0 8
19324: PPUSH
19325: CALL_OW 251
19329: PPUSH
19330: LD_VAR 0 16
19334: PPUSH
19335: CALL_OW 441
19339: GO 19307
19341: POP
19342: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19343: LD_VAR 0 18
19347: PPUSH
19348: LD_INT 2
19350: PUSH
19351: LD_INT 30
19353: PUSH
19354: LD_INT 32
19356: PUSH
19357: EMPTY
19358: LIST
19359: LIST
19360: PUSH
19361: LD_INT 30
19363: PUSH
19364: LD_INT 33
19366: PUSH
19367: EMPTY
19368: LIST
19369: LIST
19370: PUSH
19371: EMPTY
19372: LIST
19373: LIST
19374: LIST
19375: PPUSH
19376: CALL_OW 72
19380: IFFALSE 19468
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19382: LD_ADDR_VAR 0 8
19386: PUSH
19387: LD_VAR 0 18
19391: PPUSH
19392: LD_INT 2
19394: PUSH
19395: LD_INT 30
19397: PUSH
19398: LD_INT 32
19400: PUSH
19401: EMPTY
19402: LIST
19403: LIST
19404: PUSH
19405: LD_INT 30
19407: PUSH
19408: LD_INT 33
19410: PUSH
19411: EMPTY
19412: LIST
19413: LIST
19414: PUSH
19415: EMPTY
19416: LIST
19417: LIST
19418: LIST
19419: PPUSH
19420: CALL_OW 72
19424: PUSH
19425: FOR_IN
19426: IFFALSE 19466
// begin if not GetBWeapon ( i ) then
19428: LD_VAR 0 8
19432: PPUSH
19433: CALL_OW 269
19437: NOT
19438: IFFALSE 19464
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19440: LD_VAR 0 8
19444: PPUSH
19445: LD_VAR 0 8
19449: PPUSH
19450: LD_VAR 0 2
19454: PPUSH
19455: CALL 20714 0 2
19459: PPUSH
19460: CALL_OW 431
// end ;
19464: GO 19425
19466: POP
19467: POP
// end ; for i = 1 to personel do
19468: LD_ADDR_VAR 0 8
19472: PUSH
19473: DOUBLE
19474: LD_INT 1
19476: DEC
19477: ST_TO_ADDR
19478: LD_VAR 0 6
19482: PUSH
19483: FOR_TO
19484: IFFALSE 20548
// begin if i > 4 then
19486: LD_VAR 0 8
19490: PUSH
19491: LD_INT 4
19493: GREATER
19494: IFFALSE 19498
// break ;
19496: GO 20548
// case i of 1 :
19498: LD_VAR 0 8
19502: PUSH
19503: LD_INT 1
19505: DOUBLE
19506: EQUAL
19507: IFTRUE 19511
19509: GO 19591
19511: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19512: LD_ADDR_VAR 0 12
19516: PUSH
19517: LD_VAR 0 18
19521: PPUSH
19522: LD_INT 22
19524: PUSH
19525: LD_VAR 0 16
19529: PUSH
19530: EMPTY
19531: LIST
19532: LIST
19533: PUSH
19534: LD_INT 58
19536: PUSH
19537: EMPTY
19538: LIST
19539: PUSH
19540: LD_INT 2
19542: PUSH
19543: LD_INT 30
19545: PUSH
19546: LD_INT 32
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: PUSH
19553: LD_INT 30
19555: PUSH
19556: LD_INT 4
19558: PUSH
19559: EMPTY
19560: LIST
19561: LIST
19562: PUSH
19563: LD_INT 30
19565: PUSH
19566: LD_INT 5
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: PUSH
19573: EMPTY
19574: LIST
19575: LIST
19576: LIST
19577: LIST
19578: PUSH
19579: EMPTY
19580: LIST
19581: LIST
19582: LIST
19583: PPUSH
19584: CALL_OW 72
19588: ST_TO_ADDR
19589: GO 19813
19591: LD_INT 2
19593: DOUBLE
19594: EQUAL
19595: IFTRUE 19599
19597: GO 19661
19599: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
19600: LD_ADDR_VAR 0 12
19604: PUSH
19605: LD_VAR 0 18
19609: PPUSH
19610: LD_INT 22
19612: PUSH
19613: LD_VAR 0 16
19617: PUSH
19618: EMPTY
19619: LIST
19620: LIST
19621: PUSH
19622: LD_INT 2
19624: PUSH
19625: LD_INT 30
19627: PUSH
19628: LD_INT 0
19630: PUSH
19631: EMPTY
19632: LIST
19633: LIST
19634: PUSH
19635: LD_INT 30
19637: PUSH
19638: LD_INT 1
19640: PUSH
19641: EMPTY
19642: LIST
19643: LIST
19644: PUSH
19645: EMPTY
19646: LIST
19647: LIST
19648: LIST
19649: PUSH
19650: EMPTY
19651: LIST
19652: LIST
19653: PPUSH
19654: CALL_OW 72
19658: ST_TO_ADDR
19659: GO 19813
19661: LD_INT 3
19663: DOUBLE
19664: EQUAL
19665: IFTRUE 19669
19667: GO 19731
19669: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
19670: LD_ADDR_VAR 0 12
19674: PUSH
19675: LD_VAR 0 18
19679: PPUSH
19680: LD_INT 22
19682: PUSH
19683: LD_VAR 0 16
19687: PUSH
19688: EMPTY
19689: LIST
19690: LIST
19691: PUSH
19692: LD_INT 2
19694: PUSH
19695: LD_INT 30
19697: PUSH
19698: LD_INT 2
19700: PUSH
19701: EMPTY
19702: LIST
19703: LIST
19704: PUSH
19705: LD_INT 30
19707: PUSH
19708: LD_INT 3
19710: PUSH
19711: EMPTY
19712: LIST
19713: LIST
19714: PUSH
19715: EMPTY
19716: LIST
19717: LIST
19718: LIST
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: PPUSH
19724: CALL_OW 72
19728: ST_TO_ADDR
19729: GO 19813
19731: LD_INT 4
19733: DOUBLE
19734: EQUAL
19735: IFTRUE 19739
19737: GO 19812
19739: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
19740: LD_ADDR_VAR 0 12
19744: PUSH
19745: LD_VAR 0 18
19749: PPUSH
19750: LD_INT 22
19752: PUSH
19753: LD_VAR 0 16
19757: PUSH
19758: EMPTY
19759: LIST
19760: LIST
19761: PUSH
19762: LD_INT 2
19764: PUSH
19765: LD_INT 30
19767: PUSH
19768: LD_INT 6
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: PUSH
19775: LD_INT 30
19777: PUSH
19778: LD_INT 7
19780: PUSH
19781: EMPTY
19782: LIST
19783: LIST
19784: PUSH
19785: LD_INT 30
19787: PUSH
19788: LD_INT 8
19790: PUSH
19791: EMPTY
19792: LIST
19793: LIST
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: PUSH
19801: EMPTY
19802: LIST
19803: LIST
19804: PPUSH
19805: CALL_OW 72
19809: ST_TO_ADDR
19810: GO 19813
19812: POP
// if i = 1 then
19813: LD_VAR 0 8
19817: PUSH
19818: LD_INT 1
19820: EQUAL
19821: IFFALSE 19932
// begin tmp := [ ] ;
19823: LD_ADDR_VAR 0 19
19827: PUSH
19828: EMPTY
19829: ST_TO_ADDR
// for j in f do
19830: LD_ADDR_VAR 0 9
19834: PUSH
19835: LD_VAR 0 12
19839: PUSH
19840: FOR_IN
19841: IFFALSE 19914
// if GetBType ( j ) = b_bunker then
19843: LD_VAR 0 9
19847: PPUSH
19848: CALL_OW 266
19852: PUSH
19853: LD_INT 32
19855: EQUAL
19856: IFFALSE 19883
// tmp := Insert ( tmp , 1 , j ) else
19858: LD_ADDR_VAR 0 19
19862: PUSH
19863: LD_VAR 0 19
19867: PPUSH
19868: LD_INT 1
19870: PPUSH
19871: LD_VAR 0 9
19875: PPUSH
19876: CALL_OW 2
19880: ST_TO_ADDR
19881: GO 19912
// tmp := Insert ( tmp , tmp + 1 , j ) ;
19883: LD_ADDR_VAR 0 19
19887: PUSH
19888: LD_VAR 0 19
19892: PPUSH
19893: LD_VAR 0 19
19897: PUSH
19898: LD_INT 1
19900: PLUS
19901: PPUSH
19902: LD_VAR 0 9
19906: PPUSH
19907: CALL_OW 2
19911: ST_TO_ADDR
19912: GO 19840
19914: POP
19915: POP
// if tmp then
19916: LD_VAR 0 19
19920: IFFALSE 19932
// f := tmp ;
19922: LD_ADDR_VAR 0 12
19926: PUSH
19927: LD_VAR 0 19
19931: ST_TO_ADDR
// end ; x := personel [ i ] ;
19932: LD_ADDR_VAR 0 13
19936: PUSH
19937: LD_VAR 0 6
19941: PUSH
19942: LD_VAR 0 8
19946: ARRAY
19947: ST_TO_ADDR
// if x = - 1 then
19948: LD_VAR 0 13
19952: PUSH
19953: LD_INT 1
19955: NEG
19956: EQUAL
19957: IFFALSE 20166
// begin for j in f do
19959: LD_ADDR_VAR 0 9
19963: PUSH
19964: LD_VAR 0 12
19968: PUSH
19969: FOR_IN
19970: IFFALSE 20162
// repeat InitHc ;
19972: CALL_OW 19
// if GetBType ( j ) = b_barracks then
19976: LD_VAR 0 9
19980: PPUSH
19981: CALL_OW 266
19985: PUSH
19986: LD_INT 5
19988: EQUAL
19989: IFFALSE 20059
// begin if UnitsInside ( j ) < 3 then
19991: LD_VAR 0 9
19995: PPUSH
19996: CALL_OW 313
20000: PUSH
20001: LD_INT 3
20003: LESS
20004: IFFALSE 20040
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20006: LD_INT 0
20008: PPUSH
20009: LD_INT 5
20011: PUSH
20012: LD_INT 8
20014: PUSH
20015: LD_INT 9
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: LIST
20022: PUSH
20023: LD_VAR 0 17
20027: ARRAY
20028: PPUSH
20029: LD_VAR 0 4
20033: PPUSH
20034: CALL_OW 380
20038: GO 20057
// PrepareHuman ( false , i , skill ) ;
20040: LD_INT 0
20042: PPUSH
20043: LD_VAR 0 8
20047: PPUSH
20048: LD_VAR 0 4
20052: PPUSH
20053: CALL_OW 380
// end else
20057: GO 20076
// PrepareHuman ( false , i , skill ) ;
20059: LD_INT 0
20061: PPUSH
20062: LD_VAR 0 8
20066: PPUSH
20067: LD_VAR 0 4
20071: PPUSH
20072: CALL_OW 380
// un := CreateHuman ;
20076: LD_ADDR_VAR 0 14
20080: PUSH
20081: CALL_OW 44
20085: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20086: LD_ADDR_VAR 0 7
20090: PUSH
20091: LD_VAR 0 7
20095: PPUSH
20096: LD_INT 1
20098: PPUSH
20099: LD_VAR 0 14
20103: PPUSH
20104: CALL_OW 2
20108: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20109: LD_VAR 0 14
20113: PPUSH
20114: LD_VAR 0 9
20118: PPUSH
20119: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20123: LD_VAR 0 9
20127: PPUSH
20128: CALL_OW 313
20132: PUSH
20133: LD_INT 6
20135: EQUAL
20136: PUSH
20137: LD_VAR 0 9
20141: PPUSH
20142: CALL_OW 266
20146: PUSH
20147: LD_INT 32
20149: PUSH
20150: LD_INT 31
20152: PUSH
20153: EMPTY
20154: LIST
20155: LIST
20156: IN
20157: OR
20158: IFFALSE 19972
20160: GO 19969
20162: POP
20163: POP
// end else
20164: GO 20546
// for j = 1 to x do
20166: LD_ADDR_VAR 0 9
20170: PUSH
20171: DOUBLE
20172: LD_INT 1
20174: DEC
20175: ST_TO_ADDR
20176: LD_VAR 0 13
20180: PUSH
20181: FOR_TO
20182: IFFALSE 20544
// begin InitHc ;
20184: CALL_OW 19
// if not f then
20188: LD_VAR 0 12
20192: NOT
20193: IFFALSE 20282
// begin PrepareHuman ( false , i , skill ) ;
20195: LD_INT 0
20197: PPUSH
20198: LD_VAR 0 8
20202: PPUSH
20203: LD_VAR 0 4
20207: PPUSH
20208: CALL_OW 380
// un := CreateHuman ;
20212: LD_ADDR_VAR 0 14
20216: PUSH
20217: CALL_OW 44
20221: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20222: LD_ADDR_VAR 0 7
20226: PUSH
20227: LD_VAR 0 7
20231: PPUSH
20232: LD_INT 1
20234: PPUSH
20235: LD_VAR 0 14
20239: PPUSH
20240: CALL_OW 2
20244: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20245: LD_VAR 0 14
20249: PPUSH
20250: LD_VAR 0 1
20254: PPUSH
20255: CALL_OW 250
20259: PPUSH
20260: LD_VAR 0 1
20264: PPUSH
20265: CALL_OW 251
20269: PPUSH
20270: LD_INT 10
20272: PPUSH
20273: LD_INT 0
20275: PPUSH
20276: CALL_OW 50
// continue ;
20280: GO 20181
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20282: LD_VAR 0 12
20286: PUSH
20287: LD_INT 1
20289: ARRAY
20290: PPUSH
20291: CALL_OW 313
20295: PUSH
20296: LD_VAR 0 12
20300: PUSH
20301: LD_INT 1
20303: ARRAY
20304: PPUSH
20305: CALL_OW 266
20309: PUSH
20310: LD_INT 32
20312: PUSH
20313: LD_INT 31
20315: PUSH
20316: EMPTY
20317: LIST
20318: LIST
20319: IN
20320: AND
20321: PUSH
20322: LD_VAR 0 12
20326: PUSH
20327: LD_INT 1
20329: ARRAY
20330: PPUSH
20331: CALL_OW 313
20335: PUSH
20336: LD_INT 6
20338: EQUAL
20339: OR
20340: IFFALSE 20360
// f := Delete ( f , 1 ) ;
20342: LD_ADDR_VAR 0 12
20346: PUSH
20347: LD_VAR 0 12
20351: PPUSH
20352: LD_INT 1
20354: PPUSH
20355: CALL_OW 3
20359: ST_TO_ADDR
// if not f then
20360: LD_VAR 0 12
20364: NOT
20365: IFFALSE 20383
// begin x := x + 2 ;
20367: LD_ADDR_VAR 0 13
20371: PUSH
20372: LD_VAR 0 13
20376: PUSH
20377: LD_INT 2
20379: PLUS
20380: ST_TO_ADDR
// continue ;
20381: GO 20181
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20383: LD_VAR 0 12
20387: PUSH
20388: LD_INT 1
20390: ARRAY
20391: PPUSH
20392: CALL_OW 266
20396: PUSH
20397: LD_INT 5
20399: EQUAL
20400: IFFALSE 20474
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20402: LD_VAR 0 12
20406: PUSH
20407: LD_INT 1
20409: ARRAY
20410: PPUSH
20411: CALL_OW 313
20415: PUSH
20416: LD_INT 3
20418: LESS
20419: IFFALSE 20455
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20421: LD_INT 0
20423: PPUSH
20424: LD_INT 5
20426: PUSH
20427: LD_INT 8
20429: PUSH
20430: LD_INT 9
20432: PUSH
20433: EMPTY
20434: LIST
20435: LIST
20436: LIST
20437: PUSH
20438: LD_VAR 0 17
20442: ARRAY
20443: PPUSH
20444: LD_VAR 0 4
20448: PPUSH
20449: CALL_OW 380
20453: GO 20472
// PrepareHuman ( false , i , skill ) ;
20455: LD_INT 0
20457: PPUSH
20458: LD_VAR 0 8
20462: PPUSH
20463: LD_VAR 0 4
20467: PPUSH
20468: CALL_OW 380
// end else
20472: GO 20491
// PrepareHuman ( false , i , skill ) ;
20474: LD_INT 0
20476: PPUSH
20477: LD_VAR 0 8
20481: PPUSH
20482: LD_VAR 0 4
20486: PPUSH
20487: CALL_OW 380
// un := CreateHuman ;
20491: LD_ADDR_VAR 0 14
20495: PUSH
20496: CALL_OW 44
20500: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20501: LD_ADDR_VAR 0 7
20505: PUSH
20506: LD_VAR 0 7
20510: PPUSH
20511: LD_INT 1
20513: PPUSH
20514: LD_VAR 0 14
20518: PPUSH
20519: CALL_OW 2
20523: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20524: LD_VAR 0 14
20528: PPUSH
20529: LD_VAR 0 12
20533: PUSH
20534: LD_INT 1
20536: ARRAY
20537: PPUSH
20538: CALL_OW 52
// end ;
20542: GO 20181
20544: POP
20545: POP
// end ;
20546: GO 19483
20548: POP
20549: POP
// result := result ^ buildings ;
20550: LD_ADDR_VAR 0 7
20554: PUSH
20555: LD_VAR 0 7
20559: PUSH
20560: LD_VAR 0 18
20564: ADD
20565: ST_TO_ADDR
// end else
20566: GO 20709
// begin for i = 1 to personel do
20568: LD_ADDR_VAR 0 8
20572: PUSH
20573: DOUBLE
20574: LD_INT 1
20576: DEC
20577: ST_TO_ADDR
20578: LD_VAR 0 6
20582: PUSH
20583: FOR_TO
20584: IFFALSE 20707
// begin if i > 4 then
20586: LD_VAR 0 8
20590: PUSH
20591: LD_INT 4
20593: GREATER
20594: IFFALSE 20598
// break ;
20596: GO 20707
// x := personel [ i ] ;
20598: LD_ADDR_VAR 0 13
20602: PUSH
20603: LD_VAR 0 6
20607: PUSH
20608: LD_VAR 0 8
20612: ARRAY
20613: ST_TO_ADDR
// if x = - 1 then
20614: LD_VAR 0 13
20618: PUSH
20619: LD_INT 1
20621: NEG
20622: EQUAL
20623: IFFALSE 20627
// continue ;
20625: GO 20583
// PrepareHuman ( false , i , skill ) ;
20627: LD_INT 0
20629: PPUSH
20630: LD_VAR 0 8
20634: PPUSH
20635: LD_VAR 0 4
20639: PPUSH
20640: CALL_OW 380
// un := CreateHuman ;
20644: LD_ADDR_VAR 0 14
20648: PUSH
20649: CALL_OW 44
20653: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20654: LD_VAR 0 14
20658: PPUSH
20659: LD_VAR 0 1
20663: PPUSH
20664: CALL_OW 250
20668: PPUSH
20669: LD_VAR 0 1
20673: PPUSH
20674: CALL_OW 251
20678: PPUSH
20679: LD_INT 10
20681: PPUSH
20682: LD_INT 0
20684: PPUSH
20685: CALL_OW 50
// result := result ^ un ;
20689: LD_ADDR_VAR 0 7
20693: PUSH
20694: LD_VAR 0 7
20698: PUSH
20699: LD_VAR 0 14
20703: ADD
20704: ST_TO_ADDR
// end ;
20705: GO 20583
20707: POP
20708: POP
// end ; end ;
20709: LD_VAR 0 7
20713: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
20714: LD_INT 0
20716: PPUSH
20717: PPUSH
20718: PPUSH
20719: PPUSH
20720: PPUSH
20721: PPUSH
20722: PPUSH
20723: PPUSH
20724: PPUSH
20725: PPUSH
20726: PPUSH
20727: PPUSH
20728: PPUSH
20729: PPUSH
20730: PPUSH
20731: PPUSH
// result := false ;
20732: LD_ADDR_VAR 0 3
20736: PUSH
20737: LD_INT 0
20739: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
20740: LD_VAR 0 1
20744: NOT
20745: PUSH
20746: LD_VAR 0 1
20750: PPUSH
20751: CALL_OW 266
20755: PUSH
20756: LD_INT 32
20758: PUSH
20759: LD_INT 33
20761: PUSH
20762: EMPTY
20763: LIST
20764: LIST
20765: IN
20766: NOT
20767: OR
20768: IFFALSE 20772
// exit ;
20770: GO 21881
// nat := GetNation ( tower ) ;
20772: LD_ADDR_VAR 0 12
20776: PUSH
20777: LD_VAR 0 1
20781: PPUSH
20782: CALL_OW 248
20786: ST_TO_ADDR
// side := GetSide ( tower ) ;
20787: LD_ADDR_VAR 0 16
20791: PUSH
20792: LD_VAR 0 1
20796: PPUSH
20797: CALL_OW 255
20801: ST_TO_ADDR
// x := GetX ( tower ) ;
20802: LD_ADDR_VAR 0 10
20806: PUSH
20807: LD_VAR 0 1
20811: PPUSH
20812: CALL_OW 250
20816: ST_TO_ADDR
// y := GetY ( tower ) ;
20817: LD_ADDR_VAR 0 11
20821: PUSH
20822: LD_VAR 0 1
20826: PPUSH
20827: CALL_OW 251
20831: ST_TO_ADDR
// if not x or not y then
20832: LD_VAR 0 10
20836: NOT
20837: PUSH
20838: LD_VAR 0 11
20842: NOT
20843: OR
20844: IFFALSE 20848
// exit ;
20846: GO 21881
// weapon := 0 ;
20848: LD_ADDR_VAR 0 18
20852: PUSH
20853: LD_INT 0
20855: ST_TO_ADDR
// fac_list := [ ] ;
20856: LD_ADDR_VAR 0 17
20860: PUSH
20861: EMPTY
20862: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
20863: LD_ADDR_VAR 0 6
20867: PUSH
20868: LD_VAR 0 1
20872: PPUSH
20873: CALL_OW 274
20877: PPUSH
20878: LD_VAR 0 2
20882: PPUSH
20883: LD_INT 0
20885: PPUSH
20886: CALL 18452 0 3
20890: PPUSH
20891: LD_INT 30
20893: PUSH
20894: LD_INT 3
20896: PUSH
20897: EMPTY
20898: LIST
20899: LIST
20900: PPUSH
20901: CALL_OW 72
20905: ST_TO_ADDR
// if not factories then
20906: LD_VAR 0 6
20910: NOT
20911: IFFALSE 20915
// exit ;
20913: GO 21881
// for i in factories do
20915: LD_ADDR_VAR 0 8
20919: PUSH
20920: LD_VAR 0 6
20924: PUSH
20925: FOR_IN
20926: IFFALSE 20951
// fac_list := fac_list union AvailableWeaponList ( i ) ;
20928: LD_ADDR_VAR 0 17
20932: PUSH
20933: LD_VAR 0 17
20937: PUSH
20938: LD_VAR 0 8
20942: PPUSH
20943: CALL_OW 478
20947: UNION
20948: ST_TO_ADDR
20949: GO 20925
20951: POP
20952: POP
// if not fac_list then
20953: LD_VAR 0 17
20957: NOT
20958: IFFALSE 20962
// exit ;
20960: GO 21881
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
20962: LD_ADDR_VAR 0 5
20966: PUSH
20967: LD_INT 4
20969: PUSH
20970: LD_INT 5
20972: PUSH
20973: LD_INT 9
20975: PUSH
20976: LD_INT 10
20978: PUSH
20979: LD_INT 6
20981: PUSH
20982: LD_INT 7
20984: PUSH
20985: LD_INT 11
20987: PUSH
20988: EMPTY
20989: LIST
20990: LIST
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: LIST
20996: PUSH
20997: LD_INT 27
20999: PUSH
21000: LD_INT 28
21002: PUSH
21003: LD_INT 26
21005: PUSH
21006: LD_INT 30
21008: PUSH
21009: EMPTY
21010: LIST
21011: LIST
21012: LIST
21013: LIST
21014: PUSH
21015: LD_INT 43
21017: PUSH
21018: LD_INT 44
21020: PUSH
21021: LD_INT 46
21023: PUSH
21024: LD_INT 45
21026: PUSH
21027: LD_INT 47
21029: PUSH
21030: LD_INT 49
21032: PUSH
21033: EMPTY
21034: LIST
21035: LIST
21036: LIST
21037: LIST
21038: LIST
21039: LIST
21040: PUSH
21041: EMPTY
21042: LIST
21043: LIST
21044: LIST
21045: PUSH
21046: LD_VAR 0 12
21050: ARRAY
21051: ST_TO_ADDR
// list := list isect fac_list ;
21052: LD_ADDR_VAR 0 5
21056: PUSH
21057: LD_VAR 0 5
21061: PUSH
21062: LD_VAR 0 17
21066: ISECT
21067: ST_TO_ADDR
// if not list then
21068: LD_VAR 0 5
21072: NOT
21073: IFFALSE 21077
// exit ;
21075: GO 21881
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21077: LD_VAR 0 12
21081: PUSH
21082: LD_INT 3
21084: EQUAL
21085: PUSH
21086: LD_INT 49
21088: PUSH
21089: LD_VAR 0 5
21093: IN
21094: AND
21095: PUSH
21096: LD_INT 31
21098: PPUSH
21099: LD_VAR 0 16
21103: PPUSH
21104: CALL_OW 321
21108: PUSH
21109: LD_INT 2
21111: EQUAL
21112: AND
21113: IFFALSE 21173
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21115: LD_INT 22
21117: PUSH
21118: LD_VAR 0 16
21122: PUSH
21123: EMPTY
21124: LIST
21125: LIST
21126: PUSH
21127: LD_INT 35
21129: PUSH
21130: LD_INT 49
21132: PUSH
21133: EMPTY
21134: LIST
21135: LIST
21136: PUSH
21137: LD_INT 91
21139: PUSH
21140: LD_VAR 0 1
21144: PUSH
21145: LD_INT 10
21147: PUSH
21148: EMPTY
21149: LIST
21150: LIST
21151: LIST
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: LIST
21157: PPUSH
21158: CALL_OW 69
21162: NOT
21163: IFFALSE 21173
// weapon := ru_time_lapser ;
21165: LD_ADDR_VAR 0 18
21169: PUSH
21170: LD_INT 49
21172: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21173: LD_VAR 0 12
21177: PUSH
21178: LD_INT 1
21180: PUSH
21181: LD_INT 2
21183: PUSH
21184: EMPTY
21185: LIST
21186: LIST
21187: IN
21188: PUSH
21189: LD_INT 11
21191: PUSH
21192: LD_VAR 0 5
21196: IN
21197: PUSH
21198: LD_INT 30
21200: PUSH
21201: LD_VAR 0 5
21205: IN
21206: OR
21207: AND
21208: PUSH
21209: LD_INT 6
21211: PPUSH
21212: LD_VAR 0 16
21216: PPUSH
21217: CALL_OW 321
21221: PUSH
21222: LD_INT 2
21224: EQUAL
21225: AND
21226: IFFALSE 21391
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21228: LD_INT 22
21230: PUSH
21231: LD_VAR 0 16
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: PUSH
21240: LD_INT 2
21242: PUSH
21243: LD_INT 35
21245: PUSH
21246: LD_INT 11
21248: PUSH
21249: EMPTY
21250: LIST
21251: LIST
21252: PUSH
21253: LD_INT 35
21255: PUSH
21256: LD_INT 30
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PUSH
21263: EMPTY
21264: LIST
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 91
21270: PUSH
21271: LD_VAR 0 1
21275: PUSH
21276: LD_INT 18
21278: PUSH
21279: EMPTY
21280: LIST
21281: LIST
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: LIST
21288: PPUSH
21289: CALL_OW 69
21293: NOT
21294: PUSH
21295: LD_INT 22
21297: PUSH
21298: LD_VAR 0 16
21302: PUSH
21303: EMPTY
21304: LIST
21305: LIST
21306: PUSH
21307: LD_INT 2
21309: PUSH
21310: LD_INT 30
21312: PUSH
21313: LD_INT 32
21315: PUSH
21316: EMPTY
21317: LIST
21318: LIST
21319: PUSH
21320: LD_INT 30
21322: PUSH
21323: LD_INT 33
21325: PUSH
21326: EMPTY
21327: LIST
21328: LIST
21329: PUSH
21330: EMPTY
21331: LIST
21332: LIST
21333: LIST
21334: PUSH
21335: LD_INT 91
21337: PUSH
21338: LD_VAR 0 1
21342: PUSH
21343: LD_INT 12
21345: PUSH
21346: EMPTY
21347: LIST
21348: LIST
21349: LIST
21350: PUSH
21351: EMPTY
21352: LIST
21353: LIST
21354: LIST
21355: PUSH
21356: EMPTY
21357: LIST
21358: PPUSH
21359: CALL_OW 69
21363: PUSH
21364: LD_INT 2
21366: GREATER
21367: AND
21368: IFFALSE 21391
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21370: LD_ADDR_VAR 0 18
21374: PUSH
21375: LD_INT 11
21377: PUSH
21378: LD_INT 30
21380: PUSH
21381: EMPTY
21382: LIST
21383: LIST
21384: PUSH
21385: LD_VAR 0 12
21389: ARRAY
21390: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21391: LD_VAR 0 18
21395: NOT
21396: PUSH
21397: LD_INT 40
21399: PPUSH
21400: LD_VAR 0 16
21404: PPUSH
21405: CALL_OW 321
21409: PUSH
21410: LD_INT 2
21412: EQUAL
21413: AND
21414: PUSH
21415: LD_INT 7
21417: PUSH
21418: LD_VAR 0 5
21422: IN
21423: PUSH
21424: LD_INT 28
21426: PUSH
21427: LD_VAR 0 5
21431: IN
21432: OR
21433: PUSH
21434: LD_INT 45
21436: PUSH
21437: LD_VAR 0 5
21441: IN
21442: OR
21443: AND
21444: IFFALSE 21698
// begin hex := GetHexInfo ( x , y ) ;
21446: LD_ADDR_VAR 0 4
21450: PUSH
21451: LD_VAR 0 10
21455: PPUSH
21456: LD_VAR 0 11
21460: PPUSH
21461: CALL_OW 546
21465: ST_TO_ADDR
// if hex [ 1 ] then
21466: LD_VAR 0 4
21470: PUSH
21471: LD_INT 1
21473: ARRAY
21474: IFFALSE 21478
// exit ;
21476: GO 21881
// height := hex [ 2 ] ;
21478: LD_ADDR_VAR 0 15
21482: PUSH
21483: LD_VAR 0 4
21487: PUSH
21488: LD_INT 2
21490: ARRAY
21491: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21492: LD_ADDR_VAR 0 14
21496: PUSH
21497: LD_INT 0
21499: PUSH
21500: LD_INT 2
21502: PUSH
21503: LD_INT 3
21505: PUSH
21506: LD_INT 5
21508: PUSH
21509: EMPTY
21510: LIST
21511: LIST
21512: LIST
21513: LIST
21514: ST_TO_ADDR
// for i in tmp do
21515: LD_ADDR_VAR 0 8
21519: PUSH
21520: LD_VAR 0 14
21524: PUSH
21525: FOR_IN
21526: IFFALSE 21696
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21528: LD_ADDR_VAR 0 9
21532: PUSH
21533: LD_VAR 0 10
21537: PPUSH
21538: LD_VAR 0 8
21542: PPUSH
21543: LD_INT 5
21545: PPUSH
21546: CALL_OW 272
21550: PUSH
21551: LD_VAR 0 11
21555: PPUSH
21556: LD_VAR 0 8
21560: PPUSH
21561: LD_INT 5
21563: PPUSH
21564: CALL_OW 273
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21573: LD_VAR 0 9
21577: PUSH
21578: LD_INT 1
21580: ARRAY
21581: PPUSH
21582: LD_VAR 0 9
21586: PUSH
21587: LD_INT 2
21589: ARRAY
21590: PPUSH
21591: CALL_OW 488
21595: IFFALSE 21694
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
21597: LD_ADDR_VAR 0 4
21601: PUSH
21602: LD_VAR 0 9
21606: PUSH
21607: LD_INT 1
21609: ARRAY
21610: PPUSH
21611: LD_VAR 0 9
21615: PUSH
21616: LD_INT 2
21618: ARRAY
21619: PPUSH
21620: CALL_OW 546
21624: ST_TO_ADDR
// if hex [ 1 ] then
21625: LD_VAR 0 4
21629: PUSH
21630: LD_INT 1
21632: ARRAY
21633: IFFALSE 21637
// continue ;
21635: GO 21525
// h := hex [ 2 ] ;
21637: LD_ADDR_VAR 0 13
21641: PUSH
21642: LD_VAR 0 4
21646: PUSH
21647: LD_INT 2
21649: ARRAY
21650: ST_TO_ADDR
// if h + 7 < height then
21651: LD_VAR 0 13
21655: PUSH
21656: LD_INT 7
21658: PLUS
21659: PUSH
21660: LD_VAR 0 15
21664: LESS
21665: IFFALSE 21694
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
21667: LD_ADDR_VAR 0 18
21671: PUSH
21672: LD_INT 7
21674: PUSH
21675: LD_INT 28
21677: PUSH
21678: LD_INT 45
21680: PUSH
21681: EMPTY
21682: LIST
21683: LIST
21684: LIST
21685: PUSH
21686: LD_VAR 0 12
21690: ARRAY
21691: ST_TO_ADDR
// break ;
21692: GO 21696
// end ; end ; end ;
21694: GO 21525
21696: POP
21697: POP
// end ; if not weapon then
21698: LD_VAR 0 18
21702: NOT
21703: IFFALSE 21763
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
21705: LD_ADDR_VAR 0 5
21709: PUSH
21710: LD_VAR 0 5
21714: PUSH
21715: LD_INT 11
21717: PUSH
21718: LD_INT 30
21720: PUSH
21721: LD_INT 49
21723: PUSH
21724: EMPTY
21725: LIST
21726: LIST
21727: LIST
21728: DIFF
21729: ST_TO_ADDR
// if not list then
21730: LD_VAR 0 5
21734: NOT
21735: IFFALSE 21739
// exit ;
21737: GO 21881
// weapon := list [ rand ( 1 , list ) ] ;
21739: LD_ADDR_VAR 0 18
21743: PUSH
21744: LD_VAR 0 5
21748: PUSH
21749: LD_INT 1
21751: PPUSH
21752: LD_VAR 0 5
21756: PPUSH
21757: CALL_OW 12
21761: ARRAY
21762: ST_TO_ADDR
// end ; if weapon then
21763: LD_VAR 0 18
21767: IFFALSE 21881
// begin tmp := CostOfWeapon ( weapon ) ;
21769: LD_ADDR_VAR 0 14
21773: PUSH
21774: LD_VAR 0 18
21778: PPUSH
21779: CALL_OW 451
21783: ST_TO_ADDR
// j := GetBase ( tower ) ;
21784: LD_ADDR_VAR 0 9
21788: PUSH
21789: LD_VAR 0 1
21793: PPUSH
21794: CALL_OW 274
21798: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
21799: LD_VAR 0 9
21803: PPUSH
21804: LD_INT 1
21806: PPUSH
21807: CALL_OW 275
21811: PUSH
21812: LD_VAR 0 14
21816: PUSH
21817: LD_INT 1
21819: ARRAY
21820: GREATEREQUAL
21821: PUSH
21822: LD_VAR 0 9
21826: PPUSH
21827: LD_INT 2
21829: PPUSH
21830: CALL_OW 275
21834: PUSH
21835: LD_VAR 0 14
21839: PUSH
21840: LD_INT 2
21842: ARRAY
21843: GREATEREQUAL
21844: AND
21845: PUSH
21846: LD_VAR 0 9
21850: PPUSH
21851: LD_INT 3
21853: PPUSH
21854: CALL_OW 275
21858: PUSH
21859: LD_VAR 0 14
21863: PUSH
21864: LD_INT 3
21866: ARRAY
21867: GREATEREQUAL
21868: AND
21869: IFFALSE 21881
// result := weapon ;
21871: LD_ADDR_VAR 0 3
21875: PUSH
21876: LD_VAR 0 18
21880: ST_TO_ADDR
// end ; end ;
21881: LD_VAR 0 3
21885: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
21886: LD_INT 0
21888: PPUSH
21889: PPUSH
// result := true ;
21890: LD_ADDR_VAR 0 3
21894: PUSH
21895: LD_INT 1
21897: ST_TO_ADDR
// if array1 = array2 then
21898: LD_VAR 0 1
21902: PUSH
21903: LD_VAR 0 2
21907: EQUAL
21908: IFFALSE 21968
// begin for i = 1 to array1 do
21910: LD_ADDR_VAR 0 4
21914: PUSH
21915: DOUBLE
21916: LD_INT 1
21918: DEC
21919: ST_TO_ADDR
21920: LD_VAR 0 1
21924: PUSH
21925: FOR_TO
21926: IFFALSE 21964
// if array1 [ i ] <> array2 [ i ] then
21928: LD_VAR 0 1
21932: PUSH
21933: LD_VAR 0 4
21937: ARRAY
21938: PUSH
21939: LD_VAR 0 2
21943: PUSH
21944: LD_VAR 0 4
21948: ARRAY
21949: NONEQUAL
21950: IFFALSE 21962
// begin result := false ;
21952: LD_ADDR_VAR 0 3
21956: PUSH
21957: LD_INT 0
21959: ST_TO_ADDR
// break ;
21960: GO 21964
// end ;
21962: GO 21925
21964: POP
21965: POP
// end else
21966: GO 21976
// result := false ;
21968: LD_ADDR_VAR 0 3
21972: PUSH
21973: LD_INT 0
21975: ST_TO_ADDR
// end ;
21976: LD_VAR 0 3
21980: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
21981: LD_INT 0
21983: PPUSH
21984: PPUSH
// if not array1 or not array2 then
21985: LD_VAR 0 1
21989: NOT
21990: PUSH
21991: LD_VAR 0 2
21995: NOT
21996: OR
21997: IFFALSE 22001
// exit ;
21999: GO 22065
// result := true ;
22001: LD_ADDR_VAR 0 3
22005: PUSH
22006: LD_INT 1
22008: ST_TO_ADDR
// for i = 1 to array1 do
22009: LD_ADDR_VAR 0 4
22013: PUSH
22014: DOUBLE
22015: LD_INT 1
22017: DEC
22018: ST_TO_ADDR
22019: LD_VAR 0 1
22023: PUSH
22024: FOR_TO
22025: IFFALSE 22063
// if array1 [ i ] <> array2 [ i ] then
22027: LD_VAR 0 1
22031: PUSH
22032: LD_VAR 0 4
22036: ARRAY
22037: PUSH
22038: LD_VAR 0 2
22042: PUSH
22043: LD_VAR 0 4
22047: ARRAY
22048: NONEQUAL
22049: IFFALSE 22061
// begin result := false ;
22051: LD_ADDR_VAR 0 3
22055: PUSH
22056: LD_INT 0
22058: ST_TO_ADDR
// break ;
22059: GO 22063
// end ;
22061: GO 22024
22063: POP
22064: POP
// end ;
22065: LD_VAR 0 3
22069: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22070: LD_INT 0
22072: PPUSH
22073: PPUSH
22074: PPUSH
// pom := GetBase ( fac ) ;
22075: LD_ADDR_VAR 0 5
22079: PUSH
22080: LD_VAR 0 1
22084: PPUSH
22085: CALL_OW 274
22089: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22090: LD_ADDR_VAR 0 4
22094: PUSH
22095: LD_VAR 0 2
22099: PUSH
22100: LD_INT 1
22102: ARRAY
22103: PPUSH
22104: LD_VAR 0 2
22108: PUSH
22109: LD_INT 2
22111: ARRAY
22112: PPUSH
22113: LD_VAR 0 2
22117: PUSH
22118: LD_INT 3
22120: ARRAY
22121: PPUSH
22122: LD_VAR 0 2
22126: PUSH
22127: LD_INT 4
22129: ARRAY
22130: PPUSH
22131: CALL_OW 449
22135: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22136: LD_ADDR_VAR 0 3
22140: PUSH
22141: LD_VAR 0 5
22145: PPUSH
22146: LD_INT 1
22148: PPUSH
22149: CALL_OW 275
22153: PUSH
22154: LD_VAR 0 4
22158: PUSH
22159: LD_INT 1
22161: ARRAY
22162: GREATEREQUAL
22163: PUSH
22164: LD_VAR 0 5
22168: PPUSH
22169: LD_INT 2
22171: PPUSH
22172: CALL_OW 275
22176: PUSH
22177: LD_VAR 0 4
22181: PUSH
22182: LD_INT 2
22184: ARRAY
22185: GREATEREQUAL
22186: AND
22187: PUSH
22188: LD_VAR 0 5
22192: PPUSH
22193: LD_INT 3
22195: PPUSH
22196: CALL_OW 275
22200: PUSH
22201: LD_VAR 0 4
22205: PUSH
22206: LD_INT 3
22208: ARRAY
22209: GREATEREQUAL
22210: AND
22211: ST_TO_ADDR
// end ;
22212: LD_VAR 0 3
22216: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22217: LD_INT 0
22219: PPUSH
22220: PPUSH
22221: PPUSH
22222: PPUSH
// pom := GetBase ( building ) ;
22223: LD_ADDR_VAR 0 3
22227: PUSH
22228: LD_VAR 0 1
22232: PPUSH
22233: CALL_OW 274
22237: ST_TO_ADDR
// if not pom then
22238: LD_VAR 0 3
22242: NOT
22243: IFFALSE 22247
// exit ;
22245: GO 22417
// btype := GetBType ( building ) ;
22247: LD_ADDR_VAR 0 5
22251: PUSH
22252: LD_VAR 0 1
22256: PPUSH
22257: CALL_OW 266
22261: ST_TO_ADDR
// if btype = b_armoury then
22262: LD_VAR 0 5
22266: PUSH
22267: LD_INT 4
22269: EQUAL
22270: IFFALSE 22280
// btype := b_barracks ;
22272: LD_ADDR_VAR 0 5
22276: PUSH
22277: LD_INT 5
22279: ST_TO_ADDR
// if btype = b_depot then
22280: LD_VAR 0 5
22284: PUSH
22285: LD_INT 0
22287: EQUAL
22288: IFFALSE 22298
// btype := b_warehouse ;
22290: LD_ADDR_VAR 0 5
22294: PUSH
22295: LD_INT 1
22297: ST_TO_ADDR
// if btype = b_workshop then
22298: LD_VAR 0 5
22302: PUSH
22303: LD_INT 2
22305: EQUAL
22306: IFFALSE 22316
// btype := b_factory ;
22308: LD_ADDR_VAR 0 5
22312: PUSH
22313: LD_INT 3
22315: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22316: LD_ADDR_VAR 0 4
22320: PUSH
22321: LD_VAR 0 5
22325: PPUSH
22326: LD_VAR 0 1
22330: PPUSH
22331: CALL_OW 248
22335: PPUSH
22336: CALL_OW 450
22340: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22341: LD_ADDR_VAR 0 2
22345: PUSH
22346: LD_VAR 0 3
22350: PPUSH
22351: LD_INT 1
22353: PPUSH
22354: CALL_OW 275
22358: PUSH
22359: LD_VAR 0 4
22363: PUSH
22364: LD_INT 1
22366: ARRAY
22367: GREATEREQUAL
22368: PUSH
22369: LD_VAR 0 3
22373: PPUSH
22374: LD_INT 2
22376: PPUSH
22377: CALL_OW 275
22381: PUSH
22382: LD_VAR 0 4
22386: PUSH
22387: LD_INT 2
22389: ARRAY
22390: GREATEREQUAL
22391: AND
22392: PUSH
22393: LD_VAR 0 3
22397: PPUSH
22398: LD_INT 3
22400: PPUSH
22401: CALL_OW 275
22405: PUSH
22406: LD_VAR 0 4
22410: PUSH
22411: LD_INT 3
22413: ARRAY
22414: GREATEREQUAL
22415: AND
22416: ST_TO_ADDR
// end ;
22417: LD_VAR 0 2
22421: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22422: LD_INT 0
22424: PPUSH
22425: PPUSH
22426: PPUSH
// pom := GetBase ( building ) ;
22427: LD_ADDR_VAR 0 4
22431: PUSH
22432: LD_VAR 0 1
22436: PPUSH
22437: CALL_OW 274
22441: ST_TO_ADDR
// if not pom then
22442: LD_VAR 0 4
22446: NOT
22447: IFFALSE 22451
// exit ;
22449: GO 22552
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22451: LD_ADDR_VAR 0 5
22455: PUSH
22456: LD_VAR 0 2
22460: PPUSH
22461: LD_VAR 0 1
22465: PPUSH
22466: CALL_OW 248
22470: PPUSH
22471: CALL_OW 450
22475: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22476: LD_ADDR_VAR 0 3
22480: PUSH
22481: LD_VAR 0 4
22485: PPUSH
22486: LD_INT 1
22488: PPUSH
22489: CALL_OW 275
22493: PUSH
22494: LD_VAR 0 5
22498: PUSH
22499: LD_INT 1
22501: ARRAY
22502: GREATEREQUAL
22503: PUSH
22504: LD_VAR 0 4
22508: PPUSH
22509: LD_INT 2
22511: PPUSH
22512: CALL_OW 275
22516: PUSH
22517: LD_VAR 0 5
22521: PUSH
22522: LD_INT 2
22524: ARRAY
22525: GREATEREQUAL
22526: AND
22527: PUSH
22528: LD_VAR 0 4
22532: PPUSH
22533: LD_INT 3
22535: PPUSH
22536: CALL_OW 275
22540: PUSH
22541: LD_VAR 0 5
22545: PUSH
22546: LD_INT 3
22548: ARRAY
22549: GREATEREQUAL
22550: AND
22551: ST_TO_ADDR
// end ;
22552: LD_VAR 0 3
22556: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22557: LD_INT 0
22559: PPUSH
22560: PPUSH
22561: PPUSH
22562: PPUSH
22563: PPUSH
22564: PPUSH
22565: PPUSH
22566: PPUSH
22567: PPUSH
22568: PPUSH
22569: PPUSH
// result := false ;
22570: LD_ADDR_VAR 0 8
22574: PUSH
22575: LD_INT 0
22577: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22578: LD_VAR 0 5
22582: NOT
22583: PUSH
22584: LD_VAR 0 1
22588: NOT
22589: OR
22590: PUSH
22591: LD_VAR 0 2
22595: NOT
22596: OR
22597: PUSH
22598: LD_VAR 0 3
22602: NOT
22603: OR
22604: IFFALSE 22608
// exit ;
22606: GO 23422
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
22608: LD_ADDR_VAR 0 14
22612: PUSH
22613: LD_VAR 0 1
22617: PPUSH
22618: LD_VAR 0 2
22622: PPUSH
22623: LD_VAR 0 3
22627: PPUSH
22628: LD_VAR 0 4
22632: PPUSH
22633: LD_VAR 0 5
22637: PUSH
22638: LD_INT 1
22640: ARRAY
22641: PPUSH
22642: CALL_OW 248
22646: PPUSH
22647: LD_INT 0
22649: PPUSH
22650: CALL 24659 0 6
22654: ST_TO_ADDR
// if not hexes then
22655: LD_VAR 0 14
22659: NOT
22660: IFFALSE 22664
// exit ;
22662: GO 23422
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22664: LD_ADDR_VAR 0 17
22668: PUSH
22669: LD_VAR 0 5
22673: PPUSH
22674: LD_INT 22
22676: PUSH
22677: LD_VAR 0 13
22681: PPUSH
22682: CALL_OW 255
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: PUSH
22691: LD_INT 2
22693: PUSH
22694: LD_INT 30
22696: PUSH
22697: LD_INT 0
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: PUSH
22704: LD_INT 30
22706: PUSH
22707: LD_INT 1
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: PUSH
22714: EMPTY
22715: LIST
22716: LIST
22717: LIST
22718: PUSH
22719: EMPTY
22720: LIST
22721: LIST
22722: PPUSH
22723: CALL_OW 72
22727: ST_TO_ADDR
// for i = 1 to hexes do
22728: LD_ADDR_VAR 0 9
22732: PUSH
22733: DOUBLE
22734: LD_INT 1
22736: DEC
22737: ST_TO_ADDR
22738: LD_VAR 0 14
22742: PUSH
22743: FOR_TO
22744: IFFALSE 23420
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22746: LD_ADDR_VAR 0 13
22750: PUSH
22751: LD_VAR 0 14
22755: PUSH
22756: LD_VAR 0 9
22760: ARRAY
22761: PUSH
22762: LD_INT 1
22764: ARRAY
22765: PPUSH
22766: LD_VAR 0 14
22770: PUSH
22771: LD_VAR 0 9
22775: ARRAY
22776: PUSH
22777: LD_INT 2
22779: ARRAY
22780: PPUSH
22781: CALL_OW 428
22785: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
22786: LD_VAR 0 14
22790: PUSH
22791: LD_VAR 0 9
22795: ARRAY
22796: PUSH
22797: LD_INT 1
22799: ARRAY
22800: PPUSH
22801: LD_VAR 0 14
22805: PUSH
22806: LD_VAR 0 9
22810: ARRAY
22811: PUSH
22812: LD_INT 2
22814: ARRAY
22815: PPUSH
22816: CALL_OW 351
22820: PUSH
22821: LD_VAR 0 14
22825: PUSH
22826: LD_VAR 0 9
22830: ARRAY
22831: PUSH
22832: LD_INT 1
22834: ARRAY
22835: PPUSH
22836: LD_VAR 0 14
22840: PUSH
22841: LD_VAR 0 9
22845: ARRAY
22846: PUSH
22847: LD_INT 2
22849: ARRAY
22850: PPUSH
22851: CALL_OW 488
22855: NOT
22856: OR
22857: PUSH
22858: LD_VAR 0 13
22862: PPUSH
22863: CALL_OW 247
22867: PUSH
22868: LD_INT 3
22870: EQUAL
22871: OR
22872: IFFALSE 22878
// exit ;
22874: POP
22875: POP
22876: GO 23422
// if not tmp then
22878: LD_VAR 0 13
22882: NOT
22883: IFFALSE 22887
// continue ;
22885: GO 22743
// result := true ;
22887: LD_ADDR_VAR 0 8
22891: PUSH
22892: LD_INT 1
22894: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
22895: LD_VAR 0 6
22899: PUSH
22900: LD_VAR 0 13
22904: PPUSH
22905: CALL_OW 247
22909: PUSH
22910: LD_INT 2
22912: EQUAL
22913: AND
22914: PUSH
22915: LD_VAR 0 13
22919: PPUSH
22920: CALL_OW 263
22924: PUSH
22925: LD_INT 1
22927: EQUAL
22928: AND
22929: IFFALSE 23093
// begin if IsDrivenBy ( tmp ) then
22931: LD_VAR 0 13
22935: PPUSH
22936: CALL_OW 311
22940: IFFALSE 22944
// continue ;
22942: GO 22743
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
22944: LD_VAR 0 6
22948: PPUSH
22949: LD_INT 3
22951: PUSH
22952: LD_INT 60
22954: PUSH
22955: EMPTY
22956: LIST
22957: PUSH
22958: EMPTY
22959: LIST
22960: LIST
22961: PUSH
22962: LD_INT 3
22964: PUSH
22965: LD_INT 55
22967: PUSH
22968: EMPTY
22969: LIST
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: PUSH
22975: EMPTY
22976: LIST
22977: LIST
22978: PPUSH
22979: CALL_OW 72
22983: IFFALSE 23091
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
22985: LD_ADDR_VAR 0 18
22989: PUSH
22990: LD_VAR 0 6
22994: PPUSH
22995: LD_INT 3
22997: PUSH
22998: LD_INT 60
23000: PUSH
23001: EMPTY
23002: LIST
23003: PUSH
23004: EMPTY
23005: LIST
23006: LIST
23007: PUSH
23008: LD_INT 3
23010: PUSH
23011: LD_INT 55
23013: PUSH
23014: EMPTY
23015: LIST
23016: PUSH
23017: EMPTY
23018: LIST
23019: LIST
23020: PUSH
23021: EMPTY
23022: LIST
23023: LIST
23024: PPUSH
23025: CALL_OW 72
23029: PUSH
23030: LD_INT 1
23032: ARRAY
23033: ST_TO_ADDR
// if IsInUnit ( driver ) then
23034: LD_VAR 0 18
23038: PPUSH
23039: CALL_OW 310
23043: IFFALSE 23054
// ComExit ( driver ) ;
23045: LD_VAR 0 18
23049: PPUSH
23050: CALL 47843 0 1
// AddComEnterUnit ( driver , tmp ) ;
23054: LD_VAR 0 18
23058: PPUSH
23059: LD_VAR 0 13
23063: PPUSH
23064: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23068: LD_VAR 0 18
23072: PPUSH
23073: LD_VAR 0 7
23077: PPUSH
23078: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23082: LD_VAR 0 18
23086: PPUSH
23087: CALL_OW 181
// end ; continue ;
23091: GO 22743
// end ; if not cleaners or not tmp in cleaners then
23093: LD_VAR 0 6
23097: NOT
23098: PUSH
23099: LD_VAR 0 13
23103: PUSH
23104: LD_VAR 0 6
23108: IN
23109: NOT
23110: OR
23111: IFFALSE 23418
// begin if dep then
23113: LD_VAR 0 17
23117: IFFALSE 23253
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23119: LD_ADDR_VAR 0 16
23123: PUSH
23124: LD_VAR 0 17
23128: PUSH
23129: LD_INT 1
23131: ARRAY
23132: PPUSH
23133: CALL_OW 250
23137: PPUSH
23138: LD_VAR 0 17
23142: PUSH
23143: LD_INT 1
23145: ARRAY
23146: PPUSH
23147: CALL_OW 254
23151: PPUSH
23152: LD_INT 5
23154: PPUSH
23155: CALL_OW 272
23159: PUSH
23160: LD_VAR 0 17
23164: PUSH
23165: LD_INT 1
23167: ARRAY
23168: PPUSH
23169: CALL_OW 251
23173: PPUSH
23174: LD_VAR 0 17
23178: PUSH
23179: LD_INT 1
23181: ARRAY
23182: PPUSH
23183: CALL_OW 254
23187: PPUSH
23188: LD_INT 5
23190: PPUSH
23191: CALL_OW 273
23195: PUSH
23196: EMPTY
23197: LIST
23198: LIST
23199: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23200: LD_VAR 0 16
23204: PUSH
23205: LD_INT 1
23207: ARRAY
23208: PPUSH
23209: LD_VAR 0 16
23213: PUSH
23214: LD_INT 2
23216: ARRAY
23217: PPUSH
23218: CALL_OW 488
23222: IFFALSE 23253
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23224: LD_VAR 0 13
23228: PPUSH
23229: LD_VAR 0 16
23233: PUSH
23234: LD_INT 1
23236: ARRAY
23237: PPUSH
23238: LD_VAR 0 16
23242: PUSH
23243: LD_INT 2
23245: ARRAY
23246: PPUSH
23247: CALL_OW 111
// continue ;
23251: GO 22743
// end ; end ; r := GetDir ( tmp ) ;
23253: LD_ADDR_VAR 0 15
23257: PUSH
23258: LD_VAR 0 13
23262: PPUSH
23263: CALL_OW 254
23267: ST_TO_ADDR
// if r = 5 then
23268: LD_VAR 0 15
23272: PUSH
23273: LD_INT 5
23275: EQUAL
23276: IFFALSE 23286
// r := 0 ;
23278: LD_ADDR_VAR 0 15
23282: PUSH
23283: LD_INT 0
23285: ST_TO_ADDR
// for j = r to 5 do
23286: LD_ADDR_VAR 0 10
23290: PUSH
23291: DOUBLE
23292: LD_VAR 0 15
23296: DEC
23297: ST_TO_ADDR
23298: LD_INT 5
23300: PUSH
23301: FOR_TO
23302: IFFALSE 23416
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23304: LD_ADDR_VAR 0 11
23308: PUSH
23309: LD_VAR 0 13
23313: PPUSH
23314: CALL_OW 250
23318: PPUSH
23319: LD_VAR 0 10
23323: PPUSH
23324: LD_INT 2
23326: PPUSH
23327: CALL_OW 272
23331: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23332: LD_ADDR_VAR 0 12
23336: PUSH
23337: LD_VAR 0 13
23341: PPUSH
23342: CALL_OW 251
23346: PPUSH
23347: LD_VAR 0 10
23351: PPUSH
23352: LD_INT 2
23354: PPUSH
23355: CALL_OW 273
23359: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23360: LD_VAR 0 11
23364: PPUSH
23365: LD_VAR 0 12
23369: PPUSH
23370: CALL_OW 488
23374: PUSH
23375: LD_VAR 0 11
23379: PPUSH
23380: LD_VAR 0 12
23384: PPUSH
23385: CALL_OW 428
23389: NOT
23390: AND
23391: IFFALSE 23414
// begin ComMoveXY ( tmp , _x , _y ) ;
23393: LD_VAR 0 13
23397: PPUSH
23398: LD_VAR 0 11
23402: PPUSH
23403: LD_VAR 0 12
23407: PPUSH
23408: CALL_OW 111
// break ;
23412: GO 23416
// end ; end ;
23414: GO 23301
23416: POP
23417: POP
// end ; end ;
23418: GO 22743
23420: POP
23421: POP
// end ;
23422: LD_VAR 0 8
23426: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23427: LD_INT 0
23429: PPUSH
// result := true ;
23430: LD_ADDR_VAR 0 3
23434: PUSH
23435: LD_INT 1
23437: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23438: LD_VAR 0 2
23442: PUSH
23443: LD_INT 24
23445: DOUBLE
23446: EQUAL
23447: IFTRUE 23457
23449: LD_INT 33
23451: DOUBLE
23452: EQUAL
23453: IFTRUE 23457
23455: GO 23482
23457: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23458: LD_ADDR_VAR 0 3
23462: PUSH
23463: LD_INT 32
23465: PPUSH
23466: LD_VAR 0 1
23470: PPUSH
23471: CALL_OW 321
23475: PUSH
23476: LD_INT 2
23478: EQUAL
23479: ST_TO_ADDR
23480: GO 23802
23482: LD_INT 20
23484: DOUBLE
23485: EQUAL
23486: IFTRUE 23490
23488: GO 23515
23490: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23491: LD_ADDR_VAR 0 3
23495: PUSH
23496: LD_INT 6
23498: PPUSH
23499: LD_VAR 0 1
23503: PPUSH
23504: CALL_OW 321
23508: PUSH
23509: LD_INT 2
23511: EQUAL
23512: ST_TO_ADDR
23513: GO 23802
23515: LD_INT 22
23517: DOUBLE
23518: EQUAL
23519: IFTRUE 23529
23521: LD_INT 36
23523: DOUBLE
23524: EQUAL
23525: IFTRUE 23529
23527: GO 23554
23529: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23530: LD_ADDR_VAR 0 3
23534: PUSH
23535: LD_INT 15
23537: PPUSH
23538: LD_VAR 0 1
23542: PPUSH
23543: CALL_OW 321
23547: PUSH
23548: LD_INT 2
23550: EQUAL
23551: ST_TO_ADDR
23552: GO 23802
23554: LD_INT 30
23556: DOUBLE
23557: EQUAL
23558: IFTRUE 23562
23560: GO 23587
23562: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23563: LD_ADDR_VAR 0 3
23567: PUSH
23568: LD_INT 20
23570: PPUSH
23571: LD_VAR 0 1
23575: PPUSH
23576: CALL_OW 321
23580: PUSH
23581: LD_INT 2
23583: EQUAL
23584: ST_TO_ADDR
23585: GO 23802
23587: LD_INT 28
23589: DOUBLE
23590: EQUAL
23591: IFTRUE 23601
23593: LD_INT 21
23595: DOUBLE
23596: EQUAL
23597: IFTRUE 23601
23599: GO 23626
23601: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
23602: LD_ADDR_VAR 0 3
23606: PUSH
23607: LD_INT 21
23609: PPUSH
23610: LD_VAR 0 1
23614: PPUSH
23615: CALL_OW 321
23619: PUSH
23620: LD_INT 2
23622: EQUAL
23623: ST_TO_ADDR
23624: GO 23802
23626: LD_INT 16
23628: DOUBLE
23629: EQUAL
23630: IFTRUE 23634
23632: GO 23661
23634: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
23635: LD_ADDR_VAR 0 3
23639: PUSH
23640: LD_EXP 79
23644: PPUSH
23645: LD_VAR 0 1
23649: PPUSH
23650: CALL_OW 321
23654: PUSH
23655: LD_INT 2
23657: EQUAL
23658: ST_TO_ADDR
23659: GO 23802
23661: LD_INT 19
23663: DOUBLE
23664: EQUAL
23665: IFTRUE 23675
23667: LD_INT 23
23669: DOUBLE
23670: EQUAL
23671: IFTRUE 23675
23673: GO 23702
23675: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
23676: LD_ADDR_VAR 0 3
23680: PUSH
23681: LD_EXP 78
23685: PPUSH
23686: LD_VAR 0 1
23690: PPUSH
23691: CALL_OW 321
23695: PUSH
23696: LD_INT 2
23698: EQUAL
23699: ST_TO_ADDR
23700: GO 23802
23702: LD_INT 17
23704: DOUBLE
23705: EQUAL
23706: IFTRUE 23710
23708: GO 23735
23710: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
23711: LD_ADDR_VAR 0 3
23715: PUSH
23716: LD_INT 39
23718: PPUSH
23719: LD_VAR 0 1
23723: PPUSH
23724: CALL_OW 321
23728: PUSH
23729: LD_INT 2
23731: EQUAL
23732: ST_TO_ADDR
23733: GO 23802
23735: LD_INT 18
23737: DOUBLE
23738: EQUAL
23739: IFTRUE 23743
23741: GO 23768
23743: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
23744: LD_ADDR_VAR 0 3
23748: PUSH
23749: LD_INT 40
23751: PPUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 321
23761: PUSH
23762: LD_INT 2
23764: EQUAL
23765: ST_TO_ADDR
23766: GO 23802
23768: LD_INT 27
23770: DOUBLE
23771: EQUAL
23772: IFTRUE 23776
23774: GO 23801
23776: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
23777: LD_ADDR_VAR 0 3
23781: PUSH
23782: LD_INT 35
23784: PPUSH
23785: LD_VAR 0 1
23789: PPUSH
23790: CALL_OW 321
23794: PUSH
23795: LD_INT 2
23797: EQUAL
23798: ST_TO_ADDR
23799: GO 23802
23801: POP
// end ;
23802: LD_VAR 0 3
23806: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
23807: LD_INT 0
23809: PPUSH
23810: PPUSH
23811: PPUSH
23812: PPUSH
23813: PPUSH
23814: PPUSH
23815: PPUSH
23816: PPUSH
23817: PPUSH
23818: PPUSH
23819: PPUSH
// result := false ;
23820: LD_ADDR_VAR 0 6
23824: PUSH
23825: LD_INT 0
23827: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
23828: LD_VAR 0 1
23832: NOT
23833: PUSH
23834: LD_VAR 0 1
23838: PPUSH
23839: CALL_OW 266
23843: PUSH
23844: LD_INT 0
23846: PUSH
23847: LD_INT 1
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: IN
23854: NOT
23855: OR
23856: PUSH
23857: LD_VAR 0 2
23861: NOT
23862: OR
23863: PUSH
23864: LD_VAR 0 5
23868: PUSH
23869: LD_INT 0
23871: PUSH
23872: LD_INT 1
23874: PUSH
23875: LD_INT 2
23877: PUSH
23878: LD_INT 3
23880: PUSH
23881: LD_INT 4
23883: PUSH
23884: LD_INT 5
23886: PUSH
23887: EMPTY
23888: LIST
23889: LIST
23890: LIST
23891: LIST
23892: LIST
23893: LIST
23894: IN
23895: NOT
23896: OR
23897: PUSH
23898: LD_VAR 0 3
23902: PPUSH
23903: LD_VAR 0 4
23907: PPUSH
23908: CALL_OW 488
23912: NOT
23913: OR
23914: IFFALSE 23918
// exit ;
23916: GO 24654
// side := GetSide ( depot ) ;
23918: LD_ADDR_VAR 0 9
23922: PUSH
23923: LD_VAR 0 1
23927: PPUSH
23928: CALL_OW 255
23932: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
23933: LD_VAR 0 9
23937: PPUSH
23938: LD_VAR 0 2
23942: PPUSH
23943: CALL 23427 0 2
23947: NOT
23948: IFFALSE 23952
// exit ;
23950: GO 24654
// pom := GetBase ( depot ) ;
23952: LD_ADDR_VAR 0 10
23956: PUSH
23957: LD_VAR 0 1
23961: PPUSH
23962: CALL_OW 274
23966: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
23967: LD_ADDR_VAR 0 11
23971: PUSH
23972: LD_VAR 0 2
23976: PPUSH
23977: LD_VAR 0 1
23981: PPUSH
23982: CALL_OW 248
23986: PPUSH
23987: CALL_OW 450
23991: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
23992: LD_VAR 0 10
23996: PPUSH
23997: LD_INT 1
23999: PPUSH
24000: CALL_OW 275
24004: PUSH
24005: LD_VAR 0 11
24009: PUSH
24010: LD_INT 1
24012: ARRAY
24013: GREATEREQUAL
24014: PUSH
24015: LD_VAR 0 10
24019: PPUSH
24020: LD_INT 2
24022: PPUSH
24023: CALL_OW 275
24027: PUSH
24028: LD_VAR 0 11
24032: PUSH
24033: LD_INT 2
24035: ARRAY
24036: GREATEREQUAL
24037: AND
24038: PUSH
24039: LD_VAR 0 10
24043: PPUSH
24044: LD_INT 3
24046: PPUSH
24047: CALL_OW 275
24051: PUSH
24052: LD_VAR 0 11
24056: PUSH
24057: LD_INT 3
24059: ARRAY
24060: GREATEREQUAL
24061: AND
24062: NOT
24063: IFFALSE 24067
// exit ;
24065: GO 24654
// if GetBType ( depot ) = b_depot then
24067: LD_VAR 0 1
24071: PPUSH
24072: CALL_OW 266
24076: PUSH
24077: LD_INT 0
24079: EQUAL
24080: IFFALSE 24092
// dist := 28 else
24082: LD_ADDR_VAR 0 14
24086: PUSH
24087: LD_INT 28
24089: ST_TO_ADDR
24090: GO 24100
// dist := 36 ;
24092: LD_ADDR_VAR 0 14
24096: PUSH
24097: LD_INT 36
24099: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24100: LD_VAR 0 1
24104: PPUSH
24105: LD_VAR 0 3
24109: PPUSH
24110: LD_VAR 0 4
24114: PPUSH
24115: CALL_OW 297
24119: PUSH
24120: LD_VAR 0 14
24124: GREATER
24125: IFFALSE 24129
// exit ;
24127: GO 24654
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24129: LD_ADDR_VAR 0 12
24133: PUSH
24134: LD_VAR 0 2
24138: PPUSH
24139: LD_VAR 0 3
24143: PPUSH
24144: LD_VAR 0 4
24148: PPUSH
24149: LD_VAR 0 5
24153: PPUSH
24154: LD_VAR 0 1
24158: PPUSH
24159: CALL_OW 248
24163: PPUSH
24164: LD_INT 0
24166: PPUSH
24167: CALL 24659 0 6
24171: ST_TO_ADDR
// if not hexes then
24172: LD_VAR 0 12
24176: NOT
24177: IFFALSE 24181
// exit ;
24179: GO 24654
// hex := GetHexInfo ( x , y ) ;
24181: LD_ADDR_VAR 0 15
24185: PUSH
24186: LD_VAR 0 3
24190: PPUSH
24191: LD_VAR 0 4
24195: PPUSH
24196: CALL_OW 546
24200: ST_TO_ADDR
// if hex [ 1 ] then
24201: LD_VAR 0 15
24205: PUSH
24206: LD_INT 1
24208: ARRAY
24209: IFFALSE 24213
// exit ;
24211: GO 24654
// height := hex [ 2 ] ;
24213: LD_ADDR_VAR 0 13
24217: PUSH
24218: LD_VAR 0 15
24222: PUSH
24223: LD_INT 2
24225: ARRAY
24226: ST_TO_ADDR
// for i = 1 to hexes do
24227: LD_ADDR_VAR 0 7
24231: PUSH
24232: DOUBLE
24233: LD_INT 1
24235: DEC
24236: ST_TO_ADDR
24237: LD_VAR 0 12
24241: PUSH
24242: FOR_TO
24243: IFFALSE 24573
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24245: LD_VAR 0 12
24249: PUSH
24250: LD_VAR 0 7
24254: ARRAY
24255: PUSH
24256: LD_INT 1
24258: ARRAY
24259: PPUSH
24260: LD_VAR 0 12
24264: PUSH
24265: LD_VAR 0 7
24269: ARRAY
24270: PUSH
24271: LD_INT 2
24273: ARRAY
24274: PPUSH
24275: CALL_OW 488
24279: NOT
24280: PUSH
24281: LD_VAR 0 12
24285: PUSH
24286: LD_VAR 0 7
24290: ARRAY
24291: PUSH
24292: LD_INT 1
24294: ARRAY
24295: PPUSH
24296: LD_VAR 0 12
24300: PUSH
24301: LD_VAR 0 7
24305: ARRAY
24306: PUSH
24307: LD_INT 2
24309: ARRAY
24310: PPUSH
24311: CALL_OW 428
24315: PUSH
24316: LD_INT 0
24318: GREATER
24319: OR
24320: PUSH
24321: LD_VAR 0 12
24325: PUSH
24326: LD_VAR 0 7
24330: ARRAY
24331: PUSH
24332: LD_INT 1
24334: ARRAY
24335: PPUSH
24336: LD_VAR 0 12
24340: PUSH
24341: LD_VAR 0 7
24345: ARRAY
24346: PUSH
24347: LD_INT 2
24349: ARRAY
24350: PPUSH
24351: CALL_OW 351
24355: OR
24356: IFFALSE 24362
// exit ;
24358: POP
24359: POP
24360: GO 24654
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24362: LD_ADDR_VAR 0 8
24366: PUSH
24367: LD_VAR 0 12
24371: PUSH
24372: LD_VAR 0 7
24376: ARRAY
24377: PUSH
24378: LD_INT 1
24380: ARRAY
24381: PPUSH
24382: LD_VAR 0 12
24386: PUSH
24387: LD_VAR 0 7
24391: ARRAY
24392: PUSH
24393: LD_INT 2
24395: ARRAY
24396: PPUSH
24397: CALL_OW 546
24401: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24402: LD_VAR 0 8
24406: PUSH
24407: LD_INT 1
24409: ARRAY
24410: PUSH
24411: LD_VAR 0 8
24415: PUSH
24416: LD_INT 2
24418: ARRAY
24419: PUSH
24420: LD_VAR 0 13
24424: PUSH
24425: LD_INT 2
24427: PLUS
24428: GREATER
24429: OR
24430: PUSH
24431: LD_VAR 0 8
24435: PUSH
24436: LD_INT 2
24438: ARRAY
24439: PUSH
24440: LD_VAR 0 13
24444: PUSH
24445: LD_INT 2
24447: MINUS
24448: LESS
24449: OR
24450: PUSH
24451: LD_VAR 0 8
24455: PUSH
24456: LD_INT 3
24458: ARRAY
24459: PUSH
24460: LD_INT 0
24462: PUSH
24463: LD_INT 8
24465: PUSH
24466: LD_INT 9
24468: PUSH
24469: LD_INT 10
24471: PUSH
24472: LD_INT 11
24474: PUSH
24475: LD_INT 12
24477: PUSH
24478: LD_INT 13
24480: PUSH
24481: LD_INT 16
24483: PUSH
24484: LD_INT 17
24486: PUSH
24487: LD_INT 18
24489: PUSH
24490: LD_INT 19
24492: PUSH
24493: LD_INT 20
24495: PUSH
24496: LD_INT 21
24498: PUSH
24499: EMPTY
24500: LIST
24501: LIST
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: IN
24514: NOT
24515: OR
24516: PUSH
24517: LD_VAR 0 8
24521: PUSH
24522: LD_INT 5
24524: ARRAY
24525: NOT
24526: OR
24527: PUSH
24528: LD_VAR 0 8
24532: PUSH
24533: LD_INT 6
24535: ARRAY
24536: PUSH
24537: LD_INT 1
24539: PUSH
24540: LD_INT 2
24542: PUSH
24543: LD_INT 7
24545: PUSH
24546: LD_INT 9
24548: PUSH
24549: LD_INT 10
24551: PUSH
24552: LD_INT 11
24554: PUSH
24555: EMPTY
24556: LIST
24557: LIST
24558: LIST
24559: LIST
24560: LIST
24561: LIST
24562: IN
24563: NOT
24564: OR
24565: IFFALSE 24571
// exit ;
24567: POP
24568: POP
24569: GO 24654
// end ;
24571: GO 24242
24573: POP
24574: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24575: LD_VAR 0 9
24579: PPUSH
24580: LD_VAR 0 3
24584: PPUSH
24585: LD_VAR 0 4
24589: PPUSH
24590: LD_INT 20
24592: PPUSH
24593: CALL 16600 0 4
24597: PUSH
24598: LD_INT 4
24600: ARRAY
24601: IFFALSE 24605
// exit ;
24603: GO 24654
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
24605: LD_VAR 0 2
24609: PUSH
24610: LD_INT 29
24612: PUSH
24613: LD_INT 30
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: IN
24620: PUSH
24621: LD_VAR 0 3
24625: PPUSH
24626: LD_VAR 0 4
24630: PPUSH
24631: LD_VAR 0 9
24635: PPUSH
24636: CALL_OW 440
24640: NOT
24641: AND
24642: IFFALSE 24646
// exit ;
24644: GO 24654
// result := true ;
24646: LD_ADDR_VAR 0 6
24650: PUSH
24651: LD_INT 1
24653: ST_TO_ADDR
// end ;
24654: LD_VAR 0 6
24658: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
24659: LD_INT 0
24661: PPUSH
24662: PPUSH
24663: PPUSH
24664: PPUSH
24665: PPUSH
24666: PPUSH
24667: PPUSH
24668: PPUSH
24669: PPUSH
24670: PPUSH
24671: PPUSH
24672: PPUSH
24673: PPUSH
24674: PPUSH
24675: PPUSH
24676: PPUSH
24677: PPUSH
24678: PPUSH
24679: PPUSH
24680: PPUSH
24681: PPUSH
24682: PPUSH
24683: PPUSH
24684: PPUSH
24685: PPUSH
24686: PPUSH
24687: PPUSH
24688: PPUSH
24689: PPUSH
24690: PPUSH
24691: PPUSH
24692: PPUSH
24693: PPUSH
24694: PPUSH
24695: PPUSH
24696: PPUSH
24697: PPUSH
24698: PPUSH
24699: PPUSH
24700: PPUSH
24701: PPUSH
24702: PPUSH
24703: PPUSH
24704: PPUSH
24705: PPUSH
24706: PPUSH
24707: PPUSH
24708: PPUSH
24709: PPUSH
24710: PPUSH
24711: PPUSH
24712: PPUSH
24713: PPUSH
24714: PPUSH
24715: PPUSH
24716: PPUSH
24717: PPUSH
24718: PPUSH
// result = [ ] ;
24719: LD_ADDR_VAR 0 7
24723: PUSH
24724: EMPTY
24725: ST_TO_ADDR
// temp_list = [ ] ;
24726: LD_ADDR_VAR 0 9
24730: PUSH
24731: EMPTY
24732: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
24733: LD_VAR 0 4
24737: PUSH
24738: LD_INT 0
24740: PUSH
24741: LD_INT 1
24743: PUSH
24744: LD_INT 2
24746: PUSH
24747: LD_INT 3
24749: PUSH
24750: LD_INT 4
24752: PUSH
24753: LD_INT 5
24755: PUSH
24756: EMPTY
24757: LIST
24758: LIST
24759: LIST
24760: LIST
24761: LIST
24762: LIST
24763: IN
24764: NOT
24765: PUSH
24766: LD_VAR 0 1
24770: PUSH
24771: LD_INT 0
24773: PUSH
24774: LD_INT 1
24776: PUSH
24777: EMPTY
24778: LIST
24779: LIST
24780: IN
24781: PUSH
24782: LD_VAR 0 5
24786: PUSH
24787: LD_INT 1
24789: PUSH
24790: LD_INT 2
24792: PUSH
24793: LD_INT 3
24795: PUSH
24796: EMPTY
24797: LIST
24798: LIST
24799: LIST
24800: IN
24801: NOT
24802: AND
24803: OR
24804: IFFALSE 24808
// exit ;
24806: GO 43199
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
24808: LD_VAR 0 1
24812: PUSH
24813: LD_INT 6
24815: PUSH
24816: LD_INT 7
24818: PUSH
24819: LD_INT 8
24821: PUSH
24822: LD_INT 13
24824: PUSH
24825: LD_INT 12
24827: PUSH
24828: LD_INT 15
24830: PUSH
24831: LD_INT 11
24833: PUSH
24834: LD_INT 14
24836: PUSH
24837: LD_INT 10
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: LIST
24844: LIST
24845: LIST
24846: LIST
24847: LIST
24848: LIST
24849: LIST
24850: IN
24851: IFFALSE 24861
// btype = b_lab ;
24853: LD_ADDR_VAR 0 1
24857: PUSH
24858: LD_INT 6
24860: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
24861: LD_VAR 0 6
24865: PUSH
24866: LD_INT 0
24868: PUSH
24869: LD_INT 1
24871: PUSH
24872: LD_INT 2
24874: PUSH
24875: EMPTY
24876: LIST
24877: LIST
24878: LIST
24879: IN
24880: NOT
24881: PUSH
24882: LD_VAR 0 1
24886: PUSH
24887: LD_INT 0
24889: PUSH
24890: LD_INT 1
24892: PUSH
24893: LD_INT 2
24895: PUSH
24896: LD_INT 3
24898: PUSH
24899: LD_INT 6
24901: PUSH
24902: LD_INT 36
24904: PUSH
24905: LD_INT 4
24907: PUSH
24908: LD_INT 5
24910: PUSH
24911: LD_INT 31
24913: PUSH
24914: LD_INT 32
24916: PUSH
24917: LD_INT 33
24919: PUSH
24920: EMPTY
24921: LIST
24922: LIST
24923: LIST
24924: LIST
24925: LIST
24926: LIST
24927: LIST
24928: LIST
24929: LIST
24930: LIST
24931: LIST
24932: IN
24933: NOT
24934: PUSH
24935: LD_VAR 0 6
24939: PUSH
24940: LD_INT 1
24942: EQUAL
24943: AND
24944: OR
24945: PUSH
24946: LD_VAR 0 1
24950: PUSH
24951: LD_INT 2
24953: PUSH
24954: LD_INT 3
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: IN
24961: NOT
24962: PUSH
24963: LD_VAR 0 6
24967: PUSH
24968: LD_INT 2
24970: EQUAL
24971: AND
24972: OR
24973: IFFALSE 24983
// mode = 0 ;
24975: LD_ADDR_VAR 0 6
24979: PUSH
24980: LD_INT 0
24982: ST_TO_ADDR
// case mode of 0 :
24983: LD_VAR 0 6
24987: PUSH
24988: LD_INT 0
24990: DOUBLE
24991: EQUAL
24992: IFTRUE 24996
24994: GO 36449
24996: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
24997: LD_ADDR_VAR 0 11
25001: PUSH
25002: LD_INT 0
25004: PUSH
25005: LD_INT 0
25007: PUSH
25008: EMPTY
25009: LIST
25010: LIST
25011: PUSH
25012: LD_INT 0
25014: PUSH
25015: LD_INT 1
25017: NEG
25018: PUSH
25019: EMPTY
25020: LIST
25021: LIST
25022: PUSH
25023: LD_INT 1
25025: PUSH
25026: LD_INT 0
25028: PUSH
25029: EMPTY
25030: LIST
25031: LIST
25032: PUSH
25033: LD_INT 1
25035: PUSH
25036: LD_INT 1
25038: PUSH
25039: EMPTY
25040: LIST
25041: LIST
25042: PUSH
25043: LD_INT 0
25045: PUSH
25046: LD_INT 1
25048: PUSH
25049: EMPTY
25050: LIST
25051: LIST
25052: PUSH
25053: LD_INT 1
25055: NEG
25056: PUSH
25057: LD_INT 0
25059: PUSH
25060: EMPTY
25061: LIST
25062: LIST
25063: PUSH
25064: LD_INT 1
25066: NEG
25067: PUSH
25068: LD_INT 1
25070: NEG
25071: PUSH
25072: EMPTY
25073: LIST
25074: LIST
25075: PUSH
25076: LD_INT 1
25078: NEG
25079: PUSH
25080: LD_INT 2
25082: NEG
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: PUSH
25088: LD_INT 0
25090: PUSH
25091: LD_INT 2
25093: NEG
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: PUSH
25099: LD_INT 1
25101: PUSH
25102: LD_INT 1
25104: NEG
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: PUSH
25110: LD_INT 1
25112: PUSH
25113: LD_INT 2
25115: PUSH
25116: EMPTY
25117: LIST
25118: LIST
25119: PUSH
25120: LD_INT 0
25122: PUSH
25123: LD_INT 2
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: PUSH
25130: LD_INT 1
25132: NEG
25133: PUSH
25134: LD_INT 1
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: PUSH
25141: LD_INT 1
25143: PUSH
25144: LD_INT 3
25146: PUSH
25147: EMPTY
25148: LIST
25149: LIST
25150: PUSH
25151: LD_INT 0
25153: PUSH
25154: LD_INT 3
25156: PUSH
25157: EMPTY
25158: LIST
25159: LIST
25160: PUSH
25161: LD_INT 1
25163: NEG
25164: PUSH
25165: LD_INT 2
25167: PUSH
25168: EMPTY
25169: LIST
25170: LIST
25171: PUSH
25172: EMPTY
25173: LIST
25174: LIST
25175: LIST
25176: LIST
25177: LIST
25178: LIST
25179: LIST
25180: LIST
25181: LIST
25182: LIST
25183: LIST
25184: LIST
25185: LIST
25186: LIST
25187: LIST
25188: LIST
25189: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25190: LD_ADDR_VAR 0 12
25194: PUSH
25195: LD_INT 0
25197: PUSH
25198: LD_INT 0
25200: PUSH
25201: EMPTY
25202: LIST
25203: LIST
25204: PUSH
25205: LD_INT 0
25207: PUSH
25208: LD_INT 1
25210: NEG
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: PUSH
25216: LD_INT 1
25218: PUSH
25219: LD_INT 0
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: LD_INT 1
25228: PUSH
25229: LD_INT 1
25231: PUSH
25232: EMPTY
25233: LIST
25234: LIST
25235: PUSH
25236: LD_INT 0
25238: PUSH
25239: LD_INT 1
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: PUSH
25246: LD_INT 1
25248: NEG
25249: PUSH
25250: LD_INT 0
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PUSH
25257: LD_INT 1
25259: NEG
25260: PUSH
25261: LD_INT 1
25263: NEG
25264: PUSH
25265: EMPTY
25266: LIST
25267: LIST
25268: PUSH
25269: LD_INT 1
25271: PUSH
25272: LD_INT 1
25274: NEG
25275: PUSH
25276: EMPTY
25277: LIST
25278: LIST
25279: PUSH
25280: LD_INT 2
25282: PUSH
25283: LD_INT 0
25285: PUSH
25286: EMPTY
25287: LIST
25288: LIST
25289: PUSH
25290: LD_INT 2
25292: PUSH
25293: LD_INT 1
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 1
25302: NEG
25303: PUSH
25304: LD_INT 1
25306: PUSH
25307: EMPTY
25308: LIST
25309: LIST
25310: PUSH
25311: LD_INT 2
25313: NEG
25314: PUSH
25315: LD_INT 0
25317: PUSH
25318: EMPTY
25319: LIST
25320: LIST
25321: PUSH
25322: LD_INT 2
25324: NEG
25325: PUSH
25326: LD_INT 1
25328: NEG
25329: PUSH
25330: EMPTY
25331: LIST
25332: LIST
25333: PUSH
25334: LD_INT 2
25336: NEG
25337: PUSH
25338: LD_INT 1
25340: PUSH
25341: EMPTY
25342: LIST
25343: LIST
25344: PUSH
25345: LD_INT 3
25347: NEG
25348: PUSH
25349: LD_INT 0
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: PUSH
25356: LD_INT 3
25358: NEG
25359: PUSH
25360: LD_INT 1
25362: NEG
25363: PUSH
25364: EMPTY
25365: LIST
25366: LIST
25367: PUSH
25368: EMPTY
25369: LIST
25370: LIST
25371: LIST
25372: LIST
25373: LIST
25374: LIST
25375: LIST
25376: LIST
25377: LIST
25378: LIST
25379: LIST
25380: LIST
25381: LIST
25382: LIST
25383: LIST
25384: LIST
25385: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25386: LD_ADDR_VAR 0 13
25390: PUSH
25391: LD_INT 0
25393: PUSH
25394: LD_INT 0
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: PUSH
25401: LD_INT 0
25403: PUSH
25404: LD_INT 1
25406: NEG
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 1
25414: PUSH
25415: LD_INT 0
25417: PUSH
25418: EMPTY
25419: LIST
25420: LIST
25421: PUSH
25422: LD_INT 1
25424: PUSH
25425: LD_INT 1
25427: PUSH
25428: EMPTY
25429: LIST
25430: LIST
25431: PUSH
25432: LD_INT 0
25434: PUSH
25435: LD_INT 1
25437: PUSH
25438: EMPTY
25439: LIST
25440: LIST
25441: PUSH
25442: LD_INT 1
25444: NEG
25445: PUSH
25446: LD_INT 0
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PUSH
25453: LD_INT 1
25455: NEG
25456: PUSH
25457: LD_INT 1
25459: NEG
25460: PUSH
25461: EMPTY
25462: LIST
25463: LIST
25464: PUSH
25465: LD_INT 1
25467: NEG
25468: PUSH
25469: LD_INT 2
25471: NEG
25472: PUSH
25473: EMPTY
25474: LIST
25475: LIST
25476: PUSH
25477: LD_INT 2
25479: PUSH
25480: LD_INT 1
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: PUSH
25487: LD_INT 2
25489: PUSH
25490: LD_INT 2
25492: PUSH
25493: EMPTY
25494: LIST
25495: LIST
25496: PUSH
25497: LD_INT 1
25499: PUSH
25500: LD_INT 2
25502: PUSH
25503: EMPTY
25504: LIST
25505: LIST
25506: PUSH
25507: LD_INT 2
25509: NEG
25510: PUSH
25511: LD_INT 1
25513: NEG
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: PUSH
25519: LD_INT 2
25521: NEG
25522: PUSH
25523: LD_INT 2
25525: NEG
25526: PUSH
25527: EMPTY
25528: LIST
25529: LIST
25530: PUSH
25531: LD_INT 2
25533: NEG
25534: PUSH
25535: LD_INT 3
25537: NEG
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: LD_INT 3
25545: NEG
25546: PUSH
25547: LD_INT 2
25549: NEG
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: PUSH
25555: LD_INT 3
25557: NEG
25558: PUSH
25559: LD_INT 3
25561: NEG
25562: PUSH
25563: EMPTY
25564: LIST
25565: LIST
25566: PUSH
25567: EMPTY
25568: LIST
25569: LIST
25570: LIST
25571: LIST
25572: LIST
25573: LIST
25574: LIST
25575: LIST
25576: LIST
25577: LIST
25578: LIST
25579: LIST
25580: LIST
25581: LIST
25582: LIST
25583: LIST
25584: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25585: LD_ADDR_VAR 0 14
25589: PUSH
25590: LD_INT 0
25592: PUSH
25593: LD_INT 0
25595: PUSH
25596: EMPTY
25597: LIST
25598: LIST
25599: PUSH
25600: LD_INT 0
25602: PUSH
25603: LD_INT 1
25605: NEG
25606: PUSH
25607: EMPTY
25608: LIST
25609: LIST
25610: PUSH
25611: LD_INT 1
25613: PUSH
25614: LD_INT 0
25616: PUSH
25617: EMPTY
25618: LIST
25619: LIST
25620: PUSH
25621: LD_INT 1
25623: PUSH
25624: LD_INT 1
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 0
25633: PUSH
25634: LD_INT 1
25636: PUSH
25637: EMPTY
25638: LIST
25639: LIST
25640: PUSH
25641: LD_INT 1
25643: NEG
25644: PUSH
25645: LD_INT 0
25647: PUSH
25648: EMPTY
25649: LIST
25650: LIST
25651: PUSH
25652: LD_INT 1
25654: NEG
25655: PUSH
25656: LD_INT 1
25658: NEG
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: PUSH
25664: LD_INT 1
25666: NEG
25667: PUSH
25668: LD_INT 2
25670: NEG
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 0
25678: PUSH
25679: LD_INT 2
25681: NEG
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: LD_INT 1
25689: PUSH
25690: LD_INT 1
25692: NEG
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 1
25700: PUSH
25701: LD_INT 2
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 0
25710: PUSH
25711: LD_INT 2
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: LD_INT 1
25720: NEG
25721: PUSH
25722: LD_INT 1
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: LD_INT 1
25731: NEG
25732: PUSH
25733: LD_INT 3
25735: NEG
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: LD_INT 0
25743: PUSH
25744: LD_INT 3
25746: NEG
25747: PUSH
25748: EMPTY
25749: LIST
25750: LIST
25751: PUSH
25752: LD_INT 1
25754: PUSH
25755: LD_INT 2
25757: NEG
25758: PUSH
25759: EMPTY
25760: LIST
25761: LIST
25762: PUSH
25763: EMPTY
25764: LIST
25765: LIST
25766: LIST
25767: LIST
25768: LIST
25769: LIST
25770: LIST
25771: LIST
25772: LIST
25773: LIST
25774: LIST
25775: LIST
25776: LIST
25777: LIST
25778: LIST
25779: LIST
25780: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
25781: LD_ADDR_VAR 0 15
25785: PUSH
25786: LD_INT 0
25788: PUSH
25789: LD_INT 0
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 0
25798: PUSH
25799: LD_INT 1
25801: NEG
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: PUSH
25807: LD_INT 1
25809: PUSH
25810: LD_INT 0
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 1
25819: PUSH
25820: LD_INT 1
25822: PUSH
25823: EMPTY
25824: LIST
25825: LIST
25826: PUSH
25827: LD_INT 0
25829: PUSH
25830: LD_INT 1
25832: PUSH
25833: EMPTY
25834: LIST
25835: LIST
25836: PUSH
25837: LD_INT 1
25839: NEG
25840: PUSH
25841: LD_INT 0
25843: PUSH
25844: EMPTY
25845: LIST
25846: LIST
25847: PUSH
25848: LD_INT 1
25850: NEG
25851: PUSH
25852: LD_INT 1
25854: NEG
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 1
25862: PUSH
25863: LD_INT 1
25865: NEG
25866: PUSH
25867: EMPTY
25868: LIST
25869: LIST
25870: PUSH
25871: LD_INT 2
25873: PUSH
25874: LD_INT 0
25876: PUSH
25877: EMPTY
25878: LIST
25879: LIST
25880: PUSH
25881: LD_INT 2
25883: PUSH
25884: LD_INT 1
25886: PUSH
25887: EMPTY
25888: LIST
25889: LIST
25890: PUSH
25891: LD_INT 1
25893: NEG
25894: PUSH
25895: LD_INT 1
25897: PUSH
25898: EMPTY
25899: LIST
25900: LIST
25901: PUSH
25902: LD_INT 2
25904: NEG
25905: PUSH
25906: LD_INT 0
25908: PUSH
25909: EMPTY
25910: LIST
25911: LIST
25912: PUSH
25913: LD_INT 2
25915: NEG
25916: PUSH
25917: LD_INT 1
25919: NEG
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: PUSH
25925: LD_INT 2
25927: PUSH
25928: LD_INT 1
25930: NEG
25931: PUSH
25932: EMPTY
25933: LIST
25934: LIST
25935: PUSH
25936: LD_INT 3
25938: PUSH
25939: LD_INT 0
25941: PUSH
25942: EMPTY
25943: LIST
25944: LIST
25945: PUSH
25946: LD_INT 3
25948: PUSH
25949: LD_INT 1
25951: PUSH
25952: EMPTY
25953: LIST
25954: LIST
25955: PUSH
25956: EMPTY
25957: LIST
25958: LIST
25959: LIST
25960: LIST
25961: LIST
25962: LIST
25963: LIST
25964: LIST
25965: LIST
25966: LIST
25967: LIST
25968: LIST
25969: LIST
25970: LIST
25971: LIST
25972: LIST
25973: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
25974: LD_ADDR_VAR 0 16
25978: PUSH
25979: LD_INT 0
25981: PUSH
25982: LD_INT 0
25984: PUSH
25985: EMPTY
25986: LIST
25987: LIST
25988: PUSH
25989: LD_INT 0
25991: PUSH
25992: LD_INT 1
25994: NEG
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 1
26002: PUSH
26003: LD_INT 0
26005: PUSH
26006: EMPTY
26007: LIST
26008: LIST
26009: PUSH
26010: LD_INT 1
26012: PUSH
26013: LD_INT 1
26015: PUSH
26016: EMPTY
26017: LIST
26018: LIST
26019: PUSH
26020: LD_INT 0
26022: PUSH
26023: LD_INT 1
26025: PUSH
26026: EMPTY
26027: LIST
26028: LIST
26029: PUSH
26030: LD_INT 1
26032: NEG
26033: PUSH
26034: LD_INT 0
26036: PUSH
26037: EMPTY
26038: LIST
26039: LIST
26040: PUSH
26041: LD_INT 1
26043: NEG
26044: PUSH
26045: LD_INT 1
26047: NEG
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: PUSH
26053: LD_INT 1
26055: NEG
26056: PUSH
26057: LD_INT 2
26059: NEG
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: PUSH
26065: LD_INT 2
26067: PUSH
26068: LD_INT 1
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 2
26077: PUSH
26078: LD_INT 2
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 1
26087: PUSH
26088: LD_INT 2
26090: PUSH
26091: EMPTY
26092: LIST
26093: LIST
26094: PUSH
26095: LD_INT 2
26097: NEG
26098: PUSH
26099: LD_INT 1
26101: NEG
26102: PUSH
26103: EMPTY
26104: LIST
26105: LIST
26106: PUSH
26107: LD_INT 2
26109: NEG
26110: PUSH
26111: LD_INT 2
26113: NEG
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: PUSH
26119: LD_INT 3
26121: PUSH
26122: LD_INT 2
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 3
26131: PUSH
26132: LD_INT 3
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: PUSH
26139: LD_INT 2
26141: PUSH
26142: LD_INT 3
26144: PUSH
26145: EMPTY
26146: LIST
26147: LIST
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: LIST
26153: LIST
26154: LIST
26155: LIST
26156: LIST
26157: LIST
26158: LIST
26159: LIST
26160: LIST
26161: LIST
26162: LIST
26163: LIST
26164: LIST
26165: LIST
26166: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26167: LD_ADDR_VAR 0 17
26171: PUSH
26172: LD_INT 0
26174: PUSH
26175: LD_INT 0
26177: PUSH
26178: EMPTY
26179: LIST
26180: LIST
26181: PUSH
26182: LD_INT 0
26184: PUSH
26185: LD_INT 1
26187: NEG
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: LD_INT 1
26195: PUSH
26196: LD_INT 0
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: PUSH
26203: LD_INT 1
26205: PUSH
26206: LD_INT 1
26208: PUSH
26209: EMPTY
26210: LIST
26211: LIST
26212: PUSH
26213: LD_INT 0
26215: PUSH
26216: LD_INT 1
26218: PUSH
26219: EMPTY
26220: LIST
26221: LIST
26222: PUSH
26223: LD_INT 1
26225: NEG
26226: PUSH
26227: LD_INT 0
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 1
26236: NEG
26237: PUSH
26238: LD_INT 1
26240: NEG
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: PUSH
26246: LD_INT 1
26248: NEG
26249: PUSH
26250: LD_INT 2
26252: NEG
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: LD_INT 0
26260: PUSH
26261: LD_INT 2
26263: NEG
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PUSH
26269: LD_INT 1
26271: PUSH
26272: LD_INT 1
26274: NEG
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: LD_INT 2
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: PUSH
26290: LD_INT 2
26292: PUSH
26293: LD_INT 1
26295: PUSH
26296: EMPTY
26297: LIST
26298: LIST
26299: PUSH
26300: LD_INT 2
26302: PUSH
26303: LD_INT 2
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PUSH
26310: LD_INT 1
26312: PUSH
26313: LD_INT 2
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 0
26322: PUSH
26323: LD_INT 2
26325: PUSH
26326: EMPTY
26327: LIST
26328: LIST
26329: PUSH
26330: LD_INT 1
26332: NEG
26333: PUSH
26334: LD_INT 1
26336: PUSH
26337: EMPTY
26338: LIST
26339: LIST
26340: PUSH
26341: LD_INT 2
26343: NEG
26344: PUSH
26345: LD_INT 0
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: PUSH
26352: LD_INT 2
26354: NEG
26355: PUSH
26356: LD_INT 1
26358: NEG
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 2
26366: NEG
26367: PUSH
26368: LD_INT 2
26370: NEG
26371: PUSH
26372: EMPTY
26373: LIST
26374: LIST
26375: PUSH
26376: EMPTY
26377: LIST
26378: LIST
26379: LIST
26380: LIST
26381: LIST
26382: LIST
26383: LIST
26384: LIST
26385: LIST
26386: LIST
26387: LIST
26388: LIST
26389: LIST
26390: LIST
26391: LIST
26392: LIST
26393: LIST
26394: LIST
26395: LIST
26396: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26397: LD_ADDR_VAR 0 18
26401: PUSH
26402: LD_INT 0
26404: PUSH
26405: LD_INT 0
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: PUSH
26412: LD_INT 0
26414: PUSH
26415: LD_INT 1
26417: NEG
26418: PUSH
26419: EMPTY
26420: LIST
26421: LIST
26422: PUSH
26423: LD_INT 1
26425: PUSH
26426: LD_INT 0
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: PUSH
26433: LD_INT 1
26435: PUSH
26436: LD_INT 1
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PUSH
26443: LD_INT 0
26445: PUSH
26446: LD_INT 1
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: PUSH
26453: LD_INT 1
26455: NEG
26456: PUSH
26457: LD_INT 0
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 1
26466: NEG
26467: PUSH
26468: LD_INT 1
26470: NEG
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PUSH
26476: LD_INT 1
26478: NEG
26479: PUSH
26480: LD_INT 2
26482: NEG
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 0
26490: PUSH
26491: LD_INT 2
26493: NEG
26494: PUSH
26495: EMPTY
26496: LIST
26497: LIST
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: LD_INT 1
26504: NEG
26505: PUSH
26506: EMPTY
26507: LIST
26508: LIST
26509: PUSH
26510: LD_INT 2
26512: PUSH
26513: LD_INT 0
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: LD_INT 2
26522: PUSH
26523: LD_INT 1
26525: PUSH
26526: EMPTY
26527: LIST
26528: LIST
26529: PUSH
26530: LD_INT 2
26532: PUSH
26533: LD_INT 2
26535: PUSH
26536: EMPTY
26537: LIST
26538: LIST
26539: PUSH
26540: LD_INT 1
26542: PUSH
26543: LD_INT 2
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: LD_INT 0
26552: PUSH
26553: LD_INT 2
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: LD_INT 1
26562: NEG
26563: PUSH
26564: LD_INT 1
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 2
26573: NEG
26574: PUSH
26575: LD_INT 0
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: LD_INT 2
26584: NEG
26585: PUSH
26586: LD_INT 1
26588: NEG
26589: PUSH
26590: EMPTY
26591: LIST
26592: LIST
26593: PUSH
26594: LD_INT 2
26596: NEG
26597: PUSH
26598: LD_INT 2
26600: NEG
26601: PUSH
26602: EMPTY
26603: LIST
26604: LIST
26605: PUSH
26606: EMPTY
26607: LIST
26608: LIST
26609: LIST
26610: LIST
26611: LIST
26612: LIST
26613: LIST
26614: LIST
26615: LIST
26616: LIST
26617: LIST
26618: LIST
26619: LIST
26620: LIST
26621: LIST
26622: LIST
26623: LIST
26624: LIST
26625: LIST
26626: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26627: LD_ADDR_VAR 0 19
26631: PUSH
26632: LD_INT 0
26634: PUSH
26635: LD_INT 0
26637: PUSH
26638: EMPTY
26639: LIST
26640: LIST
26641: PUSH
26642: LD_INT 0
26644: PUSH
26645: LD_INT 1
26647: NEG
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: LD_INT 1
26655: PUSH
26656: LD_INT 0
26658: PUSH
26659: EMPTY
26660: LIST
26661: LIST
26662: PUSH
26663: LD_INT 1
26665: PUSH
26666: LD_INT 1
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: PUSH
26673: LD_INT 0
26675: PUSH
26676: LD_INT 1
26678: PUSH
26679: EMPTY
26680: LIST
26681: LIST
26682: PUSH
26683: LD_INT 1
26685: NEG
26686: PUSH
26687: LD_INT 0
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: PUSH
26694: LD_INT 1
26696: NEG
26697: PUSH
26698: LD_INT 1
26700: NEG
26701: PUSH
26702: EMPTY
26703: LIST
26704: LIST
26705: PUSH
26706: LD_INT 1
26708: NEG
26709: PUSH
26710: LD_INT 2
26712: NEG
26713: PUSH
26714: EMPTY
26715: LIST
26716: LIST
26717: PUSH
26718: LD_INT 0
26720: PUSH
26721: LD_INT 2
26723: NEG
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: PUSH
26729: LD_INT 1
26731: PUSH
26732: LD_INT 1
26734: NEG
26735: PUSH
26736: EMPTY
26737: LIST
26738: LIST
26739: PUSH
26740: LD_INT 2
26742: PUSH
26743: LD_INT 0
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PUSH
26750: LD_INT 2
26752: PUSH
26753: LD_INT 1
26755: PUSH
26756: EMPTY
26757: LIST
26758: LIST
26759: PUSH
26760: LD_INT 2
26762: PUSH
26763: LD_INT 2
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PUSH
26770: LD_INT 1
26772: PUSH
26773: LD_INT 2
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: PUSH
26780: LD_INT 0
26782: PUSH
26783: LD_INT 2
26785: PUSH
26786: EMPTY
26787: LIST
26788: LIST
26789: PUSH
26790: LD_INT 1
26792: NEG
26793: PUSH
26794: LD_INT 1
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: PUSH
26801: LD_INT 2
26803: NEG
26804: PUSH
26805: LD_INT 0
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: LD_INT 2
26814: NEG
26815: PUSH
26816: LD_INT 1
26818: NEG
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: LD_INT 2
26826: NEG
26827: PUSH
26828: LD_INT 2
26830: NEG
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: LIST
26840: LIST
26841: LIST
26842: LIST
26843: LIST
26844: LIST
26845: LIST
26846: LIST
26847: LIST
26848: LIST
26849: LIST
26850: LIST
26851: LIST
26852: LIST
26853: LIST
26854: LIST
26855: LIST
26856: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26857: LD_ADDR_VAR 0 20
26861: PUSH
26862: LD_INT 0
26864: PUSH
26865: LD_INT 0
26867: PUSH
26868: EMPTY
26869: LIST
26870: LIST
26871: PUSH
26872: LD_INT 0
26874: PUSH
26875: LD_INT 1
26877: NEG
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 1
26885: PUSH
26886: LD_INT 0
26888: PUSH
26889: EMPTY
26890: LIST
26891: LIST
26892: PUSH
26893: LD_INT 1
26895: PUSH
26896: LD_INT 1
26898: PUSH
26899: EMPTY
26900: LIST
26901: LIST
26902: PUSH
26903: LD_INT 0
26905: PUSH
26906: LD_INT 1
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: LD_INT 1
26915: NEG
26916: PUSH
26917: LD_INT 0
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 1
26926: NEG
26927: PUSH
26928: LD_INT 1
26930: NEG
26931: PUSH
26932: EMPTY
26933: LIST
26934: LIST
26935: PUSH
26936: LD_INT 1
26938: NEG
26939: PUSH
26940: LD_INT 2
26942: NEG
26943: PUSH
26944: EMPTY
26945: LIST
26946: LIST
26947: PUSH
26948: LD_INT 0
26950: PUSH
26951: LD_INT 2
26953: NEG
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 1
26961: PUSH
26962: LD_INT 1
26964: NEG
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: PUSH
26970: LD_INT 2
26972: PUSH
26973: LD_INT 0
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PUSH
26980: LD_INT 2
26982: PUSH
26983: LD_INT 1
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PUSH
26990: LD_INT 2
26992: PUSH
26993: LD_INT 2
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PUSH
27000: LD_INT 1
27002: PUSH
27003: LD_INT 2
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 0
27012: PUSH
27013: LD_INT 2
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PUSH
27020: LD_INT 1
27022: NEG
27023: PUSH
27024: LD_INT 1
27026: PUSH
27027: EMPTY
27028: LIST
27029: LIST
27030: PUSH
27031: LD_INT 2
27033: NEG
27034: PUSH
27035: LD_INT 0
27037: PUSH
27038: EMPTY
27039: LIST
27040: LIST
27041: PUSH
27042: LD_INT 2
27044: NEG
27045: PUSH
27046: LD_INT 1
27048: NEG
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 2
27056: NEG
27057: PUSH
27058: LD_INT 2
27060: NEG
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: LIST
27070: LIST
27071: LIST
27072: LIST
27073: LIST
27074: LIST
27075: LIST
27076: LIST
27077: LIST
27078: LIST
27079: LIST
27080: LIST
27081: LIST
27082: LIST
27083: LIST
27084: LIST
27085: LIST
27086: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27087: LD_ADDR_VAR 0 21
27091: PUSH
27092: LD_INT 0
27094: PUSH
27095: LD_INT 0
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 0
27104: PUSH
27105: LD_INT 1
27107: NEG
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 1
27115: PUSH
27116: LD_INT 0
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PUSH
27123: LD_INT 1
27125: PUSH
27126: LD_INT 1
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PUSH
27133: LD_INT 0
27135: PUSH
27136: LD_INT 1
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: PUSH
27143: LD_INT 1
27145: NEG
27146: PUSH
27147: LD_INT 0
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: PUSH
27154: LD_INT 1
27156: NEG
27157: PUSH
27158: LD_INT 1
27160: NEG
27161: PUSH
27162: EMPTY
27163: LIST
27164: LIST
27165: PUSH
27166: LD_INT 1
27168: NEG
27169: PUSH
27170: LD_INT 2
27172: NEG
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PUSH
27178: LD_INT 0
27180: PUSH
27181: LD_INT 2
27183: NEG
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_INT 1
27191: PUSH
27192: LD_INT 1
27194: NEG
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 2
27202: PUSH
27203: LD_INT 0
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 2
27212: PUSH
27213: LD_INT 1
27215: PUSH
27216: EMPTY
27217: LIST
27218: LIST
27219: PUSH
27220: LD_INT 2
27222: PUSH
27223: LD_INT 2
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PUSH
27230: LD_INT 1
27232: PUSH
27233: LD_INT 2
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: PUSH
27240: LD_INT 0
27242: PUSH
27243: LD_INT 2
27245: PUSH
27246: EMPTY
27247: LIST
27248: LIST
27249: PUSH
27250: LD_INT 1
27252: NEG
27253: PUSH
27254: LD_INT 1
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: PUSH
27261: LD_INT 2
27263: NEG
27264: PUSH
27265: LD_INT 0
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 2
27274: NEG
27275: PUSH
27276: LD_INT 1
27278: NEG
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: PUSH
27284: LD_INT 2
27286: NEG
27287: PUSH
27288: LD_INT 2
27290: NEG
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: LIST
27300: LIST
27301: LIST
27302: LIST
27303: LIST
27304: LIST
27305: LIST
27306: LIST
27307: LIST
27308: LIST
27309: LIST
27310: LIST
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27317: LD_ADDR_VAR 0 22
27321: PUSH
27322: LD_INT 0
27324: PUSH
27325: LD_INT 0
27327: PUSH
27328: EMPTY
27329: LIST
27330: LIST
27331: PUSH
27332: LD_INT 0
27334: PUSH
27335: LD_INT 1
27337: NEG
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: PUSH
27343: LD_INT 1
27345: PUSH
27346: LD_INT 0
27348: PUSH
27349: EMPTY
27350: LIST
27351: LIST
27352: PUSH
27353: LD_INT 1
27355: PUSH
27356: LD_INT 1
27358: PUSH
27359: EMPTY
27360: LIST
27361: LIST
27362: PUSH
27363: LD_INT 0
27365: PUSH
27366: LD_INT 1
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: LD_INT 1
27375: NEG
27376: PUSH
27377: LD_INT 0
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 1
27386: NEG
27387: PUSH
27388: LD_INT 1
27390: NEG
27391: PUSH
27392: EMPTY
27393: LIST
27394: LIST
27395: PUSH
27396: LD_INT 1
27398: NEG
27399: PUSH
27400: LD_INT 2
27402: NEG
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: PUSH
27408: LD_INT 0
27410: PUSH
27411: LD_INT 2
27413: NEG
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 1
27421: PUSH
27422: LD_INT 1
27424: NEG
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: PUSH
27430: LD_INT 2
27432: PUSH
27433: LD_INT 0
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 2
27442: PUSH
27443: LD_INT 1
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: PUSH
27450: LD_INT 2
27452: PUSH
27453: LD_INT 2
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PUSH
27460: LD_INT 1
27462: PUSH
27463: LD_INT 2
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 0
27472: PUSH
27473: LD_INT 2
27475: PUSH
27476: EMPTY
27477: LIST
27478: LIST
27479: PUSH
27480: LD_INT 1
27482: NEG
27483: PUSH
27484: LD_INT 1
27486: PUSH
27487: EMPTY
27488: LIST
27489: LIST
27490: PUSH
27491: LD_INT 2
27493: NEG
27494: PUSH
27495: LD_INT 0
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: LD_INT 2
27504: NEG
27505: PUSH
27506: LD_INT 1
27508: NEG
27509: PUSH
27510: EMPTY
27511: LIST
27512: LIST
27513: PUSH
27514: LD_INT 2
27516: NEG
27517: PUSH
27518: LD_INT 2
27520: NEG
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: EMPTY
27527: LIST
27528: LIST
27529: LIST
27530: LIST
27531: LIST
27532: LIST
27533: LIST
27534: LIST
27535: LIST
27536: LIST
27537: LIST
27538: LIST
27539: LIST
27540: LIST
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: LIST
27546: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27547: LD_ADDR_VAR 0 23
27551: PUSH
27552: LD_INT 0
27554: PUSH
27555: LD_INT 0
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: PUSH
27562: LD_INT 0
27564: PUSH
27565: LD_INT 1
27567: NEG
27568: PUSH
27569: EMPTY
27570: LIST
27571: LIST
27572: PUSH
27573: LD_INT 1
27575: PUSH
27576: LD_INT 0
27578: PUSH
27579: EMPTY
27580: LIST
27581: LIST
27582: PUSH
27583: LD_INT 1
27585: PUSH
27586: LD_INT 1
27588: PUSH
27589: EMPTY
27590: LIST
27591: LIST
27592: PUSH
27593: LD_INT 0
27595: PUSH
27596: LD_INT 1
27598: PUSH
27599: EMPTY
27600: LIST
27601: LIST
27602: PUSH
27603: LD_INT 1
27605: NEG
27606: PUSH
27607: LD_INT 0
27609: PUSH
27610: EMPTY
27611: LIST
27612: LIST
27613: PUSH
27614: LD_INT 1
27616: NEG
27617: PUSH
27618: LD_INT 1
27620: NEG
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: PUSH
27626: LD_INT 1
27628: NEG
27629: PUSH
27630: LD_INT 2
27632: NEG
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PUSH
27638: LD_INT 0
27640: PUSH
27641: LD_INT 2
27643: NEG
27644: PUSH
27645: EMPTY
27646: LIST
27647: LIST
27648: PUSH
27649: LD_INT 1
27651: PUSH
27652: LD_INT 1
27654: NEG
27655: PUSH
27656: EMPTY
27657: LIST
27658: LIST
27659: PUSH
27660: LD_INT 2
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: LD_INT 2
27672: PUSH
27673: LD_INT 1
27675: PUSH
27676: EMPTY
27677: LIST
27678: LIST
27679: PUSH
27680: LD_INT 2
27682: PUSH
27683: LD_INT 2
27685: PUSH
27686: EMPTY
27687: LIST
27688: LIST
27689: PUSH
27690: LD_INT 1
27692: PUSH
27693: LD_INT 2
27695: PUSH
27696: EMPTY
27697: LIST
27698: LIST
27699: PUSH
27700: LD_INT 0
27702: PUSH
27703: LD_INT 2
27705: PUSH
27706: EMPTY
27707: LIST
27708: LIST
27709: PUSH
27710: LD_INT 1
27712: NEG
27713: PUSH
27714: LD_INT 1
27716: PUSH
27717: EMPTY
27718: LIST
27719: LIST
27720: PUSH
27721: LD_INT 2
27723: NEG
27724: PUSH
27725: LD_INT 0
27727: PUSH
27728: EMPTY
27729: LIST
27730: LIST
27731: PUSH
27732: LD_INT 2
27734: NEG
27735: PUSH
27736: LD_INT 1
27738: NEG
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PUSH
27744: LD_INT 2
27746: NEG
27747: PUSH
27748: LD_INT 2
27750: NEG
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 2
27758: NEG
27759: PUSH
27760: LD_INT 3
27762: NEG
27763: PUSH
27764: EMPTY
27765: LIST
27766: LIST
27767: PUSH
27768: LD_INT 1
27770: NEG
27771: PUSH
27772: LD_INT 3
27774: NEG
27775: PUSH
27776: EMPTY
27777: LIST
27778: LIST
27779: PUSH
27780: LD_INT 1
27782: PUSH
27783: LD_INT 2
27785: NEG
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: PUSH
27791: LD_INT 2
27793: PUSH
27794: LD_INT 1
27796: NEG
27797: PUSH
27798: EMPTY
27799: LIST
27800: LIST
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: LIST
27806: LIST
27807: LIST
27808: LIST
27809: LIST
27810: LIST
27811: LIST
27812: LIST
27813: LIST
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: LIST
27825: LIST
27826: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
27827: LD_ADDR_VAR 0 24
27831: PUSH
27832: LD_INT 0
27834: PUSH
27835: LD_INT 0
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: PUSH
27842: LD_INT 0
27844: PUSH
27845: LD_INT 1
27847: NEG
27848: PUSH
27849: EMPTY
27850: LIST
27851: LIST
27852: PUSH
27853: LD_INT 1
27855: PUSH
27856: LD_INT 0
27858: PUSH
27859: EMPTY
27860: LIST
27861: LIST
27862: PUSH
27863: LD_INT 1
27865: PUSH
27866: LD_INT 1
27868: PUSH
27869: EMPTY
27870: LIST
27871: LIST
27872: PUSH
27873: LD_INT 0
27875: PUSH
27876: LD_INT 1
27878: PUSH
27879: EMPTY
27880: LIST
27881: LIST
27882: PUSH
27883: LD_INT 1
27885: NEG
27886: PUSH
27887: LD_INT 0
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: LD_INT 1
27896: NEG
27897: PUSH
27898: LD_INT 1
27900: NEG
27901: PUSH
27902: EMPTY
27903: LIST
27904: LIST
27905: PUSH
27906: LD_INT 1
27908: NEG
27909: PUSH
27910: LD_INT 2
27912: NEG
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: PUSH
27918: LD_INT 0
27920: PUSH
27921: LD_INT 2
27923: NEG
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: PUSH
27929: LD_INT 1
27931: PUSH
27932: LD_INT 1
27934: NEG
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: PUSH
27940: LD_INT 2
27942: PUSH
27943: LD_INT 0
27945: PUSH
27946: EMPTY
27947: LIST
27948: LIST
27949: PUSH
27950: LD_INT 2
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: EMPTY
27957: LIST
27958: LIST
27959: PUSH
27960: LD_INT 2
27962: PUSH
27963: LD_INT 2
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: PUSH
27970: LD_INT 1
27972: PUSH
27973: LD_INT 2
27975: PUSH
27976: EMPTY
27977: LIST
27978: LIST
27979: PUSH
27980: LD_INT 0
27982: PUSH
27983: LD_INT 2
27985: PUSH
27986: EMPTY
27987: LIST
27988: LIST
27989: PUSH
27990: LD_INT 1
27992: NEG
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: PUSH
28001: LD_INT 2
28003: NEG
28004: PUSH
28005: LD_INT 0
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 2
28014: NEG
28015: PUSH
28016: LD_INT 1
28018: NEG
28019: PUSH
28020: EMPTY
28021: LIST
28022: LIST
28023: PUSH
28024: LD_INT 2
28026: NEG
28027: PUSH
28028: LD_INT 2
28030: NEG
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 1
28038: PUSH
28039: LD_INT 2
28041: NEG
28042: PUSH
28043: EMPTY
28044: LIST
28045: LIST
28046: PUSH
28047: LD_INT 2
28049: PUSH
28050: LD_INT 1
28052: NEG
28053: PUSH
28054: EMPTY
28055: LIST
28056: LIST
28057: PUSH
28058: LD_INT 3
28060: PUSH
28061: LD_INT 1
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: LD_INT 3
28070: PUSH
28071: LD_INT 2
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PUSH
28078: EMPTY
28079: LIST
28080: LIST
28081: LIST
28082: LIST
28083: LIST
28084: LIST
28085: LIST
28086: LIST
28087: LIST
28088: LIST
28089: LIST
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28103: LD_ADDR_VAR 0 25
28107: PUSH
28108: LD_INT 0
28110: PUSH
28111: LD_INT 0
28113: PUSH
28114: EMPTY
28115: LIST
28116: LIST
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: LD_INT 1
28123: NEG
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PUSH
28129: LD_INT 1
28131: PUSH
28132: LD_INT 0
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 1
28141: PUSH
28142: LD_INT 1
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 0
28151: PUSH
28152: LD_INT 1
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: LD_INT 1
28161: NEG
28162: PUSH
28163: LD_INT 0
28165: PUSH
28166: EMPTY
28167: LIST
28168: LIST
28169: PUSH
28170: LD_INT 1
28172: NEG
28173: PUSH
28174: LD_INT 1
28176: NEG
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 1
28184: NEG
28185: PUSH
28186: LD_INT 2
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: LD_INT 0
28196: PUSH
28197: LD_INT 2
28199: NEG
28200: PUSH
28201: EMPTY
28202: LIST
28203: LIST
28204: PUSH
28205: LD_INT 1
28207: PUSH
28208: LD_INT 1
28210: NEG
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: PUSH
28216: LD_INT 2
28218: PUSH
28219: LD_INT 0
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 2
28228: PUSH
28229: LD_INT 1
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 2
28238: PUSH
28239: LD_INT 2
28241: PUSH
28242: EMPTY
28243: LIST
28244: LIST
28245: PUSH
28246: LD_INT 1
28248: PUSH
28249: LD_INT 2
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: PUSH
28256: LD_INT 0
28258: PUSH
28259: LD_INT 2
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 1
28268: NEG
28269: PUSH
28270: LD_INT 1
28272: PUSH
28273: EMPTY
28274: LIST
28275: LIST
28276: PUSH
28277: LD_INT 2
28279: NEG
28280: PUSH
28281: LD_INT 0
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: PUSH
28288: LD_INT 2
28290: NEG
28291: PUSH
28292: LD_INT 1
28294: NEG
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: LD_INT 2
28302: NEG
28303: PUSH
28304: LD_INT 2
28306: NEG
28307: PUSH
28308: EMPTY
28309: LIST
28310: LIST
28311: PUSH
28312: LD_INT 3
28314: PUSH
28315: LD_INT 1
28317: PUSH
28318: EMPTY
28319: LIST
28320: LIST
28321: PUSH
28322: LD_INT 3
28324: PUSH
28325: LD_INT 2
28327: PUSH
28328: EMPTY
28329: LIST
28330: LIST
28331: PUSH
28332: LD_INT 2
28334: PUSH
28335: LD_INT 3
28337: PUSH
28338: EMPTY
28339: LIST
28340: LIST
28341: PUSH
28342: LD_INT 1
28344: PUSH
28345: LD_INT 3
28347: PUSH
28348: EMPTY
28349: LIST
28350: LIST
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: LIST
28356: LIST
28357: LIST
28358: LIST
28359: LIST
28360: LIST
28361: LIST
28362: LIST
28363: LIST
28364: LIST
28365: LIST
28366: LIST
28367: LIST
28368: LIST
28369: LIST
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28377: LD_ADDR_VAR 0 26
28381: PUSH
28382: LD_INT 0
28384: PUSH
28385: LD_INT 0
28387: PUSH
28388: EMPTY
28389: LIST
28390: LIST
28391: PUSH
28392: LD_INT 0
28394: PUSH
28395: LD_INT 1
28397: NEG
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PUSH
28403: LD_INT 1
28405: PUSH
28406: LD_INT 0
28408: PUSH
28409: EMPTY
28410: LIST
28411: LIST
28412: PUSH
28413: LD_INT 1
28415: PUSH
28416: LD_INT 1
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: PUSH
28423: LD_INT 0
28425: PUSH
28426: LD_INT 1
28428: PUSH
28429: EMPTY
28430: LIST
28431: LIST
28432: PUSH
28433: LD_INT 1
28435: NEG
28436: PUSH
28437: LD_INT 0
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 1
28446: NEG
28447: PUSH
28448: LD_INT 1
28450: NEG
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 1
28458: NEG
28459: PUSH
28460: LD_INT 2
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 0
28470: PUSH
28471: LD_INT 2
28473: NEG
28474: PUSH
28475: EMPTY
28476: LIST
28477: LIST
28478: PUSH
28479: LD_INT 1
28481: PUSH
28482: LD_INT 1
28484: NEG
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 2
28492: PUSH
28493: LD_INT 0
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 2
28502: PUSH
28503: LD_INT 1
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 2
28512: PUSH
28513: LD_INT 2
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: LD_INT 1
28522: PUSH
28523: LD_INT 2
28525: PUSH
28526: EMPTY
28527: LIST
28528: LIST
28529: PUSH
28530: LD_INT 0
28532: PUSH
28533: LD_INT 2
28535: PUSH
28536: EMPTY
28537: LIST
28538: LIST
28539: PUSH
28540: LD_INT 1
28542: NEG
28543: PUSH
28544: LD_INT 1
28546: PUSH
28547: EMPTY
28548: LIST
28549: LIST
28550: PUSH
28551: LD_INT 2
28553: NEG
28554: PUSH
28555: LD_INT 0
28557: PUSH
28558: EMPTY
28559: LIST
28560: LIST
28561: PUSH
28562: LD_INT 2
28564: NEG
28565: PUSH
28566: LD_INT 1
28568: NEG
28569: PUSH
28570: EMPTY
28571: LIST
28572: LIST
28573: PUSH
28574: LD_INT 2
28576: NEG
28577: PUSH
28578: LD_INT 2
28580: NEG
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 2
28588: PUSH
28589: LD_INT 3
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: LD_INT 1
28598: PUSH
28599: LD_INT 3
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 1
28608: NEG
28609: PUSH
28610: LD_INT 2
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: LD_INT 2
28619: NEG
28620: PUSH
28621: LD_INT 1
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: PUSH
28628: EMPTY
28629: LIST
28630: LIST
28631: LIST
28632: LIST
28633: LIST
28634: LIST
28635: LIST
28636: LIST
28637: LIST
28638: LIST
28639: LIST
28640: LIST
28641: LIST
28642: LIST
28643: LIST
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28653: LD_ADDR_VAR 0 27
28657: PUSH
28658: LD_INT 0
28660: PUSH
28661: LD_INT 0
28663: PUSH
28664: EMPTY
28665: LIST
28666: LIST
28667: PUSH
28668: LD_INT 0
28670: PUSH
28671: LD_INT 1
28673: NEG
28674: PUSH
28675: EMPTY
28676: LIST
28677: LIST
28678: PUSH
28679: LD_INT 1
28681: PUSH
28682: LD_INT 0
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 1
28691: PUSH
28692: LD_INT 1
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 0
28701: PUSH
28702: LD_INT 1
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: LD_INT 1
28711: NEG
28712: PUSH
28713: LD_INT 0
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 1
28722: NEG
28723: PUSH
28724: LD_INT 1
28726: NEG
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 1
28734: NEG
28735: PUSH
28736: LD_INT 2
28738: NEG
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 0
28746: PUSH
28747: LD_INT 2
28749: NEG
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 1
28757: PUSH
28758: LD_INT 1
28760: NEG
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: PUSH
28766: LD_INT 2
28768: PUSH
28769: LD_INT 0
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 2
28788: PUSH
28789: LD_INT 2
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 1
28798: PUSH
28799: LD_INT 2
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 0
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 1
28818: NEG
28819: PUSH
28820: LD_INT 1
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: PUSH
28827: LD_INT 2
28829: NEG
28830: PUSH
28831: LD_INT 0
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: PUSH
28838: LD_INT 2
28840: NEG
28841: PUSH
28842: LD_INT 1
28844: NEG
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: PUSH
28850: LD_INT 2
28852: NEG
28853: PUSH
28854: LD_INT 2
28856: NEG
28857: PUSH
28858: EMPTY
28859: LIST
28860: LIST
28861: PUSH
28862: LD_INT 1
28864: NEG
28865: PUSH
28866: LD_INT 2
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 2
28875: NEG
28876: PUSH
28877: LD_INT 1
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 3
28886: NEG
28887: PUSH
28888: LD_INT 1
28890: NEG
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 3
28898: NEG
28899: PUSH
28900: LD_INT 2
28902: NEG
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: PUSH
28908: EMPTY
28909: LIST
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28933: LD_ADDR_VAR 0 28
28937: PUSH
28938: LD_INT 0
28940: PUSH
28941: LD_INT 0
28943: PUSH
28944: EMPTY
28945: LIST
28946: LIST
28947: PUSH
28948: LD_INT 0
28950: PUSH
28951: LD_INT 1
28953: NEG
28954: PUSH
28955: EMPTY
28956: LIST
28957: LIST
28958: PUSH
28959: LD_INT 1
28961: PUSH
28962: LD_INT 0
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PUSH
28969: LD_INT 1
28971: PUSH
28972: LD_INT 1
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 0
28981: PUSH
28982: LD_INT 1
28984: PUSH
28985: EMPTY
28986: LIST
28987: LIST
28988: PUSH
28989: LD_INT 1
28991: NEG
28992: PUSH
28993: LD_INT 0
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 1
29002: NEG
29003: PUSH
29004: LD_INT 1
29006: NEG
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: LD_INT 1
29014: NEG
29015: PUSH
29016: LD_INT 2
29018: NEG
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: LD_INT 0
29026: PUSH
29027: LD_INT 2
29029: NEG
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 1
29037: PUSH
29038: LD_INT 1
29040: NEG
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: LD_INT 2
29048: PUSH
29049: LD_INT 0
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 2
29058: PUSH
29059: LD_INT 1
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 2
29068: PUSH
29069: LD_INT 2
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 1
29078: PUSH
29079: LD_INT 2
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 0
29088: PUSH
29089: LD_INT 2
29091: PUSH
29092: EMPTY
29093: LIST
29094: LIST
29095: PUSH
29096: LD_INT 1
29098: NEG
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: LD_INT 2
29109: NEG
29110: PUSH
29111: LD_INT 0
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: LD_INT 2
29120: NEG
29121: PUSH
29122: LD_INT 1
29124: NEG
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 2
29132: NEG
29133: PUSH
29134: LD_INT 2
29136: NEG
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: LD_INT 2
29144: NEG
29145: PUSH
29146: LD_INT 3
29148: NEG
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: LD_INT 1
29156: NEG
29157: PUSH
29158: LD_INT 3
29160: NEG
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 3
29168: NEG
29169: PUSH
29170: LD_INT 1
29172: NEG
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 3
29180: NEG
29181: PUSH
29182: LD_INT 2
29184: NEG
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: LIST
29194: LIST
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29215: LD_ADDR_VAR 0 29
29219: PUSH
29220: LD_INT 0
29222: PUSH
29223: LD_INT 0
29225: PUSH
29226: EMPTY
29227: LIST
29228: LIST
29229: PUSH
29230: LD_INT 0
29232: PUSH
29233: LD_INT 1
29235: NEG
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 1
29243: PUSH
29244: LD_INT 0
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: LD_INT 1
29253: PUSH
29254: LD_INT 1
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 0
29263: PUSH
29264: LD_INT 1
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 1
29273: NEG
29274: PUSH
29275: LD_INT 0
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PUSH
29282: LD_INT 1
29284: NEG
29285: PUSH
29286: LD_INT 1
29288: NEG
29289: PUSH
29290: EMPTY
29291: LIST
29292: LIST
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: LD_INT 2
29300: NEG
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: PUSH
29306: LD_INT 0
29308: PUSH
29309: LD_INT 2
29311: NEG
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: PUSH
29317: LD_INT 1
29319: PUSH
29320: LD_INT 1
29322: NEG
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: LD_INT 2
29330: PUSH
29331: LD_INT 0
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 2
29340: PUSH
29341: LD_INT 1
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 1
29350: PUSH
29351: LD_INT 2
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 0
29360: PUSH
29361: LD_INT 2
29363: PUSH
29364: EMPTY
29365: LIST
29366: LIST
29367: PUSH
29368: LD_INT 1
29370: NEG
29371: PUSH
29372: LD_INT 1
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: LD_INT 2
29381: NEG
29382: PUSH
29383: LD_INT 1
29385: NEG
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 2
29393: NEG
29394: PUSH
29395: LD_INT 2
29397: NEG
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 2
29405: NEG
29406: PUSH
29407: LD_INT 3
29409: NEG
29410: PUSH
29411: EMPTY
29412: LIST
29413: LIST
29414: PUSH
29415: LD_INT 2
29417: PUSH
29418: LD_INT 1
29420: NEG
29421: PUSH
29422: EMPTY
29423: LIST
29424: LIST
29425: PUSH
29426: LD_INT 3
29428: PUSH
29429: LD_INT 1
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: LD_INT 1
29438: PUSH
29439: LD_INT 3
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: LD_INT 1
29448: NEG
29449: PUSH
29450: LD_INT 2
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: PUSH
29457: LD_INT 3
29459: NEG
29460: PUSH
29461: LD_INT 2
29463: NEG
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29494: LD_ADDR_VAR 0 30
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 0
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 0
29511: PUSH
29512: LD_INT 1
29514: NEG
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: PUSH
29523: LD_INT 0
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 1
29532: PUSH
29533: LD_INT 1
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 0
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 1
29552: NEG
29553: PUSH
29554: LD_INT 0
29556: PUSH
29557: EMPTY
29558: LIST
29559: LIST
29560: PUSH
29561: LD_INT 1
29563: NEG
29564: PUSH
29565: LD_INT 1
29567: NEG
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PUSH
29573: LD_INT 1
29575: NEG
29576: PUSH
29577: LD_INT 2
29579: NEG
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PUSH
29585: LD_INT 0
29587: PUSH
29588: LD_INT 2
29590: NEG
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: LD_INT 1
29601: NEG
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: LD_INT 2
29609: PUSH
29610: LD_INT 0
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 2
29619: PUSH
29620: LD_INT 1
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 2
29629: PUSH
29630: LD_INT 2
29632: PUSH
29633: EMPTY
29634: LIST
29635: LIST
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: LD_INT 2
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: NEG
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PUSH
29658: LD_INT 2
29660: NEG
29661: PUSH
29662: LD_INT 0
29664: PUSH
29665: EMPTY
29666: LIST
29667: LIST
29668: PUSH
29669: LD_INT 2
29671: NEG
29672: PUSH
29673: LD_INT 1
29675: NEG
29676: PUSH
29677: EMPTY
29678: LIST
29679: LIST
29680: PUSH
29681: LD_INT 1
29683: NEG
29684: PUSH
29685: LD_INT 3
29687: NEG
29688: PUSH
29689: EMPTY
29690: LIST
29691: LIST
29692: PUSH
29693: LD_INT 1
29695: PUSH
29696: LD_INT 2
29698: NEG
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 3
29706: PUSH
29707: LD_INT 2
29709: PUSH
29710: EMPTY
29711: LIST
29712: LIST
29713: PUSH
29714: LD_INT 2
29716: PUSH
29717: LD_INT 3
29719: PUSH
29720: EMPTY
29721: LIST
29722: LIST
29723: PUSH
29724: LD_INT 2
29726: NEG
29727: PUSH
29728: LD_INT 1
29730: PUSH
29731: EMPTY
29732: LIST
29733: LIST
29734: PUSH
29735: LD_INT 3
29737: NEG
29738: PUSH
29739: LD_INT 1
29741: NEG
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: LIST
29751: LIST
29752: LIST
29753: LIST
29754: LIST
29755: LIST
29756: LIST
29757: LIST
29758: LIST
29759: LIST
29760: LIST
29761: LIST
29762: LIST
29763: LIST
29764: LIST
29765: LIST
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29772: LD_ADDR_VAR 0 31
29776: PUSH
29777: LD_INT 0
29779: PUSH
29780: LD_INT 0
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 0
29789: PUSH
29790: LD_INT 1
29792: NEG
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: PUSH
29798: LD_INT 1
29800: PUSH
29801: LD_INT 0
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 1
29810: PUSH
29811: LD_INT 1
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 0
29820: PUSH
29821: LD_INT 1
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: LD_INT 1
29830: NEG
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 1
29841: NEG
29842: PUSH
29843: LD_INT 1
29845: NEG
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 1
29853: NEG
29854: PUSH
29855: LD_INT 2
29857: NEG
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 1
29865: PUSH
29866: LD_INT 1
29868: NEG
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 2
29876: PUSH
29877: LD_INT 0
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: LD_INT 2
29886: PUSH
29887: LD_INT 1
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 2
29896: PUSH
29897: LD_INT 2
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: LD_INT 2
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 0
29916: PUSH
29917: LD_INT 2
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 1
29926: NEG
29927: PUSH
29928: LD_INT 1
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 2
29937: NEG
29938: PUSH
29939: LD_INT 1
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 2
29949: NEG
29950: PUSH
29951: LD_INT 2
29953: NEG
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 2
29961: NEG
29962: PUSH
29963: LD_INT 3
29965: NEG
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 2
29973: PUSH
29974: LD_INT 1
29976: NEG
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 3
29984: PUSH
29985: LD_INT 1
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: PUSH
29995: LD_INT 3
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: PUSH
30002: LD_INT 1
30004: NEG
30005: PUSH
30006: LD_INT 2
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: LD_INT 3
30015: NEG
30016: PUSH
30017: LD_INT 2
30019: NEG
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: LIST
30029: LIST
30030: LIST
30031: LIST
30032: LIST
30033: LIST
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30050: LD_ADDR_VAR 0 32
30054: PUSH
30055: LD_INT 0
30057: PUSH
30058: LD_INT 0
30060: PUSH
30061: EMPTY
30062: LIST
30063: LIST
30064: PUSH
30065: LD_INT 0
30067: PUSH
30068: LD_INT 1
30070: NEG
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: PUSH
30079: LD_INT 0
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 1
30088: PUSH
30089: LD_INT 1
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: PUSH
30096: LD_INT 0
30098: PUSH
30099: LD_INT 1
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 1
30108: NEG
30109: PUSH
30110: LD_INT 0
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 1
30119: NEG
30120: PUSH
30121: LD_INT 1
30123: NEG
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 1
30131: NEG
30132: PUSH
30133: LD_INT 2
30135: NEG
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: LD_INT 2
30146: NEG
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 1
30154: PUSH
30155: LD_INT 1
30157: NEG
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: PUSH
30163: LD_INT 2
30165: PUSH
30166: LD_INT 1
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 2
30175: PUSH
30176: LD_INT 2
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: LD_INT 2
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 0
30195: PUSH
30196: LD_INT 2
30198: PUSH
30199: EMPTY
30200: LIST
30201: LIST
30202: PUSH
30203: LD_INT 1
30205: NEG
30206: PUSH
30207: LD_INT 1
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 2
30216: NEG
30217: PUSH
30218: LD_INT 0
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 2
30227: NEG
30228: PUSH
30229: LD_INT 1
30231: NEG
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: PUSH
30237: LD_INT 1
30239: NEG
30240: PUSH
30241: LD_INT 3
30243: NEG
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 1
30251: PUSH
30252: LD_INT 2
30254: NEG
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 3
30262: PUSH
30263: LD_INT 2
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 2
30272: PUSH
30273: LD_INT 3
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 2
30282: NEG
30283: PUSH
30284: LD_INT 1
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 3
30293: NEG
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: EMPTY
30300: LIST
30301: LIST
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: LIST
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30328: LD_ADDR_VAR 0 33
30332: PUSH
30333: LD_INT 0
30335: PUSH
30336: LD_INT 0
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 0
30345: PUSH
30346: LD_INT 1
30348: NEG
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 1
30356: PUSH
30357: LD_INT 0
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 1
30366: PUSH
30367: LD_INT 1
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 0
30376: PUSH
30377: LD_INT 1
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 1
30386: NEG
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: PUSH
30395: LD_INT 1
30397: NEG
30398: PUSH
30399: LD_INT 1
30401: NEG
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: LD_INT 2
30413: NEG
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: PUSH
30422: LD_INT 1
30424: NEG
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 2
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 2
30442: PUSH
30443: LD_INT 1
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 1
30452: PUSH
30453: LD_INT 2
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PUSH
30460: LD_INT 0
30462: PUSH
30463: LD_INT 2
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 1
30472: NEG
30473: PUSH
30474: LD_INT 1
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 2
30483: NEG
30484: PUSH
30485: LD_INT 0
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: LD_INT 2
30494: NEG
30495: PUSH
30496: LD_INT 1
30498: NEG
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 2
30506: NEG
30507: PUSH
30508: LD_INT 2
30510: NEG
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 2
30518: NEG
30519: PUSH
30520: LD_INT 3
30522: NEG
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: PUSH
30528: LD_INT 2
30530: PUSH
30531: LD_INT 1
30533: NEG
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 3
30541: PUSH
30542: LD_INT 1
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 1
30551: PUSH
30552: LD_INT 3
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: NEG
30562: PUSH
30563: LD_INT 2
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 3
30572: NEG
30573: PUSH
30574: LD_INT 2
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: EMPTY
30583: LIST
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30607: LD_ADDR_VAR 0 34
30611: PUSH
30612: LD_INT 0
30614: PUSH
30615: LD_INT 0
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: LD_INT 1
30627: NEG
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 1
30635: PUSH
30636: LD_INT 0
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: LD_INT 1
30645: PUSH
30646: LD_INT 1
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 0
30655: PUSH
30656: LD_INT 1
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 1
30665: NEG
30666: PUSH
30667: LD_INT 0
30669: PUSH
30670: EMPTY
30671: LIST
30672: LIST
30673: PUSH
30674: LD_INT 1
30676: NEG
30677: PUSH
30678: LD_INT 1
30680: NEG
30681: PUSH
30682: EMPTY
30683: LIST
30684: LIST
30685: PUSH
30686: LD_INT 1
30688: NEG
30689: PUSH
30690: LD_INT 2
30692: NEG
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 0
30700: PUSH
30701: LD_INT 2
30703: NEG
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 1
30711: PUSH
30712: LD_INT 1
30714: NEG
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 2
30722: PUSH
30723: LD_INT 1
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 2
30732: PUSH
30733: LD_INT 2
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 1
30742: PUSH
30743: LD_INT 2
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 1
30752: NEG
30753: PUSH
30754: LD_INT 1
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 2
30763: NEG
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 2
30774: NEG
30775: PUSH
30776: LD_INT 1
30778: NEG
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 2
30786: NEG
30787: PUSH
30788: LD_INT 2
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: NEG
30799: PUSH
30800: LD_INT 3
30802: NEG
30803: PUSH
30804: EMPTY
30805: LIST
30806: LIST
30807: PUSH
30808: LD_INT 1
30810: PUSH
30811: LD_INT 2
30813: NEG
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 3
30821: PUSH
30822: LD_INT 2
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 2
30831: PUSH
30832: LD_INT 3
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 2
30841: NEG
30842: PUSH
30843: LD_INT 1
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 3
30852: NEG
30853: PUSH
30854: LD_INT 1
30856: NEG
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: EMPTY
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
30887: LD_ADDR_VAR 0 35
30891: PUSH
30892: LD_INT 0
30894: PUSH
30895: LD_INT 0
30897: PUSH
30898: EMPTY
30899: LIST
30900: LIST
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: LD_INT 1
30907: NEG
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 1
30915: PUSH
30916: LD_INT 0
30918: PUSH
30919: EMPTY
30920: LIST
30921: LIST
30922: PUSH
30923: LD_INT 1
30925: PUSH
30926: LD_INT 1
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: LD_INT 0
30935: PUSH
30936: LD_INT 1
30938: PUSH
30939: EMPTY
30940: LIST
30941: LIST
30942: PUSH
30943: LD_INT 1
30945: NEG
30946: PUSH
30947: LD_INT 0
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: LD_INT 1
30960: NEG
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: PUSH
30966: LD_INT 2
30968: PUSH
30969: LD_INT 1
30971: PUSH
30972: EMPTY
30973: LIST
30974: LIST
30975: PUSH
30976: LD_INT 2
30978: NEG
30979: PUSH
30980: LD_INT 1
30982: NEG
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
30999: LD_ADDR_VAR 0 36
31003: PUSH
31004: LD_INT 0
31006: PUSH
31007: LD_INT 0
31009: PUSH
31010: EMPTY
31011: LIST
31012: LIST
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: LD_INT 1
31019: NEG
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 1
31027: PUSH
31028: LD_INT 0
31030: PUSH
31031: EMPTY
31032: LIST
31033: LIST
31034: PUSH
31035: LD_INT 1
31037: PUSH
31038: LD_INT 1
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: LD_INT 1
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 1
31057: NEG
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: LD_INT 1
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 1
31080: NEG
31081: PUSH
31082: LD_INT 2
31084: NEG
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 1
31092: PUSH
31093: LD_INT 2
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: EMPTY
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: LIST
31110: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31111: LD_ADDR_VAR 0 37
31115: PUSH
31116: LD_INT 0
31118: PUSH
31119: LD_INT 0
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 0
31128: PUSH
31129: LD_INT 1
31131: NEG
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 1
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 1
31149: PUSH
31150: LD_INT 1
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_INT 0
31159: PUSH
31160: LD_INT 1
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: LD_INT 0
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 1
31180: NEG
31181: PUSH
31182: LD_INT 1
31184: NEG
31185: PUSH
31186: EMPTY
31187: LIST
31188: LIST
31189: PUSH
31190: LD_INT 1
31192: PUSH
31193: LD_INT 1
31195: NEG
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: PUSH
31201: LD_INT 1
31203: NEG
31204: PUSH
31205: LD_INT 1
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31223: LD_ADDR_VAR 0 38
31227: PUSH
31228: LD_INT 0
31230: PUSH
31231: LD_INT 0
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 0
31240: PUSH
31241: LD_INT 1
31243: NEG
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 1
31251: PUSH
31252: LD_INT 0
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: LD_INT 1
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 0
31271: PUSH
31272: LD_INT 1
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 1
31281: NEG
31282: PUSH
31283: LD_INT 0
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 1
31292: NEG
31293: PUSH
31294: LD_INT 1
31296: NEG
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 2
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 2
31314: NEG
31315: PUSH
31316: LD_INT 1
31318: NEG
31319: PUSH
31320: EMPTY
31321: LIST
31322: LIST
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: LIST
31331: LIST
31332: LIST
31333: LIST
31334: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31335: LD_ADDR_VAR 0 39
31339: PUSH
31340: LD_INT 0
31342: PUSH
31343: LD_INT 0
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 0
31352: PUSH
31353: LD_INT 1
31355: NEG
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 1
31363: PUSH
31364: LD_INT 0
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: LD_INT 1
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: LD_INT 1
31386: PUSH
31387: EMPTY
31388: LIST
31389: LIST
31390: PUSH
31391: LD_INT 1
31393: NEG
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 1
31404: NEG
31405: PUSH
31406: LD_INT 1
31408: NEG
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 1
31416: NEG
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: EMPTY
31423: LIST
31424: LIST
31425: PUSH
31426: LD_INT 1
31428: PUSH
31429: LD_INT 2
31431: PUSH
31432: EMPTY
31433: LIST
31434: LIST
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: LIST
31440: LIST
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31447: LD_ADDR_VAR 0 40
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 1
31475: PUSH
31476: LD_INT 0
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 1
31485: PUSH
31486: LD_INT 1
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 0
31495: PUSH
31496: LD_INT 1
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 1
31505: NEG
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: LD_INT 1
31520: NEG
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 1
31528: PUSH
31529: LD_INT 1
31531: NEG
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 1
31539: NEG
31540: PUSH
31541: LD_INT 1
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31559: LD_ADDR_VAR 0 41
31563: PUSH
31564: LD_INT 0
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: EMPTY
31582: LIST
31583: LIST
31584: PUSH
31585: LD_INT 1
31587: PUSH
31588: LD_INT 0
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: LD_INT 1
31597: PUSH
31598: LD_INT 1
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: LD_INT 1
31610: PUSH
31611: EMPTY
31612: LIST
31613: LIST
31614: PUSH
31615: LD_INT 1
31617: NEG
31618: PUSH
31619: LD_INT 0
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 1
31628: NEG
31629: PUSH
31630: LD_INT 1
31632: NEG
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 1
31640: NEG
31641: PUSH
31642: LD_INT 2
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 1
31652: PUSH
31653: LD_INT 1
31655: NEG
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: LD_INT 2
31663: PUSH
31664: LD_INT 0
31666: PUSH
31667: EMPTY
31668: LIST
31669: LIST
31670: PUSH
31671: LD_INT 2
31673: PUSH
31674: LD_INT 1
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: LD_INT 2
31683: PUSH
31684: LD_INT 2
31686: PUSH
31687: EMPTY
31688: LIST
31689: LIST
31690: PUSH
31691: LD_INT 1
31693: PUSH
31694: LD_INT 2
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 1
31703: NEG
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 2
31714: NEG
31715: PUSH
31716: LD_INT 0
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 2
31725: NEG
31726: PUSH
31727: LD_INT 1
31729: NEG
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 2
31737: NEG
31738: PUSH
31739: LD_INT 2
31741: NEG
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 2
31749: NEG
31750: PUSH
31751: LD_INT 3
31753: NEG
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 2
31761: PUSH
31762: LD_INT 1
31764: NEG
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 3
31772: PUSH
31773: LD_INT 0
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 3
31782: PUSH
31783: LD_INT 1
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 3
31792: PUSH
31793: LD_INT 2
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 3
31802: PUSH
31803: LD_INT 3
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 2
31812: PUSH
31813: LD_INT 3
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 2
31822: NEG
31823: PUSH
31824: LD_INT 1
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 3
31833: NEG
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 3
31844: NEG
31845: PUSH
31846: LD_INT 1
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 3
31856: NEG
31857: PUSH
31858: LD_INT 2
31860: NEG
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PUSH
31866: LD_INT 3
31868: NEG
31869: PUSH
31870: LD_INT 3
31872: NEG
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: LIST
31893: LIST
31894: LIST
31895: LIST
31896: LIST
31897: LIST
31898: LIST
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: LIST
31907: LIST
31908: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31909: LD_ADDR_VAR 0 42
31913: PUSH
31914: LD_INT 0
31916: PUSH
31917: LD_INT 0
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 0
31926: PUSH
31927: LD_INT 1
31929: NEG
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 1
31937: PUSH
31938: LD_INT 0
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: LD_INT 1
31947: PUSH
31948: LD_INT 1
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 0
31957: PUSH
31958: LD_INT 1
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 1
31967: NEG
31968: PUSH
31969: LD_INT 0
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 1
31978: NEG
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PUSH
31988: LD_INT 1
31990: NEG
31991: PUSH
31992: LD_INT 2
31994: NEG
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 0
32002: PUSH
32003: LD_INT 2
32005: NEG
32006: PUSH
32007: EMPTY
32008: LIST
32009: LIST
32010: PUSH
32011: LD_INT 1
32013: PUSH
32014: LD_INT 1
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 2
32024: PUSH
32025: LD_INT 1
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: LD_INT 2
32034: PUSH
32035: LD_INT 2
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: LD_INT 1
32044: PUSH
32045: LD_INT 2
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PUSH
32052: LD_INT 0
32054: PUSH
32055: LD_INT 2
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 1
32064: NEG
32065: PUSH
32066: LD_INT 1
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 2
32075: NEG
32076: PUSH
32077: LD_INT 1
32079: NEG
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 2
32087: NEG
32088: PUSH
32089: LD_INT 2
32091: NEG
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 2
32099: NEG
32100: PUSH
32101: LD_INT 3
32103: NEG
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 1
32111: NEG
32112: PUSH
32113: LD_INT 3
32115: NEG
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: LD_INT 3
32126: NEG
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 1
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 3
32145: PUSH
32146: LD_INT 2
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 3
32155: PUSH
32156: LD_INT 3
32158: PUSH
32159: EMPTY
32160: LIST
32161: LIST
32162: PUSH
32163: LD_INT 2
32165: PUSH
32166: LD_INT 3
32168: PUSH
32169: EMPTY
32170: LIST
32171: LIST
32172: PUSH
32173: LD_INT 1
32175: PUSH
32176: LD_INT 3
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 0
32185: PUSH
32186: LD_INT 3
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 1
32195: NEG
32196: PUSH
32197: LD_INT 2
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 3
32206: NEG
32207: PUSH
32208: LD_INT 2
32210: NEG
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: LD_INT 3
32218: NEG
32219: PUSH
32220: LD_INT 3
32222: NEG
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: LIST
32253: LIST
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32259: LD_ADDR_VAR 0 43
32263: PUSH
32264: LD_INT 0
32266: PUSH
32267: LD_INT 0
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 0
32276: PUSH
32277: LD_INT 1
32279: NEG
32280: PUSH
32281: EMPTY
32282: LIST
32283: LIST
32284: PUSH
32285: LD_INT 1
32287: PUSH
32288: LD_INT 0
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: LD_INT 1
32297: PUSH
32298: LD_INT 1
32300: PUSH
32301: EMPTY
32302: LIST
32303: LIST
32304: PUSH
32305: LD_INT 0
32307: PUSH
32308: LD_INT 1
32310: PUSH
32311: EMPTY
32312: LIST
32313: LIST
32314: PUSH
32315: LD_INT 1
32317: NEG
32318: PUSH
32319: LD_INT 0
32321: PUSH
32322: EMPTY
32323: LIST
32324: LIST
32325: PUSH
32326: LD_INT 1
32328: NEG
32329: PUSH
32330: LD_INT 1
32332: NEG
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 1
32340: NEG
32341: PUSH
32342: LD_INT 2
32344: NEG
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 2
32355: NEG
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 1
32363: PUSH
32364: LD_INT 1
32366: NEG
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 2
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 2
32384: PUSH
32385: LD_INT 1
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PUSH
32392: LD_INT 1
32394: PUSH
32395: LD_INT 2
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 0
32404: PUSH
32405: LD_INT 2
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 1
32414: NEG
32415: PUSH
32416: LD_INT 1
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: LD_INT 2
32425: NEG
32426: PUSH
32427: LD_INT 0
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 2
32436: NEG
32437: PUSH
32438: LD_INT 1
32440: NEG
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 1
32448: NEG
32449: PUSH
32450: LD_INT 3
32452: NEG
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 0
32460: PUSH
32461: LD_INT 3
32463: NEG
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 1
32471: PUSH
32472: LD_INT 2
32474: NEG
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 2
32482: PUSH
32483: LD_INT 1
32485: NEG
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 3
32493: PUSH
32494: LD_INT 0
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 3
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 1
32513: PUSH
32514: LD_INT 3
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 0
32523: PUSH
32524: LD_INT 3
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: NEG
32534: PUSH
32535: LD_INT 2
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: LD_INT 1
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 3
32555: NEG
32556: PUSH
32557: LD_INT 0
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 3
32566: NEG
32567: PUSH
32568: LD_INT 1
32570: NEG
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: EMPTY
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32607: LD_ADDR_VAR 0 44
32611: PUSH
32612: LD_INT 0
32614: PUSH
32615: LD_INT 0
32617: PUSH
32618: EMPTY
32619: LIST
32620: LIST
32621: PUSH
32622: LD_INT 0
32624: PUSH
32625: LD_INT 1
32627: NEG
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 1
32635: PUSH
32636: LD_INT 0
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 1
32645: PUSH
32646: LD_INT 1
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 0
32655: PUSH
32656: LD_INT 1
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 1
32665: NEG
32666: PUSH
32667: LD_INT 0
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 1
32676: NEG
32677: PUSH
32678: LD_INT 1
32680: NEG
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 1
32688: NEG
32689: PUSH
32690: LD_INT 2
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: PUSH
32701: LD_INT 1
32703: NEG
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 2
32711: PUSH
32712: LD_INT 0
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 2
32721: PUSH
32722: LD_INT 1
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 2
32731: PUSH
32732: LD_INT 2
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 1
32741: PUSH
32742: LD_INT 2
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: LD_INT 1
32751: NEG
32752: PUSH
32753: LD_INT 1
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 2
32762: NEG
32763: PUSH
32764: LD_INT 0
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 2
32773: NEG
32774: PUSH
32775: LD_INT 1
32777: NEG
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 2
32785: NEG
32786: PUSH
32787: LD_INT 2
32789: NEG
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 2
32797: NEG
32798: PUSH
32799: LD_INT 3
32801: NEG
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 2
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 3
32820: PUSH
32821: LD_INT 0
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 3
32830: PUSH
32831: LD_INT 1
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 3
32840: PUSH
32841: LD_INT 2
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 3
32850: PUSH
32851: LD_INT 3
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: LD_INT 2
32860: PUSH
32861: LD_INT 3
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 2
32870: NEG
32871: PUSH
32872: LD_INT 1
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 3
32881: NEG
32882: PUSH
32883: LD_INT 0
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 3
32892: NEG
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: LD_INT 3
32904: NEG
32905: PUSH
32906: LD_INT 2
32908: NEG
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 3
32916: NEG
32917: PUSH
32918: LD_INT 3
32920: NEG
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: LIST
32955: LIST
32956: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32957: LD_ADDR_VAR 0 45
32961: PUSH
32962: LD_INT 0
32964: PUSH
32965: LD_INT 0
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 0
32974: PUSH
32975: LD_INT 1
32977: NEG
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 1
32985: PUSH
32986: LD_INT 0
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 1
32995: PUSH
32996: LD_INT 1
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 0
33005: PUSH
33006: LD_INT 1
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 1
33015: NEG
33016: PUSH
33017: LD_INT 0
33019: PUSH
33020: EMPTY
33021: LIST
33022: LIST
33023: PUSH
33024: LD_INT 1
33026: NEG
33027: PUSH
33028: LD_INT 1
33030: NEG
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 1
33038: NEG
33039: PUSH
33040: LD_INT 2
33042: NEG
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 0
33050: PUSH
33051: LD_INT 2
33053: NEG
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 1
33061: PUSH
33062: LD_INT 1
33064: NEG
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 2
33072: PUSH
33073: LD_INT 1
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 2
33082: PUSH
33083: LD_INT 2
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: PUSH
33093: LD_INT 2
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 0
33102: PUSH
33103: LD_INT 2
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 1
33112: NEG
33113: PUSH
33114: LD_INT 1
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 2
33123: NEG
33124: PUSH
33125: LD_INT 1
33127: NEG
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 2
33135: NEG
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: EMPTY
33142: LIST
33143: LIST
33144: PUSH
33145: LD_INT 2
33147: NEG
33148: PUSH
33149: LD_INT 3
33151: NEG
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: PUSH
33157: LD_INT 1
33159: NEG
33160: PUSH
33161: LD_INT 3
33163: NEG
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: LD_INT 3
33174: NEG
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: LD_INT 2
33185: NEG
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 3
33193: PUSH
33194: LD_INT 2
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 3
33203: PUSH
33204: LD_INT 3
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 2
33213: PUSH
33214: LD_INT 3
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: PUSH
33224: LD_INT 3
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 0
33233: PUSH
33234: LD_INT 3
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 1
33243: NEG
33244: PUSH
33245: LD_INT 2
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 3
33254: NEG
33255: PUSH
33256: LD_INT 2
33258: NEG
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PUSH
33264: LD_INT 3
33266: NEG
33267: PUSH
33268: LD_INT 3
33270: NEG
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: LIST
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33307: LD_ADDR_VAR 0 46
33311: PUSH
33312: LD_INT 0
33314: PUSH
33315: LD_INT 0
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 0
33324: PUSH
33325: LD_INT 1
33327: NEG
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 1
33335: PUSH
33336: LD_INT 0
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 1
33345: PUSH
33346: LD_INT 1
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 0
33355: PUSH
33356: LD_INT 1
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: LD_INT 1
33365: NEG
33366: PUSH
33367: LD_INT 0
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PUSH
33374: LD_INT 1
33376: NEG
33377: PUSH
33378: LD_INT 1
33380: NEG
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 1
33388: NEG
33389: PUSH
33390: LD_INT 2
33392: NEG
33393: PUSH
33394: EMPTY
33395: LIST
33396: LIST
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: LD_INT 2
33403: NEG
33404: PUSH
33405: EMPTY
33406: LIST
33407: LIST
33408: PUSH
33409: LD_INT 1
33411: PUSH
33412: LD_INT 1
33414: NEG
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 2
33422: PUSH
33423: LD_INT 0
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 2
33432: PUSH
33433: LD_INT 1
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 1
33442: PUSH
33443: LD_INT 2
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 0
33452: PUSH
33453: LD_INT 2
33455: PUSH
33456: EMPTY
33457: LIST
33458: LIST
33459: PUSH
33460: LD_INT 1
33462: NEG
33463: PUSH
33464: LD_INT 1
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: LD_INT 2
33473: NEG
33474: PUSH
33475: LD_INT 0
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 2
33484: NEG
33485: PUSH
33486: LD_INT 1
33488: NEG
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: NEG
33497: PUSH
33498: LD_INT 3
33500: NEG
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 0
33508: PUSH
33509: LD_INT 3
33511: NEG
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: LD_INT 2
33522: NEG
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 2
33530: PUSH
33531: LD_INT 1
33533: NEG
33534: PUSH
33535: EMPTY
33536: LIST
33537: LIST
33538: PUSH
33539: LD_INT 3
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 3
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: PUSH
33562: LD_INT 3
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 0
33571: PUSH
33572: LD_INT 3
33574: PUSH
33575: EMPTY
33576: LIST
33577: LIST
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: LD_INT 2
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 2
33592: NEG
33593: PUSH
33594: LD_INT 1
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 3
33603: NEG
33604: PUSH
33605: LD_INT 0
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 3
33614: NEG
33615: PUSH
33616: LD_INT 1
33618: NEG
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: LIST
33631: LIST
33632: LIST
33633: LIST
33634: LIST
33635: LIST
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: LIST
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: LIST
33653: LIST
33654: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33655: LD_ADDR_VAR 0 47
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: LD_INT 0
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 0
33672: PUSH
33673: LD_INT 1
33675: NEG
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: PUSH
33684: LD_INT 0
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 1
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: EMPTY
33698: LIST
33699: LIST
33700: PUSH
33701: LD_INT 0
33703: PUSH
33704: LD_INT 1
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 1
33713: NEG
33714: PUSH
33715: LD_INT 0
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: NEG
33725: PUSH
33726: LD_INT 1
33728: NEG
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 1
33736: NEG
33737: PUSH
33738: LD_INT 2
33740: NEG
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 0
33748: PUSH
33749: LD_INT 2
33751: NEG
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 1
33759: PUSH
33760: LD_INT 1
33762: NEG
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: LD_INT 1
33774: NEG
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 2
33782: NEG
33783: PUSH
33784: LD_INT 2
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: LIST
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: LIST
33801: LIST
33802: LIST
33803: LIST
33804: LIST
33805: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
33806: LD_ADDR_VAR 0 48
33810: PUSH
33811: LD_INT 0
33813: PUSH
33814: LD_INT 0
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 0
33823: PUSH
33824: LD_INT 1
33826: NEG
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 1
33834: PUSH
33835: LD_INT 0
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 1
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 0
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 1
33864: NEG
33865: PUSH
33866: LD_INT 0
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 1
33875: NEG
33876: PUSH
33877: LD_INT 1
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: NEG
33888: PUSH
33889: LD_INT 2
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: LD_INT 2
33902: NEG
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 1
33910: PUSH
33911: LD_INT 1
33913: NEG
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 2
33921: PUSH
33922: LD_INT 0
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 2
33931: PUSH
33932: LD_INT 1
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: LIST
33943: LIST
33944: LIST
33945: LIST
33946: LIST
33947: LIST
33948: LIST
33949: LIST
33950: LIST
33951: LIST
33952: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
33953: LD_ADDR_VAR 0 49
33957: PUSH
33958: LD_INT 0
33960: PUSH
33961: LD_INT 0
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 0
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: PUSH
33982: LD_INT 0
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 1
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PUSH
33999: LD_INT 0
34001: PUSH
34002: LD_INT 1
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 1
34011: NEG
34012: PUSH
34013: LD_INT 0
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 1
34022: NEG
34023: PUSH
34024: LD_INT 1
34026: NEG
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 1
34034: PUSH
34035: LD_INT 1
34037: NEG
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 2
34045: PUSH
34046: LD_INT 0
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 2
34055: PUSH
34056: LD_INT 1
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 2
34065: PUSH
34066: LD_INT 2
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 1
34075: PUSH
34076: LD_INT 2
34078: PUSH
34079: EMPTY
34080: LIST
34081: LIST
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34097: LD_ADDR_VAR 0 50
34101: PUSH
34102: LD_INT 0
34104: PUSH
34105: LD_INT 0
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: LD_INT 1
34117: NEG
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 1
34125: PUSH
34126: LD_INT 0
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 1
34135: PUSH
34136: LD_INT 1
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 0
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: NEG
34156: PUSH
34157: LD_INT 0
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 1
34166: NEG
34167: PUSH
34168: LD_INT 1
34170: NEG
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 2
34178: PUSH
34179: LD_INT 1
34181: PUSH
34182: EMPTY
34183: LIST
34184: LIST
34185: PUSH
34186: LD_INT 2
34188: PUSH
34189: LD_INT 2
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 1
34198: PUSH
34199: LD_INT 2
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 0
34208: PUSH
34209: LD_INT 2
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: LD_INT 1
34218: NEG
34219: PUSH
34220: LD_INT 1
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: EMPTY
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34241: LD_ADDR_VAR 0 51
34245: PUSH
34246: LD_INT 0
34248: PUSH
34249: LD_INT 0
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 0
34258: PUSH
34259: LD_INT 1
34261: NEG
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 1
34269: PUSH
34270: LD_INT 0
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 1
34279: PUSH
34280: LD_INT 1
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: LD_INT 1
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 1
34299: NEG
34300: PUSH
34301: LD_INT 0
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 1
34310: NEG
34311: PUSH
34312: LD_INT 1
34314: NEG
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 1
34322: PUSH
34323: LD_INT 2
34325: PUSH
34326: EMPTY
34327: LIST
34328: LIST
34329: PUSH
34330: LD_INT 0
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: LD_INT 1
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 2
34353: NEG
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 2
34364: NEG
34365: PUSH
34366: LD_INT 1
34368: NEG
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34388: LD_ADDR_VAR 0 52
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: LD_INT 0
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 0
34405: PUSH
34406: LD_INT 1
34408: NEG
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: LD_INT 1
34416: PUSH
34417: LD_INT 0
34419: PUSH
34420: EMPTY
34421: LIST
34422: LIST
34423: PUSH
34424: LD_INT 1
34426: PUSH
34427: LD_INT 1
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 0
34436: PUSH
34437: LD_INT 1
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: PUSH
34444: LD_INT 1
34446: NEG
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 1
34457: NEG
34458: PUSH
34459: LD_INT 1
34461: NEG
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 1
34469: NEG
34470: PUSH
34471: LD_INT 2
34473: NEG
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: LD_INT 1
34485: PUSH
34486: EMPTY
34487: LIST
34488: LIST
34489: PUSH
34490: LD_INT 2
34492: NEG
34493: PUSH
34494: LD_INT 0
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 2
34503: NEG
34504: PUSH
34505: LD_INT 1
34507: NEG
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 2
34515: NEG
34516: PUSH
34517: LD_INT 2
34519: NEG
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: LIST
34529: LIST
34530: LIST
34531: LIST
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34539: LD_ADDR_VAR 0 53
34543: PUSH
34544: LD_INT 0
34546: PUSH
34547: LD_INT 0
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: PUSH
34554: LD_INT 0
34556: PUSH
34557: LD_INT 1
34559: NEG
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 1
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: EMPTY
34572: LIST
34573: LIST
34574: PUSH
34575: LD_INT 1
34577: PUSH
34578: LD_INT 1
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 1
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 1
34597: NEG
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: NEG
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: PUSH
34618: LD_INT 1
34620: NEG
34621: PUSH
34622: LD_INT 2
34624: NEG
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: LD_INT 2
34635: NEG
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PUSH
34641: LD_INT 1
34643: PUSH
34644: LD_INT 1
34646: NEG
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 2
34654: PUSH
34655: LD_INT 0
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 2
34664: PUSH
34665: LD_INT 1
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: LD_INT 2
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 0
34694: PUSH
34695: LD_INT 2
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 1
34704: NEG
34705: PUSH
34706: LD_INT 1
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 2
34715: NEG
34716: PUSH
34717: LD_INT 0
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 2
34726: NEG
34727: PUSH
34728: LD_INT 1
34730: NEG
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 2
34738: NEG
34739: PUSH
34740: LD_INT 2
34742: NEG
34743: PUSH
34744: EMPTY
34745: LIST
34746: LIST
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: LIST
34752: LIST
34753: LIST
34754: LIST
34755: LIST
34756: LIST
34757: LIST
34758: LIST
34759: LIST
34760: LIST
34761: LIST
34762: LIST
34763: LIST
34764: LIST
34765: LIST
34766: LIST
34767: LIST
34768: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34769: LD_ADDR_VAR 0 54
34773: PUSH
34774: LD_INT 0
34776: PUSH
34777: LD_INT 0
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 0
34786: PUSH
34787: LD_INT 1
34789: NEG
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 1
34797: PUSH
34798: LD_INT 0
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 1
34807: PUSH
34808: LD_INT 1
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 0
34817: PUSH
34818: LD_INT 1
34820: PUSH
34821: EMPTY
34822: LIST
34823: LIST
34824: PUSH
34825: LD_INT 1
34827: NEG
34828: PUSH
34829: LD_INT 0
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 1
34850: NEG
34851: PUSH
34852: LD_INT 2
34854: NEG
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: PUSH
34860: LD_INT 0
34862: PUSH
34863: LD_INT 2
34865: NEG
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: LD_INT 1
34876: NEG
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: LD_INT 2
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 2
34894: PUSH
34895: LD_INT 1
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 2
34904: PUSH
34905: LD_INT 2
34907: PUSH
34908: EMPTY
34909: LIST
34910: LIST
34911: PUSH
34912: LD_INT 1
34914: PUSH
34915: LD_INT 2
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 0
34924: PUSH
34925: LD_INT 2
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: NEG
34935: PUSH
34936: LD_INT 1
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 2
34945: NEG
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: LD_INT 2
34956: NEG
34957: PUSH
34958: LD_INT 1
34960: NEG
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 2
34968: NEG
34969: PUSH
34970: LD_INT 2
34972: NEG
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: LIST
34982: LIST
34983: LIST
34984: LIST
34985: LIST
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: LIST
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34999: LD_ADDR_VAR 0 55
35003: PUSH
35004: LD_INT 0
35006: PUSH
35007: LD_INT 0
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 0
35016: PUSH
35017: LD_INT 1
35019: NEG
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 1
35027: PUSH
35028: LD_INT 0
35030: PUSH
35031: EMPTY
35032: LIST
35033: LIST
35034: PUSH
35035: LD_INT 1
35037: PUSH
35038: LD_INT 1
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 0
35047: PUSH
35048: LD_INT 1
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 1
35057: NEG
35058: PUSH
35059: LD_INT 0
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: LD_INT 1
35072: NEG
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 1
35080: NEG
35081: PUSH
35082: LD_INT 2
35084: NEG
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: LD_INT 2
35095: NEG
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 1
35103: PUSH
35104: LD_INT 1
35106: NEG
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 2
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 2
35124: PUSH
35125: LD_INT 1
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 2
35134: PUSH
35135: LD_INT 2
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 1
35144: PUSH
35145: LD_INT 2
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 0
35154: PUSH
35155: LD_INT 2
35157: PUSH
35158: EMPTY
35159: LIST
35160: LIST
35161: PUSH
35162: LD_INT 1
35164: NEG
35165: PUSH
35166: LD_INT 1
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 2
35175: NEG
35176: PUSH
35177: LD_INT 0
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 2
35186: NEG
35187: PUSH
35188: LD_INT 1
35190: NEG
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 2
35198: NEG
35199: PUSH
35200: LD_INT 2
35202: NEG
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: LIST
35212: LIST
35213: LIST
35214: LIST
35215: LIST
35216: LIST
35217: LIST
35218: LIST
35219: LIST
35220: LIST
35221: LIST
35222: LIST
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35229: LD_ADDR_VAR 0 56
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: LD_INT 0
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: LD_INT 0
35246: PUSH
35247: LD_INT 1
35249: NEG
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 1
35257: PUSH
35258: LD_INT 0
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 1
35267: PUSH
35268: LD_INT 1
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 0
35277: PUSH
35278: LD_INT 1
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 1
35287: NEG
35288: PUSH
35289: LD_INT 0
35291: PUSH
35292: EMPTY
35293: LIST
35294: LIST
35295: PUSH
35296: LD_INT 1
35298: NEG
35299: PUSH
35300: LD_INT 1
35302: NEG
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 1
35310: NEG
35311: PUSH
35312: LD_INT 2
35314: NEG
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: LD_INT 2
35325: NEG
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: LD_INT 1
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 2
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 2
35354: PUSH
35355: LD_INT 1
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 2
35364: PUSH
35365: LD_INT 2
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: LD_INT 2
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 0
35384: PUSH
35385: LD_INT 2
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 1
35394: NEG
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 2
35405: NEG
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 2
35416: NEG
35417: PUSH
35418: LD_INT 1
35420: NEG
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: NEG
35429: PUSH
35430: LD_INT 2
35432: NEG
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35459: LD_ADDR_VAR 0 57
35463: PUSH
35464: LD_INT 0
35466: PUSH
35467: LD_INT 0
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: LD_INT 1
35479: NEG
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 1
35487: PUSH
35488: LD_INT 0
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 1
35497: PUSH
35498: LD_INT 1
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 0
35507: PUSH
35508: LD_INT 1
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 1
35517: NEG
35518: PUSH
35519: LD_INT 0
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: PUSH
35526: LD_INT 1
35528: NEG
35529: PUSH
35530: LD_INT 1
35532: NEG
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: PUSH
35538: LD_INT 1
35540: NEG
35541: PUSH
35542: LD_INT 2
35544: NEG
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 0
35552: PUSH
35553: LD_INT 2
35555: NEG
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 1
35563: PUSH
35564: LD_INT 1
35566: NEG
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: LD_INT 2
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 2
35584: PUSH
35585: LD_INT 1
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 2
35594: PUSH
35595: LD_INT 2
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 1
35604: PUSH
35605: LD_INT 2
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 0
35614: PUSH
35615: LD_INT 2
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 2
35635: NEG
35636: PUSH
35637: LD_INT 0
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 2
35646: NEG
35647: PUSH
35648: LD_INT 1
35650: NEG
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 2
35658: NEG
35659: PUSH
35660: LD_INT 2
35662: NEG
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: LIST
35686: LIST
35687: LIST
35688: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35689: LD_ADDR_VAR 0 58
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 0
35706: PUSH
35707: LD_INT 1
35709: NEG
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 1
35717: PUSH
35718: LD_INT 0
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: PUSH
35728: LD_INT 1
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 0
35737: PUSH
35738: LD_INT 1
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 1
35747: NEG
35748: PUSH
35749: LD_INT 0
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: LD_INT 1
35762: NEG
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 1
35770: NEG
35771: PUSH
35772: LD_INT 2
35774: NEG
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 0
35782: PUSH
35783: LD_INT 2
35785: NEG
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 1
35793: PUSH
35794: LD_INT 1
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 2
35804: PUSH
35805: LD_INT 0
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 2
35814: PUSH
35815: LD_INT 1
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 2
35824: PUSH
35825: LD_INT 2
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 1
35834: PUSH
35835: LD_INT 2
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 0
35844: PUSH
35845: LD_INT 2
35847: PUSH
35848: EMPTY
35849: LIST
35850: LIST
35851: PUSH
35852: LD_INT 1
35854: NEG
35855: PUSH
35856: LD_INT 1
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 2
35865: NEG
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 2
35876: NEG
35877: PUSH
35878: LD_INT 1
35880: NEG
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 2
35888: NEG
35889: PUSH
35890: LD_INT 2
35892: NEG
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: LIST
35902: LIST
35903: LIST
35904: LIST
35905: LIST
35906: LIST
35907: LIST
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
35919: LD_ADDR_VAR 0 59
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: LD_INT 0
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 0
35936: PUSH
35937: LD_INT 1
35939: NEG
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 1
35947: PUSH
35948: LD_INT 0
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: LD_INT 1
35957: PUSH
35958: LD_INT 1
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 0
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 1
35977: NEG
35978: PUSH
35979: LD_INT 0
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: LD_INT 1
35992: NEG
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: LIST
36004: LIST
36005: LIST
36006: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36007: LD_ADDR_VAR 0 60
36011: PUSH
36012: LD_INT 0
36014: PUSH
36015: LD_INT 0
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: LD_INT 1
36027: NEG
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 1
36035: PUSH
36036: LD_INT 0
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 1
36045: PUSH
36046: LD_INT 1
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: LD_INT 1
36058: PUSH
36059: EMPTY
36060: LIST
36061: LIST
36062: PUSH
36063: LD_INT 1
36065: NEG
36066: PUSH
36067: LD_INT 0
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 1
36076: NEG
36077: PUSH
36078: LD_INT 1
36080: NEG
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36095: LD_ADDR_VAR 0 61
36099: PUSH
36100: LD_INT 0
36102: PUSH
36103: LD_INT 0
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 0
36112: PUSH
36113: LD_INT 1
36115: NEG
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 1
36123: PUSH
36124: LD_INT 0
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: PUSH
36134: LD_INT 1
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 0
36143: PUSH
36144: LD_INT 1
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: PUSH
36151: LD_INT 1
36153: NEG
36154: PUSH
36155: LD_INT 0
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 1
36164: NEG
36165: PUSH
36166: LD_INT 1
36168: NEG
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36183: LD_ADDR_VAR 0 62
36187: PUSH
36188: LD_INT 0
36190: PUSH
36191: LD_INT 0
36193: PUSH
36194: EMPTY
36195: LIST
36196: LIST
36197: PUSH
36198: LD_INT 0
36200: PUSH
36201: LD_INT 1
36203: NEG
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 1
36211: PUSH
36212: LD_INT 0
36214: PUSH
36215: EMPTY
36216: LIST
36217: LIST
36218: PUSH
36219: LD_INT 1
36221: PUSH
36222: LD_INT 1
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: LD_INT 0
36231: PUSH
36232: LD_INT 1
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 1
36241: NEG
36242: PUSH
36243: LD_INT 0
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 1
36252: NEG
36253: PUSH
36254: LD_INT 1
36256: NEG
36257: PUSH
36258: EMPTY
36259: LIST
36260: LIST
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: LIST
36269: LIST
36270: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36271: LD_ADDR_VAR 0 63
36275: PUSH
36276: LD_INT 0
36278: PUSH
36279: LD_INT 0
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 0
36288: PUSH
36289: LD_INT 1
36291: NEG
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 1
36299: PUSH
36300: LD_INT 0
36302: PUSH
36303: EMPTY
36304: LIST
36305: LIST
36306: PUSH
36307: LD_INT 1
36309: PUSH
36310: LD_INT 1
36312: PUSH
36313: EMPTY
36314: LIST
36315: LIST
36316: PUSH
36317: LD_INT 0
36319: PUSH
36320: LD_INT 1
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 1
36329: NEG
36330: PUSH
36331: LD_INT 0
36333: PUSH
36334: EMPTY
36335: LIST
36336: LIST
36337: PUSH
36338: LD_INT 1
36340: NEG
36341: PUSH
36342: LD_INT 1
36344: NEG
36345: PUSH
36346: EMPTY
36347: LIST
36348: LIST
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: LIST
36358: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36359: LD_ADDR_VAR 0 64
36363: PUSH
36364: LD_INT 0
36366: PUSH
36367: LD_INT 0
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 0
36376: PUSH
36377: LD_INT 1
36379: NEG
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: LD_INT 0
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 1
36397: PUSH
36398: LD_INT 1
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 0
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: NEG
36418: PUSH
36419: LD_INT 0
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: LD_INT 1
36428: NEG
36429: PUSH
36430: LD_INT 1
36432: NEG
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: ST_TO_ADDR
// end ; 1 :
36447: GO 42344
36449: LD_INT 1
36451: DOUBLE
36452: EQUAL
36453: IFTRUE 36457
36455: GO 39080
36457: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36458: LD_ADDR_VAR 0 11
36462: PUSH
36463: LD_INT 1
36465: NEG
36466: PUSH
36467: LD_INT 3
36469: NEG
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: LD_INT 0
36477: PUSH
36478: LD_INT 3
36480: NEG
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 1
36488: PUSH
36489: LD_INT 2
36491: NEG
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: LIST
36501: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36502: LD_ADDR_VAR 0 12
36506: PUSH
36507: LD_INT 2
36509: PUSH
36510: LD_INT 1
36512: NEG
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 3
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 3
36530: PUSH
36531: LD_INT 1
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: LIST
36542: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36543: LD_ADDR_VAR 0 13
36547: PUSH
36548: LD_INT 3
36550: PUSH
36551: LD_INT 2
36553: PUSH
36554: EMPTY
36555: LIST
36556: LIST
36557: PUSH
36558: LD_INT 3
36560: PUSH
36561: LD_INT 3
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 2
36570: PUSH
36571: LD_INT 3
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: LIST
36582: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36583: LD_ADDR_VAR 0 14
36587: PUSH
36588: LD_INT 1
36590: PUSH
36591: LD_INT 3
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 0
36600: PUSH
36601: LD_INT 3
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: NEG
36611: PUSH
36612: LD_INT 2
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: LIST
36623: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36624: LD_ADDR_VAR 0 15
36628: PUSH
36629: LD_INT 2
36631: NEG
36632: PUSH
36633: LD_INT 1
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: PUSH
36640: LD_INT 3
36642: NEG
36643: PUSH
36644: LD_INT 0
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: LD_INT 3
36653: NEG
36654: PUSH
36655: LD_INT 1
36657: NEG
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: LIST
36667: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36668: LD_ADDR_VAR 0 16
36672: PUSH
36673: LD_INT 2
36675: NEG
36676: PUSH
36677: LD_INT 3
36679: NEG
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 3
36687: NEG
36688: PUSH
36689: LD_INT 2
36691: NEG
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 3
36699: NEG
36700: PUSH
36701: LD_INT 3
36703: NEG
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: LIST
36713: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36714: LD_ADDR_VAR 0 17
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: LD_INT 3
36725: NEG
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 0
36733: PUSH
36734: LD_INT 3
36736: NEG
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: LD_INT 2
36747: NEG
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: LIST
36757: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36758: LD_ADDR_VAR 0 18
36762: PUSH
36763: LD_INT 2
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 3
36776: PUSH
36777: LD_INT 0
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 3
36786: PUSH
36787: LD_INT 1
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: LIST
36798: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36799: LD_ADDR_VAR 0 19
36803: PUSH
36804: LD_INT 3
36806: PUSH
36807: LD_INT 2
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 3
36816: PUSH
36817: LD_INT 3
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 2
36826: PUSH
36827: LD_INT 3
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: LIST
36838: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36839: LD_ADDR_VAR 0 20
36843: PUSH
36844: LD_INT 1
36846: PUSH
36847: LD_INT 3
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: LD_INT 3
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: LD_INT 2
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: LIST
36879: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36880: LD_ADDR_VAR 0 21
36884: PUSH
36885: LD_INT 2
36887: NEG
36888: PUSH
36889: LD_INT 1
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 3
36898: NEG
36899: PUSH
36900: LD_INT 0
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 3
36909: NEG
36910: PUSH
36911: LD_INT 1
36913: NEG
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: LIST
36923: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36924: LD_ADDR_VAR 0 22
36928: PUSH
36929: LD_INT 2
36931: NEG
36932: PUSH
36933: LD_INT 3
36935: NEG
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 3
36943: NEG
36944: PUSH
36945: LD_INT 2
36947: NEG
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: PUSH
36953: LD_INT 3
36955: NEG
36956: PUSH
36957: LD_INT 3
36959: NEG
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: LIST
36969: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
36970: LD_ADDR_VAR 0 23
36974: PUSH
36975: LD_INT 0
36977: PUSH
36978: LD_INT 3
36980: NEG
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 1
36988: NEG
36989: PUSH
36990: LD_INT 4
36992: NEG
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: PUSH
36998: LD_INT 1
37000: PUSH
37001: LD_INT 3
37003: NEG
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: LIST
37013: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37014: LD_ADDR_VAR 0 24
37018: PUSH
37019: LD_INT 3
37021: PUSH
37022: LD_INT 0
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: PUSH
37029: LD_INT 3
37031: PUSH
37032: LD_INT 1
37034: NEG
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 4
37042: PUSH
37043: LD_INT 1
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: LIST
37054: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37055: LD_ADDR_VAR 0 25
37059: PUSH
37060: LD_INT 3
37062: PUSH
37063: LD_INT 3
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 4
37072: PUSH
37073: LD_INT 3
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 3
37082: PUSH
37083: LD_INT 4
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: LIST
37094: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37095: LD_ADDR_VAR 0 26
37099: PUSH
37100: LD_INT 0
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 1
37112: PUSH
37113: LD_INT 4
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 1
37122: NEG
37123: PUSH
37124: LD_INT 3
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: EMPTY
37132: LIST
37133: LIST
37134: LIST
37135: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37136: LD_ADDR_VAR 0 27
37140: PUSH
37141: LD_INT 3
37143: NEG
37144: PUSH
37145: LD_INT 0
37147: PUSH
37148: EMPTY
37149: LIST
37150: LIST
37151: PUSH
37152: LD_INT 3
37154: NEG
37155: PUSH
37156: LD_INT 1
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: LD_INT 4
37165: NEG
37166: PUSH
37167: LD_INT 1
37169: NEG
37170: PUSH
37171: EMPTY
37172: LIST
37173: LIST
37174: PUSH
37175: EMPTY
37176: LIST
37177: LIST
37178: LIST
37179: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37180: LD_ADDR_VAR 0 28
37184: PUSH
37185: LD_INT 3
37187: NEG
37188: PUSH
37189: LD_INT 3
37191: NEG
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 3
37199: NEG
37200: PUSH
37201: LD_INT 4
37203: NEG
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: PUSH
37209: LD_INT 4
37211: NEG
37212: PUSH
37213: LD_INT 3
37215: NEG
37216: PUSH
37217: EMPTY
37218: LIST
37219: LIST
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: LIST
37225: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37226: LD_ADDR_VAR 0 29
37230: PUSH
37231: LD_INT 1
37233: NEG
37234: PUSH
37235: LD_INT 3
37237: NEG
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: LD_INT 3
37248: NEG
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 1
37256: PUSH
37257: LD_INT 2
37259: NEG
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 1
37267: NEG
37268: PUSH
37269: LD_INT 4
37271: NEG
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 0
37279: PUSH
37280: LD_INT 4
37282: NEG
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 1
37290: PUSH
37291: LD_INT 3
37293: NEG
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: LD_INT 1
37301: NEG
37302: PUSH
37303: LD_INT 5
37305: NEG
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 0
37313: PUSH
37314: LD_INT 5
37316: NEG
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 1
37324: PUSH
37325: LD_INT 4
37327: NEG
37328: PUSH
37329: EMPTY
37330: LIST
37331: LIST
37332: PUSH
37333: LD_INT 1
37335: NEG
37336: PUSH
37337: LD_INT 6
37339: NEG
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 0
37347: PUSH
37348: LD_INT 6
37350: NEG
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: LD_INT 5
37361: NEG
37362: PUSH
37363: EMPTY
37364: LIST
37365: LIST
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: LIST
37375: LIST
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37381: LD_ADDR_VAR 0 30
37385: PUSH
37386: LD_INT 2
37388: PUSH
37389: LD_INT 1
37391: NEG
37392: PUSH
37393: EMPTY
37394: LIST
37395: LIST
37396: PUSH
37397: LD_INT 3
37399: PUSH
37400: LD_INT 0
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: LD_INT 3
37409: PUSH
37410: LD_INT 1
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: LD_INT 3
37419: PUSH
37420: LD_INT 1
37422: NEG
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 4
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 4
37440: PUSH
37441: LD_INT 1
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 4
37450: PUSH
37451: LD_INT 1
37453: NEG
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 5
37461: PUSH
37462: LD_INT 0
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 5
37471: PUSH
37472: LD_INT 1
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 5
37481: PUSH
37482: LD_INT 1
37484: NEG
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 6
37492: PUSH
37493: LD_INT 0
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: LD_INT 6
37502: PUSH
37503: LD_INT 1
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: EMPTY
37511: LIST
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37524: LD_ADDR_VAR 0 31
37528: PUSH
37529: LD_INT 3
37531: PUSH
37532: LD_INT 2
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 3
37541: PUSH
37542: LD_INT 3
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PUSH
37549: LD_INT 2
37551: PUSH
37552: LD_INT 3
37554: PUSH
37555: EMPTY
37556: LIST
37557: LIST
37558: PUSH
37559: LD_INT 4
37561: PUSH
37562: LD_INT 3
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 4
37571: PUSH
37572: LD_INT 4
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 3
37581: PUSH
37582: LD_INT 4
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 5
37591: PUSH
37592: LD_INT 4
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 5
37601: PUSH
37602: LD_INT 5
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 4
37611: PUSH
37612: LD_INT 5
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 6
37621: PUSH
37622: LD_INT 5
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 6
37631: PUSH
37632: LD_INT 6
37634: PUSH
37635: EMPTY
37636: LIST
37637: LIST
37638: PUSH
37639: LD_INT 5
37641: PUSH
37642: LD_INT 6
37644: PUSH
37645: EMPTY
37646: LIST
37647: LIST
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
37663: LD_ADDR_VAR 0 32
37667: PUSH
37668: LD_INT 1
37670: PUSH
37671: LD_INT 3
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PUSH
37678: LD_INT 0
37680: PUSH
37681: LD_INT 3
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PUSH
37688: LD_INT 1
37690: NEG
37691: PUSH
37692: LD_INT 2
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: PUSH
37702: LD_INT 4
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 0
37711: PUSH
37712: LD_INT 4
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 1
37721: NEG
37722: PUSH
37723: LD_INT 3
37725: PUSH
37726: EMPTY
37727: LIST
37728: LIST
37729: PUSH
37730: LD_INT 1
37732: PUSH
37733: LD_INT 5
37735: PUSH
37736: EMPTY
37737: LIST
37738: LIST
37739: PUSH
37740: LD_INT 0
37742: PUSH
37743: LD_INT 5
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 1
37752: NEG
37753: PUSH
37754: LD_INT 4
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 1
37763: PUSH
37764: LD_INT 6
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: PUSH
37771: LD_INT 0
37773: PUSH
37774: LD_INT 6
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 1
37783: NEG
37784: PUSH
37785: LD_INT 5
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
37806: LD_ADDR_VAR 0 33
37810: PUSH
37811: LD_INT 2
37813: NEG
37814: PUSH
37815: LD_INT 1
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 3
37824: NEG
37825: PUSH
37826: LD_INT 0
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 3
37835: NEG
37836: PUSH
37837: LD_INT 1
37839: NEG
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 3
37847: NEG
37848: PUSH
37849: LD_INT 1
37851: PUSH
37852: EMPTY
37853: LIST
37854: LIST
37855: PUSH
37856: LD_INT 4
37858: NEG
37859: PUSH
37860: LD_INT 0
37862: PUSH
37863: EMPTY
37864: LIST
37865: LIST
37866: PUSH
37867: LD_INT 4
37869: NEG
37870: PUSH
37871: LD_INT 1
37873: NEG
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 4
37881: NEG
37882: PUSH
37883: LD_INT 1
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 5
37892: NEG
37893: PUSH
37894: LD_INT 0
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: LD_INT 5
37903: NEG
37904: PUSH
37905: LD_INT 1
37907: NEG
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 5
37915: NEG
37916: PUSH
37917: LD_INT 1
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 6
37926: NEG
37927: PUSH
37928: LD_INT 0
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 6
37937: NEG
37938: PUSH
37939: LD_INT 1
37941: NEG
37942: PUSH
37943: EMPTY
37944: LIST
37945: LIST
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
37961: LD_ADDR_VAR 0 34
37965: PUSH
37966: LD_INT 2
37968: NEG
37969: PUSH
37970: LD_INT 3
37972: NEG
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 3
37980: NEG
37981: PUSH
37982: LD_INT 2
37984: NEG
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 3
37992: NEG
37993: PUSH
37994: LD_INT 3
37996: NEG
37997: PUSH
37998: EMPTY
37999: LIST
38000: LIST
38001: PUSH
38002: LD_INT 3
38004: NEG
38005: PUSH
38006: LD_INT 4
38008: NEG
38009: PUSH
38010: EMPTY
38011: LIST
38012: LIST
38013: PUSH
38014: LD_INT 4
38016: NEG
38017: PUSH
38018: LD_INT 3
38020: NEG
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 4
38028: NEG
38029: PUSH
38030: LD_INT 4
38032: NEG
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PUSH
38038: LD_INT 4
38040: NEG
38041: PUSH
38042: LD_INT 5
38044: NEG
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 5
38052: NEG
38053: PUSH
38054: LD_INT 4
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 5
38064: NEG
38065: PUSH
38066: LD_INT 5
38068: NEG
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 5
38076: NEG
38077: PUSH
38078: LD_INT 6
38080: NEG
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 6
38088: NEG
38089: PUSH
38090: LD_INT 5
38092: NEG
38093: PUSH
38094: EMPTY
38095: LIST
38096: LIST
38097: PUSH
38098: LD_INT 6
38100: NEG
38101: PUSH
38102: LD_INT 6
38104: NEG
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: LIST
38119: LIST
38120: LIST
38121: LIST
38122: LIST
38123: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38124: LD_ADDR_VAR 0 41
38128: PUSH
38129: LD_INT 0
38131: PUSH
38132: LD_INT 2
38134: NEG
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 1
38142: NEG
38143: PUSH
38144: LD_INT 3
38146: NEG
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: LD_INT 1
38154: PUSH
38155: LD_INT 2
38157: NEG
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: LIST
38167: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38168: LD_ADDR_VAR 0 42
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: LD_INT 0
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: PUSH
38183: LD_INT 2
38185: PUSH
38186: LD_INT 1
38188: NEG
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 3
38196: PUSH
38197: LD_INT 1
38199: PUSH
38200: EMPTY
38201: LIST
38202: LIST
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: LIST
38208: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38209: LD_ADDR_VAR 0 43
38213: PUSH
38214: LD_INT 2
38216: PUSH
38217: LD_INT 2
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: LD_INT 3
38226: PUSH
38227: LD_INT 2
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 2
38236: PUSH
38237: LD_INT 3
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: LIST
38248: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38249: LD_ADDR_VAR 0 44
38253: PUSH
38254: LD_INT 0
38256: PUSH
38257: LD_INT 2
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 1
38266: PUSH
38267: LD_INT 3
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 1
38276: NEG
38277: PUSH
38278: LD_INT 2
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: LIST
38289: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38290: LD_ADDR_VAR 0 45
38294: PUSH
38295: LD_INT 2
38297: NEG
38298: PUSH
38299: LD_INT 0
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 2
38308: NEG
38309: PUSH
38310: LD_INT 1
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 3
38319: NEG
38320: PUSH
38321: LD_INT 1
38323: NEG
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: EMPTY
38330: LIST
38331: LIST
38332: LIST
38333: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38334: LD_ADDR_VAR 0 46
38338: PUSH
38339: LD_INT 2
38341: NEG
38342: PUSH
38343: LD_INT 2
38345: NEG
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 2
38353: NEG
38354: PUSH
38355: LD_INT 3
38357: NEG
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 3
38365: NEG
38366: PUSH
38367: LD_INT 2
38369: NEG
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: LIST
38379: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38380: LD_ADDR_VAR 0 47
38384: PUSH
38385: LD_INT 2
38387: NEG
38388: PUSH
38389: LD_INT 3
38391: NEG
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 1
38399: NEG
38400: PUSH
38401: LD_INT 3
38403: NEG
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38413: LD_ADDR_VAR 0 48
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: LD_INT 2
38423: NEG
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 2
38431: PUSH
38432: LD_INT 1
38434: NEG
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38444: LD_ADDR_VAR 0 49
38448: PUSH
38449: LD_INT 3
38451: PUSH
38452: LD_INT 1
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 3
38461: PUSH
38462: LD_INT 2
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38473: LD_ADDR_VAR 0 50
38477: PUSH
38478: LD_INT 2
38480: PUSH
38481: LD_INT 3
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 1
38490: PUSH
38491: LD_INT 3
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38502: LD_ADDR_VAR 0 51
38506: PUSH
38507: LD_INT 1
38509: NEG
38510: PUSH
38511: LD_INT 2
38513: PUSH
38514: EMPTY
38515: LIST
38516: LIST
38517: PUSH
38518: LD_INT 2
38520: NEG
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38533: LD_ADDR_VAR 0 52
38537: PUSH
38538: LD_INT 3
38540: NEG
38541: PUSH
38542: LD_INT 1
38544: NEG
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 3
38552: NEG
38553: PUSH
38554: LD_INT 2
38556: NEG
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38566: LD_ADDR_VAR 0 53
38570: PUSH
38571: LD_INT 1
38573: NEG
38574: PUSH
38575: LD_INT 3
38577: NEG
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 0
38585: PUSH
38586: LD_INT 3
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: LD_INT 2
38599: NEG
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: LIST
38609: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38610: LD_ADDR_VAR 0 54
38614: PUSH
38615: LD_INT 2
38617: PUSH
38618: LD_INT 1
38620: NEG
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: PUSH
38626: LD_INT 3
38628: PUSH
38629: LD_INT 0
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 3
38638: PUSH
38639: LD_INT 1
38641: PUSH
38642: EMPTY
38643: LIST
38644: LIST
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: LIST
38650: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38651: LD_ADDR_VAR 0 55
38655: PUSH
38656: LD_INT 3
38658: PUSH
38659: LD_INT 2
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 3
38668: PUSH
38669: LD_INT 3
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 2
38678: PUSH
38679: LD_INT 3
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: LIST
38690: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38691: LD_ADDR_VAR 0 56
38695: PUSH
38696: LD_INT 1
38698: PUSH
38699: LD_INT 3
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: LD_INT 3
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 1
38718: NEG
38719: PUSH
38720: LD_INT 2
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: LIST
38731: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38732: LD_ADDR_VAR 0 57
38736: PUSH
38737: LD_INT 2
38739: NEG
38740: PUSH
38741: LD_INT 1
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 3
38750: NEG
38751: PUSH
38752: LD_INT 0
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 3
38761: NEG
38762: PUSH
38763: LD_INT 1
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: LIST
38775: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38776: LD_ADDR_VAR 0 58
38780: PUSH
38781: LD_INT 2
38783: NEG
38784: PUSH
38785: LD_INT 3
38787: NEG
38788: PUSH
38789: EMPTY
38790: LIST
38791: LIST
38792: PUSH
38793: LD_INT 3
38795: NEG
38796: PUSH
38797: LD_INT 2
38799: NEG
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 3
38807: NEG
38808: PUSH
38809: LD_INT 3
38811: NEG
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: LIST
38821: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
38822: LD_ADDR_VAR 0 59
38826: PUSH
38827: LD_INT 1
38829: NEG
38830: PUSH
38831: LD_INT 2
38833: NEG
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: LD_INT 2
38844: NEG
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 1
38852: PUSH
38853: LD_INT 1
38855: NEG
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: LIST
38865: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38866: LD_ADDR_VAR 0 60
38870: PUSH
38871: LD_INT 1
38873: PUSH
38874: LD_INT 1
38876: NEG
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 2
38884: PUSH
38885: LD_INT 0
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 2
38894: PUSH
38895: LD_INT 1
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: LIST
38906: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38907: LD_ADDR_VAR 0 61
38911: PUSH
38912: LD_INT 2
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 2
38924: PUSH
38925: LD_INT 2
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: LD_INT 2
38937: PUSH
38938: EMPTY
38939: LIST
38940: LIST
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: LIST
38946: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38947: LD_ADDR_VAR 0 62
38951: PUSH
38952: LD_INT 1
38954: PUSH
38955: LD_INT 2
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 0
38964: PUSH
38965: LD_INT 2
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 1
38974: NEG
38975: PUSH
38976: LD_INT 1
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: LIST
38987: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38988: LD_ADDR_VAR 0 63
38992: PUSH
38993: LD_INT 1
38995: NEG
38996: PUSH
38997: LD_INT 1
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 2
39006: NEG
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 2
39017: NEG
39018: PUSH
39019: LD_INT 1
39021: NEG
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: EMPTY
39028: LIST
39029: LIST
39030: LIST
39031: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39032: LD_ADDR_VAR 0 64
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: LD_INT 2
39043: NEG
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 2
39051: NEG
39052: PUSH
39053: LD_INT 1
39055: NEG
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 2
39063: NEG
39064: PUSH
39065: LD_INT 2
39067: NEG
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: LIST
39077: ST_TO_ADDR
// end ; 2 :
39078: GO 42344
39080: LD_INT 2
39082: DOUBLE
39083: EQUAL
39084: IFTRUE 39088
39086: GO 42343
39088: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39089: LD_ADDR_VAR 0 29
39093: PUSH
39094: LD_INT 4
39096: PUSH
39097: LD_INT 0
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 4
39106: PUSH
39107: LD_INT 1
39109: NEG
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 5
39117: PUSH
39118: LD_INT 0
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 5
39127: PUSH
39128: LD_INT 1
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 4
39137: PUSH
39138: LD_INT 1
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 3
39147: PUSH
39148: LD_INT 0
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 3
39157: PUSH
39158: LD_INT 1
39160: NEG
39161: PUSH
39162: EMPTY
39163: LIST
39164: LIST
39165: PUSH
39166: LD_INT 3
39168: PUSH
39169: LD_INT 2
39171: NEG
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 5
39179: PUSH
39180: LD_INT 2
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 3
39189: PUSH
39190: LD_INT 3
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: LD_INT 3
39199: PUSH
39200: LD_INT 2
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: LD_INT 4
39209: PUSH
39210: LD_INT 3
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 4
39219: PUSH
39220: LD_INT 4
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: LD_INT 3
39229: PUSH
39230: LD_INT 4
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 2
39239: PUSH
39240: LD_INT 3
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 2
39249: PUSH
39250: LD_INT 2
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 4
39259: PUSH
39260: LD_INT 2
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 2
39269: PUSH
39270: LD_INT 4
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 0
39279: PUSH
39280: LD_INT 4
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 0
39289: PUSH
39290: LD_INT 3
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 1
39299: PUSH
39300: LD_INT 4
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 1
39309: PUSH
39310: LD_INT 5
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: PUSH
39317: LD_INT 0
39319: PUSH
39320: LD_INT 5
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PUSH
39327: LD_INT 1
39329: NEG
39330: PUSH
39331: LD_INT 4
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 1
39340: NEG
39341: PUSH
39342: LD_INT 3
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 2
39351: PUSH
39352: LD_INT 5
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 2
39361: NEG
39362: PUSH
39363: LD_INT 3
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 3
39372: NEG
39373: PUSH
39374: LD_INT 0
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 3
39383: NEG
39384: PUSH
39385: LD_INT 1
39387: NEG
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: LD_INT 0
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 2
39406: NEG
39407: PUSH
39408: LD_INT 1
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 3
39417: NEG
39418: PUSH
39419: LD_INT 1
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 4
39428: NEG
39429: PUSH
39430: LD_INT 0
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 4
39439: NEG
39440: PUSH
39441: LD_INT 1
39443: NEG
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 4
39451: NEG
39452: PUSH
39453: LD_INT 2
39455: NEG
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 2
39463: NEG
39464: PUSH
39465: LD_INT 2
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 4
39474: NEG
39475: PUSH
39476: LD_INT 4
39478: NEG
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 4
39486: NEG
39487: PUSH
39488: LD_INT 5
39490: NEG
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 3
39498: NEG
39499: PUSH
39500: LD_INT 4
39502: NEG
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 3
39510: NEG
39511: PUSH
39512: LD_INT 3
39514: NEG
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 4
39522: NEG
39523: PUSH
39524: LD_INT 3
39526: NEG
39527: PUSH
39528: EMPTY
39529: LIST
39530: LIST
39531: PUSH
39532: LD_INT 5
39534: NEG
39535: PUSH
39536: LD_INT 4
39538: NEG
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 5
39546: NEG
39547: PUSH
39548: LD_INT 5
39550: NEG
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 3
39558: NEG
39559: PUSH
39560: LD_INT 5
39562: NEG
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 5
39570: NEG
39571: PUSH
39572: LD_INT 3
39574: NEG
39575: PUSH
39576: EMPTY
39577: LIST
39578: LIST
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: LIST
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: LIST
39589: LIST
39590: LIST
39591: LIST
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: LIST
39597: LIST
39598: LIST
39599: LIST
39600: LIST
39601: LIST
39602: LIST
39603: LIST
39604: LIST
39605: LIST
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
39627: LD_ADDR_VAR 0 30
39631: PUSH
39632: LD_INT 4
39634: PUSH
39635: LD_INT 4
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 4
39644: PUSH
39645: LD_INT 3
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 5
39654: PUSH
39655: LD_INT 4
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 5
39664: PUSH
39665: LD_INT 5
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 4
39674: PUSH
39675: LD_INT 5
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 3
39684: PUSH
39685: LD_INT 4
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 3
39694: PUSH
39695: LD_INT 3
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 5
39704: PUSH
39705: LD_INT 3
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 3
39714: PUSH
39715: LD_INT 5
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 0
39724: PUSH
39725: LD_INT 3
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 0
39734: PUSH
39735: LD_INT 2
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 1
39744: PUSH
39745: LD_INT 3
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 1
39754: PUSH
39755: LD_INT 4
39757: PUSH
39758: EMPTY
39759: LIST
39760: LIST
39761: PUSH
39762: LD_INT 0
39764: PUSH
39765: LD_INT 4
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: PUSH
39772: LD_INT 1
39774: NEG
39775: PUSH
39776: LD_INT 3
39778: PUSH
39779: EMPTY
39780: LIST
39781: LIST
39782: PUSH
39783: LD_INT 1
39785: NEG
39786: PUSH
39787: LD_INT 2
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 2
39796: PUSH
39797: LD_INT 4
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 2
39806: NEG
39807: PUSH
39808: LD_INT 2
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 4
39817: NEG
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 4
39828: NEG
39829: PUSH
39830: LD_INT 1
39832: NEG
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PUSH
39838: LD_INT 3
39840: NEG
39841: PUSH
39842: LD_INT 0
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 3
39851: NEG
39852: PUSH
39853: LD_INT 1
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 4
39862: NEG
39863: PUSH
39864: LD_INT 1
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 5
39873: NEG
39874: PUSH
39875: LD_INT 0
39877: PUSH
39878: EMPTY
39879: LIST
39880: LIST
39881: PUSH
39882: LD_INT 5
39884: NEG
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: LD_INT 5
39896: NEG
39897: PUSH
39898: LD_INT 2
39900: NEG
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 3
39908: NEG
39909: PUSH
39910: LD_INT 2
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 3
39919: NEG
39920: PUSH
39921: LD_INT 3
39923: NEG
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 3
39931: NEG
39932: PUSH
39933: LD_INT 4
39935: NEG
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 2
39943: NEG
39944: PUSH
39945: LD_INT 3
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 2
39955: NEG
39956: PUSH
39957: LD_INT 2
39959: NEG
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 3
39967: NEG
39968: PUSH
39969: LD_INT 2
39971: NEG
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 4
39979: NEG
39980: PUSH
39981: LD_INT 3
39983: NEG
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 4
39991: NEG
39992: PUSH
39993: LD_INT 4
39995: NEG
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 2
40003: NEG
40004: PUSH
40005: LD_INT 4
40007: NEG
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 4
40015: NEG
40016: PUSH
40017: LD_INT 2
40019: NEG
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 0
40027: PUSH
40028: LD_INT 4
40030: NEG
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 0
40038: PUSH
40039: LD_INT 5
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 1
40049: PUSH
40050: LD_INT 4
40052: NEG
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 1
40060: PUSH
40061: LD_INT 3
40063: NEG
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 3
40074: NEG
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 1
40082: NEG
40083: PUSH
40084: LD_INT 4
40086: NEG
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 1
40094: NEG
40095: PUSH
40096: LD_INT 5
40098: NEG
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 2
40106: PUSH
40107: LD_INT 3
40109: NEG
40110: PUSH
40111: EMPTY
40112: LIST
40113: LIST
40114: PUSH
40115: LD_INT 2
40117: NEG
40118: PUSH
40119: LD_INT 5
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: LIST
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: LIST
40171: LIST
40172: LIST
40173: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40174: LD_ADDR_VAR 0 31
40178: PUSH
40179: LD_INT 0
40181: PUSH
40182: LD_INT 4
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 0
40191: PUSH
40192: LD_INT 3
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 1
40201: PUSH
40202: LD_INT 4
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 1
40211: PUSH
40212: LD_INT 5
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 0
40221: PUSH
40222: LD_INT 5
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 1
40231: NEG
40232: PUSH
40233: LD_INT 4
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 1
40242: NEG
40243: PUSH
40244: LD_INT 3
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 2
40253: PUSH
40254: LD_INT 5
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 2
40263: NEG
40264: PUSH
40265: LD_INT 3
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PUSH
40272: LD_INT 3
40274: NEG
40275: PUSH
40276: LD_INT 0
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: PUSH
40283: LD_INT 3
40285: NEG
40286: PUSH
40287: LD_INT 1
40289: NEG
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 2
40297: NEG
40298: PUSH
40299: LD_INT 0
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 2
40308: NEG
40309: PUSH
40310: LD_INT 1
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 3
40319: NEG
40320: PUSH
40321: LD_INT 1
40323: PUSH
40324: EMPTY
40325: LIST
40326: LIST
40327: PUSH
40328: LD_INT 4
40330: NEG
40331: PUSH
40332: LD_INT 0
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 4
40341: NEG
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 4
40353: NEG
40354: PUSH
40355: LD_INT 2
40357: NEG
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 2
40365: NEG
40366: PUSH
40367: LD_INT 2
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 4
40376: NEG
40377: PUSH
40378: LD_INT 4
40380: NEG
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 4
40388: NEG
40389: PUSH
40390: LD_INT 5
40392: NEG
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 3
40400: NEG
40401: PUSH
40402: LD_INT 4
40404: NEG
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 3
40412: NEG
40413: PUSH
40414: LD_INT 3
40416: NEG
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 4
40424: NEG
40425: PUSH
40426: LD_INT 3
40428: NEG
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 5
40436: NEG
40437: PUSH
40438: LD_INT 4
40440: NEG
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 5
40448: NEG
40449: PUSH
40450: LD_INT 5
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 3
40460: NEG
40461: PUSH
40462: LD_INT 5
40464: NEG
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 5
40472: NEG
40473: PUSH
40474: LD_INT 3
40476: NEG
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 0
40484: PUSH
40485: LD_INT 3
40487: NEG
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 0
40495: PUSH
40496: LD_INT 4
40498: NEG
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 1
40506: PUSH
40507: LD_INT 3
40509: NEG
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: PUSH
40518: LD_INT 2
40520: NEG
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 0
40528: PUSH
40529: LD_INT 2
40531: NEG
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 1
40539: NEG
40540: PUSH
40541: LD_INT 3
40543: NEG
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: LD_INT 4
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 2
40563: PUSH
40564: LD_INT 2
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 2
40574: NEG
40575: PUSH
40576: LD_INT 4
40578: NEG
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 4
40586: PUSH
40587: LD_INT 0
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 4
40596: PUSH
40597: LD_INT 1
40599: NEG
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: LD_INT 5
40607: PUSH
40608: LD_INT 0
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 5
40617: PUSH
40618: LD_INT 1
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 4
40627: PUSH
40628: LD_INT 1
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 3
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 3
40647: PUSH
40648: LD_INT 1
40650: NEG
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 3
40658: PUSH
40659: LD_INT 2
40661: NEG
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 5
40669: PUSH
40670: LD_INT 2
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
40724: LD_ADDR_VAR 0 32
40728: PUSH
40729: LD_INT 4
40731: NEG
40732: PUSH
40733: LD_INT 0
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: PUSH
40740: LD_INT 4
40742: NEG
40743: PUSH
40744: LD_INT 1
40746: NEG
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 3
40754: NEG
40755: PUSH
40756: LD_INT 0
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 3
40765: NEG
40766: PUSH
40767: LD_INT 1
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 4
40776: NEG
40777: PUSH
40778: LD_INT 1
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 5
40787: NEG
40788: PUSH
40789: LD_INT 0
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 5
40798: NEG
40799: PUSH
40800: LD_INT 1
40802: NEG
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 5
40810: NEG
40811: PUSH
40812: LD_INT 2
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: LD_INT 2
40826: PUSH
40827: EMPTY
40828: LIST
40829: LIST
40830: PUSH
40831: LD_INT 3
40833: NEG
40834: PUSH
40835: LD_INT 3
40837: NEG
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 3
40845: NEG
40846: PUSH
40847: LD_INT 4
40849: NEG
40850: PUSH
40851: EMPTY
40852: LIST
40853: LIST
40854: PUSH
40855: LD_INT 2
40857: NEG
40858: PUSH
40859: LD_INT 3
40861: NEG
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 2
40869: NEG
40870: PUSH
40871: LD_INT 2
40873: NEG
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 3
40881: NEG
40882: PUSH
40883: LD_INT 2
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 4
40893: NEG
40894: PUSH
40895: LD_INT 3
40897: NEG
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 4
40905: NEG
40906: PUSH
40907: LD_INT 4
40909: NEG
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 2
40917: NEG
40918: PUSH
40919: LD_INT 4
40921: NEG
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 4
40929: NEG
40930: PUSH
40931: LD_INT 2
40933: NEG
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 0
40941: PUSH
40942: LD_INT 4
40944: NEG
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 0
40952: PUSH
40953: LD_INT 5
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: PUSH
40964: LD_INT 4
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 1
40974: PUSH
40975: LD_INT 3
40977: NEG
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: LD_INT 0
40985: PUSH
40986: LD_INT 3
40988: NEG
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: LD_INT 1
40996: NEG
40997: PUSH
40998: LD_INT 4
41000: NEG
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 1
41008: NEG
41009: PUSH
41010: LD_INT 5
41012: NEG
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: PUSH
41018: LD_INT 2
41020: PUSH
41021: LD_INT 3
41023: NEG
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 2
41031: NEG
41032: PUSH
41033: LD_INT 5
41035: NEG
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 3
41043: PUSH
41044: LD_INT 0
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 3
41053: PUSH
41054: LD_INT 1
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: LD_INT 4
41064: PUSH
41065: LD_INT 0
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 4
41074: PUSH
41075: LD_INT 1
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 3
41084: PUSH
41085: LD_INT 1
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: LD_INT 2
41094: PUSH
41095: LD_INT 0
41097: PUSH
41098: EMPTY
41099: LIST
41100: LIST
41101: PUSH
41102: LD_INT 2
41104: PUSH
41105: LD_INT 1
41107: NEG
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: LD_INT 2
41115: PUSH
41116: LD_INT 2
41118: NEG
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: LD_INT 4
41126: PUSH
41127: LD_INT 2
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: PUSH
41134: LD_INT 4
41136: PUSH
41137: LD_INT 4
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 4
41146: PUSH
41147: LD_INT 3
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: LD_INT 5
41156: PUSH
41157: LD_INT 4
41159: PUSH
41160: EMPTY
41161: LIST
41162: LIST
41163: PUSH
41164: LD_INT 5
41166: PUSH
41167: LD_INT 5
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 4
41176: PUSH
41177: LD_INT 5
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 3
41186: PUSH
41187: LD_INT 4
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: LD_INT 3
41196: PUSH
41197: LD_INT 3
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: PUSH
41204: LD_INT 5
41206: PUSH
41207: LD_INT 3
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 3
41216: PUSH
41217: LD_INT 5
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: LIST
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: LIST
41257: LIST
41258: LIST
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: LIST
41266: LIST
41267: LIST
41268: LIST
41269: LIST
41270: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41271: LD_ADDR_VAR 0 33
41275: PUSH
41276: LD_INT 4
41278: NEG
41279: PUSH
41280: LD_INT 4
41282: NEG
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 4
41290: NEG
41291: PUSH
41292: LD_INT 5
41294: NEG
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 3
41302: NEG
41303: PUSH
41304: LD_INT 4
41306: NEG
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 3
41314: NEG
41315: PUSH
41316: LD_INT 3
41318: NEG
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: LD_INT 4
41326: NEG
41327: PUSH
41328: LD_INT 3
41330: NEG
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 5
41338: NEG
41339: PUSH
41340: LD_INT 4
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 5
41350: NEG
41351: PUSH
41352: LD_INT 5
41354: NEG
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 3
41362: NEG
41363: PUSH
41364: LD_INT 5
41366: NEG
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 5
41374: NEG
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: LD_INT 0
41386: PUSH
41387: LD_INT 3
41389: NEG
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 0
41397: PUSH
41398: LD_INT 4
41400: NEG
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 1
41408: PUSH
41409: LD_INT 3
41411: NEG
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: LD_INT 1
41419: PUSH
41420: LD_INT 2
41422: NEG
41423: PUSH
41424: EMPTY
41425: LIST
41426: LIST
41427: PUSH
41428: LD_INT 0
41430: PUSH
41431: LD_INT 2
41433: NEG
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 1
41441: NEG
41442: PUSH
41443: LD_INT 3
41445: NEG
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 1
41453: NEG
41454: PUSH
41455: LD_INT 4
41457: NEG
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: LD_INT 2
41465: PUSH
41466: LD_INT 2
41468: NEG
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 2
41476: NEG
41477: PUSH
41478: LD_INT 4
41480: NEG
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PUSH
41486: LD_INT 4
41488: PUSH
41489: LD_INT 0
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 4
41498: PUSH
41499: LD_INT 1
41501: NEG
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 5
41509: PUSH
41510: LD_INT 0
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 5
41519: PUSH
41520: LD_INT 1
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 4
41529: PUSH
41530: LD_INT 1
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: LD_INT 3
41539: PUSH
41540: LD_INT 0
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PUSH
41547: LD_INT 3
41549: PUSH
41550: LD_INT 1
41552: NEG
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: LD_INT 3
41560: PUSH
41561: LD_INT 2
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 5
41571: PUSH
41572: LD_INT 2
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 3
41581: PUSH
41582: LD_INT 3
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: PUSH
41589: LD_INT 3
41591: PUSH
41592: LD_INT 2
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 4
41601: PUSH
41602: LD_INT 3
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PUSH
41609: LD_INT 4
41611: PUSH
41612: LD_INT 4
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 3
41621: PUSH
41622: LD_INT 4
41624: PUSH
41625: EMPTY
41626: LIST
41627: LIST
41628: PUSH
41629: LD_INT 2
41631: PUSH
41632: LD_INT 3
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 2
41641: PUSH
41642: LD_INT 2
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 4
41651: PUSH
41652: LD_INT 2
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 2
41661: PUSH
41662: LD_INT 4
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: PUSH
41669: LD_INT 0
41671: PUSH
41672: LD_INT 4
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: PUSH
41679: LD_INT 0
41681: PUSH
41682: LD_INT 3
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 1
41691: PUSH
41692: LD_INT 4
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 1
41701: PUSH
41702: LD_INT 5
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 0
41711: PUSH
41712: LD_INT 5
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: LD_INT 1
41721: NEG
41722: PUSH
41723: LD_INT 4
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 1
41732: NEG
41733: PUSH
41734: LD_INT 3
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 2
41743: PUSH
41744: LD_INT 5
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: PUSH
41751: LD_INT 2
41753: NEG
41754: PUSH
41755: LD_INT 3
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
41809: LD_ADDR_VAR 0 34
41813: PUSH
41814: LD_INT 0
41816: PUSH
41817: LD_INT 4
41819: NEG
41820: PUSH
41821: EMPTY
41822: LIST
41823: LIST
41824: PUSH
41825: LD_INT 0
41827: PUSH
41828: LD_INT 5
41830: NEG
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: LD_INT 1
41838: PUSH
41839: LD_INT 4
41841: NEG
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 1
41849: PUSH
41850: LD_INT 3
41852: NEG
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 0
41860: PUSH
41861: LD_INT 3
41863: NEG
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 1
41871: NEG
41872: PUSH
41873: LD_INT 4
41875: NEG
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 1
41883: NEG
41884: PUSH
41885: LD_INT 5
41887: NEG
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: LD_INT 2
41895: PUSH
41896: LD_INT 3
41898: NEG
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 2
41906: NEG
41907: PUSH
41908: LD_INT 5
41910: NEG
41911: PUSH
41912: EMPTY
41913: LIST
41914: LIST
41915: PUSH
41916: LD_INT 3
41918: PUSH
41919: LD_INT 0
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 3
41928: PUSH
41929: LD_INT 1
41931: NEG
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: PUSH
41937: LD_INT 4
41939: PUSH
41940: LD_INT 0
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: PUSH
41947: LD_INT 4
41949: PUSH
41950: LD_INT 1
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: LD_INT 3
41959: PUSH
41960: LD_INT 1
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: PUSH
41967: LD_INT 2
41969: PUSH
41970: LD_INT 0
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 2
41979: PUSH
41980: LD_INT 1
41982: NEG
41983: PUSH
41984: EMPTY
41985: LIST
41986: LIST
41987: PUSH
41988: LD_INT 2
41990: PUSH
41991: LD_INT 2
41993: NEG
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 4
42001: PUSH
42002: LD_INT 2
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 4
42011: PUSH
42012: LD_INT 4
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 4
42021: PUSH
42022: LD_INT 3
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 5
42031: PUSH
42032: LD_INT 4
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 5
42041: PUSH
42042: LD_INT 5
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 4
42051: PUSH
42052: LD_INT 5
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 3
42061: PUSH
42062: LD_INT 4
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 3
42071: PUSH
42072: LD_INT 3
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 5
42081: PUSH
42082: LD_INT 3
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 3
42091: PUSH
42092: LD_INT 5
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 0
42101: PUSH
42102: LD_INT 3
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 0
42111: PUSH
42112: LD_INT 2
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 1
42121: PUSH
42122: LD_INT 3
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 1
42131: PUSH
42132: LD_INT 4
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: LD_INT 4
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 1
42151: NEG
42152: PUSH
42153: LD_INT 3
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 1
42162: NEG
42163: PUSH
42164: LD_INT 2
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 2
42173: PUSH
42174: LD_INT 4
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 2
42183: NEG
42184: PUSH
42185: LD_INT 2
42187: PUSH
42188: EMPTY
42189: LIST
42190: LIST
42191: PUSH
42192: LD_INT 4
42194: NEG
42195: PUSH
42196: LD_INT 0
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 4
42205: NEG
42206: PUSH
42207: LD_INT 1
42209: NEG
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: LD_INT 3
42217: NEG
42218: PUSH
42219: LD_INT 0
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: LD_INT 3
42228: NEG
42229: PUSH
42230: LD_INT 1
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 4
42239: NEG
42240: PUSH
42241: LD_INT 1
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: PUSH
42248: LD_INT 5
42250: NEG
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: LD_INT 5
42261: NEG
42262: PUSH
42263: LD_INT 1
42265: NEG
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 5
42273: NEG
42274: PUSH
42275: LD_INT 2
42277: NEG
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 3
42285: NEG
42286: PUSH
42287: LD_INT 2
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: LIST
42319: LIST
42320: LIST
42321: LIST
42322: LIST
42323: LIST
42324: LIST
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: LIST
42331: LIST
42332: LIST
42333: LIST
42334: LIST
42335: LIST
42336: LIST
42337: LIST
42338: LIST
42339: LIST
42340: ST_TO_ADDR
// end ; end ;
42341: GO 42344
42343: POP
// case btype of b_depot , b_warehouse :
42344: LD_VAR 0 1
42348: PUSH
42349: LD_INT 0
42351: DOUBLE
42352: EQUAL
42353: IFTRUE 42363
42355: LD_INT 1
42357: DOUBLE
42358: EQUAL
42359: IFTRUE 42363
42361: GO 42564
42363: POP
// case nation of nation_american :
42364: LD_VAR 0 5
42368: PUSH
42369: LD_INT 1
42371: DOUBLE
42372: EQUAL
42373: IFTRUE 42377
42375: GO 42433
42377: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42378: LD_ADDR_VAR 0 9
42382: PUSH
42383: LD_VAR 0 11
42387: PUSH
42388: LD_VAR 0 12
42392: PUSH
42393: LD_VAR 0 13
42397: PUSH
42398: LD_VAR 0 14
42402: PUSH
42403: LD_VAR 0 15
42407: PUSH
42408: LD_VAR 0 16
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: PUSH
42421: LD_VAR 0 4
42425: PUSH
42426: LD_INT 1
42428: PLUS
42429: ARRAY
42430: ST_TO_ADDR
42431: GO 42562
42433: LD_INT 2
42435: DOUBLE
42436: EQUAL
42437: IFTRUE 42441
42439: GO 42497
42441: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42442: LD_ADDR_VAR 0 9
42446: PUSH
42447: LD_VAR 0 17
42451: PUSH
42452: LD_VAR 0 18
42456: PUSH
42457: LD_VAR 0 19
42461: PUSH
42462: LD_VAR 0 20
42466: PUSH
42467: LD_VAR 0 21
42471: PUSH
42472: LD_VAR 0 22
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: LIST
42484: PUSH
42485: LD_VAR 0 4
42489: PUSH
42490: LD_INT 1
42492: PLUS
42493: ARRAY
42494: ST_TO_ADDR
42495: GO 42562
42497: LD_INT 3
42499: DOUBLE
42500: EQUAL
42501: IFTRUE 42505
42503: GO 42561
42505: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42506: LD_ADDR_VAR 0 9
42510: PUSH
42511: LD_VAR 0 23
42515: PUSH
42516: LD_VAR 0 24
42520: PUSH
42521: LD_VAR 0 25
42525: PUSH
42526: LD_VAR 0 26
42530: PUSH
42531: LD_VAR 0 27
42535: PUSH
42536: LD_VAR 0 28
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: LIST
42545: LIST
42546: LIST
42547: LIST
42548: PUSH
42549: LD_VAR 0 4
42553: PUSH
42554: LD_INT 1
42556: PLUS
42557: ARRAY
42558: ST_TO_ADDR
42559: GO 42562
42561: POP
42562: GO 43117
42564: LD_INT 2
42566: DOUBLE
42567: EQUAL
42568: IFTRUE 42578
42570: LD_INT 3
42572: DOUBLE
42573: EQUAL
42574: IFTRUE 42578
42576: GO 42634
42578: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42579: LD_ADDR_VAR 0 9
42583: PUSH
42584: LD_VAR 0 29
42588: PUSH
42589: LD_VAR 0 30
42593: PUSH
42594: LD_VAR 0 31
42598: PUSH
42599: LD_VAR 0 32
42603: PUSH
42604: LD_VAR 0 33
42608: PUSH
42609: LD_VAR 0 34
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: PUSH
42622: LD_VAR 0 4
42626: PUSH
42627: LD_INT 1
42629: PLUS
42630: ARRAY
42631: ST_TO_ADDR
42632: GO 43117
42634: LD_INT 16
42636: DOUBLE
42637: EQUAL
42638: IFTRUE 42696
42640: LD_INT 17
42642: DOUBLE
42643: EQUAL
42644: IFTRUE 42696
42646: LD_INT 18
42648: DOUBLE
42649: EQUAL
42650: IFTRUE 42696
42652: LD_INT 19
42654: DOUBLE
42655: EQUAL
42656: IFTRUE 42696
42658: LD_INT 22
42660: DOUBLE
42661: EQUAL
42662: IFTRUE 42696
42664: LD_INT 20
42666: DOUBLE
42667: EQUAL
42668: IFTRUE 42696
42670: LD_INT 21
42672: DOUBLE
42673: EQUAL
42674: IFTRUE 42696
42676: LD_INT 23
42678: DOUBLE
42679: EQUAL
42680: IFTRUE 42696
42682: LD_INT 24
42684: DOUBLE
42685: EQUAL
42686: IFTRUE 42696
42688: LD_INT 25
42690: DOUBLE
42691: EQUAL
42692: IFTRUE 42696
42694: GO 42752
42696: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
42697: LD_ADDR_VAR 0 9
42701: PUSH
42702: LD_VAR 0 35
42706: PUSH
42707: LD_VAR 0 36
42711: PUSH
42712: LD_VAR 0 37
42716: PUSH
42717: LD_VAR 0 38
42721: PUSH
42722: LD_VAR 0 39
42726: PUSH
42727: LD_VAR 0 40
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: PUSH
42740: LD_VAR 0 4
42744: PUSH
42745: LD_INT 1
42747: PLUS
42748: ARRAY
42749: ST_TO_ADDR
42750: GO 43117
42752: LD_INT 6
42754: DOUBLE
42755: EQUAL
42756: IFTRUE 42808
42758: LD_INT 7
42760: DOUBLE
42761: EQUAL
42762: IFTRUE 42808
42764: LD_INT 8
42766: DOUBLE
42767: EQUAL
42768: IFTRUE 42808
42770: LD_INT 13
42772: DOUBLE
42773: EQUAL
42774: IFTRUE 42808
42776: LD_INT 12
42778: DOUBLE
42779: EQUAL
42780: IFTRUE 42808
42782: LD_INT 15
42784: DOUBLE
42785: EQUAL
42786: IFTRUE 42808
42788: LD_INT 11
42790: DOUBLE
42791: EQUAL
42792: IFTRUE 42808
42794: LD_INT 14
42796: DOUBLE
42797: EQUAL
42798: IFTRUE 42808
42800: LD_INT 10
42802: DOUBLE
42803: EQUAL
42804: IFTRUE 42808
42806: GO 42864
42808: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
42809: LD_ADDR_VAR 0 9
42813: PUSH
42814: LD_VAR 0 41
42818: PUSH
42819: LD_VAR 0 42
42823: PUSH
42824: LD_VAR 0 43
42828: PUSH
42829: LD_VAR 0 44
42833: PUSH
42834: LD_VAR 0 45
42838: PUSH
42839: LD_VAR 0 46
42843: PUSH
42844: EMPTY
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: PUSH
42852: LD_VAR 0 4
42856: PUSH
42857: LD_INT 1
42859: PLUS
42860: ARRAY
42861: ST_TO_ADDR
42862: GO 43117
42864: LD_INT 36
42866: DOUBLE
42867: EQUAL
42868: IFTRUE 42872
42870: GO 42928
42872: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
42873: LD_ADDR_VAR 0 9
42877: PUSH
42878: LD_VAR 0 47
42882: PUSH
42883: LD_VAR 0 48
42887: PUSH
42888: LD_VAR 0 49
42892: PUSH
42893: LD_VAR 0 50
42897: PUSH
42898: LD_VAR 0 51
42902: PUSH
42903: LD_VAR 0 52
42907: PUSH
42908: EMPTY
42909: LIST
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: LIST
42915: PUSH
42916: LD_VAR 0 4
42920: PUSH
42921: LD_INT 1
42923: PLUS
42924: ARRAY
42925: ST_TO_ADDR
42926: GO 43117
42928: LD_INT 4
42930: DOUBLE
42931: EQUAL
42932: IFTRUE 42954
42934: LD_INT 5
42936: DOUBLE
42937: EQUAL
42938: IFTRUE 42954
42940: LD_INT 34
42942: DOUBLE
42943: EQUAL
42944: IFTRUE 42954
42946: LD_INT 37
42948: DOUBLE
42949: EQUAL
42950: IFTRUE 42954
42952: GO 43010
42954: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
42955: LD_ADDR_VAR 0 9
42959: PUSH
42960: LD_VAR 0 53
42964: PUSH
42965: LD_VAR 0 54
42969: PUSH
42970: LD_VAR 0 55
42974: PUSH
42975: LD_VAR 0 56
42979: PUSH
42980: LD_VAR 0 57
42984: PUSH
42985: LD_VAR 0 58
42989: PUSH
42990: EMPTY
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: PUSH
42998: LD_VAR 0 4
43002: PUSH
43003: LD_INT 1
43005: PLUS
43006: ARRAY
43007: ST_TO_ADDR
43008: GO 43117
43010: LD_INT 31
43012: DOUBLE
43013: EQUAL
43014: IFTRUE 43060
43016: LD_INT 32
43018: DOUBLE
43019: EQUAL
43020: IFTRUE 43060
43022: LD_INT 33
43024: DOUBLE
43025: EQUAL
43026: IFTRUE 43060
43028: LD_INT 27
43030: DOUBLE
43031: EQUAL
43032: IFTRUE 43060
43034: LD_INT 26
43036: DOUBLE
43037: EQUAL
43038: IFTRUE 43060
43040: LD_INT 28
43042: DOUBLE
43043: EQUAL
43044: IFTRUE 43060
43046: LD_INT 29
43048: DOUBLE
43049: EQUAL
43050: IFTRUE 43060
43052: LD_INT 30
43054: DOUBLE
43055: EQUAL
43056: IFTRUE 43060
43058: GO 43116
43060: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43061: LD_ADDR_VAR 0 9
43065: PUSH
43066: LD_VAR 0 59
43070: PUSH
43071: LD_VAR 0 60
43075: PUSH
43076: LD_VAR 0 61
43080: PUSH
43081: LD_VAR 0 62
43085: PUSH
43086: LD_VAR 0 63
43090: PUSH
43091: LD_VAR 0 64
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: PUSH
43104: LD_VAR 0 4
43108: PUSH
43109: LD_INT 1
43111: PLUS
43112: ARRAY
43113: ST_TO_ADDR
43114: GO 43117
43116: POP
// temp_list2 = [ ] ;
43117: LD_ADDR_VAR 0 10
43121: PUSH
43122: EMPTY
43123: ST_TO_ADDR
// for i in temp_list do
43124: LD_ADDR_VAR 0 8
43128: PUSH
43129: LD_VAR 0 9
43133: PUSH
43134: FOR_IN
43135: IFFALSE 43187
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43137: LD_ADDR_VAR 0 10
43141: PUSH
43142: LD_VAR 0 10
43146: PUSH
43147: LD_VAR 0 8
43151: PUSH
43152: LD_INT 1
43154: ARRAY
43155: PUSH
43156: LD_VAR 0 2
43160: PLUS
43161: PUSH
43162: LD_VAR 0 8
43166: PUSH
43167: LD_INT 2
43169: ARRAY
43170: PUSH
43171: LD_VAR 0 3
43175: PLUS
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PUSH
43181: EMPTY
43182: LIST
43183: ADD
43184: ST_TO_ADDR
43185: GO 43134
43187: POP
43188: POP
// result = temp_list2 ;
43189: LD_ADDR_VAR 0 7
43193: PUSH
43194: LD_VAR 0 10
43198: ST_TO_ADDR
// end ;
43199: LD_VAR 0 7
43203: RET
// export function EnemyInRange ( unit , dist ) ; begin
43204: LD_INT 0
43206: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43207: LD_ADDR_VAR 0 3
43211: PUSH
43212: LD_VAR 0 1
43216: PPUSH
43217: CALL_OW 255
43221: PPUSH
43222: LD_VAR 0 1
43226: PPUSH
43227: CALL_OW 250
43231: PPUSH
43232: LD_VAR 0 1
43236: PPUSH
43237: CALL_OW 251
43241: PPUSH
43242: LD_VAR 0 2
43246: PPUSH
43247: CALL 16600 0 4
43251: PUSH
43252: LD_INT 4
43254: ARRAY
43255: ST_TO_ADDR
// end ;
43256: LD_VAR 0 3
43260: RET
// export function PlayerSeeMe ( unit ) ; begin
43261: LD_INT 0
43263: PPUSH
// result := See ( your_side , unit ) ;
43264: LD_ADDR_VAR 0 2
43268: PUSH
43269: LD_OWVAR 2
43273: PPUSH
43274: LD_VAR 0 1
43278: PPUSH
43279: CALL_OW 292
43283: ST_TO_ADDR
// end ;
43284: LD_VAR 0 2
43288: RET
// export function ReverseDir ( unit ) ; begin
43289: LD_INT 0
43291: PPUSH
// if not unit then
43292: LD_VAR 0 1
43296: NOT
43297: IFFALSE 43301
// exit ;
43299: GO 43324
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43301: LD_ADDR_VAR 0 2
43305: PUSH
43306: LD_VAR 0 1
43310: PPUSH
43311: CALL_OW 254
43315: PUSH
43316: LD_INT 3
43318: PLUS
43319: PUSH
43320: LD_INT 6
43322: MOD
43323: ST_TO_ADDR
// end ;
43324: LD_VAR 0 2
43328: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
43329: LD_INT 0
43331: PPUSH
43332: PPUSH
43333: PPUSH
43334: PPUSH
43335: PPUSH
// if not hexes then
43336: LD_VAR 0 2
43340: NOT
43341: IFFALSE 43345
// exit ;
43343: GO 43493
// dist := 9999 ;
43345: LD_ADDR_VAR 0 5
43349: PUSH
43350: LD_INT 9999
43352: ST_TO_ADDR
// for i = 1 to hexes do
43353: LD_ADDR_VAR 0 4
43357: PUSH
43358: DOUBLE
43359: LD_INT 1
43361: DEC
43362: ST_TO_ADDR
43363: LD_VAR 0 2
43367: PUSH
43368: FOR_TO
43369: IFFALSE 43481
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
43371: LD_VAR 0 1
43375: PPUSH
43376: LD_VAR 0 2
43380: PUSH
43381: LD_VAR 0 4
43385: ARRAY
43386: PUSH
43387: LD_INT 1
43389: ARRAY
43390: PPUSH
43391: LD_VAR 0 2
43395: PUSH
43396: LD_VAR 0 4
43400: ARRAY
43401: PUSH
43402: LD_INT 2
43404: ARRAY
43405: PPUSH
43406: CALL_OW 297
43410: PUSH
43411: LD_VAR 0 5
43415: LESS
43416: IFFALSE 43479
// begin hex := hexes [ i ] ;
43418: LD_ADDR_VAR 0 7
43422: PUSH
43423: LD_VAR 0 2
43427: PUSH
43428: LD_VAR 0 4
43432: ARRAY
43433: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43434: LD_ADDR_VAR 0 5
43438: PUSH
43439: LD_VAR 0 1
43443: PPUSH
43444: LD_VAR 0 2
43448: PUSH
43449: LD_VAR 0 4
43453: ARRAY
43454: PUSH
43455: LD_INT 1
43457: ARRAY
43458: PPUSH
43459: LD_VAR 0 2
43463: PUSH
43464: LD_VAR 0 4
43468: ARRAY
43469: PUSH
43470: LD_INT 2
43472: ARRAY
43473: PPUSH
43474: CALL_OW 297
43478: ST_TO_ADDR
// end ; end ;
43479: GO 43368
43481: POP
43482: POP
// result := hex ;
43483: LD_ADDR_VAR 0 3
43487: PUSH
43488: LD_VAR 0 7
43492: ST_TO_ADDR
// end ;
43493: LD_VAR 0 3
43497: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43498: LD_INT 0
43500: PPUSH
43501: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43502: LD_VAR 0 1
43506: NOT
43507: PUSH
43508: LD_VAR 0 1
43512: PUSH
43513: LD_INT 21
43515: PUSH
43516: LD_INT 2
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 23
43525: PUSH
43526: LD_INT 2
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PPUSH
43537: CALL_OW 69
43541: IN
43542: NOT
43543: OR
43544: IFFALSE 43548
// exit ;
43546: GO 43595
// for i = 1 to 3 do
43548: LD_ADDR_VAR 0 3
43552: PUSH
43553: DOUBLE
43554: LD_INT 1
43556: DEC
43557: ST_TO_ADDR
43558: LD_INT 3
43560: PUSH
43561: FOR_TO
43562: IFFALSE 43593
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
43564: LD_VAR 0 1
43568: PPUSH
43569: CALL_OW 250
43573: PPUSH
43574: LD_VAR 0 1
43578: PPUSH
43579: CALL_OW 251
43583: PPUSH
43584: LD_INT 1
43586: PPUSH
43587: CALL_OW 453
43591: GO 43561
43593: POP
43594: POP
// end ;
43595: LD_VAR 0 2
43599: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
43600: LD_INT 0
43602: PPUSH
43603: PPUSH
43604: PPUSH
43605: PPUSH
43606: PPUSH
43607: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
43608: LD_VAR 0 1
43612: NOT
43613: PUSH
43614: LD_VAR 0 2
43618: NOT
43619: OR
43620: PUSH
43621: LD_VAR 0 1
43625: PPUSH
43626: CALL_OW 314
43630: OR
43631: IFFALSE 43635
// exit ;
43633: GO 44076
// x := GetX ( enemy_unit ) ;
43635: LD_ADDR_VAR 0 7
43639: PUSH
43640: LD_VAR 0 2
43644: PPUSH
43645: CALL_OW 250
43649: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43650: LD_ADDR_VAR 0 8
43654: PUSH
43655: LD_VAR 0 2
43659: PPUSH
43660: CALL_OW 251
43664: ST_TO_ADDR
// if not x or not y then
43665: LD_VAR 0 7
43669: NOT
43670: PUSH
43671: LD_VAR 0 8
43675: NOT
43676: OR
43677: IFFALSE 43681
// exit ;
43679: GO 44076
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43681: LD_ADDR_VAR 0 6
43685: PUSH
43686: LD_VAR 0 7
43690: PPUSH
43691: LD_INT 0
43693: PPUSH
43694: LD_INT 4
43696: PPUSH
43697: CALL_OW 272
43701: PUSH
43702: LD_VAR 0 8
43706: PPUSH
43707: LD_INT 0
43709: PPUSH
43710: LD_INT 4
43712: PPUSH
43713: CALL_OW 273
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: LD_VAR 0 7
43726: PPUSH
43727: LD_INT 1
43729: PPUSH
43730: LD_INT 4
43732: PPUSH
43733: CALL_OW 272
43737: PUSH
43738: LD_VAR 0 8
43742: PPUSH
43743: LD_INT 1
43745: PPUSH
43746: LD_INT 4
43748: PPUSH
43749: CALL_OW 273
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_VAR 0 7
43762: PPUSH
43763: LD_INT 2
43765: PPUSH
43766: LD_INT 4
43768: PPUSH
43769: CALL_OW 272
43773: PUSH
43774: LD_VAR 0 8
43778: PPUSH
43779: LD_INT 2
43781: PPUSH
43782: LD_INT 4
43784: PPUSH
43785: CALL_OW 273
43789: PUSH
43790: EMPTY
43791: LIST
43792: LIST
43793: PUSH
43794: LD_VAR 0 7
43798: PPUSH
43799: LD_INT 3
43801: PPUSH
43802: LD_INT 4
43804: PPUSH
43805: CALL_OW 272
43809: PUSH
43810: LD_VAR 0 8
43814: PPUSH
43815: LD_INT 3
43817: PPUSH
43818: LD_INT 4
43820: PPUSH
43821: CALL_OW 273
43825: PUSH
43826: EMPTY
43827: LIST
43828: LIST
43829: PUSH
43830: LD_VAR 0 7
43834: PPUSH
43835: LD_INT 4
43837: PPUSH
43838: LD_INT 4
43840: PPUSH
43841: CALL_OW 272
43845: PUSH
43846: LD_VAR 0 8
43850: PPUSH
43851: LD_INT 4
43853: PPUSH
43854: LD_INT 4
43856: PPUSH
43857: CALL_OW 273
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_VAR 0 7
43870: PPUSH
43871: LD_INT 5
43873: PPUSH
43874: LD_INT 4
43876: PPUSH
43877: CALL_OW 272
43881: PUSH
43882: LD_VAR 0 8
43886: PPUSH
43887: LD_INT 5
43889: PPUSH
43890: LD_INT 4
43892: PPUSH
43893: CALL_OW 273
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: ST_TO_ADDR
// for i = tmp downto 1 do
43910: LD_ADDR_VAR 0 4
43914: PUSH
43915: DOUBLE
43916: LD_VAR 0 6
43920: INC
43921: ST_TO_ADDR
43922: LD_INT 1
43924: PUSH
43925: FOR_DOWNTO
43926: IFFALSE 44027
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
43928: LD_VAR 0 6
43932: PUSH
43933: LD_VAR 0 4
43937: ARRAY
43938: PUSH
43939: LD_INT 1
43941: ARRAY
43942: PPUSH
43943: LD_VAR 0 6
43947: PUSH
43948: LD_VAR 0 4
43952: ARRAY
43953: PUSH
43954: LD_INT 2
43956: ARRAY
43957: PPUSH
43958: CALL_OW 488
43962: NOT
43963: PUSH
43964: LD_VAR 0 6
43968: PUSH
43969: LD_VAR 0 4
43973: ARRAY
43974: PUSH
43975: LD_INT 1
43977: ARRAY
43978: PPUSH
43979: LD_VAR 0 6
43983: PUSH
43984: LD_VAR 0 4
43988: ARRAY
43989: PUSH
43990: LD_INT 2
43992: ARRAY
43993: PPUSH
43994: CALL_OW 428
43998: PUSH
43999: LD_INT 0
44001: NONEQUAL
44002: OR
44003: IFFALSE 44025
// tmp := Delete ( tmp , i ) ;
44005: LD_ADDR_VAR 0 6
44009: PUSH
44010: LD_VAR 0 6
44014: PPUSH
44015: LD_VAR 0 4
44019: PPUSH
44020: CALL_OW 3
44024: ST_TO_ADDR
44025: GO 43925
44027: POP
44028: POP
// j := GetClosestHex ( unit , tmp ) ;
44029: LD_ADDR_VAR 0 5
44033: PUSH
44034: LD_VAR 0 1
44038: PPUSH
44039: LD_VAR 0 6
44043: PPUSH
44044: CALL 43329 0 2
44048: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44049: LD_VAR 0 1
44053: PPUSH
44054: LD_VAR 0 5
44058: PUSH
44059: LD_INT 1
44061: ARRAY
44062: PPUSH
44063: LD_VAR 0 5
44067: PUSH
44068: LD_INT 2
44070: ARRAY
44071: PPUSH
44072: CALL_OW 111
// end ;
44076: LD_VAR 0 3
44080: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44081: LD_INT 0
44083: PPUSH
44084: PPUSH
44085: PPUSH
// uc_side = 0 ;
44086: LD_ADDR_OWVAR 20
44090: PUSH
44091: LD_INT 0
44093: ST_TO_ADDR
// uc_nation = 0 ;
44094: LD_ADDR_OWVAR 21
44098: PUSH
44099: LD_INT 0
44101: ST_TO_ADDR
// InitHc_All ( ) ;
44102: CALL_OW 584
// InitVc ;
44106: CALL_OW 20
// if mastodonts then
44110: LD_VAR 0 6
44114: IFFALSE 44181
// for i = 1 to mastodonts do
44116: LD_ADDR_VAR 0 11
44120: PUSH
44121: DOUBLE
44122: LD_INT 1
44124: DEC
44125: ST_TO_ADDR
44126: LD_VAR 0 6
44130: PUSH
44131: FOR_TO
44132: IFFALSE 44179
// begin vc_chassis := 31 ;
44134: LD_ADDR_OWVAR 37
44138: PUSH
44139: LD_INT 31
44141: ST_TO_ADDR
// vc_control := control_rider ;
44142: LD_ADDR_OWVAR 38
44146: PUSH
44147: LD_INT 4
44149: ST_TO_ADDR
// animal := CreateVehicle ;
44150: LD_ADDR_VAR 0 12
44154: PUSH
44155: CALL_OW 45
44159: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44160: LD_VAR 0 12
44164: PPUSH
44165: LD_VAR 0 8
44169: PPUSH
44170: LD_INT 0
44172: PPUSH
44173: CALL 46369 0 3
// end ;
44177: GO 44131
44179: POP
44180: POP
// if horses then
44181: LD_VAR 0 5
44185: IFFALSE 44252
// for i = 1 to horses do
44187: LD_ADDR_VAR 0 11
44191: PUSH
44192: DOUBLE
44193: LD_INT 1
44195: DEC
44196: ST_TO_ADDR
44197: LD_VAR 0 5
44201: PUSH
44202: FOR_TO
44203: IFFALSE 44250
// begin hc_class := 21 ;
44205: LD_ADDR_OWVAR 28
44209: PUSH
44210: LD_INT 21
44212: ST_TO_ADDR
// hc_gallery :=  ;
44213: LD_ADDR_OWVAR 33
44217: PUSH
44218: LD_STRING 
44220: ST_TO_ADDR
// animal := CreateHuman ;
44221: LD_ADDR_VAR 0 12
44225: PUSH
44226: CALL_OW 44
44230: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44231: LD_VAR 0 12
44235: PPUSH
44236: LD_VAR 0 8
44240: PPUSH
44241: LD_INT 0
44243: PPUSH
44244: CALL 46369 0 3
// end ;
44248: GO 44202
44250: POP
44251: POP
// if birds then
44252: LD_VAR 0 1
44256: IFFALSE 44323
// for i = 1 to birds do
44258: LD_ADDR_VAR 0 11
44262: PUSH
44263: DOUBLE
44264: LD_INT 1
44266: DEC
44267: ST_TO_ADDR
44268: LD_VAR 0 1
44272: PUSH
44273: FOR_TO
44274: IFFALSE 44321
// begin hc_class = 18 ;
44276: LD_ADDR_OWVAR 28
44280: PUSH
44281: LD_INT 18
44283: ST_TO_ADDR
// hc_gallery =  ;
44284: LD_ADDR_OWVAR 33
44288: PUSH
44289: LD_STRING 
44291: ST_TO_ADDR
// animal := CreateHuman ;
44292: LD_ADDR_VAR 0 12
44296: PUSH
44297: CALL_OW 44
44301: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44302: LD_VAR 0 12
44306: PPUSH
44307: LD_VAR 0 8
44311: PPUSH
44312: LD_INT 0
44314: PPUSH
44315: CALL 46369 0 3
// end ;
44319: GO 44273
44321: POP
44322: POP
// if tigers then
44323: LD_VAR 0 2
44327: IFFALSE 44411
// for i = 1 to tigers do
44329: LD_ADDR_VAR 0 11
44333: PUSH
44334: DOUBLE
44335: LD_INT 1
44337: DEC
44338: ST_TO_ADDR
44339: LD_VAR 0 2
44343: PUSH
44344: FOR_TO
44345: IFFALSE 44409
// begin hc_class = class_tiger ;
44347: LD_ADDR_OWVAR 28
44351: PUSH
44352: LD_INT 14
44354: ST_TO_ADDR
// hc_gallery =  ;
44355: LD_ADDR_OWVAR 33
44359: PUSH
44360: LD_STRING 
44362: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44363: LD_ADDR_OWVAR 35
44367: PUSH
44368: LD_INT 7
44370: NEG
44371: PPUSH
44372: LD_INT 7
44374: PPUSH
44375: CALL_OW 12
44379: ST_TO_ADDR
// animal := CreateHuman ;
44380: LD_ADDR_VAR 0 12
44384: PUSH
44385: CALL_OW 44
44389: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44390: LD_VAR 0 12
44394: PPUSH
44395: LD_VAR 0 8
44399: PPUSH
44400: LD_INT 0
44402: PPUSH
44403: CALL 46369 0 3
// end ;
44407: GO 44344
44409: POP
44410: POP
// if apemans then
44411: LD_VAR 0 3
44415: IFFALSE 44538
// for i = 1 to apemans do
44417: LD_ADDR_VAR 0 11
44421: PUSH
44422: DOUBLE
44423: LD_INT 1
44425: DEC
44426: ST_TO_ADDR
44427: LD_VAR 0 3
44431: PUSH
44432: FOR_TO
44433: IFFALSE 44536
// begin hc_class = class_apeman ;
44435: LD_ADDR_OWVAR 28
44439: PUSH
44440: LD_INT 12
44442: ST_TO_ADDR
// hc_gallery =  ;
44443: LD_ADDR_OWVAR 33
44447: PUSH
44448: LD_STRING 
44450: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44451: LD_ADDR_OWVAR 35
44455: PUSH
44456: LD_INT 2
44458: NEG
44459: PPUSH
44460: LD_INT 2
44462: PPUSH
44463: CALL_OW 12
44467: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44468: LD_ADDR_OWVAR 31
44472: PUSH
44473: LD_INT 1
44475: PPUSH
44476: LD_INT 3
44478: PPUSH
44479: CALL_OW 12
44483: PUSH
44484: LD_INT 1
44486: PPUSH
44487: LD_INT 3
44489: PPUSH
44490: CALL_OW 12
44494: PUSH
44495: LD_INT 0
44497: PUSH
44498: LD_INT 0
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: LIST
44505: LIST
44506: ST_TO_ADDR
// animal := CreateHuman ;
44507: LD_ADDR_VAR 0 12
44511: PUSH
44512: CALL_OW 44
44516: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44517: LD_VAR 0 12
44521: PPUSH
44522: LD_VAR 0 8
44526: PPUSH
44527: LD_INT 0
44529: PPUSH
44530: CALL 46369 0 3
// end ;
44534: GO 44432
44536: POP
44537: POP
// if enchidnas then
44538: LD_VAR 0 4
44542: IFFALSE 44609
// for i = 1 to enchidnas do
44544: LD_ADDR_VAR 0 11
44548: PUSH
44549: DOUBLE
44550: LD_INT 1
44552: DEC
44553: ST_TO_ADDR
44554: LD_VAR 0 4
44558: PUSH
44559: FOR_TO
44560: IFFALSE 44607
// begin hc_class = 13 ;
44562: LD_ADDR_OWVAR 28
44566: PUSH
44567: LD_INT 13
44569: ST_TO_ADDR
// hc_gallery =  ;
44570: LD_ADDR_OWVAR 33
44574: PUSH
44575: LD_STRING 
44577: ST_TO_ADDR
// animal := CreateHuman ;
44578: LD_ADDR_VAR 0 12
44582: PUSH
44583: CALL_OW 44
44587: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44588: LD_VAR 0 12
44592: PPUSH
44593: LD_VAR 0 8
44597: PPUSH
44598: LD_INT 0
44600: PPUSH
44601: CALL 46369 0 3
// end ;
44605: GO 44559
44607: POP
44608: POP
// if fishes then
44609: LD_VAR 0 7
44613: IFFALSE 44680
// for i = 1 to fishes do
44615: LD_ADDR_VAR 0 11
44619: PUSH
44620: DOUBLE
44621: LD_INT 1
44623: DEC
44624: ST_TO_ADDR
44625: LD_VAR 0 7
44629: PUSH
44630: FOR_TO
44631: IFFALSE 44678
// begin hc_class = 20 ;
44633: LD_ADDR_OWVAR 28
44637: PUSH
44638: LD_INT 20
44640: ST_TO_ADDR
// hc_gallery =  ;
44641: LD_ADDR_OWVAR 33
44645: PUSH
44646: LD_STRING 
44648: ST_TO_ADDR
// animal := CreateHuman ;
44649: LD_ADDR_VAR 0 12
44653: PUSH
44654: CALL_OW 44
44658: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44659: LD_VAR 0 12
44663: PPUSH
44664: LD_VAR 0 9
44668: PPUSH
44669: LD_INT 0
44671: PPUSH
44672: CALL 46369 0 3
// end ;
44676: GO 44630
44678: POP
44679: POP
// end ;
44680: LD_VAR 0 10
44684: RET
// export function WantHeal ( sci , unit ) ; begin
44685: LD_INT 0
44687: PPUSH
// if GetTaskList ( sci ) > 0 then
44688: LD_VAR 0 1
44692: PPUSH
44693: CALL_OW 437
44697: PUSH
44698: LD_INT 0
44700: GREATER
44701: IFFALSE 44771
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44703: LD_VAR 0 1
44707: PPUSH
44708: CALL_OW 437
44712: PUSH
44713: LD_INT 1
44715: ARRAY
44716: PUSH
44717: LD_INT 1
44719: ARRAY
44720: PUSH
44721: LD_STRING l
44723: EQUAL
44724: PUSH
44725: LD_VAR 0 1
44729: PPUSH
44730: CALL_OW 437
44734: PUSH
44735: LD_INT 1
44737: ARRAY
44738: PUSH
44739: LD_INT 4
44741: ARRAY
44742: PUSH
44743: LD_VAR 0 2
44747: EQUAL
44748: AND
44749: IFFALSE 44761
// result := true else
44751: LD_ADDR_VAR 0 3
44755: PUSH
44756: LD_INT 1
44758: ST_TO_ADDR
44759: GO 44769
// result := false ;
44761: LD_ADDR_VAR 0 3
44765: PUSH
44766: LD_INT 0
44768: ST_TO_ADDR
// end else
44769: GO 44779
// result := false ;
44771: LD_ADDR_VAR 0 3
44775: PUSH
44776: LD_INT 0
44778: ST_TO_ADDR
// end ;
44779: LD_VAR 0 3
44783: RET
// export function HealTarget ( sci ) ; begin
44784: LD_INT 0
44786: PPUSH
// if not sci then
44787: LD_VAR 0 1
44791: NOT
44792: IFFALSE 44796
// exit ;
44794: GO 44861
// result := 0 ;
44796: LD_ADDR_VAR 0 2
44800: PUSH
44801: LD_INT 0
44803: ST_TO_ADDR
// if GetTaskList ( sci ) then
44804: LD_VAR 0 1
44808: PPUSH
44809: CALL_OW 437
44813: IFFALSE 44861
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
44815: LD_VAR 0 1
44819: PPUSH
44820: CALL_OW 437
44824: PUSH
44825: LD_INT 1
44827: ARRAY
44828: PUSH
44829: LD_INT 1
44831: ARRAY
44832: PUSH
44833: LD_STRING l
44835: EQUAL
44836: IFFALSE 44861
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
44838: LD_ADDR_VAR 0 2
44842: PUSH
44843: LD_VAR 0 1
44847: PPUSH
44848: CALL_OW 437
44852: PUSH
44853: LD_INT 1
44855: ARRAY
44856: PUSH
44857: LD_INT 4
44859: ARRAY
44860: ST_TO_ADDR
// end ;
44861: LD_VAR 0 2
44865: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
44866: LD_INT 0
44868: PPUSH
44869: PPUSH
44870: PPUSH
44871: PPUSH
// if not base_units then
44872: LD_VAR 0 1
44876: NOT
44877: IFFALSE 44881
// exit ;
44879: GO 44968
// result := false ;
44881: LD_ADDR_VAR 0 2
44885: PUSH
44886: LD_INT 0
44888: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
44889: LD_ADDR_VAR 0 5
44893: PUSH
44894: LD_VAR 0 1
44898: PPUSH
44899: LD_INT 21
44901: PUSH
44902: LD_INT 3
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PPUSH
44909: CALL_OW 72
44913: ST_TO_ADDR
// if not tmp then
44914: LD_VAR 0 5
44918: NOT
44919: IFFALSE 44923
// exit ;
44921: GO 44968
// for i in tmp do
44923: LD_ADDR_VAR 0 3
44927: PUSH
44928: LD_VAR 0 5
44932: PUSH
44933: FOR_IN
44934: IFFALSE 44966
// begin result := EnemyInRange ( i , 22 ) ;
44936: LD_ADDR_VAR 0 2
44940: PUSH
44941: LD_VAR 0 3
44945: PPUSH
44946: LD_INT 22
44948: PPUSH
44949: CALL 43204 0 2
44953: ST_TO_ADDR
// if result then
44954: LD_VAR 0 2
44958: IFFALSE 44964
// exit ;
44960: POP
44961: POP
44962: GO 44968
// end ;
44964: GO 44933
44966: POP
44967: POP
// end ;
44968: LD_VAR 0 2
44972: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
44973: LD_INT 0
44975: PPUSH
44976: PPUSH
// if not units then
44977: LD_VAR 0 1
44981: NOT
44982: IFFALSE 44986
// exit ;
44984: GO 45056
// result := [ ] ;
44986: LD_ADDR_VAR 0 3
44990: PUSH
44991: EMPTY
44992: ST_TO_ADDR
// for i in units do
44993: LD_ADDR_VAR 0 4
44997: PUSH
44998: LD_VAR 0 1
45002: PUSH
45003: FOR_IN
45004: IFFALSE 45054
// if GetTag ( i ) = tag then
45006: LD_VAR 0 4
45010: PPUSH
45011: CALL_OW 110
45015: PUSH
45016: LD_VAR 0 2
45020: EQUAL
45021: IFFALSE 45052
// result := Insert ( result , result + 1 , i ) ;
45023: LD_ADDR_VAR 0 3
45027: PUSH
45028: LD_VAR 0 3
45032: PPUSH
45033: LD_VAR 0 3
45037: PUSH
45038: LD_INT 1
45040: PLUS
45041: PPUSH
45042: LD_VAR 0 4
45046: PPUSH
45047: CALL_OW 2
45051: ST_TO_ADDR
45052: GO 45003
45054: POP
45055: POP
// end ;
45056: LD_VAR 0 3
45060: RET
// export function IsDriver ( un ) ; begin
45061: LD_INT 0
45063: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
45064: LD_ADDR_VAR 0 2
45068: PUSH
45069: LD_VAR 0 1
45073: PUSH
45074: LD_INT 55
45076: PUSH
45077: EMPTY
45078: LIST
45079: PPUSH
45080: CALL_OW 69
45084: IN
45085: ST_TO_ADDR
// end ;
45086: LD_VAR 0 2
45090: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
45091: LD_INT 0
45093: PPUSH
45094: PPUSH
// list := [ ] ;
45095: LD_ADDR_VAR 0 5
45099: PUSH
45100: EMPTY
45101: ST_TO_ADDR
// case d of 0 :
45102: LD_VAR 0 3
45106: PUSH
45107: LD_INT 0
45109: DOUBLE
45110: EQUAL
45111: IFTRUE 45115
45113: GO 45248
45115: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
45116: LD_ADDR_VAR 0 5
45120: PUSH
45121: LD_VAR 0 1
45125: PUSH
45126: LD_INT 4
45128: MINUS
45129: PUSH
45130: LD_VAR 0 2
45134: PUSH
45135: LD_INT 4
45137: MINUS
45138: PUSH
45139: LD_INT 2
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: LIST
45146: PUSH
45147: LD_VAR 0 1
45151: PUSH
45152: LD_INT 3
45154: MINUS
45155: PUSH
45156: LD_VAR 0 2
45160: PUSH
45161: LD_INT 1
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: LIST
45168: PUSH
45169: LD_VAR 0 1
45173: PUSH
45174: LD_INT 4
45176: PLUS
45177: PUSH
45178: LD_VAR 0 2
45182: PUSH
45183: LD_INT 4
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: LIST
45190: PUSH
45191: LD_VAR 0 1
45195: PUSH
45196: LD_INT 3
45198: PLUS
45199: PUSH
45200: LD_VAR 0 2
45204: PUSH
45205: LD_INT 3
45207: PLUS
45208: PUSH
45209: LD_INT 5
45211: PUSH
45212: EMPTY
45213: LIST
45214: LIST
45215: LIST
45216: PUSH
45217: LD_VAR 0 1
45221: PUSH
45222: LD_VAR 0 2
45226: PUSH
45227: LD_INT 4
45229: PLUS
45230: PUSH
45231: LD_INT 0
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: LIST
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: ST_TO_ADDR
// end ; 1 :
45246: GO 45946
45248: LD_INT 1
45250: DOUBLE
45251: EQUAL
45252: IFTRUE 45256
45254: GO 45389
45256: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45257: LD_ADDR_VAR 0 5
45261: PUSH
45262: LD_VAR 0 1
45266: PUSH
45267: LD_VAR 0 2
45271: PUSH
45272: LD_INT 4
45274: MINUS
45275: PUSH
45276: LD_INT 3
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: LIST
45283: PUSH
45284: LD_VAR 0 1
45288: PUSH
45289: LD_INT 3
45291: MINUS
45292: PUSH
45293: LD_VAR 0 2
45297: PUSH
45298: LD_INT 3
45300: MINUS
45301: PUSH
45302: LD_INT 2
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: LIST
45309: PUSH
45310: LD_VAR 0 1
45314: PUSH
45315: LD_INT 4
45317: MINUS
45318: PUSH
45319: LD_VAR 0 2
45323: PUSH
45324: LD_INT 1
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: LIST
45331: PUSH
45332: LD_VAR 0 1
45336: PUSH
45337: LD_VAR 0 2
45341: PUSH
45342: LD_INT 3
45344: PLUS
45345: PUSH
45346: LD_INT 0
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: LIST
45353: PUSH
45354: LD_VAR 0 1
45358: PUSH
45359: LD_INT 4
45361: PLUS
45362: PUSH
45363: LD_VAR 0 2
45367: PUSH
45368: LD_INT 4
45370: PLUS
45371: PUSH
45372: LD_INT 5
45374: PUSH
45375: EMPTY
45376: LIST
45377: LIST
45378: LIST
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: LIST
45386: ST_TO_ADDR
// end ; 2 :
45387: GO 45946
45389: LD_INT 2
45391: DOUBLE
45392: EQUAL
45393: IFTRUE 45397
45395: GO 45526
45397: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45398: LD_ADDR_VAR 0 5
45402: PUSH
45403: LD_VAR 0 1
45407: PUSH
45408: LD_VAR 0 2
45412: PUSH
45413: LD_INT 3
45415: MINUS
45416: PUSH
45417: LD_INT 3
45419: PUSH
45420: EMPTY
45421: LIST
45422: LIST
45423: LIST
45424: PUSH
45425: LD_VAR 0 1
45429: PUSH
45430: LD_INT 4
45432: PLUS
45433: PUSH
45434: LD_VAR 0 2
45438: PUSH
45439: LD_INT 4
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: LIST
45446: PUSH
45447: LD_VAR 0 1
45451: PUSH
45452: LD_VAR 0 2
45456: PUSH
45457: LD_INT 4
45459: PLUS
45460: PUSH
45461: LD_INT 0
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: LIST
45468: PUSH
45469: LD_VAR 0 1
45473: PUSH
45474: LD_INT 3
45476: MINUS
45477: PUSH
45478: LD_VAR 0 2
45482: PUSH
45483: LD_INT 1
45485: PUSH
45486: EMPTY
45487: LIST
45488: LIST
45489: LIST
45490: PUSH
45491: LD_VAR 0 1
45495: PUSH
45496: LD_INT 4
45498: MINUS
45499: PUSH
45500: LD_VAR 0 2
45504: PUSH
45505: LD_INT 4
45507: MINUS
45508: PUSH
45509: LD_INT 2
45511: PUSH
45512: EMPTY
45513: LIST
45514: LIST
45515: LIST
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: LIST
45521: LIST
45522: LIST
45523: ST_TO_ADDR
// end ; 3 :
45524: GO 45946
45526: LD_INT 3
45528: DOUBLE
45529: EQUAL
45530: IFTRUE 45534
45532: GO 45667
45534: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45535: LD_ADDR_VAR 0 5
45539: PUSH
45540: LD_VAR 0 1
45544: PUSH
45545: LD_INT 3
45547: PLUS
45548: PUSH
45549: LD_VAR 0 2
45553: PUSH
45554: LD_INT 4
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: LIST
45561: PUSH
45562: LD_VAR 0 1
45566: PUSH
45567: LD_INT 4
45569: PLUS
45570: PUSH
45571: LD_VAR 0 2
45575: PUSH
45576: LD_INT 4
45578: PLUS
45579: PUSH
45580: LD_INT 5
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: LIST
45587: PUSH
45588: LD_VAR 0 1
45592: PUSH
45593: LD_INT 4
45595: MINUS
45596: PUSH
45597: LD_VAR 0 2
45601: PUSH
45602: LD_INT 1
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: LIST
45609: PUSH
45610: LD_VAR 0 1
45614: PUSH
45615: LD_VAR 0 2
45619: PUSH
45620: LD_INT 4
45622: MINUS
45623: PUSH
45624: LD_INT 3
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: LIST
45631: PUSH
45632: LD_VAR 0 1
45636: PUSH
45637: LD_INT 3
45639: MINUS
45640: PUSH
45641: LD_VAR 0 2
45645: PUSH
45646: LD_INT 3
45648: MINUS
45649: PUSH
45650: LD_INT 2
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: LIST
45657: PUSH
45658: EMPTY
45659: LIST
45660: LIST
45661: LIST
45662: LIST
45663: LIST
45664: ST_TO_ADDR
// end ; 4 :
45665: GO 45946
45667: LD_INT 4
45669: DOUBLE
45670: EQUAL
45671: IFTRUE 45675
45673: GO 45808
45675: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45676: LD_ADDR_VAR 0 5
45680: PUSH
45681: LD_VAR 0 1
45685: PUSH
45686: LD_VAR 0 2
45690: PUSH
45691: LD_INT 4
45693: PLUS
45694: PUSH
45695: LD_INT 0
45697: PUSH
45698: EMPTY
45699: LIST
45700: LIST
45701: LIST
45702: PUSH
45703: LD_VAR 0 1
45707: PUSH
45708: LD_INT 3
45710: PLUS
45711: PUSH
45712: LD_VAR 0 2
45716: PUSH
45717: LD_INT 3
45719: PLUS
45720: PUSH
45721: LD_INT 5
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: LIST
45728: PUSH
45729: LD_VAR 0 1
45733: PUSH
45734: LD_INT 4
45736: PLUS
45737: PUSH
45738: LD_VAR 0 2
45742: PUSH
45743: LD_INT 4
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: LIST
45750: PUSH
45751: LD_VAR 0 1
45755: PUSH
45756: LD_VAR 0 2
45760: PUSH
45761: LD_INT 3
45763: MINUS
45764: PUSH
45765: LD_INT 3
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: LIST
45772: PUSH
45773: LD_VAR 0 1
45777: PUSH
45778: LD_INT 4
45780: MINUS
45781: PUSH
45782: LD_VAR 0 2
45786: PUSH
45787: LD_INT 4
45789: MINUS
45790: PUSH
45791: LD_INT 2
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: LIST
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: LIST
45803: LIST
45804: LIST
45805: ST_TO_ADDR
// end ; 5 :
45806: GO 45946
45808: LD_INT 5
45810: DOUBLE
45811: EQUAL
45812: IFTRUE 45816
45814: GO 45945
45816: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
45817: LD_ADDR_VAR 0 5
45821: PUSH
45822: LD_VAR 0 1
45826: PUSH
45827: LD_INT 4
45829: MINUS
45830: PUSH
45831: LD_VAR 0 2
45835: PUSH
45836: LD_INT 1
45838: PUSH
45839: EMPTY
45840: LIST
45841: LIST
45842: LIST
45843: PUSH
45844: LD_VAR 0 1
45848: PUSH
45849: LD_VAR 0 2
45853: PUSH
45854: LD_INT 4
45856: MINUS
45857: PUSH
45858: LD_INT 3
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: LIST
45865: PUSH
45866: LD_VAR 0 1
45870: PUSH
45871: LD_INT 4
45873: PLUS
45874: PUSH
45875: LD_VAR 0 2
45879: PUSH
45880: LD_INT 4
45882: PLUS
45883: PUSH
45884: LD_INT 5
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: LIST
45891: PUSH
45892: LD_VAR 0 1
45896: PUSH
45897: LD_INT 3
45899: PLUS
45900: PUSH
45901: LD_VAR 0 2
45905: PUSH
45906: LD_INT 4
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: LIST
45913: PUSH
45914: LD_VAR 0 1
45918: PUSH
45919: LD_VAR 0 2
45923: PUSH
45924: LD_INT 3
45926: PLUS
45927: PUSH
45928: LD_INT 0
45930: PUSH
45931: EMPTY
45932: LIST
45933: LIST
45934: LIST
45935: PUSH
45936: EMPTY
45937: LIST
45938: LIST
45939: LIST
45940: LIST
45941: LIST
45942: ST_TO_ADDR
// end ; end ;
45943: GO 45946
45945: POP
// result := list ;
45946: LD_ADDR_VAR 0 4
45950: PUSH
45951: LD_VAR 0 5
45955: ST_TO_ADDR
// end ;
45956: LD_VAR 0 4
45960: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
45961: LD_INT 0
45963: PPUSH
45964: PPUSH
45965: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
45966: LD_VAR 0 1
45970: NOT
45971: PUSH
45972: LD_VAR 0 2
45976: PUSH
45977: LD_INT 1
45979: PUSH
45980: LD_INT 2
45982: PUSH
45983: LD_INT 3
45985: PUSH
45986: LD_INT 4
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: IN
45995: NOT
45996: OR
45997: IFFALSE 46001
// exit ;
45999: GO 46093
// tmp := [ ] ;
46001: LD_ADDR_VAR 0 5
46005: PUSH
46006: EMPTY
46007: ST_TO_ADDR
// for i in units do
46008: LD_ADDR_VAR 0 4
46012: PUSH
46013: LD_VAR 0 1
46017: PUSH
46018: FOR_IN
46019: IFFALSE 46062
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
46021: LD_ADDR_VAR 0 5
46025: PUSH
46026: LD_VAR 0 5
46030: PPUSH
46031: LD_VAR 0 5
46035: PUSH
46036: LD_INT 1
46038: PLUS
46039: PPUSH
46040: LD_VAR 0 4
46044: PPUSH
46045: LD_VAR 0 2
46049: PPUSH
46050: CALL_OW 259
46054: PPUSH
46055: CALL_OW 2
46059: ST_TO_ADDR
46060: GO 46018
46062: POP
46063: POP
// if not tmp then
46064: LD_VAR 0 5
46068: NOT
46069: IFFALSE 46073
// exit ;
46071: GO 46093
// result := SortListByListDesc ( units , tmp ) ;
46073: LD_ADDR_VAR 0 3
46077: PUSH
46078: LD_VAR 0 1
46082: PPUSH
46083: LD_VAR 0 5
46087: PPUSH
46088: CALL_OW 77
46092: ST_TO_ADDR
// end ;
46093: LD_VAR 0 3
46097: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
46098: LD_INT 0
46100: PPUSH
46101: PPUSH
46102: PPUSH
// result := false ;
46103: LD_ADDR_VAR 0 3
46107: PUSH
46108: LD_INT 0
46110: ST_TO_ADDR
// x := GetX ( building ) ;
46111: LD_ADDR_VAR 0 4
46115: PUSH
46116: LD_VAR 0 2
46120: PPUSH
46121: CALL_OW 250
46125: ST_TO_ADDR
// y := GetY ( building ) ;
46126: LD_ADDR_VAR 0 5
46130: PUSH
46131: LD_VAR 0 2
46135: PPUSH
46136: CALL_OW 251
46140: ST_TO_ADDR
// if not building or not x or not y then
46141: LD_VAR 0 2
46145: NOT
46146: PUSH
46147: LD_VAR 0 4
46151: NOT
46152: OR
46153: PUSH
46154: LD_VAR 0 5
46158: NOT
46159: OR
46160: IFFALSE 46164
// exit ;
46162: GO 46256
// if GetTaskList ( unit ) then
46164: LD_VAR 0 1
46168: PPUSH
46169: CALL_OW 437
46173: IFFALSE 46256
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46175: LD_STRING e
46177: PUSH
46178: LD_VAR 0 1
46182: PPUSH
46183: CALL_OW 437
46187: PUSH
46188: LD_INT 1
46190: ARRAY
46191: PUSH
46192: LD_INT 1
46194: ARRAY
46195: EQUAL
46196: PUSH
46197: LD_VAR 0 4
46201: PUSH
46202: LD_VAR 0 1
46206: PPUSH
46207: CALL_OW 437
46211: PUSH
46212: LD_INT 1
46214: ARRAY
46215: PUSH
46216: LD_INT 2
46218: ARRAY
46219: EQUAL
46220: AND
46221: PUSH
46222: LD_VAR 0 5
46226: PUSH
46227: LD_VAR 0 1
46231: PPUSH
46232: CALL_OW 437
46236: PUSH
46237: LD_INT 1
46239: ARRAY
46240: PUSH
46241: LD_INT 3
46243: ARRAY
46244: EQUAL
46245: AND
46246: IFFALSE 46256
// result := true end ;
46248: LD_ADDR_VAR 0 3
46252: PUSH
46253: LD_INT 1
46255: ST_TO_ADDR
// end ;
46256: LD_VAR 0 3
46260: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46261: LD_INT 0
46263: PPUSH
// result := false ;
46264: LD_ADDR_VAR 0 4
46268: PUSH
46269: LD_INT 0
46271: ST_TO_ADDR
// if GetTaskList ( unit ) then
46272: LD_VAR 0 1
46276: PPUSH
46277: CALL_OW 437
46281: IFFALSE 46364
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46283: LD_STRING M
46285: PUSH
46286: LD_VAR 0 1
46290: PPUSH
46291: CALL_OW 437
46295: PUSH
46296: LD_INT 1
46298: ARRAY
46299: PUSH
46300: LD_INT 1
46302: ARRAY
46303: EQUAL
46304: PUSH
46305: LD_VAR 0 2
46309: PUSH
46310: LD_VAR 0 1
46314: PPUSH
46315: CALL_OW 437
46319: PUSH
46320: LD_INT 1
46322: ARRAY
46323: PUSH
46324: LD_INT 2
46326: ARRAY
46327: EQUAL
46328: AND
46329: PUSH
46330: LD_VAR 0 3
46334: PUSH
46335: LD_VAR 0 1
46339: PPUSH
46340: CALL_OW 437
46344: PUSH
46345: LD_INT 1
46347: ARRAY
46348: PUSH
46349: LD_INT 3
46351: ARRAY
46352: EQUAL
46353: AND
46354: IFFALSE 46364
// result := true ;
46356: LD_ADDR_VAR 0 4
46360: PUSH
46361: LD_INT 1
46363: ST_TO_ADDR
// end ; end ;
46364: LD_VAR 0 4
46368: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46369: LD_INT 0
46371: PPUSH
46372: PPUSH
46373: PPUSH
46374: PPUSH
// if not unit or not area then
46375: LD_VAR 0 1
46379: NOT
46380: PUSH
46381: LD_VAR 0 2
46385: NOT
46386: OR
46387: IFFALSE 46391
// exit ;
46389: GO 46555
// tmp := AreaToList ( area , i ) ;
46391: LD_ADDR_VAR 0 6
46395: PUSH
46396: LD_VAR 0 2
46400: PPUSH
46401: LD_VAR 0 5
46405: PPUSH
46406: CALL_OW 517
46410: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46411: LD_ADDR_VAR 0 5
46415: PUSH
46416: DOUBLE
46417: LD_INT 1
46419: DEC
46420: ST_TO_ADDR
46421: LD_VAR 0 6
46425: PUSH
46426: LD_INT 1
46428: ARRAY
46429: PUSH
46430: FOR_TO
46431: IFFALSE 46553
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46433: LD_ADDR_VAR 0 7
46437: PUSH
46438: LD_VAR 0 6
46442: PUSH
46443: LD_INT 1
46445: ARRAY
46446: PUSH
46447: LD_VAR 0 5
46451: ARRAY
46452: PUSH
46453: LD_VAR 0 6
46457: PUSH
46458: LD_INT 2
46460: ARRAY
46461: PUSH
46462: LD_VAR 0 5
46466: ARRAY
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46472: LD_VAR 0 7
46476: PUSH
46477: LD_INT 1
46479: ARRAY
46480: PPUSH
46481: LD_VAR 0 7
46485: PUSH
46486: LD_INT 2
46488: ARRAY
46489: PPUSH
46490: CALL_OW 428
46494: PUSH
46495: LD_INT 0
46497: EQUAL
46498: IFFALSE 46551
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46500: LD_VAR 0 1
46504: PPUSH
46505: LD_VAR 0 7
46509: PUSH
46510: LD_INT 1
46512: ARRAY
46513: PPUSH
46514: LD_VAR 0 7
46518: PUSH
46519: LD_INT 2
46521: ARRAY
46522: PPUSH
46523: LD_VAR 0 3
46527: PPUSH
46528: CALL_OW 48
// result := IsPlaced ( unit ) ;
46532: LD_ADDR_VAR 0 4
46536: PUSH
46537: LD_VAR 0 1
46541: PPUSH
46542: CALL_OW 305
46546: ST_TO_ADDR
// exit ;
46547: POP
46548: POP
46549: GO 46555
// end ; end ;
46551: GO 46430
46553: POP
46554: POP
// end ;
46555: LD_VAR 0 4
46559: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46560: LD_INT 0
46562: PPUSH
46563: PPUSH
46564: PPUSH
// if not side or side > 8 then
46565: LD_VAR 0 1
46569: NOT
46570: PUSH
46571: LD_VAR 0 1
46575: PUSH
46576: LD_INT 8
46578: GREATER
46579: OR
46580: IFFALSE 46584
// exit ;
46582: GO 46771
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46584: LD_ADDR_VAR 0 4
46588: PUSH
46589: LD_INT 22
46591: PUSH
46592: LD_VAR 0 1
46596: PUSH
46597: EMPTY
46598: LIST
46599: LIST
46600: PUSH
46601: LD_INT 21
46603: PUSH
46604: LD_INT 3
46606: PUSH
46607: EMPTY
46608: LIST
46609: LIST
46610: PUSH
46611: EMPTY
46612: LIST
46613: LIST
46614: PPUSH
46615: CALL_OW 69
46619: ST_TO_ADDR
// if not tmp then
46620: LD_VAR 0 4
46624: NOT
46625: IFFALSE 46629
// exit ;
46627: GO 46771
// enable_addtolog := true ;
46629: LD_ADDR_OWVAR 81
46633: PUSH
46634: LD_INT 1
46636: ST_TO_ADDR
// AddToLog ( [ ) ;
46637: LD_STRING [
46639: PPUSH
46640: CALL_OW 561
// for i in tmp do
46644: LD_ADDR_VAR 0 3
46648: PUSH
46649: LD_VAR 0 4
46653: PUSH
46654: FOR_IN
46655: IFFALSE 46762
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46657: LD_STRING [
46659: PUSH
46660: LD_VAR 0 3
46664: PPUSH
46665: CALL_OW 266
46669: STR
46670: PUSH
46671: LD_STRING , 
46673: STR
46674: PUSH
46675: LD_VAR 0 3
46679: PPUSH
46680: CALL_OW 250
46684: STR
46685: PUSH
46686: LD_STRING , 
46688: STR
46689: PUSH
46690: LD_VAR 0 3
46694: PPUSH
46695: CALL_OW 251
46699: STR
46700: PUSH
46701: LD_STRING , 
46703: STR
46704: PUSH
46705: LD_VAR 0 3
46709: PPUSH
46710: CALL_OW 254
46714: STR
46715: PUSH
46716: LD_STRING , 
46718: STR
46719: PUSH
46720: LD_VAR 0 3
46724: PPUSH
46725: LD_INT 1
46727: PPUSH
46728: CALL_OW 268
46732: STR
46733: PUSH
46734: LD_STRING , 
46736: STR
46737: PUSH
46738: LD_VAR 0 3
46742: PPUSH
46743: LD_INT 2
46745: PPUSH
46746: CALL_OW 268
46750: STR
46751: PUSH
46752: LD_STRING ],
46754: STR
46755: PPUSH
46756: CALL_OW 561
// end ;
46760: GO 46654
46762: POP
46763: POP
// AddToLog ( ]; ) ;
46764: LD_STRING ];
46766: PPUSH
46767: CALL_OW 561
// end ;
46771: LD_VAR 0 2
46775: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
46776: LD_INT 0
46778: PPUSH
46779: PPUSH
46780: PPUSH
46781: PPUSH
46782: PPUSH
// if not area or not rate or not max then
46783: LD_VAR 0 1
46787: NOT
46788: PUSH
46789: LD_VAR 0 2
46793: NOT
46794: OR
46795: PUSH
46796: LD_VAR 0 4
46800: NOT
46801: OR
46802: IFFALSE 46806
// exit ;
46804: GO 46998
// while 1 do
46806: LD_INT 1
46808: IFFALSE 46998
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
46810: LD_ADDR_VAR 0 9
46814: PUSH
46815: LD_VAR 0 1
46819: PPUSH
46820: LD_INT 1
46822: PPUSH
46823: CALL_OW 287
46827: PUSH
46828: LD_INT 10
46830: MUL
46831: ST_TO_ADDR
// r := rate / 10 ;
46832: LD_ADDR_VAR 0 7
46836: PUSH
46837: LD_VAR 0 2
46841: PUSH
46842: LD_INT 10
46844: DIVREAL
46845: ST_TO_ADDR
// time := 1 1$00 ;
46846: LD_ADDR_VAR 0 8
46850: PUSH
46851: LD_INT 2100
46853: ST_TO_ADDR
// if amount < min then
46854: LD_VAR 0 9
46858: PUSH
46859: LD_VAR 0 3
46863: LESS
46864: IFFALSE 46882
// r := r * 2 else
46866: LD_ADDR_VAR 0 7
46870: PUSH
46871: LD_VAR 0 7
46875: PUSH
46876: LD_INT 2
46878: MUL
46879: ST_TO_ADDR
46880: GO 46908
// if amount > max then
46882: LD_VAR 0 9
46886: PUSH
46887: LD_VAR 0 4
46891: GREATER
46892: IFFALSE 46908
// r := r / 2 ;
46894: LD_ADDR_VAR 0 7
46898: PUSH
46899: LD_VAR 0 7
46903: PUSH
46904: LD_INT 2
46906: DIVREAL
46907: ST_TO_ADDR
// time := time / r ;
46908: LD_ADDR_VAR 0 8
46912: PUSH
46913: LD_VAR 0 8
46917: PUSH
46918: LD_VAR 0 7
46922: DIVREAL
46923: ST_TO_ADDR
// if time < 0 then
46924: LD_VAR 0 8
46928: PUSH
46929: LD_INT 0
46931: LESS
46932: IFFALSE 46949
// time := time * - 1 ;
46934: LD_ADDR_VAR 0 8
46938: PUSH
46939: LD_VAR 0 8
46943: PUSH
46944: LD_INT 1
46946: NEG
46947: MUL
46948: ST_TO_ADDR
// wait ( time ) ;
46949: LD_VAR 0 8
46953: PPUSH
46954: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
46958: LD_INT 35
46960: PPUSH
46961: LD_INT 875
46963: PPUSH
46964: CALL_OW 12
46968: PPUSH
46969: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
46973: LD_INT 1
46975: PPUSH
46976: LD_INT 5
46978: PPUSH
46979: CALL_OW 12
46983: PPUSH
46984: LD_VAR 0 1
46988: PPUSH
46989: LD_INT 1
46991: PPUSH
46992: CALL_OW 55
// end ;
46996: GO 46806
// end ;
46998: LD_VAR 0 5
47002: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47003: LD_INT 0
47005: PPUSH
47006: PPUSH
47007: PPUSH
47008: PPUSH
47009: PPUSH
47010: PPUSH
47011: PPUSH
47012: PPUSH
// if not turrets or not factories then
47013: LD_VAR 0 1
47017: NOT
47018: PUSH
47019: LD_VAR 0 2
47023: NOT
47024: OR
47025: IFFALSE 47029
// exit ;
47027: GO 47336
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47029: LD_ADDR_VAR 0 10
47033: PUSH
47034: LD_INT 5
47036: PUSH
47037: LD_INT 6
47039: PUSH
47040: EMPTY
47041: LIST
47042: LIST
47043: PUSH
47044: LD_INT 2
47046: PUSH
47047: LD_INT 4
47049: PUSH
47050: EMPTY
47051: LIST
47052: LIST
47053: PUSH
47054: LD_INT 3
47056: PUSH
47057: LD_INT 5
47059: PUSH
47060: EMPTY
47061: LIST
47062: LIST
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: LIST
47068: PUSH
47069: LD_INT 24
47071: PUSH
47072: LD_INT 25
47074: PUSH
47075: EMPTY
47076: LIST
47077: LIST
47078: PUSH
47079: LD_INT 23
47081: PUSH
47082: LD_INT 27
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: EMPTY
47090: LIST
47091: LIST
47092: PUSH
47093: LD_INT 42
47095: PUSH
47096: LD_INT 43
47098: PUSH
47099: EMPTY
47100: LIST
47101: LIST
47102: PUSH
47103: LD_INT 44
47105: PUSH
47106: LD_INT 46
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 45
47115: PUSH
47116: LD_INT 47
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: PUSH
47123: EMPTY
47124: LIST
47125: LIST
47126: LIST
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: LIST
47132: ST_TO_ADDR
// result := [ ] ;
47133: LD_ADDR_VAR 0 3
47137: PUSH
47138: EMPTY
47139: ST_TO_ADDR
// for i in turrets do
47140: LD_ADDR_VAR 0 4
47144: PUSH
47145: LD_VAR 0 1
47149: PUSH
47150: FOR_IN
47151: IFFALSE 47334
// begin nat := GetNation ( i ) ;
47153: LD_ADDR_VAR 0 7
47157: PUSH
47158: LD_VAR 0 4
47162: PPUSH
47163: CALL_OW 248
47167: ST_TO_ADDR
// weapon := 0 ;
47168: LD_ADDR_VAR 0 8
47172: PUSH
47173: LD_INT 0
47175: ST_TO_ADDR
// if not nat then
47176: LD_VAR 0 7
47180: NOT
47181: IFFALSE 47185
// continue ;
47183: GO 47150
// for j in list [ nat ] do
47185: LD_ADDR_VAR 0 5
47189: PUSH
47190: LD_VAR 0 10
47194: PUSH
47195: LD_VAR 0 7
47199: ARRAY
47200: PUSH
47201: FOR_IN
47202: IFFALSE 47243
// if GetBWeapon ( i ) = j [ 1 ] then
47204: LD_VAR 0 4
47208: PPUSH
47209: CALL_OW 269
47213: PUSH
47214: LD_VAR 0 5
47218: PUSH
47219: LD_INT 1
47221: ARRAY
47222: EQUAL
47223: IFFALSE 47241
// begin weapon := j [ 2 ] ;
47225: LD_ADDR_VAR 0 8
47229: PUSH
47230: LD_VAR 0 5
47234: PUSH
47235: LD_INT 2
47237: ARRAY
47238: ST_TO_ADDR
// break ;
47239: GO 47243
// end ;
47241: GO 47201
47243: POP
47244: POP
// if not weapon then
47245: LD_VAR 0 8
47249: NOT
47250: IFFALSE 47254
// continue ;
47252: GO 47150
// for k in factories do
47254: LD_ADDR_VAR 0 6
47258: PUSH
47259: LD_VAR 0 2
47263: PUSH
47264: FOR_IN
47265: IFFALSE 47330
// begin weapons := AvailableWeaponList ( k ) ;
47267: LD_ADDR_VAR 0 9
47271: PUSH
47272: LD_VAR 0 6
47276: PPUSH
47277: CALL_OW 478
47281: ST_TO_ADDR
// if not weapons then
47282: LD_VAR 0 9
47286: NOT
47287: IFFALSE 47291
// continue ;
47289: GO 47264
// if weapon in weapons then
47291: LD_VAR 0 8
47295: PUSH
47296: LD_VAR 0 9
47300: IN
47301: IFFALSE 47328
// begin result := [ i , weapon ] ;
47303: LD_ADDR_VAR 0 3
47307: PUSH
47308: LD_VAR 0 4
47312: PUSH
47313: LD_VAR 0 8
47317: PUSH
47318: EMPTY
47319: LIST
47320: LIST
47321: ST_TO_ADDR
// exit ;
47322: POP
47323: POP
47324: POP
47325: POP
47326: GO 47336
// end ; end ;
47328: GO 47264
47330: POP
47331: POP
// end ;
47332: GO 47150
47334: POP
47335: POP
// end ;
47336: LD_VAR 0 3
47340: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47341: LD_INT 0
47343: PPUSH
// if not side or side > 8 then
47344: LD_VAR 0 3
47348: NOT
47349: PUSH
47350: LD_VAR 0 3
47354: PUSH
47355: LD_INT 8
47357: GREATER
47358: OR
47359: IFFALSE 47363
// exit ;
47361: GO 47422
// if not range then
47363: LD_VAR 0 4
47367: NOT
47368: IFFALSE 47379
// range := - 12 ;
47370: LD_ADDR_VAR 0 4
47374: PUSH
47375: LD_INT 12
47377: NEG
47378: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47379: LD_VAR 0 1
47383: PPUSH
47384: LD_VAR 0 2
47388: PPUSH
47389: LD_VAR 0 3
47393: PPUSH
47394: LD_VAR 0 4
47398: PPUSH
47399: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47403: LD_VAR 0 1
47407: PPUSH
47408: LD_VAR 0 2
47412: PPUSH
47413: LD_VAR 0 3
47417: PPUSH
47418: CALL_OW 331
// end ;
47422: LD_VAR 0 5
47426: RET
// export function Video ( mode ) ; begin
47427: LD_INT 0
47429: PPUSH
// ingame_video = mode ;
47430: LD_ADDR_OWVAR 52
47434: PUSH
47435: LD_VAR 0 1
47439: ST_TO_ADDR
// interface_hidden = mode ;
47440: LD_ADDR_OWVAR 54
47444: PUSH
47445: LD_VAR 0 1
47449: ST_TO_ADDR
// end ;
47450: LD_VAR 0 2
47454: RET
// export function Join ( array , element ) ; begin
47455: LD_INT 0
47457: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47458: LD_ADDR_VAR 0 3
47462: PUSH
47463: LD_VAR 0 1
47467: PPUSH
47468: LD_VAR 0 1
47472: PUSH
47473: LD_INT 1
47475: PLUS
47476: PPUSH
47477: LD_VAR 0 2
47481: PPUSH
47482: CALL_OW 1
47486: ST_TO_ADDR
// end ;
47487: LD_VAR 0 3
47491: RET
// export function JoinUnion ( array , element ) ; begin
47492: LD_INT 0
47494: PPUSH
// result := array union element ;
47495: LD_ADDR_VAR 0 3
47499: PUSH
47500: LD_VAR 0 1
47504: PUSH
47505: LD_VAR 0 2
47509: UNION
47510: ST_TO_ADDR
// end ;
47511: LD_VAR 0 3
47515: RET
// export function GetBehemoths ( side ) ; begin
47516: LD_INT 0
47518: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
47519: LD_ADDR_VAR 0 2
47523: PUSH
47524: LD_INT 22
47526: PUSH
47527: LD_VAR 0 1
47531: PUSH
47532: EMPTY
47533: LIST
47534: LIST
47535: PUSH
47536: LD_INT 31
47538: PUSH
47539: LD_INT 25
47541: PUSH
47542: EMPTY
47543: LIST
47544: LIST
47545: PUSH
47546: EMPTY
47547: LIST
47548: LIST
47549: PPUSH
47550: CALL_OW 69
47554: ST_TO_ADDR
// end ;
47555: LD_VAR 0 2
47559: RET
// export function Shuffle ( array ) ; var i , index ; begin
47560: LD_INT 0
47562: PPUSH
47563: PPUSH
47564: PPUSH
// result := [ ] ;
47565: LD_ADDR_VAR 0 2
47569: PUSH
47570: EMPTY
47571: ST_TO_ADDR
// if not array then
47572: LD_VAR 0 1
47576: NOT
47577: IFFALSE 47581
// exit ;
47579: GO 47680
// Randomize ;
47581: CALL_OW 10
// for i = array downto 1 do
47585: LD_ADDR_VAR 0 3
47589: PUSH
47590: DOUBLE
47591: LD_VAR 0 1
47595: INC
47596: ST_TO_ADDR
47597: LD_INT 1
47599: PUSH
47600: FOR_DOWNTO
47601: IFFALSE 47678
// begin index := rand ( 1 , array ) ;
47603: LD_ADDR_VAR 0 4
47607: PUSH
47608: LD_INT 1
47610: PPUSH
47611: LD_VAR 0 1
47615: PPUSH
47616: CALL_OW 12
47620: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47621: LD_ADDR_VAR 0 2
47625: PUSH
47626: LD_VAR 0 2
47630: PPUSH
47631: LD_VAR 0 2
47635: PUSH
47636: LD_INT 1
47638: PLUS
47639: PPUSH
47640: LD_VAR 0 1
47644: PUSH
47645: LD_VAR 0 4
47649: ARRAY
47650: PPUSH
47651: CALL_OW 2
47655: ST_TO_ADDR
// array := Delete ( array , index ) ;
47656: LD_ADDR_VAR 0 1
47660: PUSH
47661: LD_VAR 0 1
47665: PPUSH
47666: LD_VAR 0 4
47670: PPUSH
47671: CALL_OW 3
47675: ST_TO_ADDR
// end ;
47676: GO 47600
47678: POP
47679: POP
// end ;
47680: LD_VAR 0 2
47684: RET
// export function GetBaseMaterials ( base ) ; begin
47685: LD_INT 0
47687: PPUSH
// result := [ 0 , 0 , 0 ] ;
47688: LD_ADDR_VAR 0 2
47692: PUSH
47693: LD_INT 0
47695: PUSH
47696: LD_INT 0
47698: PUSH
47699: LD_INT 0
47701: PUSH
47702: EMPTY
47703: LIST
47704: LIST
47705: LIST
47706: ST_TO_ADDR
// if not base then
47707: LD_VAR 0 1
47711: NOT
47712: IFFALSE 47716
// exit ;
47714: GO 47765
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
47716: LD_ADDR_VAR 0 2
47720: PUSH
47721: LD_VAR 0 1
47725: PPUSH
47726: LD_INT 1
47728: PPUSH
47729: CALL_OW 275
47733: PUSH
47734: LD_VAR 0 1
47738: PPUSH
47739: LD_INT 2
47741: PPUSH
47742: CALL_OW 275
47746: PUSH
47747: LD_VAR 0 1
47751: PPUSH
47752: LD_INT 3
47754: PPUSH
47755: CALL_OW 275
47759: PUSH
47760: EMPTY
47761: LIST
47762: LIST
47763: LIST
47764: ST_TO_ADDR
// end ;
47765: LD_VAR 0 2
47769: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
47770: LD_INT 0
47772: PPUSH
47773: PPUSH
// result := array ;
47774: LD_ADDR_VAR 0 3
47778: PUSH
47779: LD_VAR 0 1
47783: ST_TO_ADDR
// if size > 0 then
47784: LD_VAR 0 2
47788: PUSH
47789: LD_INT 0
47791: GREATER
47792: IFFALSE 47838
// for i := array downto size do
47794: LD_ADDR_VAR 0 4
47798: PUSH
47799: DOUBLE
47800: LD_VAR 0 1
47804: INC
47805: ST_TO_ADDR
47806: LD_VAR 0 2
47810: PUSH
47811: FOR_DOWNTO
47812: IFFALSE 47836
// result := Delete ( result , result ) ;
47814: LD_ADDR_VAR 0 3
47818: PUSH
47819: LD_VAR 0 3
47823: PPUSH
47824: LD_VAR 0 3
47828: PPUSH
47829: CALL_OW 3
47833: ST_TO_ADDR
47834: GO 47811
47836: POP
47837: POP
// end ;
47838: LD_VAR 0 3
47842: RET
// export function ComExit ( unit ) ; var tmp ; begin
47843: LD_INT 0
47845: PPUSH
47846: PPUSH
// if not IsInUnit ( unit ) then
47847: LD_VAR 0 1
47851: PPUSH
47852: CALL_OW 310
47856: NOT
47857: IFFALSE 47861
// exit ;
47859: GO 47921
// tmp := IsInUnit ( unit ) ;
47861: LD_ADDR_VAR 0 3
47865: PUSH
47866: LD_VAR 0 1
47870: PPUSH
47871: CALL_OW 310
47875: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
47876: LD_VAR 0 3
47880: PPUSH
47881: CALL_OW 247
47885: PUSH
47886: LD_INT 2
47888: EQUAL
47889: IFFALSE 47902
// ComExitVehicle ( unit ) else
47891: LD_VAR 0 1
47895: PPUSH
47896: CALL_OW 121
47900: GO 47911
// ComExitBuilding ( unit ) ;
47902: LD_VAR 0 1
47906: PPUSH
47907: CALL_OW 122
// result := tmp ;
47911: LD_ADDR_VAR 0 2
47915: PUSH
47916: LD_VAR 0 3
47920: ST_TO_ADDR
// end ;
47921: LD_VAR 0 2
47925: RET
// export function ComExitAll ( units ) ; var i ; begin
47926: LD_INT 0
47928: PPUSH
47929: PPUSH
// if not units then
47930: LD_VAR 0 1
47934: NOT
47935: IFFALSE 47939
// exit ;
47937: GO 47965
// for i in units do
47939: LD_ADDR_VAR 0 3
47943: PUSH
47944: LD_VAR 0 1
47948: PUSH
47949: FOR_IN
47950: IFFALSE 47963
// ComExit ( i ) ;
47952: LD_VAR 0 3
47956: PPUSH
47957: CALL 47843 0 1
47961: GO 47949
47963: POP
47964: POP
// end ;
47965: LD_VAR 0 2
47969: RET
// export function ResetHc ; begin
47970: LD_INT 0
47972: PPUSH
// InitHc ;
47973: CALL_OW 19
// hc_importance := 0 ;
47977: LD_ADDR_OWVAR 32
47981: PUSH
47982: LD_INT 0
47984: ST_TO_ADDR
// end ;
47985: LD_VAR 0 1
47989: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
47990: LD_INT 0
47992: PPUSH
47993: PPUSH
47994: PPUSH
// _x := ( x1 + x2 ) div 2 ;
47995: LD_ADDR_VAR 0 6
47999: PUSH
48000: LD_VAR 0 1
48004: PUSH
48005: LD_VAR 0 3
48009: PLUS
48010: PUSH
48011: LD_INT 2
48013: DIV
48014: ST_TO_ADDR
// if _x < 0 then
48015: LD_VAR 0 6
48019: PUSH
48020: LD_INT 0
48022: LESS
48023: IFFALSE 48040
// _x := _x * - 1 ;
48025: LD_ADDR_VAR 0 6
48029: PUSH
48030: LD_VAR 0 6
48034: PUSH
48035: LD_INT 1
48037: NEG
48038: MUL
48039: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
48040: LD_ADDR_VAR 0 7
48044: PUSH
48045: LD_VAR 0 2
48049: PUSH
48050: LD_VAR 0 4
48054: PLUS
48055: PUSH
48056: LD_INT 2
48058: DIV
48059: ST_TO_ADDR
// if _y < 0 then
48060: LD_VAR 0 7
48064: PUSH
48065: LD_INT 0
48067: LESS
48068: IFFALSE 48085
// _y := _y * - 1 ;
48070: LD_ADDR_VAR 0 7
48074: PUSH
48075: LD_VAR 0 7
48079: PUSH
48080: LD_INT 1
48082: NEG
48083: MUL
48084: ST_TO_ADDR
// result := [ _x , _y ] ;
48085: LD_ADDR_VAR 0 5
48089: PUSH
48090: LD_VAR 0 6
48094: PUSH
48095: LD_VAR 0 7
48099: PUSH
48100: EMPTY
48101: LIST
48102: LIST
48103: ST_TO_ADDR
// end ;
48104: LD_VAR 0 5
48108: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
48109: LD_INT 0
48111: PPUSH
48112: PPUSH
48113: PPUSH
48114: PPUSH
// task := GetTaskList ( unit ) ;
48115: LD_ADDR_VAR 0 7
48119: PUSH
48120: LD_VAR 0 1
48124: PPUSH
48125: CALL_OW 437
48129: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48130: LD_VAR 0 7
48134: NOT
48135: PUSH
48136: LD_VAR 0 1
48140: PPUSH
48141: LD_VAR 0 2
48145: PPUSH
48146: CALL_OW 308
48150: NOT
48151: AND
48152: IFFALSE 48156
// exit ;
48154: GO 48274
// if IsInArea ( unit , area ) then
48156: LD_VAR 0 1
48160: PPUSH
48161: LD_VAR 0 2
48165: PPUSH
48166: CALL_OW 308
48170: IFFALSE 48188
// begin ComMoveToArea ( unit , goAway ) ;
48172: LD_VAR 0 1
48176: PPUSH
48177: LD_VAR 0 3
48181: PPUSH
48182: CALL_OW 113
// exit ;
48186: GO 48274
// end ; if task [ 1 ] [ 1 ] <> M then
48188: LD_VAR 0 7
48192: PUSH
48193: LD_INT 1
48195: ARRAY
48196: PUSH
48197: LD_INT 1
48199: ARRAY
48200: PUSH
48201: LD_STRING M
48203: NONEQUAL
48204: IFFALSE 48208
// exit ;
48206: GO 48274
// x := task [ 1 ] [ 2 ] ;
48208: LD_ADDR_VAR 0 5
48212: PUSH
48213: LD_VAR 0 7
48217: PUSH
48218: LD_INT 1
48220: ARRAY
48221: PUSH
48222: LD_INT 2
48224: ARRAY
48225: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48226: LD_ADDR_VAR 0 6
48230: PUSH
48231: LD_VAR 0 7
48235: PUSH
48236: LD_INT 1
48238: ARRAY
48239: PUSH
48240: LD_INT 3
48242: ARRAY
48243: ST_TO_ADDR
// if InArea ( x , y , area ) then
48244: LD_VAR 0 5
48248: PPUSH
48249: LD_VAR 0 6
48253: PPUSH
48254: LD_VAR 0 2
48258: PPUSH
48259: CALL_OW 309
48263: IFFALSE 48274
// ComStop ( unit ) ;
48265: LD_VAR 0 1
48269: PPUSH
48270: CALL_OW 141
// end ;
48274: LD_VAR 0 4
48278: RET
// export function Abs ( value ) ; begin
48279: LD_INT 0
48281: PPUSH
// result := value ;
48282: LD_ADDR_VAR 0 2
48286: PUSH
48287: LD_VAR 0 1
48291: ST_TO_ADDR
// if value < 0 then
48292: LD_VAR 0 1
48296: PUSH
48297: LD_INT 0
48299: LESS
48300: IFFALSE 48317
// result := value * - 1 ;
48302: LD_ADDR_VAR 0 2
48306: PUSH
48307: LD_VAR 0 1
48311: PUSH
48312: LD_INT 1
48314: NEG
48315: MUL
48316: ST_TO_ADDR
// end ;
48317: LD_VAR 0 2
48321: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48322: LD_INT 0
48324: PPUSH
48325: PPUSH
48326: PPUSH
48327: PPUSH
48328: PPUSH
48329: PPUSH
48330: PPUSH
48331: PPUSH
// if not unit or not building then
48332: LD_VAR 0 1
48336: NOT
48337: PUSH
48338: LD_VAR 0 2
48342: NOT
48343: OR
48344: IFFALSE 48348
// exit ;
48346: GO 48574
// x := GetX ( building ) ;
48348: LD_ADDR_VAR 0 4
48352: PUSH
48353: LD_VAR 0 2
48357: PPUSH
48358: CALL_OW 250
48362: ST_TO_ADDR
// y := GetY ( building ) ;
48363: LD_ADDR_VAR 0 6
48367: PUSH
48368: LD_VAR 0 2
48372: PPUSH
48373: CALL_OW 251
48377: ST_TO_ADDR
// d := GetDir ( building ) ;
48378: LD_ADDR_VAR 0 8
48382: PUSH
48383: LD_VAR 0 2
48387: PPUSH
48388: CALL_OW 254
48392: ST_TO_ADDR
// r := 4 ;
48393: LD_ADDR_VAR 0 9
48397: PUSH
48398: LD_INT 4
48400: ST_TO_ADDR
// for i := 1 to 5 do
48401: LD_ADDR_VAR 0 10
48405: PUSH
48406: DOUBLE
48407: LD_INT 1
48409: DEC
48410: ST_TO_ADDR
48411: LD_INT 5
48413: PUSH
48414: FOR_TO
48415: IFFALSE 48572
// begin _x := ShiftX ( x , d , r + i ) ;
48417: LD_ADDR_VAR 0 5
48421: PUSH
48422: LD_VAR 0 4
48426: PPUSH
48427: LD_VAR 0 8
48431: PPUSH
48432: LD_VAR 0 9
48436: PUSH
48437: LD_VAR 0 10
48441: PLUS
48442: PPUSH
48443: CALL_OW 272
48447: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48448: LD_ADDR_VAR 0 7
48452: PUSH
48453: LD_VAR 0 6
48457: PPUSH
48458: LD_VAR 0 8
48462: PPUSH
48463: LD_VAR 0 9
48467: PUSH
48468: LD_VAR 0 10
48472: PLUS
48473: PPUSH
48474: CALL_OW 273
48478: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48479: LD_VAR 0 5
48483: PPUSH
48484: LD_VAR 0 7
48488: PPUSH
48489: CALL_OW 488
48493: PUSH
48494: LD_VAR 0 5
48498: PPUSH
48499: LD_VAR 0 7
48503: PPUSH
48504: CALL_OW 428
48508: PPUSH
48509: CALL_OW 247
48513: PUSH
48514: LD_INT 3
48516: PUSH
48517: LD_INT 2
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: IN
48524: NOT
48525: AND
48526: IFFALSE 48570
// begin ComMoveXY ( unit , _x , _y ) ;
48528: LD_VAR 0 1
48532: PPUSH
48533: LD_VAR 0 5
48537: PPUSH
48538: LD_VAR 0 7
48542: PPUSH
48543: CALL_OW 111
// result := [ _x , _y ] ;
48547: LD_ADDR_VAR 0 3
48551: PUSH
48552: LD_VAR 0 5
48556: PUSH
48557: LD_VAR 0 7
48561: PUSH
48562: EMPTY
48563: LIST
48564: LIST
48565: ST_TO_ADDR
// exit ;
48566: POP
48567: POP
48568: GO 48574
// end ; end ;
48570: GO 48414
48572: POP
48573: POP
// end ;
48574: LD_VAR 0 3
48578: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48579: LD_INT 0
48581: PPUSH
48582: PPUSH
48583: PPUSH
// result := 0 ;
48584: LD_ADDR_VAR 0 3
48588: PUSH
48589: LD_INT 0
48591: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48592: LD_VAR 0 1
48596: PUSH
48597: LD_INT 0
48599: LESS
48600: PUSH
48601: LD_VAR 0 1
48605: PUSH
48606: LD_INT 8
48608: GREATER
48609: OR
48610: PUSH
48611: LD_VAR 0 2
48615: PUSH
48616: LD_INT 0
48618: LESS
48619: OR
48620: PUSH
48621: LD_VAR 0 2
48625: PUSH
48626: LD_INT 8
48628: GREATER
48629: OR
48630: IFFALSE 48634
// exit ;
48632: GO 48709
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48634: LD_ADDR_VAR 0 4
48638: PUSH
48639: LD_INT 22
48641: PUSH
48642: LD_VAR 0 2
48646: PUSH
48647: EMPTY
48648: LIST
48649: LIST
48650: PPUSH
48651: CALL_OW 69
48655: PUSH
48656: FOR_IN
48657: IFFALSE 48707
// begin un := UnitShoot ( i ) ;
48659: LD_ADDR_VAR 0 5
48663: PUSH
48664: LD_VAR 0 4
48668: PPUSH
48669: CALL_OW 504
48673: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48674: LD_VAR 0 5
48678: PPUSH
48679: CALL_OW 255
48683: PUSH
48684: LD_VAR 0 1
48688: EQUAL
48689: IFFALSE 48705
// begin result := un ;
48691: LD_ADDR_VAR 0 3
48695: PUSH
48696: LD_VAR 0 5
48700: ST_TO_ADDR
// exit ;
48701: POP
48702: POP
48703: GO 48709
// end ; end ;
48705: GO 48656
48707: POP
48708: POP
// end ;
48709: LD_VAR 0 3
48713: RET
// export function GetCargoBay ( units ) ; begin
48714: LD_INT 0
48716: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
48717: LD_ADDR_VAR 0 2
48721: PUSH
48722: LD_VAR 0 1
48726: PPUSH
48727: LD_INT 2
48729: PUSH
48730: LD_INT 34
48732: PUSH
48733: LD_INT 12
48735: PUSH
48736: EMPTY
48737: LIST
48738: LIST
48739: PUSH
48740: LD_INT 34
48742: PUSH
48743: LD_INT 51
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: PUSH
48750: LD_INT 34
48752: PUSH
48753: LD_INT 32
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 34
48762: PUSH
48763: LD_EXP 68
48767: PUSH
48768: EMPTY
48769: LIST
48770: LIST
48771: PUSH
48772: EMPTY
48773: LIST
48774: LIST
48775: LIST
48776: LIST
48777: LIST
48778: PPUSH
48779: CALL_OW 72
48783: ST_TO_ADDR
// end ;
48784: LD_VAR 0 2
48788: RET
// export function Negate ( value ) ; begin
48789: LD_INT 0
48791: PPUSH
// result := not value ;
48792: LD_ADDR_VAR 0 2
48796: PUSH
48797: LD_VAR 0 1
48801: NOT
48802: ST_TO_ADDR
// end ;
48803: LD_VAR 0 2
48807: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
48808: LD_INT 0
48810: PPUSH
// if x1 = x2 then
48811: LD_VAR 0 1
48815: PUSH
48816: LD_VAR 0 3
48820: EQUAL
48821: IFFALSE 48855
// begin if y1 > y2 then
48823: LD_VAR 0 2
48827: PUSH
48828: LD_VAR 0 4
48832: GREATER
48833: IFFALSE 48845
// result := 0 else
48835: LD_ADDR_VAR 0 5
48839: PUSH
48840: LD_INT 0
48842: ST_TO_ADDR
48843: GO 48853
// result := 3 ;
48845: LD_ADDR_VAR 0 5
48849: PUSH
48850: LD_INT 3
48852: ST_TO_ADDR
// exit ;
48853: GO 48941
// end ; if y1 = y2 then
48855: LD_VAR 0 2
48859: PUSH
48860: LD_VAR 0 4
48864: EQUAL
48865: IFFALSE 48899
// begin if x1 > x2 then
48867: LD_VAR 0 1
48871: PUSH
48872: LD_VAR 0 3
48876: GREATER
48877: IFFALSE 48889
// result := 1 else
48879: LD_ADDR_VAR 0 5
48883: PUSH
48884: LD_INT 1
48886: ST_TO_ADDR
48887: GO 48897
// result := 4 ;
48889: LD_ADDR_VAR 0 5
48893: PUSH
48894: LD_INT 4
48896: ST_TO_ADDR
// exit ;
48897: GO 48941
// end ; if x1 > x2 and y1 > y2 then
48899: LD_VAR 0 1
48903: PUSH
48904: LD_VAR 0 3
48908: GREATER
48909: PUSH
48910: LD_VAR 0 2
48914: PUSH
48915: LD_VAR 0 4
48919: GREATER
48920: AND
48921: IFFALSE 48933
// result := 2 else
48923: LD_ADDR_VAR 0 5
48927: PUSH
48928: LD_INT 2
48930: ST_TO_ADDR
48931: GO 48941
// result := 5 ;
48933: LD_ADDR_VAR 0 5
48937: PUSH
48938: LD_INT 5
48940: ST_TO_ADDR
// end ;
48941: LD_VAR 0 5
48945: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
48946: LD_INT 0
48948: PPUSH
48949: PPUSH
// if not driver or not IsInUnit ( driver ) then
48950: LD_VAR 0 1
48954: NOT
48955: PUSH
48956: LD_VAR 0 1
48960: PPUSH
48961: CALL_OW 310
48965: NOT
48966: OR
48967: IFFALSE 48971
// exit ;
48969: GO 49061
// vehicle := IsInUnit ( driver ) ;
48971: LD_ADDR_VAR 0 3
48975: PUSH
48976: LD_VAR 0 1
48980: PPUSH
48981: CALL_OW 310
48985: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
48986: LD_VAR 0 1
48990: PPUSH
48991: LD_STRING \
48993: PUSH
48994: LD_INT 0
48996: PUSH
48997: LD_INT 0
48999: PUSH
49000: LD_INT 0
49002: PUSH
49003: LD_INT 0
49005: PUSH
49006: LD_INT 0
49008: PUSH
49009: LD_INT 0
49011: PUSH
49012: EMPTY
49013: LIST
49014: LIST
49015: LIST
49016: LIST
49017: LIST
49018: LIST
49019: LIST
49020: PUSH
49021: LD_STRING E
49023: PUSH
49024: LD_INT 0
49026: PUSH
49027: LD_INT 0
49029: PUSH
49030: LD_VAR 0 3
49034: PUSH
49035: LD_INT 0
49037: PUSH
49038: LD_INT 0
49040: PUSH
49041: LD_INT 0
49043: PUSH
49044: EMPTY
49045: LIST
49046: LIST
49047: LIST
49048: LIST
49049: LIST
49050: LIST
49051: LIST
49052: PUSH
49053: EMPTY
49054: LIST
49055: LIST
49056: PPUSH
49057: CALL_OW 446
// end ;
49061: LD_VAR 0 2
49065: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49066: LD_INT 0
49068: PPUSH
49069: PPUSH
// if not driver or not IsInUnit ( driver ) then
49070: LD_VAR 0 1
49074: NOT
49075: PUSH
49076: LD_VAR 0 1
49080: PPUSH
49081: CALL_OW 310
49085: NOT
49086: OR
49087: IFFALSE 49091
// exit ;
49089: GO 49181
// vehicle := IsInUnit ( driver ) ;
49091: LD_ADDR_VAR 0 3
49095: PUSH
49096: LD_VAR 0 1
49100: PPUSH
49101: CALL_OW 310
49105: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49106: LD_VAR 0 1
49110: PPUSH
49111: LD_STRING \
49113: PUSH
49114: LD_INT 0
49116: PUSH
49117: LD_INT 0
49119: PUSH
49120: LD_INT 0
49122: PUSH
49123: LD_INT 0
49125: PUSH
49126: LD_INT 0
49128: PUSH
49129: LD_INT 0
49131: PUSH
49132: EMPTY
49133: LIST
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: PUSH
49141: LD_STRING E
49143: PUSH
49144: LD_INT 0
49146: PUSH
49147: LD_INT 0
49149: PUSH
49150: LD_VAR 0 3
49154: PUSH
49155: LD_INT 0
49157: PUSH
49158: LD_INT 0
49160: PUSH
49161: LD_INT 0
49163: PUSH
49164: EMPTY
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: PUSH
49173: EMPTY
49174: LIST
49175: LIST
49176: PPUSH
49177: CALL_OW 447
// end ;
49181: LD_VAR 0 2
49185: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49186: LD_INT 0
49188: PPUSH
49189: PPUSH
49190: PPUSH
// tmp := [ ] ;
49191: LD_ADDR_VAR 0 5
49195: PUSH
49196: EMPTY
49197: ST_TO_ADDR
// for i in units do
49198: LD_ADDR_VAR 0 4
49202: PUSH
49203: LD_VAR 0 1
49207: PUSH
49208: FOR_IN
49209: IFFALSE 49247
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49211: LD_ADDR_VAR 0 5
49215: PUSH
49216: LD_VAR 0 5
49220: PPUSH
49221: LD_VAR 0 5
49225: PUSH
49226: LD_INT 1
49228: PLUS
49229: PPUSH
49230: LD_VAR 0 4
49234: PPUSH
49235: CALL_OW 256
49239: PPUSH
49240: CALL_OW 2
49244: ST_TO_ADDR
49245: GO 49208
49247: POP
49248: POP
// if not tmp then
49249: LD_VAR 0 5
49253: NOT
49254: IFFALSE 49258
// exit ;
49256: GO 49306
// if asc then
49258: LD_VAR 0 2
49262: IFFALSE 49286
// result := SortListByListAsc ( units , tmp ) else
49264: LD_ADDR_VAR 0 3
49268: PUSH
49269: LD_VAR 0 1
49273: PPUSH
49274: LD_VAR 0 5
49278: PPUSH
49279: CALL_OW 76
49283: ST_TO_ADDR
49284: GO 49306
// result := SortListByListDesc ( units , tmp ) ;
49286: LD_ADDR_VAR 0 3
49290: PUSH
49291: LD_VAR 0 1
49295: PPUSH
49296: LD_VAR 0 5
49300: PPUSH
49301: CALL_OW 77
49305: ST_TO_ADDR
// end ;
49306: LD_VAR 0 3
49310: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49311: LD_INT 0
49313: PPUSH
49314: PPUSH
// task := GetTaskList ( mech ) ;
49315: LD_ADDR_VAR 0 4
49319: PUSH
49320: LD_VAR 0 1
49324: PPUSH
49325: CALL_OW 437
49329: ST_TO_ADDR
// if not task then
49330: LD_VAR 0 4
49334: NOT
49335: IFFALSE 49339
// exit ;
49337: GO 49381
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49339: LD_ADDR_VAR 0 3
49343: PUSH
49344: LD_VAR 0 4
49348: PUSH
49349: LD_INT 1
49351: ARRAY
49352: PUSH
49353: LD_INT 1
49355: ARRAY
49356: PUSH
49357: LD_STRING r
49359: EQUAL
49360: PUSH
49361: LD_VAR 0 4
49365: PUSH
49366: LD_INT 1
49368: ARRAY
49369: PUSH
49370: LD_INT 4
49372: ARRAY
49373: PUSH
49374: LD_VAR 0 2
49378: EQUAL
49379: AND
49380: ST_TO_ADDR
// end ;
49381: LD_VAR 0 3
49385: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49386: LD_INT 0
49388: PPUSH
// SetDir ( unit , d ) ;
49389: LD_VAR 0 1
49393: PPUSH
49394: LD_VAR 0 4
49398: PPUSH
49399: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49403: LD_VAR 0 1
49407: PPUSH
49408: LD_VAR 0 2
49412: PPUSH
49413: LD_VAR 0 3
49417: PPUSH
49418: LD_VAR 0 5
49422: PPUSH
49423: CALL_OW 48
// end ;
49427: LD_VAR 0 6
49431: RET
// export function ToNaturalNumber ( number ) ; begin
49432: LD_INT 0
49434: PPUSH
// result := number div 1 ;
49435: LD_ADDR_VAR 0 2
49439: PUSH
49440: LD_VAR 0 1
49444: PUSH
49445: LD_INT 1
49447: DIV
49448: ST_TO_ADDR
// if number < 0 then
49449: LD_VAR 0 1
49453: PUSH
49454: LD_INT 0
49456: LESS
49457: IFFALSE 49467
// result := 0 ;
49459: LD_ADDR_VAR 0 2
49463: PUSH
49464: LD_INT 0
49466: ST_TO_ADDR
// end ;
49467: LD_VAR 0 2
49471: RET
// export function SortByClass ( units , class ) ; var un ; begin
49472: LD_INT 0
49474: PPUSH
49475: PPUSH
// if not units or not class then
49476: LD_VAR 0 1
49480: NOT
49481: PUSH
49482: LD_VAR 0 2
49486: NOT
49487: OR
49488: IFFALSE 49492
// exit ;
49490: GO 49587
// result := [ ] ;
49492: LD_ADDR_VAR 0 3
49496: PUSH
49497: EMPTY
49498: ST_TO_ADDR
// for un in units do
49499: LD_ADDR_VAR 0 4
49503: PUSH
49504: LD_VAR 0 1
49508: PUSH
49509: FOR_IN
49510: IFFALSE 49585
// if GetClass ( un ) = class then
49512: LD_VAR 0 4
49516: PPUSH
49517: CALL_OW 257
49521: PUSH
49522: LD_VAR 0 2
49526: EQUAL
49527: IFFALSE 49554
// result := Insert ( result , 1 , un ) else
49529: LD_ADDR_VAR 0 3
49533: PUSH
49534: LD_VAR 0 3
49538: PPUSH
49539: LD_INT 1
49541: PPUSH
49542: LD_VAR 0 4
49546: PPUSH
49547: CALL_OW 2
49551: ST_TO_ADDR
49552: GO 49583
// result := Replace ( result , result + 1 , un ) ;
49554: LD_ADDR_VAR 0 3
49558: PUSH
49559: LD_VAR 0 3
49563: PPUSH
49564: LD_VAR 0 3
49568: PUSH
49569: LD_INT 1
49571: PLUS
49572: PPUSH
49573: LD_VAR 0 4
49577: PPUSH
49578: CALL_OW 1
49582: ST_TO_ADDR
49583: GO 49509
49585: POP
49586: POP
// end ; end_of_file
49587: LD_VAR 0 3
49591: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
49592: LD_INT 0
49594: PPUSH
49595: PPUSH
// skirmish := false ;
49596: LD_ADDR_EXP 21
49600: PUSH
49601: LD_INT 0
49603: ST_TO_ADDR
// debug_mc := false ;
49604: LD_ADDR_EXP 22
49608: PUSH
49609: LD_INT 0
49611: ST_TO_ADDR
// mc_bases := [ ] ;
49612: LD_ADDR_EXP 23
49616: PUSH
49617: EMPTY
49618: ST_TO_ADDR
// mc_sides := [ ] ;
49619: LD_ADDR_EXP 49
49623: PUSH
49624: EMPTY
49625: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
49626: LD_ADDR_EXP 24
49630: PUSH
49631: EMPTY
49632: ST_TO_ADDR
// mc_building_repairs := [ ] ;
49633: LD_ADDR_EXP 25
49637: PUSH
49638: EMPTY
49639: ST_TO_ADDR
// mc_need_heal := [ ] ;
49640: LD_ADDR_EXP 26
49644: PUSH
49645: EMPTY
49646: ST_TO_ADDR
// mc_healers := [ ] ;
49647: LD_ADDR_EXP 27
49651: PUSH
49652: EMPTY
49653: ST_TO_ADDR
// mc_build_list := [ ] ;
49654: LD_ADDR_EXP 28
49658: PUSH
49659: EMPTY
49660: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
49661: LD_ADDR_EXP 55
49665: PUSH
49666: EMPTY
49667: ST_TO_ADDR
// mc_builders := [ ] ;
49668: LD_ADDR_EXP 29
49672: PUSH
49673: EMPTY
49674: ST_TO_ADDR
// mc_construct_list := [ ] ;
49675: LD_ADDR_EXP 30
49679: PUSH
49680: EMPTY
49681: ST_TO_ADDR
// mc_turret_list := [ ] ;
49682: LD_ADDR_EXP 31
49686: PUSH
49687: EMPTY
49688: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
49689: LD_ADDR_EXP 32
49693: PUSH
49694: EMPTY
49695: ST_TO_ADDR
// mc_miners := [ ] ;
49696: LD_ADDR_EXP 37
49700: PUSH
49701: EMPTY
49702: ST_TO_ADDR
// mc_mines := [ ] ;
49703: LD_ADDR_EXP 36
49707: PUSH
49708: EMPTY
49709: ST_TO_ADDR
// mc_minefields := [ ] ;
49710: LD_ADDR_EXP 38
49714: PUSH
49715: EMPTY
49716: ST_TO_ADDR
// mc_crates := [ ] ;
49717: LD_ADDR_EXP 39
49721: PUSH
49722: EMPTY
49723: ST_TO_ADDR
// mc_crates_collector := [ ] ;
49724: LD_ADDR_EXP 40
49728: PUSH
49729: EMPTY
49730: ST_TO_ADDR
// mc_crates_area := [ ] ;
49731: LD_ADDR_EXP 41
49735: PUSH
49736: EMPTY
49737: ST_TO_ADDR
// mc_vehicles := [ ] ;
49738: LD_ADDR_EXP 42
49742: PUSH
49743: EMPTY
49744: ST_TO_ADDR
// mc_attack := [ ] ;
49745: LD_ADDR_EXP 43
49749: PUSH
49750: EMPTY
49751: ST_TO_ADDR
// mc_produce := [ ] ;
49752: LD_ADDR_EXP 44
49756: PUSH
49757: EMPTY
49758: ST_TO_ADDR
// mc_defender := [ ] ;
49759: LD_ADDR_EXP 45
49763: PUSH
49764: EMPTY
49765: ST_TO_ADDR
// mc_parking := [ ] ;
49766: LD_ADDR_EXP 47
49770: PUSH
49771: EMPTY
49772: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
49773: LD_ADDR_EXP 33
49777: PUSH
49778: EMPTY
49779: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
49780: LD_ADDR_EXP 35
49784: PUSH
49785: EMPTY
49786: ST_TO_ADDR
// mc_scan := [ ] ;
49787: LD_ADDR_EXP 46
49791: PUSH
49792: EMPTY
49793: ST_TO_ADDR
// mc_scan_area := [ ] ;
49794: LD_ADDR_EXP 48
49798: PUSH
49799: EMPTY
49800: ST_TO_ADDR
// mc_tech := [ ] ;
49801: LD_ADDR_EXP 50
49805: PUSH
49806: EMPTY
49807: ST_TO_ADDR
// mc_class := [ ] ;
49808: LD_ADDR_EXP 64
49812: PUSH
49813: EMPTY
49814: ST_TO_ADDR
// mc_class_case_use := [ ] ;
49815: LD_ADDR_EXP 65
49819: PUSH
49820: EMPTY
49821: ST_TO_ADDR
// mc_is_defending := [ ] ;
49822: LD_ADDR_EXP 66
49826: PUSH
49827: EMPTY
49828: ST_TO_ADDR
// end ;
49829: LD_VAR 0 1
49833: RET
// export function MC_Kill ( base ) ; begin
49834: LD_INT 0
49836: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
49837: LD_ADDR_EXP 23
49841: PUSH
49842: LD_EXP 23
49846: PPUSH
49847: LD_VAR 0 1
49851: PPUSH
49852: EMPTY
49853: PPUSH
49854: CALL_OW 1
49858: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
49859: LD_ADDR_EXP 24
49863: PUSH
49864: LD_EXP 24
49868: PPUSH
49869: LD_VAR 0 1
49873: PPUSH
49874: EMPTY
49875: PPUSH
49876: CALL_OW 1
49880: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
49881: LD_ADDR_EXP 25
49885: PUSH
49886: LD_EXP 25
49890: PPUSH
49891: LD_VAR 0 1
49895: PPUSH
49896: EMPTY
49897: PPUSH
49898: CALL_OW 1
49902: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
49903: LD_ADDR_EXP 26
49907: PUSH
49908: LD_EXP 26
49912: PPUSH
49913: LD_VAR 0 1
49917: PPUSH
49918: EMPTY
49919: PPUSH
49920: CALL_OW 1
49924: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
49925: LD_ADDR_EXP 27
49929: PUSH
49930: LD_EXP 27
49934: PPUSH
49935: LD_VAR 0 1
49939: PPUSH
49940: EMPTY
49941: PPUSH
49942: CALL_OW 1
49946: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
49947: LD_ADDR_EXP 28
49951: PUSH
49952: LD_EXP 28
49956: PPUSH
49957: LD_VAR 0 1
49961: PPUSH
49962: EMPTY
49963: PPUSH
49964: CALL_OW 1
49968: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
49969: LD_ADDR_EXP 29
49973: PUSH
49974: LD_EXP 29
49978: PPUSH
49979: LD_VAR 0 1
49983: PPUSH
49984: EMPTY
49985: PPUSH
49986: CALL_OW 1
49990: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
49991: LD_ADDR_EXP 30
49995: PUSH
49996: LD_EXP 30
50000: PPUSH
50001: LD_VAR 0 1
50005: PPUSH
50006: EMPTY
50007: PPUSH
50008: CALL_OW 1
50012: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50013: LD_ADDR_EXP 31
50017: PUSH
50018: LD_EXP 31
50022: PPUSH
50023: LD_VAR 0 1
50027: PPUSH
50028: EMPTY
50029: PPUSH
50030: CALL_OW 1
50034: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50035: LD_ADDR_EXP 32
50039: PUSH
50040: LD_EXP 32
50044: PPUSH
50045: LD_VAR 0 1
50049: PPUSH
50050: EMPTY
50051: PPUSH
50052: CALL_OW 1
50056: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50057: LD_ADDR_EXP 33
50061: PUSH
50062: LD_EXP 33
50066: PPUSH
50067: LD_VAR 0 1
50071: PPUSH
50072: EMPTY
50073: PPUSH
50074: CALL_OW 1
50078: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
50079: LD_ADDR_EXP 34
50083: PUSH
50084: LD_EXP 34
50088: PPUSH
50089: LD_VAR 0 1
50093: PPUSH
50094: LD_INT 0
50096: PPUSH
50097: CALL_OW 1
50101: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
50102: LD_ADDR_EXP 35
50106: PUSH
50107: LD_EXP 35
50111: PPUSH
50112: LD_VAR 0 1
50116: PPUSH
50117: EMPTY
50118: PPUSH
50119: CALL_OW 1
50123: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
50124: LD_ADDR_EXP 36
50128: PUSH
50129: LD_EXP 36
50133: PPUSH
50134: LD_VAR 0 1
50138: PPUSH
50139: EMPTY
50140: PPUSH
50141: CALL_OW 1
50145: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
50146: LD_ADDR_EXP 37
50150: PUSH
50151: LD_EXP 37
50155: PPUSH
50156: LD_VAR 0 1
50160: PPUSH
50161: EMPTY
50162: PPUSH
50163: CALL_OW 1
50167: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
50168: LD_ADDR_EXP 38
50172: PUSH
50173: LD_EXP 38
50177: PPUSH
50178: LD_VAR 0 1
50182: PPUSH
50183: EMPTY
50184: PPUSH
50185: CALL_OW 1
50189: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
50190: LD_ADDR_EXP 39
50194: PUSH
50195: LD_EXP 39
50199: PPUSH
50200: LD_VAR 0 1
50204: PPUSH
50205: EMPTY
50206: PPUSH
50207: CALL_OW 1
50211: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
50212: LD_ADDR_EXP 40
50216: PUSH
50217: LD_EXP 40
50221: PPUSH
50222: LD_VAR 0 1
50226: PPUSH
50227: EMPTY
50228: PPUSH
50229: CALL_OW 1
50233: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
50234: LD_ADDR_EXP 41
50238: PUSH
50239: LD_EXP 41
50243: PPUSH
50244: LD_VAR 0 1
50248: PPUSH
50249: EMPTY
50250: PPUSH
50251: CALL_OW 1
50255: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
50256: LD_ADDR_EXP 42
50260: PUSH
50261: LD_EXP 42
50265: PPUSH
50266: LD_VAR 0 1
50270: PPUSH
50271: EMPTY
50272: PPUSH
50273: CALL_OW 1
50277: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
50278: LD_ADDR_EXP 43
50282: PUSH
50283: LD_EXP 43
50287: PPUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: EMPTY
50294: PPUSH
50295: CALL_OW 1
50299: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
50300: LD_ADDR_EXP 44
50304: PUSH
50305: LD_EXP 44
50309: PPUSH
50310: LD_VAR 0 1
50314: PPUSH
50315: EMPTY
50316: PPUSH
50317: CALL_OW 1
50321: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
50322: LD_ADDR_EXP 45
50326: PUSH
50327: LD_EXP 45
50331: PPUSH
50332: LD_VAR 0 1
50336: PPUSH
50337: EMPTY
50338: PPUSH
50339: CALL_OW 1
50343: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
50344: LD_ADDR_EXP 46
50348: PUSH
50349: LD_EXP 46
50353: PPUSH
50354: LD_VAR 0 1
50358: PPUSH
50359: EMPTY
50360: PPUSH
50361: CALL_OW 1
50365: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
50366: LD_ADDR_EXP 47
50370: PUSH
50371: LD_EXP 47
50375: PPUSH
50376: LD_VAR 0 1
50380: PPUSH
50381: EMPTY
50382: PPUSH
50383: CALL_OW 1
50387: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
50388: LD_ADDR_EXP 48
50392: PUSH
50393: LD_EXP 48
50397: PPUSH
50398: LD_VAR 0 1
50402: PPUSH
50403: EMPTY
50404: PPUSH
50405: CALL_OW 1
50409: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
50410: LD_ADDR_EXP 50
50414: PUSH
50415: LD_EXP 50
50419: PPUSH
50420: LD_VAR 0 1
50424: PPUSH
50425: EMPTY
50426: PPUSH
50427: CALL_OW 1
50431: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
50432: LD_ADDR_EXP 52
50436: PUSH
50437: LD_EXP 52
50441: PPUSH
50442: LD_VAR 0 1
50446: PPUSH
50447: EMPTY
50448: PPUSH
50449: CALL_OW 1
50453: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
50454: LD_ADDR_EXP 53
50458: PUSH
50459: LD_EXP 53
50463: PPUSH
50464: LD_VAR 0 1
50468: PPUSH
50469: EMPTY
50470: PPUSH
50471: CALL_OW 1
50475: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
50476: LD_ADDR_EXP 54
50480: PUSH
50481: LD_EXP 54
50485: PPUSH
50486: LD_VAR 0 1
50490: PPUSH
50491: EMPTY
50492: PPUSH
50493: CALL_OW 1
50497: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
50498: LD_ADDR_EXP 55
50502: PUSH
50503: LD_EXP 55
50507: PPUSH
50508: LD_VAR 0 1
50512: PPUSH
50513: EMPTY
50514: PPUSH
50515: CALL_OW 1
50519: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
50520: LD_ADDR_EXP 56
50524: PUSH
50525: LD_EXP 56
50529: PPUSH
50530: LD_VAR 0 1
50534: PPUSH
50535: EMPTY
50536: PPUSH
50537: CALL_OW 1
50541: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
50542: LD_ADDR_EXP 57
50546: PUSH
50547: LD_EXP 57
50551: PPUSH
50552: LD_VAR 0 1
50556: PPUSH
50557: EMPTY
50558: PPUSH
50559: CALL_OW 1
50563: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
50564: LD_ADDR_EXP 58
50568: PUSH
50569: LD_EXP 58
50573: PPUSH
50574: LD_VAR 0 1
50578: PPUSH
50579: EMPTY
50580: PPUSH
50581: CALL_OW 1
50585: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
50586: LD_ADDR_EXP 59
50590: PUSH
50591: LD_EXP 59
50595: PPUSH
50596: LD_VAR 0 1
50600: PPUSH
50601: EMPTY
50602: PPUSH
50603: CALL_OW 1
50607: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
50608: LD_ADDR_EXP 60
50612: PUSH
50613: LD_EXP 60
50617: PPUSH
50618: LD_VAR 0 1
50622: PPUSH
50623: EMPTY
50624: PPUSH
50625: CALL_OW 1
50629: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
50630: LD_ADDR_EXP 61
50634: PUSH
50635: LD_EXP 61
50639: PPUSH
50640: LD_VAR 0 1
50644: PPUSH
50645: EMPTY
50646: PPUSH
50647: CALL_OW 1
50651: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
50652: LD_ADDR_EXP 62
50656: PUSH
50657: LD_EXP 62
50661: PPUSH
50662: LD_VAR 0 1
50666: PPUSH
50667: EMPTY
50668: PPUSH
50669: CALL_OW 1
50673: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
50674: LD_ADDR_EXP 63
50678: PUSH
50679: LD_EXP 63
50683: PPUSH
50684: LD_VAR 0 1
50688: PPUSH
50689: EMPTY
50690: PPUSH
50691: CALL_OW 1
50695: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
50696: LD_ADDR_EXP 64
50700: PUSH
50701: LD_EXP 64
50705: PPUSH
50706: LD_VAR 0 1
50710: PPUSH
50711: EMPTY
50712: PPUSH
50713: CALL_OW 1
50717: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
50718: LD_ADDR_EXP 65
50722: PUSH
50723: LD_EXP 65
50727: PPUSH
50728: LD_VAR 0 1
50732: PPUSH
50733: LD_INT 0
50735: PPUSH
50736: CALL_OW 1
50740: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
50741: LD_ADDR_EXP 66
50745: PUSH
50746: LD_EXP 66
50750: PPUSH
50751: LD_VAR 0 1
50755: PPUSH
50756: LD_INT 0
50758: PPUSH
50759: CALL_OW 1
50763: ST_TO_ADDR
// end ;
50764: LD_VAR 0 2
50768: RET
// export function MC_Add ( side , units ) ; var base ; begin
50769: LD_INT 0
50771: PPUSH
50772: PPUSH
// base := mc_bases + 1 ;
50773: LD_ADDR_VAR 0 4
50777: PUSH
50778: LD_EXP 23
50782: PUSH
50783: LD_INT 1
50785: PLUS
50786: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
50787: LD_ADDR_EXP 49
50791: PUSH
50792: LD_EXP 49
50796: PPUSH
50797: LD_VAR 0 4
50801: PPUSH
50802: LD_VAR 0 1
50806: PPUSH
50807: CALL_OW 1
50811: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
50812: LD_ADDR_EXP 23
50816: PUSH
50817: LD_EXP 23
50821: PPUSH
50822: LD_VAR 0 4
50826: PPUSH
50827: LD_VAR 0 2
50831: PPUSH
50832: CALL_OW 1
50836: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50837: LD_ADDR_EXP 24
50841: PUSH
50842: LD_EXP 24
50846: PPUSH
50847: LD_VAR 0 4
50851: PPUSH
50852: EMPTY
50853: PPUSH
50854: CALL_OW 1
50858: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50859: LD_ADDR_EXP 25
50863: PUSH
50864: LD_EXP 25
50868: PPUSH
50869: LD_VAR 0 4
50873: PPUSH
50874: EMPTY
50875: PPUSH
50876: CALL_OW 1
50880: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50881: LD_ADDR_EXP 26
50885: PUSH
50886: LD_EXP 26
50890: PPUSH
50891: LD_VAR 0 4
50895: PPUSH
50896: EMPTY
50897: PPUSH
50898: CALL_OW 1
50902: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50903: LD_ADDR_EXP 27
50907: PUSH
50908: LD_EXP 27
50912: PPUSH
50913: LD_VAR 0 4
50917: PPUSH
50918: EMPTY
50919: PPUSH
50920: CALL_OW 1
50924: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50925: LD_ADDR_EXP 28
50929: PUSH
50930: LD_EXP 28
50934: PPUSH
50935: LD_VAR 0 4
50939: PPUSH
50940: EMPTY
50941: PPUSH
50942: CALL_OW 1
50946: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50947: LD_ADDR_EXP 29
50951: PUSH
50952: LD_EXP 29
50956: PPUSH
50957: LD_VAR 0 4
50961: PPUSH
50962: EMPTY
50963: PPUSH
50964: CALL_OW 1
50968: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50969: LD_ADDR_EXP 30
50973: PUSH
50974: LD_EXP 30
50978: PPUSH
50979: LD_VAR 0 4
50983: PPUSH
50984: EMPTY
50985: PPUSH
50986: CALL_OW 1
50990: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50991: LD_ADDR_EXP 31
50995: PUSH
50996: LD_EXP 31
51000: PPUSH
51001: LD_VAR 0 4
51005: PPUSH
51006: EMPTY
51007: PPUSH
51008: CALL_OW 1
51012: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51013: LD_ADDR_EXP 32
51017: PUSH
51018: LD_EXP 32
51022: PPUSH
51023: LD_VAR 0 4
51027: PPUSH
51028: EMPTY
51029: PPUSH
51030: CALL_OW 1
51034: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51035: LD_ADDR_EXP 33
51039: PUSH
51040: LD_EXP 33
51044: PPUSH
51045: LD_VAR 0 4
51049: PPUSH
51050: EMPTY
51051: PPUSH
51052: CALL_OW 1
51056: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51057: LD_ADDR_EXP 34
51061: PUSH
51062: LD_EXP 34
51066: PPUSH
51067: LD_VAR 0 4
51071: PPUSH
51072: LD_INT 0
51074: PPUSH
51075: CALL_OW 1
51079: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51080: LD_ADDR_EXP 35
51084: PUSH
51085: LD_EXP 35
51089: PPUSH
51090: LD_VAR 0 4
51094: PPUSH
51095: EMPTY
51096: PPUSH
51097: CALL_OW 1
51101: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51102: LD_ADDR_EXP 36
51106: PUSH
51107: LD_EXP 36
51111: PPUSH
51112: LD_VAR 0 4
51116: PPUSH
51117: EMPTY
51118: PPUSH
51119: CALL_OW 1
51123: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51124: LD_ADDR_EXP 37
51128: PUSH
51129: LD_EXP 37
51133: PPUSH
51134: LD_VAR 0 4
51138: PPUSH
51139: EMPTY
51140: PPUSH
51141: CALL_OW 1
51145: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51146: LD_ADDR_EXP 38
51150: PUSH
51151: LD_EXP 38
51155: PPUSH
51156: LD_VAR 0 4
51160: PPUSH
51161: EMPTY
51162: PPUSH
51163: CALL_OW 1
51167: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51168: LD_ADDR_EXP 39
51172: PUSH
51173: LD_EXP 39
51177: PPUSH
51178: LD_VAR 0 4
51182: PPUSH
51183: EMPTY
51184: PPUSH
51185: CALL_OW 1
51189: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51190: LD_ADDR_EXP 40
51194: PUSH
51195: LD_EXP 40
51199: PPUSH
51200: LD_VAR 0 4
51204: PPUSH
51205: EMPTY
51206: PPUSH
51207: CALL_OW 1
51211: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51212: LD_ADDR_EXP 41
51216: PUSH
51217: LD_EXP 41
51221: PPUSH
51222: LD_VAR 0 4
51226: PPUSH
51227: EMPTY
51228: PPUSH
51229: CALL_OW 1
51233: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51234: LD_ADDR_EXP 42
51238: PUSH
51239: LD_EXP 42
51243: PPUSH
51244: LD_VAR 0 4
51248: PPUSH
51249: EMPTY
51250: PPUSH
51251: CALL_OW 1
51255: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51256: LD_ADDR_EXP 43
51260: PUSH
51261: LD_EXP 43
51265: PPUSH
51266: LD_VAR 0 4
51270: PPUSH
51271: EMPTY
51272: PPUSH
51273: CALL_OW 1
51277: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51278: LD_ADDR_EXP 44
51282: PUSH
51283: LD_EXP 44
51287: PPUSH
51288: LD_VAR 0 4
51292: PPUSH
51293: EMPTY
51294: PPUSH
51295: CALL_OW 1
51299: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51300: LD_ADDR_EXP 45
51304: PUSH
51305: LD_EXP 45
51309: PPUSH
51310: LD_VAR 0 4
51314: PPUSH
51315: EMPTY
51316: PPUSH
51317: CALL_OW 1
51321: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51322: LD_ADDR_EXP 46
51326: PUSH
51327: LD_EXP 46
51331: PPUSH
51332: LD_VAR 0 4
51336: PPUSH
51337: EMPTY
51338: PPUSH
51339: CALL_OW 1
51343: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51344: LD_ADDR_EXP 47
51348: PUSH
51349: LD_EXP 47
51353: PPUSH
51354: LD_VAR 0 4
51358: PPUSH
51359: EMPTY
51360: PPUSH
51361: CALL_OW 1
51365: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51366: LD_ADDR_EXP 48
51370: PUSH
51371: LD_EXP 48
51375: PPUSH
51376: LD_VAR 0 4
51380: PPUSH
51381: EMPTY
51382: PPUSH
51383: CALL_OW 1
51387: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51388: LD_ADDR_EXP 50
51392: PUSH
51393: LD_EXP 50
51397: PPUSH
51398: LD_VAR 0 4
51402: PPUSH
51403: EMPTY
51404: PPUSH
51405: CALL_OW 1
51409: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51410: LD_ADDR_EXP 52
51414: PUSH
51415: LD_EXP 52
51419: PPUSH
51420: LD_VAR 0 4
51424: PPUSH
51425: EMPTY
51426: PPUSH
51427: CALL_OW 1
51431: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51432: LD_ADDR_EXP 53
51436: PUSH
51437: LD_EXP 53
51441: PPUSH
51442: LD_VAR 0 4
51446: PPUSH
51447: EMPTY
51448: PPUSH
51449: CALL_OW 1
51453: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51454: LD_ADDR_EXP 54
51458: PUSH
51459: LD_EXP 54
51463: PPUSH
51464: LD_VAR 0 4
51468: PPUSH
51469: EMPTY
51470: PPUSH
51471: CALL_OW 1
51475: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51476: LD_ADDR_EXP 55
51480: PUSH
51481: LD_EXP 55
51485: PPUSH
51486: LD_VAR 0 4
51490: PPUSH
51491: EMPTY
51492: PPUSH
51493: CALL_OW 1
51497: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51498: LD_ADDR_EXP 56
51502: PUSH
51503: LD_EXP 56
51507: PPUSH
51508: LD_VAR 0 4
51512: PPUSH
51513: EMPTY
51514: PPUSH
51515: CALL_OW 1
51519: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51520: LD_ADDR_EXP 57
51524: PUSH
51525: LD_EXP 57
51529: PPUSH
51530: LD_VAR 0 4
51534: PPUSH
51535: EMPTY
51536: PPUSH
51537: CALL_OW 1
51541: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51542: LD_ADDR_EXP 58
51546: PUSH
51547: LD_EXP 58
51551: PPUSH
51552: LD_VAR 0 4
51556: PPUSH
51557: EMPTY
51558: PPUSH
51559: CALL_OW 1
51563: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51564: LD_ADDR_EXP 59
51568: PUSH
51569: LD_EXP 59
51573: PPUSH
51574: LD_VAR 0 4
51578: PPUSH
51579: EMPTY
51580: PPUSH
51581: CALL_OW 1
51585: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51586: LD_ADDR_EXP 60
51590: PUSH
51591: LD_EXP 60
51595: PPUSH
51596: LD_VAR 0 4
51600: PPUSH
51601: EMPTY
51602: PPUSH
51603: CALL_OW 1
51607: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51608: LD_ADDR_EXP 61
51612: PUSH
51613: LD_EXP 61
51617: PPUSH
51618: LD_VAR 0 4
51622: PPUSH
51623: EMPTY
51624: PPUSH
51625: CALL_OW 1
51629: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51630: LD_ADDR_EXP 62
51634: PUSH
51635: LD_EXP 62
51639: PPUSH
51640: LD_VAR 0 4
51644: PPUSH
51645: EMPTY
51646: PPUSH
51647: CALL_OW 1
51651: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51652: LD_ADDR_EXP 63
51656: PUSH
51657: LD_EXP 63
51661: PPUSH
51662: LD_VAR 0 4
51666: PPUSH
51667: EMPTY
51668: PPUSH
51669: CALL_OW 1
51673: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51674: LD_ADDR_EXP 64
51678: PUSH
51679: LD_EXP 64
51683: PPUSH
51684: LD_VAR 0 4
51688: PPUSH
51689: EMPTY
51690: PPUSH
51691: CALL_OW 1
51695: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51696: LD_ADDR_EXP 65
51700: PUSH
51701: LD_EXP 65
51705: PPUSH
51706: LD_VAR 0 4
51710: PPUSH
51711: LD_INT 0
51713: PPUSH
51714: CALL_OW 1
51718: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
51719: LD_ADDR_EXP 66
51723: PUSH
51724: LD_EXP 66
51728: PPUSH
51729: LD_VAR 0 4
51733: PPUSH
51734: LD_INT 0
51736: PPUSH
51737: CALL_OW 1
51741: ST_TO_ADDR
// result := base ;
51742: LD_ADDR_VAR 0 3
51746: PUSH
51747: LD_VAR 0 4
51751: ST_TO_ADDR
// end ;
51752: LD_VAR 0 3
51756: RET
// export function MC_Start ( ) ; var i ; begin
51757: LD_INT 0
51759: PPUSH
51760: PPUSH
// for i = 1 to mc_bases do
51761: LD_ADDR_VAR 0 2
51765: PUSH
51766: DOUBLE
51767: LD_INT 1
51769: DEC
51770: ST_TO_ADDR
51771: LD_EXP 23
51775: PUSH
51776: FOR_TO
51777: IFFALSE 52877
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
51779: LD_ADDR_EXP 23
51783: PUSH
51784: LD_EXP 23
51788: PPUSH
51789: LD_VAR 0 2
51793: PPUSH
51794: LD_EXP 23
51798: PUSH
51799: LD_VAR 0 2
51803: ARRAY
51804: PUSH
51805: LD_INT 0
51807: DIFF
51808: PPUSH
51809: CALL_OW 1
51813: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
51814: LD_ADDR_EXP 24
51818: PUSH
51819: LD_EXP 24
51823: PPUSH
51824: LD_VAR 0 2
51828: PPUSH
51829: EMPTY
51830: PPUSH
51831: CALL_OW 1
51835: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
51836: LD_ADDR_EXP 25
51840: PUSH
51841: LD_EXP 25
51845: PPUSH
51846: LD_VAR 0 2
51850: PPUSH
51851: EMPTY
51852: PPUSH
51853: CALL_OW 1
51857: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
51858: LD_ADDR_EXP 26
51862: PUSH
51863: LD_EXP 26
51867: PPUSH
51868: LD_VAR 0 2
51872: PPUSH
51873: EMPTY
51874: PPUSH
51875: CALL_OW 1
51879: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
51880: LD_ADDR_EXP 27
51884: PUSH
51885: LD_EXP 27
51889: PPUSH
51890: LD_VAR 0 2
51894: PPUSH
51895: EMPTY
51896: PUSH
51897: EMPTY
51898: PUSH
51899: EMPTY
51900: LIST
51901: LIST
51902: PPUSH
51903: CALL_OW 1
51907: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
51908: LD_ADDR_EXP 28
51912: PUSH
51913: LD_EXP 28
51917: PPUSH
51918: LD_VAR 0 2
51922: PPUSH
51923: EMPTY
51924: PPUSH
51925: CALL_OW 1
51929: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
51930: LD_ADDR_EXP 55
51934: PUSH
51935: LD_EXP 55
51939: PPUSH
51940: LD_VAR 0 2
51944: PPUSH
51945: EMPTY
51946: PPUSH
51947: CALL_OW 1
51951: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
51952: LD_ADDR_EXP 29
51956: PUSH
51957: LD_EXP 29
51961: PPUSH
51962: LD_VAR 0 2
51966: PPUSH
51967: EMPTY
51968: PPUSH
51969: CALL_OW 1
51973: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
51974: LD_ADDR_EXP 30
51978: PUSH
51979: LD_EXP 30
51983: PPUSH
51984: LD_VAR 0 2
51988: PPUSH
51989: EMPTY
51990: PPUSH
51991: CALL_OW 1
51995: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
51996: LD_ADDR_EXP 31
52000: PUSH
52001: LD_EXP 31
52005: PPUSH
52006: LD_VAR 0 2
52010: PPUSH
52011: LD_EXP 23
52015: PUSH
52016: LD_VAR 0 2
52020: ARRAY
52021: PPUSH
52022: LD_INT 2
52024: PUSH
52025: LD_INT 30
52027: PUSH
52028: LD_INT 32
52030: PUSH
52031: EMPTY
52032: LIST
52033: LIST
52034: PUSH
52035: LD_INT 30
52037: PUSH
52038: LD_INT 33
52040: PUSH
52041: EMPTY
52042: LIST
52043: LIST
52044: PUSH
52045: EMPTY
52046: LIST
52047: LIST
52048: LIST
52049: PPUSH
52050: CALL_OW 72
52054: PPUSH
52055: CALL_OW 1
52059: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52060: LD_ADDR_EXP 32
52064: PUSH
52065: LD_EXP 32
52069: PPUSH
52070: LD_VAR 0 2
52074: PPUSH
52075: LD_EXP 23
52079: PUSH
52080: LD_VAR 0 2
52084: ARRAY
52085: PPUSH
52086: LD_INT 2
52088: PUSH
52089: LD_INT 30
52091: PUSH
52092: LD_INT 32
52094: PUSH
52095: EMPTY
52096: LIST
52097: LIST
52098: PUSH
52099: LD_INT 30
52101: PUSH
52102: LD_INT 31
52104: PUSH
52105: EMPTY
52106: LIST
52107: LIST
52108: PUSH
52109: EMPTY
52110: LIST
52111: LIST
52112: LIST
52113: PUSH
52114: LD_INT 58
52116: PUSH
52117: EMPTY
52118: LIST
52119: PUSH
52120: EMPTY
52121: LIST
52122: LIST
52123: PPUSH
52124: CALL_OW 72
52128: PPUSH
52129: CALL_OW 1
52133: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
52134: LD_ADDR_EXP 33
52138: PUSH
52139: LD_EXP 33
52143: PPUSH
52144: LD_VAR 0 2
52148: PPUSH
52149: EMPTY
52150: PPUSH
52151: CALL_OW 1
52155: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
52156: LD_ADDR_EXP 37
52160: PUSH
52161: LD_EXP 37
52165: PPUSH
52166: LD_VAR 0 2
52170: PPUSH
52171: EMPTY
52172: PPUSH
52173: CALL_OW 1
52177: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
52178: LD_ADDR_EXP 36
52182: PUSH
52183: LD_EXP 36
52187: PPUSH
52188: LD_VAR 0 2
52192: PPUSH
52193: EMPTY
52194: PPUSH
52195: CALL_OW 1
52199: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
52200: LD_ADDR_EXP 38
52204: PUSH
52205: LD_EXP 38
52209: PPUSH
52210: LD_VAR 0 2
52214: PPUSH
52215: EMPTY
52216: PPUSH
52217: CALL_OW 1
52221: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
52222: LD_ADDR_EXP 39
52226: PUSH
52227: LD_EXP 39
52231: PPUSH
52232: LD_VAR 0 2
52236: PPUSH
52237: EMPTY
52238: PPUSH
52239: CALL_OW 1
52243: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
52244: LD_ADDR_EXP 40
52248: PUSH
52249: LD_EXP 40
52253: PPUSH
52254: LD_VAR 0 2
52258: PPUSH
52259: EMPTY
52260: PPUSH
52261: CALL_OW 1
52265: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
52266: LD_ADDR_EXP 41
52270: PUSH
52271: LD_EXP 41
52275: PPUSH
52276: LD_VAR 0 2
52280: PPUSH
52281: EMPTY
52282: PPUSH
52283: CALL_OW 1
52287: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
52288: LD_ADDR_EXP 42
52292: PUSH
52293: LD_EXP 42
52297: PPUSH
52298: LD_VAR 0 2
52302: PPUSH
52303: EMPTY
52304: PPUSH
52305: CALL_OW 1
52309: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
52310: LD_ADDR_EXP 43
52314: PUSH
52315: LD_EXP 43
52319: PPUSH
52320: LD_VAR 0 2
52324: PPUSH
52325: EMPTY
52326: PPUSH
52327: CALL_OW 1
52331: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
52332: LD_ADDR_EXP 44
52336: PUSH
52337: LD_EXP 44
52341: PPUSH
52342: LD_VAR 0 2
52346: PPUSH
52347: EMPTY
52348: PPUSH
52349: CALL_OW 1
52353: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
52354: LD_ADDR_EXP 45
52358: PUSH
52359: LD_EXP 45
52363: PPUSH
52364: LD_VAR 0 2
52368: PPUSH
52369: EMPTY
52370: PPUSH
52371: CALL_OW 1
52375: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
52376: LD_ADDR_EXP 34
52380: PUSH
52381: LD_EXP 34
52385: PPUSH
52386: LD_VAR 0 2
52390: PPUSH
52391: LD_INT 0
52393: PPUSH
52394: CALL_OW 1
52398: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
52399: LD_ADDR_EXP 47
52403: PUSH
52404: LD_EXP 47
52408: PPUSH
52409: LD_VAR 0 2
52413: PPUSH
52414: LD_INT 0
52416: PPUSH
52417: CALL_OW 1
52421: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52422: LD_ADDR_EXP 35
52426: PUSH
52427: LD_EXP 35
52431: PPUSH
52432: LD_VAR 0 2
52436: PPUSH
52437: EMPTY
52438: PPUSH
52439: CALL_OW 1
52443: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
52444: LD_ADDR_EXP 46
52448: PUSH
52449: LD_EXP 46
52453: PPUSH
52454: LD_VAR 0 2
52458: PPUSH
52459: LD_INT 0
52461: PPUSH
52462: CALL_OW 1
52466: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
52467: LD_ADDR_EXP 48
52471: PUSH
52472: LD_EXP 48
52476: PPUSH
52477: LD_VAR 0 2
52481: PPUSH
52482: EMPTY
52483: PPUSH
52484: CALL_OW 1
52488: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
52489: LD_ADDR_EXP 51
52493: PUSH
52494: LD_EXP 51
52498: PPUSH
52499: LD_VAR 0 2
52503: PPUSH
52504: LD_INT 0
52506: PPUSH
52507: CALL_OW 1
52511: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
52512: LD_ADDR_EXP 52
52516: PUSH
52517: LD_EXP 52
52521: PPUSH
52522: LD_VAR 0 2
52526: PPUSH
52527: EMPTY
52528: PPUSH
52529: CALL_OW 1
52533: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
52534: LD_ADDR_EXP 53
52538: PUSH
52539: LD_EXP 53
52543: PPUSH
52544: LD_VAR 0 2
52548: PPUSH
52549: EMPTY
52550: PPUSH
52551: CALL_OW 1
52555: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52556: LD_ADDR_EXP 54
52560: PUSH
52561: LD_EXP 54
52565: PPUSH
52566: LD_VAR 0 2
52570: PPUSH
52571: EMPTY
52572: PPUSH
52573: CALL_OW 1
52577: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
52578: LD_ADDR_EXP 56
52582: PUSH
52583: LD_EXP 56
52587: PPUSH
52588: LD_VAR 0 2
52592: PPUSH
52593: LD_EXP 23
52597: PUSH
52598: LD_VAR 0 2
52602: ARRAY
52603: PPUSH
52604: LD_INT 2
52606: PUSH
52607: LD_INT 30
52609: PUSH
52610: LD_INT 6
52612: PUSH
52613: EMPTY
52614: LIST
52615: LIST
52616: PUSH
52617: LD_INT 30
52619: PUSH
52620: LD_INT 7
52622: PUSH
52623: EMPTY
52624: LIST
52625: LIST
52626: PUSH
52627: LD_INT 30
52629: PUSH
52630: LD_INT 8
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: PUSH
52637: EMPTY
52638: LIST
52639: LIST
52640: LIST
52641: LIST
52642: PPUSH
52643: CALL_OW 72
52647: PPUSH
52648: CALL_OW 1
52652: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
52653: LD_ADDR_EXP 57
52657: PUSH
52658: LD_EXP 57
52662: PPUSH
52663: LD_VAR 0 2
52667: PPUSH
52668: EMPTY
52669: PPUSH
52670: CALL_OW 1
52674: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
52675: LD_ADDR_EXP 58
52679: PUSH
52680: LD_EXP 58
52684: PPUSH
52685: LD_VAR 0 2
52689: PPUSH
52690: EMPTY
52691: PPUSH
52692: CALL_OW 1
52696: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
52697: LD_ADDR_EXP 59
52701: PUSH
52702: LD_EXP 59
52706: PPUSH
52707: LD_VAR 0 2
52711: PPUSH
52712: EMPTY
52713: PPUSH
52714: CALL_OW 1
52718: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
52719: LD_ADDR_EXP 60
52723: PUSH
52724: LD_EXP 60
52728: PPUSH
52729: LD_VAR 0 2
52733: PPUSH
52734: EMPTY
52735: PPUSH
52736: CALL_OW 1
52740: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
52741: LD_ADDR_EXP 61
52745: PUSH
52746: LD_EXP 61
52750: PPUSH
52751: LD_VAR 0 2
52755: PPUSH
52756: EMPTY
52757: PPUSH
52758: CALL_OW 1
52762: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
52763: LD_ADDR_EXP 62
52767: PUSH
52768: LD_EXP 62
52772: PPUSH
52773: LD_VAR 0 2
52777: PPUSH
52778: EMPTY
52779: PPUSH
52780: CALL_OW 1
52784: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
52785: LD_ADDR_EXP 63
52789: PUSH
52790: LD_EXP 63
52794: PPUSH
52795: LD_VAR 0 2
52799: PPUSH
52800: EMPTY
52801: PPUSH
52802: CALL_OW 1
52806: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
52807: LD_ADDR_EXP 64
52811: PUSH
52812: LD_EXP 64
52816: PPUSH
52817: LD_VAR 0 2
52821: PPUSH
52822: EMPTY
52823: PPUSH
52824: CALL_OW 1
52828: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
52829: LD_ADDR_EXP 65
52833: PUSH
52834: LD_EXP 65
52838: PPUSH
52839: LD_VAR 0 2
52843: PPUSH
52844: LD_INT 0
52846: PPUSH
52847: CALL_OW 1
52851: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
52852: LD_ADDR_EXP 66
52856: PUSH
52857: LD_EXP 66
52861: PPUSH
52862: LD_VAR 0 2
52866: PPUSH
52867: LD_INT 0
52869: PPUSH
52870: CALL_OW 1
52874: ST_TO_ADDR
// end ;
52875: GO 51776
52877: POP
52878: POP
// MC_InitSides ( ) ;
52879: CALL 53165 0 0
// MC_InitResearch ( ) ;
52883: CALL 52904 0 0
// CustomInitMacro ( ) ;
52887: CALL 277 0 0
// skirmish := true ;
52891: LD_ADDR_EXP 21
52895: PUSH
52896: LD_INT 1
52898: ST_TO_ADDR
// end ;
52899: LD_VAR 0 1
52903: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
52904: LD_INT 0
52906: PPUSH
52907: PPUSH
52908: PPUSH
52909: PPUSH
52910: PPUSH
52911: PPUSH
// if not mc_bases then
52912: LD_EXP 23
52916: NOT
52917: IFFALSE 52921
// exit ;
52919: GO 53160
// for i = 1 to 8 do
52921: LD_ADDR_VAR 0 2
52925: PUSH
52926: DOUBLE
52927: LD_INT 1
52929: DEC
52930: ST_TO_ADDR
52931: LD_INT 8
52933: PUSH
52934: FOR_TO
52935: IFFALSE 52961
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
52937: LD_ADDR_EXP 50
52941: PUSH
52942: LD_EXP 50
52946: PPUSH
52947: LD_VAR 0 2
52951: PPUSH
52952: EMPTY
52953: PPUSH
52954: CALL_OW 1
52958: ST_TO_ADDR
52959: GO 52934
52961: POP
52962: POP
// tmp := [ ] ;
52963: LD_ADDR_VAR 0 5
52967: PUSH
52968: EMPTY
52969: ST_TO_ADDR
// for i = 1 to mc_sides do
52970: LD_ADDR_VAR 0 2
52974: PUSH
52975: DOUBLE
52976: LD_INT 1
52978: DEC
52979: ST_TO_ADDR
52980: LD_EXP 49
52984: PUSH
52985: FOR_TO
52986: IFFALSE 53044
// if not mc_sides [ i ] in tmp then
52988: LD_EXP 49
52992: PUSH
52993: LD_VAR 0 2
52997: ARRAY
52998: PUSH
52999: LD_VAR 0 5
53003: IN
53004: NOT
53005: IFFALSE 53042
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53007: LD_ADDR_VAR 0 5
53011: PUSH
53012: LD_VAR 0 5
53016: PPUSH
53017: LD_VAR 0 5
53021: PUSH
53022: LD_INT 1
53024: PLUS
53025: PPUSH
53026: LD_EXP 49
53030: PUSH
53031: LD_VAR 0 2
53035: ARRAY
53036: PPUSH
53037: CALL_OW 2
53041: ST_TO_ADDR
53042: GO 52985
53044: POP
53045: POP
// if not tmp then
53046: LD_VAR 0 5
53050: NOT
53051: IFFALSE 53055
// exit ;
53053: GO 53160
// for j in tmp do
53055: LD_ADDR_VAR 0 3
53059: PUSH
53060: LD_VAR 0 5
53064: PUSH
53065: FOR_IN
53066: IFFALSE 53158
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53068: LD_ADDR_VAR 0 6
53072: PUSH
53073: LD_INT 22
53075: PUSH
53076: LD_VAR 0 3
53080: PUSH
53081: EMPTY
53082: LIST
53083: LIST
53084: PPUSH
53085: CALL_OW 69
53089: ST_TO_ADDR
// if not un then
53090: LD_VAR 0 6
53094: NOT
53095: IFFALSE 53099
// continue ;
53097: GO 53065
// nation := GetNation ( un [ 1 ] ) ;
53099: LD_ADDR_VAR 0 4
53103: PUSH
53104: LD_VAR 0 6
53108: PUSH
53109: LD_INT 1
53111: ARRAY
53112: PPUSH
53113: CALL_OW 248
53117: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
53118: LD_ADDR_EXP 50
53122: PUSH
53123: LD_EXP 50
53127: PPUSH
53128: LD_VAR 0 3
53132: PPUSH
53133: LD_VAR 0 3
53137: PPUSH
53138: LD_VAR 0 4
53142: PPUSH
53143: LD_INT 1
53145: PPUSH
53146: CALL 10781 0 3
53150: PPUSH
53151: CALL_OW 1
53155: ST_TO_ADDR
// end ;
53156: GO 53065
53158: POP
53159: POP
// end ;
53160: LD_VAR 0 1
53164: RET
// export function MC_InitSides ( ) ; var i ; begin
53165: LD_INT 0
53167: PPUSH
53168: PPUSH
// if not mc_bases then
53169: LD_EXP 23
53173: NOT
53174: IFFALSE 53178
// exit ;
53176: GO 53252
// for i = 1 to mc_bases do
53178: LD_ADDR_VAR 0 2
53182: PUSH
53183: DOUBLE
53184: LD_INT 1
53186: DEC
53187: ST_TO_ADDR
53188: LD_EXP 23
53192: PUSH
53193: FOR_TO
53194: IFFALSE 53250
// if mc_bases [ i ] then
53196: LD_EXP 23
53200: PUSH
53201: LD_VAR 0 2
53205: ARRAY
53206: IFFALSE 53248
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
53208: LD_ADDR_EXP 49
53212: PUSH
53213: LD_EXP 49
53217: PPUSH
53218: LD_VAR 0 2
53222: PPUSH
53223: LD_EXP 23
53227: PUSH
53228: LD_VAR 0 2
53232: ARRAY
53233: PUSH
53234: LD_INT 1
53236: ARRAY
53237: PPUSH
53238: CALL_OW 255
53242: PPUSH
53243: CALL_OW 1
53247: ST_TO_ADDR
53248: GO 53193
53250: POP
53251: POP
// end ;
53252: LD_VAR 0 1
53256: RET
// every 0 0$03 trigger skirmish do
53257: LD_EXP 21
53261: IFFALSE 53415
53263: GO 53265
53265: DISABLE
// begin enable ;
53266: ENABLE
// MC_CheckBuildings ( ) ;
53267: CALL 57913 0 0
// MC_CheckPeopleLife ( ) ;
53271: CALL 58074 0 0
// RaiseSailEvent ( 100 ) ;
53275: LD_INT 100
53277: PPUSH
53278: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
53282: LD_INT 103
53284: PPUSH
53285: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
53289: LD_INT 104
53291: PPUSH
53292: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
53296: LD_INT 105
53298: PPUSH
53299: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
53303: LD_INT 106
53305: PPUSH
53306: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
53310: LD_INT 107
53312: PPUSH
53313: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
53317: LD_INT 108
53319: PPUSH
53320: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
53324: LD_INT 109
53326: PPUSH
53327: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
53331: LD_INT 110
53333: PPUSH
53334: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
53338: LD_INT 111
53340: PPUSH
53341: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
53345: LD_INT 112
53347: PPUSH
53348: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
53352: LD_INT 113
53354: PPUSH
53355: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
53359: LD_INT 120
53361: PPUSH
53362: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
53366: LD_INT 121
53368: PPUSH
53369: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
53373: LD_INT 122
53375: PPUSH
53376: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
53380: LD_INT 123
53382: PPUSH
53383: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
53387: LD_INT 124
53389: PPUSH
53390: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
53394: LD_INT 125
53396: PPUSH
53397: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
53401: LD_INT 126
53403: PPUSH
53404: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
53408: LD_INT 200
53410: PPUSH
53411: CALL_OW 427
// end ;
53415: END
// on SailEvent ( event ) do begin if event < 100 then
53416: LD_VAR 0 1
53420: PUSH
53421: LD_INT 100
53423: LESS
53424: IFFALSE 53435
// CustomEvent ( event ) ;
53426: LD_VAR 0 1
53430: PPUSH
53431: CALL 9955 0 1
// if event = 100 then
53435: LD_VAR 0 1
53439: PUSH
53440: LD_INT 100
53442: EQUAL
53443: IFFALSE 53449
// MC_ClassManager ( ) ;
53445: CALL 53841 0 0
// if event = 101 then
53449: LD_VAR 0 1
53453: PUSH
53454: LD_INT 101
53456: EQUAL
53457: IFFALSE 53463
// MC_RepairBuildings ( ) ;
53459: CALL 58659 0 0
// if event = 102 then
53463: LD_VAR 0 1
53467: PUSH
53468: LD_INT 102
53470: EQUAL
53471: IFFALSE 53477
// MC_Heal ( ) ;
53473: CALL 59566 0 0
// if event = 103 then
53477: LD_VAR 0 1
53481: PUSH
53482: LD_INT 103
53484: EQUAL
53485: IFFALSE 53491
// MC_Build ( ) ;
53487: CALL 59988 0 0
// if event = 104 then
53491: LD_VAR 0 1
53495: PUSH
53496: LD_INT 104
53498: EQUAL
53499: IFFALSE 53505
// MC_TurretWeapon ( ) ;
53501: CALL 61629 0 0
// if event = 105 then
53505: LD_VAR 0 1
53509: PUSH
53510: LD_INT 105
53512: EQUAL
53513: IFFALSE 53519
// MC_BuildUpgrade ( ) ;
53515: CALL 61180 0 0
// if event = 106 then
53519: LD_VAR 0 1
53523: PUSH
53524: LD_INT 106
53526: EQUAL
53527: IFFALSE 53533
// MC_PlantMines ( ) ;
53529: CALL 62059 0 0
// if event = 107 then
53533: LD_VAR 0 1
53537: PUSH
53538: LD_INT 107
53540: EQUAL
53541: IFFALSE 53547
// MC_CollectCrates ( ) ;
53543: CALL 62850 0 0
// if event = 108 then
53547: LD_VAR 0 1
53551: PUSH
53552: LD_INT 108
53554: EQUAL
53555: IFFALSE 53561
// MC_LinkRemoteControl ( ) ;
53557: CALL 64700 0 0
// if event = 109 then
53561: LD_VAR 0 1
53565: PUSH
53566: LD_INT 109
53568: EQUAL
53569: IFFALSE 53575
// MC_ProduceVehicle ( ) ;
53571: CALL 64881 0 0
// if event = 110 then
53575: LD_VAR 0 1
53579: PUSH
53580: LD_INT 110
53582: EQUAL
53583: IFFALSE 53589
// MC_SendAttack ( ) ;
53585: CALL 65347 0 0
// if event = 111 then
53589: LD_VAR 0 1
53593: PUSH
53594: LD_INT 111
53596: EQUAL
53597: IFFALSE 53603
// MC_Defend ( ) ;
53599: CALL 65455 0 0
// if event = 112 then
53603: LD_VAR 0 1
53607: PUSH
53608: LD_INT 112
53610: EQUAL
53611: IFFALSE 53617
// MC_Research ( ) ;
53613: CALL 66188 0 0
// if event = 113 then
53617: LD_VAR 0 1
53621: PUSH
53622: LD_INT 113
53624: EQUAL
53625: IFFALSE 53631
// MC_MinesTrigger ( ) ;
53627: CALL 67302 0 0
// if event = 120 then
53631: LD_VAR 0 1
53635: PUSH
53636: LD_INT 120
53638: EQUAL
53639: IFFALSE 53645
// MC_RepairVehicle ( ) ;
53641: CALL 67401 0 0
// if event = 121 then
53645: LD_VAR 0 1
53649: PUSH
53650: LD_INT 121
53652: EQUAL
53653: IFFALSE 53659
// MC_TameApe ( ) ;
53655: CALL 68142 0 0
// if event = 122 then
53659: LD_VAR 0 1
53663: PUSH
53664: LD_INT 122
53666: EQUAL
53667: IFFALSE 53673
// MC_ChangeApeClass ( ) ;
53669: CALL 68971 0 0
// if event = 123 then
53673: LD_VAR 0 1
53677: PUSH
53678: LD_INT 123
53680: EQUAL
53681: IFFALSE 53687
// MC_Bazooka ( ) ;
53683: CALL 69621 0 0
// if event = 124 then
53687: LD_VAR 0 1
53691: PUSH
53692: LD_INT 124
53694: EQUAL
53695: IFFALSE 53701
// MC_TeleportExit ( ) ;
53697: CALL 69819 0 0
// if event = 125 then
53701: LD_VAR 0 1
53705: PUSH
53706: LD_INT 125
53708: EQUAL
53709: IFFALSE 53715
// MC_Deposits ( ) ;
53711: CALL 70466 0 0
// if event = 126 then
53715: LD_VAR 0 1
53719: PUSH
53720: LD_INT 126
53722: EQUAL
53723: IFFALSE 53729
// MC_RemoteDriver ( ) ;
53725: CALL 71091 0 0
// if event = 200 then
53729: LD_VAR 0 1
53733: PUSH
53734: LD_INT 200
53736: EQUAL
53737: IFFALSE 53743
// MC_Idle ( ) ;
53739: CALL 73040 0 0
// end ;
53743: PPOPN 1
53745: END
// export function MC_Reset ( base , tag ) ; var i ; begin
53746: LD_INT 0
53748: PPUSH
53749: PPUSH
// if not mc_bases [ base ] or not tag then
53750: LD_EXP 23
53754: PUSH
53755: LD_VAR 0 1
53759: ARRAY
53760: NOT
53761: PUSH
53762: LD_VAR 0 2
53766: NOT
53767: OR
53768: IFFALSE 53772
// exit ;
53770: GO 53836
// for i in mc_bases [ base ] union mc_ape [ base ] do
53772: LD_ADDR_VAR 0 4
53776: PUSH
53777: LD_EXP 23
53781: PUSH
53782: LD_VAR 0 1
53786: ARRAY
53787: PUSH
53788: LD_EXP 52
53792: PUSH
53793: LD_VAR 0 1
53797: ARRAY
53798: UNION
53799: PUSH
53800: FOR_IN
53801: IFFALSE 53834
// if GetTag ( i ) = tag then
53803: LD_VAR 0 4
53807: PPUSH
53808: CALL_OW 110
53812: PUSH
53813: LD_VAR 0 2
53817: EQUAL
53818: IFFALSE 53832
// SetTag ( i , 0 ) ;
53820: LD_VAR 0 4
53824: PPUSH
53825: LD_INT 0
53827: PPUSH
53828: CALL_OW 109
53832: GO 53800
53834: POP
53835: POP
// end ;
53836: LD_VAR 0 3
53840: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
53841: LD_INT 0
53843: PPUSH
53844: PPUSH
53845: PPUSH
53846: PPUSH
53847: PPUSH
53848: PPUSH
53849: PPUSH
53850: PPUSH
// if not mc_bases then
53851: LD_EXP 23
53855: NOT
53856: IFFALSE 53860
// exit ;
53858: GO 54318
// for i = 1 to mc_bases do
53860: LD_ADDR_VAR 0 2
53864: PUSH
53865: DOUBLE
53866: LD_INT 1
53868: DEC
53869: ST_TO_ADDR
53870: LD_EXP 23
53874: PUSH
53875: FOR_TO
53876: IFFALSE 54316
// begin tmp := MC_ClassCheckReq ( i ) ;
53878: LD_ADDR_VAR 0 4
53882: PUSH
53883: LD_VAR 0 2
53887: PPUSH
53888: CALL 54323 0 1
53892: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
53893: LD_ADDR_EXP 64
53897: PUSH
53898: LD_EXP 64
53902: PPUSH
53903: LD_VAR 0 2
53907: PPUSH
53908: LD_VAR 0 4
53912: PPUSH
53913: CALL_OW 1
53917: ST_TO_ADDR
// if not tmp then
53918: LD_VAR 0 4
53922: NOT
53923: IFFALSE 53927
// continue ;
53925: GO 53875
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
53927: LD_ADDR_VAR 0 6
53931: PUSH
53932: LD_EXP 23
53936: PUSH
53937: LD_VAR 0 2
53941: ARRAY
53942: PPUSH
53943: LD_INT 2
53945: PUSH
53946: LD_INT 30
53948: PUSH
53949: LD_INT 4
53951: PUSH
53952: EMPTY
53953: LIST
53954: LIST
53955: PUSH
53956: LD_INT 30
53958: PUSH
53959: LD_INT 5
53961: PUSH
53962: EMPTY
53963: LIST
53964: LIST
53965: PUSH
53966: EMPTY
53967: LIST
53968: LIST
53969: LIST
53970: PPUSH
53971: CALL_OW 72
53975: PUSH
53976: LD_EXP 23
53980: PUSH
53981: LD_VAR 0 2
53985: ARRAY
53986: PPUSH
53987: LD_INT 2
53989: PUSH
53990: LD_INT 30
53992: PUSH
53993: LD_INT 0
53995: PUSH
53996: EMPTY
53997: LIST
53998: LIST
53999: PUSH
54000: LD_INT 30
54002: PUSH
54003: LD_INT 1
54005: PUSH
54006: EMPTY
54007: LIST
54008: LIST
54009: PUSH
54010: EMPTY
54011: LIST
54012: LIST
54013: LIST
54014: PPUSH
54015: CALL_OW 72
54019: PUSH
54020: LD_EXP 23
54024: PUSH
54025: LD_VAR 0 2
54029: ARRAY
54030: PPUSH
54031: LD_INT 30
54033: PUSH
54034: LD_INT 3
54036: PUSH
54037: EMPTY
54038: LIST
54039: LIST
54040: PPUSH
54041: CALL_OW 72
54045: PUSH
54046: LD_EXP 23
54050: PUSH
54051: LD_VAR 0 2
54055: ARRAY
54056: PPUSH
54057: LD_INT 2
54059: PUSH
54060: LD_INT 30
54062: PUSH
54063: LD_INT 6
54065: PUSH
54066: EMPTY
54067: LIST
54068: LIST
54069: PUSH
54070: LD_INT 30
54072: PUSH
54073: LD_INT 7
54075: PUSH
54076: EMPTY
54077: LIST
54078: LIST
54079: PUSH
54080: LD_INT 30
54082: PUSH
54083: LD_INT 8
54085: PUSH
54086: EMPTY
54087: LIST
54088: LIST
54089: PUSH
54090: EMPTY
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: PPUSH
54096: CALL_OW 72
54100: PUSH
54101: EMPTY
54102: LIST
54103: LIST
54104: LIST
54105: LIST
54106: ST_TO_ADDR
// for j = 1 to 4 do
54107: LD_ADDR_VAR 0 3
54111: PUSH
54112: DOUBLE
54113: LD_INT 1
54115: DEC
54116: ST_TO_ADDR
54117: LD_INT 4
54119: PUSH
54120: FOR_TO
54121: IFFALSE 54312
// begin if not tmp [ j ] then
54123: LD_VAR 0 4
54127: PUSH
54128: LD_VAR 0 3
54132: ARRAY
54133: NOT
54134: IFFALSE 54138
// continue ;
54136: GO 54120
// for p in tmp [ j ] do
54138: LD_ADDR_VAR 0 5
54142: PUSH
54143: LD_VAR 0 4
54147: PUSH
54148: LD_VAR 0 3
54152: ARRAY
54153: PUSH
54154: FOR_IN
54155: IFFALSE 54308
// begin if not b [ j ] then
54157: LD_VAR 0 6
54161: PUSH
54162: LD_VAR 0 3
54166: ARRAY
54167: NOT
54168: IFFALSE 54172
// break ;
54170: GO 54308
// e := 0 ;
54172: LD_ADDR_VAR 0 7
54176: PUSH
54177: LD_INT 0
54179: ST_TO_ADDR
// for k in b [ j ] do
54180: LD_ADDR_VAR 0 8
54184: PUSH
54185: LD_VAR 0 6
54189: PUSH
54190: LD_VAR 0 3
54194: ARRAY
54195: PUSH
54196: FOR_IN
54197: IFFALSE 54224
// if IsNotFull ( k ) then
54199: LD_VAR 0 8
54203: PPUSH
54204: CALL 12934 0 1
54208: IFFALSE 54222
// begin e := k ;
54210: LD_ADDR_VAR 0 7
54214: PUSH
54215: LD_VAR 0 8
54219: ST_TO_ADDR
// break ;
54220: GO 54224
// end ;
54222: GO 54196
54224: POP
54225: POP
// if e and not UnitGoingToBuilding ( p , e ) then
54226: LD_VAR 0 7
54230: PUSH
54231: LD_VAR 0 5
54235: PPUSH
54236: LD_VAR 0 7
54240: PPUSH
54241: CALL 46098 0 2
54245: NOT
54246: AND
54247: IFFALSE 54306
// begin if IsInUnit ( p ) then
54249: LD_VAR 0 5
54253: PPUSH
54254: CALL_OW 310
54258: IFFALSE 54269
// ComExitBuilding ( p ) ;
54260: LD_VAR 0 5
54264: PPUSH
54265: CALL_OW 122
// ComEnterUnit ( p , e ) ;
54269: LD_VAR 0 5
54273: PPUSH
54274: LD_VAR 0 7
54278: PPUSH
54279: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
54283: LD_VAR 0 5
54287: PPUSH
54288: LD_VAR 0 3
54292: PPUSH
54293: CALL_OW 183
// AddComExitBuilding ( p ) ;
54297: LD_VAR 0 5
54301: PPUSH
54302: CALL_OW 182
// end ; end ;
54306: GO 54154
54308: POP
54309: POP
// end ;
54310: GO 54120
54312: POP
54313: POP
// end ;
54314: GO 53875
54316: POP
54317: POP
// end ;
54318: LD_VAR 0 1
54322: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
54323: LD_INT 0
54325: PPUSH
54326: PPUSH
54327: PPUSH
54328: PPUSH
54329: PPUSH
54330: PPUSH
54331: PPUSH
54332: PPUSH
54333: PPUSH
54334: PPUSH
54335: PPUSH
54336: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54337: LD_VAR 0 1
54341: NOT
54342: PUSH
54343: LD_EXP 23
54347: PUSH
54348: LD_VAR 0 1
54352: ARRAY
54353: NOT
54354: OR
54355: PUSH
54356: LD_EXP 23
54360: PUSH
54361: LD_VAR 0 1
54365: ARRAY
54366: PPUSH
54367: LD_INT 2
54369: PUSH
54370: LD_INT 30
54372: PUSH
54373: LD_INT 0
54375: PUSH
54376: EMPTY
54377: LIST
54378: LIST
54379: PUSH
54380: LD_INT 30
54382: PUSH
54383: LD_INT 1
54385: PUSH
54386: EMPTY
54387: LIST
54388: LIST
54389: PUSH
54390: EMPTY
54391: LIST
54392: LIST
54393: LIST
54394: PPUSH
54395: CALL_OW 72
54399: NOT
54400: OR
54401: IFFALSE 54405
// exit ;
54403: GO 57908
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54405: LD_ADDR_VAR 0 4
54409: PUSH
54410: LD_EXP 23
54414: PUSH
54415: LD_VAR 0 1
54419: ARRAY
54420: PPUSH
54421: LD_INT 2
54423: PUSH
54424: LD_INT 25
54426: PUSH
54427: LD_INT 1
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: PUSH
54434: LD_INT 25
54436: PUSH
54437: LD_INT 2
54439: PUSH
54440: EMPTY
54441: LIST
54442: LIST
54443: PUSH
54444: LD_INT 25
54446: PUSH
54447: LD_INT 3
54449: PUSH
54450: EMPTY
54451: LIST
54452: LIST
54453: PUSH
54454: LD_INT 25
54456: PUSH
54457: LD_INT 4
54459: PUSH
54460: EMPTY
54461: LIST
54462: LIST
54463: PUSH
54464: LD_INT 25
54466: PUSH
54467: LD_INT 5
54469: PUSH
54470: EMPTY
54471: LIST
54472: LIST
54473: PUSH
54474: LD_INT 25
54476: PUSH
54477: LD_INT 8
54479: PUSH
54480: EMPTY
54481: LIST
54482: LIST
54483: PUSH
54484: LD_INT 25
54486: PUSH
54487: LD_INT 9
54489: PUSH
54490: EMPTY
54491: LIST
54492: LIST
54493: PUSH
54494: EMPTY
54495: LIST
54496: LIST
54497: LIST
54498: LIST
54499: LIST
54500: LIST
54501: LIST
54502: LIST
54503: PPUSH
54504: CALL_OW 72
54508: ST_TO_ADDR
// if not tmp then
54509: LD_VAR 0 4
54513: NOT
54514: IFFALSE 54518
// exit ;
54516: GO 57908
// for i in tmp do
54518: LD_ADDR_VAR 0 3
54522: PUSH
54523: LD_VAR 0 4
54527: PUSH
54528: FOR_IN
54529: IFFALSE 54560
// if GetTag ( i ) then
54531: LD_VAR 0 3
54535: PPUSH
54536: CALL_OW 110
54540: IFFALSE 54558
// tmp := tmp diff i ;
54542: LD_ADDR_VAR 0 4
54546: PUSH
54547: LD_VAR 0 4
54551: PUSH
54552: LD_VAR 0 3
54556: DIFF
54557: ST_TO_ADDR
54558: GO 54528
54560: POP
54561: POP
// if not tmp then
54562: LD_VAR 0 4
54566: NOT
54567: IFFALSE 54571
// exit ;
54569: GO 57908
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54571: LD_ADDR_VAR 0 5
54575: PUSH
54576: LD_EXP 23
54580: PUSH
54581: LD_VAR 0 1
54585: ARRAY
54586: PPUSH
54587: LD_INT 2
54589: PUSH
54590: LD_INT 25
54592: PUSH
54593: LD_INT 1
54595: PUSH
54596: EMPTY
54597: LIST
54598: LIST
54599: PUSH
54600: LD_INT 25
54602: PUSH
54603: LD_INT 5
54605: PUSH
54606: EMPTY
54607: LIST
54608: LIST
54609: PUSH
54610: LD_INT 25
54612: PUSH
54613: LD_INT 8
54615: PUSH
54616: EMPTY
54617: LIST
54618: LIST
54619: PUSH
54620: LD_INT 25
54622: PUSH
54623: LD_INT 9
54625: PUSH
54626: EMPTY
54627: LIST
54628: LIST
54629: PUSH
54630: EMPTY
54631: LIST
54632: LIST
54633: LIST
54634: LIST
54635: LIST
54636: PPUSH
54637: CALL_OW 72
54641: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
54642: LD_ADDR_VAR 0 6
54646: PUSH
54647: LD_EXP 23
54651: PUSH
54652: LD_VAR 0 1
54656: ARRAY
54657: PPUSH
54658: LD_INT 25
54660: PUSH
54661: LD_INT 2
54663: PUSH
54664: EMPTY
54665: LIST
54666: LIST
54667: PPUSH
54668: CALL_OW 72
54672: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
54673: LD_ADDR_VAR 0 7
54677: PUSH
54678: LD_EXP 23
54682: PUSH
54683: LD_VAR 0 1
54687: ARRAY
54688: PPUSH
54689: LD_INT 25
54691: PUSH
54692: LD_INT 3
54694: PUSH
54695: EMPTY
54696: LIST
54697: LIST
54698: PPUSH
54699: CALL_OW 72
54703: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
54704: LD_ADDR_VAR 0 8
54708: PUSH
54709: LD_EXP 23
54713: PUSH
54714: LD_VAR 0 1
54718: ARRAY
54719: PPUSH
54720: LD_INT 25
54722: PUSH
54723: LD_INT 4
54725: PUSH
54726: EMPTY
54727: LIST
54728: LIST
54729: PUSH
54730: LD_INT 24
54732: PUSH
54733: LD_INT 251
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: PPUSH
54744: CALL_OW 72
54748: ST_TO_ADDR
// if mc_is_defending [ base ] then
54749: LD_EXP 66
54753: PUSH
54754: LD_VAR 0 1
54758: ARRAY
54759: IFFALSE 55220
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
54761: LD_ADDR_EXP 65
54765: PUSH
54766: LD_EXP 65
54770: PPUSH
54771: LD_VAR 0 1
54775: PPUSH
54776: LD_INT 4
54778: PPUSH
54779: CALL_OW 1
54783: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54784: LD_ADDR_VAR 0 12
54788: PUSH
54789: LD_EXP 23
54793: PUSH
54794: LD_VAR 0 1
54798: ARRAY
54799: PPUSH
54800: LD_INT 2
54802: PUSH
54803: LD_INT 30
54805: PUSH
54806: LD_INT 4
54808: PUSH
54809: EMPTY
54810: LIST
54811: LIST
54812: PUSH
54813: LD_INT 30
54815: PUSH
54816: LD_INT 5
54818: PUSH
54819: EMPTY
54820: LIST
54821: LIST
54822: PUSH
54823: EMPTY
54824: LIST
54825: LIST
54826: LIST
54827: PPUSH
54828: CALL_OW 72
54832: ST_TO_ADDR
// if not b then
54833: LD_VAR 0 12
54837: NOT
54838: IFFALSE 54842
// exit ;
54840: GO 57908
// p := [ ] ;
54842: LD_ADDR_VAR 0 11
54846: PUSH
54847: EMPTY
54848: ST_TO_ADDR
// if sci >= 2 then
54849: LD_VAR 0 8
54853: PUSH
54854: LD_INT 2
54856: GREATEREQUAL
54857: IFFALSE 54888
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
54859: LD_ADDR_VAR 0 8
54863: PUSH
54864: LD_VAR 0 8
54868: PUSH
54869: LD_INT 1
54871: ARRAY
54872: PUSH
54873: LD_VAR 0 8
54877: PUSH
54878: LD_INT 2
54880: ARRAY
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: ST_TO_ADDR
54886: GO 54949
// if sci = 1 then
54888: LD_VAR 0 8
54892: PUSH
54893: LD_INT 1
54895: EQUAL
54896: IFFALSE 54917
// sci := [ sci [ 1 ] ] else
54898: LD_ADDR_VAR 0 8
54902: PUSH
54903: LD_VAR 0 8
54907: PUSH
54908: LD_INT 1
54910: ARRAY
54911: PUSH
54912: EMPTY
54913: LIST
54914: ST_TO_ADDR
54915: GO 54949
// if sci = 0 then
54917: LD_VAR 0 8
54921: PUSH
54922: LD_INT 0
54924: EQUAL
54925: IFFALSE 54949
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
54927: LD_ADDR_VAR 0 11
54931: PUSH
54932: LD_VAR 0 4
54936: PPUSH
54937: LD_INT 4
54939: PPUSH
54940: CALL 45961 0 2
54944: PUSH
54945: LD_INT 1
54947: ARRAY
54948: ST_TO_ADDR
// if eng > 4 then
54949: LD_VAR 0 6
54953: PUSH
54954: LD_INT 4
54956: GREATER
54957: IFFALSE 55003
// for i = eng downto 4 do
54959: LD_ADDR_VAR 0 3
54963: PUSH
54964: DOUBLE
54965: LD_VAR 0 6
54969: INC
54970: ST_TO_ADDR
54971: LD_INT 4
54973: PUSH
54974: FOR_DOWNTO
54975: IFFALSE 55001
// eng := eng diff eng [ i ] ;
54977: LD_ADDR_VAR 0 6
54981: PUSH
54982: LD_VAR 0 6
54986: PUSH
54987: LD_VAR 0 6
54991: PUSH
54992: LD_VAR 0 3
54996: ARRAY
54997: DIFF
54998: ST_TO_ADDR
54999: GO 54974
55001: POP
55002: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55003: LD_ADDR_VAR 0 4
55007: PUSH
55008: LD_VAR 0 4
55012: PUSH
55013: LD_VAR 0 5
55017: PUSH
55018: LD_VAR 0 6
55022: UNION
55023: PUSH
55024: LD_VAR 0 7
55028: UNION
55029: PUSH
55030: LD_VAR 0 8
55034: UNION
55035: DIFF
55036: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55037: LD_ADDR_VAR 0 13
55041: PUSH
55042: LD_EXP 23
55046: PUSH
55047: LD_VAR 0 1
55051: ARRAY
55052: PPUSH
55053: LD_INT 2
55055: PUSH
55056: LD_INT 30
55058: PUSH
55059: LD_INT 32
55061: PUSH
55062: EMPTY
55063: LIST
55064: LIST
55065: PUSH
55066: LD_INT 30
55068: PUSH
55069: LD_INT 31
55071: PUSH
55072: EMPTY
55073: LIST
55074: LIST
55075: PUSH
55076: EMPTY
55077: LIST
55078: LIST
55079: LIST
55080: PPUSH
55081: CALL_OW 72
55085: PUSH
55086: LD_EXP 23
55090: PUSH
55091: LD_VAR 0 1
55095: ARRAY
55096: PPUSH
55097: LD_INT 2
55099: PUSH
55100: LD_INT 30
55102: PUSH
55103: LD_INT 4
55105: PUSH
55106: EMPTY
55107: LIST
55108: LIST
55109: PUSH
55110: LD_INT 30
55112: PUSH
55113: LD_INT 5
55115: PUSH
55116: EMPTY
55117: LIST
55118: LIST
55119: PUSH
55120: EMPTY
55121: LIST
55122: LIST
55123: LIST
55124: PPUSH
55125: CALL_OW 72
55129: PUSH
55130: LD_INT 6
55132: MUL
55133: PLUS
55134: ST_TO_ADDR
// if bcount < tmp then
55135: LD_VAR 0 13
55139: PUSH
55140: LD_VAR 0 4
55144: LESS
55145: IFFALSE 55191
// for i = tmp downto bcount do
55147: LD_ADDR_VAR 0 3
55151: PUSH
55152: DOUBLE
55153: LD_VAR 0 4
55157: INC
55158: ST_TO_ADDR
55159: LD_VAR 0 13
55163: PUSH
55164: FOR_DOWNTO
55165: IFFALSE 55189
// tmp := Delete ( tmp , tmp ) ;
55167: LD_ADDR_VAR 0 4
55171: PUSH
55172: LD_VAR 0 4
55176: PPUSH
55177: LD_VAR 0 4
55181: PPUSH
55182: CALL_OW 3
55186: ST_TO_ADDR
55187: GO 55164
55189: POP
55190: POP
// result := [ tmp , 0 , 0 , p ] ;
55191: LD_ADDR_VAR 0 2
55195: PUSH
55196: LD_VAR 0 4
55200: PUSH
55201: LD_INT 0
55203: PUSH
55204: LD_INT 0
55206: PUSH
55207: LD_VAR 0 11
55211: PUSH
55212: EMPTY
55213: LIST
55214: LIST
55215: LIST
55216: LIST
55217: ST_TO_ADDR
// exit ;
55218: GO 57908
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55220: LD_EXP 23
55224: PUSH
55225: LD_VAR 0 1
55229: ARRAY
55230: PPUSH
55231: LD_INT 2
55233: PUSH
55234: LD_INT 30
55236: PUSH
55237: LD_INT 6
55239: PUSH
55240: EMPTY
55241: LIST
55242: LIST
55243: PUSH
55244: LD_INT 30
55246: PUSH
55247: LD_INT 7
55249: PUSH
55250: EMPTY
55251: LIST
55252: LIST
55253: PUSH
55254: LD_INT 30
55256: PUSH
55257: LD_INT 8
55259: PUSH
55260: EMPTY
55261: LIST
55262: LIST
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: LIST
55268: LIST
55269: PPUSH
55270: CALL_OW 72
55274: NOT
55275: PUSH
55276: LD_EXP 23
55280: PUSH
55281: LD_VAR 0 1
55285: ARRAY
55286: PPUSH
55287: LD_INT 30
55289: PUSH
55290: LD_INT 3
55292: PUSH
55293: EMPTY
55294: LIST
55295: LIST
55296: PPUSH
55297: CALL_OW 72
55301: NOT
55302: AND
55303: IFFALSE 55375
// begin if eng = tmp then
55305: LD_VAR 0 6
55309: PUSH
55310: LD_VAR 0 4
55314: EQUAL
55315: IFFALSE 55319
// exit ;
55317: GO 57908
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
55319: LD_ADDR_EXP 65
55323: PUSH
55324: LD_EXP 65
55328: PPUSH
55329: LD_VAR 0 1
55333: PPUSH
55334: LD_INT 1
55336: PPUSH
55337: CALL_OW 1
55341: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
55342: LD_ADDR_VAR 0 2
55346: PUSH
55347: LD_INT 0
55349: PUSH
55350: LD_VAR 0 4
55354: PUSH
55355: LD_VAR 0 6
55359: DIFF
55360: PUSH
55361: LD_INT 0
55363: PUSH
55364: LD_INT 0
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: LIST
55371: LIST
55372: ST_TO_ADDR
// exit ;
55373: GO 57908
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55375: LD_EXP 50
55379: PUSH
55380: LD_EXP 49
55384: PUSH
55385: LD_VAR 0 1
55389: ARRAY
55390: ARRAY
55391: PUSH
55392: LD_EXP 23
55396: PUSH
55397: LD_VAR 0 1
55401: ARRAY
55402: PPUSH
55403: LD_INT 2
55405: PUSH
55406: LD_INT 30
55408: PUSH
55409: LD_INT 6
55411: PUSH
55412: EMPTY
55413: LIST
55414: LIST
55415: PUSH
55416: LD_INT 30
55418: PUSH
55419: LD_INT 7
55421: PUSH
55422: EMPTY
55423: LIST
55424: LIST
55425: PUSH
55426: LD_INT 30
55428: PUSH
55429: LD_INT 8
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: LIST
55440: LIST
55441: PPUSH
55442: CALL_OW 72
55446: AND
55447: PUSH
55448: LD_EXP 23
55452: PUSH
55453: LD_VAR 0 1
55457: ARRAY
55458: PPUSH
55459: LD_INT 30
55461: PUSH
55462: LD_INT 3
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PPUSH
55469: CALL_OW 72
55473: NOT
55474: AND
55475: IFFALSE 55689
// begin if sci >= 6 then
55477: LD_VAR 0 8
55481: PUSH
55482: LD_INT 6
55484: GREATEREQUAL
55485: IFFALSE 55489
// exit ;
55487: GO 57908
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
55489: LD_ADDR_EXP 65
55493: PUSH
55494: LD_EXP 65
55498: PPUSH
55499: LD_VAR 0 1
55503: PPUSH
55504: LD_INT 2
55506: PPUSH
55507: CALL_OW 1
55511: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
55512: LD_ADDR_VAR 0 9
55516: PUSH
55517: LD_VAR 0 4
55521: PUSH
55522: LD_VAR 0 8
55526: DIFF
55527: PPUSH
55528: LD_INT 4
55530: PPUSH
55531: CALL 45961 0 2
55535: ST_TO_ADDR
// p := [ ] ;
55536: LD_ADDR_VAR 0 11
55540: PUSH
55541: EMPTY
55542: ST_TO_ADDR
// if sci < 6 and sort > 6 then
55543: LD_VAR 0 8
55547: PUSH
55548: LD_INT 6
55550: LESS
55551: PUSH
55552: LD_VAR 0 9
55556: PUSH
55557: LD_INT 6
55559: GREATER
55560: AND
55561: IFFALSE 55642
// begin for i = 1 to 6 - sci do
55563: LD_ADDR_VAR 0 3
55567: PUSH
55568: DOUBLE
55569: LD_INT 1
55571: DEC
55572: ST_TO_ADDR
55573: LD_INT 6
55575: PUSH
55576: LD_VAR 0 8
55580: MINUS
55581: PUSH
55582: FOR_TO
55583: IFFALSE 55638
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
55585: LD_ADDR_VAR 0 11
55589: PUSH
55590: LD_VAR 0 11
55594: PPUSH
55595: LD_VAR 0 11
55599: PUSH
55600: LD_INT 1
55602: PLUS
55603: PPUSH
55604: LD_VAR 0 9
55608: PUSH
55609: LD_INT 1
55611: ARRAY
55612: PPUSH
55613: CALL_OW 2
55617: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
55618: LD_ADDR_VAR 0 9
55622: PUSH
55623: LD_VAR 0 9
55627: PPUSH
55628: LD_INT 1
55630: PPUSH
55631: CALL_OW 3
55635: ST_TO_ADDR
// end ;
55636: GO 55582
55638: POP
55639: POP
// end else
55640: GO 55662
// if sort then
55642: LD_VAR 0 9
55646: IFFALSE 55662
// p := sort [ 1 ] ;
55648: LD_ADDR_VAR 0 11
55652: PUSH
55653: LD_VAR 0 9
55657: PUSH
55658: LD_INT 1
55660: ARRAY
55661: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
55662: LD_ADDR_VAR 0 2
55666: PUSH
55667: LD_INT 0
55669: PUSH
55670: LD_INT 0
55672: PUSH
55673: LD_INT 0
55675: PUSH
55676: LD_VAR 0 11
55680: PUSH
55681: EMPTY
55682: LIST
55683: LIST
55684: LIST
55685: LIST
55686: ST_TO_ADDR
// exit ;
55687: GO 57908
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
55689: LD_EXP 50
55693: PUSH
55694: LD_EXP 49
55698: PUSH
55699: LD_VAR 0 1
55703: ARRAY
55704: ARRAY
55705: PUSH
55706: LD_EXP 23
55710: PUSH
55711: LD_VAR 0 1
55715: ARRAY
55716: PPUSH
55717: LD_INT 2
55719: PUSH
55720: LD_INT 30
55722: PUSH
55723: LD_INT 6
55725: PUSH
55726: EMPTY
55727: LIST
55728: LIST
55729: PUSH
55730: LD_INT 30
55732: PUSH
55733: LD_INT 7
55735: PUSH
55736: EMPTY
55737: LIST
55738: LIST
55739: PUSH
55740: LD_INT 30
55742: PUSH
55743: LD_INT 8
55745: PUSH
55746: EMPTY
55747: LIST
55748: LIST
55749: PUSH
55750: EMPTY
55751: LIST
55752: LIST
55753: LIST
55754: LIST
55755: PPUSH
55756: CALL_OW 72
55760: AND
55761: PUSH
55762: LD_EXP 23
55766: PUSH
55767: LD_VAR 0 1
55771: ARRAY
55772: PPUSH
55773: LD_INT 30
55775: PUSH
55776: LD_INT 3
55778: PUSH
55779: EMPTY
55780: LIST
55781: LIST
55782: PPUSH
55783: CALL_OW 72
55787: AND
55788: IFFALSE 56522
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
55790: LD_ADDR_EXP 65
55794: PUSH
55795: LD_EXP 65
55799: PPUSH
55800: LD_VAR 0 1
55804: PPUSH
55805: LD_INT 3
55807: PPUSH
55808: CALL_OW 1
55812: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
55813: LD_ADDR_VAR 0 2
55817: PUSH
55818: LD_INT 0
55820: PUSH
55821: LD_INT 0
55823: PUSH
55824: LD_INT 0
55826: PUSH
55827: LD_INT 0
55829: PUSH
55830: EMPTY
55831: LIST
55832: LIST
55833: LIST
55834: LIST
55835: ST_TO_ADDR
// if not eng then
55836: LD_VAR 0 6
55840: NOT
55841: IFFALSE 55904
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
55843: LD_ADDR_VAR 0 11
55847: PUSH
55848: LD_VAR 0 4
55852: PPUSH
55853: LD_INT 2
55855: PPUSH
55856: CALL 45961 0 2
55860: PUSH
55861: LD_INT 1
55863: ARRAY
55864: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
55865: LD_ADDR_VAR 0 2
55869: PUSH
55870: LD_VAR 0 2
55874: PPUSH
55875: LD_INT 2
55877: PPUSH
55878: LD_VAR 0 11
55882: PPUSH
55883: CALL_OW 1
55887: ST_TO_ADDR
// tmp := tmp diff p ;
55888: LD_ADDR_VAR 0 4
55892: PUSH
55893: LD_VAR 0 4
55897: PUSH
55898: LD_VAR 0 11
55902: DIFF
55903: ST_TO_ADDR
// end ; if tmp and sci < 6 then
55904: LD_VAR 0 4
55908: PUSH
55909: LD_VAR 0 8
55913: PUSH
55914: LD_INT 6
55916: LESS
55917: AND
55918: IFFALSE 56106
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
55920: LD_ADDR_VAR 0 9
55924: PUSH
55925: LD_VAR 0 4
55929: PUSH
55930: LD_VAR 0 8
55934: PUSH
55935: LD_VAR 0 7
55939: UNION
55940: DIFF
55941: PPUSH
55942: LD_INT 4
55944: PPUSH
55945: CALL 45961 0 2
55949: ST_TO_ADDR
// p := [ ] ;
55950: LD_ADDR_VAR 0 11
55954: PUSH
55955: EMPTY
55956: ST_TO_ADDR
// if sort then
55957: LD_VAR 0 9
55961: IFFALSE 56077
// for i = 1 to 6 - sci do
55963: LD_ADDR_VAR 0 3
55967: PUSH
55968: DOUBLE
55969: LD_INT 1
55971: DEC
55972: ST_TO_ADDR
55973: LD_INT 6
55975: PUSH
55976: LD_VAR 0 8
55980: MINUS
55981: PUSH
55982: FOR_TO
55983: IFFALSE 56075
// begin if i = sort then
55985: LD_VAR 0 3
55989: PUSH
55990: LD_VAR 0 9
55994: EQUAL
55995: IFFALSE 55999
// break ;
55997: GO 56075
// if GetClass ( i ) = 4 then
55999: LD_VAR 0 3
56003: PPUSH
56004: CALL_OW 257
56008: PUSH
56009: LD_INT 4
56011: EQUAL
56012: IFFALSE 56016
// continue ;
56014: GO 55982
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56016: LD_ADDR_VAR 0 11
56020: PUSH
56021: LD_VAR 0 11
56025: PPUSH
56026: LD_VAR 0 11
56030: PUSH
56031: LD_INT 1
56033: PLUS
56034: PPUSH
56035: LD_VAR 0 9
56039: PUSH
56040: LD_VAR 0 3
56044: ARRAY
56045: PPUSH
56046: CALL_OW 2
56050: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56051: LD_ADDR_VAR 0 4
56055: PUSH
56056: LD_VAR 0 4
56060: PUSH
56061: LD_VAR 0 9
56065: PUSH
56066: LD_VAR 0 3
56070: ARRAY
56071: DIFF
56072: ST_TO_ADDR
// end ;
56073: GO 55982
56075: POP
56076: POP
// if p then
56077: LD_VAR 0 11
56081: IFFALSE 56106
// result := Replace ( result , 4 , p ) ;
56083: LD_ADDR_VAR 0 2
56087: PUSH
56088: LD_VAR 0 2
56092: PPUSH
56093: LD_INT 4
56095: PPUSH
56096: LD_VAR 0 11
56100: PPUSH
56101: CALL_OW 1
56105: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56106: LD_VAR 0 4
56110: PUSH
56111: LD_VAR 0 7
56115: PUSH
56116: LD_INT 6
56118: LESS
56119: AND
56120: IFFALSE 56308
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56122: LD_ADDR_VAR 0 9
56126: PUSH
56127: LD_VAR 0 4
56131: PUSH
56132: LD_VAR 0 8
56136: PUSH
56137: LD_VAR 0 7
56141: UNION
56142: DIFF
56143: PPUSH
56144: LD_INT 3
56146: PPUSH
56147: CALL 45961 0 2
56151: ST_TO_ADDR
// p := [ ] ;
56152: LD_ADDR_VAR 0 11
56156: PUSH
56157: EMPTY
56158: ST_TO_ADDR
// if sort then
56159: LD_VAR 0 9
56163: IFFALSE 56279
// for i = 1 to 6 - mech do
56165: LD_ADDR_VAR 0 3
56169: PUSH
56170: DOUBLE
56171: LD_INT 1
56173: DEC
56174: ST_TO_ADDR
56175: LD_INT 6
56177: PUSH
56178: LD_VAR 0 7
56182: MINUS
56183: PUSH
56184: FOR_TO
56185: IFFALSE 56277
// begin if i = sort then
56187: LD_VAR 0 3
56191: PUSH
56192: LD_VAR 0 9
56196: EQUAL
56197: IFFALSE 56201
// break ;
56199: GO 56277
// if GetClass ( i ) = 3 then
56201: LD_VAR 0 3
56205: PPUSH
56206: CALL_OW 257
56210: PUSH
56211: LD_INT 3
56213: EQUAL
56214: IFFALSE 56218
// continue ;
56216: GO 56184
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56218: LD_ADDR_VAR 0 11
56222: PUSH
56223: LD_VAR 0 11
56227: PPUSH
56228: LD_VAR 0 11
56232: PUSH
56233: LD_INT 1
56235: PLUS
56236: PPUSH
56237: LD_VAR 0 9
56241: PUSH
56242: LD_VAR 0 3
56246: ARRAY
56247: PPUSH
56248: CALL_OW 2
56252: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56253: LD_ADDR_VAR 0 4
56257: PUSH
56258: LD_VAR 0 4
56262: PUSH
56263: LD_VAR 0 9
56267: PUSH
56268: LD_VAR 0 3
56272: ARRAY
56273: DIFF
56274: ST_TO_ADDR
// end ;
56275: GO 56184
56277: POP
56278: POP
// if p then
56279: LD_VAR 0 11
56283: IFFALSE 56308
// result := Replace ( result , 3 , p ) ;
56285: LD_ADDR_VAR 0 2
56289: PUSH
56290: LD_VAR 0 2
56294: PPUSH
56295: LD_INT 3
56297: PPUSH
56298: LD_VAR 0 11
56302: PPUSH
56303: CALL_OW 1
56307: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
56308: LD_VAR 0 4
56312: PUSH
56313: LD_INT 6
56315: GREATER
56316: PUSH
56317: LD_VAR 0 6
56321: PUSH
56322: LD_INT 6
56324: LESS
56325: AND
56326: IFFALSE 56520
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56328: LD_ADDR_VAR 0 9
56332: PUSH
56333: LD_VAR 0 4
56337: PUSH
56338: LD_VAR 0 8
56342: PUSH
56343: LD_VAR 0 7
56347: UNION
56348: PUSH
56349: LD_VAR 0 6
56353: UNION
56354: DIFF
56355: PPUSH
56356: LD_INT 2
56358: PPUSH
56359: CALL 45961 0 2
56363: ST_TO_ADDR
// p := [ ] ;
56364: LD_ADDR_VAR 0 11
56368: PUSH
56369: EMPTY
56370: ST_TO_ADDR
// if sort then
56371: LD_VAR 0 9
56375: IFFALSE 56491
// for i = 1 to 6 - eng do
56377: LD_ADDR_VAR 0 3
56381: PUSH
56382: DOUBLE
56383: LD_INT 1
56385: DEC
56386: ST_TO_ADDR
56387: LD_INT 6
56389: PUSH
56390: LD_VAR 0 6
56394: MINUS
56395: PUSH
56396: FOR_TO
56397: IFFALSE 56489
// begin if i = sort then
56399: LD_VAR 0 3
56403: PUSH
56404: LD_VAR 0 9
56408: EQUAL
56409: IFFALSE 56413
// break ;
56411: GO 56489
// if GetClass ( i ) = 2 then
56413: LD_VAR 0 3
56417: PPUSH
56418: CALL_OW 257
56422: PUSH
56423: LD_INT 2
56425: EQUAL
56426: IFFALSE 56430
// continue ;
56428: GO 56396
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56430: LD_ADDR_VAR 0 11
56434: PUSH
56435: LD_VAR 0 11
56439: PPUSH
56440: LD_VAR 0 11
56444: PUSH
56445: LD_INT 1
56447: PLUS
56448: PPUSH
56449: LD_VAR 0 9
56453: PUSH
56454: LD_VAR 0 3
56458: ARRAY
56459: PPUSH
56460: CALL_OW 2
56464: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56465: LD_ADDR_VAR 0 4
56469: PUSH
56470: LD_VAR 0 4
56474: PUSH
56475: LD_VAR 0 9
56479: PUSH
56480: LD_VAR 0 3
56484: ARRAY
56485: DIFF
56486: ST_TO_ADDR
// end ;
56487: GO 56396
56489: POP
56490: POP
// if p then
56491: LD_VAR 0 11
56495: IFFALSE 56520
// result := Replace ( result , 2 , p ) ;
56497: LD_ADDR_VAR 0 2
56501: PUSH
56502: LD_VAR 0 2
56506: PPUSH
56507: LD_INT 2
56509: PPUSH
56510: LD_VAR 0 11
56514: PPUSH
56515: CALL_OW 1
56519: ST_TO_ADDR
// end ; exit ;
56520: GO 57908
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
56522: LD_EXP 50
56526: PUSH
56527: LD_EXP 49
56531: PUSH
56532: LD_VAR 0 1
56536: ARRAY
56537: ARRAY
56538: NOT
56539: PUSH
56540: LD_EXP 23
56544: PUSH
56545: LD_VAR 0 1
56549: ARRAY
56550: PPUSH
56551: LD_INT 30
56553: PUSH
56554: LD_INT 3
56556: PUSH
56557: EMPTY
56558: LIST
56559: LIST
56560: PPUSH
56561: CALL_OW 72
56565: AND
56566: PUSH
56567: LD_EXP 28
56571: PUSH
56572: LD_VAR 0 1
56576: ARRAY
56577: AND
56578: IFFALSE 57186
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
56580: LD_ADDR_EXP 65
56584: PUSH
56585: LD_EXP 65
56589: PPUSH
56590: LD_VAR 0 1
56594: PPUSH
56595: LD_INT 5
56597: PPUSH
56598: CALL_OW 1
56602: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56603: LD_ADDR_VAR 0 2
56607: PUSH
56608: LD_INT 0
56610: PUSH
56611: LD_INT 0
56613: PUSH
56614: LD_INT 0
56616: PUSH
56617: LD_INT 0
56619: PUSH
56620: EMPTY
56621: LIST
56622: LIST
56623: LIST
56624: LIST
56625: ST_TO_ADDR
// if sci > 1 then
56626: LD_VAR 0 8
56630: PUSH
56631: LD_INT 1
56633: GREATER
56634: IFFALSE 56662
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
56636: LD_ADDR_VAR 0 4
56640: PUSH
56641: LD_VAR 0 4
56645: PUSH
56646: LD_VAR 0 8
56650: PUSH
56651: LD_VAR 0 8
56655: PUSH
56656: LD_INT 1
56658: ARRAY
56659: DIFF
56660: DIFF
56661: ST_TO_ADDR
// if tmp and not sci then
56662: LD_VAR 0 4
56666: PUSH
56667: LD_VAR 0 8
56671: NOT
56672: AND
56673: IFFALSE 56742
// begin sort := SortBySkill ( tmp , 4 ) ;
56675: LD_ADDR_VAR 0 9
56679: PUSH
56680: LD_VAR 0 4
56684: PPUSH
56685: LD_INT 4
56687: PPUSH
56688: CALL 45961 0 2
56692: ST_TO_ADDR
// if sort then
56693: LD_VAR 0 9
56697: IFFALSE 56713
// p := sort [ 1 ] ;
56699: LD_ADDR_VAR 0 11
56703: PUSH
56704: LD_VAR 0 9
56708: PUSH
56709: LD_INT 1
56711: ARRAY
56712: ST_TO_ADDR
// if p then
56713: LD_VAR 0 11
56717: IFFALSE 56742
// result := Replace ( result , 4 , p ) ;
56719: LD_ADDR_VAR 0 2
56723: PUSH
56724: LD_VAR 0 2
56728: PPUSH
56729: LD_INT 4
56731: PPUSH
56732: LD_VAR 0 11
56736: PPUSH
56737: CALL_OW 1
56741: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
56742: LD_ADDR_VAR 0 4
56746: PUSH
56747: LD_VAR 0 4
56751: PUSH
56752: LD_VAR 0 7
56756: DIFF
56757: ST_TO_ADDR
// if tmp and mech < 6 then
56758: LD_VAR 0 4
56762: PUSH
56763: LD_VAR 0 7
56767: PUSH
56768: LD_INT 6
56770: LESS
56771: AND
56772: IFFALSE 56960
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56774: LD_ADDR_VAR 0 9
56778: PUSH
56779: LD_VAR 0 4
56783: PUSH
56784: LD_VAR 0 8
56788: PUSH
56789: LD_VAR 0 7
56793: UNION
56794: DIFF
56795: PPUSH
56796: LD_INT 3
56798: PPUSH
56799: CALL 45961 0 2
56803: ST_TO_ADDR
// p := [ ] ;
56804: LD_ADDR_VAR 0 11
56808: PUSH
56809: EMPTY
56810: ST_TO_ADDR
// if sort then
56811: LD_VAR 0 9
56815: IFFALSE 56931
// for i = 1 to 6 - mech do
56817: LD_ADDR_VAR 0 3
56821: PUSH
56822: DOUBLE
56823: LD_INT 1
56825: DEC
56826: ST_TO_ADDR
56827: LD_INT 6
56829: PUSH
56830: LD_VAR 0 7
56834: MINUS
56835: PUSH
56836: FOR_TO
56837: IFFALSE 56929
// begin if i = sort then
56839: LD_VAR 0 3
56843: PUSH
56844: LD_VAR 0 9
56848: EQUAL
56849: IFFALSE 56853
// break ;
56851: GO 56929
// if GetClass ( i ) = 3 then
56853: LD_VAR 0 3
56857: PPUSH
56858: CALL_OW 257
56862: PUSH
56863: LD_INT 3
56865: EQUAL
56866: IFFALSE 56870
// continue ;
56868: GO 56836
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56870: LD_ADDR_VAR 0 11
56874: PUSH
56875: LD_VAR 0 11
56879: PPUSH
56880: LD_VAR 0 11
56884: PUSH
56885: LD_INT 1
56887: PLUS
56888: PPUSH
56889: LD_VAR 0 9
56893: PUSH
56894: LD_VAR 0 3
56898: ARRAY
56899: PPUSH
56900: CALL_OW 2
56904: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56905: LD_ADDR_VAR 0 4
56909: PUSH
56910: LD_VAR 0 4
56914: PUSH
56915: LD_VAR 0 9
56919: PUSH
56920: LD_VAR 0 3
56924: ARRAY
56925: DIFF
56926: ST_TO_ADDR
// end ;
56927: GO 56836
56929: POP
56930: POP
// if p then
56931: LD_VAR 0 11
56935: IFFALSE 56960
// result := Replace ( result , 3 , p ) ;
56937: LD_ADDR_VAR 0 2
56941: PUSH
56942: LD_VAR 0 2
56946: PPUSH
56947: LD_INT 3
56949: PPUSH
56950: LD_VAR 0 11
56954: PPUSH
56955: CALL_OW 1
56959: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
56960: LD_ADDR_VAR 0 4
56964: PUSH
56965: LD_VAR 0 4
56969: PUSH
56970: LD_VAR 0 6
56974: DIFF
56975: ST_TO_ADDR
// if tmp and eng < 6 then
56976: LD_VAR 0 4
56980: PUSH
56981: LD_VAR 0 6
56985: PUSH
56986: LD_INT 6
56988: LESS
56989: AND
56990: IFFALSE 57184
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
56992: LD_ADDR_VAR 0 9
56996: PUSH
56997: LD_VAR 0 4
57001: PUSH
57002: LD_VAR 0 8
57006: PUSH
57007: LD_VAR 0 7
57011: UNION
57012: PUSH
57013: LD_VAR 0 6
57017: UNION
57018: DIFF
57019: PPUSH
57020: LD_INT 2
57022: PPUSH
57023: CALL 45961 0 2
57027: ST_TO_ADDR
// p := [ ] ;
57028: LD_ADDR_VAR 0 11
57032: PUSH
57033: EMPTY
57034: ST_TO_ADDR
// if sort then
57035: LD_VAR 0 9
57039: IFFALSE 57155
// for i = 1 to 6 - eng do
57041: LD_ADDR_VAR 0 3
57045: PUSH
57046: DOUBLE
57047: LD_INT 1
57049: DEC
57050: ST_TO_ADDR
57051: LD_INT 6
57053: PUSH
57054: LD_VAR 0 6
57058: MINUS
57059: PUSH
57060: FOR_TO
57061: IFFALSE 57153
// begin if i = sort then
57063: LD_VAR 0 3
57067: PUSH
57068: LD_VAR 0 9
57072: EQUAL
57073: IFFALSE 57077
// break ;
57075: GO 57153
// if GetClass ( i ) = 2 then
57077: LD_VAR 0 3
57081: PPUSH
57082: CALL_OW 257
57086: PUSH
57087: LD_INT 2
57089: EQUAL
57090: IFFALSE 57094
// continue ;
57092: GO 57060
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57094: LD_ADDR_VAR 0 11
57098: PUSH
57099: LD_VAR 0 11
57103: PPUSH
57104: LD_VAR 0 11
57108: PUSH
57109: LD_INT 1
57111: PLUS
57112: PPUSH
57113: LD_VAR 0 9
57117: PUSH
57118: LD_VAR 0 3
57122: ARRAY
57123: PPUSH
57124: CALL_OW 2
57128: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57129: LD_ADDR_VAR 0 4
57133: PUSH
57134: LD_VAR 0 4
57138: PUSH
57139: LD_VAR 0 9
57143: PUSH
57144: LD_VAR 0 3
57148: ARRAY
57149: DIFF
57150: ST_TO_ADDR
// end ;
57151: GO 57060
57153: POP
57154: POP
// if p then
57155: LD_VAR 0 11
57159: IFFALSE 57184
// result := Replace ( result , 2 , p ) ;
57161: LD_ADDR_VAR 0 2
57165: PUSH
57166: LD_VAR 0 2
57170: PPUSH
57171: LD_INT 2
57173: PPUSH
57174: LD_VAR 0 11
57178: PPUSH
57179: CALL_OW 1
57183: ST_TO_ADDR
// end ; exit ;
57184: GO 57908
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
57186: LD_EXP 50
57190: PUSH
57191: LD_EXP 49
57195: PUSH
57196: LD_VAR 0 1
57200: ARRAY
57201: ARRAY
57202: NOT
57203: PUSH
57204: LD_EXP 23
57208: PUSH
57209: LD_VAR 0 1
57213: ARRAY
57214: PPUSH
57215: LD_INT 30
57217: PUSH
57218: LD_INT 3
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PPUSH
57225: CALL_OW 72
57229: AND
57230: PUSH
57231: LD_EXP 28
57235: PUSH
57236: LD_VAR 0 1
57240: ARRAY
57241: NOT
57242: AND
57243: IFFALSE 57908
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
57245: LD_ADDR_EXP 65
57249: PUSH
57250: LD_EXP 65
57254: PPUSH
57255: LD_VAR 0 1
57259: PPUSH
57260: LD_INT 6
57262: PPUSH
57263: CALL_OW 1
57267: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57268: LD_ADDR_VAR 0 2
57272: PUSH
57273: LD_INT 0
57275: PUSH
57276: LD_INT 0
57278: PUSH
57279: LD_INT 0
57281: PUSH
57282: LD_INT 0
57284: PUSH
57285: EMPTY
57286: LIST
57287: LIST
57288: LIST
57289: LIST
57290: ST_TO_ADDR
// if sci >= 1 then
57291: LD_VAR 0 8
57295: PUSH
57296: LD_INT 1
57298: GREATEREQUAL
57299: IFFALSE 57321
// tmp := tmp diff sci [ 1 ] ;
57301: LD_ADDR_VAR 0 4
57305: PUSH
57306: LD_VAR 0 4
57310: PUSH
57311: LD_VAR 0 8
57315: PUSH
57316: LD_INT 1
57318: ARRAY
57319: DIFF
57320: ST_TO_ADDR
// if tmp and not sci then
57321: LD_VAR 0 4
57325: PUSH
57326: LD_VAR 0 8
57330: NOT
57331: AND
57332: IFFALSE 57401
// begin sort := SortBySkill ( tmp , 4 ) ;
57334: LD_ADDR_VAR 0 9
57338: PUSH
57339: LD_VAR 0 4
57343: PPUSH
57344: LD_INT 4
57346: PPUSH
57347: CALL 45961 0 2
57351: ST_TO_ADDR
// if sort then
57352: LD_VAR 0 9
57356: IFFALSE 57372
// p := sort [ 1 ] ;
57358: LD_ADDR_VAR 0 11
57362: PUSH
57363: LD_VAR 0 9
57367: PUSH
57368: LD_INT 1
57370: ARRAY
57371: ST_TO_ADDR
// if p then
57372: LD_VAR 0 11
57376: IFFALSE 57401
// result := Replace ( result , 4 , p ) ;
57378: LD_ADDR_VAR 0 2
57382: PUSH
57383: LD_VAR 0 2
57387: PPUSH
57388: LD_INT 4
57390: PPUSH
57391: LD_VAR 0 11
57395: PPUSH
57396: CALL_OW 1
57400: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57401: LD_ADDR_VAR 0 4
57405: PUSH
57406: LD_VAR 0 4
57410: PUSH
57411: LD_VAR 0 7
57415: DIFF
57416: ST_TO_ADDR
// if tmp and mech < 6 then
57417: LD_VAR 0 4
57421: PUSH
57422: LD_VAR 0 7
57426: PUSH
57427: LD_INT 6
57429: LESS
57430: AND
57431: IFFALSE 57613
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
57433: LD_ADDR_VAR 0 9
57437: PUSH
57438: LD_VAR 0 4
57442: PUSH
57443: LD_VAR 0 7
57447: DIFF
57448: PPUSH
57449: LD_INT 3
57451: PPUSH
57452: CALL 45961 0 2
57456: ST_TO_ADDR
// p := [ ] ;
57457: LD_ADDR_VAR 0 11
57461: PUSH
57462: EMPTY
57463: ST_TO_ADDR
// if sort then
57464: LD_VAR 0 9
57468: IFFALSE 57584
// for i = 1 to 6 - mech do
57470: LD_ADDR_VAR 0 3
57474: PUSH
57475: DOUBLE
57476: LD_INT 1
57478: DEC
57479: ST_TO_ADDR
57480: LD_INT 6
57482: PUSH
57483: LD_VAR 0 7
57487: MINUS
57488: PUSH
57489: FOR_TO
57490: IFFALSE 57582
// begin if i = sort then
57492: LD_VAR 0 3
57496: PUSH
57497: LD_VAR 0 9
57501: EQUAL
57502: IFFALSE 57506
// break ;
57504: GO 57582
// if GetClass ( i ) = 3 then
57506: LD_VAR 0 3
57510: PPUSH
57511: CALL_OW 257
57515: PUSH
57516: LD_INT 3
57518: EQUAL
57519: IFFALSE 57523
// continue ;
57521: GO 57489
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57523: LD_ADDR_VAR 0 11
57527: PUSH
57528: LD_VAR 0 11
57532: PPUSH
57533: LD_VAR 0 11
57537: PUSH
57538: LD_INT 1
57540: PLUS
57541: PPUSH
57542: LD_VAR 0 9
57546: PUSH
57547: LD_VAR 0 3
57551: ARRAY
57552: PPUSH
57553: CALL_OW 2
57557: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57558: LD_ADDR_VAR 0 4
57562: PUSH
57563: LD_VAR 0 4
57567: PUSH
57568: LD_VAR 0 9
57572: PUSH
57573: LD_VAR 0 3
57577: ARRAY
57578: DIFF
57579: ST_TO_ADDR
// end ;
57580: GO 57489
57582: POP
57583: POP
// if p then
57584: LD_VAR 0 11
57588: IFFALSE 57613
// result := Replace ( result , 3 , p ) ;
57590: LD_ADDR_VAR 0 2
57594: PUSH
57595: LD_VAR 0 2
57599: PPUSH
57600: LD_INT 3
57602: PPUSH
57603: LD_VAR 0 11
57607: PPUSH
57608: CALL_OW 1
57612: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57613: LD_ADDR_VAR 0 4
57617: PUSH
57618: LD_VAR 0 4
57622: PUSH
57623: LD_VAR 0 6
57627: DIFF
57628: ST_TO_ADDR
// if tmp and eng < 4 then
57629: LD_VAR 0 4
57633: PUSH
57634: LD_VAR 0 6
57638: PUSH
57639: LD_INT 4
57641: LESS
57642: AND
57643: IFFALSE 57833
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
57645: LD_ADDR_VAR 0 9
57649: PUSH
57650: LD_VAR 0 4
57654: PUSH
57655: LD_VAR 0 7
57659: PUSH
57660: LD_VAR 0 6
57664: UNION
57665: DIFF
57666: PPUSH
57667: LD_INT 2
57669: PPUSH
57670: CALL 45961 0 2
57674: ST_TO_ADDR
// p := [ ] ;
57675: LD_ADDR_VAR 0 11
57679: PUSH
57680: EMPTY
57681: ST_TO_ADDR
// if sort then
57682: LD_VAR 0 9
57686: IFFALSE 57802
// for i = 1 to 4 - eng do
57688: LD_ADDR_VAR 0 3
57692: PUSH
57693: DOUBLE
57694: LD_INT 1
57696: DEC
57697: ST_TO_ADDR
57698: LD_INT 4
57700: PUSH
57701: LD_VAR 0 6
57705: MINUS
57706: PUSH
57707: FOR_TO
57708: IFFALSE 57800
// begin if i = sort then
57710: LD_VAR 0 3
57714: PUSH
57715: LD_VAR 0 9
57719: EQUAL
57720: IFFALSE 57724
// break ;
57722: GO 57800
// if GetClass ( i ) = 2 then
57724: LD_VAR 0 3
57728: PPUSH
57729: CALL_OW 257
57733: PUSH
57734: LD_INT 2
57736: EQUAL
57737: IFFALSE 57741
// continue ;
57739: GO 57707
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57741: LD_ADDR_VAR 0 11
57745: PUSH
57746: LD_VAR 0 11
57750: PPUSH
57751: LD_VAR 0 11
57755: PUSH
57756: LD_INT 1
57758: PLUS
57759: PPUSH
57760: LD_VAR 0 9
57764: PUSH
57765: LD_VAR 0 3
57769: ARRAY
57770: PPUSH
57771: CALL_OW 2
57775: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57776: LD_ADDR_VAR 0 4
57780: PUSH
57781: LD_VAR 0 4
57785: PUSH
57786: LD_VAR 0 9
57790: PUSH
57791: LD_VAR 0 3
57795: ARRAY
57796: DIFF
57797: ST_TO_ADDR
// end ;
57798: GO 57707
57800: POP
57801: POP
// if p then
57802: LD_VAR 0 11
57806: IFFALSE 57831
// result := Replace ( result , 2 , p ) ;
57808: LD_ADDR_VAR 0 2
57812: PUSH
57813: LD_VAR 0 2
57817: PPUSH
57818: LD_INT 2
57820: PPUSH
57821: LD_VAR 0 11
57825: PPUSH
57826: CALL_OW 1
57830: ST_TO_ADDR
// end else
57831: GO 57877
// for i = eng downto 5 do
57833: LD_ADDR_VAR 0 3
57837: PUSH
57838: DOUBLE
57839: LD_VAR 0 6
57843: INC
57844: ST_TO_ADDR
57845: LD_INT 5
57847: PUSH
57848: FOR_DOWNTO
57849: IFFALSE 57875
// tmp := tmp union eng [ i ] ;
57851: LD_ADDR_VAR 0 4
57855: PUSH
57856: LD_VAR 0 4
57860: PUSH
57861: LD_VAR 0 6
57865: PUSH
57866: LD_VAR 0 3
57870: ARRAY
57871: UNION
57872: ST_TO_ADDR
57873: GO 57848
57875: POP
57876: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
57877: LD_ADDR_VAR 0 2
57881: PUSH
57882: LD_VAR 0 2
57886: PPUSH
57887: LD_INT 1
57889: PPUSH
57890: LD_VAR 0 4
57894: PUSH
57895: LD_VAR 0 5
57899: DIFF
57900: PPUSH
57901: CALL_OW 1
57905: ST_TO_ADDR
// exit ;
57906: GO 57908
// end ; end ;
57908: LD_VAR 0 2
57912: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
57913: LD_INT 0
57915: PPUSH
57916: PPUSH
57917: PPUSH
// if not mc_bases then
57918: LD_EXP 23
57922: NOT
57923: IFFALSE 57927
// exit ;
57925: GO 58069
// for i = 1 to mc_bases do
57927: LD_ADDR_VAR 0 2
57931: PUSH
57932: DOUBLE
57933: LD_INT 1
57935: DEC
57936: ST_TO_ADDR
57937: LD_EXP 23
57941: PUSH
57942: FOR_TO
57943: IFFALSE 58060
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
57945: LD_ADDR_VAR 0 3
57949: PUSH
57950: LD_EXP 23
57954: PUSH
57955: LD_VAR 0 2
57959: ARRAY
57960: PPUSH
57961: LD_INT 21
57963: PUSH
57964: LD_INT 3
57966: PUSH
57967: EMPTY
57968: LIST
57969: LIST
57970: PUSH
57971: LD_INT 3
57973: PUSH
57974: LD_INT 2
57976: PUSH
57977: LD_INT 30
57979: PUSH
57980: LD_INT 29
57982: PUSH
57983: EMPTY
57984: LIST
57985: LIST
57986: PUSH
57987: LD_INT 30
57989: PUSH
57990: LD_INT 30
57992: PUSH
57993: EMPTY
57994: LIST
57995: LIST
57996: PUSH
57997: EMPTY
57998: LIST
57999: LIST
58000: LIST
58001: PUSH
58002: EMPTY
58003: LIST
58004: LIST
58005: PUSH
58006: LD_INT 3
58008: PUSH
58009: LD_INT 24
58011: PUSH
58012: LD_INT 1000
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: PUSH
58019: EMPTY
58020: LIST
58021: LIST
58022: PUSH
58023: EMPTY
58024: LIST
58025: LIST
58026: LIST
58027: PPUSH
58028: CALL_OW 72
58032: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58033: LD_ADDR_EXP 24
58037: PUSH
58038: LD_EXP 24
58042: PPUSH
58043: LD_VAR 0 2
58047: PPUSH
58048: LD_VAR 0 3
58052: PPUSH
58053: CALL_OW 1
58057: ST_TO_ADDR
// end ;
58058: GO 57942
58060: POP
58061: POP
// RaiseSailEvent ( 101 ) ;
58062: LD_INT 101
58064: PPUSH
58065: CALL_OW 427
// end ;
58069: LD_VAR 0 1
58073: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58074: LD_INT 0
58076: PPUSH
58077: PPUSH
58078: PPUSH
58079: PPUSH
58080: PPUSH
58081: PPUSH
58082: PPUSH
// if not mc_bases then
58083: LD_EXP 23
58087: NOT
58088: IFFALSE 58092
// exit ;
58090: GO 58654
// for i = 1 to mc_bases do
58092: LD_ADDR_VAR 0 2
58096: PUSH
58097: DOUBLE
58098: LD_INT 1
58100: DEC
58101: ST_TO_ADDR
58102: LD_EXP 23
58106: PUSH
58107: FOR_TO
58108: IFFALSE 58645
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
58110: LD_ADDR_VAR 0 5
58114: PUSH
58115: LD_EXP 23
58119: PUSH
58120: LD_VAR 0 2
58124: ARRAY
58125: PUSH
58126: LD_EXP 52
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: UNION
58137: PPUSH
58138: LD_INT 21
58140: PUSH
58141: LD_INT 1
58143: PUSH
58144: EMPTY
58145: LIST
58146: LIST
58147: PUSH
58148: LD_INT 1
58150: PUSH
58151: LD_INT 3
58153: PUSH
58154: LD_INT 54
58156: PUSH
58157: EMPTY
58158: LIST
58159: PUSH
58160: EMPTY
58161: LIST
58162: LIST
58163: PUSH
58164: LD_INT 3
58166: PUSH
58167: LD_INT 24
58169: PUSH
58170: LD_INT 1000
58172: PUSH
58173: EMPTY
58174: LIST
58175: LIST
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: PUSH
58181: EMPTY
58182: LIST
58183: LIST
58184: LIST
58185: PUSH
58186: EMPTY
58187: LIST
58188: LIST
58189: PPUSH
58190: CALL_OW 72
58194: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
58195: LD_ADDR_VAR 0 6
58199: PUSH
58200: LD_EXP 23
58204: PUSH
58205: LD_VAR 0 2
58209: ARRAY
58210: PPUSH
58211: LD_INT 21
58213: PUSH
58214: LD_INT 1
58216: PUSH
58217: EMPTY
58218: LIST
58219: LIST
58220: PUSH
58221: LD_INT 1
58223: PUSH
58224: LD_INT 3
58226: PUSH
58227: LD_INT 54
58229: PUSH
58230: EMPTY
58231: LIST
58232: PUSH
58233: EMPTY
58234: LIST
58235: LIST
58236: PUSH
58237: LD_INT 3
58239: PUSH
58240: LD_INT 24
58242: PUSH
58243: LD_INT 250
58245: PUSH
58246: EMPTY
58247: LIST
58248: LIST
58249: PUSH
58250: EMPTY
58251: LIST
58252: LIST
58253: PUSH
58254: EMPTY
58255: LIST
58256: LIST
58257: LIST
58258: PUSH
58259: EMPTY
58260: LIST
58261: LIST
58262: PPUSH
58263: CALL_OW 72
58267: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
58268: LD_ADDR_VAR 0 7
58272: PUSH
58273: LD_VAR 0 5
58277: PUSH
58278: LD_VAR 0 6
58282: DIFF
58283: ST_TO_ADDR
// if not need_heal_1 then
58284: LD_VAR 0 6
58288: NOT
58289: IFFALSE 58322
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
58291: LD_ADDR_EXP 26
58295: PUSH
58296: LD_EXP 26
58300: PPUSH
58301: LD_VAR 0 2
58305: PUSH
58306: LD_INT 1
58308: PUSH
58309: EMPTY
58310: LIST
58311: LIST
58312: PPUSH
58313: EMPTY
58314: PPUSH
58315: CALL 15704 0 3
58319: ST_TO_ADDR
58320: GO 58392
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
58322: LD_ADDR_EXP 26
58326: PUSH
58327: LD_EXP 26
58331: PPUSH
58332: LD_VAR 0 2
58336: PUSH
58337: LD_INT 1
58339: PUSH
58340: EMPTY
58341: LIST
58342: LIST
58343: PPUSH
58344: LD_EXP 26
58348: PUSH
58349: LD_VAR 0 2
58353: ARRAY
58354: PUSH
58355: LD_INT 1
58357: ARRAY
58358: PPUSH
58359: LD_INT 3
58361: PUSH
58362: LD_INT 24
58364: PUSH
58365: LD_INT 1000
58367: PUSH
58368: EMPTY
58369: LIST
58370: LIST
58371: PUSH
58372: EMPTY
58373: LIST
58374: LIST
58375: PPUSH
58376: CALL_OW 72
58380: PUSH
58381: LD_VAR 0 6
58385: UNION
58386: PPUSH
58387: CALL 15704 0 3
58391: ST_TO_ADDR
// if not need_heal_2 then
58392: LD_VAR 0 7
58396: NOT
58397: IFFALSE 58430
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
58399: LD_ADDR_EXP 26
58403: PUSH
58404: LD_EXP 26
58408: PPUSH
58409: LD_VAR 0 2
58413: PUSH
58414: LD_INT 2
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: PPUSH
58421: EMPTY
58422: PPUSH
58423: CALL 15704 0 3
58427: ST_TO_ADDR
58428: GO 58462
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
58430: LD_ADDR_EXP 26
58434: PUSH
58435: LD_EXP 26
58439: PPUSH
58440: LD_VAR 0 2
58444: PUSH
58445: LD_INT 2
58447: PUSH
58448: EMPTY
58449: LIST
58450: LIST
58451: PPUSH
58452: LD_VAR 0 7
58456: PPUSH
58457: CALL 15704 0 3
58461: ST_TO_ADDR
// if need_heal_2 then
58462: LD_VAR 0 7
58466: IFFALSE 58627
// for j in need_heal_2 do
58468: LD_ADDR_VAR 0 3
58472: PUSH
58473: LD_VAR 0 7
58477: PUSH
58478: FOR_IN
58479: IFFALSE 58625
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58481: LD_ADDR_VAR 0 5
58485: PUSH
58486: LD_EXP 23
58490: PUSH
58491: LD_VAR 0 2
58495: ARRAY
58496: PPUSH
58497: LD_INT 2
58499: PUSH
58500: LD_INT 30
58502: PUSH
58503: LD_INT 6
58505: PUSH
58506: EMPTY
58507: LIST
58508: LIST
58509: PUSH
58510: LD_INT 30
58512: PUSH
58513: LD_INT 7
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: PUSH
58520: LD_INT 30
58522: PUSH
58523: LD_INT 8
58525: PUSH
58526: EMPTY
58527: LIST
58528: LIST
58529: PUSH
58530: LD_INT 30
58532: PUSH
58533: LD_INT 0
58535: PUSH
58536: EMPTY
58537: LIST
58538: LIST
58539: PUSH
58540: LD_INT 30
58542: PUSH
58543: LD_INT 1
58545: PUSH
58546: EMPTY
58547: LIST
58548: LIST
58549: PUSH
58550: EMPTY
58551: LIST
58552: LIST
58553: LIST
58554: LIST
58555: LIST
58556: LIST
58557: PPUSH
58558: CALL_OW 72
58562: ST_TO_ADDR
// if tmp then
58563: LD_VAR 0 5
58567: IFFALSE 58623
// begin k := NearestUnitToUnit ( tmp , j ) ;
58569: LD_ADDR_VAR 0 4
58573: PUSH
58574: LD_VAR 0 5
58578: PPUSH
58579: LD_VAR 0 3
58583: PPUSH
58584: CALL_OW 74
58588: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
58589: LD_VAR 0 3
58593: PPUSH
58594: LD_VAR 0 4
58598: PPUSH
58599: CALL_OW 296
58603: PUSH
58604: LD_INT 5
58606: GREATER
58607: IFFALSE 58623
// ComMoveToNearbyEntrance ( j , k ) ;
58609: LD_VAR 0 3
58613: PPUSH
58614: LD_VAR 0 4
58618: PPUSH
58619: CALL 48322 0 2
// end ; end ;
58623: GO 58478
58625: POP
58626: POP
// if not need_heal_1 and not need_heal_2 then
58627: LD_VAR 0 6
58631: NOT
58632: PUSH
58633: LD_VAR 0 7
58637: NOT
58638: AND
58639: IFFALSE 58643
// continue ;
58641: GO 58107
// end ;
58643: GO 58107
58645: POP
58646: POP
// RaiseSailEvent ( 102 ) ;
58647: LD_INT 102
58649: PPUSH
58650: CALL_OW 427
// end ;
58654: LD_VAR 0 1
58658: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
58659: LD_INT 0
58661: PPUSH
58662: PPUSH
58663: PPUSH
58664: PPUSH
58665: PPUSH
58666: PPUSH
58667: PPUSH
58668: PPUSH
// if not mc_bases then
58669: LD_EXP 23
58673: NOT
58674: IFFALSE 58678
// exit ;
58676: GO 59561
// for i = 1 to mc_bases do
58678: LD_ADDR_VAR 0 2
58682: PUSH
58683: DOUBLE
58684: LD_INT 1
58686: DEC
58687: ST_TO_ADDR
58688: LD_EXP 23
58692: PUSH
58693: FOR_TO
58694: IFFALSE 59559
// begin if not mc_building_need_repair [ i ] then
58696: LD_EXP 24
58700: PUSH
58701: LD_VAR 0 2
58705: ARRAY
58706: NOT
58707: IFFALSE 58894
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
58709: LD_ADDR_VAR 0 6
58713: PUSH
58714: LD_EXP 42
58718: PUSH
58719: LD_VAR 0 2
58723: ARRAY
58724: PPUSH
58725: LD_INT 3
58727: PUSH
58728: LD_INT 24
58730: PUSH
58731: LD_INT 1000
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: PUSH
58738: EMPTY
58739: LIST
58740: LIST
58741: PUSH
58742: LD_INT 2
58744: PUSH
58745: LD_INT 34
58747: PUSH
58748: LD_INT 13
58750: PUSH
58751: EMPTY
58752: LIST
58753: LIST
58754: PUSH
58755: LD_INT 34
58757: PUSH
58758: LD_INT 52
58760: PUSH
58761: EMPTY
58762: LIST
58763: LIST
58764: PUSH
58765: LD_INT 34
58767: PUSH
58768: LD_EXP 73
58772: PUSH
58773: EMPTY
58774: LIST
58775: LIST
58776: PUSH
58777: EMPTY
58778: LIST
58779: LIST
58780: LIST
58781: LIST
58782: PUSH
58783: EMPTY
58784: LIST
58785: LIST
58786: PPUSH
58787: CALL_OW 72
58791: ST_TO_ADDR
// if cranes then
58792: LD_VAR 0 6
58796: IFFALSE 58858
// for j in cranes do
58798: LD_ADDR_VAR 0 3
58802: PUSH
58803: LD_VAR 0 6
58807: PUSH
58808: FOR_IN
58809: IFFALSE 58856
// if not IsInArea ( j , mc_parking [ i ] ) then
58811: LD_VAR 0 3
58815: PPUSH
58816: LD_EXP 47
58820: PUSH
58821: LD_VAR 0 2
58825: ARRAY
58826: PPUSH
58827: CALL_OW 308
58831: NOT
58832: IFFALSE 58854
// ComMoveToArea ( j , mc_parking [ i ] ) ;
58834: LD_VAR 0 3
58838: PPUSH
58839: LD_EXP 47
58843: PUSH
58844: LD_VAR 0 2
58848: ARRAY
58849: PPUSH
58850: CALL_OW 113
58854: GO 58808
58856: POP
58857: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58858: LD_ADDR_EXP 25
58862: PUSH
58863: LD_EXP 25
58867: PPUSH
58868: LD_VAR 0 2
58872: PPUSH
58873: EMPTY
58874: PPUSH
58875: CALL_OW 1
58879: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
58880: LD_VAR 0 2
58884: PPUSH
58885: LD_INT 101
58887: PPUSH
58888: CALL 53746 0 2
// continue ;
58892: GO 58693
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
58894: LD_ADDR_EXP 29
58898: PUSH
58899: LD_EXP 29
58903: PPUSH
58904: LD_VAR 0 2
58908: PPUSH
58909: EMPTY
58910: PPUSH
58911: CALL_OW 1
58915: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
58916: LD_VAR 0 2
58920: PPUSH
58921: LD_INT 103
58923: PPUSH
58924: CALL 53746 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
58928: LD_ADDR_VAR 0 5
58932: PUSH
58933: LD_EXP 23
58937: PUSH
58938: LD_VAR 0 2
58942: ARRAY
58943: PUSH
58944: LD_EXP 52
58948: PUSH
58949: LD_VAR 0 2
58953: ARRAY
58954: UNION
58955: PPUSH
58956: LD_INT 2
58958: PUSH
58959: LD_INT 25
58961: PUSH
58962: LD_INT 2
58964: PUSH
58965: EMPTY
58966: LIST
58967: LIST
58968: PUSH
58969: LD_INT 25
58971: PUSH
58972: LD_INT 16
58974: PUSH
58975: EMPTY
58976: LIST
58977: LIST
58978: PUSH
58979: EMPTY
58980: LIST
58981: LIST
58982: LIST
58983: PUSH
58984: EMPTY
58985: LIST
58986: PPUSH
58987: CALL_OW 72
58991: ST_TO_ADDR
// if mc_need_heal [ i ] then
58992: LD_EXP 26
58996: PUSH
58997: LD_VAR 0 2
59001: ARRAY
59002: IFFALSE 59046
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59004: LD_ADDR_VAR 0 5
59008: PUSH
59009: LD_VAR 0 5
59013: PUSH
59014: LD_EXP 26
59018: PUSH
59019: LD_VAR 0 2
59023: ARRAY
59024: PUSH
59025: LD_INT 1
59027: ARRAY
59028: PUSH
59029: LD_EXP 26
59033: PUSH
59034: LD_VAR 0 2
59038: ARRAY
59039: PUSH
59040: LD_INT 2
59042: ARRAY
59043: UNION
59044: DIFF
59045: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
59046: LD_ADDR_VAR 0 6
59050: PUSH
59051: LD_EXP 42
59055: PUSH
59056: LD_VAR 0 2
59060: ARRAY
59061: PPUSH
59062: LD_INT 2
59064: PUSH
59065: LD_INT 34
59067: PUSH
59068: LD_INT 13
59070: PUSH
59071: EMPTY
59072: LIST
59073: LIST
59074: PUSH
59075: LD_INT 34
59077: PUSH
59078: LD_INT 52
59080: PUSH
59081: EMPTY
59082: LIST
59083: LIST
59084: PUSH
59085: LD_INT 34
59087: PUSH
59088: LD_EXP 73
59092: PUSH
59093: EMPTY
59094: LIST
59095: LIST
59096: PUSH
59097: EMPTY
59098: LIST
59099: LIST
59100: LIST
59101: LIST
59102: PPUSH
59103: CALL_OW 72
59107: ST_TO_ADDR
// if cranes then
59108: LD_VAR 0 6
59112: IFFALSE 59248
// begin for j in cranes do
59114: LD_ADDR_VAR 0 3
59118: PUSH
59119: LD_VAR 0 6
59123: PUSH
59124: FOR_IN
59125: IFFALSE 59246
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
59127: LD_VAR 0 3
59131: PPUSH
59132: CALL_OW 256
59136: PUSH
59137: LD_INT 1000
59139: EQUAL
59140: PUSH
59141: LD_VAR 0 3
59145: PPUSH
59146: CALL_OW 314
59150: NOT
59151: AND
59152: IFFALSE 59186
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59154: LD_VAR 0 3
59158: PPUSH
59159: LD_EXP 24
59163: PUSH
59164: LD_VAR 0 2
59168: ARRAY
59169: PPUSH
59170: LD_VAR 0 3
59174: PPUSH
59175: CALL_OW 74
59179: PPUSH
59180: CALL_OW 130
59184: GO 59244
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59186: LD_VAR 0 3
59190: PPUSH
59191: CALL_OW 256
59195: PUSH
59196: LD_INT 500
59198: LESS
59199: PUSH
59200: LD_VAR 0 3
59204: PPUSH
59205: LD_EXP 47
59209: PUSH
59210: LD_VAR 0 2
59214: ARRAY
59215: PPUSH
59216: CALL_OW 308
59220: NOT
59221: AND
59222: IFFALSE 59244
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59224: LD_VAR 0 3
59228: PPUSH
59229: LD_EXP 47
59233: PUSH
59234: LD_VAR 0 2
59238: ARRAY
59239: PPUSH
59240: CALL_OW 113
// end ;
59244: GO 59124
59246: POP
59247: POP
// end ; if tmp > 3 then
59248: LD_VAR 0 5
59252: PUSH
59253: LD_INT 3
59255: GREATER
59256: IFFALSE 59276
// tmp := ShrinkArray ( tmp , 4 ) ;
59258: LD_ADDR_VAR 0 5
59262: PUSH
59263: LD_VAR 0 5
59267: PPUSH
59268: LD_INT 4
59270: PPUSH
59271: CALL 47770 0 2
59275: ST_TO_ADDR
// if not tmp then
59276: LD_VAR 0 5
59280: NOT
59281: IFFALSE 59285
// continue ;
59283: GO 58693
// for j in tmp do
59285: LD_ADDR_VAR 0 3
59289: PUSH
59290: LD_VAR 0 5
59294: PUSH
59295: FOR_IN
59296: IFFALSE 59555
// begin if IsInUnit ( j ) then
59298: LD_VAR 0 3
59302: PPUSH
59303: CALL_OW 310
59307: IFFALSE 59318
// ComExitBuilding ( j ) ;
59309: LD_VAR 0 3
59313: PPUSH
59314: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
59318: LD_VAR 0 3
59322: PUSH
59323: LD_EXP 25
59327: PUSH
59328: LD_VAR 0 2
59332: ARRAY
59333: IN
59334: NOT
59335: IFFALSE 59393
// begin SetTag ( j , 101 ) ;
59337: LD_VAR 0 3
59341: PPUSH
59342: LD_INT 101
59344: PPUSH
59345: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
59349: LD_ADDR_EXP 25
59353: PUSH
59354: LD_EXP 25
59358: PPUSH
59359: LD_VAR 0 2
59363: PUSH
59364: LD_EXP 25
59368: PUSH
59369: LD_VAR 0 2
59373: ARRAY
59374: PUSH
59375: LD_INT 1
59377: PLUS
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: PPUSH
59383: LD_VAR 0 3
59387: PPUSH
59388: CALL 15704 0 3
59392: ST_TO_ADDR
// end ; wait ( 1 ) ;
59393: LD_INT 1
59395: PPUSH
59396: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
59400: LD_ADDR_VAR 0 7
59404: PUSH
59405: LD_EXP 24
59409: PUSH
59410: LD_VAR 0 2
59414: ARRAY
59415: ST_TO_ADDR
// if mc_scan [ i ] then
59416: LD_EXP 46
59420: PUSH
59421: LD_VAR 0 2
59425: ARRAY
59426: IFFALSE 59488
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
59428: LD_ADDR_VAR 0 7
59432: PUSH
59433: LD_EXP 24
59437: PUSH
59438: LD_VAR 0 2
59442: ARRAY
59443: PPUSH
59444: LD_INT 3
59446: PUSH
59447: LD_INT 30
59449: PUSH
59450: LD_INT 32
59452: PUSH
59453: EMPTY
59454: LIST
59455: LIST
59456: PUSH
59457: LD_INT 30
59459: PUSH
59460: LD_INT 33
59462: PUSH
59463: EMPTY
59464: LIST
59465: LIST
59466: PUSH
59467: LD_INT 30
59469: PUSH
59470: LD_INT 31
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: PUSH
59477: EMPTY
59478: LIST
59479: LIST
59480: LIST
59481: LIST
59482: PPUSH
59483: CALL_OW 72
59487: ST_TO_ADDR
// if not to_repair_tmp then
59488: LD_VAR 0 7
59492: NOT
59493: IFFALSE 59497
// continue ;
59495: GO 59295
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
59497: LD_ADDR_VAR 0 8
59501: PUSH
59502: LD_VAR 0 7
59506: PPUSH
59507: LD_VAR 0 3
59511: PPUSH
59512: CALL_OW 74
59516: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
59517: LD_VAR 0 8
59521: PPUSH
59522: LD_INT 16
59524: PPUSH
59525: CALL 18303 0 2
59529: PUSH
59530: LD_INT 4
59532: ARRAY
59533: PUSH
59534: LD_INT 10
59536: LESS
59537: IFFALSE 59553
// ComRepairBuilding ( j , to_repair ) ;
59539: LD_VAR 0 3
59543: PPUSH
59544: LD_VAR 0 8
59548: PPUSH
59549: CALL_OW 130
// end ;
59553: GO 59295
59555: POP
59556: POP
// end ;
59557: GO 58693
59559: POP
59560: POP
// end ;
59561: LD_VAR 0 1
59565: RET
// export function MC_Heal ; var i , j , tmp ; begin
59566: LD_INT 0
59568: PPUSH
59569: PPUSH
59570: PPUSH
59571: PPUSH
// if not mc_bases then
59572: LD_EXP 23
59576: NOT
59577: IFFALSE 59581
// exit ;
59579: GO 59983
// for i = 1 to mc_bases do
59581: LD_ADDR_VAR 0 2
59585: PUSH
59586: DOUBLE
59587: LD_INT 1
59589: DEC
59590: ST_TO_ADDR
59591: LD_EXP 23
59595: PUSH
59596: FOR_TO
59597: IFFALSE 59981
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
59599: LD_EXP 26
59603: PUSH
59604: LD_VAR 0 2
59608: ARRAY
59609: PUSH
59610: LD_INT 1
59612: ARRAY
59613: NOT
59614: PUSH
59615: LD_EXP 26
59619: PUSH
59620: LD_VAR 0 2
59624: ARRAY
59625: PUSH
59626: LD_INT 2
59628: ARRAY
59629: NOT
59630: AND
59631: IFFALSE 59669
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
59633: LD_ADDR_EXP 27
59637: PUSH
59638: LD_EXP 27
59642: PPUSH
59643: LD_VAR 0 2
59647: PPUSH
59648: EMPTY
59649: PPUSH
59650: CALL_OW 1
59654: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
59655: LD_VAR 0 2
59659: PPUSH
59660: LD_INT 102
59662: PPUSH
59663: CALL 53746 0 2
// continue ;
59667: GO 59596
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59669: LD_ADDR_VAR 0 4
59673: PUSH
59674: LD_EXP 23
59678: PUSH
59679: LD_VAR 0 2
59683: ARRAY
59684: PPUSH
59685: LD_INT 25
59687: PUSH
59688: LD_INT 4
59690: PUSH
59691: EMPTY
59692: LIST
59693: LIST
59694: PPUSH
59695: CALL_OW 72
59699: ST_TO_ADDR
// if not tmp then
59700: LD_VAR 0 4
59704: NOT
59705: IFFALSE 59709
// continue ;
59707: GO 59596
// if mc_taming [ i ] then
59709: LD_EXP 54
59713: PUSH
59714: LD_VAR 0 2
59718: ARRAY
59719: IFFALSE 59743
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59721: LD_ADDR_EXP 54
59725: PUSH
59726: LD_EXP 54
59730: PPUSH
59731: LD_VAR 0 2
59735: PPUSH
59736: EMPTY
59737: PPUSH
59738: CALL_OW 1
59742: ST_TO_ADDR
// for j in tmp do
59743: LD_ADDR_VAR 0 3
59747: PUSH
59748: LD_VAR 0 4
59752: PUSH
59753: FOR_IN
59754: IFFALSE 59977
// begin if IsInUnit ( j ) then
59756: LD_VAR 0 3
59760: PPUSH
59761: CALL_OW 310
59765: IFFALSE 59776
// ComExitBuilding ( j ) ;
59767: LD_VAR 0 3
59771: PPUSH
59772: CALL_OW 122
// if not j in mc_healers [ i ] then
59776: LD_VAR 0 3
59780: PUSH
59781: LD_EXP 27
59785: PUSH
59786: LD_VAR 0 2
59790: ARRAY
59791: IN
59792: NOT
59793: IFFALSE 59839
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
59795: LD_ADDR_EXP 27
59799: PUSH
59800: LD_EXP 27
59804: PPUSH
59805: LD_VAR 0 2
59809: PUSH
59810: LD_EXP 27
59814: PUSH
59815: LD_VAR 0 2
59819: ARRAY
59820: PUSH
59821: LD_INT 1
59823: PLUS
59824: PUSH
59825: EMPTY
59826: LIST
59827: LIST
59828: PPUSH
59829: LD_VAR 0 3
59833: PPUSH
59834: CALL 15704 0 3
59838: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
59839: LD_VAR 0 3
59843: PPUSH
59844: CALL_OW 110
59848: PUSH
59849: LD_INT 102
59851: NONEQUAL
59852: IFFALSE 59866
// SetTag ( j , 102 ) ;
59854: LD_VAR 0 3
59858: PPUSH
59859: LD_INT 102
59861: PPUSH
59862: CALL_OW 109
// Wait ( 3 ) ;
59866: LD_INT 3
59868: PPUSH
59869: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
59873: LD_EXP 26
59877: PUSH
59878: LD_VAR 0 2
59882: ARRAY
59883: PUSH
59884: LD_INT 1
59886: ARRAY
59887: IFFALSE 59919
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
59889: LD_VAR 0 3
59893: PPUSH
59894: LD_EXP 26
59898: PUSH
59899: LD_VAR 0 2
59903: ARRAY
59904: PUSH
59905: LD_INT 1
59907: ARRAY
59908: PUSH
59909: LD_INT 1
59911: ARRAY
59912: PPUSH
59913: CALL_OW 128
59917: GO 59975
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
59919: LD_VAR 0 3
59923: PPUSH
59924: CALL_OW 314
59928: NOT
59929: PUSH
59930: LD_EXP 26
59934: PUSH
59935: LD_VAR 0 2
59939: ARRAY
59940: PUSH
59941: LD_INT 2
59943: ARRAY
59944: AND
59945: IFFALSE 59975
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
59947: LD_VAR 0 3
59951: PPUSH
59952: LD_EXP 26
59956: PUSH
59957: LD_VAR 0 2
59961: ARRAY
59962: PUSH
59963: LD_INT 2
59965: ARRAY
59966: PUSH
59967: LD_INT 1
59969: ARRAY
59970: PPUSH
59971: CALL_OW 128
// end ;
59975: GO 59753
59977: POP
59978: POP
// end ;
59979: GO 59596
59981: POP
59982: POP
// end ;
59983: LD_VAR 0 1
59987: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
59988: LD_INT 0
59990: PPUSH
59991: PPUSH
59992: PPUSH
59993: PPUSH
59994: PPUSH
// if not mc_bases then
59995: LD_EXP 23
59999: NOT
60000: IFFALSE 60004
// exit ;
60002: GO 61175
// for i = 1 to mc_bases do
60004: LD_ADDR_VAR 0 2
60008: PUSH
60009: DOUBLE
60010: LD_INT 1
60012: DEC
60013: ST_TO_ADDR
60014: LD_EXP 23
60018: PUSH
60019: FOR_TO
60020: IFFALSE 61173
// begin if mc_scan [ i ] then
60022: LD_EXP 46
60026: PUSH
60027: LD_VAR 0 2
60031: ARRAY
60032: IFFALSE 60036
// continue ;
60034: GO 60019
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60036: LD_EXP 28
60040: PUSH
60041: LD_VAR 0 2
60045: ARRAY
60046: NOT
60047: PUSH
60048: LD_EXP 30
60052: PUSH
60053: LD_VAR 0 2
60057: ARRAY
60058: NOT
60059: AND
60060: PUSH
60061: LD_EXP 29
60065: PUSH
60066: LD_VAR 0 2
60070: ARRAY
60071: AND
60072: IFFALSE 60110
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60074: LD_ADDR_EXP 29
60078: PUSH
60079: LD_EXP 29
60083: PPUSH
60084: LD_VAR 0 2
60088: PPUSH
60089: EMPTY
60090: PPUSH
60091: CALL_OW 1
60095: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60096: LD_VAR 0 2
60100: PPUSH
60101: LD_INT 103
60103: PPUSH
60104: CALL 53746 0 2
// continue ;
60108: GO 60019
// end ; if mc_construct_list [ i ] then
60110: LD_EXP 30
60114: PUSH
60115: LD_VAR 0 2
60119: ARRAY
60120: IFFALSE 60340
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60122: LD_ADDR_VAR 0 4
60126: PUSH
60127: LD_EXP 23
60131: PUSH
60132: LD_VAR 0 2
60136: ARRAY
60137: PPUSH
60138: LD_INT 25
60140: PUSH
60141: LD_INT 2
60143: PUSH
60144: EMPTY
60145: LIST
60146: LIST
60147: PPUSH
60148: CALL_OW 72
60152: PUSH
60153: LD_EXP 25
60157: PUSH
60158: LD_VAR 0 2
60162: ARRAY
60163: DIFF
60164: ST_TO_ADDR
// if not tmp then
60165: LD_VAR 0 4
60169: NOT
60170: IFFALSE 60174
// continue ;
60172: GO 60019
// for j in tmp do
60174: LD_ADDR_VAR 0 3
60178: PUSH
60179: LD_VAR 0 4
60183: PUSH
60184: FOR_IN
60185: IFFALSE 60336
// begin if not mc_builders [ i ] then
60187: LD_EXP 29
60191: PUSH
60192: LD_VAR 0 2
60196: ARRAY
60197: NOT
60198: IFFALSE 60256
// begin SetTag ( j , 103 ) ;
60200: LD_VAR 0 3
60204: PPUSH
60205: LD_INT 103
60207: PPUSH
60208: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60212: LD_ADDR_EXP 29
60216: PUSH
60217: LD_EXP 29
60221: PPUSH
60222: LD_VAR 0 2
60226: PUSH
60227: LD_EXP 29
60231: PUSH
60232: LD_VAR 0 2
60236: ARRAY
60237: PUSH
60238: LD_INT 1
60240: PLUS
60241: PUSH
60242: EMPTY
60243: LIST
60244: LIST
60245: PPUSH
60246: LD_VAR 0 3
60250: PPUSH
60251: CALL 15704 0 3
60255: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60256: LD_VAR 0 3
60260: PPUSH
60261: CALL_OW 310
60265: IFFALSE 60276
// ComExitBuilding ( j ) ;
60267: LD_VAR 0 3
60271: PPUSH
60272: CALL_OW 122
// wait ( 3 ) ;
60276: LD_INT 3
60278: PPUSH
60279: CALL_OW 67
// if not mc_construct_list [ i ] then
60283: LD_EXP 30
60287: PUSH
60288: LD_VAR 0 2
60292: ARRAY
60293: NOT
60294: IFFALSE 60298
// break ;
60296: GO 60336
// if not HasTask ( j ) then
60298: LD_VAR 0 3
60302: PPUSH
60303: CALL_OW 314
60307: NOT
60308: IFFALSE 60334
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
60310: LD_VAR 0 3
60314: PPUSH
60315: LD_EXP 30
60319: PUSH
60320: LD_VAR 0 2
60324: ARRAY
60325: PUSH
60326: LD_INT 1
60328: ARRAY
60329: PPUSH
60330: CALL 18567 0 2
// end ;
60334: GO 60184
60336: POP
60337: POP
// end else
60338: GO 61171
// if mc_build_list [ i ] then
60340: LD_EXP 28
60344: PUSH
60345: LD_VAR 0 2
60349: ARRAY
60350: IFFALSE 61171
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60352: LD_ADDR_VAR 0 5
60356: PUSH
60357: LD_EXP 23
60361: PUSH
60362: LD_VAR 0 2
60366: ARRAY
60367: PPUSH
60368: LD_INT 2
60370: PUSH
60371: LD_INT 30
60373: PUSH
60374: LD_INT 0
60376: PUSH
60377: EMPTY
60378: LIST
60379: LIST
60380: PUSH
60381: LD_INT 30
60383: PUSH
60384: LD_INT 1
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: PUSH
60391: EMPTY
60392: LIST
60393: LIST
60394: LIST
60395: PPUSH
60396: CALL_OW 72
60400: ST_TO_ADDR
// if depot then
60401: LD_VAR 0 5
60405: IFFALSE 60423
// depot := depot [ 1 ] else
60407: LD_ADDR_VAR 0 5
60411: PUSH
60412: LD_VAR 0 5
60416: PUSH
60417: LD_INT 1
60419: ARRAY
60420: ST_TO_ADDR
60421: GO 60431
// depot := 0 ;
60423: LD_ADDR_VAR 0 5
60427: PUSH
60428: LD_INT 0
60430: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
60431: LD_EXP 28
60435: PUSH
60436: LD_VAR 0 2
60440: ARRAY
60441: PUSH
60442: LD_INT 1
60444: ARRAY
60445: PUSH
60446: LD_INT 1
60448: ARRAY
60449: PPUSH
60450: CALL 18391 0 1
60454: PUSH
60455: LD_EXP 23
60459: PUSH
60460: LD_VAR 0 2
60464: ARRAY
60465: PPUSH
60466: LD_INT 2
60468: PUSH
60469: LD_INT 30
60471: PUSH
60472: LD_INT 2
60474: PUSH
60475: EMPTY
60476: LIST
60477: LIST
60478: PUSH
60479: LD_INT 30
60481: PUSH
60482: LD_INT 3
60484: PUSH
60485: EMPTY
60486: LIST
60487: LIST
60488: PUSH
60489: EMPTY
60490: LIST
60491: LIST
60492: LIST
60493: PPUSH
60494: CALL_OW 72
60498: NOT
60499: AND
60500: IFFALSE 60605
// begin for j = 1 to mc_build_list [ i ] do
60502: LD_ADDR_VAR 0 3
60506: PUSH
60507: DOUBLE
60508: LD_INT 1
60510: DEC
60511: ST_TO_ADDR
60512: LD_EXP 28
60516: PUSH
60517: LD_VAR 0 2
60521: ARRAY
60522: PUSH
60523: FOR_TO
60524: IFFALSE 60603
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
60526: LD_EXP 28
60530: PUSH
60531: LD_VAR 0 2
60535: ARRAY
60536: PUSH
60537: LD_VAR 0 3
60541: ARRAY
60542: PUSH
60543: LD_INT 1
60545: ARRAY
60546: PUSH
60547: LD_INT 2
60549: EQUAL
60550: IFFALSE 60601
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
60552: LD_ADDR_EXP 28
60556: PUSH
60557: LD_EXP 28
60561: PPUSH
60562: LD_VAR 0 2
60566: PPUSH
60567: LD_EXP 28
60571: PUSH
60572: LD_VAR 0 2
60576: ARRAY
60577: PPUSH
60578: LD_VAR 0 3
60582: PPUSH
60583: LD_INT 1
60585: PPUSH
60586: LD_INT 0
60588: PPUSH
60589: CALL 15122 0 4
60593: PPUSH
60594: CALL_OW 1
60598: ST_TO_ADDR
// break ;
60599: GO 60603
// end ;
60601: GO 60523
60603: POP
60604: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
60605: LD_EXP 28
60609: PUSH
60610: LD_VAR 0 2
60614: ARRAY
60615: PUSH
60616: LD_INT 1
60618: ARRAY
60619: PUSH
60620: LD_INT 1
60622: ARRAY
60623: PUSH
60624: LD_INT 0
60626: EQUAL
60627: PUSH
60628: LD_VAR 0 5
60632: PUSH
60633: LD_VAR 0 5
60637: PPUSH
60638: LD_EXP 28
60642: PUSH
60643: LD_VAR 0 2
60647: ARRAY
60648: PUSH
60649: LD_INT 1
60651: ARRAY
60652: PUSH
60653: LD_INT 1
60655: ARRAY
60656: PPUSH
60657: LD_EXP 28
60661: PUSH
60662: LD_VAR 0 2
60666: ARRAY
60667: PUSH
60668: LD_INT 1
60670: ARRAY
60671: PUSH
60672: LD_INT 2
60674: ARRAY
60675: PPUSH
60676: LD_EXP 28
60680: PUSH
60681: LD_VAR 0 2
60685: ARRAY
60686: PUSH
60687: LD_INT 1
60689: ARRAY
60690: PUSH
60691: LD_INT 3
60693: ARRAY
60694: PPUSH
60695: LD_EXP 28
60699: PUSH
60700: LD_VAR 0 2
60704: ARRAY
60705: PUSH
60706: LD_INT 1
60708: ARRAY
60709: PUSH
60710: LD_INT 4
60712: ARRAY
60713: PPUSH
60714: CALL 23807 0 5
60718: AND
60719: OR
60720: IFFALSE 61001
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60722: LD_ADDR_VAR 0 4
60726: PUSH
60727: LD_EXP 23
60731: PUSH
60732: LD_VAR 0 2
60736: ARRAY
60737: PPUSH
60738: LD_INT 25
60740: PUSH
60741: LD_INT 2
60743: PUSH
60744: EMPTY
60745: LIST
60746: LIST
60747: PPUSH
60748: CALL_OW 72
60752: PUSH
60753: LD_EXP 25
60757: PUSH
60758: LD_VAR 0 2
60762: ARRAY
60763: DIFF
60764: ST_TO_ADDR
// if not tmp then
60765: LD_VAR 0 4
60769: NOT
60770: IFFALSE 60774
// continue ;
60772: GO 60019
// for j in tmp do
60774: LD_ADDR_VAR 0 3
60778: PUSH
60779: LD_VAR 0 4
60783: PUSH
60784: FOR_IN
60785: IFFALSE 60997
// begin if not mc_builders [ i ] then
60787: LD_EXP 29
60791: PUSH
60792: LD_VAR 0 2
60796: ARRAY
60797: NOT
60798: IFFALSE 60856
// begin SetTag ( j , 103 ) ;
60800: LD_VAR 0 3
60804: PPUSH
60805: LD_INT 103
60807: PPUSH
60808: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60812: LD_ADDR_EXP 29
60816: PUSH
60817: LD_EXP 29
60821: PPUSH
60822: LD_VAR 0 2
60826: PUSH
60827: LD_EXP 29
60831: PUSH
60832: LD_VAR 0 2
60836: ARRAY
60837: PUSH
60838: LD_INT 1
60840: PLUS
60841: PUSH
60842: EMPTY
60843: LIST
60844: LIST
60845: PPUSH
60846: LD_VAR 0 3
60850: PPUSH
60851: CALL 15704 0 3
60855: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
60856: LD_VAR 0 3
60860: PPUSH
60861: CALL_OW 310
60865: IFFALSE 60876
// ComExitBuilding ( j ) ;
60867: LD_VAR 0 3
60871: PPUSH
60872: CALL_OW 122
// wait ( 3 ) ;
60876: LD_INT 3
60878: PPUSH
60879: CALL_OW 67
// if not mc_build_list [ i ] then
60883: LD_EXP 28
60887: PUSH
60888: LD_VAR 0 2
60892: ARRAY
60893: NOT
60894: IFFALSE 60898
// break ;
60896: GO 60997
// if not HasTask ( j ) then
60898: LD_VAR 0 3
60902: PPUSH
60903: CALL_OW 314
60907: NOT
60908: IFFALSE 60995
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
60910: LD_VAR 0 3
60914: PPUSH
60915: LD_EXP 28
60919: PUSH
60920: LD_VAR 0 2
60924: ARRAY
60925: PUSH
60926: LD_INT 1
60928: ARRAY
60929: PUSH
60930: LD_INT 1
60932: ARRAY
60933: PPUSH
60934: LD_EXP 28
60938: PUSH
60939: LD_VAR 0 2
60943: ARRAY
60944: PUSH
60945: LD_INT 1
60947: ARRAY
60948: PUSH
60949: LD_INT 2
60951: ARRAY
60952: PPUSH
60953: LD_EXP 28
60957: PUSH
60958: LD_VAR 0 2
60962: ARRAY
60963: PUSH
60964: LD_INT 1
60966: ARRAY
60967: PUSH
60968: LD_INT 3
60970: ARRAY
60971: PPUSH
60972: LD_EXP 28
60976: PUSH
60977: LD_VAR 0 2
60981: ARRAY
60982: PUSH
60983: LD_INT 1
60985: ARRAY
60986: PUSH
60987: LD_INT 4
60989: ARRAY
60990: PPUSH
60991: CALL_OW 145
// end ;
60995: GO 60784
60997: POP
60998: POP
// end else
60999: GO 61171
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
61001: LD_EXP 23
61005: PUSH
61006: LD_VAR 0 2
61010: ARRAY
61011: PPUSH
61012: LD_EXP 28
61016: PUSH
61017: LD_VAR 0 2
61021: ARRAY
61022: PUSH
61023: LD_INT 1
61025: ARRAY
61026: PUSH
61027: LD_INT 1
61029: ARRAY
61030: PPUSH
61031: LD_EXP 28
61035: PUSH
61036: LD_VAR 0 2
61040: ARRAY
61041: PUSH
61042: LD_INT 1
61044: ARRAY
61045: PUSH
61046: LD_INT 2
61048: ARRAY
61049: PPUSH
61050: LD_EXP 28
61054: PUSH
61055: LD_VAR 0 2
61059: ARRAY
61060: PUSH
61061: LD_INT 1
61063: ARRAY
61064: PUSH
61065: LD_INT 3
61067: ARRAY
61068: PPUSH
61069: LD_EXP 28
61073: PUSH
61074: LD_VAR 0 2
61078: ARRAY
61079: PUSH
61080: LD_INT 1
61082: ARRAY
61083: PUSH
61084: LD_INT 4
61086: ARRAY
61087: PPUSH
61088: LD_EXP 23
61092: PUSH
61093: LD_VAR 0 2
61097: ARRAY
61098: PPUSH
61099: LD_INT 21
61101: PUSH
61102: LD_INT 3
61104: PUSH
61105: EMPTY
61106: LIST
61107: LIST
61108: PPUSH
61109: CALL_OW 72
61113: PPUSH
61114: EMPTY
61115: PPUSH
61116: CALL 22557 0 7
61120: NOT
61121: IFFALSE 61171
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61123: LD_ADDR_EXP 28
61127: PUSH
61128: LD_EXP 28
61132: PPUSH
61133: LD_VAR 0 2
61137: PPUSH
61138: LD_EXP 28
61142: PUSH
61143: LD_VAR 0 2
61147: ARRAY
61148: PPUSH
61149: LD_INT 1
61151: PPUSH
61152: LD_INT 1
61154: NEG
61155: PPUSH
61156: LD_INT 0
61158: PPUSH
61159: CALL 15122 0 4
61163: PPUSH
61164: CALL_OW 1
61168: ST_TO_ADDR
// continue ;
61169: GO 60019
// end ; end ; end ;
61171: GO 60019
61173: POP
61174: POP
// end ;
61175: LD_VAR 0 1
61179: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61180: LD_INT 0
61182: PPUSH
61183: PPUSH
61184: PPUSH
61185: PPUSH
61186: PPUSH
61187: PPUSH
// if not mc_bases then
61188: LD_EXP 23
61192: NOT
61193: IFFALSE 61197
// exit ;
61195: GO 61624
// for i = 1 to mc_bases do
61197: LD_ADDR_VAR 0 2
61201: PUSH
61202: DOUBLE
61203: LD_INT 1
61205: DEC
61206: ST_TO_ADDR
61207: LD_EXP 23
61211: PUSH
61212: FOR_TO
61213: IFFALSE 61622
// begin tmp := mc_build_upgrade [ i ] ;
61215: LD_ADDR_VAR 0 4
61219: PUSH
61220: LD_EXP 55
61224: PUSH
61225: LD_VAR 0 2
61229: ARRAY
61230: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61231: LD_ADDR_VAR 0 6
61235: PUSH
61236: LD_EXP 56
61240: PUSH
61241: LD_VAR 0 2
61245: ARRAY
61246: PPUSH
61247: LD_INT 2
61249: PUSH
61250: LD_INT 30
61252: PUSH
61253: LD_INT 6
61255: PUSH
61256: EMPTY
61257: LIST
61258: LIST
61259: PUSH
61260: LD_INT 30
61262: PUSH
61263: LD_INT 7
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: LIST
61274: PPUSH
61275: CALL_OW 72
61279: ST_TO_ADDR
// if not tmp and not lab then
61280: LD_VAR 0 4
61284: NOT
61285: PUSH
61286: LD_VAR 0 6
61290: NOT
61291: AND
61292: IFFALSE 61296
// continue ;
61294: GO 61212
// if tmp then
61296: LD_VAR 0 4
61300: IFFALSE 61420
// for j in tmp do
61302: LD_ADDR_VAR 0 3
61306: PUSH
61307: LD_VAR 0 4
61311: PUSH
61312: FOR_IN
61313: IFFALSE 61418
// begin if UpgradeCost ( j ) then
61315: LD_VAR 0 3
61319: PPUSH
61320: CALL 22217 0 1
61324: IFFALSE 61416
// begin ComUpgrade ( j ) ;
61326: LD_VAR 0 3
61330: PPUSH
61331: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
61335: LD_ADDR_EXP 55
61339: PUSH
61340: LD_EXP 55
61344: PPUSH
61345: LD_VAR 0 2
61349: PPUSH
61350: LD_EXP 55
61354: PUSH
61355: LD_VAR 0 2
61359: ARRAY
61360: PUSH
61361: LD_VAR 0 3
61365: DIFF
61366: PPUSH
61367: CALL_OW 1
61371: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61372: LD_ADDR_EXP 30
61376: PUSH
61377: LD_EXP 30
61381: PPUSH
61382: LD_VAR 0 2
61386: PUSH
61387: LD_EXP 30
61391: PUSH
61392: LD_VAR 0 2
61396: ARRAY
61397: PUSH
61398: LD_INT 1
61400: PLUS
61401: PUSH
61402: EMPTY
61403: LIST
61404: LIST
61405: PPUSH
61406: LD_VAR 0 3
61410: PPUSH
61411: CALL 15704 0 3
61415: ST_TO_ADDR
// end ; end ;
61416: GO 61312
61418: POP
61419: POP
// if not lab or not mc_lab_upgrade [ i ] then
61420: LD_VAR 0 6
61424: NOT
61425: PUSH
61426: LD_EXP 57
61430: PUSH
61431: LD_VAR 0 2
61435: ARRAY
61436: NOT
61437: OR
61438: IFFALSE 61442
// continue ;
61440: GO 61212
// for j in lab do
61442: LD_ADDR_VAR 0 3
61446: PUSH
61447: LD_VAR 0 6
61451: PUSH
61452: FOR_IN
61453: IFFALSE 61618
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
61455: LD_VAR 0 3
61459: PPUSH
61460: CALL_OW 266
61464: PUSH
61465: LD_INT 6
61467: PUSH
61468: LD_INT 7
61470: PUSH
61471: EMPTY
61472: LIST
61473: LIST
61474: IN
61475: PUSH
61476: LD_VAR 0 3
61480: PPUSH
61481: CALL_OW 461
61485: PUSH
61486: LD_INT 1
61488: NONEQUAL
61489: AND
61490: IFFALSE 61616
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
61492: LD_VAR 0 3
61496: PPUSH
61497: LD_EXP 57
61501: PUSH
61502: LD_VAR 0 2
61506: ARRAY
61507: PUSH
61508: LD_INT 1
61510: ARRAY
61511: PPUSH
61512: CALL 22422 0 2
61516: IFFALSE 61616
// begin ComCancel ( j ) ;
61518: LD_VAR 0 3
61522: PPUSH
61523: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
61527: LD_VAR 0 3
61531: PPUSH
61532: LD_EXP 57
61536: PUSH
61537: LD_VAR 0 2
61541: ARRAY
61542: PUSH
61543: LD_INT 1
61545: ARRAY
61546: PPUSH
61547: CALL_OW 207
// if not j in mc_construct_list [ i ] then
61551: LD_VAR 0 3
61555: PUSH
61556: LD_EXP 30
61560: PUSH
61561: LD_VAR 0 2
61565: ARRAY
61566: IN
61567: NOT
61568: IFFALSE 61614
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
61570: LD_ADDR_EXP 30
61574: PUSH
61575: LD_EXP 30
61579: PPUSH
61580: LD_VAR 0 2
61584: PUSH
61585: LD_EXP 30
61589: PUSH
61590: LD_VAR 0 2
61594: ARRAY
61595: PUSH
61596: LD_INT 1
61598: PLUS
61599: PUSH
61600: EMPTY
61601: LIST
61602: LIST
61603: PPUSH
61604: LD_VAR 0 3
61608: PPUSH
61609: CALL 15704 0 3
61613: ST_TO_ADDR
// break ;
61614: GO 61618
// end ; end ; end ;
61616: GO 61452
61618: POP
61619: POP
// end ;
61620: GO 61212
61622: POP
61623: POP
// end ;
61624: LD_VAR 0 1
61628: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
61629: LD_INT 0
61631: PPUSH
61632: PPUSH
61633: PPUSH
61634: PPUSH
61635: PPUSH
61636: PPUSH
61637: PPUSH
61638: PPUSH
61639: PPUSH
// if not mc_bases then
61640: LD_EXP 23
61644: NOT
61645: IFFALSE 61649
// exit ;
61647: GO 62054
// for i = 1 to mc_bases do
61649: LD_ADDR_VAR 0 2
61653: PUSH
61654: DOUBLE
61655: LD_INT 1
61657: DEC
61658: ST_TO_ADDR
61659: LD_EXP 23
61663: PUSH
61664: FOR_TO
61665: IFFALSE 62052
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
61667: LD_EXP 31
61671: PUSH
61672: LD_VAR 0 2
61676: ARRAY
61677: NOT
61678: PUSH
61679: LD_EXP 23
61683: PUSH
61684: LD_VAR 0 2
61688: ARRAY
61689: PPUSH
61690: LD_INT 30
61692: PUSH
61693: LD_INT 3
61695: PUSH
61696: EMPTY
61697: LIST
61698: LIST
61699: PPUSH
61700: CALL_OW 72
61704: NOT
61705: OR
61706: IFFALSE 61710
// continue ;
61708: GO 61664
// busy := false ;
61710: LD_ADDR_VAR 0 8
61714: PUSH
61715: LD_INT 0
61717: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
61718: LD_ADDR_VAR 0 4
61722: PUSH
61723: LD_EXP 23
61727: PUSH
61728: LD_VAR 0 2
61732: ARRAY
61733: PPUSH
61734: LD_INT 30
61736: PUSH
61737: LD_INT 3
61739: PUSH
61740: EMPTY
61741: LIST
61742: LIST
61743: PPUSH
61744: CALL_OW 72
61748: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
61749: LD_ADDR_VAR 0 6
61753: PUSH
61754: LD_EXP 31
61758: PUSH
61759: LD_VAR 0 2
61763: ARRAY
61764: PPUSH
61765: LD_INT 2
61767: PUSH
61768: LD_INT 30
61770: PUSH
61771: LD_INT 32
61773: PUSH
61774: EMPTY
61775: LIST
61776: LIST
61777: PUSH
61778: LD_INT 30
61780: PUSH
61781: LD_INT 33
61783: PUSH
61784: EMPTY
61785: LIST
61786: LIST
61787: PUSH
61788: EMPTY
61789: LIST
61790: LIST
61791: LIST
61792: PPUSH
61793: CALL_OW 72
61797: ST_TO_ADDR
// if not t then
61798: LD_VAR 0 6
61802: NOT
61803: IFFALSE 61807
// continue ;
61805: GO 61664
// for j in tmp do
61807: LD_ADDR_VAR 0 3
61811: PUSH
61812: LD_VAR 0 4
61816: PUSH
61817: FOR_IN
61818: IFFALSE 61848
// if not BuildingStatus ( j ) = bs_idle then
61820: LD_VAR 0 3
61824: PPUSH
61825: CALL_OW 461
61829: PUSH
61830: LD_INT 2
61832: EQUAL
61833: NOT
61834: IFFALSE 61846
// begin busy := true ;
61836: LD_ADDR_VAR 0 8
61840: PUSH
61841: LD_INT 1
61843: ST_TO_ADDR
// break ;
61844: GO 61848
// end ;
61846: GO 61817
61848: POP
61849: POP
// if busy then
61850: LD_VAR 0 8
61854: IFFALSE 61858
// continue ;
61856: GO 61664
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
61858: LD_ADDR_VAR 0 7
61862: PUSH
61863: LD_VAR 0 6
61867: PPUSH
61868: LD_INT 35
61870: PUSH
61871: LD_INT 0
61873: PUSH
61874: EMPTY
61875: LIST
61876: LIST
61877: PPUSH
61878: CALL_OW 72
61882: ST_TO_ADDR
// if tw then
61883: LD_VAR 0 7
61887: IFFALSE 61964
// begin tw := tw [ 1 ] ;
61889: LD_ADDR_VAR 0 7
61893: PUSH
61894: LD_VAR 0 7
61898: PUSH
61899: LD_INT 1
61901: ARRAY
61902: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
61903: LD_ADDR_VAR 0 9
61907: PUSH
61908: LD_VAR 0 7
61912: PPUSH
61913: LD_EXP 48
61917: PUSH
61918: LD_VAR 0 2
61922: ARRAY
61923: PPUSH
61924: CALL 20714 0 2
61928: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
61929: LD_EXP 62
61933: PUSH
61934: LD_VAR 0 2
61938: ARRAY
61939: IFFALSE 61962
// if not weapon in mc_allowed_tower_weapons [ i ] then
61941: LD_VAR 0 9
61945: PUSH
61946: LD_EXP 62
61950: PUSH
61951: LD_VAR 0 2
61955: ARRAY
61956: IN
61957: NOT
61958: IFFALSE 61962
// continue ;
61960: GO 61664
// end else
61962: GO 62027
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
61964: LD_ADDR_VAR 0 5
61968: PUSH
61969: LD_EXP 31
61973: PUSH
61974: LD_VAR 0 2
61978: ARRAY
61979: PPUSH
61980: LD_VAR 0 4
61984: PPUSH
61985: CALL 47003 0 2
61989: ST_TO_ADDR
// if not tmp2 then
61990: LD_VAR 0 5
61994: NOT
61995: IFFALSE 61999
// continue ;
61997: GO 61664
// tw := tmp2 [ 1 ] ;
61999: LD_ADDR_VAR 0 7
62003: PUSH
62004: LD_VAR 0 5
62008: PUSH
62009: LD_INT 1
62011: ARRAY
62012: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62013: LD_ADDR_VAR 0 9
62017: PUSH
62018: LD_VAR 0 5
62022: PUSH
62023: LD_INT 2
62025: ARRAY
62026: ST_TO_ADDR
// end ; if not weapon then
62027: LD_VAR 0 9
62031: NOT
62032: IFFALSE 62036
// continue ;
62034: GO 61664
// ComPlaceWeapon ( tw , weapon ) ;
62036: LD_VAR 0 7
62040: PPUSH
62041: LD_VAR 0 9
62045: PPUSH
62046: CALL_OW 148
// end ;
62050: GO 61664
62052: POP
62053: POP
// end ;
62054: LD_VAR 0 1
62058: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
62059: LD_INT 0
62061: PPUSH
62062: PPUSH
62063: PPUSH
62064: PPUSH
62065: PPUSH
62066: PPUSH
62067: PPUSH
// if not mc_bases then
62068: LD_EXP 23
62072: NOT
62073: IFFALSE 62077
// exit ;
62075: GO 62845
// for i = 1 to mc_bases do
62077: LD_ADDR_VAR 0 2
62081: PUSH
62082: DOUBLE
62083: LD_INT 1
62085: DEC
62086: ST_TO_ADDR
62087: LD_EXP 23
62091: PUSH
62092: FOR_TO
62093: IFFALSE 62843
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62095: LD_EXP 36
62099: PUSH
62100: LD_VAR 0 2
62104: ARRAY
62105: NOT
62106: PUSH
62107: LD_EXP 36
62111: PUSH
62112: LD_VAR 0 2
62116: ARRAY
62117: PUSH
62118: LD_EXP 37
62122: PUSH
62123: LD_VAR 0 2
62127: ARRAY
62128: EQUAL
62129: OR
62130: PUSH
62131: LD_EXP 46
62135: PUSH
62136: LD_VAR 0 2
62140: ARRAY
62141: OR
62142: IFFALSE 62146
// continue ;
62144: GO 62092
// if mc_miners [ i ] then
62146: LD_EXP 37
62150: PUSH
62151: LD_VAR 0 2
62155: ARRAY
62156: IFFALSE 62530
// begin for j = mc_miners [ i ] downto 1 do
62158: LD_ADDR_VAR 0 3
62162: PUSH
62163: DOUBLE
62164: LD_EXP 37
62168: PUSH
62169: LD_VAR 0 2
62173: ARRAY
62174: INC
62175: ST_TO_ADDR
62176: LD_INT 1
62178: PUSH
62179: FOR_DOWNTO
62180: IFFALSE 62528
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62182: LD_EXP 37
62186: PUSH
62187: LD_VAR 0 2
62191: ARRAY
62192: PUSH
62193: LD_VAR 0 3
62197: ARRAY
62198: PPUSH
62199: CALL_OW 301
62203: PUSH
62204: LD_EXP 37
62208: PUSH
62209: LD_VAR 0 2
62213: ARRAY
62214: PUSH
62215: LD_VAR 0 3
62219: ARRAY
62220: PPUSH
62221: CALL_OW 257
62225: PUSH
62226: LD_INT 1
62228: NONEQUAL
62229: OR
62230: IFFALSE 62293
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62232: LD_ADDR_VAR 0 5
62236: PUSH
62237: LD_EXP 37
62241: PUSH
62242: LD_VAR 0 2
62246: ARRAY
62247: PUSH
62248: LD_EXP 37
62252: PUSH
62253: LD_VAR 0 2
62257: ARRAY
62258: PUSH
62259: LD_VAR 0 3
62263: ARRAY
62264: DIFF
62265: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
62266: LD_ADDR_EXP 37
62270: PUSH
62271: LD_EXP 37
62275: PPUSH
62276: LD_VAR 0 2
62280: PPUSH
62281: LD_VAR 0 5
62285: PPUSH
62286: CALL_OW 1
62290: ST_TO_ADDR
// continue ;
62291: GO 62179
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
62293: LD_EXP 37
62297: PUSH
62298: LD_VAR 0 2
62302: ARRAY
62303: PUSH
62304: LD_VAR 0 3
62308: ARRAY
62309: PPUSH
62310: CALL_OW 257
62314: PUSH
62315: LD_INT 1
62317: EQUAL
62318: PUSH
62319: LD_EXP 37
62323: PUSH
62324: LD_VAR 0 2
62328: ARRAY
62329: PUSH
62330: LD_VAR 0 3
62334: ARRAY
62335: PPUSH
62336: CALL_OW 459
62340: NOT
62341: AND
62342: PUSH
62343: LD_EXP 37
62347: PUSH
62348: LD_VAR 0 2
62352: ARRAY
62353: PUSH
62354: LD_VAR 0 3
62358: ARRAY
62359: PPUSH
62360: CALL_OW 314
62364: NOT
62365: AND
62366: IFFALSE 62526
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
62368: LD_EXP 37
62372: PUSH
62373: LD_VAR 0 2
62377: ARRAY
62378: PUSH
62379: LD_VAR 0 3
62383: ARRAY
62384: PPUSH
62385: CALL_OW 310
62389: IFFALSE 62412
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
62391: LD_EXP 37
62395: PUSH
62396: LD_VAR 0 2
62400: ARRAY
62401: PUSH
62402: LD_VAR 0 3
62406: ARRAY
62407: PPUSH
62408: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
62412: LD_EXP 37
62416: PUSH
62417: LD_VAR 0 2
62421: ARRAY
62422: PUSH
62423: LD_VAR 0 3
62427: ARRAY
62428: PPUSH
62429: CALL_OW 314
62433: NOT
62434: IFFALSE 62526
// begin r := rand ( 1 , mc_mines [ i ] ) ;
62436: LD_ADDR_VAR 0 7
62440: PUSH
62441: LD_INT 1
62443: PPUSH
62444: LD_EXP 36
62448: PUSH
62449: LD_VAR 0 2
62453: ARRAY
62454: PPUSH
62455: CALL_OW 12
62459: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
62460: LD_EXP 37
62464: PUSH
62465: LD_VAR 0 2
62469: ARRAY
62470: PUSH
62471: LD_VAR 0 3
62475: ARRAY
62476: PPUSH
62477: LD_EXP 36
62481: PUSH
62482: LD_VAR 0 2
62486: ARRAY
62487: PUSH
62488: LD_VAR 0 7
62492: ARRAY
62493: PUSH
62494: LD_INT 1
62496: ARRAY
62497: PPUSH
62498: LD_EXP 36
62502: PUSH
62503: LD_VAR 0 2
62507: ARRAY
62508: PUSH
62509: LD_VAR 0 7
62513: ARRAY
62514: PUSH
62515: LD_INT 2
62517: ARRAY
62518: PPUSH
62519: LD_INT 0
62521: PPUSH
62522: CALL_OW 193
// end ; end ; end ;
62526: GO 62179
62528: POP
62529: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
62530: LD_ADDR_VAR 0 5
62534: PUSH
62535: LD_EXP 23
62539: PUSH
62540: LD_VAR 0 2
62544: ARRAY
62545: PPUSH
62546: LD_INT 2
62548: PUSH
62549: LD_INT 30
62551: PUSH
62552: LD_INT 4
62554: PUSH
62555: EMPTY
62556: LIST
62557: LIST
62558: PUSH
62559: LD_INT 30
62561: PUSH
62562: LD_INT 5
62564: PUSH
62565: EMPTY
62566: LIST
62567: LIST
62568: PUSH
62569: LD_INT 30
62571: PUSH
62572: LD_INT 32
62574: PUSH
62575: EMPTY
62576: LIST
62577: LIST
62578: PUSH
62579: EMPTY
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: PPUSH
62585: CALL_OW 72
62589: ST_TO_ADDR
// if not tmp then
62590: LD_VAR 0 5
62594: NOT
62595: IFFALSE 62599
// continue ;
62597: GO 62092
// list := [ ] ;
62599: LD_ADDR_VAR 0 6
62603: PUSH
62604: EMPTY
62605: ST_TO_ADDR
// for j in tmp do
62606: LD_ADDR_VAR 0 3
62610: PUSH
62611: LD_VAR 0 5
62615: PUSH
62616: FOR_IN
62617: IFFALSE 62686
// begin for k in UnitsInside ( j ) do
62619: LD_ADDR_VAR 0 4
62623: PUSH
62624: LD_VAR 0 3
62628: PPUSH
62629: CALL_OW 313
62633: PUSH
62634: FOR_IN
62635: IFFALSE 62682
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
62637: LD_VAR 0 4
62641: PPUSH
62642: CALL_OW 257
62646: PUSH
62647: LD_INT 1
62649: EQUAL
62650: PUSH
62651: LD_VAR 0 4
62655: PPUSH
62656: CALL_OW 459
62660: NOT
62661: AND
62662: IFFALSE 62680
// list := list ^ k ;
62664: LD_ADDR_VAR 0 6
62668: PUSH
62669: LD_VAR 0 6
62673: PUSH
62674: LD_VAR 0 4
62678: ADD
62679: ST_TO_ADDR
62680: GO 62634
62682: POP
62683: POP
// end ;
62684: GO 62616
62686: POP
62687: POP
// list := list diff mc_miners [ i ] ;
62688: LD_ADDR_VAR 0 6
62692: PUSH
62693: LD_VAR 0 6
62697: PUSH
62698: LD_EXP 37
62702: PUSH
62703: LD_VAR 0 2
62707: ARRAY
62708: DIFF
62709: ST_TO_ADDR
// if not list then
62710: LD_VAR 0 6
62714: NOT
62715: IFFALSE 62719
// continue ;
62717: GO 62092
// k := mc_mines [ i ] - mc_miners [ i ] ;
62719: LD_ADDR_VAR 0 4
62723: PUSH
62724: LD_EXP 36
62728: PUSH
62729: LD_VAR 0 2
62733: ARRAY
62734: PUSH
62735: LD_EXP 37
62739: PUSH
62740: LD_VAR 0 2
62744: ARRAY
62745: MINUS
62746: ST_TO_ADDR
// if k > list then
62747: LD_VAR 0 4
62751: PUSH
62752: LD_VAR 0 6
62756: GREATER
62757: IFFALSE 62769
// k := list ;
62759: LD_ADDR_VAR 0 4
62763: PUSH
62764: LD_VAR 0 6
62768: ST_TO_ADDR
// for j = 1 to k do
62769: LD_ADDR_VAR 0 3
62773: PUSH
62774: DOUBLE
62775: LD_INT 1
62777: DEC
62778: ST_TO_ADDR
62779: LD_VAR 0 4
62783: PUSH
62784: FOR_TO
62785: IFFALSE 62839
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
62787: LD_ADDR_EXP 37
62791: PUSH
62792: LD_EXP 37
62796: PPUSH
62797: LD_VAR 0 2
62801: PUSH
62802: LD_EXP 37
62806: PUSH
62807: LD_VAR 0 2
62811: ARRAY
62812: PUSH
62813: LD_INT 1
62815: PLUS
62816: PUSH
62817: EMPTY
62818: LIST
62819: LIST
62820: PPUSH
62821: LD_VAR 0 6
62825: PUSH
62826: LD_VAR 0 3
62830: ARRAY
62831: PPUSH
62832: CALL 15704 0 3
62836: ST_TO_ADDR
62837: GO 62784
62839: POP
62840: POP
// end ;
62841: GO 62092
62843: POP
62844: POP
// end ;
62845: LD_VAR 0 1
62849: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
62850: LD_INT 0
62852: PPUSH
62853: PPUSH
62854: PPUSH
62855: PPUSH
62856: PPUSH
62857: PPUSH
62858: PPUSH
62859: PPUSH
62860: PPUSH
62861: PPUSH
62862: PPUSH
// if not mc_bases then
62863: LD_EXP 23
62867: NOT
62868: IFFALSE 62872
// exit ;
62870: GO 64695
// for i = 1 to mc_bases do
62872: LD_ADDR_VAR 0 2
62876: PUSH
62877: DOUBLE
62878: LD_INT 1
62880: DEC
62881: ST_TO_ADDR
62882: LD_EXP 23
62886: PUSH
62887: FOR_TO
62888: IFFALSE 64693
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
62890: LD_EXP 23
62894: PUSH
62895: LD_VAR 0 2
62899: ARRAY
62900: NOT
62901: PUSH
62902: LD_EXP 30
62906: PUSH
62907: LD_VAR 0 2
62911: ARRAY
62912: OR
62913: IFFALSE 62917
// continue ;
62915: GO 62887
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
62917: LD_EXP 39
62921: PUSH
62922: LD_VAR 0 2
62926: ARRAY
62927: NOT
62928: PUSH
62929: LD_EXP 40
62933: PUSH
62934: LD_VAR 0 2
62938: ARRAY
62939: AND
62940: IFFALSE 62978
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
62942: LD_ADDR_EXP 40
62946: PUSH
62947: LD_EXP 40
62951: PPUSH
62952: LD_VAR 0 2
62956: PPUSH
62957: EMPTY
62958: PPUSH
62959: CALL_OW 1
62963: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
62964: LD_VAR 0 2
62968: PPUSH
62969: LD_INT 107
62971: PPUSH
62972: CALL 53746 0 2
// continue ;
62976: GO 62887
// end ; target := [ ] ;
62978: LD_ADDR_VAR 0 7
62982: PUSH
62983: EMPTY
62984: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
62985: LD_ADDR_VAR 0 6
62989: PUSH
62990: LD_EXP 23
62994: PUSH
62995: LD_VAR 0 2
62999: ARRAY
63000: PUSH
63001: LD_INT 1
63003: ARRAY
63004: PPUSH
63005: CALL_OW 255
63009: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63010: LD_ADDR_VAR 0 9
63014: PUSH
63015: LD_EXP 23
63019: PUSH
63020: LD_VAR 0 2
63024: ARRAY
63025: PPUSH
63026: LD_INT 2
63028: PUSH
63029: LD_INT 30
63031: PUSH
63032: LD_INT 0
63034: PUSH
63035: EMPTY
63036: LIST
63037: LIST
63038: PUSH
63039: LD_INT 30
63041: PUSH
63042: LD_INT 1
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: PUSH
63049: EMPTY
63050: LIST
63051: LIST
63052: LIST
63053: PPUSH
63054: CALL_OW 72
63058: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63059: LD_ADDR_VAR 0 3
63063: PUSH
63064: DOUBLE
63065: LD_EXP 39
63069: PUSH
63070: LD_VAR 0 2
63074: ARRAY
63075: INC
63076: ST_TO_ADDR
63077: LD_INT 1
63079: PUSH
63080: FOR_DOWNTO
63081: IFFALSE 63326
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63083: LD_EXP 39
63087: PUSH
63088: LD_VAR 0 2
63092: ARRAY
63093: PUSH
63094: LD_VAR 0 3
63098: ARRAY
63099: PUSH
63100: LD_INT 2
63102: ARRAY
63103: PPUSH
63104: LD_EXP 39
63108: PUSH
63109: LD_VAR 0 2
63113: ARRAY
63114: PUSH
63115: LD_VAR 0 3
63119: ARRAY
63120: PUSH
63121: LD_INT 3
63123: ARRAY
63124: PPUSH
63125: CALL_OW 488
63129: PUSH
63130: LD_EXP 39
63134: PUSH
63135: LD_VAR 0 2
63139: ARRAY
63140: PUSH
63141: LD_VAR 0 3
63145: ARRAY
63146: PUSH
63147: LD_INT 2
63149: ARRAY
63150: PPUSH
63151: LD_EXP 39
63155: PUSH
63156: LD_VAR 0 2
63160: ARRAY
63161: PUSH
63162: LD_VAR 0 3
63166: ARRAY
63167: PUSH
63168: LD_INT 3
63170: ARRAY
63171: PPUSH
63172: CALL_OW 284
63176: PUSH
63177: LD_INT 0
63179: EQUAL
63180: AND
63181: IFFALSE 63236
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63183: LD_ADDR_VAR 0 5
63187: PUSH
63188: LD_EXP 39
63192: PUSH
63193: LD_VAR 0 2
63197: ARRAY
63198: PPUSH
63199: LD_VAR 0 3
63203: PPUSH
63204: CALL_OW 3
63208: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63209: LD_ADDR_EXP 39
63213: PUSH
63214: LD_EXP 39
63218: PPUSH
63219: LD_VAR 0 2
63223: PPUSH
63224: LD_VAR 0 5
63228: PPUSH
63229: CALL_OW 1
63233: ST_TO_ADDR
// continue ;
63234: GO 63080
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63236: LD_VAR 0 6
63240: PPUSH
63241: LD_EXP 39
63245: PUSH
63246: LD_VAR 0 2
63250: ARRAY
63251: PUSH
63252: LD_VAR 0 3
63256: ARRAY
63257: PUSH
63258: LD_INT 2
63260: ARRAY
63261: PPUSH
63262: LD_EXP 39
63266: PUSH
63267: LD_VAR 0 2
63271: ARRAY
63272: PUSH
63273: LD_VAR 0 3
63277: ARRAY
63278: PUSH
63279: LD_INT 3
63281: ARRAY
63282: PPUSH
63283: LD_INT 30
63285: PPUSH
63286: CALL 16600 0 4
63290: PUSH
63291: LD_INT 4
63293: ARRAY
63294: PUSH
63295: LD_INT 0
63297: EQUAL
63298: IFFALSE 63324
// begin target := mc_crates [ i ] [ j ] ;
63300: LD_ADDR_VAR 0 7
63304: PUSH
63305: LD_EXP 39
63309: PUSH
63310: LD_VAR 0 2
63314: ARRAY
63315: PUSH
63316: LD_VAR 0 3
63320: ARRAY
63321: ST_TO_ADDR
// break ;
63322: GO 63326
// end ; end ;
63324: GO 63080
63326: POP
63327: POP
// if not target then
63328: LD_VAR 0 7
63332: NOT
63333: IFFALSE 63337
// continue ;
63335: GO 62887
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
63337: LD_ADDR_VAR 0 8
63341: PUSH
63342: LD_EXP 42
63346: PUSH
63347: LD_VAR 0 2
63351: ARRAY
63352: PPUSH
63353: LD_INT 2
63355: PUSH
63356: LD_INT 3
63358: PUSH
63359: LD_INT 58
63361: PUSH
63362: EMPTY
63363: LIST
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: PUSH
63369: LD_INT 61
63371: PUSH
63372: EMPTY
63373: LIST
63374: PUSH
63375: LD_INT 33
63377: PUSH
63378: LD_INT 5
63380: PUSH
63381: EMPTY
63382: LIST
63383: LIST
63384: PUSH
63385: LD_INT 33
63387: PUSH
63388: LD_INT 3
63390: PUSH
63391: EMPTY
63392: LIST
63393: LIST
63394: PUSH
63395: EMPTY
63396: LIST
63397: LIST
63398: LIST
63399: LIST
63400: LIST
63401: PUSH
63402: LD_INT 2
63404: PUSH
63405: LD_INT 34
63407: PUSH
63408: LD_INT 32
63410: PUSH
63411: EMPTY
63412: LIST
63413: LIST
63414: PUSH
63415: LD_INT 34
63417: PUSH
63418: LD_INT 51
63420: PUSH
63421: EMPTY
63422: LIST
63423: LIST
63424: PUSH
63425: LD_INT 34
63427: PUSH
63428: LD_INT 12
63430: PUSH
63431: EMPTY
63432: LIST
63433: LIST
63434: PUSH
63435: EMPTY
63436: LIST
63437: LIST
63438: LIST
63439: LIST
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: PPUSH
63445: CALL_OW 72
63449: ST_TO_ADDR
// if not cargo then
63450: LD_VAR 0 8
63454: NOT
63455: IFFALSE 64161
// begin if mc_crates_collector [ i ] < 5 then
63457: LD_EXP 40
63461: PUSH
63462: LD_VAR 0 2
63466: ARRAY
63467: PUSH
63468: LD_INT 5
63470: LESS
63471: IFFALSE 63837
// begin if mc_ape [ i ] then
63473: LD_EXP 52
63477: PUSH
63478: LD_VAR 0 2
63482: ARRAY
63483: IFFALSE 63530
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
63485: LD_ADDR_VAR 0 5
63489: PUSH
63490: LD_EXP 52
63494: PUSH
63495: LD_VAR 0 2
63499: ARRAY
63500: PPUSH
63501: LD_INT 25
63503: PUSH
63504: LD_INT 16
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 24
63513: PUSH
63514: LD_INT 750
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: EMPTY
63522: LIST
63523: LIST
63524: PPUSH
63525: CALL_OW 72
63529: ST_TO_ADDR
// if not tmp then
63530: LD_VAR 0 5
63534: NOT
63535: IFFALSE 63582
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
63537: LD_ADDR_VAR 0 5
63541: PUSH
63542: LD_EXP 23
63546: PUSH
63547: LD_VAR 0 2
63551: ARRAY
63552: PPUSH
63553: LD_INT 25
63555: PUSH
63556: LD_INT 2
63558: PUSH
63559: EMPTY
63560: LIST
63561: LIST
63562: PUSH
63563: LD_INT 24
63565: PUSH
63566: LD_INT 750
63568: PUSH
63569: EMPTY
63570: LIST
63571: LIST
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PPUSH
63577: CALL_OW 72
63581: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
63582: LD_EXP 52
63586: PUSH
63587: LD_VAR 0 2
63591: ARRAY
63592: PUSH
63593: LD_EXP 23
63597: PUSH
63598: LD_VAR 0 2
63602: ARRAY
63603: PPUSH
63604: LD_INT 25
63606: PUSH
63607: LD_INT 2
63609: PUSH
63610: EMPTY
63611: LIST
63612: LIST
63613: PUSH
63614: LD_INT 24
63616: PUSH
63617: LD_INT 750
63619: PUSH
63620: EMPTY
63621: LIST
63622: LIST
63623: PUSH
63624: EMPTY
63625: LIST
63626: LIST
63627: PPUSH
63628: CALL_OW 72
63632: AND
63633: PUSH
63634: LD_VAR 0 5
63638: PUSH
63639: LD_INT 5
63641: LESS
63642: AND
63643: IFFALSE 63725
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
63645: LD_ADDR_VAR 0 3
63649: PUSH
63650: LD_EXP 23
63654: PUSH
63655: LD_VAR 0 2
63659: ARRAY
63660: PPUSH
63661: LD_INT 25
63663: PUSH
63664: LD_INT 2
63666: PUSH
63667: EMPTY
63668: LIST
63669: LIST
63670: PUSH
63671: LD_INT 24
63673: PUSH
63674: LD_INT 750
63676: PUSH
63677: EMPTY
63678: LIST
63679: LIST
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: PPUSH
63685: CALL_OW 72
63689: PUSH
63690: FOR_IN
63691: IFFALSE 63723
// begin tmp := tmp union j ;
63693: LD_ADDR_VAR 0 5
63697: PUSH
63698: LD_VAR 0 5
63702: PUSH
63703: LD_VAR 0 3
63707: UNION
63708: ST_TO_ADDR
// if tmp >= 5 then
63709: LD_VAR 0 5
63713: PUSH
63714: LD_INT 5
63716: GREATEREQUAL
63717: IFFALSE 63721
// break ;
63719: GO 63723
// end ;
63721: GO 63690
63723: POP
63724: POP
// end ; if not tmp then
63725: LD_VAR 0 5
63729: NOT
63730: IFFALSE 63734
// continue ;
63732: GO 62887
// for j in tmp do
63734: LD_ADDR_VAR 0 3
63738: PUSH
63739: LD_VAR 0 5
63743: PUSH
63744: FOR_IN
63745: IFFALSE 63835
// if not GetTag ( j ) then
63747: LD_VAR 0 3
63751: PPUSH
63752: CALL_OW 110
63756: NOT
63757: IFFALSE 63833
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
63759: LD_ADDR_EXP 40
63763: PUSH
63764: LD_EXP 40
63768: PPUSH
63769: LD_VAR 0 2
63773: PUSH
63774: LD_EXP 40
63778: PUSH
63779: LD_VAR 0 2
63783: ARRAY
63784: PUSH
63785: LD_INT 1
63787: PLUS
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: PPUSH
63793: LD_VAR 0 3
63797: PPUSH
63798: CALL 15704 0 3
63802: ST_TO_ADDR
// SetTag ( j , 107 ) ;
63803: LD_VAR 0 3
63807: PPUSH
63808: LD_INT 107
63810: PPUSH
63811: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
63815: LD_EXP 40
63819: PUSH
63820: LD_VAR 0 2
63824: ARRAY
63825: PUSH
63826: LD_INT 5
63828: GREATEREQUAL
63829: IFFALSE 63833
// break ;
63831: GO 63835
// end ;
63833: GO 63744
63835: POP
63836: POP
// end ; if mc_crates_collector [ i ] and target then
63837: LD_EXP 40
63841: PUSH
63842: LD_VAR 0 2
63846: ARRAY
63847: PUSH
63848: LD_VAR 0 7
63852: AND
63853: IFFALSE 64159
// begin if mc_crates_collector [ i ] < target [ 1 ] then
63855: LD_EXP 40
63859: PUSH
63860: LD_VAR 0 2
63864: ARRAY
63865: PUSH
63866: LD_VAR 0 7
63870: PUSH
63871: LD_INT 1
63873: ARRAY
63874: LESS
63875: IFFALSE 63895
// tmp := mc_crates_collector [ i ] else
63877: LD_ADDR_VAR 0 5
63881: PUSH
63882: LD_EXP 40
63886: PUSH
63887: LD_VAR 0 2
63891: ARRAY
63892: ST_TO_ADDR
63893: GO 63909
// tmp := target [ 1 ] ;
63895: LD_ADDR_VAR 0 5
63899: PUSH
63900: LD_VAR 0 7
63904: PUSH
63905: LD_INT 1
63907: ARRAY
63908: ST_TO_ADDR
// k := 0 ;
63909: LD_ADDR_VAR 0 4
63913: PUSH
63914: LD_INT 0
63916: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
63917: LD_ADDR_VAR 0 3
63921: PUSH
63922: LD_EXP 40
63926: PUSH
63927: LD_VAR 0 2
63931: ARRAY
63932: PUSH
63933: FOR_IN
63934: IFFALSE 64157
// begin k := k + 1 ;
63936: LD_ADDR_VAR 0 4
63940: PUSH
63941: LD_VAR 0 4
63945: PUSH
63946: LD_INT 1
63948: PLUS
63949: ST_TO_ADDR
// if k > tmp then
63950: LD_VAR 0 4
63954: PUSH
63955: LD_VAR 0 5
63959: GREATER
63960: IFFALSE 63964
// break ;
63962: GO 64157
// if not GetClass ( j ) in [ 2 , 16 ] then
63964: LD_VAR 0 3
63968: PPUSH
63969: CALL_OW 257
63973: PUSH
63974: LD_INT 2
63976: PUSH
63977: LD_INT 16
63979: PUSH
63980: EMPTY
63981: LIST
63982: LIST
63983: IN
63984: NOT
63985: IFFALSE 64038
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
63987: LD_ADDR_EXP 40
63991: PUSH
63992: LD_EXP 40
63996: PPUSH
63997: LD_VAR 0 2
64001: PPUSH
64002: LD_EXP 40
64006: PUSH
64007: LD_VAR 0 2
64011: ARRAY
64012: PUSH
64013: LD_VAR 0 3
64017: DIFF
64018: PPUSH
64019: CALL_OW 1
64023: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64024: LD_VAR 0 3
64028: PPUSH
64029: LD_INT 0
64031: PPUSH
64032: CALL_OW 109
// continue ;
64036: GO 63933
// end ; if IsInUnit ( j ) then
64038: LD_VAR 0 3
64042: PPUSH
64043: CALL_OW 310
64047: IFFALSE 64058
// ComExitBuilding ( j ) ;
64049: LD_VAR 0 3
64053: PPUSH
64054: CALL_OW 122
// wait ( 3 ) ;
64058: LD_INT 3
64060: PPUSH
64061: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
64065: LD_VAR 0 3
64069: PPUSH
64070: CALL_OW 314
64074: PUSH
64075: LD_VAR 0 6
64079: PPUSH
64080: LD_VAR 0 7
64084: PUSH
64085: LD_INT 2
64087: ARRAY
64088: PPUSH
64089: LD_VAR 0 7
64093: PUSH
64094: LD_INT 3
64096: ARRAY
64097: PPUSH
64098: LD_INT 30
64100: PPUSH
64101: CALL 16600 0 4
64105: PUSH
64106: LD_INT 4
64108: ARRAY
64109: AND
64110: IFFALSE 64128
// ComStandNearbyBuilding ( j , depot ) else
64112: LD_VAR 0 3
64116: PPUSH
64117: LD_VAR 0 9
64121: PPUSH
64122: CALL 12282 0 2
64126: GO 64155
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64128: LD_VAR 0 3
64132: PPUSH
64133: LD_VAR 0 7
64137: PUSH
64138: LD_INT 2
64140: ARRAY
64141: PPUSH
64142: LD_VAR 0 7
64146: PUSH
64147: LD_INT 3
64149: ARRAY
64150: PPUSH
64151: CALL_OW 117
// end ;
64155: GO 63933
64157: POP
64158: POP
// end ; end else
64159: GO 64691
// begin for j in cargo do
64161: LD_ADDR_VAR 0 3
64165: PUSH
64166: LD_VAR 0 8
64170: PUSH
64171: FOR_IN
64172: IFFALSE 64689
// begin if GetTag ( j ) <> 0 then
64174: LD_VAR 0 3
64178: PPUSH
64179: CALL_OW 110
64183: PUSH
64184: LD_INT 0
64186: NONEQUAL
64187: IFFALSE 64191
// continue ;
64189: GO 64171
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64191: LD_VAR 0 3
64195: PPUSH
64196: CALL_OW 256
64200: PUSH
64201: LD_INT 1000
64203: LESS
64204: PUSH
64205: LD_VAR 0 3
64209: PPUSH
64210: LD_EXP 47
64214: PUSH
64215: LD_VAR 0 2
64219: ARRAY
64220: PPUSH
64221: CALL_OW 308
64225: NOT
64226: AND
64227: IFFALSE 64249
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64229: LD_VAR 0 3
64233: PPUSH
64234: LD_EXP 47
64238: PUSH
64239: LD_VAR 0 2
64243: ARRAY
64244: PPUSH
64245: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64249: LD_VAR 0 3
64253: PPUSH
64254: CALL_OW 256
64258: PUSH
64259: LD_INT 1000
64261: LESS
64262: PUSH
64263: LD_VAR 0 3
64267: PPUSH
64268: LD_EXP 47
64272: PUSH
64273: LD_VAR 0 2
64277: ARRAY
64278: PPUSH
64279: CALL_OW 308
64283: AND
64284: IFFALSE 64288
// continue ;
64286: GO 64171
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64288: LD_VAR 0 3
64292: PPUSH
64293: CALL_OW 262
64297: PUSH
64298: LD_INT 2
64300: EQUAL
64301: PUSH
64302: LD_VAR 0 3
64306: PPUSH
64307: CALL_OW 261
64311: PUSH
64312: LD_INT 15
64314: LESS
64315: AND
64316: IFFALSE 64320
// continue ;
64318: GO 64171
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64320: LD_VAR 0 3
64324: PPUSH
64325: CALL_OW 262
64329: PUSH
64330: LD_INT 1
64332: EQUAL
64333: PUSH
64334: LD_VAR 0 3
64338: PPUSH
64339: CALL_OW 261
64343: PUSH
64344: LD_INT 10
64346: LESS
64347: AND
64348: IFFALSE 64628
// begin if not depot then
64350: LD_VAR 0 9
64354: NOT
64355: IFFALSE 64359
// continue ;
64357: GO 64171
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
64359: LD_VAR 0 3
64363: PPUSH
64364: LD_VAR 0 9
64368: PPUSH
64369: LD_VAR 0 3
64373: PPUSH
64374: CALL_OW 74
64378: PPUSH
64379: CALL_OW 296
64383: PUSH
64384: LD_INT 6
64386: LESS
64387: IFFALSE 64403
// SetFuel ( j , 100 ) else
64389: LD_VAR 0 3
64393: PPUSH
64394: LD_INT 100
64396: PPUSH
64397: CALL_OW 240
64401: GO 64628
// if GetFuel ( j ) = 0 then
64403: LD_VAR 0 3
64407: PPUSH
64408: CALL_OW 261
64412: PUSH
64413: LD_INT 0
64415: EQUAL
64416: IFFALSE 64628
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
64418: LD_ADDR_EXP 42
64422: PUSH
64423: LD_EXP 42
64427: PPUSH
64428: LD_VAR 0 2
64432: PPUSH
64433: LD_EXP 42
64437: PUSH
64438: LD_VAR 0 2
64442: ARRAY
64443: PUSH
64444: LD_VAR 0 3
64448: DIFF
64449: PPUSH
64450: CALL_OW 1
64454: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
64455: LD_VAR 0 3
64459: PPUSH
64460: CALL_OW 263
64464: PUSH
64465: LD_INT 1
64467: EQUAL
64468: IFFALSE 64484
// ComExitVehicle ( IsInUnit ( j ) ) ;
64470: LD_VAR 0 3
64474: PPUSH
64475: CALL_OW 310
64479: PPUSH
64480: CALL_OW 121
// if GetControl ( j ) = control_remote then
64484: LD_VAR 0 3
64488: PPUSH
64489: CALL_OW 263
64493: PUSH
64494: LD_INT 2
64496: EQUAL
64497: IFFALSE 64508
// ComUnlink ( j ) ;
64499: LD_VAR 0 3
64503: PPUSH
64504: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
64508: LD_ADDR_VAR 0 10
64512: PUSH
64513: LD_VAR 0 2
64517: PPUSH
64518: LD_INT 3
64520: PPUSH
64521: CALL 74120 0 2
64525: ST_TO_ADDR
// if fac then
64526: LD_VAR 0 10
64530: IFFALSE 64626
// begin for k in fac do
64532: LD_ADDR_VAR 0 4
64536: PUSH
64537: LD_VAR 0 10
64541: PUSH
64542: FOR_IN
64543: IFFALSE 64624
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
64545: LD_ADDR_VAR 0 11
64549: PUSH
64550: LD_VAR 0 10
64554: PPUSH
64555: LD_VAR 0 3
64559: PPUSH
64560: CALL_OW 265
64564: PPUSH
64565: LD_VAR 0 3
64569: PPUSH
64570: CALL_OW 262
64574: PPUSH
64575: LD_VAR 0 3
64579: PPUSH
64580: CALL_OW 263
64584: PPUSH
64585: LD_VAR 0 3
64589: PPUSH
64590: CALL_OW 264
64594: PPUSH
64595: CALL 13200 0 5
64599: ST_TO_ADDR
// if components then
64600: LD_VAR 0 11
64604: IFFALSE 64622
// begin MC_InsertProduceList ( i , components ) ;
64606: LD_VAR 0 2
64610: PPUSH
64611: LD_VAR 0 11
64615: PPUSH
64616: CALL 73665 0 2
// break ;
64620: GO 64624
// end ; end ;
64622: GO 64542
64624: POP
64625: POP
// end ; continue ;
64626: GO 64171
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
64628: LD_VAR 0 3
64632: PPUSH
64633: LD_INT 1
64635: PPUSH
64636: CALL_OW 289
64640: PUSH
64641: LD_INT 100
64643: LESS
64644: PUSH
64645: LD_VAR 0 3
64649: PPUSH
64650: CALL_OW 314
64654: NOT
64655: AND
64656: IFFALSE 64685
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64658: LD_VAR 0 3
64662: PPUSH
64663: LD_VAR 0 7
64667: PUSH
64668: LD_INT 2
64670: ARRAY
64671: PPUSH
64672: LD_VAR 0 7
64676: PUSH
64677: LD_INT 3
64679: ARRAY
64680: PPUSH
64681: CALL_OW 117
// break ;
64685: GO 64689
// end ;
64687: GO 64171
64689: POP
64690: POP
// end ; end ;
64691: GO 62887
64693: POP
64694: POP
// end ;
64695: LD_VAR 0 1
64699: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
64700: LD_INT 0
64702: PPUSH
64703: PPUSH
64704: PPUSH
64705: PPUSH
// if not mc_bases then
64706: LD_EXP 23
64710: NOT
64711: IFFALSE 64715
// exit ;
64713: GO 64876
// for i = 1 to mc_bases do
64715: LD_ADDR_VAR 0 2
64719: PUSH
64720: DOUBLE
64721: LD_INT 1
64723: DEC
64724: ST_TO_ADDR
64725: LD_EXP 23
64729: PUSH
64730: FOR_TO
64731: IFFALSE 64874
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
64733: LD_ADDR_VAR 0 4
64737: PUSH
64738: LD_EXP 42
64742: PUSH
64743: LD_VAR 0 2
64747: ARRAY
64748: PUSH
64749: LD_EXP 45
64753: PUSH
64754: LD_VAR 0 2
64758: ARRAY
64759: UNION
64760: PPUSH
64761: LD_INT 33
64763: PUSH
64764: LD_INT 2
64766: PUSH
64767: EMPTY
64768: LIST
64769: LIST
64770: PPUSH
64771: CALL_OW 72
64775: ST_TO_ADDR
// if tmp then
64776: LD_VAR 0 4
64780: IFFALSE 64872
// for j in tmp do
64782: LD_ADDR_VAR 0 3
64786: PUSH
64787: LD_VAR 0 4
64791: PUSH
64792: FOR_IN
64793: IFFALSE 64870
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
64795: LD_VAR 0 3
64799: PPUSH
64800: CALL_OW 312
64804: NOT
64805: PUSH
64806: LD_VAR 0 3
64810: PPUSH
64811: CALL_OW 256
64815: PUSH
64816: LD_INT 250
64818: GREATEREQUAL
64819: AND
64820: IFFALSE 64833
// Connect ( j ) else
64822: LD_VAR 0 3
64826: PPUSH
64827: CALL 18675 0 1
64831: GO 64868
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
64833: LD_VAR 0 3
64837: PPUSH
64838: CALL_OW 256
64842: PUSH
64843: LD_INT 250
64845: LESS
64846: PUSH
64847: LD_VAR 0 3
64851: PPUSH
64852: CALL_OW 312
64856: AND
64857: IFFALSE 64868
// ComUnlink ( j ) ;
64859: LD_VAR 0 3
64863: PPUSH
64864: CALL_OW 136
64868: GO 64792
64870: POP
64871: POP
// end ;
64872: GO 64730
64874: POP
64875: POP
// end ;
64876: LD_VAR 0 1
64880: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
64881: LD_INT 0
64883: PPUSH
64884: PPUSH
64885: PPUSH
64886: PPUSH
64887: PPUSH
// if not mc_bases then
64888: LD_EXP 23
64892: NOT
64893: IFFALSE 64897
// exit ;
64895: GO 65342
// for i = 1 to mc_bases do
64897: LD_ADDR_VAR 0 2
64901: PUSH
64902: DOUBLE
64903: LD_INT 1
64905: DEC
64906: ST_TO_ADDR
64907: LD_EXP 23
64911: PUSH
64912: FOR_TO
64913: IFFALSE 65340
// begin if not mc_produce [ i ] then
64915: LD_EXP 44
64919: PUSH
64920: LD_VAR 0 2
64924: ARRAY
64925: NOT
64926: IFFALSE 64930
// continue ;
64928: GO 64912
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64930: LD_ADDR_VAR 0 5
64934: PUSH
64935: LD_EXP 23
64939: PUSH
64940: LD_VAR 0 2
64944: ARRAY
64945: PPUSH
64946: LD_INT 30
64948: PUSH
64949: LD_INT 3
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PPUSH
64956: CALL_OW 72
64960: ST_TO_ADDR
// if not fac then
64961: LD_VAR 0 5
64965: NOT
64966: IFFALSE 64970
// continue ;
64968: GO 64912
// for j in fac do
64970: LD_ADDR_VAR 0 3
64974: PUSH
64975: LD_VAR 0 5
64979: PUSH
64980: FOR_IN
64981: IFFALSE 65336
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
64983: LD_VAR 0 3
64987: PPUSH
64988: CALL_OW 461
64992: PUSH
64993: LD_INT 2
64995: NONEQUAL
64996: PUSH
64997: LD_VAR 0 3
65001: PPUSH
65002: LD_INT 15
65004: PPUSH
65005: CALL 18303 0 2
65009: PUSH
65010: LD_INT 4
65012: ARRAY
65013: OR
65014: IFFALSE 65018
// continue ;
65016: GO 64980
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65018: LD_VAR 0 3
65022: PPUSH
65023: LD_EXP 44
65027: PUSH
65028: LD_VAR 0 2
65032: ARRAY
65033: PUSH
65034: LD_INT 1
65036: ARRAY
65037: PUSH
65038: LD_INT 1
65040: ARRAY
65041: PPUSH
65042: LD_EXP 44
65046: PUSH
65047: LD_VAR 0 2
65051: ARRAY
65052: PUSH
65053: LD_INT 1
65055: ARRAY
65056: PUSH
65057: LD_INT 2
65059: ARRAY
65060: PPUSH
65061: LD_EXP 44
65065: PUSH
65066: LD_VAR 0 2
65070: ARRAY
65071: PUSH
65072: LD_INT 1
65074: ARRAY
65075: PUSH
65076: LD_INT 3
65078: ARRAY
65079: PPUSH
65080: LD_EXP 44
65084: PUSH
65085: LD_VAR 0 2
65089: ARRAY
65090: PUSH
65091: LD_INT 1
65093: ARRAY
65094: PUSH
65095: LD_INT 4
65097: ARRAY
65098: PPUSH
65099: CALL_OW 448
65103: PUSH
65104: LD_VAR 0 3
65108: PPUSH
65109: LD_EXP 44
65113: PUSH
65114: LD_VAR 0 2
65118: ARRAY
65119: PUSH
65120: LD_INT 1
65122: ARRAY
65123: PUSH
65124: LD_INT 1
65126: ARRAY
65127: PUSH
65128: LD_EXP 44
65132: PUSH
65133: LD_VAR 0 2
65137: ARRAY
65138: PUSH
65139: LD_INT 1
65141: ARRAY
65142: PUSH
65143: LD_INT 2
65145: ARRAY
65146: PUSH
65147: LD_EXP 44
65151: PUSH
65152: LD_VAR 0 2
65156: ARRAY
65157: PUSH
65158: LD_INT 1
65160: ARRAY
65161: PUSH
65162: LD_INT 3
65164: ARRAY
65165: PUSH
65166: LD_EXP 44
65170: PUSH
65171: LD_VAR 0 2
65175: ARRAY
65176: PUSH
65177: LD_INT 1
65179: ARRAY
65180: PUSH
65181: LD_INT 4
65183: ARRAY
65184: PUSH
65185: EMPTY
65186: LIST
65187: LIST
65188: LIST
65189: LIST
65190: PPUSH
65191: CALL 22070 0 2
65195: AND
65196: IFFALSE 65334
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65198: LD_VAR 0 3
65202: PPUSH
65203: LD_EXP 44
65207: PUSH
65208: LD_VAR 0 2
65212: ARRAY
65213: PUSH
65214: LD_INT 1
65216: ARRAY
65217: PUSH
65218: LD_INT 1
65220: ARRAY
65221: PPUSH
65222: LD_EXP 44
65226: PUSH
65227: LD_VAR 0 2
65231: ARRAY
65232: PUSH
65233: LD_INT 1
65235: ARRAY
65236: PUSH
65237: LD_INT 2
65239: ARRAY
65240: PPUSH
65241: LD_EXP 44
65245: PUSH
65246: LD_VAR 0 2
65250: ARRAY
65251: PUSH
65252: LD_INT 1
65254: ARRAY
65255: PUSH
65256: LD_INT 3
65258: ARRAY
65259: PPUSH
65260: LD_EXP 44
65264: PUSH
65265: LD_VAR 0 2
65269: ARRAY
65270: PUSH
65271: LD_INT 1
65273: ARRAY
65274: PUSH
65275: LD_INT 4
65277: ARRAY
65278: PPUSH
65279: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65283: LD_ADDR_VAR 0 4
65287: PUSH
65288: LD_EXP 44
65292: PUSH
65293: LD_VAR 0 2
65297: ARRAY
65298: PPUSH
65299: LD_INT 1
65301: PPUSH
65302: CALL_OW 3
65306: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65307: LD_ADDR_EXP 44
65311: PUSH
65312: LD_EXP 44
65316: PPUSH
65317: LD_VAR 0 2
65321: PPUSH
65322: LD_VAR 0 4
65326: PPUSH
65327: CALL_OW 1
65331: ST_TO_ADDR
// break ;
65332: GO 65336
// end ; end ;
65334: GO 64980
65336: POP
65337: POP
// end ;
65338: GO 64912
65340: POP
65341: POP
// end ;
65342: LD_VAR 0 1
65346: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
65347: LD_INT 0
65349: PPUSH
65350: PPUSH
65351: PPUSH
// if not mc_bases then
65352: LD_EXP 23
65356: NOT
65357: IFFALSE 65361
// exit ;
65359: GO 65450
// for i = 1 to mc_bases do
65361: LD_ADDR_VAR 0 2
65365: PUSH
65366: DOUBLE
65367: LD_INT 1
65369: DEC
65370: ST_TO_ADDR
65371: LD_EXP 23
65375: PUSH
65376: FOR_TO
65377: IFFALSE 65448
// begin if mc_attack [ i ] then
65379: LD_EXP 43
65383: PUSH
65384: LD_VAR 0 2
65388: ARRAY
65389: IFFALSE 65446
// begin tmp := mc_attack [ i ] [ 1 ] ;
65391: LD_ADDR_VAR 0 3
65395: PUSH
65396: LD_EXP 43
65400: PUSH
65401: LD_VAR 0 2
65405: ARRAY
65406: PUSH
65407: LD_INT 1
65409: ARRAY
65410: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
65411: LD_ADDR_EXP 43
65415: PUSH
65416: LD_EXP 43
65420: PPUSH
65421: LD_VAR 0 2
65425: PPUSH
65426: EMPTY
65427: PPUSH
65428: CALL_OW 1
65432: ST_TO_ADDR
// Attack ( tmp ) ;
65433: LD_VAR 0 3
65437: PPUSH
65438: CALL 80239 0 1
// exit ;
65442: POP
65443: POP
65444: GO 65450
// end ; end ;
65446: GO 65376
65448: POP
65449: POP
// end ;
65450: LD_VAR 0 1
65454: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
65455: LD_INT 0
65457: PPUSH
65458: PPUSH
65459: PPUSH
65460: PPUSH
65461: PPUSH
65462: PPUSH
65463: PPUSH
// if not mc_bases then
65464: LD_EXP 23
65468: NOT
65469: IFFALSE 65473
// exit ;
65471: GO 66183
// for i = 1 to mc_bases do
65473: LD_ADDR_VAR 0 2
65477: PUSH
65478: DOUBLE
65479: LD_INT 1
65481: DEC
65482: ST_TO_ADDR
65483: LD_EXP 23
65487: PUSH
65488: FOR_TO
65489: IFFALSE 66181
// begin if not mc_bases [ i ] then
65491: LD_EXP 23
65495: PUSH
65496: LD_VAR 0 2
65500: ARRAY
65501: NOT
65502: IFFALSE 65506
// continue ;
65504: GO 65488
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
65506: LD_ADDR_VAR 0 7
65510: PUSH
65511: LD_EXP 23
65515: PUSH
65516: LD_VAR 0 2
65520: ARRAY
65521: PUSH
65522: LD_INT 1
65524: ARRAY
65525: PPUSH
65526: CALL 12504 0 1
65530: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
65531: LD_ADDR_EXP 46
65535: PUSH
65536: LD_EXP 46
65540: PPUSH
65541: LD_VAR 0 2
65545: PPUSH
65546: LD_EXP 23
65550: PUSH
65551: LD_VAR 0 2
65555: ARRAY
65556: PUSH
65557: LD_INT 1
65559: ARRAY
65560: PPUSH
65561: CALL_OW 255
65565: PPUSH
65566: LD_EXP 48
65570: PUSH
65571: LD_VAR 0 2
65575: ARRAY
65576: PPUSH
65577: CALL 12469 0 2
65581: PPUSH
65582: CALL_OW 1
65586: ST_TO_ADDR
// if not mc_scan [ i ] then
65587: LD_EXP 46
65591: PUSH
65592: LD_VAR 0 2
65596: ARRAY
65597: NOT
65598: IFFALSE 65776
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
65600: LD_ADDR_EXP 66
65604: PUSH
65605: LD_EXP 66
65609: PPUSH
65610: LD_VAR 0 2
65614: PPUSH
65615: LD_INT 0
65617: PPUSH
65618: CALL_OW 1
65622: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65623: LD_ADDR_VAR 0 4
65627: PUSH
65628: LD_EXP 23
65632: PUSH
65633: LD_VAR 0 2
65637: ARRAY
65638: PPUSH
65639: LD_INT 2
65641: PUSH
65642: LD_INT 25
65644: PUSH
65645: LD_INT 5
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 25
65654: PUSH
65655: LD_INT 8
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 25
65664: PUSH
65665: LD_INT 9
65667: PUSH
65668: EMPTY
65669: LIST
65670: LIST
65671: PUSH
65672: EMPTY
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: PPUSH
65678: CALL_OW 72
65682: ST_TO_ADDR
// if not tmp then
65683: LD_VAR 0 4
65687: NOT
65688: IFFALSE 65692
// continue ;
65690: GO 65488
// for j in tmp do
65692: LD_ADDR_VAR 0 3
65696: PUSH
65697: LD_VAR 0 4
65701: PUSH
65702: FOR_IN
65703: IFFALSE 65774
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
65705: LD_VAR 0 3
65709: PPUSH
65710: CALL_OW 310
65714: PPUSH
65715: CALL_OW 266
65719: PUSH
65720: LD_INT 5
65722: EQUAL
65723: PUSH
65724: LD_VAR 0 3
65728: PPUSH
65729: CALL_OW 257
65733: PUSH
65734: LD_INT 1
65736: EQUAL
65737: AND
65738: PUSH
65739: LD_VAR 0 3
65743: PPUSH
65744: CALL_OW 459
65748: NOT
65749: AND
65750: PUSH
65751: LD_VAR 0 7
65755: AND
65756: IFFALSE 65772
// ComChangeProfession ( j , class ) ;
65758: LD_VAR 0 3
65762: PPUSH
65763: LD_VAR 0 7
65767: PPUSH
65768: CALL_OW 123
65772: GO 65702
65774: POP
65775: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
65776: LD_EXP 46
65780: PUSH
65781: LD_VAR 0 2
65785: ARRAY
65786: PUSH
65787: LD_EXP 66
65791: PUSH
65792: LD_VAR 0 2
65796: ARRAY
65797: NOT
65798: AND
65799: PUSH
65800: LD_EXP 45
65804: PUSH
65805: LD_VAR 0 2
65809: ARRAY
65810: NOT
65811: AND
65812: IFFALSE 66063
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
65814: LD_ADDR_EXP 66
65818: PUSH
65819: LD_EXP 66
65823: PPUSH
65824: LD_VAR 0 2
65828: PPUSH
65829: LD_INT 1
65831: PPUSH
65832: CALL_OW 1
65836: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65837: LD_ADDR_VAR 0 4
65841: PUSH
65842: LD_EXP 23
65846: PUSH
65847: LD_VAR 0 2
65851: ARRAY
65852: PPUSH
65853: LD_INT 2
65855: PUSH
65856: LD_INT 25
65858: PUSH
65859: LD_INT 1
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 25
65868: PUSH
65869: LD_INT 5
65871: PUSH
65872: EMPTY
65873: LIST
65874: LIST
65875: PUSH
65876: LD_INT 25
65878: PUSH
65879: LD_INT 8
65881: PUSH
65882: EMPTY
65883: LIST
65884: LIST
65885: PUSH
65886: LD_INT 25
65888: PUSH
65889: LD_INT 9
65891: PUSH
65892: EMPTY
65893: LIST
65894: LIST
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: PPUSH
65903: CALL_OW 72
65907: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
65908: LD_ADDR_VAR 0 4
65912: PUSH
65913: LD_VAR 0 4
65917: PUSH
65918: LD_VAR 0 4
65922: PPUSH
65923: LD_INT 18
65925: PPUSH
65926: CALL 44973 0 2
65930: DIFF
65931: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
65932: LD_VAR 0 4
65936: NOT
65937: PUSH
65938: LD_EXP 23
65942: PUSH
65943: LD_VAR 0 2
65947: ARRAY
65948: PPUSH
65949: LD_INT 2
65951: PUSH
65952: LD_INT 30
65954: PUSH
65955: LD_INT 4
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 30
65964: PUSH
65965: LD_INT 5
65967: PUSH
65968: EMPTY
65969: LIST
65970: LIST
65971: PUSH
65972: EMPTY
65973: LIST
65974: LIST
65975: LIST
65976: PPUSH
65977: CALL_OW 72
65981: NOT
65982: AND
65983: IFFALSE 66045
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
65985: LD_ADDR_VAR 0 4
65989: PUSH
65990: LD_EXP 23
65994: PUSH
65995: LD_VAR 0 2
65999: ARRAY
66000: PPUSH
66001: LD_INT 2
66003: PUSH
66004: LD_INT 25
66006: PUSH
66007: LD_INT 2
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 25
66016: PUSH
66017: LD_INT 3
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 25
66026: PUSH
66027: LD_INT 4
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: LIST
66038: LIST
66039: PPUSH
66040: CALL_OW 72
66044: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
66045: LD_VAR 0 2
66049: PPUSH
66050: LD_VAR 0 4
66054: PPUSH
66055: CALL 84948 0 2
// exit ;
66059: POP
66060: POP
66061: GO 66183
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
66063: LD_EXP 46
66067: PUSH
66068: LD_VAR 0 2
66072: ARRAY
66073: PUSH
66074: LD_EXP 66
66078: PUSH
66079: LD_VAR 0 2
66083: ARRAY
66084: NOT
66085: AND
66086: PUSH
66087: LD_EXP 45
66091: PUSH
66092: LD_VAR 0 2
66096: ARRAY
66097: AND
66098: IFFALSE 66179
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66100: LD_ADDR_EXP 66
66104: PUSH
66105: LD_EXP 66
66109: PPUSH
66110: LD_VAR 0 2
66114: PPUSH
66115: LD_INT 1
66117: PPUSH
66118: CALL_OW 1
66122: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
66123: LD_ADDR_VAR 0 4
66127: PUSH
66128: LD_EXP 45
66132: PUSH
66133: LD_VAR 0 2
66137: ARRAY
66138: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
66139: LD_ADDR_EXP 45
66143: PUSH
66144: LD_EXP 45
66148: PPUSH
66149: LD_VAR 0 2
66153: PPUSH
66154: EMPTY
66155: PPUSH
66156: CALL_OW 1
66160: ST_TO_ADDR
// Defend ( i , tmp ) ;
66161: LD_VAR 0 2
66165: PPUSH
66166: LD_VAR 0 4
66170: PPUSH
66171: CALL 85518 0 2
// exit ;
66175: POP
66176: POP
66177: GO 66183
// end ; end ;
66179: GO 65488
66181: POP
66182: POP
// end ;
66183: LD_VAR 0 1
66187: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66188: LD_INT 0
66190: PPUSH
66191: PPUSH
66192: PPUSH
66193: PPUSH
66194: PPUSH
66195: PPUSH
66196: PPUSH
66197: PPUSH
66198: PPUSH
66199: PPUSH
66200: PPUSH
// if not mc_bases then
66201: LD_EXP 23
66205: NOT
66206: IFFALSE 66210
// exit ;
66208: GO 67297
// for i = 1 to mc_bases do
66210: LD_ADDR_VAR 0 2
66214: PUSH
66215: DOUBLE
66216: LD_INT 1
66218: DEC
66219: ST_TO_ADDR
66220: LD_EXP 23
66224: PUSH
66225: FOR_TO
66226: IFFALSE 67295
// begin tmp := mc_lab [ i ] ;
66228: LD_ADDR_VAR 0 6
66232: PUSH
66233: LD_EXP 56
66237: PUSH
66238: LD_VAR 0 2
66242: ARRAY
66243: ST_TO_ADDR
// if not tmp then
66244: LD_VAR 0 6
66248: NOT
66249: IFFALSE 66253
// continue ;
66251: GO 66225
// idle_lab := 0 ;
66253: LD_ADDR_VAR 0 11
66257: PUSH
66258: LD_INT 0
66260: ST_TO_ADDR
// for j in tmp do
66261: LD_ADDR_VAR 0 3
66265: PUSH
66266: LD_VAR 0 6
66270: PUSH
66271: FOR_IN
66272: IFFALSE 67291
// begin researching := false ;
66274: LD_ADDR_VAR 0 10
66278: PUSH
66279: LD_INT 0
66281: ST_TO_ADDR
// side := GetSide ( j ) ;
66282: LD_ADDR_VAR 0 4
66286: PUSH
66287: LD_VAR 0 3
66291: PPUSH
66292: CALL_OW 255
66296: ST_TO_ADDR
// if not mc_tech [ side ] then
66297: LD_EXP 50
66301: PUSH
66302: LD_VAR 0 4
66306: ARRAY
66307: NOT
66308: IFFALSE 66312
// continue ;
66310: GO 66271
// if BuildingStatus ( j ) = bs_idle then
66312: LD_VAR 0 3
66316: PPUSH
66317: CALL_OW 461
66321: PUSH
66322: LD_INT 2
66324: EQUAL
66325: IFFALSE 66513
// begin if idle_lab and UnitsInside ( j ) < 6 then
66327: LD_VAR 0 11
66331: PUSH
66332: LD_VAR 0 3
66336: PPUSH
66337: CALL_OW 313
66341: PUSH
66342: LD_INT 6
66344: LESS
66345: AND
66346: IFFALSE 66417
// begin tmp2 := UnitsInside ( idle_lab ) ;
66348: LD_ADDR_VAR 0 9
66352: PUSH
66353: LD_VAR 0 11
66357: PPUSH
66358: CALL_OW 313
66362: ST_TO_ADDR
// if tmp2 then
66363: LD_VAR 0 9
66367: IFFALSE 66409
// for x in tmp2 do
66369: LD_ADDR_VAR 0 7
66373: PUSH
66374: LD_VAR 0 9
66378: PUSH
66379: FOR_IN
66380: IFFALSE 66407
// begin ComExitBuilding ( x ) ;
66382: LD_VAR 0 7
66386: PPUSH
66387: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66391: LD_VAR 0 7
66395: PPUSH
66396: LD_VAR 0 3
66400: PPUSH
66401: CALL_OW 180
// end ;
66405: GO 66379
66407: POP
66408: POP
// idle_lab := 0 ;
66409: LD_ADDR_VAR 0 11
66413: PUSH
66414: LD_INT 0
66416: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66417: LD_ADDR_VAR 0 5
66421: PUSH
66422: LD_EXP 50
66426: PUSH
66427: LD_VAR 0 4
66431: ARRAY
66432: PUSH
66433: FOR_IN
66434: IFFALSE 66494
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66436: LD_VAR 0 3
66440: PPUSH
66441: LD_VAR 0 5
66445: PPUSH
66446: CALL_OW 430
66450: PUSH
66451: LD_VAR 0 4
66455: PPUSH
66456: LD_VAR 0 5
66460: PPUSH
66461: CALL 11574 0 2
66465: AND
66466: IFFALSE 66492
// begin researching := true ;
66468: LD_ADDR_VAR 0 10
66472: PUSH
66473: LD_INT 1
66475: ST_TO_ADDR
// ComResearch ( j , t ) ;
66476: LD_VAR 0 3
66480: PPUSH
66481: LD_VAR 0 5
66485: PPUSH
66486: CALL_OW 124
// break ;
66490: GO 66494
// end ;
66492: GO 66433
66494: POP
66495: POP
// if not researching then
66496: LD_VAR 0 10
66500: NOT
66501: IFFALSE 66513
// idle_lab := j ;
66503: LD_ADDR_VAR 0 11
66507: PUSH
66508: LD_VAR 0 3
66512: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
66513: LD_VAR 0 3
66517: PPUSH
66518: CALL_OW 461
66522: PUSH
66523: LD_INT 10
66525: EQUAL
66526: IFFALSE 67114
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
66528: LD_EXP 52
66532: PUSH
66533: LD_VAR 0 2
66537: ARRAY
66538: NOT
66539: PUSH
66540: LD_EXP 53
66544: PUSH
66545: LD_VAR 0 2
66549: ARRAY
66550: NOT
66551: AND
66552: PUSH
66553: LD_EXP 50
66557: PUSH
66558: LD_VAR 0 4
66562: ARRAY
66563: PUSH
66564: LD_INT 1
66566: GREATER
66567: AND
66568: IFFALSE 66699
// begin ComCancel ( j ) ;
66570: LD_VAR 0 3
66574: PPUSH
66575: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
66579: LD_ADDR_EXP 50
66583: PUSH
66584: LD_EXP 50
66588: PPUSH
66589: LD_VAR 0 4
66593: PPUSH
66594: LD_EXP 50
66598: PUSH
66599: LD_VAR 0 4
66603: ARRAY
66604: PPUSH
66605: LD_EXP 50
66609: PUSH
66610: LD_VAR 0 4
66614: ARRAY
66615: PUSH
66616: LD_INT 1
66618: MINUS
66619: PPUSH
66620: LD_EXP 50
66624: PUSH
66625: LD_VAR 0 4
66629: ARRAY
66630: PPUSH
66631: LD_INT 0
66633: PPUSH
66634: CALL 15122 0 4
66638: PPUSH
66639: CALL_OW 1
66643: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
66644: LD_ADDR_EXP 50
66648: PUSH
66649: LD_EXP 50
66653: PPUSH
66654: LD_VAR 0 4
66658: PPUSH
66659: LD_EXP 50
66663: PUSH
66664: LD_VAR 0 4
66668: ARRAY
66669: PPUSH
66670: LD_EXP 50
66674: PUSH
66675: LD_VAR 0 4
66679: ARRAY
66680: PPUSH
66681: LD_INT 1
66683: PPUSH
66684: LD_INT 0
66686: PPUSH
66687: CALL 15122 0 4
66691: PPUSH
66692: CALL_OW 1
66696: ST_TO_ADDR
// continue ;
66697: GO 66271
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
66699: LD_EXP 52
66703: PUSH
66704: LD_VAR 0 2
66708: ARRAY
66709: PUSH
66710: LD_EXP 53
66714: PUSH
66715: LD_VAR 0 2
66719: ARRAY
66720: NOT
66721: AND
66722: IFFALSE 66849
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
66724: LD_ADDR_EXP 53
66728: PUSH
66729: LD_EXP 53
66733: PPUSH
66734: LD_VAR 0 2
66738: PUSH
66739: LD_EXP 53
66743: PUSH
66744: LD_VAR 0 2
66748: ARRAY
66749: PUSH
66750: LD_INT 1
66752: PLUS
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PPUSH
66758: LD_EXP 52
66762: PUSH
66763: LD_VAR 0 2
66767: ARRAY
66768: PUSH
66769: LD_INT 1
66771: ARRAY
66772: PPUSH
66773: CALL 15704 0 3
66777: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
66778: LD_EXP 52
66782: PUSH
66783: LD_VAR 0 2
66787: ARRAY
66788: PUSH
66789: LD_INT 1
66791: ARRAY
66792: PPUSH
66793: LD_INT 112
66795: PPUSH
66796: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
66800: LD_ADDR_VAR 0 9
66804: PUSH
66805: LD_EXP 52
66809: PUSH
66810: LD_VAR 0 2
66814: ARRAY
66815: PPUSH
66816: LD_INT 1
66818: PPUSH
66819: CALL_OW 3
66823: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
66824: LD_ADDR_EXP 52
66828: PUSH
66829: LD_EXP 52
66833: PPUSH
66834: LD_VAR 0 2
66838: PPUSH
66839: LD_VAR 0 9
66843: PPUSH
66844: CALL_OW 1
66848: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
66849: LD_EXP 52
66853: PUSH
66854: LD_VAR 0 2
66858: ARRAY
66859: PUSH
66860: LD_EXP 53
66864: PUSH
66865: LD_VAR 0 2
66869: ARRAY
66870: AND
66871: PUSH
66872: LD_EXP 53
66876: PUSH
66877: LD_VAR 0 2
66881: ARRAY
66882: PUSH
66883: LD_INT 1
66885: ARRAY
66886: PPUSH
66887: CALL_OW 310
66891: NOT
66892: AND
66893: PUSH
66894: LD_VAR 0 3
66898: PPUSH
66899: CALL_OW 313
66903: PUSH
66904: LD_INT 6
66906: EQUAL
66907: AND
66908: IFFALSE 66964
// begin tmp2 := UnitsInside ( j ) ;
66910: LD_ADDR_VAR 0 9
66914: PUSH
66915: LD_VAR 0 3
66919: PPUSH
66920: CALL_OW 313
66924: ST_TO_ADDR
// if tmp2 = 6 then
66925: LD_VAR 0 9
66929: PUSH
66930: LD_INT 6
66932: EQUAL
66933: IFFALSE 66964
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
66935: LD_VAR 0 9
66939: PUSH
66940: LD_INT 1
66942: ARRAY
66943: PPUSH
66944: LD_INT 112
66946: PPUSH
66947: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
66951: LD_VAR 0 9
66955: PUSH
66956: LD_INT 1
66958: ARRAY
66959: PPUSH
66960: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
66964: LD_EXP 53
66968: PUSH
66969: LD_VAR 0 2
66973: ARRAY
66974: PUSH
66975: LD_EXP 53
66979: PUSH
66980: LD_VAR 0 2
66984: ARRAY
66985: PUSH
66986: LD_INT 1
66988: ARRAY
66989: PPUSH
66990: CALL_OW 314
66994: NOT
66995: AND
66996: PUSH
66997: LD_EXP 53
67001: PUSH
67002: LD_VAR 0 2
67006: ARRAY
67007: PUSH
67008: LD_INT 1
67010: ARRAY
67011: PPUSH
67012: CALL_OW 310
67016: NOT
67017: AND
67018: IFFALSE 67044
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67020: LD_EXP 53
67024: PUSH
67025: LD_VAR 0 2
67029: ARRAY
67030: PUSH
67031: LD_INT 1
67033: ARRAY
67034: PPUSH
67035: LD_VAR 0 3
67039: PPUSH
67040: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67044: LD_EXP 53
67048: PUSH
67049: LD_VAR 0 2
67053: ARRAY
67054: PUSH
67055: LD_INT 1
67057: ARRAY
67058: PPUSH
67059: CALL_OW 310
67063: PUSH
67064: LD_EXP 53
67068: PUSH
67069: LD_VAR 0 2
67073: ARRAY
67074: PUSH
67075: LD_INT 1
67077: ARRAY
67078: PPUSH
67079: CALL_OW 310
67083: PPUSH
67084: CALL_OW 461
67088: PUSH
67089: LD_INT 3
67091: NONEQUAL
67092: AND
67093: IFFALSE 67114
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67095: LD_EXP 53
67099: PUSH
67100: LD_VAR 0 2
67104: ARRAY
67105: PUSH
67106: LD_INT 1
67108: ARRAY
67109: PPUSH
67110: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67114: LD_VAR 0 3
67118: PPUSH
67119: CALL_OW 461
67123: PUSH
67124: LD_INT 6
67126: EQUAL
67127: PUSH
67128: LD_VAR 0 6
67132: PUSH
67133: LD_INT 1
67135: GREATER
67136: AND
67137: IFFALSE 67289
// begin sci := [ ] ;
67139: LD_ADDR_VAR 0 8
67143: PUSH
67144: EMPTY
67145: ST_TO_ADDR
// for x in ( tmp diff j ) do
67146: LD_ADDR_VAR 0 7
67150: PUSH
67151: LD_VAR 0 6
67155: PUSH
67156: LD_VAR 0 3
67160: DIFF
67161: PUSH
67162: FOR_IN
67163: IFFALSE 67215
// begin if sci = 6 then
67165: LD_VAR 0 8
67169: PUSH
67170: LD_INT 6
67172: EQUAL
67173: IFFALSE 67177
// break ;
67175: GO 67215
// if BuildingStatus ( x ) = bs_idle then
67177: LD_VAR 0 7
67181: PPUSH
67182: CALL_OW 461
67186: PUSH
67187: LD_INT 2
67189: EQUAL
67190: IFFALSE 67213
// sci := sci ^ UnitsInside ( x ) ;
67192: LD_ADDR_VAR 0 8
67196: PUSH
67197: LD_VAR 0 8
67201: PUSH
67202: LD_VAR 0 7
67206: PPUSH
67207: CALL_OW 313
67211: ADD
67212: ST_TO_ADDR
// end ;
67213: GO 67162
67215: POP
67216: POP
// if not sci then
67217: LD_VAR 0 8
67221: NOT
67222: IFFALSE 67226
// continue ;
67224: GO 66271
// for x in sci do
67226: LD_ADDR_VAR 0 7
67230: PUSH
67231: LD_VAR 0 8
67235: PUSH
67236: FOR_IN
67237: IFFALSE 67287
// if IsInUnit ( x ) and not HasTask ( x ) then
67239: LD_VAR 0 7
67243: PPUSH
67244: CALL_OW 310
67248: PUSH
67249: LD_VAR 0 7
67253: PPUSH
67254: CALL_OW 314
67258: NOT
67259: AND
67260: IFFALSE 67285
// begin ComExitBuilding ( x ) ;
67262: LD_VAR 0 7
67266: PPUSH
67267: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67271: LD_VAR 0 7
67275: PPUSH
67276: LD_VAR 0 3
67280: PPUSH
67281: CALL_OW 180
// end ;
67285: GO 67236
67287: POP
67288: POP
// end ; end ;
67289: GO 66271
67291: POP
67292: POP
// end ;
67293: GO 66225
67295: POP
67296: POP
// end ;
67297: LD_VAR 0 1
67301: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67302: LD_INT 0
67304: PPUSH
67305: PPUSH
// if not mc_bases then
67306: LD_EXP 23
67310: NOT
67311: IFFALSE 67315
// exit ;
67313: GO 67396
// for i = 1 to mc_bases do
67315: LD_ADDR_VAR 0 2
67319: PUSH
67320: DOUBLE
67321: LD_INT 1
67323: DEC
67324: ST_TO_ADDR
67325: LD_EXP 23
67329: PUSH
67330: FOR_TO
67331: IFFALSE 67394
// if mc_mines [ i ] and mc_miners [ i ] then
67333: LD_EXP 36
67337: PUSH
67338: LD_VAR 0 2
67342: ARRAY
67343: PUSH
67344: LD_EXP 37
67348: PUSH
67349: LD_VAR 0 2
67353: ARRAY
67354: AND
67355: IFFALSE 67392
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67357: LD_EXP 37
67361: PUSH
67362: LD_VAR 0 2
67366: ARRAY
67367: PUSH
67368: LD_INT 1
67370: ARRAY
67371: PPUSH
67372: CALL_OW 255
67376: PPUSH
67377: LD_EXP 36
67381: PUSH
67382: LD_VAR 0 2
67386: ARRAY
67387: PPUSH
67388: CALL 12657 0 2
67392: GO 67330
67394: POP
67395: POP
// end ;
67396: LD_VAR 0 1
67400: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67401: LD_INT 0
67403: PPUSH
67404: PPUSH
67405: PPUSH
67406: PPUSH
67407: PPUSH
67408: PPUSH
67409: PPUSH
67410: PPUSH
// if not mc_bases or not mc_parking then
67411: LD_EXP 23
67415: NOT
67416: PUSH
67417: LD_EXP 47
67421: NOT
67422: OR
67423: IFFALSE 67427
// exit ;
67425: GO 68137
// for i = 1 to mc_bases do
67427: LD_ADDR_VAR 0 2
67431: PUSH
67432: DOUBLE
67433: LD_INT 1
67435: DEC
67436: ST_TO_ADDR
67437: LD_EXP 23
67441: PUSH
67442: FOR_TO
67443: IFFALSE 68135
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
67445: LD_EXP 23
67449: PUSH
67450: LD_VAR 0 2
67454: ARRAY
67455: NOT
67456: PUSH
67457: LD_EXP 47
67461: PUSH
67462: LD_VAR 0 2
67466: ARRAY
67467: NOT
67468: OR
67469: IFFALSE 67473
// continue ;
67471: GO 67442
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67473: LD_ADDR_VAR 0 5
67477: PUSH
67478: LD_EXP 23
67482: PUSH
67483: LD_VAR 0 2
67487: ARRAY
67488: PUSH
67489: LD_INT 1
67491: ARRAY
67492: PPUSH
67493: CALL_OW 255
67497: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67498: LD_ADDR_VAR 0 6
67502: PUSH
67503: LD_EXP 23
67507: PUSH
67508: LD_VAR 0 2
67512: ARRAY
67513: PPUSH
67514: LD_INT 30
67516: PUSH
67517: LD_INT 3
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PPUSH
67524: CALL_OW 72
67528: ST_TO_ADDR
// if not fac then
67529: LD_VAR 0 6
67533: NOT
67534: IFFALSE 67585
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67536: LD_ADDR_VAR 0 6
67540: PUSH
67541: LD_EXP 23
67545: PUSH
67546: LD_VAR 0 2
67550: ARRAY
67551: PPUSH
67552: LD_INT 2
67554: PUSH
67555: LD_INT 30
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 30
67567: PUSH
67568: LD_INT 1
67570: PUSH
67571: EMPTY
67572: LIST
67573: LIST
67574: PUSH
67575: EMPTY
67576: LIST
67577: LIST
67578: LIST
67579: PPUSH
67580: CALL_OW 72
67584: ST_TO_ADDR
// if not fac then
67585: LD_VAR 0 6
67589: NOT
67590: IFFALSE 67594
// continue ;
67592: GO 67442
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67594: LD_ADDR_VAR 0 7
67598: PUSH
67599: LD_EXP 47
67603: PUSH
67604: LD_VAR 0 2
67608: ARRAY
67609: PPUSH
67610: LD_INT 22
67612: PUSH
67613: LD_VAR 0 5
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PUSH
67622: LD_INT 21
67624: PUSH
67625: LD_INT 2
67627: PUSH
67628: EMPTY
67629: LIST
67630: LIST
67631: PUSH
67632: LD_INT 3
67634: PUSH
67635: LD_INT 24
67637: PUSH
67638: LD_INT 1000
67640: PUSH
67641: EMPTY
67642: LIST
67643: LIST
67644: PUSH
67645: EMPTY
67646: LIST
67647: LIST
67648: PUSH
67649: EMPTY
67650: LIST
67651: LIST
67652: LIST
67653: PPUSH
67654: CALL_OW 70
67658: ST_TO_ADDR
// for j in fac do
67659: LD_ADDR_VAR 0 3
67663: PUSH
67664: LD_VAR 0 6
67668: PUSH
67669: FOR_IN
67670: IFFALSE 67751
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
67672: LD_ADDR_VAR 0 7
67676: PUSH
67677: LD_VAR 0 7
67681: PUSH
67682: LD_INT 22
67684: PUSH
67685: LD_VAR 0 5
67689: PUSH
67690: EMPTY
67691: LIST
67692: LIST
67693: PUSH
67694: LD_INT 91
67696: PUSH
67697: LD_VAR 0 3
67701: PUSH
67702: LD_INT 15
67704: PUSH
67705: EMPTY
67706: LIST
67707: LIST
67708: LIST
67709: PUSH
67710: LD_INT 21
67712: PUSH
67713: LD_INT 2
67715: PUSH
67716: EMPTY
67717: LIST
67718: LIST
67719: PUSH
67720: LD_INT 3
67722: PUSH
67723: LD_INT 24
67725: PUSH
67726: LD_INT 1000
67728: PUSH
67729: EMPTY
67730: LIST
67731: LIST
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: LIST
67741: LIST
67742: PPUSH
67743: CALL_OW 69
67747: UNION
67748: ST_TO_ADDR
67749: GO 67669
67751: POP
67752: POP
// if not vehs then
67753: LD_VAR 0 7
67757: NOT
67758: IFFALSE 67784
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
67760: LD_ADDR_EXP 35
67764: PUSH
67765: LD_EXP 35
67769: PPUSH
67770: LD_VAR 0 2
67774: PPUSH
67775: EMPTY
67776: PPUSH
67777: CALL_OW 1
67781: ST_TO_ADDR
// continue ;
67782: GO 67442
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67784: LD_ADDR_VAR 0 8
67788: PUSH
67789: LD_EXP 23
67793: PUSH
67794: LD_VAR 0 2
67798: ARRAY
67799: PPUSH
67800: LD_INT 30
67802: PUSH
67803: LD_INT 3
67805: PUSH
67806: EMPTY
67807: LIST
67808: LIST
67809: PPUSH
67810: CALL_OW 72
67814: ST_TO_ADDR
// if tmp then
67815: LD_VAR 0 8
67819: IFFALSE 67922
// begin for j in tmp do
67821: LD_ADDR_VAR 0 3
67825: PUSH
67826: LD_VAR 0 8
67830: PUSH
67831: FOR_IN
67832: IFFALSE 67920
// for k in UnitsInside ( j ) do
67834: LD_ADDR_VAR 0 4
67838: PUSH
67839: LD_VAR 0 3
67843: PPUSH
67844: CALL_OW 313
67848: PUSH
67849: FOR_IN
67850: IFFALSE 67916
// if k then
67852: LD_VAR 0 4
67856: IFFALSE 67914
// if not k in mc_repair_vehicle [ i ] then
67858: LD_VAR 0 4
67862: PUSH
67863: LD_EXP 35
67867: PUSH
67868: LD_VAR 0 2
67872: ARRAY
67873: IN
67874: NOT
67875: IFFALSE 67914
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
67877: LD_ADDR_EXP 35
67881: PUSH
67882: LD_EXP 35
67886: PPUSH
67887: LD_VAR 0 2
67891: PPUSH
67892: LD_EXP 35
67896: PUSH
67897: LD_VAR 0 2
67901: ARRAY
67902: PUSH
67903: LD_VAR 0 4
67907: UNION
67908: PPUSH
67909: CALL_OW 1
67913: ST_TO_ADDR
67914: GO 67849
67916: POP
67917: POP
67918: GO 67831
67920: POP
67921: POP
// end ; if not mc_repair_vehicle [ i ] then
67922: LD_EXP 35
67926: PUSH
67927: LD_VAR 0 2
67931: ARRAY
67932: NOT
67933: IFFALSE 67937
// continue ;
67935: GO 67442
// for j in mc_repair_vehicle [ i ] do
67937: LD_ADDR_VAR 0 3
67941: PUSH
67942: LD_EXP 35
67946: PUSH
67947: LD_VAR 0 2
67951: ARRAY
67952: PUSH
67953: FOR_IN
67954: IFFALSE 68131
// begin if GetClass ( j ) <> 3 then
67956: LD_VAR 0 3
67960: PPUSH
67961: CALL_OW 257
67965: PUSH
67966: LD_INT 3
67968: NONEQUAL
67969: IFFALSE 68010
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
67971: LD_ADDR_EXP 35
67975: PUSH
67976: LD_EXP 35
67980: PPUSH
67981: LD_VAR 0 2
67985: PPUSH
67986: LD_EXP 35
67990: PUSH
67991: LD_VAR 0 2
67995: ARRAY
67996: PUSH
67997: LD_VAR 0 3
68001: DIFF
68002: PPUSH
68003: CALL_OW 1
68007: ST_TO_ADDR
// continue ;
68008: GO 67953
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68010: LD_VAR 0 3
68014: PPUSH
68015: CALL_OW 311
68019: NOT
68020: PUSH
68021: LD_VAR 0 3
68025: PUSH
68026: LD_EXP 26
68030: PUSH
68031: LD_VAR 0 2
68035: ARRAY
68036: PUSH
68037: LD_INT 1
68039: ARRAY
68040: IN
68041: NOT
68042: AND
68043: PUSH
68044: LD_VAR 0 3
68048: PUSH
68049: LD_EXP 26
68053: PUSH
68054: LD_VAR 0 2
68058: ARRAY
68059: PUSH
68060: LD_INT 2
68062: ARRAY
68063: IN
68064: NOT
68065: AND
68066: IFFALSE 68129
// begin if IsInUnit ( j ) then
68068: LD_VAR 0 3
68072: PPUSH
68073: CALL_OW 310
68077: IFFALSE 68090
// ComExitBuilding ( j ) else
68079: LD_VAR 0 3
68083: PPUSH
68084: CALL_OW 122
68088: GO 68129
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
68090: LD_VAR 0 3
68094: PPUSH
68095: LD_VAR 0 7
68099: PUSH
68100: LD_INT 1
68102: ARRAY
68103: PPUSH
68104: CALL 49311 0 2
68108: NOT
68109: IFFALSE 68129
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
68111: LD_VAR 0 3
68115: PPUSH
68116: LD_VAR 0 7
68120: PUSH
68121: LD_INT 1
68123: ARRAY
68124: PPUSH
68125: CALL_OW 129
// end ; end ;
68129: GO 67953
68131: POP
68132: POP
// end ;
68133: GO 67442
68135: POP
68136: POP
// end ;
68137: LD_VAR 0 1
68141: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68142: LD_INT 0
68144: PPUSH
68145: PPUSH
68146: PPUSH
68147: PPUSH
68148: PPUSH
68149: PPUSH
68150: PPUSH
68151: PPUSH
68152: PPUSH
68153: PPUSH
68154: PPUSH
// if not mc_bases then
68155: LD_EXP 23
68159: NOT
68160: IFFALSE 68164
// exit ;
68162: GO 68966
// for i = 1 to mc_bases do
68164: LD_ADDR_VAR 0 2
68168: PUSH
68169: DOUBLE
68170: LD_INT 1
68172: DEC
68173: ST_TO_ADDR
68174: LD_EXP 23
68178: PUSH
68179: FOR_TO
68180: IFFALSE 68964
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68182: LD_EXP 51
68186: PUSH
68187: LD_VAR 0 2
68191: ARRAY
68192: NOT
68193: PUSH
68194: LD_EXP 26
68198: PUSH
68199: LD_VAR 0 2
68203: ARRAY
68204: PUSH
68205: LD_INT 1
68207: ARRAY
68208: OR
68209: PUSH
68210: LD_EXP 26
68214: PUSH
68215: LD_VAR 0 2
68219: ARRAY
68220: PUSH
68221: LD_INT 2
68223: ARRAY
68224: OR
68225: PUSH
68226: LD_EXP 49
68230: PUSH
68231: LD_VAR 0 2
68235: ARRAY
68236: PPUSH
68237: LD_INT 1
68239: PPUSH
68240: CALL_OW 325
68244: NOT
68245: OR
68246: PUSH
68247: LD_EXP 46
68251: PUSH
68252: LD_VAR 0 2
68256: ARRAY
68257: OR
68258: IFFALSE 68262
// continue ;
68260: GO 68179
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68262: LD_ADDR_VAR 0 8
68266: PUSH
68267: LD_EXP 23
68271: PUSH
68272: LD_VAR 0 2
68276: ARRAY
68277: PPUSH
68278: LD_INT 25
68280: PUSH
68281: LD_INT 4
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: LD_INT 50
68290: PUSH
68291: EMPTY
68292: LIST
68293: PUSH
68294: LD_INT 3
68296: PUSH
68297: LD_INT 60
68299: PUSH
68300: EMPTY
68301: LIST
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: LIST
68311: PPUSH
68312: CALL_OW 72
68316: PUSH
68317: LD_EXP 27
68321: PUSH
68322: LD_VAR 0 2
68326: ARRAY
68327: DIFF
68328: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68329: LD_ADDR_VAR 0 9
68333: PUSH
68334: LD_EXP 23
68338: PUSH
68339: LD_VAR 0 2
68343: ARRAY
68344: PPUSH
68345: LD_INT 2
68347: PUSH
68348: LD_INT 30
68350: PUSH
68351: LD_INT 0
68353: PUSH
68354: EMPTY
68355: LIST
68356: LIST
68357: PUSH
68358: LD_INT 30
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: LIST
68372: PPUSH
68373: CALL_OW 72
68377: ST_TO_ADDR
// if not tmp or not dep then
68378: LD_VAR 0 8
68382: NOT
68383: PUSH
68384: LD_VAR 0 9
68388: NOT
68389: OR
68390: IFFALSE 68394
// continue ;
68392: GO 68179
// side := GetSide ( tmp [ 1 ] ) ;
68394: LD_ADDR_VAR 0 11
68398: PUSH
68399: LD_VAR 0 8
68403: PUSH
68404: LD_INT 1
68406: ARRAY
68407: PPUSH
68408: CALL_OW 255
68412: ST_TO_ADDR
// dep := dep [ 1 ] ;
68413: LD_ADDR_VAR 0 9
68417: PUSH
68418: LD_VAR 0 9
68422: PUSH
68423: LD_INT 1
68425: ARRAY
68426: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68427: LD_ADDR_VAR 0 7
68431: PUSH
68432: LD_EXP 51
68436: PUSH
68437: LD_VAR 0 2
68441: ARRAY
68442: PPUSH
68443: LD_INT 22
68445: PUSH
68446: LD_INT 0
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 25
68455: PUSH
68456: LD_INT 12
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: PPUSH
68467: CALL_OW 70
68471: PUSH
68472: LD_INT 22
68474: PUSH
68475: LD_INT 0
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 25
68484: PUSH
68485: LD_INT 12
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 91
68494: PUSH
68495: LD_VAR 0 9
68499: PUSH
68500: LD_INT 20
68502: PUSH
68503: EMPTY
68504: LIST
68505: LIST
68506: LIST
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: LIST
68512: PPUSH
68513: CALL_OW 69
68517: UNION
68518: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
68519: LD_ADDR_VAR 0 10
68523: PUSH
68524: LD_EXP 51
68528: PUSH
68529: LD_VAR 0 2
68533: ARRAY
68534: PPUSH
68535: LD_INT 81
68537: PUSH
68538: LD_VAR 0 11
68542: PUSH
68543: EMPTY
68544: LIST
68545: LIST
68546: PPUSH
68547: CALL_OW 70
68551: ST_TO_ADDR
// if not apes or danger_at_area then
68552: LD_VAR 0 7
68556: NOT
68557: PUSH
68558: LD_VAR 0 10
68562: OR
68563: IFFALSE 68613
// begin if mc_taming [ i ] then
68565: LD_EXP 54
68569: PUSH
68570: LD_VAR 0 2
68574: ARRAY
68575: IFFALSE 68611
// begin MC_Reset ( i , 121 ) ;
68577: LD_VAR 0 2
68581: PPUSH
68582: LD_INT 121
68584: PPUSH
68585: CALL 53746 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
68589: LD_ADDR_EXP 54
68593: PUSH
68594: LD_EXP 54
68598: PPUSH
68599: LD_VAR 0 2
68603: PPUSH
68604: EMPTY
68605: PPUSH
68606: CALL_OW 1
68610: ST_TO_ADDR
// end ; continue ;
68611: GO 68179
// end ; for j in tmp do
68613: LD_ADDR_VAR 0 3
68617: PUSH
68618: LD_VAR 0 8
68622: PUSH
68623: FOR_IN
68624: IFFALSE 68960
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
68626: LD_VAR 0 3
68630: PUSH
68631: LD_EXP 54
68635: PUSH
68636: LD_VAR 0 2
68640: ARRAY
68641: IN
68642: NOT
68643: PUSH
68644: LD_EXP 54
68648: PUSH
68649: LD_VAR 0 2
68653: ARRAY
68654: PUSH
68655: LD_INT 3
68657: LESS
68658: AND
68659: IFFALSE 68717
// begin SetTag ( j , 121 ) ;
68661: LD_VAR 0 3
68665: PPUSH
68666: LD_INT 121
68668: PPUSH
68669: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
68673: LD_ADDR_EXP 54
68677: PUSH
68678: LD_EXP 54
68682: PPUSH
68683: LD_VAR 0 2
68687: PUSH
68688: LD_EXP 54
68692: PUSH
68693: LD_VAR 0 2
68697: ARRAY
68698: PUSH
68699: LD_INT 1
68701: PLUS
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: PPUSH
68707: LD_VAR 0 3
68711: PPUSH
68712: CALL 15704 0 3
68716: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
68717: LD_VAR 0 3
68721: PUSH
68722: LD_EXP 54
68726: PUSH
68727: LD_VAR 0 2
68731: ARRAY
68732: IN
68733: IFFALSE 68958
// begin if GetClass ( j ) <> 4 then
68735: LD_VAR 0 3
68739: PPUSH
68740: CALL_OW 257
68744: PUSH
68745: LD_INT 4
68747: NONEQUAL
68748: IFFALSE 68801
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
68750: LD_ADDR_EXP 54
68754: PUSH
68755: LD_EXP 54
68759: PPUSH
68760: LD_VAR 0 2
68764: PPUSH
68765: LD_EXP 54
68769: PUSH
68770: LD_VAR 0 2
68774: ARRAY
68775: PUSH
68776: LD_VAR 0 3
68780: DIFF
68781: PPUSH
68782: CALL_OW 1
68786: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68787: LD_VAR 0 3
68791: PPUSH
68792: LD_INT 0
68794: PPUSH
68795: CALL_OW 109
// continue ;
68799: GO 68623
// end ; if IsInUnit ( j ) then
68801: LD_VAR 0 3
68805: PPUSH
68806: CALL_OW 310
68810: IFFALSE 68821
// ComExitBuilding ( j ) ;
68812: LD_VAR 0 3
68816: PPUSH
68817: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
68821: LD_ADDR_VAR 0 6
68825: PUSH
68826: LD_VAR 0 7
68830: PPUSH
68831: LD_VAR 0 3
68835: PPUSH
68836: CALL_OW 74
68840: ST_TO_ADDR
// if not ape then
68841: LD_VAR 0 6
68845: NOT
68846: IFFALSE 68850
// break ;
68848: GO 68960
// x := GetX ( ape ) ;
68850: LD_ADDR_VAR 0 4
68854: PUSH
68855: LD_VAR 0 6
68859: PPUSH
68860: CALL_OW 250
68864: ST_TO_ADDR
// y := GetY ( ape ) ;
68865: LD_ADDR_VAR 0 5
68869: PUSH
68870: LD_VAR 0 6
68874: PPUSH
68875: CALL_OW 251
68879: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
68880: LD_VAR 0 4
68884: PPUSH
68885: LD_VAR 0 5
68889: PPUSH
68890: CALL_OW 488
68894: NOT
68895: PUSH
68896: LD_VAR 0 11
68900: PPUSH
68901: LD_VAR 0 4
68905: PPUSH
68906: LD_VAR 0 5
68910: PPUSH
68911: LD_INT 20
68913: PPUSH
68914: CALL 16600 0 4
68918: PUSH
68919: LD_INT 4
68921: ARRAY
68922: OR
68923: IFFALSE 68927
// break ;
68925: GO 68960
// if not HasTask ( j ) then
68927: LD_VAR 0 3
68931: PPUSH
68932: CALL_OW 314
68936: NOT
68937: IFFALSE 68958
// ComTameXY ( j , x , y ) ;
68939: LD_VAR 0 3
68943: PPUSH
68944: LD_VAR 0 4
68948: PPUSH
68949: LD_VAR 0 5
68953: PPUSH
68954: CALL_OW 131
// end ; end ;
68958: GO 68623
68960: POP
68961: POP
// end ;
68962: GO 68179
68964: POP
68965: POP
// end ;
68966: LD_VAR 0 1
68970: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
68971: LD_INT 0
68973: PPUSH
68974: PPUSH
68975: PPUSH
68976: PPUSH
68977: PPUSH
68978: PPUSH
68979: PPUSH
68980: PPUSH
// if not mc_bases then
68981: LD_EXP 23
68985: NOT
68986: IFFALSE 68990
// exit ;
68988: GO 69616
// for i = 1 to mc_bases do
68990: LD_ADDR_VAR 0 2
68994: PUSH
68995: DOUBLE
68996: LD_INT 1
68998: DEC
68999: ST_TO_ADDR
69000: LD_EXP 23
69004: PUSH
69005: FOR_TO
69006: IFFALSE 69614
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69008: LD_EXP 52
69012: PUSH
69013: LD_VAR 0 2
69017: ARRAY
69018: NOT
69019: PUSH
69020: LD_EXP 52
69024: PUSH
69025: LD_VAR 0 2
69029: ARRAY
69030: PPUSH
69031: LD_INT 25
69033: PUSH
69034: LD_INT 12
69036: PUSH
69037: EMPTY
69038: LIST
69039: LIST
69040: PPUSH
69041: CALL_OW 72
69045: NOT
69046: OR
69047: IFFALSE 69051
// continue ;
69049: GO 69005
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69051: LD_ADDR_VAR 0 5
69055: PUSH
69056: LD_EXP 52
69060: PUSH
69061: LD_VAR 0 2
69065: ARRAY
69066: PUSH
69067: LD_INT 1
69069: ARRAY
69070: PPUSH
69071: CALL_OW 255
69075: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69076: LD_VAR 0 5
69080: PPUSH
69081: LD_INT 2
69083: PPUSH
69084: CALL_OW 325
69088: IFFALSE 69341
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69090: LD_ADDR_VAR 0 4
69094: PUSH
69095: LD_EXP 52
69099: PUSH
69100: LD_VAR 0 2
69104: ARRAY
69105: PPUSH
69106: LD_INT 25
69108: PUSH
69109: LD_INT 16
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PPUSH
69116: CALL_OW 72
69120: ST_TO_ADDR
// if tmp < 6 then
69121: LD_VAR 0 4
69125: PUSH
69126: LD_INT 6
69128: LESS
69129: IFFALSE 69341
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69131: LD_ADDR_VAR 0 6
69135: PUSH
69136: LD_EXP 23
69140: PUSH
69141: LD_VAR 0 2
69145: ARRAY
69146: PPUSH
69147: LD_INT 2
69149: PUSH
69150: LD_INT 30
69152: PUSH
69153: LD_INT 0
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: LD_INT 30
69162: PUSH
69163: LD_INT 1
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: LIST
69174: PPUSH
69175: CALL_OW 72
69179: ST_TO_ADDR
// if depot then
69180: LD_VAR 0 6
69184: IFFALSE 69341
// begin selected := 0 ;
69186: LD_ADDR_VAR 0 7
69190: PUSH
69191: LD_INT 0
69193: ST_TO_ADDR
// for j in depot do
69194: LD_ADDR_VAR 0 3
69198: PUSH
69199: LD_VAR 0 6
69203: PUSH
69204: FOR_IN
69205: IFFALSE 69236
// begin if UnitsInside ( j ) < 6 then
69207: LD_VAR 0 3
69211: PPUSH
69212: CALL_OW 313
69216: PUSH
69217: LD_INT 6
69219: LESS
69220: IFFALSE 69234
// begin selected := j ;
69222: LD_ADDR_VAR 0 7
69226: PUSH
69227: LD_VAR 0 3
69231: ST_TO_ADDR
// break ;
69232: GO 69236
// end ; end ;
69234: GO 69204
69236: POP
69237: POP
// if selected then
69238: LD_VAR 0 7
69242: IFFALSE 69341
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69244: LD_ADDR_VAR 0 3
69248: PUSH
69249: LD_EXP 52
69253: PUSH
69254: LD_VAR 0 2
69258: ARRAY
69259: PPUSH
69260: LD_INT 25
69262: PUSH
69263: LD_INT 12
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PPUSH
69270: CALL_OW 72
69274: PUSH
69275: FOR_IN
69276: IFFALSE 69339
// if not HasTask ( j ) then
69278: LD_VAR 0 3
69282: PPUSH
69283: CALL_OW 314
69287: NOT
69288: IFFALSE 69337
// begin if not IsInUnit ( j ) then
69290: LD_VAR 0 3
69294: PPUSH
69295: CALL_OW 310
69299: NOT
69300: IFFALSE 69316
// ComEnterUnit ( j , selected ) ;
69302: LD_VAR 0 3
69306: PPUSH
69307: LD_VAR 0 7
69311: PPUSH
69312: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
69316: LD_VAR 0 3
69320: PPUSH
69321: LD_INT 16
69323: PPUSH
69324: CALL_OW 183
// AddComExitBuilding ( j ) ;
69328: LD_VAR 0 3
69332: PPUSH
69333: CALL_OW 182
// end ;
69337: GO 69275
69339: POP
69340: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69341: LD_VAR 0 5
69345: PPUSH
69346: LD_INT 11
69348: PPUSH
69349: CALL_OW 325
69353: IFFALSE 69612
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69355: LD_ADDR_VAR 0 4
69359: PUSH
69360: LD_EXP 52
69364: PUSH
69365: LD_VAR 0 2
69369: ARRAY
69370: PPUSH
69371: LD_INT 25
69373: PUSH
69374: LD_INT 16
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PPUSH
69381: CALL_OW 72
69385: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69386: LD_VAR 0 4
69390: PUSH
69391: LD_INT 6
69393: GREATEREQUAL
69394: PUSH
69395: LD_VAR 0 5
69399: PPUSH
69400: LD_INT 2
69402: PPUSH
69403: CALL_OW 325
69407: NOT
69408: OR
69409: IFFALSE 69612
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69411: LD_ADDR_VAR 0 8
69415: PUSH
69416: LD_EXP 23
69420: PUSH
69421: LD_VAR 0 2
69425: ARRAY
69426: PPUSH
69427: LD_INT 2
69429: PUSH
69430: LD_INT 30
69432: PUSH
69433: LD_INT 4
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 30
69442: PUSH
69443: LD_INT 5
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: EMPTY
69451: LIST
69452: LIST
69453: LIST
69454: PPUSH
69455: CALL_OW 72
69459: ST_TO_ADDR
// if barracks then
69460: LD_VAR 0 8
69464: IFFALSE 69612
// begin selected := 0 ;
69466: LD_ADDR_VAR 0 7
69470: PUSH
69471: LD_INT 0
69473: ST_TO_ADDR
// for j in barracks do
69474: LD_ADDR_VAR 0 3
69478: PUSH
69479: LD_VAR 0 8
69483: PUSH
69484: FOR_IN
69485: IFFALSE 69516
// begin if UnitsInside ( j ) < 6 then
69487: LD_VAR 0 3
69491: PPUSH
69492: CALL_OW 313
69496: PUSH
69497: LD_INT 6
69499: LESS
69500: IFFALSE 69514
// begin selected := j ;
69502: LD_ADDR_VAR 0 7
69506: PUSH
69507: LD_VAR 0 3
69511: ST_TO_ADDR
// break ;
69512: GO 69516
// end ; end ;
69514: GO 69484
69516: POP
69517: POP
// if selected then
69518: LD_VAR 0 7
69522: IFFALSE 69612
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69524: LD_ADDR_VAR 0 3
69528: PUSH
69529: LD_EXP 52
69533: PUSH
69534: LD_VAR 0 2
69538: ARRAY
69539: PPUSH
69540: LD_INT 25
69542: PUSH
69543: LD_INT 12
69545: PUSH
69546: EMPTY
69547: LIST
69548: LIST
69549: PPUSH
69550: CALL_OW 72
69554: PUSH
69555: FOR_IN
69556: IFFALSE 69610
// if not IsInUnit ( j ) and not HasTask ( j ) then
69558: LD_VAR 0 3
69562: PPUSH
69563: CALL_OW 310
69567: NOT
69568: PUSH
69569: LD_VAR 0 3
69573: PPUSH
69574: CALL_OW 314
69578: NOT
69579: AND
69580: IFFALSE 69608
// begin ComEnterUnit ( j , selected ) ;
69582: LD_VAR 0 3
69586: PPUSH
69587: LD_VAR 0 7
69591: PPUSH
69592: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
69596: LD_VAR 0 3
69600: PPUSH
69601: LD_INT 15
69603: PPUSH
69604: CALL_OW 183
// end ;
69608: GO 69555
69610: POP
69611: POP
// end ; end ; end ; end ; end ;
69612: GO 69005
69614: POP
69615: POP
// end ;
69616: LD_VAR 0 1
69620: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
69621: LD_INT 0
69623: PPUSH
69624: PPUSH
69625: PPUSH
69626: PPUSH
// if not mc_bases then
69627: LD_EXP 23
69631: NOT
69632: IFFALSE 69636
// exit ;
69634: GO 69814
// for i = 1 to mc_bases do
69636: LD_ADDR_VAR 0 2
69640: PUSH
69641: DOUBLE
69642: LD_INT 1
69644: DEC
69645: ST_TO_ADDR
69646: LD_EXP 23
69650: PUSH
69651: FOR_TO
69652: IFFALSE 69812
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
69654: LD_ADDR_VAR 0 4
69658: PUSH
69659: LD_EXP 23
69663: PUSH
69664: LD_VAR 0 2
69668: ARRAY
69669: PPUSH
69670: LD_INT 25
69672: PUSH
69673: LD_INT 9
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PPUSH
69680: CALL_OW 72
69684: ST_TO_ADDR
// if not tmp then
69685: LD_VAR 0 4
69689: NOT
69690: IFFALSE 69694
// continue ;
69692: GO 69651
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
69694: LD_EXP 49
69698: PUSH
69699: LD_VAR 0 2
69703: ARRAY
69704: PPUSH
69705: LD_INT 29
69707: PPUSH
69708: CALL_OW 325
69712: NOT
69713: PUSH
69714: LD_EXP 49
69718: PUSH
69719: LD_VAR 0 2
69723: ARRAY
69724: PPUSH
69725: LD_INT 28
69727: PPUSH
69728: CALL_OW 325
69732: NOT
69733: AND
69734: IFFALSE 69738
// continue ;
69736: GO 69651
// for j in tmp do
69738: LD_ADDR_VAR 0 3
69742: PUSH
69743: LD_VAR 0 4
69747: PUSH
69748: FOR_IN
69749: IFFALSE 69808
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69751: LD_VAR 0 3
69755: PUSH
69756: LD_EXP 26
69760: PUSH
69761: LD_VAR 0 2
69765: ARRAY
69766: PUSH
69767: LD_INT 1
69769: ARRAY
69770: IN
69771: NOT
69772: PUSH
69773: LD_VAR 0 3
69777: PUSH
69778: LD_EXP 26
69782: PUSH
69783: LD_VAR 0 2
69787: ARRAY
69788: PUSH
69789: LD_INT 2
69791: ARRAY
69792: IN
69793: NOT
69794: AND
69795: IFFALSE 69806
// ComSpaceTimeShoot ( j ) ;
69797: LD_VAR 0 3
69801: PPUSH
69802: CALL 11665 0 1
69806: GO 69748
69808: POP
69809: POP
// end ;
69810: GO 69651
69812: POP
69813: POP
// end ;
69814: LD_VAR 0 1
69818: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
69819: LD_INT 0
69821: PPUSH
69822: PPUSH
69823: PPUSH
69824: PPUSH
69825: PPUSH
69826: PPUSH
69827: PPUSH
69828: PPUSH
69829: PPUSH
// if not mc_bases then
69830: LD_EXP 23
69834: NOT
69835: IFFALSE 69839
// exit ;
69837: GO 70461
// for i = 1 to mc_bases do
69839: LD_ADDR_VAR 0 2
69843: PUSH
69844: DOUBLE
69845: LD_INT 1
69847: DEC
69848: ST_TO_ADDR
69849: LD_EXP 23
69853: PUSH
69854: FOR_TO
69855: IFFALSE 70459
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
69857: LD_EXP 58
69861: PUSH
69862: LD_VAR 0 2
69866: ARRAY
69867: NOT
69868: PUSH
69869: LD_INT 38
69871: PPUSH
69872: LD_EXP 49
69876: PUSH
69877: LD_VAR 0 2
69881: ARRAY
69882: PPUSH
69883: CALL_OW 321
69887: PUSH
69888: LD_INT 2
69890: NONEQUAL
69891: OR
69892: IFFALSE 69896
// continue ;
69894: GO 69854
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
69896: LD_ADDR_VAR 0 8
69900: PUSH
69901: LD_EXP 23
69905: PUSH
69906: LD_VAR 0 2
69910: ARRAY
69911: PPUSH
69912: LD_INT 30
69914: PUSH
69915: LD_INT 34
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: PPUSH
69922: CALL_OW 72
69926: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
69927: LD_ADDR_VAR 0 9
69931: PUSH
69932: LD_EXP 23
69936: PUSH
69937: LD_VAR 0 2
69941: ARRAY
69942: PPUSH
69943: LD_INT 25
69945: PUSH
69946: LD_INT 4
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PPUSH
69953: CALL_OW 72
69957: PPUSH
69958: LD_INT 0
69960: PPUSH
69961: CALL 44973 0 2
69965: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
69966: LD_VAR 0 9
69970: NOT
69971: PUSH
69972: LD_VAR 0 8
69976: NOT
69977: OR
69978: PUSH
69979: LD_EXP 23
69983: PUSH
69984: LD_VAR 0 2
69988: ARRAY
69989: PPUSH
69990: LD_INT 124
69992: PPUSH
69993: CALL 44973 0 2
69997: OR
69998: IFFALSE 70002
// continue ;
70000: GO 69854
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70002: LD_EXP 59
70006: PUSH
70007: LD_VAR 0 2
70011: ARRAY
70012: PUSH
70013: LD_EXP 58
70017: PUSH
70018: LD_VAR 0 2
70022: ARRAY
70023: LESS
70024: PUSH
70025: LD_EXP 59
70029: PUSH
70030: LD_VAR 0 2
70034: ARRAY
70035: PUSH
70036: LD_VAR 0 8
70040: LESS
70041: AND
70042: IFFALSE 70457
// begin tmp := sci [ 1 ] ;
70044: LD_ADDR_VAR 0 7
70048: PUSH
70049: LD_VAR 0 9
70053: PUSH
70054: LD_INT 1
70056: ARRAY
70057: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70058: LD_VAR 0 7
70062: PPUSH
70063: LD_INT 124
70065: PPUSH
70066: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70070: LD_ADDR_VAR 0 3
70074: PUSH
70075: DOUBLE
70076: LD_EXP 58
70080: PUSH
70081: LD_VAR 0 2
70085: ARRAY
70086: INC
70087: ST_TO_ADDR
70088: LD_EXP 58
70092: PUSH
70093: LD_VAR 0 2
70097: ARRAY
70098: PUSH
70099: FOR_DOWNTO
70100: IFFALSE 70443
// begin if IsInUnit ( tmp ) then
70102: LD_VAR 0 7
70106: PPUSH
70107: CALL_OW 310
70111: IFFALSE 70122
// ComExitBuilding ( tmp ) ;
70113: LD_VAR 0 7
70117: PPUSH
70118: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70122: LD_INT 35
70124: PPUSH
70125: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70129: LD_VAR 0 7
70133: PPUSH
70134: CALL_OW 310
70138: NOT
70139: PUSH
70140: LD_VAR 0 7
70144: PPUSH
70145: CALL_OW 314
70149: NOT
70150: AND
70151: IFFALSE 70122
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70153: LD_ADDR_VAR 0 6
70157: PUSH
70158: LD_VAR 0 7
70162: PPUSH
70163: CALL_OW 250
70167: PUSH
70168: LD_VAR 0 7
70172: PPUSH
70173: CALL_OW 251
70177: PUSH
70178: EMPTY
70179: LIST
70180: LIST
70181: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70182: LD_INT 35
70184: PPUSH
70185: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70189: LD_ADDR_VAR 0 4
70193: PUSH
70194: LD_EXP 58
70198: PUSH
70199: LD_VAR 0 2
70203: ARRAY
70204: PUSH
70205: LD_VAR 0 3
70209: ARRAY
70210: PUSH
70211: LD_INT 1
70213: ARRAY
70214: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70215: LD_ADDR_VAR 0 5
70219: PUSH
70220: LD_EXP 58
70224: PUSH
70225: LD_VAR 0 2
70229: ARRAY
70230: PUSH
70231: LD_VAR 0 3
70235: ARRAY
70236: PUSH
70237: LD_INT 2
70239: ARRAY
70240: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70241: LD_VAR 0 7
70245: PPUSH
70246: LD_INT 10
70248: PPUSH
70249: CALL 18303 0 2
70253: PUSH
70254: LD_INT 4
70256: ARRAY
70257: IFFALSE 70295
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70259: LD_VAR 0 7
70263: PPUSH
70264: LD_VAR 0 6
70268: PUSH
70269: LD_INT 1
70271: ARRAY
70272: PPUSH
70273: LD_VAR 0 6
70277: PUSH
70278: LD_INT 2
70280: ARRAY
70281: PPUSH
70282: CALL_OW 111
// wait ( 0 0$10 ) ;
70286: LD_INT 350
70288: PPUSH
70289: CALL_OW 67
// end else
70293: GO 70321
// begin ComMoveXY ( tmp , x , y ) ;
70295: LD_VAR 0 7
70299: PPUSH
70300: LD_VAR 0 4
70304: PPUSH
70305: LD_VAR 0 5
70309: PPUSH
70310: CALL_OW 111
// wait ( 0 0$3 ) ;
70314: LD_INT 105
70316: PPUSH
70317: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
70321: LD_VAR 0 7
70325: PPUSH
70326: LD_VAR 0 4
70330: PPUSH
70331: LD_VAR 0 5
70335: PPUSH
70336: CALL_OW 307
70340: IFFALSE 70182
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70342: LD_VAR 0 7
70346: PPUSH
70347: LD_VAR 0 4
70351: PPUSH
70352: LD_VAR 0 5
70356: PPUSH
70357: LD_VAR 0 8
70361: PUSH
70362: LD_VAR 0 3
70366: ARRAY
70367: PPUSH
70368: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
70372: LD_INT 35
70374: PPUSH
70375: CALL_OW 67
// until not HasTask ( tmp ) ;
70379: LD_VAR 0 7
70383: PPUSH
70384: CALL_OW 314
70388: NOT
70389: IFFALSE 70372
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70391: LD_ADDR_EXP 59
70395: PUSH
70396: LD_EXP 59
70400: PPUSH
70401: LD_VAR 0 2
70405: PUSH
70406: LD_EXP 59
70410: PUSH
70411: LD_VAR 0 2
70415: ARRAY
70416: PUSH
70417: LD_INT 1
70419: PLUS
70420: PUSH
70421: EMPTY
70422: LIST
70423: LIST
70424: PPUSH
70425: LD_VAR 0 8
70429: PUSH
70430: LD_VAR 0 3
70434: ARRAY
70435: PPUSH
70436: CALL 15704 0 3
70440: ST_TO_ADDR
// end ;
70441: GO 70099
70443: POP
70444: POP
// MC_Reset ( i , 124 ) ;
70445: LD_VAR 0 2
70449: PPUSH
70450: LD_INT 124
70452: PPUSH
70453: CALL 53746 0 2
// end ; end ;
70457: GO 69854
70459: POP
70460: POP
// end ;
70461: LD_VAR 0 1
70465: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
70466: LD_INT 0
70468: PPUSH
70469: PPUSH
70470: PPUSH
// if not mc_bases then
70471: LD_EXP 23
70475: NOT
70476: IFFALSE 70480
// exit ;
70478: GO 71086
// for i = 1 to mc_bases do
70480: LD_ADDR_VAR 0 2
70484: PUSH
70485: DOUBLE
70486: LD_INT 1
70488: DEC
70489: ST_TO_ADDR
70490: LD_EXP 23
70494: PUSH
70495: FOR_TO
70496: IFFALSE 71084
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70498: LD_ADDR_VAR 0 3
70502: PUSH
70503: LD_EXP 23
70507: PUSH
70508: LD_VAR 0 2
70512: ARRAY
70513: PPUSH
70514: LD_INT 25
70516: PUSH
70517: LD_INT 4
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PPUSH
70524: CALL_OW 72
70528: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
70529: LD_VAR 0 3
70533: NOT
70534: PUSH
70535: LD_EXP 60
70539: PUSH
70540: LD_VAR 0 2
70544: ARRAY
70545: NOT
70546: OR
70547: PUSH
70548: LD_EXP 23
70552: PUSH
70553: LD_VAR 0 2
70557: ARRAY
70558: PPUSH
70559: LD_INT 2
70561: PUSH
70562: LD_INT 30
70564: PUSH
70565: LD_INT 0
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: PUSH
70572: LD_INT 30
70574: PUSH
70575: LD_INT 1
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: LIST
70586: PPUSH
70587: CALL_OW 72
70591: NOT
70592: OR
70593: IFFALSE 70643
// begin if mc_deposits_finder [ i ] then
70595: LD_EXP 61
70599: PUSH
70600: LD_VAR 0 2
70604: ARRAY
70605: IFFALSE 70641
// begin MC_Reset ( i , 125 ) ;
70607: LD_VAR 0 2
70611: PPUSH
70612: LD_INT 125
70614: PPUSH
70615: CALL 53746 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
70619: LD_ADDR_EXP 61
70623: PUSH
70624: LD_EXP 61
70628: PPUSH
70629: LD_VAR 0 2
70633: PPUSH
70634: EMPTY
70635: PPUSH
70636: CALL_OW 1
70640: ST_TO_ADDR
// end ; continue ;
70641: GO 70495
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
70643: LD_EXP 60
70647: PUSH
70648: LD_VAR 0 2
70652: ARRAY
70653: PUSH
70654: LD_INT 1
70656: ARRAY
70657: PUSH
70658: LD_INT 3
70660: ARRAY
70661: PUSH
70662: LD_INT 1
70664: EQUAL
70665: PUSH
70666: LD_INT 20
70668: PPUSH
70669: LD_EXP 49
70673: PUSH
70674: LD_VAR 0 2
70678: ARRAY
70679: PPUSH
70680: CALL_OW 321
70684: PUSH
70685: LD_INT 2
70687: NONEQUAL
70688: AND
70689: IFFALSE 70739
// begin if mc_deposits_finder [ i ] then
70691: LD_EXP 61
70695: PUSH
70696: LD_VAR 0 2
70700: ARRAY
70701: IFFALSE 70737
// begin MC_Reset ( i , 125 ) ;
70703: LD_VAR 0 2
70707: PPUSH
70708: LD_INT 125
70710: PPUSH
70711: CALL 53746 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
70715: LD_ADDR_EXP 61
70719: PUSH
70720: LD_EXP 61
70724: PPUSH
70725: LD_VAR 0 2
70729: PPUSH
70730: EMPTY
70731: PPUSH
70732: CALL_OW 1
70736: ST_TO_ADDR
// end ; continue ;
70737: GO 70495
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
70739: LD_EXP 60
70743: PUSH
70744: LD_VAR 0 2
70748: ARRAY
70749: PUSH
70750: LD_INT 1
70752: ARRAY
70753: PUSH
70754: LD_INT 1
70756: ARRAY
70757: PPUSH
70758: LD_EXP 60
70762: PUSH
70763: LD_VAR 0 2
70767: ARRAY
70768: PUSH
70769: LD_INT 1
70771: ARRAY
70772: PUSH
70773: LD_INT 2
70775: ARRAY
70776: PPUSH
70777: LD_EXP 49
70781: PUSH
70782: LD_VAR 0 2
70786: ARRAY
70787: PPUSH
70788: CALL_OW 440
70792: IFFALSE 70835
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
70794: LD_ADDR_EXP 60
70798: PUSH
70799: LD_EXP 60
70803: PPUSH
70804: LD_VAR 0 2
70808: PPUSH
70809: LD_EXP 60
70813: PUSH
70814: LD_VAR 0 2
70818: ARRAY
70819: PPUSH
70820: LD_INT 1
70822: PPUSH
70823: CALL_OW 3
70827: PPUSH
70828: CALL_OW 1
70832: ST_TO_ADDR
70833: GO 71082
// begin if not mc_deposits_finder [ i ] then
70835: LD_EXP 61
70839: PUSH
70840: LD_VAR 0 2
70844: ARRAY
70845: NOT
70846: IFFALSE 70898
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
70848: LD_ADDR_EXP 61
70852: PUSH
70853: LD_EXP 61
70857: PPUSH
70858: LD_VAR 0 2
70862: PPUSH
70863: LD_VAR 0 3
70867: PUSH
70868: LD_INT 1
70870: ARRAY
70871: PUSH
70872: EMPTY
70873: LIST
70874: PPUSH
70875: CALL_OW 1
70879: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
70880: LD_VAR 0 3
70884: PUSH
70885: LD_INT 1
70887: ARRAY
70888: PPUSH
70889: LD_INT 125
70891: PPUSH
70892: CALL_OW 109
// end else
70896: GO 71082
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
70898: LD_EXP 61
70902: PUSH
70903: LD_VAR 0 2
70907: ARRAY
70908: PUSH
70909: LD_INT 1
70911: ARRAY
70912: PPUSH
70913: CALL_OW 310
70917: IFFALSE 70940
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
70919: LD_EXP 61
70923: PUSH
70924: LD_VAR 0 2
70928: ARRAY
70929: PUSH
70930: LD_INT 1
70932: ARRAY
70933: PPUSH
70934: CALL_OW 122
70938: GO 71082
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
70940: LD_EXP 61
70944: PUSH
70945: LD_VAR 0 2
70949: ARRAY
70950: PUSH
70951: LD_INT 1
70953: ARRAY
70954: PPUSH
70955: CALL_OW 314
70959: NOT
70960: PUSH
70961: LD_EXP 61
70965: PUSH
70966: LD_VAR 0 2
70970: ARRAY
70971: PUSH
70972: LD_INT 1
70974: ARRAY
70975: PPUSH
70976: LD_EXP 60
70980: PUSH
70981: LD_VAR 0 2
70985: ARRAY
70986: PUSH
70987: LD_INT 1
70989: ARRAY
70990: PUSH
70991: LD_INT 1
70993: ARRAY
70994: PPUSH
70995: LD_EXP 60
70999: PUSH
71000: LD_VAR 0 2
71004: ARRAY
71005: PUSH
71006: LD_INT 1
71008: ARRAY
71009: PUSH
71010: LD_INT 2
71012: ARRAY
71013: PPUSH
71014: CALL_OW 297
71018: PUSH
71019: LD_INT 6
71021: GREATER
71022: AND
71023: IFFALSE 71082
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71025: LD_EXP 61
71029: PUSH
71030: LD_VAR 0 2
71034: ARRAY
71035: PUSH
71036: LD_INT 1
71038: ARRAY
71039: PPUSH
71040: LD_EXP 60
71044: PUSH
71045: LD_VAR 0 2
71049: ARRAY
71050: PUSH
71051: LD_INT 1
71053: ARRAY
71054: PUSH
71055: LD_INT 1
71057: ARRAY
71058: PPUSH
71059: LD_EXP 60
71063: PUSH
71064: LD_VAR 0 2
71068: ARRAY
71069: PUSH
71070: LD_INT 1
71072: ARRAY
71073: PUSH
71074: LD_INT 2
71076: ARRAY
71077: PPUSH
71078: CALL_OW 111
// end ; end ; end ;
71082: GO 70495
71084: POP
71085: POP
// end ;
71086: LD_VAR 0 1
71090: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71091: LD_INT 0
71093: PPUSH
71094: PPUSH
71095: PPUSH
71096: PPUSH
71097: PPUSH
71098: PPUSH
71099: PPUSH
71100: PPUSH
71101: PPUSH
71102: PPUSH
71103: PPUSH
// if not mc_bases then
71104: LD_EXP 23
71108: NOT
71109: IFFALSE 71113
// exit ;
71111: GO 72053
// for i = 1 to mc_bases do
71113: LD_ADDR_VAR 0 2
71117: PUSH
71118: DOUBLE
71119: LD_INT 1
71121: DEC
71122: ST_TO_ADDR
71123: LD_EXP 23
71127: PUSH
71128: FOR_TO
71129: IFFALSE 72051
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71131: LD_EXP 23
71135: PUSH
71136: LD_VAR 0 2
71140: ARRAY
71141: NOT
71142: PUSH
71143: LD_EXP 46
71147: PUSH
71148: LD_VAR 0 2
71152: ARRAY
71153: OR
71154: IFFALSE 71158
// continue ;
71156: GO 71128
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71158: LD_ADDR_VAR 0 7
71162: PUSH
71163: LD_EXP 23
71167: PUSH
71168: LD_VAR 0 2
71172: ARRAY
71173: PUSH
71174: LD_INT 1
71176: ARRAY
71177: PPUSH
71178: CALL_OW 248
71182: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71183: LD_VAR 0 7
71187: PUSH
71188: LD_INT 3
71190: EQUAL
71191: PUSH
71192: LD_EXP 42
71196: PUSH
71197: LD_VAR 0 2
71201: ARRAY
71202: PUSH
71203: LD_EXP 45
71207: PUSH
71208: LD_VAR 0 2
71212: ARRAY
71213: UNION
71214: PPUSH
71215: LD_INT 33
71217: PUSH
71218: LD_INT 2
71220: PUSH
71221: EMPTY
71222: LIST
71223: LIST
71224: PPUSH
71225: CALL_OW 72
71229: NOT
71230: OR
71231: IFFALSE 71235
// continue ;
71233: GO 71128
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71235: LD_ADDR_VAR 0 9
71239: PUSH
71240: LD_EXP 23
71244: PUSH
71245: LD_VAR 0 2
71249: ARRAY
71250: PPUSH
71251: LD_INT 30
71253: PUSH
71254: LD_INT 36
71256: PUSH
71257: EMPTY
71258: LIST
71259: LIST
71260: PPUSH
71261: CALL_OW 72
71265: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71266: LD_ADDR_VAR 0 10
71270: PUSH
71271: LD_EXP 42
71275: PUSH
71276: LD_VAR 0 2
71280: ARRAY
71281: PPUSH
71282: LD_INT 34
71284: PUSH
71285: LD_INT 31
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PPUSH
71292: CALL_OW 72
71296: ST_TO_ADDR
// if not cts and not mcts then
71297: LD_VAR 0 9
71301: NOT
71302: PUSH
71303: LD_VAR 0 10
71307: NOT
71308: AND
71309: IFFALSE 71313
// continue ;
71311: GO 71128
// x := cts ;
71313: LD_ADDR_VAR 0 11
71317: PUSH
71318: LD_VAR 0 9
71322: ST_TO_ADDR
// if not x then
71323: LD_VAR 0 11
71327: NOT
71328: IFFALSE 71340
// x := mcts ;
71330: LD_ADDR_VAR 0 11
71334: PUSH
71335: LD_VAR 0 10
71339: ST_TO_ADDR
// if not x then
71340: LD_VAR 0 11
71344: NOT
71345: IFFALSE 71349
// continue ;
71347: GO 71128
// if mc_remote_driver [ i ] then
71349: LD_EXP 63
71353: PUSH
71354: LD_VAR 0 2
71358: ARRAY
71359: IFFALSE 71746
// for j in mc_remote_driver [ i ] do
71361: LD_ADDR_VAR 0 3
71365: PUSH
71366: LD_EXP 63
71370: PUSH
71371: LD_VAR 0 2
71375: ARRAY
71376: PUSH
71377: FOR_IN
71378: IFFALSE 71744
// begin if GetClass ( j ) <> 3 then
71380: LD_VAR 0 3
71384: PPUSH
71385: CALL_OW 257
71389: PUSH
71390: LD_INT 3
71392: NONEQUAL
71393: IFFALSE 71446
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71395: LD_ADDR_EXP 63
71399: PUSH
71400: LD_EXP 63
71404: PPUSH
71405: LD_VAR 0 2
71409: PPUSH
71410: LD_EXP 63
71414: PUSH
71415: LD_VAR 0 2
71419: ARRAY
71420: PUSH
71421: LD_VAR 0 3
71425: DIFF
71426: PPUSH
71427: CALL_OW 1
71431: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71432: LD_VAR 0 3
71436: PPUSH
71437: LD_INT 0
71439: PPUSH
71440: CALL_OW 109
// continue ;
71444: GO 71377
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71446: LD_EXP 42
71450: PUSH
71451: LD_VAR 0 2
71455: ARRAY
71456: PPUSH
71457: LD_INT 34
71459: PUSH
71460: LD_INT 31
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PUSH
71467: LD_INT 58
71469: PUSH
71470: EMPTY
71471: LIST
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PPUSH
71477: CALL_OW 72
71481: PUSH
71482: LD_VAR 0 3
71486: PPUSH
71487: CALL 45061 0 1
71491: NOT
71492: AND
71493: IFFALSE 71564
// begin if IsInUnit ( j ) then
71495: LD_VAR 0 3
71499: PPUSH
71500: CALL_OW 310
71504: IFFALSE 71515
// ComExitBuilding ( j ) ;
71506: LD_VAR 0 3
71510: PPUSH
71511: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
71515: LD_VAR 0 3
71519: PPUSH
71520: LD_EXP 42
71524: PUSH
71525: LD_VAR 0 2
71529: ARRAY
71530: PPUSH
71531: LD_INT 34
71533: PUSH
71534: LD_INT 31
71536: PUSH
71537: EMPTY
71538: LIST
71539: LIST
71540: PUSH
71541: LD_INT 58
71543: PUSH
71544: EMPTY
71545: LIST
71546: PUSH
71547: EMPTY
71548: LIST
71549: LIST
71550: PPUSH
71551: CALL_OW 72
71555: PUSH
71556: LD_INT 1
71558: ARRAY
71559: PPUSH
71560: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
71564: LD_VAR 0 3
71568: PPUSH
71569: CALL_OW 310
71573: NOT
71574: PUSH
71575: LD_VAR 0 3
71579: PPUSH
71580: CALL_OW 310
71584: PPUSH
71585: CALL_OW 266
71589: PUSH
71590: LD_INT 36
71592: NONEQUAL
71593: PUSH
71594: LD_VAR 0 3
71598: PPUSH
71599: CALL 45061 0 1
71603: NOT
71604: AND
71605: OR
71606: IFFALSE 71742
// begin if IsInUnit ( j ) then
71608: LD_VAR 0 3
71612: PPUSH
71613: CALL_OW 310
71617: IFFALSE 71628
// ComExitBuilding ( j ) ;
71619: LD_VAR 0 3
71623: PPUSH
71624: CALL_OW 122
// ct := 0 ;
71628: LD_ADDR_VAR 0 8
71632: PUSH
71633: LD_INT 0
71635: ST_TO_ADDR
// for k in x do
71636: LD_ADDR_VAR 0 4
71640: PUSH
71641: LD_VAR 0 11
71645: PUSH
71646: FOR_IN
71647: IFFALSE 71720
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
71649: LD_VAR 0 4
71653: PPUSH
71654: CALL_OW 264
71658: PUSH
71659: LD_INT 31
71661: EQUAL
71662: PUSH
71663: LD_VAR 0 4
71667: PPUSH
71668: CALL_OW 311
71672: NOT
71673: AND
71674: PUSH
71675: LD_VAR 0 4
71679: PPUSH
71680: CALL_OW 266
71684: PUSH
71685: LD_INT 36
71687: EQUAL
71688: PUSH
71689: LD_VAR 0 4
71693: PPUSH
71694: CALL_OW 313
71698: PUSH
71699: LD_INT 3
71701: LESS
71702: AND
71703: OR
71704: IFFALSE 71718
// begin ct := k ;
71706: LD_ADDR_VAR 0 8
71710: PUSH
71711: LD_VAR 0 4
71715: ST_TO_ADDR
// break ;
71716: GO 71720
// end ;
71718: GO 71646
71720: POP
71721: POP
// if ct then
71722: LD_VAR 0 8
71726: IFFALSE 71742
// ComEnterUnit ( j , ct ) ;
71728: LD_VAR 0 3
71732: PPUSH
71733: LD_VAR 0 8
71737: PPUSH
71738: CALL_OW 120
// end ; end ;
71742: GO 71377
71744: POP
71745: POP
// places := 0 ;
71746: LD_ADDR_VAR 0 5
71750: PUSH
71751: LD_INT 0
71753: ST_TO_ADDR
// for j = 1 to x do
71754: LD_ADDR_VAR 0 3
71758: PUSH
71759: DOUBLE
71760: LD_INT 1
71762: DEC
71763: ST_TO_ADDR
71764: LD_VAR 0 11
71768: PUSH
71769: FOR_TO
71770: IFFALSE 71846
// if GetWeapon ( x [ j ] ) = ar_control_tower then
71772: LD_VAR 0 11
71776: PUSH
71777: LD_VAR 0 3
71781: ARRAY
71782: PPUSH
71783: CALL_OW 264
71787: PUSH
71788: LD_INT 31
71790: EQUAL
71791: IFFALSE 71809
// places := places + 1 else
71793: LD_ADDR_VAR 0 5
71797: PUSH
71798: LD_VAR 0 5
71802: PUSH
71803: LD_INT 1
71805: PLUS
71806: ST_TO_ADDR
71807: GO 71844
// if GetBType ( x [ j ] ) = b_control_tower then
71809: LD_VAR 0 11
71813: PUSH
71814: LD_VAR 0 3
71818: ARRAY
71819: PPUSH
71820: CALL_OW 266
71824: PUSH
71825: LD_INT 36
71827: EQUAL
71828: IFFALSE 71844
// places := places + 3 ;
71830: LD_ADDR_VAR 0 5
71834: PUSH
71835: LD_VAR 0 5
71839: PUSH
71840: LD_INT 3
71842: PLUS
71843: ST_TO_ADDR
71844: GO 71769
71846: POP
71847: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
71848: LD_VAR 0 5
71852: PUSH
71853: LD_INT 0
71855: EQUAL
71856: PUSH
71857: LD_VAR 0 5
71861: PUSH
71862: LD_EXP 63
71866: PUSH
71867: LD_VAR 0 2
71871: ARRAY
71872: LESSEQUAL
71873: OR
71874: IFFALSE 71878
// continue ;
71876: GO 71128
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
71878: LD_ADDR_VAR 0 6
71882: PUSH
71883: LD_EXP 23
71887: PUSH
71888: LD_VAR 0 2
71892: ARRAY
71893: PPUSH
71894: LD_INT 25
71896: PUSH
71897: LD_INT 3
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PPUSH
71904: CALL_OW 72
71908: PUSH
71909: LD_EXP 63
71913: PUSH
71914: LD_VAR 0 2
71918: ARRAY
71919: DIFF
71920: PPUSH
71921: LD_INT 3
71923: PPUSH
71924: CALL 45961 0 2
71928: ST_TO_ADDR
// for j in tmp do
71929: LD_ADDR_VAR 0 3
71933: PUSH
71934: LD_VAR 0 6
71938: PUSH
71939: FOR_IN
71940: IFFALSE 71975
// if GetTag ( j ) > 0 then
71942: LD_VAR 0 3
71946: PPUSH
71947: CALL_OW 110
71951: PUSH
71952: LD_INT 0
71954: GREATER
71955: IFFALSE 71973
// tmp := tmp diff j ;
71957: LD_ADDR_VAR 0 6
71961: PUSH
71962: LD_VAR 0 6
71966: PUSH
71967: LD_VAR 0 3
71971: DIFF
71972: ST_TO_ADDR
71973: GO 71939
71975: POP
71976: POP
// if not tmp then
71977: LD_VAR 0 6
71981: NOT
71982: IFFALSE 71986
// continue ;
71984: GO 71128
// if places then
71986: LD_VAR 0 5
71990: IFFALSE 72049
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
71992: LD_ADDR_EXP 63
71996: PUSH
71997: LD_EXP 63
72001: PPUSH
72002: LD_VAR 0 2
72006: PPUSH
72007: LD_EXP 63
72011: PUSH
72012: LD_VAR 0 2
72016: ARRAY
72017: PUSH
72018: LD_VAR 0 6
72022: PUSH
72023: LD_INT 1
72025: ARRAY
72026: UNION
72027: PPUSH
72028: CALL_OW 1
72032: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72033: LD_VAR 0 6
72037: PUSH
72038: LD_INT 1
72040: ARRAY
72041: PPUSH
72042: LD_INT 126
72044: PPUSH
72045: CALL_OW 109
// end ; end ;
72049: GO 71128
72051: POP
72052: POP
// end ;
72053: LD_VAR 0 1
72057: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72058: LD_INT 0
72060: PPUSH
72061: PPUSH
72062: PPUSH
72063: PPUSH
72064: PPUSH
72065: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72066: LD_VAR 0 1
72070: NOT
72071: PUSH
72072: LD_VAR 0 2
72076: NOT
72077: OR
72078: PUSH
72079: LD_VAR 0 3
72083: NOT
72084: OR
72085: PUSH
72086: LD_VAR 0 4
72090: PUSH
72091: LD_INT 1
72093: PUSH
72094: LD_INT 2
72096: PUSH
72097: LD_INT 3
72099: PUSH
72100: LD_INT 4
72102: PUSH
72103: LD_INT 5
72105: PUSH
72106: LD_INT 8
72108: PUSH
72109: LD_INT 9
72111: PUSH
72112: LD_INT 15
72114: PUSH
72115: LD_INT 16
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: LIST
72122: LIST
72123: LIST
72124: LIST
72125: LIST
72126: LIST
72127: LIST
72128: IN
72129: NOT
72130: OR
72131: IFFALSE 72135
// exit ;
72133: GO 73035
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72135: LD_ADDR_VAR 0 2
72139: PUSH
72140: LD_VAR 0 2
72144: PPUSH
72145: LD_INT 21
72147: PUSH
72148: LD_INT 3
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: PUSH
72155: LD_INT 24
72157: PUSH
72158: LD_INT 250
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: EMPTY
72166: LIST
72167: LIST
72168: PPUSH
72169: CALL_OW 72
72173: ST_TO_ADDR
// case class of 1 , 15 :
72174: LD_VAR 0 4
72178: PUSH
72179: LD_INT 1
72181: DOUBLE
72182: EQUAL
72183: IFTRUE 72193
72185: LD_INT 15
72187: DOUBLE
72188: EQUAL
72189: IFTRUE 72193
72191: GO 72278
72193: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72194: LD_ADDR_VAR 0 8
72198: PUSH
72199: LD_VAR 0 2
72203: PPUSH
72204: LD_INT 2
72206: PUSH
72207: LD_INT 30
72209: PUSH
72210: LD_INT 32
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PUSH
72217: LD_INT 30
72219: PUSH
72220: LD_INT 31
72222: PUSH
72223: EMPTY
72224: LIST
72225: LIST
72226: PUSH
72227: EMPTY
72228: LIST
72229: LIST
72230: LIST
72231: PPUSH
72232: CALL_OW 72
72236: PUSH
72237: LD_VAR 0 2
72241: PPUSH
72242: LD_INT 2
72244: PUSH
72245: LD_INT 30
72247: PUSH
72248: LD_INT 4
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 30
72257: PUSH
72258: LD_INT 5
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: LIST
72269: PPUSH
72270: CALL_OW 72
72274: ADD
72275: ST_TO_ADDR
72276: GO 72524
72278: LD_INT 2
72280: DOUBLE
72281: EQUAL
72282: IFTRUE 72292
72284: LD_INT 16
72286: DOUBLE
72287: EQUAL
72288: IFTRUE 72292
72290: GO 72338
72292: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72293: LD_ADDR_VAR 0 8
72297: PUSH
72298: LD_VAR 0 2
72302: PPUSH
72303: LD_INT 2
72305: PUSH
72306: LD_INT 30
72308: PUSH
72309: LD_INT 0
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 30
72318: PUSH
72319: LD_INT 1
72321: PUSH
72322: EMPTY
72323: LIST
72324: LIST
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: LIST
72330: PPUSH
72331: CALL_OW 72
72335: ST_TO_ADDR
72336: GO 72524
72338: LD_INT 3
72340: DOUBLE
72341: EQUAL
72342: IFTRUE 72346
72344: GO 72392
72346: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72347: LD_ADDR_VAR 0 8
72351: PUSH
72352: LD_VAR 0 2
72356: PPUSH
72357: LD_INT 2
72359: PUSH
72360: LD_INT 30
72362: PUSH
72363: LD_INT 2
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 30
72372: PUSH
72373: LD_INT 3
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: EMPTY
72381: LIST
72382: LIST
72383: LIST
72384: PPUSH
72385: CALL_OW 72
72389: ST_TO_ADDR
72390: GO 72524
72392: LD_INT 4
72394: DOUBLE
72395: EQUAL
72396: IFTRUE 72400
72398: GO 72457
72400: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72401: LD_ADDR_VAR 0 8
72405: PUSH
72406: LD_VAR 0 2
72410: PPUSH
72411: LD_INT 2
72413: PUSH
72414: LD_INT 30
72416: PUSH
72417: LD_INT 6
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 30
72426: PUSH
72427: LD_INT 7
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 30
72436: PUSH
72437: LD_INT 8
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: LIST
72448: LIST
72449: PPUSH
72450: CALL_OW 72
72454: ST_TO_ADDR
72455: GO 72524
72457: LD_INT 5
72459: DOUBLE
72460: EQUAL
72461: IFTRUE 72477
72463: LD_INT 8
72465: DOUBLE
72466: EQUAL
72467: IFTRUE 72477
72469: LD_INT 9
72471: DOUBLE
72472: EQUAL
72473: IFTRUE 72477
72475: GO 72523
72477: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
72478: LD_ADDR_VAR 0 8
72482: PUSH
72483: LD_VAR 0 2
72487: PPUSH
72488: LD_INT 2
72490: PUSH
72491: LD_INT 30
72493: PUSH
72494: LD_INT 4
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 30
72503: PUSH
72504: LD_INT 5
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: LIST
72515: PPUSH
72516: CALL_OW 72
72520: ST_TO_ADDR
72521: GO 72524
72523: POP
// if not tmp then
72524: LD_VAR 0 8
72528: NOT
72529: IFFALSE 72533
// exit ;
72531: GO 73035
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
72533: LD_VAR 0 4
72537: PUSH
72538: LD_INT 1
72540: PUSH
72541: LD_INT 15
72543: PUSH
72544: EMPTY
72545: LIST
72546: LIST
72547: IN
72548: PUSH
72549: LD_EXP 32
72553: PUSH
72554: LD_VAR 0 1
72558: ARRAY
72559: AND
72560: IFFALSE 72716
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
72562: LD_ADDR_VAR 0 9
72566: PUSH
72567: LD_EXP 32
72571: PUSH
72572: LD_VAR 0 1
72576: ARRAY
72577: PUSH
72578: LD_INT 1
72580: ARRAY
72581: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
72582: LD_VAR 0 9
72586: PUSH
72587: LD_EXP 33
72591: PUSH
72592: LD_VAR 0 1
72596: ARRAY
72597: IN
72598: NOT
72599: IFFALSE 72714
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
72601: LD_ADDR_EXP 33
72605: PUSH
72606: LD_EXP 33
72610: PPUSH
72611: LD_VAR 0 1
72615: PUSH
72616: LD_EXP 33
72620: PUSH
72621: LD_VAR 0 1
72625: ARRAY
72626: PUSH
72627: LD_INT 1
72629: PLUS
72630: PUSH
72631: EMPTY
72632: LIST
72633: LIST
72634: PPUSH
72635: LD_VAR 0 9
72639: PPUSH
72640: CALL 15704 0 3
72644: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
72645: LD_ADDR_EXP 32
72649: PUSH
72650: LD_EXP 32
72654: PPUSH
72655: LD_VAR 0 1
72659: PPUSH
72660: LD_EXP 32
72664: PUSH
72665: LD_VAR 0 1
72669: ARRAY
72670: PUSH
72671: LD_VAR 0 9
72675: DIFF
72676: PPUSH
72677: CALL_OW 1
72681: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
72682: LD_VAR 0 3
72686: PPUSH
72687: LD_EXP 33
72691: PUSH
72692: LD_VAR 0 1
72696: ARRAY
72697: PUSH
72698: LD_EXP 33
72702: PUSH
72703: LD_VAR 0 1
72707: ARRAY
72708: ARRAY
72709: PPUSH
72710: CALL_OW 120
// end ; exit ;
72714: GO 73035
// end ; if tmp > 1 then
72716: LD_VAR 0 8
72720: PUSH
72721: LD_INT 1
72723: GREATER
72724: IFFALSE 72828
// for i = 2 to tmp do
72726: LD_ADDR_VAR 0 6
72730: PUSH
72731: DOUBLE
72732: LD_INT 2
72734: DEC
72735: ST_TO_ADDR
72736: LD_VAR 0 8
72740: PUSH
72741: FOR_TO
72742: IFFALSE 72826
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
72744: LD_VAR 0 8
72748: PUSH
72749: LD_VAR 0 6
72753: ARRAY
72754: PPUSH
72755: CALL_OW 461
72759: PUSH
72760: LD_INT 6
72762: EQUAL
72763: IFFALSE 72824
// begin x := tmp [ i ] ;
72765: LD_ADDR_VAR 0 9
72769: PUSH
72770: LD_VAR 0 8
72774: PUSH
72775: LD_VAR 0 6
72779: ARRAY
72780: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
72781: LD_ADDR_VAR 0 8
72785: PUSH
72786: LD_VAR 0 8
72790: PPUSH
72791: LD_VAR 0 6
72795: PPUSH
72796: CALL_OW 3
72800: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
72801: LD_ADDR_VAR 0 8
72805: PUSH
72806: LD_VAR 0 8
72810: PPUSH
72811: LD_INT 1
72813: PPUSH
72814: LD_VAR 0 9
72818: PPUSH
72819: CALL_OW 2
72823: ST_TO_ADDR
// end ;
72824: GO 72741
72826: POP
72827: POP
// for i in tmp do
72828: LD_ADDR_VAR 0 6
72832: PUSH
72833: LD_VAR 0 8
72837: PUSH
72838: FOR_IN
72839: IFFALSE 72908
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
72841: LD_VAR 0 6
72845: PPUSH
72846: CALL_OW 313
72850: PUSH
72851: LD_INT 6
72853: LESS
72854: PUSH
72855: LD_VAR 0 6
72859: PPUSH
72860: CALL_OW 266
72864: PUSH
72865: LD_INT 31
72867: PUSH
72868: LD_INT 32
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: IN
72875: NOT
72876: AND
72877: PUSH
72878: LD_VAR 0 6
72882: PPUSH
72883: CALL_OW 313
72887: PUSH
72888: LD_INT 0
72890: EQUAL
72891: OR
72892: IFFALSE 72906
// begin j := i ;
72894: LD_ADDR_VAR 0 7
72898: PUSH
72899: LD_VAR 0 6
72903: ST_TO_ADDR
// break ;
72904: GO 72908
// end ; end ;
72906: GO 72838
72908: POP
72909: POP
// if j then
72910: LD_VAR 0 7
72914: IFFALSE 72932
// ComEnterUnit ( unit , j ) else
72916: LD_VAR 0 3
72920: PPUSH
72921: LD_VAR 0 7
72925: PPUSH
72926: CALL_OW 120
72930: GO 73035
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72932: LD_ADDR_VAR 0 10
72936: PUSH
72937: LD_VAR 0 2
72941: PPUSH
72942: LD_INT 2
72944: PUSH
72945: LD_INT 30
72947: PUSH
72948: LD_INT 0
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: PUSH
72955: LD_INT 30
72957: PUSH
72958: LD_INT 1
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: LIST
72969: PPUSH
72970: CALL_OW 72
72974: ST_TO_ADDR
// if depot then
72975: LD_VAR 0 10
72979: IFFALSE 73035
// begin depot := NearestUnitToUnit ( depot , unit ) ;
72981: LD_ADDR_VAR 0 10
72985: PUSH
72986: LD_VAR 0 10
72990: PPUSH
72991: LD_VAR 0 3
72995: PPUSH
72996: CALL_OW 74
73000: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73001: LD_VAR 0 3
73005: PPUSH
73006: LD_VAR 0 10
73010: PPUSH
73011: CALL_OW 296
73015: PUSH
73016: LD_INT 10
73018: GREATER
73019: IFFALSE 73035
// ComStandNearbyBuilding ( unit , depot ) ;
73021: LD_VAR 0 3
73025: PPUSH
73026: LD_VAR 0 10
73030: PPUSH
73031: CALL 12282 0 2
// end ; end ; end ;
73035: LD_VAR 0 5
73039: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73040: LD_INT 0
73042: PPUSH
73043: PPUSH
73044: PPUSH
73045: PPUSH
// if not mc_bases then
73046: LD_EXP 23
73050: NOT
73051: IFFALSE 73055
// exit ;
73053: GO 73294
// for i = 1 to mc_bases do
73055: LD_ADDR_VAR 0 2
73059: PUSH
73060: DOUBLE
73061: LD_INT 1
73063: DEC
73064: ST_TO_ADDR
73065: LD_EXP 23
73069: PUSH
73070: FOR_TO
73071: IFFALSE 73292
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73073: LD_ADDR_VAR 0 4
73077: PUSH
73078: LD_EXP 23
73082: PUSH
73083: LD_VAR 0 2
73087: ARRAY
73088: PPUSH
73089: LD_INT 21
73091: PUSH
73092: LD_INT 1
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PPUSH
73099: CALL_OW 72
73103: PUSH
73104: LD_EXP 52
73108: PUSH
73109: LD_VAR 0 2
73113: ARRAY
73114: UNION
73115: ST_TO_ADDR
// if not tmp then
73116: LD_VAR 0 4
73120: NOT
73121: IFFALSE 73125
// continue ;
73123: GO 73070
// for j in tmp do
73125: LD_ADDR_VAR 0 3
73129: PUSH
73130: LD_VAR 0 4
73134: PUSH
73135: FOR_IN
73136: IFFALSE 73288
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73138: LD_VAR 0 3
73142: PPUSH
73143: CALL_OW 110
73147: NOT
73148: PUSH
73149: LD_VAR 0 3
73153: PPUSH
73154: CALL_OW 314
73158: NOT
73159: AND
73160: PUSH
73161: LD_VAR 0 3
73165: PPUSH
73166: CALL_OW 311
73170: NOT
73171: AND
73172: PUSH
73173: LD_VAR 0 3
73177: PPUSH
73178: CALL_OW 310
73182: NOT
73183: AND
73184: PUSH
73185: LD_VAR 0 3
73189: PUSH
73190: LD_EXP 26
73194: PUSH
73195: LD_VAR 0 2
73199: ARRAY
73200: PUSH
73201: LD_INT 1
73203: ARRAY
73204: IN
73205: NOT
73206: AND
73207: PUSH
73208: LD_VAR 0 3
73212: PUSH
73213: LD_EXP 26
73217: PUSH
73218: LD_VAR 0 2
73222: ARRAY
73223: PUSH
73224: LD_INT 2
73226: ARRAY
73227: IN
73228: NOT
73229: AND
73230: PUSH
73231: LD_VAR 0 3
73235: PUSH
73236: LD_EXP 35
73240: PUSH
73241: LD_VAR 0 2
73245: ARRAY
73246: IN
73247: NOT
73248: AND
73249: IFFALSE 73286
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73251: LD_VAR 0 2
73255: PPUSH
73256: LD_EXP 23
73260: PUSH
73261: LD_VAR 0 2
73265: ARRAY
73266: PPUSH
73267: LD_VAR 0 3
73271: PPUSH
73272: LD_VAR 0 3
73276: PPUSH
73277: CALL_OW 257
73281: PPUSH
73282: CALL 72058 0 4
// end ;
73286: GO 73135
73288: POP
73289: POP
// end ;
73290: GO 73070
73292: POP
73293: POP
// end ;
73294: LD_VAR 0 1
73298: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73299: LD_INT 0
73301: PPUSH
73302: PPUSH
73303: PPUSH
73304: PPUSH
73305: PPUSH
73306: PPUSH
// if not mc_bases [ base ] then
73307: LD_EXP 23
73311: PUSH
73312: LD_VAR 0 1
73316: ARRAY
73317: NOT
73318: IFFALSE 73322
// exit ;
73320: GO 73504
// tmp := [ ] ;
73322: LD_ADDR_VAR 0 6
73326: PUSH
73327: EMPTY
73328: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73329: LD_ADDR_VAR 0 7
73333: PUSH
73334: LD_VAR 0 3
73338: PPUSH
73339: LD_INT 0
73341: PPUSH
73342: CALL_OW 517
73346: ST_TO_ADDR
// if not list then
73347: LD_VAR 0 7
73351: NOT
73352: IFFALSE 73356
// exit ;
73354: GO 73504
// for i = 1 to amount do
73356: LD_ADDR_VAR 0 5
73360: PUSH
73361: DOUBLE
73362: LD_INT 1
73364: DEC
73365: ST_TO_ADDR
73366: LD_VAR 0 2
73370: PUSH
73371: FOR_TO
73372: IFFALSE 73452
// begin x := rand ( 1 , list [ 1 ] ) ;
73374: LD_ADDR_VAR 0 8
73378: PUSH
73379: LD_INT 1
73381: PPUSH
73382: LD_VAR 0 7
73386: PUSH
73387: LD_INT 1
73389: ARRAY
73390: PPUSH
73391: CALL_OW 12
73395: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73396: LD_ADDR_VAR 0 6
73400: PUSH
73401: LD_VAR 0 6
73405: PPUSH
73406: LD_VAR 0 5
73410: PPUSH
73411: LD_VAR 0 7
73415: PUSH
73416: LD_INT 1
73418: ARRAY
73419: PUSH
73420: LD_VAR 0 8
73424: ARRAY
73425: PUSH
73426: LD_VAR 0 7
73430: PUSH
73431: LD_INT 2
73433: ARRAY
73434: PUSH
73435: LD_VAR 0 8
73439: ARRAY
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: PPUSH
73445: CALL_OW 1
73449: ST_TO_ADDR
// end ;
73450: GO 73371
73452: POP
73453: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
73454: LD_ADDR_EXP 36
73458: PUSH
73459: LD_EXP 36
73463: PPUSH
73464: LD_VAR 0 1
73468: PPUSH
73469: LD_VAR 0 6
73473: PPUSH
73474: CALL_OW 1
73478: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
73479: LD_ADDR_EXP 38
73483: PUSH
73484: LD_EXP 38
73488: PPUSH
73489: LD_VAR 0 1
73493: PPUSH
73494: LD_VAR 0 3
73498: PPUSH
73499: CALL_OW 1
73503: ST_TO_ADDR
// end ;
73504: LD_VAR 0 4
73508: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
73509: LD_INT 0
73511: PPUSH
// if not mc_bases [ base ] then
73512: LD_EXP 23
73516: PUSH
73517: LD_VAR 0 1
73521: ARRAY
73522: NOT
73523: IFFALSE 73527
// exit ;
73525: GO 73552
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
73527: LD_ADDR_EXP 28
73531: PUSH
73532: LD_EXP 28
73536: PPUSH
73537: LD_VAR 0 1
73541: PPUSH
73542: LD_VAR 0 2
73546: PPUSH
73547: CALL_OW 1
73551: ST_TO_ADDR
// end ;
73552: LD_VAR 0 3
73556: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
73557: LD_INT 0
73559: PPUSH
// if not mc_bases [ base ] then
73560: LD_EXP 23
73564: PUSH
73565: LD_VAR 0 1
73569: ARRAY
73570: NOT
73571: IFFALSE 73575
// exit ;
73573: GO 73612
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
73575: LD_ADDR_EXP 28
73579: PUSH
73580: LD_EXP 28
73584: PPUSH
73585: LD_VAR 0 1
73589: PPUSH
73590: LD_EXP 28
73594: PUSH
73595: LD_VAR 0 1
73599: ARRAY
73600: PUSH
73601: LD_VAR 0 2
73605: UNION
73606: PPUSH
73607: CALL_OW 1
73611: ST_TO_ADDR
// end ;
73612: LD_VAR 0 3
73616: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
73617: LD_INT 0
73619: PPUSH
// if not mc_bases [ base ] then
73620: LD_EXP 23
73624: PUSH
73625: LD_VAR 0 1
73629: ARRAY
73630: NOT
73631: IFFALSE 73635
// exit ;
73633: GO 73660
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
73635: LD_ADDR_EXP 44
73639: PUSH
73640: LD_EXP 44
73644: PPUSH
73645: LD_VAR 0 1
73649: PPUSH
73650: LD_VAR 0 2
73654: PPUSH
73655: CALL_OW 1
73659: ST_TO_ADDR
// end ;
73660: LD_VAR 0 3
73664: RET
// export function MC_InsertProduceList ( base , components ) ; begin
73665: LD_INT 0
73667: PPUSH
// if not mc_bases [ base ] then
73668: LD_EXP 23
73672: PUSH
73673: LD_VAR 0 1
73677: ARRAY
73678: NOT
73679: IFFALSE 73683
// exit ;
73681: GO 73720
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
73683: LD_ADDR_EXP 44
73687: PUSH
73688: LD_EXP 44
73692: PPUSH
73693: LD_VAR 0 1
73697: PPUSH
73698: LD_EXP 44
73702: PUSH
73703: LD_VAR 0 1
73707: ARRAY
73708: PUSH
73709: LD_VAR 0 2
73713: ADD
73714: PPUSH
73715: CALL_OW 1
73719: ST_TO_ADDR
// end ;
73720: LD_VAR 0 3
73724: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
73725: LD_INT 0
73727: PPUSH
// if not mc_bases [ base ] then
73728: LD_EXP 23
73732: PUSH
73733: LD_VAR 0 1
73737: ARRAY
73738: NOT
73739: IFFALSE 73743
// exit ;
73741: GO 73797
// mc_defender := Replace ( mc_defender , base , deflist ) ;
73743: LD_ADDR_EXP 45
73747: PUSH
73748: LD_EXP 45
73752: PPUSH
73753: LD_VAR 0 1
73757: PPUSH
73758: LD_VAR 0 2
73762: PPUSH
73763: CALL_OW 1
73767: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
73768: LD_ADDR_EXP 34
73772: PUSH
73773: LD_EXP 34
73777: PPUSH
73778: LD_VAR 0 1
73782: PPUSH
73783: LD_VAR 0 2
73787: PUSH
73788: LD_INT 0
73790: PLUS
73791: PPUSH
73792: CALL_OW 1
73796: ST_TO_ADDR
// end ;
73797: LD_VAR 0 3
73801: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
73802: LD_INT 0
73804: PPUSH
// if not mc_bases [ base ] then
73805: LD_EXP 23
73809: PUSH
73810: LD_VAR 0 1
73814: ARRAY
73815: NOT
73816: IFFALSE 73820
// exit ;
73818: GO 73845
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
73820: LD_ADDR_EXP 34
73824: PUSH
73825: LD_EXP 34
73829: PPUSH
73830: LD_VAR 0 1
73834: PPUSH
73835: LD_VAR 0 2
73839: PPUSH
73840: CALL_OW 1
73844: ST_TO_ADDR
// end ;
73845: LD_VAR 0 3
73849: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
73850: LD_INT 0
73852: PPUSH
73853: PPUSH
73854: PPUSH
73855: PPUSH
// if not mc_bases [ base ] then
73856: LD_EXP 23
73860: PUSH
73861: LD_VAR 0 1
73865: ARRAY
73866: NOT
73867: IFFALSE 73871
// exit ;
73869: GO 73936
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
73871: LD_ADDR_EXP 43
73875: PUSH
73876: LD_EXP 43
73880: PPUSH
73881: LD_VAR 0 1
73885: PUSH
73886: LD_EXP 43
73890: PUSH
73891: LD_VAR 0 1
73895: ARRAY
73896: PUSH
73897: LD_INT 1
73899: PLUS
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PPUSH
73905: LD_VAR 0 1
73909: PUSH
73910: LD_VAR 0 2
73914: PUSH
73915: LD_VAR 0 3
73919: PUSH
73920: LD_VAR 0 4
73924: PUSH
73925: EMPTY
73926: LIST
73927: LIST
73928: LIST
73929: LIST
73930: PPUSH
73931: CALL 15704 0 3
73935: ST_TO_ADDR
// end ;
73936: LD_VAR 0 5
73940: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
73941: LD_INT 0
73943: PPUSH
// if not mc_bases [ base ] then
73944: LD_EXP 23
73948: PUSH
73949: LD_VAR 0 1
73953: ARRAY
73954: NOT
73955: IFFALSE 73959
// exit ;
73957: GO 73984
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
73959: LD_ADDR_EXP 60
73963: PUSH
73964: LD_EXP 60
73968: PPUSH
73969: LD_VAR 0 1
73973: PPUSH
73974: LD_VAR 0 2
73978: PPUSH
73979: CALL_OW 1
73983: ST_TO_ADDR
// end ;
73984: LD_VAR 0 3
73988: RET
// export function MC_GetMinesField ( base ) ; begin
73989: LD_INT 0
73991: PPUSH
// result := mc_mines [ base ] ;
73992: LD_ADDR_VAR 0 2
73996: PUSH
73997: LD_EXP 36
74001: PUSH
74002: LD_VAR 0 1
74006: ARRAY
74007: ST_TO_ADDR
// end ;
74008: LD_VAR 0 2
74012: RET
// export function MC_GetProduceList ( base ) ; begin
74013: LD_INT 0
74015: PPUSH
// result := mc_produce [ base ] ;
74016: LD_ADDR_VAR 0 2
74020: PUSH
74021: LD_EXP 44
74025: PUSH
74026: LD_VAR 0 1
74030: ARRAY
74031: ST_TO_ADDR
// end ;
74032: LD_VAR 0 2
74036: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74037: LD_INT 0
74039: PPUSH
74040: PPUSH
// if not mc_bases then
74041: LD_EXP 23
74045: NOT
74046: IFFALSE 74050
// exit ;
74048: GO 74115
// if mc_bases [ base ] then
74050: LD_EXP 23
74054: PUSH
74055: LD_VAR 0 1
74059: ARRAY
74060: IFFALSE 74115
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74062: LD_ADDR_VAR 0 3
74066: PUSH
74067: LD_EXP 23
74071: PUSH
74072: LD_VAR 0 1
74076: ARRAY
74077: PPUSH
74078: LD_INT 30
74080: PUSH
74081: LD_VAR 0 2
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PPUSH
74090: CALL_OW 72
74094: ST_TO_ADDR
// if result then
74095: LD_VAR 0 3
74099: IFFALSE 74115
// result := result [ 1 ] ;
74101: LD_ADDR_VAR 0 3
74105: PUSH
74106: LD_VAR 0 3
74110: PUSH
74111: LD_INT 1
74113: ARRAY
74114: ST_TO_ADDR
// end ; end ;
74115: LD_VAR 0 3
74119: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74120: LD_INT 0
74122: PPUSH
74123: PPUSH
// if not mc_bases then
74124: LD_EXP 23
74128: NOT
74129: IFFALSE 74133
// exit ;
74131: GO 74178
// if mc_bases [ base ] then
74133: LD_EXP 23
74137: PUSH
74138: LD_VAR 0 1
74142: ARRAY
74143: IFFALSE 74178
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74145: LD_ADDR_VAR 0 3
74149: PUSH
74150: LD_EXP 23
74154: PUSH
74155: LD_VAR 0 1
74159: ARRAY
74160: PPUSH
74161: LD_INT 30
74163: PUSH
74164: LD_VAR 0 2
74168: PUSH
74169: EMPTY
74170: LIST
74171: LIST
74172: PPUSH
74173: CALL_OW 72
74177: ST_TO_ADDR
// end ;
74178: LD_VAR 0 3
74182: RET
// export function MC_SetTame ( base , area ) ; begin
74183: LD_INT 0
74185: PPUSH
// if not mc_bases or not base then
74186: LD_EXP 23
74190: NOT
74191: PUSH
74192: LD_VAR 0 1
74196: NOT
74197: OR
74198: IFFALSE 74202
// exit ;
74200: GO 74227
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74202: LD_ADDR_EXP 51
74206: PUSH
74207: LD_EXP 51
74211: PPUSH
74212: LD_VAR 0 1
74216: PPUSH
74217: LD_VAR 0 2
74221: PPUSH
74222: CALL_OW 1
74226: ST_TO_ADDR
// end ;
74227: LD_VAR 0 3
74231: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74232: LD_INT 0
74234: PPUSH
74235: PPUSH
// if not mc_bases or not base then
74236: LD_EXP 23
74240: NOT
74241: PUSH
74242: LD_VAR 0 1
74246: NOT
74247: OR
74248: IFFALSE 74252
// exit ;
74250: GO 74354
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74252: LD_ADDR_VAR 0 4
74256: PUSH
74257: LD_EXP 23
74261: PUSH
74262: LD_VAR 0 1
74266: ARRAY
74267: PPUSH
74268: LD_INT 30
74270: PUSH
74271: LD_VAR 0 2
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PPUSH
74280: CALL_OW 72
74284: ST_TO_ADDR
// if not tmp then
74285: LD_VAR 0 4
74289: NOT
74290: IFFALSE 74294
// exit ;
74292: GO 74354
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74294: LD_ADDR_EXP 55
74298: PUSH
74299: LD_EXP 55
74303: PPUSH
74304: LD_VAR 0 1
74308: PPUSH
74309: LD_EXP 55
74313: PUSH
74314: LD_VAR 0 1
74318: ARRAY
74319: PPUSH
74320: LD_EXP 55
74324: PUSH
74325: LD_VAR 0 1
74329: ARRAY
74330: PUSH
74331: LD_INT 1
74333: PLUS
74334: PPUSH
74335: LD_VAR 0 4
74339: PUSH
74340: LD_INT 1
74342: ARRAY
74343: PPUSH
74344: CALL_OW 2
74348: PPUSH
74349: CALL_OW 1
74353: ST_TO_ADDR
// end ;
74354: LD_VAR 0 3
74358: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74359: LD_INT 0
74361: PPUSH
74362: PPUSH
// if not mc_bases or not base or not kinds then
74363: LD_EXP 23
74367: NOT
74368: PUSH
74369: LD_VAR 0 1
74373: NOT
74374: OR
74375: PUSH
74376: LD_VAR 0 2
74380: NOT
74381: OR
74382: IFFALSE 74386
// exit ;
74384: GO 74447
// for i in kinds do
74386: LD_ADDR_VAR 0 4
74390: PUSH
74391: LD_VAR 0 2
74395: PUSH
74396: FOR_IN
74397: IFFALSE 74445
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74399: LD_ADDR_EXP 57
74403: PUSH
74404: LD_EXP 57
74408: PPUSH
74409: LD_VAR 0 1
74413: PUSH
74414: LD_EXP 57
74418: PUSH
74419: LD_VAR 0 1
74423: ARRAY
74424: PUSH
74425: LD_INT 1
74427: PLUS
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PPUSH
74433: LD_VAR 0 4
74437: PPUSH
74438: CALL 15704 0 3
74442: ST_TO_ADDR
74443: GO 74396
74445: POP
74446: POP
// end ;
74447: LD_VAR 0 3
74451: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
74452: LD_INT 0
74454: PPUSH
// if not mc_bases or not base or not areas then
74455: LD_EXP 23
74459: NOT
74460: PUSH
74461: LD_VAR 0 1
74465: NOT
74466: OR
74467: PUSH
74468: LD_VAR 0 2
74472: NOT
74473: OR
74474: IFFALSE 74478
// exit ;
74476: GO 74503
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
74478: LD_ADDR_EXP 41
74482: PUSH
74483: LD_EXP 41
74487: PPUSH
74488: LD_VAR 0 1
74492: PPUSH
74493: LD_VAR 0 2
74497: PPUSH
74498: CALL_OW 1
74502: ST_TO_ADDR
// end ;
74503: LD_VAR 0 3
74507: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
74508: LD_INT 0
74510: PPUSH
// if not mc_bases or not base or not teleports_exit then
74511: LD_EXP 23
74515: NOT
74516: PUSH
74517: LD_VAR 0 1
74521: NOT
74522: OR
74523: PUSH
74524: LD_VAR 0 2
74528: NOT
74529: OR
74530: IFFALSE 74534
// exit ;
74532: GO 74559
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
74534: LD_ADDR_EXP 58
74538: PUSH
74539: LD_EXP 58
74543: PPUSH
74544: LD_VAR 0 1
74548: PPUSH
74549: LD_VAR 0 2
74553: PPUSH
74554: CALL_OW 1
74558: ST_TO_ADDR
// end ;
74559: LD_VAR 0 3
74563: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
74564: LD_INT 0
74566: PPUSH
74567: PPUSH
74568: PPUSH
// if not mc_bases or not base or not ext_list then
74569: LD_EXP 23
74573: NOT
74574: PUSH
74575: LD_VAR 0 1
74579: NOT
74580: OR
74581: PUSH
74582: LD_VAR 0 5
74586: NOT
74587: OR
74588: IFFALSE 74592
// exit ;
74590: GO 74765
// tmp := GetFacExtXYD ( x , y , d ) ;
74592: LD_ADDR_VAR 0 8
74596: PUSH
74597: LD_VAR 0 2
74601: PPUSH
74602: LD_VAR 0 3
74606: PPUSH
74607: LD_VAR 0 4
74611: PPUSH
74612: CALL 45091 0 3
74616: ST_TO_ADDR
// if not tmp then
74617: LD_VAR 0 8
74621: NOT
74622: IFFALSE 74626
// exit ;
74624: GO 74765
// for i in tmp do
74626: LD_ADDR_VAR 0 7
74630: PUSH
74631: LD_VAR 0 8
74635: PUSH
74636: FOR_IN
74637: IFFALSE 74763
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
74639: LD_ADDR_EXP 28
74643: PUSH
74644: LD_EXP 28
74648: PPUSH
74649: LD_VAR 0 1
74653: PPUSH
74654: LD_EXP 28
74658: PUSH
74659: LD_VAR 0 1
74663: ARRAY
74664: PPUSH
74665: LD_EXP 28
74669: PUSH
74670: LD_VAR 0 1
74674: ARRAY
74675: PUSH
74676: LD_INT 1
74678: PLUS
74679: PPUSH
74680: LD_VAR 0 5
74684: PUSH
74685: LD_INT 1
74687: ARRAY
74688: PUSH
74689: LD_VAR 0 7
74693: PUSH
74694: LD_INT 1
74696: ARRAY
74697: PUSH
74698: LD_VAR 0 7
74702: PUSH
74703: LD_INT 2
74705: ARRAY
74706: PUSH
74707: LD_VAR 0 7
74711: PUSH
74712: LD_INT 3
74714: ARRAY
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: LIST
74720: LIST
74721: PPUSH
74722: CALL_OW 2
74726: PPUSH
74727: CALL_OW 1
74731: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
74732: LD_ADDR_VAR 0 5
74736: PUSH
74737: LD_VAR 0 5
74741: PPUSH
74742: LD_INT 1
74744: PPUSH
74745: CALL_OW 3
74749: ST_TO_ADDR
// if not ext_list then
74750: LD_VAR 0 5
74754: NOT
74755: IFFALSE 74761
// exit ;
74757: POP
74758: POP
74759: GO 74765
// end ;
74761: GO 74636
74763: POP
74764: POP
// end ;
74765: LD_VAR 0 6
74769: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
74770: LD_INT 0
74772: PPUSH
// if not mc_bases or not base or not weapon_list then
74773: LD_EXP 23
74777: NOT
74778: PUSH
74779: LD_VAR 0 1
74783: NOT
74784: OR
74785: PUSH
74786: LD_VAR 0 2
74790: NOT
74791: OR
74792: IFFALSE 74796
// exit ;
74794: GO 74821
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
74796: LD_ADDR_EXP 62
74800: PUSH
74801: LD_EXP 62
74805: PPUSH
74806: LD_VAR 0 1
74810: PPUSH
74811: LD_VAR 0 2
74815: PPUSH
74816: CALL_OW 1
74820: ST_TO_ADDR
// end ;
74821: LD_VAR 0 3
74825: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
74826: LD_INT 0
74828: PPUSH
// if not mc_bases or not base or not tech_list then
74829: LD_EXP 23
74833: NOT
74834: PUSH
74835: LD_VAR 0 1
74839: NOT
74840: OR
74841: PUSH
74842: LD_VAR 0 2
74846: NOT
74847: OR
74848: IFFALSE 74852
// exit ;
74850: GO 74877
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
74852: LD_ADDR_EXP 50
74856: PUSH
74857: LD_EXP 50
74861: PPUSH
74862: LD_VAR 0 1
74866: PPUSH
74867: LD_VAR 0 2
74871: PPUSH
74872: CALL_OW 1
74876: ST_TO_ADDR
// end ;
74877: LD_VAR 0 3
74881: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
74882: LD_INT 0
74884: PPUSH
// if not mc_bases or not parking_area or not base then
74885: LD_EXP 23
74889: NOT
74890: PUSH
74891: LD_VAR 0 2
74895: NOT
74896: OR
74897: PUSH
74898: LD_VAR 0 1
74902: NOT
74903: OR
74904: IFFALSE 74908
// exit ;
74906: GO 74933
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
74908: LD_ADDR_EXP 47
74912: PUSH
74913: LD_EXP 47
74917: PPUSH
74918: LD_VAR 0 1
74922: PPUSH
74923: LD_VAR 0 2
74927: PPUSH
74928: CALL_OW 1
74932: ST_TO_ADDR
// end ;
74933: LD_VAR 0 3
74937: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
74938: LD_INT 0
74940: PPUSH
// if not mc_bases or not base or not scan_area then
74941: LD_EXP 23
74945: NOT
74946: PUSH
74947: LD_VAR 0 1
74951: NOT
74952: OR
74953: PUSH
74954: LD_VAR 0 2
74958: NOT
74959: OR
74960: IFFALSE 74964
// exit ;
74962: GO 74989
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
74964: LD_ADDR_EXP 48
74968: PUSH
74969: LD_EXP 48
74973: PPUSH
74974: LD_VAR 0 1
74978: PPUSH
74979: LD_VAR 0 2
74983: PPUSH
74984: CALL_OW 1
74988: ST_TO_ADDR
// end ;
74989: LD_VAR 0 3
74993: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
74994: LD_INT 0
74996: PPUSH
74997: PPUSH
// if not mc_bases or not base then
74998: LD_EXP 23
75002: NOT
75003: PUSH
75004: LD_VAR 0 1
75008: NOT
75009: OR
75010: IFFALSE 75014
// exit ;
75012: GO 75078
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75014: LD_ADDR_VAR 0 3
75018: PUSH
75019: LD_INT 1
75021: PUSH
75022: LD_INT 2
75024: PUSH
75025: LD_INT 3
75027: PUSH
75028: LD_INT 4
75030: PUSH
75031: LD_INT 11
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: LIST
75038: LIST
75039: LIST
75040: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75041: LD_ADDR_EXP 50
75045: PUSH
75046: LD_EXP 50
75050: PPUSH
75051: LD_VAR 0 1
75055: PPUSH
75056: LD_EXP 50
75060: PUSH
75061: LD_VAR 0 1
75065: ARRAY
75066: PUSH
75067: LD_VAR 0 3
75071: DIFF
75072: PPUSH
75073: CALL_OW 1
75077: ST_TO_ADDR
// end ;
75078: LD_VAR 0 2
75082: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75083: LD_INT 0
75085: PPUSH
// result := mc_vehicles [ base ] ;
75086: LD_ADDR_VAR 0 3
75090: PUSH
75091: LD_EXP 42
75095: PUSH
75096: LD_VAR 0 1
75100: ARRAY
75101: ST_TO_ADDR
// if onlyCombat then
75102: LD_VAR 0 2
75106: IFFALSE 75284
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75108: LD_ADDR_VAR 0 3
75112: PUSH
75113: LD_VAR 0 3
75117: PUSH
75118: LD_VAR 0 3
75122: PPUSH
75123: LD_INT 2
75125: PUSH
75126: LD_INT 34
75128: PUSH
75129: LD_INT 12
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 34
75138: PUSH
75139: LD_INT 51
75141: PUSH
75142: EMPTY
75143: LIST
75144: LIST
75145: PUSH
75146: LD_INT 34
75148: PUSH
75149: LD_EXP 68
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 34
75160: PUSH
75161: LD_INT 32
75163: PUSH
75164: EMPTY
75165: LIST
75166: LIST
75167: PUSH
75168: LD_INT 34
75170: PUSH
75171: LD_INT 13
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 34
75180: PUSH
75181: LD_INT 52
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 34
75190: PUSH
75191: LD_EXP 73
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 34
75202: PUSH
75203: LD_INT 14
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 34
75212: PUSH
75213: LD_INT 53
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: LD_INT 34
75222: PUSH
75223: LD_EXP 67
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: LD_INT 34
75234: PUSH
75235: LD_INT 31
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: LD_INT 34
75244: PUSH
75245: LD_INT 48
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 34
75254: PUSH
75255: LD_INT 8
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: LIST
75266: LIST
75267: LIST
75268: LIST
75269: LIST
75270: LIST
75271: LIST
75272: LIST
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: PPUSH
75278: CALL_OW 72
75282: DIFF
75283: ST_TO_ADDR
// end ; end_of_file
75284: LD_VAR 0 3
75288: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75289: LD_INT 0
75291: PPUSH
75292: PPUSH
75293: PPUSH
// if not mc_bases or not skirmish then
75294: LD_EXP 23
75298: NOT
75299: PUSH
75300: LD_EXP 21
75304: NOT
75305: OR
75306: IFFALSE 75310
// exit ;
75308: GO 75475
// for i = 1 to mc_bases do
75310: LD_ADDR_VAR 0 4
75314: PUSH
75315: DOUBLE
75316: LD_INT 1
75318: DEC
75319: ST_TO_ADDR
75320: LD_EXP 23
75324: PUSH
75325: FOR_TO
75326: IFFALSE 75473
// begin if sci in mc_bases [ i ] then
75328: LD_VAR 0 2
75332: PUSH
75333: LD_EXP 23
75337: PUSH
75338: LD_VAR 0 4
75342: ARRAY
75343: IN
75344: IFFALSE 75471
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75346: LD_ADDR_EXP 52
75350: PUSH
75351: LD_EXP 52
75355: PPUSH
75356: LD_VAR 0 4
75360: PUSH
75361: LD_EXP 52
75365: PUSH
75366: LD_VAR 0 4
75370: ARRAY
75371: PUSH
75372: LD_INT 1
75374: PLUS
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PPUSH
75380: LD_VAR 0 1
75384: PPUSH
75385: CALL 15704 0 3
75389: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75390: LD_ADDR_VAR 0 5
75394: PUSH
75395: LD_EXP 23
75399: PUSH
75400: LD_VAR 0 4
75404: ARRAY
75405: PPUSH
75406: LD_INT 2
75408: PUSH
75409: LD_INT 30
75411: PUSH
75412: LD_INT 0
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: LD_INT 30
75421: PUSH
75422: LD_INT 1
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: LIST
75433: PPUSH
75434: CALL_OW 72
75438: PPUSH
75439: LD_VAR 0 1
75443: PPUSH
75444: CALL_OW 74
75448: ST_TO_ADDR
// if tmp then
75449: LD_VAR 0 5
75453: IFFALSE 75469
// ComStandNearbyBuilding ( ape , tmp ) ;
75455: LD_VAR 0 1
75459: PPUSH
75460: LD_VAR 0 5
75464: PPUSH
75465: CALL 12282 0 2
// break ;
75469: GO 75473
// end ; end ;
75471: GO 75325
75473: POP
75474: POP
// end ;
75475: LD_VAR 0 3
75479: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
75480: LD_INT 0
75482: PPUSH
75483: PPUSH
75484: PPUSH
// if not mc_bases or not skirmish then
75485: LD_EXP 23
75489: NOT
75490: PUSH
75491: LD_EXP 21
75495: NOT
75496: OR
75497: IFFALSE 75501
// exit ;
75499: GO 75590
// for i = 1 to mc_bases do
75501: LD_ADDR_VAR 0 4
75505: PUSH
75506: DOUBLE
75507: LD_INT 1
75509: DEC
75510: ST_TO_ADDR
75511: LD_EXP 23
75515: PUSH
75516: FOR_TO
75517: IFFALSE 75588
// begin if building in mc_busy_turret_list [ i ] then
75519: LD_VAR 0 1
75523: PUSH
75524: LD_EXP 33
75528: PUSH
75529: LD_VAR 0 4
75533: ARRAY
75534: IN
75535: IFFALSE 75586
// begin tmp := mc_busy_turret_list [ i ] diff building ;
75537: LD_ADDR_VAR 0 5
75541: PUSH
75542: LD_EXP 33
75546: PUSH
75547: LD_VAR 0 4
75551: ARRAY
75552: PUSH
75553: LD_VAR 0 1
75557: DIFF
75558: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
75559: LD_ADDR_EXP 33
75563: PUSH
75564: LD_EXP 33
75568: PPUSH
75569: LD_VAR 0 4
75573: PPUSH
75574: LD_VAR 0 5
75578: PPUSH
75579: CALL_OW 1
75583: ST_TO_ADDR
// break ;
75584: GO 75588
// end ; end ;
75586: GO 75516
75588: POP
75589: POP
// end ;
75590: LD_VAR 0 3
75594: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
75595: LD_INT 0
75597: PPUSH
75598: PPUSH
75599: PPUSH
// if not mc_bases or not skirmish then
75600: LD_EXP 23
75604: NOT
75605: PUSH
75606: LD_EXP 21
75610: NOT
75611: OR
75612: IFFALSE 75616
// exit ;
75614: GO 75815
// for i = 1 to mc_bases do
75616: LD_ADDR_VAR 0 5
75620: PUSH
75621: DOUBLE
75622: LD_INT 1
75624: DEC
75625: ST_TO_ADDR
75626: LD_EXP 23
75630: PUSH
75631: FOR_TO
75632: IFFALSE 75813
// if building in mc_bases [ i ] then
75634: LD_VAR 0 1
75638: PUSH
75639: LD_EXP 23
75643: PUSH
75644: LD_VAR 0 5
75648: ARRAY
75649: IN
75650: IFFALSE 75811
// begin tmp := mc_bases [ i ] diff building ;
75652: LD_ADDR_VAR 0 6
75656: PUSH
75657: LD_EXP 23
75661: PUSH
75662: LD_VAR 0 5
75666: ARRAY
75667: PUSH
75668: LD_VAR 0 1
75672: DIFF
75673: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
75674: LD_ADDR_EXP 23
75678: PUSH
75679: LD_EXP 23
75683: PPUSH
75684: LD_VAR 0 5
75688: PPUSH
75689: LD_VAR 0 6
75693: PPUSH
75694: CALL_OW 1
75698: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
75699: LD_VAR 0 1
75703: PUSH
75704: LD_EXP 31
75708: PUSH
75709: LD_VAR 0 5
75713: ARRAY
75714: IN
75715: IFFALSE 75754
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
75717: LD_ADDR_EXP 31
75721: PUSH
75722: LD_EXP 31
75726: PPUSH
75727: LD_VAR 0 5
75731: PPUSH
75732: LD_EXP 31
75736: PUSH
75737: LD_VAR 0 5
75741: ARRAY
75742: PUSH
75743: LD_VAR 0 1
75747: DIFF
75748: PPUSH
75749: CALL_OW 1
75753: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
75754: LD_VAR 0 1
75758: PUSH
75759: LD_EXP 32
75763: PUSH
75764: LD_VAR 0 5
75768: ARRAY
75769: IN
75770: IFFALSE 75809
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
75772: LD_ADDR_EXP 32
75776: PUSH
75777: LD_EXP 32
75781: PPUSH
75782: LD_VAR 0 5
75786: PPUSH
75787: LD_EXP 32
75791: PUSH
75792: LD_VAR 0 5
75796: ARRAY
75797: PUSH
75798: LD_VAR 0 1
75802: DIFF
75803: PPUSH
75804: CALL_OW 1
75808: ST_TO_ADDR
// break ;
75809: GO 75813
// end ;
75811: GO 75631
75813: POP
75814: POP
// end ;
75815: LD_VAR 0 4
75819: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
75820: LD_INT 0
75822: PPUSH
75823: PPUSH
75824: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
75825: LD_EXP 23
75829: NOT
75830: PUSH
75831: LD_EXP 21
75835: NOT
75836: OR
75837: PUSH
75838: LD_VAR 0 3
75842: PUSH
75843: LD_EXP 49
75847: IN
75848: NOT
75849: OR
75850: IFFALSE 75854
// exit ;
75852: GO 75977
// for i = 1 to mc_vehicles do
75854: LD_ADDR_VAR 0 6
75858: PUSH
75859: DOUBLE
75860: LD_INT 1
75862: DEC
75863: ST_TO_ADDR
75864: LD_EXP 42
75868: PUSH
75869: FOR_TO
75870: IFFALSE 75975
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
75872: LD_VAR 0 2
75876: PUSH
75877: LD_EXP 42
75881: PUSH
75882: LD_VAR 0 6
75886: ARRAY
75887: IN
75888: PUSH
75889: LD_VAR 0 1
75893: PUSH
75894: LD_EXP 42
75898: PUSH
75899: LD_VAR 0 6
75903: ARRAY
75904: IN
75905: OR
75906: IFFALSE 75973
// begin tmp := mc_vehicles [ i ] diff old ;
75908: LD_ADDR_VAR 0 7
75912: PUSH
75913: LD_EXP 42
75917: PUSH
75918: LD_VAR 0 6
75922: ARRAY
75923: PUSH
75924: LD_VAR 0 2
75928: DIFF
75929: ST_TO_ADDR
// tmp := tmp diff new ;
75930: LD_ADDR_VAR 0 7
75934: PUSH
75935: LD_VAR 0 7
75939: PUSH
75940: LD_VAR 0 1
75944: DIFF
75945: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
75946: LD_ADDR_EXP 42
75950: PUSH
75951: LD_EXP 42
75955: PPUSH
75956: LD_VAR 0 6
75960: PPUSH
75961: LD_VAR 0 7
75965: PPUSH
75966: CALL_OW 1
75970: ST_TO_ADDR
// break ;
75971: GO 75975
// end ;
75973: GO 75869
75975: POP
75976: POP
// end ;
75977: LD_VAR 0 5
75981: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
75982: LD_INT 0
75984: PPUSH
75985: PPUSH
75986: PPUSH
75987: PPUSH
// if not mc_bases or not skirmish then
75988: LD_EXP 23
75992: NOT
75993: PUSH
75994: LD_EXP 21
75998: NOT
75999: OR
76000: IFFALSE 76004
// exit ;
76002: GO 76396
// side := GetSide ( vehicle ) ;
76004: LD_ADDR_VAR 0 5
76008: PUSH
76009: LD_VAR 0 1
76013: PPUSH
76014: CALL_OW 255
76018: ST_TO_ADDR
// for i = 1 to mc_bases do
76019: LD_ADDR_VAR 0 4
76023: PUSH
76024: DOUBLE
76025: LD_INT 1
76027: DEC
76028: ST_TO_ADDR
76029: LD_EXP 23
76033: PUSH
76034: FOR_TO
76035: IFFALSE 76394
// begin if factory in mc_bases [ i ] then
76037: LD_VAR 0 2
76041: PUSH
76042: LD_EXP 23
76046: PUSH
76047: LD_VAR 0 4
76051: ARRAY
76052: IN
76053: IFFALSE 76392
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
76055: LD_EXP 45
76059: PUSH
76060: LD_VAR 0 4
76064: ARRAY
76065: PUSH
76066: LD_EXP 34
76070: PUSH
76071: LD_VAR 0 4
76075: ARRAY
76076: LESS
76077: PUSH
76078: LD_VAR 0 1
76082: PPUSH
76083: CALL_OW 264
76087: PUSH
76088: LD_INT 31
76090: PUSH
76091: LD_INT 32
76093: PUSH
76094: LD_INT 51
76096: PUSH
76097: LD_EXP 68
76101: PUSH
76102: LD_INT 12
76104: PUSH
76105: LD_INT 30
76107: PUSH
76108: LD_EXP 67
76112: PUSH
76113: LD_INT 11
76115: PUSH
76116: LD_INT 53
76118: PUSH
76119: LD_INT 14
76121: PUSH
76122: LD_EXP 71
76126: PUSH
76127: LD_INT 29
76129: PUSH
76130: LD_EXP 69
76134: PUSH
76135: LD_INT 13
76137: PUSH
76138: LD_INT 52
76140: PUSH
76141: LD_EXP 73
76145: PUSH
76146: LD_INT 48
76148: PUSH
76149: LD_INT 8
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: LIST
76156: LIST
76157: LIST
76158: LIST
76159: LIST
76160: LIST
76161: LIST
76162: LIST
76163: LIST
76164: LIST
76165: LIST
76166: LIST
76167: LIST
76168: LIST
76169: LIST
76170: LIST
76171: IN
76172: NOT
76173: AND
76174: IFFALSE 76222
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76176: LD_ADDR_EXP 45
76180: PUSH
76181: LD_EXP 45
76185: PPUSH
76186: LD_VAR 0 4
76190: PUSH
76191: LD_EXP 45
76195: PUSH
76196: LD_VAR 0 4
76200: ARRAY
76201: PUSH
76202: LD_INT 1
76204: PLUS
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PPUSH
76210: LD_VAR 0 1
76214: PPUSH
76215: CALL 15704 0 3
76219: ST_TO_ADDR
76220: GO 76266
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76222: LD_ADDR_EXP 42
76226: PUSH
76227: LD_EXP 42
76231: PPUSH
76232: LD_VAR 0 4
76236: PUSH
76237: LD_EXP 42
76241: PUSH
76242: LD_VAR 0 4
76246: ARRAY
76247: PUSH
76248: LD_INT 1
76250: PLUS
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PPUSH
76256: LD_VAR 0 1
76260: PPUSH
76261: CALL 15704 0 3
76265: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76266: LD_VAR 0 1
76270: PPUSH
76271: CALL_OW 263
76275: PUSH
76276: LD_INT 2
76278: EQUAL
76279: IFFALSE 76308
// begin repeat Connect ( vehicle ) ;
76281: LD_VAR 0 1
76285: PPUSH
76286: CALL 18675 0 1
// wait ( 0 0$1 ) ;
76290: LD_INT 35
76292: PPUSH
76293: CALL_OW 67
// until IsControledBy ( vehicle ) ;
76297: LD_VAR 0 1
76301: PPUSH
76302: CALL_OW 312
76306: IFFALSE 76281
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76308: LD_VAR 0 1
76312: PPUSH
76313: LD_EXP 47
76317: PUSH
76318: LD_VAR 0 4
76322: ARRAY
76323: PPUSH
76324: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
76328: LD_VAR 0 1
76332: PPUSH
76333: CALL_OW 263
76337: PUSH
76338: LD_INT 1
76340: NONEQUAL
76341: IFFALSE 76345
// break ;
76343: GO 76394
// repeat wait ( 0 0$1 ) ;
76345: LD_INT 35
76347: PPUSH
76348: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76352: LD_VAR 0 1
76356: PPUSH
76357: LD_EXP 47
76361: PUSH
76362: LD_VAR 0 4
76366: ARRAY
76367: PPUSH
76368: CALL_OW 308
76372: IFFALSE 76345
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76374: LD_VAR 0 1
76378: PPUSH
76379: CALL_OW 311
76383: PPUSH
76384: CALL_OW 121
// exit ;
76388: POP
76389: POP
76390: GO 76396
// end ; end ;
76392: GO 76034
76394: POP
76395: POP
// end ;
76396: LD_VAR 0 3
76400: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76401: LD_INT 0
76403: PPUSH
76404: PPUSH
76405: PPUSH
76406: PPUSH
// if not mc_bases or not skirmish then
76407: LD_EXP 23
76411: NOT
76412: PUSH
76413: LD_EXP 21
76417: NOT
76418: OR
76419: IFFALSE 76423
// exit ;
76421: GO 76776
// repeat wait ( 0 0$1 ) ;
76423: LD_INT 35
76425: PPUSH
76426: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
76430: LD_VAR 0 2
76434: PPUSH
76435: LD_VAR 0 3
76439: PPUSH
76440: CALL_OW 284
76444: IFFALSE 76423
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76446: LD_VAR 0 2
76450: PPUSH
76451: LD_VAR 0 3
76455: PPUSH
76456: CALL_OW 283
76460: PUSH
76461: LD_INT 4
76463: EQUAL
76464: IFFALSE 76468
// exit ;
76466: GO 76776
// for i = 1 to mc_bases do
76468: LD_ADDR_VAR 0 7
76472: PUSH
76473: DOUBLE
76474: LD_INT 1
76476: DEC
76477: ST_TO_ADDR
76478: LD_EXP 23
76482: PUSH
76483: FOR_TO
76484: IFFALSE 76774
// begin if mc_crates_area [ i ] then
76486: LD_EXP 41
76490: PUSH
76491: LD_VAR 0 7
76495: ARRAY
76496: IFFALSE 76607
// for j in mc_crates_area [ i ] do
76498: LD_ADDR_VAR 0 8
76502: PUSH
76503: LD_EXP 41
76507: PUSH
76508: LD_VAR 0 7
76512: ARRAY
76513: PUSH
76514: FOR_IN
76515: IFFALSE 76605
// if InArea ( x , y , j ) then
76517: LD_VAR 0 2
76521: PPUSH
76522: LD_VAR 0 3
76526: PPUSH
76527: LD_VAR 0 8
76531: PPUSH
76532: CALL_OW 309
76536: IFFALSE 76603
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76538: LD_ADDR_EXP 39
76542: PUSH
76543: LD_EXP 39
76547: PPUSH
76548: LD_VAR 0 7
76552: PUSH
76553: LD_EXP 39
76557: PUSH
76558: LD_VAR 0 7
76562: ARRAY
76563: PUSH
76564: LD_INT 1
76566: PLUS
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PPUSH
76572: LD_VAR 0 4
76576: PUSH
76577: LD_VAR 0 2
76581: PUSH
76582: LD_VAR 0 3
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: LIST
76591: PPUSH
76592: CALL 15704 0 3
76596: ST_TO_ADDR
// exit ;
76597: POP
76598: POP
76599: POP
76600: POP
76601: GO 76776
// end ;
76603: GO 76514
76605: POP
76606: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76607: LD_ADDR_VAR 0 9
76611: PUSH
76612: LD_EXP 23
76616: PUSH
76617: LD_VAR 0 7
76621: ARRAY
76622: PPUSH
76623: LD_INT 2
76625: PUSH
76626: LD_INT 30
76628: PUSH
76629: LD_INT 0
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 30
76638: PUSH
76639: LD_INT 1
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: LIST
76650: PPUSH
76651: CALL_OW 72
76655: ST_TO_ADDR
// if not depot then
76656: LD_VAR 0 9
76660: NOT
76661: IFFALSE 76665
// continue ;
76663: GO 76483
// for j in depot do
76665: LD_ADDR_VAR 0 8
76669: PUSH
76670: LD_VAR 0 9
76674: PUSH
76675: FOR_IN
76676: IFFALSE 76770
// if GetDistUnitXY ( j , x , y ) < 30 then
76678: LD_VAR 0 8
76682: PPUSH
76683: LD_VAR 0 2
76687: PPUSH
76688: LD_VAR 0 3
76692: PPUSH
76693: CALL_OW 297
76697: PUSH
76698: LD_INT 30
76700: LESS
76701: IFFALSE 76768
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
76703: LD_ADDR_EXP 39
76707: PUSH
76708: LD_EXP 39
76712: PPUSH
76713: LD_VAR 0 7
76717: PUSH
76718: LD_EXP 39
76722: PUSH
76723: LD_VAR 0 7
76727: ARRAY
76728: PUSH
76729: LD_INT 1
76731: PLUS
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PPUSH
76737: LD_VAR 0 4
76741: PUSH
76742: LD_VAR 0 2
76746: PUSH
76747: LD_VAR 0 3
76751: PUSH
76752: EMPTY
76753: LIST
76754: LIST
76755: LIST
76756: PPUSH
76757: CALL 15704 0 3
76761: ST_TO_ADDR
// exit ;
76762: POP
76763: POP
76764: POP
76765: POP
76766: GO 76776
// end ;
76768: GO 76675
76770: POP
76771: POP
// end ;
76772: GO 76483
76774: POP
76775: POP
// end ;
76776: LD_VAR 0 6
76780: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
76781: LD_INT 0
76783: PPUSH
76784: PPUSH
76785: PPUSH
76786: PPUSH
// if not mc_bases or not skirmish then
76787: LD_EXP 23
76791: NOT
76792: PUSH
76793: LD_EXP 21
76797: NOT
76798: OR
76799: IFFALSE 76803
// exit ;
76801: GO 77080
// side := GetSide ( lab ) ;
76803: LD_ADDR_VAR 0 4
76807: PUSH
76808: LD_VAR 0 2
76812: PPUSH
76813: CALL_OW 255
76817: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
76818: LD_VAR 0 4
76822: PUSH
76823: LD_EXP 49
76827: IN
76828: NOT
76829: PUSH
76830: LD_EXP 50
76834: NOT
76835: OR
76836: PUSH
76837: LD_EXP 23
76841: NOT
76842: OR
76843: IFFALSE 76847
// exit ;
76845: GO 77080
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
76847: LD_ADDR_EXP 50
76851: PUSH
76852: LD_EXP 50
76856: PPUSH
76857: LD_VAR 0 4
76861: PPUSH
76862: LD_EXP 50
76866: PUSH
76867: LD_VAR 0 4
76871: ARRAY
76872: PUSH
76873: LD_VAR 0 1
76877: DIFF
76878: PPUSH
76879: CALL_OW 1
76883: ST_TO_ADDR
// for i = 1 to mc_bases do
76884: LD_ADDR_VAR 0 5
76888: PUSH
76889: DOUBLE
76890: LD_INT 1
76892: DEC
76893: ST_TO_ADDR
76894: LD_EXP 23
76898: PUSH
76899: FOR_TO
76900: IFFALSE 77078
// begin if lab in mc_bases [ i ] then
76902: LD_VAR 0 2
76906: PUSH
76907: LD_EXP 23
76911: PUSH
76912: LD_VAR 0 5
76916: ARRAY
76917: IN
76918: IFFALSE 77076
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
76920: LD_VAR 0 1
76924: PUSH
76925: LD_INT 11
76927: PUSH
76928: LD_INT 4
76930: PUSH
76931: LD_INT 3
76933: PUSH
76934: LD_INT 2
76936: PUSH
76937: EMPTY
76938: LIST
76939: LIST
76940: LIST
76941: LIST
76942: IN
76943: PUSH
76944: LD_EXP 53
76948: PUSH
76949: LD_VAR 0 5
76953: ARRAY
76954: AND
76955: IFFALSE 77076
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
76957: LD_ADDR_VAR 0 6
76961: PUSH
76962: LD_EXP 53
76966: PUSH
76967: LD_VAR 0 5
76971: ARRAY
76972: PUSH
76973: LD_INT 1
76975: ARRAY
76976: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
76977: LD_ADDR_EXP 53
76981: PUSH
76982: LD_EXP 53
76986: PPUSH
76987: LD_VAR 0 5
76991: PPUSH
76992: EMPTY
76993: PPUSH
76994: CALL_OW 1
76998: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
76999: LD_VAR 0 6
77003: PPUSH
77004: LD_INT 0
77006: PPUSH
77007: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77011: LD_VAR 0 6
77015: PPUSH
77016: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77020: LD_ADDR_EXP 52
77024: PUSH
77025: LD_EXP 52
77029: PPUSH
77030: LD_VAR 0 5
77034: PPUSH
77035: LD_EXP 52
77039: PUSH
77040: LD_VAR 0 5
77044: ARRAY
77045: PPUSH
77046: LD_INT 1
77048: PPUSH
77049: LD_VAR 0 6
77053: PPUSH
77054: CALL_OW 2
77058: PPUSH
77059: CALL_OW 1
77063: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77064: LD_VAR 0 5
77068: PPUSH
77069: LD_INT 112
77071: PPUSH
77072: CALL 53746 0 2
// end ; end ; end ;
77076: GO 76899
77078: POP
77079: POP
// end ;
77080: LD_VAR 0 3
77084: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77085: LD_INT 0
77087: PPUSH
77088: PPUSH
77089: PPUSH
77090: PPUSH
77091: PPUSH
77092: PPUSH
77093: PPUSH
77094: PPUSH
// if not mc_bases or not skirmish then
77095: LD_EXP 23
77099: NOT
77100: PUSH
77101: LD_EXP 21
77105: NOT
77106: OR
77107: IFFALSE 77111
// exit ;
77109: GO 78482
// for i = 1 to mc_bases do
77111: LD_ADDR_VAR 0 3
77115: PUSH
77116: DOUBLE
77117: LD_INT 1
77119: DEC
77120: ST_TO_ADDR
77121: LD_EXP 23
77125: PUSH
77126: FOR_TO
77127: IFFALSE 78480
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77129: LD_VAR 0 1
77133: PUSH
77134: LD_EXP 23
77138: PUSH
77139: LD_VAR 0 3
77143: ARRAY
77144: IN
77145: PUSH
77146: LD_VAR 0 1
77150: PUSH
77151: LD_EXP 30
77155: PUSH
77156: LD_VAR 0 3
77160: ARRAY
77161: IN
77162: OR
77163: PUSH
77164: LD_VAR 0 1
77168: PUSH
77169: LD_EXP 45
77173: PUSH
77174: LD_VAR 0 3
77178: ARRAY
77179: IN
77180: OR
77181: PUSH
77182: LD_VAR 0 1
77186: PUSH
77187: LD_EXP 42
77191: PUSH
77192: LD_VAR 0 3
77196: ARRAY
77197: IN
77198: OR
77199: PUSH
77200: LD_VAR 0 1
77204: PUSH
77205: LD_EXP 52
77209: PUSH
77210: LD_VAR 0 3
77214: ARRAY
77215: IN
77216: OR
77217: PUSH
77218: LD_VAR 0 1
77222: PUSH
77223: LD_EXP 53
77227: PUSH
77228: LD_VAR 0 3
77232: ARRAY
77233: IN
77234: OR
77235: IFFALSE 78478
// begin if un in mc_ape [ i ] then
77237: LD_VAR 0 1
77241: PUSH
77242: LD_EXP 52
77246: PUSH
77247: LD_VAR 0 3
77251: ARRAY
77252: IN
77253: IFFALSE 77292
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77255: LD_ADDR_EXP 52
77259: PUSH
77260: LD_EXP 52
77264: PPUSH
77265: LD_VAR 0 3
77269: PPUSH
77270: LD_EXP 52
77274: PUSH
77275: LD_VAR 0 3
77279: ARRAY
77280: PUSH
77281: LD_VAR 0 1
77285: DIFF
77286: PPUSH
77287: CALL_OW 1
77291: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77292: LD_VAR 0 1
77296: PUSH
77297: LD_EXP 53
77301: PUSH
77302: LD_VAR 0 3
77306: ARRAY
77307: IN
77308: IFFALSE 77332
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77310: LD_ADDR_EXP 53
77314: PUSH
77315: LD_EXP 53
77319: PPUSH
77320: LD_VAR 0 3
77324: PPUSH
77325: EMPTY
77326: PPUSH
77327: CALL_OW 1
77331: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77332: LD_VAR 0 1
77336: PPUSH
77337: CALL_OW 247
77341: PUSH
77342: LD_INT 2
77344: EQUAL
77345: PUSH
77346: LD_VAR 0 1
77350: PPUSH
77351: CALL_OW 110
77355: PUSH
77356: LD_INT 20
77358: EQUAL
77359: PUSH
77360: LD_VAR 0 1
77364: PUSH
77365: LD_EXP 45
77369: PUSH
77370: LD_VAR 0 3
77374: ARRAY
77375: IN
77376: OR
77377: PUSH
77378: LD_VAR 0 1
77382: PPUSH
77383: CALL_OW 264
77387: PUSH
77388: LD_INT 12
77390: PUSH
77391: LD_INT 51
77393: PUSH
77394: LD_EXP 68
77398: PUSH
77399: LD_INT 32
77401: PUSH
77402: LD_INT 13
77404: PUSH
77405: LD_INT 52
77407: PUSH
77408: LD_INT 31
77410: PUSH
77411: EMPTY
77412: LIST
77413: LIST
77414: LIST
77415: LIST
77416: LIST
77417: LIST
77418: LIST
77419: IN
77420: OR
77421: AND
77422: IFFALSE 77730
// begin if un in mc_defender [ i ] then
77424: LD_VAR 0 1
77428: PUSH
77429: LD_EXP 45
77433: PUSH
77434: LD_VAR 0 3
77438: ARRAY
77439: IN
77440: IFFALSE 77479
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77442: LD_ADDR_EXP 45
77446: PUSH
77447: LD_EXP 45
77451: PPUSH
77452: LD_VAR 0 3
77456: PPUSH
77457: LD_EXP 45
77461: PUSH
77462: LD_VAR 0 3
77466: ARRAY
77467: PUSH
77468: LD_VAR 0 1
77472: DIFF
77473: PPUSH
77474: CALL_OW 1
77478: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
77479: LD_ADDR_VAR 0 8
77483: PUSH
77484: LD_VAR 0 3
77488: PPUSH
77489: LD_INT 3
77491: PPUSH
77492: CALL 74120 0 2
77496: ST_TO_ADDR
// if fac then
77497: LD_VAR 0 8
77501: IFFALSE 77730
// begin for j in fac do
77503: LD_ADDR_VAR 0 4
77507: PUSH
77508: LD_VAR 0 8
77512: PUSH
77513: FOR_IN
77514: IFFALSE 77728
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
77516: LD_ADDR_VAR 0 9
77520: PUSH
77521: LD_VAR 0 8
77525: PPUSH
77526: LD_VAR 0 1
77530: PPUSH
77531: CALL_OW 265
77535: PPUSH
77536: LD_VAR 0 1
77540: PPUSH
77541: CALL_OW 262
77545: PPUSH
77546: LD_VAR 0 1
77550: PPUSH
77551: CALL_OW 263
77555: PPUSH
77556: LD_VAR 0 1
77560: PPUSH
77561: CALL_OW 264
77565: PPUSH
77566: CALL 13200 0 5
77570: ST_TO_ADDR
// if components then
77571: LD_VAR 0 9
77575: IFFALSE 77726
// begin if GetWeapon ( un ) = ar_control_tower then
77577: LD_VAR 0 1
77581: PPUSH
77582: CALL_OW 264
77586: PUSH
77587: LD_INT 31
77589: EQUAL
77590: IFFALSE 77707
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
77592: LD_VAR 0 1
77596: PPUSH
77597: CALL_OW 311
77601: PPUSH
77602: LD_INT 0
77604: PPUSH
77605: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
77609: LD_ADDR_EXP 63
77613: PUSH
77614: LD_EXP 63
77618: PPUSH
77619: LD_VAR 0 3
77623: PPUSH
77624: LD_EXP 63
77628: PUSH
77629: LD_VAR 0 3
77633: ARRAY
77634: PUSH
77635: LD_VAR 0 1
77639: PPUSH
77640: CALL_OW 311
77644: DIFF
77645: PPUSH
77646: CALL_OW 1
77650: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
77651: LD_ADDR_VAR 0 7
77655: PUSH
77656: LD_EXP 44
77660: PUSH
77661: LD_VAR 0 3
77665: ARRAY
77666: PPUSH
77667: LD_INT 1
77669: PPUSH
77670: LD_VAR 0 9
77674: PPUSH
77675: CALL_OW 2
77679: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
77680: LD_ADDR_EXP 44
77684: PUSH
77685: LD_EXP 44
77689: PPUSH
77690: LD_VAR 0 3
77694: PPUSH
77695: LD_VAR 0 7
77699: PPUSH
77700: CALL_OW 1
77704: ST_TO_ADDR
// end else
77705: GO 77724
// MC_InsertProduceList ( i , [ components ] ) ;
77707: LD_VAR 0 3
77711: PPUSH
77712: LD_VAR 0 9
77716: PUSH
77717: EMPTY
77718: LIST
77719: PPUSH
77720: CALL 73665 0 2
// break ;
77724: GO 77728
// end ; end ;
77726: GO 77513
77728: POP
77729: POP
// end ; end ; if GetType ( un ) = unit_building then
77730: LD_VAR 0 1
77734: PPUSH
77735: CALL_OW 247
77739: PUSH
77740: LD_INT 3
77742: EQUAL
77743: IFFALSE 78146
// begin btype := GetBType ( un ) ;
77745: LD_ADDR_VAR 0 5
77749: PUSH
77750: LD_VAR 0 1
77754: PPUSH
77755: CALL_OW 266
77759: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
77760: LD_VAR 0 5
77764: PUSH
77765: LD_INT 29
77767: PUSH
77768: LD_INT 30
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: IN
77775: IFFALSE 77848
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
77777: LD_VAR 0 1
77781: PPUSH
77782: CALL_OW 250
77786: PPUSH
77787: LD_VAR 0 1
77791: PPUSH
77792: CALL_OW 251
77796: PPUSH
77797: LD_VAR 0 1
77801: PPUSH
77802: CALL_OW 255
77806: PPUSH
77807: CALL_OW 440
77811: NOT
77812: IFFALSE 77848
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
77814: LD_VAR 0 1
77818: PPUSH
77819: CALL_OW 250
77823: PPUSH
77824: LD_VAR 0 1
77828: PPUSH
77829: CALL_OW 251
77833: PPUSH
77834: LD_VAR 0 1
77838: PPUSH
77839: CALL_OW 255
77843: PPUSH
77844: CALL_OW 441
// end ; if btype = b_warehouse then
77848: LD_VAR 0 5
77852: PUSH
77853: LD_INT 1
77855: EQUAL
77856: IFFALSE 77874
// begin btype := b_depot ;
77858: LD_ADDR_VAR 0 5
77862: PUSH
77863: LD_INT 0
77865: ST_TO_ADDR
// pos := 1 ;
77866: LD_ADDR_VAR 0 6
77870: PUSH
77871: LD_INT 1
77873: ST_TO_ADDR
// end ; if btype = b_factory then
77874: LD_VAR 0 5
77878: PUSH
77879: LD_INT 3
77881: EQUAL
77882: IFFALSE 77900
// begin btype := b_workshop ;
77884: LD_ADDR_VAR 0 5
77888: PUSH
77889: LD_INT 2
77891: ST_TO_ADDR
// pos := 1 ;
77892: LD_ADDR_VAR 0 6
77896: PUSH
77897: LD_INT 1
77899: ST_TO_ADDR
// end ; if btype = b_barracks then
77900: LD_VAR 0 5
77904: PUSH
77905: LD_INT 5
77907: EQUAL
77908: IFFALSE 77918
// btype := b_armoury ;
77910: LD_ADDR_VAR 0 5
77914: PUSH
77915: LD_INT 4
77917: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
77918: LD_VAR 0 5
77922: PUSH
77923: LD_INT 7
77925: PUSH
77926: LD_INT 8
77928: PUSH
77929: EMPTY
77930: LIST
77931: LIST
77932: IN
77933: IFFALSE 77943
// btype := b_lab ;
77935: LD_ADDR_VAR 0 5
77939: PUSH
77940: LD_INT 6
77942: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
77943: LD_ADDR_EXP 28
77947: PUSH
77948: LD_EXP 28
77952: PPUSH
77953: LD_VAR 0 3
77957: PUSH
77958: LD_EXP 28
77962: PUSH
77963: LD_VAR 0 3
77967: ARRAY
77968: PUSH
77969: LD_INT 1
77971: PLUS
77972: PUSH
77973: EMPTY
77974: LIST
77975: LIST
77976: PPUSH
77977: LD_VAR 0 5
77981: PUSH
77982: LD_VAR 0 1
77986: PPUSH
77987: CALL_OW 250
77991: PUSH
77992: LD_VAR 0 1
77996: PPUSH
77997: CALL_OW 251
78001: PUSH
78002: LD_VAR 0 1
78006: PPUSH
78007: CALL_OW 254
78011: PUSH
78012: EMPTY
78013: LIST
78014: LIST
78015: LIST
78016: LIST
78017: PPUSH
78018: CALL 15704 0 3
78022: ST_TO_ADDR
// if pos = 1 then
78023: LD_VAR 0 6
78027: PUSH
78028: LD_INT 1
78030: EQUAL
78031: IFFALSE 78146
// begin tmp := mc_build_list [ i ] ;
78033: LD_ADDR_VAR 0 7
78037: PUSH
78038: LD_EXP 28
78042: PUSH
78043: LD_VAR 0 3
78047: ARRAY
78048: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78049: LD_VAR 0 7
78053: PPUSH
78054: LD_INT 2
78056: PUSH
78057: LD_INT 30
78059: PUSH
78060: LD_INT 0
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: PUSH
78067: LD_INT 30
78069: PUSH
78070: LD_INT 1
78072: PUSH
78073: EMPTY
78074: LIST
78075: LIST
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: LIST
78081: PPUSH
78082: CALL_OW 72
78086: IFFALSE 78096
// pos := 2 ;
78088: LD_ADDR_VAR 0 6
78092: PUSH
78093: LD_INT 2
78095: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78096: LD_ADDR_VAR 0 7
78100: PUSH
78101: LD_VAR 0 7
78105: PPUSH
78106: LD_VAR 0 6
78110: PPUSH
78111: LD_VAR 0 7
78115: PPUSH
78116: CALL 16030 0 3
78120: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78121: LD_ADDR_EXP 28
78125: PUSH
78126: LD_EXP 28
78130: PPUSH
78131: LD_VAR 0 3
78135: PPUSH
78136: LD_VAR 0 7
78140: PPUSH
78141: CALL_OW 1
78145: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78146: LD_VAR 0 1
78150: PUSH
78151: LD_EXP 23
78155: PUSH
78156: LD_VAR 0 3
78160: ARRAY
78161: IN
78162: IFFALSE 78201
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78164: LD_ADDR_EXP 23
78168: PUSH
78169: LD_EXP 23
78173: PPUSH
78174: LD_VAR 0 3
78178: PPUSH
78179: LD_EXP 23
78183: PUSH
78184: LD_VAR 0 3
78188: ARRAY
78189: PUSH
78190: LD_VAR 0 1
78194: DIFF
78195: PPUSH
78196: CALL_OW 1
78200: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78201: LD_VAR 0 1
78205: PUSH
78206: LD_EXP 30
78210: PUSH
78211: LD_VAR 0 3
78215: ARRAY
78216: IN
78217: IFFALSE 78256
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78219: LD_ADDR_EXP 30
78223: PUSH
78224: LD_EXP 30
78228: PPUSH
78229: LD_VAR 0 3
78233: PPUSH
78234: LD_EXP 30
78238: PUSH
78239: LD_VAR 0 3
78243: ARRAY
78244: PUSH
78245: LD_VAR 0 1
78249: DIFF
78250: PPUSH
78251: CALL_OW 1
78255: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78256: LD_VAR 0 1
78260: PUSH
78261: LD_EXP 42
78265: PUSH
78266: LD_VAR 0 3
78270: ARRAY
78271: IN
78272: IFFALSE 78311
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78274: LD_ADDR_EXP 42
78278: PUSH
78279: LD_EXP 42
78283: PPUSH
78284: LD_VAR 0 3
78288: PPUSH
78289: LD_EXP 42
78293: PUSH
78294: LD_VAR 0 3
78298: ARRAY
78299: PUSH
78300: LD_VAR 0 1
78304: DIFF
78305: PPUSH
78306: CALL_OW 1
78310: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78311: LD_VAR 0 1
78315: PUSH
78316: LD_EXP 45
78320: PUSH
78321: LD_VAR 0 3
78325: ARRAY
78326: IN
78327: IFFALSE 78366
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78329: LD_ADDR_EXP 45
78333: PUSH
78334: LD_EXP 45
78338: PPUSH
78339: LD_VAR 0 3
78343: PPUSH
78344: LD_EXP 45
78348: PUSH
78349: LD_VAR 0 3
78353: ARRAY
78354: PUSH
78355: LD_VAR 0 1
78359: DIFF
78360: PPUSH
78361: CALL_OW 1
78365: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78366: LD_VAR 0 1
78370: PUSH
78371: LD_EXP 32
78375: PUSH
78376: LD_VAR 0 3
78380: ARRAY
78381: IN
78382: IFFALSE 78421
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78384: LD_ADDR_EXP 32
78388: PUSH
78389: LD_EXP 32
78393: PPUSH
78394: LD_VAR 0 3
78398: PPUSH
78399: LD_EXP 32
78403: PUSH
78404: LD_VAR 0 3
78408: ARRAY
78409: PUSH
78410: LD_VAR 0 1
78414: DIFF
78415: PPUSH
78416: CALL_OW 1
78420: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78421: LD_VAR 0 1
78425: PUSH
78426: LD_EXP 31
78430: PUSH
78431: LD_VAR 0 3
78435: ARRAY
78436: IN
78437: IFFALSE 78476
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78439: LD_ADDR_EXP 31
78443: PUSH
78444: LD_EXP 31
78448: PPUSH
78449: LD_VAR 0 3
78453: PPUSH
78454: LD_EXP 31
78458: PUSH
78459: LD_VAR 0 3
78463: ARRAY
78464: PUSH
78465: LD_VAR 0 1
78469: DIFF
78470: PPUSH
78471: CALL_OW 1
78475: ST_TO_ADDR
// end ; break ;
78476: GO 78480
// end ;
78478: GO 77126
78480: POP
78481: POP
// end ;
78482: LD_VAR 0 2
78486: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
78487: LD_INT 0
78489: PPUSH
78490: PPUSH
78491: PPUSH
// if not mc_bases or not skirmish then
78492: LD_EXP 23
78496: NOT
78497: PUSH
78498: LD_EXP 21
78502: NOT
78503: OR
78504: IFFALSE 78508
// exit ;
78506: GO 78723
// for i = 1 to mc_bases do
78508: LD_ADDR_VAR 0 3
78512: PUSH
78513: DOUBLE
78514: LD_INT 1
78516: DEC
78517: ST_TO_ADDR
78518: LD_EXP 23
78522: PUSH
78523: FOR_TO
78524: IFFALSE 78721
// begin if building in mc_construct_list [ i ] then
78526: LD_VAR 0 1
78530: PUSH
78531: LD_EXP 30
78535: PUSH
78536: LD_VAR 0 3
78540: ARRAY
78541: IN
78542: IFFALSE 78719
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
78544: LD_ADDR_EXP 30
78548: PUSH
78549: LD_EXP 30
78553: PPUSH
78554: LD_VAR 0 3
78558: PPUSH
78559: LD_EXP 30
78563: PUSH
78564: LD_VAR 0 3
78568: ARRAY
78569: PUSH
78570: LD_VAR 0 1
78574: DIFF
78575: PPUSH
78576: CALL_OW 1
78580: ST_TO_ADDR
// if building in mc_lab [ i ] then
78581: LD_VAR 0 1
78585: PUSH
78586: LD_EXP 56
78590: PUSH
78591: LD_VAR 0 3
78595: ARRAY
78596: IN
78597: IFFALSE 78652
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
78599: LD_ADDR_EXP 57
78603: PUSH
78604: LD_EXP 57
78608: PPUSH
78609: LD_VAR 0 3
78613: PPUSH
78614: LD_EXP 57
78618: PUSH
78619: LD_VAR 0 3
78623: ARRAY
78624: PPUSH
78625: LD_INT 1
78627: PPUSH
78628: LD_EXP 57
78632: PUSH
78633: LD_VAR 0 3
78637: ARRAY
78638: PPUSH
78639: LD_INT 0
78641: PPUSH
78642: CALL 15122 0 4
78646: PPUSH
78647: CALL_OW 1
78651: ST_TO_ADDR
// if not building in mc_bases [ i ] then
78652: LD_VAR 0 1
78656: PUSH
78657: LD_EXP 23
78661: PUSH
78662: LD_VAR 0 3
78666: ARRAY
78667: IN
78668: NOT
78669: IFFALSE 78715
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
78671: LD_ADDR_EXP 23
78675: PUSH
78676: LD_EXP 23
78680: PPUSH
78681: LD_VAR 0 3
78685: PUSH
78686: LD_EXP 23
78690: PUSH
78691: LD_VAR 0 3
78695: ARRAY
78696: PUSH
78697: LD_INT 1
78699: PLUS
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PPUSH
78705: LD_VAR 0 1
78709: PPUSH
78710: CALL 15704 0 3
78714: ST_TO_ADDR
// exit ;
78715: POP
78716: POP
78717: GO 78723
// end ; end ;
78719: GO 78523
78721: POP
78722: POP
// end ;
78723: LD_VAR 0 2
78727: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
78728: LD_INT 0
78730: PPUSH
78731: PPUSH
78732: PPUSH
78733: PPUSH
78734: PPUSH
78735: PPUSH
78736: PPUSH
// if not mc_bases or not skirmish then
78737: LD_EXP 23
78741: NOT
78742: PUSH
78743: LD_EXP 21
78747: NOT
78748: OR
78749: IFFALSE 78753
// exit ;
78751: GO 79414
// for i = 1 to mc_bases do
78753: LD_ADDR_VAR 0 3
78757: PUSH
78758: DOUBLE
78759: LD_INT 1
78761: DEC
78762: ST_TO_ADDR
78763: LD_EXP 23
78767: PUSH
78768: FOR_TO
78769: IFFALSE 79412
// begin if building in mc_construct_list [ i ] then
78771: LD_VAR 0 1
78775: PUSH
78776: LD_EXP 30
78780: PUSH
78781: LD_VAR 0 3
78785: ARRAY
78786: IN
78787: IFFALSE 79410
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
78789: LD_ADDR_EXP 30
78793: PUSH
78794: LD_EXP 30
78798: PPUSH
78799: LD_VAR 0 3
78803: PPUSH
78804: LD_EXP 30
78808: PUSH
78809: LD_VAR 0 3
78813: ARRAY
78814: PUSH
78815: LD_VAR 0 1
78819: DIFF
78820: PPUSH
78821: CALL_OW 1
78825: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
78826: LD_ADDR_EXP 23
78830: PUSH
78831: LD_EXP 23
78835: PPUSH
78836: LD_VAR 0 3
78840: PUSH
78841: LD_EXP 23
78845: PUSH
78846: LD_VAR 0 3
78850: ARRAY
78851: PUSH
78852: LD_INT 1
78854: PLUS
78855: PUSH
78856: EMPTY
78857: LIST
78858: LIST
78859: PPUSH
78860: LD_VAR 0 1
78864: PPUSH
78865: CALL 15704 0 3
78869: ST_TO_ADDR
// btype := GetBType ( building ) ;
78870: LD_ADDR_VAR 0 5
78874: PUSH
78875: LD_VAR 0 1
78879: PPUSH
78880: CALL_OW 266
78884: ST_TO_ADDR
// side := GetSide ( building ) ;
78885: LD_ADDR_VAR 0 8
78889: PUSH
78890: LD_VAR 0 1
78894: PPUSH
78895: CALL_OW 255
78899: ST_TO_ADDR
// if btype = b_lab then
78900: LD_VAR 0 5
78904: PUSH
78905: LD_INT 6
78907: EQUAL
78908: IFFALSE 78958
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
78910: LD_ADDR_EXP 56
78914: PUSH
78915: LD_EXP 56
78919: PPUSH
78920: LD_VAR 0 3
78924: PUSH
78925: LD_EXP 56
78929: PUSH
78930: LD_VAR 0 3
78934: ARRAY
78935: PUSH
78936: LD_INT 1
78938: PLUS
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PPUSH
78944: LD_VAR 0 1
78948: PPUSH
78949: CALL 15704 0 3
78953: ST_TO_ADDR
// exit ;
78954: POP
78955: POP
78956: GO 79414
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
78958: LD_VAR 0 5
78962: PUSH
78963: LD_INT 0
78965: PUSH
78966: LD_INT 2
78968: PUSH
78969: LD_INT 4
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: LIST
78976: IN
78977: IFFALSE 79101
// begin if btype = b_armoury then
78979: LD_VAR 0 5
78983: PUSH
78984: LD_INT 4
78986: EQUAL
78987: IFFALSE 78997
// btype := b_barracks ;
78989: LD_ADDR_VAR 0 5
78993: PUSH
78994: LD_INT 5
78996: ST_TO_ADDR
// if btype = b_depot then
78997: LD_VAR 0 5
79001: PUSH
79002: LD_INT 0
79004: EQUAL
79005: IFFALSE 79015
// btype := b_warehouse ;
79007: LD_ADDR_VAR 0 5
79011: PUSH
79012: LD_INT 1
79014: ST_TO_ADDR
// if btype = b_workshop then
79015: LD_VAR 0 5
79019: PUSH
79020: LD_INT 2
79022: EQUAL
79023: IFFALSE 79033
// btype := b_factory ;
79025: LD_ADDR_VAR 0 5
79029: PUSH
79030: LD_INT 3
79032: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79033: LD_VAR 0 5
79037: PPUSH
79038: LD_VAR 0 8
79042: PPUSH
79043: CALL_OW 323
79047: PUSH
79048: LD_INT 1
79050: EQUAL
79051: IFFALSE 79097
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79053: LD_ADDR_EXP 55
79057: PUSH
79058: LD_EXP 55
79062: PPUSH
79063: LD_VAR 0 3
79067: PUSH
79068: LD_EXP 55
79072: PUSH
79073: LD_VAR 0 3
79077: ARRAY
79078: PUSH
79079: LD_INT 1
79081: PLUS
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PPUSH
79087: LD_VAR 0 1
79091: PPUSH
79092: CALL 15704 0 3
79096: ST_TO_ADDR
// exit ;
79097: POP
79098: POP
79099: GO 79414
// end ; if btype in [ b_bunker , b_turret ] then
79101: LD_VAR 0 5
79105: PUSH
79106: LD_INT 32
79108: PUSH
79109: LD_INT 33
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: IN
79116: IFFALSE 79406
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79118: LD_ADDR_EXP 31
79122: PUSH
79123: LD_EXP 31
79127: PPUSH
79128: LD_VAR 0 3
79132: PUSH
79133: LD_EXP 31
79137: PUSH
79138: LD_VAR 0 3
79142: ARRAY
79143: PUSH
79144: LD_INT 1
79146: PLUS
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PPUSH
79152: LD_VAR 0 1
79156: PPUSH
79157: CALL 15704 0 3
79161: ST_TO_ADDR
// if btype = b_bunker then
79162: LD_VAR 0 5
79166: PUSH
79167: LD_INT 32
79169: EQUAL
79170: IFFALSE 79406
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79172: LD_ADDR_EXP 32
79176: PUSH
79177: LD_EXP 32
79181: PPUSH
79182: LD_VAR 0 3
79186: PUSH
79187: LD_EXP 32
79191: PUSH
79192: LD_VAR 0 3
79196: ARRAY
79197: PUSH
79198: LD_INT 1
79200: PLUS
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PPUSH
79206: LD_VAR 0 1
79210: PPUSH
79211: CALL 15704 0 3
79215: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79216: LD_ADDR_VAR 0 6
79220: PUSH
79221: LD_EXP 23
79225: PUSH
79226: LD_VAR 0 3
79230: ARRAY
79231: PPUSH
79232: LD_INT 25
79234: PUSH
79235: LD_INT 1
79237: PUSH
79238: EMPTY
79239: LIST
79240: LIST
79241: PUSH
79242: LD_INT 3
79244: PUSH
79245: LD_INT 54
79247: PUSH
79248: EMPTY
79249: LIST
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PPUSH
79259: CALL_OW 72
79263: ST_TO_ADDR
// if tmp then
79264: LD_VAR 0 6
79268: IFFALSE 79274
// exit ;
79270: POP
79271: POP
79272: GO 79414
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79274: LD_ADDR_VAR 0 6
79278: PUSH
79279: LD_EXP 23
79283: PUSH
79284: LD_VAR 0 3
79288: ARRAY
79289: PPUSH
79290: LD_INT 2
79292: PUSH
79293: LD_INT 30
79295: PUSH
79296: LD_INT 4
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: LD_INT 30
79305: PUSH
79306: LD_INT 5
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: LIST
79317: PPUSH
79318: CALL_OW 72
79322: ST_TO_ADDR
// if not tmp then
79323: LD_VAR 0 6
79327: NOT
79328: IFFALSE 79334
// exit ;
79330: POP
79331: POP
79332: GO 79414
// for j in tmp do
79334: LD_ADDR_VAR 0 4
79338: PUSH
79339: LD_VAR 0 6
79343: PUSH
79344: FOR_IN
79345: IFFALSE 79404
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79347: LD_ADDR_VAR 0 7
79351: PUSH
79352: LD_VAR 0 4
79356: PPUSH
79357: CALL_OW 313
79361: PPUSH
79362: LD_INT 25
79364: PUSH
79365: LD_INT 1
79367: PUSH
79368: EMPTY
79369: LIST
79370: LIST
79371: PPUSH
79372: CALL_OW 72
79376: ST_TO_ADDR
// if units then
79377: LD_VAR 0 7
79381: IFFALSE 79402
// begin ComExitBuilding ( units [ 1 ] ) ;
79383: LD_VAR 0 7
79387: PUSH
79388: LD_INT 1
79390: ARRAY
79391: PPUSH
79392: CALL_OW 122
// exit ;
79396: POP
79397: POP
79398: POP
79399: POP
79400: GO 79414
// end ; end ;
79402: GO 79344
79404: POP
79405: POP
// end ; end ; exit ;
79406: POP
79407: POP
79408: GO 79414
// end ; end ;
79410: GO 78768
79412: POP
79413: POP
// end ;
79414: LD_VAR 0 2
79418: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79419: LD_INT 0
79421: PPUSH
79422: PPUSH
79423: PPUSH
79424: PPUSH
79425: PPUSH
79426: PPUSH
79427: PPUSH
// if not mc_bases or not skirmish then
79428: LD_EXP 23
79432: NOT
79433: PUSH
79434: LD_EXP 21
79438: NOT
79439: OR
79440: IFFALSE 79444
// exit ;
79442: GO 79709
// btype := GetBType ( building ) ;
79444: LD_ADDR_VAR 0 6
79448: PUSH
79449: LD_VAR 0 1
79453: PPUSH
79454: CALL_OW 266
79458: ST_TO_ADDR
// x := GetX ( building ) ;
79459: LD_ADDR_VAR 0 7
79463: PUSH
79464: LD_VAR 0 1
79468: PPUSH
79469: CALL_OW 250
79473: ST_TO_ADDR
// y := GetY ( building ) ;
79474: LD_ADDR_VAR 0 8
79478: PUSH
79479: LD_VAR 0 1
79483: PPUSH
79484: CALL_OW 251
79488: ST_TO_ADDR
// d := GetDir ( building ) ;
79489: LD_ADDR_VAR 0 9
79493: PUSH
79494: LD_VAR 0 1
79498: PPUSH
79499: CALL_OW 254
79503: ST_TO_ADDR
// for i = 1 to mc_bases do
79504: LD_ADDR_VAR 0 4
79508: PUSH
79509: DOUBLE
79510: LD_INT 1
79512: DEC
79513: ST_TO_ADDR
79514: LD_EXP 23
79518: PUSH
79519: FOR_TO
79520: IFFALSE 79707
// begin if not mc_build_list [ i ] then
79522: LD_EXP 28
79526: PUSH
79527: LD_VAR 0 4
79531: ARRAY
79532: NOT
79533: IFFALSE 79537
// continue ;
79535: GO 79519
// for j := 1 to mc_build_list [ i ] do
79537: LD_ADDR_VAR 0 5
79541: PUSH
79542: DOUBLE
79543: LD_INT 1
79545: DEC
79546: ST_TO_ADDR
79547: LD_EXP 28
79551: PUSH
79552: LD_VAR 0 4
79556: ARRAY
79557: PUSH
79558: FOR_TO
79559: IFFALSE 79703
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
79561: LD_VAR 0 6
79565: PUSH
79566: LD_VAR 0 7
79570: PUSH
79571: LD_VAR 0 8
79575: PUSH
79576: LD_VAR 0 9
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: LIST
79585: LIST
79586: PPUSH
79587: LD_EXP 28
79591: PUSH
79592: LD_VAR 0 4
79596: ARRAY
79597: PUSH
79598: LD_VAR 0 5
79602: ARRAY
79603: PPUSH
79604: CALL 21886 0 2
79608: IFFALSE 79701
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
79610: LD_ADDR_EXP 28
79614: PUSH
79615: LD_EXP 28
79619: PPUSH
79620: LD_VAR 0 4
79624: PPUSH
79625: LD_EXP 28
79629: PUSH
79630: LD_VAR 0 4
79634: ARRAY
79635: PPUSH
79636: LD_VAR 0 5
79640: PPUSH
79641: CALL_OW 3
79645: PPUSH
79646: CALL_OW 1
79650: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
79651: LD_ADDR_EXP 30
79655: PUSH
79656: LD_EXP 30
79660: PPUSH
79661: LD_VAR 0 4
79665: PUSH
79666: LD_EXP 30
79670: PUSH
79671: LD_VAR 0 4
79675: ARRAY
79676: PUSH
79677: LD_INT 1
79679: PLUS
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PPUSH
79685: LD_VAR 0 1
79689: PPUSH
79690: CALL 15704 0 3
79694: ST_TO_ADDR
// exit ;
79695: POP
79696: POP
79697: POP
79698: POP
79699: GO 79709
// end ;
79701: GO 79558
79703: POP
79704: POP
// end ;
79705: GO 79519
79707: POP
79708: POP
// end ;
79709: LD_VAR 0 3
79713: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
79714: LD_INT 0
79716: PPUSH
79717: PPUSH
79718: PPUSH
// if not mc_bases or not skirmish then
79719: LD_EXP 23
79723: NOT
79724: PUSH
79725: LD_EXP 21
79729: NOT
79730: OR
79731: IFFALSE 79735
// exit ;
79733: GO 79925
// for i = 1 to mc_bases do
79735: LD_ADDR_VAR 0 4
79739: PUSH
79740: DOUBLE
79741: LD_INT 1
79743: DEC
79744: ST_TO_ADDR
79745: LD_EXP 23
79749: PUSH
79750: FOR_TO
79751: IFFALSE 79838
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
79753: LD_VAR 0 1
79757: PUSH
79758: LD_EXP 31
79762: PUSH
79763: LD_VAR 0 4
79767: ARRAY
79768: IN
79769: PUSH
79770: LD_VAR 0 1
79774: PUSH
79775: LD_EXP 32
79779: PUSH
79780: LD_VAR 0 4
79784: ARRAY
79785: IN
79786: NOT
79787: AND
79788: IFFALSE 79836
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79790: LD_ADDR_EXP 32
79794: PUSH
79795: LD_EXP 32
79799: PPUSH
79800: LD_VAR 0 4
79804: PUSH
79805: LD_EXP 32
79809: PUSH
79810: LD_VAR 0 4
79814: ARRAY
79815: PUSH
79816: LD_INT 1
79818: PLUS
79819: PUSH
79820: EMPTY
79821: LIST
79822: LIST
79823: PPUSH
79824: LD_VAR 0 1
79828: PPUSH
79829: CALL 15704 0 3
79833: ST_TO_ADDR
// break ;
79834: GO 79838
// end ; end ;
79836: GO 79750
79838: POP
79839: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
79840: LD_VAR 0 1
79844: PPUSH
79845: CALL_OW 257
79849: PUSH
79850: LD_EXP 49
79854: IN
79855: PUSH
79856: LD_VAR 0 1
79860: PPUSH
79861: CALL_OW 266
79865: PUSH
79866: LD_INT 5
79868: EQUAL
79869: AND
79870: PUSH
79871: LD_VAR 0 2
79875: PPUSH
79876: CALL_OW 110
79880: PUSH
79881: LD_INT 18
79883: NONEQUAL
79884: AND
79885: IFFALSE 79925
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
79887: LD_VAR 0 2
79891: PPUSH
79892: CALL_OW 257
79896: PUSH
79897: LD_INT 5
79899: PUSH
79900: LD_INT 8
79902: PUSH
79903: LD_INT 9
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: LIST
79910: IN
79911: IFFALSE 79925
// SetClass ( unit , 1 ) ;
79913: LD_VAR 0 2
79917: PPUSH
79918: LD_INT 1
79920: PPUSH
79921: CALL_OW 336
// end ;
79925: LD_VAR 0 3
79929: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
79930: LD_INT 0
79932: PPUSH
79933: PPUSH
// if not mc_bases or not skirmish then
79934: LD_EXP 23
79938: NOT
79939: PUSH
79940: LD_EXP 21
79944: NOT
79945: OR
79946: IFFALSE 79950
// exit ;
79948: GO 80066
// if GetLives ( abandoned_vehicle ) > 250 then
79950: LD_VAR 0 2
79954: PPUSH
79955: CALL_OW 256
79959: PUSH
79960: LD_INT 250
79962: GREATER
79963: IFFALSE 79967
// exit ;
79965: GO 80066
// for i = 1 to mc_bases do
79967: LD_ADDR_VAR 0 6
79971: PUSH
79972: DOUBLE
79973: LD_INT 1
79975: DEC
79976: ST_TO_ADDR
79977: LD_EXP 23
79981: PUSH
79982: FOR_TO
79983: IFFALSE 80064
// begin if driver in mc_bases [ i ] then
79985: LD_VAR 0 1
79989: PUSH
79990: LD_EXP 23
79994: PUSH
79995: LD_VAR 0 6
79999: ARRAY
80000: IN
80001: IFFALSE 80062
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80003: LD_VAR 0 1
80007: PPUSH
80008: LD_EXP 23
80012: PUSH
80013: LD_VAR 0 6
80017: ARRAY
80018: PPUSH
80019: LD_INT 2
80021: PUSH
80022: LD_INT 30
80024: PUSH
80025: LD_INT 0
80027: PUSH
80028: EMPTY
80029: LIST
80030: LIST
80031: PUSH
80032: LD_INT 30
80034: PUSH
80035: LD_INT 1
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: LIST
80046: PPUSH
80047: CALL_OW 72
80051: PUSH
80052: LD_INT 1
80054: ARRAY
80055: PPUSH
80056: CALL 48322 0 2
// break ;
80060: GO 80064
// end ; end ;
80062: GO 79982
80064: POP
80065: POP
// end ; end_of_file
80066: LD_VAR 0 5
80070: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
80071: LD_INT 0
80073: PPUSH
// ar_miner := 81 ;
80074: LD_ADDR_EXP 74
80078: PUSH
80079: LD_INT 81
80081: ST_TO_ADDR
// ar_crane := 88 ;
80082: LD_ADDR_EXP 73
80086: PUSH
80087: LD_INT 88
80089: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80090: LD_ADDR_EXP 68
80094: PUSH
80095: LD_INT 89
80097: ST_TO_ADDR
// us_hack := 99 ;
80098: LD_ADDR_EXP 69
80102: PUSH
80103: LD_INT 99
80105: ST_TO_ADDR
// us_artillery := 97 ;
80106: LD_ADDR_EXP 70
80110: PUSH
80111: LD_INT 97
80113: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80114: LD_ADDR_EXP 71
80118: PUSH
80119: LD_INT 91
80121: ST_TO_ADDR
// ar_mortar := 92 ;
80122: LD_ADDR_EXP 72
80126: PUSH
80127: LD_INT 92
80129: ST_TO_ADDR
// ru_radar := 98 ;
80130: LD_ADDR_EXP 67
80134: PUSH
80135: LD_INT 98
80137: ST_TO_ADDR
// tech_Artillery := 80 ;
80138: LD_ADDR_EXP 75
80142: PUSH
80143: LD_INT 80
80145: ST_TO_ADDR
// tech_RadMat := 81 ;
80146: LD_ADDR_EXP 76
80150: PUSH
80151: LD_INT 81
80153: ST_TO_ADDR
// tech_BasicTools := 82 ;
80154: LD_ADDR_EXP 77
80158: PUSH
80159: LD_INT 82
80161: ST_TO_ADDR
// tech_Cargo := 83 ;
80162: LD_ADDR_EXP 78
80166: PUSH
80167: LD_INT 83
80169: ST_TO_ADDR
// tech_Track := 84 ;
80170: LD_ADDR_EXP 79
80174: PUSH
80175: LD_INT 84
80177: ST_TO_ADDR
// tech_Crane := 85 ;
80178: LD_ADDR_EXP 80
80182: PUSH
80183: LD_INT 85
80185: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80186: LD_ADDR_EXP 81
80190: PUSH
80191: LD_INT 86
80193: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80194: LD_ADDR_EXP 82
80198: PUSH
80199: LD_INT 87
80201: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
80202: LD_ADDR_EXP 83
80206: PUSH
80207: LD_INT 88
80209: ST_TO_ADDR
// class_mastodont := 31 ;
80210: LD_ADDR_EXP 84
80214: PUSH
80215: LD_INT 31
80217: ST_TO_ADDR
// class_horse := 21 ;
80218: LD_ADDR_EXP 85
80222: PUSH
80223: LD_INT 21
80225: ST_TO_ADDR
// end ;
80226: LD_VAR 0 1
80230: RET
// every 1 do
80231: GO 80233
80233: DISABLE
// InitGlobalVariables ; end_of_file
80234: CALL 80071 0 0
80238: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
80239: LD_INT 0
80241: PPUSH
80242: PPUSH
80243: PPUSH
80244: PPUSH
80245: PPUSH
80246: PPUSH
80247: PPUSH
80248: PPUSH
80249: PPUSH
80250: PPUSH
80251: PPUSH
80252: PPUSH
80253: PPUSH
80254: PPUSH
80255: PPUSH
80256: PPUSH
80257: PPUSH
80258: PPUSH
80259: PPUSH
80260: PPUSH
80261: PPUSH
80262: PPUSH
80263: PPUSH
80264: PPUSH
80265: PPUSH
80266: PPUSH
80267: PPUSH
80268: PPUSH
80269: PPUSH
80270: PPUSH
80271: PPUSH
80272: PPUSH
80273: PPUSH
80274: PPUSH
// if not list then
80275: LD_VAR 0 1
80279: NOT
80280: IFFALSE 80284
// exit ;
80282: GO 84943
// base := list [ 1 ] ;
80284: LD_ADDR_VAR 0 3
80288: PUSH
80289: LD_VAR 0 1
80293: PUSH
80294: LD_INT 1
80296: ARRAY
80297: ST_TO_ADDR
// group := list [ 2 ] ;
80298: LD_ADDR_VAR 0 4
80302: PUSH
80303: LD_VAR 0 1
80307: PUSH
80308: LD_INT 2
80310: ARRAY
80311: ST_TO_ADDR
// path := list [ 3 ] ;
80312: LD_ADDR_VAR 0 5
80316: PUSH
80317: LD_VAR 0 1
80321: PUSH
80322: LD_INT 3
80324: ARRAY
80325: ST_TO_ADDR
// flags := list [ 4 ] ;
80326: LD_ADDR_VAR 0 6
80330: PUSH
80331: LD_VAR 0 1
80335: PUSH
80336: LD_INT 4
80338: ARRAY
80339: ST_TO_ADDR
// mined := [ ] ;
80340: LD_ADDR_VAR 0 27
80344: PUSH
80345: EMPTY
80346: ST_TO_ADDR
// bombed := [ ] ;
80347: LD_ADDR_VAR 0 28
80351: PUSH
80352: EMPTY
80353: ST_TO_ADDR
// healers := [ ] ;
80354: LD_ADDR_VAR 0 31
80358: PUSH
80359: EMPTY
80360: ST_TO_ADDR
// to_heal := [ ] ;
80361: LD_ADDR_VAR 0 30
80365: PUSH
80366: EMPTY
80367: ST_TO_ADDR
// repairs := [ ] ;
80368: LD_ADDR_VAR 0 33
80372: PUSH
80373: EMPTY
80374: ST_TO_ADDR
// to_repair := [ ] ;
80375: LD_ADDR_VAR 0 32
80379: PUSH
80380: EMPTY
80381: ST_TO_ADDR
// if not group or not path then
80382: LD_VAR 0 4
80386: NOT
80387: PUSH
80388: LD_VAR 0 5
80392: NOT
80393: OR
80394: IFFALSE 80398
// exit ;
80396: GO 84943
// side := GetSide ( group [ 1 ] ) ;
80398: LD_ADDR_VAR 0 35
80402: PUSH
80403: LD_VAR 0 4
80407: PUSH
80408: LD_INT 1
80410: ARRAY
80411: PPUSH
80412: CALL_OW 255
80416: ST_TO_ADDR
// if flags then
80417: LD_VAR 0 6
80421: IFFALSE 80565
// begin f_ignore_area := flags [ 1 ] ;
80423: LD_ADDR_VAR 0 17
80427: PUSH
80428: LD_VAR 0 6
80432: PUSH
80433: LD_INT 1
80435: ARRAY
80436: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
80437: LD_ADDR_VAR 0 18
80441: PUSH
80442: LD_VAR 0 6
80446: PUSH
80447: LD_INT 2
80449: ARRAY
80450: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
80451: LD_ADDR_VAR 0 19
80455: PUSH
80456: LD_VAR 0 6
80460: PUSH
80461: LD_INT 3
80463: ARRAY
80464: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
80465: LD_ADDR_VAR 0 20
80469: PUSH
80470: LD_VAR 0 6
80474: PUSH
80475: LD_INT 4
80477: ARRAY
80478: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
80479: LD_ADDR_VAR 0 21
80483: PUSH
80484: LD_VAR 0 6
80488: PUSH
80489: LD_INT 5
80491: ARRAY
80492: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
80493: LD_ADDR_VAR 0 22
80497: PUSH
80498: LD_VAR 0 6
80502: PUSH
80503: LD_INT 6
80505: ARRAY
80506: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
80507: LD_ADDR_VAR 0 23
80511: PUSH
80512: LD_VAR 0 6
80516: PUSH
80517: LD_INT 7
80519: ARRAY
80520: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
80521: LD_ADDR_VAR 0 24
80525: PUSH
80526: LD_VAR 0 6
80530: PUSH
80531: LD_INT 8
80533: ARRAY
80534: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
80535: LD_ADDR_VAR 0 25
80539: PUSH
80540: LD_VAR 0 6
80544: PUSH
80545: LD_INT 9
80547: ARRAY
80548: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
80549: LD_ADDR_VAR 0 26
80553: PUSH
80554: LD_VAR 0 6
80558: PUSH
80559: LD_INT 10
80561: ARRAY
80562: ST_TO_ADDR
// end else
80563: GO 80645
// begin f_ignore_area := false ;
80565: LD_ADDR_VAR 0 17
80569: PUSH
80570: LD_INT 0
80572: ST_TO_ADDR
// f_capture := false ;
80573: LD_ADDR_VAR 0 18
80577: PUSH
80578: LD_INT 0
80580: ST_TO_ADDR
// f_ignore_civ := false ;
80581: LD_ADDR_VAR 0 19
80585: PUSH
80586: LD_INT 0
80588: ST_TO_ADDR
// f_murder := false ;
80589: LD_ADDR_VAR 0 20
80593: PUSH
80594: LD_INT 0
80596: ST_TO_ADDR
// f_mines := false ;
80597: LD_ADDR_VAR 0 21
80601: PUSH
80602: LD_INT 0
80604: ST_TO_ADDR
// f_repair := false ;
80605: LD_ADDR_VAR 0 22
80609: PUSH
80610: LD_INT 0
80612: ST_TO_ADDR
// f_heal := false ;
80613: LD_ADDR_VAR 0 23
80617: PUSH
80618: LD_INT 0
80620: ST_TO_ADDR
// f_spacetime := false ;
80621: LD_ADDR_VAR 0 24
80625: PUSH
80626: LD_INT 0
80628: ST_TO_ADDR
// f_attack_depot := false ;
80629: LD_ADDR_VAR 0 25
80633: PUSH
80634: LD_INT 0
80636: ST_TO_ADDR
// f_crawl := false ;
80637: LD_ADDR_VAR 0 26
80641: PUSH
80642: LD_INT 0
80644: ST_TO_ADDR
// end ; if f_heal then
80645: LD_VAR 0 23
80649: IFFALSE 80676
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
80651: LD_ADDR_VAR 0 31
80655: PUSH
80656: LD_VAR 0 4
80660: PPUSH
80661: LD_INT 25
80663: PUSH
80664: LD_INT 4
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PPUSH
80671: CALL_OW 72
80675: ST_TO_ADDR
// if f_repair then
80676: LD_VAR 0 22
80680: IFFALSE 80707
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
80682: LD_ADDR_VAR 0 33
80686: PUSH
80687: LD_VAR 0 4
80691: PPUSH
80692: LD_INT 25
80694: PUSH
80695: LD_INT 3
80697: PUSH
80698: EMPTY
80699: LIST
80700: LIST
80701: PPUSH
80702: CALL_OW 72
80706: ST_TO_ADDR
// units_path := [ ] ;
80707: LD_ADDR_VAR 0 16
80711: PUSH
80712: EMPTY
80713: ST_TO_ADDR
// for i = 1 to group do
80714: LD_ADDR_VAR 0 7
80718: PUSH
80719: DOUBLE
80720: LD_INT 1
80722: DEC
80723: ST_TO_ADDR
80724: LD_VAR 0 4
80728: PUSH
80729: FOR_TO
80730: IFFALSE 80759
// units_path := Replace ( units_path , i , path ) ;
80732: LD_ADDR_VAR 0 16
80736: PUSH
80737: LD_VAR 0 16
80741: PPUSH
80742: LD_VAR 0 7
80746: PPUSH
80747: LD_VAR 0 5
80751: PPUSH
80752: CALL_OW 1
80756: ST_TO_ADDR
80757: GO 80729
80759: POP
80760: POP
// repeat for i = group downto 1 do
80761: LD_ADDR_VAR 0 7
80765: PUSH
80766: DOUBLE
80767: LD_VAR 0 4
80771: INC
80772: ST_TO_ADDR
80773: LD_INT 1
80775: PUSH
80776: FOR_DOWNTO
80777: IFFALSE 84899
// begin wait ( 5 ) ;
80779: LD_INT 5
80781: PPUSH
80782: CALL_OW 67
// tmp := [ ] ;
80786: LD_ADDR_VAR 0 14
80790: PUSH
80791: EMPTY
80792: ST_TO_ADDR
// attacking := false ;
80793: LD_ADDR_VAR 0 29
80797: PUSH
80798: LD_INT 0
80800: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
80801: LD_VAR 0 4
80805: PUSH
80806: LD_VAR 0 7
80810: ARRAY
80811: PPUSH
80812: CALL_OW 301
80816: PUSH
80817: LD_VAR 0 4
80821: PUSH
80822: LD_VAR 0 7
80826: ARRAY
80827: NOT
80828: OR
80829: IFFALSE 80938
// begin if GetType ( group [ i ] ) = unit_human then
80831: LD_VAR 0 4
80835: PUSH
80836: LD_VAR 0 7
80840: ARRAY
80841: PPUSH
80842: CALL_OW 247
80846: PUSH
80847: LD_INT 1
80849: EQUAL
80850: IFFALSE 80896
// begin to_heal := to_heal diff group [ i ] ;
80852: LD_ADDR_VAR 0 30
80856: PUSH
80857: LD_VAR 0 30
80861: PUSH
80862: LD_VAR 0 4
80866: PUSH
80867: LD_VAR 0 7
80871: ARRAY
80872: DIFF
80873: ST_TO_ADDR
// healers := healers diff group [ i ] ;
80874: LD_ADDR_VAR 0 31
80878: PUSH
80879: LD_VAR 0 31
80883: PUSH
80884: LD_VAR 0 4
80888: PUSH
80889: LD_VAR 0 7
80893: ARRAY
80894: DIFF
80895: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
80896: LD_ADDR_VAR 0 4
80900: PUSH
80901: LD_VAR 0 4
80905: PPUSH
80906: LD_VAR 0 7
80910: PPUSH
80911: CALL_OW 3
80915: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
80916: LD_ADDR_VAR 0 16
80920: PUSH
80921: LD_VAR 0 16
80925: PPUSH
80926: LD_VAR 0 7
80930: PPUSH
80931: CALL_OW 3
80935: ST_TO_ADDR
// continue ;
80936: GO 80776
// end ; if f_repair then
80938: LD_VAR 0 22
80942: IFFALSE 81431
// begin if GetType ( group [ i ] ) = unit_vehicle then
80944: LD_VAR 0 4
80948: PUSH
80949: LD_VAR 0 7
80953: ARRAY
80954: PPUSH
80955: CALL_OW 247
80959: PUSH
80960: LD_INT 2
80962: EQUAL
80963: IFFALSE 81153
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
80965: LD_VAR 0 4
80969: PUSH
80970: LD_VAR 0 7
80974: ARRAY
80975: PPUSH
80976: CALL_OW 256
80980: PUSH
80981: LD_INT 700
80983: LESS
80984: PUSH
80985: LD_VAR 0 4
80989: PUSH
80990: LD_VAR 0 7
80994: ARRAY
80995: PUSH
80996: LD_VAR 0 32
81000: IN
81001: NOT
81002: AND
81003: IFFALSE 81027
// to_repair := to_repair union group [ i ] ;
81005: LD_ADDR_VAR 0 32
81009: PUSH
81010: LD_VAR 0 32
81014: PUSH
81015: LD_VAR 0 4
81019: PUSH
81020: LD_VAR 0 7
81024: ARRAY
81025: UNION
81026: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
81027: LD_VAR 0 4
81031: PUSH
81032: LD_VAR 0 7
81036: ARRAY
81037: PPUSH
81038: CALL_OW 256
81042: PUSH
81043: LD_INT 1000
81045: EQUAL
81046: PUSH
81047: LD_VAR 0 4
81051: PUSH
81052: LD_VAR 0 7
81056: ARRAY
81057: PUSH
81058: LD_VAR 0 32
81062: IN
81063: AND
81064: IFFALSE 81088
// to_repair := to_repair diff group [ i ] ;
81066: LD_ADDR_VAR 0 32
81070: PUSH
81071: LD_VAR 0 32
81075: PUSH
81076: LD_VAR 0 4
81080: PUSH
81081: LD_VAR 0 7
81085: ARRAY
81086: DIFF
81087: ST_TO_ADDR
// if group [ i ] in to_repair then
81088: LD_VAR 0 4
81092: PUSH
81093: LD_VAR 0 7
81097: ARRAY
81098: PUSH
81099: LD_VAR 0 32
81103: IN
81104: IFFALSE 81151
// begin if not IsInArea ( group [ i ] , f_repair ) then
81106: LD_VAR 0 4
81110: PUSH
81111: LD_VAR 0 7
81115: ARRAY
81116: PPUSH
81117: LD_VAR 0 22
81121: PPUSH
81122: CALL_OW 308
81126: NOT
81127: IFFALSE 81149
// ComMoveToArea ( group [ i ] , f_repair ) ;
81129: LD_VAR 0 4
81133: PUSH
81134: LD_VAR 0 7
81138: ARRAY
81139: PPUSH
81140: LD_VAR 0 22
81144: PPUSH
81145: CALL_OW 113
// continue ;
81149: GO 80776
// end ; end else
81151: GO 81431
// if group [ i ] in repairs then
81153: LD_VAR 0 4
81157: PUSH
81158: LD_VAR 0 7
81162: ARRAY
81163: PUSH
81164: LD_VAR 0 33
81168: IN
81169: IFFALSE 81431
// begin if IsInUnit ( group [ i ] ) then
81171: LD_VAR 0 4
81175: PUSH
81176: LD_VAR 0 7
81180: ARRAY
81181: PPUSH
81182: CALL_OW 310
81186: IFFALSE 81254
// begin z := IsInUnit ( group [ i ] ) ;
81188: LD_ADDR_VAR 0 13
81192: PUSH
81193: LD_VAR 0 4
81197: PUSH
81198: LD_VAR 0 7
81202: ARRAY
81203: PPUSH
81204: CALL_OW 310
81208: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
81209: LD_VAR 0 13
81213: PUSH
81214: LD_VAR 0 32
81218: IN
81219: PUSH
81220: LD_VAR 0 13
81224: PPUSH
81225: LD_VAR 0 22
81229: PPUSH
81230: CALL_OW 308
81234: AND
81235: IFFALSE 81252
// ComExitVehicle ( group [ i ] ) ;
81237: LD_VAR 0 4
81241: PUSH
81242: LD_VAR 0 7
81246: ARRAY
81247: PPUSH
81248: CALL_OW 121
// end else
81252: GO 81431
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
81254: LD_ADDR_VAR 0 13
81258: PUSH
81259: LD_VAR 0 4
81263: PPUSH
81264: LD_INT 95
81266: PUSH
81267: LD_VAR 0 22
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 58
81278: PUSH
81279: EMPTY
81280: LIST
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PPUSH
81286: CALL_OW 72
81290: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
81291: LD_VAR 0 4
81295: PUSH
81296: LD_VAR 0 7
81300: ARRAY
81301: PPUSH
81302: CALL_OW 314
81306: NOT
81307: IFFALSE 81429
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
81309: LD_ADDR_VAR 0 10
81313: PUSH
81314: LD_VAR 0 13
81318: PPUSH
81319: LD_VAR 0 4
81323: PUSH
81324: LD_VAR 0 7
81328: ARRAY
81329: PPUSH
81330: CALL_OW 74
81334: ST_TO_ADDR
// if not x then
81335: LD_VAR 0 10
81339: NOT
81340: IFFALSE 81344
// continue ;
81342: GO 80776
// if GetLives ( x ) < 1000 then
81344: LD_VAR 0 10
81348: PPUSH
81349: CALL_OW 256
81353: PUSH
81354: LD_INT 1000
81356: LESS
81357: IFFALSE 81381
// ComRepairVehicle ( group [ i ] , x ) else
81359: LD_VAR 0 4
81363: PUSH
81364: LD_VAR 0 7
81368: ARRAY
81369: PPUSH
81370: LD_VAR 0 10
81374: PPUSH
81375: CALL_OW 129
81379: GO 81429
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
81381: LD_VAR 0 23
81385: PUSH
81386: LD_VAR 0 4
81390: PUSH
81391: LD_VAR 0 7
81395: ARRAY
81396: PPUSH
81397: CALL_OW 256
81401: PUSH
81402: LD_INT 1000
81404: LESS
81405: AND
81406: NOT
81407: IFFALSE 81429
// ComEnterUnit ( group [ i ] , x ) ;
81409: LD_VAR 0 4
81413: PUSH
81414: LD_VAR 0 7
81418: ARRAY
81419: PPUSH
81420: LD_VAR 0 10
81424: PPUSH
81425: CALL_OW 120
// end ; continue ;
81429: GO 80776
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
81431: LD_VAR 0 23
81435: PUSH
81436: LD_VAR 0 4
81440: PUSH
81441: LD_VAR 0 7
81445: ARRAY
81446: PPUSH
81447: CALL_OW 247
81451: PUSH
81452: LD_INT 1
81454: EQUAL
81455: AND
81456: IFFALSE 81934
// begin if group [ i ] in healers then
81458: LD_VAR 0 4
81462: PUSH
81463: LD_VAR 0 7
81467: ARRAY
81468: PUSH
81469: LD_VAR 0 31
81473: IN
81474: IFFALSE 81747
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
81476: LD_VAR 0 4
81480: PUSH
81481: LD_VAR 0 7
81485: ARRAY
81486: PPUSH
81487: LD_VAR 0 23
81491: PPUSH
81492: CALL_OW 308
81496: NOT
81497: PUSH
81498: LD_VAR 0 4
81502: PUSH
81503: LD_VAR 0 7
81507: ARRAY
81508: PPUSH
81509: CALL_OW 314
81513: NOT
81514: AND
81515: IFFALSE 81539
// ComMoveToArea ( group [ i ] , f_heal ) else
81517: LD_VAR 0 4
81521: PUSH
81522: LD_VAR 0 7
81526: ARRAY
81527: PPUSH
81528: LD_VAR 0 23
81532: PPUSH
81533: CALL_OW 113
81537: GO 81745
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
81539: LD_VAR 0 4
81543: PUSH
81544: LD_VAR 0 7
81548: ARRAY
81549: PPUSH
81550: CALL 44784 0 1
81554: PPUSH
81555: CALL_OW 256
81559: PUSH
81560: LD_INT 1000
81562: EQUAL
81563: IFFALSE 81582
// ComStop ( group [ i ] ) else
81565: LD_VAR 0 4
81569: PUSH
81570: LD_VAR 0 7
81574: ARRAY
81575: PPUSH
81576: CALL_OW 141
81580: GO 81745
// if not HasTask ( group [ i ] ) and to_heal then
81582: LD_VAR 0 4
81586: PUSH
81587: LD_VAR 0 7
81591: ARRAY
81592: PPUSH
81593: CALL_OW 314
81597: NOT
81598: PUSH
81599: LD_VAR 0 30
81603: AND
81604: IFFALSE 81745
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
81606: LD_ADDR_VAR 0 13
81610: PUSH
81611: LD_VAR 0 30
81615: PPUSH
81616: LD_INT 3
81618: PUSH
81619: LD_INT 54
81621: PUSH
81622: EMPTY
81623: LIST
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PPUSH
81629: CALL_OW 72
81633: PPUSH
81634: LD_VAR 0 4
81638: PUSH
81639: LD_VAR 0 7
81643: ARRAY
81644: PPUSH
81645: CALL_OW 74
81649: ST_TO_ADDR
// if z then
81650: LD_VAR 0 13
81654: IFFALSE 81745
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
81656: LD_INT 91
81658: PUSH
81659: LD_VAR 0 13
81663: PUSH
81664: LD_INT 10
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: LIST
81671: PUSH
81672: LD_INT 81
81674: PUSH
81675: LD_VAR 0 13
81679: PPUSH
81680: CALL_OW 255
81684: PUSH
81685: EMPTY
81686: LIST
81687: LIST
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PPUSH
81693: CALL_OW 69
81697: PUSH
81698: LD_INT 0
81700: EQUAL
81701: IFFALSE 81725
// ComHeal ( group [ i ] , z ) else
81703: LD_VAR 0 4
81707: PUSH
81708: LD_VAR 0 7
81712: ARRAY
81713: PPUSH
81714: LD_VAR 0 13
81718: PPUSH
81719: CALL_OW 128
81723: GO 81745
// ComMoveToArea ( group [ i ] , f_heal ) ;
81725: LD_VAR 0 4
81729: PUSH
81730: LD_VAR 0 7
81734: ARRAY
81735: PPUSH
81736: LD_VAR 0 23
81740: PPUSH
81741: CALL_OW 113
// end ; continue ;
81745: GO 80776
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
81747: LD_VAR 0 4
81751: PUSH
81752: LD_VAR 0 7
81756: ARRAY
81757: PPUSH
81758: CALL_OW 256
81762: PUSH
81763: LD_INT 700
81765: LESS
81766: PUSH
81767: LD_VAR 0 4
81771: PUSH
81772: LD_VAR 0 7
81776: ARRAY
81777: PUSH
81778: LD_VAR 0 30
81782: IN
81783: NOT
81784: AND
81785: IFFALSE 81809
// to_heal := to_heal union group [ i ] ;
81787: LD_ADDR_VAR 0 30
81791: PUSH
81792: LD_VAR 0 30
81796: PUSH
81797: LD_VAR 0 4
81801: PUSH
81802: LD_VAR 0 7
81806: ARRAY
81807: UNION
81808: ST_TO_ADDR
// if group [ i ] in to_heal then
81809: LD_VAR 0 4
81813: PUSH
81814: LD_VAR 0 7
81818: ARRAY
81819: PUSH
81820: LD_VAR 0 30
81824: IN
81825: IFFALSE 81934
// begin if GetLives ( group [ i ] ) = 1000 then
81827: LD_VAR 0 4
81831: PUSH
81832: LD_VAR 0 7
81836: ARRAY
81837: PPUSH
81838: CALL_OW 256
81842: PUSH
81843: LD_INT 1000
81845: EQUAL
81846: IFFALSE 81872
// to_heal := to_heal diff group [ i ] else
81848: LD_ADDR_VAR 0 30
81852: PUSH
81853: LD_VAR 0 30
81857: PUSH
81858: LD_VAR 0 4
81862: PUSH
81863: LD_VAR 0 7
81867: ARRAY
81868: DIFF
81869: ST_TO_ADDR
81870: GO 81934
// begin if not IsInArea ( group [ i ] , to_heal ) then
81872: LD_VAR 0 4
81876: PUSH
81877: LD_VAR 0 7
81881: ARRAY
81882: PPUSH
81883: LD_VAR 0 30
81887: PPUSH
81888: CALL_OW 308
81892: NOT
81893: IFFALSE 81917
// ComMoveToArea ( group [ i ] , f_heal ) else
81895: LD_VAR 0 4
81899: PUSH
81900: LD_VAR 0 7
81904: ARRAY
81905: PPUSH
81906: LD_VAR 0 23
81910: PPUSH
81911: CALL_OW 113
81915: GO 81932
// ComHold ( group [ i ] ) ;
81917: LD_VAR 0 4
81921: PUSH
81922: LD_VAR 0 7
81926: ARRAY
81927: PPUSH
81928: CALL_OW 140
// continue ;
81932: GO 80776
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
81934: LD_VAR 0 4
81938: PUSH
81939: LD_VAR 0 7
81943: ARRAY
81944: PPUSH
81945: LD_INT 10
81947: PPUSH
81948: CALL 43204 0 2
81952: NOT
81953: PUSH
81954: LD_VAR 0 16
81958: PUSH
81959: LD_VAR 0 7
81963: ARRAY
81964: PUSH
81965: EMPTY
81966: EQUAL
81967: NOT
81968: AND
81969: IFFALSE 82235
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
81971: LD_VAR 0 4
81975: PUSH
81976: LD_VAR 0 7
81980: ARRAY
81981: PPUSH
81982: CALL_OW 262
81986: PUSH
81987: LD_INT 1
81989: PUSH
81990: LD_INT 2
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: IN
81997: IFFALSE 82038
// if GetFuel ( group [ i ] ) < 10 then
81999: LD_VAR 0 4
82003: PUSH
82004: LD_VAR 0 7
82008: ARRAY
82009: PPUSH
82010: CALL_OW 261
82014: PUSH
82015: LD_INT 10
82017: LESS
82018: IFFALSE 82038
// SetFuel ( group [ i ] , 12 ) ;
82020: LD_VAR 0 4
82024: PUSH
82025: LD_VAR 0 7
82029: ARRAY
82030: PPUSH
82031: LD_INT 12
82033: PPUSH
82034: CALL_OW 240
// if units_path [ i ] then
82038: LD_VAR 0 16
82042: PUSH
82043: LD_VAR 0 7
82047: ARRAY
82048: IFFALSE 82233
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
82050: LD_VAR 0 4
82054: PUSH
82055: LD_VAR 0 7
82059: ARRAY
82060: PPUSH
82061: LD_VAR 0 16
82065: PUSH
82066: LD_VAR 0 7
82070: ARRAY
82071: PUSH
82072: LD_INT 1
82074: ARRAY
82075: PUSH
82076: LD_INT 1
82078: ARRAY
82079: PPUSH
82080: LD_VAR 0 16
82084: PUSH
82085: LD_VAR 0 7
82089: ARRAY
82090: PUSH
82091: LD_INT 1
82093: ARRAY
82094: PUSH
82095: LD_INT 2
82097: ARRAY
82098: PPUSH
82099: CALL_OW 297
82103: PUSH
82104: LD_INT 6
82106: GREATER
82107: IFFALSE 82182
// begin if not HasTask ( group [ i ] ) then
82109: LD_VAR 0 4
82113: PUSH
82114: LD_VAR 0 7
82118: ARRAY
82119: PPUSH
82120: CALL_OW 314
82124: NOT
82125: IFFALSE 82180
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
82127: LD_VAR 0 4
82131: PUSH
82132: LD_VAR 0 7
82136: ARRAY
82137: PPUSH
82138: LD_VAR 0 16
82142: PUSH
82143: LD_VAR 0 7
82147: ARRAY
82148: PUSH
82149: LD_INT 1
82151: ARRAY
82152: PUSH
82153: LD_INT 1
82155: ARRAY
82156: PPUSH
82157: LD_VAR 0 16
82161: PUSH
82162: LD_VAR 0 7
82166: ARRAY
82167: PUSH
82168: LD_INT 1
82170: ARRAY
82171: PUSH
82172: LD_INT 2
82174: ARRAY
82175: PPUSH
82176: CALL_OW 114
// end else
82180: GO 82233
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
82182: LD_ADDR_VAR 0 15
82186: PUSH
82187: LD_VAR 0 16
82191: PUSH
82192: LD_VAR 0 7
82196: ARRAY
82197: PPUSH
82198: LD_INT 1
82200: PPUSH
82201: CALL_OW 3
82205: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
82206: LD_ADDR_VAR 0 16
82210: PUSH
82211: LD_VAR 0 16
82215: PPUSH
82216: LD_VAR 0 7
82220: PPUSH
82221: LD_VAR 0 15
82225: PPUSH
82226: CALL_OW 1
82230: ST_TO_ADDR
// continue ;
82231: GO 80776
// end ; end ; end else
82233: GO 84897
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
82235: LD_ADDR_VAR 0 14
82239: PUSH
82240: LD_INT 81
82242: PUSH
82243: LD_VAR 0 4
82247: PUSH
82248: LD_VAR 0 7
82252: ARRAY
82253: PPUSH
82254: CALL_OW 255
82258: PUSH
82259: EMPTY
82260: LIST
82261: LIST
82262: PPUSH
82263: CALL_OW 69
82267: ST_TO_ADDR
// if not tmp then
82268: LD_VAR 0 14
82272: NOT
82273: IFFALSE 82277
// continue ;
82275: GO 80776
// if f_ignore_area then
82277: LD_VAR 0 17
82281: IFFALSE 82369
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
82283: LD_ADDR_VAR 0 15
82287: PUSH
82288: LD_VAR 0 14
82292: PPUSH
82293: LD_INT 3
82295: PUSH
82296: LD_INT 92
82298: PUSH
82299: LD_VAR 0 17
82303: PUSH
82304: LD_INT 1
82306: ARRAY
82307: PUSH
82308: LD_VAR 0 17
82312: PUSH
82313: LD_INT 2
82315: ARRAY
82316: PUSH
82317: LD_VAR 0 17
82321: PUSH
82322: LD_INT 3
82324: ARRAY
82325: PUSH
82326: EMPTY
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: PUSH
82332: EMPTY
82333: LIST
82334: LIST
82335: PPUSH
82336: CALL_OW 72
82340: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82341: LD_VAR 0 14
82345: PUSH
82346: LD_VAR 0 15
82350: DIFF
82351: IFFALSE 82369
// tmp := tmp diff tmp2 ;
82353: LD_ADDR_VAR 0 14
82357: PUSH
82358: LD_VAR 0 14
82362: PUSH
82363: LD_VAR 0 15
82367: DIFF
82368: ST_TO_ADDR
// end ; if not f_murder then
82369: LD_VAR 0 20
82373: NOT
82374: IFFALSE 82432
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
82376: LD_ADDR_VAR 0 15
82380: PUSH
82381: LD_VAR 0 14
82385: PPUSH
82386: LD_INT 3
82388: PUSH
82389: LD_INT 50
82391: PUSH
82392: EMPTY
82393: LIST
82394: PUSH
82395: EMPTY
82396: LIST
82397: LIST
82398: PPUSH
82399: CALL_OW 72
82403: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
82404: LD_VAR 0 14
82408: PUSH
82409: LD_VAR 0 15
82413: DIFF
82414: IFFALSE 82432
// tmp := tmp diff tmp2 ;
82416: LD_ADDR_VAR 0 14
82420: PUSH
82421: LD_VAR 0 14
82425: PUSH
82426: LD_VAR 0 15
82430: DIFF
82431: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
82432: LD_ADDR_VAR 0 14
82436: PUSH
82437: LD_VAR 0 4
82441: PUSH
82442: LD_VAR 0 7
82446: ARRAY
82447: PPUSH
82448: LD_VAR 0 14
82452: PPUSH
82453: LD_INT 1
82455: PPUSH
82456: LD_INT 1
82458: PPUSH
82459: CALL 16139 0 4
82463: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
82464: LD_VAR 0 4
82468: PUSH
82469: LD_VAR 0 7
82473: ARRAY
82474: PPUSH
82475: CALL_OW 257
82479: PUSH
82480: LD_INT 1
82482: EQUAL
82483: IFFALSE 82931
// begin if WantPlant ( group [ i ] ) then
82485: LD_VAR 0 4
82489: PUSH
82490: LD_VAR 0 7
82494: ARRAY
82495: PPUSH
82496: CALL 15640 0 1
82500: IFFALSE 82504
// continue ;
82502: GO 80776
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
82504: LD_VAR 0 18
82508: PUSH
82509: LD_VAR 0 4
82513: PUSH
82514: LD_VAR 0 7
82518: ARRAY
82519: PPUSH
82520: CALL_OW 310
82524: NOT
82525: AND
82526: PUSH
82527: LD_VAR 0 14
82531: PUSH
82532: LD_INT 1
82534: ARRAY
82535: PUSH
82536: LD_VAR 0 14
82540: PPUSH
82541: LD_INT 21
82543: PUSH
82544: LD_INT 2
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 58
82553: PUSH
82554: EMPTY
82555: LIST
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PPUSH
82561: CALL_OW 72
82565: IN
82566: AND
82567: IFFALSE 82603
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
82569: LD_VAR 0 4
82573: PUSH
82574: LD_VAR 0 7
82578: ARRAY
82579: PPUSH
82580: LD_VAR 0 14
82584: PUSH
82585: LD_INT 1
82587: ARRAY
82588: PPUSH
82589: CALL_OW 120
// attacking := true ;
82593: LD_ADDR_VAR 0 29
82597: PUSH
82598: LD_INT 1
82600: ST_TO_ADDR
// continue ;
82601: GO 80776
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
82603: LD_VAR 0 26
82607: PUSH
82608: LD_VAR 0 4
82612: PUSH
82613: LD_VAR 0 7
82617: ARRAY
82618: PPUSH
82619: CALL_OW 257
82623: PUSH
82624: LD_INT 1
82626: EQUAL
82627: AND
82628: PUSH
82629: LD_VAR 0 4
82633: PUSH
82634: LD_VAR 0 7
82638: ARRAY
82639: PPUSH
82640: CALL_OW 256
82644: PUSH
82645: LD_INT 800
82647: LESS
82648: AND
82649: PUSH
82650: LD_VAR 0 4
82654: PUSH
82655: LD_VAR 0 7
82659: ARRAY
82660: PPUSH
82661: CALL_OW 318
82665: NOT
82666: AND
82667: IFFALSE 82684
// ComCrawl ( group [ i ] ) ;
82669: LD_VAR 0 4
82673: PUSH
82674: LD_VAR 0 7
82678: ARRAY
82679: PPUSH
82680: CALL_OW 137
// if f_mines then
82684: LD_VAR 0 21
82688: IFFALSE 82931
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
82690: LD_VAR 0 14
82694: PUSH
82695: LD_INT 1
82697: ARRAY
82698: PPUSH
82699: CALL_OW 247
82703: PUSH
82704: LD_INT 3
82706: EQUAL
82707: PUSH
82708: LD_VAR 0 14
82712: PUSH
82713: LD_INT 1
82715: ARRAY
82716: PUSH
82717: LD_VAR 0 27
82721: IN
82722: NOT
82723: AND
82724: IFFALSE 82931
// begin x := GetX ( tmp [ 1 ] ) ;
82726: LD_ADDR_VAR 0 10
82730: PUSH
82731: LD_VAR 0 14
82735: PUSH
82736: LD_INT 1
82738: ARRAY
82739: PPUSH
82740: CALL_OW 250
82744: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
82745: LD_ADDR_VAR 0 11
82749: PUSH
82750: LD_VAR 0 14
82754: PUSH
82755: LD_INT 1
82757: ARRAY
82758: PPUSH
82759: CALL_OW 251
82763: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
82764: LD_ADDR_VAR 0 12
82768: PUSH
82769: LD_VAR 0 4
82773: PUSH
82774: LD_VAR 0 7
82778: ARRAY
82779: PPUSH
82780: CALL 43289 0 1
82784: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
82785: LD_VAR 0 4
82789: PUSH
82790: LD_VAR 0 7
82794: ARRAY
82795: PPUSH
82796: LD_VAR 0 10
82800: PPUSH
82801: LD_VAR 0 11
82805: PPUSH
82806: LD_VAR 0 14
82810: PUSH
82811: LD_INT 1
82813: ARRAY
82814: PPUSH
82815: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
82819: LD_VAR 0 4
82823: PUSH
82824: LD_VAR 0 7
82828: ARRAY
82829: PPUSH
82830: LD_VAR 0 10
82834: PPUSH
82835: LD_VAR 0 12
82839: PPUSH
82840: LD_INT 7
82842: PPUSH
82843: CALL_OW 272
82847: PPUSH
82848: LD_VAR 0 11
82852: PPUSH
82853: LD_VAR 0 12
82857: PPUSH
82858: LD_INT 7
82860: PPUSH
82861: CALL_OW 273
82865: PPUSH
82866: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
82870: LD_VAR 0 4
82874: PUSH
82875: LD_VAR 0 7
82879: ARRAY
82880: PPUSH
82881: LD_INT 71
82883: PPUSH
82884: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
82888: LD_ADDR_VAR 0 27
82892: PUSH
82893: LD_VAR 0 27
82897: PPUSH
82898: LD_VAR 0 27
82902: PUSH
82903: LD_INT 1
82905: PLUS
82906: PPUSH
82907: LD_VAR 0 14
82911: PUSH
82912: LD_INT 1
82914: ARRAY
82915: PPUSH
82916: CALL_OW 1
82920: ST_TO_ADDR
// attacking := true ;
82921: LD_ADDR_VAR 0 29
82925: PUSH
82926: LD_INT 1
82928: ST_TO_ADDR
// continue ;
82929: GO 80776
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
82931: LD_VAR 0 4
82935: PUSH
82936: LD_VAR 0 7
82940: ARRAY
82941: PPUSH
82942: CALL_OW 257
82946: PUSH
82947: LD_INT 17
82949: EQUAL
82950: PUSH
82951: LD_VAR 0 4
82955: PUSH
82956: LD_VAR 0 7
82960: ARRAY
82961: PPUSH
82962: CALL_OW 110
82966: PUSH
82967: LD_INT 71
82969: EQUAL
82970: NOT
82971: AND
82972: IFFALSE 83118
// begin attacking := false ;
82974: LD_ADDR_VAR 0 29
82978: PUSH
82979: LD_INT 0
82981: ST_TO_ADDR
// k := 5 ;
82982: LD_ADDR_VAR 0 9
82986: PUSH
82987: LD_INT 5
82989: ST_TO_ADDR
// if tmp < k then
82990: LD_VAR 0 14
82994: PUSH
82995: LD_VAR 0 9
82999: LESS
83000: IFFALSE 83012
// k := tmp ;
83002: LD_ADDR_VAR 0 9
83006: PUSH
83007: LD_VAR 0 14
83011: ST_TO_ADDR
// for j = 1 to k do
83012: LD_ADDR_VAR 0 8
83016: PUSH
83017: DOUBLE
83018: LD_INT 1
83020: DEC
83021: ST_TO_ADDR
83022: LD_VAR 0 9
83026: PUSH
83027: FOR_TO
83028: IFFALSE 83116
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
83030: LD_VAR 0 14
83034: PUSH
83035: LD_VAR 0 8
83039: ARRAY
83040: PUSH
83041: LD_VAR 0 14
83045: PPUSH
83046: LD_INT 58
83048: PUSH
83049: EMPTY
83050: LIST
83051: PPUSH
83052: CALL_OW 72
83056: IN
83057: NOT
83058: IFFALSE 83114
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83060: LD_VAR 0 4
83064: PUSH
83065: LD_VAR 0 7
83069: ARRAY
83070: PPUSH
83071: LD_VAR 0 14
83075: PUSH
83076: LD_VAR 0 8
83080: ARRAY
83081: PPUSH
83082: CALL_OW 115
// attacking := true ;
83086: LD_ADDR_VAR 0 29
83090: PUSH
83091: LD_INT 1
83093: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
83094: LD_VAR 0 4
83098: PUSH
83099: LD_VAR 0 7
83103: ARRAY
83104: PPUSH
83105: LD_INT 71
83107: PPUSH
83108: CALL_OW 109
// continue ;
83112: GO 83027
// end ; end ;
83114: GO 83027
83116: POP
83117: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
83118: LD_VAR 0 4
83122: PUSH
83123: LD_VAR 0 7
83127: ARRAY
83128: PPUSH
83129: CALL_OW 257
83133: PUSH
83134: LD_INT 8
83136: EQUAL
83137: PUSH
83138: LD_VAR 0 4
83142: PUSH
83143: LD_VAR 0 7
83147: ARRAY
83148: PPUSH
83149: CALL_OW 264
83153: PUSH
83154: LD_INT 28
83156: PUSH
83157: LD_INT 45
83159: PUSH
83160: LD_INT 7
83162: PUSH
83163: LD_INT 47
83165: PUSH
83166: EMPTY
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: IN
83172: OR
83173: IFFALSE 83429
// begin attacking := false ;
83175: LD_ADDR_VAR 0 29
83179: PUSH
83180: LD_INT 0
83182: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
83183: LD_VAR 0 14
83187: PUSH
83188: LD_INT 1
83190: ARRAY
83191: PPUSH
83192: CALL_OW 266
83196: PUSH
83197: LD_INT 32
83199: PUSH
83200: LD_INT 31
83202: PUSH
83203: LD_INT 33
83205: PUSH
83206: LD_INT 4
83208: PUSH
83209: LD_INT 5
83211: PUSH
83212: EMPTY
83213: LIST
83214: LIST
83215: LIST
83216: LIST
83217: LIST
83218: IN
83219: IFFALSE 83405
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
83221: LD_ADDR_VAR 0 9
83225: PUSH
83226: LD_VAR 0 14
83230: PUSH
83231: LD_INT 1
83233: ARRAY
83234: PPUSH
83235: CALL_OW 266
83239: PPUSH
83240: LD_VAR 0 14
83244: PUSH
83245: LD_INT 1
83247: ARRAY
83248: PPUSH
83249: CALL_OW 250
83253: PPUSH
83254: LD_VAR 0 14
83258: PUSH
83259: LD_INT 1
83261: ARRAY
83262: PPUSH
83263: CALL_OW 251
83267: PPUSH
83268: LD_VAR 0 14
83272: PUSH
83273: LD_INT 1
83275: ARRAY
83276: PPUSH
83277: CALL_OW 254
83281: PPUSH
83282: LD_VAR 0 14
83286: PUSH
83287: LD_INT 1
83289: ARRAY
83290: PPUSH
83291: CALL_OW 248
83295: PPUSH
83296: LD_INT 0
83298: PPUSH
83299: CALL 24659 0 6
83303: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
83304: LD_ADDR_VAR 0 8
83308: PUSH
83309: LD_VAR 0 4
83313: PUSH
83314: LD_VAR 0 7
83318: ARRAY
83319: PPUSH
83320: LD_VAR 0 9
83324: PPUSH
83325: CALL 43329 0 2
83329: ST_TO_ADDR
// if j then
83330: LD_VAR 0 8
83334: IFFALSE 83403
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
83336: LD_VAR 0 8
83340: PUSH
83341: LD_INT 1
83343: ARRAY
83344: PPUSH
83345: LD_VAR 0 8
83349: PUSH
83350: LD_INT 2
83352: ARRAY
83353: PPUSH
83354: CALL_OW 488
83358: IFFALSE 83403
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
83360: LD_VAR 0 4
83364: PUSH
83365: LD_VAR 0 7
83369: ARRAY
83370: PPUSH
83371: LD_VAR 0 8
83375: PUSH
83376: LD_INT 1
83378: ARRAY
83379: PPUSH
83380: LD_VAR 0 8
83384: PUSH
83385: LD_INT 2
83387: ARRAY
83388: PPUSH
83389: CALL_OW 116
// attacking := true ;
83393: LD_ADDR_VAR 0 29
83397: PUSH
83398: LD_INT 1
83400: ST_TO_ADDR
// continue ;
83401: GO 80776
// end ; end else
83403: GO 83429
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83405: LD_VAR 0 4
83409: PUSH
83410: LD_VAR 0 7
83414: ARRAY
83415: PPUSH
83416: LD_VAR 0 14
83420: PUSH
83421: LD_INT 1
83423: ARRAY
83424: PPUSH
83425: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
83429: LD_VAR 0 4
83433: PUSH
83434: LD_VAR 0 7
83438: ARRAY
83439: PPUSH
83440: CALL_OW 265
83444: PUSH
83445: LD_INT 11
83447: EQUAL
83448: IFFALSE 83726
// begin k := 10 ;
83450: LD_ADDR_VAR 0 9
83454: PUSH
83455: LD_INT 10
83457: ST_TO_ADDR
// x := 0 ;
83458: LD_ADDR_VAR 0 10
83462: PUSH
83463: LD_INT 0
83465: ST_TO_ADDR
// if tmp < k then
83466: LD_VAR 0 14
83470: PUSH
83471: LD_VAR 0 9
83475: LESS
83476: IFFALSE 83488
// k := tmp ;
83478: LD_ADDR_VAR 0 9
83482: PUSH
83483: LD_VAR 0 14
83487: ST_TO_ADDR
// for j = k downto 1 do
83488: LD_ADDR_VAR 0 8
83492: PUSH
83493: DOUBLE
83494: LD_VAR 0 9
83498: INC
83499: ST_TO_ADDR
83500: LD_INT 1
83502: PUSH
83503: FOR_DOWNTO
83504: IFFALSE 83579
// begin if GetType ( tmp [ j ] ) = unit_human then
83506: LD_VAR 0 14
83510: PUSH
83511: LD_VAR 0 8
83515: ARRAY
83516: PPUSH
83517: CALL_OW 247
83521: PUSH
83522: LD_INT 1
83524: EQUAL
83525: IFFALSE 83577
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
83527: LD_VAR 0 4
83531: PUSH
83532: LD_VAR 0 7
83536: ARRAY
83537: PPUSH
83538: LD_VAR 0 14
83542: PUSH
83543: LD_VAR 0 8
83547: ARRAY
83548: PPUSH
83549: CALL 43600 0 2
// x := tmp [ j ] ;
83553: LD_ADDR_VAR 0 10
83557: PUSH
83558: LD_VAR 0 14
83562: PUSH
83563: LD_VAR 0 8
83567: ARRAY
83568: ST_TO_ADDR
// attacking := true ;
83569: LD_ADDR_VAR 0 29
83573: PUSH
83574: LD_INT 1
83576: ST_TO_ADDR
// end ; end ;
83577: GO 83503
83579: POP
83580: POP
// if not x then
83581: LD_VAR 0 10
83585: NOT
83586: IFFALSE 83726
// begin attacking := true ;
83588: LD_ADDR_VAR 0 29
83592: PUSH
83593: LD_INT 1
83595: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
83596: LD_VAR 0 4
83600: PUSH
83601: LD_VAR 0 7
83605: ARRAY
83606: PPUSH
83607: CALL_OW 250
83611: PPUSH
83612: LD_VAR 0 4
83616: PUSH
83617: LD_VAR 0 7
83621: ARRAY
83622: PPUSH
83623: CALL_OW 251
83627: PPUSH
83628: CALL_OW 546
83632: PUSH
83633: LD_INT 2
83635: ARRAY
83636: PUSH
83637: LD_VAR 0 14
83641: PUSH
83642: LD_INT 1
83644: ARRAY
83645: PPUSH
83646: CALL_OW 250
83650: PPUSH
83651: LD_VAR 0 14
83655: PUSH
83656: LD_INT 1
83658: ARRAY
83659: PPUSH
83660: CALL_OW 251
83664: PPUSH
83665: CALL_OW 546
83669: PUSH
83670: LD_INT 2
83672: ARRAY
83673: EQUAL
83674: IFFALSE 83702
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
83676: LD_VAR 0 4
83680: PUSH
83681: LD_VAR 0 7
83685: ARRAY
83686: PPUSH
83687: LD_VAR 0 14
83691: PUSH
83692: LD_INT 1
83694: ARRAY
83695: PPUSH
83696: CALL 43600 0 2
83700: GO 83726
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
83702: LD_VAR 0 4
83706: PUSH
83707: LD_VAR 0 7
83711: ARRAY
83712: PPUSH
83713: LD_VAR 0 14
83717: PUSH
83718: LD_INT 1
83720: ARRAY
83721: PPUSH
83722: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
83726: LD_VAR 0 4
83730: PUSH
83731: LD_VAR 0 7
83735: ARRAY
83736: PPUSH
83737: CALL_OW 264
83741: PUSH
83742: LD_INT 29
83744: EQUAL
83745: IFFALSE 84111
// begin if WantsToAttack ( group [ i ] ) in bombed then
83747: LD_VAR 0 4
83751: PUSH
83752: LD_VAR 0 7
83756: ARRAY
83757: PPUSH
83758: CALL_OW 319
83762: PUSH
83763: LD_VAR 0 28
83767: IN
83768: IFFALSE 83772
// continue ;
83770: GO 80776
// k := 8 ;
83772: LD_ADDR_VAR 0 9
83776: PUSH
83777: LD_INT 8
83779: ST_TO_ADDR
// x := 0 ;
83780: LD_ADDR_VAR 0 10
83784: PUSH
83785: LD_INT 0
83787: ST_TO_ADDR
// if tmp < k then
83788: LD_VAR 0 14
83792: PUSH
83793: LD_VAR 0 9
83797: LESS
83798: IFFALSE 83810
// k := tmp ;
83800: LD_ADDR_VAR 0 9
83804: PUSH
83805: LD_VAR 0 14
83809: ST_TO_ADDR
// for j = 1 to k do
83810: LD_ADDR_VAR 0 8
83814: PUSH
83815: DOUBLE
83816: LD_INT 1
83818: DEC
83819: ST_TO_ADDR
83820: LD_VAR 0 9
83824: PUSH
83825: FOR_TO
83826: IFFALSE 83958
// begin if GetType ( tmp [ j ] ) = unit_building then
83828: LD_VAR 0 14
83832: PUSH
83833: LD_VAR 0 8
83837: ARRAY
83838: PPUSH
83839: CALL_OW 247
83843: PUSH
83844: LD_INT 3
83846: EQUAL
83847: IFFALSE 83956
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
83849: LD_VAR 0 14
83853: PUSH
83854: LD_VAR 0 8
83858: ARRAY
83859: PUSH
83860: LD_VAR 0 28
83864: IN
83865: NOT
83866: PUSH
83867: LD_VAR 0 14
83871: PUSH
83872: LD_VAR 0 8
83876: ARRAY
83877: PPUSH
83878: CALL_OW 313
83882: AND
83883: IFFALSE 83956
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
83885: LD_VAR 0 4
83889: PUSH
83890: LD_VAR 0 7
83894: ARRAY
83895: PPUSH
83896: LD_VAR 0 14
83900: PUSH
83901: LD_VAR 0 8
83905: ARRAY
83906: PPUSH
83907: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
83911: LD_ADDR_VAR 0 28
83915: PUSH
83916: LD_VAR 0 28
83920: PPUSH
83921: LD_VAR 0 28
83925: PUSH
83926: LD_INT 1
83928: PLUS
83929: PPUSH
83930: LD_VAR 0 14
83934: PUSH
83935: LD_VAR 0 8
83939: ARRAY
83940: PPUSH
83941: CALL_OW 1
83945: ST_TO_ADDR
// attacking := true ;
83946: LD_ADDR_VAR 0 29
83950: PUSH
83951: LD_INT 1
83953: ST_TO_ADDR
// break ;
83954: GO 83958
// end ; end ;
83956: GO 83825
83958: POP
83959: POP
// if not attacking and f_attack_depot then
83960: LD_VAR 0 29
83964: NOT
83965: PUSH
83966: LD_VAR 0 25
83970: AND
83971: IFFALSE 84066
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83973: LD_ADDR_VAR 0 13
83977: PUSH
83978: LD_VAR 0 14
83982: PPUSH
83983: LD_INT 2
83985: PUSH
83986: LD_INT 30
83988: PUSH
83989: LD_INT 0
83991: PUSH
83992: EMPTY
83993: LIST
83994: LIST
83995: PUSH
83996: LD_INT 30
83998: PUSH
83999: LD_INT 1
84001: PUSH
84002: EMPTY
84003: LIST
84004: LIST
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: LIST
84010: PPUSH
84011: CALL_OW 72
84015: ST_TO_ADDR
// if z then
84016: LD_VAR 0 13
84020: IFFALSE 84066
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
84022: LD_VAR 0 4
84026: PUSH
84027: LD_VAR 0 7
84031: ARRAY
84032: PPUSH
84033: LD_VAR 0 13
84037: PPUSH
84038: LD_VAR 0 4
84042: PUSH
84043: LD_VAR 0 7
84047: ARRAY
84048: PPUSH
84049: CALL_OW 74
84053: PPUSH
84054: CALL_OW 115
// attacking := true ;
84058: LD_ADDR_VAR 0 29
84062: PUSH
84063: LD_INT 1
84065: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
84066: LD_VAR 0 4
84070: PUSH
84071: LD_VAR 0 7
84075: ARRAY
84076: PPUSH
84077: CALL_OW 256
84081: PUSH
84082: LD_INT 500
84084: LESS
84085: IFFALSE 84111
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84087: LD_VAR 0 4
84091: PUSH
84092: LD_VAR 0 7
84096: ARRAY
84097: PPUSH
84098: LD_VAR 0 14
84102: PUSH
84103: LD_INT 1
84105: ARRAY
84106: PPUSH
84107: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
84111: LD_VAR 0 4
84115: PUSH
84116: LD_VAR 0 7
84120: ARRAY
84121: PPUSH
84122: CALL_OW 264
84126: PUSH
84127: LD_INT 49
84129: EQUAL
84130: IFFALSE 84251
// begin if not HasTask ( group [ i ] ) then
84132: LD_VAR 0 4
84136: PUSH
84137: LD_VAR 0 7
84141: ARRAY
84142: PPUSH
84143: CALL_OW 314
84147: NOT
84148: IFFALSE 84251
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
84150: LD_ADDR_VAR 0 9
84154: PUSH
84155: LD_INT 81
84157: PUSH
84158: LD_VAR 0 4
84162: PUSH
84163: LD_VAR 0 7
84167: ARRAY
84168: PPUSH
84169: CALL_OW 255
84173: PUSH
84174: EMPTY
84175: LIST
84176: LIST
84177: PPUSH
84178: CALL_OW 69
84182: PPUSH
84183: LD_VAR 0 4
84187: PUSH
84188: LD_VAR 0 7
84192: ARRAY
84193: PPUSH
84194: CALL_OW 74
84198: ST_TO_ADDR
// if k then
84199: LD_VAR 0 9
84203: IFFALSE 84251
// if GetDistUnits ( group [ i ] , k ) > 10 then
84205: LD_VAR 0 4
84209: PUSH
84210: LD_VAR 0 7
84214: ARRAY
84215: PPUSH
84216: LD_VAR 0 9
84220: PPUSH
84221: CALL_OW 296
84225: PUSH
84226: LD_INT 10
84228: GREATER
84229: IFFALSE 84251
// ComMoveUnit ( group [ i ] , k ) ;
84231: LD_VAR 0 4
84235: PUSH
84236: LD_VAR 0 7
84240: ARRAY
84241: PPUSH
84242: LD_VAR 0 9
84246: PPUSH
84247: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
84251: LD_VAR 0 4
84255: PUSH
84256: LD_VAR 0 7
84260: ARRAY
84261: PPUSH
84262: CALL_OW 256
84266: PUSH
84267: LD_INT 250
84269: LESS
84270: PUSH
84271: LD_VAR 0 4
84275: PUSH
84276: LD_VAR 0 7
84280: ARRAY
84281: PUSH
84282: LD_INT 21
84284: PUSH
84285: LD_INT 2
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 23
84294: PUSH
84295: LD_INT 2
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PPUSH
84306: CALL_OW 69
84310: IN
84311: AND
84312: IFFALSE 84437
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
84314: LD_ADDR_VAR 0 9
84318: PUSH
84319: LD_OWVAR 3
84323: PUSH
84324: LD_VAR 0 4
84328: PUSH
84329: LD_VAR 0 7
84333: ARRAY
84334: DIFF
84335: PPUSH
84336: LD_VAR 0 4
84340: PUSH
84341: LD_VAR 0 7
84345: ARRAY
84346: PPUSH
84347: CALL_OW 74
84351: ST_TO_ADDR
// if not k then
84352: LD_VAR 0 9
84356: NOT
84357: IFFALSE 84361
// continue ;
84359: GO 80776
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
84361: LD_VAR 0 9
84365: PUSH
84366: LD_INT 81
84368: PUSH
84369: LD_VAR 0 4
84373: PUSH
84374: LD_VAR 0 7
84378: ARRAY
84379: PPUSH
84380: CALL_OW 255
84384: PUSH
84385: EMPTY
84386: LIST
84387: LIST
84388: PPUSH
84389: CALL_OW 69
84393: IN
84394: PUSH
84395: LD_VAR 0 9
84399: PPUSH
84400: LD_VAR 0 4
84404: PUSH
84405: LD_VAR 0 7
84409: ARRAY
84410: PPUSH
84411: CALL_OW 296
84415: PUSH
84416: LD_INT 5
84418: LESS
84419: AND
84420: IFFALSE 84437
// ComAutodestruct ( group [ i ] ) ;
84422: LD_VAR 0 4
84426: PUSH
84427: LD_VAR 0 7
84431: ARRAY
84432: PPUSH
84433: CALL 43498 0 1
// end ; if f_attack_depot then
84437: LD_VAR 0 25
84441: IFFALSE 84553
// begin k := 6 ;
84443: LD_ADDR_VAR 0 9
84447: PUSH
84448: LD_INT 6
84450: ST_TO_ADDR
// if tmp < k then
84451: LD_VAR 0 14
84455: PUSH
84456: LD_VAR 0 9
84460: LESS
84461: IFFALSE 84473
// k := tmp ;
84463: LD_ADDR_VAR 0 9
84467: PUSH
84468: LD_VAR 0 14
84472: ST_TO_ADDR
// for j = 1 to k do
84473: LD_ADDR_VAR 0 8
84477: PUSH
84478: DOUBLE
84479: LD_INT 1
84481: DEC
84482: ST_TO_ADDR
84483: LD_VAR 0 9
84487: PUSH
84488: FOR_TO
84489: IFFALSE 84551
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
84491: LD_VAR 0 8
84495: PPUSH
84496: CALL_OW 266
84500: PUSH
84501: LD_INT 0
84503: PUSH
84504: LD_INT 1
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: IN
84511: IFFALSE 84549
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84513: LD_VAR 0 4
84517: PUSH
84518: LD_VAR 0 7
84522: ARRAY
84523: PPUSH
84524: LD_VAR 0 14
84528: PUSH
84529: LD_VAR 0 8
84533: ARRAY
84534: PPUSH
84535: CALL_OW 115
// attacking := true ;
84539: LD_ADDR_VAR 0 29
84543: PUSH
84544: LD_INT 1
84546: ST_TO_ADDR
// break ;
84547: GO 84551
// end ;
84549: GO 84488
84551: POP
84552: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
84553: LD_VAR 0 4
84557: PUSH
84558: LD_VAR 0 7
84562: ARRAY
84563: PPUSH
84564: CALL_OW 302
84568: PUSH
84569: LD_VAR 0 29
84573: NOT
84574: AND
84575: IFFALSE 84897
// begin if GetTag ( group [ i ] ) = 71 then
84577: LD_VAR 0 4
84581: PUSH
84582: LD_VAR 0 7
84586: ARRAY
84587: PPUSH
84588: CALL_OW 110
84592: PUSH
84593: LD_INT 71
84595: EQUAL
84596: IFFALSE 84637
// begin if HasTask ( group [ i ] ) then
84598: LD_VAR 0 4
84602: PUSH
84603: LD_VAR 0 7
84607: ARRAY
84608: PPUSH
84609: CALL_OW 314
84613: IFFALSE 84619
// continue else
84615: GO 80776
84617: GO 84637
// SetTag ( group [ i ] , 0 ) ;
84619: LD_VAR 0 4
84623: PUSH
84624: LD_VAR 0 7
84628: ARRAY
84629: PPUSH
84630: LD_INT 0
84632: PPUSH
84633: CALL_OW 109
// end ; k := 8 ;
84637: LD_ADDR_VAR 0 9
84641: PUSH
84642: LD_INT 8
84644: ST_TO_ADDR
// x := 0 ;
84645: LD_ADDR_VAR 0 10
84649: PUSH
84650: LD_INT 0
84652: ST_TO_ADDR
// if tmp < k then
84653: LD_VAR 0 14
84657: PUSH
84658: LD_VAR 0 9
84662: LESS
84663: IFFALSE 84675
// k := tmp ;
84665: LD_ADDR_VAR 0 9
84669: PUSH
84670: LD_VAR 0 14
84674: ST_TO_ADDR
// for j = 1 to k do
84675: LD_ADDR_VAR 0 8
84679: PUSH
84680: DOUBLE
84681: LD_INT 1
84683: DEC
84684: ST_TO_ADDR
84685: LD_VAR 0 9
84689: PUSH
84690: FOR_TO
84691: IFFALSE 84789
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
84693: LD_VAR 0 14
84697: PUSH
84698: LD_VAR 0 8
84702: ARRAY
84703: PPUSH
84704: CALL_OW 247
84708: PUSH
84709: LD_INT 1
84711: EQUAL
84712: PUSH
84713: LD_VAR 0 14
84717: PUSH
84718: LD_VAR 0 8
84722: ARRAY
84723: PPUSH
84724: CALL_OW 256
84728: PUSH
84729: LD_INT 250
84731: LESS
84732: PUSH
84733: LD_VAR 0 20
84737: AND
84738: PUSH
84739: LD_VAR 0 20
84743: NOT
84744: PUSH
84745: LD_VAR 0 14
84749: PUSH
84750: LD_VAR 0 8
84754: ARRAY
84755: PPUSH
84756: CALL_OW 256
84760: PUSH
84761: LD_INT 250
84763: GREATEREQUAL
84764: AND
84765: OR
84766: AND
84767: IFFALSE 84787
// begin x := tmp [ j ] ;
84769: LD_ADDR_VAR 0 10
84773: PUSH
84774: LD_VAR 0 14
84778: PUSH
84779: LD_VAR 0 8
84783: ARRAY
84784: ST_TO_ADDR
// break ;
84785: GO 84789
// end ;
84787: GO 84690
84789: POP
84790: POP
// if x then
84791: LD_VAR 0 10
84795: IFFALSE 84819
// ComAttackUnit ( group [ i ] , x ) else
84797: LD_VAR 0 4
84801: PUSH
84802: LD_VAR 0 7
84806: ARRAY
84807: PPUSH
84808: LD_VAR 0 10
84812: PPUSH
84813: CALL_OW 115
84817: GO 84843
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84819: LD_VAR 0 4
84823: PUSH
84824: LD_VAR 0 7
84828: ARRAY
84829: PPUSH
84830: LD_VAR 0 14
84834: PUSH
84835: LD_INT 1
84837: ARRAY
84838: PPUSH
84839: CALL_OW 115
// if not HasTask ( group [ i ] ) then
84843: LD_VAR 0 4
84847: PUSH
84848: LD_VAR 0 7
84852: ARRAY
84853: PPUSH
84854: CALL_OW 314
84858: NOT
84859: IFFALSE 84897
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
84861: LD_VAR 0 4
84865: PUSH
84866: LD_VAR 0 7
84870: ARRAY
84871: PPUSH
84872: LD_VAR 0 14
84876: PPUSH
84877: LD_VAR 0 4
84881: PUSH
84882: LD_VAR 0 7
84886: ARRAY
84887: PPUSH
84888: CALL_OW 74
84892: PPUSH
84893: CALL_OW 115
// end ; end ; end ;
84897: GO 80776
84899: POP
84900: POP
// wait ( 0 0$2 ) ;
84901: LD_INT 70
84903: PPUSH
84904: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
84908: LD_VAR 0 4
84912: NOT
84913: PUSH
84914: LD_VAR 0 4
84918: PUSH
84919: EMPTY
84920: EQUAL
84921: OR
84922: PUSH
84923: LD_INT 81
84925: PUSH
84926: LD_VAR 0 35
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PPUSH
84935: CALL_OW 69
84939: NOT
84940: OR
84941: IFFALSE 80761
// end ;
84943: LD_VAR 0 2
84947: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
84948: LD_INT 0
84950: PPUSH
84951: PPUSH
84952: PPUSH
84953: PPUSH
84954: PPUSH
// if not base or not mc_bases [ base ] or not solds then
84955: LD_VAR 0 1
84959: NOT
84960: PUSH
84961: LD_EXP 23
84965: PUSH
84966: LD_VAR 0 1
84970: ARRAY
84971: NOT
84972: OR
84973: PUSH
84974: LD_VAR 0 2
84978: NOT
84979: OR
84980: IFFALSE 84984
// exit ;
84982: GO 85513
// side := mc_sides [ base ] ;
84984: LD_ADDR_VAR 0 5
84988: PUSH
84989: LD_EXP 49
84993: PUSH
84994: LD_VAR 0 1
84998: ARRAY
84999: ST_TO_ADDR
// if not side then
85000: LD_VAR 0 5
85004: NOT
85005: IFFALSE 85009
// exit ;
85007: GO 85513
// for i in solds do
85009: LD_ADDR_VAR 0 6
85013: PUSH
85014: LD_VAR 0 2
85018: PUSH
85019: FOR_IN
85020: IFFALSE 85081
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
85022: LD_VAR 0 6
85026: PPUSH
85027: CALL_OW 310
85031: PPUSH
85032: CALL_OW 266
85036: PUSH
85037: LD_INT 32
85039: PUSH
85040: LD_INT 31
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: IN
85047: IFFALSE 85067
// solds := solds diff i else
85049: LD_ADDR_VAR 0 2
85053: PUSH
85054: LD_VAR 0 2
85058: PUSH
85059: LD_VAR 0 6
85063: DIFF
85064: ST_TO_ADDR
85065: GO 85079
// SetTag ( i , 18 ) ;
85067: LD_VAR 0 6
85071: PPUSH
85072: LD_INT 18
85074: PPUSH
85075: CALL_OW 109
85079: GO 85019
85081: POP
85082: POP
// if not solds then
85083: LD_VAR 0 2
85087: NOT
85088: IFFALSE 85092
// exit ;
85090: GO 85513
// repeat wait ( 0 0$2 ) ;
85092: LD_INT 70
85094: PPUSH
85095: CALL_OW 67
// enemy := mc_scan [ base ] ;
85099: LD_ADDR_VAR 0 4
85103: PUSH
85104: LD_EXP 46
85108: PUSH
85109: LD_VAR 0 1
85113: ARRAY
85114: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85115: LD_EXP 23
85119: PUSH
85120: LD_VAR 0 1
85124: ARRAY
85125: NOT
85126: PUSH
85127: LD_EXP 23
85131: PUSH
85132: LD_VAR 0 1
85136: ARRAY
85137: PUSH
85138: EMPTY
85139: EQUAL
85140: OR
85141: IFFALSE 85178
// begin for i in solds do
85143: LD_ADDR_VAR 0 6
85147: PUSH
85148: LD_VAR 0 2
85152: PUSH
85153: FOR_IN
85154: IFFALSE 85167
// ComStop ( i ) ;
85156: LD_VAR 0 6
85160: PPUSH
85161: CALL_OW 141
85165: GO 85153
85167: POP
85168: POP
// solds := [ ] ;
85169: LD_ADDR_VAR 0 2
85173: PUSH
85174: EMPTY
85175: ST_TO_ADDR
// exit ;
85176: GO 85513
// end ; for i in solds do
85178: LD_ADDR_VAR 0 6
85182: PUSH
85183: LD_VAR 0 2
85187: PUSH
85188: FOR_IN
85189: IFFALSE 85485
// begin if IsInUnit ( i ) then
85191: LD_VAR 0 6
85195: PPUSH
85196: CALL_OW 310
85200: IFFALSE 85211
// ComExitBuilding ( i ) ;
85202: LD_VAR 0 6
85206: PPUSH
85207: CALL_OW 122
// if GetLives ( i ) > 333 then
85211: LD_VAR 0 6
85215: PPUSH
85216: CALL_OW 256
85220: PUSH
85221: LD_INT 333
85223: GREATER
85224: IFFALSE 85252
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
85226: LD_VAR 0 6
85230: PPUSH
85231: LD_VAR 0 4
85235: PPUSH
85236: LD_VAR 0 6
85240: PPUSH
85241: CALL_OW 74
85245: PPUSH
85246: CALL_OW 115
85250: GO 85483
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
85252: LD_VAR 0 6
85256: PPUSH
85257: LD_EXP 23
85261: PUSH
85262: LD_VAR 0 1
85266: ARRAY
85267: PPUSH
85268: LD_INT 2
85270: PUSH
85271: LD_INT 30
85273: PUSH
85274: LD_INT 0
85276: PUSH
85277: EMPTY
85278: LIST
85279: LIST
85280: PUSH
85281: LD_INT 30
85283: PUSH
85284: LD_INT 1
85286: PUSH
85287: EMPTY
85288: LIST
85289: LIST
85290: PUSH
85291: LD_INT 30
85293: PUSH
85294: LD_INT 6
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: EMPTY
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: PPUSH
85307: CALL_OW 72
85311: PPUSH
85312: LD_VAR 0 6
85316: PPUSH
85317: CALL_OW 74
85321: PPUSH
85322: CALL_OW 296
85326: PUSH
85327: LD_INT 10
85329: GREATER
85330: IFFALSE 85483
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
85332: LD_ADDR_VAR 0 7
85336: PUSH
85337: LD_EXP 23
85341: PUSH
85342: LD_VAR 0 1
85346: ARRAY
85347: PPUSH
85348: LD_INT 2
85350: PUSH
85351: LD_INT 30
85353: PUSH
85354: LD_INT 0
85356: PUSH
85357: EMPTY
85358: LIST
85359: LIST
85360: PUSH
85361: LD_INT 30
85363: PUSH
85364: LD_INT 1
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: PUSH
85371: LD_INT 30
85373: PUSH
85374: LD_INT 6
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: LIST
85385: LIST
85386: PPUSH
85387: CALL_OW 72
85391: PPUSH
85392: LD_VAR 0 6
85396: PPUSH
85397: CALL_OW 74
85401: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
85402: LD_VAR 0 6
85406: PPUSH
85407: LD_VAR 0 7
85411: PPUSH
85412: CALL_OW 250
85416: PPUSH
85417: LD_INT 3
85419: PPUSH
85420: LD_INT 5
85422: PPUSH
85423: CALL_OW 272
85427: PPUSH
85428: LD_VAR 0 7
85432: PPUSH
85433: CALL_OW 251
85437: PPUSH
85438: LD_INT 3
85440: PPUSH
85441: LD_INT 5
85443: PPUSH
85444: CALL_OW 273
85448: PPUSH
85449: CALL_OW 111
// SetTag ( i , 0 ) ;
85453: LD_VAR 0 6
85457: PPUSH
85458: LD_INT 0
85460: PPUSH
85461: CALL_OW 109
// solds := solds diff i ;
85465: LD_ADDR_VAR 0 2
85469: PUSH
85470: LD_VAR 0 2
85474: PUSH
85475: LD_VAR 0 6
85479: DIFF
85480: ST_TO_ADDR
// continue ;
85481: GO 85188
// end ; end ;
85483: GO 85188
85485: POP
85486: POP
// until not solds or not enemy ;
85487: LD_VAR 0 2
85491: NOT
85492: PUSH
85493: LD_VAR 0 4
85497: NOT
85498: OR
85499: IFFALSE 85092
// MC_Reset ( base , 18 ) ;
85501: LD_VAR 0 1
85505: PPUSH
85506: LD_INT 18
85508: PPUSH
85509: CALL 53746 0 2
// end ;
85513: LD_VAR 0 3
85517: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
85518: LD_INT 0
85520: PPUSH
85521: PPUSH
85522: PPUSH
85523: PPUSH
85524: PPUSH
85525: PPUSH
85526: PPUSH
85527: PPUSH
85528: PPUSH
85529: PPUSH
85530: PPUSH
85531: PPUSH
85532: PPUSH
85533: PPUSH
85534: PPUSH
85535: PPUSH
85536: PPUSH
85537: PPUSH
85538: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
85539: LD_ADDR_VAR 0 12
85543: PUSH
85544: LD_EXP 23
85548: PUSH
85549: LD_VAR 0 1
85553: ARRAY
85554: PPUSH
85555: LD_INT 25
85557: PUSH
85558: LD_INT 3
85560: PUSH
85561: EMPTY
85562: LIST
85563: LIST
85564: PPUSH
85565: CALL_OW 72
85569: ST_TO_ADDR
// if mc_remote_driver [ base ] then
85570: LD_EXP 63
85574: PUSH
85575: LD_VAR 0 1
85579: ARRAY
85580: IFFALSE 85604
// mechs := mechs diff mc_remote_driver [ base ] ;
85582: LD_ADDR_VAR 0 12
85586: PUSH
85587: LD_VAR 0 12
85591: PUSH
85592: LD_EXP 63
85596: PUSH
85597: LD_VAR 0 1
85601: ARRAY
85602: DIFF
85603: ST_TO_ADDR
// for i in mechs do
85604: LD_ADDR_VAR 0 4
85608: PUSH
85609: LD_VAR 0 12
85613: PUSH
85614: FOR_IN
85615: IFFALSE 85650
// if GetTag ( i ) > 0 then
85617: LD_VAR 0 4
85621: PPUSH
85622: CALL_OW 110
85626: PUSH
85627: LD_INT 0
85629: GREATER
85630: IFFALSE 85648
// mechs := mechs diff i ;
85632: LD_ADDR_VAR 0 12
85636: PUSH
85637: LD_VAR 0 12
85641: PUSH
85642: LD_VAR 0 4
85646: DIFF
85647: ST_TO_ADDR
85648: GO 85614
85650: POP
85651: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
85652: LD_ADDR_VAR 0 8
85656: PUSH
85657: LD_EXP 23
85661: PUSH
85662: LD_VAR 0 1
85666: ARRAY
85667: PPUSH
85668: LD_INT 2
85670: PUSH
85671: LD_INT 25
85673: PUSH
85674: LD_INT 1
85676: PUSH
85677: EMPTY
85678: LIST
85679: LIST
85680: PUSH
85681: LD_INT 25
85683: PUSH
85684: LD_INT 5
85686: PUSH
85687: EMPTY
85688: LIST
85689: LIST
85690: PUSH
85691: LD_INT 25
85693: PUSH
85694: LD_INT 8
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PUSH
85701: LD_INT 25
85703: PUSH
85704: LD_INT 9
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: PUSH
85711: EMPTY
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: PPUSH
85718: CALL_OW 72
85722: ST_TO_ADDR
// if not defenders and not solds then
85723: LD_VAR 0 2
85727: NOT
85728: PUSH
85729: LD_VAR 0 8
85733: NOT
85734: AND
85735: IFFALSE 85739
// exit ;
85737: GO 87509
// depot_under_attack := false ;
85739: LD_ADDR_VAR 0 16
85743: PUSH
85744: LD_INT 0
85746: ST_TO_ADDR
// sold_defenders := [ ] ;
85747: LD_ADDR_VAR 0 17
85751: PUSH
85752: EMPTY
85753: ST_TO_ADDR
// if mechs then
85754: LD_VAR 0 12
85758: IFFALSE 85911
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
85760: LD_ADDR_VAR 0 4
85764: PUSH
85765: LD_VAR 0 2
85769: PPUSH
85770: LD_INT 21
85772: PUSH
85773: LD_INT 2
85775: PUSH
85776: EMPTY
85777: LIST
85778: LIST
85779: PPUSH
85780: CALL_OW 72
85784: PUSH
85785: FOR_IN
85786: IFFALSE 85909
// begin if GetTag ( i ) <> 20 then
85788: LD_VAR 0 4
85792: PPUSH
85793: CALL_OW 110
85797: PUSH
85798: LD_INT 20
85800: NONEQUAL
85801: IFFALSE 85815
// SetTag ( i , 20 ) ;
85803: LD_VAR 0 4
85807: PPUSH
85808: LD_INT 20
85810: PPUSH
85811: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
85815: LD_VAR 0 4
85819: PPUSH
85820: CALL_OW 263
85824: PUSH
85825: LD_INT 1
85827: EQUAL
85828: PUSH
85829: LD_VAR 0 4
85833: PPUSH
85834: CALL_OW 311
85838: NOT
85839: AND
85840: IFFALSE 85907
// begin un := mechs [ 1 ] ;
85842: LD_ADDR_VAR 0 10
85846: PUSH
85847: LD_VAR 0 12
85851: PUSH
85852: LD_INT 1
85854: ARRAY
85855: ST_TO_ADDR
// ComExit ( un ) ;
85856: LD_VAR 0 10
85860: PPUSH
85861: CALL 47843 0 1
// AddComEnterUnit ( un , i ) ;
85865: LD_VAR 0 10
85869: PPUSH
85870: LD_VAR 0 4
85874: PPUSH
85875: CALL_OW 180
// SetTag ( un , 19 ) ;
85879: LD_VAR 0 10
85883: PPUSH
85884: LD_INT 19
85886: PPUSH
85887: CALL_OW 109
// mechs := mechs diff un ;
85891: LD_ADDR_VAR 0 12
85895: PUSH
85896: LD_VAR 0 12
85900: PUSH
85901: LD_VAR 0 10
85905: DIFF
85906: ST_TO_ADDR
// end ; end ;
85907: GO 85785
85909: POP
85910: POP
// if solds then
85911: LD_VAR 0 8
85915: IFFALSE 85974
// for i in solds do
85917: LD_ADDR_VAR 0 4
85921: PUSH
85922: LD_VAR 0 8
85926: PUSH
85927: FOR_IN
85928: IFFALSE 85972
// if not GetTag ( i ) then
85930: LD_VAR 0 4
85934: PPUSH
85935: CALL_OW 110
85939: NOT
85940: IFFALSE 85970
// begin defenders := defenders union i ;
85942: LD_ADDR_VAR 0 2
85946: PUSH
85947: LD_VAR 0 2
85951: PUSH
85952: LD_VAR 0 4
85956: UNION
85957: ST_TO_ADDR
// SetTag ( i , 18 ) ;
85958: LD_VAR 0 4
85962: PPUSH
85963: LD_INT 18
85965: PPUSH
85966: CALL_OW 109
// end ;
85970: GO 85927
85972: POP
85973: POP
// repeat wait ( 0 0$2 ) ;
85974: LD_INT 70
85976: PPUSH
85977: CALL_OW 67
// enemy := mc_scan [ base ] ;
85981: LD_ADDR_VAR 0 21
85985: PUSH
85986: LD_EXP 46
85990: PUSH
85991: LD_VAR 0 1
85995: ARRAY
85996: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85997: LD_EXP 23
86001: PUSH
86002: LD_VAR 0 1
86006: ARRAY
86007: NOT
86008: PUSH
86009: LD_EXP 23
86013: PUSH
86014: LD_VAR 0 1
86018: ARRAY
86019: PUSH
86020: EMPTY
86021: EQUAL
86022: OR
86023: IFFALSE 86060
// begin for i in defenders do
86025: LD_ADDR_VAR 0 4
86029: PUSH
86030: LD_VAR 0 2
86034: PUSH
86035: FOR_IN
86036: IFFALSE 86049
// ComStop ( i ) ;
86038: LD_VAR 0 4
86042: PPUSH
86043: CALL_OW 141
86047: GO 86035
86049: POP
86050: POP
// defenders := [ ] ;
86051: LD_ADDR_VAR 0 2
86055: PUSH
86056: EMPTY
86057: ST_TO_ADDR
// exit ;
86058: GO 87509
// end ; for i in defenders do
86060: LD_ADDR_VAR 0 4
86064: PUSH
86065: LD_VAR 0 2
86069: PUSH
86070: FOR_IN
86071: IFFALSE 86969
// begin e := NearestUnitToUnit ( enemy , i ) ;
86073: LD_ADDR_VAR 0 13
86077: PUSH
86078: LD_VAR 0 21
86082: PPUSH
86083: LD_VAR 0 4
86087: PPUSH
86088: CALL_OW 74
86092: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86093: LD_ADDR_VAR 0 7
86097: PUSH
86098: LD_EXP 23
86102: PUSH
86103: LD_VAR 0 1
86107: ARRAY
86108: PPUSH
86109: LD_INT 2
86111: PUSH
86112: LD_INT 30
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 30
86124: PUSH
86125: LD_INT 1
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: LIST
86136: PPUSH
86137: CALL_OW 72
86141: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
86142: LD_ADDR_VAR 0 16
86146: PUSH
86147: LD_VAR 0 7
86151: NOT
86152: PUSH
86153: LD_VAR 0 7
86157: PPUSH
86158: LD_INT 3
86160: PUSH
86161: LD_INT 24
86163: PUSH
86164: LD_INT 600
86166: PUSH
86167: EMPTY
86168: LIST
86169: LIST
86170: PUSH
86171: EMPTY
86172: LIST
86173: LIST
86174: PPUSH
86175: CALL_OW 72
86179: OR
86180: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
86181: LD_VAR 0 4
86185: PPUSH
86186: CALL_OW 247
86190: PUSH
86191: LD_INT 2
86193: DOUBLE
86194: EQUAL
86195: IFTRUE 86199
86197: GO 86595
86199: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
86200: LD_VAR 0 4
86204: PPUSH
86205: CALL_OW 256
86209: PUSH
86210: LD_INT 1000
86212: EQUAL
86213: PUSH
86214: LD_VAR 0 4
86218: PPUSH
86219: LD_VAR 0 13
86223: PPUSH
86224: CALL_OW 296
86228: PUSH
86229: LD_INT 40
86231: LESS
86232: PUSH
86233: LD_VAR 0 13
86237: PPUSH
86238: LD_EXP 48
86242: PUSH
86243: LD_VAR 0 1
86247: ARRAY
86248: PPUSH
86249: CALL_OW 308
86253: OR
86254: AND
86255: IFFALSE 86377
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
86257: LD_VAR 0 4
86261: PPUSH
86262: CALL_OW 262
86266: PUSH
86267: LD_INT 1
86269: EQUAL
86270: PUSH
86271: LD_VAR 0 4
86275: PPUSH
86276: CALL_OW 261
86280: PUSH
86281: LD_INT 30
86283: LESS
86284: AND
86285: PUSH
86286: LD_VAR 0 7
86290: AND
86291: IFFALSE 86361
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
86293: LD_VAR 0 4
86297: PPUSH
86298: LD_VAR 0 7
86302: PPUSH
86303: LD_VAR 0 4
86307: PPUSH
86308: CALL_OW 74
86312: PPUSH
86313: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
86317: LD_VAR 0 4
86321: PPUSH
86322: LD_VAR 0 7
86326: PPUSH
86327: LD_VAR 0 4
86331: PPUSH
86332: CALL_OW 74
86336: PPUSH
86337: CALL_OW 296
86341: PUSH
86342: LD_INT 6
86344: LESS
86345: IFFALSE 86359
// SetFuel ( i , 100 ) ;
86347: LD_VAR 0 4
86351: PPUSH
86352: LD_INT 100
86354: PPUSH
86355: CALL_OW 240
// end else
86359: GO 86375
// ComAttackUnit ( i , e ) ;
86361: LD_VAR 0 4
86365: PPUSH
86366: LD_VAR 0 13
86370: PPUSH
86371: CALL_OW 115
// end else
86375: GO 86478
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
86377: LD_VAR 0 13
86381: PPUSH
86382: LD_EXP 48
86386: PUSH
86387: LD_VAR 0 1
86391: ARRAY
86392: PPUSH
86393: CALL_OW 308
86397: NOT
86398: PUSH
86399: LD_VAR 0 4
86403: PPUSH
86404: LD_VAR 0 13
86408: PPUSH
86409: CALL_OW 296
86413: PUSH
86414: LD_INT 40
86416: GREATEREQUAL
86417: AND
86418: PUSH
86419: LD_VAR 0 4
86423: PPUSH
86424: CALL_OW 256
86428: PUSH
86429: LD_INT 650
86431: LESSEQUAL
86432: OR
86433: PUSH
86434: LD_VAR 0 4
86438: PPUSH
86439: LD_EXP 47
86443: PUSH
86444: LD_VAR 0 1
86448: ARRAY
86449: PPUSH
86450: CALL_OW 308
86454: NOT
86455: AND
86456: IFFALSE 86478
// ComMoveToArea ( i , mc_parking [ base ] ) ;
86458: LD_VAR 0 4
86462: PPUSH
86463: LD_EXP 47
86467: PUSH
86468: LD_VAR 0 1
86472: ARRAY
86473: PPUSH
86474: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
86478: LD_VAR 0 4
86482: PPUSH
86483: CALL_OW 256
86487: PUSH
86488: LD_INT 1000
86490: LESS
86491: PUSH
86492: LD_VAR 0 4
86496: PPUSH
86497: CALL_OW 263
86501: PUSH
86502: LD_INT 1
86504: EQUAL
86505: AND
86506: PUSH
86507: LD_VAR 0 4
86511: PPUSH
86512: CALL_OW 311
86516: AND
86517: PUSH
86518: LD_VAR 0 4
86522: PPUSH
86523: LD_EXP 47
86527: PUSH
86528: LD_VAR 0 1
86532: ARRAY
86533: PPUSH
86534: CALL_OW 308
86538: AND
86539: IFFALSE 86593
// begin mech := IsDrivenBy ( i ) ;
86541: LD_ADDR_VAR 0 9
86545: PUSH
86546: LD_VAR 0 4
86550: PPUSH
86551: CALL_OW 311
86555: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
86556: LD_VAR 0 9
86560: PPUSH
86561: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
86565: LD_VAR 0 9
86569: PPUSH
86570: LD_VAR 0 4
86574: PPUSH
86575: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
86579: LD_VAR 0 9
86583: PPUSH
86584: LD_VAR 0 4
86588: PPUSH
86589: CALL_OW 180
// end ; end ; unit_human :
86593: GO 86940
86595: LD_INT 1
86597: DOUBLE
86598: EQUAL
86599: IFTRUE 86603
86601: GO 86939
86603: POP
// begin b := IsInUnit ( i ) ;
86604: LD_ADDR_VAR 0 18
86608: PUSH
86609: LD_VAR 0 4
86613: PPUSH
86614: CALL_OW 310
86618: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
86619: LD_ADDR_VAR 0 19
86623: PUSH
86624: LD_VAR 0 18
86628: NOT
86629: PUSH
86630: LD_VAR 0 18
86634: PPUSH
86635: CALL_OW 266
86639: PUSH
86640: LD_INT 32
86642: PUSH
86643: LD_INT 31
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: IN
86650: OR
86651: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
86652: LD_VAR 0 18
86656: PPUSH
86657: CALL_OW 266
86661: PUSH
86662: LD_INT 5
86664: EQUAL
86665: PUSH
86666: LD_VAR 0 4
86670: PPUSH
86671: CALL_OW 257
86675: PUSH
86676: LD_INT 1
86678: PUSH
86679: LD_INT 2
86681: PUSH
86682: LD_INT 3
86684: PUSH
86685: LD_INT 4
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: IN
86694: AND
86695: IFFALSE 86732
// begin class := AllowSpecClass ( i ) ;
86697: LD_ADDR_VAR 0 20
86701: PUSH
86702: LD_VAR 0 4
86706: PPUSH
86707: CALL 12504 0 1
86711: ST_TO_ADDR
// if class then
86712: LD_VAR 0 20
86716: IFFALSE 86732
// ComChangeProfession ( i , class ) ;
86718: LD_VAR 0 4
86722: PPUSH
86723: LD_VAR 0 20
86727: PPUSH
86728: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
86732: LD_VAR 0 16
86736: PUSH
86737: LD_VAR 0 2
86741: PPUSH
86742: LD_INT 21
86744: PUSH
86745: LD_INT 2
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PPUSH
86752: CALL_OW 72
86756: PUSH
86757: LD_INT 1
86759: LESSEQUAL
86760: OR
86761: PUSH
86762: LD_VAR 0 19
86766: AND
86767: PUSH
86768: LD_VAR 0 4
86772: PUSH
86773: LD_VAR 0 17
86777: IN
86778: NOT
86779: AND
86780: IFFALSE 86873
// begin if b then
86782: LD_VAR 0 18
86786: IFFALSE 86835
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
86788: LD_VAR 0 18
86792: PPUSH
86793: LD_VAR 0 21
86797: PPUSH
86798: LD_VAR 0 18
86802: PPUSH
86803: CALL_OW 74
86807: PPUSH
86808: CALL_OW 296
86812: PUSH
86813: LD_INT 10
86815: LESS
86816: PUSH
86817: LD_VAR 0 18
86821: PPUSH
86822: CALL_OW 461
86826: PUSH
86827: LD_INT 7
86829: NONEQUAL
86830: AND
86831: IFFALSE 86835
// continue ;
86833: GO 86070
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
86835: LD_ADDR_VAR 0 17
86839: PUSH
86840: LD_VAR 0 17
86844: PPUSH
86845: LD_VAR 0 17
86849: PUSH
86850: LD_INT 1
86852: PLUS
86853: PPUSH
86854: LD_VAR 0 4
86858: PPUSH
86859: CALL_OW 1
86863: ST_TO_ADDR
// ComExitBuilding ( i ) ;
86864: LD_VAR 0 4
86868: PPUSH
86869: CALL_OW 122
// end ; if sold_defenders then
86873: LD_VAR 0 17
86877: IFFALSE 86937
// if i in sold_defenders then
86879: LD_VAR 0 4
86883: PUSH
86884: LD_VAR 0 17
86888: IN
86889: IFFALSE 86937
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
86891: LD_VAR 0 4
86895: PPUSH
86896: CALL_OW 314
86900: NOT
86901: PUSH
86902: LD_VAR 0 4
86906: PPUSH
86907: LD_VAR 0 13
86911: PPUSH
86912: CALL_OW 296
86916: PUSH
86917: LD_INT 30
86919: LESS
86920: AND
86921: IFFALSE 86937
// ComAttackUnit ( i , e ) ;
86923: LD_VAR 0 4
86927: PPUSH
86928: LD_VAR 0 13
86932: PPUSH
86933: CALL_OW 115
// end ; end ; end ;
86937: GO 86940
86939: POP
// if IsDead ( i ) then
86940: LD_VAR 0 4
86944: PPUSH
86945: CALL_OW 301
86949: IFFALSE 86967
// defenders := defenders diff i ;
86951: LD_ADDR_VAR 0 2
86955: PUSH
86956: LD_VAR 0 2
86960: PUSH
86961: LD_VAR 0 4
86965: DIFF
86966: ST_TO_ADDR
// end ;
86967: GO 86070
86969: POP
86970: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
86971: LD_VAR 0 21
86975: NOT
86976: PUSH
86977: LD_VAR 0 2
86981: NOT
86982: OR
86983: PUSH
86984: LD_EXP 23
86988: PUSH
86989: LD_VAR 0 1
86993: ARRAY
86994: NOT
86995: OR
86996: IFFALSE 85974
// MC_Reset ( base , 18 ) ;
86998: LD_VAR 0 1
87002: PPUSH
87003: LD_INT 18
87005: PPUSH
87006: CALL 53746 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
87010: LD_ADDR_VAR 0 2
87014: PUSH
87015: LD_VAR 0 2
87019: PUSH
87020: LD_VAR 0 2
87024: PPUSH
87025: LD_INT 2
87027: PUSH
87028: LD_INT 25
87030: PUSH
87031: LD_INT 1
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: PUSH
87038: LD_INT 25
87040: PUSH
87041: LD_INT 5
87043: PUSH
87044: EMPTY
87045: LIST
87046: LIST
87047: PUSH
87048: LD_INT 25
87050: PUSH
87051: LD_INT 8
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 25
87060: PUSH
87061: LD_INT 9
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: PPUSH
87075: CALL_OW 72
87079: DIFF
87080: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
87081: LD_VAR 0 21
87085: NOT
87086: PUSH
87087: LD_VAR 0 2
87091: PPUSH
87092: LD_INT 21
87094: PUSH
87095: LD_INT 2
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PPUSH
87102: CALL_OW 72
87106: AND
87107: IFFALSE 87445
// begin tmp := FilterByTag ( defenders , 19 ) ;
87109: LD_ADDR_VAR 0 11
87113: PUSH
87114: LD_VAR 0 2
87118: PPUSH
87119: LD_INT 19
87121: PPUSH
87122: CALL 44973 0 2
87126: ST_TO_ADDR
// if tmp then
87127: LD_VAR 0 11
87131: IFFALSE 87201
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
87133: LD_ADDR_VAR 0 11
87137: PUSH
87138: LD_VAR 0 11
87142: PPUSH
87143: LD_INT 25
87145: PUSH
87146: LD_INT 3
87148: PUSH
87149: EMPTY
87150: LIST
87151: LIST
87152: PPUSH
87153: CALL_OW 72
87157: ST_TO_ADDR
// if tmp then
87158: LD_VAR 0 11
87162: IFFALSE 87201
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
87164: LD_ADDR_EXP 35
87168: PUSH
87169: LD_EXP 35
87173: PPUSH
87174: LD_VAR 0 1
87178: PPUSH
87179: LD_EXP 35
87183: PUSH
87184: LD_VAR 0 1
87188: ARRAY
87189: PUSH
87190: LD_VAR 0 11
87194: UNION
87195: PPUSH
87196: CALL_OW 1
87200: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
87201: LD_VAR 0 1
87205: PPUSH
87206: LD_INT 19
87208: PPUSH
87209: CALL 53746 0 2
// repeat wait ( 0 0$1 ) ;
87213: LD_INT 35
87215: PPUSH
87216: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87220: LD_EXP 23
87224: PUSH
87225: LD_VAR 0 1
87229: ARRAY
87230: NOT
87231: PUSH
87232: LD_EXP 23
87236: PUSH
87237: LD_VAR 0 1
87241: ARRAY
87242: PUSH
87243: EMPTY
87244: EQUAL
87245: OR
87246: IFFALSE 87283
// begin for i in defenders do
87248: LD_ADDR_VAR 0 4
87252: PUSH
87253: LD_VAR 0 2
87257: PUSH
87258: FOR_IN
87259: IFFALSE 87272
// ComStop ( i ) ;
87261: LD_VAR 0 4
87265: PPUSH
87266: CALL_OW 141
87270: GO 87258
87272: POP
87273: POP
// defenders := [ ] ;
87274: LD_ADDR_VAR 0 2
87278: PUSH
87279: EMPTY
87280: ST_TO_ADDR
// exit ;
87281: GO 87509
// end ; for i in defenders do
87283: LD_ADDR_VAR 0 4
87287: PUSH
87288: LD_VAR 0 2
87292: PUSH
87293: FOR_IN
87294: IFFALSE 87383
// begin if not IsInArea ( i , mc_parking [ base ] ) then
87296: LD_VAR 0 4
87300: PPUSH
87301: LD_EXP 47
87305: PUSH
87306: LD_VAR 0 1
87310: ARRAY
87311: PPUSH
87312: CALL_OW 308
87316: NOT
87317: IFFALSE 87341
// ComMoveToArea ( i , mc_parking [ base ] ) else
87319: LD_VAR 0 4
87323: PPUSH
87324: LD_EXP 47
87328: PUSH
87329: LD_VAR 0 1
87333: ARRAY
87334: PPUSH
87335: CALL_OW 113
87339: GO 87381
// if GetControl ( i ) = control_manual then
87341: LD_VAR 0 4
87345: PPUSH
87346: CALL_OW 263
87350: PUSH
87351: LD_INT 1
87353: EQUAL
87354: IFFALSE 87381
// if IsDrivenBy ( i ) then
87356: LD_VAR 0 4
87360: PPUSH
87361: CALL_OW 311
87365: IFFALSE 87381
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
87367: LD_VAR 0 4
87371: PPUSH
87372: CALL_OW 311
87376: PPUSH
87377: CALL_OW 121
// end ;
87381: GO 87293
87383: POP
87384: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
87385: LD_VAR 0 2
87389: PPUSH
87390: LD_INT 95
87392: PUSH
87393: LD_EXP 47
87397: PUSH
87398: LD_VAR 0 1
87402: ARRAY
87403: PUSH
87404: EMPTY
87405: LIST
87406: LIST
87407: PPUSH
87408: CALL_OW 72
87412: PUSH
87413: LD_VAR 0 2
87417: EQUAL
87418: PUSH
87419: LD_EXP 46
87423: PUSH
87424: LD_VAR 0 1
87428: ARRAY
87429: OR
87430: PUSH
87431: LD_EXP 23
87435: PUSH
87436: LD_VAR 0 1
87440: ARRAY
87441: NOT
87442: OR
87443: IFFALSE 87213
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
87445: LD_ADDR_EXP 45
87449: PUSH
87450: LD_EXP 45
87454: PPUSH
87455: LD_VAR 0 1
87459: PPUSH
87460: LD_VAR 0 2
87464: PPUSH
87465: LD_INT 21
87467: PUSH
87468: LD_INT 2
87470: PUSH
87471: EMPTY
87472: LIST
87473: LIST
87474: PPUSH
87475: CALL_OW 72
87479: PPUSH
87480: CALL_OW 1
87484: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
87485: LD_VAR 0 1
87489: PPUSH
87490: LD_INT 19
87492: PPUSH
87493: CALL 53746 0 2
// MC_Reset ( base , 20 ) ;
87497: LD_VAR 0 1
87501: PPUSH
87502: LD_INT 20
87504: PPUSH
87505: CALL 53746 0 2
// end ; end_of_file
87509: LD_VAR 0 3
87513: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
87514: LD_INT 0
87516: PPUSH
87517: PPUSH
87518: PPUSH
87519: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87520: LD_VAR 0 1
87524: PPUSH
87525: CALL_OW 264
87529: PUSH
87530: LD_EXP 71
87534: EQUAL
87535: IFFALSE 87607
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87537: LD_INT 68
87539: PPUSH
87540: LD_VAR 0 1
87544: PPUSH
87545: CALL_OW 255
87549: PPUSH
87550: CALL_OW 321
87554: PUSH
87555: LD_INT 2
87557: EQUAL
87558: IFFALSE 87570
// eff := 70 else
87560: LD_ADDR_VAR 0 4
87564: PUSH
87565: LD_INT 70
87567: ST_TO_ADDR
87568: GO 87578
// eff := 30 ;
87570: LD_ADDR_VAR 0 4
87574: PUSH
87575: LD_INT 30
87577: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87578: LD_VAR 0 1
87582: PPUSH
87583: CALL_OW 250
87587: PPUSH
87588: LD_VAR 0 1
87592: PPUSH
87593: CALL_OW 251
87597: PPUSH
87598: LD_VAR 0 4
87602: PPUSH
87603: CALL_OW 495
// end ; end ;
87607: LD_VAR 0 2
87611: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
87612: LD_INT 0
87614: PPUSH
// end ;
87615: LD_VAR 0 4
87619: RET
// export function SOS_Command ( cmd ) ; begin
87620: LD_INT 0
87622: PPUSH
// end ;
87623: LD_VAR 0 2
87627: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
87628: LD_INT 0
87630: PPUSH
// if cmd = 121 then
87631: LD_VAR 0 1
87635: PUSH
87636: LD_INT 121
87638: EQUAL
87639: IFFALSE 87641
// end ;
87641: LD_VAR 0 6
87645: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
87646: LD_INT 0
87648: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
87649: LD_VAR 0 1
87653: PUSH
87654: LD_INT 250
87656: EQUAL
87657: PUSH
87658: LD_VAR 0 2
87662: PPUSH
87663: CALL_OW 264
87667: PUSH
87668: LD_EXP 74
87672: EQUAL
87673: AND
87674: IFFALSE 87695
// MinerPlaceMine ( unit , x , y ) ;
87676: LD_VAR 0 2
87680: PPUSH
87681: LD_VAR 0 4
87685: PPUSH
87686: LD_VAR 0 5
87690: PPUSH
87691: CALL 90044 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
87695: LD_VAR 0 1
87699: PUSH
87700: LD_INT 251
87702: EQUAL
87703: PUSH
87704: LD_VAR 0 2
87708: PPUSH
87709: CALL_OW 264
87713: PUSH
87714: LD_EXP 74
87718: EQUAL
87719: AND
87720: IFFALSE 87741
// MinerDetonateMine ( unit , x , y ) ;
87722: LD_VAR 0 2
87726: PPUSH
87727: LD_VAR 0 4
87731: PPUSH
87732: LD_VAR 0 5
87736: PPUSH
87737: CALL 90321 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
87741: LD_VAR 0 1
87745: PUSH
87746: LD_INT 252
87748: EQUAL
87749: PUSH
87750: LD_VAR 0 2
87754: PPUSH
87755: CALL_OW 264
87759: PUSH
87760: LD_EXP 74
87764: EQUAL
87765: AND
87766: IFFALSE 87787
// MinerCreateMinefield ( unit , x , y ) ;
87768: LD_VAR 0 2
87772: PPUSH
87773: LD_VAR 0 4
87777: PPUSH
87778: LD_VAR 0 5
87782: PPUSH
87783: CALL 90738 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
87787: LD_VAR 0 1
87791: PUSH
87792: LD_INT 253
87794: EQUAL
87795: PUSH
87796: LD_VAR 0 2
87800: PPUSH
87801: CALL_OW 257
87805: PUSH
87806: LD_INT 5
87808: EQUAL
87809: AND
87810: IFFALSE 87831
// ComBinocular ( unit , x , y ) ;
87812: LD_VAR 0 2
87816: PPUSH
87817: LD_VAR 0 4
87821: PPUSH
87822: LD_VAR 0 5
87826: PPUSH
87827: CALL 91109 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
87831: LD_VAR 0 1
87835: PUSH
87836: LD_INT 254
87838: EQUAL
87839: PUSH
87840: LD_VAR 0 2
87844: PPUSH
87845: CALL_OW 264
87849: PUSH
87850: LD_EXP 69
87854: EQUAL
87855: AND
87856: PUSH
87857: LD_VAR 0 3
87861: PPUSH
87862: CALL_OW 263
87866: PUSH
87867: LD_INT 3
87869: EQUAL
87870: AND
87871: IFFALSE 87887
// HackDestroyVehicle ( unit , selectedUnit ) ;
87873: LD_VAR 0 2
87877: PPUSH
87878: LD_VAR 0 3
87882: PPUSH
87883: CALL 89404 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
87887: LD_VAR 0 1
87891: PUSH
87892: LD_INT 255
87894: EQUAL
87895: PUSH
87896: LD_VAR 0 2
87900: PPUSH
87901: CALL_OW 264
87905: PUSH
87906: LD_INT 14
87908: PUSH
87909: LD_INT 53
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: IN
87916: AND
87917: PUSH
87918: LD_VAR 0 4
87922: PPUSH
87923: LD_VAR 0 5
87927: PPUSH
87928: CALL_OW 488
87932: AND
87933: IFFALSE 87957
// CutTreeXYR ( unit , x , y , 12 ) ;
87935: LD_VAR 0 2
87939: PPUSH
87940: LD_VAR 0 4
87944: PPUSH
87945: LD_VAR 0 5
87949: PPUSH
87950: LD_INT 12
87952: PPUSH
87953: CALL 87970 0 4
// end ;
87957: LD_VAR 0 6
87961: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
87962: LD_INT 0
87964: PPUSH
// end ;
87965: LD_VAR 0 4
87969: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87970: LD_INT 0
87972: PPUSH
87973: PPUSH
87974: PPUSH
87975: PPUSH
87976: PPUSH
87977: PPUSH
87978: PPUSH
87979: PPUSH
87980: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87981: LD_VAR 0 1
87985: NOT
87986: PUSH
87987: LD_VAR 0 2
87991: PPUSH
87992: LD_VAR 0 3
87996: PPUSH
87997: CALL_OW 488
88001: NOT
88002: OR
88003: PUSH
88004: LD_VAR 0 4
88008: NOT
88009: OR
88010: IFFALSE 88014
// exit ;
88012: GO 88354
// list := [ ] ;
88014: LD_ADDR_VAR 0 13
88018: PUSH
88019: EMPTY
88020: ST_TO_ADDR
// if x - r < 0 then
88021: LD_VAR 0 2
88025: PUSH
88026: LD_VAR 0 4
88030: MINUS
88031: PUSH
88032: LD_INT 0
88034: LESS
88035: IFFALSE 88047
// min_x := 0 else
88037: LD_ADDR_VAR 0 7
88041: PUSH
88042: LD_INT 0
88044: ST_TO_ADDR
88045: GO 88063
// min_x := x - r ;
88047: LD_ADDR_VAR 0 7
88051: PUSH
88052: LD_VAR 0 2
88056: PUSH
88057: LD_VAR 0 4
88061: MINUS
88062: ST_TO_ADDR
// if y - r < 0 then
88063: LD_VAR 0 3
88067: PUSH
88068: LD_VAR 0 4
88072: MINUS
88073: PUSH
88074: LD_INT 0
88076: LESS
88077: IFFALSE 88089
// min_y := 0 else
88079: LD_ADDR_VAR 0 8
88083: PUSH
88084: LD_INT 0
88086: ST_TO_ADDR
88087: GO 88105
// min_y := y - r ;
88089: LD_ADDR_VAR 0 8
88093: PUSH
88094: LD_VAR 0 3
88098: PUSH
88099: LD_VAR 0 4
88103: MINUS
88104: ST_TO_ADDR
// max_x := x + r ;
88105: LD_ADDR_VAR 0 9
88109: PUSH
88110: LD_VAR 0 2
88114: PUSH
88115: LD_VAR 0 4
88119: PLUS
88120: ST_TO_ADDR
// max_y := y + r ;
88121: LD_ADDR_VAR 0 10
88125: PUSH
88126: LD_VAR 0 3
88130: PUSH
88131: LD_VAR 0 4
88135: PLUS
88136: ST_TO_ADDR
// for _x = min_x to max_x do
88137: LD_ADDR_VAR 0 11
88141: PUSH
88142: DOUBLE
88143: LD_VAR 0 7
88147: DEC
88148: ST_TO_ADDR
88149: LD_VAR 0 9
88153: PUSH
88154: FOR_TO
88155: IFFALSE 88272
// for _y = min_y to max_y do
88157: LD_ADDR_VAR 0 12
88161: PUSH
88162: DOUBLE
88163: LD_VAR 0 8
88167: DEC
88168: ST_TO_ADDR
88169: LD_VAR 0 10
88173: PUSH
88174: FOR_TO
88175: IFFALSE 88268
// begin if not ValidHex ( _x , _y ) then
88177: LD_VAR 0 11
88181: PPUSH
88182: LD_VAR 0 12
88186: PPUSH
88187: CALL_OW 488
88191: NOT
88192: IFFALSE 88196
// continue ;
88194: GO 88174
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
88196: LD_VAR 0 11
88200: PPUSH
88201: LD_VAR 0 12
88205: PPUSH
88206: CALL_OW 351
88210: PUSH
88211: LD_VAR 0 11
88215: PPUSH
88216: LD_VAR 0 12
88220: PPUSH
88221: CALL_OW 554
88225: AND
88226: IFFALSE 88266
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
88228: LD_ADDR_VAR 0 13
88232: PUSH
88233: LD_VAR 0 13
88237: PPUSH
88238: LD_VAR 0 13
88242: PUSH
88243: LD_INT 1
88245: PLUS
88246: PPUSH
88247: LD_VAR 0 11
88251: PUSH
88252: LD_VAR 0 12
88256: PUSH
88257: EMPTY
88258: LIST
88259: LIST
88260: PPUSH
88261: CALL_OW 2
88265: ST_TO_ADDR
// end ;
88266: GO 88174
88268: POP
88269: POP
88270: GO 88154
88272: POP
88273: POP
// if not list then
88274: LD_VAR 0 13
88278: NOT
88279: IFFALSE 88283
// exit ;
88281: GO 88354
// for i in list do
88283: LD_ADDR_VAR 0 6
88287: PUSH
88288: LD_VAR 0 13
88292: PUSH
88293: FOR_IN
88294: IFFALSE 88352
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88296: LD_VAR 0 1
88300: PPUSH
88301: LD_STRING M
88303: PUSH
88304: LD_VAR 0 6
88308: PUSH
88309: LD_INT 1
88311: ARRAY
88312: PUSH
88313: LD_VAR 0 6
88317: PUSH
88318: LD_INT 2
88320: ARRAY
88321: PUSH
88322: LD_INT 0
88324: PUSH
88325: LD_INT 0
88327: PUSH
88328: LD_INT 0
88330: PUSH
88331: LD_INT 0
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: PUSH
88343: EMPTY
88344: LIST
88345: PPUSH
88346: CALL_OW 447
88350: GO 88293
88352: POP
88353: POP
// end ;
88354: LD_VAR 0 5
88358: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
88359: LD_EXP 88
88363: NOT
88364: IFFALSE 88414
88366: GO 88368
88368: DISABLE
// begin initHack := true ;
88369: LD_ADDR_EXP 88
88373: PUSH
88374: LD_INT 1
88376: ST_TO_ADDR
// hackTanks := [ ] ;
88377: LD_ADDR_EXP 89
88381: PUSH
88382: EMPTY
88383: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
88384: LD_ADDR_EXP 90
88388: PUSH
88389: EMPTY
88390: ST_TO_ADDR
// hackLimit := 3 ;
88391: LD_ADDR_EXP 91
88395: PUSH
88396: LD_INT 3
88398: ST_TO_ADDR
// hackDist := 12 ;
88399: LD_ADDR_EXP 92
88403: PUSH
88404: LD_INT 12
88406: ST_TO_ADDR
// hackCounter := [ ] ;
88407: LD_ADDR_EXP 93
88411: PUSH
88412: EMPTY
88413: ST_TO_ADDR
// end ;
88414: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
88415: LD_EXP 88
88419: PUSH
88420: LD_INT 34
88422: PUSH
88423: LD_EXP 69
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: PPUSH
88432: CALL_OW 69
88436: AND
88437: IFFALSE 88692
88439: GO 88441
88441: DISABLE
88442: LD_INT 0
88444: PPUSH
88445: PPUSH
// begin enable ;
88446: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
88447: LD_ADDR_VAR 0 1
88451: PUSH
88452: LD_INT 34
88454: PUSH
88455: LD_EXP 69
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: PPUSH
88464: CALL_OW 69
88468: PUSH
88469: FOR_IN
88470: IFFALSE 88690
// begin if not i in hackTanks then
88472: LD_VAR 0 1
88476: PUSH
88477: LD_EXP 89
88481: IN
88482: NOT
88483: IFFALSE 88566
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
88485: LD_ADDR_EXP 89
88489: PUSH
88490: LD_EXP 89
88494: PPUSH
88495: LD_EXP 89
88499: PUSH
88500: LD_INT 1
88502: PLUS
88503: PPUSH
88504: LD_VAR 0 1
88508: PPUSH
88509: CALL_OW 1
88513: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
88514: LD_ADDR_EXP 90
88518: PUSH
88519: LD_EXP 90
88523: PPUSH
88524: LD_EXP 90
88528: PUSH
88529: LD_INT 1
88531: PLUS
88532: PPUSH
88533: EMPTY
88534: PPUSH
88535: CALL_OW 1
88539: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
88540: LD_ADDR_EXP 93
88544: PUSH
88545: LD_EXP 93
88549: PPUSH
88550: LD_EXP 93
88554: PUSH
88555: LD_INT 1
88557: PLUS
88558: PPUSH
88559: EMPTY
88560: PPUSH
88561: CALL_OW 1
88565: ST_TO_ADDR
// end ; if not IsOk ( i ) then
88566: LD_VAR 0 1
88570: PPUSH
88571: CALL_OW 302
88575: NOT
88576: IFFALSE 88589
// begin HackUnlinkAll ( i ) ;
88578: LD_VAR 0 1
88582: PPUSH
88583: CALL 88695 0 1
// continue ;
88587: GO 88469
// end ; HackCheckCapturedStatus ( i ) ;
88589: LD_VAR 0 1
88593: PPUSH
88594: CALL 89138 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
88598: LD_ADDR_VAR 0 2
88602: PUSH
88603: LD_INT 81
88605: PUSH
88606: LD_VAR 0 1
88610: PPUSH
88611: CALL_OW 255
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 33
88622: PUSH
88623: LD_INT 3
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: PUSH
88630: LD_INT 91
88632: PUSH
88633: LD_VAR 0 1
88637: PUSH
88638: LD_EXP 92
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: LIST
88647: PUSH
88648: LD_INT 50
88650: PUSH
88651: EMPTY
88652: LIST
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: PPUSH
88660: CALL_OW 69
88664: ST_TO_ADDR
// if not tmp then
88665: LD_VAR 0 2
88669: NOT
88670: IFFALSE 88674
// continue ;
88672: GO 88469
// HackLink ( i , tmp ) ;
88674: LD_VAR 0 1
88678: PPUSH
88679: LD_VAR 0 2
88683: PPUSH
88684: CALL 88831 0 2
// end ;
88688: GO 88469
88690: POP
88691: POP
// end ;
88692: PPOPN 2
88694: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
88695: LD_INT 0
88697: PPUSH
88698: PPUSH
88699: PPUSH
// if not hack in hackTanks then
88700: LD_VAR 0 1
88704: PUSH
88705: LD_EXP 89
88709: IN
88710: NOT
88711: IFFALSE 88715
// exit ;
88713: GO 88826
// index := GetElementIndex ( hackTanks , hack ) ;
88715: LD_ADDR_VAR 0 4
88719: PUSH
88720: LD_EXP 89
88724: PPUSH
88725: LD_VAR 0 1
88729: PPUSH
88730: CALL 15489 0 2
88734: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
88735: LD_EXP 90
88739: PUSH
88740: LD_VAR 0 4
88744: ARRAY
88745: IFFALSE 88826
// begin for i in hackTanksCaptured [ index ] do
88747: LD_ADDR_VAR 0 3
88751: PUSH
88752: LD_EXP 90
88756: PUSH
88757: LD_VAR 0 4
88761: ARRAY
88762: PUSH
88763: FOR_IN
88764: IFFALSE 88790
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
88766: LD_VAR 0 3
88770: PUSH
88771: LD_INT 1
88773: ARRAY
88774: PPUSH
88775: LD_VAR 0 3
88779: PUSH
88780: LD_INT 2
88782: ARRAY
88783: PPUSH
88784: CALL_OW 235
88788: GO 88763
88790: POP
88791: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
88792: LD_ADDR_EXP 90
88796: PUSH
88797: LD_EXP 90
88801: PPUSH
88802: LD_VAR 0 4
88806: PPUSH
88807: EMPTY
88808: PPUSH
88809: CALL_OW 1
88813: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
88814: LD_VAR 0 1
88818: PPUSH
88819: LD_INT 0
88821: PPUSH
88822: CALL_OW 505
// end ; end ;
88826: LD_VAR 0 2
88830: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
88831: LD_INT 0
88833: PPUSH
88834: PPUSH
88835: PPUSH
// if not hack in hackTanks or not vehicles then
88836: LD_VAR 0 1
88840: PUSH
88841: LD_EXP 89
88845: IN
88846: NOT
88847: PUSH
88848: LD_VAR 0 2
88852: NOT
88853: OR
88854: IFFALSE 88858
// exit ;
88856: GO 89133
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
88858: LD_ADDR_VAR 0 2
88862: PUSH
88863: LD_VAR 0 1
88867: PPUSH
88868: LD_VAR 0 2
88872: PPUSH
88873: LD_INT 1
88875: PPUSH
88876: LD_INT 1
88878: PPUSH
88879: CALL 16139 0 4
88883: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
88884: LD_ADDR_VAR 0 5
88888: PUSH
88889: LD_EXP 89
88893: PPUSH
88894: LD_VAR 0 1
88898: PPUSH
88899: CALL 15489 0 2
88903: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
88904: LD_EXP 90
88908: PUSH
88909: LD_VAR 0 5
88913: ARRAY
88914: PUSH
88915: LD_EXP 91
88919: LESS
88920: IFFALSE 89109
// begin for i := 1 to vehicles do
88922: LD_ADDR_VAR 0 4
88926: PUSH
88927: DOUBLE
88928: LD_INT 1
88930: DEC
88931: ST_TO_ADDR
88932: LD_VAR 0 2
88936: PUSH
88937: FOR_TO
88938: IFFALSE 89107
// begin if hackTanksCaptured [ index ] = hackLimit then
88940: LD_EXP 90
88944: PUSH
88945: LD_VAR 0 5
88949: ARRAY
88950: PUSH
88951: LD_EXP 91
88955: EQUAL
88956: IFFALSE 88960
// break ;
88958: GO 89107
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
88960: LD_ADDR_EXP 93
88964: PUSH
88965: LD_EXP 93
88969: PPUSH
88970: LD_VAR 0 5
88974: PPUSH
88975: LD_EXP 93
88979: PUSH
88980: LD_VAR 0 5
88984: ARRAY
88985: PUSH
88986: LD_INT 1
88988: PLUS
88989: PPUSH
88990: CALL_OW 1
88994: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
88995: LD_ADDR_EXP 90
88999: PUSH
89000: LD_EXP 90
89004: PPUSH
89005: LD_VAR 0 5
89009: PUSH
89010: LD_EXP 90
89014: PUSH
89015: LD_VAR 0 5
89019: ARRAY
89020: PUSH
89021: LD_INT 1
89023: PLUS
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PPUSH
89029: LD_VAR 0 2
89033: PUSH
89034: LD_VAR 0 4
89038: ARRAY
89039: PUSH
89040: LD_VAR 0 2
89044: PUSH
89045: LD_VAR 0 4
89049: ARRAY
89050: PPUSH
89051: CALL_OW 255
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PPUSH
89060: CALL 15704 0 3
89064: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
89065: LD_VAR 0 2
89069: PUSH
89070: LD_VAR 0 4
89074: ARRAY
89075: PPUSH
89076: LD_VAR 0 1
89080: PPUSH
89081: CALL_OW 255
89085: PPUSH
89086: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
89090: LD_VAR 0 2
89094: PUSH
89095: LD_VAR 0 4
89099: ARRAY
89100: PPUSH
89101: CALL_OW 141
// end ;
89105: GO 88937
89107: POP
89108: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
89109: LD_VAR 0 1
89113: PPUSH
89114: LD_EXP 90
89118: PUSH
89119: LD_VAR 0 5
89123: ARRAY
89124: PUSH
89125: LD_INT 0
89127: PLUS
89128: PPUSH
89129: CALL_OW 505
// end ;
89133: LD_VAR 0 3
89137: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
89138: LD_INT 0
89140: PPUSH
89141: PPUSH
89142: PPUSH
89143: PPUSH
// if not hack in hackTanks then
89144: LD_VAR 0 1
89148: PUSH
89149: LD_EXP 89
89153: IN
89154: NOT
89155: IFFALSE 89159
// exit ;
89157: GO 89399
// index := GetElementIndex ( hackTanks , hack ) ;
89159: LD_ADDR_VAR 0 4
89163: PUSH
89164: LD_EXP 89
89168: PPUSH
89169: LD_VAR 0 1
89173: PPUSH
89174: CALL 15489 0 2
89178: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
89179: LD_ADDR_VAR 0 3
89183: PUSH
89184: DOUBLE
89185: LD_EXP 90
89189: PUSH
89190: LD_VAR 0 4
89194: ARRAY
89195: INC
89196: ST_TO_ADDR
89197: LD_INT 1
89199: PUSH
89200: FOR_DOWNTO
89201: IFFALSE 89373
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
89203: LD_ADDR_VAR 0 5
89207: PUSH
89208: LD_EXP 90
89212: PUSH
89213: LD_VAR 0 4
89217: ARRAY
89218: PUSH
89219: LD_VAR 0 3
89223: ARRAY
89224: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
89225: LD_VAR 0 5
89229: PUSH
89230: LD_INT 1
89232: ARRAY
89233: PPUSH
89234: CALL_OW 302
89238: NOT
89239: PUSH
89240: LD_VAR 0 5
89244: PUSH
89245: LD_INT 1
89247: ARRAY
89248: PPUSH
89249: CALL_OW 255
89253: PUSH
89254: LD_VAR 0 1
89258: PPUSH
89259: CALL_OW 255
89263: NONEQUAL
89264: OR
89265: IFFALSE 89371
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
89267: LD_VAR 0 5
89271: PUSH
89272: LD_INT 1
89274: ARRAY
89275: PPUSH
89276: CALL_OW 305
89280: PUSH
89281: LD_VAR 0 5
89285: PUSH
89286: LD_INT 1
89288: ARRAY
89289: PPUSH
89290: CALL_OW 255
89294: PUSH
89295: LD_VAR 0 1
89299: PPUSH
89300: CALL_OW 255
89304: EQUAL
89305: AND
89306: IFFALSE 89330
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
89308: LD_VAR 0 5
89312: PUSH
89313: LD_INT 1
89315: ARRAY
89316: PPUSH
89317: LD_VAR 0 5
89321: PUSH
89322: LD_INT 2
89324: ARRAY
89325: PPUSH
89326: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
89330: LD_ADDR_EXP 90
89334: PUSH
89335: LD_EXP 90
89339: PPUSH
89340: LD_VAR 0 4
89344: PPUSH
89345: LD_EXP 90
89349: PUSH
89350: LD_VAR 0 4
89354: ARRAY
89355: PPUSH
89356: LD_VAR 0 3
89360: PPUSH
89361: CALL_OW 3
89365: PPUSH
89366: CALL_OW 1
89370: ST_TO_ADDR
// end ; end ;
89371: GO 89200
89373: POP
89374: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
89375: LD_VAR 0 1
89379: PPUSH
89380: LD_EXP 90
89384: PUSH
89385: LD_VAR 0 4
89389: ARRAY
89390: PUSH
89391: LD_INT 0
89393: PLUS
89394: PPUSH
89395: CALL_OW 505
// end ;
89399: LD_VAR 0 2
89403: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
89404: LD_INT 0
89406: PPUSH
89407: PPUSH
89408: PPUSH
89409: PPUSH
// if not hack in hackTanks then
89410: LD_VAR 0 1
89414: PUSH
89415: LD_EXP 89
89419: IN
89420: NOT
89421: IFFALSE 89425
// exit ;
89423: GO 89510
// index := GetElementIndex ( hackTanks , hack ) ;
89425: LD_ADDR_VAR 0 5
89429: PUSH
89430: LD_EXP 89
89434: PPUSH
89435: LD_VAR 0 1
89439: PPUSH
89440: CALL 15489 0 2
89444: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
89445: LD_ADDR_VAR 0 4
89449: PUSH
89450: DOUBLE
89451: LD_INT 1
89453: DEC
89454: ST_TO_ADDR
89455: LD_EXP 90
89459: PUSH
89460: LD_VAR 0 5
89464: ARRAY
89465: PUSH
89466: FOR_TO
89467: IFFALSE 89508
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
89469: LD_EXP 90
89473: PUSH
89474: LD_VAR 0 5
89478: ARRAY
89479: PUSH
89480: LD_VAR 0 4
89484: ARRAY
89485: PUSH
89486: LD_INT 1
89488: ARRAY
89489: PUSH
89490: LD_VAR 0 2
89494: EQUAL
89495: IFFALSE 89506
// KillUnit ( vehicle ) ;
89497: LD_VAR 0 2
89501: PPUSH
89502: CALL_OW 66
89506: GO 89466
89508: POP
89509: POP
// end ;
89510: LD_VAR 0 3
89514: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
89515: LD_EXP 94
89519: NOT
89520: IFFALSE 89555
89522: GO 89524
89524: DISABLE
// begin initMiner := true ;
89525: LD_ADDR_EXP 94
89529: PUSH
89530: LD_INT 1
89532: ST_TO_ADDR
// minersList := [ ] ;
89533: LD_ADDR_EXP 95
89537: PUSH
89538: EMPTY
89539: ST_TO_ADDR
// minerMinesList := [ ] ;
89540: LD_ADDR_EXP 96
89544: PUSH
89545: EMPTY
89546: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
89547: LD_ADDR_EXP 97
89551: PUSH
89552: LD_INT 5
89554: ST_TO_ADDR
// end ;
89555: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
89556: LD_EXP 94
89560: PUSH
89561: LD_INT 34
89563: PUSH
89564: LD_EXP 74
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PPUSH
89573: CALL_OW 69
89577: AND
89578: IFFALSE 90041
89580: GO 89582
89582: DISABLE
89583: LD_INT 0
89585: PPUSH
89586: PPUSH
89587: PPUSH
89588: PPUSH
// begin enable ;
89589: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
89590: LD_ADDR_VAR 0 1
89594: PUSH
89595: LD_INT 34
89597: PUSH
89598: LD_EXP 74
89602: PUSH
89603: EMPTY
89604: LIST
89605: LIST
89606: PPUSH
89607: CALL_OW 69
89611: PUSH
89612: FOR_IN
89613: IFFALSE 89685
// begin if not i in minersList then
89615: LD_VAR 0 1
89619: PUSH
89620: LD_EXP 95
89624: IN
89625: NOT
89626: IFFALSE 89683
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
89628: LD_ADDR_EXP 95
89632: PUSH
89633: LD_EXP 95
89637: PPUSH
89638: LD_EXP 95
89642: PUSH
89643: LD_INT 1
89645: PLUS
89646: PPUSH
89647: LD_VAR 0 1
89651: PPUSH
89652: CALL_OW 1
89656: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
89657: LD_ADDR_EXP 96
89661: PUSH
89662: LD_EXP 96
89666: PPUSH
89667: LD_EXP 96
89671: PUSH
89672: LD_INT 1
89674: PLUS
89675: PPUSH
89676: EMPTY
89677: PPUSH
89678: CALL_OW 1
89682: ST_TO_ADDR
// end end ;
89683: GO 89612
89685: POP
89686: POP
// for i := minerMinesList downto 1 do
89687: LD_ADDR_VAR 0 1
89691: PUSH
89692: DOUBLE
89693: LD_EXP 96
89697: INC
89698: ST_TO_ADDR
89699: LD_INT 1
89701: PUSH
89702: FOR_DOWNTO
89703: IFFALSE 90039
// begin if IsLive ( minersList [ i ] ) then
89705: LD_EXP 95
89709: PUSH
89710: LD_VAR 0 1
89714: ARRAY
89715: PPUSH
89716: CALL_OW 300
89720: IFFALSE 89748
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
89722: LD_EXP 95
89726: PUSH
89727: LD_VAR 0 1
89731: ARRAY
89732: PPUSH
89733: LD_EXP 96
89737: PUSH
89738: LD_VAR 0 1
89742: ARRAY
89743: PPUSH
89744: CALL_OW 505
// if not minerMinesList [ i ] then
89748: LD_EXP 96
89752: PUSH
89753: LD_VAR 0 1
89757: ARRAY
89758: NOT
89759: IFFALSE 89763
// continue ;
89761: GO 89702
// for j := minerMinesList [ i ] downto 1 do
89763: LD_ADDR_VAR 0 2
89767: PUSH
89768: DOUBLE
89769: LD_EXP 96
89773: PUSH
89774: LD_VAR 0 1
89778: ARRAY
89779: INC
89780: ST_TO_ADDR
89781: LD_INT 1
89783: PUSH
89784: FOR_DOWNTO
89785: IFFALSE 90035
// begin side := GetSide ( minersList [ i ] ) ;
89787: LD_ADDR_VAR 0 3
89791: PUSH
89792: LD_EXP 95
89796: PUSH
89797: LD_VAR 0 1
89801: ARRAY
89802: PPUSH
89803: CALL_OW 255
89807: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
89808: LD_ADDR_VAR 0 4
89812: PUSH
89813: LD_EXP 96
89817: PUSH
89818: LD_VAR 0 1
89822: ARRAY
89823: PUSH
89824: LD_VAR 0 2
89828: ARRAY
89829: PUSH
89830: LD_INT 1
89832: ARRAY
89833: PPUSH
89834: LD_EXP 96
89838: PUSH
89839: LD_VAR 0 1
89843: ARRAY
89844: PUSH
89845: LD_VAR 0 2
89849: ARRAY
89850: PUSH
89851: LD_INT 2
89853: ARRAY
89854: PPUSH
89855: CALL_OW 428
89859: ST_TO_ADDR
// if not tmp then
89860: LD_VAR 0 4
89864: NOT
89865: IFFALSE 89869
// continue ;
89867: GO 89784
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
89869: LD_VAR 0 4
89873: PUSH
89874: LD_INT 81
89876: PUSH
89877: LD_VAR 0 3
89881: PUSH
89882: EMPTY
89883: LIST
89884: LIST
89885: PPUSH
89886: CALL_OW 69
89890: IN
89891: PUSH
89892: LD_EXP 96
89896: PUSH
89897: LD_VAR 0 1
89901: ARRAY
89902: PUSH
89903: LD_VAR 0 2
89907: ARRAY
89908: PUSH
89909: LD_INT 1
89911: ARRAY
89912: PPUSH
89913: LD_EXP 96
89917: PUSH
89918: LD_VAR 0 1
89922: ARRAY
89923: PUSH
89924: LD_VAR 0 2
89928: ARRAY
89929: PUSH
89930: LD_INT 2
89932: ARRAY
89933: PPUSH
89934: CALL_OW 458
89938: AND
89939: IFFALSE 90033
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
89941: LD_EXP 96
89945: PUSH
89946: LD_VAR 0 1
89950: ARRAY
89951: PUSH
89952: LD_VAR 0 2
89956: ARRAY
89957: PUSH
89958: LD_INT 1
89960: ARRAY
89961: PPUSH
89962: LD_EXP 96
89966: PUSH
89967: LD_VAR 0 1
89971: ARRAY
89972: PUSH
89973: LD_VAR 0 2
89977: ARRAY
89978: PUSH
89979: LD_INT 2
89981: ARRAY
89982: PPUSH
89983: LD_VAR 0 3
89987: PPUSH
89988: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
89992: LD_ADDR_EXP 96
89996: PUSH
89997: LD_EXP 96
90001: PPUSH
90002: LD_VAR 0 1
90006: PPUSH
90007: LD_EXP 96
90011: PUSH
90012: LD_VAR 0 1
90016: ARRAY
90017: PPUSH
90018: LD_VAR 0 2
90022: PPUSH
90023: CALL_OW 3
90027: PPUSH
90028: CALL_OW 1
90032: ST_TO_ADDR
// end ; end ;
90033: GO 89784
90035: POP
90036: POP
// end ;
90037: GO 89702
90039: POP
90040: POP
// end ;
90041: PPOPN 4
90043: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
90044: LD_INT 0
90046: PPUSH
90047: PPUSH
// result := false ;
90048: LD_ADDR_VAR 0 4
90052: PUSH
90053: LD_INT 0
90055: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
90056: LD_VAR 0 1
90060: PPUSH
90061: CALL_OW 264
90065: PUSH
90066: LD_EXP 74
90070: EQUAL
90071: NOT
90072: IFFALSE 90076
// exit ;
90074: GO 90316
// index := GetElementIndex ( minersList , unit ) ;
90076: LD_ADDR_VAR 0 5
90080: PUSH
90081: LD_EXP 95
90085: PPUSH
90086: LD_VAR 0 1
90090: PPUSH
90091: CALL 15489 0 2
90095: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
90096: LD_EXP 96
90100: PUSH
90101: LD_VAR 0 5
90105: ARRAY
90106: PUSH
90107: LD_EXP 97
90111: GREATEREQUAL
90112: IFFALSE 90116
// exit ;
90114: GO 90316
// ComMoveXY ( unit , x , y ) ;
90116: LD_VAR 0 1
90120: PPUSH
90121: LD_VAR 0 2
90125: PPUSH
90126: LD_VAR 0 3
90130: PPUSH
90131: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
90135: LD_INT 35
90137: PPUSH
90138: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
90142: LD_VAR 0 1
90146: PPUSH
90147: LD_VAR 0 2
90151: PPUSH
90152: LD_VAR 0 3
90156: PPUSH
90157: CALL 46261 0 3
90161: NOT
90162: PUSH
90163: LD_VAR 0 1
90167: PPUSH
90168: CALL_OW 314
90172: AND
90173: IFFALSE 90177
// exit ;
90175: GO 90316
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
90177: LD_VAR 0 2
90181: PPUSH
90182: LD_VAR 0 3
90186: PPUSH
90187: CALL_OW 428
90191: PUSH
90192: LD_VAR 0 1
90196: EQUAL
90197: PUSH
90198: LD_VAR 0 1
90202: PPUSH
90203: CALL_OW 314
90207: NOT
90208: AND
90209: IFFALSE 90135
// PlaySoundXY ( x , y , PlantMine ) ;
90211: LD_VAR 0 2
90215: PPUSH
90216: LD_VAR 0 3
90220: PPUSH
90221: LD_STRING PlantMine
90223: PPUSH
90224: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
90228: LD_VAR 0 2
90232: PPUSH
90233: LD_VAR 0 3
90237: PPUSH
90238: LD_VAR 0 1
90242: PPUSH
90243: CALL_OW 255
90247: PPUSH
90248: LD_INT 0
90250: PPUSH
90251: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
90255: LD_ADDR_EXP 96
90259: PUSH
90260: LD_EXP 96
90264: PPUSH
90265: LD_VAR 0 5
90269: PUSH
90270: LD_EXP 96
90274: PUSH
90275: LD_VAR 0 5
90279: ARRAY
90280: PUSH
90281: LD_INT 1
90283: PLUS
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PPUSH
90289: LD_VAR 0 2
90293: PUSH
90294: LD_VAR 0 3
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PPUSH
90303: CALL 15704 0 3
90307: ST_TO_ADDR
// result := true ;
90308: LD_ADDR_VAR 0 4
90312: PUSH
90313: LD_INT 1
90315: ST_TO_ADDR
// end ;
90316: LD_VAR 0 4
90320: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
90321: LD_INT 0
90323: PPUSH
90324: PPUSH
90325: PPUSH
// if not unit in minersList then
90326: LD_VAR 0 1
90330: PUSH
90331: LD_EXP 95
90335: IN
90336: NOT
90337: IFFALSE 90341
// exit ;
90339: GO 90733
// index := GetElementIndex ( minersList , unit ) ;
90341: LD_ADDR_VAR 0 6
90345: PUSH
90346: LD_EXP 95
90350: PPUSH
90351: LD_VAR 0 1
90355: PPUSH
90356: CALL 15489 0 2
90360: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
90361: LD_ADDR_VAR 0 5
90365: PUSH
90366: DOUBLE
90367: LD_EXP 96
90371: PUSH
90372: LD_VAR 0 6
90376: ARRAY
90377: INC
90378: ST_TO_ADDR
90379: LD_INT 1
90381: PUSH
90382: FOR_DOWNTO
90383: IFFALSE 90544
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
90385: LD_EXP 96
90389: PUSH
90390: LD_VAR 0 6
90394: ARRAY
90395: PUSH
90396: LD_VAR 0 5
90400: ARRAY
90401: PUSH
90402: LD_INT 1
90404: ARRAY
90405: PUSH
90406: LD_VAR 0 2
90410: EQUAL
90411: PUSH
90412: LD_EXP 96
90416: PUSH
90417: LD_VAR 0 6
90421: ARRAY
90422: PUSH
90423: LD_VAR 0 5
90427: ARRAY
90428: PUSH
90429: LD_INT 2
90431: ARRAY
90432: PUSH
90433: LD_VAR 0 3
90437: EQUAL
90438: AND
90439: IFFALSE 90542
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
90441: LD_EXP 96
90445: PUSH
90446: LD_VAR 0 6
90450: ARRAY
90451: PUSH
90452: LD_VAR 0 5
90456: ARRAY
90457: PUSH
90458: LD_INT 1
90460: ARRAY
90461: PPUSH
90462: LD_EXP 96
90466: PUSH
90467: LD_VAR 0 6
90471: ARRAY
90472: PUSH
90473: LD_VAR 0 5
90477: ARRAY
90478: PUSH
90479: LD_INT 2
90481: ARRAY
90482: PPUSH
90483: LD_VAR 0 1
90487: PPUSH
90488: CALL_OW 255
90492: PPUSH
90493: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
90497: LD_ADDR_EXP 96
90501: PUSH
90502: LD_EXP 96
90506: PPUSH
90507: LD_VAR 0 6
90511: PPUSH
90512: LD_EXP 96
90516: PUSH
90517: LD_VAR 0 6
90521: ARRAY
90522: PPUSH
90523: LD_VAR 0 5
90527: PPUSH
90528: CALL_OW 3
90532: PPUSH
90533: CALL_OW 1
90537: ST_TO_ADDR
// exit ;
90538: POP
90539: POP
90540: GO 90733
// end ; end ;
90542: GO 90382
90544: POP
90545: POP
// for i := minerMinesList [ index ] downto 1 do
90546: LD_ADDR_VAR 0 5
90550: PUSH
90551: DOUBLE
90552: LD_EXP 96
90556: PUSH
90557: LD_VAR 0 6
90561: ARRAY
90562: INC
90563: ST_TO_ADDR
90564: LD_INT 1
90566: PUSH
90567: FOR_DOWNTO
90568: IFFALSE 90731
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
90570: LD_EXP 96
90574: PUSH
90575: LD_VAR 0 6
90579: ARRAY
90580: PUSH
90581: LD_VAR 0 5
90585: ARRAY
90586: PUSH
90587: LD_INT 1
90589: ARRAY
90590: PPUSH
90591: LD_EXP 96
90595: PUSH
90596: LD_VAR 0 6
90600: ARRAY
90601: PUSH
90602: LD_VAR 0 5
90606: ARRAY
90607: PUSH
90608: LD_INT 2
90610: ARRAY
90611: PPUSH
90612: LD_VAR 0 2
90616: PPUSH
90617: LD_VAR 0 3
90621: PPUSH
90622: CALL_OW 298
90626: PUSH
90627: LD_INT 6
90629: LESS
90630: IFFALSE 90729
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
90632: LD_EXP 96
90636: PUSH
90637: LD_VAR 0 6
90641: ARRAY
90642: PUSH
90643: LD_VAR 0 5
90647: ARRAY
90648: PUSH
90649: LD_INT 1
90651: ARRAY
90652: PPUSH
90653: LD_EXP 96
90657: PUSH
90658: LD_VAR 0 6
90662: ARRAY
90663: PUSH
90664: LD_VAR 0 5
90668: ARRAY
90669: PUSH
90670: LD_INT 2
90672: ARRAY
90673: PPUSH
90674: LD_VAR 0 1
90678: PPUSH
90679: CALL_OW 255
90683: PPUSH
90684: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
90688: LD_ADDR_EXP 96
90692: PUSH
90693: LD_EXP 96
90697: PPUSH
90698: LD_VAR 0 6
90702: PPUSH
90703: LD_EXP 96
90707: PUSH
90708: LD_VAR 0 6
90712: ARRAY
90713: PPUSH
90714: LD_VAR 0 5
90718: PPUSH
90719: CALL_OW 3
90723: PPUSH
90724: CALL_OW 1
90728: ST_TO_ADDR
// end ; end ;
90729: GO 90567
90731: POP
90732: POP
// end ;
90733: LD_VAR 0 4
90737: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
90738: LD_INT 0
90740: PPUSH
90741: PPUSH
90742: PPUSH
90743: PPUSH
90744: PPUSH
90745: PPUSH
90746: PPUSH
90747: PPUSH
90748: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
90749: LD_VAR 0 1
90753: PPUSH
90754: CALL_OW 264
90758: PUSH
90759: LD_EXP 74
90763: EQUAL
90764: NOT
90765: PUSH
90766: LD_VAR 0 1
90770: PUSH
90771: LD_EXP 95
90775: IN
90776: NOT
90777: OR
90778: IFFALSE 90782
// exit ;
90780: GO 91104
// index := GetElementIndex ( minersList , unit ) ;
90782: LD_ADDR_VAR 0 6
90786: PUSH
90787: LD_EXP 95
90791: PPUSH
90792: LD_VAR 0 1
90796: PPUSH
90797: CALL 15489 0 2
90801: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
90802: LD_ADDR_VAR 0 8
90806: PUSH
90807: LD_EXP 97
90811: PUSH
90812: LD_EXP 96
90816: PUSH
90817: LD_VAR 0 6
90821: ARRAY
90822: MINUS
90823: ST_TO_ADDR
// if not minesFreeAmount then
90824: LD_VAR 0 8
90828: NOT
90829: IFFALSE 90833
// exit ;
90831: GO 91104
// tmp := [ ] ;
90833: LD_ADDR_VAR 0 7
90837: PUSH
90838: EMPTY
90839: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
90840: LD_ADDR_VAR 0 5
90844: PUSH
90845: DOUBLE
90846: LD_INT 1
90848: DEC
90849: ST_TO_ADDR
90850: LD_VAR 0 8
90854: PUSH
90855: FOR_TO
90856: IFFALSE 91051
// begin _d := rand ( 0 , 5 ) ;
90858: LD_ADDR_VAR 0 11
90862: PUSH
90863: LD_INT 0
90865: PPUSH
90866: LD_INT 5
90868: PPUSH
90869: CALL_OW 12
90873: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
90874: LD_ADDR_VAR 0 12
90878: PUSH
90879: LD_INT 2
90881: PPUSH
90882: LD_INT 6
90884: PPUSH
90885: CALL_OW 12
90889: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
90890: LD_ADDR_VAR 0 9
90894: PUSH
90895: LD_VAR 0 2
90899: PPUSH
90900: LD_VAR 0 11
90904: PPUSH
90905: LD_VAR 0 12
90909: PPUSH
90910: CALL_OW 272
90914: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
90915: LD_ADDR_VAR 0 10
90919: PUSH
90920: LD_VAR 0 3
90924: PPUSH
90925: LD_VAR 0 11
90929: PPUSH
90930: LD_VAR 0 12
90934: PPUSH
90935: CALL_OW 273
90939: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
90940: LD_VAR 0 9
90944: PPUSH
90945: LD_VAR 0 10
90949: PPUSH
90950: CALL_OW 488
90954: PUSH
90955: LD_VAR 0 9
90959: PUSH
90960: LD_VAR 0 10
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_VAR 0 7
90973: IN
90974: NOT
90975: AND
90976: PUSH
90977: LD_VAR 0 9
90981: PPUSH
90982: LD_VAR 0 10
90986: PPUSH
90987: CALL_OW 458
90991: NOT
90992: AND
90993: IFFALSE 91035
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
90995: LD_ADDR_VAR 0 7
90999: PUSH
91000: LD_VAR 0 7
91004: PPUSH
91005: LD_VAR 0 7
91009: PUSH
91010: LD_INT 1
91012: PLUS
91013: PPUSH
91014: LD_VAR 0 9
91018: PUSH
91019: LD_VAR 0 10
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PPUSH
91028: CALL_OW 1
91032: ST_TO_ADDR
91033: GO 91049
// i := i - 1 ;
91035: LD_ADDR_VAR 0 5
91039: PUSH
91040: LD_VAR 0 5
91044: PUSH
91045: LD_INT 1
91047: MINUS
91048: ST_TO_ADDR
// end ;
91049: GO 90855
91051: POP
91052: POP
// for i in tmp do
91053: LD_ADDR_VAR 0 5
91057: PUSH
91058: LD_VAR 0 7
91062: PUSH
91063: FOR_IN
91064: IFFALSE 91102
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
91066: LD_VAR 0 1
91070: PPUSH
91071: LD_VAR 0 5
91075: PUSH
91076: LD_INT 1
91078: ARRAY
91079: PPUSH
91080: LD_VAR 0 5
91084: PUSH
91085: LD_INT 2
91087: ARRAY
91088: PPUSH
91089: CALL 90044 0 3
91093: NOT
91094: IFFALSE 91100
// exit ;
91096: POP
91097: POP
91098: GO 91104
91100: GO 91063
91102: POP
91103: POP
// end ;
91104: LD_VAR 0 4
91108: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
91109: LD_INT 0
91111: PPUSH
91112: PPUSH
91113: PPUSH
91114: PPUSH
91115: PPUSH
91116: PPUSH
91117: PPUSH
// if not GetClass ( unit ) = class_sniper then
91118: LD_VAR 0 1
91122: PPUSH
91123: CALL_OW 257
91127: PUSH
91128: LD_INT 5
91130: EQUAL
91131: NOT
91132: IFFALSE 91136
// exit ;
91134: GO 91524
// dist := 8 ;
91136: LD_ADDR_VAR 0 5
91140: PUSH
91141: LD_INT 8
91143: ST_TO_ADDR
// viewRange := 12 ;
91144: LD_ADDR_VAR 0 7
91148: PUSH
91149: LD_INT 12
91151: ST_TO_ADDR
// side := GetSide ( unit ) ;
91152: LD_ADDR_VAR 0 6
91156: PUSH
91157: LD_VAR 0 1
91161: PPUSH
91162: CALL_OW 255
91166: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
91167: LD_INT 61
91169: PPUSH
91170: LD_VAR 0 6
91174: PPUSH
91175: CALL_OW 321
91179: PUSH
91180: LD_INT 2
91182: EQUAL
91183: IFFALSE 91193
// viewRange := 16 ;
91185: LD_ADDR_VAR 0 7
91189: PUSH
91190: LD_INT 16
91192: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
91193: LD_VAR 0 1
91197: PPUSH
91198: LD_VAR 0 2
91202: PPUSH
91203: LD_VAR 0 3
91207: PPUSH
91208: CALL_OW 297
91212: PUSH
91213: LD_VAR 0 5
91217: GREATER
91218: IFFALSE 91297
// begin ComMoveXY ( unit , x , y ) ;
91220: LD_VAR 0 1
91224: PPUSH
91225: LD_VAR 0 2
91229: PPUSH
91230: LD_VAR 0 3
91234: PPUSH
91235: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
91239: LD_INT 35
91241: PPUSH
91242: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
91246: LD_VAR 0 1
91250: PPUSH
91251: LD_VAR 0 2
91255: PPUSH
91256: LD_VAR 0 3
91260: PPUSH
91261: CALL 46261 0 3
91265: NOT
91266: IFFALSE 91270
// exit ;
91268: GO 91524
// until GetDistUnitXY ( unit , x , y ) < dist ;
91270: LD_VAR 0 1
91274: PPUSH
91275: LD_VAR 0 2
91279: PPUSH
91280: LD_VAR 0 3
91284: PPUSH
91285: CALL_OW 297
91289: PUSH
91290: LD_VAR 0 5
91294: LESS
91295: IFFALSE 91239
// end ; ComTurnXY ( unit , x , y ) ;
91297: LD_VAR 0 1
91301: PPUSH
91302: LD_VAR 0 2
91306: PPUSH
91307: LD_VAR 0 3
91311: PPUSH
91312: CALL_OW 118
// wait ( 5 ) ;
91316: LD_INT 5
91318: PPUSH
91319: CALL_OW 67
// _d := GetDir ( unit ) ;
91323: LD_ADDR_VAR 0 10
91327: PUSH
91328: LD_VAR 0 1
91332: PPUSH
91333: CALL_OW 254
91337: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
91338: LD_ADDR_VAR 0 8
91342: PUSH
91343: LD_VAR 0 1
91347: PPUSH
91348: CALL_OW 250
91352: PPUSH
91353: LD_VAR 0 10
91357: PPUSH
91358: LD_VAR 0 5
91362: PPUSH
91363: CALL_OW 272
91367: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
91368: LD_ADDR_VAR 0 9
91372: PUSH
91373: LD_VAR 0 1
91377: PPUSH
91378: CALL_OW 251
91382: PPUSH
91383: LD_VAR 0 10
91387: PPUSH
91388: LD_VAR 0 5
91392: PPUSH
91393: CALL_OW 273
91397: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
91398: LD_VAR 0 8
91402: PPUSH
91403: LD_VAR 0 9
91407: PPUSH
91408: CALL_OW 488
91412: NOT
91413: IFFALSE 91417
// exit ;
91415: GO 91524
// ComAnimCustom ( unit , 1 ) ;
91417: LD_VAR 0 1
91421: PPUSH
91422: LD_INT 1
91424: PPUSH
91425: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
91429: LD_VAR 0 8
91433: PPUSH
91434: LD_VAR 0 9
91438: PPUSH
91439: LD_VAR 0 6
91443: PPUSH
91444: LD_VAR 0 7
91448: PPUSH
91449: CALL_OW 330
// repeat wait ( 1 ) ;
91453: LD_INT 1
91455: PPUSH
91456: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
91460: LD_VAR 0 1
91464: PPUSH
91465: CALL_OW 316
91469: PUSH
91470: LD_VAR 0 1
91474: PPUSH
91475: CALL_OW 314
91479: OR
91480: PUSH
91481: LD_VAR 0 1
91485: PPUSH
91486: CALL_OW 302
91490: NOT
91491: OR
91492: PUSH
91493: LD_VAR 0 1
91497: PPUSH
91498: CALL_OW 301
91502: OR
91503: IFFALSE 91453
// RemoveSeeing ( _x , _y , side ) ;
91505: LD_VAR 0 8
91509: PPUSH
91510: LD_VAR 0 9
91514: PPUSH
91515: LD_VAR 0 6
91519: PPUSH
91520: CALL_OW 331
// end ; end_of_file end_of_file
91524: LD_VAR 0 4
91528: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
91529: LD_VAR 0 1
91533: PUSH
91534: LD_INT 200
91536: DOUBLE
91537: GREATEREQUAL
91538: IFFALSE 91546
91540: LD_INT 299
91542: DOUBLE
91543: LESSEQUAL
91544: IFTRUE 91548
91546: GO 91580
91548: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
91549: LD_VAR 0 1
91553: PPUSH
91554: LD_VAR 0 2
91558: PPUSH
91559: LD_VAR 0 3
91563: PPUSH
91564: LD_VAR 0 4
91568: PPUSH
91569: LD_VAR 0 5
91573: PPUSH
91574: CALL 87646 0 5
91578: GO 91657
91580: LD_INT 300
91582: DOUBLE
91583: GREATEREQUAL
91584: IFFALSE 91592
91586: LD_INT 399
91588: DOUBLE
91589: LESSEQUAL
91590: IFTRUE 91594
91592: GO 91656
91594: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
91595: LD_VAR 0 1
91599: PPUSH
91600: LD_VAR 0 2
91604: PPUSH
91605: LD_VAR 0 3
91609: PPUSH
91610: LD_VAR 0 4
91614: PPUSH
91615: LD_VAR 0 5
91619: PPUSH
91620: LD_VAR 0 6
91624: PPUSH
91625: LD_VAR 0 7
91629: PPUSH
91630: LD_VAR 0 8
91634: PPUSH
91635: LD_VAR 0 9
91639: PPUSH
91640: LD_VAR 0 10
91644: PPUSH
91645: LD_VAR 0 11
91649: PPUSH
91650: CALL 102884 0 11
91654: GO 91657
91656: POP
// end ;
91657: PPOPN 11
91659: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
91660: LD_VAR 0 1
91664: PPUSH
91665: LD_VAR 0 2
91669: PPUSH
91670: LD_VAR 0 3
91674: PPUSH
91675: LD_VAR 0 4
91679: PPUSH
91680: LD_VAR 0 5
91684: PPUSH
91685: CALL 87628 0 5
// end ; end_of_file
91689: PPOPN 5
91691: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91692: LD_INT 0
91694: PPUSH
// if p2 = 100 then
91695: LD_VAR 0 2
91699: PUSH
91700: LD_INT 100
91702: EQUAL
91703: IFFALSE 92652
// begin if not StreamModeActive then
91705: LD_EXP 98
91709: NOT
91710: IFFALSE 91720
// StreamModeActive := true ;
91712: LD_ADDR_EXP 98
91716: PUSH
91717: LD_INT 1
91719: ST_TO_ADDR
// if p3 = 0 then
91720: LD_VAR 0 3
91724: PUSH
91725: LD_INT 0
91727: EQUAL
91728: IFFALSE 91734
// InitStreamMode ;
91730: CALL 92812 0 0
// if p3 = 1 then
91734: LD_VAR 0 3
91738: PUSH
91739: LD_INT 1
91741: EQUAL
91742: IFFALSE 91752
// sRocket := true ;
91744: LD_ADDR_EXP 103
91748: PUSH
91749: LD_INT 1
91751: ST_TO_ADDR
// if p3 = 2 then
91752: LD_VAR 0 3
91756: PUSH
91757: LD_INT 2
91759: EQUAL
91760: IFFALSE 91770
// sSpeed := true ;
91762: LD_ADDR_EXP 102
91766: PUSH
91767: LD_INT 1
91769: ST_TO_ADDR
// if p3 = 3 then
91770: LD_VAR 0 3
91774: PUSH
91775: LD_INT 3
91777: EQUAL
91778: IFFALSE 91788
// sEngine := true ;
91780: LD_ADDR_EXP 104
91784: PUSH
91785: LD_INT 1
91787: ST_TO_ADDR
// if p3 = 4 then
91788: LD_VAR 0 3
91792: PUSH
91793: LD_INT 4
91795: EQUAL
91796: IFFALSE 91806
// sSpec := true ;
91798: LD_ADDR_EXP 101
91802: PUSH
91803: LD_INT 1
91805: ST_TO_ADDR
// if p3 = 5 then
91806: LD_VAR 0 3
91810: PUSH
91811: LD_INT 5
91813: EQUAL
91814: IFFALSE 91824
// sLevel := true ;
91816: LD_ADDR_EXP 105
91820: PUSH
91821: LD_INT 1
91823: ST_TO_ADDR
// if p3 = 6 then
91824: LD_VAR 0 3
91828: PUSH
91829: LD_INT 6
91831: EQUAL
91832: IFFALSE 91842
// sArmoury := true ;
91834: LD_ADDR_EXP 106
91838: PUSH
91839: LD_INT 1
91841: ST_TO_ADDR
// if p3 = 7 then
91842: LD_VAR 0 3
91846: PUSH
91847: LD_INT 7
91849: EQUAL
91850: IFFALSE 91860
// sRadar := true ;
91852: LD_ADDR_EXP 107
91856: PUSH
91857: LD_INT 1
91859: ST_TO_ADDR
// if p3 = 8 then
91860: LD_VAR 0 3
91864: PUSH
91865: LD_INT 8
91867: EQUAL
91868: IFFALSE 91878
// sBunker := true ;
91870: LD_ADDR_EXP 108
91874: PUSH
91875: LD_INT 1
91877: ST_TO_ADDR
// if p3 = 9 then
91878: LD_VAR 0 3
91882: PUSH
91883: LD_INT 9
91885: EQUAL
91886: IFFALSE 91896
// sHack := true ;
91888: LD_ADDR_EXP 109
91892: PUSH
91893: LD_INT 1
91895: ST_TO_ADDR
// if p3 = 10 then
91896: LD_VAR 0 3
91900: PUSH
91901: LD_INT 10
91903: EQUAL
91904: IFFALSE 91914
// sFire := true ;
91906: LD_ADDR_EXP 110
91910: PUSH
91911: LD_INT 1
91913: ST_TO_ADDR
// if p3 = 11 then
91914: LD_VAR 0 3
91918: PUSH
91919: LD_INT 11
91921: EQUAL
91922: IFFALSE 91932
// sRefresh := true ;
91924: LD_ADDR_EXP 111
91928: PUSH
91929: LD_INT 1
91931: ST_TO_ADDR
// if p3 = 12 then
91932: LD_VAR 0 3
91936: PUSH
91937: LD_INT 12
91939: EQUAL
91940: IFFALSE 91950
// sExp := true ;
91942: LD_ADDR_EXP 112
91946: PUSH
91947: LD_INT 1
91949: ST_TO_ADDR
// if p3 = 13 then
91950: LD_VAR 0 3
91954: PUSH
91955: LD_INT 13
91957: EQUAL
91958: IFFALSE 91968
// sDepot := true ;
91960: LD_ADDR_EXP 113
91964: PUSH
91965: LD_INT 1
91967: ST_TO_ADDR
// if p3 = 14 then
91968: LD_VAR 0 3
91972: PUSH
91973: LD_INT 14
91975: EQUAL
91976: IFFALSE 91986
// sFlag := true ;
91978: LD_ADDR_EXP 114
91982: PUSH
91983: LD_INT 1
91985: ST_TO_ADDR
// if p3 = 15 then
91986: LD_VAR 0 3
91990: PUSH
91991: LD_INT 15
91993: EQUAL
91994: IFFALSE 92004
// sKamikadze := true ;
91996: LD_ADDR_EXP 122
92000: PUSH
92001: LD_INT 1
92003: ST_TO_ADDR
// if p3 = 16 then
92004: LD_VAR 0 3
92008: PUSH
92009: LD_INT 16
92011: EQUAL
92012: IFFALSE 92022
// sTroll := true ;
92014: LD_ADDR_EXP 123
92018: PUSH
92019: LD_INT 1
92021: ST_TO_ADDR
// if p3 = 17 then
92022: LD_VAR 0 3
92026: PUSH
92027: LD_INT 17
92029: EQUAL
92030: IFFALSE 92040
// sSlow := true ;
92032: LD_ADDR_EXP 124
92036: PUSH
92037: LD_INT 1
92039: ST_TO_ADDR
// if p3 = 18 then
92040: LD_VAR 0 3
92044: PUSH
92045: LD_INT 18
92047: EQUAL
92048: IFFALSE 92058
// sLack := true ;
92050: LD_ADDR_EXP 125
92054: PUSH
92055: LD_INT 1
92057: ST_TO_ADDR
// if p3 = 19 then
92058: LD_VAR 0 3
92062: PUSH
92063: LD_INT 19
92065: EQUAL
92066: IFFALSE 92076
// sTank := true ;
92068: LD_ADDR_EXP 127
92072: PUSH
92073: LD_INT 1
92075: ST_TO_ADDR
// if p3 = 20 then
92076: LD_VAR 0 3
92080: PUSH
92081: LD_INT 20
92083: EQUAL
92084: IFFALSE 92094
// sRemote := true ;
92086: LD_ADDR_EXP 128
92090: PUSH
92091: LD_INT 1
92093: ST_TO_ADDR
// if p3 = 21 then
92094: LD_VAR 0 3
92098: PUSH
92099: LD_INT 21
92101: EQUAL
92102: IFFALSE 92112
// sPowell := true ;
92104: LD_ADDR_EXP 129
92108: PUSH
92109: LD_INT 1
92111: ST_TO_ADDR
// if p3 = 22 then
92112: LD_VAR 0 3
92116: PUSH
92117: LD_INT 22
92119: EQUAL
92120: IFFALSE 92130
// sTeleport := true ;
92122: LD_ADDR_EXP 132
92126: PUSH
92127: LD_INT 1
92129: ST_TO_ADDR
// if p3 = 23 then
92130: LD_VAR 0 3
92134: PUSH
92135: LD_INT 23
92137: EQUAL
92138: IFFALSE 92148
// sOilTower := true ;
92140: LD_ADDR_EXP 134
92144: PUSH
92145: LD_INT 1
92147: ST_TO_ADDR
// if p3 = 24 then
92148: LD_VAR 0 3
92152: PUSH
92153: LD_INT 24
92155: EQUAL
92156: IFFALSE 92166
// sShovel := true ;
92158: LD_ADDR_EXP 135
92162: PUSH
92163: LD_INT 1
92165: ST_TO_ADDR
// if p3 = 25 then
92166: LD_VAR 0 3
92170: PUSH
92171: LD_INT 25
92173: EQUAL
92174: IFFALSE 92184
// sSheik := true ;
92176: LD_ADDR_EXP 136
92180: PUSH
92181: LD_INT 1
92183: ST_TO_ADDR
// if p3 = 26 then
92184: LD_VAR 0 3
92188: PUSH
92189: LD_INT 26
92191: EQUAL
92192: IFFALSE 92202
// sEarthquake := true ;
92194: LD_ADDR_EXP 138
92198: PUSH
92199: LD_INT 1
92201: ST_TO_ADDR
// if p3 = 27 then
92202: LD_VAR 0 3
92206: PUSH
92207: LD_INT 27
92209: EQUAL
92210: IFFALSE 92220
// sAI := true ;
92212: LD_ADDR_EXP 139
92216: PUSH
92217: LD_INT 1
92219: ST_TO_ADDR
// if p3 = 28 then
92220: LD_VAR 0 3
92224: PUSH
92225: LD_INT 28
92227: EQUAL
92228: IFFALSE 92238
// sCargo := true ;
92230: LD_ADDR_EXP 142
92234: PUSH
92235: LD_INT 1
92237: ST_TO_ADDR
// if p3 = 29 then
92238: LD_VAR 0 3
92242: PUSH
92243: LD_INT 29
92245: EQUAL
92246: IFFALSE 92256
// sDLaser := true ;
92248: LD_ADDR_EXP 143
92252: PUSH
92253: LD_INT 1
92255: ST_TO_ADDR
// if p3 = 30 then
92256: LD_VAR 0 3
92260: PUSH
92261: LD_INT 30
92263: EQUAL
92264: IFFALSE 92274
// sExchange := true ;
92266: LD_ADDR_EXP 144
92270: PUSH
92271: LD_INT 1
92273: ST_TO_ADDR
// if p3 = 31 then
92274: LD_VAR 0 3
92278: PUSH
92279: LD_INT 31
92281: EQUAL
92282: IFFALSE 92292
// sFac := true ;
92284: LD_ADDR_EXP 145
92288: PUSH
92289: LD_INT 1
92291: ST_TO_ADDR
// if p3 = 32 then
92292: LD_VAR 0 3
92296: PUSH
92297: LD_INT 32
92299: EQUAL
92300: IFFALSE 92310
// sPower := true ;
92302: LD_ADDR_EXP 146
92306: PUSH
92307: LD_INT 1
92309: ST_TO_ADDR
// if p3 = 33 then
92310: LD_VAR 0 3
92314: PUSH
92315: LD_INT 33
92317: EQUAL
92318: IFFALSE 92328
// sRandom := true ;
92320: LD_ADDR_EXP 147
92324: PUSH
92325: LD_INT 1
92327: ST_TO_ADDR
// if p3 = 34 then
92328: LD_VAR 0 3
92332: PUSH
92333: LD_INT 34
92335: EQUAL
92336: IFFALSE 92346
// sShield := true ;
92338: LD_ADDR_EXP 148
92342: PUSH
92343: LD_INT 1
92345: ST_TO_ADDR
// if p3 = 35 then
92346: LD_VAR 0 3
92350: PUSH
92351: LD_INT 35
92353: EQUAL
92354: IFFALSE 92364
// sTime := true ;
92356: LD_ADDR_EXP 149
92360: PUSH
92361: LD_INT 1
92363: ST_TO_ADDR
// if p3 = 36 then
92364: LD_VAR 0 3
92368: PUSH
92369: LD_INT 36
92371: EQUAL
92372: IFFALSE 92382
// sTools := true ;
92374: LD_ADDR_EXP 150
92378: PUSH
92379: LD_INT 1
92381: ST_TO_ADDR
// if p3 = 101 then
92382: LD_VAR 0 3
92386: PUSH
92387: LD_INT 101
92389: EQUAL
92390: IFFALSE 92400
// sSold := true ;
92392: LD_ADDR_EXP 115
92396: PUSH
92397: LD_INT 1
92399: ST_TO_ADDR
// if p3 = 102 then
92400: LD_VAR 0 3
92404: PUSH
92405: LD_INT 102
92407: EQUAL
92408: IFFALSE 92418
// sDiff := true ;
92410: LD_ADDR_EXP 116
92414: PUSH
92415: LD_INT 1
92417: ST_TO_ADDR
// if p3 = 103 then
92418: LD_VAR 0 3
92422: PUSH
92423: LD_INT 103
92425: EQUAL
92426: IFFALSE 92436
// sFog := true ;
92428: LD_ADDR_EXP 119
92432: PUSH
92433: LD_INT 1
92435: ST_TO_ADDR
// if p3 = 104 then
92436: LD_VAR 0 3
92440: PUSH
92441: LD_INT 104
92443: EQUAL
92444: IFFALSE 92454
// sReset := true ;
92446: LD_ADDR_EXP 120
92450: PUSH
92451: LD_INT 1
92453: ST_TO_ADDR
// if p3 = 105 then
92454: LD_VAR 0 3
92458: PUSH
92459: LD_INT 105
92461: EQUAL
92462: IFFALSE 92472
// sSun := true ;
92464: LD_ADDR_EXP 121
92468: PUSH
92469: LD_INT 1
92471: ST_TO_ADDR
// if p3 = 106 then
92472: LD_VAR 0 3
92476: PUSH
92477: LD_INT 106
92479: EQUAL
92480: IFFALSE 92490
// sTiger := true ;
92482: LD_ADDR_EXP 117
92486: PUSH
92487: LD_INT 1
92489: ST_TO_ADDR
// if p3 = 107 then
92490: LD_VAR 0 3
92494: PUSH
92495: LD_INT 107
92497: EQUAL
92498: IFFALSE 92508
// sBomb := true ;
92500: LD_ADDR_EXP 118
92504: PUSH
92505: LD_INT 1
92507: ST_TO_ADDR
// if p3 = 108 then
92508: LD_VAR 0 3
92512: PUSH
92513: LD_INT 108
92515: EQUAL
92516: IFFALSE 92526
// sWound := true ;
92518: LD_ADDR_EXP 126
92522: PUSH
92523: LD_INT 1
92525: ST_TO_ADDR
// if p3 = 109 then
92526: LD_VAR 0 3
92530: PUSH
92531: LD_INT 109
92533: EQUAL
92534: IFFALSE 92544
// sBetray := true ;
92536: LD_ADDR_EXP 130
92540: PUSH
92541: LD_INT 1
92543: ST_TO_ADDR
// if p3 = 110 then
92544: LD_VAR 0 3
92548: PUSH
92549: LD_INT 110
92551: EQUAL
92552: IFFALSE 92562
// sContamin := true ;
92554: LD_ADDR_EXP 131
92558: PUSH
92559: LD_INT 1
92561: ST_TO_ADDR
// if p3 = 111 then
92562: LD_VAR 0 3
92566: PUSH
92567: LD_INT 111
92569: EQUAL
92570: IFFALSE 92580
// sOil := true ;
92572: LD_ADDR_EXP 133
92576: PUSH
92577: LD_INT 1
92579: ST_TO_ADDR
// if p3 = 112 then
92580: LD_VAR 0 3
92584: PUSH
92585: LD_INT 112
92587: EQUAL
92588: IFFALSE 92598
// sStu := true ;
92590: LD_ADDR_EXP 137
92594: PUSH
92595: LD_INT 1
92597: ST_TO_ADDR
// if p3 = 113 then
92598: LD_VAR 0 3
92602: PUSH
92603: LD_INT 113
92605: EQUAL
92606: IFFALSE 92616
// sBazooka := true ;
92608: LD_ADDR_EXP 140
92612: PUSH
92613: LD_INT 1
92615: ST_TO_ADDR
// if p3 = 114 then
92616: LD_VAR 0 3
92620: PUSH
92621: LD_INT 114
92623: EQUAL
92624: IFFALSE 92634
// sMortar := true ;
92626: LD_ADDR_EXP 141
92630: PUSH
92631: LD_INT 1
92633: ST_TO_ADDR
// if p3 = 115 then
92634: LD_VAR 0 3
92638: PUSH
92639: LD_INT 115
92641: EQUAL
92642: IFFALSE 92652
// sRanger := true ;
92644: LD_ADDR_EXP 151
92648: PUSH
92649: LD_INT 1
92651: ST_TO_ADDR
// end ; if p2 = 101 then
92652: LD_VAR 0 2
92656: PUSH
92657: LD_INT 101
92659: EQUAL
92660: IFFALSE 92788
// begin case p3 of 1 :
92662: LD_VAR 0 3
92666: PUSH
92667: LD_INT 1
92669: DOUBLE
92670: EQUAL
92671: IFTRUE 92675
92673: GO 92682
92675: POP
// hHackUnlimitedResources ; 2 :
92676: CALL 103825 0 0
92680: GO 92788
92682: LD_INT 2
92684: DOUBLE
92685: EQUAL
92686: IFTRUE 92690
92688: GO 92697
92690: POP
// hHackSetLevel10 ; 3 :
92691: CALL 103958 0 0
92695: GO 92788
92697: LD_INT 3
92699: DOUBLE
92700: EQUAL
92701: IFTRUE 92705
92703: GO 92712
92705: POP
// hHackSetLevel10YourUnits ; 4 :
92706: CALL 104043 0 0
92710: GO 92788
92712: LD_INT 4
92714: DOUBLE
92715: EQUAL
92716: IFTRUE 92720
92718: GO 92727
92720: POP
// hHackInvincible ; 5 :
92721: CALL 104491 0 0
92725: GO 92788
92727: LD_INT 5
92729: DOUBLE
92730: EQUAL
92731: IFTRUE 92735
92733: GO 92742
92735: POP
// hHackInvisible ; 6 :
92736: CALL 104602 0 0
92740: GO 92788
92742: LD_INT 6
92744: DOUBLE
92745: EQUAL
92746: IFTRUE 92750
92748: GO 92757
92750: POP
// hHackChangeYourSide ; 7 :
92751: CALL 104659 0 0
92755: GO 92788
92757: LD_INT 7
92759: DOUBLE
92760: EQUAL
92761: IFTRUE 92765
92763: GO 92772
92765: POP
// hHackChangeUnitSide ; 8 :
92766: CALL 104701 0 0
92770: GO 92788
92772: LD_INT 8
92774: DOUBLE
92775: EQUAL
92776: IFTRUE 92780
92778: GO 92787
92780: POP
// hHackFog ; end ;
92781: CALL 104802 0 0
92785: GO 92788
92787: POP
// end ; end ;
92788: LD_VAR 0 7
92792: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
92793: GO 92795
92795: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
92796: LD_STRING initStreamRollete();
92798: PPUSH
92799: CALL_OW 559
// InitStreamMode ;
92803: CALL 92812 0 0
// DefineStreamItems ( ) ;
92807: CALL 93252 0 0
// end ;
92811: END
// function InitStreamMode ; begin
92812: LD_INT 0
92814: PPUSH
// streamModeActive := false ;
92815: LD_ADDR_EXP 98
92819: PUSH
92820: LD_INT 0
92822: ST_TO_ADDR
// normalCounter := 36 ;
92823: LD_ADDR_EXP 99
92827: PUSH
92828: LD_INT 36
92830: ST_TO_ADDR
// hardcoreCounter := 16 ;
92831: LD_ADDR_EXP 100
92835: PUSH
92836: LD_INT 16
92838: ST_TO_ADDR
// sRocket := false ;
92839: LD_ADDR_EXP 103
92843: PUSH
92844: LD_INT 0
92846: ST_TO_ADDR
// sSpeed := false ;
92847: LD_ADDR_EXP 102
92851: PUSH
92852: LD_INT 0
92854: ST_TO_ADDR
// sEngine := false ;
92855: LD_ADDR_EXP 104
92859: PUSH
92860: LD_INT 0
92862: ST_TO_ADDR
// sSpec := false ;
92863: LD_ADDR_EXP 101
92867: PUSH
92868: LD_INT 0
92870: ST_TO_ADDR
// sLevel := false ;
92871: LD_ADDR_EXP 105
92875: PUSH
92876: LD_INT 0
92878: ST_TO_ADDR
// sArmoury := false ;
92879: LD_ADDR_EXP 106
92883: PUSH
92884: LD_INT 0
92886: ST_TO_ADDR
// sRadar := false ;
92887: LD_ADDR_EXP 107
92891: PUSH
92892: LD_INT 0
92894: ST_TO_ADDR
// sBunker := false ;
92895: LD_ADDR_EXP 108
92899: PUSH
92900: LD_INT 0
92902: ST_TO_ADDR
// sHack := false ;
92903: LD_ADDR_EXP 109
92907: PUSH
92908: LD_INT 0
92910: ST_TO_ADDR
// sFire := false ;
92911: LD_ADDR_EXP 110
92915: PUSH
92916: LD_INT 0
92918: ST_TO_ADDR
// sRefresh := false ;
92919: LD_ADDR_EXP 111
92923: PUSH
92924: LD_INT 0
92926: ST_TO_ADDR
// sExp := false ;
92927: LD_ADDR_EXP 112
92931: PUSH
92932: LD_INT 0
92934: ST_TO_ADDR
// sDepot := false ;
92935: LD_ADDR_EXP 113
92939: PUSH
92940: LD_INT 0
92942: ST_TO_ADDR
// sFlag := false ;
92943: LD_ADDR_EXP 114
92947: PUSH
92948: LD_INT 0
92950: ST_TO_ADDR
// sKamikadze := false ;
92951: LD_ADDR_EXP 122
92955: PUSH
92956: LD_INT 0
92958: ST_TO_ADDR
// sTroll := false ;
92959: LD_ADDR_EXP 123
92963: PUSH
92964: LD_INT 0
92966: ST_TO_ADDR
// sSlow := false ;
92967: LD_ADDR_EXP 124
92971: PUSH
92972: LD_INT 0
92974: ST_TO_ADDR
// sLack := false ;
92975: LD_ADDR_EXP 125
92979: PUSH
92980: LD_INT 0
92982: ST_TO_ADDR
// sTank := false ;
92983: LD_ADDR_EXP 127
92987: PUSH
92988: LD_INT 0
92990: ST_TO_ADDR
// sRemote := false ;
92991: LD_ADDR_EXP 128
92995: PUSH
92996: LD_INT 0
92998: ST_TO_ADDR
// sPowell := false ;
92999: LD_ADDR_EXP 129
93003: PUSH
93004: LD_INT 0
93006: ST_TO_ADDR
// sTeleport := false ;
93007: LD_ADDR_EXP 132
93011: PUSH
93012: LD_INT 0
93014: ST_TO_ADDR
// sOilTower := false ;
93015: LD_ADDR_EXP 134
93019: PUSH
93020: LD_INT 0
93022: ST_TO_ADDR
// sShovel := false ;
93023: LD_ADDR_EXP 135
93027: PUSH
93028: LD_INT 0
93030: ST_TO_ADDR
// sSheik := false ;
93031: LD_ADDR_EXP 136
93035: PUSH
93036: LD_INT 0
93038: ST_TO_ADDR
// sEarthquake := false ;
93039: LD_ADDR_EXP 138
93043: PUSH
93044: LD_INT 0
93046: ST_TO_ADDR
// sAI := false ;
93047: LD_ADDR_EXP 139
93051: PUSH
93052: LD_INT 0
93054: ST_TO_ADDR
// sCargo := false ;
93055: LD_ADDR_EXP 142
93059: PUSH
93060: LD_INT 0
93062: ST_TO_ADDR
// sDLaser := false ;
93063: LD_ADDR_EXP 143
93067: PUSH
93068: LD_INT 0
93070: ST_TO_ADDR
// sExchange := false ;
93071: LD_ADDR_EXP 144
93075: PUSH
93076: LD_INT 0
93078: ST_TO_ADDR
// sFac := false ;
93079: LD_ADDR_EXP 145
93083: PUSH
93084: LD_INT 0
93086: ST_TO_ADDR
// sPower := false ;
93087: LD_ADDR_EXP 146
93091: PUSH
93092: LD_INT 0
93094: ST_TO_ADDR
// sRandom := false ;
93095: LD_ADDR_EXP 147
93099: PUSH
93100: LD_INT 0
93102: ST_TO_ADDR
// sShield := false ;
93103: LD_ADDR_EXP 148
93107: PUSH
93108: LD_INT 0
93110: ST_TO_ADDR
// sTime := false ;
93111: LD_ADDR_EXP 149
93115: PUSH
93116: LD_INT 0
93118: ST_TO_ADDR
// sTools := false ;
93119: LD_ADDR_EXP 150
93123: PUSH
93124: LD_INT 0
93126: ST_TO_ADDR
// sSold := false ;
93127: LD_ADDR_EXP 115
93131: PUSH
93132: LD_INT 0
93134: ST_TO_ADDR
// sDiff := false ;
93135: LD_ADDR_EXP 116
93139: PUSH
93140: LD_INT 0
93142: ST_TO_ADDR
// sFog := false ;
93143: LD_ADDR_EXP 119
93147: PUSH
93148: LD_INT 0
93150: ST_TO_ADDR
// sReset := false ;
93151: LD_ADDR_EXP 120
93155: PUSH
93156: LD_INT 0
93158: ST_TO_ADDR
// sSun := false ;
93159: LD_ADDR_EXP 121
93163: PUSH
93164: LD_INT 0
93166: ST_TO_ADDR
// sTiger := false ;
93167: LD_ADDR_EXP 117
93171: PUSH
93172: LD_INT 0
93174: ST_TO_ADDR
// sBomb := false ;
93175: LD_ADDR_EXP 118
93179: PUSH
93180: LD_INT 0
93182: ST_TO_ADDR
// sWound := false ;
93183: LD_ADDR_EXP 126
93187: PUSH
93188: LD_INT 0
93190: ST_TO_ADDR
// sBetray := false ;
93191: LD_ADDR_EXP 130
93195: PUSH
93196: LD_INT 0
93198: ST_TO_ADDR
// sContamin := false ;
93199: LD_ADDR_EXP 131
93203: PUSH
93204: LD_INT 0
93206: ST_TO_ADDR
// sOil := false ;
93207: LD_ADDR_EXP 133
93211: PUSH
93212: LD_INT 0
93214: ST_TO_ADDR
// sStu := false ;
93215: LD_ADDR_EXP 137
93219: PUSH
93220: LD_INT 0
93222: ST_TO_ADDR
// sBazooka := false ;
93223: LD_ADDR_EXP 140
93227: PUSH
93228: LD_INT 0
93230: ST_TO_ADDR
// sMortar := false ;
93231: LD_ADDR_EXP 141
93235: PUSH
93236: LD_INT 0
93238: ST_TO_ADDR
// sRanger := false ;
93239: LD_ADDR_EXP 151
93243: PUSH
93244: LD_INT 0
93246: ST_TO_ADDR
// end ;
93247: LD_VAR 0 1
93251: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
93252: LD_INT 0
93254: PPUSH
93255: PPUSH
93256: PPUSH
93257: PPUSH
93258: PPUSH
// result := [ ] ;
93259: LD_ADDR_VAR 0 1
93263: PUSH
93264: EMPTY
93265: ST_TO_ADDR
// if campaign_id = 1 then
93266: LD_OWVAR 69
93270: PUSH
93271: LD_INT 1
93273: EQUAL
93274: IFFALSE 96212
// begin case mission_number of 1 :
93276: LD_OWVAR 70
93280: PUSH
93281: LD_INT 1
93283: DOUBLE
93284: EQUAL
93285: IFTRUE 93289
93287: GO 93353
93289: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
93290: LD_ADDR_VAR 0 1
93294: PUSH
93295: LD_INT 2
93297: PUSH
93298: LD_INT 4
93300: PUSH
93301: LD_INT 11
93303: PUSH
93304: LD_INT 12
93306: PUSH
93307: LD_INT 15
93309: PUSH
93310: LD_INT 16
93312: PUSH
93313: LD_INT 22
93315: PUSH
93316: LD_INT 23
93318: PUSH
93319: LD_INT 26
93321: PUSH
93322: EMPTY
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: PUSH
93333: LD_INT 101
93335: PUSH
93336: LD_INT 102
93338: PUSH
93339: LD_INT 106
93341: PUSH
93342: EMPTY
93343: LIST
93344: LIST
93345: LIST
93346: PUSH
93347: EMPTY
93348: LIST
93349: LIST
93350: ST_TO_ADDR
93351: GO 96210
93353: LD_INT 2
93355: DOUBLE
93356: EQUAL
93357: IFTRUE 93361
93359: GO 93433
93361: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
93362: LD_ADDR_VAR 0 1
93366: PUSH
93367: LD_INT 2
93369: PUSH
93370: LD_INT 4
93372: PUSH
93373: LD_INT 11
93375: PUSH
93376: LD_INT 12
93378: PUSH
93379: LD_INT 15
93381: PUSH
93382: LD_INT 16
93384: PUSH
93385: LD_INT 22
93387: PUSH
93388: LD_INT 23
93390: PUSH
93391: LD_INT 26
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: PUSH
93405: LD_INT 101
93407: PUSH
93408: LD_INT 102
93410: PUSH
93411: LD_INT 105
93413: PUSH
93414: LD_INT 106
93416: PUSH
93417: LD_INT 108
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: ST_TO_ADDR
93431: GO 96210
93433: LD_INT 3
93435: DOUBLE
93436: EQUAL
93437: IFTRUE 93441
93439: GO 93517
93441: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
93442: LD_ADDR_VAR 0 1
93446: PUSH
93447: LD_INT 2
93449: PUSH
93450: LD_INT 4
93452: PUSH
93453: LD_INT 5
93455: PUSH
93456: LD_INT 11
93458: PUSH
93459: LD_INT 12
93461: PUSH
93462: LD_INT 15
93464: PUSH
93465: LD_INT 16
93467: PUSH
93468: LD_INT 22
93470: PUSH
93471: LD_INT 26
93473: PUSH
93474: LD_INT 36
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: PUSH
93489: LD_INT 101
93491: PUSH
93492: LD_INT 102
93494: PUSH
93495: LD_INT 105
93497: PUSH
93498: LD_INT 106
93500: PUSH
93501: LD_INT 108
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: PUSH
93511: EMPTY
93512: LIST
93513: LIST
93514: ST_TO_ADDR
93515: GO 96210
93517: LD_INT 4
93519: DOUBLE
93520: EQUAL
93521: IFTRUE 93525
93523: GO 93609
93525: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
93526: LD_ADDR_VAR 0 1
93530: PUSH
93531: LD_INT 2
93533: PUSH
93534: LD_INT 4
93536: PUSH
93537: LD_INT 5
93539: PUSH
93540: LD_INT 8
93542: PUSH
93543: LD_INT 11
93545: PUSH
93546: LD_INT 12
93548: PUSH
93549: LD_INT 15
93551: PUSH
93552: LD_INT 16
93554: PUSH
93555: LD_INT 22
93557: PUSH
93558: LD_INT 23
93560: PUSH
93561: LD_INT 26
93563: PUSH
93564: LD_INT 36
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: PUSH
93581: LD_INT 101
93583: PUSH
93584: LD_INT 102
93586: PUSH
93587: LD_INT 105
93589: PUSH
93590: LD_INT 106
93592: PUSH
93593: LD_INT 108
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: ST_TO_ADDR
93607: GO 96210
93609: LD_INT 5
93611: DOUBLE
93612: EQUAL
93613: IFTRUE 93617
93615: GO 93717
93617: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
93618: LD_ADDR_VAR 0 1
93622: PUSH
93623: LD_INT 2
93625: PUSH
93626: LD_INT 4
93628: PUSH
93629: LD_INT 5
93631: PUSH
93632: LD_INT 6
93634: PUSH
93635: LD_INT 8
93637: PUSH
93638: LD_INT 11
93640: PUSH
93641: LD_INT 12
93643: PUSH
93644: LD_INT 15
93646: PUSH
93647: LD_INT 16
93649: PUSH
93650: LD_INT 22
93652: PUSH
93653: LD_INT 23
93655: PUSH
93656: LD_INT 25
93658: PUSH
93659: LD_INT 26
93661: PUSH
93662: LD_INT 36
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: LIST
93669: LIST
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: PUSH
93681: LD_INT 101
93683: PUSH
93684: LD_INT 102
93686: PUSH
93687: LD_INT 105
93689: PUSH
93690: LD_INT 106
93692: PUSH
93693: LD_INT 108
93695: PUSH
93696: LD_INT 109
93698: PUSH
93699: LD_INT 112
93701: PUSH
93702: EMPTY
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: ST_TO_ADDR
93715: GO 96210
93717: LD_INT 6
93719: DOUBLE
93720: EQUAL
93721: IFTRUE 93725
93723: GO 93845
93725: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
93726: LD_ADDR_VAR 0 1
93730: PUSH
93731: LD_INT 2
93733: PUSH
93734: LD_INT 4
93736: PUSH
93737: LD_INT 5
93739: PUSH
93740: LD_INT 6
93742: PUSH
93743: LD_INT 8
93745: PUSH
93746: LD_INT 11
93748: PUSH
93749: LD_INT 12
93751: PUSH
93752: LD_INT 15
93754: PUSH
93755: LD_INT 16
93757: PUSH
93758: LD_INT 20
93760: PUSH
93761: LD_INT 21
93763: PUSH
93764: LD_INT 22
93766: PUSH
93767: LD_INT 23
93769: PUSH
93770: LD_INT 25
93772: PUSH
93773: LD_INT 26
93775: PUSH
93776: LD_INT 30
93778: PUSH
93779: LD_INT 31
93781: PUSH
93782: LD_INT 32
93784: PUSH
93785: LD_INT 36
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 101
93811: PUSH
93812: LD_INT 102
93814: PUSH
93815: LD_INT 105
93817: PUSH
93818: LD_INT 106
93820: PUSH
93821: LD_INT 108
93823: PUSH
93824: LD_INT 109
93826: PUSH
93827: LD_INT 112
93829: PUSH
93830: EMPTY
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: ST_TO_ADDR
93843: GO 96210
93845: LD_INT 7
93847: DOUBLE
93848: EQUAL
93849: IFTRUE 93853
93851: GO 93953
93853: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
93854: LD_ADDR_VAR 0 1
93858: PUSH
93859: LD_INT 2
93861: PUSH
93862: LD_INT 4
93864: PUSH
93865: LD_INT 5
93867: PUSH
93868: LD_INT 7
93870: PUSH
93871: LD_INT 11
93873: PUSH
93874: LD_INT 12
93876: PUSH
93877: LD_INT 15
93879: PUSH
93880: LD_INT 16
93882: PUSH
93883: LD_INT 20
93885: PUSH
93886: LD_INT 21
93888: PUSH
93889: LD_INT 22
93891: PUSH
93892: LD_INT 23
93894: PUSH
93895: LD_INT 25
93897: PUSH
93898: LD_INT 26
93900: PUSH
93901: EMPTY
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: PUSH
93917: LD_INT 101
93919: PUSH
93920: LD_INT 102
93922: PUSH
93923: LD_INT 103
93925: PUSH
93926: LD_INT 105
93928: PUSH
93929: LD_INT 106
93931: PUSH
93932: LD_INT 108
93934: PUSH
93935: LD_INT 112
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: PUSH
93947: EMPTY
93948: LIST
93949: LIST
93950: ST_TO_ADDR
93951: GO 96210
93953: LD_INT 8
93955: DOUBLE
93956: EQUAL
93957: IFTRUE 93961
93959: GO 94089
93961: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
93962: LD_ADDR_VAR 0 1
93966: PUSH
93967: LD_INT 2
93969: PUSH
93970: LD_INT 4
93972: PUSH
93973: LD_INT 5
93975: PUSH
93976: LD_INT 6
93978: PUSH
93979: LD_INT 7
93981: PUSH
93982: LD_INT 8
93984: PUSH
93985: LD_INT 11
93987: PUSH
93988: LD_INT 12
93990: PUSH
93991: LD_INT 15
93993: PUSH
93994: LD_INT 16
93996: PUSH
93997: LD_INT 20
93999: PUSH
94000: LD_INT 21
94002: PUSH
94003: LD_INT 22
94005: PUSH
94006: LD_INT 23
94008: PUSH
94009: LD_INT 25
94011: PUSH
94012: LD_INT 26
94014: PUSH
94015: LD_INT 30
94017: PUSH
94018: LD_INT 31
94020: PUSH
94021: LD_INT 32
94023: PUSH
94024: LD_INT 36
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 101
94051: PUSH
94052: LD_INT 102
94054: PUSH
94055: LD_INT 103
94057: PUSH
94058: LD_INT 105
94060: PUSH
94061: LD_INT 106
94063: PUSH
94064: LD_INT 108
94066: PUSH
94067: LD_INT 109
94069: PUSH
94070: LD_INT 112
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: PUSH
94083: EMPTY
94084: LIST
94085: LIST
94086: ST_TO_ADDR
94087: GO 96210
94089: LD_INT 9
94091: DOUBLE
94092: EQUAL
94093: IFTRUE 94097
94095: GO 94233
94097: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
94098: LD_ADDR_VAR 0 1
94102: PUSH
94103: LD_INT 2
94105: PUSH
94106: LD_INT 4
94108: PUSH
94109: LD_INT 5
94111: PUSH
94112: LD_INT 6
94114: PUSH
94115: LD_INT 7
94117: PUSH
94118: LD_INT 8
94120: PUSH
94121: LD_INT 11
94123: PUSH
94124: LD_INT 12
94126: PUSH
94127: LD_INT 15
94129: PUSH
94130: LD_INT 16
94132: PUSH
94133: LD_INT 20
94135: PUSH
94136: LD_INT 21
94138: PUSH
94139: LD_INT 22
94141: PUSH
94142: LD_INT 23
94144: PUSH
94145: LD_INT 25
94147: PUSH
94148: LD_INT 26
94150: PUSH
94151: LD_INT 28
94153: PUSH
94154: LD_INT 30
94156: PUSH
94157: LD_INT 31
94159: PUSH
94160: LD_INT 32
94162: PUSH
94163: LD_INT 36
94165: PUSH
94166: EMPTY
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: LIST
94188: PUSH
94189: LD_INT 101
94191: PUSH
94192: LD_INT 102
94194: PUSH
94195: LD_INT 103
94197: PUSH
94198: LD_INT 105
94200: PUSH
94201: LD_INT 106
94203: PUSH
94204: LD_INT 108
94206: PUSH
94207: LD_INT 109
94209: PUSH
94210: LD_INT 112
94212: PUSH
94213: LD_INT 114
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: ST_TO_ADDR
94231: GO 96210
94233: LD_INT 10
94235: DOUBLE
94236: EQUAL
94237: IFTRUE 94241
94239: GO 94425
94241: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
94242: LD_ADDR_VAR 0 1
94246: PUSH
94247: LD_INT 2
94249: PUSH
94250: LD_INT 4
94252: PUSH
94253: LD_INT 5
94255: PUSH
94256: LD_INT 6
94258: PUSH
94259: LD_INT 7
94261: PUSH
94262: LD_INT 8
94264: PUSH
94265: LD_INT 9
94267: PUSH
94268: LD_INT 10
94270: PUSH
94271: LD_INT 11
94273: PUSH
94274: LD_INT 12
94276: PUSH
94277: LD_INT 13
94279: PUSH
94280: LD_INT 14
94282: PUSH
94283: LD_INT 15
94285: PUSH
94286: LD_INT 16
94288: PUSH
94289: LD_INT 17
94291: PUSH
94292: LD_INT 18
94294: PUSH
94295: LD_INT 19
94297: PUSH
94298: LD_INT 20
94300: PUSH
94301: LD_INT 21
94303: PUSH
94304: LD_INT 22
94306: PUSH
94307: LD_INT 23
94309: PUSH
94310: LD_INT 24
94312: PUSH
94313: LD_INT 25
94315: PUSH
94316: LD_INT 26
94318: PUSH
94319: LD_INT 28
94321: PUSH
94322: LD_INT 30
94324: PUSH
94325: LD_INT 31
94327: PUSH
94328: LD_INT 32
94330: PUSH
94331: LD_INT 36
94333: PUSH
94334: EMPTY
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 101
94367: PUSH
94368: LD_INT 102
94370: PUSH
94371: LD_INT 103
94373: PUSH
94374: LD_INT 104
94376: PUSH
94377: LD_INT 105
94379: PUSH
94380: LD_INT 106
94382: PUSH
94383: LD_INT 107
94385: PUSH
94386: LD_INT 108
94388: PUSH
94389: LD_INT 109
94391: PUSH
94392: LD_INT 110
94394: PUSH
94395: LD_INT 111
94397: PUSH
94398: LD_INT 112
94400: PUSH
94401: LD_INT 114
94403: PUSH
94404: EMPTY
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: PUSH
94419: EMPTY
94420: LIST
94421: LIST
94422: ST_TO_ADDR
94423: GO 96210
94425: LD_INT 11
94427: DOUBLE
94428: EQUAL
94429: IFTRUE 94433
94431: GO 94625
94433: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
94434: LD_ADDR_VAR 0 1
94438: PUSH
94439: LD_INT 2
94441: PUSH
94442: LD_INT 3
94444: PUSH
94445: LD_INT 4
94447: PUSH
94448: LD_INT 5
94450: PUSH
94451: LD_INT 6
94453: PUSH
94454: LD_INT 7
94456: PUSH
94457: LD_INT 8
94459: PUSH
94460: LD_INT 9
94462: PUSH
94463: LD_INT 10
94465: PUSH
94466: LD_INT 11
94468: PUSH
94469: LD_INT 12
94471: PUSH
94472: LD_INT 13
94474: PUSH
94475: LD_INT 14
94477: PUSH
94478: LD_INT 15
94480: PUSH
94481: LD_INT 16
94483: PUSH
94484: LD_INT 17
94486: PUSH
94487: LD_INT 18
94489: PUSH
94490: LD_INT 19
94492: PUSH
94493: LD_INT 20
94495: PUSH
94496: LD_INT 21
94498: PUSH
94499: LD_INT 22
94501: PUSH
94502: LD_INT 23
94504: PUSH
94505: LD_INT 24
94507: PUSH
94508: LD_INT 25
94510: PUSH
94511: LD_INT 26
94513: PUSH
94514: LD_INT 28
94516: PUSH
94517: LD_INT 30
94519: PUSH
94520: LD_INT 31
94522: PUSH
94523: LD_INT 32
94525: PUSH
94526: LD_INT 34
94528: PUSH
94529: LD_INT 36
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 101
94567: PUSH
94568: LD_INT 102
94570: PUSH
94571: LD_INT 103
94573: PUSH
94574: LD_INT 104
94576: PUSH
94577: LD_INT 105
94579: PUSH
94580: LD_INT 106
94582: PUSH
94583: LD_INT 107
94585: PUSH
94586: LD_INT 108
94588: PUSH
94589: LD_INT 109
94591: PUSH
94592: LD_INT 110
94594: PUSH
94595: LD_INT 111
94597: PUSH
94598: LD_INT 112
94600: PUSH
94601: LD_INT 114
94603: PUSH
94604: EMPTY
94605: LIST
94606: LIST
94607: LIST
94608: LIST
94609: LIST
94610: LIST
94611: LIST
94612: LIST
94613: LIST
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: ST_TO_ADDR
94623: GO 96210
94625: LD_INT 12
94627: DOUBLE
94628: EQUAL
94629: IFTRUE 94633
94631: GO 94841
94633: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
94634: LD_ADDR_VAR 0 1
94638: PUSH
94639: LD_INT 1
94641: PUSH
94642: LD_INT 2
94644: PUSH
94645: LD_INT 3
94647: PUSH
94648: LD_INT 4
94650: PUSH
94651: LD_INT 5
94653: PUSH
94654: LD_INT 6
94656: PUSH
94657: LD_INT 7
94659: PUSH
94660: LD_INT 8
94662: PUSH
94663: LD_INT 9
94665: PUSH
94666: LD_INT 10
94668: PUSH
94669: LD_INT 11
94671: PUSH
94672: LD_INT 12
94674: PUSH
94675: LD_INT 13
94677: PUSH
94678: LD_INT 14
94680: PUSH
94681: LD_INT 15
94683: PUSH
94684: LD_INT 16
94686: PUSH
94687: LD_INT 17
94689: PUSH
94690: LD_INT 18
94692: PUSH
94693: LD_INT 19
94695: PUSH
94696: LD_INT 20
94698: PUSH
94699: LD_INT 21
94701: PUSH
94702: LD_INT 22
94704: PUSH
94705: LD_INT 23
94707: PUSH
94708: LD_INT 24
94710: PUSH
94711: LD_INT 25
94713: PUSH
94714: LD_INT 26
94716: PUSH
94717: LD_INT 27
94719: PUSH
94720: LD_INT 28
94722: PUSH
94723: LD_INT 30
94725: PUSH
94726: LD_INT 31
94728: PUSH
94729: LD_INT 32
94731: PUSH
94732: LD_INT 33
94734: PUSH
94735: LD_INT 34
94737: PUSH
94738: LD_INT 36
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: PUSH
94777: LD_INT 101
94779: PUSH
94780: LD_INT 102
94782: PUSH
94783: LD_INT 103
94785: PUSH
94786: LD_INT 104
94788: PUSH
94789: LD_INT 105
94791: PUSH
94792: LD_INT 106
94794: PUSH
94795: LD_INT 107
94797: PUSH
94798: LD_INT 108
94800: PUSH
94801: LD_INT 109
94803: PUSH
94804: LD_INT 110
94806: PUSH
94807: LD_INT 111
94809: PUSH
94810: LD_INT 112
94812: PUSH
94813: LD_INT 113
94815: PUSH
94816: LD_INT 114
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: PUSH
94835: EMPTY
94836: LIST
94837: LIST
94838: ST_TO_ADDR
94839: GO 96210
94841: LD_INT 13
94843: DOUBLE
94844: EQUAL
94845: IFTRUE 94849
94847: GO 95045
94849: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
94850: LD_ADDR_VAR 0 1
94854: PUSH
94855: LD_INT 1
94857: PUSH
94858: LD_INT 2
94860: PUSH
94861: LD_INT 3
94863: PUSH
94864: LD_INT 4
94866: PUSH
94867: LD_INT 5
94869: PUSH
94870: LD_INT 8
94872: PUSH
94873: LD_INT 9
94875: PUSH
94876: LD_INT 10
94878: PUSH
94879: LD_INT 11
94881: PUSH
94882: LD_INT 12
94884: PUSH
94885: LD_INT 14
94887: PUSH
94888: LD_INT 15
94890: PUSH
94891: LD_INT 16
94893: PUSH
94894: LD_INT 17
94896: PUSH
94897: LD_INT 18
94899: PUSH
94900: LD_INT 19
94902: PUSH
94903: LD_INT 20
94905: PUSH
94906: LD_INT 21
94908: PUSH
94909: LD_INT 22
94911: PUSH
94912: LD_INT 23
94914: PUSH
94915: LD_INT 24
94917: PUSH
94918: LD_INT 25
94920: PUSH
94921: LD_INT 26
94923: PUSH
94924: LD_INT 27
94926: PUSH
94927: LD_INT 28
94929: PUSH
94930: LD_INT 30
94932: PUSH
94933: LD_INT 31
94935: PUSH
94936: LD_INT 32
94938: PUSH
94939: LD_INT 33
94941: PUSH
94942: LD_INT 34
94944: PUSH
94945: LD_INT 36
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: PUSH
94981: LD_INT 101
94983: PUSH
94984: LD_INT 102
94986: PUSH
94987: LD_INT 103
94989: PUSH
94990: LD_INT 104
94992: PUSH
94993: LD_INT 105
94995: PUSH
94996: LD_INT 106
94998: PUSH
94999: LD_INT 107
95001: PUSH
95002: LD_INT 108
95004: PUSH
95005: LD_INT 109
95007: PUSH
95008: LD_INT 110
95010: PUSH
95011: LD_INT 111
95013: PUSH
95014: LD_INT 112
95016: PUSH
95017: LD_INT 113
95019: PUSH
95020: LD_INT 114
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: ST_TO_ADDR
95043: GO 96210
95045: LD_INT 14
95047: DOUBLE
95048: EQUAL
95049: IFTRUE 95053
95051: GO 95265
95053: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
95054: LD_ADDR_VAR 0 1
95058: PUSH
95059: LD_INT 1
95061: PUSH
95062: LD_INT 2
95064: PUSH
95065: LD_INT 3
95067: PUSH
95068: LD_INT 4
95070: PUSH
95071: LD_INT 5
95073: PUSH
95074: LD_INT 6
95076: PUSH
95077: LD_INT 7
95079: PUSH
95080: LD_INT 8
95082: PUSH
95083: LD_INT 9
95085: PUSH
95086: LD_INT 10
95088: PUSH
95089: LD_INT 11
95091: PUSH
95092: LD_INT 12
95094: PUSH
95095: LD_INT 13
95097: PUSH
95098: LD_INT 14
95100: PUSH
95101: LD_INT 15
95103: PUSH
95104: LD_INT 16
95106: PUSH
95107: LD_INT 17
95109: PUSH
95110: LD_INT 18
95112: PUSH
95113: LD_INT 19
95115: PUSH
95116: LD_INT 20
95118: PUSH
95119: LD_INT 21
95121: PUSH
95122: LD_INT 22
95124: PUSH
95125: LD_INT 23
95127: PUSH
95128: LD_INT 24
95130: PUSH
95131: LD_INT 25
95133: PUSH
95134: LD_INT 26
95136: PUSH
95137: LD_INT 27
95139: PUSH
95140: LD_INT 28
95142: PUSH
95143: LD_INT 29
95145: PUSH
95146: LD_INT 30
95148: PUSH
95149: LD_INT 31
95151: PUSH
95152: LD_INT 32
95154: PUSH
95155: LD_INT 33
95157: PUSH
95158: LD_INT 34
95160: PUSH
95161: LD_INT 36
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: LIST
95200: PUSH
95201: LD_INT 101
95203: PUSH
95204: LD_INT 102
95206: PUSH
95207: LD_INT 103
95209: PUSH
95210: LD_INT 104
95212: PUSH
95213: LD_INT 105
95215: PUSH
95216: LD_INT 106
95218: PUSH
95219: LD_INT 107
95221: PUSH
95222: LD_INT 108
95224: PUSH
95225: LD_INT 109
95227: PUSH
95228: LD_INT 110
95230: PUSH
95231: LD_INT 111
95233: PUSH
95234: LD_INT 112
95236: PUSH
95237: LD_INT 113
95239: PUSH
95240: LD_INT 114
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: ST_TO_ADDR
95263: GO 96210
95265: LD_INT 15
95267: DOUBLE
95268: EQUAL
95269: IFTRUE 95273
95271: GO 95485
95273: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
95274: LD_ADDR_VAR 0 1
95278: PUSH
95279: LD_INT 1
95281: PUSH
95282: LD_INT 2
95284: PUSH
95285: LD_INT 3
95287: PUSH
95288: LD_INT 4
95290: PUSH
95291: LD_INT 5
95293: PUSH
95294: LD_INT 6
95296: PUSH
95297: LD_INT 7
95299: PUSH
95300: LD_INT 8
95302: PUSH
95303: LD_INT 9
95305: PUSH
95306: LD_INT 10
95308: PUSH
95309: LD_INT 11
95311: PUSH
95312: LD_INT 12
95314: PUSH
95315: LD_INT 13
95317: PUSH
95318: LD_INT 14
95320: PUSH
95321: LD_INT 15
95323: PUSH
95324: LD_INT 16
95326: PUSH
95327: LD_INT 17
95329: PUSH
95330: LD_INT 18
95332: PUSH
95333: LD_INT 19
95335: PUSH
95336: LD_INT 20
95338: PUSH
95339: LD_INT 21
95341: PUSH
95342: LD_INT 22
95344: PUSH
95345: LD_INT 23
95347: PUSH
95348: LD_INT 24
95350: PUSH
95351: LD_INT 25
95353: PUSH
95354: LD_INT 26
95356: PUSH
95357: LD_INT 27
95359: PUSH
95360: LD_INT 28
95362: PUSH
95363: LD_INT 29
95365: PUSH
95366: LD_INT 30
95368: PUSH
95369: LD_INT 31
95371: PUSH
95372: LD_INT 32
95374: PUSH
95375: LD_INT 33
95377: PUSH
95378: LD_INT 34
95380: PUSH
95381: LD_INT 36
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: PUSH
95421: LD_INT 101
95423: PUSH
95424: LD_INT 102
95426: PUSH
95427: LD_INT 103
95429: PUSH
95430: LD_INT 104
95432: PUSH
95433: LD_INT 105
95435: PUSH
95436: LD_INT 106
95438: PUSH
95439: LD_INT 107
95441: PUSH
95442: LD_INT 108
95444: PUSH
95445: LD_INT 109
95447: PUSH
95448: LD_INT 110
95450: PUSH
95451: LD_INT 111
95453: PUSH
95454: LD_INT 112
95456: PUSH
95457: LD_INT 113
95459: PUSH
95460: LD_INT 114
95462: PUSH
95463: EMPTY
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: ST_TO_ADDR
95483: GO 96210
95485: LD_INT 16
95487: DOUBLE
95488: EQUAL
95489: IFTRUE 95493
95491: GO 95617
95493: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
95494: LD_ADDR_VAR 0 1
95498: PUSH
95499: LD_INT 2
95501: PUSH
95502: LD_INT 4
95504: PUSH
95505: LD_INT 5
95507: PUSH
95508: LD_INT 7
95510: PUSH
95511: LD_INT 11
95513: PUSH
95514: LD_INT 12
95516: PUSH
95517: LD_INT 15
95519: PUSH
95520: LD_INT 16
95522: PUSH
95523: LD_INT 20
95525: PUSH
95526: LD_INT 21
95528: PUSH
95529: LD_INT 22
95531: PUSH
95532: LD_INT 23
95534: PUSH
95535: LD_INT 25
95537: PUSH
95538: LD_INT 26
95540: PUSH
95541: LD_INT 30
95543: PUSH
95544: LD_INT 31
95546: PUSH
95547: LD_INT 32
95549: PUSH
95550: LD_INT 33
95552: PUSH
95553: LD_INT 34
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 101
95579: PUSH
95580: LD_INT 102
95582: PUSH
95583: LD_INT 103
95585: PUSH
95586: LD_INT 106
95588: PUSH
95589: LD_INT 108
95591: PUSH
95592: LD_INT 112
95594: PUSH
95595: LD_INT 113
95597: PUSH
95598: LD_INT 114
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: ST_TO_ADDR
95615: GO 96210
95617: LD_INT 17
95619: DOUBLE
95620: EQUAL
95621: IFTRUE 95625
95623: GO 95837
95625: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
95626: LD_ADDR_VAR 0 1
95630: PUSH
95631: LD_INT 1
95633: PUSH
95634: LD_INT 2
95636: PUSH
95637: LD_INT 3
95639: PUSH
95640: LD_INT 4
95642: PUSH
95643: LD_INT 5
95645: PUSH
95646: LD_INT 6
95648: PUSH
95649: LD_INT 7
95651: PUSH
95652: LD_INT 8
95654: PUSH
95655: LD_INT 9
95657: PUSH
95658: LD_INT 10
95660: PUSH
95661: LD_INT 11
95663: PUSH
95664: LD_INT 12
95666: PUSH
95667: LD_INT 13
95669: PUSH
95670: LD_INT 14
95672: PUSH
95673: LD_INT 15
95675: PUSH
95676: LD_INT 16
95678: PUSH
95679: LD_INT 17
95681: PUSH
95682: LD_INT 18
95684: PUSH
95685: LD_INT 19
95687: PUSH
95688: LD_INT 20
95690: PUSH
95691: LD_INT 21
95693: PUSH
95694: LD_INT 22
95696: PUSH
95697: LD_INT 23
95699: PUSH
95700: LD_INT 24
95702: PUSH
95703: LD_INT 25
95705: PUSH
95706: LD_INT 26
95708: PUSH
95709: LD_INT 27
95711: PUSH
95712: LD_INT 28
95714: PUSH
95715: LD_INT 29
95717: PUSH
95718: LD_INT 30
95720: PUSH
95721: LD_INT 31
95723: PUSH
95724: LD_INT 32
95726: PUSH
95727: LD_INT 33
95729: PUSH
95730: LD_INT 34
95732: PUSH
95733: LD_INT 36
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: LIST
95771: LIST
95772: PUSH
95773: LD_INT 101
95775: PUSH
95776: LD_INT 102
95778: PUSH
95779: LD_INT 103
95781: PUSH
95782: LD_INT 104
95784: PUSH
95785: LD_INT 105
95787: PUSH
95788: LD_INT 106
95790: PUSH
95791: LD_INT 107
95793: PUSH
95794: LD_INT 108
95796: PUSH
95797: LD_INT 109
95799: PUSH
95800: LD_INT 110
95802: PUSH
95803: LD_INT 111
95805: PUSH
95806: LD_INT 112
95808: PUSH
95809: LD_INT 113
95811: PUSH
95812: LD_INT 114
95814: PUSH
95815: EMPTY
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: PUSH
95831: EMPTY
95832: LIST
95833: LIST
95834: ST_TO_ADDR
95835: GO 96210
95837: LD_INT 18
95839: DOUBLE
95840: EQUAL
95841: IFTRUE 95845
95843: GO 95981
95845: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
95846: LD_ADDR_VAR 0 1
95850: PUSH
95851: LD_INT 2
95853: PUSH
95854: LD_INT 4
95856: PUSH
95857: LD_INT 5
95859: PUSH
95860: LD_INT 7
95862: PUSH
95863: LD_INT 11
95865: PUSH
95866: LD_INT 12
95868: PUSH
95869: LD_INT 15
95871: PUSH
95872: LD_INT 16
95874: PUSH
95875: LD_INT 20
95877: PUSH
95878: LD_INT 21
95880: PUSH
95881: LD_INT 22
95883: PUSH
95884: LD_INT 23
95886: PUSH
95887: LD_INT 25
95889: PUSH
95890: LD_INT 26
95892: PUSH
95893: LD_INT 30
95895: PUSH
95896: LD_INT 31
95898: PUSH
95899: LD_INT 32
95901: PUSH
95902: LD_INT 33
95904: PUSH
95905: LD_INT 34
95907: PUSH
95908: LD_INT 35
95910: PUSH
95911: LD_INT 36
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: PUSH
95937: LD_INT 101
95939: PUSH
95940: LD_INT 102
95942: PUSH
95943: LD_INT 103
95945: PUSH
95946: LD_INT 106
95948: PUSH
95949: LD_INT 108
95951: PUSH
95952: LD_INT 112
95954: PUSH
95955: LD_INT 113
95957: PUSH
95958: LD_INT 114
95960: PUSH
95961: LD_INT 115
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: PUSH
95975: EMPTY
95976: LIST
95977: LIST
95978: ST_TO_ADDR
95979: GO 96210
95981: LD_INT 19
95983: DOUBLE
95984: EQUAL
95985: IFTRUE 95989
95987: GO 96209
95989: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
95990: LD_ADDR_VAR 0 1
95994: PUSH
95995: LD_INT 1
95997: PUSH
95998: LD_INT 2
96000: PUSH
96001: LD_INT 3
96003: PUSH
96004: LD_INT 4
96006: PUSH
96007: LD_INT 5
96009: PUSH
96010: LD_INT 6
96012: PUSH
96013: LD_INT 7
96015: PUSH
96016: LD_INT 8
96018: PUSH
96019: LD_INT 9
96021: PUSH
96022: LD_INT 10
96024: PUSH
96025: LD_INT 11
96027: PUSH
96028: LD_INT 12
96030: PUSH
96031: LD_INT 13
96033: PUSH
96034: LD_INT 14
96036: PUSH
96037: LD_INT 15
96039: PUSH
96040: LD_INT 16
96042: PUSH
96043: LD_INT 17
96045: PUSH
96046: LD_INT 18
96048: PUSH
96049: LD_INT 19
96051: PUSH
96052: LD_INT 20
96054: PUSH
96055: LD_INT 21
96057: PUSH
96058: LD_INT 22
96060: PUSH
96061: LD_INT 23
96063: PUSH
96064: LD_INT 24
96066: PUSH
96067: LD_INT 25
96069: PUSH
96070: LD_INT 26
96072: PUSH
96073: LD_INT 27
96075: PUSH
96076: LD_INT 28
96078: PUSH
96079: LD_INT 29
96081: PUSH
96082: LD_INT 30
96084: PUSH
96085: LD_INT 31
96087: PUSH
96088: LD_INT 32
96090: PUSH
96091: LD_INT 33
96093: PUSH
96094: LD_INT 34
96096: PUSH
96097: LD_INT 35
96099: PUSH
96100: LD_INT 36
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: PUSH
96141: LD_INT 101
96143: PUSH
96144: LD_INT 102
96146: PUSH
96147: LD_INT 103
96149: PUSH
96150: LD_INT 104
96152: PUSH
96153: LD_INT 105
96155: PUSH
96156: LD_INT 106
96158: PUSH
96159: LD_INT 107
96161: PUSH
96162: LD_INT 108
96164: PUSH
96165: LD_INT 109
96167: PUSH
96168: LD_INT 110
96170: PUSH
96171: LD_INT 111
96173: PUSH
96174: LD_INT 112
96176: PUSH
96177: LD_INT 113
96179: PUSH
96180: LD_INT 114
96182: PUSH
96183: LD_INT 115
96185: PUSH
96186: EMPTY
96187: LIST
96188: LIST
96189: LIST
96190: LIST
96191: LIST
96192: LIST
96193: LIST
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: PUSH
96203: EMPTY
96204: LIST
96205: LIST
96206: ST_TO_ADDR
96207: GO 96210
96209: POP
// end else
96210: GO 96429
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
96212: LD_ADDR_VAR 0 1
96216: PUSH
96217: LD_INT 1
96219: PUSH
96220: LD_INT 2
96222: PUSH
96223: LD_INT 3
96225: PUSH
96226: LD_INT 4
96228: PUSH
96229: LD_INT 5
96231: PUSH
96232: LD_INT 6
96234: PUSH
96235: LD_INT 7
96237: PUSH
96238: LD_INT 8
96240: PUSH
96241: LD_INT 9
96243: PUSH
96244: LD_INT 10
96246: PUSH
96247: LD_INT 11
96249: PUSH
96250: LD_INT 12
96252: PUSH
96253: LD_INT 13
96255: PUSH
96256: LD_INT 14
96258: PUSH
96259: LD_INT 15
96261: PUSH
96262: LD_INT 16
96264: PUSH
96265: LD_INT 17
96267: PUSH
96268: LD_INT 18
96270: PUSH
96271: LD_INT 19
96273: PUSH
96274: LD_INT 20
96276: PUSH
96277: LD_INT 21
96279: PUSH
96280: LD_INT 22
96282: PUSH
96283: LD_INT 23
96285: PUSH
96286: LD_INT 24
96288: PUSH
96289: LD_INT 25
96291: PUSH
96292: LD_INT 26
96294: PUSH
96295: LD_INT 27
96297: PUSH
96298: LD_INT 28
96300: PUSH
96301: LD_INT 29
96303: PUSH
96304: LD_INT 30
96306: PUSH
96307: LD_INT 31
96309: PUSH
96310: LD_INT 32
96312: PUSH
96313: LD_INT 33
96315: PUSH
96316: LD_INT 34
96318: PUSH
96319: LD_INT 35
96321: PUSH
96322: LD_INT 36
96324: PUSH
96325: EMPTY
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: LIST
96349: LIST
96350: LIST
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: PUSH
96363: LD_INT 101
96365: PUSH
96366: LD_INT 102
96368: PUSH
96369: LD_INT 103
96371: PUSH
96372: LD_INT 104
96374: PUSH
96375: LD_INT 105
96377: PUSH
96378: LD_INT 106
96380: PUSH
96381: LD_INT 107
96383: PUSH
96384: LD_INT 108
96386: PUSH
96387: LD_INT 109
96389: PUSH
96390: LD_INT 110
96392: PUSH
96393: LD_INT 111
96395: PUSH
96396: LD_INT 112
96398: PUSH
96399: LD_INT 113
96401: PUSH
96402: LD_INT 114
96404: PUSH
96405: LD_INT 115
96407: PUSH
96408: EMPTY
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: PUSH
96425: EMPTY
96426: LIST
96427: LIST
96428: ST_TO_ADDR
// if result then
96429: LD_VAR 0 1
96433: IFFALSE 96722
// begin normal :=  ;
96435: LD_ADDR_VAR 0 3
96439: PUSH
96440: LD_STRING 
96442: ST_TO_ADDR
// hardcore :=  ;
96443: LD_ADDR_VAR 0 4
96447: PUSH
96448: LD_STRING 
96450: ST_TO_ADDR
// for i = 1 to normalCounter do
96451: LD_ADDR_VAR 0 5
96455: PUSH
96456: DOUBLE
96457: LD_INT 1
96459: DEC
96460: ST_TO_ADDR
96461: LD_EXP 99
96465: PUSH
96466: FOR_TO
96467: IFFALSE 96568
// begin tmp := 0 ;
96469: LD_ADDR_VAR 0 2
96473: PUSH
96474: LD_STRING 0
96476: ST_TO_ADDR
// if result [ 1 ] then
96477: LD_VAR 0 1
96481: PUSH
96482: LD_INT 1
96484: ARRAY
96485: IFFALSE 96550
// if result [ 1 ] [ 1 ] = i then
96487: LD_VAR 0 1
96491: PUSH
96492: LD_INT 1
96494: ARRAY
96495: PUSH
96496: LD_INT 1
96498: ARRAY
96499: PUSH
96500: LD_VAR 0 5
96504: EQUAL
96505: IFFALSE 96550
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96507: LD_ADDR_VAR 0 1
96511: PUSH
96512: LD_VAR 0 1
96516: PPUSH
96517: LD_INT 1
96519: PPUSH
96520: LD_VAR 0 1
96524: PUSH
96525: LD_INT 1
96527: ARRAY
96528: PPUSH
96529: LD_INT 1
96531: PPUSH
96532: CALL_OW 3
96536: PPUSH
96537: CALL_OW 1
96541: ST_TO_ADDR
// tmp := 1 ;
96542: LD_ADDR_VAR 0 2
96546: PUSH
96547: LD_STRING 1
96549: ST_TO_ADDR
// end ; normal := normal & tmp ;
96550: LD_ADDR_VAR 0 3
96554: PUSH
96555: LD_VAR 0 3
96559: PUSH
96560: LD_VAR 0 2
96564: STR
96565: ST_TO_ADDR
// end ;
96566: GO 96466
96568: POP
96569: POP
// for i = 1 to hardcoreCounter do
96570: LD_ADDR_VAR 0 5
96574: PUSH
96575: DOUBLE
96576: LD_INT 1
96578: DEC
96579: ST_TO_ADDR
96580: LD_EXP 100
96584: PUSH
96585: FOR_TO
96586: IFFALSE 96691
// begin tmp := 0 ;
96588: LD_ADDR_VAR 0 2
96592: PUSH
96593: LD_STRING 0
96595: ST_TO_ADDR
// if result [ 2 ] then
96596: LD_VAR 0 1
96600: PUSH
96601: LD_INT 2
96603: ARRAY
96604: IFFALSE 96673
// if result [ 2 ] [ 1 ] = 100 + i then
96606: LD_VAR 0 1
96610: PUSH
96611: LD_INT 2
96613: ARRAY
96614: PUSH
96615: LD_INT 1
96617: ARRAY
96618: PUSH
96619: LD_INT 100
96621: PUSH
96622: LD_VAR 0 5
96626: PLUS
96627: EQUAL
96628: IFFALSE 96673
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96630: LD_ADDR_VAR 0 1
96634: PUSH
96635: LD_VAR 0 1
96639: PPUSH
96640: LD_INT 2
96642: PPUSH
96643: LD_VAR 0 1
96647: PUSH
96648: LD_INT 2
96650: ARRAY
96651: PPUSH
96652: LD_INT 1
96654: PPUSH
96655: CALL_OW 3
96659: PPUSH
96660: CALL_OW 1
96664: ST_TO_ADDR
// tmp := 1 ;
96665: LD_ADDR_VAR 0 2
96669: PUSH
96670: LD_STRING 1
96672: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96673: LD_ADDR_VAR 0 4
96677: PUSH
96678: LD_VAR 0 4
96682: PUSH
96683: LD_VAR 0 2
96687: STR
96688: ST_TO_ADDR
// end ;
96689: GO 96585
96691: POP
96692: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
96693: LD_STRING getStreamItemsFromMission("
96695: PUSH
96696: LD_VAR 0 3
96700: STR
96701: PUSH
96702: LD_STRING ","
96704: STR
96705: PUSH
96706: LD_VAR 0 4
96710: STR
96711: PUSH
96712: LD_STRING ")
96714: STR
96715: PPUSH
96716: CALL_OW 559
// end else
96720: GO 96729
// ToLua ( getStreamItemsFromMission("","") ) ;
96722: LD_STRING getStreamItemsFromMission("","")
96724: PPUSH
96725: CALL_OW 559
// end ;
96729: LD_VAR 0 1
96733: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96734: LD_EXP 98
96738: PUSH
96739: LD_EXP 103
96743: AND
96744: IFFALSE 96868
96746: GO 96748
96748: DISABLE
96749: LD_INT 0
96751: PPUSH
96752: PPUSH
// begin enable ;
96753: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96754: LD_ADDR_VAR 0 2
96758: PUSH
96759: LD_INT 22
96761: PUSH
96762: LD_OWVAR 2
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: PUSH
96771: LD_INT 2
96773: PUSH
96774: LD_INT 34
96776: PUSH
96777: LD_INT 7
96779: PUSH
96780: EMPTY
96781: LIST
96782: LIST
96783: PUSH
96784: LD_INT 34
96786: PUSH
96787: LD_INT 45
96789: PUSH
96790: EMPTY
96791: LIST
96792: LIST
96793: PUSH
96794: LD_INT 34
96796: PUSH
96797: LD_INT 28
96799: PUSH
96800: EMPTY
96801: LIST
96802: LIST
96803: PUSH
96804: LD_INT 34
96806: PUSH
96807: LD_INT 47
96809: PUSH
96810: EMPTY
96811: LIST
96812: LIST
96813: PUSH
96814: EMPTY
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: LIST
96820: PUSH
96821: EMPTY
96822: LIST
96823: LIST
96824: PPUSH
96825: CALL_OW 69
96829: ST_TO_ADDR
// if not tmp then
96830: LD_VAR 0 2
96834: NOT
96835: IFFALSE 96839
// exit ;
96837: GO 96868
// for i in tmp do
96839: LD_ADDR_VAR 0 1
96843: PUSH
96844: LD_VAR 0 2
96848: PUSH
96849: FOR_IN
96850: IFFALSE 96866
// begin SetLives ( i , 0 ) ;
96852: LD_VAR 0 1
96856: PPUSH
96857: LD_INT 0
96859: PPUSH
96860: CALL_OW 234
// end ;
96864: GO 96849
96866: POP
96867: POP
// end ;
96868: PPOPN 2
96870: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96871: LD_EXP 98
96875: PUSH
96876: LD_EXP 104
96880: AND
96881: IFFALSE 96965
96883: GO 96885
96885: DISABLE
96886: LD_INT 0
96888: PPUSH
96889: PPUSH
// begin enable ;
96890: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96891: LD_ADDR_VAR 0 2
96895: PUSH
96896: LD_INT 22
96898: PUSH
96899: LD_OWVAR 2
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: LD_INT 32
96910: PUSH
96911: LD_INT 3
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: EMPTY
96919: LIST
96920: LIST
96921: PPUSH
96922: CALL_OW 69
96926: ST_TO_ADDR
// if not tmp then
96927: LD_VAR 0 2
96931: NOT
96932: IFFALSE 96936
// exit ;
96934: GO 96965
// for i in tmp do
96936: LD_ADDR_VAR 0 1
96940: PUSH
96941: LD_VAR 0 2
96945: PUSH
96946: FOR_IN
96947: IFFALSE 96963
// begin SetLives ( i , 0 ) ;
96949: LD_VAR 0 1
96953: PPUSH
96954: LD_INT 0
96956: PPUSH
96957: CALL_OW 234
// end ;
96961: GO 96946
96963: POP
96964: POP
// end ;
96965: PPOPN 2
96967: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96968: LD_EXP 98
96972: PUSH
96973: LD_EXP 101
96977: AND
96978: IFFALSE 97071
96980: GO 96982
96982: DISABLE
96983: LD_INT 0
96985: PPUSH
// begin enable ;
96986: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96987: LD_ADDR_VAR 0 1
96991: PUSH
96992: LD_INT 22
96994: PUSH
96995: LD_OWVAR 2
96999: PUSH
97000: EMPTY
97001: LIST
97002: LIST
97003: PUSH
97004: LD_INT 2
97006: PUSH
97007: LD_INT 25
97009: PUSH
97010: LD_INT 5
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: PUSH
97017: LD_INT 25
97019: PUSH
97020: LD_INT 9
97022: PUSH
97023: EMPTY
97024: LIST
97025: LIST
97026: PUSH
97027: LD_INT 25
97029: PUSH
97030: LD_INT 8
97032: PUSH
97033: EMPTY
97034: LIST
97035: LIST
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: PUSH
97043: EMPTY
97044: LIST
97045: LIST
97046: PPUSH
97047: CALL_OW 69
97051: PUSH
97052: FOR_IN
97053: IFFALSE 97069
// begin SetClass ( i , 1 ) ;
97055: LD_VAR 0 1
97059: PPUSH
97060: LD_INT 1
97062: PPUSH
97063: CALL_OW 336
// end ;
97067: GO 97052
97069: POP
97070: POP
// end ;
97071: PPOPN 1
97073: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97074: LD_EXP 98
97078: PUSH
97079: LD_EXP 102
97083: AND
97084: PUSH
97085: LD_OWVAR 65
97089: PUSH
97090: LD_INT 7
97092: LESS
97093: AND
97094: IFFALSE 97108
97096: GO 97098
97098: DISABLE
// begin enable ;
97099: ENABLE
// game_speed := 7 ;
97100: LD_ADDR_OWVAR 65
97104: PUSH
97105: LD_INT 7
97107: ST_TO_ADDR
// end ;
97108: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97109: LD_EXP 98
97113: PUSH
97114: LD_EXP 105
97118: AND
97119: IFFALSE 97321
97121: GO 97123
97123: DISABLE
97124: LD_INT 0
97126: PPUSH
97127: PPUSH
97128: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97129: LD_ADDR_VAR 0 3
97133: PUSH
97134: LD_INT 81
97136: PUSH
97137: LD_OWVAR 2
97141: PUSH
97142: EMPTY
97143: LIST
97144: LIST
97145: PUSH
97146: LD_INT 21
97148: PUSH
97149: LD_INT 1
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: PUSH
97156: EMPTY
97157: LIST
97158: LIST
97159: PPUSH
97160: CALL_OW 69
97164: ST_TO_ADDR
// if not tmp then
97165: LD_VAR 0 3
97169: NOT
97170: IFFALSE 97174
// exit ;
97172: GO 97321
// if tmp > 5 then
97174: LD_VAR 0 3
97178: PUSH
97179: LD_INT 5
97181: GREATER
97182: IFFALSE 97194
// k := 5 else
97184: LD_ADDR_VAR 0 2
97188: PUSH
97189: LD_INT 5
97191: ST_TO_ADDR
97192: GO 97204
// k := tmp ;
97194: LD_ADDR_VAR 0 2
97198: PUSH
97199: LD_VAR 0 3
97203: ST_TO_ADDR
// for i := 1 to k do
97204: LD_ADDR_VAR 0 1
97208: PUSH
97209: DOUBLE
97210: LD_INT 1
97212: DEC
97213: ST_TO_ADDR
97214: LD_VAR 0 2
97218: PUSH
97219: FOR_TO
97220: IFFALSE 97319
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97222: LD_VAR 0 3
97226: PUSH
97227: LD_VAR 0 1
97231: ARRAY
97232: PPUSH
97233: LD_VAR 0 1
97237: PUSH
97238: LD_INT 4
97240: MOD
97241: PUSH
97242: LD_INT 1
97244: PLUS
97245: PPUSH
97246: CALL_OW 259
97250: PUSH
97251: LD_INT 10
97253: LESS
97254: IFFALSE 97317
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97256: LD_VAR 0 3
97260: PUSH
97261: LD_VAR 0 1
97265: ARRAY
97266: PPUSH
97267: LD_VAR 0 1
97271: PUSH
97272: LD_INT 4
97274: MOD
97275: PUSH
97276: LD_INT 1
97278: PLUS
97279: PPUSH
97280: LD_VAR 0 3
97284: PUSH
97285: LD_VAR 0 1
97289: ARRAY
97290: PPUSH
97291: LD_VAR 0 1
97295: PUSH
97296: LD_INT 4
97298: MOD
97299: PUSH
97300: LD_INT 1
97302: PLUS
97303: PPUSH
97304: CALL_OW 259
97308: PUSH
97309: LD_INT 1
97311: PLUS
97312: PPUSH
97313: CALL_OW 237
97317: GO 97219
97319: POP
97320: POP
// end ;
97321: PPOPN 3
97323: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97324: LD_EXP 98
97328: PUSH
97329: LD_EXP 106
97333: AND
97334: IFFALSE 97354
97336: GO 97338
97338: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97339: LD_INT 4
97341: PPUSH
97342: LD_OWVAR 2
97346: PPUSH
97347: LD_INT 0
97349: PPUSH
97350: CALL_OW 324
97354: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97355: LD_EXP 98
97359: PUSH
97360: LD_EXP 135
97364: AND
97365: IFFALSE 97385
97367: GO 97369
97369: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97370: LD_INT 19
97372: PPUSH
97373: LD_OWVAR 2
97377: PPUSH
97378: LD_INT 0
97380: PPUSH
97381: CALL_OW 324
97385: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97386: LD_EXP 98
97390: PUSH
97391: LD_EXP 107
97395: AND
97396: IFFALSE 97498
97398: GO 97400
97400: DISABLE
97401: LD_INT 0
97403: PPUSH
97404: PPUSH
// begin enable ;
97405: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97406: LD_ADDR_VAR 0 2
97410: PUSH
97411: LD_INT 22
97413: PUSH
97414: LD_OWVAR 2
97418: PUSH
97419: EMPTY
97420: LIST
97421: LIST
97422: PUSH
97423: LD_INT 2
97425: PUSH
97426: LD_INT 34
97428: PUSH
97429: LD_INT 11
97431: PUSH
97432: EMPTY
97433: LIST
97434: LIST
97435: PUSH
97436: LD_INT 34
97438: PUSH
97439: LD_INT 30
97441: PUSH
97442: EMPTY
97443: LIST
97444: LIST
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: LIST
97450: PUSH
97451: EMPTY
97452: LIST
97453: LIST
97454: PPUSH
97455: CALL_OW 69
97459: ST_TO_ADDR
// if not tmp then
97460: LD_VAR 0 2
97464: NOT
97465: IFFALSE 97469
// exit ;
97467: GO 97498
// for i in tmp do
97469: LD_ADDR_VAR 0 1
97473: PUSH
97474: LD_VAR 0 2
97478: PUSH
97479: FOR_IN
97480: IFFALSE 97496
// begin SetLives ( i , 0 ) ;
97482: LD_VAR 0 1
97486: PPUSH
97487: LD_INT 0
97489: PPUSH
97490: CALL_OW 234
// end ;
97494: GO 97479
97496: POP
97497: POP
// end ;
97498: PPOPN 2
97500: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97501: LD_EXP 98
97505: PUSH
97506: LD_EXP 108
97510: AND
97511: IFFALSE 97531
97513: GO 97515
97515: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97516: LD_INT 32
97518: PPUSH
97519: LD_OWVAR 2
97523: PPUSH
97524: LD_INT 0
97526: PPUSH
97527: CALL_OW 324
97531: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97532: LD_EXP 98
97536: PUSH
97537: LD_EXP 109
97541: AND
97542: IFFALSE 97723
97544: GO 97546
97546: DISABLE
97547: LD_INT 0
97549: PPUSH
97550: PPUSH
97551: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97552: LD_ADDR_VAR 0 2
97556: PUSH
97557: LD_INT 22
97559: PUSH
97560: LD_OWVAR 2
97564: PUSH
97565: EMPTY
97566: LIST
97567: LIST
97568: PUSH
97569: LD_INT 33
97571: PUSH
97572: LD_INT 3
97574: PUSH
97575: EMPTY
97576: LIST
97577: LIST
97578: PUSH
97579: EMPTY
97580: LIST
97581: LIST
97582: PPUSH
97583: CALL_OW 69
97587: ST_TO_ADDR
// if not tmp then
97588: LD_VAR 0 2
97592: NOT
97593: IFFALSE 97597
// exit ;
97595: GO 97723
// side := 0 ;
97597: LD_ADDR_VAR 0 3
97601: PUSH
97602: LD_INT 0
97604: ST_TO_ADDR
// for i := 1 to 8 do
97605: LD_ADDR_VAR 0 1
97609: PUSH
97610: DOUBLE
97611: LD_INT 1
97613: DEC
97614: ST_TO_ADDR
97615: LD_INT 8
97617: PUSH
97618: FOR_TO
97619: IFFALSE 97667
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97621: LD_OWVAR 2
97625: PUSH
97626: LD_VAR 0 1
97630: NONEQUAL
97631: PUSH
97632: LD_OWVAR 2
97636: PPUSH
97637: LD_VAR 0 1
97641: PPUSH
97642: CALL_OW 81
97646: PUSH
97647: LD_INT 2
97649: EQUAL
97650: AND
97651: IFFALSE 97665
// begin side := i ;
97653: LD_ADDR_VAR 0 3
97657: PUSH
97658: LD_VAR 0 1
97662: ST_TO_ADDR
// break ;
97663: GO 97667
// end ;
97665: GO 97618
97667: POP
97668: POP
// if not side then
97669: LD_VAR 0 3
97673: NOT
97674: IFFALSE 97678
// exit ;
97676: GO 97723
// for i := 1 to tmp do
97678: LD_ADDR_VAR 0 1
97682: PUSH
97683: DOUBLE
97684: LD_INT 1
97686: DEC
97687: ST_TO_ADDR
97688: LD_VAR 0 2
97692: PUSH
97693: FOR_TO
97694: IFFALSE 97721
// if Prob ( 60 ) then
97696: LD_INT 60
97698: PPUSH
97699: CALL_OW 13
97703: IFFALSE 97719
// SetSide ( i , side ) ;
97705: LD_VAR 0 1
97709: PPUSH
97710: LD_VAR 0 3
97714: PPUSH
97715: CALL_OW 235
97719: GO 97693
97721: POP
97722: POP
// end ;
97723: PPOPN 3
97725: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97726: LD_EXP 98
97730: PUSH
97731: LD_EXP 111
97735: AND
97736: IFFALSE 97855
97738: GO 97740
97740: DISABLE
97741: LD_INT 0
97743: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97744: LD_ADDR_VAR 0 1
97748: PUSH
97749: LD_INT 22
97751: PUSH
97752: LD_OWVAR 2
97756: PUSH
97757: EMPTY
97758: LIST
97759: LIST
97760: PUSH
97761: LD_INT 21
97763: PUSH
97764: LD_INT 1
97766: PUSH
97767: EMPTY
97768: LIST
97769: LIST
97770: PUSH
97771: LD_INT 3
97773: PUSH
97774: LD_INT 23
97776: PUSH
97777: LD_INT 0
97779: PUSH
97780: EMPTY
97781: LIST
97782: LIST
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: LIST
97792: PPUSH
97793: CALL_OW 69
97797: PUSH
97798: FOR_IN
97799: IFFALSE 97853
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97801: LD_VAR 0 1
97805: PPUSH
97806: CALL_OW 257
97810: PUSH
97811: LD_INT 1
97813: PUSH
97814: LD_INT 2
97816: PUSH
97817: LD_INT 3
97819: PUSH
97820: LD_INT 4
97822: PUSH
97823: EMPTY
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: IN
97829: IFFALSE 97851
// SetClass ( un , rand ( 1 , 4 ) ) ;
97831: LD_VAR 0 1
97835: PPUSH
97836: LD_INT 1
97838: PPUSH
97839: LD_INT 4
97841: PPUSH
97842: CALL_OW 12
97846: PPUSH
97847: CALL_OW 336
97851: GO 97798
97853: POP
97854: POP
// end ;
97855: PPOPN 1
97857: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97858: LD_EXP 98
97862: PUSH
97863: LD_EXP 110
97867: AND
97868: IFFALSE 97947
97870: GO 97872
97872: DISABLE
97873: LD_INT 0
97875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97876: LD_ADDR_VAR 0 1
97880: PUSH
97881: LD_INT 22
97883: PUSH
97884: LD_OWVAR 2
97888: PUSH
97889: EMPTY
97890: LIST
97891: LIST
97892: PUSH
97893: LD_INT 21
97895: PUSH
97896: LD_INT 3
97898: PUSH
97899: EMPTY
97900: LIST
97901: LIST
97902: PUSH
97903: EMPTY
97904: LIST
97905: LIST
97906: PPUSH
97907: CALL_OW 69
97911: ST_TO_ADDR
// if not tmp then
97912: LD_VAR 0 1
97916: NOT
97917: IFFALSE 97921
// exit ;
97919: GO 97947
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97921: LD_VAR 0 1
97925: PUSH
97926: LD_INT 1
97928: PPUSH
97929: LD_VAR 0 1
97933: PPUSH
97934: CALL_OW 12
97938: ARRAY
97939: PPUSH
97940: LD_INT 100
97942: PPUSH
97943: CALL_OW 234
// end ;
97947: PPOPN 1
97949: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97950: LD_EXP 98
97954: PUSH
97955: LD_EXP 112
97959: AND
97960: IFFALSE 98058
97962: GO 97964
97964: DISABLE
97965: LD_INT 0
97967: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97968: LD_ADDR_VAR 0 1
97972: PUSH
97973: LD_INT 22
97975: PUSH
97976: LD_OWVAR 2
97980: PUSH
97981: EMPTY
97982: LIST
97983: LIST
97984: PUSH
97985: LD_INT 21
97987: PUSH
97988: LD_INT 1
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PUSH
97995: EMPTY
97996: LIST
97997: LIST
97998: PPUSH
97999: CALL_OW 69
98003: ST_TO_ADDR
// if not tmp then
98004: LD_VAR 0 1
98008: NOT
98009: IFFALSE 98013
// exit ;
98011: GO 98058
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98013: LD_VAR 0 1
98017: PUSH
98018: LD_INT 1
98020: PPUSH
98021: LD_VAR 0 1
98025: PPUSH
98026: CALL_OW 12
98030: ARRAY
98031: PPUSH
98032: LD_INT 1
98034: PPUSH
98035: LD_INT 4
98037: PPUSH
98038: CALL_OW 12
98042: PPUSH
98043: LD_INT 3000
98045: PPUSH
98046: LD_INT 9000
98048: PPUSH
98049: CALL_OW 12
98053: PPUSH
98054: CALL_OW 492
// end ;
98058: PPOPN 1
98060: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98061: LD_EXP 98
98065: PUSH
98066: LD_EXP 113
98070: AND
98071: IFFALSE 98091
98073: GO 98075
98075: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98076: LD_INT 1
98078: PPUSH
98079: LD_OWVAR 2
98083: PPUSH
98084: LD_INT 0
98086: PPUSH
98087: CALL_OW 324
98091: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98092: LD_EXP 98
98096: PUSH
98097: LD_EXP 114
98101: AND
98102: IFFALSE 98185
98104: GO 98106
98106: DISABLE
98107: LD_INT 0
98109: PPUSH
98110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98111: LD_ADDR_VAR 0 2
98115: PUSH
98116: LD_INT 22
98118: PUSH
98119: LD_OWVAR 2
98123: PUSH
98124: EMPTY
98125: LIST
98126: LIST
98127: PUSH
98128: LD_INT 21
98130: PUSH
98131: LD_INT 3
98133: PUSH
98134: EMPTY
98135: LIST
98136: LIST
98137: PUSH
98138: EMPTY
98139: LIST
98140: LIST
98141: PPUSH
98142: CALL_OW 69
98146: ST_TO_ADDR
// if not tmp then
98147: LD_VAR 0 2
98151: NOT
98152: IFFALSE 98156
// exit ;
98154: GO 98185
// for i in tmp do
98156: LD_ADDR_VAR 0 1
98160: PUSH
98161: LD_VAR 0 2
98165: PUSH
98166: FOR_IN
98167: IFFALSE 98183
// SetBLevel ( i , 10 ) ;
98169: LD_VAR 0 1
98173: PPUSH
98174: LD_INT 10
98176: PPUSH
98177: CALL_OW 241
98181: GO 98166
98183: POP
98184: POP
// end ;
98185: PPOPN 2
98187: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98188: LD_EXP 98
98192: PUSH
98193: LD_EXP 115
98197: AND
98198: IFFALSE 98309
98200: GO 98202
98202: DISABLE
98203: LD_INT 0
98205: PPUSH
98206: PPUSH
98207: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98208: LD_ADDR_VAR 0 3
98212: PUSH
98213: LD_INT 22
98215: PUSH
98216: LD_OWVAR 2
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PUSH
98225: LD_INT 25
98227: PUSH
98228: LD_INT 1
98230: PUSH
98231: EMPTY
98232: LIST
98233: LIST
98234: PUSH
98235: EMPTY
98236: LIST
98237: LIST
98238: PPUSH
98239: CALL_OW 69
98243: ST_TO_ADDR
// if not tmp then
98244: LD_VAR 0 3
98248: NOT
98249: IFFALSE 98253
// exit ;
98251: GO 98309
// un := tmp [ rand ( 1 , tmp ) ] ;
98253: LD_ADDR_VAR 0 2
98257: PUSH
98258: LD_VAR 0 3
98262: PUSH
98263: LD_INT 1
98265: PPUSH
98266: LD_VAR 0 3
98270: PPUSH
98271: CALL_OW 12
98275: ARRAY
98276: ST_TO_ADDR
// if Crawls ( un ) then
98277: LD_VAR 0 2
98281: PPUSH
98282: CALL_OW 318
98286: IFFALSE 98297
// ComWalk ( un ) ;
98288: LD_VAR 0 2
98292: PPUSH
98293: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98297: LD_VAR 0 2
98301: PPUSH
98302: LD_INT 5
98304: PPUSH
98305: CALL_OW 336
// end ;
98309: PPOPN 3
98311: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
98312: LD_EXP 98
98316: PUSH
98317: LD_EXP 116
98321: AND
98322: PUSH
98323: LD_OWVAR 67
98327: PUSH
98328: LD_INT 3
98330: LESS
98331: AND
98332: IFFALSE 98351
98334: GO 98336
98336: DISABLE
// Difficulty := Difficulty + 1 ;
98337: LD_ADDR_OWVAR 67
98341: PUSH
98342: LD_OWVAR 67
98346: PUSH
98347: LD_INT 1
98349: PLUS
98350: ST_TO_ADDR
98351: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98352: LD_EXP 98
98356: PUSH
98357: LD_EXP 117
98361: AND
98362: IFFALSE 98465
98364: GO 98366
98366: DISABLE
98367: LD_INT 0
98369: PPUSH
// begin for i := 1 to 5 do
98370: LD_ADDR_VAR 0 1
98374: PUSH
98375: DOUBLE
98376: LD_INT 1
98378: DEC
98379: ST_TO_ADDR
98380: LD_INT 5
98382: PUSH
98383: FOR_TO
98384: IFFALSE 98463
// begin uc_nation := nation_nature ;
98386: LD_ADDR_OWVAR 21
98390: PUSH
98391: LD_INT 0
98393: ST_TO_ADDR
// uc_side := 0 ;
98394: LD_ADDR_OWVAR 20
98398: PUSH
98399: LD_INT 0
98401: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98402: LD_ADDR_OWVAR 29
98406: PUSH
98407: LD_INT 12
98409: PUSH
98410: LD_INT 12
98412: PUSH
98413: EMPTY
98414: LIST
98415: LIST
98416: ST_TO_ADDR
// hc_agressivity := 20 ;
98417: LD_ADDR_OWVAR 35
98421: PUSH
98422: LD_INT 20
98424: ST_TO_ADDR
// hc_class := class_tiger ;
98425: LD_ADDR_OWVAR 28
98429: PUSH
98430: LD_INT 14
98432: ST_TO_ADDR
// hc_gallery :=  ;
98433: LD_ADDR_OWVAR 33
98437: PUSH
98438: LD_STRING 
98440: ST_TO_ADDR
// hc_name :=  ;
98441: LD_ADDR_OWVAR 26
98445: PUSH
98446: LD_STRING 
98448: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98449: CALL_OW 44
98453: PPUSH
98454: LD_INT 0
98456: PPUSH
98457: CALL_OW 51
// end ;
98461: GO 98383
98463: POP
98464: POP
// end ;
98465: PPOPN 1
98467: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98468: LD_EXP 98
98472: PUSH
98473: LD_EXP 118
98477: AND
98478: IFFALSE 98487
98480: GO 98482
98482: DISABLE
// StreamSibBomb ;
98483: CALL 98488 0 0
98487: END
// export function StreamSibBomb ; var i , x , y ; begin
98488: LD_INT 0
98490: PPUSH
98491: PPUSH
98492: PPUSH
98493: PPUSH
// result := false ;
98494: LD_ADDR_VAR 0 1
98498: PUSH
98499: LD_INT 0
98501: ST_TO_ADDR
// for i := 1 to 16 do
98502: LD_ADDR_VAR 0 2
98506: PUSH
98507: DOUBLE
98508: LD_INT 1
98510: DEC
98511: ST_TO_ADDR
98512: LD_INT 16
98514: PUSH
98515: FOR_TO
98516: IFFALSE 98715
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98518: LD_ADDR_VAR 0 3
98522: PUSH
98523: LD_INT 10
98525: PUSH
98526: LD_INT 20
98528: PUSH
98529: LD_INT 30
98531: PUSH
98532: LD_INT 40
98534: PUSH
98535: LD_INT 50
98537: PUSH
98538: LD_INT 60
98540: PUSH
98541: LD_INT 70
98543: PUSH
98544: LD_INT 80
98546: PUSH
98547: LD_INT 90
98549: PUSH
98550: LD_INT 100
98552: PUSH
98553: LD_INT 110
98555: PUSH
98556: LD_INT 120
98558: PUSH
98559: LD_INT 130
98561: PUSH
98562: LD_INT 140
98564: PUSH
98565: LD_INT 150
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: LIST
98572: LIST
98573: LIST
98574: LIST
98575: LIST
98576: LIST
98577: LIST
98578: LIST
98579: LIST
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: PUSH
98585: LD_INT 1
98587: PPUSH
98588: LD_INT 15
98590: PPUSH
98591: CALL_OW 12
98595: ARRAY
98596: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98597: LD_ADDR_VAR 0 4
98601: PUSH
98602: LD_INT 10
98604: PUSH
98605: LD_INT 20
98607: PUSH
98608: LD_INT 30
98610: PUSH
98611: LD_INT 40
98613: PUSH
98614: LD_INT 50
98616: PUSH
98617: LD_INT 60
98619: PUSH
98620: LD_INT 70
98622: PUSH
98623: LD_INT 80
98625: PUSH
98626: LD_INT 90
98628: PUSH
98629: LD_INT 100
98631: PUSH
98632: LD_INT 110
98634: PUSH
98635: LD_INT 120
98637: PUSH
98638: LD_INT 130
98640: PUSH
98641: LD_INT 140
98643: PUSH
98644: LD_INT 150
98646: PUSH
98647: EMPTY
98648: LIST
98649: LIST
98650: LIST
98651: LIST
98652: LIST
98653: LIST
98654: LIST
98655: LIST
98656: LIST
98657: LIST
98658: LIST
98659: LIST
98660: LIST
98661: LIST
98662: LIST
98663: PUSH
98664: LD_INT 1
98666: PPUSH
98667: LD_INT 15
98669: PPUSH
98670: CALL_OW 12
98674: ARRAY
98675: ST_TO_ADDR
// if ValidHex ( x , y ) then
98676: LD_VAR 0 3
98680: PPUSH
98681: LD_VAR 0 4
98685: PPUSH
98686: CALL_OW 488
98690: IFFALSE 98713
// begin result := [ x , y ] ;
98692: LD_ADDR_VAR 0 1
98696: PUSH
98697: LD_VAR 0 3
98701: PUSH
98702: LD_VAR 0 4
98706: PUSH
98707: EMPTY
98708: LIST
98709: LIST
98710: ST_TO_ADDR
// break ;
98711: GO 98715
// end ; end ;
98713: GO 98515
98715: POP
98716: POP
// if result then
98717: LD_VAR 0 1
98721: IFFALSE 98781
// begin ToLua ( playSibBomb() ) ;
98723: LD_STRING playSibBomb()
98725: PPUSH
98726: CALL_OW 559
// wait ( 0 0$14 ) ;
98730: LD_INT 490
98732: PPUSH
98733: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98737: LD_VAR 0 1
98741: PUSH
98742: LD_INT 1
98744: ARRAY
98745: PPUSH
98746: LD_VAR 0 1
98750: PUSH
98751: LD_INT 2
98753: ARRAY
98754: PPUSH
98755: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98759: LD_VAR 0 1
98763: PUSH
98764: LD_INT 1
98766: ARRAY
98767: PPUSH
98768: LD_VAR 0 1
98772: PUSH
98773: LD_INT 2
98775: ARRAY
98776: PPUSH
98777: CALL_OW 429
// end ; end ;
98781: LD_VAR 0 1
98785: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98786: LD_EXP 98
98790: PUSH
98791: LD_EXP 120
98795: AND
98796: IFFALSE 98808
98798: GO 98800
98800: DISABLE
// YouLost (  ) ;
98801: LD_STRING 
98803: PPUSH
98804: CALL_OW 104
98808: END
// every 0 0$1 trigger StreamModeActive and sFog do
98809: LD_EXP 98
98813: PUSH
98814: LD_EXP 119
98818: AND
98819: IFFALSE 98833
98821: GO 98823
98823: DISABLE
// FogOff ( your_side ) ;
98824: LD_OWVAR 2
98828: PPUSH
98829: CALL_OW 344
98833: END
// every 0 0$1 trigger StreamModeActive and sSun do
98834: LD_EXP 98
98838: PUSH
98839: LD_EXP 121
98843: AND
98844: IFFALSE 98872
98846: GO 98848
98848: DISABLE
// begin solar_recharge_percent := 0 ;
98849: LD_ADDR_OWVAR 79
98853: PUSH
98854: LD_INT 0
98856: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98857: LD_INT 10500
98859: PPUSH
98860: CALL_OW 67
// solar_recharge_percent := 100 ;
98864: LD_ADDR_OWVAR 79
98868: PUSH
98869: LD_INT 100
98871: ST_TO_ADDR
// end ;
98872: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98873: LD_EXP 98
98877: PUSH
98878: LD_EXP 122
98882: AND
98883: IFFALSE 99122
98885: GO 98887
98887: DISABLE
98888: LD_INT 0
98890: PPUSH
98891: PPUSH
98892: PPUSH
// begin tmp := [ ] ;
98893: LD_ADDR_VAR 0 3
98897: PUSH
98898: EMPTY
98899: ST_TO_ADDR
// for i := 1 to 6 do
98900: LD_ADDR_VAR 0 1
98904: PUSH
98905: DOUBLE
98906: LD_INT 1
98908: DEC
98909: ST_TO_ADDR
98910: LD_INT 6
98912: PUSH
98913: FOR_TO
98914: IFFALSE 99019
// begin uc_nation := nation_nature ;
98916: LD_ADDR_OWVAR 21
98920: PUSH
98921: LD_INT 0
98923: ST_TO_ADDR
// uc_side := 0 ;
98924: LD_ADDR_OWVAR 20
98928: PUSH
98929: LD_INT 0
98931: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98932: LD_ADDR_OWVAR 29
98936: PUSH
98937: LD_INT 12
98939: PUSH
98940: LD_INT 12
98942: PUSH
98943: EMPTY
98944: LIST
98945: LIST
98946: ST_TO_ADDR
// hc_agressivity := 20 ;
98947: LD_ADDR_OWVAR 35
98951: PUSH
98952: LD_INT 20
98954: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98955: LD_ADDR_OWVAR 28
98959: PUSH
98960: LD_INT 17
98962: ST_TO_ADDR
// hc_gallery :=  ;
98963: LD_ADDR_OWVAR 33
98967: PUSH
98968: LD_STRING 
98970: ST_TO_ADDR
// hc_name :=  ;
98971: LD_ADDR_OWVAR 26
98975: PUSH
98976: LD_STRING 
98978: ST_TO_ADDR
// un := CreateHuman ;
98979: LD_ADDR_VAR 0 2
98983: PUSH
98984: CALL_OW 44
98988: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98989: LD_VAR 0 2
98993: PPUSH
98994: LD_INT 1
98996: PPUSH
98997: CALL_OW 51
// tmp := tmp ^ un ;
99001: LD_ADDR_VAR 0 3
99005: PUSH
99006: LD_VAR 0 3
99010: PUSH
99011: LD_VAR 0 2
99015: ADD
99016: ST_TO_ADDR
// end ;
99017: GO 98913
99019: POP
99020: POP
// repeat wait ( 0 0$1 ) ;
99021: LD_INT 35
99023: PPUSH
99024: CALL_OW 67
// for un in tmp do
99028: LD_ADDR_VAR 0 2
99032: PUSH
99033: LD_VAR 0 3
99037: PUSH
99038: FOR_IN
99039: IFFALSE 99113
// begin if IsDead ( un ) then
99041: LD_VAR 0 2
99045: PPUSH
99046: CALL_OW 301
99050: IFFALSE 99070
// begin tmp := tmp diff un ;
99052: LD_ADDR_VAR 0 3
99056: PUSH
99057: LD_VAR 0 3
99061: PUSH
99062: LD_VAR 0 2
99066: DIFF
99067: ST_TO_ADDR
// continue ;
99068: GO 99038
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99070: LD_VAR 0 2
99074: PPUSH
99075: LD_INT 3
99077: PUSH
99078: LD_INT 22
99080: PUSH
99081: LD_INT 0
99083: PUSH
99084: EMPTY
99085: LIST
99086: LIST
99087: PUSH
99088: EMPTY
99089: LIST
99090: LIST
99091: PPUSH
99092: CALL_OW 69
99096: PPUSH
99097: LD_VAR 0 2
99101: PPUSH
99102: CALL_OW 74
99106: PPUSH
99107: CALL_OW 115
// end ;
99111: GO 99038
99113: POP
99114: POP
// until not tmp ;
99115: LD_VAR 0 3
99119: NOT
99120: IFFALSE 99021
// end ;
99122: PPOPN 3
99124: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99125: LD_EXP 98
99129: PUSH
99130: LD_EXP 123
99134: AND
99135: IFFALSE 99189
99137: GO 99139
99139: DISABLE
// begin ToLua ( displayTroll(); ) ;
99140: LD_STRING displayTroll();
99142: PPUSH
99143: CALL_OW 559
// wait ( 3 3$00 ) ;
99147: LD_INT 6300
99149: PPUSH
99150: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99154: LD_STRING hideTroll();
99156: PPUSH
99157: CALL_OW 559
// wait ( 1 1$00 ) ;
99161: LD_INT 2100
99163: PPUSH
99164: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99168: LD_STRING displayTroll();
99170: PPUSH
99171: CALL_OW 559
// wait ( 1 1$00 ) ;
99175: LD_INT 2100
99177: PPUSH
99178: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99182: LD_STRING hideTroll();
99184: PPUSH
99185: CALL_OW 559
// end ;
99189: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99190: LD_EXP 98
99194: PUSH
99195: LD_EXP 124
99199: AND
99200: IFFALSE 99263
99202: GO 99204
99204: DISABLE
99205: LD_INT 0
99207: PPUSH
// begin p := 0 ;
99208: LD_ADDR_VAR 0 1
99212: PUSH
99213: LD_INT 0
99215: ST_TO_ADDR
// repeat game_speed := 1 ;
99216: LD_ADDR_OWVAR 65
99220: PUSH
99221: LD_INT 1
99223: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99224: LD_INT 35
99226: PPUSH
99227: CALL_OW 67
// p := p + 1 ;
99231: LD_ADDR_VAR 0 1
99235: PUSH
99236: LD_VAR 0 1
99240: PUSH
99241: LD_INT 1
99243: PLUS
99244: ST_TO_ADDR
// until p >= 60 ;
99245: LD_VAR 0 1
99249: PUSH
99250: LD_INT 60
99252: GREATEREQUAL
99253: IFFALSE 99216
// game_speed := 4 ;
99255: LD_ADDR_OWVAR 65
99259: PUSH
99260: LD_INT 4
99262: ST_TO_ADDR
// end ;
99263: PPOPN 1
99265: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99266: LD_EXP 98
99270: PUSH
99271: LD_EXP 125
99275: AND
99276: IFFALSE 99422
99278: GO 99280
99280: DISABLE
99281: LD_INT 0
99283: PPUSH
99284: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99285: LD_ADDR_VAR 0 1
99289: PUSH
99290: LD_INT 22
99292: PUSH
99293: LD_OWVAR 2
99297: PUSH
99298: EMPTY
99299: LIST
99300: LIST
99301: PUSH
99302: LD_INT 2
99304: PUSH
99305: LD_INT 30
99307: PUSH
99308: LD_INT 0
99310: PUSH
99311: EMPTY
99312: LIST
99313: LIST
99314: PUSH
99315: LD_INT 30
99317: PUSH
99318: LD_INT 1
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: PUSH
99325: EMPTY
99326: LIST
99327: LIST
99328: LIST
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: PPUSH
99334: CALL_OW 69
99338: ST_TO_ADDR
// if not depot then
99339: LD_VAR 0 1
99343: NOT
99344: IFFALSE 99348
// exit ;
99346: GO 99422
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99348: LD_ADDR_VAR 0 2
99352: PUSH
99353: LD_VAR 0 1
99357: PUSH
99358: LD_INT 1
99360: PPUSH
99361: LD_VAR 0 1
99365: PPUSH
99366: CALL_OW 12
99370: ARRAY
99371: PPUSH
99372: CALL_OW 274
99376: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99377: LD_VAR 0 2
99381: PPUSH
99382: LD_INT 1
99384: PPUSH
99385: LD_INT 0
99387: PPUSH
99388: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99392: LD_VAR 0 2
99396: PPUSH
99397: LD_INT 2
99399: PPUSH
99400: LD_INT 0
99402: PPUSH
99403: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99407: LD_VAR 0 2
99411: PPUSH
99412: LD_INT 3
99414: PPUSH
99415: LD_INT 0
99417: PPUSH
99418: CALL_OW 277
// end ;
99422: PPOPN 2
99424: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99425: LD_EXP 98
99429: PUSH
99430: LD_EXP 126
99434: AND
99435: IFFALSE 99532
99437: GO 99439
99439: DISABLE
99440: LD_INT 0
99442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99443: LD_ADDR_VAR 0 1
99447: PUSH
99448: LD_INT 22
99450: PUSH
99451: LD_OWVAR 2
99455: PUSH
99456: EMPTY
99457: LIST
99458: LIST
99459: PUSH
99460: LD_INT 21
99462: PUSH
99463: LD_INT 1
99465: PUSH
99466: EMPTY
99467: LIST
99468: LIST
99469: PUSH
99470: LD_INT 3
99472: PUSH
99473: LD_INT 23
99475: PUSH
99476: LD_INT 0
99478: PUSH
99479: EMPTY
99480: LIST
99481: LIST
99482: PUSH
99483: EMPTY
99484: LIST
99485: LIST
99486: PUSH
99487: EMPTY
99488: LIST
99489: LIST
99490: LIST
99491: PPUSH
99492: CALL_OW 69
99496: ST_TO_ADDR
// if not tmp then
99497: LD_VAR 0 1
99501: NOT
99502: IFFALSE 99506
// exit ;
99504: GO 99532
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99506: LD_VAR 0 1
99510: PUSH
99511: LD_INT 1
99513: PPUSH
99514: LD_VAR 0 1
99518: PPUSH
99519: CALL_OW 12
99523: ARRAY
99524: PPUSH
99525: LD_INT 200
99527: PPUSH
99528: CALL_OW 234
// end ;
99532: PPOPN 1
99534: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99535: LD_EXP 98
99539: PUSH
99540: LD_EXP 127
99544: AND
99545: IFFALSE 99624
99547: GO 99549
99549: DISABLE
99550: LD_INT 0
99552: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99553: LD_ADDR_VAR 0 1
99557: PUSH
99558: LD_INT 22
99560: PUSH
99561: LD_OWVAR 2
99565: PUSH
99566: EMPTY
99567: LIST
99568: LIST
99569: PUSH
99570: LD_INT 21
99572: PUSH
99573: LD_INT 2
99575: PUSH
99576: EMPTY
99577: LIST
99578: LIST
99579: PUSH
99580: EMPTY
99581: LIST
99582: LIST
99583: PPUSH
99584: CALL_OW 69
99588: ST_TO_ADDR
// if not tmp then
99589: LD_VAR 0 1
99593: NOT
99594: IFFALSE 99598
// exit ;
99596: GO 99624
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99598: LD_VAR 0 1
99602: PUSH
99603: LD_INT 1
99605: PPUSH
99606: LD_VAR 0 1
99610: PPUSH
99611: CALL_OW 12
99615: ARRAY
99616: PPUSH
99617: LD_INT 60
99619: PPUSH
99620: CALL_OW 234
// end ;
99624: PPOPN 1
99626: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99627: LD_EXP 98
99631: PUSH
99632: LD_EXP 128
99636: AND
99637: IFFALSE 99736
99639: GO 99641
99641: DISABLE
99642: LD_INT 0
99644: PPUSH
99645: PPUSH
// begin enable ;
99646: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99647: LD_ADDR_VAR 0 1
99651: PUSH
99652: LD_INT 22
99654: PUSH
99655: LD_OWVAR 2
99659: PUSH
99660: EMPTY
99661: LIST
99662: LIST
99663: PUSH
99664: LD_INT 61
99666: PUSH
99667: EMPTY
99668: LIST
99669: PUSH
99670: LD_INT 33
99672: PUSH
99673: LD_INT 2
99675: PUSH
99676: EMPTY
99677: LIST
99678: LIST
99679: PUSH
99680: EMPTY
99681: LIST
99682: LIST
99683: LIST
99684: PPUSH
99685: CALL_OW 69
99689: ST_TO_ADDR
// if not tmp then
99690: LD_VAR 0 1
99694: NOT
99695: IFFALSE 99699
// exit ;
99697: GO 99736
// for i in tmp do
99699: LD_ADDR_VAR 0 2
99703: PUSH
99704: LD_VAR 0 1
99708: PUSH
99709: FOR_IN
99710: IFFALSE 99734
// if IsControledBy ( i ) then
99712: LD_VAR 0 2
99716: PPUSH
99717: CALL_OW 312
99721: IFFALSE 99732
// ComUnlink ( i ) ;
99723: LD_VAR 0 2
99727: PPUSH
99728: CALL_OW 136
99732: GO 99709
99734: POP
99735: POP
// end ;
99736: PPOPN 2
99738: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99739: LD_EXP 98
99743: PUSH
99744: LD_EXP 129
99748: AND
99749: IFFALSE 99889
99751: GO 99753
99753: DISABLE
99754: LD_INT 0
99756: PPUSH
99757: PPUSH
// begin ToLua ( displayPowell(); ) ;
99758: LD_STRING displayPowell();
99760: PPUSH
99761: CALL_OW 559
// uc_side := 0 ;
99765: LD_ADDR_OWVAR 20
99769: PUSH
99770: LD_INT 0
99772: ST_TO_ADDR
// uc_nation := 2 ;
99773: LD_ADDR_OWVAR 21
99777: PUSH
99778: LD_INT 2
99780: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99781: LD_ADDR_OWVAR 37
99785: PUSH
99786: LD_INT 14
99788: ST_TO_ADDR
// vc_engine := engine_siberite ;
99789: LD_ADDR_OWVAR 39
99793: PUSH
99794: LD_INT 3
99796: ST_TO_ADDR
// vc_control := control_apeman ;
99797: LD_ADDR_OWVAR 38
99801: PUSH
99802: LD_INT 5
99804: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99805: LD_ADDR_OWVAR 40
99809: PUSH
99810: LD_INT 29
99812: ST_TO_ADDR
// un := CreateVehicle ;
99813: LD_ADDR_VAR 0 2
99817: PUSH
99818: CALL_OW 45
99822: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99823: LD_VAR 0 2
99827: PPUSH
99828: LD_INT 1
99830: PPUSH
99831: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99835: LD_INT 35
99837: PPUSH
99838: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99842: LD_VAR 0 2
99846: PPUSH
99847: LD_INT 22
99849: PUSH
99850: LD_OWVAR 2
99854: PUSH
99855: EMPTY
99856: LIST
99857: LIST
99858: PPUSH
99859: CALL_OW 69
99863: PPUSH
99864: LD_VAR 0 2
99868: PPUSH
99869: CALL_OW 74
99873: PPUSH
99874: CALL_OW 115
// until IsDead ( un ) ;
99878: LD_VAR 0 2
99882: PPUSH
99883: CALL_OW 301
99887: IFFALSE 99835
// end ;
99889: PPOPN 2
99891: END
// every 0 0$1 trigger StreamModeActive and sStu do
99892: LD_EXP 98
99896: PUSH
99897: LD_EXP 137
99901: AND
99902: IFFALSE 99918
99904: GO 99906
99906: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99907: LD_STRING displayStucuk();
99909: PPUSH
99910: CALL_OW 559
// ResetFog ;
99914: CALL_OW 335
// end ;
99918: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99919: LD_EXP 98
99923: PUSH
99924: LD_EXP 130
99928: AND
99929: IFFALSE 100070
99931: GO 99933
99933: DISABLE
99934: LD_INT 0
99936: PPUSH
99937: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99938: LD_ADDR_VAR 0 2
99942: PUSH
99943: LD_INT 22
99945: PUSH
99946: LD_OWVAR 2
99950: PUSH
99951: EMPTY
99952: LIST
99953: LIST
99954: PUSH
99955: LD_INT 21
99957: PUSH
99958: LD_INT 1
99960: PUSH
99961: EMPTY
99962: LIST
99963: LIST
99964: PUSH
99965: EMPTY
99966: LIST
99967: LIST
99968: PPUSH
99969: CALL_OW 69
99973: ST_TO_ADDR
// if not tmp then
99974: LD_VAR 0 2
99978: NOT
99979: IFFALSE 99983
// exit ;
99981: GO 100070
// un := tmp [ rand ( 1 , tmp ) ] ;
99983: LD_ADDR_VAR 0 1
99987: PUSH
99988: LD_VAR 0 2
99992: PUSH
99993: LD_INT 1
99995: PPUSH
99996: LD_VAR 0 2
100000: PPUSH
100001: CALL_OW 12
100005: ARRAY
100006: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100007: LD_VAR 0 1
100011: PPUSH
100012: LD_INT 0
100014: PPUSH
100015: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100019: LD_VAR 0 1
100023: PPUSH
100024: LD_OWVAR 3
100028: PUSH
100029: LD_VAR 0 1
100033: DIFF
100034: PPUSH
100035: LD_VAR 0 1
100039: PPUSH
100040: CALL_OW 74
100044: PPUSH
100045: CALL_OW 115
// wait ( 0 0$20 ) ;
100049: LD_INT 700
100051: PPUSH
100052: CALL_OW 67
// SetSide ( un , your_side ) ;
100056: LD_VAR 0 1
100060: PPUSH
100061: LD_OWVAR 2
100065: PPUSH
100066: CALL_OW 235
// end ;
100070: PPOPN 2
100072: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100073: LD_EXP 98
100077: PUSH
100078: LD_EXP 131
100082: AND
100083: IFFALSE 100189
100085: GO 100087
100087: DISABLE
100088: LD_INT 0
100090: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100091: LD_ADDR_VAR 0 1
100095: PUSH
100096: LD_INT 22
100098: PUSH
100099: LD_OWVAR 2
100103: PUSH
100104: EMPTY
100105: LIST
100106: LIST
100107: PUSH
100108: LD_INT 2
100110: PUSH
100111: LD_INT 30
100113: PUSH
100114: LD_INT 0
100116: PUSH
100117: EMPTY
100118: LIST
100119: LIST
100120: PUSH
100121: LD_INT 30
100123: PUSH
100124: LD_INT 1
100126: PUSH
100127: EMPTY
100128: LIST
100129: LIST
100130: PUSH
100131: EMPTY
100132: LIST
100133: LIST
100134: LIST
100135: PUSH
100136: EMPTY
100137: LIST
100138: LIST
100139: PPUSH
100140: CALL_OW 69
100144: ST_TO_ADDR
// if not depot then
100145: LD_VAR 0 1
100149: NOT
100150: IFFALSE 100154
// exit ;
100152: GO 100189
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100154: LD_VAR 0 1
100158: PUSH
100159: LD_INT 1
100161: ARRAY
100162: PPUSH
100163: CALL_OW 250
100167: PPUSH
100168: LD_VAR 0 1
100172: PUSH
100173: LD_INT 1
100175: ARRAY
100176: PPUSH
100177: CALL_OW 251
100181: PPUSH
100182: LD_INT 70
100184: PPUSH
100185: CALL_OW 495
// end ;
100189: PPOPN 1
100191: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100192: LD_EXP 98
100196: PUSH
100197: LD_EXP 132
100201: AND
100202: IFFALSE 100413
100204: GO 100206
100206: DISABLE
100207: LD_INT 0
100209: PPUSH
100210: PPUSH
100211: PPUSH
100212: PPUSH
100213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100214: LD_ADDR_VAR 0 5
100218: PUSH
100219: LD_INT 22
100221: PUSH
100222: LD_OWVAR 2
100226: PUSH
100227: EMPTY
100228: LIST
100229: LIST
100230: PUSH
100231: LD_INT 21
100233: PUSH
100234: LD_INT 1
100236: PUSH
100237: EMPTY
100238: LIST
100239: LIST
100240: PUSH
100241: EMPTY
100242: LIST
100243: LIST
100244: PPUSH
100245: CALL_OW 69
100249: ST_TO_ADDR
// if not tmp then
100250: LD_VAR 0 5
100254: NOT
100255: IFFALSE 100259
// exit ;
100257: GO 100413
// for i in tmp do
100259: LD_ADDR_VAR 0 1
100263: PUSH
100264: LD_VAR 0 5
100268: PUSH
100269: FOR_IN
100270: IFFALSE 100411
// begin d := rand ( 0 , 5 ) ;
100272: LD_ADDR_VAR 0 4
100276: PUSH
100277: LD_INT 0
100279: PPUSH
100280: LD_INT 5
100282: PPUSH
100283: CALL_OW 12
100287: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100288: LD_ADDR_VAR 0 2
100292: PUSH
100293: LD_VAR 0 1
100297: PPUSH
100298: CALL_OW 250
100302: PPUSH
100303: LD_VAR 0 4
100307: PPUSH
100308: LD_INT 3
100310: PPUSH
100311: LD_INT 12
100313: PPUSH
100314: CALL_OW 12
100318: PPUSH
100319: CALL_OW 272
100323: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100324: LD_ADDR_VAR 0 3
100328: PUSH
100329: LD_VAR 0 1
100333: PPUSH
100334: CALL_OW 251
100338: PPUSH
100339: LD_VAR 0 4
100343: PPUSH
100344: LD_INT 3
100346: PPUSH
100347: LD_INT 12
100349: PPUSH
100350: CALL_OW 12
100354: PPUSH
100355: CALL_OW 273
100359: ST_TO_ADDR
// if ValidHex ( x , y ) then
100360: LD_VAR 0 2
100364: PPUSH
100365: LD_VAR 0 3
100369: PPUSH
100370: CALL_OW 488
100374: IFFALSE 100409
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100376: LD_VAR 0 1
100380: PPUSH
100381: LD_VAR 0 2
100385: PPUSH
100386: LD_VAR 0 3
100390: PPUSH
100391: LD_INT 3
100393: PPUSH
100394: LD_INT 6
100396: PPUSH
100397: CALL_OW 12
100401: PPUSH
100402: LD_INT 1
100404: PPUSH
100405: CALL_OW 483
// end ;
100409: GO 100269
100411: POP
100412: POP
// end ;
100413: PPOPN 5
100415: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100416: LD_EXP 98
100420: PUSH
100421: LD_EXP 133
100425: AND
100426: IFFALSE 100520
100428: GO 100430
100430: DISABLE
100431: LD_INT 0
100433: PPUSH
100434: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100435: LD_ADDR_VAR 0 2
100439: PUSH
100440: LD_INT 22
100442: PUSH
100443: LD_OWVAR 2
100447: PUSH
100448: EMPTY
100449: LIST
100450: LIST
100451: PUSH
100452: LD_INT 32
100454: PUSH
100455: LD_INT 1
100457: PUSH
100458: EMPTY
100459: LIST
100460: LIST
100461: PUSH
100462: LD_INT 21
100464: PUSH
100465: LD_INT 2
100467: PUSH
100468: EMPTY
100469: LIST
100470: LIST
100471: PUSH
100472: EMPTY
100473: LIST
100474: LIST
100475: LIST
100476: PPUSH
100477: CALL_OW 69
100481: ST_TO_ADDR
// if not tmp then
100482: LD_VAR 0 2
100486: NOT
100487: IFFALSE 100491
// exit ;
100489: GO 100520
// for i in tmp do
100491: LD_ADDR_VAR 0 1
100495: PUSH
100496: LD_VAR 0 2
100500: PUSH
100501: FOR_IN
100502: IFFALSE 100518
// SetFuel ( i , 0 ) ;
100504: LD_VAR 0 1
100508: PPUSH
100509: LD_INT 0
100511: PPUSH
100512: CALL_OW 240
100516: GO 100501
100518: POP
100519: POP
// end ;
100520: PPOPN 2
100522: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100523: LD_EXP 98
100527: PUSH
100528: LD_EXP 134
100532: AND
100533: IFFALSE 100599
100535: GO 100537
100537: DISABLE
100538: LD_INT 0
100540: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100541: LD_ADDR_VAR 0 1
100545: PUSH
100546: LD_INT 22
100548: PUSH
100549: LD_OWVAR 2
100553: PUSH
100554: EMPTY
100555: LIST
100556: LIST
100557: PUSH
100558: LD_INT 30
100560: PUSH
100561: LD_INT 29
100563: PUSH
100564: EMPTY
100565: LIST
100566: LIST
100567: PUSH
100568: EMPTY
100569: LIST
100570: LIST
100571: PPUSH
100572: CALL_OW 69
100576: ST_TO_ADDR
// if not tmp then
100577: LD_VAR 0 1
100581: NOT
100582: IFFALSE 100586
// exit ;
100584: GO 100599
// DestroyUnit ( tmp [ 1 ] ) ;
100586: LD_VAR 0 1
100590: PUSH
100591: LD_INT 1
100593: ARRAY
100594: PPUSH
100595: CALL_OW 65
// end ;
100599: PPOPN 1
100601: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100602: LD_EXP 98
100606: PUSH
100607: LD_EXP 136
100611: AND
100612: IFFALSE 100741
100614: GO 100616
100616: DISABLE
100617: LD_INT 0
100619: PPUSH
// begin uc_side := 0 ;
100620: LD_ADDR_OWVAR 20
100624: PUSH
100625: LD_INT 0
100627: ST_TO_ADDR
// uc_nation := nation_arabian ;
100628: LD_ADDR_OWVAR 21
100632: PUSH
100633: LD_INT 2
100635: ST_TO_ADDR
// hc_gallery :=  ;
100636: LD_ADDR_OWVAR 33
100640: PUSH
100641: LD_STRING 
100643: ST_TO_ADDR
// hc_name :=  ;
100644: LD_ADDR_OWVAR 26
100648: PUSH
100649: LD_STRING 
100651: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100652: LD_INT 1
100654: PPUSH
100655: LD_INT 11
100657: PPUSH
100658: LD_INT 10
100660: PPUSH
100661: CALL_OW 380
// un := CreateHuman ;
100665: LD_ADDR_VAR 0 1
100669: PUSH
100670: CALL_OW 44
100674: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100675: LD_VAR 0 1
100679: PPUSH
100680: LD_INT 1
100682: PPUSH
100683: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100687: LD_INT 35
100689: PPUSH
100690: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100694: LD_VAR 0 1
100698: PPUSH
100699: LD_INT 22
100701: PUSH
100702: LD_OWVAR 2
100706: PUSH
100707: EMPTY
100708: LIST
100709: LIST
100710: PPUSH
100711: CALL_OW 69
100715: PPUSH
100716: LD_VAR 0 1
100720: PPUSH
100721: CALL_OW 74
100725: PPUSH
100726: CALL_OW 115
// until IsDead ( un ) ;
100730: LD_VAR 0 1
100734: PPUSH
100735: CALL_OW 301
100739: IFFALSE 100687
// end ;
100741: PPOPN 1
100743: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100744: LD_EXP 98
100748: PUSH
100749: LD_EXP 138
100753: AND
100754: IFFALSE 100766
100756: GO 100758
100758: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100759: LD_STRING earthquake(getX(game), 0, 32)
100761: PPUSH
100762: CALL_OW 559
100766: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100767: LD_EXP 98
100771: PUSH
100772: LD_EXP 139
100776: AND
100777: IFFALSE 100868
100779: GO 100781
100781: DISABLE
100782: LD_INT 0
100784: PPUSH
// begin enable ;
100785: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100786: LD_ADDR_VAR 0 1
100790: PUSH
100791: LD_INT 22
100793: PUSH
100794: LD_OWVAR 2
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: PUSH
100803: LD_INT 21
100805: PUSH
100806: LD_INT 2
100808: PUSH
100809: EMPTY
100810: LIST
100811: LIST
100812: PUSH
100813: LD_INT 33
100815: PUSH
100816: LD_INT 3
100818: PUSH
100819: EMPTY
100820: LIST
100821: LIST
100822: PUSH
100823: EMPTY
100824: LIST
100825: LIST
100826: LIST
100827: PPUSH
100828: CALL_OW 69
100832: ST_TO_ADDR
// if not tmp then
100833: LD_VAR 0 1
100837: NOT
100838: IFFALSE 100842
// exit ;
100840: GO 100868
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100842: LD_VAR 0 1
100846: PUSH
100847: LD_INT 1
100849: PPUSH
100850: LD_VAR 0 1
100854: PPUSH
100855: CALL_OW 12
100859: ARRAY
100860: PPUSH
100861: LD_INT 1
100863: PPUSH
100864: CALL_OW 234
// end ;
100868: PPOPN 1
100870: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100871: LD_EXP 98
100875: PUSH
100876: LD_EXP 140
100880: AND
100881: IFFALSE 101022
100883: GO 100885
100885: DISABLE
100886: LD_INT 0
100888: PPUSH
100889: PPUSH
100890: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100891: LD_ADDR_VAR 0 3
100895: PUSH
100896: LD_INT 22
100898: PUSH
100899: LD_OWVAR 2
100903: PUSH
100904: EMPTY
100905: LIST
100906: LIST
100907: PUSH
100908: LD_INT 25
100910: PUSH
100911: LD_INT 1
100913: PUSH
100914: EMPTY
100915: LIST
100916: LIST
100917: PUSH
100918: EMPTY
100919: LIST
100920: LIST
100921: PPUSH
100922: CALL_OW 69
100926: ST_TO_ADDR
// if not tmp then
100927: LD_VAR 0 3
100931: NOT
100932: IFFALSE 100936
// exit ;
100934: GO 101022
// un := tmp [ rand ( 1 , tmp ) ] ;
100936: LD_ADDR_VAR 0 2
100940: PUSH
100941: LD_VAR 0 3
100945: PUSH
100946: LD_INT 1
100948: PPUSH
100949: LD_VAR 0 3
100953: PPUSH
100954: CALL_OW 12
100958: ARRAY
100959: ST_TO_ADDR
// if Crawls ( un ) then
100960: LD_VAR 0 2
100964: PPUSH
100965: CALL_OW 318
100969: IFFALSE 100980
// ComWalk ( un ) ;
100971: LD_VAR 0 2
100975: PPUSH
100976: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100980: LD_VAR 0 2
100984: PPUSH
100985: LD_INT 9
100987: PPUSH
100988: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100992: LD_INT 28
100994: PPUSH
100995: LD_OWVAR 2
100999: PPUSH
101000: LD_INT 2
101002: PPUSH
101003: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101007: LD_INT 29
101009: PPUSH
101010: LD_OWVAR 2
101014: PPUSH
101015: LD_INT 2
101017: PPUSH
101018: CALL_OW 322
// end ;
101022: PPOPN 3
101024: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101025: LD_EXP 98
101029: PUSH
101030: LD_EXP 141
101034: AND
101035: IFFALSE 101146
101037: GO 101039
101039: DISABLE
101040: LD_INT 0
101042: PPUSH
101043: PPUSH
101044: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101045: LD_ADDR_VAR 0 3
101049: PUSH
101050: LD_INT 22
101052: PUSH
101053: LD_OWVAR 2
101057: PUSH
101058: EMPTY
101059: LIST
101060: LIST
101061: PUSH
101062: LD_INT 25
101064: PUSH
101065: LD_INT 1
101067: PUSH
101068: EMPTY
101069: LIST
101070: LIST
101071: PUSH
101072: EMPTY
101073: LIST
101074: LIST
101075: PPUSH
101076: CALL_OW 69
101080: ST_TO_ADDR
// if not tmp then
101081: LD_VAR 0 3
101085: NOT
101086: IFFALSE 101090
// exit ;
101088: GO 101146
// un := tmp [ rand ( 1 , tmp ) ] ;
101090: LD_ADDR_VAR 0 2
101094: PUSH
101095: LD_VAR 0 3
101099: PUSH
101100: LD_INT 1
101102: PPUSH
101103: LD_VAR 0 3
101107: PPUSH
101108: CALL_OW 12
101112: ARRAY
101113: ST_TO_ADDR
// if Crawls ( un ) then
101114: LD_VAR 0 2
101118: PPUSH
101119: CALL_OW 318
101123: IFFALSE 101134
// ComWalk ( un ) ;
101125: LD_VAR 0 2
101129: PPUSH
101130: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101134: LD_VAR 0 2
101138: PPUSH
101139: LD_INT 8
101141: PPUSH
101142: CALL_OW 336
// end ;
101146: PPOPN 3
101148: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101149: LD_EXP 98
101153: PUSH
101154: LD_EXP 142
101158: AND
101159: IFFALSE 101303
101161: GO 101163
101163: DISABLE
101164: LD_INT 0
101166: PPUSH
101167: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101168: LD_ADDR_VAR 0 2
101172: PUSH
101173: LD_INT 22
101175: PUSH
101176: LD_OWVAR 2
101180: PUSH
101181: EMPTY
101182: LIST
101183: LIST
101184: PUSH
101185: LD_INT 21
101187: PUSH
101188: LD_INT 2
101190: PUSH
101191: EMPTY
101192: LIST
101193: LIST
101194: PUSH
101195: LD_INT 2
101197: PUSH
101198: LD_INT 34
101200: PUSH
101201: LD_INT 12
101203: PUSH
101204: EMPTY
101205: LIST
101206: LIST
101207: PUSH
101208: LD_INT 34
101210: PUSH
101211: LD_INT 51
101213: PUSH
101214: EMPTY
101215: LIST
101216: LIST
101217: PUSH
101218: LD_INT 34
101220: PUSH
101221: LD_INT 32
101223: PUSH
101224: EMPTY
101225: LIST
101226: LIST
101227: PUSH
101228: EMPTY
101229: LIST
101230: LIST
101231: LIST
101232: LIST
101233: PUSH
101234: EMPTY
101235: LIST
101236: LIST
101237: LIST
101238: PPUSH
101239: CALL_OW 69
101243: ST_TO_ADDR
// if not tmp then
101244: LD_VAR 0 2
101248: NOT
101249: IFFALSE 101253
// exit ;
101251: GO 101303
// for i in tmp do
101253: LD_ADDR_VAR 0 1
101257: PUSH
101258: LD_VAR 0 2
101262: PUSH
101263: FOR_IN
101264: IFFALSE 101301
// if GetCargo ( i , mat_artifact ) = 0 then
101266: LD_VAR 0 1
101270: PPUSH
101271: LD_INT 4
101273: PPUSH
101274: CALL_OW 289
101278: PUSH
101279: LD_INT 0
101281: EQUAL
101282: IFFALSE 101299
// SetCargo ( i , mat_siberit , 100 ) ;
101284: LD_VAR 0 1
101288: PPUSH
101289: LD_INT 3
101291: PPUSH
101292: LD_INT 100
101294: PPUSH
101295: CALL_OW 290
101299: GO 101263
101301: POP
101302: POP
// end ;
101303: PPOPN 2
101305: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101306: LD_EXP 98
101310: PUSH
101311: LD_EXP 143
101315: AND
101316: IFFALSE 101499
101318: GO 101320
101320: DISABLE
101321: LD_INT 0
101323: PPUSH
101324: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101325: LD_ADDR_VAR 0 2
101329: PUSH
101330: LD_INT 22
101332: PUSH
101333: LD_OWVAR 2
101337: PUSH
101338: EMPTY
101339: LIST
101340: LIST
101341: PPUSH
101342: CALL_OW 69
101346: ST_TO_ADDR
// if not tmp then
101347: LD_VAR 0 2
101351: NOT
101352: IFFALSE 101356
// exit ;
101354: GO 101499
// for i := 1 to 2 do
101356: LD_ADDR_VAR 0 1
101360: PUSH
101361: DOUBLE
101362: LD_INT 1
101364: DEC
101365: ST_TO_ADDR
101366: LD_INT 2
101368: PUSH
101369: FOR_TO
101370: IFFALSE 101497
// begin uc_side := your_side ;
101372: LD_ADDR_OWVAR 20
101376: PUSH
101377: LD_OWVAR 2
101381: ST_TO_ADDR
// uc_nation := nation_american ;
101382: LD_ADDR_OWVAR 21
101386: PUSH
101387: LD_INT 1
101389: ST_TO_ADDR
// vc_chassis := us_morphling ;
101390: LD_ADDR_OWVAR 37
101394: PUSH
101395: LD_INT 5
101397: ST_TO_ADDR
// vc_engine := engine_siberite ;
101398: LD_ADDR_OWVAR 39
101402: PUSH
101403: LD_INT 3
101405: ST_TO_ADDR
// vc_control := control_computer ;
101406: LD_ADDR_OWVAR 38
101410: PUSH
101411: LD_INT 3
101413: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101414: LD_ADDR_OWVAR 40
101418: PUSH
101419: LD_INT 10
101421: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101422: LD_VAR 0 2
101426: PUSH
101427: LD_INT 1
101429: ARRAY
101430: PPUSH
101431: CALL_OW 310
101435: NOT
101436: IFFALSE 101483
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101438: CALL_OW 45
101442: PPUSH
101443: LD_VAR 0 2
101447: PUSH
101448: LD_INT 1
101450: ARRAY
101451: PPUSH
101452: CALL_OW 250
101456: PPUSH
101457: LD_VAR 0 2
101461: PUSH
101462: LD_INT 1
101464: ARRAY
101465: PPUSH
101466: CALL_OW 251
101470: PPUSH
101471: LD_INT 12
101473: PPUSH
101474: LD_INT 1
101476: PPUSH
101477: CALL_OW 50
101481: GO 101495
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101483: CALL_OW 45
101487: PPUSH
101488: LD_INT 1
101490: PPUSH
101491: CALL_OW 51
// end ;
101495: GO 101369
101497: POP
101498: POP
// end ;
101499: PPOPN 2
101501: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101502: LD_EXP 98
101506: PUSH
101507: LD_EXP 144
101511: AND
101512: IFFALSE 101734
101514: GO 101516
101516: DISABLE
101517: LD_INT 0
101519: PPUSH
101520: PPUSH
101521: PPUSH
101522: PPUSH
101523: PPUSH
101524: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101525: LD_ADDR_VAR 0 6
101529: PUSH
101530: LD_INT 22
101532: PUSH
101533: LD_OWVAR 2
101537: PUSH
101538: EMPTY
101539: LIST
101540: LIST
101541: PUSH
101542: LD_INT 21
101544: PUSH
101545: LD_INT 1
101547: PUSH
101548: EMPTY
101549: LIST
101550: LIST
101551: PUSH
101552: LD_INT 3
101554: PUSH
101555: LD_INT 23
101557: PUSH
101558: LD_INT 0
101560: PUSH
101561: EMPTY
101562: LIST
101563: LIST
101564: PUSH
101565: EMPTY
101566: LIST
101567: LIST
101568: PUSH
101569: EMPTY
101570: LIST
101571: LIST
101572: LIST
101573: PPUSH
101574: CALL_OW 69
101578: ST_TO_ADDR
// if not tmp then
101579: LD_VAR 0 6
101583: NOT
101584: IFFALSE 101588
// exit ;
101586: GO 101734
// s1 := rand ( 1 , 4 ) ;
101588: LD_ADDR_VAR 0 2
101592: PUSH
101593: LD_INT 1
101595: PPUSH
101596: LD_INT 4
101598: PPUSH
101599: CALL_OW 12
101603: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101604: LD_ADDR_VAR 0 4
101608: PUSH
101609: LD_VAR 0 6
101613: PUSH
101614: LD_INT 1
101616: ARRAY
101617: PPUSH
101618: LD_VAR 0 2
101622: PPUSH
101623: CALL_OW 259
101627: ST_TO_ADDR
// if s1 = 1 then
101628: LD_VAR 0 2
101632: PUSH
101633: LD_INT 1
101635: EQUAL
101636: IFFALSE 101656
// s2 := rand ( 2 , 4 ) else
101638: LD_ADDR_VAR 0 3
101642: PUSH
101643: LD_INT 2
101645: PPUSH
101646: LD_INT 4
101648: PPUSH
101649: CALL_OW 12
101653: ST_TO_ADDR
101654: GO 101664
// s2 := 1 ;
101656: LD_ADDR_VAR 0 3
101660: PUSH
101661: LD_INT 1
101663: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101664: LD_ADDR_VAR 0 5
101668: PUSH
101669: LD_VAR 0 6
101673: PUSH
101674: LD_INT 1
101676: ARRAY
101677: PPUSH
101678: LD_VAR 0 3
101682: PPUSH
101683: CALL_OW 259
101687: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101688: LD_VAR 0 6
101692: PUSH
101693: LD_INT 1
101695: ARRAY
101696: PPUSH
101697: LD_VAR 0 2
101701: PPUSH
101702: LD_VAR 0 5
101706: PPUSH
101707: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101711: LD_VAR 0 6
101715: PUSH
101716: LD_INT 1
101718: ARRAY
101719: PPUSH
101720: LD_VAR 0 3
101724: PPUSH
101725: LD_VAR 0 4
101729: PPUSH
101730: CALL_OW 237
// end ;
101734: PPOPN 6
101736: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101737: LD_EXP 98
101741: PUSH
101742: LD_EXP 145
101746: AND
101747: IFFALSE 101826
101749: GO 101751
101751: DISABLE
101752: LD_INT 0
101754: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101755: LD_ADDR_VAR 0 1
101759: PUSH
101760: LD_INT 22
101762: PUSH
101763: LD_OWVAR 2
101767: PUSH
101768: EMPTY
101769: LIST
101770: LIST
101771: PUSH
101772: LD_INT 30
101774: PUSH
101775: LD_INT 3
101777: PUSH
101778: EMPTY
101779: LIST
101780: LIST
101781: PUSH
101782: EMPTY
101783: LIST
101784: LIST
101785: PPUSH
101786: CALL_OW 69
101790: ST_TO_ADDR
// if not tmp then
101791: LD_VAR 0 1
101795: NOT
101796: IFFALSE 101800
// exit ;
101798: GO 101826
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101800: LD_VAR 0 1
101804: PUSH
101805: LD_INT 1
101807: PPUSH
101808: LD_VAR 0 1
101812: PPUSH
101813: CALL_OW 12
101817: ARRAY
101818: PPUSH
101819: LD_INT 1
101821: PPUSH
101822: CALL_OW 234
// end ;
101826: PPOPN 1
101828: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101829: LD_EXP 98
101833: PUSH
101834: LD_EXP 146
101838: AND
101839: IFFALSE 101951
101841: GO 101843
101843: DISABLE
101844: LD_INT 0
101846: PPUSH
101847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101848: LD_ADDR_VAR 0 2
101852: PUSH
101853: LD_INT 22
101855: PUSH
101856: LD_OWVAR 2
101860: PUSH
101861: EMPTY
101862: LIST
101863: LIST
101864: PUSH
101865: LD_INT 2
101867: PUSH
101868: LD_INT 30
101870: PUSH
101871: LD_INT 27
101873: PUSH
101874: EMPTY
101875: LIST
101876: LIST
101877: PUSH
101878: LD_INT 30
101880: PUSH
101881: LD_INT 26
101883: PUSH
101884: EMPTY
101885: LIST
101886: LIST
101887: PUSH
101888: LD_INT 30
101890: PUSH
101891: LD_INT 28
101893: PUSH
101894: EMPTY
101895: LIST
101896: LIST
101897: PUSH
101898: EMPTY
101899: LIST
101900: LIST
101901: LIST
101902: LIST
101903: PUSH
101904: EMPTY
101905: LIST
101906: LIST
101907: PPUSH
101908: CALL_OW 69
101912: ST_TO_ADDR
// if not tmp then
101913: LD_VAR 0 2
101917: NOT
101918: IFFALSE 101922
// exit ;
101920: GO 101951
// for i in tmp do
101922: LD_ADDR_VAR 0 1
101926: PUSH
101927: LD_VAR 0 2
101931: PUSH
101932: FOR_IN
101933: IFFALSE 101949
// SetLives ( i , 1 ) ;
101935: LD_VAR 0 1
101939: PPUSH
101940: LD_INT 1
101942: PPUSH
101943: CALL_OW 234
101947: GO 101932
101949: POP
101950: POP
// end ;
101951: PPOPN 2
101953: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101954: LD_EXP 98
101958: PUSH
101959: LD_EXP 147
101963: AND
101964: IFFALSE 102238
101966: GO 101968
101968: DISABLE
101969: LD_INT 0
101971: PPUSH
101972: PPUSH
101973: PPUSH
// begin i := rand ( 1 , 7 ) ;
101974: LD_ADDR_VAR 0 1
101978: PUSH
101979: LD_INT 1
101981: PPUSH
101982: LD_INT 7
101984: PPUSH
101985: CALL_OW 12
101989: ST_TO_ADDR
// case i of 1 :
101990: LD_VAR 0 1
101994: PUSH
101995: LD_INT 1
101997: DOUBLE
101998: EQUAL
101999: IFTRUE 102003
102001: GO 102013
102003: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102004: LD_STRING earthquake(getX(game), 0, 32)
102006: PPUSH
102007: CALL_OW 559
102011: GO 102238
102013: LD_INT 2
102015: DOUBLE
102016: EQUAL
102017: IFTRUE 102021
102019: GO 102035
102021: POP
// begin ToLua ( displayStucuk(); ) ;
102022: LD_STRING displayStucuk();
102024: PPUSH
102025: CALL_OW 559
// ResetFog ;
102029: CALL_OW 335
// end ; 3 :
102033: GO 102238
102035: LD_INT 3
102037: DOUBLE
102038: EQUAL
102039: IFTRUE 102043
102041: GO 102147
102043: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102044: LD_ADDR_VAR 0 2
102048: PUSH
102049: LD_INT 22
102051: PUSH
102052: LD_OWVAR 2
102056: PUSH
102057: EMPTY
102058: LIST
102059: LIST
102060: PUSH
102061: LD_INT 25
102063: PUSH
102064: LD_INT 1
102066: PUSH
102067: EMPTY
102068: LIST
102069: LIST
102070: PUSH
102071: EMPTY
102072: LIST
102073: LIST
102074: PPUSH
102075: CALL_OW 69
102079: ST_TO_ADDR
// if not tmp then
102080: LD_VAR 0 2
102084: NOT
102085: IFFALSE 102089
// exit ;
102087: GO 102238
// un := tmp [ rand ( 1 , tmp ) ] ;
102089: LD_ADDR_VAR 0 3
102093: PUSH
102094: LD_VAR 0 2
102098: PUSH
102099: LD_INT 1
102101: PPUSH
102102: LD_VAR 0 2
102106: PPUSH
102107: CALL_OW 12
102111: ARRAY
102112: ST_TO_ADDR
// if Crawls ( un ) then
102113: LD_VAR 0 3
102117: PPUSH
102118: CALL_OW 318
102122: IFFALSE 102133
// ComWalk ( un ) ;
102124: LD_VAR 0 3
102128: PPUSH
102129: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102133: LD_VAR 0 3
102137: PPUSH
102138: LD_INT 8
102140: PPUSH
102141: CALL_OW 336
// end ; 4 :
102145: GO 102238
102147: LD_INT 4
102149: DOUBLE
102150: EQUAL
102151: IFTRUE 102155
102153: GO 102216
102155: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102156: LD_ADDR_VAR 0 2
102160: PUSH
102161: LD_INT 22
102163: PUSH
102164: LD_OWVAR 2
102168: PUSH
102169: EMPTY
102170: LIST
102171: LIST
102172: PUSH
102173: LD_INT 30
102175: PUSH
102176: LD_INT 29
102178: PUSH
102179: EMPTY
102180: LIST
102181: LIST
102182: PUSH
102183: EMPTY
102184: LIST
102185: LIST
102186: PPUSH
102187: CALL_OW 69
102191: ST_TO_ADDR
// if not tmp then
102192: LD_VAR 0 2
102196: NOT
102197: IFFALSE 102201
// exit ;
102199: GO 102238
// DestroyUnit ( tmp [ 1 ] ) ;
102201: LD_VAR 0 2
102205: PUSH
102206: LD_INT 1
102208: ARRAY
102209: PPUSH
102210: CALL_OW 65
// end ; 5 .. 7 :
102214: GO 102238
102216: LD_INT 5
102218: DOUBLE
102219: GREATEREQUAL
102220: IFFALSE 102228
102222: LD_INT 7
102224: DOUBLE
102225: LESSEQUAL
102226: IFTRUE 102230
102228: GO 102237
102230: POP
// StreamSibBomb ; end ;
102231: CALL 98488 0 0
102235: GO 102238
102237: POP
// end ;
102238: PPOPN 3
102240: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102241: LD_EXP 98
102245: PUSH
102246: LD_EXP 148
102250: AND
102251: IFFALSE 102407
102253: GO 102255
102255: DISABLE
102256: LD_INT 0
102258: PPUSH
102259: PPUSH
102260: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102261: LD_ADDR_VAR 0 2
102265: PUSH
102266: LD_INT 81
102268: PUSH
102269: LD_OWVAR 2
102273: PUSH
102274: EMPTY
102275: LIST
102276: LIST
102277: PUSH
102278: LD_INT 2
102280: PUSH
102281: LD_INT 21
102283: PUSH
102284: LD_INT 1
102286: PUSH
102287: EMPTY
102288: LIST
102289: LIST
102290: PUSH
102291: LD_INT 21
102293: PUSH
102294: LD_INT 2
102296: PUSH
102297: EMPTY
102298: LIST
102299: LIST
102300: PUSH
102301: EMPTY
102302: LIST
102303: LIST
102304: LIST
102305: PUSH
102306: EMPTY
102307: LIST
102308: LIST
102309: PPUSH
102310: CALL_OW 69
102314: ST_TO_ADDR
// if not tmp then
102315: LD_VAR 0 2
102319: NOT
102320: IFFALSE 102324
// exit ;
102322: GO 102407
// p := 0 ;
102324: LD_ADDR_VAR 0 3
102328: PUSH
102329: LD_INT 0
102331: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102332: LD_INT 35
102334: PPUSH
102335: CALL_OW 67
// p := p + 1 ;
102339: LD_ADDR_VAR 0 3
102343: PUSH
102344: LD_VAR 0 3
102348: PUSH
102349: LD_INT 1
102351: PLUS
102352: ST_TO_ADDR
// for i in tmp do
102353: LD_ADDR_VAR 0 1
102357: PUSH
102358: LD_VAR 0 2
102362: PUSH
102363: FOR_IN
102364: IFFALSE 102395
// if GetLives ( i ) < 1000 then
102366: LD_VAR 0 1
102370: PPUSH
102371: CALL_OW 256
102375: PUSH
102376: LD_INT 1000
102378: LESS
102379: IFFALSE 102393
// SetLives ( i , 1000 ) ;
102381: LD_VAR 0 1
102385: PPUSH
102386: LD_INT 1000
102388: PPUSH
102389: CALL_OW 234
102393: GO 102363
102395: POP
102396: POP
// until p > 20 ;
102397: LD_VAR 0 3
102401: PUSH
102402: LD_INT 20
102404: GREATER
102405: IFFALSE 102332
// end ;
102407: PPOPN 3
102409: END
// every 0 0$1 trigger StreamModeActive and sTime do
102410: LD_EXP 98
102414: PUSH
102415: LD_EXP 149
102419: AND
102420: IFFALSE 102455
102422: GO 102424
102424: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102425: LD_INT 28
102427: PPUSH
102428: LD_OWVAR 2
102432: PPUSH
102433: LD_INT 2
102435: PPUSH
102436: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102440: LD_INT 30
102442: PPUSH
102443: LD_OWVAR 2
102447: PPUSH
102448: LD_INT 2
102450: PPUSH
102451: CALL_OW 322
// end ;
102455: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102456: LD_EXP 98
102460: PUSH
102461: LD_EXP 150
102465: AND
102466: IFFALSE 102587
102468: GO 102470
102470: DISABLE
102471: LD_INT 0
102473: PPUSH
102474: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102475: LD_ADDR_VAR 0 2
102479: PUSH
102480: LD_INT 22
102482: PUSH
102483: LD_OWVAR 2
102487: PUSH
102488: EMPTY
102489: LIST
102490: LIST
102491: PUSH
102492: LD_INT 21
102494: PUSH
102495: LD_INT 1
102497: PUSH
102498: EMPTY
102499: LIST
102500: LIST
102501: PUSH
102502: LD_INT 3
102504: PUSH
102505: LD_INT 23
102507: PUSH
102508: LD_INT 0
102510: PUSH
102511: EMPTY
102512: LIST
102513: LIST
102514: PUSH
102515: EMPTY
102516: LIST
102517: LIST
102518: PUSH
102519: EMPTY
102520: LIST
102521: LIST
102522: LIST
102523: PPUSH
102524: CALL_OW 69
102528: ST_TO_ADDR
// if not tmp then
102529: LD_VAR 0 2
102533: NOT
102534: IFFALSE 102538
// exit ;
102536: GO 102587
// for i in tmp do
102538: LD_ADDR_VAR 0 1
102542: PUSH
102543: LD_VAR 0 2
102547: PUSH
102548: FOR_IN
102549: IFFALSE 102585
// begin if Crawls ( i ) then
102551: LD_VAR 0 1
102555: PPUSH
102556: CALL_OW 318
102560: IFFALSE 102571
// ComWalk ( i ) ;
102562: LD_VAR 0 1
102566: PPUSH
102567: CALL_OW 138
// SetClass ( i , 2 ) ;
102571: LD_VAR 0 1
102575: PPUSH
102576: LD_INT 2
102578: PPUSH
102579: CALL_OW 336
// end ;
102583: GO 102548
102585: POP
102586: POP
// end ;
102587: PPOPN 2
102589: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102590: LD_EXP 98
102594: PUSH
102595: LD_EXP 151
102599: AND
102600: IFFALSE 102881
102602: GO 102604
102604: DISABLE
102605: LD_INT 0
102607: PPUSH
102608: PPUSH
102609: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102610: LD_OWVAR 2
102614: PPUSH
102615: LD_INT 9
102617: PPUSH
102618: LD_INT 1
102620: PPUSH
102621: LD_INT 1
102623: PPUSH
102624: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102628: LD_INT 9
102630: PPUSH
102631: LD_OWVAR 2
102635: PPUSH
102636: CALL_OW 343
// uc_side := 9 ;
102640: LD_ADDR_OWVAR 20
102644: PUSH
102645: LD_INT 9
102647: ST_TO_ADDR
// uc_nation := 2 ;
102648: LD_ADDR_OWVAR 21
102652: PUSH
102653: LD_INT 2
102655: ST_TO_ADDR
// hc_name := Dark Warrior ;
102656: LD_ADDR_OWVAR 26
102660: PUSH
102661: LD_STRING Dark Warrior
102663: ST_TO_ADDR
// hc_gallery :=  ;
102664: LD_ADDR_OWVAR 33
102668: PUSH
102669: LD_STRING 
102671: ST_TO_ADDR
// hc_noskilllimit := true ;
102672: LD_ADDR_OWVAR 76
102676: PUSH
102677: LD_INT 1
102679: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102680: LD_ADDR_OWVAR 31
102684: PUSH
102685: LD_INT 30
102687: PUSH
102688: LD_INT 30
102690: PUSH
102691: LD_INT 30
102693: PUSH
102694: LD_INT 30
102696: PUSH
102697: EMPTY
102698: LIST
102699: LIST
102700: LIST
102701: LIST
102702: ST_TO_ADDR
// un := CreateHuman ;
102703: LD_ADDR_VAR 0 3
102707: PUSH
102708: CALL_OW 44
102712: ST_TO_ADDR
// hc_noskilllimit := false ;
102713: LD_ADDR_OWVAR 76
102717: PUSH
102718: LD_INT 0
102720: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102721: LD_VAR 0 3
102725: PPUSH
102726: LD_INT 1
102728: PPUSH
102729: CALL_OW 51
// p := 0 ;
102733: LD_ADDR_VAR 0 2
102737: PUSH
102738: LD_INT 0
102740: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102741: LD_INT 35
102743: PPUSH
102744: CALL_OW 67
// p := p + 1 ;
102748: LD_ADDR_VAR 0 2
102752: PUSH
102753: LD_VAR 0 2
102757: PUSH
102758: LD_INT 1
102760: PLUS
102761: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102762: LD_VAR 0 3
102766: PPUSH
102767: CALL_OW 256
102771: PUSH
102772: LD_INT 1000
102774: LESS
102775: IFFALSE 102789
// SetLives ( un , 1000 ) ;
102777: LD_VAR 0 3
102781: PPUSH
102782: LD_INT 1000
102784: PPUSH
102785: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102789: LD_VAR 0 3
102793: PPUSH
102794: LD_INT 81
102796: PUSH
102797: LD_OWVAR 2
102801: PUSH
102802: EMPTY
102803: LIST
102804: LIST
102805: PUSH
102806: LD_INT 91
102808: PUSH
102809: LD_VAR 0 3
102813: PUSH
102814: LD_INT 30
102816: PUSH
102817: EMPTY
102818: LIST
102819: LIST
102820: LIST
102821: PUSH
102822: EMPTY
102823: LIST
102824: LIST
102825: PPUSH
102826: CALL_OW 69
102830: PPUSH
102831: LD_VAR 0 3
102835: PPUSH
102836: CALL_OW 74
102840: PPUSH
102841: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
102845: LD_VAR 0 2
102849: PUSH
102850: LD_INT 60
102852: GREATER
102853: PUSH
102854: LD_VAR 0 3
102858: PPUSH
102859: CALL_OW 301
102863: OR
102864: IFFALSE 102741
// if un then
102866: LD_VAR 0 3
102870: IFFALSE 102881
// RemoveUnit ( un ) ;
102872: LD_VAR 0 3
102876: PPUSH
102877: CALL_OW 64
// end ;
102881: PPOPN 3
102883: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102884: LD_INT 0
102886: PPUSH
// case cmd of 301 :
102887: LD_VAR 0 1
102891: PUSH
102892: LD_INT 301
102894: DOUBLE
102895: EQUAL
102896: IFTRUE 102900
102898: GO 102932
102900: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102901: LD_VAR 0 6
102905: PPUSH
102906: LD_VAR 0 7
102910: PPUSH
102911: LD_VAR 0 8
102915: PPUSH
102916: LD_VAR 0 4
102920: PPUSH
102921: LD_VAR 0 5
102925: PPUSH
102926: CALL 104133 0 5
102930: GO 103053
102932: LD_INT 302
102934: DOUBLE
102935: EQUAL
102936: IFTRUE 102940
102938: GO 102977
102940: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102941: LD_VAR 0 6
102945: PPUSH
102946: LD_VAR 0 7
102950: PPUSH
102951: LD_VAR 0 8
102955: PPUSH
102956: LD_VAR 0 9
102960: PPUSH
102961: LD_VAR 0 4
102965: PPUSH
102966: LD_VAR 0 5
102970: PPUSH
102971: CALL 104224 0 6
102975: GO 103053
102977: LD_INT 303
102979: DOUBLE
102980: EQUAL
102981: IFTRUE 102985
102983: GO 103022
102985: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102986: LD_VAR 0 6
102990: PPUSH
102991: LD_VAR 0 7
102995: PPUSH
102996: LD_VAR 0 8
103000: PPUSH
103001: LD_VAR 0 9
103005: PPUSH
103006: LD_VAR 0 4
103010: PPUSH
103011: LD_VAR 0 5
103015: PPUSH
103016: CALL 103058 0 6
103020: GO 103053
103022: LD_INT 304
103024: DOUBLE
103025: EQUAL
103026: IFTRUE 103030
103028: GO 103052
103030: POP
// hHackTeleport ( unit , x , y ) ; end ;
103031: LD_VAR 0 2
103035: PPUSH
103036: LD_VAR 0 4
103040: PPUSH
103041: LD_VAR 0 5
103045: PPUSH
103046: CALL 104817 0 3
103050: GO 103053
103052: POP
// end ;
103053: LD_VAR 0 12
103057: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103058: LD_INT 0
103060: PPUSH
103061: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103062: LD_VAR 0 1
103066: PUSH
103067: LD_INT 1
103069: LESS
103070: PUSH
103071: LD_VAR 0 1
103075: PUSH
103076: LD_INT 3
103078: GREATER
103079: OR
103080: PUSH
103081: LD_VAR 0 5
103085: PPUSH
103086: LD_VAR 0 6
103090: PPUSH
103091: CALL_OW 428
103095: OR
103096: IFFALSE 103100
// exit ;
103098: GO 103820
// uc_side := your_side ;
103100: LD_ADDR_OWVAR 20
103104: PUSH
103105: LD_OWVAR 2
103109: ST_TO_ADDR
// uc_nation := nation ;
103110: LD_ADDR_OWVAR 21
103114: PUSH
103115: LD_VAR 0 1
103119: ST_TO_ADDR
// bc_level = 1 ;
103120: LD_ADDR_OWVAR 43
103124: PUSH
103125: LD_INT 1
103127: ST_TO_ADDR
// case btype of 1 :
103128: LD_VAR 0 2
103132: PUSH
103133: LD_INT 1
103135: DOUBLE
103136: EQUAL
103137: IFTRUE 103141
103139: GO 103152
103141: POP
// bc_type := b_depot ; 2 :
103142: LD_ADDR_OWVAR 42
103146: PUSH
103147: LD_INT 0
103149: ST_TO_ADDR
103150: GO 103764
103152: LD_INT 2
103154: DOUBLE
103155: EQUAL
103156: IFTRUE 103160
103158: GO 103171
103160: POP
// bc_type := b_warehouse ; 3 :
103161: LD_ADDR_OWVAR 42
103165: PUSH
103166: LD_INT 1
103168: ST_TO_ADDR
103169: GO 103764
103171: LD_INT 3
103173: DOUBLE
103174: EQUAL
103175: IFTRUE 103179
103177: GO 103190
103179: POP
// bc_type := b_lab ; 4 .. 9 :
103180: LD_ADDR_OWVAR 42
103184: PUSH
103185: LD_INT 6
103187: ST_TO_ADDR
103188: GO 103764
103190: LD_INT 4
103192: DOUBLE
103193: GREATEREQUAL
103194: IFFALSE 103202
103196: LD_INT 9
103198: DOUBLE
103199: LESSEQUAL
103200: IFTRUE 103204
103202: GO 103256
103204: POP
// begin bc_type := b_lab_half ;
103205: LD_ADDR_OWVAR 42
103209: PUSH
103210: LD_INT 7
103212: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103213: LD_ADDR_OWVAR 44
103217: PUSH
103218: LD_INT 10
103220: PUSH
103221: LD_INT 11
103223: PUSH
103224: LD_INT 12
103226: PUSH
103227: LD_INT 15
103229: PUSH
103230: LD_INT 14
103232: PUSH
103233: LD_INT 13
103235: PUSH
103236: EMPTY
103237: LIST
103238: LIST
103239: LIST
103240: LIST
103241: LIST
103242: LIST
103243: PUSH
103244: LD_VAR 0 2
103248: PUSH
103249: LD_INT 3
103251: MINUS
103252: ARRAY
103253: ST_TO_ADDR
// end ; 10 .. 13 :
103254: GO 103764
103256: LD_INT 10
103258: DOUBLE
103259: GREATEREQUAL
103260: IFFALSE 103268
103262: LD_INT 13
103264: DOUBLE
103265: LESSEQUAL
103266: IFTRUE 103270
103268: GO 103347
103270: POP
// begin bc_type := b_lab_full ;
103271: LD_ADDR_OWVAR 42
103275: PUSH
103276: LD_INT 8
103278: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103279: LD_ADDR_OWVAR 44
103283: PUSH
103284: LD_INT 10
103286: PUSH
103287: LD_INT 12
103289: PUSH
103290: LD_INT 14
103292: PUSH
103293: LD_INT 13
103295: PUSH
103296: EMPTY
103297: LIST
103298: LIST
103299: LIST
103300: LIST
103301: PUSH
103302: LD_VAR 0 2
103306: PUSH
103307: LD_INT 9
103309: MINUS
103310: ARRAY
103311: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103312: LD_ADDR_OWVAR 45
103316: PUSH
103317: LD_INT 11
103319: PUSH
103320: LD_INT 15
103322: PUSH
103323: LD_INT 12
103325: PUSH
103326: LD_INT 15
103328: PUSH
103329: EMPTY
103330: LIST
103331: LIST
103332: LIST
103333: LIST
103334: PUSH
103335: LD_VAR 0 2
103339: PUSH
103340: LD_INT 9
103342: MINUS
103343: ARRAY
103344: ST_TO_ADDR
// end ; 14 :
103345: GO 103764
103347: LD_INT 14
103349: DOUBLE
103350: EQUAL
103351: IFTRUE 103355
103353: GO 103366
103355: POP
// bc_type := b_workshop ; 15 :
103356: LD_ADDR_OWVAR 42
103360: PUSH
103361: LD_INT 2
103363: ST_TO_ADDR
103364: GO 103764
103366: LD_INT 15
103368: DOUBLE
103369: EQUAL
103370: IFTRUE 103374
103372: GO 103385
103374: POP
// bc_type := b_factory ; 16 :
103375: LD_ADDR_OWVAR 42
103379: PUSH
103380: LD_INT 3
103382: ST_TO_ADDR
103383: GO 103764
103385: LD_INT 16
103387: DOUBLE
103388: EQUAL
103389: IFTRUE 103393
103391: GO 103404
103393: POP
// bc_type := b_ext_gun ; 17 :
103394: LD_ADDR_OWVAR 42
103398: PUSH
103399: LD_INT 17
103401: ST_TO_ADDR
103402: GO 103764
103404: LD_INT 17
103406: DOUBLE
103407: EQUAL
103408: IFTRUE 103412
103410: GO 103440
103412: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103413: LD_ADDR_OWVAR 42
103417: PUSH
103418: LD_INT 19
103420: PUSH
103421: LD_INT 23
103423: PUSH
103424: LD_INT 19
103426: PUSH
103427: EMPTY
103428: LIST
103429: LIST
103430: LIST
103431: PUSH
103432: LD_VAR 0 1
103436: ARRAY
103437: ST_TO_ADDR
103438: GO 103764
103440: LD_INT 18
103442: DOUBLE
103443: EQUAL
103444: IFTRUE 103448
103446: GO 103459
103448: POP
// bc_type := b_ext_radar ; 19 :
103449: LD_ADDR_OWVAR 42
103453: PUSH
103454: LD_INT 20
103456: ST_TO_ADDR
103457: GO 103764
103459: LD_INT 19
103461: DOUBLE
103462: EQUAL
103463: IFTRUE 103467
103465: GO 103478
103467: POP
// bc_type := b_ext_radio ; 20 :
103468: LD_ADDR_OWVAR 42
103472: PUSH
103473: LD_INT 22
103475: ST_TO_ADDR
103476: GO 103764
103478: LD_INT 20
103480: DOUBLE
103481: EQUAL
103482: IFTRUE 103486
103484: GO 103497
103486: POP
// bc_type := b_ext_siberium ; 21 :
103487: LD_ADDR_OWVAR 42
103491: PUSH
103492: LD_INT 21
103494: ST_TO_ADDR
103495: GO 103764
103497: LD_INT 21
103499: DOUBLE
103500: EQUAL
103501: IFTRUE 103505
103503: GO 103516
103505: POP
// bc_type := b_ext_computer ; 22 :
103506: LD_ADDR_OWVAR 42
103510: PUSH
103511: LD_INT 24
103513: ST_TO_ADDR
103514: GO 103764
103516: LD_INT 22
103518: DOUBLE
103519: EQUAL
103520: IFTRUE 103524
103522: GO 103535
103524: POP
// bc_type := b_ext_track ; 23 :
103525: LD_ADDR_OWVAR 42
103529: PUSH
103530: LD_INT 16
103532: ST_TO_ADDR
103533: GO 103764
103535: LD_INT 23
103537: DOUBLE
103538: EQUAL
103539: IFTRUE 103543
103541: GO 103554
103543: POP
// bc_type := b_ext_laser ; 24 :
103544: LD_ADDR_OWVAR 42
103548: PUSH
103549: LD_INT 25
103551: ST_TO_ADDR
103552: GO 103764
103554: LD_INT 24
103556: DOUBLE
103557: EQUAL
103558: IFTRUE 103562
103560: GO 103573
103562: POP
// bc_type := b_control_tower ; 25 :
103563: LD_ADDR_OWVAR 42
103567: PUSH
103568: LD_INT 36
103570: ST_TO_ADDR
103571: GO 103764
103573: LD_INT 25
103575: DOUBLE
103576: EQUAL
103577: IFTRUE 103581
103579: GO 103592
103581: POP
// bc_type := b_breastwork ; 26 :
103582: LD_ADDR_OWVAR 42
103586: PUSH
103587: LD_INT 31
103589: ST_TO_ADDR
103590: GO 103764
103592: LD_INT 26
103594: DOUBLE
103595: EQUAL
103596: IFTRUE 103600
103598: GO 103611
103600: POP
// bc_type := b_bunker ; 27 :
103601: LD_ADDR_OWVAR 42
103605: PUSH
103606: LD_INT 32
103608: ST_TO_ADDR
103609: GO 103764
103611: LD_INT 27
103613: DOUBLE
103614: EQUAL
103615: IFTRUE 103619
103617: GO 103630
103619: POP
// bc_type := b_turret ; 28 :
103620: LD_ADDR_OWVAR 42
103624: PUSH
103625: LD_INT 33
103627: ST_TO_ADDR
103628: GO 103764
103630: LD_INT 28
103632: DOUBLE
103633: EQUAL
103634: IFTRUE 103638
103636: GO 103649
103638: POP
// bc_type := b_armoury ; 29 :
103639: LD_ADDR_OWVAR 42
103643: PUSH
103644: LD_INT 4
103646: ST_TO_ADDR
103647: GO 103764
103649: LD_INT 29
103651: DOUBLE
103652: EQUAL
103653: IFTRUE 103657
103655: GO 103668
103657: POP
// bc_type := b_barracks ; 30 :
103658: LD_ADDR_OWVAR 42
103662: PUSH
103663: LD_INT 5
103665: ST_TO_ADDR
103666: GO 103764
103668: LD_INT 30
103670: DOUBLE
103671: EQUAL
103672: IFTRUE 103676
103674: GO 103687
103676: POP
// bc_type := b_solar_power ; 31 :
103677: LD_ADDR_OWVAR 42
103681: PUSH
103682: LD_INT 27
103684: ST_TO_ADDR
103685: GO 103764
103687: LD_INT 31
103689: DOUBLE
103690: EQUAL
103691: IFTRUE 103695
103693: GO 103706
103695: POP
// bc_type := b_oil_power ; 32 :
103696: LD_ADDR_OWVAR 42
103700: PUSH
103701: LD_INT 26
103703: ST_TO_ADDR
103704: GO 103764
103706: LD_INT 32
103708: DOUBLE
103709: EQUAL
103710: IFTRUE 103714
103712: GO 103725
103714: POP
// bc_type := b_siberite_power ; 33 :
103715: LD_ADDR_OWVAR 42
103719: PUSH
103720: LD_INT 28
103722: ST_TO_ADDR
103723: GO 103764
103725: LD_INT 33
103727: DOUBLE
103728: EQUAL
103729: IFTRUE 103733
103731: GO 103744
103733: POP
// bc_type := b_oil_mine ; 34 :
103734: LD_ADDR_OWVAR 42
103738: PUSH
103739: LD_INT 29
103741: ST_TO_ADDR
103742: GO 103764
103744: LD_INT 34
103746: DOUBLE
103747: EQUAL
103748: IFTRUE 103752
103750: GO 103763
103752: POP
// bc_type := b_siberite_mine ; end ;
103753: LD_ADDR_OWVAR 42
103757: PUSH
103758: LD_INT 30
103760: ST_TO_ADDR
103761: GO 103764
103763: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103764: LD_ADDR_VAR 0 8
103768: PUSH
103769: LD_VAR 0 5
103773: PPUSH
103774: LD_VAR 0 6
103778: PPUSH
103779: LD_VAR 0 3
103783: PPUSH
103784: CALL_OW 47
103788: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103789: LD_OWVAR 42
103793: PUSH
103794: LD_INT 32
103796: PUSH
103797: LD_INT 33
103799: PUSH
103800: EMPTY
103801: LIST
103802: LIST
103803: IN
103804: IFFALSE 103820
// PlaceWeaponTurret ( b , weapon ) ;
103806: LD_VAR 0 8
103810: PPUSH
103811: LD_VAR 0 4
103815: PPUSH
103816: CALL_OW 431
// end ;
103820: LD_VAR 0 7
103824: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103825: LD_INT 0
103827: PPUSH
103828: PPUSH
103829: PPUSH
103830: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103831: LD_ADDR_VAR 0 4
103835: PUSH
103836: LD_INT 22
103838: PUSH
103839: LD_OWVAR 2
103843: PUSH
103844: EMPTY
103845: LIST
103846: LIST
103847: PUSH
103848: LD_INT 2
103850: PUSH
103851: LD_INT 30
103853: PUSH
103854: LD_INT 0
103856: PUSH
103857: EMPTY
103858: LIST
103859: LIST
103860: PUSH
103861: LD_INT 30
103863: PUSH
103864: LD_INT 1
103866: PUSH
103867: EMPTY
103868: LIST
103869: LIST
103870: PUSH
103871: EMPTY
103872: LIST
103873: LIST
103874: LIST
103875: PUSH
103876: EMPTY
103877: LIST
103878: LIST
103879: PPUSH
103880: CALL_OW 69
103884: ST_TO_ADDR
// if not tmp then
103885: LD_VAR 0 4
103889: NOT
103890: IFFALSE 103894
// exit ;
103892: GO 103953
// for i in tmp do
103894: LD_ADDR_VAR 0 2
103898: PUSH
103899: LD_VAR 0 4
103903: PUSH
103904: FOR_IN
103905: IFFALSE 103951
// for j = 1 to 3 do
103907: LD_ADDR_VAR 0 3
103911: PUSH
103912: DOUBLE
103913: LD_INT 1
103915: DEC
103916: ST_TO_ADDR
103917: LD_INT 3
103919: PUSH
103920: FOR_TO
103921: IFFALSE 103947
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103923: LD_VAR 0 2
103927: PPUSH
103928: CALL_OW 274
103932: PPUSH
103933: LD_VAR 0 3
103937: PPUSH
103938: LD_INT 99999
103940: PPUSH
103941: CALL_OW 277
103945: GO 103920
103947: POP
103948: POP
103949: GO 103904
103951: POP
103952: POP
// end ;
103953: LD_VAR 0 1
103957: RET
// export function hHackSetLevel10 ; var i , j ; begin
103958: LD_INT 0
103960: PPUSH
103961: PPUSH
103962: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103963: LD_ADDR_VAR 0 2
103967: PUSH
103968: LD_INT 21
103970: PUSH
103971: LD_INT 1
103973: PUSH
103974: EMPTY
103975: LIST
103976: LIST
103977: PPUSH
103978: CALL_OW 69
103982: PUSH
103983: FOR_IN
103984: IFFALSE 104036
// if IsSelected ( i ) then
103986: LD_VAR 0 2
103990: PPUSH
103991: CALL_OW 306
103995: IFFALSE 104034
// begin for j := 1 to 4 do
103997: LD_ADDR_VAR 0 3
104001: PUSH
104002: DOUBLE
104003: LD_INT 1
104005: DEC
104006: ST_TO_ADDR
104007: LD_INT 4
104009: PUSH
104010: FOR_TO
104011: IFFALSE 104032
// SetSkill ( i , j , 10 ) ;
104013: LD_VAR 0 2
104017: PPUSH
104018: LD_VAR 0 3
104022: PPUSH
104023: LD_INT 10
104025: PPUSH
104026: CALL_OW 237
104030: GO 104010
104032: POP
104033: POP
// end ;
104034: GO 103983
104036: POP
104037: POP
// end ;
104038: LD_VAR 0 1
104042: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104043: LD_INT 0
104045: PPUSH
104046: PPUSH
104047: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104048: LD_ADDR_VAR 0 2
104052: PUSH
104053: LD_INT 22
104055: PUSH
104056: LD_OWVAR 2
104060: PUSH
104061: EMPTY
104062: LIST
104063: LIST
104064: PUSH
104065: LD_INT 21
104067: PUSH
104068: LD_INT 1
104070: PUSH
104071: EMPTY
104072: LIST
104073: LIST
104074: PUSH
104075: EMPTY
104076: LIST
104077: LIST
104078: PPUSH
104079: CALL_OW 69
104083: PUSH
104084: FOR_IN
104085: IFFALSE 104126
// begin for j := 1 to 4 do
104087: LD_ADDR_VAR 0 3
104091: PUSH
104092: DOUBLE
104093: LD_INT 1
104095: DEC
104096: ST_TO_ADDR
104097: LD_INT 4
104099: PUSH
104100: FOR_TO
104101: IFFALSE 104122
// SetSkill ( i , j , 10 ) ;
104103: LD_VAR 0 2
104107: PPUSH
104108: LD_VAR 0 3
104112: PPUSH
104113: LD_INT 10
104115: PPUSH
104116: CALL_OW 237
104120: GO 104100
104122: POP
104123: POP
// end ;
104124: GO 104084
104126: POP
104127: POP
// end ;
104128: LD_VAR 0 1
104132: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104133: LD_INT 0
104135: PPUSH
// uc_side := your_side ;
104136: LD_ADDR_OWVAR 20
104140: PUSH
104141: LD_OWVAR 2
104145: ST_TO_ADDR
// uc_nation := nation ;
104146: LD_ADDR_OWVAR 21
104150: PUSH
104151: LD_VAR 0 1
104155: ST_TO_ADDR
// InitHc ;
104156: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104160: LD_INT 0
104162: PPUSH
104163: LD_VAR 0 2
104167: PPUSH
104168: LD_VAR 0 3
104172: PPUSH
104173: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104177: LD_VAR 0 4
104181: PPUSH
104182: LD_VAR 0 5
104186: PPUSH
104187: CALL_OW 428
104191: PUSH
104192: LD_INT 0
104194: EQUAL
104195: IFFALSE 104219
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104197: CALL_OW 44
104201: PPUSH
104202: LD_VAR 0 4
104206: PPUSH
104207: LD_VAR 0 5
104211: PPUSH
104212: LD_INT 1
104214: PPUSH
104215: CALL_OW 48
// end ;
104219: LD_VAR 0 6
104223: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104224: LD_INT 0
104226: PPUSH
104227: PPUSH
// uc_side := your_side ;
104228: LD_ADDR_OWVAR 20
104232: PUSH
104233: LD_OWVAR 2
104237: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104238: LD_VAR 0 1
104242: PUSH
104243: LD_INT 1
104245: PUSH
104246: LD_INT 2
104248: PUSH
104249: LD_INT 3
104251: PUSH
104252: LD_INT 4
104254: PUSH
104255: LD_INT 5
104257: PUSH
104258: EMPTY
104259: LIST
104260: LIST
104261: LIST
104262: LIST
104263: LIST
104264: IN
104265: IFFALSE 104277
// uc_nation := nation_american else
104267: LD_ADDR_OWVAR 21
104271: PUSH
104272: LD_INT 1
104274: ST_TO_ADDR
104275: GO 104320
// if chassis in [ 11 , 12 , 13 , 14 ] then
104277: LD_VAR 0 1
104281: PUSH
104282: LD_INT 11
104284: PUSH
104285: LD_INT 12
104287: PUSH
104288: LD_INT 13
104290: PUSH
104291: LD_INT 14
104293: PUSH
104294: EMPTY
104295: LIST
104296: LIST
104297: LIST
104298: LIST
104299: IN
104300: IFFALSE 104312
// uc_nation := nation_arabian else
104302: LD_ADDR_OWVAR 21
104306: PUSH
104307: LD_INT 2
104309: ST_TO_ADDR
104310: GO 104320
// uc_nation := nation_russian ;
104312: LD_ADDR_OWVAR 21
104316: PUSH
104317: LD_INT 3
104319: ST_TO_ADDR
// vc_chassis := chassis ;
104320: LD_ADDR_OWVAR 37
104324: PUSH
104325: LD_VAR 0 1
104329: ST_TO_ADDR
// vc_engine := engine ;
104330: LD_ADDR_OWVAR 39
104334: PUSH
104335: LD_VAR 0 2
104339: ST_TO_ADDR
// vc_control := control ;
104340: LD_ADDR_OWVAR 38
104344: PUSH
104345: LD_VAR 0 3
104349: ST_TO_ADDR
// vc_weapon := weapon ;
104350: LD_ADDR_OWVAR 40
104354: PUSH
104355: LD_VAR 0 4
104359: ST_TO_ADDR
// un := CreateVehicle ;
104360: LD_ADDR_VAR 0 8
104364: PUSH
104365: CALL_OW 45
104369: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104370: LD_VAR 0 8
104374: PPUSH
104375: LD_INT 0
104377: PPUSH
104378: LD_INT 5
104380: PPUSH
104381: CALL_OW 12
104385: PPUSH
104386: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104390: LD_VAR 0 8
104394: PPUSH
104395: LD_VAR 0 5
104399: PPUSH
104400: LD_VAR 0 6
104404: PPUSH
104405: LD_INT 1
104407: PPUSH
104408: CALL_OW 48
// end ;
104412: LD_VAR 0 7
104416: RET
// export hInvincible ; every 1 do
104417: GO 104419
104419: DISABLE
// hInvincible := [ ] ;
104420: LD_ADDR_EXP 152
104424: PUSH
104425: EMPTY
104426: ST_TO_ADDR
104427: END
// every 10 do var i ;
104428: GO 104430
104430: DISABLE
104431: LD_INT 0
104433: PPUSH
// begin enable ;
104434: ENABLE
// if not hInvincible then
104435: LD_EXP 152
104439: NOT
104440: IFFALSE 104444
// exit ;
104442: GO 104488
// for i in hInvincible do
104444: LD_ADDR_VAR 0 1
104448: PUSH
104449: LD_EXP 152
104453: PUSH
104454: FOR_IN
104455: IFFALSE 104486
// if GetLives ( i ) < 1000 then
104457: LD_VAR 0 1
104461: PPUSH
104462: CALL_OW 256
104466: PUSH
104467: LD_INT 1000
104469: LESS
104470: IFFALSE 104484
// SetLives ( i , 1000 ) ;
104472: LD_VAR 0 1
104476: PPUSH
104477: LD_INT 1000
104479: PPUSH
104480: CALL_OW 234
104484: GO 104454
104486: POP
104487: POP
// end ;
104488: PPOPN 1
104490: END
// export function hHackInvincible ; var i ; begin
104491: LD_INT 0
104493: PPUSH
104494: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104495: LD_ADDR_VAR 0 2
104499: PUSH
104500: LD_INT 2
104502: PUSH
104503: LD_INT 21
104505: PUSH
104506: LD_INT 1
104508: PUSH
104509: EMPTY
104510: LIST
104511: LIST
104512: PUSH
104513: LD_INT 21
104515: PUSH
104516: LD_INT 2
104518: PUSH
104519: EMPTY
104520: LIST
104521: LIST
104522: PUSH
104523: EMPTY
104524: LIST
104525: LIST
104526: LIST
104527: PPUSH
104528: CALL_OW 69
104532: PUSH
104533: FOR_IN
104534: IFFALSE 104595
// if IsSelected ( i ) then
104536: LD_VAR 0 2
104540: PPUSH
104541: CALL_OW 306
104545: IFFALSE 104593
// begin if i in hInvincible then
104547: LD_VAR 0 2
104551: PUSH
104552: LD_EXP 152
104556: IN
104557: IFFALSE 104577
// hInvincible := hInvincible diff i else
104559: LD_ADDR_EXP 152
104563: PUSH
104564: LD_EXP 152
104568: PUSH
104569: LD_VAR 0 2
104573: DIFF
104574: ST_TO_ADDR
104575: GO 104593
// hInvincible := hInvincible union i ;
104577: LD_ADDR_EXP 152
104581: PUSH
104582: LD_EXP 152
104586: PUSH
104587: LD_VAR 0 2
104591: UNION
104592: ST_TO_ADDR
// end ;
104593: GO 104533
104595: POP
104596: POP
// end ;
104597: LD_VAR 0 1
104601: RET
// export function hHackInvisible ; var i , j ; begin
104602: LD_INT 0
104604: PPUSH
104605: PPUSH
104606: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104607: LD_ADDR_VAR 0 2
104611: PUSH
104612: LD_INT 21
104614: PUSH
104615: LD_INT 1
104617: PUSH
104618: EMPTY
104619: LIST
104620: LIST
104621: PPUSH
104622: CALL_OW 69
104626: PUSH
104627: FOR_IN
104628: IFFALSE 104652
// if IsSelected ( i ) then
104630: LD_VAR 0 2
104634: PPUSH
104635: CALL_OW 306
104639: IFFALSE 104650
// ComForceInvisible ( i ) ;
104641: LD_VAR 0 2
104645: PPUSH
104646: CALL_OW 496
104650: GO 104627
104652: POP
104653: POP
// end ;
104654: LD_VAR 0 1
104658: RET
// export function hHackChangeYourSide ; begin
104659: LD_INT 0
104661: PPUSH
// if your_side = 8 then
104662: LD_OWVAR 2
104666: PUSH
104667: LD_INT 8
104669: EQUAL
104670: IFFALSE 104682
// your_side := 0 else
104672: LD_ADDR_OWVAR 2
104676: PUSH
104677: LD_INT 0
104679: ST_TO_ADDR
104680: GO 104696
// your_side := your_side + 1 ;
104682: LD_ADDR_OWVAR 2
104686: PUSH
104687: LD_OWVAR 2
104691: PUSH
104692: LD_INT 1
104694: PLUS
104695: ST_TO_ADDR
// end ;
104696: LD_VAR 0 1
104700: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104701: LD_INT 0
104703: PPUSH
104704: PPUSH
104705: PPUSH
// for i in all_units do
104706: LD_ADDR_VAR 0 2
104710: PUSH
104711: LD_OWVAR 3
104715: PUSH
104716: FOR_IN
104717: IFFALSE 104795
// if IsSelected ( i ) then
104719: LD_VAR 0 2
104723: PPUSH
104724: CALL_OW 306
104728: IFFALSE 104793
// begin j := GetSide ( i ) ;
104730: LD_ADDR_VAR 0 3
104734: PUSH
104735: LD_VAR 0 2
104739: PPUSH
104740: CALL_OW 255
104744: ST_TO_ADDR
// if j = 8 then
104745: LD_VAR 0 3
104749: PUSH
104750: LD_INT 8
104752: EQUAL
104753: IFFALSE 104765
// j := 0 else
104755: LD_ADDR_VAR 0 3
104759: PUSH
104760: LD_INT 0
104762: ST_TO_ADDR
104763: GO 104779
// j := j + 1 ;
104765: LD_ADDR_VAR 0 3
104769: PUSH
104770: LD_VAR 0 3
104774: PUSH
104775: LD_INT 1
104777: PLUS
104778: ST_TO_ADDR
// SetSide ( i , j ) ;
104779: LD_VAR 0 2
104783: PPUSH
104784: LD_VAR 0 3
104788: PPUSH
104789: CALL_OW 235
// end ;
104793: GO 104716
104795: POP
104796: POP
// end ;
104797: LD_VAR 0 1
104801: RET
// export function hHackFog ; begin
104802: LD_INT 0
104804: PPUSH
// FogOff ( true ) ;
104805: LD_INT 1
104807: PPUSH
104808: CALL_OW 344
// end ;
104812: LD_VAR 0 1
104816: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104817: LD_INT 0
104819: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104820: LD_VAR 0 1
104824: PPUSH
104825: LD_VAR 0 2
104829: PPUSH
104830: LD_VAR 0 3
104834: PPUSH
104835: LD_INT 1
104837: PPUSH
104838: LD_INT 1
104840: PPUSH
104841: CALL_OW 483
// CenterOnXY ( x , y ) ;
104845: LD_VAR 0 2
104849: PPUSH
104850: LD_VAR 0 3
104854: PPUSH
104855: CALL_OW 84
// end ; end_of_file
104859: LD_VAR 0 4
104863: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
104864: LD_VAR 0 1
104868: PPUSH
104869: LD_VAR 0 2
104873: PPUSH
104874: LD_VAR 0 3
104878: PPUSH
104879: LD_VAR 0 4
104883: PPUSH
104884: LD_VAR 0 5
104888: PPUSH
104889: LD_VAR 0 6
104893: PPUSH
104894: CALL 91692 0 6
// end ;
104898: PPOPN 6
104900: END
